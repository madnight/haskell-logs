00:01:24 <hpaste>  (anonymous) annotated "control stack overflow" with "(no title)" at http://hpaste.org/3001#a1
00:05:06 <scodil> it seems like it should be easy: you've got a list of types like `C Int (C Float (C Bool ()))` and there's a class `Find a b c | a -> b` which ideally would have a base-case instance like `Find a (C a b)`, and an inductive instance like `Find a c => Find a (C b c)` but these overlap because a can be equal to b in the second instance
00:05:35 <scodil> er, i messed that up
00:05:42 <scodil> class Find a b | a -> b
00:06:39 <scodil> If it was a subset of types I was dealing with, like the natural numbers, I could define a NotEqual predicate class
00:11:14 <scodil> oh woops. that works. forgot to turn on overlapping instances
00:11:34 <scodil> what is the rule? how does it decide which instance to use?
00:11:43 <Cale> It's kind of confusing :)
00:12:00 <Cale> There's some way in which it decides which rule is more specific
00:12:17 <scodil> oh ok. as long as its not something stupid like it takes the top-most one in the file
00:13:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#instance-overlap
00:13:35 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
00:14:04 <Cale> It's an error for the thing to actually match more than one.
00:14:18 <Cale> apparently
00:14:48 <Cale> er, oh, it was talking in general there, right
00:15:00 <omniscientIdiot> you mean if there's more than one instance with the same specificity?
00:15:11 <Cale> Yeah, that's right.
00:15:47 <Cale> Without -fallow-overlapping-instances, it's an error regardless if more than one instance matches the constraint
00:16:24 <omniscientIdiot> is this caught when the compiler tries to compile the instances themselves, or on overload resolution?
00:16:26 <Cale> With -fallow-overlapping-instances, it's only an error only if there isn't a most specific instance which matches.
00:16:51 <Cale> Only on resolution. It's okay for instances to potentially overlap.
00:17:41 <narain> ?index unfoldr
00:17:41 <lambdabot> Data.List
00:18:02 <Cale> Then there's -fallow-incoherent-instances, but that's completely evil and broken.
00:18:43 <omniscientIdiot> incoherent, even.
00:19:45 <Cale> That will allow a polymorphic instance to apply in a polymorphic context, even though later on those type variables might get specified to something more specific which would match a different instance.
00:20:45 <Cale> It's possible to break referential transparency with -fallow-incoherent-instances and ST.
00:20:54 <duryodhan222> doserj: thanks a lot .... is there any place I could see how the compiler will parse what I write ?
00:21:40 <Cale> Oh, and Dynamic too.
00:22:23 <Cale> The trick is to write a generic instance of Typeable which applies to anything.
00:23:12 <LeCamarade> Is there an RTF lib for Haskell?
00:23:20 <LeCamarade> Rich Text Format, that is.
00:23:48 <duryodhan222> doserj: the code you put in doesn't work ... I don't know why ... cos I don't know maps etc.
00:24:03 <Cale> hmm, a google search came up with http://johnmacfarlane.net/pandoc/ which I didn't even know about
00:24:50 <Cale> http://johnmacfarlane.net/pandoc/doc/index.html
00:25:08 <Cale> It doesn't have an RTF reader though
00:25:08 <LeCamarade> Yeah, Pandoc. :o)
00:25:22 <LeCamarade> :-o
00:25:39 <Cale> (only a writer)
00:26:13 <LeCamarade> Um ... I will need to read.
00:26:44 <LeCamarade> To read into a structure that is manipulable. It's what I'm going to be using to manage my blog entries.
00:27:05 <Cale> RTF?
00:27:16 <Cale> Pandoc can read markdown
00:28:54 <LeCamarade> Well, I want to be using a number of formats, RTF being one (because I want to enable well-formatted coments right out of the word processor for people who aren't into learning a twentieth format language).
00:32:07 <Cale> Oh, apparently I *should* have known about Pandoc, given that I modded it up on reddit ;)
00:34:14 <LeCamarade> :o)
00:34:52 <Cale> Probably adding RTF reading support to Pandoc would be easier than starting from scratch, since it already has a nice datatype for storing structured formatted text.
00:53:18 <narain> i want to check if a value matches a given constructor. is there anything more succinct than (\x -> case x of Foo _ -> True; _ -> False)?
00:54:04 <narain> oh wait, i'll just move that out to where clause
00:54:09 <narain> never mind
00:55:10 <bakert> :t lookM
00:55:16 <lambdabot> Not in scope: `lookM'
00:55:23 <bakert> ?hoogle lookM
00:55:23 <lambdabot> No matches found
00:55:39 <bakert> :t lookMb
00:55:41 <lambdabot> Not in scope: `lookMb'
00:55:47 <bakert> ?hoogle lookMb
00:55:47 <lambdabot> No matches found
00:55:50 <bakert> :(
00:56:01 <bakert> :t readM
00:56:03 <lambdabot> Not in scope: `readM'
00:56:09 <bakert> @hoogle readM
00:56:09 <lambdabot> Control.Concurrent.MVar.readMVar :: MVar a -> IO a
00:56:10 <lambdabot> System.IO.ReadMode :: IOMode
00:56:10 <lambdabot> Data.Graph.Inductive.Internal.Thread.threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
00:56:26 <Cale> :t readIO
00:56:28 <lambdabot> forall a. (Read a) => String -> IO a
00:56:38 <fax> I'm sure there was a way to get an values Constructor from the value itself
00:57:28 <Cale> fax: yeah, Data.Generics will let you get a representation of the constructor
00:57:36 <Cale> using toConstr
00:58:01 <fax> ah cool thanks
00:58:20 <Cale> and then you can use constrRep on that to get a properly observable representation
00:58:23 <omniscientIdiot> @type \s -> case reads s of [(x,"")] -> return x; _ -> mzero
00:58:25 <lambdabot> forall a (m :: * -> *). (Read a, MonadPlus m) => String -> m a
00:58:43 <edwardk> @type toContr
00:58:45 <lambdabot> Not in scope: `toContr'
00:58:45 <edwardk> er
00:58:47 <Cale> fax: However, it's kinda unusual
00:58:48 <edwardk> @type toConstr
00:58:50 <lambdabot> Not in scope: `toConstr'
00:58:55 <phlpp> morning
00:58:56 <phlpp> :>
00:58:58 <Cale> fax: Usually you just pattern match with case or something :)
00:59:00 <edwardk> @type Data.Generics.toConstr
00:59:02 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> Data.Generics.Basics.Constr
00:59:51 <edwardk> > Data.Generics.toConstr (Just 12)
00:59:52 <lambdabot>  Just
01:00:40 <edwardk> its eq comparable, so i guess you could save it then compare against it ;)
01:01:11 <omniscientIdiot> let just = toConstr (Just ())
01:01:31 <omniscientIdiot> toConstr val == just
01:01:52 <Cale> :t isJust
01:01:55 <lambdabot> forall a. Maybe a -> Bool
01:02:03 <omniscientIdiot> :P
01:02:07 <Cale> But that's no fun :)
01:02:22 <edwardk> > ((==) `on` Data.Generics.toConstr) (Just ()) (Just 12)
01:02:23 <lambdabot>   Not in scope: `on'
01:02:28 <edwardk> @src on
01:02:28 <lambdabot> (*) `on` f = \x y -> f x * f y
01:02:34 <Cale> heh
01:02:38 <omniscientIdiot> @let on f g x y = f (g x) (g y)
01:02:44 <lambdabot> Defined.
01:02:53 <edwardk> > ((==) `on` Data.Generics.toConstr) (Just ()) (Just 12)
01:02:54 <lambdabot>   add an instance declaration for (Num ())
01:03:02 <edwardk> oh well
01:03:21 <edwardk> heh, on isn't very nice in terms of polymorphism in that case
01:04:02 <omniscientIdiot> > ((==) `on` (Data.Generics.toConstr :: forall a. (Data.Generics.Basics.Data a) => a -> Data.Generics.Basics.Constr)) (Just ()) (Just 12)
01:04:02 <lambdabot>  Parse error
01:05:28 <omniscientIdiot> > () :: forall a. a
01:05:28 <lambdabot>  Parse error
01:05:51 <omniscientIdiot> no rank-n for me
01:05:59 <edwardk> @pl \x -> toConstr x == toConst (Just undefined)
01:05:59 <lambdabot> (toConst (Just undefined) ==) . toConstr
01:06:28 * Cale wants a new Catsters video
01:06:30 <fax> @index Error
01:06:30 <lambdabot> Control.Monad.Error, Graphics.Rendering.OpenGL.GLU.Errors, Graphics.Rendering.OpenGL.GLU, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Graphics.Rendering.OpenGL.GLU.Errors, Graphics.Rendering.OpenGL.
01:06:30 <lambdabot> GLU, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
01:06:30 <edwardk> > ((toConst (Just undefined) ==) . toConstr) (Just 12)
01:06:31 <lambdabot>   Not in scope: `toConstr'
01:06:31 <omniscientIdiot>  @pl \x -> toConstr x == toConstr (Just undefined)
01:06:37 <omniscientIdiot> @pl \x -> toConstr x == toConstr (Just undefined)
01:06:37 <lambdabot> (toConstr (Just undefined) ==) . toConstr
01:06:56 <edwardk> > ((Data.Generics.toConst (Just undefined) ==) . Data.Generics.toConstr) (Just 12)
01:06:57 <lambdabot>   Not in scope: `Data.Generics.toConst'
01:07:09 <edwardk> > ((Data.Generics.toConstr (Just undefined) ==) . Data.Generics.toConstr) (Just 12)
01:07:09 <lambdabot>  Add a type signature
01:07:17 <edwardk> heh
01:07:29 <edwardk> > ((Data.Generics.toConstr (Just ()) ==) . Data.Generics.toConstr) (Just 12)
01:07:30 <lambdabot>  True
01:07:44 <edwardk> > ((Data.Generics.toConstr (Just ()) ==) . Data.Generics.toConstr) Nothing
01:07:45 <lambdabot>  Add a type signature
01:08:02 <edwardk> > ((Data.Generics.toConstr (Just ()) ==) . Data.Generics.toConstr) (Nothing :: Maybe Int)
01:08:04 <lambdabot>  False
01:09:24 <edwardk> @pl \x -> toConstr (Just ()) == toConstr x
01:09:24 <lambdabot> (toConstr Just ==) . toConstr
01:10:06 <fax> Why does parsec not come with something like,
01:10:06 <fax> instance Error ParseError where strMsg str = newErrorMessage (Message str) (newPos "" 0 0)
01:10:23 <omniscientIdiot> @pl toConstr (Just ())
01:10:24 <lambdabot> toConstr Just
01:10:25 <fax> It's ok to do this?
01:10:27 <omniscientIdiot> uh oh!
01:10:31 <edwardk> ?
01:10:44 <edwardk> omniscientIdiot: yeah i was staring at that myself
01:11:02 <omniscientIdiot>  @pl doesn't know unit!
01:11:10 <edwardk> heh
01:11:42 <edwardk> @pl \x -> toConstr (Just []) == toConstr x
01:11:42 <lambdabot> (toConstr (Just []) ==) . toConstr
01:12:27 <edwardk> @pl \x -> ((),x)
01:12:27 <lambdabot> (,)
01:12:35 <edwardk> heh
01:12:54 <edwardk> @pl \x -> ()
01:12:54 <lambdabot> const ()
01:13:05 <edwardk> @pl \x -> ((),())
01:13:05 <lambdabot> const (,)
01:13:23 <edwardk> @pl \x -> Just ()
01:13:23 <lambdabot> const Just
01:13:31 <omniscientIdiot> @pl Just ()
01:13:31 <lambdabot> Just
01:13:50 <bakert> :t readsPrec
01:13:52 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
01:14:26 <bakert> @google readsPrec
01:14:28 <lambdabot> http://www.zvon.org/other/haskell/Outputprelude/readsPrec_f.html
01:14:28 <lambdabot> Title: Haskell : readsPrec
01:15:14 <omniscientIdiot> useful link...
01:15:18 <bakert> :(
01:15:42 <bakert> this is better:
01:15:43 <bakert> http://www.haskell.org/pipermail/haskell/2001-June/007442.html
01:15:44 <lambdabot> Title: Haskell report typo (bad law for readsPrec)
01:15:58 <bakert> has the haskell 98 description of readsPrec
01:16:30 <bakert> I still don't really understand what the Int is for though
01:16:35 <bakert> "precedence level"
01:17:47 <edwardk> bakert: think 2 * 3 + 4
01:18:00 <bakert> Ah.  merci edwardk
01:18:09 <edwardk> what precedence level are we at, so when should we 'pop out' of what we're reading
01:18:50 <bakert> hmm.  so i'm setting a precedence level for this operation "on the fly" or i'm describing the precedence level of various parsings that i may not do in precedence order?
01:19:28 <fax> Where can you find some bunch of algorithms using lists?
01:19:57 <bakert> ?hoogle List
01:19:57 <lambdabot> Control.Monad.List :: module
01:19:58 <lambdabot> Data.List :: module
01:19:58 <lambdabot> List :: module
01:20:00 <bakert> ???
01:20:04 <edwardk> iirc its the precedence of the environment you are reading in, anything that binds more loosely than that requires explicit parentheses kind of thing
01:20:25 <fax> ok yeah
01:20:28 <fax> probably ghc source code
01:20:45 <edwardk> i only really remember the showsPrec side of the coin =)
01:21:17 <bakert> thanks edwardk.  sadly that doesn't help me with my problem but at least i understand what it is trying to do a bit better :)
01:23:23 <fax> @src inits
01:23:24 <lambdabot> inits []     =  [[]]
01:23:24 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
01:23:33 <fax> Is this efficient?
01:24:46 <Cale> fax: as efficient as it can be
01:25:19 <Cale> well, it should use : instead of ++ there
01:25:59 <Cale> init itself is pretty costly, inits tends to behave a bit nicer.
01:26:09 <misterbeebee>  Is Edison still active and will it be usable with GHC 6.8?  Many of the links to Edison info are dead links.. it's hard to see if Edison is still alive or whether it is fully implemented yet. The latest activity seems to be 12/2006.  References: http://www.haskell.org/ghc/docs/edison/index.html  http://www.eecs.tufts.edu/~rdocki01/edison.html
01:26:10 <lambdabot> Title: Edison User's Guide* (Haskell version)
01:26:11 <Cale> (provided that you need them all)
01:26:22 <fax> ah ok
01:26:45 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonCore-1.2.1
01:26:47 <lambdabot> http://tinyurl.com/2y94qw
01:26:48 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonAPI-1.2.1
01:26:50 <lambdabot> http://tinyurl.com/2qto6a
01:27:17 <iguana_> is there a modulus for Rationals?
01:27:28 <Cale> iguana_: Data.Ratio
01:27:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
01:27:44 <lambdabot> http://tinyurl.com/ytrm99
01:28:52 <misterbeebee> cale: thx. that page abstract seems to claim that edison should be future-proof.... "have no dependencies other than those commonly bundled with Haskell compilers."
01:29:16 <iguana_> Cale: you mean I have to write it myself?
01:29:37 <Cale> iguana_: oh, modulus :)
01:29:41 <Cale> heh, I misread that :)
01:29:47 <Cale> What would it do?
01:30:06 <iguana_> well, e.g. 7%5 `mod` 3%5 -> 1%5
01:30:19 <Cale> ah, okay
01:30:39 <Cale> I suppose it's not so hard to write in terms of the mod on integers
01:30:46 <iguana_> yes
01:30:49 <Cale> (but no, it's not in the libraries)
01:30:57 <ivant> Hi guys
01:31:04 <Cale> ivant: hello
01:31:08 <ivant> who is at Haskell Workshop right now? :-)
01:31:10 <iguana_> is there a function to bring two ratios to common denominator?
01:31:18 <nathanael> @ivant: me :-)
01:31:18 <lambdabot> Unknown command, try @list
01:31:24 <Cale> iguana_: there's lcm and gcd
01:31:30 <nathanael> hi
01:31:32 <Cale> and denominator/numerator functions
01:31:43 <Cale> nathanael: hello
01:31:56 <nathanael> break s now over :)
01:32:05 <iguana_> better than nothing, I guess :)
01:32:33 <Cale> iguana_: Rationals are automatically put in lowest terms
01:33:49 <fax> > zipWith (\x -> if (x==3) then id else (1-)) [1..] [5,6,8,4,7,5,2]
01:33:55 <lambdabot>  [-4,-5,8,-3,-6,-4,-1]
01:33:59 <bakert> What does a capital B before a String mean?  As in Request { rqBody = B"a=1&b=22" } ?
01:34:06 <fax> can this be done in a less silly way? :p
01:34:18 <Cale> bakert: that would be a constructor, I think
01:34:57 <Cale> fax: apply a function to all but one element of a list?
01:35:03 <fax> yes
01:35:23 <Cale> Well, you could abstract it, but that's a pretty decent way to handle that
01:35:32 <Cale> I suppose you could also write it as a comprehension
01:35:39 <fax> oh ok I will try that
01:36:18 <Cale> > [ if k == 4 then x else 1 - x | (k,x) <- zip [0..] [5,6,8,4,7,5,2]]
01:36:19 <lambdabot>  [-4,-5,-7,-3,7,-4,-1]
01:36:35 <Cale> > [ if k == 2 then x else 1 - x | (k,x) <- zip [0..] [5,6,8,4,7,5,2]]
01:36:36 <lambdabot>  [-4,-5,8,-3,-6,-4,-1]
01:37:59 <fax> ah ok you have to zip the lists otherwise there are infinite results
01:38:20 <fax> what can I call this? something better than mapIndicesOtherThan?
01:38:43 <misterbeebee> mapExcept?
01:38:49 <fax> ok :D
01:39:42 <fax> @let mapExcept index f list = [ if k == index then x else f x | (k,x) <- zip [0..] list ]
01:39:45 <lambdabot> Defined.
01:39:56 <fax> > mapExcept 2 (1-) [1,77,956,4,2,243,65]
01:39:57 <lambdabot>  [0,-76,956,-3,-1,-242,-64]
01:41:21 <bakert> :t Data.Map.lookup
01:41:23 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
01:41:29 <hpaste>  iguana pasted "rational mod" at http://hpaste.org/3002
01:41:38 <iguana_> does that look right?
01:44:28 <bakert_> :t bodyToMap
01:44:30 <lambdabot> Not in scope: `bodyToMap'
01:44:41 <bakert_> @hoogle bodyToMap
01:44:42 <lambdabot> No matches found
01:47:54 <misterbeebee> iguana:  do you care about negative values of the 2nd argument?
01:47:55 <bakert_> :t (>>=)
01:47:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:50:23 <bakert_> :t readsPrec
01:50:25 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
01:50:40 <bakert_> how does readsPrec know what it is looking for?
01:50:51 <bakert_> Does it only read numbers?
01:51:43 <fax> > readsPrec 2 "'x' 546 231 67" :: [(Char, String)]
01:51:45 <lambdabot>  [('x'," 546 231 67")]
01:51:51 <fax> > readsPrec 2 "546 231 67" :: [(Int, String)]
01:51:52 <lambdabot>  [(546," 231 67")]
01:52:01 <ivant> @where IOSpec
01:52:01 <lambdabot> I know nothing about iospec.
01:52:08 <bakert_> fax: interesting
01:52:08 <fax> > readsPrec 2 "'x' 546 231 67" :: [(Int, String)]
01:52:10 <lambdabot>  []
01:52:31 <bakert_> > readsPrec 2 "1 2 3"
01:52:33 <lambdabot>  [(1," 2 3")]
01:52:38 <bakert_> > readsPrec 2 "x 2 3"
01:52:40 <lambdabot>  []
01:52:46 <bakert_> so numbers by default?
01:52:55 <bakert_> but you can type it into doing something else
01:53:08 <bakert_> which is why i am getting an empty list when i should be getting a word :)
01:53:09 <fax> Why numbers by default?
01:53:09 <ivant> @where+ IOSpec http://www.cs.nott.ac.uk/~wss/repos/IOSpec/
01:53:10 <lambdabot> Done.
01:53:11 <fax> > read "2"
01:53:12 <lambdabot>  2
01:53:18 <fax> >:O
01:53:24 <bakert_> > readsPrec 2 "hello monkey"
01:53:26 <lambdabot>  []
01:53:43 <bakert_> > readsPrec 2 "hello monkey" :: [(Char, String)}
01:53:43 <lambdabot>  Parse error
01:53:47 <bakert_> oops
01:53:54 <bakert_> > readsPrec 2 "x monkey" :: [(Char, String)}
01:53:54 <lambdabot>  Parse error
01:54:10 <bakert_> ah i see.  the single quotes, for a char?
01:54:12 <fax> > readsPrec 2 "\"hello monkey\"" :: [(String, String)]
01:54:14 <lambdabot>  [("hello monkey","")]
01:54:20 <bakert_> and double quotes for a string
01:54:22 <bakert_> :)
01:54:32 <fax> @src readsPrec
01:54:32 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
01:54:37 <fax> what is the Int ?
01:54:42 <fax> 2 in that case
01:54:49 <bakert_> precedence of the operation
01:54:55 <fax> ah
01:55:07 <bakert_> odd.  but true.
01:55:44 <fax> @pointless f where f _ x = x
01:55:45 <lambdabot> f = const (const (const id))
01:58:16 <fax> :t (|||)
01:58:19 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
01:58:37 <fax> @pointless (\(x,y) -> (f x, f y))
01:58:37 <lambdabot> f *** f
02:02:30 <fax> hum :|
02:02:43 <fax> Is there something wrong with this..
02:02:54 <fax> I got told Equations for `substitute' have different numbers of arguments
02:03:36 <fax> f x y = <stuff> ; f _ = id
02:03:48 <fax> so I have to write the last one as f _ y = y ?
02:03:52 <narain> ?index comparing
02:03:52 <lambdabot> bzzt
02:04:49 <narain> where is comparing?
02:05:12 <bakert_> :t lookM
02:05:14 <lambdabot> Not in scope: `lookM'
02:05:19 <bakert_> @hoogle lookM
02:05:19 <lambdabot> No matches found
02:05:28 <ivant> Data.Ord?
02:05:39 <desp> @get-shapr
02:05:39 <lambdabot> shapr!!
02:05:39 <narain> yes!
02:05:50 <narain> thanks ivant
02:06:14 <narain> wonder why i didnt think of that
02:06:23 <hpaste>  misterbee pasted "another rational mod" at http://hpaste.org/3003
02:09:50 <bakert_> :t Control.Monad.State.put
02:09:52 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
02:10:25 <thetallguy> Can anyone point me to a definition of the free monad?
02:14:03 <ivant> thetallguy, there is something here http://www.dpmms.cam.ac.uk/~rhgg2/CT07.pdf
02:14:43 <Cale> data FreeMonad sig a
02:14:43 <Cale>   = Return a
02:14:43 <Cale>   | Expr (sig (FreeMonad sig a))
02:14:57 <Cale> foldFM ret expr (Return a) = ret a
02:14:57 <Cale> foldFM ret expr (Expr e)
02:14:57 <Cale>   = expr (fmap (foldFM ret expr) e)
02:15:02 <Cale> instance Functor sig => Functor (FreeMonad sig) where
02:15:02 <Cale>     fmap f = foldFM (Return . f) Expr
02:15:02 <Cale> instance Functor sig => Monad (FreeMonad sig) where
02:15:02 <Cale>     return = Return
02:15:04 <Cale>     fm >>= f = foldFM f Expr fm
02:15:13 <Cale> (probably should have hpasted that :)
02:17:33 <Cale> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
02:18:08 <Cale> Main let x :: Expr (Add :+: Val ) = val 30000 ⊕ val 1330 ⊕ val 7
02:18:08 <Cale> Main eval x
02:18:08 <Cale> 31337
02:18:12 <Cale> ahaha
02:18:16 <fax> :O
02:18:44 <fax> > let (⊕) = map (+) in [1,2,3] ⊕ [6,7,8]
02:18:45 <lambdabot>  Illegal character ''\138''
02:18:51 <fax> ;'(
02:19:47 <fax> @index (***)
02:19:48 <lambdabot> Control.Arrow
02:27:08 <thetallguy> Cale, ivant: thanks.
02:28:04 <misterbeebee> g'night everyone, and nice to meet you. (2:30am PDT)
02:28:12 <sioraiocht> ha! I just woke up!
02:28:32 <sioraiocht> I guess I'll start meeting a whole different #haskell crowd, now...
02:28:55 <Pseudonym> My five-year-old daughter is currently doing calculations on my Addiator.
02:29:24 <Pseudonym> How many five-year-olds know how to use an Addiator?
02:29:35 <fax> Addiator looks cool :o
02:29:42 <fax> (I never heard of one)
02:29:50 <helikoptik> what is Addiator?
02:29:57 <Pseudonym> ?go addiator
02:29:59 <fax> helikoptik: http://upload.wikimedia.org/wikipedia/en/9/9e/Addiator_2.jpg
02:30:00 <lambdabot> http://en.wikipedia.org/wiki/Addiator
02:30:10 <Pseudonym> Mine is shinier than that one.
02:30:15 <fax> jhehe
02:30:26 <Pseudonym> She now wants to know what a negative number is.
02:30:31 <helikoptik> someone triggers this bot or it just recognizes keywords?
02:30:32 <Pseudonym> After subtracting a large number.
02:30:37 <jeffz> Pseudonym: how come you have an addiator?
02:30:47 <Pseudonym> jeffz: I have a small collection of retro-computing devices.
02:30:57 <Pseudonym> Slide rules, abacuses, and now an addiator.
02:31:05 <jeffz> ah - cool.
02:31:11 <Pseudonym> I want a Curta, but they're seriously expensive.
02:31:39 <Pseudonym> http://www.vcalc.net/curta_simulator_en.htm
02:31:41 <lambdabot> Title: Curta-Simulator
02:31:48 <fax> omg
02:32:05 <fax> that Curta looks so cool
02:32:13 <Pseudonym> It is!
02:32:26 <fax> Looks straight out of Myst
02:32:30 <Pseudonym> It's probably the most intricate mechanical calculating device ever made.
02:32:51 <Pseudonym> Given that the Babbage analytical engine was never actually built.
02:32:55 <Pseudonym> Well... not in his lifetime.
02:34:04 <Pseudonym> This will give you some idea how intricate it was:
02:34:06 <Pseudonym> http://www.vcalc.net/disassy/
02:34:07 <lambdabot> Title: <H1>CURTA DISASSEMBLY</H1>Last Update: April 22, 2006 -- THE CURTA REFERENCE
02:35:21 <Pseudonym> The weird thing is, Curtas actually worked on the same principle as desk adders.
02:35:34 <Pseudonym> Just a cylindrical cam system.
02:36:15 <Pseudonym> Curtas are famous for being used on the Dakar rally.
02:36:48 <Pseudonym> Even after the advent of pocket electronic calculators, they used Curtas because they didn't fail under desert conditions.
02:37:33 <fax> huh that's impressive
02:37:41 <fax> I thought they would be much more tempremental
02:38:37 <Pseudonym> Rock-solid, apparently.
02:41:44 <hpaste>  fax pasted "performSubstitutions" at http://hpaste.org/3004
02:42:01 <fax> I rewrote performSubstitutions.. and just wanting to ask is this ok?
02:42:25 <fax> like is foldl appropriate ?
02:42:48 <oerjan> almost never
02:43:02 <fax> What do you generally do instead?
02:43:07 <oerjan> foldl'
02:43:30 <fax> What is that?
02:43:43 <oerjan> @src foldl'
02:43:43 <lambdabot> foldl' f a []     = a
02:43:43 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:43:51 <oerjan> strict version of foldl
02:44:01 <Cale> Usually you want either foldr or foldl'
02:44:06 <oerjan> because foldl tends to build up huge thunks
02:45:19 <fax> @index foldl'
02:45:19 <lambdabot> Data.List
02:45:20 <oerjan> second point, !! for iteration is inefficient
02:46:06 <oerjan> although in this case eqs is not the same each time is it...
02:52:47 <oerjan> if i understand this correctly, you could avoid it by passing a pair of lists, where the first part is those equations already used
02:53:05 <oerjan> and the current equation is the head of the second part
02:53:48 <oerjan> (well, pair or two separate arguments)
02:54:31 <oerjan> additional advantage: you don't need to consider length at all, just test second part for emptyness
02:54:47 <fax> oh yeah that sounds good
03:08:17 <bakert_> @hoogle reduce
03:08:17 <lambdabot> No matches found
03:08:37 <bakert_> @hoogle foldl
03:08:38 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
03:08:38 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
03:08:38 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
03:10:01 <ivant> wow, Uniplate is cool! ndm is a good speaker too
03:10:44 <bakert_> @hoogle join
03:10:44 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
03:10:44 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
03:10:44 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
03:13:48 <EvilTerran> concat?
03:15:18 <oerjan> reduce is lisp/python/whatever for fold, isn't it?
03:17:16 <dibblego> oerjan, I think foldx1 as well
03:17:25 <dibblego> oerjan, or maybe I am thinking of Ruby
03:20:41 <oerjan> i meant fold*
03:20:46 <oerjan> all of them
03:25:46 <EvilTerran> in c2hs, is there a way to get the value of a const or a #define'd value?
03:26:27 <EvilTerran> fooBar = {# const FOO_BAR #} kinda thing?
03:26:55 <phlpp> oh man, all this own-type stuff is reaally confusing
03:26:56 <phlpp> ._.
03:27:31 <phlpp> "own-type", lol \o/
03:27:52 <oerjan> data Data dat = Data (Data dat) dat (Maybe dat)
03:28:01 <phlpp> :)
03:28:08 <phlpp> i'll post an example, sec
03:29:03 <phlpp> in "yet another haskell tutorial", section 4.5.3, we got sth like: data List a = Nil | Cons a (List a)
03:29:32 <phlpp> and there's described how to write a length function on this data type, that's clear to me
03:29:46 <phlpp> and task is, to write other simple list functions for this type like head, tail, and so on
03:30:20 <phlpp> but ffs, how can i TEST my functions, i mean, how can i construct a list with the help of my own List data type?
03:30:23 <phlpp> ._.
03:30:24 <fax> ghci
03:30:30 <oerjan> pattern matching, generally
03:30:32 <fax> and write e.g.
03:30:40 <fax> (Cons 1 (Cons 2 (Cons 3 Nil)))
03:30:50 <Cale> phlpp: Once you've defined the type in a file, you can use the constructors directly to build values
03:31:08 * Cale suddenly wonders if data decls work with @let
03:31:19 <phlpp> fax, hm
03:31:21 <Cale> @let data List a = Nil | Cons a (List a)
03:31:21 <lambdabot> Invalid declaration
03:31:21 <oerjan> nope
03:31:41 <phlpp> Possible fix: add an instance declaration for (Show (List t))
03:31:44 <fax> onetwothree = (Cons 1 (Cons 2 (Cons 3 Nil)))
03:31:46 <Cale> Too bad, isn't it just sticking the decls into a file anyway?
03:31:47 <fax> head onetwothree
03:31:49 <fax> ^ in ghci
03:32:01 <Cale> fax: you'll need a let there
03:32:01 <phlpp> its just confusing to me this data type stuff, sorry :/
03:32:02 <fax> You cabn change
03:32:06 <fax> data List a = Nil | Cons a (List a)
03:32:15 <fax> to data List a = Nil | Cons a (List a) deriving (Show)
03:32:39 <phlpp> like just introducing new types/constructor just by writing sth like data x y = One x or sth.
03:32:51 <phlpp> hard to explain what i mean :F
03:33:30 <oerjan> Cale: something about type checking with weird types being able to crash lambdabot, iiuc what i read on the wiki
03:33:49 <Cale> The thing on the left of the = sign in a data declaration is the type constructor -- essentially you give the name of the type you're defining, and if it takes any parameters, you list those as well
03:34:15 <Cale> On the right of the = sign you give a | separated list of data constructors
03:34:42 <Cale> Data constructors are functions which are used to build up the data type, and also used to deconstruct values in pattern matches
03:34:57 <Cale> Each data constructor is followed by a list of types of its parameters
03:35:46 <Cale> data Employee = Boss String Integer | Slave String
03:36:06 <Cale> (slaves don't have a salary, so they won't have an Integer field there :)
03:36:23 <Cale> So examples of values of that type are:
03:36:59 <Cale> Boss "Russ T. Hinge" 1000000
03:37:45 <phlpp> ah, ok
03:37:47 <Cale> Slave "Whatever"
03:37:58 <Cale> etc.
03:38:15 <Cale> The possibly confusing bit is when types are recursive
03:38:32 <Cale> Data constructors can take values of the type you're defining as parameters
03:38:47 <Cale> For example, in the list case, you have
03:38:57 <Cale> data List a = Nil | Cons a (List a)
03:39:14 <Cale> So a value of type (List a) is either Nil
03:39:24 <phlpp> hm, i think the confusing bit to me is/was the syntax, as u explained it, and why i didn't got that List type working (in/at functions)
03:39:28 <phlpp> ;_
03:39:38 <Cale> or it's something of the form (Cons x xs), where x is a value of type a, and xs is a value of type List a
03:39:57 <phlpp> hm
03:40:14 <Cale> I think your problem was that you didn't make it an instance of Show, which is important if you want to be able to print out values of the type
03:40:16 <phlpp> is there sth. to check, whether Xyz is a data constructor?
03:40:29 <Cale> All data constructors start with a capital letter
03:40:37 <Cale> (or if they're infix, with a colon)
03:40:48 <Cale> (and no other functions do)
03:40:50 <phlpp> hm, i mean if it's there
03:40:53 <phlpp> so to check at ghci
03:40:58 <Cale> ah
03:41:08 <Cale> You can simply do something like  :t Cons
03:41:12 <Cale> to get its type
03:41:17 <phlpp> oh, stupid me
03:41:17 <phlpp> :D
03:41:45 <phlpp> and yeah, this show class stuff looks fine, it's not explained in my tutorial so far, so..
03:41:49 <oerjan> or :i Cons
03:41:56 <phlpp> i actually don't know about deriving yet, ;)
03:42:35 <phlpp> but thx for all that help guys
03:42:37 <phlpp> :)
03:42:44 <matt__r> would an editor that uses lambdabot (the one here on #haksell) for looking up info be welcomed or hated
03:42:46 <Cale> The Show class is just all the types which support the function show
03:42:52 <Cale> show turns values into strings
03:42:56 <Cale> > show 437289
03:42:58 <lambdabot>  "437289"
03:43:04 <Cale> > show [1,2,3,4,5]
03:43:05 <lambdabot>  "[1,2,3,4,5]"
03:43:11 <Cale> > show (Just 7)
03:43:12 <matt__r> I am thinking of adding a command to textmate to allow you to query lambdabot from withing the editor
03:43:12 <lambdabot>  "Just 7"
03:43:28 <Cale> > show "Hello"
03:43:30 <lambdabot>  "\"Hello\""
03:43:40 <matt__r> but that will generate a little (if it is just me) or a lot (if other like it) extra traffic (in the background) for the bot
03:43:59 <fax> matt__r: Why not just use GHCi?
03:44:10 <Cale> deriving (Show) will make Haskell write the code for show for you, based on the structure of your type
03:44:13 <matt__r> you need ghci on acid right?
03:44:23 <Cale> deriving only works for a few special classes though
03:44:35 <phlpp> ok
03:44:39 <matt__r> I want something that anyone can use on any computer (as long as they have a net connection)
03:44:54 <fax> download ghci ;)
03:45:17 <matt__r> well, I have ghci, but unless it has changed, it is not a patch on old lambdabot
03:45:34 <Cale> (Namely, Eq, Ord, Enum, Bounded, Read, and Show)
03:46:00 <nornagon> > read $ show [1,2,3,4,5] :: [Int]
03:46:01 <lambdabot>  [1,2,3,4,5]
03:46:08 <Cale> Well, there are a few others in some extensions of the basic Haskell language :)
03:46:31 <nornagon> > read $ show ([1,2,3,4,5] :: [Int]) :: [Double]
03:46:32 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
03:46:38 <Cale> heh
03:46:39 <fax> How do you debug ? :(
03:46:47 <fax> I found an infinite loop
03:46:56 <nornagon> trace!
03:47:00 <nornagon> :t trace
03:47:01 <lambdabot> Not in scope: `trace'
03:47:03 <nornagon> boo
03:47:07 <nornagon> i forgot what it was called
03:47:12 <Cale> :t Debug.Trace.trace
03:47:14 <lambdabot> forall a. String -> a -> a
03:47:18 <nornagon> ah :)
03:47:22 <Cale> That can be handy
03:47:25 <matt__r> this is part of my attempts to try and answer the teasing I get from my ide using buddies that they can look up all kinds of stuff from right in the editor.
03:47:32 <oerjan> fax: generally the simplest is to hpaste your code and ask #haskell
03:47:43 <fax> It is about 40 lines though
03:47:48 <Cale> Other things to try are breaking your program down into small bits until each bit is understandable :)
03:47:54 <matt__r> evn just a pre-compiled lambdabot for osx will do the job.... anyone
03:48:39 <Cale> Or, compile with profiling and profile for a bit
03:48:57 <Cale> Which function the infinite loop is in should become obvious from the profiling output
03:49:45 <matt__r> fax: hpaste it, I am curious now and I want a look
03:49:55 <Cale> To do that, use the options -prof -auto-all on the GHC commandline, and then +RTS -p -RTS on your program's commandline (you can forgo the -RTS if you stick it at the end)
03:50:12 <nornagon> i would love someone to compile a lambdabot for OSX; my laptop's power board died and now i'm using my sister's powerbook
03:50:20 <hpaste>  fax pasted "HerbrandMGU (non-terminating due to a bug)" at http://hpaste.org/3006
03:50:21 <nornagon> and I miss ghci :(
03:50:25 <nornagon> although it has irb
03:50:43 <fax> This is my rewrite to try and make it more legible..
03:50:51 <Cale> hehe, we don't have PrologAST to be able to try it do we?
03:51:05 <fax> oops
03:51:22 <hpaste>  fax annotated "HerbrandMGU (non-terminating due to a bug)" with "AST" at http://hpaste.org/3006#a1
03:51:24 <Cale> Yeah, this looks like something you're going to want trace for.
03:52:13 <fax> how do I use trace?
03:52:15 <Pseudonym> What's an example that doesn't terminate?
03:52:21 <matt__r> fax: if you haven't already, make sure you have exercised each individual function well before you move on.
03:52:30 <fax> Pseudonym: unify [((PrologCompound "f" 2 [PrologCompound "g" 1 [PrologVariable "Y"],PrologVariable "Y"]),(PrologCompound "f" 2 [PrologCompound "g" 1 [PrologVariable "X"],PrologCompound "f" 1 [PrologVariable "X"]]))]
03:52:38 <matt__r> The code is nicely written to allow you to use HUnit to test, test, test
03:52:48 <matt__r> trace "string" $ expression
03:52:49 <Pseudonym> Incidentally, the Prolog name isn't "compound", it's "functor".
03:52:59 <Pseudonym> Which, unfortunately, confuses Haskellers.
03:53:04 <Pseudonym> And it's not "AST", it's "term".
03:53:11 <matt__r> then the string gets printed wehn the expression is evaluated
03:53:13 <Pseudonym> Just thought I'd mention that.
03:53:29 <fax> in f(X, Y) f is the functor
03:53:51 <Pseudonym> So it's f(g(Y),Y) = f(g(X),f(X)), right?
03:54:03 <fax> Yeah
03:54:04 <nornagon> case trace "foo" Nothing of Nothing -> blah
03:54:09 <Pseudonym> OK, first comment.
03:54:22 <matt__r> fax: I am writing a little interpreter and HUnit is my best friend.  Seriously, it is worth the effort and I don't have to use tracing that much!
03:54:32 <Pseudonym> I think you actually want to perform the unifications sequentially, rather than in parallel.
03:54:52 <Pseudonym> Because a binding in one unification might be used in the next one.
03:55:42 <therp> pseudonym: yes I think so too
03:55:52 <therp> pseudonym: but I wonder where an infinite loop should come from
03:55:56 <therp> because of this..
03:56:28 <fax> What am I doing that is parallel?
03:56:39 <Pseudonym> The zipWithM's and mapM's.
03:57:12 <iguana_> how to convert Rational to Float?
03:57:26 <nornagon> :t toRational
03:57:28 <fax> iguana_: fromRational
03:57:33 <nornagon> er.
03:57:35 <lambdabot> forall a. (Real a) => a -> Rational
03:57:35 <nornagon> right.
03:57:42 <nornagon> :t fromRational
03:57:44 <lambdabot> forall a. (Fractional a) => Rational -> a
03:57:46 <fax> If I have like, f(X, Y, Z) = f(a, b, c), then I want to get [X=a, Y=b, Z=c]
03:57:57 <iguana_> > fromRational (5%2) :: Double
03:58:01 <lambdabot>  2.5
03:58:03 <iguana_> ok
03:58:10 <fax> so zipWithM unifyPairM seems ok, the monad is there so if any one of them doesn't unify it bails immeditaly
03:58:13 <Cale> substitute ("X",PrologCompound "f" 1 [PrologVariable "X"]) PrologCompound "f" 1 [PrologCompound "f" 1 [PrologCompound "f" 1 [PrologVariable "X"]]]
03:58:19 <Cale> that produces an infinite loop
03:58:30 <Cale> (the same infinite loop you're in)
03:58:37 <Pseudonym> Aha!
03:58:40 <Pseudonym> That makes sense.
03:58:43 <iguana_> @hoogle intAtBase
03:58:43 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
03:58:44 <Pseudonym> Occurs check.
03:58:54 <Cale> I got that by adding
03:59:07 <Pseudonym> You need to implement the occurs check.
03:59:07 <iguana_> @hoogle hex
03:59:07 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
03:59:07 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
03:59:07 <lambdabot> Numeric.readHex :: Integral a => ReadS a
03:59:14 <Cale> substitute (var,val) x | trace (concat ["substitute ", show (var,val)," ",show x,"\n"]) False = undefined
03:59:20 <nornagon> I wonder if you could create a ConcurrencyMonad, that would work out data dependencies and parcel out tasks to different processors in an optimal manner
03:59:26 <Cale> To the top of the definition of substitute
03:59:31 <Pseudonym> nornagon: Data parallelism!
03:59:36 <nornagon> yes :)
03:59:42 <Pseudonym> Talk to SPJ.
03:59:53 <iguana_> what is the difference between fromRational and Numeric.fromRat?
04:00:02 <fax> Cale: wow :D
04:00:04 <nornagon> :t Numeric.fromRat
04:00:06 <lambdabot> forall a. (RealFloat a) => Rational -> a
04:00:13 <matt__r> I second that wow
04:00:17 <matt__r> "wow"
04:00:20 <nornagon> :t fromRational
04:00:22 <lambdabot> forall a. (Fractional a) => Rational -> a
04:00:23 <Pseudonym> MOM!
04:00:30 <nornagon> trace is so cool
04:00:31 <therp> fax: but you don't zipM over equations. you mapM over them.
04:00:39 <oerjan> :t realToFrac
04:00:40 <therp> fax: in unify
04:00:41 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
04:00:46 <Cale> ¡MOM
04:00:54 <nornagon> @yow
04:00:54 <lambdabot> Is it 1974?  What's for SUPPER?  Can I spend my COLLEGE FUND in one
04:00:54 <lambdabot> wild afternoon??
04:00:54 <Cale> hehe
04:01:20 <therp> fax: hmm. ah sorry it's the maybe monad
04:01:24 <iguana_> is fromRat more efficient for converting to float?
04:01:30 <therp> fax: forget that comment
04:02:17 <Cale> Oh, I also determined where the loop was through profiling so I knew where to put the trace
04:03:08 <matt__r> OK - I feel like getting an osx build of lambdabot going - wish me luch
04:03:10 <matt__r> luck
04:03:13 <matt__r> or lunch
04:03:16 <matt__r> either is fine
04:03:32 <hpaste>  Cale annotated "HerbrandMGU (non-terminating due to a bug)" with "profiling output" at http://hpaste.org/3006#a2
04:03:55 <fax> ok right
04:04:00 <fax> I will implement the occurs check
04:04:10 <fax> thanks everyone
04:04:30 <Cale> (you can see clearly there the 851 thousand some-odd entries of substitute ;)
04:04:52 <fax> ahh
04:08:02 <bakert> good lunch matt__r
04:08:05 <bakert> :)
04:08:18 <matt__r> bakert:  thankyou :)
04:09:26 <Cale> So there's some kind of Haskell convention taking place? Are videos being made of the talks?
04:09:50 <bakert> ?google haskell convention 2007
04:09:53 <lambdabot> http://conferences.oreillynet.com/cs/os2007/view/e_sess/14016
04:09:53 <lambdabot> Title: O'Reilly Open Source Convention 2007 &#8226; July 23-27, 2007 &#8226; Portland,  ...
04:09:57 <bakert> pah
04:10:17 <bakert> ?google haskell convention 2007 september
04:10:19 <lambdabot> http://swik.net/tutorial+haskell
04:10:19 <lambdabot> Title: tutorial + haskell - SWiK
04:10:23 <bakert> nope
04:10:24 <bakert> :(
04:10:37 <bakert> it's just too hard to leave irc and actually search ;)
04:10:55 <oerjan> http://proglang.informatik.uni-freiburg.de/ICFP2007/
04:10:59 <lambdabot> Title: ICFP 2007
04:11:13 <Cale> yeah, http://www.cse.unsw.edu.au/~keller/haskellws/HaskellWorkshop.html
04:11:14 <lambdabot> Title: Haskell Workshop 2007
04:13:02 <bakert> funky
04:14:29 <bakert> If you were going to do some web programming in Haskell, what would you use?
04:15:32 <fax> cool :D
04:15:38 <fax> the occurs check fixed this bug
04:16:22 <fax> @hoogle Bool -> Maybe a
04:16:23 <lambdabot> No matches, try a more general search
04:16:36 <fax> @hoogle Bool -> a -> Maybe a
04:16:37 <lambdabot> No matches, try a more general search
04:16:56 <fax> Is it ok to do: if any occursCheck unified then Nothing else Just ()
04:18:16 <matt__r> can't even get hs-plugins to compile :(
04:18:20 <matt__r> I am a failure
04:18:21 <Boney> @hoogle a -> Bool -> Maybe a
04:18:21 <lambdabot> No matches, try a more general search
04:18:28 <oerjan> :t guard
04:18:30 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:18:48 <oerjan> fax: guard has that as its Maybe instance
04:19:07 <vincenz> re
04:19:17 <fax> cool
04:19:21 <Boney> > guard True :: Mabye a
04:19:22 <lambdabot>   Not in scope: type constructor or class `Mabye'
04:19:26 <fax> so like guard $ not (any occursCheck unified)
04:19:29 <Boney> > guard True :: Maybe a
04:19:29 <lambdabot>   Maybe a
04:19:29 <lambdabot>       Inferred type: Maybe ()
04:19:29 <lambdabot>     In the expression: guard True
04:19:29 <lambdabot>    ...
04:19:32 <nornagon> @src Maybe guard
04:19:32 <lambdabot> Source not found. You type like i drive.
04:19:37 <nornagon> @src guard
04:19:37 <lambdabot> guard True  =  return ()
04:19:37 <lambdabot> guard False =  mzero
04:19:48 <Boney> > guard True :: Maybe ()
04:19:50 <lambdabot>  Just ()
04:19:52 <nornagon> @src MonadPlus Maybe
04:19:52 <lambdabot> Source not found. Wrong!  You cheating scum!
04:19:54 <fax> hm that's very neat
04:19:54 <Boney> > guard False :: Maybe ()
04:19:56 <lambdabot>  Nothing
04:19:59 <fax> I like this monad :D
04:20:49 <hpaste>  mattr pasted "hs-plugins compile is dying here" at http://hpaste.org/3007
04:21:26 <matt__r> does this mean the pre-processor is not running?
04:27:55 <matt__r> actually, it *seems* like an included file is missing
04:28:31 <hpaste>  mattr pasted "no sign of this .h file anywhere" at http://hpaste.org/3008
04:28:39 <matt__r> am I missing something?
04:29:41 <matt__r> indeed I am http://www.haskell.org/pipermail/glasgow-haskell-bugs/2007-January/007048.html
04:29:43 <lambdabot> Title: [GHC] #1106: During install, network's Typeable.h clobber's base's copy, http://tinyurl.com/ynluj3
04:32:47 <matt__r> can anyone help me decipher the solution ? http://hackage.haskell.org/trac/ghc/ticket/1106
04:32:49 <lambdabot> Title: #1106 (During install, network's Typeable.h clobbers base's copy) - GHC - Trac
04:41:58 <matt__r> yay! problem solved
04:42:10 <matt__r> I am sure you are all facinated to know that :)
04:42:17 <fax> How?
04:43:08 <matt__r> I went to the ghc repo and copied the Typeable.h file in there.  I put this over the "clobbered" on in /usr/local/lib/....
04:43:14 <matt__r> then everything was fine
05:05:42 <nominolo> ?users
05:05:42 <lambdabot> Maximum users seen in #haskell: 420, currently: 356 (84.8%), active: 5 (1.4%)
05:06:56 <iguana_> @pl \x -> length x == 2
05:06:57 <lambdabot> (2 ==) . length
05:08:08 <hpaste>  iguana pasted "hex color" at http://hpaste.org/3009
05:08:27 <iguana_> I feel stupid about that paste, anyone has a better way?
05:09:25 <fax> > (\x -> [(x `div` 16) `mod` 16,x `mod` 16]) 24
05:09:27 <lambdabot>  [1,8]
05:09:49 <fax> > map ("0123456789ABCDEF"!!) [1,8]
05:09:51 <lambdabot>  "18"
05:10:00 <fax> that is how I'd do it
05:10:03 <oerjan> drop 1 $ showHex (256+x) ""
05:10:06 <edwardk> @pl \x -> (x `div` 16) `mod` 16,x `mod` 16
05:10:06 <lambdabot> (line 1, column 28):
05:10:06 <lambdabot> unexpected ","
05:10:06 <lambdabot> expecting digit, variable, "(", "`", "!!", ".", operator or end of input
05:10:20 <edwardk> @pl \x -> ((x `div` 16) `mod` 16,x `mod` 16)
05:10:20 <lambdabot> ap ((,) . (`mod` 16) . (`div` 16)) (`mod` 16)
05:10:23 <oerjan> at least it's short :)
05:10:27 <edwardk> blech
05:10:36 <iguana_> oerjan: all right
05:10:39 <iguana_> :)
05:11:00 <fax> > let hex x = map ("0123456789ABCDEF"!!) [(x `div` 16) `mod` 16,x `mod` 16] in "#" ++ (hex 32) ++ (hex 245) ++ (hex 124)
05:11:02 <lambdabot>  "#20F57C"
05:11:29 <iguana_> fax: I think you could use intToDigit instead of the section
05:11:40 <edwardk> @type intToDigit
05:11:42 <lambdabot> Int -> Char
05:11:45 <fax> I don't need intToDigit
05:12:20 <edwardk> > intToDigit 15
05:12:21 <lambdabot>  'f'
05:12:45 <edwardk> > let hex x = map intToDigit [(x `div` 16) `mod` 16,x `mod` 16] in "#" ++ (hex 32) ++ (hex 245) ++ (hex 124)
05:12:49 <oerjan> hm...
05:12:51 <lambdabot>  "#20f57c"
05:13:33 <iguana_> @src intToDigit
05:13:34 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:16:44 <oerjan> > let sx x = uncurry concat $ join (***) ((:[]). intToDigit) $ divMod x 16 in sx 65
05:16:45 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[a]'
05:17:02 <oerjan> > let sx x = uncurry (++) . join (***) ((:[]). intToDigit) $ divMod x 16 in sx 65
05:17:03 <lambdabot>  "41"
05:17:19 <fax> > let sx x = uncurry (++) . join (***) ((:[]). intToDigit) $ divMod x 16 in sx 65543445
05:17:22 <lambdabot>  Exception: Char.intToDigit: not a digit 4096465
05:17:32 <oerjan> it's for bytes
05:19:37 <fax> ?djinn (a -> b -> c) -> (a -> b) -> a -> c
05:19:38 <lambdabot> f a b c = a c (b c)
05:20:53 <edwardk> > concatMap (liftM2 (!!) tails (subtract 2 . length) . ('0':)  . flip showHex "") [32,245,124]
05:20:54 <lambdabot>  "20f57c"
05:21:53 <fax> ?djinn a -> a -> a
05:21:53 <lambdabot> f _ a = a
05:22:00 <fax> @more
05:22:04 <edwardk> that at least just picks out the right tail
05:22:04 <fax> :(
05:22:50 <oerjan> f a _ = a and i don't think there are more without bottom
05:24:08 <oerjan> i recall that forall a. a -> a -> a is a representation of booleans
05:26:16 <edwardk> > '#':concatMap (liftM2 (!!) tails (subtract 2 . length) . ('0':)  . flip showHex "") [32,245,124]
05:26:18 <lambdabot>  "#20f57c"
05:26:22 <edwardk> better =)
05:27:09 <fax> > showHex 32
05:27:10 <lambdabot>  <[Char] -> [Char]>
05:27:20 <fax> > showHex 32 ""
05:27:22 <lambdabot>  "20"
05:27:52 <fax> > '#':concat $map (flip showHex "") [32,245,124]
05:27:53 <lambdabot>  Couldn't match expected type `[Char]'
05:28:21 <oerjan> $ has lowest precedence
05:28:37 <fax> > '#':(concat (map (flip showHex "") [32,245,124]))
05:28:39 <lambdabot>  "#20f57c"
05:28:48 <edwardk> fax: the issue is
05:28:54 <edwardk> > '#':(concat (map (flip showHex "") [12,245,124]))
05:28:56 <lambdabot>  "#cf57c"
05:29:08 <fax> ahh
05:30:44 <fax> > showHex "000" 654
05:30:45 <lambdabot>   add an instance declaration for (Integral [Char])
05:30:45 <lambdabot>     In the expression: sh...
05:30:45 <oerjan> > ('#':tail . showHex . foldl' (\x d -> 256*x+d) 1) [12,245,124]
05:30:46 <lambdabot>  Couldn't match expected type `[a]'
05:31:07 <oerjan> > ('#':tail . flip showHex "" . foldl' (\x d -> 256*x+d) 1) [12,245,124]
05:31:08 <lambdabot>  Couldn't match expected type `[Char]'
05:31:30 <oerjan> > (('#':) . tail . flip showHex "" . foldl' (\x d -> 256*x+d) 1) [12,245,124]
05:31:32 <lambdabot>  "#0cf57c"
05:33:52 <Japsu> :t showHex
05:33:54 <lambdabot> forall a. (Integral a) => a -> String -> String
05:34:02 <Japsu> showHex 42 "foo"
05:34:06 <Japsu> > showHex 42 "foo"
05:34:07 <lambdabot>  "2afoo"
05:34:16 <Japsu> hmm?
05:34:17 <fax> why does it  have that?
05:34:19 <Japsu> > showHex 42 ""
05:34:20 <lambdabot>  "2a"
05:34:20 <fax> @src showHex
05:34:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:34:48 <Japsu> > let n = lenght s; pad s = if n < 2 then replicate (2-n) "0" ++ s else s in '#' : concatMap (pad . flip showHex "") [12,245,124]
05:34:49 <lambdabot>   Not in scope: `s'
05:35:17 <Japsu> > let pad s = if length s < 2 then replicate (2 - length s) "0" ++ s else s in '#' : concatMap (pad . flip showHex "") [12,245,124]
05:35:18 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
05:35:35 <Japsu> > let pad s = if length s < 2 then replicate (2 - length s) '0' ++ s else s in '#' : concatMap (pad . flip showHex "") [12,245,124]
05:35:36 <lambdabot>  "#0cf57c"
05:35:58 <Japsu> > let pad s = if length s < 2 then replicate (2 - length s) '0' ++ s else s in '#' : concatMap (pad . flip showHex "") [12,245,0]
05:35:59 <lambdabot>  "#0cf500"
05:38:56 <phlpp> listLength :: (Num a) => List b -> a
05:39:12 <phlpp> how would this look like, if i knew exactly, that the length can only be a integer?
05:39:15 <iguana_> fax: that is for easy concatenation of Show values
05:39:27 <iguana_> I read that it's linear time then
05:39:32 <phlpp> is it possible to precise this one more, or do i have to use Num?
05:39:37 <fax> :: List a -> Integer
05:39:53 <phlpp> ah o
05:39:54 <phlpp> k
05:40:14 <phlpp> Num is a type constructor, isn't it?
05:40:26 <iguana_> is there a map variant that applies the function only to the first element of a tuple?
05:40:32 * serishema is wondering about writing snake as a programming excercise
05:40:36 <iguana_> (something with arrows?)
05:40:40 <fax> :t ((1+) *** id)
05:40:42 <lambdabot> forall t a. (Num t) => (t, a) -> (t, a)
05:41:00 <fax> serishema: Sounds good
05:41:01 <iguana_> does it also work with 3-tuples?
05:41:08 <iguana_> :t ((1+) *** id *** id)
05:41:10 <lambdabot> forall t a a1. (Num t) => (t, (a, a1)) -> (t, (a, a1))
05:41:13 <iguana_> :(
05:41:19 <fax> @pointless (\(x,y,z) -> (1+x,y,z))
05:41:19 <lambdabot> (line 1, column 7):
05:41:19 <lambdabot> unexpected ","
05:41:19 <lambdabot> expecting letter or digit, operator or ")"
05:41:19 <lambdabot> ambiguous use of a non associative operator
05:41:25 <serishema> just built gtk2hs for output
05:41:36 <iguana_> huh?
05:42:00 * serishema wonders what knots this is going to tie her brain in
05:42:14 <serishema> I want to learn LISP too, just becaus i have excessive amounts of curiosity.
05:42:17 <serishema> I must be insane.
05:42:20 <matt__r> done.!
05:42:32 <matt__r> I have a lambdabot for ppx macosx
05:42:32 <phlpp> serishema: indeed :D
05:42:34 <fax> serishema: You're not insane :p
05:42:41 <matt__r> but I am not sure I have it all working
05:42:48 <phlpp> got that same idea ;) learning haskell and lisp at the same time
05:42:52 <matt__r> hoogle gives errors :(
05:42:53 <fax> serishema: I am doingthe same in the other order
05:43:02 <phlpp> but im concentrating on haskell ;)
05:43:06 <mr_tenor> haha - "And, no, you won't be able to set breakpoints in type-level programs..." (Chak) http://www.haskell.org/pipermail/haskell-cafe/2007-September/031810.html
05:43:07 <fax> then again I am insane.. so you might be too
05:43:07 <lambdabot> Title: [Haskell-cafe] Monad.Reader 8: Haskell, the new C++, http://tinyurl.com/2z6thp
05:43:38 <serishema> i guess i got interested in the weird programming languages because just about everything else is yet-another C
05:43:55 <edwardk> aw, but breakpoints in the typesystem sounds like fun ;)
05:44:08 <edwardk> we're not THAT weird
05:44:14 <fax> yeah, most language are very similar to C.. it causes a lot of misconceptions
05:44:23 <bakert> OK, I wrote a HAppS tutorial thing for ignoramuses like me that could hardly begin to figure out where to start.
05:44:23 <bakert> http://bluebones.net/2007/09/simple-haskell-web-programming-with-happs/
05:44:26 <lambdabot> Title: Simple Haskell Web Programming with HAppS - bluebones.net, http://tinyurl.com/3crnhf
05:44:27 <fax> most popular ones anyway
05:44:41 <ivant> serishema, you should also take a look at J :-)
05:44:56 <fax> J is way cool
05:46:12 <ivant> serishema, http://en.wikipedia.org/wiki/J_programming_language
05:46:13 <lambdabot> Title: J (programming language) - Wikipedia, the free encyclopedia
05:46:27 * serishema reads
05:48:07 <fax> Average of a list in J: +/%#
05:48:28 <serishema> it doesn't like very readable at all.
05:48:33 <fax> it is quite readable I think
05:48:40 <fax> for really basic code
05:49:12 <fax> +/%# means + inserted between each element (sum), divided by (%) the length (#)
05:49:24 <fax> once you know the vocabulary it is simpler
05:49:31 <fax> (It's based on APL)
05:52:56 <ivant> serishema, I suggested it as an additional way to tie your brain in a strange way :-)
05:53:06 <gio126126> is somebody here fimilier about Regular expressions?
05:53:10 <serishema> ah
05:53:45 <phlpp> haskell web programming?
05:53:47 <phlpp> oh dear :-D
05:54:09 <Cale> gio126126: I expect most people here are :)
05:54:33 <mr_tenor> are they some new form of Monad?
05:54:56 <phlpp> hm
05:55:13 <phlpp> what about S-Expressions for web?
05:55:20 <phlpp> i mean, replace html with S-Expressions :D
05:55:37 <gio126126> somebody knows good notes for regular expressions?
05:55:52 <fax> gio126126: O'Reillys Mastering Regex is a decent book
05:55:54 <phlpp> regular-expressions.info or sth?
05:56:04 <Cale> gio126126: From what perspective? Formal language theory?
05:56:04 <phlpp> this book is also fine
05:56:09 <phlpp> and nearly all perl books
05:56:15 <phlpp> have a chapter about regex
05:56:24 <gio126126> so, i am reading papers about rule based programing
05:56:36 <gio126126> and they use regular expresion to constraint some variables
05:56:37 <fax> gio126126: Have you seen Curry yet? :D
05:56:40 <mr_tenor> syntax, which superset of regexps is supported, and what needs to beescaped diferes between implementations unfortunately :(
05:56:55 <mr_tenor> man i need a new keyboard
05:56:59 <gio126126> hei fax
05:57:04 <fax> hey :)
05:57:08 <gio126126> :)
05:57:14 <fax> let me find Curry examples
05:57:30 <fax> http://www.informatik.uni-kiel.de/~curry,/examples/
05:57:31 <lambdabot> Title: Curry Examples
06:00:01 <Cale> gio126126: http://www.cs.nuim.ie/~jpower/Courses/parsing/ http://www.tik.ee.ethz.ch/tik/education/lectures/DES/Book/des_book_automata.pdf -- some things google found
06:00:04 <lambdabot> Title: Notes on Formal Language Theory and Parsing
06:00:33 <gio126126> <Cale> thanks gale
06:01:21 <iguana_> @pl \d x -> concat (intersperse d x)
06:01:21 <lambdabot> (join .) . intersperse
06:01:28 <gio126126> Cale could u please look http://www.risc.uni-linz.ac.at/people/tkutsia/papers/Marin-Kutsia-JANCL-06.pdf
06:01:31 <lambdabot> http://tinyurl.com/yr9v5o
06:01:35 <iguana_> @pl concat
06:01:36 <lambdabot> join
06:01:52 <Cale> gio126126: sure
06:01:52 <phlpp> is there a FAQ for lambdabot?
06:01:54 <pastorn> @src join
06:01:54 <lambdabot> join x =  x >>= id
06:02:24 <gio126126> <Cale> i am reading that paper, so they use regexp
06:02:42 <Cale> okay
06:02:49 <Cale> yeah, I see that
06:03:06 <gio126126> actually i implemeted that calculus without regexp
06:03:33 <gio126126> now i want to extend it and add regexp, but to be honest i didnt undestand much about regexpr yest
06:06:08 <Cale> hmm, do you have any particular questions?
06:06:49 <gio126126> my question is to point paper to read which will help me to read this paper then
06:07:02 <vincenz> "google tutorial regular expressions"
06:07:11 <vincenz> @google introduction to regular expressions
06:07:13 <lambdabot> http://www.4guysfromrolla.com/webtech/090199-1.shtml
06:07:13 <lambdabot> Title: 4GuysFromRolla.com - An Introduction to Regular Expression with VBScript
06:07:14 <Cale> http://en.wikipedia.org/wiki/Regular_language
06:07:15 <lambdabot> Title: Regular language - Wikipedia, the free encyclopedia
06:07:24 <Cale> That will probably help
06:07:46 <iguana_> > printf "%02x" 32
06:07:47 <lambdabot>  Add a type signature
06:07:52 <iguana_> > printf "%02x" 32 :: String
06:07:53 <lambdabot>  "20"
06:07:55 <iguana_> ha
06:07:58 <iguana_> > printf "%02x" 10 :: String
06:07:59 <lambdabot>  "0a"
06:08:36 <Cale> There will be lots of stuff about matching strings in perl if you try to find tutorials on regular expressions, while you probably want a more formal introduction, given what you're doing. (Also, Perl's regular expressions aren't really regular expressions anymore)
06:08:50 <jeffz> vincenz: http://www.matthewgifford.com/a-tao-of-regular-expressions/
06:08:51 <lambdabot> Title: A Tao of Regular Expressions - Matthew Gifford
06:09:29 <Cale> So one trick would be to search for regular language
06:09:44 <Cale> since it'll occur on the same pages which formally introduce regular expressions :)
06:09:56 <Cale> (but not the pages which you likely don't want)
06:10:05 <gio126126> <Cale> can u go page 8
06:10:14 <Cale> yep
06:10:28 <vincenz> jeffz: thanks, not for me tho
06:10:38 <jeffz> vincenz: you made the request =)
06:10:42 <vincenz> gio126126: To be honest this 1) seems to require a lot of effort from Cale, b) is Offtopic
06:10:47 <vincenz> jeffz: look at the gio126126's conversation trace
06:11:05 <jeffz> vincenz: yes, I know - 23:06 <vincenz> @google introduction to regular expressions
06:11:08 <vincenz> so at least karma hm to hell :)
06:15:44 <mr_tenor> the Casters videos are cool. I haven't had my fix of lacking intuition in abstract algebra in years.
06:16:07 <Pseudonym> Clearly, the best way to do that is go one level up.
06:16:19 <Pseudonym> The more abstract you get, the more intuition fails you.
06:17:34 <Cale> or at least, every level of abstraction is a chance for things to get in which elude your intuition
06:18:03 <Pseudonym> YEah/.
06:18:12 <Pseudonym> I really should learn more topology.
06:18:14 <Cale> Sometimes it can remove concerns which seemed unintuitive too though.
06:18:21 <Pseudonym> Apparently that's the best source of intuition-breaking stuff.
06:18:34 <Cale> For example, I find normed vector spaces to be way less intuitive than vector spaces.
06:18:49 <vincenz> Cale: eh?
06:18:55 <vincenz> oh... I missed the word 'normed'
06:19:18 <Cale> (or say, Banach spaces)
06:20:25 <Cale> You have just enough geometry to tempt intuition, but just enough generality to behave in unintuitive ways (at least until you start getting used to it)
06:22:13 <mr_tenor> yah :)
06:22:59 <Cale> Dense proper subspaces really messed me up for a long time.
06:23:12 <mr_tenor> heh.. i remember one of my old professors told us when he was driing past some road sign with a bunch of circles on it and his young boy went "look daddy! Banach Spaces!"
06:23:20 <mr_tenor> *driving*
06:23:30 <Cale> hehehe
06:24:11 <astrolabe> high dimensional euclidean space is counter-intuitive to me.  You can find a ball which touches all the sides of a hypercube, but which doesn't contain the cubes centre  ?!
06:24:44 <fax> woah
06:24:46 <Cale> astrolabe: hmm, which ball?
06:24:55 <fax> ball meaning hypersphere?
06:24:59 <Cale> fax: yeah
06:25:06 <fax> which dimensions?
06:25:08 <Cale> fax: filled hypersphere
06:25:27 <astrolabe> Cale: Um don't know.  An exercise for the reader.
06:25:42 <fax> I don't believe it :P
06:26:03 <kaol> I wish I could use "case foo of "abc"++xs -> xs" instead of "case foo of 'a':'b':'c':xs -> xs"
06:26:18 <astrolabe> fax: Well, I didn't.  Perhaps I've misremembered it.  But can you prove that there is no such ball?
06:26:33 <Cale> kaol: you might try isPrefixOf
06:26:38 <mr_tenor> http://www.mathreference.com/ca-int,hsp.html
06:26:39 <lambdabot> Title: The Volume of the Hypersphere
06:26:46 <kaol> yeah, but that gives no access to xs
06:26:51 <Cale> kaol: right
06:27:32 <mr_tenor> not a very good refernce, but at a glance the calculations look ok
06:27:57 <kaol> it's a minor nit, really. I'm using a function of my own instead.
06:28:48 <fax> "We will not be surprised to see the volume of the sphere drop to 0 as n approaches infinity."
06:28:51 <fax> ^ I am >:|
06:28:53 <mr_tenor> ah http://en.wikipedia.org/wiki/Hypersphere looks better
06:28:54 <lambdabot> Title: Hypersphere - Wikipedia, the free encyclopedia
06:29:47 <fax> oh not really
06:30:03 <mr_tenor> yeah, my intuition tells me it drops off, but my brain isn't enough to tell meit drops to zero. like, every time you go up a dimension, you "carve off" part of thevolumne
06:30:31 <astrolabe> fax,cale: It actually isn't that hard to find an example.  If the centre of the sphere is one of the corners of the hypercube, the distance to the furthest edge is 1 while the distance to the center of the hypercube is (1/2)sqrt n
06:30:33 <Cale> Well, it doesn't actually *reach* zero of course :)
06:30:44 <mr_tenor> eg line doesn't go to square, it goes to circle. circle doesn't go to cylinder, it goes to sphere
06:31:02 <mr_tenor> Cale: yeah, but how do you mentally visualisea nonzero asymptote orthe absence of one?
06:31:03 <fax> astrolabe: Ahh! cool
06:31:09 <fax> that is reasonable
06:31:34 <astrolabe> fax: yeah.  But weird.
06:33:40 <Cale> ah, so it's not required to be tangent to each of the faces :)
06:34:14 <Cale> (which would pretty much rule out anything but the one centred on the middle of the cube)
06:34:25 <astrolabe> Cale: Sorry, no. But as you say...
06:34:46 <Cale> Still kind of unintuitive, I suppose
06:35:38 <Cale> http://mathworld.wolfram.com/Hypersphere.html is a decent article too
06:35:39 <lambdabot> Title: Hypersphere -- from Wolfram MathWorld
06:37:19 <Cale> It's pretty hard to imagine the surface area dropping off, especially as it only starts falling after the 7-dimensional one :)
06:37:58 <Cale> and the volume after the 6th
06:38:32 <Cale> er, 5th rather
06:39:57 <Cale> (but you're not really comparing the same thing either)
06:39:58 <fax> It is a little bit strange though
06:40:01 <fax> To compare e.g.
06:40:10 <fax> 1 m^2, and 0.556 m^3
06:40:16 <Cale> yes :)
06:41:43 <Cale> That's a cool stereographic projection of the 3-sphere
06:41:52 <Cale> (on the wikipedia page)
07:10:55 <mux> how can I tell cabal to link my code with some static library (libfoo.a) ?
07:12:03 <scook0> extra-libraries: foo
07:12:27 <mux> you mean just like for dynamic ones?
07:12:54 <scook0> well, I know I've used extra-libraries to link to a static lib
07:13:21 <scook0> (because I built the static lib myself)
07:14:03 <desegnis> mux, you mean, ghc is now productive at dynamic linking? I must have missed the news...
07:14:48 <mux> heh, it works on a few platforms.
07:15:06 <desegnis> hm, PowerPC, was it?
07:15:14 <mux> scook0: worked fine, though I had to add -L. in ghc-options; I suppose there's a better field for that, Libraries-Dirs didn't work
07:15:40 <scook0> extra-lib-dirs?
07:16:08 <mux> thanks
07:21:23 <shaftyy> my ghci seems buggy. logBase 10 1000 gives me 2.9999...6
07:21:52 <fax> Does not sound like a bug
07:22:11 <shaftyy> shouldnt it be 3.0 ?
07:22:49 <fax> approximately
07:22:53 <fax> (Which it is)
07:24:04 <EvilTerran> @go what every computer scientist should know about floating point
07:24:06 <lambdabot> http://docs.sun.com/source/806-3568/ncg_goldberg.html
07:24:06 <lambdabot> Title: What Every Computer Scientist Should Know About Floating-Point Arithmetic
07:27:38 <shaftyy> hm, even my pocket calc gets this right
07:28:21 <roconnor> > logBase 10 1000
07:28:23 <lambdabot>  2.9999999999999996
07:28:33 <allbery_b> pocket calcs don't generally do floating point
07:28:47 <roconnor> > realFrac (logBase 10 1000::Double)::Float
07:28:48 <lambdabot>   Not in scope: `realFrac'
07:29:12 <allbery_b> for instance HP calculators use BCD-encoded integer arithmetic internally
07:29:28 <shaftyy> > logBase 10 10000
07:29:30 <lambdabot>  4.0
07:29:34 <allbery_b> (that is, fixed-point represented by integers)
07:29:37 <puusorsa> rpn hp calculators for teh win!
07:29:38 <shaftyy> > logBase 10 1000000
07:29:40 <lambdabot>  5.999999999999999
07:29:46 <roconnor> > realToFrac (logBase 10 1000::Double)::Float
07:29:47 <lambdabot>  3.0
07:30:00 <shaftyy> ahh :)
07:30:00 <roconnor> > realToFrac (logBase 10 1000)::Float
07:30:02 <lambdabot>  3.0
07:30:06 <puusorsa> non-rpn calculators feel so stupid it's unreal, after you get used to rpn
07:30:21 <puusorsa> "what i have to use parentheses?? no stack??"
07:32:05 <LoganCapaldo> otoh  without "outerfix" (is that a word?) it makes it more dificult  to have arbitrary length things (what I have to count how many I have and throw the count into the mix too?)
07:32:46 <EvilTerran> do calculators ever have need for such arbitrary-length things?
07:32:56 <LoganCapaldo> not that i'm aware of :)
07:33:19 <LoganCapaldo> but I've always thought of calculators as sort of castrated interpreters :)
07:33:22 <EvilTerran> if they did, they could follow postscript's approach and have a "mark" that you can push on the stack
07:33:46 <EvilTerran> and then commands that operate on everything down to the first mark
07:34:00 <allbery_b> HP's internal RPN interpreter does use that trick
07:34:14 <allbery_b> (as distinct from the outer interpreter/REPL)
07:34:30 <LoganCapaldo> yeah but then you need a dynamicly typed stack or you need to reduce the number of values you can represent
07:35:37 <LoganCapaldo> I heart rpn but the need to work around that somehow has always irked me
07:36:00 <EvilTerran> ...could a stack-based language have haskell-style static typing?
07:36:38 <phlpp> hm
07:36:52 <EvilTerran> i think that would work, although it might need a little tweaking for the particular requirements of stack-based-ness
07:37:24 <LoganCapaldo> @google cat
07:37:24 <allbery_b> <EvilTerran> do calculators ever have need for such arbitrary-length things?
07:37:27 <lambdabot> http://www.cat.com/
07:37:36 <LoganCapaldo> @google cat programming language
07:37:38 <lambdabot> http://www.cdiggins.com/cat/
07:37:42 <allbery_b> HP's statistical operations do
07:37:56 <EvilTerran> allbery_b, oh, right. good thing i asked. ;)
07:38:59 <roconnor> EvilTerran: haskell makes a fine typed stack based calculuator with the right definitions
07:39:08 <allbery_b> (old HP48 hacker here :)
07:39:14 <LoganCapaldo> http://www.cat-language.com/paper.html
07:39:15 <lambdabot> Title: Cat Publications
07:39:20 <LoganCapaldo> I want a hp calculator
07:39:25 <LoganCapaldo> I';ve never had one
07:39:37 <LoganCapaldo> the "coolest" calculator I've ever had wasa ti-89
07:39:41 <EvilTerran> roconnor, given that sensibly static-typing a stack-based language is possible, somehow that  doesn't surprise me
07:39:57 <kpreid> roconnor: what definitions are those? I couldn't find one that allowed recursive functions
07:39:59 <roconnor> EvilTerran: there was a nice example on the old wiki
07:40:16 <allbery_b> thing is, these days I've schewed the big HP48GX in favor of a Palm T3 and RPN 3.x
07:40:24 <roconnor> kpreid: oh, I haven't seend recursive functions
07:40:30 <EvilTerran> fix?
07:41:23 <kpreid> I tried to do stack programming with arrow combinators and a (a, (b, (c, _))) stack representation
07:41:41 <kpreid> the problem is that a recursive function then needs to be polymorphic over the type of the rest of the stack
07:41:56 <kpreid> even as it calls itself
07:42:09 * mux had fun writing a list module where lists are represented as functions taking a natural number and returning a Maybe a
07:42:11 <EvilTerran> add :: (Int, (Int, s)) -> (Int, s) -- kinda thing?
07:42:17 <EvilTerran> -- but what about sum?
07:42:18 <kpreid> EvilTerran: 'zactly
07:42:41 <kpreid> well, the entirety of the question is in how you represent stacks in Haskell's type system
07:42:53 <kpreid> sum :: ([Int], s) -> (Int, s)
07:44:32 <EvilTerran> what about sumN, that adds up (pop) items off the top of the stack, and pushes the result back on, then?
07:44:36 <EvilTerran> (that's more what i was after)
07:44:53 <EvilTerran> i can kinda envisage something with typeclasses, but it'd be a bit messy.
07:46:32 <EvilTerran> or, likewise, put the first N items into a list or whatever
07:51:18 <kpreid> I think one should avoid that :-)
07:51:46 <kpreid> (the stack language Factor does, for the sake of type inference)
07:52:05 <LoganCapaldo> factor is dynamically typed no?
07:52:06 <roconnor>  http://tunes.org/~nef/logs/haskell/05.12.23
07:52:15 <roconnor> 07:38:39 <Cale> *Main> start push 1 push 2 add push "Hello" len add end
07:52:15 <roconnor> 07:38:39 <Cale> 8
07:53:49 <EvilTerran> i guess you could do "nil 1 cons 2 cons 3 cons 4 cons" kinda thing, thus dispensing with the need for that sort of thing
07:54:58 <LoganCapaldo> you could but you have to build your list backwards
07:55:00 <LoganCapaldo> :(
07:55:14 <kpreid> LoganCapaldo: the compiler infers stack effects (number of values in and out); not sure whether it infers types. it's all optional, but unanalysable code won't compile
07:55:28 <LoganCapaldo> mmm
07:55:48 <LoganCapaldo> well you'd do it like [ 1 2 3 4 ] sum probbaly in facotr anyway
07:56:09 * kpreid has a Haskell interpreter that can evaluate code that won't typecheck :-)
07:56:15 <LoganCapaldo> sweet
07:56:23 <kpreid> it even does type classes!
07:56:29 <EvilTerran> how do [ and ] work? are they commands, or special syntax?
07:56:44 <LoganCapaldo> same way they would in forth about I imagine
07:56:55 <EvilTerran> kpreid, how does that work? quietly insert unsafeCoerce when no-one's looking?
07:57:03 <LoganCapaldo> [ takes over the reader thingy and grabs stuff til it sees a ]
07:57:04 <kpreid> EvilTerran: no
07:57:18 <Philippa_> kpreid: that's an impressive combination, what happens when you need to find the instance for an unknown type?
07:57:20 <kpreid> LoganCapaldo: actually, it's { 1 2 3 4 } -- [] are for code quotation
07:57:29 <LoganCapaldo> oops
07:57:29 <EvilTerran> kpreid, that was a joke ;) ... how does it work, though? is there a paper about it or sth?
07:57:47 <kpreid> Philippa_: it defers determining the value until the instance can be known
07:58:28 <roconnor> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
07:58:30 <lambdabot>  5
07:58:40 <kpreid> one thing it doesn't do is handle type parameters properly
07:58:48 <kpreid> it won't blink at [Just 0, [1]]
07:59:15 <kpreid> clearly I should publish this...
07:59:24 <roconnor> let start f = f (); push s a f = f (a,s); eval (a,(b,s)) f = f (a b,s); end (a,_) = a in start push 2 push 3 push (+) eval eval end
07:59:34 <roconnor> > let start f = f (); push s a f = f (a,s); eval (a,(b,s)) f = f (a b,s); end (a,_) = a in start push 2 push 3 push (+) eval eval end
07:59:35 <lambdabot>  5
07:59:53 <LoganCapaldo> Hey is there like a write yourself a H-M type checker in 48 hours dealy out there on the interwebs?
08:01:04 <kpreid> LoganCapaldo: if you find out, let me know -- I was just recently thinking of doing something H-Mish
08:01:12 <kpreid> it seems straightforward from wikipedia, though
08:02:39 <kpreid> wow, this interpreter is even cruftier than I remembered
08:02:46 <kpreid> hpaste: url?
08:02:46 <hpaste> Haskell paste bin: http://hpaste.org/
08:02:53 <roconnor> @remember stack-calculator let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
08:02:53 <lambdabot> Done.
08:03:02 <roconnor> @quote stack-calculator
08:03:02 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
08:03:09 <LoganCapaldo> kpreid: the notation on wikipedia is making me go crossed eyed
08:03:26 <LoganCapaldo> I guess I need to pony up for TAPL or something
08:03:58 <hpaste>  kpreid pasted ""dynamic" Haskell interpreter with type classes" at http://hpaste.org/3010
08:04:12 <kpreid> Philippa_, EvilTerran: there you go :-)
08:04:23 <EvilTerran> ta
08:04:29 <kpreid> it's crufty and hard-wired, but it does work
08:04:42 <kpreid> ...for some code :)
08:04:59 <kpreid> the magic is in VaryResult and VaryArg
08:05:17 <LoganCapaldo> the fact that you can fit that on hpaste is mind boggling.
08:06:29 <roconnor> I always think it should be start 2 push 3 push add end.
08:06:45 <EvilTerran> hmm
08:07:03 <MyCatVerbs> Halllooooo, #haskell.
08:07:07 <EvilTerran> or just start 2 3 add end
08:07:33 <roconnor> yeah, that would be harder :'(
08:07:38 <roconnor> oh wait
08:07:44 <roconnor> we can overload the num class
08:07:59 <EvilTerran> although that'd need overlapping instances so it wouldn't complain that someone might instance Num (typeOf end)
08:08:03 <roconnor> in that case it ought to be easy :)
08:08:11 <EvilTerran> hm. we might be thinking of different implementations here.
08:08:27 <roconnor> yeah, I'm thinking of Cale's implemenation that I found.
08:09:00 <EvilTerran> i was envisaging a printf-style monstrosity
08:10:05 <EvilTerran> or something like that iI ... Ii "idiom brackets" hack
08:11:14 <kpreid> that was in the Applicative paper, right?
08:11:36 <EvilTerran> yeah, i think so
08:12:06 <mux> @hoogle handleToFd
08:12:07 <lambdabot> No matches found
08:15:31 <LoganCapaldo> @hoogle Handle -> IO Int
08:15:32 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
08:15:32 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
08:15:32 <lambdabot> System.IO.hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
08:15:41 <LoganCapaldo> @hoogle Handle -> IO Fd
08:15:41 <lambdabot> No matches, try a more general search
08:15:45 <LoganCapaldo> ah well
08:15:48 <LoganCapaldo> I tried
08:15:52 <LoganCapaldo> heh
08:16:54 <allbery_b> @hoogle FD
08:16:54 <lambdabot> System.Posix.Types.Fd :: CInt -> Fd
08:16:54 <lambdabot> System.Posix.Types.Fd :: newtype Fd
08:16:54 <lambdabot> Network.Socket.fdSocket :: Socket -> CInt
08:17:28 <allbery_b> @hoogle Handle -> Fd
08:17:28 <lambdabot> No matches, try a more general search
08:48:28 * mux wishes for Handle -> IO (Ptr CFile)
09:49:41 <tehgeekmeister> how do i map an io action over a list of values (printing a number along with some surrounding text)?
09:49:57 <tehgeekmeister> (the surrounding text is constant, tho.)
09:50:17 <Saizan> ?type mapM
09:50:22 <ddarius> :t mapM_
09:50:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:50:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:50:51 <tehgeekmeister> thanks
09:50:51 <tehgeekmeister> =]
09:51:12 <Saizan> like mapM_ (\n -> putStrLn $ "number is:" ++ show n) [1..10]
09:51:28 <EvilTerran> @src mapM
09:51:28 <lambdabot> mapM f as = sequence (map f as)
09:51:41 <EvilTerran> sequence(_) are also useful to know
09:52:00 <ddarius> foldr is also useful to know
09:52:12 <LoganCapaldo> the future is also useful to know
09:52:14 <EvilTerran> sequence = foldr (liftM (:)) (return []), iirc
09:52:33 <EvilTerran> so you gotta know foldr to know sequence! (or not :P)
09:52:42 <shachaf> liftM2, no?
09:52:52 <shachaf> @src sequence
09:52:52 <lambdabot> sequence ms = foldr k (return []) ms
09:52:52 <EvilTerran> yes, my error
09:52:52 <lambdabot>     where
09:52:52 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
09:53:00 <LoganCapaldo> liftM2
09:53:43 <chessguy> EvilTerran, you can write sequence without a fold
09:53:56 <EvilTerran> <EvilTerran> ... (or not :P)
09:54:25 <shachaf> chessguy: Of course; you can write anything without a fold.
09:54:35 <EvilTerran> i know that, i just felt that foldr version's worth mentioning in the context of a discussion about sequence and foldr
09:54:58 <chessguy> yeah yeah, i know, you can do anything with anything, blah blah blah
09:55:09 <EvilTerran> X combinator! :D
09:55:43 <LoganCapaldo> member meumble turing complete mumble mumble
09:55:54 <LoganCapaldo> I mumbled my mumbles
09:55:54 <olsner> turing-complete combinators <3
09:55:55 <shachaf> @let x a = a (\x y z -> x z (y z)) (\x _ -> x)
09:56:00 <shachaf> Yes?
09:56:00 <lambdabot> Defined.
09:56:12 <chessguy> this is why i hate describing things as turing complete
09:56:17 <chessguy> i mean, so what?
09:56:25 <olsner> @ty \a ->  a (\x y z -> x z (y z)) (\x _ -> x)
09:56:27 <LoganCapaldo> that was my point I think
09:56:27 <lambdabot> forall t t1 t2 t3 t4 t5. (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t3) -> t5) -> t5
09:56:34 <shachaf> chessguy: Are you turing-complete?
09:56:42 <chessguy> ?
09:56:53 <LoganCapaldo> I dunno, does he need inifinite memory?
09:56:56 <pjd> was Turing complete?
09:57:12 <LoganCapaldo> @remember pjd was Turing complete?
09:57:12 <lambdabot> Done.
09:57:23 <fax> ?djinn forall t t1 t2 t3 t4 t5. (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t3) -> t5) -> t5
09:57:23 <lambdabot> f a = a (\ b c d -> b d (c d)) (\ e _ -> e)
09:57:27 <fax> ..omg
09:57:38 <fax> lambdabot++
09:57:40 <tac-tics> > 1 + 2 + 3
09:57:41 <lambdabot>  6
09:57:49 <shachaf> djinn++ , you mean.
09:57:56 <tehgeekmeister> are there versions of print that don't output a " on either side of the output?
09:57:59 <olsner> @karma djinn
09:57:59 <lambdabot> djinn has a karma of 0
09:58:06 <fax> lambdabot: responded fast :P
09:58:09 <shachaf> @karma+ djinn
09:58:09 <lambdabot> djinn's karma raised to 1.
09:58:14 <LoganCapaldo> tehgeekmeister: print = putStrLn . show
09:58:29 <LoganCapaldo> so print is sort of a bad name imo
09:58:45 <EvilTerran> tehgeekmeister, you might want putStr or putStrLn, depending on what you're after
09:58:50 <LoganCapaldo> but haskell is forever doing that anyway :)
09:58:59 <LoganCapaldo> (eg return)
09:59:11 <shachaf> LoganCapaldo: Is Ruby's "p" a better name?
09:59:19 <LoganCapaldo> not really
09:59:58 <tehgeekmeister> hmm, it's doing the same with either putStrLn and print.
10:00:02 <LoganCapaldo> print just has a lot of baggage from othe rlanguages as a name
10:00:17 <LoganCapaldo> so it's a personal problem :)
10:00:25 <olsner> @pl \a -> a (\ b c d -> b d (c d)) (\ e _ -> e)
10:00:25 <lambdabot> flip ($ ap) const
10:00:31 <EvilTerran> @paste, tehgeekmeister?
10:00:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:00:35 <LoganCapaldo> tehgeekmeister: that seems unlikely
10:01:01 <pjd> LoganCapaldo: print seems very sensible, coming from Python
10:01:04 <EvilTerran> alternatively, did you remember to save (and recompile/reload, as appropriate)? i've made that mistake a fewtimes...
10:01:05 <shachaf> tehgeekmeister: Are you also typing the "show"?
10:01:28 <tehgeekmeister> i need the show to convert the int to a string, but otherwise, no.
10:01:30 <tehgeekmeister> *pastes
10:01:34 <shachaf> pjd: Does "print 'abc'" print "abc" in Python (with quotes)?
10:01:36 <LoganCapaldo> isn't it print in scheme or something too?
10:01:53 <hpaste>  tehgeekmeister pasted "exercise from YAHT" at http://hpaste.org/3011
10:01:54 <shachaf> tehgeekmeister: You may be showing twice, somehow.
10:01:56 <olsner> scheme has display iirc
10:02:07 <pjd> shachaf: a minor detail
10:02:40 <pjd> Python's print does the equivalent of show;  it just has two variations of show
10:02:44 <LoganCapaldo> My problem is my first language was a basic, and print meant putStr(Ln) :)
10:03:04 * tehgeekmeister retracts his statement
10:03:08 <tehgeekmeister> there was a rogue print
10:03:12 <tehgeekmeister> my fault.
10:03:20 <shachaf> pjd: In which instance Show String where show = id?
10:04:05 <pjd> shachaf: for str(), yes
10:04:07 <shachaf> LoganCapaldo: Really? What did "print 5" do?
10:04:19 <pjd> repr() would be the truer equivalent of Show
10:04:23 <shachaf> Python has str() and repr(), right?
10:04:27 <LoganCapaldo> well yes
10:04:32 <shachaf> Like Ruby's to_s and inspect.
10:04:33 <pjd> shachaf: yes
10:05:09 <tehgeekmeister> out of curiosity, are there any limits on integers?  (not ints)
10:05:23 <bos> just memory and time
10:05:24 <LoganCapaldo> your addressable memory
10:05:25 <stepcut> tehgeekmeister: heat death
10:05:41 <tehgeekmeister> that's useful.
10:06:01 <bos> pretty normal for bignums
10:06:04 <EvilTerran> > 10^1000
10:06:16 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
10:06:30 <ddarius> EvilTerran: That's a rather small number.
10:06:52 <EvilTerran> eh, gotta start somewhere
10:07:06 <LoganCapaldo> > foldr (**) [9,9..]
10:07:07 <lambdabot>   add an instance declaration for (Floating [t])
10:07:07 <shachaf> > 0
10:07:09 <lambdabot>  0
10:07:16 <EvilTerran> > 10^(10^1000)
10:07:17 <LoganCapaldo> > foldr (^) [9,9..]
10:07:18 <lambdabot>   add an instance declaration for (Integral [t])
10:07:20 <lambdabot> Terminated
10:07:25 <shachaf> > foldr1 (**) [9,9..]
10:07:26 <lambdabot>  Exception: stack overflow
10:07:30 <olsner> > foldr (^) 10 (replicate 10 10)
10:07:34 <lambdabot> Terminated
10:07:42 <olsner> > foldr (^) 10 (replicate 5 10)
10:07:46 <lambdabot> Terminated
10:07:51 <olsner> > foldr (^) 10 (replicate 3 10)
10:07:53 <paczesiowa> > 1
10:07:55 <lambdabot>  1
10:07:56 <lambdabot> Terminated
10:08:07 <EvilTerran> ...
10:08:13 <EvilTerran> > 10^(10^10)
10:08:17 <lambdabot> Terminated
10:08:33 <EvilTerran> must take too long to show it or something
10:08:49 <LoganCapaldo> > let g = foldr (^) 9 [g,g..] in g
10:08:49 <paczesiowa> isn't (^) right associative?
10:08:51 <lambdabot>  Exception: stack overflow
10:08:57 <EvilTerran> > 2^2^2
10:08:58 <lambdabot>  16
10:09:09 <EvilTerran> wait, that one's not a good example
10:09:12 <paczesiowa> :D
10:09:17 <paczesiowa> > 2^2^3
10:09:18 <lambdabot>  256
10:09:30 <EvilTerran> > (2^3^4,2^(3^4),(2^3)^4)
10:09:32 <lambdabot>  (2417851639229258349412352,2417851639229258349412352,4096)
10:09:53 <paczesiowa> so it is
10:10:06 <LoganCapaldo> @info (^)
10:10:07 <lambdabot> ((^))
10:10:09 <EvilTerran> it makes sense, really, seeing as (a^b)^c = a^(b*c), so associating to the left'd be redundant
10:10:11 <LoganCapaldo> gah
10:10:25 <EvilTerran> but there isn't another succinct representation of a^(b^c)
10:11:56 <paczesiowa> > foldl (^) 10 (replicate 3 10)
10:11:57 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
10:12:02 <paczesiowa> > foldr (^) 10 (replicate 3 10)
10:12:05 <lambdabot> Terminated
10:12:21 <LoganCapaldo> > ['1','0
10:12:21 <lambdabot>  Improperly terminated character constant
10:12:27 <EvilTerran> > foldl1 (^) (replicate 5 2)
10:12:28 <lambdabot>  65536
10:12:29 <LoganCapaldo> > ['1','0','0'..]
10:12:29 <lambdabot>  Parse error
10:12:30 <EvilTerran> > foldr1 (^) (replicate 5 2)
10:12:31 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
10:12:47 <LoganCapaldo> > '1':['0','0' ..]
10:12:48 <lambdabot>  "100000000000000000000000000000000000000000000000000000000000000000000000000...
10:12:50 <EvilTerran> > '1':repeat 0
10:12:51 <lambdabot>   add an instance declaration for (Num Char)
10:12:55 <EvilTerran> > '1':repeat '0'
10:12:57 <lambdabot>  "100000000000000000000000000000000000000000000000000000000000000000000000000...
10:13:10 <LoganCapaldo> > read $ '1':['0','0' ..]
10:13:14 <lambdabot> Terminated
10:13:25 <LoganCapaldo> read is too strict! boo :)
10:13:39 <EvilTerran> i think it's more that Integer is too stricta
10:14:06 <tehgeekmeister> it's okay to put a type signature inline in the case of numbers?  like 5::int in an expression?
10:14:06 <monochrom> > read (show fix)
10:14:07 <lambdabot>  Add a type signature
10:14:13 <monochrom> > read (show fix) :: String
10:14:14 <lambdabot>  Add a type signature
10:14:22 <LoganCapaldo> > read $ repeat '"'
10:14:23 <lambdabot>  Exception: Prelude.read: no parse
10:14:23 <monochrom> > read (fix show) :: String
10:14:27 <lambdabot> Terminated
10:14:31 <EvilTerran> tehgeekmeister, yes, but bear in mind that :: is lower precedence than any infix operator, so you may need brackets
10:14:32 <monochrom> read is too strict
10:14:57 <shachaf> > show fix
10:14:58 <lambdabot>  Add a type signature
10:14:59 <EvilTerran> monochrom, okay, that works for the String instance, yeah
10:15:01 <EvilTerran> > fix show
10:15:03 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
10:15:17 <shachaf> Why does (show fix) say that?
10:15:33 <EvilTerran> ?type fix
10:15:35 <lambdabot> forall a. (a -> a) -> a
10:15:46 <monochrom> > read (['"', 'a'] ++ undefined ) :: String
10:15:48 <lambdabot>  Undefined
10:15:56 <shachaf> > show id
10:15:56 <lambdabot>  Add a type signature
10:16:04 <EvilTerran> with a type for (a), it'd be able to tell if there were an instance Show ((a->a)->a), i guess
10:16:05 <opqdonut> shachaf: because when show takes a string it outputs "
10:16:23 <shachaf> opqdonut: (show fix).
10:16:23 <opqdonut> > take 1 $ show (undefined :: String)
10:16:24 <lambdabot>  "\""
10:16:27 <opqdonut> there
10:16:29 <shachaf> opqdonut: Not (fix show).
10:16:31 <monochrom> show fix is a typo
10:16:35 <shachaf> I know.
10:16:39 <olsner> > head (read (['"', 'a'] ++ undefined ) :: String)
10:16:40 <lambdabot>  Undefined
10:16:45 <opqdonut> yeah fix show
10:16:49 <shachaf> Why does it ask for a type signaure, though?
10:17:10 <opqdonut> because a->a is too general and can't be unified with a showable type
10:17:14 <Saizan> ?type show fix
10:17:16 <lambdabot>     No instance for (Show ((a -> a) -> a))
10:17:16 <lambdabot>       arising from use of `show' at <interactive>:1:0-7
10:17:22 <opqdonut> ghc won't say "no instance" because ...
10:17:28 <opqdonut> oh wait it does say no instance
10:17:34 <shachaf> ?ty show id
10:17:36 <lambdabot>     No instance for (Show (a -> a))
10:17:36 <lambdabot>       arising from use of `show' at <interactive>:1:0-6
10:17:39 <Saizan> > show (fix :: (Int -> Int) -> Int)
10:17:42 <lambdabot>  "<(Int -> Int) -> Int>"
10:17:52 <monochrom> lambdabot's > abstracts away from error messages.
10:17:56 <EvilTerran> ?instances Show
10:17:57 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
10:17:59 <Saizan> shachaf: that's why
10:18:05 <shachaf> Oh, it only works with concrete types?
10:18:09 <shachaf> OK.
10:18:17 <shachaf> > show (+1)
10:18:18 <lambdabot>  "<Integer -> Integer>"
10:18:24 <monochrom> probably only works for Typeable types.
10:18:40 <shachaf> Yes.
10:27:25 <sorear> > take 2 (show (show (undefined :: [Char])))
10:27:37 <lambdabot>  "\"\\"
10:29:47 <vincenz> > take 3 (show (show (undefined :: [Char])))
10:29:49 <lambdabot>  "\"\\\""
10:30:02 <vincenz> 4 will boom
10:30:05 <vincenz> sorear: going to Hac?
10:30:15 <sorear> no
10:30:36 <shachaf> That's in Germany, isn't it?
10:30:43 <vincenz> yes
10:31:26 * sorear is not
10:31:37 * vincenz isn't either
10:32:37 * allbery_b never goes anywhere :(
10:32:52 <allbery_b> (otoh what would I do there?  I'm really a sysadmin...)
10:33:51 <monochrom> You can admin the sys there... :)
10:36:27 <vincenz> Would a Data.Trie be appreciated?
10:36:36 <LoganCapaldo> No!
10:36:44 <LoganCapaldo> take your data sructures and go!
10:36:51 <LoganCapaldo> No one appreciates them!
10:36:59 <LoganCapaldo> :-p
10:37:10 <allbery_b> unless you make ti an Arrow?
10:37:12 <monochrom> data structures get depreciated only
10:40:04 <vincenz> are you serious?
10:40:11 * vincenz has a partial implementation
10:40:15 <vincenz> with an interface matching Map
10:40:18 <vincenz> was thinking of finishing that
10:40:35 <monochrom> I am not serious. :)
10:40:43 <vincenz> LoganCapaldo: ?
10:40:58 <LoganCapaldo> I was kiding :)
10:41:09 <monochrom> I think he is speaking in such a hyperbole it can't be true. :)
10:41:10 <vincenz> is that like chiding but like a kid?
10:41:44 <LoganCapaldo> it's like joking but with goats?
10:42:25 * LoganCapaldo has got to stop trying to be funny
10:42:43 <monochrom> There is some truth in my "get depreciated only". When a new data structure is invented, it is highly acclaimed. After many years, people say "it's trivial".
10:42:56 <iguana_> @yarr
10:42:56 <lambdabot> I'll keel haul ya fer that!
10:43:04 <vincenz> @keal
10:43:04 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
10:45:28 <xs> hi! does anyone happen to know of a handy numerical approximation to the regularised gamma function in haskell?
10:46:19 <b_jonas> xs: re gamma function: http://www.rskey.org/gamma.htm
10:46:21 <lambdabot> Title: Programmable Calculators: Calculators and the Gamma Function
10:47:47 <xs> b_jonas: thanks! the approximation at the end looks good!
11:01:17 <tehgeekmeister> ?src mapM_
11:01:17 <lambdabot> mapM_ f as = sequence_ (map f as)
11:01:30 <tehgeekmeister> ?src sequence_
11:01:30 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:01:59 <xs> b_jonas: aha! by the way, i've just found that GSLHaskell has the requisite bindings. :)
11:12:57 <b_jonas> @src Maybe mplus
11:12:57 <lambdabot> Nothing `mplus` ys  = ys
11:12:57 <lambdabot> xs      `mplus` _ys = xs
11:13:20 <vincenz> @src [] mplus
11:13:21 <lambdabot> mplus = (++)
11:13:28 <vincenz> @src Either Error mplus
11:13:28 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:13:35 <vincenz> @src (Either Error) mplus
11:13:35 <lambdabot> Source not found. Are you on drugs?
11:13:42 <vincenz> Yes, monadic sugar!
11:14:15 <monochrom> @src Either mplus
11:14:16 <lambdabot> Left _ `mplus` n = n
11:14:16 <lambdabot> m      `mplus` _ = m
11:14:27 <b_jonas> @src Maybe >>=
11:14:27 <lambdabot> Source not found. My pet ferret can type better than you!
11:14:38 <b_jonas> @src Maybe (>>=)
11:14:39 <lambdabot> (Just x) >>= k      = k x
11:14:39 <lambdabot> Nothing  >>= _      = Nothing
11:14:46 <b_jonas> @src Maybe return
11:14:46 <lambdabot> return              = Just
11:17:04 <b_jonas> @hoogle [Maybe a] -> Maybe a
11:17:05 <lambdabot> No matches, try a more general search
11:17:23 <pjd> catMaybes?
11:17:29 <b_jonas> no, that gives a list
11:17:35 <b_jonas> it's [Maybe a] -> [a]
11:17:47 <b_jonas> I want the first Just, so I'll use msum
11:17:50 <pjd> ah, right
11:17:57 <b_jonas> and pretend m means maybe
11:17:58 <pjd> head . catMaybes?
11:18:24 <pjd> or fromList, not head
11:19:12 <b_jonas> yeah, or something like foldr flip fromMaybe
11:19:19 <pjd> ...listToMaybe, even
11:19:54 <b_jonas> no, that's no good
11:20:09 <newsham> are there programs that do step-wise reduction of haskell programs until the result is derived?  can lambdabot do this?
11:20:10 <b_jonas> oh, listToMaybe . catMaybes
11:20:11 <b_jonas> I see
11:20:16 <b_jonas> yeah, that can work
11:20:41 <b_jonas> but msum sounds short enough
11:21:00 * kaol watches the type errors die in his code one by one, as he figures out what his code was supposed to do, really
11:21:13 <chessguy> @quote melted
11:21:13 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
11:21:19 <b_jonas> > msum [Nothing, Nothing, Just 2, Nothing, Just 5, Just 1, Nothing]
11:21:21 <lambdabot>  Just 2
11:21:37 <pjd> b_jonas: yeah, that's better
11:21:56 <newsham> > msum [[], [], [1,2], [], [3,4]]
11:21:57 <lambdabot>  [1,2,3,4]
11:22:53 <LoganCapaldo> @src msum
11:22:53 <lambdabot> msum =  foldr mplus mzero
11:23:03 <pjd> > id =<< [[], [], [1,2], [], [3,4]]
11:23:03 <LoganCapaldo> I somehow expected foldM
11:23:04 <lambdabot>  [1,2,3,4]
11:23:11 <LoganCapaldo> hey wait!
11:23:12 <newsham> > [] `mplus` [] `mplus` [2,3] `mplus` [1,4]
11:23:14 <lambdabot>  [2,3,1,4]
11:23:22 <oerjan> > fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap return "fmap" id id id
11:23:26 <lambdabot>  ghc: failed with error code 9
11:23:28 <newsham> > Nothing `mplus` Just 3 `mplus` Just 5
11:23:30 <lambdabot>  Just 3
11:23:31 <LoganCapaldo> @src sum
11:23:31 <lambdabot> sum = foldl (+) 0
11:23:34 <LoganCapaldo> BAH
11:23:47 <LoganCapaldo> sum = foldl mappend mempty
11:24:11 <oerjan> > fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap return "fmap" id id id
11:24:13 <lambdabot>  "fmap"
11:24:29 <LoganCapaldo> Oh I guess theres too many  possible defns for mempty and mappend for numbers for that to be useful
11:24:32 <shachaf> glguy: Did you get my message about NM?
11:26:10 <LoganCapaldo> > mempty :: Maybe ()
11:26:11 <lambdabot>   add an instance declaration for (Monoid (Maybe ()))
11:26:11 <lambdabot>     In the expression: ...
11:26:17 <LoganCapaldo> What?
11:26:19 <LoganCapaldo> booooo
11:27:08 <chessguy> @src Monoid
11:27:08 <lambdabot> class Monoid a where
11:27:08 <lambdabot>     mempty  :: a
11:27:08 <lambdabot>     mappend :: a -> a -> a
11:27:08 <lambdabot>     mconcat :: [a] -> a
11:27:10 <shachaf> > getSum $ mconcat (map Sum [1,2,3])
11:27:11 <lambdabot>  6
11:27:24 <oerjan> > mzero :: Maybe ()
11:27:25 <lambdabot>  Nothing
11:27:31 <LoganCapaldo> yeah Iknow
11:27:59 <mike__> > data Foo a = Foo a | Bar a
11:27:59 <lambdabot>  Parse error
11:28:16 <LoganCapaldo> no type declarations
11:28:58 <byorgey> LoganCapaldo: there are multiple options for a Monoid Maybe instance.
11:29:01 <b_jonas_> @src Maybe fmap
11:29:01 <lambdabot> fmap _ Nothing       = Nothing
11:29:01 <lambdabot> fmap f (Just a)      = Just (f a)
11:29:15 <LoganCapaldo> byorgey: do tell
11:29:19 <oerjan> it could be mplus, or >>
11:29:41 <LoganCapaldo> hmm
11:29:52 <LoganCapaldo> that sucks
11:30:35 <oerjan> although you could have had the same trick as with numbers, a newtype for each case
11:30:38 <b_jonas_> so that's like flip >>=
11:30:40 <byorgey> also, sum = getSum . foldl mappend mempty . map Sum =)
11:30:55 <newsham> anyone know a program that can show haskell reductions/derivations?
11:31:10 <misterbeebee> \me left room as mike__, back in as misterbeebee
11:31:23 <misterbeebee> had some Colloquy trouble (IRC client)
11:31:24 <shachaf> /me, you mean. :-)
11:31:27 <LoganCapaldo> b_jonas: no, =<< is like flip >>=
11:31:33 * misterbeebee is /me
11:31:35 <misterbeebee> yes
11:31:43 <oerjan> newsham: i've seen it discussed on haskell-cafe, i think, and the answer was no, for any substantial part of it
11:31:47 <b_jonas_> @src (=<<) -- what's that
11:31:47 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:31:50 <misterbeebee> > data Foo a = Foo a | Bar a
11:31:50 <lambdabot>  Parse error
11:31:58 <byorgey> (=<<) = flip (>>=)
11:32:01 <b_jonas_> @type (=<<)
11:32:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:32:06 <b_jonas_> I see
11:32:11 <misterbeebee> That line worked in ghc. is it bad in interactive shell?
11:32:12 <ddarius> @src (=<<)
11:32:13 <lambdabot> f =<< x = x >>= f
11:32:14 <LoganCapaldo> @type liftM
11:32:14 <b_jonas_> but fmap is the same as that for monads, isn't it?
11:32:16 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:32:19 <b_jonas_> for maybes I mean
11:32:21 <LoganCapaldo> no
11:32:22 <oerjan> it's simply too complicated if you want to do it precisely with type classes and all
11:32:29 <shachaf> misterbeebee: Yes.
11:32:41 <byorgey> misterbeebee: yeah, you can't define data types in an interactive session.
11:32:45 <b_jonas_> > (\x -> 2 * x) =<< Just 5
11:32:46 <lambdabot>   add an instance declaration for (Num (Maybe b))
11:32:46 <shachaf> misterbeebee: At least in ghci and lambdabot.
11:32:47 <newsham> oerjan: humans seem to be able to do it ;-)
11:32:54 <LoganCapaldo> @type fmap
11:32:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:32:58 <LoganCapaldo> @type =<<
11:33:00 <lambdabot> parse error on input `=<<'
11:33:07 <LoganCapaldo> @type (=<<)
11:33:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:33:10 <misterbeebee> oh, that's sad. anyway. my question is, is that bad style? The two Foos are in different namespaces, but it's needlessly confusing to me
11:33:11 <shachaf> You want return $.
11:33:14 <byorgey> > return (\x -> 2 * x) =<< Just 5
11:33:15 <lambdabot>  Couldn't match expected type `(->) b' against inferred type `Maybe'
11:33:27 <LoganCapaldo> b_jonas_: see?
11:33:31 <shachaf> Well, not necessarily.
11:33:33 <byorgey> > return . (\x -> 2 * x) =<< Just 5
11:33:34 <lambdabot>  Just 10
11:33:41 <shachaf> It depends on the context, I think.
11:33:45 <kscaldef> http://kevin.scaldeferri.com/blog/2007/09/29/UrlSpider1HaXML.html
11:33:47 <kscaldef> http://kevin.scaldeferri.com/blog/2007/09/30/UrlSpider2HXT.html
11:33:47 <lambdabot> Title: Kevin's Weblog 2007-09-29
11:33:49 <lambdabot> Title: Kevin's Weblog 2007-09-30
11:33:50 <b_jonas_> I see
11:33:50 <misterbeebee> what i saw that annoyed me was this:
11:33:51 <b_jonas_> makes sense
11:33:51 <misterbeebee> > data Node a = Leaf a | Node (Node a) (Node a) (Node a)
11:33:52 <lambdabot>  Parse error
11:34:01 <misterbeebee> prefer this:
11:34:02 <newsham> > liftM (2*) (Just 5)
11:34:03 <lambdabot>  Just 10
11:34:09 <kscaldef> exposition on my attempt to write a web spider using the various XML libraries
11:34:10 <shachaf> Oh, that seems to make sense.
11:34:27 <misterbeebee> data Tree a  = Leaf a | Node (Tree a) (Tree a) (Tree a)
11:34:39 <shachaf> That also makes sense.
11:34:52 <misterbeebee> It's like typedefs and structs in C.
11:34:57 <shachaf> Perhaps "Tree" is a bit nicer in some cases.
11:34:59 <misterbeebee> typedef struct Foo { } Foo;
11:35:11 <misterbeebee> I prefer typedef struct Foo {} FooT;
11:35:28 <b_jonas_> on the other hand, isn't using maybes as monadpluses a special case of using lists as monadpluses, when you only listToMaybe of the resulting list at the end?
11:35:33 <misterbeebee> I came across that code in: http://en.wikibooks.org/wiki/Haskell/Zippers#Differentiation_of_data_types
11:35:33 <oerjan> newsham: humans make simplifications, like ignoring the passing of class dictionaries
11:35:35 <lambdabot> http://tinyurl.com/3cauba
11:35:47 <byorgey> misterbeebee: yeah, using the same name for a type and a type constructor can be confusing.
11:35:51 <shachaf> > [1] `mplus` [2]
11:35:53 <lambdabot>  [1,2]
11:35:58 <misterbeebee> in educational material, I'd rather not see the same word mean two different things in one line
11:36:04 <byorgey> misterbeebee: edit it =)
11:36:12 <misterbeebee> i was about to, but I wanted confirmation
11:36:21 <shachaf> It seems so, yes.
11:36:24 <byorgey> I say, go for it.
11:36:46 <b_jonas_> shachaf: well, you'd have to check that >>= and return work the same as well
11:37:06 <LoganCapaldo> Maybe is "just" a 1 element list
11:37:12 <ddarius> Well many (most?) Haskell programmers write code that way in practice
11:37:18 <LoganCapaldo> rather a 0 or 1 element list
11:37:32 <shachaf> newsham: Maybe ghci-6.7's debugger can do something?
11:37:33 <b_jonas_> LoganCapaldo: you mean, it's the same as such a list if you use it as a monad?
11:38:13 <oerjan> b_jonas_: no. there can be differences with backtracking
11:38:18 <LoganCapaldo> no I mean it's effectively a 0 or 1 element list period
11:38:30 <monochrom> "u let u = sin t so ur equation ur = arccos u becomes r sin t = arccos (sin t)"  example of students themselves using the same word to mean two different things in one line
11:38:45 <b_jonas_> LoganCapaldo:
11:38:57 <b_jonas_> > Maybe 1 `mplus` Maybe 2
11:38:58 <lambdabot>   Not in scope: data constructor `Maybe'
11:39:07 <b_jonas_> > Just 1 `mplus` Just 2
11:39:08 <lambdabot>  Just 1
11:39:09 <shachaf> monochrom: Ugh.
11:39:15 <b_jonas_> > [1] `mplus` [2]
11:39:16 <lambdabot>  [1,2]
11:39:50 <b_jonas> so they seem to behave differently wrt monadplus
11:40:18 <LoganCapaldo> yeah because list doesn't enfore that you an have only one element
11:40:29 <LoganCapaldo> *an
11:40:31 <LoganCapaldo> *can
11:40:50 <b_jonas> but it still makes sense to do mplus in both of these cases I gues
11:41:01 <monochrom> "it converges, therefore its limit is 0"  another example of students themselves using the same word "it" to mean two different things. The intention is: Sum a_i converges, therefore lim a_i = 0.
11:41:27 <oerjan> > let a () = do x <- (return 1) `mplus` (return 2); guard (even x); return x in (a () :: Maybe Int, a () :: [Int])
11:41:29 <lambdabot>  (Nothing,[2])
11:41:38 <oerjan> b_jonas: ^^
11:42:03 <LoganCapaldo> I want to say that Maybe a is isomorphic to [a] of less than 2 elements but I'm afeared I will be playing too fast and loose with the meaning of isomorphic and will get in trouble :)
11:42:20 <oerjan> LoganCapaldo: i just showed a counterexample
11:43:02 <LoganCapaldo> and that's why I didn't say it
11:43:08 <b_jonas> oerjan: ah, I see
11:43:40 <LoganCapaldo> Also I'm not trying to make as strong a sounding claim as it appears I'm getting across
11:43:42 <b_jonas> LoganCapaldo: isomorphic makes sense only if you tell what operations you mean
11:44:09 <b_jonas> typically, you'd say that all methods in a certain class behave the same on the two
11:44:36 <LoganCapaldo> I just mean you can doing anything with a 0 or 1 element list that you can do with a maybe
11:44:43 <oerjan> typically you want the operations to commute with the isomorphism
11:44:45 <b_jonas> so, as oerjan's shown, they're not isomorphic as MonadPluses
11:45:01 <b_jonas> but they're still isomorphic as Monads probably
11:45:10 <b_jonas> so what I said originally was false
11:45:18 <LoganCapaldo> But I don't mean that you can just swap one for the other without changigng the definitions of these functions and get the exact same result
11:45:23 <misterbeebee> LoganCapaldo: your idea breaks down when you think about overflow (that's what oerjan's counterexample shows)
11:45:37 <LoganCapaldo> just that you could do without Maybe
11:45:43 <misterbeebee> Maybe "truncates" when you combine two Just values, but List doesn't
11:45:52 <LoganCapaldo> or you could do newtype Maybe a = Maybe [a]
11:45:57 <LoganCapaldo> yteah I know
11:46:14 <LoganCapaldo> but you could provide truncating operations for lists
11:46:16 <oerjan> :t maybeToList
11:46:18 <lambdabot> forall a. Maybe a -> [a]
11:46:46 <oerjan> technically, maybeToList is probably a homomorphism as monads but not monadpluses
11:46:46 <b_jonas> LoganCapaldo: you could, but that's not what their Monadplus instance does in the library
11:46:51 <misterbeebee> you'd have to define a different (from the usual) behavior of bind on lists then.
11:47:01 <LoganCapaldo> I know!
11:47:17 <LoganCapaldo> I'm not saying this is the way it is, I'm saying it could be this way :)
11:47:35 <misterbeebee> ok. sorry, I missed some lines in the chat history. sorry.
11:47:48 <b_jonas> on the other hand, list is probably more useful the way it is
11:47:53 <LoganCapaldo> I knew it was going to end up like this as soon as I said it :)
11:48:31 <misterbeebee> Yes, you can model Maybe as a modified List. Aboslutely.
11:48:42 <misterbeebee> That's a Lispy way of thinking :)
11:49:04 <b_jonas> I think no
11:49:07 <oerjan> or maybe maybeToList is a natural transformation between functors Maybe and []
11:49:43 <b_jonas> the lispy way is not to use explicit maybes unless you have to, instead just model Just x with x and Nothing with a value that's not in the domain of x-s
11:49:58 <ddarius> oerjan: Every polymorphic function between functors is a natural transformation.
11:50:25 <oerjan> ddarius: oh right
11:50:48 <misterbeebee> If you use nil for Nothing, and ((lambda x) (cons x nil) for Just, and define mplus appropriately...
11:51:50 <LoganCapaldo> ddarius: so join is a natural transformation as well?
11:51:58 <ddarius> Yese.
11:52:00 <ddarius> -e
11:52:20 <oerjan> LoganCapaldo: join and return from category theory are defined as such
11:52:47 <oerjan> as part of that monad definition
11:53:25 <b_jonas> it's funny how in functional languages like haskell, you can write most useful functions with very short code combining a few random library functions that happen to combine the right way
11:53:48 <ddarius> b_jonas: That's the goal.
11:54:08 <oerjan> b_jonas: that's because those library functions are not random, but selected because they're useful to combine with
11:54:09 <LoganCapaldo> But Maybe a -> Either a b would not be a natural transformation right?
11:54:21 <b_jonas> oerjan: yes, exactly
11:54:44 <oerjan> LoganCapaldo: Either is a functor in its last parameter, not the first
11:55:11 <ddarius> Either is a functor in both, you just can't conveniently write it in Haskell
11:55:21 <LoganCapaldo> oerjan: By that you mean thats how its Functor instance is defined or you mean in general?
11:55:25 <ddarius> It is still a natural transformation.
11:55:35 <oerjan> as defined, as ddarius says
11:56:11 <LoganCapaldo> Ok i think I keep losing sight of the fact that this stuff only applies at the type level
11:56:20 <ddarius> LoganCapaldo: ?
11:56:51 <LoganCapaldo> well my thought was "You can't write a function with this type (unless you use undefined) so it can't be a natural transformation"
11:57:03 <oerjan> sure you can
11:57:08 <oerjan> i think
11:57:15 <LoganCapaldo> Really?
11:57:18 <ddarius> oerjan: There is no where to put Nothing
11:57:56 <oerjan> ddarius: it doesn't need to be polymorphic in all parts, does it?
11:58:02 <ddarius> LoganCapaldo: Using undefined is not a problem (though you then need to more carefully define the category)
11:58:36 <oerjan> m2e default = maybe (Left default) Right
11:58:40 <oerjan> :t maybe
11:58:45 <ddarius> oerjan: It depends on what you say.
11:58:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:58:57 <ddarius> oerjan: If you say Maybe a -> Either a b natural in a and b then obviously it does.
11:59:24 <oerjan> i mean Maybe a -> Either b a
11:59:30 <b_jonas> but then default may have to be undefined (if b has an empty domain)
11:59:56 <oerjan> of course, it's m2e default that is the natural transformation, for each default
12:00:26 <ddarius> oerjan: Even m2e is a natural transformation in both a and b.
12:00:44 <thoughtpolice> is there any docs over what's new in 6.8 yet, since it's now considered the STABLE branch?
12:01:11 <thoughtpolice> i was thinking of taking a 6.8.0 snapshot and compiling it today to check it out.
12:01:16 <ddarius> thoughtpolice: There will be when it's released and there probably are in the src tree.
12:01:34 <oerjan> ddarius: it's essentially (a, Maybe b) -> Either a b, i guess
12:03:00 <thoughtpolice> ddarius: cool stuff. what's an ETA on a 6.8.0 release?
12:03:09 <thoughtpolice> if you happen to know, that is.
12:03:12 <shachaf> Never.
12:03:27 <thoughtpolice> postponed indefinately, huh
12:03:31 <newsham> what is "up-the-garden-path style" for us non-brits?
12:03:32 <misterbeebee> http://hackage.haskell.org/trac/ghc:  "The 6.8 branch is the current STABLE, and we are in the 6.8.1 release candidate phase. We aim to release 6.8.1 around the beginning of October."
12:03:33 <shachaf> 6.8.1 will come out sometime, though.
12:03:52 <thoughtpolice> ah, so they're just skipping to 6.8.1? that's what I thought from reading trac.
12:03:54 <shachaf> Oh, that's sooner than I thought.
12:04:19 <oerjan> i'm sure they would have liked to announce it at ICFP
12:04:21 <newsham> hrmm.. 6.8 stable?  I wonder if they addressed the freebsd/amd64 problems.
12:05:15 <shachaf> 6.8 isn't officially released, I think.
12:05:43 <misterbeebee> STABLE means that's the branch that will be stable, once the first release comes out.
12:06:16 <shachaf> Oh.
12:06:31 <LoganCapaldo>  So fmap is a naural transformation
12:06:36 <LoganCapaldo> *natural
12:06:51 <LoganCapaldo> almost sort of _the_ natural transformation :)
12:07:08 <misterbeebee> (As in, all releases of 6.8.x will be stable, as opposed to 6.8.y, which are all experimental, even after release.)
12:07:52 <ddarius> LoganCapaldo: In Haskell, yes.  In CT, fmap is operating between Hom-sets
12:08:32 <oerjan> :t fmap
12:08:32 <ddarius> Though you could say (for a small category), that fmap is a natural transformation in Set.
12:08:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:09:09 <LoganCapaldo> why does it seem like this is all so much easier to talk about and think about as long as I stay inside haskell-land?
12:09:29 <oerjan> LoganCapaldo: you have just one fairly concrete category?
12:09:34 <b_jonas> those inline kind declarations are very confusing
12:09:46 <LoganCapaldo> that's probably it
12:09:52 <ddarius> LoganCapaldo: Because (if we squint our eyes) Haskell has a lot of structure and it is all internalized.
12:10:50 <ihope> Does GHC use cooperative multitasking?
12:11:35 <ddarius> ihope: Yes and no and no.
12:11:39 <oerjan> ihope: it's not totally preemtive
12:12:02 <ihope> Hmm... actually, I guess it doesn't really matter for my purposes.
12:12:16 <ddarius> It's effectively preemptive.
12:12:18 <oerjan> if a thread never does IO or allocates memory, it won't yield
12:12:32 <oerjan> but that's fairly rare
12:12:41 <thoughtpolice> ihope: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#12
12:12:41 <oerjan> iiuc
12:12:42 <lambdabot> http://tinyurl.com/33wpmr
12:12:53 <ihope> Does sequence (repeat (return ())) allocate memory?
12:12:58 <ddarius> It's pretty hard to make useful Haskell code that doesn't allocate.
12:13:13 <b_jonas> in a lazy language, that shouldn't make a semantic difference unless some thread diverges, won't it?
12:13:14 <oerjan> ihope: it generates a list
12:13:19 <ddarius> ihope: It may but it's probably that it doesn't.
12:13:20 <b_jonas> I mean, in a pure language
12:13:24 <oerjan> but sequence_ might not
12:13:34 <ddarius> oerjan: repeat only needs to allocate one cell.
12:13:45 <oerjan> oh right...
12:13:56 <b_jonas> no wait, that was stupid
12:14:04 <thoughtpolice> hm. has anybody thought about a ghc port to QNX now that it's open source?
12:14:13 <oerjan> but sequence cannot take advantage of that without some special rules
12:14:58 <ddarius> Well sequence would allocate, yes.  I thought that was a sequence_
12:17:15 <dino-> In this STM example, is the 'milliSleep 800' action there to allow the forked guys to complete their work?  http://haskell.org/haskellwiki/Simple_STM_example
12:17:16 <lambdabot> Title: Simple STM example - HaskellWiki
12:17:23 <newsham> anyone know what "hutton's razor" is?
12:17:26 <SamB> what is special about QNX again?
12:17:42 <gaborek> Hi! I would like to join usefull, open source project but I am not advanced user, I want to learn. Can somebody help me? What should I choose?
12:17:52 <SamB> besides that livefloppy demo they had?
12:19:39 <LoganCapaldo> SamB: It's all badass and junk. I found some story on the interwebs about how this box in a closet had all its disks fail and they only discovered after months because they decided to check the log file on a whim or something
12:20:01 <SamB> ... okay ...
12:20:09 <SamB> so where did it KEEP the logfiles?
12:20:10 <LoganCapaldo> I may be exaggerating in time scale and number of failed disks
12:20:12 <ddarius> dino-: Yes and no.  It's a silly program anyway and I'm not sure what it is supposed to demonstrate.
12:20:47 <LoganCapaldo> I think it just decided not to write them anymore because it couldn't
12:21:04 <LoganCapaldo> I read this a while ago
12:21:13 <LoganCapaldo> before the most recent QNX hubbub
12:23:40 <sorear> ihope: As written, yes.  If it deforests properly, no.
12:24:10 <mudge> hey I just realized,  the emtpy list [] is a constructor
12:24:18 <mudge> right?
12:24:19 <sorear> if it deforests properly, and the root optimization kicks in, you should get a <<loop>> even
12:24:23 <sorear> @src []
12:24:23 <lambdabot> data [] a = [] | a : [a]
12:24:34 <omniscientIdiot> mudge: yep
12:24:39 <omniscientIdiot> as is (:)
12:24:43 <integral> mudge: yes.
12:24:45 <mudge> rad
12:24:46 <dino-> ddarius: I see. Maybe I should look for other examples.
12:24:50 <shachaf> data List a = Nil | Cons a (List a)
12:26:14 <LoganCapaldo> mudge: more fun, (,) is a constructor
12:26:20 <LoganCapaldo> > (,) 1 2
12:26:21 <lambdabot>  (1,2)
12:26:36 <EvilTerran> also (,,) etc
12:26:41 <mudge> wow,  I didn't know that
12:27:10 <oerjan> mudge: none of those are legal syntax for your own constructors, of course
12:27:24 <EvilTerran> can't take sections of (,), unfortunately. there's no (1,) or (,2) or whatever.
12:27:33 <EvilTerran> oerjan, well, (:) would be if it wasn't taken
12:27:42 <omniscientIdiot> you can still flip (,), though
12:28:04 <LoganCapaldo> Yeah you can use :<somestuff>
12:28:05 <EvilTerran> omniscientIdiot, that's rather more verbose, though. (flip (,) 2) vs (,2)...
12:28:17 <int-e> > (`(,)` 2) 1 -- doesn't work either
12:28:17 <lambdabot>  Parse error
12:28:19 <LoganCapaldo> @typ (:+)
12:28:21 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
12:28:28 <LoganCapaldo> @src Complex
12:28:28 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
12:28:28 * shachaf doesn't like that ":" is used for capitalization.
12:28:31 <EvilTerran> ``s only work for identifiers, not expressions
12:28:39 <EvilTerran> *not more complex expressions
12:28:51 <ddarius> EvilTerran: Actually, (:) still isn't because you can't use it even if you hide the Prelude one.
12:28:55 <LoganCapaldo> you can always name the expression
12:29:05 <mudge> I don't understand this type declaration:  data [] a = [] | a : [a]
12:29:12 <mudge> it is declaring [] as a type
12:29:12 <EvilTerran> ddarius, well, yes, but it's no-where near as magic as [] or (,,) or what-have-you
12:29:18 <mudge> and then using it as a type constructor
12:29:25 <mudge> i mean contstructor
12:29:30 <LoganCapaldo> mudge: yes this actually common
12:29:34 <shachaf> data Id a = Id a
12:29:39 <omniscientIdiot> mudge: yep.  you can write [Int] as ([] Int)
12:29:40 <shachaf> Same thing.
12:29:41 <EvilTerran> yes; type and value constructors inhabit different namespaces
12:29:49 <mudge> you can use the type you are defining as a constructor?
12:29:49 <LoganCapaldo> newtype Name = Name String
12:29:57 <LoganCapaldo> yep
12:30:02 <LoganCapaldo> data Foo = Foo
12:30:04 <LoganCapaldo> is fine
12:30:13 <byorgey> well, they are still different things, they just happen to share the same name.
12:30:13 <mudge> ah,  the types and constructors have different namespaces,  makes sense
12:30:30 <EvilTerran> the data constructor name is wholly indepent of the type constructor; you could have data Foo a = Bar a; data Bar a = Foo a if you wanted
12:30:49 <EvilTerran> @kind []
12:30:51 <omniscientIdiot> EvilTerran: but that would be evil :)
12:30:51 <lambdabot> * -> *
12:30:53 <byorgey> you can shoot yourself in the foot in any language =)
12:31:03 <EvilTerran> omniscientIdiot, yes. yes it would. doesn't mean you can't do it, though.
12:31:08 <EvilTerran> >:]
12:31:13 <LoganCapaldo> Haskell just makes sure the bullet has the right type to hit your foot :)
12:31:14 <misterbeebee> We just talked about this an hour ago :-)
12:32:08 <byorgey> shoot :: Bullet a -> Foot -> Ouch a
12:32:35 <omniscientIdiot> mudge: so lists and tuples are just perfectly ordinary datatypes with weird constructor names.
12:32:38 <mudge> you guys are funny
12:32:43 <oerjan> @remember byorgey you can shoot yourself in the foot in any language =) / LoganCapaldo> Haskell just makes sure the bullet has the right type to hit your foot :)
12:32:44 <lambdabot> Done.
12:32:56 <mudge> omniscientIdiot: cool
12:33:19 <mudge> @quote types
12:33:19 <lambdabot> types says: A good type system is like a set of tests, except they're actuallly proofs
12:33:48 <oerjan> gaborek: seems no one has an idea at the moment, try asking at the haskell-cafe mailing list (or search the archive, i think it's been discussed before)
12:34:15 * olsner tries to conjure a funny quote involving bullets, feet and monads
12:34:31 <oerjan> i couldn't find anything on the wiki but i didn't try very hard
12:34:44 <sclv> @quote
12:34:45 <lambdabot> Miod says: [On the vax] How many processors come with a built-in instruction which computes polynomials of degrees up to 31?
12:35:03 <sclv> @quote monad
12:35:03 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
12:35:03 <lambdabot> entire human race would have to be rewritten!
12:36:00 <mudge> I heard that bird book was pretty good
12:36:43 <b_jonas> polynomials of degrees up to 31... I hope he means polynomials over GF(2) only
12:36:46 <mudge> how does it compare to like Hutton's Programming in Haskell or Hudak's book?
12:38:11 <oerjan> b_jonas: er, that wouldn't be half as useful as normal numbers, would it?
12:38:30 <sorear> int is evil
12:38:46 <sorear> I wish processors used GF(2^32) as their core numeric type
12:38:54 <sorear> it's nice, finite, and a FIELD
12:39:03 <olsner> what's GF(x)?
12:39:26 <oerjan> sorear: and x+x = 0 for every x
12:39:37 <sorear> http://en.wikipedia.org/wiki/Finite_field#Classification
12:39:38 <oerjan> not particularly intuitive
12:40:14 <sorear> oerjan: any finite field must have finite order...
12:40:27 <oerjan> (if you want something that can be used for ordinary arithmetic)
12:40:28 <sorear> on the plus side, it means SUB is unnecesarry
12:40:29 <olsner> hmm.. so basically, GF(2) is just bits, OR and AND?
12:40:39 <sorear> oerjan: bits, XOR and AND
12:40:44 <olsner> *XOR
12:40:56 <b_jonas> oerjan: yeah, I guess. maybe something in between GF(2) and "normal numbers)
12:41:09 <sorear> olsner: single bit, XOR and AND, yes
12:41:11 <b_jonas> sorear: oh, no wai
12:41:15 <b_jonas> that would suck
12:41:36 <b_jonas> can you easily imitate other kinds of numbers with it?
12:41:38 <b_jonas> I think no
12:41:50 <b_jonas> while you can with the numbers real cpus use
12:41:57 <oerjan> i have used GF(32) (or something like it) once.  It was in my INTERCAL interpreter for Unlambda.
12:42:26 <EvilTerran> . . .
12:42:34 <b_jonas> and in fact, some checksum routines I think calculate in GF(32) or something like that using fixnums
12:42:43 <b_jonas> oerjan: heh
12:42:48 <sorear> don't you mean GF(2^32) ?
12:42:54 <b_jonas> yeah sorry
12:42:57 <oerjan> sorear: er, yes
12:43:00 <b_jonas> some GF(2^k) at least
12:43:12 <sorear> 32 is 2^k for k=5
12:43:28 <newsham> whats the relation between a ring and a field?
12:43:28 <b_jonas> sure, but I just don't know what those routines use
12:43:41 <b_jonas> newsham: a field is a ring
12:43:59 <sorear> newsham: class (Ring a) => Field a
12:44:05 <b_jonas> and you can construct a field from any (commutative ring without zero divizors) I think
12:44:25 <b_jonas> s/divizors/divisors/
12:44:27 <sorear> commutative ring refers to (*) ?
12:44:33 <b_jonas> yes
12:44:49 <b_jonas> because + has to be commutative in all rings (otherwise you don't call it like that)
12:45:53 <oerjan> b_jonas: it is hard for distributivity to make sense if addition isn't commutative
12:48:28 <misterbeebee> is Diffarray pure haskell? or does it use FFI to implement efficient array updates (plus extra bookkeeping to provide pure access to 'earlier' array state?
12:49:53 <b_jonas> I considered using some GF(p^k) for 1<=k for one of my obfus that evaluate polynomials, but then I decided I don't actually know how to implement such fields.
12:50:00 <sjanssen> misterbeebee: it uses unsafePerformIO + mutable arrays
12:50:18 <sjanssen> misterbeebee: the mutable arrays aren't part of the FFI, but they aren't part of Haskell '98 either
12:50:36 <b_jonas> by mutable arrays, do you mean IOArrays?
12:50:40 <sjanssen> yes
12:51:09 <misterbeebee> Yes, IOArrays. so, what it is it (and how to do i write something similar myself)? Is there a special GHC flag that says "destructively modify this value"?
12:51:24 <sjanssen> misterbeebee: no, it's all done manually
12:51:29 <sjanssen> misterbeebee: the source is pretty readable
12:51:30 <newsham> are haskell researches playing with suns hardware support for transactional memories?
12:51:57 <b_jonas> I think IOArray and IORef and the like are quite useful
12:51:57 <misterbeebee> which module? http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IO.html ?
12:51:59 <lambdabot> http://tinyurl.com/3dydza
12:52:08 <b_jonas> in that you can't easily replace them with something else
12:52:10 <sjanssen> misterbeebee: http://darcs.haskell.org/packages/array/Data/Array/Diff.hs
12:53:06 <misterbeebee> ok so unsafeWrite is what I'm interested in
12:53:42 <misterbeebee> where is that defined?
12:53:52 <sorear> unsafeWrite just turns off bounds checking
12:53:56 <misterbeebee> oh
12:54:06 <sorear> it has nothing whatsoever to do with destructive modification
12:54:14 <misterbeebee> oh. so, what am i looking for?
12:54:24 <sorear> @doc Data.Array.MArray
12:54:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
12:54:26 <sjanssen> misterbeebee: writeArray?
12:54:27 <sorear> that
12:54:28 <misterbeebee> I'm looking for the literal equivalent of arr[0] = 1
12:54:34 <sorear> writeArray
12:54:44 <sorear> writeArray arr 0 1
12:54:49 <sorear> writeArray
12:55:00 <sorear> @slep sorear's keyboard
12:55:00 * lambdabot beats up sorear's keyboard
12:55:29 <misterbeebee> getting closer... where is writeArray defined? It's exported but not defined in Data.Array.MArray.hs source
12:55:53 <shachaf> @index writeArray
12:55:53 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
12:57:18 <oerjan> @src MArray
12:57:18 <lambdabot> Source not found. You speak an infinite deal of nothing
12:58:05 <misterbeebee> hmm. of those, only MArray has writeArray in its documentation page, and i already checked the source of that. so i should go read through the source of all those?
12:58:11 <misterbeebee> after my mozarella sticks....
12:58:41 <oerjan> misterbeebee: Data.Array.Base
12:59:12 <misterbeebee> hmm that's not listed in http://haskell.org/ghc/docs/latest/html/libraries/base/ .
12:59:13 <lambdabot> Title: Index of /ghc/docs/latest/html/libraries/base
12:59:18 <misterbeebee> (am I being stupid?)
12:59:30 <sjanssen> misterbeebee: do you really want to read the source of writeArray?
12:59:40 <sjanssen> misterbeebee: it's just a small wrapper around a compiler primitive
12:59:45 <oerjan> i was looking in Hugs
12:59:50 <misterbeebee> my real question: how does the array library actual implement efficient array update.
13:00:07 <misterbeebee> oh, "compiler primitive" is the answer.
13:00:15 <misterbeebee> so i can't do the same thing myself for a non-array
13:00:16 <sjanssen> misterbeebee: compiler prims that actually mutate the memory
13:00:24 <sjanssen> misterbeebee: you can use IORefs
13:00:52 <oerjan> misterbeebee: writeArray is defined in terms of unsafeWrite, which is a method of the MArray class
13:01:14 <sjanssen> @src unsafeWrite
13:01:14 <lambdabot> Source not found. My pet ferret can type better than you!
13:01:17 <sjanssen> blast
13:01:32 <int-e> misterbeebee: it's explicitely hidden from haddock docs.
13:01:38 <misterbeebee> right, but IORefs aren't efficient for bulk objects.. but bulk objects are implemented on top of arrays, so if i have some funny bulk/tree thing, I should use IORefs around arrays and wrap my "guts" with a safe interface
13:01:40 <iguana_> @type fromRational
13:01:43 <lambdabot> forall a. (Fractional a) => Rational -> a
13:01:49 <oerjan> so for the latter, you probably want to look in the Data.Array.IO etc.
13:01:57 <int-e> misterbeebee: Data.Array.Base that is.
13:03:32 <misterbeebee> OK I think I get it now. when I make time to actually write the code I'm thinking about, I'll see if I actually understand :-)
13:03:52 <newsham> so is the set of naturals N not a field/ring because of no additive inverse?
13:04:12 <sorear> it's not a ring
13:04:46 <newsham> is there a name for something like naturals that are closed under addition and multiplication?
13:04:57 <int-e> it's a semiring.
13:05:19 <sorear> misterbeebee: What are you trying to do?
13:05:55 <oerjan> misterbeebee: i see Data.Array.IO.Internals, which has Foreign imports
13:06:22 <oerjan> so the ffi probably gets involved at some point
13:07:00 <sorear> oerjan: that's just to suppport unpacked arrays of Ptr
13:07:11 <oerjan> oh
13:08:11 <hpaste>  Japsu pasted "deriving Random instances for Enum Bounded with Template Haskell" at http://hpaste.org/3012
13:09:02 <oerjan> anyway, that file has MArray instance definitions, leading further
13:09:14 <misterbeebee> I'm kicking around ideas for ICFP contest 07/ropes, basically, and thinking in general about working on a linear type. I want to make a data structure with some algebraic structure (tree-like structure) with bulk bytes on the leaves, and then I want to efficiently insert/delete,copy/paste. I want to make the tradeoff:  there will only be one unique instance of the object in the program, and no external references to subcomponents,  so  I w
13:09:53 <int-e> GHC.Arr implements the fun stuff for ghc - using primops.
13:10:09 <b_jonas> does that really require unsafe mutations instead of just IOArray/IORef?
13:10:18 <sjanssen> misterbeebee: you were cut off at "subcomponents,  so  I w"
13:10:40 <misterbeebee> what got chopped off:  there will only be one unique instance of the object in the program, and no external references to subcomponents,  so  I want functions on it to efficiently (destructively) mo
13:10:49 <misterbeebee> ify it when it evolves.
13:10:53 <int-e> misterbeebee: you need to sequence those operations too so a monad is appropriate, I think.
13:10:59 <sorear> misterbeebee: Anyways, the function you are looking for is writeArray#, and it's defined in http://darcs.haskell.org/ghc/compiler/codeGen/CgPrimOp.lhs
13:11:01 <misterbeebee> I think you all just explained to me that IOARray/IORef combination is what i want
13:11:29 <misterbeebee> sorear: that line is 404 for me
13:12:16 <misterbeebee> IOArray/IORef  === unasfe mutations (wrapped in a monad to give a safe interface), right?
13:12:17 <sorear> http://darcs.haskell.org/ghc/compiler/codeGen/CgPrimOp.hs
13:12:31 <misterbeebee> sorear: thanks
13:12:37 <sorear> misterbeebee: No.  It's IO all the way down.
13:13:32 <misterbeebee> (I'm probably out of my depth here) I thought  "IO" as a whole == impure stuff wrapped in a pure interface. (I just changed "unsafe" to "impure"
13:13:33 <misterbeebee> )
13:13:46 <oerjan> @src IO
13:13:46 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
13:13:53 <b_jonas> if it's wrapped, it's not unsafe anymore
13:13:58 <b_jonas> that's why it's wrapped into IO
13:14:07 <sorear> it's pure all the way down
13:14:08 <int-e> the compiler knows about State# and about the RealWorld type.
13:14:11 <b_jonas> (that is, unless you use unsafePerformIO or something)
13:14:22 <sorear> if it weren't for State#, it would be impure
13:14:34 <int-e> @src unsafePerformIO
13:14:34 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
13:14:36 <misterbeebee> ah, ok, got it.
13:15:08 <misterbeebee> I guess was conflating unsafe/impure with the State#
13:15:21 <b_jonas> misterbeebee: you may also want to know about ST and STRef and STArray
13:15:43 <misterbeebee> b_jonas: Thanks. I'm aware of them... I just haven't written enough code to get intuitive with it all yet.
13:16:35 <sclv> anyone got any advice on compiling StringMap? its driving me crazy
13:19:07 <phobes> @src State#
13:19:07 <lambdabot> Source not found. I feel much better now.
13:19:52 <sclv> i suspect the problem may be that stringmap uses one set of stuff from Tree.AVL and Data.COrdering, while collections provides another (but of course they can't both be deployed simultaneously...)
13:28:12 <hpaste>  sclv pasted "Basic Quadratic Sieve" at http://hpaste.org/3013
13:29:48 <hpaste>  sclv annotated "Basic Quadratic Sieve" with "oops -- there's more" at http://hpaste.org/3013#a1
13:33:54 <iguana_> is there a function that map over a function that yields a Maybe and gives me the first Just in the result?
13:34:25 <omniscientIdiot> what's the type you want?
13:34:32 <omniscientIdiot> (a -> Maybe b) -> ...
13:34:49 <sjanssen> iguana_: sounds like you want catMaybes
13:34:54 <sjanssen> @hoogle catMabyes
13:34:54 <lambdabot> No matches found
13:34:57 <sjanssen> @hoogle catMaybes
13:34:58 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
13:35:05 <omniscientIdiot> > catMaybes [Just 1, Nothing, Just 2]
13:35:07 <lambdabot>  [1,2]
13:35:20 <iguana_> well, but I want to keep the Just
13:35:31 <iguana_> so I thought there may be some monadic trick
13:35:37 <omniscientIdiot> filter isJust?
13:35:44 <sjanssen> oh, I guess catMaybes isn't right
13:35:47 <sjanssen> @hoogle msum
13:35:47 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
13:35:48 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
13:35:56 <sjanssen> iguana_: msum should work
13:36:00 <EvilTerran> msum sounds right
13:36:10 <iguana_> msum (mapM ...) ?
13:36:14 <b_jonas> stupid question, but what precedence does @ have in pattern matches?
13:36:17 <EvilTerran> or listToMaybe . filter isJust. same thing, afaict.
13:36:21 <sjanssen> iguana_: msum (map ...)
13:36:27 <omniscientIdiot> > msum [Nothing, Nothing, Just 1, Just 2, Nothing, Just 3]
13:36:28 <lambdabot>  Just 1
13:36:31 <iguana_> great
13:36:33 <iguana_> thanks
13:36:44 <misterbeebee> Is there a performance difference between Ints and data types, when they are used in other functions or data structures? As in this:
13:36:55 <misterbeebee> data ItemData = A | B | C | D
13:36:55 <misterbeebee> newtype ItemInt = Item Int
13:37:06 <misterbeebee> is ItemInt more efficient than ItemData?
13:37:16 <iguana_> @type lookup
13:37:17 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:37:41 <EvilTerran> misterbeebee, it's unlikely to be significant enough to worry about, if there is one
13:38:03 <oerjan> b_jonas: @ is about the only thing that has higher precedence than application, i've heard this considered an error :)
13:38:22 <b_jonas> I see
13:38:24 <oerjan> (operator-like thing)
13:38:47 <misterbeebee> EvilTerran: and what about usability and compatibility with libraries?  Forexample, ByteString.pack   is compatible with chars and ints
13:39:11 <misterbeebee> Is there a one-time way to fit my little data type into efficient byte-managing datastructures?
13:39:42 <misterbeebee> er, ByteString likes chars and *word8's*, of course
13:39:46 <sjanssen> misterbeebee: ItemInt is sometimes more efficient
13:40:26 <sjanssen> notably, GHC knows how to unpack ItemInt when an UNPACK pragma is used
13:44:52 <sjanssen> misterbeebee: it is pretty easy to get an Int out of ItemData with deriving Enum
13:49:25 <misterbeebee> > ByteString.pack    $   map (fromIntegral  . fromEnum)   [A, B, C]  -- is this right? how is it guaranteed to be safe (it should be ok, since ItemData has less than 2^8 values)
13:49:26 <lambdabot>   Not in scope: data constructor `C'
13:50:45 <sjanssen> misterbeebee: right, it is safe as long as there are fewer than 2^8 values
13:50:47 <hsuh> 17:48 *** phlpp QUIT "Lost terminal"
13:50:51 <hsuh> sry
13:50:56 <oerjan> fromIntegral probably truncates otherwise?
13:51:09 <misterbeebee> do i have to declare anything? Or GHC counts how many data constructors I have?
13:51:09 <oerjan> from Int to Word8
13:51:11 <sjanssen> yes
13:51:29 <sjanssen> misterbeebee: deriving Enum is totally automated
13:52:01 <hsuh> i'm looking at Tiger.hs from parsec/examples, but can't understand where from does it knows what to do with a "While" or a "For"
13:52:32 <misterbeebee> awesome. thanks for the info. that makes me comfortable mixing abstract types with arrays....
13:52:51 <mux> nasty monad! give me back my >> as shiftR :-)
13:52:56 <hsuh> the function whileExpr parses this while expressions and returns (While cond body)... where is "While" defined?
13:53:00 <Japsu> ;D
13:53:07 <LoganCapaldo> nasty moads we hates them
13:53:25 <Japsu> they ssstole it from us! thieffffs!
13:53:26 <oerjan> hsuh: since it is capitalized, it must be a data constructor
13:53:35 <oerjan> look for a data declaraion
13:53:38 <oerjan> *tion
13:53:45 <omniscientIdiot> hsuh: TigerAS.hs
13:53:47 <misterbeebee> ...as long as it's efficient. will (fromIntegral . fromEnum) and {-# UNPACK #-} make  the ByteString.pack on enums as efficient as with regular ints?
13:53:51 <hsuh> oerjan: ok. so we have in another file While Expr Expr
13:54:00 <LoganCapaldo> so somewhere, out there theres a data ... = ... | While ... | ...
13:54:11 <omniscientIdiot> http://darcs.haskell.org/packages/parsec/examples/tiger/
13:54:12 <hsuh> but i don't understand where does it get to now that is must loop with the cond is true :)
13:54:12 <lambdabot> Title: Index of /packages/parsec/examples/tiger
13:54:50 <oerjan> hsuh: it builds a tree - there would need to be an interpreter function to run the tree
13:54:59 <omniscientIdiot> hsuh: from a cursory glance, that file just looks like it parses an AST, you'd need an interpreter
13:55:47 <hsuh> oh. its a recursive data declaration
13:55:53 <hsuh> i had missed that
13:59:11 <b_jonas> at least now I have a test case for which my program gives a wrong answer instead of just getting an exception or going to an infinite loop
13:59:15 <b_jonas> much easier to debug
14:05:42 <gaborek> Hi! I would like to join usefull, open source project but I am not advanced, I want to learn. Can somebody help me? What project should I choose?
14:06:05 <gaborek> which project should I choose?
14:06:54 <Japsu> gaborek: Many projects offer so-called "Junior Jobs" that are listed in their bug tracking systems. Perhaps that would be a good way to start
14:07:57 <gaborek> Oh, I havent seen it yet
14:14:29 <omniscientIdiot> Darcs and Pugs are well known.  darcs.net seems down at the moment.  You could pore through http://haskell.org/haskellwiki/Applications_and_libraries
14:14:30 <lambdabot> Title: Applications and libraries - HaskellWiki
14:15:44 <misterbeebee> gaborek: If someone brings cabal-install into the 21st century, that would be a huge win for haskell novices users. http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
14:15:46 <lambdabot> Title: CabalInstall - Hackage - Trac
14:16:26 <b_jonas> I think I'm getting near to the bug
14:16:27 <gaborek> misterbeebee: :D
14:16:49 <b_jonas> so prepare to me swearing hardly when I actually find that damn problem (which might be a typo)
14:17:05 <b_jonas> and another instance of the same when I correct it and the program still won't work
14:18:01 <misterbeebee> b_jonas: how long is your largest module file in your project? Have you tested all of your module files except for the one broken one?
14:18:28 <b_jonas> one module only,
14:18:45 <b_jonas> and 258 lines
14:18:52 <b_jonas> (with comments and empty lines)
14:19:10 <misterbeebee> oh that's not bad at all.
14:19:43 <b_jonas> it will have to grow of course
14:19:50 <b_jonas> but I have to debug first
14:23:35 <hsuh> looking at this (http://haskell.org/haskellwiki/Parsing_expressions_and_statements) another example, i see something very similar for parsing the while, for example. but i'm missing something here, can someone bother to explain ? :)
14:23:36 <lambdabot> Title: Parsing expressions and statements - HaskellWiki
14:25:34 <oerjan> hm?
14:25:59 <hsuh> its the same thing, the whileexpr parser returns ; return (While b p)
14:26:26 <hsuh> and we have the type data Stmt = Nop | String := Expr | If Expr Stmt Stmt | While Expr Stmt | Seq [Stmt]
14:26:27 <hpaste>  b_jonas pasted "this is the one I'm debugging (not main but another test case which isn't here)" at http://hpaste.org/3014
14:27:07 <b_jonas> I've found the error meanwhile
14:27:14 <b_jonas> it's a sign error so I'm not so much annoyed
14:27:28 <b_jonas> I know I'll have to mess up the sign half of the time
14:27:32 <oerjan> hsuh: and what is the problem?
14:27:51 <hsuh> oerjan: but i can't figure it out where is defined something like "evaluate the stmt while expr is true"
14:27:52 <misterbeebee> b_jonas: the trick is to mess up the sign twice as often and your golden.
14:28:03 <misterbeebee> *you're* golden
14:28:09 <ddarius> b_jonas: You randomly pick a sign everytime you need one.
14:28:13 <ddarius> ?
14:28:18 <hsuh> oerjan: i'm probably missing the whole point on using those datatypes :/
14:28:27 <omniscientIdiot> hsuh: that's because there's no evaluator.
14:28:34 <oerjan> hsuh: there isn't.  this is parsing.  it is a separate stage done to turn a file into a hierarchical structure.
14:28:37 <b_jonas> ddarius: no, I actually always think it through
14:28:43 <b_jonas> but have messed up twice so far
14:28:59 <ddarius> b_jonas: So you consistently aim for choosing the wrong one half the time?
14:29:09 <b_jonas> no
14:29:11 <ddarius> Otherwise you might as well save time and just guess in each case.
14:29:14 <b_jonas> it's just that I make errors
14:29:28 <hsuh> ok, so the parser only return the tree... i need to make something out of it
14:29:33 <omniscientIdiot> hsuh: the parser just transforms a source code String into an abstract syntax tree.  You'd need to write an evaluator/interpreter to take the syntax tree and an initial state and step through the statements.
14:29:40 <b_jonas> ddarius: well, I think I might learn about the error I make when I think it through
14:29:59 <iguana_> wow, -O1 takes quite a long while...
14:30:27 <hsuh> omniscientIdiot: now i see that. its because there are some examples where the evaluation is done in place
14:30:58 <hsuh> with something like "return e1 (+) e2" .. so i was led to think that something similar would happen with 'while' :)
14:31:12 <omniscientIdiot> hsuh: yep, you could do that if you want, but in a more complex language seperating parsing from evaluating is usually more sane.
14:31:19 <oerjan> hsuh: it actually _is_ possible to generate the resulting program directly with Parsec in simple cases, because of monads.  But if you are going to do anything complicated between parsing and final evaluation, it is useful to have an intermediate data structure.
14:31:45 <ddarius> Separation of Concerns
14:31:45 <b_jonas> yeah
14:31:49 <b_jonas> especially for debugging
14:32:15 <hsuh> actually i want only to write some kind of preprocessor... my first input would be to convert
14:32:21 <b_jonas> you cannot show the monad while you can write a shower for the intermediate
14:32:27 <omniscientIdiot> I wrote a mixed parser/evaluator for a small stack-based language that parsed directly into StateT InterpState IO () actions.
14:32:34 <hsuh> for i = 0 to 8 generate a(i) <= b(i+1); end generate;
14:32:56 <hsuh> this would "expand" to "a(0) <= b(1); a(1) <= b(2); ... etc
14:33:23 <b_jonas> now the second swearing, it still doesn't work after the fix of that sign
14:33:43 <hsuh> omniscientIdiot: that looks like fun but i know nothing about StateT InterpState IO actions :)
14:34:10 <omniscientIdiot> it's just a fancy way to say InterpState -> IO InterpState functions :)
14:34:21 <oerjan> hsuh: you are going to want those for the evaluator
14:34:31 <hsuh> oerjan: those what?
14:34:39 <oerjan> those actions
14:34:42 <hsuh> oerjan: oh.. InterpState ?
14:34:52 <omniscientIdiot> where InterpState was my own data type that represented the interpreter state
14:34:58 <b_jonas> @source StateT -- is that a "type" then?
14:34:58 <lambdabot> StateT -- is that a "type" then? not available
14:35:03 <b_jonas> @source StateT
14:35:04 <lambdabot> StateT not available
14:35:07 <oerjan> @src StateT
14:35:07 <lambdabot> Source not found. That's something I cannot allow to happen.
14:35:16 <oerjan> :t StateT
14:35:18 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
14:35:30 <b_jonas> hey, it's a type, you can't :t it
14:35:37 <omniscientIdiot> newtype StateT s m a = StateT (s -> m (a, s))
14:35:47 <omniscientIdiot> StateT is also the data constructor
14:35:52 <oerjan> b_jonas: i think lambdabot only supports -- comments in those commands that take a full haskell expression
14:36:02 <b_jonas> oerjan: yeah, makes sense
14:36:09 <b_jonas> for example,
14:36:18 <b_jonas> @src Maybe >>=
14:36:18 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:36:35 <b_jonas> @src Maybe (>>=)
14:36:35 <lambdabot> (Just x) >>= k      = k x
14:36:35 <lambdabot> Nothing  >>= _      = Nothing
14:36:44 <hsuh> so, are there evaluator tutorials like there are parsing/parsec tutorials ? :)
14:36:45 <b_jonas> that's not valid haskell syntax afaik
14:36:46 <xerox> b_jonas: StateT is both a type constructor and a data constructor
14:37:03 <hsuh> the ones i saw were all for lisp/scheme which seems simpler
14:38:07 <oerjan> b_jonas: what isn't valid syntax?
14:38:20 <b_jonas> oerjan: "Maybe (>>=)
14:38:21 <b_jonas> "
14:39:48 <oerjan> :t let f = Nothing; f :: Maybe (>>=) in f
14:39:50 <lambdabot> Maybe (>>=) in f :: forall >>=. Maybe >>=
14:40:29 <LoganCapaldo> lol
14:40:30 <oerjan> b_jonas: it's a ghc extension, infix type variables
14:40:32 <omniscientIdiot> b_jonas: the @src command is in the form @src <name> or @src <type> <method>, LB commands need not be haskell syntax
14:41:01 <b_jonas> oerjan: ok, but that's not what it means in that src command
14:41:17 <b_jonas> there, (>>=) is a variable, not a typecon
14:41:23 <oerjan> just nitpicking :)
14:43:24 <omniscientIdiot> hsuh: I think dons wrote an interpreter example somewhere
14:44:39 <omniscientIdiot> http://www.google.com/search?q=site%3Ahttp%3A//cgi.cse.unsw.edu.au/%7Edons/blog%20interpreter
14:44:41 <lambdabot> Title: site:http://cgi.cse.unsw.edu.au/~dons/blog interpreter - Google Search, http://tinyurl.com/38l6m5
14:45:56 <omniscientIdiot> "Quick interpreters with the Reader monad", but that looks like a pure stateless expression interpreter :/
14:46:12 <hsuh> stateless :/
14:46:28 <oerjan> http://haskell.org/haskellwiki/Meta-tutorial , the last item
14:46:29 <lambdabot> Title: Meta-tutorial - HaskellWiki
14:46:55 <oerjan> hsuh: ^^
14:47:54 <omniscientIdiot> It's *State*less, but it's *Reader*ful :)  using 'local' for local namespacing.
14:48:23 <monochrom> You seldom need state.
14:49:05 <monochrom> Most often you just need "write-once". Well Reader or lazy evaluation suffice.
14:49:32 <hsuh> you guys don't realize you're talking about concepts i still don't know :)
14:49:51 <omniscientIdiot> just grin and nod :)
14:57:26 <b_jonas> ok, found another error
14:57:27 <hsuh> yeah, 'write yourself a scheme in 48 hours' seems like  a good read :)
14:57:51 <ramza3> anybody know off hand if the opengl "enable" function is available; eg to enable DepthTest --   enable DepthTest
14:57:55 <hsuh> (but i still don't believe i couldn't code the macro-expander pre-processor in a simpler way)
14:58:33 <ramza3> with ghc
15:00:16 <sorear> ramza3: grep is your friend
15:00:17 <sorear> :(
15:00:39 <b_jonas> hsuh: yeah, I suppose that's difficult
15:00:51 <b_jonas> but it greatly simplfies writing the interpreter
15:00:56 <ramza3> sorear: I was skating on ice with that question wasnt i
15:01:01 <hsuh> i should have run tiger once, then i would have seen the AST and right away get that it wasn't returning a solution but a structure :)
15:01:06 <b_jonas> because then you can just copy the macro definitions for all the library macros
15:01:08 <hsuh> just did that now
15:01:11 <b_jonas> like let and letrec and stuff
15:02:45 * hsuh will still have to read the red dragon book
15:03:26 <b_jonas> good night now
15:03:54 <sorear> ramza3: skating on ice?
15:04:28 <sorear> ramza3: grep is your friend means "the documentation sucks", not "you suck"
15:04:28 <ramza3> sorear: skating on thin ice, meaning I could have probably googled for the answer as opposed to bothering the fine folks on #haskell
15:04:34 <ramza3> ah
15:06:21 <hpaste>  iguana pasted "findError" at http://hpaste.org/3015
15:06:42 <iguana_> who wants to tell me I'm stupid and could have written findError in one line?
15:08:05 <Heffalump> [e | Error e <- xs] `mplus` cons xs
15:08:09 <nornagon> @quote one-line
15:08:09 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
15:08:09 <lambdabot> for your entire program.")
15:08:16 <Heffalump> sorry, not quite.
15:08:18 <MyCatVerbs> iguana_: er, the only thing that cannot be written on one line in Haskell are import and module statements.
15:08:40 <mrd> ;
15:08:47 <Heffalump> head ([e | Error e <- xs] ++ [cons xs])
15:08:49 <MyCatVerbs> iguana_: aside from that, just (ab)use { } and ; instead of actual indentation and newlines and entire programs become one-liners.
15:09:16 <iguana_> MyCatVerbs: well, that'd be boring... I'm rather looking for a less verbose solution
15:09:41 <oerjan> MyCatVerbs: import and module statements cannot?
15:09:41 <iguana_> Heffalump: thanks, that looks good
15:09:57 <Heffalump> ++ing with a singleton is kind of ugly
15:10:08 <ddarius> MyCatVerbs: module Foo where { import Bar; foobar = bar foo } is perfectly fine.
15:10:20 <Heffalump> but since we take the head it probably doesn't actually matter
15:10:35 <iguana_> I use list comps much too infrequently
15:10:42 <kpreid> Where's our monad comprehension?!
15:10:47 <MyCatVerbs> oerjan: well, *I* thought they couldn't. Guess y'learn something new every day.
15:10:48 <iguana_> which surprises me, coming from python
15:10:57 <dmwit> ?instances MonadPlus
15:10:58 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
15:11:04 <kpreid> fromMaybe (cons xs) [e | Error e <- xs]
15:11:14 <hpaste>  (anonymous) annotated "findError" with "isError could use a name, and Data.Maybe helps" at http://hpaste.org/3015#a1
15:11:19 <Heffalump> kpreid: but the list comprehension isn't a Maybe
15:11:20 <lament> iguana_: probably because in haskell (unlike python) it's often more convenient to use map and filter
15:11:32 <Heffalump> I did think of that as my first correction
15:11:42 <kpreid> Heffalump: I said, where's our monad comprehension?!
15:11:47 <Heffalump> ah, right
15:12:12 <dmwit> :t Error
15:12:14 <lambdabot> Not in scope: data constructor `Error'
15:12:36 * ddarius isn't too keen on list comprehensions.
15:12:49 * omniscientIdiot neither
15:12:58 <oerjan> kpreid: doesn't quite work because xs isn't maybe either
15:13:07 <oerjan> as you will see if rewriting in do notation
15:13:15 <kpreid> oerjan: ...erk
15:13:46 <Heffalump> oh, Freiburg has idiot tire-squealing drivers too
15:13:54 <kpreid> fromMaybe (cons xs) (listToMaybe [e | Error e <- xs])
15:14:25 <Heffalump> I think head and ++ wins there
15:14:53 <kpreid> indeed
15:14:54 <dmwit> I think you should make the datatype for which Error is a constructor into an instance of MonadPlus.
15:15:00 <iguana_> @src fromMaybe
15:15:00 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
15:15:08 <ddarius> Heffalump: You thought they were a local phenomenon?
15:15:09 <dmwit> You get a slightly different type signature, but it might be nicer that way, anyway.
15:15:16 <hpaste>  mux pasted "Why the warning about defaulting?" at http://hpaste.org/3016
15:15:24 <hpaste>  (anonymous) annotated "findError" with "oops" at http://hpaste.org/3015#a2
15:15:49 <Heffalump> I thought the British were one of the most yobbish cultures in Europe
15:15:59 <iguana_> argh
15:16:03 <kpreid> hmm, anonymous helpers
15:16:03 <Heffalump> but it's just an impression
15:16:08 * ddarius has no idea what "yobbish" means.
15:16:39 <SaMBuCa_> 2+2
15:16:47 <SaMBuCa_> ?
15:16:53 <omniscientIdiot> SaMBuCa_: prefix it with '> '
15:16:56 <SaMBuCa_> -_-
15:16:58 <SaMBuCa_> tnx
15:17:00 <SaMBuCa_> >2+2
15:17:03 <SaMBuCa_> lol
15:17:05 <dmwit> > 2+2
15:17:06 <SaMBuCa_> i'm n00b
15:17:06 <lambdabot>  4
15:17:07 <SaMBuCa_> :D
15:17:09 <dmwit> You need the space.
15:17:09 <omniscientIdiot> > 2+2 -- need the space
15:17:11 <lambdabot>  4
15:17:17 <SaMBuCa_> right tnx
15:17:21 <SaMBuCa_> > 2+2
15:17:22 <lambdabot>  4
15:17:26 <SaMBuCa_> xD
15:17:29 <SaMBuCa_> happy now.
15:17:29 <Heffalump> http://en.wikipedia.org/wiki/Yob
15:17:30 <lambdabot> Title: Yob - Wikipedia, the free encyclopedia
15:17:37 <SaMBuCa_> yeah yeah
15:17:37 <dmwit> mux: Because there are other RealFrac instances?
15:17:37 <omniscientIdiot> LB doesn't understand the command '>2+2', but she understands '>'
15:17:45 <SaMBuCa_> xerox told me to look 4 it
15:17:53 <SaMBuCa_> to learn a bit of haskell
15:17:54 <SaMBuCa_> :D
15:17:59 <SaMBuCa_> bases..
15:18:03 <ddarius> "doom metal" ...
15:18:11 <goalieca> > 1/0
15:18:12 <lambdabot>  Infinity
15:18:13 <kpreid> SaMBuCa_: Welcome to #haskell.
15:18:21 <oerjan> mux: apparently if you turn on all warnings ghc warns about all defaulting
15:18:22 <goalieca> !cookie
15:18:24 <SaMBuCa_> tnx kpreid
15:18:24 <kpreid> SaMBuCa_: But would you mind hitting return less often?
15:18:27 <goalieca> @cookie
15:18:27 <lambdabot> Unknown command, try @list
15:18:28 <omniscientIdiot> SaMBuCa_: LB listens to /msg if you'd like to play.  First try /msg lambdabot @list, then @help <command>
15:18:33 <SaMBuCa_> lool
15:18:36 <dmwit> ?botsnack
15:18:36 <lambdabot> :)
15:18:49 <omniscientIdiot> ?botspank
15:18:49 <lambdabot> :)
15:18:58 <dmwit> lambdabot is a masochist. =)
15:19:00 <Japsu> lol
15:19:06 <goalieca> !botsnack
15:19:10 <goalieca> @botsnack
15:19:10 <lambdabot> :)
15:19:28 <SaMBuCa_> can i query LB to practice cmds?
15:19:29 <opqdonut> ?botsmack
15:19:29 <lambdabot> :)
15:19:35 <omniscientIdiot>  ? and @ are interchangeable, : only works with :t and :k, > is short for @run
15:19:37 <opqdonut> SaMBuCa_: yep
15:19:48 <SaMBuCa_> tnx
15:19:59 <omniscientIdiot> @run 2 + 2
15:20:00 <lambdabot>  4
15:20:02 <SaMBuCa_> well, so i can leave u in peas (lol)
15:20:03 <goalieca> @botsnack for passing the turring test
15:20:04 <lambdabot> :)
15:20:17 <dmwit> :i Monad
15:20:32 <dmwit> Huh, I could have sworn :i was an alias for ?info.
15:20:42 <LoganCapaldo> I don't think lambdabot does info at all
15:20:43 <MyCatVerbs> dmwit: you're just used to ghci.
15:20:45 <omniscientIdiot> is there a ?info?
15:20:46 <oerjan> dmwit: lambdabot doesn't have @info
15:20:56 <goalieca> @src length
15:20:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:21:02 <dmwit> ?info Monad
15:21:02 <lambdabot> (Monad)
15:21:05 <goalieca> lol
15:21:07 <SaMBuCa_> i've finished by 2 hours an interesting discussion with xerox (#haskell user) about haskell and his way to understand commands
15:21:09 <dmwit> It isn't very useful, but it's there. =)
15:21:12 <oerjan> @info do { x <- whee; return x }
15:21:12 <lambdabot> (whee >>= \ x -> return x)
15:21:13 <goalieca> @src repeat
15:21:13 <lambdabot> repeat x = xs where xs = x : xs
15:21:15 <omniscientIdiot>  @info --spellcheck--> @undo
15:21:22 <MyCatVerbs> It \bot had ghci's :i, it'd end up flooding the channel all the time 'cuz that feature spits out so much text.
15:21:26 <dmwit> ...oh
15:21:27 <LoganCapaldo> @type sum . map (const 1)
15:21:29 <lambdabot> forall a a1. (Num a) => [a1] -> a
15:21:42 <goalieca> ./query lambdabot ;)
15:22:19 <dmwit> MyCatVerbs: I like that abbreviation, though it took me a second to recognize it. =)
15:22:41 <LoganCapaldo> Just a second?
15:22:53 <shapr> @yow !
15:22:53 <lambdabot> While my BRAINPAN is being refused service in BURGER KING, Jesuit
15:22:53 <lambdabot> priests are DATING CAREER DIPLOMATS!!
15:23:04 <LoganCapaldo> I kept toggling back and forth between It and \bot trying to figure out the both of them at the same time :)
15:23:20 <dmwit> heh
15:23:24 <mux> dmwit: I don't _understand_ this warning, where does the ambiguity come from?
15:23:34 <dmwit> :t round . fromInteger
15:23:36 <lambdabot> forall b. (Integral b) => Integer -> b
15:23:53 <dmwit> :t \x y -> round x / y
15:23:55 <MyCatVerbs> dmwit: ^_^
15:23:55 <lambdabot> forall a b. (RealFrac a, Integral b, Fractional b) => a -> b -> b
15:24:03 <dmwit> mux: From there.
15:24:31 <omniscientIdiot> :t \x y -> round (x / y) -- rather this
15:24:33 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> a -> b
15:24:52 <MyCatVerbs> LoganCapaldo: Haskell has caused me to always read \ as "lambda" now, just like playing with QBASIC once taught me to always think of $ as "string" :)
15:24:53 <mux> omniscientIdiot: can't use / with Integer
15:25:13 <mux> dmwit: hmmm, any suggestion on how to write this in order to avoid the warning?
15:25:14 <dmwit> mux: Sorry, I was going from memory.
15:25:23 <LoganCapaldo> MyCatVerbs: I still think "escape sequence"
15:25:26 <dmwit> I see you have actually got \x y -> round (fromInteger x / y)
15:25:32 <mux> yes
15:25:41 <dmwit> :t \x y -> round (fromInteger x / y)
15:25:43 <lambdabot> forall a b. (RealFrac a, Integral b) => Integer -> a -> b
15:25:49 <omniscientIdiot> from (/) it infers that 'fromInteger picosecs' and '1000000' are RealFrac a => a, but it has to default them to pick an implementation of (/)
15:25:49 <dmwit> :t \x y -> round (fromInteger x :: Double / y)
15:25:51 <lambdabot>     No instance for (RealFrac (/ Double y))
15:25:51 <lambdabot>       arising from use of `round' at <interactive>:1:8-42
15:25:55 <oerjan> mux: use / 1000000 :: Double)
15:25:55 <SaMBuCa_> xerox told me to read a pdf introduction 2 haskell 4 n00bs....but i don't remember the name...can u help me?
15:26:06 <dmwit> :t \x y -> round ((romInteger x :: Double)/ y)
15:26:08 <lambdabot> Not in scope: `romInteger'
15:26:12 <dmwit> :t \x y -> round ((fomInteger x :: Double)/ y)
15:26:14 <lambdabot> Not in scope: `fomInteger'
15:26:19 <dmwit> ugh
15:26:21 <iguana_> SaMBuCa_: yaht?
15:26:24 <dmwit> :t \x y -> round ((fromInteger x :: Double)/ y)
15:26:26 <lambdabot> forall b. (Integral b) => Integer -> Double -> b
15:26:27 <iguana_> (search google for that)
15:26:42 <dmwit> mux: Adding some judicious type declarations should clear the warning.
15:26:47 <MyCatVerbs> LoganCapaldo: what, as in \n, \t, etc? Yeah, those too I guess, but only really if there are double quotes surrounding. :)
15:27:04 <LoganCapaldo> well I learned Latex slightly before haskell
15:27:11 <LoganCapaldo> so i don't need the double quotes :)
15:27:15 <mux> ok
15:27:18 <SaMBuCa_> iguana: "yaht"?
15:27:28 <omniscientIdiot> yet another haskell tutorial
15:27:33 <allbery_b> @where yaht
15:27:33 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
15:27:39 <LoganCapaldo> it's long boat
15:27:41 <hpaste>  mux annotated "Why the warning about defaulting?" with "Fixed version, thanks guys :-)" at http://hpaste.org/3016#a1
15:27:41 <omniscientIdiot> there's also a wikibook version
15:27:43 <SaMBuCa_> lol
15:27:45 <LoganCapaldo> that teaches you haskell
15:27:47 <mux> :)
15:27:50 <MyCatVerbs> SaMBuCa_: Yet Another Haskell Tutorial.
15:28:04 <MyCatVerbs> Ooops, sorry, I missed omniscientIdiot. >>
15:28:26 <omniscientIdiot> mux: there was technically nothing wrong with it, it was just warning that it had to default
15:29:15 <omniscientIdiot> @google yaht wikibook
15:29:18 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
15:29:18 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
15:29:39 <prophet> How do I make a union datatype that was either an element or list of elements? I tried this: data ItemOrList = Item a | [a] -- But it didn't work :P
15:29:43 <SaMBuCa_> tnx
15:29:52 <mux> omniscientIdiot: yeah, I just wasn't seeing the need for GHC to default anything there
15:29:57 <dmwit> prophet: You need a constructor for each of those.
15:29:57 <dmwit> Try:
15:29:58 <omniscientIdiot> prophet: data ItemOrList = Item a | List [a]
15:30:02 <tacc> has anyone done problem 144 on projecteuler.net?
15:30:04 <dmwit> data ItemOrList = Item a | List [a]
15:30:14 <twanvl> mux: why do you want to round anyway? To me floor (or directly using div) seems like the right thing to do here
15:30:15 * LoganCapaldo would do Item a | Items [a]
15:30:22 <dmwit> prophet: You may also be interested in the built-in (Either a [a]) type.
15:30:26 * omniscientIdiot agrees with Logan
15:30:29 <prophet> I thought [] was syntactic sugar for List whatever
15:30:53 <omniscientIdiot> prophet: it is, but you need a constructor to put it into your datatype
15:30:57 <LoganCapaldo> prophet: Item a | [a] doesn't type check
15:31:19 <dataangel> Either is probably what I want
15:31:25 <omniscientIdiot> LoganCapaldo: not *exactly*, the problem is that the [] constructor is already taken
15:31:58 <LoganCapaldo> omniscientIdiot: I don't think he was thinking of it in those terms though, correct me if I am wrong dataangel
15:33:02 <dataangel> not sure
15:33:21 <omniscientIdiot> data Type tvar1 tvar2 ... tvarn = Cons1 t1 t2 ... tn | Cons2 t1 t2 ... tn | ... | Consn t1 t2 ... tn
15:33:41 <omniscientIdiot> [a] by itself is just the list type
15:33:49 <LoganCapaldo> Basically you can't have a type that's an existing type and oh by the way something else
15:34:04 <SaMBuCa_> What is the work that "@google" do?
15:34:05 <omniscientIdiot> to be a part of your new datatype, you'll have to box the list up into a data constructor
15:34:20 <dataangel> What kind of variables does a data declaration take before the = if they aren't used in this case? I'm guessing by reusing 'a' it knows they should be the same
15:34:23 <LoganCapaldo> it wouldn't be able to figure out whether [1] was a [a] or a ListOrItem
15:34:25 <dmwit> Cons1 t11 t12 ... t1a | Cons2 t21 t22 ... t2b | ... | Consm tm1 tm2 ... tmc
15:36:04 <oerjan> dataangel: all variables to the right of = must be mentioned to the left
15:36:05 <EvilTerran> the thing on the left of the = is the type returned by any of the things on the right of it
15:36:36 <LoganCapaldo> but you can do this, data Foo a b c = Foo Int
15:36:41 <LoganCapaldo> bwahahaha
15:36:49 <omniscientIdiot> shh!
15:36:52 <oerjan> the opposite is sometimes useful for type hackery
15:37:10 <oerjan> er, having something on the left not mentioned on the right
15:37:22 <EvilTerran> LoganCapaldo's suggestion is not without its uses, but generally only when you've been overdoing your consumption of olegs.
15:37:26 <oerjan> (called "phantom" types)
15:37:48 * omniscientIdiot hits LoganCapaldo with an existentially-qualified type
15:38:15 <EvilTerran> also, you can have a type variable on the right that isn't on the left with -as omniscientIdiot just mentioned - existental typesw
15:38:31 <EvilTerran> and then there's GADTs ;)
15:38:43 <dataangel> geeks ;)
15:38:51 <omniscientIdiot> *sigh*, can we just teach him the basics, please
15:39:05 <oerjan> basically haskell grows type extensions like the plague
15:39:14 <EvilTerran> dataangel, er, you do realise you're on freenode?
15:39:16 <dataangel> actually I've heard the term 'phantom types' and was wondering what it was, interesting to know even if I have no idea how to make use of them yet
15:39:28 <EvilTerran> in a channel full of academics, no less
15:39:43 <dataangel> I know ;0
15:39:51 <dataangel> I'm on my way to becoming an academic
15:39:57 <dmwit> YAY!
15:40:08 * LoganCapaldo is a rebel
15:40:08 <dataangel> it just seemed appropriate to say
15:40:15 <LoganCapaldo> a non-academic
15:40:22 <omniscientIdiot> @quote kool
15:40:23 <lambdabot> eyeris says: grr... I hate the way every haskell tutorial brags about how easy strings are to use. They are only easy once you drink the koolaid.
15:40:23 <oerjan> LoganCapaldo: just like everyone else
15:40:38 <dataangel> I'm still having to warp my brain everytime I try to use foldl though, so I think I have a ways to go
15:40:51 <LoganCapaldo> Everyone else is a rebel or everyone else is a non-academic?
15:40:54 <LoganCapaldo> Or both???
15:40:56 <oerjan> don't use foldl!
15:41:03 <dataangel> lol
15:41:07 <dataangel> lol?
15:41:08 <oerjan> use foldl' or foldr
15:41:10 <dataangel> err, why?
15:41:13 <omniscientIdiot> @quote foldr
15:41:13 <lambdabot> Cale says: I know I always have trouble explaining what the weather is like without involving foldr somehow.
15:41:23 <dataangel> What's foldl'?
15:41:25 <EvilTerran> unless you're sure that you want that one in particular
15:41:25 <oerjan> because foldl builds up uge thunks
15:41:29 <oerjan> *huge
15:41:43 <oerjan> @src foldl'
15:41:43 <lambdabot> foldl' f a []     = a
15:41:43 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:41:45 <EvilTerran> foldl f e (x:xs) = foldl f (f e x) xs -- you've seen this, i take it?
15:41:47 <dataangel> Well, I want foldl instead of foldr right, since the latter won't work with infinite lists, right?
15:42:00 <LoganCapaldo> backwards
15:42:15 <LoganCapaldo> foldr works dandy with infinite lists
15:42:20 <thoughtpolice> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29#Evaluation_order_considerations
15:42:23 <lambdabot> http://tinyurl.com/y4jgyn
15:42:29 <LoganCapaldo> DANDY I say
15:42:32 <LoganCapaldo> woah
15:42:36 <LoganCapaldo> I need to chill :)
15:42:37 <sorear> foldl is the one that breaks with infinite lists
15:42:41 <dataangel> oh, so this is wrong? http://www.zvon.org/other/haskell/Outputprelude/foldr_f.html
15:42:43 <lambdabot> Title: Haskell : foldr
15:42:50 <dataangel> It says it takes the last item of the list, which won't work for infinite lists
15:42:59 <EvilTerran> lazy languages evaluate outside-to-inside, so foldl needs to be applied to every element in your list before it starts evaluating f
15:43:30 <EvilTerran> as each application of f happens as a parameter to an application of foldl, and isn't forced inside the (x:xs) case
15:43:46 <tacc> that zvon site sucks, use skell.org/ghc/docs/latest/html/libraries/base/Prelude.html
15:44:00 <dataangel> tacc: it was just the first google result for "haskell foldr"
15:44:03 <EvilTerran> foldr f e (x:xs) = f e (foldr f e xs) -- f is on the outside, so gets forced before the following foldrs
15:44:05 <tacc> s/skell/haskell/
15:44:10 <EvilTerran> dataangel, do you see?
15:44:17 <ddarius> Phantom types are extremely useful and don't require insane type hackery to be useful.
15:44:30 <EvilTerran> @docs Prelude
15:44:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
15:44:59 <dmwit> data Clean
15:45:01 <dmwit> data Unclean
15:45:09 <dmwit> data ProtectedString a = PS String
15:45:18 <EvilTerran> ddarius, it's a level of type hackery that's still probably not appropriate when giving newbies the whistlestop tour
15:45:22 <dmwit> sanitize :: ProtectedString Unclean -> ProtectedString Clean
15:45:27 <dataangel> EvilTerran: Yes, but still, that won't work with infinite lists right? You can't take the last item of something that's infinite.
15:45:47 <EvilTerran> dataangel, ah, but! it depends if your f depends on its second parameter or not
15:46:11 <sarehu> > take 20 $ foldr (:) [] [1..]
15:46:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
15:46:17 <dataangel> EvilTerran: in most situations though, won't people use f's that use both params?
15:46:50 <dataangel> sarehu: could you write that with more operators? it's not close enough to perl
15:46:55 <oerjan> > foldr (:) [] [1..] -- lambdabot truncates automatically
15:46:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:46:57 <omniscientIdiot> dataangel: the key is that f can produce a top-level constructor for evaluation before evaluating its second arg
15:47:03 <EvilTerran> that's "most" of an infinite space, dataangel ;)
15:47:12 <EvilTerran> also, what omni said
15:47:18 <sarehu> mine is portable to GHCi ^_^
15:48:32 <iguana_> @type maybe
15:48:34 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:49:12 <dmwit> :t \x -> maybe x const
15:49:14 <lambdabot> forall a b. (b -> a) -> Maybe a -> b -> a
15:49:16 <LoganCapaldo> I love the religious functions
15:49:24 <EvilTerran> ?
15:49:29 <dataangel> sarehu: I'm confused why your example works
15:49:32 <omniscientIdiot> > map (maybe fromEnum 0) [Just 'a', Just '/', Nothing]
15:49:33 <lambdabot>        add an instance declaration for (Num (Char -> a -> Int))
15:49:55 <omniscientIdiot> > map (maybe 0 fromEnum) [Just 'a', Just '/', Nothing] -- had the order wrong
15:49:56 <lambdabot>  [97,47,0]
15:50:24 <omniscientIdiot> maybe n j (Just x) = j x, maybe n j Nothing = n
15:50:25 <dmwit> :t \x -> maybe x id -- whoops
15:50:26 <sarehu> dataangel: foldr replaces : i.e. 'cons' with a custom function and [] with a custom value.
15:50:27 <lambdabot> forall a. a -> Maybe a -> a
15:50:29 <dataangel> sarehu: the foldr description says it will apply (:) to the second argument, so [], and the last item in the list... like a gajillion ;) So after the first step we should get a single entry list with infinity inside it...
15:51:13 <omniscientIdiot> dataangel: do you understand Haskell's evaluation order?
15:51:14 <dataangel> sarehu: You mean (:) and [] are specially defined inside foldr? @_@
15:51:20 <sarehu> dataangel: no no no
15:51:25 <dataangel> lol
15:51:30 <EvilTerran> oh no, they're replaced within the list you give it
15:51:34 <sarehu> dataangel: what will (head (1 : foldr foo bar someList)) equal?
15:51:38 <ddarius> @src foldr
15:51:38 <lambdabot> foldr k z xs = go xs
15:51:38 <lambdabot>     where go []     = z
15:51:38 <lambdabot>           go (y:ys) = y `k` go ys
15:51:44 <dataangel> omniscientIdiot: I know that it's different, and I understood when you said outside-to-inside, but maybe I'm not recognizing how it applies here...
15:51:53 <EvilTerran> foldr (+) 0 [1,2,3] = foldr (+) 0 (1:2:3:[]) = 1+2+3+0
15:52:00 <oerjan> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs -- obligatory example
15:52:02 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:52:05 <EvilTerran> the [] is replaced with 0, and the (:) with (+)
15:52:16 <sarehu> there the function (:) is applied to something that depends on the 'last' value of the list.  But... that's ok, we can see part of the return value
15:52:22 <ddarius> @where fold
15:52:22 <lambdabot> I know nothing about fold.
15:52:28 <ddarius> @where foldr
15:52:28 <lambdabot> I know nothing about foldr.
15:52:43 <omniscientIdiot> @Cale lazy example
15:52:43 <lambdabot> Unknown command, try @list
15:52:48 <omniscientIdiot> awww
15:53:00 <omniscientIdiot> someone write an @Cale command!
15:53:04 <chessguy> @go haskell wiki lazy magic
15:53:07 <lambdabot> http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation
15:53:07 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
15:53:18 <EvilTerran> sounds like a RHCP album
15:53:43 <dataangel> EvilTerran: errr... but Haskell isn't actually doing rewriting per se... I thought?
15:53:58 <dmwit> It's a fine mental model, though.
15:54:09 * dataangel reads the wiki
15:54:24 <LoganCapaldo> trust the wiki, the wiki is your friend
15:54:25 <monochrom> I like thinking of Haskell execution as rewriting, too.
15:54:34 <EvilTerran> dataangel, not on a stream of tokens, no. it's got a tree of things-to-be-evaluated that it repeatedly evalutes the root of.
15:54:38 <EvilTerran> that's how i think of it, anyway.
15:54:52 <oerjan> dataangel: graph rewriting is a perfectly acceptable implementation technique for haskell
15:54:55 <LoganCapaldo> I don't think about haskell's evaluation
15:55:15 <LoganCapaldo> It working is an axiom as far as I am concerned :-p
15:55:23 <omniscientIdiot> LoganCapaldo: maybe not about the order, but you have to evaluate things in your head to see if they work
15:55:24 <monochrom> haha
15:56:25 <monochrom> Hardware uses binary for numbers. But we pretend it does decimal, or whatever.
15:56:58 <monochrom> As long as there is a bisimulation between what it does and what we pretend it does, there is no problem.
15:57:10 <omniscientIdiot> dataangel: foldr f z (x:xs) = f x (foldr f z xs) -- so when foldr applies to a non-empty list, it immediately calls 'f'.  If 'f' produces a top level constructor before having to evaluate its second arg, that constructor can be matched, elsewhere, immediately, before even having to look any further down the list
15:57:30 <EvilTerran> @where WHNF
15:57:30 <lambdabot> I know nothing about whnf.
15:58:14 <ddarius> > let head = foldr const (error "head of empty list) in head [1,2,3]
15:58:14 <lambdabot>  Improperly terminated string
15:58:18 <ddarius> > let head = foldr const (error "head of empty list") in head [1,2,3]
15:58:20 <lambdabot>  1
15:58:44 <omniscientIdiot> @let head' = foldr const (error "head of empty list")
15:58:48 <lambdabot> Defined.
15:58:49 <omniscientIdiot> > head' [1..]
15:58:50 <lambdabot>  1
15:59:07 <omniscientIdiot> > head' []
15:59:08 <lambdabot>  Exception: head of empty list
15:59:10 <tacc> > take 10 primes
15:59:10 <lambdabot>   Not in scope: `primes'
15:59:15 <thoughtpolice> here's a link for stuff on WHNF and the like: http://en.wikibooks.org/wiki/Haskell/Laziness
15:59:21 <dataangel> omniscientIdea: How would f "produce a top level constructor before having to evaluate its second arg"? By top level constructor, you mean, if it could deduce what concrete type (which union constructor if dealing with a union) f is going to return, before evaluating the second arg?
15:59:38 <EvilTerran> not what type, that's determined at compiletime
15:59:46 <EvilTerran> but which constructor of that type
15:59:54 <EvilTerran> eg, is it returning (x:xs) or []?
16:00:03 <oerjan> @let primes = nubBy ((>1).gcd) [2..]
16:00:04 <EvilTerran> is it returning Nothing, or Just x?
16:00:04 <lambdabot> Couldn't match expected type `a -> Bool'
16:00:05 <EvilTerran> etc
16:00:13 <dataangel> using 'constructor' in that context leaves a funny taste :) C++ has traumatized me
16:00:19 <oerjan> @let primes = nubBy (((>1).).gcd) [2..]
16:00:22 <lambdabot> Defined.
16:00:24 <dataangel> right
16:00:27 <dataangel> I understand
16:00:29 <EvilTerran> okay, in haskell, a constructor is a function you can patternmatch on
16:00:31 <oerjan> > take 10 primes
16:00:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
16:00:43 <dataangel> right I got that too
16:00:49 <EvilTerran> they either start with a capital letter, or a colon (in the case of infix ones)
16:00:55 <dataangel> yep read that
16:01:06 <omniscientIdiot> A constructor is a tag that defines data.  You can pass other data into to make more complex data, or use pattern matching to pull it apart.
16:01:40 <EvilTerran> the least non-zero amount of information that can be determined about a value is its outermost constructor
16:01:53 <dataangel> how from looking at the definition of foldr though can I know that it gives a top level constructor before its second arg needs to be evaluated? Since it's not referenced except in the empty list definition... ah hah...
16:02:43 <omniscientIdiot> EvilTerran, dataangel: and the parameters to the constructor usually aren't evaluated yet (i.e. they're just pointers to evaluating code) until they are forced.
16:02:57 <EvilTerran> it doesn't always do so. that depends on the properties of f, dataangel.
16:03:35 <omniscientIdiot> dataangel: you'd have to look at the definition of f.
16:03:38 <oerjan> > foldr (+) 0 [1..] -- doesn't work
16:03:40 <lambdabot>  Exception: stack overflow
16:03:52 <EvilTerran> however, you can tell from its definition that, in the (x:xs) case, f is started to be evaluated before (foldr f e xs) is
16:03:56 <omniscientIdiot> foldr (:) [] -- f obviously gives a constructor.  It is one!
16:04:05 <oerjan> > foldr (:) [] [1..] -- works perfectly
16:04:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:04:31 <omniscientIdiot> ^^ that evals to: (:) 1 (foldr (:) [] [2..])
16:04:32 <EvilTerran> and, from that, it's possible to write an application of foldr that isn't strict in the tail of the list
16:05:02 <omniscientIdiot> the printer sees the (:) 1 (...) so it prints "[1," and forces the (...)
16:05:05 <EvilTerran> however, for foldl, the next application of foldl happens before the first application of f
16:05:17 <LoganCapaldo> > foldl (flip (:)) [] [1..]
16:05:21 <lambdabot> Terminated
16:05:25 <LoganCapaldo> see?
16:05:33 <EvilTerran> > foldl (flip (:)) [] [1..10] -- reverse, btw
16:05:34 <LoganCapaldo> > foldl (flip (:)) [] [1,2,3]
16:05:34 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
16:05:35 <lambdabot>  [3,2,1]
16:05:42 <EvilTerran> glorious stereo!
16:05:53 <chessguy> @stereo
16:05:54 <lambdabot> Unknown command, try @list
16:06:02 <chessguy> we need an @stereo :)
16:06:07 <sclv> @quote stereo
16:06:07 <lambdabot> z0d says: What was the stereo quote?
16:06:14 <chessguy> haha
16:06:14 <EvilTerran> *snerk*
16:06:15 <omniscientIdiot> no we don't
16:06:19 <LoganCapaldo> stereo is dead, may it RIP
16:06:25 <chessguy> @quote Cale.stereo
16:06:25 <lambdabot> No quotes match. My mind is going. I can feel it.
16:06:27 * omniscientIdiot shakes fist at stereo quote
16:06:33 <chessguy> @quote stereo
16:06:33 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
16:06:37 <chessguy> hahaha
16:06:48 <LoganCapaldo> It's the end of an era
16:06:54 <olsner> @quote stereo
16:06:54 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
16:07:20 <omniscientIdiot> anyways, did you understand the explanation, dataangel?
16:07:52 <dataangel> omniscientIdiot: I'm digesting it ;p
16:08:02 <sclv> @quote knot
16:08:03 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
16:08:07 <sclv> @quote knot
16:08:07 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
16:08:11 <sclv> @quote
16:08:11 <lambdabot> b7j0c says: the haskell community should take out life insurance on dons
16:08:17 <LoganCapaldo> hehhe
16:08:21 <monochrom> hahaha
16:08:24 <dmwit> heh
16:08:28 <dmwit> I like that one a lot.
16:08:30 <dmwit> b7j0c++
16:08:31 <omniscientIdiot> foldr (:) [] [1..] = (:) 1 (foldr (:) [] [2..])  {- then print sees ((:) 1 ...) and prints "[1," and forces: -}  = (:) 1 ((:) 2 (foldr (:) [] [3..]))
16:09:11 <olsner> > head (read ("[1,2,"++undefined))
16:09:13 <lambdabot>  Undefined
16:09:39 <chessguy> > foldr (:) [] [1..]
16:09:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:09:44 <LoganCapaldo> read is too strict, I thought we had established this earlier today
16:10:19 <olsner> hmm, perhaps we did
16:10:40 <olsner> I do seem to recall this discussion
16:10:54 <dmwit> > reads ("[1,2," ++ undefined)
16:10:56 <lambdabot>  []
16:10:59 <dmwit> huh
16:11:19 <LoganCapaldo> reads doesn't cause an error on a failure to parse
16:11:26 <LoganCapaldo> it just returns an empty list
16:11:30 <LoganCapaldo> @type reads
16:11:32 <lambdabot> forall a. (Read a) => String -> [(a, String)]
16:11:34 <dmwit> Oh, duh, I shouldn't expect that to work.
16:11:39 <dmwit> Thanks, LoganCapaldo.
16:11:54 <oerjan> except how can it do that when it hits undefined?
16:11:55 <omniscientIdiot> @src read
16:11:56 <lambdabot> read s = either error id (readEither s)
16:12:05 <Saizan> > reads "[1,2]"
16:12:06 <lambdabot>  []
16:12:09 <monochrom> There seems some defaulting or monomorphism going on with reads ("[1,2," ++ undefined)
16:12:16 <LoganCapaldo> woah
16:12:25 <omniscientIdiot> > reads "[1,2]" :: [Int] -- it defaulted wrong
16:12:25 <LoganCapaldo> Saizan you just took a shotgun to my mind
16:12:26 <lambdabot>  Couldn't match expected type `Int'
16:12:40 <dmwit> > read "[1,2]" :: ([Int], String)
16:12:42 <lambdabot>  Exception: Prelude.read: no parse
16:12:45 <dmwit> > reads "[1,2]" :: ([Int], String)
16:12:46 <lambdabot>  Couldn't match expected type `([Int], String)'
16:12:49 <omniscientIdiot> > (reads::ReadS  [Int]) "[1,2]" -- it defaulted wrong
16:12:50 <lambdabot>  [([1,2],"")]
16:12:56 <omniscientIdiot> there we are :)
16:13:02 <LoganCapaldo> there we go
16:13:26 <Saizan> > (reads::ReadS  [Int]) $ "[1,2" ++ undefined
16:13:27 <lambdabot>  Undefined
16:14:08 <olsner> it can't know if the string ends with ] without examining it to the end, unfortunately
16:14:19 <LoganCapaldo> unfortunately
16:14:55 <LoganCapaldo> I don't see how that's a problem
16:15:30 <olsner> that means it can't be lazy enough for (head . reads) "[" ++ undefined to work
16:15:43 <LoganCapaldo> sue?
16:15:48 <LoganCapaldo> *sure?
16:15:52 <dmwit> That's fine, because maybe it really isn't a list.
16:15:59 <monochrom> What would you like for parsing "[1,2 a" ?
16:16:00 <dmwit> Maybe the string really is "[32,garbage"
16:16:11 <LoganCapaldo> 1 : 2 : error "garbage"
16:16:17 <LoganCapaldo> ?
16:16:27 <omniscientIdiot> in which case having already returned a partially- constructed list would be problematic
16:16:37 <dmwit> LoganCapaldo: No, you want it to return []
16:16:40 <dataangel> I am now more confused after consulting wikibooks :)
16:16:55 <LoganCapaldo> Am I nuts?
16:17:06 <LoganCapaldo> I feel like this would be a perfectly ok response
16:17:09 <monochrom> That's undecidable.
16:17:10 <dataangel> there explanation of foldl puts f on the outside as well
16:17:20 <dataangel> *their
16:17:25 <dmwit> LoganCapaldo: I'm pretty sure I use reads to *avoid* errors.
16:17:36 <oerjan> > head . unfoldr (listToMaybe . reads) $ "1 2 fnord" :: Integer
16:17:38 <lambdabot>  1
16:17:39 <edwardk> logan: the biggest worry that i have is that I think your interpretation would require that reads cannot backtrack at all.
16:17:40 <omniscientIdiot> dataangel: nope, foldl has to evaluate foldl before reaching a toplevel constructor
16:17:57 <oerjan> > unfoldr (listToMaybe . reads) $ "1 2 fnord" :: [Integer]
16:17:58 <LoganCapaldo> edwardk: that seems a valid point
16:17:59 <lambdabot>  [1,2]
16:18:19 <edwardk> logan: that would shutdown a number of perfectly valid parsers
16:18:28 <dataangel> omniscientIdiot: Maybe correct the wiki? http://en.wikibooks.org/wiki/Haskell/List_processing They say foldl f z becomes "f (f (f z a) b) c"
16:18:29 <lambdabot> Title: Haskell/List processing - Wikibooks, collection of open-content textbooks
16:18:45 <omniscientIdiot> dataangel: exactly
16:18:54 <dataangel> omniscientIdiot: that has f on the outside! :P
16:19:17 <sioraiocht_> wow, people i recognise on #haskell!
16:19:19 <dataangel> I (mistakenly?) thought that was the defining feature here...
16:19:28 <omniscientIdiot> dataangel: but foldl f z (x:xs) = foldl (f z x) z xs, which doesn't
16:19:32 <scodil> does someone want to help me with some type-level programming? I'm working on a record system, but for data in memory rather than native haskell values. Kind of like Storable, except you can peek/poke individual fields without having to (de)serialize the whole record. I'm trying to make the record an instance of Storable, but it's messing up my type-level functions. Can anyone take a look? http://hpaste.org/3017
16:19:45 <edwardk> i'd be cool if "[1,2" + undefined could at least go to [1,error "blech"] (since it wouldn't be able to finish parsing the integer for 2, but that would require the creator of the list reads instance to somehow commit to the parse to a certain point.
16:19:59 <dataangel> omniscientIdiot: oh
16:20:01 <edwardk> er ++
16:20:46 <tomodiz> how would you convert the length of a list to a float
16:21:06 <omniscientIdiot> > fromIntegral (length [1..10]) :: Float
16:21:08 <lambdabot>  10.0
16:21:08 <oerjan> @quote fromIntegral
16:21:08 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:21:11 <sclv> :t fromIntegral
16:21:12 <tomodiz> thanks
16:21:13 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:21:27 <edwardk> "[1,2," ++ undefined could also be made to get the [1,2,error "blech"] with enough contortions, but you can't finish parsing the 2 to get [1,2" + to have a second non-error list item.
16:22:01 <dmwit> edwardk: I would be okay with "[1,2,garbage]" -> [1,2,error "garbage"], but I argue that "[1,2,garbage" should not successfully parse as a list at all.
16:22:22 * omniscientIdiot had to look up foldl's definition.  Such a seldom-used function :D
16:22:26 <edwardk> dmwit: i personally agree
16:23:14 <edwardk> dmwit: otherwise a parser for a 'list-like-thing' and a parser for a 'list-comprehension-like-thing' couldn't be combined
16:23:15 <ddarius> omniscientIdiot: foldl' and foldr should both be very commonly used functions
16:23:20 <dataangel> omniscientIdiot: I was wrong about how fold works -- I thought of the accumulator as a "starting value" before, I didn't think of it as, "on the last call of f, when there need to be two arguments and one can't be another application of f because we're out of items, this is the value to use"
16:23:59 <dataangel> omniscientIdiot: I guess I pictured the tree upside down
16:24:16 <LoganCapaldo> dataangel: have you seen Cale'
16:24:21 <LoganCapaldo> 's diagrams?
16:24:25 <ddarius> dataangel: foldl (and foldl') do work essentially in that way.
16:24:31 <omniscientIdiot> if fact, /me got it wrong :D
16:24:37 <Saizan> dataangel: with foldl the accumulator _is_ the starting value
16:24:47 <dataangel> LoganCapaldo: There are diagrams on wikibooks and wikipedia, but I don't know if those are the one's you're thinking of
16:25:02 <dataangel> Saizan: which for me is the intuitive thing ;p
16:25:06 <ddarius> dataangel: Those are the same diagrams, but Cale also has a page specifically on the diagrams.
16:25:07 <oerjan> LoganCapaldo: Cale', is that the strict version?
16:25:23 <LoganCapaldo> heh
16:25:25 <ddarius> http://cale.yi.org/index.php/Fold_Diagrams
16:25:26 <lambdabot> Title: Fold Diagrams - CaleWiki
16:28:50 <dataangel> I keep testing my understandings by trying to duplicate foldr (/) 2 [8,12,24,4] = 8.0, but all of my orders fail :P
16:28:59 <omniscientIdiot> with an infinite list, you'll never be able to inspect a toplevel constructor because it'll expand to: foldl f (foldl f (foldl f (foldl f (...)))) never getting to the bottom (f z x) which would allow f to possibly result in an inspectable constructor
16:30:10 <omniscientIdiot> (if I understand it correctly) :D
16:30:26 <tehgeekmeister> how can simple record type (a pair, for example) be defined such that both elements must be of the same type?
16:30:42 <newsham> its turtles all the way down
16:30:42 <ddarius> type Pair a = (a,a)
16:30:44 <omniscientIdiot> tehgeekmeister: you can make a custorm type
16:30:52 <omniscientIdiot> (lol, custorm)
16:31:25 <ddarius> omniscientIdiot: foldl doesn't look like that
16:31:29 <dataangel> omniscientIdiot: The tree diagram makes me think foldr (/) 2 [8,12,24,4] = (4 / (24 / (12 / (8 / 2)))) but that = 0.5, not 8
16:32:06 <omniscientIdiot> are you talking about the local 'lgo' definition?
16:32:10 <oerjan> dataangel: wrong direction on the list
16:32:54 <oerjan> note that for foldr, the initial value (2) gets combined with the last element of the list, if any
16:33:12 <dataangel> oerjan: Why would you describe foldr as looking at the last item in the list then? Is the explanation just bad?
16:33:26 <oerjan> huh?
16:33:57 <omniscientIdiot> dataangel: it's bad.  It kinda seems to suggest that evaluation is innermost-first, when it's not.
16:34:00 <dataangel> oerjan: "it takes the second argument and the last item of the list and applies the function"
16:34:14 <oerjan> some of the problem is that / is a strict function which does _not_ produce a constructor until it has evaluated everything
16:34:33 <tacc> foldl f z xs = last (scanl f z xs)
16:34:50 <dataangel> oerjan: wait... that's what everyone just said foldl was, this is foldr
16:35:09 <dataangel> crap, cleared IRC window
16:35:49 <omniscientIdiot> http://tunes.org/~nef/logs/haskell/07.09.30
16:35:55 <LoganCapaldo> dataangel: 8 : 12 : 24 : 4 :  [] -> 8 / ( 12 / ( 24 / (4 / 2). You replace the (:) with the function and [] with the initial aucucmlator value
16:36:02 <oerjan> http://ircbrowse.com/channel/haskell/20070930
16:36:04 <lambdabot> Title: Meme haskell IRC Log 2007/09/30
16:36:31 <oerjan> whoops
16:36:55 <LoganCapaldo> if that helps
16:36:57 <oerjan> it has changed to new day, but no link yet
16:38:54 <dataangel> LoganCapaldo: the reason that example is confusing is because the choice of : seems arbitrary so long as the operator is left associative
16:39:50 <LoganCapaldo> well it may helpp to compare with the same version with foldl:
16:40:32 <LoganCapaldo> ((((2 / 8) / 12) / 24) / 4 )
16:40:56 <dataangel> how would you express that in terms of : and [] replacing? that may help
16:41:07 <LoganCapaldo> you still replace : with the function
16:41:15 <LoganCapaldo> you don't do anything with []
16:41:30 <LoganCapaldo> and you stick the aculator at the front intead of replace [] with it
16:42:36 <dataangel> LoganCapaldo: "stick"?
16:43:08 <LoganCapaldo> lol sorry
16:43:25 <LoganCapaldo> the initial accumulator value becomes your first value
16:43:38 <dataangel> LoganCapaldo: like this?:  [] ++ [8] ++ [12] ++ [24] ++ [4]...  then you replace ++ with the function... err.... but strip the elements out of the lists... and replace []...
16:43:52 <dataangel> oh so like
16:43:55 <LoganCapaldo> um
16:44:09 <dataangel> hmm... with it as the first value you can't really write it the same way as before
16:44:17 <dataangel> [] : 8 doesn't work ;p
16:44:39 <omniscientIdiot> > let snoc = flip (:) in [] `snoc` 8
16:44:41 <lambdabot>  [8]
16:44:45 <LoganCapaldo> no but 2 : 8 : 12 : 24 : 4 does
16:45:54 <LoganCapaldo> it's like you cons the accumlator on to the front of the list, forget about [] and replace the : with the function
16:45:58 <LoganCapaldo> (for foldl)
16:46:23 <dataangel> LoganCapaldo: I think I get it but I dunno if explaining it as rewriting is a good idea, since it doesn't work cleanly for foldl as well.
16:46:30 <oerjan> foldl "pretends" that lists chain together in the opposite direction
16:47:02 <LoganCapaldo>  oerjan: that's a good way of putting it
16:47:44 <LoganCapaldo> foldl f i = foldr f i . reverse sort of
16:47:54 <omniscientIdiot> foldl f z [1..] = foldl f (f 1 (foldl f (f 2 (foldl f (f 3 (foldl f (...))))))) -- I think this is right, ddarius
16:48:05 <oerjan> foldr (flip f) i . reverse
16:48:44 <omniscientIdiot> er, I think I flipped f's args
16:49:00 <oerjan> @check \l x f -> foldl (f::Int->Int->Int) x l == foldr (flip f) x (reverse l)
16:49:03 <dataangel> How does the accumulator work as an accumulator in foldl if it still gets applied in the most nested call? I'd expect an accumulator to be applied first, then the list items, with the last call being to the last two list items. I guess that isn't as elegant.
16:49:06 <lambdabot> Terminated
16:49:13 <ddarius> foldl f z [1..] ~> foldl f (f z 1) [2..] ~> foldl f (f (f z 1) 2) [3..] etc.
16:49:25 <ddarius> It doesn't build up a big nested collection of calls to foldl.
16:49:27 <ddarius> It's an iteration.
16:49:36 <oerjan> @check \l x f -> foldl' (f::Int->Int->Int) x l == foldr (flip f) x (reverse l)
16:49:42 <lambdabot>  OK, passed 500 tests.
16:49:42 <dataangel> ddarius: it builds up nested calls to f
16:49:49 <ddarius> dataangel: Yes.
16:49:51 <omniscientIdiot> ddarius: right, that was dumb of me
16:50:12 <ddarius> dataangel: That's why you usually want foldl'.
16:50:34 <dataangel> ddarius: why?
16:50:56 <omniscientIdiot> foldl forces the applications of f at each step
16:50:58 <LoganCapaldo> cause it's less lazy on you, so muchy less lazy lazy on you
16:50:58 <dataangel> ah from the diagrams foldl1 is what I intuively expected to happen
16:51:02 <omniscientIdiot> foldl', rather
16:52:26 <omniscientIdiot> using seq
16:52:35 <kaol> foo f x = f x `mplus` return x -- what would you call foo? or is such a foo already defined somewhere?
16:53:11 <omniscientIdiot> @. hoogle type \f x -> f x `mplus` return x
16:53:13 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) a.'
16:53:19 <omniscientIdiot> @type \f x -> f x `mplus` return x
16:53:21 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> m a) -> a -> m a
16:53:26 <idnar> @pl foo f x = f x `mplus` return x
16:53:27 <lambdabot> foo = (`ap` return) . (mplus .)
16:53:27 <dataangel> brb
16:53:36 <oerjan> kaol: resembles the guarded function which people have asked for, but which isn't defined
16:53:43 <idnar> @hoogle (a -> m a) -> a -> m a
16:53:43 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
16:53:44 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
16:53:44 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
16:54:01 <oerjan> er wait
16:54:01 <idnar> heh
16:54:04 <Cale> tryApply ?
16:54:21 <omniscientIdiot> it's some kind of Kleisli transform
16:54:30 <oerjan> actually it doesn't seem much similar anyhow
16:54:51 <Cale> It tries both possibilities of applying and not applying f
16:55:27 <Cale> "perhaps"
16:55:55 <Cale> er, hmm, it's a little different from that
16:56:16 <Cale> Because it's not  return (f x) `mplus` return x
16:56:18 <omniscientIdiot> would that name fit with the [] semantics
16:56:26 <kaol> I like "perhaps"
16:56:29 <omniscientIdiot> orReturn
16:57:19 <Cale> well, "perhaps" still works anyway
16:57:41 <Cale> It's sort of like, "try applying this transformation, but if you can't find a way, don't worry about it"
17:00:37 <mudge> umm,  is the class keyword just used for generic types,  and instance keyword used for specific types?
17:01:01 <mudge> like:   class Eq a where    for the variable a
17:01:10 <ddarius> mudge: Your terminology is jacked.
17:01:19 <mudge> and instance Eq Bool where    for the Bool type
17:01:25 <mudge> oh please straigten me out
17:01:30 <LoganCapaldo> jacked
17:01:30 <omniscientIdiot> classes are lists of functions and their types.  When you say a specific type is an instance of some class, you provide implementations of its members.
17:01:36 <LoganCapaldo> nice
17:02:40 <ddarius> mudge: A class declaration declares a name for a collection of types (or type constructors).  An instance declaration states that some type(s) (or type constructors) are in that collection.
17:02:43 <omniscientIdiot> Eq is the class of all types that can be compared for equality.  When you say instance Eq SomeType, you provide the implementation of the (==) operator for SomeType.
17:03:09 <ddarius> mudge: instance Eq a => Eq [a] is not about a specific type.
17:04:23 <mudge> oh i see,    thank you my teachers
17:04:47 <ddarius> mudge: Do you know some (very basic) set theory?
17:04:59 <mudge> just that it is about sets
17:10:30 <mudge> no i still don't get classes and instances
17:11:00 <omniscientIdiot> in java, a 'class' is three things simultaneously:  A set of types that satisfy a certain interface (Haskell class), A concrete type (Haskell data), and a declaration that the type belongs to the class (Haskell instance)
17:11:27 <SamB> of course, Haskell data is two things...
17:11:46 <sjanssen> mudge: very roughly: class is like interface in Java, instance is like implements
17:11:56 <omniscientIdiot> More concrete types can belong to the defined interface (i.e. 'subclasses' in java).
17:11:57 <mudge> i don't know java
17:12:10 <omniscientIdiot> oh
17:12:12 <monochrom> Some people use class for module.
17:12:13 <omniscientIdiot> bummer
17:12:35 <sjanssen> mudge: what about C++'s OO?
17:12:37 <SamB> monochrom: that's probably related to the fact that Java has no non-class-based functions
17:12:45 <mudge> nope
17:12:56 <Pseudonym> Yes, to confuse things slightly, Haskell "data" is both data and codata.
17:12:57 <SamB> mudge: hmm, that's nice
17:13:02 <Pseudonym> But let's ignore that for the moment.
17:13:08 <monochrom> mudge will eventually surprise all of us by saying "I only know C#" XD
17:13:15 <SamB> hahahaha
17:13:32 <mudge> Well I know PHP and C, and javascript
17:13:35 <SamB> I think he would have understood the Java stuff if he knew C#...
17:13:43 <ddarius> Oh great googly moogly
17:13:46 <monochrom> hehe
17:13:54 <monochrom> who is moogly?
17:14:06 <geocalc> is there a hscpp2hs ?
17:15:24 <SamB> geocalc: go ahead and write one ;-)
17:16:17 <geocalc> not enough proficient yet ;)
17:18:23 <mudge> okay, so a class defines the interface,  and instance gives the implementation
17:21:08 <dmwit> right
17:22:03 <mudge> a class describes an interface,  and a class can give default implementations of parts of the interface ---   and instances give implementations of the interface,  and can override default implementations given in the class
17:22:27 <dmwit> True
17:23:55 <fnord123> Hi all. I have a design question regarding 'data' types vs lists. I know in Lisp and Scheme, people are happy to pass lists around as data types; and my frustration in scheme is that I keep using records, which have clunky syntax. In haskell, what do people find to be more useful for them.
17:24:05 <mudge> so if you make a type an instance of a class  -- you have to define what the functions in the class mean for this type in the instance declaration
17:24:24 <LoganCapaldo> fnord123: it's pretty diffcult to use "just" lists in Haskell
17:24:31 <dmwit> fnord123: Records can still be a bit clunky in Haskell.
17:24:57 <LoganCapaldo> you can't have hetereogenous lists in Haskell for instance
17:25:07 <dmwit> fnord123: But they do a lot of work for you that you would have to do yourself if you were creating a non-record based data type.
17:25:27 <dmwit> mudge: Still correct! =)
17:25:35 <mudge> dmwit: thanks
17:26:15 <wnoise> you can't _easily_ have heterogeneous lists.  And there are ways to design such that you usually don't need or want them.
17:26:35 <LoganCapaldo> wnoise: shh
17:26:56 <wnoise> Really, I think records work fine in Haskell.  I don't "get" most of the complaints.
17:26:57 <SamB> fnord123: they are at least not more clunky than the alternative
17:27:32 <fnord123> so 'data' types.. it's appropriate to map a data type to db tables and use that rather than basing my data types off lists pulled from queries
17:27:41 <fnord123> i.e. formalise my types
17:27:53 <LoganCapaldo> it's not just appropiate, it's encouraged :)
17:28:02 <dmwit> wnoise: I have to main complaints; first, record modification isn't first-class, and second, the pattern-matching is really verbose.
17:28:05 <allbery_b> my only real complaint is that foo {bar = baz} (update syntax) is not a first-class function
17:28:19 <SamB> I agree
17:28:35 <SamB> I want composable updates
17:28:39 <fnord123> ah ok. Then I'll do that. A data type for my tables and then queries to pull the ones I want w/ serialization and so on.
17:28:40 <allbery_b> pattern matching verbosity doesn't bother me given that most of my records are large enough that an ordinary pattern match would be even more verbose
17:28:45 <dmwit> Verbosity is livable (and probably not fixable in a nice way), but first-classness is a real killer.
17:28:49 <allbery_b> or at least a lot longer
17:29:29 <mudge> i heard you could have heterogenous types in lists in haskell
17:29:30 <mudge> curious
17:29:38 <SamB> mudge: who said?
17:29:46 <allbery_b> nudge: maybe they were talking about HList
17:29:48 <SamB> mudge: there are some tricks you can do...
17:29:49 <wnoise> Is it that much of a pain to wrap a function around it to turn it into first class?
17:29:55 <mudge> coffeemug in #lisp
17:30:17 <wnoise> What does first-classness buy, anyways?  Obviously you guys would find it valuable, but I don't see how...
17:30:20 <mudge> SamB I wonder how you do that in Haskell
17:30:21 <dmwit> wnoise: Nope!  And it's totally mechanical, so why shouldn't the compiler do it?
17:30:33 <SamB> mudge: tricks involving extensions, actually
17:31:12 <allbery_b> (\r -> r {a=b}) is just annoying
17:31:28 <dmwit> wnoise: Suppose I want to pass the modifying function to a map or fold?
17:31:38 <SamB> allbery_b: I'm assuming he means that you should give it a name
17:32:21 <wnoise> See, I don't see (\r -> r {a=b}) as being that annoying.  More complicated, and yeah, it should be slapped in a where clause.
17:32:44 <wnoise> But, okay, yes, it's something the compiler should be doing.
17:33:01 <SamB> I was thinking more like "defined near the datatype"
17:33:12 <SamB> and maybe a slightly different function would be better
17:34:17 <fnord123> It shouldn't be difficult to define a hetereogenous list.
17:35:11 <dmwit> > [3, "hey"] :: [forall a. a]
17:35:11 <lambdabot>  Parse error
17:35:58 <dmwit> I guess it's probably difficult enough that I wouldn't want to implement it in lambdabot. =P
17:36:12 <wnoise> fnord123: you can use algebraic datatypes to make a new type that's the tagged union of what things you want in the list.
17:36:13 <SamB> dmwit: with GHC, you might get some kind of error talking about . and forall as type variables...
17:36:36 <LoganCapaldo> > [ toDyn 3, toDyn "hey" ]
17:36:38 <lambdabot>  [<<Integer>>,<<[Char]>>]
17:36:49 <SamB> Prelude> [3, "hey"] :: [forall a. a]
17:36:49 <SamB> <interactive>:1:4:
17:36:49 <SamB>     Couldn't match expected type `. (forall a)'
17:36:49 <SamB>            against inferred type `[]'
17:37:09 <geocalc> * fnord123 est parti ("bed")
17:37:26 <SamB> dmwit: wierd, eh?
17:37:29 <ddarius> dmwit: You'd want [3, "hey"] :: [exists a. a]
17:37:30 <wnoise> > [Left 3, Right "hey"]
17:37:31 <lambdabot>  [Left 3,Right "hey"]
17:37:39 <dmwit> SamB: A bit, yeah.
17:38:06 <dmwit> geocalc: That looks suspiciously French, and I don't speak French.  Therefore, fnord123 is still in the room. ;-)
17:38:21 <SamB> I'm not sure why GHC is parsing . as an infix type variable without any extensions enabled...
17:38:24 <geocalc> ?
17:38:51 <allbery_b> actually it's exactly because no extensions are enabled
17:39:08 <allbery_b> (I think)
17:39:20 <SamB> but I thought infix type variables WERE an extension?
17:40:19 <allbery_b> I think they're an extension but not one controlled by an extension flag
17:40:55 <SamB> that seems clear
17:41:04 <geocalc> fnord123 is not here for me why for you ?
17:41:07 <SamB> but it has got to be some kind of a bug
17:41:13 <SamB> or at least a misfeature
17:41:22 <allbery_b> ghc sometimes does that.  postfix operators are another example I think
17:41:25 <dmwit> geocalc: I was just kidding.  Sorry.
17:41:47 <geocalc> ok ok
17:41:52 <allbery_b> aarguiably it's a bug, or at least an infelicity, but since it's otherwise illegal syntax I suppose they don't worry much about it
17:42:04 <allbery_b> since it can't break h98 programs, being illegal h98 syntax
17:42:30 <SamB> it would be annoying if you were trying to write h98 code...
17:49:02 <mudge> okay, a monad is an instance of the Monad class, right?
17:49:26 <Saizan> yes
17:49:43 <mudge> wow, that's pretty simple,    if it's an instance of the monad class, than it is a monad
17:49:55 <mudge> a monad is an instance of a monad class,   gees,  that's so simple
17:50:01 <wnoise> Well, the instance has to obey the monad laws, too.
17:50:17 <wnoise> And unfortunately, the compiler can't yet check that.
17:50:34 <mudge> and the Monad class has the return and >>= functions
17:51:04 <Pseudonym> If it's any consolation, one of the monad laws is probably redundant.
17:51:19 <Pseudonym> So you only have to prove two of them.
17:51:31 <mudge> what are they?
17:51:40 <Pseudonym> return a >>= k = k a
17:51:47 <phobes> i. Don't talk about the Monad Laws
17:51:54 <Pseudonym> (m >>= k1) >>= k = m >>= (\x -> k1 x >>= k)
17:51:58 <Pseudonym> And the possibly redundant one:
17:52:01 <Pseudonym> m >>= return = m
17:52:20 <mudge> i found tham: http://haskell.org/haskellwiki/Monad_Laws
17:52:21 <lambdabot> Title: Monad laws - HaskellWiki
17:52:23 <mudge> why not talk about them?
17:52:25 <Pseudonym> Yeah.
17:52:42 <dmwit> phobes: =)
17:52:43 <platypus> Demorgains laws are redundent but usefull.
17:52:54 <Pseudonym> I'm not saying they're not useful.
17:53:02 <Pseudonym> But... oh, hell, just read my blog entry.
17:53:04 <ddarius> Pseudonym: Perhaps the last is a result of monads in Haskell being strong.
17:53:12 <dmwit> "possibly" redundant?
17:53:48 <Pseudonym> http://andrew.bromage.org/blog/archive/2007/09/post.html
17:53:49 <lambdabot> Title: The BWAIN: Laws on the cheap
17:53:50 <Pseudonym> And the one following.
17:54:08 <Pseudonym> dmwit: In the sense that I don't think there's a general proof that the law is provable from the others.
17:54:19 <Pseudonym> But for any monad you can name, you can prove it by induction on m.
17:54:58 <Pseudonym> The thing is, a "law" is not an "axiom".
17:55:18 <Pseudonym> An axiom is something that you, as someone who wants to build a cool new monad, have to prove about your implementation.
17:55:35 <Pseudonym> If you only have to prove two things instead of three, that's less work for you./
17:56:05 <Pseudonym> If one monad law can be proven from the other two, then that's one less thing you have to do.
17:56:10 <Pseudonym> Make sense?
17:56:26 <mudge> are the return and >>= functions the only the functions in the Monad class interface?
17:56:34 <Pseudonym> mudge: Oh, can of worms!
17:56:37 <dmwit> ?src Monad
17:56:37 <lambdabot> class  Monad m  where
17:56:37 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
17:56:37 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
17:56:37 <lambdabot>     return      :: a -> m a
17:56:37 <lambdabot>     fail        :: String -> m a
17:56:41 * dmwit sighs
17:56:51 <dmwit> fail
17:56:58 <Pseudonym> It's fair to say that nobody is happy about "fail" being there.
17:57:11 <Pseudonym> It's evil, but whether or not it's a necessary evil is still up for debate.
17:57:36 <Pseudonym> (>>) is the more interesting one.  It's obviously implementable in terms of (>>=), but you can provide a more efficient implementation if you want.
17:58:29 <kpreid> Pseudonym: are there instances that do?
17:58:35 <xelxebar> what does the @ symbol mean, such as in the expression (cs@(_:_),t)?
17:58:43 <sorear> as-pattern
17:58:49 <kpreid> xelxebar: it means bind the value to both cs and (_:_)
17:58:53 <ddarius> @google "Gentle introduction" patterns site:haskell.org
17:58:54 <lambdabot> http://haskell.org/tutorial/patterns.html
17:58:54 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
17:59:11 <kpreid> xelxebar: in this case, it has the effect that it will bind cs, but only if the list is nonempty
17:59:29 <xs> Pseudonym: sorry. it sounds like you're saying an axiom is something that can be proved. axioms cannot be proved. i presume you meant law?
17:59:40 <Pseudonym> kpreid: Excellent question.
17:59:49 <Pseudonym> xs: Uhm, yeah.  Just a moment.
17:59:56 <Pseudonym> A "law" is something that the abstraction must obey.
18:00:00 <kpreid> xelxebar: in this case, it has the effect that it will bind cs, but only if the list is nonempty
18:00:07 <Pseudonym> Laws are either axioms or theorems.
18:00:16 <Pseudonym> And, of course, you can pick different equivalent basis axioms.
18:00:33 <Pseudonym> kpreid: Can't find one.
18:01:17 <kpreid> I'm wondering what sort of monad would have one
18:01:24 <dmwit> I saw a monad that defined forever in a way that wasn't forever a = a >> forever a.
18:01:28 <dmwit> I wonder if that is related.
18:01:58 <xs> kpreid: some strict monads perhaps?
18:02:18 <kpreid> forever' a = forever a >> a -- can be useful for e.g. Writer or State
18:02:51 <dmwit> kpreid: The monad I'm talking about built a log of the intermediate results; in the "forever" function it kept only the most recent "cycle" of the log.
18:03:11 <dmwit> kpreid: So, maybe something similar would apply -- you could build up a log, then collapse it when you reached (>>) at any time.
18:03:15 <kpreid> dmwit: yeah, that's sort of like the writer case
18:03:30 * dmwit can't think of a real-live case right away, though
18:03:40 <Pseudonym> OK, it looks like Graphics.HGL.Internals.Draw implements (>>)
18:04:25 <ddarius> @free fmap
18:04:27 <Pseudonym> So there you go.  One example. :_)
18:04:27 <lambdabot> Expected variable or '.'
18:04:33 <kpreid> > let w = w >> modify ("foo" ++) in runState w "x"
18:04:35 <lambdabot>  ((),"foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
18:04:40 <Pseudonym> ?free fmap :: (a -> b) -> (M a -> M b)
18:04:41 <lambdabot> g . h = k . f => $map_M g . fmap h = fmap k . $map_M f
18:04:52 <kpreid> that's the sort of thing I was thinking of
18:05:13 <kpreid> if you do that with forever, it will be _|_
18:05:23 <ddarius> @free return :: a -> M a
18:05:24 <lambdabot> $map_M f . return = return . f
18:06:02 <Pseudonym> It only assumes that M is a functor.
18:06:16 <mudge> what the heck is forall?
18:06:28 <ddarius> mudge: Exactly what it sounds like.
18:06:34 <kpreid> mudge: explicit scoping for type variables
18:06:37 <Pseudonym> mudge: It's the definition of parametric polymorphism.
18:06:43 <Pseudonym> id :: forall a. a -> a
18:06:51 <Pseudonym> id maps a to a, for ALL types "a".
18:07:49 <mudge> so it makes all as  be as?
18:08:02 <ddarius> @free join :: M (M a) -> M a
18:08:02 <lambdabot> $map_M f . join = join . $map_M ($map_M f)
18:08:34 <Pseudonym> mudge: Well, it's a mapping.  It doesn't "do" anything in the sense of modifying it.
18:09:37 <mudge> ok, thanks
18:10:54 <Pseudonym> ?free bind :: M a -> (a -> M b) -> M b
18:10:54 <lambdabot> $map_M g . h = k . f => $map_M g (bind x h) = bind ($map_M f x) k
18:16:13 <phobes> Pseudonym:  Do you have an example of a Monad that satisfies all but the third law?
18:16:41 <ddarius> phobes: By definition, no.
18:16:49 <phobes> heh
18:16:57 <phobes> "pseudo-Monad"
18:16:58 <phobes> :P
18:17:00 <Pseudonym> :-)
18:17:03 <Pseudonym> No.
18:17:09 <phobes> I'm wondering if this works:
18:17:10 <Pseudonym> As I noted, I don't think it's possible.
18:17:14 <phobes> data Foo a = Foo a Bool
18:17:14 <phobes> instance Monad Foo where
18:17:14 <phobes>     return a = Foo a False
18:17:14 <phobes>     (Foo a1 b1) (>>=) k = let Foo a2 b2 = k a1 in Foo a2 (b1 && b2)
18:17:26 <Pseudonym> Let's see.
18:17:40 <phobes> It's a rather contrived example, but the Bool keeps track of whether the Monad is "totally impure"
18:17:53 <phobes> If you introduce any pure computation via return, that flag will be false for the entire bound monad
18:18:22 <mudge> is: type EnergyFunction a  = a -> Int     the same as:   EnergyFunction :: a  = a -> Int
18:18:41 <ddarius> No.
18:18:44 <ddarius> mudge
18:19:00 <phobes> It's easy to prove though that (m >>= return) >>=k  =  (m >== k)  for any k though
18:19:00 <Pseudonym> In that case, does it satisfy return a >>= k = k a?
18:19:16 <mudge> i've never seen a function's type declared with type before
18:19:40 <phobes> hmm, probably not
18:19:40 <ddarius> mudge: type doesn't declare a function.  It's just a synonym.
18:20:23 <ddarius> mudge: type EnergyFunction a = a -> Int means anywhere you see EnergyFunction X in a type you can replace it with X -> Int
18:21:53 <Pseudonym> I suspect it's like the law for MonadPlus:
18:21:59 <Pseudonym> m `mplus` mzero == m
18:22:16 <Pseudonym> I'm 99% certain that's provable by induction for any MonadPlus.
18:22:45 <Pseudonym> And it's probably true for any kind of right-identity law.
18:23:05 <Pseudonym> For monads, that is.
18:23:30 <mudge> oh yea, I see
18:24:07 <phobes> (trying to patch my example - I think I might have broken it during simplification)
18:27:29 * Tac-Tics is confused by monadplus
18:28:50 <Pseudonym> phobes: Let me help you out here.
18:29:10 <Pseudonym> Any monad which only has return and bind, and obeys those two monad laws, automatically obeys the third.
18:29:24 <Pseudonym> You can show that by construction.
18:29:57 <Pseudonym> If you have a monad that doesn't obey the right-identity law, but does obey the other two, it's going to be some OTHER monad operation that breaks it.
18:30:47 <Pseudonym> i.e. something additional, like mzero or fail.
18:30:51 <Pseudonym> or reads
18:30:53 <phobes> hmm
18:30:58 <Pseudonym> They all work, of course.
18:31:01 <phobes> By construction?
18:31:05 <Pseudonym> Yup.
18:31:17 <phobes> This is a shallow fact?
18:31:20 <Pseudonym> http://andrew.bromage.org/blog/archive/2007/09/correct_by_constructi.html
18:31:22 <lambdabot> Title: The BWAIN: Correct by construction, http://tinyurl.com/2blzev
18:33:24 <phobes> You're referring to the 'by induction' argument found in the mentioned paper?
18:33:48 <Pseudonym> Yeah.
18:34:03 <Pseudonym> Well, he doesn't prove it, but it's pretty obvious how you'd do it.
18:34:10 <Pseudonym> return a >>= return = return a
18:34:27 <Pseudonym> (m >>= k) >>= return = m >>= (\x -> k x >>= return)
18:34:37 <Pseudonym> Since k is smaller than m >>= k, the result follows by induction.
18:35:18 <Pseudonym> That assumes a finite expression, I guess.
18:35:36 <Pseudonym> But it's certainly true in Haskell sans fixpoint operator (i.e. the same conditions under which the free theorem is true).
18:38:57 <Pseudonym> So if the law is incorrect, it's going to be because of some:
18:39:02 <Pseudonym> otherop >>= return /= otherop
18:39:29 <phobes> yes
18:39:39 <phobes> sorry, I'm on the phone but I think I have an example
18:39:56 <Pseudonym> Sure, I'm in no hurry. :_0
18:39:59 <Pseudonym> :-)
18:40:03 <ddarius> Pseudonym: That would be the important part.
18:40:16 <jaredj> :)
18:40:18 <phobes> Ya, I reached the same conclusion as you
18:40:23 <phobes> Informally, what about this idea:
18:40:50 <ddarius> It's blatantly obvious.  eta is a unit to mu.  If you only use eta and mu you only end up with eta.
18:41:22 <phobes> huh?
18:41:27 <phobes> Anyway...
18:41:31 <Pseudonym> "It's blatantly obvious" sounds like Proof by Intimidation to me.
18:42:27 <phobes> well, let me just write it down and make sure it's not obviously wrong this time
18:42:27 <jaredj> This *point* is Chewbacca.
18:42:35 <jaredj> Chewbacca is a wookiee.
18:42:51 <wnoise> t should be obvious to even the most dim-witted individual who holds an advanced degree in category theory
18:43:17 <ddarius> They don't give out degrees in category theory as far as I know (which wouldn't be very far)
18:43:21 <Pseudonym> Then the individual who invented monads surely didn't need to make this an axiom, did they?
18:43:41 <ddarius> Pseudonym: What's "this"?
18:44:11 <Pseudonym> http://upload.wikimedia.org/wikipedia/en/9/94/Monad_unit.png
18:44:19 <Pseudonym> "This" would be the right-hand cycle in that diagram.
18:44:28 <wnoise> No, they don't.  It's a slightly altered simpson's quote.
18:44:50 <ddarius> Pseudonym: You don't use only eta and mu is the point.
18:45:04 <jaredj> i eta mu
18:45:18 <Pseudonym> Ah, right.
18:45:19 <wnoise> But it is obvious once you understand certain universality properties, but isn't before that point.
18:45:19 <jaredj> tasty
18:45:30 <Pseudonym> Yeah, sorry, I misunderstood you.
18:45:49 <phobes> ddarius:  I agree it's quite obvious that you don't just use return and bind to construct the example problem monad - is that what you're saying?
18:46:10 <phobes> Talk of eta and mu sends me looking up definitions
18:46:21 <ddarius> eta = return, mu = join
18:46:25 <Pseudonym> I think we should call them return and join here.
18:46:28 <Pseudonym> And fmap, of course.
18:46:48 <Pseudonym> join . fmap return = id
18:46:56 <ddarius> phobes: I was agree with Pseudonym and restating his inductive proof in a different manner.
18:47:35 <ddarius> Oh noes! Someone actually got the gall up to ask a question they shouldn't on Haskell-Cafe!
18:47:59 <phobes> data Foo a = Foo a Bool
18:47:59 <phobes> instance Monad Foo where
18:47:59 <phobes>     return a = Foo a False
18:47:59 <phobes>     (Foo a1 b1) (>>=) k = k a1
18:48:18 <LoganCapaldo> a question they shouldn't?
18:48:32 <Pseudonym> return a >>= k = Foo a False >>= k = k a
18:48:34 <Pseudonym> That's cool.
18:49:28 <dmwit> That fails the (m >>= return = m) law.
18:49:41 <dmwit> ...or was that the point?
18:49:45 * phobes rests
18:50:15 * jaredj looks at the haskell cafe
18:50:17 <Pseudonym> Just checking the associative law.
18:50:20 <ddarius> dmwit: That's the goal
18:50:37 <dmwit> Okay, sorry.  I must have missed a bit of the conversation while I was at dinner.
18:51:39 <dmwit> Pseudonym: I think it satisfies the other two laws.
18:51:45 <dmwit> neat!
18:52:08 <phobes> The point is that bind keeps the flag of the last monad shifted in.   It should be associative, since taking the last element is independent of parens.
18:52:22 <phobes> but it fails >>= return because that clears the flag
18:52:24 <jaredj> dmwit: to what tabu question do you refer?
18:52:37 <dmwit> ddarius, even
18:52:37 <Pseudonym> So, a quick question.
18:52:41 <Pseudonym> How is equality defined here?
18:52:50 <phobes> deriving Eq
18:53:15 <Pseudonym> So let's define a new monad operation:
18:53:18 <ddarius> jaredj: The kind of (->)
18:53:24 <Pseudonym> otherKindOfReturn :: a -> Monad a
18:53:30 <ddarius> In H98 it's * -> * -> *, but
18:53:31 <Pseudonym> otherKindOfReturn a = Foo a True
18:53:33 <ddarius> :k (->)
18:53:35 <lambdabot> ?? -> ? -> *
18:53:39 <jaredj> oh. ???
18:53:42 <phobes> Yes, this is another Monad :)
18:53:52 <Pseudonym> We're saying that otherKindOfReturn a >>= return /= otherKindOfReturn a
18:54:25 <phobes> yes
18:56:19 <ddarius> :t 1
18:56:21 <lambdabot> forall t. (Num t) => t
18:56:22 <ddarius> :k 1
18:56:24 <lambdabot> *
18:59:29 <Pseudonym> Yup, looks like you're right.
18:59:39 <LoganCapaldo> :k Just
18:59:41 <lambdabot> Not in scope: type constructor or class `Just'
19:00:00 <LoganCapaldo> why does 1 have a kind?
19:00:08 <ddarius> Shh!
19:00:18 <jaredj> :k Just 1
19:00:20 <lambdabot> Not in scope: type constructor or class `Just'
19:00:28 <ddarius> :k Maybe 1
19:00:30 <lambdabot> *
19:00:33 <LoganCapaldo> does not compute
19:00:37 <Pseudonym> Ow.
19:00:37 <jaredj> ?
19:01:04 <LoganCapaldo> 1 == ()?
19:01:05 <jaredj> is 1 a type?
19:01:08 <ddarius> Yes.
19:01:14 <ddarius> 1 ~= ()
19:01:29 <dmwit> yikes
19:01:38 <ddarius> :t Unit
19:01:40 <lambdabot> Not in scope: data constructor `Unit'
19:01:49 <ddarius> :t GHC.Exts.Unit
19:01:50 <lament> :t ()
19:01:53 <lambdabot> ()
19:01:53 <lambdabot> Not in scope: data constructor `GHC.Exts.Unit'
19:01:58 <ddarius> @hoogle Unit
19:01:58 <lambdabot> Data.Graph.Inductive.Internal.Heap.unit :: Ord a => a -> b -> Heap a b
19:01:58 <lambdabot> Data.FiniteMap.unitFM :: key -> elt -> FiniteMap key elt
19:01:58 <lambdabot> Data.Set.unitSet :: a -> Set a
19:02:03 <ddarius> @index Unit
19:02:03 <lambdabot> bzzt
19:02:15 <jaredj> is :k 1 == :k Int?
19:02:30 <ddarius> jaredj: :k 1 = * is the kind of any type
19:02:39 <dmwit> :k 2
19:02:41 <lambdabot> Only unit numeric type pattern is valid
19:02:43 <sjanssen> @kind 1
19:02:45 <lambdabot> *
19:02:54 <sjanssen> hmm
19:02:58 <ddarius> So, yes, but :k 1 = :k Bool = :k Maybe [Either Int Double]
19:03:00 <jaredj> so 1 is a "type pattern" not a type strictly
19:03:18 <sjanssen> this must be some strange GHC extension
19:03:20 <ddarius> jaredj: It's a type.  There are values of it.
19:03:31 <jaredj> sjanssen: of the third kind.
19:03:36 <dmwit> There are values of type 1.
19:03:38 <LoganCapaldo> a strange and mysterious ghc extensions
19:03:39 <dmwit> Really?
19:03:51 <jaredj> time for more reading before more talking
19:04:37 <dmwit> > 1 :: 1
19:04:37 <lambdabot>  Parse error
19:04:48 <sjanssen> there are values of any type of kind *
19:04:52 <sjanssen> @type undefined
19:04:54 <lambdabot> forall a. a
19:05:27 <Pseudonym> phobes: OK, I see my faulty reasoning.
19:05:30 <ddarius> @source GHC.Exts
19:05:30 <lambdabot> http://darcs.haskell.org/packages/base/GHC/Exts.hs
19:05:34 <LoganCapaldo> > undefined :: 1
19:05:35 <lambdabot>  Parse error
19:05:39 <Pseudonym> The free theorems for monad operations depend on the monad being a valid Functor.
19:05:46 <Pseudonym> And your monad isn't a valid Functor either.
19:06:04 <ddarius> Uh oh.
19:06:15 <ddarius> @source GHC.Prim
19:06:15 <lambdabot> GHC.Prim not available
19:06:21 <ddarius> Bastardly thing
19:06:38 <Pseudonym> Right.
19:06:45 <phobes> Pseudonym:  Also given any Monad, if you restrict to the fixpoint set of (>>= return), you still have a Monad and one that does satisfy all 3 laws
19:07:15 <sorear> 1 is a Weird Type That You Don't Want To Know About
19:07:39 <sjanssen> sorear: do you know where it comes from?
19:07:45 <LoganCapaldo> well ddarius started it
19:07:52 <LoganCapaldo> it
19:07:53 <sorear> it has to do with a GHC extension so unspeakably horrible most people have forgotten it
19:07:58 <LoganCapaldo> *it's all his fault
19:08:06 <LoganCapaldo> LOL
19:08:06 <sjanssen> sorear: inquiring minds must know!
19:08:18 <LoganCapaldo> the non-euclidean cyclopean geometry extension?
19:08:29 <dmwit> The Cthulhu extension.
19:08:53 <phobes> Pseudonym:  I had been lead to believe that every Monad is a Functor - not so?
19:09:03 <dmwit> You enable it via -funsafe-destroy-souls. ;-)
19:09:08 <sorear> phobes: Every monad is a functor.
19:09:17 <Pseudonym> But not every Monad is a Functor.
19:09:25 <Pseudonym> Because not everyone bothers to implement the Functor instance.
19:09:48 <sorear> sjanssen: "derivable type classes", but don't tell them I told you
19:10:13 <phobes> oh:  <Pseudonym> The free theorems for monad operations depend on the monad being a valid Functor.
19:10:13 <phobes> <Pseudonym> And your monad isn't a valid Functor either.
19:10:17 <phobes> Were you not talking to me?
19:10:24 <sjanssen> sorear: oh, is that Generic Haskell?
19:10:30 <Pseudonym> phobes: Sure I was.
19:10:39 <Pseudonym> My point is that your monad breaks the Functor laws.
19:10:43 <Pseudonym> In particular, fmap id /= id
19:10:48 <phobes> oh ok
19:11:04 <phobes> makes perfect sense...  I'm easily confused :)
19:11:36 <Pseudonym> Anyway, phobes, how should I credit you for this cool monad?
19:11:47 <ddarius> fmap f (Foo a b) = Foo (f a) b   fmap id = id
19:12:15 <Pseudonym> ddarius: fmap f m = m >>= return . f
19:12:32 <ddarius> Wrong instance of Functor
19:12:34 <phobes> Pseudonym:  "Some dude on IRC"
19:12:42 <Pseudonym> Some dude on IRC it is.
19:13:01 <Pseudonym> (I officially have more information now that I know you're a dude.)
19:13:12 <ddarius> Pseudonym: Wait, there you go.
19:13:25 <phobes> All you really know is that I want it credited to a dude :)
19:13:59 <phobes> (But seriously, no worries about crediting me)
19:14:07 <ddarius> Anything that satisfies fmap id = id clearly satisfies m >>= return = m
19:14:20 <lament> 'dude' is gender-neutral :)
19:14:24 <LoganCapaldo> night
19:14:31 <jaredj> correct
19:14:36 <jaredj> (in my locale)
19:14:41 <Pseudonym> ddarius: How do you figure that?
19:15:01 <phobes> Blatantly obvious.
19:15:04 <jaredj> snerk! - ... um.
19:15:07 <ddarius> phobes: Exactly!
19:15:13 <phobes> :D
19:15:31 <ddarius> fmap id m = m >>= return . id <=> m = m >>= return
19:15:51 <Pseudonym> So it ALSO has to satisfy that fmap f m = m >>= return . f
19:16:30 <dmwit> Urgh.
19:16:44 <Pseudonym> Which given phobes' Monad instance and ddarius' Functor instance isn't true.
19:16:45 <dmwit> You're starting from the assumption that it is a valid Monad, and "deriving" the fact that it follows the monad laws.
19:16:47 <dmwit> =(
19:17:15 <dmwit> If it is not a valid monad, there is no reason to suspect that it is also a valid functor.
19:17:22 <ddarius> Pseudonym: So the question is is fmap f m = m >>= return . f have to hold?
19:17:28 <Pseudonym> Right.
19:17:32 <Pseudonym> Is that documented anywhere?
19:17:36 <ddarius> If you say yes, then you have your answer.
19:17:41 <ddarius> (re your article)
19:17:44 <Pseudonym> Right.
19:18:26 <ddarius> dmwit: The goal is to satisfy everything but the second unit law.
19:18:36 <Pseudonym> Or, put another way, m >>= return has to hold otherwise fmap isn't a Functor.
19:18:43 <omniscientIdiot> http://www.haskell.org/onlinereport/basic.html#sect6.3.6 "Instances of both Monad and Functor should additionally satisfy the law: fmap f xs = xs >>= return . f"
19:18:44 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
19:19:12 <phobes> So the setup now is that we have a pseudo-Monad like before AND a functor, and we want to prove that it satisfies the third axiom?
19:19:23 <dmwit> As a side note, the fact that ddarius and Pseudonym apparently hash to the same thing with whatever algorithm Xchat uses to decide colorings makes this conversation a bit difficult to follow.
19:19:46 <ddarius> I hash to blue, Pseudonym hashes to red in my xchat.
19:19:56 * Pseudonym has never been accused of being a hash collision before
19:19:59 <phobes> Anyone who says my name hashes to red
19:20:04 <phobes> I hash to gray
19:20:06 <dmwit> I'm pretty sure that xchat uses a default color for your own nick.
19:20:16 <phobes> Everyone else blue with black text
19:20:16 <ddarius> phobes: do /me
19:20:20 <Pseudonym> I use a vt100 emulation, which only does black and white.
19:20:27 * ddarius_ foo
19:20:28 <Pseudonym> So I don't have this problem.
19:20:31 <phobes> ddarius:  do /youself
19:20:36 <DeGuerre> bar
19:20:40 * phobes testing
19:20:40 <ddarius> Perhaps /me always displays blue.
19:20:51 <omniscientIdiot> phobes are purple
19:20:51 * dmwit hum
19:21:00 * doodad ho
19:21:15 <phobes> anyway, good night all
19:21:28 * omniscientIdiot checks the text events in xchat...
19:21:28 <dmwit> Ah, /me does seem to reveal your hash color.
19:21:28 * Tac-Tics hmm
19:21:31 <Pseudonym> The question that I'm _actually_ trying to answer is this?:
19:21:36 <Tac-Tics> yeah, mine is blue too
19:21:58 <Pseudonym> If you derive a monad using only left-expansion, will you automatically obey the second monad law?
19:22:06 <Pseudonym> Because you can satisfy the other two by construction.
19:22:11 <omniscientIdiot> "Your message" starts with %C18, which is blue.
19:22:18 <Pseudonym> Do that, and you don't have to prove a damn thing.
19:22:33 <Pseudonym> Does the other law follow?
19:22:33 <omniscientIdiot> s/message/action/
19:22:41 <ddarius> Pseudonym: Does it automatically obey the functor laws?
19:22:46 * omniscientIdiot wonders what color others see him as.
19:22:51 <Pseudonym> Perhaps it's the construction process that guarantees the other law.
19:23:38 <allbery_b> * omniscientIdiot wonders what color others see him as.
19:23:54 <Pseudonym> You all look the same to me.
19:23:58 <dmwit> Heh, can't paste formatting.
19:24:03 <allbery_b> purple, since xchat2 hashes the nickname and then determines a color from that
19:24:26 <lament> First monad law: A monad may not injure a human being or, through inaction, allow a human being to come to harm.
19:25:09 <allbery_b> oh, I see hat's already been discussed
19:25:24 <allbery_b> and yes, it makes me green, at least here.  (bah.  I hate green :)
19:26:34 <ddarius> allbery_b: You don't have to see it.
19:26:45 <Pseudonym> First law of Monad Club... oh, forget it.
19:27:30 <dmwit> Obey monads, it's the law!
19:27:43 <Pseudonym> In this house, we obey the laws of monads!
19:29:30 <ddarius> No we don't.
19:29:43 <Pseudonym> Well, phobes doesn't.
19:30:23 <omniscientIdiot> but... it's not a monad if it doesn't obey the laws...
19:31:09 <omniscientIdiot> (+) and 0, such that (x + 0 /= x), do not a define a number
19:31:15 <ddarius> omniscientIdiot: Luckily, I'm not a monad.
19:31:46 <omniscientIdiot> (for some specific meaning of "number".  I'm very weak in abstract algebra)
19:31:59 <sorear> omniscientIdiot: light grey on black
19:32:19 <dmwit> People who eschew X don't count. ;-)
19:32:40 <jaredj> omniscientIdiot: black on light yellow
19:32:57 <Pseudonym> OK, I think the only question we haven't yet settled is this:
19:32:59 <Pseudonym> The question is still open as to whether or not the right-identity law is correct by virtue of using the Hughes/Hinze derivation process.
19:33:06 <omniscientIdiot> dmwit: woah, massive Zelda 1 flashback.  There was one in game text similar to what you said.
19:33:30 <Pseudonym> It _may_ be that the process guarantees that the law is correct.
19:34:13 <Pseudonym> Ah, there's a way to check that.
19:34:27 <Pseudonym> Define the Phobes Monad (I hereby name it!) as an algebra.
19:34:42 <oklopl> o
19:34:59 <dmwit> Hiya oklopl!
19:35:06 <oklopl> hi dmwit
19:35:11 <dolio> Buy somethin' will ya'?
19:35:16 <dmwit> omniscientIdiot: zelda eschew gives me no interesting results on Google.
19:35:47 <dmwit> dolio: Wasn't that from Icarus?
19:38:25 <dolio> It was the shopkeep in zelda 1.
19:38:41 <Pseudonym> And the answer is "no".
19:38:55 * omniscientIdiot apologizes for off-topic
19:40:11 <dolio> Well, HAppS seems to be getting a chilly reception on reddit.
19:41:21 <Pseudonym> Thanks for the help, everyone.
19:53:05 <jaredj> what's the happs my bro
19:53:51 <dmwit> ?where happs
19:53:51 <lambdabot> http://happs.org
19:54:11 <jaredj> happenin'.
19:54:11 <dolio> I think that was a pun.
19:54:18 <omniscientIdiot> yo dawg, ya just gots to be clickin' all up on dat link.
19:54:24 <jaredj> 1/2 pun. :)
19:54:32 <Pseudonym> We need a jive plugin for lambdabot.
19:55:00 <dmwit> ?. elite elite yo dawg, ya just gots to be clickin' all up on dat link
19:55:00 <lambdabot> Y0 DaWG, Ya Ju57 9o+s +O 8E (|iCxIN' a1l Up On dA7 LINk
19:55:03 <Pseudonym> http://james.bond.edu.au/courses/inft13310/053/Labs/Zips/jivesrc.tar.gz
19:55:05 <lambdabot> http://tinyurl.com/2bym3q
19:55:43 <omniscientIdiot> L0|_, J41\/3
19:57:32 <lament> "?. elite elite" ?
19:57:37 <omniscientIdiot> \BAWT IN TEH HIZZOUSE!!
19:57:49 <omniscientIdiot> @help compose
19:57:49 <lambdabot> . <cmd1> <cmd2> [args].
19:57:49 <lambdabot> . [or compose] is the composition of two plugins
19:57:49 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
19:59:38 <dolio> Why do people always run things through @elite twice?
20:00:19 <omniscientIdiot> it's not elite enough going through once.
20:00:56 <omniscientIdiot> @. vixen elite Right, LB?
20:00:57 <lambdabot> i'll hafta plead the fifth on that one.
20:01:08 <lament> so it's "?elite", "?. elite elite", "?. elite . elite elite" ?
20:01:20 <omniscientIdiot> lament: yep
20:01:25 <dmwit> Sounds reasonable.
20:01:40 <lament> ?. elite . elite elite easy enough to verify
20:01:40 <lambdabot> 345y 3n0u9|-| +0 \/3riPHY
20:01:58 <dmwit> ?. . elite elite elite hum, what about this?
20:01:58 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "E|I7E"
20:01:59 <jaredj> @. . elite vixen faq Can haskell clean my bathroom?
20:02:00 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "\\/IXeN"
20:02:04 <jaredj> ?. . elite vixen faq Can haskell clean my bathroom?
20:02:04 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "vIXeN"
20:02:10 <jaredj> oop ack
20:02:35 <jaredj> heh oops
20:02:44 <omniscientIdiot> that would send "Yes! Haskell can.." to vixen, then her response through elite
20:02:44 <dmwit> ?. elite . vixen faq Can haskell clean my bathroom?
20:02:45 <lambdabot> CHUR(H Is my faV0Uri+e (OmPuteR z(IEntIz7.
20:03:00 <jaredj> what??
20:03:14 <jaredj> vixen talks about computer scientists?
20:12:55 <seafoodX> @hoogle getArgs
20:12:55 <lambdabot> System.getArgs :: IO [String]
20:15:26 <Randroid> What in the name of Britney Spears is @hoogle?
20:15:34 <omniscientIdiot> haskell api search
20:15:39 <Randroid> ah
20:15:41 <Randroid> I dig
20:15:42 <omniscientIdiot> @where hoogle
20:15:42 <lambdabot> http://haskell.org/hoogle
20:15:53 <Randroid> @hoogle System.Process.runInteractiveCommand
20:15:54 <lambdabot> No matches, try a more general search
20:15:59 <Randroid> hm
20:16:13 <omniscientIdiot> @hoogle interactive
20:16:13 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
20:16:13 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
20:16:52 <seafoodX> Question: Does everything pasted to the Haskell paste bin come up here on this channel?
20:17:09 <omniscientIdiot> if the announce box is checked
20:17:28 <omniscientIdiot> (and the bot's not feeling sick)
20:18:04 <seafoodX> Ah, funky
20:18:25 <dmwit> Sometimes, things not even pasted there show up here!
20:18:29 * dmwit ducks
20:19:40 <omniscientIdiot> dmwit: I noticed in the logs that a couple hours ago you and a couple others were talking about records.  Have you read http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details ?
20:19:42 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
20:21:21 <dmwit> Nope, but that looks nice.
20:24:23 <dmwit> Unlike the other proposals I have seen, that one is usable *right now*, which is a real advantage.
20:26:28 * omniscientIdiot would like a Data.FRef and some kind of TH thingy.
20:26:35 <omniscientIdiot> Maybe I should write that TH thingy.
20:26:45 <omniscientIdiot> Never used TH before.
20:28:34 <omniscientIdiot> the composition is real clever.
20:31:43 * allbery_b bookmarked that so he can look it over
20:31:53 <allbery_b> although it's not so useful in my current project
20:36:37 <jaredj> us postage: 39¢ or 40¢?
20:38:07 <jaredj> bagh! 41¢!
20:38:22 <jaredj> termagants. all my stamps are useless.
20:39:43 <omniscientIdiot> buy some 1 cent stamps
20:40:05 <jaredj> feh.
20:40:09 * omniscientIdiot still has 37s
20:40:13 * jaredj too
20:41:12 * ddarius doesn't even think about it when he uses his stamps.  They are probably too little now.
20:41:24 <jaredj> how often do you use stamps
20:41:43 <ddarius> Almost never.  I don't even no where they are.
20:41:48 <omniscientIdiot> As often as I mail things :)
20:41:51 <jaredj> exactly.
20:42:02 <jaredj> i can barely find my 39¢ stamps much less 2¢
20:42:38 <jaredj> i heard they had a "forever stamp". one stamp for one letter. wonderful. haven't got any yet.
20:42:56 <jaredj> while i'm OT, i recommend _going postal_ by terry pratchett
20:43:34 <sieni> jaredj: yeah, they have had such stamps for something like 10 years here in finland. very practical.
20:43:43 <ddarius> I'll charge you $10 for a stamp you can use forever.
20:44:24 <omniscientIdiot> ddarius: it'll be a good deal in twenty years
20:44:33 * allbery_b has forever stamps
20:46:53 <jaredj> boo hiss
20:47:15 <jaredj> jaredj@harpster:~/src/darcs/cac-unstable$ darcs pull -p '^smartcard:' ../cac-stable/
20:47:18 <jaredj> Pulling from "../cac-stable"...
20:47:19 <jaredj> darcs: bug in get_extra commuting patch: [...]
20:48:40 <ddarius> Bah.  Don't talk about cac cards now.
20:48:48 <jaredj> ?
20:49:28 <jaredj> did one of them run over your dog?
20:50:53 <ddarius> Gah.  You're just going from bad to worse.
20:51:20 <omniscientIdiot> That's a yes?
20:51:26 <jaredj> lol
20:57:59 <mnu> exit
21:06:00 <seafoodX> omniscientIdiot: You want something to automatically generate the accessors for the functional references?
21:06:18 <omniscientIdiot> I was thinking something like that, yes
21:06:27 <seafoodX> omniscientIdiot: By the way, I just read that article. It was cool! Especially the instance for Ref (->) which keeps the old composition operator around!
21:07:29 <omniscientIdiot> salary john = (ref salary_ (\s emp -> ...)) john = (const salary_ (\s emp -> ...)) john = salary_ john -- really quite genious
21:07:59 <omniscientIdiot> because it's so remarkably simple
21:08:44 <omniscientIdiot> I wonder if this Twan person is ever on IRC?
21:10:20 <allbery_b> @seen twanvl
21:10:20 <lambdabot> I saw twanvl leaving #haskell 5h 35m 14s ago, and .
21:11:15 <Cale> genius*
21:11:31 * omniscientIdiot slaps omniscientIdiot
21:12:18 <allbery_b> well, I don't guarantee that's him, but it does seem likely
21:14:08 <Cale> Interesting...
21:14:09 <Cale>     1. With reference to classical pagan belief: The tutelary god or attendant spirit allotted to every person at his birth, to govern his fortunes and determine his character, and finally to conduct him out of the world; also, the tutelary and controlling spirit similarly connected with a place, an institution, etc.
21:15:05 <omniscientIdiot> eh?  Is that a definition?
21:15:08 <Cale> yeah
21:15:13 <omniscientIdiot> of?
21:15:16 <Cale> Genius
21:15:24 <omniscientIdiot> oh.
21:15:29 <Cale> It's the earliest one
21:15:43 <arcatan> lol, invizibl type deklarashuns
21:16:18 <Cale> (at least, that the OED lists)
21:17:31 <omniscientIdiot> data Foo = Foo { x_ :: Bar, y_ :: Baz } -- what would the TH look like?
21:17:52 <omniscientIdiot> $(addRefs 'Foo)
21:19:37 <omniscientIdiot> expands to: x = ref x_ (\x foo -> foo { x_ = x }); y = ref y_ (\y foo -> foo { y_ = y })
21:20:37 <omniscientIdiot> could I introspect on Foo's definition?
21:22:13 * omniscientIdiot goes to read up on TH
21:22:41 <lament> genius, n: see lament
21:22:44 <Cale> http://www.haskell.org/hawiki/TemplateHaskellTutorial -- damn, another thing blown away...
21:23:14 <omniscientIdiot> HaWiki was deleted?!
21:23:31 <Cale> Well, taken off line
21:24:46 <ddarius> > scanl (+) 0 $ map recip $ zipWith (*) (cycle [1,-1]) [1,3..]
21:24:48 <lambdabot>  [0.0,1.0,0.6666666666666667,0.8666666666666667,0.7238095238095239,0.83492063...
21:25:06 <ddarius> > drop 10 $ scanl (+) 0 $ map recip $ zipWith (*) (cycle [1,-1]) [1,3..]
21:25:08 <lambdabot>  [0.7604599047323508,0.8080789523513985,0.7646006914818333,0.8046006914818333...
21:25:23 <Cale> http://www.haskell.org/bz/thdoc.htm -- near the end of this is an example for how to derive Show, which shows how to do inspection of the structure of a datatype.
21:25:24 <lambdabot> Title: Template Haskell Documentation-
21:25:36 <ddarius> > arctan 1
21:25:37 <lambdabot>   Not in scope: `arctan'
21:25:41 <ddarius> > atan 1
21:25:43 <lambdabot>  0.7853981633974483
21:25:51 <ddarius> > drop 100 $ scanl (+) 0 $ map recip $ zipWith (*) (cycle [1,-1]) [1,3..]
21:25:53 <lambdabot>  [0.7828982258896384,0.7878733502677479,0.7829472418933636,0.7878252906738514...
21:28:53 <omniscientIdiot> thanks, Cale
21:56:30 <levi13> hi, what signs to you look for, when coding, to indicate a monad might be appropriate?
21:57:08 <omniscientIdiot> stuff's getting complicated?
21:59:20 <levi13> ok, but what might suggest a monad is the right abstraction to help with that complexity?
21:59:51 <sarehu> when you're threading a state variable through a series of functions
22:00:35 <levi13> so that would suggest the state monad or reader monad in most cases right?
22:00:41 <sarehu> yeah
22:01:16 <sarehu> I guess when you recognize that something in the Control.Monad. hierarchy might be useful
22:01:31 <levi13> k, how about for your own types?
22:02:02 <levi13> so, what suggests it might be a good idea to make your own type an instance of Monad?
22:02:10 <sarehu> when it is one...
22:02:46 <allbery_b> if you reach the point where one of your own types needs to be a monad, you'll probablly know it
22:02:55 <allbery_b> generally you don't need to roll your own monads
22:03:30 <omniscientIdiot> I don't have the intuition yet to see when a type gives rise to monad, but having returnlike, fmaplike, and joinlike functions would indicate it.
22:03:57 <sarehu> if you find yourself wanting to use functions of the form (a -> f b) and chaining them together, that's a hint.
22:04:45 <omniscientIdiot> the transformers in the mtl are some of the most generally useful
22:04:50 <levi13> cool. I was thinking of that. Keeping an eye on type signatures
22:05:56 <levi13> I keeping thinking I have a monad somewhere in what I'm working on at the moment,
22:06:05 <sarehu> you might just not notice, and it won't be a big deal.
22:06:06 <levi13> but there's also IO in there
22:06:20 <levi13> so a few things like   f a -> b -> IO f a
22:06:30 <sarehu> IO (f a)
22:06:51 <levi13> yep, thanks sarehu ;) (I meant to say that)
22:07:22 <sarehu> well if that f were Maybe, you'd have MaybeT.  If it were [], you'd have ListT...
22:07:47 <sarehu> in the return type.
22:08:10 <allbery_b> actually you wouldn't have that type; IO has to be at the "bottom"
22:08:32 <allbery_b> MaybeT (IO a) can happen, but there is no (and can be no) IOT (Maybe a)
22:08:40 <sarehu> um, yes
22:08:51 <sarehu> MaybeT IO a is implemented as IO (Maybe a)
22:10:13 <omniscientIdiot> @unmtl WriterT w m a
22:10:13 <lambdabot> m (a, w)
22:10:15 <levi13> I'll have to look at monad transformers :) Haven't looked that closely at them yet
22:10:36 <omniscientIdiot> levi13: they are the *real* reason monads are powerful :)
22:11:31 <levi13> darn haskell. Always something more powerful to learn ;)
22:11:39 <lament> monads are powerful, but they rule in secrecy, hiding behind the "do" notation
22:13:17 <sarehu> mmmmmmkay.
22:13:49 <levi13> my main concern in what I'm working on at the moment, is the presence of IO in a lot of return values
22:13:54 <levi13> I'm wondering whether I could be doing more to avoid it
22:14:09 <sarehu> well, are you using IO for the purpose of I/O?
22:14:44 <levi13> I'm using TChan's, does that count?
22:15:05 <sarehu> then you can't escape it, can you
22:15:58 <levi13> k, cool
22:40:13 <gandhi_> hi
22:40:37 <sjanssen> gandhi_: greetings
22:40:42 <gandhi_> Im not a haskell programmer, but a good friend is,
22:41:35 <gandhi_> do u know a ny real world appliction in  haskell? this is not flame, I mean... something that is not a fibonacci calculator or image algorithm or something like that
22:41:36 <gandhi_> ?
22:41:49 <sjanssen> gandhi_: there are several
22:42:08 <sjanssen> darcs is a revision control system (like CVS or SVN, but way better)
22:42:13 <jeffz> gandhi_: picnicmob.org is one.
22:42:16 <omniscientIdiot> pugs, an implementation of perl6
22:42:41 <sieni> ghc, a haskell compiler
22:42:50 <gandhi_> picnicmob seems interesting...
22:42:52 <sjanssen> gandhi_: there's xmonad, an X11 window manager
22:42:57 <gandhi_> the engine is in haskell?
22:43:14 <omniscientIdiot> @where xmonad
22:43:14 <lambdabot> http://xmonad.org/
22:43:27 <gandhi_> thats the point... Im talking about crm software, project management, something more "high level."
22:43:35 <gandhi_> not compilers,
22:43:38 <Pseudonym> darcs is a source code versioning system.
22:43:43 <jeffz> organising picnics is project management, sort of :p
22:43:44 <gandhi_> too technical softwares
22:43:58 <gandhi_> Ive heard darcs
22:44:01 <omniscientIdiot> @wiki Applications and libraries
22:44:01 <lambdabot> http://www.haskell.org/haskellwiki/Applications_and_libraries
22:44:28 <omniscientIdiot> Yi, a text editor
22:44:53 <gandhi_> heh... searching in freshmeat gives more projects than smalltalk... embarassing for smalltalk... heheh
22:45:47 <omniscientIdiot> pancito and pandoc are interesting
22:45:56 <omniscientIdiot> there's Frag, the first person shooter
22:45:59 <gandhi_> my friend did a personal timesheet in haskell
22:47:00 <gandhi_> Im think about using more languages, but Im more inclined to use mixed languages like ocaml , erlang... etc
22:47:11 <Pseudonym> I bet there's more legacy code written in Smalltalk than Haskell.
22:47:21 <Pseudonym> Smalltalk code tends not to be bazaar open source projects.
22:47:29 <gandhi_> thats true
22:47:50 <gandhi_> I did some smalltalk code to a company in brazil that uses smalltalk still
22:48:00 <sorear> otoh, Haskell folks tend to like infrastructure hacking
22:48:23 <levi13> http://lambda-the-ultimate.org/node/2315
22:48:24 <lambdabot> Title: Haskell web store | Lambda the Ultimate
22:48:35 <gandhi_> hum... I think haskell guys are like my friend, purists
22:48:48 <gandhi_> with a math background
22:48:59 <sorear> math is fun
22:48:59 <gandhi_> he has math degree.
22:49:01 <omniscientIdiot> @vixen Aren't you written in Haskell, lambdabot?
22:49:01 <lambdabot> Ooh, functional programmers are so hot!
22:49:32 <gandhi_> I think brainfuck is fun... :-)
22:49:47 <Pseudonym> Haskellers aren't necessarily purists, though.  We tend to believe that purity is practical.
22:49:59 <gandhi_> good point
22:50:10 <gandhi_> I dont believe it... but good point. hehe
22:50:12 <Pseudonym> Here's the circle labelled "good theory".
22:50:17 <Pseudonym> Here's the circle labelled "good practice".
22:50:20 <Pseudonym> They overlap.
22:50:21 <omniscientIdiot> @bf ++[-]
22:50:21 <lambdabot>  fd:27: hClose: resource vanished (Broken pipe)
22:51:12 <gandhi_> but... that speech seems very similar to the beginning OO, they tried to solve everything in a purist way...
22:51:29 <gandhi_> and what we discovered at the end is that u cant do it
22:51:42 <gandhi_> u brake rules
22:51:47 <Pseudonym> I don't agree with that.  Alan Kay invented OO not for reasons of theoretical purity.
22:51:53 <sorear> The difference is that in Haskell we don't break rules.
22:52:07 <Pseudonym> He was thinking in terms of decomposition, maintainability and robustness.
22:52:16 <gandhi_> because u dont developed enough, IMHO
22:52:19 <sorear> We've been monkishly adhering to pure FP for the last 20 years.
22:52:24 <omniscientIdiot> *cough* unsafePerformIO (newIORef x) {- NOINLINE -} *cough*
22:52:26 <Pseudonym> And compared to what came before, OO did pretty well with that.
22:52:55 <gandhi_> YEs.,,, we cant compare with what we had before
22:53:03 <gandhi_> Is a lot of more maturity
22:53:28 <Pseudonym> But I don't think OO was designed with theoretical purity in mind.
22:53:34 <Pseudonym> The theory of OO was somewhat retro-fitted.
22:53:55 <gandhi_> anything that tries to creates rules is a purist wannabe
22:54:27 <Pseudonym> Well I don't think it's wrong to want to reason formally even about "not nice" systems.
22:54:52 <Pseudonym> Perhaps the reason why purists like Haskell is that it's easier to be a purist. :-)
22:55:01 <gandhi_> hehe
22:55:06 <Pseudonym> It's hard to be a purist about COBOL.
22:56:18 <gandhi_> thats why Im more inclined to a language that can mix some aspects, can be formal and not
22:56:20 <Tac-Tics> Purity gives you the ability to never do a shitty job at the cost of robbing you the ability to always get the job done ^^
22:57:36 <gandhi_> the fact is that I get pissed when programming when I get back to common computing problems, that exists for decades
22:57:54 <Tac-Tics> like what?
22:58:04 <gandhi_> transparence, persistence, historical data, etc
22:59:35 <gandhi_> right now Im programming in a project, in java, and we are using a sort of reactive programming,
22:59:46 <gandhi_> trying to use generics
23:00:00 <gandhi_> and some king of contracts, wihtou using aop
23:00:11 <gandhi_> and java is not for that!
23:00:55 <linuxacolyspe> gandhi....I get the feeling I'm gonna hate Java, right?
23:01:22 <Tac-Tics> reactive programming sounds very Haskellesque, reading the wiki article of it
23:01:24 <gandhi_> its good for OO learning.. and thats it.
23:01:31 <gandhi_> I consider productive
23:01:37 <linuxacolyspe> Thats what I thought
23:01:37 <gandhi_> with unit testing
23:02:03 <gandhi_> no message passing...
23:02:12 <linuxacolyspe> geez
23:02:49 <gandhi_> what they are doing know is making it more accessible from reflection
23:02:55 <gandhi_> using proxies,
23:03:16 <gandhi_> adding bytecode generators and modifiers to transform into a metalanguage
23:03:26 <linuxacolyspe> how the hell does that make java creative and expandible?
23:03:31 <gandhi_> using javassist, bcel, etc
23:03:51 <gandhi_> its not
23:03:58 <linuxacolyspe> I gather
23:04:03 <gandhi_> what make is strong is a well defined api
23:04:15 <gandhi_> thats why python sucks
23:04:21 <levi13> gandhi_: have you looked at scala?
23:04:33 <linuxacolyspe> because of the api...hmmmm
23:04:36 <gandhi_> I ve seen the page... but never used.
23:05:00 <levi13> k, I like it because you can access all the practical libraries java has,
23:05:21 <levi13> but get goodies such as type inferance, HOF etc., for your own code
23:05:38 <Tac-Tics> wait, what about python sucking?
23:05:55 <gandhi_> I like python, I dont like its organization
23:06:13 <timbod> I got enthusiastic about hpc yesterday, and am making code work with ghc-6.8. I need Data.Binary, but ByteString API changes in 6.8 prevent it from building. Anyone fixed this already?
23:06:39 <gandhi_> how are haskell apis organized?
23:06:58 <sorear> Well, imo
23:07:03 <Tac-Tics> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
23:07:22 <sorear> And getting better constantly
23:07:37 <Tac-Tics> aside from modules with just 1~3 functions defined X-D
23:07:43 <Tac-Tics> and the long long names
23:07:47 <Tac-Tics> Control.Monad.Continuation???
23:08:17 <Tac-Tics> that's almost 30 characters to type to get access to continuations~
23:08:27 <Tac-Tics> plus the "import" part
23:08:34 <sjanssen> Tac-Tics: Control.Monad.Cont
23:08:38 <Tac-Tics> err
23:08:39 <Tac-Tics> sorry
23:08:47 <Tac-Tics> I mixed that up with Concurrent I think
23:08:48 <gandhi_> well.. at least u have continuations
23:08:50 <Tac-Tics> yeah
23:08:59 <gandhi_> in java dont...
23:09:07 <gandhi_> well theres a package called rife
23:09:11 <gandhi_> i never tried
23:09:21 <sjanssen> I do think the 'Data' and 'Control' hierarchies are minor mistakes
23:09:28 <Tac-Tics> Control.Concurrent.STM is still pretty long
23:09:42 <gandhi_> heh... and a good IDE, ?
23:09:44 <Tac-Tics> and the name conflicts are annoying between Data.Map, etc
23:10:35 <gandhi_> ah... there is eclipse support for haskell... good
23:11:28 <Cale> gandhi_: most people just use vim though
23:11:33 <Cale> or emacs
23:11:58 <gandhi_> well... at least they have syntax coloring...
23:12:00 <gandhi_> hehe
23:12:27 <linuxacolyspe> <- could never get emacs
23:12:45 <linuxacolyspe> too many moving parts. :-)
23:13:29 <Cale> gandhi_: They're actually fairly well-featured editors, you know :)
23:13:29 <gandhi_> the day I use emacs again will be the day I use again gopher, archie, pico and pine
23:13:38 <gandhi_> :_)
23:13:58 <Cale> I'm pretty sure eclipse takes longer to load even than emacs ;)
23:14:10 <linuxacolyspe> I know....if I had the time, though, I bet it would be a good editor to learn. :-)
23:14:29 <gandhi_> hum... my desk calculator loads in one nanosecond in my hand... a lot faster than my desktop computer. :-)
23:15:11 <linuxacolyspe> <- computer loads in about 20 seconds. :-?
23:15:13 <Cale> Emacs is decent if you're going to edit the same file for a long time. I find vim better for small edits, but I tend to end up using it for larger things too.
23:16:00 <gandhi_> vim dont have subversion/cvs shortcuts. :-)
23:16:01 <Cale> vim has the nice property that it loads quickly
23:16:20 <gandhi_> maybe some crazy script... haha
23:16:30 <linuxacolyspe> LOL
23:16:42 <gandhi_> http://www.vim.org/scripts/script.php?script_id=922
23:16:43 <lambdabot> Title: svncommand.vim - Subversion (svn) integration plugin : vim online
23:16:43 <Cale> gandhi_: I just use the shell for that
23:16:52 <gandhi_> I saw it...huahu
23:17:12 <gandhi_> maybe I can annotated the diff by hand on paper
23:17:20 <gandhi_> it works too
23:17:26 <gandhi_> huahu
23:17:32 <Cale> hm?
23:17:46 <linuxacolyspe> they used to say real programmers code in pen. :-)
23:17:56 <Cale> I program in pen all the time
23:18:09 <linuxacolyspe> yup
23:18:11 <linuxacolyspe>  :-)
23:18:18 <gandhi_> Im being ironic too and trying to say that dont be ashamed to use an easier way
23:18:23 <Tac-Tics> I kinda wish I knew more about emacs
23:18:32 <Tac-Tics> I've used vim since I started using linux
23:18:41 <gandhi_> eclispe has more shortcuts than emacs.
23:19:04 <gandhi_> and I know emacs is FULL of shortcuts
23:19:13 <Cale> gandhi_: I think if your version control system is hard enough to use that you need to build a GUI around it to make it tolerable, you should try a different version control system ;)
23:19:21 <Cale> darcs is pretty nice
23:19:37 <gandhi_> ah...
23:19:39 <gandhi_> cale...
23:19:45 <gandhi_> you said something important
23:19:49 <linuxacolyspe> Even the wisest of men adore a bit of tom-foolery..siad by...some wise man, I think! LOL ;-)
23:20:04 <gandhi_> Im working on a version system idea
23:20:38 <gandhi_> but the point is (IT DONT WORK WITHOUT A GUI!)
23:20:52 <Cale> why not?
23:21:03 <gandhi_> because:
23:21:21 <Tac-Tics> I use TortoiseSVN at work for Windows GUI SVN
23:21:23 <Tac-Tics> it sucks so badly
23:21:28 <gandhi_> 1 - 99% of people use GUIs today, why not use its power?
23:21:37 <Tac-Tics> it's slow and doesn't keep its icons up to date
23:21:38 <gandhi_> the idea is not tortoise...
23:21:53 <Tac-Tics> GUIs aren't as awesome as commandline
23:22:02 <Tac-Tics> they may be more intuitive, be more usable on a large scale
23:22:09 <linuxacolyspe> Thats why Intel keeps making more heat producing processors.
23:22:11 <Tac-Tics> but do you really want to take awesome out of computing?
23:22:20 <Cale> gandhi_: Sure, I'm all for using GUI's when appropriate. But if something like a version control system isn't easy to use from the commandline, you probably have some design issues already.
23:22:50 <felzix> automating version control would be easier with an intuitive command-line interface, yes?
23:23:00 <Cale> I would never think of using the commandline for an application like inkscape, for example ;)
23:23:09 <Tac-Tics> Cale: Blasphemer!
23:23:10 <Tac-Tics> hehe
23:23:18 <gandhi_> the idea is totally different... first... a synchrone version system.
23:23:32 <Tac-Tics> I read on some Haskell blog a while ago an interesting article
23:23:58 <Tac-Tics> the author's idea was that for software to be in a class he considers to be "excellent" pieces of software, it needs among other things, a commandline
23:24:10 <glguy> a VCS just adds an extra dimension to your filesystem, and you'd no more want to manage your files from GUI than versions of them
23:24:13 <Tac-Tics> what if you had inskape or photoshop with a commandline in addition to the mouse?
23:24:26 <glguy> what, what autocad?
23:24:30 <Cale> Versioning really seems like something that should be built in at the filesystem level, actually.
23:24:31 <gandhi_> aff... you are not getting the point... its not the command line... its the power int it.
23:24:47 <gandhi_> if you could redirect thing graphically, you would use it
23:25:16 <gandhi_> if you could drag a list into a file and pass trhough a filter called regex,
23:25:44 <gandhi_> command line is os hotswap
23:25:54 <linuxacolyspe> As long as there are questions, there are bound to be answers in one way or another....g'night guys, be cool and code like the gawdarn wind...peace, OUT! :-)
23:25:56 <glguy> so who likes Haskell?
23:25:56 <gandhi_> is realtime programming
23:26:06 <gandhi_> hehe
23:26:09 <sjanssen> glguy: I do!
23:26:22 * felzix hasn't gotten to really use it yet.
23:26:31 <gandhi_> they are here just drinking and fooling around
23:26:36 <gandhi_> :-)
23:26:48 <Cale> gandhi_: Here's another example -- for programming in a language like Java, you really want an IDE, because there's so much cruft you have to type over and over otherwise.
23:26:57 <Tac-Tics> glguy: I heard that this one time, there was a monad which abstracted the flow control of chat room topics... but it didn't obey the right identity, and so everyone started talking about Java, and version control, and porn
23:27:22 <Cale> However, I think you'll find that in Haskell, you don't really need an IDE for programming because Haskell's UI, that is, its syntax, is nicely concise.
23:27:44 <glguy> ?localtime dons
23:27:45 <lambdabot> Local time for dons is Sun Sep 30 23:26:40 2007
23:27:47 <Tac-Tics> for loops take three times the space that map does
23:27:51 <gandhi_> you still use a oven to do your food, or just get some sticks and try to make fire? :)
23:28:09 <Cale> gandhi_: That's not the appropriate analogy at all.
23:28:16 <gandhi_> do u really think u are not more productive in haskell using and graphical ide?
23:28:38 <Tac-Tics> graphical ides are just sugar. a web browser powered with the internet is all the intellisense I need
23:28:50 <gandhi_> no... u need gopher
23:28:53 <Tac-Tics> and I guess a command line and grep
23:28:55 <gandhi_> u can read it all
23:28:59 <gandhi_> why photos?
23:29:07 <Tac-Tics> IDEs piss me off
23:29:10 <gandhi_> hehe
23:29:14 <Tac-Tics> always inserting extra parens
23:29:18 <gandhi_> haha
23:29:26 <Tac-Tics> they probably cause more syntax errors than without them when I use them
23:29:55 <Cale> There are only a few things where a graphical Haskell IDE could make life better, and they're not presently implemented (at least in free software)
23:30:15 <Cale> All the usual benefits of an IDE are kind of pointless.
23:30:21 <Tac-Tics> I think a Haskell IDE might be neat though
23:30:30 <Tac-Tics> it can help beginners find why their types aren't right
23:30:40 <Tac-Tics> you could like select an expression and see its type
23:30:48 <Tac-Tics> but then again, you can do that with ghci
23:30:50 <Cale> yeah, things like that would be nice
23:30:52 <gandhi_> IDE plugins in haskell would be cool...hehe
23:30:55 <Tac-Tics> but it'd be convinient
23:31:00 <glguy> gandhi_: so did you have any Haskell questions?
23:31:13 <Tac-Tics> hah @ glguy
23:31:25 <felzix> glguy: what an odd question to ask
23:31:27 <OceanSpray> Who's this Haskell Curry character, anyways?
23:31:32 <felzix> :)
23:31:35 <gandhi_> well....
23:31:44 <Cale> gandhi_: You can write Eclipse plugins in Haskell.
23:32:04 <OceanSpray> yeah, an IDE would be nice.
23:32:26 <gandhi_> I will try haskell in eclipse tomorrow
23:32:28 <felzix> what would a haskell ide need to be useful, anyway?
23:32:33 <Tac-Tics> moral of the story: IDEs.... nice, but not necessary
23:32:40 <OceanSpray> emacs + ghc in a terminal isn't exactly what you'd call 'wieldy'
23:32:55 <OceanSpray> see, in eclipse,
23:33:08 <Cale> felzix: realtime typechecking (with highlighting of errors), type-directed autocompletion
23:33:19 <gandhi_> templates
23:33:21 <OceanSpray> errors get pointed out the moment they're written
23:33:24 <Cale> templates?
23:33:33 <Cale> What would you want templates for?
23:33:50 <gandhi_> programmers always have patterns they always use
23:33:58 <OceanSpray> always
23:33:59 <omniscientIdiot> they're mostly used for what Haskell's type system does easily
23:34:07 <Cale> Yeah, and in Haskell, you can basically always abstract them
23:34:18 <OceanSpray> but the realtime type-checking
23:34:23 <Cale> Mostly the patterns become functions.
23:34:24 <Pseudonym> Not always.  Sometimes you want real meta-programming.
23:34:24 <OceanSpray> that's a killer feature right thar
23:34:35 <OceanSpray> metaprogramming?
23:34:35 <omniscientIdiot> There does exist Template Haskell for really out there things
23:34:37 <OceanSpray> try liskell
23:34:39 <Cale> Pseudonym: yeah, but that's what Template Haskell is for. :)
23:34:49 <Cale> It's not the job of an IDE.
23:34:50 * omniscientIdiot is toying with TH right now.
23:34:50 <Pseudonym> I still detest TH.
23:34:57 <Pseudonym> But that might just be me.
23:35:01 <Pseudonym> I don't think it's the "right" answer.
23:35:13 <glguy> I've never come to a problem that required TH at work
23:35:17 <Cale> Pseudonym: Yeah, but that would probably be the design of TH, not really the idea of it.
23:35:23 <Pseudonym> But yeah, "templates" (say, in C++) correspond more or less to built-in Haskell type niceness.
23:35:26 <OceanSpray> The Knights Template
23:35:31 <OceanSpray> The Haskell Templar
23:35:36 <Pseudonym> Cale: I'd agree with that provisionally.
23:35:54 <Tac-Tics2> The Knights Haskellar
23:36:07 * omniscientIdiot is writing a functional references auto-generator.  See http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
23:36:09 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
23:36:18 <Cale> Pseudonym: I'm sure you'd agree that it's not really something which an IDE should be doing ;)
23:36:41 <Pseudonym> Yes. :-)
23:36:55 <gandhi_> another important thing. build, unit tests, continuous integration
23:37:02 <glguy> yeah , then you are no better than ruby on rails with scaffolding
23:37:07 <Cale> Unit tests go into the code.
23:37:10 <omniscientIdiot> gandhi_: have you heard of quickcheck?
23:37:12 <dolio> I thought he meant templates as in "paste in getter-setter functions", not like C++ templates.
23:37:13 <gandhi_> no
23:37:14 <Pseudonym> Probably 80% of the things I'd be tempted to use TH for are covered by the various "scrap your boilerplate" techniques.
23:37:18 <Cale> and yeah, quickcheck :)
23:37:26 <olsner> oh, functional references look neat! perhaps I could build a symbol table out of such things
23:37:28 <gandhi_> ill see
23:37:33 <Tac-Tics2> I never understood what "scrap your boilerplate" meant
23:37:43 <glguy> so you have this boilerplate code
23:37:44 <Cale> gandhi_: Quickcheck autogenerates random unit tests to see if a given property holds.
23:37:46 <OceanSpray> syntax-highlighting, auto-tab, file/module navigation, one-button compilation, debugging,
23:37:48 <glguy> and then you *scrap* it
23:37:50 <omniscientIdiot> gandhi_: it uses haskell's type system to auto generate test data for properties
23:38:08 <Tac-Tics2> what is boilerplate code though?
23:38:12 <Pseudonym> Tac-Tics2: If you want more detail than that...
23:38:12 <gandhi_> hum.... it test norma limits, right?
23:38:17 <Cale> gandhi_: It's just an ordinary Haskell library
23:38:18 <gandhi_> ynormal
23:38:27 <Pseudonym> Boilerplate code is stuff that you find yourself writing for various types.
23:38:28 <Pseudonym> Like...
23:38:28 <Tac-Tics2> is it like what an IDE generates for you when you say "Create new Java file?"
23:38:30 <omniscientIdiot> @check (\x -> reverse (reverse xs) == xs) :: [Int] -> Bool -- gandhi_
23:38:31 <lambdabot>   Not in scope: `xs'
23:38:34 <Cale> There's smallcheck as well, which tries to check boundary cases.
23:38:37 <Pseudonym> You know how you can auto-derive Ord, Eq, Show etc.
23:38:40 <glguy> Is there an easy way to tell irssi not to indent what people type under their names?
23:38:42 <omniscientIdiot> @check (\xs -> reverse (reverse xs) == xs) :: [Int] -> Bool -- oops
23:38:43 <lambdabot>  OK, passed 500 tests.
23:38:49 <glguy> like /set indent off
23:38:52 <glguy> or something :)
23:38:57 <Pseudonym> Imagine being able to do that sort of thing for any type, only writing the transformation once.
23:39:01 <OceanSpray> reatime error detection, automatic code generation for common things, built-in documentation navigation and referencing from code,
23:39:04 <Pseudonym> That's "boilerplate".
23:39:18 <Tac-Tics2> ah
23:39:21 <OceanSpray> let's see, what else...
23:39:24 <gandhi_> hummm ok, but you always have your business rules to test
23:39:33 <Tac-Tics2> so basically, stuff macros are good for, I guess, thus, Template Haskell
23:39:45 <Cale> gandhi_: Yeah, you can express those as equations and it will test them for you.
23:39:54 <OceanSpray> screw you guys
23:39:57 <OceanSpray> I'm going to sleep.
23:40:03 <Tac-Tics2> heh
23:40:06 <Tac-Tics2> bye OS
23:40:12 <omniscientIdiot> Has everyone seen that functional references thing, btw?  It's quite cool.
23:40:29 <gandhi_> bye
23:40:36 <omniscientIdiot> come again!
23:41:16 <omniscientIdiot> oh wait, I thought you were leaving, gandhi_ :)
23:41:26 <gandhi_> hehe
23:41:29 <olsner> that compose thingy makes it really neat and easy to make "mutable" containers
23:41:38 <omniscientIdiot> olsner: yes!
23:42:04 <Cale> gandhi_: the idea of functional programming is that if you find yourself doing the same thing over and over, it's a language deficiency.
23:42:04 <gandhi_> looks like block codes in smalltalk
23:42:15 <omniscientIdiot> and you can use this *now* without any special extensions!
23:42:16 <Cale> gandhi_: Or else you just need to write a library ;)
23:42:34 <omniscientIdiot> gandhi_: what does?
23:42:46 <Tac-Tics2> Cale: I thought the idea of functional programming was first class lambda objects?
23:42:46 <gandhi_>  "mutable" containers
23:42:58 <Cale> Tac-Tics: The bigger idea :)
23:43:02 <Tac-Tics2> whatever
23:43:02 <Tac-Tics2> hehe
23:43:25 <gandhi_> man... where u from...
23:43:31 <gandhi_> Im from brazil.
23:43:45 <Cale> Canada
23:43:57 <omniscientIdiot> Do you know any Haskell, gandhi_?
23:44:13 <glguy> no, but his friend does
23:44:21 <gandhi_> nope. very good friend knows a lot
23:44:51 <omniscientIdiot> http://blogs.nubgames.com/code/?p=22 is a great read for some high-level advocacy :o)
23:44:52 <lambdabot> Title: Nub Games : Haskell IO for Imperative Programmers
23:45:04 <gandhi_> I have sent good links.
23:45:36 <olsner> omniscientIdiot: now you just put it in a monad, and you could get something suspiciously like OOP on records
23:47:05 <omniscientIdiot> olsner: not sure what you mean.  The FRef page doesn't have anything that looks suspiciously like a monad to me.
23:49:19 <Cale> btw, does anyone have a shorter solution to that pennies puzzle than this: http://cale.yi.org/autoshare/pennies.png ?
23:50:06 <Cale> (the one from here: http://programming.reddit.com/info/2v8td/comments)
23:50:08 <lambdabot> Title: Arboreal Isomorphisms from Nuclear Pennies (reddit.com)
