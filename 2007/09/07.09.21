00:09:03 <sarehu> > liftM2 (||) (== 0) (== 1) 2
00:09:06 <lambdabot>  False
00:09:32 * glguy discovers that hpaste already builds against current happs
00:11:26 <kaol> I find that I miss perl's s/// operator.
00:12:40 <glguy> shapr: are you there?
00:18:25 <shapr> glguy: yup
00:18:34 <glguy> can you add an ssh key to my kakapo account?
00:18:52 <shapr> glguy: yup
00:18:56 <glguy> I want to push an anti-spam patch
00:19:36 <shapr> I wonder if an hpaste account would be a good idea.
00:19:57 <glguy> could be
00:26:11 <dolio> @type ((+1) ***) . ((+) . (/n))
00:26:20 <lambdabot> Not in scope: `n'
00:26:27 <bos> http://www.realworldhaskell.org/blog/2007/09/21/early-chapters-have-gone-to-reviewers/
00:26:28 <dolio> @type ((+1) ***) . ((+) . (/?n))
00:26:30 <lambdabot> Title: Real World Haskell » Blog Archive » Early chapters have gone to reviewers, http://tinyurl.com/yvlo3e
00:26:30 <lambdabot> Not in scope: `/?'
00:26:30 <lambdabot>  
00:26:30 <lambdabot> <interactive>:1:23: Not in scope: `n'
00:26:37 <dolio> @type ((+1) ***) . ((+) . (/ ?n))
00:26:39 <lambdabot> forall b a. (Num b, ?n::a, Fractional a) => a -> (b, a) -> (b, a)
00:28:05 <oerjan> @unpl ((+1) ***) . ((+) . (/ n))
00:28:06 <lambdabot> (\ f -> (\ a -> a + 1) *** ((+) (f / n)))
00:28:33 <dolio> \e (m,k) -> (e/n + m, k+1)
00:28:45 <dolio> Er, reversed.
00:31:11 <glguy> @tell sorear I added a patch to hpaste to help deter some of the spam that has been occurring lately, let me know what you think and consider restarting the daemon
00:31:11 <lambdabot> Consider it noted.
00:31:41 <lokik> is there a hexadecimal type?
00:31:49 <glguy> Like Int?
00:31:50 <glguy> or String?
00:32:01 <glguy> for math and for showing
00:32:47 <lokik> math
00:32:51 <oerjan> > 0xBEEF :: Int
00:32:53 <lambdabot>  48879
00:33:02 <lokik> cool
00:33:12 <lokik> :-)
00:33:16 <lokik> thanks
00:33:20 <glguy> hexadecimal is just a representation, it doesn't change the math
00:33:34 <glguy> but that is how you write a hexadecimal literal
00:33:43 <oerjan> > showHex 48879
00:33:45 <lambdabot>  <[Char] -> [Char]>
00:33:50 <oerjan> > showHex 48879 ""
00:33:52 <lambdabot>  "beef"
00:34:09 <lokik> i just only needed the 4 bits, Int's should be even easier to work with, theoretically anyways, maybe
00:34:42 <lokik> working on a random number generator
00:35:19 <lokik> -- takes 3 hex's (initial, comparison, function-list)
00:35:35 <lokik> atm is what i got :-)
00:35:36 <lokik> lol
00:35:45 <lokik> kk i'll use int's
00:35:59 <glguy> lol, so eithe rI don't know what you're talking about or you don't ;)
00:36:18 <lokik> well i do,  i need to examine the hex bit for bit
00:36:32 <oerjan> @docs Data.Bits
00:36:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
00:36:38 <oerjan> you may want that
00:37:09 <lokik> yea, is there a tutorial for that?
00:37:24 <lokik> bitwise operations in haskell?
00:37:33 <lokik> like some example code
00:37:35 <glguy> lokik: so you realize that the bits in a "hex number" are the same as those in a "decimal number" right?
00:37:38 <fax> :t (.&.)
00:37:41 <lambdabot> forall a. (Bits a) => a -> a -> a
00:38:23 <lokik> glguy: well i need 4 bits to get a complete set of bit streams
00:38:52 <lokik> 2^2 = 4
00:39:11 <lokik> 4^2 = 16 = hexadecimal
00:39:30 <lokik> and all bit streams are based off of that
00:40:01 <lokik> well out of the initial 16 varieties
00:40:07 <glguy> lokik: oh, ok. do you have a link to the algorithm you are using?
00:40:09 <fax> 16 does not "equal" hexadecimal
00:40:25 <fax> hexadecimal is a way of representing numbers
00:40:38 <lokik> agreed, it was assumed you understood that
00:40:56 <fax> if you just want a type which has at least 16 bits pretty sure Int  does
00:41:10 <lokik> well i need 4 bits
00:41:11 <fax> > 17 :: Int
00:41:14 <fax> er :/
00:41:16 <lambdabot>  17
00:41:19 <oerjan> if you want to be sure there is Word16
00:41:38 <wli> Wide words?
00:41:57 <glguy> lokik: Where can I read about this algorithm?
00:42:08 <oerjan> well, actually i think Int's are guaranteed 31 or 32
00:42:18 <lokik> well i haven't finished it yet, still looking for a haskell bitwise tutorial
00:42:19 <sjanssen> 29 IIRC
00:42:24 <wli> oerjan: 29
00:42:32 <glguy> lokik: no, the spec for what you are implementing
00:42:33 <oerjan> > bitSize (1::Int)
00:42:35 <lambdabot>  32
00:42:52 <lokik> yea, i haven't written it yet cause i want to have a realistic implementation
00:42:53 <oerjan> ok
00:43:21 <lokik> to make sure it generates random numbers at least
00:43:42 <lokik> it should, in theory, as it is functionally complete
00:43:52 <lokik> uses, not, and, or
00:43:57 <lokik> so that's everything
00:44:08 <lokik> uses:
00:44:09 <lokik> *
00:44:11 <oerjan> i hope you are not making this algorithm yourself
00:44:15 <oerjan> *making up
00:44:16 <lokik> i am
00:44:18 <glguy> are we being trolled?
00:44:21 <lokik> i make up everything
00:44:43 <oerjan> because if you are you are either a genius, or in way over your head
00:44:53 <lokik> well i'm a super genius
00:44:58 <lokik> :-)
00:45:05 <lokik> divinity actually
00:45:08 <oerjan> you about that :)
00:45:24 <lokik> tcana.info <- website
00:45:25 <glguy> sweet, we taught a god about hex :)
00:45:39 * osfameron is considering a "study break" of 2-6 weeks after this contract
00:45:43 <lokik> sorta, still haven't found that tutorial
00:45:50 <ari> The joys of hex :)
00:45:53 <osfameron> what would you guys recommend as stuff to learn/books to follow in that period?
00:46:26 * osfameron is thinking of: a) finish HSOE, b) learn git/darcs c) TAPL, d) some Perl modules I need to catch up on e) possibly Erlang
00:46:28 <iguana_> how to convert double to int?
00:46:34 <lokik> like so i could use bitwise operations between int's?
00:46:36 <oerjan> @quote fromIntegral
00:46:37 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
00:46:46 <oerjan> oh wait, wrong direction :D
00:47:02 <oerjan> stop asking the wrong FAQ's :D
00:47:06 <iguana_> heh
00:47:18 <glguy> lokik: Did you used to go by loki, and Lokadin?
00:47:23 <lokik> yep
00:47:26 <oerjan> @src RealFrac
00:47:27 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
00:47:27 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
00:47:27 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
00:47:33 <oerjan> try one of those
00:47:33 <lokik> my friends call me loki
00:47:47 <iguana_> ok
00:47:53 <paolino> Is there a general complexity relation between ordering and grouping by equality ?
00:48:13 <lokik> no idea
00:48:29 <lokik> what's a general complexit relation?
00:48:55 <paolino> ehm, is possible to explain sorting in terms of grouping by eq and complexity only
00:49:08 <lokik> what you mean by complexity
00:49:20 <lokik> ?
00:49:22 <paolino> like sorting makes grouping less then O(n!)
00:49:40 <oerjan> sorting is usually considered O(n log n)
00:50:12 <lokik> how about unique lines?
00:50:32 <oerjan> you're not talking about grouping with group, which only groups adjacent things?
00:50:35 <paolino> oerjan: then grouping is linear after sorting ?
00:50:48 <paolino> yes be quality
00:50:50 <oerjan> paolino: would imagine so
00:51:01 <Pseudonym> O(log(n!)) = O(n log n)
00:51:03 <paolino> *by equality
00:51:10 <oerjan> group is linear
00:51:19 <oerjan> and after you've sorted, you can use group
00:51:34 <oerjan> but group itself only groups adjacent things
00:51:36 <iguana_> @type mod
00:51:44 <lambdabot> forall a. (Integral a) => a -> a -> a
00:51:53 <iguana_> hmm... is there a mod for floats?
00:52:00 <oerjan> nope, another FAQ
00:52:18 <oerjan> properFraction is closest
00:52:36 <oerjan> it mods by 1,
00:52:44 <paolino> Pseudonym: that is right ? O(log(n!)) = O(n log n)
00:52:54 <oerjan> (well for positive numbers)
00:52:59 <glguy> n! is similar to n^n
00:53:02 <iguana_> this is already good enough
00:53:05 <glguy> log (n ^ n) is n log n
00:53:27 <Pseudonym> paolino: Yup.
00:53:46 <Pseudonym> It's the closest "reasonable" function.
00:54:56 <paolino> mmhh, then something sortable is not easier groupable than something unsortable
00:54:58 <oerjan> modding by other things can be done by using that with a bit multiplication and division
00:55:10 <oerjan> paolino: sure it is
00:55:29 <glguy> sortable things can be grouped in n log n time while unsortable ones take n^2
00:55:48 <Pseudonym> Not quite.
00:55:49 <sjanssen> Pseudonym: is "O(log(n!)) = O(n log n)" really true, or just close to true?
00:55:59 <Pseudonym> Comparable things can be grouped in n log n time.
00:56:04 <paolino> how much is the complexity of grouping via eq an unsotable ?
00:56:05 <glguy> it's true in O notation
00:56:11 <Pseudonym> Equality testable things can be grouped in O(n^2) time.
00:56:25 <Pseudonym> Certainly, O(log(n!)) >= O(n log n)
00:56:28 <Pseudonym> That's easy to see.
00:56:32 <quicksilver> aha!
00:56:39 <Pseudonym> I _think_ the bound is tight.
00:56:46 <Pseudonym> Within a constant factor.
00:57:03 * quicksilver realises you need to turn off depth testing for transparent particles
00:57:13 <sjanssen> so we're sure that "n log n \elem O(log(n!))"?
00:57:32 <Pseudonym> Erm, hang on.
00:57:37 * dolio is pretty sure.
00:57:38 <Pseudonym> O(log(n!)) <= O(n log n)
00:57:41 <sjanssen> I'm not sure what ">=" means there, subset?
00:57:42 <Pseudonym> That's the obviosu one.
00:57:48 <Pseudonym> Yeah, subset.
00:57:53 <oerjan> 2^n <= n! <= n^n
00:58:14 <oerjan> hm, the first is not enough
00:58:21 <quicksilver> n! is asymptotic to sqrt(n) (n/e)^n
00:58:35 <Pseudonym> See, to find a specific permutation of n things, you need to know a number between 1 and n!.
00:58:43 <Pseudonym> That requires log(n!) bits of information.
00:58:51 <quicksilver> so log (n!) is asymptotic to log(n)/2 + n (log n - log e)
00:58:52 <Pseudonym> Since one comparison provides one bit of information.
00:59:06 <Pseudonym> It follows that comparison-based sorting is worst-case O(log(n!))
00:59:10 <quicksilver> conclusion: log(n!) is asymptotically the same as n log n
00:59:13 <Pseudonym> Right.
00:59:37 <paolino> ok, so usually you get impression sortable things can be grouped faster than the messy ones , but not for google numbers
01:00:06 <oerjan> google numbers?
01:00:14 <paolino> big ones
01:01:12 <paolino> yes, sorry, my question was more semantica than haskell prob
01:01:26 <Pseudonym> In theory, of course, hashable things can be grouped even faster.
01:01:45 <glguy> isn't that more of a "in practice"
01:01:51 <goalieca> O(log(n!)) is n log(n) ? i suppose it is upper bounded.. but is it actually convergent?
01:02:05 <goalieca> at the infinity of course
01:02:10 <oerjan> quicksilver just gave the argument
01:02:15 <paolino> mmhh it depends on the hash lenght ?
01:02:25 <Pseudonym> glguy: Given an exceedingly good hash function, hashing is amortised O(1) per element.
01:02:39 * goalieca needs to learn to use scroll
01:02:45 <oerjan> O() is up to constant bound
01:03:14 <glguy> Pseudonym: sure, but that is an "in practice" thing
01:03:25 <glguy> in theory hash tables suffer from collisions
01:03:39 <glguy> and have non linear worst cases
01:03:48 <glguy> if you had a perfect hash function, you've already solved the grouping problem
01:03:52 <goalieca> what is maximum possible colission rate though
01:03:56 <goalieca> depending on data
01:04:01 <glguy> goalieca: 100%
01:04:11 <dolio> Heh.
01:04:15 <Pseudonym> glguy: Actually, that's not true.
01:04:19 <glguy> which part?
01:04:23 <Pseudonym> If you keep the load on your hash table constant.
01:04:41 <Pseudonym> Then you need O(longest chain length) worst-case time to find an element, right?
01:04:52 <paolino> a hash function is is good if show is accurate ?
01:05:13 <oerjan> someone just implemented a HashTable that used Map for the chains
01:05:21 <goalieca> yup.. but if you have a finite space of input to the hash function.. you can hopefully distribute it across n hashes
01:05:28 <glguy> Pseudonym: but in theory there is no reason for all of the elements not to collide
01:05:28 <oerjan> claimed it was faster than Map in some cases
01:05:32 <Pseudonym> Right.
01:05:50 <Pseudonym> And, I might add, in the case of group, you only need one entry per group.
01:05:53 <Pseudonym> Not one entry per element.
01:05:58 <oerjan> think it was in haskell-cafe maybe?
01:06:22 <glguy> Pseudonym: so if they are all unique, the worst case goes to O(n^2)
01:06:25 <dolio> I think it was here.
01:06:39 <Pseudonym> glguy: Assuming a bad hash function.
01:06:57 <Pseudonym> The O(1) amortised time assumes that you grow the hash table to keep the load factor constant.
01:07:17 <Pseudonym> And growing it geometrically assures O(1) work per element doing the copying.
01:07:26 <glguy> there isn't a guarantee that you'll find a suitable hash function
01:07:34 <glguy> so the worst case still exists
01:08:06 <Pseudonym> Sure.
01:08:15 <glguy> but in practice, you can find a suitable function
01:08:21 <glguy> that's all I was hoping to say
01:08:26 * Pseudonym thinks about that
01:08:32 <Pseudonym> I'm not sure if it's "in practice" or "randomised".
01:08:54 <glguy> randomized algorithms have expected complexity
01:09:00 <Pseudonym> Yeah.
01:09:00 <glguy> but they still have worst case complexity
01:09:20 <glguy> so it might be linear expected time, (I don't know)
01:11:09 <quicksilver> depends on what assumptions you're prepared to make about your incoming data
01:11:35 <quicksilver> there certainly are assumptions under which you can get expected O(1)
01:11:50 <quicksilver> but real data may not be like that
01:13:09 <quicksilver> I find probabilistic arguments hard to check :) I'm quite easily misled by them, and I suspect I'm not alone. So I don't entirely trust people's esitimates on expected complexities ;)
01:13:12 <iguana_> @pl \(x,y) -> (y,x)
01:13:12 <lambdabot> uncurry (flip (,))
01:13:16 <iguana_> uh
01:13:41 <quicksilver> iguana_: (snd &&& fst) is perhaps prettier
01:13:53 <quicksilver> iguana_: although myself I tend to use (\(x,y)->(y,x))
01:13:56 * glguy wonders what was wrong with the original ;)
01:13:59 <iguana_> &&&?
01:14:09 <glguy> quicksilver: ***
01:14:10 <oerjan> :t (&&&)
01:14:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:14:14 <Cale> http://pics.livejournal.com/moomlyn/pic/000173gf/ -- haha :)
01:14:15 <lambdabot> Title: untitled picture
01:14:21 <oerjan> :t (***)
01:14:23 <iguana_> uh
01:14:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:14:45 <quicksilver> glguy: no, I was right
01:14:47 <Pseudonym> Gotta go.
01:14:48 <Pseudonym> Nytol!
01:14:52 <glguy> yeah, I figured that too :)
01:14:54 <quicksilver> glguy: I normally get those two wrong, but this time I didn't :)
01:14:54 <iguana_> I think I stay with \(x,y) -> (y,x)
01:14:57 <oerjan> :t (***).(id.)
01:14:59 <lambdabot> forall b' c' b a. (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
01:15:00 <quicksilver> > (snd &&& fst) (3,4)
01:15:02 <lambdabot>  (4,3)
01:15:26 <quicksilver> glguy: you can't built a twist out of ***
01:15:38 <quicksilver> it doesn't let the two 'channels' communicate, I don't think
01:15:56 <iguana_> the whole arrow thing is still beyond my reach
01:16:05 <quicksilver> iguana_: not really using arrows though
01:16:07 <quicksilver> iguana_: just functions
01:16:19 <quicksilver> iguana_: &&& and *** are just useful functions on tuples
01:16:21 <oerjan> :t (&&&).(id.)
01:16:23 <lambdabot> forall c' b a. (a -> b) -> (a -> c') -> a -> (b, c')
01:16:32 <quicksilver> > ((+1) &&& (-1)) 4
01:16:32 <lambdabot>   add an instance declaration for (Num (b -> c'))
01:16:36 <fax> is it tupples or tooples?
01:16:41 <glguy> tuples
01:16:45 <quicksilver> > ((+1) &&& (*2)) 4
01:16:46 <lambdabot>  (5,8)
01:16:50 <fax> how do you pronounce :|
01:16:53 <glguy> oh :)
01:16:54 <glguy> too
01:16:56 <iguana_> fax: I'd say tupples, but then I'm german
01:16:57 <Syzygy-> I pronounce oo
01:17:01 <quicksilver> iguana_: &&& just lets you do two functions to the same thing
01:17:03 <quicksilver> 'tooples'
01:17:08 <lokik> are bitwise and and or operators 3 or 5 characters long? confusing specs..
01:17:08 <oerjan> i say tomayto, you say tomahto
01:17:26 <quicksilver> lokik: .&. is three characters?
01:17:26 <iguana_> quicksilver: and puts them in a tuple?
01:17:26 <glguy> but *websters* says...
01:17:27 <glguy> ;)
01:17:30 <quicksilver> iguana_: right
01:17:31 <lokik> kk
01:17:37 <lokik> thanks
01:17:44 <iguana_> > (fst &&& snd &&& fst) (1,2)
01:17:46 <lambdabot>  (1,(2,1))
01:18:02 <oerjan> O_o
01:18:07 <iguana_> okay, I think I got that ^^
01:18:07 <glguy> m-w.com says that tuple is a combining form
01:18:12 <glguy> 2-tuple
01:18:23 <Syzygy-> oerjan: You didn't expect that?
01:18:28 <fax> @hoogle (a,a) -> [a]
01:18:28 <lambdabot> No matches, try a more general search
01:18:28 <glguy> doesn't seem to have the generalization
01:18:52 <quicksilver> glguy: I suspect it was coined by date & darwen, or maybe codd?
01:18:57 <Syzygy-> fax: The standard answer there is "If you want to do that, you need to rethink what you do"
01:19:02 <oerjan> it's not the kind of operator you expect to associate
01:19:08 <Syzygy-> At least, that's what people told me to do.
01:19:08 <glguy> Definition:Â Â in a database, an ordered set of data constituting a record; a data structure consisting of comma-separated values passed to a program or operating system
01:19:16 <iguana_> > (head &&& tail) [1,2,3]
01:19:18 <lambdabot>  (1,[2,3])
01:19:19 <Syzygy-> oerjan: It's just another function. Of course it associates.
01:19:22 <glguy> comma-separated values, eh?
01:19:36 <oerjan> Syzygy-: it could have infix[^lr]
01:19:39 <oerjan> *been
01:19:40 <Syzygy-> glguy: o.O
01:19:50 <quicksilver> Syzygy-: I think you could make a case for 'forbidding' association when it doesn't make sense
01:19:57 <oerjan> > (0$0 &&&)
01:19:58 <lambdabot>      The operator `&&&' [infixr 3] of a section
01:19:58 <lambdabot>         must have lower prece...
01:20:01 <Syzygy-> quicksilver: Sure.
01:20:02 <glguy> Syzygy-: Webster's New Millenniumâ¢ Dictionary of English said that
01:20:15 <quicksilver> Syzygy-: (+) is genuinely associative, that's fine. (.) has a useful association direction, that's fine.
01:20:16 <Syzygy-> glguy: ...
01:20:29 <quicksilver> (&&&) doesn't really have a natural association direction so forbid it, IMO :)
01:20:34 * iguana_ doesn't dare say he expected a 3-tuple
01:20:36 <Syzygy-> quicksilver: I agree with that there is a case for it. I also observe that it doesn't seem to actually do that.
01:20:40 <quicksilver> ;)
01:20:44 <glguy> Syzygy-: I'm not sure what you want me to say :)
01:21:03 <lokik> hmm have problem where it says inferred type: m Int
01:21:05 <Syzygy-> glguy: That's more of an expression for my speechlessness than an expectation on you.
01:21:10 <glguy> ah, good :)
01:21:17 <lokik> after i do complement i::Int
01:21:26 <Syzygy-> :t complement
01:21:27 <lambdabot> forall a. (Bits a) => a -> a
01:22:37 <Syzygy-> lokik: Is Int really implementing Bits though?
01:22:49 <lokik> well you tell me
01:22:52 <paolino> :t \i -> complement i >>= return
01:22:54 <lambdabot> forall (m :: * -> *) a. (Bits (m a), Monad m) => m a -> m a
01:23:08 <oerjan> > complement 1 :: Int
01:23:10 <lambdabot>  -2
01:23:15 <Syzygy-> Hmmm.
01:23:18 <Syzygy-> Of course it does.
01:23:19 <Syzygy-> GOA Data.Bits> complement (12::Int)
01:23:19 <Syzygy-> -13
01:23:29 <oerjan> lokik: i think i may the problem
01:23:34 <oerjan> *may be
01:23:40 <lokik> ?
01:23:45 <oerjan> it is probably not an Int
01:23:59 <lokik> output?
01:24:16 <Syzygy-> lokik: Where does i come from?
01:24:25 <lokik> how else could i flip the bits from 1's to 0's?
01:24:31 <lokik> er reverse them
01:24:42 <Syzygy-> lokik: Listen to what we say. Where did you get i?
01:25:00 <oerjan> !paste
01:25:01 <hpaste> Haskell paste bin: http://hpaste.org/
01:25:14 <paolino> lokik: you are inside a monad ?
01:25:22 <glguy> bah, don't drag hpaste into this... it didn't do anything wrong
01:25:43 <paolino> eheh
01:26:10 <oerjan> glguy: when we start debugging code we haven't seen?
01:26:13 <hpaste>  loki pasted "random number generator" at http://hpaste.org/2837
01:26:32 <lokik> kk
01:26:36 * paolino greats his "euclidean problems" master glguy
01:26:53 <glguy> ex-master
01:27:00 <glguy> pe has moved on since my time ;)
01:27:28 <oerjan> hpaste appears to be wading in molasses
01:27:31 <lokik> hpaste is really slow for some reason
01:27:34 <lokik> yea
01:27:41 <glguy> its upset
01:27:59 <wli> What's this Euclidean bit?
01:28:02 <paolino> glguy oh no,it means I risk to be alone in the deep space, if I reach that line
01:28:16 <glguy> wli: he's just referring to Project Euler
01:28:21 <glguy> I think
01:28:25 <paolino> it shouldn't happen
01:28:30 <paolino> sure
01:28:33 <wli> Those would be Eulerian problems.
01:28:37 <lokik> only 11 lines of code
01:28:42 <paolino> ops
01:28:53 <oerjan> :t testBit
01:28:56 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
01:29:24 <paolino> wli, my ignorance preceds me :P
01:29:36 <oerjan> lokik: remove those return
01:29:41 <lokik> kk
01:30:04 <oerjan> return is only for monadic code. it does _not_ return from a function in haskell.
01:30:45 <osfameron> why is it called "return" in that case, by the way?
01:31:02 <glguy> creates a monadic value that returns the value given
01:31:03 <lokik> hhmmm, oh well i'll work on it some more
01:31:19 <oerjan> don't know, it used to be called unit i think
01:31:34 <oerjan> but someone thought that was even less obvious, i take
01:31:35 <paolino> I just asked about ordering and grouping thinking about problem 62 of that project
01:32:11 <oerjan> a bit too late to change the name now
01:33:56 <paolino> return is the object creation or what else ?
01:34:09 <paolino> :t return
01:34:11 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:34:17 <quicksilver> osfameron: I think it's called return because it does feel rather like return, in monads like IO
01:34:33 <quicksilver> osfameron: if you view a monad as a 'computation' then return 'returns a result to this computation'
01:34:48 <quicksilver> osfameron: and "return 5" is the "computation which does no work and then yields the result 5"
01:35:03 <quicksilver> osfameron: it does cause plenty of confusion though :)
01:35:12 <paolino> it creates the object of type m with as booting parameter
01:35:20 <osfameron> quicksilver: yeah, the odd thing is that sometimes it feels like a return and sometimes it doesn't...
01:35:44 <paolino> well that's my idea IMO really
01:36:21 <Rebooted> \msg lambdabot
01:36:23 <quicksilver> paolino: the word "object" has a lot of connotations ;)
01:36:24 <Rebooted> oops
01:36:47 <quicksilver> paolino: for some particular sense of the word, yes
01:37:27 <paolino> quicksilver , monad is enough complex to identify a class of them
01:37:32 <Rebooted> you should probably play around with the identity monad or something and see what is going on
01:37:55 <quicksilver> paolino: I certainly wouldn't call an IO action an 'object' though
01:38:08 <quicksilver> paolino: mainly because object has so many connotations from the world of OOP
01:38:14 <quicksilver> I think 'action' is a much better word, in fact
01:38:58 <paolino> I think IO is the object , not the action which returns IO a
01:39:17 <paolino> Monad is the class
01:39:18 <quicksilver> paolino: the action doesn't return IO a
01:39:27 <quicksilver> paolino: the "IO a" value *is* the action
01:39:27 <paolino> ah
01:39:30 <Rebooted> paolino: Haskell doesn't have objects
01:39:45 <Rebooted> paolino: and classes are not the same as in OOP
01:39:50 <quicksilver> paolino: suppose you have drawRect : Int -> Int -> Int -> Int -> IO ()
01:40:04 <quicksilver> paolino: then drawRect is a function, which takes four parameters, and returns an IO () actions
01:40:15 <quicksilver> at least, that's the terminology I think is most pleasing
01:40:25 <quicksilver> you could say "takes for parameters and returns an IO () object"
01:40:33 <quicksilver> but, it wouldn't be an object in the Java sense
01:40:35 <paolino> right
01:41:00 <quicksilver> it is an object in the sense of "black box thing that we can't do much to except a limited range"
01:41:01 <paolino> it has the Monad methods
01:41:18 <quicksilver> in this case all we can do to it is combine it with other IO actions
01:41:25 <quicksilver> (and run it, implicitly, by putting it in main)
01:41:27 <Rebooted> paolino: yes, >>= and return
01:41:50 <glguy> paolino: my solution to 62 runs instantaneously in interpreted mode
01:41:59 <glguy> what optimizations were you talking about?
01:42:28 <paolino> glguy last I post and did is 61,now
01:42:41 <paolino> so I can't see yours still
01:42:48 <glguy> I didn't post mine
01:42:53 <glguy> I just recoded it
01:43:01 <glguy> to remember how fast it was
01:43:06 <iguana_> isn't it true that you can't get the "a" out of IO a?
01:43:14 <quicksilver> iguana_: yes
01:43:28 <quicksilver> iguana_: but, surprisingly, you never need to :)
01:43:49 <iguana_> but  then liftIO is a bit surprising to me
01:44:09 <iguana_> @type liftIO
01:44:17 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
01:44:43 <iguana_> because you can at least put the a into another monad
01:45:00 <paolino> quicksilver, an instantiated implemeted interface is a Java object IIRC
01:46:05 <iguana_> but ok, you'd have to deliver your own liftIO implementation for a custom monad, which is again impossible
01:46:26 <paolino> which mimics IO () creation operations in haskell
01:48:50 <paolino> anyway, what counts is understanding monads at least to breath out
01:49:44 <paolino> then make a piece of euler, and then stop some time to digest
01:51:15 <paolino> not like Java or python, that you can eat them all , with no sleeping
01:51:53 <paolino> ok, work time
01:51:59 <glguy> paolino: you should be able to solve #62 with 3 lines, a case statement and two branches
01:58:20 <wli> What's #62 again?
01:58:46 <glguy> first cube for which 4 other permutations of its digits are also cubes
01:59:08 <wli> Okay.
01:59:38 <wli> I don't see a 4-line solution but I can do it.
02:00:01 <glguy> I posted my Haskell to the end of the forum
02:02:43 <iguana_> where are these tasks from?
02:02:53 <glguy> http://www.projecteuler.net
02:02:56 <lambdabot> Title: Project Euler
02:05:34 <osfameron> ooo, I'm behind on my eulering...
02:06:53 <adaptable2> What's your score.
02:07:36 * osfameron is on 11%... haven't looked at it for weeks
02:07:41 <quicksilver> iguana_: the point about liftIO is that 'm' also includes IO, in one sense or another
02:07:52 <quicksilver> iguana_: typical example is StateT s IO
02:08:02 <quicksilver> iguana_: so the IO is there underneath anyway
02:30:32 <tibbe> is there a name for non-monadic code other than, well, non-monadic?
02:30:44 <nominolo> pure?
02:30:50 <tibbe> that was my idea
02:30:57 <tibbe> but monadic code is also pure, no?
02:31:05 <nominolo> no
02:31:13 <nominolo> applicative is not pure
02:31:29 <tibbe> I want to write a section title: "Monadic vs. <insert word here> API"
02:31:29 <nominolo> so that's not exactly accurate
02:31:47 <tibbe> so what does pure mean in this context?
02:31:55 <tibbe> referentially transparent?
02:32:14 <nominolo> depends on what the point of the section is going to be
02:36:03 <nominolo> not sure that's totally accurate either, since any pure program can trivially be mad monadic using the identity monad
02:36:39 <nominolo> but, fwiw, i think "monadic vs non-monadic api" sounds reasonable to me
02:37:02 <kosmikus> monadic code can be pure
02:37:13 <tibbe> nominolo: basically I'm going to write a discussion about a new web application interface for haskell and want a section on the pros and cons of having a monadic API for it
02:37:35 <tibbe> nominolo: I could go with "Monadic?!?" as the title ;)
02:37:58 <nominolo> "monadic???!!!1111oneone"
02:38:13 <tibbe> that's it!
02:38:27 <tibbe> you forgot the "eleven" though
02:38:45 <nominolo> eleventyone
02:39:42 <nominolo> (bilbo baggins' age)
02:40:10 <tibbe> heh
02:47:53 <hs-newb> can anybody explain to me the subtle difference between 'fst $ snd (1,(2,3))' and '(fst . snd) (1,(2,3)'?
02:48:40 <iguana_> is there a difference?
02:48:46 <fax> > fst $ snd (1,(2,3))
02:48:48 <lambdabot>  2
02:48:53 <fax> > (fst . snd) (1,(2,3)
02:48:53 <lambdabot>  Unbalanced parenthesis
02:49:04 <quicksilver> hs-newb: well $ is function application
02:49:22 <hs-newb> I missed a ) sry
02:49:24 <quicksilver> hs-newb: so fst $ snd (1,(2,3)) is fst (snd (1,(2,3))
02:49:56 <quicksilver> hs-newb: meanwhile, (.) is composition, defined precisel so that (f.g) x is the same as f ( g x )
02:49:59 <iguana_> ...)
02:50:22 <quicksilver> hs-newb: so (fst . snd) (1,(2,3)) is therefore fst (snd (1,(2,3)))
02:50:24 <quicksilver> hs-newb: i.e. the same
02:50:43 <opqdonut> f (g x) == f $ g x == (f.g) x == f.g $ x == f $ g $ x
02:50:59 <b_jonas> don't you need spaces around the dots?
02:51:06 <opqdonut> nope
02:51:09 <b_jonas> because of package things
02:51:16 <quicksilver> b_jonas: no, but it's considered good style by some
02:51:17 <opqdonut> packages start with a caps
02:51:23 <b_jonas> I see
02:51:30 <quicksilver> of course some functions start with a cap, too
02:51:35 <quicksilver> and then you do need it
02:51:36 <b_jonas> so you need a space when you have a constructor on the left
02:51:40 <opqdonut> yep
02:51:46 <hs-newb> thx quicksilver
02:51:47 <b_jonas> thanks
02:51:51 <quicksilver> it is goot style to always use a space
02:51:55 <opqdonut> so it's good form to have spaces :)
02:51:56 <opqdonut> yeah
02:51:56 <quicksilver> btu I don't always bother myself :)
02:52:00 <b_jonas> obviously
02:52:07 <b_jonas> or parens
02:52:54 <SamB_XP> @src .
02:52:54 <lambdabot> (.) f g x = f (g x)
02:52:59 <SamB_XP> @src $
02:53:00 <lambdabot> f $ x = f x
02:53:09 <b_jonas> well, in J I'm quite agressive in omitting spaces (and to delimit larger parts of an expression visually with spaces)
02:53:20 <b_jonas> but the rules for where you need them are quite easy
02:53:48 <b_jonas> I mean, easier than in haskell
02:53:55 <SamB_XP> to be sure
02:54:06 <SamB_XP> J doesn't have precedence or associativity
02:54:25 <b_jonas> sort of
02:54:31 <SamB_XP> yeah
02:54:32 <b_jonas> it has some precedence
02:54:36 <b_jonas> but it does have associativity
02:54:41 <SamB_XP> hmm?
02:54:44 <b_jonas> but always the same way
02:54:49 <fax> 2*34+
02:54:55 <SamB_XP> ah, yes, that's what I m meant ;-)
02:55:03 <fax> 2*3+4 in J is like APL, 2*(3+(4)) ?
02:55:08 <b_jonas> I mean, it's not like all verbs are non-associative
02:55:14 <b_jonas> fax: yes
02:55:23 <fax> where is preceidence?
02:55:28 <fax> I forgot :S
02:55:42 <b_jonas> J has higher level operators which can act on both verbs and nouns
02:55:52 <b_jonas> (apl too but not only a few of them)
02:56:04 <b_jonas> and those are in a separate syntax category
02:56:15 <b_jonas> and have higher precedence and opposite associativity
02:56:21 <SamB_XP> I know very little J -- maybe two days worth...
02:56:37 <fax> ooh
02:57:20 <b_jonas> so there are four basic kinds of data which are distinguished by the evaluator (parser) as well: nouns, verbs (functions), adverbs (higher level functions, unary), and conjunctions (higher level functoins, binary)
02:58:20 <b_jonas> plus variables which can take any of these as a value, and very few extra stuff like parenthesis and assignment ops
02:58:42 <SamB_XP> well, compared to Haskell where precedence/associativity applies between any two infix operators regardless of syntactic category...
02:59:10 <b_jonas> these four types and variables and their type and junks define what the evaluator does
03:00:09 <fax> I found something beautful in J
03:00:16 <arcatan> what?
03:00:29 <b_jonas> SamB_XP: actually, the ugly part of J syntax (apart from the hacks you have to do to imitate things it doesn't have, like full lexical scope) is that it's very dynamic
03:00:47 <SamB_XP> b_jonas: yes, that I have learned
03:00:59 <b_jonas> an expression can be interpreted differently depending on what variables contain or what a (non-pure) function happens to return
03:01:27 <b_jonas> luckily, in almost all cases, you don't write programs that depend on this, but rely on some fixed parsing
03:01:58 <SamB_XP> but how hard is it for the implementation to see this?
03:02:11 <b_jonas> what do you mean?
03:02:22 <b_jonas> oh, you mean to prove this?
03:03:22 <b_jonas> I think it's very hard because something like eval happens quite often (in fact, two such things)
03:03:27 <hpaste>  fax pasted "precidence rules" at http://hpaste.org/2838
03:03:37 <fax> arcatan: this
03:05:25 <SamB_XP> if it weren't for that I'd be interested in trying to write a J -> Haskell w/ ndp compiler ;-)
03:06:08 <b_jonas> "w/ ndp"?
03:06:19 <quicksilver> natural data parallelism
03:06:32 <b_jonas> the impure nature of J would also make that a bit difficult, though that's less of an obstacle
03:06:34 <SamB_XP> well, perhaps it wouldn't really use the n
03:07:06 <b_jonas> otoh, the J interpreter is supposed to be quite fast (especially if you program it well)
03:07:09 <fax> what I pasted lets you enter some expressions
03:07:17 <b_jonas> so I don't think you really need to write a to-haskell compiler
03:07:17 <fax> and it displays in a simple form how they are parsed
03:09:17 <SamB_XP> so & is a bit like on...
03:12:29 <SamB_XP> okay, whoever decided to allow javascript programs to pick cursor shapes by number needs some hurting
03:12:50 <SamB_XP> whoever decided that Mozilla and IE would use different numberings needs even *more*
03:13:27 <SamB_XP> (or is that stylesheets?)
03:14:00 <puusorsa> "we at microsoft have always felt we can improve the standards!"
03:14:07 <fax> haha
03:15:12 <SamB_XP> no, wait
03:15:23 <SamB_XP> apparantly someone actually PICKED this cursor!
03:15:29 <SamB_XP> that's even worse than I thought
03:15:42 <SamB_XP> who the heck picks the "help" cursor for links?
03:15:51 <fax> 8 year olds
03:16:01 <SamB_XP> links having nothing whatsoever to do with help?
03:18:27 <SamB_XP> okay, that makes me want to have a way to have my browser ignore "cursor" properties for unqualified a:hover...
03:18:54 <SamB_XP> (i.e. with no particular class or parents)
03:19:36 <SamB_XP> I mean, really, I want the pointing pointer for links unless there's a specific reason not to have it...
03:20:20 <quicksilver> SamB_XP: that's what a user stylesheet is for
03:26:07 <SamB_XP> quicksilver: hmm. would that not override all CSS pointer properties?
03:26:23 <SamB_XP> or cursor, whatever...
03:26:35 <SamB_XP> yes, cursor...
03:29:54 <DRMacIver> Hm. qwewhatever has a blog?
03:34:35 <Syzygy-> Yo DRMacIver
03:36:21 <DRMacIver> Hi Syzygy-
03:36:23 <DRMacIver> What's up?
03:38:20 <Syzygy-> Well, at this time, the souther cross, I guess...
03:41:33 <ski> iguana_ : typically 'm' in 'MonadIO m' includes 'IO' somewhere inside it .. e.g. 'm a' could be 'StateT s IO a', i.e. essentially 's -> IO (a,s)' .. so one is then not ridden of the 'IO', just hidden
03:41:54 <ToRA> @paste
03:41:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:44:06 <hpaste>  ToRA pasted "Ghc crash..." at http://hpaste.org/2840
03:44:49 <cognominal_> in pqge 3 of a paper about fold, Graham hutton uses a section in th eleft side of a pattern:   (++ ys) = fold (:) ys       Is it supported in haskell?
03:44:53 <ToRA> hey, would with a ghc 6.6.1 + available see if the pasted crashes for them?
03:45:12 <ToRA> pretty please?
03:45:41 <mauke> ghc-6.6.1: panic! (the 'impossible' happened)
03:45:41 <mauke>   (GHC version 6.6.1 for i386-unknown-linux):
03:45:41 <mauke> 	splitFunTy b{tv aGo} [sk]
03:45:46 <quicksilver> cognominal_: I don't think that's a pattern
03:45:57 <mauke> oh, +
03:45:59 <quicksilver> cognominal_: I think he's doing equational reasoning?
03:46:05 <tibbe> how are the SoC projects coming along? escpecially the ByteString parsec?
03:46:32 <cognominal_> quicksilver, indeed. thx
03:46:47 <ToRA> mauke: stil useful - i'm running 64 bit
03:47:10 <ToRA> mauke: ta
03:47:50 <quicksilver> ToRA: me too : ghc-6.6.1: panic! (the 'impossible' happened)
03:47:51 <quicksilver>   (GHC version 6.6.1 for i386-apple-darwin):
03:47:51 <quicksilver> 	splitFunTy b{tv a2jjS} [sk]
03:48:29 <quicksilver> ToRA: but aren't associated types basically known to be broken, in 6.6?
03:48:42 <ToRA> that's not AT
03:48:45 <ToRA> that's GADT
03:48:52 <quicksilver> oh yes
03:49:01 <ToRA> i don't know if they're known to be broken or not
04:17:38 <hpaste>  loki annotated "random number generator" with "random number generator (hangs run in time)" at http://hpaste.org/2837#a1
04:17:52 <lokik> hey
04:18:01 <lokik> yea, it hangs at runtime
04:18:05 <lokik> and i have no idea why
04:18:18 <hpaste>  loki annotated "random number generator" with "random number generator (hangs in run time)" at http://hpaste.org/2837#a2
04:18:33 <lokik> added a few lines of code.. 18 in total with comments
04:19:57 <lokik> anyone here?
04:21:01 <tibbe> lokik: yes
04:21:16 * pjd points at the user list
04:21:38 <Lemmih> lokik: This looks a bit weird: loseKARbipa = cunkArbipa loseKARbipa loveKARbi
04:21:50 <lokik> .ua discovery
04:22:51 <lokik> hmmm
04:22:52 <Lemmih> lokik: 'a = f a b' can easily loop forever.
04:22:55 <Botje> did hpaste just fall down?
04:23:05 <lokik> yes i fixed it up
04:23:06 <lokik> :-)
04:23:10 <lokik> thanks
04:24:29 <lokik> is there any way to pass binary instead of hex
04:24:43 <lokik> i'm not sure what bits it's seeing
04:26:02 <lokik> like if it's using bytes that would be tragically inaccurate
04:26:45 <lokik> hmmm
04:26:48 <lokik> *thinks*
04:27:20 <lokik> guess it was the simple version of the random number generator that's the real one..
04:27:55 <lokik> can't use more than 2 bits :|
04:28:03 <Botje> lokik: surely that code is a joke?
04:28:19 <lokik> it's the annotation, the previous one is the real one
04:28:36 <lokik> here one sec i'll post up fixed code
04:28:47 <Botje> those variable names make no sense to someone who doesn't know those words
04:29:49 <lokik> it's LOJban makes much more sense than single letter variable names
04:30:00 <Botje> except if you don't know lojban
04:30:28 <Botje> it's very easy to lose track of things if variable names are in another language
04:30:29 <lokik> well then you could think of them as single letter variable names
04:31:04 <arcatan> why hpaste.org is so slow, btw?
04:31:26 <Botje> no idea
04:39:46 <vali> does anyone know where i can find an example of a simple genetic algorithm written in haskell?
04:43:54 <quicksilver> I don't generally associate 'simple' with 'genetic algorithm'
04:44:53 <lokik> > complement 0x1
04:44:54 <lambdabot>  Add a type signature
04:45:02 <lokik> > complement 0x1::Int
04:45:03 <lambdabot>  -2
04:45:13 <lokik> > complement 0x14::Int
04:45:15 <lambdabot>  -21
04:45:30 <lokik> > complement 20::Int
04:45:32 <lambdabot>  -21
04:45:54 <lokik> so basically doesn't do anything
04:45:59 <lokik> hmmm
04:46:13 <quicksilver> ?
04:46:17 <quicksilver> what do you mean?
04:46:20 <quicksilver> it
04:46:31 <quicksilver> it gives the ones-complement
04:46:35 <quicksilver> like it says on the tin :)
04:47:41 <lokik> yea, but it doesn't generate unpredictable numbers
04:47:47 <lokik> so doesn't help with adding complexity
04:47:53 <quicksilver> no, of course not
04:48:00 <quicksilver> complement isn't supposed to be unpredicatable
04:48:07 <lokik> so wouldn't be useful in a random number generator
04:48:11 <quicksilver> complement turns all 0s to 1s and 1s to 0s
04:48:18 <quicksilver> that's about as predictable as you can get :)
04:48:49 <doserj> every function is predictable in haskell...
04:49:22 <hpaste>  loki annotated "random number generator" with "random number generator (complete)" at http://hpaste.org/2837#a3
04:49:40 <lokik> probably should add some comments
04:50:20 <lokik> basically rocunkArbi ::Int ::Int   generates a tuple with random numbers
04:52:35 <quicksilver> lokik: traditional approaches to pseudo-random number generation normally involve modulus multiplication
04:52:48 <lokik> well this is bitwise
04:53:02 <lokik> xard-kor
04:53:03 <quicksilver> lokik: arguably the most important thing is that your hidden 'random state' contains many many more bits than the numbers you are drawing from it
04:53:28 <quicksilver> so if you're producing 32 bit ints, you normally want a >128 bit state
04:53:45 <quicksilver> it's not really an area I know much about, but there is plenty written on the subject
04:54:32 <lokik> yea
04:55:02 <doserj> I don't see what the code has to do with random numbers. It just returns the bitwise and and the bitwise or
04:55:17 <lokik> it's for making random number generator for making states,  or producing new states from already created ones
04:55:46 <lokik> doserj: that's the only 2 functions that really produce anything unpredictable
04:55:58 <doserj> ?
04:56:09 <lokik> the only other function is negation
04:56:44 <lokik> negation + or + and = turing complete
04:57:08 <doserj> not really
04:57:29 <dcoutts> tibbe: ask xerox about the ByteString parsec
04:57:52 <quicksilver> lokik: not turing complete no. Complete for bitwise arithmetic, yes.
04:57:56 <doserj> I guess I don't understand what you are trying to do (I hope you do...)
04:58:02 <tibbe> dcoutts: ok, thanks
04:58:06 <tibbe> xerox: ping
04:58:16 <quicksilver> lokik: and, of course, not at all unpredictable
04:58:23 <dcoutts> @seen P_D
04:58:24 <lambdabot> I saw P_D leaving #haskell 5h 52m 1s ago, and .
04:59:03 <lokik> its very unpredictable actually
04:59:12 <lokik> in comparison to negation
04:59:19 <lokik> at least
04:59:35 <quicksilver> ?
04:59:46 <lokik> complete for bitwise arithmetic is complete for all math
04:59:55 <lokik> all math can be expressed in binary
05:00:12 <lokik> using bitwise operations
05:00:19 <quicksilver> lokik: "turing complete" means capable of expressing any algorithm
05:00:26 <lokik> yes precisely
05:00:33 <quicksilver> you need a looping construct or a recursion construct for that
05:00:47 <doserj> lokik: there is no bitwise operator that enlarges the number of bits...
05:01:17 <quicksilver> > 1 .|. 8
05:01:25 <lambdabot>  Add a type signature
05:01:31 <lokik> hmmm
05:01:32 <quicksilver> > 1 .|. 8 :: Int
05:01:35 <lambdabot>  9
05:01:46 <quicksilver> lokik: I don't really know what you mean by unpredictable. 1 OR 8 will always be 9 :)
05:01:48 <tibbe> @seen xerox
05:01:49 <lambdabot> xerox is in ##logic, #haskell-overflow, #haskell-blah, #haskell and #ghc. I last heard xerox speak 16h 28m 56s ago.
05:01:52 <quicksilver> lokik: that's pretty predictable
05:02:06 <lokik> > 1487 .|. 1749
05:02:07 <lambdabot>  Add a type signature
05:02:16 <lokik> > 1487::Int .|. 1749::Int
05:02:17 <lambdabot>  Parse error
05:02:26 <lokik> > 1487 :: Int .|. 1749 :: Int
05:02:26 <lambdabot>  Parse error
05:02:33 <lokik> > 1487  .|. 1749 :: Int
05:02:35 <lambdabot>  2015
05:02:46 <lokik> > 1487  .&. 1749 :: Int
05:02:47 <lambdabot>  1221
05:03:23 <lokik> well, while it is a deterministic process, it is not predictable without previous knowledge
05:03:38 <lokik> or calculation
05:03:43 <quicksilver> much like '+', then?
05:03:46 <quicksilver> or '*' ?
05:03:47 <quicksilver> ;)
05:04:00 <lokik> yep, but those are combinations or bitwise functions
05:04:13 <lokik> right?
05:04:17 <doserj> so everything nonconstant is unpredictable?
05:04:43 <lokik> well negation is predictable
05:05:13 * iguana_ is confused
05:05:26 <lokik> i made an unpredictable statement :-)
05:05:35 <lokik> as i did not negate
05:06:02 <iguana_> why is the outcome of -x more predictable than that of x+1 ?
05:06:44 <lokik> when will asks "why?", will stops, and does naught
05:07:01 <iguana_> in other words, you don't have an answer?
05:07:10 <lokik> why is an illusion
05:07:39 <lokik> any non predictable reason is good enough
05:07:39 <iguana_> ok, this is beyond my threshold of rational reasoning
05:08:30 <lokik> it's not rational, as rational is finite, therby halting, therby mortal
05:08:55 <lokik> non-deterministic, therby irrational, therby non-halting, therby immortal
05:10:02 <lokik> non-deterministic machines theoretically allow for an infinite possiblity of things
05:10:10 <lokik> hmmm
05:10:20 <lokik> can solve any problem in linear time
05:10:34 <iguana_> sure, and they will find a proof of god's existence
05:10:46 <lokik> http://tcana.info
05:10:56 <lambdabot> Title: la.ma'aSELtcan.: The We with You Network
05:13:18 <iguana_> anyone can suggest a good book to get that crap out of my mind again?
05:22:18 <tibbe> I so wish ByteString was just called Bytes so people don't use them for unicode strings, and in my imaginary word we wouldn't have the String = [Char] typedef and String would be a unicode layer on top of Bytes
05:22:58 <dcoutts> tibbe: we're planning to add unicode variant of bytestring, though called something else obviously
05:23:06 <quicksilver> tibbe: well ByteString is, IMO, obviously not to be used for unicode strings
05:23:16 <quicksilver> tibbe: the word 'Byte' kind of gives it away
05:23:19 <dcoutts> that should reduce the tendency to use ByteString for text strings
05:23:42 <quicksilver> tibbe: however, getting rid of String = [Char] doesn't sound like a good idea to me
05:23:57 <quicksilver> tibbe: lists are haskell's way of representing iteration and suchlike
05:24:05 <dcoutts> though of course ByteString is perfectly ok for when dealing with bytes that we'll eventually convert into a unicode string of some sort
05:24:16 <dcoutts> eg read a file as a ByteString, decode it into a unicode string
05:24:39 <quicksilver> dcoutts: right; but being scrupulously precise, when they're in the ByteString they're still encoded
05:24:40 <dcoutts> String = [Char] is ok from a unicode point of view
05:24:54 <dcoutts> it's readFile :: FilePath -> IO String that's evil
05:24:58 <tibbe> quicksilver: but the String suffix is kinda redundant :)
05:25:03 <dcoutts> since the result is really [Word8]
05:25:14 <dcoutts> tibbe: it's a string of bytes!
05:25:18 <quicksilver> tibbe: no; it's a string of bytes
05:25:29 <dcoutts> rather than a string of chars
05:25:43 <quicksilver> dcoutts: yes. Also the putChar which actually puts bytes, etc etc
05:25:45 <tibbe> dcoutts: or a sequences of bytes or something :)
05:25:59 <quicksilver> dcoutts: various regrettable names in System.IO :(
05:26:04 <dcoutts> aye
05:26:13 <quicksilver> well not just names, but types too
05:26:15 <quicksilver> types which lie!
05:26:29 <tibbe> I recently had a look at the bytes/str separation Python doing in Python 3000 and it looked very nice and clean to me
05:26:38 <quicksilver> there is, of course, Data.CompactString
05:26:49 <quicksilver> dcoutts: does Data.CompactString take a sensible approach?
05:26:59 <dcoutts> quicksilver: I don't know it well
05:27:00 <tibbe> but that typedef just hogs that name without giving anything back!
05:27:25 <quicksilver> dcoutts: it layers an 'Encoding' phantom over a ByteString
05:27:27 <tibbe> my more realistic suggestion would be to call the unicode layer UniString or something
05:27:42 <dcoutts> tibbe: yes, I think the bytes vs unicode string separation is a good one, as I say, eventually we'll get a unicode bytestring style module
05:27:43 <quicksilver> dcoutts: and has well behaved accessors which en/decode correctly
05:27:54 <quicksilver> tibbe: CompactString is more general, in principle
05:28:06 <quicksilver> tibbe: it admits the notion that there could be a bunch of byte encodings
05:28:17 <tibbe> quicksilver: I haven't looked at it, in what way?
05:28:22 <dcoutts> quicksilver: hmm, so what's the type of head then?
05:28:24 <quicksilver> tibbe: you just choose which one, as in CompactString UTF8, or CompactString ISO88591
05:28:36 <quicksilver> head :: Encoding a => CompactString a -> Char
05:28:38 <tibbe> right
05:28:41 <dcoutts> ok
05:28:46 <dcoutts> sounds slow :-)
05:28:50 <tibbe> but I rather not mix the concepts of encodings and representation
05:29:09 <tibbe> i.e. an unicode ADT with operations and encode/decode pair of functions
05:29:23 <quicksilver> 'unicode'?
05:29:23 <tibbe> encode :: UniString -> ByteString
05:29:25 <quicksilver> what do you mean?
05:29:28 <quicksilver> UTF8?
05:29:30 <tibbe> no
05:29:33 <tibbe> unicode code points
05:29:34 <dcoutts> btw, I've got a new iconv package that does encoding conversion between lazy bytestrings
05:29:40 <quicksilver> tibbe: ok, well that's what [Char[ is
05:29:43 <tibbe> which is a conceptual entitity
05:29:47 <quicksilver> [Char] is unicode code points
05:29:54 <tibbe> quicksilver: right but too slow
05:30:23 <quicksilver> tibbe: well then you, I suppose, use CompactString UCS32
05:30:27 <tibbe> let me see if I can link the python PEP
05:30:46 <tibbe> but I don't like the conceptual mixup of encodings and unicode strings
05:30:57 <dcoutts> the point is I think, that you should be able to have a unicod string adt that doesn't tell you how it's encoded internally
05:31:10 <dcoutts> it just gives to access to the sequence of unicode code points
05:31:12 <quicksilver> dcoutts: that is [Char], surely
05:31:12 <tibbe> I have an UnicodeString not an CompactString UCS32, that's just an implementation detail
05:31:23 <dcoutts> quicksilver: that's one implementation, sure
05:31:26 <tibbe> dcoutts: exactly
05:31:32 <quicksilver> dcoutts: it's not really an implementaiton, though
05:31:36 <quicksilver> dcoutts: it's an *interface*
05:31:37 <quicksilver> :)
05:31:44 <tibbe> so Java uses UTF16 internally I think
05:31:45 <quicksilver> assuming fusion works correctly
05:31:47 <tibbe> some use UTF8
05:31:52 <dcoutts> in this case it's both since [Char] isn't very abstract
05:31:57 <tibbe> implementation detail you might want to change
05:32:04 <quicksilver> dcoutts: well it's a very simple interface
05:32:15 <quicksilver> dcoutts: since all it supports is efficient sequential traversal
05:32:20 <quicksilver> dcoutts: and nothing else at all
05:32:25 <quicksilver> dcoutts: still, that's good enough a lot of the time
05:32:33 <dcoutts> right
05:33:12 <quicksilver> I don't think I grasp tibbe's objection, really
05:33:15 <dcoutts> so then UnicodeString would provide functions for decoding into various standard unicode encodings of which one would be O(1) and the others O(n)
05:33:37 <tibbe> yes
05:33:52 <tibbe> in particular UTF8 might be O(1) if that's the internal encoding
05:33:53 <dcoutts> and from there you could use iconv or something to get latin1, or ascii or whatever
05:33:57 <dcoutts> tibbe: right
05:35:05 <dcoutts> or there could be multiple implementations with different internal encodings, for some special cases where people are working with one encoding a lot and so want to minimise conversion costs, eg utf16, 32
05:35:08 <quicksilver> I think I prefer the simple API of CompactString
05:35:14 <tibbe> in a unicode library functions like index, length, isSpace etc would just work
05:35:14 <quicksilver> no need for a seperate iconv setp
05:35:29 <dcoutts> quicksilver: you need iconv for CompactString anyway
05:35:29 <quicksilver> recode_ :: (Encoding a, Encoding b) => CompactString a -> CompactString b
05:35:36 <dcoutts> if you want more than a few encodings
05:35:37 <tibbe> the interaction with the IO library is also very important
05:35:39 <quicksilver> dcoutts: no, it's just recode, and it's magic
05:35:44 <quicksilver> dcoutts: all in the types :)
05:35:51 <tibbe> either you read Bytes or you specify an encoding and read UniString
05:36:08 <dcoutts> quicksilver: but you need to provide Encoding instances for all the encodings you'd ever want
05:36:17 <dcoutts> quicksilver: iconv provides dozens and dozens
05:36:22 <quicksilver> dcoutts: true
05:36:27 <quicksilver> dcoutts: seems more elegant though
05:36:30 <dcoutts> and implemented very fast
05:36:39 <dcoutts> quicksilver: it could be used internally
05:36:43 <quicksilver> dcoutts: of course your Encoding instance can just call iconv via the FFI if it wants :)
05:37:00 <dcoutts> quicksilver: not via the ffi! via my iconv package :-)
05:37:07 <quicksilver> ah yes
05:37:09 <dcoutts> iconv is actually a bit of a pain of an api
05:37:10 <quicksilver> even better :)
05:37:21 <dcoutts> which my package smooths out
05:37:35 <dcoutts> convert :: EncodingName -> EncodingName -> Lazy.ByteString -> Lazy.ByteString
05:37:44 <dcoutts> nice and simple
05:37:46 <quicksilver> tibbe: don't really understand your object to CompactString
05:37:53 <quicksilver> tibbe: it seems to me like a nice API
05:38:05 <quicksilver> if you don't care about performance (99% of the time) just use [Char]
05:38:14 <quicksilver> and if you do care, choose the encoding you believe is efficient
05:38:43 <dcoutts> quicksilver: I think the point is, we should use Unicode as the default and others only on the edges when conversing with other systems
05:39:07 <quicksilver> dcoutts: we do use Unicode as the default, don't we?
05:39:11 <tibbe> quicksilver: case in point is writing the web framework I want to write, I can't chose String since then if chosen an inefficient representation for all clients that can't be rolled back
05:39:15 <quicksilver> dcoutts: we just have broken edge-cases
05:39:18 <dcoutts> quicksilver: but which encoding? :-)
05:39:48 <dcoutts> quicksilver: I write a module using CompactString UTF8 and you write one using CompactString UTF16 and now we can't use them together without converting
05:39:55 <tibbe> Strings should always be unicode expect at the edges as dcoutts says, otherwise you have a huge i18n mess
05:40:07 <dcoutts> quicksilver: by pushing the encoding information too far into the middle of the program we encourage incompatibility
05:40:34 <quicksilver> dcoutts: surely you write your module polymoprhically over Encoding a => CompactString a
05:40:36 <tibbe> that's what I learned from working here at least, we support 40 languages, everything must be unicode all the time or you're screwed
05:40:44 <quicksilver> dcoutts: unless you have some very good reason to care which encoding it uses
05:40:55 <tibbe> and having different encodings floating around is a PITA
05:40:55 <dcoutts> quicksilver: no, because you don't even know that it's unicode then!
05:41:10 <quicksilver> dcoutts: you know that it "supports" unicode
05:41:18 <dcoutts> quicksilver: CompactString ASCII is fundamentally different than CompactString UTF8
05:41:20 <quicksilver> dcoutts: you know that client modules can give it unicode compactstrings and it will work
05:41:30 <quicksilver> dcoutts: yes, so your module supports both; it doesn't care...
05:41:46 <dcoutts> quicksilver: not if my module expects to use unicode properties
05:42:04 <quicksilver> dcoutts: the unicode properties are still supported on CompactString ASCII
05:42:07 <tibbe> http://python.org/dev/peps/pep-3116/
05:42:09 <lambdabot> Title: PEP 3116 -- New I/O
05:42:13 <tibbe> that's the new python IO system
05:42:14 <quicksilver> dcoutts: it still produces 'Char' when you unpack
05:42:24 <tibbe> they're moving from there strings being bytes to unicode ADT
05:42:25 <quicksilver> dcoutts: (index, etc)
05:42:30 <tibbe> and added a bytes type
05:42:34 <dcoutts> quicksilver: but it maps many Char's to the same Char when you use ASCII
05:42:41 <dcoutts> that's an easily observable property
05:42:59 <quicksilver> dcoutts: true; but that's the callers's fault for supplying you with a CompactString ASCII, surely?
05:43:01 * pjd writes an applicative functor mini-tutorial: http://programming.reddit.com/info/2rqdr/comments/c2rzuj
05:43:02 <lambdabot> Title: Haskell and the South African Computer Olympiad (reddit.com)
05:43:11 <quicksilver> dcoutts: this seems like what polymorphism is for...
05:43:31 <dcoutts> quicksilver: no, it's my fault for saying I can accept any string encoding when I actually need to know at least what character set I'm using
05:43:32 <tibbe> http://www.python.org/dev/peps/pep-0332/
05:43:34 <lambdabot> Title: PEP 332 -- Byte vectors and String/Unicode Unification
05:43:44 <dcoutts> it's making a promise I can't keep
05:43:51 <quicksilver> dcoutts: my claim is that most modules *wouldn't* need to know which character set they're using
05:43:52 <dcoutts> so I can't be polymorphic in the Encoding
05:44:01 <dcoutts> quicksilver: we're confusing Encoding and CharacterSet
05:44:10 <quicksilver> that's true
05:44:16 <tibbe> but surely we don't people to specify their favorite enconding in their API!?!
05:44:16 <quicksilver> although the two are related
05:44:21 <dcoutts> quicksilver: you don't need to know the Encoding, you often need to know the CharacterSet
05:44:33 <quicksilver> dcoutts: yes. That can be supported as a typeclass too, though
05:44:39 <dcoutts> and the default CharacterSet is Unicode
05:44:56 <quicksilver> (Encoding a, SupportsUmlauts a) => dcoutts_cool_fun :: CompactString a
05:45:09 <dcoutts> and the internal encoding of that is unimportant (except for performance)
05:45:15 <quicksilver> for the (IMO rare) occasion when you write a library which cares
05:45:18 <dcoutts> hence UnicodeString, with not type paramater
05:45:37 <quicksilver> tibbe: I'm not sure how relevant the python thing is
05:45:49 <quicksilver> tibbe: we have different problems
05:45:58 <mauke> re
05:45:59 <quicksilver> tibbe: haskell has *always* had unicode as its core type
05:46:03 <tibbe> quicksilver: I think most languages, Java, Python, etc end up doing the same things regarding unicode
05:46:12 <quicksilver> tibbe: there are two key problems with haskell/unicode
05:46:15 <quicksilver> and they're totally separate
05:46:20 <tibbe> quicksilver: as Chars yes but ByteString no
05:46:26 <quicksilver> (1) is [Char] too slow?
05:46:29 <tibbe> yes
05:46:32 <tibbe> and big
05:46:34 <quicksilver> (2) all the System.IO functions have the wrong types
05:46:39 <tibbe> yes
05:46:41 <dcoutts> quicksilver: though as you know we too often misuse String as if it were [Word8]
05:46:46 <dcoutts> especially for IO
05:46:49 <quicksilver> right
05:46:51 <quicksilver> that's my (2)
05:46:57 <quicksilver> these 2 are separate problems
05:47:04 <quicksilver> and I really don't thinkt hey're the same as the python problems
05:47:06 <tibbe> so the unicode string representation must interact with the IO API
05:47:40 <quicksilver> dcoutts: maybe you just want type UnicodeString = CompactString UCS32 ?
05:47:49 <tibbe> as I see it ByteString is Python's 'bytes' type, String is their new unicode string type
05:47:58 <quicksilver> dcoutts: but I *still* think it's more elegant to have polymorphism in encoding
05:48:01 <tibbe> we need one fast UnicodeString type
05:48:18 <tibbe> we don't have polymorphism in the encoding of Char!
05:48:19 <dcoutts> tibbe: I agree
05:48:24 <mauke> why do you have the encoding in the type?
05:48:27 <dcoutts> I think the python issue is relevant to us
05:48:37 <tibbe> I think Char is ISO something or other, probably 8859-1
05:48:50 <quicksilver> tibbe: Char is Unicode code point
05:49:03 <dcoutts> yes, Char is Unicode code point. It's specified as such in Haskell98 spec.
05:49:17 <tibbe> quicksilver: so do you think, if it was possible that Char should have an Encoding type param?
05:49:26 <quicksilver> tibbe: it "appears" to be a bit like 8859-1 in the sense that the system IO functions truncate all but the lower 8 bits
05:49:37 <quicksilver> and the lower 8 bits of unicode code points bear a striking resemblance to 8859-1
05:49:46 <tibbe> i.e. isAlpha :: (Encoding e) => Char e -> Bool ?
05:49:52 <quicksilver> no, I don't
05:49:55 <quicksilver> I think Char is just fine as it is
05:50:12 <dcoutts> tibbe: no, it'd be: isAlpha :: (CharacterSet c) => Char c -> Bool ?
05:50:12 <quicksilver> maybe the correct thing is:
05:50:19 <dcoutts> tibbe: Char has no 'encoding' at all
05:50:21 <tibbe> quicksilver: but why do you want an encoding type parameter for the ByteString version then?
05:50:32 <quicksilver> type FastUnicodeString = CompactString W_char_32
05:50:57 <quicksilver> tibbe: because, if you're asking the system to store your string efficiently in bytes, you need to think about which encoding you use to map chars to bytes
05:51:22 <mauke> pfft, that's the system's job
05:51:27 <mauke> I don't want to think :(
05:51:27 <tibbe> quicksilver: right so you can use CompactString as the implementation and have everyone use FastUnicodeString, but if someone uses something else the interfaces get incompatible or at least complicated to use
05:51:28 <quicksilver> tibbe: this is important because in many of the times we need to store strings efficiently / copy them fast it's to communicate with outside things
05:51:43 <quicksilver> so we have to choose the right encoding
05:51:43 <dcoutts> quicksilver: head :: Encoding e => CompactString e -> Char  isn't really true.
05:51:53 <quicksilver> dcoutts: why not?
05:51:53 <tibbe> quicksilver: I want a simple and fast enough interface
05:51:55 <dcoutts> quicksilver: unless we assume that all encodings can map into Unicode
05:52:04 <ddarius> AH?
05:52:05 <quicksilver> dcoutts: right. we do assume that.
05:52:11 <dcoutts> quicksilver: and even if then can, the reverse fails...
05:52:17 <quicksilver> dcoutts: well yes, of course.
05:52:24 <dcoutts> quicksilver: cons :: Encoding e => CompactString e -> Char -> CompactString e
05:52:25 <quicksilver> dcoutts: that is the danger of choosing your encoding, certainly.
05:52:34 <quicksilver> yes, cons can fail in principle
05:52:39 <dcoutts> especially if you're polymophic in the encoding
05:52:42 <quicksilver> no idea if twanvl's library fails in practice
05:52:47 <dcoutts> so have no idea what the charset actually is
05:53:10 <dcoutts> so Char there is the wrong type
05:53:18 <tibbe> if people use different internal representation then there's little point in adding a unicode layer in the first place since it will be a pain to use, like error handling. if everyone uses the same then supporting different encoding has little value
05:53:23 <quicksilver> tibbe: the problem is that you often wouldn't be able to use FastUnicodeString
05:53:24 <doserj> is there a need for a characterset other than Unicode?
05:53:24 <dcoutts> you really do what a CharSet c => Character c
05:53:41 <twanvl> If a character cannot be represented it would be a runtime error.
05:53:45 <tibbe> quicksilver: I'm not sure that's true, it is what all the Java guys are doing
05:53:46 <quicksilver> tibbe: because if you want to (e.g.) write to a HTTP client, you probably want UTF8
05:53:56 <tibbe> quicksilver: sure
05:53:57 <dcoutts> doserj: I don't think there is no, except for conversions on the edge for talking to external systems
05:54:09 <quicksilver> tibbe: erm sorry, I lost track there. Which thing don't you think is true?
05:54:16 <tibbe> so if you use the internal encoding the cost is O(1)
05:54:25 <doserj> dcoutts: you could just use Word8 there, couldn't you?
05:54:42 <quicksilver> well of course, Java uses BrokenMoronEncoding(TM), IIRC
05:54:47 <tibbe> quicksilver: that most people couldn't use the FastUnicodeString if we settled on one encoding but this is in fact what both Java and Python has done.
05:55:00 <dcoutts> doserj: right, for conversion into external encodings, you can just produce a sequence of bytes, like a ByteString
05:55:02 <quicksilver> Java uses something which resembles UTF16 but actually isn't
05:55:14 <tibbe> quicksilver: at least from a performance perspective they don't seem to have a problem
05:55:29 <quicksilver> indeed
05:55:36 <tibbe> quicksilver: I'm not a 100% sure what they do, I thought it was normal UTF16
05:55:43 <quicksilver> tibbe: it's not
05:55:46 <twanvl> The only thing that is expensive is converting a large string from one encoding to another
05:55:55 <quicksilver> tibbe: IIRC, UTF16 didn't exist when java was standardised
05:55:56 <dcoutts> iconv!
05:56:01 <tibbe> so choosing one enconding will at least not hurt performance too much
05:56:04 <quicksilver> tibbe: they made something up a bit like it, and got it wrong
05:56:31 <tibbe> so lets go back to the HTTP server example. it surely has to serve more than one encoding
05:56:37 <mauke> I think we need to make Char a record type
05:56:40 <tibbe> so you still have to do conversion anyway
05:56:48 <quicksilver> true
05:56:48 <dcoutts> tibbe: yes, it converts just before sending, using iconv :-)
05:56:56 <quicksilver> I think there are two separate needs here
05:56:58 <tibbe> dcoutts: exactly, which is good
05:57:05 <quicksilver> (A) Need for something fairly fast to store internally
05:57:12 <quicksilver> (B) need to support various encodings for input/output
05:57:17 <dcoutts> yep
05:57:28 <quicksilver> My claim is that CompactString is a step in the correct direction
05:57:32 <dcoutts> A is UnicodeString
05:57:37 <quicksilver> we just need to add a 'universal' encoding to CompactString
05:57:46 <quicksilver> what I was calling W_char_32
05:57:48 <tibbe> B is a nice I/O API
05:57:51 <dcoutts> B is conversions from UnicodeString to ByteString in various encodings/charsets
05:57:53 <quicksilver> (which is what GHC uses internall, I believe)
05:58:14 <quicksilver> because I don't think you *always* want to recode whole-sale
05:58:20 <quicksilver> if you're writing a UTF8-filter
05:58:22 <tibbe> hmmm, sounds like we need a wiki page :)
05:58:26 <quicksilver> you want to read UTF8 and write it
05:58:26 <dcoutts> converting to the internal encoding is O(n) anyway, since you need to validate the encoding
05:58:33 <quicksilver> so CompactString UTF8 is ideal
05:58:46 <twanvl> quicksilver: If you import Data.CompactString.UTF8 you get a single encoding
05:58:53 * quicksilver nods
05:58:53 <tibbe> so newtype UnicodeString = CompactString UTF8
05:59:13 <quicksilver> no, UTF8 is really daft as a general purpose encoding
05:59:18 <tibbe> right
05:59:19 <quicksilver> since it's non-uniform length
05:59:21 <doserj> no, UnicodeString = ByteString.Char
05:59:23 <tibbe> probably UTF16
05:59:31 <dcoutts> quicksilver: so is UTF16 non-uniform length
05:59:35 <quicksilver> dcoutts: right
05:59:38 <quicksilver> dcoutts: and it was IMO stupid
05:59:39 <dcoutts> only UTF-32 is uniform
05:59:39 <twanvl> uniform length is not that useful
05:59:45 <dcoutts> indeed
05:59:49 <quicksilver> twanvl: sure it is? O(1) indexing?
05:59:56 <dcoutts> note how we don't need indexing of String ?
05:59:58 <mauke> quicksilver: unicodepoint /= character
06:00:03 <quicksilver> mauke: I know
06:00:10 <mauke> so indexing is useless anyway
06:00:27 <dcoutts> yes, mostly
06:00:52 <dcoutts> so length is O(n) just like for String
06:01:27 * quicksilver ponders that
06:01:30 <dcoutts> almost all string processing is linear anyway
06:01:43 <tibbe> we definetly want a canonical UnicodeString though, so we can decode two ByteStrings of different encodings and compare them
06:02:01 <quicksilver> dcoutts: if it's linear we can hide this all under the carpet and just use [Char]
06:02:16 <quicksilver> dcoutts: and rely on fusion to keep us fast
06:02:17 <dcoutts> quicksilver: except for (large) constant factors
06:02:24 <tibbe> quicksilver: [Char] is 8 bytes or something to store
06:02:28 <dcoutts> in time and memory use
06:02:29 <mauke> the question is, do we want to use unicode?
06:02:31 <quicksilver> tibbe: not if it's never stored
06:02:38 <dcoutts> tibbe: 12 or 24 actually depending on arch
06:02:40 <quicksilver> tibbe: if the actual list never exists due to fusion
06:02:52 <tibbe> quicksilver: but sometime it is, and the locality of reference is not great if you don't get fusion
06:03:06 <tibbe> quicksilver: right, but that's not every operation
06:03:11 <dcoutts> quicksilver: text strings often do end up in memory, unlike many other lists used as control structures
06:03:28 <tibbe> that's /very/ true :)
06:03:29 <quicksilver> dcoutts: yes, and behind the scenes you have a bytestring, sure
06:03:35 <tibbe> quicksilver: yes
06:03:38 <quicksilver> dcoutts: so, behind the scenes its efficiently stored
06:03:47 <tibbe> quicksilver: in some encoding which your UnicodeString hides :)
06:03:59 <quicksilver> dcoutts: btu then the public API is [Char]
06:04:07 <quicksilver> dcoutts: and so the consumers of the data don't need to know
06:04:25 <dcoutts> quicksilver: you probably could get a long way with just pack/unpack
06:04:34 <dcoutts> it's not ideal though, imoh
06:04:51 <dcoutts> imoh/imho
06:04:54 <tibbe> if I read a whole file into memory I surely want it to be readFile :: FilePath -> Encoding -> UnicodeString if I'm going to do text processing on it
06:05:19 <dcoutts> yes, probably so
06:05:22 <mauke> I don't :(
06:05:32 <mauke> I want FilePath -> Encoding -> String
06:05:41 <quicksilver> dcoutts: I think you can get a long way with pack/unpack, and you can use a scheme like CompactString when that isn't far enough
06:05:42 <mauke> where String is something higher-level than unicode
06:06:06 <tibbe> all text processing must surely be done by a unicode string API and no encoding confusion must exist so the encoding must travel with the raw bytes
06:06:12 <dcoutts> the default H98 readFile should use the locale's encoding for text files
06:06:23 <dcoutts> so keep readFile :: FilePath -> IO String
06:06:29 <quicksilver> yes
06:06:42 <tibbe> dcoutts: no I need to be able to tell what encoding the file is in
06:06:52 <tibbe> because it might not be consistent in all files
06:06:54 <quicksilver> because String == [Char]s are (or can be) perfectly fast enough for linear access
06:06:59 <quicksilver> tibbe: he only means the default
06:07:00 <dcoutts> tibbe: we add convert :: Encoding -> ByteString -> UnicodeString
06:07:14 <mauke> s/convert/decode/
06:07:17 <tibbe> right
06:07:25 <dcoutts> tibbe: then you can:  decode UTF8 <$> B.readFile "foo"
06:07:36 <quicksilver> fromByteString_ :: Encoding a => ByteString -> CompactString a
06:07:44 <quicksilver> ^^ we already have it! :)
06:07:50 <mauke> dcoutts: what if I want to be able to catch decoding errors?
06:08:11 <mauke> quicksilver: that's broken; it puts the encoding in the result type
06:08:20 <tibbe> there are a few useful errors strategies you want to support
06:08:20 <dcoutts> mauke: by default you get exceptions, if you want more control use one of the conversion variants
06:08:21 <quicksilver> mauke: in CompactString, there is a version without a _ with reports errors
06:08:32 <tibbe> one is to replace illegal byte sequences with ????
06:08:33 <quicksilver> mauke: just use unpack . fromByteString_
06:08:40 <dcoutts> mauke: in my iconv lib I provide a convert, and some others that give full control over decoding errors
06:08:41 <quicksilver> mauke: that gives you back a String
06:08:55 <mauke> ok
06:09:02 <tibbe> I'll try to sumarize this in a wiki soon
06:09:06 <twanvl> mauke: Why do you consider puting the ecoding in the type to be broken?
06:09:11 <tibbe> I need to work :(
06:09:18 <tibbe> afk for a sec
06:09:22 <quicksilver> I think putting the encoding in the type is right at certain times
06:09:27 <quicksilver> it's right when you want that level of control
06:09:40 <quicksilver> but I agree with mauke that the more common case is taht you don't
06:09:46 <quicksilver> but then, I think unpack gives you the right interface
06:10:09 <mauke> well, you could just say data EncodedString a = Enc ByteString
06:10:15 <dcoutts> quicksilver: as a way of recording the encoding when converting it's ok, but not for internal processing imho
06:10:18 <mauke> i.e. a phantom type on top of bytestrings
06:10:26 <twanvl> Data.CompactString.UTF8.decode_ :: Encoding e => e -> ByteString -> CompactString?
06:10:38 <quicksilver> mauke: that is basically what CompactString does, yes
06:10:40 <dcoutts> quicksilver: so if it does not provide any access to the content, then it's ok, only for conversions
06:11:09 <quicksilver> dcoutts: you can 'forget' the encoding at any time with unpack
06:14:57 <Bacta> welcome to BactaBot ... For a list of commands type COMMANDS
06:15:19 <exDM69> 0.o
06:15:30 <nornagon> erm.
06:15:56 <fanf> hello
06:16:13 <fanf> wow, this chan is crowed :)
06:16:14 <ari> Pffft, it can't handle commands in privmsg
06:16:26 <tibbe> fanf: welcome
06:16:35 <quicksilver> dcoutts, tibbe: it would be great to have thhat in either a mailing list or wiki post
06:16:37 <fanf> hello tibbe
06:16:40 <quicksilver> there are some confusing issues there
06:16:41 <fanf> thank you
06:16:45 <tibbe> quicksilver: yes
06:16:50 <tibbe> fanf: :)
06:16:52 <quicksilver> ari: probably not registered to freenode
06:16:56 <Bacta> welcome to BactaBot ... For a list of commands type COMMANDS
06:17:29 <ari> quicksilver: No, it specifically told me "I'm sorry ... You must type that command in BactaBot's resident channel"
06:17:32 <mauke> COMMANDS
06:17:39 <tibbe> quicksilver: dcoutts: is there a possibility that a library writer at some point has to pick an arbitrary encoding (for storing something say)? that would spell trouble at API boundaries
06:17:40 <quicksilver> ari: weird
06:17:48 <Bacta> 1) To say Hello type HELLO
06:18:02 <Bacta> 2) To tell jokes about Freenodes founder type LULZ
06:18:05 <tibbe> polymorpic encoding requires that it is chosen exactly ones
06:18:15 <quicksilver> tibbe: well I think the most elegant solution would be to make it polymorphic
06:18:21 <quicksilver> where possible
06:18:31 <quicksilver> but the other solution is to find a 'universal' encoding and use that
06:18:42 <tibbe> quicksilver: so I'll write up my confused understanding of the issue and then you guys can correct me where I am wrong :)
06:18:45 <quicksilver> possibly you'd even make the universal encoding compiler-dependent
06:18:54 <quicksilver> so that a compiler could do whatever was fastest on that platform
06:19:14 <dcoutts> I think when you store externally you have to know and specify the format
06:19:20 <tibbe> but we agree on that we need a ByteString backed unicode type that carries the encoding with itself
06:19:21 <Bacta>    o           __/   |____  ---
06:19:21 <Bacta>   /L,         |__________|  ---
06:19:21 <Bacta> (o)/(o)        o       o    ---
06:19:21 <quicksilver> agreed
06:19:33 <tibbe> dcoutts: yes, at the boundaries you have to know
06:19:37 <ddarius> Is that thing going to keep talking unprompted?
06:19:39 <quicksilver> so that wouldn't be a format for external storage
06:19:47 <tibbe> dcoutts: inside your code you shouldn't have to care if you don't want to
06:19:49 <quicksilver> it would be only for fast processing
06:19:57 <dcoutts> tibbe: right
06:19:58 <quicksilver> if there are reasons to want to optimise that
06:20:51 <dcoutts> tibbe: and yes, it needs to know it's own encoding, we disagree over whether the encoding should be polymorphic or fixed as a universal unicode encoding
06:21:00 <tibbe> the I/O functions should either 1) Read raw ByteStrings 2) Force you to specify and encoding and read UnicodeString or 3) use some deafult like what in your locale or UTF-8 depending what is deamed appropriate
06:21:09 <tibbe> dcoutts: right
06:21:31 <tibbe> dcoutts: I could go with polymorphic if there's no possibility of API boundary problems
06:21:36 <dcoutts> tibbe: as for IO, yes, I agree.
06:21:59 <dcoutts> tibbe: but imho api boundary problems are exactly what we'll get with an encoding type parameter
06:22:01 <tibbe> dcoutts: I would also try to make it easy enough so people don't confused encodings and unicode code points, etc
06:22:10 <quicksilver> the advantage of polymorphic, is that, potentialy, it can avoid a recode
06:22:18 <tibbe> dcoutts: so I'm not 100% clear on that issue
06:22:32 <quicksilver> if you write your library polymorphic and it's convenient for someone to send you UTF8 they can, and your library will 'just work'
06:22:44 <pejo> Grr. Why do people repeat 5 pages of other papers before they start describing their own work?
06:22:44 <dcoutts> tibbe: yes, we need to not confuse encodings and charsets, they're different
06:22:47 <tibbe> dcoutts: it seems like we will have problems if someone has to pick an encoding at any point in an API
06:22:50 <quicksilver> whereas if you forced a universal encoding there would always be at least one recode
06:23:15 <dcoutts> tibbe: exactly, hence using a universal encoding
06:23:23 <quicksilver> pejo: because they need to make sure that busy reviewers who can't be bothered to reference chase understand the point of their paper :)
06:23:29 <tibbe> dcoutts: rights, depending if that possibility exists or not
06:23:41 <dcoutts> tibbe: just like we have a single String type, rather than dozens
06:24:01 <axm_> or maybe because chasing references was the most work for the paper?
06:24:04 <dcoutts> it makes apis much more reusable to have a single string type thought
06:24:09 <pejo> quicksilver, .. and instead they don't have room to describe their own work, which is supposed to be new and unheard of.
06:24:19 <tibbe> dcoutts: right, but if the String types encoding only could be set at encode/decode the same encoding would be carried through all the different libraries
06:24:41 <pejo> quicksilver, but of course you're right.
06:24:48 <dcoutts> tibbe: I've worked on C++ projects where there were 5 different string types in a single module and they all had to be painfully converted between
06:24:49 <tibbe> dcoutts: my gut feeling tells me that we need to settle for one but I'm open to evidence of the contrary
06:25:00 <pejo> dcoutts, talking about Mozilla?
06:25:02 <tibbe> dcoutts: right
06:25:10 <quicksilver> dcoutts: however we have type classes and polymorphism which means we can make these things automagic :)
06:25:13 <dcoutts> pejo: no, some proprietary thing I worked on when I had a real job
06:25:21 <quicksilver> dcoutts: we do have some advantages over less expressive languages...
06:25:22 <dcoutts> tibbe: i agree with your gut feeling :-)
06:26:14 <tibbe> quicksilver: right, what I'm not sure about is if all API functiosn will always be Encoding e => CompactString e or if there will be some Encoding IncompatibleWithYourEncoding
06:26:14 <dcoutts> quicksilver: yes, the conversions are a bit less painful, but still it doesn't encourage reuse to have too many incompatibilities that need patching over with conversion functions
06:26:42 <tibbe> as soon as you have one conversion function you lost the benefit of avoiding recoding
06:26:48 <quicksilver> yes, that's quite true
06:26:59 <quicksilver> however, some simple cases may work very well
06:27:00 <tibbe> so that would be criteria I think
06:27:10 <quicksilver> for example, an XML library may only care about <> and A-Z mostly
06:27:15 <quicksilver> which are in every encoding
06:27:25 <tibbe> true, it might work sometimes and sometimes not but in that case I prefer compatible APIs over a (may small) performance gain
06:27:27 <quicksilver> so you oculd feed your XML library UTF8 just as well as ASCII or UTF32
06:27:49 <tibbe> I'm not sure that performance gain will be big given that Java uses one encoding and doesn't appear to suffer any performance problems from it
06:28:21 <tibbe> quicksilver: but the types need to be coerced then right?
06:28:31 <quicksilver> no
06:28:46 <mauke> just make the universal type use different encodings internally
06:29:02 <mauke> with automatic conversion where required
06:29:03 <quicksilver> tibbe: Encoding a => decode_xml :: CompactString a -> XMLStructure (CompactString a)
06:29:09 <tibbe> so if I have to choose between incompatibles in some APIs and a small performance loss I go with the latter
06:29:40 <tibbe> cause API incompatibles might make the programmer's experience bad enough that the whole thing gets discarded in favor of String again
06:30:01 <quicksilver> that's probably a fair point
06:30:08 <quicksilver> and String is great :)
06:30:24 <tibbe> but I want concrete evidence for and against any solution
06:30:26 <quicksilver> many programs would work just perfectly with String, and fixed IO
06:30:27 <tibbe> show me the code! ;)
06:30:46 <tibbe> quicksilver: right but for those which don't we want a solution that works for all of them
06:31:42 <tibbe> but could functions like readNBytes return [Word8] and still be efficient? i.e. can you always fuse and get a ByteString instead?
06:32:50 <tibbe> quicksilver: where do I find the CompactString library?
06:32:58 <quicksilver> @where compactstring
06:32:59 <lambdabot> http://twan.home.fmf.nl/compact-string/
06:33:07 <dcoutts> quicksilver: an xml parser being polymorphic in the encoding will be considerably slower than one that uses a single encoding internally and converts just before lexing.
06:33:21 <tibbe> it needs to be on hackage!
06:33:46 <tibbe> dcoutts: right, needs to be taken into consideration although I don't like it
06:33:54 <quicksilver> dcoutts: it can do that and still be polymorphic, if it wants :)
06:34:00 <tibbe> dcoutts: can't we specialize the polymorphic function?
06:34:15 <dcoutts> quicksilver: yes, but only polymorphic in the external encoding conversion function
06:34:18 <quicksilver> dcoutts: either way it will be quite a bit faster than [Char]
06:34:22 <dcoutts> not in the internal string type itself
06:34:41 <dcoutts> see for example der_eq's typed encoding conversion lib
06:35:32 <tibbe> quicksilver: but if you decode you lose your performance gain right?
06:35:45 <tibbe> we want to keep it or the extra flexibilty is for nothing
06:35:50 <tibbe> we need benchmarks!
06:35:55 <dcoutts> and if you do many ops on a string where you don't statically know the encoding, it's slow
06:35:58 <tibbe> preferably small and unrealistic
06:36:06 <dcoutts> due to class dictionary dispatch overheads
06:36:39 <quicksilver> dcoutts: "you" == module write may not statically know
06:36:48 <quicksilver> dcoutts: but it remains possible that the compiler statically knows
06:37:16 <dcoutts> quicksilver: in which case it has to duplicate & specialise for each encoding or revert to passing dictionaries
06:37:22 <dcoutts> either way is not great
06:37:43 <quicksilver> dcoutts: well it might be inline & specialise
06:37:52 <quicksilver> dcoutts: that works very well
06:38:11 <tibbe> I really have to work now, I'll try to get this in a wiki
06:38:13 <quicksilver> dcoutts: anyhow, you're right that the motivation behind my suggestions is not performance
06:38:17 <dcoutts> for clawing back performance, yes, but at the expense of code duplication
06:38:20 <quicksilver> dcoutts: it's API elegant
06:38:56 <tibbe> if you know of any libraries/packages/examples that might be of relevance please email me at johan.tibell@gmail.com and I take them into consideration
06:39:00 <dcoutts> quicksilver: take a look at der_eq's conversion lib for another approach to an elegant api, but where it's only polymorphic in the conversions, not in the internal string type.
06:39:03 <quicksilver> dcoutts: obviously the notion of having some kind of bytestring-backed structure is for performance reasons :) but after that I have just been arguing for a cute API
06:39:10 <phobes> fmota:  posting python code to reddit?  tsk. tsk
06:39:51 <dcoutts> quicksilver: tibbe: see der_eq's encoding package:
06:39:51 <dcoutts> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/encoding-0.2
06:39:53 <tibbe> dcoutts: how does that conversion lib work? doesn't it carry around the encoding? or is it not in the type but in a data member?
06:39:53 <lambdabot> http://tinyurl.com/2esa9v
06:40:13 <tibbe> dcoutts: thanks
06:40:50 <quicksilver> dcoutts: hmm. No browsable haddock?
06:41:12 <dcoutts> quicksilver: seems no, not sure why, check the build log
06:41:35 <quicksilver> ghc-6.6: unrecognised flags: -I
06:41:40 <quicksilver> didn't get all that far :)
06:41:44 <doserj> class Encoding enc where encode :: enc -> String -> ByteString; decode :: enc -> ByteString -> String
06:41:46 <dcoutts> ah, that's a cabal bug since fixed
06:41:48 <doserj> is the main idea
06:42:49 <quicksilver> doserj: doesn't look very different from CompactString pack/unpack to me
06:43:03 <quicksilver> doserj: it simply chooses not to tag the result type...
06:43:03 <dcoutts> encode :: enc -> String -> [Word8]
06:43:04 <dcoutts> encode :: enc -> PackedString -> ByteString   for the faster data rep
06:43:13 <dcoutts> quicksilver: yes, that's crucial
06:43:21 <tibbe|work> gah, the List API is duplicated in 10123012043123 places
06:43:59 <quicksilver> dcoutts: simply because you view polymorphism as a run-time overhead because of dictionary passing?
06:44:38 <dcoutts> quicksilver: no, because then you add operations on that tagged string so it can be used as an internal string type
06:45:01 <quicksilver> dcoutts: but the string isn't tagged?
06:45:03 <dcoutts> where as ByteString holding some encoded string is very clearly an external representation for communicating with other systems
06:45:11 <dcoutts> quicksilver: the String is Unicode.
06:45:17 <quicksilver> right
06:45:25 <dcoutts> the [Word8] / ByteString is some external encoding
06:45:29 * quicksilver nods
06:45:37 <dcoutts> not to be treated as a string
06:45:49 <quicksilver> but it doesn't solve the speed issue
06:46:00 <quicksilver> that doesn't give you a "fast compact unicode string" ?
06:46:02 <dcoutts> if it was PackedString rather than String it would
06:46:11 <dcoutts> we're just missing the "fast compact unicode string" at the moment
06:46:13 * quicksilver nods
06:46:30 <dcoutts> but as soon as that exists, that's the obvious candidate for the speedy use case
06:47:19 <dcoutts> quicksilver: as I said, I think it'd be ok to tag the bunch of bytes with an encoding, as long as you don't provide any string operations on it
06:47:41 <dcoutts> so you convert to the UnicodeString type before treating it as a string
06:47:44 <quicksilver> hmm
06:47:54 <TuringTest> I added RZ's unsafeCoerce bug from the ghc-user's list to trac, http://hackage.haskell.org/trac/ghc/ticket/1724
06:47:55 <lambdabot> Title: #1724 (Type family and GADT error) - GHC - Trac
06:48:00 <quicksilver> you want to forbid "reasonably fast packed UTF8 operations" ?
06:48:03 <dcoutts> quicksilver: and if it happens that the encoding is the same it's O(1)
06:48:14 <TuringTest> I though type families were supposed to work well with GADTs now.
06:48:34 <TuringTest> I thought...
06:49:00 <dcoutts> quicksilver: I want to forbid string operations on external encodings, only allow them on a single common unicode string type
06:49:12 <quicksilver> hmm
06:49:31 <quicksilver> dcoutts: why? what if I'm writing a UTF8 stream filter? why can't I have my reasonably fast UTF8 operations?
06:49:59 <dcoutts> quicksilver: you can, if the internal UnicodeString rep happens to be UTF8
06:50:07 <quicksilver> but let's suppose it isn't
06:50:11 <dylan> utf8++
06:50:28 <quicksilver> CompactString UTF8 gives me pretty fast operations on natively UTF8 data
06:50:33 <dcoutts> quicksilver: but that's not a very common case really, that you're doing little to no work between taking a string in and shoving it out again
06:50:42 <quicksilver> that's true
06:50:48 <dcoutts> quicksilver: such that the cost of the operations is much less than the cost of conversion
06:51:27 <quicksilver> maybe you're right
06:51:32 <quicksilver> I can certainly see your point
06:51:39 <quicksilver> I just think twanvl's API is really elegant :)
06:51:46 <dcoutts> quicksilver: in theory a proper streaming op might fuse anyway
06:51:52 <quicksilver> that's true
06:52:03 <quicksilver> which takes us back to [Char] :)
06:52:10 <dcoutts> heh, true
06:52:38 <dcoutts> sed = interact (unpack . munge . pack)
06:52:44 <quicksilver> yes
06:52:46 <dcoutts> erm otherway around
06:52:51 <quicksilver> I knew what you meant
06:53:08 <quicksilver> actually I've often wanted a class for the 'pack/unpack' idiom
06:53:26 <quicksilver> class Conjugate a b where in :: a -> b ; out :: b -> a
06:53:33 <quicksilver> conj f = out . f . in
06:53:49 <phobes> I haven't tested lately, but the cache improvement of smaller UTF8 strings can be an advantage over word encodings
06:54:07 <phobes> (in terms of performance, even though the UTF manipulation code is more complex)
06:54:12 <quicksilver> the reason I've never done it is that "pack . munge . unpack" is actually more readable that "conj munge"
06:54:15 <quicksilver> ;)
06:54:48 <dcoutts> phobes: we should be able to benchmark implementations of the three utf encodings against each other to find out
06:54:57 <phobes> yup
06:55:06 <quicksilver> phobes: it can be even faster to store things compressed and decompress once they're inside the cache, I believe
06:55:10 <quicksilver> phobes: if you do it right :)
06:56:23 <phobes> quicksilver:  I could see that
06:56:59 <twanvl> A problem with utf>8 over bytestrings is that (as far as I know) there is no good way to align on word boundaries, if the string is (known to be) aligned it should improve performance.
06:57:12 <tibbe|work> um, how does compactstring work?
06:57:49 <tibbe|work> are only the encode/decode functions in the type class?
06:58:01 <doserj> yes
06:58:10 <twanvl> No, the type class contains some evil low level functions
06:58:17 <tibbe|work> how would someone write an index function then?
06:58:25 <tibbe|work> twanvl: right, it has to
06:58:53 <tibbe|work> twanvl: could see them in the haddock
06:59:04 <nominolo> @info Applicative
06:59:04 <lambdabot> (Applicative)
06:59:30 <doserj> ups, was confused with Data.Encoding...
07:01:03 <nominolo> @src IO (<*>)
07:01:03 <lambdabot> (<*>) = ap
07:03:05 <doserj> f <*> x = do f' <- f ; x' <- x ; return (f' x') -- for any monad
07:04:19 <nominolo> is there any specific reason why Parsec is no instance of Applicative?
07:04:35 <nominolo> or why there's no instance Monad m => Applicative m ?
07:04:37 <twanvl> Applicative was invented after parsec
07:04:58 <nominolo> sure
07:05:17 <nominolo> still, someone could have defined an instance in the libs
07:05:28 <twanvl> true
07:05:39 <nominolo> ie, in the version for hackage or sth
07:06:02 <twanvl> That instance is not allowed, it would mean that the compiler can always change "(Applicative f =>" to "Monad f =>" everywhere.
07:06:36 <quicksilver> twanvl: no, that's what it would mean if it occured in the *class* declaration
07:06:44 <quicksilver> twanvl: that's not what it means if you write a general instance
07:06:59 <mauke> needs overlapping instances
07:07:01 <quicksilver> nominolo: a problem with general instances is that they, by definition, overlap
07:07:18 <quicksilver> nominolo: since contexts are not taken into account when considering "overlap"
07:08:01 <quicksilver> nominolo: logically, anyway, there could be an Applicative context in the Monad definition. But there are practical problems with making the class hierarchy fine grained
07:08:26 <quicksilver> nominolo: same reason we don't force Monads to be Functors
07:08:29 <quicksilver> tis annoying though
07:08:31 <doserj> I want default definitions for superclass methods...
07:08:36 <twanvl> We should
07:08:49 <nominolo> is there some wiki page describing those problems?
07:09:30 <doserj> and definitions for superclass methods in instance declarations
07:09:43 <quicksilver> I'm sure there is something in the haskell-prime wiki
07:09:47 <quicksilver> let me see if I can find it
07:10:04 <nominolo> nah, i don't need to know right now
07:10:17 <nominolo> i'll look myself later
07:11:36 <quicksilver> http://repetae.net/john/recent/out/classalias.html
07:11:37 <lambdabot> Title: Class Alias Proposal for Haskell
07:11:52 <quicksilver> ^^ it's actually about class synonyms, but I think John goes through the main issues too
07:12:21 <twanvl> See also http://haskell.org/haskellwiki/Class_system_extension_proposal
07:12:22 <lambdabot> Title: Class system extension proposal - HaskellWiki
07:16:03 <quicksilver> nominolo: in particular, John's example of lattices shows the danger (in the current system) of a really fine-grained hierarchy
07:16:19 <Apocalisp> Anybody using yi on Windows?
07:16:41 <quicksilver> nominolo: when I say "danger" it's really just syntactic clutter/build-up
07:26:14 <nominolo> quicksilver, thanks. bookmarked
07:53:41 <paolin1> glguy your 62 solution is not checking that the number has exactly 5 good permutation
08:03:30 <glen_quagmire> let's say I'm calling function f x.   Is there a way to toggle x between True and False each time f x is called?
08:04:08 <malcolmw> let bools = cycle [False,True] in map f bools
08:04:50 <nominolo> let bools = modify not >> get in mapM bools
08:04:55 <nominolo> > let bools = modify not >> get in mapM bools
08:04:57 <lambdabot>  1:12-21
08:05:02 <glen_quagmire> :t cycle
08:05:04 <lambdabot> forall a. [a] -> [a]
08:05:26 <nominolo> > let bools = modify not >> get in execState (mapM bools) True
08:05:26 <lambdabot>  Couldn't match expected type `State s a'
08:05:35 <nominolo> :t execState
08:05:37 <lambdabot> forall s a. State s a -> s -> s
08:05:54 <glen_quagmire> let's say i'm in a language with no lazy evaluation nor variables
08:06:12 <quicksilver> glen_quagmire: I'd say in that case you're in the wrong channel? :)
08:06:12 <nominolo> > let bools = modify not >> get in evalState (mapM bools) True
08:06:13 <glen_quagmire> i mean, can a boolean logic store True|False state and toggle?
08:06:13 <lambdabot>  Couldn't match expected type `State s a'
08:06:16 <malcolmw> let bools = cycle [False,True]; f=not in map f bools
08:06:28 <malcolmw> > let bools = cycle [False,True]; f=not in map f bools
08:06:30 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
08:06:54 <quicksilver> glen_quagmire: not sure what "a boolean logic" means
08:06:59 <quicksilver> glen_quagmire: logics can't store anything
08:07:09 <quicksilver> glen_quagmire: a logic is a formal language with rewrite rules
08:07:31 <quicksilver> glen_quagmire: recursive programs can 'fake' storage by calling themselves with different argments, of course
08:07:35 <glen_quagmire> f (boolean expression here. using only And, Or, Not);
08:07:35 <quicksilver> hide the storage in the arguments
08:08:30 <quicksilver> glen_quagmire: if f is a function, then no, it can't store anything
08:08:36 <quicksilver> glen_quagmire: that is, of course, what function means :)
08:09:07 <glen_quagmire> i see
08:20:53 <paolin1> > let bools f = modify not >> get >>= return.f in evalState (replicateM 5 (bools id)) True
08:20:56 <lambdabot>  [False,True,False,True,False]
08:24:38 <twanvl> > take 5 $ iterate not False
08:24:40 <lambdabot>  [False,True,False,True,False]
08:32:36 <Apocalisp> setup.exe: can't find source for Yi.Boot in ["."]
08:33:05 <Apocalisp> Has anyone seen my Yi.Boot?
08:33:22 <quicksilver> Apocalisp: check behind the fridge
08:34:06 <Apocalisp> You don't see a behind there.
08:34:39 <Apocalisp> Exits are North, Up, and Yonder.
08:39:41 <byorgey> take fridge
08:40:01 <Apocalisp> You are now carrying the fridge.
08:40:02 <sebell> "It's too heavy!"
08:41:25 <byorgey> throw fridge at sebell
08:41:39 <sebell> "You are not carrying the fridge."
08:41:56 <byorgey> hehe =)
08:42:54 <byorgey> hmm, someone should make an EDSL for interactive fiction in Haskell
08:44:00 <quicksilver> interact (const "You can't do that")
08:45:19 <fax> I wanna see a IF made with Make :|
08:45:31 <fax> I should stop telling people and actually do it sometime..
08:49:07 * EvilTerran is reminded of PUTPBAD
08:50:22 <Apocalisp> What's wrong with Inform?
08:51:09 <osfameron> Inform has loveliness but also much hate
08:51:23 <osfameron> not that I've played with the new Logic programming version at all
08:51:26 <Apocalisp> Inform 7 has like a GUIness IDE and everything.
08:51:44 <Spark> can haskell's GL wrapper do anisotropic filtering?
08:51:55 <Apocalisp> How's SOE coming, osfameron?
08:52:20 <quicksilver> Spark: it can do everything GL can do, up to some version
08:52:29 <quicksilver> Spark: when was anisotropic filtering added to GL?
08:52:50 <osfameron> Apocalisp: not put mcuh time into it recently.  Thinking about a study break in November/December.  If I can afford it.
08:53:51 <mnislaih> hiya Lemmih
08:53:59 <Apocalisp> cool
08:54:10 <Lemmih> mnislaih: Indeed. (:
08:54:15 <Apocalisp> I'm currently working through Chapter 8.
08:54:57 <Apocalisp> It's quite mathy for a book whose author claims that traditional functional programming books have too much math.
08:56:35 <Apocalisp> Chapter 8 also has some annoying errors in it.
08:57:17 <Lemmih> mnislaih: I was fearing you had vanished just before the ICFP.
08:57:29 <mrd> bos: enjoying the feedback?
08:57:43 <bos> apart from getting screwed my mysql, yes.
08:57:50 <mnislaih> actually, I just checked my trip details  and booked the train Frankfurt-Freiburg this morning Lemmih :)
08:57:50 <mrd> mysql == :(
08:57:53 <bos> getting screwed by, that is.
08:58:01 <Spark> quicksilver: ToRA found it
08:58:05 <Apocalisp> why use mysql?
08:58:20 <bos> its default encoding for text is swedish, and its default collation is case insensitive. wtf?
08:58:37 <travisbrady> <newb>does anyone have pointers for printing a [IO [String]]
08:58:56 <mrd> travisbrady: you want to run the IO actions? use sequence
08:58:58 <bos> Apocalisp: it was already installed on the server i was using?
08:59:10 <Apocalisp> I don't know.
08:59:18 <pejo> bos, you never know when you need åäö!
08:59:20 <EvilTerran> ?typ sequence
08:59:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:59:34 <bos> pejo: that's why god gave us utf-8 :-)
08:59:50 <mrd> mysql is widely installed and even more widely reviled
08:59:58 <Apocalisp> hah
09:00:13 <pejo> bos, hm? We've had those letters for quite some time.
09:00:36 <bos> pejo: yes, but with utf-8, i get to represent other letters too. it's the new thing!
09:00:55 <pejo> bos, oh. We liked SWASCII too though!
09:03:19 <bos> holy mother of wow. we've already had 357 comments!
09:03:23 <gattocarlo> Am I the only one experiencing lost messages with the mailing list?
09:03:26 <bos> in 9 hours!
09:04:21 <Apocalisp> Wow, Inform 7 is quite impressive.
09:05:52 <gattocarlo> bos: comments to what?
09:05:56 <paolin1> is it possible to implement takeWhile with a do  ?
09:06:35 <sjanssen> paolin1: sure, you could use a monad somewhere.  Perhaps Writer?
09:06:40 <bos> gattocarlo: the book
09:07:09 <paolin1> sjanssen: not the list one ?
09:07:34 <travisbrady> mrd: could you post a brief example? i'm struggling
09:07:34 <sjanssen> paolin1: hmm, I don't think takeWhile fits the list monad very well
09:08:00 <opqdonut> yeah, as the elements are in no specific order
09:08:09 <opqdonut> filter seems more apt
09:08:14 <xerox> paolin1: you need a Prolog monad for that :)
09:08:26 <paolin1> filter is guard
09:08:45 <opqdonut> yep
09:09:19 <paolin1> xerox : ConT [] ?
09:09:33 <xerox> paolin1: yeah, or the other way around.
09:12:02 <gattocarlo> bos: is there a public review? how were the comments (positive ones, I'm sure ;)
09:12:03 <mrd> travisbrady: sequence [putStrLn "hello", putStrLn "world"] -- run both and return [(),()]
09:12:05 <jedbrown> :t (#)
09:12:10 <lambdabot> parse error on input `)'
09:12:31 <sjanssen> jedbrown: in what context are you seeing #?
09:12:34 <quicksilver> jedbrown: # is magic
09:12:48 <bos> gattocarlo: public review is in about 2 weeks
09:12:51 <quicksilver> jedbrown: it's used to flag some reserved internal GHC stuff, mostly to do with unboxed types
09:12:52 <shapr> @users
09:12:52 <lambdabot> Maximum users seen in #haskell: 407, currently: 368 (90.4%), active: 23 (6.3%)
09:13:04 <bos> comments have been variable, which is reasonable for a first draft
09:13:21 <jedbrown> hmm, I entered that in the wrong buffer.  Thanks.
09:13:39 <ed1t> is there any good haskell IDE then emacs and vim?
09:14:03 <sjanssen> ed1t: there's some Eclipse integration
09:14:12 <mrd> sjanssen: he said 'good'
09:14:13 <ed1t> eclipse is alright
09:14:18 <ed1t> lol
09:14:23 <sjanssen> and Visual Haskell, which is an addon to Visual Studio
09:14:33 <ed1t> another crappy one
09:14:37 <quicksilver> eclipse is good, but the haskell eclipse plugin is not very powerful
09:14:48 <quicksilver> it doesn't have the really nice features you'd want
09:14:53 <mrd> eclipse choked my computer to death
09:15:09 <ed1t> is anybody working on haskell IDE instead of a plugins?
09:15:14 <mrd> Yi
09:15:38 <mrd> well -- its an editor, but there's lots of hope =)
09:16:02 <ed1t> i just need an editor with maybe color highlighting
09:16:13 <mrd> well vim and emacs can provide that easily
09:16:14 <ed1t> tired of using nano/gedit
09:16:40 <ed1t> you cant really ident well with nano
09:16:52 <mrd> indeed
09:17:04 <sjanssen> ed1t: several editors have Haskell syntax highlighting
09:17:10 <mrd> there's a list on the wiki
09:17:22 <ed1t> sjanssen, do you have link or list?
09:17:27 <psnively> I like EMACS
09:17:28 <ed1t> mrd, where?
09:17:28 <sjanssen> actually, I'd expect most programming-oriented editors to support it
09:17:38 <gattocarlo> When I finished my bindings to the Audiacious xmms_remote API I found out it has been (undocumentedly) deprecated ... ;)
09:17:57 <mrd> ed1t: under program development in applications and libraries i think
09:18:09 <sjanssen> http://www.haskell.org/haskellwiki/Applications_and_libraries/Program_development#Editor_support
09:18:13 <lambdabot> Title: Applications and libraries/Program development - HaskellWiki, http://tinyurl.com/yt5nlf
09:18:31 <ed1t> thx
09:20:31 <Apocalisp> I'm having trouble compiling Yi
09:20:43 <Apocalisp> is it I, or the repo?
09:21:32 <notsmack> Apocalisp: so am i
09:25:44 <Apocalisp> :-(
09:26:12 <Apocalisp> @seen dons
09:26:12 <lambdabot> I saw dons leaving #xmonad and #haskell 15h 34m 40s ago, and .
09:26:38 <Apocalisp> "and ."
09:26:42 <Apocalisp> @type and .
09:26:48 <lambdabot> parse error (possibly incorrect indentation)
09:27:26 <mauke> @type (and .)
09:27:28 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
09:27:30 <Apocalisp> ah!
09:33:39 <gattocarlo> Apocalisp: I've just finished compiling Yi
09:34:02 <Apocalisp> yay! Did you run into any troble?
09:34:17 <Apocalisp> or any trouble?
09:34:40 <gattocarlo> no
09:35:18 <gattocarlo> I just pulled  yi and vty. both build cleanly
09:36:04 <Apocalisp> hmm
09:36:24 <Apocalisp> setup complains about not finding Yi.Boot. I have no idea where this file is supposed to exist.
09:38:32 <ed1t> why didnt they do haskell IDE in google summer of code?
09:38:57 <psnively> Not enough time for an IDE.
09:39:22 <ed1t> its 4 months and they will probably have like team of 10 working on it
09:39:27 <bos> you can't write an IDE in a summer; you can barely write a dialog box.
09:39:42 <psnively> ed1t: Ever tried to write an IDE? :-)
09:39:45 <ed1t> no
09:39:55 <psnively> edi1t: I didn't think so!
09:40:07 <ed1t> team of 10 working on an IDE for 4 months isnt enough?
09:40:13 <psnively> Nope.
09:40:21 <bos> especially not 4 students.
09:40:30 <psnively> 10 is probably too many people, first of all.
09:40:38 <ed1t> i mean for a beta version....i know it takes time to get a final release
09:40:46 <psnively> It's unbelievably unlikely that developing an IDE is that parallelizable.
09:40:49 <sjanssen> 10 people, with little to no face time
09:41:06 <ndm> ed1t: they did, for 1 person, guihaskell
09:42:20 <ndm> developing an IDE is ridiculously hard...
09:42:49 <psnively> Word.
09:42:52 <ddarius> Mainly because language implementations don't readily expose enough.
09:43:27 <Apocalisp> I'd love something like "Turbo Haskell"
09:43:31 <psnively> ddarius: I would humbly suggest that even in language implementations that do (Lisp), developing an IDE is ridiculously hard.
09:44:50 <ddarius> psnively: Perhaps, but that takes a massive chunk out of it.  Also, even when exposed the tools may not be useable.
09:44:53 <bos> dons: !!!!!
09:45:17 <dons> bos!!! woot!
09:45:17 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
09:45:21 <glguy> heh
09:45:31 <psnively> ddarius: Yes, although I suspect that multi-staged languages, e.g. MetaOCaml, also make it easier.
09:45:35 <Apocalisp> wo0t4g3!
09:45:35 <dons> 5 messages. crikey!
09:45:43 <glguy> lol, crikey
09:46:03 <dons> lolololz
09:46:24 <dons> bos is officially a god of web publishing
09:46:35 <bos> a pretty stupid god.
09:46:41 * ddarius reserves his judgement on that.
09:46:42 <Apocalisp> I met a guy the other day who actually says "lol", pronouced like it's spelled.
09:46:49 <ddarius> Apocalisp: People do that.
09:47:05 <gattocarlo> how can I have Cabal execute pkg-config to retrieve flags for c2hs? hooks or I need autoconf?
09:47:09 <bos> you should see the fun i'm having trying to unbugger the comment database after nine hours of case folded comment IDs getting added.
09:47:28 <psnively> Many kids pronounce emoticons etc.
09:47:37 <sjanssen> gattocarlo: I've heard that Cabal 1.2.0 has pkg-config support
09:47:47 <dons> mm, opengl haskell tetris? http://myawesomeblag.blogspot.com/2007/03/opengl-tetris-in-haskell.html
09:47:50 <lambdabot> Title: My Awesome Blag: OpenGL Tetris in Haskell, http://tinyurl.com/283j4x
09:47:54 <ddarius> When I have a kid, he/she is going to be beat if he/she does that.
09:48:23 <b_jonas> pronounce emoticons? how?
09:48:26 <Apocalisp> When I have a kid, they will be beaten if they ever say "be beat".
09:48:35 <b_jonas> I've heared about "lol" but emoticons?
09:48:47 <ddarius> That too Apocalisp.
09:48:52 <Apocalisp> lawl
09:49:04 <psnively> Yeah, they'll say "sigh" or "frown" or whatever.
09:49:18 <Apocalisp> Hah. Why not just sigh or frown?
09:49:26 <psnively> Because it lacks irony.
09:49:34 <b_jonas> "sigh"? not "smile"?
09:49:39 <glguy> *wink*
09:49:47 <psnively> I haven't heard a "smile" yet.
09:49:49 <ddarius> Apocalisp: Accessibility!  If you frown and say "frown" both sighted and blind people will know what is going on.
09:49:56 <gattocarlo> sjanssen: yes indeed. thanks
09:50:10 <glguy> yeah, no one likes being sued
09:50:38 <Apocalisp> ddarius: Pretty soon that will be a law in Canada, I'm sure.
09:50:40 <b_jonas> yeah, "smile" doesn't really sound well. maybe "grin" would be better
09:53:45 <Apocalisp> That's just poorly typed English. "Grin" all by itself is an imperative.
09:54:09 <glguy> yeah... maybe we just have a lot of bossy kids running around
09:54:13 <psnively> As is "Smile."
09:54:16 <psnively> As is "Sigh."
09:54:20 <Apocalisp> Exactly.
09:54:27 <glguy> psnively: Smile.
09:54:49 <psnively> :-)
09:54:53 <glguy> Maybe we could have lambdabot write the emote icons for us.
09:55:04 <glguy> if you wrote the imperative: smile.
09:55:07 <glguy> lambdabot: :-)
09:55:12 * Apocalisp routinely asks what they want me to name, whenever somebody says "Name?".
09:55:19 <glguy> so you wouldn't have to write them yourself!
09:55:22 <glguy> think of the savings
10:00:54 <phobes> So why is writing an IDE ridiculously hard?
10:01:57 <bos> it isn't, it's just endless fiddly details
10:06:48 <psnively> phobes: On a human level, it's very hard to specify what an IDE should do. On a technical level, it's frequently very hard to hook into the development tools in such a way as to support whatever the requirements turn out to be.
10:14:55 <b_jonas> no, grin is a noun
10:15:17 <b_jonas> at least, I meant it as a noun, just like "smile" or "frown"
10:15:47 <psnively> Interestingly, "grin," "smile," "frown," etc. are either verbs or nouns, depending upon usage.
10:16:18 <psnively> In English, any word that can be either a verb or a noun, used by itself, is implicitly a verb used in the imperative, with an implicit "You" as the subject.
10:16:50 <psnively> "Grin" alone, then, is the imperative "You grin!"
10:17:24 <b_jonas> ues, but it's not used by itself there
10:17:27 <b_jonas> it's like saying "period"
10:17:33 <b_jonas> when reading something out
10:17:40 <mauke> there are asterisks around it: *grin*
10:17:42 <mauke> but they're silent
10:18:02 <b_jonas> or "full stop"
10:18:32 <Apocalisp> In English, a noun cannot stand by itself without an article.
10:18:50 <Apocalisp> Except for proper names, maybe.
10:19:06 <byorgey> For maximum irony, today's internet-savvy teenagers don't just say "lol", but "silent asterisk lol silent asterisk".
10:19:11 <Apocalisp> In which case you're addressing the subject.
10:19:19 <mauke> http://de.wikipedia.org/wiki/Erikativ
10:21:03 <oerjan> Apocalisp: uncountable nouns too
10:21:10 <phobes> \o/  is this always a cheer or can it be exasperation?
10:21:22 <b_jonas> Apocalisp: it's quite the contrary, a singular noun usually cannot stand without an article _in a sentence_
10:21:44 <b_jonas> alone, like in a title or on an exit sign, it can
10:21:47 <oerjan> phobes: i don't know \o/
10:21:55 <phobes> b_jonas:  bullocks.
10:22:00 <phobes> o*
10:22:01 <b_jonas> :)
10:22:35 <b_jonas> on the other hand, reading out the punctation or smilies generally is wrong, you should do that only when you want to read something out exactly
10:24:19 * Apocalisp wonders what Lisp would sound like if you pronounced all the parens.
10:24:27 <UnaRacer> Does anybody know if it is possible to either temporarily suspend garbage collection, or get the amount of time spent garbage collecting?
10:24:28 <lambdabot> UnaRacer: You have 1 new message. '/msg lambdabot @messages' to read it.
10:25:07 <sjanssen> UnaRacer: GHC has various RTS flags to get those statistics, check the manual
10:25:22 <UnaRacer> Can I get them as the program runs?
10:25:57 <sjanssen> yes, I believe so
10:26:59 <sebell> Apocalisp: ??
10:27:14 <Apocalisp> !!
10:27:32 <oerjan> :t (??)
10:27:34 <lambdabot> Not in scope: `??'
10:27:51 <Apocalisp> :t \o/
10:27:52 <lambdabot> parse error on input `/'
10:29:44 <Apocalisp> (\o/) :: (Monad m) => m a -> Woot
10:30:29 <oerjan> :t \O->O/ O-O
10:30:31 <lambdabot> Not in scope: data constructor `O'
10:30:31 <lambdabot>  
10:30:31 <lambdabot> <interactive>:1:4: Not in scope: data constructor `O'
10:30:50 <oerjan> :t \o->o/ o-o
10:30:52 <lambdabot> forall a. (Fractional a) => a -> a
10:39:04 <oerjan> beick bsmbtvbombdood ?
10:39:17 <oerjan> wrong channel
10:52:40 <Janni> Hello.
10:52:49 <byorgey> hi Janni
10:56:43 <Janni> Hmm. This is a first time experience. I just came here to ask some question and I actually figured it out myself BEFORE asking it. That normally happens about 5 seconds AFTER I asked it. That's an improvement...
10:56:55 <Janni> But that way IRC/#haskell is still useful...
10:56:59 <psnively> Heh.
11:05:31 <pejo> Janni, we're happy to help.
11:14:08 <shapr> hi Janni, haven't seen you in awhile.
11:17:50 <hpaste>  Ron pasted "freeglut custom makefile" at http://hpaste.org/2841
11:18:46 <hpaste>  Ron pasted "freeglut custom def file" at http://hpaste.org/2842
11:19:59 <shapr> Who's ron?
11:20:54 <shapr> hpaste sure is slow today.
11:29:30 <Lemmih> hpaste is probably written in some slow language.
11:31:24 <shapr> Lemmih: heh
11:32:54 <scandal> i have a question about how lazy evaluation works.  i was reading comp.lang.python last night and someone asked how to generate a list of partial sums of a list of numbers (eg.  partial_sum [1,2,3,4] = [1, 1+2, 1+2+3, 1+2+3+4]).
11:33:00 <scandal> > let partial_sum s@(x:xs) = x:zipWith (+) xs (partial_sum s) in partial_sum [1..4]
11:33:03 <lambdabot>  [1,3,6,10]
11:33:13 <xerox> > scanl (+) [1..]
11:33:13 <lambdabot>   add an instance declaration for (Num [t])
11:33:19 <shapr> Lemmih: It's probably more that my virtual server sucks butt.
11:33:21 <xerox> > scanl (+) 1 [2..]
11:33:22 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
11:33:32 <xerox> aka triangle numbers
11:33:45 <scandal> what confuses me is how partial_sum can work since it calls itself with the *same* arguments its was given!
11:34:13 <Lemmih> shapr: We could install a node on catenova and run in multimaster mode (:
11:34:19 <shapr> Oh that would be cool!
11:34:24 <shapr> *very* cool!
11:34:25 <xerox> scandal: start with the expression you want to evaulate, and substitute the definition.
11:34:51 <desegnis> scandal, the trick is the (x :) in the beginning
11:36:00 <desegnis> To get the first element of zipWith (+) xs (partial_sum s), you need to know (head xs) and (head (partial_sum s))
11:36:09 <pjd> scandal: infinite recursion is only a problem if you actually try to consume the whole result
11:36:15 <xerox> psum [1..4] = 1 : zipWith (+) [2,3,4] (psum [1,2,3,4])
11:36:40 <pjd> but zipWith stops on the shortest list, which is xs
11:37:04 <xerox>  = 1 : zipWith (+) [2,3,4] (2 : zipWith (+) [3,4] (psum [2,3,4]))
11:37:31 <pjd> > let ones = 1:ones in take 5 ones
11:37:33 <lambdabot>  [1,1,1,1,1]
11:38:30 <pjd> > let ones = 1:ones in zip "abc" $ take 5 ones
11:38:31 <lambdabot>  [('a',1),('b',1),('c',1)]
11:38:40 <dons> http://programming.reddit.com/info/2s3zk/details
11:38:42 <lambdabot> Title: OpenGL Tetris in Haskell in a couple hundred lines of code (mouse movement, keyb ...
11:38:42 <pjd> err
11:38:45 <pjd> > let ones = 1:ones in zip "abc" ones
11:38:46 <lambdabot>  [('a',1),('b',1),('c',1)]
11:39:26 <scandal> ok, thanks.  i didn't realize that there was already a function `scanl` that did that operation.
11:40:02 <scandal> that make sense since someone posted a reply with an iscan() python function using itertools.
11:40:04 <shapr> It even fits into your nickname!
11:40:11 <scandal> heh ;)
11:40:22 <scandal> perhaps i should shorten my nick.
11:40:30 <shapr> scanl would be an excellent choice.
11:40:46 <shapr> I keep hoping Haskell will get shapl and shapr, but it never happens.
11:40:58 <pjd> "Haskell's typing inference"
11:40:59 <scandal> in some parts of the U.S., people would pronounce it that way, too.
11:40:59 <kaol> what would they do?
11:40:59 <pjd> heh
11:41:13 <kaol> @src shapr
11:41:14 <lambdabot> Source not found. Wrong!  You cheating scum!
11:41:18 <shapr> @src shapl
11:41:19 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:41:38 <shapr> kaol: They'd probably be shaping HOFs
11:41:45 <oerjan> shift application right, clearly
11:41:51 <shapr> Huh
11:41:54 <shapr> oerjan: What would that do?
11:42:23 <oerjan> i don't quite know but it would have an Applicative constraint
11:42:29 <shapr> hm, yeh
11:43:36 <oerjan> and probably take a list
11:45:14 <shapr> hiya atomb
11:45:28 <atomb> hi shapr
11:45:38 <xerox> so you can see it this way, scandal:
11:45:42 <xerox> psum [1..4] =
11:45:42 <xerox> = 1 : zipWith (+) [2,3,4] (psum [1..4])
11:45:42 <xerox> = 1 : zipWith (+) [2,3,4] (1 : ...)
11:45:42 <xerox> = 1 : 3 : zipWith (+) [3,4] (3 : ...)
11:45:42 <xerox> = 1 : 3 : 6 : zipWith (+) [4] (6 : ...)
11:45:44 <xerox> = 1 : 3 : 6 : 10 : zipWith (+) [] (10 : ...) = [1,3,6,10]
11:46:28 <scandal> xerox: yeah, i'm just not used to thinking about problems this way.  i was really surprised when i wrote that code and it worked. ;)
11:46:45 <opqdonut> psum?
11:46:46 <xerox> it's called equational reasoning, it's really quite powerful
11:46:59 <pjd> the Killer Feature
11:47:11 <scandal> i realized the solution must look something like that after doing the simple primes problem.
11:47:26 <scandal> it really is quite elegant
11:48:45 <Cale> scandal: yeah, you just have to remember that lazy evaluation evaluates everything outermost-first
11:49:29 <Cale> scandal: So in some sense, psum returns "immediately", but leaves a recursive call to itself stuck in the thing which it returned.
11:49:55 <Cale> (that cons cell)
11:49:56 <pjd> like Python generators
11:53:37 <scandal> is the space allocated for the result shared between the internal closure (i'm not sure if that is the proper name for this) with the output of the function?
11:55:13 <scandal> hrm, i guess it would have to be, since there is no way to get the second element on the list without invoking the closure.
11:55:13 <coffeemug> hi
11:55:22 <shapr> y0 coffeemug
11:55:45 <coffeemug> there was a paper on monads where the guy explained maybe, state, IO, and I think something else
11:55:50 <coffeemug> I can't find it :(
11:56:07 <coffeemug> does anyone remember about that one?
11:56:19 <shapr> That's a lot of papers.
11:56:27 <shapr> Maybe http://www.haskell.org/all_about_monads/ ?
11:56:27 <lambdabot> Title: All About Monads
11:56:33 <coffeemug> no, not that one
11:56:37 <shapr> Or http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.lhs ?
11:57:10 <coffeemug> not that one either :)
11:57:23 <coffeemug> arghh
11:57:26 <coffeemug> when you need something
11:57:29 <coffeemug> you just can't find it
11:58:57 <shapr> Maybe it's sigfpe's "You could have invented monads" ?
12:00:18 <therp> coffeemug: look at the papers by "wadler"
12:00:31 <therp> coffeemug: he has at least 3 papers about monads
12:00:34 <coffeemug> yeah, I *think* it may have been a wadler paper
12:00:42 <therp> though, he usually don't talk about IO
12:00:49 <coffeemug> but I looked through all of them
12:00:56 <coffeemug> and couldn't find that one
12:01:02 <coffeemug> shapr: no, not that one :)
12:01:08 <therp> coffeemug: you looked at his website, right?
12:01:08 <coffeemug> I went through all the usual suspects
12:01:13 <coffeemug> therp: yeah
12:01:21 <shapr> Maybe it's a paper by John Hughes?
12:02:05 <therp> coffeemug: maybe one of the references in wadler's papers?
12:02:21 <coffeemug> shapr: hmm, may be
12:03:15 <Adamant> Tackling the Awkward Squad
12:03:22 <Adamant> that it?
12:03:29 <wli> Comprehending monads?
12:04:32 <coffeemug> no
12:04:34 <coffeemug> hmm
12:04:35 <timthelion> is there some way for haskell programs to send objects between eachother in a typesafe maner, without serializing?  (in c++ forinstance, you can pass pointers between programs)
12:04:40 <coffeemug> may be I envisioned that paper in my sleep
12:04:45 <coffeemug> and it doesn't really exist :)
12:05:04 <coffeemug> timthelion: but you can't in C++
12:05:14 <coffeemug> timthelion: unless you're using windows 3.0
12:05:16 <coffeemug> :)
12:05:24 <coffeemug> because of different address space
12:05:38 <koala_man> using shared memory presumably?
12:05:54 <timthelion> coffeemug: oh yes you can, you might not be able to do so under any reasonable os, but you can do it!
12:06:01 <coffeemug> heh
12:06:01 <timthelion> koala_man: yes,
12:06:11 <timthelion> it's technically possible
12:06:16 <coffeemug> win32 allows one process to access address space of another with some special functions
12:06:19 <coffeemug> don't remember what they are
12:06:24 <coffeemug> also there's shared memory
12:06:31 <timthelion> well I'm using debian gnu linux
12:06:35 <coffeemug> but you can use that stuff in Haskell too via FFI
12:06:48 <coffeemug> so figure out how to do it in C on your OS
12:06:55 <coffeemug> and then do the same thing in Haskell with FFI
12:06:56 <Lemmih> Shared memory requires serialization, even in C++.
12:07:01 <phobes> you can pass the pointer, though you might not like what it points to when you get it
12:07:14 <timthelion> Lemmih: no it doesn't where did you get that idea?
12:07:44 <coffeemug> Lemmih: not really
12:07:47 <timthelion> FFI won't do me any good
12:08:01 <coffeemug> Lemmih: on win32, at least, you can initialize memory that's accessible to two processes
12:08:04 <Lemmih> timthelion: You might move some structure into the shared memory but you're fscked if it contains any pointers.
12:08:05 <coffeemug> and write to it directly
12:08:50 <wli> shmget(), shmat(), etc.
12:08:52 <timthelion> Lemmih: that's a problem with the OS, it's not a technological barier. it just means you have to change those pointers values
12:09:09 <Lemmih> timthelion: Exactly.
12:09:34 <Lemmih> (ie. serialize it)
12:10:20 <kyevan> Has anyone looked at MS's new dynamic language stuff on top of .NET to see if it would make a Haskell on top of it any easier?
12:11:06 <timthelion> ghci doesn't allow for incramental developement, you can't define function f, and then use it later.  as far as I can tell, you can't even use the return value of function f later, and I'm trying to figure out why.
12:11:10 <coffeemug> kyevan: what's dynamic about haskell? :)
12:11:32 <coffeemug> timthelion: you can say let x a b = a + b in ghci
12:11:49 <timthelion> kyevan: I think that there is a haskell 2 il compiler
12:11:51 <kyevan> coffeemug: Nothing, but it might introduce other things that are helpful, still
12:12:03 <Cale> timthelion: however, be prepared to lose all your definitions if you do lots of that :)
12:12:11 <timthelion> coffeemug: yes, but you can't do anything accrost statements
12:12:21 <Cale> (just because things like reloading modules will kill them)
12:12:29 <Cale> timthelion: sure you can
12:12:37 <timthelion> Cale: show me
12:13:12 <Cale> Prelude> let double x = x + x
12:13:12 <Cale> Prelude> let quadruple x = double (double x)
12:13:12 <Cale> Prelude> quadruple 1
12:13:12 <Cale> 4
12:13:31 <Cale> You can use earlier bindings in later ones.
12:13:36 <coffeemug> brb
12:14:01 <Cale> Obviously, you can't write mutually recursive things without smashing the whole group on to one line though.
12:14:19 <timthelion> then why do you need let?
12:14:34 <Cale> Hm?
12:14:39 <pjd> timthelion: it's like a do block
12:15:00 <timthelion> why can't you do
12:15:09 <timthelion> double x = x+x
12:15:18 <timthelion> instead of let double...
12:15:18 <Cale> Prelude> foo <- readFile "TODO"
12:15:19 <Cale> Prelude> length (lines foo)
12:15:19 <Cale> 14
12:15:25 <pjd> you can't do that in a do block
12:15:36 <timthelion> ok
12:15:47 <Cale> The syntax is set up in order that you can sort of imagine that you're typing in the contents of a do-block
12:16:23 <Cale> The only exception to this is that if the type of the expression you type is not (IO t), then it tries wrapping it in a call to print
12:17:05 <timthelion> is there a state machein in ghci? can I use ans?
12:17:16 <Cale> it
12:17:20 <Cale> Prelude> it^2
12:17:20 <Cale> 196
12:17:50 <jonathanv> hi #haskell
12:17:55 <Cale> hello
12:18:12 <jonathanv> i don't know haskell, but i plan to learn it someday
12:18:16 <Cale> cool
12:18:27 <Cale> Make sure to hang around here while you're learning
12:18:38 <Cale> and ask lots of questions :)
12:18:40 <jonathanv> i'm on an ocaml kick, but i'm adding haskell to my list because i'm really pissed abotu how strings are mutable in ocaml
12:19:20 <Lemmih> jonathanv: Welcome to the immutable world of Haskell.
12:19:26 <coffeemug> mutability of strings can be useful :)
12:19:37 <coffeemug> (sorry for this blasphemy)
12:19:47 <coffeemug> are strings represened at arrays in OCaml?
12:19:50 <jonathanv> i'd rather they used arrays of characters for behavior that requires it
12:20:04 <Cale> By the way, there are new Catsters videos up, in case anyone didn't already notice :) http://uk.youtube.com/profile_videos?user=TheCatsters
12:20:04 <lambdabot> Title: YouTube - Broadcast Yourself.
12:20:56 <byorgey> There's also a new Project Euler problem up, in case anyone didn't already notice =)
12:20:58 <byorgey> http://projecteuler.net/index.php?section=problems&id=161
12:20:58 <lambdabot> Title: Project Euler
12:21:21 * byorgey happily fiddles with triominoes
12:33:46 <sjanssen> @keal
12:33:46 <lambdabot> just seeing how offtopic i could get everyone
12:44:36 <hpaste>  timthelion pasted "hmm, why aren't those there paterns exauhstive?" at http://hpaste.org/2843
12:45:03 <timthelion> my other question is "why is hpaste so frigin slow?"
12:45:28 <shapr> Probably something I upgraded last night.
12:45:31 <shapr> I bet it needs a restart.
12:45:53 <byorgey> hm, yeah, it definitely seems much slower than usual.
12:46:02 <timthelion> it took me 3 secconds to load the front page
12:46:07 <sjanssen> it isn't loading at all for me
12:46:16 <shapr> I could try to reboot the virtual machine, but no guarantees it'll come back up.
12:46:17 <byorgey> ah, timthelion's post is finally loading...
12:46:29 <shapr> Bah, I'll reboot it.
12:46:31 <byorgey> come one...
12:46:33 <byorgey> *on
12:46:40 <shapr> Wow, I can't even login.
12:47:00 <byorgey> load average: Infinity
12:47:15 <shapr> ACtually, more like 0.13
12:47:16 <byorgey> hey!  it loaded!
12:47:19 <shapr> Dunno why it's acting this way.
12:47:24 <sjanssen> timthelion: paste.lips.org ?
12:47:27 <shapr> I'm going to reboot it anyway.
12:47:29 <sjanssen> s/lips/lisp
12:47:46 * shapr hopes it returns
12:48:01 <shapr> Should really move hpaste to community.haskell.org
12:48:26 <byorgey> timthelion: in Haskell, 1000/3 does not do integer division
12:48:36 <byorgey> you really want something like 1000 `div` 3
12:49:22 <byorgey> so when you call threes (1000/3), it does 1000.0 : threes (332.33333) and so on
12:49:31 <sjanssen> !paste
12:49:31 <byorgey> eventually reaching threes (0.33333...)
12:49:31 <hpaste> Haskell paste bin: http://hpaste.org/
12:49:32 <timthelion> yes, and I tried that.
12:49:47 <byorgey> timthelion: you tried what?  1000 `div` 3?
12:49:56 <timthelion> ya, you see the all1
12:50:24 <byorgey> ohhh, wait, I see
12:50:36 <byorgey> you defined the cases for threes in the wrong order
12:50:44 <byorgey> it pattern-matches in order from top to bottom
12:51:00 <byorgey> so the first one is "threes n = ..." and the n matches anything, including 0
12:51:02 <timthelion> I thought haskell was unordered
12:51:15 <timthelion> ok
12:51:19 <sjanssen> patterns are matched top to bottom
12:51:28 <Cale> declarations are unordered, but the clauses in one function declaration are ordered
12:52:13 <byorgey> timthelion: I might also suggest putting all of that stuff in a .hs file, and :load'ing it into ghci
12:52:19 <byorgey> it's a lot easier to work with that way
12:52:42 <Cale> I recommend keeping an editor window open alongside ghci
12:53:10 <Cale> Then :r will reload the file (or just : even)
12:53:37 <timthelion> byorgey: I'm working on creating a new developement model, an incramental development model. for writting software.  I'm trying to get away from the write, build, run, to the test as you write goodness of elisp
12:53:56 <Cale> oh, also, on the command line like that, your second definition for threes is shadowing the first
12:54:10 <sjanssen> timthelion: ghci really isn't built for this
12:54:27 <Cale> When you do  let threes 0 = [], it's throwing away the previous definition of threes
12:54:41 <timthelion> sjanssen: I'm trying to figure out if it's possible to change ghci slightly to make it built for this
12:54:43 <Cale> You have to put recursive definitions all in one let
12:54:55 <timthelion> ok
12:55:02 <Cale> let threes 0 = []; threes n = n*3 : threes (n-1)
12:55:07 <timthelion> that's deffinatly usefull to know.
12:55:10 <byorgey> timthelion: haskell actually supports the test-as-you-write model really well, but it's still usually necessary to keep code in a separate file
12:55:13 <sjanssen> crazy idea of the moment: I want to see a ghci wrapper that uses inotify to watch my modules, and reloads them automatically when they change
12:55:39 <sjanssen> timthelion: the changes would need to be quite deep
12:55:48 <xerox> timthelion: in emacs ishandy enough, in that you write and then just C-c C-l to load it.
12:55:51 <sjanssen> for example, you'd want to change when names are resolved
12:55:54 <timthelion> shut up nei sayers!
12:56:07 <sjanssen> let add x y = x*y
12:56:09 <shapr> I think we have more ni sayers here.
12:56:11 <shapr> NI NI!
12:56:24 <sjanssen> let add3 x y z = add (add x y) z
12:56:27 <byorgey> timthelion: in fact, I was just going to suggest that you might have wanted to test each of those functions (threes, fives, pushf, etc.) as you went along
12:56:38 <sjanssen> oops, now we see that add x y should be x+y
12:56:45 <shapr> Hey, I want to write tests that run inside Template Haskell so that compiles fail if HUnit or QuickCheck tests fail.
12:56:49 <shapr> How do I do this?
12:56:53 <byorgey> timthelion: as it is it seems you only tested at the end, when you finally uncovered a problem with the definition of threes.
12:56:55 <sjanssen> so we "let add x y = x + y"
12:57:07 <sjanssen> but add3 will still be using the old defn. of add that used (*)
12:57:07 <timthelion> byorgey: I know I know
12:57:37 <byorgey> timthelion: ok, sorry if I'm coming across as condescending, I don't mean to =)
12:57:50 <timthelion> I'm best at writting in shell script, or elisp, where I learned to write incramentally, but now, don't even need to test as I go.
12:58:46 <byorgey> shapr: didn't someone ask about that on -cafe recently?
12:58:48 <timthelion> I guess I'll start over :)
12:58:53 <shapr> Probably
12:59:08 <sjanssen> timthelion: I argue that you can still write code incrementally with the combination of ghci and a text editor
12:59:28 <byorgey> shapr: I recall that someone put forth a very slick solution, but unfortunately I don't remember what it was =P
12:59:30 <timthelion> sjanssen: what we need, is for ghci to call : when it gains focus again
12:59:49 <timthelion> so you switch to the text editor, ghci does not have focus, you switch back, and it reloads
13:00:01 <sjanssen> timthelion: yeah, or even every time you write to the file
13:00:25 <byorgey> hm, that would be pretty sweet =)
13:00:32 <xerox> rebind C-x o to C-c C-l :)
13:00:34 <timthelion> sjanssen: not all file systems have dependible file hooks do they?
13:00:39 <shapr> Ah, that is slick.
13:00:52 <sjanssen> timthelion: I'm not entirely sure
13:01:24 <sjanssen> is inotify not reliable?
13:01:43 <shapr> hinotify is nifty
13:01:47 <timthelion> I don't know. not in windows.
13:01:56 <sjanssen> it doesn't exist on Windows
13:02:10 <timthelion> there are file hooks in windows, they just don't work.
13:02:12 <sjanssen> but who cares about Windows :P
13:02:23 <timthelion> so I assumed that in linux there would be similar problems :)
13:02:45 <Vq^> just use polling :)
13:02:53 <shapr> inotify in Linux is really great.
13:03:14 <Vq^> shouldn't slow down Microsoft Windows more than those silly virus-protection-viruses
13:03:24 <sjanssen> @hackage hint
13:03:24 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint
13:03:28 <sjanssen> ^^^ looks promising
13:04:32 <timthelion> what would be cool, is if I could define threes, and then define test threes = threes (div 1000 3), and each time I reloaded in ghci, it would run the test function, for each of the functions that had changed since last reloading.
13:04:45 <timthelion> and the test function would never get compiled into a finished version.
13:04:59 <timthelion> it would just show output in ghci
13:05:46 <sjanssen> you could probably do that with TH
13:07:16 <Cale> timthelion: how is it supposed to know if threes is good or not based on just that? You'd probably want to give it an equation of some sort to test.
13:08:14 <timthelion> Cale: what do you mean? ghci would act as though test had been called at the prompt, it would print 3 6 9 ... and I could look and see that the output was correct.
13:08:14 <Cale> timthelion: Have you looked at QuickCheck? You can define a bunch of algebraic properties that your code is supposed to satisfy, and it will generate random parameters and test it.
13:08:20 <Cale> ah
13:08:56 <sjanssen> I wonder if GHC's optimizer will remove a declaration that isn't used or exported
13:20:34 <njbartlett> http://www.londonhug.net/2007/09/21/games-in-haskell-video-now-available/
13:20:41 <lambdabot> Title: Î»ondon HUG » Blog Archive » Games in Haskell: Video now Available, http://tinyurl.com/29qk7u
13:28:22 * byorgey <3 Catsters =)
13:48:45 <Cale> http://programming.reddit.com/info/2s6r2/comments
13:48:46 <lambdabot> Title: Games in Haskell talk video now available (reddit.com)
13:49:02 <Cale> (sorry if you'd wanted to submit that njbartlett :)
13:49:29 <njbartlett> No problem! Thanks Cale
13:50:33 <jmob> If I have an integer that's in an IO monad how do I allow a now monadized function to access it?
13:50:46 <matthew-_> njbartlett: howdy. how's the video?
13:50:46 <glguy> lift the function into the monad
13:50:54 <glguy> :t liftM
13:50:54 <Cale> jmob: By an integer in the IO monad, you mean an IO Integer?
13:50:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:51:04 <njbartlett> matthew-_: You can check it out for yourself
13:51:14 <matthew-_> njbartlett: oh boy!
13:51:28 <njbartlett> The audio isn't as good as I'd like, and Google seems to have reduced the resolution drastically as well ;-(
13:51:29 <Cale> jmob: That's actually a computation which computes an integer when run, so you need to run it with do-notation:
13:51:34 <sorear> @users
13:51:35 <lambdabot> Maximum users seen in #haskell: 407, currently: 377 (92.6%), active: 12 (3.2%)
13:51:37 <Cale> do n <- myIOInteger; ...
13:51:49 <matthew-_> oh crap! that's me!
13:51:53 <Cale> Then n will be an actual integer for the rest of the do-block
13:52:09 <jmob> Cale: right, what if it's wrapped in two monads
13:52:18 <Cale> jmob: which two?
13:52:23 <Cale> IO and something else?
13:52:29 <Cale> Or IO and IO?
13:52:37 <jmob> Cale: CGI IO Int, but I have something that wants access to the Int
13:53:02 <Cale> Is that thing a CGI computation?
13:53:27 <jmob> Cale: no, its a normal function, not in any monads
13:53:54 <Cale> Note that the Int doesn't actually exist in there
13:54:19 <jmob> if I liftM the function, it can access the IO Int, but yet jsut the Int
13:54:20 <Cale> a value of type CGI (IO Int) is a CGI computation which produces an IO computation which produces an Int when run
13:55:00 <Cale> If you're writing a CGI computation, you can get access to the IO Int, and then you can use liftIO to turn it into a CGI Int, and run that.
13:55:50 <Cale> You just have to run the CGI action, which will give you the IO Int
13:55:51 <bos> @seen dons
13:55:52 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 51m 40s ago.
13:56:03 <Cale> Let's say  x :: CGI (IO Int)
13:56:03 <jmob> hrmm
13:56:10 * jmob boards a plane
13:56:14 <jmob> thanks
13:56:16 <Cale> then, in  do { v <- x; ... }
13:56:19 <Cale> v :: IO Int
13:56:37 <Cale> and so we can write  do { v <- x; n <- liftIO v; ...}
13:56:40 <Cale> and then n :: Int
13:57:00 <matthew-_> njbartlett: um, if you need hosting for the high bandwidth version then do yell - I have > 1 TB transfer a month available...
13:57:04 <Cale> jmob: does that make sense?
13:57:54 <sjanssen> njbartlett: "There is no video of Dr Patersonâs talk", is that no video available yet, or no video available ever?
13:59:13 <matthew-_> sjanssen: he declined to be videoed
13:59:18 <sjanssen> aww
13:59:25 <njbartlett> matthew-_: Yeah that would be great!
13:59:43 <matthew-_> sjanssen: but he just gave a cut down version of the paper - just read the paper frankly! ;)
14:00:19 <sjanssen> matthew-_: I've read the paper, I'd still like to see him talk about it though
14:04:15 <DRMacIver> Stupid question. In http://www.soi.city.ac.uk/~ross/software/Data/FingerTree.hs , anyone know why the v parameter for Deep is strict?
14:04:40 <DRMacIver> This seems like it will end up forcing the evaluation of a large part of the structure, because in order to evaluate v you may have to evaluate a lot of the center.
14:04:42 <matthew-_> no. Also, I don't understand why they used Maybe on the view stuff and not MonadPlus
14:05:23 <sjanssen> DRMacIver: it's to combat space leaks, I'm sure
14:05:53 <DRMacIver> sjanssen: I don't follow why it would have that effect.
14:06:17 <sjanssen> DRMacIver: there's a 'v' attached to essentially every node in the FingerTree
14:06:37 <DRMacIver> Still not following. :)
14:06:44 <sjanssen> so you'd potentially build up a thunk of size O(n) in each node
14:07:02 <DRMacIver> Hm
14:07:32 <sjanssen> the spine of a FingerTree is always fully evaluated, IIRC
14:08:31 <DRMacIver> Then why is the center lazy?
14:09:18 <sjanssen> hmm, I'm not sure
14:09:28 <DRMacIver> I don't really follow the justification for why laziness helps finger trees to be honest.
14:09:42 <DRMacIver> I probably need to read Okasaki's stuff.
14:10:48 <DRMacIver> The core structure seems actually rather well suited to being strict, and now that I look at it they're not using the laziness in the parts where I thought it would be useful.
14:11:16 <DRMacIver> Laziness was suggested as helping amortize the cost of building the tree in the shared case, but I don't really follow why it does.
14:11:40 <sjanssen> DRMacIver: the paper does explicitly mention that only the middle needs to be lazy
14:12:09 <DRMacIver> sjanssen: Ok, I realise that, but in most of the use cases requiring the v field to be strict prevents that from actually working.
14:12:16 <sjanssen> page 7, last paragraph
14:12:22 <sjanssen> oh
14:13:01 <DRMacIver> Because the monoid being used is strict in its operation, so you need to completely evaluate the center in order to strictly evaluate that v field.
14:13:58 <DRMacIver> Unless I'm misunderstanding, which is very possible. :)
14:14:30 <dons> bos?
14:14:59 <bos> dons: how are you settling in?
14:15:15 <dons> i'm actually comitting patches now, so that's good
14:15:35 <dons> got a monitor today. so i'd say this week has been the first week of normalcy
14:15:50 <bos> i hear monitors can be useful
14:16:15 <dons> its funny writing a tiling window manager, but never needing to use tiling
14:16:22 <dons> but now i have a 19" lcd, so tiling is kinda useful
14:16:29 <DRMacIver> (Ok, I guess there's the obvious 'just use it as a sequence' monoid and measure instance for () )
14:17:12 <goalieca> does xmonad support virtual desktops?
14:17:18 <goalieca> that would be a cool feature
14:17:44 <sjanssen> goalieca: yes, xmonad has workspaces
14:18:17 <goalieca> wow. i'm going to have to try it out later tonight then
14:19:40 <dons> mod-1..n
14:21:16 <sjanssen> DRMacIver: I can't find any instances where 'Deep' is applied to a non-evaluated middle
14:21:17 * sorear invites goalieca to #xmonad
14:21:18 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
14:21:21 <sorear> @messages
14:21:21 <lambdabot> glguy said 13h 50m 9s ago: I added a patch to hpaste to help deter some of the spam that has been occurring lately, let me know what you think and consider restarting the daemon
14:23:12 <sjanssen> unless mappend is lazy in an argument
14:23:18 <sorear> glguy++
14:23:56 <DRMacIver> sjanssen: mappend is just the Monoiad type class's operation.
14:24:03 <sjanssen> right
14:24:19 <sjanssen> there are some monoids that are lazy in one argument
14:25:43 <DRMacIver> All the 'applications' listed in the paper look strict to me.
14:26:23 <DRMacIver> (other than the unit instance mentioned above)
14:26:35 <DRMacIver> I guess there are some things you could do with newtyped booleans that might be relatively lazy.
14:27:24 <jonathanv> haha does emacs seriously have an irc client
14:27:30 <sjanssen> DRMacIver: the Prio Monoid is conditionally lazy
14:28:28 <DRMacIver> Is it?
14:28:53 <DRMacIver> It doesn't look it to me. But maybe I'm being stupid.
14:30:20 <DRMacIver> (I probably really shouldn't be thinking about this until tomorrow. I'm not sure I'm up to rational thought this evening. :) )
14:31:12 <sjanssen> oops, it isn't
14:31:40 <sjanssen> I agree, none of them are lazy
14:31:59 <doserj> plus on Peano naturals would be lazy
14:33:37 <DRMacIver> Ok. I shall remain skeptical about the utility of laziness in this structure then. :)
14:34:18 <sjanssen> DRMacIver: you could add a ! and see what happens :)
14:34:37 <pejo> jonathanv, 22.0 has two of them included, iirc.
14:34:53 <jonathanv> not sure how i feel about that
14:36:02 <DRMacIver> sjanssen: True.
14:36:18 <DRMacIver> Hm. I *really* don't see why Data.Sequence follows suit and has the center lazy.
14:37:53 <DRMacIver> (It uses Int with + as the monoid)
14:52:23 <DRMacIver> sjanssen: Oh, the ordered sequences application is partially lazy.
15:02:14 * dons downloads all of hackage
15:02:33 <dons> let's get serious about this haskell thing :)
15:02:50 <jonathanv> i'm not ready
15:02:58 <timthelion> dons: isn't that a diss to the productivity of the haskell comunity, I mean, that you can...
15:03:22 <timthelion> or is that a compliment to the cleanness and consiseness of the code?
15:03:25 <dons> its pretty big -- i can only do it because i'm in the same building as hackage.haskell.org itself :)
15:03:39 <timthelion> oh, where's that?
15:03:39 <dons> and can get at the archive via ssh
15:03:47 <dons> its hosted at galois
15:04:03 * dolio needs to update CC-delcont.
15:04:14 <dons> makes building lambdabot easier, when all possible dependencies are on disk already
15:05:13 <nominolo> how much is all of hackage?
15:05:23 <dolio> The version on hackage only builds with an unspecified version from somewhere in the 6.7 branch. :)
15:05:48 <dons> 180M of .tar.gz
15:06:04 <nominolo> yeah.  i figured it can't be that much
15:06:20 <timthelion> so you're in the us now...
15:06:24 <dons> yeah
15:06:25 <dons> OR
15:06:32 <nominolo> EGON
15:06:59 <dons> Igloo: do we have scripts to download all of hackage, and check a ghc release candidate builds with everything? ...
15:07:01 <timthelion> so you're only in the northwest.
15:07:14 <dolio> VENKMAN?
15:07:34 <dons> i'm only in the northwest.
15:07:40 <Igloo> dons: I don't
15:07:53 <dons> i have all of hackage here. and a ghc release candidate
15:07:53 <timthelion> I don't really recognise the US's claim to the northwest.  I think we should be our own country :)
15:07:56 <nominolo> dons, wasn't that a SoC project?
15:07:57 <dons> i should do something with that
15:08:06 <sjanssen> dons: I bet all of hackage doesn't build with 6.6
15:08:06 <goalieca> canada will annex you if you like
15:08:19 <timthelion> really?
15:08:24 <goalieca> sure why not
15:08:35 <dolio> sjanssen: I guarantee it. :)
15:08:36 <goalieca> are you referring to the whole cascadia thing?
15:08:37 <timthelion> I don't think the us would let us
15:08:53 <timthelion> seatle is pretty strategic.
15:08:55 <goalieca> washington state has nukes.. we have a problem with that... they'll have to be used up first :P
15:09:07 <kaol> does the northwest have any oil?
15:09:16 <goalieca> northwest has a port and trees
15:09:19 <timthelion> we have enough nukes to blow up the world 75 times over!
15:09:19 <nominolo> is alaska northwest?
15:09:24 <atomb> and lots of beer!
15:09:31 <atomb> at least portland does
15:09:39 <timthelion> seatle doesn't
15:10:04 <timthelion> canada wouldn't want oregon, it's too hot there.
15:10:04 <goalieca> oregon has the worst beer in the world. Low percentage and tiny cans
15:10:15 <goalieca> and crappy beer too.. like coors
15:10:17 <sorear> so, how long until Galois starts selling Hackage on CDs?
15:10:33 <dons> goalieca: i think you've seen the wrong part of oregon
15:10:36 <dons> sorear: oh, that's a great idea!
15:10:39 <timthelion> does galios own hackage?
15:10:49 <dons> what's to own?
15:10:53 <atomb> galois hosts it
15:11:00 <atomb> i guess they own the computer?
15:11:04 <goalieca> dons: which part has good beer? honestly. its all so awful
15:11:14 <timthelion> well they wouldn't be allowed to make profit off it would they?
15:11:16 <atomb> they = we, i guess
15:11:21 <dons> goalieca: the 500 micro breweries produce a few nice drops
15:11:29 <dons> i've only had good beer here so far (mostly)
15:11:33 <atomb> i agree with dons
15:11:35 <goalieca> dons: microbrews always have good beer
15:11:36 <sorear> timthelion: most of hackage is licensed under BSD3 or GPL, both of which allow sale
15:11:39 <elliottt> dons: where's the bad beer? :)
15:11:46 <dons> goalieca: and oregon is all about micro breweries
15:11:53 <Igloo> timthelion: I haven't checked all the licences, but I think anyone would be able to sell a CD of hackage
15:11:55 <elliottt> and wine production...
15:11:57 <timthelion> sorear: I thought gpl was distribution cost only
15:12:03 <dons> elliottt: well, i had an organic squash beer called `greg'. that was a bit ... weird.
15:12:11 <elliottt> yeah, i would imagine so...
15:12:15 <goalieca> dons: vancouver has granville island.. mmmmmm
15:12:26 <goalieca> but quebec has unibroue
15:12:35 <dons> it seemed like a good idea at the time, elliottt :)
15:12:38 <jonathanv> are you canadian?
15:12:40 <sorear> http://www.gnu.org/licenses/gpl-faq.html#DoesTheGPLAllowMoney
15:12:42 <lambdabot> Title: Frequently Asked Questions about the GNU GPL - GNU Project - Free Software Found ...
15:12:43 <atomb> you can charge as much as you want for gpl software. you just have to make the source available for download for free, as well. and not make any restrictions on distribution after sale.
15:12:50 <timthelion> washington has a microbrewery on every corner, but they never produce more than enough for the groups of friends that run them, so there's no surplus of beer here.
15:12:55 <elliottt> dons: rogue makes a really strange tasting smoked beer
15:13:34 <goalieca> yaletown has a beer that tastes like citrus
15:13:39 <goalieca> chick drink but tastes really good
15:14:12 <goalieca> i like frothy heavy tastes-like-a-meal beers
15:14:13 <elliottt> goalieca: a ruby?
15:14:29 <goalieca> not sure what it is called
15:14:45 <goalieca> i always drink ales myself.
15:16:00 <timthelion> hmm, this Galois company sounds scary. like drm scary.
15:16:52 <Igloo> timthelion: In what way?
15:17:30 <timthelion> well isn't cryptography by definition a closed thing?
15:17:42 <ddarius> timthelion: That makes no sense.
15:17:42 <dons> hmm?
15:17:45 <elliottt> not if you do it right :)
15:17:55 <atomb> the best cryptography works well as open-source
15:17:57 <Igloo> No, bad cryptography relies on being closed
15:18:38 * ddarius hugs his CAC card, which falls apart.  Piece of shit.
15:18:50 <olsner> it's not good cryptography if it relies on or even benefits from being closed ;-)
15:19:41 <Cale> Heh, their little graphics at the top of the pages have someone working out an integral.
15:20:07 <Cale> http://www.galois.com/c-challenges.php
15:20:08 <lambdabot> Title: Challenges in Cryptography
15:20:21 <dons> i note the 'people' page is out of date
15:20:23 <Cale> (also http://www.galois.com/methods.php)
15:20:24 <lambdabot> Title: Methods
15:20:30 <dons> about half the company is missing from that list :)
15:20:40 * ddarius has never done math on graph paper.
15:21:44 <coffeemug> hey dons
15:21:45 <Cale> ddarius: It's handy for combinatorics where you have lots of Ferrers' diagrams for partitions :)
15:22:06 <coffeemug> is your uni email still working
15:22:08 <coffeemug> ?
15:23:22 <Cale> (Or Young diagrams)
15:23:36 <Cale> http://en.wikipedia.org/wiki/Young_tableau
15:23:38 <lambdabot> Title: Young tableau - Wikipedia, the free encyclopedia
15:24:04 <coffeemug> finally a company that appreciates mathematics :)
15:24:47 <coffeemug> it's funny how when you read a company's website or go to their interview it seems like you're dealing with geniouses who do rocket science
15:25:02 <coffeemug> but when you actually join it turns out they're just plain people doing plain stuff
15:25:12 * ddarius slowly gets farther and farther behind on the Haskell-Cafe mailinglist.
15:25:17 <coffeemug> I wonder if that holds true for all companies :)
15:25:26 <ddarius> coffeemug: Nope.
15:25:49 <timthelion> what company are you refering to coffeemug?
15:26:12 <coffeemug> in this case Galois
15:26:31 <coffeemug> it sounds like they do really cool stuff
15:26:37 <coffeemug> I wonder what it's like in practice :)
15:26:43 <dons> hey, we do do cool stuff!
15:26:50 <atomb> and it's in Haskell
15:26:55 <elliottt> that's the best part :)
15:26:56 <coffeemug> sorry, sorry :-D
15:27:00 <atomb> (or PHP) :-P
15:27:26 <coffeemug> yeah, they probably do all their cryptography and analysis software in PHP
15:27:32 <coffeemug> but claim it's Haskell :)
15:27:50 <olsner> given the haskell part, I think they're much more likely to be geniuses than the people at most other companies
15:27:51 <timthelion> I can't imagine having a job where I did haskell. purely functionality makes my head hurt.
15:28:21 <timthelion> I think if I worked there I would decide I was stupid and become depressed.
15:28:27 <coffeemug> timthelion: what if you did it in a purely functional language with dynamic typing? :)
15:28:37 <Cale> timthelion: No, you'd just become smarter :)
15:28:41 <timthelion> coffeemug: huh?
15:28:48 <olsner> coffeemug: don't give people strange ideas now!
15:29:09 <coffeemug> timthelion: you know, no assignment operator and no static type system either
15:29:13 <coffeemug> would you find that easier? :)
15:29:24 <timthelion> no
15:29:30 <timthelion> not at all
15:29:32 <coffeemug> timthelion: but why not?
15:29:38 <coffeemug> you'd just use the state monad
15:29:48 <ptolomy> I'm working on a multithreaded large (35k+ lines) C++ server, and I'm a little annoyed by trying to manage the multitude of locks; public methods get called from all sorts of threads, there are a lot of locks, and it is mostly manual locking and non-recursive mutexes. I keep thinking, "It'd be nice to be able to statically verify that certain portions of critical section aren't being wrongly...
15:29:49 <ptolomy> ...addressed... hmm.. sounds like a job for.. MONADS."  Has anyone played with such an idea (in haskell)?
15:30:21 <coffeemug> ptolomy: sounds like a job for Erlang or Haskell's STM
15:30:23 <Cale> ptolomy: We've transcended locks :)
15:30:33 <ptolomy> (Using monads to deal with critical section access or ensure that stuff that touches certain methods/data get a different type)
15:30:42 <Cale> ptolomy: Have you looked at STM?
15:30:52 <ptolomy> Yep.
15:31:03 <ptolomy> I'm familiar with STM, but not the underlying stuff.
15:31:23 <coffeemug> STM is still shared concurrency
15:31:32 <coffeemug> I'd cast my vote for shared-nothing concurrency
15:31:32 <matthew-_> there's also a lot of work going on with region type systems, ownership types and so forth and lock inference
15:31:34 <Cale> coffeemug: so is message passing :)
15:31:39 <timthelion> didn't peyton make a speech at oscon about that?
15:31:43 <coffeemug> message passing, not so much :)
15:31:53 <Cale> coffeemug: shared-nothing should really refer to the kind of concurrency where you share *nothing*
15:31:59 <matthew-_> STM is really not considered any sort of meaningful solution these days
15:32:12 <ptolomy> I'm thinking a bit more like monads for security permission-levels or something..
15:32:20 <coffeemug> Cale: but shared implies shared memory, not shared data
15:32:22 <matthew-_> it makes some things prettier, but it's really not a lasting solution or utopian achievement
15:32:35 <Cale> coffeemug: Same thing :)
15:32:52 <Cale> Of course, it gives you more control over exactly what is shared, and when.
15:32:53 <coffeemug> in some ways, may be
15:33:07 <Cale> But it's not as different as some people make it sound
15:33:10 <matthew-_> I personally think the message passing ideas will be much longer lasting...
15:33:17 <Cale> It also doesn't solve a lot of the problems which STM does.
15:33:20 <coffeemug> with erlang if you want to share something you create a process that manages that resource
15:33:25 <coffeemug> and answers queries about it
15:34:04 <ptolomy> I'm still not clear on how message passing concurrency is supposed to efficiently handle atomicity stuff.
15:34:16 <coffeemug> the problem with that though, if you have a manager for a large resource (say, a large db table), you syncrhonize access to it
15:34:24 <coffeemug> because of message queueing
15:34:28 <coffeemug> so I don't know
15:34:31 <coffeemug> that point is moot
15:34:31 <coffeemug> :)
15:34:57 <Cale> There are still problems when it comes to making multiple working programs work together.
15:35:20 <Cale> You still end up needing a transactional system of some sort quite often.
15:35:42 <coffeemug> well
15:35:49 <coffeemug> STM just describes semantics
15:35:54 <coffeemug> you could still implement it using locks
15:36:00 <Cale> and usually that means an ad-hoc sort of transaction-handling process which separates the involved subsystems to be combined from the rest of the program
15:36:00 <coffeemug> or using copying memory
15:36:05 <coffeemug> or using something else
15:36:07 <Cale> right
15:36:27 <coffeemug> though I'm not sure what something else would be
15:36:52 <coffeemug> some hardware solution I suppose
15:37:29 <Cale> It could be something complicated, where the compiler actually compiles different transactions somewhat differently. (But obviously in compatible ways)
15:38:06 * sorear prefers `par` over all shared schemes
15:38:10 <Cale> The thing which I like about STM is that it doesn't really tell you how the things should be implemented, which means that compiler writers have some room to improve things in the future.
15:38:26 <Cale> sorear: right, *that's* shared-nothing :)
15:38:41 <Cale> Concurrency without sharing is parallelism.
15:38:56 <coffeemug> Cale: Common Lisp spec also doesn't tell compiler implementors how to implement Common Lisp, which is why I spent the past two weeks porting my project to 5 commonly used implementations
15:39:03 <coffeemug> I don't want to go through the same thing with STM :)
15:39:04 <Cale> heh
15:39:14 <ddarius> ptolomy: You want to look at separation logic.
15:39:28 <Cale> Well, the paper says what you're allowed to assume about the way that STM works.
15:39:44 <goalieca> wow: http://scienceblogs.com/loom/2007/09/21/mathematical_markings.php
15:39:46 <Cale> and it does give you enough that you should be okay :)
15:40:55 <Cale> coffeemug: It's like worrying about the semantics of the garbage collector. Usually you're not going to worry about it. :)
15:41:03 <lokik> how do I declare an instance declaration for (Bits String) ?
15:41:08 <Cale> (the low-level implementation, that is)
15:41:18 <coffeemug> Cale: yeah, and then you get memory leaks in Java
15:41:29 <coffeemug> and you say "but I thought Java has GC!!!"
15:41:35 <Cale> instance Bits String where
15:41:38 <Cale>  ...
15:41:48 <lokik> er should i paste?
15:41:54 <coffeemug> do some research and realize you can still leak memory if you don't set stuff to null :)
15:42:10 <Cale> Then in the instance block, you need to define (.&.), (.|.), xor, complement, shift, rotate, bitSize and isSigned
15:42:16 <dons> http://video.google.co.uk/videoplay?docid=9139666903029663537&hl=en-GB
15:42:19 <dons> haskell games.
15:42:29 <Cale> dons: already reddited
15:42:34 <sorear> coffeemug: doesn't the CL spec say that 2 + 2 = 4??
15:42:35 <ptolomy> dons: I didn't see the video but I read the paper.. did they really write that DEFCON game in Haskell?
15:42:35 <twanvl> You could instead define instance Bits a => Bits [a] and instance Bits Char
15:42:44 <ptolomy> (their website doesn't say, which is reasonable)
15:42:49 <Cale> dons: but it could use some upmods, last I checked...
15:43:07 <matthew-_> ptolomy: be careful. what we wrote in Haskell will eventually become a CLONE of defcon
15:43:12 <sorear> dons: pdf? :)
15:43:14 <coffeemug> sorear: that it does :)
15:43:17 <ptolomy> ahhh...
15:43:20 * ptolomy gets it.
15:43:21 <matthew-_> it's not /the/ defcon game from introversion that you can download and play
15:43:36 <matthew-_> I really hope that doesn't become a common confusion
15:43:52 <matthew-_> /the/ defcon game is written in C++
15:43:59 <dons> http://programming.reddit.com/info/2s7o9/details
15:44:10 <Cale> http://programming.reddit.com/info/2s6r2/comments
15:44:10 <ptolomy> matthew-_: I just read the slide that had a link, then I visited it.
15:44:22 <dons> i added it here, http://haskell.org/haskellwiki/Video_presentations#Games
15:44:24 <hpaste>  loki annotated "random number generator" with "Bits String instance lack" at http://hpaste.org/2837#a4
15:45:39 <lokik> would be easiest to store as ASCII string in file
15:46:09 <Cale> lokik: I don't think I understand what it is that your code wants to do.
15:46:11 <lokik> like from my perspective anyways
15:46:14 <matthew-_> ugh. And today I fixed various texture mistakes and got trilinear filtering and anisotropic filtering working too!
15:46:18 <Cale> What is it that .|. is supposed to do for strings?
15:46:27 <lokik> well i just want it to see the bits in the string
15:46:36 <lokik> it doesn't matter what the text is
15:46:45 <sorear> Cale: in Perl, it's zipWith (\a b -> chr (ord a .|. ord b))
15:46:54 <lokik> then i could use shakespear as random seed
15:47:18 <Cale> I suppose you could write a Bits instance which converted the characters to Ints using fromEnum
15:47:29 <Cale> and then applied the operations character-wise
15:47:45 <ddarius> That's what sorear just did.
15:48:07 <lokik> @hoogle fromEnum
15:48:19 <lokik> ddarius: really? where
15:48:27 <lokik> ?
15:48:42 <ddarius> [17:45] <sorear> Cale: in Perl, it's zipWith (\a b -> chr (ord a .|. ord b))
15:48:53 <lokik> ait
15:49:13 <Cale> Yeah, and take twanvl's suggestion and write an instance Bits a => Bits [a]
15:49:25 <lokik> Cale: where could i see an example instance declaration?
15:49:46 <Cale> You just write:
15:49:48 <Cale> instance Bits Char where
15:49:50 <Cale>   ...
15:50:03 <Cale> where ... is the function declarations for the methods of Bits
15:50:17 <Cale> Minimal complete definition: .&., .|., xor, complement, (shift or (shiftL and shiftR)), (rotate or (rotateL and rotateR)), bitSize and isSigned.
15:50:57 <Cale> hmm, surely it also needs 'bit'?
15:51:06 <ddarius> :t bit
15:51:23 <ddarius> @bot
15:51:56 <timthelion> um, if I have a function which returns an IO String, say it reads a file. if I don't want to have that file read each time I want that functions value, do I have to use Reader?  or is there a better caching method?
15:52:07 <Cale> Oh, Bits requires Num
15:52:23 <Cale> timthelion: an IO String is not a String
15:52:32 <Cale> It's a computation which you run in order to produce a String
15:52:49 <Cale> So you should run it once, and then pass the String you get around.
15:53:01 <sorear> Too bad you can't just say   derive instance Bits Char
15:53:06 <timthelion> yes, but can I assign a function to the value gotten by doing that action at program initialization?
15:53:22 <sorear> since Char isn't a newtype, it's a completely separate primitive :(
15:53:37 * sorear really wonders what motivated Char#, ord#, chr#, etc
15:53:42 <Cale> timthelion: Not without low-level, slightly-dangerous hackery
15:53:47 <timthelion> sorear: unicode?
15:53:53 <sorear> timthelion: eh?
15:54:48 <sjanssen> sorear: stronger typing, I suppose
15:54:56 <timthelion> Char should be it's own privat and highly clugy entity, because that' s what a char is, it's a char(which is inherently weird and hard to deal with generically) and not a byte or anything else
15:55:01 <Cale> timthelion: So there, you might want a Reader monad, but it's probably simplest at first just to pass the thing around manually.
15:55:06 <lokadin> bah internet disconnected
15:55:22 <lokadin> all i got was: instance Bits Chars where
15:55:33 <lokadin> Char*
15:56:08 <Cale> timthelion: That is, in every function which needs access to that string, tack on an additional parameter for it.
15:56:11 <lokadin> where would i put that in relation to the other function?
15:56:23 <timthelion> Cale: that's just insane.
15:56:31 <Cale> timthelion: why is that?
15:56:40 <kpreid> lokadin: you can read what you missed at http://www.ircbrowse.com/channel/haskell/today
15:56:50 <lokadin> k thanks :)
15:56:51 <timthelion> Cale: it's just not nice.
15:56:57 <Cale> timthelion: If you have hundreds of such Strings, you might want to build a Map or Set of them.
15:57:02 <Cale> (or just a list)
15:57:13 <xerox> Cale: anyway Reader is not much boilerplate
15:57:32 <Cale> xerox: yeah, but it's good to get a sense of where it's needed and where it's not really needed
15:57:43 <timthelion> I'm trying to figure out how to make a generic deamon shell, for all haskell applications.
15:58:10 <timthelion> xmonad is a good example, of what I see as a deamon which has failed because of that kind of passing.
15:58:29 <timthelion> you see, it's very dissruptive to change the state, which gets passed to layouts.
15:58:48 <timthelion> you have to re-write the layouts, every time you add something to the state.
15:58:58 <timthelion> because the layouts get passed the state.(or part of it)
15:59:09 <Cale> Hmm, not if you use record syntax consistently.
15:59:44 <timthelion> so I'm trying to figure out a better way, I take it that this better way is the Reader, but the Reader has problems, like in the function, you don't declare what gets read
16:00:00 <timthelion> Cale: was that to me?
16:00:03 <Cale> yeah
16:00:10 <timthelion> what do you mean?
16:00:22 <Cale> Well, if you have a record type... say
16:00:41 <Cale> data MyState = MS { foo :: String, bar :: Integer }
16:00:53 <Cale> and pass that around
16:01:18 <Cale> then things which access it can either pattern match using record syntax, or use the field extractors foo and bar
16:01:28 <timthelion> example?
16:01:29 <sorear> timthelion: what you want is first-class modules
16:02:06 <Cale> f (s @ MS { foo = f }) = s { foo = reverse f }
16:02:11 <Cale> er
16:02:16 <Cale> shouldn't have called the function f :)
16:02:25 <Cale> reverseFoo (s @ MS { foo = f }) = s { foo = reverse f }
16:02:49 <Cale> This will update the foo part of the state, so that it's reversed.
16:03:14 <Cale> It will work even if additional fields are added to the state type later.
16:03:47 <Cale> Does that make sense?
16:03:57 <timthelion> that way if you redefine MS to be { foo :: String, bar :: Integer, eggplant :: Vegitable } one doesn't have to re-write the funtion reverseFoo?
16:04:08 <Cale> yeah
16:04:23 <timthelion> no changes needed at all?
16:05:24 <kpreid> one can also do it without the record syntax; define your data type and extractFoo and updateFoo functions for every field foo
16:05:25 <timthelion> the order of foo = f bugs me
16:06:29 <timthelion> kpreid: is there a dissadvantage to record syntax?
16:11:35 <lokadin> i'm looking at the Data.Bits source for instance declaration examples, and there are all these lines starting with #'s do I need to use those?
16:12:24 <lokadin> when declaring,  instance Bits Char where
16:12:38 <timthelion> I love named pipes, however, I think it's a bad practice to have a file in /tmp/ for every singe program, am I correct in this thinking?
16:13:07 <ecksit> hello, is there any way in haskell i can save output from a function
16:14:10 <ecksit> into a constant
16:14:32 <coffeemug> ecksit: you mean like x = someFunction someArg1 someArg2
16:14:33 <coffeemug> ?
16:14:57 <coffeemug> everything after the "like" :)
16:15:01 <timthelion> ecksit: a function is a constant :)
16:15:05 <ecksit> yeah, like x = ((length xs ) `div` 2)
16:15:25 <coffeemug> ecksit: so why can't you say what you typed here?
16:15:33 <coffeemug> except I'd remove the outermost parens :)
16:15:59 <lokadin> Cale: ?
16:15:59 <omniscientIdiot> ecksit: it'd need to have access to an 'xs'.  If you want you use a name as part of a larger expression, use a 'let'.
16:16:02 <ecksit> it says parse error on input '='
16:16:06 <EvilTerran> and the innermost. function application binds tightest.
16:16:20 <omniscientIdiot> ecksit: in ghci?
16:16:22 <EvilTerran> > let (<,) = const (const "test") in 1 <, 2
16:16:33 <ecksit> omniscientIdiot: yea
16:16:34 <EvilTerran> @bot
16:16:51 <EvilTerran> ecksit, tack "let " onto the beginning
16:16:54 <ecksit> oh, so u use let
16:17:32 * EvilTerran notes that of course that test wouldn't work, even if the bot were alive, because that thing on the left of the = looks like a malformed tuple
16:17:50 * omniscientIdiot was thinking the same
16:18:22 <ecksit> thanx
16:18:49 <timthelion> is socket programming easy?
16:20:07 <edwardk> @seen lambdabot
16:20:09 <edwardk> =)
16:20:21 <omniscientIdiot> @bot's dead :(
16:20:31 * edwardk mourns.
16:20:34 <Lemmih> That's a 'no', then?
16:23:51 <coffeemug> > are you dead?
16:23:57 <coffeemug> he is!
16:23:59 <coffeemug> :(
16:24:56 <kpreid> lokadin: the # stuff is conditional inclusion in the style of the C preprocessor, because these library files are used in multiple haskell implementations. you don't need to use it
16:25:17 <sorear> coffeemug: this is why you should never blanket-ignore PART messages
16:25:26 <sorear> coffeemug: 16:12 -!- lambdabot [i=dons@pill01.orchestra.cse.unsw.EDU.AU] has quit [Read error: 110 (Connection timed out)]
16:25:31 <lokik> kk well i hope my random guessing is going to work :-)
17:04:38 <SeanMcE> 	Couldn't match expected type `ByteString' against inferred type `IO ByteString'
17:05:02 <SeanMcE> I'm trying to putStrLn and I got this message
17:05:31 <sjanssen> welcome to Haskell and the IO Monad :)
17:06:06 <sjanssen> say your code is "putStrLn foo", you need to write "do x <- foo; putStrLn x"
17:07:23 <SeanMcE> thanks, I'll try it
17:07:42 <sorear> SeanMcE: or, putStrLn =<< foo   if you don't like introducing meaningless names
17:30:59 <ramza3> thoughtpolice, how is austin?
17:31:08 <ramza3> doing that is
17:31:54 <ramza3> is there a haskell channel for noobs, haskell cafe or something
17:32:35 <notsmack> ramza3: i think this is your best bet
17:32:37 <jrcapa> hello... could anyone give me some tips on how to write a kind of "macro-expanding" parser
17:32:55 <ramza3> notsmack, haskell-cafe mailing list isn't too bad
17:33:43 <EvilTerran> this place tries to be noob-friendly
17:34:03 <ramza3> EvilTerran, hehe, as long as the noobs are friendly, too right?
17:35:20 <EvilTerran> there is that. I know we should do our best to recruit everyone into the Haskell army, but personally, i'll leave recruiting B1FF up to someone else
17:36:09 <olsner> who's b1ff?
17:36:24 <jrcapa> i want to get started with haskell/parsec/compilers all at once
17:37:27 <olsner> 'tis not that hard... start out with a grammar, refactor to remove left-recursion, and you're basically all done (just add a little bit of syntax)
17:38:00 <jrcapa> olsner: i saw some rather elegant code, but always for parsing scheme or lisp, that are easy to parse (i guess)
17:38:11 <thoughtpolice> ramza3: ? i am austin.
17:38:28 <jrcapa> i want to parse something like this :
17:38:28 <jrcapa> bleh: for i in 0 to (A/8)-1 generate
17:38:28 <jrcapa>     sig_tab(i) <= sig(((i+1)*8)-1 downto i*8);
17:38:28 <jrcapa> end generate;
17:38:47 <ramza3> thoughtpolice, your connection string looked it came from austin
17:38:48 <EvilTerran> http://catb.org/jargon/html/B/B1FF.html
17:38:58 <EvilTerran> olsner, /\
17:39:11 <thoughtpolice> ramza3: ? have we met?
17:39:24 <thoughtpolice> sorry, i just must be really bad with monikers
17:39:28 <olsner> oh, the original troll, eh?
17:41:47 <bos> the feedback we've been getting for the first chapters of the book has been outstanding. very detailed and thoughtful comments from many, many people.
17:42:15 <olsner> is that the real-world haskell book?
17:43:35 <olsner> ah yes, the nick does correspond to the initials of the author of the blog posts there ;-)
17:53:28 <dons> working at galois is great. i'm having so much fun.
17:53:42 <dons> getting paid to write cool software in haskell is nice :)
17:53:56 <dons> sjanssen: you looking for a job yet? :)
17:54:13 <mrd> what do they have ya doin
17:54:21 <Igloo> Hah, I was about to ask if we could infer you were on the look out for new recruits  :-)
17:54:36 <dons> can't talk about it yet :(
17:54:44 <dons> but there's lots of haskell. *lots*
17:54:53 <dons> we actually got an internal hackage setup running today
17:55:06 <dons> hopefully more libs will make their way outside now that we know what's available inside galois
17:55:27 <dons> Igloo: i think they always want new recruits
17:55:39 <Igloo> Heh, true
17:55:44 <olsner> where's galois located?
17:55:45 <dons> there's a lot of new people here
17:55:51 <dons> portland, oregon, olsner
17:55:54 <edwardk> dons @ galois? congratulations
17:56:02 <dons> :)
17:56:10 <Igloo> Are you R&D or engineering, dons?
17:56:23 <dons> Igloo: my business card say: research, development, engineering   :)
17:56:38 <Igloo> I guess that's a "yes"  :-)
17:57:38 <dons> hacking the interwebs with haskell :)
18:03:01 * wli wishes he were non-burned-out enough to do such things.
18:04:49 <njbartlett> dons: You on H1B?
18:09:27 <hpaste>  ryani annotated "hmm, why aren't those there paterns exauhstive?" with "(no title)" at http://hpaste.org/2843#a1
18:13:43 <EvilTerran> yeah, let{}s over several lines in a ghci prompt/do block aren't mutually recursive
18:14:02 <EvilTerran> (although any bindings within any one such let{} are)
18:14:05 <dons> njbartlett: E3 (similar, but better, but .au only)
18:14:21 <sorear> People seem to think you can just prefix every line with let
18:14:39 <njbartlett> dons: Really, the US has special visas for Aussies?
18:14:52 <njbartlett> Too late :-)
18:15:00 <EvilTerran> no, sorear, *I*'m an imperative programmer! ;)
18:15:43 <sorear> @seen shapr
18:15:49 <sorear> oh right
18:16:05 <timthelion> @
18:16:22 <timthelion> sorear-lambdabot: hello
18:16:23 <sorear> don't even try >
18:16:38 <timthelion> try what?
18:16:39 <sorear> if you do, I'll expect a patch fixing hs-plugins
18:17:03 <timthelion> I don't know what you're talking about
18:17:19 <sorear> timthelion: you don
18:17:21 <EvilTerran> @bot ?
18:17:22 <sorear-lambdabot> :)
18:17:27 <sorear> 't know what > does to lambdabot?
18:17:29 <sorear> *faint*
18:17:39 <timthelion> oh
18:17:40 <timthelion> that
18:17:47 <timthelion> does that not work?
18:18:03 <sorear> nope
18:18:13 <timthelion> it used to eval an expression no?
18:18:16 <sorear> hs-plugins is horribly broken in the presense of multiple GHC versions
18:18:25 <sorear> I have at least 13
18:18:31 <sorear> dons, apparently, has 1
18:19:01 <timthelion> oh, why not reformat/reinstall? or are all those ghc's installed in home?
18:19:18 <sorear> reformat?
18:19:29 <timthelion> you only need one ghc no?
18:19:37 <sorear> no
18:19:44 <timthelion> why?
18:19:58 <sorear> lots of programs use unstable interfaces
18:20:05 <sorear> besides, bug regression
18:20:16 <timthelion> hmm?
18:20:25 <timthelion> why don't you use just the latest?
18:20:44 <P_D> Is there something resembling a sleep action in IO?
18:20:49 <EvilTerran> @hoogle sleep
18:20:50 <sorear-lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
18:20:50 <sorear> threadDelay
18:20:56 <sorear> @hoogle threadDelay
18:20:56 <sorear-lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
18:21:03 <EvilTerran> that looks better
18:21:06 <EvilTerran> @docs System.IO
18:21:07 <sorear-lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
18:21:28 <P_D> Gtk2Hs throws FUD over multithreading
18:21:56 <sorear> it should!
18:22:19 <sorear> wait, what are you talking about?
18:22:47 <sorear> Control.Concurrent has *absolutely* *nothing* *whatsoever* *to* *do* *with* *the* *threaded* *runtime*
18:23:21 <lokik> how do I add instance decleration for Num Char ?
18:23:29 <lokik> i've just made Bits Char
18:23:39 <P_D> OK, so what is the significance to "thread" in "threadDelay"?
18:23:40 <sorear> lokik: what does it mean to negate characters?
18:23:46 <sorear> P_D: Haskell threads
18:23:48 <lokik> ?
18:24:02 <sorear> P_D: Which are an entirely unrelated concept which happens to have the same name.
18:24:09 <lokik> sorear: seems like a cryptic reply
18:24:18 <EvilTerran> sorear, the same as it would to negate Word8s, say
18:24:36 <lokik> a char is a string of bits
18:25:01 <lokik> can get it's complement
18:25:10 <sorear> lokik: no, a character is a single abstract letter, like 'A' or '×'
18:25:17 <lokik> *shrugs*
18:25:29 <lokik> glyphs aren't my intended purpose
18:25:44 <lokik> it's just easier to store strings than int's
18:25:47 <EvilTerran> lokik, would, perhaps, something from Data.Word be more appropriate?
18:26:02 <lokik> not sure
18:26:08 <Cale> Why not use lists of Word8's then?
18:26:09 <sorear> lokik: why is [Char] better than [Int] ?
18:26:22 <sorear> pssh, Char /= Word8
18:26:29 <sorear> > maxBound :: Char
18:26:30 <sorear-lambdabot>      Failed to load interface for `Control.Parallel':
18:26:30 <sorear-lambdabot>       Use -v to see a l...
18:26:38 <P_D> Does threaded RTS mean that Haskell threads are implemented as OS threads?
18:26:40 <sorear> @slap hs-plugins
18:26:40 <sorear-lambdabot> why on earth would I slap hs-plugins
18:26:46 <sorear> P_D: No
18:26:51 <lokik> because String = [Char]
18:26:53 <sorear> P_D: It uses a load-balancing system
18:26:53 <EvilTerran> sorear, i never said it was. only that it has more predictable serialisation semantics than Int
18:26:54 <Cale> sorear: I know, but it seems like that's what's wanted.
18:26:57 <ari> @remember sorear hs-plugins is horribly broken in the presense of multiple GHC versions, I have at least 13
18:26:57 <sorear-lambdabot> Done.
18:27:09 <EvilTerran> no worries about system word lengths, endianness, etc
18:27:11 <P_D> Same threads though, with different implementation?
18:27:17 <timthelion> it seems to me that at least half the info avalible on haskell exists in the for of people describing what is wrong with the current system and how their proposal makes it better
18:27:32 <sorear> right
18:27:37 <lament> timthelion: love is the desire to improve.
18:27:46 <P_D> OK, that helps.
18:28:13 <Cale> timthelion: Haskell is still for the most part a research language :)
18:28:14 <timthelion> lament: shall I tell that to the next girl I attempt to please?
18:28:21 <lokik> hmmm what's the page for Data.Word
18:28:22 <lokik> ?
18:28:29 <Cale> timthelion: So many things are documented with papers :)
18:28:32 <lament> timthelion: you could try...
18:28:51 <EvilTerran> @docs Data.Word
18:28:51 <sorear-lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
18:28:52 <Cale> You can't get a good paper out of not solving a problem :)
18:29:16 <lament> Abstract: All the problems have been solved, and there's nothing to do.
18:29:50 <lokik> not so
18:30:18 <lokik> *shrugs* I'm making a new programming language based on scheme in haskell using lojban language
18:30:29 <timthelion> lokik: wow,
18:30:31 <lokik> so lots of tings to do
18:30:40 <lokik> :-)
18:30:43 <timthelion> lokik: do you have anything up in darcs?
18:30:47 <Cale> Definition 1.1. A programming language L is said to be _perfect_ when ... Proposition 1.2. Any two perfect languages are isomorphic.  Theorem 1.3: Haskell is perfect.
18:31:18 <sorear> meh, haskell doesn't even have first class modules
18:31:19 <wli> Monad comprehensions? The fail method in Monad?
18:31:24 <Cale> I'm joking.
18:31:25 <lament> Cale: i suspect 1.2 is similar or equivalent to the incompleteness theorem
18:31:27 <wli> Oh yes, the module fiasco.
18:31:37 <timthelion> lokik: that doesn't even make sence, I mean, lojban x<1's are not descriptors of x1 unlike what most people think.
18:31:44 <lokik> not at the moment, i've only started on the lojban syntax parser, have been working on some side RI projects recently
18:31:50 <timthelion> lokik: it really can't be done
18:31:58 <lokik> so < would be ze'a
18:32:02 <Cale> wli: This is regarding the complaint that many things in Haskell are documented in the form of proposals for fixing some issue.
18:32:12 <lokik> ( = vei,  ) = ve'o
18:32:13 <timthelion> lokik: and they already have the lojban sql frontend Ithink.
18:33:00 * EvilTerran notes that a lot that can be done with first-class modules can also be done with typeclasses
18:33:02 <lokik> and there are unlimited different kinds of quotes, zoi (quote-type) text (quote-type)
18:33:09 <timthelion> lokik: if you're just going to require the coder to learn a whole bunch of vocabulary, while butchuring lojbans only asset(it's grammar) I frankly cannot see the point.
18:33:36 <lokik> they will learn a lot less vocabulary technically
18:33:43 <lokik> and have much better grammar
18:33:49 <lokik> as it would produce code
18:33:54 <lokik> or be code
18:34:10 <lokik> could just read source code verbally
18:34:18 <timthelion> I never learned lojban, as it had far to much vocab work.
18:34:33 <timthelion> and there wasn't anyone I ever met who was comfortable with the grammar
18:34:34 <lokik> agreed, scheme doesn't have much vocab
18:34:47 <lokik> i'm using the write scheme in 48 hours haskell tutorial
18:35:04 <lokik> instead of scheme keywords i use lojban
18:35:15 <lament> is scheme grammar anything like lojban? Doesn't seem so...
18:35:18 <timthelion> I try much harder at haskell, because I can look up to wizards like dons and sjanssen and see that they aren't just speaking jibberish.
18:35:34 <lokik> sure it is, lambda calculus is supported by lojban
18:36:01 <lament> oh, in that sense.
18:36:04 <lokik> yep
18:36:41 <wli> I'd start with H98 - monomorphism restriction + multiparameter typeclasses + higher-order modules, then spend a great deal of time making the compiler/interpreter intrinsics and standard library "perfect."
18:37:05 <lokik> for some $$?
18:37:24 <lokik> or?
18:37:28 <wli> Probably the best way to do it would be hacking on ghc.
18:37:37 <lament> lojban is kinda cute, it's like a linguistic equivalent of principia mathematica - "let's start from scratch and make everything clear and logical"
18:38:17 <Brian`> hello
18:38:23 <Cale> hi
18:38:32 <lament> it's stuck about 200 years in the past, in the era of neoclassicism
18:38:40 * Cale is thankful for GÃ¶del's incompleteness theorem.
18:38:42 <lament> "reason will prevail"
18:39:39 <timthelion> what is? lojban's only like 30 years old
18:39:45 <Brian`> what's the difference between function composition and function application?
18:39:49 <Brian`> i mean difference between . and $
18:39:56 <EvilTerran> :t ($)
18:39:57 <Cale> Brian`: the type, first of all
18:39:58 <sorear-lambdabot> forall a b. (a -> b) -> a -> b
18:39:59 <EvilTerran> :t (.)
18:40:01 <sorear-lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:40:07 <EvilTerran> @src ($)
18:40:08 <sorear-lambdabot> f $ x = f x
18:40:09 <EvilTerran> @src (.)
18:40:10 <sorear-lambdabot> (.) f g x = f (g x)
18:40:13 <Cale> Brian`: Function composition takes two functions and gives another function
18:40:13 <wli> lament: Anyone who thinks that does so in the face of numerous current events and long-term trends since 1950 or thereabouts.
18:40:17 <EvilTerran> the implementation's different, too ;)
18:40:28 <Cale> Brian`: Function application takes a function and a parameter for it, and applies the function to the parameter
18:40:46 <lament> wli: who thinks what, that reason will prevail or that lojban is silly?
18:40:57 <wli> lament: That reason will prevail.
18:41:01 <Cale> Brian`: ($) has the wrong associativity, so they can end up looking similar (which I and quite a few others think is actually a bad thing)
18:41:21 <Brian`> Cale : hm.. i c
18:41:32 <pjd> Cale: i've also been noticing that
18:41:33 <timthelion> I do not get how $ is different from f x
18:41:42 <lament> wli: right, it's a thoroughly obsolete point of view, which is why lojban is silly
18:41:46 <Cale> Presently, ($) is right associative, so f $ g $ h $ x = f $ (g $ (h $ x)) = f (g (h x))
18:41:48 <pjd> are there any cases where right-associative $ actually helps?
18:42:20 <Cale> pjd: very few -- basically, only those where you have other infix operators mixed in with the same precedence as (.)
18:42:50 <Cale> All others, you can always rewrite to use only one ($), and (.) otherwise.
18:43:07 <lament> wli: the best argument against lojban would be a mental experiment where it somehow becomes the native language of millions of speakers - and then you watch them make short work of its pretty grammar and logical structure
18:43:19 <Cale> f . g . h $ x = (f . g . h) x = f (g (h x)) as well.
18:43:31 <wli> lament: Not very interesting.
18:43:33 <timthelion> where in the deffinition of $ does it say that it is right associative?
18:43:35 <KatieHuber> is there no way to pass arbitrary flags through GHC to the system linker?
18:43:45 <sorear> -optl
18:43:46 <Cale> timthelion: there's an infixr declaration for it
18:43:52 <sorear> KatieHuber: -optl-foo
18:43:56 <Cale> timthelion: Usually near the top of the Prelude.
18:44:02 <KatieHuber> thanks
18:44:12 <Cale> infixr 0  $, $!, `seq`
18:44:20 <timthelion> oh,
18:44:23 <wli> lament: More interesting is fixing up compiler/deSugar/DsListComp.lhs and whatever else incidentally needs it so as to support monad comprehensions.
18:44:29 <Brian`> Cale : if Function Application takes a function and a parameter for it, and applies the function to the parameter, why does this not work? filter ((>0) $ fst)
18:44:29 <timthelion> that was not returned by @src
18:44:43 <Cale> Brian`: because (>0) wants a number
18:44:47 <Cale> and fst is not a number
18:44:49 <timthelion> which makes @src kinda pointless, as you can't really see what the function does
18:44:50 <lament> wli: point :)
18:45:02 <pjd> Brian`: you might want . in that case
18:45:06 <Brian`> Cale : oh.. i c...
18:45:18 <Cale> Yeah, (>0) . fst is a well typed function
18:45:19 <wli> Anyone else want to take a look at DsListComp.lhs here?
18:45:25 <Brian`> pjd : yeah i saw this example on Yet Another Haskell Tutorial and wanted to see if $ can replace .
18:45:35 <Cale> It takes a pair, the first component of which is a number, and compares that with 0.
18:45:40 <pjd> (0<) . fst means take the fst, then check whether it's 0<
18:45:58 <Brian`> Cale, pjd : gotcha :) thanks
18:46:10 <pjd> ((>0) $ fst) and ((>0) fst) are exactly the same, FWIW
18:46:47 <Cale> Brian`: Some people overuse ($), which I really don't recommend. If you find yourself writing an expression which contains more than one ($) in a row, consider replacing all but the last ($) with (.)
18:46:48 <pjd> (which then becomes (fst > 0), giving that error)
18:47:12 <Brian`> Cale : does that rule always work?
18:47:27 <Brian`> Cale : replacing all but the last ($) with (.) thing..
18:47:35 <EvilTerran> almost always
18:47:43 <Cale> Brian`: basically, so long as there aren't infix operators with just the wrong precedence mixed into your expression
18:47:44 <EvilTerran> it's a precedence thing
18:48:01 <Cale> The reason you want to switch is that (.) has nicer properties. It's associative, which means that f . (g . h) = (f . g) . h
18:48:09 <EvilTerran> if there's something of precedence lower than (or equal to) that of (.), things might go wrong
18:48:13 <Cale> So that gives you nicer possibilities for refactoring.
18:48:43 <Cale> If you have f $ g $ h $ x, the g $ h is meaningless
18:48:52 <Brian`> EvilTerran : could you give me a simple example if you can find one on top of your head?
18:48:58 <Cale> But if you have f . g . h $ x, then g . h is actually a meaningful function
18:49:02 <Cale> as is f . g
18:49:19 <Brian`> Cale : why is g $ h meaningless?
18:49:35 <Cale> Brian`: because presumably g and h are functions which are intended to be composed
18:49:53 <Cale> Whereas g $ h means to pass h to g as its first parameter
18:50:07 <EvilTerran> a . b =<< c . d  is  (a . b) =<< (c . d), but  a $ b =<< c $ d  is  a $ (b =<< c) $ d
18:50:09 <Brian`> Cale : oh.. i c
18:50:09 <Cale> which is typically going to be a type error, unless g is somehow very polymorphic
18:51:04 <Brian`> EvilTerran : i'm not that familiar with monad concept but yeah that example makes sense :) thanks
18:51:09 <Cale> EvilTerran: Thankfully, I think it can be argued that in cases like that, explicit parens are probably a good idea.
18:51:23 <EvilTerran> true
18:51:24 <Cale> (regardless)
18:52:18 <Cale> Brian`: Things would be nicer if ($) had the opposite associativity -- after all, function application itself (being represented by whitespace) is left associative
18:52:40 <Cale> That would allow us to write things like  f $ g x $ h y rather than f (g x) (h y)
18:53:32 <newsham> why not define another one?
18:53:48 <Cale> newsham: most of the good single character functions are taken
18:54:06 <newsham> time for unicode? ;-)
18:54:07 <Cale> newsham: also, it would be kind of silly to have both
18:54:29 <Cale> If it takes more than one keystroke, you might as well use parens :)
18:54:48 <newsham> you could get an extended keyboard? ;-)
18:54:50 <Cale> heh
18:55:31 <Cale> Since very few uses of chained ($) are essential, I think it's better if we just get everyone to use composition more, and then at some point flip it :)
18:55:51 <Brian`> k :) sounds like a plan
18:55:58 <sorear> @quote Cale plot
18:55:58 <sorear-lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
18:56:01 <sorear> @quote Cale \.
18:56:01 <sorear-lambdabot> Cale says: I've written an entire IRC bot as what was essentially a single extremely long shell pipeline.
18:56:16 <Brian`> so how long have you guys been haskelling?
18:56:27 <Cale> Brian`: a few years now
18:56:34 <newsham> I've used chained $'s several times
18:57:02 <newsham> i dunno about "essential" (hey, i coulda used parens!)
18:57:02 <Cale> newsham: I have too, but at some point I stopped doing it, and haven't looked back :)
18:57:05 <Brian`> Cale : so can haskell be used as a prototyping language?
18:57:08 <wli> I use chained $
18:57:22 <wli> I often put the elements of the "pipeline" on different lines.
18:57:24 <Cale> Brian`: prototyping? I suppose so, yeah.
18:57:40 <Cale> wli: you can still use (.) for that :)
18:58:06 <wli> Cale: I prefer to use $ because it's more uniform.
18:58:23 <newsham> I like flip (.)
18:58:30 <newsham> too much unix
18:58:44 <sorear> >>>
18:59:02 <Cale> wli: One nice thing about using (.) is that you can clip out some subset of the lines from your pipeline and define it as its own function without having to do any editing.
18:59:08 <wli> (>>>) = flip (.) for function arrows?
18:59:14 <timthelion> is case a keyword in haskell?
18:59:17 <sorear> yeah
18:59:18 <sorear> yeah
18:59:18 <Cale> timthelion: yes
18:59:38 <newsham> I also like fold of (>>>) and id
19:00:12 <Brian`> hey I'm using emacs + haskell. If I load a module, ghci shows module_name> instead of prelude> right? how can i go back to prelude?
19:00:23 <wli> Cale: I've found that to be far less significant an issue than making the big function pipelines pretty enough to be read.
19:00:27 <Cale> Brian`: the Prelude is always loaded anyway
19:00:29 <EvilTerran> Brian`, :l
19:00:36 <EvilTerran> but note what Cale said
19:00:58 <Brian`> kk :l works. and yeah thanks Cale for the note :)
19:01:23 <KatieHuber> if I link with -threaded and run with -N2 will stuff be automatically parallelized, or do I still need explicit threading stuff in my code?
19:01:42 <Cale> KatieHuber: You still need annotations of some sort.
19:01:50 <sorear> KatieHuber: You still need explicit parallelism annotations, but they are much less disruptive than threading
19:02:03 <sorear> KatieHuber: x `par` y  runs x and y in parallel, returning x
19:02:12 <Cale> returning y
19:02:18 <sorear> KatieHuber: adding `par` *never* introduces bugs
19:02:18 <sorear> right
19:02:25 <sorear> KatieHuber: unlike threads
19:02:34 <KatieHuber> and if I don't use -threaded, what does `par` do then?
19:02:39 <sorear> noop
19:02:41 <KatieHuber> cool.
19:02:42 <ecksit> hello, in haskell, how would i get rid of a "Fractional Integer" error
19:02:52 <Cale> Well, it doesn't actually do that, it adds x to a queue of things to be evaluated in parallel, doesn't it?
19:02:55 <sorear> ecksit: use the right division operator
19:02:57 <ecksit> even though i am returning a Double
19:03:08 <lament> ecksit: by doing a lot of ugly stuff with casting and whatnot :(
19:03:13 <wli> ecksit: fromIntegral
19:03:19 <sorear> @quote fromInt
19:03:19 <sorear-lambdabot> No quotes match. Are you on drugs?
19:03:25 <Cale> ecksit: Usually that happens when you try to take an Integer and use (/) on it.
19:03:25 <wli> ecksit: show the code
19:03:27 <KatieHuber> presumably `par` is only useful when x is something in IO?
19:03:35 <sorear> not at all
19:03:36 <Cale> KatieHuber: no, quite the opposite
19:03:40 <EvilTerran> indeed not!
19:03:41 <sorear> infact it's useless in that case
19:03:50 <KatieHuber> but... if its result is ignored... ?
19:03:53 * KatieHuber is confused :p
19:04:01 <Cale> KatieHuber: x can occur in y
19:04:12 <KatieHuber> I was kinda expecting there to be a parallelMap or something
19:04:13 <Cale> (typically y is some expression)
19:04:21 <Cale> Oh, there is, it's built in terms of par
19:04:28 <ecksit> sorear: ok, i will show the code in a sec
19:04:33 <wli> There is a parMap floating around somewhere.
19:04:41 <wli> Control.Parallel.Strategies or some such.
19:04:42 <Cale> Control.Parallel.Strategies
19:04:47 <Cale> yes
19:04:54 <wli> I never use par directly; only parMap et al.
19:04:56 <KatieHuber> so (trivially) let x = 3 + 4 in x `par` x + (5 + 6) maybe?
19:05:02 <Cale> :t Control.Parallel.Strategies.parMap
19:05:04 <sorear-lambdabot> Couldn't find qualified module.
19:05:06 <sorear> KatieHuber: right
19:05:15 <Cale> um, what?
19:05:21 <Cale> anyway
19:05:25 <Cale> parMap :: Strategy b -> (a -> b) -> [a] -> [b]
19:05:37 <ecksit> http://pastebin.ca/706597
19:06:14 <sorear> @pretty let { fib 0 = 0; fib 1 = 1; fib n = let { x = fib (n-1); y = fib (n-2) } in x `par` y `seq` (x+y)
19:06:14 <sorear-lambdabot> "Parse error" at column 98
19:06:20 <Cale> For the Strategy b parameter, you can use something like rwhnf (which reduces the elements to weak head normal form), or rnf (which completely reduces them, but that requires an instance of NFData)
19:06:22 <sorear> @pretty let { fib 0 = 0; fib 1 = 1; fib n = let { x = fib (n-1); y = fib (n-2) } in x `par` y `seq` (x+y) } in fib 40
19:06:22 <sorear-lambdabot>  i = let fib 0 = 0
19:06:22 <sorear-lambdabot>          fib 1 = 1
19:06:22 <sorear-lambdabot>          fib n
19:06:22 <sorear-lambdabot>            = let x = fib (n - 1)
19:06:22 <sorear-lambdabot>                  y = fib (n - 2)
19:06:24 <sorear-lambdabot>                in x `par` y `seq` (x + y)
19:06:26 <sorear-lambdabot>        in fib 40
19:06:37 <sorear> KatieHuber: that's the standard example
19:06:44 <newsham> way to not use hpaste
19:06:44 <Cale> > let { fib 0 = 0; fib 1 = 1; fib n = let { x = fib (n-1); y = fib (n-2) } in x `par` y `seq` (x+y) } in fib 40
19:06:45 <sorear-lambdabot>      Failed to load interface for `Control.Parallel':
19:06:45 <sorear-lambdabot>       Use -v to see a l...
19:06:56 <Cale> What's up with that?
19:06:56 <balodja> oh my very god. that's really pretty :)
19:06:56 <timthelion> with bash script, I can write complex aplications, by having a set of deamons comunicating via named pipes, I know that haskell can do named pipes, but I should think there might be a better, cleaner, way in haskell to do interprogram comunication?
19:07:01 <dolio> Huh, that isn't right.
19:07:14 <sorear> Cale: see earlier about hs-plugins brokenness
19:07:20 <Cale> oh
19:07:38 <ecksit> could anyone let me know what im doing wron?g
19:07:41 <sorear> Cale: it assumes `which ghc` is the same version that was used to compile hs-plugins...
19:07:48 <Cale> timthelion: Chan?
19:08:09 <Cale> ecksit: looking...
19:08:30 <sorear> ecksit: btw, there is a #haskell pastebin
19:08:30 <KatieHuber> what is this Strategy b thing in parMap?
19:08:34 <sorear> !paste
19:08:34 <newsham> lazy lists arent pipe-like enough?
19:08:34 <hpaste> Haskell paste bin: http://hpaste.org/
19:08:47 <timthelion> Cale: link?
19:08:49 <Cale> ecksit: sort xs !! x is an Integer
19:08:52 <KatieHuber> I can use const () ?
19:08:56 <sorear> KatieHuber: it tells parMap how much evaluating to do in parallel, and how much to defer until used
19:09:02 <ecksit> oh, didnt know, now i do
19:09:05 <Cale> ecksit: therefore, dividing it by 2 with / isn't allowed
19:09:05 <sorear> KatieHuber: parMap r0 does nothing in parallel
19:09:22 <sorear> KatieHuber: parMap rnf does everything in parallel, possibly much more than is needed
19:09:24 <Cale> ecksit: You'll have to convert it with fromIntegral first, before the division
19:09:33 <sorear> KatieHuber: parMap rwhnf only reduces to WHNF
19:09:50 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
19:09:50 <sorear-lambdabot> http://tinyurl.com/3953km
19:10:06 <ecksit> oh ok, now i see
19:10:30 <Cale> ecksit: So you just need to move your parens a bit :)
19:10:44 <Cale> ecksit: Also, you're sorting the list multiple times
19:10:58 <Cale> ecksit: It would be a good idea to use let or where to sort the list in one place.
19:11:22 <Cale> Similarly for computing the length
19:11:29 <ecksit> Cale: i know, im thinking about putting let xs = sort in ....
19:11:38 <ecksit> but dont know whether that will owrk
19:12:05 <Saizan> can you share a Chan between processes?
19:13:41 <Cale> ecksit: http://pastebin.ca/706602
19:13:59 <Cale> Saizan: sure
19:14:36 <Cale> Saizan: just pass it into each of them. Also, you can control read and write permissions by passing partial applications of readChan and writeChan
19:14:36 <EvilTerran> ecksit, generally, if you give an expression a name (bind it with let, where, or otherwise, to something with no parameters), it will only be calculated once while that name remains in scope
19:15:07 <EvilTerran> ecksit, and if you don't, it may be calculated multiple times
19:15:33 <KatieHuber> so if I have an algorithm written in terms of working an element at a time, it won't be easy to parallelize it without a rewrite?
19:15:39 <EvilTerran> (emphasis on *may be*; ghc *can* do common subexpression elimination, but it would be grand folly to rely on it)
19:16:02 <Cale> KatieHuber: depends, but if there are data dependencies, it makes it pretty hard
19:16:31 <ecksit> Cale: i just used let xs = sort xs (not the example you showed) and am stuck in an infinite loop, not sure why
19:16:47 <EvilTerran> KatieHuber, if reducing each element to WHNF is enough to do in parallel, and none depend on each other, par'ing along the list should do
19:16:52 <Cale> ecksit: because that defines xs as the result of sorting itself
19:16:53 <KatieHuber> yeah, I think this won't be possible.  Oh well, back to more important algorithmic improvements ;)
19:16:56 <EvilTerran> ecksit, you can't re-use variable names like that
19:17:03 <Cale> ecksit: which is sort (sort (sort (...)))
19:17:05 <EvilTerran> > let xs = 1 : xs in xs
19:17:06 <sorear-lambdabot>      Failed to load interface for `Control.Parallel':
19:17:06 <sorear-lambdabot>       Use -v to see a l...
19:17:16 <Cale> here...
19:17:19 <EvilTerran> = [1,1..]
19:17:31 <ecksit> oh
19:17:35 <Cale> > let xs = 1 : xs in xs
19:17:36 <sorear-lambdabot>      Failed to load interface for `Control.Parallel':
19:17:36 <sorear-lambdabot>       Use -v to see a l...
19:17:38 <EvilTerran> (1:) has a nice fixedpoint; sort doesn't.
19:17:38 <mbot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:17:47 <Cale> sorear: let's use mine :)
19:17:54 <Cale> sorear-lambdabot: @part #haskell
19:18:11 <sorear> sorear-lambdabot: @quit
19:18:27 <sorear> suppose I didn't need to have him join for that
19:18:48 <EvilTerran> ecksit, within a let{}, any variables defined in that let{} mask anything with the same name from outside it
19:18:57 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
19:18:59 <mbot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:19:17 <Cale> There's a list defined in terms of itself and its own tail.
19:19:20 <EvilTerran> including "above" the definition, as in
19:19:21 <EvilTerran> > let xs = 0 : ys; ys = 1 : xs in xs
19:19:23 <mbot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
19:19:42 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in odds
19:19:44 <mbot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
19:19:49 <EvilTerran> "ys" is already visible, above where it's apparently defined, 'cos haskell is cool that way
19:20:17 <EvilTerran> but it does mean you can't say "let xs = f xs", referring to a previous xs.
19:21:10 <ecksit> one last question: what do the | exactly do, are they specialized branch statements?
19:21:26 <Cale> Yeah, they're guards -- it tries each one
19:21:36 <Cale> and the first test to succeed wins
19:21:53 <Cale> otherwise is just another name for True
19:22:01 <Cale> > otherwise
19:22:03 <mbot>  True
19:22:24 <ecksit> Cale: otherwise is always equal to True
19:22:29 <Cale> right
19:22:29 <ecksit> so its like an else
19:22:34 <Cale> It's actually defined in the Prelude :)
19:22:38 <EvilTerran> > let f x | odd x = "odd" | even x = "even" | otherwise = "oh noes my nanomachines" in map f [0..]
19:22:40 <mbot>  ["even","odd","even","odd","even","odd","even","odd","even","odd","even","od...
19:22:49 <Cale> heh
19:23:18 <ecksit> k, thanx again for the help
19:23:34 <SeanMcE> 		Help! I want to read lines into a list until a condition is met http://hpaste.org/2844
19:24:26 <Cale> SeanMcE: why isn't readLines recursive?
19:24:37 <EvilTerran> ... must be September
19:24:42 <SeanMcE> It started out recursive
19:24:44 <Cale> hehe
19:25:02 * EvilTerran wonders how got so cynical so quickly, and goes to bed, muttering
19:25:25 <Cale> SeanMcE: Surely BS.length isn't an IO computation
19:25:38 <Cale> SeanMcE: You don't have to run it like you do hGetLine
19:25:50 <SeanMcE> ok
19:25:54 <Cale> you can use let inside a do-block if you want to make a local declaration
19:26:02 <Cale> let len = BS.length line
19:26:31 <Cale> Then, inside the if (which is indented too far)
19:26:36 <SeanMcE> i think I had that and one point and it wanted a statement after do
19:26:55 <Cale> Well, you can't end a do-block with a <- or let
19:27:04 <Cale> It must end with some action.
19:27:25 <SeanMcE> my action is to return a list
19:27:36 <Cale> oh, and watch out
19:27:42 <Cale> You have tab characters in your file
19:27:57 <Cale> It's best to get your text editor to convert them to spaces automatically.
19:28:14 <Cale> They count as 8 spaces otherwise
19:28:14 <SeanMcE> :set tabexpand -- got it
19:28:21 <SamB_XP> at the very least, ensure that your editor is configured to interpret tabs correctly
19:28:40 * EvilTerran uses tabs, shown as 4 characters each, yet, but is careful to be consistent with them
19:29:07 <SamB_XP> EvilTerran: WHY!
19:29:11 <EvilTerran> as in, only using tabs, and nothing other than tabs, for indentation
19:29:27 <EvilTerran> (that "only" meaning "not using tabs for anything else")
19:29:30 <SamB_XP> in Haskell?
19:29:46 <EvilTerran> out of habit from non-indentation-dependent languages
19:30:12 <EvilTerran> my text editor is not an OS in its own right, so configuring it to switch automatically would be a nusiance ;]
19:30:28 <EvilTerran> and it'd involve learning to work with the new behaviour
19:30:58 <EvilTerran> regardless, i've always been fairly anal about making sure my tabs continue to make sense regardless of what tabsize people view the document under
19:31:00 <SamB_XP> Emacs is probably not really an OS
19:31:16 <EvilTerran> i can do it without really thinking about it
19:31:33 <SamB_XP> It's surely a shell, in the same sense that both bash and explorer.exe are shells...
19:31:55 <EvilTerran> don't over-analyse. it's just an offhand joke.
19:32:01 <Saizan> EvilTerran: isn't painful when editing something written with only spaces?
19:32:15 <EvilTerran> pardon?
19:32:41 <Saizan> using tabs in a module written using spaces
19:33:00 <EvilTerran> in those cases, i make the effort to reconfigure on a one-off
19:33:04 <Cale> http://hpaste.org/2844#a1 -- note: I didn't test that code :)
19:33:17 <SamB_XP> Cale: did you at least prove it correct?
19:33:33 <EvilTerran> i prefer my text editors to be light and predictable, otherwise i'd have some kind of magic autodetection of tabbing style
19:33:35 <Cale> SamB_XP: Nah, but I looked at it :)
19:34:11 <SamB_XP> ... I'd really like to see autodetection of Haskell indentation style ;-P
19:34:15 <Cale> btw, I tried Haskell-mode in emacs again the other day, and the smart tabs still annoy me :)
19:34:44 <Cale> er, sorry, that ought to be BS.length near the bottom
19:34:47 <EvilTerran> SamB_XP, as in "are there tabs at the starts of lines in this file? okay, indent using tabs" sort of thing.
19:35:29 <SeanMcE> Cale, thanks, i play around with it
19:35:39 <Cale> I think the tab character should be killed off with the rest of the outdated ASCII control characters
19:38:52 <wli> Cale: How am I supposed to have tabs without it?
19:39:04 <EvilTerran> meh. i like being able to change how big my indents are depending on my mood
19:39:34 <SamB_XP> wli: MS word!
19:39:35 <EvilTerran> "i think i'll have three-character-wide indents today... *tweak* *now all files appear that way*"
19:40:09 <EvilTerran> anyway. 'tis late.
19:40:28 <wli> I get the distinct feeling this is a proposed feature removal with non-solutions backing it.
19:40:56 <SamB_XP> what was the feature again?
19:41:10 <wli> SamB_XP: Tab and other control characters.
19:41:23 <SamB_XP> how about we just talk about tab
19:41:51 <SamB_XP> most of the others aren't generally allowed in source files anyway
19:42:15 <wli> Let's talk about monad comprehensions, specifically how to go about shoehorning them into DsListComp.lhs or a parallel file in compiler/deSugar/
19:44:20 <notsmack> "indent to the next multiple of N fixed-width characters from left margin" doesn't have any meaning in most modern contexts
19:45:09 <wli> notsmack: No idea what you mean. It's quite well-defined to this day in xterm and most other terminal emulators.
19:48:28 <P_D> Has anyone by chance written a haskellized visa or GPIB lib?
19:49:02 <Saizan> if i bind a function that returns a CString, am i supposed to free it after using peekCString?
19:49:43 <Saizan> or the GC handles that by itself?
19:55:20 <sorear> haha
19:55:24 <sorear> Ptr CChar
19:55:31 <sorear> no
19:55:50 <sorear> how could the GC possibly know whether you're even *supposed* to free the string?
19:55:52 <bparkis_> it is possible to determine whether two finite state machines are equivalent, and part of a Turing machine is the FSM
19:56:25 <bparkis_> what is the meaning of sets of Turing machines related by having the same finite state machine?
19:56:31 <sorear> bparkis_: none
19:56:36 <bparkis_> or that is, equivalent finite state machines
19:56:59 <bparkis_> why none?
19:57:19 <sorear> bparkis_: the FSM is not an invariant property of the Turing Machine, so saying two Turing Machines have the same FSM is as meaningless as saying two physical events happened at the same time
19:57:41 <bparkis_> well let's also say they have the same input and tape alphabets
19:57:48 <sorear> still
19:57:55 <Saizan> sorear: magic!
19:58:16 <bparkis_> if they have the same input and tape alphabets, and equivalent FSMs, then they have the same behavior
19:58:20 <sorear> you can transform a TM into an equivilent TM with a different FSM quite easily
19:58:21 <sorear> ah
19:58:22 <sorear> yes
19:58:48 <sorear> tape + FSM is a valid representation of turing machines
19:58:53 <sorear> and by valid I mean injective
19:59:03 <sorear> but there are other representations
19:59:14 <bparkis_> so I'm wondering if there is a specific class of program transformations that corresponds to equivalent alternate representations of the FSM
19:59:32 <sorear> no, because programming languages are not turing machines
20:00:00 <bparkis_> programs in programming languages can be converted into Turing machines
20:00:04 <sorear> yes
20:00:05 <sorear> but
20:00:13 <sorear> once you allow that kind of transformation
20:00:32 <sorear> you have to allow the entire set of denotation-symmetries
20:00:40 <sorear> and then the FSM loses its invariance
20:01:14 <bparkis_> you lost me at "the entire set of denotation symmetries," could you explain?
20:02:37 <wli> bparkis: Also VHDL and/or other circuit specifications.
20:03:35 <wli> bparkis: (Translators from programming languages to such are called "silicon compilers" BTW.)
20:04:59 <chessguy> 'evening
20:05:01 <Daveman> hey chessguy :)
20:08:21 <wli> There's an idea. Translate a very simple FPL to circuit diagrams. That might be a good monadic programming exercise for someone writing a Haskell book.
20:09:54 <lokik> what's the escape sequence for eof?
20:10:13 <lokik> like \n \r
20:10:16 <wli> I don't believe there is one.
20:10:25 <wli> Probably the closest thing is \EOT
20:10:43 <lokik> kk i'll try that
20:10:56 <notsmack> lokik: why?
20:11:31 <lokik> just cause i have my cmene parser, and so if there is a name at the end of the file/text it wont give error
20:11:37 <omniscientIdiot> its codepoint is 27, right?  I think you can use hex escapes: '\x1B'
20:11:48 <edwardk> lokik: there isn't one, eof is usually out of band
20:11:49 <lokik> like a name without a space/period after it
20:12:10 <lokik> as names need one... and so if i accept \EOT as a space, then it works
20:12:36 <wli> Basically you get an IO error when trying to read from a file, check the error condition, and notice it's an EOF.
20:13:24 <wli> Typically read(2) returns 0 with an errno of 0.
20:13:32 <wli> That is, 0 bytes read.
20:13:35 <Saizan> lokik: there's "eof" if you're using parsec
20:13:46 <lokik> hmmm, well it's like string input. says unexpected end of input if i make cmene "la.lokam" instead of "la.lokam "
20:13:51 <omniscientIdiot> there's also hIsEOF
20:14:03 <wli> Libraries can propagate this back to the app in various ways.
20:14:19 <lokik> it's end of text, not end of file
20:14:34 <wli> I think EOF tests are usually lseek() -based.
20:14:39 <balodja> Cale: http://cale.yi.org/autoshare/monadlaws.jpg -- Is it a new idea? Are there any theoretical confirmations for such representation?
20:15:20 <Cale> balodja: It's not new. In fact, if you'd like more detail, watch the Catsters videos on YouTube :)
20:15:41 <Cale> I drew that in anticipation of the recently released videos.
20:15:59 <Cale> balodja: basically, they're duals of 2-categorical diagrams
20:16:19 <Cale> 2-cells are categories, 1-cells are functors, and 0-cells (which I draw as bubbles) are natural transformations
20:16:31 <Cale> The identity functor, I don't draw.
20:16:41 <Cale> (nor the identity natural transformation)
20:17:29 <Cale> also, as you can probably tell, they're meant to be read as going from bottom to top.
20:17:37 <Cale> (and right to left)
20:17:38 <balodja> Category theory has lots of amazing pitfalls :)
20:17:39 <wli> Something like off_t fpos = lseek(fd, 0, SEEK_CUR); fstat_err = fstat(fd, &stat_buf); /* error checking */ return stat_buf.st_size == fpos;
20:19:07 <Cale> http://uk.youtube.com/user/TheCatsters
20:19:24 <wli> lseek(fd, 0, SEEK_CUR); retrieves the current file position; fstat(fd, &stat_buf); retrieves various bits of information about the file, e.g. its size.
20:20:13 <wli> The file type may also factor into the equation. You won't get EOF under quite the same conditions or detect it the same way for sockets, pipes, device special files, etc.
20:20:41 <balodja> Good-good. I've seen some of that videos. They are excellent! :)
20:20:48 <balodja> *those
20:21:54 <wli> System.IO deals with some (perhaps all?) of this for you, but you might occasionally see the low-level details peeking through.
20:31:27 <Cale> Heh, I like how a song by the Klein Four Group is in the related videos for one of the Catsters' videos. :)
20:38:05 <reffie> http://scienceblogs.com/loom/2007/09/21/mathematical_markings.php
21:02:47 <bos> @seen sorear
21:02:47 <mbot> Unknown command, try @list
21:02:53 <sorear> ?
21:03:07 <oerjan> @list
21:03:07 <mbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:03:28 <bos> sorear: do you know if the value of +RTS -Nx is available to running code?
21:03:38 <bos> somewhere in the bowels of GHC.* perhaps?
21:04:28 <sorear> @source GHC.Conc
21:04:28 <mbot> http://darcs.haskell.org/packages/base/GHC/Conc.hs
21:04:38 <bos> ++sorear
21:04:51 <sorear> syntax error
21:04:52 <sorear> !say sorear++
21:04:53 <hpaste> sorear++
21:05:06 <sorear> actually, I'm just looking
21:05:12 <sorear> it's not necessarily in there
21:05:18 <bos> yeah, it's not
21:05:50 <coffeemug> good evening
21:07:27 <araujo> :-)
21:10:04 <bos> bugger, darcs is going exponential on the ghc tree that i've never modified
21:13:11 <timthelion> Cale: it seems that Chan has a newChan function, but it doesn't have an openChan function, so I cannot see how it can be used for interprogram comunication...
21:15:04 <timthelion> @seen Cale
21:15:04 <mbot> Unknown command, try @list
21:15:13 <timthelion> @sean Cale
21:15:14 <mbot> Maybe you meant: keal learn read
21:15:34 <timthelion> @keal learn read
21:15:34 <mbot> i just got banned from math because i not have good ability to convey thoughts
21:15:51 * timthelion bops mbot on the head
21:16:05 <phobes> What's does @keal reference?
21:16:13 <glguy> keal
21:16:23 <phobes> glguy++
21:16:27 <glguy> :)
21:16:28 <oerjan> @help keal
21:16:28 <mbot> keal. Talk like Keal
21:16:38 <timthelion> @keal
21:16:38 <mbot> love a black and white lower 128 from 32 up of ascii glyphs?
21:17:07 <timthelion> @que es Keal
21:17:07 <mbot> Maybe you meant: bug quit quote run
21:17:13 <notsmack> @keal
21:17:13 <mbot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
21:17:25 <timthelion> @quen es Keal?
21:17:25 <mbot> Maybe you meant: quit run
21:17:32 <timthelion> @quit run
21:17:32 <mbot> Not enough privileges
21:22:29 <timthelion> so, I can't see that Chan could be what I want, I want a clean way to do inter program comunication
21:23:19 <bos> sorear: as far as I can tell from reading the RTS code, there's no way to get at -N from haskell
21:27:03 <bos> timthelion: there isn't one
21:27:10 <timthelion> what?
21:27:14 <timthelion> you gota be kidding me!
21:27:25 <bos> nope
21:27:29 <timthelion> do I really have to resort to dirty tricks?
21:28:00 <bos> write a library for typed binary I/O. everyone will love you.
21:28:26 <bos> layer some Chan-like thing on top. everyone will love you even more.
21:28:43 <glguy> hmm
21:28:48 <notsmack> bos: data.binary style?
21:28:51 <glguy> thre was a paper recently about interprocess chans
21:28:55 <glguy> via tcp
21:29:09 <bos> glguy: there was a paper a *long* time ago about them, like 2000 or so
21:29:12 <glguy> ah
21:29:18 <bos> notsmack: on top of data.binary, sure
21:29:18 <glguy> I just meant recently on reddit :)
21:29:41 <bos> reddit, the retarded goldfish bowl of computing
21:31:41 <jcreigh> haha
21:31:50 <glguy> Ah , they called them "ports"
21:32:05 <glguy> looks like it was back in 2001 like you mentioned
21:32:15 <balodja> String diagrams are guiet amazing.
21:33:10 <bos> i have a half-written chan-over-binary library sitting unfinished somewhere
21:33:38 <balodja> So simple, so powerful, ans so expressive :)
21:34:51 <thetallguy> Hey, any Ruby hackers here?  I'm looking for a definition of a block in Haskell terms.
21:35:38 <Olathe> thetallguy: (\a b -> something)
21:35:57 <Olathe> Similar to { |a, b| something }
21:36:09 <thetallguy> Olathe, my friend says more than a lambda
21:36:19 <glguy> yeah, a poorly implemented one
21:36:31 <glguy> in that block with a and b
21:36:36 <glguy> a and b escape the block
21:36:37 <glguy> after it is used
21:37:11 <Olathe> I can't get it to do that.
21:37:18 <glguy> a = 1; [2,3].each { | a | puts a }; puts a;
21:37:36 <Olathe> Ahh.
21:37:57 <Korollary> how excellent
21:39:09 <Caelum> glguy: it seems to work correctly in 1.9
21:39:40 <glguy> that's an impressive step for ruby
21:40:13 <thetallguy> Thanks guys
21:48:11 <Cale> thetallguy: It's actually a little more like a lambda containing a do-block, since it's not really an expression that's in there, but a sequence of statements to be executed.
21:49:24 <Cale> well, sometimes it's just an expression :)
21:51:45 <dons> is it a type error to say, write,  1 + { | a | puts a } ?
21:52:04 <dons> or does that have a cute runtime coercion?
21:52:16 <dons> glguy: what happens if you add 1 to a function in php?
21:52:16 <bos> and ruby blocks have yield
21:52:27 <timthelion> bos: would you care to share it with me?  I am willing to invest considurable effort(though I'm not an experienced haskell programmer) in making that work.
21:52:41 <glguy> dons: syntax error?
21:52:53 <glguy> err
21:52:55 <bos> timthelion: it's really not in a usable state, or even a handable-overable one, sorry
21:53:02 <glguy> some kind of type error at least at run time?
21:53:06 <Cale> dons: it's a syntax error, even.
21:53:11 <dons> in ruby?
21:53:17 <dons> ah, so no first class closures
21:53:27 <Cale> I don't think that { |a| puts a } is a value on its own
21:53:31 <phobes> 1 + { | a | puts a } is definitely a syntax error in haskell :^)
21:53:42 <dons> oh, i see, they're not expressions.
21:53:47 <glguy> <?php echo 1 + phpinfo ?>
21:53:49 <glguy> returns 1
21:53:52 <dons> sweet
21:53:54 <Cale> But 1 + (\a -> putStr a) isn't
21:54:08 * jql tries that in various languages...
21:54:13 * jql is getting amused
21:54:14 <Cale> (it's just a type error)
21:54:24 <dons> well, its fine in haskell if you've got a Num instance :)
21:54:29 <Cale> yeah
21:54:32 <dons> one more reason to not use ruby :)
21:54:34 <phobes> which, of course, you should
21:54:50 <glguy> dons: reasons not to use ruby: you have an education
21:54:50 <jql> javascript:alert(1 + function() { alert("inside"); })   # oh yeah
21:54:52 <glguy> all you need...
21:54:59 <dons> Cale, got  cute mapping of the numeric literals to functions?
21:55:11 <dons> glguy: true. php is much more fun
21:55:21 <glguy> :-/
21:55:23 <dons> like a birthday surprise around every corner
21:55:30 <Korollary> Self-modifying assembly is the best.
21:55:32 <glguy> Its the weekend, I don't need to be reminded
21:55:39 <dons> ok ok :)
21:55:42 <Cale> What, an instance of Num for String -> IO () ?
21:55:56 <dons> for a -> b would be ok.
21:56:19 <dons> such that 1 + 2 does something plausible
21:56:33 <dons> (for overloaded numeric literals)
21:56:48 <bos> glguy: been writing php recently?
21:56:50 <Caelum> perl -le 'print 1 + sub { print $_[0] }' # returns 1 + a memory address :)
21:56:59 <phobes> Self modifying assembly used to be easier to use back before you had to worry about the cache
21:57:04 <glguy> bos: hacking against mediawiki
21:57:07 <glguy> so yeah
21:57:11 <jql> Caelum: that's classy
21:57:16 <glguy> can't do it all in Haskell :)
21:57:23 <dons> mmm. can we categorise 'safe' v 'unsafe' languages by what they do when you add 1 to a code block/
21:57:38 <glguy> dons: php doesn't crash
21:57:40 <glguy> so that's safe
21:57:41 <phobes> Put C++ in the safe camp!
21:57:45 <dons> seems like a cheap heuristic to capture both safety and expressiveness
21:57:46 <glguy> and Haskell complains, unsafe!
21:57:48 <scook0> I think Perl is a bit of a red herring here
21:57:52 <glguy> what if you were running a heart monitor?
21:57:52 <Korollary> I think it's sane vs insane.
21:57:57 <dons> (i.e. a syntax error in ruby == not expressive enough)
21:58:02 <glguy> you want it to say type error, or keep beating?
21:58:03 <scook0> since the semantics of + coerce the argument to a number before addition
21:58:26 <jql> Caelum: even more disturbing, it does the same thing with or without the sub. hash is just as good
21:58:29 <dons> glguy: i want it to keep beating a 1 + memory address Hz :)
21:59:03 <dons> would someone like to put up a little table for what the various languages do?
21:59:10 <dons> it would make a lovely little reddit meme for the weekend
21:59:23 <glguy> ?quote fishbowl
21:59:23 <mbot> No quotes match. Maybe if you used more than just two fingers...
21:59:23 <glguy> ;)
21:59:28 <dons> heh
21:59:36 <bdash> dons: a more useful Ruby version is probably: 1 + proc {|a| puts a }, which is just a type error at runtime
21:59:41 <phobes> dons:  is your aim to use reddit as a haskell recruiting tool?
21:59:54 <dons> i suspect you can learn something about each language from this little test
22:00:06 <dons> its a corner case exposing assumptions about types, and expressivity
22:00:15 <glguy> People aren't still using ruby, are they?
22:00:20 <glguy> seems like I'm hearing less about it
22:00:42 <glguy> (until someone brought it up in channel!)
22:00:42 <dons> phobes: no, i like reading stuff about programming. and hanging out in a community of such people :)
22:00:43 <Korollary> they are
22:00:43 <phobes> There are still Ruby books in the mainstream bookstores
22:00:44 <jql> Erlang still the new hotness, or has the target moved? I haven't been redditing enough. :)
22:00:59 <Korollary> both erang and ruby are infinitely ht
22:01:01 <Korollary> hot
22:01:13 <dons> less ruby, more erlang, more python?
22:01:18 <Korollary> Lindsey Lohan is a ruby hacker
22:01:21 <glguy> erlang is getting more exposure than "check out my cool blog post"?
22:01:22 <jql> more python? but why?
22:01:51 <jql> 3.0 out yet?
22:02:11 <dons> maybe there isn't more python -- maybe its just been constant, and often
22:02:34 <Caelum> python doesn't even have real closures...
22:02:34 <dons> we seem to be past the 'omg haskell' wave of this time last year
22:02:56 <dons> the posts are a bit more considered, and also people assume a working knowledge of the language
22:03:00 <dons> that's a good result
22:03:28 <Korollary> yet we dont have a web browser written in haskell. you have failed.
22:03:40 <jql> python and java seem like bosom buddies in old leg-shackling decisions anchoring them to history. but I'm probably just biased
22:03:56 <dons> ah well, i've a real job hacking haskell now: that'll do.
22:04:01 <oerjan> Korollary: is there one in ruby?
22:04:07 <phobes> java is much more tedious than python
22:04:17 <jcreigh> oerjan: oh...my head hurts just thinking about it.
22:04:17 <Korollary> oerjan, do I need to make sense and be fair at this hour?
22:04:22 <jcreigh> firefox is slow enough!
22:04:46 <bdash> oerjan: there was one written in Python a few years ago
22:04:56 <oerjan> Korollary: me neither!
22:05:13 <Korollary> oerjan, refrigerator then.
22:13:04 <bos> @hoogle fix
22:13:05 <mbot> http://www.fixprotocol.org/
22:13:05 <mbot> Title: The FIX Protocol Organization > Home page
22:13:11 <bos> wtf?
22:13:37 <wli> A web browser in Haskell would be a nice demonstration of comparative expressive power; most browsers are gargantuan piles of code.
22:15:02 <oerjan> @ogle
22:15:02 <mbot> Empty search.
22:15:06 <dons> too much work to just prove a point though
22:15:13 <oerjan> @ogl
22:15:14 <mbot> Maybe you meant: pl url
22:15:15 <Cale> bos: spell corrector
22:15:17 <dons> things like xmonad demonstrate it well enough
22:15:24 <Cale> bos: plus lack of hoogle
22:15:45 <wli> xmonad is an excellent demonstration of it all, yes.
22:15:53 <Cale> mbot is only running a small subset of the available plugins
22:16:10 <Cale> But there's a couple other things there too
22:16:20 <bos> web browsers are gargantuan piles of code in part because the problem is gargantuan in scope
22:16:22 <Cale> % Integrate[Sqrt[Cos[x]],x]
22:16:22 <Zao> Grokking HTML the way the no-good page authors mean it to be interpreted is bothersome.
22:16:22 <notsmack> a web browser's been on my list for a while, but the relevant standards are pretty thick
22:16:23 <mbot> Cale: 2*EllipticE[x/2, 2]
22:16:45 <Cale> % Sum[1/n^2, {n,1,Infinity}]
22:16:47 <mbot> Cale: Pi^2/6
22:17:09 <wli> EllipticE Hmm. I prefer Jacobian elliptic functions.
22:17:56 <phobes> Applications where you're interfacing with complex externally defined standards probably aren't the easiest way to show off an expressive language I'd think
22:18:39 <wli> phobes: Point.
22:21:15 <P_D> I just ran into jacobi elliptic functions
22:21:34 <wli> Cale: t=tan(x/2) gives 2 \int (1-t^2)(1-t^4)^{-1/2} dt which I think comes out in terms of lemniscate functions (Jacobian elliptic functions with modulus 2^{-1/2}).
22:21:52 <omniscientIdiot> P_D: did it leave a bruise?
22:22:16 <P_D> indeed
22:22:40 <P_D> a real bitch to evaluate, mathematica would not cooperate
22:22:56 <P_D> trying to get heat capacity and such for the ideal gas
22:22:57 <phobes> From what point of view do you guys work with them?
22:23:04 <phobes> ah
22:23:34 <P_D> sum over n exp( - n^2 h^2 w^2 / 2 m L) -> sum r ^(n^2)
22:23:41 <phobes> I've worked with them in constructing examples of minimal surfaces over tori
22:24:00 <Cale> % Integrate[ (1 - t^2) (1 - t^4)^(-1/2) , t]
22:24:01 <mbot> Cale: -EllipticE[ArcSin[t], -1] + 2*EllipticF[ArcSin[t], -1]
22:24:03 <Cale> heh
22:24:25 <Cale> It seems to really like the elliptic integrals a whole lot.
22:24:33 <P_D> % Sum[r^(n^2),{n,0,\inf}]
22:24:34 <mbot> P_D: No (forbidden content).
22:24:43 <phobes> Cale:  Ya, it seems to find them everywhere
22:24:49 <Cale> % Sum[r^(n^2), {n,0,Infinity}]
22:24:50 <mbot> Cale: (1 + EllipticTheta[3, 0, r])/2
22:24:55 <P_D> yeah there we go.
22:25:25 <P_D> % D[(1+EllipticTheta[3,0,r])/2,r] /. r -> 0.5
22:25:26 <mbot> P_D: 1.5356460224140007
22:25:32 <P_D> Fun.
22:25:36 <Cale> % D[(1+EllipticTheta[3,0,r])/2,r] /. r -> 1/2
22:25:37 <mbot> Cale: Derivative[0, 0, 1][EllipticTheta][3, 0, 1/2]/2
22:25:40 <Cale> heh
22:25:41 <P_D> nice try
22:26:17 <P_D> % D[D[(1+EllipticTheta[3,0,r])/2,r],r] /. r -> {0.1,0.5,0.9}
22:26:18 <mbot> P_D: Derivative[0, 0, 2][EllipticTheta][3, 0, {0.1, 0.5, 0.9}]/2
22:26:49 <P_D> % Map[D[D[(1+EllipticTheta[3,0,r])/2,r],r] /. r -> #&,{0.1,0.5,0.9}]
22:26:50 <mbot> P_D: {0.12000720000125308, 3.5772200364311493, Derivative[0, 0, 2][EllipticTheta][3, 0, 0.9]/2}
22:27:22 <P_D> runs out of steam at the top end.
22:29:25 <dons> well, if people have nothing else to do, this is interesting: http://rebelscience.blogspot.com/2007/09/why-i-think-functional-programming.html
22:29:37 <dons> but be warned, scary rant alert
22:30:31 * notsmack reads
22:30:35 <sjanssen> "Why I Think Functional Programming Languages Like Erlang and Haskell are Crap" sounds like I'll be grumpy after reading it :)
22:30:54 <notsmack> huh, that's not the topic the URL lead me to expect!
22:31:00 <wli> The substitution is sd(2^{-1/2} t, 2^{-1/2}).
22:31:05 <dons> ah, you had to fill in the ... :)
22:31:23 <Korollary> Damn those mathematicians
22:31:37 <dons> security dude. you can't do security unless you're updating ur varz!
22:31:47 <dons> mbot: @part #haskell
22:31:58 <dons> http://rebelscience.blogspot.com/2007/09/why-i-think-functional-programming.html
22:32:08 <lambdabot> Title: Rebel Science News: Why I Think Functional Programming Languages Like Erlang and ..., http://tinyurl.com/2aqftc
22:32:09 <dons> ah, title checking is back.
22:32:28 <omniscientIdiot> still no "Are Crap", though :)
22:32:34 <dons> oh, some are good posts, `The Age of Crappy Concurrency: Erlang'
22:32:41 <Korollary> I am in ur compiler, manipulating state behind ur back.
22:32:46 <dons> from the same author! how did i not know about this guy?!
22:32:58 <Cale> http://en.wikipedia.org/wiki/COSA
22:32:59 <dons> `Is Erlang a Parallel Language? Simple Answer: No'
22:33:03 <dons> this guy rocks
22:33:15 <notsmack> haha
22:33:38 <notsmack> You may say, so what?  Wrong.
22:33:39 <dons> hah
22:33:47 <SnailRacer> Threads are the absolute work of the devil. Hmm, I am legion....
22:33:56 <P_D> captain, the temporal determinator has been breached!
22:34:02 <sjanssen> this guy screws it up in the second paragraph
22:34:07 <omniscientIdiot> oh noes!
22:34:12 <mr_tenor> is this the "recursion sux" guy again?
22:34:20 <phobes> oh, this is from that project COSA crank
22:34:53 <notsmack> "temporally non-deterministic."  i like that.
22:35:02 <dons> so if FP is not the path to techniques to solving these problems, is he suggesting imperative programming is?
22:35:18 <dons> since that's worked so well for oh, parallelism, in the past..
22:35:19 <Korollary> You don't need to suggest anything to bash something.
22:35:23 <phobes> except now he's ranting about how you can't code a program that detects that it's affected by malware unless you have control of each clock cycle
22:35:32 <dons> yeah, so that marks a rant from a .. something ..
22:35:38 <Zao> If you have someone inserting spy modules, you have bigger issues.
22:35:49 * dons hands OP some types
22:35:50 <dons> :)
22:35:56 <notsmack> what if some malware surreptitiously replaces your timing watchdog?
22:35:57 <mr_tenor> you hae no hope anyway, if you trust the VM that your OS is presenting to you :)
22:36:08 <arcatan> oh, you've found the COSA guy
22:36:15 <Korollary> what's COSA?
22:36:24 <dons> plz what is COSA? it sounds cool
22:36:34 <dons> my variables aren't varying and i'm sick of it!
22:36:34 <phobes> http://www.rebelscience.org/Cosas/COSA.htm
22:36:35 <Zao> So his solution is what, having lots of independent behaviours creating an emergent system?
22:36:36 <lambdabot> Title: Project COSA
22:36:46 <mr_tenor> eg. in a cool WoW hack, you have a kernel module that switches the content of a VM address range whenever the userland hack detector is gonna kick in
22:36:54 <Korollary> ouch @ the logo
22:37:01 <phobes> "rebelscience.org" ... I wonder if this guy is affiliated with Wolfram...
22:37:18 <dons> ah,`We must abandon the algorithmic model and embrace a new paradigm'
22:37:20 <sjanssen> this rant slightly applies to Erlang but not at all to Haskell
22:37:28 <Korollary> aha! graphical over textual. This alone wins me over. Where do I sign up and pay dues?
22:38:02 <notsmack> Your post is so refreshing and enlightening it actually makes me want to get back in computer science. Thank you.
22:38:06 <dons> yeah, that's the best category, isn't it Korollary :)
22:38:23 <dons> so FP is a threat to his solution to bugs and reliability i guess
22:38:31 <dons> hence the rants -- particularly against erlang
22:38:31 <Korollary> No no
22:38:50 <Korollary> erlang will fail as COSA flourishes. It's just a friendly warning.
22:38:59 <dons> do you think he comments as sock puppet on his own blog?
22:39:17 <dons> arcatan: how'd you know about this guy?
22:39:30 <Korollary> I try not to think too hard about this guy.
22:39:32 <wli> I have it down to 2^{1/2} \int (1 - sd(2^{-1/2} t, 2^{-1/2})^2)^{1/2} (1 + sd(2^{-1/2} t, 2^{-1/2})^2)^{-1/2} cd(2^{-1/2} t, 2^{-1/2})^2 dt with t=sd(2^{-1/2} s, 2^{-1/2}) and s = tan(x/2)
22:39:47 <dons> `No algorithmic construct (e.g., IF/THEN/WHILE, GOSUB, GOTO, DO WHILE) is allowed'
22:39:53 <dons> almost declarative :)
22:40:14 <dons> Korollary: yeah, its refreshing :)
22:40:19 <Korollary> "Extreme information hiding"
22:40:32 <Korollary> It withstands torture
22:40:40 <phobes> Examples of complementary pairs are: sensor/effector, cause/effect, departure/arrival, start/stop, input/output, male/female, source/destination, mouse-up/mouse-down, component/constituent, etc...
22:40:43 <Korollary> "No, I will never tell you about m_count!"
22:40:58 <phobes> This is almost a spiritual programming philosophy
22:41:03 <dons> `At this time, there is only one COSA developer in Finland. I am actively looking for a sponsor'
22:41:10 <Cale> Forgot yin/yang
22:41:13 <Korollary> Deepak Chopra would sponsor him
22:41:26 <wli> woops that's wrong
22:41:26 <phobes> and dog/cat
22:41:43 <dons> but `erlang is crap' doesn't fit with this zen like approach to language design
22:42:00 <wli> It's 2^{1/2} \int (1 - sd(2^{-1/2} t, 2^{-1/2})^2)^{1/2} (1 + sd(2^{-1/2} t, 2^{-1/2})^2)^{-1/2} cd(2^{-1/2} t, 2^{-1/2}) nd(2^{-1/2} t, 2^{-1/2}) dt with t=sd(2^{-1/2} s, 2^{-1/2}) and s = tan(x/2)
22:42:06 <Korollary> erlang is functional, ergo mathematician's crap. so, no zen.
22:42:18 <arcatan> dons: I follow some erlang RSS feeds
22:42:23 <notsmack> vaguelly remeniscent of timecube
22:42:25 <dons> ah :)
22:42:30 <phobes> lol wli, I'm having flashbacks of you working out the formula for spherical interpolation
22:42:31 <dons> i follow some too, arcatan. that's how i found it.
22:42:55 <dons> so we can only blame google, for finding this guy
22:43:20 <P_D> sd cd nd?
22:44:23 <phobes> This movie I'm watching is just terrible...
22:44:26 <wli> P_D: Glaisher's notation for quotients of Jacobian elliptic functions.
22:44:35 <sjanssen> phobes: what is it?
22:44:51 <Korollary> You can also prevent traffic accidents by killing threads
22:44:51 <phobes> "A slipping downlife"
22:53:04 <notsmack> i like "Why Timing Is the Most Important Thing in Computer Programming"
22:54:23 <SnailRacer> How dare you remember the answer from last time, figure it out again!
22:54:34 <dons> notsmack: :)
22:54:48 <dons> cause how can you control your effects otherwise!?
22:55:24 <notsmack> when the security watchdogs check the virtual clock, the most important thing is that it be the right time
22:56:01 <glguy> dons: I can think of one project at Galois that might think that the idea that functional programs can't be monitored is pretty hilarious
22:56:37 <notsmack> glguy: are you at Galois ,too?
22:56:38 <phobes> glguy:  is it an AI with a sense of humour?
22:56:43 <dons> he seems rather obsessed with very low level details, doesn't he. an embedded systems guy, perhaps.
22:57:34 <dons> we have a purely functional espresso machine, and a haskell program that monitors it
22:57:37 <phobes> glguy:  Wait - are you guys developing ddarius?
22:57:42 <dons> to check we got the tamp right
22:58:03 <omniscientIdiot> What the hell is a "temporal signature"?
22:58:08 <dons> glguy: we need more scriptable components to the office, don't you think?
22:58:13 <notsmack> dons: and is Galois the reason HWN is from 8/7?  ;-)
22:58:23 <glguy> notsmack: yeah, I've been up here since June now :)
22:58:23 <dons> yeah :) :(
22:58:24 <arcatan> omniscientIdiot: how much time something takes, I guess
22:58:44 <glguy> phobes: I don't know what ddarius is, I thought that was someone's irc nick
22:59:18 <phobes> omniscientIdiot:  it's a disturbance in the takyon field caused by a failure of your inertial dampeners
22:59:25 <notsmack> interesting.  anybody else from #haskell, or just you two?
23:00:02 <phobes> glguy: nm, ddarius has complained several times of being accused of being an AI
23:00:30 <glguy> notsmack: there are others :)
23:00:39 <glguy> andyjgill
23:00:42 <glguy> syntaxninja
23:00:57 <glguy> and more!
23:01:03 <notsmack> huh.  must be something cool going on.
23:01:04 <dons> oh, Xen was sold?
23:01:17 * notsmack gets resume together
23:01:33 <arcatan> galois is taking over #haskell
23:01:52 <dons> atomb and elliott started in the last couple of weeks
23:02:12 <glguy> You missed a 't' ;)
23:02:22 <dons> hah i did
23:02:40 <notsmack> "Deficiencies:  Don't know how to write an accent aigu in IRC."
23:03:47 <phobes> I wonder how many of those comments to the COSA site he posted himself...
23:04:02 <dons> yes, i wondered this :)
23:04:22 <dons> i'm sorry for inflicting that on everyone. but it was a curiosity
23:04:33 <dons> Korollary: we need an @cosa plugin :)
23:04:37 <omniscientIdiot> a curious one at that!
23:04:59 <oerjan> phobes: you think one could find out by _carefully_ checking the timing of the comments? >:)
23:05:12 <Adamant> dons - is Galois still focused on security/crypto?
23:05:16 <phobes> hehe
23:05:46 <phobes> Someone should prepare a mystical zen of haskell webpage
23:05:48 <Adamant> if you can talk about that without NDA kicking in
23:07:36 <dons> Adamant: mmm. i'm not working on crypto stuff. security is an overarching theme, though
23:07:42 <Adamant> ah.
23:09:01 <dons> look at the open source releases: file systems, web server test frameworks, curl bindings -- a pretty diverse range of things
23:10:51 <dons> hopefully we can get some more infrastructure for the community released -- with such a big team of haskell hackers now, there's a lot of code flying around
23:11:27 * merus imagines a commerical for "Red Curry: it gives >>= wings!"
23:13:35 <dibblego> I'm giving a talk/workshop on Scala [with a touch of Haskell] at Red Hat in the next couple of weeks (date TBD)
23:13:51 <dons> sweet. well done dibblego
23:14:04 <dons> in the states?
23:14:07 <dibblego> they want to stop using Java :)
23:14:09 <dibblego> no, Brisbane
23:14:18 <dons> oh, didn't know they had a branch there.
23:14:25 <dibblego> yep, 200 metres from my work
23:14:34 <dons> well, you guys have been on the 'let's stop using Java' story for a while now :)
23:14:38 <dons> good to see its paying off
23:14:53 <dibblego> I think I'm on my own mostly these days
23:15:53 <dibblego> getting annoying actually
23:16:50 <dons> mmm
23:17:33 <dibblego> long story :)
23:18:09 * notsmack knows the feeling
23:19:10 <dibblego> we have been studying languages for nearly a year and I still have to have such elementary debates with my fellow colleague(s) who do same
23:19:26 <notsmack> dibblego: i gave a haskell presentation that involved a VB dev yelling "You have to program in TEXT FILES?!  That's older than UNIX!" and storming out
23:19:41 <sjanssen> wow.
23:19:45 <Adamant> jesus
23:19:47 <dibblego> notsmack, that would have been hilarious :)
23:19:54 <Adamant> that's scary. even for VB.
23:20:06 * notsmack is not exaggerating
23:20:21 <dibblego> notsmack, you could point to CAL's object manager or Vital(?) for Haskell
23:20:33 <sjanssen> I probably would have laughed out loud had I been there
23:20:34 <P_D> don't VB folks need text?  it's not labview..
23:20:42 <P_D> *shudder*
23:20:54 <phobes> VB interprets as you type
23:21:04 <Zao> Point-and-drool to define structure and then just fill in the blanks.
23:21:06 <phobes> and occasionally interrupts you with "OMG error" when you try to change lines
23:21:26 <phobes> (maybe it's gotten better - I haven't used a recent version)
23:21:30 <P_D> surely there's some silly emacs mode which does the same for haskell
23:21:56 <Zao> phobes: VB.Net is a rather competent language, far from the old VB.
23:22:22 <Zao> Heck, I even think they'll get lambdas in the next version :)
23:22:23 <phobes> Zao:  I was using VB.Net, and I agree it's much better, but it still would interrupt me once in a while
23:22:48 <phobes> Zao:  Although it seemed to produce excruciatingly slow code in some cases
23:23:06 <dibblego> notsmack, I think the audience of my presentation will be a bit more competent than that; I was whinging about my colleagues
23:23:42 <notsmack> dibblego: i think that was a corner case; i'd imagine you'll be fine :-)
23:26:20 <phobes> I think there's some validity to a criticism of editing text files directly (without a sufficiently smart - versed in your language - editor), though having the results persisted as human readable text seems like a no-brainer
23:26:40 <phobes> Eclipse makes Java programming so much easier
23:27:24 <glguy> Eclipse makes *Java programming* so much easier
23:27:24 <notsmack> java requires eclipse, certainly
23:27:36 <glguy> a wheel barrow makes moving bricks easier too
23:27:39 <Zao> Or netbeans, or a suitably mangled vim.
23:27:45 <dibblego> I only ever used eclipse when forced (when working for IBM)
23:28:05 <phobes> glguy:  If you're suggesting that with haskell, an IDE wouldn't be much of a value-add, then I don't believe you
23:28:10 <dibblego> it is as retarded as the language it supports
23:28:29 <glguy> phobes: I'm suggesting that editing Haskell with vim is perfectly managable
23:28:33 <notsmack> phobes: nah, just that java absolutely requires it in ways that haskell doesn't quite
23:28:43 <glguy> and that editing java with vim exclusively would be a huge hassle
23:28:55 <phobes> glguy:  That's probably true
23:29:01 <phobes> notsmack: same
23:29:13 <notsmack> i suspect that once yi kicks ass, it'll be unbelievably awesome to write haskell code
23:29:44 <coffeemug> good night everyone (I was lurking) :)
23:30:51 <notsmack> i'll be sad if i ever see anything like a tomcat/catalina/spring call-stack in haskell
23:31:21 <phobes> Is there a timeframe on Yi's "long term goal" of making itself the editor of choice for haskell coding?
23:32:19 <notsmack> phobes: probably an unfair question without funding it.  maybe slightly more fair:  anybody know why i can't currently build yi?
23:32:44 <notsmack>     Could not find module `Distribution.Setup':
23:32:44 <notsmack>       it is a member of package Cabal-1.1.6.2, which is hidden
23:32:56 <phobes> notsmack:  I just meant "anyone have a guess when it will be ready?" - not "what's the holdup here?"
23:34:05 <glguy> notsmack: didn't you just paste the answer to your question?
23:34:19 <notsmack> phobes: ah, nevermind then.  my guess is perpertually "eventually."  it seems like as the ghc-api gets better and the text manipulation libraries get better it'll keep improving?
23:34:43 <notsmack> glguy: well, ghc-pkg doesn't show it in parentheses?  i thought that's what shows hidden
23:35:36 <glguy> notsmack: cabal hides things that aren't listed in its build-depends
23:36:28 <notsmack> you're talking about Yi's build-depends, and not Cabal's, right?
23:38:24 <notsmack> i still don't really grok cabal
23:38:29 <glguy> probably in the file: yi.cabal
23:38:35 <glguy> or something similarly named
23:38:46 <notsmack> yep, there's a yi.cabal
23:38:52 <notsmack> build-depends:  filepath>=1.0, ghc>=6.6, base, mtl, regex-posix==0.71
23:39:13 <glguy> so those are the only packages that will not be hidden when you try to build yi
23:39:14 <sorear> dcoutts: can we please have a cabal faq list?
23:39:17 <glguy> if you want something else to be
23:39:22 <glguy> add it to that
23:39:47 <notsmack> glguy: should that be a patch to yi.cabal then?
23:40:55 <glguy> depends... the yi devs might be using a different version of GHC?
23:41:02 <glguy> that exposes that package differently or something
23:41:04 <glguy> I don't know
23:41:18 <notsmack> hmm, adding "Cabal==1.1.6.2" to yi.cabal doesn't seem to fix it...
23:41:38 <sorear> just add Cabal
23:41:51 <notsmack> sorear: same thing
23:42:28 <glguy> you have to rerun configure
23:43:42 <notsmack> configure's what's giving me the error
23:44:47 <notsmack> i'm on ghc-6.6.1, think updating may be a fix?
23:45:29 <notsmack> hm, ghc says: hiding package Cabal-1.1.6.2 to avoid conflict with later version Cabal-1.2.0; is that why it's hidden maybe?
23:46:48 <sjanssen> notsmack: the problem is with Cabal 1.2.0
23:46:59 <sjanssen> they removed the Distribution.Setup module
23:48:06 <notsmack> sjanssen: ah, thanks.  hiding 1.2.0 gets me past that.
