00:18:32 <alexeevg> quicksilver: lol
00:19:05 <alexeevg> oops, it was in reply to "I wasn't aware that ability to play was any barrier to forming an alternative rock band."
00:51:46 <quicksilver> alexeevg: ;)
00:52:20 <osfameron> morning
01:28:44 <ari> http://www.haskell.org/pipermail/haskell-cafe/2007-September/031425.html <- I feel guilty for not having rewired my brain for monads well enough to intuitively know how to write this function knowing the type
01:28:46 <lambdabot> Title: [Haskell-cafe] About mplus, http://tinyurl.com/232znu
01:30:45 <olsner> :t guard
01:30:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
01:53:47 <hpaste>  alexeevg pasted "badly performing function" at http://hpaste.org/2574
01:54:11 <alexeevg> can anyone give me a hint how to optimize ^^^
01:54:51 <alexeevg> i'm calling positions' very often, and profiler tells me that this function spends 98 % on memory allocation
01:55:23 <vincenz> why are you using an acumulator?
01:55:29 <vincenz> That's only useful in strict languages like ML
01:55:39 <vincenz> in haskell you want to use laziness, in which case using this acumulator style isn't ideal
01:56:13 <alexeevg> vincenz: I don't need lazyness here, because I get a Set as a result
01:56:38 <vincenz> so you awnt it strict?
01:56:39 <alexeevg> vincenz: the first version used lists
01:56:42 <vincenz> perhaps then use bbang patterns?
01:56:45 <vincenz> and place a bang on acc?
01:56:47 <vincenz> !acc
01:56:52 <vincenz> similarly for d
01:56:55 <vincenz> since it's just an integer
01:57:20 <alexeevg> vincenz: hmm, might work, I'll try it (though I guess ghc -O2 might do it as well)
02:01:28 * alexeevg wonders if change of runtime from 104 s to 98 s is significant
02:01:47 <vincenz> > (104-98)/104
02:01:49 <lambdabot>  5.7692307692307696e-2
02:01:51 <vincenz> 5%
02:02:26 <alexeevg> I mean it could be random variation
02:02:52 <wli> Variability can be tested.
02:03:01 <vincenz> alexeevg: why not use a list and sort once?
02:03:16 <wli> Student's t test etc.
02:03:18 <vincenz> it seems you're just collecting a set of integers?
02:03:58 <vincenz> hmm
02:04:08 <alexeevg> vincenz: yes, i'm collecting a set of integers. i'll paste original version now (it used lists and performed bad as well)
02:04:54 <hpaste>  alexeevg annotated "badly performing function" with "original version" at http://hpaste.org/2574#a1
02:05:12 <vincenz> no wonder :)
02:05:31 <alexeevg> alexeevg: I guess the problem with the first version was concat . map for singleton lists
02:06:07 <alexeevg> I thought using Data.Set should improve things
02:06:18 <alexeevg> what options are left? DList?
02:06:23 <vincenz> have a test case?
02:06:28 <vincenz> I have an idea
02:06:58 <alexeevg> hmm, test case requires some infrastructure
02:07:02 <alexeevg> what idea?
02:09:48 <vincenz> sec
02:11:24 <vincenz> @type uni
02:11:24 <vincenz> @type uniq
02:11:26 <lambdabot> Not in scope: `uni'
02:11:27 <lambdabot> Not in scope: `uniq'
02:11:31 <vincenz> @hoogle [a] -> [a]
02:11:32 <lambdabot> Prelude.cycle :: [a] -> [a]
02:11:32 <lambdabot> Prelude.init :: [a] -> [a]
02:11:32 <lambdabot> Prelude.reverse :: [a] -> [a]
02:12:04 <vincenz> ok, I might be somewhat off, since I don't have a test case..
02:12:07 <olsner> nub
02:12:11 <alexeevg> map head . group . sort $ xs ?
02:12:11 <vincenz> thx
02:12:14 <vincenz> no
02:12:21 <alexeevg> nub is quadratic
02:12:48 <vincenz> anyways
02:12:55 <vincenz> test case please
02:13:20 <alexeevg> ok, thanks for your attention, i'll try to make a testcase
02:13:39 <fax> @hoogle [a] -> [b] -> [(a,b)]
02:13:40 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
02:13:44 <fax> :D great
02:13:50 <Sizur> is anybody inhere familiar with HAppS?
02:13:53 <fax> how does it owkr?
02:14:16 <fax> @hoogle [x] -> [b] -> [(x,b)]
02:14:17 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
02:14:48 <olsner> > take 5 $ zip [1..] ['a'..'z']
02:14:50 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e')]
02:14:57 <vincenz> crud
02:15:01 <vincenz> I don't have Data.SufficeTree
02:15:11 <hpaste>  vincenz annotated "badly performing function" with "using list continuations" at http://hpaste.org/2574#a2
02:15:14 <vincenz> try htat
02:15:29 <vincenz> hmm
02:15:32 <vincenz> that shoul dbe
02:15:36 <vincenz> a:(uniq (b:r))
02:15:37 <vincenz> in the else case
02:16:46 * alexeevg is trying vincenz's code
02:16:53 <vincenz> might have some small bugs :|
02:17:05 <alexeevg> that's ok, i'll quickcheck that
02:17:09 <vincenz> hard to test without a compiling case
02:17:21 <fax> @hoogle [(x,y)] -> (x -> y)
02:17:22 <lambdabot> No matches, try a more general search
02:17:28 <fax> :<
02:17:31 <vincenz> fax: it should be
02:17:33 <Sizur> HAppS anybody? i have a small design question
02:17:37 <vincenz> @hoogle [(x,y)] -> x -> Maybe y
02:17:39 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:17:39 <vincenz> lookup
02:17:45 <fax> :O
02:17:50 <fax> Awesome!!
02:17:52 <vincenz> well...flip lookup
02:18:20 <fax> @src lookup
02:18:20 <lambdabot> lookup _key []          =  Nothing
02:18:20 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
02:18:20 <lambdabot>                         | otherwise = lookup key xys
02:18:34 <fax> So cool :D
02:19:13 <therp> mudge: your story on "how I became a Haskeller" reads like mine -- if I would have written one :) .. really nice. Common Lisp/Paul Graham. Lambda calculus, type theory :)
02:21:28 <DRMacIver> Mine was closer to "Haskell people pestered me to give the language a try until I gave in". ;)
02:21:32 <fax> > let f = (flip lookup) [(1,'x'),(2,'y'),(3,'z')] in (f 3) -- Amazing :D
02:21:33 <lambdabot>  Just 'z'
02:21:54 <fax> currying is sooooo useful
02:21:58 <fax> Why doesn't everyone do it?
02:23:00 <roconnor> @type flip lookup
02:23:03 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> Maybe b
02:23:39 <fax> @src flip
02:23:39 <lambdabot> flip f x y = f y x
02:23:44 <fax> O_o
02:23:57 <roconnor> @. pl src flip
02:23:58 <lambdabot> (line 1, column 1):
02:23:58 <lambdabot> unexpected end of input
02:23:58 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
02:24:02 <fax> This is riduclous
02:24:08 <fax> There's no possible way haskell can work
02:24:13 <roconnor> @. pl (src flip)
02:24:14 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "(src"
02:24:15 <fax> It's far to succinct
02:24:29 <vincenz> @type (fromJust .) . flip lookup
02:24:31 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> b
02:24:34 <vincenz> ;)
02:24:36 <fax> @pointless flip
02:24:36 <lambdabot> flip
02:24:40 <fax> ?:|
02:24:40 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
02:26:48 <vincenz> alexeevg: so?
02:27:27 <alexeevg> vincenz: thank you very much, but no luck - runtime is still ~ 100 s
02:27:43 * vincenz snaps his fingers
02:27:48 <alexeevg> I understand that this figure means nothing without testcase
02:27:50 <fax> > let f = (flip lookup) $ zipWith (,) [1..] "2357" in (f 3)
02:27:52 <lambdabot>  Just '5'
02:29:05 <olsner> > let f = ("2357" !!) in (f 3)
02:29:07 <lambdabot>  '7'
02:29:09 <alexeevg> I guess I should change algorithm and call `positions' less often in the first place
02:29:12 <fax> aha ;d
02:29:49 <fax> > let f = (flip lookup) $ zipWith (,) [0.01,0.06,0.074,0.213] "2357" in (f 0.06)
02:29:50 <roconnor> > let f = ("2357" !!) . (subtract 1) in (f 3)
02:29:51 <lambdabot>  Just '3'
02:29:52 <lambdabot>  '5'
02:30:40 <vincenz> alexeevg: maybe it's just that complicated?
02:31:09 <vincenz> alexeevg: truth be told, I think the allocations are not due to your algo
02:31:19 <vincenz> alexeevg: afaik, haskell does not inline/fuse accross modules
02:31:26 <vincenz> and if you see, you're constantly getting (lbl, tree) stuff
02:31:33 <vincenz> whch is an allocation and deallocation of a pair
02:32:10 <olsner> > let f = (flip lookup) $ zipWith (,) [0.01,0.06,0.074,0.213] "2357" in (f (0.01*6))
02:32:12 <lambdabot>  Just '3'
02:32:31 <vincenz> so maybe the allocations are due to the creation of the suffix tree, but get measured in positions as this is the first funciton that forces the data structue
02:32:42 <vincenz> alexeevg: I'd try timing a second run of positions after a first one, to see if it'll go faster
02:33:26 <alexeevg> vincenz: hmm, that's a nice tip (about allocation of pairs). I should try Data.SuffixTree.fold, it may cut some allocations
02:33:59 <alexeevg> vincenz: I must hav screwed up something, because I'm trying to implement algorithm that is claimed to be O(n)
02:34:15 <vincenz> alexeevg: well try running positions a few times on the same tree
02:34:18 <vincenz> see if the times vary
02:35:00 <vincenz> if they do significantly from 1 to 2nd execution, then the timing includes the actual creation of the tree
02:36:00 <alexeevg> true, thanks
02:37:21 <alexeevg> argh. ByteStrings don't work in ghci on Windows
02:38:51 <quicksilver> vincenz: haskell does inline and fuse across modules
02:38:58 <quicksilver> vincenz: otherwise bytestrings would be useless :)
02:39:10 <vincenz> quicksilver: oh
02:39:11 * vincenz whoopses
02:39:12 <vincenz> :)
02:39:12 <quicksilver> vincenz: rather, I should say, GHC does inline and fuse across modules
02:39:28 <quicksilver> the cross-module inline threshold is based on code size
02:39:29 <vincenz> I must've been thinking of ocaml then
02:39:33 <quicksilver> but you can override it with a pragma
02:39:34 <vincenz> Ocaml doesn't ;)
02:39:45 <vincenz> or didn't, been a while since I've used it
02:42:08 <alexeevg> vincenz++
02:42:17 * alexeevg is going to lunch
02:43:21 <lick_me_f> http://vans.tbc.bg/uploaded
02:43:49 --- mode: ChanServ set +o vincenz
02:44:02 --- kick: lick_me_f was kicked by vincenz (Please use a proper nickname and don't spam with pointless pictures)
02:44:05 --- mode: vincenz set -o vincenz
02:49:17 <fax> hey I thought I could write a tutorial with lookup
02:49:30 <hpaste>  fax pasted "lookup example" at http://hpaste.org/2575
02:49:37 <fax> So I wrote that..
02:50:06 <fax> but I wonder, if my formatting is ok and I think I should also put in info about currying and partial application involved
02:50:12 <fax> Do you think it's ok?
02:50:48 <vincenz> use literate haskell :)
02:50:51 <vincenz> so the document is executable
02:51:24 <quicksilver> fax: nice
02:51:27 --- mode: ChanServ set +o vincenz
02:51:55 <fax> vincenz: ok I will do that too
02:52:02 <fax> quicksilver: Thans :D
02:52:03 <fax> Thanks
02:52:19 <vincenz> lick_me_f: please change your username
02:54:40 <cizra>         map print (map fib [0..12])
02:54:43 <cizra> Why doesn't it work?
02:55:13 <quicksilver> cizra: well, it does
02:55:22 <quicksilver> cizra: it just doesn't do what you were perhaps expecting
02:55:23 <vincenz> mapM_ print (map fib [0..12])
02:55:32 <quicksilver> cizra: it builds a list of IO actions
02:55:57 <quicksilver> cizra: you could then execute those actions with sequence or sequence_
02:56:10 <quicksilver> and, in fact, mapM_ which vincenz suggested is just sequence . map
02:56:26 <cizra> Thanks!
02:56:45 <vincenz> quicksilver: sequence_ :)
02:57:00 --- mode: vincenz set -o vincenz
02:57:03 <vincenz> @src mapM_
02:57:03 <lambdabot> mapM_ f as = sequence_ (map f as)
02:57:15 <vincenz> @src mapM
02:57:15 <lambdabot> mapM f as = sequence (map f as)
02:57:30 <vincenz> @type sequence
02:57:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:58:29 <quicksilver> vincenz: right, yes, I realised that after I wrote it
02:58:36 <vincenz> I was double checking with the @src :)
02:58:41 <vincenz> wasn't sure myself now
03:01:37 <quicksilver> fax: incidentally, you did spell 'centipede' wrong
03:02:36 <fax> ok will correct it, thank you
03:08:08 <vincenz> lick_me_f:
03:16:33 <hpaste>  fax annotated "lookup example" with "fixes + lhs" at http://hpaste.org/2575#a1
03:16:54 <fax> I made those amendments
03:17:08 <Blwood> huhu
03:17:34 <vincenz> hmm
03:17:41 <vincenz> that's not really literate haskell..
03:18:01 <fax> oops :|
03:18:07 <fax> I misunderstood http://www.haskell.org/onlinereport/literate.html
03:18:08 <lambdabot> Title: The Haskell 98 Report: Literate Comments
03:18:31 <quicksilver> fax: it's nearly literate haskell
03:18:46 <quicksilver> fax: but it contains multiple definitions of f
03:18:50 <quicksilver> at different types :)
03:18:56 <fax> ah :|
03:19:02 <fax> I don't think it needs to be executed just read
03:19:08 <quicksilver> and the *Main> part doesn't go inside >
03:19:14 <quicksilver> because that isn't haskell
03:19:21 <quicksilver> it's a transcript of a ghci session
03:19:23 <fax> ah, removed thanks
03:20:11 <quicksilver> you could call the second one f'
03:20:14 <quicksilver> or f_better
03:20:16 <quicksilver> or something
03:20:50 <fax> ok that's an improvement
03:21:25 <vincenz> not to mention that it tries to apply a string to a number :)
03:21:29 <vincenz> in the first few lines
03:21:40 <vincenz> and there's just plain type definitions on lines without actually saying what they apply to
03:21:52 <fax> oh yaeh
03:21:56 <fax> damn.. haha
03:22:04 <fax> I think my translation to literate haskell is bad
03:24:19 <vincenz> is it me or is 'utilitzed' rather archaic
03:24:24 <vincenz> well, properly spelled
03:25:50 <doserj> http://users.wpi.edu/~nab/sci_eng/99_Apr_22.html
03:25:51 <lambdabot> Title: Scientific English--Utilize and Use
03:26:57 <vincenz> hmm interesting :)
03:35:44 <koeien> @pl y f = f $ y f
03:35:44 <lambdabot> y = fix (ap id)
03:36:28 <opqdonut> @unpl fix ($)
03:36:29 <lambdabot> fix (\ a b -> a b)
03:37:24 <quicksilver> that's very cute
03:37:26 <quicksilver> fix (ap id)
03:37:28 <quicksilver> I like it
03:37:56 <quicksilver> maybe fix (id `ap`)
03:38:00 <opqdonut> > let y = fix (ap id) in y (1:)
03:38:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:38:08 <opqdonut> > let fix (1:)
03:38:09 <lambdabot>  Parse error
03:38:13 <opqdonut> > fix (1:)
03:38:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:38:15 <quicksilver> because that sounds like 'fix it up' with an american accent
03:38:15 <opqdonut> woops :)
03:38:22 <opqdonut> quicksilver: :D
03:38:30 <IvdSangen> @src fix
03:38:30 <lambdabot> fix f = let x = f x in x
03:38:40 <opqdonut> but isn't that ap id redundant?
03:38:47 <koeien> yeah i would think so?
03:39:42 <fax> > let y = fix (ap id) in y (:)
03:39:42 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b] -> [b]
03:39:43 <lambdabot>     Pro...
03:39:59 <quicksilver> :t fix (id `ap`)
03:39:59 <koeien> @type ap id
03:40:01 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
03:40:02 <lambdabot> forall b. (b -> b) -> b
03:40:08 <koeien> :t id ap
03:40:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:40:17 <vincenz> id x === x
03:40:35 <koeien> :t ap id
03:40:37 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
03:40:58 <vincenz> :t fix (ap id)
03:41:00 <lambdabot> forall b. (b -> b) -> b
03:41:05 <vincenz> thought so, all b's
03:41:14 <koeien> yes
03:41:19 <vincenz> which means (:) will never work
03:41:38 <ndm> hello!
03:41:59 <vincenz> > fix (ap id) (1:)
03:42:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:44:04 <koeien> ap id = \f g -> g (f g)
03:46:53 <koeien> hence,  fix (ap id) = let x = (\g -> g (x g)) x in x
03:47:02 <koeien> fix (ap id) = fix
03:49:23 <quicksilver> right, so fix (id `ap`) = fix
03:49:40 <quicksilver> but it's much nicer to say "fix it up" than just "fix"
04:07:37 <alexeevg> does anyone know a nice way of testing inner functions in REPL? Say you have foo = x . y . fold z . z' where { x = ...; y= ... } and suddenly you want to check if `z' works properly?
04:08:11 <jedai> alexeevg: copy-paste ?
04:08:25 <xerox> alexeevg: yeah, it is called lambda-lifting. More on that <http://haskell.org/haskellwiki/Lambda_lifting>
04:08:27 <jedai> alexeevg: with a let before it
04:08:37 <alexeevg> jedai: yeah, obvious but tedious
04:08:55 <alexeevg> xerox: I'll look at it, thanks
04:09:04 <quicksilver> alexeevg: no. it's a bit of a pain.
04:09:13 <jedai> alexeevg: Well lambda lifting is the same
04:09:15 <nominolo> i usually comment out the type sig, and have foo = z
04:09:27 <quicksilver> alexeevg: to be honest it's one reason why I don't use them more often than necessary :)
04:09:36 <alexeevg> jedai: yeah, I just skimmed over a page and realized it ^(
04:09:38 <xerox> Maybe a proper refactoring ide would have a lambda-lifting clicckety-click.
04:09:46 <jedai> nominolo: but that might break a bunch of other functions
04:09:53 <alexeevg> quicksilver: too bad ^(
04:10:20 <jedai> xerox: Yeah, it seems a straightforward thing to do if you have the AST for the code
04:11:01 <quicksilver> it is straightforward but obviously you end up with a bunch of extra parameters in general
04:11:12 * alexeevg thinks that it's better to improve REPL/debugger that force programmer use lambda-lifting, even automated one
04:11:54 <nominolo> jedai, then copy'n'paste and rename first :)
04:12:16 <nominolo> alexeevg, agreed
04:13:36 <tibbe> anyone here running the ghc binary package on a Mac?
04:14:05 <allbery_b> not a recent one (i.e. 6.6.1)
04:14:18 <allbery_b> also,"Mac" isn't specific enough:  PPC or Intel?
04:14:36 <tibbe> allbery_b: intel, just wondering where to put the unzipped ghc folder
04:15:05 <kReepicheep> allbery_b: he means m68k of course
04:15:34 <tibbe> allbery_b: or should I run the install script so it'll poh all over my file system?
04:15:38 <allbery_b> hm.  haven't checked 6.6.1 but with 6.6 you put it anywhere and ran configure/make/make install to get it moed to the preferred install location
04:15:47 <quicksilver> alexeevg: I'm running the darwinports version
04:15:52 <quicksilver> erm
04:15:55 <quicksilver> tibbe: that was for you
04:15:59 <quicksilver> brane hurts
04:16:52 <tibbe> ok
04:17:34 <quicksilver> takes a while to compile but runs well
04:17:46 <quicksilver> I've used binary dist in the past though, and I think I installed it to /usr/local/bin
04:18:00 <allbery_b> yeh, default is under /usr/local
04:18:04 <xerox> tibbe: just 'make install' should do it.
04:18:17 <allbery_b> (whereas macports puts it in /opt/local)
04:18:25 <xerox> ...well, after 'sh configure' indeed.
04:19:42 <xerox> It is easy to remove it afterwards, just delete everything under /usr/local/lib/ghc-6.6.1 and remove che symlinks in /usr/local/bin/.
04:20:04 <tibbe> xerox: ok, thanks
04:20:16 <tibbe> ah great, need a C compiler?
04:20:21 <tibbe> isn't this a binary dist
04:20:39 <allbery_b> hm, I didn't think a C compiler was needed for the binary dist
04:21:11 <allbery_b> that said, the configure boilerplate may not be smart enough to realize that...
04:24:37 <tibbe> argh
04:25:14 <tibbe> so I need XCode?
04:26:48 <ChilliX> tibbe: the reason you need a C compiler is
04:27:36 <ChilliX> because ghc (depending on options) generates C from haskell that the C compiler then compiles to assembly
04:28:38 <ChilliX> tibbe: and, yes, X code is the way to go
04:28:57 <ChilliX> just insert the Mac OS X dvd that came with your mac
04:29:04 <ChilliX> its got X code on it
04:29:33 <xerox> And you also need {GMP,readline}.framework in /Libraries/Frameworks
04:29:46 <tibbe> xerox: got the libs already
04:30:10 <tibbe> just downloaded x code, 6Mb/s rocks ;)
04:30:19 <xerox> Yay :)
04:30:38 <ChilliX> tibbe: yeah, but it really does not make sense to bundle a C compiler with ghc on macos (in contrast to windows)
04:30:52 <ChilliX> macos is a real unix and it has vendor support for a C compiler
04:31:36 <ChilliX> so, other compilers which need a C compiler should build on the vendor compiler
04:31:53 <ChilliX> esp if they explicitly rely on gcc (which X code also uses)
04:33:02 <tibbe> I agree
04:33:14 <tibbe> just a bit annoying that the binary dist requires it
04:34:13 <ChilliX> yeah, I agree that it is annoying
04:34:24 <MyCatSchemes> Hrmn, how much disk space does xmonad take up these days?
04:34:39 <ChilliX> if you ask me, Apple should install those parts of X code (ie, the non-gui stuff) by default
04:34:44 <cizra> MyCatSchemes: 1625760
04:34:52 <MyCatSchemes> cizra: bytes!?
04:34:58 <cizra> yes
04:34:59 <ChilliX> given current HD sizes that wouldn't make a big dent and remove the problem
04:35:08 <cizra> MyCatSchemes: That's the binary
04:35:23 <MyCatSchemes> cizra: man, that's ridiculously tiny. Does it put much in /usr/local/share/?
04:35:33 <kReepicheep> ChilliX: Doesn't microsoft offer a free compiler now?
04:36:12 <ChilliX> kReepicheep: Do they?  And does it come on the windows install cd?
04:36:47 <slarba_> it doesn't
04:37:16 <kReepicheep> ChilliX: Yeah, their visual studio express versions have one I believe
04:37:42 <ChilliX> visual studio express versions?
04:37:57 <quicksilver> tibbe: but the binary dist requires it because ghc is a compiler :)
04:38:01 <slarba_> there's also visual c++ 2003 compiler that comes with the command line tools only
04:38:04 <quicksilver> tibbe: it's not any old program
04:38:08 <ChilliX> I don't think I have ever seen visual studio (in any version) on the cds of any pc I bought
04:38:19 <quicksilver> tibbe: it doesn't need gcc, it also needs an assembler and a linker :)
04:38:28 <slarba_> "visual c++ toolkit 2003"
04:38:30 <quicksilver> tibbe: which are also supplied by xcode
04:38:47 <kReepicheep> it does not come on the install cd's of course
04:39:09 <tibbe> quicksilver: right
04:39:36 <ChilliX> kReepicheep: well, the tradition with unix is that when you buy your new shiny machine and unpack it, you have a flly fledged dev environment in your hand
04:39:48 <ChilliX> kReepicheep: Apple sticks to it
04:40:06 <ChilliX> you can Xcode and no dumped down version or other tease-ware
04:40:09 <ChilliX> the real thing
04:40:18 <ChilliX> can = get
04:40:25 <kReepicheep> ChilliX: it comes in a .mpkg on the default system installs
04:40:56 <pejo> ChilliX, considering Sun doesn't bundle their compiler with Solaris, and HP doesn't bundle their compiler with HP-UX, and I'm fairly sure that IBM doesn't bundle their compiler with AIX..
04:41:05 <ChilliX> kReepicheep: You mean Xcode.  Yeah, its on the DVD in the package.
04:41:41 <kReepicheep> IBM sells their compiler for a good price
04:42:26 <ChilliX> hmm, don't suns have gcc bundled (maybe also on an extra disk)
04:42:38 <ChilliX> their compiler, tyou have to buy
04:42:41 <ChilliX> which is stupid, too
04:43:21 <ChilliX> Why would any os vendor want to prevent people writing apps (or if not prevent make it harder)...except for games consoles ;)
04:43:25 <kReepicheep> with opensolaris, I think they've offer a free bersion
04:43:38 <kReepicheep> s/bersion/version/
04:44:00 <ChilliX> but opensolaris is x86 only, isn't it?
04:44:06 <pejo> ChilliX, oh, you mean the companion CD. Well, yeah, but the general impression is that they're not big fans of gcc.
04:44:15 <kReepicheep> ChilliX: that and sparc
04:44:32 <ChilliX> pejo: of course they give that impression, they want to sell their compiler after all
04:44:41 <pejo> ChilliX, it's more of a necessary evil, just like they bundle gmake there too, since a lot of software today won't compile without it.
04:47:37 <bitwize> > (ap id + 3)
04:47:42 <lambdabot>        add an instance declaration for
04:47:42 <lambdabot>       (Num (((a -> b) -> a) -> (a -> b...
04:47:51 <MyCatSchemes> ChilliX: I'm fairly confident you could probably get OpenSolaris to run on SPARC if you tried really hard... it'd be a bit of a manky arse bummer for Sun if you couldn't. ;)
04:48:02 <bitwize> > (ap id + 3::Int)
04:48:03 <lambdabot>  Couldn't match expected type `Int'
04:48:19 <tibbe> xerox: do you know where mac os x keeps its PATH env variable?
04:48:47 <ChilliX> tibbe: What do you mean with "keep"?
04:48:54 <quicksilver> tibbe: I set mine in .bashrc and .profile
04:48:59 <quicksilver> (just like I would on any other unix)
04:48:59 <ChilliX> Were you set it?
04:49:09 <tibbe> ChilliX: were do I put /usr/local/bin so every user gets ghc
04:49:21 <tibbe> quicksilver: want it globally
04:49:48 <ChilliX> tibbe: /etc/profile
04:49:53 <bdash> tibbe: /etc/profile or /etc/bashrc
04:49:57 <tibbe> thanks
04:50:15 <ChilliX> bad
04:50:16 <kReepicheep> echo 'PATH="/usr/local/bin:$PATH"' >> .bashrc
04:50:22 <quicksilver> /etc/bashrc is good enough
04:50:29 <ChilliX> ^^^oops - that was meant to go to ghci
04:50:31 <quicksilver> since the /etc/profile apple supply sources /etc/bashrc
04:52:14 <alexeevg> what's the best way to extract subdirectory of darcs repo as separate darcs repo?
04:52:18 <pejo> ChilliX, I agree about your statement that you really should want people to write software for your unix though, and hate when I end up with a crippled cc by default (like on HP-UX).
04:53:30 <ChilliX> pejo: What does HP-UX supply?
04:54:02 <MyCatSchemes> ChilliX: a pack of paracetamol in the box along with the install media.
04:54:09 <MyCatSchemes> ChilliX: on account of you'll need it in order to cope.
04:54:39 <allbery_b> System V derivatives tend to provide a script which tells you to buy the expen$ive vendor C compiler package
04:54:44 <pejo> ChilliX, something very crippled so you can basically relink your kernel iirc.
04:55:13 <ChilliX> MyCatSchemes: lol
04:56:46 <allbery_b> hp/ux?  paracetamol?  figures.  ought include at least tylenol-3, maybe oxycontin
04:57:18 <allbery_b> (for the americans:  paracetamol = acetaminophen)
04:57:47 <pejo> allbery_b, heh. A friend expressed it as "once you have zsh installed it's ok".
05:01:49 <MyCatSchemes> pejo: don't forget sudo, screen, irssi...
05:02:51 <pejo> MyCatSchemes, I don't think people buy a 'large' machine from HP to irc from. :-)
05:04:10 <ChilliX> pejo: But it could run *really many* irc clients are once!
05:04:17 <ChilliX> are = at
05:04:20 <MyCatSchemes> pejo: oh yeah, and mutt and xdaliclock and root-tail and urxvt and xpenguins and Nethack.
05:05:03 <MyCatSchemes> pejo: well what else *would* you wanna buy HP's big iron for, other than getting fifty thousand irssi instances to connect to fifty thousand IRC channels apiece simultaneously?
05:05:27 <profmakx> ghc?
05:05:37 <vincenz> fifty thousand lambdabots
05:05:53 <profmakx> world domination!
05:05:57 <MyCatSchemes> vincenz: that too, because you've got to have something to *do* with all those irssi sessions :)
05:06:20 <vincenz> I wonder what the computational power of fifty-thousand lambdabots is...
05:06:21 <vincenz> o.O
05:06:29 <MyCatSchemes> profmakx: eh, GHC runs fine on smelly boring tiny consumer kit with 128 megabytes. I know this firsthand. :)
05:07:05 <profmakx> well, i`d like to try out all those fancy paralellism things on more than 2 processors
05:07:32 <vincenz> yes, let's get a fibonacci running on 50k procs :)
05:07:55 <MyCatSchemes> profmakx: this is true.
05:28:10 <Sizur> "there are 3 fundamental logical operators (or, and, not) using which you can derive all others" are they really fundamental?
05:28:30 <wli> Just use nand.
05:28:45 <idnar> or nor
05:29:03 <vincenz> idnar: no, just nor, don't need or :P
05:29:04 <Sizur> can you define the three in terms of only nor or only nand?
05:29:07 <vincenz> yes
05:29:15 <vincenz> nand = not . and
05:29:17 <vincenz> erm
05:29:19 <allbery_b> IIRC the composite nand and nor are more convenient, but you can derive all of them from the three basic ones
05:29:20 <vincenz> and = not . and
05:29:23 <vincenz> and = not . nand
05:29:27 <Sizur> show please. i know you can use just "implies"
05:29:29 <idnar> vincenz: tee hee
05:29:41 <quicksilver> x nand x gives you not
05:29:49 <quicksilver> then not . nand gives you and
05:29:58 <vincenz> and x y = not . nand $ x y,  not x = nand x, or x y = nand (not x) (not y)
05:30:02 <quicksilver> then not . (not x) and (not x) gives you or
05:30:05 <vincenz> there you go
05:30:08 <quicksilver> and the rest is easy
05:30:20 <vincenz> and x y = not $ nand x y
05:30:25 * vincenz curses his typist
05:30:56 <vincenz> quicksilver: can I rent your typist?
05:31:13 * allbery_b used to do this stuff in discrete logic aeons ago
05:31:25 <Sizur> i still like implies more :)
05:31:32 <allbery_b> (in hardware, that is)
05:31:36 <fax> and x y = nand (nand x y) (nand x y)
05:31:37 <fax> ?
05:31:58 <vincenz> no
05:32:05 <vincenz> or yes
05:32:14 <vincenz> but it's actually
05:32:20 <vincenz> and x y = let z = nand x y in nand z z
05:32:50 <fax> @pointless nand (nand x y) (nand x y)
05:32:50 <lambdabot> nand (nand x y) (nand x y)
05:32:54 <fax> >:|
05:33:04 <vincenz> @pointless and x y = nand (nand x y) (nand x y)
05:33:04 <lambdabot> and = ap (ap . (nand .) . nand) nand
05:33:19 <vincenz> fax: how should it know what are parameters ..
05:33:38 <fax> :t nand
05:33:42 <lambdabot> Not in scope: `nand'
05:33:48 <fax> ah, ok
05:38:22 <Sizur> @pointless implies a b = if a then b else True
05:38:22 <lambdabot> implies = flip flip True . if'
05:38:38 <Sizur> @type implies
05:38:40 <lambdabot> Not in scope: `implies'
05:39:07 <allbery_b> and implication is ¬p∨q
05:39:08 <vincenz> @type let implies a b = if a then b else True in implies
05:39:11 <lambdabot> Bool -> Bool -> Bool
05:40:24 <Sizur> my point is you can define all operators using implication only
05:40:29 <Sizur> didnt know you could use nand
05:40:59 <alexeevg> Sizur: implication is insufficient
05:41:03 <fax> I didn't know you could use implication :p
05:41:10 <Sizur> i will show it is
05:41:15 <allbery_b> back when people hacked discret logic in hardware, it was convenient to use quad nand gates hooked together in various ways
05:41:35 <fax> implies a b = if a then b else True
05:41:38 <fax> Why else True?
05:41:44 <Sizur> @let imply a b = if a then b else True
05:41:44 <sieni> fax: because
05:41:46 <lambdabot> Defined.
05:41:46 <allbery_b> rather than separrate components for not, and, or (or for all possible rules)
05:41:52 <vincenz> fax: cause it's "if .. then .. else .."
05:42:04 <fax> why else True and not else Flase?
05:42:11 <Sizur> @let myNot a = a imply False
05:42:13 <vincenz> fax: if a is false then the implication is always true
05:42:14 <lambdabot> Defined.
05:42:17 <allbery_b> fax: because the only case that *cannot* happen is p false and q true
05:42:34 <fax> aha
05:42:54 <Sizur> @let myNot a = a `imply` False
05:42:55 <lambdabot> Couldn't match expected type `Bool'
05:43:25 <vincenz> @unlet
05:43:27 <lambdabot> Defined.
05:43:28 <hpaste>  fax pasted "implies?" at http://hpaste.org/2576
05:43:33 <Sizur> ok i cannot make labdabot do what i want. here's in english
05:43:34 <fax> damn
05:43:40 <fax> hpaste cannot handle unicode?
05:43:57 <Sizur> let --> denote logical implication
05:44:05 <Sizur> not a = a --> False
05:44:08 <vincenz> or simply =>
05:44:12 <vincenz> :)
05:44:17 <Sizur> ok have it =>
05:44:30 <Sizur> or a b = a => b => b
05:44:40 <sieni> Sizur: well, with implication you are using a constant for False as well
05:44:43 <Sizur> and a b = a => (b => False) => False
05:44:48 <Sizur> so?
05:44:54 <vincenz> a constant for false isn't that hard, it's just drawing a line to the source
05:44:56 <vincenz> erm
05:44:58 <vincenz> to the ground
05:45:03 <sieni> Sizur: so you are not defining other connectives with implication alone
05:45:11 <vincenz> sieni: you are in hardware
05:45:13 <allbery_b> I think I got my statementbackwards.  p implies q -> p true, q false is invalid (hjence false) --- all other states are valid, in particular p false says nthing about q so the implication returns true
05:45:16 <vincenz> sieni: true and false are for free
05:45:21 <sieni> Sizur: like it's possible with NOR and NAND
05:45:44 <Sizur> i see, you dont need to introduce a constant for them
05:45:51 <vincenz> but flipflops are rather cheap to define with nands, not sure how expensive that'd be with an implicative primitive
05:46:01 <vincenz> Constants needn't bei ntroduced in hardware!
05:46:02 <vincenz> they're there
05:46:06 <vincenz> you have the ground and the source
05:46:21 * vincenz mutters "computer scientists"
05:46:44 <allbery_b> heh
05:46:45 <Sizur> lol
05:47:36 <allbery_b> the discrete logic representing a constant is a resistor or capacitor, as appropriate, tied to +Vcc or ground
05:47:46 <vincenz> exactly
05:47:54 <fax> how to write implies using just   and or not xor?
05:48:01 <allbery_b> (I did say I used to do this stuff)
05:48:27 <allbery_b> you have (not p) or q.  you have translations for them
05:48:28 * vincenz smacks sieni with an already developed pvc board
05:48:33 <vincenz> feel the solder
05:48:35 <fax> not (and x (xor x y))
05:48:43 <fax> Any shorter way?
05:48:45 <vincenz> why use xor, it's superfluous
05:48:50 <fax> how shorter then?
05:48:51 <alexeevg> fax: implies a b = not a || b
05:48:59 <liyang> (capacitor tied to ground? PVC boards? What?)
05:49:10 <fax> ahh
05:49:10 <fax> nice
05:49:30 <vincenz> nand (nand (nand a) b)
05:49:35 <vincenz> erm
05:49:40 <vincenz> nand a (nand b)
05:49:48 * vincenz coughs and hides himself
05:50:25 <allbery_b> liyang: capacitors generally used in case the power supply has flutter (i.e. incompletely rectified AC power source), or to otherwise stabilize voltage
05:50:53 * vincenz reminesces in the days he was working with opams
05:50:54 <vincenz> +
05:50:55 <vincenz> p
05:51:02 * vincenz really fires his typist now and hires a new one
05:51:15 <allbery_b> heh.
05:51:18 <allbery_b> (op-amps)
05:51:32 <allbery_b> for the now bewildered onlookers...
05:51:38 <ddarius> Feedback, everyone loves feedback.
05:52:00 <liyang> allbery_b: er, yes but how does that have anything to do with logical constants?
05:52:34 <allbery_b> liyang: in general 1 and 0 are voltage levels.  if your voltage level varies for some reason, then your constant may not in fact be "constant"
05:52:53 <vincenz> or D-flipflops
05:53:03 <allbery_b> er, reverse the quoting there:  your "constant" may not be constant
05:53:13 <liyang> this is digital logic we're talking about right?
05:53:14 * kReepicheep wonders if they turned in breadboards for cs 101
05:53:17 <allbery_b> but in general, a constant in discrete logic is just a tie to Vcc or ground
05:53:20 <vincenz> allbery_b: all depends on your definition of 'constant', to speak like a computer scientist
05:53:29 <liyang> >_>
05:53:34 <vincenz> usually with a resistor to limit current
05:53:38 <allbery_b> the resistor and/or capacitor are concessions to the real world
05:53:47 <ddarius> liyang: The level just below digital logic.
05:53:58 <vincenz> that level is still ok
05:54:01 <vincenz> it's the level below that
05:54:08 <vincenz> when you start talking about the phases of a transistor that freaks me
05:54:53 <ddarius> It's just signal processing.
05:55:48 <vincenz> what is?
05:55:56 <ddarius> Analog electronics.
05:55:59 <vincenz> heh
05:56:06 <vincenz> It's a bit more complicated than that
05:56:09 <vincenz> signal processing is nicely linear
05:56:17 <ddarius> Most of the time.
05:56:22 <vincenz> it's when you're outside of that linear region that transistors scare me
05:57:16 <ddarius> Modulation, for example, is well within the realm of signal processing.
05:58:28 * vincenz peers at ddarius 
05:58:31 <vincenz> Of course it is
05:58:35 <vincenz> modulation is in the linear region of transistors
06:00:00 <ddarius> Actually, class D or C wirings of transistors are often used for amplitude modulation.
06:01:28 <liyang> (What are you doing with digital electronics when your power supply fluctuates sufficiently as to cause a line tied straight to +Vcc or Gnd to be interpreted as anything other than 1 and 0? Has the Real World changed since I last looked...?)
06:01:34 <hpaste>  fasta pasted "Basic Haskell properties do not hold..." at http://hpaste.org/2577
06:02:00 <allbery_b> liyang: I'm talking about an older world
06:02:01 <vincenz> liyang: that's not really hard, given that typically the headroom nowadays is measured in the 10ths of a volt
06:02:06 <fasta> (as is a list of length 1)
06:02:08 <allbery_b> in particular, I worked with TTL logics
06:02:18 <vincenz> Or modern day processors :)
06:02:46 <ddarius> A diode is not linear at all, but if we focus on one part, squint a little and say it's an exponential curve, and expand in a Taylor series we get an output signal that is the sum of the input (amplitude) modulated with itself more and more times.
06:02:57 <vincenz> ddarius: I was referring to when you go in reverse bias, or cutoff
06:02:59 <ddarius> Or truncating horribly, x + x*x
06:03:00 <vincenz> I forgot the terminology
06:03:06 <vincenz> but there's more than just linear and semi linear
06:03:40 <ddarius> vincenz: class D only pops out of reverse bias for a "pulse" and class C spends most of its time in reverse bias.  Only class A is linear.
06:04:45 <vincenz> hmm
06:05:56 * liyang thinks you're all insane. Or we're from different pasts. Or both.
06:07:14 <fasta> This is spooky. Adding a call to unsafePerformIO changes the results of completely unrelated code...
06:07:32 <DRMacIver> That's pretty unsafe. :)
06:08:12 <Sizur> dont think you can do [a] <- bar x
06:08:22 <fasta> Sizur: that doesn't matter.
06:08:25 <fasta> Sizur: since you can
06:08:42 <fasta> DRMacIver: no, it's a compiler bug.
06:08:56 <fasta> DRMacIver: there's no way unsafePerformIO is specified like this.
06:09:01 <DRMacIver> fasta: Yes. Compiler bugs are pretty unsafe. :)
06:09:07 <ddarius> unsafePerformIO is barely specified
06:09:12 <Lemmih> fasta: A GHC compiler bug?
06:09:17 <fasta> Lemmih: yes
06:09:24 <Lemmih> fasta: Are you sure?
06:09:26 <fasta> I wonder what it will do when I compile it.
06:09:32 <fasta> This is ghci.
06:09:43 <DRMacIver> Oh. That invalidates my next question then. :)
06:09:57 <vincenz> fasta: test-case/
06:10:17 <fasta> vincenz: probably hard to create...
06:10:55 <vincenz> and the process of creating it will probably shed more light :)
06:11:32 <fasta> If there was just another Haskell compiler that could do everything GHC can...
06:11:43 <quicksilver> fasta: well they're not the same, in that the second one will fail in the monad if 'bar x' doesn't return exactly one item
06:11:55 <fasta> quicksilver: I asked for the length
06:11:56 <quicksilver> fasta: but I assume that's not what you're talking about
06:11:58 <fasta> quicksilver: it's one
06:13:39 <Saizan> well the second version is still stricter, no?
06:14:20 <fasta> Saizan: I use both the output variables.
06:14:28 <fasta> Saizan: so, that shouldn't be the case.
06:16:07 <fasta> GHC seems to _compile_ it ok
06:16:16 <vincenz> That dastardly ghc
06:16:39 <fasta> Even with the calls to unsafePerformIO
06:18:02 <fasta> Will GHCi use the optimized native code when it's available?
06:18:11 <fasta> Since it now returns the right answer too.
06:18:37 <quicksilver> ghci will use .o files for "other modules"
06:18:48 <quicksilver> but always interprets the one you told it to load explicitly
06:18:49 <quicksilver> I think
06:19:21 <Igloo> No, it'll use the .o whenever there is one
06:19:40 <Igloo> (it might do an up-to-date check too)
06:19:42 <fasta> Ok, this is great, now it all appears to work. :(
06:20:02 <fasta> I have had this on more than one occasion.
06:20:54 <vincenz> haha
06:21:01 <vincenz> @remember fasta Ok, this is great, now it all appears to work. :(
06:21:02 <lambdabot> Done.
06:21:44 <Sizur> quicksilver: are you from dbix?
06:22:48 <quicksilver> Sizur: I'm *from* the uk
06:22:55 <quicksilver> Sizur: but I'm in #dbix-class, yes :)
06:22:59 <gipy> !
06:23:50 <fasta> Still, something odd, is going on, I just replaced equals with equals and it stopped working(returned wrong answer).
06:24:04 <fax> "replaced equals with equals" ?
06:24:18 <fasta> Yes, I moved a foldM <...> to a function.
06:24:33 <fasta> And then instead of the foldM I called that function.
06:24:36 <Sizur> quicksilver: odd couple: perl + haskell :) perl was my favorite before i found out about haskell
06:25:05 <vincenz> Sizur: Heh, that's like saying "pinto + ferrari" "pinto's were my favourite until I found out about ferraris"
06:25:20 <quicksilver> Sizur: smart people are interested in good tools. Haskell and DBIx::Class are both good tools, although in radically different ways.
06:26:06 <Sizur> quicksilver: ORMs limit me
06:26:41 <Sizur> relational is more expressive
06:27:01 <bitwize> I haven't met the orm yet that wasn't cumbersome in some way or another
06:27:08 <dylan> ORMs are good if you're using mysql and sucky if you have a real database. ;)
06:27:17 <vincenz> what is a real database?
06:27:28 <Sizur> doesnt exist yet
06:27:30 <dylan> postgresql, and for my purposes, sqlite.
06:27:37 <fasta> Hmm, I think there's some interaction between unsafeInterleaveST and unsafePerformIO
06:27:50 <bitwize> I guess you have to make the tradeoff: does the convenience of being able to invoke methods on in-memory foos loaded from my FOO table offset the cumbersome aspects?
06:28:10 <fasta> Length forces all the unsafeInterleaveST actions, which could explain the results I see.
06:28:24 <fasta> With length everything is OK, without that call, it's not.
06:28:26 <Naktibalda> sqlite is real db? o_O
06:28:47 <fax> :t (\u->u u)
06:28:49 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
06:28:49 <lambdabot>     Probable cause: `u' is applied to too many arguments
06:28:54 <fax> ah dammit
06:29:10 <Sizur> vincenz: i contest your parallel of pinto and perl :) but still haskell is better
06:29:10 <vincenz> nice try ;)
06:29:34 <vincenz> Sizur: I proposed a perfectly parsimonous pair of pinto and perl
06:29:35 <fasta> Ok, I think it'
06:29:37 <dylan> Naktibalda: it supports foreign keys, mysql only does that when using a specific database type.
06:29:40 <fasta> s not a compiler bug :)
06:30:04 <dylan> it's lot a easier shuffling sql between sqlite and postgres, so I prefer them. :)
06:30:12 <fasta> Just a rather complex interaction. About the same issue as modifying elements in an iterator in Java/C++.
06:30:50 <fax> > [1..3..20]
06:30:50 <lambdabot>  Parse error
06:30:58 <fax> > [1,3...30]
06:30:59 <lambdabot>   Not in scope: `...'
06:31:00 <vincenz> [1,3..20]
06:31:03 <vincenz> > [1,3..20]
06:31:05 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
06:31:07 <fax> aha
06:31:16 <fax> Is there a full specification for this sy=ntax?
06:32:16 <vincenz> the h98 report?
06:32:28 <fasta> I am currently using a <- b, where b uses unsafeInterleaveST, a is a list. Is there a way other than using length to force all the actions in b?
06:33:14 <fasta> I could reimplement b without unsafeInterleaveST, but that would duplicate code for every lazy and non-lazy use of b.
06:33:18 <Saizan> > enumFromThenTo 1 3 20
06:33:20 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
06:33:23 <fax> ah yeah, I found that, cheers vincenz
06:33:28 <Saizan> ?hoogle rnf
06:33:29 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
06:33:37 <vincenz> s/cheers vincenz/vincenz++
06:34:08 <fasta> Saizan: was that for me?
06:34:09 <Saizan> > rnf (1:undefined) `seq` ()
06:34:11 <lambdabot>  Undefined
06:34:15 <Saizan> fasta: yes
06:34:37 <fasta> Saizan: does that have zero run-time cost?
06:34:55 <fasta> I will read the docs ;)
06:34:55 <Saizan> fasta: have you seen deepSeq?
06:35:20 <roconnor> I only vaguely understand how my recursive function works.  and I only vaguely understand it's proof of correctness,  but coq understands both, so I guess that is good enough.
06:35:26 <fasta> Saizan: yes, but haven't used it, so I am not very familiar with it.
06:35:27 <roconnor> The human is out of the loop
06:35:44 * vincenz finished the naked sun in less than a day
06:37:26 <roconnor> stupid unintellegable continuation passing style...
06:39:10 <oerjan> er, isn't continuation passing style nearly isomorphic to do syntax?
06:39:37 <quicksilver> not really, no
06:39:51 <quicksilver> not if you're threading continuations through multiple arguments
06:39:59 <quicksilver> :t either
06:40:01 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:40:06 <quicksilver> that kind of thing, only more so
06:40:13 <oerjan> ah
06:40:26 <conal> for instance, success & failure continuations in logic programming
06:40:32 <oerjan> have you seen Raph Levien's IO language?
06:40:33 <conal> (implementation of LP)
06:41:54 <oerjan> @go amalthea io levien
06:41:57 <lambdabot> http://lambda-the-ultimate.org/node/1108
06:41:57 <lambdabot> Title: OOPSLA 2005: Io, a small programming language | Lambda the Ultimate
06:42:25 <oerjan> hm, not the link i wanted (although it does contain a further link iirc)
06:44:07 <oerjan> http://www.guldheden.com/~sandin/amalthea.html
06:44:09 <lambdabot> Title: vague's - amalthea
06:44:19 <vincenz> oerjan: what about it?
06:44:28 <oerjan> it's continuation based
06:44:50 <oerjan> everything is continuation passing
06:44:50 <vincenz> ah
06:44:54 <vincenz> I see
06:44:58 <vincenz> though I fail to see how IO ties into this
06:45:03 <vincenz> IO is a prototype-based language
06:45:08 <oerjan> wrong IO
06:45:12 * vincenz nods
06:45:27 <vincenz> people should invent more unique, and more importantly, more googly names
06:45:47 <oerjan> if you look in the faq for the prototype Io, you will find an apology for not noticing the name was taken :)
06:46:15 <fasta> It was taken 2000 years ago already ;)
06:47:52 <fax> > [6,4..-20]
06:47:52 <oerjan> http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/finkel02.pdf
06:47:55 <lambdabot> http://tinyurl.com/y39uw5
06:47:56 <lambdabot>   Not in scope: `..-'
06:48:05 <fax> > [6,4..(-20)]
06:48:07 <lambdabot>  [6,4,2,0,-2,-4,-6,-8,-10,-12,-14,-16,-18,-20]
06:48:15 <oerjan> (the free partial description)
06:49:00 <oerjan> the actual paper is behind the ACM moats...
06:49:32 <fax> > [20..0]
06:49:34 <lambdabot>  []
06:49:45 <vincenz> > [20, 19..0]
06:49:47 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]
06:50:17 <fax> > [42,42..]
06:50:18 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
06:50:36 <fax> :D
06:50:45 <oerjan> > [42,42..42]
06:50:46 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
06:50:56 <oerjan> > [42,42..43]
06:50:58 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
06:51:01 <fax> :o
06:51:06 <oerjan> > [42,42..41]
06:51:08 <lambdabot>  []
06:51:12 <fax> > last [42,42..43]
06:51:16 <lambdabot> Terminated
06:51:17 <osfameron> I would have expected [42,42..42] to terminate a little earlier
06:51:23 <vincenz> no
06:51:35 <osfameron> as it does indeed reach the end of the sequence (42)
06:51:37 <oerjan> incidentally, why should ..41 behave differently?
06:51:56 <vincenz> [a,b..c] = let d = b - a in if a > c then [] else a:[b,b+d..c]
06:52:18 <vincenz> @src enumFrom
06:52:19 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:52:21 <vincenz> @src enumFromTo
06:52:22 <lambdabot> Source not found. stty: unknown mode: doofus
06:52:25 <oerjan> no, definitely not that
06:53:21 <vincenz> @hoogle enumFrom
06:53:22 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
06:53:22 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
06:53:22 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
06:53:27 <vincenz> @src enumFromThenTo
06:53:27 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:53:30 * vincenz smacks lambdabot 
06:53:45 <oerjan> it's a method!
06:54:15 <vincenz> point
06:54:26 <vincenz> how do you do the src of a specific method again?
06:54:36 <vincenz> @src enumFromThenTo Int
06:54:37 <lambdabot> Source not found. It can only be attributed to human error.
06:54:45 <vincenz> @src enumFromThenTo :: Int -> Int -> Int -> [Int]
06:54:45 <lambdabot> Source not found. My mind is going. I can feel it.
06:54:49 <oerjan> the other order
06:54:53 <vincenz> @src Int enumFromThenTo
06:54:53 <lambdabot> Source not found. I feel much better now.
06:54:57 <vincenz> @src Integer enumFromThenTo
06:54:58 <lambdabot> Source not found. Where did you learn to type?
06:55:05 * vincenz sighs whistfully
06:55:08 <oerjan> except it is of course not available
06:55:16 <vincenz> thanks for the post-factuum info :)
06:56:15 <oerjan> "The sequence enumFromThenTo e1 e2 e3 is the list [e1,e1+i,e1+2i,...e3], where the increment, i, is e2-e1. If the increment is positive or zero, the list terminates when the next element would be greater than e3; the list is empty if e1 > e3. If the increment is negative, the list terminates when the next element would be less than e3; the list is empty if e1 < e3."
06:56:35 <oerjan> (Int and Integer, from the report)
06:56:40 <vincenz> [42,42..42]
06:56:47 <vincenz> > [42,42..42]
06:56:49 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
06:57:11 <fax> > [[0],[0,1]...]
06:57:11 <lambdabot>  Parse error
06:57:38 <quicksilver> fax: it only works for instances of Enum
06:57:38 <fax> > [(0,1),(1,1)...]
06:57:38 <lambdabot>  Parse error
06:57:39 <oerjan> > [42,42..41] -- buggy?
06:57:40 <lambdabot>  []
06:58:23 <vincenz> the increment isn't positive
06:58:23 <quicksilver> although, I'm not sure why that's a parse error I must admit
06:58:28 <oerjan> actually, that's right
06:58:36 <oerjan> three dots
06:58:39 <quicksilver> ah
06:58:50 <quicksilver> > [(0,1),(1,1)..]
06:58:51 <lambdabot>   add an instance declaration for (Enum (t, t1))
06:58:51 <lambdabot>     In the expression: [(0, ...
06:58:56 <quicksilver> that's the error I expected :)
06:59:03 <fax> How do you add Enum?
06:59:11 <fax> So that  [(0,1),(1,1)..] generates fibonacci
06:59:19 <quicksilver> > [(False,False)..]
06:59:21 <lambdabot>   add an instance declaration for (Enum (Bool, Bool))
06:59:21 <lambdabot>     In the expression: ...
06:59:57 <vincenz> bool isn't an enum?
07:00:08 <oerjan> tuples of Bools aren't
07:00:13 <fax> > [False,...]
07:00:13 <lambdabot>  Parse error
07:00:17 <fax> > [False..]
07:00:18 <lambdabot>  Parse error
07:00:26 <fax> > [False ..]
07:00:28 <quicksilver> there's no instance for Enum a, Enum b => Enum (a,b)
07:00:28 <lambdabot>  [False,True]
07:00:32 <vincenz> that's pretty lame
07:00:33 <fax> hhaha :D
07:00:39 <quicksilver> although I think you could make a good case for allowing one if a was Bounded
07:00:47 <vincenz> fax: False can be interpreted as a module name
07:00:47 <quicksilver> erm
07:00:56 <quicksilver> if b was bounded, rather
07:01:13 <quicksilver> Enum a, Enum b, Bounded b => Enum (a,b)
07:01:16 <profmakx> using diagonalisation one could make this work without bounds too
07:01:24 <profmakx> (i think)
07:01:43 <quicksilver> yes, but it would be inconsistent with the finite orderings
07:01:46 <quicksilver> which would be strange
07:01:54 <quicksilver> mind you, we have some pretty strange Enum instances as is
07:01:58 <vincenz> you don't need bounded
07:01:59 <quicksilver> like the one for Double
07:02:04 <profmakx> ieks
07:02:06 <profmakx> okay
07:02:08 <vincenz> (a,b) .. (c,d)  is just a rectangle
07:02:15 <quicksilver> vincenz: that's IX
07:02:20 <quicksilver> vincenz: not Enum
07:02:30 <quicksilver> would be a bit odd if Enum behaved that way
07:02:34 <vincenz> why is that?
07:02:38 <quicksilver> I assume this is why Ix exists
07:02:39 <fax> How can you make it enum that?
07:02:52 <fax> as in [(0,0)..(3,5)] ?
07:02:54 <quicksilver> vincenz: think about the relationship with the order
07:03:06 <quicksilver> vincenz: and (a,b) .. (c+1,d-1) and stuff
07:03:06 <vincenz> quicksilver: oh like succ and prev?
07:03:11 * vincenz nods
07:03:16 <vincenz> right, there wouldn't be a total order
07:03:17 <quicksilver> vincenz: (a,b) is also an Ord instance
07:03:18 <vincenz> or at least a consistent one
07:03:27 <quicksilver> and all other Enum instances are consistent with their Ord instances
07:03:33 * vincenz nods
07:03:45 <quicksilver> I've always assume that's why Ix exists at all
07:03:50 <fax> Can't it be done?
07:03:52 <quicksilver> (rather then just using Enum for array indexing)
07:05:23 <liyang> http://haskell.org/haskellwiki/Liyang/sudoku.hs has an Enum (a,b) instance for any Bounded, Ix and Enum a and b. FYI.
07:05:24 <lambdabot> Title: Liyang/sudoku.hs - HaskellWiki
07:08:02 <fax> liyang: Can I use [(0,0)..(3,5)] with it?
07:08:30 <fax> [(0,0)..(3,5)] :: [(Int,Int)] gives me a divide by zero :/
07:09:07 <liyang> er, you're kind of restricted by the fact that to/fromEnum take/give Ints. :-/
07:09:13 <nominolo> aren't that infinitely many elements in between?
07:09:22 <liyang> nominolo: *nod*
07:09:57 <liyang> well, if we take 2^32 to be infinity.
07:10:00 <fax> I thought there was only 24 elements
07:10:11 <nominolo> > [(x,y) | x <- [0..3], y <- [0..5]]
07:10:18 <vincenz> I hate it when linux freezes
07:10:23 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2,...
07:10:30 <fax> eyah
07:10:34 <fax> That is what I wanted :D
07:10:40 <fax> > length [(x,y) | x <- [0..3], y <- [0..5]]
07:10:41 <lambdabot>  24
07:10:50 <aleator> Hey, can any suggest a fast and idiomatic way of grouping list of numbers according to their distance from given list of prototypes?
07:11:04 <fax> > length [(0,0)..(3,5)]
07:11:06 <lambdabot>   add an instance declaration for (Enum (t, t1))
07:11:26 <liyang> (0,maxBound) would be in [(0,0)..(3,5)], according to the default Ord on (a,b)
07:12:19 <oerjan> aleator: can you be more precise?
07:12:29 <liyang> But you can write [(False,False) .. (True,True)]
07:12:41 <vincenz> aleator: something like
07:13:19 <vincenz> groupBy snd $ sortBy snd $ zipWith (\x y -> (x, (x-y)^2)) list prototypes?
07:13:58 <vincenz> @hoogle sortBy
07:13:58 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:14:09 <vincenz> @hoogle sortBy
07:14:09 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:14:13 <vincenz> @hoogle groupBy
07:14:14 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
07:15:13 <oerjan> i'd expect he wants a double map rather than zipWith
07:15:33 <oerjan> of sorts
07:15:43 <vincenz> > let over f g x y = g (f x) (f y) in groupBy (snd `over` <=) $ sortBy (snd `over` compare) $ zipWith (\x y -> (x, (x-y)^2)) [1,2,3,4,5,6,8,9] [1..]
07:15:43 <lambdabot>  Parse error
07:15:55 <vincenz> > let over f g x y = g (f x) (f y) in groupBy (snd `over` (<=)) $ sortBy (snd `over` compare) $ zipWith (\x y -> (x, (x-y)^2)) [1,2,3,4,5,6,8,9] [1..]
07:15:56 <lambdabot>  [[(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(8,1),(9,1)]]
07:16:07 <fasta> Why isn't rnf implemented in the evaluator?
07:16:11 <oerjan> over?
07:16:13 <vincenz> > let over f g x y = g (f x) (f y) in groupBy (snd `over` (==)) $ sortBy (snd `over` compare) $ zipWith (\x y -> (x, (x-y)^2)) [1,2,3,4,5,6,8,9] [1..]
07:16:15 <lambdabot>  [[(1,0),(2,0),(3,0),(4,0),(5,0),(6,0)],[(8,1),(9,1)]]
07:16:40 <fax> What is the type of an odd Int?
07:16:51 <vincenz> > let on f g x y = g (f x) (f y) in groupBy (snd `on` (<=)) $ sortBy (snd `on` compare) $ zipWith (\x y -> (x, (x-y)^2)) [1,2,3,4,5,6,8,9] [1..]
07:16:51 <oerjan> in Haskell, Int
07:16:52 <lambdabot>  [[(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(8,1),(9,1)]]
07:16:54 <vincenz> oerjan: happier?
07:17:07 <fax> I want a type specifically odd Ints
07:17:08 <fax> though
07:17:16 <vincenz> newtype OddInt = OddInt Int
07:17:20 <nominolo> > (0,4312421) < (1,3)
07:17:22 <lambdabot>  True
07:17:32 <vincenz> then allow only proper constructors :)
07:17:35 <oerjan> well i'm still not sure aleator wanted to compare each number with just one prototype
07:17:49 <vincenz> oerjan: then he should give more specs :)
07:18:09 <conal> or interpret the contained int via  asOdd i = 2 * i + 1, for instance
07:18:35 <conal> asOdd (OddInt i) = 2 * i + 1
07:19:06 <fax> f (x :: Even Int) = f x / 2
07:19:06 <fax> f (x :: Odd Int) = f (3 * x + 1)
07:19:07 <fasta> Saizan: rnf doesn't work for structures built within ST (with STRefs).
07:19:27 <fax> Is this possible?
07:19:28 <vincenz> fasta: heh, that makes no sense, unless you use typeclasses
07:19:40 <fasta> vincenz: what makes no sense?
07:19:47 <vincenz> s/fasta/fax
07:20:00 <fax> I meant  f (x / 2)
07:20:06 <quicksilver> fax: sure
07:20:07 <fax> > 4/2
07:20:09 <lambdabot>  2.0
07:20:09 <liyang> fax: I'd have to write case x `div` 2 of { 0 -> ...; 1 -> ...; }
07:20:16 <fax> case :(
07:20:18 <doserj> f x | even x = ...
07:20:25 <quicksilver> f x | even x = f (x/2)
07:20:34 <quicksilver>     | odd x = f (3 * x + 1)
07:20:46 <oerjan> fasta: well i don't think it makes sense that rnf should depend on where you built things either, but that may be just me :)
07:20:48 <quicksilver> mind you this function as written doesn't terminate
07:20:53 <quicksilver> but I imagine that's not your point
07:21:13 <fax> quicksilver: Do you have a proof? :P
07:21:14 <vincenz> unless he adds another case
07:21:16 <vincenz> f x | one x = ..
07:21:23 <oerjan> or maybe you mean that it cannot look inside references?
07:21:50 <liyang> (ugh. I don't like | guards. Case analysis all the way...)
07:22:06 <quicksilver> fax: yes. There is no base case. Every value calls f again
07:22:17 <oerjan> but guards _are_ case analysis
07:22:18 <fax> I was joking ;[
07:22:30 <vincenz> fax: nice recovery... :P
07:22:36 <roconnor> @go 4 lb in kg
07:22:38 <lambdabot> 4 pounds = 1.81436948 kilograms
07:22:41 <liyang> oerjan: compiler can't warn you about missing cases, in those instances.
07:23:33 <aleator> vincenz: (afk for a while, sorry) So i basically want to give list [1,2,3,4,5,6,7,8,9,10] and prototypes [2,5,7] and have grouping [[1,2,3],[4,5,6],[7,8,9,10]]
07:23:42 <oerjan> although that odd x should have been otherwise...
07:23:48 <fax> @hoogle maximumBy
07:23:48 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
07:23:49 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
07:23:52 <oerjan> liyang: fair point
07:24:04 <vincenz> aleator: oh
07:24:15 <vincenz> aleator: ok, easy nuff
07:24:43 <liyang> (to the extent I prefer case over if/then/else... but that's mainly a formatting/layout issue.)
07:25:44 <hpaste>  fax pasted "f" at http://hpaste.org/2578
07:25:47 <oerjan> assuming both the list and prototypes are sorted that should be possible to do more efficiently
07:26:00 <fax> Do you know how to find x such that this function doesn't terminate?
07:26:15 <vincenz> > let on f g x y = g (f x) (f y) in map (\x -> fst . head . sortBy (snd `on` compare) . map (\y -> (x-y)^2) $ [2,5,7]) [1..9]
07:26:16 <lambdabot>   add an instance declaration for (Num (a, b))
07:26:17 <lambdabot>     In the expression: 9
07:26:32 <vincenz> let on f g x y = g (f x) (f y) in map (\x -> fst . head . sortBy (snd `on` compare) . map (\y -> (x, (x-y)^2)) $ [2,5,7]) [1..9]
07:26:37 <vincenz> > let on f g x y = g (f x) (f y) in map (\x -> fst . head . sortBy (snd `on` compare) . map (\y -> (x, (x-y)^2)) $ [2,5,7]) [1..9]
07:26:39 <oerjan> fax: funny guy
07:26:39 <lambdabot>  [1,2,3,4,5,6,7,8,9]
07:26:43 <vincenz> doh
07:26:46 <vincenz> sec
07:27:26 <oerjan> fax: actually yes: -1
07:27:34 <fax> ach
07:27:45 <fax> I need it to be positive
07:27:51 <quicksilver> all powers of two?
07:28:06 <vincenz> > let on f g x y = g (f x) (f y) in groupBy ((fst . snd) `on` (==)) . map (\x -> head . sortBy ((snd . snd) `on` compare) . map (\y -> (x, (y, (x-y)^2))) $ [2,5,7]) $ [1..9]
07:28:07 <lambdabot>  [[(1,(2,1)),(2,(2,0)),(3,(2,1))],[(4,(5,1)),(5,(5,0)),(6,(5,1))],[(7,(7,0)),...
07:28:19 <vincenz> > map fst $ let on f g x y = g (f x) (f y) in groupBy ((fst . snd) `on` (==)) . map (\x -> head . sortBy ((snd . snd) `on` compare) . map (\y -> (x, (y, (x-y)^2))) $ [2,5,7]) $ [1..9]
07:28:20 <lambdabot>  Couldn't match expected type `(a, b)'
07:28:30 <vincenz> > map (map fst) $ let on f g x y = g (f x) (f y) in groupBy ((fst . snd) `on` (==)) . map (\x -> head . sortBy ((snd . snd) `on` compare) . map (\y -> (x, (y, (x-y)^2))) $ [2,5,7]) $ [1..9]
07:28:31 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
07:28:54 <vincenz> enough golfing/spamming
07:29:02 <oerjan> > on
07:29:03 <lambdabot>   Not in scope: `on'
07:29:13 <vincenz> on should be in the prelude
07:29:18 <aleator> Ok.. I knew there was "one"-liner for it. Now just a minute for me to understand it.. :)
07:29:34 <vincenz> basically I map each element to the one closest to it, and keep enough context around to group later
07:29:47 <oerjan> @let ((==) `on` f) x y = f x == f y
07:29:51 <lambdabot> Defined.
07:29:59 <vincenz> @type on
07:30:01 <lambdabot> Not in scope: `on'
07:30:05 <vincenz> @type L.on
07:30:07 <lambdabot> Couldn't find qualified module.
07:30:19 <kolmodin> shapr: I just saw that you're in the program committee of CUFP. congrats :)
07:30:51 <oerjan> > on
07:30:53 <lambdabot>  Add a type signature
07:31:01 <aleator> vincenz: ok. Got it. Thanks. (where did you get the on and over?)
07:31:09 <vincenz> I defined em
07:31:18 <oerjan> > (on +)
07:31:20 <lambdabot>        add an instance declaration for
07:31:20 <lambdabot>       (Num ((t1 -> t1 -> t2) -> (t -> ...
07:31:38 <vincenz> > (on (+1)
07:31:39 <lambdabot>  Unbalanced parenthesis
07:31:39 <vincenz> > (on (+1))
07:31:40 <lambdabot>      Occurs check: cannot construct the infinite type: t1 = t1 -> t2
07:31:40 <lambdabot>     Prob...
07:31:52 <vincenz> oerjan: you reversed the args
07:32:02 <vincenz> @let (f `on` (==)) x y = f x == f y
07:32:02 <lambdabot> <local>:7:20:     Occurs check: cannot construct the infinite type: t = t -> ...
07:32:05 <vincenz> @unlet on
07:32:06 <lambdabot>  Parse error
07:32:07 <vincenz> @let (f `on` (==)) x y = f x == f y
07:32:08 <lambdabot> <local>:7:20:     Occurs check: cannot construct the infinite type: t = t -> ...
07:32:16 <oerjan> no, that's wrong!
07:32:20 <vincenz> no it's not
07:32:23 <vincenz> snd `on` compare
07:32:41 <ari> We need to settle on a name for that function
07:32:43 <doserj> vincenz: compare `on` snd sounds right
07:32:45 <ari> I've seen on, over, and pointwise
07:32:47 <vincenz> no it doesn't
07:32:49 <oerjan> but that sounds wrong!
07:32:50 <vincenz> oh
07:32:54 <vincenz> hmm
07:32:58 <mboes> hey, any YHC hackers around? I can't build YHC anymore. Depending on what i do it tells me can't find gmp (even though it's there) or can't determine endianness.
07:33:01 <vincenz> I guess it depends on how you see it
07:33:02 <vincenz> :P
07:33:18 <vincenz> oerjan, doserj: point taken
07:33:22 <ari> Me, I actually just define comparing (for compare) and matching (for (==)) because they're the only things I use that function for
07:33:24 <oerjan> ari: on is going into the libraries
07:33:36 <vincenz> ari: I still prefer `on`
07:33:40 <ari> oerjan: I see
07:33:46 <oerjan> ari: comparing is already in the libraries
07:33:49 <vincenz> you can always just define comparing = (compare `on` )
07:34:01 <ari> oerjan: Yeah, I'm aware of that
07:34:07 <quicksilver> it's useful for other things too
07:34:07 <doserj> comparing is already defined
07:34:13 <quicksilver> like choosing instances
07:34:22 <quicksilver> (mappend `on` Plus)
07:34:28 <quicksilver> to choose the additive monoid
07:34:32 <quicksilver> or whatever that's called
07:34:40 <ari> It's just that I can usually never remember it's in Data.Ord and it's easier to just define it on the spot :(
07:34:54 <doserj> :)
07:35:21 <vincenz> quicksilver: mappend `on` Plus ??
07:35:28 <vincenz> quicksilver: where is the data-constructor Plus defined?
07:35:42 <quicksilver> Data.Monoid?
07:36:00 <quicksilver> oh it's called 'Sum'
07:36:02 <quicksilver> sorry :)
07:36:16 <vincenz> @doc Data.Monoid
07:36:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
07:36:29 <quicksilver> > (Sum 3) `mappend` (Sum 5)
07:36:31 <lambdabot>  Sum {getSum = 8}
07:36:32 <vincenz> heh, didn't know about those
07:36:39 <vincenz> eenteresting
07:36:46 <quicksilver> > let (++) = mappend `on` Sum in 3 (++) 5
07:36:48 <lambdabot>        add an instance declaration for
07:36:48 <lambdabot>       (Num ((t -> t -> Sum t) -> t1 ->...
07:36:53 <quicksilver> bah
07:37:32 <vincenz> > let (++) = mappend `on` Sum in 3 ++ 5
07:37:33 <lambdabot>  Sum {getSum = 8}
07:38:21 <vincenz> you were applying 3 to the function (++) and 5
07:38:52 <quicksilver> doh
07:38:54 <quicksilver> thanks :)
07:39:11 <quicksilver> > let (++) = mappend `on` Prod in 3 ++ 5
07:39:12 <lambdabot>   Not in scope: data constructor `Prod'
07:39:17 <quicksilver> > let (++) = mappend `on` Product in 3 ++ 5
07:39:19 <lambdabot>  Product {getProduct = 15}
07:40:49 <oerjan> > (0$0 `on`)
07:40:50 <lambdabot>      The operator `on' [infixl 9] of a section
07:40:51 <lambdabot>         must have lower preced...
07:41:35 <earthy> > let (*) = mappend `on` Product in 3 * 5
07:41:37 <lambdabot>  Product {getProduct = 15}
07:42:04 <oerjan> @let infix 8 off; (f `off` g) x y = f (g x y)
07:42:04 <lambdabot>  Parse error
07:42:15 <earthy> > let (*) = mappend `on` Product in let (+) = mappend `on` Sum in 3 * 5 + 4 * 5
07:42:16 <lambdabot>      Occurs check: cannot construct the infinite type:
07:42:17 <lambdabot>       t = Sum (Product...
07:42:22 <earthy> ghe ;)
07:42:24 <oerjan> @let infix 8 (off); (f `off` g) x y = f (g x y)
07:42:25 <lambdabot>  Parse error
07:43:49 <oerjan> @pl \x y -> f (g x y)
07:43:50 <lambdabot> (f .) . g
07:45:20 <doserj> > let (*) = mappend `on` Product in let (+) = mappend `on` Sum in getProduct (3 * 5) + getProduct (4 * 5)
07:45:22 <lambdabot>  Sum {getSum = 35}
08:02:53 <vincenz> @join #oasis
08:08:10 <b_jonas> was that to your client or someone else?
08:08:25 <oerjan> probably lambdabot
08:08:31 <vincenz> hmm?
08:08:47 <vincenz> to lambdabot
08:09:02 <b_jonas> oh yeah
08:09:06 <b_jonas> I should've known
08:09:15 <b_jonas> you seem to like lambdabot the only bot here
08:09:35 <vincenz> well it'd be rather annoying if 5 bots responded to every command :)
08:09:40 <vincenz> especially given the heavy uses of LeCamarade
08:09:41 <vincenz> erm
08:09:41 <vincenz> lambdabot:
08:09:48 * vincenz apologizes to LeCamarade for all the ab-use
08:10:37 <LeCamarade> :o)
08:11:28 <LeCamarade> BitchX doesn't fill in the names with tab, while they still collide. Can be annoying, can be like a static type-system. :o)
08:12:19 <vincenz> LeCamarade: sure, like an explicit statici type-system without HM
08:12:52 <LeCamarade> Yeah. bash-style is like Hindley-Milner. Fills as far as it can go, and no farther.
08:13:23 <vincenz> sounds more like soft-typing
08:13:51 <vincenz> HM wouold be the client guessing whom you want to talk to based on your previous conversation and the topic you're talking about
08:14:31 <LeCamarade> :o)
08:23:02 <b_jonas> I should probably have just seen who joined #oasis at that time
08:23:26 <b_jonas> as for responding, I hate bots that have too broad regex to respond to
08:23:34 <b_jonas> and I try to avoid that with my bot very hard
08:24:04 <vincenz> problem is that many have come here with lambdabot-children
08:24:25 <b_jonas> (if you still find it matches too much, do tell me)
08:24:31 <b_jonas> but I understand that you don't like bot flood
08:24:36 <encryptio> :t filterM
08:24:38 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
08:24:42 <b_jonas> even if it's because I type commands it's supposed to match
08:25:20 <b_jonas> (obviously, a separate channel for a bot is different, I think it's ok that cbstream matches everything on #cbstream)
08:31:00 <quicksilver> \
08:31:52 <EvilTerran> x
08:31:56 <EvilTerran> ->
08:32:04 <vincenz> x
08:32:04 <alexeevg> x
08:32:10 <vincenz> type error
08:32:22 <EvilTerran> cannot construct infinite type
08:32:24 <alexeevg> U-combinator
08:32:48 <vincenz> I guess this is what GHC feels like on a 286 accross a modemline
08:32:56 <ski> newtype U a = LambdaU {applyU :: U a -> a}
08:33:00 <Sizur> multiverse colapse
08:33:27 <cjeris> vincenz: no, on a 286 GHC feels warm, like a little fire you can warm your hands at.  wait, that smells funny.  wait, that was my CPU.
08:33:45 <vincenz> "This is your CPU on monads"
08:34:12 <oerjan> @remember cjeris vincenz: no, on a 286 GHC feels warm, like a little fire you can warm your hands at.  wait, that smells funny.  wait, that was my CPU.
08:34:12 <lambdabot> Done.
08:34:48 <ndm> cjeris: 286's were still passively cooled, you couldn't make them heat up whatever happened
08:35:40 <vincenz> ndm: how do you know? Have you tried running GHC on a 286?
08:36:10 <ndm> vincenz: no, but i did used to work with a 286 for years, and had to take it apart to replace the bios battery
08:36:12 <Sizur> with 1meg ram
08:36:22 <cjeris> ndm: meaning the maximum power dissipation was small enough that it just never got warm?
08:36:25 <vincenz> ndm: hmm, my humor was too faint
08:36:32 <ndm> cjeris: yes, pretty much
08:36:49 <ndm> my dad's office was running a 286 up until 2004
08:36:55 <Sizur> wow
08:37:05 <Sizur> scary
08:37:11 <ndm> they had other machines, but that was the only one which did the timekeeping
08:37:18 * sjanssen doesn't undestand why people don't like "No instance for (Num [Char])"
08:37:36 <Sizur> you could still use 286 as a router
08:37:36 * ndm can't understand why sjanssen does
08:37:41 <quicksilver> depends a bit what you mean by warm
08:37:53 <quicksilver> 286s certainly got warm as in 'appreciably above room temperature'
08:38:04 <vincenz> @hoogle appreciably
08:38:04 <lambdabot> No matches found
08:38:10 <cjeris> quicksilver: 'can fry egg on package'
08:38:11 * alexeevg is on the ndm's side
08:38:20 <quicksilver> cjeris: definitely not :)
08:38:29 <ndm> Sizur: the battery had an operational life of 15 years, they weren't made in the last 15 years and you can't replace them - its not a good situation
08:38:44 <quicksilver> the pentium was the first egg-fryer in that chip class
08:38:45 <quicksilver> IIRC
08:38:56 <cjeris> quicksilver: i think the first cpu i heard described that way was the initial Alpha 21064
08:39:07 <quicksilver> I'm pretty sure the 68040 meanwhile was hot enough to give you a nasty burn
08:39:12 <quicksilver> but not hot enough to need a heat sink
08:40:00 <Sizur> i want GHC on C64
08:40:05 <cjeris> that's how apple kept their customers!  they branded them all on the butt with a running Quadra motherboard!  so they were all afflicted with the Mark of the Fruit
08:40:51 <Sizur> Mark of the Fruit heh
08:40:56 <EvilTerran> GHC on Atari STE!
08:41:03 <Sizur> C64 wins!
08:41:10 <EvilTerran> STE!
08:41:40 * EvilTerran never had a C64, so I can't really judge. but I did like the Atari.
08:41:51 <sjanssen> ndm: what's better?
08:42:03 <Sizur> heh, think we could even hack ghc to run on C64 sound chip
08:42:22 <olsner> the SID is probably not turing complete unfortunately
08:42:23 <ndm> sjanssen: an error message that doesn't suggest something which is wrong most of the time
08:42:47 <ndm> sjanssen: i more object to the "perhaps you should add one" hint
08:42:48 <sjanssen> ndm: I'll agree that "Possible fix: add an instance declaration for (Num [Char])" is less helpful
08:43:09 <ndm> sjanssen: entirely inaccurate, in most cases
08:43:31 <EvilTerran> "Possible fix: add an application of (read)"
08:43:48 <sjanssen> EvilTerran: I don't think that will scale
08:44:13 <EvilTerran> hm...
08:44:58 <sjanssen> ndm: what else could it say?  "Make sure you didn't write something stupid"?
08:45:27 <EvilTerran> once it's got the expected type and the inferred type, it could look through the functions in scope, hoogle-style, for a function ... -> inferred -> ... -> expected
08:45:36 <EvilTerran> and suggest those
08:45:52 <ndm> sjanssen: the code you have written requires an instance for Num [Char], but one does not exist
08:46:03 <EvilTerran> @hoogle Num a => [Char] -> a
08:46:07 <lambdabot> No matches, try a more general search
08:46:13 <ndm> sjanssen: state the facts, state why what you wrote was wrong, do not suggest an answer unless you actually can think of one
08:46:23 <sjanssen> ndm: that's what "No instance for (Num [Char])" means ;)
08:46:32 <ndm> @hoogle Num a => String -> a
08:46:33 <lambdabot> Prelude.error :: String -> a
08:46:33 <lambdabot> Debug.Trace.trace :: String -> a -> a
08:46:33 <lambdabot> Prelude.fail :: Monad m => String -> m a
08:46:34 <doserj> I never understood why one would write "instance for Num [Char]".
08:46:41 <dcoutts> hmm, just got an email from a commercial prog tools company in the UK asking me about stream fusion and C++
08:47:01 <EvilTerran> i agree, i wouldn't miss the "possible fix" thing in the error message
08:47:10 <quicksilver> are they offering to pay you $obscene_amounts?
08:47:19 <ndm> sjanssen: true, i read that as you got something wrong, but whatever it was, you can guarantee it ISN'T going to be fixed by following the suggestions
08:47:49 <ndm> sjanssen: but beginners sometimes read and interpret the error message literally, without the knowledge that its horribly wrong
08:48:01 <ndm> dcoutts, neat - sell them a copy of your paper :)
08:48:07 <doserj> according to haskell syntax, it should be "no instance Num [Char]" or similar
08:48:27 <doserj> but it is obvioulsy better to just say there is no [Char] instance for class Num
08:48:29 <dcoutts> ndm: they've already read that, they want to meet up and talk about extending to a non-functional context.
08:48:40 <ndm> doserj: no, it should be no instance Num [] x, where x can be a Char - H98 rules apply
08:48:44 <sebell> sjanssen: Either way, given "No instance of..." the possible fix to add an instance is redundant
08:48:52 <dcoutts> quicksilver: not at the moment :-)
08:48:57 <sjanssen> doserj: that gets ugly with MPTCs
08:49:09 <ndm> dcoutts, doesn't seem immediately obvious how you would, since there are rarely intermediate data structures in C++ - people just overwrite them
08:49:14 <quicksilver> dcoutts: shame :)
08:49:29 <doserj> "T1 T2" is not an instance of class C
08:49:44 <doserj> sounds fine to me
08:50:24 <sjanssen> doserj: but then you've got ambiguity with things like "IO Int"
08:50:54 <sjanssen> it could either be a single parameter class or a MPTC
08:50:54 <dcoutts> ndm: right, though apparently they're working on immutable parallel arrays, so it's not obvious if it is or not yet
08:51:08 <dcoutts> ndm: they're trying to program SPMD
08:51:16 <ndm> dcoutts, ah, now that i can believe could be done
08:51:42 <dcoutts> sounds like they're looking for a semantics that allows crazy optimisations
08:51:55 <doserj> sjannsen: you should never write "C T" in error messages, when C is a class.
08:52:11 <sjanssen> doserj: why?
08:52:26 <doserj> "T" is not an instance of class C is much more easier to understand
08:52:33 <sjanssen> doserj: why?
08:52:51 <sjanssen> "C T" is real Haskell syntax
08:53:01 <dons> ?users
08:53:01 <lambdabot> Maximum users seen in #haskell: 402, currently: 391 (97.3%), active: 20 (5.1%)
08:53:08 <doserj> instance for C T is not real Haskell syntax
08:53:46 * Sizur contemplates the bliss of porting GHC to SID
08:54:05 <doserj> "instance for" sounds like whatever comes afterwards names a classnd
08:54:13 <doserj> *class
08:54:18 <EvilTerran> without "instance" immediately to the left of "C T", i do find myself thinking that C is a constructor
08:54:20 <sjanssen> doserj: of course our entire error message can't be Haskell source :)
08:54:23 <doserj> but C T is not a class
08:54:48 <doserj> but it could be grammatically correct and sensible english
08:55:16 <sjanssen> IMO, that just takes up more screen space without giving any extra information
08:55:59 <doserj> it explicitely names what is the instance and what is the class
08:56:10 <doserj> i find this helpful
09:30:59 <hpaste>  llewyenoh annotated "Change battery information" with "Compilation error on printf" at http://hpaste.org/2552#a6
09:31:47 <kpreid> llewyenoh: always include the error.
09:32:17 <monochrom> I like bugs
09:32:51 <hpaste>  llewyenoh annotated "Change battery information" with "Error output for above annotation" at http://hpaste.org/2552#a7
09:32:54 <mauke> why is there a .
09:33:57 <llewyenoh> mauke: so take out that .?
09:34:36 <Lemmih> llewyenoh: (rcap / fcap)
09:34:58 <Lemmih> Oh wait.
09:35:16 <Lemmih> llewyenoh: (100 * rcap / fcap), no dot.
09:35:17 <mauke> llewyenoh: why is it there?
09:35:31 <kpreid> I think that . should be a $
09:35:45 <llewyenoh> mauke: yeah, now it's complaining about a type signature
09:36:09 <monochrom> printf "%.1f" (100 * rcap / fcap)
09:36:19 <monochrom> (why hate parentheses)
09:36:20 <llewyenoh> right, or $
09:36:35 <monochrom> $ will not work.
09:36:40 <llewyenoh> why not?
09:36:54 <monochrom> Next year you will know.
09:37:07 <llewyenoh> ok, i'm still getting type signature error though
09:37:21 <llewyenoh> or an ambiguous type variable
09:37:36 <Japsu> isn't printf some TH hack?
09:37:49 <kpreid> it's a typeclass hack, but no (visible) TH
09:37:50 <monochrom> typeclass hack.
09:37:53 <Japsu> k
09:38:25 <idnar> > printf "%.1f" $ 100 * 5 / 6
09:38:27 <lambdabot>  Add a type signature
09:38:43 <quicksilver> > printf "%.1f" $ 100 * 5 / 6 :: String
09:38:44 <lambdabot>  "83.3"
09:38:56 <llewyenoh> oh, that's what i'm missing
09:39:04 <llewyenoh> can someone explain why that's necessary?
09:39:08 <quicksilver> yes
09:39:15 <fax> > printf "%.1f" $ 100 * 5 / 6 :: Int -> String
09:39:16 <lambdabot>  <Int -> [Char]>
09:39:18 <quicksilver> that's the magic that allows it to take multiple parameters
09:39:30 <quicksilver> a printf expression is 'either' waiting for one more parameter
09:39:39 <quicksilver> or it's not (i.e. it's a string)
09:39:40 <vincenz> or type-complete :)
09:39:52 <idnar> > printf "%.1f" (100 * 5 / 6) 10 :: String
09:39:54 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
09:39:56 <idnar> heh
09:40:01 <fax> > (printf "%.1f" :: Float -> String) 100 * 5 / 6
09:40:02 <lambdabot>   add an instance declaration for (Fractional String)
09:40:02 <lambdabot>     In the expression:
09:40:02 <lambdabot> ...
09:40:06 <quicksilver> in many contexts in a real problem this is hidden from you by the compiler
09:40:14 <quicksilver> as it can infer stuff from other uses of the context
09:40:22 <quicksilver> that's if you get it right
09:40:30 <quicksilver> if you get it wrong, the error message can be pretty odd
09:40:38 <quicksilver> that's always the risk with type class hackery
09:40:48 <quicksilver> > printf "foo" + 10
09:40:49 <lambdabot>  Add a type signature
09:41:07 <quicksilver> @more
09:41:12 <quicksilver> hmph
09:41:19 <llewyenoh> oh, ok
09:41:21 <quicksilver> well the full error for that is a bit nasty, anyhow
09:42:17 <monochrom> once type class is involved, automatic type inference fails
09:42:19 <quicksilver> I think such type class hacks should be used with caution, personally
09:42:22 <shapr> Good morning #haskell!
09:42:24 <quicksilver> monochrom: may fail
09:42:28 <monochrom> > show (read "True")
09:42:30 <lambdabot>  Exception: Prelude.read: no parse
09:42:44 <quicksilver> monochrom: there may be other information available to make it pass
09:42:49 <monochrom> > show (read "1")
09:42:50 <lambdabot>  "1"
09:42:53 <llewyenoh> quicksilver: how do i have to parenthesize the (...) :: String part with the let?
09:43:21 <quicksilver> llewyenoh: normally you don't need it, because what you actually *do* with the value gives the compiler the right type
09:43:26 <monochrom> > show (read "1.1")
09:43:27 <lambdabot>  Exception: Prelude.read: no parse
09:43:35 <quicksilver> llewyenoh: but if you want to give a type, it's cleanest to write:
09:43:38 <quicksilver> let foo :: String
09:43:44 <quicksilver>     foo = printf "bar %d" 5
09:43:59 <quicksilver> At least, IMO, that's the most pleasant syntax
09:44:12 <llewyenoh> oh, ok, thanks
09:44:27 <llewyenoh> but i have to have it in my case, right?
09:44:39 <mauke> I don't think so
09:44:56 <llewyenoh> so how would i get around have to do that?
09:45:01 <llewyenoh> *having
09:45:01 <quicksilver> llewyenoh: shouldn't do, no
09:45:04 <monochrom> You could use parentheses. printf "%.1f" (100 * 5 / 6)
09:45:14 <quicksilver> llewyenoh: the fact that you use percent as an argument to ++
09:45:22 <quicksilver> llewyenoh: tells it that percent is a String
09:45:30 <monochrom> It baffles me how much you people go out of your way to save a parenthesis.
09:45:39 <llewyenoh> but why is the compiler complaining?
09:45:42 <fax> > printf "%.1f" (100 * 5 / 6)
09:45:44 <lambdabot>  Add a type signature
09:45:45 <llewyenoh> and monochrom, that has the same error
09:45:46 <wolverian> whoot, someone (daniel gorin) released a sane api around ghc's api to compile haskell. I wonder how long it will stay in sync with ghc's api...
09:45:53 <quicksilver> llewyenoh: you want $ not .
09:46:05 <quicksilver> llewyenoh: or, you want ( 100 * rcap / fcap )
09:46:11 <quicksilver> one of the two
09:46:21 <llewyenoh> quicksilver: right, i fixed that part already
09:46:31 <llewyenoh> quicksilver: it's the :: String part that i was worried about
09:46:32 <monochrom> Can you infer that rcap is a Double?
09:46:32 <quicksilver> oh, sorry
09:46:37 <quicksilver> which part are we doing now then?
09:46:49 <mauke> an unspecified "error"
09:46:53 <llewyenoh> in my case, is it necessary to append the :: String?
09:46:58 <llewyenoh> or is there a way around that?
09:47:02 <quicksilver> shouldn't be
09:47:05 <quicksilver> show us the new error
09:47:12 <llewyenoh> sure
09:49:06 <hpaste>  llewyenoh annotated "Change battery information" with "Type signature for printf" at http://hpaste.org/2552#a8
09:49:53 <quicksilver> llewyenoh: ok, it's not the printf that's worrying it really
09:49:56 <quicksilver> llewyenoh: it's the "read"
09:49:58 <Lemmih> llewyenoh: (100 * rcap / fcap :: Double)
09:50:04 <monochrom> Can you infer the type of rate?
09:50:08 <quicksilver> llewyenoh: there's something quite odd about the way you have a map of strings
09:50:12 <quicksilver> and use read to pull them out
09:50:19 <quicksilver> (instead of having a map of the correct type)
09:50:54 <llewyenoh> Lemmih: that's what was causing it, thanks
09:50:59 <llewyenoh> quicksilver: can you clarify please?
09:51:16 <monochrom> yeah, could have put the read inside getTable. Moreover the type signature for getTable will take the correct read.
09:52:18 <Lemmih> monochrom: Wouldn't that mess up the "charging state"?
09:52:39 <sioraiocht> > ap (return (\x -> x + 1)) (return 5)
09:52:40 <lambdabot>   add an instance declaration for (Show (m a))
09:52:53 <sioraiocht> okay, in ghci, that prints 6
09:52:54 <sioraiocht> why?
09:52:55 <monochrom> You know how to correct that properly. Use a sum type.
09:53:49 <sjanssen> what is wrong with using read inside grab?
09:54:00 <monochrom> GADT is also a solution.
09:54:10 <mauke> sioraiocht: probably because it defaults m to IO and a to Integer
09:54:35 <monochrom> Generally, any proper method of implementing a parse tree is a solution.
09:54:42 <Cale> sioraiocht: which modules do you have loaded?
09:55:11 <sioraiocht> cale: just Control.Monad
09:55:42 <Cale> oh, it's treating it as an IO action
09:55:47 <mauke> ghci first tries to run YOURINPUT >>= print
09:55:48 <Cale> and printing the result
09:55:56 <sioraiocht> oh
09:56:11 <sioraiocht> okay, thanks =)
09:56:12 <Cale> Damn, I even have that behaviour switched off, and it's still doing it in that case.
09:56:25 <sioraiocht> orly? see, that's weird, imo
09:56:58 <Cale> Yeah, I have -fno-print-bind-result turned on, and it seems to ignore it.
09:57:28 <Cale> Prelude Control.Monad> return 6 >>= (\x -> return x)
09:57:28 <sioraiocht> is ghci written in haskell?
09:57:29 <Cale> 6
09:57:29 <Cale> Prelude Control.Monad> print "Hello" >>= (\x -> return x)
09:57:29 <Cale> "Hello"
09:57:33 <Cale> yes
09:58:09 <sioraiocht> does it compile each line in ghc and then execute and return the result, then?
09:58:13 <monochrom> I wonder what type it infers
09:58:20 <Saizan> Cale: isn't that flag for binds like  a <- foo ?
09:58:57 <Cale> Saizan: It applies more generally. See, in that example above, the one which printed a string doesn't have the trivial result printed as well.
09:59:24 <Cale> I liked GHCi 6.4's behaviour, which was consistent.
09:59:31 <Saizan> ah, right
09:59:33 <mauke> Cale: IO () never prints the result
09:59:51 <monochrom> REPL is misleading.
10:00:09 <Cale> oh, you're right
10:00:20 <Cale> it still does print things like the result of mapM
10:00:22 <Cale> that's annoying
10:00:41 <idnar> :t ap (return (\x -> x + 1)) (return 5)
10:00:46 <monochrom> Some people who use REPLs for debugging asked for it.
10:00:46 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a
10:00:56 <mauke> _ <- return 42
10:01:03 <Cale> If I wanted it to print the result of executing the IO action, I'd have typed >>= print at the end of it.
10:01:07 <monochrom> As usual, the vocal minority is heard and heeded.
10:01:26 <mauke> put _<- at the front :-)
10:01:27 <idnar> I guess it's sometimes-convenient, but confusing
10:01:31 <Cale> Where should I complain to have it put back?
10:01:49 <Cale> (or at least have -fno-print-bind-result work correctly)
10:02:23 <ndm> Cale: i think they've fixed it since
10:02:24 <monochrom> glasgow-haskell-users mailing list.
10:02:39 <monochrom> You have to scream like newbies do.
10:03:18 <monochrom> Evidently, this bug was added because some other newbies screamed some years ago. You may even be able to find it in the mailing list archive.
10:03:19 <Cale> I find it amazing the sorts of things which people request.
10:03:39 <Cale> Especially... who was it... Brian somebody, I think.
10:04:01 <monochrom> This is why every time someone requests something, I am always a nay sayer. If I have time.
10:04:34 <sioraiocht> @remember monochrom I am always a nay sayer. If I have time.
10:04:34 <lambdabot> Done.
10:04:43 <monochrom> hehe
10:04:51 <Cale> Yeah, I think it was Brian Hulley that was suggesting lots of fairly ridiculous syntax changes.
10:05:07 <Cale> Also, these people who seem to think (.) shouldn't mean composition?!
10:05:12 <sioraiocht> WHAT?
10:05:23 <sioraiocht> stab them
10:05:24 <sioraiocht> in the FACE
10:05:26 <kReepicheep> it should be o
10:05:27 <monochrom> I did not have time to ridicule that "(<- blah)" thread, unfortunately.
10:06:12 <Cale> Yeah, that one's kinda strange too.
10:06:15 <sioraiocht> kReepicheep: an operator shouldn't be a letter, imo.
10:06:25 <Cale> And then you have the group which is totally opposed to even the tiniest amount of syntax sugar.
10:06:30 <monochrom> Generally, it is a failure of teaching science. I mean science, the spirit, not science, the knowledge of physics etc.
10:06:45 <Cale> Like Henning Thielemann
10:06:46 <dino-> Well, the rules in Haskell are that an infix starting with a letter must use ` `, so that would have to be changed unless you'd like to type `o` everywhere.
10:06:47 <sioraiocht> Cale: to which I would say, "then don't use it!"
10:07:27 <sioraiocht> Cale: he would cry if he saw Lua, then
10:07:43 <monochrom> The scientific spirit is that if you request a feature, you are the one to do your homework and justify its benefits and its non-conflicts with other things. If you don't, other people ignore you, they are not even obliged to point out how wrong you are.
10:08:07 <monochrom> But our society have it backwards.
10:10:14 <Cale> Henning doesn't even seem to think that list syntax is a good idea.
10:10:16 <sjanssen> I really don't understand syntactic sugar hate
10:10:17 <kReepicheep> monochrom: I meant the function composition symbol which probably won't show up (or I was too lazy to type it)... I just put o... of course I'm not serious
10:10:27 <Cale> like [1,2,3]
10:10:43 <sioraiocht> kReepicheep: see, what's kinda sad, is that given other suggestions, yours didn't seem SO ridiculous =p
10:10:43 <sjanssen> sugary goodness is at the very core of Haskell
10:10:50 <Cale> and he's against  (if ... then ... else ...) expressions, of course
10:11:03 <sioraiocht> Cale: I'm sort of against those, too
10:11:20 <dino-> I use (>>=) when it's convenient and makes syntactical sense, but I would really dislike seeing do notation go away. ugh
10:11:24 <Cale> He also thinks that modules should only declare at most one type, and it should always be called T.
10:11:39 <monochrom> SML allows you to declare an alphanumeric identifier infix. You just have to say "infixr 5 o" or something.
10:11:43 <kReepicheep> sioraiocht: I'd prefer typing . than some alt combo... of course I use perl too so that kinda voids my opinion a bit
10:12:16 <Cale> kReepicheep: I agree with that, and I don't even use perl :)
10:12:18 <sioraiocht> kReepicheep: I am a firm believer in keeping programming language syntax in the realm of what appears on my keyboard =p  and I use perl, too
10:12:26 <Cale> (.) is probably my most-used infix operator.
10:12:36 <monochrom> In fact HOL, built upon SML, has things like "infixr 5 THEN" so you can write "MP_TAC THEN SIMP_TAC".
10:12:44 <dino-> Or ($) maybe
10:12:56 <Cale> Which means that changing it to something that's not explicitly a key on my keyboard would be extremely painful.
10:13:02 <dino-> But both of those, I can see that, extremely often used.
10:13:04 <sioraiocht> I think $ { ; } are the ugliest thinks about haskell
10:13:21 <sioraiocht> *things
10:13:22 <Cale> I would really like to see the associativity of ($) changed. It would force people not to overuse it as well.
10:13:23 <dino-> sioraiocht: See ($) makes sense to me in the same way that | makes sense in shell scripting.
10:14:12 <sioraiocht> dino-: $ just brings me back to the world of dollar-signed variables =(
10:14:24 <Cale> $(...) syntax is ugly
10:14:31 <sioraiocht> hideous
10:14:41 <Cale> In general, the TH syntax is pretty awkward
10:15:17 <Cale> {;} aren't bad, since they're optional.
10:15:27 <sioraiocht> I know, and so is ($)
10:15:43 <Cale> Which $ ?
10:15:51 <monochrom> application $
10:15:54 <sioraiocht> right
10:16:07 <Cale> The application $ doesn't have anything to do with $'d variables though :)
10:16:26 <Cale> The TH $ is rather suggestive of variable interpolation in strings.
10:16:29 <monochrom> map $f $xs
10:16:40 * sioraiocht weeps silently in a corner.
10:17:15 * monochrom snickers at the Perl-likeliness of map $f $xs
10:17:20 <Cale> It would be really nice to swap the associativity of ($) so that people couldn't put them in long chains where they ought to be using (.) instead.
10:17:22 <dino-> Don't I wish you could lose the argument , in Perl.
10:17:32 <dino-> comma list separator
10:17:41 <Cale> Also, it would let you avoid even more parens :)
10:17:47 <osfameron> I think people should use parentheses instead of $ ...
10:18:03 <monochrom> I think newbies should not have opinions.
10:18:07 <osfameron> :-)
10:18:11 <sioraiocht> LOL
10:18:30 <vincenz> I think opinions are like asses
10:19:38 <dino-> No matter how dense the thicket of ($) or whatever, this is still the most spare, clearest language I've ever tried.
10:19:59 <monochrom> I am just as guilty on $ because I recently wrote withSubCont q $ \k -> withSubCont p $ \r -> pushPrompt p $ pushSubCont r $ pushPrompt q $ pushSubCont k $ pushSubCont r $ return undefine
10:20:25 <dino-> monochrom: It's just a reverse piping operation, nothing scary about that.
10:20:50 <monochrom> I'm trying to get Cale to stab me.
10:20:53 <Cale> heh
10:20:56 <fasta> What does this mean exactly? _exception = thread blocked indefinitely
10:21:24 <sjanssen> fasta: it generally means that a thread is blocked on an MVar that can't be resolved
10:21:46 <Cale> monochrom: the lambdas make that really funny
10:22:18 <fasta> sjanssen: I don't use MVars in my code. This is in a piece of simple recursion that should stop, but in fact goes in an infinite loop, but shows this with the debugger.
10:22:23 <osfameron> good god, you don't need parens around lambdas?
10:22:30 <Cale> osfameron: no
10:22:53 <ski> it could possibly be nice, if the '$' wasn't needed, as well
10:22:58 <sjanssen> fasta: are you using any threading stuff?
10:23:00 <monochrom> without parens, lambda's scope goes all the way to the right
10:23:15 <Cale> yeah, why *is* the $ needed?
10:23:27 <monochrom> I should be using parens.
10:23:33 <fasta> sjanssen: no
10:23:54 <liyang> Is portal.acm.org dead?
10:23:59 <sjanssen> fasta: huh, weird.  Maybe "thread blocked indefinitely" means "Exception: <<loop>>"?
10:24:16 <fasta> sjanssen: I don't get "Exception: <<loop>>" when I execute it without the debugger
10:24:25 <monochrom> Afterall, any GHC-compiled program runs in a thread, trivially...
10:24:28 <kencausey> On Debian Unstable I've installed ghc6 but can't get runghc to work.  First I find it's not in the default path so I have to expressly use /usr/lib/ghc-6.6.1/bin/runghc but even then it immediately exits with "cannot find ghc"  Have I missed a step?
10:24:38 <monochrom> The debugger may add yet another thread.
10:24:39 <sjanssen> I think "withSubCont q $ \k ..." is perfectly fine
10:24:40 <fasta> sjanssen: I do get that when I use the debugger in the state as described earlier and then do :step and then C-c C-c
10:24:58 <liyang> kencausey: try runhaskell instead
10:25:01 <sjanssen> I use it all the time with the with/alloca style functions
10:25:06 <kencausey> liyang: Same result there also
10:25:11 <Cale> Yeah, the $'s which are before the lambdas there are just fine
10:25:19 <liyang> oh? Hrm.
10:25:22 <Cale> They're not chaining.
10:26:09 <Cale> q $ \k -> withSubCont p $ \r -> pushPrompt p . pushSubCont r . pushPrompt q . pushSubCont k . pushSubCont r $ return undefined
10:27:04 <ski_> argument expressions in applications, is 'aexp', while a lambda expression is 'exp^10'
10:27:05 <fasta> I find . a bit backwards. People read from left to right modulo Arabic countries
10:27:06 <Cale> kencausey: that's really odd.
10:27:17 <liyang> kencausey: I'm on GHC 6.6-3 and it works here. But I can't say anything about the current unstable. :-/
10:27:34 <Cale> fasta: it's not any more backwards than function application
10:27:41 <kencausey> hmm, this is 6.6.1
10:27:59 <kencausey> I'll note that there is no ghc in the path, but there is ghc6
10:28:00 * glguy recommends factor
10:28:00 <Cale> fasta: If we wrote x f rather than f x, we'd probably want it to be the other way.
10:28:04 <glguy> 1 2 +
10:28:38 <Cale> kencausey: yeah, that's a problem, it would be good to make a symlink
10:28:53 <ski_> fasta : showsPrec _ (Lam ident expr) = showParen True $ showChar '\\' . showIdent ident . showString " -> " . showsPrec 0 expr
10:29:06 <kencausey> Seems like that package installation should have taken care of that.
10:29:07 <ski_> fasta : sometimes one can read '.' straight left-to-right
10:29:38 <liyang> kencausey: er... format and reinstall? <grin>
10:30:13 <Cale> kencausey: yeah
10:30:14 <doserj> kencausey, the link from ghc to ghc6 is handled by the alternatives system on my debian
10:30:20 <liyang> (Unless there's a problem with the packaging, which I wouldn't suspect in the first instance, I would guess something went wrong during the install.)
10:31:05 <kencausey> doserj: hmm, dead symlink there, let me kill it and reinstall the package
10:31:29 <Cale> There should be symlinks from /etc/alternatives/{ghc,ghci,ghc-pkg,ghcprof} to /usr/bin
10:32:08 <doserj> /usr/sbin/update-alternatives --display ghc ?
10:32:38 <fax> :t call/cc
10:32:40 <lambdabot> Not in scope: `call'
10:32:40 <lambdabot>  
10:32:40 <lambdabot> <interactive>:1:5: Not in scope: `cc'
10:32:49 <Cale> :t callCC
10:32:51 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
10:33:09 <fax> hm ok, I don't understand why it is that type
10:33:33 <fax> maybe
10:33:41 <Cale> Well, it takes a function from the current continuation to an action, and it calls it with that current continuation
10:34:12 <kencausey> Cale: Is there also one for runghc?
10:34:14 <SyntaxNinja> @seen shapr
10:34:14 <lambdabot> shapr is in #scannedinavian, #haskell-overflow, #haskell-blah and #haskell. I last heard shapr speak 51m 52s ago.
10:34:36 <Cale> kencausey: yep
10:34:42 <kencausey> thanks
10:34:49 <Cale> kencausey: and a bunch of others too
10:35:06 <ski> it returns something of type 'm a' .. thus it captures a continuation waiting to return to that type, the argument of 'callCC' should be a function also returning 'm a' (so that if it returns normally, the whole call returns normally), the argument of the functional argument is the contunation, packaged up as a function taking 'a' (what to return) and giving 'm b', i.e. anything at all in the monad, so that you can use it in 
10:35:14 <ski> note that
10:35:38 <ski> callCC :: MonadCont m => ((forall b. a -> m b) -> m a) -> m a
10:35:39 <Cale> "so that you can use it in" -- cut off message?
10:35:42 <ski> would be more general
10:35:54 <ski> "... so that you can use it in any context"
10:36:28 <fax> ohh
10:36:30 <fax> ok yeah
10:36:33 <ski> an alternative formulation is to do something like
10:36:56 <Cale> Note that the continuation is obviously a function from the type a, because callCC produces an action of type m a.
10:37:02 <ski> callCC :: MonadCont m cont => (cont a -> m a) -> m a
10:37:18 <ski> jump :: MonadCont m cont => cont a -> a -> m b
10:37:31 <kencausey> Cale: yep, trying to get dpkg to do the job right for me
10:37:33 <ski> (SML/NJ uses this variant)
10:38:05 <ski> (this variant also get the above generality, because the instantiation of 'b' is delayed until calls to 'jump')
10:38:23 <Cale> ski: wouldn't the cont constructor also have to take a parameter for b?
10:38:24 <fax> And you could actually implement a version of call/cc which is type ((a -> b) -> a) -> a ?
10:38:42 <Cale> er, hmm
10:38:47 <ski> Cale : no
10:39:12 <ski> Cale : 'jump' just dicards the current continuation passed to the application of it, hence polymorphic in 'b'
10:39:19 <ski> s/dicards/discards/
10:39:21 <Cale> ah, the jumped-to continuation is never expected to finish
10:40:00 <ski> this latter formulation separates the duplication (and reification) of continuation from the discarding of continuation
10:40:19 <fasta> Are partial repositories in some way inferior repositories?
10:40:24 <fasta> darcs: failed to read patch in get_extra:
10:40:40 <fasta> "Perhaps this is a 'partial' repository?"
10:40:45 <ski> (one can also imagine just reification without copying, and also invoking without discarding)
10:40:45 <vincenz> Anyone know what the main airport of NY is?
10:41:26 <Cale> vincenz: John F. Kennedy, LaGuardia and Newark International
10:41:26 <ski> phi :: MonadCont m cont => (cont a -> m b) -> cont b -> m a
10:41:36 <vincenz> Cale: thx
10:42:17 <ski> contElim :: MonadCont m cont => (cont a -> m Void) -> m a
10:42:32 <ski> invoke :: MonadCont m cont => cont a -> a -> m Void
10:42:37 <ski> or something like that
10:43:01 <Cale> Well, the first two are actually in the city, Newark International is obviously in Newark, but apparently lots of people use it to get to New York.
10:43:22 * ski used such a 'Void' type for a concurrency monad
10:48:31 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2580
10:48:50 <fasta> That's the complete error message I get. Anyone with darcs Fu?
10:49:57 <bos> fasta: did you "darcs get --partial" that repository initially?
10:52:57 <fasta> bos: yes
10:53:27 <bos> then darcs may not have some of the patches it needs to construct the context for applying a patch.
10:53:57 <fasta> bos: doesn that mean that partial isn't usuable to track software?
10:54:12 <fasta> bos: does*
10:54:50 <bos> i find partial to be fairly useless, but that's just me.
10:56:22 <mornfall> i think it is going away in favor of lazy repos or such
10:56:53 <fasta> However, if you are a developer and intend to make changes to your GHC source tree, then we recommend not using --partial,
10:57:25 <fasta> That must be the problem.
10:57:34 <dino-> I flew into Newark last time I was up there, July. Place is kind of a dump.
10:58:17 <dino-> Our flight crew was apparently already pre-pissed-off with the ground crew because they got immediately mad that we weren't handled once on the ground. Got on the horn and told the passengers to write in and complain about it.
10:58:30 <dino-> Told us that this happens to them every time they fly into there.
10:59:29 <vincenz> trying to book a ticket is insane
11:00:07 <vasylp> ?
11:00:48 <kencausey> hmm, looks to be a bad ghc6.prerm  script with regard to the use of update-alternatives
11:01:36 <dozer> I've got a program that I think is infinite-looping
11:01:43 <dozer> is there a way to debug this?
11:01:58 <fasta> dozer: with HEAD, sometimes.
11:02:06 <fasta> dozer: otherwise Debug.trace
11:02:14 <mauke> profile it, see where it spends 99% of the time
11:02:14 <fasta> dozer: Debug.Trace.trace*
11:02:27 <fasta> mauke: that was suggestion three. :)
11:02:57 <dozer> ok - pointers for profiling?
11:02:57 <fasta> dozer: if it's H98 code, also try Hugs.
11:03:04 <fasta> dozer: GHC user guide
11:03:06 <dozer> it's definitely ghc code
11:03:34 <dozer> not H98 :)
11:03:51 <mauke> @where profiling
11:03:51 <Igloo> kencausey: Can you be more specific?
11:03:51 <lambdabot> I know nothing about profiling.
11:03:59 <mauke> @where+ profiling http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
11:04:00 <lambdabot> Done.
11:04:22 <kencausey> Igloo: "Use of uninitialized value in string eq at /usr/sbin/update-alternatives line 432"
11:04:44 <kencausey> Igloo: I think maybe I'm finding that it's a bug on update-alternatives itself though, still investigating
11:05:32 <Igloo> OK
11:05:42 <vasylp> QUIT
11:06:27 <dozer> right, trace it is I guess
11:06:36 <kencausey> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=423140
11:06:39 <lambdabot> Title: #423140 - update-alternatives: lots of "uninitialized value" error messages - De ...
11:06:41 <kencausey> hmm, claims to have been fixed though
11:07:39 <kencausey> Igloo: I get the above error if I try to "update-alternatives --remove ghc /usr/lib/ghc-6.6.1/bin/ghc" which is part of the ghc6.prerm script
11:08:59 <Igloo> kencausey: What versino of dpkg do you have?
11:09:21 <kencausey> 1.14.6
11:09:35 <kencausey> I'm running Debian Unstable and just updated a few hours ago
11:10:01 <Igloo> kencausey: If you think it's a ghc6 bug can you file a bug, including how to reproduce it from scratch please?
11:10:04 <kencausey> I get the same error with a dpkg-reconfigure ghc6
11:10:53 <kencausey> well, the from scratch might be difficult for me to determine since the original cause may be due to past installation of some version of ghc (or even say hugs)
11:20:00 <dons> glguy: hey :)
11:20:49 <dons> hi glguy
11:20:52 <glguy> hi
11:21:06 <glguy> ah irc, it saves us from atually looking at and talking to each otherc
11:21:09 <dons> :)
11:21:22 <gkr> Uhm.
11:21:39 <gkr> How should I declare show for (Integer, Integer, Integer, Integer, Integer, Integer)?
11:21:45 <gkr> ERROR - Cannot find "show" function for:
11:21:45 <gkr> *** Expression : [(1,2,3,4,5,6)]
11:21:45 <gkr> *** Of type    : [(Integer,Integer,Integer,Integer,Integer,Integer)]
11:21:49 <gkr> (Hugs)
11:22:18 <vincenz> instance (Show a, Show b, Show c, Show d, Show e, Show f) => Show (a,b,c,d,e,f) where
11:22:50 <dons> yeah, large tuples are missing instances in hugs. you can get them with newer hugs though
11:23:01 <vincenz>   showsprec d = ('(':) . shows a . (++ ", " ++) . shows b . (++ ", " ++_) . shows c .... . (:')')
11:24:39 <pejo> dons, how's work?
11:24:39 <Lemmih> Igloo: ping.
11:24:42 <monochrom> That is a humongous tuple.
11:24:47 <dons> pejo: fun :)
11:25:11 <Igloo> Lemmih: pong
11:25:16 <monochrom> "If you have to ask how many threads you can have, there is probably a design flaw."
11:25:36 <monochrom> "If you have to ask how large tuples you can have, there is probably a design flaw." :)
11:27:02 <sorear> 0-infinity rule, people! :)
11:27:13 <vincenz> you mean [0, inf) ?
11:27:23 <vincenz> I wonder if it's possible to have the interval [-inf, inf]
11:27:29 <sorear> no, {0, inf}
11:27:40 <vincenz> { ?
11:27:56 <vincenz> what is a brace?
11:28:03 <sorear> set notation
11:28:13 <vincenz> so the set consisting of two elements?
11:28:18 <vincenz> 0 and inf
11:28:21 <sorear> yes
11:30:16 <monochrom> What is a tuple with negatively many components?
11:30:50 <fax> )1, 2, 3(
11:31:06 <vincenz> monochrom: you mean few?
11:31:21 <monochrom> yeah
11:32:13 <vincenz> anyways, you can build up large tuples out of small ones
11:35:06 <sorear> @users
11:35:06 <lambdabot> Maximum users seen in #haskell: 402, currently: 392 (97.5%), active: 17 (4.3%)
11:35:44 <sorear> ghc-6.8/ghc eh?
11:36:58 <sorear> Igloo: (re your -Wwarn patch) Why not -Wno-error?  (I think it should exist, for consistency)
11:37:31 <Igloo> Hmm, could do. Although -w/-W/-Wall don't have the symmetry either
11:37:42 <Igloo> ghc-6.8/ghc is the ghc repo in the ghc-6.8 branch
11:42:41 <newsham> has anyone converted the .svg image posted on haskell-cafe to something more mainstream?
11:42:47 <newsham> i dont want to install svg viewer
11:42:58 <Nafai> newsham: Don't you have firefox?
11:43:16 <newsham> huh, firefox shows it.. danke
11:43:30 <Nafai> np
11:44:12 <profmakx> .svg is not mainstream?
11:44:55 <monochrom> "mainstream" means "I have heard of it". Always.
11:45:04 <monochrom> See also "real world".
11:45:20 <vincenz> "real world" : That which people refer to when handwaving about the nonviability of a good solution.
11:45:40 <monochrom> "real world" means "I use it". Always.
11:46:52 * oerjan wonders if lambdabot is going to need a @monochrom command :D
11:47:10 <monochrom> You have probably heard enough about "they use C++ in the real world". Actually, even that is too good to be true. I have friends who say "I saw no one using templates in C++".
11:47:25 * monochrom beats up oerjan
11:48:05 * fasta would vote for such a feature ^^
11:48:09 <vincenz> monochrom == palomer2?
11:48:16 * kReepicheep hands out rabies shots
11:48:41 <fasta> @girl17
11:48:42 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
11:49:08 <oerjan> @list girl17
11:49:08 <lambdabot> No module "girl17" loaded
11:49:14 <vincenz> @keal
11:49:14 <lambdabot> actually it bug in math
11:49:16 <vincenz> @keal
11:49:17 <lambdabot> doctor just give meds not fix prollem
11:49:28 <oerjan> @help girl17
11:49:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:49:31 <vincenz> @monochrom
11:49:31 <lambdabot> Unknown command, try @list
11:49:31 <puusorsa> medication time!
11:49:33 <oerjan> @girl
11:49:33 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
11:49:40 <oerjan> @gir
11:49:40 <lambdabot> I have been into not actually hacking, but social engineering
11:49:45 <oerjan> @gi
11:49:46 <lambdabot> well.. I never hacked Russians
11:49:54 <oerjan> @irl
11:49:54 <lambdabot>  @where <key>, return element associated with key
11:50:01 <vincenz> @irc
11:50:01 <lambdabot> Not enough parameters!
11:50:04 <vincenz> @irc 1
11:50:04 <lambdabot> Not enough parameters!
11:50:04 <monochrom> Go for it! Go for it! @g
11:50:05 <vincenz> @irc 1 2
11:50:06 <lambdabot> Not enough parameters!
11:50:07 <vincenz> @irc 1 2 3
11:50:07 <lambdabot> Not enough parameters!
11:50:10 <vincenz> @irc 1 2 3 4 5 6 7
11:50:10 <lambdabot> Plugin `irc' failed with: IRCRaised connect: invalid argument (Invalid argument)
11:50:12 <oerjan> @g
11:50:13 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . v
11:50:14 <vincenz> o.O
11:50:23 <monochrom> Darn.
11:50:29 <oerjan> @list girl19
11:50:29 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
11:50:46 <fasta> @b52s
11:50:46 <lambdabot> Hot pants explosion at the factory!
11:51:30 <fasta> So.. anyone got a clue about my indebuggable infinite loop?
11:51:34 <kaol> using /msg lambdabot @get-shapr is a solipsistic experience
11:51:47 <idnar> @girl19
11:51:47 <lambdabot> I have stolen about 50 msn and yahoo accounts
11:52:09 <oerjan> fasta: where?
11:53:06 <fasta> oerjan: I didn't paste code.
11:53:13 <sieni> @yhjulwwiefzojcbxybbruweejw
11:53:14 <lambdabot> "\""
11:53:17 <sieni> @yhjulwwiefzojcbxybbruweejw
11:53:18 <lambdabot> "\""
11:53:21 <monochrom> oerjan: I think that's the question. Where is the loop? :)
11:53:25 <sieni> that's a useful feature
11:53:27 <oerjan> in that case i _really_ don't have a clue :D
11:53:30 <sorear> monochrom has a very well established real world identity
11:53:32 <fasta> oerjan: It should be simple tail call recursion.
11:53:39 <mornfall> hm... how do i write this (http://hpaste.org/2581) much better?  Liskni_si? :-)
11:54:12 <fasta> oerjan: I placed unsafePerformIO(putStrLn "test") before every operation, but even those don't get printed.
11:54:26 <oerjan> fasta: um, i just logged on.  was this discussed previously?
11:54:29 <fasta> oerjan: except for the first time the loop get's run.
11:54:33 <vincenz> fasta: link?
11:54:44 <mornfall> i use bits from http://www.cse.unsw.edu.au/~dons/blog/2007/03 (with Process.run to not hang)
11:54:44 <lambdabot> Title: Haskell hacking
11:54:46 <fasta> oerjan: a bit, you can scroll back.
11:54:49 <mornfall> +fixed
11:55:01 <oerjan> fasta: unsafePerformIO(putStrLn "test") _should_ only print once
11:55:05 <sorear> mornfall: You really ought to be using a temporary directory
11:55:45 <fasta> oerjan: "test" is variable
11:55:48 <mornfall> sorear: probably, how do i make one? :)
11:56:04 <fasta> oerjan: but you are right that GHC could evaluate the literal code above only once.
11:56:08 <mornfall> oh
11:56:11 <mornfall> getTemporaryDirectory
11:56:17 <mornfall> no
11:56:20 <sorear> mornfall: not that ;)
11:56:23 <oerjan> fasta: and you have no actual code to show?
11:56:29 <mornfall> no more candidates from hoogle
11:56:37 <oerjan> this being work for the NSA, i presume
11:56:53 <fasta> oerjan: I don't have a test case and otherwise I would have to post 5KLOC, I think.
11:57:16 <fasta> oerjan: which would require you to get the same build setup as I have etc...
11:57:20 <fasta> oerjan: not practical.
11:57:24 <sorear> mornfall: use getTemporaryDirectory and System.Random to invent a name, then call System.Directory.createDirectory.  Retry on EEXIST.
11:57:35 <sorear> mornfall: Then create your files inside the new directory.
11:58:48 <kencausey> Trying to build with Cabal I'm getting 'no hsc2hs preprocessor available' even though I have a link /usr/bin/hsc2hs which appears to work.  Is there something else it could be expecting to find?
11:58:50 <sorear> dons: is it "safe" for a package to depend on Data.Stream?
11:59:04 * oerjan takes a look at the channel logs
11:59:15 <sorear> kencausey: don't think so, but why are you worried?
11:59:19 <sorear> kencausey: echo $?
11:59:43 <kencausey> 1
11:59:48 <sorear> oh.
11:59:52 <kencausey> are you saying it's an ignorable error?
12:00:02 <sorear> no, I'm saying it's a warning.
12:00:18 <kencausey> So it was in fact successful?
12:00:28 <sorear> every other day someone comes in panicking over harmless cabal warnings even with exitcode 0
12:00:58 <kencausey> Well, it's not labelled as a warning, so how is one to know?
12:01:09 <sorear> echo $?  prints 0 :)
12:01:19 <sorear> but your case is different.
12:01:28 <kencausey> sure
12:01:32 <sorear> what's the last message printed?
12:01:51 <kencausey> Setup.lhs: Graphics/X11/Xlib/Extras.hsc: no hsc2hs preprocessor available
12:01:51 <kencausey> 1
12:01:59 <kencausey> oops, ignore that trailing 1
12:02:12 <sorear> kencausey: ah, that's a build error
12:02:20 <sorear> kencausey: configure is the noisy one :)
12:02:24 <kencausey> I said I was using cabal to build ;)
12:02:33 <monochrom> All I can say is: look harder. "f x = f x" is a loop, and obvious. "f x = if b then f x else blah" is probably also a loop, and probably less obvious. You see it can hide arbitrarily deep. Here is another factoid: all loops are due to tail recursion.
12:02:58 <sorear> kencausey: (random guessing) Did you rerun ./Setup.lhs configure; after installing hsc2hs?
12:03:17 <kencausey> sorear: hmm, that could be a good guess, one moment...
12:04:12 <fax> :t f in let f x = f x
12:04:12 <kencausey> sorear: yep, that looks like it takes care of it, thanks
12:04:14 <lambdabot> parse error on input `in'
12:04:25 <fax> :t let f x = f x in f
12:04:27 <lambdabot> forall t t1. t -> t1
12:04:40 <sorear> kencausey: (trying to preempt another FAQ) did you run autoreconf (ignore this unless you are running the darcs version)
12:05:19 <kencausey> sorear: No, if you look back in the logs a built you will find that ghc6 install on Debian unstable is having problems with alternative links for me.
12:05:36 <kencausey> sorear: I'm having to manually create them, didn't know of hsc2hs until this point
12:05:43 <dozer> ok, I'm bored of adding in trace statements
12:05:44 <kencausey> sorear: so, probably a corner case at best
12:05:49 <dozer> what do I do for a debugger?
12:06:52 <mauke> dozer: wait a few years
12:06:55 <mauke> or write one
12:06:57 <Lemmih> dozer: Tried 'breakpoint' in ghci?
12:07:10 <fasta> dozer: you install GHC head, but don't expect it to be perfect.
12:07:54 <monochrom> Pay me money to debug it for you.
12:08:07 <monochrom> I am a good debugger.
12:09:07 * dozer swears heavily
12:09:45 <vincenz> open source monochrom !
12:09:55 <monochrom> working on it.
12:10:11 <oerjan> fasta: is this a specific loop that seems to somehow run only one iteration?
12:10:17 <monochrom> wish I could just pour out all my wisdom over you.
12:10:20 <Lemmih> dozer: 'breakpoint' is useless in your case?
12:10:42 <mornfall> hm, no path manipulation in ghc libs?
12:10:48 <fasta> oerjan: this loop should only run one iteration and then at the next find out no more loop are needed.
12:10:50 <mornfall> (ie, basename and friends)
12:11:01 <fasta> oerjan: when I inline the second loop, it all works as intended.
12:11:16 <monochrom> System.FilePath
12:12:21 <oerjan> what are the arguments to the loop function for each of the two iterations?
12:13:37 <dozer> Lemmih: I'm trying to find an infinite loop somewhere in 3kl of haskell, across 5 files - without IDE support, I'm never going to be able to use :break to find things
12:13:55 <fasta> oerjan: I will look for myself somewhat more, since I doubt this will go anywhere.
12:13:59 <sorear> dozer: what about -fbreak-on-exception?
12:14:56 <dozer> google doesn't know anything about that
12:15:02 <fasta> dozer: the manual does
12:15:09 <fasta> dozer: but you need HEAD
12:15:28 <fasta> But -fbreak-on-exception only worked for me once in 6 times.
12:15:38 <Lemmih> dozer: Good news then, ghc-6.6 doesn't support :break.
12:15:44 <monochrom> hahaha
12:15:46 <vincenz> @remember fasta dozer: but you need HEAD
12:15:47 <lambdabot> Done.
12:16:39 <fasta> If you don't use girl17 grammar you can only parse that in one way.
12:16:40 <Lemmih> fasta: There's low power breakpoint functionality in ghc-6.6.
12:17:10 <fasta> Lemmih: 6.6 is too buggy to be usable, imho.
12:17:22 <fasta> But different people have different needs.
12:17:43 <FMota> Hello. :)
12:17:56 <dozer> I really like haskell as a language, but the immaturity of the libraries and dev environment keeps making me think "wouldn't it be easier to botch this in Java?"
12:17:58 <Lemmih> "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
12:18:25 <fasta> Lemmih: is that directed to me?
12:18:32 <Lemmih> fasta: Yeah.
12:18:33 <oerjan> @remember Lemmih "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
12:18:33 <lambdabot> Done.
12:18:37 <vincenz> oerjan: beat me to it
12:18:39 <mornfall> is it possible to have a type (Foo) that "is" a string, is accepted where string is expected, but when Foo is expected, only Foo is accepted, and no String?
12:18:57 <vincenz> newtype Foo = Foo Stirng
12:18:57 <fasta> Lemmih: I don't think you understand how many bugs I found in GHC.
12:19:15 <Cale> mornfall: no
12:19:26 <Cale> mornfall: but you can create a newtype, like vincenz showed
12:19:48 <mornfall> but i have to unwrap the string manually then?
12:19:52 <Cale> yeah
12:19:55 <mornfall> bummer
12:20:06 <fasta> mornfall: can you tell us how it would work otherwise?
12:20:08 <Cale> However, the unwrapping doesn't cost anything performance wise
12:20:16 * fasta grabs popcorn
12:20:21 <Cale> it's purely a type system thing which gets boiled away in compilation
12:21:08 <mornfall> what would be the practice for protecting things like, say, rmTempDir = removeDirectoryRecursive from accepting something that didn't come from makeTempDir?
12:21:47 <vincenz> phantom types
12:21:59 <monochrom> That would be newtype indeed.
12:22:21 <mornfall> i have heard the term (phantom type)
12:22:22 <mornfall> --> study
12:22:39 <vincenz> tho a simple solution can be done with simply a newtype
12:22:42 <vincenz> and hiding the constructor
12:22:55 <Cale> I don't think you need a phantom type for something this simple, just a newtype and module boundaries.
12:23:05 * vincenz beeps Cale 
12:23:43 <bos> hmm. the Crypto package defines several large Word types as synonyms. it exports those synonyms, but not the type they're synonyms of. and though that type is an instance of many useful classes, GHC swears that the synonyms are not.
12:23:58 <Cale> So you create a module for makeTempDir to live in, and a newtype for String which makeTempDir is going to produce a value of.
12:24:22 <Cale> You export a function which turns that type back into a String, but you *don't* export the constructor.
12:24:40 <Cale> That is, if you have something like:
12:24:49 <bos> Cale: i was just having this conversation with peter simons about his desire for mutable bytestrings :-)
12:24:55 <monochrom> protection is a special case of abstraction aka encapsulation
12:25:00 <geezusfreeek> does there exist a typeclass something like: (class Zippable z where genericZip :: (a -> b -> c) -> z a -> z b -> z c)?
12:25:06 <Cale> newtype TempDir = TD String
12:25:19 <geezusfreeek> and i know that name is probably a bad one
12:25:28 <Cale> er
12:25:38 <oerjan> geezusfreeek: Applicative
12:25:42 <Cale> newtype TempDir = TD { dirName :: String }
12:25:48 * geezusfreeek looks up applicative
12:25:51 <oerjan> ZipList is an instance of that
12:25:58 <Cale> then in your export list, you want something like (makeTempDir, TempDir, dirName)
12:26:01 <Cale> but not TD
12:26:07 <oerjan> although it is far more general than just zipping
12:26:19 <mornfall> Cale: i intended to avoid decorating each use of makeTempDir result with (dirName ...)
12:26:50 <Cale> mornfall: you still won't -- however, you will extract the dirName shortly afterward
12:27:05 <geezusfreeek> oerjan, hmm, yeah it's a bit different, but that will do even more nicely. thanks
12:27:17 <Cale> mornfall: You want to hang on to that original TempDir, because you'll need it to pass to your removeTempDir
12:27:23 <mornfall> right
12:27:31 <mornfall> that's a bit silly though
12:27:41 <Cale> The tag is "proof" that the directory was actually created as temporary.
12:28:26 <Cale> Another way to do it is just to write something like  withTempDir :: (FilePath -> IO a) -> IO a
12:28:50 <mornfall> hm
12:28:53 <mornfall> sounds better
12:29:04 <Cale> that handles allocation and deallocation of the directory
12:30:40 <monochrom> that still allows you to leak the name of the tempdir, e.g., withTempDir return
12:30:58 <Cale> of course.
12:30:59 <monochrom> and there is a way to stop even that.
12:31:05 <monochrom> PHANTOM TYPE
12:32:13 <fasta> strace >> PHANTOM TYPE
12:32:30 <mornfall> i wish i knew how to use phantom type for that :-)
12:32:57 <monochrom> You will in about six months.
12:33:06 <Cale> monochrom: heh
12:33:36 <mornfall> six months is way too long
12:33:38 <mornfall> :-)
12:33:48 <mornfall> i'll find out sooner
12:34:33 <monochrom> You can shorten that to one week if you devote one week to reading academic treatises and not do anything else e.g. go to school or go to work.
12:34:54 <Liskni_si> what's phantom type?
12:34:54 <vincenz> or eat
12:35:02 <mornfall> well, question is, what you mean with "leak the name of the  tempdir" anyway
12:35:05 <monochrom> eat is ok. you eat while you read.
12:35:08 <Cale> heh, phantom types aren't *that* involved :)
12:35:09 <mornfall> since i actually need the tempdir name to construct paths
12:35:51 <mornfall> Liskni_si: http://en.wikibooks.org/wiki/Haskell/Phantom_types and http://babel.ls.fi.upm.es/~pablo/Papers/Notes/GADTs.html
12:36:02 <monochrom> The semantics of (withTempDir m) is: create tempdir, call m, remove tempdir.
12:36:30 <Cale> (and return the result of m)
12:36:35 <mornfall> ah, understand
12:36:37 <monochrom> The intended use is: withTempDir (\name -> create and use files under name)
12:36:51 <Cale> It's not actually all that reasonable to do it safely, because you'd need to wrap up all the directory handling functions, which is kind of silly.
12:36:55 <monochrom> But nothing stops you frome withTempDir return.
12:37:23 <mornfall> monochrom: sure, but i'd say that's a reasonable tradeoff
12:37:23 <monochrom> But withTempDir return is misleading. So you have the name, but the corresponding tempdir no longer exists.
12:37:45 <Liskni_si> well, other withFunctions allow you to return a pointer and then segfault
12:37:53 <Liskni_si> so i'd guess this is ok
12:37:57 <fasta> Cale: you mean that directory handling functions should be in a type class? ;)
12:38:10 <monochrom> It comes down to how much discipline you obey, i.e., how much discipline you have in faithfully RTFM for the intended use.
12:38:25 <Cale> fasta: no, I just mean that the way things are now, there's not much point in trying to use the type system to enforce this
12:38:56 <monochrom> Programmers, or at least programming students, are notorious for never RTFM.
12:39:37 <monochrom> Take a look at the man page of strcpy for example. It begins with: char * strcpy(char *dst, char *src);
12:39:48 <monochrom> You know what my classmates did upon reading that?
12:39:58 <monochrom> char *s; strcpy(s, "hello");
12:39:59 <sieni> senior software architects are, however, sometimes known to rtfm after banging their head to the wall for a week or two
12:40:09 <Cale> You could do something like  withTempDir :: (String -> IO ()) -> IO (), which would prevent the case of just returning the file path, but wouldn't prevent you from, say, writing the string into another file, or an IORef, and then reading that back later.
12:40:39 <monochrom> Talk about the type system having faith in human intelligence.
12:41:29 <Cale> Basically any system where the file path remains treated as a string is going to be a little "unsafe" in that regard.
12:41:45 <monochrom> Yeah, it should be a phantom type.
12:41:50 <monochrom> XD
12:42:27 <Cale> But any system in which it's not a String is impractical.
12:42:35 <Cale> (at least right now)
12:42:54 <Cale> (unless you care to do quite a lot of work for that little bit of extra protection)
12:43:13 <monochrom> And just when you use phantom types or whatever type system to proctect it, and think you're safe now... Oleg shows you how to use continuations to invert control and subvert it!
12:44:31 <sorear> I think we should reimplement the entire file system inside Haskell using monadic references.
12:44:38 <Vq^> is Oleg turning into a Chuck Norris of type-systems?
12:44:55 <monochrom> I think there only need an injection String -> FilePath, and a suite of "add more", "cut it here", "what is the directory part" operations.
12:45:00 <sorear> @quote OlegFacts
12:45:00 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
12:45:00 <fasta> Vq^: wasn't he already?
12:45:16 <Vq^> maybe i just missed that
12:45:28 <bos> that's kind of what System.FilePath does, only without the type bondage
12:45:28 <Vq^> oh, theres an olegfacts out there :)
12:46:06 <monochrom> Once you have as many operations as in System.FilePath, you will miss little by abstracting the type.
12:47:53 <oerjan> and then someone will add unsafeExtractString :)
12:48:12 <monochrom> There are only two things you'll miss. One is inertia, i.e., "OMG BBS you're breaking my existing code LOL". Another is it will be harder to "I want to go through a sequence of paths, /a/0/b, /a/1/b, /a/2/b, /a/3/b, ..."
12:48:36 <mornfall> monochrom: oleg or not, who stops you from writing the tempdir name out in the filesystem and reading it later out of withTempDir :-)
12:49:02 <sorear> that's why we rewrite the whole FS inside GHC.
12:49:10 <mornfall> ah, right
12:49:13 <monochrom> That depends on the rest of the file operations.
12:49:25 <mornfall> like halfs or so?
12:49:34 <Cale> mornfall: in his idea, the path is not a string anymore, but an abstract datatype which you can't directly observe
12:49:42 <mornfall> ah
12:49:47 <mornfall> okey, that could help
12:49:58 <monochrom> If withTempDir imposes a phantom type, then you need all other file operations to comply with that phantom type too. IOW if you have a string you pretty much can't call any file operation on it.
12:50:00 <mornfall> until you go and read memory with a C FFI call
12:50:18 <Cale> yeah, but that doesn't count ;)
12:50:20 <fasta> This is really a low-point in GHC bugs... manually unrolling the recursion even 20 times with copy pasting works, but using the most basic thing of all in functional programming doesn't...
12:50:33 <Liskni_si> and you can encrypt the internal representation
12:50:41 <Liskni_si> and, well, glibc does that with some things
12:50:46 <Liskni_si> so why not :)
12:50:46 <sjanssen> fasta: what's the bug?
12:50:59 <mornfall> Liskni_si: glibc is clearly nuts :)
12:51:15 <oerjan> fasta: maybe you have a scoping error somewhere that makes the copy/paste not actually equivalent?
12:51:22 <fasta> oerjan: no
12:51:28 <fasta> oerjan: I already compiled with -Wall
12:52:11 <monochrom> I would love to see it. In a 100-token self-contained reproduction.
12:52:37 <fasta> monochrom: sure, I would love to see that too.
12:52:54 <fasta> monochrom: doesn't mean it's a) possible b) non-trivial
12:53:14 <fasta> easy*
12:54:44 <monochrom> That is why I offer service that costs money.
12:59:34 <monochrom> It is interesting how as soon as I offer paid service, people show they do not put their money where my mouth is. :)
13:00:00 <vincenz> monochrom: are you high?
13:00:14 <mornfall> maybe low
13:00:51 <FMota> that reminds me... I've got to watch weeds before we return the DVD to blockbuster.
13:01:01 <FMota> "Higher Education" XD
13:01:12 <monochrom> I am just witty. :)
13:01:29 <FMota> Pretty, witty, and gay?
13:02:23 <fasta> monochrom: If you lived next door, I could consider it on a no-cure-no-pay basis, but even then it would have little point, unless your first name is Simon.
13:02:41 <mornfall> now, how do i ensure that withTempFile is not terminated by an exception from inside?
13:02:47 <mornfall> withTempDir
13:03:09 <monochrom> withTempDir can catch and re-throw exceptions.
13:03:20 <shapr> @ YOW !
13:03:29 <fasta> @yow
13:03:29 <lambdabot> I was making donuts and now I'm on a bus!
13:15:47 <hpaste>  mornfall pasted "tif2pdf, take 2" at http://hpaste.org/2582
13:17:31 <mornfall> any obvious holes? (in eg. mkTempDir)
13:19:32 <mornfall> (and i'm still somewhat puzzled about exception/error handling, ie. ioError x in there should be probably replaced with something else?)
13:20:31 <scandal> what package do i need to install to be able to import Control.Monad.Reader on an Ubuntu system for use with ghc?
13:20:57 <bos> mtl
13:21:14 <mornfall> could be libghc6-mtl-dev
13:22:02 <scandal> mornfall : yes that was it, thanks!
13:23:20 <mornfall> i should write cabal-deb or something, too :)
13:23:45 <mornfall> unless there already is one
13:25:56 <Tac-Work> > [1, 2, 3] >>= \x -> [1,2,3] >> = \y -> return [x, y]
13:25:56 <lambdabot>  Parse error
13:26:10 <mornfall> extra space?
13:26:20 <Tac-Work> > [1, 2, 3] >>= \x -> [1,2,3] >>= \y -> return [x, y]
13:26:23 <Tac-Work> indeed
13:26:28 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
13:30:37 <mauke> > replicateM 2 [1,2,3]
13:30:39 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
13:32:23 <Tac-Work> @src replicateM
13:32:24 <lambdabot> replicateM n x = sequence (replicate n x)
13:32:37 <Tac-Work> @sequence
13:32:42 <lambdabot> Unknown command, try @list
13:32:42 <Tac-Work> @src sequence
13:32:44 <lambdabot> sequence ms = foldr k (return []) ms
13:32:46 <lambdabot>     where
13:32:48 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:35:20 <Tac-Work> @type sequence
13:35:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:38:18 <Tac-Work> @info replicateM
13:38:18 <lambdabot> (replicateM)
13:38:30 <Tac-Work> where is replicateM defined?
13:38:36 <mauke> @index replicateM
13:38:36 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:38:55 <Tac-Work> thanks
13:44:00 <hpaste>  llewyenoh annotated "Change battery information" with "Changing time formula based on charging or discharging" at http://hpaste.org/2552#a9
13:44:15 <Tac-Work> @src scanl
13:44:16 <lambdabot> scanl f q ls = q : case ls of
13:44:16 <lambdabot>     []   -> []
13:44:16 <lambdabot>     x:xs -> scanl f (f q x) xs
13:48:52 <llewyenoh> can someone please help me determine if it will be difficult to modify http://hpaste.org/2552#a9 ?
13:49:56 <pgavin> llewyenoh, its not code you've written i take it
13:50:40 <llewyenoh> pgavin: no, mostly taken from other people and modified with help from others
13:51:30 <pgavin> change the Active state into 2 states
13:51:47 <pgavin> e.g. Charging and Discharging
13:52:03 <pgavin> then set time (near the bottom of battery) accordingly
13:52:24 <llewyenoh> ok, i see what you mean, i'll see what i can do
13:53:46 <llewyenoh> pgavin: is there any way i can keep it as both active and charging/discharging?
13:54:00 <llewyenoh> because i only want to do the fcap, rcap, etc if it's active
13:54:07 <llewyenoh> the only line that differs is the time line
13:54:56 <pgavin> you could factor fcap, rcap, & rate into a separate function
13:55:20 <llewyenoh> pgavin: oh, that works just as well
13:55:22 <pgavin> return a tuple (fcap, rcap, rate)
13:56:18 <pgavin> or make a separate enumeration data ChargeDirection = Charging | Discharging
13:56:35 <pgavin> then make ChargeStatus = Charged | Active ChargeDirection
13:57:08 <pgavin> or maybe CurrentDirection would be more correct )
13:57:10 <pgavin> :)
13:57:31 <llewyenoh> hahahah ok, thanks for the help
13:57:36 <llewyenoh> let me try this out
14:00:25 <jfredett> ... if i have p -> q \/ p -> s, can I deduce p->q? I think its a no, but it would be awesome if it was a yes
14:00:51 <pgavin> no
14:00:53 <jfredett> \/ == inclusive or, I think I have that notation right
14:01:00 <jfredett> pgavin: thats what i thought, thanks
14:01:20 <pgavin> if it was an & you could, however
14:01:24 <jfredett> yah
14:06:22 <llewyenoh> pgavin: when i get to the time part, how can i split between charging and discharing?
14:06:27 <llewyenoh> pgavin: not another case, is it?
14:06:46 <pgavin> post your new code so I can see where you're at
14:07:39 <esteban2> hello
14:07:55 <pgavin> hello
14:08:04 <esteban2> i'm looking for someone who would be kind to be of some help with this haskell problem
14:08:11 <esteban2> anyone?
14:08:13 <fasta> esteban2: monochrom
14:08:24 <esteban2> fasta, huh?
14:08:30 <hpaste>  llewyenoh annotated "Change battery information" with "Updated with CurrentDirection" at http://hpaste.org/2552#a10
14:08:36 <monochrom> It may cost you money. :)
14:08:57 <esteban2> mmm...
14:09:41 <pgavin> llewyenoh, you want time to depend on which direction it's going, right?
14:09:42 <esteban2> i need to find a [Char] in a list of tuples ([Char],Int).. how can that be done? i can't figure it out yet
14:09:58 <pgavin> @t fst
14:09:59 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
14:10:03 <pgavin> @type fst
14:10:05 <lambdabot> forall a b. (a, b) -> a
14:10:26 <llewyenoh> pgavin: yes, and time depends on remaining, which is the one i want to change
14:10:42 <llewyenoh> pgavin: ideally, remaining is either rcap or (fcap - rcap)
14:11:22 <ari> esteban2: It kind of depends on what you mean with "find"
14:11:26 <pgavin> llewyenoh, something like time = secondsToHHMMSS $ case direction of { Charging -> ... ; ... }
14:11:41 <ari> esteban2: If you want to get the tuple with the specific [Char] in it...
14:11:42 <ari> :t lookup
14:11:45 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:11:47 <esteban2> i'm doing something liek this:
14:11:49 <llewyenoh> pgavin: oh, duh, that makes sense
14:11:56 <llewyenoh> pgavin: thanks
14:12:01 <pgavin> llewyenoh, np :)
14:12:29 <malsyned> what does "import {-# SOURCE #-} ..." do?
14:12:38 <esteban2> func ((a,b,c):xs) (y:ys) | any (==(y)) (here i should put the list of [Chars] but its not ) = c+ func ((a,b,c):xs) ys
14:12:59 <sorear> malsyned: Evil GHC hackery
14:13:01 <esteban2> | otherwise = c+ func ((a,b,c):xs) ys
14:13:25 <sorear> malsyned: it specifies to use a .hs-boot file for breaking import cycles
14:13:53 <malsyned> woah.  that is a little evil.
14:13:54 <ari> :t map fst
14:13:56 <lambdabot> forall a b. [(a, b)] -> [a]
14:14:00 <ari> esteban2: I guess that's what you need
14:14:10 <esteban2> func ((a,b,c):xs) (y:ys) | any (==(y)) (here i should put the list of [Chars] but its not ) ==True  = c+ func ((a,b,c):xs) ys
14:14:22 <ari> esteban2: Also, I suggest
14:14:23 <esteban2> is thre a way to do the same without forall?
14:14:23 <ari> @paste
14:14:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:14:52 <esteban2> the course i'm in is a lil bit limited as to the language itself
14:14:58 <ari> esteban2: The stuff starting forall is just the type of that expression, what you actually need to use is the expression itself
14:14:59 <newsham> ?seen shapr
14:14:59 <lambdabot> shapr is in #scannedinavian, #haskell-overflow, #haskell-blah and #haskell. I last heard shapr speak 34m 35s ago.
14:15:14 <newsham> shapr alive?
14:15:17 <ari> esteban2: That is, "map fst <the appropriate list>" in this case
14:15:37 <esteban2> i'll try that
14:15:46 <esteban2> what is fst?
14:15:47 <esteban2> first?
14:15:52 <LordBrain> in a pair
14:15:53 <idnar> > fst (1, 2)
14:15:55 <newsham> > fst (5,7)
14:15:55 <lambdabot>  1
14:15:56 <LordBrain> @t fst
14:15:56 <lambdabot>  5
14:15:56 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
14:15:57 <Tac-Work> Is there a reason behind Pastebin using the logo (a -> b) -> m a -> m b?
14:15:58 <idnar> heh
14:16:22 <pgavin> liftM
14:16:29 <Tac-Work> yeah, I figured that out
14:16:30 <newsham> tac: putting the fun back into functor?
14:16:31 <hpaste>  llewyenoh annotated "Change battery information" with "Compile error with CurrentDirection" at http://hpaste.org/2552#a11
14:17:57 <esteban2> i think that fst function is what i needed.. gonna try it
14:18:08 <newsham> ?src fst
14:18:08 <lambdabot> fst (x,_) =  x
14:18:12 <llewyenoh> pgavin: any ideas about the compile issue?
14:18:38 <pgavin> jas
14:18:41 <llewyenoh> pgavin: oh duh
14:18:44 <llewyenoh> i figured it out
14:18:47 <llewyenoh> forgot Active
14:18:56 <pgavin> right
14:20:01 <llewyenoh> pgavin: i think i'm good now, thanks for all the help
14:20:11 <pgavin> llewyenoh, sure, np :)
14:21:54 <shapr> newsham: You called?
14:25:55 <esteban2> func::[([Char],[Char],Int)]->[[Char]]->Int
14:25:55 <esteban2> func ((a,b,c):xs) (y:ys) | any (==(y)) map snd ((a,b,c):xs) == True = c+ func ((a,b,c):xs) ys
14:25:55 <esteban2> 			| otherwise = c+ func ((a,b,c):xs) ys
14:26:10 <esteban2> but its not working.. :S something wrong maybe with the brackets
14:26:19 <jfredett> paste it?
14:26:19 <jfredett> ?paste
14:26:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:27:06 <hpaste>  esteban2 pasted "tuples" at http://hpaste.org/2585
14:27:24 <jfredett> so what is it supposed to do?
14:27:38 <esteban2> well, i have a list of tuples that has this structure:
14:27:46 <esteban2> (menu,food,price)
14:28:00 <jfredett> oh- its _this_ problem again
14:28:04 <esteban2> and then i have a list of chars which is the food
14:28:18 <esteban2> i want to know the total price for that list of food
14:28:27 <newsham> shapr: how familiar are you with http rfc?
14:28:27 <jfredett> right
14:28:32 <shapr> newsham: Er, somewhat, why?
14:28:36 <Cale> are you allowed to change the types involved? It really sounds like the sort of thing which would be made much clearer by using a record type.
14:28:39 <jfredett> so first off, [Char] == String
14:28:42 <jfredett> they're synonyms
14:28:52 <jfredett> I take it your fairly new to this haskell game
14:28:58 <esteban2> for handling list it's the same as using [Char]?
14:29:02 <newsham> i've been looking it over and by my reading "GET /foo/bar?foo=bar HTTP/1.1"  is an illegal request-line
14:29:05 <jfredett> yep
14:29:06 <esteban2> jfredett: yes
14:29:17 <esteban2> ok
14:29:18 <newsham> which seems ridiculous.. so I'm wondering if i'm on crack, if this is a known rfc deficiency, or what
14:29:32 <jfredett> the compiler swaps it out when you compile / interpret
14:29:34 <Cale> esteban2: yeah, instances of "String" in types are essentially replaced with "[Char]" by the compiler
14:29:37 <shapr> Uhh, I don't know. What section of the rfc?
14:29:54 <newsham> shapr: whats your email addr, i'll mail you mail I wrote about it
14:30:32 <jfredett> esteban2: one thing I have learned over the 3 months I've been messing w/ haskell, theres probably something in the prelude to do exactly what you want
14:30:40 <esteban2> that change makes no change :( or does it? i already changed [Char] to String
14:30:54 <esteban2> the prelude...
14:30:55 <jfredett> it looks like your trying to create a lookup table, right?
14:31:03 <jfredett> the prelude is the standard library
14:31:04 <Cale> data Item = Item { menu :: String, food :: String, price :: Int }
14:31:04 <jfredett> for haskell
14:31:06 <esteban2> yeah
14:31:07 <esteban2> i know..
14:31:17 <Cale> jfredett: you are -> you're
14:31:25 <esteban2> but like i said before this course im in is a bit limited and the haskell library has a lot of stuff i ahven't seen
14:31:27 <jfredett> let me finish formatting your code
14:31:36 <jfredett> esteban2: no worrys
14:31:43 <jfredett> i still find stuff in there that amazes me
14:32:00 <jfredett> like just today, I found that
14:32:00 <jfredett> > (5 - 9) `mod` 12
14:32:06 <esteban2> such as lambda expressions.. we dont use that
14:32:08 <jfredett> does it right
14:32:11 <lambdabot>  8
14:32:13 <jfredett> and returns 8
14:32:15 <jfredett> not -4,
14:32:17 <Cale> esteban2: That type definition should help clarify the code a lot. What it does is to define a new data type called Item, with a single data constructor (also called Item)
14:32:18 <jfredett> which is awesome
14:32:23 <jfredett> right
14:32:40 <Cale> That data constructor takes three fields (so it's like a tuple)
14:32:51 <jfredett> but you get lookup functions
14:32:53 <Cale> However, it also defines extraction functions
14:32:55 <esteban2> the problem i had was to match a String with a String from the tuple.. now i did map snd (the list of tuples)
14:33:00 <Cale> menu, food, and price
14:33:08 <jfredett> (menu my_data_struct) returns the menu
14:33:11 <Cale> snd only works on pairs
14:33:16 <Cale> but you have a list of triples
14:33:19 <esteban2> oh
14:33:21 <esteban2> you're right
14:33:35 <esteban2> i had forgotten that little detail
14:33:37 <Cale> also, you're missing some parens
14:33:58 <esteban2>  > any (==3) [1,2,3]
14:34:02 <esteban2> > any (==3) [1,2,3]
14:34:04 <lambdabot>  True
14:34:06 <Cale> any (== y) map snd (...)
14:34:14 <esteban2> yes.. thats what i was trying to do
14:34:21 <Cale> This passes  (== y), map, snd, and (...) as parameters to any
14:34:22 <esteban2> but its a triple
14:34:27 <Cale> which likely isn't what you want
14:34:34 <Cale> (because any only takes two)
14:34:50 <Cale> So you'd need parens around (map snd ...)
14:35:03 <Cale> but as we discussed, snd isn't the right thing here
14:35:17 <esteban2> :S
14:35:32 <esteban2> if i go through the list.. i lose it right?
14:35:34 <jfredett> esteban2: dont be afraid, the datastructure Cale suggested
14:35:39 <vincenz> > let on f g x y = f (g x) (g y) in Cale `on` Haskell
14:35:39 <jfredett> will take care of it
14:35:40 <lambdabot>   Not in scope: data constructor `Haskell'
14:37:30 <Cale> the goal is to add up the prices of all the items ordered, as found in the menu, right?
14:37:39 <esteban2> yes
14:38:06 <Cale> Are we allowed to change the types involved, or do they have to stay the same?
14:38:34 <esteban2> func [("breakfast","food1",1),("breakfast","food2",1)] ["food1","food2"] = 2
14:38:41 <Cale> right
14:38:46 <esteban2> can haskell change types?
14:39:01 <Cale> Well, we could write func to take different types of parameters
14:39:14 <jfredett> esteban2: no, not really
14:39:22 <jfredett> you can't change them on the fly
14:39:31 <esteban2> a function can be called using different types of parameters, right?
14:39:32 <jfredett> but Cale wants to change the types of the parameters
14:39:33 <Cale> If you'd prefer sticking with plain triples though, that's fine, we'll just write some additional stuff to make it convenient.
14:39:45 <jfredett> esteban2: sure, you can have polymorphic types
14:40:05 <esteban2> i knew that.. but i'm sorta newbie to this and forget all the possibilities
14:40:23 <jfredett> esteban2: we've all been there
14:40:37 <byorgey> esteban2: for example:
14:40:40 <byorgey> @type head
14:40:42 <jfredett> except maybe SLPJ, I think he was born coding Haskell.
14:40:42 <lambdabot> forall a. [a] -> a
14:40:53 <byorgey> that means that "head" can be called on a list of any type
14:40:57 <byorgey> > head [1,2,3]
14:40:59 <lambdabot>  1
14:41:05 <jfredett> > head "abc"
14:41:06 <byorgey> > head "QUZ"
14:41:07 <lambdabot>  'Q'
14:41:08 <lambdabot>  'a'
14:41:20 <byorgey> hmph.  I like mine better. =P
14:41:21 <jfredett> byorgey: beat you!
14:41:23 <jfredett> :P
14:41:29 <jfredett> yours is more interesting
14:41:38 <SamB> jfredett: lambdabot disagrees
14:41:42 <volothampubuntu> I've got a question for lists
14:41:45 <hpaste>  Cale annotated "tuples" with "prototypes" at http://hpaste.org/2585#a1
14:41:47 <byorgey> I just hit three keys at psuedorandom
14:41:51 <jfredett> Lambdabot is wrong
14:41:55 <volothampubuntu> If I want to create the whole natural number list
14:42:00 <SamB> we're all wrong
14:42:07 <volothampubuntu> why I can't write something like this:
14:42:12 <jfredett> you know your a CS-junky when, "You use psuedorandom in place of random."
14:42:20 <Cale> jfredett: you're
14:42:28 <Cale> hehe
14:42:28 <volothampubuntu> let natural = 1  : (natural + 1)
14:42:33 <SamB> lambdabot must be closer to byorgey on the spanning tree or something
14:42:33 <jfredett> Cale: I'm saying your just to annoy you
14:42:34 <jfredett> :P
14:42:49 <monochrom> My naturals include 0.
14:42:51 <Cale> volothampubuntu: because natural is a list, so + 1 doesn't make sense there
14:43:00 <volothampubuntu> yeah, right
14:43:00 <byorgey> > [1..]
14:43:00 <Cale> volothampubuntu: you need to use map
14:43:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:43:08 <jfredett> you're discomfort pleases me, Cale, :P
14:43:16 <Cale> > let natural = 0 : map (+ 1) natural in natural
14:43:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:43:19 <SamB> > natural = 1 : (natural + 1)
14:43:19 <lambdabot>  Parse error
14:43:27 <SamB> @let natural = 1 : (natural + 1)
14:43:27 <lambdabot> <local>:7:15:     No instance for (Num [t])       arising from use of `+' at ...
14:43:49 <esteban2>  > head ([1,2,3],[2,3,4])
14:43:51 <jfredett> > natural = 1 : (tail natural $ + 1)
14:43:51 <lambdabot>  Parse error
14:43:55 <volothampubuntu> uhm, understand..
14:43:55 * byorgey says something witty and entirely unhelpful about making a Num instance for lists
14:43:57 <jfredett> > natural = 1 : ((tail natural) + 1)
14:43:57 <lambdabot>  Parse error
14:44:03 <jfredett> > natural = 1 : ((last natural) + 1) -- I'm dumb
14:44:04 <lambdabot>  Parse error
14:44:09 <jfredett> doh!
14:44:13 <esteban2>  > head [(1,2,3),(2,3,4)]
14:44:13 <Saizan> let!
14:44:16 <mauke> *Main> let natural = 1 : (natural + 1) in take 10 natural
14:44:16 <mauke> [1,2,3,4,5,6,7,8,9,10]
14:44:20 <monochrom> You need a list after :
14:44:22 <mauke> huhu
14:44:25 <jfredett> > let natural = 1 : ((last natural) + 1) in natural
14:44:26 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
14:44:27 <lambdabot>       Expected...
14:44:31 <jfredett> heh heh heh
14:44:32 <esteban2>  > head [(1,2,3),(2,3,4)]
14:44:43 <volothampubuntu> uhm
14:44:45 <byorgey> mauke: heh
14:44:47 <olsner> instance (Num a, Monad m) => Num (m a) where (+) = fmap (+) etc...
14:44:49 <esteban2>  > head [(1,2,3),(2,3,4)]
14:44:55 <esteban2>  > head [1,2]
14:45:03 <volothampubuntu> so let natural = 1 : (natural + 1) in take 10 natural
14:45:05 <mauke> olsner: not Monad, Applicative
14:45:11 <olsner> whatever :P
14:45:15 <mauke> volothampubuntu: no, I'm cheating
14:45:19 <Cale> volothampubuntu: doesn't work, because + doesn't work on lists
14:45:20 <volothampubuntu> but natural :: Int -> èint«
14:45:39 <Cale> volothampubuntu: and natural is a list, because you used :
14:45:40 <volothampubuntu> ok let's try another example
14:45:43 <olsner> (that's only about my second instance declaration anyway)
14:45:59 <Cale> volothampubuntu: however, if you want to add 1 to all the elements of a list, the way to do that is with map
14:46:11 <Cale> map (+1) natural is the list of naturals, incremented by 1
14:46:20 <volothampubuntu> because I'm kinda stuck with infinte list
14:46:22 <Cale> > let nat = 0 : map (+1) nat in nat
14:46:24 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:46:28 <Cale> > let nat = 1 : map (+1) nat in nat
14:46:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:46:30 <monochrom> who isn't. :)
14:46:31 <mauke> olsner: http://83.189.5.24/stuff/haskell/fun.hs
14:46:31 <volothampubuntu> so, for instance, I'm writing a even list
14:46:37 <volothampubuntu> :)
14:46:39 <Cale> > let nat = 0 : map (+2) nat in nat
14:46:41 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:46:52 <mauke> > filter even [0 ..]
14:46:53 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:46:59 <thedward> > take 10 [0,2..]
14:47:01 <lambdabot>  [0,2,4,6,8,10,12,14,16,18]
14:47:06 <Cale> > [0,2..]
14:47:07 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:47:17 <volothampubuntu> uhm
14:48:03 <monochrom> You can also devise your own way.
14:48:04 <volothampubuntu> let even x = 1 : if (mod x 2) == 0 then x : even x + 1 else è«
14:48:16 <volothampubuntu> I know
14:48:18 <volothampubuntu> I know it's ugly
14:48:24 <olsner> hmm... so liftA = liftM = fmap, for anything with instances of all three of Monad, Applicative and Functor?
14:48:34 <volothampubuntu> but this is a function :: Int -> èInt«
14:48:36 <hpaste>  esteban2 pasted "max and min" at http://hpaste.org/2587
14:48:50 <Philippa> olsner: it's not guaranteed
14:49:03 <monochrom> even (x+1) ?
14:49:05 <esteban2> this funcion i just pasted is doing the wrong operation. It's supposed to take the max number if i put (>) but it takes the min
14:49:09 <Cale> volothampubuntu: there's some extra junk characters in what you're typing, but yeah
14:49:19 <volothampubuntu> yeah, I'm sorry
14:49:20 <Philippa> there can be more than one possible Functor instance on a given type, and liftM doesn't have to be the same as the fmap supplied
14:49:23 <volothampubuntu> it's bitchx
14:49:30 <volothampubuntu> something about italian keyboard, I suppose
14:49:39 <esteban2> can anyone check that out?
14:49:49 <esteban2> i just got so confsed but that
14:49:50 <olsner> but the intended semantics of those functions is that they should do the same thing, right?
14:50:25 <Cale> esteban2: um, what's it supposed to be doing?
14:50:38 <esteban2> mom [1,2,3] (>) = 3
14:50:41 <esteban2> mom [1,2,3] (<) = 1
14:50:47 <Cale> oh
14:50:51 <esteban2> but it works the other way around
14:50:53 <esteban2> dont know why
14:51:13 <esteban2> this is what i get:
14:51:21 <esteban2> mom [1,2,3] (>) 1
14:51:23 <esteban2> mom [1,2,3] (>) = 1
14:51:27 <esteban2> mom [1,2,3] (<) = 3
14:51:39 <Cale> by the way, == True is superfluous
14:52:01 <TSC> The partial application of f is backwards
14:52:07 <esteban2> ERROR file:.\a3.hs:3 - Syntax error in input (unexpected `=')
14:52:12 <Cale> yeah, that seems likely
14:52:17 <TSC> If you put in, say, (>), you get "any (> x)"
14:52:24 <Cale> > (>) 5 6
14:52:25 <monochrom> Indeed, imagine, "if you are a flower, I am your leaf" becomes "if you are a flower equals True, I am your leaf equals True".
14:52:25 <lambdabot>  False
14:52:28 <TSC> So you're asking for any elements less than x!
14:52:36 <ari> @type minimumBy
14:52:36 <esteban2> oh..
14:52:38 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
14:52:42 <Cale> > (>) 6 5
14:52:43 <lambdabot>  True
14:53:07 <Cale> > maximumBy compare [1..3]
14:53:08 <lambdabot>  3
14:53:12 <esteban2> well i dont want to use forall.
14:53:13 <Cale> > maximumBy (flip compare) [1..3]
14:53:15 <lambdabot>  1
14:53:38 <Cale> esteban2: that's okay, the bot only prints the forall because it's got some extensions to Haskell turned on
14:53:53 <Cale> esteban2: It's implied if you leave it out :)
14:54:03 <TSC> esteban2: You could implement it with a fold instead if you prefer
14:54:05 <esteban2> is there a predefined function that does what i want to achieve?
14:54:17 <monochrom> > maximum [1,2,3]
14:54:19 <lambdabot>  3
14:54:19 <esteban2> ok.. i'll check that out
14:54:21 <Cale> esteban2: basically minimumBy and maximumBy
14:54:32 <Cale> (or just minimum/maximum)
14:54:36 <esteban2> because if i use those functinos i'll need to know its src
14:54:45 <Cale> > maximum [4,7,21,5,2,5,87,2]
14:54:46 <lambdabot>  87
14:54:51 <Cale> > minimum [4,7,21,5,2,5,87,2]
14:54:52 <lambdabot>  2
14:54:58 <Cale> @src maximum
14:54:59 <lambdabot> maximum [] = undefined
14:54:59 <lambdabot> maximum xs = foldl1 max xs
14:55:01 <monochrom> Many places have the src.
14:55:09 <Cale> that's reasonable
14:55:10 <esteban2> i know
14:55:19 <Cale> @src max
14:55:20 <lambdabot> max x y = if x <= y then y else x
14:55:26 <esteban2> you people live coding haskell? :|
14:55:37 <Cale> esteban2: hehe yep :)
14:56:00 <Cale> esteban2: want to work on that tuples problem some more?
14:56:25 <esteban2> yes.. in fact i need to solve that, but i just stumbled upon this other function that was working wrong
14:56:30 <Cale> Here's how I recommend doing it: write a function lookupMenu which finds a menu item having a given name
14:56:47 <Cale> then look up all the ordered items in the menu (use map)
14:56:53 <esteban2> ok
14:57:04 <esteban2> i'll hve to play with all of those predefined functions..
14:57:10 <Cale> then, use a function which extracts the price from a menu item and map that over the list
14:57:32 <Cale> and apply sum to the resulting list of prices
14:58:06 <Cale> > sum [1,2,3,4]
14:58:08 <lambdabot>  10
14:58:12 <esteban2> ok, i'll work on it now.. when i have something done i'll post it
14:58:34 <Cale> You might want to use the prototypes and helper functions that I pasted
14:58:36 <Cale> http://hpaste.org/2585#a1
14:58:49 <monochrom> Someone should plagiarize "how to design programs" http://www.htdp.org/ for Haskell.
14:58:51 <lambdabot> Title: How to Design Programs
15:01:48 <ddarius> monochrom: I've been thinking about that for a long time.
15:01:58 <ddarius> A HtDP for typeful programming.
15:02:58 <monochrom> In fact the more I read it, the more it seems the author is screaming static types. It alreadys writes like "f :: number -> star" in comments.
15:04:18 <ddarius> Yeah. It does.  Does it ever discuss the general notion of folds?  My recollection is that it does not while dancing around the idea the entire time.
15:06:14 <monochrom> It doesn't.
15:06:39 <monochrom> It's a software engineering book for highschool students.
15:20:48 <Saizan> why do i feel a huge pain even from the most basic things returning to java after a year of haskell?
15:20:59 <shapr> well...
15:22:04 <Botje> Saizan: it's your brain cells slithering away
15:22:28 <Nafai> Botje: Crap, is that what happens?
15:22:34 <esteban2> psicology in here too, wow :)
15:22:36 <Nafai> That would explain this feeling
15:23:04 <Botje> MASS EXTINCTION OF BRANE CELLS
15:23:13 <monochrom> brane?
15:23:20 <Saizan> i've those class members that i can't manipulate only sintactically and pollute my methods with state!
15:23:22 <phobes> It's a string theory thing
15:23:45 <Saizan> s/can't/can/
15:23:52 <Cale> also, an alt.religion.kibology thing :)
15:24:59 <phobes> heh Had to google that one Cale
15:25:25 <phobes> No reference to Branes on the wikipedia page
15:25:50 <Cale> No, there are so many in jokes and references in Kibology that it would be insane to try to list them all on the wikipedia page.
15:26:29 <malsyned> is it newtype or type that introduces a synonym, rather than a new data type?
15:26:42 <DRMacIver> Cale: Isn't kibology one big in joke?
15:26:44 <Botje> type
15:26:56 <Cale> DRMacIver: well, yeah :)
15:27:27 <Cale> hmm, can anyone connect to ftp.std.com?
15:27:45 <Cale> There's a nice diagram of the joke there
15:28:18 <Cale> hmmm
15:29:56 <dozer> Cale: I can't reach it on ftp, or on http, or ping :)
15:30:02 <Cale> hmm
15:30:08 <shapr> nntp?
15:30:28 <shapr> Saizan: What are you writing in Java?
15:30:51 <shapr> Saizan: Considered using the haskell to jvm bridge? :-)
15:39:47 <mcnster> hi. fgl newb q: why does gmap return values inconsistent with the graph structure, and is there anything i can do to make it do so?
15:40:01 <mcnster> !hoogle gmap
15:40:26 <mauke> ?hoogle gmap
15:40:27 <lambdabot> Data.Graph.Inductive.Graph.gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
15:40:28 <lambdabot> Data.Generics.Basics.gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
15:40:28 <lambdabot> Data.Generics.Basics.gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
15:41:21 <mcnster> any ideas, mauke?
15:41:40 <mauke> no, I've never used it
15:41:52 <Saizan> shapr: uni assignment, i need to give the sources unfortunately
15:42:47 <Cale> btw, anyone who's never heard of Kibo should definitely have a look at his photos page :) http://www.kibo.com/photos/
15:42:51 <lambdabot> Title: Kibo : Kibo : Virtual Reality Tour: Menu
15:43:48 <mcnster> i really don't want to wade into the fgl sources if i can help it...
15:44:36 <Cale> mcnster: er, inconsistent with the graph structure?
15:45:32 <Heffalump> should I expect adding to the end of a ByteString to be slow?
15:45:47 <mcnster> Cale, when i print the graph i get one result.  when i run a gmap on it, i get another
15:46:09 <dcoutts> Heffalump: yep O(n), a bit quicker for a lazy bytestring, but still slow
15:46:34 <Cale> mcnster: That's possible
15:46:40 <mcnster> i recall there is something fishy about fgl, but i don't remember what or why....
15:47:08 <mcnster> Cale, can u explain?
15:47:29 <Heffalump> dcoutts: ok, ta. What does Binary.Put do, then?
15:47:47 <luqui> fundeps are obsolete?
15:48:26 <Cale> mcnster: well, gmap does a ufold over the graph with the function (\c -> (f c &)), where f is the context function you pass it.
15:49:08 <dcoutts> Heffalump: ah, that's cunning :-)
15:49:18 <mcnster> ?hoogle ufold
15:49:22 <lambdabot> Data.Graph.Inductive.Graph.ufold :: Graph gr => (Context a b -> c -> c) -> c -> gr a b -> c
15:49:22 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c -> c) -> c -> m (gr a b) -> m c
15:49:22 <lambdabot> Data.Graph.Inductive.Query.Monad.graphUFold :: GraphM m gr => (Context a b -> c -> c) -> c -> GT m (gr a b) c
15:49:38 <dcoutts> Heffalump: it generates the lazy bytestring in the dlist style ([a] -> [a])
15:49:54 <Heffalump> ok :-)
15:50:07 <dcoutts> Heffalump: and uses a buffer that it appends into, but in an externally pure way
15:50:09 <mcnster> Cale, i still don't grok
15:50:32 <Heffalump> how does it do that if the interface is [a] -> [a] ?
15:50:48 <luqui> can someone explain why "functional dependences are now obsolete!" is mentioned in the topic?
15:51:47 <Heffalump> luqui: because of associated types
15:51:55 <Cale> mcnster: Why do you expect gmap to leave the graph the same?
15:52:12 <luqui> Heffalump: thanks, I'll read about those
15:52:19 <luqui> are they implemented?
15:52:40 <Heffalump> yes, in GHC 6.7
15:52:45 <dcoutts> Heffalump: do you do mtl? if so, the best explanation is: type Put a = StateT Buffer (ContT [Strict.ByteString] IO) a
15:53:48 <Cale> mcnster: Which function are you gmapping over the graph?
15:54:03 <malsyned> I've never seen this error before.  What does it mean? "Inferred type is less polymorphic than expected"
15:54:04 <Heffalump> if only I understood ContT ;-)
15:54:06 <Heffalump> but ta.
15:54:16 <Cale> mcnster: It's *supposed* to replace the structure of the graph according to the function given.
15:54:29 <Cale> mcnster: If the function is id, then perhaps there's a problem :)
15:54:41 <mcnster> i don't!  i made gmap f g; f (ins, n, l, outs) = case length l of 1 -> foo; otherwise -> bar
15:54:46 <Heffalump> malsyned: are you using ST?
15:54:57 <malsyned> Heffalump: what's that mean?
15:55:03 <pgavin> dcoutts, ping
15:55:05 <Heffalump> the ST monad
15:55:11 <malsyned> Heffalump: nope
15:55:18 <dcoutts> Heffalump: when you force a chunk, it goes and writes out that chunk strictly in IO into a mutable buffer, then it yields the chunk and lazily suspends the remaining chunks
15:55:23 <dcoutts> pgavin: hia
15:55:35 <pgavin> dcoutts, glib is almost cabalized :)
15:55:39 <dcoutts> @yarr!
15:55:39 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
15:55:42 <Cale> mcnster: Yeah, that's going to give you a potentially very different graph
15:55:46 <dcoutts> pgavin: nice
15:56:10 <Heffalump> malsyned: ok, are you playing with rank-2 types or the like?
15:56:21 <malsyned> Heffalump: not on purpose ;)
15:56:38 <malsyned> I've defined type ScreenSplitter = (Integral d) => d -> d
15:56:54 <Heffalump> oh, that's asking for trouble. Quantifying out variables in a type alias.
15:57:13 <Heffalump> I would recommend making d a parameter to ScreenSplitter, or using a newtype.
15:57:17 <pgavin> dcoutts, once I get it to build all the way I'll put up a patch
15:57:30 <Cale> @paste
15:57:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:57:33 <mcnster> cale, i *expect* a different graph after running a gmap
15:57:59 <hpaste>  (anonymous) pasted "examples of gmap use." at http://hpaste.org/2588
15:58:28 <dcoutts> pgavin: so we're just about to release cabal-1.2 and we've got a branch for that, so we can put cool experimental stuff into the main cabal repo
15:58:32 <mm_freak_> what's a suitable type for vectors of fixed dimension?
15:58:34 <malsyned> Heffalump: ok, I'll try messing with it.
15:58:38 <pgavin> dcoutts, cool :)
15:59:03 <mm_freak_> i'm going to need addition and scalar products, but i could code that myself, if the type doesn't feature at
15:59:04 <Cale> mm_freak_: Array Int ?
15:59:11 <Cale> How big?
15:59:22 <mm_freak_> that may vary extremely
15:59:26 <Cale> You could just use lists even, if they're small.
15:59:27 <mm_freak_> i'm trying to write a neural network
15:59:35 <Cale> ah, then use Arrays :)
15:59:40 <mm_freak_> ok, thanks =)
15:59:49 <mm_freak_> should i bother using mutable arrays?
16:00:12 <Cale> Probably not, but you might be able to do unboxed ones.
16:00:26 <mm_freak_> k
16:00:38 <Cale> If you really have trouble with performance, you might consider moving to mutable arrays.
16:00:50 <Cale> But usually it's not worth the trouble :)
16:01:01 <sieni> and anyway you might use diffarrays
16:01:21 <mm_freak_> what are diffarrays?
16:01:41 <Cale> Yeah, might give those a shot -- they have disappointing constant terms, but the asymptotic performance is nice :)
16:01:43 <sieni> mm_freak_: they are regular arrays that provide functional interface
16:01:57 <Cale> They're arrays with an immutable interface, but do mutation under the covers.
16:02:18 <Cale> Accesses to old versions of the array get progressively slower though.
16:02:19 <mm_freak_> ok, that sounds interesting =)
16:02:22 <sieni> mm_freak_: regular mutable arrays, that is. they just keep track of the changes you do in case you refer to the old version of the array
16:02:31 <mm_freak_> like with reference counts and stuff?
16:03:01 <sieni> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Diff.html
16:03:04 <lambdabot> http://tinyurl.com/22vwjo
16:03:28 <mm_freak_> hmm…  i need to test their performance first…  they should be faster for ANN training, but slower for ANN application
16:03:29 <sieni> mm_freak_: garbage collection will take care of the old versions
16:03:32 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2590
16:03:49 <Cale> Basically, when you do an array update operation x // changeList, x is silently modified to be a pointer to the newly constructed array along with the reverse set of changes
16:04:09 <mcnster> Cale, that pastebin is my code (sorta)
16:04:23 <mm_freak_> yeah…  however, i'll just try out, thanks a lot
16:04:29 <TSC> mcnster: Do you really have length or "lenth"?
16:04:51 <mcnster> TSC, i really have length
16:04:58 <pgavin> dcoutts, for the different extensions in Language.Haskell.Extensions, which one should I use to enable pattern type signatures?
16:05:07 <mcnster> (and width)  :>
16:05:31 <sieni> and "heigth"? ;-)
16:05:46 <mcnster> occassionally breadth
16:05:59 <dcoutts> pgavin: erm, not sure actually
16:07:27 <pgavin> dcoutts, PatternGuards seems closest...
16:09:39 <ddarius> My impression is that the constant overheads of DiffArrays destroy their asymptotic benefits.
16:11:27 <sieni> ddarius: what do you mean?
16:11:38 <mcnster> thanks
16:11:49 <ddarius> sieni: I mean they are ridiculously slow, or at least that's what I hear.
16:12:04 <sorear> sieni: diffarrays are over 200x slower than true mutable arrays, I'm told
16:12:21 <sieni> is that bad implementation or what?
16:12:32 <ddarius> sieni: Largely.
16:12:39 <sorear> It's required for thread safety.
16:12:43 <ddarius> Or again, that's my impression.
16:13:02 <sorear> Just one bit of my general impression that Concurrent Haskell was a mistake...
16:13:56 <ddarius> Not providing thread unsafe alternatives to data structures is a mistake, not every program is threaded.
16:14:43 <wli> No, that's not why.
16:15:05 <wli> It's that locks may already exist that protect the things.
16:15:25 <ddarius> wli: That too. unsafeRead/Write ho!
16:16:13 <ddarius> Didn't the same thing happen to the hash tables?
16:18:17 <sieni> am I asking stupid questions or could one just make all the locking non-operations while compiling single-threaded applications?
16:19:42 <ddarius> sieni: I'm not sure it would be that simple.  The structure of the code may potentially be different than if you didn't have to worry about threading.  But then again, it may often be that simple.
16:22:13 <sieni> and anyway at least on linux, mutexes aren't really _that_ expensive
16:22:49 <sieni> but allocating stuff for the "undo buffer" might be, if not done wisely
16:25:08 <sieni> so when you update, you should update the array, allocate one more node in the end of the "undo buffer" and then update the previous before last to point to this one, so you don't have to touch any older versions
16:25:39 <sieni> I could see 10 times overhead, but 200 times overhead seems excessive
16:28:47 <Tchakkazulu> Hello.
16:29:10 <Tchakkazulu> I'm messing around with zippers a bit, following the wikibooks article. And there's something that I don't quite get.
16:29:23 <Tchakkazulu> In one of my own experimentations.
16:30:26 <Tchakkazulu> I try to define the zipper for Tree a = Tree a [Tree a]
16:30:49 <timthelion> so, I want to make programs, que and showque, que, multiple instances of showque output text about a set of ques, and que changes that info and triggers the showques, to update, how do I do this cross program triggering in haskell?
16:32:05 <Tchakkazulu> So I saw that Zipper (Tree a) = (Context (Tree a), Tree a), and Context (Tree a) = [Thread (Tree a)], where Thread (Tree a) is the "derivative type" of Tree a.
16:32:15 <Tchakkazulu> http://en.wikibooks.org/wiki/Haskell/Zippers (the article, for reference)
16:32:18 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
16:32:41 <shapr> Hm, are nested where allowed?
16:32:47 <mauke> shapr: yes
16:32:53 <ddarius> shapr: Of course
16:33:12 <timthelion> is there a way to make program a have an infinite loop that waits for program b to be called, before it goes around again?
16:33:30 <shapr> Ok, that's not the problem then.
16:33:45 <Tchakkazulu> And so I try to find the derivative type of Tree a.
16:33:54 <kpreid> timthelion: you could use a unix named pipe for that.
16:34:01 <Pseudonym> ?seen int-e
16:34:02 <lambdabot> I saw int-e leaving ##logic, #ghc, #haskell-overflow and #haskell 1d 4h 42m 31s ago, and .
16:34:50 <timthelion> kpreid: ok, that sounds like it would work, given that there is such a thing as a named pipe
16:35:02 <Tchakkazulu> So I define T_a x = a * [x], and say that Tree a = \mu x . T_a x = T_a (Tree a)
16:35:21 <Tchakkazulu> Well... "define" on paper, of course, as none of this is valid Haskell.
16:35:55 <Pseudonym> It should be!
16:35:56 <timthelion> kpreid: so then program b would somehow modify stdout and write to it, and program a would then be triggered by the success of a read?
16:36:02 <kpreid> timthelion: it lives in the filesystem; que writes one byte to trigger showque to wake up and do whatever.
16:36:27 <Tchakkazulu> Then the derivative type would be a * [x]', so we first need to find the derivative type of [x], which I think is 'x'.
16:36:50 * timthelion looks into named pipes
16:37:01 <Saizan> Tchakkazulu: T a = a*L(T a), T'(a) = 1*L(T a) + a*L'(T a)*T'(a) = L(a*L'(T a))*L(T a) ?
16:37:05 <kpreid> timthelion: I dunno what stdout has to do with it, but yes, you write one byte to the pipe to use it as a wakeup message
16:37:07 <Tchakkazulu> Giving a Zipper (Tree a) of ([(a, Tree a)], Tree a)
16:37:19 <mauke> and as you look into named pipes, the named pipe looks back into you
16:37:40 <Tchakkazulu> Saizan: I'll check that, one moment.
16:38:54 <Pseudonym> mauke: That's only if you've installed the uberdaemon.
16:39:58 <kpreid> timthelion: the command 'mkfifo' can be used to make a named pipe from the shell; you can play around with it with cat/tail/etc if you like
16:40:29 <timthelion> will do
16:40:47 <kpreid> timthelion: note that if you don't open it nonblocking, opening for read or write blocks until there's at least one writer or reader (or something like that)
16:41:01 <Tchakkazulu> Saizan: I get L(a*L'(T a)) + L(T a) as final answer. Also, the wikipage derives the T_a x to x, instead of T a to a.
16:41:23 <Tchakkazulu> Oh, no wait. I made a mistake there -_-
16:41:29 <kpreid> this might be good, or not, depending on your app (and ghc's io gimmicks)
16:42:45 <Tchakkazulu> Saizan: I get the same answer now :)
16:43:09 <Saizan> Tchakkazulu: nice :)
16:43:54 <ddarius> Pseudonym: Nice movie on your blog.
16:44:06 <Saizan> Tchakkazulu: i like the final step where you expand T' ad infinitum getting a L
16:44:21 <Pseudonym> ddarius: Don't thank me, I didn't make it.
16:44:33 <ddarius> Pseudonym: Disaster averted.  I didn't thank you.
16:45:43 <Tchakkazulu> Saizan: Yes, that's nice. I initially forgot that the L(T a) stops the list from going on, hence the * instead of the +.
16:46:12 <Tchakkazulu> And according to that logic, L'a = L a * L a.
16:46:21 <Saizan> yup
16:46:54 <Tchakkazulu> And that is the context?
16:47:14 <Tchakkazulu> As in, add a T a, and you have the zipper structure?
16:47:44 <Tchakkazulu> Hmm... I can make more sense out of that than my initial way :)
16:48:50 <Tchakkazulu> Could you explain then what the wikibooks page is doing when it uses d x (T_a x), because I get strange things then.
16:49:00 <Tchakkazulu> T_a x = a * [x]
16:49:02 <Pseudonym> ddaius: Sorry, I meant don't flatter me.
16:49:04 <Saizan> uhm i'd have to read it first
16:49:10 <Tchakkazulu> Ah, okay.
16:49:14 <Tchakkazulu> Thanks anyway :)
16:49:48 <Saizan> but usually i've seen Zipper type a = a (type' a)
16:49:55 <Saizan> err
16:50:05 <Saizan> Zipper type a = a*(type' a)
16:50:40 <Saizan> so to get the context is the derivative itself
16:50:46 <Saizan> s/to get//
16:51:00 * Tchakkazulu nods.
16:51:37 <Saizan> so, data ZipList a = Z { focus :: a, prev :: [a], succ [a]}
16:52:55 <Tchakkazulu> And prev ++ focus : succ == the list it represents.
16:53:29 <mauke> no, newtype ZipList a = ZipList {getZipList :: [a]}
16:53:38 <ddarius> reverse prev ++ focus : succ
16:53:39 <mauke> (ignore me)
16:54:03 <Tchakkazulu> Err... you're right. The prev is in reverse order :)
16:54:40 <Saizan> right, you've the nearest element on top
16:56:30 <Modius> In functional programming theory/circles, where are "list comprehension" vs. "map and filter" in relation to eachother?  Is one considered superior or ghetto?  Are they considered different views on the problem, or part of the same solution space?
16:57:22 <ddarius> list comprehensions are syntactic sugar for "maps and filters"
16:57:29 <mauke> list comprehension is more general
16:57:44 <wli> Oh wow. One of my favorite Chinese restaurants got robbed.
16:57:48 <ddarius> mauke: Than combinators?
16:57:58 <ari> Modius: Different people have different preferences, also list comprehensions are excellent for representing cartesian products which are more difficult to represent beautifully with sequence
16:58:10 <mauke> > [x | c <- "foo", x <- [c, toUpper c]]
16:58:12 <lambdabot>  "fFoOoO"
16:58:20 <mauke> you can't do that with just map/filter
16:58:25 <SamB_XP_> @unlist [x | c <- "foo", x <- [c, toUpper c]]
16:58:26 <lambdabot> No module "[x | c <- "foo", x <- [c, toUpper c]]" loaded
16:58:31 <SamB_XP_> heh
16:58:33 <ddarius> mauke: Hence my "scare" quotes.
16:59:42 <ari> > \xs -> sequence . transpose $ [xs, map toUpper xs]
16:59:43 <lambdabot>  <[Char] -> [[Char]]>
16:59:46 <ari> > \xs -> sequence . transpose $ [xs, map toUpper xs] "foo"
16:59:47 <lambdabot>  Couldn't match expected type `t -> [[a]]'
16:59:56 <ddarius> But just to be certain, Modius you realize that list comprehensions translate straightforwardly into usages of a few combinators.
16:59:57 <ddarius> ?
17:00:43 <ari> Hmm, interesting
17:01:09 <mauke> @undo do c <- "foo"; x <- [c, toUpper c]; return x
17:01:09 <lambdabot> ("foo" >>= \ c -> [c, toUpper c] >>= \ x -> return x)
17:01:12 <EvilTerran> that's \xs -> (sequence . transpose) ([xs, map toUpper xs] "foo"), i think
17:01:26 <ddarius> > (\xs -> sequence . transpose $ [xs, map toUpper xs]) "foo"
17:01:27 <lambdabot>  ["foo","foO","fOo","fOO","Foo","FoO","FOo","FOO"]
17:01:32 <mauke> @. pl undo do c <- "foo"; x <- [c, toUpper c]; return x
17:01:32 <lambdabot> ap (:) (return . toUpper) =<< "foo"
17:02:19 * EvilTerran blinks
17:02:23 <EvilTerran> ?type ap (:)
17:02:25 <lambdabot> forall a. (a -> [a]) -> a -> [a]
17:02:42 <ddarius> \g x -> x : g x
17:02:46 <EvilTerran> > ap (:) return "a"
17:02:48 <lambdabot>  ["a","a"]
17:02:57 <ari> EvilTerran: Something like that... /me shrugs and goes off to do something else
17:03:24 * EvilTerran makes a mental note of (ap (:)) for future pointsfree golf
17:03:35 <Botje> ap (,) is nice.
17:03:41 <mauke> EvilTerran: memorize liftM2, it's more general
17:03:53 <mauke> liftM2 c f g x == f x `c` g x
17:03:56 <Botje> map (ap (,) (**2)) [1..5]
17:03:56 <EvilTerran> i know that one, tho
17:04:04 <mauke> ap is just liftM2 with id
17:04:09 <ddarius> And we readily see from this the definition of ap
17:04:10 <ddarius> @src ap
17:04:10 <lambdabot> ap = liftM2 id
17:04:31 <EvilTerran> it's a bit terser because of it, tho
17:04:48 <mauke> and >>= is the mirror of ap
17:07:14 <Tchakkazulu> ap is the S combinator from SKI calculus?
17:07:22 <mauke> yes
17:07:23 <Tchakkazulu> That's nifty :)
17:07:41 <EvilTerran> and K and I are the obvious
17:07:49 <Tchakkazulu> and pure/return is K.
17:07:57 <ddarius> Yep.
17:07:57 <EvilTerran> or const...
17:07:58 <mauke> @pl \f g x -> (f x) (g x)
17:07:58 <lambdabot> ap
17:08:00 <Tchakkazulu> And I... that's I ;)
17:08:06 <ddarius> ask
17:08:06 <Tchakkazulu> Or id... whatever.
17:08:17 <ddarius> :t ask
17:08:19 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
17:08:29 <Tchakkazulu> Hah! True :)
17:08:32 <ddarius> If m = (r ->) ask :: r -> r
17:09:10 <ddarius> Tchakkazulu: Now look at the conversion of the lambda calculus into the combinatory algebra and compare.
17:09:33 <mauke> :t ap return return
17:09:35 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> a
17:09:41 <EvilTerran> ha!
17:09:56 <mauke> > ap return return 42
17:09:57 <lambdabot>  Add a type signature
17:10:00 <mauke> :(
17:10:06 <ddarius> > ap return return 'a'
17:10:07 <lambdabot>  Add a type signature
17:10:20 <EvilTerran> that might be difficult to add a signature to, given that it's looking for the monad...
17:10:33 <EvilTerran> > ap (return :: a -> Maybe a) return 'a'
17:10:33 <lambdabot>  Couldn't match expected type `a -> b'
17:10:37 <ddarius> It shouldn't be though.
17:10:46 <ddarius> At least I don't think it should be.
17:10:57 <EvilTerran> i'm just guessing that it is, given what \bot said the type was
17:11:08 <Saizan> ?type ap return return 'a'
17:11:10 <lambdabot>     Ambiguous type variable `m' in the constraint:
17:11:10 <lambdabot>       `Monad m' arising from use of `return' at <interactive>:1:10-15
17:11:41 <ddarius> Yes, but it should know that m is (a ->) to get that final type.  Maybe I need to work through it by hand.
17:11:56 <Saizan> there are 2 monads imo
17:12:08 <mauke> > ap return (return :: a -> Maybe a) 42
17:12:13 <lambdabot>  42
17:12:35 <ddarius> Ah, I see. Since return = const
17:12:39 <EvilTerran> egad
17:12:53 <Tchakkazulu> SKK = I
17:12:55 <ddarius> > ap return (return :: a -> StateT Int IO a) 42
17:12:56 <lambdabot>  42
17:13:08 <Tchakkazulu> SK<whatever> = I, even.
17:13:32 <shapr> ChilliX: Hey will ndp code that's both pretty and parallel be in 6.8?
17:13:46 <reffie> http://www.jesusoftheweek.com/art/j2k7-8.jpg
17:13:50 <ddarius> "pretty parallel NDP code"
17:14:00 <shapr> reffie: Hey, that belongs in #haskell-blah
17:14:12 <shapr> ddarius: iirc, you get one or the other right now.
17:14:29 <mauke> > ap return undefined 42
17:14:31 <lambdabot>  42
17:14:37 <EvilTerran> ddarius, is that pretty code, or pretty parallel?
17:14:38 <Tac-Tics2> @src a[
17:14:38 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:14:41 <Tac-Tics2> @src ap
17:14:42 <lambdabot> ap = liftM2 id
17:14:47 <mauke> > fmap fix return 42
17:14:49 <lambdabot>  42
17:15:43 <Tac-Tics2> @index ap
17:15:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
17:15:43 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
17:16:01 <ChilliX> shapr: A lot of the code will be in 6.8, because we develop in the head and not on a branch, but it won't be usable in 6.8, sorry.
17:16:14 <shapr> aww
17:16:26 <ChilliX> We hope that we have the first stuff going by ICFP.
17:16:26 <ddarius> EvilTerran: That's the point
17:16:37 <mauke> fmap fix return is the e^(i*pi)+1 of haskell
17:16:40 <shapr> ChilliX: 6.8.1 maybe?
17:17:01 <EvilTerran> quite
17:17:05 <Botje> @remember mauke fmap fix return is the e^(i*pi)+1 of haskell
17:17:05 <lambdabot> Done.
17:17:23 <ChilliX> shapr: depends on whether GHC HQ allows a major feature addition in a stable branch
17:17:27 <shapr> ok, cool
17:17:38 <EvilTerran> how soon're type functions gonna trickle down into the stable branch?
17:18:06 <ChilliX> the vectorisation code in GHC is about 2.5kLOC so far
17:18:16 <ChilliX> its just a lot of stuff to implement
17:18:36 <ChilliX> EvilTerran: type functions are in 6.8, but not officially supported
17:18:49 * EvilTerran wants to play with them, but i have enough trouble getting "stable" programs to work. the HEAD would probably make my computer spontaneously explode in a ball of hate
17:19:09 <LoganCapaldo> type functions?
17:19:20 <ChilliX> not officially supported means, we do neither promise to fix all bugs on the branch nor that the extensions might not somewhat change in 8.10
17:19:27 <ChilliX> LoganCapaldo: type families
17:19:30 <ddarius> LoganCapaldo: We were running out of room at the value level.
17:19:48 <LoganCapaldo> are they like uber-functors?
17:19:54 <ChilliX> LoganCapaldo: http://haskell.org/haskellwiki/GHC/Type_families
17:19:55 <lambdabot> Title: GHC/Type families - HaskellWiki
17:20:01 <LoganCapaldo> or functor expressions?
17:20:08 <EvilTerran> i look forward to fighting with any limitations of the implementation ;]
17:20:08 <LoganCapaldo> (I just made that up)
17:22:37 <Tac-Tics2> Is there a way in ghc to print out the kind of a type?
17:22:51 <sjanssen> Tac-Tics2: :kind
17:23:17 <mauke> @kind StateT
17:23:22 <Tac-Tics2> I see, I see
17:23:26 <lambdabot> * -> (* -> *) -> * -> *
17:23:44 <ddarius> :k (->)
17:23:46 <lambdabot> ?? -> ? -> *
17:23:55 <Tac-Tics2> hehe
17:23:58 <Tac-Tics2> @kind ([])
17:24:00 <lambdabot> * -> *
17:24:03 <Tac-Tics2> cool!
17:24:42 <Tac-Tics2> Can someone point me to some introductory material on type systems?
17:24:54 <ddarius> @google "introductory material on type systems"
17:24:55 <lambdabot> No Result Found.
17:24:56 <Tac-Tics2> Only in the last few days have I started to realize how complicated Haskell's type sistem is
17:25:11 <ddarius> Worth a try.
17:25:47 <Tac-Tics2> Why use google for Haskell stuff when the kind folks in this channel can point me to the __good__ stuff
17:26:06 <Tac-Tics2> There's so many pdfs saved on my desktop I have still to read that I never would have found through google
17:26:14 * Tchakkazulu goes away.
17:26:17 <Tchakkazulu> Thanks again :)
17:26:18 * EvilTerran has a folder called "papers" for that sort of thing
17:26:34 <Tac-Tics2> EvilTerran: you are a more brilliant man than I
17:26:40 <Tac-Tics2> I should probably do something like that
17:26:50 <mauke> :k 0
17:26:52 <Tac-Tics2> and then have a folder called "read" that I move them too when they're done
17:26:52 <lambdabot> Only unit numeric type pattern is valid
17:27:01 <jfredett> esteban2: did you ever get your question answered?
17:27:07 <EvilTerran> nah, it means i'm not reminded of them whenever i start my computer, so i never read any of 'em
17:27:19 * EvilTerran looks at his bookstack
17:27:32 <jfredett> esteban2: I had to leave, but hopefully Cale was able to help you
17:27:34 <Tac-Tics2> @kind (->)
17:27:36 <lambdabot> ?? -> ? -> *
17:27:39 <Tac-Tics2> weird!
17:27:45 <mauke> @kind 1
17:27:46 <jfredett> not really
17:27:48 <lambdabot> *
17:27:56 <EvilTerran> and i've got 24 real books to read, on top of the PDFs...
17:28:10 <jfredett> it just means that  -> takes two types and returns a type. right?
17:28:15 <sorear> right.
17:28:17 <EvilTerran> why does 1 have a kind, but 0 not?
17:28:24 * ddarius has several folders called "papers"
17:28:24 <Tac-Tics2> are the ?'s in that kind above something like kind variables?
17:28:34 * jfredett has one folder with papers
17:28:41 <ari> :k 2
17:28:43 <EvilTerran> (?) is a type that isn't unboxed
17:28:44 <lambdabot> Only unit numeric type pattern is valid
17:28:47 * jfredett rarely reads much out of it
17:28:56 <EvilTerran> (#) is a type that is unboxed, (*) can be either
17:29:18 * ddarius usually reads stuff into it or in it, rarely out of it.
17:29:35 <ari> @type undefined :: 1
17:29:36 <Pseudonym> Hang on, isn't (*) specifically boxed
17:29:37 <lambdabot> 1 :: GHC.Base.Unit
17:29:37 <EvilTerran> (**) is to (*), what the tyvar (a) is to the tyvar (b)
17:29:56 * Pseudonym has flashbacks of Miranda and has to go lie down
17:30:02 <jfredett> so 1 == ()?
17:30:04 <EvilTerran> Pseudonym, actually, you may be right. i might have (*) and (?) swapped.
17:30:05 <ddarius> Pseudonym: Indeed.
17:30:26 <ddarius> jfredett: 1 ~= () yes.
17:30:36 <jfredett> cool
17:30:43 <jfredett> type theory roxorz.
17:30:45 <EvilTerran> ?type () :: 1
17:30:47 <lambdabot>     Couldn't match expected type `GHC.Base.Unit'
17:30:47 <lambdabot>            against inferred type `()'
17:30:52 <EvilTerran> buu
17:30:55 <Pseudonym> ?type undefined :: 2
17:30:57 <lambdabot> Only unit numeric type pattern is valid
17:31:02 <Pseudonym> ?type undefined :: 0
17:31:04 <lambdabot> Only unit numeric type pattern is valid
17:31:08 <jfredett> ?type x :: 1
17:31:10 <lambdabot> Not in scope: `x'
17:31:17 <Pseudonym> It would make sense to make 0 =~ Void
17:31:20 <Pseudonym> Where: data Void
17:31:26 <ari> > [undefined :: 1, undefined :: ()]
17:31:26 <lambdabot>  Parse error
17:31:34 <jfredett> isn
17:31:42 <jfredett> isn't 0 ~= _|_
17:31:43 <jfredett> ?
17:31:43 <Pseudonym> Probably a bug in Language.Haskell there.
17:31:49 <Pseudonym> jfredett: Kind of.
17:31:52 <EvilTerran> > [undefined :: 1, undefined :: GHC.Base.Unit]
17:31:52 <lambdabot>  Parse error
17:31:53 <ari> @type [undefined :: 1, undefined :: ()]
17:31:55 <lambdabot>     Couldn't match expected type `GHC.Base.Unit'
17:31:55 <lambdabot>            against inferred type `()'
17:31:56 <EvilTerran> ?type [undefined :: 1, undefined :: GHC.Base.Unit]
17:31:58 <lambdabot> 1, undefined :: GHC.Base.Unit] :: [GHC.Base.Unit]
17:31:58 <Pseudonym> Void is the type with no members other than undefined.
17:32:00 <Saizan> _|_ is a value, not a type
17:32:07 <jfredett> oh
17:32:19 <jfredett> so wait
17:32:24 <jfredett> _|_ is a value
17:32:28 <jfredett> that inhabits all types
17:32:37 <jfredett> so the type 0 contains only _|_
17:32:38 <jfredett> ?
17:32:53 <Saizan> (also, types form a semiring only in absence of _|_ afaiu)
17:32:54 <jfredett> that was how I thought it worked
17:33:07 <Pseudonym> jfredett: Technically, in GHC, it inhabits all boxed types.
17:33:23 <jfredett> well- in a type-theoretic sense
17:33:28 <jfredett> less GHC busines
17:33:28 <jfredett> s
17:33:34 <Pseudonym> Yeah.
17:33:55 <Pseudonym> That about sums it up
17:34:21 <Pseudonym> Void is a useful type.
17:34:40 <ddarius> 0# ho!
17:34:41 <Pseudonym> It allows a form of subtyping, by not letting you construct certain constructors.
17:34:55 <jfredett> interesting
17:35:49 <ddarius> jfredett: Haskell 98 does not allow 'data Void;', how would you defined it anyway?
17:36:05 <jfredett> hmm?
17:36:28 <glguy> @users
17:36:28 <lambdabot> Maximum users seen in #haskell: 402, currently: 361 (89.8%), active: 17 (4.7%)
17:36:29 <jfredett> I have no idea- I was just talking about a type called 0, who's sole inhabitant was _|_
17:36:31 <ddarius> jfredett: Declare a data type Void that is only inhabited by bottom.
17:36:40 <jfredett> well,my thought is you dont
17:36:50 <EvilTerran> i guess you need -fglasgow-exts to do it in Haskell. it's still good for type theory.
17:36:50 <ddarius> jfredett: You can, how?
17:36:55 <jfredett> ....
17:37:15 <jfredett> I have no clue
17:37:18 <Pseudonym> Yeah, define -fglasgow-exts, and you have: data Void
17:37:24 <jfredett> i never really came across the need
17:37:44 <jfredett> i didn't know there was going to be a quiz
17:37:48 <jfredett> i would have prepared
17:37:48 <jfredett> :P
17:37:54 <ddarius> data Void = Void !Void
17:38:06 <Pseudonym> OK, this works in H98 too: newtype Void = Void Void
17:38:19 <mauke> fix Void
17:38:52 <LoganCapaldo> Pseudonym, Ack!
17:39:19 <Pseudonym> Unfortunately, fix Void works!
17:39:31 <Pseudonym> So you CAN construct a member of Void there.
17:39:40 <LoganCapaldo> How does it both let you get away with that, and terminate??
17:39:51 <LoganCapaldo> (the newtype, not the fix)
17:39:59 <Pseudonym> No idea!
17:40:38 <LoganCapaldo> Me either!
17:40:50 <LordBrain> i think my brain just fell out
17:41:34 <LoganCapaldo> it sucks that fix Void works
17:41:40 <LordNoBrain> what does this do?
17:41:46 <LordNoBrain> any of this...
17:41:48 <ddarius> How does fix Void work and better than undefined :: Void?
17:42:05 <ddarius> s/and/any
17:42:09 <LoganCapaldo> ddarius, I thought it was generally acknowledge that using undefined was "cheating"?
17:42:41 <EvilTerran> the point is we're trying to construct something with no non-_|_ values, tho, so if fix Void works, we're still sunk
17:42:50 <LordNoBrain> when you say fix Void, what is the definition of Void?
17:42:53 <ddarius> LoganCapaldo: Okay, "How does fix Void work any better than fix id :: Void?"
17:42:53 <LoganCapaldo> for the purposes of using the type system to prove things...
17:42:56 <EvilTerran> does it work for both the strict data _and_ the newtype?
17:43:01 <ddarius> LordNoBrain: The constructor.
17:43:02 <LoganCapaldo> ddarius, point
17:43:11 <LoganCapaldo> I withdraw my objection
17:43:23 <ddarius> EvilTerran: fix Void will only work with a lazy data version.
17:43:36 <LordNoBrain> the constructor for data Void = Void Void ?
17:43:52 <EvilTerran> hm
17:43:53 <ddarius> Working meaning: E `seq` 2 evaluates to 2
17:47:34 <EvilTerran> ddarius, so do the data Void = Void !Void and newtype Void = Void Void ones work for our purposes ,then?
17:48:50 <LoganCapaldo> but we don't want it to work
17:49:09 <EvilTerran> by "work", i mean "can take no value other than _|_"
17:49:44 <Saizan> EvilTerran: yes, fix Void causes a <<loop>>
17:50:02 <EvilTerran> hooray
17:50:06 <Saizan> (compiled)
17:50:17 <Saizan> (for the newtype)
17:51:36 <LoganCapaldo> huzzah
17:51:59 <LoganCapaldo> I'm still surprised it's cool with that though
17:52:42 <LoganCapaldo> well I guess not really
17:53:08 <Saizan> yeah i was a bit shocked when i've seen c2hs use types like newtype Foo = Foo (Ptr Foo)
17:53:37 <LoganCapaldo> Saizan, what the heck is that, void*?
17:54:02 <Saizan> typed :)
17:54:07 <LoganCapaldo> heh
17:54:11 <LoganCapaldo> does kind of make sense
17:54:20 <LoganCapaldo> a void** is a void*
17:54:33 <LoganCapaldo> wow
17:54:38 <LoganCapaldo> haskell++
17:54:48 <LoganCapaldo> @karma haskell
17:54:49 <lambdabot> haskell has a karma of 22
17:54:54 <LoganCapaldo> @karma Haskell
17:54:54 <lambdabot> Haskell has a karma of 22
17:54:56 <LoganCapaldo> ah
17:54:58 <LoganCapaldo> ok
17:58:40 <LoganCapaldo> Mmmm
17:59:09 <LoganCapaldo> newtype M = M (Maybe M)
17:59:36 <LoganCapaldo> only M Nothing works
17:59:41 <LoganCapaldo> oh wait
17:59:42 <LoganCapaldo> no
17:59:47 <LoganCapaldo> M (Just (M Nothing))
18:00:00 <LoganCapaldo> woah
18:00:04 <LoganCapaldo> that's weird
18:00:26 <LoganCapaldo> you can like use newtypes to have place holders
18:00:34 <LoganCapaldo> all structure with no actual values
18:00:48 <LoganCapaldo> it's just the shape
18:02:20 <EvilTerran> fix (M . Just) ?
18:02:34 <LoganCapaldo> what's with you and the fix?
18:02:35 <LoganCapaldo> :)
18:02:45 <EvilTerran> that looks like an arcane way of defining the peano numbers to me
18:02:56 <EvilTerran> fix is faster than typing let...in...
18:03:00 <LoganCapaldo> newtype E = E (Either E E)
18:03:07 <LoganCapaldo> so weird...
18:03:12 <EvilTerran> O.o
18:03:17 <LoganCapaldo> Oh
18:03:30 <LoganCapaldo> I just figured out what it reminded me of!
18:03:38 <LoganCapaldo> using undefined as a placeholder
18:03:56 <LoganCapaldo> this gives you the ability to do something similar at the type level
18:04:38 <EvilTerran> what does? Void?
18:05:07 <LoganCapaldo> this newtype T = F T pattern
18:05:20 <LoganCapaldo> err newtype T = T (F T)
18:07:25 <EvilTerran> ah
18:07:40 <LoganCapaldo> newtype E a = E (Either a E) this seems interesting too
18:08:02 <LoganCapaldo> I dunno what you would use it for
18:08:19 <LoganCapaldo> it's almost, but not quite Maybe
18:09:18 <Saizan> newtype Mu t = Mu (t (Mu t))
18:09:39 <ihope> You and you fancy type-level fix-point operators...
18:09:56 <LoganCapaldo> Oh back to newtype M = M (Maybe M), M (Just (M Nothing)) and M (Just (M (Just (M Nothing)))) have the same type...
18:10:03 <LoganCapaldo> weird
18:10:10 <LoganCapaldo> this is fun
18:10:28 <ihope> Mu Maybe! :-)
18:10:34 <LoganCapaldo> but it seems like void* is the only real use to me
18:11:15 <ihope> So, suppose I have an expression along the lines of let val = expr in func val val. Will any part of expr ever be evaluated more than once?
18:11:53 <shachaf> It shouldn't be, I think.
18:12:07 <ihope> I mean, if expr is 2 + 2 :: Int or something, I'm guessing it'd be more efficient to just inline it...
18:12:07 <LoganCapaldo> -ddump-simpl?
18:12:18 <__nasa__> LoganCapaldo: You can use a similar construct (\x -> x x) to calculate fixed points of functions.
18:12:18 <LoganCapaldo> is that the right option?
18:12:40 <ddarius> newtype E = E (Either E E) ~= Stream Bool
18:12:40 <LoganCapaldo> __nasa__, isn't that the "U" combinator?
18:13:00 <LoganCapaldo> ddarius, ah
18:13:08 <LoganCapaldo> I felt like there was something there
18:13:41 <ihope> ~=? Is that some new extension?
18:13:44 <LoganCapaldo> just need an unfoldr for E
18:14:00 <EvilTerran> ihope, i think all current implementations would only evaluate expr once, but it's up to the implementation
18:14:01 <LoganCapaldo> what's the long fancy -morphism name for unfoldr?
18:14:14 <ddarius> anamorphism
18:14:42 <LoganCapaldo> that's not that long
18:14:46 <LoganCapaldo> heh
18:14:50 <__nasa__> hmm, I don't really remember (this was a while ago, and not in Haskell, actually), but very possibly. Looking on wikipedia, it is the Y combinator.
18:15:01 <__nasa__> @wiki Y combinator
18:15:01 <lambdabot> http://www.haskell.org/haskellwiki/Y_combinator
18:15:21 <__nasa__> @google Y combinator
18:15:26 <lambdabot> http://www.ycombinator.com/
18:15:26 <lambdabot> Title: Y Combinator
18:15:35 <EvilTerran> um... i don't think (\x -> x x) is valid haskell
18:15:36 <__nasa__> (probably the compaky)
18:15:45 <LoganCapaldo> http://okmij.org/ftp/Computation/fixed-point-combinators.html
18:15:46 <lambdabot> Title: Many faces of the fixed-point combinator
18:15:47 <__nasa__> EvilTerran: no it is not
18:16:01 <LoganCapaldo> it's valid haskell it just doesn't type check no
18:16:04 <ari> :t \x -> x x
18:16:06 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
18:16:07 <lambdabot>     Probable cause: `x' is applied to too many arguments
18:16:07 <__nasa__> it is essentially what you are doing and is really concise, however.
18:16:19 <Saizan> __nasa__: the fixed-point combinator in haskell is called fix
18:16:22 <__nasa__> It works in Scheme, IIRC.
18:16:25 <__nasa__> ooh.
18:16:29 <EvilTerran> @src fix
18:16:30 <lambdabot> fix f = let x = f x in x
18:16:30 <ari> > fix (:[])
18:16:31 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
18:16:31 <lambdabot>       Expected...
18:16:33 <__nasa__> fix (sqrt)
18:16:39 * ari liek infinite types :(
18:16:43 <EvilTerran> > fix (1:)
18:16:43 <Saizan> > fix (1:)
18:16:43 <LoganCapaldo> > fix (1:)
18:16:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:16:45 <ddarius> :t \(x :: forall a. a -> a) -> x x
18:16:48 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
18:16:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:16:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:16:49 <EvilTerran> oh wow
18:16:51 <Saizan> :D
18:16:52 <__nasa__> >fix sqrt
18:17:03 <LoganCapaldo> space
18:17:20 <LoganCapaldo> > fix sqrt
18:17:21 <lambdabot>  Exception: <<loop>>
18:17:27 <__nasa__> oh
18:17:35 <ari> > fix Data.Set.singleton
18:17:36 <lambdabot>      Occurs check: cannot construct the infinite type:
18:17:36 <lambdabot>       a = Data.Set.Set...
18:17:49 <EvilTerran> > fix (const 1)
18:17:50 <lambdabot>  1
18:18:06 <Olathe> > fix my car
18:18:06 <lambdabot>   Not in scope: `car'
18:18:15 <__nasa__> > fix (\x -> case x of Nothing -> 0; Just i -> i;)
18:18:16 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
18:18:16 <lambdabot>       Expe...
18:18:19 <Saizan> > fix ((1:) . map (+1))
18:18:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:18:35 <__nasa__> :t fix
18:18:38 <lambdabot> forall a. (a -> a) -> a
18:19:11 <Saizan> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
18:19:13 <lambdabot>  120
18:19:13 <__nasa__> > fix (+1)
18:19:15 <lambdabot>  Exception: <<loop>>
18:20:01 <malsyned> what's the difference between GHC.Int.Int32 and GHC.Word.Word32?
18:20:05 <sorear> __nasa__: fix is not definable in the subset of Haskell generated by lambda and application because fix id diverges and no expression of the STLC diverges (weak normalization theorem)
18:20:10 <sorear> malsyned: Word32 is unsigned
18:20:25 <sorear> __nasa__: however, it's quite possible with data types or let
18:20:26 <sorear> @src fix
18:20:26 <lambdabot> fix f = let x = f x in x
18:20:31 <LoganCapaldo> > fix (\fib n -> if n == 0 or n == 1 then 1 else fib (n - 1) + fib (n - 2)) 8
18:20:33 <ddarius> > ((minBound :: Word32, maxBound :: Word32), (minBound :: Int32, maxBound :: Int32))
18:20:35 <lambdabot>      precedence parsing error
18:20:35 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
18:20:36 <lambdabot>  ((0,4294967295),(-2147483648,2147483647))
18:20:37 <__nasa__> ok, interesting.
18:20:57 <LoganCapaldo> > fix (\fib n -> if (n == 0) or (n == 1) then 1 else fib (n - 1) + fib (n - 2)) 8
18:20:58 <lambdabot>  Couldn't match expected type `t -> t1 -> Bool'
18:21:02 <malsyned> sorear: thx
18:21:10 <LoganCapaldo> :(
18:21:12 <Saizan> LoganCapaldo: || /= or
18:21:15 <ddarius> :t or
18:21:17 <LoganCapaldo> > fix (\fib n -> if (n == 0) || (n == 1) then 1 else fib (n - 1) + fib (n - 2)) 8
18:21:18 <lambdabot>  34
18:21:19 <lambdabot> [Bool] -> Bool
18:21:19 <LoganCapaldo> doh
18:21:20 <__nasa__> > fix (\x -> x) -- diverges
18:21:21 <lambdabot>  Exception: <<loop>>
18:21:25 <LoganCapaldo> I'm such a doofus
18:21:34 <LoganCapaldo> too much ruby
18:21:44 <ddarius> Twenty lashes.
18:22:01 <shachaf> LoganCapaldo: Ruby has || too. :-)
18:22:07 <__nasa__> Just the opposite -- too much Haskell (what?! you can't curry in Python?!)
18:22:11 <LoganCapaldo> yes but or reads better
18:22:16 <ihope> Sure you can curry in Python.
18:22:21 <ihope> You just don't.
18:22:21 <shachaf> Not for me, I think.
18:22:31 <ihope> Just like you don't write func(arg1,arg2) in Haskell...
18:22:42 <__nasa__> ihope: it isn't as nice as Haskell, is it?
18:22:50 <Saizan> __nasa__: at least in python you've first class functions, try java.. sob
18:22:55 <ddarius> __nasa__: It's not the "default"
18:23:00 <__nasa__> oh, ok.
18:23:05 <LoganCapaldo> > let func = uncurry (+) in func(1, 2)
18:23:06 <lambdabot>  3
18:23:20 <ihope> First-class functions in Java can be done with a functor interface. :-P
18:23:44 <ihope> s.call(i).call(i).call(s.call(i).call(i))
18:24:10 <LoganCapaldo> you forgot the .Run() at the end :)
18:25:10 <__nasa__> I was actually doing to HOFs in C. It is pretty painful, but I just passed stacks in and out for pseudo-polymorphism.
18:25:23 <__nasa__> (or at least variable number of args)
18:29:23 <EvilTerran> LoganCapaldo, make that .RunAwayScreaming() ;p
18:40:08 <__nasa__> I had a question about a recursive function with return type IO [a] (call it f). Is this possible? I always found that I was trying to have the last line be something like "return val:f newargs".
18:40:34 <LoganCapaldo> @type sequence
18:40:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:40:42 <EvilTerran> it's possible, yes
18:40:49 <ari> __nasa__: rest <- f newargs; return val:rest
18:40:49 <EvilTerran> @src mapM
18:40:50 <lambdabot> mapM f as = sequence (map f as)
18:40:57 <EvilTerran> @src sequence
18:40:57 <lambdabot> sequence ms = foldr k (return []) ms
18:40:58 <lambdabot>     where
18:40:58 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:41:03 <__nasa__> ari: that is what I did (even used rest :-))
18:41:03 <EvilTerran> god damn. ignore that.
18:41:09 <EvilTerran> sequence [] = []
18:41:23 <EvilTerran> sequence (m:ms) = do x <- m; xs <- sequence ms; return (x:xs)
18:41:39 <EvilTerran> or, if you prefer, sequence (m:ms) = liftM2 (:) m ms
18:41:55 <__nasa__> ok, that makes sense.
18:42:02 <EvilTerran> liftM2 (:) m (sequence ms), rather
18:42:36 <EvilTerran> maybe you want "liftM (val:) (f newargs)" rather than "return val:f newargs"
18:42:54 <__nasa__> so I would change that to sequence (return val) (f newargs), no?
18:43:10 <__nasa__> yeah, that works.
18:43:13 <EvilTerran> or, as ari suggested, pull the value out of the recursive call with <-, and return (val:that)
18:43:42 <__nasa__> I was doing that, but I was worried about it ruining the lazy eval. or does that not apply with IO monads?
18:43:43 <ddarius> liftM (val:)
18:43:48 <EvilTerran> that's probably easier on the eyes, albeit less verbose
18:43:53 <EvilTerran> *more verbose
18:44:07 <EvilTerran> monads aren't brilliant with laziness in any case
18:44:28 <__nasa__> Yeah, I figured that one out the hard way...
18:44:46 <EvilTerran> when you bind the result of, say, sequence, the entire list has to be evaluated, i think
18:45:01 <EvilTerran> kinda.
18:45:12 <__nasa__> ok...
18:45:47 <EvilTerran> think of sequence [m0, m1, ..., mN] as do { x0 <- m0; x1 <- m1; ...; xN <- mN; return [x0, x1, ..., xN] }
18:46:08 <__nasa__> ok, that really helps. Thanks!
18:46:38 <ddarius> > head $ sequence $ repeat [1,2]
18:46:40 <lambdabot>  Exception: <<loop>>
18:47:05 <EvilRanter> huh
18:47:07 <__nasa__> basically, return the value of every element in IO's case.
18:47:22 <EvilTerran> what did I miss?
18:47:35 <__nasa__> nothing.
18:49:06 <EvilTerran> okay
18:49:51 <__nasa__> and sequence_ is the same but just returns the last value in the list, right? (evaluating in order)
18:50:31 <LoganCapaldo> it just doens't return any value
18:50:37 <LoganCapaldo> it returns ()
18:50:41 <LoganCapaldo> @type sequence_
18:50:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:50:44 <__nasa__> :t sequence_
18:50:47 <__nasa__> oh
18:50:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:51:12 <LoganCapaldo> It's a bit like the difference between >>= and >>
18:51:17 <LoganCapaldo> @src sequence_
18:51:17 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
18:51:18 <__nasa__> yeah.
18:51:39 <__nasa__> @src sequence
18:51:40 <lambdabot> sequence ms = foldr k (return []) ms
18:51:40 <lambdabot>     where
18:51:40 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:53:01 <LoganCapaldo> @type \ms -> sequence ms >> return () -- lame version of sequence_ :)
18:53:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:53:39 <__nasa__> so what happens if a value is undefined?
18:53:51 <__nasa__> (in sequence_, original)
18:53:58 <LoganCapaldo> ?
18:54:19 <LoganCapaldo> > sequence_ [ Just 1, undefined, Just 2]
18:54:22 <__nasa__> as in (if this is possible), a function returns IO bottom.
18:54:23 <lambdabot>  Undefined
18:54:31 <__nasa__> ok.
18:54:59 <LoganCapaldo> > sequence_ [ put 1, undefined, put 2]
18:55:00 <lambdabot>   add an instance declaration for (Show (m ()))
18:55:08 <LoganCapaldo> @ty put
18:55:10 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
18:55:23 <LoganCapaldo> oh interesting
18:55:37 <__nasa__> > sequence_ [ putStrLn "hi", undefined, putStrLn "no hi!"]
18:55:38 <lambdabot>  <IO ()>
18:55:39 <LoganCapaldo> > runState $ sequence_ [ put 1, undefined, put 2]
18:55:40 <lambdabot>  <Integer -> ((),Integer)>
18:55:47 <__nasa__> strange...
18:55:53 <LoganCapaldo> > runState ( sequence_ [ put 1, undefined, put 2] ) 0
18:55:55 <lambdabot>  ((),2)
18:55:59 <LoganCapaldo> see
18:56:05 <LoganCapaldo> you can get away with it sometimes
18:56:22 <__nasa__> but I shouldn't count on it.
18:56:51 <LoganCapaldo> depends on what you mean by "count on it"
18:57:00 <LoganCapaldo> you don't always want to get away with it
18:57:03 <ddarius> You can always get away with return undefined >> m = m
18:58:01 <LoganCapaldo> > runState ( sequence_ [ put 1, put 2, undefined] ) 0
18:58:03 <lambdabot>  Undefined
18:58:13 <LoganCapaldo> > runState ( sequence_ [ undefined, put 1, put 2] ) 0
18:58:14 <lambdabot>  ((),2)
18:58:33 <LoganCapaldo> I love undefined
18:58:39 <__nasa__> > runState ( sequence_ [ put 1, put 2] ) 0
18:58:41 <lambdabot>  ((),2)
18:58:42 <LoganCapaldo> It's like a landmine
18:58:49 <Tac-Tics> > undefined
18:58:50 <lambdabot>  Undefined
18:58:53 <LoganCapaldo> don't step on it, and it won't explode
18:59:01 <__nasa__> > sequence_ [ undefined, put 1, put 2]
18:59:02 <lambdabot>   add an instance declaration for (Show (m ()))
18:59:14 <Tac-Tics> hehe, "undefined" evaludates to "Undefined" with a capital U
18:59:25 <__nasa__> > Undefinet
18:59:26 <lambdabot>   Not in scope: data constructor `Undefinet'
18:59:31 <__nasa__> > Undefined
18:59:32 <lambdabot>   Not in scope: data constructor `Undefined'
18:59:34 <newsham> http://research.sun.com/spotlight/2007/2007-08-13_transactional_memory.html
18:59:37 <lambdabot> Title: Transactional Memory, http://tinyurl.com/2c3yw4
18:59:37 <Tac-Tics> > error "Undefined"
18:59:39 <lambdabot>  Exception: Undefined
18:59:48 <LoganCapaldo> @src undefined
18:59:48 <lambdabot> undefined =  error "Prelude.undefined"
19:00:00 <Tac-Tics> > error "Your program is hating you"
19:00:01 <lambdabot>  Exception: Your program is hating you
19:00:04 <__nasa__> yeah, STM is sweet.
19:00:23 <LoganCapaldo> > error "I can make lambdabot say anything"
19:00:24 <lambdabot>  Exception: I can make lambdabot say anything
19:00:25 <newsham> sun is talking hardware TM and hybrid hardware/software TM
19:00:31 <__nasa__> error is the coolest function ever IMO
19:00:35 <__nasa__> :t error
19:00:35 <LoganCapaldo> > error "al work sir!"
19:00:37 <lambdabot>  Exception: al work sir!
19:00:38 <lambdabot> forall a. [Char] -> a
19:01:22 <LoganCapaldo> hmm
19:01:32 <LoganCapaldo> theres gotta be a joke in there somewhere
19:02:27 <LoganCapaldo> @type read
19:02:28 <newsham> ?elite lambdabot already says lots of stuff
19:02:29 <lambdabot> forall a. (Read a) => String -> a
19:02:29 <lambdabot> |4M8dab0+ 41REaDy $aY$ Lo+z0rz OF 57uphF
19:02:38 <Tac-Tics> > error "Build more pylons"
19:02:39 <lambdabot>  Exception: Build more pylons
19:02:57 <LoganCapaldo> > error "For Aire! I mean, Nazzul.:
19:02:57 <lambdabot>  Improperly terminated string
19:03:01 <LoganCapaldo> > error "For Aire! I mean, Nazzul."
19:03:03 <lambdabot>  Exception: For Aire! I mean, Nazzul.
19:03:19 <LoganCapaldo> > error "Need a light?"
19:03:20 <lambdabot>  Exception: Need a light?
19:03:27 <Tac-Tics> > "Starcraft II is coming"
19:03:28 <newsham> > error "hello wor#1k#$,df)#MF021213.asdfm2#$!#$!#$a"
19:03:29 <lambdabot>  Unbalanced parenthesis
19:03:29 <lambdabot>  "Starcraft II is coming"
19:03:43 <FMota> > error "Stop abusing me."
19:03:44 <__nasa__> > error (show error "show")
19:03:44 <lambdabot>  Exception: Stop abusing me.
19:03:45 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
19:03:56 <__nasa__> :t error
19:03:57 <ddarius> > fix error
19:03:58 <lambdabot> forall a. [Char] -> a
19:03:59 <lambdabot>  Exception: <<loop>>
19:04:07 <thoughtpolice> > error "I thought you loved me!"
19:04:08 <lambdabot>  Exception: I thought you loved me!
19:04:09 <LoganCapaldo> I love that one
19:04:12 <LoganCapaldo> fix error
19:04:21 <__nasa__> > error (show (error "show"))
19:04:23 <lambdabot>  Exception: show
19:04:31 <__nasa__> > fix error
19:04:31 <FMota> error "The Sequel"
19:04:32 <lambdabot>  Exception: <<loop>>
19:04:37 <newsham> > error "Excep Exc Ex E"
19:04:38 <FMota> > error "The Sequel"
19:04:39 <lambdabot>  Exception: Excep Exc Ex E
19:04:40 <lambdabot>  Exception: The Sequel
19:04:48 <__nasa__> :-)
19:05:04 <LoganCapaldo> > error "Insert Stacktrace here."
19:05:05 <lambdabot>  Exception: Insert Stacktrace here.
19:05:07 <__nasa__> > error (show (error "show")) show
19:05:08 * LoganCapaldo ducks
19:05:09 <lambdabot>  Exception: show
19:05:29 <__nasa__> > error (shows (error "show") (error "show"))
19:05:31 <lambdabot>  Exception: show
19:05:34 <thoughtpolice> > error "going under 55mph, have a nice death"
19:05:36 <lambdabot>  Exception: going under 55mph, have a nice death
19:05:56 <FMota> that's enough
19:05:57 <FMota> :/
19:05:59 <thoughtpolice> on a completely unrelated note Speed was pretty lame.
19:06:12 <LoganCapaldo> Speed was awesome
19:06:14 <newsham> http://jeffr-tech.livejournal.com/13462.html
19:06:15 <lambdabot> Title: jeffr_tech: http://research.sun.com/spotlight/2007/2
19:06:31 <LoganCapaldo> Denis Hopper is the best King Koopa ever
19:06:35 <ddarius> speed's great! *twitch*
19:08:01 <FMota> Is Denis Hopper related to Grace Hopper?
19:09:00 <thoughtpolice> LoganCapaldo: when they come out with "Speed 3: Comet of DOOM" I might change my mind on the whole matter.
19:09:18 <thoughtpolice> that would also probably be the best title ever.
19:09:25 <__nasa__> newsham: Interesting. It would seem that with HyTM, it would be pretty easy to have to have some transactional hardware routines that eliminates (3).
19:09:38 <__nasa__> s/eliminates/eliminate
19:09:39 <LoganCapaldo> I thought there was a speed 3...
19:09:45 <LoganCapaldo> or did I imagine that
19:09:47 <__nasa__> just came out.
19:10:09 <__nasa__> (I think. No, that was Rush Hour 3. Doh!)
19:10:34 <LoganCapaldo> nope
19:10:37 <LoganCapaldo> no speed 3
19:10:47 <LoganCapaldo> must have been a family guy episode
19:10:51 <LoganCapaldo> oh yeah
19:10:54 <LoganCapaldo> with the iceberg
19:11:03 <__nasa__> http://www.starpulse.com/news/index.php/2006/03/17/speed_3_for_keanu_reeves_aamp_sandra_bul
19:11:10 <lambdabot> Title: 'Speed 3' for Keanu Reeves & Sandra Bullock? - Starpulse News Blog, http://tinyurl.com/ynvbae
19:11:28 <LoganCapaldo> "If this iceberg drops below 3 inches a year, we're dead" or some such
19:11:38 <newsham> nasa: sounds like he wants to mix side effects with his memory transactions
19:11:45 <mudge> hi guys
19:11:45 <newsham> if he used haskell he would know better ;-)
19:12:25 <LoganCapaldo> I demand more side effects!
19:12:32 <LoganCapaldo> everything as a sideeffect!
19:12:43 <LoganCapaldo> the anti-haskell
19:12:49 <newsham> some drugs have nice side effects
19:12:59 <mudge> what's the opposite of a side effect?
19:13:04 <__nasa__> yeah, newsham. There is that problem.
19:13:06 <newsham> and drug use leads to creation of languages like perl
19:13:22 <LoganCapaldo> think perl was drug induced?
19:13:28 <LoganCapaldo> I dunno
19:13:29 <dons> ?users
19:13:29 <lambdabot> Maximum users seen in #haskell: 402, currently: 362 (90.0%), active: 11 (3.0%)
19:13:39 <__nasa__> Haskell would really work with STM on a large scale.
19:13:50 <mudge> dons: how's xmonad?
19:13:56 <__nasa__> (if people embrace it, that is...)
19:13:59 <newsham> there are two things larry wall is known for, and the other is drug use
19:14:24 <mudge> newsham: what's the other thing he is known for?
19:14:43 <dons> mudge: yummy
19:14:58 <__nasa__> http://xkcd.com/312/
19:14:59 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
19:15:02 <mudge> dons: sounds like you are having fun
19:15:25 <mudge> dons: I thought it was really neat the Simon Peyton Jones used xmonads for his videos
19:15:48 <mudge> dons: do you know spj?
19:15:53 <newsham> thats not a close paren, its a smiley, nasa.
19:16:06 <dons> mudge: yeah, i do.
19:16:12 <newsham> if you look at the universe sideways it makes sense
19:16:18 <__nasa__> oh
19:16:25 <dons> we worked with him to get things organised for the talk, and it seemed to go very well
19:16:29 <sioraiocht> LoganCapaldo: worse, perl was linguistics induced
19:16:36 <__nasa__> I guess.
19:17:01 <mudge> dons: oh wow,  that's cool
19:17:03 <sorear> mudge: FTR, it's Peyton-Jones.  If you insist on using his middle name, it's Lester not Peyton.
19:17:10 <__nasa__> Anyways, this isn't nearly as good as the other perl-lisp one.
19:17:33 <mudge> sorear: what?
19:17:51 <dons> sorear is the hyphen police today
19:17:54 <newsham> (actually not sure about wall drug use statement, i thought it was true but i dont see anything on google backing it up)
19:18:20 <newsham> so-rear
19:18:22 <sorear> mudge: Simon Peyton Jones makes it sound like a first middle and last name
19:18:33 <mudge> sorear:  oh, really,   Lester is his middle name?
19:18:41 <sorear> mudge: it's actually first:Simon middle:Lester last:Peyton-Jones
19:18:42 <mudge> sorear: I thought it was his first, middle, last name
19:18:53 <ddarius> sorear: Fix your ears then.
19:18:54 <mudge> sorear: oh wow, neat,  thanks
19:19:09 <newsham> I think everyone should be limited to one last name
19:19:13 <newsham> two is just getting greedy
19:19:29 <mudge> newsham: yea, it should be illegal or something to have more
19:19:39 <newsham> unless you borrow madonna or prince's
19:20:16 <Chris> perhaps someone should email him and let him know he's spelled his name wrong on his homepage.
19:20:19 <Lemmih> I think the hyphen is just syntactic sugar.
19:20:26 <newsham> ?karma+ chris
19:20:27 <lambdabot> chris's karma raised to 1.
19:20:53 <__nasa__> \me is sad to be opressed (I am hyphenated).
19:21:27 <newsham> nasa: how did that happen?
19:21:37 <__nasa__> ?
19:21:49 <newsham> how did your last name come to be hyphenated
19:21:52 <mudge> I didn't know lambdabot gave out karma
19:21:56 <__nasa__> oh, parents.
19:22:00 <mudge> ?karma + mudge
19:22:01 <lambdabot> + has a karma of 8
19:22:09 <mudge> ?karma+ mudge
19:22:09 <lambdabot> You can't change your own karma, silly.
19:22:09 <ddarius> Go +!
19:22:15 <mudge> damn
19:22:34 <mudge> ?karma dons
19:22:34 <lambdabot> dons has a karma of 122
19:22:37 <mudge> damn
19:22:39 <__nasa__> wow!
19:22:41 <mudge> how'd he get so much?
19:22:43 <newsham> ?karma+ dons
19:22:43 <lambdabot> dons's karma raised to 123.
19:22:47 <__nasa__> well, he deserves it...
19:22:52 <mudge> yea, he does
19:22:55 <newsham> thats just for having such a high karma
19:22:58 <FMota> ?karma FMota
19:22:59 <lambdabot> You have a karma of 0
19:23:01 <FMota> :)
19:23:02 <ddarius> @karma audreyt
19:23:02 <lambdabot> audreyt has a karma of 111
19:23:06 <ddarius> @karma lwall
19:23:07 <lambdabot> lwall has a karma of 43
19:23:15 <__nasa__> ?karma- /me
19:23:16 * lambdabot 's karma lowered to -1.
19:23:18 <mudge> ?karma+5
19:23:19 <lambdabot> usage @karma(+|-) nick
19:23:25 <__nasa__> oops, sorry!
19:23:26 <mudge> ?karma+5 FMota
19:23:26 <lambdabot> FMota's karma raised to 1.
19:23:32 <FMota> :o
19:23:36 <FMota> why ty :o
19:23:48 <mudge> welcome
19:23:51 <newsham> ?karma- /quit
19:23:51 <lambdabot> /quit's karma lowered to -1.
19:24:01 <mudge> wonder if there are more ways to get karma from lambdabot
19:24:08 <__nasa__> somebody save lambdabot! I lowered it's karma...
19:24:14 <mudge> @quote mudge
19:24:14 <lambdabot> mudge says: I like big butts and can not lie
19:24:15 <__nasa__> s/it's/its
19:24:40 <sjanssen> __nasa__: no, you lowered "/me"'s karma
19:24:41 <newsham> ?karma- ?karma-
19:24:42 <lambdabot> ?karma-'s karma lowered to -1.
19:25:04 <__nasa__> did I? It says "lambdabot's karma lowered to -1.
19:25:05 <mudge> newsham: what do you do with haskell?
19:25:15 <__nasa__> ?karma+ lambdabot
19:25:15 <lambdabot> lambdabot's karma raised to 44.
19:25:15 <newsham> mudge: goof around mostly
19:25:28 <__nasa__> oh, it prints as lambdabot...
19:25:35 <__nasa__> ?karma+ /me
19:25:36 * lambdabot 's karma raised to 0.
19:25:42 <mudge> newsham: okay, what kind of goof projects or whatever?
19:26:17 <newsham> web server, fuzzing tools, small examples, ...
19:26:32 <newsham> nothing super exciting :(
19:26:39 <mudge> newsham: that's awesome,  I really want to write a webserver in haskell
19:26:58 <mudge> how do you write a webserver in haskell,   i don't know how to write a webserver in any language
19:27:16 <newsham> http://www.haskell.org/~simonmar/papers/web-server.ps.gz
19:27:37 <newsham> simon can answer better than I can :)
19:27:56 <newsham> mudge: http://www.thenewsh.com/%7Ehws/
19:28:09 <lambdabot> Title: HWS - Haskell Web Server
19:28:09 <reffie> http://people.freebsd.org/~ssouhlal/stuff/rephttpd-0.4.hs this is better
19:28:19 * reffie actually uses it
19:28:44 <newsham> reffie: i actually use HWS.
19:28:44 <__nasa__> I liked the Haskell OS myself. Brilliant idea to have different IO monads for different IO devices...
19:29:00 <reffie> newsham doesHWS do cgi?
19:29:19 <newsham> not the stock version.  there's a plugin version that can do cgi but i wasnt very impressed by the code and I dont run it
19:29:28 <reffie> ah
19:29:37 <reffie> i needed cgi, so i just wrote my own server
19:29:42 <mudge> newsham, reffie,  sweet stuff!
19:29:48 <newsham> I dont care about cgis, but i would like an app server for some things..  and there's HAppS for that...
19:30:28 <newsham> where is rephttpd running?
19:30:38 <reffie> liarpedia.org
19:33:02 <LoganCapaldo> who came up with newtype Mu t = Mu (t (Mu t)) ?
19:33:15 <ddarius> LoganCapaldo: Bunches of people.
19:33:20 <mudge> this is the whole web server? http://people.freebsd.org/~ssouhlal/stuff/rephttpd-0.4.hs
19:33:21 <chessguy> what in the world is liarpedia.org?
19:33:23 <LoganCapaldo> I mean just now
19:33:24 <reffie> mudge yes
19:33:26 <mudge> that's not a lot of lines of code
19:33:30 <LoganCapaldo> who said it in the channel
19:33:33 <reffie> chessguy try it :P
19:33:41 <LoganCapaldo> I'm trying to decide who to direct this thought at :)
19:33:43 <chessguy> reffie, i'm on it, but i don't get it
19:33:54 <reffie> http://liarpedia.org/wiki.cgi/Haskell
19:33:56 <lambdabot> Title: Haskell - Lies, Damn Lies and Wikipedia
19:34:01 <__nasa__> LoganCapaldo: my buffer ran out :-(
19:34:18 * LoganCapaldo directs it at everyone
19:34:22 <reffie> mudge it doesn't support the whole http spec
19:34:30 <reffie> just the parts i need :P
19:34:45 <hpaste>  LoganCapaldo pasted "Does this idea make sense?" at http://hpaste.org/2591
19:34:47 <mudge> cool
19:35:03 <reffie> Haskell is a lamp made usually of clay, with wick made of cotton and dipped in ghee or vegetable oils. Clay Haskells are temporary and are used for special occasions, while Haskells made of brass are permanent fixtures in homes and temples.
19:35:08 <mudge> any other advice on writing a webserver in haskell,  specially information that describes how a webserver works
19:35:26 <mudge> wow
19:35:31 <jbalint> wow
19:35:34 <reffie> mudge have you ever wrote any network code?
19:35:42 <reffie> written
19:35:43 <newsham> ?google rfc2616
19:35:52 <lambdabot> http://www.faqs.org/rfcs/rfc2616.html
19:35:52 <lambdabot> Title: RFC 2616 (rfc2616) - Hypertext Transfer Protocol -- HTTP/1.1
19:36:05 <mudge> reffie: I've written a little web crawler in python
19:36:25 <reffie> mudge ok, so you have some ideas about how http works
19:36:37 <mudge> i am familiar with http requests and response,  yes
19:36:41 <mudge> headers
19:36:45 <ddarius> LoganCapaldo: I don't understand the question or the comment in the source.
19:36:45 <newsham> ?google rfc2396
19:36:48 <lambdabot> http://www.ietf.org/rfc/rfc2396.txt
19:36:55 <reffie> then just make a program that parses the requests and provides responses :P
19:37:08 <__nasa__> > newtype Mu t = Mu (t (Mu t)); Mu []
19:37:09 <lambdabot>  Parse error
19:37:22 <mudge> but how does the outside world access the webserver?
19:37:41 <FMota> All summer long, as long as there is good weather, there are boating trips to Haskell. People come not only to see the cliff's imposing size, but also the famous bird colony found there. The colony is counted as the most important in the archipelago.
19:37:46 <newsham> telnet www.google.com 80; GET / HTTP/1.0<enter><enter>
19:37:55 <LoganCapaldo> ddarius, if you can write a function f, such that f :: Mu t does that "prove" that t is "isomorphic" to Maybe
19:38:11 <newsham> mudge: for more details see rfc2616 mentioned above
19:38:14 <LoganCapaldo> Iv eput quotes around things I mean in the loosest, laymanniest sense of the words
19:38:51 <mudge> newsham,  k thanks
19:39:00 <mudge> newsham, that seems to cover http
19:39:03 <mudge> i know http
19:39:15 <newsham> so then you know web servers
19:39:22 <mudge> okay
19:39:31 <newsham> [16:36] < mudge> but how does the outside world access the webserver?
19:39:33 <newsham> http.
19:39:34 <ddarius> LoganCapaldo: No.
19:39:58 <mudge> i guess I don't know how to make the webserver listen on a port,
19:40:03 <LoganCapaldo> ddarius, you don't happen to have a simple counterexample do you?
19:40:03 <reffie> mudge you use the haskell network library to create sockets and listen for connections on them
19:40:13 <FMota> ROFL: Haskell is a unique species in that is has been used by Native American tribes as a mind altering substance.
19:40:15 <mudge> oh okay,  make sense,
19:40:18 <newsham> mudge: the first few lines of main in rephattpd-0.4.hs
19:40:21 <reffie> FMota :)
19:40:22 <LoganCapaldo> or am i just wrong by definition?
19:40:38 <mudge> newsham,  reffie,  okay thanks,  i think I get it
19:40:44 <reffie> good luck
19:40:45 <FMota> hadn't had such a good laugh in a while
19:40:56 <reffie> FMota yeah, liarpedia makes me laugh pretty hard, sometimes
19:41:08 <reffie> unfortunately, it doesn't really have a lasting value
19:41:09 <mudge> you guys,  I was thinking that it might be great for haskell to have a mascot
19:41:30 <FMota> lambda?
19:41:34 <ddarius> LoganCapaldo: You can write a value f :: Mu T for practically any T.  All algebraic data types are of the form Mu F for some F.
19:42:00 <mudge> I was thinking Haskell the dragon
19:42:05 <mudge> you know Haskell the dragon?
19:42:14 <mudge> http://tellmeastory.com/haskell/pages/page1.cfm
19:42:16 <lambdabot> Title: The Hatching of Haskell Page 1 of 17
19:42:59 <LoganCapaldo> ddarius, Maybe I'm just dense, but how would you do it for type T a = ((), a) ?
19:44:06 <newsham> mascot:  eddie haskell
19:44:22 <reffie> mascot: haskell church
19:44:48 <reffie> or not
19:45:02 <reffie> i really meant haskell curry :(
19:45:31 <LoganCapaldo> (barring bottom)
19:45:37 <ddarius> LoganCapaldo: newtype K a b = K a; type T a = Mu (K ((),a)) -- (modulo bottoms perhaps as I'm not trying very hard)
19:45:53 <ddarius> Or you mean Mu T?
19:46:01 <LoganCapaldo> I mean Mu T
19:46:05 <ddarius> Mu T is just Stream ()
19:46:15 <mudge> haskell curry sounds familiar
19:46:26 <Tac-Tics> gah, I hate it when authors start using new notation without explaining the notation before hand
19:46:57 <LoganCapaldo> well you can't just do f = ((), f) cause that won't terminate no?
19:47:09 <ddarius> That won't type check.
19:47:17 <LoganCapaldo> right
19:47:24 <LoganCapaldo> I don't want it to :)
19:47:32 <chessguy> that's different from not terminating
19:47:35 <glguy> *in haskell's type system
19:47:36 <LoganCapaldo> ok
19:47:38 <ddarius> f = Mu ((), f) typechecks and terminates just fine.
19:47:45 <glguy> recursive types are explicityly disallowed
19:47:59 * monochrom hugs newtype
19:48:11 <Tac-Tics> glgly: is that restriction do to the inference algorithm or something?
19:48:39 <ddarius> Tac-Tics: It was a decision.
19:48:49 <Tac-Tics> I always found it strange you can define the fixpoint function in Haskell, but you can't define it as a lambda expression
19:48:53 <Tac-Tics> even with a type cast*
19:49:05 <Tac-Tics> what do recursive types do that's so bad?
19:49:14 <ddarius> Tac-Tics: Types were originally introduced -specifically- to disallow that.
19:49:53 <monochrom> untyped lambda calculi have their share of paradoxes.
19:50:13 <Tac-Tics> this is something I've never understood
19:50:21 <Tac-Tics> can you give me an example of such a paradox?
19:50:31 <newsham> a machine that halts only if it doesnt halt?
19:50:36 <ddarius> Tac-Tics: Russel's paradox is the untyped lambda calculus is Y not
19:50:56 <Tac-Tics> > fix not
19:50:57 <lambdabot>  Exception: <<loop>>
19:51:17 <Tac-Tics> but any turing complete system will have something equivalent, won't it?
19:51:42 <ddarius> Types were originally introduced at the beginning of the 20th century in mathematical logic.
19:52:09 <Philippa> yep, turing complete => unsound
19:52:34 <ddarius> inconsistent
19:52:45 <glguy> isn't this where Godel comes in?
19:53:15 <Tac-Tics> Types or no types, though, the halting problem persists
19:53:24 <LoganCapaldo> ddarius, if Haskell were strict, would f = Mu ((), f) still terminate? I feel like you are only getting away with that because of laziness, would my idea be more workable if I did it in ML for instance?
19:53:35 <ddarius> Tac-Tics: False.  The simply typed lambda calculus is strongly normalizing.
19:53:38 <Tac-Tics> what do types do to improve that situation
19:54:12 <newsham> ddarius: but you cant implement fix in strongly typed lambda calc right?
19:54:24 <Philippa> offer you a useful sub-turing language, and/or a way of marking out when you're using features that make the halting problem undecidable
19:54:25 <newsham> so when we go to haskell....
19:54:35 <sorear> newsham: Sure you can.  It depends on the type of strong types.
19:54:39 <ddarius> newsham: You could in some, but not in the simply typed one without special primitives.
19:55:15 <newsham> so are these typed lambda calculi not turing complete?
19:55:40 <Philippa> newsham: many aren't, intentionally
19:55:51 <ddarius> LoganCapaldo: No it wouldn't, but that's not particularly significant and it's easily fixed.  Much like strict languages need an applicative Y combinator.
19:56:02 <Tac-Tics> So would strongly typed lambda expressions be isomorphic to primitive recursive functions then?
19:56:21 <Tac-Tics> or are they similiar but distinct?
19:56:30 <ddarius> Tac-Tics: With the appropriate type system, yes.
19:56:39 <Tac-Tics> ok
19:57:08 <LoganCapaldo> so basically I've come up with nothing :(
19:57:26 <ddarius> LoganCapaldo: What were you trying to come up with?
19:57:45 <LoganCapaldo> well I wasn't trying to come up with anything
19:58:01 <LoganCapaldo> I thought I had come up with an application of that type
19:58:14 <Tac-Tics> so strict avoidance of recursive types, I'm guessing, voids a system's turing completeness?
19:58:23 <ddarius> LoganCapaldo: There are plenty of applications for the type level fixpoint operator.
19:58:34 <LoganCapaldo> I have no doubt
19:58:42 <LoganCapaldo> it was just a thought that came to me
19:59:00 <ddarius> What application had you thought you'd come up with?
19:59:08 <LoganCapaldo> the one I just described
19:59:14 <LoganCapaldo> proving "maybeness"
20:00:30 <LoganCapaldo> Hmm
20:02:43 <LoganCapaldo> type Tuple a b = (a, b); type Stream a = Mu (Tuple a) ?
20:03:17 <ddarius> LoganCapaldo: Yes.  Mu ((,) a) should work.
20:04:15 <ddarius> Nu would be a better name for Mu in that case, but such is Haskell.
20:05:14 <ddarius> "Carried to its logical extreme the ultimate form of the uniform delay rule is to never compute the value of any expression unless the value is needed for output to the external environment!"
20:07:14 <jcreigh> if only we had some eyeball tracking hardware that only forced a thunk if someone actually *looked* at that part of the screen...
20:07:32 <ddarius> "SECTION VI --- The LAMBDA CALCULUS of CHURCH"
20:07:38 <ddarius> jcreigh: We do have that technology.
20:07:58 <Tac-Tics> The Church of the Lambda Calculus
20:08:07 <Tac-Tics> That would be a cool name for a Haskell cult
20:08:12 <jcreigh> ddarius: are you being serious or is that a lead-in to a joke?
20:08:45 <ari> Tac-Tics: We already have the Church of the Least Fixed Point, thank you :)
20:08:59 <Tac-Tics> Maybe all truth in the Universe is stored in a thunk
20:09:22 <Tac-Tics> and even god doesn't know it all until he evaluates (head truths)
20:11:09 <coffeemug> hmmm
20:11:12 <coffeemug> test = 1 : 1 : zipWith (*) test (tail test)
20:11:25 <coffeemug> (!!) test 10000000
20:11:28 <shapr> yarr
20:11:29 <coffeemug> that causes a stack overflow
20:11:50 <ddarius> jcreigh: I'm being serious.
20:12:23 <jcreigh> ddarius: I know eyeball tracking is possible...I didn't think anybody had actually tied it to lazy evaluation, though.
20:13:14 <coffeemug> > let test = 1 : 1 : zipWith (*) test (tail test)
20:13:14 <lambdabot>  Parse error
20:14:05 <LoganCapaldo> I'm silly
20:14:12 <LoganCapaldo> You don't even need Mu
20:14:22 <LoganCapaldo> (for Stream)
20:14:30 <LoganCapaldo> data Stream a = Cons a (Stream a)
20:15:36 <coffeemug> hmm
20:15:40 <coffeemug> is this supposed to happen?
20:16:02 <coffeemug> basically trying to grab a far enough item in the infinite self-referencing list
20:16:06 <coffeemug> causes a stack overflow
20:16:11 <monochrom> God help me. I'm learning Scheme macros. They allow recursive definitions! E.g., I can tell it to rewrite (haha x y) to (haha x), and then (haha x) to whatever...
20:16:47 <coffeemug> monochrom: oh yeah, this stuff gets real fun
20:17:29 <mrd> recursive macros are fun
20:17:50 <TSC> What happens if the recursion is infinite?
20:17:56 * monochrom tries
20:17:58 <TSC> Does the compiler blow its top?
20:18:08 <LoganCapaldo> non-terminating compiler
20:18:10 <mrd> user-beware
20:18:20 <LoganCapaldo> WARNING: Hot!
20:18:35 <monochrom> It runs hot :)
20:18:49 <monochrom> It goes out of memory :)
20:19:00 <TSC> The compiler does?
20:19:25 <coffeemug> yeah
20:19:30 <coffeemug> in CL compiling blows the stack
20:19:35 <coffeemug> if you use infinite recursion in macros
20:20:25 <Tac-Tics2> hehe
20:20:27 <Tac-Tics2> interesting
20:20:41 <coffeemug> hmm
20:20:42 <Tac-Tics2> a compiler freezing
20:20:47 <coffeemug> why does this not work?
20:21:01 <coffeemug> taking a one millionth item from my test example?
20:21:02 * mrd reminds you that -fallow-undecidable-isntances can do the same
20:21:37 <TSC> coffeemug: this example?  test = 1 : 1 : zipWith (*) test (tail test)
20:22:01 <ddarius> LoganCapaldo: Mu is a type level fix and thus can be replaced by naming just like at the value level.
20:22:16 <coffeemug> TSC: yeah
20:22:29 <coffeemug> try to grab (using !!) one millionth item
20:22:32 <coffeemug> or 10 millionth
20:22:33 <LoganCapaldo> ddarius, uh huh
20:22:35 <coffeemug> you'll blow the stack
20:22:50 <ddarius> coffeemug: You aren't forcing any of the previous multiplications so when you actually get to the one you pick it's a giant thunk.
20:22:59 <TSC> The whole list is just (repeat 1) ...
20:23:01 <monochrom> Using TSC's example, test !! 10000000000 will cause a stack overfloow. This is because the requested number is a thunk being a chain of 100000000 multiplications.
20:23:05 <LoganCapaldo> Let's see all you need is Either, (,), () (Maybe?) and Mu and you can do anything right?
20:23:17 <coffeemug> yeah
20:23:25 <coffeemug> I mean, I understand that
20:23:38 <ddarius> LoganCapaldo: (->) and 0
20:23:46 <LoganCapaldo> heh
20:23:56 <LoganCapaldo> church encoding ftw
20:23:58 <TSC> coffeemug: Evaluating the huge thunk requires lots of stack space
20:23:59 <LoganCapaldo> what's 0?
20:24:00 <coffeemug> I was just under impression that compiler is smart enough to force things when lazyness chain gets large enough
20:24:04 <monochrom> OTOH if you "print test" there is no overflow, since multiplications are forced before they thunk up.
20:24:25 <ddarius> LoganCapaldo: The dual of (); the Void we were talking about earlier.
20:24:29 <coffeemug> hmm
20:24:30 <coffeemug> I see
20:24:30 <LoganCapaldo> ah
20:24:41 <TSC> Is it allowed to force things?  I think that changes the semantics in the presence of undefined
20:25:00 <ddarius> TSC: It isn't unless it arranges for it to not make a differenc.
20:25:07 <ddarius> TSC: E.g. in Eager Haskell.
20:25:13 <TSC> Ok
20:25:45 <coffeemug> well, in this case it wouldn't make any semantic difference
20:25:46 <TSC> So GHC's strictness analyser has to be sure it won't change anything before it goes around sticking !s onto things
20:25:52 <ddarius> Speculative evaluation would actually work well in this case.
20:26:12 <coffeemug> so ghc isn't smart enough to figure out that this is safe to force evaluation upon
20:26:13 <coffeemug> I see
20:26:28 <ddarius> coffeemug: What you need is head strict lists.
20:26:41 <coffeemug> ddarius: yeah
20:26:49 <coffeemug> I wrote a library that does all this in Lisp
20:26:51 <ddarius> data HeadStrictList a = Nil | Cons !a (HeadStrictList a)
20:26:59 <coffeemug> and someone pointed out that it blows the stack on large enough elements
20:27:12 <coffeemug> so I'm trying to figure out how this works in Haskell
20:27:22 <coffeemug> ddarius: yeah, I see
20:27:41 <ddarius> Or alternatively, you can use a forcing zipWith
20:28:01 <hpaste>  esteban2 annotated "tuples" with "tuples" at http://hpaste.org/2585#a2
20:28:03 <coffeemug> cool
20:28:09 <coffeemug> every day you learn smtg new!
20:28:34 <LoganCapaldo> data HeadStrictList a = Nil | Cons !a (HeadStrictList a) deriving ( toList :: HeadStrictList a -> [a] ) <-- feature I suddenly want :)
20:28:37 <Tac-Tics2> Are Scheme or CL macros allowed to be recursive?
20:29:05 <coffeemug> Tac-Tics2: yes
20:29:10 <coffeemug> sometimes it's rather useful
20:29:24 <ddarius> > let zipWith' f (x:xs) (y:ys) = (: zipWith' f xs ys) $! f x y; test = 1:1:zipWith' (*) test (tail test) in test!!1000000000
20:29:29 <lambdabot> Terminated
20:29:33 <scook0_> though I imagine unbounded recursion would hang your compiler ;)
20:29:37 <Tac-Tics2> would it be possible to define a Lisp with macros that could only be primitively recursive? to prevent the compiler from bottoming?
20:29:53 <ddarius> > let zipWith' f (x:xs) (y:ys) = (: zipWith' f xs ys) $! f x y; test = 1:1:zipWith' (*) test (tail test) in test!!100000000
20:29:57 <lambdabot> Terminated
20:29:59 <Tac-Tics2> so it would require Typed macros?
20:30:59 <coffeemug> Tac-Tics2: who cares if it bottoms?
20:31:04 <coffeemug> just don't use infinite recursion :)
20:31:30 <Tac-Tics2> Well, obviously, *I* would never do that
20:31:36 <Tac-Tics2> but to the wayward Lisp user
20:31:48 <Tac-Tics2> Will anybody PLEASE think of the Lispers?
20:34:01 <ari> Hey, it's no worse than using undecidable instances, which I seem to end up doing quite often
20:35:36 <scook0_> I think in practice you could get away with some soft limit on recursion depth
20:36:02 <Tac-Tics2> and ruin the purity of the compiler? blasphemy!
20:36:45 <ari> Actually, come to think of it, ghc does use a configurable (-fcontext-stack) recursion depth limit when using undecidable instances AFAIK
20:36:47 <scook0_> so you're suggesting a type system to detect errors at ... uh ... pre-compile time? ;)
20:36:59 <ddarius> scook0_: There are already soft limits on the recursion depth, programmer's won't wait forever.
20:37:33 <Tac-Tics2> You'd need to 1) Type Check Macros, 2) expand the macros, 3) typecheck the expansion, 4) compile, 5) dance
20:38:07 <johnnowak> Tac-Tics2: Now go find a lisper that won't laugh when you suggest that :)
20:38:23 <reffie> have you ever had a long distance relationship
20:38:54 <scook0_> typed macros: because catching errors at compile-time is too late!
20:38:55 <Tac-Tics2> And while I'm add it, I'm going to do the world a favor and impose a syntax to Lisp
20:38:59 <Cale> reffie: Who are you asking? This is #haskell, in case you didn't notice :)
20:39:11 <coffeemug> hehe
20:39:17 <coffeemug> I'm in a long distance relationship right now
20:39:20 <coffeemug> works great for me
20:39:32 <coffeemug> it's great while she's here
20:39:39 <coffeemug> and I get all the time to code when she's not
20:39:44 <coffeemug> what else could one wish for? :)
20:39:44 <Tac-Tics2> instance Monad Relationship where ...
20:40:03 <reffie> Cale everyone, including you
20:41:13 <ramza3> is there a popular web server written in haskell
20:41:21 <greentea> Hey all. i'm having some trouble with the basics of Arrows. Is the arr function in the Arrow class similar to the liftM function for the Monad class?
20:41:26 <ramza3> s/popular/what is the most popular/g
20:41:42 <ari> :t arr
20:41:50 <sjanssen> ramza3: HAppS, probably
20:41:52 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
20:41:57 <johnnowak> ramza3: there's no need to be greedy
20:41:58 <Cale> greentea: yeah, or kinda like return, actually
20:42:26 <greentea> Hm.
20:42:28 <coffeemug> hmm
20:42:45 <coffeemug> that thunking example demonstrates fairly low level implementation details leaking into high level abstractions
20:42:56 <scook0_> greentea: it depends on how loose you want to be with "similar"
20:42:59 <Cale> It turns a Haskell function (any haskell function) into an arrow-value.
20:43:10 <ddarius> coffeemug: Yes, machines should have infinite memory.
20:43:18 <coffeemug> ddarius: no
20:43:23 <coffeemug> not that :)
20:43:35 <coffeemug> this *can* be done with limited memory
20:43:38 <ddarius> coffeemug: If you evaluate it using normal-order evaluation, that is what you get.
20:43:39 <coffeemug> clearly
20:43:39 <greentea> Cale: Well, that's what i thought. But in GHCi, i can't do something like: let x = arr length
20:43:48 <greentea> Because of a type ambiguity.
20:44:08 <ddarius> coffeemug: The point is it isn't an implementation detail, it's a fact of non-strictness.
20:44:14 <greentea> And i can't work out how to fix that type ambiguity - i can't work out what signature i need to add to get that let to work.
20:44:41 <coffeemug> ddarius: I disagree
20:45:05 <Cale> greentea: :set -fno-monomorphism-restriction
20:45:16 <ddarius> coffeemug: You can catch some cases, but not all cases.
20:45:17 <greentea> Ah, of course.
20:45:18 <scook0_> yeah, it's a monomorphism thing
20:45:19 <coffeemug> basically if the runtime system can preserve the semantics it should flush the context if it gets too large by eager evaluation
20:45:53 <greentea> But what sort of type signature would disambiguate things without needing to turn off the monomorphism restriction?
20:46:08 <coffeemug> an interesting question is whether it's possible to define the semantics in such a way that it's always possible to determine if it's safe to force evaluation when you run into hardware limitations
20:46:12 <Cale> x :: MyArrow [a] Int
20:46:21 <scook0_> @type arr length
20:46:23 <lambdabot> forall a (a1 :: * -> * -> *). (Arrow a1) => a1 [a] Int
20:46:32 <Philippa> coffeemug: sounds like the halting problem's dual to me
20:46:34 <Cale> or that :)
20:47:03 <Cale> x :: (Arrow (
20:47:08 <coffeemug> Philippa: halting problem? Meaning if a program ever terminates? I don't think it's a dual of that at all
20:47:12 <Cale> x :: (Arrow (~>)) => [a] ~> Int
20:47:45 <scook0_> you can turn off the MR, get GHCi/LB to tell you the type, and then turn on MR and use that type signature explicitly
20:47:49 <Philippa> coffeemug: you're asking if the program runs in bounded space instead of bounded time
20:48:04 <coffeemug> Philippa: no
20:48:15 <coffeemug> Philippa: I run it and if I run out of space at runtime I force evaluation
20:48:22 <coffeemug> Philippa: so I'm not asking in advance
20:48:34 <coffeemug> what I am asking is whether forcing evaluation will change the semantics
20:48:34 <Philippa> yes you are - otherwise you don't know it's safe to evaluate anything
20:48:38 <coffeemug> and that's a different problem
20:48:50 <Philippa> oh, that *and* the halting problem again
20:48:51 <greentea> Ah! Thanks for your help, Cale and scook0_. :-)
20:49:17 <Philippa> forcing evaluation changes the semantics any time it makes something stricter than it was before
20:49:32 <coffeemug> hmm
20:49:34 <coffeemug> I'm not sure I agree
20:49:46 <coffeemug> making something stricter in and of itself doesn't change semantics
20:49:53 <mudge> coffeemug: how's weblocks?
20:50:00 <coffeemug> mudge: it's going :)
20:50:09 <coffeemug> doing some other stuff now but will get back to it shortly
20:50:18 <Philippa> yes it does - strictness is an equational property
20:50:24 <mudge> when are you going to publish some more articles?
20:50:35 <coffeemug> mudge: when they're ready (tm) :)
20:50:39 <coffeemug> can't give promises
20:50:49 <mudge> k :0
20:50:49 <coffeemug> hmm
20:51:06 <coffeemug> Philippa: why is that?
20:51:17 <coffeemug> if order of evaluation makes no difference
20:51:24 <coffeemug> and there are no side effects
20:51:50 <coffeemug> then what do I care if there is more or less strictness as long as I can still manage infinite data structures?
20:52:08 <Philippa> because that's exactly what strictness affects
20:52:14 <scook0_> an amusing question is: if you have a theoretically non-strict program that fails due to hardware constraints, and you replace it with a strict program that fails due to strictness, have you really altered the semantics? :P
20:52:40 <coffeemug> well, in that example strictness wouldn't affect anything
20:52:49 <Philippa> how so?
20:52:56 <coffeemug> it would only give an illusion of a machine with infinite ram
20:52:57 <ddarius> scook0_: You can buy more hardware without recompiling the program.
20:53:14 <Philippa> it wouldn't any more so than garbage collection would
20:53:41 <coffeemug> hmm
20:53:56 <ddarius> coffeemug: There is nothing that would work all the time.
20:53:58 <Philippa> basically you can only start forcing thunks that you know behave strictly anyway. And GHC already does this
20:54:04 <Cale> If a bottom falls in a forest, but there's no case there to evaluate it, does it throw an exception? (Answer: no.)
20:55:16 <Philippa> and you can't do a perfect strictness analysis because it's effectively the halting problem again
20:55:44 <coffeemug> hmm
20:56:01 <Philippa> in fact, it *is* the halting problem once you've applied _|_ as the appropriate parm
20:57:50 <coffeemug> hmm
20:57:51 <coffeemug> I think I see
20:57:54 <coffeemug> vaguely :)
20:57:57 <coffeemug> I need to think about it
20:58:07 <Philippa> additionally, you don't know that forcing the thunk won't allocate more memory than it frees
20:58:34 <coffeemug> right
20:59:03 <ddarius> In these kinds of situations it's best to do nothing or something very simple.
20:59:04 <coffeemug> well, in Haskell lazyness is deterministic
20:59:11 <coffeemug> what if it weren't?
20:59:18 <Philippa> no difference
20:59:22 <coffeemug> and there would be no gurantees when something might be evaluate
20:59:23 <coffeemug> d
20:59:31 <coffeemug> or when it might now
20:59:32 <coffeemug> not
20:59:42 <Philippa> there aren't any, it's up to the implementation
20:59:52 <coffeemug> there are
20:59:59 <coffeemug> I can use the self-referencing fib example
21:00:06 <ddarius> coffeemug: Haskell doesn't specify when something is evaluated (it just needs to be evaluated before it's needed for obvious reasons)
21:00:09 <sioraiocht> coffeemug: the only guarantee is that it will be evaluated when it's needed
21:00:11 <coffeemug> it's guranteed to work in conforming haskell implementations, isn't it?
21:00:20 <reffie> http://image.bayimg.com/laglhaabl.jpg
21:00:53 <coffeemug> so fib = 1 : 1 : zipWith (+) fib (tail fib) isn't guranteed to work on a given conforming Haskell system?
21:00:57 <ddarius> reffie: Clowns are scary.  That one is more so than most.
21:00:59 <Philippa> the only guarantees are that unnecessary things won't be evaluated and that you'll eventually get the value you asked for if it doesn't get into a loop
21:01:43 <LoganCapaldo> What if I ask for a loop?
21:01:46 <ddarius> coffeemug: non-strictness is a semantic property not an aspect of the implementation.  There are many implementations that can satisfy it.
21:01:50 <ddarius> LoganCapaldo: You get a loop.
21:02:01 <LoganCapaldo> but it gets into a loop
21:02:05 <coffeemug> ddarius: I see
21:02:05 <LoganCapaldo> so I don't get it
21:02:12 <LoganCapaldo> but a loop is what I wanted
21:02:15 <LoganCapaldo> so I do get
21:02:16 <LoganCapaldo> it
21:02:17 <monochrom> Now you two are in a loop.
21:02:22 <sfultong> anyone familiar with the HGL libraries?
21:02:30 <LoganCapaldo> but since I'm in a loop I couldn't have gotten it
21:02:32 <Philippa> LoganCapaldo: there's a difference between metaness and having your head up your arse :-)
21:02:37 <monochrom> hahahahaha
21:03:08 <LoganCapaldo> I believe strongly in head arsery
21:03:22 <Philippa> you know where -blah is
21:03:23 * ddarius loves Philippa's subtle tact.
21:03:40 <monochrom> but it's not subtle
21:04:01 <Philippa> that was tactful? :-)
21:04:13 <monochrom> and so it's subtle. and so it's subtle iff not subtle. I don't get it...
21:04:17 <LoganCapaldo> It was so subtle no one could tell it was tactful
21:04:54 <sfultong> this channel gets more offtopic conversation than blah does... blah is dead most of the time
21:05:01 <LoganCapaldo> lies
21:05:10 <ddarius> sfultong: Lately (at least when I've been on)
21:05:18 <LoganCapaldo> we were just discussing purchasing teenage brides on the interwebs
21:05:28 <monochrom> interwed?
21:05:29 <ddarius> Most of the time #haskell is better behaved and there are often very lively conversations on #haskell-blah
21:05:33 <sfultong> oh, then... by all means, go on
21:06:57 <Tac-Tics2> (I brought up the website for the record ;-)
21:07:05 <Philippa> that, and I sometimes employ unsubtle tact there
21:07:26 <ddarius> For #haskell it is only subtle tact.
21:10:38 <scandal> is returning an `exit code' just a simple matter of declaring   main :: IO Int   and returning the value you want?
21:11:10 <sfultong> sadly, no
21:11:23 <sfultong> (why don't languages do this)
21:11:24 <sfultong> ?
21:13:09 <Tac-Tics2> The exit code isn't really that prominent of a programming technique anymore really
21:13:34 <sfultong> :(
21:13:35 <johnnowak> Tac-Tics2: ?
21:13:41 <sfultong> noone loves the console anymore
21:13:43 <monochrom> Look for System.Exit
21:13:51 <scandal> heh, except i'm writing a console app :(
21:14:26 <Tac-Tics2> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
21:14:28 <lambdabot> http://tinyurl.com/yyce5n
21:15:51 <scandal> thank ya.
21:19:19 <Tac-Tics2> I'm think I'm about ready to exitWtih ExitSuccess here in #haskell
21:19:20 <Tac-Tics2> nightall
21:19:59 <sfultong> I think that HGL is redrawing the screen in my app window before sending the ReSize event, causing BadDrawable error messages
21:31:26 <shapr> @yow !
21:31:27 <lambdabot> My polyvinyl cowboy wallet was made in Hong Kong by Montgomery Clift!
21:35:12 <shapr> mmm code
21:35:50 <shapr> Yay, other people wrote better code than I did, and I get to use it instead!
21:44:03 <Adamant> other people writing better code than me? that's unpossible!
21:44:21 <Adamant> - Ralph Codeums
21:44:24 <FMota> gosh
21:44:32 <FMota> so long to make blog posts work :/
21:44:34 <FMota> http://odi-sei-a.blogspot.com/2007/09/three-design-rules-used-in-sei.html
21:44:41 <lambdabot> Title: odiseia: Three Design Rules used in Sei, http://tinyurl.com/36udo2
21:44:44 <FMota> *done
21:44:59 <FMota> It's functional, hence it's ontopic.
21:45:03 <FMota> :o
21:51:44 <Pseudonym> Damn, just missed int-e.
21:55:14 * bos watches sam ruby gush over erlang with some amusement
21:59:48 <shapr> Is that the because of multicore, use erlang or haskell post?
22:01:38 <bos> oh, he posted something about haskell?
22:01:48 <bos> i don't read his blog, just see people refer to it every so often.
22:02:45 <bos> the current wave of gushing erlang fanboyism doesn't impress me with its intellectual depth.  "look! shiny! shinier than ruby! spangly!"
22:02:48 <shapr> I don't know, I read a recent erlang gush centering on the massively multicore argument.
22:03:25 <shapr> I only hope the professional programming community is growing up in general.
22:03:33 <bos> ahahahahaha
22:03:41 <Nafai> shapr: What do you mean by "growing up"?
22:03:43 <shapr> You don't think it's likely?
22:04:05 <shapr> Nafai: I mean that if all the Java programmers in the world also knew Haskell and Erlang, Java code wouldn't suck nearly as much.
22:04:20 <Pseudonym> The programming community is always growing up.
22:04:30 <shapr> I'm not convinced.
22:04:44 <coffeemug> shapr: and lisp
22:04:45 <shapr> Pseudonym: How so?
22:04:46 <coffeemug> don't forget lisp :)
22:04:48 <Nafai> shapr: I don't see it happening :/
22:04:56 <Pseudonym> Java was a step forward, because it added a new language with some nice features to the ecosystem in a big way.
22:05:03 <shapr> coffeemug: I dunno, I talked to rahul on irc and I never wanted to learn Lisp after that.
22:05:04 <Pseudonym> Java is secure, portable and garbage collected.
22:05:08 <shapr> I did learn scheme and elisp though.
22:05:09 <Pseudonym> To a first approximation.
22:05:24 <Pseudonym> Before Java, you'd hear a lot of "ugh, GC, slow".
22:05:29 <shapr> Pseudonym: That's true, getting rid of malloc/free made the rest of it worthwhile.
22:05:30 <Boney> shapr: It might slowly.  I'm seeing more penatration of functional ideas being used in mainstream languages and teams.
22:05:30 <Pseudonym> You don't hear that any more except from Linux.
22:05:38 <shapr> Boney: That's good to hear.
22:05:49 <Nafai> Pseudonym: Hear what from Linux?
22:05:53 <Pseudonym> Linus
22:05:54 <Pseudonym> Sorry.
22:05:56 <shapr> Pseudonym: Speaking of which, I think they need GC.
22:06:00 <Nafai> Pseudonym: Common typo :)
22:06:04 <Pseudonym> Yeah.
22:06:06 <reffie> pavarotti died :((((((
22:06:10 <Pseudonym> He did?
22:06:17 <reffie> http://www.msnbc.msn.com/id/20607839/
22:06:18 <lambdabot> Title: Opera star Luciano Pavarotti dies - Music - MSNBC.com
22:06:22 <bos> @seen dons
22:06:23 <lambdabot> dons is in #haskell and #xmonad. I last heard dons speak 19m 47s ago.
22:06:24 <Pseudonym> Well, he couldn't hit the high C any more anyway.
22:06:27 <shapr> Pseudonym: http://lwn.net/Articles/236108/
22:06:28 <lambdabot> Title: Slab defragmentation [LWN.net]
22:06:51 <coffeemug> shapr: it's silly to make such decisions because of one person
22:06:53 <Pseudonym> They've been scoring arias down for him for years.
22:07:14 <coffeemug> but yes, #lisp can be "interesting" on occassion
22:08:15 <shapr> coffeemug: Haven't we had this discussion recently? Oh no, that was gigamonkey_
22:08:31 <coffeemug> hehe
22:08:40 <coffeemug> I think this discussion is recurrent :)
22:08:44 <shapr> coffeemug: In short, I like lisp the language and the idea, but I do not like lisp the community.
22:08:48 <reffie> shapr what about that url?
22:09:13 <shapr> reffie: Seems to me that defragmentation calls for GC.
22:09:19 <shapr> reffie: Do you agree?
22:09:20 <dons> hey bos
22:09:26 <reffie> no
22:09:31 <shapr> reffie: Why not?
22:09:38 <reffie> how would gc help
22:09:51 <bos> dons: how's portland so far?
22:10:04 <Pseudonym> The tricky bit here is moving something in a realtime program.
22:10:05 <shapr> reffie: It'd defragment stuff?
22:10:17 <dons> bos, warm :) today was work day 1. lots of fun.
22:10:20 <Pseudonym> The slab allocator actually doesn't need compaction.
22:10:20 <reffie> the problem is that the entries are not all freed in the same order
22:10:29 <reffie> so you can't free whole slabs
22:10:31 <Pseudonym> Because it only allocates things of the same size on the same page.
22:10:34 <reffie> in general
22:10:52 <Nafai> dons: I was meaning to ask how the first day of work was; glad it is fun!
22:11:07 <reffie> you might be able to do some virtual memory tricks, but it's not easy
22:11:32 <coffeemug> moving to the west coast is becoming so tempting lately
22:11:37 <coffeemug> the thought is driving me crazy
22:11:53 <Nafai> coffeemug: Where are you currently?
22:12:06 <shapr> New York?
22:12:07 <reffie> coffeemug relax, don't do it, when you want to go to it
22:12:24 <coffeemug> yeah, NYC
22:16:21 <shapr> I'm going east.
22:18:45 <bos> http://www.serpentine.com/software/mysql/
22:18:47 <lambdabot> Title: teideal glic deisbhéalach  mysql - Haskell language bindings for MySQL
22:19:38 <shapr> bos: Cool, that's your second library in what, four days?
22:19:40 <coffeemug> shapr: to do what?
22:19:51 <shapr> coffeemug: Live with my gf in Stockholm.
22:20:01 <bos> shapr: something like that
22:20:11 <bos> i must now return to book hacking
22:20:16 * shapr gives bos the profilic lambda award for the week.
22:20:20 <Nafai> bos: Yay for book hacking!
22:20:24 <bos> @where+ mysql http://www.serpentine.com/software/mysql/
22:20:24 <lambdabot> Done.
22:20:28 <coffeemug> ahh, *that* east :)
22:20:51 <bos> writing pure mysql bindings in haskell is total fun thanks to Data.Binary
22:20:55 <shapr> Yeah, I'm already in Alabama.
22:21:11 <shapr> bos: Are you reconstituting binary streams?
22:21:32 <bos> i'll also be able to hook the mysql library up to the pcap library, and watch live query streams over the network
22:21:32 * shapr grabs the source to look
22:21:37 <shapr> whoa nifty
22:21:57 <bos> yeah, the client is subordinate to my desire to do server performance monitoring
22:22:08 <shapr> bos: Where's Mirrors.hs ?
22:22:15 <bos> Mirrors?
22:22:22 <shapr> You've already got Smoke.hs ;-)
22:22:26 <bos> heh
22:23:20 <bos> the code is very early, but it can authenticate to a server and perform queries
22:23:29 <dons> bos, good work :)
22:23:49 <shapr> Pretty code!
22:23:51 <bos> now back to fucking around with django so we can start publishing book chapters :-(
22:24:13 <bos> shapr: thanks :-)
22:24:27 <shapr> toBits and fromBits seem more generally useful...
22:24:27 * dons `ap` sleep
22:24:37 <int-e> good night dons
22:25:01 <bos> shapr: yes, they are
22:25:07 <shapr> Actually, a bunch of these functions look like they'd fit into Data.Binary.Util or something.
22:25:52 <reffie> i wish i was a good programmer
22:25:59 <shapr> reffie: Easy to become one.
22:26:03 <reffie> how?
22:26:14 <reffie> i'm not good at anything
22:26:16 <shapr> reffie: Start where are now, write code. Then try to improve that code.
22:26:25 <bos> shapr: that's a good idea, i should send a patch to dons :-)
22:26:25 <shapr> Then ask others how to improve that code when you think it's good code.
22:26:32 <shapr> bos: truly
22:26:33 <reffie> i can't find the motivation :(
22:26:45 <Pseudonym> reffie: Another suggestion.  If you want to be a good novelist, you need to read other novels, and read them critically.
22:26:49 <Pseudonym> Same with programming.
22:26:52 <shapr> reffie: Then you don't wish enough to become a good programmer.
22:27:07 <shapr> If you really want something, you go out and get it.
22:27:10 <Pseudonym> shapr: No, he wants to _be_ a good programmer, not _become_ one.
22:27:13 <shapr> aha
22:27:20 <Pseudonym> I caught that detail.
22:27:22 <reffie> Pseudonym speaks the truth
22:27:38 <shapr> reffie: There is a useful trick you can use... get a job that requires you to be a good programmer.
22:28:03 <shapr> Everyone I've ever met wants food enough to go out and get it. If the only way to get food is to become a good programmer, problem solved!
22:28:05 <Pseudonym> Yeah, if eating depends on it...
22:28:12 <shapr> in stereo...
22:28:24 <reffie> hm
22:28:32 <shapr> reffie: I'ved used that trick myself ;-)
22:28:38 <reffie> did it work?
22:28:45 <Pseudonym> shapr is pretty good.
22:29:00 <shapr> I weigh 105 kilos...
22:29:05 <shapr> Not at all starving.
22:29:05 <reffie> heh.
22:29:22 <shapr> Pseudonym: Pretty good at what? ;-)
22:29:28 <Pseudonym> shapr: I could easily weight more than that (and I do!) being a Visual Basic script kiddie.
22:29:41 <Pseudonym> I weigh more than that.  I'm not a VB script kiddie.
22:29:43 <shapr> Pseudonym: Bah, you're a nano-haskell script kiddie!
22:29:45 <Pseudonym> Just wanted to put that out there.
22:30:21 <shapr> I wanted to make meatballs today, but I forgot to buy eggs :-( I need to write a Haskell program to send my grocery list to my phone.
22:30:31 <Pseudonym> (Not very much more than that, mind.)
22:30:44 <shapr> Silly question, is there some way to send SMS messages to yourself from your computer?
22:30:54 <Pseudonym> reffie: That's the other thing.  Scratch some itches.
22:30:55 <shapr> Pseudonym: You should try unicycling!
22:31:00 <Pseudonym> Yeah, I should.
22:31:15 <shapr> Pseudonym: Yeah, good point! I want to remember to buy eggs, I write a Haskell SMS binding.
22:31:18 <Pseudonym> Though it's very hilly around my place.
22:31:19 <shapr> reffie: That works well.
22:31:24 <shapr> Pseudonym: It's pretty hilly here.
22:31:26 <reffie> Pseudonym what do you mean?
22:31:39 <Pseudonym> reffie: If you have some task that needs doing, just do it.
22:31:42 <Pseudonym> In Haskell.
22:31:44 <reffie> ah
22:31:46 <Pseudonym> Something that annoys you.
22:31:54 <Nafai> shapr: Depends on your provider.
22:32:02 <shapr> I'm using AT&T, formerly Cingular.
22:32:13 <Nafai> shapr: For example, I have Verizon and I can just send an e-mail to <my phone number>@vtext.com
22:32:13 <shapr> Nafai: Know anything about them?
22:32:16 * Nafai looks
22:32:19 <shapr> Oh, that's handy.
22:32:31 <Vq^> i have touched some code that worked with Telias SMS service
22:32:49 <Pseudonym> There are LOTS of SMS gateways, too.
22:32:51 <shapr> Vq^: Hopefully I'll be using Telia again soon, so that sounds interesting to me.
22:32:55 <Pseudonym> Some of them are very cheap.
22:33:31 <Vq^> shapr: it's a simple http push request
22:33:32 <Nafai> shapr: Looks like it is number@txt.att.net perhaps: http://www.wireless.att.com/learn/messaging-internet/messaging/using-text-messaging.jsp
22:33:36 <allbery_b> used to be numbver@cingularme.com
22:33:36 <lambdabot> Title: Using Text Messaging | AT&T wireless services, http://tinyurl.com/34abyh
22:33:39 <shapr> Nifty, I'll try that.
22:33:40 <allbery_b> probably changed recetly
22:33:45 <allbery_b> heh
22:33:59 <Vq^> s/push/post/
22:34:04 <allbery_b> (actually cingularme.com still works)
22:35:15 * shapr sends email to both addresses.
22:35:17 <shapr> aha
22:35:26 <shapr> Little beepies, I can hear them!
22:35:38 <Nafai> shapr: Conveniently, there is also this linked from reddit: http://www.debatablybeta.com/posts/10/
22:35:40 <reffie> am i too old to become a good programmer? 24..
22:35:43 <lambdabot> Title: Sending SMS Messages With Your Web Application at Debatably Beta
22:35:51 <shapr> reffie: No
22:36:05 <reffie> i would guess you have a better chance if you start when you're a teenager
22:36:18 <shapr> reffie: I got started doing 'real' programming about 24.
22:36:26 <Tac-Tics> Getting good at something is not about age. It's about confidence.
22:36:37 <shapr> Before that I was going to be an artist... or a radiation safety guy, or an archelogist, or...
22:36:40 <Tac-Tics> The older you get, the less confidence you have in yourself to do anything you've never done before
22:36:42 <Nafai> reffie: Only because it takes time to learn; I doubt you are any less capable now, perhaps moreso
22:36:58 <shapr> Tac-Tics: Unless you forget to take your Ritalin, in which case, unlimited confidence is YOURS!
22:37:09 <shapr> Tac-Tics: Bad for the budget though.
22:37:29 <allbery_b> <Tac-Tics> The older you get, the less confidence you have in yourself to do anything you've never done before
22:37:31 <allbery_b> that depends
22:37:45 <allbery_b> I try to keep my mind flexible by learning new suff every 6 months to a year
22:38:15 <shapr> I'm on the other end of that, it's hard for me to stick with something for a month :-(
22:38:44 <shapr> allbery_b: I agree that regular changes make change easier :-)
22:39:02 <shapr> reffie: I learned to unicycle at the age of 32
22:39:09 <allbery_b> (Haskell being a case in point)
22:39:16 <reffie> i would think programming is harder than unicycle
22:39:25 <shapr> Not so much :-)
22:39:37 <reffie> heh
22:39:53 <allbery_b> not harder, just hard ina  different area
22:39:57 <allbery_b> or aspect, or something
22:39:58 <shapr> Yeah
22:40:17 <shapr> Plus with programming you can have regular small accomplishments. Write a hello world, read a file, etc.
22:40:21 * allbery_b notes that he is 43 and still learning and growing.  life does not end when you hit 20!
22:40:33 <shapr> With unicycling, it's more of an all or bleed kind of thing.
22:40:37 <reffie> allbery_b that's not my experience :(
22:40:42 <reffie> but i'm 24
22:40:43 <shachaf> > product [1..20]
22:40:44 <lambdabot>  2432902008176640000
22:41:54 <Tac-Tics> has anyone here ever tried to compile yi and gotten this error when running it?
22:41:54 <Tac-Tics> yi: panic! (the 'impossible' happened)
22:41:54 <Tac-Tics>   (GHC version 6.6 for i386-unknown-linux):
22:41:54 <Tac-Tics>         Could not compile Yi.main!
22:42:05 <reffie> why is impossible in quotes
22:42:47 <Tac-Tics> I think it's probably a developer joke
22:42:53 <Tac-Tics> but it's still an error
22:43:28 <reffie> i try writing stuff but i usually get discouraged and don't finish them
22:43:37 <allbery_b> it's supposed to be impssible, but obviously it happened.  therefore 'impossible' in quotes
22:43:58 <reffie> and start doing something else
22:44:09 <allbery_b> I haven't seen that but haven't built yi at all recently
22:45:37 <reffie> basically i have a very short attention span
22:45:59 <allbery_b> ADD?
22:46:04 <reffie> no
22:46:53 * allbery_b has actually had a fair amount of trouble finishing stuff of late --- depression, and the drug the doctor put me on turned out to cause problems of its own.  feh
22:47:30 <reffie> :(
22:47:46 <reffie> basically life sucks
22:48:23 <Adamant> life is what you make it
22:49:10 <shapr> Yeah, truly.
22:49:15 * allbery_b is working on getting himself straighened out
22:49:30 <Tac-Tics> This is #haskell. The only things that officially suck are side effects, imperative languages, and dynamically typed languages
22:49:33 <reffie> i suck, so my life sucks too :/
22:49:39 <allbery_b> in fact I should probably be heading to bed and seeing if I actually wake up tomorrow morning (ah, drug interactions...)
22:49:42 <shapr> reffie: But you can change both of those yourself.
22:49:47 <reffie> it's hard
22:49:50 <shapr> Yes it is.
22:49:52 <shapr> But it's worth it.
22:51:51 <Tac-Tics> learning Haskell isn't going to turn anyone's life around
22:52:08 <Tac-Tics> well, it may turn their world upside-down, but not around
22:52:24 <reffie> what do you mean
22:52:35 <Tac-Tics> Haskell is hard and weird
22:52:45 <reffie> i guess
22:53:16 <psykon> good things in life are hard to achieve
22:53:20 <psykon> get used to it
22:53:38 <reffie> then maybe it's not worth living
22:53:43 <Tac-Tics> =-/
22:53:50 <reffie> (no, i'm not going to kill myself)
22:53:54 <psykon> suicide is a perfectly valid option
22:54:11 <Pseudonym> Valid by which metric?
22:54:18 <aleator> recommending it isn't btw :)
22:55:02 <Tac-Tics> stupid yi
22:55:08 <Tac-Tics> I want to run you!
22:55:43 <reffie> do you consider being a good programmer as a good thing?
22:56:01 <Tac-Tics> Programming is just a skill
22:56:04 <Tac-Tics> Like being able to aim a gun
22:56:07 <Tac-Tics> only more deadly
22:57:04 <psykon> programming isn't really a skill
22:57:10 <psykon> it's more like an art
22:57:21 <Tac-Tics> arts are skills
22:57:23 <reffie> i'm not so sure
22:57:25 <Tac-Tics> you can be skilled at drawing
22:57:30 <Tac-Tics> it's very arty indeed though
22:57:39 <Pseudonym> It's more correctly a craft.
22:57:53 <Pseudonym> Artists make useless things.  Artisans make useful things.
22:58:09 <reffie> there are a lot of useless programs
22:58:11 <psykon> programmers might make useless things
22:58:35 <Tac-Tics> I solely make useless things
23:01:57 <reffie> i just don't know if i can become good enough to be competitive
23:02:08 <Pseudonym> Competitive with whom, exactly?
23:02:11 <Pseudonym> This isn't a race.
23:02:16 <reffie> there's a limited number of jobs
23:02:27 <Tac-Tics> There's a comparable number of jobs
23:02:43 <reffie> *good jobs
23:02:48 <shapr> reffie: You're only competing with yourself.
23:02:51 <Tac-Tics> there's no such thing as a good job
23:02:56 <Tac-Tics> or it wouldn't be called as such
23:03:29 <roconnor> jobs don't have to suck by definition.
23:03:56 <Tac-Tics> roconnor: you're just making this more complicated =-P
23:04:08 <reffie> shapr if i want to get a job, i have to compete with all other people who applied for that job
23:04:18 <roconnor> maybe ``suckiness isn't a defining characteristic of a job'' is a better way to say it.
23:04:44 <Tac-Tics> well, my job definitely sucks ^^;
23:05:05 <Tac-Tics> setup: cannot satisfy dependency gtk>=0.9.11...... I know I have gtk installed.....
23:05:15 <aleator> Thats better than sucking at your job.
23:05:23 <psykon> reffie, i'll let you in a little secret
23:05:30 <psykon> dedication beats intelligence
23:05:37 <shapr> definitely
23:05:49 <psykon> when they are combined, you have a champion
23:05:58 <shapr> I also say that skill & training always beats raw talent.
23:06:02 <wli> There is no formula.
23:06:08 <wli> Not even those.
23:06:11 <psykon> wli, you know what i mean
23:06:15 <aleator> Btw. vincenz and others amused me with stuff like `on` `over`and mapend yesterday. Is there some place I can mine for more nuggets like these?
23:06:23 <coffeemug> dedication only beats intelligence if a) the dedicated person posesses a certain amount of intelligence and b) other intelligent people aren't dedicated
23:06:47 <psykon> coffeemug, that's pretty obvious
23:06:52 <wli> What's `over` ?
23:07:00 <coffeemug> of course it is
23:07:19 <shapr> But you only have to 'beat' enough people to get a job.
23:07:21 <aleator> wli: if i remember correctly it was reversed on.
23:07:21 <reffie> the problem is that i'm not able to dedicate myself on things for a long period of time
23:07:27 <shapr> reffie: So change that.
23:07:33 <psykon> reffie, you have a serious problem then
23:08:09 <aleator> So.. Only perk about beeing smart is that you can also be lazy?
23:08:23 <Tac-Tics> I'm plenty lazy, that's for sure
23:08:40 <psykon> Tac-Tics, doesn't work the other way around :P
23:08:47 <shapr> I'm not sure that's a perk, you get passed by those who were forced to learn dedication.
23:09:05 <Tac-Tics> My mom always said I was a purist, and my teachers always told me I'm lazy. That's why I chose Haskell
23:09:17 <shapr> My preference is to drop into the smartest bunch of people I can find and try to keep up.
23:09:44 <psykon> shapr, don't keep up, pass them :)
23:09:55 <shapr> Heh, good point
23:11:48 <taruti> damn GHC. I had a nice example for a pretty but inefficient way to compute things and now the new GHC optimizes it to be fast ._.
23:12:11 <Pseudonym> Even better, do something slightly different from them.
23:12:24 <Pseudonym> Don't try to beat Oleg at his game.  Seriously.
23:12:38 <wli> What is Oleg's game?:
23:12:42 <oerjan> @remember taruti damn GHC. I had a nice example for a pretty but inefficient way to compute things and now the new GHC optimizes it to be fast ._.
23:12:43 <lambdabot> Done.
23:12:49 <reffie> oleg is a genius
23:14:30 <wli> That's not a meaningful answer.
23:14:40 <Pseudonym> ?quote OlegFact
23:14:40 <lambdabot> No quotes match. You speak an infinite deal of nothing
23:14:42 <Pseudonym> ?quote OlegFacts
23:14:42 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
23:14:44 <Pseudonym> ?quote OlegFacts
23:14:45 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
23:14:46 <Pseudonym> ?quote OlegFacts
23:14:47 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
23:14:48 <Pseudonym> ?quote OlegFacts
23:14:48 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
23:14:55 <Pseudonym> We surely have more facts than that.
23:14:56 <Pseudonym> ?quote OlegFacts
23:14:56 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
23:15:02 <Pseudonym> ?quote Oleg
23:15:02 <olsner> @quote oleg
23:15:02 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
23:15:02 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
23:15:03 <wli> Pardon me if I'm not so into Oleg worship.
23:15:11 <Pseudonym> ?quote Oleg
23:15:11 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
23:15:13 <Pseudonym> ?quote Oleg
23:15:13 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
23:15:15 <Pseudonym> ?quote Oleg
23:15:15 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
23:15:18 <Pseudonym> Damn.
23:15:18 <olsner> it's kind of a haskell meme
23:15:35 <wli> The infrastructure required to implement RSA at the type level would actually be useful for things other than RSA.
23:16:11 <shapr> oleg spam!
23:16:47 <Pseudonym> Oleg isn't an object of worship.
23:17:00 <shapr> He's a function of ... ?
23:17:01 <Adamant> This is not an Oleg
23:17:03 <Pseudonym> He just does all the cool type hackery that everyone else doesn't even know needs doing.
23:17:31 <Pseudonym> I have the curious distinction of having inspired two Oleg papers.
23:18:30 <shapr> That's cool!
23:18:57 <Pseudonym> It's nowhere near as cool as co-authoring.
23:19:05 <quicksilver> wli: Oleg's "game" is that he has a very unusually clear view of what is possible and not possible with the haskell type-system
23:20:29 <Pseudonym> But I'm a bit honoured to have come across 1.5 problems worthy of Oleg.
23:32:12 <wli> However, it's unclear to me that primality etc. typeclasses on type numerals are so trivial as to be left as exercises to readers.
23:32:40 <quicksilver> primality certainly doesn't strike me as trivial
23:32:52 <quicksilver> since it's a negative property and TCs don't express negation well
23:33:21 <quicksilver> however I imagine you can do something like have a 'prime factors' TC you build up in parallel
23:33:25 <quicksilver> not sure
23:33:56 <wli> The thing people most want to express is probably GF(p^n).
23:34:23 <quicksilver> I imagine ghc might turn into a rather slow compiler if compiling your code involved proving whether or not a mersenne prime was prime :)
23:35:39 <wli> Not ghc's problem. If you ask it to do such things it's your problem.
23:35:49 <quicksilver> that's true
23:36:06 <quicksilver> but in a sufficiently complex TC system the programmer may not be entirely aware of what he has asked for
23:36:46 <quicksilver> and a type error message resulting for RSA at the type level would be a sight to see
23:38:38 <wli> Another Great Polymorphic Scare?
23:44:51 <olsner> "no instance for InvalidRSAKey BuyLicense"
23:46:55 <olsner> anyway, it's kind of a wtf that haskell has features that require Oleg the mythical type hacker to make use of
23:48:28 <Tac-Tics> @src Typeable
23:48:29 <lambdabot> Source not found. Take a stress pill and think things over.
23:49:06 <oerjan> @index Typable
23:49:07 <lambdabot> bzzt
23:49:11 <oerjan> @index Typeable
23:49:12 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
23:54:23 <Tac-Tics> @index Unique
23:54:23 <lambdabot> Data.Unique
23:54:31 <Tac-Tics> @hoogle a -> Unique
23:54:32 <lambdabot> No matches, try a more general search
23:54:36 <reffie> http://video.google.com/videoplay?docid=-6487851886765386610 <- best song ever
23:54:37 <lambdabot> Title: Deftones - Riviere
23:56:57 <oerjan> Tac-Tics: i don't think Unique's can be made outside the IO monad
23:57:17 <Tac-Tics> You'd think that
23:57:30 <Tac-Tics> @hoogle IO Unique
23:57:31 <lambdabot> Data.Unique.newUnique :: IO Unique
23:57:34 <Tac-Tics> cool!
