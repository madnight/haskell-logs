00:00:13 <omniscientIdiot> yeah
00:00:44 <omniscientIdiot> incidentally, if you wrap (a -> m b)'s in the Kleisli constructor, you can use its (>>>) to compose.
00:00:51 <omniscientIdiot> @src Kleisli (>>>)
00:00:51 <lambdabot> Source not found. It can only be attributed to human error.
00:02:22 <omniscientIdiot> @type \f g x -> f x >>= g -- I think this is it.
00:02:24 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
00:02:57 <omniscientIdiot> > Kleisli getLine >>> Kleisli readIO
00:02:58 <lambdabot>  Couldn't match expected type `a -> m b'
00:03:30 <monochrom> I'm wondering if getLine takes a parameter at all
00:03:31 <Pseudonym> Ah, yeah.
00:03:33 <omniscientIdiot> wait, getLine isn't a Kleisli
00:03:44 <Pseudonym> > Kleisli hGetLine >>> Kleisli readIO
00:03:44 <lambdabot>   Not in scope: `hGetLine'
00:03:44 <omniscientIdiot> d'oh
00:03:49 <Pseudonym> Erm.
00:03:50 <Pseudonym> Something.
00:04:03 <monochrom> @src readLn
00:04:03 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
00:04:17 <Pseudonym> Oh well.
00:04:20 <monochrom> getLine >>= readIO
00:04:32 <omniscientIdiot> ordinary bind, then :)
00:04:59 <olsner> :t readIO
00:05:01 <lambdabot> forall a. (Read a) => String -> IO a
00:05:13 <omniscientIdiot> @ty Kleisli readIO
00:05:14 <lambdabot> forall a. (Read a) => Kleisli IO String a
00:05:38 <omniscientIdiot> Kleisli m, for some Monad m, is an Arrow
00:06:08 <dmwit> > Kleisli (const getLine) >>> Kleisli readIO
00:06:09 <lambdabot>        add an instance declaration for (Show (Kleisli IO a1 a))
00:06:36 <omniscientIdiot> it works, just no show :)
00:06:42 <dmwit> right
00:06:55 <olsner> so, Kleisli is fairly obvious after all... but why the wicked name? :P
00:07:21 <dmwit> Because Kleisli was such a smart guy?
00:07:22 <omniscientIdiot> I presume it's someone's name
00:07:55 <omniscientIdiot> > runKleisli (arr id)
00:07:56 <lambdabot>  Add a type signature
00:08:02 <omniscientIdiot> @type runKleisli (arr id)
00:08:03 <lambdabot> forall a (m :: * -> *). (Arrow (Kleisli m)) => a -> m a
00:08:20 <omniscientIdiot> arr id = return I think
00:08:55 <omniscientIdiot> > runKleisli (arr id) 1 :: [Int]
00:08:56 <lambdabot>  [1]
00:08:59 <omniscientIdiot> yep :)
00:09:13 <Pseudonym> :t arr id
00:09:15 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
00:09:26 <omniscientIdiot> a = Kleisli []
00:09:30 <Pseudonym> :t Kleisli return
00:09:32 <lambdabot> forall a (m :: * -> *). (Monad m) => Kleisli m a a
00:10:52 * omniscientIdiot thinks LB's kind annotations aren't terribly helpful when the kind can be inferred from class membership
00:11:05 <olsner> @src Kleisli pure
00:11:06 <lambdabot> Source not found. Wrong!  You cheating scum!
00:11:08 <olsner> @src Kleisli arr
00:11:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:11:22 <omniscientIdiot> @type Kleisli
00:11:24 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
00:11:39 <omniscientIdiot> ^^ has to be a Kleisli to pass it to Kleisli :)
00:12:40 <aegis17> Alright, it's gotten retardedly late for me, I'm getting some sleep.  Thanks for the help you guys.
00:13:28 <olsner> oh great, time to begin the trek to work
00:15:34 <balodja> Is there any generic class like 'Category' in terms of which there is a possibility to define a composition (.)?
00:16:08 <Pseudonym> Almost.
00:16:14 <Pseudonym> Arrow is as close as you get.
00:16:25 <balodja> omg
00:16:33 <Pseudonym> But lots of categories are Freyd categories.
00:16:54 <Pseudonym> :t pure
00:16:56 <lambdabot>     Ambiguous occurrence `pure'
00:16:56 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
00:17:10 <Pseudonym> :src Control.Applicative
00:17:15 <Pseudonym> Erm.
00:17:19 <Pseudonym> ?src Control.Applicative
00:17:19 <lambdabot> Source not found. It can only be attributed to human error.
00:17:54 <Pseudonym> Anyway.
00:17:55 <Pseudonym> :t arr
00:17:55 <omniscientIdiot> olsner: note that many of the definitions for (>>=) name the second arg 'k', for Kleisli.
00:17:57 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
00:17:59 <Pseudonym> :t (>>>)
00:18:01 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
00:18:16 <Pseudonym> Satisfying: arr id >>> a = a >>> arr id = a
00:18:23 <Pseudonym> And arr (f . g) = arr g >>> arr f
00:18:26 <omniscientIdiot> @src [] (>>=)
00:18:26 <lambdabot> m >>= k     = foldr ((++) . k) [] m
00:18:31 <Pseudonym> That is, essentially, a contravariant functor.
00:19:02 <Pseudonym> The catch is that Arrows also support:
00:19:04 <Pseudonym> :t first
00:19:06 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
00:19:20 <omniscientIdiot> @src Arrow
00:19:20 <lambdabot> class Arrow a where
00:19:20 <lambdabot>     arr, pure   :: (b -> c) -> a b c
00:19:20 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
00:19:20 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
00:19:20 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
00:19:22 <Pseudonym> With some axioms for that thrown in.
00:19:22 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
00:19:24 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
00:20:00 <balodja> (&&&) is a product?
00:20:06 <Pseudonym> Kinda.
00:20:10 <Pseudonym> It's a type of product.
00:20:29 <Pseudonym> map (id &&& (*2)) [1,2,3]
00:20:33 <Pseudonym> > map (id &&& (*2)) [1,2,3]
00:20:38 <lambdabot>  [(1,2),(2,4),(3,6)]
00:21:56 <omniscientIdiot> f &&& g = arr (\x -> (x, x)) >>> (f *** g)
00:22:25 <Pseudonym> Right, thus proving that (&&&) is redundant.
00:23:24 <omniscientIdiot> second f = arr swap >>> first >>> arr swap where swap = (\(x,y)->(y,x))
00:23:33 <Pseudonym> Right.
00:23:40 <Pseudonym> Now define (***) in terms of first and second and you're done.
00:23:58 <omniscientIdiot> @src (***)
00:23:59 <lambdabot> f *** g = first f >>> second g
00:24:01 <omniscientIdiot> :P
00:24:04 <Pseudonym> :-)
00:25:43 <balodja> Good mind-exercise :)
00:27:08 <Pseudonym> Really interesting, though, is the fact that not all of the arrow axioms are axioms.
00:27:32 <Pseudonym> The free theorem for first is:
00:28:00 <P_D> I've got a block of haskell I need to include in a latex document.  Verbatim is killing my tabs.  Suggestions?
00:28:12 <Pseudonym> a >>> f = g >>> b  => first a >>> arr (f *** h) = arr (g *** h) >>> first b
00:28:39 <Pseudonym> P_D: Don't use tabs.
00:28:45 <P_D> Spaces?
00:28:49 <Pseudonym> Yup.
00:29:16 <P_D> great, thanks.
00:29:30 <Pseudonym> Anyway, from that free theorem, you can prove two of the three axioms for first.
00:29:45 <Pseudonym> That's a fun exercise.
00:32:18 * vincenz thinks the TAB key should be remapped to smack the user
00:36:42 <balodja> Hm, (***) and (&&&) are for products. And what about interface for sums?
00:37:31 <Pseudonym> What would the type be?
00:37:43 <Pseudonym> It would involve Either, presumably.
00:37:54 <Pseudonym> What would the type be?
00:37:56 <Pseudonym> It would involve Either, presumably.
00:38:03 * omniscientIdiot double-takes
00:39:02 <Pseudonym> I have to go.
00:39:04 <Pseudonym> Nytol!
00:40:51 <dmwit> :t either
00:40:54 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:43:21 <dmwit> :t (left, right, (+++), (|||)) -- for balodja
00:43:23 <lambdabot> forall (a :: * -> * -> *) b c d (a1 :: * -> * -> *) b1 c1 d1 (a2 :: * -> * -> *) b2 c2 b' c' (a3 :: * -> * -> *) b3 d2 c3. (ArrowChoice a, ArrowChoice a1, ArrowChoice a2, ArrowChoice a3) => (a b c ->
00:43:23 <lambdabot>  a (Either b d) (Either c d), a1 b1 c1 -> a1 (Either d1 b1) (Either d1 c1), a2 b2 c2 -> a2 b' c' -> a2 (Either b2 b') (Either c2 c'), a3 b3 d2 -> a3 c3 d2 -> a3 (Either b3 c3) d2)
00:43:46 <balodja> dmwit: yeah, that's. thanks
00:46:15 <balodja> So, for every category, that can be defined in haskell, there is at list one product. But it's not relevant to sums?
00:48:29 <balodja> s/at list/at least :)
01:06:59 <quicksilver> balodja: if, by defining categories in haskell, you mean mapping them directly and elementarily into the type system
01:07:18 <quicksilver> balodja: then there will always be a product, since haskell's type system is a CCC. (approximately).
01:07:56 <quicksilver> balodja: of course if you want to model categories *in* rather than *onto* the type system, you can do whatever you want. But then arrows wouldn't be functions, typically.
01:15:56 <quicksilver> eyuck!
01:16:19 <quicksilver> Hudak-- # nasty caching scheme using unsafePerformIO and unsafePtrEquality
01:18:50 <sjanssen> quicksilver: where?
01:21:12 <quicksilver> sjanssen: http://www.nabble.com/Troubles-understanding-memoization-in-SOE-t4502151.html
01:21:14 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - Troubles understanding memoization in SOE, http://tinyurl.com/2b3q7d
01:21:19 <quicksilver> sjanssen: (apparently it's an example in SOE)
01:22:49 <sjanssen> yikes!
01:26:13 <quicksilver> sjanssen: yeah, that was my reaction :)
01:31:49 <quicksilver> 'ReaderT doesn't work' : discuss
01:32:04 <Cale> quicksilver: hm?
01:32:07 <quicksilver> The objective of the reader monad is to hide the plumbing of 'passing the same argument to a bunch of actions'
01:32:22 <quicksilver> however, when you use it in practice, only some of your actions needed that
01:32:29 <quicksilver> the others were in the underlying monad, so you have to lift them
01:32:39 <quicksilver> so you win some, by removing some explicit arguments
01:32:48 <quicksilver> but you lose some, by adding a bunch of explicit 'lift's
01:33:05 <quicksilver> seems to me you rarely succeed in improving the look of the code overall
01:33:18 <Cale> Monad transformers should always be newtyped
01:33:41 <quicksilver> that doesnt' solve the explicit lift problem though
01:33:47 <Cale> and you should do all the lifting in one place, and wrap the lifted things in the data constructor for your newtype
01:34:24 <quicksilver> but if you're using a whole bunch of different IO actions, say around 20
01:34:33 <quicksilver> that's a lot of boilerplate to make lifted versions of them all
01:35:12 <Cale> for IO, you can make your new monad an instance of MonadIO and use liftIO -- that does increase the overhead a bit, but not any more than any other monad transformer over IO
01:35:22 <quicksilver> you can mediate with a typeclass of course
01:35:30 <quicksilver> an extra typeclass which does auto-lifting
01:36:07 <quicksilver> at least, I think you can
01:36:20 <quicksilver> I think you might need an extra typeclass and another newtype
01:36:25 <Cale> The rest of the stuff, I just recommend lifting manually, since it's uncommon to have another kind of base monad with so many primitives that it's awkward to do that
01:36:44 <quicksilver> Cale: yeah, it's IO I'm thinking of
01:36:50 <quicksilver> Cale: or other monads with lots of primitives like GL
01:36:58 <quicksilver> (which is really IO, but for the sake of the argument it might be GL)
01:37:02 <Cale> Is there a GL monad now?
01:37:04 <quicksilver> no
01:37:09 <quicksilver> but it would be nice if there was
01:37:39 <scodil> why? all the important gl functions use Ptrs
01:38:11 <scodil> well actually, now that i think about it...
01:43:04 <quicksilver> scodil: hardly any of them do?
01:43:23 <quicksilver> scodil: just texture + bitmap loading ones
01:43:33 <quicksilver> I don't think it actually matters, even so :)
01:43:48 <quicksilver> there's no reason why you can't allow a GL monad to operate on Ptrs
01:44:54 <scodil> vertex arrays
01:45:18 <scodil> all the new buffer object stuff
01:45:25 <fax> picking
01:45:41 <scodil> which is all the more important in haskell, because calls to glVertex are that much more expensive
01:45:42 <fax> glLoad/MultMatrix
01:51:15 <quicksilver> why are calls to glVertex more expensive?
01:51:35 <scodil> did anyone see this? http://hackage.haskell.org/trac/ghc/ticket/1610
01:51:36 <lambdabot> Title: #1610 (Make arrays safer) - GHC - Trac
01:54:09 <scodil> quicksilver: how could they not be? how are you gonna get the haskell values onto the C stack before making the underlying call?
01:56:44 <scodil> there was a thing on reddit a while back abound a gl monad. seems kind of pointless. opengl is like a client/server connection between you and the gpu. if that's not IO i don't know what is.
01:58:43 <quicksilver> scodil: it would be IO underneath
01:58:57 <quicksilver> scodil: it's just a way of restricting callback types
01:59:07 <quicksilver> scodil: and annotating your actions with accurate types
01:59:08 <augustss> which is a good thing!
01:59:24 <scodil> what do you mean 'restricting callback types'?
02:00:30 <quicksilver> if you have a callback-taking action GL a -> GL a
02:00:39 <quicksilver> then you know that it can't do IO-only stuff
02:00:42 <quicksilver> it can only do GL stuff
02:00:53 <quicksilver> in particular, you would know it couldn't modify IORefs
02:00:57 <quicksilver> or call unrestricted IO actions
02:00:59 <quicksilver> no File IO
02:01:01 <quicksilver> etc
02:01:09 <scodil> but you just said it would be IO underneath
02:01:13 <quicksilver> right
02:01:19 <quicksilver> but you wouldn't export that ability
02:01:30 <quicksilver> in principle, somewhere, there would be an unsafeIOtoGL
02:01:41 <quicksilver> but you wouldn't keep that non-exported in a private module
02:01:58 <quicksilver> so consumer code would only be able to build GL actions out of GL actions
02:02:05 <quicksilver> s/wouldn't/would/
02:03:12 <scodil> what is the gain?
02:03:32 <scodil> you can't modify IO refs, but you can still mess up your openGL state
02:03:33 <quicksilver> the gain is accurate types
02:03:36 <quicksilver> right
02:03:52 <quicksilver> but you can't mess with other IO
02:04:01 <quicksilver> you can write drawMySpaceship :: GL ()
02:04:02 <steven_ashley> scodil: also, if your smart enough about it you can remove redundant gl calls on the fly
02:04:06 <quicksilver> and know it doesn't do any io
02:04:17 <steven_ashley> in some cases anyway
02:04:22 <scodil> steven_ashley: for instance?
02:04:27 <quicksilver> true, but that's quite a bit harder :)
02:04:34 <quicksilver> redundant pushMatrix woudl eb the obvious one
02:04:39 <steven_ashley> yep
02:04:56 <quicksilver> caused by nesting two preservingMatrix'es
02:06:16 <matthew-_> I would imagine that kinda thing is taken care of by the driver
02:07:00 <steven_ashley> probably so but there are other uses for this kind of thing
02:07:10 <scodil> so what types of errors are prevented by not allowing other IO to happen during GL actions? The only way to modify openGL state is through the API, so your other IO actions can't have side effects that effect openGL. and the GL api itself is stateful so you still have to worry about evaluation order within the GL actions
02:07:41 <quicksilver> well, things like GL actions not being able to read files, or modify your IORefs
02:08:01 <quicksilver> or fork threads
02:08:24 <steven_ashley> opengl uses local thread state doesnt it?
02:08:39 <quicksilver> I imagine so
02:08:58 <matthew-_> yes it does
02:09:11 <matthew-_> um, ok, so how would taking a video work?
02:09:23 <matthew-_> you say to opengl: "convert the current rendered screen to a texture"
02:09:33 <matthew-_> then "let me grab that texture off you"
02:09:58 <matthew-_> you want to pass in buffers as Ptrs that allow you to efficiently grab the texture and then write it out to disk
02:11:01 <scodil> i'd imagine you would have IO actions that take GL actions, run them, then return gl object handles, which you then use to call the old-fashioned IO based gl api, to get at the contents of memory
02:11:39 <scodil> either that or you have to lift the whole Storable / StorableArray api into the GL monad
02:14:46 <quicksilver> well you could do that, or something like it
02:14:54 <scodil> the only immediately visible benefit I can imagine is preventing illegal calls to gl functions outside of begin/end blocks. the api is pretty well segregated into functions that are allowed within the blocks, and those that aren't
02:14:57 <quicksilver> the storable API is much smaller than the whole GL api :)
02:16:20 <vincenz> @seen bringert
02:16:21 <lambdabot> I saw bringert leaving #haskell 45m 59s ago, and .
02:16:22 <vincenz> @bot
02:16:22 <lambdabot> :)
02:17:33 <leila> hi all
02:17:45 <vincenz> hello
02:18:06 <vincenz> als je wil, er is ook een nederlands haskell kanaal: #haskell.dut
02:18:38 <leila> does anyone know where i can look up errors reported back while using hugs98 ?
02:18:49 <leila> dank je, maar engels zou prima moeten gaan ^^:
02:18:53 <vincenz> oki
02:20:22 <leila> <-- trying to figure out the class / Instance thing (i create an class Collection c and want to make it work for a data Set a = Set a (Set a))
02:20:41 <vincenz> leila: do you have some code?
02:20:42 <vincenz> @paste
02:20:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:20:46 <leila> sure
02:20:52 <vincenz> Might be easier to help that way
02:22:15 <leila> http://hpaste.org/2887
02:24:16 <quicksilver> leila: your class Collection doesn't know anything about the typa 'a'
02:24:19 <vincenz> yes
02:24:35 <quicksilver> leila: so those type sigs don't make much sense to the compiler (interpreter)
02:24:54 <leila> i see
02:24:56 <quicksilver> leila: it's interpreting 'a' as a universal
02:25:11 <quicksilver> to do collections like that you need the collection type *and* the element type
02:25:13 <vincenz> leila: what you want is
02:25:23 <quicksilver> which means you need multi-parameter classes
02:25:25 <vincenz> Collection c a where
02:25:30 <quicksilver> not sure if hugs can do that
02:25:34 <vincenz> add :: a -> c a -> c a
02:25:42 <vincenz> Collection (c :: * -> *) a where
02:25:43 <vincenz> add :: a -> c a -> c a
02:25:55 <vincenz> but yeah, hugs might not be able to handle that
02:26:04 <quicksilver> well you have two choices for 'c'
02:26:12 <quicksilver> you can make c "Set" or "Set a"
02:26:18 <quicksilver> (to use your first excample)
02:26:23 <vincenz> qpoint
02:26:41 <leila> ERROR "petproject.hs":1 - Haskell 98 does not support multiple parameter classes
02:26:41 <leila>  (tried that one already ^^)
02:26:43 <vincenz> but personally I'd think a collection should be a functor
02:27:03 <quicksilver> vincenz: it should be a functor, but its parameters might be in the wrong order, or something
02:27:07 <scook0> vincenz: sure, but you also have things like ByteString
02:27:16 <scook0> which carry an implied element type
02:27:17 <quicksilver> vincenz: so it can be restricting to enforce 'c a'
02:27:32 <vincenz> scook0: point 2
02:27:48 <vincenz> scook0: but I think that's an issue that should be resolved otherwise
02:28:11 <leila> ok i think i get 50% of that, i will read up on Functor
02:28:20 <quicksilver> leila: if you're just playing, you could fix 'a'
02:28:30 <quicksilver> leila: you could for example fix 'a' to "Int"
02:28:36 <quicksilver> leila: and only play with collections of Ints
02:28:44 <quicksilver> leila: that would let you define add, remove, count etc
02:29:30 <scook0> Functor is interesting in its own right, but I don't think it'll help much here
02:29:34 <leila> that would work yes, but that would be kind of missing the point of having all that polymorphism
02:29:55 <quicksilver> leila: true. I don't think you can get that polymorphism going in hugs, but maybe I'm missing a clever way of encoding it.
02:30:09 <quicksilver> well, you can do it with 'data' but not with class
02:30:25 <vincenz> @join haskell-hac07
02:30:31 <vincenz> @join #haskell-hac07
02:30:32 <scook0> hugs doesn't support MPTC at all?
02:30:35 <leila> yup data i already done
02:30:39 <doserj> hugs -98 does
02:31:07 <scook0> yeah, I thought it did
02:31:14 <leila> hmm indeed
02:31:18 <KatieHuber> leila: is this something like what you need: http://hpaste.org/2888
02:31:19 <leila> let me try this again
02:31:33 <KatieHuber> (look down to "class Fringe" which is kinda like your "class Collection"
02:32:32 <KatieHuber> oh, your "Set" and "Bag" were classes in their own right, weren't they
02:32:36 <vincenz> KatieHuber: good point, no need for the element type if it's a functor
02:32:38 <scook0> the difference seems to be that Collection allows removal of specified elements
02:32:44 <vincenz> KatieHuber: no they're dataConsts
02:32:46 <vincenz> and tyconsts
02:33:23 <KatieHuber> so they are
02:33:37 <KatieHuber> I think what I have should work then
02:33:45 <vincenz> either way, Set is never going to work
02:33:54 <vincenz> eventually she'll have to add eitehr an Ord or an Eq constraint
02:33:57 <vincenz> on the element
02:34:17 <KatieHuber> I wasn't at all sure what was intended by those data definitions
02:34:35 <vincenz> KatieHuber: I Set is a list and Bag is a list of lists
02:34:42 <vincenz> +guess
02:35:15 <leila> thats about right, set and bag are just the normal math versions (just that i didnt use [] for constructing them)
02:35:26 <leila> also it seem that hugs -98 seems to swallow it
02:35:29 <KatieHuber> anyway, disregarding that for a moment, add should be add :: a -> c a -> c a and so forth
02:35:42 <vincenz> leila: the problem is that eventually you'll need to compare the elements to make sure you have no duplicates, at which point you'll have to add a constraint to your element type
02:35:54 <vincenz> KatieHuber: yeah, I completely oversaw the fact that there was no need for 'a' :)
02:36:18 <leila> vincenz, or add the constraint in the class Collection like: Eq a => a -> c a -> c a
02:36:30 <vincenz> leila: yep :)
02:36:39 <vincenz> leila: I guess you're already there then, no point in me making more remarks
02:37:13 <leila> still digesting all that info ^^; (not used to more than one ppl jumping up in irc :))
02:38:04 <vincenz> @stereo
02:38:04 <lambdabot> Unknown command, try @list
02:38:08 <vincenz> @quote stereo
02:38:08 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
02:38:11 <vincenz> meh
02:38:14 <vincenz> @quote stereo
02:38:14 <lambdabot> z0d says: What was the stereo quote?
02:38:15 <vincenz> @quote stereo
02:38:16 <lambdabot> z0d says: What was the stereo quote?
02:38:17 * vincenz sighs
02:38:18 <vincenz> it's gone!
02:38:26 <KatieHuber> that's what the first answer you got said :p
02:38:29 <vincenz> @quote elp.*stereo
02:38:29 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
02:38:32 <vincenz> @quote help.*stereo
02:38:32 <lambdabot> No quotes match. Take a stress pill and think things over.
02:38:38 <KatieHuber> leila: at least none of the 3 of us said "monad" ;)
02:38:45 * vincenz gives up
02:38:48 <vincenz> @quote monad
02:38:49 <lambdabot> droundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
02:39:01 <vincenz> KatieHuber: that's a first :)
02:39:06 <leila> hmm makes me wonder, putting the constraint on method level makes it possible to have an collection of any type 'a', but would that make sense
02:39:09 <KatieHuber> vincenz: I think so
02:39:15 <sieni> @quote stereo
02:39:15 <leila> answer: no since add / remove need it
02:39:16 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
02:39:29 <leila> and without those the collection wont function anyway
02:39:31 <sieni> what was that stereo quote?
02:39:46 <vincenz> "Welcome to #haskell, where your questions are answered in stereo"
02:39:47 <vincenz> or some such
02:39:50 <leila> and the 'Monad' thing i read about in "a gentle introduction to hugs"
02:42:30 <vincenz> leila: if it didn't make sense, there's a really good free tutorial on haskell
02:42:32 <vincenz> yah
02:42:34 <vincenz> yaht even
02:42:36 <vincenz> @where yaht
02:42:36 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
02:42:42 <KatieHuber> oi vincenz stop chasing me :p
02:42:45 * vincenz personally found it the most grokkable
02:42:51 <vincenz> KatieHuber: hey, I saw 'games' and was curious
02:42:57 <KatieHuber> :)
02:43:42 * vincenz is working on a little engine in lua
02:44:11 <KatieHuber> you and CrackBunny should get along great ;)
02:44:47 <KatieHuber> he's making a lua game engine too: http://bang2d.com/
02:44:49 <lambdabot> Title: Bang2D.com
02:44:56 <vincenz> yep, he showed me that ste :)
02:45:04 * vincenz is working on a mud engine, but mostly to get into a nice techincal framework
02:45:21 <vincenz> like complete state-serialization, live code-reloading, proper socket-scheduler
02:46:01 <KatieHuber> sounds complicated :)
02:46:07 <vincenz> nah, that's the fun of lua :)
02:46:16 <vincenz> it has really good metaprogramming capabilities
02:46:27 <vincenz> I shopped around for quite a while for a perfect language
02:46:33 <vincenz> scheme's nice, but scheme lacks metaprogramming
02:47:16 <fax> no it doesn't
02:47:29 <vincenz> fax: yes it does
02:47:39 <vincenz> you can't hang data on a function
02:48:15 <sieni> vincenz: what do you mean by that?
02:48:20 <fax> um
02:48:28 <fax> try syntax-rules
02:48:33 <vincenz> fax: I mean runtime
02:48:41 <fax> and an interpreter
02:49:03 <vincenz> sure
02:49:05 <vincenz> if I greenspun
02:49:07 <vincenz> I can do anything
02:49:10 <vincenz> but that's besides the point
02:49:17 <vincenz> as is, there's no metaprogramminig capabilities
02:49:22 <vincenz> syntax-extensions are -not- metaprogramming
02:49:22 <fax> yes there are
02:49:25 <fax> see syntax-rules
02:49:25 <vincenz> they're metasyntax if anything
02:49:32 <fax> which is standard part of the language
02:49:35 <fax> (R5RS)
02:49:37 <vincenz> that's meta-syntax
02:49:37 <leila> it seems that defining an Eq on the first element of a tuple is harder than i thought it would be
02:49:40 <vincenz> not meta-programming
02:49:43 <vincenz> but this is a bit OT in this chan
02:49:47 <vincenz> feel free to join #oasis
02:50:00 <fax> nah.. I know by now I can't convince you
02:50:08 <vincenz> then stop arguing :)
02:50:13 <KatieHuber> what do you mean by that, leila?
02:50:17 <fax> I am not arguing
02:50:26 <vincenz> leila: What are you trying to do?
02:50:31 <leila> KatieHuber, instance Eq (String, a) where
02:50:31 <leila>         (xs, a) == (ys, b) = xs == ys
02:50:53 <vincenz> leila: can't do that afaik, that would overlap with the generic tuple one
02:50:59 <KatieHuber> Eq is already defined for tuples
02:51:04 <leila> i see
02:51:20 <vincenz> well except if you had ghc and -fallow-overlapping-instances, but taht is evil
02:51:21 <KatieHuber> (in the obvious way)
02:51:24 <scook0> you should be able to define that instance on a new type of your own
02:51:50 <leila> what i figured, explains the ERROR "petproject.hs":9 - Overlapping instances for class "Eq"
02:52:18 <scook0> data WithString a = MkWithString String a
02:52:37 <vincenz> instance (Eq a) => Eq (WithString a) where ...
02:53:00 <scook0> vincenz: actually, the instance above doesn't even use a
02:53:10 <vincenz> oh right
02:53:21 <scook0> though that's a bit of a questionable practice
02:53:56 <SamB_XP> vincenz: would it work even with overlapping instances?
02:54:05 <vincenz> SamB_XP: I think so
02:54:09 <scook0> (though harsh reality might justify it in some cases)
02:54:11 <vincenz> SamB_XP: it's more specific than (a,b)
02:54:24 <SamB_XP> I mean, was the tuple instance built with overlapping instances?
02:54:52 <quicksilver> no, apaprently not
02:54:53 <vincenz> SamB_XP: Not sure I'm following
02:55:00 <quicksilver> instance (Eq a, Eq b) => Eq (a, b) -- Defined in Data.Tuple
02:55:08 <quicksilver> (that would say 'OVERLAP OK' or something, if it was)
02:55:17 <quicksilver> ghci reports about overlap settings
02:59:13 <leila> vincenz, i made it into: http://hpaste.org/2889
02:59:45 <vincenz> leila: very nice
03:00:11 <leila> finally getting understanding of the error messages
03:00:33 <vincenz> they can be confusing at times
03:00:43 <vincenz> due to type-inference, sometimes it's very very hard to locate where the error comes from
03:00:52 <vincenz> that's why error-handling is actually one of the harder parts of a compiler
03:01:05 <scook0> that looks like yet another appearance of the on combinator
03:01:28 <vincenz> scook0: yeah :)
03:01:29 <scook0> (==) = (==) `on` name
03:01:32 <quicksilver> known to its oldest friends as 'S'
03:01:37 <vincenz> scook0: was going to say that, but then I wasn't sure if 'on' was in prelude
03:01:45 <vincenz> quicksilver: or `comparing`
03:01:47 <KatieHuber> that looks weird ^_^
03:01:54 <quicksilver> it isn't.
03:02:01 <quicksilver> but it will be in the standard libs with 6.8
03:02:03 <leila> lol, that works ?
03:02:06 <vincenz> leila: yeah
03:02:09 <leila> cool
03:02:14 <vincenz> (==) `on` name == on (==) name
03:02:20 <quicksilver> I'm not sure if it's made it into the prelude
03:02:28 <quicksilver> or it it's in Data.Functions only
03:02:28 <vincenz> on f g x y = f (g x) (g y)
03:02:32 <KatieHuber> somebody said Data.Function
03:02:40 <KatieHuber> when they suggested it to me last night
03:02:42 <scook0> quicksilver: actually, I never realised on was S
03:02:42 <vincenz> that's a new one
03:02:44 <vincenz> @hoogle on
03:02:45 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
03:02:45 <lambdabot> System.Console.Readline.onNewLine :: IO ()
03:02:45 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
03:02:49 <scook0> it's so obvious now
03:02:55 <vincenz> @doc Data.Function
03:02:55 <lambdabot> Data.Function not available
03:02:58 <vincenz> @doc Data.Functions
03:02:58 <lambdabot> Data.Functions not available
03:03:11 <KatieHuber> lambdabot doesn't know about GHC 6.8 yet
03:03:24 <KatieHuber> (and not much good to leila using Hugs either way I think)
03:03:30 <leila> :info on does not yield any results for me, could be that i am outdated :)
03:03:32 <SamB_XP> lambdabot might be scared if she did know
03:03:35 <vincenz> true and true
03:03:47 <vincenz> leila: no `on` is very new
03:03:56 <KatieHuber> I ended up defining "on" locally 'cos it made the code prettier
03:04:02 <KatieHuber> what is this S thing?
03:04:06 <vincenz> KatieHuber: SKI?
03:04:06 <leila> it looks rather nice tho
03:04:18 <quicksilver> scook0: I never realised S was useful until I realised it was 'on' :)
03:04:24 <EvilTerran> @go SKI combinators
03:04:25 <xerox> 'on' is not 'S'
03:04:25 <lambdabot> http://en.wikipedia.org/wiki/SKI_combinator_calculus
03:04:25 <lambdabot> Title: SKI combinator calculus - Wikipedia, the free encyclopedia
03:04:26 <SamB_XP> lambdabot doesn't exactly get along with new GHCs
03:04:40 <leila> the thing i noticed is that Constructors must be unique, which is a shame
03:04:51 <EvilTerran> ... indeed, it's not S
03:04:54 <SamB_XP> leila: eh?
03:05:00 <fax> :t on
03:05:02 <lambdabot> Not in scope: `on'
03:05:06 <EvilTerran> (e->) ap is S, isn't it?
03:05:08 <scook0> well, that would explain why I never realised they were the same :)
03:05:12 <EvilTerran> @src ap
03:05:12 <lambdabot> ap = liftM2 id
03:05:26 <SamB_XP> @type let on f g x y = f (g x) (g y) in on
03:05:27 <xerox> 'S' is 'ap'
03:05:29 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
03:05:35 <EvilTerran> @type ap
03:05:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:05:41 <leila> SamB_XP, like i have an EmptySet and a EmptyBag, whereas sementically Empty could be used for both
03:05:55 <vincenz> leila: they're both lists
03:06:14 <quicksilver> it's closely related to S
03:06:21 <vincenz> quicksilver: everything is :)
03:06:22 <leila> vincenz, ?
03:06:25 <vincenz> quicksilver: unless you have something very simple
03:06:25 <EvilTerran> @type ap :: (e -> a -> b) -> (e -> a) -> e -> b
03:06:27 <lambdabot> (e -> a -> b) -> (e -> a) -> e -> b :: forall e a b. (e -> a -> b) -> (e -> a) -> e -> b
03:06:27 <SamB_XP> leila: 'twould confuse the poor compiler ;-)
03:06:28 <KatieHuber> presumably empty :: c a will end up being a method of your Collection class anyway, so no problem there ;)
03:06:36 <vincenz> leila: data Set a = Set a (Set a) | EmptySet
03:06:43 <vincenz> data List a = List a (List a) | EmptyList
03:06:46 <vincenz> it's a list :)
03:06:49 <vincenz> and Bag ...
03:06:53 <vincenz> well that's a List of lists
03:07:00 <leila> true
03:07:22 <leila> but i am learning how stuff works
03:07:34 <leila> but basically any 1 dimension structure is a list
03:08:12 <ToRA> hey all;  does anyone know if it is possible to test if a value has been forced or not?
03:08:16 <quicksilver> depending quite what you mean by 'basically' and 'list'
03:08:18 <EvilTerran> i think the idiomatic thing to do when you have something isomorphic to a list is to newtype list, rather than creating a new ADT
03:08:19 <leila> SamB_XP, i know, but at the same time i am telling what data it should use in the type of the function
03:08:39 <EvilTerran> as then you can use Data.List
03:08:49 <quicksilver> what about data Queue a  which is Queue [a] [a]
03:09:02 <quicksilver> EvilTerran: not necessarily, if your bjective is to learn about ADTs and haskell :)
03:09:09 <quicksilver> EvilTerran: it may be a good exercise to define your own
03:09:21 <quicksilver> EvilTerran: especially as lists have non-uniform syntax
03:09:23 <EvilTerran> if that was my objective, i'd be doing binary trees, but okay
03:09:38 <vincenz> binary trees are boring
03:09:40 <leila> which is kinda what i am doing atm, or rather filling in some practical knowledge which they happen to skip at uni
03:09:40 <vincenz> N-ary trees!
03:09:55 <leila> n-ary balanced trees
03:10:00 * vincenz winces
03:10:10 <EvilTerran> much like, if i were doing recursion, i wouldn't do, say, fibonacci numbers - that's a stupid example, I don't know why it's such a popular one
03:10:32 <EvilTerran> trees'd work again...
03:10:33 <vincenz> EvilTerran: it's simpel enough to explaini the concept of recursion
03:10:48 <leila> well then define a graph
03:10:52 <EvilTerran> exponential complexity!
03:10:52 <flux> I think (a simplistic) floodfill is a good example of recursion
03:11:02 <leila> the more general type of trees and implement bfs and dfs
03:11:17 <flux> but it needs some background, such as an array (brr, array?-)) to perform the operation on
03:11:26 <SamB_XP> leila: have you seen the definition of []?
03:11:28 <vincenz> bfs and dfs in haskell are actually surprisingly simle
03:11:33 <vincenz> s/simle/simple
03:11:49 <leila> ofc
03:11:49 * vincenz waves as he *AFKS* for lunch
03:12:03 <leila> so is almost any algo from compute science ^^:
03:12:06 <SamB_XP> of course, it's totally true that it has a non-uniform syntax
03:12:16 <SamB_XP> the type and value syntaxes don
03:12:21 <SamB_XP> 't even match
03:12:24 <leila> @src []
03:12:24 <lambdabot> data [] a = [] | a : [a]
03:12:27 <leila> now i did
03:13:43 <leila> you need to know that constructor may have the same name as the type tho
03:14:27 <scook0> type/constructor punning will boil your brain eventually
03:14:41 <leila> lol, it might
03:14:59 <scook0> which is why these days I tend to go data Foo = MkFoo
03:15:14 <scook0> it's worse when the punned constructor is for a different type
03:15:44 * scook0 has fond memories of pugs AST code...
03:16:06 <SamB_XP> Lava puns like that
03:16:09 <SamB_XP> internally
03:18:47 <leila> is 'in' a keyword ?
03:19:25 <SamB_XP> well, I can't think how I could shadow it...
03:19:37 <SamB_XP> so I'm guessing yes ;-)
03:19:55 <scook0> let a = b in c
03:19:57 <leila> ofc "slaps head" let ... in ...
03:20:19 <leila> i'll stick to el then
03:20:41 <SamB_XP> > let in = () in in
03:20:41 <lambdabot>  Parse error
03:20:55 <scook0> >let in' = () in in'
03:20:57 <SamB_XP> > in
03:20:58 <lambdabot>  Parse error
03:21:06 <SamB_XP> scook0: you missed the space
03:21:15 <scook0> > let in' = () in in'
03:21:17 <lambdabot>  ()
03:21:47 <scook0> reminds me of that obfuscated program, where every identifier is of the form (?) (??) (???) ...
03:21:49 <SamB_XP> as, on the other hand, is not a keyword no matter whether your editor highlights it or not
03:21:59 <EvilTerran> @go in in in
03:22:00 <lambdabot> 1 in = 1 in
03:22:14 <SamB_XP> hahaha
03:22:14 <EvilTerran> as is a "special", isn't it?
03:22:31 <quicksilver> SamB_XP: any more than 'qualified' is a keyword
03:23:12 <SamB_XP> EvilTerran: well, insofar as it's function in imports makes it so, yes
03:23:27 <scook0> and yet I had to edit my gtksourceview files to make type highlighted :)
03:23:53 <leila> in vi highlighting seems ok thus far :)
03:24:26 <SamB_XP> in emacs it highlights not-quite-keywords like as and qualified
03:25:13 <scook0> well, intelligently highlighting pseudo-keywords is probably beyond the capabilities of most regex-based highlighters
03:25:47 <SamB_XP> yes
03:26:07 <KatieHuber> textmate's haskell bundle highlights "otherwise" but not "qualified" which I found odd
03:26:21 <quicksilver> of course the emacs highlighter isn't actually regex-based, is it?
03:26:22 <scook0> though regex-based highlighting is a bit of a sham
03:26:27 <SamB_XP> otherwise doesn't even act special
03:26:28 <quicksilver> it's syntax-table based, I think
03:26:29 <SamB_XP> ever
03:26:32 <scook0> > otherwise
03:26:34 <lambdabot>  True
03:26:40 <SamB_XP> quicksilver: it IS regex based
03:26:53 <quicksilver> SamB_XP: it is? oh
03:26:55 <leila> i like the lambdabot btw
03:26:58 <SamB_XP> it has a syntax table for individual characters or something
03:27:01 <scook0> highlighting otherwise is understandable though
03:27:10 <scook0> since it's de-facto syntax
03:27:34 <sieni> @src otherwise
03:27:35 <lambdabot> otherwise = True
03:28:03 <scook0> (I can just imagine using otherwise for logic obfuscation ...)
03:28:06 <quicksilver> otherwise is an idiom
03:28:17 <SamB_XP> thats one of the ones where you don't have to ask whether that's the report version or the GHC version ;-)
03:28:18 <quicksilver> I have no objection to it being syntax highlighted, if it makes guards easier to read
03:28:36 <SamB_XP> quicksilver: I guess so
03:28:50 <SamB_XP> it'd be extremely odd to shadow it
03:29:54 <scook0> whack otherwise = False deep in a massive where clause...
03:31:57 <SamB_XP> wierd
03:32:03 <EvilTerran> hm... i was looking at the various Map classes, and noticed that there's (deliberately) a lot of overlap in interface
03:32:12 <SamB_XP> The form "module M" names the set of all entities that are in scope with both an unqualified name "e" and a qualified name "M.e". This set may be empty.
03:32:20 <DRMacIver> EvilTerran: Shame it doesn't have a type class, huh? :)
03:32:21 <Lycurgus> wow all I got was shi _, shi _ , bu ? _ _ _ _ _ Ren Le
03:32:22 <EvilTerran> got me thinking about writing an "IMap" class
03:32:36 <SamB_XP> EvilTerran: which map classes?
03:32:48 <nornagon> :t filterM
03:32:50 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
03:32:53 <SamB_XP> also you are doing that type/class thing again...
03:32:59 <EvilTerran> Data.Map, Data.IntMap
03:33:04 <nornagon> :t mapM
03:33:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:33:23 <DRMacIver> EvilTerran: You run into problems with the class constraints on the map methods I think.
03:33:27 <KatieHuber> Lycurgus: Google Translate says "Surprise, surprise, no matter who you permission to the birds" which doesn't mean much more to me :|
03:33:29 <EvilTerran> yes, you do.
03:33:37 <SamB_XP> DRMacIver: eh?
03:33:51 <SamB_XP> DRMacIver: I thought the problem was that Map and IntMap have different kinds?
03:33:57 <quicksilver> scook0: could be funny, yes. But I think massive where clauses are poor style.
03:34:13 <EvilTerran> if you write IMap k v m | m -> k v, you run into trouble with functions that involve maps with different value types
03:34:25 <Lycurgus> KH: ah, my client (irssi) didn't even show the underscore characters.
03:34:29 <SamB_XP> I tried something a bit like that...
03:34:36 <SamB_XP> not exactly, actually
03:34:37 <DRMacIver> SamB_XP: I was thinking more comparing association lists and Map. IntMap has a different issue I guess.
03:34:56 <SamB_XP> mine was more like Collection c i | c -> i
03:35:01 <DRMacIver> I guess that's not a major deal. You could add the constraint to the instance declaration.
03:35:11 <EvilTerran> IMap k m | m -> k (so you can define an instance for IntMap) makes writing mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a etc difficult
03:35:12 <SamB_XP> but then map was all crazy
03:35:57 <SamB_XP> it was like totally polymorphic
03:36:08 <scook0> I do remember once writing a wrapper for IntMap that could hold anything injectible to Int
03:36:11 <nornagon> @hoogle (a -> m Bool) -> [a] -> m ([a],[a])
03:36:12 <lambdabot> No matches, try a more general search
03:36:14 <scook0> (and recoverable)
03:36:31 <nornagon> @hoogle (a -> Bool) -> [a] -> ([a],[a])
03:36:31 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
03:36:32 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
03:36:32 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
03:36:34 <SamB_XP> you could use map id to convert [(k,v)] to Map k v...
03:36:44 <nornagon> @src break
03:36:44 <lambdabot> break p =  span (not . p)
03:36:49 <nornagon> @src span
03:36:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:36:52 <leila> http://hpaste.org/2891
03:37:03 <leila> meh lacks certain ellegance but seems to work
03:37:08 <EvilTerran> that'd be fromList, i think
03:37:15 <nornagon> how do I get two lists, one of which contains elements that match the condition and the other of which contains those that do not?
03:37:25 <SamB_XP> EvilTerran: I'm talking about my attempt at a collection framework ;-)
03:37:27 <EvilTerran> @src partition
03:37:27 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
03:37:27 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
03:37:27 <lambdabot>                               | otherwise = (ts, x:fs)
03:37:47 <quicksilver> > partition odd [2,4,3,4,5]
03:37:52 <lambdabot>  ([3,5],[2,4,4])
03:37:55 <EvilTerran> ah, okay
03:38:16 <leila> lol SamB_XP sounds a tad like mine experimentation
03:38:34 <scook0> those count instances are ... questionable
03:38:39 <nornagon> quicksilver: uh, where did that extra 4 come from?
03:38:49 <nornagon> er
03:38:50 <nornagon> oh.
03:38:51 <nornagon> :$
03:39:22 <leila> how is that scook0
03:39:28 <nornagon> :t partitionM
03:39:30 <lambdabot> Not in scope: `partitionM'
03:39:48 <nornagon> :t liftM2 partition
03:39:50 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m [a] -> m ([a], [a])
03:39:52 <scook0> leila: well, the Bag instance seems to be missing its else case
03:40:08 <leila> let me check, could be that i pasted wrong
03:40:21 <leila> yup ^^; it misses a line
03:40:22 <scook0> and the Map instance returns 1 even if the element isn't present (which could be intended)
03:40:33 <scook0> *Set, sorry
03:40:38 <leila> scook0, else count a r
03:41:18 <scook0> yeah, I figured you'd run into that once you tried to load it anyway
03:41:20 <leila> scook0, nope, i am forgetting to recurse
03:41:33 <SamB_XP> I wonder if there are any other langauges where you can be spending who-knows-how-long trying to figure out a way to give map more rigid type?
03:41:34 <quicksilver> ooh, more neat haskell tricks from york.ac.uk
03:42:01 <leila> SamB_XP, try brainfuck ?
03:42:09 <quicksilver> @where sparsecheck
03:42:10 <lambdabot> I know nothing about sparsecheck.
03:42:19 <quicksilver> @where+ sparsecheck http://www-users.cs.york.ac.uk/~mfn/sparsecheck/
03:42:20 <lambdabot> Done.
03:43:23 <nornagon> @hoogle [[a]] -> [a]
03:43:23 <lambdabot> Prelude.concat :: [[a]] -> [a]
03:43:32 <leila> scook0, anything you know that i can use to avoid the if .. then .. else with a more elegant structure ?
03:43:33 <nornagon> :t concatMap
03:43:35 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
03:43:48 <nornagon> :t concatMapM
03:43:49 <lambdabot> Not in scope: `concatMapM'
03:44:20 <quicksilver> nornagon: concatMapM is probably >>= for a ListT monad transformation
03:44:29 <quicksilver> nornagon: that observation may be entirely unhelpful :)
03:44:36 <nornagon> this is in IO :)
03:44:48 <scook0> leila: I suppose you could use guards, but I'm not sure if it would help at all
03:44:48 <quicksilver> so possibly you wan't >>= in ListT IO
03:45:10 <nornagon> :t liftM (concatMap (const $ return []))
03:45:12 <lambdabot> forall b a (m :: * -> *). (Monad m) => m [b] -> m [[a]]
03:45:21 <leila> scook0, it might, but i wouldnt make it more elegant ^^;
03:46:55 * EvilTerran wonders if he could do something with type families for this map interface thing
03:47:53 <SamB_XP> EvilTerran: you could wrap IntMap in one I guess
03:48:14 <Saizan> leila: you don't need parentheses around expressions in if .. then .. esle
03:48:17 <EvilTerran> given that i'm currently using fundeps, and type families alledgedly subsume fundeps
03:48:49 <scook0> actually, I think the parens help separate (a == b) from the definitional =
03:49:20 * EvilTerran likes to parenthesise guards with infix operators for that reason
03:49:43 <scook0> I like double-spacing my guards' = as well
03:49:57 <scook0> | otherwise__=__defn...
03:50:01 <leila> all that so i could do:
03:50:05 <leila> type Entity a = Set (Attr a)
03:50:05 <leila> type Token a = Bag (Attr (Entity a))
03:50:05 <leila> type State a = Bag (Attr (Token a))
03:50:55 <quicksilver> EvilTerran: I'm pretty sure type families don't subsume fundeps
03:51:10 <vincenz> re
03:51:13 <quicksilver> EvilTerran: it is claimed that they subsume 'a large, commonly used class of fundeps'
03:51:23 <EvilTerran> oh, okay.
03:51:35 <EvilTerran> they subsume this application of 'em, anyway
03:51:39 <quicksilver> EvilTerran: they can also do some things which fundeps can't do, I think?
03:51:42 <quicksilver> I'm not sure on the details
03:51:47 <EvilTerran> hence "subsume"
03:51:53 <scook0> actually, is there a predefined Bag type in any {builtin|external} libraries? I realize it's just a wrapper on Map, but still...
03:51:59 <EvilTerran> rather than just "replace"
03:52:07 * quicksilver nods
03:52:14 <vincenz> subsume typically implies it replaces -all- the functionality and adds some more
03:52:26 <vincenz> a `subsume` b === b <= a
03:52:28 <quicksilver> yes, I understand that :)
03:52:38 <quicksilver> I was just emphasising that there is no subset relationship either way
03:52:40 <EvilTerran> class IMap m where ... (!) :: m -> Key m -> Value m  -- tyfuns version
03:52:41 <quicksilver> as far as I know
03:52:47 <quicksilver> just a large useful intersection
03:53:12 <nornagon> http://hpaste.org/2892 <-- so I wrote this recursive directory listing function, but it seems to hang
03:53:37 <vincenz> nornagon: define 'hang'
03:53:51 <nornagon> it never returns, even on empty directories
03:54:00 <vincenz> maybe it's also getting '.' and '..'?
03:54:05 <nornagon> oh
03:54:08 <nornagon> snap :(
03:55:07 <entropyfails> Greetings all.
03:55:35 <entropyfails> So we have this function of type prime :: Integer -> Bool which tests for primality.
03:55:47 <entropyfails> And lets say we have some statement like
03:56:15 <entropyfails> if prime x then next-prime x
03:56:35 <entropyfails> where next-prime is of the type next-prime :: Prime -> Prime
03:56:41 <EvilTerran> you can't have "-" in names, but go on
03:56:55 <entropyfails> What parts of GHC would we need to modify to get a type that works like that.
03:57:18 <quicksilver> nornagon: I would write filterM doesDirectoryExist =<< getDirectoryContents fp
03:57:18 <vincenz> entropyfails: EvilTerran has your answer
03:57:25 <entropyfails> You'd have to add some way of signaling to the compiler that if it passes prime x then x is a prime number.
03:57:28 <leila> wb vincenz
03:57:41 <quicksilver> entropyfails: you can do that with a newtype
03:57:49 <scook0> isPrime :: Integer -> Maybe Prime
03:57:55 <quicksilver> entropyfails: newtype Prime = Prime Integer
03:57:56 <entropyfails> But I want a real prime
03:58:02 <quicksilver> and rewrite isPrime as scook0 says
03:58:14 <scook0> so isPrime "brands" its argument with a primality tag
03:58:24 <quicksilver> precisely
03:58:25 <entropyfails> Exactly
03:58:31 <scook0> though anyone with access to Prime's constructor has a proof obligation...
03:58:42 <entropyfails> *nod*
03:58:50 <entropyfails> You have to be certain that isPrime really does that.
03:58:51 <entropyfails> ;)
03:58:59 <quicksilver> you can write isPrimeBrand using the old isPrime simply as "if isPrime x then Just (Prime x) else Nothing
03:59:22 <entropyfails> Still... then you cannot do things like if isPrime x then x + 4
03:59:23 <vincenz> leila: thx
03:59:36 <entropyfails> So what I want is a type recognizer.
03:59:43 <EvilTerran> @where Coq
03:59:43 <quicksilver> or, more obscurely, do guard (isPrime x) ; return Prime x
03:59:43 <lambdabot> I know nothing about coq.
03:59:44 <entropyfails> It certainly isnt' in Haskell yet.
04:00:00 <vincenz> no, haskell needs prime types!
04:00:10 <sek> Hello, im writting some Parsec expressions parser and i want to make some code a bit neater if anyone can help: http://hpaste.org/2893
04:00:16 <entropyfails> I don't want to burden my prime type with a constructor wrapping.
04:00:35 <vincenz> sek: small suggestion: use liftM
04:00:41 <entropyfails> I want to ensure that I have a prime number for certain functions, but not loose the "numberness"
04:00:44 <scook0> if you enjoy horrible flaming death, you could instance Num Prime ;)
04:00:50 <entropyfails> *laugh*
04:00:59 <sek> vincenz, yeah i was thinking i could do this with >>= but it didnt really work
04:01:00 <vincenz> sek: cidentifier = liftM (Cident . Unqualified) identifier
04:01:01 <scook0> phantom types maybe
04:01:03 <scook0> ?
04:01:11 <sek> ah great
04:01:14 <entropyfails> hmm.
04:01:24 <quicksilver> cidentify = Cident . Unqualified `liftM` identifier
04:01:25 <scook0> data Numeric a = MkNumeric Integer
04:01:29 <quicksilver> (looks neater IMO)
04:01:31 <entropyfails> I don't think so. I don't see the mechanism for saying "isPrime" is my special "type recognizer"
04:01:41 <scook0> brandPrime :: Numeric a -> Maybe (Numeric Prime)
04:01:46 <sek> vincenz, quicksilver,  thanks alot
04:01:47 <vincenz> quicksilver: tastes vary :)
04:01:55 <EvilTerran> entropyfails, i think anything like that's going to be damn near impossible in Haskell. it's the sort of thing Coq's good for, though, i think
04:01:58 <scook0> hmm, no, that wouldn't work
04:01:58 <quicksilver> vincenz: it looks most similar to
04:02:04 <quicksilver> cidentify = Cident . Unqualified $ identifier
04:02:08 <entropyfails> Still hits with a Maybe cost. I want to say "I have a real number that ALSO happens to be prime".
04:02:13 <quicksilver> vincenz: which is what it would look like if this wasn't a monad
04:02:13 <scook0> because making Numeric a Num instance would still be broken
04:02:18 <vincenz> quicksilver: never looked at it that way ;)
04:02:19 <entropyfails> This is a reason to play with the GHC source code.
04:02:33 <entropyfails> ;)
04:02:37 <quicksilver> vincenz: I like to make the parallel clear, so I prefer the syntax which matches
04:02:56 <scook0> entropyfails: the problem is, it's difficult to pass that value to an (a -> a) function
04:03:29 <entropyfails> It isn't difficult.. it just has no realization within the current Haskell type system. Even with the upcomming extensions, it still misses this
04:03:43 <scook0> you might need subtyping, in which case don't hold your breath :)
04:03:44 <entropyfails> I think this is a better way than what Walder wants to try with positive and negative blame.
04:04:11 <entropyfails> Subtyping still doesn't cut it.. unless I want to put my entire program in the type system.
04:04:27 <vincenz> quicksilver: thx for the tip :)
04:04:30 <vincenz> quicksilver: btw, going to hac?
04:04:54 <entropyfails> So you could have a function that you get back from C that is if proper_message x then message_parse x
04:04:55 * quicksilver shakes his head
04:04:59 <vincenz> :|
04:05:21 <scook0> so it seems you want to be able to transparently treat a Prime as a Number, but not vice-versa
04:05:40 <scook0> how does subtyping fail?
04:06:13 <entropyfails> scook0: because you still cannot specify that "isPrime" is the special type recognizer.
04:06:26 <entropyfails> so there would be no way of going, at runtime, from Int -> Prime
04:06:53 <scook0> hmm, I think I see where you're going
04:07:07 <scook0> hmm
04:07:13 <entropyfails> Basically, instead of doing "casts" back and forth from the unitype lambda
04:07:40 <entropyfails> I want fully typed expressions that protect their arguments and pass along what they "find" about type at runtime
04:07:49 <entropyfails> in the sequent calculus we would have
04:07:50 <entropyfails> ___
04:08:05 <entropyfails> (prime? X) : verified >> X : prime;
04:08:07 <vincenz> you want phantomtyping
04:08:08 <entropyfails> that's Qi code...
04:08:12 <scook0> so you want (if isPrime x then ...) to let you assume primality of x in the then?
04:08:13 <entropyfails> Is that phantom typing?
04:08:23 <entropyfails> scook0: yes.
04:08:53 <scook0> that sounds Hard to do in general
04:08:56 <entropyfails> I'm trying to think up a Haskell like syntax for it and play with GHC a bit.
04:09:46 <entropyfails> scook0: yeah, it will be a bit of a project.
04:09:53 <quicksilver> I don't see how that would be different from a Maybe type
04:09:59 <scook0> maybe if you had something that desugared (if isPrime x then ...) to (case brandPrime x of Just x -> ...)
04:10:09 <entropyfails> quicksilver: because it is not a monad. ;) It is a real live int
04:10:17 <quicksilver> maybe (brandPrime x) else .. then ...
04:10:24 <quicksilver> don't see what monads have to do with it, to be honset
04:10:28 <entropyfails> scook0: interesting idea
04:10:31 <scook0> quicksilver: I think the distinction is not having to put the encoding in syntax
04:10:36 <scook0> while still having the compiler check it
04:10:53 <quicksilver> scook0: the "syntax" being using "maybe" instead of "if"?
04:11:03 <entropyfails> quicksilver: yeah.
04:11:08 <quicksilver> scook0: you lose 3 chars there but you gain back 8 from not having to type "then" and "else"
04:11:14 <quicksilver> I don't really understand that point...
04:11:24 <scook0> quicksilver: in your example, the code in "then" can't (provably) assume x is prime
04:11:28 <quicksilver> that's not anythign deep and type-theoretical, it's just renaming keywords
04:11:37 <scook0> (or perhaps I should say "checkably")
04:11:45 <quicksilver> scook0: it's just as 'provable' or not as the other case
04:11:56 <quicksilver> scook0: I have a proof obligation with brandPrime
04:12:05 <quicksilver> scook0: entropyfails has a proof obligation somewhere with isPrime
04:12:23 <entropyfails> Quicksilver: I do see that point.
04:12:23 <quicksilver> scook0: either way at some point, someone has a proof to do...
04:12:47 <scook0> I think the point is to get the compiler to implicitly chain everything after the initial proof
04:12:55 <entropyfails> quicksilver: But I don't want to have to take the type in and out of its box.
04:13:01 <quicksilver> maybe what you're saying is that you want to be able to use (+) :: Int -> Int on a Prime
04:13:09 <entropyfails> Yes
04:13:09 <quicksilver> erm
04:13:21 <quicksilver> (+) :: Int -> Int -> Int on a Prime :)
04:13:30 <vincenz> that would require an obligation of proof inside
04:13:34 <vincenz> it's possible
04:13:35 <quicksilver> well that, surely, it nothign more than a 'deficiency' in our (+)
04:13:53 <quicksilver> our (+) happens to enforce uniform types, for convenience
04:13:54 <entropyfails> using Prime as a subtype of Int proper.
04:14:05 <quicksilver> but you can imagine other (+) which don't
04:14:11 <vincenz> quicksilver: existentials?
04:14:24 <quicksilver> for example, you can imagine (Integral a,b,c) => (+) :: a -> b -> c
04:14:25 <vincenz> quicksilver: with a check to check whether it's pirme?
04:14:31 <entropyfails> quicksilver: but the idea is to not throw out the baby with the bathwater.
04:14:42 <quicksilver> entropyfails: sure
04:14:53 <quicksilver> entropyfails: but I think you need to make a strong case about what you can actually do in haskell
04:14:55 <nornagon> @. pl undo do { a <- getDirectoryContents "." ; return $ map ("/"++) a }
04:14:55 <lambdabot> map ('/' :) `fmap` getDirectoryContents "."
04:15:07 <quicksilver> entropyfails: before suggesting syntactic sugar to make it nicer
04:15:22 <entropyfails> If I could simply tell the compiler "isPrime" is my special type recognizer for Prime which is a subtype of Int, then I'm 50% of the way there.
04:15:25 <quicksilver> entropyfails: i.e. : Using our current class system I can manage *this* or *this*, but what I really want is this...
04:15:38 <nornagon> :t fmap
04:15:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:15:41 <entropyfails> quicksilver: Ok.
04:15:52 <EvilTerran> nornagon, in this case, fmap = liftM
04:15:55 <entropyfails> I'm just thinking out loud here. ;)
04:15:59 <nornagon> EvilTerran: yep :)
04:16:20 <quicksilver> entropyfails: do you see my point abou the current type of (+) ?
04:16:23 <quicksilver> :t (+)
04:16:25 <lambdabot> forall a. (Num a) => a -> a -> a
04:16:39 <quicksilver> entropyfails: it's just convenient in practice that that is tied to one single instance of Num
04:16:48 <entropyfails> I wouldn't propose it without having developed the system myself.
04:16:51 <quicksilver> entropyfails: you could imagine more general ones using 3 different nums
04:17:02 <quicksilver> entropyfails: (but in practice you'd need loads of type annotations to use it, then)
04:17:11 <entropyfails> I'm not certain how that would interact with the dictionary object.
04:17:35 <entropyfails> quicksilver: the annotation is what I want to avoid.
04:18:02 <vincenz> either way, it's gonna have to check if it's a prime after every operation anyways...
04:18:05 <vincenz> even if you hide it inside (+)
04:18:06 <entropyfails> By saying "isPrime" is a prime proper... and then using some fancy typing to statically check integers in the system
04:18:07 <vincenz> so I fail to see the use
04:18:25 <vincenz> entropyfails: if you do that, tell me how you did it and I'll get a noble price
04:18:25 <quicksilver> vincenz: it could simply assume it wasn't
04:18:42 <entropyfails> Well, lets say I have a function nextprime that is of type Prime -> Prime
04:18:42 <EvilTerran> dependent types!
04:19:06 <vincenz> EvilTerran: without a check after each operation?
04:19:13 <EvilTerran> dweomer!
04:19:33 <entropyfails> I would need some helper function nextprime' that is of type Int -> Prime
04:20:05 <entropyfails> nextPrime' x = if isPrime x then x else (nextPrime' x + 1)
04:21:04 <vincenz> entropyfails: you mean nextPrime' (x+1)
04:21:17 <entropyfails> vincenz too much lisp for me eh?
04:21:18 <entropyfails> ;)
04:21:23 <entropyfails> but yeah
04:21:30 <vincenz> then you'd need an extra set of parens ;)
04:21:54 <entropyfails> vincenz: Nah I'd use a macro.
04:21:54 <entropyfails> ;)
04:22:08 <vincenz> use liskell!
04:22:46 <entropyfails> Anyway, I'm still trying to figure out where to hang the "type verifier".
04:23:53 <entropyfails> And I just wanted to get some feedback on the idea in general.
04:24:07 <entropyfails> Which you all have been very helpful with!
04:24:19 <leila> i think you have succeeded at that :)
04:24:42 * vincenz sings 'leila ... you've got me on my knees. .. '
04:24:56 <EvilTerran> <.<
04:25:03 <entropyfails> I think it is super useful. I would much rather say "I have this C function that I will provide a special function to PROVE for me that I got a valid response."
04:25:13 <entropyfails> then do typecasting and wait for "positive or negative" blame.
04:26:50 <entropyfails> It may be a bit much to implement in GHC.
04:26:53 <entropyfails> ;)
04:28:39 <entropyfails> I did something like this in Qi.
04:28:40 <entropyfails> http://programmingkungfuqi.blogspot.com/2006/04/qi-and-magic-prime-type.html
04:28:42 <lambdabot> Title: Programming Kung Fu Qi: Qi and the "Magic" Prime Type, http://tinyurl.com/2a4zo4
04:29:12 <entropyfails> Thanks lambdabot! May someone here give you sentience.
04:29:44 <Taejo> I want to learn how to do automatic CPS-transformation... any hints?
04:30:31 <infrared> new haskell weekly news, yay!
04:30:58 <infrared> thank you dons :)
04:31:15 <entropyfails> Thanks for the link this week, btw!
04:31:47 <MoeD> Greetings, #haskell.
04:32:04 <entropyfails> Greetings MoeD
04:32:19 <MoeD> Is this an appropriate venue for rank newbie questions?
04:32:40 <Taejo> well, I've been asking them since yesterday
04:32:41 <entropyfails> Rank 0 newbie or Rank 1?
04:32:41 <entropyfails> ;)
04:32:45 <entropyfails> Go ahead!
04:33:38 <gvdm> just keep in mind, we will be ranking you
04:33:39 <MoeD> I'd guess 0, not getting the joke... =)    I've been dipping my toe into FP after (lots of) years of imperitive.  I understand Haskell is "lazy" - I'm having trouble understanding the implications of that.  What sorts of problems lend themselves well to lazy evaluation?
04:34:00 <vincenz> MoeD: you can build infinite data structures and it will only calculate what you need
04:34:13 <entropyfails> MoeD.. lets say you have an infinite list of 1, 2, 3 ....
04:34:14 <entropyfails> ;)
04:34:15 <vincenz> MoeD: the advantage of that is that a lot of control-operators such as for instance loops lose their value
04:34:56 <opqdonut> :D
04:35:01 <opqdonut> nice way of putting it
04:35:16 <leila> @take 5 [1,2..]
04:35:16 <lambdabot> Maybe you meant: time type
04:35:22 <MoeD> I see I have more reading and playing around.
04:35:24 <leila> > take 5 [1,2..]
04:35:29 <leila> meh...
04:35:29 <lambdabot>  [1,2,3,4,5]
04:35:30 <entropyfails> MoeD lets us put it this way as well.. if you need to do some work
04:35:34 <leila> works for me :)
04:35:37 <Taejo> > fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
04:35:37 <entropyfails> is it easier to do all of the work?
04:35:37 <lambdabot>  Parse error
04:35:44 <entropyfails> or just the parts that you need to?
04:36:04 <entropyfails> THAT is the power of laziness. You only have to do the needed work
04:36:10 <entropyfails> If you look at the computer lanugage shootout
04:36:14 <MoeD> entropyfails,  ok.
04:36:20 <entropyfails> you find that ALL of the old problems were thrown away
04:36:25 <Taejo> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
04:36:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:36:38 <infrared> MoeD: for example, check out how neat the solution to Hamming problem looks in Haskell: http://hpaste.org/2894
04:36:42 <entropyfails> because Haskell came along and said... Look... you don't even need to compute 1/2 of this, just skip it
04:36:53 <entropyfails> and it made Haskell seem super fast.
04:36:55 <Taejo> fibs is the list of *all* fibonacci numbers
04:37:12 <entropyfails> So if you are used to imperative code.
04:37:19 <entropyfails> then you are use to things being "things"
04:37:40 <entropyfails> instead of things in your language being "names" to things.. that you only get a value from at the last possible moment.
04:38:26 <LeCamarade> Oh, so there is Hugs for Plan 9. :o) Half the job is done. http://mirtchovski.com/p9/hugs/
04:38:27 <lambdabot> Title: Haskell for Plan9
04:38:47 <entropyfails> MoeD: Makes sense?
04:39:02 <MoeD> Thanks all, not sure I 'get it' all yet... but I have somewhere to start.  Grey cells aren't quite awake yet.  =)
04:39:08 <entropyfails> Moed: think of it like this
04:39:13 <entropyfails> Moed: in c
04:39:30 <entropyfails> Moed: we have int my_fun(int x, int y, int z);
04:39:58 <entropyfails> Moed: so we know that x and y and z are all real things... when you call my_fun(a,b,c);
04:40:05 <entropyfails> Moed: you evaluate a,b,c
04:40:11 <Saizan> ?where whyfp
04:40:11 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
04:40:12 <entropyfails> Moed: and set that to x,y,z right?
04:40:22 <MoeD> <nod>
04:40:25 <matthew_-> @tell njbartlett Thanks for the video, it's now up at http://www.wellquite.org/non-blog/hug_games.flv
04:40:25 <lambdabot> Consider it noted.
04:40:27 <vincenz> MoeD: I suggest you read whyfp as pointed out by Saizan and then read yaht
04:40:28 <entropyfails> Moed: but what if you never use z?
04:40:28 <vincenz> @where yaht
04:40:29 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
04:40:33 <vincenz> @where whyfp
04:40:33 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
04:40:39 <vincenz> I think this is the best explanation for it
04:40:42 <vincenz> go for whyfp first
04:40:46 <vincenz> and use yaht if you get stuck in it
04:40:55 <MoeD> reading both.  =)
04:41:01 <entropyfails> ;)
04:41:16 <MoeD> more information is rarely bad.
04:41:44 <MoeD> I'm evaluating the 2 lazily, however.
04:41:52 <LeCamarade> :o)
04:41:58 <leila> i think he gets it
04:42:01 <leila> :)
04:42:16 <entropyfails> *laugh*
04:42:17 <MoeD> I really enjoyed Simon Peyton Jones' 2 part video recently.
04:42:48 <entropyfails> MoeD: Everybody loves watching Simon give a talk. Anyone with a brain that is. ;)
04:42:55 <LeCamarade> MoeD: Yeah, that was like a rock concert, you know. :o)
04:43:07 <LeCamarade> SPJ onlygives concerts, not talks.
04:43:23 <scook0> \m/
04:43:28 <MoeD> It is good to have an advocate like that who knows his stuff, and has that much personality too.
04:43:49 <leila> \m/ ^_^ \m/
04:43:54 <sieni> wwspjd?
04:43:56 <LeCamarade> He came up with that _impromptu_ lecture on Nirvana, some time. 'Twas grand.
04:43:59 <entropyfails> tis the joy of knowing things.
04:44:07 <MoeD> I'd like to see Stroustrup do something along those lines!
04:44:28 <LeCamarade> WWSPJD? Well, he'd know where to use unsafePerformIO ...
04:44:39 * entropyfails giggles.
04:46:08 <entropyfails> MoeD: The best way to learn about lazy evaluation is to write some functions that use [1,2 .. ]
04:46:14 <MoeD> *chuckle*  The "Why FP Matters" blurb apologizes for the LaTeX layout.  I WISH more things had typesetting that made sense like that.
04:46:32 <LeCamarade> > foldr1 (*) [1..100]
04:46:41 <entropyfails> MoeD: if you get it wrong (like using "map") you'll get a
04:46:43 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
04:46:49 <entropyfails> ;)
04:47:13 <entropyfails> MoeD: warm box.. in SPJ-speak.
04:47:22 <nornagon> ?let fac n = foldr (*) [n..1]
04:47:27 <lambdabot> Defined.
04:47:38 <nornagon> > fac 100
04:47:39 <lambdabot>   add an instance declaration for (Num [t])
04:47:39 <lambdabot>     In the expression: fac 100
04:47:39 <lambdabot>   ...
04:47:43 <nornagon> aw.
04:48:04 <nornagon> ?let fac n = foldr1 (*) [n..1]
04:48:04 <lambdabot> <local>:4:8:     Occurs check: cannot construct the infinite type: a = [[a]] ...
04:48:08 <nornagon> ?unlet fac
04:48:09 <lambdabot>  Parse error
04:48:25 <nornagon> ?forget
04:48:25 <lambdabot> Incorrect arguments to quote
04:48:27 <LeCamarade> > (sequence $ take 5 $ repeat $ randomRIO (0, 10)) >>= (putStrLn . show)
04:48:29 <lambdabot>  <IO ()>
04:48:30 <nornagon> ?forget fac
04:48:30 <lambdabot> Incorrect arguments to quote
04:48:37 <nornagon> boo.
04:48:49 <LeCamarade> > (sequence $ take 5 $ repeat $ randomRIO (0, 10)) >>= (return . show)
04:48:50 <lambdabot>  <IO [Char]>
04:49:26 <LeCamarade> > (sequence $ take 5 $ repeat $ randomRIO (0, 10)) >>= (unsafePerformIO . show)  -- dons'd never let unsafe* run ... :o(
04:49:27 <lambdabot>  Unbalanced parenthesis
04:49:37 <LeCamarade> Language.Haskell bug.
04:49:48 <LeCamarade> > (sequence $ take 5 $ repeat $ randomRIO (0, 10)) >>= (unsafePerformIO . show)  -- dons'd never let unsafe* run ... :o()
04:49:49 <lambdabot>   Not in scope: `unsafePerformIO'
04:51:40 <vincenz> woa, spam!
04:51:51 <entropyfails> Yeah. you can /msg the lambdabot
04:51:55 <vincenz> exactly
04:51:57 <vincenz> entropyfails++
04:54:50 * leila brain is about to enter failsafe shutdown
04:54:57 <LeCamarade> Sorry. :o(
04:55:06 <vincenz> monad-overload?
04:55:11 <leila> nope
04:55:36 <leila> just using hugs now to model some sort of state machines and i have a multilayer mapping
04:55:39 <entropyfails> caffeine underload?
04:55:41 <leila> somewhere i lost it
04:55:47 <leila> entropyfails, ... dont tempt me :)
04:56:03 <vincenz> leila: use types
04:56:04 <vincenz> types help
04:56:07 <leila> i am
04:56:14 <vincenz> I find that when I specify what I want to do in types, the code comes on its own
04:56:28 <leila> i didnt even think about coding yet
04:56:35 <scook0> vincenz: @djinn ;)
04:56:39 <vincenz> :D
04:57:01 <nornagon> @djinn a -> Bool
04:57:05 <lambdabot> f _ = False
04:57:11 <leila> Main> :info State
04:57:11 <leila> -- type constructor
04:57:11 <leila> type State = Bag (Attr [Char] (Bag (Attr [Char] (Set (Attr [Char] [Char])))))
04:57:19 <leila> how is that for a type :)
04:57:24 <scook0> o_O
04:57:25 <vincenz> why not use String?
04:57:26 <entropyfails> ack
04:57:29 <vincenz> that's an ugly type
04:57:34 <leila> its from the info
04:57:39 <vincenz> use String!
04:57:40 <entropyfails> Yeah, that would make it hard to reason about
04:57:47 <leila> i have broken it down
04:57:48 <vincenz> the type is not nicely abstract and clean :)
04:57:53 <entropyfails> what are the "attr's" why are they nested...
04:57:56 <entropyfails> etc
04:58:08 <entropyfails> why don't they have names?
04:58:14 <entropyfails> can you give them meaningful names?
04:58:15 <leila> they have
04:58:18 <vincenz> and here I thought entropyfails was a noob
04:58:19 <vincenz> o.O
04:58:31 <entropyfails> ;)
04:58:49 <entropyfails> vincenz: Why? Because I want to add a crazy verification scheme to Haskell?
04:58:54 <leila> http://hpaste.org/2897
04:58:54 <entropyfails> ;)
04:59:26 <leila> as i said, that is from :info :)
04:59:37 <vincenz> entropyfails: yeah :)
04:59:58 <vincenz> leila: your types aren't very informative
05:00:01 <vincenz> that's probably why you're getting lost
05:00:48 <entropyfails> vincenz: hehe. It is more of an excuse to play with GHC code. But I really like it better than Wadler's idea.
05:01:10 <vincenz> I think Qi does runtime type checking
05:01:16 <vincenz> hence why it can do taht kind of stuff
05:01:18 <leila> informative in what way ?
05:01:29 <vincenz> leila: well it's hard to figure out what your tyes mean
05:01:29 <entropyfails> vincenz: No it doesn't actually.
05:01:31 <vincenz> +p
05:01:40 <vincenz> entropyfails: so numbers are constant?
05:01:40 <entropyfails> vincenz: it compiles everythign first.. even in the REPL.
05:01:42 <leila> ofc you dont have the piece of paper that i am looking at :)
05:02:06 <vincenz> leila: sounds like 'pi' the movie
05:02:12 <Cale> heh
05:02:14 <vincenz> that unique string of 216 digits :)
05:02:39 <Cale> That was a pretty bizarre movie.
05:02:43 <MoeD> indeed
05:02:49 <njbartlett> @seen matthew-_
05:02:49 <lambdabot> matthew-_ is in #xmonad and #haskell. I last heard matthew-_ speak 2h 52m 51s ago.
05:02:50 <MoeD> I liked it though.
05:02:54 <entropyfails> leila: Is there a specific number of ports? Are the node names unbounded?
05:03:07 <MoeD> Do any of you make a living using Haskell?
05:03:29 <vincenz> I do
05:03:29 <entropyfails> vincenz: yeah, they are constant.
05:03:47 <vincenz> entropyfails: so any number that is gotten from io can never be of subtype prime?
05:04:18 <vincenz> oh wait
05:04:21 <vincenz> it just keeps doing +1
05:04:23 <vincenz> until it hits a prime
05:04:25 <vincenz> if a number is not prime?
05:04:30 <entropyfails> yep
05:04:32 <leila> entropyfails, there is not a specific number of ports, what do you mean with node names are unbounded ?
05:04:35 <vincenz> I can roll yo a num type for that :)
05:04:36 <vincenz> easily
05:04:47 <vincenz> erm a num-instance
05:05:38 <leila> entropyfails, eventually there will be a schedular that takes the current state and schedules a number of processors (type Processor = Set (Attr Port [Data]) -> Set (Attr Port [Data]))
05:06:10 <leila> entropyfails, to aid in the transformation there will be a consume and produce manager to break down and build up the tokens
05:06:55 <entropyfails> Vincenz, but I don't want to have to keep casting back and forth.
05:07:14 <fax> @class Either
05:07:14 <lambdabot> Unknown command, try @list
05:07:18 <fax> @list
05:07:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:07:28 <fax> @instances Either
05:07:31 <fax> @instances Either
05:07:33 <lambdabot> Couldn't find class `Either'. Try @instances-importing
05:07:33 <lambdabot> Couldn't find class `Either'. Try @instances-importing
05:07:34 <entropyfails> leila: ahh.
05:07:35 <vincenz> entropyfails: you wouldn't have to
05:07:36 <fax> :(
05:08:03 <entropyfails> entropyfails: I'm missing how it would work then. How do you keep the even's out of it?
05:08:20 <Japsu> @instances-importing Either Data.Either
05:08:21 <lambdabot> Couldn't find class `Data.Either'. Try @instances-importing
05:08:28 <entropyfails> vincenz: excepting 2 of course.
05:08:29 <Japsu> @instances-importing Data.Either Either
05:08:31 <lambdabot> Couldn't find class `Either'. Try @instances-importing
05:08:38 <Saizan> Japsu, fax: Either is not a class
05:08:41 <EvilTerran>  @instances gives you the instances of a class, not the classes instanced by a type
05:08:46 <Japsu> bah, good point
05:08:53 <mrd> @instances Functor
05:08:54 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:08:55 <fax> I have got
05:08:55 <fax> StateT [(String, PrologAST)] (Either String) ()
05:09:04 <fax> but I wanted ot use StateT [(String, PrologAST)] (Either ()) () instead >:[
05:09:10 <entropyfails> leila: Well your datatype doesn't say anything about the different "tokens" so it just knows about strings.
05:09:17 <fax> So can I make an instance of Either for ()?
05:09:35 <mrd> are you looking for ErrorT?
05:09:43 <Saizan> fax: you need an instance of Error for ()
05:09:55 <leila> entropyfails, data Eq a => Attr a b = Attr {name :: a, value :: b}
05:10:03 <Saizan> becuase Error e => Monad (Either e)
05:10:10 <mrd> yea
05:10:15 <leila> but i got to run, picking up the gf
05:10:22 <entropyfails> Look at your types this way leila... they are all the same
05:10:23 <entropyfails> id
05:10:24 <entropyfails> port
05:10:26 <entropyfails> node
05:10:30 <entropyfails> they give me nothign to reason about
05:10:38 <entropyfails> nor do they give you anything to reason about
05:10:40 <entropyfails> nor the compiler
05:10:49 <njbartlett> @seen matthew_-
05:10:49 <lambdabot> matthew_- is in #haskell. I last heard matthew_- speak 30m 24s ago.
05:10:50 <leila> ah i see
05:10:55 <entropyfails> so that's why vinz says it is a mess.
05:11:01 <leila> i was keeping that bit of meta information to myself ~_~
05:11:03 <mrd> fax: wouldn't you want Maybe then?
05:11:13 <mrd> if Left contains no info
05:11:42 <entropyfails> leila: The compiler wishes you to share.
05:11:43 <leila> entropyfails, those are identifiers,, they need to be configured together with some sort of mappig (something like: type Mapping a b = [(a, [b])] -- list of one to many relations)
05:11:48 <fax> If I used maybe
05:11:56 <fax> I shall find something other than throwError
05:12:02 <mrd> mzero
05:12:05 <mrd> fail
05:12:30 <entropyfails> leila: hmm. maybe there is a nicer way of doing it than that.
05:12:33 <Saizan> and you can use mplus as catchError
05:12:49 <Saizan> > Nothing `mplus` Just 1
05:12:49 <entropyfails> because now types are working against you.
05:12:51 <lambdabot>  Just 1
05:13:10 <leila> entropyfails, for instance a processor has "named" ports that take a list of some undefined "Data" does something and outputs "data" on another set of ports
05:13:40 <entropyfails> well, the undefined data as a string makes sense. But the type of Port being equal to string?
05:14:09 <leila> entropyfails, now the ports need to be mapped to entities and entities to tokens and the tokens to nodes and vice versa
05:14:27 <wsdo_okadr> hi
05:14:34 <wsdo_okadr> can I ask about formal languages and finite automata ?
05:14:37 <leila> entropyfails, i just gave them a name so when i read lets say State i know it maps Node to Token
05:14:38 <entropyfails> leila: perhaps real types?
05:15:01 <entropyfails> because basically it sounds like you are just pushing everything through your map function
05:15:07 <entropyfails> so what's the value of the whole type system then?
05:15:11 <entropyfails> it's getting in your way.
05:15:18 <entropyfails> er map type
05:15:24 <fax> Great :D
05:15:32 <fax> thanks a lot Maybe is better
05:16:11 <leila> entropyfails, i will get back to you later
05:16:24 <leila> fetch gf comes first
05:16:39 <entropyfails> obviously
05:16:42 <entropyfails> gf > haskell
05:16:43 <entropyfails> ;)
05:17:02 <wsdo_okadr> gf        =        ?
05:17:31 <leila> indeed
05:17:55 <vincenz> :info gf
05:17:57 <vincenz> gf :: Maybe Not
05:18:08 <Japsu> ;D
05:18:24 * entropyfails laughs.
05:18:39 <ibid> gf = Just Not?
05:18:44 <vincenz> or Nothing
05:18:46 <vincenz> or _|_
05:18:48 <ibid> yes
05:18:49 <vincenz> SO MANY CHOICES!
05:18:56 <entropyfails> gf = Just sexy
05:18:59 <entropyfails> that's my rule anyway.
05:19:00 <ibid> also Just _|_
05:19:02 <vincenz> where sexy = not sexy
05:19:12 <entropyfails> *laugh*
05:19:15 <vincenz> meanin gf = Just _|_
05:19:17 <vincenz> or with parens
05:19:20 <vincenz> Just (_|_)
05:19:23 <entropyfails> haha
05:19:31 * ibid read that as "or with parents"
05:19:32 <ibid> !
05:19:41 <vincenz> ibid: erm, no thans :)
05:19:48 <ibid> :)
05:19:57 <entropyfails> hehe
05:19:57 <nominolo> "just bottom" ?
05:20:03 <njbartlett> matthew_-: Hello are you around?
05:20:04 <lambdabot> njbartlett: You have 1 new message. '/msg lambdabot @messages' to read it.
05:20:07 <opqdonut> gf = fix easier
05:20:12 <entropyfails> Oh man...
05:20:18 <entropyfails> ;)
05:20:22 <wsdo_okadr> !fd   ==  _|_
05:20:25 <matthew_-> njbartlett: I am here!
05:20:25 <wsdo_okadr> !gf   ==  _|_
05:20:46 <matthew_-> njbartlett: is all well?
05:20:50 <njbartlett> matthew_-: Aha there you are!
05:20:56 <ibid> hm, isn't _|_ a bit ... um ... phallic for being gf :)
05:21:00 <vincenz> > let gf vincenz = vincenz gf
05:21:01 <lambdabot>  Parse error
05:21:05 <vincenz> > let gf vincenz = vincenz gf in gf
05:21:08 <matthew_-> njbartlett: Boo!
05:21:08 <njbartlett> I put up an embedded flash player in a new post
05:21:11 <njbartlett> http://www.londonhug.net/2007/09/24/better-video-for-games-in-haskell/
05:21:12 <vincenz> @type let gf vincenz = vincenz gf in gf
05:21:12 <lambdabot>      Occurs check: cannot construct the infinite type:
05:21:13 <lambdabot>       t = (t -> t1) ->...
05:21:15 <lambdabot>     Occurs check: cannot construct the infinite type:
05:21:15 <lambdabot>       t = (t -> t1) -> t1
05:21:16 <lambdabot> Title: ondon HUG  Blog Archive  Better Video for Games in Haskell, http://tinyurl.com/26m86z
05:21:16 * vincenz sighs
05:21:18 <vincenz> not typable
05:21:29 <entropyfails> What can you do, vincenz... sorry.
05:21:44 <entropyfails> At least the compiler never lies... unlike match.com
05:22:32 <matthew_-> njbartlett: oh ok, That doesn't seem to work for me, but then I'm not sure what it should be doing...
05:23:41 <njbartlett> The video doesn't work?
05:24:02 <matthew_-> njbartlett: err the flash thing doesn't seem to work for me. but then it's likely I don't have flash installed
05:24:19 <matthew_-> so I wouldn't worry. There's evidence that it works for others
05:24:22 <cjay> flash is evil. how should people on linux/ppc view it, for example?
05:24:29 <entropyfails> That was an ok presentation.
05:24:34 <njbartlett> Oh. Can you view Google Video or YouTube videos?
05:24:45 <matthew_-> um, I don't think so
05:24:51 <matthew_-> well, I can with clive or with mplayer
05:24:55 <matthew_-> cjay: mplayer
05:25:14 <matthew_-> cjay: (err, for flash *video*, not general animations)
05:25:15 <cjay> matthew_-: that only works if one can find out the url of the file
05:25:19 <njbartlett> Hmm. Then I guess I should make a download link available. mplayer can play FLV files right?
05:25:21 <ibid> and there are tools for downloading the movie
05:25:31 <ibid> for youtube at least
05:25:33 <matthew_-> njbartlett: indeed it can - that's how I checked it worked
05:26:21 <njbartlett> Okay. I think the flash player is a little friendlier because it starts streaming immediately. But I'll put a download link for people who can't use it
05:27:02 <matthew_-> well, mplayer -cache 2048 http://www.wellquite.org/non-blog/hug_games.flv will also start playing pretty quickly ;)
05:27:08 <cjay> ibid: afaik there is no generic tool to get the urls for the video files from every flash video thingie
05:27:37 <cjay> there is no reason not to provide direct downloads, except you don't want people to download them
05:27:43 <matthew_-> hmmm. I'd better check my server bandwidth
05:27:54 <njbartlett> matthew_-: Is that because mplayer does streaming, or because you happen to be on that box?
05:28:31 <njbartlett> cjay: Agreed. I want to be as accessible as possible, so I'll put the download link
05:29:15 <cjay> :)
05:29:41 <entropyfails> Thanks for the videos. Beats TV any day of the week. ;) Can you mic them up next time?
05:30:45 <njbartlett> entropyfails: Yeah I need to buy some more equipment. But London HUG is a free event so I don't have much budget for toys :-)
05:31:32 <matthew_-> njbartlett: mplayer does streaming
05:31:45 <matthew_-> njbartlett: as does xine and totem and gstreamer etc etc
05:31:51 <entropyfails> njbartlett: True that! I suppose they don't have public access channels over there? That's always a good spot around here for those sorts of things. Or a university may offer to loan equipment.
05:31:54 <njbartlett> matthew_-: Cool. So do you think you have space and bandwidth for the SPJ video as well?
05:32:01 <matthew_-> probably
05:32:37 <matthew_-> njbartlett: I have 4TB transfer a month. I'll be both impressed and worried if we end up anywhere near that!
05:32:46 <ibid> cjay: as i said, for youtube :)
05:32:56 <cjay> yo
05:33:12 <matthew_-> njbartlett: as that's about 27,000 downloads of the games video
05:33:51 <njbartlett> Well it's had around 400 views so far on Google Video. Admittedly that includes people who watch the first 30 seconds and then say "what is this crap? I was looking for porn!"
05:34:57 <njbartlett> entropyfails: Do you know anything about the kind of equipment I need to get? I'm just learning about this stuff
05:35:09 * entropyfails says in the scary movie voice, "Do you know what your little girl is... currying?"
05:35:22 <platypus> entropyfails: Favours?
05:35:30 <matthew_-> lamb?
05:35:49 <Mr_Awesome> njbartlett: Sackman and Allwood are a bit misleading :P
05:36:06 <matthew_-> oi!
05:36:17 <entropyfails> njbartlett: I'm not sure. I always piece something together from what I can beg and borrow for. I'm thinking of running a Minnesota HUG.
05:36:19 <ToRA> heh
05:36:44 <vincenz> I think a Group HUG would be good
05:36:55 <njbartlett> But the G already stands for Group!
05:36:56 * entropyfails replies in the scary movie voice, "No... No I'm sorry. The correct answer was... Garlic Nan... yes.. Garlic nan. Thank you for playing though."
05:37:29 <ttfh> should I have to do something special to import "Data.Sequence", ghc can
05:37:33 <ttfh> t seem to find it
05:38:31 <Cale> ttfh: you're not putting it in quotes like you did there, right?
05:38:43 <entropyfails> njbartlett: Well then we can define a bind and a return operator and everything should work out right?
05:38:47 <Cale> import Data.Sequence
05:39:42 <Cale> ttfh: Which GHC are you running?
05:41:58 <ttfh> 6.4
05:42:09 <Cale> Oh, that's really old.
05:42:19 <Cale> I don't think Data.Sequence existed in 6.4.
05:44:24 <ttfh> "ghc-pkg describe data" lists Sequence under "exposed-modules"...
05:46:04 <Cale> Data.Sequence is in base
05:46:27 <Cale> I don't think I even have a package data.
05:47:06 <ttfh> well, I guess an update would be in order anyway
05:49:52 <doserj> data was a package from the old hugs-ghc libraries, containing Edison among others
05:50:07 <doserj> (which in turn contains Sequences)
05:51:29 <doserj> that was, prior to the move to hierarchical libraries
05:52:20 <ttfh> so then I get in trouble reading "hierarchical libraries" docs and trying to use them in an old ghc :-)
05:52:46 <ibid> didn't 6.4 have hierarchical libs?
05:53:12 <doserj> 6.4 had both, for compatibility
05:54:35 <infrared> is there a way to import symbols from a module that it doesn't have in its export list?
05:54:55 <doserj> erm, no?
05:55:04 <MrEggCollector> Hey guize
05:55:15 <infrared> e.g. module have "module FooBar (foo, bar) where" and it defines foo, bar and baz inside
05:55:28 <infrared> now I want to import baz from outside
05:55:30 <doserj> it's the whole point of export lists that you cannot
05:55:35 <ibid> infrared: you can't
05:55:38 <ibid> infrared: that's the point
05:55:42 <infrared> damn
05:55:47 <MrEggCollector> HEY AGAIN GUIZE :D
05:56:17 <infrared> my problem is: I want to write some properties for quickcheck but don't want to keep them in the same file as the module I'm testing
05:56:31 <MrEggCollector> Sup guize? Programming anything fun? :-D?
05:56:39 <nominolo> infrared, then use an #if DEBUG section
05:57:15 <infrared> nominolo: if DEBUG around my module definition line?
05:58:00 <nominolo> module Foo where ( expF1, expF2, #if DEBUG internalF1, internalF2 #endif )
05:58:11 <nominolo> with the appropriate newlines, of course
05:58:35 <leila> back\
06:01:18 <vincenz> back-back-slash?
06:01:20 <vincenz> is that /?
06:01:46 <leila> depends on the definition of back :)(
06:02:12 <leila> entropyfails, i just discovered that i made 1 level of indirection to many, so that is why my brain got stuck
06:02:57 <Taejo> is there an easy way to check if an array index is out of bounds?
06:03:12 <ddarius> :t inRange
06:03:15 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
06:03:16 <leila> is that even possible ?
06:03:38 <ddarius> :t inRange . bounds
06:03:41 <leila> :info Ix
06:03:41 <lambdabot> forall i e. (Ix i) => Array i e -> i -> Bool
06:05:25 <vincenz> @hoogle Ix
06:05:25 <lambdabot> Data.Ix :: module
06:05:25 <lambdabot> Ix :: module
06:05:25 <lambdabot> Data.Ix.Ix :: class Ord a => Ix a
06:05:46 <ddarius> @src Ix
06:05:46 <lambdabot> class (Ord a) => Ix a where
06:05:46 <lambdabot>     range           :: (a,a) -> [a]
06:05:46 <lambdabot>     index           :: (a,a) -> a -> Int
06:05:46 <lambdabot>     inRange         :: (a,a) -> a -> Bool
06:05:46 <lambdabot>     rangeSize       :: (a,a) -> Int
06:05:50 <leila> ix is some abstract class for index ?
06:06:38 <vincenz> yes
06:06:45 <leila> ok
06:06:49 <vincenz> range ((0,0),(1,1)
06:06:50 <vincenz> > range ((0,0),(1,1))
06:06:52 <lambdabot>  [(0,0),(0,1),(1,0),(1,1)]
06:06:57 <vincenz> cause you can have multidimensional indices
06:07:54 <ddarius> Or use trees as indices.
06:08:21 <EvilTerran> trees as indices? O.o
06:08:37 <MrEggCollector> http://pastebin.com/m16dcd679 <- I get an error on line 44, problem with datatypes.. any ideas?
06:09:06 <vincenz> :t length
06:09:08 <lambdabot> forall a. [a] -> Int
06:09:15 <vincenz> :t fromIntegr
06:09:16 <vincenz> :t fromInteger
06:09:18 <lambdabot> Not in scope: `fromIntegr'
06:09:19 <lambdabot> forall a. (Num a) => Integer -> a
06:09:20 <wli> Nothing cares so long as there an Ix instance.
06:09:23 <MrEggCollector> Yeah but if you do Int/Int+Bool.. won't it cast to bool?
06:09:26 <MrEggCollector> oops, I mean float
06:09:32 <vincenz> no
06:09:35 <vincenz> you have to do it explicitly
06:09:38 <vincenz> :t fromIntegral
06:09:40 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:09:47 <vincenz> (fromIntegral $ length l)
06:10:07 <ddarius> There are no implicit coercions anywhere in Haskell.
06:10:15 <vincenz> wrong
06:10:23 <vincenz> default typeclasses :)
06:10:29 <entropyfails> ;)
06:10:29 <ddarius> Aren't implicit coercions
06:10:47 <vincenz> yes they are, they coerce a typeclass'd tyvar to a specific type
06:11:02 <wli> That's not coercion.
06:11:06 <ddarius> That's instantiation.
06:11:09 * vincenz thinks it's coercion :)
06:11:09 <entropyfails> No implicit coercions only implicit dicitionaries?
06:11:28 <entropyfails> er dictionaries.
06:11:41 * entropyfails grins.
06:11:59 <MrEggCollector> vincenz: thx sir :D
06:16:30 <wli> Well, the most you can do otherwise is to complain that monomorphism is required.
06:16:40 <fasta> Is there a parallel version of sequenceM_?
06:16:41 <lambdabot> fasta: You have 1 new message. '/msg lambdabot @messages' to read it.
06:17:55 <vincenz> fasta: you mean something like mapM_ fork?
06:18:06 <fasta> vincenz: probably.
06:19:59 <fasta> vincenz: but it should only return when all threads are complete.
06:22:20 <vincenz> mapM_ fork
06:22:22 <nominolo> > Version [2] [] < Version [2,0] []
06:22:22 <vincenz> mapM fork
06:22:23 <lambdabot>   Not in scope: data constructor `Version'
06:22:26 <vincenz> then join em :)
06:22:43 <nominolo> > Data.Version.Version [2] [] < Data.Version.Version [2,0] []
06:22:44 <lambdabot>   Not in scope: data constructor `Data.Version.Version'
06:23:57 <MrEggCollector> http://pastebin.com/m73685de2 <- You guys know what's wrong? :'(
06:24:00 <nominolo> lambdabot doesn't import base?
06:24:34 <int-e> nominolo: no. lambdabot is careful what it imports to avoid holes like unsafePerformIO.
06:24:46 <MrEggCollector> Guize!? plzzzzzzzz :'(
06:25:07 <kpreid> MrEggCollector: I recommend a little more patience.
06:25:16 <nominolo> int-e, yeah.  but Data.Version is rather pure
06:25:17 <MrEggCollector> Oh ok, sorry sir
06:25:19 <kpreid> MrEggCollector: Also, please tell us what the problem is.
06:25:24 <nominolo> > [3] < [3,0]
06:25:26 <lambdabot>  True
06:25:38 <MrEggCollector> Unexpected '=' :(
06:25:50 <int-e> nominolo: lambdabot would still have to import it explicitely.
06:26:08 <kpreid> MrEggCollector: Did you type that into ghci, perhaps?
06:26:13 <nominolo> yo
06:27:00 <kpreid> MrEggCollector: if that's the case, then: you need to either put it in a file and load the file, or prefix the definition with "let"
06:27:01 <MrEggCollector> kpreid: ghci? glasgow haskell compiler?
06:27:07 <MrEggCollector> kpreid: I'm using hugs98
06:27:09 <int-e> MrEggCollector: give more context please
06:27:20 <kpreid> MrEggCollector: I mean, the interactive prompt, whichever implementation you're using.
06:27:21 <MrEggCollector> int-e: that's supposed to be the entire function :S
06:27:30 <kpreid> MrEggCollector: as opposed to a .hs file
06:27:34 <MrEggCollector> kpreid: I'm using hugs98
06:27:36 <MrEggCollector> it's in a .hs file
06:27:40 <int-e> @index diffCount
06:27:40 <lambdabot> bzzt
06:27:47 <Taejo> why can't the haskell interpreters be nicer: allow definitions and import?
06:27:48 <int-e> MrEggCollector: I have my doubts.
06:27:57 <kpreid> MrEggCollector: Okay, the syntax error must be somewhere else in the file then.
06:28:00 <MrEggCollector> int-e: oh I forgot about that :p
06:28:23 <kpreid> Taejo: This isn't "can't" but: they'd have to define a semantics for incremental definition
06:28:32 <MrEggCollector> http://pastebin.com/m30902af3
06:28:36 <MrEggCollector> there is diffCount too :)
06:28:36 <kpreid> Taejo: in a file, all definitions may be mutually recursive
06:28:58 <Taejo> that's true
06:28:59 <ndm> @karma+ Igloo
06:28:59 <lambdabot> Igloo's karma raised to 13.
06:29:15 <Taejo> but e.g., scheme's REPL is so much nicer
06:29:16 <ndm> for saying what i was thinking to Claus, and bothering to read to the end of Claus's email (I stopped half way through)
06:29:29 <kpreid> MrEggCollector: I recommend including the entire error message when you post code.
06:29:38 <MrEggCollector> ohh ok sir
06:30:05 * Igloo high-fives ndm
06:30:20 <int-e> MrEggCollector: still, it compiles for me, both hugs and ghci accept that.
06:30:39 <int-e> MrEggCollector: you have to put it into a separate file, as has already been said. did you?
06:30:51 <kpreid> Igloo: this sounds entertaining -- URL?
06:31:09 <ndm> "PROPOSAL: Rename haskell@ to haskell-announce@" on haskell-cafe
06:31:31 <Igloo> It's not particularly entertaining, but http://www.haskell.org/pipermail/haskell/2007-September/019841.html
06:31:32 <int-e> MrEggCollector: and then  :load file.hs  on the prompt, or start hugs with   hugs file.hs
06:31:33 <lambdabot> Title: [Haskell] Re: [Haskell-cafe] PROPOSAL: Rename haskell@ to haskell-announce@, http://tinyurl.com/yq8yj7
06:31:40 <fasta> What is a common way to run n processes and wait until they are all done? Should I use n synchronizing variables and put them after the completion of the task and then take n synchronizing variables (effectively waiting on them)?
06:31:41 <MrEggCollector> http://pastebin.com/m16483b2 <- There is all code
06:31:57 <xerox> fasta: there's code on the wiki to do that
06:31:59 <MrEggCollector> int-e: I'm getting the error (at the bottom of the file) when I try to load my .hs file, sir! :(
06:32:05 <ndm> its just i read the email, disagreed with most of it, but didn't have time to read it all and respond properly
06:32:11 <MrEggCollector> :load worked before we added the if/else
06:32:17 <fasta> xerox: doesn't the wiki have code that _competes_ to return?
06:32:20 <int-e> MrEggCollector: which line is line 48? ;)
06:32:22 <doserj> poisson=
06:32:23 <kpreid> MrEggCollector: The problem is on line 48 as the message says it is.
06:32:27 <int-e> poisson= p1 p2 = -19/20*log(1-(20*(diffCount p1 p2 0)/(fromIntegral $ length p1)/19)
06:32:32 <int-e> that is clearly incorrect.
06:33:00 <ndm> i would love it if Haskell@ mailing lists all put hyperlinks to their web archives on the bottom of them - to the actual message
06:33:17 <MrEggCollector> :'(
06:35:31 <Igloo> ndm: There isn't a magic variable for that, unfortunately
06:38:02 <fxr> @hoogle Monad m => [m a] -> m [a]
06:38:06 <lambdabot> Prelude.head :: [a] -> a
06:38:06 <lambdabot> Prelude.last :: [a] -> a
06:39:17 <MrEggCollector> Guize, the datatype "Real", is it in Prelude?
06:39:46 <xerox> ?index Real
06:39:46 <lambdabot> Prelude
06:39:53 <phlpp> hi
06:39:54 <phlpp> :)
06:39:55 <doserj> it is a class, not a type
06:40:07 <MrEggCollector> So I'll have to do [Prelude]=>Real
06:40:10 <MrEggCollector> I?
06:40:20 <MrEggCollector> :o
06:40:32 <MrEggCollector> O_o
06:40:50 <xerox> MrEggCollector: try :info Real it'll show you the operations on Real types and which types are Real
06:40:56 <MrEggCollector> :info Real
06:40:59 <MrEggCollector> -_-
06:41:04 <MrEggCollector> >:info Real
06:41:09 <MrEggCollector> ?info Real
06:41:09 <lambdabot> (Real)
06:41:18 <MrEggCollector> ?:info Real
06:41:18 <phlpp> ;>
06:41:18 <lambdabot> Unknown command, try @list
06:41:18 <xerox> MrEggCollector: that used to work here, but people found it noisy, do it in your interpreter's prompt
06:41:24 <MrEggCollector> oh ok
06:41:36 <MrEggCollector> guize :D
06:42:04 * MrEggCollector is :D
06:42:59 <xerox> :)
06:44:09 <MrEggCollector> guize :(
06:44:26 <leila> @where take
06:44:26 <lambdabot> I know nothing about take.
06:44:28 <MrEggCollector> seqDistance::MolSeq->MolSeq->Real=>a
06:44:36 <MrEggCollector> I shouldn't do Real=>a?
06:44:39 <leila> hmm is take in a class ?
06:45:07 <xerox> MrEggCollector: the syntax is <name> :: <type> or <name> :: (<constraints>) => <type>
06:45:18 <doserj> @type take
06:45:21 <lambdabot> forall a. Int -> [a] -> [a]
06:45:27 <doserj> @type genericTake
06:45:29 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
06:45:37 <xerox> MrEggCollector: a constraint is a class applied to type variables, like (Num a) or (Real a).
06:45:56 <leila> doserj, i want to use it on my own type :) so i think i make it part of the collection class
06:45:57 <Taejo> hat-trans is giving me this error message: "hat-trans: Variable or constructor not in scope: member" (member is Data.Set.member here). any ideas why?
06:46:20 <MrEggCollector> But I can't just do seqDistance::MolSeq->MolSeq->Real, right?
06:46:45 <kpreid> MrEggCollector: Why bother writing the type signature?
06:46:46 <xerox> MrEggCollector: right, you want the return type to be a type variable, say 'a', and impost a constraint (Real a) to the type.
06:47:24 <doserj> MrEggCollector: and you probably want Fractional, not Real
06:48:27 <MrEggCollector> doserj: I have to use real :/
06:48:35 <sek> say i have a data type for which i'm lazy (which is good!) to implement the show function for. Is it possible to have haskell print the actual names i have used in the code
06:48:48 <mrd> derive (Show)
06:48:54 <mrd> deriving
06:49:34 <sek> for example data DAT = A Int | B Float    when i do a show (A 3) for it to show "A 3"
06:49:49 <mrd> data DAT = A Int | B Float deriving (Show)
06:50:01 <MrEggCollector> xerox: Real a => a?
06:50:01 <sek> ok i didnt know deriving was that clever
06:50:07 <sek> mrd thanks
06:50:16 <mrd> it also works for Eq, Read, Enum, Ord
06:50:28 <mrd> some random other crap
06:50:34 <MrEggCollector> whats EQ?
06:50:36 <mrd> ==
06:50:42 <MrEggCollector> oh ok thx sir :D
06:51:08 <sek> mrd, i only thought it worked for very simple types
06:51:19 <mrd> it works for all Algebraic Datatypes in Haskell'98
06:51:44 <xerox> MrEggCollector: right
06:52:00 <MrEggCollector> seqDistance::MolSeq->MolSeq->Real a=>a
06:52:04 <MrEggCollector> but thats wrong sir :(
06:52:18 <MrEggCollector> ERROR "mol.hs":50 - Syntax error in input (unexpected `=>')
06:52:27 <mrd> it's not really that clever.  it just follows the inductive structure of the ADT and generates some decent defaults.
06:52:27 <MrEggCollector> It's on that line :o(
06:52:30 <entropyfails> What a type Mr Egg!
06:52:32 <doserj> (Real a) => MolSeq -> MolSeq -> a
06:52:37 <sek> mrd, while we're at it. Would there maybe be a universal way of making all show-less classes automatically derive Show. Since i'd have to add it to quite alot of code
06:52:46 <MrEggCollector> entropyfails: THX SIR :D
06:52:55 <MrEggCollector> ok thx doserj
06:52:58 <mrd> sek: not in H'98, and not that I'm aware
06:53:19 <mrd> I'd do it with a keyboard macro
06:53:36 <entropyfails> MrEgg> Think of it as saying... for All types Real a , we can define this function MolSeq -> MolSeq -> a
06:53:42 <doserj> http://haskell.org/haskellwiki/GHC/StandAloneDeriving
06:53:44 <lambdabot> Title: GHC/Stand-alone deriving declarations - HaskellWiki
06:53:48 <entropyfails> so you keep it on the left.
06:53:54 <sek> yeah, i'm writting a library though which uses some base modules which i'm not really supposed to edit but i guess i'll go through and add some derives for debugging and such
06:53:55 <entropyfails> A handy neumonic
06:54:16 <mrd> ^ standalone deriving might be it, though i'm not sure if you have it in your ghc
06:55:05 <entropyfails> MrEggCollector: Another way to think of it is as saying Real a -> MolSeq -> MolSeq -> a
06:55:21 <entropyfails> where the dictionary that implements Real a is created by the compiler.
06:55:32 <entropyfails> and secretly inserted in.
06:56:29 <entropyfails> so (Real a) => MolSeq -> MolSeq -> a says... If I have a special dictionary function over the real numbers of type "a" then I can make a 4 argument version of the function by passing that dictionary along.
06:57:57 <sclv> hey all. last night someone was demonstrating "flip fix" as a recursion construct, but i couldn't google up a good explanation of how it works (only discussion of its typing) -- can anyone provide an example?
06:58:05 <sclv> wasn
06:58:22 <sclv> erm. wasn't sure if they meant a custom "fix" that tests or just the fix in Control.Monad.Fix either?
06:59:16 <EvilTerran> ?type flip fix
06:59:18 <lambdabot> forall b c. b -> ((b -> c) -> b -> c) -> c
06:59:42 <xerox> > (flip fix) 0 (\next x -> x : next (x+1))
06:59:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:59:57 <sclv> ?src fix
06:59:58 <lambdabot> fix f = let x = f x in x
07:00:15 <MrEggCollector> http://pastebin.com/m16901e8f <- Code
07:00:15 <MrEggCollector> http://pastebin.com/m4dee05ae <- Error
07:00:19 <MrEggCollector> Real is a little weird huh, guize?
07:00:24 <xerox> > fix (\next x -> x : next (x+1)) 0
07:00:29 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:00:33 <doserj> @type 1.0
07:00:36 <lambdabot> forall t. (Fractional t) => t
07:00:55 <sek> mrd, deriving Show for MYDATA     doesnt seem to be acceptable by ghc so i guess i need to compile differently or something?
07:01:03 <leila> enough haskell for one day :)
07:01:05 <leila> bye all
07:01:07 <MrEggCollector> NO!! :(
07:01:14 <entropyfails> MrEgg: No free stuff here. Reals are not Floats. ;)
07:01:20 <sclv> hmm... so the next in the lambda is getting passed the lambda function itself?
07:01:25 <MrEggCollector> entropyfails: Real can't be Float?
07:01:29 <leila> MrEggCollector, just protecting my brain :)
07:01:41 <MrEggCollector> I thought real was like a generic? Int, Float, Double etc?
07:01:42 <vincenz> leila: cya
07:02:02 <entropyfails> MrEgg: what do you mean by "cannot be"? If it is of different type, you need some function to convert it.
07:02:07 <EvilTerran> @instances Real
07:02:08 <lambdabot> Double, Float, Int, Integer
07:02:21 <Olathe> @instances Fake
07:02:22 <lambdabot> Couldn't find class `Fake'. Try @instances-importing
07:02:25 <MrEggCollector> An instance of Real can be Float! :(
07:02:33 <MrEggCollector> Guize this is confusing :'(
07:02:39 <vincenz> leila|wow: world of warcraft o.O?
07:03:09 <sclv> > fix (\next x -> x:(next (x*2)))
07:03:10 <lambdabot>  <Integer -> [Integer]>
07:03:28 <sclv>  fix (\next x -> x:(next (x*2))) 1
07:03:34 <entropyfails> MrEgg: Typeclasses are just a group of functions that an instance must have.
07:03:45 <sclv> > fix (\next x -> x:(next (x*2))) 1
07:03:46 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:03:55 <MrEggCollector> entropyfails: so I must explicitly state which type the instance is?
07:04:20 <sclv> hmmm... so when is using fix for recursion better than, e.g., scanl, iterate, etc?
07:04:33 <EvilTerran> sclv, when it makes for shorter code ;)
07:04:38 <entropyfails> MrEgg: I'll look over the code and see. I'm just giving the outline.
07:04:41 <leila|wow> vincenz, yes
07:05:02 <xerox> sclv: the same recursion you can write without fix.
07:05:09 <EvilTerran> it's fairly rare for fix to actually be useful, AFAIK.
07:05:19 <int-e> @type iterate
07:05:21 <lambdabot> forall a. (a -> a) -> a -> [a]
07:05:33 <Olathe> @src fix
07:05:33 <lambdabot> fix f = let x = f x in x
07:06:49 <EvilTerran> most potential uses of it fit a more specific combinator as well
07:07:52 <sclv> At least I understand how it works now -- its sort of elegant how it ties the knot. I guess its extension as mfix is of more use?
07:08:36 <sclv> (the trouble i had before was recognizing that i needed to use a cons and to pass a "continuation" to force laziness)
07:08:54 <MrEggCollector> guize  ? :E
07:09:50 <EvilTerran> mfix isn't really that useful either, IMO
07:10:07 <sclv> ok now my other basic question i was pondering this morning -- how to use sequence in the reader monad properly to, e.g., apply a list of computations to a number and return a list of bools
07:10:30 <EvilTerran> i find, if I can't find a more specific combinator, explicit recursion is usually clearer and often terser than using (m)fix
07:10:43 <Taejo> can anyone help me with Hat?
07:10:47 <doserj> MrEggCollector: jukesCantor uses log, it therefore returns Floating a, not Real a, as you declare.
07:10:51 <int-e> > sequence [(+1), (*5), (+7)] 3
07:10:52 <EvilTerran> that sounds like writer, sclv
07:10:56 <sclv> something like "sequence [==0,>5] =<< 6"
07:10:56 <lambdabot>  [4,15,10]
07:11:02 <Olathe> > fix (\a -> a) 1
07:11:03 <EvilTerran> oh, right, nvm.
07:11:03 <lambdabot>  Exception: <<loop>>
07:11:16 <MrEggCollector> PLS DONT FORGET ABOUT ME GUIZE :(
07:11:22 <EvilTerran> MrEggCollector, don't shout.
07:11:24 <int-e> sclv: like that?
07:11:31 <doserj> MrEggCollector: and seqDistance returns a Fractional, not a real
07:11:32 <sclv> oh hey, it worked for you!
07:11:46 <entropyfails> ;)
07:11:58 <sclv> ghci spit up something about no monad instance for ((->) a) this morning
07:12:02 <EvilTerran> > map ($3) [(+1), (*5), (+7)] -- sclv, what about something monad-less like this?
07:12:04 <lambdabot>  [4,15,10]
07:12:06 <int-e> sclv: import Control.Monad.Reader
07:12:18 <int-e> or do what EvilTerran says
07:12:30 <shachaf> int-e: Control.Monad.Instances.
07:12:34 <Olathe> How does fix know when to stop ?
07:12:39 <EvilTerran> or Control.M- what shachaf says
07:12:43 <MrEggCollector> mm, so I can just skip toFractional?
07:12:48 <EvilTerran> Olathe, it doesn't. the laziness is the only thing that makes it stop.l
07:12:57 <sclv> yep -- that's what was tricking me out
07:13:05 <Olathe> How does the laziness know when to stop ?
07:13:18 <sclv> when you stop asking for it to eval thunks.
07:13:33 <entropyfails> Or it solves the halting problem, whichever comes first.
07:13:38 <sclv> feed the result into a break or takeWhile or soemthing
07:13:41 <entropyfails> ;)
07:13:50 <int-e> shachaf: I see no advantage in that
07:13:52 <xerox> Olathe: it finds fixpoints
07:13:53 <MrEggCollector> entropyfails: you got my pm? or do I need to be regged to pm?
07:14:19 <Olathe> > fix (\a -> a) 1
07:14:21 <lambdabot>  Exception: <<loop>>
07:14:26 <Olathe> Why does that not terminate ?
07:14:27 <EvilTerran> Olathe, (fix % \f x -> ...) is just the same as (let f x = ... in f)
07:14:32 <MrEggCollector> 1337
07:14:36 <EvilTerran> (fix $ ..., rather
07:14:38 <xerox> > fix ((1:) . map (+1))
07:14:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:14:59 <EvilTerran> > let loop = loop in loop Olathe, for the same reason this doesn't
07:14:59 <lambdabot>   parse error on input `,'
07:15:03 <EvilTerran> > let loop = loop in loop -- Olathe, for the same reason this doesn't
07:15:04 <lambdabot>  Exception: <<loop>>
07:15:16 <Olathe> Right, but 1 is a fixed point.
07:15:42 <xerox> that x is such that x = (1 :) . map (+1) $ x
07:15:55 <EvilTerran> i don't like the "fixed points" explanation of fix, to be honest. it just confused me 'til i grokked how it worked.
07:16:17 <shachaf> Olathe: fix id 1 == let x = x in x 1
07:16:18 <malcolmw> Taejo: I'm a Hat developer, but I'm afraid I can't really help right now - quite busy.
07:16:21 <Olathe> If fix finds fixed points, it would terminate with fix (\a -> a) 1
07:16:34 <EvilTerran> it finds _least_fixed_points_
07:16:40 <EvilTerran> sometimes that's bottom
07:16:45 <malcolmw> Taejo: Are you trying to transform Data.Set, or just to use it?
07:16:51 <Taejo> use it
07:16:52 <shachaf> Olathe: _|_ is a fixed point of id.
07:17:07 <Olathe> I don't know what _|_ really is.
07:17:09 <malcolmw> Taejo: I suspect the problem is that the Hat version of the base package is extremely old now
07:17:26 <Taejo> ok... is there a workaround?
07:17:28 <EvilTerran> as i said, i don't like describing it as fixed points. it's misleading. makes one expect fix (^2) = 1.
07:17:39 <malcolmw> Taejo: there is someone currently working on updating the Hat libraries so that they match the current ghc-6.8.0 RC
07:17:47 <Taejo> ok
07:17:53 <sclv> > fix (^2)
07:17:55 <lambdabot>  Exception: <<loop>>
07:18:00 <xerox> Olathe: that one blackholes because the recursive call is the exact same code as the calling instance
07:18:09 <EvilTerran> the first parameter to fix has to be corecursive if you want a non-bottom result
07:18:30 <EvilTerran> (pardon me while i abuse terminology)
07:18:48 <Olathe> xerox: I know. Looking at the definition of fix, it makes sense.
07:18:48 <EvilTerran> fix (1:) = (let x = 1:x in x) = 1:1:1:1:...
07:18:56 <xerox> > fix (\_ x -> x) 1
07:18:58 <lambdabot>  1
07:19:03 <malcolmw> Taejo: but in the meantime, sorry, I think you will have to abandon using Hat
07:19:16 <EvilTerran> fix id = (let x = id x in x) = <<loop>>
07:19:16 <Taejo> ok, thanks for taking the time
07:19:27 <shachaf> Olathe: _|_ (undefined, <<loop>>, etc.) isn't a fixed point of (1:), because 1:undefined /= undefined.
07:19:48 <Taejo> malcolmw, thank you for Hat anyway... it's awesome
07:20:01 <xerox> Olathe: there you go :)
07:20:15 <shapr> Good morning #haskell!
07:20:53 <swiert> hiya shapr.
07:21:43 <shapr> hoi swiert, what's up?
07:22:31 <swiert> not too much. Getting ready for Haskell Workshop.
07:23:54 <Olathe> > let x = (\_ a -> a) x in x 2
07:23:56 <lambdabot>  2
07:24:30 <vincenz> o.O
07:24:34 <vincenz> that types?
07:24:34 <sek> another Parsec question folks. I have setup a lexer which works just fine, apart from the fact that it doesnt parse comments and whitespace at the beggining of the file. Should i be using lexeme before i start parsing my file?
07:24:44 <vincenz> @type let x = (\_ a -> a) x in x
07:24:46 <lambdabot> forall t. t -> t
07:25:47 <Tac-Work> speaking of Parsec, who knows of a good article explaining monadic parsers that I can chew on for the week?
07:26:31 <sek> maybe there's a link on the parsec website
07:26:43 <Tac-Work> oh yeah, I will check!
07:27:28 <Olathe> OK, so it throws away x.
07:27:36 <swiert> Tac-Work: You may want to read: http://www.cs.nott.ac.uk/~gmh/monparsing.ps
07:27:57 <Tac-Work> thanks
07:28:05 <sek> Tac-Tics2, http://legacy.cs.uu.nl/daan/download/papers/parsec-paper.pdf this and its biblio might help
07:28:30 <Olathe> > let x = (\a -> a) in x 2
07:28:32 <lambdabot>  2
07:29:23 <EvilTerran> > id 2
07:29:24 <lambdabot>  2
07:35:54 <shachaf> vincenz: Why shouldn't it?
07:38:57 <byorgey> @pl \f x -> zip (map f x) x
07:38:58 <lambdabot> join . (zip .) . map
07:49:17 <cognominal_>  @pl  foldr (\(x, y) (mx, my) -> (min x mx, min y my)) p ps
07:50:09 <cognominal_>  :t foldr
07:50:28 <cognominal_> lambdabot ignores me :(
07:50:40 <sjanssen> lambdabot: @botsnack
07:50:40 <lambdabot> :)
07:50:47 <fax> @pl foldr (\(x, y) (mx, my) -> (min x mx, min y my)) p ps
07:50:48 <lambdabot> foldr (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. min) . flip . (((.) . (,)) .) . min)) p ps
07:50:50 <fax> haha
07:50:58 <sjanssen> how did this happen?
07:51:37 <EvilTerran> ?type (min *** max)
07:51:39 <lambdabot> forall a a1. (Ord a, Ord a1) => (a, a1) -> (a -> a, a1 -> a1)
07:52:14 <EvilTerran> ?type uncurry (***) . (min *** min)
07:52:15 <byorgey> cognominal_: lambdabot ignores you if you put a space before your commands =)
07:52:16 <lambdabot> forall b b'. (Ord b, Ord b') => (b, b') -> (b, b') -> (b, b')
07:52:27 <EvilTerran> ?type foldr (\(x, y) (mx, my) -> (min x mx, min y my)) p ps
07:52:29 <lambdabot> Not in scope: `p'
07:52:30 <lambdabot>  
07:52:30 <lambdabot> <interactive>:1:51: Not in scope: `ps'
07:52:34 <EvilTerran> ?type (\(x, y) (mx, my) -> (min x mx, min y my))
07:52:36 <lambdabot> forall t t1. (Ord t, Ord t1) => (t, t1) -> (t, t1) -> (t, t1)
07:53:47 <byorgey> @type min *** min
07:53:51 <lambdabot> forall a a1. (Ord a, Ord a1) => (a, a1) -> (a -> a, a1 -> a1)
07:54:20 <EvilTerran> ... anyway. cognominal_, i'd suggest "uncurry (***) . (min *** min)"
08:02:40 <cognominal_> the output of @pl cqn be scary
08:02:45 <cognominal_> :t flip
08:02:47 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:02:59 <cognominal_> @src flip
08:02:59 <lambdabot> flip f x y = f y x
08:03:16 <allbery_b> @quote flip-stream
08:03:16 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
08:04:17 <sjanssen> @. pl . djinn type flip
08:04:19 <lambdabot> f = flip
08:06:05 <cognominal_> :t ((.) . (,))
08:06:07 <lambdabot> forall b a a1. a1 -> (a -> b) -> a -> (a1, b)
08:07:09 <quicksilver> cognominal_: the 'left-nipple-ring' combinator?
08:08:07 <paolino> is parallel list comprehension doable with the do notation ?
08:08:16 <cognominal_> I like ((.)$(.)). In French, we would call that : cravate de notaire
08:08:50 * mux didn't haskell coders were vicious :-P
08:09:22 <quicksilver> paolino: there's no reason why >>= in the list monad shouldn't be interpreted as parallel
08:09:44 <quicksilver> paolino: it's just concatMap, after all, and map is "naturally" parallel
08:10:08 <cognominal_> :t ((.)$(.))
08:10:10 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
08:10:54 <paolino> quicksilver:  [(x,y) | x <- xs | y <- ys] in do notation is ?
08:11:28 <quicksilver> paolino: there's no way of writing it, per se
08:11:28 <allbery_b> do x <- xs; y <- ys; return (x,y)
08:11:48 <quicksilver> paolino: I'm just saying, there's no reason semantically why >>= shouldn't be parallel
08:11:51 <quicksilver> but, it isn't.
08:11:52 <paolino> allbery_b: that is not parallel
08:12:04 <allbery_b> hm, right, missed the | vs ,
08:12:18 <allbery_b> no parallel do (perhaps pdo is needed somewhere)
08:12:49 <EvilTerran> a ZipList monad would work
08:13:47 <EvilTerran> return = repeat; m >>= f = ... er, i'm not sure.
08:13:55 <paolino> > let p xs ys = do {(x,y) <- zip xs ys ; return x+y} in p [1,2] [3,4]
08:13:56 <lambdabot>   add an instance declaration for (Num [t])
08:13:56 <lambdabot>     In the expression:
08:13:56 <lambdabot>         le...
08:14:18 <EvilTerran> ?type (>>=)
08:14:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:14:33 <sjanssen> paolino: parens around x+y
08:15:11 <paolino> k
08:15:19 <EvilTerran> xs >>= f = zipWith (!!) (map f xs) [0..], i think...
08:15:35 <idnar> > let p xs ys = do {(x,y) <- zip xs ys ; return $ x+y} in p [1,2] [3,4]
08:15:37 <lambdabot>  [4,6]
08:15:59 <quicksilver> EvilTerran: the ziplist applicative cannot, as far as I know, be made into a monad
08:16:05 <idnar> > let p xs ys = do {(x,y) <- zip xs ys ; return (x,y)} in p [1,2] [3,4]
08:16:06 <lambdabot>  [(1,3),(2,4)]
08:16:09 <EvilTerran> @src ZipList fmap
08:16:09 <lambdabot> Source not found. Where did you learn to type?
08:16:26 <idnar> > [(x,y) | x <- [1,2] | y <- [3,4]]
08:16:26 <lambdabot>  Parse error
08:16:42 <EvilTerran> 'ts an extension
08:16:53 <idnar> so I see
08:16:57 <idnar> I'm a little confused, though
08:17:40 <nominolo> > is that supposed to be a zip?
08:17:41 <lambdabot>   parse error on input `}'
08:17:44 <idnar> wouldn't making >>= parallel like that change the semantics?
08:18:41 <sjanssen> yes
08:20:44 <sjanssen> hmm, is ZipList a Monad?
08:21:03 <sjanssen> the documentation in Control.Applicative doesn't seem to think so
08:22:15 <EvilTerran> it's not got an instance defined, but i think there is one
08:22:18 <EvilTerran> possible
08:22:23 <MrEggCollector> guize, it works now :_D
08:22:31 <sjanssen> EvilTerran: what is join?
08:22:41 <EvilTerran> take the diagonal?
08:24:02 <EvilTerran> i'm looking at the monad axioms just now
08:24:49 <EvilTerran> actually, gotta wander off. bbiab.
08:25:27 <quicksilver> sjanssen: I believe it isn't
08:25:32 <quicksilver> sjanssen: but I could be wrong
08:25:38 <quicksilver> sjanssen: (isn't => can't be)
08:28:28 <takamura> hi
08:29:48 <takamura> how can i remove files by extension in haskell? For example, removeFile "*.log" doesn't work
08:29:58 <twanvl> Actually I think there is a possible join for ZipList:
08:30:11 <twanvl> Take the first element from the first list, the second one from the second list, etc.
08:30:22 <mux> takamura: the missingH library has a glob function that can do what you want
08:30:33 <takamura> thanks, mux
08:31:08 <mux> then you can do glob "*.log" >>= mapM_ removeFile
08:31:14 <mux> or something
08:33:30 <phobes> sjanssen:  Isn't zipList just a newtype for List?   It seems like that would give it an obvious Monad instance... but maybe you want it to respect additional structure?
08:33:52 <quicksilver> phobes: no, because that doesn't generalise the applicative instance for ZipList
08:34:05 <quicksilver> twanvl: that doesn't sound to me like it satisfies the 'identity' laws?
08:34:29 <twanvl> return for zip lists is repeat
08:35:00 <quicksilver> twanvl: oh. interesting.
08:35:11 <quicksilver> twanvl: maybe it does then :)
08:36:30 <quicksilver> twanvl: however, Cale says it isn't
08:36:43 <quicksilver> twanvl: "It's the canonical example of an applicative functor which isn't a monad."
08:36:51 <phobes> quicksilver:  ah, that makes sense.  I figured something like that was the issue (that's what I meant by additional structure)
08:37:17 <twanvl> Let's try it...
08:38:20 <fasta> How can I efficiently call one function that is implemented in R repeatedly?
08:38:45 <phobes> twanvl:  That's not associative   x << (y << z)  /=  (x << y) << z
08:39:29 <quicksilver> twanvl: maybe it's a monad but only if you restrict to to infinite lists (streams) ?
08:39:36 <quicksilver> twanvl: and maybe that's the source of the confusion?
08:42:47 <ttfh> is the topic right? NO side effects?
08:43:12 <ClaudiusMaximus> :t take
08:43:13 <Olathe> ttfh: Well, your computer won't have any.
08:43:14 <lambdabot> forall a. Int -> [a] -> [a]
08:43:26 <Olathe> ttfh: You, on the other hand, will have an aching brain.
08:44:12 <ttfh> Olathe: but I can have side effects, in a safe way
08:44:17 <sjanssen> ttfh: it's more accurate to say that side effects are controlled
08:44:49 <Botje> controlled? "gagged and bound" seems more likely
08:45:03 <puusorsa> well they like it
08:45:24 <sjanssen> things that will produce side effects are wrapped in 'IO', and the type system guarantees that we can only execute those IO actions inside another IO action
08:46:13 <mux> tackling the awkward squad :-)
08:46:55 <ttfh> "with CONTROLLED side effects" doesn't have the same ring to it
08:47:22 <sjanssen> ttfh: hmm, you might say that we don't have "side" effects, only "main" effects :)
08:47:40 <Olathe> We have special effects.
08:47:41 <int-e> we take no responsibility for exhausting your memory though
08:47:54 <Philippa> ttfh: on a strictly semantic level, Haskell has no side effects whatsoever
08:48:08 <Olathe> "Like in the movies ?!" Yes.
08:48:14 <Philippa> from a pragmatic point of view, it only has the side effects you build yourself, which you'll end up being forced to control
08:54:50 <Tac-Work> @pl map (\(_, x) -> (x++))
08:54:50 <lambdabot> map ((++) . snd)
08:55:44 <doserj> quicksilver, phobes, twanvl: see
08:55:44 <doserj> http://www.haskell.org/pipermail/libraries/2007-July/007725.html
08:55:45 <lambdabot> Title: Proposal: Data.Stream
08:55:51 <Baughn> ...why does happy depend on happy? How am I supposed to compile it?
08:55:54 <Mitar> how could i read a binary file and represent it as a integer value
08:56:11 <Mitar> (so a stream of bits represent to an integer)
08:56:30 <Baughn> Mitar: Read the octets, do a bit of bit-shifting and ORin?
08:56:41 <Mitar> ohh
08:56:59 <Mitar> i thought there is something more higher level
08:57:16 <oerjan> :t readInt
08:57:19 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
08:57:33 <Baughn> Mitar: There probably is, but hackage is down, so.. *shrug*
08:57:55 <oerjan> Mitar: in principle you can do base 256 with readInt, i think
08:58:15 <Baughn> > chr 255
08:58:17 <lambdabot>  '\255'
08:58:20 <oerjan> > chr 0
08:58:22 <lambdabot>  '\NUL'
08:58:26 <Baughn> Mm. Shouldn't be a problem.
08:58:32 <Olathe> > chr -5
08:58:33 <lambdabot>   add an instance declaration for (Num (Int -> Char))
08:58:33 <lambdabot>     In the expression: ...
08:58:52 <Olathe> > chr (-5)
08:58:54 <lambdabot>  Exception: Prelude.chr: bad argument
08:59:06 <pejo> Hm. Is darcs.haskell.org down?
08:59:18 <Baughn> Yes
08:59:36 <oerjan> otoh, for a big Integer, building it up digit by digit could mean a lot of copying...
08:59:56 <Baughn> The compiler might get clever
09:00:23 <Baughn> It does that a lot. Say, is there a precompiled version of happy for OSX/intel somewhere?
09:00:27 <vincenz[away]> "GHC WARNING > You're trying to build a big Integer, allow me to give you a clue-stick.  Please smack user with clue-stick"
09:00:45 <oerjan> well, i recall a comment that ghc doesn't even do strictness analysis on Integers properly.
09:01:26 <oerjan> @src Integer
09:01:27 <lambdabot> data Integer = S# Int#
09:01:27 <lambdabot>              | J# Int# ByteArray#
09:01:41 <oerjan> :t GHC.Exts.J#
09:01:46 <lambdabot> GHC.Prim.Int# -> GHC.Prim.ByteArray# -> Integer
09:02:07 <oerjan> you might be able to use that if you are willing to be non-portable
09:02:20 <phobes> doserj:  thanks
09:02:57 <oerjan> Happy generates Haskell, doesn't it?
09:04:17 <oerjan> might be able to copy the generated code from somewhere, in case nothing else works.
09:04:54 <oerjan> @src readInt
09:04:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:06:42 <Mitar> @src readInteger
09:06:43 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:06:46 <oklokok> @read srcInt
09:06:47 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
09:06:52 <Mitar> @src Data.ByteString.Char8.readInteger
09:06:53 <Olathe> lambdabot: Yes. I won.
09:06:53 <lambdabot> Source not found. You speak an infinite deal of nothing
09:07:21 <oerjan> :t Data.ByteString.Char8.readInteger
09:07:24 <lambdabot> Data.ByteString.Base.ByteString -> Maybe (Integer, Data.ByteString.Base.ByteString)
09:08:30 <quicksilver> doserj: so I was basically correct? ZipList forms a monad over infinite lists?
09:09:03 <oerjan> quicksilver: Monad? not just Applicative?
09:09:09 <quicksilver> oerjan: right
09:09:13 <quicksilver> oerjan: that was the question
09:09:20 <quicksilver> oerjan: "ZipList is an Applicative, is it also a Monad"
09:09:35 <quicksilver> oerjan: the answer appears to be "Yes, but only if the lists are all infinite"
09:09:40 <doserj> quicksilver: yes
09:10:06 <quicksilver> doserj: that table doesn't show a way of making Stream a Monad under nondet
09:10:16 <doserj> quicksilver: the other interesting thing there is that usual lists do not form a monad
09:10:18 <quicksilver> doserj: I thought that was possible if you made the join some kind of fair-choice thing
09:10:52 <doserj> nondet means concatMap
09:10:59 <doserj> you cannot concatMap infinite lists
09:11:13 <quicksilver> you can do a kind of fairchoice over infinite lists
09:11:25 <quicksilver> which is "the same" on finite lists (but the ordering is wrong)
09:11:34 <quicksilver> but also "Works" on infinite lists
09:11:48 <doserj> ?
09:11:51 <mrd> > concatMap (:[]) [1..]
09:11:52 <quicksilver> I thought that made infinite lists a monad under a kind of nondet
09:11:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:12:07 <mrd> > concatMap (const [1..]) [1..]
09:12:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:13:12 <doserj> mrd: think about concatMap reapeat
09:13:12 <quicksilver> doserj: I wrote the code once but I can't find it :(
09:13:14 <phobes> What is the .HI file format?
09:13:16 <phobes> .hi
09:13:23 <quicksilver> doserj: it's simpler to just consider concat
09:13:24 <ToRA> @paste
09:13:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:13:25 <mrd> > concatMap repeat [1..]
09:13:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:13:32 <quicksilver> doserj: concat doesn't work on an infinite-list of infinite lists, obviously
09:13:40 <quicksilver> doserj: but, you can do a diagonal zig-zag
09:13:53 <quicksilver> doserj: and get a productive stream which eventually enumerates any particular element
09:13:58 <quicksilver> doserj: and that's "good enough", I think
09:14:07 <mrd> phobes: it changes from ghc version to version, can probe the ghc devel wiki i guess. or hs-plugins src.
09:14:23 <phobes> mrd: thanks
09:14:37 <quicksilver> doserj: ah, I found the code. One moment, will hpaste
09:14:45 <Botje> @src foldr
09:14:45 <lambdabot> foldr k z xs = go xs
09:14:45 <lambdabot>     where go []     = z
09:14:45 <lambdabot>           go (y:ys) = y `k` go ys
09:14:49 <Botje> oh duh
09:15:15 <quicksilver> doserj: http://hpaste.org/2903
09:15:19 <oerjan> there is a step from having a productive version of concatMap on infinite lists to having something that actually satisfies the monad laws.
09:15:20 <paolino> [(x,n) | x <- xs | m <- ms , n <- m] , how can I make repeat also x every n in m ?
09:15:25 <mrd> phobes: you might have to go to the ghc src
09:15:35 <ToRA> is the pastebot down?
09:15:40 <oerjan> !paste
09:15:41 <hpaste> Haskell paste bin: http://hpaste.org/
09:15:43 <quicksilver> oerjan: indeed there is. But my instincts say that is satsifies the monad laws "up to something sensible"
09:15:47 <ToRA> as in announce
09:15:51 <phobes> mrd:  Nah, I'm going to adandon the idea - thanks though :)
09:15:51 <quicksilver> oerjan: that is "up to re-ordering of infinite lists"
09:16:12 <quicksilver> oerjan: which I don't care about, since my semantics of non-determinism cares about possibilities but not the order they are produced in.
09:16:15 <ToRA> mmm, anyways, http://hpaste.org/2902
09:16:43 <ToRA> can someone look at that and tell me if i'm being dense please?
09:17:17 <mrd> you can't instance a type synonym
09:17:47 <paolino>  do  (x,m) <- zip xs ms ; n <- m; return (x,n)  is what I expected from the comprehension above
09:17:58 <oerjan> quicksilver: i.e. really a monad of sets
09:17:59 <quicksilver> mrd: you can with -fglasgow-exts, I think
09:18:08 <quicksilver> oerjan: no, multisets
09:18:11 <ToRA> i have the t-s instances flag turned on
09:18:11 <mrd> i've never heard of that
09:18:11 <oerjan> er, multisets
09:18:17 <quicksilver> oerjan: repetition is allowed and considered important
09:18:19 <quicksilver> oerjan: right
09:18:23 <mrd> does it even make sense?
09:18:33 <quicksilver> mrd: you have to be a bit careful with overlaps
09:18:40 <mrd> just a bit ;)
09:18:43 <quicksilver> mrd: but its' convenient to be able to make String an instance of show directly
09:18:53 <quicksilver> mrd: rather than some bizarre isString trick
09:19:38 <quicksilver> ToRA: however, it appears that you can't partially apply type synonyms
09:19:47 <quicksilver> ToRA: which is not something I knew, but I'm not surprised
09:20:02 <ToRA> quicksilver: yeah, i kinda knew that
09:20:15 <quicksilver> ToRA: try it with newtype instead?
09:20:16 <ToRA> quicksilver: but it seems look like something that should so obviously have a way to do
09:21:02 * paolino waves
09:21:55 <quicksilver> ToRA: I can't think of a deep reason why you shouldn't be able to partially apply type synonyms I must admit
09:22:08 <paolino> is parallel list comp an unfinished feature ?
09:23:18 <ToRA> would type families provide a solution?
09:23:29 <ToRA> (i'm using 6.8 because of other magic in the code)
09:24:00 <oerjan> ToRA: the problem is that haskell's type class lookup tries hard _not_ to be higher order, for decidability.  So the only thing that can be made an instance of a class is a data or newtype constructor minus some of the last arguments.
09:24:31 <oerjan> *data type or newtype constructor
09:25:02 <oerjan> this allows simple unification to be used rather than higher-order.
09:25:09 <oerjan> iiuc
09:26:02 <oerjan> i don't know if there are any extensions that change this fundamental fact of Haskell 98.
09:26:35 <quicksilver> oerjan: ah, thank you, that's interesting
09:26:42 <ToRA> oerjan: ah ok, ta for that
09:27:07 <quicksilver> ToRA: my gut feeling is that, yes, type families and associated types would be a solution for you
09:27:10 <quicksilver> ToRA: but I'm not sure
09:27:32 <int-e> paolino: why do you think it's unfinished?
09:27:33 <quicksilver> depends if you can partially apply an associated type and make it an instance
09:27:44 <fasta> Are there any libraries for computing the unbiased variance of a list of numbers?
09:28:00 <int-e> paolino: it's a language extension but you probably know that.
09:28:40 <phobes> fasta: isn't that a one-liner?
09:28:52 <fasta> phobes: probably not
09:29:12 <fasta> phobes: you can try
09:29:35 <fasta> phobes: http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
09:29:37 <lambdabot> Title: Algorithms for calculating variance - Wikipedia, the free encyclopedia
09:29:43 <fasta> phobes: I want the one by Knuth.
09:30:40 <phobes> ah, you want to be able to update the variance?
09:31:18 <fasta> phobes: ?
09:31:32 <phobes> fasta: nm, interesting - I always use the bad way :)
09:31:36 <fasta> phobes: It's a single value, there's nothing to update about it.
09:31:43 <fasta> phobes: I already assumed you did.\
09:32:08 <lindzeyn> I passed ghc these flags ghc --make -O2 -prof -auto-all +RTS -M1G -c -B -t --RTS myFile.lhs
09:32:12 <oerjan> a State action should be able to do that
09:32:14 <lindzeyn> and got this error
09:32:15 <fasta> Anyway, I would rather just call R (the statistics programming language).
09:32:25 <lindzeyn> Could not find module `List':
09:32:27 <lindzeyn>       Perhaps you haven't installed the profiling libraries for package haskell98?
09:32:46 <lindzeyn> I've been hunting for said package
09:32:48 <fasta> But.. I don't know how to do that lots of times without starting <lots of times> a new process.
09:32:51 <takamura> This is not a Haskell question, but anyway... What is the equivalent on Windows to the Unix shell command separator ; ?
09:32:56 <phobes> fasta:  The reason I asked 'isn't that a one-liner' is so that you'd enlighten me :)
09:33:21 <fasta> phobes: now, if only someone would enlighten me...
09:33:56 <oerjan> could still be a one-liner
09:34:29 <phobes> ya, looks like it could be implemented with a fold
09:34:39 <fasta> oerjan: yes, could be. I think I will just read the article by Knuth, since probably nobody else has.
09:35:43 <jonathanv> takamura: &&
09:35:51 <takamura> thanks, jonathanv
09:35:54 <EvilTerran> or &
09:36:04 <jonathanv> & works too?
09:36:16 <EvilTerran> && is the equivalent to &&, it short-circuits if the first command returns nonzero
09:36:26 <jonathanv> oh i see
09:36:27 <EvilTerran> & doesn't, so it's more like ;
09:36:37 <EvilTerran> there's no equivalent to shell's &
09:37:09 <paolino> int-e : my example of use behave buggy imo
09:37:30 <EvilTerran> well, there's start "..." & ...
09:37:48 <jonathanv> cmd sucks
09:38:00 <jonathanv> there's always cygwin
09:38:21 <lindzeyn> does anyone know where I could obtain the heap profiling package for haskell98
09:38:49 <EvilTerran> I have nothing against cmd, actually. an awful lot of shell functionality's snuck in in the last decade.
09:38:56 <int-e> paolino: oh. but [(x,n) | x <- xs | m <- ms , n <- m] gets desugared to [(x,n) | (x,(m,n)) <- zip [x | x <- xs] [(m,n) | m <- ms, n <- n]]
09:38:57 <EvilTerran> with different names, yes, but it's there...
09:39:46 <int-e> paolino: personally I never found parallel list comprehensions very useful.
09:40:07 * EvilTerran just uses zip explicitly
09:40:13 <phobes> fasta:  So this is a numerically better way to calculate means, too?
09:40:47 <oerjan> that knuth algorithm is discustingly imperative.
09:40:53 <fasta> phobes: I am no expert at numerics.
09:41:11 <oerjan> update each variable, then use the new value, in the _same_ iteration.
09:42:00 <quicksilver> oerjan: Knuth had different optimisation constraints to thsose we have now :)
09:42:07 <quicksilver> oerjan: and he was very smart at using them
09:42:49 <int-e> oerjan: the algorithm is designed for incremental updates.
09:43:07 <phobes> Seems like a more precise algorithm would be to first find the mean (maybe using this method), then sort the elements by distance from the mean, the accumulate variance least to greatest
09:43:49 <oerjan> phobes: "For a particularly robust two-pass algorithm for computing the variance, first compute and subtract an estimate of the mean, and then use this algorithm on the residuals."
09:44:16 <oerjan> (under the knuth algorithm)
09:45:19 <phobes> oerjan:  I saw that - I'm just suggesting that sorting residuals from least to greatest (magnitude) seems like it would provide additional precision
09:45:54 <tibbe_> @seen dcoutts
09:45:54 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 8m 5s ago.
09:46:00 <tibbe_> dcoutts: ping
09:46:02 <dcoutts> hia tibbe_
09:46:22 <tibbe> dcoutts: I just started to write a UnicodeString proposal
09:46:28 <byorgey> oerjan: all knuth algorithms are disgustingly imperative =)
09:46:57 <tibbe> dcoutts: I'll continue tonight when I get home
09:47:01 <tibbe> dcoutts: http://haskell.org/haskellwiki/UnicodeByteString
09:47:02 <lambdabot> Title: UnicodeByteString - HaskellWiki
09:47:18 <tibbe> I've only written the motivation so far, feel free to add
09:47:22 <dcoutts> tibbe: oh, great
09:48:02 <dcoutts> tibbe: looks fine so far
09:49:32 <twanvl> I found a way to make zip lists into a monad (using a different zip list type)
09:50:35 <dcoutts> tibbe: so we should make clear that the level of abstraction we're aiming for is about the same as what [Char] provides, ie a sequence of "Unicode code points". Remember that code points do not correspond directly to characters in many cases.
09:50:50 <Mitar> how can i construct ByteArray#?
09:51:02 <phobes> What's the relationship between Applicative and Monad?
09:51:04 <tibbe> dcoutts: I really need to read up on that, I'll do that when I get home too
09:51:09 <dcoutts> tibbe: indeed the concept of a character in Unicode is rather fuzzy
09:51:17 <dcoutts> tibbe: right'o
09:51:20 <oerjan> @hoogle ByteArray#
09:51:20 <Cale> phobes: Every Monad is an Applicative functor, but not the other way around.
09:51:20 <phobes> I didn't see any instance declarations going either way
09:51:21 <tibbe> dcoutts: yep
09:51:21 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
09:51:35 <phobes> So there is an instance Applicative => Monad?
09:51:39 <EvilTerran> phobes, monad = applicative + monoid. i'm not sure exactly how that works, but that's what i'm told
09:51:44 <phobes> err backwards
09:51:49 <Cale> no, but there could be an overall class constraint like that
09:51:57 <EvilTerran> @instances Applicativ
09:51:58 <EvilTerran> @instances Applicative
09:51:59 <lambdabot> Couldn't find class `Applicativ'. Try @instances-importing
09:52:00 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
09:52:19 <Cale> Or, you could write a great big overlapping instance which did Monad m => Applicative m
09:52:58 <Cale> pure = return, <*> = ap
09:52:59 <oerjan> @instances-importing Control.Applicative Applicative
09:53:00 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
09:53:13 <oerjan> @hoogle byteArray
09:53:14 <lambdabot> No matches found
09:53:15 <lindzeyn> last question, is there a flag that you can throw that will make all data stay within the heap
09:53:18 <oerjan> @hoogle bytearray
09:53:19 <lambdabot> No matches found
09:53:21 <lindzeyn> no virtual memory
09:53:27 <lindzeyn> in ghc that is
09:53:36 <phobes> Cale:  I see, it's the overlapping instance problem that stops people from doing that
09:53:38 <tibbe> dcoutts: I'm going to write the proposal as if newtype UnicodeString = ByteString and only take up the possibility of type UnicodeString enc in the discussion as I want a concrete example instead of lots of discussions and no concrete proposal
09:53:49 <Cale> phobes: yeah
09:54:02 <dcoutts> tibbe: I'd start with newtype UnicodeString = String :-)
09:54:16 <tibbe> dcoutts: yeah, as long as it's ADT
09:54:19 <int-e> lindzeyn: you can restrict the heap size. it's really up to the OS what it swaps and what stays in memory.
09:54:22 <phobes> I don't like the way overlapping instances are handled
09:54:22 <tibbe> so I can change it to BS
09:54:26 <dcoutts> tibbe: in fact the underlying representation should not matter at all
09:54:32 <tibbe> dcoutts: exactly
09:54:38 <phobes> It seems like you should have a mechanism for choosing which instances you want to apply locally
09:54:49 <tibbe> dcoutts: I have to think about what functions belong on BS vs US also
09:54:55 <dcoutts> tibbe: so perhaps it's best not to start out by giving an example as it brings along a lot of baggage
09:55:06 <MrEggCollector> guize HELLO
09:55:07 <MrEggCollector> BYEEEE
09:55:09 <tibbe> dcoutts: you mean the Motivation?
09:55:28 <tibbe> dcoutts: or just not mentioning the newtype?
09:56:02 <dcoutts> tibbe: you can leave it abastract in the description, data UnicodeString
09:56:02 <Cale> lindzeyn: +RTS -M<size>  on the commandline of a compiled program will set the maximum heap size
09:56:04 <tibbe> dcoutts: I want to outline the implementation though so I can get feedback on it, otherwise it'll be too abstract.
09:56:09 <dcoutts> tibbe: I think most Data.List functions apply to a unicode string
09:56:29 <dcoutts> tibbe: then just say the underlying representation etc will be similar to bytestring
09:56:40 <tibbe> dcoutts: are there any functions in BS that you feel don't belong there because they're too character specific instead of byte specific
09:56:52 <tibbe> dcoutts: right
09:56:57 <dcoutts> tibbe: in fact it probably would not be newtype since the ByteString api isn't necessarily best for the implementation of the unicode layer
09:56:59 <lindzeyn> cool, thanks.
09:57:10 <tibbe> dcoutts: right
09:57:37 <dcoutts> tibbe: not really, if you look at ByteString vs ByteString.Char8, there are several ones in Char8 that are not in the Word8 version, but not the other way around
09:57:43 <tibbe> dcoutts: although I'm not well versed enough in the ByteString implementation to tell
09:57:52 <phobes> Why won't lambdabot respond to :t in private sessions?
09:57:55 <dcoutts> tibbe: ie I can't think of any functions on the Word8 that we do not have on the Char8 version
09:57:57 <tibbe> dcoutts: ok
09:58:23 <dcoutts> tibbe: in both cases they're extended subsets of the Data.List api
09:58:28 <tibbe> dcoutts: hmm, why wouldn't the newtype do though?
09:58:34 <tibbe> dcoutts: right
09:58:52 <dons> ?yow
09:58:53 <lambdabot> Someone in DAYTON, Ohio is selling USED CARPETS to a SERBO-CROATIAN
09:58:57 <dcoutts> tibbe: you'd probably want direct access to the data, not via Data.ByteString functions
09:59:16 <shapr> @yow !
09:59:17 <lambdabot> Don't hit me!!  I'm in the Twilight Zone!!!
09:59:21 <oerjan> phobes: strange. well @ty works.
09:59:22 <dcoutts> hia dons
09:59:25 <shapr> greetz dons
09:59:35 <wli> re dons
09:59:40 <dcoutts> dons: I need to pick your brains about the bytestring searching functions
09:59:59 <phobes> oerjan: ya, I figure out @type worked
09:59:59 <dcoutts> dons: the current api was more or less chucked in without a great deal of thought
10:00:34 <dcoutts> dons: and I'm worried about freezing it, since it steals the best names and is not the api we'd want for lazy bs searching
10:00:42 <tibbe> dcoutts: right but ByteString lets you touch its internal representation no?
10:01:18 <dcoutts> tibbe: true, true. It's not all that important what it's exact internal rep is. I suggest being vague about it otherwise it distracts people from the real point.
10:01:42 <dons> dcoutts: hmm. i agree
10:01:42 <tibbe> dcoutts: right, I was planning to describe to get a US from a BS and vice versa
10:01:47 <dons> but i suspect we're running out of time :)
10:01:56 <tibbe> dcoutts: and sketch the API
10:01:57 <dons> i'm more worried about every package that depends on D.B.Base breaking atm
10:02:09 <dons> dcoutts: perhaps we can do a bytestring-search package to sort out the api
10:02:11 <tibbe> dcoutts: and mention change to the I/O api (or a new one)
10:02:13 <dons> and tie that in to the next release
10:03:06 <dcoutts> dons: and just remove/deprecate the ones in bytestring-0.9 for the moment?
10:03:20 <dons> leave 'em there, then deprecate once we've sorted out the api
10:03:26 <tibbe> dcoutts: I'm heading home, ttyl
10:03:28 <dcoutts> tibbe: that's fine, conversion functions in the api are fine
10:03:43 <dcoutts> tibbe: they're mostly independent of the internal rep, except for performance
10:03:59 <tibbe> dcoutts: right
10:04:29 <dcoutts> dons: well, we might want to bring searching back into the bytestring package once we've settled the api and at that point we'd be changing the types of the functions
10:04:54 <dcoutts> dons: where as if we deprecate them now, it gives people warning, and we get more testers for the new searching package
10:04:54 <dons> right.
10:05:03 <dons> ok, that would be ok
10:05:09 <dons> the current functions shouldn't be used anyway, right? :)
10:05:13 <cognominal_> @src ($!)
10:05:14 <lambdabot> Source not found. Where did you learn to type?
10:05:14 <dons> since they're suckfully slow
10:05:18 <dcoutts> dons: yes.
10:05:33 <dons> ok. deprecate is fine.
10:05:36 <dcoutts> @arr
10:05:37 <lambdabot> Yeh scurvy dog...
10:05:37 <dcoutts> ok
10:05:38 <dons> do we have a commit list of api changes?
10:05:46 <dons> i'd like to publish that, so we can fix hackage easily
10:05:52 <dcoutts> no, but we can make one
10:06:20 <dcoutts> dons: it's mostly ByteString.Base -> ByteString.Internal or ByteString.Unsafe
10:06:34 <dcoutts> dons: I've updated zlib, bzlib and iconv
10:06:39 <dcoutts> but not binary
10:06:43 <dons> right. and the representation change for lazy bytestrings
10:06:47 <dcoutts> yes
10:06:49 <dons> yeah, binary and hmp3 are broken, slightly
10:07:03 <dons> lambdabot too
10:07:22 <dons> but binary is the main one
10:07:31 <dons> that absolutely must work for 6.8, from the start
10:07:39 <dcoutts> dons: imho, the right thing for this transition is to target cabal-1.2, that way it works with ghc-6.6 and 6.8
10:07:39 <dons> did you know we've 15 or so hackage packages using it now?
10:07:44 <dons> right.
10:07:53 <dons> i think in fact we should have a 'Upgrade FAQ'
10:07:56 <dcoutts> (and indeed earlier versions of ghc are possible too)
10:08:00 <dons> which describes the common things that need fixing
10:08:02 <dons> for everyone
10:08:08 <dons> i.e. start by moving to cabal configuratoins
10:08:09 <dcoutts> dons: it does mean that anyone installing new packages needs cabal-1.2
10:08:13 <dons> add extra packages
10:08:18 <dons> fix bytestring api changes
10:08:20 <dons> etc.
10:08:33 <dcoutts> and we should promote cabal-setup to devs now
10:08:35 <sjanssen> dcoutts: isn't 1.2.0 still broken with tons of packages?  Especially all of them that import Distribution.Simple
10:08:39 <dcoutts> I'm confident it works well
10:08:51 <twanvl> If anyone is still interested, here is a zip list monad type: http://hpaste.org/2905
10:08:53 <dcoutts> sjanssen: Distribution.Setup you mean?
10:09:02 <dons> and cabal-install will come standard with this release?
10:09:10 <dcoutts> dons: that's less clear
10:09:11 <dons> seems more important now the base is split into 6 or 7 new packages
10:09:18 <dons> we're using it here, fwiw.
10:09:19 <sjanssen> dcoutts: right, that's what I mean
10:09:22 <dons> though its not ideal
10:09:53 <dcoutts> sjanssen: I added a dummy Distribution.Setup that re-exports Distribution.Simple.Setup and adds a DEPRECATED notice
10:12:14 <sjanssen> I think a separate binary package for cabal-install is good enough
10:12:14 <dcoutts> sjanssen: however there may be further cases where Setup.hs does not compile that we cannot fix in Cabal-1.2 easily
10:12:14 <dolio> twanvl: Does ap do the same thing as (<*>)?
10:12:14 <dons> it needs more prominance, anyway, cabal-install
10:12:14 <twanvl> It should
10:12:14 <dcoutts> sjanssen: since they're just that those Setup.hs are using internal Cabal apis that have changed
10:12:14 <dcoutts> dons: it needs fixing to cope with configurations
10:12:14 <dcoutts> dons: cabal-install I mean
10:12:14 <sjanssen> dcoutts: makes sense
10:12:14 <sjanssen> dcoutts: is that change available in a .1 release yet?
10:12:14 <byorgey> twanvl: neat.
10:12:15 <dcoutts> sjanssen: not yet, I've asked Igloo to move a bunch of recent patches from Cabal HEAD to the 1.2 branch, once that's done I might do another point release
10:12:42 <dcoutts> sjanssen: in almost all cases where there is a non-trivial Setup.hs it can be replaced with configurations and using the simple build system
10:12:45 <twanvl> dolio: QuickCheck seems to think so
10:13:23 <dcoutts> dons: another important point in the upgrade faq is to get people to add: "setup-type: Simple" to their .cabal files if they are using the default Setup.hs
10:13:26 <dolio> twanvl: Close enough, then. :)
10:13:45 <dcoutts> that makes cabal-setup work quicker and is nicer for hackage and other tools
10:14:21 <dcoutts> though we might be able to get that recommendation added as a Cabal QA warning
10:14:22 <dons> ok, should we start a wiki page?
10:14:28 <dons> or a ghc wiki page
10:14:32 <dcoutts> dons: yeah, we should
10:14:37 <nominolo> dcoutts, so having cabal-install ready for the ghc release is important, or should we better wait for 6.8.2?
10:14:40 <dcoutts> dons: it's not just a ghc thing
10:15:22 <dons> yes, you're right.
10:15:27 <dcoutts> nominolo: I'm not really sure, it'd be nice but I don't know the ghc-6.8.1 ETA
10:15:50 <dcoutts> nominolo: getting at least the basics fixed would be nice
10:16:00 <dcoutts> nominolo: and if cabal-install can upgrade itself later....
10:16:05 <nominolo> i wouldn't want a badly broken setup-install in a ghc release
10:16:14 <dcoutts> indeed
10:16:35 <sjanssen> I think it's a bad idea to tie cabal-install to ghc releases at this point
10:17:06 <cognominal_> ghc 6.8.8 is out?
10:17:26 <nominolo> nope
10:17:40 <nominolo> 6.8.1 rc 1 is out
10:17:51 <nominolo> it's called 6.8.0 ;)
10:17:52 <cognominal_> oops
10:17:59 <wli> 6.8.0?
10:18:04 <cognominal_> I meant 6.8.0
10:18:09 <nominolo> yes, new versioning scheme
10:18:48 <cognominal_> where is that?
10:18:54 <nominolo> so it's a testing release. hence no major announcement
10:18:57 <byorgey> we should just use Java's versioning scheme and call it, oh, I don't know, GHC 17
10:19:17 <sjanssen> dcoutts: what is the correct Setup.hs to use with a package that needs to run a configure script?
10:19:26 <nominolo> we could call it names, too
10:19:47 <nominolo> ghc "we are family"
10:19:58 <dons> sjanssen: yeah, we want to get this cabal stuff right for xmonad. with testing before hand
10:20:04 <nominolo> or rather "we are (type) family"
10:20:49 <cognominal_> I don't understand the ghc release numbering beyond the traditional linux style
10:20:52 <dcoutts> sjanssen: somewhat distressingly it's "main = defaultMainWithHooks defaultUserHooks"
10:21:00 <dcoutts> sjanssen: ie defaultUserHooks are not the default :-)
10:21:27 <nominolo> i should push in that proposal by simonM
10:21:44 <sjanssen> dcoutts: importing from which module?
10:21:44 <dcoutts> nominolo: which proposal was that?
10:21:50 <cognominal_> nominolo, it is avalaible thru darcs?
10:21:55 <dcoutts> sjanssen: Distribution.Simple as always
10:22:20 <EvilTerran> are there plans afoot to get rid of the dependency on autoreconf?
10:22:26 <nominolo> hooks = emptyHooks `addHook` myHook
10:22:29 <nominolo> or sth
10:22:44 <nominolo> there's a trac ticket
10:22:47 <dcoutts> nominolo: oh, yes, for the next dev cycle we need to sort out the hooks api
10:22:56 <sjanssen> EvilTerran: for X11-extras? no
10:23:02 <nominolo> definitely
10:23:19 <EvilTerran> for cabal in general. i'm yet to see a Setup.hs that doesn't use it.
10:23:43 <dcoutts> dons: see for example my updated zlib: http://haskell.org/~duncan/zlib/zlib.cabal
10:23:46 <nominolo> hooks `onCmd` Before "configure" myHook -- would read nicely :)
10:24:01 <dons> very useful, dcoutts
10:24:06 <EvilTerran> -- * We need to do this via a shell script that has been munged by ./configure,
10:24:06 <EvilTerran> --   as Cabal doesn't give us enough info (eg, no package name and version) to
10:24:06 <EvilTerran> --   do it all in Haskell.
10:24:07 <dcoutts> EvilTerran: only a few cabal packages use autoconf
10:24:26 <dons> dcoutts: are you able to write a short tutorial/faq on porting things to 6.8/cabal 1.2?
10:24:44 <dcoutts> dons: not a complete one, and not before ICFP :-)
10:24:58 <dons> well, we can start making notes
10:24:58 <dcoutts> dons: I can add info to an existing wiki page as I discover it
10:25:06 <EvilTerran> i've seen that sort of thing several times, and i'd expect it to be fixable (by cabal providing the required info)
10:25:16 <dons> dcoutts: i'll create a page now
10:25:22 <nominolo> cognominal, http://www.haskell.org/ghc/dist/stable/dist/
10:25:23 <lambdabot> Title: Index of /ghc/dist/stable/dist
10:25:29 <dcoutts> dons: eg we'll be trying testing the gentoo collection with cabal-1.2 soon and that collection covers most of hackage
10:25:43 <dons> its also easy enough to scp all of hackage, i noticed.
10:25:48 <nominolo> dons, i guess that'd be my job
10:25:50 <dons> so we can do some analysis scripts during the hackathon
10:25:57 <dcoutts> EvilTerran: package name and version of what?
10:26:04 <dons> nominolo: yeah, just trying to build everything would be a start
10:26:12 <EvilTerran> that particular snippet's from c2hs's Setup.hsw
10:26:14 <EvilTerran> *hs
10:26:14 <dons> then spam^h^h^h informing the maintainers about what failed
10:26:18 <dons> with a link to the upgrade faq :)
10:26:22 <dcoutts> dons: yeah, it's all in the hackage index file, just a big tarball of .cabal files
10:26:55 <dcoutts> EvilTerran: c2hs-0.15.0's Setup.hs is the default one.
10:27:27 <EvilTerran> hm. i appear to have 0.14.2 here. it might've gone since i last looked...
10:27:31 <nominolo> dcoutts, i'll fix that c2hs problem today.  if not, please beat me to it ;)
10:27:41 <dcoutts> dons: if we managed the hackage stuff like we do for distros we'd have facilities for the distro maintainers to apply minor patches to make things build
10:28:01 <dcoutts> EvilTerran: it has, I fixed it. :-)
10:28:04 <dons> yeah.
10:28:07 <EvilTerran> oh, awesome!
10:28:08 <dcoutts> nominolo: that'd be great :-)
10:28:16 <dons> nominolo: any news on recategorisation of hackage packages, btw?
10:28:23 <dons> we've got lots of little variants of category names
10:28:33 <dons> i'd like to start restricting the possible values to a known set
10:28:41 <dons> so no "data" , "Data", "data structures" etc
10:28:50 <EvilTerran> sorry 'bout that, i imagine people reporting fixed issues is tedious at best =/
10:28:52 <nominolo> dons, i'm not the hackage guy
10:28:53 <dcoutts> dons: that's not nominolo's area, who was it who did the hackage SoC project?
10:29:00 <nominolo> i'm the cabal configs guy
10:29:00 <dons> ah oops.
10:29:03 <dons> sascha
10:29:04 <dons> ?
10:29:08 <dcoutts> dons: we could start with an alias file
10:29:09 <nominolo> yep
10:29:26 <nominolo> he's not often on irc though
10:29:30 <dons> http://haskell.org/haskellwiki/Upgrading_packages
10:29:31 <lambdabot> Title: Upgrading packages - HaskellWiki
10:29:39 <nominolo> rather, almost never
10:30:43 <dcoutts> dons: it'd be useful to think at the hackathon about 'distro' style maintenance of the hackage collection, ie the ability of the package collection maintainers to add/make minor patches
10:30:54 <nominolo> dcoutts, i'd also like to get the simplified version syntax into cabal-1.2, since that should be easy to test
10:31:00 <dcoutts> dons: we use that facility extensively in debian and gentoo
10:31:08 <nominolo> are there any comments on what would be best?
10:31:11 <dons> i'd like to see upgrade details recorded in this kind of form,
10:31:12 <dons>   http://openbsd.org/faq/current.html#20070326
10:31:13 <lambdabot> Title: Following -current
10:31:15 <nominolo> the best syntax i mean
10:31:26 <dons> so we have a list of api / build changes for each new release
10:31:29 <dcoutts> nominolo: you'll have to propose it to the cabal-devel/libraries lists
10:31:43 <nominolo> meh
10:31:45 <dcoutts> dons: for what? every package?
10:31:46 <EvilTerran> hm. still not building here, but it's closer than it was :)
10:31:48 * EvilTerran -> eats
10:31:56 <dons> dcoutts: things that change in the core
10:32:08 <dons> i.e. what a maintainer needs to know about the core libs, to upgrade
10:32:14 <dons> or at least some of the things
10:32:24 <dcoutts> dons: aye, doing it comprehensively would be hard
10:32:27 <dons> yep
10:32:46 <dcoutts> EvilTerran: c2hs-0.15.0 does not build for you? if not send in a report
10:46:12 <newsham> ?karma+ HWN
10:46:13 <lambdabot> HWN's karma raised to 1.
10:47:29 <dons> @remember dcoutts Of course Cabal-1.2 works perfectly well with all versions of GHC
10:47:29 <lambdabot> Done.
10:47:46 <dcoutts> >= 6.2
10:47:52 <araujo> hello
10:47:59 <dons> ok. so we may just ask people to upgrade to cabal 1.2 then
10:48:01 <dons> for xmonad.
10:48:06 <dons> in order to continue supporting 6.6
10:48:10 <cognominal_> I am reading http://www.haskell.org/tmrwiki/GeneratingPolyominoes and wonder what is mkSet. Help!
10:48:13 <lambdabot> Title: GeneratingPolyominoes - TmrWiki
10:48:16 <dons> which means widespread distribution of cabal 1.2 packages for older ghcs
10:49:28 <cognominal_> ok, got it
10:50:08 <dcoutts> dons: yes.
10:50:48 <newsham> anyone know the expected growth in number of cores?  doubling every 18mos?
10:51:41 <jonathanv> that's be pretty nust
10:51:43 <jonathanv> nuts
10:52:14 <shapr> dcoutts: Have you tried to build cabal-setup with cabal-1.2 ?
10:52:28 <dcoutts> shapr: yes, I'm using it all the time.
10:52:34 <shapr> dcoutts: Funny, it won't build for me...
10:52:36 * shapr tries again
10:52:37 <dcoutts> shapr: oh, though with Cabal HEAD atm
10:52:49 <shapr> Me too
10:52:51 <dcoutts> shapr: the patches will make it to the 1.2 branch soon I hope
10:53:15 <dcoutts> shapr: well darcs pull Cabal and cabal-setup, it works fine for me.
10:53:26 <shapr> ok, pulling
10:53:29 <shapr> I'll report any problems.
10:53:30 <EvilTerran> hm... ghc doesn't come with alex or happy, does it?
10:53:38 <dcoutts> shapr: I fixed it up the other day
10:56:38 * EvilTerran finishes downloading the alex zip... er, where do i put this stuff, then? on the path?
10:56:59 <dcoutts> EvilTerran: yes, alex.exe on the %PATH%
10:57:23 <EvilTerran> do i need the folder as well, or is that just for building it yourself?
10:59:27 <dcoutts> EvilTerran: alex has a number of data files that it needs to be able to find
10:59:35 <paolino> anyone can show me how to recode takeWhile with ContT List , if possible ?
11:00:46 <EvilTerran> okay. so... put the folder in the .zip in the same place as the executable?
11:00:59 <EvilTerran> (that'd make sense, but i'm trying to avoid breaking anything here ;] )
11:01:26 <dons> dcoutts: join #haskell-hac07 plz :)
11:05:35 <paolino> is ContT List the right tool for pruning lists ?
11:05:49 <EvilTerran> pruning?
11:06:33 <paolino> yes in the end I need to prune permutations , while I produce them
11:07:17 <oerjan> :t contT
11:07:20 <lambdabot> Not in scope: `contT'
11:07:22 <oerjan> :t ContT
11:07:25 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
11:07:44 <paolino> I'm starting with something simple like takeWhile , I hope
11:08:24 <oerjan> paolino: for takeWhile, i wonder if Writer is better than []
11:08:32 <oerjan> as underlying monad
11:08:50 <fasta> paolino: is this for an academic exercise or real work?
11:09:16 <oerjan> or and ErrorT is usually simpler than ContT if it works
11:09:26 <paolino> uhm, I'm tring to solve problem 68 of euler project
11:09:35 <oerjan> s/or //
11:09:47 <EvilTerran> dcoutts (/ other), i get "Setup.hs: Warning: Unknown field 'build-tools'" when running c2hs's Setup.hs - does my Distribution.* need updating or sth?
11:10:04 <fasta> paolino: but the list monad already prunes by itself?
11:10:06 <dcoutts> EvilTerran: no, thats fine
11:10:13 <fasta> paolino: by using guard
11:10:22 <oerjan> paolino: you know you can use guards in list comprehensions?
11:10:28 <oerjan> (or do notation)
11:10:29 <dcoutts> EvilTerran: it's a new field recognised by cabal-1.2 but it works fine with older cabal, it just generates a warning.
11:10:31 <fasta> paolino: so, I don't see why you want to use continuations.
11:10:47 * dolio tries to figure out how haskell-cafe could be "flooded" with redirected traffic from haskell@. :)
11:11:16 <EvilTerran> looking at the contents of it, it would explain why i didn't get an error immediately when trying to build without alex installed ^^
11:11:27 <oerjan> for takeWhile, i could see the need for a quick way to bail out
11:12:33 <EvilTerran> you want some kind of (if p x then <carry on> else <bail out>)?
11:13:39 <paolino> fasta, I tried too little without possibly
11:13:50 <HairyDude> are type classes and types in separate namespaces?
11:14:08 <dolio> I don't think so.
11:14:17 <HairyDude> hm
11:17:07 <paolino> oerjan, I tried some code for takeWhile but I don't know how to exit the returned part
11:17:21 <paolino> the taken part
11:17:24 <omniscientIdiot> HairyDude: They are.
11:17:34 <HairyDude> ah, good
11:18:55 <HairyDude> I'm fiddling with defining an alternative numeric class hierarchy, and it seems pretty odd to me that Real is called Real and not Rational :)
11:19:50 <dolio> 'data Foo ; class Foo a' definitely doesn't work here.
11:20:24 * omniscientIdiot defined a data Ord = X and it worked
11:20:40 <dolio> Those are in different modules.
11:21:01 <HairyDude> /tmp/Test.hs:3:6:
11:21:01 <HairyDude>     Multiple declarations of `Main.Foo'
11:21:27 <HairyDude> looks like dolio is right
11:21:35 <shapr> dcoutts: When I try to build cabal-setup I get ./CabalSetup.hs:14:7:\n    Could not find module `Distribution.SetupWrapper':
11:21:48 <omniscientIdiot> hmm, I thought they were
11:21:59 <dolio> Prelude.Ord and Main.Ord (or wherever they're actually defined) will be different.
11:22:05 <doserj> HairyDude: module export lists would be ambiguous if you could do that
11:22:25 <HairyDude> doserj: didn't know you could specifically import classes
11:22:43 <HairyDude> doserj: but then you might be able to do import Foo (class Foo)
11:22:54 <dcoutts> shapr: just checking I've pushed all my changes...
11:23:06 <doserj> not with the current syntax :)
11:23:22 <omniscientIdiot> right, I was wrong
11:23:53 <HairyDude> doserj: well yes, like I said, might :)
11:24:30 <dolio> Is that the only place where it's ambiguous? If so, it might be nice to allow both.
11:24:52 <omniscientIdiot> it seems like they could be seperated in principal if not for that
11:24:54 <dolio> To allow people to make existential wrapper types with the same name as classes for all your OO programming needs.
11:25:13 <dcoutts> shapr: oops, yes, I've not pushed them all, gimme a sec...
11:26:12 <HairyDude> dolio: I was thinking more in terms of class Num a => Rational a where fromRational :: a -> Rational (where type Rational = Ratio Integer)
11:26:43 <dolio> There is that, too.
11:27:17 <elliottt> does anyone know who authored the hackage scripts?
11:27:32 <dons> ross mostly
11:27:50 <sjw> dons: re
11:27:53 <dons> yo sjw
11:28:03 <elliottt> ok, maybe i should send him an email about the cabalization i did
11:28:23 <dons> yeah. i'd just ping him, describe the support, and send the patches
11:29:53 * bos wishes the new string search stuff was in ByteString already :-(
11:30:28 <dons> bos, just the stuff Chris wrote?
11:30:33 <dons> (Chris et al)
11:30:39 <bos> dons: yes
11:30:49 <dons> oh, he only pasted it to the list, didn't he.
11:30:50 <bos> with my suggested tweaks to dcoutts's api
11:30:56 <dcoutts> bos: we cant agree on the api quickly enough it would appear
11:30:59 <dons> dcoutts: did we want to just stick it in a cabal package then?
11:31:09 <dons> i'd like bytestring-search for 1 ghc cycle
11:31:14 <dcoutts> dons: so far we've not put it anywhere
11:31:16 <dons> then merge into bytestring once we've used it a bit
11:31:20 <bos> dcoutts: where's the disagreement lie?
11:31:23 <dcoutts> bos: I'm happy to talk about the api
11:31:30 <dcoutts> bos: that's not even clear :-)
11:31:42 <dcoutts> bos: you saw the thread on the libraries list
11:31:53 <bos> dcoutts: yes, and i was very happy with my suggestion :-)
11:33:31 <bos> wow, dropWhile is expensive
11:33:54 <EvilTerran> is it possible to have haddock output linked into my local copy of http://haskell.org/ghc/docs/latest/html/libraries/ ?
11:34:09 <sjw> later
11:36:42 <dcoutts> bos: what makes dropWhile expensive?
11:38:12 <bos> dcoutts: calling the predicate
11:38:18 <bos> using elemIndex is much faster
11:38:43 <bos> i.e. LB.drop (fromJust . elemIndex ' ')
11:40:24 <EvilTerran> that's less flexible, mind
11:40:31 <bos> of course
11:40:46 <dcoutts> bos: elemIndex uses a C lib function
11:40:52 <bos> but bumming bytestring performance is fun
11:41:20 <EvilTerran> um.
11:41:27 <dcoutts> bos: dropWhile (/=' ') could be specialised
11:41:37 <EvilTerran> "Warning: cannot use package c2hs-0.15.0: ghc-pkg failed" when "runhaskell Setup.hs haddock"ing
11:41:44 <dcoutts> bos: well dropWhile (/=w) for any w
11:42:32 <bos> dcoutts: yes, that would be winnage
11:42:44 <bos> and likewise for takeWhile
11:43:21 <oerjan> what about findIndex?
11:43:24 <EvilTerran> and (==w), i suppose
11:43:41 <dons> > 1+2 -- race!
11:43:43 <lambdabot>  3
11:43:44 <oerjan> it seems to hover in between there
11:43:49 <dons> well, network settle first..
11:43:55 <lambdabot-usa>  3
11:43:56 <oerjan> (in spirit)
11:43:57 <dons> ?bot
11:43:58 <lambdabot> :)
11:44:01 <sieni> > 2+2 -- I won!
11:44:03 <lambdabot>  4
11:44:05 <dons> that's weird. maybe it is the firewall
11:44:07 <lambdabot-usa> :)
11:44:13 <lambdabot-usa>  4
11:44:14 <dons> since its instantaneous on the inside of the network
11:44:34 <dons> > 1+1
11:44:35 <lambdabot>  2
11:44:35 <lambdabot-usa>  2
11:44:38 <dons> ah..
11:44:45 <dons> > sum [1..100000]
11:44:46 <lambdabot-usa>  5000050000
11:44:47 <lambdabot>  5000050000
11:44:52 <dons> now we're talking.
11:45:34 <dons> ok. so we might do the migration later
11:46:16 <omniscientIdiot> > ack g_64 g_64
11:46:16 <lambdabot>   Not in scope: `g_64'
11:47:17 <oerjan> i have some vague doubts that it would finish within the 3 seconds...
11:47:57 <omniscientIdiot> you never know :)
11:48:07 <bos> i've been playing with a silly benchmark of tim bray's for log file processing, just to take a break from book work.
11:48:42 <bos> he has this little ruby script that rummages through an apache log file. perl is about 2x faster.
11:48:44 <oerjan> omniscientIdiot: that would take some seriously lazy integer implementation
11:49:08 <bos> python is about the same speed as perl.
11:49:20 <bos> with posix regexps, haskell is about 25% slower than python.
11:49:33 <bos> with pcre, it's about 15% faster.
11:49:50 <dons> cool.
11:49:57 <dons> regexes would be the limiting speed, i'd imagine
11:49:57 <bos> with a handwritten rummager, haskell's over 2x faster.
11:49:59 <EvilTerran> hpaste, poke?
11:50:02 <dons> given experience with the shootout
11:50:15 <dons> and careful hand written strict bytestring search, avoiding regexes, can really scoot
11:50:34 <bos> and i wrote a parallel file processor, so i can use both cores on my laptop.
11:50:45 <bos> which improves performance by a further 45%.
11:50:54 <dons> mm. very nice
11:51:01 <flux> how about compiling re to haskell and linking it in with hsplugins?-)
11:51:17 <EvilTerran> http://hpaste.org/2906 <- the "runhaskell Setup.hs haddock" error in full
11:51:23 <bos> so the end result is that the haskell code is about 4x faster than the python, 8x faster than the ruby, and maybe 200x faster than erlang.
11:52:36 <pejo> bos, how long did it take you to write the Haskell and perl solutions?
11:52:37 <oerjan> erlang is that slow?
11:53:40 <dons> strings in erlang are like [Char] bad old days
11:53:43 <dons> running in hugs
11:54:01 <ndm> hmm, i wonder if regexps can be optimised "better"
11:54:35 <ndm> i wonder if a clever static optimiser could pull them apart at compile time and drop down really efficient string prodding
11:56:36 <Philippa> definitely
11:56:56 <Philippa> best if your regexp representation isn't a string, of course
11:58:21 <dylan> I think erlang has something like bytestrings, though
11:59:09 <dons> strict, unboxed?
12:00:32 <ndm> does erlang have lazy strings?
12:01:03 <dons> they seem to have some issues with largish files, fairly regularly, so i don't think any lazy bytestring is widely available
12:01:53 <dolio> They have some kind of binary thing that seems to be the recommended way of doing I/O.
12:02:12 <dolio> With easy (de)serialization from various stuff, I think.
12:04:23 <vincenz> dolio: going to hac?
12:10:52 <EvilTerran> ...
12:13:37 <EvilTerran> is there a setting somewhere where you specify what folder "runhaskell Setup.hs install" copies things into by default?
12:15:36 <doserj> Setup.hs configure --user --prefix=...
12:17:20 <EvilTerran> defaults, though?
12:21:16 <doserj> http://www.haskell.org/ghc/docs/latest/html/Cabal/builders.html#setup-configure-paths shows the defaults
12:21:17 <lambdabot> Title: 3. Building and installing a package, http://tinyurl.com/ox63q
12:22:29 <doserj> I think these are hardcoded in Cabal
12:23:06 <EvilTerran> bah
12:36:52 <matthew-_> has anyone written an irc server in haskell?
12:37:20 <EvilTerran> okay, i've got c2hs... now what?
12:44:17 <psnively> Hi guys. :-)
12:44:55 <byorgey> hi psnively =)
12:45:13 <psnively> How's stuff?
12:46:20 <byorgey> INSUFFICIENT DATA FOR MEANINGFUL ANSWER
12:46:35 <psnively> Yeah, good point.
12:48:31 <monochrom> There is sufficient data. "How's stuff?" the necessary and sufficient answer is "Stuff is how stuff should be."
12:48:57 <eyeris> I am just learning haskell. Is there a builtin function that returns the first n items from a list, as this does: http://rafb.net/p/AOBWzk57.html
12:48:59 <lambdabot> Title: Nopaste - No description
12:49:48 <oerjan> take
12:49:49 <EvilTerran> take
12:49:52 <monochrom> > take 3 "hello wold"
12:49:54 <lambdabot>  "hel"
12:50:18 <eyeris> awesome. Is there a simple reference list for common functions like this? I couldn't seem to find one on the wiki.
12:50:28 <oerjan> @where prelude
12:50:28 <lambdabot> I know nothing about prelude.
12:50:31 <oerjan> gah
12:50:37 <oerjan> @where standard-prelude
12:50:38 <lambdabot> I know nothing about standard-prelude.
12:50:50 <oerjan> lambdabot: you amnesiac!
12:50:55 <eyeris> @where Prelude
12:50:55 <lambdabot> I know nothing about prelude.
12:50:59 <eyeris> hrm :)
12:51:19 <oerjan> @docs Prelude
12:51:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
12:51:20 <EvilTerran> @docs Prelude
12:51:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
12:51:38 <bakert_> @docs records
12:51:38 <lambdabot> records not available
12:51:55 <eyeris> Thanks
12:51:57 <bakert_> Are there any shortcuts to adding two records together or do I need to define such an operation myself in detail?
12:52:06 <bakert_> (where the fields are Ints)
12:52:15 <oerjan>  @docs only takes a module name afaik
12:52:15 <EvilTerran> grr. stop being faster than be, oerjan!
12:52:17 <EvilTerran> *me
12:52:23 <oerjan> bwahaha!
12:52:48 <EvilTerran> bakert_, as in something like zipRecordWith (+) aRecord anOtherRecord (if zipRecordWith existed)?
12:53:00 <bakert_> EvilTerran: yeah
12:53:00 <EvilTerran> if that's what you're after, then no.
12:53:02 <EvilTerran> sorry.
12:53:03 <bakert_> :(
12:53:13 <oerjan> only for lists
12:53:16 <EvilTerran> go yell at the haskell' people 'til they put a good record system in
12:53:26 <bakert_> i don't like records.  but i don't know how to write programs without them!
12:53:32 <oerjan> possibly some other types
12:53:43 <oerjan> but not self-defined ones
12:53:59 <bakert_> i'm storing 13 numeric values.
12:54:06 <EvilTerran> however, if all your fields are of the same type, you could data FooFields = Foo | Bar | Baz | ... deriving Ix, and then use an Array FooFields Int instead of your record
12:54:10 <EvilTerran> @docs Data.Array
12:54:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
12:54:16 <bakert_> they could be [(String, Int)]
12:54:20 <bakert_> i suppose
12:54:45 <EvilTerran> hm. there doesn't seem to be an appropriate function for what you're after for arrays, either
12:55:01 <bakert_> or even a list where certain positions always refer to the same thing.  but that sounds icky.
12:55:04 <oerjan> no zipArray?
12:55:12 <bakert_> ?hoogle zipArray
12:55:12 <lambdabot> No matches found
12:55:15 <EvilTerran> @docs Data.Set
12:55:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
12:55:26 <EvilTerran> @type Data.Set.unionWith -- this could be useful
12:55:29 <lambdabot> Not in scope: `Data.Set.unionWith'
12:55:35 <EvilTerran> unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
12:56:12 <bakert_> i'm not sure if that gels with the idea of them being name=value pairs
12:56:17 <EvilTerran> not Set.
12:56:18 <twanvl> If you add an instance Monoid Int, then you can use Data.Derive to derive instance Monoid MyRecord, which gives you mappend :: MyRecor -> MyRecord -> MyRecord
12:56:19 <EvilTerran> Map. doh.
12:56:36 <EvilTerran> @docs Data.Map
12:56:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
12:56:45 <EvilTerran> @type Data.Map.unionWith
12:56:47 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> Data.Map.Map k a -> Data.Map.Map k a -> Data.Map.Map k a
12:57:09 <bakert_> ah.  looks good.
12:57:28 <EvilTerran> that'll give you name/value pairs, if you create a data FooFields as above (except deriving (Eq, Ord) instead of Ix)
12:57:54 <oerjan> i just realized...
12:58:02 <bakert_> So do you normally shy away from Records in favor of this kind of thing?
12:58:05 <oerjan> if your record is really _all_ Int fields
12:58:17 <bakert_> yes it is
12:58:35 <EvilTerran> won't be anywhere near as efficient at runtime as doing it manually, but would be (hopefully) less typing.
12:58:37 <bakert_> although i have about 10 other record types that aren't
12:58:53 <bakert_> records just break out all over when i start programming in haskell :(
12:59:13 <bakert_> oerjan: what did you realise?!
12:59:25 <oerjan> oh wait, doesn't work
12:59:26 <EvilTerran> @go haskell extensible records
12:59:27 <lambdabot> https://research.microsoft.com/users/simonpj/Papers/records.htm
12:59:40 <oerjan> i just thought there would be a way to fill it in from a list
12:59:51 <oerjan> but you cannot extract to a list
13:00:14 <bakert_> oerjan: i could keep it as a list, with "constants" to point at each value.  but that is just yuk.
13:00:19 <oerjan> some kind of generic programming should work
13:00:30 <EvilTerran> hm. not the one i was looking for.
13:01:26 <bakert_> I think Data.Map holds out some promise.  At least to these bits.  How I will ween myself off records in general will have to wait for another day :)
13:01:29 <bakert_> thanks!
13:02:27 <EvilTerran> bakert_, there might be something to be gained from looking at Data.Generics, as well
13:02:31 <bakert_> Then again, with records I guarantee that each name=value pair appears in the data structure once and once only.  Which is not enforced for Data.Map.
13:02:39 <EvilTerran> (well, Scrap Your Boilerplate in general)
13:03:41 <bakert_> Scrap Your Boilerplate looks exciting.  Will this work now without extra installing?  Or is it some kind of extension?
13:04:46 <Heffalump> I think it comes with GHC
13:04:57 <Heffalump> certainly it works with standard GHC extensions
13:05:04 <bakert_> cool
13:06:04 <iguana_> what's scrap your boilerplate about?
13:06:24 <bakert_> generic programming
13:06:29 <bakert_> http://www.cs.vu.nl/boilerplate/
13:06:31 <lambdabot> Title: Scrap your boilerplate ... in Haskell
13:06:50 <Cale> iguana_: generic programming. You can do things like apply a function to all the Integers occurring anywhere in a data structure.
13:08:20 <iguana_> sounds nice
13:08:46 <iguana_> that's really the exciting thing about haskell, so many nice concepts
13:08:54 <iguana_> now I only need to find use cases :)
13:10:33 <EvilTerran> ?type gzip
13:10:39 <lambdabot> Not in scope: `gzip'
13:10:48 <EvilTerran> gzip :: GenericQ (GenericM Maybe) -> GenericQ (GenericM Maybe)
13:11:11 <EvilTerran> that there's the trouble with SYB - type signatures from hell ;)
13:12:08 <iguana_> hm... how would it defined bzip2? :D
13:12:40 <pejo> iguana, a compiler is a great use-case for the traversal of datastructures.
13:12:55 <iguana_> right
13:15:41 <olsner> ctk (haskell compiler toolkit) is kind of disappointing in that manner - as far as I understand, it basically uses unsafePerformIO tricks to get mutable data structures
13:15:47 <olsner> I may be completely wrong though
13:20:42 <dons> olsner: well, it is circa 1998. style was different back then
13:21:10 <dons> gzip :: ByteString -> ByteString -- btw
13:21:49 * EvilTerran gurgles
13:22:00 <olsner> 9 years old? go figure... but is there anything similar out there?
13:22:06 <EvilTerran> dons, i think that's a different gzip
13:22:32 <EvilTerran> @type Data.Generics.Twins.gzip
13:22:35 <lambdabot> forall a a1. (Data.Generics.Basics.Data a1, Data.Generics.Basics.Data a) => Data.Generics.Aliases.GenericQ (Data.Generics.Aliases.GenericM Maybe) -> a -> a1 -> Maybe a1
13:22:46 <dons> oh, not generic zip :)
13:23:48 <olsner> meanwhile, my toasted bread has gone stale
13:27:48 <EvilTerran> HA!
13:28:40 <byorgey> EvilTerran: did you defeat your arch-nemesis?
13:29:33 * EvilTerran pasted "bakert_: using Data.Generics to add records pairwise" at http://hpaste.org/2909
13:29:39 <EvilTerran> ... why isn't hpaste announcing?
13:29:53 <byorgey> @seen hpaste
13:29:53 <lambdabot> hpaste is in #haskell. I last heard hpaste speak 4h 14m 11s ago.
13:29:59 <omniscientIdiot> @slap hpaste
13:29:59 <lambdabot> why on earth would I slap hpaste
13:30:08 <byorgey> those bots stick together, you know
13:30:25 * EvilTerran wanders off. bbiab.
13:30:39 <bakert_> EvilTerran: nice.
13:31:27 <swiert> ndm: ping?
13:36:45 <pejo> swiert, he left quite a while ago?
13:37:35 <bakert_> @seen ndm
13:37:36 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1h 34m 12s ago, and .
13:38:26 <shapr> dcoutts: Pushed cabal-setup?
13:47:18 <bakert_> Is there an easy way to implement show for a function so that it just doesn't display?
13:47:43 <bakert_> instance Show (A -> B) where ...
13:47:45 <bakert_> ?
13:47:50 <KatieHuber> instance Show T where show = const ""
13:47:52 <KatieHuber> ?
13:47:52 <sorear> instance Show (a -> b) where showsPrec _ _ = drop
13:48:06 <sorear> s/drop/tail/
13:48:12 <bakert_> tail?
13:48:17 <sorear> yes
13:48:29 <sorear> KatieHuber's solution will give (Foo  23)
13:48:50 <sorear> mine deletes the character immediately after the function
13:49:02 <sorear> ...which I suppose breaks in the (Foo 23 ) case
13:55:07 <bakert_> sorear, KatieHuber: thanks
13:59:25 <Caelum> anyone know if this code is supposed to work? it doesn't work for me: http://www.cs.nott.ac.uk/~gmh/Parsing.lhs
14:00:17 <sorear> looks like it should
14:00:45 * Caelum tries again
14:01:20 <eyeris> f :: a -> (a -> a)  -- what does this function return? Is that a function that takes a parameter of type a and returns a value of type a?
14:01:23 <monochrom> It compiles.
14:01:36 <olsner> eyeris: that's the same as f :: a -> a -> a
14:01:40 <KatieHuber> @paste
14:01:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:02:00 <shachaf> eyeris: It takes a value of type a and returns a function that takes another value of type a, and returns a third value of type a.
14:02:28 <swiert> Caelum: What's wrong with it?
14:02:30 <monochrom> welcome to higher order functions, where functions return functions
14:02:31 <Caelum> sorear: when I try to run something like item "abcdef" I get: Couldn't match expected type `[Char] -> t' against inferred type `Parser Char'
14:02:47 <KatieHuber> if I have this: http://hpaste.org/2910 can I somehow make a default implementation of pairs in A in terms of pairs' in B for instances of B?
14:03:09 <shachaf> Caelum: Try using parse.
14:03:14 <monochrom> You are not supposed to item "abcdef"
14:03:30 <eyeris> ok, so if I want to make a function that takes 3 lists and returns 3 lists, how do I write the function definition?
14:03:49 <shachaf> Caelum: Monad instances can't be type aliases, they have to be newtypes.
14:03:52 <monochrom> You have probably misunderstood the purpose of item.
14:03:53 <sorear> f a b c = (a', b', c') where...
14:04:12 <Caelum> shachaf: that works, thank you
14:04:23 <eyeris> erm, the function declaration
14:04:28 <eyeris> function type
14:04:46 <mauke> [a] -> [b] -> [c] -> ([a], [b], [c])
14:04:47 <omniscientIdiot> KatieHuber: as far as I understand, subclasses can't give default supermethod implementations.
14:05:32 <KatieHuber> OK, thanks
14:05:39 <KatieHuber> annoying, but scarcely the end of the world ;)
14:06:25 <omniscientIdiot> KatieHuber: but you could provide a pairsDefault outside of B, and tell your class users that if they have instance B T where domain = ..., then they should define instance A T where pairs = pairsDefault
14:06:42 <KatieHuber> yeah, that's what I'll end up doing
14:06:47 <shachaf> eyeris: [a] -> [b] -> [c] -> ([a] -> [b] -> [c] -> r) -> r would also work.
14:06:57 <mauke> hehe, CPS
14:07:04 <shachaf> eyeris: Or ([a],[b],[c]) -> ([a],[b],[c])
14:07:18 <shachaf> Both of those seem a bit more symmetrical.
14:07:33 <Caelum> shachaf: where can I learn more about Monads? The book doesn't cover them in too much detail
14:07:39 <shachaf> Caelum: It does.
14:07:50 <Excedrin> was there something about probability announced on the mailing list recently?
14:07:51 <monochrom> I posit that it does, too.
14:07:53 <shachaf> Caelum: It just doesn't call them that.
14:07:54 <eyeris> I was using the ([a], [a], [a]) -> ([a], [a], [a]) form but I was getting 'Coultn'd match expected type' errors ...
14:08:08 <shachaf> Caelum: Parser is a monad, for example.
14:08:11 <jsedgwick> I don't want to start a flame war, but for a beginner in functional languages, would you recommend to start with Erlang, Haskell, or something else?
14:08:25 <shachaf> eyeris: You have to call the function "f (xs,ys,zs)" then.
14:08:28 <Caelum> shachaf: I see that, but I mean how to write the ghc syntax for them
14:08:38 <shachaf> Caelum: That's later on in the book, I think.
14:08:42 <monochrom> But in the good spirit of "you need three books", I add Richard Bird's "introduction to functional programming using haskell". It is heavy on monads too.
14:08:44 <shachaf> Caelum: When it talks about type classes.
14:08:56 <Caelum> oh ok...I'm only on chapter 9, I'll shutup until I finish the book :)
14:09:01 <shachaf> Caelum: (This is generic Haskell syntax, not just GHC.)
14:09:34 <shachaf> Caelum: Monads are just (>>=) and return, together with a few simple laws (and a bit of syntax sugar, do-notation).
14:10:18 <Cale> If you want, I can take you on a tour of some monads.
14:10:49 <monochrom> jsedgwick: I would still recommend starting with Haskell.
14:11:02 <omniscientIdiot> KatieHuber: http://www.haskell.org/haskellwiki/Class_system_extension_proposal
14:11:04 <lambdabot> Title: Class system extension proposal - HaskellWiki, http://tinyurl.com/ypupbe
14:11:57 <eyeris> shachaf does that mean my returns have to be (as, bs, cs) too?
14:13:00 <KatieHuber> omniscientIdiot: looks helpful :)  Is such a thing likely ever to actually be implemented?
14:13:43 <omniscientIdiot> KatieHuber: look at the implications section
14:14:01 <omniscientIdiot> i.e. I'm not sure :)
14:14:24 <KatieHuber> hmm
14:14:51 <KatieHuber> Oh well, not like I'd wait for it even if it was in GHC 6.8 already so...
14:15:16 <Cale> Caelum: Is there any information about monads which you'd be particularly interested in?
14:15:46 <eyeris> What is the type of :? Is [a]:a legit?
14:15:57 <Cale> eyeris: (:) :: a -> [a] -> [a]
14:16:00 <sorear> @type (:)
14:16:02 <lambdabot> forall a. a -> [a] -> [a]
14:16:03 <omniscientIdiot> @ty (:)
14:16:05 <lambdabot> forall a. a -> [a] -> [a]
14:16:06 <monochrom> [a]:a is not legit.
14:16:19 <sorear> [a]:a is not legit for monotyped a
14:16:28 <sorear> > let a = [] in [a] : a
14:16:30 <lambdabot>  [[[]]]
14:16:42 * sorear <3 DM
14:16:57 <omniscientIdiot> > let snoc = flip (:) in [1] `snoc` 2
14:16:59 <lambdabot>  [2,1]
14:17:12 <eyeris> grr... I hate the way every haskell tutorial brags about how easy strings are to use. They are only easy once you drink the koolaid.
14:17:22 <Cale> eyeris: If you'd like to add elements to the end of a list, use ++
14:17:30 <Cale> (with a single element list)
14:17:38 <sorear> @remember eyeris grr... I hate the way every haskell tutorial brags about how easy strings are to use. They are only easy once you drink the koolaid.
14:17:39 <lambdabot> Done.
14:17:42 <Cale> However, try to avoid doing that repeatedly.
14:17:47 <eyeris> @type ++
14:17:49 <lambdabot> parse error on input `++'
14:17:56 <eyeris> @type (++)
14:17:58 <lambdabot> forall a. [a] -> [a] -> [a]
14:17:59 <sorear> eyeris: I think you just set a record for fastest entry to the lambdabot quote database
14:18:02 <sorear> :)
14:18:05 <Cale> Because xs ++ ys costs O(length xs) steps to fully evaluate
14:18:34 <SamB_XP> sorear: hwo long has eyeris been here?
14:18:59 <sorear> SamB_XP: 1 hour and 15 minutes
14:19:06 <bakert_> /msg lambdabot @quote bakert
14:19:09 <bakert_> oop
14:19:10 <bakert_> :)
14:19:20 <sorear> no
14:19:21 <Cale> So if you make lots of small additions to the end of a list, it's really inefficient.
14:19:23 <sorear> 30 minutes
14:19:30 <sorear> i hate arithmetic :)
14:19:34 <jsedgwick> What is the best Haskell book that starts at the very beginning IYO? I'm coming from C-like languages.
14:19:34 <eyeris> Cale is there an efficient way?
14:19:41 <eyeris> That is also easy?
14:19:53 <sorear> @go Haskell for C programmers
14:19:54 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
14:19:55 <lambdabot> Title: Haskell for C Programmers
14:20:02 <eyeris> I've read tyhat.
14:20:04 <eyeris> that*
14:20:05 <Cale> eyeris: The usual trick is to work with functions which prepend some elements to a list that they're given.
14:20:05 <omniscientIdiot> @go haskell for c programmers
14:20:06 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
14:20:06 <lambdabot> Title: Haskell for C Programmers
14:20:08 <sorear> I wouldn't call it a book, but it is a specific intro
14:20:29 <Cale> eyeris: composition of such functions is fast, and in the end, you can simply apply the function to an empty list
14:20:55 <Cale> Also, once you're used to the idea, it's not very hard at all
14:21:07 <sorear> @src ShowS
14:21:07 <Cale> Let me write up an example...
14:21:07 <lambdabot> type ShowS = String -> String
14:21:09 <Cale> !paste
14:21:09 <hpaste> Haskell paste bin: http://hpaste.org/
14:21:16 <jsedgwick> Forget the C part. Best book overall? I'm trtying to learn FP through erlang/haskell. I have Pragmatic Programming Erlang already
14:21:19 <omniscientIdiot> @src ShowS
14:21:19 <lambdabot> type ShowS = String -> String
14:21:47 <SamB_XP> @where dlist
14:21:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
14:21:54 <Caelum> Cale: thank you, I'm going to finish the book and I see some articles on monads on the haskell.org wiki, going to read those
14:22:01 <monochrom> Cale: I think the general technique of "map f (x:xs) = f x : map f xs" is under-appreciated.
14:22:09 <Cale> Caelum: I recommend the ones I wrote ;)
14:22:09 <omniscientIdiot> jsedgwick: YAHT is the standby recommendation
14:22:09 <omniscientIdiot> @where yaht
14:22:09 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
14:24:08 <xerox> monochrom: and in the near future, with views, we get in all its sweetness map _ [] = []; map (x : (map f -> xs)) = f x : xs
14:24:10 <omniscientIdiot> there's a wiki version if you're averse to pdf
14:24:52 <Cale> eyeris: http://hpaste.org/2911
14:25:15 <eyeris> This is what I'm trying to implement, along with the error message I am getting. Does this error mean that ghci inferred the type of 'head bs' as a or that it inferred the type of bs as a? http://pastebin.ca/709670
14:25:47 <monochrom> Somehow map (x : (map f -> xs)) = ... looks wrong. Incorrect number of parameters.
14:26:17 <xerox> right, I meant map f (x : (map f -> xs)) = ...
14:26:39 <jsedgwick> omniscientIdiot: "standby"== default, of sorts?
14:27:15 <omniscientIdiot> yeah :)
14:27:19 <Cale> eyeris: You're trying to add as as the first element of a list whose only element is the head of bs
14:27:23 <EvilTerran> eyeris, as is a list. as:[head bs] is wrong.
14:27:34 <omniscientIdiot> as in "old standby"
14:27:36 <EvilTerran> "as as" O.o
14:27:36 <Cale> eyeris: However, as is itself a list
14:27:51 <eyeris> Yeah, I figured out that that is wrong
14:27:53 <EvilTerran> you may have meant (as ++ [head bs])
14:27:55 <Cale> which by the type signature you gave, has the same type as bs
14:28:11 <Cale> However, what you really ought to do here is to use pattern matching
14:28:19 <EvilTerran> however, overlap (as:[head bs]) (tail bs) cs should be overlap (as ++ [head bs], tail bs, cs)
14:28:22 <Cale> because it's so much saner than using head and tail everywhere
14:28:26 <eyeris> I can't figure out how to pattern match out the length bs
14:28:27 <EvilTerran> you're mixing tuples and curried application
14:28:43 <Cale> also, computing the length of bs 3 times on every iteration might be a little expensive :)
14:30:18 <eyeris> Ok. I know that as:[head bs] is wrong. I know why. What I don't understand is how I am supposed to infer that from the error message.
14:30:48 <EvilTerran> "In the expression: head bs" tells you that it's talking about the type of (head bs)
14:30:48 <Cale> It's telling you that based on the information it has, head bs has both type a and type [a]
14:31:03 <monochrom> "couldn't match [a] against a" says that.
14:31:04 <EvilTerran> "Expected type: [a]" means "that expression must have this type, from context"
14:31:19 <EvilTerran> "Inferred type: a" means "that expression *actually* has this type"
14:31:43 <eyeris> Ok.
14:32:02 <eyeris> That makes sense. "*In* the expression: head bs" was confusing.
14:32:18 <Cale> That's just telling you where the error occurred.
14:32:30 <eyeris> Right.
14:32:54 <EvilTerran> where's that docu that talks about splitting up Monad into two classes?
14:33:09 <EvilTerran> Bind and Return, or whatever
14:33:33 <phobes> I agree with eyeris that it seems like a poorly phrased error message
14:34:07 <Cale> You get used to the error messages quickly. :)
14:34:11 <phobes> yea
14:34:11 <monochrom> I disagree.
14:34:20 <phobes> The next line clears it up though
14:34:29 <phobes> or at least helps
14:34:40 <sorear> eyeris: good error messages from a damas-milner type inference program are very, very hard.  people have done entire PhDs on improving it...
14:35:01 <leila|wow> good night all
14:38:31 <eyeris> Ok. I think I have that fixed, but now it is complaining that there is no Eq for a. a should be a string. I thought `overlap :: (String a) => ([a],[a],[a]) -> ([a],[a],[a])` would fix that. ghci complains that I use constructor String as a class. What should I be using instead of String?
14:38:33 <Cale> Why might hpaste never remember me? As far as I can tell, I'm accepting cookies.
14:38:46 <Cale> Eq
14:38:47 <phobes> I wonder why it didn't complain about  'as:'
14:38:54 <phobes> Why did it complain about [head bs] ?
14:39:06 <phobes> It's figured out that the resulting type should be [a]
14:39:21 <monochrom> > [1,0] : [ [2], [3,4] ]
14:39:22 <lambdabot>  [[1,0],[2],[3,4]]
14:39:23 <eyeris> phobes: because [head bs] has to be type inferred as part of the as: type check?
14:39:36 <monochrom> That is why, phobes. as:blah is perfectly legit, if blah cooperates.
14:39:43 <Cale> eyeris: (Eq a) => ...
14:39:46 <phobes> heh nm, I'm an idiot
14:39:52 <Cale> eyeris: String is a type, Eq is a class
14:40:11 <phobes> Ok, I think that error message is fine :^)
14:40:13 <phobes> ignore me please
14:40:14 <monochrom> Why not (String, String, String) -> (String, String, String) ?
14:40:26 <Cale> Sure, if you want the less general type.
14:40:30 <EvilTerran> well, Eq a => is more general
14:41:04 <Cale> eyeris: Here's an initial translation of your function to using pattern matching: http://hpaste.org/2912
14:41:11 <eyeris> monochrom because this is taking lists of strings and and finding the overlap between then and returning a new set of lists with the overlapped parts in the third list
14:42:00 <EvilTerran> Cale, doesn't that have different semantics if bs is longer than cs?
14:42:00 <EvilTerran> *as is longer than bs
14:42:09 <phobes> oh actually I understood it just fine
14:42:15 <phobes> man it's tired and I'm late
14:42:23 <eyeris> as can be longer than bs. as is the accumulator list.
14:42:24 <Cale> EvilTerran: hmmm...
14:42:31 <monochrom> ([String], [String], [String]) -> ([String], [String], [String]) ?
14:42:46 <Cale> If bs is longer than cs, you were right the first time
14:42:55 <Cale> yeah, that is different, sorry about that :)
14:42:58 <EvilTerran> yes, sorry, bs and cs. i'm just confused
14:43:00 <phobes> monochrom:  My point was that the error message has figured out that as a parameter to overlap, the resulting type has to be [a].    [a] : BLAH isn't going to give you an [a], it's going to give you an [[a]]
14:43:13 <phobes> monochrom:  So it did have enough information to make a better error message (but I can see why it's hard)
14:43:50 <Cale> http://hpaste.org/2912#a1
14:43:50 <EvilTerran> @go haskell set monad
14:43:50 <lambdabot> http://groups.google.com/group/comp.lang.functional/msg/e10290b2511c65f0
14:43:50 <lambdabot> Title: constructor classes & "set" monad? - comp.lang.functional | Google Groups
14:44:18 <Cale> in fact, that suggests we can use splitAt
14:44:32 <Cale> because we have both take n cs, and drop n cs
14:44:33 <monochrom> I now agree. Thanks.
14:45:25 <Cale> http://hpaste.org/2912#a2
14:47:53 <Cale> and then if we want, we can get rid of n again, because it's only used in one place now.
14:48:23 <EvilTerran> you're missing that Eq a =>, mind
14:48:41 <Cale> yes, I just noticed that :)
14:49:09 <eyeris> How can I manually construct a list of lists of strings?
14:49:12 <Cale> I'm not sure I completely understand the meaning of this function
14:49:19 <mauke_> [[""]]
14:49:35 <eyeris> x = [ [ "abc" : "def" ] : [ "tuv" : "xyz" ] ] gives errors
14:49:46 <Cale> [["hello","world"],["this","is","a","list"],["of","lists","of","strings"]]
14:50:01 <mauke_> s/:/,/g
14:50:22 <Cale> Whenever you have (:) between two things, the thing on the left of the (:) is a single element, and the thing on the right is a list.
14:50:33 <EvilTerran> > ("hello":"world"]:[]):("this":"is":"a":"list":[]):("of":"lists":"of":"strings":[]):[]
14:50:33 <lambdabot>  Parse error
14:50:40 <phobes> > (1:2:3:[]) : (4:5:6:[]) : []
14:50:40 <EvilTerran> > ("hello":"world":[]):("this":"is":"a":"list":[]):("of":"lists":"of":"strings":[]):[]
14:50:45 <ddarius> @unlist [1,3,4,6]
14:50:45 <lambdabot> No module "[1,3,4,6]" loaded
14:50:51 <eyeris> k
14:50:52 <lambdabot>  [[1,2,3],[4,5,6]]
14:50:52 <lambdabot>  [["hello","world"],["this","is","a","list"],["of","lists","of","strings"]]
14:51:00 <eyeris> So : is not just a list element separator
14:51:03 <Cale> no
14:51:05 <EvilTerran> it's cons!
14:51:07 <mauke_> s/just //
14:51:09 <EvilTerran> @src []
14:51:09 <lambdabot> data [] a = [] | a : [a]
14:51:27 <EvilTerran> gotta have an element on the left, and a list on the right. says so right there.
14:51:37 <monochrom> , is the element separator
14:51:38 <phobes> > 1 : (2 : (3 : []))
14:51:39 <lambdabot>  [1,2,3]
14:51:48 <Cale> Every list of type [a] is either the empty list [], or it's x:xs, where x :: a and xs :: [a]
14:51:51 <mauke_> > 1 : [2,3]
14:51:53 <lambdabot>  [1,2,3]
14:52:03 <mauke_> > tail [1,2,3]
14:52:05 <lambdabot>  [2,3]
14:52:13 <Cale> It's that property which allows you to do pattern matching
14:52:14 <eyeris> woohoo, I have a working program
14:52:37 <Cale> eyeris: You should also note how I laid out the if-then-else in your code
14:52:58 <Cale> eyeris: It's not important there, but there are places where it'll break if you don't indent it properly.
14:53:22 <Cale> The 'then' and 'else' should be lined up, and should be indented farther than the 'if'
14:54:34 <Cale> That's different from C, I know, but it makes more sense when you think about it :)
14:54:47 <eyeris> EvilTerran yeah well that's half the difficulty in learning Haskell for me. So much of it is learning to read function signatures which leads to tutorials and books explaining almost everything in terms of function signatures. So if you're like me, having trouble reading function signatures, you go in circles trying to find examples to explain small snippets of each function signature, and the alternate syntaxes for so many things make it difficult
14:55:03 <eyeris> I bet that got cut off...
14:55:14 <eyeris> Cale noted.
14:55:22 <Cale> eyeris: At least you've determined the most important thing to learn first :)
14:55:40 <Cale> eyeris: Type signatures are in some sense the key to learning Haskell quickly.
14:55:57 <Cale> Once you understand the types, most things are easy.
14:56:33 <eyeris> yeah, I can see that.
14:56:36 <SamB_XP> so does this mean we can tell the monad tutorial authors to write about type signatures instead?
14:56:39 <Cale> So with that in mind, perhaps I'll give a bit better explanation of what that (Eq a) => thing is
14:56:57 <eyeris> I actually understand that part
14:56:58 <kscaldef> I think to some extent that's a cop-out for the lack of documentation
14:57:05 <Cale> Normally when you have a type variable in a type signature, it ranges over any type at all.
14:57:19 <Cale> Typeclasses let you restrict which types the variables range over
14:57:28 <kscaldef> I frequently have to locate library functions by figuring out the type of the function I want and hoogling that
14:57:34 <Cale> and in so doing, you can require that certain functionality is present
14:57:45 <Cale> Eq is the typeclass of types which support equality
14:57:50 <SamB_XP> hoogle needs djinn magic ;-P
14:58:18 <monochrom> I swear by type-oriented programming. It's only logical.
14:58:20 <KatieHuber> is Data.Map going to be faster than "lookup" and other simple list ops for very small maps (say, 8-20 elements) ?
14:58:28 <SamB_XP> kscaldef: how would documentation change that?
14:58:38 <eyeris> Cale yeah. After you told me (Eq a) => , it made complete sense.
14:58:49 <KatieHuber> (or should I make a class so I can switch between the two as performance warrants)
14:58:58 <eyeris> Cale: is there a way to specify multiple type classes?
14:59:09 <mauke_> (X a, Y a, Z b) => ...
14:59:11 <Cale> eyeris: yep, you just use commas to separate them inside the ()
14:59:14 <SamB_XP> KatieHuber: which ops exactly?
14:59:26 <eyeris> awesome
14:59:33 <Cale> So yeah, things like (Eq a, Enum a) => ...
14:59:39 <kscaldef> SamB_XP: if functions were better documented, I could read the documentation to figure out what does what, rather than postulating a type signature, hoogling it, and reading the source code
14:59:58 <SamB_XP> kscaldef: how are you proposing to find the documentation?
15:00:07 <KatieHuber> mostly lookup, but occasionally replacing an element with a given key with a new one
15:00:07 <mauke_> :t \x -> 2 * succ x
15:00:15 <Cale> eyeris: There are also typeclasses with more than one type parameter
15:00:16 <lambdabot> forall a. (Enum a, Num a) => a -> a
15:00:26 <Cale> eyeris: Those let you specify relationships between types
15:00:32 <kscaldef> well if, say, I'm using HXT, I would go to the HXT webpage and click on the link to the docs
15:00:43 <mauke> there are also constructor classes :-)
15:00:57 <eyeris> Cale: alright. That sounds cool but I'm going to stick to the basics for now :)
15:01:06 <eyeris> thanks again. I'll likely be back tomorrow :)
15:01:12 <kscaldef> and I would find something more than a list of functions and type signatures
15:01:15 <Cale> An example of that is the immutable array interface:  IArray a e  says that a is an array type having elements of type e
15:01:31 <kscaldef> (picking on one library somewhat unfairly, but it's the one I'm struggling with currently(
15:01:52 <SamB_XP> kscaldef: an overabundance of exported names bordering on obscenity?
15:02:19 * EvilTerran thinks
15:02:49 * EvilTerran notes that writing a SYB "Cast" monad doesn't seem to be possible, even with splitting Monad up and MPTCing it
15:03:27 * EvilTerran wanted liftM2 (+) = \mx my -> do x <- cast mx; y <- cast my; cast (x+y)
15:03:57 <kscaldef> SamB_XP: actually, most of my problems dealt with things being scattered through a dozen or so arrow subclasses, without a good summary of how to do common things
15:04:21 <EvilTerran> return = cast, obviously, but bind isn't gonna type nicely.
15:04:30 <kscaldef> 1 page per module leads to a lot of bouncing around sometimes.
15:05:10 <twanvl> EvilTerran: perhaps Applicative?
15:05:29 <EvilTerran> maybe...
15:06:21 <SamB_XP> kscaldef: that doesn't help much either
15:15:17 <EvilTerran> twanvl, it's not Applicative either - i need the Typeable constraint on the parameter
15:19:06 <Saizan> EvilTerran: Monad2 m a b doesn't work either?
15:20:21 <EvilTerran> i'm having trouble with (>>=) :: m a -> (*a* -> m b) -> m b
15:20:47 <augustss> EvilTerran: you want a monad with a context on bind like most everyone else, I bet :)
15:21:14 <EvilTerran> I tried that, it doesn't stick
15:21:20 <augustss> I know
15:21:30 <monochrom> I'll find you an Oleg article on that.
15:21:35 <EvilTerran> even with the -fno-implicit-prelude trickery
15:22:54 <EvilTerran> i think you're thinking of http://article.gmane.org/gmane.comp.lang.haskell.prime/483
15:22:56 <lambdabot> Title: Gmane -- Mail To News And Back Again
15:23:29 <monochrom> Yes.
15:24:37 <ndm> @karma+ augustss -- Data.Numeric.Natural
15:24:38 <lambdabot> augustss's karma raised to 4.
15:25:17 <augustss> :)
15:25:32 <nominolo> @karma  Data.Numeric.Natural
15:25:32 <lambdabot> Data.Numeric.Natural has a karma of 0
15:26:09 <augustss> But it's not exactly what Colin wants.  1-2 generates an exception
15:26:25 <ndm> I think length is the one everyone will actually use
15:26:25 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
15:26:41 <ndm> although i would have liked lengthNat as a typecast version of genericLength
15:26:58 <ndm> otherwise genericLength [1..] > 10 has undefined semantics without knowing types etc
15:27:04 <augustss> and takeNat, dropNat
15:27:26 <ndm> yeah, but length is the one everyone will actually use :)
15:27:28 <twanvl> dropNat is not useful
15:27:55 <augustss> twanvl: you're right, it's not that useful
15:29:07 <augustss> efficient naturals will require some horrible hackery
15:29:30 <Igloo> ndm: genericLength already has undefined semantics if you don't know the types
15:29:48 <ndm> Igloo: yes, but this would lead to more surprises :)
15:30:23 <ndm> we planned them out on a whiteboard at york, IORef (Integer, Nat) did the trick
15:30:42 <augustss> ndm: and unsafePerformIO
15:30:44 <ndm> with plenty of unsafePerformIO
15:31:04 <ndm> what was surprising is just how few operations actually let you move stuff out of Nat and into Integer
15:31:29 <ndm> once information ends up in the Nat, it rarely makes it back to the Integer
15:31:30 <augustss> ummm, really?
15:31:45 <ndm> yeah, we initially had a few operations doing that
15:31:59 <ndm> but then examining their strictness information more closely most turned out to be unsafe
15:32:17 <augustss> but any pattern match should be able to move something
15:32:53 <augustss> any that touches that Nat, I mean
15:33:08 <ndm> yes, but thats usually not the interesting bit, since you are typically wanting the answer, rather than to fix up the input
15:33:23 <augustss> Oh, i don't know about that
15:33:24 <ndm> depends how often you use a Natural really
15:33:44 <augustss> I'd fix any Natural as soon as I could
15:34:23 <augustss> Using IORef might make that costly
15:34:40 <augustss> To get good efficiency you need an even lower level hack
15:34:57 <augustss> to avoid the write log in wrireIORef
15:35:32 <ndm> if you have something like >, you can loop until you have decided the answer, then log the answer in both numbers
15:35:44 <augustss> yep
15:36:18 <augustss> and use weak pointers so the originals can be GCed
15:37:35 <augustss> there's almost a phd of optimizations :)
15:37:49 <ndm> Colin has had a student do some of this stuff before
15:37:57 <ndm> he reimplemented the Haskell prelude using lazy naturals
15:38:19 <ndm> i don't think its online though, only in the departmental library
15:38:26 <augustss> sad
15:39:04 <augustss> I think it's a disgrace that Haskell doesn't come with some Natural number type
15:39:23 <augustss> not necessarily the lazy ones.  just anything
15:39:39 <ddarius> [()]
15:39:40 <augustss> since they are so, ummm, natural
15:39:44 <ndm> they are hard to type check
15:39:59 <ndm> or rather things like 4-8 might go wrong and won't be a type error
15:40:23 <ddarius> Yes, they aren't useful as "numbers" the way most programmers (and people in general) view them.
15:40:25 <augustss> avoid unsafeSubtract :)
15:40:54 <ndm> I think it would have been sensible to add type Natural = Integer, just to give interfaces better documentation
15:40:59 <augustss> Most of my uses of numbers in Haskell code could be naturals
15:41:11 <ndm> and then let people do the checking stuff later, dynamically or statically, or not at all
15:41:25 <ndm> its sad that Ada has them, but Haskell doesn't
15:41:34 <augustss> I agree
15:41:38 <augustss> and modula
15:42:51 <ddarius> augustss: When Ints are induction variables, they can usually be replaced with naturals.
15:43:26 <augustss> what I use numbers for mostly is to count things.  so natural numbers would do fine
15:44:06 <ihope> Moduli?
15:44:09 <ddarius> Indeed, but in many cases, Haskell programmers replace those with lists and/or Int/Integer would be fine as wel.
15:44:47 <ndm> i don't think many programmers use [] to count things
15:44:59 <ndm> [()] is not a standard trick
15:45:07 <augustss> it's unnatural
15:45:09 <ddarius> ndm: Yes, they don't count them, they just keep a list of them which is usually more handy.
15:45:21 <ihope> Just create a data declaration saying it's Integer and then add all the classes.
15:45:42 <ihope> newtype IntegerModuloRSA170 = IntegerModuloRSA170 Integer deriving ...
15:46:38 <augustss> And I don't want [()] for counting.  I want a different type.  I like many different types
15:47:03 * ddarius was never (seriously) suggesting [()]
15:48:43 * ndm is fixing a paper which is on the page limit, and one referee has asked for an additional 9 examples!
15:48:47 <Cale> Yeah, it would be nice to have a proper Nat type with properly defined Nat operations, and an efficient implementation.
15:49:39 <ddarius> Cale: And by "efficient" you mean ridiculously inefficient just not as ridiculously as usual?
15:49:52 <Cale> yeah
15:50:06 <Cale> Like using a list of machine integer chunks.
15:50:31 <ddarius> Lazy ByteNumbers!
16:09:15 <bct> so how does one make simple images with haskell?
16:09:22 <bct> i just want a few coloured rectangles and some text
16:10:00 <monochrom> One of the two SOE implementations should work.
16:10:43 <sorear> twanvl++
16:10:46 <monochrom> Graphics.SOE is one. It is in the HGL package. Requires OpenGL.
16:11:02 <monochrom> There is another based on gtk2hs.
16:11:03 <twanvl> what did I do?
16:11:27 <sorear> twanvl: you apparently wrote the utf8 bytestring layer while I wasn't lookign
16:21:22 <BoudewijnE> good evening
16:21:54 <BoudewijnE> can someone help me a bit using parsers?
16:22:38 <Tac-Work> what about them?
16:22:50 <BoudewijnE> well, I'm a CS student learning about these
16:23:01 <BoudewijnE> and I'm using the book "Learning haskell" from hutton
16:23:28 <BoudewijnE> I'm trying to create a parser which takes a string, and returns the 4 integers in it, which are seperated by spaces
16:23:35 <BoudewijnE> input is like "1 2 3 4"
16:23:41 <BoudewijnE> i do NOT want a solution for this
16:23:48 <Tac-Work> gotcha
16:24:00 <BoudewijnE> ^^ is a disclaimer, my teacher hangs around here too ;)
16:24:01 <Tac-Work> what seems to be confusing?
16:24:04 <Tac-Work> heh
16:24:08 <mauke> map read . words
16:24:09 <BoudewijnE> well
16:24:25 <Tac-Work> mauke: (6:22:07 PM) BoudewijnE: i do NOT want a solution for this
16:24:32 <BoudewijnE> there's a chapter about parser sequention in the hutton book
16:24:38 <BoudewijnE> well, i want to learn from it :)
16:24:59 <mauke> Tac-Work: shh, maybe he won't notice
16:25:00 <BoudewijnE> and copying your stuff isn't actually learning
16:25:18 <Tac-Work> heh
16:25:25 <BoudewijnE> but to the task at hand
16:25:39 <BoudewijnE> hutton says this (/me runs to pastebin...):
16:25:46 <Tac-Work> I wouldn't use read anyway, if the input isn't properly formatted, it throws an exception..... and that's just not in the spirit of Haskell
16:27:35 <BoudewijnE> okay
16:27:51 <BoudewijnE> http://pastebin.com/f19740c27
16:27:54 <BoudewijnE> my code
16:28:01 <dons> who says xmonad on OSX makes no sense? http://code.haskell.org/~dons/tmp/Xmonad-OSX.png :)
16:28:10 <BoudewijnE> directly taken from hutton's book
16:28:12 <dons> get yr haskell system software here :)
16:28:14 <BoudewijnE> error :     The last statement in a 'do' construct must be an expression
16:28:18 <BoudewijnE> what to do about that one?
16:28:47 <LoganCapaldo> dons: awesome
16:29:00 <sorear_> BoudewijnE: the indentation is wrong
16:29:14 <Pseudonym> Awesome indeed, but that thing down the bottom really gets in the way.
16:29:17 <BoudewijnE> but where?
16:29:18 <mauke> BoudewijnE: start a new line after "do"
16:29:25 <sorear_> BoudewijnE: are you sure the rest of the do is indented more than the first statement?
16:29:34 <BoudewijnE> @sorear: yes
16:29:35 <lambdabot> Unknown command, try @list
16:29:43 <BoudewijnE> I's an exact copy of the book 8)7
16:29:46 <BoudewijnE> thanks mates :)
16:29:52 <BoudewijnE> I'll give it a shot
16:30:06 <Tac-Work> yeah, your do's are following proper indentation
16:30:24 <Tac-Work> and 'item' is never declared
16:30:46 <Tac-Work> aren't* sorry
16:30:47 <BoudewijnE> well in my textbook it isn't either I'm afraid
16:31:08 <Tac-Work> it's very possible. The most the book costs, the less time the author took to test their own examples X-D
16:31:14 <BoudewijnE> LOL
16:31:20 <BoudewijnE> it was only 40E :)
16:31:33 <BoudewijnE> but do you have a nice example of a simple parser
16:31:45 <BoudewijnE> I want to learn it properly, because haskell is quite cool :)
16:31:55 <Tac-Work> Haskell is
16:32:00 <BoudewijnE> indeed
16:32:01 <Tac-Work> I am relatively new to parsers myself
16:32:22 <BoudewijnE> no problem
16:32:41 <Tac-Work> you seem to be using Parser as a monad
16:32:51 <LoganCapaldo> the type of p looks fishy
16:32:53 <Tac-Work> because of the 'do' notation, Haskell will type it as a monad
16:32:57 <mlh> dons: actually the content of the windows is more interesting for me than xmonad on osx?  Selenium haskell binding .. nice!
16:32:58 <Tac-Work> but it's not a monad
16:33:05 <LoganCapaldo> I don't think Parser has the right kind
16:33:18 <Saizan> uhm, there are other errors: like Parser should be type Parser a = String -> [(a,String)], you can't write Parser (Char,Char) otherwise
16:33:19 <BoudewijnE> yes, go on please
16:33:23 <dons> mlh: heh. yeah, galois is releasing more libs now that things are nicely cabalised and in our local hackage system
16:33:32 <dons> mlh: the selenium bindings are on code.haskell.org
16:33:32 <BoudewijnE> well, it's an exact copy
16:33:35 <Tac-Work> All monads have kind * -> *
16:34:02 <BoudewijnE> okay, anybody's got a simple example for me?
16:34:34 <Saizan> simple example of what?
16:34:41 <BoudewijnE> a parser
16:34:53 <BoudewijnE> due to my textbook seeming to be incorrect
16:35:45 <Tac-Work> http://64.233.167.104/search?q=cache:PBmGO_VK0f0J:www.cs.nott.ac.uk/~gmh/monparsing.ps+monadic+parser&hl=en&ct=clnk&cd=1&gl=us&lr=lang_en
16:35:47 <lambdabot> http://tinyurl.com/yqvdym
16:36:03 <Tac-Work> That looks to be almost exactly what you seem to be wanting to do
16:36:26 <Tac-Work> I was going to read through that document earlier today, but instead I had to work =-(
16:36:34 <BoudewijnE> indeed
16:36:38 <BoudewijnE> thanks people :)
16:37:52 <Saizan> not surprising since it's from hutton :)
16:38:01 <BoudewijnE> lol
16:38:07 <BoudewijnE> and from some UU guys too
16:39:20 <Saizan> BoudewijnE: just to clarify: type Parser a = String -> [(a,String)] is just the type of a particular family of parser combinators, there are others in the standard libs
16:40:03 <BoudewijnE> saizan: that kind of parser takes 1 element from the input string, returns it as 'a' and returns the rest of the input too
16:40:04 <BoudewijnE> ?
16:40:30 <mauke> yes, except the element it returns doesn't have to come from the input string
16:40:43 <ramza3> I am trying to resolve this error (newb question); http://hpaste.org/2915
16:40:55 <BoudewijnE> @mauke, please explain
16:40:56 <lambdabot> Unknown command, try @list
16:41:01 <Tac-Work> that kind of parser must be from haskell way back when, right? It uses a list of 0 length to indicate failture and a list of length 1 for success...
16:41:05 <BoudewijnE> it can be a modified first element too?
16:41:50 <mauke> BoudewijnE: it can be a random value
16:42:00 <mauke> \s -> [(42, s)]
16:42:02 <Saizan> BoudewijnE: it can consume as many elements as it wish, also it's a non-deterministic parser, since it can give you many results: the elements of the list
16:42:36 <BoudewijnE> yes I see
16:42:37 <BoudewijnE> okay
16:42:43 <BoudewijnE> I thin I understand :)
16:42:45 <BoudewijnE> *think
16:43:09 <BoudewijnE> but the idea is that the unparsed part of the input is returned ?
16:43:15 <Saizan> yes
16:43:15 <BoudewijnE> as being the String
16:43:17 <BoudewijnE> ok
16:43:21 <ramza3> I was trying to just print something and then return a data type
16:43:28 <BoudewijnE> I've grasped it, now I have to play around using it :)
16:45:32 <BoudewijnE> good night everybody (it's 1:44 PM over here)
16:45:36 <BoudewijnE> thanks :)
16:45:37 <Saizan> ramza3: your 2 equations for mechKeyboardAct have different types, the first is IO SimplePlayer while the second is SimplePlayer
16:46:19 <ramza3> Saizan, I know but, how would I use putStrLn without it returning IO SimplePlayer ?  If I remove IO, that wont work either
16:47:02 <Saizan> ramza3: you can't, once you're in IO you can't escape
16:47:35 <Saizan> ramza3: if it's for debugging purposes you can use trace from Debug.Trage
16:47:46 <LoganCapaldo> IO, no one gets out alive
16:47:46 <Saizan> ?type Debug.Trace.trace
16:47:48 <lambdabot> forall a. String -> a -> a
16:49:20 <Saizan> ramza3: haskell programs are usually structured such that the logic is in pure functions with a tiny IO layer around them
16:49:50 <ramza3> Saizan, makes sense;
16:52:04 <LoganCapaldo> main :: (Monad m) => IOT m () -- a thought
16:55:22 <Saizan> that's m (IO ()) judging from the other definitions of transformers
16:59:55 <LoganCapaldo> naw I was thinking basically StateT with s always being RealWorld
17:00:50 <LoganCapaldo> you could have type IO = IOT Identity
17:00:56 <kyevan> Hmm...
17:01:21 <LoganCapaldo> except I'd what everything that's currently in terms of IO to be in terms of IOT m
17:01:23 <kyevan> How to go about imitating the LOLCODE types in Haskell...
17:05:15 <_dolio> LoganCapaldo: As I understand it, if you have IOT, you can't ensure that a RealWorld is not used twice (it depends on the underlying monad).
17:05:43 <Saizan> ?src StateT
17:05:44 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:05:46 <LoganCapaldo> dolio: ah
17:05:59 <Saizan> ?unmtl StateT m a
17:05:59 <lambdabot> err: Unknown MTL(1)
17:06:12 <LoganCapaldo> that sounds like a good reason
17:06:26 <LoganCapaldo> Hmm
17:06:30 <LoganCapaldo> Like maybe IOT List
17:06:45 <dolio> Yeah, that's one I'd bet on.
17:06:47 <LoganCapaldo> I could see that maybe using the same real world more than once
17:06:59 <Saizan> you'd get RealWorld -> m (RealWorld,a) so yeah with list you've a lot of worlds :)
17:08:09 <kyevan> Now define RealWorld! What is real? :P
17:09:01 <Saizan> they are writing a book on that!
17:09:20 <chessguy> fascinating stuff: http://cache.libsyn.com/javapolis/The_future_will_be_about_programming_languages.mp3
17:09:22 <lambdabot> http://tinyurl.com/yqmyko
17:09:36 <sorear> real world is __EVIL__
17:09:46 <Pseudonym> sorear: You're a gnostic?
17:10:11 <sorear> Pseudonym: No, I'm a Contist.
17:11:01 <chessguy> err, sorry. http://lambda-the-ultimate.org/node/2469
17:11:02 <lambdabot> Title: The Future(s) | Lambda the Ultimate
17:11:16 <dolio> ++
17:11:27 <sorear> @karma
17:11:27 <lambdabot> You have a karma of 24
17:12:25 <Pseudonym> Ah, yes.  Constists believe that the world will end as soon as someone find the control state that it was created with.
17:14:06 <Pseudonym> Or do they believe that the world is an illusion caused by unbreakable abstractions which only enforce strict sequencing to time?
17:14:37 <allbery_b> Cont, not const :)
17:14:52 <Pseudonym> Yes, Cont.
17:15:14 <Pseudonym> Constists believe that the world was created as-is one Planck time unit ago.
17:15:47 <dolio> LoganCapaldo: If you're interested, there's a paper "Rolling Your Own Mutable ADT" by Chen and Hudak that describes how to derive a monad based on a data structure and a set of linearly typed operations on it.
17:16:13 <LoganCapaldo> dolio: the sound you're hearing is that sentence flying over my head
17:16:33 <LoganCapaldo> mostly the "linearly typed operations" bit
17:16:42 <dolio> LoganCapaldo: Presumably, if you wanted a transformer for it, you'd need to prove things about the underlying monad to prove them about the transformer, or something like that.
17:17:09 <dolio> LoganCapaldo: Think 'uniqueness typing' from Clean. That's how they do IO/mutable data, after all.
17:17:09 <LoganCapaldo> I see
17:18:48 <dolio> So, given a mutable data structure from Clean, you can write a monad that allows you to use that data structure in the same, appropriate way.
17:22:02 <dolio> Although, a haskell compiler probably won't see your monad and implement the data structure with destructive updates and such. You'd probably have to end up using ST (not sure how it works on the Clean end).
17:30:30 <SamB_XP> Pseudonym: oww
17:30:35 <SamB_XP> milk up the nose!
17:31:48 <Pseudonym> Delayed reaction?
17:37:19 <wootles> f :: Int -> Float; f n | n > 0 = (1 - 1/( primes!!(n-1) ) )*(f (n-1)) | otherwise = 1
17:37:55 <SamB_XP> scrollback!
17:38:43 <wootles> i get 'No instance for (Integral Float)' ... i want to cast like in C :(
17:38:52 <Cale> wootles: fromIntegral
17:39:20 <Cale> fromIntegral will convert Int or Integer values to any kind of number whatsoever
17:39:37 <Cale> Or, if you want to go the other way and truncate, there's floor and ceiling
17:39:49 <Cale> :t floor
17:39:51 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:40:00 <Cale> :t round
17:40:02 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:40:05 <Cale> :t ceiling
17:40:07 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:40:13 <LoganCapaldo> > fromIntegral (3 :: Int) :: Float
17:40:14 <lambdabot>  3.0
17:40:36 <Cale> > round pi :: Integer
17:40:37 <lambdabot>  3
17:40:41 <wootles> where do i put the fromIntegral? my interpreter is giving me hate
17:40:49 <LoganCapaldo> LOL
17:41:02 <Cale> wootles: Well, what exactly are you trying to compute?
17:41:03 <LoganCapaldo> Are you using hugs?
17:41:11 <loud-> lol
17:41:13 <wootles> it's (primes!!(n-1))::fromIntegral  ?
17:41:23 <LoganCapaldo> no
17:41:36 <Pseudonym> 1/fromIntegral (primes !! (n-1))
17:41:52 <Cale> :: is read "is of type"
17:41:52 <LoganCapaldo> fromIntegral is a value, not a type
17:41:56 <Pseudonym> Right
17:41:58 <Pseudonym> :t fromIntegral
17:42:00 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:42:04 <wootles> ah, ok
17:42:19 <LoganCapaldo> (did I just say "value"
17:42:28 <Pseudonym> Yes, you did.
17:42:39 <LoganCapaldo> #haskell is clearly getting to me
17:42:41 <wootles> i seem to have gotten a little ahead of myself here, i dived into haskell relying on it to sort out the types for me, but i have no clue how the typing really works
17:42:54 <wootles> so when it hits the fan, i am sunk
17:44:22 <Cale> With numbers the types are important because exactly what results you get very much depend on the types of the numbers involved
17:44:31 <Cale> > 2^1024 :: Integer
17:44:33 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:44:34 <Cale> > 2^1024 :: Int
17:44:36 <lambdabot>  0
17:44:37 <dibblego> is the reduce in google's mapreduce, similar to foldl1 ?
17:45:38 <infrared> it'd better be foldl' or i'm going to switch to yahoo
17:45:53 <infrared> ;)
17:45:59 <dibblego> yeah that :)
17:46:11 <LoganCapaldo> dibblego: I don' remember anymore, but there was a really good paper that talked about what the map and reduce were in map reduce in tersm of things like map and reduce
17:46:23 <LoganCapaldo> err map and fold
17:46:52 <LoganCapaldo> and ISTR that reduce itself wasn't necessarily fold but rather the arameter to reduce might be a fold
17:47:01 <LoganCapaldo> *one of the aprameters
17:47:26 <LoganCapaldo> http://labs.google.com/papers/mapreduce.html
17:47:27 <lambdabot> Title: Google Research Publication: MapReduce
17:49:01 <dibblego> yeah reading thanks
17:49:08 <Cale> http://www.oxxus.net/blog/archives/1263 -- hehehe
17:49:10 <lambdabot> Title: OXXus.net: Web Hosting  I wish Haskell will take over completely then functiona ...
17:49:26 <LoganCapaldo> I'm not sure that's the paper I mean
17:49:40 <Cale> Some sort of automated script using snippets of what looks like #haskell?
17:49:56 <Cale> maybe some #C++
17:51:19 <LoganCapaldo> dibblego: pretty sure this was teh one I was thinking of
17:51:23 <LoganCapaldo> http://www.cs.vu.nl/~ralf/MapReduce/paper.pdf
17:51:37 <LoganCapaldo> that makes explicit compariions to ap and fold, etc.
17:52:00 <dibblego> cheers
17:52:59 <Pseudonym> "If you're not scared or angry at the thought of a human brain being controlled remotely, then it could be this prototype of mine is finally starting to work." -- John Alejandro King
17:53:06 <chessguy> it should come with a warning label: Caution - Explicit references inside. Keep out of reach of children.
17:56:46 <chessguy> @bot
17:56:46 <lambdabot> :)
17:56:54 <chessguy> well, i killed that conversation
18:02:50 <monochrom> what is explicit reference?
18:55:59 <Mr_Awesome> http://hpaste.org/2916  <-- have i made an obvious error to cause stack overflow with this code?
18:56:52 <TSC> Should "size" be "seed" in the if condition?
18:57:08 <TSC> Err, wait
18:59:38 <TSC> Are you sure the overflow is coused by that code?
18:59:59 <Mr_Awesome> when i change this code to just [asteroid <args>], it works
19:02:15 <TSC> Well, it's not obvious
19:03:29 <LoganCapaldo> fwiw you can use zipWith instead of map (uncurry f) zip
19:03:54 <LoganCapaldo> Not that' that' likely to help with the stack overflow
19:06:09 <LoganCapaldo> hey
19:06:18 <LoganCapaldo> where does size come from?
19:07:08 <sorear> LoganCapaldo: Anywhere.  Haskell identifierrs can be exported by any module.
19:07:22 <sorear> LoganCapaldo: So we can't say without seeing the import list
19:07:39 <LoganCapaldo> that's why I was asking
19:08:07 <LoganCapaldo> for all I know size is ausing the stack overflow
19:08:25 <LoganCapaldo> or ^+^ whatever that is
19:08:52 <sorear> it's a smily
19:08:54 <sorear> :)
19:09:00 <LoganCapaldo> heh
19:09:30 <Saizan> but size is forced by the if, however we can't see where's the recursion from that snippet so it's hard to say
19:09:44 <sorear> Mr_Awesome: ftr, if you're going to paste a link in #haskell you might as well just not have unchecked announce
19:09:57 <Saizan> ?seen hpaste
19:09:57 <lambdabot> hpaste is in #haskell. I last heard hpaste speak 4h 48m 47s ago.
19:10:12 <Mr_Awesome> sorear: i was wondering why it didnt show up. announce must have been unchecked by default
19:10:34 <sorear> no, annnounce is checked by default
19:10:37 * sorear ssh
19:11:08 <Mr_Awesome> it either wasnt for me, or i unchecked it by accident. but thats beside the point. size is simply an integer
19:11:10 <Saizan> the bot is stuck
19:11:34 <Mr_Awesome> and ^+^ is vector addition
19:11:45 <Saizan> Mr_Awesome: stack overflow is often caused by lazy accumulators
19:12:07 <Saizan> Mr_Awesome: and simple integers are often an instance of them
19:12:40 <sorear> !paste
19:12:40 <hpaste> Haskell paste bin: http://hpaste.org/
19:12:43 <sorear> Saizan: ?
19:13:05 <Mr_Awesome> Saizan: how are integers instances of lazy accumulators?
19:13:09 <Saizan> sorear: i just annotated a paste with announce checked and it didn't say anything
19:13:18 <Mr_Awesome> i thought a lazy accumulator was something like foldl
19:13:24 <Mr_Awesome> *foldr
19:15:00 <Saizan> Mr_Awesome: take for example foldl (+) 0 [1..3], that results in (((0 + 1)+2)+3) which is just an unevaluated thunk when foldl is done consuming the list
19:16:16 <Saizan> and then when you need the result that expression is traversed till the inner (0+1) before starting to reduce
19:16:31 <Saizan> if your list is longer you get a stack overflow
19:16:35 <Mr_Awesome> well, removing the if statement doesnt remove the stack overflow
19:17:00 <mudge> are actions monads?
19:17:02 <LoganCapaldo> I was wondering a little bit more about the size - 1 bit
19:17:25 <mudge> are actions and monads the same thing?
19:17:32 <Saizan> well, the if statement was helping in making size evaluated early, so reducing possibilities of overflow
19:17:46 <LoganCapaldo> mudge: as a general rule no
19:17:47 <sjanssen> mudge: no
19:17:54 <mudge> what's the difference?
19:17:55 <Mr_Awesome> LoganCapaldo: it spawns asteroids that are 1 size smaller than the current
19:18:26 <sjanssen> mudge: many monads are purely functional, like the [] monad
19:18:43 <sorear> mudge: actions are values, monads are type constructors
19:18:46 <dons> most of them
19:18:52 <Saizan> mudge: a monad is a type constructor like Maybe, IO, [].. an action instead is a value of type Monad m => m a for some a
19:18:54 <mudge> the empty list []  is a monad?
19:19:03 <dons> the type [] is a monadic type :)
19:19:07 <dons> ?instances Monad
19:19:12 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:19:15 <sjanssen> mudge: no, Monads are partially applied types
19:19:23 <dons> :t [] -- the empty list has a type
19:19:25 <sjanssen> so [] is a Monad
19:19:25 <lambdabot> forall a. [a]
19:19:31 <dons> :k [] -- the type constructor [] has a kind
19:19:33 <lambdabot> * -> *
19:19:34 <sjanssen> @kind []
19:19:36 <lambdabot> * -> *
19:20:04 <dons> night all
19:20:25 <LoganCapaldo> Even if IO was the only monad in all the land monads and actions wouldn't be the same thing
19:20:38 <mudge> thanks
19:20:41 <mudge> dons: night
19:20:43 <LoganCapaldo> IO <- monad, putStrLn "Hello, world!" <- action
19:20:59 <swix> I'm trying to write a data structure (type?) for a City that holds a location (x,y) and a name? I can't seem to figure out what to do
19:22:31 <Saizan> swix: data City = C (Int,Int) String for example, where City is the type and C is the contructor
19:22:43 <swix> oooh
19:22:50 <LoganCapaldo> swix: what exactly are you having touble with? The syntax? Or you don't know what information you should keep track of?
19:22:53 <swix> I had type/constructor reversed
19:22:55 <swix> the syntax
19:25:40 <Saizan> swix: you can also use the record syntax; data City = C { location :: (Int,Int) , name :: String } and automatically have location :: City -> (Int,Int), name :: City -> String, and special update syntax like; c{name = "foo"}
19:25:53 <phobes> Anyone know of any factorization or classification result for monads into state and control?
19:33:53 <chessguy> wow. really great lecture linked on LTU today about the future of programming
19:34:08 <mudge> where's that?
19:34:26 <mudge> chessguy: where is this?
19:34:27 <chessguy> http://lambda-the-ultimate.org/
19:34:28 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
19:34:40 <eyeris> procLine :: [String s] -> (Int x, Int y) ; procLine "n":[] = ... -- why I am getting a parse error on the pattern match?
19:35:01 <chessguy> mudge, http://parleys.libsyn.com/index.php?post_id=253927# in particular
19:35:02 <lambdabot> Title: Parleys.com
19:35:41 <eyeris> I'm trying to match a single item list that contains only the string "n"
19:36:00 <eyeris> oh wait.. now it makes sense
19:36:04 <eyeris> it should be ["n"]
19:36:39 <chessguy> i think procLine ('n':[]) would work too
19:37:03 <kpreid> eyeris: that parses as (procLine "n") : "" ...
19:37:58 <ddarius> phobes: I doubt there is one for what you asked for (though that may not be what you meant)
19:38:55 <ddarius> eyeris: This isn't C, you don't write Int x -> Int y.  Just Int -> Int.
19:39:23 <chessguy> oh yes, i was going to point that out too
19:39:37 <ddarius> eyeris: The type signature doesn't bind variables, and it doesn't even make sense to "name" the result.
19:41:15 <eyeris> ddarius Thanks.
19:41:50 <ddarius> phobes: Every monad can be "embedded" into a continuation state monad, if that is useful at all.
19:42:59 <ddarius> eyeris: What you wrote is syntactically correct (but not kind correct).  It's just interpreted as something else altogether, namely applying Int to the type variable x, which is incorrect since Int is not a type constructor.
19:43:11 <ddarius> :t Just
19:43:14 <lambdabot> forall a. a -> Maybe a
19:44:20 <chessguy> err
19:44:30 <chessguy> how can it be syntactically correct if it's not kind correct?
19:45:21 <kpreid> er, because starting with source code, parsing comes before type and kind inference?
19:45:56 <chessguy> ah, so it's valid according to the grammar
19:46:05 <chessguy> ok, i guess i can buy that
19:46:20 <kpreid> > undefined :: [] Char Char
19:46:21 <lambdabot>      Kind error: `[]' is applied to too many type arguments
19:46:21 <lambdabot>     In the type `...
20:04:36 <Mr_Awesome> Couldn't match expected type `g' (a rigid variable) against inferred type `StdGen'  <-- what does this error mean? g is declared RandomGen g =>
20:06:13 <KatieHuber> I think it means you said it was a RandomGen, but from context it knows you're lying, and that it's a StdGen
20:06:22 <sorear> Mr_Awesome: it mmans you declared a type more polymorphic than reality
20:06:39 <sorear> Mr_Awesome: are you using newStdGen / getStdGen / setStdGen / mkStdGen ?
20:06:48 <Mr_Awesome> yeah
20:07:05 <Mr_Awesome> ok, i understand
20:07:27 <Mr_Awesome> when i use mkStdGen the type just has to be StdGen, it shouldnt be a RandomGen
20:50:02 <phobes> ddarius:  thanks
20:59:32 <dibblego> ?hoogle [a] -> [(a, a)]
20:59:33 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
20:59:39 <dibblego> ?djinn [a] -> [(a, a)]
20:59:40 <lambdabot> -- f cannot be realized.
21:01:42 <Tac-Tics> @src readsPrec
21:01:42 <lambdabot> Source not found. Take a stress pill and think things over.
21:02:00 <Tac-Tics> can anyone explain what the "precedence" part of readsPrec actually does/means?
21:10:36 <sorear> Tac-Tics: what's 2 + 3 * 4 ?
21:10:51 <Tac-Tics> >2 + 3 * 4
21:10:56 <Tac-Tics> > 2 + 3 * 4
21:11:01 <lambdabot>  14
21:11:05 <Tac-Tics> It's 14
21:11:07 <Tac-Tics> =-P
21:11:12 <sorear> Tac-Tics: Why isn't the answer 20?
21:11:32 <Tac-Tics> how does precedence play into those functions though?
21:11:52 <johnnowak> 2 3 4 * +
21:11:57 <erg0t> > 3 * 4 + 2
21:11:59 <lambdabot>  14
21:12:02 * FMota wonders.
21:12:20 <FMota> one can have state and still have referential transparency and side-effect freeness
21:12:51 <FMota> without imposing too many restrictions
21:13:05 <FMota> namely, _all_ variables are local.
21:13:36 <johnnowak> FMota: there's Joy
21:13:45 <Tac-Tics> wouldn't that just be a runState inside a pure function?
21:13:59 <FMota> prolly
21:14:14 <FMota> I'm just thinking that state makes a language more expressive.
21:14:39 <Tac-Tics> it does in a way
21:15:00 <Tac-Tics> but Haskell decided that it wasn't worth the sugar to add it to the syntax of the language
21:15:35 <FMota> I suppose it isn't that great of a boon, but y'know, that
21:15:42 <FMota> *'s how everyone else does it.
21:15:51 <FMota> (as in, everyone else has state)
21:16:29 <ddarius> FMota: State only makes a language more expressive (in one sense) if it comes with it's problems too.
21:16:31 <sorear> the haskell family was created specifically to explore the consequences of shunning mutation
21:16:33 <Tac-Tics> Haskell has state too, it's just either doomed to IORef or a nonstandard extension to the language (State monad)
21:16:53 <FMota> mk
21:16:53 <sorear> IORef is even less standard than State :)
21:16:54 <ddarius> Haskell was created specifically to combine research into lazy languages, not pure languages.
21:17:14 <FMota> I see
21:17:17 <sorear> as state is implementable in standard Haskell
21:17:20 <ddarius> Tac-Tics: There is nothing non-standard about the State monad.
21:17:26 <sorear> but IORef requires implementation hooks
21:19:55 <glguy> sorear: did the 'a href' spam check I pushed not work? or have you not had time to "publish"?
21:20:15 <glguy> I wasn't clear after we spoke last about what I was supposed to do
21:20:58 <sorear> glguy: 'not had time' is a bit presumptive, I don't have a life after all :P
21:21:31 <ddarius> sorear: It's good taste to at least pretend that the other person does.
21:21:42 <glguy> :-p I consider your publishing it a favor, so I don't want to impose so obviously
21:21:58 <sorear> done
21:22:34 <Mr_Awesome> hooray, i made my first game with haskell :)
21:22:34 <glguy> awesome
21:22:42 * glguy sets out to spam hpaste
21:22:59 <ddarius> We've found our culprit
21:23:19 <glguy> bwahaha, take that spammers
21:23:31 <stepcut> what is the a href spam check ?
21:23:36 <glguy> we don't allow them
21:23:43 <stepcut> ah :)
21:24:02 <glguy> we escape the HTML, but spammers don't have time to actually verify that the paste worked
21:24:06 <glguy> so they don't seem to realize that
21:25:50 <ddarius> And real users don't post links.
21:26:03 <stepcut> I wonder how much it costs to advertise on hpaste.org
21:26:05 <stepcut> :-/
21:26:15 <glguy> good question!
21:26:20 <sorear> An alarmingly large portion of real users post non-code though. :(
21:26:38 * glguy deletes non code when he sees it
21:26:54 <sorear> Like nburtlett in #happs posting a blob-o-prose that should have gone to a mailing list...
21:26:58 <ddarius> I didn't say they posted code, just that they don't post links.
21:27:19 <ddarius> (at least not in <a href = ...> form
21:27:21 <ddarius> )
21:27:27 <stepcut> are there any plans to add annouce features for more than just #haskell ?
21:27:33 <sorear> yes
21:27:38 <sorear> in the fuzzy future
21:27:40 <stepcut> heh
21:28:43 <glguy> I need to write up some titling guildlines for people
21:28:49 <glguy> "for joe" isn't a valid title
21:30:51 <ddarius> glguy: ?
21:31:43 <glguy> ddarius: a lot of times people forget to give a paste a meaningful title
21:31:59 <glguy> if you are writing a parsing example, then the word parsing should probably appear
21:32:18 <glguy> you being the general case :)
21:32:22 <glguy> "you"*
21:34:22 <glguy> I wonder if there would be any value to allowing people to declare a paste as transitory...
21:35:32 <vegai> glguy: hpaste keeps everything in HAppS State, right?
21:35:47 <glguy> yeah
21:36:04 <vegai> how big is your state currently?
21:36:23 <vegai> if you don't mind the question
21:36:52 * glguy checks under hpaste's skirt
21:37:38 <glguy> RSS 12468
21:37:44 <glguy> VSZ 15292
21:37:49 <glguy> I'll look at the checkpoint file now
21:38:16 * kfish wonders why all haskell code is female
21:38:17 <glguy> checkpoint site: 1.8M
21:38:19 <glguy> size:
21:38:30 <glguy> kfish: same reason as cars
21:38:51 <glguy> predominantly male demographic
21:39:57 <vegai> what, you mean men cannot wear skirts? :P
21:40:03 <vegai> anyway, thanks.
21:42:41 <ddarius> glguy: Isn't the idea that all the pastes are intended to be "trasitory"?
21:42:51 <glguy> not at the moment
21:54:12 <dibblego> ?users
21:54:12 <lambdabot> Maximum users seen in #haskell: 407, currently: 363 (89.2%), active: 8 (2.2%)
22:03:15 <matt__r> what is fptools
22:03:18 <matt__r> ?
22:04:20 <omniscientIdiot> @help fptools
22:04:21 <lambdabot> fptools <lib>. Lookup url of ghc base library modules
22:05:12 <matt__r> cheers
22:05:26 <omniscientIdiot> beyond that I don't know
22:05:39 <matt__r> I need to get it to build lambdabot I think
22:07:29 <swix> is there a better (nicer syntaxically) way to extract a field from a type without using pattern matching
22:07:51 <KatieHuber> records?
22:09:17 <swix> like I have a type City (Integer, Integer) String Float [City], and most of the time I'm only concerned with that float value, and typeing a function eg: comp (City x1 y1 n1 f1 xs1) (City x2 y2 n2 f2 xs2) is a pain
22:09:39 <Zao> If you have   data Foo { bar :: Int }   , you can use   bar afoo  to get the bar record out of it.
22:09:52 <omniscientIdiot> bar :: Foo -> Int
22:09:52 <matt__r> is there a lambdabot online that I can use without spamming a channel people are trying to talk on?
22:10:01 <omniscientIdiot> matt__r: /msg lambdabot @bot
22:10:12 <Zao> Or match on  (City { fieldname=varname })
22:10:50 <matt__r> thanks
22:10:57 <matt__r> omniscientIdiot++
22:11:28 <omniscientIdiot> :)
22:15:38 <swix> Zao, do you have a link to where this is described in more detail?
22:16:02 <omniscientIdiot> there's the report
22:16:43 <sorear> matt__r: don't worry about fptools, it's dead configuration data
22:17:51 <Zao> swix: http://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29
22:17:53 <lambdabot> http://tinyurl.com/24qgex
22:33:21 <matt__r> sorear: cool
22:39:31 <hpaste>  matt__r pasted "plugins code" at http://hpaste.org/2919
22:39:54 <matt__r> plugins is refusing to install with a parse error on the pasted lines
22:40:05 <matt__r> my question is  - what are those lines doing.
22:40:08 <matt__r> ?
22:40:16 <sorear> I'm quite suprised it's not in the readme
22:40:32 <sorear> synopsis: hs-plugins 0.6 is incompatible with ghc 6.6.x
22:40:53 <matt__r> ah- so installing lambdabot is going to be hard
22:41:25 <sorear> installing lambdabot is going to be extremely hard.  I say this as a lambdabot hacker.
22:41:32 <matt__r> the version of plugins I have is claiming to be 1.0
22:41:44 <matt__r> sorear: perhaps I will try a different tack
22:41:58 <sorear> there is a newer version of hs-plugins that works with 6.6
22:42:03 <sorear> but it's not released
22:42:13 <matt__r> I am trying to boost my haskell programming efficiency with some extensions to textmate (editor on the mac)
22:42:14 <sorear> you'll need to get it from the darcs repository
22:42:23 <sorear> same for lambdabot itself - darcs only for 6.6
22:42:31 <matt__r> a lambdabot extension would be cool
22:42:44 <olsner_> why did 6.6 break all those libraries?
22:42:55 <matt__r> I really just need *some* instance of lambda bot that I can easily query when I want
22:43:13 <matt__r> kinda like a "lambdabot service"
22:43:15 <sorear>  /msg lambdabot QUERY
22:43:21 <vegai> olsner_: sloppy coding?
22:43:30 <vegai> olsner_: research mentality?
22:43:38 <matt__r> yep - but then you have to be logged into irc - I don' t know how easy that is to script
22:43:46 <matt__r> better have a look at arcii
22:43:48 <matt__r> ircii
22:43:48 <sorear> olsner_: You're assuming the libraries were written well.
22:44:00 <sorear> olsner_: They were practically designed for fragility.
22:44:12 <sorear> olsner_: this is NOT a documented interface they use!
22:44:12 <vegai> sorear: huh?
22:44:18 <olsner_> of course I am assuming! they're written in haskell ;-)
22:44:34 <sorear> vegai: 6.6 didn't preserve undocumented interfaces
22:44:40 <sorear> vegai: is this a problem?
22:45:16 <vegai> for the users, yes.
22:45:39 <vegai> users don't care whose fault it is
22:46:15 <gvdm> so true
22:50:21 <matt__r> anyone know how to send a single message to irc channel from a script (i.e. without having to interact with the program)?
22:50:49 <KatieHuber> you gotta go through all the handshakey connecty stuff anyway...
22:51:02 <vegai> you could use http://www.suckless.org/wiki/tools/irc and just cat to a file
22:51:06 <lambdabot> Title: irc it &mdash; tools/irc &mdash; suckless.org
22:53:16 <matt__r> vegai: thats pretty neat - thanks
22:53:23 <KatieHuber> that is pretty cool :)
22:55:12 <vegai> I think it doesn't handle disconnects, so that might be a problem
22:55:31 <vegai> oh, but there's a script for doing that right there. Oops.
22:55:53 <glguy> vegai: does it flood until server kick?
22:56:23 <vegai> probably
22:56:43 <reffie> http://www.news.com.au/story/0,23599,22478633-13762,00.html?from=mostpop
22:56:45 <lambdabot> Title: Biker's penis hit by lightning | NEWS.com.au, http://tinyurl.com/ytx2p5
22:56:57 <omniscientIdiot> o.O
22:57:13 * vegai checks the code
22:58:11 <omniscientIdiot> looks like it just tries to join every five seconds
22:58:40 <vegai> omniscientIdiot: unless ii blocks
22:59:17 <vegai> I mean doesn't daemonize. Which I suppose it doesn't, otherwise that script would try to join every five seconds :P
23:00:09 <vegai> yeah, there are no forks in the source of ii
23:01:20 <vegai> I didn't see any flood protection code there, but if you know a little C, shouldn't be hard to add
23:01:30 <vegai> a sleep(1) to a strategic place
23:02:30 <vegai> or implement flood protection in your script that echoes to the file
23:02:41 <vegai> but enough off-topic monologue
23:06:29 <kfish> @botsnack
23:06:30 <lambdabot> :)
23:12:47 <jmob> Anyone use HaXml?  I'm having trouble with entity references in datatypes that are serialized to xml
23:13:34 <jmob> e.g. if I have a record type Foo { bar = "&amp;" } it triggers a "non-exhaustive patterns in function fromContents" exception
23:33:42 <dons> ?users
23:33:43 <lambdabot> Maximum users seen in #haskell: 407, currently: 360 (88.5%), active: 5 (1.4%)
23:34:10 * araujo throws a lambda at dons 
23:39:35 * dons whacks the lambda with a Y combinator, into a nearby black hole
23:40:20 <kfish> trillions of black holes, all made of lambdas
23:41:03 <lament> lambdas all the way down?
23:48:04 <dons> > concat $ fix ("\x -> ":)
23:48:04 <lambdabot>  Illegal escape sequence
23:48:08 <dons> > concat $ fix ("\\x -> ":)
23:48:10 <lambdabot>  "\\x -> \\x -> \\x -> \\x -> \\x -> \\x -> \\x -> \\x -> \\x -> \\x -> \\x -...
23:48:10 <dons> you suck lambdabot
23:49:24 <dons> sorear: we used to be able to put ( in strings.
23:49:37 <Japsu> > "("
23:49:37 <lambdabot>  Unbalanced parenthesis
23:49:48 <Japsu> > "()"
23:49:49 <lambdabot>  "()"
23:49:52 <dons> someone not me broke the parser :( grumble
23:49:57 <Japsu> > read "()" :: ()
23:49:58 <lambdabot>  ()
23:49:59 * dons bans lambdabot patches till its fixed
23:50:09 <dons> fix pointed!
23:50:16 <lambdabot> It wasn't me!
23:50:31 <Japsu> fix pointfree!
23:50:32 <Japsu> ...
23:50:46 <notsmack> i thought lambdabot was done?
23:51:20 <Korollary> lambdabot is infallible
23:51:27 <Korollary> Amen
23:52:16 <lambdabot> Preach it, brother!
23:52:26 * sorear swears never to be shamed into fixing something he doesn't want to again (this bug was introduced as a result of the shamed-patch fixing 6.6.1 compatibility)
23:52:40 <dons> i'll unapply it. bugger 6.6.1
23:53:09 <dons> how a compat patch could break the parser scares me
23:54:36 <Korollary> Static typing hath failed us. The end is nigh.
23:54:41 <glguy> dons: who was the customer for the compat patch?
23:57:54 <sorear> dons: someone else scared me into cloning a sanitization pass
