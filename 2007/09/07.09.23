00:08:49 <gattocarlo> @users
00:08:49 <lambdabot> Maximum users seen in #haskell: 407, currently: 329 (80.8%), active: 3 (0.9%)
00:09:38 <gattocarlo> ah ah, all alone in #haskell...Sunday morning... have a nice day you sleeping..:)
00:09:50 <merus> Heh.
00:09:55 <merus> Sleep is for the week.
00:11:13 <araujo> hello
00:11:13 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
00:11:48 <OceanSpray> Cale, you still here?
00:11:57 <Cale> OceanSpray: yeah, mostly :)
00:12:08 <OceanSpray> lol
00:12:18 <OceanSpray> so why wouldn't it be easier?
00:12:57 <Cale> OceanSpray: because you'd be parsing the code and producing some Haskell tree structure and then what? You'd have to translate that into calls into C code.
00:12:58 <OceanSpray> isn't pointer manipulation a lot simpler to handle than monads?
00:13:04 <OceanSpray> oh yeah, that.
00:13:16 <Cale> Not really -- pointer manipulation is isomorphic to manipulation of IORefs.
00:13:37 <OceanSpray> hm
00:13:59 <OceanSpray> Is it really normal to have three to four monads wrapping a function return?
00:14:22 <Cale> Well, usually when that happens it's kind of a sign that something's strange :)
00:14:36 <Cale> You probably just want one monad that has the right features.
00:14:41 <OceanSpray> oh something's strange alright
00:14:42 <OceanSpray> tell me
00:15:21 <OceanSpray> I need IO, exception handling, an either/or type because the function could return nothing, and throw in continuations while you're at it
00:16:13 <Cale> Basically, how you should think of this is that you're writing a (pure) compiler from the abstract syntax trees of your language to IO actions.
00:16:37 <Cale> You don't *necessarily* need special monad support for those things.
00:16:44 <OceanSpray> oh?
00:17:56 <OceanSpray> I need to chew this over.
00:17:59 <Cale> It just depends on how direct you want the translation into the monad you're using to be.
00:18:18 <Cale> If you make the translation less direct, you don't need so fancy a monad.
00:18:31 <Cale> Think about how you would implement it in C -- it doesn't have first class continuations.
00:19:06 <OceanSpray> well, I actually have no idea.
00:19:17 <OceanSpray> function pointers?
00:19:55 <OceanSpray> it seems that only two things need a continuation passed to them: eval and apply
00:21:24 <OceanSpray> argh, I'm running into brock walls
00:21:53 <Cale> It just comes down to figuring out exactly how you're going to manage the features you want -- you might even want to maintain your own stack.
00:22:45 <Cale> If you can figure out how to do it in C, you can *certainly* figure out how it could be done in Haskell.
00:22:58 <Cale> There might be a better way still, but you'd at least have one option :)
00:23:01 <dons> Cale: that's a lovely point.
00:23:17 <dons> if you've figured out a C impl, you've got an over-specified haskell soln in the can.
00:23:24 <dons> (of anything..)
00:23:53 <OceanSpray> cometo think of it, I have even less of an idea of how to do it in C
00:24:23 <OceanSpray> tell me, how do other interpreters do CPS style?
00:24:38 <dons> things you don't see every day: http://www.vim.org/scripts/script.php?script_id=1986
00:24:39 <lambdabot> Title: mosalisp.vim - lisp interpreter : vim online
00:24:51 <OceanSpray> do they parse into an AST, and then use some sort of algorithm to translate it into CPS?
00:25:56 <dons> vim script is so under appreciated as a language
00:26:02 <Cale> Yes, the first step in any compiler is just building a tree which represents your syntax abstractly.
00:26:17 <OceanSpray> I had tried to avoid that.
00:27:20 <Cale> It helps a lot because carrying out actions while you're parsing can be a real mess.
00:28:06 <OceanSpray> I did realize that when I tried to create IORef objects through parsec
00:28:14 <OceanSpray> but still,
00:28:35 <Cale> yeah -- there might be a monad transformer version of Parsec now, but I'd still warn against that :)
00:28:53 <OceanSpray> ASTs somehow seem overkill in my situation
00:28:57 <pjd> dons: i've been reading through it;  it seems amazingly complete
00:29:43 <Cale> Once you have an AST, it makes it easy to translate your code into other forms, like doing CPS translation.
00:29:51 <pjd> the most obvious gap so far is only supporting unhygienic macros, instead of define-syntax
00:30:06 <pjd> s/define-syntax/syntax-rules/
00:30:09 <Cale> I don't know the details of CPS translation offhand, but I suspect that's *really* hard to do on the fly :)
00:30:24 <OceanSpray> okay then.
00:30:38 <OceanSpray> I shall do the 'right thing'
00:30:45 <OceanSpray> that is, AST generation.
00:31:00 <OceanSpray> using Haskell lists should suffice, yes?
00:31:20 <Cale> No, because they're not trees like they are in LISP.
00:31:32 <OceanSpray> aww
00:31:36 <Cale> You want a proper AST datatype, or at least a Tree
00:31:52 <OceanSpray> I sure hope there's a library for this.
00:32:09 <pjd> what's going to be in the AST?
00:32:32 <OceanSpray> what do you mean, 'in it'?
00:32:36 <Cale> I mean, if you're parsing a lispish language, the AST is really not going to be a very complicated type. :)
00:32:48 <dons> pjd: yeah, great find.
00:32:51 <notsmack> uniplate might help, i'd think
00:32:55 <OceanSpray> the AST would look EXACTLY like the code
00:33:10 <Cale> Only not a string :)
00:33:13 <OceanSpray> yes
00:33:33 <pjd> a Data.Tree of your atom type?
00:33:40 <Cale> If you want, you can just use something like a tree of atoms.
00:33:41 <Cale> yeah
00:33:47 <OceanSpray> tree of atoms...
00:34:16 <Cale> Where an atom is some small set of types of things -- numbers, strings, symbols
00:35:20 <glguy> the spam on hpaste has been intense tonight
00:35:55 <dons> glguy: have you been silently removing it?
00:36:06 <dons> is there a pattern?
00:36:23 <glguy> it typically has the word "replica" in the title
00:36:29 <glguy> I've been removing them
00:36:34 <glguy> must have kill 8 or more tonight
00:36:47 <dons> mmm.
00:37:05 <glguy> we'll have to reject any paste with "a href" in it
00:37:14 <Cale> that sounds good :)
00:37:29 <Cale> Make it go through a list of strings.
00:37:36 <Cale> which you can edit on the fly
00:38:01 <mugwump> I'm trying to install X11-extras-0.3
00:38:09 <mugwump> but it says: ghc-pkg: dependency X11-1.2.2 doesn't exist (use --force to override)
00:38:13 <Cale> It's not quite a Bayesian filter, but it'd probably help :)
00:38:24 <mugwump> but I have just installed X11-1.2.2
00:38:52 <dons> hmm. you sure you installed it?
00:38:57 <dons> what does ghc-pkg list say?
00:38:58 <OceanSpray> 'Multi-way trees (aka rose trees) and forests.'
00:39:20 <OceanSpray> what are rose trees?
00:39:44 <glguy> data Tree a = Node a [Tree a]
00:39:57 <mugwump> http://hpaste.org/2865
00:40:11 <glguy> hpaste: url
00:40:12 <hpaste> Haskell paste bin: http://hpaste.org/
00:40:18 <glguy> mugwump: is hpaste not announcing?
00:40:37 <mugwump> I clicked the announce link, yes
00:40:38 <Cale> OceanSpray: trees where the nodes have arbitrary lists of children
00:40:53 <mugwump> er, checked the announce box :)
00:40:54 <glguy> mugwump: announce is the default, did you turn it off? or leave it on and hpaste forgot
00:41:09 <mugwump> I had to check that box
00:41:18 <mugwump> because it was labelled "announce:"
00:41:20 <OceanSpray> oh.
00:42:11 <OceanSpray> I can see my goal clearly now:
00:42:43 <OceanSpray> 1) modify my parsers to generate Data.Trees
00:43:01 <OceanSpray> 2) make a function that translates the trees into CPS
00:43:26 <OceanSpray> 3) write a evaluator that takes the resulting tree and executes it
00:44:08 <OceanSpray> easier said than done, I think.
00:44:52 <Cale> yeah, those are pretty meaty steps, but that's the general idea :)
00:45:07 <OceanSpray> well, there are several problems
00:45:41 <mugwump> oh, got it.  was missing --user to configure
00:45:52 <OceanSpray> my language is pass-by expression, which means that the arguments to something might not be evaluated at all
00:46:26 <Cale> OceanSpray: You're writing a lazy language with unrestrained mutability?
00:46:45 <OceanSpray> unlike in other lisps, where only macros have that ability,
00:46:58 <OceanSpray> in which case they can be expanded in the AST phase.
00:47:00 <Cale> Yeah, that's like how Haskell works.
00:47:19 <Cale> You might be interested in reading about the STG machine
00:47:26 <OceanSpray> this means that it's not that straight-forward to translate into CPS
00:47:32 <OceanSpray> what's a STG machine?
00:47:49 <Cale> It's a machine which was devised to implement Haskell on stock hardware.
00:47:59 <Cale> (abstract machine, but it's implemented in GHC)
00:48:03 <OceanSpray> I don't get it.
00:48:33 <mugwump> is the intention that an ASIC compiler would turn that into a real IC?
00:49:10 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html (see upper right corner for downloading the paper)
00:49:12 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
00:50:09 <dons> that's a must read for everyone in here, btw.
00:50:43 <OceanSpray> oh boy, that's a hefty paper
00:51:28 <Cale> OceanSpray: yeah, it's pretty detailed, but the intro should give some idea of the approaches to implementing lazy languages
00:51:36 <OceanSpray> it's not lazy
00:51:42 <OceanSpray> just pass-by-expression
00:51:56 <Cale> Well, laziness is just a refinement of that
00:52:06 <OceanSpray> with explicit caller environment access
00:52:07 <Cale> Laziness is just outermost first evaluation with sharing.
00:52:44 <OceanSpray> isn't laziness "I'll calculate it when I need it", and handled by the implementation itself?
00:53:07 <mugwump> hey quick help question
00:53:22 <OceanSpray> what I have here is "it'll get evaluated when the programmer says so."
00:53:24 <Cale> OceanSpray: How do you think it determines when it'll need something? :)
00:53:26 <wli> The STG machine is a bit more sophistication toward the end of accomplishing precisel that.
00:53:30 <mugwump> with xmonad ... how do you resize frames in xmonad :)
00:55:05 <dolio> Edit the layout algorithm and recompile?
00:56:00 <allbery_b> M-j and M-k?
00:56:09 <allbery_b> (fsvo M- )
00:56:33 <allbery_b> also, see #xmonad
00:56:51 <dons> mugwump: resize frames : mod-h / mod-l
00:57:15 <dons> ?users #xmonad
00:57:16 <lambdabot> Maximum users seen in #xmonad: 74, currently: 61 (82.4%), active: 5 (8.2%)
00:57:23 <dons> ?users #darcs
00:57:23 <lambdabot> Maximum users seen in #darcs: 46, currently: 34 (73.9%), active: 1 (2.9%)
00:57:29 <dons> hmm.
00:57:58 <mugwump> thanks, I'll switch.  That paper was sure heavy :)
00:58:43 <allbery_b> whoops, I see I misremembered the keystrokes
00:58:58 <allbery_b> (why am I still up at 4am when I can't think straight?  damfino)
01:02:10 <pete1> when I run my app with +RTS -hc (heap breakdown by the cost-centre stack) then I get a nice *.hp file with the stacks traces shortened to about 30 chars and numbered; my problem is that I cannot find information about the full stack traces assigned to the numbers; I expected the info to be in *.prof file (as it is with -hr) but that one is empty; any idea where to see the full stack traces assigned to the numbers? (app was compiled with
01:02:40 <wolverian> cut at "compiled with"
01:03:20 <pete1> (app was compiled with ghc -make -prof -auto-all <files>)
01:05:23 <dolio> Isn't there another flag for .prof output?
01:05:28 <dolio> -p or something?
01:05:55 <pete1> -p is for time profiling; I did not try to mix it with -hc
01:06:02 <dolio> Ah.
01:06:25 <pete1> it is interesting that -hr seems to work fine
01:06:56 <pete1> and since I'm new to this I'm not even sure if -hc is supposed to provide fill stack traces as -hr does
01:07:37 <pete1> .... but without  the full stack trace the info is not much interesting ... or I do not undertand it :-(
01:08:44 <pete1> if anybody know some good description of -hc flag ussage (the better one than the one in ghc user guide 5.4.1) then I would be gratefull for the link
01:37:39 <OceanSpray> SLEEEP
01:47:54 <Taejo> Is Haskell going to win ICFP this year?
01:52:05 <KatieHuber> ICFP already happened this year?
01:54:46 <Taejo> KatieHuber, the competition did
01:54:53 <Taejo> the conference is next week
01:55:15 <KatieHuber> so what does it mean to "win" a conference?  or is that when the competition results are announced?
01:56:41 <opqdonut> he was talking about the competition
01:57:30 <opqdonut> http://en.wikipedia.org/wiki/ICFP_Programming_Contest
01:57:31 <lambdabot> Title: ICFP Programming Contest - Wikipedia, the free encyclopedia
01:57:52 <KatieHuber> I know the contest, even entered it a few times :)
02:01:14 <Taejo> KatieHuber, the results are announced at the conference
02:03:19 <Heffalump> morning
02:03:26 <kaol> the contest site has a score board, but the top 15 is shown in a randomized order. But from having a team named "PurelyFunctionalInfrastructure", I can guess that Haskell is among the candidates.
02:05:46 <kaol> ooh. I just used liftM frob foo instead of case foo of Nothing -> Nothing; Just x -> Just $ frob x. Happiness.
02:06:50 <KatieHuber> I just used "force" and a whole lot of instances of NFData to make my program substantially faster... I feel dirty :'(
02:08:08 <kaol> how'd I ever manage to do anything without monads?
02:08:33 <lokik> hey how would I go about declaring a new integer class,  that uses hexadecimal logjbang?
02:09:10 <lokik> well so i want to re-assign 0xF to "vai"
02:09:31 <lokik> for instance ^
02:11:49 <Taejo> lokik, what is logjbang?
02:12:30 <lokik> mild modification of lojban  i have the tokenizer available at http://tcana.info/VALsi.hs
02:12:53 <lokik> a description: http://lokamaf.blogspot.com/2007/09/logjbang-tokenizer.html
02:12:54 <lambdabot> Title: la.ma'aselyTCAna. pela.lokimaf.: LOGJbang Tokenizer
02:13:17 <lokik> less than 220 lines of code
02:13:28 <lokik> for the tokenizer
02:14:12 <lokik> now i want to make the math engine or what not,  so gotta start with assigning numerical values to words
02:14:35 <lokik> guess i could do with the Bits class.. or some such *wonders*
02:15:01 <Taejo> so you want [Token] -> Integer ?
02:15:52 <lokik> well there might be some form of function that does that
02:16:09 <lokik> it's a word really so a [String]
02:16:44 <lokik> numbers 1-F : pa re ci vo mu xa ze bi so dau fei gai jau rei vai
02:17:01 <lokik> 0 : no
02:17:02 <Taejo> and 0? "no"?
02:17:07 <lokik> yep
02:18:10 <lokik> would be cool if they just always turned into their appropriate bit strings
02:19:09 <lokik> hmmm
02:21:25 <lokik> might have to rewrite the Data.Bits class for myself, or even learn C
02:23:29 <lokik> oh well
02:23:56 * lokik goes to brush up on some C
02:27:35 <arcatan> brushed C
02:34:11 <Heffalump> kaol: fmap!
02:38:08 <kaol> Heffalump: ooh, I'll save one character with that
02:48:32 <Heffalump> kaol: and you'll save annoying all the people who think liftM should be called fmap :-)
02:50:31 <Heffalump> more to the point, it's less confusing if you're not actually working in the Maybe monad generally
02:52:13 <pjd> liftM and fmap should be called <$> !
02:54:15 <kaol> > fmap (fmap (+1)) [Nothing, Just 1, Nothing, Just 52]
02:54:17 <lambdabot>  [Nothing,Just 2,Nothing,Just 53]
02:55:09 <LeCamarade> ?users
02:55:09 <lambdabot> Maximum users seen in #haskell: 407, currently: 339 (83.3%), active: 9 (2.7%)
02:55:57 <Heffalump> pjd: is that the applicative thing?
02:56:10 <pjd> Heffalump: yeah
02:56:42 <pjd> (,) <$> "abc" <*> [1,2,3]
02:56:46 <pjd> > (,) <$> "abc" <*> [1,2,3]
02:56:48 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
02:58:33 <nornagon> :t <$>
02:58:35 <lambdabot> parse error on input `<$>'
02:58:40 <nornagon> :t (<$>)
02:58:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:58:53 <nornagon> :t (<*>)
02:58:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:01:04 <Paczesiowa> is there some easy&haskell&crossplatform way to check whether file (or it's string representation) is actually jpg image?
03:01:29 <pjd> Paczesiowa: file(1) ?
03:02:04 <pjd> on Unixy systems, anyway
03:02:26 <mr_tenor> check the header?
03:02:56 <mr_tenor> otherwise you'd have to parethe whole thing and see if it conforms tothe standardi guess :/
03:03:03 <mr_tenor> *parse*
03:03:04 <Paczesiowa> isn't there haskell jpg parser
03:03:06 <Paczesiowa> ?
03:04:08 <nornagon> look for JFIF in the first 10 bytes maybe?
03:04:24 <nornagon> not sure what the bytes before then are, but i'm assuming they're not variable-length
03:05:08 <LeCamarade> Paczesiowa: Maybe look for 0xffd8 in the first word?
03:06:02 <Paczesiowa> nornagon: that should work, tx
03:07:08 <Paczesiowa> I'm trying do download jpg images, but sometimes there is nice pimpedout 404 page
03:22:24 <nornagon> Paczesiowa: you could, uh, check the HTTP response code
03:23:33 <Paczesiowa> there are sites which return 200OK and nice colorful html file with info about wrong filename and some pr0n ads
03:24:11 <KatieHuber> http://hpaste.org/2867
03:24:34 <KatieHuber> obviously I could concoct something with zipWith and all, maybe it'd be tidier than what I have...
03:25:21 <Heffalump> seafood!
03:25:34 <seafoodX> Heffalump: Hello.
03:25:41 <Heffalump> kaol: zipWith xs (tail xs) is a fairly common idiom
03:25:48 <Heffalump> s/kaol/KatieHuber/ # sorry
03:25:54 <seafoodX> How are you? I hear you are working for Credit Suiss now.
03:25:55 <Heffalump> (obviously with a function too)
03:26:05 <Heffalump> indeed. Good, though pretty busy :-)
03:26:20 <dolio> and $ zipWith ((/=) `on` color) xs (tail xs), looks like.
03:26:49 <dolio> Although, that blows up for 0 element lists.
03:26:59 <Heffalump> oh, point
03:27:17 <Heffalump> actually, does it? if zipWith pattern matches on the first list first, it wouldn't.
03:27:33 <dolio> Oh, yeah, I suppose.
03:27:35 <KatieHuber> Hugs> (\l -> zipWith (,) l (tail l)) []
03:27:36 <KatieHuber> []
03:27:43 <dolio> > zip [] (tail [])
03:27:45 <lambdabot>  []
03:27:51 <dolio> Well, then.
03:28:31 <KatieHuber> what is `on` ?  not in Prelude...
03:28:44 <nornagon> @index on
03:28:45 <lambdabot> bzzt
03:28:50 <dolio> on g f x y = f x `g` f y
03:29:05 <dolio> It's in Data.Function in 6.8.
03:29:06 <Heffalump> @pl \ g f x y ->  f x `g` f y
03:29:06 <lambdabot> join . ((flip . ((.) .)) .) . (.)
03:29:10 <KatieHuber> oh, I asked about that the other day and got a much less useful answer than that :)
03:29:14 <Heffalump> @pl \ f g x y ->  f x `g` f y
03:29:14 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
03:29:17 <nornagon> Heffalump: ...
03:29:18 <nornagon> ;)
03:29:20 <KatieHuber> is it not in 6.6 ?
03:29:34 <Heffalump> it can't be quite the same, otherwise it'd give the same answer it gave me when I asked it about your function
03:29:35 <KatieHuber> it turned out to be liftM2 or something in 6.6 I think
03:29:42 <dolio> I don't think 6.6 has Data.Function.
03:29:48 <Heffalump> but it sure as hell looks the same. Most confusing :-)
03:29:59 <Heffalump> @pl \ g f x y ->  g (f x) (f y)
03:29:59 <lambdabot> join . ((flip . ((.) .)) .) . (.)
03:32:39 <dolio> liftM2 is slightly different.
03:33:02 <dolio> In the (->) e monad, liftM2 is: \h f g x -> f x `h` g x
03:33:16 <KatieHuber> yeah I just noticed it's not quite the same
03:33:51 <dolio> So, liftM2 works when you want to collect the results of two functions on one value with a third function.
03:34:06 <dolio> And on works when you want to collect the results of one function on two values with a second function.
03:48:25 <EvilTerran> @where chs2hs
03:48:26 <lambdabot> I know nothing about chs2hs.
03:49:04 <EvilTerran> @where hsc2hs
03:49:04 <lambdabot> I know nothing about hsc2hs.
03:49:06 <EvilTerran> ...
03:52:45 <Heffalump> what are you looking for? It's in GHC, isn't it?
03:52:53 <Heffalump> and it seems to have a darcs repo on darcs.haskell.org
03:54:07 <EvilTerran> yeah, i've found it now
04:00:25 <pjd> dolio: a slightly different way to think about (e ->) liftM2 is that it generalizes the parameters of h x y from plain values to functions of the environment
04:05:18 <EvilTerran> @where ffi
04:05:19 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
04:11:18 <EvilTerran> specifically, i'm looking for information about dealing with struct{}s under the FFI
04:17:16 <scook0> EvilTerran: I don't think "vanilla" FFI can deal with structs
04:17:27 <scook0> but there are a whole bunch of extra tools for dealing with them
04:18:17 <EvilTerran> what's why i was looking at hsc2hs
04:20:15 <EvilTerran> i guess "data Foo = Foo { bar :: CInt, baz :: CInt }; foreign import ... :: ... -> IO Foo" for struct { int bar; int baz; } ...(...); would have complications with field alignment and whatnot
04:21:08 <Heffalump> and boxing..
04:21:23 <scook0> yeah ... I remember there was another tool I had in mind, but I can't recall the name of it ...
04:21:29 * pjd wonders if you could make something like Pyrex for Haskell
04:21:30 <Heffalump> greencard?
04:21:37 <Heffalump> c2hs?
04:21:47 <EvilTerran> there's c2hs as well, but that doesn't build on doze-sans-cygwin afaict
04:23:01 <EvilTerran> also, i'm not sure how well it'd cope with these header files in particular; the library's "style" involves having AL_FUNC(returntype, name, (param,param...)), AL_CONST, etc
04:23:28 <KatieHuber> you binding OpenAL?
04:23:37 <KatieHuber> no, that doesn't have structs :|
04:23:41 <EvilTerran> Allegro, actually <http://alleg.sf.net>
04:23:46 <KatieHuber> ah
04:23:48 <KatieHuber> why :p
04:24:32 <EvilTerran> because i'm familiar with it in C, there's no pre-existing haskell binding for it, and i want to use it in haskell
04:24:51 <KatieHuber> SDL and OpenGL bindings already exist though right?
04:24:59 <EvilTerran> or rather, that last point would be "i want graphics in haskell"
04:25:02 <EvilTerran> see the first point
04:25:37 <EvilTerran> OpenGL's all fine and dandy, but it's difficult to use without, say, GLUT
04:25:47 <KatieHuber> or, say, SDL :p
04:25:53 <EvilTerran> GLUT and its derivatives are all dead projects
04:26:32 <dolio> pjd: Well, that would be the obvious interpretation given that liftM2 lifts a pure function to a monadic function, and (e ->) is the environment monad, no? :)
04:26:40 <EvilTerran> i did find a GLUT dll, but i want some of the freeGLUT functionality, and the readme in the freeGLUT source they they've specifically decided against providing a binary DLL for godknowswhat reason
04:26:49 <scook0> what about GLFW?
04:26:56 <dolio> pjd: My description was merely a statement about what it happens to be useful for when you're point-free golfing. :)
04:27:04 <pjd> dolio: yes, just saying :)
04:27:12 <KatieHuber> GLFW's just as much a pile of... as GLUT
04:27:19 <KatieHuber> SDL is "it", as far as such things go
04:27:47 <KatieHuber> ( and I wrote the GLFW Mac port so I think I can comment ;) )
04:28:15 <EvilTerran> the SDL bindings don't come in the windows GHC bundle, and, in my experience, trying to get a package working on windows-sans-cygwin is pretty futile
04:28:17 <KatieHuber> might be easier to bind than Allegro though, if you just want a GL window out of it
04:28:26 <scook0> ah
04:28:37 <KatieHuber> ah, somebody was in here yesterday complaining about making SDL work on Windows
04:28:46 <EvilTerran> anyway, as i mentioned before, i'm familiar with allegro in C. I'd rather use something i know.
04:29:19 <KatieHuber> even if it takes a few weeks to get bindings working clearly ;)
04:30:21 <EvilTerran> it's also an opportunity to learn how to make bindings, i guess
04:31:08 <EvilTerran> and maybe get enough insight into the process to be able to get the SDL bindings or whatever working on windows
04:32:06 <EvilTerran> i guess it might be better to start with something smaller, but i can't think of anything small that i particularly want haskell bindings for
04:32:14 <EvilTerran> maybe the xchat plugin interface...
04:33:05 * EvilTerran goes to have lunch
04:41:04 <Taejo> Can somebody explain the joke: main = mfix (\x -> putStrLn x >> getLine)
04:42:16 <scook0> joke?
04:42:52 <igel> :t mfix
04:42:55 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
04:43:43 <nornagon> :t mfix (\x -> putStrLn x >> getLine)
04:43:45 <lambdabot> IO String
04:44:28 <Paczesiowa> <<loop>>
04:44:44 <nornagon> yeah
04:44:50 <nornagon> it has nowhere to start
04:45:03 <igel> is mfix the backend of "mdo" expressions?
04:45:27 <Taejo> The source says it outputs a string before you type it... which is obviously a joke, but I don't get it.
04:46:06 <Paczesiowa> if it's not a joke than it's kinda scary...
04:49:40 <Heffalump> igel: yes
04:59:33 <pjd> > fix (1:)
04:59:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:00:22 <pjd> i.e.
05:00:22 <pjd> > fix $ \x -> (1:x)
05:00:23 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:01:08 <pjd> fix ties the inner x of the expression with the expression itself
05:03:14 <pjd> mfix does the monadic analog:  it "feeds" the result of the expression (getLine) into the expression (as x)
05:03:30 <Paczesiowa> sounds like voodo
05:04:14 <pjd> i'm hazy on the theory, but the problem (and joke) is that the above mfix isn't productive, or something
05:04:48 <byorgey> if it was productive, it would read from the future!
05:04:57 <pjd> so it's like:
05:04:58 <pjd> > fix $ (1+)
05:04:59 <lambdabot>  Exception: <<loop>>
05:05:41 <pjd> which tries to calculate an infinite sum, which you can't partially read, like you can with fix (1:)
05:08:33 <EvilTerran> surely that one just echoes whatever you type in?
05:08:53 <EvilTerran> ...never producing a value, though, so i guess it isn't "productive" in the FP sense
05:09:12 <ari> Needs moar lazy naturals!
05:16:51 <droundy> Does anyone have a suggestion how I could avoid undecideable instances with a class like:
05:17:07 <droundy> instance LayoutModifier m l a => Layout (m l) a where ...
05:49:14 <Ben`> how can I turn a digit into an Integer? (something like digitToInt, but Integer instead of Int)
05:49:38 <Paczesiowa> :t digitToInt
05:49:40 <lambdabot> Char -> Int
05:49:47 <koeien> :t toInteger
05:49:49 <lambdabot> forall a. (Integral a) => a -> Integer
05:49:59 <wli> fromIntegral . digitToInt
05:49:59 <koeien> :t toInteger.digitToInt
05:50:01 <lambdabot> Char -> Integer
05:50:19 <wli> That'll do it, too.
05:50:35 <Ben`> ah, I see
05:50:39 <Ben`> thanks :)
06:09:18 <Taejo> why can't ghci understand "import X" as a synonym for ":m +X"?
06:15:54 <kyevan> > "I, Lambdabot, am an idiot."
06:15:56 <lambdabot>  "I, Lambdabot, am an idiot."
06:16:07 <kyevan> She said it herself! It must be true!
06:16:56 <kyevan> Anyway, what happens if you compile a program that just returns a string? Does the compiler write code to write it to the console?
06:17:18 <twanvl> The type of the main function is always IO ()
06:22:55 <kyevan> ... You can't write negative literals?
06:23:13 <mauke> right
06:23:23 <int-e> -10 means negate (fromInteger 10), yes.
06:23:25 <kyevan> ... WHY!?
06:23:28 <mauke> well, you can't really write numeric literals anyway :-)
06:23:44 <kyevan> > 10
06:23:45 <lambdabot>  10
06:23:52 <kyevan> sure you can?
06:23:57 <mauke> that's not a literal value
06:24:01 <mauke> that's (fromInteger 10)
06:24:19 <kyevan> Close enough >_>
06:24:22 <kyevan> > -10
06:24:23 <lambdabot>  -10
06:24:34 <kyevan> ... sure, NOW it works
06:24:37 <int-e> The current handling unary minus isn't universally loved in the Haskell community. :P
06:24:49 <scook0> kyevan: were you trying to use them in a complicated expression?
06:24:49 <int-e> > (+) (-10) (-10)
06:24:51 <lambdabot>  -20
06:25:04 <scook0> (unary minus can cause precedence headaches)
06:25:07 <int-e> but -10 is not a literal, it's an unary minus followed by 10.
06:25:18 <kyevan> int-e: Oh, hush
06:25:19 <mauke> most languages don't have negative literals
06:25:29 <kyevan> In haskell, it's the same thing :P
06:25:43 <mauke> no, it isn't
06:25:53 <mauke> it's the same thing in C or similar
06:26:40 <kyevan> It looks like a literal
06:26:46 <kyevan> It acts like a literal
06:26:56 <kyevan> ... Do I need to finish this? :P
06:27:01 <int-e> > - - 10
06:27:01 <lambdabot>  Parse error
06:27:07 <mauke> > 1 + -1
06:27:09 <lambdabot>      precedence parsing error
06:27:09 <lambdabot>         cannot mix `(+)' [infixl 6] and prefix ...
06:27:17 <nornagon> > -1 + 1
06:27:18 <lambdabot>  0
06:27:26 <infrared> > sum $ map (toInteger . length . show) [1..999999]
06:27:28 <lambdabot>  5888889
06:27:36 <scook0> > (+1) (-1)
06:27:38 <lambdabot>  0
06:27:40 <infrared> it gives "*** Exception: stack overflow" here, hmm
06:27:57 <mauke> infrared: lambdabot compiles with optimizations enabled :-)
06:27:58 <kyevan> LB's got a bigger stack?
06:28:08 <int-e> infrared: use -O, or better, use  foldl' (+) 0  instead of  sum
06:28:23 <Paczesiowa> @src sum
06:28:24 <lambdabot> sum = foldl (+) 0
06:28:38 <nornagon> :t foldl'
06:28:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:28:41 <nornagon> @src foldl'
06:28:42 <lambdabot> foldl' f a []     = a
06:28:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:28:43 <kyevan> > -0
06:28:45 <lambdabot>  0
06:29:07 <infrared> strictness here is what is want, thanks!
06:29:27 <int-e> > sum [n*9*10^(n-1) | n <- [1..6]]
06:29:28 <lambdabot>  5888889
06:29:46 <scook0> > map (1/) [0, -0]
06:29:48 <lambdabot>  [Infinity,-Infinity]
06:30:16 <mauke> @pl \x -> 1/x
06:30:17 <lambdabot> (1 /)
06:30:19 <kyevan> > 1/0
06:30:20 <lambdabot>  Infinity
06:30:28 <kyevan> ... Erm, no?
06:30:37 <scook0> kyevan: tell IEEE
06:30:37 <mauke> lambdabot: no, I meant recip
06:30:50 <kyevan> I mean, I see how that comes, and have even argued that it's the case, but
06:31:01 <Paczesiowa> @pl \x -> 0-x
06:31:02 <lambdabot> (-) 0
06:31:11 <Paczesiowa> @pl \x -> 0+x
06:31:11 <lambdabot> id
06:31:21 <kyevan> > let _ / 0 = NaN in 1/0
06:31:22 <lambdabot>   Not in scope: data constructor `NaN'
06:31:33 <kyevan> <_< There's no NaN constructor, either?
06:31:48 <Taejo> :t \x -> 0 + x
06:31:51 <lambdabot> forall t. (Num t) => t -> t
06:31:56 <nornagon> > 1e10000 :: Float
06:31:57 <Taejo> :t id
06:31:57 <lambdabot>  Infinity
06:31:59 <lambdabot> forall a. a -> a
06:32:06 <mauke> > 1/0 :: Rational
06:32:08 <lambdabot>  Exception: Ratio.%: zero denominator
06:32:10 <scook0> > 0/0
06:32:12 <lambdabot>  NaN
06:32:48 <scook0> > (\x -> x == x) (0/0)
06:32:50 <lambdabot>  False
06:33:54 <Paczesiowa> that's weird?
06:34:07 <mauke> > liftM2 (.) ($ (==)) ($ (/)) join 0
06:34:08 <augustss> weird, but according to the iEEE spec
06:34:09 <lambdabot>   add an instance declaration for (Fractional Bool)
06:34:10 <int-e> that's how IEEE 754 NaNs work.
06:34:23 <augustss> > isNaN (0/0)
06:34:24 <lambdabot>  True
06:34:30 <Botje> > 0/0
06:34:32 <lambdabot>  NaN
06:34:40 <int-e> @src isNaN
06:34:40 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:34:43 <Botje> > read "NaN" :: Double
06:34:45 <lambdabot>  NaN
06:34:45 <Paczesiowa> :t NaN
06:34:46 <int-e> isNaN x = x /= x
06:34:46 <lambdabot> Not in scope: data constructor `NaN'
06:34:48 <Botje> heh :)
06:34:51 <int-e> works.
06:34:55 <nornagon> :t 0/0
06:34:57 <lambdabot> forall t. (Fractional t) => t
06:35:40 <int-e> > sort [1,2,3,0/0,4,5,6]
06:35:41 <lambdabot>  [4.0,5.0,6.0,NaN,1.0,2.0,3.0]
06:35:54 <nornagon> ... O_o
06:36:04 <mauke> > compare (0/0) 2
06:36:06 <lambdabot>  GT
06:36:22 <mauke> > compare 2 (0/0)
06:36:23 <nornagon> > (0/0) > 1/0
06:36:23 <lambdabot>  GT
06:36:25 <lambdabot>  False
06:36:31 <nornagon> > 0/0 < 1/0
06:36:32 <lambdabot>  False
06:36:41 <nornagon> > 0/0 == 1/0
06:36:42 <lambdabot>  False
06:36:43 <mauke> > 0/0 /= 1/0
06:36:45 <lambdabot>  True
06:38:11 <int-e> > toRational (0/0)
06:38:12 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
06:38:18 <nornagon> haha
06:38:20 <ari> o_O
06:38:23 <mauke> wtf
06:38:28 <augustss> bug
06:38:33 <int-e> > toRational (0/0) > toRational (1/0)
06:38:34 <lambdabot>  False
06:38:40 <mauke> > toRational (1/0)
06:38:42 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
06:38:52 <int-e> > toRational (0/0) < toRational (-1/0)
06:38:54 <lambdabot>  True
06:38:57 <mauke> > length . show $ toRational (1/0)
06:38:58 <lambdabot>  311
06:39:05 <mauke> ok then!
06:39:12 <augustss> ooops :)
06:39:27 <Paczesiowa> hae you guys seen movie "Pi" ?
06:40:11 <kyevan> @Infrared's quit message: Ewemacs? >_>
06:40:12 <lambdabot> Unknown command, try @list
06:40:17 <augustss> I see that the code for toRational is messing a few tests
06:40:23 <kyevan> lambdabot: that wasn't for you, >_>
06:40:42 <mauke> @vixen don't you love me anymore?
06:40:43 <lambdabot> is that really what you want to know?
06:41:08 <kyevan> Careful! Last time people were playing with vixen, she said some... weird things.
06:41:24 <DRMacIver> @vixen weird things
06:41:24 <lambdabot> why do you say weird?
06:51:16 <pharm> q
06:51:25 * pharm oops
08:28:05 <ekidd> @djinn (a,b) -> (c,d) -> (a,d)
08:28:06 <lambdabot> f (a, _) (_, b) = (a, b)
08:29:25 <ekidd> @djinn Rational -> Float
08:29:25 <lambdabot> -- f cannot be realized.
08:31:11 <ekidd> @djinn Int -> Float
08:31:11 <lambdabot> -- f cannot be realized.
08:31:20 <ekidd> Hmm. It doesn't seem to know much about type classes.
08:31:31 <mauke> it doesn't know anything about type classes
08:31:35 <allbery_b> djinn is straight lambda calculus
08:31:39 <mauke> it doesn't even understand lists
08:31:41 <allbery_b> untyped, I think
08:32:16 <allbery_b> no, suppose that's wrong.  no (haskell) types, certainly
08:34:06 <__nasa__> It does tuples.
08:34:38 <allbery_b> no concete haskell types, I should have said.  (or typeclasses)
08:34:49 <allbery_b> you won't find an Int in there for instance
08:35:00 <__nasa__> hmm...
08:35:08 <allbery_b> anonymous types and non-recursive collections
08:35:08 <__nasa__> @djinn M a -> a
08:35:09 <lambdabot> -- f cannot be realized.
08:35:21 <allbery_b> (so yes tuples, no lists)
08:35:52 <Saizan> ?djinn-env
08:35:52 <lambdabot> data () = ()
08:35:52 <lambdabot> data Either a b = Left a | Right b
08:35:52 <lambdabot> data Maybe a = Nothing | Just a
08:35:52 <lambdabot> data Bool = False | True
08:35:52 <lambdabot> data Void
08:35:54 <lambdabot> type Not x = x -> Void
08:35:55 * allbery_b doesn't really sling the lingo wrt types
08:35:56 <lambdabot> class Eq a where (==) :: a -> a -> Bool
08:36:36 <__nasa__> @djinn Monad m => a -> m a
08:36:37 <lambdabot> Cannot parse command
08:37:37 <__nasa__> @djinn Maybe a -> a
08:37:37 <lambdabot> -- f cannot be realized.
08:37:39 <ToRA|home> @djinn Maybe (a -> d) -> a -> Maybe d
08:37:39 <lambdabot> f a b =
08:37:39 <lambdabot>     case a of
08:37:39 <lambdabot>     Nothing -> Nothing
08:37:39 <lambdabot>     Just c -> Just (c b)
08:37:42 <ToRA|home> heh, cute
08:39:04 <jbauman> @. pl djinn Maybe (a -> d) -> a -> Maybe
08:39:04 <lambdabot> (line 1, column 1):
08:39:04 <lambdabot> unexpected end of input
08:39:04 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
08:40:08 <mauke> @type \f x -> fmap ($ x) f
08:40:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
08:41:26 <mauke> @type flip (.) (flip id) . flip fmap
08:41:28 <lambdabot> forall b b1 (f :: * -> *). (Functor f) => f (b -> b1) -> b -> f b1
08:43:52 <jbauman> @pl :t \a b -> a >>= \x -> return (x b)
08:43:52 <lambdabot> (line 1, column 1):
08:43:53 <lambdabot> unexpected ":"
08:43:53 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
08:43:59 <jbauman> @pl \a b -> a >>= \x -> return (x b)
08:43:59 <lambdabot> flip (fmap . flip id)
08:46:05 <jbauman> @src liftM
08:46:05 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:46:11 <jbauman> @src fmap
08:46:12 <lambdabot> Source not found. I feel much better now.
09:02:25 <tehgeekmeister> anyone got any idea what to do about this error: http://hpaste.org/2869#a1
09:03:16 <tehgeekmeister> i don't see anything immediately suspicious around the code it references, but, then again, i don't really understand that section of code, so i might be missing something.
09:03:31 <ndm> tehgeekmeister: report it to the happs people
09:03:36 <ndm> @seen shapr
09:03:36 <lambdabot> Last time I saw shapr was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #scala, #scannedinavian, #unicycling
09:03:37 <lambdabot> and #xmonad 4d 21h 56m 17s ago, and .
09:03:39 <ndm> @seen alexj
09:03:39 <lambdabot> Last time I saw alexj was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #scala, #scannedinavian, #unicycling
09:03:40 <lambdabot> and #xmonad 4d 21h 56m 21s ago, and .
09:04:40 <tehgeekmeister> post it to the mailing list, then?
09:07:38 <ndm> does happs have a mailing list?
09:07:53 <tehgeekmeister> yeh, but it's not very active.
09:08:13 <Lemmih> ndm: The IRC channel is more active.
09:08:52 * tehgeekmeister asks in #happs
09:09:44 * Igloo has just pushed a(n untested) fix
09:11:34 <Lemmih> Igloo: Urk, so have I )-:
09:12:11 <guenni> anybody here coming to Freiburg?
09:12:22 <ndm> yep :)
09:12:28 <Heffalump> yes
09:12:32 <Lemmih> Igloo: I'm rolling back my patch.
09:12:51 <Igloo> Lemmih: Heh, OK
09:13:02 <guenni> cool
09:13:38 <Lemmih> guenni: http://haskell.org/haskellwiki/Hac_2007_II/Attendees
09:13:39 <lambdabot> Title: Hac 2007 II/Attendees - HaskellWiki
09:14:17 <guenni> I'd like to come too, it's pretty much just around the corner from me
09:14:39 <guenni> I'm just not sure which days to attend
09:15:20 <guenni> there's 2 nerds from Freiburg, is that right?
09:15:20 <ndm> i'm not going to the hackathon, just the conference bits
09:16:15 <araujo> internal error: task 0xafca60: main thread 1250841 has been GC'd
09:16:15 <araujo>     (GHC version 6.6.1 for x86_64_unknown_linux)
09:16:15 <araujo>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
09:16:17 <lambdabot> Title: ReportABug - GHC - Trac
09:16:18 <araujo> :-P
09:18:41 <Heffalump> Igloo: is it worth trying the 6.8 snapshots now?
09:18:45 <guenni> btw are there any courses for haskell?
09:19:04 <Heffalump> yes, all good university CS programs :-)
09:19:16 <guenni> serious?
09:19:28 <Igloo> Heffalump: Yup, they should be working now
09:19:30 <Heffalump> about what?
09:19:36 <Heffalump> Igloo: ta.
09:19:41 <ibid> there are courses, yes
09:19:45 <matthew-_> guenni: yeah, it gets taught at several unis across the world
09:20:02 <guenni> that haskell is taught at univercitys?
09:20:08 <Heffalump> errm, yes
09:20:30 <Rebooted> its taught at Oxford, Edinburgh and Imperial at least over here in England
09:20:38 <ndm> York, Nottingham
09:20:40 <guenni> so what do you do if you're not an academic/student?
09:20:53 <matthew-_> Kings College, London, too IIRC
09:20:57 <ndm> Kent
09:20:59 <matthew-_> possible RHUL
09:21:03 <guenni> I mean will they let you participate?
09:21:08 <ndm> unlikely
09:21:12 <ibid> depends
09:21:32 <guenni> I'd be willing to pay for it
09:21:39 <Heffalump> where do you live?
09:21:42 <ndm> universities do like money
09:21:49 <guenni> Mannheim, Germany
09:21:58 <guenni> not to far from Freiburg
09:22:13 <ibid> in finland, lectures are generally open to the public - but to get individual attention, you need to be enrolled (and money is sometimes the way to do that)
09:22:15 <ndm> if you find a sympathetic lecturer, you may be able to just go to the course  informally
09:22:18 <Heffalump> I doubt there's any way to get formal tuition without attending a university course. Or working for a company that provides it internally, perhaps.
09:22:35 <ndm> Heffalump: do you know of any companies that provide such tuition?
09:22:47 <guenni> I don't
09:22:54 <Heffalump> only the one where I give it :-)
09:23:02 <guenni> which would be?
09:23:03 <Heffalump> and that's somewhat stretching the definition.
09:23:22 <ndm> yeah, i can't imagine people are after full time Haskell programmers and want to train them up
09:23:34 <Heffalump> yeah
09:24:20 <guenni> So let's say one had the money, and the time, where could one get Haskell training?
09:24:30 <ndm> nowhere
09:24:33 <ndm> other than a University
09:24:35 <Igloo> For enough money, I'd teach you Haskell  :-)
09:24:53 <Rebooted> ha
09:24:59 <ndm> guenni: or a book, which may be enough to get you started
09:25:00 <guenni> where, at the north pole?
09:25:01 * Igloo suspects it would be cheaper to convince a uni to enroll you, though  :-)
09:25:08 <astrolabe> You could learn a lot from the web, this channel, and a couple of books
09:25:28 <guenni> well I'm polluted from Java ...
09:25:29 <ddarius> I think most people here have never taken a "Haskell" course.
09:25:38 <guenni> so with books it's kind of hard
09:25:39 <ddarius> I think most people here knew Java before Haskell.
09:25:47 <ndm> i have :)
09:25:49 <Igloo> I think most people, at least most of the active ones, have taken a Haskell class at uni
09:26:17 <ddarius> Igloo: A good chunk have, but I don't think most.
09:26:22 <ddarius> I could be wrong though.
09:26:40 <ddarius> At any rate, from those that haven't it is quite clear that it is not necessary.
09:26:42 <ndm> i think most have
09:26:45 <guenni> well the reason why I'd like to take a course is also to get in touch with other haskell nerds
09:26:56 <ndm> in that case Uni probably isn't what you are after
09:27:04 <ndm> the hackathon is a good place to go for that
09:27:06 <ddarius> guenni: I'd suggest conferences and such.
09:27:18 <ndm> if you want Haskell nerds, Haskell Workshop is a good choice
09:27:21 <pejo> Those who took a course at a university might ahve been exposed to Haskell as first language.
09:27:22 <augustss> I've never taken a Haskell class. :)
09:27:29 <guenni> I think I'll attend the hackaton
09:27:38 <ddarius> You want the people who -like- Haskell, not just take a class on it.
09:27:39 <guenni> is it too late to register?
09:27:39 <pejo> augustss, those who defined the language does not count!
09:27:39 <ndm> augustss: never given one?
09:27:47 <astrolabe> It should be taken or given a haskell class
09:27:54 <augustss> Oh, I've given Haskell classes.
09:28:10 <Heffalump> Igloo: make in-place is broken, right?
09:28:17 <ndm> ddarius: those who take the class tend to leave IRC quite quickly
09:28:39 <ddarius> ndm: Agreed.
09:28:48 <Igloo> Heffalump: Yes; does it still advertise it?
09:29:18 <astrolabe> A lot of learning seems to be done by helping with haskell libraries/  open source projects
09:29:25 <Heffalump> Igloo: yes, in INSTALL
09:29:41 <Heffalump> and the make target is still there, it should probably produce some kind of error
09:29:50 <ddarius> astrolabe subtly recruiting workers.
09:30:11 <astrolabe> ddarius: and hypocritically too.
09:30:22 <Igloo> Heffalump: Ah, thanks
09:32:26 <Igloo> Heffalump: Hmm, the make target is still there?
09:32:51 <guenni> the commercial users event, anybody here with some info on that?
09:34:16 <dons> guenni: its a workshop. 70-odd attendees (or more)
09:34:24 <dons> lots of cool kids
09:35:15 <guenni> thanks
09:35:32 <Heffalump> oh, sorry, I got confused by "Nothing to be done for `in-place'"
09:35:37 <Heffalump> I forget make has awful error messages.
09:36:03 <Heffalump> oh, though it differs from the message from "make foobar".
09:36:17 <Heffalump> perhaps because it's in the RHS of a .PHONY rule
09:38:46 <Heffalump> ooh, you got rid of the huge banner
09:43:42 <phobes_> What's the median age of the attendees at the Haskell Workshop?
09:44:38 <Igloo> Quite young, I imagine, as a large proportion are PhD students
09:46:16 <guenni> any cute ones?
09:46:38 <Igloo> Well, I'm extremely cute, but no longer a PhD student
09:46:40 <astrolabe> lots have long hair
09:47:16 <phobes_> ya?  What's the median gender?
09:47:28 <guenni> ehm, male?
09:47:42 * ndm thinks Igloo is cute too
09:47:46 <astrolabe> fraid so
09:48:01 <guenni> what do you mean, that suits *me* fine ...
09:50:21 <Heffalump> isn't Igloo a bit hairy to be cute?
09:50:40 <astrolabe> kittens are cute
09:50:40 <ndm> http://www.haskell.org/haskellwiki/Hac_2007/GroupPhoto
09:50:40 <guenni> uh, beard, shoulders, back?
09:50:42 <lambdabot> Title: Hac 2007/GroupPhoto - HaskellWiki
09:50:50 <ndm> a selection of Haskell Workshop attendees
09:51:02 <guenni> the one on the left?
09:51:21 <ndm> Igloo wins on the hair front in that photo
09:51:33 <Igloo> I don't think everyone in that photo has been to a HW
09:51:55 <astrolabe> which is Igloo?
09:52:01 <ndm> yes, but its probably ~75%
09:52:41 <Heffalump> far left front
09:52:47 <jbauman> astrolabe, the one with the lots of visible hair
09:52:50 <ddarius> You needed to add Wadler
09:52:52 <astrolabe> thanks.  just seen the caption
09:53:03 <ddarius> Though he's calmed it down some.
09:53:20 <fanf> hello
09:53:26 <Lemmih> hi
09:53:26 <guenni> that's one female? amoung ~ 15 guys?
09:53:36 <ddarius> guenni: Actually... ...
09:54:05 <guenni> ddarius
09:54:08 <guenni> ddarius
09:54:13 <guenni> yes?
09:54:38 <ddarius> guenni: Google Kirsten Chevalier
09:55:33 <jbauman> guenni, not so much anymore, apparently
09:55:40 <EvilTerran> ooh, that's in front of the Wolfson building, isn't it?
09:55:51 * EvilTerran has lectures in there...
09:56:04 <Igloo> yup
09:56:06 <ddarius> EvilTerran: That seems an odd place to leave them.
09:56:40 <EvilTerran> someone else left them, i just had to go pick them up...
09:57:02 <guenni> ddarius: that's not you, is it?
09:58:33 <ddarius> guenni: /whois ddarius
09:58:50 <ddarius> That would be a serious problem for me if it was.
10:01:55 <guenni> ddarius: how can I change the name so people can see my real name with whois?
10:02:08 <allbery_b> depends on the irc client
10:08:54 <dons> http://programming.reddit.com/info/2snta/comments
10:08:55 <lambdabot> Title: Transitioning from sequential to parallel programming: part 2: How to achieve pa ...
10:09:36 <dons> http://programming.reddit.com/info/2snti/comments
10:09:37 <lambdabot> Title: Transitioning from sequential to parallel programming: part 3: parallel programm ...
10:10:01 <mdmkolbe3> dons: is there a part one?
10:10:10 <phobes_> http://www.embedded.com/design/multicore/201806715
10:10:31 <phobes_> There's apparently a part 6!
10:10:35 <dons> http://programming.reddit.com/info/2sntx/comments
10:10:35 <lambdabot> Title: Transitioning from sequential to parallel programming: part 4: explicit paralell ...
10:10:38 <augustss> Holy shit!  There's a conincidence!
10:10:52 <augustss> I was just reading those articles right now.
10:11:03 <xerox> dons: mind have \bot joining #haskell.it ?
10:11:09 <xerox> or can I do it?
10:11:37 <augustss> And I was not led to the articles from reddit
10:11:47 <dons> no, reddit didn't know about them
10:11:50 <dons> i just noticed them too
10:12:46 <augustss> I was reading George Harper's blog
10:13:46 <dons> http://programming.reddit.com/info/2snui/comments
10:13:47 <lambdabot> Title: Transitioning from sequential to parallel programming: part 5: Implicit parallel ...
10:13:54 <dons> http://programming.reddit.com/info/2snuq/comments
10:13:55 <lambdabot> Title: Transitioning from sequential to parallel programming: part 6: So, why aren&#39; ...
10:14:59 <augustss> Nice to see some pH again
10:15:04 <phobes_> http://www.embedded.com/design/multicore/201500267
10:15:06 <dons> yeah!1
10:15:06 <phobes_> Here's part one
10:15:25 <dons> also, we talked about part 1 a few weeks ago, http://programming.reddit.com/info/2fp4r/comments
10:15:26 <lambdabot> Title: Making the transition from sequential to implicit parallel programming: How sequ ...
10:15:38 <ddarius> Why are they not linked to each other?!
10:15:40 <flux> strange how the articles don't link to each other; or even to older articles
10:15:43 <flux> :-)
10:15:52 <P_D> they do on page 2
10:16:35 <xerox> ?source Data.Map
10:16:35 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
10:16:43 <ddarius> P_D: To old ones?
10:16:46 <dons> its weird, isn't it ddarius
10:16:51 <dons> i had to trawl the archives to find htem all
10:17:09 <P_D> and to the next one
10:17:47 <dons> there's some good stuff on embedded.com about parallel programming.
10:17:51 <dons>  a series from the intel guys too
10:18:08 <ddarius> P_D: I don't see a link to 2 from 1, but maybe I'm missing it.
10:18:36 <P_D> You're right, they just have the name.
10:19:22 <mrd> i'm in a parallel algorithms class atm.  special topic run on occasion.
10:19:54 <mrd> hopefully i will be less stupid about it by the end
10:20:24 <dons> this is a really great resource, http://www.embedded.com/design/archive/?content_type=design
10:20:25 <lambdabot> Title: Embedded Systems Design - Embedded.com
10:23:06 <FMota> geez dons
10:23:16 <FMota> way to flood reddit with submissions :o
10:23:26 <augustss> dons: How's Portland/Beaverton?
10:23:39 <dons> FMota: its sunday , i figure people want something to read :)
10:23:40 <mrd> getting random numbers outside of IO is kinda annoying, and you really need it for many parallel algorithms though.  I suppose you could pass around generators.
10:23:54 <dons> augustss: lovely. weather's still nice. food is spectacular.
10:24:09 <FMota> :) I suppose. Or they may just be masochists and program lexers by hand in python.
10:24:18 <augustss> dons: yes, there's plenty of good food.  Where do you live?
10:25:12 <mrd> how about the beer
10:25:26 <dons> augustss: in the pearl district, right down town.
10:25:39 <dons> mrd: beer is diverse
10:25:48 <augustss> Oh, cool.  The Pearl district is great for food and drink.
10:26:05 <augustss> So tram&max to work?
10:26:11 <dons> yep. just walk to the max.
10:26:19 <mrd> pdx is supposed to be microbrew capital
10:26:33 <dons> it sure seems like that, mrd!
10:26:38 <dons> i'm not sure i've seen the same beer twice yet
10:27:01 <augustss> I love Portland, it's a great place.
10:29:48 <augustss> Hmmm, from Arvind&Nikhil's article "We designed pH ...".  I didn't see my name mentioned anyway. :)
10:30:13 <dons> boo :)
10:31:46 <dons> this is another nice collection of articles on parallel and multicore arch/programming, http://www.embedded.com/design/multicore/173400008
10:31:57 <dons> i wonder why embedded.com doesn't appear in the usual rss feeds and search
10:48:55 <mdmkolbe> Anyone ever implemented the simply typed lambda calculus with GADTs to automate the type checking? (I'm running into trouble with proper scope shadowing if I don't use DeBruijn indexes.  E.g. I need to prevent (Lam a (Lam a (Var a)) from getting type checked as a -> b -> a.)
10:50:24 <mdmkolbe> I think this would require some sort of negative assertion in the Haskell type system.
10:50:45 <Heffalump> how do you track names in GADTs?
10:50:45 <EvilTerran> ...that should be a->b->b, right?
10:50:54 <Heffalump> EvilTerran: yes
10:50:58 <mdmkolbe> EvilTerran: yes
10:51:10 <mdmkolbe> Heffalump: as free type variables
10:51:32 <Heffalump> surely their own scoping should come into play then?
10:52:20 <OceanSpray> Haskell does tail-call optimization, right?
10:52:33 <EvilTerran> OceanSpray, the big implementations do so, yes
10:52:42 <OceanSpray> ghc/
10:52:44 <mdmkolbe> OceanSpray: yes, but lazy eval makes tail calls not mean exactly the same thing
10:52:44 <OceanSpray> ?
10:53:16 <ddarius> @wiki Stack overflow
10:53:16 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
10:53:39 <sjanssen> tail calls mean the same thing, but you can accidentally cause heap and stack overflows by using a lazy accumulator
10:54:09 <mdmkolbe> Heffalump: I think I've got trouble b/c in the environment would look like "env :: forall a b. Env ((a, Bool), ((b, Char), ((a, Char), ()))))" in which case both uses of "a" as a veriable name would match.
10:55:03 <Heffalump> ah, yes, I sort of see
10:56:05 <mdmkolbe> Basically I need an extendable finite map that supports shadowing and the type tells me what is stored in the map.
10:56:13 <Heffalump> how do you relate the 'a' at the expression level with the 'a' at the type level?
10:56:38 <oerjan> what if you give a variable a type that includes not only the current value, but also those of the outer scopes?
10:56:41 <phobes_> mdmkolbe:  Why don't you just insist that all nested terms have their own type variables?
10:56:59 <phobes_> (all nested lambdas have their own letters)
10:57:17 <phobes_> The type system will take care of renaming for you
10:58:28 <mdmkolbe> phobes_: that has to do with the higher level point of the exersize, eventually I plan to morph this into something that allows direct manipulation of the variables (the details are complicated)
10:58:30 <oerjan> or something like that.
10:59:11 <mdmkolbe> oerjan: I like your idea.  I'll have to think on it to see if it works.
11:00:41 <mdmkolbe> Heffalump: relating 'a' at the expression level to the type level is done by using a lookup function that runs down the environment and stops when the var names match (it is dependantly typed)
11:00:58 <EvilTerran> mdmkolbe, this sounds rather like that extensible records system someone linked a while ago
11:01:56 <EvilTerran> http://legacy.cs.uu.nl/daan/pubs.html#scopedlabels
11:01:58 <lambdabot> Title: Publications
11:02:35 <Heffalump> but how does it know the names at either level?
11:03:33 <OceanSpray> Cale, you awake?
11:03:57 <OceanSpray> oh nevermind.
11:04:19 <OceanSpray> guys, most of you have some sort of degree in CS, right?
11:04:28 <allbery_b> not I
11:04:47 * ddarius doesn't even have any college besides AP credit and a calc class.
11:04:48 <lament> i took a CS course once
11:04:57 * EvilTerran is working on one
11:05:17 <OceanSpray> well, I need some help
11:05:25 <OceanSpray> see, I'm writing this interpreter
11:05:33 <OceanSpray> of a really unorthodox 'lisp'
11:05:58 <flux> it uses )(-pairs instead of ()?
11:06:10 <flux> (I guess that wasn't being helpful..)
11:06:15 <phobes_> it uses {}
11:06:18 <OceanSpray> and I'm trying to implement continuations by parsing into AST and then 'transforming' the tree into CPS style
11:06:20 <mdmkolbe> "Heffalump: but how does it know the names at either level?" What that at me or EvilTerran?
11:06:34 <ddarius> OceanSpray: Where does a CS degree come in?
11:07:00 <OceanSpray> I'll get to that.
11:07:00 <phobes_> ddarius: heh, I was waiting for someone to take him to task for that :)
11:07:15 <OceanSpray> well, the thing is,
11:07:20 <OceanSpray> I don't have a lambda.
11:07:27 <OceanSpray> how the hell would I do that?
11:07:39 <P_D> have you seen the 90 minute scheme presentation?
11:07:41 <lament> that is.. pretty unorthodox, yes.
11:07:53 <EvilTerran> do you have S and K? :P
11:07:58 <OceanSpray> what are those?
11:08:09 <mdmkolbe> k = \a b -> a
11:08:12 <pjd> OceanSpray: how do you make functions, then?
11:08:13 <EvilTerran> @google SKI calculus
11:08:16 <lambdabot> http://en.wikipedia.org/wiki/SKI_combinator_calculus
11:08:16 <lambdabot> Title: SKI combinator calculus - Wikipedia, the free encyclopedia
11:08:19 <mdmkolbe> s = \f a b -> (f a) (f b)
11:08:27 <ddarius> OceanSpray: We can't help you without know what -is- available?
11:08:38 <OceanSpray> well, I have 'flambda'
11:08:45 <OceanSpray> pass-by-expression.
11:09:01 <phobes_> call-by-name?
11:09:14 <OceanSpray> flambdas have access to the environment of their caller's environment
11:09:27 <OceanSpray> yes, it breaks a lot of things, I know.
11:09:38 <mdmkolbe> OceanSpray: i.e. flambdas are dynamically scoped?
11:09:41 <OceanSpray> no.
11:09:47 <OceanSpray> not dynamically scoped.
11:09:49 <lament> sounds like Io
11:09:58 <OceanSpray> it is.
11:10:08 <OceanSpray> inspired to a degree, I mean.
11:10:13 <augustss> OceanSpray: which language is this?
11:10:24 <OceanSpray> I haven't thought of a name for it
11:10:43 <ddarius> OceanSpray: Familiar with Brown, Blonde, Black, and Refci?
11:10:44 <phobes_> I suggest CobraExtreme
11:10:52 <OceanSpray> what?
11:11:26 <bakert> boring monad question.  if i get a result in main that is in a monad (not IO), how do i "unwrap" it without main saying "Couldn't match `BlahMonad' against `IO'"?  i thought i could just use do and <- but apparently not :(
11:12:03 <oerjan> bakert: depends on the BlahMonad.
11:12:04 <mauke> depends on the monad
11:12:12 <lament> bakert: in general, you can't "unwrap" stuff from monads.
11:12:14 <int-e> it depends on the monad obviously; many come with some runFoo function
11:12:15 <oerjan> often some function named run***
11:12:24 <OceanSpray> ok, I googled 'Brown, Blonde, Black, and Refci', and got something about Reflective Towers
11:12:27 <allbery_b> most non-IO monads have a runMumble
11:12:27 <bakert> Ah.  It's Test.QuckCheck.Gen (for random numbers)
11:12:27 <augustss> OceanSpray: well, how can you expect to program without a proper lambda? ;)
11:12:30 <lament> bakert: that's why the unwrapping function is missing from the typeclass definition.
11:12:48 <OceanSpray> see, lambda can be implemented in terms of the flambda I have
11:13:06 <bakert> lament: i only mean unwrap in the sense of peak inside and print a string representation of.
11:13:28 <ddarius> OceanSpray: Brown, Blonde, Black and Refci are each behaviourally reflective languages.
11:13:28 <oerjan> bakert: maybe generate?
11:13:30 <mauke> that's kind of hard if the monadic value is a function
11:14:14 <int-e> @type Test.QuickCheck.generate
11:14:16 <OceanSpray> (flambda (x) (eval x caller-environment)) would be synonymous with (lambda (x) x)
11:14:16 <lambdabot> forall a. Int -> StdGen -> Test.QuickCheck.Gen a -> a
11:14:21 <int-e> looks good
11:14:41 <cinimod> bakert: I'm not sure which QuickCheck you are using. Mine comes with sample :: forall a. (Show a) => Gen a -> IO ()
11:14:54 <OceanSpray> caller-environment is a symbol that is dynamically bound to the caller's environment with each procedure call.
11:16:11 <OceanSpray> so anyways... is CPS transformation even possible?
11:16:16 <bakert> cinimod: what i've done is i've wrapped functions of mine in Gen.  so now i reach the top level (main) with a record  (of type defined by me) inside Gen.  And i need to "get it out" and print the string representation.
11:16:24 <OceanSpray> should I try keeping my own call stack instead?
11:17:26 <oerjan> strange, generate could almost be Gen's field name but has different argument order
11:17:59 <bakert> So I can't just have: main = putStrLn $ show $ myFunc, because there's no definition of Show (Gen MyType)
11:18:04 <oerjan> :t Test.QuickCheck.Gen
11:18:07 <lambdabot>     Not in scope: data constructor `Test.QuickCheck.Gen'
11:18:44 <oerjan> (not exported?)
11:18:47 <dons> right, you'll need to run your Gen monad somehow
11:18:58 <dons> usually via 'quickCheck' or some similar function
11:18:58 <ddarius> OceanSpray: The problem with CPS is that it is a global transformation.
11:19:01 <dons> :t quickCheck
11:19:03 <lambdabot> Not in scope: `quickCheck'
11:19:11 <dons> :t Test.QuickCheck.quickCheck
11:19:13 <lambdabot> forall a. (Test.QuickCheck.Testable a) => a -> IO ()
11:19:23 <ddarius> OceanSpray: I think you would greatly benefit at looking at Brown as described in "The Mystery of the Tower Revealed"
11:19:31 <OceanSpray> hmm.
11:19:33 <bakert> dons: i thought i could just use: do x <- myFunc ... but I guess that is IO specific in some way
11:19:47 <dons> but myFunc isn't a function, is it? its a function wrapped in a Generator monad
11:19:51 <mauke> bakert: it isn't
11:20:05 <int-e> bakert: do does not convert between monads, all computations happen in the same monad and the result will be in the same monad
11:20:19 <bakert> um.  myFunc :: Gen MyType
11:20:23 <dons> you'd need 'sample' or one of the other Gen-flattening functions
11:20:30 <bakert> does that mean it's not a function?
11:20:31 <int-e> > do x <- [1,2,3]; y <- [4,5,6]; return (x, y)
11:20:32 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:20:39 <int-e> do is syntax.
11:20:47 <SamB> the Haskell 98 report doesn't even say that do needs to return a monadic value ;->
11:21:00 <ddarius> OceanSpray: http://library.readscheme.org/page11.html contains links to many other papers that would be relevant
11:21:03 <lambdabot> Title: Reflection
11:21:06 <dons> oh, you want to run the code in the Gen monad, then wrap that in an outer shell of type IO. (for test case generation?)
11:21:06 <int-e> it does say, however, how it gets desugared.
11:21:07 <int-e> > 1
11:21:08 <lambdabot>  1
11:21:09 <int-e> > do 1
11:21:10 <lambdabot>   add an instance declaration for (Num (t t1))
11:21:10 <lambdabot>     In the expression: 1
11:21:10 <lambdabot>     I...
11:21:26 <int-e> and ghc adds a type constraint here.
11:21:35 <int-e> @undo do 1
11:21:35 <lambdabot> (1)
11:21:49 <bakert> but i still have the same problem if i abandon "do
11:21:57 <bakert> " and go with the non-sugary version, right?
11:22:07 <bakert> which is that main want's to be :: IO ()
11:22:25 <bakert> and i have a (Gen MyType) that i want to display
11:22:36 <OceanSpray> so what I'm trying to write has already been described or implemented?
11:22:45 <cinimod> bakert: http://hpaste.org/2872 might be the sort of thing you want
11:23:05 <oerjan> bakert: a value of type Gen a is a procedure to generate _many_ values of type a.
11:23:10 <SamB> I was teasing about that Haskell 98 thing. apparantly the majority opinion is that it was an omission...
11:23:21 <oerjan> there isn't one particular value in it, usually.
11:23:46 <SamB> though I have to wonder if it's a good idea to desugar do 1 to something you can't write in Haskell 98...
11:23:50 <oerjan> however, you can use generate to get one of them.
11:24:07 <bakert> oerjan: i see.  so perhaps i have structured my program incorrectly.
11:24:27 <bakert> i thought because i was using these random numbers at the low level
11:24:35 <bakert> that i should wrap everything in the Gen monad up to the top
11:24:51 <bakert> and then unwrap the final record i have generated and print it
11:24:54 <bakert> is that madness?
11:25:01 <oerjan> not necessarily.
11:25:22 <oerjan> however you need to pass in the random generator and seed
11:25:43 <bakert> oh.  i thought i was avoiding that by having everything happen in Gen!
11:25:44 <bakert> :(
11:25:57 <oerjan> Gen handles the passing around of those
11:26:00 <bakert> i didn't like the idea of passing an extra arg to every function
11:26:06 <oerjan> but you have to pass in the initial one
11:26:16 <bakert> oh i see ... so i just need to pass it in at the top where i slip into Gen.  good :)
11:26:48 <gwern> hey everyone. do ByteStrings offer O(1) access to elements of a ByteString? "Note that, unlike Haskell, both Scheme and CL have random- access on strings in O(1), something which I exploit to generate better code."
11:27:00 <dons> yes.
11:27:16 <SamB> except those darn lazy ones
11:27:27 <dons> lazy ones are O(n/k) which is O(1) for most strings
11:27:33 <dons> :)
11:27:36 <gwern> SamB: oh, so it's just strict ByteStrings?
11:27:45 <gwern> dons: what's O(n/k)?
11:27:56 <int-e> @type \x -> System.Random.newStdGen >>= \g -> Test.QuickCheck.generate 3 g x
11:27:58 <lambdabot> forall b. Test.QuickCheck.Gen (IO b) -> IO b
11:28:02 <augustss> O(n/k) is O(1) for anything that fits in memory :)
11:28:13 <int-e> @type \x -> System.Random.newStdGen >>= \g -> return (Test.QuickCheck.generate 3 g x)
11:28:15 <lambdabot> forall a. Test.QuickCheck.Gen a -> IO a
11:28:27 <bakert> ooh
11:28:31 <SamB> gwern: well, the lazy bytestrings are essentially represented as lists of strict ones
11:28:32 <bakert> that looks interesting
11:28:35 <gwern> augustss: I guess I should rephrase that then - what are n and k in that expression? n is input, I know, but what's k?
11:28:37 <dons> and [a] strings are O(n) of course. which is what the OP is referring to
11:28:56 <dons> gwern: for the lazy bytestring type, k is the chunkszie
11:29:12 <gwern> dons: yes, but I was going to post a comment pointing out that ByteStrings didn't have the list style's complexities
11:29:16 <dons> so indexing is just walking the chunk list, then O(1) index into the chunk. chunks are typically 32k
11:29:40 <gwern> oh, ok. that makes sense
11:29:49 <dons> gwern: right. you can just say: look, ByteStrings have O(1) indexing, and substrings, and are bloody fast.
11:29:53 <SamB> which is pretty darn close to O(1) when you aren't trying to fix a Fuun
11:30:01 <dons> they also fuse. unlike in Scheme or CL
11:30:41 <gwern> heh. yeah, the ICFP endo thing turned out to be a great advertisement for byestrings eh?
11:30:46 <bakert> So if I pass this newStdGen into my top level function, am I then going to have to pass it down to the bottom of my program in order to use it in a generate call, or can I somehow pass responsibility for that to the Gen monad once i am inside it?
11:31:01 <bakert> and not have an extra arg on all my functions?
11:31:29 <augustss> gwern: I used Data.Sequence for endo.  Seems to work too
11:31:41 <oerjan> bakert: generate is on the outside of the Gen monad.
11:32:02 <SamB> I suppose it would be a good idea to avoid actually slicing the middle zone of DNA unless something is actually being written to it?
11:32:10 <bakert> oerjan: but i can't call generate on an arbitrary function of my own creation that happens to be in Gen, can I?
11:32:38 <oerjan> sure you can
11:32:46 <oerjan> if i understand what you mean
11:32:51 <SamB> bakert: what does the type say?
11:32:58 <bakert> SamB: of my function?
11:33:03 <SamB> of generate
11:33:10 <SamB> @hoogle generate
11:33:11 <lambdabot> Test.QuickCheck.generate :: Int -> StdGen -> Gen a -> a
11:33:11 <lambdabot> System.Win32.Mem.hEAP_GENERATE_EXCEPTIONS :: HeapAllocFlags
11:33:19 <SamB> the type says "yes!"
11:33:50 <bakert> Cool.  OK!  I'm not sure what that Int is for!
11:34:08 <SamB> I expect that it's written somewhere
11:34:18 <SamB> @doc Test.QuickCheck
11:34:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
11:34:49 <infrared> what's the best/idiomatic way to format strings in Haskell? Text.Printf?
11:34:57 <oerjan> QuickCheck uses it to get varying but consistent values in some cases, i think
11:36:44 <wli> printf -like things are evil
11:36:58 <wli> I favor show and ++
11:37:21 * araujo agrees
11:37:36 <wli> printf -like things are also inefficient
11:38:02 <infrared> i care more about how the code will look
11:38:33 <dons> infrared: for complex formating requirements, Text.PrettyPrint. for medium formating requirements, printf. for lightweight formatting, ++
11:38:34 <int-e> @type shows
11:38:34 <infrared> and to admit, i don't like the idea of concatenating different parts of a return string either..
11:38:38 <wli> show and ++ really win there
11:38:40 <lambdabot> forall a. (Show a) => a -> String -> String
11:38:43 <bakert> ooh thanks oerjan and SamB and int-e and dons and everyone.  working with generate and an aribitrary "3" in there ... will work out what that does later!
11:39:02 <infrared> dons: now that's an answer, thanks, i'll check out pretty print
11:39:11 <int-e> bakert: it's a parameter that affects the size of generated numbers and lists and the like.
11:39:39 <bakert> so basically it is the responsibility of a monad to provide a function to get the result of itself into IO if that might be useful.  and they are sometimes called run and sometimes have other names.  have i understood right?
11:39:54 <oerjan> yeah
11:40:24 <pchiusano> hello
11:41:14 <oerjan> those that are defined in the Control.Monad.* modules have run***, i think
11:41:22 <SamB> bakert: evidently the Int determines the maximum size
11:41:40 <bakert> ah.  thanks
11:41:44 <oerjan> whoops, that was it
11:42:07 * oerjan now recall being confused about that int himself last time QuickCheck was discussed
11:42:15 <SamB> bakert: lots of monads don't have anything to do with IO though, so typically they'll have a pure function instead
11:42:16 <oerjan> *s
11:42:31 <int-e> @type Control.Monad.State.runState
11:42:32 <bakert> SamB: a pure function that unwraps the value without going into IO you mean?
11:42:33 <lambdabot> forall s a. State s a -> s -> (a, s)
11:42:40 <int-e> bakert: take this one
11:42:44 <bakert> right.
11:42:49 <SamB> bakert: well, does whatever it is that the monad is for
11:43:04 <oerjan> and those that are monad _transformers_ will have a function that unwraps into the underlying monad
11:43:13 <oerjan> @type Control.Monad.State.runStateT
11:43:15 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
11:43:28 <oerjan> which may or may not be IO-based
11:43:56 <SamB> bakert: most of them take arguments, so can't really be said to unwrap a value
11:44:09 <bakert> i see (ish).  i should have known by analogy with "browse" in Http.Browser that this is how it works.  perhaps i needed to see a second one to start to get it.
11:44:12 <SamB> Writer is one notable exception
11:44:45 <pchiusano> is there a handy pretty print library in haskell?
11:44:47 <SamB> it unwraps not one but *two* values ;-P
11:44:52 <SamB> @hoogle PrettyPrint
11:44:53 <lambdabot> No matches found
11:44:58 <SamB> @hoogle Pretty
11:44:59 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
11:44:59 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
11:45:00 <dons> pchiusano: yeah, Text.PrettyPrint is an excellent one
11:45:04 <oerjan> also, for the monads that are based on Prelude types the functions are usually _not_ called run***
11:45:05 <SamB> hmm.
11:45:10 <dons> ?docs Text.PrettyPrint.HughesPJ
11:45:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
11:45:18 <SamB> why didn't hoogle find it?
11:45:26 <pchiusano> I want something for non-haskell code
11:45:26 <oerjan> Maybe, [] and Either
11:45:27 <dons> ?hoogle Doc
11:45:27 <lambdabot> Text.PrettyPrint.HughesPJ.Doc :: data Doc
11:45:27 <lambdabot> Language.Haskell.TH.PprLib.Doc :: type Doc
11:45:27 <lambdabot> Language.Haskell.TH.PprLib.to_HPJ_Doc :: Doc -> Doc
11:45:44 <dons> pchiusano: right. Text.PrettyPrint is a generic pretty printer library
11:45:46 <SamB> pchiusano: it's a library for pretty-printing -- not for pretty-printing Haskell code
11:45:49 <dons> like parsec, but for printing out.
11:46:02 <SamB> I would like to see a library that was designed with Haskell code in mind, actually
11:46:10 <dons> i've used them for .txt, .hs, .tex, .html, .wiki
11:46:18 <pchiusano> okay
11:46:22 <dons> for .c too
11:46:29 <SamB> (but still a general purpose one)
11:46:41 <pchiusano> dons: is there someplace I can see some examples of Text.PrettyPrint
11:46:44 <pchiusano> or tutorials
11:46:47 <bakert> Is there an easy way to give "Show" powers to a data declaration like "data X = Hello | Goodbye" where the output would be "Hello" or "Goodbye"?
11:47:08 <SamB> pchiusano: the documentation should reference a paper
11:47:08 <dons> pchiusano: i've some examples here, http://www.cse.unsw.edu.au/~dons/code/hwn/utils/publish.hs
11:47:11 <oerjan> bakert: data X = Hello | Goodbye deriving (Show)
11:47:13 <int-e> bakert: add a 'deriving Show' directly after the declaration.
11:47:16 <dons> pchiusano: and hte paper is an excellent source
11:47:21 <dons> http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps
11:47:31 <bakert> oerjan, int-e: thanks
11:47:33 <pchiusano> ok, thx
11:48:11 <SamB> pchiusano: yes, do not underestimate the usefullness and practicality of papers
11:49:41 <pchiusano> 44 pages??
11:50:00 <ddarius> pchiusano: Is too much documentation a problem?
11:50:13 * notsmack was excited to see (1 of 44)
11:50:17 <dons> me too :)
11:50:21 <SamB> you don't have to read it from cover to cover
11:50:32 <pchiusano> hehe
11:50:37 <dons> its basically, render $ text "this" <+> text "is" <> parens (vsep [some, cool, stuff])
11:50:50 <dons> you just use the combinators to mark up text and blocks, wrap them in syntax
11:50:52 <dons> and then print it out
11:51:12 <pchiusano> okay, I am taking a look
11:51:35 <dons> ghc uses these combinators for all its different backends
11:51:42 <dons> so they're good to know if you plan on generating source
11:52:24 <dons> here's an example http://darcs.haskell.org/ghc/compiler/cmm/PprCmm.hs
11:52:27 <dons> for the C-- language
11:52:40 <dons> pprBBlock (BasicBlock ident stmts) = hang (pprBlockId ident <> colon) 4 (vcat (map ppr stmts))
11:52:53 <dons> you in general wrap things in a bit of syntax, then recursively descend
11:52:58 <pchiusano> hmm
11:53:12 <dons> so that does:    label:\n    stmt; stmt; stmt
11:55:15 <pchiusano> okay, this is actually somewhat cool
11:55:41 <pchiusano> I would never have thought to develop a combinator library for prettyprinting
11:56:32 <ddarius> pchiusano: What would you have done?
11:56:39 <dons> it makes publishing and maintaining complex document formats so much easier though, since you've separated output from formatting, and then described a rich formatting language
11:56:46 <dons> so EDSL ftw!
11:56:59 <pchiusano> hehe, I would have just written some ad hoc functions for doing it myself
11:58:25 <chessguy> @hoogle String -> [String]
11:58:26 <lambdabot> Prelude.lines :: String -> [String]
11:58:26 <lambdabot> Prelude.words :: String -> [String]
11:58:26 <lambdabot> Text.Regex.splitRegex :: Regex -> String -> [String]
11:58:35 <chessguy> @hoogle+
11:58:50 <chessguy> @hoogle [a] -> [[a]]
11:58:51 <lambdabot> List.inits :: [a] -> [[a]]
11:58:51 <lambdabot> List.tails :: [a] -> [[a]]
11:58:51 <lambdabot> List.group :: Eq a => [a] -> [[a]]
11:59:02 <chessguy> @hoogle+
11:59:02 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
11:59:34 <sorear> The Haskell community has an acute shortage of buggy underdocumented programs.
11:59:56 <oerjan> @remember sorear The Haskell community has an acute shortage of buggy underdocumented programs.
11:59:57 <lambdabot> Done.
12:00:29 <oerjan> sometimes i think i'm a bit too easy to bait :)
12:00:41 <dons> sorear: :)
12:00:42 <cognominal_> can someone give a example of a simple Tree as per Data.Tree. I dont know to use type with records
12:00:48 <chessguy> how do i turn "foo,bar,baz" into ["foo","bar","baz"] again?
12:00:50 <sorear> > Node []
12:00:51 <lambdabot>  Add a type signature
12:00:54 <sorear> > Node 0 []
12:00:57 <dons> there's lambdabot though, sorear :)
12:00:57 <lambdabot>  Node {rootLabel = 0, subForest = []}
12:01:15 <sorear> chessguy: write a function
12:01:34 <sorear> chessguy: there is no standard split, because no two library gods can agree on the API
12:01:39 <oerjan> > parse
12:01:40 <lambdabot>   Not in scope: `parse'
12:01:46 <cognominal_> @t Node 0 []
12:01:46 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
12:01:56 <cognominal_> @type  Node 0 []
12:01:58 <lambdabot> forall t. (Num t) => Tree t
12:02:06 <int-e> you can use  :t  for  @type
12:02:10 <oerjan> :t parse
12:02:11 <cognominal_> thx  sorear
12:02:12 <lambdabot> Not in scope: `parse'
12:02:21 <sorear> oerjan: there is no parse
12:02:53 <infrared> there is not spoon :)
12:02:55 <oerjan> sure there is
12:02:57 <mauke> splits :: (Eq a) => [a] -> [a] -> [[a]]
12:03:05 <mauke> ^ that's the API
12:03:35 <tehgeekmeister> ?src random
12:03:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:03:36 <oerjan> but i cannot be bothered to try an example if i have to prefix everything by Text.ParserCombinators.Parsec.
12:03:40 <wli> @hoogle splits
12:03:41 <lambdabot> No matches found
12:04:34 <chessguy> @quote loop.head
12:04:34 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
12:04:47 <chessguy> @quote loop
12:04:47 <lambdabot> chessguy says: the loop is only in your brain
12:05:55 <oerjan> parse (sepBy (many (noneOf ",")) (char ',')) "" "foo,bar,baz"
12:06:17 <chessguy> @src lines
12:06:17 <lambdabot> Source not found. Where did you learn to type?
12:06:20 <oerjan> gives Right ["foo","bar","baz"]
12:06:42 <chessguy> @src words
12:06:42 <lambdabot> words s = case dropWhile isSpace s of
12:06:42 <lambdabot>     "" -> []
12:06:42 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:07:21 <oerjan> @hoogle Either a b -> b
12:07:22 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
12:09:03 <oerjan> Parsec is rather strict though, unlike words and lines
12:09:17 <mauke> http://hpaste.org/2873
12:10:05 <BSP> has anyone here using the build of ghc for mac os x? i've probably done something dumb, but whenever i try to "runghc" it just says "runghc: cannot find ghc"
12:13:07 <chessguy> http://hpaste.org/2874
12:14:16 <mauke> that's limited to a single character
12:14:24 <chessguy> so?
12:15:05 <EvilTerran> <mauke> splits :: (Eq a) => [a] -> [a] -> [[a]] <mauke> ^ that's the API
12:15:31 <mauke> chessguy: and I don't like that it can't produce empty fields
12:16:52 <chessguy> so call my separateByChar and have a more general version too
12:16:58 <chessguy> well, not Char
12:17:05 <chessguy> Elem
12:17:16 <oerjan> make one with parameters for all the options.  call it kitchenSink.
12:17:33 <EvilTerran> oerjan, i think that's parsec ;)
12:17:40 <chessguy> lol
12:17:42 <mauke> no, make one that preserves empty fields
12:17:49 <mauke> you can always filter them out later
12:18:03 <tehgeekmeister> ?src runState
12:18:04 <lambdabot> Source not found. My mind is going. I can feel it.
12:18:45 <chessguy> @type interact
12:18:50 <lambdabot> (String -> String) -> IO ()
12:18:57 <mauke> chessguy: if you can make your version non-reentrant, you can call it strtok :-)
12:19:10 <chessguy> non-re-whowhat?
12:19:29 <wli> splits is what I usually call \xs -> zip (inits xs) (tails xs) done in more efficient fashions.
12:20:13 <mauke> getting that to "work" will be very hard in haskell
12:20:15 <chessguy> mauke, oh yeah, well if you can reflumigate the foobarator, i'll behaggle the barfazzle
12:20:16 <nominolo> data State s a = State { runState :: s -> (a,s) }
12:20:32 <nominolo> tehgeekmeister, so, runState (State f) = f
12:20:39 <mauke> http://en.wikipedia.org/wiki/Reentrant
12:20:42 <lambdabot> Title: Reentrant - Wikipedia, the free encyclopedia
12:21:20 <chessguy> oh, concurrency-friendly
12:21:48 <mauke> not necessarily
12:22:10 <chessguy> "A computer program or routine is described as reentrant if it can be safely executed concurrently"
12:22:20 <mauke> ok, strtok doesn't take a callback, but if it did, the callback couldn't call strtok
12:23:15 <ddarius> chessguy: A function is non-reentrant if it breaks if it is called while it is executing.
12:23:23 <tehgeekmeister> nominolo: thanks
12:23:37 <Zao> If a function is not reentrant, you couldn't call it from a signal handler, for example.
12:23:51 <Zao> Because the signal may have been raised while inside the function.
12:24:06 <pjd> you can't use strtok with two strings at once (that is, parse a bit from the one, then the other, and so on)
12:24:18 <pjd> because of the internal state it keeps
12:24:28 <Zao> It's a quite silly function in general.
12:24:30 <sieni> although a function might be reentrant for other purposes than being called from a signal handler
12:25:29 <pjd> you get for example strtok_r, which maintains the state in an explicit parameter, to remove that limitation
12:25:30 <sieni> e.g. calling pthread_mutex_lock from a signal handler might be unsafe
12:26:59 <Zao> pjd: Which is not in any C standard, just posix, but still quite nice.
12:27:33 <pjd> it's in implementations, which is what matters most :)
12:27:55 <chessguy> @pl e = i $ \l -> (p . t . g) l
12:27:55 <lambdabot> e = i (p . t . g)
12:28:10 <wli> > let splits sep xs | sep `isPrefixOf` xs = [] : splits sep (drop (length sep) xs) | otherwise = case xs of { [] -> [] ; y:ys -> case splits sep ys of { [] -> [[y]] ; z:zs -> (y:z):zs } } in splits "," "aardwolf,echidna,,quagga"
12:28:12 <lambdabot>  ["aardwolf","echidna","","quagga"]
12:29:42 <EvilTerran> > let splits ds xs = fromMaybe [] $ listToMaybe [it : splits ds (drop (length ds) tl) | (it,tl) <- zip (inits xs) (tails xs), ds `isPrefixOf` tl] in splits "xy" "xyfooxybarxyxybazxy"
12:29:43 <lambdabot>  ["","foo","bar","","baz"]
12:30:20 <mauke> fail
12:30:29 <EvilTerran> hm. misses the "" at the end.
12:30:38 <EvilTerran> > let splits ds xs = fromMaybe xs $ listToMaybe [it : splits ds (drop (length ds) tl) | (it,tl) <- zip (inits xs) (tails xs), ds `isPrefixOf` tl] in splits "xy" "xyfooxybarxyxybazxy"
12:30:40 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
12:30:40 <lambdabot>       Expected...
12:30:45 <EvilTerran> > let splits ds xs = fromMaybe [xs] $ listToMaybe [it : splits ds (drop (length ds) tl) | (it,tl) <- zip (inits xs) (tails xs), ds `isPrefixOf` tl] in splits "xy" "xyfooxybarxyxybazxy"
12:30:47 <lambdabot>  ["","foo","bar","","baz",""]
12:30:50 <EvilTerran> > let splits ds xs = fromMaybe [xs] $ listToMaybe [it : splits ds (drop (length ds) tl) | (it,tl) <- zip (inits xs) (tails xs), ds `isPrefixOf` tl] in splits "xy" "xyfooxybarxyxybaz"
12:30:52 <lambdabot>  ["","foo","bar","","baz"]
12:30:55 <EvilTerran> there we go
12:31:52 <chessguy> so interact expects its input on STDIN?
12:32:05 <EvilTerran> yes
12:32:10 <EvilTerran> and outputs to STDOUT
12:32:55 * EvilTerran makes a note of that defn of splits
12:32:57 <EvilTerran> i like that
12:34:09 <oerjan> @src interact
12:34:10 <lambdabot> interact f = do s <- getContents; putStr (f s)
12:34:49 <pchiusano> hmm, I am playing with Text.PrettyPrint
12:35:14 <pchiusano> suppose I have an expression like: a = Blah
12:35:43 <pchiusano> I want 'Blah' to wrap to the next line, indented one tabstop, if it doesn't fit on the same line as the 'a ='
12:36:03 <pchiusano> how would I express that?
12:38:35 <EvilTerran> @src isPrefixOf
12:38:35 <lambdabot> isPrefixOf [] _          = True
12:38:35 <lambdabot> isPrefixOf _  []         = False
12:38:35 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
12:40:26 <pjd> and . zipWith (==) ?
12:40:42 <dons> and . zip
12:40:46 <dons> ?src zip
12:40:46 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
12:40:46 <lambdabot> zip _      _      = []
12:40:51 <dons> oh . oops. :)
12:40:55 <dons> ?src group
12:40:56 <lambdabot> group = groupBy (==)
12:41:08 * dons needs ... coffee!
12:41:10 <EvilTerran> > and . zipWith (==) $ "abcdef" "abc"
12:41:11 <lambdabot>  Couldn't match expected type `[Bool]'
12:41:17 <EvilTerran> > (and . zipWith (==)) "abcdef" "abc"
12:41:18 <lambdabot>  Couldn't match expected type `[Bool]'
12:41:30 <EvilTerran> > and $ zipWith (==) "abcdef" "abc"
12:41:32 <lambdabot>  True
12:41:34 * pjd wires dons a brew
12:41:39 <EvilTerran> > isPrefixOf "abcdef" "abc"
12:41:40 <lambdabot>  False
12:41:50 <EvilTerran> there we go!
12:42:07 <dons> actually, i've got some new beans here to try. caffeine time!
12:43:06 <dons> what's the point of joining the ACM these days?
12:43:25 <xerox> :t (and .) . zipWith (==)
12:43:27 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
12:43:36 <Zao> dons: You get a shiny membership card :P
12:44:00 <dons> yeah, seems kinda expensive and pointless. just for that research paper lock-in
12:44:24 <chessguy> @src Eq
12:44:24 <lambdabot> class  Eq a  where
12:44:24 <lambdabot>     (==), (/=)   :: a -> a -> Bool
12:44:31 <pejo> dons, discounts for conferences?
12:45:03 <pejo> dons, if you're not a student the discount is noticable.
12:45:28 <dons> yeah. there's that too
12:46:21 <dons> so just paying to join an event organising business, and to get the discount
12:46:39 <dons> they should provide frequent author cards. write 5 papers, and get the 6th conference free!
12:47:18 <Heffalump> I think they're worth supporting, given the amount of stuff they do.
12:47:21 <iguana_> how to I read "2.1" as a Rational?
12:47:39 <Heffalump> > read "2.1" :: Rational
12:47:41 <dons> Heffalump: but what do they do?
12:47:41 <lambdabot>  Exception: Prelude.read: no parse
12:47:58 <pejo> dons, quality, not quantity. :-)
12:48:02 <Heffalump> organise conferences is quite a big thing
12:48:04 <oerjan> > readFloat "2.1" :: Rational
12:48:05 <lambdabot>  Couldn't match expected type `Rational'
12:48:15 <Heffalump> > fromDouble (read "2.1" :: Double)
12:48:16 <lambdabot>   Not in scope: `fromDouble'
12:48:17 <dons> other than spam me to join. and organise conference events/hoard research papers under their library
12:48:32 <allbery_b> :t toRational
12:48:33 <lambdabot> forall a. (Real a) => a -> Rational
12:48:40 <oerjan> > readFloat "2.1" :: [(Rational,String)]
12:48:42 <lambdabot>  [(21%10,"")]
12:48:45 <dons> we pay to go to the conferences anyway, with or without acm membership
12:48:53 <allbery_b> > toRational (read "2.1" :: Double)
12:48:54 <lambdabot>  4728779608739021%2251799813685248
12:48:58 <dons> mmm
12:49:02 <phlpp> hi
12:49:02 <iguana_> allbery_b: I had that too :)
12:49:02 <Heffalump> they don't necessarily make a profit on them, though
12:49:03 <allbery_b> ...gesundheit!
12:49:04 <oerjan> > readFloat "-2.1" :: [(Rational,String)]
12:49:06 <lambdabot>  []
12:49:06 <Heffalump> and they do underwrite them
12:49:11 <oerjan> (no negatives)
12:49:23 <phlpp> i've got some short question; what's the most favourite editor/ide for hacking haskell?
12:49:40 <allbery_b> emacs :)
12:49:50 <Heffalump> emacs
12:49:50 <dons> vim :)
12:49:51 <Zao> vim! :P
12:49:51 <phlpp> yeah, this was my intention, too
12:49:54 <phlpp> (emacs)
12:49:56 <iguana_> emacs!!!1
12:49:57 <EvilTerran> SciTE!
12:49:59 <lambdabot> vim!!!
12:50:00 <mauke> vim
12:50:00 <Heffalump> Visual Haskell is nice, when it works.
12:50:01 <Zao> notepad.exe
12:50:06 <phlpp> is there some addon which's useful for hacking haskell at emacs?
12:50:15 <lambdabot> the vim plugin!
12:50:18 <phlpp> :D
12:50:19 <Zao> I've heard that Yi is pretty neato.
12:50:21 <Choko> haskell-mode
12:50:30 <EvilTerran> @bot ?
12:50:31 <lambdabot> :)
12:50:32 <phlpp> i mean, there's slime for lisp at emacs
12:50:41 <chessguy> @pl \f -> r (d 1 f)
12:50:42 <lambdabot> r . d 1
12:51:07 <phlpp> okay guys, l8er
12:51:08 <phlpp> :>
12:52:22 <iguana_> @hoogle readFloat
12:52:22 <lambdabot> Numeric.readFloat :: RealFloat a => ReadS a
12:52:22 <lambdabot> Numeric.readFloat :: RealFrac a => ReadS a
12:52:45 <EvilTerran> uhh
12:52:58 <eric-lavigne> I am new to Haskell and trying to start with HAppS (latest darcs version). When running Setup.hs, I get the error "cannot satisfy dependency hslogger>=1.0.2". I installed hslogger 1.0.2 through debian's synaptic package manager but still get the error. How do I help Setup.hs to find the new library? I tried looking at the source in Setup.hs, but it looks more like "I am an installation script" than actual instructions for installation.
12:53:33 <dons> you sure it was installed though?
12:53:41 <dons> check whether hslogger is found with ghc-pkg list
12:54:01 <dons> once a haskell library is properly installed, Setup.hs should find it automatically
12:54:03 <eric-lavigne> I should find that file in my ghc installation?
12:54:10 <dons> yep
12:54:21 <dons> $ ghc-pkg list
12:54:21 <dons> /home/dons/lib/ghc-6.9.20070919/package.conf: Cabal-1.2.0, QuickCheck-1.0.1, X11-1.2.2, array-0.1, arrows-0.2.1,
12:54:24 <dons> ...
12:54:24 <eric-lavigne> I have not checked. I will return when I have done that.
12:54:29 <allbery_b> when using a package manager you need to make sure that you're installing for the right environment (ghc vs. hugs vs. etc., same version)
12:54:31 <dons> its a command to list the installed haskell packages
12:54:32 <SamB_XP> eric-lavigne: the vast majority of Setup.{hs,lhs} scripts just use the stock "main" routine, yes...
12:54:40 <eric-lavigne> It is definitely for ghc.
12:56:18 <dons> whoa, check out RyanT's spectral norm program, http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=all
12:56:19 <lambdabot> Title: spectral-norm benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/bruf8
12:57:28 <dons> he just tweaked the compiler flags slightly, and started using shifts
12:57:35 <dons> and now 3x faster
12:58:06 <eric-lavigne> "ghc-pkg list" shows that I have version 1.0.1, even though I installed 1.0.2 through synaptic. Looks like I have more than one copy of the library.
12:58:46 <nominolo> that program looks like really ugly C to me
12:58:56 <dons> it is. its low level floating point math
12:59:05 <dons> welcome to microbenchmarks :)
12:59:21 <nominolo> nice tweaking, but hardly a show-off for Haskell
12:59:21 <dons> the point being: the ruby and python guys just wish they could do this without going to C.
12:59:33 <dons> while we can stay in haskell if needed
12:59:47 <Zao> eric-lavigne: What's the name of the package?
12:59:51 <nominolo> yeah,  but going via C still seems the quickest solution, doesn't it?
13:00:01 <dons> not in terms of speed :)
13:00:12 <pjd> dons: hey, we have Pyrex
13:00:14 <nominolo> speed of what?
13:00:22 <dons> `the quickest solution'
13:00:33 <nominolo> i mean, is the C code particularly optimized?
13:00:35 <eric-lavigne> The synaptic package that I installed was libghc6-hslogger-dev (version 1.0.2)
13:01:06 <SamB_XP> dons: not `the most performant solution'?
13:01:12 <dons> nominolo: looks like it.
13:01:21 <dons> it scrapes in just behind ghc on this one
13:01:25 <nominolo> if i have a problem that requires some amount of C, isn't it best to just write it in C and interface, rather than tweak Haskell for hours?
13:01:31 <dons> right.
13:02:11 <dons> that's what i'd usually do. nonetheless, this hints at what is possible: imagine hiding this stuff inside a library
13:02:15 <SamB_XP> nominolo: it'll screw up your inlining
13:02:17 <dons> oh, we do do that already
13:02:20 <iguana_> how to I convert a hex number?
13:02:27 <nominolo> but, of course, sometimes that might not be possilble, yes
13:02:33 <iguana_> "a" -> 10
13:02:33 <dons> > read "0x123ffa" :: Integer
13:02:35 <lambdabot>  1196026
13:02:38 <iguana_> cool
13:03:10 <dons> nominolo: so your point is well made. in practice you'd write your key inner loop for your number crunching in C anyway -- its a good notation for this kind of haskell.
13:03:13 <nominolo> > read "077" :: Integer
13:03:14 <lambdabot>  77
13:03:22 <dons> additionally, we have the additional point that you can stay in haskell if that is better
13:03:45 <nominolo> yes, it's good knowing you have a choice
13:03:47 <oerjan> > read "0o77" :: Integer
13:03:49 <lambdabot>  63
13:04:06 <nominolo> oerjan, ah, thanks
13:04:11 <dons> my surprise was that spectral-norm has been one of the hardest nuts to crack
13:04:18 <dons> and it just turned out to be cranking up gcc of all things
13:04:35 <SamB_XP> dons: I'd want to write it in a new kind of C
13:05:51 <nominolo> hm, i'd like to see "C icc" for comparision
13:05:59 <dons> yeah
13:06:01 <dons> icc rocks
13:06:19 <dons> also, i'd like to see ghc with icc as the compiler for comparison :)
13:06:26 <nominolo> the DPH paper had some nice references claiming 4x faster than gcc :)
13:07:45 <SamB_XP> in high-FP code?
13:08:19 <nominolo> hm, don't remember
13:08:19 <chessguy> @pl \f -> l (e g lf f)
13:08:19 <lambdabot> l . e g lf
13:08:42 <phobes_> Has there been any thought of making a C-like Monad that compiles fairly literally to C?
13:09:10 <chessguy> @pl \f -> l (e g (lf f))
13:09:11 <lambdabot> l . e g . lf
13:09:20 <phobes_> I guess you'd really need a theorem prover to get C-efficiency in a safe way
13:09:48 <nominolo> SamB, it was a simple spare matrix mulitplication
13:09:49 <phobes_> You could have unsafeRunCMonad :)
13:10:25 <nominolo> it's likely that the compiler had special detection for the routine and replaced it with a library call
13:10:55 <SamB_XP> was it a common library routine?
13:10:59 <nominolo> the SGI MIPS compiler did this kind of stuff
13:11:04 <Heffalump> phobes_: yes, augustss ha
13:11:04 <Heffalump> s
13:11:08 <Heffalump> see his recent blog post(s)
13:11:28 <Heffalump> oh, well, I think he compiles to assembler, actually. But he tries to mimic C syntax.
13:11:42 <SamB_XP> compiles?
13:11:58 <SamB_XP> I don't remember any compiling...
13:12:09 <nominolo> smvm sm v = [: dotp row v | row <- sm :]
13:12:16 <eric-lavigne> Synaptic claims that hslogger is version 1.0.2, but when I look at installed files for that package I am seeing .../ghc6/lib/hslogger-1.0.1/...
13:12:16 <eric-lavigne> Looks like a mistake in the debian package. I will have to figure out how to install this without debian's help.
13:12:20 <nominolo> so, matrix * vector
13:13:48 <Heffalump> SamB_XP: oh, maybe I misremembered what he does with the results.
13:13:52 <SamB_XP> eric-lavigne: you should probably give the debian maintainer an earful
13:13:58 <Heffalump> I'm sure he could compile them, given Harpy.
13:14:15 <nominolo> i'm pretty sure we can embed a great low-level programming language in haskell
13:14:15 <SamB_XP> I think it's faster not to though ;-P
13:15:35 <eric-lavigne> SamB_XP: I will definitely mention this to the debian maintainer, but will probably still end up needing to install this package on my own.
13:15:36 <SamB_XP> man, augustss's wikipedia article comes up before his blog when I google his name...
13:16:00 <nominolo> SamB_XP, you can generate (safe) C code and then compile it
13:16:10 <SamB_XP> eric-lavigne: sure
13:16:18 <nominolo> and use regions and arrows for security
13:16:38 <nominolo> and lightweight static capabilities where necessary
13:17:48 <SamB_XP> nominolo: I'm seeing that with his current setup you can apparantly just run a program in the ST monad...
13:18:40 <nominolo> I haven't read augustss's post
13:18:56 <nominolo> just saying it should be possible
13:19:08 <SamB_XP> @tell augustss your blog is still doing something that confuses Mozilla into double-spacing the code
13:19:09 <lambdabot> Consider it noted.
13:19:22 <chessguy> so if i do main = interact f, and build the program, i should be able to just do myProgram < someTextFile and see the result of f on each line, shouldn't i?
13:19:22 <SamB_XP> http://augustss.blogspot.com/
13:19:23 <lambdabot> Title: Things that amuse me
13:20:49 <chessguy> @type interact id
13:20:51 <lambdabot> IO ()
13:21:11 <Cale> I think what's worse is how the code bleeds into the side column
13:21:12 <SamB_XP> chessguy: interact runs f on the whole input
13:21:21 <SamB_XP> Cale: side column?
13:21:37 <SamB_XP> oh, that.
13:21:41 <SamB_XP> that's very hard to prevent
13:21:43 <Cale> The column with "About Me", "Links", "Previous Posts", etc.
13:21:45 <chessguy> SamB, huh? i thought it ran f on each line
13:22:04 <Cale> Why is it so hard?
13:22:17 <EvilTerran> ?type interact
13:22:19 <lambdabot> (String -> String) -> IO ()
13:22:19 <SamB_XP> Cale: what would you suggest?
13:22:35 <EvilTerran> chessguy, it runs f on the entirety of STDIN, reading lazily
13:22:43 <chessguy> bah
13:22:50 <Cale> Tables?
13:22:58 <SamB_XP> chessguy: unlines . map f . lines
13:23:18 <EvilTerran> Cale, changing the value of the overflow: css attribute would work, too
13:23:25 <SamB_XP> Cale: well, then you'd have a horizontal scrollbar
13:23:39 <SamB_XP> you'd need to use it to see that bar on the right
13:23:47 <Cale> SamB: only if you'd set a fixed column width
13:24:15 <Cale> Huh? No, there's enough room on that page to see everything. It's just that the margins are freaking huge.
13:24:16 <SamB_XP> Cale: I meant, in the browser window
13:24:26 <SamB_XP> oh, okay, those margins are a bit large
13:24:40 <iguana_> what's the best way to write multi line string literals in code?
13:24:51 <EvilTerran> "foo\
13:24:53 <EvilTerran>     \bar"
13:25:06 <mauke> "foo" ++ "bar"
13:25:10 <iguana_> aahh
13:25:13 <iguana_> you need two backslashes
13:25:18 <EvilTerran> whitespace between backspaces is elided inside strings
13:25:18 <Cale> iguana_: unlines with a list works well too
13:25:30 <EvilTerran> *backslashes
13:25:38 <Cale> (or simply concat, depending on the behaviour you want)
13:25:59 <Cale> String gaps won't insert newlines for you, because the newline always occurs inside the gap.
13:26:12 <EvilTerran> if you want newlines included, Cale's suggestion (a list, and unlines) works better
13:26:17 <iguana_> ok
13:26:28 <EvilTerran> i forget - is a literal newline allowed in haskell strings?
13:26:36 <Cale> I don't think so
13:26:42 <mauke> no
13:26:44 <mauke> which is stupid
13:26:54 <EvilTerran> hmph. somewhat.
13:26:55 <iguana_> it's kind of awkward
13:27:16 <Cale> I think if we were to have multiline strings, I'd want them to follow the layout convention.
13:27:18 <iguana_> +1 for triple quoted strings?
13:27:33 * EvilTerran tends to string-gap with \n\ at the end of each line rather than unlines a list of strings, but that's a matter of preference
13:27:54 <EvilTerran> Hugs and GHC (with the right flag) support heredocs, i think
13:28:36 <SamB_XP> Cale: they couldn't
13:28:48 <SamB_XP> Cale: not precisely
13:28:56 <iguana_> EvilTerran: really?
13:29:01 <SamB_XP> they could do something similar
13:29:05 <EvilTerran> Hugs definitely does
13:29:09 <SamB_XP> and I'd really really really want that
13:29:17 <Cale> Well, you could require the following lines of the string to line up with the first character after the opening quote.
13:29:26 <SamB_XP> it always bothers me that it doesn't work that way in Python
13:29:52 <SamB_XP> Cale: yes, that's the thing I'd want
13:30:13 <Cale> It would also have the advantage that leaving out a quote by accident would still probably produce a syntax error.
13:30:23 <iguana_> so how would you have indentation in the multiline strings?
13:30:26 <Cale> (immediately, and not somewhere at the end of the file)
13:30:34 <EvilTerran> hm. apparently GHC doesn't
13:30:35 <SamB_XP> in Python they have this lame thing where the multiline literals do the obvious stupid thing
13:30:41 <Cale> iguana_: by indenting relative to that line
13:31:30 <nominolo> "foo  \ \n \   bar \ \n \baz" works
13:31:36 <SamB_XP> and pydoc munges docstrings (the biggest usecase of multiline literals) in an attempt to compensate
13:31:44 <nominolo> @losers
13:31:44 <lambdabot> Maximum users seen in #haskell: 407, currently: 383 (94.1%), active: 20 (5.2%)
13:31:50 <SamB_XP> but it is clearly not reliable, since it doesn't know where the literal started
13:32:03 <iguana_> hmm... I can only find http://www.haskell.org/haskellwiki/Poor_man's_here_document
13:32:04 <lambdabot> Title: Poor man's here document - HaskellWiki
13:32:11 <goalieca> stupid question from noob. How to deal with 3-tuples
13:32:14 <SamB_XP> (multi-line string literals in python are tripple quoted)
13:32:43 <pjd> goalieca: (foo,bar,baz) ?
13:32:52 <goalieca> yeah, but take 3rd for eg
13:33:02 <goalieca> snd $ snd tuple doesn't work
13:33:05 <goalieca> that way my only guess
13:33:05 <chessguy> > 34 / 126
13:33:07 <lambdabot>  0.2698412698412698
13:33:21 <mauke> > (\(_, _, x) -> x) (1,2,3)
13:33:21 <chessguy> woohoo, over 25% on my move-generation test suite :)
13:33:22 <lambdabot>  3
13:33:34 <mauke> > (snd . snd) (1,(2,3))
13:33:35 <pjd> goalieca: in general, you use pattern matching, like that
13:33:36 <lambdabot>  3
13:33:48 <goalieca> pjd: so there is no built-in functions
13:33:58 <Cale> http://hpaste.org/2877 -- it would look like that
13:34:00 <pjd> you could define thrd (_,_,x) = x
13:34:03 * SamB_XP wonders what happens if you do a[1,2] in augustss' C-like DSEL
13:34:36 <pjd> there's no builtin, no;  pairs are the common use case
13:34:39 <DRMacIver> SamB_XP: I think it blows up as he originally conceived it. But I noticed something amusing the other day - that is actually valid C.
13:34:48 <iguana_> nobody have a pointer to the hugs heredoc facility?
13:34:50 <blazzy> how long does ghc typically take to build?
13:34:55 <DRMacIver> So there's a perfectly reasonable way of interpreting it. :)
13:34:58 <SamB_XP> DRMacIver: true!
13:35:01 <Cale> blazzy: too long :)
13:35:11 <Cale> blazzy: Are you thinking of hacking on it?
13:35:40 <goalieca> pjd: i think 3d vectors are also quite common though
13:35:41 <Cale> blazzy: Unless you're hacking on it, or you have a really strange platform, it's best not to build it yourself.
13:36:10 <pjd> goalieca: you probably want a more specialized type for them, though
13:36:22 <DRMacIver> SamB_XP: Although I don't think there's a valid interpretation for the expression a[] is there?
13:36:48 <oerjan> http://cvs.haskell.org/Hugs/pages/users_guide/here-documents.html
13:36:50 <SamB_XP> DRMacIver: how about *(a+)
13:37:04 <tehgeekmeister> anyone know of any excellent explanations of the state monad?
13:37:10 <SamB_XP> or, um, *((a)+())
13:37:11 <blazzy> Cale: I'm just curious about how it's implemented. no goals related to actually doing anything with it.
13:37:20 <Cale> blazzy: ah, okay
13:37:48 <piggybox_> blazzy: 2 hours on a 2G cpu box
13:38:12 <Cale> Yeah, it typically takes a few hours
13:38:13 <SamB_XP> blazzy: you won't learn much without trying to hack it, imo
13:38:27 <SamB_XP> not from the compiler sources, anyway
13:38:38 <SamB_XP> the library sources are an entirely different matter ;-)
13:38:39 <DRMacIver> SamB_XP: Hm. I'm not sure what that would mean.
13:38:51 <Cale> What's this I heard about HEAD compiling in 10 minutes on Don's laptop though?
13:39:01 <SamB_XP> DRMacIver: well basically it means "no" ;-)
13:39:16 <Cale> I know he had a fast enough desktop machine to do that...
13:39:18 <DRMacIver> Ah, ok. :)
13:39:24 <SamB_XP> Cale: perhaps dons is compiling it with his GPU
13:39:37 <Lemmih> Cale: Disabling -O2 and -split-objs gives a huge speed-up.
13:39:46 <SamB_XP> ah, yes it would ;-)
13:39:53 <Cale> ah, okay
13:40:10 <SamB_XP> ar(1) is for some reason not used to being showered with millions of .o files
13:40:34 <phobes_> Compiling GHC generates _millions_ of .o files?
13:40:36 <Cale> SamB_XP: Which is strange, since that's basically its job.
13:40:48 <SamB_XP> or is it ld(1) that isn't used to pulling them out again?
13:41:05 <SamB_XP> er, well, whatever.
13:41:13 <SamB_XP> Cale: perhaps hundreds
13:41:21 <SamB_XP> phobes: I might be exaggerating slightly
13:41:25 <phobes>  :)
13:41:31 <nominolo> hm, how hard is it to run ghc on a gpu?
13:41:58 <phobes> just about as hard as running it on your sound card, I'd expect
13:42:07 <SamB_XP> nominolo: lacking the appropriate type of GPU -- heck, I'm just happy that it has enough RAM to work with recent builds of X -- I haven't the slightest idea
13:42:10 <Heffalump> you can't even compile all of C to GPUs, can you?
13:42:10 <olsner> I think ar and ld both are quite ill-suited to doing their jobs quickly
13:42:34 <nominolo> no, but they do some sort of math pretty well
13:42:35 <SamB_XP> olsner: I'd like to see someone re-implement them
13:42:40 <SamB_XP> olsner: with good algorithms
13:42:58 <nominolo> but it'd sure require rewriting large parts of ghc
13:42:58 <Heffalump> nominolo: sure, but that doesn't seem particularly useful for running ghc.
13:42:59 <phobes> Heffalump:  I'd think you can ... for some appropriate value of "can"
13:43:02 <olsner> SamB_XP: me too.. I've been thinking about making a keeping-it-simple linker in haskell
13:43:14 <Heffalump> phobes: I mean "no compiler exists to"
13:43:17 <phobes> Heffalump: right
13:43:21 <phobes> I'm sure that's true
13:43:42 <SamB_XP> Heffalump: I've heard the latest cards have zillions of cores
13:43:43 <blazzy> SamB_XP: well I do expect to be doing some twiddling to figure things out. i suppose that qualifies as hacking? :)
13:44:07 <nominolo> SamB_XP, latest cards have 128 / 256 cores
13:44:13 <nominolo> (nVidea)
13:44:20 <Heffalump> SamB_XP: sure. but that, in itself, isn't useful for GHC.
13:44:25 <phobes> They don't call them cores, right?
13:44:30 <Heffalump> they don't branch well, do they?
13:44:33 <mudge> hello
13:44:36 <Heffalump> well, they're SIMD units, AFAIK
13:44:39 <SamB_XP> Heffalump: not a clue...
13:44:43 <nominolo> i'm not even sure if they can run independently
13:44:47 <Heffalump> right.
13:44:51 <mudge> hey dons
13:44:55 <SamB_XP> though I heard they could run C programs nowadays...
13:45:01 <SamB_XP> could have been bad info though
13:45:10 <phobes> Generally you're running the same shader program on (at least) 2x2 quads of pixels
13:45:11 <Heffalump> are you sure that's not just C running on the main CPU and handing off some work to the CPU?
13:45:15 <Heffalump> s/CPU/GPU/2
13:45:29 <phobes> There are operations that compute on-screen derivatives of things
13:45:34 <nominolo> i could ask around at my university.  they're experimenting with implementing algorithms on gpus using a haskell dsl
13:45:34 <olsner> I guess a good, scalable base would be something like libdb to keep track of symbols and their data (but I still know too little about everything that a linker keeps track of)
13:45:48 <phobes> And they work by differencing neighboring values being computed in the quad
13:46:13 <SamB_XP> olsner: personally I was thinking that it would just be a good idea to use a binary search tree instead of a linear list...
13:46:54 <Heffalump> nominolo: oh, that sounds nice.
13:47:03 <phobes> SamB_XP:  Are you talking about CUDA?
13:47:12 <Heffalump> do they have any publications/drafts/software out there?
13:47:21 <SamB_XP> phobes: this was second-hand info
13:47:31 <nominolo> Heffalump, no.  it's in experimental stage
13:47:32 <SamB_XP> could easily have been bad
13:47:38 <olsner> SamB_XP: yeah, that's basically what I was thinking of using libdb for, but looking at object files and libraries as databases might give you a foot in the door towards easy incremental linking and such
13:47:45 <nominolo> Heffalump, they try to use techniques from Lava
13:48:25 <phobes> nVidia has CUDA - a C-like parallel programming language that targets the GPU
13:48:28 <SamB_XP> nominolo: heck. how about doing a lava backend?
13:48:39 <Heffalump> phobes: right, but I thought that does what I described.
13:48:44 <Heffalump> I don't know that much about it, though
13:49:36 <dons> we've got a ghc project that extracts data-parallel expressions into cuda code, btw
13:49:39 <phobes> The general problem with general purpose programming on GPUs is that GPUs are setup to pull data, not push data
13:49:51 <phobes> CUDA provides some gather capabilities to make that easier
13:49:55 <phobes> (pushing)
13:50:17 <Heffalump> dons: Galois or UNSW?
13:50:22 <dons> unsw
13:50:59 <dons> Sean Lee is doing his phd on the topic
13:52:09 <phobes> I haven't used CUDA, but I'm guessing that algorithms which can't be decomposed into a relatively small number of gather cycles aren't going to fare well on the GPU
13:52:11 <Heffalump> what's the status of DPH in general?
13:52:33 <dons> pretty good. beta?
13:52:42 <nominolo> SamB_XP, i don't know what exactly they're doing.  i was interested in that topic as a MSc thesis, but i they already had a student on it
13:52:44 <dons> its in 6.8, but unannounced/incomplete
13:52:49 <dons> very active though, 2 full time hackers
13:52:54 <dons> + 1 doing gpu dph
13:56:50 <phobes> In DPH, does sumP have different semantics from sum?  or is it just a different implementation?
13:57:39 <phobes> Why are they introducing new operators instead of just providing compiler hints?
13:57:54 <dons> the operators are the compiler hints
13:57:57 <phobes> k
13:58:00 <dons> sumP works on data parallel types
13:58:18 <dons> and the compiler uses that info to combine them with fusion, and then distribute them across cores
13:58:46 <dons> so you program the same way, sumP . foldP g 0 . mapP f
13:58:53 <dons> but that fuses into a parallel array program
13:59:35 <phobes> ya, that'll be neat
14:03:35 <augustss> SamB_XP: a[1,2] can either do what C does (use 2), or be used for multiple indicies
14:03:35 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
14:03:49 <monochrom> I love haskell
14:04:03 <Heffalump> dons: hopefully by 6.10 all the type system bugs will be fixed :-)
14:04:07 <dons> :)
14:04:24 <dons> right, the type system had to be cranked a bit, as did the inliner and specialiser, and -fvectorise is being added
14:04:32 <augustss> By 6.10 there will be some new ones
14:04:52 <dons> dependently indexed type families :)
14:04:52 <SamB_XP> there always are
14:05:06 <SamB_XP> typesystem bugs, I mean
14:05:24 <dons> people are already trying to write HOL in type families. its quite exciting
14:06:06 <phobes> if you can call type level programming exciting ... I prefer to call it grotesque
14:06:29 <augustss> With type families it's getting much nicer
14:06:32 <dons> its currently grotesque. its getting less so.
14:06:40 <dons> and then its more about static checking, and improving your code
14:06:42 <Heffalump> multi-stage programming is nice, and the type system is just another stage. OTOH some of the present hacks are pretty ugly.
14:06:44 <dons> then in giving headaches
14:06:58 <monochrom> then? than? :)
14:07:16 <dons> heh
14:07:39 <monochrom> I completely don't mind programming languages give people headaches for writing buggy code.
14:07:49 <phobes> I don't know why you'd ever want two representations for the number 2
14:08:21 <notsmack> "Haskell is a nonstrict language, and most implementations use lazy evaluation to implement this."
14:08:42 <notsmack> anybody care to elaborate on that distinction?
14:08:46 <dons> phobes: sure! 2 :: Int, 2 :: Double :)
14:08:59 <dons> 2 :: Exp LitInt
14:09:04 <Cale> notsmack: Sure. Nonstrict just specifies what results are meant to be given.
14:09:09 <phobes> nonstrict just means not strict - it's not an evaluation strategy
14:09:10 <Heffalump> notsmack: nonstrict just means that it's possible to write a function where f bottom /= bottom
14:09:15 <Cale> notsmack: Not how you get to those results.
14:09:29 <mauke>  (\x -> x + x) (sqrt 2)
14:09:51 <xerox> s/+/*/
14:09:54 <notsmack> hmm, seems like that implies lazy evaluation to me
14:10:08 <monochrom> listen to mauke's example
14:10:12 <shachaf> xerox: s/\+/\\+/ :-)
14:10:18 <phobes> call-by-name is the original not-strict implementation
14:10:23 <Cale> Actually, I think it means a little more in Haskell's case -- you don't simply want not-strict, but you want to ensure that if there is an evaluation order which terminates, that the evaluation order you choose terminates as well.
14:10:46 <phobes> in that implementation you'd evaluate the argument each time it's needed.  Lazy implies you evaluate the argument only once, the first time it's needed
14:11:11 <xerox> shachaf: are you regexping my regexps?! ;)
14:11:19 <Cale> Shall I do my standard strict/normal-order/lazy evaluation example?
14:11:19 <notsmack> phobes: ah!  that's very helpful, thanks.
14:11:23 <shachaf> xerox: Why not?
14:11:25 <notsmack> Cale: yes, please!
14:11:31 <Cale> Let's define double x = x + x
14:11:41 <Cale> Under strict evaluation, we have:
14:11:46 <Cale> double (double 5)
14:11:48 <phobes> Cale:  Ya, you're right - it doesn't just mean not-strict :)
14:11:53 <Cale> -> double (5 + 5)
14:11:57 <Cale> -> double 10
14:12:02 <Cale> -> 10 + 10
14:12:03 <Cale> -> 20
14:12:16 <Cale> Strict evaluation is innermost (leftmost) first.
14:12:35 <Cale> Under outermost first evaluation, we have:
14:12:41 <Cale> double (double 5)
14:12:48 <Cale> -> double 5 + double 5
14:12:49 <notsmack> double 5 + double 5?
14:12:56 <Cale> -> (5 + 5) + double 5
14:13:00 <Cale> -> 10 + double 5
14:13:04 <Cale> -> 10 + (5 + 5)
14:13:09 <Cale> -> 10 + 10
14:13:10 <Cale> -> 20
14:13:29 <Cale> However, that took more steps, because we computed double 5 twice.
14:13:38 <notsmack> yep
14:13:40 <monochrom> Here is an unorthodox implementation of non-strict. Fork off threads to try all possible evaluation orders. Adopt the answer given by the first thread that finishes. Optionally, kill off the other threads. Optionally, unroll what other threads have done to the heap.
14:14:20 <Cale> So lazy evaluation makes up for this somewhat by doing outermost first evaluation, but when a parameter to a function shows up multiple times in the body, it shares the results between the copies.
14:14:27 <Cale> and that's all lazy evaluation is
14:14:32 <Cale> So in this example...
14:14:36 <Cale> double (double 5)
14:14:43 <Cale> = let x = double 5 in x + x
14:14:55 <Cale> = let x = 5 + 5 in x + x
14:15:00 <Cale> = let x = 10 in x + x
14:15:02 <Cale> = 20
14:15:16 <Cale> and we're back down to the same number of steps as the strict case.
14:15:18 <tehgeekmeister> what's a simple, concrete example of a use of the state monad?  (even if it's contrived)
14:15:20 <notsmack> i see.  that's a distinction that never clicked before, thanks.
14:15:49 <notsmack> tehgeekmeister: a common one is to just have an Int representing a counter stored as the state
14:15:56 <Cale> tehgeekmeister: how about relabelling a tree with the numbers from 1 up to the number of labels.
14:16:20 <mauke> > flip runState 2 $ do modify succ; modify succ; modify succ; return "butter"
14:16:22 <lambdabot>  ("butter",5)
14:16:31 <Cale> tehgeekmeister: That is, take the type  data Tree a = Leaf | Branch (Tree a) a (Tree a)
14:16:43 <Cale> and write a function  relabel :: Tree a -> Tree Integer
14:17:16 <Cale> such that the inorder traversal of the result of relabel will always be [1..n] for n being the number of Branch nodes of the tree.
14:17:32 <Cale> and such that the overall structure of the tree is unchanged
14:17:46 <Cale> Try that without the State monad first :)
14:18:06 <Cale> With the state monad, it becomes much simpler.
14:18:16 <monochrom> One of the earliest example for the state monad.
14:18:19 <tehgeekmeister> Cale: first i'd have to understand the problem.
14:18:22 <Cale> okay
14:18:37 <tehgeekmeister> ?src modify
14:18:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:19:00 <tehgeekmeister> that hasn't worked once today.
14:19:00 <notsmack> Cale: simple for /normal/ people ;-)
14:19:13 <xerox> > let compose = execState . mapM modify in compose [(*2),(subtract 1),(^3),(+10)] 42
14:19:15 <lambdabot>  571797
14:19:37 <mauke> tehgeekmeister: modify f = do { x <- get; put (f x) }
14:19:54 <tehgeekmeister> mauke: thanks
14:20:13 <xerox> that was for the contrived one
14:20:18 <tehgeekmeister> problem is, i don't understand >>= in the context of the state monad -- that definition confuses me like nothing else.
14:20:40 <mauke> then ignore it
14:20:53 <tehgeekmeister> okay, what should i expect it to do, then?
14:21:17 <Cale> tehgeekmeister: Okay, so for example,  relabel (Branch (Branch Leaf "hello" Leaf) "there" (Branch Leaf "world" Leaf))  will become  Branch (Branch Leaf 1 Leaf) 2 (Branch Leaf 3 Leaf)
14:21:45 <shachaf> > let compose = foldl (flip (.)) id in compose [(*2),(subtract 1),(^3),(+10)] 42
14:21:46 <lambdabot>  571797
14:21:51 <mauke> State gives you a single implicit global variable
14:22:07 <Cale> tehgeekmeister: x >>= f will run the computation x (which might read and write the state), then pass its result to f to get a further computation to run, and run that as well.
14:22:10 <mauke> you can access this variable with get/put/modify
14:22:16 <xerox> tehgeekmeister: you're given a computation of type 'State s a' which returns a value of type 'a' using a state of type 's', along with a function from 'a' to computations of type 'State s b' (same state type), and you are required to make a 'State s b' with those two ingredients, there aren't many ways to do that.
14:22:51 <SamB_XP> hmm. it seems that Shader Model 3.0 allows shaders to branch, at least...
14:22:55 <Cale> xerox: there are enough that it's possible to screw it up :)
14:24:12 <Cale> But yeah, there's only one way which reflects the idea that changes to the state are passed forward to the computations on the right side of the >>=
14:24:16 <mauke> sqrt y = do { x <- get; put $ (x + y / x) / 2; return x }  -- actually computes square roots if you don't use the standard State
14:24:32 <mauke> (this one uses backwards state passing)
14:24:50 <Cale> mauke: don't you also need a termination condition?
14:25:04 <mauke> no, I just use time travel
14:25:08 <xerox> how does the backward state passing monad look like?
14:25:42 <Cale> Well, let's take a close look at >>= in the ordinary state monad, and then see how it would go :)
14:25:44 <mauke> actually, the latest version is mysqrt num = do { p <- newPVar 1;  r <- readPVar p; writePVar p ((r + num / r) / 2); return r }
14:25:52 <Cale> We have:
14:26:15 <Cale> newtype State s a = State { runState :: s -> (s,a) }
14:26:51 <mauke> why doesn't hpaste announce my pastes?
14:26:59 <Cale> So I said that the first thing x >>= f will do is to run x.
14:27:01 <Cale> So:
14:27:12 <mauke> xerox: http://hpaste.org/2878
14:27:23 <xerox> thanks.
14:27:34 <phobes> SamB:  Branching is supported, but as of the 7800 generation (last gen) it's very painful - if it's discovered that different branches are taken, then shaders that went down a different path have their results thrown away and are rerun
14:27:36 <Cale> x >>= f = State (\s -> let (s',v) = runState x s in ...)
14:28:01 <SamB_XP> phobes: wierd!
14:28:07 <Cale> That is, we run x with the initial state, and get a new state s' along with a result value v
14:28:29 <phobes> SamB: For small branches, you're often better of implementing 'branching' yourself by computing both results and then combining them with linear interpolation (either 0 or 1)
14:28:37 <dons> Tomas Caithaml is asking on -cafe about what math classes would help him best get a grips with prog lang theory
14:28:40 <Cale> then we run (f v) with the initial state being the new state after running x
14:28:57 <dons> any suggestions beyond lambda calc and category theory?
14:29:05 <Cale> x >>= f = State (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w))
14:29:10 <Taejo> @pl find a e = fst $ head $ elems a $ filter (== e). snd
14:29:10 <lambdabot> find = ((fst . head) .) . (. ((. snd) . filter . (==))) . elems
14:29:12 <dons> there's a lot of things from theorem proving that are useful, but maybe they're not taught in math classes.
14:29:24 <Cale> tehgeekmeister: does that make sense?
14:29:57 <Cale> xerox: So to thread the state backwards, we just hook up the s's backwards :)
14:29:58 <phobes> dons:  logic
14:30:13 <mauke> Cale: but that doesn't work for numbers
14:30:43 <eric-lavigne> I was nervous about installing from source with an unfamiliar language and build system, but cabal has been surprisingly gentle so far.
14:31:33 <monochrom> math classes never teach theorem proving. they require you to do it, but they don't teach how to do it.
14:31:49 <phobes> monochrom:  doing it is how you learn to do it :)
14:31:59 <tehgeekmeister> Cale: i'm catching up, that's a different definition of >>= than i've seen before for the state monad
14:32:03 <Cale> monochrom: My classical algebra course had lots of good hints on how to prove things mixed in.
14:32:26 <monochrom> Yes, a few exceptional teachers recognize the omission and make up for it.
14:32:31 <Cale> tehgeekmeister: It should be effectively the same -- I wrote it that way because I think it reads better like that
14:32:43 <tehgeekmeister> Cale: i think so too, so far.
14:32:58 <Cale> monochrom: Overall, working in groups on assignments in first year taught me quite a lot :)
14:33:15 <dons> and logic gets taught in CS
14:33:27 <Cale> Also, the TA's tended to give good advice in the form of notes written on handed-back assignments.
14:33:47 <Cale> dons: Heh, the first logic course I took was in 4th year.
14:34:11 <phobes> dons:  CS logic is typically a joke
14:34:28 <phobes> at the undergrad level at not elite schools anyway
14:34:47 <phobes> It's just DeMorgan's law and such
14:34:50 <Cale> PMath 432 Mathematical Logic
14:34:57 <Cale> It was basically a course on model theory.
14:34:59 <phobes> Cale: Yes, that's what I'm talking about
14:35:18 <phobes> Model theory, completeness / incompleteness theorems, etc
14:35:25 <dons> phobes: oh, i guess i got spoilt doing types / programming language/ theorem proving/ logic
14:35:28 <dons> in CS.
14:36:05 <phobes> dons:  Also I'm speaking of In-the-states schools... don't really know about elsewhere
14:36:16 <Cale> There isn't really all that much to just using logic.
14:36:16 <Saizan> ?where cabal manual
14:36:17 <lambdabot> http://www.haskell.org/cabal
14:36:27 <monochrom> It is not a joke. Most people haven't noticed such basic things as de Morgan, contraposition, etc. They seriously need to be told. You call it a joke because you're smart, you don't need to be told.
14:36:30 <Cale> Not enough to warrant a full course on it.
14:36:40 <dons> phobes: ah ok. but certainly at places like CMU you'd get a decent grounding
14:36:45 <Cale> If your other courses are good enough :)
14:37:31 <Cale> You just have to make sure that the early courses are careful to instil the basic rules and techniques.
14:37:32 <tehgeekmeister> so where do these states come from?  it doesn't seem they're ever used in any of these computations
14:37:35 <phobes> monochrom:  ok... maybe it's not a joke :)
14:37:39 <tehgeekmeister> or ever defined anywhere
14:37:53 <Cale> tehgeekmeister: What do you mean by not used?
14:38:00 <Cale> runState uses s
14:38:22 <Cale> okay, I suppose you're just seeing them threaded along
14:38:25 <EvilTerran> comlab.ox.ac.uk do propositional, predicate, and some temporal logic in the second term of the first year of their CS degrees
14:38:27 <tehgeekmeister> it does?  that's news to me.  i've not been able to find out what runstate does yet.
14:38:35 <EvilTerran> @src runState
14:38:36 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:38:43 <mauke> return and >>= do state plumbing
14:38:51 <mauke> runState supplies an initial value for the state
14:38:52 <Cale> All that runState does is unpack the function of type s -> (s,a) from the State s a value
14:39:02 <EvilTerran> (including such things as De Morgan, but also more interesting things such as natural deduction)
14:39:05 <Cale> So if x :: State s a
14:39:11 <nominolo> tehgeekmeister, state is simulated by functions that take a current state and return a new state and a result
14:39:14 <Cale> then runState x :: s -> (s,a)
14:39:15 <phobes> dons:  I'd still be surprised to find model theory in the CS department somewhere ... though it's quite possibly there
14:39:29 <Cale> and if s :: s
14:39:33 <nominolo> tehgeekmeister, >>= just composes those functions, ie, creates a new function
14:39:45 <Cale> then runState x s :: (s,a) -- a final state and result value
14:39:46 <nominolo> runState just calls this function
14:40:18 <Cale> Yes, I suppose it's important to explain exactly how it is that we're modelling state :)
14:40:20 <xerox> Cale: and then is MonadState equivalent to MonadBState?
14:40:34 <nominolo> tehgeekmeister, so, when you have a monad, running it gets you out of the monad (but only gives you the final result of running it)
14:40:37 <Cale> xerox: yeah -- the operations are the same
14:40:41 <tehgeekmeister> so >>= is essentially composition for functions that take a state as an input, and produce a state and a value as an output, in a two tuple
14:40:45 <Cale> xerox: the only difference is how you define >>=
14:40:57 <nominolo> tehgeekmeister, yup
14:41:03 <Cale> actually, it's almost more like application
14:41:15 <nominolo> tehgeekmeister, try reading the "you could have invented monads yourself" blogpost
14:41:22 * FMota hereby declares that 'flip cons nil' be an expression that denotes shock (where cons = (:) and nil = []).
14:42:03 <idnar> > flip (:) []
14:42:04 <lambdabot>  Add a type signature
14:42:10 <Cale> tehgeekmeister: I think your complaint has to do with the fact that we haven't actually looked at any examples of values of type (State s a)
14:42:16 <idnar> heh
14:42:26 <nominolo> > let (<>) = flip (:) in [] <> 3 <> 4 <> 5
14:42:28 <lambdabot>  [5,4,3]
14:42:29 <Cale> tehgeekmeister: It's those things which actually do something with the states
14:42:37 <Cale> tehgeekmeister: >>= only glues them together
14:43:20 <Cale> Actually, do you properly understand the code for bind, or would you like to try something simpler? I find it's often useful to look at (>>) first.
14:43:20 <FMota> btw, flip cons nil =  :[]
14:43:38 <dons> ?users
14:43:38 <tehgeekmeister> sorry, distraction over here
14:43:38 <lambdabot> Maximum users seen in #haskell: 407, currently: 373 (91.6%), active: 23 (6.2%)
14:43:41 <tehgeekmeister> let me catch up again
14:44:51 <tehgeekmeister> gawsh, i'd forgotten about >> entirely!
14:45:04 <tehgeekmeister> hadn't seen it in the monad tutorial i'm on for so long
14:45:12 <mauke> >> is just >>= with alzheimer's
14:45:21 <Cale> I think it's simpler at first to look at that
14:45:22 <FMota> what's >> called again?
14:45:26 <Cale> 'then'
14:45:35 <FMota> oh, ok
14:45:41 <Botje> 'programmable semi-colon'
14:45:46 <monochrom> @remember mauke >> is just >>= with alzheimer's
14:45:46 <lambdabot> Done.
14:45:47 <FMota> lol
14:45:49 <monochrom> hehehe
14:46:07 <Cale> If x and y are state computations, then x >> y is the computation which runs x, throws away the result, but chains along the state, and runs y
14:46:15 <Cale> In code, that is:
14:46:23 <monochrom> I miss dons's Haskell Quarterly News! :)
14:46:49 <Cale> x >> y = State (\s -> let (s',v) = runState x s in runState y s')
14:46:55 <dons> i am attempting to prepare an article today monochrom :)
14:47:04 <dons> see the flood of updates to haskell wiki's blog section for clues..
14:47:51 <Cale> tehgeekmeister: make sense? It's the state computation which takes an initial state, runs x with that to get a new state, and then runs y with that new state, returning the final state and result of y
14:48:27 <tehgeekmeister> i get >>
14:48:30 <Cale> okay
14:48:53 <Cale> The thing which should be slightly painful about the definition of (>>) is that v is just thrown away.
14:49:06 <Cale> (but this is by design)
14:49:25 <Cale> Suppose we wanted to actually use v for something?
14:49:38 <tehgeekmeister> right
14:49:43 <tehgeekmeister> then bind comes in handy
14:49:47 <Cale> One thing we could do is to make y into a function which would take that v as a parameter
14:49:54 <Cale> and that's where >>= comes from here
14:50:39 * tehgeekmeister rereads bind
14:50:46 <Cale> So >> just chains computations end-to-end, and >>= gives you control over what the next computation is, based on the result of the previous one.
14:51:14 <Cale> x >>= y = State (\s -> let (s',v) = runState x s in runState (y v) s')
14:51:23 <Cale> if you'd like :)
14:51:56 <Cale> we just add an = to the end of >>, and stick v in as a parameter to y in the second runState
14:52:14 <Cale> x >> y = State (\s -> let (s',v) = runState x s in runState y s')
14:52:16 <Cale> x >>= y = State (\s -> let (s',v) = runState x s in runState (y v) s')
14:52:58 <dons> i'd really like a reduction plugin for expression fragments
14:53:19 <sorear> me too
14:53:36 <dons> we'll have to solve this lambdabot issue for the longer term
14:53:43 <dons> lambdabot is too gunky for me to want to improve now
14:53:54 <dons> we should consider it prototype 1.
14:54:05 <dons> now that we've identified what kind of IDE support a bot should provide
14:54:13 <omniscientIdiot> in (>>=), y :: a -> m b, so you give it the 'a' returned from runState x to get a new action, and run it, threading through the updated state.
14:54:27 <dons> and just start over with type,kind,lookup,packages,docs,and general term and type rewriting
14:54:30 <xerox> maybe at the hackaton we can hack together lambdabot phase 2
14:54:38 <dons> xerox: oh, that's a _nice_ idea
14:54:43 <Cale> Yeah, that's going the other direction, starting with the type and working down.
14:54:46 <dons> we can get a simple bot going for the hackathon channel
14:55:02 <xerox> !
14:55:22 <dons> a clean module interface, a solid concurrency foundation
14:55:29 <edwardk> @paste
14:55:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:55:32 <dons> sorear: what do you think: we should just consider lambdabot done for now?
14:55:58 * dons makes notes for lambdabot2 design
14:56:07 <ddarius> Completely rewrite the insides of lambdabot, sounds like fun.
14:56:14 <omniscientIdiot> lambdabot2?!  :O!
14:56:16 <monochrom> "betabot" does beta reduction :)
14:56:16 <dons> the insides are small, and old fashioned.
14:56:28 <xerox> we need MMOCTE like MMORPG, Massive Multiplayer Online Concurrent Text Editing
14:56:40 <phobes> you should make lambdabot appear as a paperclip in Yi
14:56:48 * omniscientIdiot shoots phobes
14:56:52 <xerox> hahaha
14:58:18 <tehgeekmeister> ?src get
14:58:18 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:58:21 <sorear> why do we want concurrency in lambdabot2?
14:58:24 <mauke> "it looks like you're trying to compute primes in the type system"
14:58:44 <sorear> not freezing when people as questions is good, but not randomly crashing is better
14:58:55 <monochrom> haha mauke
14:59:02 <sorear> that's EASY
14:59:24 <dons> http://haskell.org/haskellwiki/Lambdabot#.40version
14:59:25 <lambdabot> Title: Lambdabot - HaskellWiki
14:59:29 <dons> notes for lambdabot 2
14:59:36 <Cale> tehgeekmeister: get = State (\s -> (s,s))
14:59:37 <omniscientIdiot> get = State (\s -> (s, s)) -- the state is returned to the value portion of the result
14:59:58 <Cale> put x = State (\s -> (x,()))
15:00:00 <dons> sorear: i'd prefer responsive + multicore friendly + reliable
15:00:12 <dons> which means design, rather than hack
15:00:16 <omniscientIdiot> @type runState
15:00:19 <lambdabot> forall s a. State s a -> s -> (a, s)
15:00:35 <omniscientIdiot> cale: that should be ((), x) I think
15:00:38 <Cale> omniscientIdiot: Not the runState which I'm using
15:00:42 <monochrom> I don't like hacking either. I prefer specifying and design.
15:00:55 <dons> lambdabot should be considered the prototype
15:00:56 <omniscientIdiot> okay
15:01:02 <monochrom> The next Hackathon should be renamed the Specathon.
15:01:06 <dons> since we didn't even know IDE features would actually be the killer applicaiton
15:01:12 <Cale> I prefer putting the return value second, it's more natural. That's a small flaw in the MTL.
15:01:47 <ddarius> hacking lambdabot has been a #haskell tradition for over five years!
15:01:51 <omniscientIdiot> well, I would go so far as a "flaw", since it technically doesn't matter.
15:01:57 <Cale> The reason why is that (,) s is a Functor
15:01:58 <dons> indeed!
15:02:13 <omniscientIdiot> Cale: good point
15:02:15 <dons> http://www.cse.unsw.edu.au/~dons/images/commits/lambdabot-commits.png
15:02:17 <lambdabot> http://tinyurl.com/ylvpv7
15:02:40 <dons> at the start we didn't know how to do irc in haskell at all :)
15:02:46 <dons> by the end, we know too much
15:03:06 <ddarius> dons: This is where you steal Simon's graph.
15:03:48 <dons> oh, the 'what's the big deal?' one?
15:03:59 <ddarius> Yes.
15:04:06 <dons> how do we do it? despair? hack hack hack! what was the big deal :)
15:04:09 <dons> that's lambdabot too.
15:04:16 <xerox> hehe, indeed.
15:04:34 <Cale> Heh, and then another little portion where you have "Time for a rewrite!"
15:04:49 <dons> really, its the ide core that is the key IP for lambdabot
15:04:56 <dons> and then the irc frontend is just one of many frontends
15:05:02 <dons> we'd actually like to support ghci and the web better
15:05:20 <dons> and better editor integration
15:05:59 <ddarius> "Why do I need to install an IRC bot to use HIDE 3.7?"
15:06:45 <dons> oh, btw, people were asking about what i was doing at galois now. what projects, and i wasn't sure what i could talk about. but apparently we have a public page about the projects, http://galois.com/xdomain_projects.php
15:06:47 <lambdabot> Title: Cross Domain Technology Services
15:06:56 <dons> this is the non-crypto, non-compiler haskell stuff at galois.
15:07:31 <dons> nicely atypical haskell, i'd say
15:07:53 <ddarius> A window manager isn't atypical Haskell?
15:07:58 <dons> that's atypical too :)
15:08:59 <dons> i note the 'people' page on galois isn't updated though. half the new employees are missing
15:09:35 <tehgeekmeister>                                                                                                                                                                                                                                                                                                                                                                                                                                              
15:10:00 <tehgeekmeister> errr.  oops.
15:10:59 <augustss> I see Galois is looking for an FPGA engineer
15:11:27 <dons> yeah, they just hired one guy, but they're looking for more.
15:11:43 <ddarius> That sounds interesting.
15:12:40 <augustss> I bet it's for Cryptol
15:13:17 <augustss> I must say that the Galois web pages are refreshingly open for a company that does a lot of work for government agencies.
15:13:26 <dons> yeah, i'm surprised actually
15:13:41 <dons> i thought things i was doing were secretive, till i noticed the web page :)
15:14:06 <dons> lots of interesting things you can do once you can map fp techniques to hardware
15:14:21 <dons> high assurance irc on a chip? :)
15:14:22 <augustss> absolutly
15:14:30 <ddarius> Just what we need . . .
15:14:41 <dons> lambdabot on a chip!
15:14:58 <monochrom> ghc on a chip
15:15:00 <nornagon> how much are fpgas these days?
15:15:08 <phobes> $10,000?
15:15:21 <nornagon> pretty sure you can get them cheaper than that.
15:15:26 <augustss> depends on what you want
15:15:35 <Nafai> dons: Sounds like your company is very similar to mine, doing SBIR work, etc
15:15:35 <monochrom> I would like to implant a "ghc on a chip" in my brain. My Haskell-fu will be amplified ten-fold.
15:15:39 <augustss> You can get a nice little board for $100
15:15:42 <Nafai> dons: Except we use Java
15:15:43 <Taejo> Sounds like a job for... SHard... scheme-to-fpga compiler
15:16:12 <phobes> augustss:  What does that nice little board do?
15:16:17 <dons> Nafai: oh, cool. well, not for you  and Java ;)
15:16:29 <ddarius> monochrom: But those "my brain exploded" error messages will take an alarming and messy turn for the worse.
15:16:42 <augustss> phobes: whatever you want.  it has 1M gate
15:16:45 <augustss> sorry, $200
15:16:49 <monochrom> haha
15:17:02 <augustss> http://www.xess.com/
15:17:03 <lambdabot> Title: XESS homepage announcements
15:17:28 <Nafai> dons: Nice to know that the government isn't demanding Java as my superiors make it seem
15:17:38 <augustss> I have one of those, but I've not played with it because the parallel port for programming it only works with windows :(
15:17:59 <nornagon> http://www.knjn.com/ShopBoards_USB2.html
15:18:02 <lambdabot> Title: KNJN.com - Shop - Development boards (USB-2)
15:18:04 <nornagon> $90
15:18:16 <augustss> phobes: the $200 card has a PS2 connector and a VGA connector
15:18:26 <matthew-_> ok, so let's assume I'm either using the bzip2 or gnuzip bindings from hackage that work on lazy bytestrings. I the uncompressed result as a Ptr because I have to ship it across to the graphics card via opengl. So, how would you suggest getting from ByteString to Ptr GLfloat without eating tonnes of memory?
15:18:51 <phobes> Ya, I don't have much FPGA experience... I'm just trying to figure out what's the difference between these and the $10,000 board I was recently working with
15:19:01 <matthew-_> mmm. I think I missed out "need" in there somewhere...
15:19:06 <augustss> phobes: size and speed of the FPGAs
15:19:15 <phobes> augustss:  ah ok
15:19:48 <xerox> http://www.picocomputing.com/products/cards.php these are very interesting.
15:19:49 <lambdabot> Title: Pico Computing, Inc - Products
15:20:01 <augustss> phobes: but 1M gates is plenty for e.g. doing your own CPU, DRAM controller, VGA controller, PS2 controller
15:20:09 <dons> matthew-_: you can get the Ptr out of a strict ByteString in O(1)
15:20:20 <dons> for a lazy one, you'll need to concat the chunks (i.e. copy)
15:20:24 <augustss> Niklas Rjemo did that on a board with 100k gates
15:20:44 <dons> matthew-_: so: toForeingPtr . concat . fromChunks . compress
15:20:57 <phobes> augustss:  Ya, that's neat.  If I had time for it, that'd make a fun project
15:21:25 <Liskni_si> @type toForeingPtr
15:21:27 <lambdabot> Not in scope: `toForeingPtr'
15:21:39 <dons> :hoogle toForeign
15:21:46 <dons> ?hoogle toForeign
15:21:46 <lambdabot> No matches found
15:21:54 <dons> :t Data.ByteString.Base.toForeignPtr
15:21:56 <lambdabot> Data.ByteString.Base.ByteString -> (GHC.ForeignPtr.ForeignPtr Word8, Int, Int)
15:21:57 <augustss> phobes: I demoed a pong game on one of those cards at a Haskell Workshop a few years ago.  written in Bluespec
15:22:18 <Liskni_si> i c, thx.
15:23:16 <matthew-_> dons: ok, I've never quite been clear whether it's safe to use the stuff in Base
15:23:22 <matthew-_> (err, BS.Base)
15:23:52 <phobes> augustss:  I haven't looked at Bluespec... is it much better than Verilog?
15:24:35 <dons> matthew-_: its generally unsafe in the sense that calling into C is unsafe
15:24:53 <phobes> afk
15:25:13 <mudge> dons: it was fun posting stuff to reddit programming today,   I finally got some karma
15:25:42 <dons> mudge: :)
15:26:05 <dons> mudge: btw, we were pondering your do /sequence post here last night
15:26:37 <mudge> dons: woa,  that's cool,    what did you guys think?
15:27:01 <dons> and that, twoChar = do v1 <- item ; v2 <- item ; return (v1:v2:[]) can be simplified in fun ways
15:27:19 <dons> firstly, the names says 'two' , so the type should reflect that, and instead return a tuple
15:27:26 <dons>    twoChar = do v1 <- item ; v2 <- item ; return (v1,v2)
15:27:30 <augustss> phobes: Bluespec is incredibly much better.  But the version of Bluespec that looks like Haskell is no longer officially supported.
15:27:40 <dons> then we can play some fun games
15:27:48 <dons> twoChar = liftM2 (,) item item
15:28:05 <dons> and then we have Arrows for nice IO/tuple glue
15:28:15 <dons> and the reader monad for duplicating arguments
15:28:25 <dons> so someone suggested twoChar = join (&&&) item
15:28:39 <dons> however, i didn't check that we had an Arrow  IO instance (pretty sure we don't) so it would be a variant of that
15:29:24 <omniscientIdiot> I don't understand, IO isn't kinded to be an Arrow
15:29:42 <mudge> dons: cool, great stuff
15:29:50 <dons> however, better check the types match.
15:29:57 <dons> there's also the Applicative approach
15:30:11 <mudge> dons: I like the idea of returning a tuple
15:30:15 <dons> which goes something like,   (,) <$> item <*> item
15:30:30 <dons> oh yeah, that's the first  thing you'd do: state in the type that two Chars are returned only
15:31:31 <omniscientIdiot> what's the url for this post?
15:31:45 <mudge> http://nickmudge.info/?post=56
15:31:45 <dons> oh, nick's is here, http://nickmudge.info/?post=56
15:31:46 <lambdabot> Title: Do Notation and Sequence Operator
15:31:46 <lambdabot> Title: Do Notation and Sequence Operator
15:31:53 <dons> there's some nice ways to golf it though
15:32:20 <SamB_XP> lambdabot's stereo technique needs work
15:32:37 <dons> using monadic stuff to lift out the do syntax, then arrow glue to hide  the tupling, and Reader to hide the duplicating of `item'. or Applicatives to instead hide the syntax
15:33:34 <omniscientIdiot> well, it's not terribly monad-magicky, it's just simple spot-the-pattern-and-replace-with-function
15:33:36 <dons> just some ideas to play around with, mudge
15:33:37 <omniscientIdiot> @src liftM2
15:33:37 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:33:43 <dons> omniscientIdiot: zactly.
15:34:08 <dons> little haskell puzzles
15:34:09 <mudge> dons: cool, thanks
15:34:27 <dons> you know the type, you have a bunch of combinators of various types, which you must combine to get the shortest result
15:35:24 <augustss> because shortest is always best? :)
15:35:48 <dons> shortest is always more fun :)
15:36:35 <dons> this is our `golf' culture. perl guys shrink for line noise, using their wacky dynamic casting and magic coercions. we have a bunch of jigsaw puzzle based types, which we join up :)
15:36:46 <augustss> speaking of short, I saw some terrible code fragments in your book ;)
15:37:08 <augustss> not short
15:37:21 <dons> augustss: well, there's 3 of us :) but thanks for all the feedback!
15:37:33 <monochrom> I have a hunch that shorter is better.
15:37:38 <dons> i've yet to get into the writing seriously, due to the move, but hopefully will do so soon
15:37:44 <augustss> But on the whole, the book looks great
15:38:02 <mudge> when's it going to be published?
15:38:12 <Taejo> dons, excuse my noobness, but what is your book?
15:38:19 <mudge> dons: you know if it is going to be on the web like Practical Common Lisp or something?
15:38:25 <ddarius> @where realworldhaskell
15:38:25 <lambdabot> http://www.realworldhaskell.org/
15:38:26 <dons> next year some time. the alpha drafts of early chapters are going up now to early-adopter reviewers
15:38:34 <dons> mudge: see ^^
15:39:26 <dons> augustss: i'm pretty confident with 3 authors editing heavily, and then the 10 or so core reviewers sweeping over the text, we'll get a very tight result that satisfies most people
15:39:45 <augustss> dons: I'm sure you will
15:40:03 <dons> wouter's also helping out a lot. he had lots of very useful comments
15:40:05 <ddarius> dons: I was/am pretty confident just from the author roll.
15:41:07 <dons> ddarius: its interesting: the authors aren't old school haskellers really (of the SPJ of augustss flavour), and i'm the most `academic' guy on the team. so it will be interesting to see how that influences the result. we're second generation haskellers :)
15:41:22 <dons> the most important thing i suspect will be the hard headed revierwers like augustss helping out :)
15:41:29 <tehgeekmeister> another noobish question: in the state monad, how is this state just being maintained, i see (specifically in this http://www.haskell.org/all_about_monads/examples/example15.hs code) a call to get before i see any reason for there to be any state in the state monad yet.  so how does the state get initialized and where does it stay, being that there's no variables of the imperative sort in haskell.
15:42:21 <omniscientIdiot> tehgeekmeister: get is a State action.  State actions are wrapped functions.  The actual state to be 'got' is provided later, when the action is run.
15:42:24 <dons> it says something for haskell that 3 guys like john, bos and i could be writing a book about it. its indicative of some kind of phase transition in the language and community
15:42:26 <augustss> dons: are you going to have a chapter with hints on how to write good Haskell.  I mean more general, like indentation, export lists, import lists, blah, blah?
15:42:30 <sorear> tehgeekmeister: it's not state, it's a free variable!
15:42:46 <sorear> tehgeekmeister: do you understand higher order functions?
15:42:53 <dons> augustss: mm. yes, i think there's style stuff penciled in to be sprinkled through the text
15:42:59 <tehgeekmeister> sorear: kinda sorta.
15:43:00 <dons> but i may write more concretely on that
15:43:11 <tehgeekmeister> sorear: i understand some specific ones, and other ones confuse me.
15:43:32 <tehgeekmeister> omniscientIdiot: gah!  is this what i've read about monads borrowing from the future?
15:43:47 <tehgeekmeister> my imperative programming sensibilities are not liking this.
15:43:50 <omniscientIdiot> tehgeekmeister: nothing of the sort!
15:44:01 <omniscientIdiot> @type State
15:44:02 <lambdabot> forall s a. (s -> (a, s)) -> State s a
15:44:08 <Taejo> omniscientIdiot, you didn't see the function I posted earlier
15:44:25 <omniscientIdiot> Taejo: no, what was it?
15:44:50 <mudge> dons: I met bos
15:45:01 <dons> oh cool. i've not met him yet :)
15:45:28 <Taejo> omniscientIdiot, I can't remember... found it somewhere... it output what you input, before you input
15:45:28 <mudge> dons: oh,   i met him at the functional meeting in San Fran
15:45:45 <mudge> he's really cool
15:45:57 <ddarius> tehgeekmeister: No.  What the monadic action describes is not some code updating state, but a state transformation that, when given an initial state, will transform it.
15:46:53 <tehgeekmeister> ddarius: right, and i understand that.  i don't get the meaning of the initial gets here http://www.haskell.org/all_about_monads/examples/example15.hs in getAny and getOne.
15:47:15 <tehgeekmeister> oh!
15:47:20 <SamB_XP> tehgeekmeister: the borrowing-from-the-future thing is done with mfix
15:47:24 <mauke> tehgeekmeister: getAny is a state transformer
15:47:50 <sorear> tehgeekmeister: imagine that you had a pure language without monads
15:47:58 <tehgeekmeister> okay
15:47:59 <augustss> SamB_XP: you don't need mfix to borrow from the future.  You can use a state monad where the state flows backwards
15:48:08 <SamB_XP> augustss: sure.
15:48:10 <sorear> tehgeekmeister: so if you want to add up a bunch of numbers, you use an accumulating programmer
15:48:14 <sorear> *parameter
15:48:20 <mudge> geez,  the realworldhaskell  book got 400 comments from the early reviewers
15:48:34 * tehgeekmeister can't wait for that book
15:48:37 <sorear> tehgeekmeister: still following?
15:48:38 <ddarius> I thought it was 800?
15:48:41 <mudge> http://www.realworldhaskell.org/blog/2007/09/21/wow-what-a-response/
15:48:43 <lambdabot> Title: Real World Haskell  Blog Archive  Wow, what a response, http://tinyurl.com/2a6w66
15:48:45 <tehgeekmeister> sorear: yes
15:48:49 <mudge> ddarius: maybe it is by now
15:48:56 <SamB_XP> augustss: but that basically requires you to run the computation...
15:49:04 <sorear> tehgeekmeister: but you get tired of passing around a bunch of
15:49:09 <sorear> tehgeekmeister: but you get tired of passing around a bunch of parameters
15:49:13 <tehgeekmeister> right
15:49:16 <sorear> tehgeekmeister: and notice a pattern...
15:49:26 <augustss> SamB_XP: it's of limited use
15:49:27 <SamB_XP> yes.
15:49:29 <SamB_XP> s'''''''''
15:49:30 <sorear> tehgeekmeister: type IntChanger = Int -> Int
15:49:42 <dons> mudge: yeah BayFP is taking off it seems
15:49:47 <sorear> tehgeekmeister: doesn't actually modify anything, it's just a way of talking about maps
15:49:49 <dons> mudge: what with your book discounts and all!
15:49:58 <Taejo> Any recommendations on what to attend at the ICFP for a complete noob?
15:49:59 <glguy> sorear: I think that we need to drop all pastes that contain "a href", since these replica spams are getting out of hand
15:50:05 <sorear> tehgeekmeister: now you can combine them with (>>) f1 f2 x = f2 (f1 x)
15:50:32 <ddarius> glguy: Do it.
15:50:44 <augustss> Taejo: everything :)
15:51:03 <sorear> tehgeekmeister: and   nothing x = x
15:51:07 <mudge> dons: haha, yea, the book discounts!
15:51:09 <Taejo> augustss, unfortunately I can only be in one place at a time
15:51:23 <mudge> dons: looks like speakers are being organized for future meetings
15:51:27 <augustss> Ah, you're talking parallel session
15:51:33 <glguy> ?doc Data.ByteString
15:51:33 <lambdabot> Data.ByteString not available
15:51:34 <augustss> CUFP is usually fun
15:51:41 <sorear> tehgeekmeister: now with your shiny new functions, you can write   add i x = i + x      adder [] = nothing ; adder (x:xs) = add x >> adder xs
15:51:45 <sorear> tehgeekmeister: follow?
15:51:51 <SamB_XP> augustss: Cute Uses of Functional Programming?
15:52:05 <augustss> Close!
15:52:11 <tehgeekmeister> sorear: yep
15:52:17 <sorear> tehgeekmeister: add has type Int -> Int -> Int, or equivalently Int -> IntChanger
15:52:24 <SamB_XP> Current?
15:52:27 <Taejo> hmm... is the registration separate?
15:52:39 <augustss> Commercial
15:52:46 <Taejo> I can't really afford more
15:52:48 <ddarius> http://cufp.galois.com
15:52:49 <lambdabot> Title: Commercial Users of Functional Programming
15:52:59 <sorear> tehgeekmeister: now, suppose you want to describe 'Take the current number, double it, and return the new value as a string'
15:53:08 <augustss> Taejo: noone will check exactly what you have registered for
15:53:10 <dons> Taejo: the haskell workshop is usually the highlight for me
15:53:28 <sorear> tehgeekmeister: you can't manage that with just IntChanger
15:53:40 <augustss> Taejo: of course the HW, I didn't think I needed to mention that one
15:53:40 <sorear> tehgeekmeister: but it's possible with a simple generalization
15:53:52 <Taejo> :( I arrive too late for the Haskell workshop
15:53:56 <sorear> tehgeekmeister: type IntState a = Int -> (Int, a)
15:54:02 <SamB_XP> augustss: do they just need to know how many snacks to buy or something?
15:54:08 <Taejo> I'm in Freiburg Sunday night until Friday afternoon
15:54:10 <sorear> tehgeekmeister: now IntState () is equivalent to the old IntChanger
15:54:26 <dons> Taejo: you could drop by day 1 of the hackathon then
15:54:27 <augustss> SamB_XP: mostly to get a room of the right size
15:54:36 <sorear> tehgeekmeister: which makes sense, since returning a void value is like returning nothing (just like C)
15:54:39 <sorear> tehgeekmeister: follow?
15:54:40 <SamB_XP> augustss: ah, that is always nice
15:54:48 <omniscientIdiot> i.e. IntChanger () = Int -> (Int, ())
15:54:52 <Taejo> hackathon?
15:54:56 <omniscientIdiot> IntState, rather
15:54:57 <tehgeekmeister> sorear: yes, as long as () is void.  i've not encountered that yet.
15:55:08 <sorear> @src ()
15:55:09 <lambdabot> data () = ()
15:55:16 <mauke> () is the empty tuple
15:55:21 <SamB_XP> tehgeekmeister: it isn't, but it's close enough for practical purposes
15:55:30 <SamB_XP> well, the purposes of returning no useful information
15:55:30 <mauke> @type ()
15:55:31 <tehgeekmeister> okay
15:55:39 <lambdabot> ()
15:55:42 <ddarius> SamB_XP: It's C and co. that have it wrong.
15:56:00 <SamB_XP> ddarius: you mean calling it void and not letting you have variables of that type?
15:56:17 <ddarius> SamB_XP: I just mean calling it void.
15:56:18 <Taejo> I don't think I'd be of much use at the hackathon -- I only started coding in Haskell last week
15:56:23 <sorear> tehgeekmeister: we can generalize the old (>>) to the new type:
15:56:55 <monochrom> I am not sure "void" is wrong.
15:56:56 <sorear> tehgeekmeister: (>>) f1 f2 i = let { (i', val1) = f1 i } in f2 i'
15:57:30 <augustss> monochrom: seems wrong to me
15:57:31 <SamB_XP> monochrom: well, some say the proper haskell void would be "data Void"
15:57:40 <tehgeekmeister> sorear: let me have a moment grokking that definition
15:57:43 <monochrom> I see now. Thanks.
15:58:20 <augustss> or data Void = Void (forall a . a)
15:58:32 <augustss> but I prefer data Void
15:58:50 <tehgeekmeister> sorear: i get it.
15:59:02 <tehgeekmeister> sorear: essentially the same as >> in the state monad?
15:59:17 <sorear> tehgeekmeister: yeah, I'm using the same name deliberately :)
15:59:43 <sorear> augustss: that has two sets of values...  undefined and Void undefined
15:59:45 <omniscientIdiot> tehgeekmeister: the only difference is the State constructor which wraps up the functions into a new type.
15:59:50 <sorear> augustss: need a ! or newtype
16:00:06 <sorear> augustss: and H98 already has  newtype Void = Void Void
16:00:12 <omniscientIdiot> @type get
16:00:14 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
16:00:17 <augustss> Oh if we use bottom then none of these are void anyway :)
16:00:21 <omniscientIdiot> @unmtl State s s
16:00:22 <lambdabot> s -> (s, s)
16:00:42 <sorear> tehgeekmeister: yeah, State and MonadState-foo just complicate the picture, so I'm ignoring them for now.  You should too.
16:00:52 <sorear> tehgeekmeister: I'll get back to them in a minute
16:00:57 <tehgeekmeister> sorear: okay.
16:01:08 <glguy> Is it possible (not necessarily easy) to generate i686 binaries from an x86_64 arch?
16:01:14 <glguy> Haskell binaries
16:01:17 <sorear> tehgeekmeister: so, we have >>.  but it's not always enough, because it throws away the return value of the first action
16:01:34 <sorear> tehgeekmeister: f() + f() in C can't be done with just >>
16:01:49 <sorear> tehgeekmeister: so we need >>=
16:02:15 <Taejo> glguy, it wouldn't be easy, but it's certainly possible: embed an emulator
16:02:23 <sorear> tehgeekmeister: (>>=) ac fn i = let { (i', vl) = ac i } in  fn vl i'
16:02:45 <sorear> tehgeekmeister: >>= is like >>, but it's second argument receives the value of its first
16:03:23 <tehgeekmeister> sorear: got it.
16:03:28 <sorear> tehgeekmeister: so we can have   doubleAndStringize >>= \ s1 -> doubleAndStringize >>= \ s2 -> return (s1 ++ s2)
16:03:28 <omniscientIdiot> here, fn :: a -> IntState b, and IntState b = Int -> (Int, b).  fn first takes the 'a' returned by ac, and you get an IntState action (which is just a function)
16:03:50 <sorear> tehgeekmeister: which effectively runs doubleAndStringize twice in sequence and concatenates the results
16:04:05 <sorear> tehgeekmeister: I'm introducing return, which is the analog of the old nothing
16:04:12 <sorear> tehgeekmeister: return x i = (i, x)
16:04:26 * omniscientIdiot goes off to rewrite (>>=)s in the above
16:04:28 <sorear> tehgeekmeister: (return foo) is an action which does nothing and returns foo
16:04:32 <sorear> tehgeekmeister: follow?
16:04:42 <tehgeekmeister> sorear: catching up.
16:05:42 <ddarius> sorear: Define doing nothing.
16:06:05 <sorear> ddarius: Producing a new state identical to the old state?
16:06:46 <omniscientIdiot> return x = \s -> (s, x) -- s, the Int state, stays the same, x is also returned
16:06:52 <tehgeekmeister> sorear: the chain of binds and doubleAndStringize, at no point, receive any values as input, as far as i can tell.  this means, as far as i can tell, it should just end up as one big computation waiting for a value to operate on, or a lambda-of-sorts.  i'm sure there IS somewhere where a value goes in, but i sure don't see it.
16:07:22 <mauke> tehgeekmeister: the whole thing effectively results in a function waiting for input (the initial state)
16:07:31 <omniscientIdiot> tehgeekmeister: a lambda-in-fact!  bind just composes functions in the State monads!
16:07:33 <tehgeekmeister> mauke: that's what i thot.
16:07:35 <ddarius> :t runState
16:07:40 <lambdabot> forall s a. State s a -> s -> (a, s)
16:07:41 <tehgeekmeister> ahh!!!
16:08:12 <tehgeekmeister> so, then, in my initial question involving get
16:08:30 <tehgeekmeister> we're just chaining together a bunch of computations
16:08:34 <tehgeekmeister> which need to be fed a state?
16:08:41 <tehgeekmeister> to generate any interesting output
16:08:45 <sorear> exactly.
16:08:51 <omniscientIdiot> Yes.  get is just a wrapped function.  Use runState to unwrap it and pass it a value.
16:09:20 <ddarius> get = State (\s -> (s,s))
16:09:33 <mauke> > runState get 42
16:09:35 <lambdabot>  (42,42)
16:09:49 <sorear> tehgeekmeister: once you have >>= and return for State, you start seeing it in other places. Lists, Maybe, IO, etc.  the natural thing to do is create a type class, and that's how we get Monad.
16:09:56 <omniscientIdiot> runState get 1 = runState (State (\s -> (s,s))) 1 = (\s -> (s,s)) 1 = (1,1)
16:10:27 <tehgeekmeister> sorear: i understand >>= in list, io, maybe.  i'm just trying to get it in as many different places as possible.
16:10:44 <mauke> oh, then learn Reader
16:10:58 <tehgeekmeister> i'm really used to imperative thinking, and so when i see something that returns a function, i get confused for a little bit
16:11:02 <omniscientIdiot> tehgeekmeister: do you understand the progression I wrote?
16:11:03 <Botje> > runState (modify (*2)) 42
16:11:05 <lambdabot>  ((),84)
16:11:16 <omniscientIdiot> @src modify
16:11:17 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:11:19 <ddarius> There's is nothing particularly "functional" about returning functions.
16:11:27 <ddarius> @src State modify
16:11:27 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:11:35 <dibblego> imperative programmers return functions all the time; they just call it something else
16:11:41 <mauke> > fmap (*2) . ((,) ()) $ 42
16:11:42 <Botje> modify f = do { s <- get; put (f s) }
16:11:43 <lambdabot>  ((),84)
16:11:58 <omniscientIdiot> modify f = State (\s -> ((), f s)) -- more direct :)
16:12:07 <Botje> that too :)
16:12:36 <mauke> yeah, but modify is generic
16:12:40 <Taejo> dibblego, care to explain?:
16:12:47 <mauke> (which is why it breaks for backwards state)
16:12:57 <tehgeekmeister> omniscientIdiot: which progression?
16:12:58 <dibblego> Taejo, they call them 'objects'
16:13:07 <tehgeekmeister> omniscientIdiot: nm, found it.
16:13:15 <omniscientIdiot> runState (modify (*2)) 3 = runState (State (\s -> ((), (*2) s))) 3 = (\s -> ((), (*2) s)) 3 = ((), 6)
16:13:22 <omniscientIdiot> ^^ another one
16:13:45 <Taejo> dibblego, aaah. and C programmers pass pointers to functions... but that's less powerful
16:13:54 <tehgeekmeister> OH!
16:14:07 <tehgeekmeister> so get is (not sure if this is the right term) a partial function?
16:14:31 <omniscientIdiot> just a function that you haven't giving an argument yet :)
16:14:32 <mauke> hmm, no
16:14:37 <Saizan> partially applied?
16:14:40 <tehgeekmeister> yes!
16:14:43 <mauke> it's just a normal function
16:14:48 <mauke> unapplied
16:14:50 <tehgeekmeister> partial application, that's what i was looking for.
16:15:01 <ddarius> get is just the function \s -> (s,s) wrapped up.
16:15:04 <Taejo> tehgeekmeister, a partial function is undefined (_|_) on some inputs
16:15:15 <tehgeekmeister> Taejo: okay.
16:15:27 <Saizan> well every action in the state monad is "partially applied" in the sense that it waits for an argument, the state
16:15:40 <ddarius> Saizan: That's not partially applied.
16:16:31 <ddarius> Every function "waits" for its arguments
16:16:35 <omniscientIdiot> bind is kinda complicated.  It takes a two functions and makes a new one with all the right parts hooked together.
16:17:25 <tehgeekmeister> in the code i've been linking to, the call to getStdGen, what is that doing?  methinks it's supplying the initial state when called from the command line.
16:17:54 <tehgeekmeister> (http://www.haskell.org/all_about_monads/examples/example15.hs if anyone needs the link.)
16:18:04 <Saizan> ?type getStdGen
16:18:06 <lambdabot> IO StdGen
16:18:19 <ddarius> tehgeekmeister: The initial state is provided at runState which is partially applied, so the initial state is what makeRandomGen is applied to (i.e. g)
16:18:49 * omniscientIdiot immediately notices that makeRandomValue could be simplified if made into a State StdGen MyType
16:19:42 <ddarius> omniscientIdiot: That's the whole point, hence makeRandomValueST
16:19:42 <Saizan> omniscientIdiot: that's the point
16:19:55 <tehgeekmeister> ddarius: makeRandomGen?
16:20:08 <ddarius> tehgeekmeister: Sorry, makeRandomValueST
16:20:30 <tehgeekmeister> ?type runState
16:20:32 <lambdabot> forall s a. State s a -> s -> (a, s)
16:20:56 <omniscientIdiot> here, s is StdGen, and a is MyType
16:20:57 <tehgeekmeister> ddarius: i get it, yes.
16:21:40 <tehgeekmeister> so getStdGen is what's providing the initial state to makeRandomValue and makeRandomValueST
16:21:48 <omniscientIdiot> getAny = State random
16:22:16 <ddarius> tehgeekmeister: g is. getStdGen is just an IO action that gets the standard random number generator and is completely unrelated to the State parts.
16:22:27 <omniscientIdiot> getOne bds = State (randomR bds)
16:23:27 <tehgeekmeister> ddarius: right, but getStdGen is providing the first random number, the value that goes into the initial state, g.
16:23:33 <tehgeekmeister> ddarius: right?
16:24:02 <ddarius> tehgeekmeister: Close enough.  But you could just as well make one using makeStdGen (I think it's called).
16:25:17 <omniscientIdiot> @type newStdGen
16:25:19 <lambdabot> IO StdGen
16:26:05 <ddarius> :t makeStdGen
16:26:07 <lambdabot> Not in scope: `makeStdGen'
16:26:12 <int-e> yep you generally want newStdGen. getStdGen will give you the same one if called two times in a row.
16:26:13 <ddarius> @hoogle StdGen
16:26:13 <lambdabot> System.Random.StdGen :: data StdGen
16:26:13 <lambdabot> Random.getStdGen :: IO StdGen
16:26:13 <lambdabot> Random.mkStdGen :: Int -> StdGen
16:26:19 <ddarius> mkStdGen
16:26:42 <int-e> @src newStdGen
16:26:42 <lambdabot> Source not found. Are you on drugs?
16:29:08 <ddarius> Does anyone besides Simon Peyton Jones read mkFoo as muk-Foo rather than make-Foo?
16:31:08 * tehgeekmeister moves onto the reader monad
16:31:27 <merus> The reader monad is by far my favorite.
16:31:51 <Mr_Awesome> ddarius: no
16:32:00 <int-e> > join (*) 12
16:32:02 <lambdabot>  144
16:32:02 <sjanssen> ddarius: I'm in the "make" camp.  I thought "muk" was a bit weird too
16:32:47 <Mr_Awesome> considering that mk stands for "make," i never considered pronouncing it differently
16:36:04 <SamB_XP> I might pronounce it emm kay
16:36:15 <mauke> mmmkay
16:36:41 <mauke> drugsAreBadMk
16:40:57 <pgavin> :t runStateT
16:41:03 <pgavin> @type runStateT
16:41:06 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
16:41:07 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
16:46:22 <Cale> I don't even really know why getStdGen and setStdGen are in that library.
16:46:50 <Cale> You always either want newStdGen or mkStdGen.
16:47:41 <SamB_XP> Cale: probably they predate concurrent programming...
16:48:30 <Cale> They're still somewhat abusive. They involve an extra piece of global state which is unnecessary.
16:49:32 <Cale> I'm also somewhat disappointed with how the library doesn't use the system random number generator to get seeds.
16:49:53 <Cale> newStdGen should use /dev/random
16:50:32 <SamB_XP> Cale: what does it do now? the old clock thing?
16:50:52 <tehgeekmeister> ?type fromIntegral
16:50:52 <Cale> It splits the generator which getStdGen returns
16:50:57 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:51:08 <Cale> and there's a toplevel IORef which is initialised using the clock
16:51:14 <Cale> iirc
16:56:15 <sorear> Cale: I gave a mbot @tell a few hours ago
16:56:56 <Cale> sorear: Yeah, I caught that.
16:57:20 <Cale> I think it's mostly because I haven't told it to accept them from unregistered users.
16:59:26 <sorear> right; just my @msg didn't go through so I had to @ask :)
17:03:34 <phobes> @hoogle MonadRef
17:03:35 <lambdabot> No matches found
17:06:21 <dons> mudge: hmm. did 3 copies of my mail just go through to the bayfp list?
17:06:41 <dons> stupid google groups
17:12:04 <Cale> tehgeekmeister: Hey, sorry I took off for a while there if you had questions.
17:12:25 <tehgeekmeister> Cale: no problem, i think i've gotten the state monad well enough for now.
17:12:30 <Cale> cool
17:12:40 <tehgeekmeister> i'm playing around with reader now.
17:13:16 <Cale> Reader is easier, it's just like the state monad, only there are no final states to keep track of.
17:13:39 <Cale> The unwrapped version of reader, the ((->) e) monad, is rather fun though :)
17:16:36 <Cale> Basically the idea there is that the computations are just functions which take a parameter of type e, and to run them, a value of type e is passed down to them.
17:16:46 <Cale> So you have things like:
17:17:23 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
17:17:34 <lambdabot>  ("hello","olleh","HELLO")
17:19:00 <Cale> The stuff in Control.Monad has lots of useful corollaries in this particular monad.
17:19:16 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
17:19:18 <lambdabot>  [5,7,10,25,32]
17:19:42 <Cale> (sort of a strangely-flipped version of map)
17:19:58 <Cale> > join (*) 5
17:19:59 <lambdabot>  25
17:20:00 <tehgeekmeister> i get it
17:20:02 <tehgeekmeister> that's really easy
17:20:04 <Cale> join f x = f x x
17:20:22 <tehgeekmeister> >> in the reader monad would be pretty useless, then, wouldn't it?
17:20:34 <Cale> pretty much yeah
17:21:08 <tehgeekmeister> thanks, that gets me thru a monad a lot painlessly and quicker than doing it on my own.
17:21:22 <mauke> > return 2 3
17:21:24 <lambdabot>  2
17:22:09 <tehgeekmeister> haskell knows which >>= to use because of type inference, right?
17:22:23 <Cale> yep
17:22:47 <Cale> It can tell which monad by looking just at the type of the left parameter
17:23:07 <tehgeekmeister> w00t!  all i need now is useful things to do with haskell and i'll be well on my way with it.
17:23:48 <Cale> The list monad is another awesome one.
17:24:08 <tehgeekmeister> yea, i get that one quite well by now
17:24:11 <tehgeekmeister> i've spent a lot of time on it
17:24:21 <SamB_XP> Cale: it can also tell based on the type you need, or the right paramter...
17:24:29 <Cale> SamB_XP: right
17:24:34 <Cale> > filterM (const [False, True]) [1,2,3]
17:24:35 <mauke> > sequence ["salt", "pepper", "ketchup"]
17:24:37 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
17:24:38 <lambdabot>  ["spk","spe","spt","spc","sph","spu","spp","sek","see","set","sec","seh","se...
17:24:59 <tehgeekmeister> the example i saw using the list monad for parsing ambiguous inputs is really cool.
17:25:15 <merus> So I want to apply filter a list by a bunch of different predicates and collect the results as a list. How can I abuse the list monad to do this?
17:25:21 <chessguy> > sequence ["a","bc","d"]
17:25:22 <merus> *I want to filter
17:25:23 <lambdabot>  ["abd","acd"]
17:25:33 * SamB_XP force chokes dons
17:25:33 <chessguy> > sequence ["a","bc","de"]
17:25:35 <lambdabot>  ["abd","abe","acd","ace"]
17:26:00 <Cale> merus: Doesn't that just mean composing the predicates in the right way?
17:26:15 <merus> Oh, I suppose it does. Duh.
17:26:20 <mudge> dons: ah, don't worry about it
17:26:23 <mauke> > filterM (sequence [even, odd]) [1 .. 10]
17:26:25 <lambdabot>  [[2,4,6,8,10],[2,4,6,8],[2,4,6,8,9,10],[2,4,6,8,9],[2,4,6,10],[2,4,6],[2,4,6...
17:26:32 <mudge> dons: I only saw one copy
17:26:45 <Cale> > filterM (sequence [even, odd]) [1..4]
17:26:47 <lambdabot>  [[2,4],[2],[2,3,4],[2,3],[4],[],[3,4],[3],[1,2,4],[1,2],[1,2,3,4],[1,2,3],[1...
17:27:11 <mrd> > sequence [even,odd]
17:27:12 <lambdabot>  <Integer -> [Bool]>
17:27:18 <fax> hi
17:27:34 <Cale> > sequence [even, odd] 5
17:27:35 <lambdabot>  [False,True]
17:27:37 <Cale> > sequence [even, odd] 6
17:27:38 <lambdabot>  [True,False]
17:27:46 <mrd> > and $ sequence [even,odd] 6
17:27:47 <lambdabot>  False
17:28:06 <mrd> isn't that the reader monad
17:28:10 <Cale> yes
17:28:25 <Cale> and then the outer layer with filterM is the list monad
17:28:42 <mauke> @check not . and . sequence [even,odd] :: Integer -> Bool
17:28:43 <dons> mudge: oh, great.
17:28:44 <lambdabot>  OK, passed 500 tests.
17:28:53 <dons> mudge: so its something weird about my subscription..
17:28:59 <dons> http://programming.reddit.com/info/2sra3/comments/c2sra6?context=5
17:29:02 <lambdabot> Title: Proving the monad laws in Coq (reddit.com), http://tinyurl.com/yq7w7l
17:29:04 <Cale> @check or . sequence [even,odd] :: Integer -> Bool
17:29:05 <lambdabot>  OK, passed 500 tests.
17:29:10 <dons> mrd++
17:29:40 <Cale> dons: Have you seen the Catsters videos on monads?
17:29:46 <mrd> ooh forgot about that post
17:29:49 <phobes> Is there something like check that attempts to algebraically prove properties, rather than just verifying a few instances?
17:30:02 <Cale> dons: I particularly like the string diagram stuff they're getting into now :)
17:30:08 <dons> Cale: yeah, they're spectacular
17:31:07 <SamB_XP> would be more spectacular if I actually knew abstract nonsense...
17:31:20 <mrd> i need to polish up some examples of strongly specified functions
17:31:27 <mauke> @scheck not . and . sequence [even,odd] :: Int -> Bool
17:31:30 <lambdabot>   Completed 13 test(s) without failure.
17:31:42 <pastorn> i want to see the source for >>= for IO
17:31:46 <EvilTerran> phobes, have you looked at Coq?
17:31:48 <Cale> I'm pretty convinced that string diagrams are a great way to look at monads and adjunctions :)
17:31:52 <mauke> @src IO >>=
17:31:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:31:55 <dons> i count 8 blogs about proving haskell programs in theorem provers in the last 4 weeks
17:31:59 <EvilTerran> @src IO
17:32:00 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:32:08 <mauke> @src IO (>>=)
17:32:09 <lambdabot> m >>= k     = bindIO m k
17:32:12 <dons> 4 on coq, one on isabelle, 3 in agda/coa
17:32:13 <EvilTerran> pastorn, surprise! it's the state monad.
17:32:14 <dons> coq
17:32:19 <pastorn> hehe
17:32:20 <mrd> i've been working with twelf lately, though, which doesn't extract to anything
17:32:22 <pastorn> coolers
17:32:25 <EvilTerran> ish.
17:32:27 <Cale> The purely topological proof of the associative law for the monad arising from an adjunction is brilliant :)
17:32:41 <EvilTerran> State#, whatever that is.
17:32:42 <merus> Cale: Is it posted somewhere?
17:32:45 <mauke> @src bindIO
17:32:45 <lambdabot> bindIO (IO m) k = IO ( \ s ->
17:32:45 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
17:32:47 <dons> mrd: oh, yes it does. i'm pretty sure you can pull ML out of twelf
17:32:54 <Cale> merus: I drew a picture here http://cale.yi.org/autoshare/monadassociativity.jpg
17:32:57 <phobes> EvilTerran:  I meant for haskell ... I guess @pl will fit the bill once its limitations are removed
17:33:00 <mrd> i think they deprecated that
17:33:01 <EvilTerran> @src unIO
17:33:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:33:04 <dons> mrd: do you just use the command line interface?
17:33:08 <dons> or proof general + twelf?
17:33:10 <Cale> merus: but if you want the details, watch the Catsters videos, because they've done that now :)
17:33:13 <mrd> i use twelf-server/emacs
17:33:16 <dons> yeah
17:33:24 <dons> i wrote a haskell binding to that if you're interested
17:33:29 <mrd> yes, i am
17:33:31 <dons> you can send fragments from haskell to twelf, and get the result back
17:33:38 <dons> let me see if i can find it
17:33:43 <chessguy> so, i've been developing a chess engine, and there's a GUI for engines that just supplies a protocol, and if you implement that protocol, it will provide the front end for your engine. can someone look at http://www.tim-mann.org/xboard/engine-intf.html#2 and tell me if i'm going to have trouble doing this in haskell, with laziness?
17:33:44 <lambdabot> Title: Chess Engine Communication Protocol
17:33:46 <EvilTerran> phobes, i figured that's what you meant. i guess it's a bit fiddly, without something like the manual annotation of axioms that you provide when using Coq
17:33:49 <chessguy> (it's under point 2)
17:33:51 <mrd> right, there is an sml interface i remember, but i had to compile with MLton which doesn't support that
17:34:12 <EvilTerran> (but don't trust me on that one)
17:34:26 <pastorn> in "newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))", what's #?
17:34:31 <dons> mine was just a 2 way pipe to twelf
17:34:36 <dons> so you could script it from haskell
17:34:46 <dons> useful if you want ot use twelf as your type checker ;)
17:34:49 <mrd> that's cool
17:34:53 <mauke> pastorn: concentrated evil
17:34:59 <pastorn> hehe
17:35:05 <phobes> EvilTerran:  Ya, more complicated rewrites are probably beyond current tech without human assistance
17:35:12 <pastorn> dous this evil have a name?
17:35:13 <mrd> what have you done with twelf?
17:35:20 <mauke> unboxed types
17:35:33 <chessguy> is this just going to be a matter if implementing a REPL?
17:35:39 <dons> mrd, oh, research project in proof carrying code
17:35:51 <mrd> hehe PCC gets around
17:35:54 <dons> we embedded a type system in twelf, with LF for the proof fragment
17:35:58 <mrd> whodya work with
17:35:58 <pastorn> mauke: is it like a special case of 'a'?
17:36:01 <dons> and used twelf as the actual type checker of the compiler
17:36:06 <merus> Cale: Oh, the Catsters are so awesome! <3
17:36:12 <dons> mrd , this was at unsw.
17:36:17 <dons> http://www.cse.unsw.edu.au/~pls
17:36:17 <lambdabot> Title: Programming Languages & Systems Research Group
17:36:18 * chessguy sighs
17:36:36 <mauke> pastorn: huh?
17:36:39 <dons> Cale, do we have .wmv  or mpg of the catsters stuff?
17:36:44 <Cale> merus: Yeah, I drew that after the initial episode on string diagrams, because I couldn't wait to see them do it.
17:37:01 <EvilTerran> pastorn, # is part of the token State# and the syntax (# ... #)
17:37:06 <sorear> import Control.Monad; x = length $ filter (>= 57) $ fmap sum $ replicateM 9 [1::Int ..8]; main = print x
17:37:11 <Cale> dons: I don't know, but you might be able to use some tool to rip the videos from YouTube.
17:37:12 <sorear> what's wrong with that program?
17:37:22 <SamB_XP> dons: is there something wrong with .flv?
17:37:31 <pastorn> EvilTerran: what cool stuff that is needed for IO does # give?
17:37:40 <sorear> it should run in constant space, but it trips the oom-killer for me
17:37:44 <EvilTerran> pastorn, in the latter case, it indicates an unboxed tuple. i don't know what it means in terms of State# - it's just a character like any other there
17:37:54 <Cale> It would certainly be nice to have them in higher resolution
17:38:06 <pastorn> EvilTerran: ok, thanks
17:38:07 <Cale> The writing on the board is sometimes small and blurry
17:38:13 <SamB_XP> in State# it means "sharp, do not touch!"
17:38:19 <pastorn> i'll look at this again in a year or four
17:38:35 <mauke> > 8^9
17:38:42 <mrd> dons: is that twelf bit in one of the software files there
17:38:47 <lambdabot>  134217728
17:38:48 <sorear> it still shouldn't consume 300MB
17:39:00 <dons> mrd: hmm, not sure its public. bug me later and i'll hunt it down for you
17:39:11 <mrd> sure, np
17:39:11 <dons> a quick glance and i couldn't see it in my public_html
17:39:49 <idnar> yeah, .flv is really painful to view
17:40:10 <dmwit> ?users
17:40:10 <lambdabot> Maximum users seen in #haskell: 407, currently: 360 (88.5%), active: 18 (5.0%)
17:41:53 <mrd> you can use twelf as a logic programming language.  i wasn't aware of any extraction capabilities as in Coq, though.
17:43:28 <dons> yeah, only to ML afaik
17:43:46 <mrd> well you can invoke it from ML, but that's not quite the same ... sorta
17:45:27 <zarvok> I believe Coq now extracts to ocaml, haskell, and scheme
17:45:35 <zarvok> oh, I see
17:45:36 <zarvok> I misread, sorry
17:50:05 <mrd> i did an exercise in Coq and Twelf recently to compare
17:53:54 <pastorn> how do i get the lambda symbol with my keyboard (utf8 if that matters)?
17:54:02 <ddarius> Cale: Simon said he'd show a quick way to prove that adjunctions give rise to monads, but I distinctly remember Eugenia's being quicker.
17:54:42 <Cale> ddarius: Once you have the string diagram notation, it's very much easier.
17:54:58 <fax> pastorn: 
17:55:16 <pastorn> fax: <3 <3 <3 @ u
17:55:33 <SamB_XP> fax: yes, but HOW
17:55:34 <pastorn> fax: is there a key combination for it?
17:55:59 <mauke> ctrl+shift+3bb
17:56:07 <mrd> in urxvt?
17:56:12 <ddarius> Cale: Indeed (well once you show that the "obvious" laws suggested by the notation hold.)
17:56:59 <ddarius> Cale: I was mostly emphasizing Eugenia racing through the proof at the end of Adjunctions 3.
17:58:40 <Cale> ah, haha
17:58:43 <pastorn> mauke: thanks :D
17:58:50 <Cale> yeah, that was a pretty fast proof :)
18:00:21 <monochrom> I type ctrl-alt-space, then \lambda, to get 
18:00:32 <monochrom> CLEARLY IT IS SPECIFIC TO MY SETUP.
18:00:55 <dons> your setup seems to have a broken caps lock key
18:00:58 <Cale> I hit both alt keys and then hit l
18:01:15 <merus> Heh, Adjunctions 3 was great
18:01:24 <merus> I think it's the one that really set the tone for the series.
18:01:57 <merus> hmm, my alt-l is 
18:02:42 <Cale> Well, I do those two things separately, pressing both alt keys swaps my keyboard map to greek.
18:02:48 <idnar> what input method is that?
18:03:02 <Cale> Sometimes I use SCIM, but that's separate.
18:03:09 <pastorn> Cale: you REALLY use those symbols that much?
18:03:16 <idnar> the \lambda thing, I mean
18:03:26 <SamB> idnar: the LaTeX one ;-P
18:03:32 <monochrom> SCIM's latex input method.
18:04:00 <idnar> ah
18:04:07 <Cale> pastorn: sure, enough to bind "pressing both alt keys at the same time" to it :)
18:04:18 <monochrom> This kind of questions is like "how do I auto-indent haskell code in my editor"
18:04:44 <idnar> of course
18:05:44 <SamB> apparantly for me the combo is C-Space
18:06:12 <SamB> no wait
18:06:38 <SamB> yeah, that works...
18:06:55 <SamB> 
18:07:36 <SamB> 
18:07:52 <Cale> 
18:08:05 <mauke> 
18:08:13 <Cale> 
18:08:17 <fax> _
18:08:31 <SamB> 
18:09:06 <mauke> .
18:09:09 <Cale> _
18:09:25 <Cale> _
18:09:35 <fax> haha
18:09:46 <Cale> _
18:09:59 <KatieHuber> haskell needs a  operator ^_^
18:10:00 <mauke> 
18:10:04 <monochrom> I love 
18:10:07 <lokik_> rili UTF xapi
18:10:42 * lokik_ is more inclined to use multi-letter operators
18:10:43 <pastorn> KatieHuber: what would  do?
18:11:10 <KatieHuber> something cool in Control.Arrow inevitably ;)
18:11:21 <lokik_> :|
18:11:31 <Cale> maybe "first"
18:12:11 <fax> `\+@
18:14:26 <SamB> okay, I'm not sure how it's supposed to work exactly, but C-A-up/down seem to switch input methods
18:21:31 <monochrom> You can customize how to switch input methods.
18:22:05 <nominolo> is there something that shows the current status?
18:22:44 <monochrom> Yes. The same user interface that changes key bindings shows the current key bindings.
18:24:35 <ferron> hi there
18:25:29 * SamB marvels at google getting part of gmail's interface on TOP of the browser's scroll bars...
18:26:18 <ddarius> Perhaps the whole screen is in a div with overflow:auto
18:26:19 <monochrom> IIRC CSS allows that through specifying z-orders.
18:26:43 <SamB_XP> ddarius: it is not!
18:26:54 <SamB_XP> maybe body acts that way though ;-P
18:27:44 <nominolo> probably a browser bug
18:27:48 <ferron> hey guys can you help me with my haskell home work ???
18:28:51 <dons> ferron: http://haskell.org/haskellwiki/Homework_help
18:28:51 <lambdabot> Title: Homework help - HaskellWiki
18:30:10 <ferron> it is a simple problem please help me
18:30:17 <ferron> I am using winhugs
18:30:25 <pjd> ferron: it's better to just ask :)
18:30:38 <puusorsa> dont tell anyone its your homework
18:31:06 <phobes> Ya, tell people you're researching recursion and string manipulation
18:31:15 <fax> haha
18:31:22 <ferron> cool
18:31:34 <fax> That's not so odd
18:31:37 <dons> ok, anyway, what's the question?
18:32:13 <pjd> ferron: what i mean is, don't ask to ask
18:32:31 <pjd> *do* say it's homework, so you get useful explanations
18:32:39 <dibblego> where is the wiki rant about if' ?
18:32:43 <puusorsa> describe the problem before asking if anyone can help
18:32:47 <ferron> i want to create a simple function to find the average of three numbers and then output how many of your input is greater than the average of the three
18:32:51 <dibblego> searching for if' sucks
18:33:18 <dons> ferron: right. so you know about the Ord class, and < <= == > >= and so on?
18:33:31 <dons> > 1 < 2
18:33:33 <lambdabot>  True
18:33:40 <phobes> dons: He's asking to average numbers.. I doubt he knows about Ord
18:33:41 <dons> > let f x y = x < y in   f 1 2
18:33:42 <lambdabot>  True
18:33:47 <kawfee> wtf is fax doing in here?
18:33:57 <dons> ftw fax is here.
18:34:03 <fax> :D
18:34:07 <dons> go fax!
18:34:15 <fax> I'm writing haskell code (really slowly)
18:34:20 <kawfee> ferron what school?
18:34:30 <ferron> the result suppose to be numeric not Bool
18:34:48 <jbauman> makes sense
18:34:56 <dons> what aspect of the problem is causing trouble, ferron ?
18:35:00 <ferron> Jamaica College (high school)
18:35:09 <puusorsa> "output how many of your input".. that would be a bit hard as bool i think
18:35:10 <jbauman> if you want the output to be a number
18:35:17 <dons> do you have a type for your function?
18:35:28 <kawfee> ferron high school or college?
18:35:47 <ferron> I can find the average of the three numbers but I don't know how to calculate how much is greater than the average
18:36:02 <dons> ah ok. you know about list comprehensions?
18:36:08 <dons> or 'filter' ?
18:36:13 <dons> > filter (< 3) [1..10]
18:36:14 <lambdabot>  [1,2]
18:36:17 <dons> > filter (>= 3) [1..10]
18:36:19 <lambdabot>  [3,4,5,6,7,8,9,10]
18:36:29 <dons> > [ x | x <- [1..10] , x >= 3 ]
18:36:30 <lambdabot>  [3,4,5,6,7,8,9,10]
18:36:47 <dons> basic mechanisms for traversing a list, filtering out elements that match some condition
18:36:48 <ferron> howManyAboveAverage :: Int -> Int -> Int -> Int
18:36:57 <puusorsa> > length $ filter (>= 3) [1..10]
18:36:59 <lambdabot>  8
18:37:01 <dons> wouldn't it take a list though?
18:37:12 <dons> Int -> Int -> Int -> [Int] -> Int ?
18:37:32 <dons> so it takes 3 values, computes the average of them, and then does what... ?
18:37:49 <ferron> howManyAboveAverage :: Int -> Int -> Int -> Int : Teacher said I shhould use this function
18:38:02 <idnar> dons: I think the "list" is merely comprised of the three numbers passed as input
18:38:25 <dons> ah.
18:38:35 <dons> ferron: right, so you've worked out the average of the 3 inputs?
18:38:50 <jbauman> that makes it just brute force ifs, then
18:38:50 <dons> and now you need to find out how many of those 3 are above that average, right?
18:38:56 <dons> ferron: so how would you do that?
18:39:34 <ferron> remember I have to find the average of the three numbers first then find out how many is greater than the average of the three
18:40:00 <monochrom> Can you use a list?
18:40:10 <SamB_XP> ferron: you know, I think it would be simpler to just write howManyAboveAverage :: [Int] -> Int
18:40:41 <ferron> howManyAboveAverage a b c = filter ((a + b + c) `div` 3) []
18:40:47 <fax> you can have an intermediate like, f x y z = otherF [x,y,z]
18:40:48 <ferron> can that work ??
18:40:56 <fax> if you are required to pass in 3 ints
18:40:57 <phobes> It's nice that your professor lets you assume they are integers so that you can use recursion
18:41:29 <dibblego> that's a good beginner exercise; I am writing those for Scala, might steal that one :)
18:42:11 <ferron> is the above good ??? howManyAboveAverage a b c = filter ((a + b + c) `div` 3) [] Can this work ???
18:42:19 <nominolo> i think the goal of the assignment is to use guards, and comparisions
18:42:36 <nominolo> ferron, no, div returns a number
18:42:41 <monochrom> filter ((a + b + c) `div` 3) [] doesn't even type-check. I guess I now agree with jbauman. Just KISS.
18:42:42 <nominolo> not a boolean
18:42:49 <fax> ferron: ?x1
18:43:39 <ferron> I use the div to find the average of the three
18:44:04 <dons> that's ok.
18:44:14 <dons> > sum [1,2,3]
18:44:24 <ferron> filter (>) ((a+b+c) `div` 3) []
18:44:25 <lambdabot>  6
18:44:26 <dons> might be nicer than interleaving + through the 3 values yourself.
18:44:46 <ferron> to filter out how many is great than the average
18:44:49 <dons> you'll need to name the result of the average though, in order to use it to filter
18:44:56 <dons> do you know about 'where' clauses?
18:45:09 <dons> f x = y where y = average 1 2 3 -- for example?
18:45:14 <ferron> yeah
18:45:26 <ferron> ok
18:45:33 <ferron> that makes sense
18:46:31 <dons> once you've got the average in a variable, then you can use filter to sieve out elements from the list greater than the average
18:46:38 <dons> you should try to do that now
18:46:53 <ferron> thats what I am doing
18:47:31 <dons> cool.
18:48:25 <ferron> one thing i love with haskell it helps me think
18:48:28 <puusorsa> whee, got similar thing working, for lists, not limited to 3 numbers :)
18:48:55 <dons> :)
18:49:14 <dons> ferron: yep, it helps get clear what the essence of your algorithm is, i find.
18:49:17 <monochrom> The next natural question is "variable number of arguments".
18:50:02 <puusorsa> had to use fromIntegral before ghci liked using /
18:52:07 <ferron> next week we have to try challenge the tower of honoi problem
18:52:07 <puusorsa> now that i think a bit more about i dont like it... how to do division for any numeric type?
18:53:37 <ferron> i am getting a type error
18:54:08 <monochrom> You can't do division for all numeric types.
18:54:23 <P_D> anyone aware of a haskellized least squares solver?
18:54:32 <dons> ferron: what is type error?
18:54:32 <puusorsa> ok. don't need to, looked what i had written a bit closer
18:54:38 <dons> what is /the/ type error :)
18:54:49 <puusorsa> 5am maybe i should sleep a while, have to wake up in 3 hours..
18:55:07 <ferron> something about a bool
18:55:26 <monochrom> @info (/)
18:55:26 <lambdabot> ((/))
18:55:29 <ferron> howManyAboveAverage :: Int -> Int -> Int -> Int
18:55:31 <ferron> howManyAboveAverage a b c = filter (>)(average) []
18:55:32 <ferron> 			
18:55:33 <ferron> 			where average = ((a + b + c) `div` 3)
18:56:06 <dons> filter (> average)
18:56:11 <dons> and currently you filter the empty list
18:56:19 <dons> you probably want to put a , b and c into that list you filter on
18:56:21 <monochrom> Fractional is the class that supports division.
18:56:43 <dons> ferron: also, you filter the list, producing a list of values > than the average
18:56:50 <dons> you'll then have to count them, to produce a final Int
18:57:09 <ferron> k
18:58:46 <dons> see how the type, :: Int -> Int -> Int -> Int, is guiding you towards the solution
18:58:49 <dons> :t filter
18:58:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:58:54 <dons> returns a [Int], but you need an Int
18:59:03 <dons> so you'll need to find a function to count the number of elements in a list
18:59:10 <ferron> Type error in explicitly typed binding
18:59:10 <dons> and such a function would have type [Int] -> Int
18:59:13 <dons> or more generally, [a] -> a
18:59:17 <dons> or more generally, [a] -> Int
18:59:44 <dons> type errors are the compiler telling you that you got something wrong. you need to look at it, think about what it means, and adjust your code accordingly
19:00:30 <ferron> Int -> Int -> Int -> [Int]
19:00:32 <ferron> i changed it to this
19:00:52 <dons> ok, so now it returns all the elements > than the average
19:00:59 <puusorsa> hm why doesnt this work: length . (filter =<< flip (>) . liftM2 (/) sum (fromIntegral . length)) [1..10]
19:01:12 <dons> or at least, that's what you're asking the compiler to confirm: that it does return a list of elements
19:01:12 <puusorsa> the same before using pl on it does
19:01:41 <monochrom> Many type errors are brain errors.
19:02:02 <ferron> so what do i do to count them ?
19:02:25 <monochrom> Many brain errors are due to Python Ruby etc. that encourage sloppiness and cause brain damage.
19:02:50 <merus> It's so cool that a lot of the early Project Euler problems are one line in Haskell.
19:03:09 <dons> ferron: perhaps take the length of the list?
19:03:17 <edwardk> merus: yeah
19:03:28 <idnar> :hoogle [a] -> Int
19:03:32 <idnar> @hoogle [a] -> Int
19:03:33 <lambdabot> Prelude.length :: [a] -> Int
19:03:56 <jbauman> @hoogle [Int]->Int
19:03:57 <lambdabot> No matches, try a more general search
19:04:22 <puusorsa> > length . (filter =<< flip (>) . liftM2 (/) sum (fromIntegral . length)) [1..10]
19:04:23 <lambdabot>  Couldn't match expected type `a -> [a1]'
19:04:30 <dons> so if you can work out the type of your functoin, @hoogle can be used to find it for you
19:04:38 <dons> ferron: did you see that?
19:04:42 <puusorsa> :type length . (filter =<< flip (>) . liftM2 (/) sum (fromIntegral . length))
19:04:46 <dons> @hoogle [a] -> Int
19:04:46 <lambdabot> Prelude.length :: [a] -> Int
19:05:03 <ferron> here is it
19:05:05 <ferron> howManyAboveAverage :: Int -> Int -> Int -> Int
19:05:07 <ferron> howManyAboveAverage a b c = length (filter (> average) [a,b,c])
19:05:08 <ferron> 			
19:05:09 <puusorsa> :type (length . (filter =<< flip (>) . liftM2 (/) sum (fromIntegral . length)) )
19:05:09 <ferron> 			where average = ((a + b + c) `div` 3)
19:06:18 <ferron> howManyAboveAverage :: Int -> Int -> Int -> Int
19:06:20 <ferron> howManyAboveAverage a b c = length (filter (> average) [a,b,c])
19:06:21 <ferron> 			
19:06:22 <ferron> 			where average = ((a + b + c) `div` 3)
19:06:24 <ferron> I wrote this and it worked !!!
19:06:32 <idnar> ferron: congratulations :)
19:06:34 <dons> yay!
19:06:37 <dons> welcome to haskell :)
19:06:40 <puusorsa> hooray!
19:08:33 <ferron> thanks guys. You are the best!!! Special thanks to dons
19:09:33 <sorear> ferron: we try to be the best, always
19:09:36 <sorear> @quote tropical
19:09:36 <lambdabot> No quotes match. stty: unknown mode: doofus
19:09:39 <sorear> bah
19:10:07 <jbauman> aww, he isn't going to hang around?
19:10:22 <kaol> @users
19:10:22 <lambdabot> Maximum users seen in #haskell: 407, currently: 350 (86.0%), active: 15 (4.3%)
19:10:29 <sorear> *wap*
19:10:29 <jbauman> he was just ...using... us?   (    :-)
19:10:37 <dons> omg. i feel so dirty
19:10:43 <kaol> @losers
19:10:44 <lambdabot> Maximum users seen in #haskell: 407, currently: 350 (86.0%), active: 15 (4.3%)
19:10:48 <fax> haha
19:10:57 <sorear> *sob* *sob*
19:12:22 <monochrom> Yeah, you slept with a newbie to get him/her into haskell, then he/she just walks away.
19:12:56 <monochrom> So now you develop an obsession of taking showers.
19:13:24 <jbauman> there could be worse obsessions
19:13:39 <jbauman> like an obsession with not taking showers
19:14:07 <dons> it's like he just wanted to get his homework done!
19:14:23 <dons> but i feel that deep down he's got a bit more of an understanding of the language now.
19:15:42 <ferron> of course I did. I've got the greatest teachers to help, and u
19:17:26 <dons> :)
19:17:43 <dons> now you can meet lambdabot
19:17:45 <dons> ?bot
19:17:45 <lambdabot> :)
19:17:50 <dons> she'll guide you on your haskell journey
19:17:51 <Zao> From that we can infer that dons is not in the set "greatest teachers".
19:18:00 <dons> > map (^2) [1..]
19:18:06 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
19:18:07 <dons> with online haskell evaluation
19:18:14 <dons> (hmm, i should really move lambdabot to the US..)
19:18:16 <dons> :t map
19:18:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:18:19 <dons> type inference!
19:18:24 <dons> ?index map
19:18:25 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
19:18:28 <dons> module lookup
19:18:33 <dons> ?docs Data.List
19:18:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
19:18:36 <dons> and documentatoin lookup
19:18:51 <dons> with these, ferron, you can lookup anything you need as you go
19:18:58 <dons> ?hoogle (a -> b) -> [a] -> [b]
19:18:58 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
19:18:58 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
19:18:58 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
19:19:04 <dons> for when you know the type, and need to find a function
19:19:12 <fax> hoogle is amazing :D
19:19:13 <dons> and of course, lambdabot is written in 100% haskell
19:19:16 <dons> ?version
19:19:16 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
19:19:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:19:27 <dons> and if you know the type, and just want the bot to write your code for you:
19:19:32 <dons> ?djinn a -> b -> (a,b)
19:19:32 <lambdabot> f a b = (a, b)
19:19:37 <dons> the bot can also do that.
19:19:42 <dons> great for homework :)
19:19:58 <dons> sometimes you want the bot to simplify your code too, which is easy enough:
19:20:08 <dons> :t map (\x -> x + 2) [1..10]
19:20:10 <lambdabot> forall a. (Num a, Enum a) => [a]
19:20:13 <dons> ?pl map (\x -> x + 2) [1..10]
19:20:13 <lambdabot> map (2 +) [1..10]
19:20:18 <dons> it finds a simpler form.
19:20:26 <dons> and this is how we spend our days.
19:21:11 <dons> ferron: i hope you were paying attention. we don't do the lambdabot tour very often :)
19:21:15 <jbauman> or you could use it to complexify your code as well
19:21:21 <dons> quite so!
19:21:54 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint, ferron
19:21:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:22:40 <dons> the other place to get aquainted with is haskell.org
19:23:06 <jbauman> lambdabot needs a tour command
19:23:10 <jbauman> so it could do this itself
19:23:42 <dons> oh, automated. that's good thinking jbauman. we can use computers for that!
19:23:50 <dons> :)
19:24:03 <dons> lambdabot likes computers too
19:26:37 <dons> > sum [1..100000]
19:26:39 <lambdabot>  5000050000
19:26:47 <lambdabot-usa>  5000050000
19:26:51 <dons> > sum [1..100000]
19:26:51 <idnar> heh
19:26:52 <lambdabot>  5000050000
19:26:56 <dons> interesting.
19:26:59 <idnar> doesn't seem to be an improvement
19:27:01 <lambdabot-usa>  5000050000
19:27:03 <dons> ?bot
19:27:03 <lambdabot> :)
19:27:06 <dons> huh.
19:27:11 <lambdabot-usa> :)
19:27:14 <dons> lambdabot-usa seems a bit sick
19:27:18 <dons> Main: caught (and ignoring) IRCRaised Data.ByteString.index: index too large: 0, length =
19:27:31 <idnar> oh dear
19:27:33 <fax> phew
19:27:37 <dons> oh, oops. /dev/hda1              20G   19G  572K 100% /
19:27:43 <idnar> teehee
19:28:20 <dons> maybe computers are faster in australia
19:28:49 <ivanm> dons: of course they are! :p
19:29:06 <monochrom> lambdabot-northern-hemisphere
19:29:10 <dons> well, evidence so far indicates this
19:29:12 <dons> ?bot
19:29:12 <lambdabot> :)
19:29:20 <dons> wait for network to settle...
19:29:26 <lambdabot-usa> :)
19:29:31 <dons> to bits flow backwards in the northern hemisphere?
19:29:34 <dons> ?bot
19:29:34 <fax> can you make lambdabots talk?
19:29:34 <lambdabot> :)
19:29:42 <lambdabot-usa> :)
19:29:44 <fax> > print "> print hi"
19:29:46 <lambdabot>  <IO ()>
19:29:47 <dons> weirdness.
19:29:49 <fax> :[
19:30:03 <monochrom> I posit that it is the firewalls at Galois.com that cause delays.
19:30:07 <dons> lambdabot-usa: @quit try again tomorrow
19:30:12 <dons> its running on a xen host too
19:32:06 <idnar> > "> \"foo\""
19:32:08 <lambdabot>  "> \"foo\""
19:32:41 <idnar> hmm, no
19:33:31 <sorear> idnar: it won't work, ever
19:33:43 <sorear> idnar: IRC doesn't give your own lines back to you
19:33:56 <jbauman> no, but if there are two bots it would work
19:34:02 <sorear> jbauman: and it does.
19:34:07 <sorear> i've done it.
19:34:20 <sorear> but we have /kick, so it's no big deal
19:34:41 <jbauman> now we have to make a quine for lambdabot...
19:35:58 <Pseudonym> > let q x = x ++ show x in q "> let q x = x ++ show x in q "
19:35:59 <lambdabot>  "> let q x = x ++ show x in q \"> let q x = x ++ show x in q \""
19:36:20 <Pseudonym> Yes, we've been here before.
19:37:06 <Pseudonym> ?where+ ?where ?where
19:37:07 <lambdabot> Done.
19:37:19 <Pseudonym> ?where ?where
19:37:19 <lambdabot> ?where
19:37:30 <Pseudonym> ?where+ ?where ?where ?where
19:37:30 <lambdabot> Done.
19:37:32 <Pseudonym> ?where ?where
19:37:32 <lambdabot> ?where ?where
19:37:42 <Pseudonym> Now if only lambdabot-usa was here...
19:37:46 <jbauman> oh, there it goes...
19:38:09 <idnar> heh
19:38:16 <SamB_XP> Pseudonym: does that denote country, or is it one of them japanese suffixes?
19:38:33 <SamB_XP> or something
19:38:41 <Pseudonym> I think "something".
19:39:01 <SamB_XP> where did it come from?
19:40:53 <Pseudonym> dons: Perhaps the ?where command should add a space before its response.
19:41:09 <dons> seems like a good idea
19:41:19 <Pseudonym> That adds to the challenge.
19:43:11 <phobes> Does lambdabot have a built-in spam guard?
19:43:24 <dons> yeah
19:43:26 <ferron> hi lambdabot
19:43:54 * lambdabot listens to the sound of crickets chirping
19:44:45 <edwardk> everytime i get to the stage or writing a haskell-like parser that i need to implement layout i start cursing.
19:44:56 <edwardk> er s/or/of/
19:45:01 <dons> do the layout in the lexer :)
19:45:09 <edwardk> you can't, coz it has to interact with the parser
19:45:11 <Pseudonym> Yeah, because we need another Haskell parser.
19:45:22 <Pseudonym> Why don't you link it into lambdabot while you're at it?
19:46:03 <Pseudonym> Seriously, someone needs to take on the task of getting Language.Haskell usable.
19:46:06 <edwardk> the rule for:     L (t:ts) (m:ms) | m /= 0 && parse-error t
19:46:57 <edwardk> Pseudonym: the language in question isn't haskell, but now i want layout for it since its ready for monads ;)
19:47:07 <Pseudonym> Ah. :-)
19:48:19 <edwardk> i basically started ripping types out of my toy language, and found i could still get haskell-like monad syntax to work
19:48:28 <edwardk> so now i want monad sugar =)
19:48:37 <merus> so If I have a pattern of the form [a:as], how does it match [1]?
19:48:50 <merus> a = 1, as = []?
19:48:55 <phobes> no
19:48:59 <phobes> it doesn't match
19:49:09 <monochrom> Since it's your language, you can design simpler layout rules and have easier implementation.
19:49:11 <phobes> if your pattern is just a:as, that matches [1] the way you want
19:49:27 <merus> ooh.
19:49:35 <merus> Right.
19:49:36 <steven_ashley> merus, use (a:as) not [a:as]
19:50:04 <edwardk> monochrom: the trick is getting something useful out of the simplified rule
19:50:15 <pa-ching> Huh... I can't get hs-plugins to ./configure right, complains about a missing trailing s in a sed script..
19:50:27 <monochrom> For example there is a Haskell layout rule that allows "let a=1 \n     b=1 in \n ..." i.e. the "in" is allowed to be on the same line as "b=1". You can easily drop that.
19:50:47 <edwardk> actually let ... in is the easy case =)
19:50:49 <monochrom> And I think that's the only rule making Haskell layout hard.
19:50:53 <ferron> does anyone understand the tower of honoi problem and can better explain it to me
19:50:57 <edwardk> its the let ... ; inside of a do block thats hard ;)
19:51:19 <monochrom> Does your language have both "let ... in" and "do ... let ... "?
19:51:26 <edwardk> or the stupid corner cases like do a == b == c  becoming do { a == b } == c
19:51:45 <edwardk> monochrom: i haven't worked out a do ... let sugar yet, so er... no ;)
19:51:56 <monochrom> I'm referring to the "if parse error, backtrack" rule.
19:52:10 <edwardk> yeah
19:52:29 <phobes> ferron: wikipedia wants to explain it!  http://en.wikipedia.org/wiki/Tower_of_Hanoi
19:52:30 <monochrom> It's probably the same backtracking rule that allows both "b=1 in" and "do a==b==c".
19:52:31 <lambdabot> Title: Tower of Hanoi - Wikipedia, the free encyclopedia
19:52:53 <monochrom> You drop it, you drop 99% of the problems, I speculate.
19:53:04 <ferron> thanks
19:53:09 <edwardk> if you're in an implicit { and the next token would cause a parse error, but if you substitute an implicit } it wouldn't error, then insert the }.. the L (t:ts) (m:ms) case
19:53:34 <edwardk> monochrom: if its dropped then lexing and parsing can stage out separately
19:53:51 <edwardk> monochrom: been trying to figure out minor syntactic changes that would let that happen
19:54:22 <edwardk> http://www.haskell.org/pipermail/haskell-prime/2006-March/000915.html talks through some of those issues in haskell
19:54:24 <lambdabot> Title: the dreaded offside rule, http://tinyurl.com/yv55g4
19:56:46 <edwardk> in can pair up with a let so let ... in is easy regardless of the parse-error rule, but i think the main issues are things like (case x of y -> z, foo)
19:57:45 <monochrom> Ah. Darn.
19:57:52 <edwardk> and the unpaired lets in do sugar and comprehensions
19:59:36 <edwardk> in my case i kinda want to steal back ; and {} for other purposes which encourages heavy use of layout (using something heavier like {|  |} and ;; for when they are explicitly needed)  so having a powerful layout is kinda important
20:00:31 <edwardk> that or if i'm desperate enough i can just not have a { } symbol, since you can always (do something; x <- foo) or (case something of x -> y)
20:00:50 <jbauman> it would be ust like sml
20:00:53 <jbauman> *just
20:00:57 <edwardk> the ;; ?
20:01:09 <jbauman> parentheses everywhere
20:01:29 <edwardk> well, i'm rather parenthesis-phobic, hence why i want layout to just work ;)
20:07:27 <bos> @seen dibblego
20:07:27 <lambdabot> dibblego is in #haskell, #scala and #jtiger. I last heard dibblego speak 8m 53s ago.
20:07:55 <dibblego> hello
20:10:20 <sorear> bos: I tried to subscribe today to RWH, it didn't succeed
20:10:47 <bos> well bugger. privmsg your email addy to me and i'll subscribe you
20:10:47 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
20:11:22 <dibblego> sorear, worked for me, about 4 or so hours ago
20:13:13 <bos> we have so many comments on the first draft chapters of the book that i'm going to have to write a comment management subsystem to deal with them.
20:13:22 <dibblego> heh
20:13:39 <sorear> in Haskell? :P
20:14:04 <bos> sorear: i used django instead of happs.
20:16:24 <sorear> bos: that URL you gave me doesn't exist, and its truncation leads to a software company rather than a book site
20:16:37 <sorear> er
20:16:38 <sorear> bah
20:16:57 <bos> how interesting.
20:17:09 <bos> it works for me.
20:17:11 * sorear hates tlds.
20:17:33 <bos> what, has someone registered realworldhaskell.gr?
20:17:38 <ddarius> tlds? tildes? ?
20:17:47 <omniscientIdiot> toplevel domains
20:18:00 <omniscientIdiot> .com .org etc
20:18:11 <sorear> bos: book.realworldhaskell.com exists...
20:18:16 <sorear> gr?
20:18:41 <bos> as a typo of .org?
20:18:46 <dibblego> sorear, works for me
20:18:56 <dibblego> oh wait, no
20:19:11 <bos> ah, i need to redirect it
20:19:16 <sorear> bos: anyway, I'm in
20:19:16 <sorear> ?
20:19:29 <sorear> somehow I was expecting a forest of pdfs...
20:19:47 <bos> nah, we loves teh htmls
20:20:06 <dons> get ur hwn! http://sequence.complete.org/hwn/20070923
20:20:08 <lambdabot> Title: Haskell Weekly News: September 23, 2007 | The Haskell Sequence
20:20:12 <dons> the 'w' stands for 'whenever' !
20:20:28 <zarvok> heh
20:20:36 <sorear> dons++
20:20:36 <dons> or possibly 'workload'
20:20:53 <dons> can haskell people please write less libraries in future
20:20:56 <dons> there's too much stuff
20:21:09 <sorear> but dons, there's a quota!
20:21:25 <dons> oh damn, we gotta make quota, or we'll lose our privledges
20:23:22 <dons> Your mail to 'Haskell-Cafe' with the subject
20:23:22 <dons>     Haskell Weekly News: September 23, 2007
20:23:22 <dons> Is being held until the list moderator can review it for approval.
20:23:22 <dons> The reason it is being held:
20:23:22 <dons>                             
20:23:24 <dons>     Message body is too big
20:23:28 <dons> see what i mean!!
20:23:59 <omniscientIdiot> someone poke the mod
20:24:21 <sorear> @seen Igloo
20:24:21 <lambdabot> Igloo is in #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 10h 28m 15s ago.
20:24:24 * dons is the mod :)
20:24:36 <omniscientIdiot> well then poke yourself!
20:25:48 <allbery_b> apparently he did :)
20:25:52 <dons> done.
20:25:57 * allbery_b just watched it arrive
20:26:45 <notsmack> dons++
20:26:50 * allbery_b considers sugggesting that the weekly news would be shorter if it were, er, weekly
20:26:55 <allbery_b> :)
20:27:02 <dons> that's an interesting thought.
20:27:03 <allbery_b> dons++ yes I know you've been a bit busy
20:29:30 <dons> http://programming.reddit.com/info/2ssnz/comments :)
20:29:31 <lambdabot> Title: Haskell Weekly News: Truckloads of new libraries! User groups! Jobs! Comedy! (re ...
20:30:31 <ramza3> newb question; can I not define functions when using gchi/prelude?
20:30:41 <zarvok> haha! The "haskell curry? yes I dated his daughter." blog link in the hwn is great!
20:30:44 <shachaf> ramza3: Use let.
20:31:13 <shachaf> "let f x = x + 1", "f 5"
20:31:27 <ramza3> cool
20:31:32 <allbery_b> you can define things with let, note that if you :reload they will be lost.  if you want them to be persistent put them in a .hs file and load it
20:31:39 <shachaf> dons: "OzHaskell, and Australian haskell user's group."
20:31:55 <shachaf> ramza3: If you need more than one line at a time, use ;.
20:32:01 <dons> shachaf: ah oops
20:32:39 <shachaf> I guess it's too late to fix it now. :-)
20:33:33 <dons> nah, well, sort of partially fixed
20:33:43 <dons> since i own the interwebs. mwhahaha!
20:33:52 <fax> :o
20:34:43 <dons> well, i have a login on sequence.complete.org. one of the smaller interwebs
20:35:49 <shachaf> The Haskell mode for vim looks interesting.
20:36:26 <dons> it seems people really rely on the hwn to track all the different goings on, eh?
20:36:55 <allbery_b> I tend to collect hwns instead of all the individual announcements, certainly
20:37:12 <allbery_b> convenient way to keep track of what's been released
20:37:16 <dons> yeah
20:37:36 <dons> the multiformat aggregator of haskell news
20:37:55 * scsibug throws a new library out into the world (haskell S3 out on hackage now)
20:38:11 <dons> cool, scsibug
20:38:39 <scsibug> now...what's the news on getting ByteStrings for the HTTP library?
20:39:15 <scsibug> because I can cook up some pretty scary benchmarks on what happens when multi-megabyte files get sent with it :)
20:40:26 <dons> mm. i thought we had some bytestring http already
20:40:40 <dons> certainly in happs, and in last year's network library project for SoC
20:40:47 <scsibug> I saw it mentioned, but I thought it needed to be merged in with the main HTTP
20:41:00 <dons> main http ain't so hot anyway though :)
20:41:21 <scsibug> what would be ideal to use?
20:41:44 <dons> i'd probably roll my own. but you better do a survey of hackage libs at least, since something might have crept in without us noticing
20:41:59 <dons> have you written up anything else on the s3 bindings?
20:42:06 <dons> http://scsibug.com/hS3 ah yes
20:42:08 <lambdabot> Title: Index of /hS3
20:42:12 <dons> kind of
20:42:28 <scsibug> I've just made a post on my blog (http://scsibug.com)
20:42:29 <lambdabot> Title: scsibug.com
20:42:31 <dons> this looks really useful.
20:42:49 <dons> ah, wonderful
20:42:50 <scsibug> I would like to have a hask-home style site, but I couldn't get that program working
20:43:12 <dons> mm. yeah, String sucks.
20:43:15 <scsibug> I set a hard deadline for myself of one week start-to-initial-release for this ;)
20:43:18 <dons> but we definitely have http for bytestrings
20:43:33 <scsibug> so, more work to be done, but at least I have something out there, instead of sitting on my disk
20:43:35 <dons> bringert uses it for some file download program, iirc
20:43:55 <dons> scsibug: you another vegan haskeller? :)
20:44:01 <scsibug> indeed :))
20:44:07 <scsibug> are there more out there?
20:44:07 <dons> that makes a club of two, I think :)
20:44:18 <mudge> dons: the weekly news is really nice
20:44:20 <scsibug> who else?
20:44:26 <dons> well, you and me.
20:44:31 <scsibug> oh, sweet :)
20:44:41 <dons> dcoutts is close, but addicted to cheese
20:44:45 <ddarius> I think there are a few more.
20:44:46 <scsibug> congrats on the job at Galois by the way.
20:44:47 <ddarius> At least.
20:44:48 <pjd> dons is vegan?
20:44:54 <dons> scsibug: cheers
20:44:56 <dons> pjd: yeah.
20:44:56 <ddarius> pjd's world shatters
20:45:04 * pjd notes down
20:45:10 <dons> hah
20:46:16 <mudge> bos,  when are you going to build the CMSS comment management subsystem?
20:46:31 <bos> mudge: soon, i guess
20:46:40 <dons> mm. i wonder if i can swing some aggregator stuff into my work project.
20:47:09 <dons> bos, i'm tired. what bytestring http stuff do we have?
20:47:49 * dons tries to remember what bringert's big file downloader was called
20:48:02 <dons> he had multi-gig files downloaded via lazy bytestrings, scsibug
20:48:07 <dons> which is kind of what you want to do, right?
20:48:09 <shachaf> Is there a reason haskell.org (without www.) is suddenly pointing to Google for me?
20:48:19 <shachaf> Is that just over here?
20:48:26 <dons> your interwebs are blocked
20:48:31 <dons> works fine here.
20:48:47 <jcreigh> shachaf: "pointing to Google"?
20:48:50 <shachaf> dons: Well, you own them. Fix it.
20:48:53 <scsibug> dons: sweet, investigating how to incorporate that will probably be tops on my priority list.
20:48:58 <dons> scsibug: i think switching over to bytestrings should be a main priority.
20:49:01 <dons> oh, yes. as you say. :)
20:49:19 <dons> you might even just want to write your own micro bytestring http
20:49:24 <dons> see then you'll also want bytestring Crypto
20:49:30 <dons> which i think dominic is working on
20:50:02 <bos> dons: don't know of any bytestring http stuff, alack
20:50:20 <bos> dominic is lazily evaluating the bytestring crypto stuff.
20:50:27 <dons> yeah
20:50:29 <shachaf> Hmm, odd. This only happens in Opera.
20:50:54 <dons> http://darcs.haskell.org/SoC/haskellnet.lgpl/HaskellNet/
20:50:55 <scsibug> Crypto isn't a performance issue for me, since S3 doesn't require you do anything with the body of the request.
20:50:56 <lambdabot> Title: Index of /SoC/haskellnet.lgpl/HaskellNet
20:50:58 <dons> is certainly a bytestring http
20:51:06 <shachaf> Never mind, I guess.
20:51:13 <dons> i'd just use openssl or similar on bytestrings , scsibug
20:51:27 <dons> but the main thing is to get a non-copying bytestring io going on
20:51:44 <dino-_> dons: HWN! Thank you!
20:51:49 <dons> scsibug: btw, vegan + portland == good mix.
20:52:22 <dons> dino-_: cheers. gotta get some more automation into it though. the traffic is higher than it used to be, so human aggregator becomes a bit of a bottleneck...
20:52:23 <scsibug> dons: I've got friends in portland, and was up there for ICFP, it is great :)
20:53:10 <dons> scsibug: we should get your blog on planet.haskell.org
20:53:21 <dons> otherwise too many people miss the posts.
20:53:42 <scsibug> how does that work, does every post get pushed over, or just haskell-related ones?
20:54:26 <dons> depending on tags and your blog software
20:54:33 <scsibug> Ah, cool
20:54:38 <dons> do you have rss feeds?
20:54:43 <scsibug> yes
20:55:15 <mudge> antti juhani says planet haskell is also about people
20:55:22 <dons> ok, the thing to do then is find a feed url you feel comfortable with appearing on planet haskell (non-fp content is fine!) , and hand that to ibid.
20:55:36 <scsibug> OK, sounds good
20:55:44 <dons> ibid: scsibug has a nice blog for inclusion, http://scsibug.com/. he'll find a feed for you :)
20:55:45 <mudge> he's the guy to email
20:55:45 <lambdabot> Title: scsibug.com
20:55:59 <mudge> not everything on haskell planet has to be about haskell
20:56:02 <mudge> ibid told me
20:56:15 <dons> everything on scsibug.com looks fine for p.h.o
20:56:17 <mudge> so it would be okay for some posts not to be about haskell
20:56:26 <dons> we've got people on there who never write about haskell
20:56:32 <mudge> there we go
20:56:39 <dons> ozone: <- i'm looking at you boyo.
20:56:53 <dons> this erlang stuff. flash in the pan ;)
20:58:08 <Lycurgus> speaking of flash in the pan, I'm happy with GF but what did happen to LOLITA?
20:58:35 <Lycurgus> (although I guess 10 years is a longish flash)
20:59:11 <dons> more of a tyre fire?
21:00:15 <bos> dons: i've been planning to do bytestring/http stuff for the reverse http proxying chapter.
21:00:54 <bos> along with using stepcut's bytestring parsec-alike to provide a http header parser.  (not so sure about that, though.)
21:01:17 <dons> hmm. yes.
21:01:23 * dons `ap` dinner
21:01:53 <bos> return ()
21:02:29 <FMota> oh, I never thought of using `f` x to mean flip f x
21:02:54 <ddarius> @pl flip f x
21:02:54 <lambdabot> flip f x
21:03:01 <ddarius> @pl (`f` x)
21:03:01 <bos> it takes a long time to learn all the little tricks.
21:03:02 <lambdabot> (`f` x)
21:03:23 <bos> people get all wigged out by stuff like using "flip fix" to write loops, too.
21:03:45 <FMota> :o
21:03:59 <sjanssen> @type flip fix
21:03:59 <bos> after 20 years, a fair bit of the haskell community that was around in 1987 is *still* learning the tricks.
21:04:01 <lambdabot> forall b c. b -> ((b -> c) -> b -> c) -> c
21:04:34 <bos> flip fix 0 \loop counter -> if counter == 100 then return "foo" else loop (counter + 1)
21:04:39 <ddarius> > flip fix 5 $ \fac n -> if n < 2 then 1 else n*fac (n - 1)
21:04:41 <lambdabot>  120
21:04:46 <ddarius> > flip fix 5  \fac n -> if n < 2 then 1 else n*fac (n - 1)
21:04:46 <lambdabot>  Parse error
21:05:14 * omniscientIdiot squints
21:05:22 <bos> "flip fix" can beat up common lisp's do loops any day
21:06:45 * omniscientIdiot thinks aloud: "the (b -> c) is the function being fixed, in this case fac, and the flip allows the arg to be passed first, makes sense"
21:13:04 <sorear> bos: login broke
21:13:20 <ramza3> hmm, something is wrong with my code; what am I doing wrong (besides only using haskell for 2 days); http://hpaste.org/2883
21:13:34 <bos> sorear: oh?
21:13:55 <bos> sorear: 's working for me
21:14:05 <bos> @hoogle mappend
21:14:09 <lambdabot> Data.Monoid.mappend :: Monoid a => a -> a -> a
21:14:09 <allbery_b> ramza3: for starters, "get" doesn't take an argument
21:14:11 <sorear> ramza3: what's a SimplePlayer?
21:14:24 <allbery_b> :t get
21:14:30 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
21:14:39 * bos is a bit mystified by regex-tdfa not building
21:14:46 <sorear> bos: that u/p you gave isn't working for the second chapter
21:14:54 <tehgeekmeister> has there been any sort of work on erlang style concurrency in haskell?  just curious.
21:15:12 <sorear> still works for the first though
21:15:21 <bos> sorear: i'm not seeing that problem - what's the failing url?
21:15:23 <ramza3> sorear, data SimplePlayer = SimplePlayer { angle :: GLfloat }
21:15:34 <ramza3> sorear, and some other fields
21:15:38 <ddarius> tehgeekmeister: You get some of that with (T)Chans and a long time ago there were also ports for distribution.
21:15:46 <sorear> tehgeekmeister: we have all the bits and pieces, in the form of reactive objects and channels
21:16:06 <tehgeekmeister> okay, cool.
21:16:20 <tehgeekmeister> may have to play with that someday.
21:16:22 <bos> the piece of glue that's missing is network-transparent channels
21:16:29 <ddarius> ports
21:16:36 <sorear> ramza3: ... why are you using monad sugar?  SimplePlayer is a value
21:16:37 <ddarius> @google Manuel Chakravarty ports
21:16:37 <lambdabot> No Result Found.
21:16:42 <ddarius> @google Haskell ports
21:16:45 <lambdabot> http://freshmeat.net/projects/ports/
21:16:45 <lambdabot> Title: freshmeat.net: Project details for Haskell Ports Library
21:16:46 <bos> ddarius: it was some germans, not manuel
21:17:01 <bos> ah, different ports
21:17:07 <ddarius> http://www.cse.unsw.edu.au/~chak/haskell/ports/
21:17:07 <lambdabot> Title: The Haskell Ports Library
21:17:15 <ddarius> @where+ ports http://www.cse.unsw.edu.au/~chak/haskell/ports/
21:17:16 <lambdabot> Done.
21:17:18 <ddarius> What the hey.
21:17:44 <bos> @hoogle mplus
21:17:46 <lambdabot> Control.Monad.mplus :: MonadPlus m => m a -> m a -> m a
21:18:09 <sorear> bos: and now it's working again... go figure
21:18:47 <bos> sorear: what browser?
21:19:06 <bos> ddarius: i was thinking of http://www.google.com/url?sa=t&ct=res&cd=5&url=http%3A%2F%2Fwww-i2.informatik.rwth-aachen.de%2FForschung%2FdistributedHaskell%2Fifl2001.ps.gz&ei=dDr3Ro7bN4zCgwOQxcTABA&usg=AFQjCNGa4MD8n4T_mNHQIFc-40QArNhwSA&sig2=1rsOk64WB7w2CCl2OYbWAg
21:19:09 <lambdabot> http://tinyurl.com/2ymr46
21:19:22 <sorear> bos: elinks
21:19:22 <bos> augh, http://www-i2.informatik.rwth-aachen.de/Forschung/distributedHaskell/ifl2001.ps.gz
21:19:24 <lambdabot> http://tinyurl.com/3yddma
21:19:28 <bos> friggin google links
21:19:42 <bos> sorear: you need a browser that does javascript to use the comment system
21:20:27 <sorear> bah.
21:22:11 <sorear> bos: " For a short sentence, this one gives us a lot to pore over." <- pore looks misspelled
21:22:59 <bos> it's not, but i need to drop that word anyway. it's caused enough confusion.
21:23:01 <shteou> :o
21:24:21 <sorear> Int is 32 or 64 bits under GHC, not 31 or 63
21:24:27 <notsmack>    1.  To read or study carefully and attentively: pored over the classified ads in search of a new job.
21:24:27 <notsmack>    2. To gaze intently; stare.
21:24:27 <notsmack>    3. To meditate deeply; ponder: pored on the matter.
21:25:59 <bos> sorear: thank you, but please don't feed me comments in irc. i can't do anything with them. i have over a thousand to wade through on the web site already.
21:44:46 <timthelion> http://timtheli.freeshell.org/focusN.hs is it possible to do guards like that?
21:45:04 <timthelion> right now it says parse error on |
21:45:13 <bos> timthelion: no
21:45:21 <bos> what's "| _" supposed to mean?
21:45:22 <timthelion> so I need an if statement?
21:45:32 <timthelion> well I thought it matched anything
21:45:38 <bos> no, that's in a pattern
21:45:43 <bos> "| otherwise" would be correct
21:45:53 <timthelion> would True work?
21:45:53 <bos> or "| True" (less idiomatic, though)
21:45:54 <omniscientIdiot> a guard is an expression with type Bool
21:46:04 <omniscientIdiot> yes, True works, as does otherwise:
21:46:07 <omniscientIdiot> @src otherwise
21:46:07 <lambdabot> otherwise = True
21:46:31 <monochrom> The definition of pops' makes no sense for a human being.
21:46:44 <timthelion> how come?
21:46:54 <monochrom> Err sorry. Not all of the definition. The second part.
21:47:18 <timthelion> you have something against parens?
21:47:41 <omniscientIdiot> is pops take?
21:47:42 <monochrom> So, presumably, "pops' (l:ls) n = ..." is already the last case, and it has no guard.
21:47:56 <omniscientIdiot> @src take
21:47:56 <lambdabot> take n _      | n <= 0 =  []
21:47:56 <lambdabot> take _ []              =  []
21:47:56 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
21:48:08 <monochrom> So what does " | otherwise = ... " do?
21:48:22 <bos> maybe it belongs to the very first function?
21:48:49 <monochrom> It belongs to focusN?
21:49:13 <bos> i'm just guessing.
21:49:23 <monochrom> Well, a "where" is not allowed between two guards.
21:49:44 <omniscientIdiot> yeah, where clauses scope over all guards
21:49:53 <monochrom> Not to mention that the indentation completely obscures it.
21:51:19 <timthelion> ok, I uploaded a new versoin
21:51:26 <timthelion> but it fails to parse on where
21:51:52 <timthelion> the first where
21:51:59 <omniscientIdiot> timthelion: if you want local names like that, use let
21:52:00 <timthelion> which I really don't understand.
21:52:04 <monochrom> You are still not allowed "where" inside if-then-else -_-;
21:52:10 <omniscientIdiot> timthelion: where is part of the function definition syntax
21:52:49 <omniscientIdiot> let name = val; name = val in expr
21:53:06 <omniscientIdiot> (or indentation instead of semicolons)
21:53:56 <monochrom> @src gcd
21:53:56 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
21:53:56 <lambdabot> gcd x y = gcd' (abs x) (abs y)
21:53:56 <lambdabot>    where gcd' a 0  =  a
21:53:56 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
21:54:04 <timthelion> ok, thankyou let seems to have cleared up things
21:58:01 <monochrom> timthelion: You can also try something like this: http://www.vex.net/~trebla/haskell/calculator/Calculator.hs  look for euclid'
21:58:15 <omniscientIdiot> timthelion: look at the 'take' and 'drop' functions.  I think you've reimplemented them.
21:58:22 <omniscientIdiot> > take 3 [1..10]
21:58:24 <lambdabot>  [1,2,3]
21:58:31 <omniscientIdiot> > drop 6 [1..10]
21:58:32 <lambdabot>  [7,8,9,10]
21:59:12 <timthelion> ok
21:59:35 <timthelion> those look like what I attempted to write
22:00:54 <fax> > ((take 3) &&& (drop 6)) [1..10]
22:00:57 <lambdabot>  ([1,2,3],[7,8,9,10])
22:01:21 * omniscientIdiot clubs fax on the head with an ampersand
22:01:32 <fax> :P
22:02:48 <timthelion> I uploaded a new version inwhich it says
22:02:49 <timthelion>     Couldn't match expected type `W.Stack a'
22:02:49 <timthelion> 	   against inferred type `[a] -> W.Stack a'
22:03:00 <timthelion> and it says for the whole if statement
22:03:11 <timthelion> no closer look at the faliur to typecheck
22:04:39 <omniscientIdiot> timthelion: looks like you forgot an arg on the last line.
22:04:58 <timthelion> ah yes
22:05:23 <timthelion> yay, it compiles
22:05:39 <timthelion> and I can replace the whole thing with a one liner usnig take and drop
22:05:42 <timthelion> :)
22:06:17 <omniscientIdiot> what does it *do*?
22:06:32 <Syzygy-> :t curry
22:06:34 <timthelion> focuses the n'th element of a Stack
22:06:34 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:06:35 <shteou> Don't concern yourself with such trivial questions, omniscientIdiot :p
22:06:57 <shteou> When has one ever needed to know what something *does* to use it? :>
22:07:28 <Syzygy-> > uncurry (++) . ((take 3) && (drop 6)) $ [1..10]
22:07:29 <lambdabot>  Couldn't match expected type `Bool'
22:07:48 <Syzygy-> > uncurry (++) . ((take 3) &&& (drop 6)) $ [1..10]
22:07:49 <lambdabot>  [1,2,3,7,8,9,10]
22:08:09 <timthelion> focusN :: Int -> W.Stack a -> W.Stack a
22:08:10 <timthelion> focusN n (W.Stack t ls rs) = let ws = ls ++ t:rs W.Stack (head (drop n ws)) (take n ws) (drop n ws)
22:08:13 <monochrom> The stack is possibly part of an abstract machine for a lambda calculus.
22:08:14 <timthelion> that's my new function
22:08:34 <timthelion> oops forgot the in
22:09:04 <monochrom> With luck, it may even be one that supports delimited continuations.
22:09:20 <omniscientIdiot> I understand that version! :)
22:09:53 <omniscientIdiot> @check \xs n -> head (drop n xs) == xs !! n
22:09:54 <lambdabot>  Add a type signature
22:10:04 <omniscientIdiot> @check \xs n -> head (drop n xs) == xs !! n :: T -> I -> Bool
22:10:05 <lambdabot>  Couldn't match expected type `T -> I -> Bool'
22:10:48 <omniscientIdiot> anyway, I think (head (drop n xs)) = (xs !! n)
22:10:55 <omniscientIdiot> timthelion: ^^
22:14:37 <omniscientIdiot> > ((head . drop 4) &&& (!! 4)) [5..20]
22:14:39 <lambdabot>  (9,9)
22:17:39 <omniscientIdiot> > "aah!" >>= replicate 8
22:17:41 <lambdabot>  "aaaaaaaaaaaaaaaahhhhhhhh!!!!!!!!"
22:19:18 <Pseudonym> > "arr!" >>= replicate 4
22:19:20 <lambdabot>  "aaaarrrrrrrr!!!!"
22:19:50 <omniscientIdiot> > cycle "LO"
22:19:52 <lambdabot>  "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL...
22:19:58 <fax> lol
22:20:07 <bos> @pl \(a,b) -> (b,a)
22:20:08 <lambdabot> uncurry (flip (,))
22:20:56 <fax> > (fix (cycle . replicate 2)) "hum"
22:20:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
22:20:57 <lambdabot>       Expected...
22:21:02 <fax> tsk
22:21:09 <Tac-Tics> > last $ cycle ["Chicken", "Egg"]
22:21:13 <lambdabot> Terminated
22:21:15 <nornagon> ha
22:21:18 <Tac-Tics> the world may never know
22:21:27 <fax> last? :P
22:21:30 <nornagon> > first $ cycle ["Chicken", "Egg"]
22:21:31 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
22:21:38 <fax> what came *last* the chicken or the egg
22:21:38 <nornagon> > head $ cycle ["Chicken", "Egg"]
22:21:40 <lambdabot>  "Chicken"
22:22:21 <fax> :t interleavae
22:22:23 <lambdabot> Not in scope: `interleavae'
22:22:28 <fax> :t interleave
22:22:30 <lambdabot> Not in scope: `interleave'
22:23:01 <monochrom> The chicken probably comes last.
22:23:24 <omniscientIdiot> > intersperse 'O' (repeat 'L')
22:23:25 <lambdabot>  "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL...
22:23:54 <fax> @src cycle
22:23:55 <lambdabot> cycle [] = undefined
22:23:55 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
22:23:58 <fax> @src repeat
22:23:58 <lambdabot> repeat x = xs where xs = x : xs
22:24:03 <fax> > repeta []
22:24:04 <lambdabot>   Not in scope: `repeta'
22:24:06 <fax> > repeat []
22:24:07 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
22:24:27 <fax> > cycle [[]]
22:24:28 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
22:24:53 <fax> cycle = concat repeat ?
22:25:12 <Pseudonym> ?src cycle
22:25:12 <lambdabot> cycle [] = undefined
22:25:12 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
22:25:31 <Pseudonym> Not quite.
22:25:39 <Pseudonym> > concat (repeat [])
22:25:39 <fax> > concat $ repeat []
22:25:41 <lambdabot>  Exception: <<loop>>
22:25:42 <lambdabot>  Exception: <<loop>>
22:25:48 <Pseudonym> > cycle []
22:25:49 <lambdabot>  Exception: Prelude.cycle: empty list
22:26:00 <Pseudonym> Apart from that, likely to be the same.
22:26:11 <Pseudonym> > concat (repeat [1..])
22:26:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:26:17 <dibblego> > repeat []
22:26:19 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
22:26:19 <Pseudonym> > cycle [1..]
22:26:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:26:24 <sclv> > concat (repeat [1,2,3])
22:26:26 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
22:26:49 <kawfee> repeat[1..,10]
22:26:55 <kawfee> > repeat[1..,10]
22:26:55 <lambdabot>  Parse error
22:27:02 <fax> @pointless (\x ->x ++ (reverse x))
22:27:02 <lambdabot> ap (++) reverse
22:27:04 <kawfee> maybe I am thinking range
22:27:26 <omniscientIdiot> kawfee: you got an extraneous comma
22:27:29 <fax> > cycle $ ap (++) reverse $ [1..10]
22:27:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,10,9,8,7,6,5,4,3,2,1,1,2,3,4,5,6,7,8,9,10,10,9,8,7,6,5...
22:28:19 * omniscientIdiot derived ((->) r)'s ap a while ago.  Pasting...
22:29:40 <omniscientIdiot> hpaste: you announcing?
22:29:48 <omniscientIdiot> http://hpaste.org/2884
22:34:10 <ibid> dons: i'm going through the planet blog list and seeing if they qualify, thanks to your comments above
22:36:24 <ibid> (done)
22:36:31 <ibid> (sent queries to yt
22:36:37 <ibid> two people(
22:36:37 <ibid> )
22:41:00 <dibblego> ?where mapreduce
22:41:00 <lambdabot> I know nothing about mapreduce.
22:46:31 <omniscientIdiot> @quote discovery.of.fire
22:46:32 <lambdabot> bootslack says: Once, around the time of the discovery of fire, there was a large population of people that thought mastering fire would be too difficult so they didn't. The rest of us killed them,
22:46:32 <lambdabot> cooked them and ate them.
22:49:12 <glguy> Can you ever have too much Silly Putty?
22:49:45 <Pseudonym> Of course you can.
22:50:04 <Pseudonym> There are billions in the world today without silly putty.
22:52:46 <Tac-Tics> @src liftM
22:52:46 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:52:55 <Tac-Tics> @src liftM2
22:52:55 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:54:59 <swix> I was wondering if there was any good docs on writting a show function for my class? I'm not sure how to do it just yet?
22:55:16 <Pseudonym> swix: What is this "class" of which you speak?
22:55:21 <monochrom> your class? your type?
22:55:32 <swix> yeah, my type, sorry
22:55:39 <Pseudonym> Is deriving (Show) insufficient?
22:55:41 <swix> haskell still toying with my imperative mind
22:55:46 <monochrom> SOE has one.
22:55:52 <swix> somewhat, it's kinda ugly how it turns out
22:56:14 <swix> I'm also trying to learn, with show, how to derive classes in general
22:56:17 <Pseudonym> Sure.
22:56:27 <fax> There is a custom show here http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/evaluator1.html#show
22:56:31 <omniscientIdiot> instance Show YourType where
22:56:36 <omniscientIdiot> show value = ...
22:56:48 <Pseudonym> One thing, though.
22:56:56 <Pseudonym> And I'd like to get some expert opinions on this.
22:57:07 <Pseudonym> Show and Read are _supposed_ to work together.
22:57:17 <Pseudonym> I'm not 100% sure if encouraging people to overload Show is a good idea.
22:57:54 <swix> so, if I just deriving(Show) I automatically get Read support?
22:58:01 <Pseudonym> No.
22:58:03 <Pseudonym> That's the problem.
22:58:32 <swix> so I have to implement both to be fair and good to the world?
22:58:38 <omniscientIdiot> if you derive Read and Show, the generated instances should be such that read and show are inverses.
22:58:49 <Pseudonym> Right.
22:59:10 <monochrom> Supposedly you implement both Show and Read and make sure they work together, manually or automatically.
22:59:20 <swix> alright, I'll keep that in mind
22:59:21 <omniscientIdiot> It's not a *requirement*, though.
22:59:30 <Pseudonym> It's in the standard.
22:59:34 <omniscientIdiot> oh?
22:59:46 <Pseudonym> Well, it's not technically a standard.
22:59:48 <Pseudonym> It's in the report.
23:00:20 <swix> is there a reference for Haskell besides the language definition... something similar to the Java API docs?
23:00:46 <sjanssen> @docs
23:00:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
23:00:51 <sjanssen> swix: like that?
23:01:29 <swix> heh, exactly
23:01:41 <omniscientIdiot> Pseudonym: the report says the derived instances are specified that way, but it isn't required AFAICT.
23:02:10 <omniscientIdiot> http://www.haskell.org/onlinereport/basic.html#sect6.3.3
23:02:11 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
23:02:17 <Pseudonym> Hmm, OK.
23:02:42 <Pseudonym> Generally speaking, if I want pretty printing, I do that rather than Show.
23:02:57 <omniscientIdiot> "Strings produced by showsPrec are usually readable by readsPrec."  Note 'usually'.
23:05:04 <monochrom> We kind of accept breaking that by an information-less implementation for functions. It just says "I'm a function".
23:08:05 <scodil> do SPECIALIZE pragmas have an effect if the function ends up being inlined?
23:09:00 <Pseudonym> I would suspect that it depends whether or not the call site is specialised or not.
23:09:08 <Pseudonym> Err...
23:09:18 <Pseudonym> Redundant sentence, but you know what I mean.
23:09:39 <omniscientIdiot> or not :)
23:10:35 <scodil> if there was an effect I'd see it in -ddump-simpl, right?
23:10:50 <Pseudonym> No doubt.
23:13:11 <swix> lol, I always find it funny when I'm looking up something benign and i find myself on my university's domain
23:25:05 <aegis17> Hey, I've been working on a haskell problem for my programming languages class for several hours now... it's a stupid easy question, but I am getting something wrong
23:25:36 <aegis17> Hey, I've been working on a haskell problem for my programming languages class for several hours now... it's a stupid easy question, but I am getting something wrong
23:25:37 <omniscientIdiot> ask away
23:25:46 <aegis17> I need to reverse a list
23:25:51 <aegis17> without using the reverse function
23:26:14 <P_D> How would you reverse a list of two elements?
23:26:47 <omniscientIdiot> start smaller, what would reverse [] equal?
23:26:52 <aegis17> []
23:27:04 <omniscientIdiot> what about reverse (x:xs)?
23:27:33 <omniscientIdiot> do you understand that syntax?
23:27:43 <aegis17> [reverse(xs), x]?
23:27:56 <omniscientIdiot> close.
23:28:27 <omniscientIdiot> you get the idea, reverse xs, then tack x onto the end
23:28:37 <aegis17> yeah
23:28:56 <omniscientIdiot> you're allowed to use (++)?
23:28:59 <aegis17> The best I got is myreverse n = if n == [] then [] else ((myreverse (tail n)) : ((head n) : []))
23:29:05 <Cale> however, [reverse xs, x] represents a two element list (whose elements are reverse xs and x)
23:29:31 <Cale> So you don't really want that, you want the concatenation of reverse xs with the one element list [x]
23:29:38 <omniscientIdiot> (which, by the way, doesn't type)
23:30:00 <aegis17> I don't know what (++) is
23:30:08 <aegis17> but as far as I know, it's kosher.
23:30:11 <omniscientIdiot> > "con" ++ "cat"
23:30:12 <Cale> > [1,2,3] ++ [4,5]
23:30:13 <lambdabot>  "concat"
23:30:14 <lambdabot>  [1,2,3,4,5]
23:30:17 <aegis17> Oh.
23:30:36 <Cale> You might try writing it yourself first :)
23:30:46 <Cale> It's also a good little exercise
23:31:29 * omniscientIdiot restrains himself from asking LB
23:32:52 <aegis17> okay, so myreverse n = if n == [] then [] else (( myreverse (tail n)) ++ head n) compiles just fine, but throws an error when I try to run it: cannot infer instance
23:33:11 <aegis17> wait... if ++ is concat, what was :?
23:33:16 <omniscientIdiot> cons
23:33:25 <Cale> (:) adds an element to the start of a list
23:33:37 <omniscientIdiot> singleElement : restOfList, vs. leftList ++ rightList
23:33:40 <Cale> (:) is special because you can pattern match with it
23:33:56 <aegis17> I see omniscientIdiot, thanks for that clarification.
23:34:04 <Cale> By the way, I recommend pattern matching rather than using that if-then-else and head/tail
23:35:11 <aegis17> I can do this without using Head and Tail?
23:35:15 <Cale> yeah
23:35:29 <Cale> also, without ==
23:35:52 <omniscientIdiot> > let reverse [] = []; reverse (x : xs) = reverse xs ++ [x] in reverse "blah"
23:35:52 <Cale> (which in this case, makes the type of reverse more restrictive than it should be
23:35:53 <Cale> )
23:35:53 <lambdabot>  "halb"
23:36:19 <Cale> If you want to test if a list is empty, it's better to use null than (== [])
23:36:24 <Cale> :t null
23:36:26 <lambdabot> forall a. [a] -> Bool
23:36:29 <Cale> :t (== [])
23:36:31 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
23:37:02 <Cale> (== []) only works when it's possible to compare the elements of the list for equality, because of the way that == works
23:37:08 * omniscientIdiot tries to think of a non-Eq type to illustrate the difference, fails.
23:37:53 <Cale> > null [reverse, id]
23:37:55 <lambdabot>  False
23:37:59 <Cale> > [reverse, id] == []
23:38:00 <lambdabot>   add an instance declaration for (Eq ([a] -> [a]))
23:38:00 <lambdabot>     In the expression: [r...
23:38:03 <omniscientIdiot> thx
23:39:01 <aegis17> Cale: how do I test for null in code, rather than directly to the interpreter?
23:39:15 <Cale> aegis17: exactly the same way, or else you pattern match
23:39:43 <Cale> Usually you don't just want to know if the list is null or not, you want to break it apart if it's not null
23:39:52 <Cale> So that's where pattern matching is better
23:40:05 <Cale> f [] = ... what f should be when applied to the empty list ...
23:40:22 <Cale> f (x:xs) = ... what f should be when the list has at least one element ...
23:40:35 <Cale> For example,
23:40:37 <aegis17> And I can type that straight into code?
23:40:40 <Cale> yep
23:40:44 <Cale> length [] = 0
23:40:50 <Cale> length (x:xs) = 1 + length xs
23:41:03 <omniscientIdiot> aegis17: in ghci, you have to introduce new names with 'let'
23:41:51 <omniscientIdiot> let f [] = ...; f (x:xs) = ...
23:41:52 <aegis17> I am using hugs, but I assume they are the same anywyas
23:42:05 <Cale> Oh, in hugs you must put declarations in a file
23:42:18 <Cale> (which you're actually better off doing anyway, imo)
23:43:29 <monochrom> REPLs are confusing.
23:44:30 <asl> I once wrote a scheme REPL
23:44:32 <asl> in scheme
23:44:36 <asl> it was pretty easy
23:45:54 <omniscientIdiot> . o O ("(loop (print (eval (read))))" would make an interesting tattoo...)
23:46:11 <asl> ^_^
23:46:51 <aegis17> Oh, hawt, I got it, thanks a ton =D
23:47:08 <omniscientIdiot> now write (++)
23:47:15 <aegis17> and it sorta makes sense too
23:47:25 <omniscientIdiot> good!
23:48:07 <aegis17> Now I need to do the same for scheme and ML... and something slightly different for java and C and prolog.
23:49:04 <asl> aegis17: this sounds like a fun class
23:49:13 <Cale> aegis17: Learning 6 languages at the same time?
23:49:22 <aegis17> At least the java and C parts will be easy for me.
23:49:49 <monochrom> learn in bulk and save
23:49:55 <aegis17> Technically, I did take a course in scheme some 5 years ago, so in theory I should be able to crank that one out in about 10 seconds too, given what I learned from this one
23:49:55 <asl> hah
23:50:11 <omniscientIdiot> monochrom: forgot the (tm)
23:50:34 <aegis17> prolog, scheme, haskell, ml, java, c and pascal
23:51:06 <glguy> what does pascal bring to the party?
23:51:14 <aegis17> I don't know if I'll be doing all assignments in 7 languages throughout the semester or not... it may be just this one, or a handful.  Either way, it's kinda fun in a masochistic kinda way.
23:52:39 <aegis17> Oh, I have to do the reverse function in prolog, c/java/pascal prompt for user input rather than operating on the input list.  They're all the same reverse function I guess.
23:53:23 <Pseudonym> glguy: Pascal is damn easy to learn, and it has a compiler that's not hard to understand the source of.
23:54:44 <omniscientIdiot> > putStr "list? " >> (readLn :: IO [Int]) >>= print . reverse
23:54:46 <lambdabot>  <IO ()>
23:55:01 <olsner> @src readLn
23:55:01 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
23:55:03 <monochrom> If you can prompt the user, you can always say, "please input the list in reverse order, so that I have nothing to do"
23:55:27 <Cale> heh
23:56:02 <Pseudonym> readLn = getLine @@ readIO
23:56:12 <Pseudonym> ?src (@@)
23:56:13 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:56:15 <Pseudonym> Hmm.
23:56:23 <Pseudonym> ?src (Control.Monad.@@)
23:56:23 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:56:29 <omniscientIdiot> (@@) = (>=>), i.e. Kleisli composition?
23:56:33 <Pseudonym> I could have sworn that's in the stanrard library somewhere.
23:56:34 <Pseudonym> Yeah.
23:56:46 <olsner> what's kleisli composition?
23:57:02 <omniscientIdiot> a Kleisli is a function (a -> m b)
23:57:08 <omniscientIdiot> (to simplify a bit)
23:57:12 <Pseudonym> Where m is a monad.
23:57:30 <olsner> so, >>= takes a monad and a kleisli and produces a monad?
23:57:33 <Pseudonym> No.
23:57:41 <Pseudonym> A Kleisli and a Kleisli and returns a Kleisli.
23:57:45 <omniscientIdiot> s/monad/monadic value/g
23:57:49 <omniscientIdiot> but yes
23:57:53 <Cale> Pseudonym: he's talking about >>=
23:58:00 <Pseudonym> Oh, duh.
23:58:01 <Pseudonym> Right.
23:58:05 * Pseudonym needs caffeine
23:58:06 <aegis17> Alright, time to start the scheme version.  Anyone have a scheme interpreter for linux they'd recommend?
23:58:16 <P_D> stalin
23:58:17 <Pseudonym> :t (>=>)
23:58:19 <omniscientIdiot> (>=>) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
23:58:19 <lambdabot> Not in scope: `>=>'
23:58:23 <Pseudonym> There you go.
23:58:24 <P_D> gambit
23:58:33 <Pseudonym> omniscientIdiot makes a good lambdabot.
23:58:35 <olsner> but >=>'d be (a -> m b) -> (b -> m c) -> (a -> m c)
23:58:45 <monochrom> hahahahah
23:58:45 <omniscientIdiot> er, I think I flip'd it, yes
23:58:58 <omniscientIdiot> used to (.)'s order
23:59:22 <olsner> (I could've flipped it - that type was just the logical conclusion of the description of kleisli composition)
23:59:57 <olsner> but the direction of the arrows suggest my order of arguments
