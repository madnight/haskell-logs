00:00:08 <FMota> but you can't really have 1st-class functions in FORTH
00:00:12 <FMota> ciao!
00:14:00 <Weremanatee> here's the time for the C version
00:14:01 <Weremanatee> real    0m0.020s
00:14:01 <Weremanatee> user    0m0.010s
00:14:01 <Weremanatee> sys     0m0.010s
00:14:10 <Weremanatee> for a million points
00:15:39 <Weremanatee> then again...
00:16:00 <Weremanatee> The haskell version calculates 10 million points in a couple of minutes.
00:16:13 <Weremanatee> The C version simply segfaults if given 10 million floats.
00:16:19 <Weremanatee> teehee
00:16:56 <Weremanatee> Well, good night.
00:16:58 <dolio> Haskell isn't ideal for number crunching loops yet.
00:17:01 <dolio> :)
00:17:55 <Weremanatee> it's really not that bad, and you get gc and everything.
00:18:47 <Weremanatee> ... and no segfaults!
00:19:09 <doserj> only stack overflows :)
00:19:21 <Weremanatee> You get those in C as well
00:19:47 <mauke> yeah, but C doesn't annoy you with error messages and stuff
00:19:55 <mauke> it just says Killed
00:20:20 <Weremanatee> Buleted!
00:21:29 <Weremanatee> nor does C annoy you with type errors when you try to do clever things like add one to a boolean.
00:21:42 <fax> boolean?
00:21:58 <mauke> pfft, who needs booleans
00:22:04 <Weremanatee> ...which is another name for a char, right?
00:22:13 <mauke> C has no bool type
00:22:21 <b_jonas> actually, c99 has a boolean (it's stolen from c++ but called differently)
00:22:27 <Cale> data Bool = False | True | FileNotFound
00:22:29 <mauke> yeah, _Bool
00:22:37 <mauke> (it's useless)
00:22:38 <b_jonas> but it's really jsut an integer with range 0..1
00:22:48 <b_jonas> so it is useless indeed
00:22:57 <b_jonas> an int almost always works
00:23:06 <mauke> isTrue = (/= 0)
00:23:12 <Cale> kind of funny to name it with an initial underscore
00:23:28 <Cale> > fromEnum True
00:23:30 <lambdabot>  1
00:23:31 <mauke> (that's the official C definition of truth, btw)
00:23:34 <Cale> > fromEnum False
00:23:35 <lambdabot>  0
00:24:48 <fax> > toEnum 2 :: Boolean
00:24:49 <lambdabot>   Not in scope: type constructor or class `Boolean'
00:24:54 <fax> > toEnum 2 :: Bool
00:24:56 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
00:25:56 <b_jonas> hmm I typed 'let y = -1/1e999999' to a ghci and it's fallen to a cpu-eating loop. why is that?
00:26:31 <b_jonas> I can kill it no problem, I'd just like to know what's happened
00:26:34 <Cale> heh, sweeti
00:26:37 <Cale> -i
00:26:48 <olsner> ghci seems to have problems with very large exponents
00:27:04 <Cale> It's probably actually working out that number as a Rational
00:27:10 <b_jonas> olsner: the reader you mean? reading large exponents?
00:27:17 <b_jonas> oh, it thinks it's a rational? why
00:27:23 <b_jonas> it's in floating point format, isn't it?
00:27:34 <mauke> > 1e99999
00:27:38 <lambdabot>  ghc: failed with error code 9
00:27:39 <dolio> > 1e99 :: Rational
00:27:41 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
00:27:47 <mauke> > 1e9999
00:27:51 <lambdabot>  ghc: failed with error code 9
00:27:55 <olsner> > 1e9999 :: Float
00:27:56 <lambdabot>  Infinity
00:28:01 <b_jonas> -1/1e999999 :: Double takes a long time as well
00:28:07 <mauke> oh, 1e99999 actually terminates and prints "Infinity"
00:28:07 <Cale> The floating point literal f is equivalent to fromRational (n Ratio.% d), where fromRational is a method in class Fractional and Ratio.% constructs a rational from two integers, as defined in the Ratio library. The integers n and d are chosen so that n/d = f.
00:28:09 <b_jonas> but it at least finishes
00:28:10 <mauke> it just takes a while
00:28:33 <Cale> It's computing fromRational (n % d)
00:28:53 <b_jonas> Cale: I thought that happens for integers only
00:29:03 <Cale> No, for integers it's fromInteger
00:29:11 <Cale> (that's a direct quote from H98)
00:29:15 <b_jonas> that is, I thought it might call somethinglike fromFloat for floats
00:29:23 <mauke> > sum [replicate 10 0.1]
00:29:24 <lambdabot>   add an instance declaration for (Num [t])
00:29:24 <lambdabot>     In the expression: sum [repli...
00:29:25 <b_jonas> oh well
00:29:28 <b_jonas> thank you
00:29:30 <mauke> > sum (replicate 10 0.1)
00:29:31 <lambdabot>  0.9999999999999999
00:29:33 <Cale> Floating point values are too restrictive
00:29:35 <mauke> > sum (replicate 10 0.1) :: Rational
00:29:36 <lambdabot>  1%1
00:29:52 <Cale> > 0.9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 :: Rational
00:29:53 <lambdabot>  9999999999999999999999999999999999999999999999999999999999999999999999999999...
00:29:57 <Cale> > 0.9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 :: Double
00:29:59 <lambdabot>  1.0
00:30:09 <Cale> See?
00:30:34 <Cale> If it treated that as a Double first, then when it converted it to a rational, precision would be lost.
00:30:37 <b_jonas> sure, I can always just tell it the exact type when needed
00:30:53 <Cale> It's still going to compute it though.
00:31:00 <Cale> The default type is Double
00:31:25 <Cale> it's just that to interpret floating point literals, it starts out by constructing an appropriate rational number and then converts it
00:31:43 <b_jonas> ah yes, that makes sense
00:31:49 <b_jonas> otherwise you'd lose precision
00:32:43 <b_jonas> ideally, you'd need a decimal bigfloat type which is not good for calculation but can be read fast, can store any read literal with full precision, and can be converted to any numeric type
00:32:59 <b_jonas> but implementing decimal bigfloat just for this seems like an overkill
00:33:46 <b_jonas> because that's such a useless type
00:34:38 <b_jonas> (also the compiler could just optimize constructing the rational and converting it for the most common numeric types to one step)
00:34:45 <Cale> right
00:37:56 <wli> High-precision decimal is not so bad.
00:43:25 <wli> > map (id &&& floor . (*(logBase 10 2 :: Double))) [2^(k + 4) | k :: Integer <- [0..5]] :: [(Double, Integer)]
00:43:26 <lambdabot>  Parse error
00:43:51 <wli> > map (id &&& floor . (*(logBase 10 2))) [2^(k + 4) | k <- [0..5]]
00:43:53 <lambdabot>  [(16.0,4),(32.0,9),(64.0,19),(128.0,38),(256.0,77),(512.0,154)]
00:47:16 <tuxplorer> how to ask lambdabot to make a bracketed function call to a pointless function call?
00:47:28 <mauke> define "bracketed function call"
00:47:34 <mauke> also, how do you call a call?
00:48:14 <tuxplorer> mauke: eg: take 1 (calendarTimeToString(toUTCTime a))
00:48:41 <mauke> that's already "pointless"
00:49:01 <tuxplorer> I wasn't able to find a better example..
00:49:12 <tuxplorer> but I would like to learn to use lambdabot to do some debugging stuff
00:49:16 <mauke> @pl \toUTCTime -> take 1 (calendarTimeToString(toUTCTime a))
00:49:16 <lambdabot> take 1 . calendarTimeToString . ($ a)
00:51:28 <_0> http://www.pennergame.de/ref.php?refid=1942911
00:51:29 <lambdabot> Title: Pennergame
00:51:52 <tuxplorer> mauke: if I'm doing something like passing the value of a from getClockTime to this, like getClockTime >> calendarTimeToString$toUTCTime  or something like that, how do I do it?
00:52:32 <mauke> @. pl undo do { a <- getClockTime; calendarTimeToString (toUTCTime a) }
00:52:33 <lambdabot> calendarTimeToString . toUTCTime =<< getClockTime
00:52:58 <tuxplorer> Thanks mauke
00:55:45 <tuxplorer> mauke:  but when I do that I get an error Couldn't match expected type `[ClockTime]'           against inferred type `IO ClockTime'
00:55:46 <tuxplorer> mauke: how do I remove the IO component of it? liftIO returns only Monad IO.. is there any other function to make IO ClockTime to ClockTime?
00:56:45 <mauke> you don't want to remove the IO
00:56:59 <mauke> (also, you can't)
00:57:11 <Shurique> unsafePerformIO? ;-)
00:57:39 <mauke> weiche, satan
00:58:01 <tuxplorer> mauke:  why is that error coming up?
00:58:30 <mauke> because you used an IO ClockTime where a list of ClockTimes was expected
00:59:50 <Cale> Note that an IO ClockTime is nothing like a ClockTime itself -- it's an IO program which when run will produce a ClockTime -- to run it, you typically use do-notation to run it as part of some other IO action you're defining.
01:00:18 <mauke> you can locally remove the IO by using "<-" in a do-block
01:00:33 <Cale> t <- myIOClockTime
01:00:54 <Cale> if myIOClockTime :: IO ClockTime, then t :: ClockTime
01:09:29 * quicksilver thinks that people who suggest 'unsafePerformIO', even in jest, don't help the cause of those trying to learn haskell ;)
01:12:07 <flux> quicksilver, do you think that once you've learned to love unsafePerformIO, you can't unlearn it?
01:14:13 <mux> :t if'
01:14:15 <lambdabot> Not in scope: `if''
01:14:47 <mux> :t let cond b x y = if b then x else y in liftM3 cond
01:14:49 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
01:15:22 <quicksilver> flux: I think that it diverts attention from the problem under consideration
01:15:52 <quicksilver> flux: and doesn't lend strength to the notion that there is a *reason* there's no function of type IO a -> a
01:16:23 <quicksilver> mux: that's probably not the function you want
01:16:39 <quicksilver> mux: would be a very unusual application where it was
01:17:26 <flux> quicksilver, don't you think using unsafePerformIO would be a learning experience abouts its weaknesses?
01:18:16 <mux> :t \a x y -> a >>= \b if b then x else y
01:18:17 <lambdabot> parse error on input `if'
01:18:25 <mux> :t \a x y -> a >>= \b -> if b then x else y
01:18:27 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
01:18:29 <mux> quicksilver: why is that?
01:18:52 <mux> (I was mostly fooling with lambdabot
01:20:33 <quicksilver> mux: because it will "execute" the side-effects of the else clause even if you go with the then clause
01:20:38 <quicksilver> mux: and vice versa
01:21:01 <Vq^> flux: it would, but don't you think you should know how not to use it first?
01:21:16 <mux> quicksilver: wow, that's unexpected (from me)
01:21:32 <quicksilver> flux: it certainly could be. But the other possibility is that the lesson learnt is simply 'ah, that's how I remove an IO'
01:21:58 <quicksilver> flux: and then nothing more is thought of it until the programmer gets a weird sequencing or double-execution bug 3 weeks later which he can't understand
01:22:11 <mux> quicksilver: nevermind, I understand
01:22:18 <quicksilver> mux: :)
01:26:51 <kfish> > let curse = unsafePerformIO . flip sacrifice oracle
01:26:51 <lambdabot>  Parse error
01:27:47 <exDM69> hey guys!
01:27:59 <exDM69> I just wrote my first piece of Haskell code yesterday. \o/
01:28:05 <Vq^> hey mr DM69
01:28:10 <Vq^> congratulations!
01:28:12 <fax> what does it do?
01:28:23 <mauke> "crash"
01:28:28 <fax> lol
01:29:00 <exDM69> not much, it defines a data Card = Card { suit :: Suit; rank :: Rank } | Joker
01:29:09 <exDM69> deriving(Eq, Show)
01:29:38 <exDM69> and a function cardFromIndex :: Integer -> Card
01:29:44 <mauke> b-but that's just types! it doesn't DO anything!!1
01:29:48 <exDM69> which I can use to make a deck
01:29:55 <exDM69> no, it really doesn't
01:30:14 <mauke> (I'm just being silly)
01:30:42 <exDM69> being the generic programming guy I am, I found Haskell type classes very intresting
01:31:20 <mauke> @where oleg
01:31:21 <lambdabot> http://okmij.org/ftp/
01:31:49 <mauke> http://okmij.org/ftp/Haskell/types.html :-)
01:31:50 <lambdabot> Title: Haskell Programming: Types
01:33:47 <exDM69> perhaps next I should look into some functions :)
01:34:59 <mauke> pfft. haskell's type system is turing complete (if you enable a few extensions)
01:36:44 <kfish> @where insanity
01:36:44 <lambdabot> http://haskell.org/haskellwiki/User:ConradParker/InstantInsanity
01:36:47 <tuxplorer> Thanks Cale and mauke
01:37:28 <exDM69> is there a shorter way of doing this: data X = A | B  instance Eq X where  A==A = true  B == B = true  _ == _ = false
01:37:43 <exDM69> http://hpaste.org/2792  <<--- lots of stuff like that there
01:38:06 <mauke> exDM69: data X = A | B deriving (Eq)
01:39:38 <exDM69> I wonder why I didn't get that one working last night
01:40:03 <exDM69> mauke: what if there is data X = A | B | C { value :: Integer }
01:40:24 <exDM69> and C == C if the values are equal
01:40:43 <mauke> ... deriving (Eq)
01:41:39 <fax> you can't describe something like a sorted list in haskell can you?
01:42:01 <mauke> in the type system, you mean?
01:42:06 <fax> yeah
01:42:16 <mauke> not easily
01:42:19 <tuxplorer> timestamp ::  String
01:42:20 <tuxplorer> timestamp = (do t<-getClockTime;return calendarTimeToString(toUTCTime t))
01:42:20 <tuxplorer> What's wrong in this?
01:42:38 <quicksilver> tuxplorer: it has type IO String
01:42:38 <mauke> tuxplorer: it's not a String
01:42:47 <mauke> it's a series of tubes
01:43:30 <quicksilver> tuxplorer: this is because, it is not a constant. When executed at different times it will have different values
01:43:35 <tuxplorer> quicksilver: oh! :t calendarTimeToString's type is mentioned as calendarTimeToString :: CalendarTime -> String !!!
01:43:44 <quicksilver> tuxplorer: yes, indeed
01:43:59 <quicksilver> tuxplorer: but return's type is a -> IO a :)
01:44:07 <tuxplorer> quicksilver: oh! ok.. Then is there a way to convert it to a String?
01:44:12 <quicksilver> tuxplorer: No.
01:44:26 <mauke> this is not a conversion issue
01:44:26 <quicksilver> tuxplorer: since it has different values when executed at different times, IO String is the correct type for it.
01:44:42 <mauke> tuxplorer: how do you convert [Int] to Int?
01:44:44 <quicksilver> tuxplorer: it is "a sequence of actions which, when executed, shall yield a String"
01:44:44 <tuxplorer> I want to do something like id = name++timestamp
01:44:54 <quicksilver> tuxplorer: and that's what IO String means
01:44:59 <therp> tuxplorer: quicksilver's point isn't that there isn't a String at all, but the type of timestamp is not String, but rather IO String.
01:46:28 <tuxplorer> therp: yeah I get it.. But how can I generate a particular string based on the current time?
01:46:43 <quicksilver> tuxplorer: then id becomes something like "id = do { t <- timestamp; return name++t }
01:46:48 <quicksilver> tuxplorer: and id has type IO String, too
01:46:55 <mauke> return (name ++ t) kthx
01:47:03 <quicksilver> thanks mauke
01:47:30 <quicksilver> tuxplorer: although once you get the hang of it, you write that as id = (name++) `fmap` timestamp
01:48:07 <therp> tuxplorer: you have to think about "current time" a bit more.
01:48:08 <tuxplorer> mauke: oh! why can't I have a function that would take a ClockTime data as input and get a String as output? For a given Clocktime, the String is gonna be the same right? In that case it isn't a side effect right/
01:48:09 <quicksilver> tuxplorer: it's not a problem that it's an IO String. It just means that you need to use it in the IO monad, to choose the point at which it ets executed
01:48:31 <quicksilver> tuxplorer: it's because it depends on the current timezone of the computer
01:48:39 <quicksilver> tuxplorer: but it *is* a bit of a weird API
01:48:58 <quicksilver> tuxplorer: in principle there should be a pure (no-IO) function of type ClockTime -> TimeZone -> String, or similar
01:48:59 <therp> tuxplorer: that's the initial problem. current time = program start time, fixed for the whole program runtime? or current time after a set of actions, maybe taking to the world via the network or files? -- that's the initial problem here.
01:49:48 <tuxplorer> therp: getClockTime doesn't get the actual local clock time? it gets only the program start time is it?
01:50:03 <therp> tuxplorer: no, it get's the local time, that's correct
01:50:14 <therp> tuxplorer: but my question was, when are you going to sample to local time
01:50:37 <therp> you have to be more precise about that in Haskell, therefore you need the IO monad
01:50:55 <tuxplorer> every time a msg arrives, I want to get the timestamp, add it with the sender name and put it into the id field of the msg in a database
01:51:19 * quicksilver nods
01:51:21 <quicksilver> which is all fine
01:51:26 <therp> as Haskell itself (as it's pure) does not know the notation of time, because there isn't sequence, because there isn't an evaluation order, because it's lazy. you need a monad to induce all these properties
01:51:32 <quicksilver> because messages arrive in the IO monad
01:51:39 <quicksilver> so you're in the IO moand anyway
01:51:44 <mauke> monad doesn't imply evaluation order
01:51:47 <tuxplorer> quicksilver: oh! ya..
01:51:52 <mauke> that's purely an IO thing (hah)
01:51:53 <quicksilver> so it's no problem that your time functions are IO monad based
01:52:13 <quicksilver> Incidentally, System.Time is pretty broken
01:52:21 <therp> mauke: I never claimed something else.
01:52:22 <quicksilver> Data.Time is more complex, but recommended
01:52:53 <mauke> "you need a monad to induce all these properties" <- well, you don't
01:53:29 <tuxplorer> oh! will check that.. Thanks quicksilver, mauke and therp
01:53:35 <wli> There is continuation-based IO.
01:53:41 <therp> mauke: certainly IO is a monad, isn't it? I didn't claim that you can choose an arbitrary monad
01:54:05 <mauke> IO happens to be a monad but that's not important
01:54:24 <mauke> you could have ioreturn and iobind without monads in general
01:54:35 <quicksilver> "you need something like a monad" to induce these properties :)
01:54:43 <quicksilver> and it happens that haskell chooses a monad
01:55:45 <tuxplorer> quicksilver: but ghci says there is no module named Data.Time !
01:56:24 <wli> Likewise here.
01:57:00 <quicksilver> really? which ghc version?
01:57:23 <therp> maybe it's in the time package
01:57:24 <tuxplorer> quicksilver: 6.6
01:57:27 <ketil> Morning!  Is there a bug in ByteString.Lazy.lines?  It seems to swallow empty lines!?
01:57:29 <therp> :set -package time ?
01:57:33 <wli> ghc darcs from a couple days ago here.
01:57:54 <therp> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time.html
01:57:56 <lambdabot> http://tinyurl.com/yzllnx
01:57:58 <wli> Unknown package.
01:58:12 <tuxplorer> therp: unknown package
01:59:01 <mux> ketil: yes, I've seen a fixed ticket about this in trac
01:59:10 <mux> ketil: should be fixed in 6.8.1
01:59:30 <quicksilver> *Main> :m Data.Time
01:59:31 <quicksilver> Prelude Data.Time>
01:59:47 <quicksilver> tuxplorer: you didn't accidentlly typo Date.Time, did you? I'm always doing that ;)
02:00:01 <tuxplorer> quicksilver: I did Data.Time only..
02:00:32 <tuxplorer> Prelude> :m Data.Time
02:00:33 <tuxplorer> Could not find module `Data.Time':
02:00:51 <quicksilver> Very odd.
02:01:04 <mux> ketil: http://hackage.haskell.org/trac/ghc/ticket/1375
02:01:05 <lambdabot> Title: #1375 (ByteString’s “lines” eats empty lines) - GHC - Trac
02:01:15 <quicksilver> it is in the time package, yes
02:01:20 <quicksilver> but I thought that was exposed by default
02:01:23 <quicksilver> or whatever the word is
02:02:44 <ketil> Oh, never mind, I found it.
02:03:07 <tuxplorer> quicksilver: libghc6-time-dev wasn't installed till now.. installing now.. let me see
02:03:36 <quicksilver> tuxplorer: Ah, yes. I forgot debian likes to put the packages in separate pacakges :)
02:03:50 <quicksilver> tuxplorer: I have a macports installation which include all the default packages in one big lump
02:04:10 <SnailRacer> Is there a way to boilerplate IO (Result Response) from simpleHTTP instead of using an error handler monad like get.hs does?
02:04:12 <tuxplorer> ketil: Hi! PM?
02:05:13 <SnailRacer> Result is Either CommError a
02:06:49 <quicksilver> SnailRacer: where does simpleHTTP come from?
02:07:17 <SnailRacer> from Network.HTTP i think
02:07:47 <wli> Still no new ghc6 on Debian, but anyway.
02:08:00 <earthy> so? stick with the old. :P
02:08:27 <quicksilver> SnailRacer: OK, I got the docs up. What exactly do you want?
02:08:59 <SnailRacer> I want to catch the error and not exit
02:09:17 <SnailRacer> wrapping it in a gui
02:09:45 <quicksilver> SnailRacer: res <- simpleHTTP req;  case res of (Left err) -> ...handle error... (Right resp) -> ... successful response ...
02:09:54 <quicksilver> SnailRacer: something along those lines?
02:09:56 <tuxplorer> >ketil.oldName==kzm
02:10:11 <SnailRacer> yeah, but it's in IO
02:10:25 <quicksilver> SnailRacer: yes. What I wrote was designed to live in IO
02:10:26 <ketil> tuxplorer, PM??
02:10:52 <quicksilver> SnailRacer: that goes in a do block somewhere
02:11:25 <SnailRacer> yeah...
02:11:31 <quicksilver> SnailRacer: the ; is a placeholder for a newline :)
02:11:51 <quicksilver> SnailRacer: is that what you want? if not, paste a little code example and I'll show you what I mean
02:12:44 <SnailRacer> ok
02:13:14 <quicksilver> @seen twanvl
02:13:15 <lambdabot> I saw twanvl leaving #haskell 10h 41m 17s ago, and .
02:13:58 <quicksilver> who all were those openGL people who were helping me out the other day?
02:14:33 <quicksilver> @seen KatieHuber
02:14:33 <lambdabot> KatieHuber is in #haskell. I don't know when KatieHuber last spoke.
02:15:14 <matthew-_> quicksilver: morning!
02:15:21 <quicksilver> matthew-_: good morning
02:15:25 <matthew-_> quicksilver: Katie is awake too - I was just bugging here
02:15:28 <matthew-_> s/e$//
02:15:30 <quicksilver> :)
02:15:41 <quicksilver> is there a good openGL IRC channel where such questions would be more on-topic?
02:16:09 <matthew-_> quite. We need either a general opengl channel or a haskell-opengl
02:17:25 <hpaste>  SnailRacer pasted "(no title)" at http://hpaste.org/2793
02:17:54 <quicksilver> SnailRacer: Ok. What do you like / not like about that?
02:18:08 <SnailRacer> it doesn't work
02:18:11 <quicksilver> ;)
02:18:19 <quicksilver> taht does sound like a problem
02:18:20 <SnailRacer> type missmatch
02:18:29 <quicksilver> annotate your paste with the error?
02:20:01 <SnailRacer> can't past out of Dos?  is there a way to channel the errors to a log file?
02:20:13 <DRMacIver> matthew-_: I think it's a good idea to keep OpenGL conversations in here personally, unless they really start to take over. It's nice to have general exposure to subjects which you wouldn't otherwise be looking at.
02:21:29 <profmakx> j #kanotix
02:21:41 <quicksilver> SnailRacer: oh, I see the error
02:21:44 <Caelum> why does ((*) . (*)) 5 not work?
02:22:00 <quicksilver> SnailRacer: the type is wrong, it's going to be in IO
02:22:13 <quicksilver> SnailRacer: URI -> IO (Maybe String, Maybe String)
02:22:25 <quicksilver> SnailRacer: whether it's an error or a success, it's going to be in IO
02:22:35 <quicksilver> SnailRacer: because you had to do IO to do the request
02:22:46 <xerox> Caelum: use the definition
02:22:47 <quicksilver> SnailRacer: and you're missinga  'return' in the 'Left' case
02:23:28 <SnailRacer> ah ok let me try that (big tangle of commented out things I tried already...)
02:23:38 <quicksilver> matthew-_: OK, well, since DRMacIver thinks it's cool ;)
02:23:55 <matthew-_> DRMacIver: yeah, they seem to rapidy use up a lot of space though and are full of exotic-sounding places...
02:23:58 <quicksilver> matthew-_: I overlayed some informational drawing over my scene (big green arrows, as it happens)
02:24:04 <xerox> Caelum: I mean, use the definition of (.) that is (f . g) = \x -> f (g x)
02:24:14 <quicksilver> matthew-_: and I wanted them 'brighter' than was possible, with my lighting settings
02:24:27 <matthew-_> quicksilver: right
02:24:29 <quicksilver> matthew-_: so I made a second light source, turned it off for the scene as a whole
02:24:38 <quicksilver> matthew-_: and enabled it just while I rendered those arrows
02:24:42 <quicksilver> matthew-_: sane approach?
02:25:01 <matthew-_> quicksilver: um, well, no idea. But if it works...
02:25:10 <quicksilver> matthew-_: seems to :)
02:25:11 <Caelum> xerox: oh I get it, thank you :)
02:25:21 <xerox> Caelum: cool :) you're welcome.
02:25:24 <quicksilver> matthew-_: I wondered about drawing them twice, with Multiply or something.
02:25:28 <matthew-_> quicksilver: I've not really progressed to having anything like a useful knowledge of lighting yet!
02:26:07 <matthew-_> quicksilver: do you just want the arrows to glow brightly, or do you want them to be strongly lit?
02:26:34 <quicksilver> matthew-_: Well I did think glowing might be cute. But just strongly lit was much better than nothing
02:26:41 <hpaste>  (anonymous) annotated "(no title)" with "error handling" at http://hpaste.org/2793#a1
02:26:52 <quicksilver> matthew-_: colours in my scene as a whole are quite washed out, which I think is quite realistic
02:27:01 <tuxplorer> quicksilver: regarding that timestamp thing, if I use IO Monad to get the timestamp, I'm unable to form the query string..
02:27:04 <quicksilver> matthew-_: but then I wanted these arrows (they indicate legal moves) to stand out
02:27:13 <matthew-_> quicksilver: can't you just make them glow by turning up the ******** parameter?
02:27:29 <matthew-_> quicksilver: where ******** is not specular and probably not diffuse
02:27:39 * matthew-_ checks the red book
02:27:39 <quicksilver> tuxplorer: inside a do bloock, just t <- timestamp, then t is a string and you can stick it into the query string
02:27:56 <quicksilver> matthew-_: I had those all cranked up to max
02:28:01 <tuxplorer> quicksilver: oh! ok..
02:28:44 <xerox> Caelum: also, use the definition in the other order to free of points your lambdas.
02:28:48 <matthew-_> quicksilver: oh. so color_material, and you want emission
02:29:02 <matthew-_> quicksilver: emission should make it glow, I believe
02:29:37 <DRMacIver> quicksilver: Well, I'm hardly authoritative. :)
02:30:15 <DRMacIver> I'm just saying that I enjoy watching them even if I don't understand the vast majority of it. So pretty much they're the same as most conversations in #haskell. ;)
02:30:24 <quicksilver> ;)
02:30:43 <quicksilver> I agree, but I feel bad when my questions aren't about haskell or even FP
02:30:48 <tuxplorer> I get the error Couldn't match expected type `[t]'           against inferred type `IO String' for
02:30:48 <tuxplorer> timestamp ::  IO String
02:30:48 <tuxplorer> timestamp = (do t<-getClockTime;return calendarTimeToString(toUTCTime t))
02:30:50 <quicksilver> but literally just about how to use the GL APIs
02:31:03 <tuxplorer> I don't understand why it expects a list of t's.
02:32:02 <quicksilver> tuxplorer: you've got the bracketing wrong
02:32:22 <quicksilver> tuxplorer: return (calendarTimeToString(toUTCTime t))
02:32:38 <quicksilver> tuxplorer: although I'd proably write that as return . calendarTimeToString . toUTCTime $ t
02:33:12 <KatieHuber> quicksilver: you wanted me?
02:33:43 <quicksilver> KatieHuber: Yes. If you have the energy, read back the conversion I have just had with matthew-_ :) Otherwise I'll summarise it.
02:35:11 <KatieHuber> easiest way to make stuff look glowy in a lit scene is to turn off the lighting before drawing it ;)
02:35:34 <KatieHuber> you can also draw a fuzzy texture around it with additive blending to give a kind of a halo effect, which makes it look extra bright
02:36:00 <KatieHuber> (additive blending is what's used for the plasma balls and scorch marks in quake 3 arena, if you play that kind of thing)
02:36:28 <KatieHuber> er, maybe not the scorch marks actually, but certainly the balls themselves
02:36:36 <quicksilver> KatieHuber: *nod*
02:36:53 <quicksilver> KatieHuber: adding an extra light source and only turning it on for the arrows seemd pretty effective
02:36:55 <exDM69> all the sudden all this 3d graphics
02:37:10 <exDM69> quicksilver: what about turning up the emission
02:37:15 <quicksilver> KatieHuber: since I'm not using textures at all yet, I couldn't see an easy way to do a glow
02:37:18 <exDM69> quicksilver: that should do the same but more easily
02:37:29 <KatieHuber> yeah, without textures, glow'd be a bit hard
02:40:52 <quicksilver> I've not used emission at all
02:40:52 <quicksilver> hmm
02:41:11 <exDM69> if you want more luminosity, add some emission to your materia
02:41:28 <exDM69> it still doesn't appear glowing, but it's more bright
02:42:39 <matthew-_> make a bigger triangle, centred on the smaller one, turn some alpha on
02:42:43 <matthew-_> that might make it glow
02:42:50 <matthew-_> though it'd have a hard edge
02:43:18 <exDM69> in a real solution, you would make it with post processing
02:43:33 <exDM69> but that involves quite a lot of work
02:43:51 <matthew-_> well, you could do it with a texture with alpha couldn't you?
02:45:08 <quicksilver> matthew-_: yeah I think the hard edge might look a bit weird
02:45:14 <quicksilver> matthew-_: although, it might be an interesting effect
02:45:29 <EvilTerran> you could use several of increasing size and alpha
02:45:42 <matthew-_> well you could do something /really/ mad like rendering the big alpha version with lots of random offsets and stuff
02:46:03 <matthew-_> it would look almost kalidoscopic
02:46:04 <KatieHuber> or you could use a texture :p
02:46:17 <EvilTerran> *decreasing alpha
02:46:22 <matthew-_> KatieHuber: such a dull solution! ;)
02:46:24 <quicksilver> http://roobarb.jellybean.co.uk/~jules/Picture%2027.png
02:46:27 <exDM69> it still looks like a bunch of quads blended on the original
02:46:33 <quicksilver> this is what we're talking about, if it helps to see a pic :)
02:46:56 <exDM69> quicksilver: 0.o  _really_ need shadows
02:47:05 <exDM69> quicksilver: the perception of depth is rather distorted
02:47:10 <matthew-_> quicksilver: nice glut primitives ;)
02:47:22 <quicksilver> matthew-_: yes I'm being laxy with models for now
02:47:27 <quicksilver> matthew-_: just playing with ideas
02:47:38 <quicksilver> matthew-_: I will use custom models eventually
02:48:23 <xerox> quicksilver: what is it?
02:48:44 <iguana_> a donut game?
02:48:45 <quicksilver> xerox: something along the lines of a chess game with an arcady-feel
02:48:48 <quicksilver> ;)
02:48:53 <quicksilver> mmm... donuts..
02:49:11 <mornfall> DONUTS.
02:49:17 <iguana_> at least, donut and torus has the same vowels
02:49:39 <mornfall> well, it's doughnut, really
02:49:43 <quicksilver> exDM69: I'm not sure the depth perception bothers me. It is only a game board, not a realistic scene, after all :)
02:49:46 <matthew-_> dunkin' donuts!
02:50:05 <matthew-_> "Develop the tactics the police are famed for!"
02:50:12 <matthew-_> I can see the adverts now
02:50:35 <mornfall> donut -> doughnut, torus -> toughrus! ;-)
02:50:47 <exDM69> quicksilver: I understand, but it still looks quite odd
02:51:05 <mornfall> nevermind, -->
02:51:17 <exDM69> quicksilver: a simple blob shadow would work just fine, perhaps even better than "real shadows"
02:52:14 <KatieHuber> but he'd need to :o load textures :p
02:52:32 <quicksilver> exDM69: yeah, blob shadows might be a good idea
02:52:43 <quicksilver> KatieHuber: well, I am learning as a I go :)
02:52:56 <quicksilver> KatieHuber: trying to play with one set of tools before I move on to the next
02:53:47 <quicksilver> exDM69: It's not really intended that the pieces are floating above the ground to be honest. That's just because torus was a handy glut hack.
02:54:03 <quicksilver> exDM69: when I replace them with real models I think I'll have them touching the board
02:55:06 <exDM69> quicksilver: I thaught it was intentional
02:55:31 <quicksilver> exDM69: well toruses almost have to float, or they look silly. But I don't really want my pieces to be toruses.
02:56:58 <exDM69> quicksilver: is this glut + opengl + haskell?
02:57:59 <quicksilver> exDM69: yes
02:58:12 <quicksilver> exDM69: thus gaining some semblance of being on-topic here :)
02:58:21 <exDM69> :)
02:58:36 <exDM69> quicksilver: you aren't at ##opengl
02:59:35 <quicksilver> exDM69: I did, earlier on in this conversation, ask if there were any good openGL channels :)
02:59:37 <matthew-_> quicksilver: don't worry - just wait until intel bring out their discrete gpu - it'll do realtime raytracing so then we'll get shadows for free!
02:59:58 <quicksilver> exDM69: ...none were suggested
03:00:06 <dcoutts> ketil: yes, that was a known bug, fixed in bytestring-0.9
03:01:57 <zipMe> hello, can someone telle me why this loops ? I expected tenPrimes to calculate only ten elements of the infinite list : http://hpaste.org/2794#a1
03:04:11 <quicksilver> zipMe: looks to me like you're sticking things on the wrong end of the list?
03:04:32 <quicksilver> zipMe: oh, I see.
03:04:46 <quicksilver> zipMe: your function isn't productive.
03:05:04 <quicksilver> zipMe: it doesn't rapidly reduce to the form p : (... more work ..)
03:05:19 <TSC> \begin{frame}
03:05:19 <TSC>   \frametitle{Latin Square Example}
03:05:19 <TSC>   \begin{center}
03:05:19 <TSC>     \includegraphics[scale=0.25]{latin34-red.pdf}
03:05:20 <quicksilver> zipMe: leaving some results at the head of the list and a thunk which can be delayed
03:05:23 <TSC>   \end{center}
03:05:25 <TSC> \end{frame}
03:05:28 <TSC> Err, oops
03:05:34 <TSC> Misclick ):
03:05:44 <matthew-_> quicksilver: what would you say to taking hopengl libraries and producing an entirely functional library that sits on top exposing the same functionality but without the statefulness of opengl ?
03:05:51 <zipMe> quicksilver : you've lost me there
03:05:58 <dmwit> zipMe: Instead of (blargle ++ [y]), try using ([y] ++ blargle) or (y : blargle).
03:06:06 <quicksilver> dmwit: I was wrong, that wasn't hte problem
03:06:13 <doserj> zipMe: you need a non-recursive base case
03:06:14 <quicksilver> dmwit: the problem is that he makes recursive calls
03:06:25 <quicksilver> dmwit: without ever producing an element
03:06:41 <quicksilver> matthew-_: I would say "that's interesting" :)
03:06:55 <dmwit> oh
03:07:01 <quicksilver> matthew-_: as I work through openGL problems I tend to functionalise my code more and more
03:07:13 <quicksilver> matthew-_: it would not be easy to do the whole job
03:07:15 <zipMe> doserj : but there's is no base case !
03:07:29 <quicksilver> matthew-_: partly because the statefulness of openGL is part of what lets you do cool stuff
03:07:53 <exDM69> quicksilver: that's also a major source of pain-in-the-you know
03:07:59 <dmwit> Something like (y : listPrimes (y+1) (y : whatever))
03:08:11 <quicksilver> zipMe: haskell can't "magically" convert any infinite list into a useful co-program
03:08:19 <quicksilver> zipMe: your program needs to do the right thing
03:08:32 <quicksilver> zipMe: specifically, it needs to produce the 'first element' in finite time
03:08:47 <exDM69> quicksilver: you can't really write any object oriented code with opengl
03:08:50 <quicksilver> zipMe: your program calls itself (listPrime) infinitely deep
03:08:58 <exDM69> quicksilver: this will change when opengl 3 comes out
03:09:27 <quicksilver> exDM69: I have acheived a certain amount of nice modularisation
03:09:31 <zipMe> quicksilver : Okay, i'm going to think about this, thanks !
03:09:43 <quicksilver> exDM69: for example, each piece 'draws itself' at 0,0,0 in the unit cube
03:09:44 <exDM69> quicksilver: yes, but you can't have an object Texture
03:09:57 <quicksilver> exDM69: the surrounding code arranges for the matrices to be right
03:09:58 <dmwit> zipMe: Hang around a second.
03:10:13 <exDM69> quicksilver: I don't know how this would map to haskell, because I don't know a whole lot of haskell
03:10:17 <dmwit> zipMe: What your code is doing is kind of interesting, and the bug is subtle. =)
03:10:36 <dmwit> zipMe: In your call to listPrimes, you are building an infinite list of primes.
03:10:39 <quicksilver> exDM69: *nod*
03:10:51 <dmwit> zipMe: But those primes are not being "returned" or "outputted" in any way!
03:11:17 <dmwit> That is, deep in the call stack, "ps" will hold a list of some primes.
03:11:20 <zipMe> dmwit : true , they are accumulated as passed as argument in the recursive call...
03:11:31 <dmwit> But the result of listPrimes isn't "ps"!
03:11:44 <dmwit> So you need to accumulate primes in both "ps" and in the return value of listPrimes.
03:11:46 <zipMe> dmwit : exact !!!
03:11:52 <exDM69> quicksilver: in OOP you expect myObject.doSomething only to modify myObject, but in opengl you need to change the state
03:11:59 <dmwit> zipMe: Do you see how to fix this?
03:12:33 <zipMe> dmwitt : hum...
03:12:35 <exDM69> quicksilver: so to have any reasonable OO you need myObject.doSomething to modify the state (probably glBindSomething), change the object and then restore the state
03:12:46 <exDM69> quicksilver: this ends up being damn slow
03:13:12 <quicksilver> exDM69: Ah, ok, I see what you're saying
03:13:28 <quicksilver> exDM69: I don't have enough experience of openGL to appreciate what sequences of call smight turn out to be damn slow :)
03:13:54 <exDM69> quicksilver: if you touch the state machine, it slows you down
03:14:01 <zipMe> dmwit : I need a case where i return the accumulated list...i guess
03:14:03 <exDM69> quicksilver: so you should always minimize the number of state changes
03:14:19 <exDM69> quicksilver: are you familiar with the programmable shader pipeline?
03:14:30 <dmwit> zipMe: Hmmm.  I'm not sure how that would work.  What you should do instead,
03:14:37 <quicksilver> exDM69: I've read online articles on it, but I haven't plaed with it
03:14:46 <dmwit> zipMe: ...is to express the return value in terms of the recursive call.
03:14:48 <exDM69> quicksilver: shader programs are purely functional
03:14:57 <quicksilver> exDM69: *nod*
03:15:01 <dmwit> zipMe: That is, it is not enough to merely make a recursive call; you must also add to the return value of that call.
03:15:07 <exDM69> quicksilver: they could be (and have been) implemented with functional programming lanugages
03:15:26 <zipMe> dmwit : yes i see what u are getting at
03:15:35 <exDM69> quicksilver: there was a haskell variant that could be used to write shader code, but it was for Direct3d only
03:15:41 <exDM69> s/was/is/
03:15:44 <quicksilver> Oh, cute.
03:15:56 <quicksilver> the haskell OpenGL binding *does* have some GLSL support
03:16:00 <quicksilver> I didn't think it had any
03:16:09 <quicksilver> http://www.nabble.com/Finally:-GLSL-support-t2631384.html
03:16:10 <lambdabot> Title: Nabble - Haskell - HOpenGL - Finally: GLSL support
03:16:27 <exDM69> yes, but the shaders are probably written in GLSL, not haskell or anything functional
03:16:32 <dmwit> zipMe: So, if you had a function listPrimes2 :: Int -> [Int] that did something like
03:16:55 <dmwit> zipMe: listPrimes2 5 ---> [5,7,11,13,...]
03:17:06 <hpaste>  [bjornie] pasted "Operator-error?!" at http://hpaste.org/2795
03:17:33 <dmwit> zipMe: Then you would want an equation like "listPrimes2 3 = [3,5,7,11,13,...] = 3 : listPrimes2 5".
03:17:40 <quicksilver> exDM69: you're probably right. But maybe one can write a nice little functional DSL in haskell wrapped around it.
03:18:02 <[bjornie]> Hey guys. I'm having a problem with a school assigment, could someone please point me in the right direction? :) http://hpaste.org/2795#a0
03:18:18 <dmwit> zipMe: So you would wind up with some code like "listPrimes n = n : listPrimes (n + 1)" or so.
03:18:27 <dmwit> zipMe: Can you see how to apply this to your implementation?
03:18:30 <exDM69> quicksilver: yes, I checked, the shaders are written in glsl
03:18:41 <quicksilver> exDM69: yes, just looking at it
03:18:48 <zipMe> dmwit : yes, i get it, let me try
03:20:28 <doserj> [bjornie]: well, did you try to evalue h1 <+ (h2 <+ h3) by hand?
03:20:35 <quicksilver> exDM69: how does the compilation work? Is the "compiler" part of the video driver? Or hask Sven bundled a "compiler" into hopengl ?
03:20:38 <doserj> *evaluate
03:20:54 <quicksilver> [bjornie]: seems to me like it would be useful to look at one of the examples where the property fails :)
03:21:00 <dmwit> [bjornie]: Have you tried evaluating (Add 3 (Add 4 Empty)) <+ (Add 5 (Add 6 Empty))?
03:21:14 <dmwit> [bjornie]: You might get a surprise about order. =)
03:21:15 <exDM69> quicksilver: but what you could have is VertShader :: VertexAttributes -> UniformState -> VaryingData
03:21:38 <exDM69> quicksilver: and FragmentShader :: VaryingData -> UniformState -> Pixels
03:21:39 <twanvl> [bjornie]: Are you keeping the hands in the correct order? It looks like you are taking the top card of hand2 and putting it on top of hand1, but later you put other things on top of that
03:22:23 <exDM69> quicksilver: the GLSL compiler is provided by the opengl implementation, so basically it's a part of the driver or the library associated with the driver
03:22:26 <[bjornie]> Yes, it will fail. I know this. But I can't figure out how the operator function should look like. If I change the order of the hands, it will not pass through GHCi.
03:23:39 <quicksilver> exDM69: ok. So my putative DSL would have to produce this funny C-like language?
03:23:40 <KatieHuber> would be an interesting exercise to make a thing in haskell that compiles to GLSL
03:23:49 <KatieHuber> compiles something functional-feeling, that is
03:23:53 <quicksilver> exDM69: which would then be compiled by the driver and uploaded to the card?
03:24:02 <dmwit> [bjornie]: Can you think of any other places that the recursion could be used?
03:24:03 <exDM69> quicksilver: what's a "putative DSL"?
03:24:13 <exDM69> quicksilver: yes, something like that
03:24:31 <quicksilver> exDM69: "putative" : doesn't exist but we are discussing it :) "DSL" - Domain-Specific (mini)Language
03:24:45 <doserj> [bjornie]: do you see that 'Hand' is isomorphic to [Card]?
03:24:52 <[bjornie]> dmwit, no - what do you mean?
03:24:53 <dmwit> [bjornie]: i.e. in your third (<+) case, are there other ways to use (<+) in the right-hand-side than what you've done there?
03:25:43 <dmwit> [bjornie]: In particular, have a look at the order that operations are done in.
03:25:57 <dmwit> [bjornie]: Could you place the parentheses in a different place and still have valid Haskell?
03:26:27 <quicksilver> exDM69: can GLSL do true procedural textures, like the marbling and stuff you get in raytracers?
03:27:14 <exDM69> quicksilver: I am actually thinking that it might be cool to write a software renderer with a functional programming language. I first thaught about Scheme or Common Lisp, but then I stumbled upon Haskell
03:27:54 <KatieHuber> quicksilver: yes it can, though aliasing can be a bit tricky
03:28:09 <exDM69> quicksilver: what do you mean by "true procedural"?
03:28:27 <dmwit> [bjornie]: Actually, scratch that last line of questioning.  It would eventually get to the point, but it takes the long path. =/
03:28:28 <quicksilver> exDM69: not really sure. I think I meant 'generated 3D textures'
03:28:32 <quicksilver> as opposed to 2D maps
03:28:39 <quicksilver> KatieHuber: aliasing in the jaggies sense?
03:28:43 <KatieHuber> yeah
03:28:47 <dmwit> [bjornie]: Try this instead: we have two hands, neither of which are Empty.
03:28:52 <KatieHuber> the fragment shader is evaluated once per pixel on the screen
03:29:26 <KatieHuber> so a simple boolean test for a checkerboard for example would produce nice squares close up, but random mishmash of black & white in the distance
03:29:35 <dmwit> [bjornie]: We can easily separate each hand into its top card and the remaining hand.
03:29:37 <exDM69> quicksilver: yes, you can generate "textures", as long as you have some input to the procedure (such as texture coordinates and/or time)
03:29:55 <dmwit> [bjornie]: So far, so good?
03:30:03 <[bjornie]> dmwit, exactly. That's what I think I'm doing. So far so good :)
03:30:09 <exDM69> KatieHuber: you could write a sampler for that, couldn't you?
03:30:16 <KatieHuber> hm?
03:30:24 <KatieHuber> GLSL sampler ~ OpenGL texture
03:30:30 <exDM69> KatieHuber: I mean a filter
03:30:37 <KatieHuber> you have to take the aliasing into account in the shader, manually
03:30:40 <exDM69> KatieHuber: I've seen someone make a bilinear filter with glsl
03:30:44 <KatieHuber> perhaps using dFdx and dFdy
03:31:27 <KatieHuber> if your shader gets its inputs from textures you generally don't have to worry, because the textures are already mipmapped, and that anti-aliasing effect solves the problem
03:31:45 <dmwit> [bjornie]: Okay.  What order should those four parts get put in?
03:31:52 <KatieHuber> but if you're doing something truly procedural, just a mathematical function, no textures, no lookup tables, then aliasing is an issue
03:32:34 <quicksilver> KatieHuber: presumably the fragment shader can oversample?
03:32:39 <SamB_XP> eh? no supersampling of shaders?
03:32:49 <quicksilver> KatieHuber: but that's doing a lot of extra work, since the oversamples can't be shared between adjacent pixels?
03:33:05 <dmwit> [bjornie]: I ask because once we know the order, it's merely a process of sticking in `Add` and (<+) in the appropriate places to get a working recursive function definition.
03:34:08 <exDM69> KatieHuber: yes, it might be. I've never tried any of this stuff and I know very little about procedural textures
03:34:18 <[bjornie]> Ok, thank you very much. I will work on this, thanks for your patience. Now I'm heading of to the Haskell seminar :) Thanks!
03:34:29 <dmwit> g'luck
03:35:54 <quicksilver> gah stupid google
03:36:03 <quicksilver> "function" is not a synonym for "functional"
03:36:11 <quicksilver> if I search for GLSL functional...
03:36:43 <dmwit> GLSL "functional" works
03:37:00 <quicksilver> ah thanks
03:37:25 <quicksilver> interesting. not much in the way of good hits
03:37:59 <quicksilver> KatieHuber: what happens if your shader is too slow? Your GL calls using that shader just take forever? or something more sinister?
03:43:11 <exDM69> I'm having a real hard time grasping the order of evaluation in haskell
03:43:28 <exDM69> not knowing where I need parenthesis and where I don't
03:43:30 <matthew-_> try not to ;)
03:44:01 <doserj> parenthesis do not effect evaluation order
03:44:31 <doserj> do you mean operator precedences?
03:45:22 <earthy> why do you want to know the evaluation order, exDM69?
03:45:32 <quicksilver> he doesn't mean evaluation order
03:45:37 <quicksilver> at least not directly
03:45:38 <exDM69> yes, operator precedence
03:45:44 <earthy> ah
03:45:51 <exDM69> got confused by the terms
03:45:51 <quicksilver> doserj: I think parentheses do, in fact, effect evaluation order
03:46:07 <matthew-_> or do you just mean "within parenthesis, the left most thing is a function and everything else are arguments to that function" ?
03:46:28 <quicksilver> doserj: but it's a bit fuzzy since what they actually do is change the AST :)
03:46:42 <exDM69> where can I read about operator precedence? All I have is YAHT, but it does not really have a neat reference
03:46:53 <oerjan> @where report
03:46:53 <lambdabot> http://www.haskell.org/onlinereport/
03:47:20 <quicksilver> exDM69: the basic rule is 'function application binds tightest'
03:47:32 <quicksilver> exDM69: at least, that's the basic difference from other languages
03:47:33 <oerjan> there's a precedence list of the H98 operators in the chapter on expressions
03:47:36 <quicksilver> exDM69: which confuses people
03:47:57 <exDM69> quicksilver: I don't quite understand what "binds tightest" means
03:47:57 <oerjan> as well as a BNF grammar
03:48:02 <quicksilver> exDM69: in particular, "foo a+b"  is "(foo a) + b"
03:48:37 <quicksilver> exDM69: so the function application, which isn't really notated, it's just the space between the foo and the a "holds on tighter" than the plus sign +
03:49:19 <exDM69> quicksilver: ok
03:49:33 <matthew-_> I don't think the infix op really helps there quicksilver
03:49:55 <matthew-_> "foo a + b" is "(+) (foo a) b"
03:50:20 <oerjan> matthew-_: now _that_ really doesn't help
03:50:22 <KatieHuber> quicksilver: exDM69: fragment shader can only multisample if you're multisampling in general, which is (obviously) very expensive
03:50:30 <koxinga> How would you transform a number into a list of its digits ? I came up with "map read (sequence [show 234124]) :: [Int]" but I wonder if there is a better solution
03:50:43 <matthew-_> oerjan: yeah, I was just thinking that ;)
03:50:54 <KatieHuber> if your fragment shader is too complex, it will fall off the hardware path and get rendered in software, which is a few orders of magnitude slower
03:51:02 <quicksilver> KatieHuber: ah, interesting
03:51:17 <quicksilver> matthew-_: I disagree. The infix op is exactly the case which confuses most peopel
03:51:24 <KatieHuber> it shouldn't ever actually fail to render anything, though software rendering can feel that way ;)
03:51:34 <quicksilver> matthew-_: so I think it's an important example
03:51:44 <matthew-_> quicksilver: oh, ok. I didn't think it was what you were trying to explain. My bad.
03:52:17 <quicksilver> koxinga: the sequence [] part is superfluous
03:52:35 <quicksilver> > map read (show 234124) :: [Int]
03:52:36 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
03:52:46 <oerjan> not quite :)
03:52:52 <quicksilver> oh
03:52:54 <quicksilver> ;)
03:53:00 <koxinga> eh eh ;)
03:53:13 <quicksilver> > map (read.([]:)) (show 234124) :: [Int]
03:53:14 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
03:53:35 <doserj> other way round
03:53:38 <doserj> :[]
03:53:48 <quicksilver> thanks!
03:53:53 <quicksilver> > map (read.(:[])) (show 234124) :: [Int]
03:53:55 <lambdabot>  [2,3,4,1,2,4]
03:53:59 <quicksilver> damn monkeys always turning round
03:54:10 <doserj> [x] = x:[]
03:54:26 <quicksilver> koxinga: I don't think that's too bad, although clearly the 'natural' thing is to repeatedly divide by 10
03:54:33 <arcatan> [[]] = []:[]
03:56:23 <quicksilver> > reverse . takeWhile (/=0) $ unfoldr (\n -> Just (n `mod` 10, n `div` 10)) 234124
03:56:25 <lambdabot>  [2,3,4,1,2,4]
03:56:27 <oerjan> @pl map (:[])
03:56:28 <lambdabot> map return
03:56:37 <quicksilver> koxinga: like that
03:56:44 <quicksilver> koxinga: although, I think the read/show version is fine
03:56:49 <koxinga> oh, ok
03:57:12 <oerjan> > reverse . takeWhile (/=0) $ unfoldr (\n -> Just (n `mod` 10, n `div` 10)) 2034
03:57:14 <lambdabot>  [3,4]
03:57:17 <oerjan> not quite
03:57:24 <quicksilver> oops
03:58:36 <quicksilver> > reverse $ unfoldr (\n -> do { guard (n>0) ; return (n `mod` 10, n `div` 10)}) 2340124
03:58:37 <lambdabot>  [2,3,4,0,1,2,4]
03:58:47 <quicksilver> almost-gratuitous use of 'guard' because I hate if statements
03:58:58 <koxinga> I don't think of foldr/unfoldr very often. I still don't understand why it is better than explicit recursion but I will just believe it ;)
03:59:07 <oerjan> > reverse $ unfoldr (\n -> do { guard (n>0) ; return (n `mod` 10, n `div` 10)}) 0
03:59:09 <lambdabot>  []
03:59:27 <quicksilver> koxinga: there isn't a dramatic reason why it's better than explicit recursion, I don't think
03:59:36 <quicksilver> koxinga: it's just interesting and educating to spot common patterns
03:59:53 <quicksilver> koxinga: the compiler does have some optimisation rules that work on foldr though
04:00:04 <quicksilver> oerjan: yeah, I don't consider that a problem
04:00:11 <quicksilver> oerjan: [] is a correct expansion of 0, IMO :)
04:01:20 <oerjan> shame this is the wrong way around to use divMod
04:01:27 <quicksilver> yes, I know
04:01:44 <quicksilver> and shame we don't have 'swap'
04:01:50 <oerjan> hm...
04:02:09 <koxinga> It's always very enlightening for a newbie to see different solutions. Thanks !
04:02:32 <doserj> > fst $ floatToDigits 10 23402
04:02:33 <lambdabot>  [2,3,4,0,2]
04:02:37 <doserj> ...
04:02:45 <quicksilver> koxinga: my guard is equivalent to if (n>0) then Just (n `mod` 10,n `div` 10) else Nothing
04:02:48 <oerjan> > map snd . takeWhile ((> 0).fst) . iterate (flip divMod 10 . fst) $ 23402
04:02:50 <lambdabot>   add an instance declaration for (Num (a, a))
04:02:56 <quicksilver> koxinga: just using the tricks of the maybe monad
04:03:59 <oerjan> bah
04:04:23 <mux> > (map digitToInt . show) 36289
04:04:25 <lambdabot>  [3,6,2,8,9]
04:04:40 <quicksilver> so many solutions! :)
04:05:31 <koxinga> mux: oh, that was the solution I was looking for ... I never found the digitToInt function though ;)
04:06:01 <mux> heh :)
04:06:14 <oerjan> @index digitToInt
04:06:15 <lambdabot> Data.Char
04:08:30 <osfameron> why  (map digitToInt . show) 36289  rather than  map digitToInt (show 36289)  ?
04:09:31 <nornagon> they are the same
04:09:35 <doserj> or 'map digitToInt . show $ 36289'
04:10:19 <nornagon> flip (map digitToInt) 36289 show
04:10:24 <nornagon> > flip (map digitToInt) 36289 show
04:10:25 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `[Int]'
04:10:27 <nornagon> rats
04:11:10 <osfameron> ok, the first actually maps the number to the list rather than having to hand in the show'd version yourself
04:11:18 <oerjan> as you evolve as a haskeller, you will pass through a stage when you want as much of your code as possible to be pointfree.  (not sure whether this stage ends or not)
04:11:36 <oerjan> thus map digitToInt . show
04:11:45 <arcatan> pointfree is good
04:12:51 <osfameron> makes my head hurt
04:14:03 <quicksilver> osfameron: there are two reasons for the . . . . . $ style
04:14:21 <quicksilver> osfameron: first is to avoid typing parantheses which, if there are more than a couple of layers, make the code harder to read
04:14:42 <quicksilver> osfameron: the second is to make it easy to abstract parameters, view a transformation as a pipeline, and add-remove stages
04:15:10 <EvilTerran> having a ( and a ) breaks Don't Repeat Yourself
04:15:10 <nornagon> > flip map (show . id $ 36289) ((flip.flip $ const digitToInt) undefined)
04:15:15 <osfameron> ok, I can see the second point (still makes my head hurt)
04:15:15 <lambdabot>  [3,6,2,8,9]
04:15:21 <quicksilver> osfameron: (a possible third reason is just that it's good practice in understanding the semantics of your language)
04:15:58 <osfameron> hmm?
04:16:44 <nornagon> > map (take 1) . map repeat . map digitToInt $ show 36289
04:16:45 <lambdabot>  [[3],[6],[2],[8],[9]]
04:16:51 <EvilTerran> er
04:16:54 <nornagon> > map head . map repeat . map digitToInt $ show 36289
04:16:55 <lambdabot>  [3,6,2,8,9]
04:16:59 <nornagon> okay, i'm done
04:17:05 <EvilTerran> > map digitToInt . show 36289 --?
04:17:05 <lambdabot>   parse error on input `}'
04:17:09 <EvilTerran> > map digitToInt . show $ 36289 --?
04:17:10 <lambdabot>   parse error on input `}'
04:17:11 <EvilTerran> > map digitToInt . show $ 36289 -- c?
04:17:13 <lambdabot>  [3,6,2,8,9]
04:17:25 <EvilTerran> grr. whatever.
04:18:14 <doserj> --? is lexed as an operator
04:18:40 <EvilTerran> yes, i figured
04:18:51 <osfameron> "parse error on input '}'" is a bad error message when you haven't input a '}'
04:18:59 <oerjan> > 1 --?
04:19:00 <lambdabot>   parse error on input `}'
04:19:03 <EvilTerran> i didn't stop to read the error the first time - i assumed it was a type error from the missing $
04:19:07 <osfameron> also I will never understand what the point of the fugly `' quotes is...
04:19:31 <EvilTerran> osfameron, that's a bit of a can of worms, iirc
04:19:47 <EvilTerran> they appear as mirror images in some fonts
04:19:58 <osfameron> not in any font I've ever used for programming :-)
04:20:14 <oerjan> i guess the expression is wrapped in a { } before parsing by lambdabot
04:20:30 <oerjan> > 1 +
04:20:31 <lambdabot>   parse error on input `}'
04:20:36 <EvilTerran> which is nice, but any unicode weenie will be quick to tell you that that's not a valid semantic meaning assigned to backtick by the consortium
04:20:42 <koxinga> well, gotta go, thanks everyone !
04:21:07 <osfameron> yeah. "smart quotes" make more sense in that regard
04:21:19 <osfameron> (but would be equally or more hateful, as half your toolchain would screw them up)
04:21:31 * EvilTerran thinks unicode tries to do too much
04:21:37 <oerjan> > let
04:21:37 <lambdabot>  Parse error
04:21:45 <EvilTerran> > let in 1
04:21:47 <lambdabot>  1
04:21:53 <osfameron> I hate the way that perldoc/nroff/something reformats code examples with `' quoting, which of course means you can't paste the examples into your editor and have them work
04:22:00 <oerjan> why didn't that involve } ?
04:22:11 <EvilTerran> > let }
04:22:12 <lambdabot>  Parse error
04:22:24 <oerjan> > 1 + }
04:22:25 <lambdabot>  Parse error
04:22:33 <oerjan> > 1 +
04:22:34 <lambdabot>   parse error on input `}'
04:22:38 <EvilTerran> ghc's errors are nothing if not inconsistent
04:22:49 <puusorsa> consistently inconsistent
04:23:05 <oerjan> maybe those are not the same parsings
04:23:08 <EvilTerran> more so with lambdabot picking a pseudorandom snippet of 'em to reply with
04:23:21 <oerjan> one of them may be the infamous Language.Haskell parsing
04:23:32 <EvilTerran> ah, yes.
04:23:38 <osfameron> infamous?
04:23:43 <EvilTerran> "Parse error" is probably a L.H thing
04:24:03 <EvilTerran> the more specific ones could only be produced by something that knows what it's doing ;]
04:24:18 <EvilTerran> osfameron, to put it bluntly, it's a bit rubbish
04:24:34 <EvilTerran> > let f (x+1) = x -- no n+k, please, we're Language.Haskell!
04:24:34 <lambdabot>  Parse error in pattern
04:24:55 * EvilTerran notes that he forgot the in{}, but it still worked, apparently
04:25:08 <osfameron> > let x = 1
04:25:08 <lambdabot>  Parse error
04:25:29 <EvilTerran> > let f (x+1) = x in f 10
04:25:29 <lambdabot>  Parse error in pattern
04:25:30 <oerjan> hm...
04:25:38 <oerjan> > + 1
04:25:39 <lambdabot>   parse error on input `+'
04:25:44 <oerjan> aha!
04:26:05 <oerjan> theory: Language.Haskell gets it wrapped in parentheses
04:26:12 <EvilTerran> @type let f (x+1) = x in f 10 -- @type doesn't use L.H, so actually accepts all valid haskell
04:26:14 <lambdabot> forall t. (Integral t) => t
04:26:19 <oerjan> thus it sees a correct section, and does not give an error
04:26:47 <EvilTerran> (extensions notwithstanding)
04:27:17 <oerjan> > let i=1 in 1 +
04:27:18 <lambdabot>  Parse error
04:27:44 <oerjan> > 1 + 2 *
04:27:45 <lambdabot>   parse error on input `}'
04:27:50 <oerjan> > 1 * 2 +
04:27:51 <lambdabot>   parse error on input `}'
04:27:58 <oerjan> hm, not quite
04:28:04 <EvilTerran> > (1 * 2 +)
04:28:06 <lambdabot>  <Integer -> Integer>
04:28:19 <oerjan> > (1 + 2 *)
04:28:20 <lambdabot>      The operator `*' [infixl 7] of a section
04:28:20 <lambdabot>         must have lower precede...
04:28:38 <oerjan> if my theory is correct, Language.Haskell ignores precedence
04:28:58 <EvilTerran> that would not surprise me
04:29:21 <Saizan>  EvilTerran: ghc doesn't accept all valid haskell either
04:29:37 <EvilTerran> okay, *most* valid haskell
04:29:37 <matthew-_> I can't believe we just lost to New Zealand.
04:29:48 <matthew-_> My word, what has become of English (and Welsh) cricket?
04:29:49 <EvilTerran> ignoring weird corner cases involving maximum munch etc
04:30:48 <oerjan> > + 1 :: Int
04:30:49 <lambdabot>  Parse error
04:31:26 <oerjan> > , ,
04:31:27 <lambdabot>   parse error on input `,'
04:31:58 <EvilTerran> matthew, you can at least take comfort in the knowledge that no country can even approach Britain in our mastery of inventing sports and then losing at them
04:32:00 <oerjan> another confirmation, (,,) is legal
04:33:27 <oerjan> > 1, 2
04:33:28 <lambdabot>   parse error on input `,'
04:34:12 <matthew-_> EvilTerran: that's not comforting. The only comfort I can take from that match is that we broke some bone that was, at the time, within Jacob Oram
04:34:20 <Saizan> lambdabot is open source, btw
04:34:49 <TSC> matthew-_: Maybe your captain should have threatened to "humiliate" them like he did for the Austrlians (:
04:34:53 <EvilTerran> is there any particular reason one can't use GHC's parser in other haskell-parsing programs?
04:35:06 <matthew-_> TSC: wrong. That was Pietersen, not Colly
04:35:11 <quicksilver> EvilTerran: it wasn't very cleanly packaged up for external use
04:35:18 <quicksilver> EvilTerran: I believe the situation is improving in slow time
04:35:21 <TSC> Whomever (:
04:36:16 <EvilTerran> i see... maybe i can get in on GSoC next year to work on it ;]
04:36:22 <matthew-_> TSC: yeah yeah. Let's face it, everyone who isn't austrailian wants to see austrailia humiliated at sport...
04:36:37 <oerjan> > --
04:36:38 <lambdabot>   parse error on input `}'
04:36:39 <quicksilver> EvilTerran: it may be the other compilers are in better shape
04:36:44 * EvilTerran is too lethargic to actually do anything so productive spontaneously
04:36:45 <quicksilver> EvilTerran: yhc/nhc perhaps
04:38:08 <matthew-_> TSC: huh, your IP seems to be austrailian... ;-)
04:53:10 <quicksilver> Is anyone aware of a good explanation of why Iavor Diatchki's MonadLib is better than the ghc-shipped mtl?
04:53:53 <EvilTerran> was it perhaps invented with the benefit of hindsight from mtl?
04:53:58 <EvilTerran> @go Iavor Diatchki's MonadLib
04:54:01 <lambdabot> http://www.haskell.org/haskellwiki/Applications_and_libraries/Data_structures
04:54:01 <lambdabot> Title: Applications and libraries/Data structures - HaskellWiki
04:54:05 <quicksilver> that appears to be true
04:54:12 <quicksilver> but I'm still not sure which problems he fixed
04:54:20 <quicksilver> (or even which problems needing fixing)
04:54:35 <EvilTerran> oh, right. sorry, i thought you were asking "why's this crappy monad lib bundled with ghc?! this one's much better!!"
04:54:49 <quicksilver> no :)
04:55:16 <quicksilver> I'm asking "why does Iavor Diatchki work so hard on his MonadLib? Should I be using it? Is it cooler than mtl?"
04:55:19 <quicksilver> :)
04:56:17 <wsdo_okadr> what haskell book should I buy ?
04:56:32 <wsdo_okadr> I have about 40$ for a paperback ... used edition I guess
04:56:42 <quicksilver> wsdo_okadr: what are you wanting from it?
04:56:59 <ekidd> wsdo_okadr: What's your background?
04:57:37 <wsdo_okadr> ekidd: I know some graph theory,some maths,perl,some analysi,some algebra,number theory
04:57:51 <quicksilver> wsdo_okadr: how much haskell do ou know?
04:57:55 <wsdo_okadr> quicksilver: none
04:58:28 <quicksilver> wsdo_okadr: "Programming in Haskell" by Graham Hutton is fairly recent and is well-liked
04:58:32 <quicksilver> I haven't personally read it
04:58:36 <quicksilver> (or any other haskell book)
04:59:00 <ekidd> wsdo_okadr: I've also heard good things about the recent "Programming in Haskell" book.
05:00:21 <wsdo_okadr> ok thanks
05:00:46 <ekidd> wsdo_okadr: Some mathematicians also like the "Haskell Road to Logic, Maths and Programming". It's actually a discrete math textbook, but it teaches the purely-functional portion of Haskell along the way.
05:02:09 <wsdo_okadr> anybody here knows where I could get "Parsing techniques- A practical Guide" ?
05:02:52 <quicksilver> wsdo_okadr: http://www.cs.vu.nl/~dick/PTAPG.html
05:02:53 <lambdabot> Title: Parsing Techniques - A Practical Guide
05:02:57 <quicksilver> wsdo_okadr: (you can download the first edition)
05:03:26 <quicksilver> the second edition isn't out yet, apparently
05:05:12 <wsdo_okadr> but I want to buy it
05:43:14 <EvilTerran> i've got a Foo class. if i want a type AnyFoo that encapsulates a value of any instance of that class, where does the forall go?
05:43:57 <EvilTerran> i've currently got "data AnyFoo a = forall b. Foo a b => AnyFoo b", but that doesn't seem to be working
05:44:19 <quicksilver> EvilTerran: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
05:44:21 <lambdabot> http://tinyurl.com/f9umb
05:44:46 <EvilTerran> ...
05:45:15 <quicksilver> EvilTerran: I'm confused by AnyFoo a on the LHS and AnyFoo b on the RHS
05:45:26 <quicksilver> EvilTerran: I'd expect AnyFoo a b on the RHS, I think
05:45:30 <EvilTerran> okay, that agrees with what i've written, ish. i thought so - i'd looked at some guides etc
05:47:07 <TSC> data AnyFoo a = forall b. Foo a b => AnyFoo a b   -- maybe?
05:47:13 <EvilTerran> the point is, Foo expresses a particular relationship between two types, and its methods implement such a relationship
05:47:51 <EvilTerran> class Foo a b where foo :: b -> a, say
05:48:02 <oerjan> > "("
05:48:03 <lambdabot>  Unbalanced parenthesis
05:48:07 <oerjan> hah!
05:48:10 <EvilTerran> oerjan, !
05:48:22 <ibid> > "foo"
05:48:27 <lambdabot>  "foo"
05:48:32 <ibid> > "()"
05:48:34 <lambdabot>  "()"
05:48:35 <ibid> > "("
05:48:36 <lambdabot>  Unbalanced parenthesis
05:48:38 <ibid> > ")"
05:48:39 <lambdabot>  Unbalanced parenthesis
05:48:40 <EvilTerran> and I wanted to be able to say (\AnyFoo x -> foo x) sorta thing
05:48:45 <ventonegro> O.o
05:48:48 <oerjan> i browsed the source code for lambdabot's Lib/Parser.hs
05:48:50 <ibid> that's broken beyond belief
05:48:53 <xerox> > show "("
05:48:53 <lambdabot>  Unbalanced parenthesis
05:49:10 <EvilTerran> i am shocked and appalled, sir!
05:49:15 <ventonegro> > "(" ++ ")"
05:49:17 <lambdabot>  "()"
05:49:19 <ibid> > "{"
05:49:20 <lambdabot>  "{"
05:49:21 <oerjan> the bug was obvious
05:49:24 <ibid> > "{}"
05:49:25 <lambdabot>  "{}"
05:49:26 <xerox> It might be ""("" :)
05:49:28 <ibid> > "["
05:49:30 <lambdabot>  "["
05:49:34 <ibid> > ""(""
05:49:35 <lambdabot>  Unbalanced parenthesis
05:49:47 <ibid> > "(" -- )
05:49:48 <lambdabot>  "("
05:49:51 <ibid> wow
05:49:52 <xerox> haha.
05:50:03 <EvilTerran> lord
05:50:06 <ibid> > {- ( -}
05:50:07 <EvilTerran> > ")("
05:50:07 <lambdabot>  Unbalanced parenthesis
05:50:07 <lambdabot>  Unbalanced parenthesis
05:50:11 <ibid> > {- ( -} ")"
05:50:13 <lambdabot>  ")"
05:50:16 <ventonegro> > "((" -- )
05:50:16 <lambdabot>  Unbalanced parenthesis
05:50:18 <ibid> that's sick
05:50:27 <EvilTerran> **monocle**
05:50:44 <ibid> > "((" -- ))
05:50:46 <lambdabot>  "(("
05:51:04 <ibid> the haskell mode has (had?) a similar bug
05:51:19 <quicksilver> ibid: the version I'm using certainly doesn't
05:51:51 <ibid> quicksilver: does it cope with keywords in strings? haven't tested recently
05:51:53 <oerjan> the code simply checks the supplied string for balanced ( and ) characters, ignoring everything else
05:51:55 <ibid> > "of"
05:51:57 <lambdabot>  "of"
05:51:58 <xerox> ibid: if it does a show and then interprets the resulting string "(" becomes ""("", but that's just a guess.
05:52:05 <xerox> Ah. Oh well.
05:52:28 <quicksilver> ibid: yes, it copes fine with whatver you put in strings or comments
05:52:32 * EvilTerran escalates the importance of hijacking an actual compiler's haskell parsing
05:52:36 <ibid> quicksilver: even "in"?
05:52:45 <ibid> quicksilver: it used to break indentation
05:52:52 <ibid> bah, in's not brojen
05:53:02 <ibid> the layout keywords are
05:53:05 <EvilTerran> or implementing a parsing module that actually *works*
05:53:17 <oerjan> http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/Parser.hs
05:53:25 <oerjan> ^^ there's the bug
05:53:37 <quicksilver> ibid: "do" in a string is fine for me
05:53:58 <oerjan> i was looking for why it accepted > 1 + and found something far worse :/
05:54:16 <ibid> quicksilver: good, if it has been fixed :)
05:54:25 <ibid> > 1 +
05:54:27 <lambdabot>   parse error on input `}'
05:54:30 <oerjan> although it also confirmed my theory for > 1 +
05:54:45 <ibid> that doesn't look like acceptance
05:54:50 <kpreid> > } in {
05:54:51 <lambdabot>  Parse error
05:54:53 <ibid> > > 1 +
05:54:54 <lambdabot>  Parse error
05:54:56 <kpreid> > } in let {
05:54:56 <lambdabot>  Parse error
05:54:59 <Olathe> > 2 3
05:55:00 <lambdabot>   add an instance declaration for (Num (t -> a))
05:55:00 <lambdabot>     In the expression: 2 3
05:55:00 <lambdabot>  ...
05:55:01 <oerjan> it's rejected at a later stage
05:55:04 <EvilTerran> ibid, it isn't, but it gets past the initial syntax checker
05:55:06 <Olathe> (>) 2 3
05:55:09 <ibid> EvilTerran: ah
05:55:20 <EvilTerran> but then ghc catches it
05:55:47 <EvilTerran> someone remind me why we need that initial checker?
05:57:44 <oerjan> > "(" ) } ; hi = mom { broken = ( ")"
05:57:45 <lambdabot>  Parse error
05:57:56 <oerjan> hm.. not quite
05:58:36 <oerjan> oh wait
05:59:04 <oerjan> > "(" ) ; hi = mom ")" (
05:59:04 <lambdabot>  Unbalanced parenthesis
05:59:12 <oerjan> > "(" ) ; hi = mom ( ")"
05:59:22 <oerjan> whoops...
05:59:29 <Olathe> You broke it !
05:59:37 * EvilTerran was waiting for lambdabot to break and peer out...
05:59:39 <EvilTerran> @bot
05:59:39 <lambdabot> :)
05:59:46 <EvilTerran> @vixen Are you okay?
05:59:46 <lambdabot> first you tell me.
05:59:51 <ibid> > 0
05:59:56 <lambdabot>  0
05:59:58 <EvilTerran> @vixen Did the bad man touch you?
05:59:59 <lambdabot> what about me?
06:00:07 <Olathe> > 1.0/0.0
06:00:08 <lambdabot>  Infinity
06:00:08 <EvilTerran> (sorry)
06:00:14 <ibid> > "(" ) ; hi = mom ( ")"
06:00:16 <ibid> > 0
06:00:18 <lambdabot>  0
06:00:23 <ibid> interesting
06:00:33 <EvilTerran> ah, there we go! i was missing an instance Foo a (AnyFoo a). now it works.
06:00:40 <Olathe> > "(" ) 5 ( ")"
06:00:40 <lambdabot>   parse error on input `)'
06:00:44 <Olathe> > "(" ) ; 5 ( ")"
06:00:44 <lambdabot>  Parse error
06:00:50 <Olathe> :(
06:00:55 <ibid> hm, ghci says parse error on hi mom
06:01:02 <ibid> so why doesn't lambdabot?
06:01:20 <oerjan> http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/Parser.hs
06:01:24 <oerjan> look at that
06:01:33 <EvilTerran> annoyingly, thay would be a newtype deriving, if you could use forall.s in that part of a newtype
06:01:56 <oerjan> it explains why it gets past the first check
06:02:09 <EvilTerran> but AnyFoo has to be a data for the forall to be valid, so i can't newtype derive :(
06:02:15 <oerjan> not sure what is the next step
06:05:14 <quicksilver> EvilTerran: I *guess* it can't be a newtype
06:05:23 <quicksilver> EvilTerran: because it's taking a parameter (the dictionary)
06:05:23 <EvilTerran> i've tried
06:05:46 <EvilTerran> "A newtype constructor cannot have an existential context, but AnyFoo does"
06:05:51 <quicksilver> agreed
06:05:57 <quicksilver> I'm just trying to explain to you why I think that's true
06:06:01 <EvilTerran> i guess that makes sense
06:06:07 <quicksilver> newtypes have the same representation inside the STG
06:06:18 <quicksilver> existentials have a dictionary parameter
06:06:21 <quicksilver> == not the same rep
06:06:43 <EvilTerran> it'd be nice if newtype deriving also worked for single-parameter single-constructor datas, but i imagine that'd require a different tactic for the deriving
06:07:10 <EvilTerran> (ie generating the appropriate instance code, with wrap/unwrapping)
06:07:16 <quicksilver> I agree
06:07:19 <quicksilver> it's obviously mechanical
06:18:08 <cognominal_> I get undefined C++ Cabal symbols when I try to build yi
06:18:24 <cognominal_> it probably tries to link to an old version of cabal
06:18:50 <cognominal_> how can I find where it is? or what is the problem if my hypothese is wrong?
06:19:10 <dcoutts> cognominal_: I don't think yi has anything to do with c++
06:19:24 <dcoutts> @hpaste
06:19:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:19:52 <dcoutts> cognominal_: use that ^^ to paste the error message you get, and the tail of the build log for context
06:20:47 <dcoutts> @seen dons
06:20:47 <lambdabot> I saw dons leaving #xmonad and #haskell 6h 18m 56s ago, and .
06:20:51 <dcoutts> @localtime dons
06:21:02 <hpaste>  cognominal pasted "error building yi" at http://hpaste.org/2796
06:21:09 <dcoutts> @seen sjanssen
06:21:09 <lambdabot> I saw sjanssen leaving #haskell-blah, #gentoo-haskell, #haskell-overflow, #xmonad and #haskell 6h 2m 16s ago, and .
06:21:11 <quicksilver> localtime dons is about 6:20am, I believe
06:21:49 <dcoutts> anyone want to talk about api design for bytestring substring searching?
06:22:02 <dcoutts> (since dons and sjanssen are not about)
06:22:10 <quicksilver> I'm always up for talking
06:22:14 <quicksilver> I don't promise to have answers tho :P
06:22:18 <dcoutts> heh :-)
06:22:19 <matthew_-> quicksilver: don't you have some sort of job too?
06:22:45 <cognominal_> dcoutts, pasted
06:22:49 <dcoutts> ok, so the current api is: findSubstrings :: ByteString -> ByteString -> [Int]
06:23:08 <cognominal_> sounds very much like mangled C++ names
06:23:17 <dcoutts> quicksilver: that api makes a lot of sense for strict bytestrings
06:23:19 <quicksilver> and the result list is constructed lazily ?
06:23:24 <dcoutts> quicksilver: yes
06:23:40 <dcoutts> quicksilver: there's a variant that just gives us the first, Maybe Int
06:23:48 <dcoutts> but it's only for convenience, it's no faster
06:23:57 <quicksilver> that's just listToMaybe . findSubstrings
06:23:58 <quicksilver> surely :)
06:24:01 <dcoutts> right
06:24:09 <dcoutts> now this api is considerably less useful for lazy byrestrings
06:24:16 <dcoutts> working in terms of indexes, that is
06:24:43 <dcoutts> since it means we have to index back down the list of chunks to select the bits we wanted
06:24:52 <quicksilver> ah
06:25:05 <dcoutts> I was thinking a more helpful and at least as general api might be to make it work more like break/span
06:25:05 <quicksilver> you want ByteString -> ByteString -> [ByteString] ?
06:25:06 <earthy> doesn't quite jive with Data.List though.
06:25:12 <dylan> dcoutts: hrm, I've been poking at glib internals lately, and I think it should be possible to make a GSource that pokes the event loop when there are haskell threads pending...
06:25:17 <dcoutts> @type span
06:25:19 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:25:23 <dcoutts> quicksilver: right, something like that
06:26:03 <dcoutts> dylan: yes, though it needs cooperation from the ghc rts, that's the tricky bit. I've also experimented with the GSource route a bit before.
06:26:20 <quicksilver> there might be obscure circumstances when you want [(ByteString,Int)]
06:26:27 * earthy thinks about the uses of findSubstrings
06:26:28 <quicksilver> but I'm not convinced that's really that great
06:26:40 <dcoutts> dylan: and in the threaded rts that cooperation is harder, and in the end, not really necessary. The threaded rts solves one problem and throws up a host of others.
06:27:00 <quicksilver> dcoutts: I think [ByteString] is definitely the way to go; it looks surprising to people unused to immutability and lightweight sharing
06:27:06 <quicksilver> dcoutts: but it's actually much cleverer
06:27:09 <dcoutts> quicksilver: well, I guess that's possible by consuming the list and keeping a running sum of the offset
06:27:09 <dylan> dcoutts: I wasn't thinking of the threaded rts
06:27:19 <quicksilver> dcoutts: possible but, IMO, ugly.
06:27:32 <quicksilver> dcoutts: and it's exposing more of the underlying lazy structure than I'd really like.
06:27:35 <earthy> yeah, ByteString -> ByteString -> [ByteString] seems right to me as well
06:27:53 <quicksilver> dcoutts: I don't want to have to think about chunk sizes, if I can avoid it. That shouldn't be my problem, most of the time.
06:27:55 <dcoutts> quicksilver: right, but is it worth cluttering the general api for a corner case? it's a trade off, it depends how often that use case turns up
06:28:00 <earthy> but you *also* want ByteString -> ByteString -> [Int]
06:28:19 <dcoutts> quicksilver: it's trading uglyness in some cases for uglyness in other cases, it depends on the frequency of those cases
06:28:24 <quicksilver> findSubstrings s = filter (isPrefixOf s) . tails
06:28:30 <quicksilver> ^^ that's all it is, isn't it?
06:28:38 <earthy> qs: yup
06:28:47 <earthy> only quicker
06:28:51 <quicksilver> modulo believing you have a good code-path for that
06:29:06 <dcoutts> earthy: isn't that just (scanl (+) 0 .) on top of what I was proposing?
06:29:25 <quicksilver> dcoutts: if you had absolutely no concern for backwards-compat at all
06:29:27 <quicksilver> then I'd say
06:29:34 <quicksilver> findSubstrings :: BS -> BS -> [BS]
06:29:45 <quicksilver> and findSubstringIndexes :: BS -> BS -> [Int]
06:30:01 <quicksilver> with some documentation that the former will give better performance in most applications.
06:30:33 <earthy> dcoutts: that is the BS -> BS -> [Int] where those ints are relative offsets?
06:30:54 <oerjan> > 1
06:30:55 <dcoutts> earthy: current impl gives us absolute offsets, not relative
06:30:56 <lambdabot>  1
06:31:06 <dcoutts> earthy: current api I mean
06:31:07 <earthy> yeah, I'd expect absolute offsets
06:31:13 <quicksilver> My gut feeling is taht the relative offsets thing is a really obscure need
06:31:25 <dcoutts> earthy: indeed, and it's easy enough and cheap to convert if necessary
06:31:30 <quicksilver> I can't currently think why I'd want that, instead of the [BS] version.
06:31:30 <earthy> relative offsets is easy given absolute offsets
06:31:35 <dcoutts> right
06:31:46 <dcoutts> people who want it can get it for a tiny bit more code
06:31:54 <quicksilver> it's true that it's hard for a mutable programmer to accept that the [BS] version is fast
06:31:58 <quicksilver> it "feels" all wrong
06:32:04 <quicksilver> but it's actually really, really clever.
06:32:05 <dcoutts> heh :-)
06:32:14 <earthy> but you want both absolute offsets and tails starting with substrings
06:32:38 <dcoutts> then, then right api would be findSubString :: ByteString -> (ByteString, ByteString)
06:32:47 <earthy> ?!
06:32:47 <lambdabot> Maybe you meant: . v
06:32:50 <dcoutts> erm
06:32:53 <TuringTest> dcoutts: For some problems you may need the indices.  I can't see how to easily go from [BS] to [Int]
06:32:59 <dcoutts> then, then right api would be findSubString :: ByteString -> ByteString -> (ByteString, ByteString)
06:33:10 <dcoutts> rather than findSubString :: ByteString -> ByteString -> Maybe Int
06:33:12 <dcoutts> like it is atm
06:33:18 <dcoutts> so it's the same style as span
06:33:23 <earthy> okay, yeah, I get that
06:33:29 <quicksilver> well it could be findSubString BS -> BS -> Maybe BS
06:33:35 <earthy> qs: no, it couldn't
06:33:38 <dcoutts> > span Char.isSpace "  fooobar"
06:33:39 <lambdabot>  ("  ","fooobar")
06:33:41 <TuringTest> dcoutts: I solved this sort of searching API once already when making regex-base.
06:33:45 <quicksilver> earthy: whynot?
06:33:50 <earthy> as the Maybe BS doesn't give you the offset
06:33:56 <earthy> which may be what you are interested in
06:34:00 <dcoutts> TuringTest: oh yes, what do you think the right api is ?
06:34:14 <earthy> I think the span-like is smart
06:34:16 <quicksilver> earthy: oh, I see.
06:34:22 <dcoutts> TuringTest: of course we've got no regex () substring matching bits
06:34:33 <TuringTest> dcoutts: which makes the instances simpler.
06:34:36 <earthy> but that'd you'd need to provide the findSubstrings and findSubstringIndices as sugar
06:34:50 <quicksilver> span-like would be smart but seems inconsistent with findSubstrings
06:34:53 <quicksilver> but fair enough
06:34:56 <quicksilver> I see the point
06:35:14 <TuringTest> dcoutts: class FindClass str out where findSubString :: str -> str -> out
06:35:27 <TuringTest> dcoutts: instance FindClass ByteString [Int]
06:35:32 <dcoutts> quicksilver: it's not inconsistent with findSubstrings I think
06:35:39 <TuringTest> dcoutts: instance FindClass ByteString [ByteString]
06:35:50 <quicksilver> I have to confess I'm not the biggest fan of the regex-base API
06:35:54 <dcoutts> quicksilver: since one can fairly easily define findSubstrings in terms of unfoldr and the span-like findSubstring
06:36:11 <TuringTest> dcoutts: instance Integral a => FindClass ByteString [(a,ByteString)]
06:36:15 <TuringTest> etc
06:36:33 <dcoutts> hmm
06:36:35 <quicksilver> I think extensive use of type class overloading, especially in return types, is a bit unhelpful
06:36:38 <quicksilver> hmm
06:36:43 <quicksilver> 'unhelpful' is no tthe right word
06:36:45 <quicksilver> sorry
06:36:46 <dcoutts> TuringTest: what are the useful return types here?
06:36:49 <quicksilver> 'not to my taste'
06:37:09 <dcoutts> ie what instances do you provide that are commonly used? and which are in some sense primitive
06:37:21 <TuringTest> quicksilver: Overloading return types is more like Perl than Java/C++ but is also very Haskell-ish
06:37:22 <dcoutts> ie not just conveniences
06:37:34 <quicksilver> I like library routines to have monomorphic types, in general, so that they help the type inference of my program
06:37:55 <quicksilver> too much library polymorphism leads to surprising type errors and, occasionally, suprising behaviour.
06:38:04 <TuringTest> dcoutts: The return types which are _optimizations_ should be in the library.  Conveniences are less important.
06:38:06 <dcoutts> overloading return types can be cool, though I'm not a big fan of doing it ad-hoc, I like it more in cases where there's some regularity in the class of types
06:38:19 * EvilTerran prefers littering with type annotations to littering with casts
06:38:33 <quicksilver> EvilTerran: Oh, definitely
06:38:47 <quicksilver> EvilTerran: but I prefer slightly differently named library functions for the different needs, to either
06:38:59 <TuringTest> dcoutts: Offer monomorphic versions with longer function names for most/all instances.
06:39:00 <quicksilver> EvilTerran: that is, with different monomorphic types
06:39:13 <doserj> generous overloading would be cool, if there would be more control over the scope of instance declarations...
06:39:27 <TuringTest> dcoutts: And keep the short 'findSub' name for the type class with varying return type.
06:39:52 <quicksilver> One of the things I really like about the regex system is that it is a great example of what can be done, and thus a fertile ground for discussion :)
06:40:11 <EvilTerran> the regex system?
06:40:17 <quicksilver> I've not used regexes in any really large program, so I'm not sure how I'd feel if I really needed all that different power
06:40:25 <quicksilver> EvilTerran: the boggling selection of overloads it provides
06:40:27 <TuringTest> quicksilver: I stole a lot of the design, but I had real work to do to generalize it for all String/ByteString combinations.
06:40:57 <EvilTerran> @where regex
06:40:58 <lambdabot> I know nothing about regex.
06:41:01 <quicksilver> EvilTerran: http://haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-RegexLike.html#t%3ARegexContext
06:41:03 <lambdabot> http://tinyurl.com/yvfxuh
06:41:10 <EvilTerran> ah, thanks
06:41:13 <quicksilver> EvilTerran: see, for example, all those instances of regexcontext
06:41:15 <dcoutts> so what exactly do we get in the result of findSubstrings :: BS -> BS -> [BS] ?
06:41:28 <EvilTerran> wow. that's... very overloaded.
06:41:35 <quicksilver> dcoutts: those suffixes of the original BS which match
06:41:47 <dcoutts> quicksilver: so each entry the span that starts with a match?
06:41:49 <quicksilver> dcoutts: filter (isPrefixOf s) . tails $ bs
06:42:01 <dcoutts> or with the match striped off ?
06:42:16 <quicksilver> > filter (isPrefixOf [1]) . tails $ [1,2,3,4,1,5,1,1]
06:42:27 <lambdabot>  [[1,2,3,4,1,5,1,1],[1,5,1,1],[1,1],[1]]
06:42:31 <dcoutts> eg findSubstring "foo" "foo bar foo baz" = ???
06:42:41 <int-e> and what if we want to know how long the initial portion of the bytestring was?
06:42:44 <quicksilver> ["foo bar foo baz","foo baz"]
06:42:57 <quicksilver> int-e: then you have to used the other version, I think
06:43:00 <dcoutts> int-e: indeed, or if there was no match at all?
06:43:03 <quicksilver> int-e: the [Int] version instead
06:43:09 <quicksilver> dcoutts: no match at all = empty list
06:43:29 <TuringTest> EvilTerran and quicksilver : The RegexLike offers functions which are used to build the long list of RegexContext instances.  So you can avoid using the magic 'match' and 'matchM' if they are not your style.
06:44:01 <Japsu> @src tails
06:44:01 <lambdabot> tails []         = [[]]
06:44:01 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
06:44:19 <quicksilver> TuringTest: fair answer
06:44:22 <dcoutts> quicksilver: or include the leading span
06:44:28 <quicksilver> dcoutts: yes, or that
06:44:35 <dcoutts> quicksilver: like span/break
06:44:41 <quicksilver> dcoutts: doesn't feel like such a clean API, for some reason
06:44:42 <idnar> @src heads
06:44:42 <lambdabot> Source not found. My pet ferret can type better than you!
06:44:48 <idnar> heh
06:44:49 <TuringTest> dcoutts:
06:44:51 <quicksilver> dcoutts: but it conveys more information, I agree
06:45:39 <dcoutts> quicksilver: so if there's no match we get findSubstring needle haystack = (haystack,[])
06:45:51 <dcoutts> like for span
06:46:03 <quicksilver> yes
06:46:09 <TuringTest> The main return should be absolute indices.  You can use a newtype to make an instance which returns relative indices.  You can use newtypes to obtain any semantics you want from the type class instances.  One might want a tuple of (index,BS) for instances.
06:46:13 <doserj> you mean [(haystack,[])]?
06:46:16 <quicksilver> I agree that is more general
06:46:19 <dcoutts> doserj: no
06:46:28 <dcoutts> quicksilver: or just provide findSubstring and let people do what they like for the many case
06:46:40 <roconnor>  @pl (\x -> any (\y -> claim == claimName y) (marketData x))
06:46:44 <dcoutts> that's what Data.List does
06:47:00 <roconnor> @vixen hello?
06:47:00 <lambdabot> how're you?
06:47:02 <dcoutts> it doesn't provide any 'many' variant of span/break
06:47:02 <TuringTest> dcoutts: Another API issue is whether the matches can be overlapping....
06:47:09 <roconnor>  @pl (\x -> any (\y -> claim == claimName y) (marketData x))
06:47:24 <roconnor> @vixen how do I get the pointless command to work?
06:47:24 <lambdabot> how? it depends...
06:47:25 <dcoutts> TuringTest: mm, true. The single shot version would allow that
06:47:32 <roconnor> @vixen depends on what?
06:47:33 <lambdabot> let me answer that later, okay?
06:47:43 <roconnor> @vixen :/
06:47:44 <lambdabot> Beer, it's so much more than just a breakfast drink!
06:47:45 <dcoutts> @pl (\x -> any (\y -> claim == claimName y) (marketData x))
06:47:45 <lambdabot> any ((claim ==) . claimName) . marketData
06:47:54 <dcoutts> roconnor: no leading ' '
06:47:55 <DavidLeon> i've read the famous qsort in haskell
06:48:01 <DavidLeon> i've got a little bit questions
06:48:06 <TuringTest> dcoutts: Some efficient algorithms cannot be made from single shot versions.
06:48:09 <roconnor> dcoutts: oops
06:48:09 <DavidLeon> does it work in runtime?
06:48:13 <dcoutts> TuringTest: true
06:48:23 <dcoutts> TuringTest: like searching for many strings at once
06:48:27 <quicksilver> dcoutts: I think it's useful to provide a many case, if you want to guide your users into an "efficient" way of doing it
06:48:45 <DavidLeon> that qsort thing seems like only work for static list?
06:48:56 <TuringTest> dcoutts: So you want a type class wit a single shot and multi-overlap and non-overlap versions.  So the type class has 3 methods.
06:48:58 <dcoutts> quicksilver: I think in our case there's no efficiency advantage
06:49:14 <quicksilver> dcoutts: well the original point was to "guide" users away from using indices
06:49:25 <quicksilver> dcoutts: and towards using direct "sub-ByteStrings"
06:49:26 <dcoutts> quicksilver: yes, the span style does that, no?
06:49:29 <quicksilver> it does
06:49:52 <quicksilver> dcoutts: You may possibly find this email interesting : http://www.haskell.org/pipermail/haskell-cafe/2007-July/028032.html
06:49:54 <lambdabot> Title: [Haskell-cafe] needsaname :: ([a] -> Maybe (b, [a])) -> (b -> [a]) -> [a] -> [a], http://tinyurl.com/2xyxyq
06:49:54 <TuringTest> DavidLeon: sorting can be done on a list constructed at run time.
06:50:12 <TuringTest> DavidLeon: It is not a compile-time trick.
06:50:16 <quicksilver> dcoutts: I think a correctly efficient 'morph' would be a powerful tool in a ByteString library
06:50:29 <dcoutts> quicksilver: morph?
06:50:41 <quicksilver> dcoutts: see the email :)
06:50:46 * dcoutts notices
06:50:51 <DavidLeon> TuringTest: umm, i see ^^
06:50:51 <quicksilver> dcoutts: it's basically generalised search + replace + concat
06:51:05 <dcoutts> hmm
06:51:08 <dcoutts> sed ? :-)
06:51:10 <quicksilver> dcoutts: ideally you want it to work with bytestrings without copying the un-changed portions
06:51:14 <quicksilver> dcoutts: yes, pretty much
06:51:44 <dcoutts> quicksilver: that only works on lazy bs of course
06:51:51 <dcoutts> at least with zero-copy
06:52:04 <dcoutts> zero-copy is probably over-rated anyway
06:52:11 <quicksilver> dcoutts: well the "source" could be strict, if I correctly understand bytestrings
06:52:18 <quicksilver> dcoutts: but the destination has to be lazy
06:52:21 <dcoutts> right
06:52:30 <DavidLeon> i'm interested in how haskell compiler eliminates the temp list generated by the filter func, and also the recursive calling of the qsort
06:52:37 <dcoutts> and it's easy to make a strict bs into a one-chunk lazy one
06:52:45 * quicksilver notes that strict-lazy aren't really the right words for it
06:53:12 <quicksilver> dcoutts: you may be right about zero-copy being over-rated
06:53:23 <quicksilver> dcoutts: but it feels promising for stream processing large data
06:53:27 <dcoutts> quicksilver: esp for short stuff, for really big stuff, sure.
06:53:30 <matthew_-> how on earth is instance Enum Int ?
06:53:46 <quicksilver> matthew_-: fromEnum = id, toEnum = id, roughly? :)
06:53:48 <dcoutts> the bookkeeping can easily be more expensive that copying
06:53:55 <quicksilver> dcoutts: yes, true
06:54:07 <TuringTest> dcoutts: Another argument for type classes: it makes it easier to mix strict and lazy bytestring arguments to the findSub function
06:54:12 <quicksilver> dcoutts: there have been discussions about a self-defragmenting ByteString
06:54:19 <matthew_-> quicksilver: show off ;)
06:54:33 <quicksilver> dcoutts: which attempts to keep chunk size kind-of optimal. Whatever that means.
06:54:34 <dcoutts> TuringTest: true true
06:54:49 <dcoutts> quicksilver: yes, we've been thinking of adding a defrag function
06:55:13 <dcoutts> quicksilver: but it's hard to know if it's a benefit in general, so I'm nervous about adding it to the lib more automatically
06:55:32 <quicksilver> dcoutts: yes, very hard
06:55:38 <quicksilver> dcoutts: (obviously) it depends what you're using it for
06:56:06 <quicksilver> dcoutts: in some contexts the main advantage of the "lazy" bytestrings is the fact that they can be GCed in pieces
06:56:13 <quicksilver> (most contexts, perhaps?)
06:56:29 <dcoutts> and they don't need to be in memory all at once
06:56:35 <TuringTest> dcoutts: I made 4 monomorphic functions to handle all SS LS SL LL strict and lazy combinations for the Boyer-Moore searching.  A type class would have simplified the API ( more haskellish, less o'camlish).
06:56:38 <quicksilver> isn't that saying the same thing?
06:56:56 <quicksilver> bearing in mind that I'm well known for not believing in lazy IO :P
06:57:04 <dcoutts> quicksilver: so not just the bits you've read can be GCed, the bits you've not read don't need to exist yet.
06:57:17 <dcoutts> IO isn't the only source of lazy bs
06:57:21 <quicksilver> yes, that's true
06:57:23 <dcoutts> eg lazy binary serialisation
06:57:27 * quicksilver nods
06:58:17 <dcoutts> TuringTest: aye, though I'm not sure we need all 4 variations 'natively'
06:58:42 <DavidLeon> @vixen you're smart
06:58:43 <lambdabot> Im going to be a movie star.  I just applied online for this new movie with chris farley.  It only cost me $50!
06:58:57 <DavidLeon> *costs :p
06:59:08 <TuringTest> dcoutts: The algorithm forces the searched-for string to be strict, and the searched-in string to be lazy.
06:59:28 <TuringTest> (Though I optimized that a bit later)
06:59:28 <dcoutts> TuringTest: exactly, so the LL case doesn't really exist
06:59:37 <dcoutts> since we force it to LS
06:59:42 <kosmikus> what's the current situation with wxhaskell on Windows? how difficult is it to get running?
06:59:43 <lambdabot> kosmikus: You have 1 new message. '/msg lambdabot @messages' to read it.
06:59:45 <EvilTerran> say i represent a queue as data Queue a = Q [a] [a]; enqueue (Q xs ys) y = Q xs (y:ys); dequeue (Q (x:xs) ys) = Just (x, Q xs ys); dequeue (Q [] []) = Nothing; dequeue (Q [] ys) = dequeue (Q (reverse ys) [])
07:00:00 <EvilTerran> am I right in thinking this has amortized O(1) enqueueing and dequeueing?
07:00:12 <dcoutts> TuringTest: similarly for SL, so the only cases are SS and LS
07:00:45 <quicksilver> EvilTerran: yes, although unless you are having fun with your own data structure, I suggest you just use Data.Sequence :)
07:00:52 <TuringTest> dcoutts: But we should not force the users to put to/from casts everywhere.  I would provide all four as separate functions and/or as instances of a class.
07:01:14 <DavidLeon> the qsort implementation of haskell, choose the the first number to divide the array, how could I pick the 3rd number to recursive call?
07:01:28 <TuringTest> dcoutts: The underlying algorithm should not leak through the API more than neccessary.
07:01:33 <EvilTerran> quicksilver, great. it was basically playing with toy problems, yeah.
07:01:37 <DavidLeon> or rather the (array length)/2 number
07:01:37 <dcoutts> EvilTerran: only if you use it non-persistently, see Purely Functional Data Structures book for details.
07:01:52 <EvilTerran> non-persistently?
07:02:00 <quicksilver> DavidLeon: list !! (length list / 2)
07:02:05 <EvilTerran> hm
07:02:10 <quicksilver> DavidLeon: however, the runtime cost for that is rather large
07:02:10 <dcoutts> EvilTerran: non-persistent / in a single threaded manner
07:02:12 <EvilTerran> quicksilver, div!
07:02:25 <quicksilver> DavidLeon: list !! (length list `div` 2)
07:02:26 <quicksilver> :)
07:02:28 <EvilTerran> ah, there's a PDF of that thar book
07:02:43 <EvilTerran> dcoutts, as in, only if i use it as if it's got a uniqueness type?
07:02:50 <dcoutts> EvilTerran: right
07:03:09 <dcoutts> EvilTerran: otherwise you can repeatedly pay the O(n) reverse cost if you happen to save a copy that's just about to need reversing
07:03:11 <EvilTerran> ah, yes, i see.
07:03:26 <EvilTerran> Data.Sequence is superior ;]
07:03:49 * EvilTerran reads the docs... finger trees, eh?
07:04:06 * EvilTerran might be tempted to do ADSA next year at this rate ;)
07:04:44 <dcoutts> TuringTest: I want to keep it simple and general for the BS api, so I'd probably go for SS and LL for the strict and lazy modules respectively
07:05:13 <dcoutts> TuringTest: the .Lazy module never mentions the Strict one at the moment, except for the to/fromChunks functions
07:05:37 <DavidLeon> seems this link http://haskell.org/hawiki/RunTimeCompilation is broken?
07:06:24 * EvilTerran ponders turning it into a monad for the heck of it
07:06:33 * EvilTerran wants his O(1) back, dagnabbit
07:07:05 <EvilTerran> i made a stack monad yesterday, i might as well make a queue monad today ;)
07:07:30 * EvilTerran notices he's winking an awful lot. I must've had too much coffee... **twitch twitch**
07:09:35 <quicksilver> twanvl: did you give any thought to applying the functional reference stuff to state buried in a monad?
07:20:21 <wsdo_okadr> quicksilver: what are these monads ?
07:21:31 <ekidd> wsdo_okadr: A surprisingly versatile programming trick, but not an immediately obvious one. :-)
07:21:38 <olsner> Monad n., warm fuzzy thing
07:23:03 <quicksilver> wsdo_okadr: they are a way to hide irritating details of plumbing
07:23:14 <ekidd> wsdo_okadr: Do you know about list comprehensions, in Python, etc.?
07:23:15 <quicksilver> wsdo_okadr: and, as a consequence often enable you to program more polymorphicaly
07:23:38 <quicksilver> bit like plasterboard and duct tape
07:23:59 <oerjan> @slap quicksilver
07:24:00 <lambdabot> why on earth would I slap quicksilver
07:24:04 <ekidd> > [ x+y | x <- [1,2,3], y <- [10,20,30] ]
07:24:06 <lambdabot>  [11,21,31,12,22,32,13,23,33]
07:25:28 <ekidd> Monads are a generalization of list comprehensions, but you can use many different data types instead of lists. And if you chose your data type correctly, you can implement side-effects, transactions, backtracking, and all sorts of other neat things.
07:25:32 <shapr> Good morning #haskell
07:25:38 <ekidd> shapr: Good morning!
07:25:51 <shapr> ekidd: Hiya, you'll be coming to CUFP, right?
07:26:01 <ekidd> Yup. And the Hackathon.
07:26:11 <shapr> Not that I'll be there :-)
07:33:01 <olsner> @quote {
07:33:01 <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"Invalid preceding regular expression")
07:33:15 <olsner> fail :(
07:35:00 <int-e> @quote \{
07:35:00 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
07:36:23 <olsner> @quote \{
07:36:23 <lambdabot> puusorsa says: do not try this in a shell: :() { :&:; } ;:
07:36:24 <idnar> heh
07:36:43 <idnar> I think it looks nicer without the spaces
07:37:50 <dcoutts> cognominal_: is that from a clean yi tree using ghc-6.6.1 and cabal-1.1.6.2
07:38:25 <dcoutts> quicksilver: TuringTest: http://www.haskell.org/pipermail/libraries/2007-September/008199.html
07:38:26 <lambdabot> Title: substring search api, http://tinyurl.com/2c7cm7
07:39:15 <olsner> yeah, it is much less obvious that way... looks more like a parser bug exploit than a forkbomb
07:39:57 <TuringTest> dcoutts: hmmm...thanks
07:40:11 <shapr> @quote
07:40:11 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
07:40:14 <shapr> aww
07:40:18 <shapr> @quote shapr
07:40:18 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
07:40:25 <shapr> @quote foo
07:40:25 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
07:40:28 <shapr> suck
07:40:42 <quicksilver> dcoutts: FWIW, my version of findSubstrings included the whole tail, not just that up to the next match
07:41:02 <quicksilver> dcoutts: I find that more haskelly but either can be useful :)
07:41:04 <olsner> although there's another variant of it with {:|:&} in the body of the function - I wonder how the pipe works there
07:42:19 <dcoutts> quicksilver: oh yes, I see
07:42:31 <dcoutts> quicksilver: that's more consistent with an overlapping span style
07:42:43 <dcoutts> quicksilver: feel free to post that point in a reply
07:42:47 <olsner> perhaps it's just more forks in the same number of characters, since all parts of a pipe sequence must be started separately... and it also uses pipes which may not be in infinite supply!
07:42:59 <dcoutts> quicksilver: I didn't realise that's what you meant at first
07:43:33 <olsner> @quote \{
07:43:33 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
07:44:03 <olsner> what happened? operator sabotage?
07:44:07 <quicksilver> dcoutts: I woudl note, as an aside, that ndm uses these two different styles in TagSoup
07:44:09 <dcoutts> quicksilver: that has an advantage that we do not need an initial span
07:44:23 <dcoutts> quicksilver: which styles exactly?
07:44:25 <quicksilver> dcoutts: he calls one 'sections' and, erm..
07:44:38 <malcolmw> dcoutts: I'm not convinced this equation is correct:-)  break isSpace "foobar" == ("foo bar", "")
07:44:54 <dcoutts> doh
07:44:59 <dcoutts> > break isSpace "foobar" == ("foobar", "")
07:45:01 <lambdabot>  True
07:45:40 <quicksilver> dcoutts: oh, the other one 'partitions'
07:46:03 <malcolmw> dcoutts: but I do think the break/span-like API is preferable to one that returns indexes
07:46:19 <quicksilver> http://www.cs.york.ac.uk/fp/haddock/tagsoup/Text-HTML-TagSoup.html#v%3Apartitions
07:46:21 <lambdabot> http://tinyurl.com/2ojdv5
07:46:31 <dcoutts> malcolmw: yes, though how about the overlapping vs non issue
07:47:22 <malcolmw> dcoutts: letting people define their own multiple-span function if they require it seems right.  It will be difficult to predict someone's exact requirements otherwise
07:47:45 <dcoutts> malcolmw: I leaning in that direction too
07:48:06 <malcolmw> dcoutts: some multiple-span variations are just a simple fold using the single-span function in any case
07:48:16 <dcoutts> malcolmw: indeed
07:50:18 <malcolmw> hi andyjgill
07:50:53 <wsdo_okadr> exit
07:53:20 <quicksilver> dcoutts: you could be really friendly and indicate int he documentation how you might do that :)
07:53:39 <quicksilver> dcoutts: I find it extremely hard to draw the line between what to implement and what not to implement in haskell
07:54:08 <dcoutts> quicksilver: aye, what to put in the lib vs what bits of glue code to leave in the caller
07:54:13 <quicksilver> dcoutts: a function may have a one-line definition, but there may still be value in defining it in a library purely to give it a name (which people can talk about, and recognise in other people's code)
07:54:21 <dcoutts> yes
07:54:31 <dcoutts> esp if it occurs frequently
07:54:41 <dcoutts> but if the range is too great...
07:55:01 <quicksilver> if 70% of bytestring code included "findSubstrings = unfoldr ..."
07:55:06 <quicksilver> then you know you got it wrong :)
07:55:17 <dcoutts> quicksilver: yeah, then we'd know we needed to add it
07:55:31 <quicksilver> if 70% of bytestring code has its own definition, being one of 7 possible slightly different variants then .. hmm..
07:55:49 <quicksilver> then I don't know what's going on. Maybe someone has the abstraction level wrong :)
07:55:58 <quicksilver> or maybe it's just there aren't always simple answers...
07:59:33 <dcoutts> quicksilver: if a generalisation of all 7 is no simpler then I'd leave it as is with all 7
07:59:55 <quicksilver> dcoutts: yes, quite
08:00:00 <quicksilver> dcoutts: hard call to make though
08:00:09 <quicksilver> dcoutts: depending on the exact value of '7'
08:00:17 <dcoutts> quicksilver: canonical example: tokenise
08:00:43 <dcoutts> there's a string tokenise function in loads of programs/libs
08:00:58 <quicksilver> dcoutts: yes, good example
08:01:11 <dcoutts> but try and find one that covers most uses, and doesn't make the simple uses really complex...
08:01:13 <quicksilver> dcoutts: there is one in almost every FP program I've ever written, in fact :)
08:01:17 <dcoutts> yeah
08:01:44 <dcoutts> there's probably a reasonably small set that cover most cases with reasonable clarity
08:01:51 <dcoutts> but finding them is hard
08:02:08 <dcoutts> for starters it would have to be possible to define words, lines, and lines' in terms of them
08:02:53 <quicksilver> and there are questions about how much 'balancing' you need to do
08:03:07 <quicksilver> and whenever you're doing 'balancing' you probably also need some kind of 'escaping'
08:03:20 <quicksilver> "\"\\\\"\""
08:03:25 <quicksilver> etc :)
08:03:34 <malcolmw> the implementation of cpphs has somewhere between four and five different tokenisers internally
08:04:01 <hpaste>  roconnor pasted "How would you generalize these two functions into two instances of one function?" at http://hpaste.org/2797
08:04:58 <malcolmw> Adam Bakewell and Colin Runciman. "Automated Generalisation of Function Definitions". Proc. Functional and Logic Programming (FLOPS'99). November 1999.
08:05:22 <quicksilver> roconnor: of you want to be really cute, you'd put lowProb and highProb into custom monoids
08:05:37 <quicksilver> roconnor: and have the monoidal operation do the 'right' thing resp. addition and subtraction
08:06:08 <quicksilver> roconnor: then which code is selected depends just on which Monoid instance you pass it
08:06:41 <roconnor> quicksilver: that was my thought too
08:06:50 <roconnor> you see why I hesitate
08:06:59 <quicksilver> I don't know if would result in 'clearer' code, though
08:07:22 <EvilTerran> couldn't you do it with passing highProb and lowProb as parameters?
08:07:37 <quicksilver> EvilTerran: well you need to change some plusses to minusses, too
08:07:38 <EvilTerran> one way round for one function, t'other for t'other
08:07:48 <EvilTerran> ah, yes.
08:08:01 * EvilTerran needs a charwise diff of the two functions ;]
08:08:17 <olsner> "(hpx - adj)):(fixup (he-adj)" and "err = 1 - lowProb target - sum (map lowProb claims)" seems to be the two parts that differ
08:08:38 <olsner> and (highProb target) vs (lowProb target) in the first line
08:09:33 <doserj> data Opt = High | Low as an additional parameter would be too easy?
08:09:55 <roconnor> quicksilver: actually rather switch between doing a - b and b - a rather than switching pluses and minuses.
08:10:23 <olsner> yes, there's always the if-based solution :P
08:10:31 <quicksilver> roconnor: in that place, yes but then in the - adj  + adj case...
08:10:56 <roconnor> quicksilver: ah right. ... I almost missed that
08:11:22 <ndm> dcoutts: do not use tagsoup as an example of API design, because it really wasn't designed, it just happened
08:11:39 <dcoutts> ndm: it's about needs, not design as such
08:11:43 <dcoutts> use cases
08:12:08 <ndm> true :)
08:12:15 <quicksilver> ndm: I was just interested by the fact that you'd seen the need for 'partitions' and 'sections'
08:12:17 <roconnor> quicksilver: maybe if I change one case to having adj being a negative value, I can expose more symmetry in the two operations.
08:12:28 <ndm> dcoutts: could the substring searching go in a separate package from bytestring?
08:12:29 <quicksilver> ndm: and what dcoutts was discussing reminded me of them
08:12:35 <roconnor> then min becomes max and such.
08:12:54 <ndm> quicksilver: they are both necessary, in different places - partitions is usually more useful since you are searching on a single lexeme at a time, but both get used
08:13:01 <ndm> (and neither has a good name)
08:13:03 <quicksilver> ndm: yes, I know, I've seen your examples :)
08:13:05 <dcoutts> ndm: no, I think a simple case is needed. We can add more sophisticated stuff in another lib sure.
08:13:12 <quicksilver> ndm: and, indeed, I've used them myself
08:13:14 <dcoutts> but we need a simple default
08:13:41 <dcoutts> ndm: but the many case could easily be dropped imho
08:13:55 <ndm> dcoutts: i meant you can keep simple+complex ones in another library, and once you have real users, you can figure out which ones belong in bytestring itself
08:14:16 * roconnor tries his hand and program transformaton
08:14:24 <dcoutts> ndm: sure, but what do I do with the api we have now? get rid of it completely?
08:14:28 <roconnor> at program transformatoin
08:14:33 <ndm> dcoutts: move it to the library
08:14:36 <roconnor> ... stupid fingers
08:14:44 <dcoutts> ndm: I really want to avoid freezing and promoting the current bad api
08:14:52 <ndm> roconnor tries his hand and finds it wanting
08:15:01 <dcoutts> ndm: so post your thoughts to the list. I've got to go catch a train
08:15:10 * dcoutts -> London
08:16:04 <roconnor> ndm: actually I already made an error
08:17:38 <TuringTest> dcoutts: I replied to the mailing list
08:20:05 <hpaste>  roconnor annotated "How would you generalize these two functions into two instances of one function?" with "phase 1: transforming highOpt to look more like lowOpt" at http://hpaste.org/2797#a1
08:20:25 <quicksilver> TuringTest: I don't understand why you think the BS-returning version requires forcing the whole input string?
08:20:44 <TuringTest> quicksilver: How do I know the offset of the second returned hit?
08:20:49 <quicksilver> TuringTest: calculating offsets obviously requires you to force up to that chunk, and the choice of API doesn't make it worse
08:21:14 <roconnor> wow, by changing the sign of an arguement, I see the functions are more similar than I had realized.
08:21:19 <quicksilver> TuringTest: in dcoutts' version, you take the length of the prefix
08:21:32 <quicksilver> TuringTest: that only forces up to that point :)
08:21:34 <roconnor> min -> max; lowProp <-> highProb
08:21:49 <quicksilver> TuringTest: which is not avoidable anyhow
08:21:53 <TuringTest> quicksilver: That only works for the findSubstring (one hit returned version).  I objected to the (BS,[BS]) version.
08:22:18 <quicksilver> TuringTest: then your comment was attached to the wrong chunk of quoted text
08:22:23 <TuringTest> oh well
08:22:29 <quicksilver> TuringTest: because it appears just after the (BS,BS) version :)
08:23:12 <TuringTest> quicksilver: Mainly I wanted to emphasize that findSubstrings pre-preprocesses the search-for string and this should be part of the API, and might be considered another regex backend.
08:23:15 <quicksilver> TuringTest: but yes, you're quite right that the full "tails-like" version almost-throws-away that information
08:23:21 * quicksilver nods
08:24:13 <TuringTest> A nice think about Haskell is that whatever is done in the ByteString lib, I could always release a regex backend that wraps it.
08:24:26 * TuringTest must go to meeting
08:27:51 <hpaste>  roconnor annotated "How would you generalize these two functions into two instances of one function?" with "phase 2: the merge" at http://hpaste.org/2797#a2
08:29:45 <olsner> now it's just the inconsistent l/h prefixes left... like le = e, lpx = pAx, hpx = pBx (or something)
08:30:23 <olsner> :t mapAccumL
08:30:25 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:33:46 <olsner> fixup' e x = (e - adj, (claimName x, shares x, lpx + adj)), fixup e xs = snd (mapAccumL fixup' e xs)
08:37:10 <quicksilver> JaffaCake: d'oh. I didn't click the up arrow even one time which would have revealed the other exception :)
08:53:07 <greenrd> Is (a, a) an instance of anything which (a, b) isn't?
08:53:31 <greenrd> and how would I search for such instances?
09:01:01 <EvilTerran> @hoogle (a,a)
09:01:09 <lambdabot> Data.Map.findMax :: Map k a -> (k, a)
09:01:09 <lambdabot> Data.Map.findMin :: Map k a -> (k, a)
09:01:09 <lambdabot> Data.Map.elemAt :: Int -> Map k a -> (k, a)
09:01:17 <smashor> Hi, another beginner's question: I want to read in a text file, line by line. If I understood it correctly, there's no way to achieve this with the basic I/O operations - instead, I have to use the IO module.
09:01:40 <EvilTerran> lines . getContents?
09:02:20 <balodja> @type join (,)
09:02:23 <lambdabot> forall a. a -> (a, a)
09:02:42 <smashor> EvilTerran: but getContents returns a single string
09:02:43 <EvilTerran> do contents <- readFile "blah.txt"; let ls = lines contents; ... -- smashor
09:02:52 <EvilTerran> @src lines
09:02:52 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
09:03:00 <EvilTerran> > lines "foo\nbar\nbaz"
09:03:03 <lambdabot>  ["foo","bar","baz"]
09:03:37 <EvilTerran> smashor, readFile is lazy (in a slightly dubious manner), so it'll only read characters when you need 'em
09:04:13 <EvilTerran> so f . words =<< readFile is not as gratuitously memory-hogging as you might think
09:04:14 <smashor> EvilTerran: well, never heard of lines. But I see what it's doing.. well this is just the simple way. Thanks , just learned a bit more
09:05:29 <EvilTerran> smashor, if you might be writing to or otherwise changing the file after you start reading from it, it's probably better to use hGetLine etc from System.IO, however.
09:05:53 <EvilTerran> as the laziness of readFile can cause strange effects in those cases
09:06:09 <quicksilver> and if you care about recovering elegantly from exceptions
09:07:01 <smashor> EvilTerran: just write a simple dictionary program and want to implement the "searchWord" function. I read in all lines, compare whether a match is found, and print that line. so there should be no problem with lines and getContents...
09:24:24 <jatqceer> is there any library function that has type [a -> b] -> a -> [b]?  apply a list of function to a and get a list of b
09:25:42 <quicksilver> jatqceer: yes
09:25:53 <quicksilver> jatqceer: although not quite in that order
09:25:54 <kpreid> @type \f -> map ($ f)
09:25:56 <lambdabot> forall a b. a -> [a -> b] -> [b]
09:26:19 <quicksilver> > map ($5) [(+1),(*3),(/2)]
09:26:20 <lambdabot>  [6.0,15.0,2.5]
09:26:28 <kpreid> then there's "swing"
09:26:29 <quicksilver> jatqceer: ^^ three functions applied to 5
09:26:42 <jatqceer> ah, thanks
09:27:16 <jatqceer> i didn't know i could do ($ b) in map
09:27:55 <kpreid> jatqceer: there should be no reason to believe you can't.
09:27:58 <quicksilver> jatqceer: $ is an operator for function application
09:28:00 <kpreid> @type ($ 5)
09:28:02 <lambdabot> forall a b. (Num a) => (a -> b) -> b
09:28:10 <quicksilver> jatqceer: and you can section all operators, tis very powerful :)
09:28:11 <idnar> @pl \f -> map ($ f)
09:28:11 <lambdabot> map . flip id
09:28:22 <roconnor> @pl ($)
09:28:23 <lambdabot> id
09:28:27 <quicksilver> jatqceer: sections are great for making code concise
09:28:45 <idnar> @pl \fs v -> map ($ v) fs
09:28:45 <lambdabot> flip (map . flip id)
09:30:16 <jatqceer> right, i was playing with map without luck until i saw that
09:32:23 <jatqceer> @pl \x -> map ($x) [(+1),(*3),(/2)]
09:32:23 <lambdabot> flip map [(1 +), (3 *), (/ 2)] . flip id
09:32:44 <quicksilver> !!!
09:32:51 <quicksilver> @pl knows that + and * are commutative?
09:32:52 <lambdabot> (line 1, column 36):
09:32:52 <lambdabot> unexpected end of input
09:32:52 <lambdabot> expecting white space or simple term
09:33:00 <quicksilver> @pl (+1)
09:33:00 <lambdabot> (1 +)
09:33:03 <quicksilver> freaky
09:33:29 <Botje> @pl \a -> 1 + a + b
09:33:29 <lambdabot> ((b + 1) +)
09:33:32 <jatqceer> lot smarter
09:34:12 <quicksilver> Botje: ah, I see. Handy.
09:34:18 <quicksilver> jatqceer: it's not true, of course :)
09:34:38 <quicksilver> jatqceer: (+) is not even associative with floating point numbers
09:34:47 <quicksilver> but then again, floating point numbers are horribly evil
09:35:15 <jatqceer> i love them.  Double is my friend
09:35:30 <quicksilver> You think he is, sure
09:35:34 <quicksilver> he says nice things about you
09:35:46 <quicksilver> but one day, when your back is turned, he will stab you in the back with a mantissa
09:37:03 <jatqceer> but, i can't live without them.  those floating point numbers are just floating around me all the time
09:39:34 <twanvl> quicksilver: (I was away, so a slow response) You could change 'gets' and add 'sets' that take a reference, I don't see a way to make it more generic without reverting to MPTCs+fundeps/ATs. Another minor problem is that Control.Monad.State currently uses the names 'get', 'set' and 'update'
09:40:05 <quicksilver> twanvl: well the nice part would be to have your version of 'update' working
09:40:11 <quicksilver> twanvl: and have type-class automagic
09:40:16 <allbery_b> @remember quicksilver <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he will stab you in the back with a mantissa
09:40:16 <lambdabot> Done.
09:40:32 <quicksilver> twanvl: so that it can 'find' the right bit to change even in multi-layered state
09:40:46 <quicksilver> twanvl: (using your idea of composable FPRefs)
09:41:41 <twanvl> Well you can write that as: updateS $ updateR ref fun    where updateS = Control.Monad.State.update; updateR = Data.Ref.update
09:41:57 <twanvl> Of course you could make a single function for it
09:42:02 * quicksilver nods
09:42:20 <quicksilver> but suppose I have the ref == 'mode'
09:42:26 <quicksilver> (name of the reference bit)
09:42:35 <quicksilver> I want a typeclass StateMode ...
09:42:48 <quicksilver> which refers to all Monads which have a mode ref buried somewhere inside
09:42:59 <quicksilver> and get transparent composition through layers of nested records
09:43:49 <twanvl> That would be cool
09:44:09 <quicksilver> I am forever writing crap like this: \ws -> let StartMenu i s = playing ws in ws { playing = StartMenu (inc i) s }
09:44:17 <quicksilver> here 'playing' is a record selector
09:44:23 <quicksilver> so I'm deconstructing my record
09:44:30 <quicksilver> and I'm also deconstructing 'StartMenu'
09:44:42 <quicksilver> just to apply 'inc' to the 'i' buried inside there
09:44:49 <quicksilver> annoying mess for a simple change
09:44:55 <twanvl> Just references take care of most of that
09:45:17 <quicksilver> to the left of the \ws is "env $~"
09:45:32 <quicksilver> where $~ is Sven Panne's binding around 'modifyIORef', basically
09:45:44 <twanvl> update (playing . startMenuFirst) inc
09:45:49 * quicksilver nods
09:46:28 <hpaste>  kjdf pasted "please help fix "undo"" at http://hpaste.org/2798
09:46:58 <kjdf> can someone help? the error messages are quite intimidating when trying to compile
09:47:14 <ekidd> Since I appear to have dropped off Haskell Planet, here are my plans in Freiburg:
09:47:31 <quicksilver> twanvl: I need to play with it some more
09:47:39 <ekidd> http://www.randomhacks.net/articles/2007/09/18/freiburg-in-october
09:47:41 <lambdabot> Title: Freiburg in October: Scheme, Dylan, and probability monads, http://tinyurl.com/26tu7k
09:47:56 <sjanssen> kjdf: please paste the error messages
09:49:32 <sjanssen> kjdf: ah, I see the problem.  You're existentially quantifying 'm' inside SAState, existentials aren't allowed to escape
09:50:00 <kjdf> sjanssen: what does that even mean? :)
09:50:03 <hpaste>  kjdf annotated "please help fix "undo"" with "compilation errors" at http://hpaste.org/2798#a1
09:50:21 <sjanssen> kjdf: what do you think the type of "\(SAState _ _ _ _ u) -> u" should be?
09:51:29 <sjanssen> kjdf: you probably shouldn't be using GADTs if you don't know this stuff, it's easy to write complex things accidentally
09:52:07 <kjdf> perhaps I shouldn't
09:52:34 <sjanssen> kjdf: the problem is that SAState could be wrapping *any* monadic type
09:53:02 <kjdf> anyway, you can see in "minimize" that I am threading the 'undo' from the 'neighbour' computation
09:53:12 <kjdf> I just want to put that into SAState as well
09:53:19 <JohnnyL> what's a good haskell tutorial for newbies to functional/haskell programmer (cover up to intermediate).
09:53:22 <JohnnyL> ?
09:53:28 <sjanssen> kjdf: I think you want "data SAState m a"
09:54:20 <kjdf> sjanssen: yes, I do.
09:54:42 <kjdf> I'll try fiddling around with that
09:54:46 <kjdf> thanks :)
09:56:27 <Lemmih> JohnnyL: People seem to recommend yaht.
09:56:49 <JohnnyL> Lemmih, you mean the online stutf?
09:57:00 <JohnnyL> i'm in a hospital, so I"m limited to 2 hours a day.
09:57:25 <Saizan> JohnnyL: you can download it as pdf
09:57:31 <Botje> JohnnyL: there's a pdf you can print
09:57:49 <JohnnyL> thats nice if you have access to a printer.
09:58:22 <Philippa> so you're actually after a book?
09:58:46 <JohnnyL> yah
09:59:22 <therp> when building with Cabal, "local" modules by the same name are preferred over modules in packages?
10:01:38 <Lemmih> JohnnyL: Haskell: The Craft of Functional Programming, is pretty good.
10:02:03 <JohnnyL> ok
10:02:10 <JohnnyL> thanks
10:05:04 <slarba_> *baffled*
10:05:30 <slarba_> does a segfault at s33k_info mean anything to anyone?
10:06:49 <slarba_> seems to be related to lazy bytestrings and context switch (since crash does not occur with +RTS -C0)
10:07:19 <slarba_> compiling with -debug does not produce any useful information
10:11:53 <kjdf> sjanssen, you rule
11:12:09 <dons> http://programming.reddit.com/info/2qw37/comments
11:12:10 <lambdabot> Title: Solving the "word numbers" problem (reddit.com)
11:16:35 <dons> ekidd: congratulations :)
11:16:47 <ekidd> dons: Many thanks!
11:16:49 <dons> everyone's getting married. (i can think of 4 or 5 #haskellers..)
11:17:03 * therp isn't
11:17:03 <dons> including me ;)
11:17:09 <shapr> Or at least, relationships are changing for many of us.
11:17:12 <shapr> dons: congrats!
11:17:26 <ekidd> dons: Congratulations to you as well!
11:17:50 <dons> getting old :)
11:18:04 * ekidd will probably bring a Control.Monad.Probability library to Hac...
11:18:21 <dons> sounds good. yes, i saw the post
11:18:37 <dons> you do need something to hack on that you're reasonably familiar with, to make the most of it
11:18:50 * therp only got a new girlfriend, and he recently explain "map" to her :)
11:18:50 <sjanssen> dons: congratulations!
11:19:15 <dons> thanks!
11:19:19 * dylan is getting married in a few months too.
11:19:51 <ekidd> Congrats, dylan! It really does seem to be the season.
11:20:24 <dylan> February 29th is the ceremony part, but the legalities are happening much sooner. :)
11:20:24 <dons> SyntaxNinja and droundy also just got married, and glguy
11:20:51 <scandal> the "Building production stable software in haskell" thread seems very similar to the situation with lisp vs. common lisp.  i wonder if many haskellers are ex-lispers?
11:20:52 <ibid> you're so depressing people, you know :)
11:21:00 <Philippa> 'grats to all the newlyweds!
11:21:31 <dylan> woo!
11:21:34 <dylan> everything went green.
11:21:59 <dylan> I think the magic fairies that make this 21" CRT are dying.
11:22:35 <shapr> dylan: Wiggle the VGA cable at the back of the monitor, should fix it.
11:22:42 <dylan> shapr: Nope.
11:22:43 <ibid> scandal: well, considering that the #lisp.fi channel was all about haskell the last time i looked in ... :)
11:22:49 <ibid> (on ircnet, i believe)
11:23:05 <shapr> dylan: Wiggle the VGA plug on the gfx card?
11:23:10 <dons> heya Philippa.
11:23:13 <shapr> hiya ibid
11:23:14 * therp raises the hand on the ex-lisper part, scandal
11:23:15 <dylan> shapr: yeah, it's not the physical.
11:23:16 * dons waves from Orrr-egon
11:23:36 <dylan> it's not just that everything is green, either. everything is less bright.
11:23:38 * ekidd hacks in Scheme at work
11:23:46 * shapr hacks in Haskell at work
11:23:54 <ekidd> Oooh, that's cool.
11:24:16 * CosmicRay hackes in Haskell at work too
11:24:33 * dons hacks Haskell at work too too
11:25:02 * ibid currently doesn't hack very much
11:25:05 * dylan hacks badly written perl at work.
11:25:05 * ibid writes
11:25:13 <CosmicRay> dylan: yeow.
11:25:14 * Nafai hacks Java at work
11:25:15 <Nafai> :(
11:25:29 <CosmicRay> I'm not sure who has the more annoying task: dylan or nafai
11:25:34 <mrd> lumberjacks hack trees at work
11:25:39 <scandal> perhaps it is just a sign of maturity that the discussion of "include many libs in the default install" (eg, java, python) vs "programmers are smart enough to choose their own libs" (scheme, lisp, perl)
11:25:45 <dylan> for what it's  worth, I also can take 2 hour lunches if I want
11:25:45 <CosmicRay> I would say that very badly written perl is probably worse than java, though on the otherhand, it can be improved more ;-)
11:26:06 <Nafai> CosmicRay: Heh
11:26:16 <dylan> I am in fact re-writing the badly written perl.
11:26:28 <Philippa> mrd: you're a lumberjack and you're okay?
11:26:31 <dylan> it's badly written in the way that C or java can be, actually. Copy 'n' paste code reuse.
11:26:43 <CosmicRay> oh, that's not quite as bad then.
11:27:00 <dylan> also, the person has no idea how foreach is supposed to work...
11:27:02 <CosmicRay> badly written perl can be one of the most inscrutable languages still in common use.
11:27:04 <CosmicRay> heh
11:27:25 <mrd> well, i do sleep all night and work all day
11:27:45 <dylan> I'd rather work all night and sleep all day
11:28:11 <mrd> it's tough to mix class with that
11:28:24 <CosmicRay> dylan: http://worsethanfailure.com/Articles/I-Didn%e2%80%99t-Know-You-Could-Do-That!.aspx
11:28:26 <lambdabot> Title: I Didn’t Know You Could Do That! - Worse Than Failure, http://tinyurl.com/2ej8zh
11:29:26 <shapr> http://worsethanfailure.com/Articles/I-Didn%e2%80%99t-Know-You-Could-Do-That!.aspx works
11:29:28 <lambdabot> Title: I Didn’t Know You Could Do That! - Worse Than Failure, http://tinyurl.com/2ej8zh
11:29:28 <shapr> agh
11:29:44 <mrd> time to hack more proofs
11:30:42 <CosmicRay> "'Ere, I just added a pointer to every piece of data that points to the next piece of data! ... What do you mean, 'array?'"
11:34:20 <crazy_coder> hey dons congrats
11:45:36 <Mr_Awesome> is it a bad idea to do a busy loop with HGL.getTime until a millisecond has elapsed? it seems that when i do this, at some point, getTime just hangs
11:45:52 <nominolo> @ho sleep
11:45:52 <lambdabot> Maybe you meant: hoogle hoogle+ . bf echo ft ghc id pl rc show thx v wn yow
11:46:00 <nominolo> @hoogle sleep
11:46:00 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
11:46:39 <nominolo> Mr_Awesome, i think there are ways to create a timer-event + callback
11:46:52 <dons> more catsters stuff on youtube, http://www.youtube.com/user/TheCatsters
11:46:53 <lambdabot> Title: YouTube - Broadcast Yourself.
11:47:32 <Mr_Awesome> hmm, actually its not getTime thats hanging. the program just freezes for no reason at all
11:48:17 <Mr_Awesome> nominolo: callbacks wont really work in this case
11:50:40 <kolmodin> has anyone tried F#?
11:50:58 <kolmodin> um. ok. I'm sure lots have tried it. anyone like to mention first impressions? :)
11:51:19 <dons> ocaml for windows?
11:51:26 <kolmodin> ocaml for .net :)
11:51:35 <dons> close enough
11:51:40 <kolmodin> hah, yeah :)
11:51:45 <dons> :)
11:52:00 <kolmodin> as I'm stuck with .net at work I thought it might be an option to look into
11:52:11 <nominolo> well, it's o'caml
11:52:30 <nominolo> even has (slow) join-calculus extensions
11:52:31 <dons> yeah, if you're using .net, F# is a good choice
11:52:47 <dons> we've got a student doing that at unsw, kolmodin, quite succesfully
11:53:05 <dons> there's also .NET bridge for haskell under development
11:53:16 <dons> if you're interested, talk to aja or ChilliX, about getting the code
11:53:21 <kolmodin> dons: right
11:53:22 <dons> should be pretty usable
11:53:46 <dons> F# at least you don't need to do bindings
11:53:47 <nominolo> kolmodin, but note that someone has to maintain your code some day after you ;)
11:54:16 <dons> that's right: a functional programmer, nominolo :)
11:54:36 <kolmodin> dons: I found several sites mentioning haskell and .net. the top site of googeling "haskell .net" gives a site which has no releases and not been updated since 2004
11:54:45 <nominolo> probably not too hard to find in göteborg, but still...
11:55:26 <kolmodin> nominolo: aye, that's why they don't won't let me use haskell :)
11:55:29 <dons> there's a very active project at unsw, kolmodin, from one of the top students here
11:55:33 <kolmodin> nominolo: but if I say it's micrsosoft... :)
11:55:40 <nominolo> lol
11:55:45 <nominolo> d'oh
11:55:49 <dons> i can get you in touch with the guys if you want to follow it up?
11:56:02 <kolmodin> sure :)
11:56:10 <kolmodin> they don't have a site yet?
11:56:38 <dons> let's see..
11:56:49 <ndm> you can also pass --dotnet to Yhc and get out .NET bytecode files
11:57:03 <dons> kolmodin: i'll see if i can get hold of it for you.
11:57:15 <kolmodin> dons: thanks
11:58:26 <kolmodin> ndm: interesting
11:58:38 <dons> i've mailed the authors, we'll see what they say
11:59:08 <Mr_Awesome> hmm, it seems that if you dont tell HGL to generate an event every millisecond or so, it will eventually stop generating any events at all
11:59:11 <kolmodin> yay
11:59:59 <nominolo> Mr_Awesome, you can't just use that "tick" event?
12:00:53 <Mr_Awesome> regardless, i think its interesting to know that
12:01:21 <dino-> dons: Were you being facetious about F#, or is it basically OCaml?
12:01:40 <Mr_Awesome> its easier to just do a busy loop. basically im writing a function that gets called every once in awhile and the time elapsed must be returned and > 0
12:01:48 <nominolo> well, i don't think hgl is maintained too actively.  i did a course homepage, and people were surprised that i used it
12:01:49 <dons> dino-: its pretty much exactly ocaml
12:02:03 <dons> so no, i was being literal
12:02:15 <Mr_Awesome> nominolo: perhaps. do you know of a better option?
12:02:20 <dino-> I wonder why not just call it what it is.
12:02:37 <nominolo> Mr_Awesome, depends on what you want to do -- opengl can draw 2D, too
12:02:45 <dino-> Maybe the answer to that is in the creepy history of how C# came to be.
12:02:55 <nominolo> Mr_Awesome, if you're on linux, pango+gtk is nice
12:03:14 <Mr_Awesome> id like it to be cross-platform
12:03:39 <Mr_Awesome> if i used ogl, what windowing system would i use though? glut?
12:03:53 <nominolo> Mr_Awesome, yes, glut.
12:04:30 <nominolo> Mr_Awesome, i know, gtk has an openGL widget; i don't think wxHaskell has, though
12:05:00 <nominolo> wxHaskell also seemed buggy on macosx
12:05:22 <dolio> @remember bitwize computer science advances by talented c++ programmers solving new cache and hash table problems. nothing else.
12:05:22 <lambdabot> Done.
12:06:28 <nominolo> btw, gtk is rather portable.  the win32 theme looks good and it works on osx, though doesn't look native
12:08:28 <dylan> it looks native if you happen to not use aqua ever. <g>
12:08:51 <nominolo> who uses vista anyways? ;P
12:09:23 <dylan> As soon as xmonad runs on it, I might consider it iff I was forced to.
12:09:23 <conal> apparently wxHaskell does have OpenGL support: http://wxhaskell.sourceforge.net/samples.html#opengl
12:09:24 * ndm has used vista (on friends computers)
12:09:24 <lambdabot> Title: wxHaskell
12:09:28 <nominolo> 20% cpu and 500MB ram usage in idle mode.. talk about bloatware
12:09:38 <ndm> thats not fair, it doesn't hit 20% CPU
12:09:38 <conal> i haven't used it, though.
12:09:43 <olsner> dolio: where from?
12:09:58 <ndm> it does suck (apart from Inkball), but it isn't that bad at CPU on idle
12:10:08 <Excedrin> it's 20% if you move the mouse
12:10:14 <dolio> He said it on reddit (in jest).
12:10:21 <nominolo> ndm, the pc in the store was bouncing between 5 and 20 %
12:10:24 <matthew-_> ndm: it will hit 20% cpu at idle if you underclock your cpu
12:10:54 <matthew-_> nominolo: you know, I bet that's dynamic frequency changing
12:11:18 <nominolo> matthew-_, possibly, but 5% is still unacceptable
12:11:21 <dino-> > filterM (const [True, False]) "abc"
12:11:22 <matthew-_> whenever it has work to do, it'll show 20%, raise the frequency, get the work done and then show 5%, drop back down...
12:11:22 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
12:11:40 <ndm> on the laptop i've been using last week, if you kill all the virus checker, toshiba "system utilities" etc, it was about 3-4%, i think
12:11:40 <matthew-_> nominolo: yeah yeah, I'm really not going to start defending microsloth
12:12:32 <nominolo> i'm relatively with ubuntu on my macbook now
12:13:19 <nominolo> there was a "happy" missing in the sentence above
12:13:56 <matthew-_> why did you waste the money on overpriced hardware?
12:14:36 <pejo> No no no - there's always a good reason to use a Mac. But why buy one to run Ubuntu?
12:14:54 <nominolo> matthew-_, it was a good offer at the time (student discount)
12:15:06 <sjanssen> pejo: some of use prefer to work in another operating system
12:15:22 <nominolo> pejo, i ran macosx for 1+ year
12:15:29 <sjanssen> Apple's hardware is generally nice, and reasonably priced if you buy at the right time
12:15:38 <matthew-_> nominolo: ahh, fair enough. Apple keep spamming me - I think my computing dept gives all our email addresses to apple in return for some educational discount on machines that NO ONE uses
12:15:43 <nominolo> but got annoyed at it's high resource usage
12:16:10 <sjanssen> nominolo: yes, I switched for much the same reason
12:16:21 <sjanssen> that and the fact that macports sucks
12:16:25 <nominolo> sjanssen, you use gentoo, right?
12:16:30 <sjanssen> nominolo: yeah
12:16:48 <olsner> I've found macports to Just Work, as opposed to linux counterparts I've come in contact with
12:16:52 <nominolo> i got kinda used to aptitude / binary packages in general
12:17:13 <sjanssen> olsner: IME, packages were very frequently broken
12:17:22 <matthew-_> ime, package managers come and go, but it's the quality of the packages that makes the difference
12:17:26 <dylan> macports is great, I just wish firefox 2 existed for X11. :(
12:17:35 <nominolo> (better than port install ghc -- wait 3h)
12:17:48 <sjanssen> nominolo: yeah, and it doesn't even have make -j support!
12:18:03 <matthew-_> just using apt gets you a great tool, but unless you back it up with the same commitment to QA that debian has, it's not going to be successful
12:18:31 <nominolo> matthew-_, yep.  QA is really important
12:18:39 <olsner> yeah, lacking make -j is just embarassing, given that almost every new Mac has 2 or more cores
12:19:02 <sjanssen> I'm pretty sure that it's 'every' by now
12:19:19 <nominolo> C2D
12:20:15 <nominolo> i guess the next intel chip is called, cee-too-dee-too
12:20:18 <dino-> yay, Debian. I've seen major upgrades to testing be a problem maybe twice in 4 years.
12:21:06 <matthew-_> dino-: I run unstable on my main work machines. Contrary to popular opinion, I don't spend hours every day keeping my machine working.
12:21:15 <dino-> matthew-_: Brave man. :D
12:21:34 <olsner> is testing more or less stable than unstable?
12:21:44 <dino-> olsner: Theoretically more stable
12:21:55 <dino-> stable -> testing -> unstable
12:22:03 <olsner> okay, so patches go from unstable to testing to stable?
12:22:07 <matthew-_> dino-: I love being on the edge man!! It's just so far out!! It's like all this stable software which the devopers are probably using themselves and have tested and I don't use anything fancy so it's just soooo rad!
12:22:22 <matthew-_> olsner: err, they often start in "experimental"
12:22:39 <olsner> oh, have they added that one recently or have I just missed it?
12:23:09 <nominolo> vaporware -> pre-alpha -> beta -> experimental -> unstable -> testing -> stable ;)
12:23:13 <dino-> matthew-_: I haven't tried it, but aren't you supposed to be able to downgrade that bad boy? Like change source.list to testing and dist-upgrade. I wonder if that really works.
12:23:55 <dino-> sources.list
12:25:22 <olsner> the *real* bleeding edge must be to use Duke Nukem Forever as your OS
12:26:35 <Japsu> the *real* bleeding edge does not have operating systems. all applications are self-contained and are run inside a virtual machine under a hypervisor.
12:26:38 <matthew-_> dino-: err, you can do pinning, normally it moans if you try to downgrade
12:27:37 <matthew-_> I don't ever do that. The solution to whatever ales you lies in the future, not the past ;)
12:27:47 <olsner> Japsu: nah, that's already here... apparently some JVM provider (the company behind JRockit, IIRC) have been developing a JVM-only operating system for use under a hypervisor
12:28:26 <nominolo> there's also MS Research's Singularity
12:29:16 <matthew-_> s/ales/ails/
12:29:40 <dino-> olsner: You know, I remember when Sun was trying to sell that Java-based thin client (JavaStation?) in 1996. This sounds so last-century.
12:29:40 <spx2> how much mathematics can one do with haskell ?
12:30:01 <lament> the subset which is turing-complete? :)
12:30:12 <spx2> what is turing-complete
12:30:13 <spx2>  ?
12:30:14 <nominolo> spx2, what do you want it to do?
12:30:18 <spx2> excuse my ignorance
12:30:27 <spx2> nominolo: I want to do number theory with it
12:30:40 <lament> for number theory, should be fine, although maybe not the most convenient tool.
12:30:45 <spx2> nominolo: and I want to do Measure theory with it
12:30:49 <nominolo> spx2, turing complete = "everything you can do with a computer"
12:30:55 <lament> for measure theory...
12:31:04 <spx2> nominolo: I suppose I would need to have a very good axiom system
12:31:10 <spx2> wich I don't think exists in measure theory
12:31:20 <spx2> thus existence of non-measurable sets ... etc
12:31:21 <lament> not sure about measure theory
12:31:29 <spx2> wich I dn't think haskell can comprehend
12:31:29 <nominolo> spx2, i suppose haskell is more of a programming language than a math system
12:31:39 <spx2> nominolo: so what can it do ?
12:31:52 <spx2> I hear people left and right , haskell is great, it can do "that and that "
12:32:05 <spx2> </trolling>
12:32:06 <spx2> <serios>
12:32:09 <spx2> <serious>
12:32:16 <spx2> what can haskell do at its peak ?
12:32:33 <lament> haskell is great, but it's not specifically designed for math.
12:32:36 <nominolo> it's not meant to do proofs, for example
12:32:37 <spx2> what most-complicated mathematical applications are implimented in haskell ?
12:32:38 <dino-> I've seen talk on one of the mailing lists about doing a different Prelude that's more math serious.
12:33:05 <spx2> lament: so what is it desigend for ?
12:33:14 <spx2> dino-: what's this Prelude ?
12:33:17 <lament> dino-: i would love a prelude with a frikking mod function that works on reals, and some way to deal with numbers without constantly having to cast them there and back :D
12:33:21 <lament> s/:D/:(
12:33:23 <nominolo> spx2, haskell uses quite a few mathematical constructs to structure programs
12:33:34 <lament> spx2: it's a general-purpose programming language.
12:33:41 <nominolo> spx2, formost it's a programming language
12:33:42 <ndm> it scares me every time people discuss this more mathematical prelude, as i'm pretty sure i'll be screwed the first time i come to add two numbers
12:33:43 <lament> spx2: just like most programming languages.
12:33:52 <spx2> I'm a perlist
12:34:01 <spx2> My day job is Perl
12:34:02 <Japsu> BURN HIM AT THE STAKE
12:34:02 <lament> spx2: and unlike Maple, Matlab, Mathematica and other things generally beginning with "Ma" that tend to do math stuff :)
12:34:19 <Japsu> ;P
12:34:27 <spx2> What is the difference between haskell and lisp ?
12:34:36 <olsner> haskell+math prelude = Maskell?
12:34:36 <lament> spx2: pretty much everything
12:34:37 <nominolo> spx2, haskell is statically typed
12:34:39 <Japsu> haskell has a practical syntax, lisp doesn't
12:34:40 * spx2 knows some lisp
12:34:48 <nominolo> Japsu, debatable !
12:34:48 <lament> spx2: haskell and lisp are almost nothing alike.
12:34:48 <spx2> nominolo: meaning ?
12:34:53 <sjanssen> s/practical//
12:34:56 <Japsu> nominolo: no, it's the ultimate truth
12:34:57 <Japsu> ...
12:35:04 <dino-> ndm: As not that great with math, scares me too. :)
12:35:06 <spx2> lament: so what is the strong point of haskell ?
12:35:16 <lament> spx2: what's the strong point of perl?
12:35:31 <spx2> lament: parsing
12:35:34 <lament> oh
12:35:36 <nominolo> spx2, you should really read a tutorial, that gives you a better idea -- there's lot's of stuff that requires < 30min to get started
12:35:38 <spx2> lament: It can parse the hell out of anything
12:35:41 <lament> then the strong point of haskell is also parsing.
12:35:46 <spx2> lament: it has very strong regex implimentation
12:35:46 <Japsu> ;)
12:35:46 <dino-> How would you describe what the Prelude is to someone?
12:35:57 <spx2> what does haskell do *BEST* ?
12:36:07 <lament> haskell is pretty good at parsing, certainly :)
12:36:09 <ndm> spx2: I can program in over 10 languages, Haskell makes me most productive by a long way
12:36:10 <nominolo> dino-, the "built-in" functions ;)
12:36:12 <travisbrady> the Prelude is like builtins in Python
12:36:19 <ndm> dino-: stdio.h
12:36:31 <lament> dino-: "standard library"
12:36:49 <spx2> ndm: how far is haskell about getting a job in it ?
12:37:03 <spx2> ndm: what kind of things do people write in haskell ?
12:37:06 <dino-> spx2: One of the big strengths of Haskell is that it allows no side-effects. The benefit being that a whole swath of common bugs can't be modeled or not easily.
12:37:12 <matthew-_> spx2: games
12:37:14 <ndm> spx2: you can, if you learn for the next 3 years you should be able to get a job, if you want one
12:37:35 <nominolo> spx2, security-critical stuff
12:37:35 <ndm> spx2: web servers, commerical applications, high assurance, fincance
12:37:42 <matthew-_> spx2: so, games, and some boring stuff too ;)
12:37:56 <dino-> spx2: Another benefit is lazy evaluation. You can do things like manipulate infinite lists.
12:38:10 <spx2> dino-: that sounds very cool
12:38:15 <spx2> I don't know if you heard
12:38:20 <spx2> but Claus Tondering
12:38:26 <spx2> has this article on Surreal Numbers
12:38:34 <spx2> I've read it and always wanted to impliment them
12:38:44 <spx2> it has to do with infinite sets
12:38:45 <jatqceer> if I have data N = A Int | B Double, and f :: Num a => a -> a, how do I define f' :: Num a => N -> a, so that f' (A a) = f a and f' (B a) = f a?  I tried f' (_ a) = f a, but it doesn't work
12:38:50 <dino-> > take 10 $ filter odd [1..]
12:38:52 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
12:39:19 <nominolo> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
12:39:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:39:37 <spx2> that's some strong stuff
12:39:39 <spx2> wtf ?
12:39:46 <dino-> spx2: This is very good and short reading: http://www.haskell.org/haskellwiki/Why_Haskell_matters
12:39:48 <lambdabot> Title: Why Haskell matters - HaskellWiki
12:39:52 <nominolo> that's the infinite list of the fibonacci sequence
12:40:46 <lament> somebody should write an article titled "Why Haskell doesn't matter"
12:41:11 <nominolo> spx2, http://sigfpe.blogspot.com/ talks about mathematical stuff + haskell
12:41:13 <lambdabot> Title: A Neighborhood of Infinity
12:41:21 <spx2> hollymother jesus christ
12:41:33 <spx2> what kind of mind do I need to impliment such abstractisations ?
12:41:34 <sieni> someone should write an article titled "Why juggling doesn't matter"
12:41:51 <dino-> Another thing, I look at the code and it's just gorgeous. I want to put it up on my fridge.
12:42:22 <matthew-_> hmmm. Does your fridge run Haskell?
12:42:23 <lament> juggling doesn't matter?
12:42:37 <Japsu> fridges are bad at running haskell
12:42:58 <matthew-_> the food in them side effects (goes mouldy) without you noticing!
12:42:58 <Japsu> porting ghc to a fridge usually incorporates a part with lots of pain and suffering
12:43:06 <matthew-_> fridges don't type-check!
12:43:10 <nominolo> spx2, you don't have to understand everything sigfpe writes ;)
12:43:33 <dino-> nominolo: ha, I was thinking something like that
12:43:33 <sieni> lament: I mean, the article would be as relevant as the article about haskell not mattering
12:45:41 <nominolo> dino-, i like however, that he introduces you to some mathematical concepts, which can really widen your horizon
12:46:56 <nominolo> that article is wrong: "It doesn't allow any side-effects"
12:47:19 <nominolo> should be "it doesn't allow any _hidden_ side effects"
12:48:12 <nominolo> otherwise, haskell would really be useless, as SPJ stated
12:48:51 <sieni> well, not really
12:49:26 <wli> It'd be an overgrown calculator language with no side effects.
12:49:26 <matthew-_> yeah, really useless - you wouldn't be able to write games in it
12:49:31 <nominolo> every program would only have one answer
12:49:44 <sieni> "tackling the awkward squad" discusses the situation before monadic io'
12:50:36 <nominolo> the problem was (and partially still is) how to best embed side effects
12:51:15 <nominolo> possibly the next advancement will be (practical) effect type systems
12:51:29 <dino-> nominolo: re: sigfpe  I don't think I've tried hard enough to read his stuff. I should change that.
12:51:51 <nominolo> since monads, etc, are viral
12:52:06 <matthew-_> nominolo: that's an interesting point. Lots of effect systems are in progress and done (at least, theoretically)
12:52:23 <omniscientIdiot> spx2: http://blogs.nubgames.com/code/?p=22 is a good read to get a fuzzy first idea of Haskell's capability, and some of its strangeness.
12:52:24 <wli> matthew-: Like what?
12:52:24 <lambdabot> Title: Nub Games : Haskell IO for Imperative Programmers
12:52:41 <matthew-_> wli: er, eg, Session Types
12:53:25 <nominolo> i've seen the presentation slides from some guy from unsw, a while ago
12:53:33 <nominolo> i think it was on ltu
12:56:28 <spx2> what are monads
12:56:34 <spx2> I saw some thins on acm about it
12:56:44 <spx2> is the whole field of programming languages changing
12:56:54 <spx2> I'm pretty much also afraid I'll loose my job tommorow
12:57:03 <norpan> spx2: let's hope the field is always changing to the better
12:57:17 <norpan> loose or lose?
12:57:17 <dylan> Monads are things that can have two/three operations done on them.
12:57:19 <spx2> norpan: yes but I want to keep my job too
12:57:30 <liyang> ( Indeed. Invest in Haskell: http://www.thotmarket.com/thot.php?id=MTIxOTIxNjcuODQ= )
12:57:31 <lambdabot> Title: Thot Details
12:57:32 <nominolo> spx2, nono.  haskell will only be mainstream in 10+ years
12:57:34 <spx2> norpan: as a verb
12:57:35 <smashor> I wonder if there is a findAll :: String -> [String] -> [String] function which returns all Strings as a list out of a list of Strings containing the first String?
12:57:35 <norpan> you will get a better job
12:58:09 <norpan> there are always jobs for the computer scientist
12:58:15 <smashor> I've just wrote my own one but I'm pretty sure there are better solutions for this
12:58:18 <wli> I won't. When I get canned I'll be hairdressing or interior decorating or something.
12:58:21 <ari> :t \s c -> filter (s `isInfixOf`) c
12:58:23 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> [[a]]
12:58:24 <omniscientIdiot> smasher: (\x xs -> filter (x `isInfixOf`) xs)?
12:58:35 <spx2> norpan: yes but I'm a programmer not a computer scientist
12:58:55 <norpan> spx2: so invest in learning new languages and methods
12:58:59 <dylan> wli: I know the feeling...
12:59:01 <nominolo> spx2, it's a programmable semicolon -- by implementing two operations you can define semantics for embedded languages
12:59:07 <Japsu> spx2: Back to your question about monads... You should first learn the basics and then read http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
12:59:09 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
12:59:37 <nominolo> spx2, i also recommend that article above
12:59:38 <spx2> If I don't know Formal Languages and Finite Automata how am I going to cope with haskell ?
13:00:01 <norpan> by learning
13:00:01 <dino-> spx2: I really hope the field changes in this direction. And I say that as a current professional Perl programmer. Functional programming is extremely exciting.
13:00:20 <liyang> spx2: ITYM ``If I don't know category theory, how am I going to cope with Haskell?''
13:00:20 <norpan> you are never to old to learn new things
13:00:21 <omniscientIdiot> Bare description the terms of which you'll need to know: A monad is a type supporting the bind and return functions (a type in the Monad class) such that the monad laws hold.
13:00:30 <dylan> spx2: I have no idea what those words you just said are, but I manage to be learning haskell alright. :)
13:00:33 <nominolo> spx2, look it up on wikipedia, look at examples, and realize it's actually just simple stuff with scary names ;)
13:00:54 <dino-> spx2: Start with the big tutorial: http://en.wikibooks.org/wiki/Haskell/YAHT
13:00:55 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
13:01:05 <omniscientIdiot> bind is a sort of multiply, return a sort of unit.  The monad laws say the return is bind's unit, and that bind is associative.
13:01:06 <dino-> spx2: this is also downloadable as a PDF for printing or whatever you need
13:01:20 * liyang prefers scary names over soft-fuzzy-ambiguous-concepts.
13:01:42 <wli> Names aren't scary. Name and conquer.
13:01:50 <dino-> spx2: And don't worry about Monads yet.
13:02:21 * dylan has been trying to name a module in a C program he's working on for 3 days now
13:02:23 <omniscientIdiot> spx2: if you want to get up and running start at http://haskell.org/haskellwiki/Haskell_in_5_steps
13:02:23 <smashor> ari: omniscientIdiot: what is isInfixOf ? didnt found that in the Prelude ?
13:02:24 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
13:02:39 <Japsu> @indix isInfixOf
13:02:40 <lambdabot> bzzt
13:03:19 <omniscientIdiot> isInfixOf x xs = any (x `isPrefixOf`) (tails xs)
13:03:27 <omniscientIdiot> @index isPrefixOf
13:03:28 <lambdabot> Data.List
13:06:05 <smashor> omniscientIdiot: Japsu: thats just I was looking for... my own code was about 10 lines for that... thanks!
13:07:03 <omniscientIdiot> @quote fluxbox
13:07:03 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
13:07:04 <lambdabot> for your entire program.")
13:07:13 <pejo> spx2, quite a few places teach Haskell as first language/first course, so people have roughly high school mathematics background, and they seem to cope.
13:07:43 <pejo> Heh, like he was sensing I was going to comment!
13:11:03 <mux> @users
13:11:03 <lambdabot> Maximum users seen in #haskell: 407, currently: 388 (95.3%), active: 16 (4.1%)
13:13:10 <smashor> I have problems understanding that line: (\x xs -> filter (x `isInfixOf`) xs) ; I mean filter needs a function a -> Bool and a list (xs), and isInfixOf needs also two lists, giving a boolean then. but where are the two arguments for isInfixOf? I only see x...
13:13:29 <smashor> could you please describe that line a little bit to me ?
13:14:03 <omniscientIdiot> (x `isInfixOf`) = (\y -> x `isInfixOf` y), it's a section.
13:14:25 <dino-> isInfixOf is a function that takes two arguments. The x is one of them, so it becomes a function from a -> Bool
13:14:56 * mux was trying to explain that without involving the words eta-reduction or currying
13:15:03 <omniscientIdiot> :)
13:15:12 <dino-> Or maybe partial evaluation is a good term.
13:15:42 <dino-> I'll note that people here have told me that partial evaluation != currying
13:15:48 <dino-> But I remain confused about the distinctions. :/
13:15:55 <scandal> @type ([] `isInfixOf`)
13:15:55 <omniscientIdiot> they're compliments.
13:15:56 <mux> I always find it very difficult to explain the few I know about haskell to friends; with all this CS/PLT vocabulary, it's hard
13:15:56 <lambdabot> forall a. (Eq a) => [a] -> Bool
13:15:59 * therp misses common lisp :: for referencing symbols inside packages.
13:16:04 <Philippa> dino-: it's the difference between application and evaluation
13:16:13 <omniscientIdiot> isInfixOf is curried, so that it may be partially applied.
13:16:24 <Philippa> partial application tries to evaluate 'under' the remaining lambdas in a function
13:16:31 <Philippa> oops, partial evaluation even
13:16:38 <Philippa> (well-timed thinko, that...)
13:16:45 <mux> btw, I thought that section only applies to operators; left section vs right section
13:16:52 <dino-> Philippa: It seemed like there was one point in the big SPJ Haskell video where he refers to them as the same thing. But I would have to watch it again and take notes to be absolutely certain.
13:17:27 <dino-> But yeah, I was imagining that it's a subtlety that I'm not getting yet.
13:17:35 <omniscientIdiot> it's just a small distinction, like the one between argument and parameter.  Not all that important to note.
13:17:54 <olsner> oh, so partial *application* === currying?
13:18:12 <Igloo> No, currying makes partial application simpler
13:18:52 <omniscientIdiot> currying is making functions that return functions.  Partial application is giving a curried function an argument.
13:19:55 <smashor> dino-: omniscientIdiot: thanks for explaining, so isInfixOf which is of type [a] -> [a] -> Bool becomes to [a] -> Bool when x is applied to isInfixOf.
13:20:06 <dino-> smashor: yes
13:20:07 <omniscientIdiot> precisely!
13:20:12 <Philippa> no. Giving the curried function an argument is a way of implementing partial application
13:20:18 <Philippa> that doesn't mean partial application /is/ curry
13:20:20 <Philippa> *currying
13:20:22 <dino-> And then the other argument, xs, is used for the filter
13:21:24 <smashor> dino-: ok, that makes sense with output of :t filter
13:21:28 <smashor> thanks again
13:21:52 <mux> smashor: it's the same thing that allows you to write "somefunction = someotherfunction" without needing to bother about parameters
13:22:05 <mux> taken to the extreme
13:24:52 <omniscientIdiot> with (.) to hook together functions, and flip, ap, and join to juggle arguments, you can dispense with formal parameters entirely, as @pl testifies.
13:25:31 <norpan> @src flop
13:25:32 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:25:39 <olsner> (... combinatory logic)
13:26:20 <omniscientIdiot> s = flip ap, k = const, i = id
13:27:19 <sorear> c = flip, b = id, w = join
13:27:50 <sorear> and s = ap, not flip ap
13:28:30 <omniscientIdiot> I thought (->) r's ap and ski's S had different argument orders.
13:28:53 <olsner> @pl (\x y z -> (x z (y z)))
13:28:53 <lambdabot> ap
13:29:03 <olsner> there ya go
13:29:18 <norpan> i know flip, but i wanted flop
13:29:49 <sorear> flop (,,) 1 2 3 = what?
13:30:59 <olsner> like (flip . flop) f = f, or (flop . flip) f = f?
13:31:15 <norpan> flip = flop and it works
13:31:31 <omniscientIdiot> @type (flip . flip)
13:31:33 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
13:31:51 <sorear> @pl flip . flip
13:31:51 <lambdabot> id
13:32:19 <norpan> @pl let flop = flip in flip . flop . flip . flop
13:32:20 <lambdabot> id
13:32:22 <norpan> wow
13:32:45 <omniscientIdiot> yes, id . id = id :)
13:32:59 <sorear> @pl \fix -> let a = 2 in a
13:32:59 <lambdabot> ($ const 2)
13:33:03 <sorear> @pl \fax -> let a = 2 in a
13:33:04 <lambdabot> const 2
13:33:26 <omniscientIdiot> ?
13:33:56 <sorear> those two expressions are α-equivalent
13:34:12 <omniscientIdiot> (that an alpha?  stupid client)
13:34:20 <sorear> yes, an alpha
13:34:39 <olsner> but why does @pl derive them differently? just because of the naming of fix/fax?
13:34:43 <omniscientIdiot> bizarre
13:35:08 <sorear> olsner: name capture
13:35:27 <dmhouse> sorear: it shouldn't make a difference, though. Bug in ?pl.
13:35:33 <sorear> olsner: @pl desugars let a = 2 in a  to fix (\a -> 2)
13:35:49 <omniscientIdiot> O.o
13:35:59 <olsner> oh... so it becomes \f -> f (\a -> 2)?
13:36:15 <sorear> yep
13:37:14 <olsner> crazy!
13:37:35 <phobes> So desugaring isn't "hygenic" :)
13:37:48 <omniscientIdiot> In @pl's implementation.
13:37:56 <phobes> oh ok
13:38:09 <dmhouse> Really ?pl should rename variable or use something like de Brujin indices.
13:40:23 <olsner> pl will also happily optimize expressions that won't typecheck, such as when someone fed it (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
13:41:10 <dmhouse> olsner: why doesn't that typecheck?
13:41:16 <omniscientIdiot> does that still cause lb to flood? :)
13:41:45 <olsner> @quote f\ i\ x\ e
13:41:45 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
13:42:30 <omniscientIdiot> dmhouse: passing a function into itself, thus that arg's type would be the function's whole type, causing an infinite type.
13:42:37 <omniscientIdiot> r ( ... r)
13:43:06 <dmhouse> ?type \f -> f (const 4 f)
13:43:14 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
13:43:29 <omniscientIdiot> hmm..
13:44:12 <omniscientIdiot> oh, silly me, r is an arg to t, I was wrong
13:45:07 <dmhouse> I think what was meant is:
13:45:09 <dmhouse> L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
13:45:17 <dmhouse> Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L)
13:45:30 <dmhouse> Then Yk has an infinite type.
13:45:39 <olsner> yeah, I just didn't want to type all of that
13:46:15 <omniscientIdiot> rename L to LO and you have LOLOLOLOLOLOL :)
13:46:29 <olsner> Yk was what someone fed @pl, which happily produced a slew of dots and ap/flip/consts
13:47:10 * omniscientIdiot tries in privmsg
13:49:06 <dmhouse> ?type let l = \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)); yk = l l l l l l l l l l l l l l l l l l l l l l l l l l in yk -- There, an infinite type.
13:49:07 <lambdabot>     Occurs check: cannot construct the infinite type:
13:49:08 <lambdabot>       t
13:49:19 <dmhouse> (Although 't' doesn't look very infinite to me.)
13:50:39 <omniscientIdiot> @ty \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
13:50:41 <lambdabot>     Occurs check: cannot construct the infinite type:
13:50:41 <lambdabot>       t
13:51:20 <FMotAFK> :o ?
13:51:26 <olsner> @ty \f r -> r (f r)
13:51:28 <lambdabot> forall t t1. ((t -> t1) -> t) -> (t -> t1) -> t1
13:52:03 <dmhouse> @ty \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t r))
13:52:03 <FMotAFK> @ty \f -> f (f f)
13:52:04 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25. -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10 -> t11 -> t12 -> t13 -> t14 -> t15 ->
13:52:05 <lambdabot>  t16 -> t17 -> ((t24 -> t25) -> t24) -> t18 -> t19 -> t20 -> t21 -> t22 -> t23 -> (t24 -> t25) -> t25
13:52:06 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:52:06 <lambdabot>     Probable cause: `f' is applied to too many arguments
13:52:22 <omniscientIdiot> t ... p o i n >t< ...
13:52:44 <dmhouse> > const 4 const
13:52:45 <lambdabot>  4
13:52:56 <dmhouse> ?type const const 4
13:52:57 <lambdabot> forall a b. a -> b -> a
13:53:00 <omniscientIdiot> >:/
13:53:07 <dmhouse> ?type \r -> r (const const 4 r)
13:53:09 <lambdabot>     Occurs check: cannot construct the infinite type: a = (b -> a) -> t
13:53:09 <lambdabot>     Probable cause: `r' is applied to too many arguments
13:53:24 <dmhouse> ?type \r -> r (const const 4 r 5)
13:53:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> t
13:53:26 <lambdabot>     Probable cause: `r' is applied to too many arguments
13:54:07 <dmhouse> Oops, wrong way around.
13:54:22 <dmhouse> ?type \r -> r (const const 4 5 r)
13:54:24 <lambdabot> forall a t. (Num a) => (a -> t) -> t
13:54:25 <xerox> > \x -> x x
13:54:26 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
13:54:27 <lambdabot>     Probab...
13:54:33 <sorear> olsner: lambdabot doesn't believe in quoting, you'll have to do better than that
13:54:38 <sorear> @quote f.i.x.e
13:54:38 <lambdabot> No quotes match. Are you on drugs?
13:55:13 <dmhouse> ?type (\t r -> r (t t 4 5 r)) const
13:55:15 <lambdabot>     Occurs check: cannot construct the infinite type:
13:55:15 <lambdabot>       t = t -> t3 -> t4 -> t1 -> t2
13:55:24 <dmhouse> How peculiar.
13:55:40 <FMotAFK> :t Y where Y f = f (Y f)
13:55:42 <lambdabot> parse error on input `where'
13:55:45 * omniscientIdiot is not smart enough to unravel the details, though he likes to pretend :)
13:55:55 <olsner> @quote \{
13:55:55 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
13:55:58 <FMotAFK> :t let Y f = f (Y f) in Y
13:56:00 <lambdabot> Not in scope: data constructor `Y'
13:56:00 <lambdabot>  
13:56:00 <lambdabot> <interactive>:1:13: Not in scope: data constructor `Y'
13:56:00 <olsner> the works ;-)
13:56:03 <olsner> *that
13:56:08 <dmhouse> :t let y f = f (y f) in y
13:56:08 <xerox> > \x y -> (y x) (x y)
13:56:09 <lambdabot>      Occurs check: cannot construct the infinite type:
13:56:09 <lambdabot>       t = (t -> t1 -> ...
13:56:10 <lambdabot> forall t. (t -> t) -> t
13:56:14 <xerox> aw :)
13:56:15 <sorear> FMotAFK: AFK? really? :)
13:56:20 <dmhouse> FMotAFK: uppercase 'functions' are data constructors.
13:56:27 <FMota> oh, right
13:56:28 <FMota> :o
13:56:34 <xerox> > \x y -> x y x
13:56:34 <lambdabot>      Occurs check: cannot construct the infinite type: t = t2 -> t -> t1
13:56:35 <lambdabot>     ...
13:56:41 <dmhouse> omniscientIdiot: basically, I don't understand why if the following types:
13:56:44 <dmhouse> ?type \r -> r (const const 4 5 r)
13:56:49 <lambdabot> forall a t. (Num a) => (a -> t) -> t
13:56:52 <dmhouse> Why, then, doesn't the following?
13:56:56 <dmhouse> ?type (\t r -> r (t t 4 5 r)) const
13:56:57 <lambdabot>     Occurs check: cannot construct the infinite type:
13:56:58 <lambdabot>       t = t -> t3 -> t4 -> t1 -> t2
13:57:03 <FMota> there should be an Inf type
13:57:09 <dmhouse> The latter is a simple beta-expansion of the former.
13:57:19 <FMota> Inf x = Inf x -> x
13:57:22 <FMota> :o
13:57:28 <FMota> ... not saying it's a good idea
13:57:49 <sorear> FMota: Switch to ML
13:57:52 <dmhouse> FMota: dead easy to define. type Inf x = Inf x -> x.
13:57:53 <omniscientIdiot> dmhouse: very strange
13:58:31 <dmhouse> FMota: it has inhabitants too, but only boring ones like const 5 :: Inf Int.
13:59:04 <FMota> :o
13:59:18 <sorear> it's still a type error though
13:59:26 <sorear> # (fun t r -> r (t t 4 5 r)) (fun a b -> a);;
13:59:26 <sorear> This expression has type 'a -> int -> int -> ('b -> 'c) -> 'b as 'a
13:59:26 <sorear> but is here used with type int -> ('b -> 'c) -> 'b
14:02:09 <FMota> so
14:02:29 <FMota> what're you guys' opinions on total-ness?
14:03:48 <Baughn> Handy when you can get it, but not worth getting hung up over
14:05:24 <fax> what is it?
14:05:30 <FMota> totality
14:05:44 <FMota> functions are total -- i.e. no function diverges
14:05:45 <omniscientIdiot> I wonder if it'd be a good idea tag call attention to partial functions in the libs, like Ruby uses (!) for mutation.
14:05:53 <omniscientIdiot> s/tag//
14:06:12 <fax> oh I see
14:06:12 <byorgey> fax: a total function is one which is defined for all its inputs.
14:06:13 <FMota> that might a good idea
14:06:15 <FMota> *be
14:06:21 <omniscientIdiot> > head []
14:06:29 <lambdabot>  Exception: Prelude.head: empty list
14:06:30 <byorgey> fax: for example, head is not total.
14:06:50 <FMota> pred 0
14:06:52 <FMota> > pred 0
14:06:53 <lambdabot>  -1
14:07:00 <b_jonas> omniscientIdiot: ruby's stolent that from scheme
14:07:02 <FMota> > pred (0 :: Nat)
14:07:03 <lambdabot>   Not in scope: type constructor or class `Nat'
14:07:09 <FMota> oh, bummer
14:07:10 <roconnor> @go 1 CAD in USD
14:07:11 <lambdabot> 1 Canadian dollar = 0.972006 U.S. dollars
14:07:12 <b_jonas> and it's not used as consistently in ruby as in scheme
14:07:14 <FMota>  you get the point, though
14:07:18 <sorear> I think it's better to tag partiallity in the TYPE SYSTEM
14:07:27 <sorear> head :: [a] -> Maybe a
14:07:34 <fax> ah
14:07:36 <FMota> mmhmm
14:07:49 <FMota> I have to agree with sorear here.
14:07:57 <b_jonas> but you cannot have all total functions
14:07:59 <sorear> fix :: ((a -> GR b) -> (a -> GR b)) -> a -> GR b
14:08:06 * omniscientIdiot sprinkles fromJusts through his code to spite sorear
14:08:14 <b_jonas> because a function that can go to a real infinite loop isn't total
14:08:16 <FMota> it's better than nothing
14:08:31 <sorear> b_jonas: no, but we CAN have all functions that can be proven total in mathematical logic
14:08:45 <FMota> b_jonas: certain types of recursion guarantee that the function has a result
14:08:52 <b_jonas> yeah, that's true
14:08:56 <sorear> b_jonas: if you say your function is total, but it can't be proven in mathematical logic, who's going to beleive you?
14:09:00 <b_jonas> but I do not want to be restricted as much
14:09:05 <Baughn> It /can/ be handy to have functions that fail hard instead of using fromJust, but if I don't have the option of avoiding them I'll be very annoyed
14:09:06 <b_jonas> I want a turing-complete language at least
14:09:29 * sorear doesn't think TC is worth it
14:09:33 <FMota> you want a turing complete language
14:09:33 <b_jonas> and it's also convenient to have partial functions
14:09:39 <FMota> ...to run on your non-turing complete computer>
14:09:41 <FMota> *?
14:09:48 <b_jonas> FMota: yes
14:09:50 <sorear> it's also convienient to have run time type errores
14:09:51 <FMota> ;)
14:10:00 <b_jonas> at least a good approximation of it can run on my computer
14:10:13 <b_jonas> and I can reason about programs in that language with mathematics
14:10:55 <sorear> I don't have to use mathematics to reason about my non-TC language, because mathematics *is* my non-TC language
14:11:07 <FMota> XD
14:11:33 <sieni> sorear: interesting point
14:11:34 <Baughn> How on earth is math not TC?
14:12:12 <b_jonas> I mean, look
14:12:25 <b_jonas> haskell is purely functional, purely lazy, and strongly typed
14:12:27 <b_jonas> that much is ok
14:12:44 <b_jonas> but if you also make it provably total, then you get an unusable language
14:12:50 <sorear> "non-TC" languages can still express Turing power, if you use something external, like the GR monad
14:12:53 <b_jonas> you cannot have so many restrictions
14:13:18 <sorear> don't give up so easily! :D
14:13:35 <b_jonas> plus, do those restrictions in iteration work even in a haskell-like language?
14:13:54 <b_jonas> I guess they do
14:14:17 <omniscientIdiot> would totality mean getting rid of _|_?  I've only enough knowledge here to wave my arms wildly.
14:14:35 <b_jonas> the delta-nought thing, for example, does work
14:14:36 <FMota> they pretty much do ... or should
14:14:39 <sieni> Baughn: well I guess if you have a fixed set of axioms that contain enough arithmetics, then you have lots of recursive functions that you can't prove to be computable even if they are, so you are stuck with provably computable functions (which, of course, you don't know what they are, since the set is only recursively enumerable)
14:15:43 <b_jonas> also, FMota, even your non-TC total language will be non-total on a real computer
14:15:47 <b_jonas> because you'll be able to run out of memory
14:15:58 <FMota> right
14:16:04 <FMota> but then you're in real trouble anyway
14:16:09 <b_jonas> sorear: that's a valid point though, yes
14:17:01 <FMota> in reality, you'd run out of memory before being able to make my total non-TC language run out of memory by itself,
14:17:06 <FMota> (probably)
14:17:48 <sorear> There are no total TC languages.
14:17:51 <b_jonas> no. I think if you wanted to run out of memory, it would be easy to write a program for that even with your total language
14:18:19 <sorear> it's pretty easy to write a decision procedure for Presburger arithmetic in a total language
14:18:40 <sorear> it's been proven that any such algorithm must run in triple-exp time, and thus double-exp space
14:18:52 <FMota> the real question is whether or not TC is relevant
14:18:59 <sorear> so no matter how good the optimizer, your total language must be at least that complex
14:19:09 <FMota> can we get by with a strict subset of TC?
14:19:14 <sorear> I think so
14:19:16 * roconnor didn't realize sorear was so knowledgeable on this topic.
14:20:03 <b_jonas> what's presburger arith?
14:20:06 <FMota> :o
14:20:13 <b_jonas> is that the one with addition only, and no multiplication?
14:20:56 <sorear> yeah
14:21:11 <SamB_XP> @pl let a = foo b; b = bar a in (a,b)
14:21:12 <lambdabot> fix (uncurry (flip ((,) . foo) . bar))
14:23:52 <roconnor> FMota: in response to your original question, I program in a total functional language (Coq) for my job as a researcher.
14:24:05 <BoudewijnE> hi guys, I've been playing around a bit using ghci. But what changes do I need to make when using ghc and runnign the binary? (error is     No instance for (Num (IO a)) )
14:24:10 <Olathe> What does xxs@(x:xs) mean ?
14:24:15 <FMota> Coq is very verbose isn't it?
14:24:31 <roconnor> I find it hard to imagine working in a total functional language if I didn't have a dependent type system.
14:24:46 <omniscientIdiot> Olathe: the whole list is bound to xxs, the head to x, the tail to xs
14:24:54 <FMota> well, yeah
14:24:58 <Olathe> Alright, thanks.
14:25:05 <omniscientIdiot> name@(pattern) binds name to the whole pattern
14:25:18 <roconnor> FMota: I don't have any figures, but I estimate I put in 10x the amount of work into than I do into my haskell version.
14:25:33 <roconnor> (very much an estimate)
14:25:48 <FMota> but is that the fault of totality, or of Coq?
14:26:07 <omniscientIdiot> @paste your code on the hpaste site, BoudewijnE
14:26:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:26:23 <roconnor> ... probably a fault of totality.  Proving termination is sometimes a big pain.
14:26:25 <BoudewijnE> ok willdo
14:26:35 <FMota> let's say you want to create (a - b)
14:26:44 <FMota> you have to prove that it works? ugh
14:26:52 <FMota> I'd say that's a problem with Coq.
14:26:52 <hpaste>  BoudewijnE pasted "(no title)" at http://hpaste.org/2799
14:27:14 <fax> FMota: http://coq.inria.fr/V8.1/stdlib/Coq.Arith.Minus.html
14:27:15 <lambdabot> Title: Coq.Arith.Minus
14:27:17 <BoudewijnE> it's a course assignment
14:27:25 <fax> FMota: looks like subtraction is in the standard library
14:27:30 <BoudewijnE> and for now , I was able to run everything in ghci
14:27:32 <roconnor> Well, in haskell I don't need to prove termination, so clearly more work needs to be done in the Coq version.
14:27:44 <BoudewijnE> but this one has to be compiled first
14:28:03 <roconnor> Perhaps smarter people can come up with better datatypes and algorithms to make the job easier.
14:28:08 <omniscientIdiot> BoudewijnE:  which line gives the error?
14:28:17 <BoudewijnE> well wait a minute
14:28:23 <BoudewijnE> I was confusing 2 things :p
14:28:30 <FMota> mk
14:28:36 <BoudewijnE> boudewijn@zeus ~/uu/fpgo/mastermind $ ghc --make MasterMind.hs -o main
14:28:40 <BoudewijnE> I ran this
14:28:43 <BoudewijnE> and executed main
14:29:02 <BoudewijnE> i was assuming something would pop up because of the main loop being executed
14:29:16 <FMota> right, but one could have total fp without having to prove the totality
14:29:32 <roconnor> FMota: not really.
14:29:34 <pejo> roconnor, if you prove that your program terminates you know fairly much more than you do about the Haskell equivalent though.
14:29:36 <omniscientIdiot> if it says no instance for Num (IO a), I'd assume you're trying to add something to an IO action, or something like that.
14:29:58 <FMota> roconnor: with more restrictions, of course
14:30:11 <roconnor> pejo: agreed
14:30:11 <BoudewijnE> omniscientIdiot>  I know, i was confusing 2 problems
14:30:27 <BoudewijnE> sorry
14:30:54 <UnaRacer> Does anybody know if there's a way with Data.Set to get the element in the set that's equal to a given object?  (My definition for Eq only compares part of my data structure.)
14:31:13 <roconnor> FMota: Writing in a total function language basically means using only structural recursion, and that is the equivalent (or identical) work of proving a function is total.
14:31:31 <FMota> yes
14:31:35 <Cale> http://programming.reddit.com/info/2qwe7/comments needs more up-mods :)
14:31:36 <lambdabot> Title: After the monad videos on YouTube, here are the adjunction ones ! (reddit.com)
14:31:56 <FMota> is that really a huge hassel?
14:31:57 <BoudewijnE> another problem I have is running haskell programs from Eclipse
14:32:00 <FMota> er, *hassle
14:32:06 <pjd> Cale: four downvotes?
14:32:07 <pjd> for shame
14:32:09 <BoudewijnE> installed the eclispefp plugin
14:32:12 <sorear> FMota: consider the unification algorithm
14:32:15 <omniscientIdiot> BoudewijnE: instead of tODO, you could use undefined for your unfinished parts.
14:32:16 <BoudewijnE> ran the config
14:32:21 <FMota>   /lol,  hassel v. haskell
14:32:25 <BoudewijnE> well, it's not my code ;)
14:32:48 <BoudewijnE> but running it from eclipse might be nice too
14:32:53 <BoudewijnE> so I ran the config wizzard of it
14:33:05 <BoudewijnE> and when building it, it does nothing at all
14:33:07 <Cale> pjd: yeah, Eugenia Cheng is an excellent lecturer. There's too many anti-math people creeping into programming reddit now.
14:33:25 <BoudewijnE> or at least : it doesn't seem to build
14:33:43 <BoudewijnE> and when trying to run, eclipse says "could not locate the project's executable"
14:33:44 <roconnor> FMota: sometimes it seems to be difficult.
14:33:48 <FMota> sorear: the unification algorithm?
14:34:04 <FMota> roconnor: example? :)
14:34:11 <byorgey> UnaRacer: maybe you could do something like head . elems . filter (==x)?
14:34:46 <fax> herbrand unification always terminated
14:35:36 <roconnor> FMota: lately I've been trying to prove that you can sum a series bounded by a geometric series upto any given error.
14:35:59 <roconnor> FMota: in haskell you can just estimate the error based on the current term.
14:36:14 <FMota> uhm
14:36:22 <roconnor> FMota: in coq I have to prove that I will always reach a point when the error is smaller than epsilon.
14:36:25 <FMota> a geometric series has a simple thing though
14:36:40 <FMota> * a simple equation
14:36:51 <roconnor> FMota: I'm summing a series bounded by a geometric series, not necessiarly one itself.
14:37:19 <FMota> oh, right
14:37:20 <FMota> well
14:37:31 <FMota> that isn't a problem with total fp
14:37:35 <FMota> it's a problem with coq
14:37:54 <roconnor> I don't see how my difficulties are coq specific.
14:38:12 <Philippa> I don't think there's a lot that can't be done in coq but could be done in another total language
14:38:46 <byorgey> BoudewijnE: my guess is that many people in here have experience using EclipseFP.
14:38:54 <byorgey> erm, *not* many people
14:38:55 <FMota> Philippa: right, but Coq probably gets in the way.
14:39:08 <roconnor> FMota: actually in some sense you are right; it is easy to compute an upper bound on the number of terms that need to be summed.
14:39:09 <fax> FMota: So just use a paper and pencil if you find it easier
14:39:10 <BoudewijnE> lol, most of you are ghc fans?
14:39:25 <FMota> :p
14:39:43 <roconnor> FMota: the hard part is proving that the result has an error of epsilon
14:40:07 <byorgey> BoudewijnE: well, EclipseFP is not a compiler, it still has to use a compiler (which could be ghc) as a backend
14:40:12 <roconnor> FMota: which is needed so that function can be used elsewhere safely.
14:40:28 <FMota> but does Coq make you prove that?
14:40:41 <glen_quagmire> Coq is pi calculus?
14:40:53 <roconnor> Coq is lambda calculus :)
14:41:22 <roconnor> FMota: I need to prove that so I can use this function as parameters to other functions.
14:41:51 <FMota> I see
14:41:59 <FMota> idk
14:43:04 <roconnor> FMota: but let me think about why other functions need this proof.
14:43:38 <FMota> I feel like totality is desirable, but you should be allowed to create partial functions as well -- as long as it's obvious that they're partial.
14:44:09 <roconnor> FMota: as sorear mentioned partial functions are easily represented in the paritality monad.
14:44:18 <FMota> yep
14:44:22 <mux> can someone help me in solving a memory leak? http://hpaste.org/2800 -- code and profiling output there
14:44:32 <mux> this is a very stupid program :-)
14:44:46 <roconnor> FMota: you might have a point here, I may be mixing up proofs of termination and proofs of correctness in my work.
14:45:08 <FMota> that's what I was thinking
14:45:12 <FMota> but nvm
14:45:15 <roconnor> FMota: maybe if you throw away all my correctness proofs that would strip away much of my work.
14:45:25 <roconnor> and none of it is needed for termination.
14:45:33 <roconnor> (almost none)
14:45:35 <FMota> okay
14:45:46 <UnaRacer> byorgey: (Re: Data.Set) Yeah, I was looking at that.. I was hoping to be able to do it as fast as a "member" - Thanks. :)
14:45:48 <roconnor> I don't know.  I'll have to think about it.
14:45:53 <FMota> :) me too
14:45:59 <roconnor> FMota: thanks for questioning me :)
14:46:07 <FMota> :o
14:46:12 <FMota> you're ... welcome :o
14:46:44 <omniscientIdiot> BoudewijnE: the only advice I could give you is to try the contact page on the eclipseFP home page.
14:47:46 <BoudewijnE> okay thanks
14:48:20 <FMota> okay, now an opinion question about the other side of the spectrum. Dynamic fp, any good?
14:48:36 <fax> ..what lol
14:48:51 <fax> all these things are useful sometimes
14:49:00 <FMota> :) ofc
14:49:16 <FMota> but the point in asking is not whether they are good sometimes
14:49:19 <byorgey> @tell UnaRacer actually, due to laziness, I think head . elems . filter (==x) should be just as fast as member.
14:49:19 <lambdabot> Consider it noted.
14:49:24 <FMota> it's whether they are generally better
14:49:50 <dmwit> :t elems
14:49:52 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
14:50:05 <byorgey> @type Data.Set.elems
14:50:07 <lambdabot> forall a. Data.Set.Set a -> [a]
14:50:27 <quicksilver> FMota: "generally" it's better to have types
14:50:44 <quicksilver> FMota: because "generally" your data has some regularity, and the more you of that you can encode the better
14:51:00 <quicksilver> FMota: of course some programming techniques are less amenable to that than others
14:51:29 <FMota> even though it means making a lot more modification for something minor like handling an error differently?
14:51:45 <quicksilver> it doesn't, in my experience
14:52:03 <FMota> and I don't know why you're quoting generally, it makes you sound pompous
14:52:22 <FMota> or, hmm... that might not be the word I'm looking for. Nevertheless.
14:52:32 <FMota> okay
14:52:34 <quicksilver> :)
14:52:37 <FMota> :)
14:52:42 <quicksilver> I do, generally, sound pompous
14:52:50 <FMota> XD
14:53:03 <quicksilver> I was quoting it for emphasis, maybe it would have been better to use /generally/ for that purpose
14:53:17 <Baughn> FMota: In my experience, the more regularities you encode, the /less/ you have to change during maintenance
14:54:16 <Philippa> dynamic FP is useful when there isn't a good enough type system available
14:54:17 <omniscientIdiot> furthermore, changes you would have to make anyway are flagged by the compiler.
14:54:21 <psnively> I'm trying to understand what the benefit of dynamic typing is.
14:54:29 <Philippa> these days though you usually only want dynamism at certain boundaries
14:54:35 <FMota> :)
14:54:41 <psnively> I/O boundaries.
14:54:50 <Baughn> psnively: Not having to write data statements, mostly
14:54:54 <psnively> You have to parse some unstructured stuff into a structure...
14:54:55 <Philippa> not just I/O
14:55:07 <psnively> Baughn: heh.
14:55:10 <quicksilver> psnively: some people argue that an advantage is evolutionary deployment
14:55:13 <Philippa> you have to reconfigure a bunch of stuff internally and the type system's not up to proving it'll all go off without a hitch
14:55:22 <Philippa> right, that
14:55:22 <quicksilver> psnively: a.k.a. keeping old clients running against new servers
14:55:33 <quicksilver> psnively: I don't find that argument especially convincing :)
14:55:40 <quicksilver> psnively: but the erlang crowd are keen on it
14:55:40 <psnively> quicksilver: sounds like that's addressed with proper interfaces to me...
14:55:51 <Excedrin> is there something like nondet that is also random? (inserting 99 into [1,2,3] returns [99,1,2,3], [1,99,2,3] etc, but always in the same order)
14:55:52 <Philippa> proper interfaces isn't good enough
14:55:53 <Baughn> psnively: Naturally, once you /do/ use data statements, you sometimes lose a lot of the benefit of static typing
14:56:01 <Philippa> you also need enough polymorphism to handle interfaces changing over time
14:56:16 <psnively> quicksilver: The Erlang folks probably do have a better dynamic story than anyone else (except maybe the Oz people).
14:56:29 <psnively> Philippa: short of strongly-specified functions, yes. :-)
14:56:46 <roconnor> quicksilver:  I'd say it is an advantage for evolutionary development :)
14:56:52 <psnively> Philippa: of course.
14:57:07 <dons> Igloo: thanks for applying the unix lib patch. you'll also do the Linker.c one?
14:57:11 <roconnor> When your algorithms are generated by breeding programs
14:57:19 <roconnor> and thus you have not proof of correctness
14:57:25 <fax> strongly-specified functions are functions which return 'the answer' as well as a proof it's right?
14:57:27 <roconnor> s/not/no
14:58:02 <Igloo> dons: Which patch didn't I apply to the HEAD?
14:58:29 <dons> checking...
14:58:50 <Philippa> psnively: "enough" turns out to be more than I've seen in any sufficiently-usable statically-typed language
14:58:53 <omniscientIdiot> http://cdsmith.twu.net/types.html
14:58:54 <lambdabot> Title: What To Know Before Debating Type Systems
14:59:00 <psnively> fax: Strongly-specified functions' return type completely specifies what the function does.
14:59:09 <dons> ah, no, you've applied them, thanks Igloo
14:59:17 <Igloo> OK, cool
14:59:30 <psnively> Philippa: That's probably a fair assessment. :-)
14:59:35 <fax> psnively: where can I find out more?
15:00:12 <psnively> fax: http://www.alpheccar.org/en/posts/show/72
15:00:13 <lambdabot> Title: Strongly specified function in Coq
15:00:20 <fax> thank you
15:00:30 <glen_quagmire> you're welcome
15:00:32 <psnively> You betcha.
15:00:51 <quicksilver> Philippa: if you're aware of the requirement, you can easily use a rather 'lisp-like' nested tree structure for plasticity in certain interfaces
15:01:08 <quicksilver> Philippa: and still retain tighter structure in those places where you don't believe you need it
15:02:45 <Philippa> quicksilver: not anywhere near good enough
15:03:15 <Philippa> at a minimum I'm after first-class modules
15:03:21 <hpaste>  calvins pasted "regex type problems" at http://hpaste.org/2801
15:03:57 <quicksilver> Philippa: surely a generic nested tree gives you everything that the erlang camp has?
15:04:21 <calvins> I'm feeling really stupid trying to use makeRegex from Text.Regex.Base. I've been trying to just compile a simple regex for about half an hour now, and have been unable to get anything that will type-check.
15:04:55 <calvins> If anybody could look at the paste and perhaps expand that a little, I would be very appreciative.
15:05:01 <psnively> Philippa: Acute?
15:05:02 <Philippa> quicksilver: only once I've implemented an interpreter on the top of that. Sorry, got better things to do than reinvent lisp
15:05:12 <Philippa> psnively: that's something I should look at
15:05:29 <psnively> Philippa: But all the cool kids reinvent Lisp (at least once, and often, more). :-)
15:05:59 <Philippa> sure. I nearly did just designing a PIM system for myself :-)
15:06:20 <psnively> PIMs seem to drive everyone to dynamic wildness.
15:06:32 <Philippa> the embarassing bit being how long it took me to go from "simple checklisting app" to "I'll want structured data and queries" (soon enough) to "ah, that'll be a lisp then"
15:06:58 <Baughn> calvins: You can't use mkRegex instead?
15:07:33 <calvins> doesn't work with unicode. i wish i could
15:07:44 <calvins> you mean the old regex lib, right?
15:07:45 <psnively> Philippa: lately I've been learning a bit about the Event Calculus. Try that--then everything will turn into a non-Prolog logic program. :-)
15:07:57 <Baughn> calvins: The mkRegex in Text.Regex. I suppose I might mean that.
15:07:58 <calvins> that's what I tried originally, but it couldn't parse a unicode pattern
15:08:47 <Philippa> psnively: yeah, I'd realised a while later that I wanted something event driven. Will look up the calculus, it's always good to add to the collection of minimal models
15:08:59 <sorear> @remember lament i could just use for loops for everything, i would just rather stab myself in the crotch
15:09:00 <lambdabot> Done.
15:09:50 <psnively> Philippa: It's not bad. 14 axioms for the discrete version; 21 for the continuous version. As always, the hard part is axiomatizing your domain.
15:10:13 <omniscientIdiot> calvins: try http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
15:10:15 <lambdabot> Title: teideal glic deisbhéalach  Blog Archive  A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
15:10:34 <psnively> Make the closed-world assumption, convert it all to CNF predicate logic, and throw it at a SAT solver.
15:10:35 <Baughn> calvins: Hm. I haven't looked at this library before - I appreciate their trying for something more structured, but tend to think String should instance RegexMaker
15:10:51 <Cale> Haha, the 10 minute length restriction on the videos makes for some interesting proof demonstrations :)
15:11:06 <psnively> Cale: "And then a miracle occurs..."
15:11:10 <calvins> omniscientIdiot: thanks, i already saw that, and it is definitely helpful for using =~, but it doesn't explain how to compile a regex so that it can be repeatedly re-used, which is what I'm trying to do.
15:11:23 <Baughn> @instances-all RegexMaker
15:11:23 <lambdabot> Unknown command, try @list
15:12:56 <calvins> Baughn: could you elaborate? Are you saying that the library should, or that that may be the fix to my problem?
15:13:36 <Baughn> calvins: Actually, I'm saying I can't figure out head nor tails of this library. makeRegex requires an instance of RegexMaker, and there /are/ none, anywhere, that I can find.
15:14:29 <Baughn> calvins: It looks like a stub. I suppose that's why it's marked experimental.
15:14:39 <calvins> I'm with you regarding not being able to make heads or tails of it.
15:14:45 <calvins> Perhaps I should have started by asking:
15:15:15 <omniscientIdiot> @instances-importing Text.Regex.Base RegexMaker
15:15:27 <calvins> Does anybody know of a *simple* or *well-documented* Haskell regex library that can handle Unicode? I.e., I want use a pattern like "[\x0000-\x000F]".
15:15:44 <omniscientIdiot> @instances-importing Text.Regex.Posix RegexMaker
15:15:46 <lambdabot> Regex CompOption ExecOption String
15:16:49 <Baughn> omniscientIdiot: Sadly, that'd be the non-unicode-supporting library he wants to avoid
15:19:02 <Baughn> calvins: Ah, here we go. Try http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-pcre-0.92
15:19:04 <lambdabot> http://tinyurl.com/29t2kx
15:19:24 <matthew-_> KatieHuber: ping!
15:19:34 <KatieHuber> matthew-_: pong!
15:19:44 <matthew-_> yay! My opengl guru is still awake!
15:20:00 <matthew-_> now, it would appear that I have 115MB of textures.
15:20:13 <KatieHuber> still awake?
15:20:16 <KatieHuber> it's 10.20am
15:20:26 <KatieHuber> I've had a good night's sleep since we last talked ;)
15:20:27 <matthew-_> oh, for some reason I thought you were in the uk
15:20:30 <matthew-_> ahh!
15:20:36 <matthew-_> at level 0. so with mipmapping, that'll become < 230MB yes?
15:20:46 <KatieHuber> mipmapping adds one third
15:21:07 <KatieHuber> so that's < 154MB
15:21:10 <matthew-_> yep
15:21:26 <matthew-_> so then I actually need < 0.6 of that loaded at the same time
15:21:43 <matthew-_> so that means that I demand no more than 92MB of textures loaded
15:21:46 <Baughn> KatieHuber: How much does a modern gpu take for non-texture things? Z-buffering and all that?
15:21:47 <KatieHuber> which fits neatly on a 128M card
15:22:28 <matthew-_> now, if there's only 64MB of ram on the card, do implementations manage to send unused mipmap levels out to main ram?
15:22:37 <matthew-_> or do they all keep all the mipmap levels together?
15:22:39 <KatieHuber> you can work it all out -- width * height * (4 (color, back) + 4 (color, front) + 4 (depth + stencil)) would be quite normal
15:22:40 <calvins> Baughn: that's the package I posted about (an earlier version, I believe). Even when I try importing Text.Regex.Base (which I need for the compile options and the like) and Text.Regex.PCRE.String, I get type errors that I can't fix
15:22:54 <KatieHuber> matthew-_: current video hardware can't page partial textures
15:23:04 <KatieHuber> a texture is resident or it's not, no half-way house
15:23:10 <matthew-_> okeydokie
15:23:12 <KatieHuber> (resident at all levels)
15:23:15 <Baughn> calvins: The library ships with tests. Hopefully you can use one of those as an example?
15:23:47 <Philippa> Baughn: re non-texture stuff, that entirely depends onwhat you ask the card to do
15:23:48 <matthew-_> KatieHuber: so the red book talks about things like, replacing a texture can be faster than creating a new one and deleting.
15:23:55 <calvins> ah, good idea, i'll check that out
15:24:06 <matthew-_> KatieHuber: all my textures are the same size. Is this actually true in real life?
15:24:12 <Baughn> Philippa: I'm asking mine to calculate the mandelbrot set, which is to say I haven't the faintest idea yet
15:24:21 <KatieHuber> TexSubImage2D is much cheaper than TexImage2D, it's true...
15:24:27 <KatieHuber> but you won't be altering your textures will you?
15:24:31 <matthew-_> no
15:24:34 <matthew-_> they're static
15:24:34 <sebell> I seem to recall seeing this discussed in the cafe, but is the `binary' package suitable for custom binary representations?
15:24:53 <sorear> YES!
15:25:00 <sjanssen> sebell: some of them, yes
15:25:02 <sorear> But the Binary *clas* is not
15:25:16 <Philippa> matthew-_: if you think about it, trying to page out mip levels is likely to go horribly wrong
15:25:19 <sjanssen> it does everything but bit-level encoding now
15:25:22 <Philippa> the cost of a cache miss is pretty nasty
15:25:24 <matthew-_> KatieHuber: but I have to deal with making sure I have the right textures in my 92MB - so I was thinking of using the SubImage stuff to swap out the textures I don't need
15:25:33 * mux wonders why Data.ByteString only offers a constrained map interface and not a generic one
15:25:51 <sebell> sjanssen: everything _but_ bit level encoding?
15:25:59 <sjanssen> yes
15:26:00 <sorear> yep.
15:26:01 <Philippa> sebell: bit != byte
15:26:02 <matthew-_> Philippa: err, well if you know you'll never need a particular level for filtering...
15:26:15 <Philippa> ...then you uploaded at too high a resolution in the first place
15:26:32 <matthew-_> no no, more the other way round - I'll never need the 1x1 version.
15:26:38 <Philippa> *hah*
15:26:42 <sebell> Philippa: Indeed :) I only ask because I'm looking to do bit-level encoding.
15:26:45 <matthew-_> of course, the memory savings by avoiding that are worthless
15:26:50 <Philippa> exactly
15:27:08 <matthew-_> yeah, good solid destruction of that idea then ;)
15:27:15 <sorear> sebell: is your data aligned to a bight boundary?
15:27:39 <KatieHuber> matthew-_: I wouldn't worry about it, let the GL driver sort it out
15:27:59 <matthew-_> KatieHuber: you'd just create objects for all of them then and just hope?
15:28:08 <KatieHuber> as long as the total MB-age of textures for a single frame is less than the available VRAM the driver should do a decent job of that
15:28:25 <sebell> sorear: No. It would probably be more clear to say that I'm looking to implement the BER for a subset of ASN.1
15:28:26 <matthew-_> KatieHuber: do real applications use the proxy stuff to try and figure out the size of vram and only load suitable textures?
15:28:33 <KatieHuber> if you're exceeding VRAM in a single frame then you can help out significantly
15:28:44 <Philippa> real apps tend to bucket primitives by material where they can
15:28:49 <Philippa> that minimises swapping cost
15:28:53 <matthew-_> yeah, the batching stuff.
15:29:01 <matthew-_> my problem is that I have one use of each texture
15:29:09 <KatieHuber> proxy stuff doesn't help you know how much VRAM you have
15:29:13 <matthew-_> true
15:29:18 <Baughn> matthew-_: You could try for procedural textures
15:29:21 <Philippa> there's not much you can do then, is there?
15:29:39 <matthew-_> well, I do know whether a particular texture is on screen or not
15:29:56 <matthew-_> so I can manually destroy that texture object, or maintain a working set of texture objects that are on screen
15:30:13 <matthew-_> I just wanted to know whether it's likely I'd do a better or worse job at that than the driver
15:30:15 * Philippa wonders if drivers actually buffer commands enough to do predictive caching yet
15:30:46 <Philippa> we're working with enough memory these days
15:30:55 <KatieHuber> I would just do the naïve thing.  there's a very good chance it's perfectly good enough.
15:31:26 <matthew-_> yes, KISS and all that. Super, I'll give it a go. In the morning. It's bed time. Thanks for the advice.
15:31:36 <KatieHuber> if it's not, there may be some tricks you can employ to help it out, but there's no point doing something complicated when the simple thing is probably right
15:31:40 <Philippa> as a rule, implement the KISS approach first
15:31:46 <matthew-_> indeed
15:31:47 <Philippa> at least that way you catch any other problems
15:32:06 <sebell> sorear, sjanssen: I'm suspecting that for that reason I won't be able to use it. Thought I'd run it by the channel in case my assumptions were wrong!
15:32:25 <nothingmuch> -
15:32:25 <sorear> sebell: write a transformer
15:32:41 <matthew-_> Philippa: I've actually had successful speed improvements when writing a memory manager to delete unused VBOs
15:32:59 <ddarius> psnively: What's this Event Calculus stuff and why haven't I heard about it on LtU?
15:33:01 <matthew-_> thus keeping the VBOs that are in use in the VRAM does seem to help
15:33:20 <Philippa> yeah, VBOs are a more likely candidate for that
15:33:20 <matthew-_> otoh, this was most obvious on an ATI card using mesa drivers, which probably suck
15:33:32 <sebell> sorear: From ? -> ?
15:33:55 <psnively> ddarius: It's not really programming-language related.
15:33:56 * matthew-_ -> IO Sleep
15:34:19 <sorear> sebell: StateT Byte Get a
15:34:35 <psnively> ddarius: http://www.amazon.com/Commonsense-Reasoning-Erik-T-Mueller/dp/0123693888
15:34:36 <Philippa> is there a good basic calculus for dataflow programming yet?
15:34:39 <lambdabot> http://tinyurl.com/2et3th
15:39:02 <sebell> sorear: Ah ok. That makes sense (I think) :)
15:40:03 <glen_quagmire> how can I develope a new calculus? like lambda calculus, pi calculus
15:40:34 <psnively> glen_quagmire: Be Tony Hoare or Alonzo Church?
15:41:18 <glen_quagmire> ok. that'd be my next holloween costume
15:41:20 <ddarius> Or Luca Cardelli.
15:41:41 <ddarius> glen_quagmire: I'd stick with Church, he's dead enough not to notice.
15:41:48 <glen_quagmire> I am Dr. Church, submit to my lambdas
15:42:01 <glen_quagmire> we need Alonzo Church action figure
15:42:03 <Philippa> not be bound by them?
15:42:18 <FMota> :/  I'm get sad every time someone mentions Church because I remember Turing
15:42:27 <FMota> and Turing's story is so sad
15:42:57 <psnively> FMota: I don't get sad.
15:43:00 <psnively> I get angry.
15:43:11 <FMota> :/
15:43:26 <fax> hey times have changed
15:43:27 <FMota> at who? soceity? the British? :/
15:43:36 <FMota> you can't get angry at the past
15:43:52 <sieni> FMota: yes you can
15:43:53 <psnively> On the contrary; getting angry at the past is a vital component of changing the future.
15:44:19 <Philippa> and institutionalised homophobia and mistreatment of psychiatric patients are both good things to get angry about
15:44:25 <FMota> hmm, I don't mean it like that though
15:44:31 <glen_quagmire> our president got angry at sadam for attacking his father
15:44:36 <sieni> FMota: perhaps a zen master wouldn't get angry about the past, but regular people do
15:44:39 <glen_quagmire> oh crap it's all off topic
15:44:55 <FMota> glen_quagmire: it's all off topic anyway :)
15:44:55 <sieni> -> -blah
15:45:16 <FMota> anyway
15:45:23 <FMota> I don't get angry when I hear about Turing
15:45:25 <FMota> I get sad.
15:45:47 <glen_quagmire> Offtopic a, Ontopic b => a -> b
15:45:50 <sieni> we have this thing called #haskell-blah when we get off topic, so everybody is ofcourse welcome there
15:47:23 <glen_quagmire> :t liftM
15:47:25 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:49:51 <byorgey> glen_quagmire: liftM is pretty much the same as fmap, if that helps.
15:49:55 <ptolomy> Uniqueness typing is cool.
15:50:25 <psnively> Yes. And Clean is a nice language.
15:50:42 <psnively> Too bad they bailed on concurrency and took wayyyyyyy too long to go to free software.
15:50:43 <ddarius> Except for the ugly parts.
15:51:16 <glen_quagmire> byorgey: thanks
15:51:30 * ptolomy looks to the Clean website for information on concurrency bailing.
15:51:43 <psnively> ddarius: Well, that's a truism of any language. :-)
15:52:28 <byorgey> forall x. (Language x) => x is nice except for the ugly parts.
15:52:48 <psnively> Word.
15:57:15 * FMota wonders
15:57:56 <FMota> is there any theorem that proves that a quine can be constructed on any Turing Machine
15:58:08 <psnively> I think so.
15:58:14 <FMota> there should be :)
15:58:15 <psnively> But I'm not 100% sure.
15:58:18 <sieni> what is a quine?
15:58:35 <pgavin> a quine is a program that prints out a quine
15:58:38 <psnively> "Is a quine" is a quine.
15:58:39 <FMota> turing machine writes its own code onto the disk before running
15:58:39 <pgavin> err, itself
15:58:54 <sieni> ahh'
15:59:04 <pgavin> both :)
15:59:09 <FMota> code being the states and stuff :)
15:59:12 <psnively> I'm reasonably confident that the theorem would just be a variation of some fixpoint theorem.
15:59:28 <FMota> fixpoint theorem?
15:59:30 <sieni> psnively: I thought the same.
15:59:32 <abc1234567> hi
15:59:49 <abc1234567> I'm new to haskell, and trying to run a simple function in GHCi
15:59:55 <abc1234567> xPrelude> sum x = x  +x
15:59:55 <abc1234567> <interactive>:1:6: parse error on input `='
16:00:00 <shachaf> abc1234567: Use let.
16:00:00 <abc1234567> what's wrong?
16:00:04 <shachaf> let sum x = x + x
16:00:27 <abc1234567> thanks :)
16:00:38 <omniscientIdiot> > let sum x = x + x in sum 5
16:00:44 <shachaf> "Is a quine" is not a quine.
16:00:44 <lambdabot>  10
16:00:44 <byorgey> FMota: yes, there is.
16:00:50 <sieni> abc1234567: because of the nature of haskell, you can't just dump some random code into ghci
16:00:55 <FMota> :)
16:00:55 <psnively> shachaf: Heh. I was waiting!
16:00:57 <byorgey> FMota: I think it's called the recursion theorem.
16:00:59 <abc1234567> I see
16:01:05 <scsibug> abc123: think of GHCi as a big "do" loop.  So you can't write code in there as if it was a normal source file.
16:01:06 <abc1234567> thanks sieni :)
16:01:15 <abc1234567> I know, I've read the book
16:01:18 <shachaf> "Is a quine when quined" is a quine when quined.
16:01:26 <abc1234567> but they don't mention let in the begin of it
16:01:49 <abc1234567> thanks people
16:01:51 <FMota> ty, byorgey
16:01:53 <shachaf> abc1234567: Which book?
16:02:12 <abc1234567> bu hutton
16:02:14 <abc1234567> *by
16:02:17 <abc1234567> let me have a look
16:02:23 <shachaf> Oh.
16:02:27 <shachaf> Doesn't that one use Hugs?
16:02:30 <shachaf> Mostly?
16:02:32 <sieni> abc1234567: that's a property of ghci, I'm not sure if e.g. hugs allows that
16:03:11 <abc1234567> not explicitely
16:03:19 <psnively> FMota, byorgey: http://www.google.com/url?sa=t&ct=res&cd=2&url=http%3A%2F%2Fwww.cs.pomona.edu%2F~joev%2Fcourses%2Ff05%2Fcs081%2Fsupplements%2Frecursion.pdf&ei=6VjwRoScEqOOgwP_062hCw&usg=AFQjCNEBM7Y1Q9buAzmwUuxdRqWdNeKeYw&sig2=0PIq8P6uvOCJRJop136iqg
16:03:21 <lambdabot> http://tinyurl.com/2fs8zn
16:03:33 <abc1234567> thanks, I'm going to get some sleep
16:03:35 <abc1234567> seeya
16:03:59 <FMota> nice
16:05:08 <sieni> pure functionality and lexically scoped top level don't work that well with an interactive toplevel
16:05:44 <Philippa> well no. So what you do interactively is something slightly different
16:05:53 <sieni> and static typing as long as we are talking about this
16:06:05 <sieni> Philippa: indeed
16:06:24 <kpreid> an interactive definition-supporting toplevel *could* be supported
16:06:29 <kpreid> it's just no been done
16:06:33 <kpreid> +t
16:06:49 <hpaste>  LoganCapaldo pasted "Pleae, what is wrong with the commented out type signature? (code typechecks w/o it)" at http://hpaste.org/2802
16:07:29 <omniscientIdiot> LoganCapaldo: what does :t say?
16:07:52 <byorgey> LoganCapaldo: shouldn't it return m (a,s)?
16:08:05 <LoganCapaldo> doh
16:08:16 <ddarius> sieni: ML has had interactive top-levels for a long long time and hbc was far more flexible than GHC.
16:08:23 <psnively> Eh. MetaOCaml does a nice job with static typing and an interactive toplevel.
16:08:39 <sieni> ddarius: and ML has its problems with the top-level
16:09:02 <LoganCapaldo> I shoulda stopped trying to grok the type error, heh :)
16:09:05 <sorear> sieni: it does!?
16:09:09 <psnively> Yes, at least if you expect the toplevel to print types of things typed in interactively.
16:09:10 <sieni> ddarius: (i'm not saying that lisp doesn't)
16:09:25 <sorear> ddarius: those are quite related
16:09:27 <psnively> sorear: Yes. Examine the source code for, e.g. OCaml's toploop.
16:09:38 <ddarius> sorear: True.
16:09:39 <oerjan> LoganCapaldo: instead you could have asked what the compiler thought the type was with :t
16:10:06 <sieni> ddarius: since the top-level is lexically bound, then if you reload some definitions, your old functions will see the old definitions and you will only partly override stuff
16:10:21 <LoganCapaldo> oerjan: yeah that's been mentioned
16:10:26 <LoganCapaldo> I also did do that
16:10:39 <LoganCapaldo> but my eyes mustve glazed over :)
16:12:29 <sieni> ddarius: this way your running system will get rotten piece by piece and eventually you have to restart your program (unless you use hs-plugins or something similar, which tries to exactly avoid this problem)
16:12:30 <FMota> > "abc"
16:12:32 <lambdabot>  "abc"
16:12:36 <FMota> > show "abc"
16:12:38 <lambdabot>  "\"abc\""
16:12:56 <oerjan> iirc Vital/Pivotal recompute everything necessary when you change the interactive document
16:12:56 <pgavin> > show $ show "abc"
16:12:57 <omniscientIdiot> A small note, Control.Monad.State's StateT orders its type args differently
16:12:58 <lambdabot>  "\"\\\"abc\\\"\""
16:13:25 <LoganCapaldo> omniscientIdiot: I was trying not to peek
16:13:37 <omniscientIdiot> LoganCapaldo: good job, otherwise :)
16:14:16 <omniscientIdiot> typically the inner monad argument to a transformer is last before the result type.
16:14:55 <oerjan> that way it can be a member of the MonadTrans type class
16:15:08 <FMota> > let bod = " in  \"let bod = \" ++ show bod ++ bod" in "let bod = " ++ show bod ++ bod
16:15:10 <lambdabot>  "let bod = \" in  \\\"let bod = \\\" ++ show bod ++ bod\" in  \"let bod = \"...
16:15:36 <omniscientIdiot> note also that runStateT can have the s removed, and then it just unpacks f.
16:16:02 <LoganCapaldo> yeah
16:16:29 <LoganCapaldo> I found it easier not to overload my brain with that :)
16:16:43 <LoganCapaldo> at one poitn my bind was doing the unpacking in the pattern matching
16:16:48 <omniscientIdiot> and thus can be written as a field selector: newtype StateT s m a = StateT {runStateT :: s -> m (a, s)}
16:16:49 <oerjan> that's a common trick in the monad library - runXXX is just the field name for the newtype
16:16:53 <balodja> Oh! Now about ajunctions! That's first-class. http://youtube.com/watch?v=loOJxIOmShE
16:16:54 <LoganCapaldo> and I got conufsed how "unwrapped" a value was
16:17:10 <hpaste>  FMota pasted "My Haskell Quine :) -- sort of" at http://hpaste.org/2803
16:18:10 <LoganCapaldo> It's weird
16:18:32 <byorgey> FMota: nice =)
16:18:37 <FMota> :D
16:19:06 <LoganCapaldo> StateT Foo is more like Foo (State a) than State s (Foo a) whch is kind of backwards from what I thought
16:20:06 <omniscientIdiot> not *quite* sure what you mean by that, but it sounds sorta towards the right thing :)
16:20:38 <LoganCapaldo> well the example I always think of StateT List
16:20:55 <LoganCapaldo> I kept thinking it would look like ([a], s)
16:21:07 <LoganCapaldo> when it really looks like [(a,s)]
16:21:09 <omniscientIdiot> That's just State s [a]
16:21:17 <LoganCapaldo> yeah
16:21:31 <LoganCapaldo> I thought the Ts just sort of tacked on their stuff to the outside
16:22:05 <LoganCapaldo> which in retrospect is kind of pointless, since you can already do that
16:22:06 <omniscientIdiot> it kinda squidges it in the middle
16:22:10 <LoganCapaldo> yeah
16:22:34 <LoganCapaldo> so writing this has _just now_ had me start to understand how they work
16:24:40 <fax> can you make haskell memoize stuff
16:24:40 <sorear> > ap(++)show"ap(++)show"
16:24:40 <lambdabot>  "ap(++)show\"ap(++)show\""
16:24:40 <sorear> fax: yes, all 0-argument functions are automatically memoized
16:24:40 <fax> thats cool
16:24:41 <fax> not possible for anything else though?
16:24:41 <fax> I guess if you tried it would probably run out of memory soon
16:24:41 <byorgey> sure it is, but depending on what you want to do, it may not be necessary.
16:24:49 <FMota> sorear: fun :)
16:25:46 <oerjan> > fib = 1:1:zipWith(+)fib(tail fib) -- a sort of memoization
16:25:47 <lambdabot>  Parse error
16:25:56 <oerjan> > let fib = 1:1:zipWith(+)fib(tail fib) in fib -- a sort of memoization
16:25:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:26:18 <astrolabe> fax: http://www.haskell.org/haskellwiki/Memoization
16:26:19 <lambdabot> Title: Memoization - HaskellWiki
16:26:42 <byorgey> oerjan: you have some extra spaces around the equals sign =P
16:27:06 <oerjan> byorgey: this was not an attempt to be short
16:27:22 <oerjan> for that i now prefer the scanl version :)
16:27:40 <byorgey> oerjan: yes, I know, which is why I was wondering why you smooshed everything together like that =)
16:27:55 <oerjan> just partial habit
16:28:27 <byorgey> > fix ((1:) . scanl (+) 1)
16:28:29 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:28:36 <hpaste>  EvilTerran annotated "My Haskell Quine :) -- sort of" with "how's this for a compilable one?" at http://hpaste.org/2803#a1
16:28:45 <byorgey> I guess you don't need any spaces in that one!
16:28:51 * EvilTerran shows off gratuitously
16:28:53 <shachaf> > fix$(1:).scanl(+)1
16:28:57 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:29:55 <fax> EvilTerran: That's so straightfoward
16:29:58 <fax> impressive
16:29:59 <omniscientIdiot> (emphasis on *show*)
16:30:23 <omniscientIdiot> :P
16:30:26 <EvilTerran> the instance Show Char producing a valid haskell string constant for [Char] is kinda handy, yes
16:30:28 <psnively> Bwahahahahahahahahaha
16:34:43 <EvilTerran> that particular trick's kinda reminiscent of my favourite perl one, actually:
16:34:43 <EvilTerran> print <<END x 2, "END";
16:34:43 <EvilTerran> print <<END x 2, "END";
16:34:43 <EvilTerran> END
16:35:15 <EvilTerran> again, using quoting tricks to get around having to do any string processing
16:35:41 <byorgey> hehe, nice, I'd never seen that one
16:36:19 <Pseudonym> ?arr
16:36:19 <lambdabot> Drink up, me 'earties
16:36:50 <oerjan> arr! it be Sep 19 in Europe :)
16:36:52 <Pseudonym> Happy Talk Like a Pirate Day, ye Eastern Hemisphere scurvy dogs!
16:37:01 <Pseudonym> And ye Europeans!
16:37:06 <fax> @hoogle CallCC
16:37:10 <lambdabot> Control.Monad.Cont.callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
16:37:15 <Pseudonym> Especially ye Spaniards, with ye precious dubloons!
16:37:46 <psnively> And ye scurvy Englishmen with yer pieces of eight!
16:37:48 <EvilTerran> altho' there be summat stirring 'bout such trickery as "seek DATA, 0, 0; print <DATA>; __DATA__"
16:38:09 <psnively> "Seek DATA, and ye shall find..."
16:39:13 <byorgey> EvilTerran: I not be familiarr wi'that.  What language mi' that be?
16:39:46 <EvilTerran> that thar dirty trickery be in the ancient tongue they call... perl.
16:40:31 <olsner> why is it talk like a pirate day again?
16:40:46 <olsner> I thought that was all done and dusted
16:40:47 <EvilTerran> 0034 <oerjan> arr! it be Sep 19 in Europe :)
16:40:53 <psnively> The Black Perl (arrrrgh, but I repeat myself).
16:40:55 <Zao> olsner: A wild guess would be that it's about a year since last time.
16:40:56 <byorgey> Perl! well shiver me timbers!
16:40:59 <Pseudonym> It be Sep 19 in Australia, too!
16:41:09 <Pseudonym> In fact, it not be after Sep 19 anywhere.
16:41:14 <fax> @docs CallCC
16:41:14 <lambdabot> CallCC not available
16:41:16 <olsner> an entire year? I doubt
16:41:21 <hpaste>  infrared pasted "ghc shows "Ambiguous type" error" at http://hpaste.org/2804
16:41:34 <shachaf> @. arr ghc
16:41:35 <lambdabot> Arrr!
16:41:46 <Pseudonym> It still be Sep 19 in Kiribati.
16:42:09 <olsner> @ghc
16:42:10 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
16:42:11 <infrared> any ideas?
16:42:22 <shachaf> @arr should be a filter like @elite.
16:42:22 <lambdabot> Avast!
16:42:22 <olsner> are these actual ghc error messages?
16:42:29 <olsner> @. elite ghc
16:42:29 <lambdabot> 9|-|c SaY$: /\/\A|fOrmED pREdi(A7e
16:42:36 <EvilTerran> byorgey, the __DATA__ marker be indicatin' to yon interpreter to crack open a handle by the name of DATA, pointin' at the scurvy character immediately after
16:43:07 <hpaste>  infrared annotated "ghc shows "Ambiguous type" error" with "(no title)" at http://hpaste.org/2804#a1
16:43:25 <EvilTerran> seek be movin' the marker to the start o' the file, an' then print be printin' it. yarr.
16:43:26 <infrared> pasted the error message as well
16:44:18 <infrared> i would like it to work for both empty and non-empty lists
16:45:42 <byorgey> EvilTerran: madness, I tell ye!
16:46:42 <hpaste>  LoganCapaldo pasted "ReaderT, and look the type params are in the right order" at http://hpaste.org/2805
16:47:34 <olsner> ooh... so M=M+2N corresponds to the haskell type data M = Loop M | Finish Bool N ... with (,) as multiplication and Either as addition
16:47:47 <byorgey> infrared: since the empty list is of type [a] for any a, the compiler can't prove that a is an instance of Show
16:48:02 <olsner> my head hurts... but in a good way, I think
16:48:04 <EvilTerran> > show ([] :: [Char])
16:48:06 <lambdabot>  "\"\""
16:48:09 <EvilTerran> > show ([] :: [Int])
16:48:11 <lambdabot>  "[]"
16:48:21 <EvilTerran> ^ how does it know which show to use?
16:48:26 <EvilTerran> @instances Show
16:48:28 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
16:48:31 <byorgey> EvilTerran: that's not quite the same thing
16:49:06 <infrared> byorgey: but second returns Nothing for empty list and we have a case for Nothing that returns an instance of Show (namely a string)
16:49:29 <idnar> @type Any
16:49:32 <lambdabot> Bool -> Any
16:49:56 <hpaste>  byorgey annotated "ghc shows "Ambiguous type" error" with "(no title)" at http://hpaste.org/2804#a2
16:50:30 <byorgey> infrared: the type of showSecond is (Show a) => [a] -> String, which means that it only works on lists of type (Show a) => [a].
16:50:38 <byorgey> i.e. lists which contain Show-able things.
16:51:03 <olsner> @seen sigfpe
16:51:03 <lambdabot> I haven't seen sigfpe.
16:51:08 <infrared> byorgey: yeah, i wrote that, but i actually wanted to write other type (just don't know haskell that well yet)
16:51:31 <infrared> i meant: it returns a string and takes either an empty list or a list of (Show a)
16:51:36 <oerjan> infrared: ye mi' be trying yon -fextended-default-rules flag
16:51:42 <olsner> that's not what he's called here huh
16:51:42 <infrared> how can i denote that type?
16:52:44 <byorgey> infrared: you can't that I know of.  In practice, though, it shouldn't be a problem since any empty lists you pass to showSecond will have a particular type.
16:53:13 <byorgey> at least, that would be my guess.
16:53:35 <infrared> byorgey: yeah, you're probably right. exception is an empty list literal without type definition
16:54:30 <infrared> what -fextended-default-rules does that the compilation passes for my example?
16:55:23 <oerjan> it allows defaulting in more cases, such as for a Show constraint
16:55:51 <oerjan> in original haskell 98 you don't get defaulting unless you use numeric types
16:56:32 <infrared> so here [] defaults to [Int] or [String] or sth else, just like 1 defaults to Int in haskell 98, yes?
16:56:46 <oerjan> Integer, actually
16:56:59 <infrared> ok
16:57:06 <byorgey> interesting, I didn't know about -fextended-default-rules
16:57:12 <infrared> thanks, that clears things up
16:57:17 <oerjan> default (Integer, Double) is the default default :)
16:57:43 <infrared> but either way is awkward for my dynamicly-typed mind :)
16:58:28 <oerjan> http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html#extended-default-rules
16:58:31 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2c2oeu
17:00:09 <psnively> infrared: Wow, going whole hog from dynamic to static and lazy and pure, eh? :-D
17:01:06 <chessguy> 'evening
17:01:13 <fax> hi chessguy
17:01:27 <sorear> hi
17:01:37 <fax> can you use state monad and callcc together?
17:01:49 <dons> sure
17:01:52 <fax> ok cool
17:02:07 <oerjan> > "(" -- dons, you know about this?
17:02:07 <lambdabot>  Unbalanced parenthesis
17:02:26 <sjanssen> that is weird
17:02:43 <dons> talk to Language.Haskell :)
17:02:46 <sjanssen> > "(" ++ ")"
17:02:47 <lambdabot>  "()"
17:02:48 <oerjan> Lib/Parser.hs is broken in at least three different ways
17:02:55 <dons> likely more
17:02:56 <oerjan> dons: nope, it's not there
17:03:13 <oerjan> er, is Lib/Parser.hs part of that?
17:03:15 <dons> Lib/Parser.hs is just Language.Haskell.Parser
17:03:23 <dons> with a hook into the expression parser
17:03:29 <oerjan> no it is not
17:03:32 <shachaf> > 1 -- )
17:03:33 <lambdabot>  Unbalanced parenthesis
17:03:37 <oerjan> take a look at it
17:03:46 <dons> sure it is. i did the import
17:03:53 <EvilTerran> > show ([] :: Show a => [a])
17:03:55 <lambdabot>  "[]"
17:04:02 <dons> oerjan: look at the imports
17:04:04 <oerjan> what i mean is, the way it used parseModule is broken
17:04:05 <hpaste>  LoganCapaldo pasted "I don't get how to write >>= for MaybeT. Seems like you lose the advantage of having a MaybeT with t" at http://hpaste.org/2806
17:04:06 <sorear> dons: look at it
17:04:08 <EvilTerran> > show ([] :: String)
17:04:10 <lambdabot>  "\"\""
17:04:15 <sorear> dons: I changed it recently, remember?
17:04:18 <oerjan> dons: i am not talking about Language.Haskell itself
17:04:22 <dons> oh, sorear broke it?
17:04:26 <sorear> yep
17:04:28 <dons> good.
17:04:31 * dons goes back to work
17:04:37 <sorear> and fixed the build for about ten people, so I feel justified
17:04:40 <oerjan> there is a completely useless balance function
17:05:01 <oerjan> it does not really prevent anything, and breaks legal code
17:05:02 <sorear> oerjan: code injection paranoia
17:05:16 <sorear> oerjan: you're saying it's not needed?
17:05:31 <oerjan> > {- ( -} "Not useful" )
17:05:32 <lambdabot>  Parse error
17:05:45 <oerjan> i am saying it does not help in any significant way
17:05:53 <sorear> ah
17:05:55 <oerjan> that last expression gets past it
17:06:00 <sjanssen> sorear: very real code injection problems
17:06:09 <oerjan> and the first one doesn't, despite being legal
17:06:11 <EvilTerran> LoganCapaldo, have ye taken yer chances with newtype deriving?
17:06:32 <LoganCapaldo> EvilTerran: if I do that I won't learn anything :)
17:06:34 <shachaf> Isn't it m (Maybe a) instead of Maybe (m a)?
17:06:45 <sorear> > {- ) -} )    ( {- ) -}
17:06:46 <lambdabot>  Unbalanced parenthesis
17:06:46 <LoganCapaldo> shachaf: that coud be it
17:06:52 <sorear> > {- ( -} )    ( {- ) -}
17:06:53 <lambdabot>   parse error on input `)'
17:07:19 <oerjan> > "(" ) ; thisIsTopLevel = ( ")"
17:07:37 <oerjan> that one gets past enough to crash the runplugs
17:07:40 <oerjan> i think
17:08:13 <oerjan> however, i believe for safety balance is not needed even if it worked
17:08:45 <oerjan> the trick is that the initial checks wraps the expression in ( ), while the actual compile wraps it in { }
17:09:21 <oerjan> i believe this in fact makes it impossible to inject anything that escapes the final { }
17:09:54 <oerjan> > , , -- also gets past the initial check
17:09:55 <lambdabot>   parse error on input `,'
17:10:31 <oerjan> the last one is because not everything inside parentheses needs be an expression
17:13:13 <oerjan> (i.e. it parses as (,,) )
17:13:35 <sjanssen> oerjan: you're saying that we have extra paren matching in the @run plugin?
17:13:47 <sjanssen> that's probably out of date and should be removed
17:15:25 <Paczesiowa> I got little problem: I wrote function (with hxt arrows) which downloads html file, parses it, scans for urls, downloads them all, scans them for images, and returns list (like all arrows I think) of image links. then I print head of that list. the problem is: why are other files being downloaded when they are not needed? kinda greedy...
17:15:55 <oerjan> sjanssen: yep and it is strictly character based so doesn't really work
17:16:33 <sjanssen> oerjan: must be from before the Language.Haskell integration, should be safe to remove it
17:17:48 <oerjan> i think so to
17:19:14 <shachaf> Paczesiowa: @paste your code, maybe (note that I haven't used HXT myself).
17:19:33 <Olathe> Paczesiowa: It's supposed to get the images on one page ?
17:20:13 <Paczesiowa> I kind of feard that you tell me that all hxt or all arrows aren't lazy
17:20:29 <shachaf> Paczesiowa: Is this in IO?
17:20:32 <Paczesiowa> I'll clean that code a little before pasting
17:20:48 <Paczesiowa> hxt arrows are in IO and state
17:21:00 <shachaf> do { x <- download m; y <- download n; return x } will still run "download n".
17:21:57 <oerjan> > (x ; y)
17:21:58 <lambdabot>  Parse error
17:24:09 <Paczesiowa> but if I readFile, and print it until some condition, then I won't get all read right?
17:24:20 <Paczesiowa> s/I/it
17:25:06 <EvilTerran> yeah. that's because readFile is magic, though
17:25:07 <shachaf> Paczesiowa: readFile is lazy, with unsafeInterleaveIO
17:25:11 <shachaf> @src readFile
17:25:11 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
17:25:17 <shachaf> @src hGetContents
17:25:17 <lambdabot> Source not found. Where did you learn to type?
17:26:05 <hpaste>  LoganCapaldo annotated "I don't get how to write >>= for MaybeT. Seems like you lose the advantage of having a MaybeT with t" with "Thanks, shachaf!" at http://hpaste.org/2806#a1
17:26:16 <Paczesiowa> shachaf: looks like I have some googling to do
17:26:43 <Pseudonym> http://www.youtube.com/watch?v=AarhZScyuz0
17:26:46 <Pseudonym> Gah./
17:26:50 <Pseudonym> Sorry, didn't mean to post that.
17:27:00 <shachaf> unsafeInterlaveIO makes an IO action "lazy".
17:27:09 <Paczesiowa> why is it unsafe?
17:27:22 <shachaf> So its value isn't calculated when you (>>=) it, but only when you use what's returned.
17:27:47 <shachaf> You can't control the order of evaluation when you use it.
17:28:19 <Paczesiowa> that can be dangerous for arrows downloading files:/
17:28:30 <Paczesiowa> connection can be closed or something
17:29:50 <infrared> connection shouldn't be even open in that case, i guess
17:30:40 <LoganCapaldo> I think I'm stating to get this
17:32:06 <fax> how does this sound?
17:32:24 <Paczesiowa> but that function downloads and parses html file and searches for links, lazy would mean that after finding first link it can stop parsing and even downloading. but then when I decide to get 2nd link, connection is closed:/
17:32:46 <fax> I want to traverse a tree.. and do something on each leaf.. if something happens though will need to bail out immediatly
17:33:05 <fax> so should I use callCC for that or something else?
17:33:26 <oerjan> fax: throwError might be enough
17:33:46 <fax> oh yeah that sounds good
17:34:17 <oerjan> :t throwError
17:34:20 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
17:34:38 <infrared> Paczesiowa: still, the implementation decides how many bytes are actually downloaded over the wire, so the image will be get in one step. but you're right, disconnection may happen and a good library should cover it under the hood and reconnect
17:34:48 <fax> :t catchError
17:34:50 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
17:37:48 <dolio> > either read id (foldM (\a b -> if a == 0 then Left "0" else Right (a*b)) 1 [1, 2, 3, 0, undefined, 4]) :: Integer
17:37:50 <lambdabot>  0
17:38:03 <fax> great catchError is a lot easier than callCC
17:38:40 * dolio mutters about the Either monad instance requiring an Error instance for the Left type.
17:40:16 <sorear> dolio: it's fail's faunt
17:42:19 <oerjan> > let test = do return () ; in test ++ ""
17:42:21 <lambdabot>  Couldn't match expected type `()' against inferred type `Char'
17:42:31 <oerjan> aha...
17:42:44 * oerjan cackles evilly
17:43:48 <fax> Does this type look weird? (MonadError [Char] m, MonadState Int m) => Tree -> m (m ())
17:43:50 <kpreid> > "abc" >>= show
17:43:52 <lambdabot>  "'a''b''c'"
17:44:06 <kpreid> fax: yes
17:44:23 <kpreid> m (m a) means you've probably got something wrong
17:44:43 <fax> ok I'll try and sort that
17:44:54 <oerjan> are you doing return <monadic action> perhaps?
17:45:00 <fax> yes
17:45:08 <oerjan> remove the return
17:45:08 <kpreid> well, don't do that then.
17:45:14 <fax> (MonadError [Char] m, MonadState Int m) => Tree -> m ()
17:45:17 <fax> this is better
17:45:40 <oerjan> quite normal in fact
17:45:42 <fax> Do I compose catchError and execState somehow though?
17:46:05 <fax> because I have called each one separately but I don't know how to use them together
17:46:51 <EvilTerran> something involving lift?
17:46:57 <oerjan> runErrorT and execState
17:47:35 <oerjan> what is your monad?
17:48:11 <oerjan> or isn't that precisely defined yet?
17:48:17 <fax> I'm using State Monad and Control Monad
17:48:21 <fax> err
17:48:26 <fax> I meant Error Monad sorry
17:48:38 <oerjan> the order of composition may be important
17:48:59 <dibblego> > lambda
17:49:00 <lambdabot>   Not in scope: `lambda'
17:49:04 <dibblego> > L.lambda
17:49:05 <lambdabot>   Not in scope: `L.lambda'
17:49:08 <oerjan> but anyway, catchError is within the monad
17:49:16 <oerjan> execState is outside, do set it up
17:49:44 <dibblego> @let lambda = 'λ'
17:49:45 <lambdabot>  Improperly terminated character constant
17:50:11 <oerjan> Language.Haskell apparently does not handle unicode
17:50:13 <EvilTerran> fax, i'd suggest you use one of those as a transformer
17:50:24 <fax> I thought lambdabot speaks iso-latin or something
17:50:25 <EvilTerran> oerjan, nah, ghc doesn't.
17:50:41 <fax> EvilTerran: One of which?
17:50:44 <oerjan> EvilTerran: in strings it does
17:50:45 <EvilTerran> > ord $ head "λ"
17:50:47 <lambdabot>  955
17:51:06 <EvilTerran> okay, ghc's lexer (i guess) can't cope with multibyte characters, then
17:51:09 <dibblego> > ord 'λ'
17:51:10 <lambdabot>  Improperly terminated character constant
17:51:10 <kpreid> > length "λ"
17:51:12 <lambdabot>  1
17:51:12 <oerjan> and presumably it would do character constants too
17:51:20 <EvilTerran> > printf "%x" $ ord $ head "λ"
17:51:21 <lambdabot>  Add a type signature
17:51:24 <EvilTerran> > printf "%x" $ ord $ head "λ" :: String
17:51:26 <lambdabot>  "3bb"
17:51:27 <oerjan> i _think_ that error is from the Language.Haskell check
17:51:30 <kpreid> > λ
17:51:30 <lambdabot>  Illegal character ''\187''
17:51:34 <kpreid> > é
17:51:35 <lambdabot>  Illegal character ''\169''
17:51:37 <EvilTerran> > '\x{3bb}'
17:51:38 <lambdabot>  Illegal escape sequence
17:51:39 <EvilTerran> > '\x3bb'
17:51:41 <lambdabot>  '\955'
17:51:47 <EvilTerran> there we go
17:51:51 <EvilTerran> fax, one of the monads
17:52:15 <fax> hmm
17:52:23 <fax> Where do read about transforming monads?
17:52:31 <EvilTerran> i may be confused, but it sounded like you're trying to use two instances of Monad at once
17:52:32 <fax> I've not seen anything on it
17:52:50 <oerjan> fax: there are two issues here. one is your actual action which probably is in a MonadError/MonadState monad
17:53:11 * EvilTerran figured it out by reading the docs and asking stupid questions on here
17:53:23 <oerjan> the second issue is how to build such a monad for your action to work in, this is done with transformers
17:53:40 <fax> Oh I see
17:53:53 <fax> So I actually want to make a new monad which has the properties of both State and Error ?
17:53:54 <oerjan> catchError is inside the action, so is part of the first
17:53:58 <oerjan> yep
17:54:38 <oerjan> ErrorT String (State Int) or StateT Int (Either String)
17:54:57 <EvilTerran> you'd either want ErrorT String (State Int) or StateT Int (Either String), i think
17:54:58 <oerjan> i am not sure whether it makes a difference which you use in this case
17:55:03 <EvilTerran> drat, beaten to the punch
17:55:09 <oerjan> :D
17:55:42 <kpreid> EvilTerran: it makes a difference
17:55:47 * kpreid tries to rememver which is which
17:55:50 <EvilTerran> in one case, the state would be preserved even in the case of an exception. in the other, an exception => no state retained
17:55:56 <EvilTerran> i dunno which is which, though
17:55:57 <oerjan> right
17:56:07 <oerjan> ErrorT preserves, i think
17:56:09 <kpreid> ErrorT of State rolls back, I think
17:56:11 <wli> StateT Int (Either String) can restart, ErrorT String (State Int) aborts.
17:56:12 <kpreid> er, no
17:56:47 <kpreid> ErrorT of State preserves
17:56:51 <wli> The first you just get Either String t for the result of a StateT action.
17:56:58 <kpreid> you can see this by imagining State replaced with IO
17:57:05 * EvilTerran thinks about ways of writing a BF interpreter idiomatically
17:57:14 <kpreid> you can't revert IO, but it can go in the ErrorT
17:57:21 <EvilTerran> i'm thinking there'd be something cunning involving MonadCont
17:58:00 <oerjan> EvilTerran: huh? a BF interpreter needs only StateT ... IO, surely?
17:58:05 <kpreid> I once got my monad stack wrong in an interpreter. It turned out that throwing an exception unwound certain side effects.
17:58:21 <wli> The result of an ErrorT String (State Int) can either be Left s for some string or Right (st, x) for the state st and result x.
17:58:43 <EvilTerran> oerjan, i was thinking of the looping
17:58:59 <oerjan> EvilTerran: problem is you sometimes need to skip a loop the first time
17:59:08 <EvilTerran> hm, true
17:59:11 <oerjan> so you need some preparsing nevertheless
17:59:19 <EvilTerran> explicit recursion's easier
17:59:31 <EvilTerran> i guess. doesn't feel idiomatic enough though.
18:00:24 * EvilTerran prefers to write all-pointsfree, fully polymorphised, wholly explicit-recursion-less code :D
18:00:28 <oerjan> EvilTerran: maybe you need some operation that pauses execution until the matching ] ?
18:00:36 <oerjan> that could work
18:00:52 <EvilTerran> instance MonadTrans StopItT where...
18:01:17 <oerjan> @unmtl ErrorT String (State Int)
18:01:17 <lambdabot> err: Unknown MTL(1)
18:01:25 <oerjan> huh?
18:01:30 <chessguy> hm, perhaps parsec would be useful?
18:01:32 <EvilTerran> @help unmtl
18:01:32 <oerjan> @help unmtl
18:01:33 <lambdabot> unroll mtl monads
18:01:33 <lambdabot> unroll mtl monads
18:01:40 <fax> @docs Control.Monad.State
18:01:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
18:02:07 <oerjan> chessguy: i think the idea is _not_ to parse, but somehow define each command to do the right thing when sequenced
18:02:18 <oerjan> iiu EvilTerran correctly
18:02:32 <EvilTerran> chessguy, for BF? that's a bit of a fusion-powered factory-sized steel impact de-huller with laser guides for this particular walnut ;]
18:02:37 <fax> @docs Control.Monad.Error
18:02:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
18:03:04 <oerjan> @unmtl ErrorT String (State Int) a
18:03:04 <lambdabot> Int -> (Either String a, Int)
18:03:07 <oerjan> ah
18:03:16 <EvilTerran> oerjan, indeed. i was thinking mapM_ (...) sourceCode
18:03:29 <cognominal_> is there anything less disgusting than slurpFile to get a file?
18:03:42 <EvilTerran> slurpFile?
18:03:48 <oerjan> cognominal_: er, you mean readFile ?
18:03:56 <oerjan> :t readFile
18:04:02 <lambdabot> FilePath -> IO String
18:04:19 <cognominal_> thx
18:05:20 * oerjan wonders where that slurpFile came from
18:05:41 <LoganCapaldo> does readFile use unsafeInterleaveIO or is that just (h)GetContents?
18:05:50 <oerjan> @src readFile
18:05:51 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
18:06:23 <LoganCapaldo> that answers that question
18:07:07 <cognominal_> @src openFile
18:07:07 <lambdabot> Source not found. Do you think like you type?
18:07:43 <oerjan> @index openFile
18:07:44 <lambdabot> System.IO
18:07:57 <oerjan> @docs System.IO
18:07:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
18:08:19 <oerjan> @. docs index openFile
18:08:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:08:28 <oerjan> huh?
18:08:49 <cognominal_> ho btw, I tried to use GOA with ghci and it cores dump.
18:08:50 <oerjan> @. id index openFile
18:08:59 <cognominal_> looks like a problem with popen
18:09:26 <cognominal_> btw, how one does debug a haskell program?
18:09:48 <sorear> ghci
18:09:59 <sorear> interactive evaluation
18:10:06 <sorear> does this give the right answer?
18:10:12 <sorear> how about this smaller problem
18:10:14 <reffie> ghci kinda sucks for debugging
18:10:22 <sorear> this yet-smaller?
18:10:31 <fax> lol
18:10:37 <fax> I got the monad transformer to work together
18:10:44 <fax> but I composed them the wrong way around
18:10:53 <cognominal_> in this specific case, it is ghci the problem :)
18:11:03 <oerjan> @unmtl ErrorT String (State Int) a
18:11:03 <lambdabot> Int -> (Either String a, Int)
18:11:07 <cognominal_> well GOA interacting with ghci
18:11:16 <fax> This is backwards I think: ErrorT String (State Int)
18:11:19 <fax> from what I watned
18:11:25 <oerjan> @unmtl StateT Int (Either String) a
18:11:26 <lambdabot> err: Unknown MTL(1)
18:11:47 <oerjan> @unmtl StateT Int (Either String)
18:11:48 <lambdabot> err: Unknown MTL(1)
18:11:53 <oerjan> huh?
18:12:11 <oerjan> it doesn't know about Either?
18:12:21 <oerjan> @unmtl StateT Int m a
18:12:22 <lambdabot> Int -> m (a, Int)
18:12:56 <fax> ghci is accepting StateT Int (Either String)
18:13:00 <oerjan> the question is, do you want to throw away the state when you throw an exception
18:13:06 <fax> yes
18:13:17 <fax> if there is an exception, I'm discarding everything
18:13:20 <oerjan> then use the Either version
18:13:32 <fax> which is the opposite of which I just programmed :p
18:15:04 <oerjan> in that case it might also be reasonable to use runStateT inside the catchError, i guess
18:15:20 <oerjan> since the catchError doesn't need the state
18:15:21 <fax> I'm trying that now
18:16:08 <fax> fantastic :D
18:16:18 <fax> thanks for all the help
18:16:49 <fax> I'll paste what I got
18:17:01 <hpaste>  fax pasted "sumLeavesMEr" at http://hpaste.org/2807
18:17:34 <fax> actually forgot to use the state monad in the final example but it should be simple :|
18:18:19 <cognominal_> how do I get the String out of the IO String?
18:18:38 <cognominal_> that's probably a monad 101 :)
18:18:56 <LoganCapaldo> you don't
18:19:16 <LoganCapaldo> you've just reached monad 102 :)
18:19:26 <cognominal_> So there must be a way to use it :)
18:19:31 <LoganCapaldo> indeed
18:19:40 <oerjan> recall that your whole program is an IO action in main
18:19:47 <pjd> cognominal_: IO String represents a "pending" String
18:19:52 <oerjan> so you don't actually need to get out of IO
18:19:54 <pjd> it hasn't arrived yet, so there is nothing to extract
18:19:59 <LoganCapaldo> you use >>= to feed it into anther IO action
18:20:34 <cognominal_> so I suppose I need to lift the said actions into io
18:20:40 <pjd> or apply a pure function to it using fmap/liftM
18:21:18 <oerjan> :t getLine
18:21:21 <lambdabot> IO String
18:21:51 <pjd> conal: you can say for example fmap length to map the IO String to an IO Int
18:21:56 <oerjan> :t do s <- getLine; putStrLn $ "My string was: " + s
18:21:58 <lambdabot>     No instance for (Num [Char])
18:21:58 <lambdabot>       arising from use of `+' at <interactive>:1:28-48
18:22:03 <oerjan> :t do s <- getLine; putStrLn $ "My string was: " ++ s
18:22:05 <lambdabot> IO ()
18:22:05 <cognominal_> :t getContents
18:22:07 <lambdabot> IO String
18:22:14 <pjd> err, s/conal/cognominal_/
18:22:35 <EvilTerran> it's worth noting that, at the ghci prompt, you can do anything you can do in a do block
18:23:18 <EvilTerran> so "ghci> x <- getLine" works, for instance
18:24:33 <pjd> cognominal_: you can think of fmap as composing functions with the IO value
18:24:33 <cognominal_> ok
18:24:33 <pjd> each fmap chains another function to the end
18:24:33 <hpaste>  fax annotated "sumLeavesMEr" with "final solution" at http://hpaste.org/2807#a1
18:24:33 <fax> ok thats finished
18:24:33 <fax> now I can use it for something real ;D
18:24:35 <cognominal_> :t getLine
18:24:35 <conal> pjd: yep
18:24:36 <lambdabot> IO String
18:24:38 <oerjan> fax: btw in this case the WriterT (Sum Int) monad trans could also be used, it does automatic summing
18:24:52 <LoganCapaldo> There's a SUm monad???
18:24:56 <conal> pjd: oh -- misdirected
18:25:00 <oerjan> :t Sum
18:25:01 <fax> oerjan: WriterT (Sum Int) instead of State?
18:25:02 <lambdabot> forall a. a -> Sum a
18:25:04 <pjd> conal: sorry :)
18:25:10 <conal> np
18:25:15 <oerjan> Sum is not a monad
18:25:22 <oerjan> it's a monoid
18:25:33 <conal> and Applicative
18:25:40 <oerjan> Writers take a monoid as their first parameter
18:25:49 <LoganCapaldo> Oh duh
18:25:51 <fax> ohh
18:25:54 <fax> hm thats cool
18:25:54 <LoganCapaldo> of course they do
18:25:57 <LoganCapaldo> mplus
18:26:01 <fax> Do you think I should write a Monoid?
18:26:01 <oerjan> fax: instead of StateT Int
18:26:09 <LoganCapaldo> brilliant!
18:26:11 <conal> oops -- not Applicative
18:26:12 <fax> I want to store some variable bindings in the state?
18:26:15 <oerjan> fax: Sum is already written for you
18:26:15 <EvilTerran> Writer is good - more specific than state
18:26:18 <cognominal_> :t liftM
18:26:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:26:51 <fax> oerjan: I mean this was just a test before I do the real thing
18:26:51 <oerjan> you can use writer because none of your actions actually _look_ at the value you collect
18:26:58 <fax> ah ok I will need to read the thing
18:27:06 <fax> I guess I need state
18:27:28 <cognominal_> :t lift
18:27:30 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
18:27:31 * EvilTerran has been fiddling with the idea of having MonadSource and MonadDrain classes, where Drain would be Writer-esque, and Source its... opposite, i guess
18:27:36 <pjd> cognominal_: liftM is basically the same as fmap
18:27:49 <oerjan> LoganCapaldo: you mean mappend
18:27:51 <cognominal_> :t fmap
18:27:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:28:10 <LoganCapaldo> oerjan: I suppose I do
18:28:35 <pjd> cognominal_: liftM is only there because Monad isn't actually a subclass of Functor
18:28:39 <LoganCapaldo> Mm
18:28:45 <cognominal_> I have [(p,n) | (p,n) <- zip idx $ map read $ lines board >>= words, n>0]
18:28:58 <cognominal_> this fails because board is an IO String
18:28:59 <LoganCapaldo> WriterT (Sum a) is cool
18:29:04 <EvilTerran> everything should be called (.)!
18:29:08 <LoganCapaldo> @type runWriter
18:29:08 <cognominal_> how could I fix it?
18:29:10 <lambdabot> forall w a. Writer w a -> (a, w)
18:29:18 <oerjan> EvilTerran: yep, i've thought similar thoughts, MonadDrain is useful for parsing
18:29:34 <cognominal_> *Main> :t idx
18:29:34 <cognominal_> idx :: [(Int, Int)]
18:30:00 <LoganCapaldo> @type mzero
18:30:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
18:30:11 <cognominal_> I am playing with the sudoku program within ghci
18:30:14 <LoganCapaldo> @src Monoid
18:30:15 <lambdabot> class Monoid a where
18:30:15 <lambdabot>     mempty  :: a
18:30:15 <lambdabot>     mappend :: a -> a -> a
18:30:15 <lambdabot>     mconcat :: [a] -> a
18:30:22 <EvilTerran> oerjan, quite. i felt they'd capture the idea of coroutines quite nicely.
18:31:11 <EvilTerran> well, processing of streams, i guess.
18:31:33 <oerjan> cognominal_: do b <- board; [(p,n) | (p,n) <- zip idx $ map read $ lines b >>= words, n>0]
18:31:36 <EvilTerran> (being a major application of coroutines)
18:31:42 <oerjan> er
18:31:49 <oerjan> cognominal_: do b <- board; return [(p,n) | (p,n) <- zip idx $ map read $ lines b >>= words, n>0]
18:32:22 <oerjan> i.e. put it in an IO action that extracts it first, inside the action
18:32:25 <EvilTerran> .oO(what's a ffeemug, and how do you take its dual?)
18:32:46 <EvilTerran> foreign function... enterprise edition... er, mug?
18:33:00 <cognominal_> to there is a way to extract it after all :)
18:33:04 <pjd> cognominal_: that's the same as saying board >>= \b -> [... b ...]
18:33:35 <oerjan> EvilTerran: now if you could actually pipe a MonadSource to a MonadDrain...
18:33:38 <pjd> you're not actually extracting it;  do is binding those functions to it
18:34:19 <EvilTerran> my intent was that you could, depending on the instance
18:34:22 <oerjan> cognominal_: you are extracting it locally, but still inside a larger IO action
18:34:38 <oerjan> intuitively speaking
18:34:42 <pjd> (err, the same as  board >>= \b -> return [... b ...], i mean)
18:34:50 <EvilTerran> although any MonadWriter could provide a MonadDrain, too, and that wouldn't pipe out, only in
18:34:59 <coffeemug> EvilTerran: hehe
18:35:08 <cognominal_> so the do or the ghci is just sequencing the actions
18:35:22 <EvilTerran> coffeemug, =]
18:36:07 <pjd> (which is the same as forM board $ \b -> [... b ...])
18:36:50 <cognominal_> :t forM
18:36:51 <pjd> cognominal_: strictly speaking, the IO monad is sequencing the actions
18:36:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
18:37:08 <pjd> forM = flip liftM
18:37:18 <Saizan> pjd: eh?
18:37:22 <dolio> No, flip mapM
18:37:23 <Saizan> ?src forM
18:37:24 <lambdabot> forM = flip mapM
18:37:24 <pjd> oh, oops
18:37:54 <hpaste>  oerjan annotated "sumLeavesMEr" with "just to demonstrate (untested)" at http://hpaste.org/2807#a2
18:38:24 <fax> quite neat
18:38:28 <fax> @docs Sum
18:38:28 <lambdabot> Sum not available
18:38:32 <coffeemug> IO monad is really a CPS transformer
18:38:36 <fax> hm what else Moniods are there?
18:38:42 <cognominal_> I like the notation >>=  it builds on the intuition of Unx pipe but is typed
18:38:45 <EvilTerran> @instances Monoid
18:38:47 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
18:38:52 <fax> cool
18:39:11 <pjd> damn, i could have swore there was a flip liftM
18:39:12 <LoganCapaldo> what's Ordering's mepty and mappened?
18:39:20 <pjd> oh well
18:39:27 <cognominal_> so like in Unix the computation in the left side of the "pipe" is "concurrent to the computation in the right side?
18:39:42 <Saizan> > mempty :: Ordering
18:39:43 <lambdabot>  EQ
18:39:47 <oerjan> :t <$$>
18:39:50 <lambdabot> parse error on input `<$$>'
18:39:55 <oerjan> :t (<$$>)
18:39:57 <lambdabot> Not in scope: `<$$>'
18:40:02 <fax> cognominal_: pretty much yeah
18:40:08 <Saizan> > LT `mappend` GT
18:40:09 <lambdabot>  LT
18:40:10 <pjd> oerjan: there's only <**>, i think
18:40:22 <cognominal_> in fact the right side "drives" the left side. This is the lazyness in haskell
18:40:50 <pjd> either side could actually be driving
18:40:55 <oerjan> pjd: right, that's what i was remembering too
18:41:02 <cognominal_> the left side calculates a type value when the right needs it
18:41:24 <LoganCapaldo> > [ (a, b, a `mappend` b) | a <- [LT ..] , b <- [LT ..] ]
18:41:25 <cognominal_> probably for complex monads the pipe is not unidirectional?
18:41:26 <lambdabot>  [(LT,LT,LT),(LT,EQ,LT),(LT,GT,LT),(EQ,LT,LT),(EQ,EQ,EQ),(EQ,GT,GT),(GT,LT,GT...
18:41:55 <pjd> cognominal_: right;  there might not be any pipe at all
18:42:05 <pjd> sequencing monads like IO are just one kind of monad
18:42:28 <oerjan> cognominal_: oops, no, in IO >>= is left to right
18:42:47 <oerjan> there are other monads thought which really are lazy
18:42:55 <oerjan> *though
18:43:07 <dolio> pjd: If you follow the naming convention, 'flip liftM' should be called 'for' I guess. :)
18:43:27 <pjd> dolio: that would be nice
18:44:02 <LoganCapaldo> @src Ordering mappend
18:44:02 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:44:02 * EvilTerran wonders if that would make grammatical sense
18:44:48 <cognominal_> @instances Monad
18:44:50 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:44:51 <EvilTerran> getContents `for` lines -- odd
18:44:58 <EvilTerran> for getContents lines -- i guess this works
18:45:00 <oerjan> instance Monoid Ordering where mempty         = EQ LT `mappend` _ = LT EQ `mappend` y = y GT `mappend` _ = GT
18:45:32 <cognominal_> ((->) r), that means a function is a monad? what is the "r"?
18:45:42 <LoganCapaldo> it's reader!
18:46:00 <oerjan> cognominal_: the argument of the function
18:46:30 <cognominal_> the returned value does not participate in the type?
18:46:32 <pjd> cognominal_: that would be (r ->), as a section
18:46:35 <LoganCapaldo> it's sorta like (r ->), if that were valid syntax
18:46:54 <oerjan> cognominal_: not the type of the monad
18:47:09 <oerjan> you add the returned value to get a monad action
18:47:13 <Saizan> cognominal_: m = (r ->) so (r -> a) == m a etc..
18:48:49 <EvilTerran> return = const; (f >>= k) r = k (f r) r
18:48:52 <EvilTerran> fmap = (.)
18:49:21 <cognominal_> with haskell I find everything weird until I see the profound consistency
18:49:27 <pjd> cognominal_: so m a (or f a) for functions means "function returning a"
18:49:50 <LoganCapaldo> cognominal_: I just figured this out the other day http://hpaste.org/2769
18:49:56 <EvilTerran> it so happens that this monad can be used to deal with environments.
18:50:01 <LoganCapaldo> good times
18:50:09 <pjd> and fmap :: (a -> b) -> f a -> f b would mean "map (a -> b) to a function returning a, to get a function returning b"
18:50:16 <oerjan> @check \l -> mconcat l == case dropWhile (== EQ) l of [] -> EQ ; x : _ -> x
18:50:22 <lambdabot>  OK, passed 500 tests.
18:51:02 <EvilTerran> heh, "equals equals"
18:51:05 <pjd> i.e.  (a -> b) -> (r -> a) -> (r -> b)
18:51:13 <pjd> i.e. (.) :)
18:51:16 <EvilTerran> @djinn (a -> b) -> (r -> a) -> (r -> b)
18:51:16 <lambdabot> f a b c = a (b c)
18:51:22 <EvilTerran> @. pl djinn (a -> b) -> (r -> a) -> (r -> b)
18:51:23 <lambdabot> f = (.)
18:51:31 <shteou> Hello team.
18:52:01 <pjd> cognominal_: figuring out join and >>= for (r ->) is fun
18:52:12 <cgranade> Quick newbie question here: how to I convert a Fractional to a Floating? I know that there's a precision loss, but I want to take the square root of something.
18:52:25 <oerjan> :t realToFrac
18:52:27 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
18:52:34 <cgranade> I found plenty of advice online on how to go the other way.
18:52:42 <oerjan> oh wait
18:52:55 <Saizan> ?instances Fractional
18:52:56 <lambdabot> Double, Float
18:53:10 <oerjan> @instances-importing Data.Complex Fractional
18:53:12 <lambdabot> Complex a, Double, Float
18:53:20 <oerjan> no can do
18:53:34 <oerjan> fractionals are not necessarily real
18:53:37 <cgranade> oerjan: How does sqrt from the Prelude to it?
18:53:41 <cgranade> Ah. I see.
18:53:45 <Saizan> uhm
18:53:54 <dolio> @type fromRational
18:53:56 <lambdabot> forall a. (Fractional a) => Rational -> a
18:54:03 <Saizan> ?src Floating
18:54:03 <lambdabot> class  (Fractional a) => Floating a  where
18:54:03 <lambdabot>     pi                                                      :: a
18:54:03 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
18:54:03 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
18:54:03 <lambdabot>     (**), logBase                                           :: a -> a -> a
18:54:27 <Saizan> a Floating IS a Fractional
18:54:33 <oerjan> @src RealFrac
18:54:34 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
18:54:34 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
18:54:34 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
18:54:57 <cgranade> OK. Now I guess I'm a bit more confused.
18:55:18 <oerjan> you might possibly be able to convert a RealFrac
18:55:19 <cgranade> One moment whilst I use a pastebin.
18:55:29 <cognominal_> @index  ((->) r)
18:55:29 <lambdabot> bzzt
18:55:35 <Saizan> no, i was caonfused :) since a Floating is a Fractional but you need to go the other way
18:55:45 <hpaste>  cgranade pasted "(no title)" at http://hpaste.org/2808
18:56:38 <oerjan> oh, Real
18:56:50 <cgranade> That function fails to compile with the following errors.
18:57:11 <hpaste>  cgranade pasted "Error from previous code." at http://hpaste.org/2809
18:57:47 <sorear> cgranade: hint: use annotate rather than making new pastes
18:57:49 <oerjan> cgranade: Floating includes its own sqrt
18:57:51 <Saizan> cgranade: what's the type of var?
18:58:09 <cgranade> sorear: Sorry. I'll do that from now on.
18:58:31 <sorear> what did I do wrong to elicit a sorry? :/
18:58:42 <oerjan> cgranade: if you change your type to Real instead of Fractional, you can use realToFrac
18:58:43 <hpaste>  cgranade annotated "(no title)" with "Problem  functions." at http://hpaste.org/2808#a1
18:58:51 <cgranade> Pasted the whole file.
18:59:10 <cgranade> sorear: Flooded with new pastebin posts/
19:01:21 <cgranade> oerjan: Let me try applying that.
19:03:04 <oerjan> cgranade: also, the type Float is rarely useful, you might mean either the Floating class or Double?
19:03:12 <cgranade> OK.
19:03:49 <Saizan> so there's no method to get the square root of a rational? uhm, well, it makes sense
19:04:05 <cgranade> oerjan: Changing everything to Real causes some problems with the division operator used in mean.
19:04:23 <oerjan> cgranade: yep, you can only do it some places
19:04:42 <oerjan> mean's type was fine as far as i can see
19:05:36 <oerjan> var doesn't need changing either
19:05:41 <cgranade> oerjan: OK. So I need to change std to require Real?
19:06:45 <oerjan> cgranade: the simplest would be to use RealFloat, then you need no conversion
19:06:53 <cgranade> Hm.
19:06:54 <cgranade> OK.
19:07:47 <oerjan> (then you can also change Float to a
19:07:49 <cgranade> oerjan: Thanks! That did it.
19:07:49 <oerjan> )
19:07:53 <cgranade> oerjan++
19:08:03 <oerjan> :)
19:08:33 <Saizan> ?src Real
19:08:33 <lambdabot> class  (Num a, Ord a) => Real a  where
19:08:33 <lambdabot>     toRational      ::  a -> Rational
19:08:51 <Saizan> i wonder why it's called Real
19:09:05 <oerjan> actually - i think just Floating would do
19:09:45 <oerjan> although your function may not make sense for non-real Floatings
19:12:02 <cgranade> Thank you all for this help.
19:12:08 <wli> Lazy infinite continued fraction representations of reals don't fit well into that category.
19:12:16 <cgranade> I'm so used to imperitive programing that this has been difficult for me.
19:13:21 <LoganCapaldo> @sparsecheck (\x -> (== 1) x == True) :: Integer -> Bool
19:13:22 <lambdabot> Unknown command, try @list
19:13:33 <LoganCapaldo> what, no sparsecheck? :)
19:13:56 <Saizan> ?pl\x -> (== 1) x == True
19:13:56 <lambdabot> (line 1, column 1):
19:13:56 <lambdabot> unexpected "-"
19:13:56 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
19:14:00 <Saizan> ?pl \x -> (== 1) x == True
19:14:00 <lambdabot> (True ==) . (1 ==)
19:14:09 <Saizan> aww, not smart enough
19:15:12 <dolio> if (b == True) == True then foo else bar
19:16:33 <oerjan> LoganCapaldo: not the quickest to take up new developments, lambdabot
19:16:40 <wli> I think the STV counting methods can be dealt with by representing Senatorial rules as a flow network.
19:22:43 <wli> Preflow-push methods can probably handle non-transferrable votes better.
19:43:15 <fax> hey there is No instance for (Error ())
19:43:23 <fax> but there is an instance for Error String
19:43:38 <fax> @instances Error
19:43:39 <lambdabot> IOError, [Char]
19:43:49 <oerjan> it's not hard to write though
19:43:52 <fax> should I make a new instance?
19:44:03 <fax> @src IOError
19:44:03 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:44:37 <oerjan> you wouldn't be the first to do so
19:45:00 <oerjan> @index IOError
19:45:01 <lambdabot> System.IO.Error, Prelude
19:46:06 <oerjan> @instances-importing Control.Monad.Error MonadError
19:46:08 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
19:49:02 <fax> @src throwError
19:49:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:49:19 <oerjan> @src MonadError
19:49:20 <lambdabot> class (Monad m) => MonadError e m | m -> e where
19:49:20 <lambdabot>     throwError :: e -> m a
19:49:20 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
19:55:24 <gregor> any HAppSers here?
19:55:55 <sorear> at least 4
19:56:08 <sorear> but that's purely coincidence
19:56:34 <sorear> we don't use #haskell for libraries that have their own channels
19:56:41 <gregor> oh
19:56:56 <kfish> same goes for the haskellers on #happs, purely coincidence
19:57:55 <kfish> damn ye random universe of discourse!
19:57:56 <gregor> tx! I'll go there
19:58:41 <fax> @where Prelude
19:58:41 <lambdabot> I know nothing about prelude.
20:00:13 <sorear> @source Prelude
20:00:13 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
20:00:16 <sorear> @docs Prelude
20:00:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
20:00:26 <fax> ah thanks
20:00:29 <oerjan> @where standard-prelude
20:00:30 <lambdabot> I know nothing about standard-prelude.
20:00:36 <sorear> httphttp://haskell.org/onlinereport/standard-prelude.html
20:00:36 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
20:01:00 <oerjan> lambdabot actually decoded that? :D
20:01:17 <oerjan> @docs standard-prelude
20:01:17 <lambdabot> standard-prelude not available
20:01:35 <oerjan> @where+ prelude http://haskell.org/onlinereport/standard-prelude.html
20:01:36 <lambdabot> Done.
20:01:54 <fax> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
20:01:55 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
20:01:55 <lambdabot> Control.Parallel.Strategies.parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
20:02:15 <oerjan> fax: also liftM2
20:05:44 <fax> :D
20:14:11 <fax> when you write, f (Thing x) (Thing y) = op x y, and f (Other x) (Other y) = op x y
20:14:29 <fax> is there any way to combine them like f (Thing|Other x) (Thing|Other y) = op x y
20:14:58 <kpreid> No.
20:15:36 <oerjan> hm...
20:16:01 <hpaste>  fax pasted "unification" at http://hpaste.org/2810
20:16:03 <oerjan> i was thinking if you gave them identical field names
20:16:29 <fax> can I ask instead.. just if you have any advice on this bit of code?
20:16:33 <fax> or is it ok?
20:16:37 <oerjan> but i don't think you can actually match on just field name, not constructor
20:17:10 <fax> yeah, on second thoughts I think Thing|Other would probably be quite awkward to read
20:17:47 <oerjan> fax: you do not need to repeat the matches when giving a new guard on the same ones
20:18:26 <fax> oh I should write, unifyM   (PrologInteger f)   (PrologInteger f) instead of | f == g?
20:18:41 <oerjan> no, that's not what i mean
20:19:14 <fax> What do you mean?
20:19:19 <oerjan> i mean: unifyM x@(PrologInteger f) y@(PrologVariable g) | f /= g = throwError "fail"
20:19:29 <fax> oh wow
20:19:32 <oerjan> | f == g = return ()
20:19:32 <fax> that slipped past me
20:19:47 <fax> cool :D
20:19:50 <oerjan> | otherwise = attemptBinding x y
20:20:25 <oerjan> (actually isn't the last one redundant?)
20:20:35 <fax> yeah but I see what you mean
20:20:39 <fax> It's a big improvement
20:21:22 <oerjan> oh, i misread that a bit
20:21:37 <oerjan> thought the first three were all the same
20:22:34 <oerjan> actually the first can be combined into = guard (f == g)
20:22:39 <oerjan> *first two
20:22:49 <oerjan> without a guard
20:23:06 <fax> :t guard
20:23:08 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:24:10 <oerjan> although that may make it harder to give more precise error messages
20:24:39 <fax> Is it possible to change unifyM (PrologCompound
20:24:43 <fax> the last bit
20:25:01 <hpaste>  fax annotated "unification" with "like this?" at http://hpaste.org/2810#a1
20:25:25 <fax> I mena does it do the exact same thing as before?
20:26:01 <oerjan> it should
20:26:12 <oerjan> and you can add the last one as well, with an otherwise
20:26:22 <fax> ohh yeah
20:26:24 <fax> thanks :D
20:28:56 <oerjan> aren't a lot of those cases the same, comparing the ASTs literally?  you could add deriving Eq to it
20:29:48 <oerjan> and then you could just compare them directly at the end, after the special cases
20:30:19 <fax> that's a great idea
20:30:35 <fax> the code will be a lot shorter
20:31:23 <oerjan> assuming your AST contains only comparable things
20:32:02 <oerjan> and no cyclic structures
20:33:21 <hpaste>  fax annotated "unification" with "huge improvement" at http://hpaste.org/2810#a2
20:33:41 <fax> excellent :
20:33:51 <oerjan> you probably want that case at the end
20:33:55 <fax> oh I need to add fail on the end yeah
20:34:41 <oerjan> also, put the Compound one first
20:35:00 <oerjan> otherwise you will be duplicating work in the equality comparison
20:35:39 <oerjan> i assume that's the only one that is deeply nested
20:35:49 <fax> yeah
20:36:30 <oerjan> actually i thought you could get rid of most of those throwError "fail" cases that way too
20:38:12 <hpaste>  fax annotated "unification" with "PrologCompound first" at http://hpaste.org/2810#a3
20:38:25 <oerjan> hm, and you don't need to have one case for each match with a variable second match?
20:38:39 <fax> oh my god!
20:38:41 <fax> You're right :D
20:38:46 <fax> I can put them in all the same thing
20:40:40 <oerjan> and now all the throwError cases except the catchall one are redundant.  this is getting a lot shorter.
20:41:39 <hpaste>  fax annotated "unification" with "tiny" at http://hpaste.org/2810#a4
20:41:46 <fax> that's insane :D
20:42:12 <oerjan> yoohoo :)
20:44:22 <oerjan> seems to be time for:
20:44:28 <oerjan> @quote two.lines.each
20:44:29 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
20:44:35 <oerjan> whoops
20:44:41 <oerjan> @quote two.lines
20:44:42 <lambdabot> ddarius says: "Oh no! My code is more than two lines!  There must be a better way!"
20:44:42 <sorear> @quote 2.lines
20:44:42 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
20:45:02 <fax> haha
20:45:32 <fax> I'm quite amazed
20:46:41 <oerjan> oh, just one more thing
20:47:08 <oerjan> add an | otherwise = throwError "fail" to the compound case
20:47:47 <fax> Why?
20:47:49 <oerjan> that way you skip the == comparison
20:47:54 <fax> ahh
20:51:01 <oerjan> afk
20:51:08 <opqdonut> asdfg
20:56:44 <Mr_Awesome> is there any way to turn off key repeat in HGL?
20:57:09 <fax> Mr_Awesome: Is that using GLUT?
20:57:36 <Mr_Awesome> no, HGL is a windowing system separate from glut
20:57:59 <fax> oh sorry
21:07:57 <Mr_Awesome> hmm, apparently im forced to just disable key repeat in X
21:11:20 <FMota> > 1 / 98.64
21:11:21 <lambdabot>  1.013787510137875e-2
21:11:24 <FMota> :o
21:11:27 <FMota> wow.
21:28:40 <Mr_Awesome> is there a modulo operator for floats in haskell?
21:29:04 <dolio> Not in the standard libraries.
21:30:16 <oerjan> > properFraction 1.3 -- modulo 1 only
21:30:21 <lambdabot>  (1,0.30000000000000004)
21:33:10 <lament> Mr_Awesome: it's the most bizarre omission i have encountered in the haskell library so far.
21:33:25 <Mr_Awesome> i agree. this is most inconvenient
21:35:26 <FMota> is  there a continued  fraction function?
21:35:34 <Pseudonym> No, but there are libraries.
21:35:39 <Mr_Awesome> ugh, properFraction gives remainder, not modulo
21:36:14 <oerjan> what's the difference? (ignoring sign)
21:37:24 <FMota> > let cf 0 = []; cf n = floor n : cf (n - floor n) in cf 1.5
21:37:28 <lambdabot>  Add a type signature
21:37:31 <FMota> :/
21:37:39 <FMota> > floor 1.5
21:37:44 <lambdabot>  1
21:37:52 <Pseudonym> http://hfl.cvs.sourceforge.net/haskell-libs/libs/exactreal/
21:37:54 <lambdabot> Title: SourceForge.net Repository - [haskell-libs] Index of /libs/exactreal
21:38:09 <oerjan> > unfoldr (Just . second recip . properFraction) (exp 1)
21:38:10 <lambdabot>  [2,1,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1,11,3,2,1,3,1,73,6,1,1,1,1,1,2,31,...
21:38:18 <FMota> > let cf :: Float -> List Int; cf 0 = []; cf n = floor n : cf (n - floor n) in cf 1.5
21:38:19 <lambdabot>   Not in scope: type constructor or class `List'
21:38:34 <FMota> oops
21:38:42 <FMota> mixing languages :/
21:38:49 <FMota> > let cf :: Float -> [Int]; cf 0 = []; cf n = floor n : cf (n - floor n) in cf 1.5
21:38:50 <lambdabot>   add an instance declaration for (Integral Float)
21:39:04 <FMota> huh? :/
21:39:30 <oerjan> FMota: you are forgetting 1 /
21:39:37 <FMota> oh
21:39:43 <FMota> yes
21:39:59 <FMota> > let cf :: Float -> List Int; cf 0.0 = []; cf n = floor n : cf (1.0 / (n - floor n)) in cf 1.5
21:40:00 <lambdabot>   Not in scope: type constructor or class `List'
21:40:07 <FMota> d'oh
21:40:18 <FMota> > let cf :: Float -> [Int]; cf 0.0 = []; cf n = floor n : cf (1.0 / (n - floor n)) in cf 1.5
21:40:19 <lambdabot>   add an instance declaration for (Integral Float)
21:40:28 <FMota> okay, so... what's up with that?
21:41:18 <oerjan> :t floor
21:41:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:41:30 <oerjan> :t truncate
21:41:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:41:36 <oerjan> er
21:42:02 <FMota> > let cf :: Float -> [Int]; cf 0.0 = []; cf n = floor n : cf (1.0 / (n - (floor n :: Int))) in cf (1.5 :: Float)
21:42:03 <lambdabot>  Couldn't match expected type `Float' against inferred type `Int'
21:42:14 <oerjan> fromIntegral
21:42:19 <FMota> ok
21:42:36 <FMota> > let cf :: Float -> [Int]; cf 0.0 = []; cf n = floor n : cf (1.0 / fromIntegral (n - floor n)) in cf 1.5
21:42:36 <lambdabot>   add an instance declaration for (Integral Float)
21:42:43 <oerjan> also, properFraction does most of what you want
21:42:50 <FMota> > let cf :: Float -> [Int]; cf 0.0 = []; cf n = floor n : cf (1.0 / (n - fromIntegral (floor n))) in cf 1.5
21:42:51 <lambdabot>  [1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:43:08 <FMota> oh well
21:43:20 <oerjan> > unfoldr (Just . second recip . properFraction) 1.5
21:43:22 <lambdabot>  [1,2,17976931348623159077293051907890247336179769789423065727343008115773267...
21:43:28 <FMota> :o
21:43:31 <oerjan> whoops :)
21:43:39 <FMota> > let cf :: Float -> [Int]; cf 0.0 = []; cf n = floor n : cf (1.0 / (n - fromIntegral (floor n))) in cf (exp 1)
21:43:41 <lambdabot>  [2,1,2,1,1,4,1,1,6,1,1,23,13,3,3,2,1,1,1,1,1,1,1,559,3,5,1,3,3,11,9,22,2,1,1...
21:44:06 <oerjan> > floor (1/0)
21:44:07 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:44:11 <oerjan> thought so
21:44:30 <fax> :O
21:44:40 <fax> What is going on
21:44:42 <oerjan> came up earlier
21:44:46 <fax> > 1/0
21:44:47 <lambdabot>  Infinity
21:44:49 <fax> :t floor
21:44:51 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:45:00 <sioraiocht_> :t ceil
21:45:01 <lambdabot> Not in scope: `ceil'
21:45:05 <sioraiocht_> :t ceiling
21:45:07 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:45:07 <dolio> decodeFloat (or something related) doesn't take the special IEEE values into account.
21:45:16 <oerjan> it's converting to the largest finite Double, approximately
21:45:17 <sioraiocht_> > ceiling (1/0)
21:45:19 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:45:24 <dibblego> on a whiteboard, how would you annotate a function as total?
21:45:24 <FMota> > let phi :: Int -> Float; phi 0 = 1; phi n = 1 + 1 / n; cf :: Float -> [Int]; cf 0.0 = []; cf n = floor n : cf (1.0 / (n - fromIntegral (floor n))) in cf (phi 100)
21:45:25 <lambdabot>  Couldn't match expected type `Float' against inferred type `Int'
21:45:38 <oerjan> dibblego: by default
21:45:50 <oerjan> in mathematics, at any rate
21:45:52 <dolio> > floor (0/0)
21:45:53 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
21:46:01 <FMota> > let phi :: Int -> Float; phi 0 = 1; phi n = 1 + 1 / (phi $ n - 1) ; cf :: Float -> [Int]; cf 0.0 = []; cf n = floor n : cf (1.0 / (n - fromIntegral (floor n))) in cf (phi 100)
21:46:01 <oerjan> O_o
21:46:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:46:09 <FMota> :p
21:46:12 <dibblego> oerjan, so I would just write "f(x) [exists]"?
21:46:33 <FMota> > let phi :: Int -> Float; phi 0 = 1; phi n = 1 + 1 / (phi $ n - 1) ; cf :: Float -> [Int]; cf 0.0 = []; cf n = floor n : cf (1.0 / (n - fromIntegral (floor n))) in phi 100
21:46:35 <lambdabot>  1.618034
21:46:59 <oerjan> dibblego: what is this context? compsci or math?
21:47:05 <FMota> > let phi :: Int -> Float; phi 0 = 1; phi n = 1 + 1 / (phi $ n - 1) in phi 1000
21:47:07 <lambdabot>  1.618034
21:47:11 <dibblego> oerjan, just explain total and partial functions to a colleague
21:47:17 <dibblego> oerjan, and the concept of bottom
21:48:03 <oerjan> i guess in that case it is total in any case, as a mathematical function, it's just some values are bottom...
21:48:08 <FMota> is there a  concept of top as well? If so, I'm in!
21:48:13 <FMota> ;) jk. Badly.
21:48:42 <oerjan> the Object type, in some systems
21:48:47 <dibblego> oerjan, I wrote something like \exists x. x \in domain | f(x) -> \bottom to indicate a partial function
21:49:34 <dibblego> but then I was stuck for a total function
21:49:39 <oerjan> you usually denote a function's domain and codomain by writing f : A -> B
21:49:46 <dibblego> yes I wrote that
21:49:53 <dibblego> well, f : D -> C
21:50:01 <dibblego> then s/domain/D
21:50:47 <oerjan> i guess you should ask someone who knows more about denotational semantics and notation
21:50:50 <Korollary> dibblego, bottom is a semantic concept.
21:51:03 <oerjan> i mostly know about mathematical functions
21:51:47 <dibblego> ok cheers
21:52:14 <Korollary> The haskell wikibook has a nice section on denotational semantics.
21:54:54 <tehgeekmeister> ?src foldM
21:54:55 <lambdabot> foldM _ a []     = return a
21:54:55 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
21:55:47 <dibblego> ?seen fax
21:55:48 <lambdabot> fax is in #haskell. I last heard fax speak 10m 58s ago.
21:55:57 <fax> :o
21:56:28 <nornagon> Hmm, this might be the wrong channel to ask, but I've seen a lot of shiny latex papers from Haskellers, so: How can I customise the layout of a latex document? I can use \documentclass, but I'm not sure where to go from there.
21:56:54 <nornagon> I've looked at DocBook for doing publishing-type stuff, but it looks fairly scary to customise too
21:57:02 <nornagon> DSSSL and XSL and stuff
21:57:33 * oerjan points at #latex
21:57:57 <oerjan> also, http://www.tex.ac.uk/cgi-bin/texfaq2html from their topic
21:57:59 <lambdabot> Title: TeX Frequently Asked Questions
21:58:18 <nornagon> thanks, i'll check out those :)
21:59:07 <goalieca> all real scientists use latex.. don't want anyone getting pregnat
22:00:31 <tehgeekmeister> anyone care to help explain why, when p becomes a list of Parsed values, rather than a single Parsed, the calls to parseHexDigit and it's counterparts (in the definition of parse) work at all.
22:00:31 <tehgeekmeister> http://www.haskell.org/all_about_monads/html/listmonad.html
22:00:32 <lambdabot> Title: The List monad
22:00:42 <tehgeekmeister> (last example on that page.)
22:01:45 <tehgeekmeister> i'm guessing it has to do with foldM, but i can't see how yet.
22:03:09 <Cale> tehgeekmeister: which calls to parseHexDigit?
22:03:17 <Cale> parse p c = (parseHexDigit p c) `mplus` (parseDigit p c) `mplus` (parseWord p c)
22:03:19 <Cale> those?
22:03:22 <tehgeekmeister> yep.
22:03:26 <Cale> `mplus`
22:03:29 <tehgeekmeister> and parseDigit
22:03:32 <tehgeekmeister> and parseWord
22:03:40 <Cale> > [1,2,3] `mplus` [4,5]
22:03:42 <lambdabot>  [1,2,3,4,5]
22:03:55 <nornagon> @src [] mplus
22:03:55 <lambdabot> mplus = (++)
22:04:01 <nornagon> @src [] mzero
22:04:01 <lambdabot> mzero = []
22:04:07 <nornagon> @instances MonadPlus
22:04:08 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
22:04:17 <nornagon> @instances Monoid
22:04:18 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
22:04:43 <Cale> Does that make sense now? :)
22:04:53 <Cale> It's concatenating the lists of results it gets
22:04:58 <nornagon> @src MonadPlus
22:04:59 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:05:41 <nornagon> MonadPlus is a class that describes a pattern in which you have a "zero" element and a way to combine two elements to form a third element
22:07:09 <tehgeekmeister> i know it's concating them
22:07:14 <tehgeekmeister> that's not the problem
22:07:20 <tehgeekmeister> just, after it's concatted them
22:07:47 <tehgeekmeister> the next call to parse may be have a p of type [Parsed]
22:07:50 <tehgeekmeister> at least as i understand it
22:07:59 <Cale> :t foldM
22:08:01 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:08:04 <tehgeekmeister> which doesn't work, it's not going to work with the type constraints
22:08:24 <Cale> So foldM is being passed parse :: Parsed -> Char -> [Parsed]
22:08:36 <oerjan> parse gets applied to the elements of the list concatenated from the last step
22:08:39 <Cale> so a = Parsed, b = Char, and m a = [Parsed]
22:10:36 <tehgeekmeister> hmm.
22:10:41 <tehgeekmeister> i think i'm starting to get it.
22:10:49 <tehgeekmeister> ?src foldM
22:10:49 <lambdabot> foldM _ a []     = return a
22:10:49 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
22:10:57 <tehgeekmeister> the \fax bit is what's confusing me, really
22:11:00 * fax growls
22:11:08 <tehgeekmeister> i know that's a lambda
22:11:21 <fax> (\fax -> foldM f fax xs) is just a 1 arg function taking the vaf fax..
22:11:23 <fax> var*
22:11:37 <tehgeekmeister> understood
22:11:39 <oerjan> the fax variable is an element of the list f a x
22:11:44 <oerjan> in the [] case
22:12:06 <tehgeekmeister> OH!
22:12:17 * tehgeekmeister has reached monadic enlightenment
22:12:22 <tehgeekmeister> well, at least the first step
22:12:40 <tehgeekmeister> that's really cool.
22:12:46 <tehgeekmeister> i like foldM now.
22:12:47 <Cale> > foldM (\x y -> [x+y]) 0 [1,1,1]
22:12:51 <lambdabot>  [3]
22:12:55 <Cale> > foldM (\x y -> [x+y,x-y]) 0 [1,1,1]
22:12:56 <lambdabot>  [3,1,1,-1,1,-1,-1,-3]
22:13:50 <Cale> > foldM (\x y -> [y:x,y:y:x]) [] [1,2,3]
22:13:52 <lambdabot>  [[3,2,1],[3,3,2,1],[3,2,2,1],[3,3,2,2,1],[3,2,1,1],[3,3,2,1,1],[3,2,2,1,1],[...
22:14:05 <dibblego> any ocaml users around here, want to translate some code to Haskell for me, so I can understand it, so I can translate it to Scala?
22:14:22 <Cale> It's like a left fold where you can give multiple options for what happens on each step, and the results are collected.
22:14:38 <dibblego> trying to help this guy in #scala, but we have no common lingo
22:14:54 <dibblego> looks like he's writing the Maybe monad to me
22:15:41 <tehgeekmeister> thanks for the help, everyone.
22:17:09 <coffeemug> hmm
22:17:11 * oerjan vaguely recalls that Maybe is option in Ocaml
22:17:22 <dibblego> oerjan, yeah, we're going through that :)
22:17:27 <coffeemug> I can't seem to find an open source database that implements versioning
22:17:33 <coffeemug> there should be one, though :)
22:18:19 <oerjan> is it short?
22:18:24 <Mr_Awesome> if i had a nickel for every time ive written Some instead of Just and None instead of Nothing
22:18:38 <dibblego> Mr_Awesome, same (from using Scala)
22:32:24 <tuxplorer> is there a function in any haskell library to compute the md5sum of a string?
22:32:57 <dolio> @hackage Crypto
22:32:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto
22:34:02 <tuxplorer> dolio: Thanks
22:38:07 <hpaste>  ivanm pasted "Trying out STM-based concurrency" at http://hpaste.org/2811
22:41:04 <ivanm> anyone got any ideas what I'm doing wrong in my hpaste-d code?
22:41:24 <sjanssen> ivanm: missing semicolon, I think
22:41:59 <ivanm> sjanssen: where?
22:42:19 <tehgeekmeister> is there haskell support for vim/textmate?
22:42:32 <hpaste>  sjanssen annotated "Trying out STM-based concurrency" with "this parses, at least" at http://hpaste.org/2811#a1
22:42:50 <tuxplorer> tehgeekmeister: yes I know there is support for vim. Not sure about textmate
22:43:00 <tehgeekmeister> hokay.
22:43:40 <sjanssen> ivanm: I'm not sure exactly, those extra braces and parens were obscuring things
22:44:16 <ivanm> well, I put them in trying to work out what was wrong :s
22:47:44 <tuxplorer> In ghci I can load packages using the :set -package <pkg name> command. how to load a package inside a program? If I import a module in any package, does ghc take care of loading the package itself?
22:47:54 <ivanm> OK, the problem ended up being that haskell-mode wasn't indenting the "then" part of the if statement correct, AFAICT
22:48:51 <allbery_b> tuxplorer: ghc --make will load packages as necessary, otherwise use -package name
22:48:56 <hpaste>  sjanssen annotated "Trying out STM-based concurrency" with "this indentation style is more clear, IMO" at http://hpaste.org/2811#a2
22:49:13 <tuxplorer> allbery_b: ok
22:50:40 <allbery_b> (in general the things :set takes in ghci are ghc options)
22:50:46 <ivanm> sjanssen: OK.... well, I'm going to head off home and bash at it a bit more there
22:50:49 <ivanm> bbl
22:53:11 <hpaste>  sjanssen annotated "Trying out STM-based concurrency" with "replace nested ifs with the case/guard idiom" at http://hpaste.org/2811#a3
23:00:02 <tehgeekmeister> tuxplorer: fyi, there is a haskell bundle for textmate.  and it seems to be decent, too.
23:00:23 <tuxplorer> tehgeekmeister: cool.
23:06:19 <coffeemug> hmm
23:06:26 <coffeemug> they should have databases based on a patch theory
23:06:57 <platypus> coffeemug: How would that differ to the transactional databases we have currently?
23:07:03 <glguy> is it just me... or is ghc 6.8.x dramatically faster than 6.6?
23:07:05 <dibblego> coffeemug, I started writing one in Scala
23:07:17 <dibblego> ?type join
23:07:19 <coffeemug> platypus: once you commit a transaction, you can't "uncommit" it
23:07:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:07:26 <coffeemug> dibblego: where did that go?
23:07:30 <wli> glguy: 6.8.x is out?
23:07:35 <shapr> Yeah, is it out?
23:07:38 <dibblego> coffeemug, it's sitting around
23:07:40 <Korollary> release candidate
23:07:51 <glguy> it isn't "official" but there are versions to try
23:07:58 <dibblego> coffeemug, it's too much work for one person and nobody around me is aware of how much work is involved
23:08:36 <dolio> glguy: Faster at what?
23:08:38 <coffeemug> dibblego: I'm aware
23:09:01 <dibblego> coffeemug, my colleagues under-estimate what is involved and so I am left high and dry
23:09:09 <coffeemug> dibblego: reimplementing an RDBMS with this feature is a huge amount of work
23:09:21 <dibblego> coffeemug, yep; but a useful one
23:09:27 <platypus> coffeemug: Is that neccery a good thing to have with an RDBMS, wouldn't it brake ACID?
23:09:36 <glguy> dolio: I recompiled some of my work libraries with it
23:09:41 <glguy> dolio: and it just seemed to tear through them
23:09:49 <coffeemug> platypus: how does it break ACID?
23:09:54 <dolio> Ah.
23:10:00 <glguy> at the compile stage
23:10:03 <coffeemug> platypus: it would make undo extremely easy
23:10:03 <glguy> specifically
23:10:17 <coffeemug> platypus: it would also make concurrent access/merging easy
23:10:39 <wli> I'm trying to figure out intelligent ways to implement surplus transfer methods for STV.
23:10:52 <platypus> One proccess compleates a transaction and commits it.  Anouther Proccess starts a transaction based on that results.  However the results are then wound back you end up with a database that is inconsistant.
23:10:59 <sjanssen> glguy: 6.8 uses -fasm instead of -fvia-c when you use -O, which cuts compilation time nearly in half
23:12:08 <glguy> sjanssen: that about matches my observations
23:12:29 <glguy> dons said he recompiled 6.8 in like 10 minutes today
23:12:35 <glguy> on his laptop
23:13:41 <sjanssen> nice
23:14:06 <glguy> so is fasm better than fvia-c now
23:14:09 <glguy> or just not much worse
23:14:46 <wli> I've not been able to build the head for a bit.
23:16:36 <sjanssen> glguy: usually about the same, I've heard
23:17:37 <allbery_b> I had to kill my existing tree and re-checkout to get HEAD to build, but it works for me now.
23:17:53 <allbery_b> also, at some point stage1 stopped being buildable by itself, dunno if that's still true
23:18:15 <allbery_b> (thta is, I needed to use ghc-6.6 to build)
23:18:18 <wli> I'll re-clone.
23:18:57 <dolio> Oh, HEAD actually builds itself now? :)
23:19:35 <dolio> Or, wait, you had to delete your checkout, I see.
23:20:39 <allbery_b> also, when the 6.7->6.9 change happened I had to go through and remove all the dist/build dirs
23:21:09 <allbery_b> (if the build breaks complianing about inconmpatible interface file versions, that's it)
23:21:43 <coffeemug> platypus: that can't work
23:22:07 <coffeemug> platypus: if results are wound back then the first process' transaction will fail to commit
23:35:09 <glguy> @users
23:35:09 <lambdabot> Maximum users seen in #haskell: 407, currently: 343 (84.3%), active: 11 (3.2%)
23:37:08 <ttfh> Is there some kind of constraint programming-system for haskell?
23:37:38 <ttfh> I have a problem where I *think* constraint programming is what I want...
23:39:09 <wli> They're not usually for programming languages per se.
23:40:57 <Korollary> I think there are constraint solver libraries for many languages.
23:41:04 <hpaste>  Petra annotated "levitra" with "levitra" at http://hpaste.org/1504#a0
23:41:10 <hpaste>  Petra annotated "levitra" with "levitra" at http://hpaste.org/1504#a1
23:41:34 <sjanssen> glguy: spam alert ^^^
23:41:52 <FMota> haskell-specific spam!
23:41:54 <FMota> or not.
23:42:13 <ttfh> yes, a constraint solving library
23:42:25 <FMota> I'm thinking of coining a new TLA:  HSS
23:44:22 <glguy> sjanssen: *zap*
23:44:42 <glguy> sjanssen: nice of them to leave the announce box on and use a descriptive title, no?
23:44:54 <sjanssen> glguy: very
23:45:26 <pjd> isn't "levitra" in the blacklist?
23:45:49 <FMota> should hpaste use a captcha? :/
23:46:29 <FMota> I don't like the idea, but it seems like the easiest way to get rid of spambots -- at least use a captcha for the first time a someone uses hpaste.
23:46:34 <FMota> *-a
23:49:59 <Cale> Or make sure that the name they type in is someone who is logged into IRC.
23:50:15 <glguy> I like that idea the best
23:50:26 <kfish> and private message them a turing test
23:50:28 <glguy> I wanted to do it a while back
23:50:36 <glguy> it isn't easy for the bot to talk to the http server though
23:50:44 <glguy> due to happs' architecture
23:50:54 <glguy> so I hadn't implemented it
23:51:09 <glguy> hpaste needs a huge update now, it is based on a version of happs that doesn't really exist
23:51:30 <Korollary> happs seems to move a lot
23:51:41 <wli> The usual trick is a difficult vision recognition problem for machines to do, such as recognizing a string of distorted characters with various nonsense squiggles floating around.
23:51:55 <glguy> vision recogintion is pretty much right out
23:52:08 <glguy> hpaste first started so people like sorear wouldn't need to do the captcha on lisppaste
23:52:10 <wli> glguy: How's that?
23:52:25 <Korollary> ah. the console mafia.
23:52:25 <glguy> from their text only browsers
23:52:33 <sjanssen> wli: it doesn't work nicely for the blind and the xterm-bound
23:52:48 <Cale> audio! ;)
23:53:01 <wli> Audio is next, of course.
23:53:04 <Korollary> A simple text based game based on english grammar may work.
23:53:18 <Korollary> "remove adjectives from the list above"
23:53:29 <glguy> there are a lot of people who paste that wouldn't be able to pass that :-p
23:53:36 <Cale> "Buffalo buffalo buffalo buffalo buffalo buffalo"
23:53:45 <glguy> how about a "does glguy think this person is attractive or not"
23:53:46 <glguy> quick
23:53:48 <glguy> quiz
23:54:05 <Korollary> This person is not well typed.
23:54:11 <glguy> Cale; you missed a 'B'
23:54:12 <glguy> ;)
23:54:56 <glguy> actually, I think you missed a word or two :)
23:55:04 <Korollary> He missed one
23:55:11 <Korollary> wait
23:55:12 <Korollary> 2
23:55:14 <glguy> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo
23:55:24 <Korollary> right
23:55:31 <Olathe> Malkovich Malkovich malkovich.
23:55:44 <Cale> For any n >= 1, the sentence buffalo^n is grammatically correct.
23:55:51 <glguy> If the police police police police, who polices police police?
23:56:00 <glguy> Police police police police police police!
23:56:07 <Olathe> glguy: The Police.
23:56:19 <sjanssen> FBI?
23:56:42 <Olathe> http://en.wikipedia.org/wiki/The_Police
23:56:43 <lambdabot> Title: The Police - Wikipedia, the free encyclopedia
23:56:48 <glguy> Sting?
23:56:54 <sjanssen> or the internal affairs department of said police unit
23:57:11 <Olathe> Yes.
23:57:26 <Olathe> The Police will run a Sting operation on the police police.
23:59:20 <glguy> > let who_polices x = x ++ " police police " ++ x in who_polices "police police"
23:59:21 <lambdabot>  "police police police police police police"
