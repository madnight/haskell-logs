00:01:18 <fax> huh you can't make it tell you which parser it errord in can you?
00:01:31 <fax> I don't think that would be possible.
00:01:59 <quicksilver> you mean if it's stuck in an infinite loop?
00:02:05 <ari> @type Text.ParserCombinators.Parsec.(<?>)
00:02:10 <lambdabot> Couldn't find qualified module.
00:02:11 <fax> When it says, Parse error:(line 1, column 10):
00:02:18 <quicksilver> yes, you can
00:02:25 <quicksilver> parsec has powerful error handling stuff
00:02:30 <quicksilver> a little complex, but powerful :)
00:05:30 <dolio> @type (Text.ParserCombinators.Parsec.<?>)
00:05:32 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> String -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
00:07:24 <fax> can now tokenize :D
00:07:34 <fax> next to parse intro prolog AST
00:50:18 <Mitar> great, i have a lazy semantics checker, which does not check those types which are not used in a code later on ... what means there can be illegal definitions and I do not catch them :-)
00:50:29 <Mitar> how can I force a parameter of a function to evaluate?
00:50:59 <Mitar> checktypes te ve e = ... -- i would like that te and ve would be strict
00:51:35 <ari> @go bang patterns
00:51:38 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/BangPatterns
00:51:38 <lambdabot> Title: BangPatterns - Haskell Prime - Trac
00:52:10 <ari> I've never used them, I'm not sure if they're actually in ghc yet
00:52:39 <ari> If they aren't, there's always seq, though figuring out how to use it is another matter
00:55:08 <ari> Though that won't actually help you make your semantics checker report any more errors unless you use _|_
00:57:34 <quicksilver> Mitar: I would be very surprised if bang patterns are the correct way to solve this problem
00:57:58 <quicksilver> hmm
00:58:17 <Mitar> so when i am adding new defined types to type environment i check them
00:58:20 <quicksilver> normally the 'type' of the whole program
00:58:29 <quicksilver> implies that all the sub parts are typed
00:58:32 <quicksilver> in some sense
00:58:34 <Mitar> but the problem is that if i never read this type from the environment it is never checked
00:59:09 <quicksilver> you could see this as a disadvantage of the way you use 'error' instead of a proper representatio of failure
00:59:19 <quicksilver> if you used a proper representation of failure you could write:
00:59:23 <quicksilver> welltyped :: Program -> Bool
00:59:46 <hpaste>  Mitar pasted "types" at http://hpaste.org/2741
01:00:07 <Mitar> yes, i do this :-)
01:00:28 <Mitar> but it finds it too early it is OK
01:00:39 <Mitar> for example, in my language this is not possible
01:00:57 <Mitar> as types have recursive loop
01:01:02 <quicksilver> well the point is, if you represent errors explicitly
01:01:06 <quicksilver> such as with an Either type
01:01:14 <quicksilver> then 'welltyped' automaticlaly forces evaluation
01:01:19 <quicksilver> since it checks for 'Right' everywhere
01:01:28 <Mitar> yes
01:01:30 <Mitar> i know ..
01:01:33 <Mitar> any other way?
01:01:33 <quicksilver> and you don't need to mess around with strictness anotations and bang patterns
01:01:47 <Mitar> i will have to mess much more with this ...
01:01:54 <Mitar> (i use error now everywhere)
01:02:08 <Mitar> and to check now for Either all around ...
01:02:21 <Mitar> and to change to do ...
01:02:34 <quicksilver> then you have to write an ugly 'welltyped' which sprinkles 'seq' everywhere
01:02:39 <quicksilver> to check for errors
01:03:21 <Mitar> i have to force stricknes only on environment variables
01:03:28 <Mitar> and on just one place
01:03:34 <quicksilver> well you could check length t > 0
01:03:40 <Mitar> hmm
01:03:42 <quicksilver> since your types are strings
01:03:51 <quicksilver> that will force them not to be _|_
01:04:08 <Mitar> the length of environment?
01:04:23 <Mitar> are bang patterns defined in ghc?
01:04:38 <quicksilver> no, the length of the individual type strings
01:04:46 <quicksilver> but then you can map that over the whole environment
01:04:54 <Mitar> hmm
01:05:05 <quicksilver> what type does your environment have?
01:05:07 <quicksilver> Map String String ?
01:06:41 <Mitar> no, [(String,Type)]
01:06:56 <Mitar> where the type is data Type = TyNil | TyUnknown | TyVoid | TyInt | TyString | TyFunc [TypedVar] Type | TyArray Type | TyRecord [TypedVar] | TyVar TypeId
01:07:02 <Mitar> :-)
01:07:27 <Mitar> maybe i could use a quard for this :-)
01:08:01 <Mitar> typecheck te ve e | forceStrict te && forceStrict ve = ...
01:08:02 <Mitar> :-)
01:09:11 <Mitar> forceStrict = id . ($!)
01:09:11 <Mitar> ?
01:09:21 <Mitar> hm, no
01:09:26 <quicksilver> doesn't really work like that
01:09:30 <quicksilver> because && is lazy
01:09:46 <quicksilver> EVERYTHING is lazy, remember that
01:09:51 <Mitar> :-)
01:10:03 <quicksilver> and just using 'seq' on your te and ve will acheive nothing
01:10:12 <quicksilver> all that proves is that the list exists
01:10:16 <quicksilver> (the list of pairs)
01:10:26 <quicksilver> this is why I really don't recommend bang patterns, or seq
01:10:51 <quicksilver> I recommend thinking of a function which by executing it obviously requires the types.
01:11:10 <quicksilver> (well actually I recommend using a proper error signalling and not abusing error ;P)
01:11:17 <osfameron> even strict things are lazy!  Calling them "eager" is a calumny, they're only evaluating because the runtime is breathing down their necks, and they decide it's less hassle to just play along...
01:11:39 <Mitar> lol
01:12:12 <quicksilver> you can use deepSeq or rnf if you like
01:12:16 * quicksilver shrugs
01:12:19 <quicksilver> I despise them
01:12:22 <quicksilver> ;)
01:12:42 <Mitar> ok, what would be the proper error handling? using either? but then I have to either use a monad and rewrite the code into a do notation or use Either and manually pass the error message higher if it comes
01:13:22 <quicksilver> you don't have to use do notation to use a monad
01:13:38 <quicksilver> > Right 4 >> Right "foo"
01:13:39 <lambdabot>  Add a type signature
01:13:47 <quicksilver> > Right 4 >> Right "foo" :: Either String String
01:13:48 <lambdabot>  Right "foo"
01:13:55 <quicksilver> > Left "oops" >> Right "foo" :: Either String String
01:13:57 <lambdabot>  Left "oops"
01:14:01 <quicksilver> no 'do' in sight :)
01:15:19 <osfameron> "Right" and "Left" are *terrible" names for "OK" and "Error"...
01:15:41 <quicksilver> I don't think they're that terrible
01:15:47 <quicksilver> but it would be more idiomatic to write
01:15:59 <quicksilver> > throwError "oops" >> return "foo" :: Either String String
01:16:00 <dolio> Right is the right answer. :)
01:16:00 <lambdabot>  Left "oops"
01:16:17 <osfameron> and Left is the, er, not-right answer?
01:16:43 <quicksilver> Mitar: to use 'rnf' from Control.Parallel.Strategies you would, I think, have to derive NFData for your type
01:16:53 <dolio> Maybe Either should be changed to the Picard monad instead of Maybe.
01:17:03 <osfameron> Picard?
01:17:24 <dolio> data Picard a b = MakeItSo a | BelayThat b
01:17:29 <fax> lol
01:18:02 <osfameron> hah
01:18:31 <osfameron> but at least that indicates some sort of Yesness and Noness, rather than 2 alternatives (which is what Either says to me)
01:18:56 <dolio> Well, Either is also used to be the sum of two types, so it's got kind of a dual role.
01:19:28 <dolio> It just happens that the monadic interpretation of Either is error handling.
01:20:19 <dolio> Be glad they didn't use the category theory (I think) names like Coq. :)
01:20:27 <int-e> you could use it for nonlocal returns of a fixed type. errors are just a special case of that.
01:20:31 <dolio> data Either a b = Inl a | Inr b
01:20:40 <quicksilver> ChilliX++ # "This is GHC after all, it tries to gently nudge you in the right direction, but if you insist, it happily let's you drill arbitrarily large holes in your foot."
01:21:03 <quicksilver> actually I think osfameron is right
01:21:08 <quicksilver> I think that Either is a bit generic
01:21:20 <quicksilver> and it would make sense to have another (isomorphic) type with better constructor names
01:21:27 <quicksilver> but I also don't think it's all that important :)
01:21:29 <dolio> Yeah, it might be better if there were Error in addition to ErrorT.
01:21:51 <quicksilver> It is of course easy enough to define your own
01:21:55 <quicksilver> and make it an instance of MonadError
01:24:09 <hpaste>  Mitar pasted "Either?" at http://hpaste.org/2742
01:24:25 <Mitar> quicksilver, but even Either is not a solution
01:24:47 <quicksilver> Mitar: different problem, I think
01:24:55 <quicksilver> Mitar: cyclicity you're going to have to check for explicitly
01:25:03 <Mitar> no no
01:25:03 <quicksilver> Mitar: that's different from being too lazy about type errors
01:25:08 <Mitar> i check it in the newenv
01:25:26 <Mitar> and the problem is that because typecheck te ve (IntLit _) = Right TyInt never consultes the te and ve
01:25:32 <Mitar> te' and ve' are never evaluated
01:26:02 <quicksilver> Mitar: the newenv needs to be in the either monad in a similar way
01:26:30 <quicksilver> Mitar: then you do (te',ve') <- newenv (te,ve)
01:26:43 <quicksilver> Mitar: and that forces it to be right and not left
01:28:28 <MarcWeber> Using recent ghc snapshot: Is  there a easy fix for Network/Socket.hsc:1901:9: Not in scope: `openeFd'?
01:28:54 <dolio> Change it to "openFd"?
01:31:39 <MarcWeber> dolio: Sorry. That has been my type. It is openFd
01:31:49 <MarcWeber> But that seems to be no longer present ?
01:31:56 <dolio> Oh. I'm out of ideas, then. :)
01:32:17 <quicksilver> MarcWeber: you may have better luck on the #ghc channel
01:32:28 <quicksilver> MarcWeber: but maybe it's just a broken snapshot. Happens sometimes.
01:35:38 <RogerTaylor> MarcWeber: does this help? http://www.google.com/search?hl=en&q=openfd+site%3Ahaskell.org
01:35:39 <lambdabot> Title: openfd site:haskell.org - Google Search
01:36:21 <RogerTaylor> I had a similar problem. There's a discontinuity between the POSIX lib and the Network lib.
01:37:23 <MarcWeber> Thanks!
01:54:29 <Qerub> Does Haskell have any nice syntax for Map literals? Something like { "foo" => 2, "bar" => 3 }?
01:55:17 <dmwit> I think just
01:55:20 <therp> yourmap x = case x of { "foo" -> 2; "bar" -> 3; }
01:55:28 <dmwit> fromList [("foo", 3), ("bar", 7)]
01:56:27 <dmwit> (To answer very literally, Data.Map gets no special syntactical status.)
01:57:54 <RogerTaylor> Qerub: if you want some special syntax, introduce your own operators (functions + fixity decs)
01:58:14 <RogerTaylor> Examples abound, e.g. HaskellDB
01:58:36 <Qerub> Alright! Thanks for the answer.
01:58:39 <RogerTaylor> "=>" is reserved IIRC, but you could use "==>"
01:58:42 <RogerTaylor> or something
01:58:57 <taruti> (k,v) ==> m = Map.insert k v m
01:59:22 <dmwit> k ==> v = Map.singleton k v
01:59:24 <taruti> ("foo",2) ==> ("bar",3) ==> empty
01:59:41 <RogerTaylor> I was thinking: fromList ["foo" ==> 3, "bar" ==> 7]
01:59:51 <RogerTaylor> but taruti's idea is nice too
01:59:52 <dmwit> (&) = Map.union
02:00:03 <RogerTaylor> x ==> y = (x,y)
02:00:04 <dmwit> "foo" ==> 2 & "bar" ==> 3
02:00:18 <RogerTaylor> go to town :-)
02:01:33 <therp> qerub: ah sorry I totally misunderstand your question.
02:06:04 <tuxplorer> is there a function in haskell to strip a string of all mysql non-compatible characters and to avoid SQL injection?
02:06:43 <quicksilver> that's certainly not really a question for haskell
02:06:49 <quicksilver> it's something you'd hope to find in the SQL libs
02:07:19 <quicksilver> which db lib are you losing?
02:08:19 <quicksilver> doestn' look like HSQL does
02:08:59 <quicksilver> HDBC has a sane design using parameters
02:09:04 <quicksilver> so you don't need 'escape'
02:09:11 <quicksilver> or that's what cosmicray claims in the docs
02:10:04 <quicksilver> I think HDBC is a bit more shiny than HSQL, overall
02:10:07 <quicksilver> although I've used neither
02:12:52 <osfameron> HSQL doesn't have parameters?
02:14:32 <quicksilver> osfameron: maybe it does, I didn't look hard enough
02:14:38 <quicksilver> osfameron: it seems to be mostly String based though
02:14:44 <gour> @paste
02:14:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:15:24 <osfameron> either way, I don't think I could use a DB system that didn't support placeholders.  It's more or less insane.
02:15:45 <quicksilver> certainly insane if you have untrusted data
02:15:49 <quicksilver> have you looked at haskellDB?
02:15:53 <quicksilver> that's a much more interesting approach
02:16:06 <quicksilver> not SQL based at all; has its own ADT representation of queries
02:16:12 <osfameron> nope I haven't.  is that the queries-as-haskell-data approach ?
02:16:17 <quicksilver> that's right
02:16:35 <quicksilver> like DBIx::Class in concept, but arguably it's quite a bit easier to get it looking nice in haskell
02:16:51 <quicksilver> with a type-system and custom operators and stuff
02:17:21 <osfameron> true.  I can vaguely imagine some goodness coming out of that :-)  Will play with it at "some point"
02:18:27 <gour> hi, i've 750M tab-delimited database which has to be read in order to populate sqlite3 database. here is python script (not mine) used to grok 10M file, but it cannot handle 750M. what are the prospects of haskell handle it with hdbc-sqlite, ie. can haskell's laziness do the job?
02:18:31 <hpaste>  gour pasted "python script" at http://hpaste.org/2744
02:20:19 <quicksilver> gour: should be fine. it will work line by line
02:20:33 <quicksilver> gour: the weak link will be sqlite
02:20:37 <quicksilver> (if there is a problem)
02:20:41 <quicksilver> not the file import
02:20:50 <gour> quicksilver: why sqlite?
02:20:50 <olsner> I have successfully applied haskell to analyzing 2GB ascii files - the end result was both faster and more readable than the equivalent perl script
02:21:06 <gour> olsner: good to know. thanks
02:21:13 <quicksilver> gour: well I don't know about sqlite's performance characteristics when you instert 750M of data
02:21:20 <quicksilver> gour: so I can't vouch for that
02:21:24 <olsner> but getting it there required a few tricks... for example, going with ByteString from the start is a good idea
02:21:37 <quicksilver> but I *do* know that line by line processing in haskell doesn't require memory
02:21:56 <quicksilver> I also know that lazy IO is extremely evil and you should just call hGetLine :)
02:22:00 <gour> quicksilver: well, i don't need all the 'fields' from CSV database, so the sqlite3 database will be probably much smaller
02:24:37 <b_jonas> lol
02:25:06 <tuxplorer> quicksilver: I use HSQL-MySQL lib of haskell
02:25:30 <b_jonas> these days I rather use ruby instead of perl for text processing unless I need some perl module (like for xml) -- ruby is not that much slower and it's easier to write programs in
02:26:55 <quicksilver> I would argue that haskell is faster then ruby and even easier to write programs in :)
02:27:10 <cognominal_> I think that ruby is mostly a clean perl5 with batteries included. More useful modules in the core
02:27:12 <quicksilver> ruby seems to be a poor middle ground: slower AND less powerful :)
02:27:16 <osfameron> b_jonas: I must play with ruby some time... but Moose is quite cute and gives you some of that goodness (but with CPAN)
02:27:31 <b_jonas> It's not relaly clean, it just has dirt in different places than perl5
02:27:43 <b_jonas> but yes, the core libraries are indeed more useful
02:27:50 <gour> i have to prepare that sqlite3 database for use with another gui program which will be in haskell, so ruby & co. are not alternatives ;)
02:27:58 <b_jonas> it's not less powerfool I think
02:28:08 <cognominal_> the syntax of reference in Perl 5 is awful
02:28:21 <quicksilver> well speaking of power in programming languages is always a bit woolly
02:28:28 <quicksilver> since in a technical sense, they are all the same power
02:28:31 <b_jonas> obviously
02:28:35 <cognominal_> as for haskell, I guess that it must be fine but the learning curve is difficult
02:28:44 <quicksilver> when I say 'ruby is less powerful than haskell' what I'm really talking about is abstraction
02:28:48 <quicksilver> and expressivity of abstractions
02:29:00 <b_jonas> oh, you mean less powerful than haskell
02:29:02 <b_jonas> I can agree that
02:29:03 <quicksilver> yes
02:29:07 <b_jonas> I thought you compared to perl
02:29:10 <quicksilver> no
02:29:14 <b_jonas> like cognominal_
02:29:16 <b_jonas> sorry
02:29:18 <quicksilver> the perl comparison was the 'slower' part
02:29:29 <b_jonas> I've done measuremens about their speed
02:29:30 <quicksilver> I was saying ruby is slower than perl, but less powerful than haskell :)
02:29:43 <quicksilver> which makes it a poor middle ground IMO
02:29:46 <quicksilver> it is cute though
02:29:53 <quicksilver> and I have no objections to it on cuteness grounds
02:30:22 <b_jonas> that sentence could mean that ruby is slower than perl but faster than haskell and less powerful than haskell but more powerful than perl
02:30:46 <b_jonas> I mostly use ruby as a perl replacement with ruby threads really
02:30:52 <b_jonas> it doesn't cover much new ground after perl
02:31:10 <goalieca> go python
02:31:20 <cognominal_> arf
02:31:25 <dolio> Sometimes I wish I could say 'list.sort_by { rand }
02:31:31 <dolio> Whoops, hit enter.
02:31:37 <b_jonas> anyway, the result I've got is that ruby wasn't that much slower than perl as I've expected it to be
02:31:43 <dolio> In Haskell, that is. But it's a small price to pay. :)
02:31:54 * roconnor wonders what units power is measured in.
02:32:02 <cognominal_> dolio: I have an obfuscation in Perl that does shuffle with sort thru rand
02:32:10 <b_jonas> (why, you could just have a specific shuffle function or something instead of sort_by)
02:32:18 <goalieca> haskell is young.. soon enough it will be 2x as fast
02:32:19 <goalieca> i'm sure
02:32:29 <roconnor> young?
02:32:30 <b_jonas> cognominal_: worse, I have a benchmark meditation in perl that compares shuffles
02:32:40 <goalieca> okay. ghc is relatively new
02:32:50 <goalieca> compared to other compilers
02:32:58 <dolio> b_jonas: Yeah, but shuffling requires a monad for random numbers in Haskell, so it feels comparatively heavyweight.
02:34:10 <cognominal_>  sub shuffle { map { @_=sort { int (3*rand)-1 } @_ } 0..5 }
02:34:42 <dolio> Yikes. :)
02:35:53 <dolio> So, 'int (3*rand)' is something in {0, 1, 2} ?
02:36:08 <cognominal_> yup
02:36:16 <dolio> Lovely. :)
02:36:16 <cognominal_> b_jonas: url?
02:37:02 <cognominal_> You can't do that with every kind of sort function. Some don't like very much rand as a sort criteria
02:37:44 <osfameron> we use a fisher-yates shuffle function in perl
02:41:37 <b_jonas_> dolio: http://www.perlmonks.com/?node_id=533396 is my benchmark of shuffles in perl, it has sory_by rand variants as well
02:41:47 <lambdabot> Title: Benchmarking perfect shuffles
02:42:01 <b_jonas_> cognomial: yeah, that one is a famously wrong shuffle in perl
02:42:20 <b_jonas_> another one is sort { rand <=> rand }
02:42:53 <b_jonas_> apart from not giving uniform probability of outputs, these can also segfault older perls that assume the compare function is transitive
02:43:07 <b_jonas_> at least so I've heared, I've never actually seen the segfault
02:43:26 <b_jonas_> dolio: could you show me your obfu with sort though? I think it could be interesting
02:43:38 <dolio> Eh?
02:43:39 <b_jonas_> It could complement something like my perlmonks.com/?node=fast+japh
02:43:51 <b_jonas_> 'dolio: I have an obfuscation in Perl that does shuffle with sort thru rand'
02:43:55 <b_jonas_> that one
02:44:05 <cognominal_> b_jonas, I see that you like pentominos. Have you seen my obfu that won the tpj contest in its category : solving pentominoes with regexen?
02:44:07 <dolio> That was cognominal_
02:44:17 <dolio> Presumably, the one he posted.
02:44:57 <b_jonas_> oh sorry
02:45:07 <b_jonas_> 'sub shuffle { map { @_=sort { int (3*rand)-1 } @_ } 0..5 }'
02:45:20 <cognominal_> heu it's wrong
02:46:19 <cognominal_>  I am very proud of the tpj writeup http://www.foo.be/docs/tpj/issues/vol3_3/tpj0303-0015.html
02:46:21 <lambdabot> Title: The 3rd Annual Obfuscated Perl Contest Victors - The Perl Journal, Fall 1999
02:46:39 <cognominal_> First Place. Stephane Payrard's Polyominos - fitting problem solver is very beautiful - eclipsed only by the entertaining reading available in the SOLUTION file. Perhaps it's fitting that such a powerful obfuscatory statement comes from the land that bred semiotics, deconstructionism and Jean-Paul Sartre. Or maybe Stephane is just demented.
02:46:39 <dolio> I was just pining for the simplicity of 'list.sort_by { rand }' from Ruby, which is commonly used to shuffle (since people probably don't care whether it's perfect or not).
02:46:48 <LeCamarade> Um ... how do I turn a, say, Char to Integer?
02:46:59 <LeCamarade> What func?
02:47:08 <therp> read maybe?
02:47:13 <dolio> ord?
02:47:32 <dolio> That'll give you an Int that you can turn into an Integer easily enough.
02:47:34 <KatieHuber> fromEnum ?
02:47:49 <LeCamarade> Oh. How could I forget ord?????????
02:47:58 <mux> > (fromIntegral . fromEnum) 'b'
02:47:59 <lambdabot>  98
02:48:00 <dolio> fromEnum would be direct, yeah.
02:48:08 <dolio> :t fromEnum
02:48:10 <lambdabot> forall a. (Enum a) => a -> Int
02:48:16 <dolio> Oh, no it wouldn't.
02:48:36 <b_jonas_> is that the polymyno puzzle quine one?
02:48:43 <int-e> I think ord and chr were added to make BASIC programmers feel at home with Haskell.
02:48:54 <hpaste>  aaim pasted "Here's another one" at http://hpaste.org/2745
02:49:10 <b_jonas_> dolio: that one is perfect
02:49:19 <LeCamarade> :o)
02:49:46 <b_jonas_> int-e: pascal programmers
02:49:53 <b_jonas_> basic has ASC and CHR$ not "ord"
02:50:06 <cognominal_> b_jonas: I dont know the polyomino quine but I don't read perlmonks much anymore
02:50:15 <b_jonas_> it's not on perlmonks I think
02:50:26 <int-e> b_jonas_: but it's funnier with basic ;)
02:50:27 <b_jonas_> I think it might  not even be in perl
02:50:38 <hpaste>  aaim annotated "Look, it does what I want, and it's easy... but isn't this built-in somewhere?" with "(no title)" at http://hpaste.org/2718#a1
02:51:00 <LeCamarade> 10 REM DON'T LAUGH AT BASIC, OK?
02:51:00 <b_jonas_> int-e: well, perl has lots of ugly syntax originating from other languages (including sh, tchs, sed, awk)
02:51:03 <dolio> b_jonas_: Is it? It's been a while since I've used Ruby.
02:51:36 <int-e> LeCamarade: I'd never. I'm too young to die.
02:51:43 <b_jonas_> dolio: yes, because sort_by uses the block to calculate keys (weights) for each element and sorts "by" comparing those weights
02:51:55 <b_jonas_> the element with lower weight gets to be the first
02:52:00 <LeCamarade> :o)
02:52:26 <b_jonas_> the ruby method "sort" is the one that accepts a comparision function like perl's sort or c++'s sort or c's qsort
02:53:44 <b_jonas_> LeCamarade: I don't. I laugh at visual basic and esp openofficeorg basic all the stupid new oo basics, but I like the non-oo ones like old zx spectrum basic, commodore basic, gwbasic, qbasic, word2basic, corelbasic etc
02:54:07 <b_jonas_> after all, basic has one of the funniest quines in existence
02:54:09 <b_jonas_> 10 LIST
02:54:14 <osfameron> eeek, spectrum basic with its lack of functions etc.
02:54:24 <dolio> As I recall Oleg has an argument that attaching random tags to elements and sorting doesn't result in a perfect shuffle...
02:54:33 <osfameron> I liked bbc basic, that was a real eye opener about the relative power of programming languages...
02:54:36 <b_jonas_> functions
02:54:39 <b_jonas_> who needs functions
02:54:46 <b_jonas_> gosub is enough
02:55:02 <b_jonas_> dolio: it depends what kind of tags you attach
02:55:30 <b_jonas_> the Cormen book discusses that algorithm (also F-Y shuffle)
02:56:09 <b_jonas_> if there are no equal tags and they are independent with the same distrubution then it's perfect
02:56:20 <b_jonas_> (provided they are ordered completely)
02:59:25 <b_jonas_> I wrote buublesort in basic once
03:00:03 <MyCatSchemes> b_jonas_: we don't care about the O(n^2), but how *dare* you use such an evil algorithm? :)
03:02:09 <b_jonas_> MyCatSchemes: well, that was ages ago
03:02:15 <b_jonas_> I didn't know about heapsort at that time
03:02:30 <b_jonas_> and quicksort or the like is difficult to write in basic
03:02:59 <int-e> > let bubble (a:b:xs) | a > b = b:bubble (a:xs) | otherwise = a:bubble (b:xs); bubble xs = xs; sort xs = last . zipWith (flip const) xs . iterate bubble $ xs in sort [3,1,2,4,561,0,3,4]
03:03:01 <lambdabot>  [0,1,2,3,3,4,4,561]
03:03:07 <b_jonas_> otoh it takes very little code
03:03:35 <int-e> looks perfectly reasonable to me, what's evil about that? ;)
03:03:39 <b_jonas_> and if I'd have memoized the result (I only used to to sort font names for a dialog box) then code size would definitely be the primary concern
03:04:10 <b_jonas_> Oh wait, I'm stupid
03:04:17 <b_jonas_> I wrote quicksort in basic another time as well
03:04:25 <b_jonas_> and in that case, speed was a concern
03:04:31 <b_jonas_> now it was bad in that case
03:04:33 <b_jonas_> but I was young
03:05:57 <hpaste>  (anonymous) annotated "Look, it does what I want, and it's easy... but isn't this built-in somewhere?" with "(no title)" at http://hpaste.org/2718#a2
03:06:55 <quicksilver> int-e: zipWith const to trim one list down to the size of another is an interesting indiom
03:09:02 <int-e> :)
03:09:50 <int-e> oh. but it means that the function doesn't work for empty lists.
03:10:07 <int-e> that wouldn't have happened with the more obvious (!! length xs)
03:12:07 <b_jonas> why wouldn't it work with an empty list?
03:12:20 <int-e> > last []
03:12:32 <lambdabot>  Exception: Prelude.last: empty list
03:13:20 <b_jonas> but quicksilver said zipWith const
03:13:22 <int-e> "the function" was the sort function above. The zipWith works just fine.
03:13:42 <b_jonas> oh, I see
03:13:44 <b_jonas> the bubble
03:14:58 <osfameron> bubblesort!
03:15:04 <osfameron> the king of sort routines!
03:19:39 <doserj> bubblesort works locally, is therefore friendly to the cache and it is nicely parallisable. What else do you want?
03:20:32 <b_jonas> well, mergesort has those advantages as well
03:21:03 <quicksilver> b_jonas: mergesort isn't truly local
03:21:06 <osfameron> oh, is a parallelised bubblesort efficient?
03:21:07 <b_jonas> but I somehow like heapsort better, even though I know it's not good for external sort
03:21:14 <quicksilver> b_jonas: it works back and forth between two copies
03:21:28 <MyCatSchemes> Mergesort requires twice as much RAM as there is data, you can't do it in-place.
03:21:34 <quicksilver> b_jonas: and it maintains at all times two 'cursors' into the source list
03:21:44 <quicksilver> b_jonas: so it's hitting three active memory locations (two read, one write) at a time
03:21:50 <quicksilver> which can be pretty widely distributed
03:21:56 <b_jonas> quicksilver: it's not local if you have one tape, sure, but it's still cache-local or can be done externally with a few tapes
03:22:08 <b_jonas> are you programming one-tape turing-machines or what?
03:22:21 <quicksilver> no, we're programming on modern CPUs
03:22:30 <quicksilver> but we're sorting lists so big they don't fit in the cache
03:22:34 <quicksilver> at least, I assume that's the point :)
03:22:34 <b_jonas> yep
03:22:46 <b_jonas> but the cache can do two locations pretty fine
03:22:57 <MyCatSchemes> Modern CPUs have a megabyte of cache apiece. How often do you sort lists bigger than, say, 128x2^10 items?
03:22:57 <b_jonas> (it's two not three but that's a minor point)
03:23:31 <MyCatSchemes> b_jonas: don't forget to count the stack for all those nifty recursive calls.
03:23:53 <b_jonas> MyCatSchemes: recursive calls? you're thinking of qsort. mergesort doesn't have those.
03:24:22 <b_jonas> non-inplace is true
03:24:25 <b_jonas> you're right
03:24:46 <b_jonas> I like heapsort which is inplace, but it's obviously really bad for localty
03:24:54 <quicksilver> the traditional encoding of mergesort is recursive
03:25:17 <quicksilver> of course it's possible to unwrap it with an extra variable for 'current sublist size'
03:25:46 <quicksilver> MyCatSchemes: if you're not sorting something bigger than the cache, then you probably don't care about performance
03:25:50 <quicksilver> MyCatSchemes: it will be fast anyway :)
03:30:27 <MyCatSchemes> quicksilver: not with bubblesort :)
03:30:34 <MyCatSchemes> quicksilver: nor with bogosort.
03:31:35 <osfameron> I believe bubblesort is actually the sort of choice when sorting nearly-sorted data ?
03:33:22 <MyCatSchemes> osfameron: only if it's already almost-sorted to some ridiculous extent. And mergesort also tends towards O(n) in nearly-sorted data, too. Methinks insertion sort does as well, and that's always faster than bubble except under really contrived circumstances anyway.
03:35:24 <osfameron> yeah, I can imagine that
03:37:21 <quicksilver> MyCatSchemes: merge sort generally has a really bad constant
03:37:45 <quicksilver> MyCatSchemes: it's a very SLOW O(n log n), and it's also a SLOW O(n) on nearly-sorted data
03:37:49 <quicksilver> but on the other hand it's stable
03:37:56 <quicksilver> which is important for lots of applications
03:38:23 <quicksilver> insertion is fastest on nearly-sorted, isn't it?
03:38:49 <quicksilver> and if you squint a little bit, you can see insertion on nearly-sorted data as a kind of "obvious" improvement to bubble-sort
03:39:00 <quicksilver> "skip out of the bubble if this bit's already in the right place"
03:50:02 <b_jonas> apart from being easy to code, quicksort has another area where it pwns all other sort kinds
03:50:59 <b_jonas> namely when you want to partition a list of length n to the k lowest and (n-k) highest data for a given k, then a modified qsort (which is not recursive just tail recursive) wins
03:51:37 <DRMacIver> "not recursive just tail recursive"? Do you mean the other way around?
03:51:38 <b_jonas> similarly if you just want the k smallest elements of a list sorted for a given k that's much less than the size of list, then that qsort or a modified heapsort are the two things that win
03:51:58 <b_jonas> I mean it's only tail recursive so doesn't need the stack
03:52:07 <DRMacIver> Ah
03:52:14 <b_jonas> so you can very easily do it inplace
03:52:14 <scook0> i.e. it doesn't need two recursions
03:52:16 <b_jonas> yep
03:53:00 <int-e> aka quickselect.
03:53:00 <b_jonas> though there's another complicated algorithm that can do that partitioning and is deterministic
03:53:34 <xtacy[]> its the median of 5 method... very innovative :)
03:54:07 <b_jonas> yep
03:54:11 <b_jonas> probably called like that
03:54:30 <b_jonas> c++ calls the task (not either algorithms just the specs) some wierder name
03:54:32 <b_jonas> I can't remember
03:54:42 <xtacy[]> Ideally we would like to have the pivot to be the median, and order statistics (kth smallest/largest selection) can be done in O(n) . So, your recurrence relation looks neat!
03:54:44 <b_jonas> uh huh, nth_element
03:55:17 <b_jonas> yep, O(n) and can be done externally in that time as well
03:55:24 <b_jonas> so it's well cache-wise
03:55:55 <xtacy[]> ? could you clarify your last statement?
03:57:18 <b_jonas> I mean, it's fast on modern cpus with cache, because it does ordered access to the memory not random access
03:57:48 <b_jonas> when I implemented the randomized one, I called the function "quantile" for that both starts with q and means what I acheive
03:58:13 <xtacy[]> :) yeah, right. Thats why quicksort is in some sense better than heapsort! (2*i and 2*i+1 are far, compared to i)
03:58:25 <osfameron> quicksort is the most beautiful sort
03:58:50 <int-e> bottom up merge sort is also pretty.
03:59:02 <b_jonas> xtacy[]: for that problem yes
03:59:03 <xtacy[]> which is the sorting algorithm that is easiest to work with, for proving correctness?
03:59:16 <b_jonas> but for partial_sort heapsort is better for it can do everything in one pass
03:59:39 <b_jonas> so it's quite fast for external data if the result fits in memory
03:59:40 <int-e> xtacy[]: hard to say. selection sort?
03:59:46 <b_jonas> faster than that qselect thing
04:00:04 <xtacy[]> int-e: hmm, insertion sort too.
04:00:29 <Sizur> are we developing metasort here? 'my sort is bigger than your sort'
04:00:29 <xtacy[]> int-e: What could be the invariant in quicksort? hard to think of
04:00:39 <b_jonas> Sizur++ metasort
04:01:17 <b_jonas> xtacy: it's easy: the invariant is that qsort returns its input sorted and calls itself only for smaller arrays (so it's finite)
04:01:41 <b_jonas> the second one is trivial and the first one you prove by induction over the size of input
04:02:59 <xtacy[]> b_jonas: in that case, this invariant holds good for merge sort too!
04:03:14 <b_jonas> xtacy[]: yes, but it's more difficult to prove
04:03:28 <b_jonas> here this invariant is really not an "invariant" but an "induction statement"
04:03:32 <b_jonas> which you use in the proof
04:04:48 <xtacy[]> b_jonas: right, but even in insertion sort, we have "P(i): array[1..i] is sorted". So, after execution of the inner loop, "P(i) => P(i+1)".
04:05:00 <xtacy[]> b_jonas: some form of induction :)
04:05:07 <b_jonas> sure
04:05:21 <b_jonas> that sounds like a nice way to prove for mergesort
04:05:29 <b_jonas> I didn't say qsort is the easiest to prove
04:05:46 <b_jonas> just answered your question about quicksort
04:05:58 <xtacy[]> b_jonas: :)
04:06:49 * xtacy[] leaves to have a cup of tea
04:11:30 <EvilTerran> @go oleg hlist
04:11:34 <lambdabot> http://www.cwi.nl/~ralf/HList/
04:11:34 <lambdabot> Title: Strongly typed heterogeneous collections
04:18:19 <Andris> hello, #haskell! looking for a little-dependencies (preferrably standard) way to load png/gif in haskell (want to play with some image processing). any pointers?
04:19:28 <EvilTerran> might be something under http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Graphics
04:19:31 <lambdabot> http://tinyurl.com/yqov7f
04:19:55 <EvilTerran> GD?
04:20:42 <EvilTerran> iirc, the GD binding's incomplete, but it might do what you want
04:21:11 <Andris> EviltTerran, thanks, will check it out; I actually was working through this list already :)
04:21:37 <Andris> but probably have chosen wrong evaluation strategy :)
04:22:26 <quicksilver> I believe there isn't a really good graphics loading lib yet
04:22:33 <EvilTerran> i've no experience with SDL, but that also might have something. i dunno.
04:22:34 <quicksilver> certainly laast time I looked properly there wasn't
04:22:36 <quicksilver> gtk2hs can do it
04:22:42 <quicksilver> as part of a gtk application I believe
04:22:53 <scook0> what's considered a good image loading lib in the C world?
04:23:00 <puusorsa> imagemagick?
04:23:00 <Andris> the trouble is, I want it clearly cut - no 3D, no windowing, just file ops and pixels
04:23:17 <EvilTerran> scook0, i think GD's fairly standard in that respect. i may be wrong, tho.
04:23:19 <Andris> gd looks ok from the spec
04:23:40 * EvilTerran was thinking about writing bindings to allegro (alleg.sf.net), which he's used for image processing in C, but that's a general-purpose "game development" library
04:24:36 <Andris> btw, what's the modern way of installing packages under GHC? I wonder what this Cabal is about - how is it better than just grabbing the tarball?
04:25:25 <quicksilver> it's been suggested several times that a binding to imagemagick
04:25:37 <quicksilver> (or that fork of imagemagick)
04:25:40 <quicksilver> woudl be a nice thing to have
04:25:46 <quicksilver> but no one has stepped up to the plate
04:26:10 <EvilTerran> hm. what OS are you on, Andris? Cabal streamlines the build process, but it doesn't really work on windows.
04:27:47 <Andris> I am affraid it is Windows
04:28:12 <Andris> well, is there any hope to manually build these Cabal distros on Windows?
04:28:50 <Andris> or just untarring is enough?
04:29:16 <Japsu> The normal process with Cabal is untar, runhaskell Setup.hs configure, runhaskell Setup.hs build
04:29:22 <Japsu> (runhaskell Setup.hs install)
04:30:23 <Andris> yes, it does not work...
04:30:29 <EvilTerran> i find there's usually an "autoreconf" step after "untar" -- being where windows falls down.
04:30:39 <Andris> ok, will try some luck with Cygwin then
04:30:44 <Andris> thanks
04:30:54 <EvilTerran> it's more likely to work on cygwin, yeah.
04:32:12 <Andris> btw, what are the reasons not to have such package in pure Haskell? performance or the fact that creating a binding is faster then porting?
04:32:15 <Andris> than
04:32:58 <scook0> mostly the latter, I'd think
04:33:13 <scook0> since it's possible to write C in Haskell if you really want to
04:33:45 <DRMacIver> Although it's rarely a good idea. :)
04:34:02 <scook0> DRMacIver: well, it can beat writing C in C sometimes ;)
04:34:35 <Andris> what about writing Fortran in Haskell...
04:35:01 <scook0> stuff like Data Parallel Haskell maybe?
04:35:58 <quicksilver> Andris: almost entirely the latter
04:36:13 <quicksilver> Andris: it's just a lot of work has gone into (e.g.) imagemagick and it would take time to port it
04:36:41 <scook0> also, a wrapper is probably easier to maintain than a library
04:36:48 <scook0> assuming the underlying library is maintained
04:36:55 <quicksilver> it's rather unusual to actually have a case where haskell performs badly and we can't fix it
04:37:00 <DRMacIver> scook0: But loses to both C and idiomatic Haskell in performance and doesn't beat writing Haskell in Haskell. :)
04:37:13 <EvilTerran> altho, once we forked all the functionality into a pure haskell version, we could then work on supplanting the original and getting the C programmers using the haskell one ;]
04:37:21 <Andris> well, at the moment I just need some way to get pixels from png file into some form operable by Haskell (even [[Int]] will do)
04:38:13 * EvilTerran usually uses an existing program (IrfanView or something) to convert the image to PPM or suchlike, then manipulates the image from that
04:38:33 <Andris> well, sounds like a plan
04:38:42 <scook0> DRMacIver: true -- though one good use case for C-in-Haskell is when mucking about with FFI stuff
04:38:55 <DRMacIver> Also true.
04:39:01 <scook0> in the sense that it's easier to write C-in-Haskell than Haskell-in-C (as some other FFI schemes force you to do)
04:39:09 <DRMacIver> Heh. Yes. :)
04:39:34 <scook0> actually, I hear even Java has a decent (third-party) FFI these days
04:40:19 * EvilTerran is reminded of the pain involved in geting Tcl calling C functions
04:42:02 <quicksilver> the haskell FFI is enviable in its simplicity
04:42:30 <EvilTerran> and Tcl boast about how easy it's meant to be to do that
04:42:40 <DRMacIver> scook0: There seem to be 3 semi-ok FFIs for Java at the moment (two open source and one not)
04:42:53 <EvilTerran> Tcl's a stupid language, anyway. i vastly prefer haskell. =]
04:42:58 <DRMacIver> I've not really used any of them though.
04:43:25 <EvilTerran> (and, for scripting, Lua, say, is eminently more sensible than Tcl)
04:43:27 <scook0> quicksilver: the only problem is that it doesn't do structs (which is Hard)
04:44:09 * EvilTerran could envisage using tuples instead of structs; or record types...
04:44:27 <scook0> it would be nice to have a lightweight FFI-helper library that can create struct-interfaces dynamically from a struct declaration ...
04:44:28 <quicksilver> scook0: right
04:44:37 <quicksilver> scook0: there are some like that I believe?
04:44:39 * EvilTerran had assumed there was some way of dealing with structs, actually
04:44:41 <quicksilver> greencard?
04:44:42 <Saizan> scook0: have you seen c2hs?
04:44:45 <EvilTerran> c2hs?
04:44:50 <EvilTerran> ah, beaten to the punch
04:44:54 <EvilTerran> @where c2hs
04:44:54 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
04:45:17 <scook0> can any of them work at runtime? or is there always a precompilation step involved?
04:45:29 <Saizan> precompilation
04:46:06 <scook0> it should be possible to do stuff at runtime, if you don't mind invoking GCC on the fly
04:46:25 <scook0> just a matter of actually implementing it ;)
04:46:29 <Saizan> well i suppose you can using hs-plugins after
04:46:53 <quicksilver> not sure what you mean by that at all?
04:47:06 <quicksilver> presumably the C library you want to interface with you choose at compile-time
04:47:37 <scook0> preprocessing adds extra complexity at build time
04:47:53 <scook0> which is fine in most cases, but sucks if you're trying to do something quick-&-dirty
04:48:24 <quicksilver> invoking gcc at runtime adds a LOT more complexity than that :)
04:48:27 <quicksilver> IMHO
04:48:30 <scook0> (my imagined use case is quick one-off bindings, when the library you want doesn't have a proper binding)
04:48:40 <quicksilver> right, but haskell has a compilation step anyway
04:48:50 <quicksilver> all we're saying is, shove this into the compilation step :)
04:49:01 <quicksilver> ok, at some level it's an extra step, because it's an external tool
04:49:11 <quicksilver> but step back a bit and 'pretend' c2hs is just part of ghc
04:49:17 <quicksilver> now it's just one compilation step :)
04:49:20 <scook0> in my mind it makes perfect sense, but it's hard to explain adequately
04:49:30 <quicksilver> scook0: you know, I have that experience *all* the time
04:49:36 <quicksilver> I may have to quote you on that one, though
04:49:48 <quicksilver> @remember scook0 in my mind it makes perfect sense, but it's hard to explain adequately
04:49:48 <lambdabot> Done.
04:50:34 * EvilTerran hand-writes the "foreign import" statements if he only needs a couple of functions
04:50:54 <scook0> EvilTerran: yeah, that's the sort of thing I'm getting at
04:51:07 <scook0> but it falls over if you want to call functions that deal in structs
04:52:09 <scook0> e.g. if I want to call nice(2), that's two lines of pure Haskell FFI
04:52:16 <quicksilver> in fact, while I'm remembering stuff
04:52:35 <quicksilver> @remember ChilliX This is GHC after all, it tries to gently nudge you in the right direction, but if you insist, it happily lets you drill arbitrarily large holes in your foot.
04:52:35 <lambdabot> Done.
04:53:02 <scook0> but trying to call a native function that takes (say) a very simple struct argument requires much more effort
04:53:52 <scook0> stuff like c2hs is too heavyweight (imo) for one-off, throwaway FFI
04:54:12 <quicksilver> well it's true that it's annoying
04:54:23 <scook0> so I imagine a library
04:54:33 <scook0> that takes a struct declaration
04:54:36 <quicksilver> but a library is the wrong approach
04:54:44 <quicksilver> you can't expect to have a header file around at runtime
04:54:53 <scook0> feeds it to GCC, with some cunningly-inserted offsetof
04:54:55 <quicksilver> you've got to fetch the struct defn at compile-time surely
04:55:03 <scook0> takes the results, and dynamically does peeks/pokes
04:55:35 <scook0> well, you could precompile the declaration, and just load the offsets at runtime
04:55:43 <scook0> (or even bake generated offsets into your program)
04:56:13 <scook0> I understand your "that's the wrong way to do it" stance
04:56:20 <Saizan> reimplement c2hs in TH so it's not a preprocessor?:)
04:56:29 <scook0> but in my view, any "right" approach is too heavy for the use case I have in mind
04:58:57 <quicksilver> there's also the issue with the runtime approach that a malicious header file could actually segfault your program :)
04:59:03 <quicksilver> or worse, allow code injection
04:59:47 <scook0> you're quite right, of course
05:04:00 <tuomov_> @hpaste
05:04:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:04:25 <hpaste>  tuomov pasted "Bug in 6.6?" at http://hpaste.org/2746
05:04:54 <tuomov_> that seems to work in ghc 6.4.2, but 6.6 complains of illegal instance declarations and fundep coverage conditions
05:05:10 <Saul__> @src Error
05:05:10 <lambdabot> class Error a where
05:05:10 <lambdabot>     noMsg  :: a
05:05:10 <lambdabot>     strMsg :: String -> a
05:05:13 <tuomov_> known?
05:06:19 <ChilliX> tuomov_: 6.4.2 was too liberal
05:06:38 <tuomov_> it's insane if that's not allowed
05:06:48 <tuomov_> fundeps are beginning to seem worthless. You can't really do anything with them
05:07:08 <ChilliX> Little to do with insanity.  More a better of when type checking become sundicidable.
05:07:17 <tuomov_> just an academic hack that you can't use for real programming...
05:07:30 <quicksilver> that's a strange thing
05:07:35 <ChilliX> Or more precisely when deciding whether specific declarations guarantee decidable type checking.
05:07:47 <quicksilver> so all these real programs out there written in haskell are actually academic hacks then? :)
05:07:53 <ChilliX> tuomov_: you can always use -fallow-undecidable-instances
05:08:04 <tuomov_> how's that undecidable
05:08:35 <ChilliX> tuomov_: The compiler cannot decide whether your declarations lead to potentially non-terminating type checking.
05:08:48 <tuomov_> that statement is a tautology
05:08:59 <quicksilver> the instance you show for Foo is, incidentally, not relevant to the example
05:09:02 <ChilliX> This does *not* mean that they make type checking undecidable.  It *just* means the compiler cannot tell, and needs to stay on teh safe side.
05:09:13 <ChilliX> tuomov_: which statement?
05:09:31 <tuomov_> that definition of undecidability... doesn't answer my question
05:09:39 <quicksilver> tuomov_: it's not a tautology; there are some programs for which the compiler *can* prove termination
05:10:02 <quicksilver> tuomov_: and the various conditions identify a conservative class of programs for which the compiler can prove it
05:10:07 <scook0> the compiler fails to prove to itself that your program is decidable
05:10:10 <quicksilver> you can turn the conditions off
05:10:17 <ChilliX> tuomov_: quicksilver is right
05:10:25 <tuomov_> bah, I think I'll just use C
05:10:28 <tuomov_> this haskell is worth nothing
05:10:34 <ChilliX> tuomov_: good idea!!
05:10:55 <tuomov_> it supposedly has a great type system, but in the end it can't do anything
05:11:02 <ChilliX> The compiler can't even solve the halting problem, must be worthless!
05:11:02 <quicksilver> yeah, I love the multi-parameter type class inference algorithm in C
05:11:06 <tuomov_> and you end up writing things as poorly typed as in C
05:11:13 <mr_tenor> you do?
05:11:20 <mr_tenor> i'm doing it wrong then :(
05:11:24 <tuomov_> quicksilver: multiparameter typeclasses and fundeps are _worthless_
05:11:31 <tuomov_> they're of no use, because the compiler is too stupid
05:11:36 <quicksilver> I've used them in many programs
05:11:40 <quicksilver> so they have worth to me
05:11:48 <tuomov_> everywhere I try to use them, I run into the compiler being too stupid
05:11:49 <ChilliX> tuomov_: we clearly must develop more intelligent compilers!
05:11:55 * ChilliX 's research agenda is set!
05:12:21 <tuomov_> it's easier to just stay away, and write poorly-typed code, like C... i.e. just write C
05:12:35 <ChilliX> tuomov_: nah, C is for wussies, write assembly!
05:13:01 <scook0> ChilliX: but make sure you use a typed assembly language!
05:13:14 <ChilliX> scook0: hehehe
05:13:21 <mr_tenor> scook0: http://lambda-the-ultimate.org/node/2450 ? ;)
05:13:23 <lambdabot> Title: Compositional type systems for stack-based low-level languages | Lambda the Ulti ...
05:13:35 <quicksilver> as I understand it, you're hoping that the compiler will take context into account when resolving instances
05:13:36 * Lemmih imagines tuomov_ writing proprietary C code on Windows ME.
05:13:54 <quicksilver> I'm not very good at expressing this, but basically contexts work in the other direction
05:14:02 <quicksilver> they aren't used to reduce the resolution search space
05:14:20 <ChilliX> tuomov_: incidentally, what's your issue with -fallow-undecidable-instances ?
05:14:24 <scook0> mr_tenor: more like http://www.cs.cornell.edu/talc/ perhaps
05:14:27 <lambdabot> Title: Typed Assembly Language
05:14:33 <tuomov_> that thing I pasted is so _trivial_
05:14:47 <tuomov_> and yet the compiler starts complaining
05:14:48 <scook0> (I remember there being a chapter on it in ATTaPL, but I don't remember any details)
05:14:59 <mr_tenor> scook0: ooo
05:15:06 <ChilliX> tuomov_: Do you know what the first thing is that I tell my first-year students?
05:15:41 <tuomov_> stay away from computers, they suck?
05:15:54 <scook0> ChilliX: 'When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.' -- Alan Perlis ?
05:16:05 <pejo> ChilliX, "Hi, I will be the teacher of this class"?
05:16:12 <ChilliX> pejo: lol
05:16:43 <ChilliX> Well, actually the first thing is just nonsense like "Welcome to COMPXYZV..."
05:16:47 <ChilliX> After that!!
05:16:52 <tuomov_> it seems basic Hindley-Milner is the best that can be had; nothing beyond it works well enough to be useful for practical programming
05:17:01 <tuomov_> and even Hindley-Milner is a bit too limited for that
05:17:14 <ChilliX> tuomov_: ok, I'll tell you anyway ;)
05:17:44 <ChilliX> I tell my first-years students that they have to get over the illusion, the propaganda fed to them, that computers are smart.
05:18:14 <tuomov_> ah, but computers indeed are as stupid as the people who created them, and people are very stupid, it seems
05:18:17 <ChilliX> As really, computers are the most stupid, the most absolutely and incredibly dump things they'll ever come across.
05:18:32 <mr_tenor> dumb
05:18:40 <MyCatSchemes> Imagine a golem with a pen in its hand and a lot of paper...
05:18:51 <ChilliX> tuomov_: you are missing the point, computers are inherently dumb (thanks mr_tenor)
05:18:52 <MyCatSchemes> I'd go back even further than that, if I were you.
05:19:22 <balodja> Who said that computer can be not stupid?
05:19:25 <scook0> ah, but the beauty of computers is that they can be stupid *millions of times a second*
05:19:34 <MyCatSchemes> Start from, "Computers are not magic." *Then* progress to, "Computers are not alive, smart, intelligent or sentient."
05:19:41 <ChilliX> scook0: indeed, that's their strength
05:19:44 <mr_tenor> the sort of stupidity that causes consistent logical behavior is something i aspire to
05:20:16 <ChilliX> balodja: tuomov_ complained that ghc is stupid, and I tried to explain that that's less ghc's problem as that of the machine executing ghc
05:20:23 <tuomov_> C's type system is actually more expressive, than Haskell's!
05:20:33 <tuomov_> for my purposes anyway
05:20:48 <scook0> it's also unsound
05:20:55 <tuomov_> can't even encode the size of a low-level structure in it; C has 'sizeof'
05:21:22 <wli> Computers are overgrown calculators, for the most part.
05:21:43 <quicksilver> you certainly can encode the size of a low-level structure in haskell
05:21:52 <balodja> tuomov_: unbelievable!
05:21:59 <quicksilver> but the details are more subtle because you're working on a more powerful system
05:22:02 <mr_tenor> tumov_:sizeof doesn't give you guarantees about anything though
05:22:19 <quicksilver> you don't normally choose to control how structures are stored in memory
05:22:24 <quicksilver> because that's not normally useful
05:22:28 <quicksilver> if you want to, you can, though
05:22:32 <tuomov_> that's very useful for disk access
05:22:43 <quicksilver> what you normally want to do, is control how they are stored in disk, or over the network
05:22:53 <quicksilver> and that you can do very powerfully in haskell
05:22:53 <tuomov_> haskell programs live in their small world that doesn't access the outside world, except through inefficient text streams...
05:23:05 <quicksilver> and that's also not true
05:23:06 <tuomov_> (and the support for those is crappy too)
05:23:13 <scook0> see, now you're just trolling
05:23:14 <balodja> tuomov_: may be you not haskell?
05:23:18 <quicksilver> you don't appear to know very much about haskell, I'm afraid
05:23:19 <scook0> at least before you sounded credible
05:23:26 <mr_tenor> it's a common technique to have the last member in a struct as a sort of placeholder name for memory going off the end of a struct which has been cast... so the 'size" of a "structure" isn't really meaningful as part of a type system
05:23:56 <mr_tenor> a "struct" is sort of a temporary naming scheme for a random bit of memory
05:24:53 <mr_tenor> It's overused, but "You can't prove anything about a program written in C or FORTRAN. It's really just Peek and Poke with some syntactic sugar." (Bill Joy)
05:25:06 <tuomov_> and how do you calculate the size of a structure from the sizes of the components, automatically?
05:25:10 <tuomov_> C does that..
05:25:24 <int-e> tuomov_: because C programs care.
05:25:25 <ChilliX> mr_tenor: lol @ peek and poke
05:25:39 <quicksilver> tuomov_: make it an instance of Binary or Storeable
05:25:50 <tuomov_> quicksilver: calculating sizes manually..
05:25:51 <MyCatSchemes> mr_tenor: what, typedef struct { size_t size; foo* data[1]; } foolection; then later { foolection* bleargh = malloc(sizeof(foolection) + (sizeof(foo*)*(n_items_required-1)); ?
05:26:02 <ChilliX> :t Foreign.Storable.peek
05:26:06 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
05:26:16 <MyCatSchemes> mr_tenor: and other (evil, heehee) tricks with arrays on the ends of structs?
05:26:16 <ChilliX> :t Foreign.Storable.poke
05:26:18 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> a -> IO ()
05:26:22 <quicksilver> tuomov_: not if you use a deriving scheme, no
05:26:35 <ChilliX> Clearly, Haskell is a superset of C..got peek and poke!
05:26:37 <mr_tenor> MyCatSchemes: things like that..also when people build classes andvtablesand inheritance in C :)
05:26:51 <mr_tenor> ChilliX: it
05:26:56 <mr_tenor> 's true though
05:27:16 <MyCatSchemes> mr_tenor: building classes, vtables and inheritance in C probably usually beats the Hell out of using the ones that C++ provides at least half the time, though. ;)
05:27:22 <ChilliX> mr_tenor: oh, I don't doubt it
05:27:35 <mr_tenor> yeah, at least there's only as much magic there as you put yourself
05:27:41 <tuomov_> and that's dynamic calculation; so no better than C
05:28:02 <int-e> tuomov_: you want to use C. nobody is stopping you.
05:28:09 <MyCatSchemes> tuomov_: now you're kind of talking out of you're arse here.
05:28:09 <ChilliX> tuomov_: ok, was funny for a while, but don't you want to join #perl now?
05:28:17 <tuomov_> I wanted to use Haskell.. but I think it was a mistake now
05:28:29 <tuomov_> in the end, you can't express anything any better than in C
05:28:49 <mr_tenor> the C type system does not tell you anything useful, that's the problem
05:28:53 <MyCatSchemes> tuomov_: because if you actually care about exactly what the structures look like on disk, you have to jump through hoops to make sure you're writing the correct endianness and, Hell, integer sizes.
05:29:00 <tuomov_> the haskell type system tells little useful
05:29:04 <mr_tenor> if you know useful things, it's due to YOU andnot the typesystem
05:29:15 <scook0> mr_tenor: it tells you "your program is written in C; it will probably segfault" ;)
05:29:21 <tuomov_> MyCatSchemes: and I've tried to encode that in the type system... with little luck
05:29:40 <tuomov_> always run into some limitation
05:29:40 <MyCatSchemes> tuomov_: why would you need to, realistically?
05:29:50 <fasta> Is there any problem with calling runInteractive process with a combination of waitForProcess in a loop? It seems that doing it once is OK, but doing it like hundreds of times blows up.
05:29:52 <tuomov_> to have something better than C would provide?
05:30:06 <tuomov_> but apparently that's not possible
05:30:14 <mr_tenor> impossibility proofs are nontriial
05:30:44 <balodja>  <tuomov_> and that's dynamic calculation; so no better than C
05:30:50 <balodja> dynamic? O_O
05:31:06 <int-e> tuomov_: use -fundecidable-instances. this option exists precisely because the coverage condition is known to be too strong. but there is no known simple condition on class instances that guarantees termination of type checking and type inference in the presence of functional dependencies that also allows all interesting uses of them.
05:31:17 <mr_tenor> "No dynamics? We're playing as loud as we can"
05:31:19 <balodja> It seems, that you know nothing about haskell's types
05:31:43 <MyCatSchemes> balodja: It seems, that your comma is erronous and should be taken out and shot. :)
05:31:45 <int-e> tuomov_: if you can come up with a better one I'm sure people like spj will be happy to hear about it.
05:31:55 <tuomov_> int-e: I dont' want to use such options that could make the compiler run into trouble in other places
05:32:09 <tuomov_> next time I'm trying to hack something, the compiler just hangs
05:33:32 <ChilliX> tuomov_: nah, you misunderstand
05:33:52 <ChilliX> -fallow-undecidable-instances does not mean the compiler is going to loop
05:33:54 <int-e> tuomov_: it doesn't run into trouble in other places
05:34:09 <ChilliX> it just means the obligation of checking that it will not loop is on you (not the compiler)
05:34:10 <balodja> MyCatSchemes: may be
05:34:17 <tuomov_> what's it for then?
05:34:20 <int-e> tuomov_: if type checking terminates the result will be correct.
05:34:35 <int-e> tuomov_: for having an a priori guarantee of termination.
05:34:49 <tuomov_> just what I said
05:34:56 <tuomov_> the compiler may not terminate
05:35:09 * wli wonders where the video game people are.
05:35:22 <MyCatSchemes> wli: what video game people?
05:35:53 <wli> There's a crew of people on #haskell who at least say they want to write video games.
05:36:09 <wli> Maybe 2-3 people.
05:36:38 <EvilTerran> hm?
05:36:40 <mr_tenor> years ago i wanted to. somehow i ended up pricing financial instruments instead. whoops.
05:36:49 <quicksilver> I'm certainly writing a game, for fun.
05:37:01 <quicksilver> I probably wouldn't use the phrase 'video game' though
05:37:21 * MyCatSchemes is interested in the idea, but has no fast hardware to play with currently.
05:37:25 <mr_tenor> quicksilver: i've heard that programming the GBA can be a hoot
05:37:55 <ChilliX> wli: I got another honours thesis student hacking Frag
05:38:04 <ChilliX> wli: it;'s going to have an AI!
05:38:42 <mr_tenor> lambdabot?
05:38:49 <fasta> mr_tenor: Frag..
05:39:01 <ChilliX> @where Frag
05:39:01 <lambdabot> http://www.haskell.org/haskellwiki/Frag
05:39:24 <mr_tenor> fasta: i know. i was suggesting that... nm. joke's ruined :(
05:39:34 <int-e> sigh. in other programming languages, nonterminating compilers are the default.
05:39:43 <int-e> (I mean C++)
05:39:52 <ChilliX> int-e: yeah...
05:40:10 <fasta> int-e: standard compliant compilers are not
05:40:15 <fasta> int-e: (C++)
05:40:51 <ChilliX> fasta: well, anybody can put in a dynamic termination condition
05:41:04 <fasta> ChilliX: ?
05:41:38 <ChilliX> fasta: AFAIK standard C++ gets around the non-termination by statically limiting the unfoldings (or similar)
05:41:49 <fasta> ChilliX: Yes, I just said that.
05:41:56 <olsner> I thought a standards-compliant C++ compiler has to be nonterminating (if templates is what you're refering to), whereas most compilers just make sure they run out of stack rather than looping
05:42:21 <ChilliX> fasta: well, that's what we call a dynamic termination condition, sorry for being cryptivc
05:42:55 <fasta> I call some Python program a few hundred times in a loop in Haskell. This fails when I feed ever increasing values to the Python program upto lets's say size X. But when I run the Python program from the command line I can call it with size Y >> X.
05:43:00 <fasta> What's going on?
05:43:03 <ChilliX> but that's not a solution, it's a ludge
05:43:07 <ChilliX> kludge, even
05:43:19 <fasta> ChilliX: who is "we"?
05:43:37 <gip> @index catch
05:43:37 <lambdabot> Control.Exception, System.IO.Error, Prelude
05:43:45 <gip> @t catch
05:43:46 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
05:43:46 <ChilliX> fasta: people like SPJ, Martin Sulzmann and me when we discuss this stuff
05:43:52 <gip> @type catch
05:43:54 <ChilliX> I think Martin starte dusing this term
05:43:54 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
05:43:54 <fasta> ChilliX: there are 5 hits on Google for that phrase.
05:44:04 <fasta> ChilliX: so, I don't accept that "definition".
05:44:12 <fasta> ChilliX: and even less in that context
05:44:13 <wli> Okay, I see Frag.
05:44:17 <quicksilver> fasta: something like a blocking IO / buffering issue maybe?
05:44:45 <fasta> ChilliX: In fact, I think you misunderstood the concept
05:44:54 <quicksilver> fasta: what's the nature of the "failure"?
05:45:02 * quicksilver thinks it unlikely that ChilliX misunderstood :P
05:45:02 <fasta> ChilliX: I see the article where they use it, and it's not the same as you claim it to be
05:45:15 <wli> ChilliX: Interesting.
05:45:18 <ChilliX> fasta: hahaha - but then "we" write the papers about this stuff at the moment, so don't we get to define the terminology?? ;)  (I am not entirely serious, in case that's not apparent)
05:45:48 <wli> ChilliX: I was having thoughts on AI because commercial games' AI is so... retarded.
05:45:58 <fasta> ChilliX: you wrote the article [PS]
05:45:59 <fasta> Sound and Decidable Type Inference for Functional Dependencies?
05:46:06 <ChilliX> wli: I agree "retraded" petty much characterises it
05:46:29 <chessguy> @type uncurry
05:46:31 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:46:34 <fasta> ChilliX: I don't know your real name, so there's no way for me to know whether you know.
05:47:00 <ChilliX> aha, sorry, http://www.cse.unsw.edu.au/~chak/
05:47:01 <lambdabot> Title: Manuel M T Chakravarty
05:47:09 <wli> ChilliX: I vaguely wonder if any of those people have heard of fire and maneuver tactics or similar.
05:47:22 <chessguy> @src uncurry
05:47:23 <lambdabot> uncurry f p = f (fst p) (snd p)
05:47:28 <ChilliX> wli: which people?
05:47:38 <quicksilver> wli: I suspect that commercial game AI isn't crap because they don't work hard on the problem
05:47:45 <quicksilver> wli: I suspect it's crap because they have a different goal
05:47:45 <wli> ChilliX: The ones who did the AI's for commercial games.
05:47:54 <fasta> quicksilver: the nature of the failure is unknown to me. I read stdout and stderr of the Python process. I write stderr to stdout to see whether the Python process halts. This does not happen.
05:48:02 <quicksilver> wli: their goal is to make the game 'fun' and balance the difficult curve
05:48:04 <chessguy> @pl \f p -> f (f' p) (s p)
05:48:05 <lambdabot> (`ap` s) . (. f')
05:48:13 <quicksilver> wli: so they cheat without any particular ill-feeling :)
05:48:18 <quicksilver> wli: just to get the curve feeling right
05:48:27 <ChilliX> wli: hmm, not sure, but I think it is a hard problem (esp given the soft realtime constraints imposed by the framerate)
05:48:32 <osfameron> that's an intelligence of sorts :-)
05:48:46 <osfameron> real soldiers should also optimize for fun!
05:49:00 <quicksilver> fasta: do you write to it and also read from it?
05:49:08 <fasta> quicksilver: no
05:49:22 * quicksilver nods
05:49:26 <quicksilver> just read from it
05:49:39 <fasta> quicksilver: I just call the program and read stdout (and later also stderror)
05:49:40 <wli> quicksilver: Well, an obvious thought is to inject errors into the AI "thought process" or find tunables to create sliding scales of combat effectiveness while having tactics that don't bore the living daylights due to trivial exploitability.
05:50:00 <Sizur> the real problem is that a good AI is _VERY_ demanding computationally
05:50:05 <quicksilver> wli: true. but it's easier to just cheat until the difficulty curve feels right :)
05:50:30 <fasta> Sizur: have you ever seen an aimbot?
05:50:32 <quicksilver> wli: the most important thing is that the game is easy enough for new players to play the 'first few' levels and challenging enough..
05:50:37 <ChilliX> quicksilver: well, but this only works in games where the human player doesn't get to reap and train much
05:50:45 <Sizur> fasta: you mean it's implementation?
05:50:52 <quicksilver> ChilliX: reap and train?
05:51:03 <ChilliX> quicksilver: it depends on the game
05:51:06 <wli> Sizur: It doesn't need to be a good AI. The tactics just need to be something less idiotic than the things walking right into your blowing them away.
05:51:07 <ChilliX> reap = repeat
05:51:10 <fasta> Creating a "fun" AI is the problem in games.
05:51:13 <quicksilver> ChilliX: *nod*
05:51:18 <fasta> Not something that can crush the human
05:51:34 <wli> quicksilver: See the above. The problem is that the AI is so phenomenally stupid it makes the game boring.
05:51:36 <quicksilver> ChilliX: I suspect (although it depends what kind of game that we're talking about) they write the AI to make "one play-through" fun
05:51:53 <ChilliX> quicksilver: AI that is challanging the first time around just gets rediculous once you practice a bit
05:52:02 <quicksilver> ChilliX: a game which people play over and over again (e.g. a network multiplayer game) ... right... what you just said
05:52:14 <ChilliX> quicksilver: exactly
05:52:18 <fasta> There are games where it's difficult to create an AI for (e.g. Go), but in most games the AI beats the best humans already.
05:52:25 <Sizur> well, my beef is with MMORPGs having no AI at all. that's because they design the game universe to reside on one machine
05:53:06 <wli> This isn't really an issue with the AI being super-intelligent. It's more like the AI existing in any nontrivial sense at all.
05:53:35 <wli> i.e. the enemies not being so stupid it makes the game boring.
05:53:41 <alexeevg> Hi all! I've just built lambdabot and now I'm getting 'Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString'. Googling has brought only some IRC logs. How to fix it?
05:53:57 <Sizur> wli: you are right, but then there are time issues and pressure to push the product out of the doors
05:53:57 <ChilliX> wli: I completely agree; hence, you hav to play humans
05:54:12 <wli> Also, when you have AI allies their stupidity really burns you up.
05:54:17 <quicksilver> wli: true
05:54:22 <ChilliX> wli: true, too
05:54:30 <quicksilver> wli: commercial games have tended to focus on domains where that's not very important
05:54:31 <scook0> wli: clearly you've never played online with *real* humans ;)
05:54:43 <ChilliX> scook0: hehehe
05:54:46 <wli> scook0: I have. I get slaughtered every time.
05:54:51 <quicksilver> wli: because the payoff for getting the AI good is not great compared to the cost
05:55:01 <ChilliX> scook0: but the humans improve, well, at l;east some of them
05:55:13 <wli> quicksilver: 100% deathmatch with no AI involved whatsoever?
05:55:44 <ChilliX> wli: deatchmatch is not even that demanding on an ai, try css
05:55:45 <quicksilver> wli: I was thinking more of "adventure" games where you progress from level to level
05:55:47 <wli> Actually since I got LASIK my hand-eye coordination and reflexes have been improving wildly.
05:55:57 <quicksilver> wli: the "AI" is normally a fixed script
05:56:00 <wli> quicksilver: Okay, wat about them?
05:56:08 <quicksilver> wli: it's tweaked to catch you out the first time you play that level
05:56:17 <quicksilver> wli: but once you work out what the AI is going to do, you're informed
05:56:25 <quicksilver> wli: so it is (at worst) 'hard the first time'
05:56:38 <quicksilver> and then it's like "well he's going to come around the left of that pillar, so I..."
05:56:44 <wli> quicksilver: And a sort of built-in planned obsolescence?
05:56:52 <quicksilver> in a way, yes :)
05:57:03 <quicksilver> the point is, they don't expect most of their customers to replay
05:57:13 <Sizur> quicksilver: that's current commercial definition of AI, but that's not AI really
05:57:13 <quicksilver> so it doesn't really matter, to saleability
05:57:25 <quicksilver> Sizur: absolutely, hence the quotes
05:57:30 <quicksilver> Sizur: wli: the "AI" is normally a fixed script
05:57:54 <quicksilver> wli: since they're not expecting people to replay, they don't spend (waste!) developer time on realistic AI
05:58:03 <quicksilver> a simple scripted behaviour with perhaps a little random variation
05:58:05 <Sizur> well, there are AI scripts and there are scripts
05:58:10 <quicksilver> is good enough for their customers
05:58:14 <Sizur> that falls under second
05:58:26 <chessguy> Sizur, there is no standard definition of AI
05:58:38 <fasta> Oh, great, let's have a millionth discussion of what AI is.
05:58:42 <quicksilver> of course, if they tried to sell a game whose success was entirely predicated on good AI
05:58:47 <Sizur> decision algorithm?
05:58:52 <quicksilver> then they'd have more incentive to work on it
05:59:00 <quicksilver> but games in that category are quite rare
05:59:06 <quicksilver> (perhaps because they're not very good at it :)
05:59:16 <chessguy> AI is very hard
05:59:27 <wli> There's a reason I don't buy many video games.
05:59:29 <chessguy> good AI, anyway
05:59:32 <scook0> chessguy: you mean in the game-AI sense, or the AI-AI sense?
05:59:43 <wli> Or otherwise that I don't like video games.
05:59:44 <Sizur> wli: why play against computer anyway
06:00:07 <quicksilver> Sizur: "why fly a kite, on your own" ?
06:00:08 <chessguy> scook0, uh, choose your poison, i guess
06:00:17 <scook0> fair enough
06:00:20 <quicksilver> Sizur: some activities are just fun. but it's subjective.
06:00:41 <quicksilver> Sizur: I have a PSP I play with on the train some times. I just enjoy the games fairly shallowly at their own level :)
06:00:57 <chessguy> e.g., to do truly good AI even at tic-tac-toe is hard
06:01:10 <wli> Sizur: Mostly I go in for co-op multiplayer; myself and co-players goofing off playing against the computer as a team.
06:01:48 <chessguy> for some definition of AI which allows for the possibility of making sub-optimal moves for the purpose of tricking the opponent
06:02:05 <Sizur> quicksilver: i play single player only for story, like PlaneScape. the rest i play multiplayer
06:03:36 <Sizur> quicksilver: but you are right, it's alway ssubjective. i just dont see sense in playing against computer
06:04:39 <quicksilver> Sizur: yes. you don't play single-player to match your skill against the computer
06:04:49 <quicksilver> Sizur: because that's not an interesting contest, in most games
06:04:58 <quicksilver> Sizur: computer vs player is asymettric, so you play an asymmetric game
06:05:05 <quicksilver> Sizur: or, as you said "for the story" :)
06:05:23 <Sizur> quicksilver: right to the point
06:05:36 <scook0> which, incidentally, is why it's hard to make a game with good single- and multi-play
06:05:42 <scook0> because of the asymmetry
06:06:15 <quicksilver> yes
06:06:24 <quicksilver> and, good games which are both, tend to actualy be different games
06:06:33 <quicksilver> they might use the same engine, but still different games really
06:06:38 <Sizur> exactly
06:08:11 <quicksilver> computer vs player works in Go (for humans who are poor go players) and chess (for humans who are good chess players)
06:08:19 <quicksilver> but most other games are too hard
06:08:30 <quicksilver> I'm not sure how the computer fares in poker. Probably poorly.
06:08:47 <scook0> but go/chess are really more like "deathmatch with bots" than traditional single-player computer games
06:09:01 <Sizur> quicksilver: actually poker AI is at advantage due to lack of emotions
06:09:20 <scook0> in the sense that the computer is merely substituting for another human
06:09:25 <Sizur> just calculate chances and approach win
06:09:59 <scook0> Sizur: though you might not be able to exploit humans as well as other humans could
06:10:15 <Sizur> there was an article recently somewhere, talking about a competition of computer against 3 best poker players
06:10:53 <quicksilver> Sizur: but the skill in poker is in judging the other players
06:10:56 <Sizur> their conclusion was that poker algorithm is applicable to business negotiations
06:11:01 <quicksilver> Sizur: and I'd think that a computer would be poor at that
06:11:15 <quicksilver> (well obviously you do also need to calculate the chances)
06:11:49 <scook0> poker isn't really a card game
06:12:50 <ibid> the skill in poker is in being as accurate as you can about your odds (which the computer does really well) and in predicting accurately the times when the opponents fail to play optimally :)
06:13:28 <Sizur> in a sense that computer was not reading human faces for tale-tales, but human always impersonates computer so computer is again at advantage because human's emotions will be as high as against another human (especially when money is involved)
06:14:30 <quicksilver> Sizur: but my speculation would be that, in a tournament with players of a wide ability range
06:14:40 <quicksilver> Sizur: the good humans would beat the poor humans by a larger margin
06:14:46 <quicksilver> than the computer beats the poor humans
06:14:57 <quicksilver> because the good humans would read when to bluff and when to call, against the poor humans
06:15:09 <Sizur> without data, i agree with you. it makes sense
06:15:14 <quicksilver> althouhg I could believe that the computer would beat the good human head to head
06:15:23 <scook0> yeah, that's what I was hinting at before
06:15:25 <quicksilver> this is all speculation from my limited experience of poker though :)
06:15:46 <scook0> (good humans can exploit bad humans better than a computer can)
06:15:54 <Sizur> in poker
06:15:57 <MyCatSchemes> What libraries are the games-in-Haskell nutters writing against, anyway?
06:16:01 <ibid> i think there are two kinds of poor humans to consider: those that don't know the odds and those who are bad at reading others or masking themselves
06:16:05 <Sizur> and in business negotiations
06:16:17 <quicksilver> MyCatSchemes: I'm using openGL
06:16:59 <scook0> nothing stopping you from using putStrLn if you're more interested in the game than the interface
06:17:19 <chessguy> itnerestingly, chess engine authors frequently build into their engines the ability to change their play depending on whether they're playing against a computer or a human
06:17:21 <MyCatSchemes> quicksilver: GLUT sounds sensible enough for graphics and for mouse and keyboard interface, but that doesn't give you any access to sound or joysticks. :/
06:17:33 <olsner> from Verbing to Scheming... that cat's upgrading
06:17:38 <quicksilver> MyCatSchemes: I imagine if I get to that point I'll investigate SDL
06:17:50 <quicksilver> MyCatSchemes: but I don't care much about sound or joysticks :)
06:18:30 <MyCatSchemes> olsner: :)
06:19:13 <MyCatSchemes> quicksilver: ahhh. That is slightly problematic to me, because I do.
06:19:43 <mrd> gtk-GLext works
06:19:44 <gip> I have a function readu s = fst . head . readFloat $ s. It may crash on empty list, so I'd like to modify it to return Maybe.. What is the best to write this plz?
06:19:59 <mrd> SDL provides sound and joystick support
06:20:15 <scook0> @hoogle [a] -> Maybe a
06:20:16 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
06:20:16 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
06:20:21 <quicksilver> gip: write a version of head which returns a maybe
06:20:26 <quicksilver> gip: or, use listToMaybe
06:20:29 <quicksilver> gip: which that is :)
06:20:34 <Sizur> i'm much more concerned with haskell lacking i18n and a good IDE to integrate literate, annotated, testable, interactive code
06:20:36 <quicksilver> then change your fst to a 'fmap fst'
06:20:42 <MyCatSchemes> Are there Haskell bindings for SDL, I wonder? Though presumably it wouldn't be intractable to write them, I do not actually have a clue how.
06:20:42 <gip> @type listToMaybe
06:20:44 <lambdabot> forall a. [a] -> Maybe a
06:20:46 <chessguy> @src listToMaybe
06:20:46 <lambdabot> listToMaybe []        =  Nothing
06:20:47 <lambdabot> listToMaybe (a:_)     =  Just a
06:20:54 <oerjan> > let hack ~(x:y)=(x:y) in fix (show.map ord.hack)
06:20:57 <lambdabot>  "[91,57,49,44,53,55,44,52,57,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44...
06:20:57 <chessguy> ugh, that's a bad name
06:20:58 <quicksilver> gip: so it becomes fst `fmap` head . readFloat $ s
06:21:02 <mrd> MyCatSchemes: pretty sure there are
06:21:10 <gip> quicksilver : thanks, exactly what I need
06:21:15 <quicksilver> @t fst `fmap` listToMaybe . readFloat $ s
06:21:15 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
06:21:19 <quicksilver> :t fst `fmap` listToMaybe . readFloat $ s
06:21:21 <lambdabot>     precedence parsing error
06:21:21 <lambdabot>         cannot mix `fmap' [infixl 9] and `(.)' [infixr 9] in the same infix expression
06:21:24 <MyCatSchemes> Oh hey, hsdl.sf.net
06:21:29 <MyCatSchemes> Awesome.
06:21:29 <quicksilver> :t (fmap fst) listToMaybe . readFloat $ s
06:21:31 <lambdabot> Not in scope: `s'
06:21:32 <gip> @type fmap
06:21:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:21:38 <quicksilver> :t \s-> (fmap fst) listToMaybe . readFloat $ s
06:21:40 <lambdabot>     Couldn't match expected type `(a, b)'
06:21:40 <lambdabot>            against inferred type `Maybe a1'
06:21:43 <quicksilver> grr
06:21:44 <quicksilver> I suck
06:21:49 <quicksilver> :t \s-> (fmap fst) . listToMaybe . readFloat $ s
06:21:50 <quicksilver> at last ?
06:21:51 <lambdabot> forall a. (RealFrac a) => String -> Maybe a
06:21:54 <quicksilver> yay :)
06:22:01 <gip> :) Great
06:22:01 <MyCatSchemes> Hmmmm. "Very incomplete", as of 2006-05-22. :/
06:22:16 <quicksilver> MyCatSchemes: yes, it is hsdl I was speaking of, but I wasn't sure if it was usable
06:22:46 <quicksilver> mrd: gtk-GLext is less interesting to me until gtk has native OSX support
06:22:51 <quicksilver> mrd: although it would be an option
06:22:52 <wli> Well, my thoughts on game AI are not actually particularly advanced. Just bonehead squad tactics, simple things like peeking around corners, ec.
06:23:18 <wli> First and foremost taking up positions.
06:23:41 <quicksilver> wli: it would certainly be fun to have a system in which you could experiment
06:23:57 <quicksilver> wli: at the moment, it's about 5 man-years of work to make a state-of-the art team FPS
06:24:07 <quicksilver> wli: which is a long time to wait before you can try out AI experiments :)
06:24:28 <fasta> quicksilver: you mean a game without graphics?
06:24:35 <wli> quicksilver: Which is why I was sort of hoping there was already a game out there.
06:24:44 <quicksilver> fasta: I'm not sure really. Maybe simplistic graphics to represent the state of the world
06:24:55 <mrd> 5 man-years sounds way low
06:25:06 <quicksilver> fasta: but with more of a focus on providing a test-bed for AI experimenation
06:25:07 <Sizur> wli: quake supports scription, doesnt it?
06:25:14 <Sizur> scripting*
06:25:16 <quicksilver> mrd: that's what one of the unreal engine 3 devs told me
06:25:27 <MyCatSchemes> quicksilver: usable? In a word, "no."
06:25:28 <mrd> is he counting making the engine and the art etc
06:25:33 <quicksilver> mrd: of course man-years are a bit mythical :)
06:25:36 <fasta> quicksilver: oh, building just an engine is not the most work.
06:25:45 <quicksilver> mrd: not really sure. I think he just meant the engine and the tool suport
06:25:47 <MyCatSchemes> quicksilver: the short version (as opposed to the one-word version) is, "Nope, not nearly."
06:25:49 <mrd> most good games have been going for years of development by many people
06:25:51 <fasta> quicksilver: e.g. the Q3 engine can be used today.
06:25:54 <quicksilver> mrd: the tools are massively important
06:26:07 <quicksilver> fasta: that's true. But I wonder if it is a good basis for the kind of thing wli wants
06:26:09 <Sizur> there are excellent 3d engines already available, why build from scratch
06:26:11 <quicksilver> fasta: (I don't know the answer)
06:26:32 <mrd> like BioShock, which uses the Unreal 3 engine, but was in devel for over  2 years anyhow
06:26:45 <quicksilver> I don't know if, for example, Q3's physics engine makes assumptions which are unhelpful
06:26:51 <quicksilver> or uses annoying data structures
06:26:52 <MyCatSchemes> quicksilver: longer versions include, for example, "This HSDL thing? Not even nearly *resembling* a state of readiness. I mean, crikey on a stick, ladies and gentlemen, this thing's makefiles assume that you're on Mac OS X and using ghc 6.0.1 *exactly*."
06:27:12 <quicksilver> MyCatSchemes: there is also HsSDL
06:27:22 <quicksilver> MyCatSchemes: I don't know if that's any closer, or if it's further away
06:27:27 <quicksilver> Lemmih: does HsSDL work?
06:27:38 <fasta> The problem of AI is that it's not economical to build one on the short term.
06:28:01 <fasta> Google doesn't have AI, they just solve one problem very good.
06:28:09 <Sizur> the unual solution is to create AI language for your game
06:28:12 <Sizur> usual*
06:28:37 <fasta> The amount of hardware Google has, though (assuming low-interconnect speed) will probably be enough to build one, though.
06:29:06 <quicksilver> MyCatSchemes: HsSDL looks much more promising to me
06:29:12 <mrd> the description of the oblivion AI struck me as something pulled out of AIMA.  unfortunately, it ended up kinda sucking.
06:29:31 <MyCatSchemes> quicksilver: thanks. :)
06:29:34 <Sizur> mrd why was it sucking?
06:29:39 <scook0> hyped-up game AI tends to disappoint
06:29:52 <Sizur> mrd: i found it quite advanced
06:30:12 <mrd> ever notice how all the NPCs walk down the same path =)
06:30:22 <scook0> because the user generally never sees half the cool stuff the dev is aware of
06:30:26 <mrd> it results in logjams and collisions in the imperial city
06:30:26 <quicksilver> hyped-up anything tends to disappoint? :)
06:30:39 <scook0> heh, true
06:30:43 <quicksilver> and what's happened to oblivion for PSP?
06:30:46 * quicksilver looks impatient
06:30:56 <mrd> and all the NPCs say the same stuff
06:31:02 <quicksilver> mind you if I'm playing PSP on the train, I'm not hacking haskell
06:31:07 <Sizur> oblivion on gameboy? :P
06:31:10 <quicksilver> maybe I don't *want* oblivion for PSP
06:31:13 <mrd> they go to bed at 11 am and wake up and then go right back to sleep
06:32:32 <quicksilver> @where hssdl
06:32:33 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
06:32:50 <Sizur> mrd: you will always find things like this in any kind of AI. you simply dont have enough time to think of everything
06:33:52 <MyCatSchemes> Sizur: I would prefer approaches where thinking of everything is not neccessary.
06:34:04 <Sizur> mrd: many times i was designing "the best"(tm) framework for something, and was ending up hacking stuff just to make it work in time
06:34:21 <mrd> of course, and that's what it appears happened here
06:34:34 <MyCatSchemes> Sizur: statistical methods - machine learning, generally. The wonderful thing about machine learning is that you don't have to teach the machine every damn little thing, just how to learn in general. ;)
06:34:52 <quicksilver> Sizur: what you just said to mrd reminds me of http://xkcd.com/224/
06:34:53 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
06:35:02 <MyCatSchemes> quicksilver: thanks, man.
06:35:04 <Sizur> MyCatSchemes: that's impossible. you can make it learn a specific thing, but never learn in general
06:35:51 <Sizur> OCR will never talk to you for example
06:36:21 <MyCatSchemes> Sizur: uhhh... well, for example, let it build out state machines by generating them from a genetic algorithm, for example. In theory I bet you'd end up with ant-colony-like behavoir every time.
06:36:41 <Sizur> quicksilver: yeah i saw that one earlier and loved it :)
06:36:55 <MyCatSchemes> Sizur: oh, I'm not thinking of strong AI here, Christ no, waaaaay too much work. Just enough weak-AI-fakery that you'd be able to let it run the opposition in a video game.
06:38:26 <Sizur> MyCatSchemes: point is you cannot make AI that will comeup with something outside of it's domain
06:39:30 <Sizur> MyCatSchemes: that you you must design it to solve a specific problem you have in mind.
06:39:44 <MyCatSchemes> Sizur: a) that's strong-AI talk, which is to say, too damn difficult to be worth attacking directly right now and b) videogames are pretty strictly bounded.
06:40:24 <Sizur> oblivion is way out there
06:40:43 <Sizur> it's a reality simulation attempt
06:41:08 <MyCatSchemes> Yes, and? I'm just saying that, if your problem is, "come up with viable strategies for wiping out human opponents in videogames," something like a messy-GA to generate state machines would probably work really well.
06:41:59 <MyCatSchemes> It's bounded, it's feasible. It's also really really cool and it tends not to get tripped up by excessively clever players.
06:42:10 <Sizur> ok, but variate your path for local optimums, have a sleeping "urge", these things must be defined in the first place
06:42:15 * olsner envisions a shoot-em-up/procreation game with AI players
06:44:03 <MyCatSchemes> Sizur: I understand your point about needing to define the "urge" in the first place - in videogames you can just use the usual scoring mechanism for that, luckily enough.
06:44:06 <quicksilver> olsner: we already have "shoot-up/procreation" AIs, but we call them pop stars
06:44:44 <olsner> the reverse turing test - is it an AI or a dumb human?
06:44:46 <scook0> I'm not sure I buy the "intelligence" part
06:44:47 <MyCatSchemes> Sizur: but what do you mean by, "variate your path for local optima"? If you're saying what I think you're saying, then that's already an intrinsic property of most heuristic searching methods anyway.
06:45:07 <Sizur> MyCatSchemes: my argument was aimed to explain why mrd thought oblivion's AI fell short
06:46:06 <Sizur> i meant in in a specific scenario as to why NPCs in Oblivion all walk seemingly similar paths leading to congestion in a populated area and why most NPCs go to sleep at specific times
06:46:13 <MyCatSchemes> Sizur: ah, I see. What did you mean by path variation, though? I just wanna check I wasn't misunderstanding you there.
06:46:36 <Sizur> not in Graph Theoretic sense
06:47:23 <MyCatSchemes> Ohhhhh, right.
06:47:51 <Sizur> simply there's no way to make any AI comeup with stuff like that on it's own
06:49:33 <MyCatSchemes> Well, if you attacked that specific problem - congestion - by giving each actor its own little heuristic engine for finding efficient paths simply by trying different paths sort-of-randomly to see which is most efficient, they'll tend to solve it over time, eventually.
06:50:03 <Sizur> yes if you have enough time to tackle that, sure
06:50:44 <Sizur> in a reality simulation there will always be things that are far from approximating reality.
06:50:50 <MyCatSchemes> Sizur: mmmhmmm. Bring thirty or fourty xboxen into your development studio and run these algorithms for a few straight days to generate the learned-data sets.
06:50:57 <puusorsa> ai ...
06:50:58 <puusorsa> http://www.imagination-engines.com/
06:51:00 <lambdabot> Title: Imagination Engines Inc.
06:51:19 <MyCatSchemes> Then, when you give the game to real players, it'll already have well-tuned AI pathfinding. As if by magic! ;)
06:51:53 <Sizur> MyCatSchemes: yes :) you will solve that problem, but there are infinite others to go
06:52:17 <puusorsa> and the scary part: "August 19, 1997, The Creativity Machine Patent Issues the Same Day SkyNet Becomes Conscious."
06:52:49 <fasta> puusorsa: what's that other than marketing blurb?
06:53:10 <MyCatSchemes> Sizur: sure there are lots, but, Hell, it's not as if you're trying to make the NPCs play Nethack or anything. The game's bounded. So is the set of actions you can perform in it, or would want to.
06:53:34 <fasta> For neural networks I can read a book and see the algorithm, for this imagination engine, no.
06:53:37 <osfameron> I thought neural networks were a bit of an AI dead end?   Have they actually had interesting results?
06:53:41 <Sizur> but your time and your resources are bounded more strongly ;)
06:53:42 <MyCatSchemes> Sizur: plus heuristics like GAs and simulated annealing and the like aren't particularly difficult to write anyway. >>
06:54:32 <fasta> If this imagination engine was really so smart, why haven't they started a search companay?
06:54:36 <fasta> company*
06:54:44 <puusorsa> fasta, no idea
06:54:49 <fasta> You can crush Google easily with such a device.
06:55:04 <puusorsa> but he seems to be doing stuff for us army
06:55:09 <Sizur> that imagination-engine stuff seems to be very much like a scam or simply wishful thinking
06:55:28 <fasta> puusorsa: show me the official books and I made buy it
06:55:36 <MyCatSchemes> osfameron: I remember once using a Half-Life bot (closed source, bleh) that apparently used neural networks to train ways of getting around the maps, obviating the need to spend bloody ages manually putting together waypoints (see: botman's bots, for example).
06:55:40 <puusorsa> fasta, i'm not selling
06:56:06 <puusorsa> (but you can pay me anyway)
06:56:11 <fasta> puusorsa: I know, I meant "buy this crap from the website)
06:56:15 <fasta> "
06:56:34 <Sizur> ai, they sell something too?
06:57:00 <MyCatSchemes> osfameron: part of the trick there was that, instead of just having the bots work on their *own* attempts and observations, they'd be building their paths by observing human players running around the map. Which means that all the sneaky places humans can get into but aren't neccessarily supposed to (and thus would never have thought to add to waypoint sets) suddenly become useful to the bots, too. :)
06:57:26 <gip> @hoogle evaluate
06:57:27 <lambdabot> Control.Exception.evaluate :: a -> IO a
06:57:27 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
06:57:28 <osfameron> MyCatSchemes: cute :-)
06:57:58 <quicksilver> osfameron: for very specific tasks, yes
06:58:06 <quicksilver> osfameron: funnily anough, not really what I'd call "AI"
06:58:15 <quicksilver> osfameron: mostly glorified fuzzy pattern recognition
06:58:16 <osfameron> handwriting recognition istr was one of those specific tasks wasn't it?
06:58:22 <quicksilver> osfameron: things like OCR
06:58:46 <fasta> 2.0 Non-Algorithmic Neural Networks (STANNOs)
06:58:49 <hpaste>  Mitar pasted "translate to Either?" at http://hpaste.org/2748
06:58:57 <fasta> Oh, cool, it's "non-algorithmic"
06:58:57 <Mitar> how can I translate this to Either monad?
06:59:08 <Mitar> how can I translate quards to monad?
06:59:30 <fasta> I know that this could mean something, I just don't think it does in this context
06:59:58 <puusorsa> fasta, i don't know how much that makes any sense still they seem to be doing stuff for the military
07:00:21 <puusorsa> which doesn't prove anything of course, except maybe that their marketing works
07:00:33 <MyCatSchemes> Oh, quick question. How do I get ghc to search specific places inside my own home directory rather than system-wide for libraries? Is there something similar to CPATH, LD_LIBRARY_PATH, etc?
07:00:46 <MyCatSchemes> (Please?)
07:01:17 <oerjan> Mitar: change error to fail and add return to the success one
07:01:45 <Mitar> what about guards?
07:02:32 <fasta> Computer programming, with at least 5 years working experience with 5th generation computer languages such as C
07:02:33 <scook0> Mitar: perhaps when (condition) (throwError "message")
07:02:35 <fasta> Hahahaha
07:02:38 <oerjan> there's guard, but it doesn't include an error message
07:02:40 <scook0> in a do block
07:03:18 <MyCatSchemes> fasta: ...5th!!!!?
07:03:30 <scook0> I think throwError is what's needed
07:03:39 <cognominal_> :i ($!)
07:03:43 <scook0> you could use it to implement a generalised guard if you wanted
07:03:50 <Mitar> how?
07:03:52 <MyCatSchemes> Wow, that's nuts.
07:03:56 <roconnor> @src ($!)
07:03:57 <lambdabot> Source not found. My pet ferret can type better than you!
07:04:01 <oerjan> MyCatSchemes: there's a flag for it, see the ghc user manual
07:04:09 <scook0> guardE cond err = when cond (throwError err)
07:04:27 <ibid> could we please get a non-offensive lambdabot in here? :)
07:04:28 <scook0> (throwError is in Control.Monad.Error.Class)
07:04:30 <hpaste>  quicksilver annotated "translate to Either?" with "(no title)" at http://hpaste.org/2748#a1
07:04:37 <fasta> They do have at least one guy that published something.
07:04:39 <quicksilver> Mitar: annotation made
07:04:56 <Sizur> MyCatSchemes:  did you need this? http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-linker
07:04:56 <heanol> -> http://uptr.pl/mV
07:04:58 <lambdabot> Title: 4.10. Options related to a particular phase, http://tinyurl.com/smq5n
07:04:58 <lambdabot> Title: 4.10. Options related to a particular phase
07:05:02 <idnar> :t ($!)
07:05:07 <lambdabot> forall a b. (a -> b) -> a -> b
07:05:19 <Mitar> why not use fail instead of throwError
07:05:20 <Mitar> ?
07:05:29 <quicksilver> :t fail
07:05:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
07:05:33 <quicksilver> :t throwError
07:05:35 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
07:05:44 <quicksilver> throwError supports custom error types
07:05:49 <quicksilver> fail only string
07:05:51 <hpaste>  scook0 annotated "translate to Either?" with "with guardE" at http://hpaste.org/2748#a2
07:05:52 <cognominal_> @src ($!)
07:05:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:06:02 <cognominal_> nasty bot
07:06:38 <scook0> ($!) is ($), strict in its argument, I believe
07:06:56 <hpaste>  quicksilver annotated "translate to Either?" with "save two lines of valuable screen space!" at http://hpaste.org/2748#a3
07:06:58 <scook0> \f x -> x `seq` f x
07:07:39 <MyCatSchemes> Sizur: I think so, but I'm unclear on whether this'll do what I'm after...
07:07:48 <quicksilver> Mitar: slightly shorter version :)
07:08:31 <Mitar> so if I use fail, i have to have Either String Type as a return type, where Type is my type
07:08:36 <scook0> quicksilver: it's less safe!
07:08:46 <doserj> I'm slightly astonished that nobody changed TyInt to TyBool :)
07:09:22 <scook0> doserj: I don't think anybody bothered to read the actual code ;)
07:09:27 <MyCatSchemes> oerjan: changing the value of -B used? It'd work, but it doesn't really seem sane. Mind you, it'd *work*, it's just that it'd be totally evil. :/
07:09:36 <quicksilver> scook0: how so?
07:09:53 <quicksilver> @src Either fail
07:09:54 <lambdabot> fail msg      = Left (strMsg msg)
07:09:58 <scook0> (the mapM trick)
07:09:59 <quicksilver> :t strMsg
07:10:01 <lambdabot> forall a. (Error a) => String -> a
07:10:07 <quicksilver> scook0: yes, but what about it is less safe?
07:10:15 * MyCatSchemes abuses ln -s, mwahahahaha.
07:10:31 <scook0> if you screw up the number of list elements, you get a runtime error
07:10:35 <oerjan> MyCatSchemes: -i
07:10:38 <scook0> instead of a compile-time error
07:11:00 <quicksilver> scook0: you mean it's "less safe to a typo" ? :P
07:11:02 <scook0> ideally you'd be mapping over a 3-tuple, or a dependently-typed vector
07:11:28 <quicksilver> scook0: it's fairly easy to inspect one line of code and verify that both lists have the same length
07:11:34 <quicksilver> scook0: but I take your point :)
07:12:19 <oerjan> MyCatSchemes: oh, you mean the packages? sorry i misunderstood
07:12:21 <scook0> yeah, it's more of a "don't play with knives" thing
07:12:55 <quicksilver> scook0: maybe there should be a type class HomoTuple with instances for (a,a) and (a,a,a) etc
07:12:56 <MyCatSchemes> oerjan: yeah. I need to install things into ~ rather than /usr/local, but I don't have the disk space to make a complete copy of $libdir
07:13:25 <scook0> quicksilver: would plain Functor work?
07:13:33 <quicksilver> no
07:13:46 <quicksilver> you can't 'upgrade' fmap to fmapM automatically
07:13:54 <quicksilver> at least I don't thin so
07:13:54 <scook0> yeah, I just realised that
07:13:58 <quicksilver> you need FunctorM
07:14:13 <scook0> (forgot the function was monadic, which was the whole point)
07:14:19 <olsner> what's fmapM?
07:14:21 <quicksilver> (my intention was that HomoTuple => Functor, though)
07:14:41 <scook0> olsner: do you know what fmap is?
07:15:03 <oerjan> MyCatSchemes: GHC_PACKAGE_PATH maybe?
07:15:11 <olsner> Functor f => (a -> b) -> f a -> f b?
07:15:13 <cognominal_> how can I tell lambdabot to load some  module to get more sources when I type @src ?
07:15:27 <olsner> :t fmapM
07:15:28 <MyCatSchemes> oerjan: oooh
07:15:29 <lambdabot> Not in scope: `fmapM'
07:15:31 <scook0> @hoogle fmapM
07:15:31 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
07:15:31 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
07:15:43 <cognominal_> @hoogle length
07:15:44 <lambdabot> Prelude.length :: [a] -> Int
07:15:44 <lambdabot> Data.PackedString.lengthPS :: PackedString -> Int
07:15:44 <lambdabot> Foreign.Marshal.Array.lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
07:16:04 <cognominal_> :i length
07:16:18 <Mitar> is there something like (liftM not) ?
07:16:57 <oerjan> cognominal_: i don't think you can, @src is no automatically generated
07:17:01 <oerjan> *not
07:17:31 <scook0> Mitar: I don't think there's a shorter name for it, if that's what you mean
07:17:38 <scook0> but nothing's stopping you from making one
07:17:43 <Mitar> yes ...
07:17:53 <Mitar> but thought that there is already notM :-)
07:17:54 <Mitar> or not'
07:18:14 <MyCatSchemes> oerjan: ah, thank you, that is exactly what I needed.
07:18:16 <oerjan> Mitar: not <$> is slightly shorter :)
07:19:13 <scook0> oerjan: though technically (<$>) is defined over Functor, not Monad
07:19:44 <MyCatSchemes> Oh weird, ghc-pkg doesn't seem to be installed here. :(
07:19:48 <scook0> which would be a pain if you were trying to write code polymorphic in Monad
07:19:50 <quicksilver> Mitar: I like to swap it around, as (not `liftM` )
07:20:07 <quicksilver> Mitar: or just (not `fmap`)
07:20:27 <scook0> quicksilver: are you one of those crazy people who use `id` instead of ($)? ;)
07:20:49 <quicksilver> nope
07:20:58 <quicksilver> but, consider the following code:
07:21:09 <quicksilver> foo = StringType bar
07:21:18 <quicksilver> (building a type with a constructor)
07:21:29 <quicksilver> now suppose you refactor a bit, and bar ends up monadic
07:21:32 <quicksilver> I prefer to then write
07:21:38 <quicksilver> foo = StringType `fmap` bar
07:21:43 <quicksilver> which 'looks like' what I had before
07:21:47 <scook0> oh, I thought you were talking about sections
07:21:47 <quicksilver> instead of
07:21:54 <quicksilver> foo = fmap StringType bar
07:22:00 <scook0> infix `liftM`/`fmap` is fine, imo
07:22:10 <oerjan> MyCatSchemes: if i read it correctly the user package database is searched first
07:22:26 <scook0> but (not `fmap`) on its own is just gross
07:22:38 <oerjan> so you may not actually need to set it if you use the default location?
07:23:01 <scook0> though if you want to write `fmap`, you might as well just use <$>
07:23:33 <MyCatSchemes> oerjan: dunno. ghc-pkg doesn't seem to be installed here, though, weirdly.
07:23:51 <MyCatSchemes> oerjan: since the usual method of creaping the user package database is to run ghc-pkg...
07:24:16 <cognominal_> what is the point of  base/GHC libraries? why are not they shoved elsewhere?
07:24:17 <oerjan> oh
07:24:43 <cognominal_> there is a GHC/List and Data/List...
07:24:57 <cognominal_> what is the point of making two librairies?
07:25:09 <MyCatSchemes> oerjan: wait, yes it is. It's just not in my account's PATH by default. *swings ln -s around and smites this issue*
07:25:14 <quicksilver> scook0: yes, point
07:25:25 <quicksilver> scook0: I think my habit dated from before Control.Applicative was in base
07:25:32 <quicksilver> :t (<$>)
07:25:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:25:43 <quicksilver> @index <$>
07:25:44 <lambdabot> bzzt
07:25:47 <quicksilver> @index (<$>)
07:25:48 <lambdabot> bzzt
07:25:51 * quicksilver shrugs
07:25:56 <olsner> @index fmap
07:25:56 <quicksilver> I think it's defined in applicative, anyway :)
07:25:56 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:25:58 <scook0> by the time I heard about `fmap`, I'd already read about <$>
07:26:14 <quicksilver> I'd heard about <$>
07:26:16 <scook0> but historically, I've always preferred fmap over liftM
07:26:17 <quicksilver> but not with that symbol
07:26:25 <quicksilver> however Conor draws it on paper
07:26:29 <quicksilver> I don't remember what he uses now
07:26:40 <quicksilver> and it wasn't in ghc 6.4, I don't think
07:27:53 <cognominal_> apparently there is dual life libraries like in Perl, that live both in the core and in hackagedb
07:28:11 <cognominal_> can someone shed the light on this ventilation of librairies?
07:28:51 <quicksilver> cognominal_: I don't properly grok hackagedb and cabal, to my chagrin
07:29:02 <quicksilver> cognominal_: so these issues confuse me too :)
07:34:39 <quicksilver> hmm, with HPDF progressing well
07:34:51 <quicksilver> maybe haskell might be the right language to write my iPhoto-killer in
07:35:24 <osfameron> I find it easy not to use iphoto by virtue of not using Mac :-) (But, seriously, cool, sounds like a fun project)
07:36:06 <drigz> did this year's icfp contest come out with a top 3 as usual?
07:36:25 <quicksilver> osfameron: the objective is to ensure that I can still access my iPhoto library if I decide not to buy a mac, next time around
07:36:32 <quicksilver> osfameron: defeat vendor lock-in! :)
07:36:48 <osfameron> ah cool!  is the format documented?  Or just easy/possible to reverse engineer ?
07:36:51 <quicksilver> drigz: I think the results aren't published until the conference itself
07:37:03 <quicksilver> osfameron: it uses apple's proplist, which is documented
07:37:12 <quicksilver> osfameron: then you just have to guess the meanings of the keys/values
07:37:15 <quicksilver> osfameron: which is simple enough
07:37:17 <fasta> Is there a plot library for Haskell?
07:37:20 <scook0> (the conference is October 1-3, apparently)
07:37:34 <drigz> quicksilver: oh, i see. thanks
07:37:58 <scook0> fasta: plotting graphs, or vector graphics in general?
07:38:23 * oerjan suddenly imagines a library for writing fictional plots
07:38:38 * CosmicRay hands oerjan Inform
07:38:40 <quicksilver> oerjan: I recall a macintosh application which did that, quite a few years back
07:39:02 <Mitar> hmm, what if === and =/= are also monadic with Either?
07:39:03 <oerjan> nothing new under the sun :)
07:39:12 <fasta> scook0: plotting graphs
07:39:22 <olsner> :t (===)
07:39:30 <lambdabot> Not in scope: `==='
07:39:38 <quicksilver> olsner: he invented them
07:39:47 <quicksilver> Mitar: define your own version of when
07:39:50 <quicksilver> :t whenM
07:39:52 <lambdabot> Not in scope: `whenM'
07:39:58 <osfameron> oerjan: you could use Vladimir Propp's classifications of story types.  Or something like Calvino's Tarot work.
07:40:08 <Mitar> ok, i am just making sure there is nothing already written
07:40:11 <Mitar> "standard"
07:40:38 <quicksilver> :t when
07:40:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:40:44 <quicksilver> :t \c -> c >>= flip when
07:40:46 <lambdabot> forall (m :: * -> *). (Monad m) => (Bool -> m ()) -> Bool -> m ()
07:40:50 <scook0> fasta: for my current research stuff, I've just been generating data to pipe into gnuplot (fwiw)
07:40:51 <quicksilver> :t \c -> c >>= when
07:40:53 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
07:40:53 <wli> A library for writing fictional plots sounds like Orwell's story-writing machines.
07:40:59 <scook0> I don't have any better advice than that, I'm afraid
07:41:01 <quicksilver> hmph
07:41:09 <quicksilver> I'm being stupid I'm sure :)
07:41:39 <quicksilver> ought to be a one-liner with 'when' and >>=
07:41:58 <quicksilver> :t let whenM c t = do b <- c; when b t
07:42:00 <lambdabot> <command line>:
07:42:00 <lambdabot>     Could not find module `L':
07:42:01 <fasta> scook0: yes, that was my plan A
07:42:04 <quicksilver> :t let whenM c t = do b <- c; when b t in whenM
07:42:06 <lambdabot> forall (t :: * -> *). (Monad t) => t Bool -> t () -> t ()
07:42:20 <MyCatSchemes> quicksilver: if you're prepared to use verrrrry long lines, and { and } and ;, *any* program can be written as a one-liner.
07:42:26 <oerjan> :t \t r -> t >>= flip when r
07:42:29 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
07:42:40 <fasta> scook0: I just asked to see whether anything might have changed (not that likely, since I don't miss a lot that's happening here)
07:42:40 <scook0> fasta: I wonder what darcs-graph (on hackage) uses?
07:42:46 <quicksilver> :t \t -> t >>= flip when
07:42:48 <lambdabot> forall (m :: * -> *). (Monad m) => (Bool -> m ()) -> Bool -> m ()
07:42:55 <MyCatSchemes> Ohhhh, fuck. My university's installation of ghc is totally FUBAR. :(
07:43:01 <quicksilver> hmph
07:43:03 <fasta> MyCatSchemes: what else is new?
07:43:30 <quicksilver> @pl \t r -> t >== flip when r
07:43:30 <lambdabot> (. flip when) . (>==)
07:43:34 <quicksilver> @pl \t r -> t >>= flip when r
07:43:34 <lambdabot> (. flip when) . (>>=)
07:43:42 <olsner> btw, xmonad compiled with the latest solaris sparc release segfaults
07:43:57 <sebell> olsner: --> #xmonad
07:44:07 <MyCatSchemes> fasta: only because they couldn't be arsed to make *one* feckin' symlink. Gah.
07:44:15 <oerjan> @pl \r t -> t >>= flip when r
07:44:15 <lambdabot> (=<<) . flip when
07:44:56 <fasta> MyCatSchemes: what version do they have installed?
07:45:03 <Mitar> whenM t a = do
07:45:03 <Mitar>   t' <- t
07:45:03 <Mitar>   when t' a
07:45:05 <MyCatSchemes> fasta: 6.6
07:45:39 <fasta> MyCatSchemes: my university still has 6.4
07:45:46 <fasta> MyCatSchemes: (and 6.2)
07:45:48 <scook0> Mitar: aww, that takes all the fun out of it! ;)
07:45:59 <Mitar> out of what?
07:46:02 <quicksilver> Mitar: right.
07:46:19 <scook0> Mitar: quicksilver et al. were trying to make a pointfree version
07:46:21 <quicksilver> Mitar: I was just trying to write it stupidly shortly :)
07:46:21 <MyCatSchemes> fasta: when I try to "runghc Setup.hs configure" for (the stable release of) Yi, it breaks because it can't find ghc-pkg in /usr/local/bin. Which is as annoying as Hell, because ghc-pkg is right in my fuggin' $PATH, just tucked away elsewhere.
07:46:26 <Mitar> he he
07:46:27 <Mitar> :-)
07:46:50 <MyCatSchemes> ...how much hackery, I wonder, would it take to get around that?
07:46:55 <Mitar> yes ... i am not so good in this so then i do it quick like this :-)
07:47:16 <fasta> MyCatSchemes: that sounds like you doing something wrong
07:47:24 <scook0> writing pointfree code off the top of your head is not so good for productivity
07:47:37 <scook0> better to write it out longhand first, and maybe refactor later
07:47:54 <ricky_clarkson> scook0: Depends whether you get fast at doing it.
07:48:22 <scook0> sure, once you've messed around enough, you'll pick up real skills
07:48:34 <MyCatSchemes> fasta: any suggestions as to what it could be? /usr/local/bin/ghc exists, /usr/local/bin/hp2hs exists, as do a few of the other misc. binaries, but they never bothered to make ghc-pkg, runghc or runhaskell available.
07:48:38 <scook0> but until then, there's no shame in writing it the long way
07:48:49 <quicksilver> hmm that pimp recruiting for haskell quant developers works just a few hundred yards from me
07:49:00 <MyCatSchemes> fasta: in the face of the evidence, I'm lead to strongly doubt that *I* am in error here.
07:50:21 <scook0> MyCatSchemes: if it's a big deal, you might try a -cafe post
07:50:34 <scook0> better chance of an authoritative answer
07:51:45 <wli> If I knew numerical methods for the Malliavin calculus and stochastic diffeq's better I'd take it more seriously.
07:54:01 <MyCatSchemes> scook0: well, it's certainly not a bug in ghc-6.6 itself or anything, it's just this university's totally broken-ass installation of it.
07:54:45 <scook0> sure, but you might find out whether there's a feasible workaround
07:56:16 <MyCatSchemes> scook0: I'm scared to ask the sysadmins at uni here because I'm afraid that they might've done this on purpose. ;)
07:56:30 <quicksilver> on balance, I suspect you have
07:56:36 <quicksilver> you are clearly a subversive
07:56:45 <quicksilver> your very presence in this channel makes that clear ;)
07:56:49 <wli> Interesting. I see video game physics for fixed-wing aircraft but not helicopters.
08:00:47 <quicksilver> I suspect that autorotation would be pretty hard to model accurately
08:02:26 <quicksilver> I would imagine it's very non-linear
08:02:47 <quicksilver> don't know anything about fluid/aero dynamics though :)
08:02:51 <fasta> MyCatSchemes: Why are you using /usr/local anyway?
08:03:06 <fasta> MyCatSchemes: that's not the default installation location
08:03:14 <MyCatSchemes> fasta: Lord knows.
08:03:36 <fasta> MyCatSchemes: Anyway, just annoy your system admins.
08:03:38 <MyCatSchemes> fasta: everything's installed in /usr/local/ghc66 anyway.
08:03:47 <fasta> MyCatSchemes: it's their job.
08:04:00 <MyCatSchemes> fasta: and then a handful of things are copied out to /usr/local/bin to make them actually available, since that's in everybodies' $PATH.
08:04:36 <fasta> MyCatSchemes: why not add /usr/local/ghc66 to your $PATH?
08:04:50 <fasta> MyCatSchemes: i.e. any directory with a binary
08:05:14 <MyCatSchemes> fasta: I *believe* it is because this version of DeadRat doesn't package anything even resembling an up-to-date version of GHC, so they've built and installed 6.6 from scratch themselves, but done it in an odd location to stop it from interacting with DeadRat's package management.
08:05:37 <fasta> DeadRat? Is that RedHat?
08:05:40 <MyCatSchemes> Yes. :)
08:05:53 <fasta> Oh, I don't have such a negative feeling about it.
08:06:06 <fasta> Spiffy name, though.
08:06:14 <MyCatSchemes> Neither did I until, oh... today.
08:06:48 <MyCatSchemes> Getting things into $PATH isn't a problem. I merely swing "ln -s" about in ~/bin and that problem goes away.
08:07:17 <MyCatSchemes> However, Setup.hs for Yi is barfing because it's only looking in /usr/local/bin for ghc-pkg, rather than actually checking my $PATH.
08:08:23 <sclv> did you check the .cabal file to see if there was something broken in it?
08:08:35 <sclv> lots of times you can just manually plug in what you want
08:08:55 <scook0> I take it there's no "/usr/local/bin/ghc-pkg" sitting conspicuously in the Setup.hs?
08:09:13 <MyCatSchemes> scook0: grepped the whole damn directory. Nope.
08:09:39 <scook0> just double-checking the easy stuff :)
08:09:41 <MyCatSchemes> (And the subdirectories)
08:10:35 <MyCatSchemes> Methinks the search must be built into Cabal itself? I presume I'm doomed in that case.
08:11:28 <scook0> at this point you should probably pick either -cafe or admins (possibly both)
08:12:32 <ricky_clarkson> Have you seen that at least part of Google's MapReduce tutorial uses Haskell?
08:12:39 <ricky_clarkson> http://code.google.com/edu/content/submissions/mapreduce/listing.html
08:12:41 <lambdabot> Title: Google Code for Educators - Google: MapReduce in a Week, http://tinyurl.com/278gp4
08:12:47 <ricky_clarkson> See the "Functional Programming Warm-up".
08:12:56 <fasta> Microschrott Windows <- another one I didn't know
08:13:07 <fasta> (from the gnuplot docs)
08:13:17 <quicksilver> ricky_clarkson: .doc? euch
08:13:27 <fasta> quicksilver is allergic to .doc
08:13:53 <fasta> I am allergic to everything OpenOffice doesn't open correctly.
08:14:03 <quicksilver> ricky_clarkson: does indeed look like haskell although it's hard to be sure
08:14:05 <ricky_clarkson> Openoffice seems to work fine for this.
08:14:15 <ricky_clarkson> quicksilver: It's easy to be sure, because the doc says it's Haskell.
08:14:16 <quicksilver> ricky_clarkson: it's simple enough and a number of languages look like that :)
08:14:22 <MyCatSchemes> fasta: I am allergic to OpenOffice.
08:14:22 <pejo> MyCatSchemes, isn't it the "getLibDir" that does it for you? It runs ghc --print-libdir.
08:14:37 <quicksilver> ricky_clarkson: oh yes, I didn't spot that :)
08:14:37 <fasta> MyCatSchemes: why?
08:14:43 <byorgey> ricky_clarkson: except the desired output for question 2 is not well-typed
08:14:48 <MyCatSchemes> fasta: slow. Abiword FTW. ^^
08:15:00 <Saizan> MyCatSchemes: i think cabal looks for a ghc-pkg in the same directory where it finds ghc hoping that in this way it's using the right ghc-pkg and not one of a different installation of ghc
08:15:05 <MyCatSchemes> fasta: (though I like the feature proliferation - equation typesetting and the like)
08:15:10 <byorgey> hmm, it does say its Haskell though
08:15:19 <quicksilver> byorgey: just a typo, I think
08:15:25 <quicksilver> byorgey: someof the [] are supposed to be ()
08:15:31 <byorgey> quicksilver: you're right, they used [] for ()
08:15:32 <byorgey> right
08:15:33 <quicksilver> byorgey: (k1,[a,c,d]) et al
08:16:17 <wli> BTW it's easy to make a game where the AI is the point even with low-quality AI.
08:16:44 <Saizan> MyCatSchemes: you can give configure a speficic path with --with-hc-pkg=
08:17:01 <wli> I hear that most people just go around running over pedestrians and shooting at cops instead of playing missions (if they even notice there are missions).
08:17:10 <wli> That is, in the GTA games.
08:17:35 <wli> So delete the missions, beef up the AI, let people screw around like they do there.
08:18:54 <ricky_clarkson> wli: That's probably why none of the pedestrians are children or old people.
08:20:20 <wli> Oh, yeah, speaking of fashion design bits, GTA:SA (and possibly earlier) have changeable wardrobes, so there's plenty of futzing with the clothes you can expand on as well. ;)
08:21:22 <ricky_clarkson> That reminds me of my brother spending all his time making cars look good in racing games, but he was crap at the actual game.
08:22:37 <wli> Yeah, more car mods and fancy pimpmobiles, too.
08:24:07 <wli> Throw in house, boat, airplane, and helicopter mods, too, while you're at it.
08:29:27 <mbrandt> hey all
08:30:10 <mbrandt> I was just trying to compile greencard so I could interface to a C lib and found that it won't compile with newer compilers.
08:30:27 <mbrandt> seems to want to reference some deprecated stuf
08:30:47 <quicksilver> I think it's essentially deprecated
08:30:49 <quicksilver> greencard
08:30:56 <quicksilver> I believe c2hs is now preferred
08:31:00 <beelsebob_> @dcos Ord
08:31:01 <lambdabot> Ord not available
08:31:07 <beelsebob_> @dcos Ordering
08:31:07 <lambdabot> Ordering not available
08:31:08 <beelsebob_> bah
08:31:19 <mbrandt> I'll have a look at c2hs. Thanks
08:32:21 <LeCamarade> Which is the 32-bit type, again?
08:33:03 <quicksilver> Word32?
08:33:09 <quicksilver> Int32?
08:33:12 <quicksilver> depending which you want
08:33:17 <MyCatSchemes> Saizan: (sorry for the slow response) --with-hc-pkg= being given to which tool, sorry?
08:33:47 <Saizan> MyCatSchemes: to runghc Setup configure, if the problem was with it
08:34:52 <oerjan> @docs Data.Ord
08:34:53 <lambdabot> Data.Ord not available
08:35:09 <oerjan> sheesh
08:35:51 <oerjan> @docs Control.Monad.State
08:35:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
08:38:08 <dcoutts> int-e: ping
08:38:16 <MyCatSchemes> Saizan: thank you, that works.
08:40:07 <Saizan> MyCatSchemes: good :), --help lists more options like this, btw
08:43:51 <dons> olsner: did you report the segfault on the sparc?
08:45:21 <olsner> yeah, that was me... I'm thinking it's probably something with the compiler setup though... had to hack -fasm to -fvia-C in the cabal files to get X11-extras and xmonad to compile
08:46:31 <dons> does it work now?
08:46:43 <dons> it could be bugs in the ffi binding, or ghc bugs, or ...
08:47:42 <sjanssen> olsner: when did xmonad crash?
08:48:02 <sjanssen> olsner: would it be too much trouble to attach gdb and get a backtrace?
08:48:11 <olsner> I more or less gave it up since it didn't work... I have no solaris/sparc systems at home, only at school, so my testing abilities are limited
08:48:39 <olsner> I did that, got stginit_something->stginit_something->???
08:49:11 <sjanssen> olsner: so it crashed immediately after startup?
08:49:20 <beelsebob_> Is it possible to write an if function (that works properly) in a strict language
08:49:40 <olsner> yeah, it didn't produce any noticable output or anything
08:50:12 <sjanssen> olsner: okay, thanks.  Seems likely that it's a GHC bug
08:50:21 <dons> beelsebob_: yeah
08:50:35 <dons> move the branches under a lambda, and apply the branch to () once the branch is chosen
08:50:54 <beelsebob_> ah, that makes sense
08:51:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2750
08:51:11 <beelsebob_> oops
08:51:12 <sjanssen> of course that has to be done at the call site
08:51:15 <beelsebob_> didn't mean to announce that
08:51:17 <sjanssen> so it's a bit less modular
08:51:31 <dons>  if_ !b !(\_ -> e1) !(\_ -> e2) = if b then e1 () else e2 ()
08:51:34 <beelsebob_> dons: that was what I was doing, and causing explosions (because mod gets evaluated forever)
08:51:38 <dons> yeah, or macros or something
08:52:15 * beelsebob_ decided to fix the language instead of the if though
08:52:21 <oerjan> some otherwise strict languages allows call-by-name arguments
08:52:30 <oerjan> like Scala
08:52:33 <hpaste>  Mitar pasted "compile error" at http://hpaste.org/2751
08:53:19 <Mitar> what means No instance for (Monad (Either String)) error?
08:53:29 <Mitar> how can Either be of type just (Either String)
08:53:40 <oerjan> Mitar: you need import Control.Monad.Error
08:54:16 <quicksilver> Mitar: (Either String) is a partially applied type
08:54:16 <Mitar> aaa
08:54:19 <sjanssen> Mitar: Monad is a constructor class -- it takes a type constructor that takes a type to produce a type
08:54:22 <sjanssen> @kind Either
08:54:27 <lambdabot> * -> * -> *
08:54:28 <oerjan> because monads have kind * -> *, so you leave out the last type argument
08:54:28 <sjanssen> @kind Either String
08:54:30 <lambdabot> * -> *
08:54:31 <quicksilver> Mitar: consider, 'Maybe Int' is not a Monad
08:54:37 <quicksilver> Mitar: 'Maybe' is a Monad
08:54:50 <quicksilver> Mitar: you must always have one parameter "waiting" for a Monad
08:55:02 <quicksilver> as oerjan says, this is because Monads are of kind * -> *
08:55:10 <Mitar> ok, but i do not understant why should i import Control.Monad.Error?
08:55:21 <Mitar> Either is not defined as a monad otherwise?
08:55:23 <quicksilver> because that is the file which contains the Monad defition for Either
08:55:56 <quicksilver> the monad definition for Either is not int he standard prelude because it isn't haskell98 compliant
08:56:01 <quicksilver> it requires MPTC and fundeps
08:56:55 <oerjan> it _could_ have been in the standard prelude
08:57:14 <oerjan> it's the MonadError stuff that cannot
08:57:58 <quicksilver> oerjan: you could make Either String a monad, in the standard prelude
08:58:08 <quicksilver> oerjan: but it would be hard to give the general instance
08:58:41 <oerjan> oh right
08:58:58 <Mitar> if I have isvalue :: Type -> Bool
08:59:05 <Mitar> and make
08:59:05 <Mitar> isvalueM = liftM isvalue
08:59:16 <Mitar> what type should isvalueM be
08:59:20 <Mitar> to be in Either monad?
08:59:25 <quicksilver> m Type -> m Bool
08:59:42 <quicksilver> Either String Type -> Either String Bool
09:03:36 <Mitar> and whenM?
09:03:39 <Mitar> whenM :: Monad m => m Bool -> m a -> m a
09:03:39 <Mitar> ?
09:03:44 <Mitar> (it is not correct)
09:05:49 <byorgey> Mitar: are you having a problem with some particular code?
09:06:14 <Mitar> just warnings now ...
09:06:20 <Mitar> i declared whenM t a = do
09:06:20 <Mitar>   t' <- t
09:06:20 <Mitar>   when t' a
09:07:29 <byorgey> @type when
09:07:39 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:08:07 <quicksilver> Mitar: m Bool -> m() -> m()
09:08:31 <quicksilver> Mitar: it can't return any value "a" because the code might not be executed
09:09:22 <Mitar> finally ... now it works ... no more laziness :-)
09:09:28 <Mitar> (I pass errors with either)
09:09:54 <quicksilver> woot
09:10:00 <quicksilver> and as a bonus, you've learn all about monads and stuff :)
09:10:11 <Mitar> great :-)))
09:10:20 <Mitar> i just spend 6 hours on that ...
09:11:47 <Mitar> ahh, not yet finished ...
09:11:49 <Mitar> :-(
09:14:38 <Mitar> is there a monadic version of foldl?
09:14:50 <Saizan> ?type foldM
09:14:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:15:00 <pjd> Mitar: foldM . reverse, probably
09:15:05 <Saizan> ?src foldM
09:15:05 <lambdabot> foldM _ a []     = return a
09:15:05 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
09:15:17 <Saizan> nah, foldM is a left fold
09:15:18 <pjd> err, plus another reverse
09:15:20 <Mitar> ?src foldl
09:15:21 <lambdabot> foldl f z xs = lgo z xs
09:15:21 <lambdabot>     where lgo z []     =  z
09:15:21 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
09:15:51 <quicksilver> pjd: plus a flip :)
09:15:55 <bos> guten morgen
09:16:01 <Mitar> liftM foldl
09:16:23 <quicksilver> foldl f = reverse . foldr (flip f) . reverse
09:16:24 <quicksilver> I think
09:17:15 <dcoutts> @seen int-e
09:17:15 <lambdabot> int-e is in ##logic, #ghc, #haskell-overflow and #haskell. I last heard int-e speak 1h 56m 40s ago.
09:17:18 <Mitar> what's wrong with liftM
09:17:18 <pjd> Mitar: that's a bit different
09:17:29 <quicksilver> nothing's wrong with liftM
09:17:35 <quicksilver> but it's something different :)
09:17:51 <Mitar> will not work?
09:18:03 <quicksilver> depends what you're trying to do
09:18:43 <quicksilver> foldM is for folding a serious of monadic calculations through a list
09:18:53 <pjd> Mitar: actually, what exactly did you mean with "monadic version of foldl"?
09:19:01 <olsner> :t foldM
09:19:03 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:19:40 <oerjan> if you just want to use foldl on a list produced in a monad, liftM will do fine
09:19:43 <pjd> foldM is like foldr where the result of the function is monadic
09:19:58 <Mitar> i have functional code, where i used error for exiting when there was an error
09:20:18 <Mitar> now i am porting it to Either
09:20:37 <quicksilver> we need to know the types involved :)
09:20:43 <quicksilver> which bits are monadic and which bits aren't
09:20:47 <oerjan> and you want to exit in the middle of the folding?
09:20:49 <quicksilver> what is your binary function, for example?
09:20:52 <bos> > x
09:20:53 <Saizan> pjd: why do you say that's like foldr? the function is called with the accumulator so far not with the result of the recursive call
09:20:53 <lambdabot>  1
09:21:10 <Mitar> deccheck :: (TypeEnv,VarEnv) -> [Dec] -> Either String (TypeEnv,VarEnv)
09:21:24 <Mitar> (after porting to Either)
09:21:36 <quicksilver> yes, you want foldM
09:22:03 <quicksilver> you run that over a [[Dec]] ?
09:23:12 <bos> > do not `want` cheezburger
09:23:13 <lambdabot>  Nothing
09:23:18 <pjd> Saizan: sorry, had it the wrong way around
09:23:31 <quicksilver> bos: heresy!
09:23:34 <oerjan> o_O
09:23:38 <hpaste>  Mitar pasted "types types" at http://hpaste.org/2752
09:23:57 <oerjan> > want
09:23:58 <lambdabot>  Add a type signature
09:24:18 <olsner> > cheezburger
09:24:19 <lambdabot>  Nothing
09:24:20 <quicksilver> Mitar: yes. looks like foldM to me
09:24:20 <oerjan> > [want,True]
09:24:21 <lambdabot>  Couldn't match expected type `(a -> b) -> f a -> f b'
09:24:44 <oerjan> > [cheezburger,True]
09:24:45 <lambdabot>  Couldn't match expected type `Maybe a' against inferred type `Bool'
09:25:25 <olsner> > do not `want` Just cheezburger
09:25:25 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Maybe a'
09:26:01 <Mitar> but, is not foldl and foldM going in the same dirrection?
09:26:10 <Mitar> why should I use reverse and all that stuff?
09:26:14 <quicksilver> you don't need to
09:26:16 <quicksilver> pjd was swrong
09:26:20 <quicksilver> foldM is left-based
09:26:22 <oerjan> sure, but foldl cannot do monadic actions _during_ the folding, like exiting
09:26:32 <olsner> hmm.. @type doesn't react to @let variables, it seems
09:26:38 <olsner> :t cheezburger
09:26:40 <lambdabot> Not in scope: `cheezburger'
09:26:47 <quicksilver> :t L.cheezburger
09:26:48 <lambdabot> Couldn't find qualified module.
09:26:51 <oerjan> olsner: why do you think i used that trick? :)
09:27:11 <Mitar> ok, so I just replace foldl with foldM if I see correctly
09:27:28 <olsner> yeah, but this is #haskell, where trickery needs no reason
09:27:44 <quicksilver> Mitar: I believe so
09:27:51 <ricky_clarkson> > let i=5 in let has=elem in let cheezburgr=5 in let can=id in can i `has` [cheezburgr]
09:27:51 <oerjan> indeed
09:27:52 <lambdabot>  True
09:28:05 <Baughn> @pl \x -> (f x, g x)
09:28:06 <lambdabot> liftM2 (,) f g
09:28:14 <oerjan> @remember ricky_clarkson> let i=5 in let has=elem in let cheezburgr=5 in let can=id in can i `has` [cheezburgr]
09:28:15 <lambdabot> Done.
09:28:43 <hkBst> is there a predefined max function which can take a compare function?
09:28:53 <oerjan> :t maximumBy
09:28:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
09:29:26 <hkBst> thanks oerjan
09:29:33 <hkBst> @karma+ oerjan
09:29:33 <lambdabot> oerjan's karma raised to 7.
09:29:35 <int-e> dcoutts: ?
09:29:44 <pjd> Mitar: yeah, sorry about that :)
09:29:50 <Mitar> no problem ...
09:30:04 <Mitar> thanks for help ...
09:30:05 <dcoutts> int-e: actually I was just misunderstanding your patch, but it's all ok now. I've applied and pushed it.
09:30:18 <int-e> ah nice.
09:30:24 <Mitar> this will really be a great compiler
09:31:50 <quicksilver> @quote trickery
09:31:50 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
09:32:00 <quicksilver> @remember olsner yeah, but this is #haskell, where trickery needs no reason
09:32:01 <lambdabot> Done.
09:32:22 <olsner> ;-)
09:32:26 <ricky_clarkson> @quote ricky_clarkson
09:32:26 <lambdabot> ricky_clarkson says: Is Haskell an interface between programming languages and academics?
09:32:32 <ricky_clarkson> @quote ricky_clarkson
09:32:32 <lambdabot> ricky_clarkson says: Is Haskell an interface between programming languages and academics?
09:32:34 <quicksilver> @quote quicksilver
09:32:35 <lambdabot> quicksilver says: someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
09:32:39 <quicksilver> @quote quicksilver
09:32:40 <lambdabot> quicksilver says: learning from other people's mistakes is so web 1.0
09:32:44 <quicksilver> @quote quicksilver
09:32:44 <lambdabot> quicksilver says: learning from other people's mistakes is so web 1.0
09:32:56 <ricky_clarkson> @quote ricky_clarkson>
09:32:56 <lambdabot> ricky_clarkson> says: let i=5 in let has=elem in let cheezburgr=5 in let can=id in can i `has` [cheezburgr]
09:33:05 <olsner> @quote olsner
09:33:05 <lambdabot> olsner says: yeah, but this is #haskell, where trickery needs no reason
09:33:22 <byorgey> what is this, Quote Yourself Day? =)
09:33:59 <sjanssen> @quote sjanssen
09:33:59 <lambdabot> sjanssen says: @djinn Haskell -> Curry
09:35:06 <hkBst> how should I write       \(a,b,v) -> v        instead?
09:35:22 <shapr> What's going on?
09:35:23 <sjanssen> hkBst: that is the only way
09:35:26 <oklopol> (\a,b,v->v)
09:35:32 <oklopol> > (\a,b,v->v) 1 2 3
09:35:32 <lambdabot>  Parse error
09:35:33 <quicksilver> hkBst: that is my preferred way to write it
09:35:37 <oklopol> > (\a, b, v -> v) 1 2 3
09:35:37 <lambdabot>  Parse error
09:35:39 <quicksilver> hkBst: well, almost
09:35:39 <oklopol> ..
09:35:41 <oklopol> darn
09:35:45 <quicksilver> koxinga: \(_,_,v) -> v
09:35:46 <byorgey> oklopol: those commas are illegal syntax
09:35:50 <quicksilver> hkBst: that was for you
09:35:55 <oklopol> > (\a b v -> v) 1 2 3
09:35:56 <lambdabot>  3
09:36:01 <oklopol> heh
09:36:03 <oklopol> copypaste :D
09:36:07 <oklopol> i do know that
09:36:16 <sjanssen> hkBst: just give the function a reasonable name (like third, or something)
09:36:21 <idnar> hmm
09:36:41 <idnar> > 1,2
09:36:42 <lambdabot>   parse error on input `,'
09:36:48 <byorgey> or thrd, to be consistent with fst and snd =)
09:36:52 <idnar> oh nm
09:36:55 * idnar misread
09:37:07 <oklopol> > (1,2)
09:37:09 <lambdabot>  (1,2)
09:37:13 <sclv> you also need a fst3 and a snd3 and then a thd3
09:37:14 <hpaste>  hkBst pasted "parse error on input `\'" at http://hpaste.org/2753
09:37:41 <hkBst> quicksilver, sjanssen: perhaps I misunderstood the error in the above then...
09:37:45 <ricky_clarkson> > fst (1,2,3)
09:37:45 <lambdabot>  Couldn't match expected type `(a, b)'
09:37:45 <quicksilver> sjanssen: I think that \(_,_,v) -> v is more pleasant on the eyes than thd
09:37:50 <ricky_clarkson> > fst (1,(2,3))
09:37:51 <lambdabot>  1
09:38:04 <quicksilver> sjanssen: it doesn't take up much space, and it does what it says on the tin
09:38:07 <sjanssen> quicksilver: depends on how often you use it, I suppose
09:38:11 <byorgey> hkBst: you need parentheses around the function, I think
09:38:20 <quicksilver> I hearby christen \(_,_,v) -> v "the Ronseal function"
09:38:21 <beelsebob_> hmm, interesting security issue with darcs... if all the processing is done client side, surely this opens a repo up to being tampered with by a malicious client (and rigged files inserted into the repo)
09:38:23 <byorgey> i.e. comparing (\(a,b,v) -> v)
09:38:29 <sclv> > (fst . snd) $ (1,(2,3))
09:38:31 <lambdabot>  2
09:38:33 <olsner> we should invent first-class pattern matching
09:39:07 <ricky_clarkson> Why aren't n-tuples made of pairs?
09:39:21 <shapr> HList is just that.
09:39:33 <byorgey> ricky_clarkson: those are called lists =)
09:39:41 <ricky_clarkson> Lists are homogenous.
09:39:48 <sjanssen> ricky_clarkson: performance reasons, most likely
09:39:52 <byorgey> oh, I see, good point
09:40:10 <shapr> ricky_clarkson: Another reason is that a tuple is a type, so (Int,Int,Int) and (Int,Int) are different types.
09:40:16 <ricky_clarkson> sjanssen: That sounds bogus.  You could uncurry Haskell for that kind of performance reason.
09:40:33 <ricky_clarkson> shapr: Sure, but (Int,(Int,Int)) and (Int,Int,Int) could be the same.
09:40:41 <beelsebob_> shapr: yes, but equally (Int, (Int,Int)) is different from (Int,Int)
09:40:42 <sjanssen> ricky_clarkson: currying has performance problems?
09:40:48 <hkBst> do I have to import something to get `maximumBy'? ghci complains Not in scope: `maximumBy'...
09:40:53 <ricky_clarkson> sjanssen: No.  Does the above?
09:41:03 <shapr> ricky_clarkson: But that's pretty much a list.
09:41:08 <sclv> you really don't want ((Int, Int), Int) to be the same as (Int, (Int, Int))
09:41:19 <oklopol> it wouldn't be...
09:41:32 <byorgey> hkBst: yes, Data.List
09:41:34 <ricky_clarkson> shapr: A heterogenous list.
09:41:38 <sjanssen> ricky_clarkson: it is moderately bogus, but it is true that there is no existing Haskell compiler that can represent (a, (b, (c, (d, ())))) as efficiently as (a, b, c, d)
09:41:54 <koxinga> hkBst: Hoogle may be useful for this kind of question
09:42:02 <ricky_clarkson> sjanssen: It doesn't need to be preserved as that at runtime.
09:42:06 <shapr> ricky_clarkson: HList is a heterogenous list type, and it uses (a,(b,(c,d)))
09:42:22 <ricky_clarkson> shapr: Ah.  I didn't realise you were talking to me when you mentioned it earlier.
09:42:50 <sclv> you can't represent them the same because the former holds more information, no?
09:43:39 <sjanssen> ah, sclv has a very good point
09:43:52 <quicksilver> yes
09:43:58 <quicksilver> contrary to what ricky_clarkson said
09:44:09 <quicksilver> (I,(I,I)) is not isomorphic to (I,I,I)
09:44:15 <quicksilver> the former has one more bottom
09:44:16 <quicksilver> so to speak :)
09:44:25 <shapr> Ok, I want to have a physical meeting of Haskellers for/in the USA, possibly just the SouthEast USA.
09:44:27 <sjanssen> ricky_clarkson: ^^^ is probably the real reason
09:44:34 <Nafai> shapr: In Austin! :)
09:44:36 <shapr> So, who's showing up?
09:44:40 <shapr> Nafai: Maybe
09:44:57 <shapr> I'd like to come up with a list of attendees and then pick a major city at the average of their locations.
09:45:22 <ricky_clarkson> sjanssen: I see.  Bottom irritates me.
09:45:30 * ricky_clarkson goes to get some pile cream for Haskell.
09:45:30 <hpaste>  hkBst annotated "parse error on input `\'" with "Exception: stack overflow" at http://hpaste.org/2753#a1
09:45:45 <shapr> ricky_clarkson: hah!
09:45:57 <sjanssen> ricky_clarkson: of course the efficiency reason is related to the _|_ issue
09:46:15 <byorgey> shapr: I'm interested!
09:46:29 <Nafai> shapr: I'm interested, depending on location/time
09:46:48 <shapr> byorgey: Where are you?
09:46:59 <oklopol> i could move the convention to see by coming from finland.
09:47:01 <byorgey> shapr: Washington, DC
09:47:02 <oklopol> *sea
09:47:03 <oklopol> *sea
09:47:11 <oklopol> if it's the average
09:47:40 <quicksilver> hkBst: did you try compiling it with -O2 ?
09:48:17 <hkBst> quicksilver: no, I didn't try compiling at all.
09:48:36 <quicksilver> hkBst: try that, the strictness analyser can solve certain types of stack overflow
09:49:04 <shapr> byorgey: Sounds good
09:53:00 <hkBst> quicksilver: I used "ghc -O2 problem27.hs -o problem27", is that right? It says "compilation IS NOT required" but still produces an executable... 8-/ which still overflows its stack.
09:53:04 <glen_quagmire> frag is awesome
09:54:02 <LeCamarade> How to know your Ruby has been improved by your Haskell:
09:54:13 <LeCamarade> def each()
09:54:18 <byorgey> hkBst: just to make sure, you may want to try deleting the executable and any .o or .hi files, and re-compiling
09:54:22 <LeCamarade> (0 ... self.length).to_a.map! {|x| yield(self[x])}
09:54:35 <LeCamarade> end
09:54:44 <sjanssen> hkBst: the recompilation checker is beating you, use -no-recomp
09:54:50 <hkBst> byorgey: ah, right. I missed those
09:55:05 <LeCamarade> Just had to spread the smile. :o)
09:55:26 <byorgey> I've never understood why you use "-no-recomp" when you DO want it to recompile
09:55:36 <hkBst> yay, it worked :)
09:55:41 <byorgey> hooray!
09:55:56 <drigz> hkBst: you can also use 'touch problem27.hs' to make it think that you have changed the source
09:56:01 <sjanssen> hkBst: I usually keep my flags in an OPTIONS_GHC pragma, so the recompilation checker will automatically pick up changes in the flags
09:56:16 <drigz> hkBst: unrelatedly, if you use --make, then you don't need -o problem27
09:57:10 <dcoutts> sjanssen: mm, cabal should track that too when we do dep tracking, ie changes to options in the .cabal file
09:57:35 <hkBst> thanks for the tips, drigz, sjanssen :)
09:57:44 <sjanssen> dcoutts: that'd be neat
09:58:22 <sjanssen> dcoutts: what is the status of dep tracking?  Is there code in the head yet?
09:58:28 <dcoutts> sjanssen: not yet
09:58:31 <dcoutts> pgavin-away: ping
09:58:41 <dcoutts> sjanssen: are you coming to the hackathon?
09:59:09 <dcoutts> I want to hack on cabal dep tracking at the hackathon
09:59:15 <sjanssen> dcoutts: nah, Freiburg is a bit far for me
09:59:26 <dcoutts> sjanssen: ok, perhaps via irc that week? :-)
09:59:44 <sjanssen> dcoutts: sure
09:59:49 <dcoutts> well, 3 days
09:59:51 <dcoutts> sjanssen: cool
10:00:10 <Igloo> @localtime sjanssen
10:00:11 <lambdabot> Local time for sjanssen is Fri Sep 14 11:57:58 2007
10:00:25 <dcoutts> sjanssen: what're you interested in joining in on? I'm planning to look at cabal dep tracking and other cabal refactoring
10:01:25 <shapr> byorgey: Ok, add yourself: http://www.haskell.org/haskellwiki/AmeroHaskell
10:01:26 <lambdabot> Title: AmeroHaskell - HaskellWiki
10:01:39 <byorgey> shapr: will do
10:02:16 <sjanssen> dcoutts: I'm not sure
10:02:20 <shapr> Nafai: Add yourself to AmeroHaskell!
10:02:28 * Nafai obeys
10:02:32 <dcoutts> g'morning dons
10:02:36 <dcoutts> @localtime dons
10:02:39 <lambdabot> Local time for dons is Fri Sep 14 10:00:51 2007
10:02:45 <dons> hey
10:04:29 <ddarius> Wait, what is this AmeroHaskell thing?
10:04:39 <shapr> ddarius: It's a Haskell gathering for the SouthEastern USA.
10:05:01 <shapr> ddarius: The idea was put into motion about ten minutes ago.
10:05:24 <hkBst> @src elem
10:05:24 <lambdabot> elem x    =  any (== x)
10:05:45 <shapr> Any other USA located Haskellers willing to show up in the Southeast USA to meet and code?
10:06:02 <dons> shapr: is there a web page?
10:06:08 <sjanssen> shapr: I'd consider it, depends on the location
10:06:13 <shapr> There's a HaskellWiki page.
10:06:18 <ddarius> shapr: I may well be depending primarily on when and how long and a bit on where.
10:06:31 <shapr> ddarius: You're in TX also, yes?
10:06:48 <dons> we need one for North and West , as well as South and East :)
10:06:52 <Nafai> shapr: Added!
10:06:57 <shapr> dons: Do it!
10:07:03 <dons> though might be a good excuse to travel around the country...
10:07:12 <dons> sjanssen: maybe we could have an xmonad hackathon.
10:07:17 <dons> shapr: what kind of location where you thinking of?
10:07:37 <shapr> dons: Some major city in the southeast.
10:07:54 <drigz> shapr: is it more like a sprint than anglohaskell?
10:07:55 <dons> in a hotel or uni or something?
10:08:00 <shapr> Hopefully someplace where enough attendees have apartments/etc for others to sleep there :-)
10:08:06 * sjanssen points out that his city is the average of "North and West" and "South and East" :)
10:08:18 <dons> yeah, bang in the middle might be convenient
10:08:23 <dons> and with university access
10:08:33 <shapr> dons: I'd rather have it in a uni, since that's more conducive to coding and zero admission costs, but a hotel would work if actual money is charged.
10:08:40 <shapr> sjanssen: Which city?
10:08:55 <dons> do we have a google maps for USAsian haskellers yet?
10:09:01 <shapr> No, but we need it.
10:09:05 <sjanssen> I don't think Lincoln is a particularly good location though, it has a small airport, and very few Haskellers in the area
10:09:10 <sjanssen> shapr: Lincoln, NE
10:09:20 <beelsebob_> Is there any way to adjust the style of documentation that Haddock outputs?
10:10:01 <byorgey> beelsebob_: you can provide a custom CSS file
10:10:17 <ddarius> shapr: Yes, I'm in Texas.
10:10:33 <beelsebob_> byorgey: oh, duh... I never even thought it would be that simple
10:11:13 <ddarius> @wiki Haskell user locations
10:11:13 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_user_locations
10:11:17 <beelsebob_> arse
10:11:19 <beelsebob_> it's all table based
10:11:28 <beelsebob_> so no rearanging the page for me :(
10:12:01 <byorgey> beelsebob_: ah yes, now that you mention it, I recall someone else complaining about that recently on -cafe
10:12:20 <beelsebob_> byorgey: yeh, was just searching archives for such stuff
10:12:26 <beelsebob_> neil was poking simon about it
10:12:41 <byorgey> indeed
10:13:18 <beelsebob_> oh well, I guess I don't add an <aol>me too</aol> to it, I think neil seems to have covered everything
10:13:37 <sjanssen> is there a quick way to get these latitude/longitude coordinates on to a Google map?
10:14:16 <dons> anyone familiar with the google maps api these days? the simple api?
10:14:28 <drigz> sjanssen: click link, i think they're in there
10:14:38 <hkBst> @src nub
10:14:38 <lambdabot> nub = nubBy (==)
10:14:51 <dons> hkBst: cunning, no? :)
10:14:58 <dons> ?src group
10:14:59 <lambdabot> group = groupBy (==)
10:15:04 <hkBst> dons: very :) Does it work on unsorted lists?
10:15:05 <dons> HOF FTW!
10:15:14 <dons> > nub "haskell"
10:15:16 <lambdabot>  "haskel"
10:15:19 <dons> > nub "haskell haskell"
10:15:21 <lambdabot>  "haskel "
10:15:31 <hkBst> :) brilliant
10:15:39 <drigz> hkBst: it runs in O(n^2) though
10:15:46 <drigz> because:
10:15:48 <drigz> @type nub
10:15:50 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:16:30 <drigz> @type (map head . group . sort)
10:16:32 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:16:46 <hkBst> I don't think it follows from that type alone. But handling unsorted lists will do that.
10:16:59 <ddarius> hkBst: Yes, actually, it does.
10:17:31 <ddarius> Well, I guess if nub did assume the lists were sorted...
10:17:50 <byorgey> then you could have O(n), of course.
10:17:52 <ddarius> But then it would have a different specification.
10:18:23 <dons> ?users
10:18:24 <lambdabot> Maximum users seen in #haskell: 407, currently: 388 (95.3%), active: 16 (4.1%)
10:18:52 <hkBst> ddarius: like what?
10:19:13 <ddarius> hkBst: ?
10:19:34 <hkBst> ddarius: what different specification would it have?
10:19:58 <drigz> hkBst: it would say that it removed consecutive duplicate elements
10:20:01 <sclv> you could have O(n*log n) on unsorted lists too, assuming that you took an Ord
10:20:05 <ddarius> hkBst: It would require sorted lists, or alternatively it would have the behavior of map head . group
10:20:27 <ddarius> sclv: Of course, but the type of nub explicitly makes that impossible.
10:20:29 <sclv> or approx O(n) with a decent hash
10:20:51 <drigz> you could have O(n) with type (Ix a, Bounded a) => [a] -> [a]
10:21:11 <sclv> or right, the Id hash
10:21:56 <byorgey> drigz: assuming there's enough memory...
10:22:33 <ddarius> Accessing the disk has constant time complexity...
10:23:28 <byorgey> no stray magnets come near the hard drive...
10:23:53 <drigz> byorgey: you can say the same for almost any implementation :p
10:24:58 <byorgey> drigz: well, my first comment was serious. =)  For example we have Ix Int and Bounded Int but I don't think you'd want to create an array of 2^32 elements just to compute nub in "O(n)" time
10:25:27 <drigz> byorgey: i know, my last comment was not serious
10:25:35 <drigz> it has a very bad memory complexity
10:25:52 <ddarius> It has constant memory complexity!
10:25:54 <hkBst> > length $ nub [ a^b | a <- [2..100], b <- [2..100] ]
10:26:04 <drigz> ddarius: for a given type
10:26:04 <byorgey> hehe
10:26:07 <lambdabot>  9183
10:26:53 <byorgey> so, such an implementation would be a big win if you wanted to find the nub of a list of 500 quadrillion Ints =)
10:27:08 <drigz> wow, that was fast for O(100,000,000) computations
10:27:44 <roconnor> O(100,000,000) = O(1)
10:27:49 <drigz> in fact, given that some of the numbers were 200 digits long
10:28:26 <drigz> roconnor: yeah, i wasn't sure how to express that
10:28:30 <drigz> roconnor: do you know what i meant?
10:28:50 <ricky_clarkson> drigz: I think you use a little o to express that.
10:29:40 <hkBst> how do I get rid of the "main = " boilerplate?
10:30:21 <sjanssen> > length "main = " -- boilerplate?
10:30:22 <oklopol> > length [1..1000000]
10:30:22 <lambdabot>  7
10:30:24 <lambdabot>  1000000
10:30:30 <oklopol> > length [1..1000000000]
10:30:33 <lambdabot> Terminated
10:30:36 <oklopol> > length [1..100000000]
10:30:40 <lambdabot> Terminated
10:30:41 <oklopol> > length [1..10000000]
10:30:45 <lambdabot> Terminated
10:30:55 <oklopol> > length [1..5000000] -- i'll find it
10:30:58 <lambdabot>  5000000
10:31:05 <oklopol> > length [1..7000000] -- gettin gcloser
10:31:10 <lambdabot> Terminated
10:31:10 <Spockz|Workstati> evening
10:31:14 <oklopol> > length [1..6000000]
10:31:17 <lambdabot> Terminated
10:31:19 <byorgey> hi Spockz|Workstati
10:31:19 <hkBst> oklopol: who said it was a constant? :)
10:31:35 <oklopol> hkBst: i'm pretty sure it doesn't change that much...
10:31:36 <oklopol> > length [1..6000000]
10:31:40 <lambdabot> Terminated
10:31:46 <oklopol> > length [1..5500000]
10:31:50 <lambdabot>  5500000
10:31:54 <drigz> oklopol: the computations in the nub were (==) :: Integer -> Integer -> Bool, which should be a lot slower than tail
10:31:58 <oklopol> i can find the range if it changes
10:32:23 <oklopol> in the... nub?
10:32:28 <oklopol> > length [1..5800000]
10:32:31 <lambdabot>  5800000
10:32:35 <oklopol> > length [1..5900000]
10:32:39 <lambdabot> Terminated
10:32:42 <oklopol> > length [1..5850000]
10:32:46 <lambdabot> Terminated
10:32:49 <oklopol> > length [1..5830000]
10:32:50 <byorgey> oklopol: that's getting somewhat annoying =P
10:32:53 <lambdabot> Terminated
10:32:56 <oklopol> i realize that :)
10:32:58 <drigz> oklopol: are you doing that to investigate why nub of 10000 elements is so fast?
10:32:59 <pjd> oklopol: /query
10:33:11 <drigz> oklopol: /msg lambdabot > ...
10:33:12 <oklopol> oh
10:33:17 <oklopol> i'll do that
10:33:24 <oklopol> didn't realize
10:33:30 <drigz> oklopol: and can i recommend a binary search :D
10:33:44 <oklopol> i'm doing that already
10:33:46 <oklopol> well...
10:33:49 <oklopol> not exactly
10:33:55 <oklopol> but almost
10:34:14 <drigz> oklopol: sorry, my mind told me you'd been doing it a lot longer than you had
10:34:17 <drigz> i'm not sure why...
10:34:34 <oklopol> because it was annoying even in small portions?
10:37:12 <oklopol> (20:35:58) (oklopol) > length [1..5823811]
10:37:12 <oklopol> (20:36:02) (lambdabot) 5823811
10:37:12 <oklopol> (20:36:04) (oklopol) > length [1..5823812]
10:37:12 <oklopol> (20:36:08) (lambdabot) Terminated
10:37:18 <oklopol> because i'm sure everyone is interested :P
10:37:28 <oklopol> that is pretty constant, too
10:40:29 <hkBst> > length $ nub [ a^b | a <- [2..100], b <- [2..100] ]
10:40:31 <hkBst> > length [1..5823811]
10:40:36 <lambdabot>  9183
10:40:37 <lambdabot>  5823811
10:40:40 <hkBst> :(
10:40:59 <oklopol> that's weird: O
10:41:13 <Mitar> any standard way for finding out if there are any duplicates in a unordered list?
10:41:37 <Saizan> nub xs == xs
10:41:57 <oklopol> okay... you can flood that like 10 times and the result is the same
10:42:28 <oklopol> 5823811 works, 5823812 not... i wonder what the real value is :)
10:43:12 <drigz> on my local ghci, legth [1..58...] takes 0.54 seconds, the nub takes 1.28 seconds
10:43:47 <drigz> however, the length allocates 236mb, the nub only allocates 13mb
10:44:26 <dons> what's it like in a file with main = print $ nub ... ; compiled with -O2 ?
10:44:53 <hkBst> Saizan: (map head . group . sort) xs == sort xs      would be faster, right?
10:46:09 <byorgey> hkBst: you probably want to do something like let sxs = sort xs in (map head . group) sxs == sxs
10:46:19 <byorgey> hkBst: just to make sure xs isn't sorted twice
10:46:22 <Saizan> hkBst: i'm not sure, because sort will make it stricter
10:46:50 <hkBst> it will?
10:47:05 <hkBst> byorgey: yeah, wouldn't want that
10:47:48 <byorgey> hkBst: In theory the compiler should be able to do CSE there, but I don't trust it =)
10:51:39 <drigz> hkBst: uncurry (==) . ((map head . group) &&& id) . sort
10:51:54 <drigz> you can probably drop some parens
10:52:03 <drigz> and i'm not sure if &&& is what i want
10:53:05 <hkBst> heh, cool drigz, didn't know that &&& could do that
10:53:13 <hkBst> @src &&&
10:53:14 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
10:53:52 <hkBst> @src >>>
10:53:52 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:54:02 <hkBst> @src ***
10:54:02 <lambdabot> f *** g = first f >>> second g
10:55:40 <drigz> @type (>>>)
10:55:42 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
10:55:51 <byorgey> hkBst: essentially, f &&& g == \f g x -> (f x, g x)
10:56:14 <byorgey> hkBst: it works for general Arrows, but what I wrote above is the function instance
10:56:42 <byorgey> > ((+2) &&& (*5)) 10
10:56:44 <lambdabot>  (12,50)
10:57:53 <drigz> @instance Arrow
10:57:53 <lambdabot> Maybe you meant: instances instances-importing
10:57:57 <drigz> @instances Arrow
10:57:58 <lambdabot> (->), Kleisli m
10:58:27 <drigz> @source first
10:58:27 <lambdabot> first not available
10:58:31 <drigz> @src first
10:58:32 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:58:47 <byorgey> first is one of the functions in the Arrow class.
10:58:58 <byorgey> i.e. every instance of Arrow must define first.
10:59:09 <drigz> byorgey: that makes sense
10:59:13 <byorgey> @type first
10:59:16 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
10:59:23 <drigz> can lambdabot get the source of an instance?
10:59:40 <byorgey> @src (->) first
10:59:42 <lambdabot> first f = f *** id
11:00:23 <byorgey> which is the same as \(a,b) -> (f a, b)
11:08:55 <gpi5> Hi.. I would like to rewrite the following using >>= (but as 'you' is used twice I don't know how to do). Thanks. main = do {you <- getLine; putStr ("You are "++you); putStr (" -- Hello "++you) }
11:09:57 <drigz> getLine >>= \you -> (putStr ("You are " ++ you) >> putStr (" -- Hello " ++ you))
11:09:59 <dylan> @unfo do {you <- getLine; putStr ("You are "++you); putStr (" -- Hello "++you) }
11:09:59 <lambdabot> (getLine >>= \ you -> putStr ("You are " ++ you) >> putStr (" -- Hello " ++ you))
11:10:12 <dylan> @pl (getLine >>= \ you -> putStr ("You are " ++ you) >> putStr (" -- Hello " ++ you))
11:10:12 <lambdabot> ap ((>>) . putStr . ("You are " ++)) (putStr . (" -- Hello " ++)) =<< getLine
11:11:44 <gpi5> @type ap
11:11:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:12:00 <gpi5> @index ap
11:12:01 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
11:12:01 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
11:12:18 <byorgey> gpi5: don't use ap
11:12:34 <byorgey> gpi5: I mean, not for this =)
11:14:09 <gpi5> byorgey: ok :) Just trying to understand.
11:14:29 <drigz> ap is one of those functions that pl uses a lot where you wouldn't expect it
11:14:32 <byorgey> gpi5: sure, nothing wrong with that
11:14:52 <drigz> along with other monad convenience functions, e.g.:
11:14:54 <drigz> @pl concat
11:14:54 <lambdabot> join
11:15:10 <byorgey> (ap .) . flip flip ap . (((ap .) .) .) . ap
11:15:26 <drigz> @unpl (ap .) . flip flip ap . (((ap .) .) .) . ap
11:15:26 <lambdabot> (\ m au r -> (\ bd aj -> ((m >>= \ am -> au >>= \ al -> return (am al)) (\ z aa -> z >>= \ x -> aa >>= \ w -> return (x w)) bd) >>= \ ag -> aj >>= \ af -> return (ag af)) >>= \ o -> r >>= \ n ->
11:15:26 <lambdabot> return (o n))
11:16:04 <byorgey> drigz: I made that up, "in the style of" @pl =)
11:16:17 <drigz> byorgey: i guessed from the type :p
11:16:22 <byorgey> hehe
11:16:29 <drigz> @type (ap .) . flip flip ap . (((ap .) .) .) . ap
11:16:31 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *) a1 b1 a2 a3. (Monad m, Monad m1) => ((m (a -> b) -> m a -> m b) -> a3 -> a2 -> m1 (a1 -> b1)) -> ((m (a -> b) -> m a -> m b) -> a3) -> (a2 -> m1 a1) -> a2 ->
11:16:31 <lambdabot> m1 b1
11:17:06 <byorgey> what, you can't understand that type?
11:18:02 <gpi5> One question: given 1 monad a of type IO String and 2 monads b and c of type String-> IO(). How do I apply the result of a to b and c?
11:18:06 <byorgey> it's clearly equivalent via Curry-Howard to the proof of coadjacency for covariant isometric functoids.
11:18:41 <gpi5> (Without do notation plz)
11:19:33 <dv^1> a >>= \x -> b a >> b c
11:19:49 <drigz> gpi5: write it in do notation and then use @undo
11:19:49 <dv^1> er, no. a >>= \x -> b x >> b x
11:20:18 <drigz> e.g. @undo do {x <- a; b x; c x}
11:20:23 <drigz> @undo do {x <- a; b x; c x}
11:20:23 <lambdabot> (a >>= \ x -> b x >> c x)
11:20:34 <gpi5> @undo do { s<-a; b s; c s}
11:20:35 <lambdabot> (a >>= \ s -> b s >> c s)
11:20:38 <wli> http://www.stormingmedia.us/65/6517/A651704.html
11:20:46 <drigz> @pl \a b c -> (a >>= \ x -> b x >> c x)
11:20:47 <lambdabot> (. liftM2 (>>)) . (.) . (>>=)
11:21:38 <gpi5> @undo do { s<-a; b s; c s; d s}
11:21:38 <lambdabot> (a >>= \ s -> b s >> c s >> d s)
11:29:12 <sfultong> if I'm looking to make a State a (), is it really State I want?  Maybe something else?  Maybe an Arrow?
11:30:41 <elliottt> sfultong: so you want to isolate state operations with a certain state type?
11:30:51 <Botje> sfultong: it's perfectly okay to use the State monad only for the state
11:30:56 <Botje> that's why you have execstate
11:31:34 <elliottt> type MyState a = State a ()
11:31:51 <Botje> sfultong: you could >> get to return the state instead of ()
11:32:45 <sfultong> ah, thanks
11:34:08 <Botje> :t runState (modify (+5)) 9
11:34:16 <lambdabot> forall s. (Num s) => ((), s)
11:34:17 <Botje> :type runState (modify (+5)) 9
11:34:19 <Botje> ah.
11:34:23 <Botje> :type runState (modify (+5) >> get) 9
11:34:29 <gpi5> @undo do { s<-a; do {ss<- e; f ss}; b s; c s; d s}
11:34:30 <lambdabot> (a >>= \ s -> e >>= \ ss -> f ss >> b s >> c s >> d s)
11:34:34 <Botje> :t runState (modify (+5) >> get) 9
11:34:36 <lambdabot> forall s. (Num s) => (s, s)
11:34:41 <Botje> \bot is feeling sluggish today
11:35:05 <gpi5> @undo do { s<-a; when test do {ss<- e; f ss}; b s; c s; d s}
11:35:05 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 50}) "Parse error"
11:35:06 <sfultong> huh, I didn't know there was an @undo command
11:35:12 <gpi5> @undo do { s<-a; when test (do {ss<- e; f ss}); b s; c s; d s}
11:35:12 <lambdabot> (a >>= \ s -> when test (e >>= \ ss -> f ss) >> b s >> c s >> d s)
11:35:12 <lambdabot> Sorry, was at a party last night.
11:35:18 <Botje> sfultong: alterantively you wan use execstate to just get the state
11:35:25 <Botje> @src execState
11:35:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:35:40 <Botje> *can
11:35:43 <elliottt> runState?
11:36:08 <Botje> it runs a computation in the State s a monad
11:36:13 <dons> http://programming.reddit.com/info/2pjok/details
11:36:14 <lambdabot> Title: Johan Jeuring on Generic Haskell :: Video (reddit.com)
11:36:17 <dons> more videos!
11:36:26 * ari watches
11:37:36 <ari> Wait, I thought continentals didn't do Haskell :/
11:38:06 <dons> europeans? that's haskell central, just about it.
11:38:15 <Botje> I resent that remark!
11:38:20 <dons> 'cept .fr of course ;)
11:39:11 <elliottt> uh oh, he's looking for students :)
11:39:11 <sfultong> has fr been consumed with O'Caml?
11:41:34 <ari> dons: Heh, it's just that I kinda got the idea that there's a lot of Brits doing Haskell from LHUG and AngloHaskell, and since the Brits never do things the same way as the continentals (and vice versa) I derived that there can be no German Haskellers ;)
11:42:00 <ricky_clarkson> ari: It seems, sadly, that all the Brit Haskellers are from the south.
11:42:15 <dons> oh,  I think there's a fair few German haskellers
11:42:41 <pejo> dons, bummer - all the other talks are in german.
11:43:18 <elliottt> pejo: time to learn german :)
11:43:19 <ricky_clarkson> Would you say that (*) 2 is a result of automatic currying, or an example of a section?
11:43:24 <pejo> ari, Peter Thiemann, Ralf Hinze, Ralf Lmmel (?).
11:43:46 <sfultong> one's in english
11:43:47 <thetallguy> Does the term ``immediate value'' mean anything to you guys?
11:44:00 <thetallguy> as in, we apply f to all immediate values:   C t1 t2 ... tn  becomes C (f t1) (f t2) ... (f tn)
11:44:57 <sfultong> intermediate?
11:45:46 <thetallguy> no.  immediate
11:45:47 <Botje> ricky_clarkson: (*) 2 is currying, (*2) is a section.
11:45:58 <twanvl> I would say "(direct) children"
11:46:16 <twanvl> (*) 2 is partial application
11:46:19 <ricky_clarkson> Botje: I struggle to see the difference.
11:46:40 <ricky_clarkson> Except that (*2) provides the 2nd arg to *.
11:47:27 <Botje> I meant (2*), yes
11:47:38 <monochrom> "immediate value" sounds like assembly
11:48:41 <thetallguy> monochrom: in this case, I think it means that  f is not applied recursively
11:48:52 <Botje> ricky_clarkson: if you were mapping over a list, sections allow you to write "map (+5) list" instead of "map ((+) 5) list"
11:49:10 <Botje> that's .. pretty much their raison d'etre :)
11:49:44 <ricky_clarkson> I mean, other than the syntax, I can't see what the difference is.
11:50:41 <thetallguy> This is from a generic programming paper.  The example actually uses a type representation C (f rt1 t1)...
11:51:04 <thetallguy> so I think it means, apply it to the current level/type, but not recursively.
11:51:12 <Botje> ricky_clarkson: there isn't. sections are syntactic sugar
11:51:58 <shapr> @seen SyntaxNinja
11:51:58 <lambdabot> I saw SyntaxNinja leaving #haskell-soc, #haskell-blah and #haskell 1d 18h 36m 17s ago, and .
11:52:12 <shapr> libcurl3 is broken in debian/unstable, and I want my darcs!
11:52:23 <byorgey> ricky_clarkson: sections are syntactic sugar for partial application.
11:52:37 <ricky_clarkson> Thanks.
11:52:43 <shapr> @tell SyntaxNinja libcurl3 is broken in debian/unstable, and I want to install darcs!
11:52:43 <lambdabot> Consider it noted.
11:53:59 <hpaste>  conal pasted "mulitple monad transfo lifters.  does this exist already?" at http://hpaste.org/2754
11:54:12 <dons> shapr: does Isaac maintain libcurl3?
11:54:32 <dons> i can tell him if you like, he's sitting next to me if its important
11:55:32 <shapr> dons: I don't know if there's anything he can do about libcurl3 being broken, but I would like to install/use darcs.
11:56:10 <thetallguy> shapr: Maybe you should grab a copy of our autobuilder and build your own.
11:57:08 <shapr> thetallguy: I tried to build my own. libcurl3 wants libssh2-0, but only libssh2-1 is available. So I hacked the debian/control build-deps and ran debuild, but I got linker errors. I suspect that libssh2-1 has a slightly different API.
11:57:35 <shapr> thetallguy: I would like to package the Freespire Haskell tools for debian though :-)
11:57:42 <wli> Hmm. Helicopter aerodynamics is complicated (and controls don't look terribly obvious either). NFI how simulators like video games even manage to cheat for standard helicopters, never mind tiltrotors et al.
11:57:48 <conal> is there already a way to lift through any number of layers of monad transformers (in mtl)  (see paste)
11:58:58 <shapr> wli: Helicopter controls are unintuitive because you have to manually correct for rotor torque.  It could be done automatically these days, but all pilots have the old way built into their cerebellum.
12:00:01 <thetallguy> shapr: are you a debian developer?  They are already debianized.  They just need a sponsor, really.
12:00:16 <shapr> thetallguy: I am not a DD, but I know a bunch from #haskell
12:00:19 <salparot> two pedals for controlling the force of the counter-rotor-whatchamacallit, one lever for controlling force (main rotor blade tilt?) and a joystick for tilting the rotor... it's only like 4-dimensional ;-)
12:00:22 <shapr> I would like to become a DD.
12:00:45 * wli just went emeritus.
12:00:52 <thetallguy> shapr: That's a tricky problem you've got.  I know the theoretical answer
12:00:56 <shapr> salparot: Ah, but pulling up on the rotor tilt lever increases rotor torque, and you have to correct with the foot pedals.
12:01:01 <shapr> thetallguy: eheh
12:01:31 <shapr> thetallguy: Theoretically, it's easy to become a DD. Practically, you better know one or more influentials DDs to get anywhere.
12:01:41 <shapr> I should have done it in y2k when it was easy.
12:01:48 <thetallguy> shapr: NixOS uses the right solution, specifying a list of all source packages down to the version, then building the entire OS and installing it.
12:02:05 <shapr> Oh, that problem.
12:02:21 <thetallguy> shapr: our autobuilder doesn't quite do that yet, because I didn't communicate the design to David correctly
12:02:36 <thetallguy> shapr: the problem of becoming a DD is way beyond my skill level.
12:02:48 <shapr> heh
12:02:50 <shapr> Who's David?
12:02:55 <Lemmih> I'm David.
12:02:59 <shapr> Oh that David.
12:03:04 <thetallguy> David Fox, another former Linspire guy
12:03:17 <shapr> How many Haskellers do you have at Linspire?
12:03:24 <thetallguy> stepcut, David and I were it
12:03:28 <Lemmih> Oh well. My day will come.
12:03:31 <thetallguy> only stepcut remains
12:03:36 <thetallguy> sorry lemmih
12:03:41 <salparot> oh, I see.. so you would have a computer keeping the helicopter at balance, and then something like a twistable joystick to rotate left and right... downside is, anyone learning to fly a new one won't be able to fly anything else
12:03:45 <shapr> thetallguy: You're not at Linspire?
12:03:56 <thetallguy> shapr:  no, recently departed
12:04:02 <shapr> thetallguy: What are you doing now?
12:04:08 <shapr> If you don't mind me asking :-)
12:04:43 <thetallguy> shapr:  starting a company.  going to tackle teaching math skills to kids
12:04:52 <shapr> olsner: Well, I can't use VMS or Fortran... not sure I'm missing anything :-) I'd rather have an intuitive helicopter interface so that emergency pilots can always handle it.
12:04:55 <shapr> thetallguy: Sounds cool!
12:04:59 <thetallguy> shapr: on the web, of course, via games
12:05:14 <thetallguy> shapr: stepcut is working on haskell -> flash compiler
12:05:21 <wli> shapr: Well, the point of all this seems to be that there's not much info about helicopter dynamics simulation out there partly because it appears that it looks like a hard problem in general.
12:05:48 <thetallguy> shapr: Yeah, should be fun.  Lots of graphics, UI, Haskell.
12:06:19 <shapr> wli: Wouldn't dual counter-rotating props be simplest to simulate?
12:06:34 <shapr> thetallguy: Cool, server from Haskell to flash?
12:06:38 <wli> shapr: And that's for normal helicopters; for weird things like the V-22 and V-44 look like total nightmares to simulate.
12:07:08 <wli> shapr: No idea, really. Aren't those mostly Russian?
12:07:18 <thetallguy> shapr: I don't understand.
12:07:59 <thetallguy> shapr:  the goal is to make a DSEL that we can call flash libraries and which gets compiled down to flash bytecode
12:08:11 <thetallguy> shapr: does that answer your question?
12:08:27 <Heffalump> are the 6.8 snapshots reasonably usable?
12:08:33 <fax> hiya
12:08:59 <shapr> thetallguy: yes
12:09:06 <olsner> btw, my university has a research project on a UAV helicopter... helicopter dynamics must've been an issue at some point, I wonder if there's any meaty published on that
12:09:17 <byorgey> hi fax
12:09:26 <Igloo> Heffalump: I'd wait for the next one
12:09:53 <dons> Igloo: just got Linker.c to build on the amd64/openbsd btw.
12:09:56 <dons> will have a patch later today
12:10:11 <Igloo> dons: Great, thanks!
12:10:13 <dons> linux-specific x86_64 syms used in linker calls
12:10:33 <thetallguy> shapr: of course, there will be issues of how to do the server side handling of communication, running it inside HAppS, etc.
12:10:44 <Heffalump> ok, ta
12:10:47 <shapr> thetallguy: Ah, you'll be using HAppS?
12:10:49 <dons> Igloo: do you know where we test for #defines for Linker.c now?
12:11:00 <shapr> thetallguy: I'll be able to help :-)
12:11:07 <dons> or do we just go with !defined(openbsd_HOST_OS) ?
12:12:52 <thetallguy> shapr:  That's the plan.  We'll see what happens when the rubber meets the road.
12:13:01 <thetallguy> shapr: will you be in Freiburg?
12:13:18 <shapr> thetallguy: Nope, too poor.
12:13:26 <shapr> thetallguy: But I'll be at AmeroHaskell, will you be there?
12:13:55 <Igloo> dons: Can't you use #if defined(the_define)?
12:14:09 <Lemmih> thetallguy: Looking for co-founders/partners/employees?
12:14:36 <shapr> thetallguy: Yeah, if you're looking for workers, I'm interested!
12:15:27 <dino-> AmeroHaskell?
12:15:44 <shapr> dino-: C'mon, it's been around for more than an hour and you haven't heard of it? ;-)
12:15:45 <thetallguy> lemmih, shapr: we are full up for now
12:15:58 <dino-> shapr: Been busy installing happs 0.9.1
12:16:27 <thetallguy> lemmih, shapr: but will certainly be coming to this community for help if we succeed
12:16:31 <shapr> spiffy
12:16:35 <thetallguy> shapr: where is AmeroHaskell
12:16:37 <thetallguy> ?
12:16:37 <shapr> dino-: How do you like it?
12:16:42 <thetallguy> when/where?
12:16:49 <dino-> shapr: Don't know yet, still darcs getting and building stuff.
12:16:50 <shapr> thetallguy: Both of those depends on the attendees.
12:17:02 <shapr> dino-: The install order:  Util, Data, IxSet, State, Server, Begin
12:17:07 <thetallguy> shapr: okay, where is the signup page?
12:17:12 <shapr> @wiki AmeroHaskell
12:17:12 <lambdabot> http://www.haskell.org/haskellwiki/AmeroHaskell
12:17:32 <dino-> shapr: Yeah. Should change the order of those lines in the page.
12:17:36 <Lemmih> dino-: Or: SearchPath, Begin
12:18:15 <thetallguy> shapr: so just in the conceptual stage
12:18:28 <thetallguy> where will ICFP 2008 be?
12:18:34 <dino-> SE US? When do we want to do this?
12:19:00 <shapr> thetallguy: Yeah, but going from concept to reality doesn't take long. EuroHaskell was disorganized about .. three weeks? ahead of time, and AngloHaskell was more like two weeks.
12:19:26 <shapr> dino-: I'd like to do it soon.
12:19:29 <wli> Much like Haskell itself.
12:19:40 <dino-> Week of Oct 13-20 is out for me. Family visiting.
12:19:51 <dino-> From far away, flying in.
12:20:04 <Philippa> shapr: AH benefitted from it being 2 months out this time round, IMO
12:20:13 <shapr> dino-: Add yourself to the wikipage, along with your location, and times you'd prefer.
12:21:37 <shapr> @where pandoc
12:21:37 <lambdabot> http://sophos.berkeley.edu/macfarlane/pandoc/
12:25:17 <dino-> shapr: Ok, done
12:25:31 <shapr> spiffy
12:26:56 <shapr> Are the pandoc developers on #haskell?
12:27:08 * shapr found bugs
12:27:41 <shapr> It really sucks that darcs doesn't work :-(
12:28:19 <shapr> Has anyone else tried to install libcurl3 on debian/unstable? Am I making a mistake?
12:28:25 <thetallguy> shapr: yes, it does
12:28:39 <wli> shapr: The first thing I tried darcs on was the Linux kernel. I'm used to that by now.
12:28:44 <thetallguy> shapr: oh, you mean when it doesn't install.  Yes, that sucks too
12:29:45 <shapr> darcs usually works fine for me, I don't use repos the size of the Linux kernel.
12:31:17 <wli> shapr: The Linux kernel is the only thing where I need revision control.
12:45:16 <dino-> shapr: What's the purpose of the SearchPath part of starting the happs? Is it required?
12:45:32 <shapr> dino-: It's not required.
12:45:47 <dino-> I looked at the page, but am kind of confused about what it's for.
12:45:50 <shapr> But the purpose is to automatically download all the files you need and build the app.
12:46:12 <dino-> Also, relying on magic download for start.. makes me nervous. :D
12:46:28 <Baughn> In 'liftM2 (,) succ pred', /which/ monad is being invoked?
12:46:36 <dino-> I'd rather know what's needed, get it, be totally clear about it.
12:46:37 <shapr> Cabal does not support downloading packages from the internet, and cabal-install only supports the one hackage server.
12:46:48 <oerjan> Baughn: e ->
12:47:03 <oerjan> succ and pred are elements of the monad
12:47:21 <Baughn> Good point. I'm really going to have to read about the -> monad now.
12:47:45 <mauke> liftM2 c f g x == f x `c` g x
12:49:06 <oerjan> :t liftM2 (,) succ pred
12:49:08 <lambdabot> forall a. (Enum a) => a -> (a, a)
12:49:16 <mauke> :t succ &&& pred
12:49:18 <lambdabot> forall a. (Enum a) => a -> (a, a)
12:49:34 <Baughn> :t (&&&)
12:49:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:49:40 <dino-> shapr: thank you
12:49:49 <oerjan> that's the -> arrow :)
12:50:26 <Baughn> mauke: Arrows and such are a part of haskell I've been putting off learning. I've looked for a book that describes them, but without much luck - any suggestions?
12:50:42 <mauke> sorry, I don't understand arrows either
12:50:59 <shapr> mmm arrows
12:51:12 <oerjan> @go arrows site:haskell.org/haskellwiki
12:51:15 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows
12:51:15 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki
12:52:01 <oerjan> http://www.haskell.org/haskellwiki/Arrows -- testing
12:52:02 <lambdabot> Title: Arrows - HaskellWiki
12:52:26 <Baughn> Research papers aren't quite what I'm looking for, but if that's what there is, I'll read them. Thanks.
12:53:30 <oerjan> oh wait, false alarm
12:53:53 <scv> http://www.haskell.org/haskellwiki/Arrow
12:53:54 <lambdabot> Title: Arrow - HaskellWiki
12:53:56 <oerjan> apparently it is not that easy to find out if a wiki page exists...
12:54:03 <monochrom> I would think arrows are easier to understand than monads, since arrows are much closer to side-effectful functions than monads are.
12:55:15 <shapr> I think arrows are easier to understand than monads.
12:55:38 <trez> good for you
12:55:43 <Heffalump> you're both crazy
12:55:57 <Heffalump> they're way more complicated, the notation is much more complicated with a non-local desugaring
12:57:05 <shapr> I didn't say they were simpler, I said they're easier to understand.
12:57:08 <dino-> shapr: heh, I hope that's true about arrows.
12:57:59 <oerjan> http://www.haskell.org/haskellwiki/Arrow_tutorial
12:58:01 <lambdabot> Title: Arrow tutorial - HaskellWiki
12:58:01 <shapr> I like the arrows as monoids paper - http://lambda-the-ultimate.org/node/1750
12:58:02 <lambdabot> Title: Arrows, like Monads, are Monoids | Lambda the Ultimate
12:58:03 <dino-> Messing with HXT, it seemed like something was simpler. It's all like data types in, data types out. Chain them together by matching types.
12:58:15 <shapr> Yeah, first class transformers...
12:58:36 <shapr> lego functions
12:58:56 <monochrom> The >>> operator is just glorified function composition. Or unix piping. Whereas the >>= operator is more subtle.
12:59:23 <Philippa> Heffalump: not everyone considers understanding haskell's arrow sugar part of understanding arrows :-)
12:59:26 <dolio> So, someone on the c.l.functional newsgroup asked why currying was any good, and I posted a response talking about how it encourages function definition by composition/etc. of partially applied functions, which can be nice...
12:59:35 <dino-> I don't get yet why the pairs of things are so important, what's the signficance.
12:59:57 <dolio> And he sent me an e-mail response saying: "Wow, I can now see how alot of abstractions in the OO world can berepresented as partially evaluated functions."
13:00:03 <dolio> Is that sarcasm? I can't tell.
13:00:16 <Philippa> probably not
13:00:19 <monochrom> If you don't have currying, you need pairing. The arrow story doesn't offer currying. So it has to offer pairing.
13:00:29 <Philippa> closures are a poor man's objects, objects are a poor man's closures
13:00:45 <fax> When you create a new object, before calling one of its functions.. in a loooong stretch you could consider that partial application
13:00:53 <fax> er methods, not functions
13:01:05 <Philippa> right, arrows actively avoid higher-order computations (ArrowApply aside) because otherwise they'd be monads
13:01:18 <Philippa> (or at least isomorphic to monads)
13:01:31 <Heffalump> arrow code without arrow notation is pretty hard to read
13:01:49 <dolio> I suppose that's true. I just thought it was a wild jump from what I actually talked about. :)
13:02:03 <dino-> Also, I look forward to when there are speakable names for these functions like (>>>) and (***) etc..
13:02:14 <Philippa> there are already
13:02:31 <Philippa> "compose", "fan in/out" etc etc
13:02:43 <dolio> >>> is compostion, clearly. *** is like tupling of functions.
13:03:03 <oerjan> http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html
13:03:07 <Philippa> they're in one or more of the papers
13:03:08 <lambdabot> Title: RE: What's so cool about Scheme?, http://tinyurl.com/25ejt3
13:03:55 <sorear> .
13:05:45 <oerjan> a useful operator indeed.
13:06:20 <pjd> fax: that's a not uncommon pattern in Python
13:06:53 <monochrom> Oh I see. If you have been programming pointful all your life (basing yourself on function application), you will understand monads easier, since >>= is glorified function application. If you have been programming pointfree all your life (basing yourself on function composition), you understand arrows easier, since >>> is glorified composition.
13:07:32 <dolio> So arrows are easier for APL programmers?
13:07:51 <oerjan> @remember monochrom Oh I see. If you have been programming pointful all your life (basing yourself on function application), you will understand monads easier, since >>= is glorified function application. If you have been programming pointfree all your life (basing yourself on function composition), you understand arrows easier, since >>> is glorified composition.
13:07:52 <lambdabot> Done.
13:08:14 <monochrom> function composition or unix piping. For example unix sysadmins who pipe all the time understand arrows easier.
13:09:33 <Botje> as long as they don't loop back to themselves
13:09:38 <monochrom> Take for example *** and &&&. A pointful programmer may go like, what's the big fuzz, just write (f x, f y) or something. Ah, but if you go pointfree, you can't do that, you need a helper operator.
13:10:57 <dino-> I have both HAppS 0.9.1 and 0.8.8 now and am getting compile complaints. Is it as simple as just ghc-pkg unregister to deal with this?
13:11:14 <dino-> (assumign I don't mind ditching the 0.8.8, of course)
13:11:30 <Lemmih> dino-: GHC should use 0.9.1 by default.
13:11:44 <dino-> :/
13:12:01 <dino-> Could not find module `HAppS': it was found in multiple packages: HAppS-Server-0.9.1 HAppS-0.8.8
13:12:30 <Lemmih> dino-: Oh right. Yeah, just unregister HAppS.
13:12:58 <alexj> dino, you may find it easier to use searchpath and avoid package manager weirdness.
13:13:48 <dino-> alexj: So that does more than just download things needed?
13:14:48 <alexj> it does module chasing accross the internet, puts all the modules you need in .haskell-cache and adds the correct -i.haskell-cache/... to your command line so everything just works properly.
13:15:02 <dino-> I need to read about it more. At the risk of sounding paranoid, I don't like things that Just Work necessarily until I know what they're doing.
13:15:19 <alexj> the searchpatch code is pretty short.
13:16:00 <alexj> it looks at the module you pass on the command line, finds its import statements, looks up the urls for those modules on the modulemaps, downloads the modules, looks up those imports etc.
13:16:19 <alexj> it uses curl to retrieve the modules from the internet.
13:17:48 <dino-> And then keep these things in ~/.haskell-cache/  It sounds nifty. Thank you for explaining.
13:18:39 <alexj> also, you can add your own module maps if you don't like mine.
13:18:50 <alexj> no problem.
13:18:58 <dino-> alexj: Like if you maybe want to pin something to a specific version?
13:19:03 <alexj> yeah.
13:19:27 <alexj> or you have your own version of some public lib.
13:19:43 <alexj> you can pass as many module maps on the command line as you like.
13:20:04 <dino-> Well, I've never seen anything like that. Not with CPAN or whatever.
13:21:23 <dino-> I could see it being used by a company to point all developers to the 'approved' modules. Interesting.
13:21:54 <dino-> Could this become part of Cabal behavior? Or does that not make sense?
13:22:09 <alexj> perhaps it could.  I don't really like the concept of packages.
13:22:31 <alexj> you need packages only when you have to compile C and link to it.
13:22:48 <sorear> even then you don't
13:22:51 <alexj> if you are doing that, you should have special functionality for that specific thing.  otherwise modules describe dependencies well enough.
13:22:59 <dino-> I guess so far I mainly use Cabal myself as a build system to avoid icky Makefiles.
13:23:08 <sorear> nothing stops GHC from supporting inline C in haskell code with -fvia-C, for instance
13:23:13 <sorear> ghc --make ftw
13:23:43 <pejo> dino, you can emulate the described behaviour by setting an environment variable for your users. PERL5LIB iirc.
13:23:44 <mauke> http://search.cpan.org/~adamk/Acme-Everything-1.00/lib/Acme/Everything.pm
13:23:47 <lambdabot> Title: Acme::Everything - Effectively loads every class in CPAN - search.cpan.org, http://tinyurl.com/2skopr
13:24:06 <fax> woah :D
13:25:30 <oerjan> works perfectly until it suddenly drops an anvil on you?
13:26:00 <mauke> you seem to be unfamiliar with the Acme:: namespace
13:26:53 <oerjan> would _you_ trust something named Acme? :D
13:27:06 <mauke> http://search.cpan.org/~asavige/Acme-EyeDrops-1.51/lib/Acme/EyeDrops.pm
13:27:09 <lambdabot> Title: Acme::EyeDrops - Visual Programming in Perl - search.cpan.org, http://tinyurl.com/z5y6n
13:27:31 <sjanssen> alexj: what does searchpath do about versioning?
13:27:49 <alexj> use urls to point to the version you want.
13:28:28 <thetallguy> shapr: added my name to the AmeroHaskell page, fixed up my wiki account to be current.
13:28:43 <shapr> thetallguy: spiffy!
13:29:16 <sorear> AmeroHaskell eh?
13:29:36 <wli> I can confirm I'm not going.
13:31:02 <Saizan> ?wiki AmeroHaskell
13:31:02 <lambdabot> http://www.haskell.org/haskellwiki/AmeroHaskell
13:31:27 <sorear> mauke: wow, even Befunge is more readable than that
13:31:33 <sjanssen> alexj: is that compositional?  My program depends on third party module Foo, and Foo only works with a certain version of yet another module Bar
13:32:10 <sjanssen> alexj: do I have to know all the details of Foo's version dependencies to use it?
13:32:12 <wli> Didn't a Haskell programmer trump all in terms of unreadability with a whitespace-only language?
13:32:14 <alexj> That is my objection to version system in cabal
13:32:20 <jatqceer> has anyone written some functional matrix inversion code?
13:32:36 <wli> Matrix inversion is almost universally a numerically bad idea.
13:32:45 <sorear> wli: edwinb *created* whitespace, but that's a whole new language
13:32:50 <alexj> since you can only have one version of a particular package/module in a particular program, you can only have one map.
13:32:53 <sorear> wli: this code is apparently valid Perl
13:32:56 <mauke> whitespace only? no problem: http://search.cpan.org/~dconway/Acme-Bleach-1.12/lib/Acme/Bleach.pm
13:32:59 <lambdabot> Title: Acme::Bleach - For really clean programs - search.cpan.org, http://tinyurl.com/28xpr
13:33:01 <alexj> one ovverall map.
13:33:06 <sorear> alexj: eh?
13:33:10 <alexj> that map is determined by the top level program.
13:33:16 <sorear> alexj: you can have as many map's as you want...
13:33:24 <jatqceer> specifically LU decomposition with partial pivoting?
13:33:49 <alexj> sorear: there is only one module/package namespace and that is determined by the set of maps you pass to searchpath.
13:34:08 <sorear> alexj: they fixed that recentlyish in GHC *fetches commit message*
13:34:27 <dino-> alexj: Are you saying, the ghc registration system only allows you to have one ver, but perhaps projects on the one system need different versions of some lib?
13:34:27 <JohnMeacham> tHmm... we should have that or something similar (AmeroHaskell) on the west coast.. I recommend san fransisco.
13:34:46 <dino-> Like I just had here, sure I can get rid of 0.8.8, but what if that was inconvenient.
13:34:47 <sjanssen> sorear: symbols have contained the package name and version since 6.6 IIRC
13:34:49 <wli> JohnMeacham: San Francisco I can make it to.
13:34:59 <sorear> sjanssen: right
13:35:04 <alexj> JohnMeacham: I am in sanfracisco, so I would suport that.
13:35:09 <sorear> sjanssen: 6.6 is within my recentlyish
13:35:12 <wli> I won't set foot in red states.
13:35:21 <sjanssen> dino-: you can probably lift that restriction using -package flags or Cabal
13:35:34 <JohnMeacham> wli: Yeah, there are a lot of people up and down the west coast. I am in los angeles (pasadena actually) but can travel to san fran on 6 hours notice.
13:35:34 <alexj> dino: I am saying that each project should be able to determine what packages it wants.  a global package system does not make sense.
13:35:37 <dino-> sjanssen: could I have kept both.. ok, was just going to ask about specifying in the .cabal file.
13:35:45 <alexj> every project has its own .haskell-cache.
13:35:51 <Nafai> wli: How about a blue city in a red state?
13:35:53 <sjanssen> wli: are you serious?  That's really ridiculous
13:35:57 <wli> JohnMeacham: Similar here.
13:36:04 <sorear> alexj: a global DNS makes even less sense </troll>
13:36:17 <Saizan> alexj: but every .cabal can specify which version it wants from the ones available
13:36:35 <Heffalump> which is red and which is blue?
13:36:39 <alexj> Saizan: thats wonderful until you have conflicting dependencies in the cabal files.
13:36:41 <wli> sjanssen: I may be completely out of my mind, but I'm not suicidal, hence, no setting foot in red states.
13:36:46 <sorear> Don't know, don't care
13:37:01 <sjanssen> wli: I find that opinion a bit offensive
13:37:07 <Saizan> alexj: why?
13:37:16 <Nafai> wli: closed minded even
13:37:37 <alexj> my program depends on Package Foo v1.2 and package Goo v2.4.
13:37:47 <alexj> Package Goo updates and now depends on Foo v1.1....
13:37:50 <wli> sjanssen: That's fine. You can be offended. I'll stay alive.
13:37:57 <fax> blah
13:38:01 <sorear> alexj: cabal/GHC can handle that just fine
13:38:06 <Saizan> alexj: you just need to install Foo 1.1 too
13:38:18 <alexj> so now your program uses both Foo 1.2 and Foo 1.1?
13:38:35 <sorear> yep.
13:38:39 <sjanssen> wli: you think someone will kill you in eg. Nebraska?
13:39:00 <alexj> so the error message blah blah in Foo.Bar applies to which module?
13:39:17 <Saizan> alexj: that's when you're not using cabal, but just --make
13:39:18 <dino-> But wait, in this one project, with both foo-1.2 and foo-1.1 in the depends, presuming both.. yeah, the import statement.
13:39:21 <jatqceer> I really wish there would be Numerical Recipes in Haskell.
13:39:50 <wli> sjanssen: Yes.
13:39:51 <alexj> Saizan: my point is that Cabal just invites confusion about the meaning of import statements.
13:40:03 <Saizan> dino-: Goo will have 1.1, and your project will use 1.2, no conflict there
13:40:20 * Nafai boggles at wli
13:40:29 <ddarius> goo that lispy language?
13:40:30 <dino-> Saizan: I see. But if your actual source code requires both. Which probably makes no sense.
13:40:34 <fax> maybe he owes money :p
13:40:42 <sorear> alexj: moreso than Haskell invites confusion about the meaning of unqualified identifiers?
13:40:47 <Mr_Awesome> Nafai: careful, one time i boggled so hard, i got a hernia
13:40:52 <dino-> Or at least could be fixed in YOUR source.
13:40:56 <Nafai> Mr_Awesome: Heh.  Those aren't fun.
13:41:14 <sjanssen> wli: what if I were to say "I refuse to step foot in a blue state, they might force me into a same-sex marriage"?
13:41:17 <Mr_Awesome> indeed not
13:41:17 <alexj> Saizan: module namespace is global.
13:41:21 <sjanssen> wli: doesn't that sound ridiculous to your ears?
13:41:24 <Saizan> dino-: i don't think that can be solved even with searchpath if you want the same module from both
13:41:41 <sorear> alexj: no it's not
13:41:50 <sorear> alexj: it depends on exposed modules
13:42:02 <Saizan> alexj: no, because you can hide packages
13:42:07 <Heffalump> sjanssen: a better parallel might be "I might see a same-sex marriage"
13:42:16 <sorear> alexj: with -hide-all-packages -package goo-1.1,  Foo.Bar refers to goo-1.1:Foo.Bar
13:42:23 <sorear> alexj: with -hide-all-packages -package goo-1.2,  Foo.Bar refers to goo-1.2:Foo.Bar
13:42:34 <alexj> in the same program?
13:42:37 <Adamant> sjanssen, you can't reason someone out of opinions that were not formed by reasoning.
13:42:48 <alexj> module namespace is global within a particular program.
13:42:58 <dylan> I don't see a problem with not wanting to visit any particular state for any arbitrary reason. I will never visit New York City because I hate cement buildings.
13:43:26 <sjanssen> Heffalump: seeing a same-sex doesn't nearly approach being killed, no matter how closed-minded you are -- just trying to come up with an equal-but-opposite ;)
13:43:40 <alexj> can we push the political conversation to a different channel.  Red/Blue blah does not affect whether my program compiles.
13:43:46 <Heffalump> being forced into one seems rather less likely than being killed, though
13:44:07 * Heffalump --> #haskell-blah
13:44:15 <oerjan> mauke++
13:44:24 * sjanssen apologizes
13:44:25 <dino-> dylan: Aw, NYC is so full of stuff to do.
13:45:00 <alexj> sorear: does my correction make sense: module namespace is global within a particular program?
13:45:09 <dino-> And food! Constantly assaulting you from every direction. :D
13:45:09 <wli> There are other considerations that make it impossible for people to attend conferences in particular countries. For example, security experts that do any sort of published penetration analysis are essentially prosecutable in the US, so they can't go to conferences here.
13:45:11 <dylan> dino-: It needs to be terraformed into a liveable environment. Also I have issues that the land would be better suited to the production of food...
13:45:37 <Heffalump> alexj: one side or the other might outlaw open source if left in power for long enough :-)
13:45:59 <Adamant> wli, you are on crack. Has Blackhat been shut down and nobody told me?
13:46:04 * dino- pouts
13:46:04 <sorear> alexj: yes, s/program/compilation unit/; but foo and goo are different compilation units (in Cabal), so it doesn't hurt
13:46:25 <Nucleo> Has anyone here a copy of Algorithms: A Functional Programming Approach?
13:46:32 <Heffalump> hmph. My bytestring program can either use 250M of RAM and take about 7 seconds, or about 45MB and take about 20 seconds.
13:46:38 <Nucleo> (and if so, is it worth $100 US? )
13:46:52 <alexj> so that means that I can't use an XML datatype I get from Goo in my program because Data.Foo.Xml means something different.
13:47:04 <wli> Adamant: No, I'm not. There is a cadre of programmers who do security work on Linux who refuse to enter the US or US-controlled territory on account of this.
13:47:28 <alexj> Goo's documents tell me that some function returns a Data.Foo.Xml, I should be able to use it.
13:47:43 <Heffalump> the US certainly strikes me as a dangerous environment for some security research
13:47:46 <Adamant> wli, they can believe whatever they want. There are security conferences held every year with American and foriegn researchers
13:47:48 <alexj> Now you are telling me that I have two different Data.Foo.Xml in my program.
13:48:35 <Adamant> jesus h, Germany just outright banned hacking tools. Guess where a lot of their projects are ending up. Hint - US
13:48:40 <wli> Adamant: This is in fact so significant it has affected the location of certain Linux-related conferences.
13:48:52 <dino-> Adamant: Dmitry Sklyarov  http://en.wikipedia.org/wiki/Dmitry_Sklyarov
13:48:54 <lambdabot> Title: Dmitry Sklyarov - Wikipedia, the free encyclopedia
13:49:14 <alexj> wli: does this discussion have anything to do with Haskell?
13:49:37 <wli> Adamant: I've not followed this topic closely. It has merely made it a major PITA for me to attend certain conferences because foreign travel vs. corporate expenses is painful.
13:49:49 <fax> wli: please talk elsewhere about this e.g blah
13:50:01 <dino-> Yeah, all this stuff to -blah
13:50:03 <wli> alexj: Conference locations.
13:50:46 <alexj> wli: I think about haskell sometimes when I take showers.  That does not mean it makes sense to open up a discussion about bathroom fixtures here.
13:51:22 <fax> alternatively keep your paranoia to yourself :P
13:51:59 <alexj> sorear: I don't want to different versions of Data.Foo.Xml in my programs.
13:52:28 <wli> In conclusion, I cast my vote in favor of San Francisco.
13:52:39 <monochrom> mainstream languages are like bar soap. haskell is like body wash gel.
13:53:03 <nominolo> :t foldr1
13:53:09 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
13:53:09 <alexj> with haskell, my code is already clean!
13:53:15 <dino-> Well, I don't know that I can go to SF. Been on a few trips lately and just lost my job.
13:53:43 * ddarius prefers bar soap...
13:54:11 <dmwit> huh
13:54:20 <dmwit> ?pl /f g h a -> f (g a) (h a)
13:54:21 <lambdabot> (line 1, column 1):
13:54:21 <lambdabot> unexpected "/"
13:54:21 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
13:54:29 <dmwit> ?pl \f g h a -> f (g a) (h a)
13:54:30 <lambdabot> liftM2
13:54:30 <shapr> other slash?
13:54:38 <dmwit> So succint!
13:54:56 <sorear> alexj: I see this as a problem with Haskell's type system, since it affects far more than just Cabal.  In particular, all dynamic code loading systems are segfault-prone because dynamism and nominal type equality, are just plain incompatible.
13:55:29 <dino-> alexj: I'll say this, coming from many (dreary) years working in Java, I sometimes felt like it would be nice to be able to include something just for this project (like you can in Java with jar files) as opposed to system-wide. SearchPath reminds me of that.
13:57:48 <nominolo> sorear, there's a guy on LtU that want's to implement a PL where types are normalized
13:58:17 <nominolo> sorear, even, e.g., [Bool] ~~ Integer
13:59:45 <nominolo> however, considering how complicated equi-recursive types are compared to iso-recursive, i'm not so sure that will ever work out
13:59:54 <alexj> dino: yes. I like having everything specific to my project.  I don't see value in global packages except saving disk space which is very cheap.
14:00:09 <Heffalump> it's also a management issue
14:00:13 <Heffalump> easier to update one central thing
14:00:24 <alexj> sorear: since we don't really have dynamism anyway, I like having nominal type equality.
14:00:44 <alexj> Heffalump: you can always use the same module maps.
14:01:06 <alexj> but with searchpath, you can also add a modulemap that takes precedence that is specific for your project.
14:01:22 <sorear> alexj: so, how is sp better?  From what I've seen so far, it sounds like it will fail just as hard (ghc: module Data.Foo found in multiple directories)
14:02:06 <alexj> I think GHC just grabs the first matching module in the set of -i directories passed.
14:02:44 <sorear> well, they must have changed the version number for a reason; won't some of your code break?
14:02:49 <alexj> each module map get converted into a directory.  you control the order of module maps and hence implicit predence on the command line.
14:03:38 <alexj> sorear: yes.  the underlying problem is real.  my point is that it is real with cabal or searchpath.  but searchpath is otherwise much more convenient to use.
14:04:02 <shapr> cabal-install could have the same convenience though.
14:04:12 <nominolo> yes, we're working on that
14:04:21 <Heffalump> I would like to know how to use fps not from base.
14:04:34 <nominolo> if packages require cabal-1.2 they're just grab it from hackage
14:04:35 <dons> Heffalump: you need a ghc head version of base
14:04:36 <Heffalump> short of -i'ing the source
14:04:42 <dons> then grab bytestring from d.h.o
14:04:44 <Heffalump> oh, has it been removed again?
14:04:46 <nominolo> otherwise, an older version is used
14:04:50 <dons> it has been, yep.
14:04:56 <dons> so its only in base for the 6.6 series
14:04:58 <Heffalump> ok, so the answer is "wait for 6.8"?
14:05:04 <dons> array isn't even in base now
14:05:09 <dons> yeah, or grab a snapshot
14:05:22 <Heffalump> I plan to, but Igloo recommended against the current one :-)
14:06:07 <dino-> Call it the self-containment factor.
14:07:11 <sorear> alexj: how does sp cope with separate compilation?  happs takes what feels like 15 minutes to build; if I compile twenty small HAppS programs will I have to wait five hours?
14:08:51 <dons> they're just linking against the lib though
14:08:58 <dons> hpaste compiles pretty fast
14:09:21 <alexj> sorear: you can always share the same .haskell-cache if you want.   .haskell-cache path is a command line option.
14:10:42 <alexj> thinking about it further, if package Foo 1.1 has a problem, I want to use Foo 1.2 and if package Goo can't work with Foo1.2 I should get a compiler error.  I don't want versioning to cause Goo to silently use a known bad version of package Foo.
14:11:57 <alexj> searchpath gives an error message.  automated cabal will silently do the wrong thing, I think.
14:13:04 <shapr> What if the cabal file has Foo >= 1.2 ?
14:16:32 <alexj> shapr: Fundamentally, having multiple versions of the same package in the same program is a recipe for trouble.  The issue comes up only when there are actual conflicts.  By default searchpath is using the latest version of packages because it is pointing at some darcs repo.
14:17:34 <shapr> alexj: Yeah, using multiple versions of something at the same time will cause problems.
14:17:40 <sjanssen> interestingly, there are dependency situations that Cabal can compile, but searchpath can't
14:18:00 <shapr> really?
14:19:22 <dons> Igloo: is there something other than EXTRA_CC/HC_OPTS for propagating -I/usr/local/include through the build system?
14:19:30 <sjanssen> yes, consider Foo depends on Bar and Baz, Bar depends on Ouch==1.0, Baz depends on Ouch==2.0
14:19:45 <dons> i'm getting failures building cbits in base with ghc-inplace, not picking up HC or CC opts
14:20:21 <dino-> To be fair to both these pieces of software, these are historically crazy nuts to crack in general in our biz.
14:20:47 <sjanssen> I wonder if there are packages that sp can build that Cabal can't
14:21:43 <alexj> sjanssen: I don't want that to build.  I want only one version of a package/module in my program.  Having two versions of Ouch is an error IMHO.
14:22:10 <Heffalump> but Bar and Baz's dependencies should be opaque to users
14:22:26 <Heffalump> otherwise Baz is inhibited from upgrading until Bar does
14:22:41 <sjanssen> alexj: even if the dependency on Ouch isn't exposed in the API of Foo?
14:24:32 <alexj> If cabal made sure that I don't end up with two different versions of Data.Ouch.Xml then I guess that would be ok.  But that is a bad smell. Baz can upgrade and your package can use the current version of Baz until Bar upgrades as well.
14:25:49 <alexj> If Bar is no longer maintained then again you probably don't want to be using that code.
14:26:30 <Heffalump> well, in practice these things sometimes happen
14:26:39 <Heffalump> maintainers are slow, or you need bleeding edge features, etc
14:27:06 <fax> Does anyone know a simple canonical example of a haskell program using multiple files?
14:27:25 <fax> (I want to look at one that's done right so I know what to do)
14:27:48 <alexj> heffalump: you can always create your own repo of Bar that does the right thing.
14:27:58 <ddarius> fax: xmonad?
14:27:59 <sjanssen> fax: xmonad?
14:28:06 <fax> alright, thanks :D
14:28:30 <dino-> I'm still thinking I'd like to see these things work together. I rely on Cabal to do the configure, build, test, install, clean stuff. But would be cool to be able to mix in this SP behavior if desired.
14:28:48 <alexj> heffalump: Does cabal actually enforce that you don't end up with functions that return two different versions of Data.Ouch.Xml in your code?
14:28:57 <sjanssen> alexj: no, it doesn't
14:29:31 <sjanssen> that would actually be a nice feature
14:29:39 <dino-> It seems like we can do dependency gymnastics and break just about any system there is.
14:30:00 <dino-> Coming up with situations that are possibly ill-advised.
14:31:04 <alexj> dino: my general belief is that if you are in a situation where you depend on two different versions of Ouch, your code is probably unreliable and not ready fo release either.
14:31:28 <Heffalump> but if Ouch is just a string library, that doesn't really follow
14:31:33 <sjanssen> alexj: when that happens, you're in one of two situations: 1) the packages are fundamentally compatible, or 2) you need to recompile a package against new dependencies
14:31:43 <sjanssen> 1) is unavoidable in any packaging system
14:32:03 <sjanssen> 2) sucks
14:32:21 <sjanssen> s/fundamentally compatible/fundamentally incompatible
14:32:55 <Heffalump> alexj: and even if you don't want to release it like that, you can't work with it either
14:32:59 <alexj> sjanssen: if you have two fundamentally incompatible packages, perhaps they should have different names rather than different version numbers.
14:33:08 <sjanssen> in fact, is 2 only a byproduct of GHC's compilation model?
14:34:02 <pgavin> does anyone know if any progress has been made on PIC in GHC?
14:34:25 <sjanssen> alexj: incrementing the version number is the popular thing to do -- don't HAppS 0.8 and 0.9 have fundamentally different APIs?
14:34:28 <alexj> sjanssen: I don't want "import Data.Ouch.Xml"  to mean different things in different places.  Similarly, I don't want a domain name system where http://haskell.org goes to a different location depending on the linking context.
14:34:29 <lambdabot> Title: Haskell - HaskellWiki
14:35:19 <alexj> sjanssen: yes, but I am not worried about people trying to use both in the same program.
14:36:02 <dino-> Time for me to brave the rainy weather and go home. See you guys later.
14:36:24 <fax> bye
14:36:27 <stepcut> is there a function in the ghc libraries like mkstemp, but for directories ?
14:38:19 <dons> Igloo: we have GHC_CC_OPTS now as well?
14:40:26 <Igloo> dons: I think it's a bug that libraries/*/GNUmakefile doesn't use EXTRA_CC_OPTS
14:40:36 <vincenz> dons: is your unsw email still active?
14:41:14 <dons> yeah, but the new one is preferred
14:41:29 <vincenz> dons: ah, because on the HAC II page, it showed your unsw one
14:41:41 <dons> my build error with -I/usr/local/include isn't propagated by the usual means
14:41:54 <dons> since we now have this GHC_* thing
14:42:08 * vincenz hopes you got his registration email
14:42:19 <dons> vincenz: yeah, you're all registered
14:42:24 <dons> you've found a hotel?
14:42:36 <vincenz> dons: not yet, but I'm most likely getting funding for the trip to go attend ICFP
14:42:38 <Igloo> dons: Right, there should be an equivalent of "GHC_OPTS += $(EXTRA_HC_OPTS)" for GHC_CC_OPTS
14:42:39 <vincenz> so they'll deal with that
14:48:14 <dons> Igloo: looks like similar issues for hsc2hs ?
14:50:22 <fax> :t (.|.)
14:50:24 <lambdabot> forall a. (Bits a) => a -> a -> a
14:53:02 <dons> Igloo: also, is cabal now building libs with -O (or -O2 on) ?
14:53:11 <dons> we don't want to be distributing unoptimised libs
14:53:50 <Igloo> dons: It is, yup
14:54:51 <dons> how do I get an -I/path through to the hsc2hs used in the hpc lib?
14:55:29 <dons> EXTRA_HSC2HS_OPTS doesn't cut it
15:04:02 <dons> dcoutts: any thoughts on how hard it would be to roll a gtk2hs app for editing values in xmonad's Config.hs ?
15:04:20 <dons> basically, the tool would constrain inputs to each config file based on the type
15:04:29 <dons> and you'd just enter values into the gui, which writes your Config.hs
15:04:45 <sorear> @go fetchmailconf
15:04:47 <lambdabot> http://linux.die.net/man/1/fetchmailconf
15:04:47 <lambdabot> Title: fetchmailconf(1): fetch mail from POP, IMAP ... - Linux man page
15:04:53 <sorear> ^^^ model
15:05:49 <dons> nice reference, thanks
15:13:10 <shachaf> dons: That could be a nice general tool (if it was general enough a tool).
15:13:45 <reilly> has anybody every done a haskell subset  to c++ template language translator?
15:14:12 <reilly> it's high on the list of very wrong but amusing projects
15:15:29 <monochrom> it may be do-able with "boost".
15:15:51 <reilly> oh, i'm sure it's doable
15:16:03 <monochrom> sorry, I haven't done it. :)
15:16:31 <ddarius> reilly: That's one of the first programs I wrote in Haskell.
15:16:35 <reilly> i'm having to hack boost metaprogramming templates and i'd really rather do it in haskell first
15:17:20 <olsner> (did lisp though)
15:17:34 <reilly> i actually can't imagine trying to do template programming in c++ without already knowing Haskell or ML
15:18:08 <reilly> ddarius: seriously?  how reasonable a subset did you get?
15:18:39 <reilly> my intent is to sidestep much of the template debuggery in C++
15:19:30 <heisenbug> anyway, C++ has associated type synonyms and type-level functions :-)
15:19:37 <reilly> yeah, i know
15:20:08 <ddarius> reilly: I believe it would translate simple (recursive) functions using pattern matching on integers and "calls" to other "functions" and primitives.
15:20:27 <ddarius> I could write factorial in it exactly as you would write it in Haskell.
15:20:40 <reilly> that's pretty cool
15:20:40 * heisenbug once implemented the cata/anamorphism stuff that is in the "bananas" paper in C++
15:20:46 <ddarius> I think it could do higher-order functions too, I don't remember if I did make a map or some such.
15:20:56 <oerjan> > product [1..10000]
15:20:58 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
15:21:24 <mr_tenor> i really wish you could specify constraints on template type parameters in C++ :(
15:21:34 <idnar> :t product
15:21:36 <lambdabot> forall a. (Num a) => [a] -> a
15:21:59 <dons> Igloo: yeah, EXTRA_HC_OPTS seems to be a bit inconsistently applied, so i've got gcc, hsc, ghc and ghc-inplace failing to set flags to find gmp in /usr/local
15:22:03 <dons> without lots of file editing
15:22:17 <dons> eg.
15:22:17 <dons> compiler/Makefile
15:22:27 <dons> has
15:22:28 <dons> $(HC) -cpp -optc-DGHC_PATH=$(DQ)$(GHC_PATH)$(DQ) -optc-DTOP_ABS=$(DQ)$(FPTOOLS_TOP_ABS)$(DQ) $(INPLACE_EXTRA_FLAGS) $< -o $@
15:24:36 <hpaste>  fax pasted "xay parsing" at http://hpaste.org/2755
15:24:53 <fax> mm I wanted to just ask is this really bad?
15:25:28 <fax> I'm not sure how else to do this though
15:26:09 <ddarius> do char 'x'; as <- many (char 'a'); char 'y'; return (length as)
15:26:47 <heisenbug> mr_tenor: C++0x will have those constraints
15:27:12 <oerjan> liftM length . between (char 'x') (char 'y') . many . char $ 'a'
15:27:46 <mauke> char 'x' >> liftM length (many $ char 'a') << char 'y'
15:28:04 <oerjan> huh?
15:28:13 <mr_tenor> heisenbug: seriously? Great! It's just so ambiguous at the moment.. like "Guess what sort of class goes here... maybe you won't get a compileerror if you read my mind" ;)
15:28:15 <oerjan> :t <<
15:28:17 <lambdabot> parse error on input `<<'
15:28:19 <oerjan> :t (<<)
15:28:21 <mauke> oerjan: doesn't exist
15:28:22 <lambdabot> Not in scope: `<<'
15:28:29 <oerjan> oh
15:28:33 <mauke> a << b = do { x <- a; b; return x }
15:28:42 <oerjan> :t (*<)
15:28:44 <lambdabot> Not in scope: `*<'
15:28:47 <oerjan> :t (<*)
15:28:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
15:28:57 <idnar> :t flip (>>)
15:28:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
15:29:04 <heisenbug> mr_tenor: google for C++ concepts
15:29:31 <fax> Which Module do you need for all this?
15:29:39 <ddarius> idnar: That would execute in the wrong order.
15:29:44 <idnar> oh true
15:29:53 <oerjan> Text.ParserCombinators.Parsec
15:30:01 <oerjan> and Control.Monad
15:30:14 <fax> ohh
15:30:18 <fax> ok well what do you think of this,
15:30:31 <fax> I parse text into tokens with Parsec.. Then use Parsec again to parse tokens into an AST
15:30:41 <mr_tenor> heisenbug: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1886.pdf ? sounds interesting... thanks :)
15:30:48 <mauke> @let a << b = do { x <- a; b; return x }
15:30:49 <ddarius> fax: Why?
15:30:52 <lambdabot> Defined.
15:31:05 <idnar> :t (<<)
15:31:07 <lambdabot> Not in scope: `<<'
15:31:11 <idnar> ag
15:31:14 <idnar> :t (>>)
15:31:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:31:34 <ddarius> idnar: Only @run and @let see those bindings.
15:31:37 <heisenbug> mr_tenor: C++ is sailing in the keelwater of Haskell ;-)
15:31:52 <idnar> ddarius: I meant to do >> not <<
15:32:01 <idnar> but I guess my fingers didn't want to cooperate ;)
15:32:04 <oerjan> ddarius: actually there was one more, i don't remember which
15:32:07 <mauke> > [1,2] << [3,4,5]
15:32:09 <lambdabot>  [1,1,1,2,2,2]
15:32:22 <fax> what?
15:32:27 <idnar> heh
15:32:37 <fax> I don't understand that at all :p
15:32:43 <shachaf> fax: The [] monad.
15:32:46 <idnar> > [3,4,5] >> [1,2]
15:32:48 <lambdabot>  [1,2,1,2,1,2]
15:32:55 <idnar> not a very useful thing to do, mind you
15:33:03 <fax> > [3,5] >> [1,2]
15:33:04 <lambdabot>  [1,2,1,2]
15:33:13 <oerjan> fax: it's equivalent to [x| x <- [1,2], _ <- [3,4,5]]
15:33:16 <mauke> > [(),(),()] >> "butter"
15:33:17 <lambdabot>  "butterbutterbutter"
15:33:23 <shachaf> > [x | x <- [1,2], _ <- [3,4,5]] -- equivalent.
15:33:24 <fax> > "abc" >> [1,2,3]
15:33:25 <lambdabot>  [1,1,1,2,2,2]
15:33:26 <lambdabot>  [1,2,3,1,2,3,1,2,3]
15:33:30 <fax> ok
15:33:45 <mauke> for _ in "abc": return [1,2,3]
15:33:59 <oerjan> @help run
15:33:59 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
15:34:02 <oerjan> @list run
15:34:03 <lambdabot> eval provides: run let undefine
15:34:03 <shachaf> fax: For [], return is (:[]) and (>>=) is (flip concatMap).
15:42:04 <fax> If you use data Tok = TokX | TokA | TokY instead of strings..
15:42:16 <fax> can you still use parsec?
15:43:05 <monochrom> Yes, with a pedantic correction.
15:44:18 <fax> ahh ok, great
15:44:28 <fax> using tokenPrim
15:45:08 <CosmicRay> does anyone know how to raise the stack size in hugs?
15:45:12 <dons> Igloo: final link fails on amd64/openbsd with:
15:45:13 <dons> /home/dons/src/ghc-6.7.20070911/libraries/unix/dist/build/libHSunix-2.0.a(SharedMem.o)(.text+0x26d): In function `unixzm2zi0_SystemziPosixziSharedMem_zdwa_info':
15:45:13 <CosmicRay> foldl keeps crashing it under quickcheck
15:45:16 <dons> : undefined reference to `shm_unlink'
15:45:40 <CosmicRay> with a control stack overflow message
15:47:15 <sorear> uhm...
15:47:18 <Igloo> dons: Do you have a C shm_unlink function?
15:47:26 <sorear> Hugs> foldl (+) 0 [1..100000]
15:47:26 <sorear> Segmentation fault (core dumped)
15:47:26 <sorear> stefan@stefans:/usr/src/bsdgames-nonfree-2.17/rogue$
15:47:30 <dons> Igloo: i suspect not, checking..
15:47:51 <Igloo> sorear: Stack overflows in hugs can cause C stack overflows, and thus segfaults
15:48:05 <Igloo> dons: Thanks for all the feedback, BTW
15:48:20 <oerjan> CosmicRay: use foldl' not foldl for starters :)
15:48:35 <dons> Igloo: i'm getting some patches together. just letting you know where things go wrong, so we can double check them before the release
15:48:38 <Igloo> dons: BTW, you don't also get an error for shm_open, right?
15:48:47 <Igloo> dons: Excellent, thanks!
15:49:14 <dons> In function `s1ik_info':
15:49:14 <dons> : undefined reference to `shm_open'
15:49:17 <dons> also shm_open
15:49:28 <Igloo> Ah, OK, if you don't have either then that makes much more sense
15:49:29 <dons> $ man -k shm
15:49:30 <dons> shmat, shmdt (2) - map/unmap shared memory
15:49:30 <dons> shmctl (2) - shared memory control operations
15:49:30 <dons> shmget (2) - get shared memory area identifier
15:49:40 <dons> that's it
15:50:31 <Igloo> OK, so in the short term we'll probably just have to ifdef out all the code when it isn't supported. I got sidetracked from sorting out the unix package, unfortunately
15:50:43 <dons> yep
15:52:54 <DRMacIver> Hm. So I need some sort of immutable tree structure in which the leaves are changed often and closer to the root is changed rarely. I'm thinking of storing this in an inverted manner where children reference parents rather than the other way around and only building the normal tree structure lazily on need. Does this sound sane, and is there any particular sort of structure I should look at?
15:53:00 <DRMacIver> Hm.
15:53:05 <DRMacIver> Actually this is basically a tree zipper, isn't it?
15:53:16 <dons> well, hmm. maybe a finger tree?
15:53:28 <DRMacIver> No, the tree has a specific and important structure.
15:53:41 <DRMacIver> (It's a quadtree)
15:53:44 <oerjan> yeah, a zipper
15:54:11 <dons> it sounds zipperish, but with multiple cursors?
15:55:41 <DRMacIver> Basically it's a tree which represents a spatial region, with each node representing a square of space. The leaves are just sets of points, and earlier branches are regions subdivided into four quadrants.
15:56:13 <DRMacIver> I need to be able to move points around and split/merge nodes without having to rebuild large chunks of the structure.
15:56:20 <dolio> Boy, why would anyone explain local variables in terms of function definition and application, when they could, much more simply, explain it in terms of the low-level implementation details on a modern PC? :)
15:56:37 <dons> Igloo: yeah, looks like that whole System.Posix.SharedMem needs to be commented out
15:56:41 <oerjan> the question is, do you change many leaves simultaneously?
15:56:49 <DRMacIver> Yes
15:57:00 <kscaldef> Hi... I'm running into a problem with ghc in the link phase, missing symbols like "_HTTPzm2006zi7zi7_NetworkziHTTP_GET_closure".   This code runs fine in ghci, so I'm not sure why the link fails or what I might need to do to fix it.
15:57:03 <DRMacIver> (It's for a particle simulation)
15:57:14 <sorear> --make
15:57:44 <sorear> kscaldef: ghci defaults to chasing dependancies, ghc oppositely.  you can tell ghc to chase deps with --make
15:57:58 <kscaldef> I see
15:58:05 <kscaldef> okay, that seems to work
15:58:10 <kscaldef> thanks!
15:58:32 <sorear> Igloo: any particular reason we don't make this the default in the non--c case?  a lot of people seem to trip over it...
15:58:37 <DRMacIver> I'm vaguely tempted to do this as a mutable structure.
15:59:00 <oerjan> well multiple changes in zippers is oleg stuff
15:59:03 <oerjan> iiuc
15:59:36 <oerjan> it's all very simple when you have only one cursor
16:00:03 <Igloo> sorear: Not sure; maybe to make GHC H98-only by default
16:00:07 <CosmicRay> sorear: it is not just --make, right?  He'll also need the -package or -l for that library
16:00:20 <CosmicRay> -package likely
16:00:22 <DRMacIver> oerjan: Well there's no reason in principle the zipper couldn't just run over all the points in order.
16:00:22 <dolio> The thing is, with multiple cursors, you have to decide how you want the cursors to interact with each other. And some modes of interaction are more difficult to do than others.
16:00:42 <DRMacIver> So I mean I guess it depends what you mean by 'simultaneously'
16:00:42 <Igloo> CosmicRay: No, --make will link against the right package automagically
16:00:44 <CosmicRay> but it is odd that ghc will happily import the module at compile time but not find it at link time
16:00:50 <sorear> Igloo: doesn't quite make sense, because h98 requires --make or -package haskell98 for nontrivial programs :)
16:01:01 <Igloo> sorear: Too late for proposing changing it for 6.8, anyway
16:01:11 <Igloo> sorear: No, it links to haskell98 by default
16:01:12 <sorear> agreed - just asking.
16:01:21 <CosmicRay> Igloo: even if one of the packages requires a C library?
16:01:36 <sorear> well, Data.Array.Unboxed is hardly 'h98 only'
16:01:49 <CosmicRay> heh
16:02:01 <Igloo> CosmicRay: If a package requires it, yes, as it'll use the link flags for the library in the package database
16:02:32 <Igloo> CosmicRay: If it's only a C library, without an accompanying Haskell package, then no, there's no way it could know what to link against
16:02:55 <oerjan> DRMacIver: but if you have only one cursor, updating several places means moving the cursor, which reconstructs everything on the path between the points
16:03:15 <jatqceer> can someone point me to an example of using runSTUArray?
16:03:24 <DRMacIver> oerjan: Ah, hmm. Yes.
16:03:45 <Igloo> sorear: It's actually a pain, because the only reason we actually need to build a handful of bootlibs is so that the haskell98 stuff (that people arguably shouldn't be using) works
16:03:48 <oerjan> and if you often go through the root, this is just as expensive as not using a zipper, i think
16:04:22 <CosmicRay> dons: hey, while you're here, do you have any idea why ByteStream's foldl would cause hugs to crash with a stack overflow under QuickCheck, but Data.List.foldl is fine?  (and both are find under GHC)
16:05:16 <oerjan> because at the point you pass the root you _are_ reconstructing the whole tree
16:05:47 <DRMacIver> Yeah
16:06:39 <dons> CosmicRay: ByteStream?
16:06:53 <dons> you mean Data.Stream.foldl ?
16:07:49 <CosmicRay> no, Data.ByteStream.foldl
16:07:57 <DRMacIver> Hm. I suppose one way to do this would be to keep the tree as a normal order immutable structure and only have the attached points reverse the index.
16:08:02 * CosmicRay didn't know about Data.Stream
16:08:05 <dons> CosmicRay: ByteString ?
16:08:12 <DRMacIver> As the expected use case is to really be moving things about on the leaves more than it is adding or removing leaves.
16:08:28 <dons> :t Data.ByteString.foldl -- this one?
16:08:30 <CosmicRay> oh.
16:08:32 <Cale> jatqceer: You just give it an ST computation which builds an STUArray, and it gives you back a UArray by running the computation
16:08:33 <CosmicRay> braino
16:08:36 <CosmicRay> yes, of course
16:08:37 <lambdabot> forall a. (a -> Word8 -> a) -> a -> Data.ByteString.Base.ByteString -> a
16:08:39 <CosmicRay> sigh
16:08:50 <dons> there's a stream fusion list library , called Data.Stream
16:08:56 <dons> which is why I was confused
16:09:03 <CosmicRay> I was even looking at the Data.ByteString page in firefox, and still typed ByteStream
16:09:13 <CosmicRay> anyhow, that thing you wrote ;-)
16:09:47 <CosmicRay> hugs oddly also crashes when running foldl over [Char] but not over [Int], so it may not necessarily be a ByteString problem
16:11:10 <oerjan> DRMacIver: i guess this depends a lot on how "dense" the particles are in the tree.  if there are only relatively few giving each a cursor might be worthwhile.  but this is just my vague intuition, since i haven't actually looked at multiple cursor implementations.
16:11:32 <jatqceer> > runSTArray (newListArray (1, 10) [1..] :: ST s (STArray s Int Int))
16:11:33 <lambdabot>   Not in scope: type constructor or class `STArray'
16:11:34 * edwinb feels his ears burning
16:11:44 <edwinb> whitespace is completely readable! If you add comments...
16:11:54 <fax> haha
16:12:23 <DRMacIver> oerjan: There's a fixed maximum number of particles per leaf with the leaves bifurcating into four when it gets too dense.
16:12:46 <DRMacIver> oerjan: So they're expected to be deep in the tree rather than dense per leaf.
16:13:00 <jatqceer> I found out it claims type error if I put a `$' after the runSTArray, how come?
16:13:35 <sorear> jatqceer: ghc's type system has problems
16:13:57 <jatqceer> sorear: I like this excuse
16:14:03 <sorear> jatqceer: impredicativity only works with a ton of type signatures
16:14:31 <mrd> the simple answer is, just stick to parens with runST*
16:14:36 <jatqceer> I was trying to figure what exactly was wrong with my code and finally found out it's just a problem of `$'
16:14:57 <sorear> jatqceer: (($) :: ((forall s. ST s a) -> a) -> (forall s. ST s a) -> a)) runST (return 2)  should work
16:14:58 <oerjan> DRMacIver: but _each_ leaf is updated each iteration or so? in that case the overhead from rebuilding the tree would be negligible, wouldn't it?
16:15:19 * sorear plugs MLF
16:15:33 <jatqceer> sorear: impressive
16:16:19 <mrd> actually, Simon put in a semi-hack to make $ work with rank-2 types at least, in development?
16:16:31 <mrd> left-to-right impredicative instantiation
16:16:50 <sorear> mrd: i wouldn't call it a SEMI hack... :)  also, it was so horrible it got reverted
16:17:18 <mrd> blah
16:17:38 <DRMacIver> oerjan: Well, each point is updated (at least to first order). But I guess you're right that the size of the tree is probably only contributing an extra log(n) factor to that.
16:18:52 <oerjan> sorear: i had this strange idea the other day - isn't the problem somehow the order the type inference goes through terms?  and this is essentially unification, and i recall Mercury uses a mode system to schedule the data flow for this...
16:19:53 <oerjan> DRMacIver: that's what i was thinking
16:20:13 <sorear> oerjan: I don't follow.
16:20:17 <oerjan> especially if the computation at each leaf is a bit expensive
16:20:29 <sorear> @go Adding Qualified Types to MLF
16:20:37 <lambdabot> http://portal.acm.org/ft_gateway.cfm?id=1086385&type=pdf
16:21:18 <DRMacIver> oerjan: Although "only an extra factor of log(n)" is still noticable for the target sample size.
16:21:26 <oerjan> sorear: it was just a weird idea - has anyone thought of using something similar to Mercury's mode system to schedule the order in which types are inferenced...
16:21:46 <sorear> oerjan: no idea :(
16:22:40 <oerjan> is there a free version of that paper?
16:23:02 <sorear> yes
16:23:11 <sorear> @go daan leijen qualified MLF
16:23:14 <lambdabot> http://portal.acm.org/citation.cfm?id=1086385
16:23:14 <lambdabot> Title: Qualified types for MLF
16:23:16 <sorear> @go daan leijen qualified MLF site:edu
16:23:19 <lambdabot> http://lists.seas.upenn.edu/pipermail/types-list/2005/000785.html
16:23:19 <lambdabot> Title: [TYPES] ICFP 2005 - Accepted papers
16:23:44 <sorear> @go qualified typed for mlf
16:23:46 <lambdabot> http://research.microsoft.com/users/daan/pubs.html
16:23:47 <lambdabot> Title: Publications
16:23:51 <sorear> there
16:24:48 <oerjan> thanks
16:24:58 <oerjan> sorear++
16:26:10 <sorear> Actually, you should probably read the original MLF paper first.  But that one is significant because for a long time the story was "MLF?  Sure, it's cute in theory, but since it cannot be extended with qualified types it's useless in our context."
16:27:00 <oerjan> oh
16:31:39 <oerjan> this one i take? http://citeseer.ist.psu.edu/lebotlan03raising.html
16:31:40 <lambdabot> Title: Raising ML to the Power of System F - Le Botlan, emy (ResearchIndex)
16:31:50 <sorear> yes
16:32:51 <oerjan> citeseer++
16:33:33 <heisenbug> there was a similar paper in JFP Jan/07
16:34:01 <heisenbug> type inference of rank-n (with local declarations)
16:40:18 <fax> hey you know deriving Eq
16:40:33 <fax> where is the code for that?
16:40:51 <shachaf> GHC sources?
16:41:17 <augustss> It's inside the compilers
16:41:21 <fax> ok
16:41:40 <fax> so you can't implement deriving if it wasn't already around?
16:41:50 <fax> without editing the compiler that is
16:41:54 <shachaf> fax: No.
16:41:59 <fax> hmm ok
16:42:06 <shachaf> fax: For example, they had to edit the sources to add deriving Data/Typeable.
16:42:19 <twanvl> Data.Derive can also derive Eq
16:42:20 <ari> There's libraries like Data.Derive around, though, that can do the job using different language features
16:42:23 <Igloo> You might be interested in the Scrap Your Boilerplate papers if you want to do that sort of thing
16:42:28 <Igloo> @where SYB
16:42:29 <lambdabot> http://www.cs.vu.nl/boilerplate
16:42:29 <augustss> There are preprocessors like Derive that can do it
16:43:02 <sorear> Derive doesn't do as good a job though, since it can't infer contexts
16:43:48 <fax> I basically wanna make some new Eq type thing (for a single data type definition) where ThisThing 4 == ThisThing 3
16:44:12 <ari> As in an instance of Eq?
16:44:29 <ari> instance Eq Thing where a == b = True
16:44:57 <fax> actually no, not an instance of Eq
16:45:03 <idnar> ari: I think he means a new type class that isn't Eqq
16:45:05 <idnar> *Eq
16:45:17 <sorear> fax: just define your own instance Eq
16:45:40 <sorear> fax: you won't break anything as long as (==) is still reflexive, transitive, and symmetric
16:55:23 <hpaste>  fax pasted "tokens and ~~" at http://hpaste.org/2756
16:55:48 <fax> so this works.. but is it the right way to do this?
16:56:45 <oerjan> fax: do you have a use for the ordinary Eq on this type?
16:56:52 <fax> yes
16:57:35 <fax> well not yet
16:57:39 <fax> but I think I will at some point
16:58:03 <oerjan> iiuc you are simply comparing the constructor names everywhere?
16:58:09 <fax> yeah
16:58:25 <fax> ignoring any parameters they take, so (IntToken 3 ~~ IntToken 4 = True)
16:58:29 <oerjan> :t toConstr
16:58:31 <lambdabot> Not in scope: `toConstr'
16:59:17 <kpreid> :t G.toConstr
16:59:18 <lambdabot> Couldn't find qualified module.
16:59:25 <kpreid> :t Data.Generics.toConstr
16:59:27 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> Data.Generics.Basics.Constr
16:59:40 <kpreid> > Data.Generics.toConstr (Left 1 :: Either Int Int)
16:59:42 <lambdabot>  Left
17:00:07 <kpreid> so 'deriving Data' gets you that
17:00:17 <ari> @instances-importing Data.Generics Eq
17:00:18 <lambdabot> (), All, Any, Bool, Char, Constr, ConstrRep, DataRep, Double, Either a b, Fixity, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
17:00:26 <fax> > (Data.Generics.toConstr (Just 5)) == (Data.Generics.toConstr (Just 6))
17:00:27 <lambdabot>  True
17:00:32 <fax> yay :D
17:00:35 <fax> Thanks very much
17:00:49 <ddarius> (==) `on` Data.Generics.toConstr
17:01:03 <hpaste>  twanvl annotated "tokens and ~~" with "You only need different behaviour for the constructors with arity>0" at http://hpaste.org/2756#a1
17:01:03 <fax> > Just 6 ((==) `on` Data.Generics.toConstr) Just 7
17:01:04 <lambdabot>  Couldn't match expected type `(t1 -> t1 -> Bool)
17:01:40 <fax> twanvl: ahh true.. thanks
17:01:43 <ari> > ((==) `on` Data.Generics.toConstr) (Just 6) (Just 7)
17:01:44 <oerjan> > ((==) `on` Data.Generics.toConstr) (Just 6) (Just 7)
17:01:45 <lambdabot>  True
17:01:46 <lambdabot>  True
17:01:48 <kpreid> not infix
17:01:50 <kpreid> ((==) `on` Data.Generics.toConstr) (Just 6) (Just 7)
17:01:52 <fax> oops
17:01:53 <kpreid> > ((==) `on` Data.Generics.toConstr) (Just 6) (Just 7)
17:01:54 <lambdabot>  True
17:02:02 <ddarius> @let (-:) = flip ($)
17:02:05 <lambdabot> Defined.
17:02:11 <ddarius> oops
17:02:17 <ddarius> @let (-|) = flip ($)
17:02:20 <lambdabot> Defined.
17:02:24 <ddarius> @let (|-) = id
17:02:27 <lambdabot> Defined.
17:02:36 <glen_quagmire> > |- 1
17:02:37 <lambdabot>   parse error on input `|-'
17:02:49 <glen_quagmire> :t |-
17:02:51 <lambdabot> parse error on input `|-'
17:02:51 <ddarius> > Just 3 -| (==) `on` Data.Generics.toConstr |- Just 4
17:02:52 <lambdabot> Terminated
17:03:04 <ddarius> God knows how that parsed.
17:03:13 <ddarius> > Just 3 -| ((==) `on` Data.Generics.toConstr) |- Just 4
17:03:14 <lambdabot> Terminated
17:03:34 <ddarius> > 3
17:03:35 <lambdabot>  3
17:03:47 <ari> > (Just 3) -| ((==) `on` Data.Generics.toConstr) |- (Just 4)
17:03:48 <fax> @hoogle on
17:03:48 <lambdabot> Terminated
17:03:48 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
17:03:48 <lambdabot> System.Console.Readline.onNewLine :: IO ()
17:03:48 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
17:04:02 <fax> @hoogle (on)
17:04:03 <lambdabot> Did you mean: On
17:04:03 <lambdabot> Prelude.undefined :: a
17:04:03 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:04:07 <twanvl> ?type on
17:04:09 <lambdabot> Not in scope: `on'
17:04:14 <oerjan> > 3 -| (+) |- 4
17:04:15 <lambdabot> Terminated
17:04:21 <ddarius> > id |- 3
17:04:22 <lambdabot>  3
17:04:29 <ddarius> > 3 -| id
17:04:30 <lambdabot> Terminated
17:04:35 <ari> :t \ f p x y -> f (p x) (p y)
17:04:37 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
17:04:57 <fax> :t (on)
17:04:59 <lambdabot> Not in scope: `on'
17:05:00 <twanvl> on :: (b -> b -> c) -> (a -> b) -> (a -> a -> c)   -- I think
17:05:09 <ddarius> @pl \f p x y -> f (p x) (p y)
17:05:09 <lambdabot> join . ((flip . ((.) .)) .) . (.)
17:05:14 <oerjan> > flip ($) 3 id
17:05:16 <lambdabot>  3
17:05:43 <ddarius> > 3 -: id
17:05:44 <lambdabot>  3
17:05:46 <oerjan> :t let (-|) = flip ($) in 3 -| id
17:05:48 <lambdabot> forall t. (Num t) => t
17:05:54 <ddarius> > Just 3 -: ((==) `on` Data.Generics.toConstr) |- Just 4
17:05:56 <lambdabot>  True
17:06:03 <ddarius> > Just 3 -: (==) `on` Data.Generics.toConstr |- Just 4
17:06:04 <lambdabot>  Couldn't match expected type `Maybe t -> t2'
17:06:22 <ddarius> There might be another definition of -| (?)
17:06:31 <oerjan> > -|
17:06:32 <lambdabot>   parse error on input `-|'
17:06:36 <oerjan> > (-|)
17:06:37 <lambdabot> Terminated
17:06:49 <JBGood> :t (-|)
17:06:51 <lambdabot> forall a b c. (a -> b) -> Strategy b -> (b -> c) -> a -> c
17:06:53 <oerjan> > \x -> (-|)
17:06:54 <lambdabot> Terminated
17:07:17 <ddarius> When'd that grow out of something?
17:07:18 <JBGood> so it has something to do with strategies...
17:07:21 <oerjan> > (L.-|)
17:07:22 <lambdabot>  Add a type signature
17:07:51 <oerjan> strange that it doesn't complain about ambiguous import?
17:08:11 <oerjan> > [(L.-|),()]
17:08:12 <lambdabot>  Couldn't match expected type `a -> (a -> b) -> b'
17:16:51 <DukeDave> :t (&&&)
17:16:56 <sorear> DukeDave: don't do it
17:16:59 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:17:22 <DukeDave> sorear: Don't ask for the type of (&&&) ?
17:17:56 <sorear> DukeDave: Correct... it has a way of making people collapse in gibbering insanity
17:18:05 <DukeDave> I only did because Hoogle couldn't find it :o
17:18:33 <DukeDave> Lol, I'm intrigued.. Didn't know it was Arrow related, just spotted it used in Dons latest Blog
17:20:26 <ddarius> DukeDave: There is nothing particularly Arrowish about it.
17:20:44 <ari> ... except the Arrow a constraint in the type?
17:23:25 <oerjan> :t (&&&).(id.)
17:23:27 <lambdabot> forall c' b a. (a -> b) -> (a -> c') -> a -> (b, c')
17:23:39 <dons> a beautiful type
17:24:27 <ddarius> :t uncurory ((&&&).(id.))
17:24:29 <lambdabot> Not in scope: `uncurory'
17:24:30 <ddarius> :t uncurry ((&&&).(id.))
17:24:32 <lambdabot> forall c' b a. (a -> b, a -> c') -> a -> (b, c')
17:25:04 <ari> :t (***).(id.)
17:25:06 <lambdabot> forall b' c' b a. (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
17:25:21 <ari> oerjan++
17:25:29 <ari> The types of the arrow stuff actually make sense with that
17:26:39 <dolio> @type ((***) :: (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c')))
17:26:40 <lambdabot>     Couldn't match expected type `b' (a rigid variable)
17:26:41 <lambdabot>            against inferred type `(b, b)'
17:26:54 <dolio> @type ((&&&) :: (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c')))
17:26:56 <lambdabot> forall (~> :: * -> * -> *) b c c'. (Arrow ~>) => ~> b c -> ~> b c' -> ~> b (c, c')
17:27:06 <dolio> Meh.
17:27:39 <oerjan> that's just not _right_ O_O
17:29:11 <fax> what is ~> ?
17:29:27 <ddarius> A name.
17:29:34 <fax> @hoogle a ~> b
17:29:35 <lambdabot> Hoogle Error: Parse Error: Unexpected character '~> b'
17:29:46 <fax> oh ok
17:29:51 <fax> I see
17:29:59 <dolio> It's an infix type variable.
17:30:29 <dolio> Ideally.
17:32:43 <sorear> It's also a Glasgow extension.
17:33:46 <dolio> Yeah, one that's not displaying correctly. Maybe @type doesn't run with the right combination of magic flags.
17:35:05 <dolio> Or maybe not. I guess the pretty printer is just screwy.
17:35:30 <oerjan> well, it did accept it on input
17:42:42 <KatieHuber> everyone freaks out when someone goes @type (&&&)
17:42:57 <KatieHuber> someone needs to edit lambdabot so it explains what the concept behind it is, rather than printing the type ;)
17:43:31 <oerjan> what, the type explains the concept perfectly ;)
17:48:53 <KatieHuber> oh, I understand, from reading the type... so why the freakout?
17:49:15 <sioraiocht> ??
17:49:17 <KatieHuber> > (length &&& head) [1, 2, 3]
17:49:18 <lambdabot>  (3,1)
17:49:42 <oerjan> i would hazard a guess that someone was joking :)
17:49:46 <sioraiocht> lol
17:50:02 <KatieHuber> not the first time it's happened though
17:50:18 <KatieHuber> like, when I did it the first time someone mentioned it, I got the same reaction...
17:50:30 <sioraiocht> > (map (+1) &&& map (*2)) [1..5]
17:50:32 <lambdabot>  ([2,3,4,5,6],[2,4,6,8,10])
17:50:36 <ddarius> KatieHuber: It's a running joke.
17:51:08 <oerjan> @check \n -> if n > 0 then uncurry (==) . (length &&& last) . fromEnum 1 $ n else True
17:51:09 <lambdabot>  Couldn't match expected type `a -> [a1]'
17:51:26 <heisenbug> > (length &&& head)
17:51:28 <lambdabot>  Add a type signature
17:51:44 <oerjan> @check \n -> if n > 0 then uncurry (==) . (length &&& last) . fromEnumTo 1 $ n else True
17:51:46 <lambdabot>   Not in scope: `fromEnumTo'
17:51:58 <KatieHuber> enumFromTo ?
17:52:09 <fax> [1..10]
17:52:12 <oerjan> @check \n -> if n > 0 then uncurry (==) . (length &&& last) . enumFromTo 1 $ n else True
17:52:13 <fax> enumFromTo 1 10
17:52:14 <lambdabot>  OK, passed 500 tests.
17:52:17 <ddarius> [x..y] === enumFromTo x y
17:52:57 <fax> @pointless (\x y->[x..y])
17:52:58 <lambdabot> enumFromTo
17:53:00 <ddarius> :t ==>
17:53:02 <lambdabot> parse error on input `==>'
17:53:12 <ddarius> :t (==>)
17:53:14 <lambdabot> Not in scope: `==>'
17:53:33 <__nasa__> Has anybody here written code using the Apple Remote?
17:53:42 <oerjan> @check (==>)
17:53:43 <lambdabot>  Add a type signature
17:53:59 <oerjan> @check [(==>),()]
17:54:00 <lambdabot>  Couldn't match expected type `Bool -> a -> Property'
17:54:49 <oerjan> :t (Test.QuickCheck.==>)
17:54:51 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
19:05:10 <mm_freak> is it safe to upgrade to GHC 6.8 ?
19:05:59 <sorear> No.
19:06:12 <sorear> The pre-release doesn't even compile.
19:06:25 <sorear> It's supposedly fixed in darcs, but no new RC has been published.
19:06:43 * sorear goes and upgrades to GHC 6.9
19:10:18 <mudge> anyone here go to the san francisco meeting?
19:11:12 <monochrom> 6.9 is vapourware!
19:14:15 <ari> n.k where k `mod` 2 == 1 is vapourware :(
19:14:45 <oerjan> huh?
19:15:00 <monochrom> untrue. 6.7 is no longer vapourware. just betaware. :)
19:15:13 <FMota> beware the betaware...
19:15:28 <mauke> ari: odd k
19:15:34 <FMota> dunno why I said that. Just thought it was cool.
19:15:42 <monochrom> It is. :)
19:15:50 * oerjan tries to stay a bit aware
19:15:52 <FMota> :)
19:15:54 <ari> mauke: Haskell is too big for my brain :(
19:16:01 <monochrom> ware :)
19:16:11 <FMota> that's nice ;)
19:16:29 <FMota> could be a software company
19:16:36 <FMota> or a middleman for beta testing.
19:16:58 <mauke> H4SK3LL- INCREAS YOUR BRAIN SIZE!! ORDER NOW
19:17:44 <FMota> mauke: You have to be very diligent and follow all the steps. After a few months, it should be bigger.
19:17:58 <FMota> er, ari:
19:18:15 <monochrom> we sell monad pills for free
19:18:16 <oerjan> you need the new HaSkull
19:18:39 <oerjan> otherwise your brain won't fit
19:18:54 <FMota> :)
19:18:57 <mudge> does skype run on debian?
19:19:07 <FMota> probably
19:19:07 <mudge> oh, sorry wrong channel
19:19:08 <FMota> well
19:19:26 <FMota> harder on debian. And yes, that is viciously offtopic.
19:19:47 <sioraiocht> mudge: but yes, it does =p
19:19:54 <sioraiocht> http://www.skype.com/intl/en/download/skype/linux/
19:19:56 <lambdabot> Title: Download Skype for Linux
19:20:17 <ricky_clarkson> mauke: 1337-speak is deprecated, u can has lolcat haskellz now.
19:20:17 * sioraiocht can't recall a time offtopicness DIDN'T occur in #haskell
19:20:28 <sioraiocht> @quote degree
19:20:28 <lambdabot> Miod says: [On the vax] How many processors come with a built-in instruction which computes polynomials of degrees up to 31?
19:20:30 <mudge> sioraiocht: sweet, thanks
19:20:43 <sioraiocht> that for example
19:21:27 <FMota> lambdabot / Miod: 1.
19:21:27 <FMota> :o
19:21:44 <FMota> (I should think. Or something is very wrong with the world).
19:21:52 <monochrom> with hindsight, it'd be more thrilling if vax came with a built-in instruction for generic catamorphisms.
19:21:55 <FMota> Er, nvm. Something is very wrong with the world regardless.
19:22:06 <oerjan> @users
19:22:06 <lambdabot> Maximum users seen in #haskell: 407, currently: 364 (89.4%), active: 12 (3.3%)
19:22:20 <FMota> vax should come with built-in haskell-style pattern-matching.
19:22:25 * sioraiocht doesn't understand morphisms
19:22:29 <sorear> there are processors with built-in "interpret forth bytecode" instructions
19:22:40 <FMota> sorear: that is very cool.
19:22:42 <sorear> sioraiocht: CT or vanilla
19:22:43 <allbery_b> I'm not altogether sure the vax didn't
19:22:49 <sioraiocht> sorear: CT
19:23:10 <sorear> sioraiocht: don't.  they are a primitive notion; it's like asking what the elements of a group are
19:23:10 <jatqceer> how do i rename the type `ST s (STUArray s Int Double)' to something like `Vector'?
19:23:16 <sorear> type Vector =
19:23:17 <allbery_b> forth bytecode???
19:23:23 <sorear> type Vector = ST s (STUArray s Int Double)
19:23:24 <allbery_b> real forth doesn't have bytecode
19:23:37 <sioraiocht> sorear: that makes me cry.  I can't help but try and think of them as functions, and I get yelled at every time I do
19:23:50 <oerjan> Error: s does not appear on the left side
19:23:51 <allbery_b> compiled forth code is just a bunch of indirect jumps with the jmp opcode elided
19:24:02 <jatqceer> sorear: that would result in "Not in scope: type variable `s'"
19:24:08 <monochrom> I think of them as functions. No one yells at me. The trick is I do it secretly.
19:24:14 <sorear> jatqceer: type Vector s = maybe?
19:24:25 <sorear> allbery_b: in DTC models, yes
19:24:31 <sorear> allbery_b: I was however misremembering
19:24:41 <dolio> sioraiocht: They're functions (or something like them) a lot, but not always.
19:24:55 <sioraiocht> dolio: they are mappings from one category to another, right?
19:24:55 <dolio> sioraiocht: Like, if you category is just some directed graph.
19:24:57 <sorear> allbery_b: the processor in question only had dtc primops, not a bytecode interp
19:25:14 * sioraiocht is taking Category Theory starting this term
19:25:26 * sioraiocht fears it.
19:25:30 <monochrom> On the other hand, in some cases, not all functions are morphisms.
19:25:32 <dolio> sioraiocht: Then the objects of the category are the nodes, and the morphisms are directed edges.
19:25:35 <jatqceer> sorear: that works.  somehow the ST makes me use an `s' that i never touch it in my code
19:25:44 <sorear> allbery_b: maybe (real) mips is good for strangness?  iirc it has multiply-loop-iteration opcodes that you have to repeat 32 times to get a proper multiply
19:26:03 <sioraiocht> dolio: and can you describe a case where this ISN'T true?
19:26:11 <allbery_b> yeh, but that's RISC taken to its (illogical) conclusion
19:26:17 <dolio> Where what isn't true?
19:26:34 <dolio> Mappings between categories are functors.
19:26:38 <allbery_b> that's one of the reasons RISC kinda died out, with the few useful aspects being absorbed into the mainstream
19:26:40 <oerjan> jatqceer: that s is magical
19:26:54 <oerjan> it makes ST inescapable
19:27:30 <jatqceer> do you think i should actually use IOArray instead?
19:28:13 <sioraiocht> dolio: how...?
19:28:16 <dolio> Unless you're talking about the category of (small) categories, or something, in which case the morphisms are functors, I guess.
19:28:28 <jatqceer> in that case i need to use another black magic `unsafePerformIO'...
19:29:09 <sorear> jatqceer: hold your nose and ignore the s-es
19:29:13 <oerjan> the ST magic is safe, the unsafePerformIO magic obviously isn't...
19:30:02 <dolio> sioraiocht: Maybe you're using the terminology differently than I'm familiar with.
19:30:20 <sioraiocht> dolio: no, I'm juust retarded
19:30:33 <sioraiocht> so a functor is some..transformation...from one cateogry to the other?
19:30:35 <jatqceer> sorear: i just don't like those s's floating around like ghosts
19:30:48 <allbery_b> but ghosts are what they are.  don't worry about them
19:31:12 <allbery_b> they only bite when you try to inappropriately pull something outside of ST
19:31:18 <oerjan> phantom types are your friends :)
19:31:22 <sorear> sioraiocht: a functor is to CT what a homomorphism is to group theory or a continuous function is to topology or a monotonic function is to order theory
19:32:05 <dolio> Yeah. So, you might have a functor F that takes a category C to a category FC, and there's a mapping from each object o in C to an object Fo in FC, or something like that.
19:32:20 <dolio> And for each morphism f in C to a morphism Ff in FC.
19:32:20 <sioraiocht> hrm, i know what  homomorphism is...
19:32:31 <dolio> And it satisfies certain laws.
19:32:38 <sioraiocht> okay, so how does that translate to when I define a functor in haskell?
19:32:48 <sioraiocht> why is a list a functor, and why does that make it mappable?
19:33:27 <monochrom> a list is not a functor. I mean bad wording.
19:33:45 <dolio> [] is a functor that takes objects A in the category of haskell types to objects [A] in the category of haskell list types, or something like that.
19:34:43 <dolio> And it comes with an operation fmap that takes a morphism (a -> b) in the former category to a morphism [a] -> [b] in the latter category.
19:34:43 <sioraiocht> okay...
19:34:45 <oerjan> the latter category is a subcategory of the first
19:34:49 <monochrom> The mapping that maps type X to type [X], function X->Y to [X]->[Y] (and I omit what that function does), that is a functor.
19:35:17 <sioraiocht> shouldn't it be X->Y to [X->Y]?
19:35:38 <oerjan> :t fmap -- no!
19:35:40 <monochrom> No. Seriously no.
19:35:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:35:44 <sioraiocht> :t fmap
19:35:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:35:51 <sioraiocht> ohh, okay
19:35:56 <sioraiocht> I was thinking of pure
19:35:57 <sioraiocht> :t pure
19:35:59 <lambdabot>     Ambiguous occurrence `pure'
19:35:59 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
19:36:11 <sioraiocht> :t Control.Applicative.pure
19:36:14 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
19:36:29 <oerjan> :t Control.Arrow.pure
19:36:32 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
19:37:03 <oerjan> :t (id.).Control.Arrow.pure
19:37:05 <lambdabot> forall b c. (b -> c) -> b -> c
19:37:26 <oerjan> nah
19:38:35 <sioraiocht> okay
19:38:37 <sioraiocht> that makes sense
19:39:59 <sioraiocht> there's an Add, Compare and Branch instruction in Vax
19:40:50 <jatqceer> how do you test code using STArray in ghci?  say, I want to see the result of getBounds acting on a `ST s (STUArray s Int Double)'
19:48:28 <mauke> runST (getBounds teh_array)
19:49:37 <FMota> :o
19:50:34 <FMota> I just created a simple program in Sei (could easily be rewritten in Haskell) in 50 lines, but it took me about 500 lines to do the same in Ada.
19:50:37 <sioraiocht> :t ap
19:50:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:51:11 <FMota> ap also has the nice type of
19:51:50 <FMota> (a -> b -> c) -> (a -> b) -> a -> c
19:52:46 <FMota> > ap (\ a b -> "c") (\ a -> "b") "a"
19:52:49 <lambdabot>  "c"
19:53:08 <jatqceer> mauke: no, that doesn't work
19:53:25 <mauke> oh, right. you can't have a freestanding STArray
19:53:49 <mauke> runST ( do a <- (newArray :: (Int,Int) -> Double -> ST s (STUArray s Int Double)) (2, 4) 123.0; getBounds a )
19:55:12 <ddarius> Yay, CT rumblings.
19:55:55 <DukeDave> Guys, I have a situation where an instance of some class does not provide an implementation function of a function in said class. However no complaint is made when I make a reference to this unimplemented function; is there some switch to force GHC to check?
19:56:01 <DukeDave> If that makes sense :)
19:56:26 <ddarius> I imagine -Wall will do that.
19:56:46 <jatqceer> mauke: thanks
20:01:15 <oerjan> :t ap.(id.) -- never change a winning team
20:01:23 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
20:04:36 <Paczesiowa> did anyone succeded with hxt's reading documents in iso-8859-X encodings?
20:05:38 <Paczesiowa> my gramma sucks:/
20:05:46 <DukeDave> ddarius: Still only get warnings
20:06:04 <mauke> "only"?
20:06:10 <ddarius> DukeDave: Oh, you wanted errors? Then just -Werror.
20:06:19 <DukeDave> As in the computation doesn't fail
20:06:24 <DukeDave> *compilation
20:07:13 <DukeDave> Ah didn't know that one ddarius, cheers.
20:34:36 <MP0> One time in class my professor said that it's remarkable how close the languages of Java and Scheme are. I didn't agree with her then, but now I've seen the light:
20:34:36 <MP0> 11545 DrScheme     0.0%  8:16.84   6    99  4029   150M  13.9M   145M   573M
20:34:43 <sioraiocht> ?
20:35:01 <MP0> all 573 MB of light.
20:35:08 <Zao> A little virtual memory never killed anyone.
20:35:35 <MP0> 145MB of real memory is more than my web browser uses.
20:36:00 <ddarius> MP0: DrScheme isn't a Scheme implementation (it contains on, but it isn't one)
20:36:44 <MP0> It's written in scheme, just like java programs are written in java. Therefore, I think the comparison is apt.
20:37:26 <sioraiocht> MP0: are you sure it's WRITTEN in scheme?
20:37:48 <MP0> hmm, you're right, I can't prove that. I just looked at the source files and assumed it was.
20:38:06 <sioraiocht> oh
20:38:09 <sioraiocht> see I didn't know
20:38:12 <sioraiocht> that's why i was asking
20:38:12 <sioraiocht> lol
20:38:17 <sioraiocht> there's no reason to be snippy
20:38:45 <MP0> I wasn't being sarcastic... I can't prove that the LISP-like syntax is indeed scheme... it's an assumption on my part.
20:39:11 <fax> scheme doesn't look much like LISP
20:39:20 <MP0> sorry, S-Expression based
20:39:24 <FMota> it does relatvely.
20:39:34 <fax> DrScheme aint written in scheme
20:39:37 <fax> anyway
20:39:40 <dolio> How much memory does visual studio use these days?
20:39:44 <ricky_clarkson> Does LISP mean Common Lisp?  I'm not accustomed to what it means when all capitalised.
20:39:44 <fax> It's mostly C++
20:39:49 <ddarius> Many programs in Java are fat and they don't have to have knowledge of an entire set of standard and semi-standard libraries for at least two languages.
20:40:46 <allbery_b> LISP is kinda a language family
20:41:01 <allbery_b> or in this context maybe more of a szyntactic family
20:41:07 <allbery_b> *syntactic
20:41:22 <sioraiocht> I normally think of generic references to lisp as clisp
20:41:44 <ricky_clarkson> clisp is a Common Lisp implementation, and reportedly not a particularly good one.
20:41:48 <ddarius> Usually, Common Lisp is abbreviated CL.
20:41:56 <sioraiocht> oh oops
20:41:57 <sioraiocht> lol
20:42:47 <shachaf> ricky_clarkson: As I understand it, Lisp is ambiguous (sometimes Common Lisp), and LISP is any language in that family (including Common Lisp, Scheme, etc.)
20:43:06 <fax> LISP is the old old version of Lisp
20:43:14 <fax> where they (USE,CAPS,AND,COMMAS)
20:43:51 <wli> Is #haskell-blah still populated or has it all migrated elsewhere?
20:44:02 <sioraiocht> wli: it's still populated
20:44:08 <shachaf> wli: It seems to be populated.
20:44:17 <ricky_clarkson> LISP is Sun's next stock ticker.
20:44:21 <allbery_b> @users #haskell-blah
20:44:21 <lambdabot> Maximum users seen in #haskell-blah: 60, currently: 44 (73.3%), active: 6 (13.6%)
20:44:56 <shachaf> ddarius: CL can also mean "Combinatory Logic".
20:45:26 <sioraiocht> shachaf: Only to NERDs...oh wait..
20:45:56 <ddarius> shachaf: It's also the stock market symbol for Colgate Palmolive
20:46:04 <sioraiocht> I guess that would apply to Common Lisp, too
20:46:05 <sioraiocht> lol
20:46:28 <shachaf> ddarius: Yes, but there's hardly ever an ambiguity there. :-)
20:46:30 <sioraiocht> http://acronyms.thefreedictionary.com/cl
20:48:23 <shachaf> @lazyk
20:48:23 <lambdabot> Unknown command, try @list
20:48:27 <shachaf> :-(
20:48:49 <ddarius> @unlambda but no lazyk (and not really unlambda either)
20:48:49 <lambdabot>  fd:22: hClose: resource vanished (Broken pipe)
20:49:00 <shachaf> @help bf
20:49:00 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
20:49:07 <shachaf> Which also doesn't work.
20:49:14 * sioraiocht has a bf interpreter..
20:49:20 <ddarius> Luckily, we have @let
20:49:37 <ddarius>  @let bf = ...
20:49:50 <sioraiocht> @help let
20:49:50 <lambdabot> let <x> = <e>. Add a binding
20:49:53 <fax> oh yeah
20:49:58 <shachaf> @let s x y z = x z (y z); k x y = x; i x = x
20:50:02 <fax> can you do a bf eval in < 512 lines? :D
20:50:02 <lambdabot> Defined.
20:50:09 <ddarius> fax: Yes.
20:50:17 <sioraiocht> yes
20:50:28 <sioraiocht> fax: my interpreter was 80 lines long, and I think it's too long
20:50:35 <fax> oops
20:50:37 <fax> I meant 512 chars
20:50:56 <ddarius> fax: Most probably.
20:50:58 <fax> IRC message length
20:50:59 <wli> sioraiocht: There must be a paucity of primops.
20:51:21 <sioraiocht> wli: there's 8
20:51:24 <sioraiocht> iirc
20:51:46 <wli> Primop tables are pretty much where the bulk of interpreters for toy languages comes from. 8 primops is vaguely preposterous.
20:51:53 <sioraiocht> LOL
20:52:00 <shachaf> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
20:52:14 <fax> > repeat 'b'
20:52:14 <allbery_b> gesundheit
20:52:15 <lambdabot>  "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb...
20:52:32 <chessguy> @pl \x y z -> x z (y z)
20:52:32 <lambdabot> ap
20:52:40 <sfultong> > let _ = 5
20:52:40 <lambdabot>  Parse error
20:52:49 <sfultong> aww, I can't bind _
20:52:55 <wli> sioraiocht: What are these primops? I'm speaking of things like integer arithmetic, floating point arithmetic, primitive data type conversions, etc.
20:52:58 <allbery_b> > let _ = 5 in _
20:52:58 <lambdabot>  Parse error in expression
20:52:59 <shachaf> > let _ = 5 in 3
20:53:00 <lambdabot>  3
20:53:06 <sfultong> @let _ = 5
20:53:08 <lambdabot> Defined.
20:53:14 <shachaf> @let _ = 3
20:53:17 <lambdabot> Defined.
20:53:20 <sfultong> err, yeah... that's what I meant
20:53:20 <shachaf> @let _ = _
20:53:20 <lambdabot>  Parse error in expression
20:53:27 <sioraiocht> wli: in bf there's only integers and one pointer
20:53:43 <sioraiocht> wli: integers can be implicitly convert to chars, and vice versa
20:53:57 <wli> sioraiocht: Okay, that's below the level of a toy language and going into pathology.
20:54:02 <sioraiocht> yes
20:54:02 <sfultong> > _
20:54:03 <lambdabot>  Parse error in expression
20:54:09 <ddarius> wli: The goal of brainfuck was to be a Turing complete language with the smallest implementations possible.
20:54:17 <sfultong> > _ == True
20:54:17 <lambdabot>  Parse error in expression
20:54:22 <sioraiocht> I've seen smaller than mine in haskell, but they cheated
20:54:51 <fax> > chr 32
20:54:52 <lambdabot>  ' '
20:54:59 <wli> I can't see why that's an interesting goal.
20:54:59 <shachaf> Unlambda doesn't even have integers. :-)
20:55:03 <sioraiocht> lol
20:56:01 <MP0> Numbers are but a convenience
20:56:02 <sfultong> wli: perhaps we could understand more about the nature of computation from finding the most minimally complete definition?
20:56:35 * sfultong thinks it would be interesting to make a TC language smaller than BF=
20:56:40 <allbery_b> surely unlambda wins there?
20:56:54 <FMota> pretty much.
20:56:58 <allbery_b> hm, actually I'm not sure if unlambda is TC
20:57:04 <shachaf> Unlambda has various extras.
20:57:04 <allbery_b> I think it is
20:57:07 <shachaf> allbery_b: It is.
20:57:16 <sioraiocht> sfultong: http://scienceblogs.com/goodmath/goodmath/programming/pathological_programming/
20:57:18 <lambdabot> Title: Good Math, Bad Math, http://tinyurl.com/2zs4o2
20:57:21 <shachaf> Lazy K is, too.
20:57:27 <fax> Iota is smaller
20:58:00 <fax> http://ling.ucsd.edu/~barker/Iota/
20:58:02 <shachaf> fax: What do you mean by smaller?
20:58:03 <sioraiocht> http://scienceblogs.com/goodmath/goodmath/programming/pathological_programming/
20:58:05 <lambdabot> Title: Good Math, Bad Math, http://tinyurl.com/2zs4o2
20:58:13 <shachaf> fax: Fewer primitives?
20:58:17 <sioraiocht> that link its to the one instruction set computer
20:58:38 <sioraiocht> it's very likely turing complete
20:59:02 <shachaf> @let x a = a s k
20:59:03 <lambdabot> <local>:16:0:     Multiple declarations of `L.x'     Declared at: <local>:6:0...
20:59:16 <shachaf> @undefine
20:59:19 <lambdabot> Undefined.
20:59:19 <sfultong> sioraiocht: this I find interesting
20:59:23 <shachaf> @let on f g x y = g x `f` g y
20:59:25 <lambdabot> Defined.
20:59:27 <fax> @pointless (\x y-> chr (x !! y))
20:59:28 <lambdabot> (chr .) . (!!)
20:59:38 <shachaf> @let s x y z = x z (y z); k x y = x; i x = x
20:59:40 <lambdabot> Defined.
20:59:42 <shachaf> @let x a = a s k
20:59:43 <sioraiocht> sfultong: I had a class where I had to implement interpreters for some of these in haskell, was fun
20:59:45 <lambdabot> Defined.
20:59:48 <sfultong> @let (_,_,_) = (1,2,3)
20:59:51 <lambdabot> Defined.
21:00:00 <sioraiocht> check out the programming language NULL
21:00:07 <allbery_b> you realize that's a pointless binding, right?
21:00:16 <sioraiocht> a program consists of a number, it's prime factorisation determines execution
21:00:37 <sfultong> allbery_b: it's a statement on the futility of life
21:00:50 <ddarius> sortle does look brilliantly insane
21:01:02 <sfultong> sioraiocht: that's scary
21:01:04 <shachaf> sioraiocht: Like Gdel numbering?
21:01:17 <ddarius> Indeed, Goedel was doing that in the twenties
21:01:55 <sfultong> anyone ever think that perhaps our universe is modeled in 1 dimensional cellular atomata?
21:02:31 <sioraiocht> similar, the VM i believe deterministically decides a specific factoring scheme, and the emerging factor determines the next instruction
21:02:33 <ddarius> sfultong: Perhaps.  The most significant person with views closest to that would be Stephen Wolfram.
21:03:00 <sioraiocht> isn't godel numbering where you do log in base p for each prime and the exponents determine the instruction?
21:03:15 <fax> you know v
21:03:16 <fax> let f (x:y) = ...
21:03:29 <fax> can you do let f (x:y) = ... [] = somehow?
21:03:39 <sfultong> ddarius: yeah, that's how I know of cellular atomata.  I'm not as crazy about it as Wolfram, but I think it's possible it could be useful
21:03:51 <shachaf> fax: What do you mean?
21:04:01 <ddarius> sfultong: Cellular automata are clearly useful.
21:04:06 <fax> hm wanted to define the two cases.. I guess it would be better to just use case
21:04:23 <ddarius> > let f (x:xs) = [x]; f [] = [] in f "foo"
21:04:24 <lambdabot>  "f"
21:04:26 * sioraiocht repressed the class in which he learned about Cellular Automata...for unrelated reasons.
21:04:30 <fax> ahh cool thanks
21:04:45 <shachaf> You want to type f's name just once?
21:04:51 <shachaf> Oh.
21:06:05 <sfultong> sioraiocht: how come? were you taught through sexual torture?
21:06:53 <sioraiocht> sfultong: no, the prof was just a PSYCHO.  the class was entitled computability theory, no students from different semesters have ever described the same topics being taught in their version of the class
21:06:59 <sioraiocht> the mid-term was three weeks before the final
21:07:25 <sioraiocht> there was a take home portion to the final..due after the in class portion but assigned before it...the proof due for the take home was given for the question in the class
21:07:31 <fax> @pointless (\x -> take 2 x ++ [1+(x!!2)] ++ drop 3 x)
21:07:32 <lambdabot> ap ((++) . take 2) (ap ((++) . return . (1 +) . (!! 2)) (drop 3))
21:07:39 <fax> ugh.. is there a better way?
21:07:47 <fax> go from [1,2,3,4,5] to [1,2,4,4,5]
21:07:48 <sioraiocht> I know people that were given the WRONG final, i.e. one designed for a different clss
21:08:05 <sclv> where was this?
21:08:14 <sioraiocht> Syracuse University
21:08:39 <sclv> hmmm... i've heard stories about crazy computability theory classes from schools everywhere now
21:08:43 <sioraiocht> LOL
21:08:56 <scook0> fax: would using splitAt help?
21:09:00 <sioraiocht> the only other class this guy taught to undergrads was titled "Chaos and Dynamical Systems"
21:09:02 <sfultong> eh, just another bit of fodder for my argument against formal education
21:09:08 <sclv> i had a guy who used to digress about ancient greek theories of the afterlife and try to relate this to chomskyian grammars
21:09:16 * sioraiocht shudders.
21:09:37 <scook0> i.e. splitAt 2, duplicate the head of the tail of the second list, then glue them back together
21:09:38 <fax> let (x,y) = splitAt 2 [1,2,3,4,5] in x ++ [1+y!!0] ++ y
21:09:40 <sioraiocht> sfultong: formal education is the foundation upon which society progresses nowadays...imo
21:09:41 <sfultong> sounds like he had quite a handle on chaos
21:09:45 <fax> It's about as long :(
21:10:04 <scook0> you're golfing?
21:10:20 <P_D> write short functions that do bits and pieces, reuse short functions later
21:10:24 <fax> I'm failing to gold
21:10:26 <fax> golf
21:10:28 * dolio was taught chaos theory as part of his freshman physics course.
21:10:48 <sfultong> sioraiocht: you'd be hard-pressed to make me believe that
21:10:57 * sioraiocht took freshman physics his senior year, and passed without ever attending class after the first exam
21:11:10 <dolio> Heh.
21:11:15 * allbery_b has done pretty well with very little formal education, he thinks
21:11:33 <sfultong> what is this "golf" of which people speak?
21:11:34 <sioraiocht> allbery_b: in individual cases that can be true, but the theory often doesn't generalise
21:11:43 <sioraiocht> golf = SATAN
21:11:52 <allbery_b> sfultong: code golfing
21:12:03 <allbery_b> @go "code golfing"
21:12:06 <lambdabot> http://bogojoker.com/weblog/2007/03/18/code-golf/
21:12:06 <lambdabot> Title: bogojoker  Blog Archive  Code Golf
21:12:10 <sfultong> ah, thanks
21:12:47 <sfultong> sioraiocht: perhaps teaching could be done in a distributed system where the brightest were taught by professors, and some tree structure taught the rest?
21:13:05 <dolio> > let (x, e:y) = splitAt 2 [1..5] in x ++ (1+e) : y
21:13:12 <sioraiocht> sfultong: the trickle down theory didn't work economically, I don't think it's gonna work pedagogically either
21:13:14 <lambdabot>  [1,2,4,4,5]
21:13:18 <sfultong> that is, where taught == tutored
21:13:42 <scook0> > (uncurry (++)) . (id *** ((:) =<< head) . tail) . (splitAt 2) $ [1..5] -- it's not golf, but I like it ;)
21:13:43 <lambdabot>  Unbalanced parenthesis
21:13:51 <scook0> > (uncurry (++)) . (id *** ((:) =<< head) . tail) . (splitAt 2) $ [1..5] -- it's not golf, but I like it ;
21:13:52 <lambdabot>  [1,2,4,4,5]
21:14:15 <allbery_b> sfultong: arguably that's how it works now.  how many of you had TAs instead f profs?
21:14:18 <shachaf> (id ***) = second?
21:14:37 <sfultong> allbery_b: good point, but there should be more tiers
21:14:41 <sioraiocht> allbery_b: I never had a TA teach a class, and only 2 adjuncts.  There was one class that was going to be TA taught and a dropped it =p
21:14:51 <sioraiocht> *and I dropped it*
21:14:58 <ddarius> and e dropped it!
21:15:01 <sfultong> a is phonetically appropriate
21:15:13 <scook0> shachaf: true, I'm not in the habit of using first/second
21:15:37 <sioraiocht> lol not for my diction, it's not
21:16:01 <sioraiocht> though I'm sure I have some weird ones, being from the Left Coast
21:16:07 <sfultong> well who needs a consistent diction?
21:16:09 <sfultong> :-P
21:16:42 <sfultong> Heh, left
21:19:14 * sioraiocht will come back from the UK with some effed up half-British diction
21:20:11 <ddarius> I don't think "diction" is quite the word that you want.
21:20:23 * sfultong spent a year when he was 5-6 years of age in Britain, and it never impressed upon his diction
21:20:23 <ddarius> Though your statement likely stands.
21:21:20 <sioraiocht> ddarius: perhaps pronunciation
21:21:21 <dolio> You haven't been referring to people as "gov'ner" ever since?
21:21:54 <sioraiocht> dolio: haha no, although when drunk I tend to pick up accents stronger..it hasn't been remarked upon yet but I'm hoping no one refers to me as that "American douchebag"
21:21:59 <ddarius> sioraiocht: Yes, that would be more appropriate, or perhaps "dialect", or "accent", or "ideolect"
21:22:14 <sioraiocht> ddarius: the problem with ALL of those words is that they cover multiple meanings, lol
21:22:55 <sioraiocht> when really i just meant I'll probably pronounce stuff all messed up, lol
21:23:04 <ddarius> sioraiocht: Yes.  It would do little for me to list synonyms.
21:23:21 <ddarius> "diction" is word choice
21:23:42 <sioraiocht> ddarius: it can also refer to enunciation in the context of spoken language
21:23:59 <sfultong> heh, enunciation is really the best word for it
21:24:26 <ddarius> sioraiocht: You are correct, and I didn't know that.
21:24:39 * ddarius has never seen it used that way.
21:24:39 * sioraiocht <------- did a stint as a linguistics major
21:24:46 <fax> how do you find the first 'x' in a string before index 5 ? ":/
21:24:48 * sioraiocht <--------- did little more than pick up esoteric bits
21:25:03 <sfultong> sioraiocht: lojban? :)
21:25:16 <shachaf> fax: Find its index?
21:25:24 <fax> yeah
21:25:28 <sioraiocht> :t index
21:25:32 <ddarius> Ah, it's a "secondary" meaning.
21:25:37 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
21:26:10 <ddarius> (at least according to wikipedia, and wordnet seems to be the only other thing that gives it that definition according to Googling "define:diction")
21:26:21 <sioraiocht> haha
21:26:22 <shachaf> 'x' `elemIndex` take 5 xs?
21:26:37 <sioraiocht> THAT's the function i was thinking of, elemIndex
21:27:32 <fax> ahh neat
21:28:00 <sioraiocht> is there a way to pass ghci a string that's a haskell program and have it print the answer and exit?
21:28:21 <shachaf> fax: Or you could use elemIndex and then check the value.
21:28:27 <shachaf> sioraiocht: -e.
21:28:30 <sioraiocht> thanks
21:28:38 <shachaf> sioraiocht: That won't work with :m and friends, though.
21:28:45 <sioraiocht> shachaf: right
21:28:55 <sioraiocht> just actual haskell code
21:28:55 <shachaf> sioraiocht: It works with ghc, too; no need for --interactive.
21:30:15 <sioraiocht> w00t, thanks
21:47:06 <fax> > (\x->case x of "+-"->1;'_'->0) "+-_"
21:47:10 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
21:47:14 <fax> :|
21:47:24 <fax> isn't it possible to have mutliple things in a case
21:47:43 <fax> match '+' or '-'
21:47:43 <P_D> "+-" is a string, '_' a char
21:48:01 <P_D> well ocaml has a | b ->
21:48:05 <ddarius> and you separate the clauses with |
21:48:11 <ddarius> Not like OCaml
21:48:31 <ddarius> Er scratch that.
21:48:46 <P_D> good to know
21:48:47 * ddarius should probably go to sleep.
21:50:57 <sfultong> night ddarius
21:51:57 <fax> > let ev ctx i prog j=let f n=ev(let(x,y:z)=splitAt i ctx in x++[y+n]++z)i prog(j+1)in(case (drop j prog) of[]->[];p:rog->(case p of '>'->ev ctx(1+i)prog(j+1);'<'->ev ctx(i-1)prog(j+1);'+'->f 1;'-'->f (-1);'.'->(Char.chr(ctx!!i)):ev ctx i prog(j+1);']'->ev ctx i prog(if((ctx!!i)==0)then j+1 else(\(Just x)->x)$List.elemIndex '['$(take j prog));_->ev ctx i prog(j+1)))in ev(repeat 0)0"++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<++++++
21:51:57 <lambdabot>  Improperly terminated string
21:52:07 <fax> lies!
21:52:18 <fax> ah damn its too long
21:52:20 <sfultong> that's quite something
21:52:26 <sfultong> yeah, probably got cut off
21:54:11 <fax> @let bf = let ev ctx i j prog=let f n=ev(let(x,y:z)=splitAt i ctx in x++[y+n]++z)i(j+1)prog in(case (drop j prog) of[]->[];p:rog->(case p of '>'->ev ctx(1+i)(j+1)prog;'<'->ev ctx(i-1)(j+1)prog;'+'->f 1;'-'->f (-1);'.'->(Char.chr(ctx!!i)):ev ctx i(j+1)prog;']'->ev ctx i(if((ctx!!i)==0)then j+1 else(\(Just x)->x)$List.elemIndex '['$(take j prog))prog;_->ev ctx i(j+1)prog))in ev(repeat 0)0 0
21:54:19 <lambdabot> Defined.
21:54:29 <fax> > bf "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>."
21:54:31 <lambdabot>  "Hello World!\n"
21:54:34 <fax> yay :D
21:54:38 <shachaf> fax++
21:54:52 <jcreigh> fax: you could also use the built-in @bf :)
21:54:52 <Nafai> woah
21:54:56 <ddarius> @bf
21:54:57 <lambdabot> Done.
21:54:57 <Nafai> bf interpreter?
21:54:59 <shachaf> jcreigh: No, it's broken.
21:55:01 <fax> what!
21:55:03 <ddarius> @bf ++
21:55:03 <jcreigh> shachaf: oh?
21:55:03 <lambdabot>  fd:22: hClose: resource vanished (Broken pipe)
21:55:04 <fax> oh *phew*
21:55:07 <sioraiocht> I feel like SUCH a douche
21:55:07 <fax> I thought it was broken :p
21:55:14 <shachaf> jcreigh: As is @unlambda.
21:55:23 <shachaf> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
21:55:23 <lambdabot>  fd:22: hClose: resource vanished (Broken pipe)
21:55:27 <jcreigh> ah, brokenness is news to me.
21:55:37 <shachaf> It's been that way for quite a while. :-(
21:55:38 <Excedrin> how would you model quantum entanglement in Haskell?
21:55:54 <P_D> .. model?
21:56:08 <ddarius> Excedrin: You do the math.
21:56:28 <P_D> it's just linear algebra
21:56:53 <laziest> Excedrin: represent the state as a list of coefficients (just as P_D said)?
22:03:14 <FMota> Oh gosh, I have a really good quote..
22:03:21 <Excedrin> hm, I'm not sure how to express my question: (a,b) <- makeQEPair; print a; ...; print b, outputs either 1 0 or 0 1, something like that
22:03:25 <jbalint> FMota: display it here
22:03:50 <ari> @quote FMota
22:03:50 <lambdabot> FMota says: Haskell's cryptic form \n is natural to some folks \n and so is Haiku's
22:03:51 <Excedrin> well, without IO
22:04:06 <P_D> you're trying to sample a distribution?
22:04:44 <P_D> oh I see
22:05:05 <Excedrin> it's a reasonable question right?
22:05:07 <FMota> "It seems to me that Ada was invented by someone who was trying to learn C and decided to take out all of complicated parts, and then made a bunch of shortcuts to make up for the lack of features."
22:05:11 <P_D> yes, you want to sample it and collapse the rest of the state appropriately
22:05:47 <ddarius> FMota: s/C/assembly and s/Ada/Algol
22:06:03 <dolio> I thought Ada was for people who want to write High Assurance Software, or something like that.
22:06:16 <FMota> not directly related to Haskell, unless you consider English to be related to a Native American tongue.
22:06:42 <FMota> Ada is terrible :/
22:06:53 <P_D> ignoring the actual math, it seems straight forward.  you have a state S and a function f which measures the state and a function g which takes that measurement and updates the state
22:06:56 <FMota> (for writing anything useful in)
22:06:57 <ddarius> Ehud Lamm is rather fond of Ada.
22:07:05 <dolio> So I gathered from your order-of-magnitude-more-code comment earlier. :)
22:07:07 <P_D> use the state monad or whatever to store the state
22:07:09 <FMota> Who
22:07:16 <FMota> *who's Ehud Lamm?
22:07:32 <ddarius> Founder of Lambda the Ultimate.
22:07:41 <FMota> mk
22:08:00 * dolio used to have Ada on his list of languages to learn, but has heard many negative reviews since then.
22:08:07 <allbery_b> @go lambda the ultimate
22:08:09 <lambdabot> http://lambda-the-ultimate.org/
22:08:09 <FMota> my problem with Ada is not so much the language, but the teacher
22:08:09 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
22:08:24 <ddarius> Ada Lovelace was soo snooty.
22:08:40 * allbery_b once had ada on his list of languages to learn... then he tried learning it and was repulsed
22:08:46 <FMota> although I wouldn't be caught dead doing anything useful with the language.
22:08:48 <dolio> Heh.
22:08:58 <ddarius> allbery_b: That's how tensor analysis was for me.
22:09:06 <FMota> XD
22:18:45 <FMota> ...
22:18:47 <FMota> for example
22:18:48 <FMota> http://pastebin.com/d7c6aa432
22:18:56 <FMota> this was my assignment
22:19:05 <FMota> I've written it in python in 17 lines.
22:19:13 <FMota> in Ada, I had over 200 lines.
22:19:36 <FMota> I spent roughly 4 hours on it
22:19:40 <FMota> ...while getting ill
22:19:41 <FMota> :/
22:27:13 <FMota> anyway
22:27:14 <FMota> bed time
22:27:16 <FMota> gnight folks
22:27:21 <FMota> see you... probably on monday
22:28:33 <goalieca> > 1/1.03
22:28:35 <lambdabot>  0.970873786407767
22:29:53 <sfultong> > 1 / 0.970873786407767
22:29:55 <lambdabot>  1.03
22:30:57 <goalieca> that's where the cdn dollar hit
22:33:36 <sfultong> I wonder if the usd won't crash... either way, it should be interesting
22:35:33 <FMotAFK> hm
22:35:41 <FMotAFK> cost of living in the us is very low
22:35:54 <FMotAFK> it's nice for Europeans who can't afford to live at home.
22:36:08 * sjanssen doesn't like "interesting" applied to the currency that all his money is in
22:36:31 <FMotAFK> sjanssen: convert your currency to something on the rise.
22:36:33 <FMotAFK> now.
22:36:37 <FMotAFK> er, *money
22:36:47 <sjanssen> meh, it's not like I have much
22:37:04 <FMotAFK> :/
22:37:15 <FMotAFK> you'll have much less if the crisis goes on.
22:42:33 <goalieca> canadian dollar is expected to break even
22:42:41 <goalieca> but we're not exactly rising compared to other markets
22:42:46 <goalieca> just the US
22:45:31 <FMotAFK> Amazing novel: http://www.lulu.com/browse/preview.php?fCID=1197639
22:45:31 <lambdabot> Title: Lorem Ipsum - The Novel by Matthew Greenwald (Book)
22:46:24 <fax> I was expecting an entire book of "lorem ipsum ..." text
22:46:33 * fax disappointed
22:46:42 <FMotAFK> ;)
22:56:21 <straszhm> i've got this type:
22:56:25 <straszhm> data Assignment = forall value domain. (Show value, Show domain) => value := domain
22:56:39 <straszhm> and want to construct a little function that pulls the value out,
22:56:45 <straszhm> getvalue (b := _) = b
22:57:15 <straszhm> so the signature would be,    getvalue :: Assignment -> ??
22:57:50 <straszhm> another forall doesn't seem to do it, and it seems that that would be too general anyhow
22:57:50 <allbery_b> I think the existential makes it impossible to pull out like that
22:58:03 <straszhm> ah
22:58:06 <allbery_b> your result is forall a. a
22:58:18 <allbery_b> and the only possibel value is therefore _|_
22:58:58 <allbery_b> (well, forall a. Show a => a, so in fact you could pull a value out by calling show on it
22:59:21 <allbery_b> getvalue :: Assignment => String; getvalue (b := _) = show b
22:59:37 <omniscientIdiot> s/=>/->/
22:59:45 <allbery_b> sorry, typo
22:59:47 <straszhm> yah
22:59:56 <allbery_b> you may have noticed I typo a lot
23:00:21 <straszhm> yah that compiles.  hm.
23:00:31 <allbery_b> anyway, you can't extract an existential type easily
23:02:08 <omniscientIdiot> When you pass values to the (:=) constructor, you get a value of type Assignment, losing any indication of the underlying type.
23:02:25 <allbery_b> yep
23:02:28 <straszhm> ah ok.
23:02:33 <straszhm> so it is like it looks like.
23:02:49 <allbery_b> if you want to be able to manipulate it, you need to lose the forall and use a type which you can deconstruct later
23:03:08 <straszhm> ok
23:03:13 <FMotAFK> This is too funny: "Invisible Pink Unicorns are beings of awesome mystical power. We know this because they manage to be invisible and pink at the same time. Like all religions, the Faith of the Invisible Pink Unicorns is based upon both logic and faith. We have faith that they are pink; we logically know that they are invisible because we can't see them" ~ Steve Eley
23:03:19 <FMotAFK> Anyway, I'm really going now.
23:03:20 <FMotAFK> Ciao
23:03:36 <straszhm> and if i don't want to limit that to a particular type
23:03:39 <allbery_b> e.g. data Value = ... -- definitions for your various value types, which give you constructors and deconstructors
23:03:47 <straszhm> i limit to a type class
23:04:00 <allbery_b> data Value = Str String | Num Int | ... -- for example
23:04:08 <straszhm> yah, that's what i just finished factoring out
23:04:27 <straszhm> trying to do a little constraint satisfaction thing
23:04:41 <straszhm> where the inputs are e.g.
23:04:55 <straszhm> data AuState = WA | NT | SA | Q | NSW | V | T deriving (Show, Eq, Ord, Enum, Bounded)
23:05:04 <straszhm> data Color = Red | Green | Blue deriving (Show, Eq, Ord, Enum, Bounded)
23:05:12 <straszhm> and an adjacency graph
23:05:17 <straszhm> (map coloring)
23:05:46 <straszhm> ah.
23:06:52 <straszhm> so instead of saying 'forall', it's "Show, Enum, Bounded", etc.
23:07:18 <allbery_b> forall creates a box that you can't look inside except under very limited conditions
23:07:29 <Mr_Awesome> is the random class in the stdlib not a monad?
23:07:48 <allbery_b> no
23:08:20 <allbery_b> it's designed so you can easily schlep around a seed in state, and you can get an initial random seed in IO
23:08:30 <allbery_b> but you don't *need* to use a monad with it
23:08:36 <Mr_Awesome> but i dont want to use IO with it
23:08:59 <allbery_b> so you can hardcode a seed
23:09:04 <dolio> @wiki New Monads
23:09:04 <lambdabot> http://www.haskell.org/haskellwiki/New_Monads
23:09:13 <omniscientIdiot> you can use the State StdGen monad for you random bits, use runState to supply it with a StdGen either from mkStdGen or newStdGen (in IO).
23:09:14 <dolio> Damn.
23:09:41 <Mr_Awesome> ah i see
23:09:56 <dons> ?yow
23:09:56 <lambdabot> Somewhere in suburban Honolulu, an unemployed bellhop is whipping up a
23:09:56 <lambdabot> batch of illegal psilocybin chop suey!!
23:10:04 <dolio> @wiki New_Monads/MonadRandom
23:10:04 <lambdabot> http://www.haskell.org/haskellwiki/New_Monads/MonadRandom
23:10:09 <omniscientIdiot> @type do {x <- State (randomR (0,10)); return (x * 2)}
23:10:12 <lambdabot> forall t s. (Random t, RandomGen s, Num t) => State s t
23:10:17 <dons> mmm, interesting spam:
23:10:17 <dons> Subject: [SPAM] Are there any side effects?
23:10:18 <dons> 100% Safe To Take, With NO Side Effects.
23:10:26 <dons> could describe haskell... :)
23:10:32 <FMotAFK> lol Haskell spam
23:10:42 <omniscientIdiot> > do {x <- State (randomR (0,10)); return (x * 2)} $ mkStdGen 42
23:10:43 <lambdabot>  Couldn't match expected type `a -> t'
23:11:08 <omniscientIdiot> > runState (do {x <- State (randomR (0,10)); return (x * 2)}) (mkStdGen 42)
23:11:09 <lambdabot>  (8,1720602 40692)
23:11:37 --- mode: ChanServ set +o dons
23:11:42 --- topic: set to '["The Haskell programming language: 100% safe to take, with NO side effects!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The language of ICFP winners 3 years running"]' by dons
23:11:47 --- mode: ChanServ set -o dons
23:11:48 <dons> :)
23:12:14 <dons> the best medicine is purely functional
23:12:53 <straszhm> what's imperative medicine, like cupping and leeches and stuff?
23:12:57 <fax> hehe
23:13:04 <sjw> dons: reffie
23:13:05 <sjw> re
23:13:25 <dons> yo yo what's up sjw!
23:14:16 <sjw> dons: plantin' time
23:14:17 <dons> straszhm: well, some kind of strange treatment: it might work, or it might not: we don't understand it, and it might also kill you
23:14:26 <arcatan> but how about functional food, where the whole point is in side effects
23:14:40 <dons> sjw, planting your crops, eh?
23:14:46 <sjanssen> food consumption is clearly monadic
23:14:46 <dons> ah, spring in the air?
23:15:02 <sjanssen> nutrients >>= me
23:15:07 <dons> sjanssen: or hmm, a fold of some sort
23:15:10 <dons> and we're the accumulator
23:15:32 <dons> foldl (\food me -> me $ food) empty [food..]
23:15:36 <allbery_b> krebs cycle as state monad?
23:16:42 <sjw> dons: yeah, basil (managed to completely kill my other stuff :), tomatoes, and hopefully some companion flowers
23:17:12 <dons> sjanssen: Iavor Diatchki reports that xmonad doesn't unset funny border widths and other state when exiting. we knew that, did'nt we/
23:17:12 <sjw> not quite sure if I should stick the flowers in the same pot tho
23:17:19 <Mr_Awesome> what do i import to get the state monad?
23:17:32 <dons> sjw, oh, one big pot of herbs and things
23:17:43 <dons> Mr_Awesome: import Control.Monad.State
23:17:57 <dons> in the `mtl' library
23:17:59 <sjanssen> dons: is he rebooting into another WM?
23:18:02 <dons> yeah
23:18:27 <Mr_Awesome> hmm, ghcxmake isnt finding it
23:18:30 <dons> it was funny, since i'd just given the talk about testing and eliminating bugs, then he finds `bug' related to setting state in the X server
23:18:51 <dons> never leave state in the X server :)
23:19:08 <sjw> dons: yeah, not sure if they will fight or not
23:19:17 <dons> sjw, so you going to come over here to hack Isabelle and haskell for a living yet? :)
23:19:23 <dons> we have an espresso machine...
23:19:39 <sjanssen> dons: I can't say that I've considered the problem before, but it makes sense
23:19:39 <fax> What kinds of things are you doing with Isabelle?
23:20:08 <dons> provin' stuff :)
23:20:29 <dons> sjanssen: well, didn't we have a rule not to leave state in the X server/
23:20:38 <dons> since its so easy to forget to set and unset it
23:20:50 <sjanssen> we don't really have a choice with window borders
23:20:55 <dons> no, i know.
23:20:59 <sjanssen> it's write-only, residual state
23:21:00 <dons> but do we care enough to reset them?
23:21:16 <dons> maybe we don't care enough -- they shouldn't be using other window managers anyway :)
23:21:43 <sjanssen> perhaps, especially if somebody can show us that it's wrong
23:22:07 <sjanssen> which WM was Iavor booting into?
23:24:27 <dons> hmm. something on ubuntu.
23:24:53 <dons> one of the fairly default ones. i can ask him on monday -- but its probably not too important
23:25:08 <dons> did you have that future directions plan sorted ?
23:25:27 <dons> i should have some time this weekend to think about what other things we should do.
23:25:33 <sjanssen> no, I got side tracked
23:25:51 * dons votes for X monad checking stuff
23:26:10 <sjanssen> my main points were to make a shorter release cycle (a month or so), and to certainly get window rules/hooks done
23:26:33 <dons> shorter release cycles seem like a good idea
23:26:41 <dons> maybe we can just get a fixed release set.
23:26:46 <dons> always freeze in the last week
23:26:53 <dons> only add a few things in the first week after release
23:27:28 <dons> so, say, window rules this week, and maybe one other feature. then just bug fix / test for a couple of weeks.
23:28:16 <Mr_Awesome> i installed the mtl library but still no State, just ST
23:29:00 <dons> in ghci, you should be able to: :m + Control.Monad.State
23:29:04 <dons> if you've installed mtl correctly
23:29:10 <dons> ghc-pkg list mtl to double check its installed
23:29:19 <cinimod> :t liftM2
23:29:21 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:32:44 <cinimod> @hoogle (Monad m) => (a -> b -> c) -> m a -> m b -> m c
23:32:45 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
23:33:29 <Mr_Awesome> dons: apparently its installed, but in a strange place
23:33:32 <cinimod> @hoogle help
23:33:33 <lambdabot> Distribution.Setup.HelpCmd :: Action
23:33:43 <cinimod> @hoogle ?
23:33:43 <lambdabot> Test.HUnit.Base.(
23:33:43 <lambdabot> Test.HUnit.Base.(
23:33:43 <lambdabot> Test.HUnit.Base.(~=?) :: (Eq a, Show a) => a -> a -> Test
23:33:51 <omniscientIdiot> @help hoogle
23:33:52 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
23:34:21 <cinimod> Thanks but I was wondering how to get hoogle to tell me I needed liftM2
23:36:20 <omniscientIdiot> it doesn't seem to understand type constraints very well
23:36:35 <cinimod> :t ap
23:36:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:37:35 <Mr_Awesome> ah, i needed to add -package mtl to the command line
23:37:39 <oklopol> > liftM2 (Just [1, 2, 3]) (Just [4, 5, 6])
23:37:40 <lambdabot>  Couldn't match expected type `a1 -> a2 -> r'
23:37:52 <oklopol> > liftM2 [1, 2, 3] [4, 5, 6]
23:37:52 <lambdabot>  Couldn't match expected type `a1 -> a2 -> r'
23:37:55 <oklopol> :P
23:38:08 <oklopol> i didn't guess what that does :<
23:38:21 <omniscientIdiot> > liftM2 (+) [1, 2, 3] [4, 5, 6]
23:38:22 <lambdabot>  [5,6,7,6,7,8,7,8,9]
23:38:31 <oklopol> hmm
23:38:39 <oklopol> cartesian product + apply the function to the pairs?
23:38:50 <fax> > liftM2 (,) [1, 2, 3] [4, 5, 6]
23:38:51 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
23:39:12 <fax> yeah, seems so
23:39:12 <sjanssen> oklopol: in the list monad, yes
23:39:25 <omniscientIdiot> liftM2 (like all Monad library functions) is based on (>>=) and return, which are concatMap and (:[]) in the list monad respectively
23:39:36 <oklopol> oerjan said something about a monad regarding that function, which was why i tried using an arbitrary monad :P
23:39:43 <omniscientIdiot> (flip concatMap to be precise)
23:39:47 <oklopol> hmm... actually i'm not sure if Maybe is a monad...
23:39:59 <omniscientIdiot> @src Maybe (>>=)
23:39:59 <lambdabot> (Just x) >>= k      = k x
23:39:59 <lambdabot> Nothing  >>= _      = Nothing
23:40:02 <sjanssen> it is :)
23:40:50 <scook0> maybe is pretty much the simplest useful monad
23:40:56 <oklopol> > Just 4 >>= (\x->10*x)
23:40:57 <lambdabot>   add an instance declaration for (Num (Maybe b))
23:40:57 <lambdabot>     In the expression: 10 *...
23:41:02 <omniscientIdiot> To say that a type "is a Monad" is to assert that there exist (>>=) and return functions that satisfy the monad laws.
23:42:04 <oklopol> > (Just 4) >>= (\x->10*x) -- i guess i misunderstood the "= x" part in "(Just x) >>= k = k x"?
23:42:05 <lambdabot>   add an instance declaration for (Num (Maybe b))
23:42:05 <lambdabot>     In the expression: 10 *...
23:42:21 <oklopol> > (Just (4 :: Int)) >>= (\x -> 10 * x) -- i guess i misunderstood the "= x" part in "(Just x) >>= k = k x"?
23:42:22 <lambdabot>  Couldn't match expected type `Maybe b' against inferred type `Int'
23:42:32 <sjanssen> oklopol: k must have type a -> Maybe b
23:42:32 <omniscientIdiot> (>>=)'s second argument needs to return back into the monad, add a Just in your lambda
23:42:39 <oklopol> oh
23:42:56 <oklopol> > (Just (4 :: Int)) >>= (\x -> Just $ 10 * x)
23:42:57 <lambdabot>  Just 40
23:43:19 <oklopol> why do you have to get back in the monad?
23:43:26 <oklopol> and can you get back to a different on e?
23:43:28 <omniscientIdiot> @type (>>=)
23:43:29 <oklopol> *one
23:43:30 <sjanssen> @type (>>=)
23:43:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:43:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:43:40 <sjanssen> oklopol: the type says so
23:43:47 <omniscientIdiot> no to the second question :)
23:44:02 <oklopol> you know you're asking noob stuff when every question is answered twice identically withina few seconds :P
23:44:09 <oklopol> *within a
23:44:13 <sjanssen> @quote stereo
23:44:14 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
23:44:19 <sjanssen> lol
23:44:30 <dolio> Yep.
23:44:38 <fax> hehe
23:45:05 <cinimod> what did it do?
23:45:15 <ari> But it was so true :(
23:45:20 <oklopol> oh cool i just got the Maybe monad and why it does a generic error propagation
23:45:25 <oklopol> i think
23:45:38 <omniscientIdiot> something like, "Welcome to #haskell, where your questions are answered in glorious stereo!"
23:45:45 <oklopol> Nothing >>= _ = Nothing <<< error propagation
23:45:55 <omniscientIdiot> precisely
23:46:01 <sjanssen> majestic stereo
23:46:16 <ari> @src Maybe (>>=)
23:46:17 <lambdabot> (Just x) >>= k      = k x
23:46:17 <lambdabot> Nothing  >>= _      = Nothing
23:46:32 <oklopol> @src Maybe (>>)
23:46:33 <lambdabot> (Just _) >>  k      = k
23:46:33 <lambdabot> Nothing  >>  _      = Nothing
23:46:48 <oklopol> >> is unconditional discard or..?
23:46:49 <bos> @seen cosmicray
23:46:50 <lambdabot> I saw cosmicray leaving #haskell-blah, #darcs and #haskell 3h 15m 15s ago, and .
23:46:57 <oklopol> @src IO (>>)
23:46:57 <lambdabot> m >> k      =  m >>= \ _ -> k
23:47:08 <oklopol> i don't get that...
23:47:12 <oklopol> hmm
23:47:42 <oklopol> @src IO (>>=)
23:47:43 <lambdabot> m >>= k     = bindIO m k
23:47:47 <arcatan> it was majestetic stereo
23:47:51 <sjanssen> oklopol: m >> n is generally, execute 'm' for it's effects, then execute n
23:48:14 <sjanssen> oklopol: for the Maybe monad, the effect is potentially failing the whole computation with Nothing
23:48:17 <oklopol> okay, and the IO monad is something magical is why that looks more complicated?
23:48:45 <sjanssen> oklopol: yeah, IO is special because the semantics are wired in to the compiler
23:49:07 <sjanssen> s/semantics/implementation
23:49:31 <cinimod> >>= used to be called bind many years ago
23:49:36 <oklopol> hmm... i don't know how haskell does Monads, actually, although i'm pretty sure i've grasped them during my idling here
23:49:39 * sjw goes to buy hoegaarden + soil
23:49:43 <oklopol> i mean, the concept
23:49:45 <sjanssen> oklopol: defining the meaning for (>>) in IO is like defining the meaning of ; in C
23:49:56 <oklopol> yeah
23:50:19 <oklopol> hmm... actually, that example was a pretty close one
23:50:27 <oklopol> i mean, >> == ; :P
23:51:22 <omniscientIdiot> oklopol: Monad is a typeclass.  Types which belong to the Monad class must supply (>>=) and return functions such that the monad laws hold ((>>=) is associative, return is (>>=)'s unit).  That's all there is to it.
23:51:57 <omniscientIdiot> Though, admittedly, this is very abstract and doesn't provide much of an intuition.
23:53:05 <oklopol> > return Just
23:53:06 <oklopol> > return Just 3
23:53:13 <lambdabot>  Add a type signature
23:53:13 <lambdabot>        add an instance declaration for (Show (m (a -> Maybe a)))
23:53:19 <oklopol> > return Just 3
23:53:20 <lambdabot>  Add a type signature
23:53:23 <oklopol> hmm
23:53:23 <fax> None of these computer theorem proving systems have been bootstrapped yet have they?
23:53:29 <oklopol> > return (Just 3)
23:53:30 <lambdabot>   add an instance declaration for (Show (m (Maybe t)))
23:53:35 <omniscientIdiot> which monad are you returning the Just function into? :)
23:53:45 <oklopol> oh
23:53:51 <omniscientIdiot> > return (Just 3) :: [Maybe Int]
23:53:56 <lambdabot>  [Just 3]
23:53:57 <oklopol> sorry, i guess i forgot what return is...
23:54:11 <Mr_Awesome> is there a prelude function that removes all duplicates in a list?
23:54:14 <oklopol> (forgot... guessed wrong that is)
23:54:18 <omniscientIdiot> nub
23:54:22 <fax> damn
23:54:30 <omniscientIdiot> > nub "funnybunnies"
23:54:32 <lambdabot>  "funybies"
23:54:55 <cinimod> I always preferred unit - I'm not sure why it got renamed return
23:55:27 <oklopol> omniscientIdiot: how do you do side-effects with that?
23:55:38 <oklopol> that's what i don't really see
23:56:01 <oklopol> i like to think of haskell's typeclasses like scheme's atoms :)
23:56:02 <omniscientIdiot> oklopol: the IO type specifically is what is really side-effectful
23:56:07 <oklopol> oh
23:56:09 <oklopol> i see
23:56:54 <oklopol> in case i actually try to program something in haskell sometime, i may understand this a bit better
23:57:02 <omniscientIdiot> merely because you can chain together IO actions via Monad's (>>=), but you cannot extract values out of an IO action into the side-effectless world.
23:57:02 <sjw> fax: how do you mean?
23:57:03 <oklopol> playing with lambdabot doesn't allow much Monad fun
23:57:33 <fax> sjw: well maybe it's ridiculous to do so.. but I don't think any have been used to prove themselves correct
23:57:49 <oklopol> omniscientIdiot: so you cannot have two states of the IO monad simultaneously?
23:58:03 <oklopol> i mean, like stored in two different vars or something...
23:58:08 <sjw> fax: John Harrison did something like that
23:58:15 <sjw> @google "HOL in HOL"
23:58:17 <lambdabot> http://www.lyrics007.com/Ab4%20Lyrics/Hol%20Lyrics.html
23:58:17 <lambdabot> Title: Ab4 - Hol Lyrics
23:58:29 <sjw> not quite
23:58:33 <fax> hehe
23:58:42 <omniscientIdiot> oklopol: aye, the only IO action ever actually run is kicked off by the compiler, and is named main.  The subsequent actions chained to it get run in sequence.
