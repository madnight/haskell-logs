00:00:00 <oklopol> and because you don't actually have like a variable with the Monad in it, you cannot have multiple copies of it, it's just implicitly passed around, nameless?
00:00:18 <sjw> fax: http://www.springerlink.com/content/t1v7147757368n73/
00:00:19 <lambdabot> Title: SpringerLink - Book Chapter
00:00:29 <sjw> lambdabot: that is not so helpful
00:00:51 <sjw> fax: the main problem is that verifying something in itself doesn't really make sense
00:01:01 <omniscientIdiot> @wiki IO_Inside
00:01:01 <lambdabot> http://www.haskell.org/haskellwiki/IO_Inside
00:01:06 <omniscientIdiot> ^^ try that, oklopol
00:01:14 <fax> yeah I guess because if there's some inconsistency you could prove anything is true
00:01:20 <sjw> at some point you have to pin the foundational medal on it and call it quits
00:01:29 <omniscientIdiot> oops
00:01:40 <sjw> but that paper does some gymnastics to get around the paradox
00:01:56 <omniscientIdiot> I guess I forgot the name.  Anyone know which wikipage I'm thinking of?
00:02:37 <sjw> fax: http://www.cl.cam.ac.uk/~jrh13/papers/holhol.html
00:02:38 <lambdabot> Title: Towards self-verification of HOL Light
00:02:57 <fax> cool
00:02:58 <fax> thanks
00:03:19 <sjw> but also, most theorem provers that I know of have a small kernel and a lot of tactics
00:03:51 <sjw> and the tactics are sound in that they can't just create terms
00:04:16 <omniscientIdiot> blasted capitalization >:/  http://haskell.org/haskellwiki/IO_inside
00:04:18 <lambdabot> Title: IO inside - HaskellWiki
00:05:12 <fax> hehe
00:05:18 <fax> I like this bit "G ̈odel’s second incompleteness theorem tells us that it cannot prove its own consistency in any way at all — unless of course it isn’t consistent,  in which case it can prove anything"
00:05:41 <oklopol> hmm... before i start reading, how does performUnsafeIO work?
00:05:51 <sjanssen> oklopol: magic
00:05:52 <omniscientIdiot> evilly
00:05:53 <oklopol> is it an identity function that has the side-effect of printing or..?
00:06:02 <oklopol> i'm thinking it'd be prefect for debugging
00:06:06 <oklopol> *perfect
00:06:10 <TSC> It lets you run an IO action "outside" of the IO monad
00:06:10 <scook0> oklopol: Debug.trace
00:06:13 <oklopol> ah
00:06:14 <scook0> :t trace
00:06:23 <lambdabot> Not in scope: `trace'
00:06:25 <TSC> So it's unsafe, unless you're careful
00:06:27 <sjanssen> trace uses unsafePerformIO internally
00:06:29 <oklopol> i guess a debugging tool might be better than debugging output
00:06:33 <scook0> @hoogle trace
00:06:33 <lambdabot> Debug.Trace.trace :: String -> a -> a
00:06:33 <lambdabot> Debug.Trace :: module
00:06:33 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
00:06:54 <oklopol> i'm just used to doing lots and lots of dummy output from python
00:07:09 <sjanssen> oklopol: trace can do that sort of thing
00:07:28 <sjanssen> it isn't used that often in typical code, however
00:07:50 <scook0> trace "msg" x is like x, but it prints the message just before x is evaluated
00:07:59 <sjanssen> Haskellers tend to write small functions which are tested alone in ghci or with QuickCheck
00:08:02 <sjw> later
00:08:35 <oklopol> > Debug.Trace.trace 7*4
00:08:36 <lambdabot>   Not in scope: `Debug.Trace.trace'
00:08:49 <oklopol> no library support or?
00:09:02 <scook0> it's probably not allowed in \bot's sandbox
00:09:09 <scook0> try it in ghci
00:09:18 <sjanssen> oklopol: lambdabot has a whitelist of allowed packages, to avoid something naughty happening
00:09:38 <omniscientIdiot> if lb could evaluate arbitrary IO actions, it could be used to do Evil Things(tm).
00:09:52 <scook0> Prelude> Debug.Trace.trace "hello" 3
00:09:52 <scook0> hello
00:09:52 <scook0> 3
00:09:54 <sjanssen> like "unsafePerformIO $ readFile "/etc/passwd"" and such
00:10:08 <omniscientIdiot> > readFile "blah"
00:10:10 <lambdabot>  <IO [Char]>
00:10:23 <omniscientIdiot> ^^ just evaluates simply to the action, without running it
00:10:55 <oklopol> because the IO monad isn't passed to whatever is on the line?
00:10:57 <oklopol> i mean
00:11:01 <oklopol> hmm
00:11:04 <oklopol> not sure what i mean.
00:12:47 <omniscientIdiot> an (IO blargh) value is a program fragment that when run will produce a blargh value.  Haskell provides no way to run IO actions yourself.  The only action run is the Main.main :: IO (), when you run your program.
00:13:03 <omniscientIdiot> (Well, no way besides unsafePerformIO, that is)
00:14:34 <omniscientIdiot> Given an action (doStuff :: IO foo) you can use ((>>=) :: IO foo -> (foo -> IO bar) -> IO bar) to connect doStuff to another action, and end up with a combined action that, when run, will produce a bar.
00:15:10 <omniscientIdiot> (>>=) is the only (safe) way to connect IO actions.
00:15:44 <Cale> and things built from >>=
00:15:54 <Cale> and do-notation, which desugars to it :)
00:16:39 <oklopol> yeah
00:18:32 <omniscientIdiot> The point of this is that any value in the IO type, specifically, cannot escape because there is no (again ignoring unsafePerformIO) function of type (IO a -> a)
00:20:36 <Cale> unsafePerformIO isn't really part of the language proper anyway, it's more of a hook into the runtime system
00:21:05 <omniscientIdiot> Thus the primitive functions which implement IO's bind and the primitive actions provide in the libs (getLine, putStr and the like) are completely under the control of the Haskell implementation.  A function cannot interact with the outside world unless it uses the IO type.
00:23:30 <omniscientIdiot> say, for example, you had x = unsafePerformIO (readFile "blah"); the file blah will be read only when the Haskell implementation decides to evaluate x, like when you try to putStr x in the main IO chain, for example.
00:24:31 <Cale> Basically, you shouldn't use unsafePerformIO unless you actually know how the compiler is going to compile it.
00:24:45 <Cale> It should actually be called simonPerformIO
00:25:21 <omniscientIdiot> since values are supposed to be pure, Haskell has the option of re-evaluating x if it wants, since pure function results are guaranteed to *only* depend on inputs and never change with time.
00:25:40 <omniscientIdiot> If the file were changed, Screwy Things(tm) could happen.
00:28:24 <omniscientIdiot> are you not completely lost?  :)
00:29:16 <oklopol> if you're talking to me, i think i'm following fine
00:29:34 <oklopol> http://web.maths.unsw.edu.au/~norman/views2.htm <<< just laughing at this too hard to be able to follow irc
00:29:35 <lambdabot> Title: A/Prof N J Wildberger Personal Pages
00:33:16 <omniscientIdiot> (on a sidenote, I think the usual emphasis on IO's "monadness" by tutorials etc. is misplaced.  That IO is a monad has little to do with its encapsulation of side-effects; the lack of an IO a -> a function has everything to do with it.)
00:34:56 <oklopol> that page is unbelievable, it's like a highschooler had spent to much time geeking around concocting theories...
00:35:01 <oklopol> *too
00:35:38 <oklopol> i used to have a similar conception of maths before i started functional programming and actually started learning stuff
00:35:50 <omniscientIdiot> "Why real numbers are a joke"...  yep, quality reading.  I'll get right on it.
00:35:58 <oklopol> heh :P
00:36:54 <wli> Depends on what it says, but the phrasing suggests it's clueless garbage vs. the philosophical objections to the reality of real numbers.
00:37:54 <fax> real numbers /are/ much scarier than imaginary numbers though
00:38:16 <omniscientIdiot> but imaginary numbers are... imaginary!
00:38:22 <wli> Or at the very least to their name (there are various very good reasons to believe they're every bit as imaginary as imaginary numbers).
00:38:26 <omniscientIdiot> IT'S CRAZY TALK!
00:39:34 <fax> naturals, zero, integers, √-1 .. all very clear cut.. but the reals are much stranger.. don't you agree?
00:41:00 <wli> The passage from rationals to reals is a more complex step than the passage from reals to complex numbers for the most part.
00:41:23 <fax> yeah, and consequently the properties they hold
00:41:34 <wli> But they're not the only possible completion of the rationals; they're merely the unique Archimedean completion.
00:42:14 <omniscientIdiot> The reals have a bunch of strange properties of infiniteness, that, as someone whose maths knowledge is largely limited to GEB, are quite strange indeed. :)
00:43:19 * omniscientIdiot hugs his copy of GEB
00:44:42 <wli> I'm almost convinced that book's done more harm than good.
00:45:03 <omniscientIdiot> Death to the infidel!
00:45:18 <astrolabe> I don't see how it's done much harm
00:46:12 <wli> It's created an artificial sense of mystery, I think. And a lot of people end up not really reading it to boot.
00:46:40 <wli> Worse than that, it has to be deciphered after a fashion.
00:47:12 <omniscientIdiot> I have a basic understanding of the formal system now, and more practice with proving.  That's beneficial at least.
00:47:37 <wli> If that happens, then it's beneficial.
00:47:39 <astrolabe> I suspect most such people would never had done much maths/physics/computing anyway.
00:47:46 <wli> I don't believe it happens most of the time.
00:49:26 <omniscientIdiot> I'll admit to behaving all dreamy-eyed "Maths and fundamental inconsistencies and the WORLD and strange loops OMG!!!!" when I first read it. :P
00:50:24 <omniscientIdiot> Hofstadter's wordplay is entertaining, at the very least. :D
00:50:40 * therp orders a copy of GEB. 
00:51:04 <wli> omniscientIdiot: That sort of reaction is something I think is not good.
00:51:09 * fax makes a mental note not to read GEB
00:51:26 <wli> omniscientIdiot: I think that is a very bad sort of impression to make.
00:51:33 <oklopol> whut... that A={a} part, where he actually says every set with 1 element is an infinite binary tree... what??!?!?
00:51:41 <omniscientIdiot> hence "I'll admit to..." :)
00:52:09 <oklopol> http://web.maths.unsw.edu.au/~norman/views2.htm and search "Just to get you thinking "
00:52:09 <lambdabot> Title: A/Prof N J Wildberger Personal Pages
00:52:18 <astrolabe> I think that people who don't read GEB miss out.
00:53:05 <oklopol> or is that true, what he says? i don't see the point
00:53:35 <wli> These are not the sorts of things that one should treat mystically. They're things one should train oneself to find as "ordinary" and develop one's intuition to find such results natural.
00:55:06 <omniscientIdiot0> INTERNET!  *shakes fist*
00:55:16 <astrolabe> I feel that a lot of things he looks at are deep enough that they are mysterious.
00:55:39 <astrolabe> For example, pretty much anything associated with consciousness.
00:56:43 <oklopol> "Mathematics does not require `Axioms'. The job of a pure mathematician is not to build some elaborate castle in the sky, and to proclaim that it stands up on the strength of some arbitrarily chosen assumptions. The job is to investigate the mathematical reality of the world in which we live. For this, no assumptions are necessary. Careful observation is necessary, clear definitions are necessary, and correct use of language and logic are necessary. But at 
00:56:47 <wli> "Deep" is a mystical notion. "Foundations" is the real issue.
00:56:50 <oklopol> whoops, that was a bit longer than i tohugh
00:56:52 <oklopol> *thought
00:57:23 <oklopol> but... 20 years of math professoring and that's the outcome?
00:57:35 <therp> oklopol: oh. that's sad.
00:57:57 <oklopol> i mean, i'm in high school, never done any math, and i'm laughing my ass off :P
00:58:04 <astrolabe> Also, I'm not really sure I believe in the idea of harmful books.  Readers should be critical, and it's like a theorem in information theory that a channel can only have a positive data rate.
00:58:14 <omniscientIdiot0> without a base of axioms and rules, you by definition cannot explore theorems.  That's the definition of formal systems!
00:58:30 <fax> oklopol: amusing read, cheers
00:58:39 <fax> the views page
00:58:59 <oklopol> that was from goodmath, might as well link http://scienceblogs.com/goodmath/2007/09/the_perspex_machine_superturin.php too
00:59:01 <lambdabot> Title: Good Math, Bad Math : The Perspex Machine: Super-Turing Computation from the Nul ..., http://tinyurl.com/25vavf
00:59:02 <astrolabe> wli: It may be mystical, but that doesn't mean it doesn't describe something real and of relevance to mathematicians.
00:59:34 <oklopol> another great mind lost in that one :P
01:00:12 <xerox> astrolabe: I think I saw a paper about negative information in the context of quantum physics. That was interesting :)
01:00:32 <xerox> http://www.damtp.cam.ac.uk/user/jono/negative-information.html
01:00:33 <lambdabot> Title: Quantum information can be negative (popular description)
01:02:53 <astrolabe> xerox: heh: The original version of the paper can be obtained at the pre-print arxiv here. It has a cartoon and George Orwell quotes, which were deemed inappropriate for Nature
01:03:09 <xerox> haha.
01:03:51 <wli> George Orwell quotes? Oh dear.
01:06:54 <wli> I can see why there would be objections to that wrt. quantum physics.
01:07:20 <oklopol> btw, before the whole superposition thing arose in the quantum world, was it already known in mathematics as an interesting concepts?
01:08:08 <oklopol> because if not, it'd be interesting to know what other trivial stuff we've missed just because it just never comes to mind without a cue from the physical world
01:08:45 <oklopol> some might disagree that qp is trivial, but i think the concept is simple to conceive
01:08:45 <dolio> oklopol: Have you read Not Even Wrong?
01:08:52 <oklopol> nope
01:09:32 <dolio> The author does a pretty good job of explaining how people in math and physics play off one another to discover interesting things in both.
01:09:37 <oklopol> i already have about 10 articles to read, all from starting to read one short goodmath article and following links and this channel :P
01:09:42 <wli> Ultimately all of it. Where do you think it all comes from? Even natural numbers are at root cognitive models of physical reality.
01:10:00 <fax> well yes
01:10:02 <fax> It's all models
01:10:16 <wli> It's why physics and math are so incestuously intertwined.
01:10:20 <dolio> Among other things. The end point of the book is to criticize string theory, but there's a lot of interesting stuff leading up to that.
01:10:44 <oklopol> dolio: is it online or do i have to ...do evil stuff to get it?
01:10:59 <dolio> It's a book. Hard back last I checked.
01:11:05 <oklopol> in finland buying isn't easy
01:11:12 <dolio> Ah.
01:11:19 <fax> hehe evil stuff
01:11:28 <oklopol> it's possible, but i don't like going out
01:11:40 <oklopol> i guess i could order it or smth
01:11:43 <oklopol> i'll put it on my list
01:11:57 <dolio> Huh, apparently it's on google books, whatever that is.
01:11:59 <omniscientIdiot0> WHAT IN THE WORLD MIGHT YOU BE REFERRING TO BY "EVIL STUFF"?  I'VE NO IDEA WHAT YOU COULD MEAN.
01:12:22 <dolio> Oh, I guess that's not full text.
01:12:42 <oklopol> omniscientIdiot: mouth stuff in an alley
01:13:01 <fax> woah :|
01:16:59 <wli> A highly underemphasized aspect of real numbers (returning to real numbers BTW) is essentially the notion of a limit.
01:21:17 <KatieHuber> man, ghc makes a mess :o
01:22:14 <oklopol> i love the ending on that negative information page :)
01:22:14 <omniscientIdiot> you shouldn't be so hard on your programs :P
01:23:17 <wli> It probably sounds weird that I say limits are underemphasized but it's true. Limits really need to be pounded into people's faces from the pedagogical POV and they aren't really treated so centrally because most presentations on foundations don't try to recapitulate the historical development that way, which I think they should.
01:25:56 <wli> There's a reason why things historically worked out the way they did, and those reasons are very good reasons to recapitulate a fair amount of history in pedagogy.
01:30:43 <dolio> People hate learning about limits, in my experience.
01:31:04 <fax> when we did limits it was ok
01:31:16 <fax> kind of cool actually
01:31:26 <dolio> Or, at least, they hate delta-epsilon proofs.
01:32:09 <roconnor> ``Even now, mathematics students are expected to learn complicated (e-d)-proofs in analysis with no help in understanding the logical structure of the arguments. Examiners fully deserve the garbage that they get in return.
01:32:27 <wli> Delta-epsilon proofs actually make a lot of sense to people when presented the right way. I've had tremendous success teaching delta-epsilon proofs to 12-year-old girls.
01:32:28 <roconnor> -- Paul Taylor, Practical Foundations of Mathematics.
01:32:48 <ricky_clarkson> wli: Success in what way? ;)
01:33:09 <KatieHuber> this could go downhill...
01:33:20 <wli> ricky_clarkson:  They're able to carry out delta-epsilon proofs.
01:33:26 <dolio> I find non-standard analysis intriguing, myself, but I've never sat down and studied it at all.
01:34:25 <ricky_clarkson> A lot of the things that people find hard aren't, if you know how to approach them.
01:34:59 <ricky_clarkson> ..and get them over any previous difficult experiences with them (this can be the most challenging part, depending on the person)
01:35:44 <wli> ricky_clarkson: I actuall find the younger and less experienced the person the easier it is because they have no idea what you're teaching them is supposed to be difficult or advanced yet.
01:35:45 <omniscientIdiot> How many approaches have monad tutorials taken thus far? :)
01:36:01 <dolio> Too many.
01:36:14 <ricky_clarkson> wli: Right.
01:36:21 <fax> I prefer the surrealist approach to teaching Monads
01:36:42 <wli> The approach not taken by any monad tutorial is to beat your face in with problem sets for working with concrete monads and monad transformers.
01:37:24 <wli> Because it actually takes work to write good problem sets. ;)
01:39:53 <omniscientIdiot> Heh.  Ultimately, after having read way too much, everything started clicking when I rewrote a simple interpreter into StateT InterpreterState IO
01:40:29 <omniscientIdiot> reading the source and understanding the function applications step-by-step.
01:40:32 <wli> Yes, it really takes monad transformers to understand monads.
01:41:30 <omniscientIdiot> I'd say: to understand their power.
01:43:29 <wli> I'd say: "to understand how to use them effectively."
01:44:01 <dolio> Transformers are sort of a realization of the original intent of monads.
01:44:19 <dolio> Nail down semantics in terms of easily composable units.
01:45:14 <dolio> Or, the intent of their use in denotational semantics, that is.
01:46:54 <wli> That probably has quite a bit to do with why monad transformers are really needed to understand how to make effective use of monads.
01:56:58 <omniscientIdiot> > cycle "lo"
01:57:00 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
01:57:20 <earnest> @src cycle
01:57:21 <lambdabot> cycle [] = undefined
01:57:21 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
01:57:26 <fax> @src repeat
01:57:27 <lambdabot> repeat x = xs where xs = x : xs
01:57:49 <earnest> > repeat "lo"
01:57:49 <lambdabot>  ["lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo",...
01:57:56 <fax> > concat $ repeat "lo"
01:57:58 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
01:58:15 <earnest> Haven't studied about $ yet. :(
01:58:25 <omniscientIdiot> f $ x = f x
01:58:27 <fax> concat (repeat "lo")
01:58:33 <omniscientIdiot> ^^ entire definition
01:58:51 <earnest> Oh, it composes?
01:59:00 <omniscientIdiot> just simple application
01:59:21 <earnest> I thought that function composition was ``.'' --- but that was a guess at looking at code.
01:59:22 <omniscientIdiot> (concat $ repeat "lo") = concat (repeat "lo")
01:59:35 <earnest> I see. That's function composition then.
01:59:37 <takamura> parentize until end of line
01:59:45 <omniscientIdiot> er, no...
01:59:47 <earnest> I guess.
01:59:58 <earnest> No? :) Function composition is then ``.'' really?
02:00:01 <omniscientIdiot> (.) *is* composition
02:00:19 <omniscientIdiot> ($) is application.  It effectively does nothing.
02:00:29 <omniscientIdiot> ($) f x = f x
02:00:43 <earnest> And why can't we write f x directly?
02:01:00 <takamura> f x y = (f x) y
02:01:03 <omniscientIdiot> Its usefulness is its low precedence.  You can omit parens.
02:01:05 <earnest> Like: > concat (repeat "lo")
02:01:09 <takamura> f $ x y = f (x y)
02:01:26 <earnest> Oh, so it's syntactic sugar for parentesis?
02:01:36 <takamura> yep
02:01:36 <omniscientIdiot> Effectively :)
02:01:53 <earnest> Hm, I see. Thanks. I feel better now.
02:02:21 <dolio> It isn't syntactic sugar, though. It's an operator that anyone could define.
02:02:22 <omniscientIdiot> f (giant honking argument to f) = f $ giant honking argument to f
02:02:38 <roconnor> (f . g) x =  f $ g x
02:02:52 <roconnor> f . g /= f $ g
02:02:58 <scook0> incidentally, ($) is just a type-restricted form of id
02:03:08 <earnest> Syntactic sugar is when the work is done by the compiler directly? THat is, it belongs in that syntax for convenience?
02:03:16 <omniscientIdiot> scook0: hush, you!
02:03:20 <scook0> f x = f $ x = f `id` x = id f x
02:03:48 <earnest> Let me try something for this case: > concat . repeat "lo"
02:03:50 <scook0> yeah, ignore that if it burns your brain ;)
02:03:59 <earnest> > concat . repeat "lo"
02:04:00 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
02:04:16 <omniscientIdiot> (.) expects a function.  (repeat "lo") isn't a function.
02:04:22 <earnest> Right.
02:04:29 <omniscientIdiot> > (concat . repeat) "lo" -- repeat is, though :)
02:04:29 <lambdabot>  Unbalanced parenthesis
02:04:34 <omniscientIdiot> :/
02:04:40 <omniscientIdiot> > (concat . repeat) "lo"
02:04:42 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
02:04:43 <takamura> > zipWith ($) [f, g, h] [x, y, z]
02:04:44 <fax> @pointless (\x->[0]++x++[1])
02:04:45 <lambdabot>   Not in scope: `z'
02:04:45 <lambdabot> (0 :) . (++ [1])
02:04:55 <takamura> @pl zipWith ($) [f, g, h] [x, y, z]
02:04:56 <lambdabot> zipWith id [f, g, h] [x, y, z]
02:04:59 <dolio> That'd be my definition, I suppose. do notation is syntactic sugar, because it performs syntactic transformations that you couldn't do without a preprocessor. I don't consider Haskell's operators syntactic sugar though, myself.
02:05:02 <takamura> @unpl zipWith ($) [f, g, h] [x, y, z]
02:05:03 <lambdabot> zipWith (\ a b -> a b) [f, g, h] [x, y, z]
02:05:06 <fax> > map ((0 :) . (++ [1])) [1..]
02:05:07 <takamura> nnn
02:05:07 <lambdabot>   add an instance declaration for (Num [a])
02:05:07 <lambdabot>     In the expression: 1
02:05:20 <earnest> dolio: got ya; I'd agree.
02:05:23 <fax> > map ((0 :) . (++ [1])) $ map (\x->[x]) [1..]
02:05:24 <lambdabot>  [[0,1,1],[0,2,1],[0,3,1],[0,4,1],[0,5,1],[0,6,1],[0,7,1],[0,8,1],[0,9,1],[0,...
02:05:40 <earnest> omniscientIdiot: I see your work above; thanks.
02:10:33 <omniscientIdiot> > 0 -- comments acting strangely?  (
02:10:33 <lambdabot>  Unbalanced parenthesis
02:10:43 <omniscientIdiot> > 0 -- blah
02:10:46 <lambdabot>  0
02:11:40 <earnest> Seems like the authors of lambdabot probably added a verification that just counts parenthesis before it feeds that to the interpreter, and the verification ignores comments.
02:11:47 <wli> Dyck languages; basically balanced parenthesis languages modulo regular sets or some such.
02:13:48 <STEWMONSTER> Good morning.
02:14:43 <omniscientIdiot> Good night.  I'm hittin' the sack.
02:14:47 <shteou> Cya :)
02:35:53 <EvilTerran> hm... i don't suppose it's possible to deriving() most of an instance, then selectively override some bits of it?
02:36:04 * EvilTerran wants an enum instance which doesn't start at 0...
02:36:45 <EvilTerran> > map fromEnum [LT, EQ, GT]
02:36:47 <lambdabot>  [0,1,2]
02:37:09 * EvilTerran thinks [-1,0,1] would make more sense, a la signum
02:37:15 <EvilTerran> but meh.
02:39:14 <Ben`> is it possible to import all the modules from a directory?
02:39:55 <EvilTerran> not implicitly, AFAIK, but if you find yourself doing it a lot, you could create another module which imports and re-exports all of 'em
02:40:29 <Ben`> ok, thanks
02:40:32 <EvilTerran> module Foo (module Bar, module Baz, module Eek, ...) where import Bar; import Baz; import Eek; ...
02:41:15 <EvilTerran> module Foo (module Foo.Bar, module Foo.Baz, module Foo.Eek, ...) where import Foo.Bar; import Foo.Baz; import Foo.Eek; ... -- even, with this module in the folder above; that's how things like TH and SYB with a lot of sub-modules do it
02:59:32 * EvilTerran notes that he has a habit of writing (q,r) = foo `divMod` bar; perhaps this is an occasion where `quotRem` would be more appropriate, for mnemonic reasons
02:59:41 <EvilTerran> (i'm only using positive numbers anyway)
03:01:10 <shteou> That's one way to stave off the inevitable depression of programming all day!
03:02:12 <EvilTerran> hm?
03:02:22 <shteou> Sorry, bad joke :(
03:02:26 * shteou hides
03:02:31 <EvilTerran> ahhh... i get it.
03:02:37 * EvilTerran gives shteou a hiding ;]
03:02:41 <shteou> ;p
03:13:07 * EvilTerran notes that there's a default method for divMod in terms of quotRem anyway, so it may be better for performance to use quotRem
03:14:27 <fax> I hope not :[
03:14:36 <fax> wouldn't the compiler be able to sort it out beforehand?
03:14:57 <KatieHuber> how does GHC handle classes anyway?
03:15:06 <EvilTerran> for Ints or whatever, there'll probably be native implementations of both
03:15:18 <scook0> dictionary passing, I believe
03:15:29 <KatieHuber> I assumed that it worked more or less like templates in C++, lots of copies of the code for each type, with each copy being efficient
03:15:32 <EvilTerran> and it can't tell if your numbers are always going to be such that quotRem = divMod
03:15:51 <scook0> KatieHuber: nope, unless inlining gets involved, there's only one copy of each polymorphic function
03:15:57 <KatieHuber> interesting
03:16:45 <KatieHuber> so every general function pays penalties like C++ virtual calls all the time?
03:17:12 <scook0> KatieHuber: well, only class-polymorphic functions incur dictionary lookup
03:17:27 <EvilTerran> > read (printf "%02x%02x" 14 238) :: Int
03:17:32 <lambdabot>  Exception: Prelude.read: no parse
03:17:40 <EvilTerran> > read (printf "0x%02x%02x" 14 238) :: Int
03:17:41 <lambdabot>  3822
03:17:57 <EvilTerran> > printf "0x%02x%02x" 14 238
03:17:58 <lambdabot>  Add a type signature
03:18:01 <EvilTerran> > printf "0x%02x%02x" 14 238 :: String
03:18:02 <lambdabot>  "0x0eee"
03:18:10 <scook0> (I should warn you that I'm only repeating what I've heard; I'm no GHC expert)
03:18:12 <EvilTerran> don't mind me, i'm just fighting with my FTP client ;]
03:19:30 <scook0> so if you call a parametric-polymorphic function like head, there shouldn't be any "virtual dispatch" going on
03:20:01 <scook0> you end up using the same object code for lists of all types
03:21:39 <KatieHuber> hmm
03:21:54 <KatieHuber> so there's no penalty to using existential types, if that's the case
03:22:08 <KatieHuber> since you've already got the virtual thing going on
03:22:30 <scook0> unless the compiler was previously being clever enough to specialise
03:25:13 <scook0> I have no idea how much specialization -O tends to do, but there are pragmas that can give the compiler hints
03:25:16 <Heffalump> it could specialise existentials too, though
03:25:55 <KatieHuber> in fewer situations, though
03:26:09 <KatieHuber> or at least, proportionally fewer :p
03:26:23 <Heffalump> sure. That's a Turing-complete problem to decide, whereas specialising normal type class usage is always possible, just a time-space tradeoff.
03:26:32 <scook0> I'd expect all operations on existentials to involve at least one virtual dispatch
03:26:49 <KatieHuber> doesn't in C++
03:26:50 <Heffalump> evaluating Haskell in general involves lots of virtual dispatch
03:26:53 <scook0> but if that dispatches to specialized code, you might be fine from then on
03:27:14 <scook0> KatieHuber: what do you mean "doesn't in C++"?
03:27:20 <Heffalump> since things are generally represented as thunks
03:27:27 <scook0> Heffalump: that's quite true, I was going to mention that
03:27:33 <olsner> is it leap->leapt or leap->lept?
03:27:37 <KatieHuber> I mean, if the compiler can statically prove the type of a given object, it doesn't have to do a virtual dispatch to its functions
03:27:37 <Heffalump> lept
03:27:41 <KatieHuber> leapt
03:27:51 <Heffalump> no, lept
03:27:52 <fax> left
03:28:01 <EvilTerran> leapt
03:28:09 <Heffalump> KatieHuber: I don't think C++ compilers do that very much. I think JVMs do.
03:28:09 <KatieHuber> lept is something to do with butterflies
03:28:12 <EvilTerran> @go lept
03:28:15 <lambdabot> http://www.lept-eu.org/
03:28:15 <lambdabot> Title: LEPT homepage
03:28:18 <EvilTerran> @go leapt
03:28:20 <lambdabot> http://www.thefreedictionary.com/leapt
03:28:21 <Heffalump> oh yes, I'm wrong.
03:28:30 <scook0> KatieHuber: I think that's mostly equivalent to class method inlining
03:28:37 <EvilTerran> hm. @go doesn't do "did you mean"...
03:28:44 <kjdf> I am wondering if there was any work on haskell-like language but more dynamic in behaviour
03:28:49 <KatieHuber> no wait that's lepidoptera
03:29:04 <KatieHuber> what do you want that's more dynamic than existentials provide?
03:29:05 <Heffalump> I'm just confused. Ignore me.
03:29:09 <olsner> thanks ;-)
03:29:10 <Heffalump> dynamic loading?
03:29:17 <scook0> what kind of dynamism did you have in mind?
03:29:30 <kjdf> that is, for example, one which allow replacing a function in the run time, and as long as everything looks the same (types, and whatever else is needed), other functions quietly pick it up
03:29:39 <kjdf> dynamic loading of sorts, yes
03:30:05 <scook0> a kind of still-well-typed extremely-late-binding
03:30:11 <KatieHuber> yikes, you're into Ruby territory there :p
03:30:12 <EvilTerran> sounds like a job for IORefs and hsPlugins
03:30:33 <EvilTerran> that sort of thing's better off explicit, imo, but i guess it depends on the task at hand
03:30:34 <scook0> sounds Hard to do elegantly, while retaining typing
03:31:03 <EvilTerran> it'd be painfully incompatible with laziness
03:31:29 <scook0> I wonder how well Qi can do that sort of thing?
03:31:41 <kjdf> well, the naive implementation wouldn't be too hard I think..
03:34:06 <shteou> Wow, cucumber juice is actually green.
03:34:09 <shteou> That's amazing.
03:34:42 <scook0> what were you expecting?
03:37:27 <pejo> kjdf, sounds like you have to be careful with inlining that function too.
03:38:40 <shteou> Colourless juice perhaps, scook0?
03:39:11 <scook0> oh, ok, fair enough
03:39:11 <shteou> I wasn't really expecting anything though, just happened to have cucumber juice drip on a piece of kitchen towel when I was making a lovely cucumber sandwich.
03:39:12 <fax> gross
03:39:28 <shteou> Not something I'd given much thought to :)
03:40:56 <kjdf> alice ml seems to do some things similar to what I asked, and surely is more thought through than my silly idea
03:58:18 <hpaste>  kurt pasted "Float to Double" at http://hpaste.org/2757
04:10:05 <b_jonas> Can you point me to a document that explains haskell classes and class methods?
04:10:59 <beelsebob_> well, there are many Haskell tutorials out there
04:11:12 <beelsebob_> but there's no such thing as a "Class method" in haskell
04:11:23 <shteou> I'm reading up from wikibooks atm, b_jonas.
04:11:26 <Botje> beelsebob_: do you mean typeclasses, perhaps?
04:11:27 <beelsebob_> if you're thinking that Classes are like OO Classes you're in for a bit of a shock
04:11:33 <hkBst> b_jonas: type class is the name
04:11:35 <shteou> heh
04:11:36 <Botje> b_jonas, even
04:11:58 <b_jonas> type classes and overloading, yes
04:12:26 <scook0> http://en.wikibooks.org/wiki/Haskell/Class_declarations perhaps?
04:12:28 <b_jonas> and what kind of functions you can declare in a class declaration and how instance works
04:13:04 <b_jonas> I'll look at that. why doesn't the bot reply with the title btw?
04:13:22 <scook0> @botsnack
04:13:23 <lambdabot> :)
04:18:46 <hpaste>  (anonymous) annotated "Float to Double" with "(no title)" at http://hpaste.org/2757#a2
04:27:05 <fax> oh man
04:27:23 <fax> I can't force myself to parse the prefix/infix/postfix ops
04:28:22 <fax> :[
04:30:29 <hkBst> postfix ops?
04:30:44 <fax> yeah, Prolog
04:31:40 <b_jonas> scook0: thanks, but that didn't really answer what I'd like to nkow
04:31:44 <fax> operators suck to parse
04:31:52 <scook0> ok, what did you have in mind?
04:31:56 <b_jonas> I'd like to know what kind of functions you can declare in a class declaration
04:32:14 <b_jonas> where can the type appear in the declaration that is
04:32:23 <scook0> more or less anywhere, I believe
04:32:38 <scook0> as an argument, as the return type
04:32:44 <scook0> even as a plain value
04:33:17 <b_jonas> can it be a parameter to a datatype constructor that gives the type of a parameter
04:33:35 <scook0> can you give me an example?
04:33:49 <b_jonas> like, can I say class Foo a where { bar :: [a] -> Bool }
04:34:02 <scook0> sure
04:34:08 <b_jonas> right
04:34:34 <b_jonas> right
04:34:47 <scook0> @src Show
04:34:47 <lambdabot> class  Show a  where
04:34:48 <lambdabot>     showsPrec :: Int -> a -> ShowS
04:34:48 <lambdabot>     show      :: a   -> String
04:34:48 <lambdabot>     showList  :: [a] -> ShowS
04:35:12 <scook0> there's an example (ShowS is just String -> String)
04:35:29 <b_jonas> so these methods you have to define either as a default implementation in the class, or in an instance declaration
04:35:38 <scook0> yeah
04:35:59 <scook0> you give the type signatures in the class declaration
04:36:05 <scook0> plus any default implementations you want
04:36:06 <b_jonas> but what about when you don't say class Foo a but like class Foo (T a) where T is a type constructor
04:36:15 <b_jonas> I don't get how that works
04:36:29 <b_jonas> or can you not do that?
04:36:33 <scook0> I think you'd say class Foo T in that case
04:36:47 <scook0> so-called "constructor classes"
04:36:56 <scook0> (classes over higher kinds)
04:37:05 <b_jonas> and then the type constructor T will have to appear somewhere in the method type declarations
04:37:08 <scook0> @src Functor
04:37:08 <lambdabot> class  Functor f  where
04:37:08 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
04:37:22 <scook0> is that the sort of thing you mean?
04:37:26 <b_jonas> yes
04:37:42 <scook0> Monad is another example (I picked Functor because it has fewer methods)
04:38:22 <b_jonas> but on the other hand, I can use a complex type in an instance declaration
04:38:33 <scook0> yeah, that's a little different
04:38:37 <b_jonas> like instance Eq (T a)
04:38:46 <b_jonas> so that's different
04:38:58 <b_jonas> I see, so that's what makes it complicated
04:39:02 <scook0> the result of the "complex type" application has to have the same kind as the class expects
04:39:19 <scook0> so you could have instance Functor IO
04:39:43 <scook0> but not instance Functor (IO a)
04:39:43 <scook0> because the kind is wrong
04:39:43 <b_jonas> yes, that makes sense
04:40:46 <b_jonas> and if you want a function that's overloaded on the types of two different parameters, you'll need an auxiliary function because a function can be method in only one class
04:41:12 <scook0> unless you use multiparameter type classes
04:41:26 <scook0> (whether you need those depends on your problem)
04:41:26 <b_jonas> ouch
04:41:49 <b_jonas> this type class system sounds really different from anything else I've seen in other languages
04:41:57 <scook0> it is
04:42:43 <scook0> MPTCs tend to put your brain into relational (database) mode
04:43:38 <scook0> you might want to read "How to Make Ad-Hoc Polymorphism Less Ad Hoc", which I think is the original typeclass paper
04:45:34 <scook0> (though skimming it now, I think constructor-classes and MPTCs came later)
04:45:53 <b_jonas> and can I say, like, class (Eq [a]) => Foo a where ...
04:46:13 <b_jonas> or does that work only in instance declarations?
04:46:20 <scook0> hmm, I'm not sure
04:46:33 <scook0> you can say class (Eq a) => Foo a where ...
04:46:49 <scook0> which means any instance of Foo must also be in Eq
04:47:03 <scook0> which, again, is different from the meaning of => in instances
04:47:33 <scook0> @src Ord
04:47:34 <lambdabot> class  (Eq a) => Ord a  where
04:47:34 <lambdabot>     compare      :: a -> a -> Ordering
04:47:34 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
04:47:35 <lambdabot>     max, min         :: a -> a -> a
04:50:44 <b_jonas> It's confusing how they use the word "polymorphism" for type classes and overloading
04:51:08 <b_jonas> polymorphism sounds to me rather like the runtime thing pattern matches do
04:52:20 <scook0> actually, pattern matching isn't polymorphic at all
04:52:30 <scook0> (at least in Haskell)
04:52:54 <scook0> because a datatype's constructors aren't themselves distinct types
04:53:01 <pejo> @go making ad-hoc polymorphism less ad hoc
04:53:03 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps.gz
04:53:32 <scook0> (unlike similar solutions in OO languages)
04:54:26 <scook0> it's almost as if all the terminology was specifically designed to confuse people with an OO background
04:55:12 <b_jonas> well that's the terminology you have to use with strong typing of course
04:55:44 <scook0> e.g. in functional circles, "polymorphism" usually means parametric polymorphism
04:55:44 <b_jonas> with weak typing, you can say a virtual method dispatches between different but compatible types
04:56:00 <scook0> whereas in OO circles, "polymorphism" means ad-hoc polymorphism
04:56:38 <b_jonas> in c++, the compile-time polymorhism is called "overloading" (and templates)
04:56:59 <b_jonas> if you have the word "overloading" as well for haskell methods, what's the point of using "polymorphism" as well
04:57:18 <b_jonas> it doesn't really matter though
04:57:34 <scook0> it's a terminology/culture difference
04:57:37 <b_jonas> yep
04:57:42 <scook0> consider head
04:57:45 <scook0> :t head
04:57:47 <lambdabot> forall a. [a] -> a
04:57:48 <b_jonas> it's like how "generator" and "iterator" means different things
04:58:05 <scook0> that's a (parametric) polymorphic function
04:58:07 <b_jonas> in different languages
04:58:15 <pejo> b_jonas, id is polymorphic, I doubt most people would consider it "overloaded".
04:58:31 <scook0> no matter what type a happens to be, the same code gets executed
04:58:35 <b_jonas> they can even mean two things in a language and the same two things reversed in another
04:58:58 <b_jonas> pejo: yes, because the implementation is the same in call cases
04:59:00 <scook0> I remember reading a good article about the different meanings of "polymorphism"
04:59:02 <b_jonas> there's just one definition for it
04:59:36 <b_jonas> even a function like 'f x y = x == y' is not polymorhic, it just calls a polymorphic functions
05:00:05 <b_jonas> oh well
05:00:15 <scook0> well, if you can't inspect the function source, you can't tell the difference
05:00:25 <b_jonas> scook0: sure you can't
05:00:29 <scook0> and in that case, the polymorphism is ad-hoc (not parametric)
05:00:41 <b_jonas> but if you don't have overloading (like in sml) you can't do some things
05:00:50 <scook0> because the equality-testing code used depends on the type of x & y
05:01:06 <wli> I have less kind words to describe ad hoc polymorphism.
05:01:31 <b_jonas> what would parametric mean?
05:02:50 <scook0> e.g. head (x:xs) = x
05:03:12 <scook0> which has type forall a. [a] -> a, usually just written [a] -> a
05:03:32 <scook0> the function doesn't even need to care what type a happens to be
05:04:06 <b_jonas> yes
05:05:18 <scook0> (I wish I could find that article)
05:06:01 <scook0> basically, parametric polymorphism works over all types, and the behaviour is uniform for all types
05:06:22 <scook0> whereas ad-hoc polymorphism only works over a subset of types, and the behaviour can differ for different types
05:06:40 <b_jonas> so parametric polymorphism is sml's generic functions
05:06:52 <b_jonas> except that it's not restricted to functions in haskell
05:07:12 <b_jonas> (because of lazyness)
05:07:16 <scook0> yeah, "generic" is the name usually given to PP in OO circles
05:07:32 <b_jonas> it's not actually called like that
05:07:33 <scook0> you mean the value restriction?
05:07:36 <b_jonas> it's functions of generic types
05:07:38 <b_jonas> I think
05:07:57 <b_jonas> generic type is anything that's not a specific type but contains type variables
05:08:59 <b_jonas> in sml that is
05:10:19 <scook0> SML doesn't have type classes, so I think anything using type variables would be parametric
05:10:41 <b_jonas> c++ doesn't actually have such functions, it just has templates and overloaded functions and functions in namespaces and things like that that make two functions have the same name
05:10:49 <b_jonas> yep, sml is like that exactly
05:10:50 <pejo> scook0, head can be defined in SML too.
05:11:08 <b_jonas> yes, and it is defined indeed (it's called hd though)
05:11:09 <scook0> c++ cheats, because it only types templates after they've been expanded (IIRC)
05:11:19 <scook0> pejo: that was my point, I think
05:11:27 <b_jonas> that's what I'm saying
05:11:34 <SamB_XP> b_jonas: if they are so into obscure names, why not "car"?
05:11:35 <b_jonas> c++ cheats, does everything in a symbolic manner
05:11:42 <b_jonas> SamB_XP: don't ask me
05:11:46 <pejo> scook0, so what was your reply when b_jonas asked about what parametric would mean?
05:12:07 <b_jonas> probably just shortening everything ("fun" and "fn" are keywords in sml)
05:12:32 <pejo> Oh, you meant it the other way around. Ok.
05:12:42 <b_jonas> I'm not surprised really, all languages do that (just think of "int", "def", "sub" and the like)
05:12:54 <scook0> head is parametric; (<=) is ad-hoc
05:13:27 <scook0> I don't think you can define a generic (<=) in SML, at least not without invoking the module system
05:13:42 <b_jonas> the long keywords like "procedure" and "subroutine" worked in old languages when they were just written like that but really represented as a single character in the punchcard (or two bytes in basic)
05:14:05 <b_jonas> scook0: yes, you can't,
05:14:23 <b_jonas> but there are some builtin arithmetic and comparision operations (including <=) which cheat
05:14:37 <b_jonas> and are polymorphic
05:14:40 <SamB_XP> cheat like C!
05:14:44 <b_jonas> but you cannot define new ones like that
05:14:54 <b_jonas> like "C"? no, it's C++
05:15:13 <b_jonas> and it also has polymorphic literals that cheat like that
05:15:22 <SamB_XP> <= cheats in C too ;-P
05:15:37 <b_jonas> hmm
05:15:49 <scook0> so in ML, you couldn't define a polymorphic sort of type (Ord a => [a] -> [a]) (modulo modules)
05:16:24 <b_jonas> yep
05:16:30 <scook0> but you could define sortWith :: (a -> a -> Ordering) -> [a] -> [a]
05:16:50 <b_jonas> yep (even if that's not the exact syntax)
05:16:56 <scook0> and in a sense, typeclasses are syntactic sugar for not having to specify that first argument everywhere
05:17:10 <scook0> (though there's more to them than that, of course)
05:17:11 <b_jonas> um, no
05:17:25 <scook0> I'm being pretty fuzzy here
05:17:31 <b_jonas> well, they do look like that
05:17:37 <b_jonas> but I don't know if it's really just that
05:17:42 <fax> scook0: You're just probability theory in disguise!
05:18:01 <SamB_XP> b_jonas: it isn't *just* that
05:18:04 <scook0> fax: ... outlook hazy, try again
05:18:16 <SamB_XP> it also means you can only have one first argument of a given "type"...
05:18:25 <fax> hmm looks like we need more fuzzy logic naysayers
05:18:47 <SamB_XP> I will advocate my new logic -- linty logic!
05:18:53 <bvd> Hello, quick question: How does the scope of the context affect the following datatypes: 'data Foo a = Num a => MkFoo a' and 'data Num a => Bar a = MkBar a' ?
05:18:55 <scook0> SamB_XP: which is fine for, say, Eq, but a pain for Monoid
05:19:09 <SamB_XP> scook0: a bit, yes!
05:19:18 <b_jonas> actually, sml has Eq
05:19:30 <scook0> b_jonas: yeah, but it *only* has Eq, as a special case
05:19:45 <b_jonas> and only the equivalent of 'deriving Eq'
05:19:53 <b_jonas> exactly
05:19:53 <scook0> so from another point of view, typeclasses are a generalization of eqtypes
05:20:02 <scook0> can you specify the comparison for eqtypes?
05:20:06 <b_jonas> no
05:20:10 <b_jonas> you can't
05:20:21 <b_jonas> it happens automatically for types where it's possible
05:20:44 <b_jonas> and for types that have functions or floats or anything like that, you can't define it
05:21:08 <scook0> bvd: is that first example legal?
05:22:03 <bvd> scook0: it compiles fine under GHC HEAD... I can also try it under GHC 6.6.1
05:22:38 <scook0> my guess is that in the former case, only the particular constructor is constrained
05:23:41 <b_jonas> scook0: that would be strange
05:23:56 <bvd> scook0: it also compiles under GHC 6.6.1
05:24:08 <b_jonas> would that mean that the type Foo a exists even if a is not Num but that constructor doesn't?
05:24:13 <b_jonas> what would the constructor do then?
05:25:04 <scook0> if I try to derive Show, ghci complains that MkFoo is a non-Haskell-98 constructor
05:25:14 <scook0> so I presume it's nonstandard
05:25:24 <scook0> and perhaps getting into GADT territory
05:25:47 <bvd> scook0: Mmm I'm browsing throught the GHC HEAD User Guide to find documentation on this...
05:29:30 <SamB_XP> scook0: how'd you define it?
05:30:04 <scook0> define what? (I just got peered)
05:31:03 <scook0> data Alfa a = Num a => Bravo a | Charlie a
05:31:06 <scook0>   deriving (Show)
05:34:36 <nornagon> Hm, I wonder if I could program my AVR microcontrollers in haskell with -fvia-C
05:35:07 <scook0> programming a microcontroller *in* Haskell might be going a bit far
05:35:32 <scook0> but you might be able to use a Haskell DSEL to generate code
05:36:16 <shteou> heh
05:36:24 <scook0> e.g. http://sigfpe.blogspot.com/2007/05/haskell-incarnate.html
05:36:25 <lambdabot> Title: A Neighborhood of Infinity: Haskell Incarnate
05:36:40 <shteou> :o
05:36:44 * shteou pats lambdabot
05:38:27 <b_jonas> I don't really know more than the essentials of sml though
05:38:57 <b_jonas> because of the badly designed criterions for the class that was meaning to teach it
05:39:07 <pejo> scook0, what are your objections to programming the microcontorller in Haskell?
05:40:37 <mrd> dreyer showed that haskell type-classes and ML functor/modules were interchangable functionality
05:40:42 <scook0> well, you're welcome to try, but I suspect Hs is too heavy for such a machine
05:41:10 <scook0> mrd: aren't the encodings onerous in practice?
05:41:31 <mrd> perhaps, but the idiomatic usage gets the job done
05:41:54 <scook0> I don't know enough ML (any, really) to comment
05:42:59 <b_jonas> the longset ML program I ever wrote I didn't actually write and doesn't even work well (it was still enough to succeed on the 8 easier test cases out of 10)
05:43:01 <scook0> there's a chapter on modules in ATTaPL, I think; I should read that again sometime
05:43:12 <mrd> I don't know about translating stupid type-class tricks but for your basic functionality of generalizing say "ordered types", you just write inside of a functor with an Ord structure parameterized.
05:43:29 <int-e> pejo: Haskell pretty much requires real time garbage collection in that scenario. It seems to be a little much for microcontrollers, although it should work in principle.
05:43:51 <SamB_XP> b_jonas: who/what wrote it?
05:44:28 <b_jonas> SamB_XP: a translator I wrote, see http://www.math.bme.hu/~ambrus/pu/olvashato/
05:44:29 <lambdabot> Title: Olvashato compiler
05:45:34 <mrd> I suppose there's more boilerplate in the ML version, but on the other hand, it doesn't have all these crazy issues with instances and (lack of) modulization.
05:45:46 <mrd> modularization?
05:46:26 <scook0> yeah, instance importing really ought to be first class
05:47:15 <mrd> but what does it mean to "qualify" an instance?
05:47:16 <scook0> supporting multiple instances for a single type tends to get ugly (e.g. newtypes)
05:47:24 <mrd> it doesn't have a name
05:47:39 <scook0> hey, I didn't say it was easy
05:47:57 <pejo> int-e, oh, we have a guy working on that here.  http://pure.ltu.se/ws/fbspretrieve/901432
05:48:00 <mrd> you would have to add some method of allowing the programmer to indicate the desired instance in a function call
05:48:32 <pejo> int-e, well. For a strict language. But still.
05:48:49 <scook0> I think implicit parameters might be related (i.e. a different solution to the same problem)
05:49:25 <mrd> well insomuch that type-class dictionaries are treated as "implicit" parameters
05:49:47 <mrd> but that's an implementational technique, not mandatory semantics
05:49:58 <scook0> and as I said, you can influence dictionary selection with newtypes, but it's ugly
05:50:11 <pejo> int-e, I'm not sure that the GC is the main problem with real time properties though, the lazy evaluation might be rather tricky to reason about.
05:50:11 <mrd> yep
05:50:20 <mrd> especially now that newtype deriving may have to be removed
05:50:31 <scook0> typeclasses are *really* nice in simple cases, though
05:50:36 <scook0> mrd: really? why?
05:50:43 <mrd> they're not type-safe
05:50:48 <mrd> or it*
05:50:52 <scook0> o_O
05:51:15 <int-e> pejo: yes, that too. and memory usage is hard to reason about.
05:51:27 <int-e> pejo: thanks for the link.
05:51:55 <scook0> mrd: do you have some link or reference? I'm curious
05:52:31 <scook0> (since I like newtype deriving)
05:52:49 <pejo> int-e, well, the memory usage goes hand in hand with the GC. If you have much memory the time for gc -> 0.
05:53:18 <mrd> http://hackage.haskell.org/trac/ghc/ticket/1496
05:53:20 <lambdabot> Title: #1496 (Newtypes and type families combine to produce inconsistent FC(X) axiom se ...
05:54:16 <int-e> pejo: you still have to bound the memory usage of live objects. if you generate an infinite list, you'll run out of memory. haskell has so much abstraction that this could easily happen by accident
05:54:21 <pejo> int-e, Hm. That did not come out right. If we either miss deadlines, or run out of memory - the system isn't behaving according to spec. Both are of course bad.
05:54:27 <mrd> bbl
05:55:03 <pejo> int-e, yes. Tricky problems.
05:55:45 <int-e> strict evaluation should be easier. (you pretty much said that already)
05:56:47 <pejo> int-e, yeah. He has reasoning about time/space properties listed as future work in the article, or has atleast been talking about tackling the problem.
05:57:55 <Saizan> mrd: there's already a solution for that, like adding a new kind iirc
06:08:42 <b_jonas> can you define a data that has no constructors? the report says that's invalid syntax, but is there some way?
06:10:17 <scook0> {-# LANGUAGE EmptyDataDecls #-}
06:10:25 <scook0> (or just -fglasgow-exts)
06:10:37 <b_jonas> uh huh
06:10:55 <b_jonas> I thought there was some other way to define an abstract data type using the report only
06:11:17 <scook0> oh, you just want an abstract type?
06:11:31 <b_jonas> depends on what abstract means
06:11:34 <scook0> you put it in a module, but don't export the actual constructor(s)
06:11:45 <scook0> so importing code can't use them
06:11:48 <b_jonas> yeah, that could work
06:12:04 <scook0> all (non-phantom) data types must have constructors
06:12:28 <scook0> but for abstract types, you want to hide those constructors from your clients
06:12:59 <scook0> bear in mind that if you don't specify an export list, the compiler will export everything
06:13:30 <Saizan> if you want a type with only _|_ as type you can use data Void = Void !Void
06:13:35 <scook0> (so to hide stuff, you must explicitly export everything else)
06:13:43 <b_jonas> Saizan: I wand a distinct type
06:13:57 <Saizan> s/as type/as value/
06:14:06 <scook0> do you want this type to have any values?
06:14:12 <b_jonas> no
06:14:15 <kpreid> b_jonas: distinct from what?
06:14:15 <b_jonas> no values
06:14:30 <Saizan> b_jonas: you can name it as you wish
06:14:36 <scook0> then you want EmptyDataDecls, or Saizan's trick
06:14:53 <b_jonas> ah, Void !Void
06:14:54 <b_jonas> I see
06:15:01 <b_jonas> so it can't be instantiated without an error
06:15:25 <scook0> I prefer just data Void, with the extension enabled
06:15:34 <scook0> but whatever floats your boat
06:16:14 <scook0> are strict fields H98?
06:16:19 <Saizan> yes
06:16:55 <SamB_XP> @where report
06:16:56 <lambdabot> http://www.haskell.org/onlinereport/
06:17:08 <scook0> b_jonas: can I ask what you need a phantom (value-less) type for?
06:17:30 <b_jonas> well, 'data Void = Void !Void' has the disadvantage that it might not catch compile-time if I attempt an instantiation
06:17:43 <b_jonas> scook0: to make them members of a type class
06:18:00 <b_jonas> then I can use methods of that type class with that type even if there's no such value
06:18:57 <SamB_XP> I thought "phantom types" was a term related to types having parameters that they don't actually use?
06:19:09 <SamB_XP> such as, oh...
06:19:11 <SamB_XP> @src Ptr
06:19:12 <lambdabot> data Ptr a = Ptr Addr#
06:19:27 <b_jonas> and then I can use them eg. to simulate data arguments to type constructros instead of type arguments
06:19:35 <b_jonas> s/data/value/
06:19:41 <scook0> maybe my terminology is wrong
06:19:44 <b_jonas> because I wrap the value in a type which I can pass there
06:19:56 <b_jonas> I don't know what counts as a "phantom type"
06:20:28 <scook0> SamB_XP: haskellwiki seems to back up my usage
06:21:05 <SamB_XP> http://en.wikibooks.org/wiki/Haskell/Phantom_types seems to agree with me
06:21:07 <lambdabot> Title: Haskell/Phantom types - Wikibooks, collection of open-content textbooks
06:21:17 <scook0> but your comment is certainly related to my usage, either way
06:22:45 <b_jonas> yep, it seems it is
06:23:01 <b_jonas> except I'd use templates to extract useful information from the type argument
06:23:15 <b_jonas> not just have the type argument so the type checker can check something
06:23:46 <SamB_XP> b_jonas: typeclasses!
06:24:33 <b_jonas> yes, sorry
06:24:36 <b_jonas> type classes
06:26:34 <scook0> SamB_XP: hmm, skimming papers seems to back up the "phantom type parameter" usage
06:27:01 <scook0> (i.e. yours, not mine)
06:29:04 <scook0> the GHC manual backs you up too, so I guess haskellwiki is wrong
06:29:37 <scook0> (or my reading of it)
06:51:09 <Esteth> if i have a Maybe object constructed with "Just 4", how do i get the 4 out of the Maybe?
06:51:21 <kpreid> Pattern matching.
06:51:35 <Saizan> > case Just 4 of Just x -> x
06:51:37 <lambdabot>  4
06:51:44 <kpreid> ? case Just 4 of Just x -> show x; Nothing -> "nope"
06:51:48 <kpreid> > case Just 4 of Just x -> show x; Nothing -> "nope"
06:51:49 <lambdabot>  "4"
06:51:53 <kpreid> > case Nothing of Just x -> show x; Nothing -> "nope"
06:51:54 <lambdabot>  "nope"
06:52:53 <kpreid> > case Nothing of Just x -> x
06:52:56 <Esteth> Ok, thanks. I think i understand.
06:52:56 <lambdabot>   Non-exhaustive patterns in case
06:52:59 <oerjan> :t fromMaybe
06:53:01 <lambdabot> forall a. a -> Maybe a -> a
06:53:02 <pejo> > fromJust (Just 4)
06:53:03 <lambdabot>  4
06:53:04 <kpreid> you can also use the functions fromMaybe and Maybe
06:53:06 <kpreid> er, maybe
06:53:09 <kpreid> :t maybe
06:53:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:53:20 <kpreid> fromMaybe lets you supply a default value.
06:53:35 <kpreid> 'maybe' lets you also transform the Just-value if there is one.
06:53:48 <oerjan> fromJust lets you crash and burn when you were wrong about it being a Just :)
06:54:09 <kpreid> fromJust is equivalent to a case expression with no clause for Nothing
06:55:16 <kpreid> these might also be interesting:
06:55:21 <kpreid> :t maybeToList
06:55:23 <lambdabot> forall a. Maybe a -> [a]
06:55:24 <kpreid> :t listToMaybe
06:55:26 <lambdabot> forall a. [a] -> Maybe a
06:55:58 <kpreid> they map between Nothing and [], and Just x and (x : _)
06:56:18 <LoganCapaldo> mmm maybe and list, the best of friends
06:56:37 <Esteth> Thanks all :)
06:57:12 <LoganCapaldo> @bot
06:57:12 <lambdabot> :)
07:00:03 <b_jonas> the sml library also has a function that maps Just Just x to Just x; Just Nothing to Nothing; and Nothing to Nothing
07:00:22 <kpreid> > join (Just (Just 1))
07:00:27 <lambdabot>  Just 1
07:00:33 <kpreid> > join (Just Nothing)
07:00:35 <lambdabot>  Nothing
07:00:38 <kpreid> > join Nothing
07:00:40 <lambdabot>  Nothing
07:00:42 <b_jonas> uh huh
07:00:43 <kpreid> @type join
07:00:44 <b_jonas> I see
07:00:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:00:52 <LoganCapaldo> pwnage! :)
07:01:22 <LoganCapaldo> @src join -- don't even need to write it
07:01:22 <sclv> > join [[2],[2]]
07:01:23 <lambdabot> Source not found. My mind is going. I can feel it.
07:01:24 <lambdabot>  [2,2]
07:01:27 <LoganCapaldo> oh
07:01:30 <b_jonas> is that the one that flattens a list of lists
07:01:38 <kpreid> @src Maybe join
07:01:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:01:38 <LoganCapaldo> well it's (>>= id)
07:01:49 <kpreid> er
07:01:56 <sclv> concat [[2],[2]]
07:01:58 <b_jonas> > join [[1, 2], [3, 4]]
07:02:00 <lambdabot>  [1,2,3,4]
07:02:07 <sclv> > concat [[2],[2]]
07:02:08 <lambdabot>  [2,2]
07:02:34 <sclv> @src (Maybe) join
07:02:34 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:02:46 <sclv> @src Maybe (join)
07:02:46 <lambdabot> Source not found. My pet ferret can type better than you!
07:02:48 <sclv> oy
07:02:49 <oerjan> it's not a method
07:02:58 <LoganCapaldo> it's just (>>= id)
07:03:02 <oerjan> it's just not listed in @src for some reason
07:03:08 <LoganCapaldo> @source Control.Monad
07:03:09 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
07:03:10 <b_jonas> can you use haskell for one-liners? and if so, how?
07:03:17 <b_jonas> I have ghc installed
07:03:19 <oerjan> or wait
07:03:21 <opqdonut> b_jonas: with pointless style
07:03:22 <oerjan> @src join
07:03:23 <lambdabot> join x =  x >>= id
07:03:24 <opqdonut> *pointfree
07:03:25 <opqdonut>  :P
07:03:31 <oerjan> comment was not allowed
07:03:38 <allbery_b> ghc -e ...
07:03:53 <opqdonut> ah, he meant that
07:04:00 <opqdonut> and not one-line programs
07:04:04 <sclv> @pl \x-> x>>= id
07:04:04 <lambdabot> join
07:04:16 <b_jonas> join is a useful function I think
07:05:13 <Saizan> m >>= f = join (fmap f m)
07:05:21 <b_jonas> ghc -e works, but that evaluates an expression only
07:05:30 <b_jonas> so can you use all kinds of declarations in that?
07:05:42 <b_jonas> you can use let for functions and the like
07:05:48 <b_jonas> but what about data types
07:05:53 <oerjan> nope
07:05:55 <allbery_b> you can't do e.g. data there
07:06:22 <LoganCapaldo> you don't need data anyway. you might need newtype...
07:06:23 <kpreid> I can't imagine a *useful* one-liner needing a data type...
07:07:14 <b_jonas> even if it's 5 or 6 lines long?
07:07:19 <LoganCapaldo> heh if you do ghc -ne does it pass your expresison to interact? :)
07:07:47 <b_jonas> obviously you can do lots of things with lists and maybes and functions etc alone
07:09:11 <oerjan> and Eithers
07:09:23 <opqdonut> and typles
07:09:25 <b_jonas> I mean, my real question is, is that because haskell is not useful for one-liners or because data are needed only in longer programs?
07:09:28 <opqdonut> *tuples
07:09:31 <b_jonas> yes, tuples
07:09:46 <opqdonut> well, all data types are practically isomorphic to tuples
07:09:49 <opqdonut> so there :)
07:10:00 <LoganCapaldo> Like I said I'm pretty sure you never *need* data.
07:10:00 <b_jonas> or I can represent any data with functions
07:10:05 <oerjan> all non-recursive ones
07:10:12 <LoganCapaldo> you might need newtype
07:10:16 <opqdonut> oerjan: yeah, with that limitation
07:10:17 <LoganCapaldo> :)
07:10:22 <b_jonas> newtype for what/
07:10:28 <opqdonut> but some recursive ones can be represented as lists
07:10:29 <opqdonut> :)
07:10:40 <oerjan> i guess newtype gives you the recursive ones too
07:11:47 <LoganCapaldo> like data Stream a = Cons a (Stream a). You can do that with a list as long as you a very carful to never use [] by accident. or you can do it with newtype + pair
07:12:00 <oerjan> but i guess one-liners would usually do things with Strings or maybe ByteStrings, and need little new?
07:12:21 <b_jonas> probably yes
07:12:46 <Saizan> so -e accepts import statements but not data declarations??
07:12:51 <b_jonas> in fact, I just searched my bash-history (which is full of ruby one-liners and some perl ones as well) for "class" and there were no useful instances
07:13:10 <b_jonas> but of course ruby is weakly typed so it's easy to have recursive data structures with just arrays
07:13:31 <LoganCapaldo> did you try searching the perl one liners for occurences of package? <g>
07:13:39 <allbery_b> I don't think you can import either
07:13:42 <opqdonut> :))
07:13:54 <b_jonas> LoganCapaldo: no, wait...
07:14:00 <LoganCapaldo> LOL
07:14:01 <b_jonas> but I probably just used functions there
07:14:03 <oerjan> however, ghc allows you to import implicitly by qualifying things
07:14:23 <allbery_b> well, ghci / ghc -e does
07:14:24 <oerjan> at least in ghci
07:14:37 <LoganCapaldo> perl -e '{ package Foo; ...}' my $foo = new Foo; ... " I want to meet the programmer that does that
07:14:38 <b_jonas> no, no instance of 'package' where I create a class with it
07:14:54 <b_jonas> but as I've said, it would just be functions in both perl and ruby
07:15:08 <LoganCapaldo> it can be just functions in Haskell too :)
07:15:13 <b_jonas> sort of
07:15:20 <LoganCapaldo> no really :)
07:15:28 <b_jonas> but you can't create a tree from arrays
07:15:42 <b_jonas> now I'll really have to search for such a one-liner
07:15:44 <LoganCapaldo> No but you can create a tree from functions :)
07:15:58 <b_jonas> would that not lead to circular types?
07:16:12 <LoganCapaldo> well you still need newtype I think
07:16:22 <oerjan> not if you use those cata-/anamorphisms
07:16:26 <b_jonas> can you newtype a function?
07:16:30 <LoganCapaldo> sure
07:16:33 <b_jonas> wow
07:16:33 <LoganCapaldo> @src State
07:16:34 <lambdabot> Source not found. You speak an infinite deal of nothing
07:16:45 <b_jonas> well it would work that way then
07:16:58 <LoganCapaldo> newtype State s a = State (\s -> (a, s))
07:17:19 <b_jonas> and how can you use newtype in a -e ?
07:17:23 <b_jonas> you can't put it in a let
07:17:29 <oerjan> you cannot
07:17:30 <LoganCapaldo> I don't think you can
07:17:33 <Saizan> LoganCapaldo: lambda /= type :)
07:17:35 <b_jonas> (quite obviously, because there are no lexical types in haskell)
07:18:00 <LoganCapaldo> Saizan: I'm just trying to cause trouble :)
07:21:12 * SamB_XP wonders about DSP compilers and Haskell...
07:21:41 <LoganCapaldo> @go DSP Haskell
07:21:44 <lambdabot> http://haskelldsp.sourceforge.net/doc/index.html
07:22:19 <wli> SamB_XP: I wonder about IA64 and Haskell (or perhaps that should be a "what if?" or similar).
07:22:32 <LoganCapaldo> @go IA64 Haskell
07:22:34 <lambdabot> http://qa.debian.org/debcheck.php?dist=sid&package=haskell-haskell-src
07:22:34 <lambdabot> Title: Debian Quality Assurance -- debcheck
07:22:46 <LoganCapaldo> that one seems less relevant
07:23:42 <wli> Fancy codegen for Haskell on IA64 is probably not closely related to Debian packaging considerations.
07:24:55 <LoganCapaldo> wli: let me know if you come up with anything
07:25:21 <wli> I'm pretty sure nothing ever happened.
07:25:33 <LoganCapaldo> sad face
07:31:55 <b_jonas> I'm still looking over my bash_history
07:32:07 <opqdonut> wget porn.avi
07:32:14 <b_jonas> and so far it seems that lists and tuples and maybes are enough for everything
07:32:57 <b_jonas> this one has hashes too but that's not enough
07:33:41 <b_jonas> are tuples Ord by default?
07:33:51 <oerjan> Data.Map gives you that, although qualifying everything may be a pain
07:33:56 <oerjan> certainly
07:33:58 <LoganCapaldo> > (1, 2) < (3, 4)
07:34:01 <lambdabot>  True
07:34:02 <b_jonas> good
07:34:06 <opqdonut> b_jonas: at least if you import something
07:34:08 <LoganCapaldo> @instances Ord
07:34:09 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
07:34:19 <oklopol> will that calculate the lenght of the vector and compare that or??
07:34:21 <oklopol> *-?
07:34:27 <opqdonut> @instances-importin Control.Monad.Instances Ord
07:34:29 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
07:34:32 <oerjan> Ord for tuples is in the Prelude, i'm sure
07:34:34 <opqdonut> oklopol: dictionary order
07:34:41 <oklopol> ah
07:34:50 <oklopol> so you can do
07:34:56 <oklopol> > (1,2,3) > (43,4)
07:34:56 <lambdabot>  Couldn't match expected type `(t, t1, t2)'
07:34:58 <opqdonut> > (2,0) < (1,1)
07:34:59 <oklopol> oh
07:35:00 <lambdabot>  False
07:35:09 <opqdonut> > (1,2) < (1,1)
07:35:10 <oerjan> which happens to be the default derived order
07:35:11 <lambdabot>  False
07:35:22 <LoganCapaldo> > lookup [("a", 1), ("b", 2)] "a" -- probably ok for many uses of hashes
07:35:24 <lambdabot>  Couldn't match expected type `([([Char], t)], b)'
07:35:27 <opqdonut> oklopol: only between tuples of same type
07:35:45 <byorgey> oklopol: you can do that with lists, though
07:35:51 <blazzy> i've installed cabal with and without --user. both times i've seen Distribution.Program get built. yet I keep getting  "Could not find module `Distribution.Simple.Program':"
07:35:51 <oklopol> ah
07:35:53 <byorgey> > [1,2,3] > [43,4]
07:35:55 <lambdabot>  False
07:35:59 <blazzy> any idea what I'm missing?
07:36:04 <LoganCapaldo> > lookup "a" [("a", 1), ("b", 2)] -- probably ok for many uses of hashes
07:36:06 <lambdabot>  Just 1
07:36:06 <oklopol> should've known
07:36:14 <oerjan> oh wait - there isn't some flag to import that you can add to -e ?
07:36:18 <LoganCapaldo> *-+
07:36:20 <b_jonas> I couldn't find a one-liner that builds trees
07:36:22 <b_jonas> pity
07:36:56 <byorgey> b_jonas: what kind of trees are you trying to build?
07:38:39 <blazzy> oh, heh distribuiton.program is not the same as distribution.simple.program. i kept mentally inserting the simple in their
07:39:26 <b_jonas> I don't want to, I was just wondering whether haskell -e is good for one-liners
07:39:36 <b_jonas> but as I never use trees in one-liners, it seems it's enough
07:39:37 <oerjan> apparently you can add a source file to load first to the ghc -e command
07:39:56 <oerjan> *list of source files
07:40:03 <b_jonas> if you do, that doesn't count as a one-liner anymore
07:40:22 <oerjan> well if you list only builtin modules...
07:40:33 <oerjan> it's just to replace import statements
07:40:45 <oerjan> (or could be)
07:41:20 <b_jonas> oh sure, in that case it's ok
07:41:22 <LoganCapaldo> could just edit the local prelude to include more imports ;)
07:41:35 <b_jonas> I didn't know that was the same switch
07:41:55 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/modes.html#eval-mode
07:41:57 <lambdabot> Title: 4.4. Modes of operation, http://tinyurl.com/28f8aj
07:42:16 <b_jonas> LoganCapaldo: ouch. that would be two sins at once
07:42:42 <b_jonas> changing the default environment of the language is one, and namespace pollution is another
07:43:24 <LoganCapaldo> its not any (additional) namespace pollution if you use import qualified
07:43:49 <oklopol> > [1,2]*[3,4]
07:43:52 <b_jonas> but if you add them to the local prelude, then how do you decide what to import to the namespace?
07:43:56 <lambdabot>   add an instance declaration for (Num [t])
07:43:56 <lambdabot>     In the expression: [1, 2] * [...
07:44:03 <b_jonas> oh, you mean
07:44:13 <b_jonas> you import every name only qualified?
07:44:13 <oklopol> can that be overridden to mean cartesian product?
07:44:18 <oklopol> hmm
07:44:30 <LoganCapaldo> oklopol: not cartesian product
07:44:35 <oklopol> err
07:44:37 <LoganCapaldo> @type (*)
07:44:40 <lambdabot> forall a. (Num a) => a -> a -> a
07:44:49 <b_jonas> use another operator?
07:44:53 <opqdonut> liftM2 (*) [1,2] [3,4]
07:44:56 <opqdonut> > liftM2 (*) [1,2] [3,4]
07:45:01 <lambdabot>  [3,4,6,8]
07:45:04 <LoganCapaldo> since the result would havea different type han the inputs
07:45:10 <opqdonut> you mean that?
07:45:28 <shachaf> > liftM2 (,) [1,2] [3,4]
07:45:30 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
07:45:34 <oklopol> opqdonut: yes
07:45:43 <byorgey> > sequence [[1,2], [3,4]]
07:45:44 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
07:45:48 <LoganCapaldo> > [(x,y) | x <- [1,2], y <- [3,4] ]
07:45:49 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
07:46:03 <oklopol> > let a*b = liftM2 (,) a b in [1,2,3]*[3,4,5]
07:46:04 <lambdabot>  [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
07:47:04 <LoganCapaldo> > let (*) = liftM2 (,) in [1,2,3] * [3,4,5]
07:47:06 <lambdabot>  [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
07:52:08 <kpreid> I think Haskell ought to allow `(...)`
07:52:20 <b_jonas> that reminds me to the question about perl "why cannot for iterate on multiple lists?"
07:52:39 <b_jonas> which is so ambiguous because there are more then one ways to iterate on them
07:52:40 <kjdf> what is that "fptools" that lambdabot would like to have?
07:52:49 <b_jonas> I think it wasn't even the actual questoin
07:52:56 <b_jonas> that was more ambiguous than this
07:52:57 <scook0> kpreid: there's potential for much trouble when the subexpression gets complicated
07:53:09 <kpreid> scook0: that's why the parens
07:53:15 <b_jonas> I think it was "can I use multiple iteration variables in a for loop?"
07:53:16 <opqdonut> and many different suggestions for the syntax
07:53:26 <chessguy> @type liftM
07:53:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:53:39 <b_jonas> that too
07:53:45 <kpreid> [1,2,3] `(liftM2 (,))` [4,5,6]
07:53:49 <Saizan> what do you mean with (...)?
07:53:55 <chessguy> @pl \p -> l n (f p)
07:53:56 <lambdabot> l n . f
07:54:03 <scook0> kpreid: I'm thinking from a human-readability perspective
07:54:06 <b_jonas> hmm
07:54:09 <Saizan> ah, now i see
07:54:25 <scook0> though there's always the "well, don't do stupid stuff with it then" counterargument
07:54:27 <LoganCapaldo> -: ... :-
07:54:41 <LoganCapaldo> no wait
07:54:48 <LoganCapaldo> you can't use colons
07:54:49 <b_jonas> reversed
07:54:52 <b_jonas> :- ... -:
07:54:54 <LoganCapaldo> -| ... |-
07:54:56 <b_jonas> you can that way
07:55:04 <b_jonas> oh wait you can't
07:55:09 <b_jonas> yes you can
07:55:13 <b_jonas> :- -: would work
07:55:38 <b_jonas> because it would parse as (lhs :- funct) -: rhs
07:55:46 <b_jonas> and -: could act on the data type :- created
07:55:55 <b_jonas> unless one of those operators are used for something else
07:55:59 <LoganCapaldo> oh yuo want to do it with a ta type
07:56:01 <kpreid> @hoogle :-
07:56:01 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':-'
07:56:06 <kpreid> @hoogle -:
07:56:06 <lambdabot> hoogle: unrecognized option `-:'
07:56:06 <lambdabot> HOOGLE - Haskell API Search
07:56:06 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
07:56:06 <lambdabot>  
07:56:06 <lambdabot> Usage: hoogle [OPTION...] search
07:56:08 <lambdabot> [15 @more lines]
07:56:13 <kpreid> ook
07:56:21 <byorgey> hehe
07:56:21 <b_jonas> @t (-:)
07:56:21 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:56:24 <b_jonas> :t (-:)
07:56:25 <lambdabot> Not in scope: `-:'
07:56:28 <b_jonas> :t (:-)
07:56:29 <lambdabot> Not in scope: data constructor `:-'
07:56:37 <opqdonut> hehe, smiely
07:56:44 * scook0 (:[])
07:56:45 <LoganCapaldo> it doesn't have to be a data type
07:56:49 <oklopol> > let :- == 5 in :-
07:56:50 <lambdabot>  Parse error
07:56:51 <opqdonut> i think somebody actually had a -: :- proposal
07:56:51 <LoganCapaldo> -| nd |- can both be function
07:56:53 <opqdonut> datatype based
07:57:07 <mrd> > fix (0:)
07:57:08 <LoganCapaldo> and I can't find that paste to save my life
07:57:11 <b_jonas> but then you'll also want an operator meaning (flip $)
07:57:11 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:57:13 <opqdonut> but yeah, a functional approach works too
07:57:14 <LoganCapaldo> its really hard to search for -|
07:57:28 <opqdonut> b_jonas: how so?
07:57:40 <b_jonas> so you can apply something as postfix, not infix
07:58:23 <b_jonas> mathematica in fact has some such operators: f[x], f@x, and x//f are all equivalently functoin calls
07:58:27 <b_jonas> with different precedences
07:58:35 <b_jonas> and there's infix x~f~y
07:58:45 <opqdonut> let f = (+1) in (1 `f`)
07:58:55 <opqdonut> > let f = (+1) in (1 `f`)
07:58:56 <lambdabot>  2
07:59:04 <opqdonut> that's postfix for you :)
07:59:49 <opqdonut> > let (!) a = product [1..a] in (20 !)
07:59:51 <lambdabot>  2432902008176640000
07:59:53 <opqdonut> :)
08:00:14 <shachaf> > let (|>) = flip ($); f = (+1) in 1 |> f
08:00:15 <lambdabot>  2
08:00:22 <opqdonut> :))
08:00:29 <chessguy> @type \b t f = b >>= \bool -> if' bool t f
08:00:30 <lambdabot> parse error on input `='
08:00:38 <chessguy> @type \b t f -> b >>= \bool -> if' bool t f
08:00:40 <lambdabot> Not in scope: `if''
08:00:51 <opqdonut> > let  = flip ($); f = (+1) in 1  f
08:00:52 <lambdabot>  Illegal character ''\162''
08:00:54 <opqdonut> bah
08:00:56 <opqdonut> :)
08:00:57 <LoganCapaldo> >>= in idenity ;)
08:01:04 <shachaf> if' bool t f?
08:01:08 <chessguy> @type \b t f -> b >>= \bool -> if bool then t else f
08:01:10 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
08:01:24 <byorgey> if' b t f = if b then t else f
08:01:29 <opqdonut> isnyeah
08:01:34 <byorgey> it's a common idiom although not in the standard libraries
08:01:34 <opqdonut> liftM3 if'
08:01:36 <shachaf> Yes, never mind.
08:01:43 <chessguy> @type \b t f -> b >>= \bool -> return $ if bool then t else f
08:01:45 <lambdabot> forall a (m :: * -> *). (Monad m) => m Bool -> a -> a -> m a
08:02:30 <chessguy> ermm, i don't want to end up with a monadic result
08:02:35 <byorgey> actually, I'm really not sure why Haskell has if as part of the syntax
08:03:08 <kpreid> because if/then/else make pretty parens?
08:03:22 <chessguy> actually, i can't remember why i was trying to define this function, lol
08:03:23 <byorgey> chessguy: well, if you use >>= then you have to.
08:03:33 <byorgey> :t (>>=)
08:03:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:04:06 <chessguy> that's what i get for dropping a project completely for a week or two
08:04:19 <byorgey> chessguy: hehe
08:04:42 <byorgey> chessguy: is this your chess engine?
08:04:55 <chessguy> yeah
08:05:05 <byorgey> cool
08:05:29 <byorgey> maybe I should try writing a Go engine...
08:05:39 <chessguy> i'm hoping to get it running in time to get it crushed in a tournament that's coming up :)
08:06:18 <byorgey> sweet!
08:06:29 <chessguy> my schedule is not cooperating though
08:08:30 <chessguy> let takeWhile' _ _ [] = []; takeWhile' p p' (x:xs) | p  x = x : takeWhile' p p' xs; takeWhile' p p' (x:xs) | p' x      = [x]; takeWhile' p p' (x:xs) | otherwise = []
08:08:33 <chessguy> @let takeWhile' _ _ [] = []; takeWhile' p p' (x:xs) | p  x = x : takeWhile' p p' xs; takeWhile' p p' (x:xs) | p' x      = [x]; takeWhile' p p' (x:xs) | otherwise = []
08:08:39 <lambdabot> Defined.
08:08:41 * byorgey gives chessguy's schedule a stern talking-to
08:08:48 <chessguy> @type liftM takeWhile'
08:08:50 <lambdabot> Not in scope: `takeWhile''
08:09:01 <chessguy> @type liftM L.takeWhile'
08:09:03 <lambdabot> Couldn't find qualified module.
08:09:09 * chessguy sighs
08:09:33 <byorgey> unfortunately, @let and @type do not talk to each other =P
08:09:45 <chessguy> @undefine
08:09:47 <lambdabot> Undefined.
08:10:58 <twanvl> ?type let takeWhile' _ _ [] = []; takeWhile' p p' (x:xs) | p  x = x : takeWhile' p p' xs; takeWhile' p p' (x:xs) | p' x      = [x]; takeWhile' p p' (x:xs) | otherwise = [] in liftM takeWhile'
08:11:00 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ((a -> Bool) -> [a] -> [a])
08:11:35 <chessguy> eww
08:11:39 <chessguy> not what i wanted
08:11:54 <byorgey> chessguy: what did you want?
08:12:05 <byorgey> rather, what is the type of what you want?
08:12:23 <chessguy> well takeWhile' is :: (a -> Bool) -> (a -> Bool) -> [a] -> [a]
08:12:28 <byorgey> right
08:13:03 <oklopol> hmm
08:13:21 <oklopol> > takeWhile (\x -> x<3) [1,2,3,3,4,5]
08:13:22 <lambdabot>  [1,2]
08:13:25 <chessguy> but i want a function to that takes takeWhile' and returns a function of type (a -> m Bool) -> (a -> m Bool) -> [a] -> [a]
08:13:48 <byorgey> chessguy: you can't
08:13:51 <chessguy> err
08:13:55 <chessguy> but i want a function to that takes takeWhile' and returns a function of type (a -> m Bool) -> (a -> m Bool) -> [a] -> m [a]
08:14:01 <byorgey> oh, ok =)
08:14:03 <hoelzro> you want a monadic version of takeWhile?
08:14:30 <chessguy> not quite. i want the almost-monadic version of takeWhile'
08:14:37 <chessguy> (which is different from takeWhile
08:14:42 <hoelzro> got it
08:14:47 <SamB> Cale: what did you use to illustrate http://haskell.org/arrows/syntax.html ?
08:14:47 <lambdabot> Title: Arrow syntax
08:14:58 <twanvl> Why 'almost' monadic?
08:15:10 <byorgey> chessguy: hm, I'm not sure there's a nice combinator to transform takeWhile' into takeWhileM'
08:15:25 <chessguy> twanvl, well the last input isn't monaic
08:15:26 <Saizan> chessguy: you've to rewrite it monadically
08:15:28 <chessguy> monadic
08:16:05 <chessguy> i think it would be like liftM3 otherwise
08:16:10 <chessguy> @type liftM3
08:16:12 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
08:16:26 <oklopol> umm... what's LiftM3?
08:16:30 <oklopol> *liftM3
08:16:34 <Saizan> there's no way to transofrm a -> m Bool to a -> Bool without knowing how to exit from m
08:16:37 <b_jonas> opqdonut: owever, if you had a postfix function call operator like x $~ f = f x, you could use it for infix like x $~ f $ y
08:16:55 <chessguy> Saizan, no, i'm going the other way
08:17:05 <chessguy> transforming a -> Bool to a -> m Bool
08:17:10 <twanvl> There is no general function ((a -> b) -> c) -> (a -> m b) -> m c
08:17:20 <byorgey> oklopol: see the type above.  It's for "threading" a pure function a -> b -> c -> d over three monadic values
08:17:37 <LoganCapaldo> @type (== 3)
08:17:39 <lambdabot> forall a. (Num a) => a -> Bool
08:17:41 <kjdf> chessguy: maybe try foldrM from data.foldable
08:17:50 <LoganCapaldo> @type return . (== 3)
08:17:52 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => a -> m Bool
08:17:56 <chessguy> basically i want (a -> b -> c -> d) -> m a -> m b -> c -> m d
08:17:59 <chessguy> or something
08:18:05 <LoganCapaldo> I jsut went from a -> Bool to a -> m Boll ;)
08:18:12 * LoganCapaldo ducks
08:18:14 <byorgey> chessguy: not quite.  you said you wanted (a -> m Bool), not m (a -> Bool)
08:18:16 <Saizan> chessguy: if you want to write takeWhileM' using takeWhile' you're accepting a (a -> m Bool) parameter and want to give a (a -> Bool) one to takeWhile'
08:18:24 <chessguy> oh, right
08:18:30 <chessguy> ugh
08:18:40 <chessguy> well this just sucks
08:19:00 <twanvl> You could do it if you evaluate all the function on all elements beforehand
08:19:01 <Saizan> ?src filterM
08:19:01 <lambdabot> Source not found. Take a stress pill and think things over.
08:19:04 <byorgey> chessguy: it shouldn't be too hard to write it from scratch though?
08:19:10 <byorgey> without using takeWhile'
08:19:18 <chessguy> probably not
08:19:29 <hoelzro> could you do something like this: takeWhileM' a b c d = _takeWhileM' a b (return c) d where _takeWhileM' = liftM3 takeWhile'
08:20:23 <chessguy> hoelzro, except it's actually not liftM3, as byorgey pointed out
08:20:28 <Saizan> hoelzro: that would give takeWhileM' :: m (a -> Bool) -> etc.
08:20:28 <chessguy> my mistake
08:20:36 <hoelzro> oh ok
08:20:53 <hoelzro> <- very new to Haskell
08:20:59 <chessguy> hoelzro, that thought did cross my mind though
08:21:08 <chessguy> hoelzro, then you're doing very well :)
08:21:12 <hoelzro> =D thanks
08:21:13 <byorgey> hoelzro: welcome =)
08:21:22 <chessguy> i've been at it for like a year, and i'm still so clueless
08:26:03 <hpaste>  (anonymous) pasted "takeWhileM'" at http://hpaste.org/2759
08:26:16 <byorgey> I think that works? ^^
08:27:00 <hoelzro> has anyone here had trouble building GHC 6.6.1 on GNU/Linux AMD64?
08:27:04 <byorgey> not the prettiest thing ever, but... =)
08:27:33 <allbery_b> hoelzro: it's known broken, I think
08:27:38 <byorgey> hoelzro: if I recall correctly, wli was having trouble with that
08:27:47 <byorgey> @seen wli
08:27:47 <lambdabot> wli is in #haskell. I last heard wli speak 1h 2m 26s ago.
08:27:51 <allbery_b> not just linxu either, when I checked the other day freebsd amd64 was disabled in ports
08:27:56 <hoelzro> damn
08:28:00 <hoelzro> I want to build pugs!
08:28:49 <oklopol> @seen oklopol
08:28:50 <lambdabot> You are in #haskell. I last heard you speak just now.
08:29:15 <byorgey> @seen lambdabot
08:29:15 <lambdabot> Yes, I'm here. I'm in #bioclipse, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc
08:29:15 <lambdabot> and #darcs
08:29:44 <chessguy> very nice, byorgey!
08:29:50 <chessguy> works perfectly
08:29:52 <chessguy> byorgey++
08:30:02 <byorgey> glad to help! =)
08:30:27 <hoelzro> byorgey++ is a destructive update, though...
08:30:39 <chessguy> oops :)
08:33:47 <oklopol> > 0
08:33:49 <lambdabot>  0
08:37:36 <chessguy> @type gets
08:37:38 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
08:40:05 <chessguy> @pl \p -> f p == t s
08:40:06 <lambdabot> (t s ==) . f
08:41:05 <oklopol> > (\x -> 2 * x) == (\x -> x * 2)
08:41:06 <lambdabot>   add an instance declaration for (Eq (t -> t))
08:41:06 <lambdabot>     In the expression: (\ x -...
08:41:08 <oklopol> :P
08:41:31 <oklopol> haskell should add support for that... we need more superturing @ it!
08:41:55 <Saizan> oklopol: are you going to be the oracle?:)
08:41:57 <LoganCapaldo> @check (\x -> x * 2 == 2 * x) :: Integer -> Bool
08:42:02 <lambdabot>  OK, passed 500 tests.
08:42:10 <LoganCapaldo> I'm satisfied :)
08:42:46 <byorgey> oklopol: look up QuickCheck =)
08:43:32 <oklopol> hmm
08:43:44 <oklopol> can you do that with a function?
08:43:58 <byorgey> oklopol: sure
08:44:02 <oklopol> i mean, like > check (* 2) == (2 *)
08:44:08 <oklopol> > check (* 2) == (2 *)
08:44:09 <lambdabot>   Not in scope: `check'
08:44:16 <byorgey> oklopol: that's basically what LoganCapaldo did
08:44:23 <oklopol> > QuickCheck.check (* 2) == (2 *)
08:44:24 <lambdabot>   Not in scope: `QuickCheck.check'
08:44:30 <LoganCapaldo> it's not a function
08:44:32 <LoganCapaldo> it' a command
08:44:34 <oklopol> no it isn't, he used a lambdabot command
08:44:38 <LoganCapaldo> @check
08:44:39 <lambdabot>  quickcheck: <stdin>: hGetLine: end of file
08:44:52 <byorgey> oh, sorry, I see what you are asking
08:45:04 <chessguy> @pl \s -> m p (b s)
08:45:04 <lambdabot> m p . b
08:45:05 <byorgey> @type Test.QuickCheck.check
08:45:07 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Test.QuickCheck.Config -> a -> IO ()
08:45:10 <byorgey> @type Test.QuickCheck.test
08:45:12 <lambdabot> forall a. (Test.QuickCheck.Testable a) => a -> IO ()
08:45:14 <oklopol> hmm...
08:45:28 <oklopol> actually, i guess i could easily write that function myself.
08:45:32 <oklopol> actually not
08:45:34 <byorgey> lambdabot's @check command is basically an interface to the Test.QuickCheck.test function
08:45:48 <oklopol> but you can't access that?
08:45:58 <oklopol> how does that module make up the random values?
08:46:03 <oklopol> hmm
08:46:03 <oerjan> it's not imported by lambdabot's >
08:46:07 <LoganCapaldo> @check let feq f g = \x -> f x == g x in ((2 *) `feq` (* 2)) :: Integer -> Bool
08:46:09 <lambdabot>  OK, passed 500 tests.
08:46:12 <oerjan> typeclasses
08:46:15 <chessguy> @pl \p -> g (m p . b)
08:46:15 <lambdabot> g . (. b) . m
08:46:22 <chessguy> heh
08:46:27 <byorgey> oklopol: I suggest you go read about it, it's quite nifty
08:46:30 <byorgey> @where quickcheck
08:46:30 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
08:46:32 <oklopol> heh
08:46:40 <b_jonas> @pl flip id
08:46:41 <lambdabot> flip id
08:46:54 <oerjan> @unpl flip id
08:46:54 <byorgey> the random values come from the Random monad
08:46:55 <lambdabot> (\ b c -> c b)
08:47:29 <opqdonut> isn't it Arbitary and not random?
08:47:31 <opqdonut> *Random
08:47:56 <LoganCapaldo> Arbitrary is the class your types need to beinstances of
08:47:56 <byorgey> opqdonut: Arbitrary is the type class for which QC can generate random instances, but the randomness comes from Random
08:47:59 <oklopol> but... how can you get enough access to the type to find out what a random value in it should be?
08:48:03 <oerjan> Random is not a monad, strangely enough
08:48:21 <LoganCapaldo> oklopol: instance Arbitrary Foo where ...
08:48:22 <b_jonas> @pl \b c -> c b
08:48:22 <lambdabot> flip id
08:48:24 <oerjan> oklopol: there is a typeclass with instances for many types
08:48:24 <allbery_b> oklopol: that's what Arbitrary does
08:48:24 <EvilTerran> hm... okay, my copy of GHC 6.6.1 came without GLUT. my friend's copy came with GLUT. what's going on here?
08:48:47 <byorgey> oerjan: hm... good point
08:49:03 <byorgey> you're right, it's all in IO, isn't it?
08:49:08 <arcatan> I~ made` you` a` GLUT~ but` then` I~ eated` it
08:49:12 <oerjan> no, there is also a pure interface
08:49:23 <byorgey> hm
08:49:25 <oerjan> it's just not monadic, but passes generators explicitly
08:49:34 <LoganCapaldo> I've definitely seena  Random monad floating around out there too
08:49:37 * byorgey needs to go read up on Random again
08:49:38 <allbery_b> Random is State-friendly but doesn't require it
08:49:38 <oerjan> it could easily be wrapped into a State monad
08:49:44 <allbery_b> there's a Random monad on he wiki
08:50:09 <EvilTerran> you okay over there, arcatan?
08:50:22 <petekaz> What's the easiest way to map over a single list 2-elements at a time?
08:50:50 <chessguy> petekaz, ooh, there was just a discussion on -cafe about this
08:50:54 <mrd> a,b b,c c,d or a,b c,d e,f?
08:51:00 <petekaz> okay, I'll search for it.
08:51:11 <petekaz> mrd: a,b c,d e,f
08:51:16 <allbery_b> <arcatan> there's` something` wrong` with` spacebar,` as` you` can` see,` and` the` right` arrow` also` does` something` weird
08:51:20 <oerjan> too bad, the other way is much easier
08:51:25 <allbery_b> (in -blah)
08:51:38 <EvilTerran> hm. drink spill?
08:51:42 <mrd> > takeWhile (not . null) $ iterate (drop 2) [1..6]
08:51:43 <arcatan> indeed
08:51:44 <lambdabot>  [[1,2,3,4,5,6],[3,4,5,6],[5,6]]
08:51:47 <allbery_b> ice tea, I gther
08:51:53 <mrd> > map (take 2) . takeWhile (not . null) $ iterate (drop 2) [1..6]
08:51:54 <lambdabot>  [[1,2],[3,4],[5,6]]
08:52:28 <mrd> > map (take 2) . takeWhile (not . null) $ iterate (drop 2) [1..7]
08:52:29 <lambdabot>  [[1,2],[3,4],[5,6],[7]]
08:52:36 <petekaz> mrd: thanks.
08:54:22 * byorgey goes off to work on grad school applications
08:54:59 <mrd> it's Sept 15th!
08:55:17 <mrd> the floodgates are opened
08:55:25 <oklopol> > (.)
08:55:26 <lambdabot>  Add a type signature
08:55:34 <oerjan> :t (.)
08:55:36 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:55:56 <oklopol> > (.) :: ((Int -> Int) -> (Int -> Int) -> (Int -> Int -> Int))
08:55:57 <lambdabot>  Couldn't match expected type `Int -> Int'
08:56:00 <oklopol> hmm :P
08:56:10 <oklopol> can't i just have the actual function?
08:56:13 <oklopol> > (+ 5)
08:56:15 <lambdabot>  <Integer -> Integer>
08:56:18 <oklopol> like that
08:56:24 <mrd> you have it
08:56:31 <allbery_b> that's only doable for non-polymorphic functions
08:56:37 <EvilTerran> the result of @run can't be polymorphic
08:56:50 <mrd> (.) is in your grasp, under your command!
08:56:51 <oklopol> i see, even if i make the type explicit? :\
08:56:58 <allbery_b> you did it wrong
08:57:03 <EvilTerran> > (.) :: (Int -> Int) -> (Int -> Int) -> (Int -> Int)
08:57:04 <oklopol> most likely i did.
08:57:05 <lambdabot>  <(Int -> Int) -> (Int -> Int) -> Int -> Int>
08:57:08 <oklopol> oh
08:57:15 <oklopol> oh indeed
08:57:22 <oklopol> but i was close! :)
08:57:59 <oerjan> @djinn (a->a)->(a->a)->(a->a->a)
08:58:00 <lambdabot> f a _ b _ = a b
08:58:03 <chessguy> that reminds me
08:58:06 <chessguy> @let takeWhile' _ _ [] = []; takeWhile' p p' (x:xs) | p  x = x : takeWhile' p p' xs; takeWhile' p p' (x:xs) | p' x      = [x]; takeWhile' p p' (x:xs) | otherwise = []
08:58:06 <allbery_b> the typechecker doesn't do "close" :)
08:58:08 <lambdabot> Defined.
08:58:09 <oklopol> > (..) (\x -> 1) (\y -> 2) (\z -> 3)
08:58:09 <lambdabot>  Parse error
08:58:17 <chessguy> > liftM3 takeWhile'
08:58:18 <lambdabot>  Add a type signature
08:58:38 <oerjan> hoogle tries to do close
08:59:26 <oerjan> @pl \f g h -> f.g.h
08:59:27 <lambdabot> (. (.)) . (.) . (.)
08:59:31 <allbery_b> > (.) (\x->1) (\y->2) 3
08:59:33 <lambdabot>  1
08:59:42 <LoganCapaldo> yah it only took me forever but
08:59:43 <oerjan> eek
08:59:44 <LoganCapaldo> > unfoldr (\ys -> if null ys then Nothing else Just (take 2 ys, drop 2 ys) ) [1..6]
08:59:46 <lambdabot>  [[1,2],[3,4],[5,6]]
09:00:00 <hpaste>  Saizan annotated "takeWhileM'" with "CPS to rule them all" at http://hpaste.org/2759#a1
09:01:44 <hpaste>  (anonymous) annotated "takeWhileM'" with "(no title)" at http://hpaste.org/2759#a2
09:05:17 <chessguy> what the heck is caseM?
09:05:19 <chessguy> @type caseM
09:05:21 <lambdabot> Not in scope: `caseM'
09:05:23 <chessguy> @hoogle caseM
09:05:24 <lambdabot> No matches found
09:06:07 <byorgey> chessguy: it's defined there in the paste
09:06:20 <chessguy> oh, haha
09:07:38 <chessguy> hm, doesn't typecheck
09:09:25 <oklopol> "<-" is like demonadify?
09:09:42 <opqdonut> "<-" is  like "run action and bind return value
09:09:43 <opqdonut> "
09:09:46 <oklopol> oh
09:09:53 * oklopol sucks at guessing
09:10:31 <Saizan> do x <- m; ... === m >>= \x -> ...
09:10:41 * LoganCapaldo doesn't think "<-" makes sense by itself
09:11:12 <chessguy> ah, monomorphism restriction problem
09:11:23 <chessguy> (i think)
09:11:42 <hpaste>  chessguy annotated "takeWhileM'" with "need to specify this" at http://hpaste.org/2759#a3
09:11:50 <LoganCapaldo> iow, you need saizan's ... for it to make sense
09:13:12 <hpaste>  EvilTerran annotated "takeWhileM'" with "what I call takeWhileM" at http://hpaste.org/2759#a4
09:13:37 <LoganCapaldo> @undo do { x <- a; b }
09:13:38 <lambdabot> (a >>= \ x -> b)
09:13:45 <LoganCapaldo> @undo do { x <- a }
09:13:46 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 41}) "Parse error"
09:14:07 <EvilTerran> dunno if that's relevant, but meh.
09:14:24 <EvilTerran> LoganCapaldo, the last line in a do{} block has to be an expression
09:14:25 <chessguy> @pl \b -> if' b v $ caseM pvs
09:14:25 <lambdabot> ($ caseM pvs) . flip if' v
09:14:32 <LoganCapaldo> EvilTerran: my point
09:14:48 <EvilTerran> or, to quote ghci, <interactive>:1:3: The last statement in a 'do' construct must be an expression
09:14:59 <opqdonut> ?quote ghc
09:14:59 <lambdabot> ghc says:  This is very gruesome indeed
09:15:00 <opqdonut> :))
09:15:02 <EvilTerran> oh, okay. ignore me, i should read more scrollback first
09:15:03 <SamB> @hoogle unsafeCoerce
09:15:07 <lambdabot> No matches found
09:15:13 <EvilTerran> ghc said that at one point?
09:15:30 <EvilTerran> awesome
09:16:45 <hpaste>  chessguy annotated "takeWhileM'" with "caseM somewhat simplified" at http://hpaste.org/2759#a5
09:19:07 <Saizan> ?pl k x ms _ = p x >>= \b -> if' b ms (return [])
09:19:07 <lambdabot> k = (const .) . (. flip (flip . flip if') (return [])) . (>>=) . p
09:19:51 <chessguy> heh
09:21:24 <chessguy> @unpl k = (const .) . (. flip (flip . flip if') (return [])) . (>>=) . p
09:21:24 <lambdabot> k o ab _ = (p o) >>= \ h -> if' h ab (return [])
09:22:27 <Saizan> i just realized m >>= \b -> if b then t else f is quite different from liftM3 if' m t f
09:22:49 <chessguy> indeed
09:23:18 <chessguy> @type liftM3 (if ?m then ?t else ?f)
09:23:24 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (?m::Bool, ?t::a1 -> a2 -> a3 -> r, ?f::a1 -> a2 -> a3 -> r, Monad m) => m a1 -> m a2 -> m a3 -> m r
09:23:32 <chessguy> @type ?m >>= \b -> if b then ?t else ?f
09:23:34 <lambdabot> forall (m :: * -> *) b. (?m::m Bool, ?t::m b, ?f::m b, Monad m) => m b
09:26:36 <chessguy> @pl r p d = t v (i (+d) (p+d))
09:26:36 <lambdabot> r = (t v .) . liftM2 i (+) . (+)
09:27:15 <chessguy> wow
09:27:20 <chessguy> that's almost sensible
09:28:17 <chessguy> @pl r p d = t v (i (+d) p)
09:28:18 <lambdabot> r = (t v .) . flip (i . (+))
09:37:13 <sclv> i'm trying to make yi and keep getting errors such as:
09:37:15 <sclv> Yi/Vty.hs:18:14: Not in scope: `setBold'
09:38:17 <chessguy> whee, 4 undefined functions left
09:38:32 <Paczesiowa> can someone explain to me why this code "main = getArgs >>= print . length . ( !! 0)" gives 2 for every non ascii character? shouldn't Char represent real unicode char?
09:38:42 <sclv> any ideas?
09:38:59 <byorgey> Paczesiowa: unfortunately, it doesn't.
09:39:29 <norpan> Paczesiowa: it does
09:39:58 <Paczesiowa> now I'm confused:>
09:40:02 <norpan> but the IO functions mess it up
09:40:02 <LoganCapaldo> print . length . head
09:40:04 <byorgey> ?  me too =)
09:40:16 <blazzy> sclv: you aren't getting errors before that? about not being able to find vty modules?
09:40:19 <allbery_b> the Char type represents Unicode but the GHC libs don't handle Unicode
09:40:39 <byorgey> ah, now I get it
09:40:43 <allbery_b> (or indeed any multibyte encoding)
09:40:44 <sclv> hmmm trying a make clean now
09:41:42 <Liskni_si> works in hugs
09:42:05 <blazzy> sclv: if not, you might be using an outdated version. http://members.cox.net/stefanor/#toc10
09:42:06 <lambdabot> Title: Stefan O'Rear's page
09:42:58 <hpaste>  twanvl annotated "takeWhileM'" with "caseM is not a good primitive" at http://hpaste.org/2759#a6
09:43:05 <sclv> make clean didn't help -- i thought i pulled the latest from darcs
09:43:09 <Paczesiowa> my real problem is with hxt's readDocument, when I read some html file (with correctly set encoding) I can write it with writeDocument, but I can't do anything interesting when internal nodes contain tgis garbage
09:45:18 <EvilTerran> if i want to uninstall a version of GHC on 'doze, just deleting it's okay, yeah?
09:45:35 <EvilTerran> it doesn't leave detritus in other folders/the registry/whatever, right?
09:45:41 <chessguy> twanvl, "not good" in what sense?
09:45:51 <EvilTerran> oh, wait, here's an uninstaller.
09:45:53 <EvilTerran> nvm.
09:46:40 <twanvl> chessguy: In the sense that separating the alternatives with an operator is better
09:47:10 <chessguy> err
09:47:19 <chessguy> you're kind of begging the question, aren't you?
09:47:48 <blazzy> sclv: i successuflly compiled with 3.0. Although I'm failing on the linker step.
09:47:58 <chessguy> twanvl, i'm not disagreeing, just trying to understand
09:48:01 <EvilTerran> chessguy, i guess an infix operator is more "primative" than a list consumer that can be expressed in terms of it
09:48:05 <sclv> it was an outdated vty alright
09:48:24 <sclv> i don't really feel like installing all of gtk on my tiger machine for the other interface tho.
09:48:31 <chessguy> ok, so the issue is that caseM was tied to a list
09:49:29 <chessguy> @type (<$>)
09:49:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:50:13 <chessguy> oh, a generalized liftM
09:50:15 <chessguy> ?
09:50:24 <byorgey> it's fmap
09:50:25 <SamB> wow. what a crazy type error:
09:50:33 <SamB> Modules/MyST.hs:49:27:
09:50:33 <SamB>     Couldn't match expected type `ST'
09:50:33 <SamB>            against inferred type `.' (a rigid variable)
09:50:33 <SamB>       `.' is bound by the type signature for `runST'
09:50:44 <chessguy> haha
09:50:46 <byorgey> which would be the same as liftM, if all Monads were Functors as they should be
09:51:11 <byorgey> <$> is from Applicative
09:51:18 <chessguy> ok
09:51:35 <SamB> apparantly GHC thinks that . counts as a type variable when higher-order types aren't enabled?
09:52:28 <byorgey> SamB: haha, you mean you have something like forall a . blah blah, and it thinks the . is a type?
09:52:39 <SamB> byorgey: precisely!
09:52:42 <byorgey> weird
09:54:09 <EvilTerran> I guess that works.
09:54:51 <EvilTerran> pure :: Arrow (.) => (a -> b) -> a . b; etc
09:56:12 <SamB> EvilTerran: should it?
09:56:28 <SamB> is that Haskell 98?
09:56:39 <EvilTerran> ... I think it's an -fglasgow-exts
09:56:50 <SamB> yes but I hadn't enabled any extensions!
09:57:44 <chessguy> @type foldl'
09:57:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:58:29 <Paczesiowa> allbery_b: are those ghc libs going to support unicode? I think it should be top priority in 21st century...
09:58:52 <allbery_b> dunno, ask the ghc folks
10:00:24 <Paczesiowa> allbery_b: do they hang out here on #haskell? because I'm scared of those maillists
10:00:39 <allbery_b> most of them do, yes
10:01:22 <Saizan> Paczesiowa: are you having a problem with HXT and encodings? it worked fine for me with utf-8
10:01:26 <sclv> @src lookup
10:01:26 <lambdabot> lookup _key []          =  Nothing
10:01:27 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
10:01:27 <lambdabot>                         | otherwise = lookup key xys
10:02:21 <allbery_b> there's also http://hackage.haskell.org/trac/ghc
10:03:16 <Saizan> ?hackage utf8-string
10:03:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
10:04:22 <chessguy> :t execState
10:04:24 <lambdabot> forall s a. State s a -> s -> s
10:06:26 * LoganCapaldo thinks execState and evalState should be swapped
10:06:36 <Paczesiowa> Saizan: I need arrow which reads html file and returns text from one of the nodes but text contains those weird \123\456 combinations (I can print them using putStrLn or writeDocument, but I can't manipulate them in this state)
10:06:47 <LoganCapaldo> actually they'd still have lousy names
10:06:58 * allbery_b thinks execState and evalState make sense as is
10:07:17 <allbery_b> execute a state-modifying operation and evaluate an expression with a given state
10:07:34 <LoganCapaldo> evaluat the State of a given expression
10:07:43 <LoganCapaldo> is how I keep reading evalState
10:08:24 <LoganCapaldo> maybe evalWithState
10:08:33 <LoganCapaldo> its a personal problem
10:08:37 * LoganCapaldo shrug
10:09:22 <Paczesiowa> allbery_b: I'm scared of anything that's not irc or forum. everything else isn't noobfriendly, there are too many smart people and every noob like me is scared to say something stupid
10:11:06 <shachaf> Paczesiowa: haskell-cafe is friendly.
10:11:21 <EvilTerran> Paczesiowa, the UTF8-to-characters transformation is fairly straightforward, iirc. it shouldn't be too hard to roll a transformer yourself if needs be, also
10:11:53 <Saizan> but \465 is not an utf8 codepoint, is it?
10:12:24 <Saizan> s/codepoint/whatever is called/
10:12:41 <SamB> utf8 hasn't codepoints
10:12:48 <SamB> they belong to unicode
10:12:52 <Saizan> yeah
10:13:26 <Saizan> > chr 123
10:13:31 <lambdabot>  '{'
10:13:31 <Paczesiowa> that was just an example
10:13:51 <Paczesiowa> chr 243
10:13:58 <Paczesiowa> > chr 243
10:13:59 <lambdabot>  '\243'
10:15:12 <Paczesiowa> > chr \195\179
10:15:12 <lambdabot>  Parse error
10:15:23 <Paczesiowa> that should be ó
10:17:41 <Saizan> Paczesiowa: have you tried passing (a_encoding,utf8) in the list of options to readDocument?
10:17:46 * Heffalump wonders what happened to the generation of 6.8 release candidates yesterday
10:18:13 <der_eq> may I use this opportunity to shamelessly promote my own library http://code.haskell.org/encoding/ that handles not only UTF-8 but a whole lot of other common encodings? :D
10:18:14 <lambdabot> Title: Index of /encoding
10:18:29 <Paczesiowa> Saizan: I parse it as iso8859_2 because it has this encoding in meta tag (and I confirmed it with good old school hexeditor)
10:20:10 <Saizan> Paczesiowa: are you sure the document is not mixing encodings?
10:20:37 <chessguy> @pl parseBoard fen state = foldl' place state fen
10:20:38 <lambdabot> parseBoard = flip (foldl' place)
10:22:13 <Paczesiowa> I'm sure. besides my simpler example "main = getArgs >>= print . length . ( !! 0)" hax exactly the same problem: characters are correctly read and correctly written (with putStrLn) they just have wrong form
10:24:18 <Saizan> yeah but HXT should convert to proper Unicode
10:24:34 <chessguy> is there a better way to say s{c = (f c s)}
10:24:49 <chessguy> err
10:24:51 <chessguy> f (c s)
10:25:06 * SamB wonders how to use Lava now that he's got it build/loading
10:25:17 <LoganCapaldo> carefully
10:25:23 <LoganCapaldo> It's hot :)
10:25:47 <chessguy> @quote hot
10:25:48 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
10:25:48 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
10:26:06 <oklopol> > let o 0 = 0; o n = o (n - 1) in o 9
10:26:08 <lambdabot>  0
10:27:19 <cognominal_> how do I quick benchmarking from ghci?
10:27:44 <chessguy> "i can has benchmarking?"
10:28:12 <cognominal_> oops
10:28:23 <cognominal_> how can I do  quick benchmarking from ghci?
10:28:58 <chessguy> cognominal_, yes, english is a silly language :)
10:29:03 <cognominal_> I am messy with irc, and I am not a native speaker. and I am a haskell beginner
10:29:17 <cognominal_> and I prefer go to chess :)
10:29:25 <chessguy> hey now
10:30:13 <LoganCapaldo> Where's the lazy version of lolcode?
10:30:26 <chessguy> @go lolcode lazy
10:30:29 <lambdabot> http://icanhascheezburger.com/tag/lolcode/
10:30:29 <lambdabot> Title: lolcode  I CAN HAS CHEEZBURGER?
10:31:52 <LoganCapaldo> that's the regular strict evaluation version isn't it? :)
10:32:33 <chessguy> i'm sure i wouldn't know
10:33:45 <Cale> cognominal_: :set +s
10:34:23 <Cale> cognominal_: thereafter, ghci will print time and (raw) allocation statistics for every expression you enter
10:35:38 <LoganCapaldo> once again cale reveals a ghci secret
10:35:39 <SamB> what is a sequent?
10:35:50 <LoganCapaldo> Cale++
10:36:09 <Cale> http://en.wikipedia.org/wiki/Sequent_calculus
10:36:10 <lambdabot> Title: Sequent calculus - Wikipedia, the free encyclopedia
10:36:47 <Cale> It's something of the form  A |- B where |- means "proves" or "yields"
10:37:06 <Cale> and A and B are sequences of logical formulae
10:37:28 <chessguy> wheeee, down to 2 undefined's
10:37:46 <oklopol> i can't make a case expression where only some of the cases lead to recursion?
10:37:53 <oklopol> do i have to make a type for that?
10:38:01 <Cale> oklopol: hm? Sure you can.
10:38:14 <Cale> oklopol: You just have to make sure that all the branches have the same type.
10:38:45 <Cale> So the recursive call you make has to eventually return something of the same type as the thing you return in the nonrecursive cases.
10:39:00 <EvilTerran> corecursion!
10:39:11 * EvilTerran will stop obfuscating now
10:39:28 <SamB> what has that got to do with this:
10:39:37 <SamB> class Functor s => Sequent s where
10:39:37 <SamB>   sequent :: Monad m => s (m a) -> m (s a)
10:39:55 <oklopol> hmm... i think i just have an error or smth
10:40:48 * EvilTerran tries to work out where he got his GHC 6.6.1 MSI that didn't come with GLUT
10:40:57 <Cale> SamB: Oh, that would be a completely different sense.
10:41:08 <EvilTerran> must've been off the comlab website, i guess.
10:41:09 <Cale> SamB: That looks like Traversable
10:41:15 <oklopol> whoops, was matching [x:xs] instead of (x:xs)
10:41:34 <Cale> SamB: sequent there has a generalisation of the type for sequence
10:41:54 <SamB> yeah
10:42:02 <Cale> And is basically the same thing as Data.Traversable.Sequence
10:42:05 <Cale> er
10:42:10 <Cale> Data.Traversable.sequence
10:42:16 <Cale> :t Data.Traversable.sequence
10:42:18 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
10:42:26 <Cale> heh
10:42:27 <SamB> Traversable has 3 other methods though
10:42:30 <Cale> right
10:45:58 <oklopol> but i do have to make a type to get access to a tree?
10:46:16 <oklopol> or is there a generic one for lists in prelude?
10:46:30 <chessguy> @docs Data.Tree
10:46:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
10:46:38 <Saizan> a generic tree for lists?
10:46:58 <Cale> oklopol: A tree for lists?
10:47:04 <oklopol> so i can do [1,2,[],3], was what i meant
10:47:11 <Cale> oh, no you can't do that
10:47:12 <oklopol> that was very badly said, i realize that :)
10:47:22 <EvilTerran> the closest we've got is Data.Tree, i think.
10:47:27 <Cale> because that would mean that 1 had the same type as []
10:47:27 <ricky_clarkson> HList can do that, I think.
10:47:33 <chessguy> but you can do [[1],[2],[],[3]]
10:47:33 <oklopol> you can't get that syntax anyway? damn
10:47:34 <Cale> which it probably doesn't :)
10:47:45 <oklopol> doesn't help, i need arbitrarily recursive
10:47:51 <oklopol> eh
10:47:53 <ricky_clarkson> oklopol: Tuples?
10:47:56 <Cale> Lists are lists, to get a tree, you need a separate datatype
10:47:57 <oklopol> arbitrarily nested...
10:47:58 <ricky_clarkson> (1,2,[],3)
10:47:59 <EvilTerran> oklopol, Data.Tree is the way to go, i think
10:48:00 <P_D> Int 1 | List [a]
10:48:08 <chessguy> instance Num [a] anyone?
10:48:16 <ricky_clarkson> (1,2,(3,(4,[],5)))
10:48:34 <chessguy> ricky_clarkson, tuples are awful
10:48:34 <EvilTerran> aren't tuples (and HList) slightly restricted in what you can actually do with 'em at runtime?
10:48:44 <EvilTerran> chessguy, i've got one of those...
10:49:20 <sclv> yipe!
10:49:21 <EvilTerran> well, instance Num [Int]. i needed laziness in the higher digits.
10:49:23 <sclv> yi: unable to load package `readline-1.0'
10:49:42 <sclv> due to "/usr/local/lib/ghc-6.6.1/HSreadline.o: unknown symbol `_rl_insert_completions'
10:49:43 <sclv> "
10:49:48 <oklopol> i made a bf interpreter, and just when i add the final nesting support, i realize it doesn't work that way in haskell :)
10:49:58 <sclv> does this mean I need to upgrade ghc to do yi?
10:50:15 <ricky_clarkson> oklopol: Can you make a list of Eithers?
10:50:50 <oklopol> [1,1,1,1,1,1,1,1,[3,1,1,1,1,1,1,1,1,2,0],3,1,4] <<< wanna convert that for me?
10:50:52 <oklopol> :)
10:51:03 <omniscientIdiot> @ty [Left 1, Left 2, Right [Left 3, Right []], Left 4]
10:51:05 <lambdabot> forall t t1 a. (Num t1, Num t) => [Either t [Either t1 [a]]]
10:51:11 <SamB> oklopol: data BFInst = Incr | Decr | Next | Prev | GetC | PutC | Loop [BFInst]
10:51:49 <oklopol> SamB: then i'd need to make a parser too
10:51:55 <SamB> heh
10:51:57 <SamB> that
10:52:03 <SamB> is not hard ;-)
10:52:07 <omniscientIdiot> Parsec is GOD.
10:52:08 <oklopol> not hard, but not trivial.
10:52:14 <oklopol> since i don't know haskell
10:52:20 <SamB> it is almost trivial
10:52:36 <oklopol> i know it is, but i'm a bit afraid of it :P
10:52:36 <omniscientIdiot> Dive in!
10:52:41 <oklopol> i know, but i was going for a 1 min lambdabot program...
10:53:00 <LoganCapaldo> Parsec makes parsing (even more) fun!
10:53:00 * EvilTerran would probably do something involving composing functions together, one for each of the BF operators
10:53:01 <EvilTerran> probably get list zippers involved
10:53:02 <oklopol> i can't dive in, i need to get into physics in 10 min! :P
10:53:28 <SamB> oklopol: surely you could do it later
10:53:30 <chessguy> @pl \b -> r s (c s t (r t b)))
10:53:30 <lambdabot> (line 1, column 26):
10:53:30 <lambdabot> unexpected ")"
10:53:30 <lambdabot> expecting variable, "(", operator or end of input
10:53:31 <EvilTerran> incidentally, is there any particular reason why parsec is restricted to Strings?
10:53:35 <oklopol> but i'll gladly append a parsec tutorial on my TODO list :)
10:53:36 <chessguy> @pl \b -> r s (c s t (r t b))
10:53:36 <lambdabot> r s . c s t . r t
10:53:37 <SamB> also what kind of crazy school do you go to ?
10:53:40 <SamB> it's saturday!
10:53:45 <oklopol> me?
10:53:53 <LoganCapaldo> On this side of the international date line anyway
10:53:56 <EvilTerran> it seems to me that making it work on Eq a => [a], say, would be more useful
10:53:56 <oklopol> i have my matriculation exam on physics on monday
10:54:06 <monochrom> Parsec is restricted to [tok] for all type tok.
10:54:11 <oklopol> i love using that term since no one knows it.
10:54:12 <SamB> EvilTerran: on t'other, it's sunday!
10:54:18 <xerox> monochrom: not anymore !
10:54:26 <EvilTerran> SamB, I'm not LoganCapaldo
10:54:29 <omniscientIdiot> @ty let tr '+' = [1]; tr '>' = 2; tr '[' = []; tr ']' = 3 in concatMap tr "+++>+++++[-]"
10:54:31 <lambdabot> forall b. (Num b, Num [b]) => [b]
10:54:34 <LoganCapaldo> Not yet, anyway
10:54:37 <LoganCapaldo> Bwahahahahahaha
10:54:47 <monochrom> xerox: what is the new restriction?
10:54:49 * LoganCapaldo conceals his tranformation potion
10:54:52 <SamB> EvilTerran: oh. how did I do THAT one?
10:55:05 <monochrom> Oh! It's [tok] or ByteString?
10:55:08 <xerox> monochrom: class Stream s t | s -> t where uncons :: s -> (t,s)
10:55:20 <EvilTerran> monochrom, ah, yes, so it is. i've been looking at the Parser type, so overlooked GenParser etcetc
10:55:29 <monochrom> OK nice! Now tell that to EvilTerran please :)
10:55:33 <EvilTerran> i see it
10:55:33 <SamB> monochrom: presumably there's a class involved
10:55:51 <EvilTerran> is this duncan's streams?
10:56:08 <monochrom> Excellent! Now Oleg's inversion trick applies...
10:56:09 <xerox> EvilTerran: nope.
10:56:18 <EvilTerran> aw.
10:56:40 <LoganCapaldo> the type of uncons looks like State
10:56:49 <SamB> @where parsec
10:56:49 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
10:56:56 <monochrom> the type of uncons looks like zipper
10:57:08 <chessguy> @pl remove pos board = if' (M.member pos board) (M.delete pos board) board
10:57:08 * EvilTerran was speculating to duncan at AngloHaskell that streams might make a good general interface for linear container types
10:57:08 <lambdabot> remove = join . ap (ap . ((if' . (M .)) .) . member) (((M .) .) . delete)
10:57:12 <chessguy> epe
10:57:14 <chessguy> eep
10:57:21 <LoganCapaldo> monochrom: quiet you. i'm only a level 0 :)
10:57:21 <Saizan> ?type (head &&& tail)
10:57:23 <lambdabot> forall a. [a] -> (a, [a])
10:57:35 <ricky_clarkson> :type (&&&)
10:57:51 <oklopol> :t (&&&)
10:57:53 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:58:24 <EvilTerran> remove pos = liftM3 if' (member pos) (delete pos) id
11:00:02 <omniscientIdiot> The pointy version is readable.  No need to change.
11:00:07 <EvilTerran> remove = ($id) . liftM3 . liftM2 (if' member delete)
11:00:09 <EvilTerran> er, i think.
11:00:20 <EvilTerran> ?type \pos board = if' (M.member pos board) (M.delete pos board) board
11:00:22 <lambdabot> parse error on input `='
11:00:23 <EvilTerran> ?type \pos board -> if' (M.member pos board) (M.delete pos board) board
11:00:24 <lambdabot> Couldn't find qualified module.
11:00:30 <EvilTerran> ?type \pos board -> if' (member pos board) (delete pos board) board
11:00:32 <lambdabot> Not in scope: `if''
11:00:32 <lambdabot>  
11:00:32 <lambdabot> <interactive>:1:19: Not in scope: `member'
11:00:36 <EvilTerran> bah. never mind.
11:01:28 <chessguy_> @type \p -> liftM3 $ if (?m p) (?d p) id
11:01:29 <lambdabot> parse error (possibly incorrect indentation)
11:01:43 <monochrom> s -> (t,s) is still not as convenient as s -> m (t,s) for monadic m.
11:01:50 <chessguy_> @type \p -> liftM3 $ if (?m p) then (?d p) else id
11:01:51 <lambdabot> forall a2 a3 r (m :: * -> *) t. (Monad m, ?m::t -> Bool, ?d::t -> (a2 -> a3 -> r) -> a2 -> a3 -> r) => t -> m (a2 -> a3 -> r) -> m a2 -> m a3 -> m r
11:02:10 <EvilTerran> \o/
11:02:33 <chessguy_> ...
11:02:41 <SamB> xerox: your patches seem stuck in http://darcs.haskell.org/~paolo/darcs/parsec
11:02:42 <chessguy_> that doesn't look right to me
11:02:43 <lambdabot> Title: Index of /~paolo/darcs/parsec
11:03:04 <omniscientIdiot> chessguy_: I'd just keep it pointy, unless you like obfuscation.
11:03:35 <chessguy> omniscientIdiot, i don't like obfuscation, i was just looking for an easier way
11:05:33 <xerox> SamB: that doesn't work.
11:05:58 <SamB> xerox: oh. where's the one that works?
11:05:59 <omniscientIdiot> looking back at the original @pl, it looks like it thinks M is a constructor function.
11:06:00 <xerox> SamB: I'm working on a new release, parsec 3, somewhere soon (-:
11:06:10 <omniscientIdiot> @pl remove pos board = if' (M_member pos board) (M_delete pos board) board
11:06:10 <lambdabot> remove = join . ap (ap . (if' .) . M_member) M_delete
11:06:43 <xerox> Should at least write some documentation before releasing it.
11:06:58 <omniscientIdiot> you'll need those (confusing) aps if you want to duplicate arguments.
11:07:13 <chessguy> oh, whoops
11:07:24 <chessguy> still not nice
11:07:30 <DRMacIver> Can I mix record style accessors with normal data definitions?
11:07:42 <DRMacIver> I have a datatype with multiple constructors, all of the form Foo -> (other stuff). Is there any way to extract that first Foo from them without writing the obvious boring code.
11:07:57 <SamB> xerox: I suppose so ;-)
11:08:44 <SamB> xerox: but you could, uh, have a darcs repo somewhere...
11:09:02 <monochrom> Like data Baa = Foo { foo :: Int } | Poo Double ?
11:09:35 <monochrom> foo (Poo 1.0) will be a runtime error, but no type error
11:09:44 <monochrom> foo (Foo 1) will work.
11:10:55 <DRMacIver> More like data baa = Foo { foo :: Int } | Bar { foo :: Int } String
11:11:11 <chessguy> @hoogle [m [a]] -> m [a]
11:11:15 <lambdabot> No matches, try a more general search
11:11:54 <monochrom> That is not allowed. But this is allowed. data Baa = Foo { foo :: Int } Bar { foo :: Int, uselessname :: String }
11:12:03 <monochrom> I forgot | there.
11:12:22 <DRMacIver> Hm.
11:12:26 <DRMacIver> Ok. Thanks.
11:12:28 <Botje> :t return . concat . sequence
11:12:32 <Arnia> Hm. In the Grammatical Framework I've created an application grammar (basic) for my system. I load it with gr, and it compiles fine. I then try and parse, and it recognises none of the nouns, and generate and it gives me this error: 'no nonrecursive refinements available for BareClass'
11:12:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[a]] -> m [a]
11:12:44 <monochrom> Then foo (Foo 1) and foo (Bar 1 "x') both works.
11:13:07 <DRMacIver> Thanks.
11:13:09 <chessguy> Botje, not quite
11:13:27 <Arnia> Any idea how to interpret that? BareClass is declared with cat BareClass and there is one function; Bare : BareClass -> AtomicClass to coerce it
11:13:35 <omniscientIdiot> @type fmap concat . sequence
11:13:37 <lambdabot> forall a (m :: * -> *). (Functor m, Monad m) => [m [a]] -> m [a]
11:13:40 <DRMacIver> I think I'll just write the boring code. :)
11:13:57 <chessguy> aha
11:14:23 <omniscientIdiot> > (fmap concat . sequence) [Just [1,2], Nothing, Just [3]]
11:14:25 <lambdabot>  Nothing
11:14:32 <omniscientIdiot> > (fmap concat . sequence) [Just [1,2], Just [3]]
11:14:33 <lambdabot>  Just [1,2,3]
11:16:06 <omniscientIdiot> sequence :: [m [a]] -> m [[a]], so you must concat inside the monad, via fmap
11:17:33 <EvilTerran> > foldM (liftM . (++)) [] [Just [1,2], Just [3]]
11:17:34 <lambdabot>  Just [1,2,3]
11:17:39 <EvilTerran> > foldM (liftM . (++)) [] [Just [1,2], Nothing, Just [3]]
11:17:40 <lambdabot>  Nothing
11:18:21 <omniscientIdiot> @src foldM
11:18:21 <lambdabot> foldM _ a []     = return a
11:18:21 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
11:18:53 <omniscientIdiot> seems somewhat like sequence
11:18:58 <omniscientIdiot> @src sequence
11:18:59 <lambdabot> sequence ms = foldr k (return []) ms
11:18:59 <lambdabot>     where
11:18:59 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
11:19:19 <mauke> k = liftM2 (:)
11:19:31 <EvilTerran> it's related, but it collapses down to any (m b) instead of (m [a])
11:19:36 <sorear> .
11:20:02 <EvilTerran> ?type foldM
11:20:04 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:20:17 <oerjan> ?type sequence
11:20:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:20:40 <EvilTerran> also, i think, if you write the function correctly, it's possible to not run every action in the list (if it's even a list of actions)
11:20:51 <DRMacIver> Hm. I think I need to work on my ability to adapt to a language's idioms.
11:21:11 <DRMacIver> Whatever language I like it seems like I'm trying to emulate other languages in it...
11:21:20 <omniscientIdiot> DRMacIver: comes with practice and lots of exposure.
11:21:34 <DRMacIver> No, I don't think so.
11:21:38 <QuietPurple> je parle francais comme une vache espagnol, you mean?
11:21:58 <omniscientIdiot> DRMacIver: the libs are filled with creamy goodness, if you don't know they exist, you can't use them.
11:22:05 <QuietPurple> i speak french like a spanish cow --- a french idiom :-)
11:22:28 <EvilTerran> heh. did your little finger tell you that? ;)
11:22:38 <DRMacIver> omniscientIdiot: My experience is that the more practice and exposure to a language I have, the better I get at forcing it obey my twisted whims, so my code actually becomes *less* idiomatic, not more. :)
11:22:40 <QuietPurple> ahh, you know that one too
11:22:41 <QuietPurple> !
11:22:46 <DRMacIver> And the libraries aren't really relevant here.
11:22:50 <omniscientIdiot> :)
11:23:15 <ddarius> DRMacIver: Start sending patches to a tightly controlled project.
11:23:20 <monochrom> People like to come up with opinions and speak up.
11:23:26 * EvilTerran is reminded of "you can write perl in any language if you try hard enough"
11:23:48 <ddarius> EvilTerran: Except for Perl apparently.
11:24:07 <DRMacIver> EvilTerran: It's not really that though. It's not like I have one language which I try to write all other languages in its image.
11:24:09 <EvilTerran> i stick to writing haskell in perl and perl in haskell ;]
11:24:24 <DRMacIver> EvilTerran: It's more like I try to write OO code in Haskell and do type hackery in Java. ;)
11:24:26 <omniscientIdiot> :O
11:24:53 <ddarius> DRMacIver: So clearly you want a language that you can do both in.
11:24:55 * omniscientIdiot imagines Haskellish perl
11:25:05 <ddarius> @google "Higher Order Perl"
11:25:06 <DRMacIver> ddarius: Definitely.
11:25:08 <lambdabot> http://hop.perl.plover.com/
11:25:08 <lambdabot> Title: Higher-Order Perl
11:25:15 <oerjan> "You can write FORTRAN in any language"
11:25:20 <ddarius> DRMacIver: I wish Neel had kept working on Needle.
11:25:33 <DRMacIver> ddarius: There's a reason I want Haskell to have first class modules. :)
11:25:52 <ddarius> DRMacIver: Subtyping is really the main thing Haskell is missing.
11:25:57 <EvilTerran> i think in the end it boils down to "you can write any language in any language"
11:25:57 <QuietPurple> i've a haskell problem, if anyone can help
11:25:58 <DRMacIver> And a reason I find (the core of) Scala very appealing.
11:26:07 <mauke> QuietPurple: just ask
11:26:11 <DRMacIver> ddarius: Yes. I'd like subtyping too. :) With multiple dispatch obviously.
11:26:16 <QuietPurple> i have an error message: invalid type signature
11:26:21 <ddarius> DRMacIver: Look at Needle and weep.
11:26:29 <EvilTerran> @paste -- let's see the type signature
11:26:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:26:32 <omniscientIdiot> paste here if 1 or 2 lines, hpaste if more
11:26:39 <chessguy> @pl \f a b c -> f c a b
11:26:40 <lambdabot> (flip .) . flip
11:26:45 <monochrom> The error message is probably telling the complete truth.
11:26:47 <ddarius> ... it should only be one or two lines...
11:26:48 <QuietPurple> it seems not to like (Double, Double) -> [(Double, Double)]
11:26:53 <DRMacIver> ddarius: I look at Nice and weep too.
11:26:57 <EvilTerran> toil and trouble!
11:27:03 <QuietPurple> yes
11:27:09 <mauke> QuietPurple: that looks ok
11:27:11 <ddarius> DRMacIver: Nice is not as nice and Needle would've been in my opinion.
11:27:13 <DRMacIver> (Although needle is closer to what I want)
11:27:17 <oerjan> QuietPurple: perfectly valid type under the right circumstances.
11:27:19 <QuietPurple> maybe it is scared of the 'scottish play' effect
11:27:23 <wli> What's Needle?
11:27:26 <DRMacIver> ddarius: Yeah, But I've actually used Nice. :)
11:27:31 <ddarius> QuietPurple: Check the lines around it.
11:27:36 <oerjan> @paste
11:27:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:27:36 <wli> And Nice, for that matter.
11:27:39 <omniscientIdiot> QuietPurple: put your code on the hpaste link above.
11:27:43 <ddarius> @google Needle programming language
11:27:45 <lambdabot> http://lambda-the-ultimate.org/classic/message5270.html
11:27:45 <lambdabot> Title: LtU Classic Archives
11:27:49 <wli> These things aren't quite googlable.
11:27:52 <ddarius> @google Nice programming language
11:27:54 <lambdabot> http://nice.sourceforge.net/
11:28:05 <DRMacIver> wli: Hybrid functional OO languages.
11:28:06 <EvilTerran> haskell's a nice programming language!
11:28:30 <ddarius> wli: Those are both accurate hits.
11:28:43 <QuietPurple> juliaStep :: (Double, Double) -> (Double, Double) -> (Double, Double)
11:28:50 <ddarius> More specifically for Needle, http://www.nongnu.org/needle/
11:28:52 <lambdabot> Title: Needle, An Object-Oriented Functional Language
11:28:59 <QuietPurple> juliaStep (x,y) (c1,c2) = (x^2 - y^2 + c1, 2*x*y + c2)
11:29:09 <omniscientIdiot> @ty (^)
11:29:14 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:29:16 <QuietPurple> Iterations :: (Double, Double) -> [(Double, Double)
11:29:20 <omniscientIdiot> @ty (**)
11:29:22 <lambdabot> forall a. (Floating a) => a -> a -> a
11:29:26 <EvilTerran> missing [ there, QuietPurple?
11:29:29 <QuietPurple> Iterations (c1,c2) = foldl (\(x,y) -> \a -> juliaStep (x,y) (c1,c2)) (0,0) [1..]
11:29:29 <EvilTerran> ], even
11:29:37 <ddarius> Iterations can't be a function name
11:29:51 <omniscientIdiot> you need (**) for Doubles.
11:29:52 <mauke> Uppercase is for constants, lowercase for variables
11:29:53 <QuietPurple> sorry, the ] is there in the file
11:29:55 <EvilTerran> ah... yeah, that too. values gotta start with a small letter
11:29:56 <mauke> omniscientIdiot: no.
11:30:00 <omniscientIdiot> oh?
11:30:05 <mauke> > pi ^ 2
11:30:07 <lambdabot>  9.869604401089358
11:30:11 <EvilTerran> ?type (^)
11:30:13 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:30:15 <omniscientIdiot> nvm then
11:30:17 <QuietPurple> ok, i've made it lower case
11:30:20 <EvilTerran> @src (^)
11:30:20 <lambdabot> Source not found. stty: unknown mode: doofus
11:30:32 <QuietPurple> will that solve it?
11:30:56 <EvilTerran> the error you got's a bit peculiar, mind, but that should be enough. we can't be sure unless you paste everything, tho, but see if that works.
11:31:08 <wli> I'm not sure you can get subtyping atop constructor classes in any decidable fashion.
11:31:24 <oerjan> omniscientIdiot: you need ** only if the _second_ argument is Double
11:31:32 <EvilTerran> ?type (**)
11:31:34 <lambdabot> forall a. (Floating a) => a -> a -> a
11:31:44 <mauke> @type (^^)
11:31:47 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:31:52 * omniscientIdiot points at the second part of his nick.
11:31:57 <EvilTerran> ?type (^^) -- and the happy japanese emoticon, for good measure
11:31:59 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:32:09 <DRMacIver> wli: It's not that hard. The constructors become types in their own right and multiple dispatch selects among them.
11:32:24 <oerjan> omniscientIdiot: got all cases covered, eh? :)
11:32:28 <QuietPurple> it's now giving a different error
11:32:30 <omniscientIdiot> :D
11:32:32 <DRMacIver> wli: The problem is type inference.
11:32:44 <QuietPurple> can't match expected against inferred
11:32:57 <EvilTerran> @paste -- let's see the whole thing (and the error), QuietPurple. we can give you style advice while we're at it. ;]
11:32:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:33:08 <oerjan> QuietPurple: right, now it _parses_ correctly and has got to the typing part
11:33:28 <QuietPurple> sorry, how do i use the paste bin?
11:33:32 <wli> Yes, I needed to say something about type inference there.
11:33:40 <EvilTerran> follow that link (http://hpaste.org/new), paste your code in
11:33:45 <monochrom> Sometimes this community is too helpful. So helpful that askers will never learn how to efficiently ask.
11:33:57 <EvilTerran> put in your nick and a title, make sure "announce" is checked, and click [paste].
11:34:44 <hpaste>  QuietPurple pasted "(no title)" at http://hpaste.org/2760
11:35:34 <omniscientIdiot> foldl reduces it to a single pair, you might look into iterate
11:35:39 <oerjan> QuietPurple: remove \a ->
11:35:46 * chessguy] sighs
11:35:54 <QuietPurple> oh, i mean scanl !!!!!!!!
11:35:58 <QuietPurple> i am a doofus
11:36:00 <chessguy]> @hoogle [Bool] -> Bool
11:36:00 <lambdabot> Prelude.and :: [Bool] -> Bool
11:36:00 <lambdabot> Prelude.or :: [Bool] -> Bool
11:36:02 <EvilTerran> "\(x,y) -> \a -> ..." = "\(x,y) a -> ...", btw
11:36:19 <QuietPurple> *hit head repeatedly*
11:36:24 * omniscientIdiot punches the internet for chessguy
11:36:27 <EvilTerran> also, as omniscientIdiot suggests, iterate might be an appropriate function here
11:36:30 <wli> I think structural subtyping is far more interesting than aping OO.
11:36:40 <chessguy> it's not the internet, it's my wireless
11:36:59 * omniscientIdiot punches the internet anyway
11:37:00 <QuietPurple> i think that's it
11:37:11 <sorear> @go haskerl
11:37:14 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
11:37:14 <lambdabot> Title: The Haskerl index
11:37:20 <QuietPurple> sorry it was a silly question---i have to go for dinner anyway
11:37:21 <sorear> omniscientIdiot: ^^^
11:37:38 <oerjan> QuietPurple: anyone who has got to the point of wanting scanl cannot be a doofus
11:37:42 <EvilTerran> > iterate (\(x,y) -> (x^2 - y^2 + 0.1, 2*x*y + 0.1)) (0.1,0.1)
11:37:47 <lambdabot>  [(0.1,0.1),(0.1,0.12000000000000001),(9.56e-2,0.12400000000000001),(9.376336...
11:38:14 <QuietPurple> cool, that looks like what i want
11:38:15 * EvilTerran has no idea what the (0.1,0.1) julia set looks like, but apparently that one diverges...
11:38:19 <EvilTerran> ?type iterate
11:38:21 <lambdabot> forall a. (a -> a) -> a -> [a]
11:38:27 <QuietPurple> bye, anyway
11:38:30 <EvilTerran> > iterate (1:) []
11:38:32 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
11:38:38 <EvilTerran> oh, he's gone.
11:39:47 <idnar> > fix (1:)
11:39:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:40:20 <oerjan> > fix (([]:).map(1:))
11:40:22 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
11:40:42 <EvilTerran> > map (flip replicate 1) [0..]
11:40:44 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
11:40:54 <EvilTerran> > inits [1..]
11:40:56 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
11:41:01 <EvilTerran> > inits (repeat 1) -- rather
11:41:02 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
11:41:08 <oerjan> > inits [1,1..]
11:41:10 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
11:41:21 <idnar> heh
11:41:23 * monochrom giggles at "goferl"
11:41:55 <EvilTerran> hm. it shouldn't make a difference here, but am i right in thinking that (repeat 1) is constant memory, and [1,1..] is O(n) in how far you evaluate it?
11:41:56 <sorear> is omniscientIdiot still here?
11:42:05 <earnest> > iterate (1+) []
11:42:05 <lambdabot>   add an instance declaration for (Num [a])
11:42:13 <ddarius> EvilTerran: In practice, yes.
11:42:36 <sorear> EvilTerran: no, [1,1..] is often O(1) since the head can be garbage collected as the tail is forced :)
11:42:40 <omniscientIdiot> sorear: yep, taking a look.  Looks like the preliminary do-notation introduction?
11:42:56 <sorear> omniscientIdiot: actuallly, it's an april fools joke
11:43:18 <sorear> omniscientIdiot: the fact that it introduces do-notation is amusing, but it's not the motive
11:43:33 <monochrom> the do-notation was a hoax :)
11:43:40 <EvilTerran> sorear, but with mark-and-sweep GC like what GHC uses, that means the GC'll have to run more often
11:43:45 <EvilTerran> surely?
11:44:19 <oerjan> also, that doesn't work if you keep a reference to the start of [1,1..]
11:44:55 <sorear> EvilTerran: that doesn't increase asymptotic space or time
11:45:06 <EvilTerran> meh.
11:45:35 <monochrom> hopefully deforestation kicks in and helps
11:45:57 <EvilTerran> I find it a helpful excercise to consider that sort of thing, anyway.
11:46:01 <sorear> EvilTerran: besides, most of us don't have export GHCRTS=-c in our .$SHELLrc :)
11:46:16 <EvilTerran> what?
11:46:43 * EvilTerran is insufficiently familiar with GHC to know what that would do
11:46:55 <monochrom> methinks you should write .${SHELL}rc
11:47:18 <omniscientIdiot> *punch*
11:47:21 * EvilTerran finishes looking it up
11:47:21 <sorear> EvilTerran: ghc uses a copying collector unless you tell it not to
11:47:24 <monochrom> you forgot [ again, chessguy
11:47:30 <sorear> chessgy]:
11:47:31 <EvilTerran> okay, I was being informal when I said mark-and-sweep
11:47:47 <sorear> @quote cheeseguy
11:47:47 <EvilTerran> i meant as compared to, say, reference-counting
11:47:47 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
11:47:52 <sorear> aww
11:48:12 <monochrom> you had a typo
11:48:12 <omniscientIdiot> @quote chessguy
11:48:13 <lambdabot> chessguy says: lament, it takes a while to undiselegantize his code first
11:48:27 <chessguy> @quote cheese
11:48:28 <lambdabot> No quotes match. You speak an infinite deal of nothing
11:48:29 <sorear> monochrom: no I didn't
11:48:32 <monochrom> OTOH, cheese and broccoli sound related
11:48:39 <omniscientIdiot> undiselegantize++
11:48:48 <chessguy> hm. the cheese quote must have gotten lost
11:48:56 <omniscientIdiot> summary?
11:48:58 <sorear> ./07.04.19:10:54:02 <sjanssen> @remember cheeseguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
11:49:00 <EvilTerran> but i intended that to include copying-style GC, 'cos i'm too lazy to look up the term that encompasses both.
11:49:17 <monochrom> hahahahahhaa I see!
11:49:29 <sorear> @remember cheeseguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
11:49:29 <lambdabot> Done.
11:49:34 <sorear> @remember chessguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
11:49:34 <lambdabot> Done.
11:49:40 <omniscientIdiot> :O
11:49:45 <sorear> @remember chseesseeeguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
11:49:45 <lambdabot> Done.
11:49:55 <sorear> @remember cheesguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
11:49:56 <lambdabot> Done.
11:50:12 <sorear> and yes, it was @remember'd under all four names the first time
11:51:02 <omniscientIdiot> you misspelled chsesesseee
11:51:04 <monochrom> But you forgot chessguy_ and chessguy__
11:51:05 <ricky_clarkson> @quote sorear
11:51:06 <lambdabot> sorear says: -f flags are so 2006
11:51:09 <ricky_clarkson> @quote sorear
11:51:09 <lambdabot> sorear says: "Boredom breeds existential pondering"
11:51:59 <oerjan> sorear: @remember to always @flush, perhaps? (if that is what @flush does)
11:52:00 <omniscientIdiot> @remember chsesesseeeguy what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
11:52:00 <lambdabot> Done.
11:52:17 <omniscientIdiot> @quote @flush
11:52:17 <lambdabot> No quotes match. Do you think like you type?
11:52:34 <omniscientIdiot> @quote oerjan
11:52:34 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
11:52:55 <sorear> oerjan: @flush woks around the fact that lambdabot is broken and crashes constantly
11:53:18 <oerjan> why doesn't it occasionally autoflush? or does it?
11:53:54 * EvilTerran can has GLUT nao :D
11:53:58 <sorear> because nobody has bothered
11:54:13 <omniscientIdiot> @protontorpedo
11:54:13 <lambdabot> that dude is selling u  a book
11:54:57 <chessguy> @quote keal
11:54:58 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
11:55:00 <chessguy> @keal
11:55:00 <lambdabot> i still dont understand how gci is supposed to do anything other than mathematics
11:55:28 <oerjan> everything is mathematics!
11:55:38 <omniscientIdiot> nothing is mathematics!
11:55:45 <omniscientIdiot> War is peace!
11:55:46 <chessguy> same thing
11:57:01 <monochrom> Abstraction Is Strength
11:57:36 <chessguy> well, more generally, abstraction is power
11:57:37 <oerjan> Concrete Sets Under Water
12:00:07 <chessguy> hi dolio
12:00:48 * SamB wonders why Lava has Int signals and not, say, Integer signals...
12:01:16 <norpan> because it's hard to implement an infinite number of bits in hardware?
12:01:42 <SamB> or Word*/Int*...
12:01:55 <SamB> or something a little less, um, ambiguous...
12:02:37 <jatqceer> can i use `if then' withou the `else'?  Or is there something equivalent to that?
12:02:40 <monochrom> Laziness Is Speed. Duck Typing is Slavery. Abstraction Is Strength.
12:03:01 <monochrom> Or even...
12:03:04 <norpan> jatqceer: but what would the result be if the condition is not true?
12:03:04 <oerjan> jatqceer: when in monads
12:03:06 <monochrom> Laziness Is Speed. Duck Typing is Slavery. Abstract Nonsense Is Strength.
12:03:07 <SamB> monochrom: what does that have to do with Int?
12:03:24 <oerjan> :t when
12:03:27 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:03:42 <monochrom> I don't recall showing interest in discussing Int.
12:03:59 <jatqceer> norpan: so I always need the else return (), right?
12:04:09 <omniscientIdiot> @src when
12:04:09 <lambdabot> when p s = if p then s else return ()
12:04:16 <norpan> jatqceer: well, then you can use "when"
12:04:19 <sorear> jatqceer: what would 'if False then 2' evaluate to?
12:04:36 <omniscientIdiot> _|_  :)
12:04:45 <jatqceer> sorear: that's an interesting question
12:04:46 <norpan> i think monochrom shows interest in travesting scifi literature
12:05:06 <jatqceer> norpan: ah, i don't know there is the `when'
12:05:13 <omniscientIdiot> @index when
12:05:13 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:05:14 <norpan> jatqceer: it's for monads
12:05:39 <chessguy> norpan, all the good stuff is :)
12:05:56 <norpan> yeah, the yummy monad gooddies
12:06:06 * fasta doesn't like half-baked "domain specific languages" 
12:06:27 <norpan> hey, you're calling lava half-baked?
12:06:29 <jatqceer> chessguy: not, when you are frustrated...like me
12:06:32 <omniscientIdiot> so make sure you bake it all the way through :)
12:06:50 <fasta> norpan: I don't read logs before I enter a channel :)
12:06:54 <chessguy> jatqceer, heh. been there, done that, 1000 times over
12:06:58 <fasta> norpan: but probably it is :)
12:07:29 <jatqceer> chessguy: have you tried to rewrite some code in numerical recipes?
12:08:08 <fasta> norpan: "Lava is a tool to assist circuit designers in specifying, designing, verifying and implementing hardware. " <- does it have users that work in that industry?
12:08:32 <norpan> i have no idea :)
12:08:38 <fasta> Lava is an _experimental_ system design
12:08:46 <fasta> Right, so, it's half-baked
12:08:53 <fasta> I was talking about something else, btw.
12:08:57 <norpan> of course
12:13:17 <monochrom> In that case, I prefer experimental steak and lamb chops, i.e., cooked to medium.
12:13:39 <EvilTerran> what, so neither rare nor well done?
12:14:06 <monochrom> Right. I don't enjoy rare.
12:14:12 <EvilTerran> (Ambrose Bierce, on mediums)
12:17:30 <monochrom> @quote monochrom
12:17:30 <lambdabot> monochrom says: people ∩ haskellers = ∅
12:18:32 <EvilTerran> is that last character emptyset? it doesn't appear right here.
12:18:39 <monochrom> It is.
12:22:01 <EvilTerran> so... is there any implementation of GLUT that's still maintained?
12:22:45 <EvilTerran> the most recent update i can see is OpenGLUT's May '05
12:23:19 <EvilTerran> and that one's explicitly no longer maintained, leaving FreeGLUT at 2003 and the original GLUT at 2001
12:28:19 <jatqceer> how do you make a tuple of STUArray?  I mean, making a function's type to be (ST s (STUArray s Int Double), ST s (STUArray s Int Double)), while you are doing these Array operations in the function.  What should I do if I want two arrays to be returned?
12:29:01 <Lemmih> ST s (STUArray s Int Double, STUArray s Int Double) ?
12:31:36 <monochrom> You aren't supposed to leak arrays outside the ST monad. OTOH, inside, what Lemmih says.
12:31:39 <int-e> jatqceer: use runST and do freezeArray yourself
12:32:07 <int-e> err. just freeze.
12:32:26 <monochrom> @type freeze
12:32:28 <lambdabot> Not in scope: `freeze'
12:32:39 <int-e> @type Data.Array.Base.freeze
12:32:41 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *) (b :: * -> * -> *). (Data.Array.Base.IArray b e, Data.Array.Base.MArray a e m, Ix i) => a i e -> m (b i e)
12:32:45 <jatqceer> I want two arrays from "newArray_ (1, 10)" and "newArray_ (1, 20)", what should I do?
12:32:51 <Mr_Awesome> @pl \x -> f x && g x
12:32:51 <lambdabot> liftM2 (&&) f g
12:33:08 <monochrom> It may be much better if you give more contextual information.
12:33:56 <int-e> @src runSTArray
12:33:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:34:29 <jatqceer> If I do "a <- newArray_ (1, 10) ; b <- newArray_ (1, 20)", I want something like "return (a, b)"
12:34:35 <oerjan> :t runSTArray
12:34:37 <lambdabot> Not in scope: `runSTArray'
12:34:45 <int-e> runSTArray st = runST (st >>= unsafeFreezeSTArray)
12:35:02 <int-e> you just have to do the freezing of the arrays yourself
12:35:10 <Saizan> jatqceer: what's the problem with return (a,b)?
12:35:42 <jatqceer> Saizan: what is the type of return (a,b)?
12:35:51 <int-e> I think he's using runSTArray.
12:36:02 <int-e> or runSTUArray. one of these
12:36:14 <oerjan> :t Control.Monad.ST.runSTArray
12:36:16 <lambdabot> Not in scope: `Control.Monad.ST.runSTArray'
12:36:22 <monochrom> return (a,b)  results in what Lemmih says.
12:36:29 <int-e> :t Data.Array.ST.runSTUArray
12:36:31 <lambdabot> forall i e. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
12:36:36 <jatqceer> I don't want to freeze them because I want to use these two arrays in another function
12:36:51 <int-e> you have to freeze them to get them out of the ST monad.
12:37:11 <jatqceer> I don't want to get out of the ST monad
12:37:20 <monochrom> You can write the other function to stay in the same ST monad.
12:37:26 <int-e> ok. this is silly then, show code.
12:38:33 <monochrom> We don't say "this is silly. show code" often enough and early enough. Usually we say it ten minutes late.
12:38:52 <int-e> there's no problem at all with forming a tuple from ST(U)Arrays, so the problem must be something different.
12:39:07 <jatqceer> I think there are many problems in this code.  how and where do I paste code?
12:39:14 <Lemmih> ?paste
12:39:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:40:18 <hpaste>  jatqceer pasted "ludcmp" at http://hpaste.org/2761
12:41:13 <Lemmih> jatqceer: And what's the problem with that code?
12:41:21 <jatqceer> just a quick rewrite of the ludcmp in numeric recipes chapter 2-15
12:42:48 <jatqceer> in ghci, [1 of 1] Compiling MatrixOp         ( MatrixOp.hs, interpreted )
12:42:48 <jatqceer>  
12:42:48 <jatqceer> MatrixOp.hs:57:2:
12:42:48 <jatqceer>     The last statement in a 'do' construct must be an expression
12:42:51 <jatqceer> Failed, modules loaded: none.
12:42:54 <omniscientIdiot> Are you getting an error?  Click on the Annotate link and paste it.
12:43:19 <omniscientIdiot> which is line 57?
12:43:47 <jatqceer> the line starting with "  let crout _ ..."
12:44:02 <sclv> try "return crout 1 1 0 0" ?\
12:44:22 <Lemmih> sclv: 'crout' is an action.
12:44:26 <monochrom> don't try
12:44:37 <Lemmih> sclv: And 'return' is a normal function.
12:44:45 <int-e> when () do foo   doesn't work.
12:44:55 <int-e> when (...) $ do foo does.
12:44:56 <fasta> when (ajj == 0) error "0 in diagonal"
12:44:59 <sclv> return $ ?
12:45:01 <omniscientIdiot> I'd hazard a guess that it could be indentation problems.
12:45:06 <fasta> That's also wrong
12:45:10 <fasta> when is not syntax
12:45:29 <jatqceer> so how do I use when?
12:45:29 <monochrom> nice int-e and fasta
12:45:40 <mauke> when (ajj == 0) (error "0 in diagonal")
12:45:46 <sclv> oh... the return is in the crout function. nevermind :-(
12:45:51 <jatqceer> and the do expression?
12:46:06 <mauke> parens or $
12:46:09 <omniscientIdiot> parens around it, or ($)
12:46:31 <jatqceer> like when () $ do foo?
12:46:40 <omniscientIdiot> yep
12:46:41 <fasta> Shall we remember that @stereo is not here again? :)
12:47:07 <monochrom> We don't need that stereo quote.
12:47:33 <omniscientIdiot> when (test) (do foo), when is an ordinary function, so it would misinterpret the word 'do' itself as an argument, or something.
12:47:49 <omniscientIdiot> in any case it's bad syntax.
12:47:49 <fasta> And I see n+k pattern...
12:47:53 <mauke> I think it's just brain damage in the haskell grammar
12:47:55 <fasta> patterns*
12:48:16 <mauke> (f do x) is not ambiguous
12:48:24 <Ben`> how can I drop every nth element of a list?
12:48:29 <omniscientIdiot> Meh, I'll take a little brain damage for the usual gravy :)
12:49:01 <jatqceer> mauke: I agree with you.  My brain is indeed damaged
12:49:06 <Lemmih> Ben`: Create a new list where the nth element is missing.
12:49:09 <LoganCapaldo> Ben`: zip with [1..] and filter mod whtever
12:49:17 <LoganCapaldo> and then map fst
12:49:27 <oerjan> > takeWhile (not.null) $ unfoldr (Just . second (drop 1) . splitAt 5) [1..20]
12:49:30 <lambdabot>  [[1,2,3,4,5],[7,8,9,10,11],[13,14,15,16,17],[19,20]]
12:49:33 <omniscientIdiot> > map (take 2) $ iterate (drop 3) [1,2,3,4,5,6,7,8,9,10]
12:49:35 <lambdabot>  [[1,2],[4,5],[7,8],[10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
12:49:46 <omniscientIdiot> + takeWhile (not . null)
12:49:51 <EvilTerran> > [x | (x,i) <- zip ['a'..'z'] [0..], i `mod` 6 /= 0]
12:49:52 <lambdabot>  "bcdefhijklnopqrtuvwxz"
12:50:16 <Ben`> thanks :)
12:50:25 <LoganCapaldo> a isn't the sixth element :)
12:50:27 <EvilTerran> this sorta thing's where list comprehensions really shine, imo
12:50:32 <LoganCapaldo> (hence [1..]
12:50:44 <EvilTerran> > [x | (x,i) <- zip ['a'..'z'] [1..], i `mod` 6 /= 0] -- then, pedant. ;]
12:50:46 <lambdabot>  "abcdeghijkmnopqstuvwyz"
12:51:05 <omniscientIdiot> chunk + map init
12:51:37 <omniscientIdiot> where chunk is the often-written [1,2,3,4,5,6] -> [[1,2],[3,4],[5,6]]
12:51:43 <LoganCapaldo> I keep forgetting list comprehensions exists
12:51:58 <EvilTerran> unfortunately, chunk isn't in the prelude
12:52:14 <omniscientIdiot> thus "often written" :D
12:53:26 <sclv> et'
12:53:33 <sclv> s solution is inefficient with the mods
12:53:44 <sclv> maybe something using cycle and zipWith?
12:54:10 <oerjan> sclv: didn't you see the two others posted?
12:54:26 <oerjan> although we both missed a concat
12:54:45 <fasta> sclv: what makes you think it's inefficient?
12:55:13 <omniscientIdiot> DIVISIONS ARE BAD, MM'KAY?
12:55:16 <sclv> oh dear. my brain is going -- i'd better go while i've still got some left
12:55:20 <twanvl> > [x | (x,b) <- zip ['a'..'z'] (cycle $ replicate 5 True ++ [False]), b]
12:55:21 <lambdabot>  "abcdeghijkmnopqstuvwyz"
12:55:29 <oerjan> > on
12:55:30 <lambdabot>   Not in scope: `on'
12:56:02 <EvilTerran> omniscientIdiot, sclv, many temporary lists is hardly better than divisions, i'd say
12:56:20 <omniscientIdiot> deforestation!
12:56:29 <oerjan> @let (~~ `on` f) x y = f x ~~ f y
12:56:29 <lambdabot>  Parse error
12:56:40 <EvilTerran> the optimiser is not all-powerful
12:56:54 <omniscientIdiot> @let ((*) `on` f) x y = f x * f y
12:56:56 <lambdabot> Defined.
12:57:25 <omniscientIdiot> > ((==) `on` fst) (1, "blah") (1, "poop")
12:57:27 <lambdabot>  True
12:57:27 <twanvl> > concat $ zipWith ($) (cycle $ replicate 5 return ++ [const []]) ['a'..'z']
12:57:28 <lambdabot>  "abcdeghijkmnopqstuvwyz"
12:58:08 <oerjan> > map snd . groupBy ((==)`on`snd) . zip (map (replicate 5) [0,1]) $ [0..20]
12:58:09 <lambdabot>  Couldn't match expected type `(a, b)'
12:58:11 <hpaste>  int-e annotated "ludcmp" with "this typechecks" at http://hpaste.org/2761#a1
12:58:29 <oerjan> > map snd . groupBy ((==)`on`snd) . zip (concatMap (replicate 5) [0,1]) $ [0..20]
12:58:30 <lambdabot>  Couldn't match expected type `(a, b)'
12:59:19 <EvilTerran> regardless of all this, i say not using my version is premature optimisation
12:59:19 <oerjan> > map (map snd) . groupBy ((==) `on` fst) . zip (concatMap (replicate 5) $ cycle [0,1]) $ [0..20]
12:59:21 <lambdabot>  [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20]]
12:59:21 <int-e> jatqceer: the problem for the type checker was that it couldn't infer the type for the scaleInfo array.
12:59:47 <EvilTerran> given that the meaning of mine is immediately obvious, imo, and we haven't done any profiling
13:00:04 <omniscientIdiot> concat . map init . chunk n is much clearer.
13:00:12 <EvilTerran> if you had chunk, yes.
13:00:24 <int-e> jatqceer: which is a rather annoying issue to deal with really because explicit type signatures aren't that great in ST either. The assertSTUArray function that I added serves the purpose of nudging the type checker to do the right thing.
13:00:51 <Saizan> > ($[]) . foldr (.) id $ zipWith ($) (cycle $ replicate 5 (:) ++ [const id]) ['a'..'z']
13:00:52 <lambdabot>  "abcdeghijkmnopqstuvwyz"
13:01:22 <omniscientIdiot> gotta love folding function together!
13:01:23 <EvilTerran> given that someone else coming to your code would probably have to find chunk to know what it is, though, it's probably much the same
13:01:47 <EvilTerran> also INIT IS BAD, MM'KAY?!
13:01:54 <omniscientIdiot> chunk is useful on its own, though.
13:02:03 <omniscientIdiot> :P
13:03:31 <LoganCapaldo> init is bad?
13:03:32 <EvilTerran> i say generalise: chunk n = takeNdropNetcetc n 0 ;)
13:03:37 <sorear> EvilTerran: right, it should be called createNewListWithAllElementsOfTheUniqueMaximalProperPrefixOfAnExistingList
13:03:39 <EvilTerran> init is O(n)
13:03:51 <int-e> jatqceer: btw, the same code in IO would have a similar problem, but giving an explicit type signature would be far more easy.
13:04:03 <EvilTerran> sorear, i didn't say that. i just figure it's better to use std library functions when they're available
13:04:15 <EvilTerran> (or indeed not use them when they aren't)
13:04:20 <oerjan> EvilTerran: that's just map (take n) . chunk m
13:04:21 <hpaste>  jatqceer annotated "ludcmp" with "ludcmp" at http://hpaste.org/2761#a2
13:04:25 <LoganCapaldo> so is map, is map BAD too?
13:04:46 <EvilTerran> okayokay
13:05:07 <omniscientIdiot> > let filt = replicate 5 True ++ [False] in map snd . filter fst . zip (cycle filt) $ [1..20]
13:05:09 <lambdabot>  [1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,20]
13:05:13 <omniscientIdiot> ^^ clear for me
13:05:15 <EvilTerran> i was merely making the point that getting upset about the odd division might be misplaced
13:05:19 <EvilTerran> through satire
13:05:25 <LoganCapaldo> sorry
13:05:32 <LoganCapaldo> I wasn't paying attention
13:05:36 <omniscientIdiot> no worries :)
13:05:42 <LoganCapaldo> all I saw was INIT IS BAD, mmkay
13:05:42 <jatqceer> now, I pasted the whole file
13:05:44 <EvilTerran> omniscientIdiot, yeah, well... er, you just wrote it. ;]
13:05:51 <LoganCapaldo> out of context
13:05:56 <int-e> jatqceer: please look at the first annotation.
13:06:11 <jatqceer> int-e: I'm trying your id, now
13:06:25 <sorear> my take on Haskell and "efficiency": if you want ##c, you know where to get it
13:06:29 <int-e> jatqceer: btw note that "Vector s" is the wrong type for the row permutation
13:07:02 <oerjan> @let chunk n = takeWhile (not.null) . unfoldr (Just . splitAt n)
13:07:05 <lambdabot> Defined.
13:07:07 <jatqceer> int-e: why?
13:07:20 <int-e> because Double isn't Int
13:07:26 <DRMacIver> Hm. It would be nice if type classes could enforce "You must override one of these methods" constraints.
13:07:40 <DRMacIver> (I just spent a few minutes headscratching because I'd accidentally defined < instead of <= )
13:07:51 <oerjan> > concatMap (drop 1) . chunk 6 . (undefined:) $ [1..20]
13:07:53 <lambdabot>  [1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,19,20]
13:08:00 <oerjan> look, no init!
13:08:08 <norpan> DRMacIver: isn't it enough to define <? shouldn't it be?
13:08:13 <omniscientIdiot> hehe, (undefined:)
13:08:35 <DRMacIver> norpan: Ord seems to require you define <= or compare. When I defined <, trying to do comparisons caused a stack overflow.
13:08:38 <omniscientIdiot> norpan: Ord's compare is defined in terms of (<=)
13:09:04 <norpan> but <= could be defined in terms of == and <
13:09:07 <sorear> Actually, the problem is that haskell supports ⊥.
13:09:28 <DRMacIver> Supports ? ?
13:09:29 <Cale> sorear: How could it not? :)
13:09:39 <Cale> Every language supports bottom.
13:09:42 <twanvl> We should have (<=) in terms of (<) in terms of (>) in terms of (>=) in terms of compare in terms of (<=)
13:09:43 <DRMacIver> Oh, right.
13:09:44 <int-e> Cale: you could give up turing completeness
13:09:45 <omniscientIdiot> DRMacIver: bottom.
13:09:49 <Cale> (Everything turing complete)
13:10:07 <Cale> int-e: Yeah, but who wants that? :)
13:10:18 <sorear> ME!
13:10:19 <LoganCapaldo> I want a language that's turing complete modulo bottom :)
13:10:20 <sorear> :)
13:10:36 <omniscientIdiot> WHAT, YOU MEAN I CAN'T DO ARBITRARY AMOUNTS OF WORK?!
13:11:08 <sorear> right.  you die after no more than 122 years.
13:11:36 * omniscientIdiot pokes sorear
13:12:13 <fasta> sorear: some people get older than that
13:12:16 * fasta ducks
13:14:55 <fasta> Hmm, the (language) document I am reading clearly doesn't have the same audience as some Scheme manuals. What can we conclude from that?
13:15:07 <int-e> having functions besides compare in Ord is a premature optimization. :P
13:15:16 <hpaste>  jatqceer annotated "ludcmp" with "ludcmp: compiles, yet strange result" at http://hpaste.org/2761#a3
13:18:52 <jatqceer> int-e: what do you mean?  I just didn't want to write another loop searching for max in the array
13:18:58 <DRMacIver> int-e: One should have the ability to specify arbitrary functions to instances nanyway. ;)
13:19:11 <DRMacIver> err. specialise
13:21:44 <jatqceer> can someone lookat the code I pasted and tell me if I have to make mat and rowPerm as the argument of crout
13:22:41 <Lemmih> jatqceer: You don't.
13:23:30 <jatqceer> Lemmih: are you sure?  because it's not doing anything to the arrays as i observed
13:24:14 <Lemmih> jatqceer: I am 100% sure.
13:24:46 <int-e> jatqceer: crout _ (n + 1) _ _ = return (mat, rowPerm) ... what did you expect that to do?
13:25:16 <int-e> jatqceer: here's what it is: it's a n-pattern that binds n to the value of the second parameter minus 1, if that value is non-negative.
13:25:34 <int-e> jatqceer: what you mean is crout _ j _ _ | j == n+1 = ...
13:25:50 <jatqceer> really?  thanks
13:26:07 <int-e> > let f (n+1) = n in f 1
13:26:08 <lambdabot>  Parse error in pattern
13:26:21 <int-e> lambdabot: ?
13:26:22 <lambdabot> Maybe you meant: . activity activity-full admin all-dicts arr ask b52s babel bf botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add djinn-clr
13:26:22 <lambdabot> djinn-del djinn-env djinn-names djinn-ver docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq figlet figlet' flush foldoc forecast forget fortune
13:26:22 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma karma+
13:26:22 <lambdabot> karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on offline oldwiki palomer
13:26:24 <lambdabot> part paste pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc read reconnect redo
13:26:27 <lambdabot> [3 @more lines]
13:26:31 <int-e> woops. sorry.
13:26:37 <omniscientIdiot> :D
13:26:43 <int-e> anyway, in ghci that gives 0
13:26:45 <omniscientIdiot> bad bot
13:27:23 <oerjan> int-e: i heard something about Language.Haskell's parsing disallowing n+1 patterns for some anti-injection reason
13:27:41 <oerjan> which > uses
13:27:57 <int-e> hmm, I wonder.
13:28:13 <int-e> but n+k-patterns are evil anyway.
13:28:19 <oerjan> cannot imagine how that is dangerous, though
13:29:17 <jatqceer> i didn't mean it to be a pattern...I thought it's a kind of number
13:29:57 <omniscientIdiot> any lowercase name in a pattern introduces a new binding.
13:30:46 <QuietPurple> hello evilterran?
13:30:59 <EvilTerran> hi
13:38:18 <hpaste>  jatqceer annotated "ludcmp" with "ludcmp: array *** Exception: Error in array index" at http://hpaste.org/2761#a4
13:40:29 <int-e> jatqceer: you have the same mistake in the sum functions
13:40:49 <int-e> jatqceer: and dividePivot, and maybe some other that I'm missing
13:42:03 <int-e> jatqceer: it's easier to write loops with mapM_ (or, with recent enough libraries, forM_)
13:42:30 <int-e> @type forM_ [1..5] $ \n -> do print n
13:42:33 <lambdabot> IO ()
13:43:20 <oerjan> > forM_ [1..5] $ \n -> do (tell . show) n
13:43:21 <lambdabot>   add an instance declaration for (Show (m ()))
13:43:28 <int-e> @type foldM
13:43:29 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:43:32 <oerjan> > runWriter $ forM_ [1..5] $ \n -> do (tell . show) n
13:43:37 <lambdabot>  ((),"12345")
13:43:38 <int-e> or that. hmm.
13:44:00 <int-e> jatqceer: but direct recursion is easier to understand I guess.
13:45:50 <oerjan> > runWriter $ forM_ [1..5] $ \n -> do (tell . printf "%4d ") n
13:45:52 <lambdabot>  Add a type signature
13:47:00 <oerjan> > runWriter $ forM_ [1..5] $ \n -> do tell (printf "%4d " n :: String)
13:47:02 <lambdabot>  ((),"   1    2    3    4    5 ")
13:57:30 <chessguy> @pl \x -> s (m s x)
13:57:30 <lambdabot> s . m s
13:58:25 <chessguy> @pl \s x -> s (m s x)
13:58:25 <lambdabot> ap (.) m
14:07:39 <chessguy> @type (ap (.) m) show
14:07:41 <lambdabot> Not in scope: `m'
14:07:49 <chessguy> @type (ap (.) ?m) show
14:07:51 <lambdabot> forall b a. (?m::(b -> String) -> a -> b, Show b) => a -> String
14:10:00 <scandal> what does the ? in that expression signify.  looks like its converting it to a type?
14:10:20 <oerjan> it's an implicit parameter
14:10:47 <oerjan> an extension that allows you to pass some variables dynamically
14:11:13 <oerjan> they're type shows up in the context of the function
14:11:16 <oerjan> *their
14:12:36 <oerjan> here, it's just a trick to get the type for an expression involving a free variable
14:15:04 <oerjan> it's one of the extensions supported by @type but not > , alas
14:15:12 <nominolo> @seen SyntaxNinja
14:15:12 <lambdabot> SyntaxNinja is in #haskell. I don't know when SyntaxNinja last spoke.
14:15:37 <ddarius> You're not going to hack the machine with :t.
14:16:13 <allbery_b> huh?  I thought it was just that @run uses Language.Haskell which doesn't do such things
14:16:43 <sjanssen> allbery_b: yes, that's right
14:16:57 <ddarius> And why does @run use Language.Haskell.
14:17:10 <sjanssen> ddarius: to avoid various injection attacks
14:17:21 <shteou> I'm starting to like Haskell :o
14:17:53 <shteou> Well, I'm getting to grips with some of the more useful constructs now heh
14:17:54 <oerjan> perhaps it could eventually use the ghc api instead
14:18:21 * ddarius lackidaisically attempts to warn shteou away.
14:18:37 * ddarius is kind of surprised that he correctly spelled lackidaisically from the get-go.
14:19:01 <shteou> heh
14:19:12 <shteou> lacka* ? :o
14:19:27 <chessguy> sorry scandal, didn't mean to ignore you. i got a phone call
14:19:38 <oerjan> ddarius: better luck next time
14:19:53 <shteou> I'm presently impressed with the 'toy compression algorithms' at the YHC wiki :(
14:20:02 <omniscientIdiot> @wn lackadaisically
14:20:05 <lambdabot> *** "lackadaisically" wn "WordNet (r) 2.0"
14:20:05 <lambdabot> lackadaisically
14:20:05 <lambdabot>      adv : in an idle and lackadaisical manner; "he was hanging around
14:20:05 <lambdabot>            the house lackadaisically"
14:20:23 <chessguy> @wn lackadaisical
14:20:25 <lambdabot> *** "lackadaisical" wn "WordNet (r) 2.0"
14:20:25 <lambdabot> lackadaisical
14:20:25 <lambdabot>      adj 1: lacking spirit or liveliness; "a lackadaisical attempt"; "a
14:20:25 <lambdabot>             languid mood"; "a languid wave of the hand"; "a hot
14:20:25 <lambdabot>             languorous afternoon" [syn: {dreamy}, {languid}, {languorous}]
14:20:27 <lambdabot> [4 @more lines]
14:20:38 <omniscientIdiot> @more
14:20:38 <lambdabot>      2: idle or indolent especially in a dreamy way; "she was
14:20:39 <lambdabot>         annoyingly lackadaisical and impractical";
14:20:39 <lambdabot>         "a...lackadaisical, spiritless young man-about-town"-
14:20:39 <lambdabot>         P.G.Wodehouse
14:20:44 <shapr> SyntaxNinja: Hey, darcs is broken in debian/unstable
14:22:42 <ddarius> Doh
14:23:21 <shteou> Hmm, wet & dry hair clippers with mains adapter sounds scary :(
14:25:15 <oerjan> might be a misspelling of wet & fry
14:26:47 <pgavin> @seen dcoutts
14:26:48 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1d 3h 26m 24s ago.
14:27:14 <shapr> Is anyone here using debian/unstable and can install libcurl3?
14:27:55 <shapr> I added experimental to my sources, but it still won't install.
14:29:35 <shteou> heh true oerjan ;p
14:30:51 <shapr> Surprisingly, I can't find a libcurl3-dev package either. I wonder if there's something wrong with my apt database.
14:32:31 <DRMacIver> @pl \w x y z -> w + x + y + z
14:32:31 <lambdabot> ((((+) .) . (+)) .) . (+)
14:32:34 <DRMacIver> Ick
14:32:54 <Heffalump> @pl \w x y z -> (w + x) + (y + z)
14:32:55 <lambdabot> flip flip (+) . (((.) . (.) . (+)) .) . (+)
14:33:06 * Heffalump fails to help the situation
14:33:17 <Heffalump> @pl \(w, x) (y, z) -> (w + x) + (y + z)
14:33:18 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (+) . (((.) . (.) . (+)) .) . (+))
14:33:31 <Heffalump> I'm not deliberately trying to make it worse, it just seems that way.
14:33:35 <ddarius>  @pl fails to help the situation?!  That's unpossible!
14:33:47 <allbery_b> @quote flip-stream
14:33:47 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
14:35:49 <DRMacIver> @pl \w x y z -> w + (x + y) + z
14:35:49 <lambdabot> (((+) .) .) . (. (+)) . (.) . (+)
14:36:08 <DRMacIver> When the pointless version is longer than the lambda, it's time to give up. :)
14:38:32 <dolio> > ((((+) .) .) . ((+) .) . (+)) 1 2 3 4
14:38:34 <lambdabot>  10
14:39:46 <oerjan> @pl \w x y z -> w + (x + (y + z))
14:39:47 <lambdabot> (. ((. (+)) . (.) . (+))) . (.) . (.) . (+)
14:40:50 <ddarius> @pl \w x y z -> w + ((x + y) + z)
14:40:50 <lambdabot> (. (((+) .) . (+))) . (.) . (.) . (+)
14:41:01 <oerjan> @unpl ((((+) .) .) . ((+) .) . (+))
14:41:01 <lambdabot> (\ f l o -> (+) ((f + l) + o))
14:43:21 <oerjan> @pl \f x y -> f (x+y)
14:43:22 <lambdabot> (. (+)) . (.)
14:44:18 <oerjan> @unpl ((. (+)) . (.)) $ ((. (+)) . (.)) id
14:44:18 <lambdabot> (\ t d h -> (t + d) + h)
14:44:27 <oerjan> @unpl ((. (+)) . (.)) $ ((. (+)) . (.)) $ ((. (+)) . (.)) id
14:44:28 <lambdabot> (\ ac d h l -> ((ac + d) + h) + l)
14:45:57 * allbery_b isn't sure he wants to see what @unpl's intermediates look like if it got up to ac
14:48:28 <oerjan> @unpl (. (+)) . (.) . (. (+)) . (.) . (. (+)) . (.) $ id
14:48:29 <lambdabot> (\ ag d h l -> ((ag + d) + h) + l)
14:49:01 <Heffalump> @. unpl pl \a b c d -> a + b + c + d
14:49:01 <lambdabot> (\ e k n -> (+) ((e + k) + n))
14:49:42 <DRMacIver> God, what have I started? :)
14:50:47 <oerjan> i think it got nice if not exactly short
14:51:03 <SamB> NICE?
14:51:05 <SamB> THAT?
14:51:24 <oerjan> it's perfectly regular, with linear growth if you add more variables
14:51:33 <dmhouse> Anyone read sigfpe's 'The Antidiagonal'?
14:51:47 <SamB> @type \x y -> x . (.) . y
14:51:49 <lambdabot> forall c b c1 a a1. (((a -> b) -> a -> c1) -> c) -> (a1 -> b -> c1) -> a1 -> c
14:52:58 <oerjan> i did not say anything about being understandable, did i? :D
14:54:03 <ddarius> dmhouse: Are you doing a survey?
14:55:08 <shapr> Ah, libcurl3 should be fixed as soon as the new package is on the mirrors.
14:55:26 <dmhouse> ddarius: no. I don't understand one of the paragraphs :)
15:00:48 <sorear> .
15:01:12 * oerjan blinks.
15:01:25 * omniscientIdiot SCREAMS!
15:03:27 <oerjan> sorear did that yesterday too. what's up?
15:03:55 <wolverian> dmhouse, just one? :)
15:04:21 <DRMacIver> Hm. It's nice how much less clever I have to be to write Haskell code than I do to write Java. :)
15:04:24 <allbery_b> he doesn't like to use @messages? like the rest of us
15:07:12 <allbery_b> or /msg lambdabot @messages
15:07:23 <allbery_b> which is what I do (but I have a persistent window)
15:10:06 <dmhouse> wolverian: ironically I follow the algebra but not the "more intuitive explanation". :)
15:11:30 <SamB> man the reduceron is wierd
15:11:46 <SamB> 18-bit RAM?
15:12:44 <shteou> heh
15:12:52 <shteou> <3 FPGAs
15:13:24 <SamB> and it is severely lacking in comments...
15:15:18 <lucca> sounds DECprecated
15:15:20 <dmhouse> Hmm, the finite-state diagram representation of recursive types from http://sigfpe.blogspot.com/2007/09/type-of-distinct-pairs.html is really interesting.
15:15:21 <lambdabot> Title: A Neighborhood of Infinity: The Antidiagonal
15:20:11 <bkudria> i have a general functional programming question, is this a good place to ask?
15:20:47 <omniscientIdiot> only one way to find out :)
15:21:32 <Philippa> bkudria: it is for most such questions, yeah
15:21:38 <bkudria> omniscientIdiot: i have a value that is expensive to compute, and i need it twice.  should i assign it to a variable, or what?
15:22:01 <SamB> bkudria: that should be fine
15:22:25 <bkudria> SamB: aah, ok, next question...i'm doing this in sml, how do i assign a temp. variable inside a function?
15:22:42 <allbery_b> let
15:22:54 <allbery_b> let a = ... in ...
15:23:01 <dmhouse> allbery_b: in SML?
15:23:14 <omniscientIdiot> it should be similar
15:23:15 <dmhouse> That's a little off-topic. General FP questions are okay, but questions specific to other languages really belong in their own channels.
15:23:16 <allbery_b> sml uses that syntax as well, yes
15:23:30 <dmhouse> allbery_b: righto, just checking. :)
15:23:46 <dmhouse> bkudria: but that isn't to say you won't get an answer. :)
15:23:50 * allbery_b can't actually write sml but can understand programs written in it
15:24:12 <SamB> allbery_b: huh. saw something different in Purely Functional Data Structures the other day...
15:24:25 <bkudria> well, i must not be using it correctly... it's not: let smaller = f(x); ?
15:24:29 <SamB> it looks like you say "let val a = ... in ..."
15:24:44 <allbery_b> mainly because someone in SCS had a habit of tossing SML at us
15:24:49 <bkudria> what comes after in ?
15:24:54 <sorear> you might also need an 'end' there
15:25:06 <SamB> sorear: true
15:25:29 <lucca> and similarly let fun ... = ... in
15:25:46 <ivant> is there any general name for functions of type a -> a (where a is some specific type)?
15:26:08 <bkudria> so, it's "let y = f(x) in dosomething(y) end; ?  that doesn't seem to work for me
15:26:12 <lucca> samb: neat book, btw... just got mine
15:27:27 <oerjan> ivant: in category theory, endomorphism
15:27:39 <ddarius> Or just endofunction
15:28:27 <ivant> oh, good, I know how to name the type then :-)
15:28:35 <ddarius> :t Endo a
15:28:40 <lambdabot> Not in scope: `a'
15:28:41 <allbery_b> hm, wikipedia thinks it's let val ... in ... end
15:28:46 <ddarius> :t id :: Endo a
15:28:48 <lambdabot>     Couldn't match expected type `Endo a'
15:28:48 <lambdabot>            against inferred type `a1 -> a1'
15:28:52 <ddarius> Oh yeah.
15:28:57 <ddarius> @src Endo
15:28:57 <lambdabot> Source not found. It can only be attributed to human error.
15:29:04 <ivant> @index Endo
15:29:05 <lambdabot> bzzt
15:29:29 <jbauman> allbery_b, yes, that's the case in SML
15:29:32 <oerjan> :t Endo
15:29:34 <lambdabot> forall a. (a -> a) -> Endo a
15:29:45 * allbery_b knew there was a reason he considered sml ugly
15:29:49 <oerjan> it's a newtype constructor
15:29:51 <ivant> where is it defined?
15:29:59 <oerjan> Data.Monoid
15:30:11 <bkudria> allbery_b: neither let nor val worked for me
15:30:33 <ivant> thanks. I think I need a type though
15:30:37 <allbery_b> let val y = f(x) in something end
15:30:50 <ddarius> allbery_b: There is a lot more than makes it ugly than that.
15:30:54 <allbery_b> but you may bebetter off looking for an SML channel; at this point
15:30:59 <allbery_b> yes, yes there is
15:31:45 <bkudria> allbery_b: aah, i'll try that, thanks
15:31:54 <bkudria> allbery_b: no one awake there
15:32:25 <allbery_b> like I said, I can't write SML for shit but I can read SML programs
15:35:23 <bkudria> allbery_b: hmm, doesn't work - i got an error
15:35:32 <bkudria> allbery_b: this is supposed to be simple sml, i think :)
15:36:06 <allbery_b> think you need to find someone who actually knows sml well enough to write it properly, which would not be me :/
15:36:18 <bkudria> ahh, ok, well, thanks for the help anyway
15:36:54 <QuietPurple> is there a function that finds the first true in a list of bools, and then gives you the length of the list up to that point?
15:37:01 <QuietPurple> or something to that effect...
15:37:14 <QuietPurple> if not, i suppose i can write it myself
15:37:28 <ddarius> elemIndex True
15:37:41 <QuietPurple> cool, thanks loads
15:38:22 <QuietPurple> @type elemIndex
15:38:31 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
15:38:43 <KatieHuber> much more elegant than my (length . fst . (break id))
15:39:10 <oerjan> you could have done length . takeWhile id
15:39:12 <KatieHuber> also, mine returns the length of the list if there are no True
15:39:45 <oerjan> right...
15:39:53 <omniscientIdiot> > elemIndex 1 [5,6,7,8]
15:39:54 <lambdabot>  Nothing
15:40:03 <QuietPurple> crazy
15:40:23 <QuietPurple> >elemIndex 3 [0,0,0,0,3,0,0]
15:40:37 <KatieHuber> need a space after > I think
15:40:42 <QuietPurple> > elemIndex 3 [0,0,0,0,3,0,0]
15:40:43 <lambdabot>  Just 4
15:41:00 <omniscientIdiot> (add a space after >)
15:41:06 <QuietPurple> i don't understand Maybe and Just, but they crack me up
15:41:12 <omniscientIdiot> case ... of Just x -> x; Nothing -> length ...
15:41:49 <KatieHuber> if you're used to a language like Java, Nothing is null, and Just is anything non-null :)
15:41:57 <omniscientIdiot> @hoogle Maybe a -> a
15:41:58 <lambdabot> Maybe.fromJust :: Maybe a -> a
15:41:58 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
15:41:58 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
15:42:06 <ddarius> Except that you have to check to use the value.
15:42:21 <omniscientIdiot> fromMaybe (length ...) (elemIndex ...)
15:42:21 <monochrom> Java is a big monad.
15:42:47 <KatieHuber> OMG Data.Set seems rather memory-inefficient :o
15:43:00 <monochrom> how so?
15:43:14 <KatieHuber> or maybe my program is just that much faster now that it can chew through a GB in the time it took the old program to get through 70M
15:43:17 <omniscientIdiot> @src fromMaybe
15:43:18 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
15:43:42 <ddarius> @. djinn type fromMaybe
15:43:44 <QuietPurple> is elemIndex not in Prelude? it's not working in ghci
15:43:44 <lambdabot> f a b =
15:43:44 <lambdabot>     case b of
15:43:44 <lambdabot>     Nothing -> a
15:43:44 <lambdabot>     Just c -> c
15:43:50 <ddarius> @index elemIndex
15:43:50 <lambdabot> Data.List
15:44:10 <QuietPurple> aha
15:44:23 <QuietPurple> thanks again
15:44:47 <omniscientIdiot> @index elemIndex
15:44:47 <omniscientIdiot> should be Data.List
15:44:48 <lambdabot> Data.List
15:45:05 <omniscientIdiot> I must be laggy.
15:45:40 <oerjan> that's what they all say
15:45:47 <Philippa> KatieHuber: depending on what you did to your code that's plenty plausible
15:46:07 <KatieHuber> I had a list of seen states, and was using `elem` to check membership every time
15:46:28 <KatieHuber> now I have a Data.Set of seen states, using member to check membership every time (and added Ord instances everywhere to allow it)
15:46:55 <KatieHuber> so it's gone from an O(n^2) to O(n log n) algorithm I think
15:47:32 <Philippa> plenty plausible then, yeah
15:47:41 <KatieHuber> so since I'm talking about hundreds of thousands of states, it'd make a pretty big difference
15:47:48 <eugman> So are there any well know programs made in haskel?
15:47:50 <Philippa> really I should get out of the habit of using lists by default for things like that myself
15:47:57 <Philippa> eugman: darcs, pugs, xmonad
15:48:16 <jcreigh> GHC. :)
15:48:39 <Philippa> GHC's really not that well-known among non-haskellers
15:48:40 <fasta> Does GHC HEAD on x86-64 work as good as on x86?
15:48:55 <sorear> fasta: probably not
15:49:05 <sorear> fasta: ghc doesn't do subword types, period
15:49:14 <KatieHuber> yeah, wow, that could easily make that kind of difference :|
15:49:20 <sorear> fasta: this bites hard on 64-bit, since a character consumes 16 bytes
15:50:13 <Philippa> good thing it's comparatively easy to swap datatypes in haskell, huh?
15:50:38 <Philippa> equational reasoning really makes life easier when you've got refactorings and rewritings to do
15:51:14 <monochrom> Abstract Nonsense Is Strength.
15:51:35 <fasta> sorear: a char takes 4 words? For what again precisely?
15:51:36 <fnord123> has anyone been using gtk2hs cairo? I tried the clock example at (http://darcs.haskell.org/gtk2hs/demo/cairo/Clock.hs) and the bg is a white square; not invisible like I would have hoped.
15:52:04 <KatieHuber> somebody was here just the other day saying how much they love using it :)
15:52:09 <sorear> fasta: what's 64 divided by 8?
15:52:15 <sorear> fasta: 16 bytes is only 2 words
15:52:26 <sorear> fasta: on the 64 bit computers you're talking about
15:52:32 <allbery_b> on x86-64 16 bytes would be 2 words, 1 for constructor and 1 for value
15:52:42 <allbery_b> as I understand it
15:52:57 <Lemmih> fasta: I've been using GHC on x86-64 for the last 9 months and I haven't encountered a problem yet.
15:54:22 <eugman> "One danger that is often mentioned is that of a lack of contributors due to the rarity of Haskell programmers. I've been surprised by the number and quality of contributors darcs has had. There seem to be quite a few people out there just looking for somewhere to use Haskell! "
15:54:53 <SamB> I'm sure it doesn't hurt that darcs is so fun to use
15:55:05 <ddarius> eugman: That was written years ago too.  Things are even better in that regard now.
15:56:36 <eugman> Well i think I might try around with haskell a bit. It was one of the most common responses when I asked for something a bit thought expanding.
15:57:01 <allbery_b> @quote exploded
15:57:01 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
15:58:31 <SamB> eugman: that's one thing it certainly is ;-)
15:59:10 <chessguy> eugman, what background do you come from?
16:00:29 <eugman> chessguy, basic->TI89Basic->Python->c++->Python
16:02:02 <chessguy> this should rock your world a bit :)
16:03:07 <eugman> Yes, that is the intention. I was considering lisp for that purpose but I don't like the idea of coding in a language twice my age.
16:03:44 <chessguy> haha
16:03:52 <KatieHuber> I have to say, Haskell is the language that has most influenced the way I think about programming
16:04:17 <chessguy> well, other than macros, this will give you all the mind-bending-ness of lisp, and more
16:05:23 <eugman> Is there any graphical libraries like a sdl wrapper? I find unless I have some big program in mind it's great to just make games so I can enjoy the benifits of my program and test it very quickly.
16:05:40 <KatieHuber> HOpenGL does GLUT
16:05:49 <omniscientIdiot> eugman: I always recommend http://blogs.nubgames.com/code/?p=22 to newbies with similar backgrounds.  It's a great read.
16:05:51 <lambdabot> Title: Nub Games : Haskell IO for Imperative Programmers
16:06:10 <P_D> HSDL?
16:06:17 <sorear> hsSDL
16:06:28 <sorear> Lemmih: is hsSDL still maintained?
16:06:58 <sorear> eugman: haskell isn't really that much younger
16:06:58 <pgavin> Lemmih: is libxml still maintained? :)
16:07:04 <sorear> eugman: FPCA'87
16:07:27 <chessguy> sorear, uh...isn't lisp from the 50's?
16:07:40 <eugman> yeah, haskel is only as old as me give a year
16:07:43 <mrd> not the Lisp as it exists today
16:08:00 <fasta> newLisp!
16:08:02 <allbery_b> the earliest papers on it were from 1946, IIRC
16:08:04 <chessguy> well, it's roots are from back then
16:08:05 * mrd pukes
16:08:06 <fasta> (that was a joke)
16:08:33 <mrd> Scheme is the basis of modern Lisp, and Scheme was invented in the 70s.
16:08:37 <oerjan> *4*6?
16:08:38 <eugman> Also, are there any utilities for making binaries/executables for people without haskell installed?
16:08:39 <allbery_b> (back then it was just a notation, IIRC)
16:08:57 <allbery_b> implementations came later
16:08:58 <sorear> chessguy: I know lisp is from the 50's... it was my number sense that failed, not my memory :(
16:09:10 <sorear> eugman: ghc
16:09:11 <fasta> eugman: the wiki answers all your questions, AFAIK.
16:09:12 <P_D> GHC generates static binaries by default I thought
16:09:34 <mrd> not on Linux
16:09:39 <chessguy> number spense? what, were you bitten by a radioactive microchip?
16:09:47 <eugman> fasta, fair enough. Just like to make sure a few things are available before I make any dive.
16:09:50 <chessguy> s/sp/s/
16:10:01 <allbery_b> ghc's own libs are static, but it uses dynamic libc etc. by default
16:10:08 <fasta> eugman: Haskell is not perfect, but at least the implementation seems better than Python.
16:10:15 <allbery_b> also dynamic libgmp when that's what's installed
16:10:21 <ddarius> Common Lisp is from the 80's
16:10:31 <eugman> fasta, in what way?
16:10:37 <fasta> eugman: no recursion limit for example
16:10:58 <mrd> it has a compiler, for example =)
16:11:06 <fasta> eugman: (at least you can raise the stack size to whatever value you want)
16:11:09 <sorear> it has a TYPE SYSTEM
16:11:19 <ddarius> Wouldn't it be easier to lists ways in which Haskell is not better than python?
16:11:19 <mrd> well we're discussing implementation
16:11:24 <mrd> Simons > Guidos
16:11:32 <sorear> GvR hasn't outright banned recursion?
16:11:42 <omniscientIdiot> meh, I happen to enjoy haskell, but use of the word "better" between languages is not very informative and a little loaded.
16:12:00 <eugman> psyco seems rather good at dealing with the fact python is scripted, as for TYPE SYSTEM do you eman static types or soemthing else
16:12:16 <mrd> there's lots of vagaries, for sure.  however, there's some definite statements to be made.
16:12:32 <mrd> like: Ruby's implementation is inferior to everything else, including projects by CS undergrads.
16:12:38 <SamB> !
16:13:00 <SamB> how about statistics undergrads?
16:13:05 <fasta> omniscientIdiot: I meant language implementations.
16:13:10 <mrd> SamB: with high probability
16:13:26 <pgavin> you've obviously never had to work with engineers' code
16:13:40 <mrd> well, I didn't say engineers =)
16:13:47 <SamB> hey, watch it
16:13:49 <pgavin> some of it's aweful
16:13:51 <mrd> and yes, I have seen it.  also, mathematicians (non-CS) code.
16:13:55 <SamB> I'm an EE major
16:14:04 <pgavin> SamB: that doesn't count
16:14:07 <pgavin> :)
16:14:10 <mrd> FORTRAN and MATLAB-aniacs
16:14:25 <ddarius> SamB: We forgive you.
16:14:30 <SamB> heh
16:14:35 * allbery_b works in an EE department and won't argue the comment about EE-ers' code :)
16:14:50 <eugman> Really INTERCAL is where it's at.
16:14:50 <sorear> code sucks.  period.
16:15:00 <SamB> ddarius: so you think that it's evil to major in EE?
16:15:07 <mrd> write proofs, extract code
16:15:37 <ddarius> SamB: Most of the time I forgive someone, it's not because they did something evil.
16:15:50 <chessguy> @remember sorear code sucks.  period.
16:15:50 <lambdabot> Done.
16:16:02 <SamB> ddarius: oh?
16:16:11 <allbery_b> Samb: you're an EE who codes in Haskell, clearly an exception to the rule
16:16:14 <allbery_b> :)
16:16:17 <ddarius> I wouldn't mind an EE diploma, though I'd prefer others first.
16:16:26 <sorear> @remember chessguy number sense?  what, were you bitten by a radioactive microchip?
16:16:27 <lambdabot> Done.
16:16:34 <SamB> I'd prefer if you said I'm a Haskell user who is majoring in EE...
16:16:48 <conal> does anyone know the status of cabal-install?
16:16:49 <allbery_b> well, there ya go :)
16:16:53 <chessguy> sorear, thanks for correcting my typo :)
16:17:04 <pgavin> most engineers' code I've seen is awefully written C++ that reinvents the wheel every chance it gets
16:17:04 <ddarius> Haskell is wunderbar fuer EE.
16:17:10 <eugman> @quote chessguy
16:17:11 <lambdabot> chessguy says: dolio, hyperbole is the worst form of linguistic expression ever invented
16:17:18 <mrd> pgavin: oh they haven't discovered MATLAB yet?
16:17:31 <allbery_b> verilog.  *shudder*
16:17:37 <ddarius> www.dspguide.com DSP code in BASIC and FORTRAN, yay!
16:17:45 <SamB> man, why bother with C++ if you're still gonna reinvent the wheel...
16:17:53 <SamB> might as well use C for that
16:17:57 <mrd> my friend is an EE here who churns out volumes of hideous matlab
16:18:09 <sorear> people still use BASIC?
16:18:19 <mrd> yep
16:19:23 <ddarius> sorear: You thought BASIC was just a scary story mothers told their children?
16:19:46 <SamB> ddarius: surely you mean fathers
16:19:47 <pgavin> mrd: well, at least the matlab code stays mostly on their desktops :)
16:19:49 <sorear> ddarius: No, I've seen it
16:19:58 <shteou> EE?
16:19:59 <pgavin> mrd: I end up having to compile the C++ code :)
16:20:01 <mrd> pgavin: it nearly takes out his desktop every time it runs
16:20:11 <SamB> shteou: Electrical Engineer[ing]
16:20:12 <shteou> Electrical engineering?
16:20:14 <shteou> ah k
16:20:16 <ddarius> SamB: Fathers speak of COBOL.
16:20:19 <shteou> Ta :]
16:20:37 <shteou> My father speaks of lisp and lisp only ;p
16:20:38 <SamB> my father doesn't tell horror stories
16:20:49 <mrd> if your father teaches you BASIC you can report him for child abuse!
16:20:53 <shteou> lol
16:21:04 <shteou> My dad didn't teach me any programming :(
16:21:07 <Philippa> yeah, use that Dijkstra code as supporting evidence :-)
16:21:10 <Philippa> *quote
16:21:11 <shteou> I think I was too proud to let him teach me any though ;)
16:21:19 <conal> no one here knows the status of cabal-install?
16:21:20 <Philippa> hmm. My brain's clearly not working. Time for bed, methinks
16:21:21 <ddarius> @quote Dijkstra
16:21:22 <lambdabot> No quotes match. stty: unknown mode: doofus
16:21:22 <shteou> He beats me at everything still, I have to have some dignity ;p
16:21:23 <eugman> hey! BASIC is how I got into programming. In middle school I bought a cd from scholastic.
16:21:29 <fasta> conal: I know
16:21:36 <fasta> conal: it needs a maintainer.
16:21:50 <sorear> I started on C
16:21:54 <conal> fasta: ah -- sitting & rotting at the moment?
16:22:05 <SamB> I started with BASIC myself
16:22:06 <sorear> it's a disgusting imperative language, but at least it's higher order!
16:22:17 <Nafai> I started with BASIC on the Apple II way back when
16:22:20 <fasta> conal: yes, almost dead.
16:22:23 <SamB> however I learned important data structures with it!
16:22:29 * ddarius started with QBASIC.
16:22:32 <SamB> such as binary search trees
16:22:34 <fasta> conal: (at least that's popular to say) ;)
16:22:46 <SamB> well, okay, so that's the ONLY one I learned
16:22:52 <ddarius> SamB: You learned data structures in BASIC? Oh dear God.
16:22:56 <SamB> but that is THE most important data structure EVAR
16:23:04 <allbery_b> hey, I started on TRS-80 Model I L2 BASIC.  But I got better.
16:23:09 <mrd> I learned how to construct linked lists in C and thought it was the most sacrosanct data structure ever.
16:23:13 <conal> fasta: thanks.  do you know if the maintainers are just busy?  or someone had a cooler idea, or something?
16:23:19 <ddarius> mrd: Then you found Haskell.
16:23:24 <KatieHuber> yay my program to play patience won a game ^_^
16:23:31 <mrd> no, then I spent many years constructing linked lists manually in C.
16:23:32 <allbery_b> I think they're still arguing over how to organize hackage
16:23:38 <KatieHuber> only, it doesn't know it did... moving on :)
16:23:52 <ddarius> KatieHuber: Pat it on the head and tell it good job.
16:23:56 <allbery_b> overly patient, huh?
16:24:02 <shteou> Don't suppose there's a bytecode 'viewer' for YHC bytecode? Or some verbose output for generated bytecode structures etc.?
16:24:09 <fasta> conal: if you mean the old maintainers, AFAIK, just busy/lost interest.
16:24:11 <SamB> allbery_b: couldn't they just have a list of packages for now?
16:24:21 <Philippa> shteou: isn't there at least a Show instance?
16:24:22 <SamB> with the full URLs
16:24:37 <SamB> so they can reorganize as desired without breaking cabal-install?
16:24:40 <mrd> conal: are you still a Twelf whiz?
16:24:51 <shteou> Hmm Philippa? How would that work?
16:25:02 <conal> mrd: not really.  i worked on predecessors at cmu.
16:25:11 <ddarius> Eleventh?
16:25:31 <sorear> shteou: -help
16:25:32 <Philippa> shteou: for the datatypes corresponding to bytecode
16:25:59 <sorear>      -bcodecompile   show B code after compile (default=off)
16:25:59 <sorear>      -bcodemem       show B code after heap usage analysis (default=off)
16:25:59 <sorear>      -bcodeflatten   show B code after flattening (default=off)
16:26:01 <sorear> etc
16:26:11 <shteou> Oh, quite marvelous :)
16:30:57 <shteou> Hmm, looks perfect for my needs, won't switch itself on though :( I'll play around though, thanks sorear / Philippa :>
16:31:06 <fasta> HEAD on x86-64 doesn't work here.
16:31:16 <hpaste>  ramza3 pasted "(no title)" at http://hpaste.org/2762
16:36:51 <fasta> ./configure: line 2727: utils/pwd/pwd: No such file or directory <- this was a known problem, right?
16:39:07 <fasta> Never mind
16:40:03 <KatieHuber> it's not allowed for a class to declare functions which don't use the type variables the class is parameterized on?
16:41:07 <allbery_b> not without functional dependencies, no
16:41:43 <allbery_b> since the variables determine what instantiation of the function to use
16:41:57 <KatieHuber> how does a functional dependency help?
16:42:05 <SamB> @hoogle setEnv
16:42:06 <lambdabot> No matches found
16:42:08 <SamB> @hoogle setenv
16:42:09 <lambdabot> No matches found
16:42:19 <allbery_b> so if you omit one it can't be sure which to invoke, unless a functional dependency statyes that the type of one variable depends on the other(s)
16:42:24 <eugman> So why would someone want to make a perl implementation in haskell?
16:42:43 <fasta> eugman: see Pugs FAQ probably
16:43:04 <allbery_b> because the Reader monad is a nice way to handle variable scoping sanely?
16:43:15 <KatieHuber> so if I want the class to have a function of some really boring type (like, say, Int -> Int -> Bool) I have to add a useless argument?
16:43:30 <shapr> eugman: It all started as a fun exercise to use the stuff from TaPL
16:44:02 <shapr> audreyt showed up here, I recommended TaPL, reading and coding commenced, and then it appeared.
16:44:30 <allbery_b> if it's a fixed type, why does it need to be a member of the class?
16:44:35 <shapr> fasta: I misread that as utils/pwnd/pwnd :-)
16:44:49 <allbery_b> keep in mind that typeclasses are not like OO languages' classes
16:44:49 <fasta> checking for ghc... no ... (just installed it)
16:45:52 <fasta> Hmm, probably broken PATH.
16:46:29 <QuietPurple> how do i turn Maybe Int into Int?
16:46:43 <Lemmih> QuietPurple: unsafeCoerce#
16:46:46 <fasta> Hmm, that's not it, I also rehashed
16:46:48 <allbery_b> oh dear
16:46:49 <scook0> QuietPurple: pattern matching
16:46:51 <fasta> Lemmih: funny answer
16:46:51 <allbery_b> pattern matching
16:46:54 <scook0> Lemmih: quiet, you!
16:47:13 <scook0> (or fromMaybe, or maybe maybe)
16:47:15 <fasta> It teaches people to ask the right questions
16:47:33 <Lemmih> Life just isn't fun without random segfaults.
16:47:40 <QuietPurple> @type fromMaybe
16:47:43 <lambdabot> forall a. a -> Maybe a -> a
16:48:18 <QuietPurple> what is the first a in that type expression
16:48:19 <scook0> case mi of Just i -> i; Nothing -> 0 -- something along these lines
16:48:23 <QuietPurple> ?
16:48:36 <scook0> QuietPurple: a default value, to use in case the Maybe is Nothing
16:48:53 <QuietPurple> ok
16:49:27 <scook0> if you're *really* sure the Maybe contains a Just, and you enjoy horrible debugging pain, you can use fromJust
16:49:33 <scook0> but I heartily recommend against it
16:49:33 <chessguy> > sequence [Just 3, Nothing, Just 2]
16:49:35 <lambdabot>  Nothing
16:49:46 <fasta> With this PATH, bash and hash -r, /usr/bin/ghci existing, /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games, why doesn't executing ghci in some unrelated directory work?
16:49:49 <chessguy> > sequence [Just 3, Just 827289, Just 2]
16:49:50 <lambdabot>  Just [3,827289,2]
16:50:01 <chessguy> hm.
16:50:05 <QuietPurple> i'll see if that works
16:50:09 <scook0> chessguy: see catMaybes as well
16:50:21 <scook0> > catMaybes [Just 3, Nothing, Just 2]
16:50:22 <lambdabot>  [3,2]
16:50:32 <chessguy> @src sequence
16:50:32 <lambdabot> sequence ms = foldr k (return []) ms
16:50:32 <lambdabot>     where
16:50:32 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
16:51:59 <QuietPurple> what library is fromMaybe in?
16:52:09 <chessguy> @hoogle fromMaybe
16:52:09 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
16:52:31 <chessguy> @index fromMaybe
16:52:31 <lambdabot> Data.Maybe
16:52:40 <chessguy> i guess that would be a more precise answer
16:57:08 <chessguy> @src Num
16:57:09 <lambdabot> class  (Eq a, Show a) => Num a  where
16:57:09 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:57:09 <lambdabot>     negate, abs, signum     :: a -> a
16:57:09 <lambdabot>     fromInteger             :: Integer -> a
16:57:19 <chessguy> @src Eq
16:57:19 <lambdabot> class  Eq a  where
16:57:19 <lambdabot>     (==), (/=)   :: a -> a -> Bool
16:57:45 <chessguy> hmm, you can have an instance of Num that isn't necessarily an instance of Ord?
16:58:14 <allbery_b> fasta: isn't ghci a wrapper which looks for the lib directory in a location relative to where the wrapper is?
16:58:28 <fasta> allbery_b: that should be irrelevant
16:58:36 <fasta> allbery_b: since it cannot find ghci
16:59:30 <fasta> allbery_b: never mind
16:59:50 * allbery_b may havemisparsed 'in an unrelated directory'
17:00:02 <P_D> chessguy: sure why not
17:00:04 <fasta> allbery_b: ghci only exists on my 32-bits system (due to a head build)
17:00:23 <fasta> allbery_b: on Debian apparently only ghci6 gets installed.
17:00:23 <allbery_b> ah
17:00:28 <P_D> all you need is Eq
17:02:25 * eugman thinks the idea of a feasibly infinitely long list is interesting.
17:03:34 <monochrom> Yes, it is very nice.
17:03:55 <allbery_b> oh, right, I forgot that bashism
17:03:58 <oerjan> chessguy: Complex Double is an example
17:04:15 <ddarius> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
17:04:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:04:39 <oerjan> > 1 < sqrt(-1 :: Complex Double)
17:04:40 <lambdabot>        add an instance declaration for (Ord (Complex Double))
17:04:40 <lambdabot>     In the expr...
17:04:45 <allbery_b> No such file or directory but it exists -> check for its "interpreter" (whch for a binary is the appropriate ld*.so*)
17:12:35 <fnord123> @seen dcoutts
17:12:35 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1d 6h 12m 12s ago.
17:16:23 <allbery_b> @seen dcoutts_
17:16:24 <lambdabot> dcoutts_ has changed nick to dcoutts.
17:16:24 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1d 6h 16m ago.
17:17:26 <eugman> let test = 1:test + 1
17:18:08 <oerjan> that's not going to work without some strange Num instance
17:18:20 <eugman> bah
17:18:54 <oerjan> perhaps you meant to use map (+ 1)
17:23:50 <hpaste>  chessguy pasted "any hope for this code?" at http://hpaste.org/2763
17:24:11 <chessguy> so i came across this code
17:24:26 <chessguy> and i'm trying to figure out where to go in cleaning it up
17:24:44 <sorear> You're hopeless.
17:24:46 <sorear> Oh.
17:24:57 <sorear> Look at maximumBy and friends
17:24:59 <chessguy> here, Tree a b is a gametree, with a being a type that represents a move, and b is the 'value' of the current position
17:25:13 <chessguy> @type maximumBy
17:25:15 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:25:33 <chessguy> mmm, that's not going to cut it
17:25:44 <chessguy> it has to be able to short-circuit
17:25:57 <chessguy> well, ok, not for negamax
17:26:07 <sorear> short circuit?
17:26:13 <olsner> how could maximumBy short-circuit?
17:26:30 <chessguy> olsner, it can't, that's the point
17:26:39 <eugman> Prelude> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:26:40 <eugman> <interactive>:1:5: parse error on input `='
17:26:50 <chessguy> and by short circuit, i'm referring to alphabeta, which doesn't always look at all children
17:27:06 <eugman> oh wiat the wikipedia code needs a let
17:27:16 <oerjan> eugman: let fibs = ...
17:27:32 <chessguy> oerjan, and ... in fibs
17:27:43 <chessguy> (if he wants to run it on here)
17:27:47 <eugman> That's what I get for taking code from wikipedia
17:28:00 <chessguy> eugman, there's nothing wrong with that code
17:28:09 <chessguy> eugman, it's just intended to be put in a file
17:28:31 <chessguy> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:28:35 <chessguy> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:28:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:30:51 <Cale> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
17:30:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:31:31 <ddarius> @pl \fibs -> 0:1:zipWith (+) fibs (tail fibs)
17:31:31 <lambdabot> (0 :) . (1 :) . ap (zipWith (+)) tail
17:33:03 <oerjan> > fix (scanl (+) 1) -- was this it?
17:33:05 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
17:34:34 <ddarius> B(B(S(:)(K0))(S(:)(K1)))(S(SzipWith(K(+)))tail)
17:34:55 <eugman> That lines just looks scary
17:34:58 <oerjan> o_O
17:36:31 <oerjan> looks like a strange mixture of Haskell and combinatory logic
17:36:32 <ddarius> I need three more Ks
17:38:05 <ddarius> B(B(S(K(:))(K0))(S(K(:))(K1)))(S(S(KzipWith)(K(+)))tail)
17:39:47 <ddarius> > let b = (.); s = ap; k = const; y = fix in y(b(b(s(k(:))(k 0))(s(k(:))(k 1)))(s(s(k zipWith)(k(+)))tail))
17:39:48 <lambdabot>  Couldn't match expected type `[a] -> [a]'
17:39:52 <pgavin> omg its bf
17:40:02 <pgavin> embedded in haskell
17:40:07 <oerjan> you mean unlambda
17:40:15 <ddarius> > bf
17:40:16 <lambdabot>   Not in scope: `bf'
17:40:49 <pgavin> http://en.wikipedia.org/wiki/Brainfuck
17:40:50 <lambdabot> Title: Brainfuck - Wikipedia, the free encyclopedia
17:41:02 <ddarius> I totally mistranslated those applications.
17:41:23 <oerjan> whatever ddarius did was not brainfuck
17:41:31 <pgavin> @help tell
17:41:31 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
17:41:39 <allbery_b> no, it's unlambda.  sort of.
17:41:47 <pgavin> yeah, your right
17:41:58 <pgavin> I forgot bf was the turing machine language
17:42:02 <oerjan> well, combinatory logic. there's that b.
17:42:12 <ddarius> :t let b = (.); s = ap; k = const; y = fix in b(b(s(k(:))(k 0))(s(k(:))(k 1)))(s(s(k zipWith)(k(+)))tail)
17:42:14 <lambdabot>     Couldn't match expected type `[a] -> [a]'
17:42:14 <lambdabot>            against inferred type `[a1]'
17:42:36 <oerjan> er, you are not actually using y
17:42:44 <ddarius> not in that one
17:43:15 <ddarius> :t let b = (.); s = ap; k = const; y = fix in s(k(:))(k 0)
17:43:17 <lambdabot> forall a b. (Num a) => b -> [a] -> [a]
17:44:46 <oerjan> > fix ((1:).scanl (+) 1) -- googled it
17:44:48 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:46:38 <allbery_b> aren't there a bunch of fib one-liners in the wiki?
17:47:32 <azories> amm http://ip-adress.com - http://whatismyip.com - http://www.iplobster.com - ipchick.com and so on = any one can explain why the dumb utilizers dont use ipconfig ?
17:47:34 <lambdabot> Title: What is my IP address? Show my IP address. IP Tracer & IP Locator.
17:48:18 <ddarius> > let b = (.); s = ap; k = const; y = fix; c = flip in y(b(b(c(s(:))(k 0))(c(s(:))(k 1)))(s (zipWith(+))tail))
17:48:19 <lambdabot>  Couldn't match expected type `(->) (b -> t)'
17:49:07 <nornagon> is there a way to construct a function that takes either zero or two arguments? I hear printf does it with wacky type hackery.
17:49:10 <chessguy__> @pl n (m,v) = (m,-v)
17:49:10 <lambdabot> (line 1, column 9):
17:49:10 <lambdabot> unexpected "="
17:49:10 <lambdabot> expecting variable, "(", operator or end of input
17:49:11 <allbery_b> azories: they're behind NAT routers
17:49:15 <nornagon> :t printf
17:49:17 <lambdabot> forall r. (PrintfType r) => String -> r
17:49:19 <chessguy__> is there an arrow function for this?
17:49:25 <nornagon> @src PrintfType
17:49:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:49:29 <ddarius> :t let b = (.); s = ap; k = const; y = fix; c = flip in c(s(:))(k 0)
17:49:31 <lambdabot> forall t b. (Num t) => ((b -> t) -> [b -> t]) -> [b -> t]
17:49:55 <ddarius> :t let b = (.); s = ap; k = const; y = fix; c = flip in s(:)(k 0)
17:49:57 <lambdabot> forall a. (Num [a]) => a -> [a]
17:50:01 <oerjan> chessguy: second negate
17:50:11 <ddarius> :t let b = (.); s = ap; k = const; y = fix; c = flip in c s(:)(k 0)
17:50:13 <lambdabot> forall b a. (Num (([a] -> [a]) -> b)) => a -> b
17:50:36 <ddarius> :t let b = (.); s = ap; k = const; y = fix; c = flip in s(c(:))(k 0)
17:50:38 <lambdabot> forall a. (Num a) => [a] -> [a]
17:50:39 <ddarius> Silly me.
17:51:17 <chessguy__> @type second negate
17:51:18 <ddarius> > let b = (.); s = ap; k = const; y = fix; c = flip in y(b(b(s(c(:))(k 0))(s(c(:))(k 1)))(s (zipWith(+))tail))
17:51:19 <lambdabot> forall a d. (Num a) => (d, a) -> (d, a)
17:51:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:51:29 * ddarius is a crappy compiler.
17:52:22 <oerjan> nornagon: you make your function a method of a new typeclass, and make its two possible types instances of that typeclass
17:52:53 <nornagon> oerjan: ah :)
17:53:32 <nornagon> wait, erm
17:54:00 <nornagon> class Something where thingy :: a -> b -> c -- now what?
17:54:24 <oerjan> class Something a where thingy :: a
17:54:52 * SamB wonders how you could implement 6502-style memory busses using Lava... possibly Lava can't handle that...
17:55:25 <hpaste>  chessguy annotated "any hope for this code?" with "my first attempt" at http://hpaste.org/2763#a1
17:55:38 <oerjan> instance Something ZeroArgType where thingy = zeroArgValue
17:56:05 <ddarius> nullary
17:56:06 <oerjan> instance Something (FirstArg -> SecondArg -> Result) where thingy ...
17:56:27 <nornagon> oerjan: thanks :)
17:56:30 <nornagon> oerjan++
17:56:41 <ddarius> instance Something Result where thingy = nullary; instance Something (A -> B -> Result) where thingy = binary
17:57:59 * ddarius makes crazy class, class Foo a | -> a where x :: a
17:58:16 <oerjan> er...
17:58:44 <oerjan> it's sort of logical, but does that compile? :D
17:58:55 <ddarius> I'm pretty sure it does.
17:59:07 <ddarius> Of course, it's pretty much the same as just defining x as a normal value.
17:59:56 <nornagon> oerjan: er, doesn't seem to...
18:00:11 <nornagon> "Illegal instance declaration"
18:00:20 <nornagon> The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables
18:00:28 <nornagon> In the instance declaration for `LPMOp (Writer [Code] ())'
18:00:31 <oerjan> nornagon: you talking about ddarius's crazy class?
18:00:38 <nornagon> no, yours :)
18:00:40 <oerjan> nornagon: you need extensions enabled
18:00:44 <nornagon> ah.
18:00:58 <oerjan> -fglasgow-exts or something
18:01:29 <oerjan> in theory you _could_ rewrite it all horribly to make it legal haskell 98
18:02:40 <oerjan> probably requires two additional classes :)
18:03:15 <jcreigh> whoever put all those nice Haskell packages (libghc6-*-dev) in Debian deserves a pizza or something.
18:05:03 <nornagon> hm, so I made an instance for LPMOp (Writer [Code] ())
18:05:19 <nornagon> now GHC complains "No instance for (LPMOp (Writer [Code] t))"
18:05:23 <sorear> arjanoosting and Igloo, maybe others
18:06:24 <ddarius> nornagon: If it doesn't instantiate the variable to () in use, then it won't use that instance.
18:06:53 <nornagon> um?
18:06:55 <ibid> after installing dctrl-tools and after running sync-available, do "grep-available -Pe ^libghc6- -sMaintainer -n | sort -u" and it will tell you who the people are :)
18:07:00 <oerjan> oh...
18:07:33 <oerjan> that means you may need to add some type declarations
18:07:51 <chessguy> @type maximumBy (compar . snd)
18:07:53 <lambdabot> Not in scope: `compar'
18:07:55 <chessguy> @type maximumBy (compare . snd)
18:07:57 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
18:07:57 <lambdabot>       Expected type: (a, b) -> (a, b) -> Ordering
18:07:58 <oerjan> that's a problem with printf too
18:08:08 <nornagon> it works if i explicitly type the call as :: Writer [Code] ()
18:08:12 <chessguy> @type maximumBy (comparing snd)
18:08:14 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
18:08:30 <eugman> So has any serious game been made in haskell? I mean something a bit deeper than minesweeper.
18:08:46 <ddarius> @google Frag Haskell
18:08:48 <lambdabot> http://www.bluishcoder.co.nz/2005/11/frag-haskell-first-person-shooter.html
18:08:48 <lambdabot> Title: Bluish Coder: Frag: Haskell First Person Shooter
18:09:04 <arjanoosting> hmm pizza :)
18:10:27 <ddarius> @wiki Frag
18:10:28 <lambdabot> http://www.haskell.org/haskellwiki/Frag
18:11:51 <wli> That reminds me.
18:12:38 * allbery_b recalls he was going to go crosseyed trying to figure out Text.Printf again (with the intention of adding ANSI printf specs)
18:13:02 <allbery_b> of course, my record so far mailing darcs patches is rather negative
18:13:23 <oerjan> negative? you got more back? :D
18:13:26 <wli> The interest I had in video games was mostly just art and/or graphic design -type stuff. I wasn't all that interested in the physics (the physics stuff was for the phenomena themselves) or AI (that was frustration from actually playing the things).
18:13:45 * ddarius uses his hand as a magnifying glass.
18:14:30 <wli> Is there enough infrastructure out there to just start editing images etc. and so on?
18:14:53 * allbery_b has tried at lkeast 5 times so far to submit a patch to xmonad
18:14:59 <allbery_b> it keeps arriving corrupted
18:15:00 <ddarius> wli: For a game?  Obviously there are tools to make random graphics.
18:15:11 <sorear> use a better MTA :P
18:16:01 <wli> ddarius: I meant largely to slap together some sort of video game to dump the graphics into (I have a vague idea the texture maps etc. there).
18:16:15 <allbery_b> it's more ike "kick the $cow_orker who broke the mail system on client machines"
18:16:20 <allbery_b> like, even
18:16:32 <allbery_b> this worked when I was managing it :/
18:17:26 <ddarius> There are certainly various game building programs and raw game engines where you can just add skins and textures and such.
18:18:03 <wli> ddarius: Sounds like I just need to dredge those up.
18:35:02 <elliottt> @type mapM
18:35:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:51:24 <kpreid> I wonder if anyone's defined a fmapM
18:51:57 <oerjan> @type Data.Traversable.map
18:51:59 <lambdabot> Not in scope: `Data.Traversable.map'
18:52:07 <dolio> @type Data.Traversable.mapM
18:52:09 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
18:52:10 <kpreid> (Monad m, Foo f) => (a -> m b) -> f a -> m (f b)
18:52:17 <kpreid> ding
18:52:26 <kpreid> thanks. I haven't got a use for it, but...
18:53:41 <dolio> There used to be a FunctorM class, too.
18:53:52 <dolio> With fmapM.
18:54:59 <iskaldur> what is the function that does a sort of cartesian product? eg, something like FOOBAR ["a","b","c"] ["d","e"] = ["ad", "ae", "bd", "be", "cd", "ce"] ?
18:55:32 <oerjan> in this case, liftM2 (++)
18:55:45 <dolio> > liftM2 (++) ["a","b","c"] ["d","e"]
18:55:47 <lambdabot>  ["ad","ae","bd","be","cd","ce"]
18:56:02 <allbery_b> > sequence [["a","b","c"],["d","e"]]
18:56:03 <lambdabot>  [["a","d"],["a","e"],["b","d"],["b","e"],["c","d"],["c","e"]]
18:56:10 <allbery_b> hm, whoops
18:56:42 <straszheim> > [x++y | x<-["a","b","c"],y<-["d","e"]]
18:56:44 <lambdabot>  ["ad","ae","bd","be","cd","ce"]
18:56:47 <Saizan> > sequence . map concat $ [["a","b","c"],["d","e"]]
18:56:49 <lambdabot>  ["ad","ae","bd","be","cd","ce"]
18:56:49 <iskaldur> ah, yes, sequence was  actually the one i was thinking of :)
18:56:51 <oerjan> > mapM join [["a","b","c"],["d","e"]]
18:56:53 <lambdabot>  ["ad","ae","bd","be","cd","ce"]
18:58:58 <dolio> Saizan: What did you think of my delimited continuation intro?
19:01:53 <sorear> dolio: where is it?
19:02:23 <dolio> http://www.haskell.org/haskellwiki/Library/CC-delcont
19:02:24 <lambdabot> Title: Library/CC-delcont - HaskellWiki
19:02:42 <idnar> > map concat $ [["a","b","c"],["d","e"]]
19:02:44 <lambdabot>  ["abc","de"]
19:02:55 <idnar> oh, of course
19:06:08 <Saizan> dolio: i've not finished reading it, but the example of breadth-first with control feels a lot like black magic
19:06:48 <dolio> Yeah. I feel like that one isn't written very well. Probably because I have a pretty shaky understanding of it myself. :)
19:07:30 <dolio> I think I actually found a paper on it, so I should probably read that and then go rewrite that section.
19:09:01 <Saizan> a question: why k takes a (return ()) parameter? couldn't it just be the returned value?
19:10:31 <Saizan> i imagine you might use a different argument in other situations, but..
19:11:29 <dolio> Well, what part bothers you? When it's 'k (return ())' that's because, effectively, the subcontinuation doesn't do anything with the value that gets passed in.
19:11:39 <dolio> Hence the ().
19:12:06 <dolio> The reason the 'return' is there is due to the type of shift/control.
19:12:37 <dolio> The subcontinuation has type 'm a -> m b' not 'a -> m b'
19:13:46 <Saizan> i see, parametrizing away the need for an argument is not worth it
19:17:53 <Saizan> uhm, could not find module Unsafe.Coerce
19:18:11 <dolio> Yeah, that's a 6.7+ thing.
19:18:49 <Saizan> ah, so to compile on 6.6.1?
19:18:56 <dolio> As are type-class interactions with GADTs, which are also used.
19:19:03 <Saizan> ok.
19:19:59 <dolio> Come to think of it, the released library might not compile on 6.7 anymore, either, due to various LANGUAGE pragmas not just turnign on -fglasgow-exts anymore.
19:20:05 <dolio> :)
19:20:26 <dolio> I guess that means I should get my act together and make another release.
19:21:52 <Saizan> haddock doesn't like deriving of MPTCs it seems
19:22:11 <dolio> It doesn't like any generalized newtype deriving.
19:22:16 <dolio> Or GADTs. :)
19:23:13 <dolio> I might be able to tell you how to get it to compile on 6.6.1... hold on.
19:23:35 <Saizan> ok
19:29:01 <dolio> In Control/Monad/CC/Prompt.hs, ad a # to the end of unsafeCoerce, and change the import to GHC.Exts (that seems to have it here).
19:30:00 <dolio> And in Control/Monad/CC/Dynvar.hs, add "MonadDelmitedCont p s m =>" contexts to all the relevant functions.
19:41:15 <Saizan> dolio: worked, thanks :)
19:41:24 <dolio> No problem.
19:42:24 <elliottt> @hoogle [String] -> String
19:42:25 <lambdabot> Prelude.unlines :: [String] -> String
19:42:25 <lambdabot> Prelude.unwords :: [String] -> String
19:42:25 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
19:45:30 <sorear> allbery_b: if it still doesn't work you might try pre-gzipping it to defeat well-meaning MTAs?
19:46:01 <ddarius> Well-meaning MTAs doing what?
19:47:54 <sorear> ddarius: Obfuscating email addresses inside darcs patch files, thus causing mass chaos when multiple versions of a singly-named patch exist
19:50:16 <allbery_b> actually it looks like my final attempt worked, unless it;s actually SuSE's build of darcs that is broken such that darcs send -o created a corrupt patch to start with
19:50:25 <allbery_b> (which would explain a lot of things...)
19:54:32 <sorear> why would anyone do something that horrible?
19:55:26 <allbery_b> cluelessness?
19:56:29 <ddarius> @quote malice
19:56:29 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
19:57:17 <elliottt> @pl \x y z -> x ++ y ++ z
19:57:17 <lambdabot> (. (++)) . (.) . (++)
19:57:50 * allbery_b is testing the patch by putting xmonad on the home box and seeing if the patch applies
19:58:06 <allbery_b> ...not that I can (sanely) build it here
20:01:30 <allbery_b> whew.  it works as received from the list.  (the final attempt which is an attachment from mail.app)
20:09:47 <Olathe> What's the point of pointfree stuff ;) ?
20:10:04 <sjanssen> there are no points, that's the whole point
20:10:16 <dolio> It's sometimes more elegant.
20:10:30 <pgavin> isn't it easier sometimes for the compiler to optimize?
20:10:46 <allbery_b> pointfree (variable-less) expressions admit to some optimizations harder to do with pointful code, supposedly
20:10:55 <allbery_b> (well beynd my level of understanding...)
20:11:22 <ddarius> It's about human reasoning of the code, an algebra of programming, similar to concatenative programming in e.g. Joy and relations to category theory.
20:12:07 <ddarius> Usually not every "parameter" is "abstracted" away, e.g. you get stuff like map f . map g = map (f . g)
20:12:14 <ddarius> Not
20:12:25 <ddarius> @pl \f g x -> map f . map g $ x
20:12:25 <lambdabot> (. map) . (.) . map
20:16:25 <Olathe> @unpl (. map)
20:16:25 <lambdabot> (\ a d -> a (map d))
20:17:11 <Olathe> @unpl ((.) map)
20:17:12 <lambdabot> (\ b c -> map (b c))
20:17:49 <Olathe> My brain !
20:18:41 <shachaf> ((.) map) is (map .)
20:18:55 <Olathe> Is (. map) like (+1) ?
20:19:14 <oerjan> same syntax, yes
20:19:24 <Olathe> @unpl (+1)
20:19:24 <lambdabot> (\ a -> a + 1)
20:19:45 <ddarius> @ \x -> map f (map g x)
20:19:46 <shachaf> Careful with (+), @pl assumes it's commutative.
20:19:51 <ddarius> @pl \x -> map f (map g x)
20:19:51 <lambdabot> map (f . g)
20:20:29 <pjd> Olathe: section syntax, specifically
20:20:48 <shachaf> @where report
20:20:48 <lambdabot> http://www.haskell.org/onlinereport/
20:20:55 <Olathe> So (operator whatsit) argument is the same as argument operator whatsit ?
20:21:29 <oerjan> yep
20:21:34 <Olathe> Alright.
20:21:48 <shachaf> http://www.haskell.org/onlinereport/exps.html#sections
20:21:50 <lambdabot> Title: The Haskell 98 Report: Expressions
20:22:02 <Olathe> Ahh, thanks.
20:57:00 <pjd> @quote qwe1234 the c++ type system is ugly and very ad-hoc, but it's by far and without question the most powerful and expressive one in existence today.
20:57:01 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
20:57:06 <pjd> @remember qwe1234 the c++ type system is ugly and very ad-hoc, but it's by far and without question the most powerful and expressive one in existence today.
20:57:06 <lambdabot> Done.
20:58:41 <omniscientIdiot> qwe1234++ you can't make that stuff up.
20:59:09 <shapr> dons: You're in Minnesota?
20:59:21 <sorear> shapr: Oregon
20:59:28 <sorear> oh, he appeared
20:59:33 <shapr> So why the Minnesota hostname?
20:59:59 <sorear> pjd: can C++ express the fact that + is commuative?
21:00:19 <allbery_b> shapr: that's not reliable as a location indication
21:00:35 <allbery_b> I think it indicates a routing point more than anything else
21:00:41 <shapr> Just wondering.
21:01:08 * allbery_b has seen all sorts of people in the western US show up as .mn.comcast.net
21:02:00 <allbery_b> ...whereas the router that handles .pit1.dsl.speakeasy.net is in washington dc
21:03:05 <dolio> pjd: Is that from somewhere in the 1000x faster thing?
21:04:10 <dons> yo yo
21:04:13 * sorear boggles at the people on the mailing list who not only fail to RTFM before asking, but also fail to RTFM before *answering*
21:04:20 <dons> shapr: oh, weird.
21:04:24 <dons> its normally .or.*
21:04:37 * dons has ghci running on amd64/openbsd :)
21:05:03 <pjd> dolio: yeah
21:05:25 <dolio> pjd: The thing that boggles my mind there is that people try to defend him.
21:05:31 <pjd> actually, there's a better quote:  good c++ code doesn't ever crash -- c++ is practically the only language out there that can give static compile-time safety guarantees.
21:06:01 <pjd> dolio: i would not be surprised if argv is a sock puppet
21:06:25 <dolio> pjd: Yeah, that occurred to me, too. He/she/it seems way too willing to believe whatever qwe says.
21:07:16 * sorear , left to his own devices, would ban everyone who so much as mentions qwe1234.  you're just feeding the troll
21:08:10 <dolio> Some people in general say that he's somehow valuable because he occasionally says something right, and you should look through for the nuggets of wisdom.
21:08:38 <dolio> But I assume they don't read timecube.com every day on the off chance that he started making sense.
21:09:10 <sorear> dolio: Are these people familiar with the infinite-monkey principle?
21:09:35 <sorear> an infintitely stupid monkey ranting for an infinite time will eventually say all truisms
21:10:09 <P_D> clearly they're arguing it's above white noise
21:10:09 <dolio> Presumably.
21:10:41 <Philippa> feeding the troll, playing with the chew-toy, what's the difference?
21:11:04 <omniscientIdiot> most of us do not have the benefit of an infinite period of time.
21:11:05 <dons> Igloo: got patches for unix and Linker.c , which get amd64/openbsd buliding, and ghci working on that platform
21:11:09 <dons> just validating now
21:12:01 <bos> timecube.com is awesome. we need to redesign haskell.org tonight, preferably after drinking a few pints of cough medicine.
21:12:41 <allbery_b> @remember bos timecube.com is awesome. we need to redesign haskell.org tonight, preferably after drinking a few pints of cough medicine.
21:12:41 <lambdabot> Done.
21:13:09 <shapr> Wow, timecube.com is impressive.
21:13:14 <shapr> I like the use of wollow for example.
21:14:09 <jcreigh> I always wonder (hope?) if sites like that are satire.
21:14:51 <straszheim> yah that one is a winner
21:15:04 <dolio> The guy's pretty dedicated if it is.
21:15:40 <P_D> it looks like it was automatically translated from mandarin in 1999
21:16:30 <bos> it's a pretty common style of schizophrenic writing. you'll see the same stilted use of language on bottle's of dr bronner's soap.
21:16:39 <pjd> sorear: i stopped responding to him looong ago
21:16:54 <sorear> pjd: and yet you propagate his remarks
21:17:24 <pjd> his amusing ones :)
21:18:51 <ddarius> For some, not unreasonable, values of "powerful" and "expressive" his statement stands (accepting that it also stands for other type systems too)
21:18:55 <pjd> shapr: MIT invited the timecube guy for a lecture once
21:19:18 * bos curses darcs yet again
21:19:39 <straszheim> http://www.cubicao.tk/
21:19:43 <lambdabot> Title: CUBIC AWARENESS ONLINE - You Must Seek Time Cube!
21:19:46 <P_D> the schizophrenic writing thing appears to have been researched
21:19:51 <bos> execute bit grumble grumble fume
21:20:01 <straszheim> "We must attack the scientists, Academia and religion, or face cannibalism like Easter Island."
21:20:10 <P_D> "mother is not holding completely respect": Making social sense of schizophrenic writing, Human Studies Vol 18 #1 Jan 1995 p 89-106
21:22:43 <Philippa> ddarius: I think they're pretty unreasonable values to use without explicitly stating they're the ones you're using
21:23:30 <P_D> not to a C++ programmer =)
21:24:14 <Philippa> even to most C++ programmers, they're more likely to just not realise that there's any room for improvement
21:26:55 <dolio> Sort of reminds me of the Qi guy who touted its type system as the 'most powerful ever implemented' or something like that a while back, which, as far as I could tell, came down to it being Turing complete.
21:28:44 <ddarius> Did they fix that "issue" in Epigram?  I think they had * : * for a while (for "simplicity"/"convenience")
21:30:36 <omniscientIdiot> timecube.com seems to a lot of almost coherent stuff, if one were inclined to dredge through it.  "The half of Earth seen from space, cannot exist without the opposite half not seen... existing as opposite values."  Has a certain poetic quality.
21:30:50 <P_D> "seems to a lot of almost coherent stuff" ???
21:31:01 <omniscientIdiot> +have :P
21:31:28 <omniscientIdiot> how ironic :)
21:31:46 <straszheim> ooo it gets better
21:31:51 <straszheim> http://chairofwisdom.cubicao.tk/
21:31:53 <lambdabot> Title: Chair of Wisdom - CubicAO
21:31:55 <straszheim> timecube + flash
21:31:59 <mauke> @vixen you are educated stupid
21:32:00 <lambdabot> Yeah
21:32:04 <omniscientIdiot> oh gawd
21:36:17 <mauke> another reason haskell sucks: <jjore> oh further arg, haskell's use of ++ has me reading abigail's code as "the list $flag appended to other stuff" instead of as the increment operator. blech.
21:36:53 * allbery_b offers to send said moron a copy of Icon
21:37:39 <pjd> dolio: to be fair, that Qi statement goes to pains to point out that "powerful" (in the sense of Turing equivalence) need not imply "better"
21:38:18 <pjd> and it does not make the claim without being clear that nothing more Turing equivalence is being referred to
21:39:14 * omniscientIdiot rocks out to the midi music in the timecube flash
21:39:20 <sorear> turing equivalence has a lot of downsides
21:39:26 <dolio> Well, it took me a while to figure out what exactly was meant by "powerful", as I recall.
21:40:12 <dolio> But, I seem to recall people at least giving examples and stuff. And Qi actually seems to have a somewhat novel type system.
21:41:17 <pjd> dolio: are you talking about http://www.lambdassociates.org/advtypes.htm ?
21:41:19 <lambdabot> Title: Advanced Types in Qi
21:41:31 <pjd> it's pretty clear about it, i think
21:41:46 <pjd> it has it in bold and underlined, even :)
21:41:48 <dolio> I don't recall. It was a long time ago.
21:46:35 <jbauman> omniscientIdiot, you should see thymecube.com
21:48:51 <dons> dolio: though it seems rather informal, for a radical type system, doesn't it?
21:49:17 <dons> where are the papers? /me gets nervous about type systems lacking lots of latex ;)
21:49:38 <dolio> Heh. I haven't studied Qi that much, to be honest.
21:50:26 <sorear> WOW
21:50:38 <sorear> chanerr
21:50:43 <dons> i worry they just hacked up some macros in lisp, talk about how its terribly powerful, but don't really say what exactly the type system is
21:50:59 <dolio> Whenever I read stuff by him, I come away with a vague impression that's he's kind of a lone nut. But he seems happy doing what he does.
21:51:08 <wli> dons: What languae?
21:51:14 <ddarius> wli: Qi
21:52:00 <P_D> the pattern matching looks nice in parens anyway
21:52:31 <omniscientIdiot> jbauman: haha.  I was confident in the existance of parodies, but a little dissapointed in the lack of dedication. :)
21:52:32 <wli> I don't know anything about Qi.
21:53:39 <jbauman> omniscientIdiot, i'm guessing that there's only so much parodying you can do before you want to kill yourself
21:54:29 <pjd> dons: isn't Qi's system formally supported as sequent calculus?
21:55:00 <dons> possibly, do you have a reference for that?
21:55:10 <pjd> for sequent calculus?
21:55:24 <dons> for Qi's type theory :)
21:55:33 <pjd> well, http://en.wikipedia.org/wiki/Sequent_calculus has pointers
21:55:34 <lambdabot> Title: Sequent calculus - Wikipedia, the free encyclopedia
21:55:43 <dons> to Qi?
21:56:11 <pjd> re. Qi, there is http://www.lambdassociates.org/webbook/contents.htm
21:56:12 <lambdabot> Title: Contents
21:57:09 <pjd> which is a textbook, but seems to have theoretic discussions and references
21:57:17 <dons> ah ok. that looks better
21:57:44 <pjd> "Note that this HTML page was generated from Word 2000"
21:57:47 * pjd runnes away
21:58:31 <dons> saw that.
21:58:52 <dons> the preferred type setting software of all type system hackers :)
21:59:27 <mauke> please don't say stuff like that when I'm eating :-)
22:00:19 <dons> sorry mauke. i should remember that some people are sensitive to gluten and/or Word.
22:02:28 <ddarius> "Note that this HTML page ...
22:02:28 * ddarius runs away.
22:02:28 <bos> i'm almost ready to put up haskell book web bits for dons and cosmicray to look at. just need to sort out some python config problems with the co-admins of the server i'm using.
22:03:32 <dons> sweet.
22:04:09 * dons delivers to bos a big bag of publishing software guru candy
22:04:35 <bos> oh, i wish i didn't know about all this stuff. i was happier when i could just write latex.
22:05:22 <dons> now you're strong with the dark side. useful!
22:05:29 <Nafai> I can't wait to read what you guys are writing!
22:05:48 <ddarius> It is really cool that O'Reilly is allowing an online version.
22:06:15 <bos> yeah, it will be interesting to see what kind of feedback it gets.
22:06:19 <mauke> what's a good name for an RPG hero (5 characters max)?
22:06:23 <wli> bos: What do you have to use?
22:06:29 <straszheim> ah you guys have an online-oreilly book thing in the works?
22:06:34 <omniscientIdiot> mauke: Crono!
22:06:35 <bos> wli: docbook.
22:06:41 <ddarius> It'll be nice to point newbies at a free online resource rather than saying "Hey, buy our book!"
22:06:47 <pjd> mauke: Monad
22:06:55 <mauke> omniscientIdiot: you win the prize! (also, that was the default selection)
22:07:04 <nornagon> mauke: lamda!
22:07:15 <ddarius> SCHEME
22:07:15 <nornagon> (i know, i know)
22:07:24 <ddarius> FORTH
22:07:24 <dolio> dons: You know, reading more now, the type definitions remind me of epigram.
22:07:28 <nornagon> Arrow
22:07:32 <mauke> Curry
22:07:41 <dons> dolio: yeah, i thought it was a vaguely dependent type system last time i snooped
22:07:56 <omniscientIdiot> The default?  So you're playing CT?
22:07:59 <mauke> ContT (I mean, this game is about time travelling)
22:08:18 <dolio> dons: Although, you're right, there seems to be a lack of papers on what exactly he's doing. I suppose not everyone's a paper writer. :)
22:08:20 <nornagon> hehe
22:08:22 * dons loves setting CPUS=2 on his laptop
22:08:38 <dons> i got ghc built in 10 minutes, _on a laptop_. life is good :)
22:08:59 * ddarius should do a GHC build.  It's been years.
22:09:00 <wli> mauke: There are online resources with the names of ancient people all over them.
22:09:20 <dons> i can heartily recommend these new dual core thinkpads for haskell hacking
22:09:36 <dons> 4G ram and 2 cores doesn't go astray when ghc's at work
22:09:38 <bos> absolutely.  my main workstation is a teeny weeny thinkpad.
22:09:51 <dons> my new one's an x61 -- something like that?
22:09:59 <bos> yes, i have an x60.
22:09:59 <Nafai> dons: Jealous!
22:10:13 <wli> z61t here
22:10:17 <pjd> dons: you're making my desktop machine feel very inadequate
22:10:22 <bos> it's older than yours by half a year or so.  best laptop i've ever owned.
22:10:44 * dolio thought his 2 gigs of ram was pretty good.
22:10:45 <Saizan> 392mb of ram here, i can see how 4G would make a difference..
22:10:53 <dons> these x61's are nicely tricked out.
22:11:05 <ddarius> My laptop is the best laptop I've ever owned... (ignore the fact that it is the only one I've ever owned...)
22:11:16 <bos> i have 2G, it's enough for normal use :-)
22:11:27 <ddarius> @seen gigamonkey
22:11:27 <lambdabot> I saw gigamonkey leaving #haskell-blah and #haskell 4d 5h 12m 34s ago, and .
22:11:29 <dons> yeah, i don't think i've used more than about 300M yet..
22:11:31 <ddarius> @seen gigamonkey_
22:11:31 <lambdabot> I saw gigamonkey_ leaving #haskell-blah and #haskell 2d 9h 27m 26s ago, and .
22:11:34 <dons> i should do some jhc builds
22:11:51 <wli> I don't really own this. It's corporate. I destroy laptops too fast for me to ever put my own money down on one.
22:12:11 * ddarius mostly uses his laptop as a desktop.
22:12:19 <Nafai> I do Java development at work, in addition to running Windows XP in VmWare for Outlook and other Windows programs I need.  Eclipse + VmWare + FireFox + Geronimo + Postgresql + a bunch of terminals makes 2 Gig kind of tight
22:14:09 <bos> i hear good things about virtualbox lately, for people who want non-spendy virtualisation without the pain and suffering of xen
22:14:40 <wli> I run Windows on this thing. I don't hack on desktop/laptop issues and I'd rather have a wireless modem card than a clean conscience.
22:15:20 <bos> most wireless modem cards look like USB modems with a hayes interface
22:15:26 <dylan> the only real problem with development on windows I've noticed is the lack of control-c inside rxvt.
22:15:29 <bos> many run fine under linux
22:16:24 <wli> bos: This is PCMCIA, not USB, plus there's some idiot Verizon app needed to authenticate, which, of course, is Windows-only.
22:16:29 <sorear> but how do you know in advance?
22:16:43 <bos> sorear: the miracle of google?
22:16:56 <Nafai> dylan: "only"?
22:17:32 <dylan> Nafai: everything else was working within one man-day.
22:18:04 <dylan> Nafai: zsh, vim, darc, mutt... it wasn't very painful either. The broken terminal was a bit of a show-stopper, though
22:18:20 <wli> I'm pretty sure Linux has a driver for the device but lacks any sorts of apps for authentication (never mind the actual codes, which are buried who knows where and would need serious reverse engineering to extract).
22:18:39 <pjd> dylan: isn't there a hack to use PuTTY as a terminal?
22:18:52 <dylan> pjd: that might work, actually.
22:19:03 <pjd> (without SSHing to localhost, that is;  although you could do that too)
22:19:11 <dylan> but then I'd have to translate my .Xdefaults colors to putty
22:19:30 <dylan> I was trying to get my ~/ portable to windows.
22:19:41 <pjd> you're a brave man
22:19:43 <Nafai> dylan: Isn't it ironic that to make a "useable" operating system more "usable" you have to bring things over that originated on "non-usable" operating environments?
22:19:44 * dylan is somewhat obsessive about having portable dotfiles.
22:20:13 <dylan> Nafai: unix is more useable as far as I'm concerned.
22:20:36 <Nafai> Sure *nix isn't without its frustrations.
22:20:41 <wli> The window manager on Windows is horrible.
22:20:55 <Nafai> Like just today I was struggling trying to get Xinerama + DRI working
22:20:56 <dylan> and I started out as a windows users.
22:21:16 <Nafai> I've grown quite used to having a dual monitor set up; but I kind of need to do some stuff with Google Earth
22:21:23 <Nafai> Can't figure it out for the life of me :(
22:21:30 <dylan> Nafai: eh, it's a struggle to get 3d acceleration going in windows, unless you have an nvidia card.
22:22:25 <dylan> Nafai: if you're using nvidia and want xinerama and acceleration on both screens you need to enable 'twin view'
22:22:41 <Nafai> My wife actually prefers Linux now; she hates having to reboot in Windows just to use our photo printer
22:22:42 <dylan> if you're using intel, I forget. and if you're using ATI, god help you.
22:22:45 <Nafai> dylan: ATI :(
22:22:47 <wli> Monitors have really come down lately.
22:24:06 <dylan> pjd: oh, putty wouldn't work.
22:24:13 <stepcut> Nafai: virtualbox :)
22:24:24 <dylan> It doesn't run under X11
22:24:35 <pjd> dylan: yes it does :)
22:24:45 <dylan> pjd: really?
22:24:55 <pjd> it's been ported
22:24:56 <Nafai> stepcut: That would solve my problem how?
22:25:05 <dylan> huh. :)
22:25:21 <dylan> Nafai: your wife's problem
22:25:22 <stepcut> Nafai: wouldn't have to 'reboot'... just boot
22:25:38 <Nafai> dylan: Yeah.
22:25:47 <Nafai> Sorry, I was thinking about work problems :)
22:25:57 <dylan> I need to think about sleep.
22:26:16 <Nafai> If only it were legal to run my copy of Windows under vmware/virtual box and on the bare hardware
22:26:17 <pjd> dylan: search down for "Unix source code" on the download page
22:26:35 <pjd> you'll need GTK, i think
22:26:36 <dons> int-e++
22:26:38 <dons> "Dear Haskellers,
22:26:38 <dons> My thanks to people on the irc channel, especially `int-e'.
22:26:38 <dons> With their help, I managed to write a linear equation solver
22:26:39 <dons> using STUArrays."
22:26:58 <dylan> note: the person that wrote plugin/darcs.vim (http://robotics.eecs.berkeley.edu/~srinath/darcs/) deserves a monkey. it's wonderfuly helpful.
22:26:59 <lambdabot> Title: Vim+Darcs
22:27:00 <stepcut> Nafai: ah yes, forgot about that crap :(
22:27:18 <idnar> pjd: by "hack to use PuTTY as a terminal", do you mean pterm?
22:27:28 <pjd> idnar: no idea
22:27:31 <idnar> I wasn't aware that was considered a hack ;)
22:27:41 <Nafai> stupid *grumble grumble* draconian licensing
22:27:42 <idnar> it's built from the same source
22:27:43 <pjd> i think i was thinking about an earlier hack
22:27:48 <idnar> but I'm not sure if there's a windows port of pterm
22:28:24 <dylan> I think co-linux is an easier solutionm for my needs.
22:28:28 <idnar> anyhow, I don't use windows for anything other than gaming
22:28:37 <mauke>   * darcs.vim (Modified December 31, 1969 )
22:28:44 <idnar> so I just dual-boot
22:28:48 <idnar> mauke: yeah, it's awesome
22:28:49 <dylan> mauke: yes, it pre-dates darcs.
22:28:58 <idnar> dylan: *and* vim
22:29:05 <dylan> idnar: well, yeah
22:29:12 <idnar> someone was a major visionary!
22:29:12 <dylan> and vi for that matter.
22:29:23 <dylan> it was written by a psychic
22:30:22 <jbauman> http://web.gccaz.edu/~medgar/puttycyg/ ?
22:30:23 <lambdabot> Title: Mark Edgar - PuTTY patch for Cygwin terminal
22:31:06 <pjd> jbauman: ah, that's the hack i was thinking of, yes
22:31:41 <jbauman> although they say that it doesn't perfectly emulate a regular windows command line, because those are special
22:32:04 <mauke> "special"
22:34:26 <dylan> only proper windiws command lines can capture control-c
22:34:55 <dylan> (as a signal)
22:38:01 <bos> @seen dons
22:38:01 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 11m 22s ago.
22:38:11 <elliottt> @hoogle [Maybe a] -> [a]
22:38:12 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
22:38:17 <bos> dangit, don't tell me dons thoughtlessly went to bed or something.
22:38:42 <wli> heh
22:39:46 <bos> wow, that LU solver is ugly. it would be more readable in fortran.
22:39:49 <Saizan> dolio: re CC-delcont page: some exercises for the reader would be nice
22:40:17 <dolio> Hmm, I guess that's a good idea. I'll have to think of some.
22:40:37 <ddarius> "Exercise 1. Implement ZipperFS"
22:41:20 <Saizan> ah, and how does it relate to logict?
22:41:37 <KatieHuber> suppose I have data D = A | B | C, and [D], is there some nice concise way to get a [D] which only contains As ?
22:41:45 * sorear tries to figure out a way to work delimited continuations into the next incarnation of lambdabot
22:41:47 <ddarius> "Exercise 2. Implement the LogicT primitives in it."
22:42:05 <mauke> KatieHuber: as in subtyping?
22:42:15 <KatieHuber> as in, something nice to pass to filter
22:42:32 <KatieHuber> obviously filter A ds doesn't work, but something like that
22:42:36 <mauke> isA :: D -> Bool; isA A = True; isA _ = False
22:42:38 <mauke> filter isA
22:42:42 <ddarius> KatieHuber: You could define an isA function, or you could derive Data and use toConstr.
22:42:43 <omniscientIdiot> is D in Eq?
22:42:50 <mauke> or filter (A ==) if you derive Eq
22:43:00 <ddarius> Yeah, that's probably best.
22:43:22 <KatieHuber> yeah, unfortunately it's actually like D = A Int | B Float | C Int Float
22:43:26 <KatieHuber> so the Eq trick won't work
22:44:22 <KatieHuber> guess I'll make isA and friends
22:44:22 <ddarius> toConstr would work.
22:44:22 <KatieHuber> @type toConstr
22:44:22 <ddarius> or whatever it is
22:44:22 <lambdabot> Not in scope: `toConstr'
22:44:22 <KatieHuber> not that ;)
22:44:22 <ddarius> :t Data.Generics.toConstr
22:44:22 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> Data.Generics.Basics.Constr
22:45:24 <ddarius> > Data.Generics.toConstr (Just 3)
22:45:26 <lambdabot>  Just
22:46:25 <dolio> Saizan: Was that a question you want an answer to? LogicT can be implmemented using CC.
22:46:48 <dolio> Saizan: It's been a while since I read that portion of the paper, though.
22:47:50 <ddarius> dolio: So set it as an exercise.
22:51:06 <ddarius> What the hell?  How is it finding old virtualbox files?
22:54:41 <elliottt> @pl \x y -> show x ++ show y
22:54:42 <lambdabot> (. show) . (++) . show
22:55:51 <dolio> @type uncurry (++) . join (***) show
22:55:59 <lambdabot> forall b. (Show b) => (b, b) -> [Char]
22:56:37 <elliottt> oooh
22:56:38 <omniscientIdiot> @pl let on f g x y = f (g x) (g y) in (++) `on` show
22:56:39 <lambdabot> (. show) . (++) . show
22:56:39 <elliottt> that's much cleaner
22:56:47 <omniscientIdiot> (++) `on` show
22:58:43 <elliottt> @type on
22:58:46 <lambdabot> Not in scope: `on'
22:58:52 <elliottt> oh, silly me :)
23:00:40 <omniscientIdiot> 'on' is more generally useful, too
23:01:40 <ari> :t \f p -> uncurry f . join (***) p
23:01:42 <lambdabot> forall c b c1. (c1 -> c1 -> c) -> (b -> c1) -> (b, b) -> c
23:02:06 <mauke> @. djinn type  \f p -> uncurry f . join (***) p
23:02:08 <lambdabot> f a b (c, _) = a (b c) (b c)
23:02:13 <elliottt> curry (uncurry f . join (***) p)
23:03:47 <pjd> that's a bit different; it forces the same instance
23:05:31 <dons> Igloo: i just sent you the patches for Linker.c and the unix package needed to get ghc up on amd64/openbsd
23:14:09 <glguy> @users
23:14:09 <lambdabot> Maximum users seen in #haskell: 407, currently: 346 (85.0%), active: 10 (2.9%)
23:16:42 <ddarius> @seen bos
23:16:42 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 36m 56s ago.
23:17:23 <bos> ?
23:18:01 <ddarius> Did/do you use virtualbox with an existing Windows installation (as a guest)?
23:18:55 <bos> nope, sorry
23:35:23 <takamura> hey
