00:01:35 <fax> @hoogle (a -> m [b]) -> [a] -> m [b]
00:01:39 <lambdabot> No matches, try a more general search
00:02:06 <fax> Is there something like concat mapM ?
00:02:32 <dmwit> :t sequence
00:02:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:03:23 <omniscientIdiot> @type (fmap concat .) . mapM
00:03:26 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
00:03:54 <dmwit> :t mapM
00:03:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:04:00 <fax> woah
00:04:01 <omniscientIdiot> use mapM to get an m [[a]], then fmap the concat into the monad
00:04:41 <omniscientIdiot> @unpl (fmap concat .) . mapM
00:04:42 <lambdabot> (\ d g -> fmap concat (mapM d g))
00:04:54 <dmwit> :t let concatMapM f = liftM concat . mapM f in concatMapM
00:04:56 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m [a1]) -> [a] -> m [a1]
00:05:07 <dmwit> Yeah, same idea.
00:05:27 <dmwit> If you use liftM instead of fmap, you reduce the restrictions on your monad.
00:05:57 <omniscientIdiot> A monad which is not a Functor should be wrong
00:06:06 <omniscientIdiot> *should* be :/
00:06:12 <dmwit> Unless I'm lazy.
00:06:14 <dmwit> ...which I am.
00:06:40 <dmwit> And besides, who's to say that your Functor instance has fmap = liftM ?
00:06:51 <omniscientIdiot> the report does
00:06:53 <dmwit> Just because it *could* be doesn't mean it *has* to be, amirite?
00:07:06 <dmwit> omniscientIdiot: Only for instances provided by the standard libraries.
00:07:17 <dmwit> People write their own Functors and Monads all the time.
00:07:44 <lament> you might be confusing the mathematical objects functor and monad with their incomplete specifications as provided by haskell typeclasses :)
00:07:45 <dmwit> On the other hand, I could be talking out of my hat, too.
00:08:13 <omniscientIdiot> "Instances of both Monad and Functor should additionally satisfy the law:
00:08:23 <omniscientIdiot> fmap f xs = xs >>= return . f"
00:08:43 <dmwit> hmph
00:09:14 <omniscientIdiot> IOW, fmap = liftM
00:19:45 <wli> O, for the days when fmap was still called map.
00:20:53 <fax> I use: sequence (map ...)
00:21:02 <omniscientIdiot> @src mapM
00:21:03 <lambdabot> mapM f as = sequence (map f as)
00:21:10 <fax> argh!
00:21:13 <fax> ok thanks
00:21:13 <omniscientIdiot> same thing :)
00:21:20 <fax> and I thought I was starting to understand things :p
00:21:50 <fax> hm :|
00:21:53 <omniscientIdiot> map the as into a list of actions, then sequence them into one action that returns a list
00:22:20 <fax> mapM gives me [a] -> Maybe [[a]]
00:23:02 <fax> no that is the same as sequence (map ..)
00:23:16 <fax> thought I had something else for a sec
00:24:08 <omniscientIdiot> if you want Maybe [a], then fmap the concat function into the Maybe
00:24:25 <omniscientIdiot> fmap concat (x :: Maybe [[a]]) :: Maybe [a]
00:24:44 <omniscientIdiot> (or liftM, if you prefer the name)
00:26:56 <fax> if you only deal with a Monad fmap = liftM
00:27:02 <fax> because a Monad is a Functor ?
00:27:49 <omniscientIdiot> the two names are for the same thing, but unfortunately in Haskell 98 the Monad class does not subclass Functor
00:27:58 <fax> oh ok
00:28:28 <omniscientIdiot> so you'll get two constraints on your type, (Monad m, Functor m) => ...
00:29:00 <omniscientIdiot> (if you use fmap)
00:29:04 <omniscientIdiot> @type fmap
00:29:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:29:06 <omniscientIdiot> @type liftM
00:29:08 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:30:24 <fax> ok so I wrote this: liftM concat $ sequence (map unifyPair equations)
00:30:38 <eck> is it possible to use a where/let within a list comprehension?
00:30:41 <fax> does that make sense because It would take some time for me to decode..
00:30:49 <wli> eck: Yes.
00:30:56 <eck> wli: what is the syntax for it?
00:31:04 <omniscientIdiot> fax: looks right
00:31:35 <wli> eck: Normal syntax within the expression, let clause without "in" in the binding clauses.
00:32:25 <omniscientIdiot> map changes each equation into an action, sequence puts the actions together into one action returning a list, liftM concat concats the list of lists inside in the action.
00:33:01 <fax> thanks :D
00:33:03 <eck> wli: thanks, i got it
00:33:52 <omniscientIdiot> though sequence (map f xs) = mapM f xs, if you want to use it
00:34:15 <fax> augh
00:34:22 <fax> that's true.. I forgot
00:35:32 <omniscientIdiot> these are Maybe actions, right?
00:35:43 <fax> yes
00:36:16 <omniscientIdiot> > sequence [Just 1, Nothing, Just 3] -- remember that Maybe's (>>=) bails out at the first Nothing.
00:36:18 <lambdabot>  Nothing
00:36:26 <omniscientIdiot> > sequence [Just 1, Just 2, Just 3]
00:36:27 <lambdabot>  Just [1,2,3]
00:36:28 <fax> That's perfect
00:36:47 <ADEpt> is there a separate channel for xmonad already? :)
00:45:04 * omniscientIdiot kicks the freenode servers
00:45:29 * fax blames the IRC protocol
00:45:46 <vincenz> moin
00:45:58 <vincenz> netsplit?
00:46:07 <fax> yeah
00:46:17 <omniscientIdiot> er... yeah, kinda :)
00:46:19 <vincenz> seems so
00:46:20 <vincenz> :)
00:48:50 <KatieHuber> If I want qualified module names (like Data.Map) what do I need to do?
00:49:33 * vincenz was just offered a book on women activism in WW1 from amazon through email... I wonder what I read that made them suggest me that o.O
00:49:41 <omniscientIdiot> import qualified Data.Map
00:49:49 <vincenz> KatieHuber: import qualified Data.Map as M
00:49:54 <vincenz> KatieHuber: unless you want the full name
00:49:55 <KatieHuber> I mean, I want to create a module with a . in the name
00:50:07 <vincenz> KatieHuber: oh you want a new name with a .?
00:50:13 <vincenz> KatieHuber: why, if I may ask?
00:50:24 <vincenz> oh... I get it now
00:50:25 <vincenz> :)
00:50:29 <KatieHuber> my source is in like 2 categories
00:50:29 <vincenz> MyDirectory/Foo.hs
00:50:32 <vincenz> MyDirectory.Foo
00:50:40 <KatieHuber> that's all?
00:50:42 <vincenz> yep
00:50:46 <KatieHuber> man, I figured it'd be much harder ^_^
00:51:20 <vincenz> you mean you'd have to use monads?
00:51:27 <omniscientIdiot> also, "module MyDirectory.Foo where ..." at the top
00:51:42 <omniscientIdiot> OH GOD NO MONADS SCARY GO AWAY AAAAAHHHHHHHH!!!!
00:51:47 <KatieHuber> lol vincenz
00:52:15 <vincenz> yes omniscientIdiot makes a good point
00:52:15 <KatieHuber> no, I figured I would have to make an explicit MyDirectory module which imported all the modules in the directory, then reexported them qualified or something ;)
00:52:28 <wli> omniscientIdiot: Oh wow, are you one of the H98 report authors?
00:52:32 <vincenz> KatieHuber: I sometimes do that, but for -different reasons
00:52:35 <omniscientIdiot> heck no
00:52:41 <vincenz> KatieHuber: I have all the modules in MyDirectory public
00:52:49 <vincenz> KatieHuber: then I reimport them in MyDirectory.hs and expose what I want
00:52:55 <omniscientIdiot> wli: where'd you get that idea?
00:53:01 <wli> omniscientIdiot: Sorry, your bit about monads could make people mistake you for one. ;)
00:53:32 <omniscientIdiot> wli: you mean the quote I pulled?
00:53:48 <wli> omniscientIdiot: That, yeah.
00:53:59 <vincenz> Does anyone remember that paper on how to make bindings to other languages through the use of combinators?
00:55:48 <glguy> !ask dons Do you think people are using the Selenium bindings to write Haskell based spam bots?
00:55:53 <glguy> err
00:55:54 <glguy> @ask dons Do you think people are using the Selenium bindings to write Haskell based spam bots?
00:55:55 <lambdabot> Consider it noted.
00:56:24 <hermann_348> pls klick http://www.pennergame.de/ref.php?refid=6460491
00:56:25 <lambdabot> Title: Pennergame
00:56:45 --- mode: ChanServ set +o vincenz
00:56:55 * vincenz mutters
00:56:56 --- mode: vincenz set -o vincenz
00:57:04 <glguy> DON'T CLICK THE LINK please :)
00:57:08 <glguy> he gets credit if you do
00:57:10 --- mode: ChanServ set +o vincenz
00:57:27 <glguy> they are playing a game a few irc channels over
00:57:33 <glguy> where you get points for people clicking your spam
00:57:49 --- mode: vincenz set -o vincenz
00:57:57 <fax> there is like 11 people in #pennergame :/
00:58:03 <fax> wtf
00:58:06 <glguy> vincenz: enjoying the mode switch?
00:58:14 <glguy> :-p
00:59:08 <wli> pennergame?
00:59:09 <vincenz> glguy: was tryng to kick him
00:59:10 <osfameron> report #pennergame to freenode ops?
00:59:11 <vincenz> then ban him
00:59:18 <vincenz> osfameron: yes
00:59:37 * vincenz groans....a webpage on mozilla.com just made my browser hang
01:00:28 <quicksilver> vincenz: I don't remember that paper but it sounds intersting
01:01:12 <vincenz> quicksilver: I believe it was on ltu.  I was wondering how applicable it'd be to get a 2-way lua-binding
01:01:13 <glguy> There never seem to be any ircops online when I check (/stats p)
01:02:37 <Auris-> glguy, there was some other way to do that when /stats p reported nothing. it should be on the relevant help page (whichever it was).
01:02:52 <glguy> yeah: /who freenode*
01:02:59 <glguy> to find people with staff hostmasks
01:04:34 <Auris-> maybe they are supposed to drop the ircop status when not doing anything withit.
01:08:39 <vincenz> no available staff
01:08:46 <vincenz> #freenode has no +s
01:09:07 <vincenz> glguy++
01:09:45 <glguy> !ask dons Do you think people are using the Selenium bindings to write Haskell based spam bots?
01:09:47 <glguy> errr
01:09:57 <glguy> 01:06  kloeri> glguy_: most of the pennergame people are nice and don't spam
01:09:57 <glguy>                and the ops have a good attitude towards this problem as well so
01:09:57 <glguy>                we try to handle problems on a case by case basis pretty much
01:11:36 <fax> @hoogle (a -> a) -> [a] -> [a]
01:11:36 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
01:11:36 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
01:11:36 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
01:12:10 <fax> @hoogle (a -> a -> a) -> [a] -> [a]
01:12:11 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
01:12:11 <lambdabot> Prelude.scanr1 :: (a -> a -> a) -> [a] -> [a]
01:12:11 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
01:20:52 <glguy> Pidgin is a lousy IRC client!
01:21:32 * glguy reverts to irssi
01:25:47 <quicksilver> vincenz: I put a mostly-automatic two way lua binding together with C++ template magic once
01:26:00 <quicksilver> vincenz: typeclass magic is a lot more powerful than C++ template magic, so it should be possible
01:27:16 <vincenz> quicksilver: could I have a look?
01:27:39 <quicksilver> vincenz: in principle, certainly. However it was some years ago on a different machine so I'd have to go find it :)
01:27:54 <vincenz> ok :)
01:30:06 * vincenz wants a new keyb
01:30:09 <vincenz> any suggestions?
01:30:59 <vincenz> Mainly to cure deviation
01:31:18 <osfameron> deviation?
01:31:36 * vincenz was using terminology from a keyboard website.
01:31:43 <vincenz> Basically your wrist having to turn sideways
01:31:46 <glguy> I really like my Kinesis keyboard
01:31:59 <vincenz> glguy: I looked at it, but that doesn't cure deviation afaict
01:32:03 <glguy> ah
01:32:05 <vincenz> http://www.safetype.com/deviation.htm
01:32:06 <lambdabot> Title: Safetype Keyboard Design - Deviation
01:32:07 <vincenz> this thing
01:32:13 <glguy> that's the vertical keyboard?
01:32:18 <vincenz> (p.s.: I don't like the keyb from that site)
01:32:22 <vincenz> glguy: no, that is what deviation is
01:32:25 <vincenz> but yeah, same site
01:32:42 <vincenz> basically my left wrist has to turn left a lot to fit on my laptop
01:33:08 <glguy> yeah, laptop keyboards are lousy for lots of typing
01:33:13 * glguy is on one now :-/
01:33:52 <vincenz> So wll kinesis cure that?
01:34:01 <vincenz> IT doesn't seem that it would since the ditches aren't angled
01:34:27 <LeCamarade> Me, I guess I should learn to type gentler. My finger - the one I use to hit left Shift, especially - hurts at times. :o(
01:34:33 <omniscientIdiot> http://www.typematrix.com/ looks interesting; unique if anything
01:34:34 <wli> I'm using laptop keyboards far too much... I'm in a world of pain.
01:34:36 <lambdabot> Title: TypeMatrix Home Page*
01:34:42 <vincenz> same
01:34:46 <vincenz> my left wrist often cracks
01:35:38 <fax> if you use emacs for a week you will be able to handstand on your pinky though
01:36:06 <osfameron> vim ftw!  (less chording)
01:36:12 <kfish> fewer combinators use, try
01:36:13 <vincenz> ++
01:36:37 <vincenz> glguy: so would it help with that?  They don't seem slanted from a topview, though they are further apart
01:36:51 <glguy> I don't know if it would
01:36:58 <glguy> I really like how it positions my hands
01:37:03 <glguy> but I don't know if it would address your situation
01:38:37 <vincenz> This is a test on a usb keyb
01:38:56 <LeCamarade> I see they also have a mouse.
01:39:27 <vincenz> what about datahand?
01:39:34 <LeCamarade> I mourn the passing of the trackball, my first pointing device. I saw nothing wrong with it.
01:40:22 <sieni> trackball <3
01:40:34 <sieni> I've been very satisfied with my logitech marble mouse
01:41:16 * LeCamarade wants an Apple Mighty Mouse!
01:41:17 <vincenz> glguy: you're not going to hac2 by any chance with that keyb, are you?
01:41:28 <fax> LeCamarade: Don't buy one!
01:41:38 <glguy> no
01:41:42 <LeCamarade> fax: :-o
01:41:48 <fax> LeCamarade: The scroll ball needs cleaned every week or two
01:41:50 <vincenz> 300 dollars is steep to buy without trying first
01:41:57 <glguy> I like the strong click sound my mighty mouse makes
01:42:02 * kfish plugs in a trackball
01:42:03 <glguy> but it isn't comfortable for long term use
01:42:04 <fax> It's fine otherwise..
01:42:09 <vincenz> glguy: do you use subwoofers for that?
01:42:15 <glguy> heh
01:42:15 <fax> but having to clean every week is not acceptable
01:42:17 <LeCamarade> glguy: Plus that no click actually happens. :o)
01:42:48 * osfameron likes laptop trackpad as pointer device... much less stressful than mouse
01:42:49 <LeCamarade> fax: Tell the Apple guys. ;o) I like geeks who know that geeking is 99% art and beauty. Or should be.
01:42:57 <fax> heh
01:42:58 <vincenz> osfameron: I hate those things
01:43:06 <glguy> mighty mouse has a huge deficiency
01:43:11 <glguy> you can't right and left click at the same time
01:43:25 <osfameron> vincenz: yeah, seems to polarize opinion.  Like the thinkpad pointing nipples
01:43:26 <fax> when do you ever wanna do that?
01:43:32 <LeCamarade> glguy: Wow. I have never done that, though.
01:43:35 <fax> some computer games?
01:43:37 <glguy> eyah
01:43:37 <vincenz> osfameron: trackpads don't work for ;e
01:43:39 <glguy> games
01:43:47 <vincenz> osfameron: they get more in the way when I type if anything
01:43:51 <glguy> but I have a logitech mouse I use for games
01:43:57 <fax> glguy: make middle button = left & right click maybe?
01:44:02 <fax> though I am not certain how
01:44:07 <glguy> fax: no, I use tha for zoom
01:44:13 <glguy> say hold left click down for zoom
01:44:15 <glguy> errr middle
01:44:18 <glguy> and then shoot with left
01:44:36 <vincenz> logitechs are nice, I have a smaller one that I bring with my everywhre, always use it with lappy
01:44:47 <osfameron> vincenz: oh, I never had that problem at all.  Though with previous version of ubuntu the synaptic drivers were misconfigured I goterroneous  clicks while moving the pointer, but never while typing
01:44:57 <LeCamarade> EyeTrack (TM) !!!
01:45:20 <vincenz> osfameron: I can't use it at all, and when I type sometimes I go out of focus cause I accidentally pressed over t
01:45:25 <LeCamarade> iEyeTrack - Blink to Click.
01:45:43 <vincenz> LeCamarade: and to not click?
01:45:57 <LeCamarade> vincenz: Look away. :o)
01:46:11 <LeCamarade> Or hold tongue out. =))
01:46:55 <vincenz> LeCamarade: so then you'd really be drooling when staring at porn?
01:48:25 <LeCamarade> vincenz: Well,literally, yes.
01:49:07 <fax> My source code is like this: substitutions equations = [] ------------ Write this
01:50:47 <vincenz> damn, glguy left
02:09:51 <greenrd> How much RAM do the ghc 6.8.1 snapshots require to build in a reasonable amount of time?
02:13:03 <quicksilver> I'd be suprised if you needed more than 512M real + some swap
03:15:17 <Mitar> what would be proper syntax for this:
03:15:18 <Mitar> let a = [x | let x = 2^alpha * 3^beta * 5^gamma * 7^delta, alpha <- [0..], beta <- [0..], gamma <- [0..], delta <- [0..], x <= 405]
03:17:46 <quicksilver> Mitar: you can't "let x" until after you've defined alpha beta gamma and delta
03:18:00 <quicksilver> Mitar: just move the "let x" to after the delta part
03:18:33 <Mitar> thanks
03:19:07 <Mitar> great ... it loops :-)
03:19:23 <dpn`> could i safely assume 2.14618471906e-16 == 0?
03:19:39 <dpn`> after doing a rather long series of floating point operations
03:19:43 <fax> 2.14618471906e-16 <= 2.14618471906e-16
03:20:01 <dpn`> thanks :P
03:20:11 <matthew-_> f = filter (< 405) [ let x = 2^α * 3^β * 5^γ * 7^δ in x | α <- [0..], β <- [0..], γ <- [0..], δ <- [0..]]
03:20:20 <Mitar> > [x | alpha <- [0..], beta <- [0..], gamma <- [0..], delta <- [0..], let x = 2^alpha * 3^beta * 5^gamma * 7^delta, x <= 405]
03:20:25 <lambdabot> Terminated
03:20:44 <matthew-_> oh, you can put filters back there?
03:20:57 * matthew-_ goes to read list comprehension syntax again
03:20:59 <quicksilver> you can indeed
03:21:15 <quicksilver> Mitar: it doesn't iterate infinite lists fairly
03:21:21 <Mitar> yes ...
03:21:28 <Mitar> and a fix is
03:21:30 <Mitar> ?
03:21:30 <matthew-_> yeah, convert that to breadth first...
03:21:47 <quicksilver> don't use infinite lists in the list monad
03:21:50 <quicksilver> (well, not more than one)
03:22:15 <matthew-_> α <- [0..], β <- [0..α] etc
03:22:28 <quicksilver> although if you're interested, here's a different list monad:
03:22:30 <quicksilver> http://hpaste.org/2903
03:22:47 <quicksilver> which correctly makes progress through an infinite list of infinite lists
03:22:56 <quicksilver> (by a back-and-forth bottom left-diagonal)
03:23:19 <Mitar> is it in any library?
03:23:26 <quicksilver> nope
03:23:38 <quicksilver> it exists only in my head, and usual retails for $1000
03:23:46 <quicksilver> but for ONE DAY ONLY you can have it ABSOLUTELY FREE!
03:24:02 <matthew-_> can I resell it for $1000 ?
03:24:16 <STreggae> i have been trying to find to find a good guide on tail recursion in haskell ?
03:24:27 <STreggae> Can you point to one ?
03:25:08 <STreggae> I have the Craft of Functional Programming using haskell, but it ain't in here ?
03:28:07 <STreggae> can anyone help me with a tree recursion problem
03:28:09 <STreggae> ???
03:29:03 <osfameron> STreggae: why don't you paste the problem to hpaste and see if someone offers suggestions
03:29:17 <osfameron> STreggae: to http://hpaste.org/new
03:29:30 <SamB_XP> what is tail recursion again ;-P?
03:30:13 <fax> Do you write (map snd (tail equations)) or (map snd $ tail equations) ?
03:31:02 <DRMacIver> map . snd . tail $ equations
03:31:20 <DRMacIver> Oops
03:31:26 <DRMacIver> Ignore the first . :)
03:31:42 <SamB_XP> DRMacIver: pay me!
03:31:57 * DRMacIver gives SamB_XP a cookie
03:32:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2920
03:32:18 <SamB_XP> DRMacIver: do you need to know my address?
03:32:31 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2920#a1
03:33:15 <fax> (anonymous): take a look at http://www.willamette.edu/~fruehr/haskell/evolution.html
03:33:16 <Mitar> liftList (filter (<= 405)) $ do { alpha <- DiagList [0..]; beta <- DiagList [0..]; gamma <- DiagList [0..]; delta <- DiagList [0..]; return $ 2^alpha * 3^beta * 5^gamma * 7^delta}
03:33:18 <lambdabot> Title: The Evolution of a Haskell Programmer
03:33:19 <Mitar> still loops
03:35:01 <DRMacIver> SamB_XP: It's an eCookie.
03:35:18 <SamB_XP> DRMacIver: I don't have a cookie printer!
03:35:19 <quicksilver> Mitar: works fine for me
03:35:24 <quicksilver> Mitar: well it's an infinite list
03:35:28 <quicksilver> of course
03:35:35 <quicksilver> but I can view, e.g., the first 10 elements of it
03:35:38 <STreggae> tail recursion on finding the factorial of a number
03:36:06 <Mitar> but smaller or equal than 405 is finite
03:36:13 <quicksilver> Mitar: yes, but the code doesn't know that :)
03:36:20 <Mitar> and how could i make ti know that?
03:36:23 <quicksilver> > filter (<10) [1..]
03:36:28 <lambdabot> Terminated
03:36:48 <matthew-_> some magic with enum ?
03:37:00 <quicksilver> embed a general numeric theorem prover into your code?
03:37:01 <DRMacIver> SamB_XP: I'd be happy to sell you one for only $999.99.
03:37:02 <SamB_XP> Mitar: for all it can tell, the millionth element of the original list might be less than 405...
03:37:06 <matthew-_> and a more restricted version of filter
03:37:25 <SamB_XP> DRMacIver: this is not the proper method of bribing me not to laugh at you!
03:37:41 <matthew-_> splitAt should do it
03:38:05 <quicksilver> if you believe it's monotonically increasing?
03:38:09 <quicksilver> which it isn't
03:38:31 <matthew-_> well you'd need to assume that if you want it to work at all wouldn't you?
03:38:48 <DRMacIver> SamB_XP: Oh well.
03:38:50 <SamB_XP> > filter (<405) (repeat 1)
03:38:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:39:15 <quicksilver> matthew-_: assuming something which isn't true can make lots of tasks appear easier
03:39:25 <matthew-_> quicksilver: indeed ;-)
03:39:26 <quicksilver> matthew-_: however, given that in fact it isn't true... it's a poor assumption
03:39:28 <Axioplase> :)
03:39:28 <quicksilver> ;)
03:39:56 <matthew-_> so simplify the problem until that fact becomes true :p
03:42:42 <STreggae> let { fac 0 = 1; fac n | n > 0 = n * fac (n-1) } in fac 5
03:43:30 <STreggae> let { fac 0 = 1; fac n | n > 0 = n * fac (n-1) } in fac 5777
03:44:32 <fax> gr I got stuck :/
03:44:47 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2921
03:46:22 <fax> > let { fac 0 = 1; fac n | n > 0 = n * fac (n-1) } in fac 5006
03:46:34 <lambdabot>  6634949341902814337916519864546097961149021484037629442209212097050967966200...
03:48:29 <KatieHuber> what's with the guard in the second case of fac, fax?
03:48:48 * fax didn't write it
03:49:50 <kaol> > let { fac 0 = 1; fac n | n > 0 = n * fac (n-1) } in fac -1
03:49:52 <lambdabot>   add an instance declaration for (Num (t -> t))
03:49:52 <lambdabot>     In the expression:
03:49:52 <lambdabot>      ...
03:50:11 <kaol> > let { fac 0 = 1; fac n | n > 0 = n * fac (n-1) } in fac (-1)
03:50:13 <lambdabot>   Non-exhaustive patterns in function fac
03:50:27 <kaol> > let { fac 0 = 1; fac n = n * fac (n-1) } in fac (-1)
03:50:29 <lambdabot>  Exception: stack overflow
03:50:42 <KatieHuber> not tail-recursive?
03:51:08 <KatieHuber> or just building a nice big thunk somewhere?
03:51:44 <fax> > product $ map (0-) $ [1..]
03:51:48 <lambdabot> Terminated
03:52:08 <KatieHuber> it's a cyclops smiley!
03:52:11 <fax> fac is not tail recursive
03:52:30 <KatieHuber> oh, obviously not.  duh.
03:52:37 <vincenz> stupid Q: Do you think that for hac2, doing a 2 way binding to and fro lua would be useful?
03:54:59 <njbartlett> matthew-_: Did you get the upload?
03:57:00 <ToRA> njbartlett: matthew is out atm, i'll prod him to prod you when he get's in
03:57:24 <njbartlett> ToRA: Okay thanks
04:02:49 <vincenz> So would that be useful?
04:11:51 <DukeDave> Hey hey, anyone going to the Haskell workshop at ICFP on Sunday?
04:13:51 <Igloo> Yes
04:14:20 <fax> @pointless (\(x, y)->(f x, f y))
04:14:20 <lambdabot> f *** f
04:14:50 <DukeDave> Excellent, would you like to be my friend :)
04:16:38 <vincenz> @poll-help
04:16:38 <lambdabot> Unknown command, try @list
04:16:39 <vincenz> @poll
04:16:39 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
04:16:48 <vincenz> @poll-add 'Lua embedding into Haskell'
04:16:49 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
04:16:56 <vincenz> @poll-add "Lua embedding into Haskell"
04:16:56 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
04:17:00 <vincenz> do
04:17:06 <vincenz> @poll-add LuaEmbeddingIntoHaskell
04:17:06 <lambdabot> Added new poll: "LuaEmbeddingIntoHaskell"
04:17:11 <vincenz> @vote-add
04:17:11 <lambdabot> Unknown command, try @list
04:17:14 <vincenz> @choice-add
04:17:14 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
04:17:21 <vincenz> @choice-add LuaEmbeddingIntoHaskell Useful
04:17:21 <lambdabot> New candidate "Useful", added to poll "LuaEmbeddingIntoHaskell".
04:17:25 <vincenz> @choice-add LuaEmbeddingIntoHaskell NotUseful
04:17:25 <lambdabot> New candidate "NotUseful", added to poll "LuaEmbeddingIntoHaskell".
04:17:51 <fax> :t (***)
04:17:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:17:56 <arcatan> in soviet russia, haskell is embedded into lua
04:18:17 <vincenz> @choice-add LuaEmbeddingIntoHaskell DontCare
04:18:17 <lambdabot> New candidate "DontCare", added to poll "LuaEmbeddingIntoHaskell".
04:21:05 <vincenz> votes would be nice :)
04:21:43 <fax> lua is nice for games
04:21:54 <fax> anyone writing a computer game might like a lua bindin
04:22:05 <fax> but they maybe prefer a language written in haskell
04:22:33 <vincenz> you mean a dsl
04:22:43 <vincenz> not to mention, with a parsec-parser
04:22:59 <vincenz> the problem is that then each time you're inventing a new language
04:23:09 <fax> no I don't mean a DSL
04:23:19 <fax> I mean Lua implemented in haskell
04:23:22 <fax> or something similar to Lua
04:23:37 <vincenz> well implementing itin haskell doesn't solve the main issue, namely communication
04:23:46 <vincenz> you can easily implement a version in ahskell and use a datatype like
04:23:52 <vincenz> data LuaValue = LuaNil | LuaBool Boolean | LuaNumbmer Double ...
04:24:05 <vincenz> but then it becomes rather hard to use std haskell functions on these types, or passing haskell functions to the lua
04:24:13 <vincenz> without adding a lot of custom glue for -each- function
04:25:40 <vincenz> but I guess, fax, your vote is more towards NotUsefl or DontCare?
04:26:11 <fax> I think having a good scripting language like lua is really useful
04:26:26 <fax> but Lua is implemented in C.. so I would only use it from C
04:26:35 <fax> what I think is best is to write something like lua in haskell
04:26:37 <quicksilver> why?
04:26:41 <vincenz> you can sue ffi
04:26:43 <quicksilver> what would be the benefit of that?
04:26:48 <fax> you don't have to use FFI
04:26:49 <vincenz> the focus is not on the interpreter, but the communication
04:27:13 <vincenz> and I'm considering doing this at Hac, but only if ther'es interest
04:27:17 <SamB_XP> I don't really think implementing it in Haskell would make it that much easier
04:27:33 <vincenz> agreed
04:27:47 <vincenz> a bit of FFI gets you the same.  But again, the focus is on a proper way of communication :)
04:27:52 <fax> I don't think it would easier
04:27:55 <fax> either
04:28:04 <quicksilver> having a cute minilanguage for application scripting is nice
04:28:14 <quicksilver> I'm undecided whether the right approach is a separate language like lua
04:28:21 <quicksilver> or a subset of haskell, with hs-plugins
04:28:28 <pejo> fax, having someone else maintain the lua-part is definitely nice from a maintainance burden pov.
04:28:35 <quicksilver> (or, (c) write your own custom language every time)
04:28:50 <SamB_XP> quicksilver: that's the ugly path
04:28:52 <vincenz> quicksilver: the issue with hs-plugis is state persistency when you do live scripting
04:29:03 <quicksilver> SamB_XP: which is the ugly path?
04:29:16 <SamB_XP> create your own custom language every time
04:29:16 <quicksilver> vincenz: don't think I follow?
04:29:18 <fax> http://www.haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
04:29:21 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2868t9
04:29:26 <SamB_XP> because you're fairly likely to start by accident
04:29:29 <fax> vincenz: Why not pick a language from there instead of Lua?
04:29:34 <quicksilver> SamB_XP: Ah right. Well, it depends on your motivations
04:29:44 <quicksilver> SamB_XP: writing a custom language is very educatig and interesting
04:29:46 <vincenz> fax: because an interpreter in haskell is orthogonal to the issue
04:29:47 <SamB_XP> and that almost never results in a very pretty language ;-)
04:30:05 <fax> vincenz: So you are just as easy to use one from there as Lua?
04:30:05 <sieni> there's already lua-ml... perhaps that could be ported to haskell
04:30:21 <vincenz> fax: and since I'd be doing this, I have a pref for lua
04:30:27 <fax> oh ok then, go for it
04:30:35 <vincenz> but again, only if people would find it useful
04:30:49 <SamB_XP> vincenz: what sort of communications were you looking for?
04:31:02 <vincenz> SamB_XP: well for instance, it'd be nice if you could pass haskell functions into lua
04:31:08 <vincenz> (and viceversa)
04:31:09 <SamB_XP> vincenz: well, yes.
04:31:21 <SamB_XP> well, to be more specific, what kinds of functions?
04:31:25 <vincenz> I remember a paper dealing with a combinator language for this
04:31:26 <quicksilver> I think the best competitor to lua might be ECMAscript
04:31:32 <quicksilver> or a subset of ECMAscript
04:31:32 <SamB_XP> what would their types be?
04:31:39 <matthew_-> njbartlett: yes, I did
04:31:41 <SamB_XP> quicksilver: we call it javascript usually...
04:31:45 <vincenz> SamB_XP: that I'm not fully clear on yet.
04:32:03 <SamB_XP> vincenz: well, would you need to be able to call them at multiple types?
04:32:04 <quicksilver> SamB_XP: sometime people do, but that name carries baggage I wanted to avoid
04:32:17 <SamB_XP> quicksilver: oh?
04:32:19 <njbartlett> matthew_-: welcome back
04:32:26 <vincenz> SamB_XP: I think the paper on ml-schme communication and blame is interesting
04:32:30 <SamB_XP> the ecmascript name has baggage too
04:32:48 <vincenz> SamB_XP: namely, if you pass a strictly typed haskell function to lua, obviously it should only work with lua values of a corresponding type
04:32:56 <matthew_-> njbartlett: howdie. yeah, I probably got it - I'll have a poke around in just a minute
04:33:03 <SamB_XP> vincenz: well yeah
04:33:10 <SamB_XP> but would you be content to pass those?
04:33:39 <vincenz> SamB_XP: I'm not sure I udnerstand what you mean to imply with that question
04:34:35 <SamB_XP> would you be happy if that was the only kind of Haskell function you could pass to lua?
04:34:48 <vincenz> SamB_XP: erm, are there any other haskell functions?
04:35:38 <SamB_XP> nevermind...
04:37:49 <vincenz> do you mean passing in polymorphic functions?
04:39:18 <quicksilver> the other question is how much you restrict the types
04:39:34 <quicksilver> for example, can you only pass in functions of some special 'LUADouble' type
04:39:44 <vincenz> well no, you'd use embedding and projections
04:39:47 <vincenz> LuaDouble <-> Double
04:40:01 <quicksilver> given that the normal procedure is to compile your own lua
04:40:04 <quicksilver> you can choose the number type
04:40:09 <vincenz> not true
04:40:14 <quicksilver> you could choose it to match haskell Double, I think
04:40:14 <vincenz> since haskell would be using the lua interpreter
04:40:18 <vincenz> one implemention would have to be in the ffi
04:40:25 <vincenz> meaning the one whose number type we choose
04:40:53 <quicksilver> I've seen luas compiled where all numbers are integer, as well as luas compiled for floating point
04:41:02 <quicksilver> lua internally just has 'number' doesn't it?
04:41:26 <vincenz> quicksilver: right but that requires patching the core libs, you could easily ship 1-version of the lua lib with the library that is guaranteed to use doubles
04:41:58 <quicksilver> I've only seen lua used in a couple of projects, and I think they both patched lua
04:42:03 <vincenz> (changing the number type requires changing the core interpreter and recompiling it)
04:42:08 <quicksilver> I had the impression that was a common way to proceed
04:42:19 <vincenz> I can ask how common it is
04:42:33 <vincenz> heh
04:42:37 <vincenz> we could spin one based on Integer :)
04:42:47 <quicksilver> unfortunately standardising on double and standardising on int are both pretty unsatisfactory
04:42:49 <vincenz> bigints :)
04:42:57 <quicksilver> because there are times when you want floating point and times when you don't
04:43:11 <vincenz> then make it an option to the compilation of the whole haskell module
04:43:18 <SamB_XP> hahaha
04:45:13 <quicksilver> but I think double throughout is probably the simplest option
04:45:45 <SamB_XP> didn't perl used to work that way?
04:51:45 <fasta> How can I somehow force Parsec to only succeed when the complete input has been used?
04:52:38 <pejo> quicksilver, are you thinking of world of warcraft, and qc-- as projects that use lua?
04:53:08 <quicksilver> pejo: no
04:53:08 <vincenz> fasta: parse an eof?
04:53:22 <fasta> vincenz: yes, I suspected that.
04:53:43 <fasta> vincenz: thanks for reassuring
05:20:35 <fax> :/
05:20:59 <fax> any suggestions how to do this.. like if I had a list [1, 2, 3, 4]
05:21:22 <fax> I want to do [1] ++ (f 1 [2, 3, 4])
05:21:49 <fax> after that, (f 2 [1]) ++ [2] ++ (f 2 [3, 4])
05:21:55 <fax> and so on, for each element
05:22:14 <fax> I did it by cycling the list around each time, and just workign with the first.. repeating 4 times
05:22:19 <fax> seems really bad though
05:25:13 <quicksilver> fax : (f (l!!n) (take (n-1) l)) ++ [l!!n] ++ (f (l!!n) (drop n l))
05:25:20 <quicksilver> fax: where 'l' is the list and 'n' is the index
05:25:44 <fax> Do you think that's an ok way to do what I wanted to do though?
05:26:25 <dolio> let g n [] = [] ; g n l = f n l in [ g e a ++ [e] ++ g e b | (a, e:b) <- zip (inits l, tails l) ]
05:26:25 <quicksilver> well my way doesn't require cycling or anything
05:26:28 <dolio> Something like that, maybe.
05:26:40 <quicksilver> you just map my version over all indexes n
05:27:06 <fax> oih ok
05:27:10 <dolio> Oops, that zip is wrong.
05:27:11 <fax> I explained it a bit wrong
05:28:04 <fasta> Parsec contains a "float" function in Text.ParserCombinators.Parsec.Token, but it accesses a record. How can I just get a parser that parses a float without writing it myself?
05:28:14 <fax> thanks
05:30:34 <DRMacIver> fax: You need to provide it with a language definition.
05:30:40 <DRMacIver> err. fasta ^^
05:31:21 <DRMacIver> fasta: Or rather a token parser from a language definition. float $ makeTokenParser haskellDef will do what you want for example.
05:31:48 <fasta> DRMacIver: will an empty definition work?
05:32:14 <fasta> DRMacIver: since of coruse I need a language definition. The question is whether a trivial one is enough
05:32:19 <DRMacIver> fasta: I don't think so. But there are various predefined language definitions you can use.
05:33:44 <fasta> DRMacIver: forgive me, but that does sounds a bit like a lame construction.
05:35:24 <DRMacIver> I don't understand Parsec well enough to comment on that. :) But I imagine there are different edge cases in parsing floats in different language definitions. It's certainly the case that most of the other token parsers do.
05:35:42 <DRMacIver> err. other things which rely on specific token parsers.
05:35:53 <DRMacIver> But it's possible that there's a much better approach of which I'm simply not aware.
05:36:53 <fasta> DRMacIver: oh, maybe it is, but I think that providing a function in the library that parses floats would be nice.
05:37:53 <fasta> Well, Parsec was an academic exercise biased to implementing toy languages. One cannot expect anything different.
05:38:06 <Mitar> how can i devide Integer values?
05:38:11 <Mitar> divide
05:38:19 <fax> fasta: what
05:38:34 <fax> fasta: It's pretty easy to write a float parser with parsec
05:38:36 <quicksilver> Mitar: `div`
05:38:42 <fasta> fax: that's not the point
05:38:44 <fax> fasta: I did it, you probably can too
05:38:51 <fasta> fax: I have already done it once
05:38:56 <fax> fasta: You might be able to do it without insulting the parsec author too
05:38:57 <Mitar> ah, yes ..
05:39:34 <DRMacIver> fasta: It does provide a function in the library which parses floats. It provides several. They're encapsulated in language definitions. :)
05:39:42 <fasta> fax: there's nothing insulting about it.
05:39:52 <Philippa> there is when it's /wrong/
05:39:58 <DRMacIver> (Parsec really feels like it's crying out for ML style functors to me)
05:40:04 <Philippa> yeah, definitely
05:40:30 <Philippa> parsec was a practical exercise performed by an academic with an interest in building something suitable for non-toy problems
05:40:48 <Philippa> what it /wasn't/ was funded to the point you can expect it to include every last item on a wishlist
05:41:04 <fasta> I can agree with that.
05:42:41 <fasta> What are the requirements for uploading to Hackage anyway? None?
05:46:10 <fasta> I'd rather have a list of 30/40 packages that do everything they tell they do (be it little) correct than a list of 300 crappy packages or ordered by some criteria (e.g. stability, number of users, etc). Looking at some packages makes me think of some Perl packages on CPAN...
05:51:29 <fax> @hoogle (a -> a) -> a -> a
05:51:30 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
05:51:30 <lambdabot> Control.Monad.Reader.local :: MonadReader r m => (r -> r) -> m a -> m a
05:51:30 <lambdabot> Control.Monad.Writer.censor :: MonadWriter w m => (w -> w) -> m a -> m a
05:53:06 <DRMacIver> @type ($)
05:53:09 <lambdabot> forall a b. (a -> b) -> a -> b
05:54:10 <fax> > let power f n = (\x-> (!!n) iterate f x) in power (+1) 3 5
05:54:11 <lambdabot>  Couldn't match expected type `[t -> t1 -> t2]'
05:54:22 <fax> :t iterate
05:54:24 <lambdabot> forall a. (a -> a) -> a -> [a]
05:54:46 <fax> > let power f n = (\x-> (!!n) $ iterate f x) in power (+1) 3 5
05:54:47 <lambdabot>  8
05:55:04 <fax> does 'power' already exit ?
06:01:26 <fasta> What's an easy way to parse the grammar A -> "foo"-A;B -> A - "foobar". I am now using sepBy1 <something> (char '-'), but the '-' already gets consumed too early and then the parsing fails.
06:02:20 <fasta> Oh, never mind, that grammar definition is worthless.
06:03:05 <fax> @pointless (\x-> (!!n) $ iterate f x)
06:03:05 <lambdabot> (!! n) . iterate f
06:03:59 <fasta> It needs an extra rule A -> "something"
06:12:31 <fax> hm you know how Maybe is a monad you can write stuff a lot better
06:12:37 <fax> using do notation
06:12:54 <fax> Is it a similar situation with Either?
06:13:03 <fax> (Left error, Right stuff)
06:13:41 <Vq^> yes
06:14:18 <Vq^> i believe you need to import Control.Monad.Error thought
06:14:46 <quicksilver> and 'error' needs to be an instance of 'Error'
06:14:53 <quicksilver> which is not too trick to acheive
06:15:21 <fax> Text.ParserCombinators.Parsec.Error.ParseError
06:15:27 <fax> I wonder if it's an error
06:15:42 <fax> oh it will be :|
06:15:51 <quicksilver> I think parsec might predate the Control.Monad.Error stuff
06:15:56 <quicksilver> it's esy to write an error instance though
06:16:06 <fax> ok, I will try then
06:16:08 <fax> thanks you guys :D
06:17:11 <EvilTerran> haskell has a lot of ways to do error handling
06:17:46 <hpaste>  fax pasted "messed up routine" at http://hpaste.org/2922
06:18:05 <fax> ^ that's why I thought I use it like Maybe if possible
06:19:35 <DRMacIver> EvilTerran: And comparably few ways to generate errors. ;)
06:19:53 <quicksilver> fax: yes, I agree
06:20:02 <fax> cool
06:20:08 <quicksilver> fax: but are the two 'errors' the same type?
06:20:13 <quicksilver> fax: otherwise it isn't a monad :(
06:20:19 <fax> :L
06:20:28 <fax> Maybe I have two monads?
06:20:32 <phobes> Does Control.Monad.Cont not come with ghc?
06:20:36 <EvilTerran> you could Either the two error types together :D
06:20:45 <quicksilver> you can lift one into the other
06:20:49 <quicksilver> or lift both into a common type
06:20:52 <quicksilver> bit of a mess, though :(
06:20:58 <fax> hmm
06:21:04 <fax> Well I have some text right, A list of Chars
06:21:04 <quicksilver> "monads which are parametric in two variables" are not monads
06:21:11 <quicksilver> although, in a sense, you can see why they should be
06:21:18 <fax> so I attempt to parse it into tokens, then I get a list of tokens, which i attempt to parse into an AST
06:21:36 <fax> so It should be two monads instead of one with two types?
06:21:45 <fax> at least.. it could be
06:21:47 <osfameron> would they be duads if parametric in two variables?
06:22:32 <fasta> Is there a simple way to parse this format with Parsec? I am thinking of just splitting the string on '-' which seems an order of magnitude easier. I already wrote a parser for positive floats. <number>-<number>-<number>-<positive float>
06:23:10 <fasta> You cannot assume that there are only three numbers
06:23:46 <EvilTerran> ( <number> - )* <positive float>
06:23:46 <EvilTerran> ?
06:24:31 <vincenz> what's the <number> for?
06:24:42 <fasta> vincenz: that's an Int
06:24:43 <fax> Yeah, you are right quicksilver
06:24:53 <fax> No instance for (Control.Monad.Error.Class.Error ParseError), so that's fine
06:25:24 <fasta> EvilTerran: the problem is that 1-5.2 matches the first part too, only later it discovers that .2 is still left in the input and then fails.
06:25:48 <fasta> EvilTerran: it should backtrack in that case.
06:25:50 <mrd> use 'try'
06:26:01 <fasta> mrd: I tried, but I the question is where.
06:26:15 <mrd> you could 'try' to match a float after every '-'
06:26:39 <EvilTerran> try to match a float, and if that fails, go for another <int> -
06:27:25 <fasta> EvilTerran: ok, so I basically parse it two times?
06:27:35 <fasta> EvilTerran: once to try and once after to do the real parsing?
06:27:42 <mrd> no
06:27:42 <EvilTerran> hm? no...
06:27:46 <mrd> if it's a float you return it
06:28:00 <fasta> But those types are not compatible.
06:28:12 <mrd> disjoint union
06:28:23 <fasta> Right, that's possible too.
06:28:59 <mrd> quick guess: many (try (Left `fmap` myFloat) <|> (do n <- myInt; char '-'; return (Right n)))
06:29:31 <fax> ?djinn instance Control.Monad.Error.Class.Error ParseError
06:29:32 <lambdabot> -- f cannot be realized.
06:29:36 <fax> >:D
06:30:01 <mrd> hm
06:30:10 <mrd> actually that'll probably parse an int as a float
06:30:26 <mrd> i guess you'll need to put a little more logic into that
06:30:32 <EvilTerran> does the float always have a "." in it?
06:30:55 <fasta> EvilTerran: yes
06:31:28 <EvilTerran> if myFloat fails in the absence of a period, mrd's suggestion should work
06:31:32 <mrd> well, make myFloat fail if, ...
06:31:33 <mrd> yea
06:31:43 <EvilTerran> :D
06:31:58 <mrd> though why not just parse the whole thing as floats separated by -?
06:33:28 <sclv> would it be possible to write a decent scanf for haskell?
06:34:13 <fax> :o
06:34:16 <fax> that sounds like fun
06:34:34 <fax> you could return a tuple?
06:35:10 <sclv> yes... but of *what*
06:35:13 <allbery_b> actually that's troublesome since each tuple is its own type
06:35:19 <quicksilver> you could do the same kind of evil type class hackery that printf uses
06:35:20 <allbery_b> HList, maybe
06:35:35 <quicksilver> so you'd return (Double,Double) if it was %f %f
06:35:40 <quicksilver> and if you got it wrong, it would just error
06:35:51 <vincenz> error is unpure
06:35:54 <vincenz> :)
06:35:57 <sclv> yes -- i was thinking something like that or a custom defined record type
06:36:02 <quicksilver> ("error: scanf: format string doesn't match required type)
06:36:06 <quicksilver> vincenz: no it isn't
06:36:07 <allbery_b> the PrintfType stuff would require each such possible tuple to be predeclared as an instance, though, I think
06:36:14 <quicksilver> vincenz: error has perfectly pure semantics
06:36:44 <quicksilver> allbery_b: instance ScanfType Double; instance (ScanfType a, ScanfType b) => ScanfType (a,b)
06:36:47 <quicksilver> allbery_b: etc etc
06:36:50 <vincenz> quicksilver: bottom?
06:36:54 <quicksilver> vincenz: right
06:36:59 <vincenz> my bottom :)
06:37:04 <mrd> catching the error isn't pure ;)
06:38:52 <sclv> i think error handling would be the least of the difficulties
06:41:04 <sclv> compared to getting something remotely like c scanf format in a language without mutability
06:41:29 <sclv> maybe somehow using Typable
06:41:30 <allbery_b> huh?
06:41:48 <allbery_b> same way read does it
06:42:03 <allbery_b> typeclasses for polymorphism
06:42:04 <sclv> right, except we're talking a variable number of results, right?
06:42:13 <EvilTerran> @where hlist
06:42:13 <lambdabot> http://homepages.cwi.nl/~ralf/HList
06:42:35 <allbery_b> see quicksilver's response when I raised that
06:42:38 <sclv> well, ok, maybe using hlist seems easy for some of the old hands here, but...
06:42:39 <EvilTerran> you could return ([String],[Int],[Double],[Char]) or something
06:42:44 <allbery_b> the probem there is you'd have a fixed maximum
06:43:04 <allbery_b> kinda like the Ord instances for tuples
06:43:57 <EvilTerran> i mean, scanf "%f %d %s" "1.1 23 foobarbaz" would return (["foobarbaz"], [23], [1.1], [])
06:44:02 <sclv> hmmm... EvilTerran++
06:44:22 <EvilTerran> each format specifier could be attached to a specific type, and put its result in the appropriate list
06:44:36 <EvilTerran> maybe make it a record for sanity's sake
06:45:17 <quicksilver> HList is just tuples
06:45:19 <quicksilver> by the way
06:45:23 <quicksilver> it's not magic :)
06:45:35 <quicksilver> and it doesn't realy change the essential questions
06:46:09 <fasta> quicksilver: It's just (a,(b,())) etc?
06:46:37 <EvilTerran> equivalent to that, anyway. isomorphic types.
06:47:11 <b_jonas> I can't see why that's needed:
06:47:25 <b_jonas> a scanf-like function would surely only support a finite number of types
06:47:29 <quicksilver> fasta: right (essentiialy)
06:47:37 <sclv> right -- and strict in the type of its elements, except the typeclass of a given hlist can be generated at runtime, right?
06:47:44 <quicksilver> it depends whether you want to write one where the type is staticaly known
06:47:48 <b_jonas> so it could just return a list of some type which has constructors for eacho of those types
06:47:51 <quicksilver> which is mostly what you want
06:47:58 <quicksilver> or truly dynamic (not known until runtime)
06:47:59 <EvilTerran> b_jonas, that's similar to my suggestion
06:48:00 <b_jonas> so scanf would be of a specific types
06:48:06 <quicksilver> scanf "%d" :: Int
06:48:12 <quicksilver> scanf "%f" :: Double
06:48:15 <b_jonas> the problem with that is obviously that it's more complicated syntax
06:48:19 <quicksilver> would be the easiest and most type-sound
06:48:26 <b_jonas> which is just what we wanted to avoid with scanf
06:48:31 <quicksilver> scanf "%f" :: [ScanfTypes]
06:48:38 <quicksilver> would be more dynamic
06:48:42 <quicksilver> you could support both, of course...
06:48:52 <quicksilver> or even a mixture
06:49:05 <b_jonas> because if you have to call the extractors from ScanfTypes, it's easier to just have separate scanf-like functoins for each or something like that
06:49:07 <quicksilver> scanf "%d,%d,%f" :: (Int,ScanfType,Double)
06:49:15 <quicksilver> ^^ middle one is dynamic, other two are static
06:49:49 <sclv> which is sort of silly because the %d in the string tells you what its going to be, no?
06:50:31 <allbery_b> perhaps the oddest part of this is that I consider scanf evil even in C, because the error handling for mismatched input just sucks
06:50:49 <b_jonas> allbery_b: only if you don't know about "%n"
06:51:18 <mauke> no, scanf is definitely evil
06:51:30 <quicksilver> sclv: yes but what if the string was specified at runtime :)
06:51:48 <quicksilver> scanf "%d,%"++specified_by_user++",%f" :: (Int,ScanfType,Double)
06:52:00 <b_jonas> mauke: it's evil, sure
06:52:08 <b_jonas> but not because of the error handling but because of the types
06:52:19 <mauke> even if you have %n, you can't rewind stdin
06:52:26 <allbery_b> ==mauke
06:52:47 <allbery_b> in any case, this is haskell, why are there not cominaor-based alternatives to these things?
06:52:54 <allbery_b> combinator.  feh.  cannot type
06:52:58 <mauke> like parsec?
06:53:31 <allbery_b> actually parsec is what I would use for input.  but output?
06:53:31 <sclv> quicksilver: except what can you do with a generic value whose type is only specified at runtime except show it anyway? except coerce it, if you know it will be numeric of some form i suppose, which is what scanf should handle anyway?
06:54:19 <quicksilver> sclv: well as someone pointed out earlier, there are a finite number of format specificiers
06:54:38 <quicksilver> sclv: so ScanfType would be data ScanfType = Double | Int | String | ....
06:55:40 <b_jonas> mauke: yeah, it's difficult too but I don't see how it's worse than other options
06:55:47 <b_jonas> you can read a line to a buffer and scanf it
06:55:57 <mauke> that's a big improvement
06:56:10 <EvilTerran> you can do that in C, soo, with sscanf
06:56:11 <b_jonas> as I see, the problem with scanf (and printf to a lesser improvement) is the static types
06:56:32 <b_jonas> they work much better in a dynamically typed language where you can just use "%d" for any integer type
06:57:04 <b_jonas> but in C, you have to convert an integer to something of which you know the flags for printf, and use a temp variable for scanf
06:57:38 <b_jonas> if you meet a type of which you don't know the formatter flags for sure (because the type of that variable can change or because it's a typedefed type like time_t or uid_t or whatever)
06:58:25 <b_jonas> there are printf flags for char, short, int, long, longlong, and macros of printf flag string constants for int32_t etc
06:58:40 <b_jonas> but there're none for all the types defined by your system library
06:58:57 <b_jonas> and you too can define an integer type or just change your mind about what type a single variable should be
06:59:10 <mauke> you can't define an integer type in C
06:59:10 <b_jonas> and in that case, you cannot hardcode the printf/scanf flag
06:59:17 <b_jonas> you cannot define a new one
06:59:32 <b_jonas> but you can define one which can be one of the builtin types
06:59:45 <mauke> then you can also define a conversion macro
07:00:02 <b_jonas> you can, but that gets ugly because you need lots of such macros
07:00:21 <b_jonas> you need one for every typedeffed type, variable, and structure field you may ever want to change
07:00:28 <mauke> no, I don't
07:00:30 <b_jonas> and the standard libraries don't define such macros
07:00:47 <mauke> usually I don't want to do textual I/O with them
07:00:55 <b_jonas> yeah
07:01:09 <b_jonas> that's true, but still it's a problem
07:01:30 <b_jonas> ps and kill want to do textual io for pid_t and uid_t
07:01:32 <b_jonas> etc
07:01:43 <mauke> I don't think they should
07:02:04 <b_jonas> of course, they can always use a cast (with printf) or a temporary variable (for scanf)
07:02:17 <mauke> because when you do that, the external interface of your program changes because of an internal type change
07:02:30 <b_jonas> I forgot to mention that there are new printf flags for size_t, ptrdiff_t, intmax_t, and long long
07:02:34 <b_jonas> doesn't that tell something?
07:02:45 <b_jonas> mauke: how does it do that?
07:02:50 <b_jonas> it's always an integer
07:02:56 <b_jonas> I don't think it really changes the interface
07:03:28 <mauke> the size_t one is nice because size_t isn't required to be a standard type
07:03:41 <mauke> the others I've never needed
07:04:05 <b_jonas> oh, I forgot wchar_t and long double
07:04:14 <b_jonas> but those are bad examples
07:04:19 <mauke> %Lf
07:04:48 <b_jonas> even though it doesn't have to be a standard type, I think it has to have a range smaller than maxint_t and there's a flag for that
07:05:22 <b_jonas> so you can use maxint_t or its unsigned variant as a temporary type to convert any integer, provided you know its signedness
07:05:37 <b_jonas> but for some typedeffed types, you don't even know whether it's signed or not
07:06:03 <b_jonas> that's not a real problem in practice though
07:06:11 <mauke> the max* stuff is new in C99
07:06:18 <b_jonas> yep
07:06:23 <b_jonas> the int32_t is as well
07:06:44 <mauke> int32_t is optional so I never use it
07:06:57 <b_jonas> I think I've used the conversion flag for long long once though
07:08:54 <b_jonas> one more thing that can cause problems is that even though gcc can check printf/scanf format and types (if the format string is a compile-time constant), that check doesn't guarantee that your program will work on another systam where types are different
07:09:39 <b_jonas> though that check still helps a lot with typos
07:11:57 <hpaste>  quicksilver pasted "scanf sketch" at http://hpaste.org/2925
07:12:25 <quicksilver> sclv, allbery_b, EvilTerran: there's one way
07:12:41 <quicksilver> with "optional" polymorphism
07:12:47 <quicksilver> although I didn't bother to write many instances
07:13:28 <b_jonas> what I'd like is a regexp library that allows something like scanf-like fomat specifiers inside regexen so %d would match a number and capture it not as a string like (-?\d+) does but as a read number
07:13:59 <quicksilver> to be fair I'm not entirely sure I'm *advocating* the procedure I just outlined
07:14:06 <quicksilver> overuse of overloading makes me feel a bit ill
07:14:13 <quicksilver> I was just demonstrating it :)
07:14:35 <b_jonas> (though you can probably implement this in perl6)
07:15:10 <vincenz> quicksilver: seems hslua exists :D
07:17:28 <quicksilver> vincenz: yes, didn't you know that?
07:17:34 <quicksilver> vincenz: it was announced rather recently
07:19:04 <DRMacIver> I keep meaning to have a play with that.
07:19:21 <vincenz> quicksilver: no :)
07:20:26 <quicksilver> vincenz: however he has made no particular attempt to do nice tools for automatic API wrapping
07:20:33 <quicksilver> vincenz: tis' just a port of the lua C api
07:20:36 <quicksilver> could be a useful basis, though
07:20:45 <vincenz> quicksilver: seems to do more than that
07:20:56 <quicksilver> oh, I didn't look very closely
07:20:57 <vincenz> some types are mapped transparently
07:21:03 <vincenz> you can register haskell functions
07:22:14 <allbery_b> b_jonas: I think that's built into perl6 already :)
07:22:41 <Lemmih> Igloo: ping.
07:22:44 <quicksilver> ah yes
07:22:48 <quicksilver> StackValue class
07:22:57 <quicksilver> (things which can be shoved onto the lua stack)
07:22:57 <quicksilver> nice
07:23:31 <fax> ok I finished writing the herbrand unification
07:23:39 <quicksilver> presumably you can make your custom types instancse of that
07:23:45 <quicksilver> which push userdata/lightuserdata
07:23:48 <quicksilver> sexy...
07:24:14 <fax> is anyone willing to scan my code quickly to say if I did anything really stupid? (even though afaict the code works, it might not be written in good haskell style)
07:24:50 <fasta> Style doesn't matter when your code is perfect ;)
07:25:08 <fax> It's not perfect :|
07:25:44 <fasta> Then again, usually one needs to make something "beautiful" to have some idea of correctness.
07:26:46 <phobes> don't axe to axe
07:26:51 <phobes> :P
07:27:12 <fax> alright, I'll just paste
07:27:18 <hpaste>  fax pasted "unification" at http://hpaste.org/2926
07:28:07 <fax> I'm just wondering stuff like.. Is it totally unreadable?
07:28:22 <fax> like I can tell what's going on but I wrote it :/
07:30:07 <fasta> fax: seems reasonable to me (style-wise). I could say that I would do some things differently, but there's nothing "wrong" with your style.
07:30:39 <doserj> substitution (x:xs) = xs ++ [x] -- is that correct?
07:31:47 <fax> fasta: ok cheers, I was worried of doing some ridiculous stuff without noticing :)
07:32:10 <fax> doserj: not sure if it's the best thing but I want to cycle through each equation
07:32:13 <fasta> fax: example: Your use of = and | vertically stacked
07:32:25 <fax> oh yeah?
07:32:34 <fasta> fax: "common style" is | foo = bar
07:32:44 <fax> I'm running out of space though :|
07:32:49 <fasta> fax: concat $ map would be concatMap
07:32:56 <fax> oh nice :D
07:33:03 <fasta> fax: and I wouldn't use the type annotations.
07:33:19 <fax> should I really remove them all?
07:33:23 <fasta> fax: no
07:33:27 <doserj> keep them!
07:33:29 <fasta> fax: you now already did the work
07:34:35 <phobes> Am I the only one that writes down type annotations first to guide the implementation?
07:34:48 <fasta> phobes: no
07:35:10 <fasta> phobes: I did that, but now I just put pseudo types there.
07:35:29 <phobes> pseudo-types?
07:35:46 <phobes> You mean you put them in as comments and let them get stale?
07:36:01 <phobes> (or something)
07:36:38 <fasta> phobes: if you want to get negative, yes.
07:36:55 <phobes> fasta:  wasn't trying to be negative :)
07:37:31 <fasta> Adding type annotations (especially the rank-N (N>=2)) ones make code less fit for change.
07:37:44 <phobes> I understand
07:38:10 <mauke> where "less fit for change" = stable
07:54:47 <Mitar> @src maximum
07:54:47 <lambdabot> maximum [] = undefined
07:54:47 <lambdabot> maximum xs = foldl1 max xs
07:55:04 <fax> > foldl1 max []
07:55:04 <Mitar> is there a strict version of maximum?
07:55:06 <lambdabot>  Exception: Prelude.foldl1: empty list
07:57:33 <mauke> :t groupBy
07:57:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
07:57:51 <Saizan> Mitar: no, but ghc should use a strict version for the basic numeric types if you compile with -O2 (don't know if this is useful for you)
07:58:09 <Mitar> i use it for Integer and in interactive mode
07:58:31 <nominolo> > 0xc0ffee
07:58:33 <lambdabot>  12648430
07:58:38 <Saizan> i don't think such optimizations are enabled in ghci
07:58:51 <Mitar> yes, i am using now foldl1' max
08:24:05 <allbery_b> hehhe.  apropos of scanf:  "The scanf() function is a large and complex beast that often does something but not quite entirely unlike what you desired." -- Chris Torek
08:25:35 <allbery_b> urk
08:25:41 <allbery_b> "something almost but ..."
08:27:15 <quicksilver> allbery_b: tis a partial quote from HHGTTG
08:27:34 <allbery_b> yes, I know (except they weren't talking about scanf :)
08:27:37 <EvilTerran> i would be worried if scanf() produced tea.
08:27:43 <quicksilver> I would be grateful
08:27:49 <quicksilver> save me getting up from my desk
08:27:54 <quicksilver> that would be a reason to use C!
08:27:56 * allbery_b didn't sleep well last night, and copy-paste doesn't work in this getup
08:28:03 <vincenz> quicksilver: not if you were a coffee drinker!
08:28:15 <allbery_b> (x11.app on osx has its downsides.  sadly CotVNC has issues as well)
08:29:01 <quicksilver> I've never had trouble with copy and paste in x11.app
08:29:10 <quicksilver> although I've mostly moved to using iTerm and carbon emacs
08:29:13 <quicksilver> so don't use X11.app much
08:29:28 <allbery_b> vnc clients don't play at all well with it
08:31:12 <chessguy> @src (.)
08:31:13 <lambdabot> (.) f g x = f (g x)
08:31:23 <quicksilver> allbery_b: oh, I've not needed to do that
08:31:36 <quicksilver> allbery_b: used Chicken a couple of times and it seemed OK, but I'm not a heavy user :)
08:32:37 <chessguy> > (map . map) length [[1,2],[3],[4,5]]
08:32:38 <lambdabot>   add an instance declaration for (Num [a])
08:32:38 <lambdabot>     In the expression: 5
08:32:38 <lambdabot>     In t...
08:32:50 <chessguy> @type map . map
08:32:52 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
08:33:08 <chessguy> > (map . map) (+1) [[1,2],[3],[4,5]]
08:33:10 <lambdabot>  [[2,3],[4],[5,6]]
08:33:10 <allbery_b> CotVNC has two problems:  (1) tends to "hang on to" modifier keys inappropriately (I've inadvertently blown away my IRC session several times that way because it decided for unknown reasons that I had Alt pressed); (2) mishandles non-Roman keysyms
08:33:50 * vincenz wonders whether he should indulge himself and get virtual hosting for 20$/month
08:35:03 <chessguy> > (\f -> map (map f)) (+1) [[1,2],[3],[4,5]]
08:35:05 <lambdabot>  [[2,3],[4],[5,6]]
08:35:21 <mauke> > (fmap fmap fmap) succ [[1,2],[3],[4,5]]
08:35:23 <lambdabot>  [[2,3],[4],[5,6]]
08:35:34 <opqdonut> :D
08:36:08 <mauke> > let om=fmap;nom=fmap in (om nom nom) succ [[1,2],[3],[4,5]]
08:36:09 <lambdabot>  [[2,3],[4],[5,6]]
08:36:19 <fax> :t (fmap fmap fmap)
08:36:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:36:30 <fax> Wtf :/
08:36:37 <doserj> the middle fmap is (.)
08:36:43 <Saizan> no, the first is
08:36:51 <doserj> ah yes.
08:36:54 <doserj> :)
08:38:12 <doserj> > (fmap `fmap` fmap) succ [[1,2],[3],[4,5]]
08:38:13 <lambdabot>  [[2,3],[4],[5,6]]
08:38:20 <doserj> now it is the middle one...
08:38:53 <quicksilver> the problem with fmap for arrows is it only works for one-parameter functions
08:39:03 <quicksilver> which is, well, kind of how the type system is :)
08:39:07 <quicksilver> but sometimes it's annoying
08:40:06 <byorgey> quicksilver: fmap for arrows?
08:40:11 <jbauman> :t liftM liftM liftM
08:40:13 <phobes> define fmap2, 3, 4, etc
08:40:14 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
08:40:51 <quicksilver> byorgey: fmap for (->) e, I mean
08:41:01 <quicksilver> byorgey: arrow in the sense of ->
08:41:07 <byorgey> quicksilver: ah, ok =)
08:41:20 <mauke> > om nom nom succ (words "speng bab")
08:41:22 <lambdabot>  ["tqfoh","cbc"]
08:41:56 <jbauman> liftM2?
08:42:22 <byorgey> > om nom nom succ (words "hal bot")
08:42:23 <lambdabot>  ["ibm","cpu"]
08:42:23 <mauke> > liftM2 (+) [2,3] [9,10]
08:42:25 <lambdabot>  [11,12,12,13]
08:43:20 <jbauman> yeah, different
08:43:22 <vincenz> > nom om nom succ (words "hal bot")
08:43:23 <lambdabot>  ["ibm","cpu"]
08:44:02 <fax> lol
08:44:40 <scvr> i just only looked at the printf code and it was surprisingly compact
08:44:52 <phobes> :t om
08:44:54 <lambdabot> Not in scope: `om'
08:44:56 <b_jonas> hmm. what's nom and om ?
08:45:02 <fax> fmap I think
08:45:06 <b_jonas> @source nom
08:45:06 <lambdabot> nom not available
08:45:08 <byorgey> nom === om === fmap
08:45:10 <scvr> it seems that way with most impressive haskell magic libraries -- all the hard work is in the coming up with how it works part
08:45:33 <phobes> @hoogle om
08:45:34 <lambdabot> Random :: module
08:45:34 <lambdabot> System.Random :: module
08:45:34 <lambdabot> Network.recvFrom :: HostName -> PortID -> IO String
08:45:43 <phobes> hmm, what is that from?
08:45:49 <byorgey> someone must have defined them with @let, I think
08:46:14 <byorgey> > L.om
08:46:15 <lambdabot>  Add a type signature
08:46:26 <b_jonas> I see
08:46:27 <byorgey> > L.om succ [1,2,3]
08:46:27 <tibbe> I just checked in the source of Network.Socket, some functions are a ^ or | away for being documented :/
08:46:29 <lambdabot>  [2,3,4]
08:47:23 <byorgey> scvr: yes, Haskell is very good at "getting out of the way" and allowing you to implement an idea compactly and directly, without a lot of excess syntactic garbage
08:50:19 <phobes> any know if ghc comes with source for its imports?
08:50:27 <phobes> or do I have to get that in a separate package?
08:50:49 <tibbe> phobes: I think that you have to select it separately in the Ubuntu package manager at least
08:51:00 <phobes> tibbe: hmm thanks
08:51:06 <mauke> @source Data.List
08:51:07 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
08:51:09 <phobes> (i'll look again)
08:51:23 <tibbe> phobes: I could be wrong though
08:51:46 <quicksilver> phobes: that depends entirely how you installed it
08:51:56 <quicksilver> phobes: if you installed it from source then (obvioiusly!) you have the source...
08:52:05 <quicksilver> phobes: the binary installations don't come with the source, no
08:52:06 <phobes> quicksilver: No, I didn't get the source
08:52:30 <phobes> quicksilver: ok, I thought they might come with the standard library source, but not the compiler
08:52:31 <quicksilver> it's available online, or you can just grab the tarball for offline browsing
08:52:40 <phobes> (I don't realy want the compiler)
08:52:49 <phobes> though I actually have that!
08:53:15 <phobes> but I don't know if that's current ... anyway, thanks
08:55:49 <Lemmih> @seen benl23
08:55:49 <lambdabot> I haven't seen benl23.
09:11:11 <fasta> Can I catch an exception in some way without ending up in the IO monad?
09:11:44 <fasta> (in the monad of Parsec)
09:12:57 <EvilTerran> if you're the one throwing it, you could do something with continuations or ErrorT or something
09:13:29 <fasta> EvilTerran: I am not
09:14:08 <fasta> EvilTerran: the problem is that with the suggestion of you the parser now accepts a language that's too large.
09:14:21 <EvilTerran> hm?
09:14:25 <fasta> EvilTerran: then subsequently I call a function that assumes it was parsed OK>
09:14:34 <fasta> EvilTerran: but that assumption is invalid.
09:15:24 <fasta> Well, never mind.
09:15:26 <EvilTerran> what're you trying to parse? /(%d\-)*%f/?
09:15:38 <fasta> EvilTerran: right
09:15:41 <EvilTerran> (to use a freakish combination of regex and format)
09:16:15 <fasta> EvilTerran: currently it parses (%d <|> %f)*
09:16:28 <fasta> EvilTerran: in another freak language.
09:16:43 <mauke> (@ds, $f) = split /-/
09:17:18 <EvilTerran> to use yet another freak language!
09:17:21 <EvilTerran> ;)
09:17:34 <fax> is that perl 6?
09:17:39 <EvilTerran> although that doesn't work in perl5; everything ends up in @ds and $f is undefined.
09:17:52 <mauke> ok, $f = pop @ds
09:18:02 <mauke> let @ds' = map read @ds; $f' = read $f
09:18:10 <EvilTerran> $f = pop (@ds = split /-/); would work, i think
09:18:22 <kawfee> mauke is that you?
09:18:30 <mauke> what
09:18:50 <kawfee> I thought you were a C crowney
09:19:21 <mauke> think again, bat man!
09:19:23 <kawfee> oh wow, it is you
09:19:33 <mauke> HOW ARE YOU GENTLEMEN!
09:19:42 <wolverian> mauke, are you writing haskellperl? sheesh :]
09:19:51 <mauke> I think it's called haskerl
09:19:53 <wolverian> haskerl?
09:19:56 <wolverian> right
09:19:58 <kawfee> wtf
09:20:00 * wolverian was a tad slow
09:20:03 <kawfee> don't abuse haskell like that
09:20:22 <wolverian> abuse? it makes haskell more readable
09:20:35 <kawfee> haskell is very readable already
09:21:04 <wolverian> you are not disagreeing :)
09:21:20 <kawfee> why are you trying to pick a fight?
09:21:23 <kawfee> You big bully.
09:21:33 <wolverian> because I haven't eaten, probably.
09:21:39 <mauke> the combined readability of haskell and perl overwhelms me!!
09:21:45 <mauke> AIIRRR
09:21:54 <wolverian> anyway, I really do think that haskell's big problem is that the atoms (names) are too uniform in appearance
09:22:13 <wolverian> but it's probably because I'm used to perl and C-like languages
09:22:34 <kawfee> I hate you.
09:22:36 <mauke> @djinn (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b
09:22:36 <lambdabot> f a b c d =
09:22:36 <lambdabot>     case a d of
09:22:36 <lambdabot>     False -> b d
09:22:36 <lambdabot>     True -> c d
09:22:41 <wolverian> mauke, try regexes and haskell
09:22:45 <mauke> lambdabot: wrong!
09:22:48 <kawfee> trying to ruin haskell with C and perl
09:23:15 <mauke> hmm, or maybe it does make sense
09:23:20 <EvilTerran> looks right to me
09:23:24 <mauke> but that means "if" is broken in all languages
09:23:38 <fax> mauke: Why?
09:23:39 <EvilTerran> @type let f a b c d = case a d of False -> b d; True -> c d in f
09:23:41 <lambdabot> forall t t1. (t -> Bool) -> (t -> t1) -> (t -> t1) -> t -> t1
09:24:07 <mauke> fax: because the else part should come first if you listen to djinn
09:24:34 <fax> :S
09:24:44 <fax> > [False..]
09:24:44 <lambdabot>  Parse error
09:24:49 <fax> hum
09:24:57 <sjanssen> fax: space after False
09:24:59 <mauke> there's a reason I put spaces around my operators
09:25:32 <EvilTerran> liftM2 (,) (try parseInt `endBy` char '-') parseFloat -- fasta, how about this?
09:25:32 <sjanssen> "False.." parses as the operator '.' in the module False
09:25:36 <kawfee> to protect them from the other operators?
09:25:45 <fax> @djinn (a -> Bool) -> (a -> b) -> (a -> c) -> a -> Either b c
09:25:45 <lambdabot> f a b c d =
09:25:46 <lambdabot>     case a d of
09:25:46 <lambdabot>     False -> Left (b d)
09:25:46 <lambdabot>     True -> Right (c d)
09:25:49 <kawfee> cause if you put them next to each other they will fight
09:26:09 <chessguy> sjanssen, hm, that sounds wrong. in that case, wouldn't it give an error about (.) not being in scope?
09:26:29 <chessguy> > [False.(.)]
09:26:30 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Bool'
09:26:32 <sjanssen> > [.]
09:26:32 <lambdabot>  Parse error
09:26:55 <chessguy> sjanssen, i think it's just syntactically incorrect
09:26:56 <mauke> > [(False..)]
09:26:57 <lambdabot>   Not in scope: `False..'
09:27:18 <sjanssen> chessguy: it's syntactically incorrect because it's an operator where an operator isn't allowed
09:27:26 <sjanssen> > [$%^]
09:27:26 <lambdabot>  Parse error
09:27:36 <chessguy> right, but it's not trying to parse it as False.(.)
09:27:42 <chessguy> i don't think
09:27:51 <sjanssen> chessguy: False.(.) is "False . (.)"
09:28:04 <chessguy> well, ok
09:28:06 <sjanssen> sections of qualified operators look like "(False..)"
09:28:13 <kawfee> mauke why aren't you in ##c?
09:28:16 <chessguy> it's not trying to parse it as the operator '.' in the module False
09:28:30 <mauke> kawfee: because it's not interesting
09:28:37 <sjanssen> > (False.+)
09:28:39 <lambdabot>   Not in scope: `False.+'
09:28:43 <sjanssen> > (False..)
09:28:44 <lambdabot>   Not in scope: `False..'
09:28:50 <sjanssen> chessguy: ^^^ yes, it is
09:28:57 <mauke> also, PoppaVic is still not banned and I don't have ops
09:28:58 <chessguy> sjanssen, but that's different from [False..]
09:29:14 <chessguy> that's the error i would expect if it were trying to parse it as the operator '.' in the module False
09:29:15 <sjanssen> chessguy: not according to the lexer
09:29:46 <sjanssen> chessguy: the compiler doesn't get to the name resolution stage because it's also a syntax error
09:29:50 <sjanssen> > False.+
09:29:51 <lambdabot>   parse error on input `False.+'
09:29:53 <sjanssen> > False..
09:29:54 <chessguy> \right, that's my point
09:29:54 <lambdabot>   parse error on input `False..'
09:30:01 <mauke> > .
09:30:02 <lambdabot>   parse error on input `.'
09:30:15 <sjanssen> chessguy: it's a syntax error because you're using an *operator* where an expression is expected
09:30:17 <chessguy> the error reported is the syntax error, not the scoping error
09:30:34 <xerox> > undefined False.. undefined
09:30:35 <lambdabot>   Not in scope: `False..'
09:30:37 <sjanssen> chessguy: hence, the compiler is clearly parsing it as a qualified operator
09:30:51 <sjanssen> > undefined..
09:30:51 <lambdabot>  Parse error
09:31:03 <chessguy> ...
09:31:12 <chessguy> ok, i guess it doesn't really matter
09:31:14 <sjanssen> hmm, that doesn't illustrate my point
09:31:18 <sjanssen> see what xerox wrote
09:31:18 <fasta> EvilTerran: something like that appears to work.
09:31:43 <chessguy> > [False ..] -- what the heck does this do anyway
09:31:46 <lambdabot>  [False,True]
09:31:51 <chessguy> interesting
09:31:57 <xerox> > enumFrom False
09:31:59 <lambdabot>  [False,True]
09:32:04 <chessguy> @src enumFrom
09:32:04 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:32:30 <chessguy> lambdabot, whatever you say, cauliflower-head
09:32:55 <chessguy> anyway
09:33:02 <chessguy> on that note, back to the real world
09:39:18 <sjanssen> @keal
09:39:19 <lambdabot> i can explain why something is without knowing what the rules decided by man are
09:39:56 <EvilTerran> fasta, i've tested this - it seems to work: liftM2 (,) (many $ try $ liftM2 const parseNatural (char '-')) parseFloat
09:41:08 <EvilTerran> endBy doesn't quite work right, 'cos (try parseNatural) would succeed and then (try $ char '-') would fail when it reached the float, and then the start of the float would still be consumed
09:41:33 <EvilTerran> so the '-' needs to be in the same try as the parseNatural is
09:44:13 <sjanssen> @hackage number
09:44:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/number
09:44:18 <sjanssen> @hackage numbers
09:44:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
09:45:06 <EvilTerran> @hackage doesn't validate?
09:45:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/doesn't validate?
09:45:13 <EvilTerran> hehe
09:47:31 <fasta> sjanssen: you were suggesting that such a function existed?
09:47:47 <sjanssen> fasta: no, I just wanted the URL for the numbers package
09:47:53 <sjanssen> it's unrelated to parsing
09:48:30 <dnm> Hey newsham.
09:48:38 <sebell> What is the simplest way to get a ByteString or [Word8] to (Ptr a)?
09:48:52 <sjanssen> @hoogle withArray
09:48:53 <lambdabot> Foreign.Marshal.Array.withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
09:48:53 <lambdabot> Foreign.Marshal.Array.withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
09:48:53 <lambdabot> Foreign.Marshal.Array.withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
09:49:22 <dons> ?users
09:49:23 <lambdabot> Maximum users seen in #haskell: 410, currently: 408 (99.5%), active: 13 (3.2%)
09:49:26 <dons> mm
09:49:26 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:49:44 <sjanssen> sebell: or newArray
09:50:39 <sebell> sjanssen: Ah, excellent. Thank you
09:51:10 <sjanssen> sebell: there's also Data.ByteString.useAsCStringLen
09:51:52 <sebell> sjanssen: And that would save me the unpacking step?
09:51:56 <sjanssen> yes
09:52:02 <sjanssen> it should be significantly faster
09:52:15 <dons> never unpack :)
09:52:25 <sjanssen> it might memcpy first, I can't remember
09:53:01 <DRMacIver> It amuses me that #haskell is larger than ##java.
09:53:24 <dons> that rocks
09:53:38 <DRMacIver> (##java tends to have a bit under 300 users)
09:53:49 <EvilTerran> well, ours is an official channel...
09:54:17 <DRMacIver> Yes. And there are rather a lot more java channels than haskell channels.
09:54:26 <DRMacIver> And IRC is something of a niche.
09:54:32 <DRMacIver> But it still amuses me. :)
09:54:57 <sjanssen> I don't think anybody is claiming there are more Haskell users than Java users
09:55:16 <sjanssen> I think the size of the channel is a testament to the quality, not quantity, of our community
09:55:23 <dons> dcoutts: this unicode bytestring proposal page looks promising
09:55:32 <DRMacIver> sjanssen: Yeah.
09:55:48 <DRMacIver> sjanssen: And the fact that the channel manages to be this good even with this many users.
09:56:21 <EvilTerran> the total in *haskell* significantly outnumbers that for *java* as well, from what i can see
09:56:29 <EvilTerran> even if you count ##javascript ;)
09:57:31 <olsner_> EvilTerran: that's an insult to javascript
10:01:49 <lament> i think it's just that haskell users are more nerdy and so more likely to use irc.
10:03:16 <Naktibalda> isn't this the only server with haskell channels in the world?
10:03:48 <Naktibalda> other languages has much more local chanels
10:05:10 <jonathanv> nobody programs in java because they think the language is beautiful (do they?)
10:06:07 <shapr> Naktibalda: There are other text chat Haskell forums.
10:06:13 <vincenz> lament: the proper term is geeky
10:06:49 <shapr> jonathanv: When I switched to Java from Visual Basic, Java seemed beautiful.
10:06:57 <jonathanv> heh
10:07:04 <Nafai> Java is more "corporate" and that seems to be anti-IRC
10:07:07 <jonathanv> i'm not sure that's what i'm talking about
10:07:28 <jonathanv> i think it's hard to be a java "fan"
10:07:36 <shapr> jonathanv: I'm saying that it's a matter of perspective.
10:07:55 <jonathanv> you're not a believer if you code in java
10:08:01 <jonathanv> you're not deviating from any norms
10:08:11 <ToRA> shapr: it's like if you've not played with sand on a beach, you'll think mud is great
10:08:13 <shapr> jonathanv: Twenty years from now, people may say the same about Haskell, if new languages have so much more beauty.
10:08:34 <dylan> but java was never beautiful. :P
10:08:35 <jonathanv> true
10:09:00 <Naktibalda> I am working as php programmer and some others phpers is java fans :)
10:09:07 <dylan> smalltalk, yes. objective c, yes. But not java.
10:09:10 <jonathanv> so by then, the haskell irc channel may not be very popular
10:09:28 <shapr> jonathanv: But over the next twenty years, #haskell might reach 1000 users!
10:09:39 <jonathanv> yeah, we'll have to wait and see
10:09:44 <shapr> Not that number of users is a good measure of anything except a fun community.
10:10:01 <shapr> #haskell is lots of fun!
10:10:26 <jonathanv> i don't even know haskell yet so
10:10:31 <dmwit> 1000 users... nearly .0001% of the world...
10:10:39 <jonathanv> i'm just full of crap here
10:10:43 <shapr> jonathanv: Oh you have an immensely fun adventure in front of you!
10:10:47 <Saizan> jonathanv: being a believer in a programming language is a bit silly however, you should know that your preferred language can be improved or that there will be a better one
10:10:58 <vincenz> dmwit: you mean 0.00001%
10:11:04 <vincenz> we're nearly 10G
10:11:06 <dmwit> vincenz: Probably.
10:11:13 <jonathanv> i'm still playing around in ocaml
10:11:18 <DRMacIver> jonathanv: There seem to be a lot of Java fans.
10:11:21 <shapr> jonathanv: That's good, learning is good stuff.
10:11:24 <jonathanv> i've decided to stick with ocaml for another month or two
10:11:31 <jonathanv> then i'll learn haskell
10:11:33 <DRMacIver> jonathanv: 'though personally I doubt their sanity. :)
10:11:41 <shapr> jonathanv: Focus and finishing things is good too :-)
10:11:45 <shapr> I should try that someday.
10:11:47 <vincenz> DRMacIver: you can't blame them for knowing any better
10:12:09 <jonathanv> i don't think java fans are going to be anywhere near as fanatical as haskell fans
10:12:50 <olsner_> I for one spent helluva lot more time in #haskell than I do coding haskell
10:12:54 <olsner_> *spend
10:13:04 <vincenz> both are correct :)
10:13:32 <DRMacIver> jonathanv: They seem to be significantly more fanatical. Fanaticism is a sign of ignorance. :)
10:13:40 <jonathanv> haha
10:13:45 <jonathanv> enthused then
10:13:51 <DRMacIver> Yeah
10:13:52 <jonathanv> you know what i mean
10:14:09 <jaj> Hi!
10:14:28 <DRMacIver> But the difference is that if you say "X, Y and Z are wrong with Haskell" there's a good chance that a Haskell fan will either agree with you or provide a reasoned argument as to why this is not a problem.
10:14:39 <DRMacIver> If you did the same to a Java fan they'd probably yell at you. :)
10:14:42 <lament> DRMacIver: not necessarily
10:14:44 <lament> example
10:14:55 <lament> DRMacIver: static typing, type classes, monads and lazy evaluation are wrong with Haskell.
10:14:58 <lament> ;)
10:15:24 <jaj> I'm trying to build xmonad on FreeBSD
10:15:45 <jaj> and I get an error when I try to build the unix package
10:16:07 <sjanssen> jaj: the Unix package should already be installed
10:16:13 <DRMacIver> lament: I've seen a lot more reasoned arguments about type systems from Haskell users than Java users. Lazy evaluation is very powerful, but is admittedly a mixed blessing. "Could you elaborate on what you dont' like about the other two?" ;)
10:16:31 <sjanssen> jaj: what is the output of 'ghc-pkg list unix'
10:16:33 <jaj> sjanssen, http://rafb.net/p/VP1Ng718.html
10:16:35 <lambdabot> Title: Nopaste - No description
10:16:58 <lament> DRMacIver: oh yeah, and the WORST thing is significant whitespace. I just HATE that. :D
10:16:59 <sjanssen> jaj: that package should have come with ghc
10:17:13 <lament> DRMacIver: I could live with the other flaws, but that one just kills it for me :)
10:17:13 <DRMacIver> lament: Ok. There are no rational arguments to be had on either side of the whitespace argument. ;)
10:17:28 <oerjan> lament:indeedthatisahorriblething!
10:17:34 <DRMacIver> lament: Totally agreed. :)
10:17:50 <Saizan> well, you can write your braces and semicolons :)
10:17:51 <kilimanjaro> lambdabot, what about higher order functions? Isn't that a bit unpractical?
10:17:56 <jonathanv> to learn haskell and the haskell way of thinking is difficult and bold and almost rebellious, where as java is much closer to default behavior for programmers
10:17:56 <jaj> sjanssen, oh, yeah ghc-pkg lists unix-2.1
10:18:02 <kscaldef> DRMacIver: yes, there are.  For example, if whitespace sensitivity breaks cut-and-paste, that's a valid concern
10:18:19 <DRMacIver> kscaldef: There are rational reasons.
10:18:23 <DRMacIver> kscaldef: There are no rational arguments.
10:18:27 <jaj> sjanssen, thanks!
10:18:27 <lament> kilimanjaro: true, it probably slows things down quite a bit, and who would use higher-order functions anyway?
10:19:11 <DRMacIver> kscaldef: It's one of those subjects which people have a visceral reaction to. You can make a good case for both sides, but no one will listen. :)
10:19:16 <Saizan> jonathanv: well, that might depend on the fact that programmers learns OO first these days?
10:19:16 <lament> i never even use _functions_, much less higher-order ones
10:19:29 <jonathanv> yes
10:19:29 <kilimanjaro> lament, I think I remember some academic guys talking about that. They kept saying stuff like "fold map", I thought they were lost
10:19:50 <lament> kilimanjaro: are you sure it wasn't a geography class?
10:19:55 <jonathanv> programmers are brought up in the c->java tradition and not the lisp->haskell tradition
10:19:56 <Saizan> jonathanv: i've found a bit difficult to move from procedural to OO, too
10:20:49 <jonathanv> though we did learn scheme when i was in college
10:20:54 <kscaldef> jonathanv: in my observation of young programmers, learning haskell is rebellious in more-or-less the same way that buying a leather jacket is
10:21:26 <kilimanjaro> kscaldef, well, except for the whole getting laid part
10:21:29 * lament programs some haskell, puts on his leather jacket and rides off into the sunset
10:21:38 <jonathanv> haha
10:21:53 <kscaldef> kilimanjaro: does that actually work with leather jackets?
10:23:02 <ventonegro> @type ap
10:23:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:23:44 <oerjan> @src ap
10:23:45 <lambdabot> ap = liftM2 id
10:23:48 <kilimanjaro> kscaldef, beats me, I've never had a leather jacket
10:24:11 <Naktibalda> http://flor.nl/text/softdrugs.html
10:24:13 <lambdabot> Title: flor.nl - text-only - drug-dealers vs software developers
10:54:43 <b_jonas> if I want to simulate nondeterministic functions by backtracking, is using lists as monads the right tool?
10:55:07 <xerox> ?tell dons can I (/ you?) get lambdabot back in #haskell.it
10:55:07 <lambdabot> Consider it noted.
10:55:22 <Lemmih> ?join #haskell.it
10:56:11 <nominolo> ?users
10:56:12 <lambdabot> Maximum users seen in #haskell: 412, currently: 407 (98.8%), active: 13 (3.2%)
10:56:51 <oerjan> b_jonas: unless you want finer control over the backtracking, i think so
10:58:54 <oerjan> there might also be a problem if you have infinitely many possibilities
10:59:01 <shapr> @yow !
10:59:01 <lambdabot> I want you to MEMORIZE the collected poems of EDNA ST VINCENT MILLAY
10:59:01 <lambdabot> ... BACKWARDS!!
10:59:47 <xerox> Lemmih: oh thanks.
10:59:57 <oerjan> > [1..] >>= repeat -- for example, this throws away everything after the first
11:00:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:00:38 <b_jonas> I see
11:01:18 <oerjan> but that last may be a general problem for naive backtracking, i guess
11:02:15 <oerjan> but for enumarting all of a finite number of possibilities, lists are fine.
11:02:20 <oerjan> *enumerating
11:03:14 <oerjan> there's a LogicT monad by oleg etc. which i haven't looked into, but which is supposedly very powerful
11:03:34 <oerjan> iiuc
11:07:35 <EvilTerran> does some kind of weaving to map many countable infinities to one?
11:07:54 <fax> diagonaliations
11:07:55 <oerjan> i don't know about that...
11:09:29 <b_jonas> lazyness++
11:18:14 <ttfh> good evening
11:19:36 <EvilTerran> hm... it seems to me that (liftM2 const) is a fairly useful idiom, especially in, say, parsec. does it have a name?
11:19:43 <EvilTerran> @. hoogle type liftM2 const
11:19:52 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *). ('
11:19:58 <EvilTerran> @type liftM2 const
11:20:00 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
11:20:09 <EvilTerran> @hoogle m a1 -> m a2 -> m a1
11:20:10 <lambdabot> Did you mean: m A1 -> m A2 -> m A1
11:20:10 <lambdabot> Prelude.asTypeOf :: a -> a -> a
11:20:10 <lambdabot> Prelude.const :: a -> b -> a
11:20:16 <Igloo> If Java is "mainstream", what's the term for Haskell, epigram etc?
11:20:29 <oerjan> :t <*
11:20:31 <lambdabot> parse error on input `<*'
11:20:38 <oerjan> :t (<*)
11:20:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:21:02 <ttfh> is there a difference between using the Writer monad inside the ReaderT monad and doing it the other way around?
11:21:42 <EvilTerran> i think ML calls this thing "before" or something.
11:21:57 <EvilTerran> oerjan, oh right. Control.Applicative, that?
11:22:07 <oerjan> EvilTerran: @hoogle doesn't do type classes properly
11:22:41 <oerjan> yeah
11:23:52 <oerjan> @unmtl ReaderT Writer a
11:23:53 <lambdabot> err: Unknown MTL(1)
11:24:07 <oerjan> @unmtl ReaderT (Writer a) b
11:24:08 <lambdabot> err: Unknown MTL(1)
11:24:08 <EvilTerran> @help unmtl
11:24:08 <lambdabot> unroll mtl monads
11:24:20 <EvilTerran> @help unroll
11:24:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:24:35 <oerjan> *sigh
11:24:47 <oerjan> @unmtl ReaderT (Writer a)
11:24:47 <lambdabot> ReaderT (Writer a)
11:24:57 <oerjan> o_O
11:25:14 <EvilTerran> @help mtl
11:25:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:25:18 <oerjan> @unmtl ReaderT
11:25:19 <lambdabot> err: No applications
11:25:27 <oerjan> @unmtl ReaderT a
11:25:28 <lambdabot> ReaderT a
11:25:32 <EvilTerran> is there even an @unmtl?
11:25:32 <oerjan> @unmtl ReaderT a b
11:25:33 <lambdabot> err: Unknown MTL(1)
11:25:35 <EvilTerran> @mtl [a]
11:25:35 <lambdabot> Maybe you meant: ft map msg pl unmtl url
11:25:41 <EvilTerran> hm. okay then.
11:25:53 <oerjan> @unmtl WriterT a b
11:25:54 <lambdabot> err: Unknown MTL(1)
11:26:12 <oerjan> oh wait
11:26:29 <EvilTerran> oh, wait. "unroll mtl monads" wasn't a list of things supported by the "mtl" plugin/extension/thingy, it was a statement. doh.
11:27:01 * EvilTerran thought it meant there were three commands @unroll, @mtl, and @monads, grouped as "mtl"...
11:27:02 <oerjan> @unmtl Reader f
11:27:03 <lambdabot> Reader f
11:27:19 <oerjan> @unmtl ask
11:27:20 <lambdabot> err: No applications
11:27:26 <ttfh> I don't have a clue about what you're doing :-)
11:27:35 <dolio> @unmtl State s a
11:27:36 <lambdabot> s -> (a, s)
11:27:43 <oerjan> i'm trying to remember how this !"# thing works
11:27:43 <EvilTerran> monad transformers, ttfh
11:28:10 <oerjan> @unmtl Reader r a
11:28:11 <lambdabot> r -> a
11:28:13 <dolio> @unmtl ((a -> Cont r b) -> Cont r a) -> Cont r a
11:28:13 <lambdabot> err: No applications
11:28:21 <oerjan> @unmtl ReaderT r m a
11:28:21 <lambdabot> r -> m a
11:28:23 <ttfh> EvilTerran: yes, but what does @unmtl do in lambdabot?
11:28:36 <oerjan> @unmtl ReaderT r (Writer w) a
11:28:37 <lambdabot> r -> (a, w)
11:28:52 <EvilTerran> UNdoes abstractions to the Monad Transformer Library classes
11:29:04 <oerjan> @unmtl WriterT w (Reader r) a
11:29:04 <lambdabot> r -> (a, w)
11:29:16 <oerjan> ok, finally, and those are identical
11:29:18 <EvilTerran> Reader r = (r->), Writer r = (,) r, etc
11:30:34 <oerjan> ttfh: since the unrolled types are the same, i guess there is no real difference
11:30:51 <nickus> @hoogle replicate
11:30:52 <lambdabot> Prelude.replicate :: Int -> a -> [a]
11:30:52 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
11:30:52 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
11:30:58 <ttfh> alright, but there are some monad(transformers) for which it matters right?
11:31:24 <oerjan> sure
11:31:43 <dolio> @unmtl ReaderT e (Cont r) a
11:31:43 <lambdabot> e -> (a -> r) -> r
11:31:51 <dolio> @unmtl ContT r (Reader e) a
11:31:51 <lambdabot> (a -> e -> r) -> e -> r
11:32:30 <ttfh> Hehe, I'm scared of the Cont-monad
11:32:46 <augustss> just embrace it :)
11:33:19 <oerjan> Cont and Error in particular - if you use them as the inner monad, everything in the transformer gets "thrown away" if you throw an error or continuation
11:33:39 <oerjan> while in the other order, it is preserved
11:34:14 <augustss> @djinn e -> (a -> r) -> r
11:34:15 <lambdabot> -- f cannot be realized.
11:34:33 <augustss> @djinn a -> e -> (a -> r) -> r
11:34:34 <lambdabot> f a _ b = b a
11:34:40 <ttfh> So then if there's an exception, you can look at what's inside your inner monad?
11:35:04 <augustss> @djinn a -> (a -> e -> r) -> e -> r
11:35:04 <lambdabot> f a b = b a
11:35:12 <oerjan> yeah
11:35:23 <fax> @djinn ((a -> b) -> a) -> a
11:35:24 <lambdabot> -- f cannot be realized.
11:35:40 <fax> @djinn (a -> Not (Not a))
11:35:44 <lambdabot> f a b = b a
11:36:51 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
11:36:51 <lambdabot> f a b = a (\ c _ -> b c) b
11:37:17 <dons> mm, http://www.scriptlance.com/projects/1190732749.shtml?ref=dcm .. :(
11:37:17 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:37:18 <lambdabot> Title: Contest for Haskell program - ScriptLance Programming Project
11:37:39 <augustss> homework?
11:37:45 <dons> someone looking for homework help, i guess
11:38:07 <dolio> $75, eh?
11:38:18 <byorgey> ridiculous
11:38:35 * dmhouse watches #haskell empty as everyone races for that $75
11:38:40 <EvilTerran> bet he won't pay
11:39:14 <augustss> he doesn't realize he could get the solution for free o #haskell
11:39:29 <dons> he probably doesn't know about the community
11:39:38 <Igloo> How did you find it, dons?
11:39:53 <byorgey> he also doesn't realize that he can compute hamming numbers without using threads and queues and priorities =)
11:40:04 <EvilTerran> the only reason i'd do anything for it would be to mung something obfu'd together that looks like it does the job, but really produces the message "do your own homework, foo'!" when run ')
11:40:04 <dons> Igloo: rss
11:40:22 <byorgey> EvilTerran: that would be totally sweet.
11:40:49 <EvilTerran> or, more subtly, solve the problem in the most horrible way possible
11:41:02 <dons> http://programming.reddit.com/info/2tfo8/comments looks nice!
11:41:04 <EvilTerran> so he gets into trouble when he hands in a hideous hack as a solution
11:41:13 <lambdabot> Title: More OpenGL 3D Games in Haskell: Octane Mech (reddit.com)
11:41:34 <byorgey> EvilTerran: implementing the program in exactly the way he's asking for would already result in a hideous hack.
11:41:58 <EvilTerran> true
11:43:35 * EvilTerran 's first thought was kinda reminiscent of http://brainhz.com/underhanded/ , i guess
11:43:46 <lambdabot> Title: 2006 Underhanded C Contest
11:44:08 <eyeris> I'm trying understand the reason for String if "string" is a [Char] so I did :kind String in ghci. It gave me `String :: *'... wtf?
11:44:22 <EvilTerran> (http://bingweb.binghamton.edu/~scraver/underhanded/ loads faster here, seems t obe the same thing)
11:44:23 <lambdabot> Title: 2006 Underhanded C Contest
11:44:27 * EvilTerran wanders off
11:44:34 <dolio> @kind [Char]
11:44:37 <dons> eyeris: right, [] Char has kind *
11:44:40 <lambdabot> *
11:44:44 <dons> that is, its fully applied type constructor
11:45:07 <eyeris> kind != class?
11:45:10 <byorgey> eyeris: maybe you meant to enter :type String?
11:45:13 <eyeris> How can I find the class of a type?
11:45:18 <eyeris> class(es)?
11:45:29 <dons> given a class, you can find what types are an instance
11:45:38 <dons> and using :info in ghci,  you can find what classes a type is part of
11:45:43 <allbery_b> in ghci, try :info type
11:45:51 <allbery_b> in lambdabot:
11:45:55 <allbery_b> @instances Num
11:45:56 <lambdabot> Double, Float, Int, Integer
11:46:12 <eyeris> oh, so String IS [Char]. ok.
11:46:35 <sjanssen> @src String
11:46:36 <lambdabot> type String = [Char]
11:46:36 <dons> yep
11:46:43 <dons> simple type synonym
11:47:14 <dons> now we're talking, http://programming.reddit.com/info/2tfrm/comments
11:47:15 <lambdabot> Title: Fast, parallel log file processing in Haskell (reddit.com)
11:49:41 <dons> bos: i spent some time carefully optimising the 'align chunks on line boundaries' problem for the shootout, http://www.haskell.org/pipermail/haskell-cafe/2007-June/026654.html
11:49:43 <lambdabot> Title: [Haskell-cafe] Fast number parsing with strict bytestrings [Was: Re: Seemingly s ..., http://tinyurl.com/33g4r9
11:49:58 <dons> given a list of strict chunks, you can do a rather good job this way, creating a small alignment chunk of its own (minimal copying)
11:50:09 <dons> then you just go to town on each chunk strictly
11:51:12 <dons> bos, if you're interested, i could probably get a 16 core benchmark for that code too, given some test data..
11:51:35 <bos> dons: i expect gc would kill it
11:51:52 <dons> right.
11:52:00 <eyeris> btw guys, while we're on the topic of reddit... get your own damn haskell.reddit.com. Most days the programming.reddit.com FP is nothing but haskell and erlang stuff :/
11:52:23 <dons> eyeris: tell the lisp guys to write something interesting.
11:52:26 <allbery_b> :)
11:52:57 <bos> eyeris: isn't that the point? all the ruby noise is just pebbles rattling in a can.
11:53:21 <sjanssen> eyeris: blame the people not posting interesting content about other subjects
11:53:28 <dons> prog reddit's not very programming based these days anyway
11:53:33 <fax> I would probably check haskell.reddit.com
11:53:36 <dons> i see CSS articles near the top, and general tech news, all the time
11:53:39 <fax> it would be neat to have that
11:53:46 <dons> i note a SICP article at #4..
11:53:50 <eyeris> haskell is much more interesting than ruby, but I like other langs too. Javascript is fun. I like C.
11:53:53 * eyeris ducks
11:54:31 <bos> dons: it would be interesting to see whether your code performs any differently than mine. i was *very* lazy with my optimisation; just used standard lazy bytestring i/o and line splitting.
11:55:18 <dons> yeah, so given a list of strict chunks extracted with toChunks, you then align the chunks,
11:55:22 <dons>     process :: Int -> Int -> [S.ByteString] -> Int
11:55:24 <dons>     process k i []      = i
11:55:25 <bos> dons: i wouldn't be surprised if we could squeeze another 4x out of it with a bit of work.
11:55:26 <dons>     process k !i (s:t:ts) | S.last s /= '\n' = process k (add k i s') ts'
11:55:28 <dons> yeah.
11:55:31 <dons>       where
11:55:33 <dons>         (s',r) = S.breakEnd (=='\n') s
11:55:35 <dons>         ts'    = (S.append r t) : ts        -- join chunks on line boundaries
11:55:42 <dons> this seems to be quite a profitable approach (the very fast SPOJ and shootout entries used this technique)
11:56:08 <dons> see the use of breakEnd to work back on the current chunk to the first \n
11:56:51 <dons> oh, i think that's even inefficent. it should create a chunk with the head of 't'
11:59:35 <dolio> Oh, right, because otherwise you're effectively duplicating the whole string.
12:00:07 <dolio> Or, most of it.
12:02:13 <eyeris> What is the difference between <- and let?
12:02:26 <bos> in principle, erland would have an advantage for this sort of parallel work, because each process has its own heap that gets gc'ed separately.
12:02:31 <bos> er, erlang.
12:02:39 <Tac-Tics> <- is a monad thing
12:02:45 <bos> of course, the fact that erlang doesn't compile to native code is a problem.
12:02:51 <Tac-Tics> let is just giving the name to an expression
12:04:04 <bos> dons: the lazy bytestring version of isSuffixOf performs horribly, btw.
12:04:12 <eyeris> Tac-Tics ok, so <- is used in `l <- getLine' because getLine does IO?
12:04:28 <Tac-Tics> yes, it's easiest to think of it like that
12:04:33 <Tac-Tics> until you get to understanding monads
12:04:38 <bos> i ended up writing this instead:
12:04:39 <bos> isSuffixOf needle haystack =
12:04:39 <bos>     needle == LB.drop (LB.length haystack - LB.length needle) haystack
12:04:58 <Tac-Tics> eyeris: there are also two forms of "let" you should be aware of
12:05:21 <Tac-Tics> eyeris: let .... in .... is available anywhere. let ....... is only possible in monads and works slightly differently
12:05:45 <bos> Tac-Tics: only possible in a do-expression
12:05:48 <Tac-Tics> so the rule of thumb is to use the "in" keyword for expressions, but not in a monad
12:06:00 <Tac-Tics> bos: yes, yes
12:06:25 <eyeris> Tac-Tics: So is main "in a monad"?
12:06:36 <Tac-Tics> yeah
12:06:39 <Tac-Tics> whenever you see 'do'
12:06:43 <eyeris> gotcha
12:06:43 <dons> bos, hmm. i think this is known (but i don't remember why that should be the case)
12:06:51 <sjanssen> "do let x = y; stmts" is the same as "let x = y in do stmts" -- that's the whole story for do and let
12:07:42 <bos> dons: it reverses both strings, so it allocates a lot
12:08:33 <dons> isSuffixOf :: ByteString -> ByteString -> Bool
12:08:33 <dons> isSuffixOf x y = reverse x `isPrefixOf` reverse y
12:08:33 <dons> --TODO: a better implementation
12:08:51 <dons> grumble
12:09:16 <dons> looks like that one slipped through the net
12:09:41 <oerjan> indeed not
12:09:51 <oerjan> (wrong channel)
12:10:16 <dons> bos, ah, this is the code for optimal strict chunk boundary aligning, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=0
12:10:18 <lambdabot> Title: sum-file Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ..., http://tinyurl.com/327qll
12:10:28 <dons> it copies the minimal one or two lines to align chunks
12:11:49 <Tac-Tics> Can someone give me of an example of how to use the ListT monad? Like.... what it would be useful for computing?
12:12:03 <Tac-Tics> I'm trying to do something with ListT (State Int) Int
12:12:27 <Tac-Tics> but I can't seem to figure out how to make use of the outer layer list monad
12:13:07 <kscaldef> does anyone know, is there a doc or webpage out there somewhere that discusses the error handing parts of HXT?
12:13:45 <kscaldef> It appears to me that once I use readDocument on a url with errors, all future calls to readDocument silently fail
12:14:07 <kscaldef> there's a bunch of functions related to the error status, but it's not immediately clear to me how to use them from the haddock
12:14:49 <Cale> ListT is kind of strange, because it often doesn't produce a monad.
12:15:15 <Tac-Tics> what do you mean, 'doesn't produce a monad?'
12:15:28 <Cale> As in, it produces something which doesn't satisfy the monad laws.
12:15:42 <Tac-Tics> I see...
12:15:44 <Tac-Tics> /does not really see
12:15:46 <Tac-Tics> ^^;
12:15:57 <Cale> I think it was that associativity fails sometimes
12:16:39 <Cale> anyway, in that case, you'd have a monad with nondeterminism but with a separate state, where backtracking would not cause the state to be rolled back
12:16:58 <hpaste>  Tac-Work pasted "Doesn't work ListT" at http://hpaste.org/2929
12:17:01 <Tac-Tics> For some reason, I was expecting something like this to work:
12:17:45 <Cale> You need to use MonadPlus
12:17:53 <Cale> You can't use lists directly
12:18:06 <eyeris> Is there any way to access the elements of a tuple without deconstructing it? e.g. I'm storing a coordinate as a tuple (x,y).
12:18:08 <Cale> However, a useful function not in the libraries is
12:18:20 <Cale> option = msum . map return
12:18:21 <byorgey> > fst (1,2)
12:18:23 <lambdabot>  1
12:18:25 <byorgey> > snd (1,2)
12:18:27 <lambdabot>  2
12:18:30 <Tac-Tics> eyeris: fst and snd work for 2-tuples
12:18:41 <Tac-Tics> there is no general function though, sadly
12:18:52 <Cale> So you can write  y <- option [1,2,3]
12:18:58 <eyeris> Thanks
12:19:03 <byorgey> ...which is because there is no general type that a general function could have.
12:19:28 * quicksilver is quite chuffed. Managed to get a cross product formula right first time :)
12:19:37 <Tac-Tics> @src msum
12:19:37 <lambdabot> msum =  foldr mplus mzero
12:19:41 * byorgey high-fives quicksilver 
12:19:43 <Tac-Tics> @src mzero
12:19:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:19:45 <fax> yzzyxzxz ?!
12:19:54 * fax randoms
12:19:54 <quicksilver> surface normals looking right :)
12:20:01 <byorgey> @src MonadPlus
12:20:01 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:20:17 <byorgey> Tac-Tics: mzero is from MonadPlus
12:20:27 <Cale> mzero and mplus are defined per-monad
12:20:59 <eyeris> And finally how can I convert ints to string to print?
12:21:01 <Cale> mzero means failure, and mplus means nondeterministic choice between options
12:21:09 <Cale> eyeris: show
12:21:17 <Cale> Or you can use print
12:21:26 <Cale> print = putStrLn . show
12:21:53 <Tac-Tics> yeah, I have a vague idea of what they mean
12:22:29 <Tac-Tics> Is ListT the only monad transformer that does weird crap to invalidate monad laws?
12:22:37 <Cale> Yeah, the only one in the libraries
12:22:54 <Tac-Tics> why does it invalidate them?
12:23:08 <oerjan> Tac-Tics: i recall there was a repaired ListT that didn't
12:23:55 <Tac-Tics> I wish I had a better intuition when it comes to monads
12:24:06 <byorgey> eyeris: in fact, the show function is for more than converting ints to strings
12:24:13 <byorgey> @type show
12:24:15 <lambdabot> forall a. (Show a) => a -> String
12:24:26 <byorgey> which means it can convert anything "showable" (anything in the type class Show) into a string
12:24:27 <Cale> Well, in particular ListT [] isn't a monad
12:24:38 <byorgey> which includes pretty much all built-in types
12:24:41 <Cale> and the reason is roughly that order in lists matters
12:24:49 <Tac-Tics> ah
12:24:56 <Tac-Tics> so SetT Set would be a monad?
12:25:14 <Cale> yeah, probably
12:25:58 <cinimod> :t (.)
12:26:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:26:08 <cinimod> :t (.).(.)
12:26:10 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:26:47 <Cale> let u = ListT [["a"],["b"]]; v = ListT [[u],[u]]; w = ListT [[v,v]] in join (join w) == join (fmap join w)
12:27:33 <Cale> Oh, I suppose you should apply runListT to both sides first
12:27:52 <Cale> Prelude Control.Monad.List> let u = ListT [["a"],["b"]]; v = ListT [[u],[u]]; w = ListT [[v,v]] in runListT (join (join w)) == runListT (join (fmap join w))
12:27:52 <Cale> False
12:28:18 <Cale> The LHS is:
12:28:23 <Cale> [["a","a"],["a","b"],["b","a"],["b","b"],["a","a"],["a","b"],["b","a"],["b","b"],["a","a"],["a","b"],["b","a"],["b","b"],["a","a"],["a","b"],["b","a"],["b","b"]]
12:28:31 <Cale> The RHS is:
12:28:35 <Cale> [["a","a"],["a","b"],["a","a"],["a","b"],["b","a"],["b","b"],["b","a"],["b","b"],["a","a"],["a","b"],["a","a"],["a","b"],["b","a"],["b","b"],["b","a"],["b","b"]]
12:28:50 <HairyDude> ?hoogle String -> ByteString
12:28:51 <lambdabot> No matches, try a more general search
12:28:58 <HairyDude> odd
12:29:11 <Cale> > sort [["a","a"],["a","b"],["b","a"],["b","b"],["a","a"],["a","b"],["b","a"],["b","b"],["a","a"],["a","b"],["b","a"],["b","b"],["a","a"],["a","b"],["b","a"],["b","b"]] == sort [["a","a"],["a","b"],["a","a"],["a","b"],["b","a"],["b","b"],["b","a"],["b","b"],["a","a"],["a","b"],["a","a"],["a","b"],["b","a"],["b","b"],["b","a"],["b","b"]]
12:29:16 <lambdabot>  True
12:29:41 <Cale> So the same things are there, and the same number of times, but just in a different order.
12:29:51 <Tac-Tics> ah I see
12:30:50 <Tac-Tics> I'm getting a "no Eq for ListT [] [Char]" error
12:30:52 <Tac-Tics> hmm
12:31:07 <Tac-Tics> ah
12:31:14 <Tac-Tics> I thought I copied the updated version
12:32:22 <Tac-Tics> more errors!
12:32:40 <Tac-Tics> got it
12:32:48 <Tac-Tics> oh noes, they are different!
12:35:36 <Cale> okay, I have another test too, this time with the combination you were considering
12:35:39 <Cale> !paste
12:35:39 <hpaste> Haskell paste bin: http://hpaste.org/
12:37:31 <hpaste>  Cale pasted "ListT sucks." at http://hpaste.org/2930
12:37:45 <bos> dons: btw, your k-nucleotide thingy on the shootout doesn't compile
12:38:14 <Cale> In this case, you not only get different orders of things, you actually get completely different results.
12:38:32 <Cale> Obviously, test1 and test2 ought to be the same thing, but they're not.
12:40:17 <Tac-Tics> interesting
12:41:05 <Tac-Tics> how is it that you can use put and get in 'next' without a lift?
12:41:05 <Cale> Generally, if you want nondeterminism, it's usually better to put the list monad at the bottom of the stack of monad transformers.
12:41:19 <Cale> Because MonadState has a lifting instance
12:41:30 <Cale> MonadState s m => MonadState s (ListT m)
12:41:43 <Tac-Tics> ah
12:41:44 <Cale> (it's in the library)
12:41:46 <Tac-Tics> yeah
12:41:56 <Tac-Tics> I had a feeling something like that was going on
12:42:02 <Tac-Tics> but now I know
12:42:30 <Tac-Tics> There's lots of tutorials for state transformers, but none of them really explain __how__ to use them
12:42:35 <Cale> I actually kind of wish that the lifting instances weren't there by default.
12:42:36 <Tac-Tics> er well
12:42:39 <Tac-Tics> when to use them
12:43:03 <Cale> It would be better if they'd stuck them all in modules which you could import separately if you wanted.
12:43:08 <eyeris> If I call let x = x -1 inside main, then call main again, the second invocation of main doesn't witness the decrement because it is called from inside the do block and do block results are "committed" after the block exits, right?
12:43:27 <Tac-Tics> x is not a variable
12:43:28 <Cale> eyeris: let x = x - 1 defines x as an infinite loop
12:43:28 <Heffalump> let x = x - 1 makes x into an infinite loop...
12:43:31 <Tac-Tics> it can't be changed
12:43:38 <eyeris> ok
12:43:45 <Cale> Because then
12:43:48 <Cale> x = (x - 1) - 1
12:43:51 <Tac-Tics> x in that case is undefined and evaluating it will cause your program to loop indefinitely
12:43:51 <Cale> and so
12:43:54 <eyeris> Right that makes sense
12:43:56 <Cale> x = ((x - 1) - 1) - 1
12:43:58 <Cale> and so on
12:44:13 <Cale> = is really equals :)
12:44:42 <eyeris> I was trying to make the question simple. Let me just paste some code...
12:44:44 <Cale> Actually, depending on the instance of Num, x might be a defined value
12:44:51 <Cale> But it's pretty unlikely :)
12:45:47 <Tac-Tics> like instance Num [()]
12:45:54 <Tac-Tics> where the predecessor or [] is []?
12:46:02 <Tac-Tics> of*
12:46:20 <allbery_b> if your question is what I think it is, then x is a local definition and not visible in other invocations of that function
12:46:26 <allbery_b> unless you explicitly pass it
12:46:31 <Cale> No, you'd need lazy representations of negative numbers
12:47:04 <Cale> Like data LazyInt = Zero | Pred LazyInt | Succ LazyInt
12:47:49 <Cale> So that a constructor would get in the way when you did x - 1, and the recursion could stop
12:48:24 <Cale> I suppose it would also work with an expression tree instance of Num
12:48:31 <hpaste>  eyeris pasted "two diff mains" at http://hpaste.org/2931
12:48:35 <Tac-Tics> Is it possible to use a StateT Monad in conjunction with the Cont monad to do awesome thing?
12:48:39 <Tac-Tics> things?*
12:48:45 <Cale> yep
12:48:52 <Tac-Tics> I have a feeling StateT (Cont r) a is a kick-ass data type
12:48:59 <Cale> Or more commonly ContT over State
12:49:00 <Tac-Tics> but I can't figure out how to actually get anything to complie with it
12:49:03 <Tac-Tics> ah
12:49:19 <eyeris> I'm writing a simple text adventure to learn haskell. The first main in that paste "works" (if I type north, south, east, west the position is changed in the output) but the second doesn't
12:49:29 <Tac-Tics> I've poked around a little bit with that every once in a while
12:49:46 <eyeris> erm, the first does not work and the second does
12:50:02 <Cale> eyeris: In the first one, position isn't even defined
12:50:09 <Cale> In the first line of the first main
12:50:21 <eyeris> Cale it is defined globally in the file.
12:50:23 <Cale> Unless you have another top-level binding somewhere for position
12:50:25 <Cale> ah
12:50:35 <eyeris> I think I know why it works the way it does
12:50:48 <jfredett> hmm, paste that bit too? (the top-level definition?)
12:50:48 <eyeris> because in the second call the print occurs after the let =
12:51:06 <jfredett> or- i dont think you can re-let a top-level binding
12:51:07 <jfredett> like that
12:51:13 <allbery_b> sure you can
12:51:14 <eyeris> where in the first the result of the let = isn't seen in the "lower" call of main because the do block of the "upper" call has not exited
12:51:16 <eyeris> Is that close?
12:51:24 <Cale> let position = processLine (split l ' ') *doesn't* modify that top-level binding for position
12:51:32 <jfredett> hmm
12:51:35 <allbery_b> the let hides any existing binding
12:51:44 <Cale> It merely defines locally a new constant called position
12:51:45 <allbery_b> so the top level binding is useless
12:51:48 <eyeris> ok
12:52:00 <Cale> Your top-level binding is a constant
12:52:09 <Cale> When you make definitions in Haskell, they stay that way forever.
12:52:15 <Tac-Tics> Haskell is the language where everything you know is wrong
12:52:25 <Cale> (or until they go out of scope anyway)
12:52:28 <Tac-Tics> You can't do variable assignments like you want to ever =-P
12:52:37 <Tac-Tics> You have to use references or state
12:52:43 <Tac-Tics> but those are all monad-level things
12:53:01 <eyeris> so then in the second definition, the recursive call to main "sees" the "change" to position because it is seeing the locally scoped version of position?
12:53:05 <Cale> Yeah, you could put something at the top of main like
12:53:11 <Cale> position <- newIORef (0,0)
12:53:19 <Cale> and then position would be an IORef
12:53:32 <Cale> and you could use readIORef to get the pair out, and writeIORef to set it
12:53:51 <Cale> You'd still have to pass the IORef around manually though.
12:54:01 <eyeris> Ok
12:54:03 <Cale> eyeris: yeah, it's seeing the local version
12:54:14 <oerjan> eyeris: actually the second definition cannot possibly work either
12:54:41 <eyeris> Would it be "more haskell-ish" to just make main pass the initial position to processLine and make processLine recursive
12:54:46 <Heffalump> yes
12:54:49 <Cale> Yeah, the second one redefines position afresh every time
12:55:00 <eyeris> so that processLine makes a new position and passes it to another call of processLine?
12:55:02 <Cale> yeah, that'd be the way to do it
12:55:33 <eyeris> ok. I knew that when I started. I just wanted to concentrate on the guards upwards in the file
12:55:40 <eyeris> :)
12:56:12 <eyeris> btw, is there a cmd line to post a file to hpaste with wget, lynx, etc?
12:56:41 <Cale> No, but that's kind of an interesting idea
12:57:03 <mrd> i've seen emacs functions for sending buffers to other paste-sites
12:58:04 <slarba> someone C-x C-f hpaste.el RET
13:00:53 <Tac-Tics> Cale, how would you use ContT and a State monad?
13:01:18 <Tac-Tics> This is so confusing X-D
13:02:54 <cognominal_> what is the equivalent of print that prints "a\na" in  2 lines?
13:02:58 <eyeris> curl --form 'content=<./txtadv.hs' http://hpaste.org/new
13:03:05 <eyeris> http://hpaste.org/2933
13:03:19 <oerjan> putStrLn
13:03:25 <oerjan> probably
13:03:35 <eyeris> Could someone look at processLine and tell me if it is proper?
13:03:55 <eyeris> e.g. could I have done it with just pattern matching?
13:04:20 <oerjan> yes you could
13:04:23 <Tac-Tics> eyeris: position can't just be (0, 0) at the top
13:04:29 <Tac-Tics> it's a constant and cannot change
13:04:42 <Tac-Tics> what you want is for NSEW to be functions
13:04:51 <eyeris> Tac-Tics: yeah, I know that now. I plan to make processLine recursive
13:04:54 <Tac-Tics> north :: (Int, Int) ->(Int, Int)
13:04:57 <Tac-Tics> ok
13:05:34 <Tac-Tics> in that case, process line also needs to take an additional parameter of type (Int, Int)
13:05:40 <eyeris> right
13:06:13 <cognominal_> thx oerjan
13:07:38 <Cale> !paste
13:07:41 <hpaste> Haskell paste bin: http://hpaste.org/
13:07:41 <hpaste>  Tac-Work annotated "(no title)" with "(no title)" at http://hpaste.org/2933#a1
13:07:47 <Tac-Tics> it'd be something kinda like that
13:08:27 <hpaste>  Cale pasted "Using ContT to bring the wonders of goto into Haskell." at http://hpaste.org/2934
13:08:28 <Tac-Tics> of course, north et al would need to be changed
13:08:36 <Tac-Tics> oh boy! goto!
13:08:48 <mrd> lambdabot: the ultimate GOTO
13:08:57 <Cale> oops, some indentation issues there
13:09:04 <Cale> At least it doesn't affect anything
13:09:10 <Tac-Tics> I'm gonna just create a Cale.hs
13:10:33 <Cale> sillyMod' m  modifies the state n so that it becomes n `mod` m
13:11:12 <Cale> and it does this by using a loop implemented with something rather goto-like
13:12:07 <Tac-Tics> this is all going over my head
13:12:08 <Tac-Tics> wow
13:12:39 <Tac-Tics> what is getCC' for... it doesn't seem to be used anywhere
13:13:00 <Cale> It's a variant of getCC you can use which lets you pass a parameter back when you jump
13:13:08 <Cale> So it's like goto-with-value
13:13:12 <nominolo> Cale, where are the Negation types?
13:13:41 <ukl> Hello! What's the proper way to get Haskell packages installed into Fedora 7? I found _some_ SRPMs but don't really know how to handle them (and I might need packages that I didn't find - what to do with them?).
13:13:47 <Cale> If you write something like:
13:13:47 <nominolo> https://research.microsoft.com/users/simonpj/papers/not-not-ml/index.htm
13:13:48 <lambdabot> http://tinyurl.com/3yo2xx
13:13:50 <shapr> ukl: cabal?
13:13:56 <Cale> (x,jump) <- getCC' 0
13:14:06 <Cale> then what happens is x is initially bound to 0
13:14:17 <nominolo> ukl, http://www.haskell.org/cabal/
13:14:17 <lambdabot> Title: The Haskell Cabal
13:14:30 <Cale> and jump is a function which takes an Integer, and jumps back up to just after that point, but x will be bound to that Integer instead.
13:15:43 <ukl> shapr, nominolo, from the fact that SRPMs exist and some people took care of introducing Haskell libs into the rpm repository, I concluded cabal wasn't the way to go here. This was wrong? Fine :))
13:16:00 <shapr> ukl: I don't know, I use debian/unstable.
13:16:03 <Cale> So for example...
13:16:04 <shapr> But cabal is very nice.
13:16:16 <Cale> do (x,jump) <- getCC' 0; print x; jump (x+1)
13:16:28 <Cale> do (x,jump) <- getCC' 0; liftIO (print x); jump (x+1)
13:16:30 <Cale> rather
13:16:38 <nominolo> ukl, not all packages are usually in the distros
13:16:43 <Cale> Will be an infinite loop that prints out the natural numbers
13:16:48 <nominolo> ukl, especially not very new ones
13:17:11 <oerjan> Cale: if you use mdo can you jump forward? >:)
13:17:33 <oerjan> oh, no mfix for Cont monads :(
13:17:33 <Cale> That's a good question, I hadn't thought to try it.
13:17:36 <nominolo> ukl, however, gentoo has a haskell overlay that (with help from cabal) contains over 50 packages
13:17:41 <Cale> ah, makes sense
13:17:43 <oklopol> getCC' 0; continuation?
13:17:51 <Cale> oklopol: yeah
13:17:58 <oklopol> nize
13:18:02 <ukl> shapr, nominolo, thanks for your help. Might just get cabal running and be happy :)
13:18:17 <Cale> oklopol: That was in the ContT IO monad.
13:18:48 <gwern> so, I'm a litlte confused about how lazy evaluation works with control structures
13:19:03 <Cale> gwern: okay
13:19:05 <oklopol> i'll read about that too, once i get past my current idling state
13:19:15 <gwern> I thought eager evaluation made it hard/impossible to write ifthenelse as a function in lisp
13:19:15 <oklopol> if i ever do.
13:19:20 <gwern> but I've been told otherwise
13:19:23 <dons> bos, how so? broken with new bytestring api?
13:19:28 <Cale> gwern: It does.
13:19:38 <Cale> gwern: You end up using macros.
13:19:44 <gwern> and that this was one reason for macros, so you could then write it
13:19:47 <Cale> To do the expansion at compile time
13:20:04 <oklopol> would lisp be tc without macros?
13:20:04 <gwern> but as I said, I was asking questions in #lisp, and I've been told that cond/if-then-else don't have to be macros
13:20:11 <nominolo> ukl, if you have ghc-6.x cabal should come prepackaged.  however, some packages require the new Cabal version 1.2 and will fail to build with older ones.  We're in a transition right now...
13:20:14 <Cale> You could also write it such that it takes two nullary functions as branches.
13:20:14 <oklopol> i guess it would
13:20:30 <nominolo> ukl, so if you have problems, just ask for help
13:20:39 <oklopol> ah
13:20:42 <Cale> and then calls one of those branches in response to the evaluation of the parameter -- but that's just simulating lazy evaluation with functions
13:20:44 <oklopol> functions
13:20:48 <ukl> nominolo: I have ghci 6.6.1, but there's no cabal here...
13:20:53 <oklopol> clevers
13:20:53 <dmhouse> Yeah, the standard way to delay computation in an eager language is to make it a lambda of none (or of one trivial) argument.
13:21:12 <nominolo> ukl, try "ghc-pkg list" in a console
13:21:33 <ukl> Oh happy day! Cabal-1.1.6.2
13:21:44 <gwern> wow, that is a weird technique. I'm trying to understand how that works... it borrows the lzyness of the already present control structures?
13:21:46 <Cale> But you can't write a "real" if-then-else
13:22:08 <cognominal_>  map putStrLn $ lines "ab\nc\nd" --this wrong.  what is the correct way?
13:22:10 <Cale> Yeah, it (ab)uses the fact that the language doesn't evaluate underneath lambdas
13:22:16 <bos> dons: i've forgotten what you're asking about :-)
13:22:35 <dmhouse> og: mapM_. putStrLn is a monadic function, so you should use mapM. As you don't care about collecting the results, mapM_ is more applicable.
13:22:44 <cognominal_> I still have problem to figure to know how to use the IO monad
13:22:45 <nominolo> ukl, yes.  see the cabal website for how to install a cabal-based package
13:22:58 <Cale> cognominal: Do you know about sequence?
13:23:17 <Cale> cognominal: I forget if I've gone through my intro to monads with you :)
13:23:24 <eyeris> Is there a way to exit a do block without doing anything? Or is that a sign that I'm doing something wrong?
13:23:40 <nominolo> ukl, we might have a command line tool some day, and later hopefully also a GUI.  but that's still work in progress
13:23:51 <cognominal_> Cale : I am able to read some haskell. I have problem to write it. I will try with sequence
13:23:55 <Cale> eyeris: You can have something like an if, and in one branch, just put return (), and in the other, put the remainder of the block
13:24:06 <Cale> cognominal: sequence isn't directly what you want
13:24:09 <ukl> nominolo: Now I might just as well get cabal-rpm and use this (so I might more easily be able to uninstall/update packages)?
13:24:16 <eyeris> Cale ok, that is what I was looking for, but I was missing my () in the return :)
13:24:23 <Cale> cognominal: But it's useful for explaining mapM
13:24:23 <dmhouse> cognominal_: mapM_. putStrLn is a monadic function, so you should use mapM. As you don't care about collecting the results, mapM_ is more applicable.
13:24:32 <dmhouse> og: sorry, that previous comment wasn't addressed to you.
13:24:46 <nominolo> ukl, i haven't used that.
13:25:02 <cognominal_> ok, thx
13:25:09 <Cale> cognominal: You probably already know about >> and >>=, right?
13:25:11 <fox86> is haskell a good language for AI-related things? like genetic algorithms, neural networks etc?
13:25:22 <ukl> nominolo: I'll just try it... might be good, who knows... :) thanks for your help so far
13:25:23 <nominolo> ukl, if you don't want to clutter your system too much, try installing packages per-user.
13:25:30 <Cale> fox86: I don't think it would be a particularly bad language for such things.
13:25:33 <gwern> fox86: no worse than many, and better than quite a few
13:25:37 <oerjan> @faq is haskell a good language for AI-related things?
13:25:38 <lambdabot> The answer is: Yes! Haskell can do that.
13:25:44 <Cale> fox86: It's a nice language in general.
13:25:46 <dmhouse> cognominal_: in terms of sequence, mapM f xs = sequence (map f xs). map putStrLn ["hello", "world"] produces a list of IO actions that, when executed, would print out "hello" (the first element) and "world" (the second). sequence takes a list of IO actions and runs them all in order.
13:25:55 <gwern> although most ai related work does seem to be in natural language-related areas from what I've seen
13:25:58 <nominolo> ukl, runhaskell Setup.hs install --user
13:26:17 <fox86> Cale: oh, okay. i am using python at the moment, but haskell seems to exciting!
13:26:24 <fox86> Cale: s/to/so
13:26:53 <Taejo> fox86, Haskell is faster than python, which I find a big help when you're doing hard/interesting stuff
13:27:11 <Taejo> well ghc-compiled haskell, at least
13:27:12 <Tac-Tics> Python is just about the slowest language ever created ^^
13:27:13 <nominolo> fox86, be warned though, that haskell feels a little different, because you have to get programs to typecheck before you run them
13:27:36 <Taejo> Tac-Tics, I've heard it's faster than Ruby, but I've never used Ruby
13:27:37 <nominolo> fox86, so the "haskell-way" might feel quite a bit different than python
13:27:37 <Cale> Getting programs to typecheck is faster than getting the bugs out though. :)
13:27:58 <nominolo> Cale, yes, but you have to think first :)
13:28:06 <Tac-Tics> Cale, yes, with Java maybe
13:28:15 <Taejo> Tac-Tics, in fact, I've heard it's one of the fastest languages in its genre (where its genre is defined as languages that are slower than it :)
13:28:15 <sieni> if it compiles, ship it
13:28:15 <Cale> I now *really* hate it when programming in another language and it lets me compile something idiotic.
13:28:16 <Tac-Tics> Trying to read and comprehend a Haskell error message tho....
13:29:19 <Tac-Tics> I've decided if I ever start my own business, I will use Haskell is my primary language so that if I accidently end up with an incompetent coder on my staff, I can use Haskell's typechecker to prevent him from compiling code
13:29:29 <nominolo> Cale, in Haskell you usually work best by thinking about your API first, and try to get the requirements sorted out by thinking about the types
13:30:12 <nominolo> Cale, I don't say it's bad.  I just say it feels very different from how you approach things in "dynamic" languages
13:30:33 <Cale> With dynamically typed languages you have to be bloody careful *all* the time.
13:30:41 <nominolo> Cale, true
13:30:46 <Cale> Or else you end up running bad code.
13:30:55 <Tac-Tics> Cale: my current job is proof that that statement is not true
13:31:03 <Tac-Tics> You don't *have* to be careful, and that's the problem
13:31:05 <psnively> I'm looking for an excuse to use HAppS sometime. :-)
13:31:09 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2933#a2
13:31:09 <nominolo> Cale, i implemented part of parsec in emacs lisp - it felt so fragile
13:31:16 <Tac-Tics> any idiot with a ged can throw PHP code together and get it to run
13:31:18 <Cale> Tac-Tics: heh, yeah, you can just write broken software, I suppose
13:31:23 <Tac-Tics> T_____T
13:31:34 <eyeris> So this is the "real" haskell way: http://hpaste.org/2933#a2  right?
13:31:57 <Cale> eyeris: main1 would benefit from pattern matching pos
13:32:22 <nominolo> Cale, you have to test each and every function - otherwise, you most certainly have a bug in there somewhere
13:32:47 <Tac-Tics> @pl \(x, y) -> (x+1,y)
13:32:48 <lambdabot> first (1 +)
13:32:49 <gwern> out of curiosity, would you be able to write 'split ("":cs) delim = ...'?
13:32:54 <Cale> I'm too used to not being careful at all, and just letting the typechecker sort things out.
13:33:04 <Tac-Tics> @pl \(x, y) -> (x, y+1)
13:33:04 <lambdabot> second (1 +)
13:33:12 <Tac-Tics> > first (1, 2)
13:33:13 <lambdabot>   add an instance declaration for (Arrow (,))
13:33:13 <lambdabot>     In the expression: first (1...
13:33:17 <Tac-Tics> @type first
13:33:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:33:29 <nominolo> Cale, yes, me too.
13:33:38 <Cale> gwern: "" is the empty string
13:33:45 <Cale> So ("":cs) is a list of strings
13:33:54 <gwern> oh. hm. good point.
13:34:04 <gwern> well, alright, what if it were 'a' isntead?
13:34:09 <Cale> Yeah, you could write that
13:34:23 <Cale> ('a':cs) is a perfectly acceptable pattern match against a String
13:34:24 <byorgey> Tac-Tics: first is a function from the Arrow class, but when applied to functions (which are instances of Arrow), first f (a,b) = (f a,  b).
13:35:11 <byorgey> The type is more intuitive if you use Arrow (~>) instead of Arrow a:
13:35:13 <nominolo> @src (->) first
13:35:13 <lambdabot> first f = f *** id
13:35:17 <nominolo> heh
13:35:21 <oerjan> :t first.(id.)
13:35:23 <lambdabot> forall d b a. (a -> b) -> (a, d) -> (b, d)
13:35:37 <Cale> :t first ?f
13:35:37 <eyeris> Cale what cases for pos could be pattern matched out?
13:35:39 <lambdabot> forall (a :: * -> * -> *) b c d. (?f::a b c, Arrow a) => a (b, d) (c, d)
13:35:44 <nominolo> @djinn  (a -> b) -> (a, d) -> (b, d)
13:35:44 <lambdabot> f a (b, c) = (a b, c)
13:35:46 <byorgey> first :: (Arrow (~>)) => (b ~> c) -> ((b, d) ~> (c,d))
13:35:49 <Cale> :t first (?f :: b -> c)
13:35:49 <augustss> eyeris: I'd have fewer functions in the IO monad, if I wrote that
13:35:51 <lambdabot>     No instance for (?f::b -> c)
13:35:51 <lambdabot>       arising from use of implicit parameter `?f' at <interactive>:1:7-8
13:35:56 <Tac-Tics> Arrows confuse the hell out of me
13:36:06 <fax> @djinn (a -> b) -> (a, a) -> (b, b)
13:36:07 <lambdabot> f a (b, _) = (a b, a b)
13:36:13 <eyeris> Cale the main1 function gets the pos argument just to pass along to processLine
13:36:16 <nominolo> they are just generalized functions
13:36:18 <Cale> Tac-Tics: They're not so bad, really.
13:36:29 <Cale> Tac-Tics: They're actually even simpler than monads.
13:36:32 <kpreid> byorgey: you *could* have a general fst function, given an appropriate typeclass-for-all-tuples
13:36:37 <byorgey> @where arrows
13:36:38 <lambdabot> http://www.haskell.org/arrows/
13:36:42 <nominolo> Cale, though more laws ;)
13:36:43 <Cale> Tac-Tics: It's the *examples* of Arrows which are hard :)
13:36:47 <byorgey> Tac-Tics: have you looked at that page? ^^
13:36:51 <cognominal_> :t mapM_
13:36:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:36:54 <byorgey> it's pretty nice
13:36:58 <Tac-Tics> yes, the pictures on that page are very pretty
13:37:03 <Tac-Tics> but I still don't quite get them
13:37:06 * Cale made the graphics for that page :)
13:37:08 <Tac-Tics> I haven't read it all that carefully
13:37:13 * byorgey should have known =)
13:37:17 <cognominal_> :t mapM IO
13:37:19 <Tac-Tics> What advantages do arrows give over monads?
13:37:19 <lambdabot> Not in scope: data constructor `IO'
13:37:27 <Tac-Tics> besides being more general mathematically?
13:37:37 <Heffalump> more confusion factor for newbies
13:37:49 <eyeris> augustss How would you achieve that? I thought that processLine would need to be -> IO () since it calls main1. (keep in mind that I don't understand monads yet)
13:37:50 <Heffalump> more expressive, when you want to control how inputs are handled
13:37:51 <Cale> Tac-Tics: Basically, the problem you occasionally run into with monads is that the right hand parameter of >>= is a function
13:37:54 <byorgey> kpreid: hm, I guess you could.  but wouldn't you still be limited to using whatever finite subset of all tuple types you bothered to declare as instances of the class?
13:38:04 <Cale> Tac-Tics: Functions in Haskell are not observable
13:38:10 <byorgey> kpreid: or is your point that GIVEN a mythical "all-tuples" class, you could do it?
13:38:11 <Cale> The only thing you can really do is to apply them
13:38:14 <Tac-Tics> observable?
13:38:16 <nominolo> whoa, with the right fonts that website looks just like a PDF
13:38:16 <kpreid> byorgey: the latter
13:38:33 <Cale> You can't have the definition of >>= check to see if a particular function has been passed to it
13:38:36 <byorgey> kpreid: hm, what functions would belong to such a class?
13:38:40 <kpreid> byorgey: ...actually, I don't think you can, because the type parameters are wrong
13:38:44 <cognominal_> hum, how could I print mapM_ instancied for  IO ()
13:39:03 <cognominal_> ...print the type of mapM_
13:39:09 <byorgey> :type mapM_
13:39:10 <Cale> But the corresponding thing in arrows is >>>, and it takes two arrow values
13:39:11 <augustss> eyeris: I'd write a function String->String that maps stdin to stdout
13:39:19 <Cale> which are of a data type you control
13:39:23 <byorgey> @type mapM_
13:39:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:39:29 <Cale> So you *can* potentially compare the values.
13:39:32 <kpreid> class Fst a b where fst :: a b -> b -- this doesn't work because the first element of a tuple isn't the final type parameter
13:39:44 <byorgey> cognominal_: just substitute "IO ()" for "m _"
13:39:52 <Cale> That sometimes lets you implement optimisations which would otherwise not be available.
13:39:58 <byorgey> i.e. (a -> IO ()) -> [a] -> IO ()
13:40:03 <cognominal_> byorgey, I know that
13:40:14 <Tac-Tics> hmm
13:40:27 <Cale> This started out with parser combinator libraries
13:40:31 <cognominal_> but I would like to know how to make lambdabot print it for me
13:40:39 <kpreid> @type \x -> mapM (x `asTypeOf` undefined :: a -> IO ())
13:40:41 <lambdabot>     Inferred type is less polymorphic than expected
13:40:41 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
13:40:48 <Tac-Tics> What is the role of arrows in Haskell?
13:40:49 <byorgey> cognominal_: oh, sorry, I misunderstood your question
13:40:56 <Tac-Tics> I know that they are not especially commonplace
13:41:08 <cognominal_> byorgey, maybe it was ambiguous
13:41:09 <kpreid> @type \x -> mapM (\y -> undefined :: a -> IO ())
13:41:11 <lambdabot> forall t a a1. t -> [a] -> a1 -> [IO ()]
13:41:12 <Cale> There are tricks which you can use to optimise arrow parsers which you just can't apply to monadic parsers because you can't ever actually observe what strings the right hand parameter to >>= might parse
13:41:23 <byorgey> cognominal_: oh, sorry, I misunderstood your question
13:41:39 <byorgey> @where yampa
13:41:40 <lambdabot> http://www.haskell.org/yampa/
13:41:41 <kpreid> @type \x -> mapM ((\y -> undefined :: IO ()) `asTypeOf` x)
13:41:42 <Cale> Tac-Tics: Like monads, they form a common foundation for many kinds of combinator libraries.
13:41:42 <lambdabot> forall a. (a -> IO ()) -> [a] -> IO [()]
13:41:46 <kpreid> there we go
13:41:50 <EvilTerran> merging identical prefixes and whatnot
13:41:52 <byorgey> Tac-Tics: ^^^ that's a nice use of arrows
13:42:25 <byorgey> cognominal_: it looks like kpreid has answered your question, but I don't know if it's worth it =)
13:42:28 <Cale> Tac-Tics: The real idea of monads and arrows, applicative functors, comonads, etc. is to give what would be otherwise disparate combinator libraries a common language.
13:42:55 <Cale> That lets you factor out all the control-structure-like things into separate libraries.
13:42:56 <kpreid> @let constrain f t = \x -> f (x `asTypeOf` t)
13:43:00 <lambdabot> Defined.
13:43:04 <Cale> and share them between combinator libraries
13:43:10 <eyeris> augustss And that function would be called where?
13:43:14 <kpreid> > constrain mapM (undefined :: Int -> IO ())
13:43:16 <lambdabot>  <(Int -> IO ()) -> [Int] -> IO [()]>
13:43:18 <Cale> Like we don't have to redefine mapM for every monad.
13:43:28 <Tac-Tics> yeah
13:43:37 <cognominal_> kpreid : that seems nice but is way beyond my understandin
13:43:38 <augustss> eyeris: main = interact $ theFunction
13:44:06 <eyeris> ahh, another symbol I don't recognize. no wonder we are not on the same page.
13:44:12 <cognominal_> :t constrain
13:44:13 <eyeris> I will look into that
13:44:14 <lambdabot> Not in scope: `constrain'
13:44:33 <Cale> So the next thing you'd be likely to ask is what *kind* of combinator library is an Arrow library.
13:44:33 <kpreid> cognominal_: "constrain f t" has the type of f restricted to taking an argument of the same type as t
13:44:38 <Tac-Tics> I will have to think carefully about the Monad stuff and read into arrows
13:44:39 <kpreid> @type L.constrain
13:44:41 <lambdabot> Couldn't find qualified module.
13:44:42 <Tac-Tics> but I need to go now
13:44:48 <Tac-Tics> thank you for your help
13:44:53 <Cale> Pretty simply, it's one where the "computations" you're manipulating look like functions.
13:45:01 <Cale> no problem
13:45:05 <Tac-Tics> later all
13:45:24 <kpreid> @type \f t -> \x -> f (x `asTypeOf` t) -- this is my "constrain"
13:45:26 <lambdabot> forall a t. (a -> t) -> a -> a -> t
13:46:21 <dmwit> ?src asTypeOf
13:46:21 <lambdabot> asTypeOf = const
13:46:39 <cognominal_> I am reading stuff about template haskell so this stuff interest me
13:46:58 <cognominal_> @hoogle asTypeOf
13:46:59 <lambdabot> Prelude.asTypeOf :: a -> a -> a
13:47:05 <kpreid> dmwit: the magic is in the explicit type specifier which makes it more constrained than const
13:47:11 <dmwit> Yup.
13:47:24 <dmwit> But I was under the impression that it is mostly unneeded now that we have type declarations.
13:47:36 <cognominal_> @hoogle constrain
13:47:36 <lambdabot> No matches found
13:47:40 <kpreid> It's unneeded in the presence of leically scoped type variables.
13:47:47 <kpreid> cognominal_: I just defined it. It's not in the libraries.
13:47:55 <cognominal_> ok
13:47:56 <kpreid> cognominal_: look up at where I did @let
13:48:31 <cognominal_> go tit
13:49:16 <bakert> I'm looking at HAppS.  Which is daunting.  And I see that state is a Haskell type that derives Read, Show and Typeable.  Anyone care to explain what Typeable is?
13:49:58 <ptolomy> Wow. I feel silly. I just spent 10 minutes trying to make a 'Int -> [Int] -> ([Int], [Int])' long division function, and I failed. Granted, I just started typing stuff, but I expected it to not be too hard.
13:50:07 <Heffalump> it's a class that gives you a value-level view of the type
13:50:16 <psnively> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
13:50:18 <lambdabot> http://tinyurl.com/ynu4qa
13:50:24 <kpreid> bakert: Typeable provides runtime type information.
13:50:27 <kpreid> > typeOf "abc"
13:50:32 <lambdabot>  [Char]
13:50:37 <kpreid> @src Typeable
13:50:37 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:50:45 <bakert> psnively: i found that page.  but I didn't know what it meant by reified.
13:50:48 <bakert> :(
13:50:56 <sorear> @web1913 reify
13:50:57 <psnively> It's kind of a principled approach to dynamic typing (boy, is that a wildly misleading oversimplification, or what)?
13:50:58 <lambdabot> No match for "reify".
13:51:04 <sorear> @all-dicts reify
13:51:05 <lambdabot> *** "reify" wn "WordNet (r) 2.0"
13:51:05 <lambdabot> reify
13:51:05 <lambdabot>      v : consider an abstract concept to be real
13:51:05 <lambdabot>      [also: {reified}]
13:51:05 <lambdabot>  
13:51:07 <lambdabot> [7 @more lines]
13:51:10 <kpreid> bakert: the most often interesting functions are typeOf and cast
13:51:17 <sorear> @more
13:51:18 <lambdabot> *** "reify" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
13:51:18 <lambdabot> reify
13:51:18 <lambdabot>  
13:51:18 <lambdabot>         To regard (something abstract) as a material thing.
13:51:18 <lambdabot>  
13:51:20 <lambdabot>         (1995-03-07)
13:51:22 <lambdabot>  
13:51:31 <psnively> Oh, yeah: "reify" is a fancy-schmancy term for "make one thing like another, usually in the sense of making an abstraction concrete."
13:51:37 <bakert> So typeOf says "hello can you tell me what kind of thing you are please"?
13:51:42 <kpreid> bakert: typeOf gives you "the type of" a value
13:51:53 <bakert> And cast is a possible conversion between one type and another, if possible.  Or Nothing.
13:51:57 <kpreid> No.
13:51:57 <bakert> ?
13:52:06 <psnively> I think it was Robert Heinlein who proposed that all occurrences of "reify" be changed to "thingify."
13:52:11 <kpreid> What cast lets you do is...
13:52:46 <kpreid> you can essentially say to the type checker "I can't prove these are the same type at compile time, but let me try at runtime and fail (return None) if they're different
13:53:05 <Cale> Nothing
13:53:09 <kpreid> er, yes
13:53:18 <kpreid> bakert: Data.Dynamic is trivially built on top of Typeable
13:53:33 <Cale> He's an ML programmer! Get him!
13:53:40 <psnively> Cale: ROFL
13:53:46 <kpreid> I blame Python
13:53:53 <bakert> So there are circumstances in which the type is not known at compile time?
13:53:55 <psnively> @remember Cale
13:53:55 <psnively> :
13:53:55 <lambdabot> Incorrect arguments to quote
13:53:56 <psnively> He's an ML programmer! Get him!
13:53:58 <Heffalump> kpreid: and unsafeCoerce# presumably?
13:54:01 <Heffalump> bakert: existential types
13:54:09 <kpreid> Heffalump: no, the unsafeCoerce# is inside cast
13:54:21 <kpreid> Heffalump: Dynamic is built safely out of Typeable and existentials
13:54:27 <Heffalump> oh, right, yes
13:54:40 <psnively> bakert: The canonical case of "unknown at compile time types" is precisely at I/O boundaries, which is why HAppS relies on Typeable.
13:55:18 <bakert> So you might load the state of your application from somewhere?
13:55:35 <psnively> Not might: do.
13:55:47 <bakert> I can see how that would make the values unknown at compile time.  But the type?
13:55:59 <psnively> For example, if a HAppS app goes down, it reconstructs its state at next execution by replaying the write-ahead log.
13:56:12 <psnively> You can't know the type of a value you don't have.
13:56:46 <bakert> I see.
13:56:50 <bakert> Perhaps :)
13:57:06 <Cale> Not if the state of your application is always the same type
13:57:09 <psnively> Yeah, my take on this stuff is that it's easier to learn by trying than discussing.
13:57:27 <psnively> Cale: Yeah. That's either be a very complex type or a very simple application. ;-)
13:57:38 <psnively> That'd, even.
13:57:45 <bakert> One look at HAppS' "hello world" and I felt I needed a bit of discussion to gird myself :)
13:58:00 <bakert> print "hello world"; it ain't.
13:58:03 <psnively> bakert: Understood; the HAppS docs assume, er, some expertise.
13:58:07 <psnively> Amen, brother.
13:58:40 <Philippa> the Network.CGI hello world's not much more complex than print "hello world"
13:58:49 <Philippa> you just don't get a lot of support for doing anything either
13:58:57 <bakert> Philippa: I already wrote some stuff with that.  It was OK>
13:59:12 <bakert> but it wasn't exactly exciting :)
13:59:16 <Philippa> yeah, I know it's OK. Wrote a wiki with it ages ago
13:59:18 <Philippa> well no
13:59:29 <psnively> HAppS is one of those things that really shows Haskell off. But like most things that "really show Haskell off," it requires a certain mindset.
13:59:55 <bakert> I thought I might try and stretch my brain.  But I think it may be an overstretch.  I do kind of understand lots of bits of Haskell.  But I am no expert.
13:59:57 <psnively> A... leap of faith.
14:00:04 <Philippa> right. All our "boring" libs tend to have a batch of advantages over many languages that're just stuff we're used to
14:00:10 <psnively> I'm a Haskell newbie myself.
14:00:14 <Philippa> they're boring, it's just painful going without them
14:00:27 <Taejo> Philippa, example?
14:00:57 <Philippa> Taejo: more precise typing - it's just that little bit harder to screw up with our libs
14:01:13 <Taejo> yeah
14:01:25 <psnively> Yep. Kind of like using LablGL (in OCaml) vs. the C OpenGL APIs.
14:01:37 <Philippa> working in a language with pervasive currying and lazy HOFs helps, too
14:01:56 <psnively> Indeed.
14:01:58 <Cale> bakert: Well, from my perspective, types are exactly those things which you want to verify at compile time. If you don't want to know what the state is at compile time, you can just make some sufficiently general type -- like a tree of atoms.
14:02:04 <cognominal_> :t const
14:02:12 <lambdabot> forall a b. a -> b -> a
14:02:13 <cognominal_> :t asTypeOf
14:02:15 <lambdabot> forall a. a -> a -> a
14:02:26 <Philippa> I have a sneaking suspicion that I'm going to redo my pet project to be lazily evaluated somewhere down the line
14:02:29 <Cale> (where an atom is some small number of things)
14:02:49 <bakert> Cale: i'm very happy to know the type at compile time :) but HAppS seems to think I may not want to.
14:02:53 <Philippa> (it's currently nothing that interesting - essentially a collection of code to make it easy to do language experiments)
14:03:01 <bakert> hence a requirement for deriving Typeable
14:03:06 <Philippa> yeah. And you may not
14:03:06 <psnively> s/not want to/not be able to/
14:03:19 <Philippa> for example, you might want to do significant live updates
14:03:31 <bakert> like erlang
14:03:33 <bakert> ?
14:03:40 <Philippa> in that kind of vein, yeah
14:03:56 <Philippa> lambdabot and yi are both happily capable of that kind of thing already
14:15:04 <Taejo> what is GUI programming like in Haskell?
14:16:25 <kosmikus> Taejo: just look at some code in http://darcs.haskell.org/gtk2hs/demo/
14:16:26 <lambdabot> Title: Index of /gtk2hs/demo
14:16:41 <Taejo> kosmikus, thx
14:17:40 <Paczesiowa> I have question about gtk2hs too:] does this http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Gdk-Pixbuf.html#v%3ApixbufNewFromFile make any sense? how can it return Left (err,msg) with result type of IO PixBuf?
14:17:41 <lambdabot> http://tinyurl.com/2xzmke
14:24:41 <tibbe> do we have a mapPair function that maps a function onto both components of a pair?
14:26:39 <oerjan> > join (***) (+1) (1,2)
14:26:41 <lambdabot>  (2,3)
14:28:29 <tibbe> hmm
14:28:30 <oerjan> mixing the -> monads and arrows
14:28:35 <tibbe> cute
14:28:41 <tibbe> not a 100% clear ;)
14:29:02 <oerjan> :t join (***)
14:29:04 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:29:04 <tibbe> and Data.Map as all possible combinations of map functions except one that maps both keys and values at once
14:30:24 <sioraiocht> FINALLY
14:30:26 * sioraiocht has been having #haskell withdrawals.
14:30:45 <psnively> It's an unusually powerful drug. ;-)
14:32:34 <oerjan> tibbe: well - since mapping keys means completely rearranging the map, it's probably just as efficient to use fromList, List.map and toList?
14:33:31 <tibbe> oerjan: that is what I ended up doing
14:39:54 <Taejo> oerjan: not if your mapping function is increasing
14:43:08 <sioraiocht> psnively: I was freaking out when I found out my college blocks port 6667
14:43:21 <sioraiocht> Luckily freenode keeps ports 8000 and 8001 open for such cases
14:43:33 <sioraiocht> though I thinkI could make a legitimate academic case for #haskell
14:44:02 <psnively> I would hope so!
14:45:48 <sioraiocht> they seem quite restrictive on the use of their network, frankly if I'm not booted for some accidental indiscretion I'll count myself lucky
14:46:39 <sjanssen> sioraiocht: they block 6667 in residential halls?
14:47:00 <sioraiocht> sjanssen: yes, the entire college network, actually
14:47:07 <sjanssen> that is a bit insane
14:47:29 <sioraiocht> sjanssen: from what I can tell, they block nearly all outgoing ports with few exceptions
14:47:45 <ddarius> Hmm, past that slump I see.
14:47:46 <sioraiocht> they probably keep 8000 open because some web servers use them as their incoming ports
14:48:09 <sioraiocht> though oddly
14:48:12 <sioraiocht> JABBER is blocked
14:48:13 <sioraiocht> but not AIM
14:48:42 <sioraiocht> and skype used to be prohibited by the entire uni
14:48:49 <sioraiocht> they just recently changed that
14:49:54 <sioraiocht> iTunes sharing is x prohibited x
14:50:08 <sioraiocht> the use of Tor is as well
14:50:14 <sioraiocht> whiuch really pisses me off
14:52:04 <sjanssen> sioraiocht: where are you?
14:52:14 <sioraiocht> sjanssen: St Anne's College, Oxford
14:52:40 <ddarius> More Eugenia!
14:53:05 <Tac-Tics> why kind of shitty policy is that?
14:53:57 <psnively> Um, a sane one for a university?
14:55:13 <Tac-Tics> cutting off ports just sweeps the real problems under the rug
14:55:19 <sjanssen> psnively: it doesn't seem so sane to me
14:55:37 <sjanssen> why cut off IRC?
14:55:50 <psnively> It is when a) you're paying for the bandwidth, b) you could easily be on the receiving end of lawsuits about how that bandwidth is used.
14:56:23 <psnively> Because IRC supports file sharing, I would imagine.
14:56:40 <Tac-Tics> by a similar set of logic, I would say that water and electricity have the same risks
14:56:45 <Tac-Tics> you pay for both
14:56:54 <Tac-Tics> and you can easily start fires or floods in a school with so many students
14:56:57 <Tac-Tics> there's lots of liability
14:57:44 <Saul_> Yeah I think it's bullshit too, how will you get haskell advice without IRC?
14:57:47 <Tac-Tics> I used to live on a dorm floor with a problem RA who had a personal habit of starting fires in the trash cute when he was bored
14:57:51 <psnively> There's a point at which a difference of degree becomes a difference of kind.
14:58:01 <psnively> LOL
14:58:29 <sorear> RA?
14:58:40 <mrd> resident advisor
14:58:40 <Tac-Tics> resident assistent.... basically the "mayor" of our floor
14:58:46 <Saul_> psnively: Well sure, but IRC can be used for actual communication, not just file sharing
14:58:51 <mrd> you'll learn when you go to school sorear ;)
14:59:02 <sorear> in any case, IRC bandwidth is neglible.  I can see banning http, but IRC?
14:59:02 <psnively> Saul_: Of course, but which one can you be sued for?
14:59:18 <sorear> IRC can be used for file sharing?
14:59:23 <mrd> i'm sure they don't distinguish IRC
14:59:27 <sorear> you're limited to 1kb/s by the server
14:59:28 <mrd> they just block anything not "intarweb"
14:59:41 <Saul_> psnively: I don't think they actually sue universities for it
14:59:47 <sorear> no, wait, 256b/s
14:59:52 <psnively> Saul_: You lose that bet.
14:59:58 <mrd> sorear: DCC
15:00:11 <sorear> that's not IRC though
15:00:18 <sorear> it goes through different ports
15:00:24 <Tac-Tics> regardless
15:00:25 <sorear> besides, this network is natted
15:00:28 <Tac-Tics> if people want to share media
15:00:33 <Tac-Tics> it doesn't matter what ports are blocked
15:00:33 <mrd> well, I'm not sure if you realize this, but generally IRC networks are used for illegal purposes.  freenode is a exceptional network.
15:00:44 <Tac-Tics> I can share through aim or ftp or http just as easily
15:00:50 <mrd> not really #haskell talk anyhow
15:00:59 <sorear> if I were doing something illegal, I wouldn't use such a badly designed protocol
15:01:14 <psnively> Tac-Tics: Right. But the institution needs to be able to demonstrate that they've taken the issue seriously and done what they can.
15:01:14 <mrd> yes, sorear, but you see ... you're intelligent.  most skript kiddies are not.
15:01:21 <Philippa_> mrd: I'm not sure I'd go so far as "generally", though it's frequent
15:01:21 <Cale> When I was in residence at Waterloo, I had my own external IP address.
15:01:33 <Tac-Tics> Cale: did you know a professor named Becker?
15:01:33 <Saul_> Yeah I use bittorrent for filesharing, way easier to use
15:01:43 <Cale> Tac-Tics: nope, is he a CS prof?
15:01:46 <Philippa_> psnively: really they take utterly the wrong approach to it unfortunately
15:01:59 <Tac-Tics> yeah, he wrote the book for our CS classes (<--- Illinois State University)
15:02:04 <Cale> Cool
15:02:13 <Philippa_> problem is, when they take the right approach they instead cosy up to some company that does something utterly horrific in terms of what access they'll provide on a commercial basis because they have a captive market
15:02:19 <Cale> Byron Becker?
15:02:23 <Philippa_> this is one of the reasons I got the hell away from uni-provided accomodation
15:02:23 <Saul_> I usually download in my room though, it's faster than at uni
15:02:35 <Tac-Tics> I was a TA..... so many students (major and nonmajor) had trouble understanding Threads and GUI in their first year
15:02:39 <Tac-Tics> yes, that's him
15:02:53 <Cale> Ah, okay, I've heard the name actually. :)
15:02:59 <Tac-Tics> awesome, hehe
15:03:01 <mrd> they were pretty open about the network here, but later they cracked down on bandwidth.
15:03:09 <Cale> He was the guy who did Karel the robot.
15:03:12 <mrd> it got pretty insane
15:03:20 <Philippa_> I showed up to Nottingham just after they cracked down so far all we got was a JANET proxy
15:03:26 <mrd> our school accounted for half the traffic in the entire region
15:03:27 <Tac-Tics> yeah, Robots. They were the nightmares of so many of my students
15:03:31 <psnively> The only definition of "right" that matters here is the one that doesn't put the institution out of business.
15:03:36 <Philippa_> they'd got sued because someone'd run an FTP server full of warez off their line
15:03:53 <gwern> so is there a way in ghci to alias commands to another? I want :T to go to :t (which goes to :type), but :def doesn't seem to be the right thing to use since it wants IO String and the function :type seems to call doesn't have that type
15:04:04 <Cale> I didn't take the course with Karel, since I started with the next CS course.
15:04:12 <Philippa_> psnively: actually in this country I could probably put a lawsuit together out of that given enough time
15:04:23 <sioraiocht> sorear: sorry, disappeared.  AFAIK, some people freak out because irc could allow someone to be running a both, which is like SO unacceptable...because they said so
15:04:28 <Philippa_> what happened to me was pretty damn bad actually, I'd been specifically promised internet access in hall
15:04:28 <sorear> gwern: it re-evaluates, try return $ ":t"  ++ something or other
15:04:32 <Cale> (I only ended up taking two CS credits, because I was in pure mathematics)
15:04:34 <psnively> Philippa_: Perhaps. :-)
15:04:34 <ddarius> :def :T \_ -> return ":type"
15:04:38 <sorear> sioraiocht: a both?
15:04:39 <Philippa_> an HTTP proxy doesn't cut it
15:04:42 <ddarius> Or what sorear said.
15:04:43 <sioraiocht> sorear: sorry,  a bot
15:05:06 <gwern> sorear: ok
15:05:27 <sorear> sioraiocht: I don't get it.  What's so scary about bots?
15:05:30 <Cale> Anyway, at least when I was in residence there, the internet connection was pretty awesome. There were rolling limits on how much bandwidth you could use, but that only applied to traffic out to the internet.
15:05:35 <sioraiocht> sorear: ask weird IT people
15:05:43 <Philippa_> Cale: yeah, that's the sensible way to do it
15:05:51 <sioraiocht> they also ban anonymisation of any sort
15:05:54 <sioraiocht> which REALLY pisses me off
15:05:57 <Cale> So we got everyone to turn on windows file sharing, and a friend and I wrote a search engine.
15:06:14 <Philippa_> right. There was a crapload of warez being trafficked within halls
15:06:16 <Cale> (which use samba and mysql)
15:06:20 <Tac-Tics> the day is done. Time to head to DDR
15:06:22 <Tac-Tics> later all~
15:06:23 <Cale> used*
17:04:06 --- topic: '["The Haskell programming language: 100% safe to take, with NO side effects!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The language of ICFP winners 3 years running"]'
17:04:06 --- topic: set by dons on [Fri Sep 14 23:11:02 2007]
17:04:42 <chessguy> @bot
17:04:42 <lambdabot> :)
17:05:42 <kscaldef> grumble... how come when I was looking for XML libraries, everyone told me to use HXT, but now when I have questions about it, no one seem to know anything?
17:06:07 <psnively> kscaldef: Try a different library. :-D
17:06:33 <kscaldef> well, HXML doesn't validate, and HaXML seems even more broken that HXT
17:07:00 <wolverian> how is HXT broken?
17:07:29 <kscaldef> wolverian: "has anyone else ever seen HXT go into an inf loop when validating an XML doc?"
17:07:54 <phobes> i'm guessing you have!
17:07:55 <wolverian> not a very good bug report :)
17:08:14 <kscaldef> I sent a better bug report to the maintainers
17:09:31 <encryptio> > fmap (+1) [[1,2],[3,4,5]]
17:09:32 <lambdabot>   add an instance declaration for (Num [t])
17:09:35 <encryptio> aww.
17:10:00 <omniscientIdiot> > fmap (fmap (+1)) [[1,2],[3,4,5]]
17:10:01 <lambdabot>  [[2,3],[4,5,6]]
17:10:03 <kscaldef> however, given that it successfully parses the document, it's hard to understand how validation can fail to terminate.  Maybe tomorrow I will have the energy to dig into the code further
17:10:09 <dnm> Anyone know of good quality Qt bindings for Haskell? Random query.
17:10:13 <encryptio> yeah yeah, but automatic recursion based on the type is so much cooler
17:10:16 <dons> kscaldef: you could also ask the authors
17:10:34 <dons> dnm: we do't have Qt bindings, afaik, due to them being in C++ (?) though it often comes up
17:10:34 <kscaldef> dons: "I sent a better bug report to the maintainers"
17:10:42 <dons> kscaldef: good
17:10:44 <omniscientIdiot> encryptio: you could define an instance Num a => Num [a]
17:10:57 <encryptio> emphasis on automatic
17:10:58 <dnm> dons: Ah.
17:11:43 <LoganCapaldo> encryptio: that woul be difficult, type inference + overloading plus dwim = crazy confusing
17:12:06 <encryptio> and Num a => Num [a] is not a good thing to instansiate, there is a much more general instantiation that i can't describe because i haven't thought about it enough. [[a]] => [a] or something.
17:13:15 <LoganCapaldo> Num [[a]] => Num [a] would be less general...
17:13:25 <encryptio> not Num.
17:13:28 <encryptio> [[a]] => [a]
17:13:39 <LoganCapaldo> wheres the classs?
17:13:49 <encryptio> Functor, i'm not sure how to put it in
17:14:13 * encryptio cowers in the corner at all the people asking him questions about what they seem to think he's thought through
17:14:26 <omniscientIdiot> :)
17:14:57 <LoganCapaldo> instance (Functor f) => Functor (f (f a)) ?
17:14:58 <omniscientIdiot> questions are good for guiding thought sometimes
17:15:19 <encryptio> LoganCapaldo: something like that, yeah
17:15:25 <omniscientIdiot> => Functor (Compose f f), f (f a) doesn't have the right kind
17:15:31 <LoganCapaldo> I'm trying to figure out how to get rid of the a
17:15:44 <LoganCapaldo> omniscientIdiot: yeah
17:16:41 <LoganCapaldo> But you can't partially applied type synonmons and a newtype would make this just as "annoying" as the current situation...
17:17:27 <LoganCapaldo> They need to expose the type lambdas at the haskell level ;)
17:17:44 <encryptio> yay complexity
17:17:51 <encryptio> think how horrible error messages would be then
17:18:11 <LoganCapaldo> encryptio: you started it! ;)
17:18:21 <encryptio> =p
17:18:24 <omniscientIdiot> it's all encryptio's fault!
17:18:58 <EvilTerran> seems `O` might be of use to you there
17:19:19 <EvilTerran> can't for the life of me remember where that is, though
17:19:19 <omniscientIdiot> a name is a name
17:19:40 <EvilTerran> (something to the effect of type O f g x = f (g x))
17:20:02 <omniscientIdiot> O = Compose, but you can't partially apply synonym's
17:20:06 <omniscientIdiot> s/'//
17:20:25 <EvilTerran> ah, yes. i need to study the scrollback closer.
17:20:39 <EvilTerran> can you partially apply type families?
17:20:51 <sjanssen> EvilTerran: no, I don't think so
17:21:23 <EvilTerran> aww
17:21:42 <EvilTerran> having an alternative class, FunctorOf a f | f -> a, would work.
17:22:50 <EvilTerran> FunctorOf a [a], FunctorOf a (Maybe a), ..., (FunctorOf a (f a), FunctorOf (f a) (g (f a))) => FunctorOf a (g (f a))...
17:22:52 <Cale> EvilTerran: except that we already have that, it's called a function ;)
17:22:54 <EvilTerran> i think that would work.
17:22:58 <dbueno> I'm reading "Comprehending Monads" by Wadler -- does the feature it describes exist in Haskell?  That is, a comprehension-syntax that is implemented in a monad?
17:23:14 <Cale> dbueno: Currently we have do-notation
17:23:17 <EvilTerran> might need recrafted to avoid death-by-overlapping-instances
17:23:29 <Cale> dbueno: We used to have monad comprehensions which looked just like list comprehensions
17:23:42 <Cale> dbueno: But the Haskell 98 committee saw fit to remove them
17:23:42 <dbueno> Cale: But there was a problem?
17:23:48 <Cale> dbueno: Not really
17:23:52 <dbueno> Cale: Is there documentation of why?
17:23:58 <Cale> dbueno: Just confusing error messages for beginners
17:24:04 <dbueno> Cale: it seems particularly intuitive.
17:24:17 <Cale> (beginners trying to use list comprehensions would get errors about monads)
17:24:34 <Cale> But I think that's less of a language problem and more of a compiler problem
17:24:59 <encryptio> oh... the functor thing wouldn't work, the types don't work: fmap on [[a]] is explicitly mapping [a]s. it provides no possibilities of breaking down further... alas. so yes, new typeclass required.
17:25:04 <Pseudonym> I also think it made more sense at a time when Haskell was primarily for teaching and research.
17:25:05 <dbueno> Cale: I'm no expert on do-notation -- is it fairly easy to see how do-notation could look like a corresponding comprehension?
17:25:12 <Pseudonym> Haskell is now cool, so I think that argument is weakened.
17:25:20 <Cale> Actually, removing monad comprehensions is the thing which set off a whole avalanche of warts in H98
17:25:27 <Cale> dbueno: yeah
17:25:28 <EvilTerran> fail?
17:25:29 <Pseudonym> dbueno: do { x <- xs; guard (p x); return x } == [ x | x <- xs, p x ]
17:25:37 <Cale> EvilTerran: yeah, fail's included in that
17:25:49 <Cale> EvilTerran: along with MonadZero and MonadPlus being glommed together
17:26:17 <Cale> the bad translation for do-syntax
17:26:31 <Cale> So, most of the things which annoy me :)
17:26:32 <dbueno> Pseudonym: ooh, didn't know about guard.
17:26:43 <Pseudonym> dbueno: I think you need to import Control.Monad or something.
17:26:47 <EvilTerran> class FunctorOf a f where fomap :: (a -> b) -> er, oops.
17:27:04 <dbueno> Pseudonym: Hoogle confirms your thoughts. =]
17:27:07 <Pseudonym> Yeah.
17:27:42 <dbueno> Good to know it seems fairly easy to transition mentally from the comprehension syntax do-notation.  Although comprehensions are particularly elegant-looking, at times.
17:29:43 <dbueno> So what Wadler calls "monads" are MonadPlus's in Haskell?
17:29:49 <dbueno> (In this paper.)
17:34:48 <hpaste>  EvilTerran pasted "class FunctorOf a b fa fb where fomap :: (a -> b) -> fa -> fb" at http://hpaste.org/2938
17:35:01 <EvilTerran> it's really Not Very Nice, but still
17:35:02 <Pseudonym> dbueno: Well, he doesn't have constructor classes in that paper.
17:35:43 <dbueno> Pseudonym: What is a constructor class?
17:35:52 <wli> typeclass
17:36:00 <Pseudonym> Typeclass with higher kinds.
17:36:12 <Pseudonym> instance Eq Bool -- This is a type class, because Bool is a type.
17:36:22 <Pseudonym> instance Monad IO -- This is a constructor class, because IO is a constructor.
17:36:41 <Pseudonym> The distinction is blurred in Haskell with the kind system.
17:36:56 <Pseudonym> But Haskell originally had type classes, but not constructor classes.
17:37:11 <EvilTerran> picking instances based on arcane inference hackery always makes me feel warm and fuzzy inside =]
17:37:15 <LoganCapaldo> and thus I learn something new today
17:37:19 <dbueno> Right.  I see.  I guess what I mean is, what do *I* need to have an instance of in order to be able to get functions that behave according to his laws for "map", "unit" and "join"?
17:37:24 <dbueno> unit == return, obviously.
17:37:29 <Pseudonym> It's not a useful distinction any more, but when you're reading historic papers like you are...
17:37:33 <EvilTerran> map = fmap = liftM
17:37:37 <EvilTerran> @src join
17:37:37 <lambdabot> join x =  x >>= id
17:37:42 <EvilTerran> join = join :P
17:37:42 <Pseudonym> unit = return
17:37:48 <Pseudonym> join = concat, in lists, too
17:37:49 <LoganCapaldo> @type join -- more informative
17:37:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:38:09 <dbueno> Join looks familiar.
17:38:16 <dbueno> @type liftM
17:38:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:38:31 <EvilTerran> any thoughts on that FunctorOf class? i'd hope to reduce it to two parameters (FunctorOf a fa), but that doesn't seem to be possible
17:39:18 <dbueno> EvilTerran: map, fmap, and liftM seem to have similar types, but liftM is the only one that actually works for monads, right?
17:39:41 <dmwit> liftM works for all monads.
17:39:58 <LoganCapaldo> in list map == fmap == liftM
17:40:00 <dmwit> map works for the list monad.
17:40:01 <sjanssen> dbueno: in an ideal world, Functor would be a superclass of Monad
17:40:11 <dmwit> fmap works for all functors (and therefore, usually monads).
17:40:13 <dbueno> Ah, I see.  In thi list monad.
17:40:16 <LoganCapaldo> stupid non-ideal worlds
17:40:18 <EvilTerran> making the second one's context be (FunctorOf a b fa fb, Functor g) => rather than FunctorOf everywhere was not only terser, but i think also is needed to escape death by overlapping instances
17:40:25 <dbueno> sjanssen: Why isn't it?
17:40:46 <sjanssen> dbueno: I'm not sure, I'm convinced it was a bad decision
17:40:58 <dbueno> sjanssen Part of H98?
17:41:03 <sjanssen> yes
17:42:09 <Pseudonym> I think it made sense in 1998.
17:42:14 <Pseudonym> I don't think it makes sense today.
17:42:22 <sjanssen> Pseudonym: what has changed?
17:42:29 <Pseudonym> Haskell is used seriously.
17:42:39 <encryptio> dmwit: what monad is not a functor?
17:42:46 <Pseudonym> That's what's changed.
17:43:04 <EvilTerran> a monad is a monoidal applicative functor, is it not?
17:43:07 <dmwit> I've written a few monads and not explicitly instanced Functor.  Mainly laziness.
17:43:08 <Pseudonym> As a first-year "introduction to computer science" language, it's much more important to have the good error messages,.
17:43:24 <encryptio> dmwit: yes, but are there any that cannot have sane Functor instances?
17:43:26 <psnively> Helium?
17:43:28 <Pseudonym> But if you're using Haskell in anger, it's more important to have one concept that you can use everywhere.
17:43:31 <dmwit> encryptio: No.
17:43:37 <EvilTerran> ie any monad is a functor, so any Monad *could* be trivially made a Functor, with instance Functor Foo where fmap = liftM
17:43:41 <dbueno> Pseudonym: That's how Haskell was originally applied?  I've been meaning to read the history of haskell paper, but haven't got around to it yet....
17:43:43 <Pseudonym> Yes, I'd be happy if Helium were the teaching language.
17:43:45 <sjanssen> Pseudonym: I don't see how "class Functor m => Monad m" can cause bad error messages
17:43:57 <Pseudonym> sjanssen: Oh, as for that...
17:44:05 <wli> Who the *@#$ ever heard of fmap and liftM? Functor is Functor and its method should be called map.
17:44:18 <EvilTerran> people expect liftM = fmap; it'd be mean to break it for a certain type, even if you could
17:44:18 <Pseudonym> I think that class Functor m => Monad m requires a language feature that we don't have.
17:44:35 <EvilTerran> (for instance, using the list monad as-is, but making the list Functor instance be ZipList)
17:44:43 <Pseudonym> You should be able to define a Monad instance, and get the Functor instance for free.
17:44:56 <sjanssen> Pseudonym: I don't think that's a sufficient explanation
17:45:25 <sjanssen> Pseudonym: we're talking about a *single line* of additional code to write the fmap instance
17:46:08 <Pseudonym> No, I disagree.
17:46:23 <Pseudonym> For lists, fmap is a single line.  For other monads, that may not be true.
17:46:43 <LoganCapaldo> Pseudonym: if you wrote the monad instance it _is_ a single line
17:46:48 <LoganCapaldo> fmap = liftM
17:46:50 <dbueno> Pseudonym: so fmap wouldn't always be liftM?
17:47:03 <Pseudonym> But I thought we were also ditching liftM.
17:47:03 <sjanssen> Pseudonym: if you've got a Monad, it is a single line
17:47:06 <sjanssen> @src liftM
17:47:06 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:47:38 <encryptio> oh damn.
17:47:44 <sjanssen> Pseudonym: instance Functor m where fmap f m = m >>= return . f
17:48:02 <Pseudonym> sjanssen: But that means that Functor requires a Monad instance, and Monad requires a Functor instance.
17:48:03 <EvilTerran> instance Monad m => F-, yeah.
17:48:09 <Pseudonym> Which is a circular dependency.
17:48:15 <Tac-Tics> Functions!
17:48:16 <wli> I don't see the point of liftM; it's just fmap with a less general type.
17:48:27 <Pseudonym> Yeah, me neither.
17:48:28 <EvilTerran> Pseudonym, remember the => in class declerations points the wrong way
17:48:30 <Pseudonym> I never use it.
17:48:36 <Pseudonym> And I always associate "lift" with transformers.
17:48:43 <dbueno> Pseudonym: You use fmap instead?
17:48:45 <EvilTerran> it's not circular, just... odd.
17:48:45 <Pseudonym> Yes.
17:48:53 <sjanssen> Pseudonym: Haskell handles that well, doesn't it?
17:49:03 <encryptio> it reads nicer than fmap when you do things like: do v <- liftM myFunc myMonadValue
17:49:13 <wli> I use fmap instead (and am miffed the name "map" got eaten by monomorphic bullcrap).
17:49:24 <Pseudonym> sjanssen: I think you might need -fallow-undecidable-instances or something.
17:49:54 <Pseudonym> I think it would make more sense if you could just do:
17:50:00 <Pseudonym> instance Monad IO where
17:50:02 <sjanssen> Pseudonym: look more closely, I'm not defining a catch-all instance for Functor
17:50:03 <Pseudonym>     ...
17:50:09 <Pseudonym> And derive the fmap instance directly.
17:50:19 <Pseudonym> class (Functor m) => Monad m where
17:50:26 <Pseudonym>     (>>=) :: ...
17:50:30 <sjanssen> erm, my example was bad
17:50:33 <Pseudonym>     fmap m = m >>= id
17:50:45 <Pseudonym> Allow the child class to provide a default implementation for the parent.
17:50:50 <sjanssen> for any Monad M, you can get the Functor instance with "instance Functor M where fmap f m = m >>= return . f"
17:50:57 <Pseudonym> Then you just declare a Monad instance and you get Functor for free.
17:51:06 <Pseudonym> Sorry, yeah, I got that wrong.
17:51:07 <sjanssen> Pseudonym: sure, that'd be handy sometimes -- but it isn't required
17:51:12 <ericlavigne> How do I convert from Integer to Double? I found round, truncate, etc for going in the other direction.
17:51:21 <sjanssen> Pseudonym: consider Eq and Ord
17:51:30 <LoganCapaldo> @type fromIntegeral
17:51:32 <lambdabot> Not in scope: `fromIntegeral'
17:51:36 <Pseudonym> sjanssen: It's not required in the sense that you can do without it.
17:51:39 <encryptio> @hoogle fromIntegral
17:51:40 <LoganCapaldo> @type fromIntegral
17:51:40 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
17:51:41 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:51:49 <sjanssen> Pseudonym: Ord subsumes Eq, but nobody complains that Eq is a superclass of Ord
17:51:55 <wli> I say class Functor f where map :: f t -> f t' ; class Functor m => Monad m where { join :: m (m t) -> m t ; return :: t -> m t }
17:52:05 <LoganCapaldo> > fromIntegral 3 :: Double
17:52:07 <lambdabot>  3.0
17:52:09 <ericlavigne> @Double fromIntegral 7
17:52:10 <lambdabot> Unknown command, try @list
17:52:14 <LoganCapaldo> > fromIntegral 3 :: Float
17:52:15 <lambdabot>  3.0
17:52:23 <Pseudonym> sjanssen: I don't mind that because most of the time, I just derive them.
17:52:44 <LoganCapaldo> > fromIntegral 3 + 2.3
17:52:45 <lambdabot>  5.3
17:52:47 <Pseudonym> When I need to implement my own semantics, it is a little painful to have to implement both Eq and Ord instances.
17:52:55 <Pseudonym> When I could jsut implement Ord and be done with it.
17:52:55 <dmwit> > 3 + 2.3
17:52:57 <lambdabot>  5.3
17:53:13 <LoganCapaldo> dmwit: that's besides the point
17:53:21 <ericlavigne> So usually Integers autocast to Double?
17:53:28 <LoganCapaldo> no
17:53:32 <LoganCapaldo> they don't
17:53:49 <wli> Actuallly...
17:53:57 <LoganCapaldo> > (3 :: Double) + 2.3
17:53:58 <lambdabot>  5.3
17:54:05 <LoganCapaldo> > (3 :: Integer) + 2.3
17:54:06 <lambdabot>   add an instance declaration for (Fractional Integer)
17:54:08 <Saizan> Pseudonym: you can implement Ord and then instance Eq MyType where x == y = compare x y == EQ
17:54:13 <wli> I will even go so far as to say class Functor f where map :: f t -> f t' ; class Functor m => Monad m where { join :: m (m t) -> m t ; unit :: t -> m t }
17:54:37 <LoganCapaldo> it's just so happens that the literal 3 is a perfectly valid way of writing the double 3.0 or the integer 3
17:54:41 <wli> "return" just crossdresses it as imperative.
17:55:35 <LoganCapaldo> either way fromIntegral is how you get a Double from an Integer,
17:55:36 <Tac-Tics> lol
17:56:19 <LoganCapaldo> or a Float from an Int
17:56:21 <ericlavigne> LoganCapaldo: I see how to use that. Now I'm just trying to figure out how this pattern fits what I already know. Probably I can do that on my own.
17:56:36 <ericlavigne> let a = 3 :: Int
17:56:50 <ericlavigne> let b = fromIntegral a :: Num
17:56:52 <ericlavigne> b
17:57:05 <LoganCapaldo> Num is a class not a type
17:57:38 <LoganCapaldo> @instances Num
17:57:39 <lambdabot> Double, Float, Int, Integer
17:57:49 <Tac-Tics> "class" and "return" in Haskell were named as such to confuse the hell out of imperative programmers
17:57:55 <dbueno> What is the difference between Monad and Control.Monad in GHC?
17:58:12 <dmwit> The name.
17:58:23 <dbueno> Ooh.  Okay.
17:58:24 <dmwit> Monad is H98.
17:58:28 <Tac-Tics> the latter is the hierarchial name for it
17:58:31 <Tac-Tics> Monad is the classical name
17:58:36 <dmwit> (There's no hierarchies in H98.)
17:59:24 <dbueno> Have you all read H98 or do you just pick up what's in it as you go along?  I'm wondering if it's one of those language specs you read or you ignore. =]
18:00:09 <ihope_> I've pretty much ignored it.
18:00:34 <Tac-Tics> the standard doesn't have all the modern niceness of ghc or hugs
18:00:42 <Tac-Tics> but it would be interesting to skim
18:00:51 <LoganCapaldo> the haskell report is probbaly the only language standard I've even made any sort of dent in reading
18:01:19 <Tac-Tics> The Scheme standard isn't too hard a read
18:01:26 <psnively> Mostly for being brief.
18:01:27 <Tac-Tics> it's very skimpy on the details though ^^;
18:01:37 <ericlavigne> LoganCapaldo: I think that I understand now. Thank you. Back to reading....
18:01:40 <psnively> Excuse me? The entire denotational semantics is there!
18:01:54 <Tac-Tics> You are excused =-P
18:02:04 <psnively> Then there's VLISP, for the truly hardcore.
18:02:06 <LoganCapaldo> ericlavigne: you're welcome
18:02:19 <psnively> One annoyance of OCaml and Haskell: neither has a formal semantics.
18:03:56 <Philippa_> hmm, why am I thinking all of a sudden that "val" would be a good name for return?
18:04:05 <Philippa_> the haskell report's useful once in a while
18:04:17 <Tac-Tics> the more category theoretic name is "unit" I think
18:04:19 <Philippa_> there's no formal semantics but at least it gives you equational reasoning
18:04:25 <Tac-Tics> but I think "wrap" would be a cool name for "return"
18:04:43 <dibblego> putInSpaceSuit
18:04:43 <chessguy> i like 'lift', though that suggests other things now
18:04:52 <Tac-Tics> @let putInSpaceSuit = return
18:04:53 <lambdabot> <local>:7:17:     Ambiguous type variable `m' in the constraint:       `Monad...
18:04:55 <psnively> Yeah, it's not a total loss. I like OCaml and what little I know of Haskell.
18:04:59 <ihope_> @docs
18:04:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:05:02 <chessguy> how about 'new'
18:05:07 <Tac-Tics> How is OCaml as a language?
18:05:09 <psnively> I just found the "details" comment on the Scheme spec to be, um... quite odd.
18:05:21 <Tac-Tics> I've tried to read the tutorials, but it doesn't really ring as strongly as Haskell did with me
18:05:24 <Philippa_> (the reason I'm thinking of 'val' - the connection to A-Normal Form)
18:05:32 <psnively> Tac-Tics: In my experience, quite nice, if you prefer a language with more pragmatic compromises than Haskell.
18:05:56 <ericlavigne> I found OCaml much easier to learn than Haskell, still trying with the latter, but I have a feeling Haskell will be worth it.
18:06:02 <psnively> Yeah. If you find yourself really drawn to typeclasses, you likely won't care for OCaml.
18:06:04 <Tac-Tics> How do the standard libraries for OCaml rank?
18:06:07 <P_D> on ocaml: "I mean, really astoundingly fast, which is why it is so evil. Its like that psychotic girlfriend that was amazing in bed. You keep trying to break up with her, but she seduces you right back into that abusive relationship."
18:06:12 <Tac-Tics> Compared to Haskell or python?
18:06:23 <psnively> The standard libraries are "adequate." Everyone uses ExtLib for real work.
18:06:34 <psnively> P_D: LOL
18:06:37 <P_D> It's a punishing language.  F# is better, but slow.
18:06:45 <psnively> "Punishing?"
18:06:47 <Tac-Tics> ExtLib?
18:07:08 <psnively> http://ocaml-lib.sourceforge.net
18:07:09 <lambdabot> Title: OCaml ExtLib Home Page
18:07:13 <P_D> as a science guy lack of operator overloading hurt me a lot
18:07:17 <ericlavigne> ExtLib is the extended standard library, because many believe that the real standard library is too small.
18:07:17 <wli> The thing I liked so much about SML and Caml was the module system.
18:07:34 <P_D> I could never get extlib working on windows
18:07:40 <Tac-Tics> Haskell's modules could use some improvement
18:07:40 <psnively> Yes. OCaml's module system in particular rocks.
18:07:48 <P_D> Except that it's slow.
18:07:52 <P_D> doesn't compile right.
18:08:12 <dbueno> I've heard that functors in ocaml give you as much (more?) expressive power than typeclasses.  I gleaned this from some slides I now can't find.  Does this ring a bell?
18:08:16 <P_D> OCaml's development is locked up tight.  The guys at inria do everything and ignore contributions
18:08:31 <psnively> dbueno: Yes.
18:08:42 <psnively> P_D: Some of us find that a feature.
18:08:52 <dbueno> I thought it was slides from a haskell talk, but I don't remember.
18:09:02 <ericlavigne> The guys at inria do a good job, though. They create high quality tools, and the source code of those tools is very readable.
18:09:16 <psnively> dbueno: As usual, Oleg Kiselyov has explored that topic rather thoroughly.
18:09:18 <chessguy> who/what is inria?
18:09:33 <P_D> Sure, it's great, compared to something like C
18:09:34 <psnively> French CS research center.
18:09:44 <ericlavigne> Inria is a research institute, and the OCaml creators work there.
18:09:57 <wli> dbueno: In down-to-earth terms, they're not competing features. They're used in vastly different contexts.
18:09:59 <psnively> P_D: I'd argue, compared to virtually everything, eh-maybe-including-or-not Haskell.
18:10:11 <P_D> Well I agree with you.
18:10:21 <chessguy> by the way, anybody see the video linked on LtU yesterday about the future of programming?
18:10:22 <Philippa_> wli: I wouldn't go that far, and something suitably unifying is a Good Thing
18:10:29 <chessguy> err, s/video/audio/
18:10:33 <Tac-Tics> awe, there's no SDL binding for OCaml
18:10:35 <ericlavigne> I don't use ExtLib. The real standard library is mostly caught up, and is better implemented.
18:10:36 <chessguy> and s/see/hear/
18:10:37 <Philippa_> but they certainly started off in very different contexts
18:10:44 <psnively> Tac-Tics, eh? I use ocaml-sdl all the time.
18:10:50 <Tac-Tics> really? hmm
18:10:51 <dbueno> wli: It's true that functors are rarely referred to as "a mechanism for operator overloading".
18:10:58 <Tac-Tics> psnivley: It's not on the sdl main page
18:11:05 <Tac-Tics> ah
18:11:09 <Tac-Tics> it's under "ML"
18:11:09 <dbueno> wli: But I wonder whether it's practical if one were actually to code that way.
18:11:24 <Philippa_> not least because functors require you to state explicitly what the type class system will infer
18:11:25 <Tac-Tics> Since OCaml's claim to fame is it's speed, that's what I'd want to tinker with
18:11:32 <wli> Philippa: Module systems and typeclasses, while theoretically unifiable, don't really have anything to do with each other when people are actually programming (unless they're doing typesystem stunts).
18:11:32 <psnively> http://ocamlsdl.sourceforge.net/home.html
18:11:33 <lambdabot> Title: OCamlSDL
18:11:46 <dbueno> Tac-Tics: Speed of compilation or execution?
18:12:00 <Tac-Tics> execution
18:12:02 <ericlavigne> OCaml is great for projects where people expect me to use Fortran. Easier to work with, shorter code, just as fast.
18:12:20 <Philippa_> wli: I've had crossover cases that didn't feel overly stuntlike
18:12:42 <LoganCapaldo>  
18:12:50 <psnively> Besides, typeful programming IS "typesystem stunts."
18:12:53 <P_D> Sure, if you can read 1 /.3*.x-.(x*.y)
18:13:06 <Philippa_> hell, a lot of instances get written that're very clearly equivalent to "in this situation, apply this functor to an existing instance to get a new one"
18:13:08 <P_D> Or rather 1.0/.3.0*.x-.(x*.y)
18:13:38 <JFT> IMVHO if you learn Ocaml before Haskell you might like it but once you touch Haskell Ocaml feels very lacking in term of expressiveness
18:13:48 <P_D> Yeah exactly my feelings, JFT
18:13:53 <ericlavigne> I tend to use more spaces: 1.0 /. 3.0 *. x -. (x *. y) so that the operators appear distinct
18:14:01 <P_D> I loved ocaml to death until haskell started to make sense.
18:14:16 <ericlavigne> JFT: That's what I'm hoping, still trying to reach that point.
18:14:19 <JFT> I used Ocaml to introduce myself to static  type inference on my way to Haskell, and for that it was good
18:14:32 <P_D> Writing programs that worked the first time you run them.. miraculous!
18:14:38 <JFT> hell yes
18:14:45 <JFT> and compilation DO mean something!
18:15:26 <dbueno> P_D: I've just started considering that there might be a language I like more than OCaml.
18:15:33 <psnively> Yes. I have to admit, Oleg's writing on Haskell has gotten me more and more curious, and I'm interested in, e.g. hs-plugin... tired of waiting for natdynlink in OCaml.
18:15:38 <dbueno> Interesting that other ocaml hackers' experience is similar....
18:15:49 <ericlavigne> OCaml already feels lacking in expressiveness (coming from Lisp background) but makes up for it in other ways. Hoping for the best of both in Haskell.
18:16:21 <JFT> If you read some blog about Hacker that cut their teeth on the ICFP contest of this year, many that were fan of Ocaml are a bit less...
18:16:33 <Philippa_> *snigger*
18:16:39 <Philippa_> yeah, that was possibly a little unfair though :-)
18:16:42 <wli> I started more on the SML side but SML/NJ's weird compilation model made it awkward to use in various places, so I started using ocaml.
18:17:02 <ericlavigne> I first heard about Data.Sequence in that competition. I'm quite impressed with the neat tools in Haskell standard library.
18:17:02 <psnively> OCaml's applicative functors are very nice, though.
18:17:29 <JFT> psnively: I'll have to check that up as this doesn't ring any bell :/
18:17:48 <wli> I actually learned Haskell around the same time and gravitated more to it later.
18:18:00 <psnively> JFT, sorry, what doesn't?
18:18:13 <JFT> psnively: what are they "equivalent" to in Haskell? (Applicative Functor)
18:18:37 <JFT> I may have discarded Ocaml too fast, I mean before seeing some of its jewel :)
18:18:51 <psnively> Oh! Some ways of combining modules and typeclasses, IIRC.
18:19:16 <psnively> http://www.haskell.org/pipermail/haskell/2004-August/014463.html
18:19:17 <lambdabot> Title: [Haskell] Applicative translucent functors in Haskell
18:19:21 <JFT> psnively: Thanks I'll check this, as the lack of typeclass was one of the main peeves I had against Ocaml
18:19:43 <wli> Scoped instances anyone?
18:19:58 <dbueno> wli: That's weird.  CM in SML was the thing I missed *immediately* when I went from SML to OCaml.
18:20:13 <dbueno> wli: I hated having to make my own Makefiles and blah blah.
18:20:14 <psnively> CM? Compilation Manager?
18:20:21 <dbueno> Yes.
18:20:31 <psnively> JFT: Yeah, it'd be nice to have typeclasses!
18:20:33 <P_D> the 3.10 release has an ocamlbuild tool, which I have not tried
18:20:45 <psnively> dbueno: Gotcha. Personally, I like http://omake.metaprl.org
18:20:46 <lambdabot> Title: The OMake build system
18:21:17 <dbueno> psnively: It looks nice, but I've never used it.  I have used OCamlMakefile, which is certainly suboptimal.
18:21:20 <swix> if the title of your webpage is a lambda function with the bot execute it?
18:21:35 <psnively> dbueno: It's a world of difference.
18:21:40 <dbueno> psnively: with CM in SML you literally put each module name on one like and call one function in SML... and you're done.
18:21:50 <dbueno> psnively: ... one *line*.
18:22:19 <psnively> dbueno: I think you'd find omake similarly concise.
18:22:31 <wli> dbueno: I liked CM too but had issues with SML/NJ not working on some arches/OS's/etc.
18:22:57 <dbueno> psnively:  I'll keep it in mind for my (hypothetical) next OCaml project.
18:23:33 <psnively> dbueno: Yeah. If you do a lot of typeclass hackery, OCaml functors are likely to annoy you. Other than that, though...
18:24:22 * wli used to write in the fully functorial style.
18:24:26 <JFT> Honestly I find it hard to imagine hacking Haskell without lots of typeclass
18:24:43 <JFT> Not sure if my style is idiomatic or not though :P
18:24:46 <dbueno> psnively;  I've used functors in the past for hooking up large backends to other pieces of code ... never for code as "small" as a type class/instance would require.
18:25:42 <dbueno> psnively: I'm puzzling over how bad it would be if I parameterised all my code by functors... so that if I ever used a simple stack I'd actually take a stack module as a functor parameter, and that could be just a list, but I'd never know.
18:25:53 <psnively> Yeah
18:26:11 <wli> dbueno: Yeah, realistic/idiomatic usage of functors cuts across typeclasses.
18:26:44 <shachaf> fix's type isn't invariably restricted to ((a -> b) -> (a -> b)) -> (a -> b) in practice, is it?
18:26:52 <shachaf> What about, say, fix (1:)?
18:27:20 <psnively> You can go nuts with functorizing, definitely.
18:28:46 <psnively> Typeclasses seem like a big win in Haskell... principled overloading, and all that.
18:29:24 <wli> Typeclasses + higher-order modules would rule the universe.
18:29:26 <JFT> psnively: Naively I also think of them as "mixins" as by deriving them you get lots of freebies
18:29:37 <JFT> akin to mixins in Ruby
18:29:57 <psnively> Yes.
18:30:08 <ddarius> That's one thing about Haskell I like, the abstraction mechanisms are very lightweight.  It makes abstracting code very easy.
18:30:13 * wli runs screaming at OO stuff like mixins.
18:30:27 <psnively> It's interesting, though. I had Coq a little, and stuff like an infinite type hierarchy really isn't all THAT useful.
18:30:39 <ddarius> * : * all the way
18:30:40 <dbueno> JFT: That's one of the big annoyances of OCaml... no "deriving".
18:30:52 <dbueno> Man deriving saves so much time.
18:31:12 <psnively> http://code.google.com/p/deriving/
18:31:12 <lambdabot> Title: deriving - Google Code
18:31:14 <JFT> dbueno: true but Haskell is not really "deriving" either, bad name IMO altough the analogy make sense
18:31:33 <wli> There need to be polytypic bits to allow things to derive on fresh typeclasses.
18:31:34 <mrd> i wonder how things like QuickCheck look with functors
18:31:35 <JFT> I'd chosen "adopting" instead
18:31:36 <dbueno> psnively: I'm aware of that, but only became so after I'd finished my last big OCaml project. =[
18:31:38 <psnively> Had Coq? HACK Coq.
18:31:58 * mrd is too tired to think much about it though
18:31:59 <psnively> dbueno: Yeah, just making the point that OCaml is developing some sweet libraries. :-)
18:32:42 <JFT> wli: Sorry for scaring you ;) Been working too long in OO, hard to not draw parallels lol
18:32:54 <psnively> I'm so over objects.
18:33:06 <JFT> me too
18:33:10 <mansu> hi all
18:33:16 <JFT> but 13 years of OO vs 1 year of FP...
18:33:26 <psnively> Yeah, not to mention the ENTIRE INDUSTRY.
18:33:37 <dmwit> Hiya mansu!
18:33:52 <wli> I hack the Linux kernel for a living.
18:33:57 <wli> No OO here.
18:33:59 <JFT> I manage to bring some Haskell to my company and trying to push FP but it isn't easy :(
18:34:08 <psnively> wli: I'm sorry.
18:34:38 <JFT> wli: ouch straight C would be my death :/
18:35:18 <allbery_b> <wli> I hack the Linux kernel for a living.
18:35:22 <allbery_b> I'm sorry :)
18:35:41 <JFT> Curiosity of my part how many of you long time Haskell hackers have read/understand Category Theory?
18:35:53 <JFT> Is that "required" to really understand the bowel of "the beast"?
18:35:59 <dmwit> Dang, why all the smack talk against C and the kernel?
18:36:08 <dmwit> JFT: nah
18:36:26 <wli> Straight C? Well, when not asm. ;)
18:36:39 <dmwit> JFT: I don't really grok category theory, but monads in Haskell are only tangentially related to monads in category theory.
18:36:46 <dolio> JFT: It's just cool stuff to know. :)
18:36:52 <dmwit> Using them is possible without all the theory.
18:37:03 * allbery_b is a freebsd-er.  and got fed up with the linux community several years back, after being a card carrying linux hacker for years
18:37:05 <psnively> dmwit: It's long past time to get past C's ascendancy for "bare metal" stuff.
18:37:21 <psnively> The Lisp Machine should have put paid to that account.
18:37:22 <JFT> Yes I"m now using Monad and monad transformer just fine, but I was wondering if I'd gain some precious insight by studying Category Theory...
18:37:36 <psnively> God willing, Coyotos/Bit-C will.
18:37:37 <dmwit> psnively: Bah.  At least C has a stable definition and a fairly simple standard.
18:37:38 <mansu> Is there an operator in haskell to compare charecters? I want to say if x == " "
18:37:49 <mansu> hi dmwit
18:37:51 <psnively> dmwit: Bwahahahahahahahaha!
18:37:52 <dmwit> > ' ' == ' '
18:37:54 <lambdabot>  True
18:38:01 <omniscientIdiot> mansu: that should work
18:38:02 <dmwit> > " " == " "
18:38:03 <ddarius> JFT: I have read and understood category theory and no it's not required at all.
18:38:03 <lambdabot>  True
18:38:08 <dmwit> > " " == ' ' -- type error
18:38:09 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
18:38:09 <Olathe> > let x = 'p' in x == ' '
18:38:09 <omniscientIdiot> if x is a String
18:38:10 <mansu> omniscientIdiot, ah thx
18:38:11 <lambdabot>  False
18:38:19 <P_D> try compiling the kernel with a random version of GCC.. good luck.
18:38:24 <JFT> ddarius: Thanks, did you retired anything good, applicable out of it?
18:38:25 <mansu> omniscientIdiot, what do I do for strings?
18:38:34 <Olathe> > let x = "hello" in x == "hello"
18:38:36 <lambdabot>  True
18:38:54 <dmwit> P_D: Oh yes, and the various Haskell implementations are so portable!
18:39:03 <ddarius> "retired"?  There is definitely useful stuff (most of it isn't immediately/obviously), but you definitely don't need it to be a superb Haskell hacker.
18:39:05 <omniscientIdiot> both Char and [Char] (or String) are in Eq, so just use (==)
18:39:14 <mansu> omniscientIdiot, thx
18:39:18 <JFT> dmwit: I'm using GHC on Linux, OS X and Windows and it works very well :)
18:39:28 <dmwit> I'm not saying C is great, or it's the be-all end-all; I'm just saying it doesn't deserve heaping spoonfulls of scorn.
18:39:30 <omniscientIdiot> Char literals use single quotes, String literals, double-quotes
18:39:44 <psnively> dmwit: I think the point is that one can easily envision a language as portable as C that does bare-metal without C's warts (e.g. Bit-C).
18:39:45 <dmwit> JFT: Chances are good you are also using GHC-specific extensions that don't fly in YHC or Hugs.
18:39:49 <wli> allbery_b: Well, if I do that I'm out of a rather decent-paying job and have to ship almost a ton of equipment to the next sparc32 mantainer at my expense.
18:39:54 <JFT> dmwit: I wasn't scorning it's just that C is 20 years in my  past :)
18:40:02 <JFT> dmwit: you are right as I only use GHC
18:40:07 <ddarius> psnively: Heck, just start with C and remove some of its warts and you'd already be much better.
18:40:13 <psnively> dmwit: Well, we're going to have to agree to disagree there: I think it deserves many metric tons of scorn.
18:40:14 <allbery_b> guess so, my main claim to fame back when was iBCS2
18:40:14 <ddarius> E.g. add TCO.
18:40:36 <allbery_b> (which dates me pretty seriouslyt I think, then again I think I may be the oldest regular contributer here anyway :)
18:40:43 <psnively> ddarius: They tried (C++). ;-)
18:40:50 <Tac-Tics> C > PHP
18:40:55 <ddarius> psnively: C++ doesn't have TCO.
18:40:59 <Tac-Tics> PHP is the most garbage language
18:40:59 <wli> allbery_b: It's been removed and people at my work want it back.
18:41:01 <fax> silly programming languages
18:41:02 <psnively> OK, folks, I'm out.
18:41:03 <dmwit> C doesn't have to suck.
18:41:05 <ddarius> psnively: I said remove, not add.
18:41:07 <fax> none of them are haskell
18:41:08 <psnively> Enjoy!
18:41:09 <dmwit> Look at dwm.
18:41:14 <psnively> ddarius: A good point.
18:41:15 <JFT> psnively: Night
18:41:43 * dmwit decides to shut up
18:43:13 <Tac-Tics> Why can't you end a Cont with the k from a callCC in Haskell?
18:43:14 <hpaste>  Tac-Tics pasted "(no title)" at http://hpaste.org/2939
18:43:30 <Tac-Tics> I can't figure out why the second version there fails
18:45:14 <hpaste>  mansu pasted "trim" at http://hpaste.org/2940
18:45:32 <wli> allbery_b: I remember and used to use iBCS2
18:45:37 <mansu> http://hpaste.org/2940 what's the indentation error in this program?
18:46:14 <Cale> Tac-Tics: um, why are you calling runCont inside of a Cont computation?
18:46:28 <omniscientIdiot> mansu: x :: Char, so use (x == ' ')
18:46:30 <Cale> Tac-Tics: I suppose you can do that, but it's a strange thing to do
18:46:40 <Tac-Tics> because I don't understand how to use them yet, clearly
18:46:47 <omniscientIdiot> " " :: String
18:47:25 <mansu> omniscientIdiot, are the precedence rules different inside an if in haskell? I thought haskell automatically gets the arguments to a func
18:47:56 <Tac-Tics> mansu: did you mean to use 'ltrim' recursively?
18:48:00 <Tac-Tics> because you have 'trim' written there
18:48:15 <Tac-Tics> the indentation seems fine
18:48:17 <mansu> Tac-Tics, yeah
18:48:26 <omniscientIdiot> mansu: Hmm?, the problem is that x has type Char, but " " has type String, so you get a type error.
18:48:36 <omniscientIdiot> use ' ' instead
18:49:07 <mansu> omniscientIdiot, it gaives me a parse error in a line which is beyond my program...
18:49:11 <Cale> Tac-Tics: The whole point of the continuation monad is that you don't have to explicitly pass the continuation
18:49:27 <Tac-Tics> I understand that much
18:49:29 <omniscientIdiot> hm, I can't see any parse errors in the pasted code
18:49:37 <Tac-Tics> I guess I just haven't seen enough examples of Cont used correctly
18:49:45 <Tac-Tics> and I clearly can't think of any interesting examples myself ^^;
18:49:46 <hpaste>  mansu annotated "trim" with "(no title)" at http://hpaste.org/2940#a1
18:49:57 <Cale> fact n a = callCC $ \k -> do
18:49:57 <Cale>             when (n == 0) (k a)
18:49:57 <Cale>             fact (n - 1) (n * a)
18:50:06 <Tac-Tics> hah
18:50:07 <Cale> You could do that
18:50:13 <mansu> omniscientIdiot, i pasted the total code...
18:50:14 <Tac-Tics> yeah, I could
18:50:19 <Cale> But then the callCC is kinda pointless too
18:50:36 <Tac-Tics> yeah
18:50:45 <Tac-Tics> I'm trying to figure out how to use callCC in an interesting way
18:51:01 <hpaste>  mansu annotated "trim" with "(no title)" at http://hpaste.org/2940#a2
18:51:10 <omniscientIdiot> mansu: in a Haskell file, the only thing allowed toplevel is definitions, try adding "main = print " before that next line.
18:51:26 <mansu> omniscientIdiot, i pasted the whole file...
18:51:45 <omniscientIdiot> ltrim "  Suman" isn't allowed there
18:52:05 <Cale> Tac-Tics: I'll see if I can come up with an interesting direct example
18:52:06 <hpaste>  (anonymous) annotated "trim" with "(no title)" at http://hpaste.org/2940#a3
18:52:51 <mansu> omniscientIdiot, yeah figured that out.. why is it not allowed?
18:53:01 <Tac-Tics> Continuations and Monads are both something that I think I understand, and if I had a test or something on them, I'd get like a 90% on
18:53:15 <Tac-Tics> but I have no clear idea of how to use them. I have no intuition for them at all =-(
18:53:22 <omniscientIdiot> because it's just an expression?  Haskell source files only permit definitions.
18:53:39 <JFT> Tac-Tics: monads in general or just the continuation monad?
18:53:44 <Tac-Tics> general-style
18:54:25 <JFT> Tac-Tics: well I've learn alone and had some difficulty to grasp them for a while. The key to understand them for me was to work on the state monad
18:54:35 <omniscientIdiot> mansu: did you want it to evaluate that and show the result for testing or something?
18:54:46 <mansu> omniscientIdiot, yes
18:55:17 <wli> The way to understand them is to use them.
18:55:24 <wli> The way to use them is monad transformers.
18:55:29 <JFT> Tac-Tics: it might not be correct but one viewpoint that help me understand/visualise them was to look at monad like "collector" (in the sense of the Little Schemer)
18:55:45 <Tac-Tics> JFT: yeah, the state monad is a good one. I understand state in concept
18:55:57 <omniscientIdiot> it's an interesting idea, but it isn't supported.  You might have 'test = ltrim "  Suman"', load into ghci, then try 'test'.
18:55:58 <wli> Analogies are dangerous. Understanding them in their own right is best.
18:56:10 <JFT> wli: I agree but I had a hard time to use them before I grasp the root of them
18:56:28 <wli> Monad transformers are the way to go.
18:56:35 <JFT> Tac-Tics: Do you understand how/why the State monad work?
18:56:51 <mansu> omniscientIdiot, yeah am doing that... is there a reason why that is not supported.. i mean that
18:56:55 <JFT> wli: true but "better learn to walk before starting to run" ;)
18:57:08 <mansu> calling a function is not a side effect , so why is it an error?
18:57:24 <wli> That's not really how it works.
18:57:43 <mansu> omniscientIdiot, and why is it not an error in ghci?
18:57:51 <JFT> wli: What do you mean?
18:58:04 <wli> You barely learn to get by with one level. Then to exercise it, you use the next level up requiring it as a sub-step. In that sense it's more like math.
18:58:16 <omniscientIdiot> ghci acts like a do-block where all the file definitions are in scope
18:58:19 <Cale> mansu: what should ltrim "  Suman" mean?
18:58:26 <Cale> mansu: That's just an expression
18:58:46 <Cale> Do you mean to *print* the value of (ltrim "  Suman")?
18:58:56 <JFT> wli: true you need transformer for any "serious" use. But in my case I found it helpful to start with playing with only one level :)
18:59:06 <Tac-Tics> newtype State s r = State (s -> (r s))
18:59:06 <Tac-Tics> return x = State $ \s -> (x s)
18:59:06 <Tac-Tics> m >>= f = State $ \s -> let (r', s') = runState m s in runState (f r') s'
18:59:10 <Tac-Tics> something like that... right?
18:59:19 <omniscientIdiot> Cale: I suppose he wants something Pythonish, where it'd print all the toplevel expressions when loaded into the interpreter.
18:59:26 <Cale> Tac-Tics: You're missing some ,'s
18:59:30 <wli> JFT: Yes, you start there, but it's best to move on fast to monad transformers to drive the use of monads.
18:59:30 <Tac-Tics> probably not 100%, but certainly 90% with a good partial credit
18:59:42 <mansu> Cale, I was expecting it to print, but even if it did not print and just returned it would be fine... atleast that's what i intended...
18:59:58 <mansu> run the function on that string...
19:00:14 <Cale> mansu: The problem is how to define what order the things will print in, relative to the running of the rest of the program.
19:00:26 <Cale> mansu: Ordinarily, it just runs main.
19:00:43 <Cale> mansu: If you want to do things when the program starts, you just add them to main
19:01:21 <Cale> Declarations in a source file are largely unordered. (Of course, the cases of a particular function declaration are ordered, but that's different)
19:01:29 <JFT> wli: yes, talking of transformer I have a question... Is there performance issues to use them?
19:01:30 <ddarius> Tac-Tics: Write programs, implement classic examples.  There is no partial credit for software.
19:01:41 <JFT> wli: performance in term of speed or memory usage
19:01:48 <omniscientIdiot> Cale: I suppose it could be useful to have ghci run a test :: IO () definition when it loads or reloads a source file.
19:02:04 <Cale> omniscientIdiot: yeah, that could be decent
19:02:27 <Cale> One thing you can do is to define a bunch of quickcheck properties and prefix their names with prop_
19:02:31 <JFT> Tac-Tics: the robot exemple in Haskell School of Expression helped me groked state monad, you might want to give that book a spin
19:02:36 <wli> JFT: Yes, inlining etc. across module boundaries is often hampered because the MTL needs to be compiled with various "go faster" options to allow things to be unraveled as they usually are in a single module.
19:02:56 <Cale> Then the quickcheck script (which is hanging around somewhere), will run all the properties.
19:03:33 <wli> JFT: Debian and maybe others don't compile the MTL with such options.
19:03:36 <JFT> wli: do you have any pointer about these, as I'm starting to profile optimize a program that uses them, and I'd hate to have to thread the moand manually
19:03:48 <mansu> Cale, k cool... i kind of get it, so can i summarise that the only way to call a function is to call it from main?
19:04:03 <mansu> Cale, also is there a way to enforce eager evaluation of expressions in haskell?
19:04:05 <Cale> mansu: yeah, essentially, main is the only thing which runs in a compiled program
19:04:10 <Cale> and you build it up from other things
19:04:19 <omniscientIdiot> by convention, Main.main is the action run in a compiled program
19:04:28 <Cale> There's seq
19:04:43 <Cale> x `seq` y will ensure that x is evaluated before returning y
19:05:00 <mansu> Cale, cool!
19:05:04 <Cale> If x is some list type, say, it's similar to writing:
19:05:07 <bparkis> I'm looking for an algorithm so that given k-dimensional vectors a1, a2, ... an, and another set of k-dimensional vectors b1, b2, ..., bn, it computes for each b the corresponding a with the closest taxicab distance
19:05:09 <wli> JFT: No, I've only seen discussions on it in passing and have never personally cared about speed enough to do something about it.
19:05:12 <Cale> case x of [] -> y; _ -> y
19:05:18 <Cale> But it's more general
19:05:19 <ddarius> mansu: You shouldn't really want that (this is false, but when you can show that you don't need to take that advice anymore)
19:05:55 <Cale> mansu: In order to know where seq is needed, you really have to understand lazy evaluation well.
19:05:57 <JFT> wli: Thanks, I never cared too much until now, I kicked myself to work on this years ICFP contest for fun to force me into profiling/optimizing Haskells code :P
19:06:17 <Cale> (and it's only ever needed in very few situations)
19:06:22 <omniscientIdiot> if your program is hosted in something else, the main action could be different.  I think I remember some UI lib requiring a Main.main :: CustomLibMonad ()
19:06:55 <Cale> mansu: Are you aware of how lazy evaluation works?
19:07:03 <omniscientIdiot> (I think it was an Arrow, actually, UI () ())
19:07:12 <JFT> wli: mtl comes with GHC right? (I dont recall downloading and building it independantly...)
19:07:19 <Cale> If you want, I can give an explanation
19:08:02 <Tac-Tics> They call them "kind errors", but they aren't being very kind to me
19:08:21 <mansu> Cale, yes... I am , i am trying to write an interpreter for scheme and am thinking about it... so I have to evaluate the values of expressions as soon as i get to them... so was thinking about it...
19:08:38 <JFT> Tac-Tics: what is giving you kind errors?
19:08:39 <mansu> Cale, yeah I would love an explanation though :)
19:08:40 <bparkis> oh... and if it helps I guess I can assume that all of the vectors are at lattice points of a hypercube with bounded size
19:08:46 <Cale> mansu: Okay
19:08:55 * dino- turns on logging.
19:08:57 <bparkis> the sides of the hypercube are no more than 5 or 6 probably
19:09:01 <Cale> Strict evaluation is innermost (leftmost) first evaluation.
19:09:04 <Tac-Tics> As a self-test I'm coding up my state implementation I tried to recite above
19:09:25 <Cale> That is, to evaluate a function applied to some parameters, you evaluate the parameters first.
19:09:57 <Cale> To illustrate the different kinds of evaluation, I'll use a simple program:
19:10:03 <Cale> double x = x + x
19:10:13 <Cale> So under strict evaluation, we have:
19:10:19 <Cale> double (double 5)
19:10:19 <hpaste>  Tac-Tics annotated "(no title)" with "State with kind errors. Something silly most likely" at http://hpaste.org/2939#a1
19:10:24 <Cale> = double (5 + 5)
19:10:27 <Cale> = double 10
19:10:30 <Cale> = 10 + 10
19:10:31 <Cale> = 20
19:10:37 <Cale> That should be familiar :)
19:10:51 <Cale> So another thing we could do is evaluate expressions outermost first
19:10:52 <mansu> Cale, yes, that's the eager evaluation
19:11:02 <Cale> So we'd have:
19:11:06 <Cale> double (double 5)
19:11:11 <Cale> = double 5 + double 5
19:11:16 <JFT> Tac-Tics: what's the exact error message you are getting?
19:11:17 <Cale> = (5 + 5) + double 5
19:11:19 <Cale> = 10 + double 5
19:11:23 <Cale> = 10 + (5 + 5)
19:11:25 <Cale> = 10 + 10
19:11:26 <Cale> = 20
19:11:38 <fax> :S
19:11:42 <Cale> But as you can see there, some work is wasted: we compute double 5 twice!
19:11:49 <Tac-Tics> Expected kind `* -> *', but `State s' has kind `(* -> *) -> *' in the instance declr for "monad (state s)"
19:11:59 <Cale> So lazy evaluation avoids this
19:12:14 <mansu> Cale, isn't (double 5) + (double 5) = (5 + 5) + ( 5+5)?
19:12:16 <Saizan> Tac-Tics: you've missed a comma, newtype State s r = State (s -> (r,s))
19:12:55 <Tac-Tics> oops
19:12:55 <Cale> mansu: eventually, but that doesn't happen in one step in normal-order evaluation
19:13:02 <Tac-Tics> hehe, I justcopy and pasted my psuedohaskell
19:13:08 <Cale> However, this is what lazy evaluation is designed to fix
19:13:12 <Cale> by sharing the result of evaluating expressions when they come from duplicating a function parameter in the body
19:13:24 <Cale> So under lazy evaluation:
19:13:28 <Cale> double (double 5)
19:13:31 <dino-> Does the purity have an effect on this? As in, the compiler know that a pure function called with the same args must result in the same value, so it can beta reduce that.
19:13:34 <Cale> = let x = double 5 in x + x
19:13:40 <mansu> Cale, isn't that what memoization was supposed to fix?
19:13:41 <Cale> = let x = 5 + 5 in x + x
19:13:46 <Cale> = let x = 10 in x + x
19:13:50 <Cale> = 20
19:13:58 <Cale> and we're back down to the same number of steps
19:14:03 <Cale> this is sharing, not memoisation
19:14:07 <fax> Cale: :D
19:14:09 <Cale> there's a difference
19:14:11 <fax> thats cool
19:14:51 <mansu> Cale, hmm  that's a different version than what i read... lemme think a bit..
19:14:52 <Cale> With memoisation, you actually use up memory holding on to the results of some number of calls to a function, say in a table. That's not what's happening here.
19:15:21 <Cale> It's simply that the variables become pointers to the same result in memory, so that when one is evaluated, they all are.
19:15:57 <Tac-Tics> I wonder if there's a Memorize monad
19:16:06 <Cale> dino-: It has an effect because the sharing would make things really confusing in the presence of effects
19:16:33 <LoganCapaldo> memoize
19:16:37 <Tac-Tics> A monad which stores queries to functions in a mutable array for fast access
19:16:42 <wli> Hence call by copy-restore and similar for imperative bits.
19:17:03 <mansu> Cale, is my understanding wrong because I mis-understood call-by-name and call-by-need?
19:17:09 <dino-> ISTR reading something about laziness really kind requiring a side-effect-less environment.
19:17:15 <dino-> some months ago
19:17:33 <Cale> mansu: I always get the call-by-* names for the evaluation mechanisms mixed up
19:17:48 <Cale> Perhaps you were conflating normal-order and lazy evaluation
19:18:05 <Cale> Lazy evaluation is outermost first + sharing
19:18:12 <Cale> normal order is just outermost first
19:18:33 <Tac-Tics> Lazy evaluation is cool
19:18:37 <mansu> Cale, yeah i think so... outermost u mean outermost left?
19:18:42 <Cale> yes
19:18:59 <Cale> Though the leftmost doesn't really matter so much
19:18:59 <fax> but if you write an evaluator for a strict language, in a lazy language
19:19:22 <JFT> Lazy evaluation is very cool but it is more challenging to optimize in its presence.
19:19:25 <fax> The lazyness doesn't affect the evaluation order of your interpreter does it
19:19:35 <Cale> JFT: It is an optimisation in itself
19:20:03 <LoganCapaldo> But an optimization of what is the question :)
19:20:24 <JFT> Cale: I see what you mean but but it is not strictly true
19:20:35 <mansu> Cale, I didn't understand sharing... do you calculate the values of the redundant expressions in that scope ?
19:20:59 <JFT> Cale: I'm still learning when to force strictness to gain performance (performance in the larger sense of faster or to use less memory)
19:21:23 <Cale> mansu: Whenever you have a function parameter which occurs multiple times in the body, you pull it out so that when it is computed once, the result is shared between all the copies.
19:22:07 <dino-> JFT: I know what you mean. And noting places where stricness is used in the Prelude. Like length uses foldl'
19:22:24 <Cale> JFT: The general heuristic I use is that you want a little strictness whenever you're going from some "big" data structure, one with many separately evaluable components, down to a "small" data structure, one with few or just one evaluable component.
19:22:30 <dino-> foldl with ($!) application.
19:22:42 <Cale> For example, summing a list of Integers.
19:23:13 <Cale> In every other case, lazy evaluation is either equivalent, or better.
19:23:24 <JFT> Cale: True
19:23:49 <Cale> Note also that you have to include some recursive processes as virtually constructing big data structures.
19:23:58 <JFT> Cale: I'm working with very large dataset at the moment which is why I'm confronted to that issue.
19:24:03 <Cale> (even if they don't explicitly call a constructor)
19:24:20 <mansu> Cale, yeah got that ...
19:24:35 <Cale> Many problems can be solved just with a careful application of foldl'
19:24:40 <JFT> Cale: can you say more about that I"m not sure I understand what you mean "... recursive processes as virtually constructiong...."
19:24:40 <Cale> (note the prime)
19:24:57 <Cale> JFT: For example, tail recursive functions which accumulate a parameter
19:24:58 <JFT> cale: yes I know foldl'
19:25:09 <Cale> For instance,
19:25:10 <JFT> cale: is that what your sentence meant?
19:25:11 <wli> catamorphisms should be strict? ;)
19:25:58 <Cale> wli: No.
19:26:09 <Cale> wli: Only those which reduce large data structures to small ones.
19:26:20 <Cale> Which is not in general what catamorphisms do
19:26:38 <wli> Okay, "catamorphisms should have strict alternatives for cases where this stuff comes up"
19:26:43 <Cale> right
19:26:51 <JFT> which is what foldl' is :)
19:27:00 <Cale> and it's almost always a catamorphism where you want strictness
19:27:12 <Cale> Or something closely related anyway
19:27:14 <Cale> Consider f x 0 = x; f x n = f (n+x) (n-1)
19:27:31 <Cale> This is tail recursive, but lazy evaluation wastes space here
19:27:37 <Cale> (assuming numbers are strict)
19:28:02 <ddarius> catamorphisms are recursive, you want iterative alternatives as well and those should be strict
19:28:10 <wli> (ignore continued fractions momentarily)
19:28:40 <LoganCapaldo> I'm lazy on you, so lazy lazy on you
19:29:05 <JFT> I still have issue "guessing" which arguments a function is "strict in"
19:29:24 <Tac-Tics> @let f x 0 = x; f x n = f (n+x) (n-1)
19:29:28 <Tac-Tics> > f 4 4
19:29:30 <lambdabot> Defined.
19:29:32 <lambdabot>  14
19:29:44 <JFT> I'm referring to the bottom note in this page: http://www.haskell.org/haskellwiki/Stack_overflow
19:29:45 <lambdabot> Title: Stack overflow - HaskellWiki
19:29:52 <Cale> f 0 5 -> f (5+0) 4 -> f (4+(5+0)) 3 -> f (3+(4+(5+0))) 2 -> f (2+(3+(4+(5+0)))) 1 -> f (1+(2+(3+(4+(5+0))))) 0 -> (1+(2+(3+(4+(5+0))))) -> ... -> 15
19:30:43 <JFT> How to reason/guess that '+' is strict in the second argument? Any rule of thumb?
19:31:04 <dolio> What is 'n + undefined'?
19:31:07 <Cale> JFT: A function is strict in an argument if it has to pattern match in that argument before it can return a top-level constructor.
19:31:26 <wli> Saying (+), (*), et al are strict somehow would probably kill off a lot of this.
19:31:28 <JFT> dolio: my guess is that it would be undefined
19:31:33 <Philippa_> in general + doesn't have to be strict in its second argument
19:31:41 <Cale> In the case of Integers, you can treat every integer as a separate constructor
19:31:54 <ddarius> In general, + could be completely lazy in both arguments
19:31:59 <Cale> (it's not really the case, but it might as well be)
19:32:08 <JFT> Now I'm confused :P
19:32:27 <Philippa_> JFT: imagine data Integer = 0 | 1 | 2 | ...
19:32:29 <ddarius> JFT: You just have to know the strictness of "primitives", i.e. they have to be given.
19:32:35 <LoganCapaldo> I suspect + is a lousy example
19:32:38 <JFT> Is '+' forced to be strict in its second argument or not? And is it strict in its first?
19:32:40 <Cale> The reason why (+) could be lazy is due to the fact that you might define a completely different numeric type.
19:32:46 <Philippa_> for example:
19:32:50 <Philippa_> data Nat = Zero | Succ Nat
19:32:55 <JFT> ddarius: is there anywhere where they are given?
19:33:05 <ddarius> JFT: The Report should give most of them.
19:33:17 <Cale> But as a heuristic rule of thumb, most numeric types are completely strict.
19:33:23 <Philippa_> one obvious implementation would yield Succ Zero + _|_ => Succ _|_
19:33:38 <Cale> There are things like lazy naturals and, say, power series, where laziness works
19:33:41 <JFT> ddarius : Thanks I think I'm due to skim through the report :P
19:33:45 <wli> Continued fractions.
19:33:45 <Cale> But mostly things are strict.
19:34:08 <wli> There are lazy arithmetic operations on infinite continued fractions.
19:34:09 <JFT> Cale: Thanks it's starting to clear up
19:34:31 <ddarius> JFT: Not a bad idea, but you should be able to do some very basic strictness analysis in your head for functions over user-defined types.
19:34:55 <JFT> ddarius: any hind as to where to start(how to do stricness analysis?)
19:35:10 <goalieca> lambdabot passes the turing as well as a bureaucrat
19:35:14 <goalieca> turing test*
19:35:15 <Cale> JFT: Since you think of Integer as just having each of its values as a separate constructor, in order to return a constructor, (+) must pattern match both its arguments.
19:35:20 <JFT> I have "lazily" delayed my understanding of strictness/laziness until I needed it lol
19:35:48 <JFT> Cale: so '+' is strict in both of its argument
19:35:52 <Cale> yeah
19:36:16 <Cale> Pattern matching is actually what drives evaluation in Haskell.
19:36:21 <JFT> Cale: then '++' is strict in its first argument but not its second?
19:36:26 <Cale> yep
19:36:44 <Cale> > null (undefined ++ [5])
19:36:55 <lambdabot>  Undefined
19:36:56 <Cale> > null ([5] ++ undefined)
19:36:57 <lambdabot>  False
19:37:08 <JFT> Where does Lazy Pattern Matching stand against all that?
19:37:18 <JFT> I mean forcing it
19:37:25 <Tac-Tics> > length [1 `div` 0, 2 `div` 0, 3 `div` 0]
19:37:26 <lambdabot>  3
19:37:26 <wli> O, for when (++) was the method of MonadPlus
19:37:28 <Cale> Well, lazy pattern matching doesn't match at all until one of the variables matched is needed
19:37:35 <JFT> could it be used to force a lazy "+" for example?
19:37:42 <ddarius> Lazy pattern "matching" is a binding construct, not a matching one.
19:37:50 <Cale> That is, it simply assumes that the thing matches the pattern and moves forward immediately.
19:38:10 <JFT> what would happened if it didn't? Crash?
19:38:15 <JFT> I mean exception?
19:38:21 <Cale> Yeah, it throws an exception
19:38:26 <ddarius> > let Just x = Nothing in x
19:38:27 <Cale> But only once it needs the value
19:38:27 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just x
19:38:29 <LoganCapaldo>  > let ~(x,y) = undefined in x
19:38:42 <Cale> > let Just x = Nothing in 5
19:38:43 <lambdabot>  5
19:38:57 <Cale> (note that pattern bindings are lazy by default)
19:39:00 <ddarius> > let x@(Just y) in Nothing in x
19:39:01 <lambdabot>  Parse error
19:39:01 <JFT> ouch my head hurts now :P
19:39:02 <LoganCapaldo> you guys are better at doing examples than me
19:39:08 <ddarius> > let x@(Just y) = Nothing in x
19:39:09 <lambdabot>   Irrefutable pattern failed for pattern (x@(Data.Maybe.Just y))
19:39:14 <JFT> I'm going to have to sift that down...
19:39:19 <Cale> > let f ~(Just x) = 5 in f Nothing
19:39:20 <lambdabot>  5
19:39:27 <Cale> ^^ look at that one
19:39:32 <Cale> > let f ~(Just x) = x in f Nothing
19:39:34 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
19:39:37 <Cale> and then that one
19:39:55 <ddarius> > let f (Just x) = 5 in f Nothing
19:39:56 <lambdabot>   Non-exhaustive patterns in function f
19:40:33 <JFT> interesting....
19:40:43 <JFT> Good example I think it drove the point home!
19:40:47 <JFT> Thank you guys!
19:40:52 <Cale> No problem :)
19:40:54 <ddarius> > let f (Just x) = 5; f Nothing = 3 in f Nothing
19:40:56 <lambdabot>  3
19:41:09 <ddarius> > let f ~(Just x) = 5; f ~Nothing = 3 in f Nothing
19:41:09 <Cale> > let f ~(Just x) = 5; f Nothing = 3 in f Nothing
19:41:10 <lambdabot>      Warning: Pattern match(es) are overlapped
19:41:10 <lambdabot>              In the definition...
19:41:10 <lambdabot>      Warning: Pattern match(es) are overlapped
19:41:11 <lambdabot>              In the definition...
19:41:16 <Cale> oh, it's too smart
19:41:19 <ddarius> Indeed.
19:41:20 <Cale> hehe
19:41:27 <omniscientIdiot> ~(...) is effectively _
19:41:36 <Cale> anyway, if it weren't for the warning, that would give 5
19:41:45 <omniscientIdiot> (from a matching standpoint)
19:41:58 <JFT> isn't there a flag for that?
19:42:04 <JFT> I mean to allow that to pass?
19:42:22 <omniscientIdiot> don't see why you would want to
19:42:30 <ddarius> It does pass, that was just a warning.
19:42:34 <omniscientIdiot> the second case is guaranteed to *never* occur.
19:42:39 <ddarius> lambdabot just didn't get to the output.
19:43:07 <LoganCapaldo> @bot
19:43:07 <lambdabot> :)
19:43:18 <dolio> > let f ~(Just x) = 5 in f Nothing
19:43:20 <lambdabot>  5
19:43:34 <Pseudonym> Does anyone know what cases the pattern matching compiler gets wrong?
19:43:52 <LoganCapaldo> > let f ~Nothing = 5 in Just 2
19:43:53 <ddarius> Pseudonym: I'm sure one of the Simons knows and Trac probably does too.
19:43:54 <lambdabot>  Just 2
19:44:00 <LoganCapaldo> > let f ~Nothing = 5 in f (Just 2)
19:44:01 <omniscientIdiot> "gets wrong"?
19:44:01 <lambdabot>  5
19:44:11 <Pseudonym> Yeah, I was just curious if anyone here knew to save me looking it up. :-)
19:44:13 <ddarius> ndm probably knows as well.
19:44:32 <LoganCapaldo> Say it aint so
19:44:43 <LoganCapaldo> there can't be bugs in ghc or haskell
19:44:51 <Pseudonym> LoganCapaldo: They're just spurious warnings.
19:44:59 <Pseudonym> It doesn't generate wrong code or anything.
19:45:06 <JFT> Good Night all and thanks for the insights :)
19:45:11 <SamB_XP> LoganCapaldo: the impossible happened!
19:46:39 <fax> hm :|
19:47:19 <Cale> http://www.suturesound.com/stwpt/tracks/0145_he_will_state_the_obvious_(captain_obvious_theme_song).mp3
19:47:21 <lambdabot> http://tinyurl.com/3crsl3
19:47:50 <ddarius> LoganCapaldo: There aren't bugs in Haskell.
19:48:10 <LoganCapaldo> are you sure?
19:48:23 <ddarius> Yes.
19:48:35 <Pseudonym> There are.
19:48:42 <Pseudonym> The associativity of ($) is a bug.
19:48:56 <Cale> :)
19:49:04 <Cale> fail is a bug :)
19:50:14 <jcreigh> map isn't fmap
19:50:34 <Cale> yep
19:50:35 <Pseudonym> That's not a bug, it's code rot.
19:50:58 <Cale> Pseudonym: I'd say it's a bug due to it explicitly being created.
19:51:05 <Cale> 1.4 had the right idea there
19:51:31 <jcreigh> it's all part of lists having this kind of god-like status in H98.
19:51:34 <Cale> (on both accounts of fail and map)
19:52:01 <Cale> jcreigh: Well, they kind of deserve god-like status, but maybe not quite the god-like status we give them.
19:52:06 <Tac-Tics> They say a function is strict if f _|_ = _|_, but what if f x = const _|_?
19:52:36 <Cale> Tac-Tics: you mean f = const _|_ ?
19:52:43 <Tac-Tics> er yes
19:53:12 <Cale> I suppose that's technically strict.
19:53:21 <omniscientIdiot> f _|_ = _|_, but so does everything else, so it's not a very useful function :)
19:53:34 <Cale> Even though it doesn't actually require the evaluation of its parameter
19:53:45 <Pseudonym> H98 doesn't have god-like status.  It's just that it's an improvement on the moving target that came before it.
19:54:12 <Cale> Pseudonym: They weren't talking about H98 having god-like status, they were talking about lists having god-like status *in* H98.
19:54:19 <Pseudonym> Ah, right.
19:54:21 <Pseudonym> Sorry, yes.
19:54:38 <Cale> Pseudonym: Also, there are many ways in which H98 was not an improvement over 1.4
19:54:42 <Cale> which is very irritating
19:55:01 <Pseudonym> I maintain that the primary purpose of H98 was to keep a non-moving target.
19:55:03 <Cale> In fact, I highly recommend people read the 1.4 report
19:55:10 <ddarius> const undefined /= undefined
19:55:22 <pjd> Cale: why didn't people object?
19:55:22 <Pseudonym> And to come up with a standard that you could write textbooks for and teach to first years.
19:55:33 <Tac-Tics> Cale, link to 1.4?
19:55:40 <Pseudonym> I personally think that Haskell-prime is, in retrospect, a mistake.
19:55:44 <Cale> pjd: I don't know. There was some objection...
19:55:45 <Pseudonym> We should be working on Haskell08.
19:55:55 <Tac-Tics> why do you say that Pseudonym?
19:55:57 <Cale> We should be working on Haskell 2
19:56:07 <Cale> and not care about backward compatibility so much :)
19:56:10 <pjd> Haskell 2.0!
19:56:10 <Pseudonym> First off, because Haskell-prime hasn't actually come up with any documents yet.
19:56:12 <pjd> beta
19:56:30 <LoganCapaldo> now with more rouunded corners
19:56:35 <Cale> Tac-Tics: One sec, I'll find it
19:56:37 <Pseudonym> I say "in retrospect", because I think that this is only clear from the Haskell-prime discussion.
19:56:40 <Tac-Tics> thanks~
19:56:57 <Cale> http://haskell.org/haskellwiki/Language_and_library_specification#Historic_development_of_Haskell
19:56:59 <lambdabot> Title: Language and library specification - HaskellWiki, http://tinyurl.com/3ymrzn
19:57:00 <Pseudonym> Haskell-prime could have been standardised pretty quickly.
19:57:06 <Cale> there are links from there to all the old reports
19:57:08 <Pseudonym> Just decide on what glasgow-exts made sense.
19:57:30 <Pseudonym> But it became pretty clear pretty quickly that people were actually just plain not happy with H98.
19:57:39 <Tac-Tics> is there a summary of the diff between 1.4 and 98?
19:58:02 <Cale> No, but the things I'd look at first are the translation of do-notation, and the Prelude.
19:58:09 <SamB_XP> it went downhill from the monomorphism restriction, iirc...
19:58:19 <Pseudonym> Tac-Tics: http://andrew.bromage.org/darcs/diff/  -- Produce your own summary!
19:58:21 <lambdabot> Title: Index of /darcs/diff
19:58:30 <Tac-Tics> hah
19:58:33 <dons> Pseudonym: when are you going to upload your stuff to hackage? :)
19:58:44 <Pseudonym> dons: When I have something worth uploading.
19:58:54 <dons> we even have mkcabal to bundle it , if you worry about .cabal files
19:58:59 <SamB_XP> Pseudonym: maybe you should have suggested GNU diff
19:59:04 <Pseudonym> Honestly, what's the point in uploading a proof of concept that you can write diff in half an hour.
19:59:24 <Cale> Pseudonym: otoh, that sounds like a blog entry
19:59:56 <SamB_XP> Cale: you're saying he should upload it padded with prose?
20:00:05 <Cale> SamB_XP: essentially :)
20:00:11 <shapr> dons: Has anyone attempted hs-plugins via ghc-api?
20:00:38 * dnm looks for cheap prices on Graham's book.
20:00:38 <Pseudonym> Of all that code, I think this is the msot elegant:
20:00:41 <Pseudonym> newtype Line = Line Int
20:00:41 <Pseudonym>     deriving (Eq, Ord, Num, Enum, Ix)
20:00:49 <Pseudonym> That sums up so much.
20:01:27 <SamB_XP> shapr: I believe it's going to use interfaces that are going to be provided by GHC...
20:01:33 <dnm> shapr!
20:01:41 <dnm> LTNS!
20:01:54 <shapr> y0 dnm, wassup?
20:02:13 <SamB_XP> I believe the hope is that this will make it more resiliant WRT GHC releases
20:02:24 <Tac-Tics> They flip flopped on List vs. Monad comprehensions
20:02:28 <Tac-Tics> Why did they do that?
20:02:35 <shapr> Ah, so it wouldn't be useful to implement a new hs-plugins version using the current ghc-api?
20:02:44 <dnm> shapr: Not much. What's new with you. Saw you getting props on HWN for bulking #haskell up to 400+ people!
20:02:55 <Cale> Tac-Tics: Apparently because monad comprehensions were confusing to beginners
20:03:02 <Tac-Tics> was that it?
20:03:02 <dnm> <crotchety> I remember when this channel was barely a dozen! </crochety>
20:03:08 <Cale> Tac-Tics: yep
20:03:16 <Cale> At one point I remember reading the whole H98 mailing list archive
20:03:16 <Tac-Tics> forall a. monad a is confusing to beginners
20:03:20 <SamB_XP> dnm: inconcievable!
20:03:20 <Tac-Tics> X-(
20:03:20 <Cale> I wonder if it's still online.
20:03:28 <shapr> dnm: dons does most of the advocacy the last year or so, my life has been busy since I moved back from Sweden.
20:03:52 <pjd> as if the rest of Haskell *isn't* confusing to beginners? :)
20:03:53 <shapr> dnm: But I do talk sometimes :-)
20:04:02 <SamB_XP> dons even moved to the US to increase his advocational ability
20:04:05 <shapr> dnm: I have a fulltime Haskell job, that's nice.
20:04:05 <dnm> You're back from Sweden?
20:04:09 <dnm> I'm so out of date?
20:04:11 <dnm> Oh awesome!
20:04:15 <dnm> Can I ask with whom?
20:04:20 <shapr> dnm: Yeah, been back a year now.
20:04:25 <dnm> s/date?/date!/
20:04:25 <SamB_XP> actually he moved here to work with galois ;-P
20:04:26 <dnm> Wild.
20:04:35 <SamB_XP> dons,  I mean
20:04:45 <shapr> I got back september 3rd 2006
20:04:55 <shapr> I'm working for HAppS LLC.
20:05:17 <shapr> dnm: What are you doing these days?
20:05:20 <sorear> dnm: Hello!
20:05:41 <dnm> sorear: Hi?
20:06:04 <shapr> I'm thinking about changing domain names since I'm not moving back to Sweden... but I can't think of anything interesting.
20:06:15 <dnm> sorear: Hrm... #interhack...
20:06:21 <dnm> You know Mat Curtin I take it?
20:06:25 <dnm> s/Mat/Matt/
20:06:28 <ddarius> dnm: Wow, you are an oldtimer.  When I first started #haskell had something in the 30s.
20:06:46 <sorear> dnm: Matt Curtin?
20:06:53 <dnm> ddarius: I'm not a regular though.
20:07:06 <ddarius> dnm: I'm an irregular regular.
20:07:23 <dnm> sorear: Trying to think if I know you from some place. Saw you were in #interhack, wondered if it was related to the Interhack I know.
20:07:44 <dnm> shapr: I'm actually job hunting right now.
20:07:59 <dnm> Just left a small security company a few weeks back.
20:08:00 <shapr> dnm: Weren't you doing EFF for awhile?
20:08:06 <dnm> Yeah, back in 2003-2004.
20:08:11 <shapr> That sounded like a cool job.
20:08:37 <dnm> It was neat.
20:08:38 <sorear> dnm: I don't think I know you from anywhere.  Although I might... you never know
20:08:45 <bos> dnm: where are you based out of now?
20:08:54 <Eidolos> dnm: the Interhack he's in is a NetHack cheating layer :)
20:08:56 <dnm> sorear: Heh, entirely possible. It sounded like you might, wasn't sure.
20:08:57 <sorear> dnm: I'm just a #haskell regular, intermittently the most active human
20:09:03 <shapr> Has anyone written a simple RTS-style simulator in Haskell?
20:09:12 <sorear> dnm: but I've only been here for a year
20:09:25 <sorear> shapr: RTS?
20:09:35 <shapr> real-time strategy
20:09:35 <dnm> bos: D.C./Northern VA. Though I'm currently maintaining an apt. in San Francisco also.
20:09:36 <sorear> shapr: you mean like GranSim?  Frag?
20:09:41 <sorear> oh
20:10:11 <ddarius> dnm: Northern VA is where I'm from and had spent most of my life.
20:10:15 <bos> dnm: i'm in san francisco
20:10:26 <dnm> bos: Awesome.
20:10:41 <dnm> I'm sort of trying to figure out where to be at the moment.
20:10:47 <dnm> Depends a lot on work.
20:10:50 <bos> sf ftw
20:10:58 <ddarius> dnm: If you don't mind me asking, where are you currently (more specifically)?
20:11:02 <dnm> bos: Are you in SF proper, or outside SF?
20:11:07 <bos> dnm: in the mission
20:11:13 <dnm> ddarius: Arlington. Clarendon, more precisely.
20:11:22 <shapr> I'd like to move to SF... or Portland.
20:11:24 <dnm> bos: Ah, my SF apt. is in the Inner Richmond.
20:11:36 <bos> shapr: join us!
20:11:41 <shapr> I bet Portland is cheaper rent-wise.
20:11:49 <shapr> bos: Would be nice to start another Haskell enclave.
20:11:51 <dnm> I hear Portland is more depressing.
20:11:56 <bos> shachaf: +1
20:11:57 <dnm> But I haven't been.
20:12:00 <bos> portland is really nice.
20:12:02 * ddarius has "Come Join Us" by Bad Religion pops into his head.
20:12:12 <bos> er, shapr +1
20:12:14 <shapr> I've been itching to setup a real-life #haskell equivalent.
20:12:34 <dnm> I heard from a friend that there's a Bay Area FP meetup now.
20:12:37 <shapr> Sort of like the l0pht or something.
20:12:39 <dnm> Right after I'm not regularly there!
20:12:40 <bos> shapr: we had about 30 people at the local FP inaugural meeting last week
20:12:41 * dnm cries.
20:12:44 <shapr> bos: wow!
20:12:44 <Pseudonym> http://www.flickr.com/photo_zoom.gne?id=1435963911 -- Serious unicycle
20:12:47 <lambdabot> Title: Flickr Photo Download: unicycle
20:12:55 <Nafai> bos: Awesome!
20:12:58 <dnm> Pseudonym: Does it have rims?
20:13:04 <shapr> Pseudonym: Does it actually work?
20:13:08 <dnm> Pseudonym: Is it rollin on a dub?
20:13:08 <Pseudonym> No clue.
20:13:16 <bos> evenly divided between haskell, erlang, and ocaml users
20:13:18 <shapr> Pseudonym: I've been thinking about a design like that using inductrack.
20:13:27 <Tac-Tics> > "\&"
20:13:27 <lambdabot>  ""
20:13:42 <Tac-Tics> interesting
20:14:04 <shapr> Pseudonym: I think it does work, from looking at it.
20:15:35 <dnm> There's a kind of FP group here.
20:15:42 <dnm> Not specific to FP, but pretty much FP people.
20:15:45 <dnm> "FringeDC"
20:15:49 <bos> dnm: yeah, the NSA :-)
20:15:49 <shapr> dnm: I'm in Birmingham, Alabama... the FP group here is ...
20:15:55 <shapr> living in my apartment
20:16:05 <dnm> shapr: Why there?
20:16:09 <shapr> My hometown.
20:16:13 <SamB_XP> who else is involved, or is it just you?
20:16:14 <dnm> I thought so.
20:16:33 <shapr> SamB_XP: It's just me.
20:16:43 <Nafai> shapr: Hey, me too! :)
20:16:45 <dnm> bos: Are you working with Haskell full time?
20:16:51 <dnm> In SF?
20:16:52 <shapr> Nafai: What? You're from b'ham originally?
20:16:52 <bos> dnm: only part time
20:17:00 <Nafai> shapr: No, I'm my own FP group
20:17:03 <SamB_XP> just making sure you didn't start some kind of functional orphans home or something ;-P
20:17:03 <shapr> oh!
20:17:06 * shapr laughs
20:17:16 <Tac-Tics> > '\&'
20:17:17 <lambdabot>  Illegal escape sequence
20:17:42 <ddarius> Crap, I randomly put the wrong city on my 29B.
20:18:20 <bos> dnm: what kind of work are you looking for?
20:18:20 <dnm> bos: Can I ask where you're working?
20:18:25 <dnm> Heh.
20:18:25 <bos> dnm: linden lab
20:18:29 <dnm> Oh neat.
20:18:39 <dnm> I knew a lot of people who worked at There, once.
20:18:54 <bos> yeah
20:18:56 <omniscientIdiot> > "\35\&1" -- it looks like it's for terminating numeric escapes followed by numeric chars
20:18:57 <lambdabot>  "#1"
20:18:59 <Cale> ddarius: is that some kind of tax form?
20:19:22 <ddarius> Cale: No.  It's no big deal, I'll change it tomorrow.  It's a ridiculous form. (Stupid AETC...)
20:20:01 <bos> ddarius: you're in the military?
20:20:03 <omniscientIdiot> > "\351"
20:20:05 <lambdabot>  "\351"
20:20:38 <ddarius> bos: Yes.
20:20:50 <bos> which branch?
20:20:53 <ddarius> USAF
20:21:45 <dnm> bos: I'm kind of open to ideas if they involve FP.
20:22:35 <dnm> My only concern is that I haven't done FP or really any programming professionally.
20:22:38 <dnm> Mostly by design.
20:22:53 <dnm> I have tended to keep it strictly avocational.
20:22:56 <sorear> omniscientIdiot: look at the report
20:23:01 <dnm> For a variety of reasons.
20:23:08 <sorear> omniscientIdiot: \&'s purpose is clearly specified
20:23:12 <omniscientIdiot> sorear: way ahead of you
20:23:15 <omniscientIdiot> http://www.haskell.org/onlinereport/lexemes.html#sect2.6
20:23:16 <lambdabot> Title: Haskell 98 Lexical Structure
20:24:12 <Sgeo> Bye all!
20:24:36 <jedahu> @where shim
20:24:37 <lambdabot> http://shim.haskellco.de/trac/
20:25:52 * bos sets to retooling the comment system for the book
20:26:40 <jedahu> http://shim.haskellco.de/trac/ returns a 500, is shim mirrored anywhere?
20:26:44 <ddarius> bos: What are you going to do when the first chapters are completely public?
20:26:51 <dnm> There's a local company I'm interested in that uses ML, but I'm not sure they have any openings right now.
20:26:58 <bos> ddarius: hide in a cave!
20:27:16 <bos> ddarius: the response so far has been pretty overwhelming
20:27:27 <dnm> And there's another guy locally who has some Haskell projects he's thinking about launching as maybe-sorta start-uppy kind of things, and I may see if I can help him out, but there's no full-time work in the latter at the moment.
20:27:29 <bos> and that's just with a relative handful of reviewers
20:28:20 <dnm> bos: Do you do any FP for LL?
20:28:35 <bos> dnm: only a wee bit
20:28:52 <dnm> I confess I know nothing about Second Life.
20:29:03 <bos> the hacker contingent within the company is divided between erlang people and me, the haskell camp
20:29:20 <dnm> I didn't know there were Erlang people there!
20:29:24 <dnm> Interesting!
20:29:24 <Cale> Heh, a version of SL with a declarative scripting language would be awesome.
20:29:35 <dnm> Isn't there LindenScript or something?
20:29:38 <dnm> I though I heard about it once.
20:30:02 <dnm> s/though/thought/
20:30:55 <Cale> Yeah, it's pretty imperative
20:31:20 <bos> Cale: we're replacing the current shitty homemade script interpreter with mono
20:31:31 <bos> Cale: so F# or the like ought to become a possibility at some point
20:31:38 <dnm> F#!
20:31:39 <dnm> Yay!
20:31:58 <dnm> bos: Is LL hiring for anything in particular?
20:32:14 <bos> dnm: various random things, depending on the phase of the moon
20:32:26 <dnm> Heh.
20:33:24 <bos> we keep the jobs page up to date
20:33:44 <dnm> Do they have an in house security team?
20:33:49 <dnm> I imagine they do.
20:34:11 <bos> sort of.
20:36:36 <bos> jesus. django's ORM is a steaming pile of the sort of thing that piles steamingly.
20:36:50 <omniscientIdiot> ramen?
20:37:02 <bos> it curls around like ramen sometimes.
20:37:05 <dnm> I think that's a property of ORMs generally.
20:37:21 <bos> i should have bitten the bullet and used happs for this.
20:37:29 <bos> then i could beat shapr up.
20:38:03 <dnm> Aforementioned local Haskell hacker is using HAppS. I've been meaning to on some projects with newsham, but haven't dived in.
20:38:53 <bos> django is performing 600 queries where it could be performing 1.
20:39:20 <bos> this leads to something of a slowdown.
20:39:48 * bos clutches his head like a stunned monkey.
20:40:24 * dnm carefully witdraws the dart gun from the bushes.
20:40:25 <Korollary> That is very eager evaluation
20:40:31 <dnm> s/witdraws/withdraws
20:40:39 * dnm rimshot
20:43:32 <dnm> bos: I think you may have met my friend who showed up to that FP meeting.
20:43:43 <bos> dnm: could be. who was it?
20:43:46 <dnm> Marshall.
20:43:50 <bos> oh, yea
20:43:52 <bos> h
20:46:27 <Tac-Tics> @src until
20:46:27 <lambdabot> until p f x | p x       = x
20:46:27 <lambdabot>             | otherwise = until p f (f x)
20:47:53 <omniscientIdiot> > until (< 10) (/ 2) 2983
20:47:54 <lambdabot>  5.826171875
20:48:21 <Mr_Awesome> is there a way to compile haskell executables that dont require gmp?
20:48:29 <Mr_Awesome> with ghc
20:48:33 <dmwit> > last . takeWhile (> 0) . iterate (/ 2) $ 1
20:48:34 <lambdabot>  5.0e-324
20:50:09 <dmwit> Mr_Awesome: Do you also require that gmp not be linked into the compiled executable in any way?
20:52:54 <dmwit> > map (fromEnum . odd) . takeWhile (> 0) . iterate (`div` 2) $ 2983
20:52:55 <lambdabot>  [1,1,1,0,0,1,0,1,1,1,0,1]
20:53:08 <Mr_Awesome> dmwit: preferably, but not necessarily
20:53:45 <dmwit> Mr_Awesome: I'm trying to imagine a scenario where not using a library would cause compilation to fail.  What's the actual problem you're having?
20:54:18 <P_D> If the runtime doesn't use Integer internally, you should get away with a library of stubs
20:56:51 <Mr_Awesome> dmwit: the problem im having is that i dont want gmp to be a requirement for executables when i distribute them
20:57:19 <dmwit> aha
20:57:21 <P_D> Frequently you see people provide both dynamic and statically linked binaries.
20:57:51 <P_D> dynamically and statically to avoid busting up the parallel
20:58:27 <dmwit> Mmmm, well-written English.
20:59:27 <bos> Mr_Awesome: that's next to impossible. gmp is wired deeply into the runtime.
21:02:02 <Mr_Awesome> bos: i see
21:38:20 <bos> hi andyjgill
21:38:29 <andyjgill> hi bos
21:48:49 <ari> @pl \x y -> x ++ "\n" ++ y
21:48:50 <lambdabot> (. ('\n' :)) . (++)
21:50:32 <exDM69> what's @pl ?
21:50:45 <omniscientIdiot> @help pl
21:50:45 <lambdabot> pointless <expr>. Play with pointfree code.
21:51:01 <exDM69> ok
21:51:01 <omniscientIdiot> @pl \x -> x + 1
21:51:01 <lambdabot> (1 +)
21:51:32 <johnnowak> @pl \x -> x * x
21:51:32 <lambdabot> join (*)
21:51:33 <exDM69> I read about point-free code, what does it exactly mean?
21:51:59 <johnnowak> @pl \x y -> x
21:51:59 <lambdabot> const
21:52:08 <ari> @wiki Pointfree
21:52:08 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
21:52:25 <omniscientIdiot> no explicit lambdas, at a first approximation
21:52:52 <omniscientIdiot> @go the point of point free
21:52:55 <lambdabot> http://rickyclarkson.blogspot.com/2007/09/point-free-programming-in-java-7-beyond.html
21:52:55 <lambdabot> Title: Ricky's technical blog: Point-free Programming in Java 7 - Beyond Closures
21:53:30 <ari> @go "the point of pointfree"
21:53:32 <lambdabot> http://www.vex.net/~trebla/weblog/pointfree.html
21:53:32 <lambdabot> Title: The Point of Pointfree
21:54:38 <omniscientIdiot> google--
21:54:50 <ari> I don't quite agree with that site, considering that naming a function argument tends to involve less cleanup work than creating a temporary file
21:55:38 <johnnowak> omniscientIdiot: You may want to look at Joy, which is a functional language and also entirely point-free.
21:55:50 <shapr> bos: Hey, I'm large, muscular, and I can run really fast!
21:56:37 <bos> shapr: me too! :-)
21:56:48 <bos> functional fight club!
21:57:33 <omniscientIdiot> ooh! ooh!  Can I slowly descend into destructive insanity?!
21:58:11 * kaol is already there
21:59:27 <shapr> bos: First rule of karate... run with confidence.
22:25:36 <vagif> Hello, anyone using HaskellNet library ? I'm intrested in its SMTP module
22:28:41 <Cale> hmm, I wonder why it's not on hackage
22:32:19 <Cale> vagif: I haven't used the module, but apparently the SoC project was successful.
22:32:55 <vagif> doSMTP "127.0.0.1" $ sendMail "vagif" ["vagif@blabla.com"] (pack "test haskell email")
22:32:59 <vagif> This hangs
22:33:06 <vagif> but it connects to smtp server
22:33:11 <vagif> and habgs
22:33:50 <dmwit> What if you use ["vagif"] instead?
22:34:06 <vagif> no, it requires string there
22:34:07 <dmwit> (or ["vagif@localhost"] if you're feeling expansive)
22:34:35 <dmwit> vagif: I meant, try using that in place of ["vagif@blabla.com"].
22:35:04 <vagif> that's the reciever address
22:35:18 <vagif> it should be any valid email address
22:35:32 <dmwit> Right.  I'm asking you to try your local delivery, rather than testing immediately on true Internet addresses.
22:35:59 <Korollary> blabla.com goes to ebay.com
22:36:18 <vagif> i replaced my email address with blabla in this snippet :)
22:36:44 <Korollary> I guessed so. But, this is interesting.
22:37:04 <vagif> i see. I do not think it is a problem, because when i close smtp server, haskell program ends with error:
22:38:15 <vagif> *** Exception: <socket: 1880>: Data.ByteString.hGetLine: end of file
22:38:48 <vagif> and if i run haskell program without smtp server running it gives error that it cannot connect
22:39:09 <vagif> so obviously it connects fine, but then cannot finish email transmit
22:39:36 <vagif> so i hoped someone used smtp module and have working example
22:39:37 <eck> can someone help me define this function correctly... i'm trying to compute (a * (log b)) where a, b :: Int and I want to get a double
22:39:50 <dmwit> :t fromInteger
22:39:52 <lambdabot> forall a. (Num a) => Integer -> a
22:40:06 <Cale> fromIntegral a * log (fromIntegral b)
22:40:10 <Cale> :t fromIntegral
22:40:13 <dmwit> ?hoogle Int -> a
22:40:13 <eck> thanks
22:40:13 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
22:40:13 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
22:40:13 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
22:40:13 <lambdabot> forall a b. (Num b, Integral a) => a -> b
22:41:25 <Cale> :t fromIntegral ?a * log (fromIntegral ?b)
22:41:27 <lambdabot> forall b. (?a::Integer, ?b::Integer, Floating b) => b
22:41:33 <Cale> heh
22:41:42 <Cale> defaulting :)
22:49:58 <Soliah> :t Nothing
22:50:06 <lambdabot> forall a. Maybe a
22:58:48 <araujo> mm..
22:59:06 <araujo> what is a good antonym for 'regular expression' ?
22:59:22 <dmwit> nonregular?
22:59:51 <Pseudonym> There's no antonym, just different kinds of expression.
22:59:58 <dmwit> You could also classify the other thing as what it is, i.e. a context-free grammar or so.
23:00:13 <Pseudonym> Besides, the complement of a regular expression is regular!
23:00:25 <dmwit> But!
23:00:36 <dmwit> > "antonym" == "complement"
23:00:42 <dmwit> ;-)
23:00:44 <lambdabot>  False
23:01:36 <araujo> mmm...
23:02:23 <olsner> "irregular expression" is a nice term for the kinds of regular expressions supported by e.g. Perl, with back-references etc ... but that's still not an antonym, just a different kind of expression
23:02:46 <Pseudonym> However, the fact is, if it's not regular, chances are it's not an expression either.
23:03:10 <Pseudonym> And areyou talking about the expression or the underlying language?
23:03:17 <dmwit> bingo
23:03:44 <Korollary> co-language of all regular languages?
23:03:46 <Pseudonym> Of course you can extend regular expression syntax to any computable language.
23:04:03 <Pseudonym> Given suitable additional algebra.
23:07:36 <olsner> Korollary: is that the set of all regular expressions?
23:08:37 <Korollary> olsner, no. The set of all strings that can't be matched with a regexp.
23:08:51 <wnoise> So, the null set?
23:09:04 <wnoise> (You need a set of sets approach.)
23:09:04 <dmwit> No, the set of all *languages* that can't be matched with a regexp.
23:09:20 <wnoise> Right.
23:09:47 <Pseudonym> I think that the binary expansion of the Busy Beaver number can't be matched with a regular expression.
23:10:03 <Pseudonym> You were allowing infinite-length strings, right?
23:10:11 <dmwit> sure
23:10:15 <wnoise> "the" Busy Beaver number?  It's parameterized by both number and UTM.
23:10:29 <dmwit> But it's easier than that: the language of prime-length strings can't be matched with a regular expression.
23:10:34 <dmwit> (for example)
23:10:55 <Pseudonym> Well, as previously noted, it can if you allow extra algebra.
23:10:57 <dmwit> You may be thinking of the set of languages that can't be matched by a Turing machine, which is a strict subset.
23:11:50 <olsner> "a language is defined as a possibly infinite set of finite-length sequences of elements drawn from a specified finite set" - I think this definition excludes languages of languages
23:12:05 <Pseudonym> A push-down automaton is just a DFA with a stack.  If you encode the stack into non-alphabet symbols that obey some reasonable algebra, you can encode then in regular expressions.
23:12:39 <Pseudonym> And a TM is the same with two stacks.
23:27:04 <olsner> Pseudonym: but the expression would stop being regular
23:28:01 <Pseudonym> Of course, POSIX or Perl regular expressions aren't regular either.
23:31:35 <flux> and infact with such regular expression you can match strings of prime length
23:31:53 <Pseudonym> Not POSIX.
23:31:55 <Pseudonym> Perl, yes.
23:32:31 <flux> hm, posix doesn't support backtracking within the expression?
23:33:03 <Pseudonym> No.
23:33:17 <Pseudonym> The main thing it supports which isn't regular is ^ and $.
23:35:20 <olsner> which ^ is that? if you mean [^abcd] then that's actually regular (just a shorter way of naming 252 symbols)
23:35:45 <olsner> oh, start and end of string... stupid me ;-)
23:36:45 <jbauman> well, you could have special end-of-string and start-of-string symbols
23:36:51 <jbauman> so ^ and $ would be regular
23:37:38 <olsner> or just preprocess regular expressions without start/end markers into .*(re).*, .*(re) or (re).* then match against the whole string
23:38:09 <Pseudonym> Well, the way that automaton-based regular expression engines usually do it is to have special start states and end states.
23:38:28 <Pseudonym> So you have a NFA with two start states: One if it's the start of a line, one if it's not.
23:38:31 <Pseudonym> And similarly for end states.
23:39:31 <Pseudonym> But if you want a real challenge, work out how to implement the lex slash operator.
23:39:42 <Pseudonym> And if you want a serious brain-bending challenge, try to understand the source code of flex.
23:40:49 <olsner> And for a seriously brain-damaging challenge, try to edit a text file in emacs.
23:41:02 <Korollary> low blow
23:41:21 <shapr> I can edit files in both vim and emacs!
23:41:26 <fax> emacs is a good text editor
23:41:33 <olsner> "But not as low as Glocalnet"
23:41:34 <fax> You do have to learn how to use it though
23:41:46 <Pseudonym> No, emacs is a good shell with a terrible text editor built into it.
23:42:20 <olsner> ... but in my experience it's not even a good shell
23:46:18 <platypus> Its a run time enviroment.
