01:05:13 <kuribas> Why does haddock give me the error: "Warning: cannot use package HaXml-1.13.2: HTML directory /usr/local/share/HaXml-1.13.2/doc/html does not exist?"
01:05:22 <kuribas> Doesn't it create the directories?
01:05:47 <sorear> kuribas: uh...
01:06:09 <sorear> kuribas: if it starts with "Warning: " it's not an error.
01:06:21 <sorear> it's a warning.
01:06:48 <kuribas> So it builds the docs?
01:07:07 <sorear> Yeah.  Just not as fully linked as it could be.
01:07:23 <kuribas> Oh, I see, thanks.
01:12:45 <tehgeekmeister> anyone used programming in haskell?
01:13:33 <cinimod> is that the name of a book?
01:17:54 <tehgeekmeister> yes
01:18:20 <cinimod> author?
01:18:43 <tehgeekmeister> graham hutton
01:19:14 <cinimod> I guess you can deduce from my ignorance that I haven't :-)
01:19:37 <tehgeekmeister> yea, i figured as much.
01:19:56 <tehgeekmeister> it seems to be more introductory/less thorough than hudak's book, so i'll probably go with his.
01:23:11 <cinimod> :t suchThat
01:23:13 <lambdabot> Not in scope: `suchThat'
01:23:26 <cinimod> @src suchThat
01:23:26 <lambdabot> Source not found. Wrong!  You cheating scum!
01:24:02 <cinimod> @src arbitrary
01:24:03 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:24:20 <cinimod> :t arbitrary
01:24:22 <lambdabot> Not in scope: `arbitrary'
01:24:39 <cinimod> :t Test.QuickCheck.arbitrary
01:24:41 <lambdabot> forall a. (Test.QuickCheck.Arbitrary a) => Test.QuickCheck.Gen a
01:24:50 <cinimod> :t Test.QuickCheck.suchThat
01:24:52 <lambdabot> Not in scope: `Test.QuickCheck.suchThat'
01:24:59 <cinimod> Bother!
01:26:09 <cinimod> @hoogle (\a -> Bool) -> (\b -> Bool) -> (\(a,b) -> Bool)
01:26:10 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\a -> Bool'
01:26:21 <cinimod> @hoogle (a -> Bool) -> (b -> Bool) -> ((a,b) -> Bool)
01:26:22 <lambdabot> No matches, try a more general search
01:28:23 <cinimod> @pointless \x -> x
01:28:23 <lambdabot> id
01:28:40 <cinimod> @pointless \l -> \u -> \x -> (x >= l) && (x <= u)
01:28:40 <lambdabot> (. flip (<=)) . ap . ((&&) .) . flip (>=)
01:30:39 <augustss> @djinn (a -> Bool) -> (b -> Bool) -> ((a,b) -> Bool)
01:30:39 <lambdabot> f a b (c, d) =
01:30:39 <lambdabot>     case a c of
01:30:39 <lambdabot>     False -> b d
01:30:39 <lambdabot>     True -> False
01:34:59 <jbauman> xor is an interesting choice
01:35:33 <jbauman> well, not xor
01:46:37 <cinimod> :t \l u -> do m <- l; n <- u; return (n >= m)
01:46:39 <lambdabot> forall (t :: * -> *) t1. (Ord t1, Monad t) => t t1 -> t t1 -> t Bool
01:47:06 <cinimod> :t \x -> case x of Nothing -> True; (Just x) -> x
01:47:08 <lambdabot> Maybe Bool -> Bool
01:47:10 <opqdonut> jbauman: isn't that something akin to implication
01:48:34 <cinimod> :t \l u -> do m <- l; n <- u; return (n >= m) Nothing Nothing
01:48:36 <lambdabot>     Couldn't match expected type `t2 -> t1 t'
01:48:36 <lambdabot>            against inferred type `Bool'
01:48:47 <cinimod> :t (\l u -> do m <- l; n <- u; return (n >= m)) Nothing Nothing
01:48:49 <lambdabot> Maybe Bool
01:49:28 <cinimod> :t (\x -> case x of Nothing -> True; (Just x) -> x) ((\l u -> do m <- l; n <- u; return (n >= m)) Nothing Nothing)
01:49:31 <lambdabot> Bool
01:50:13 <cinimod> :t \a b -> (\x -> case x of Nothing -> True; (Just x) -> x) ((\l u -> do m <- l; n <- u; return (n >= m)) a b)
01:50:16 <lambdabot> forall t. (Ord t) => Maybe t -> Maybe t -> Bool
01:50:20 <int-e> @type fromMaybe True
01:50:22 <lambdabot> Maybe Bool -> Bool
01:50:48 <int-e> > map (fromMaybe True) [Nothing, Just False, Just True]
01:50:49 <lambdabot>  [True,False,True]
01:50:57 <cinimod> :t \a b -> fromMaybe ((\l u -> do m <- l; n <- u; return (n >= m)) a b)
01:50:59 <lambdabot> forall (t :: * -> *) t1. (Ord t1, Monad t) => t t1 -> t t1 -> Maybe (t Bool) -> t Bool
01:51:21 <cinimod> :t fromMaybe ((\l u -> do m <- l; n <- u; return (n >= m)) Nothing Nothing)
01:51:23 <lambdabot> Maybe (Maybe Bool) -> Maybe Bool
01:51:46 <int-e> @type fromMaybe
01:51:48 <lambdabot> forall a. a -> Maybe a -> a
01:52:06 <cinimod> :t fromMaybe True ((\l u -> do m <- l; n <- u; return (n >= m)) Nothing Nothing)
01:52:08 <lambdabot> Bool
01:52:12 <cinimod> Ta
01:52:42 <cinimod> :t \a b -> fromMaybe True ((\l u -> do m <- l; n <- u; return (n >= m)) a b)
01:52:44 <lambdabot> forall t. (Ord t) => Maybe t -> Maybe t -> Bool
01:53:02 <cinimod> @pointless \a b -> fromMaybe True ((\l u -> do m <- l; n <- u; return (n >= m)) a b)
01:53:03 <lambdabot> (line 1, column 43):
01:53:03 <lambdabot> unexpected ";"
01:53:03 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
01:53:10 <cinimod> @pointless (\a b -> fromMaybe True ((\l u -> do m <- l; n <- u; return (n >= m)) a b))
01:53:10 <lambdabot> (line 1, column 44):
01:53:10 <lambdabot> unexpected ";"
01:53:10 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
01:53:22 <cinimod> :t \a b -> fromMaybe True ((\l u -> do m <- l; n <- u; return (n >= m)) a b)
01:53:24 <lambdabot> forall t. (Ord t) => Maybe t -> Maybe t -> Bool
01:53:34 <cinimod> @pointless (\a b -> fromMaybe True ((\l u -> do m <- l; n <- u; return (n >= m)) a b))
01:53:35 <lambdabot> (line 1, column 44):
01:53:35 <lambdabot> unexpected ";"
01:53:35 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
01:53:45 <int-e> the @pl command can't handle do notation
01:54:23 <int-e> @pl \l u -> fromMaybe True (l >>= \m -> u >>= \n -> return (n >= m))
01:54:23 <lambdabot> (fromMaybe True .) . liftM2 (flip (>=))
01:54:42 <cinimod> you beat me to it
01:55:00 <cinimod> Hmm not sure how readable that is though
01:55:05 <int-e> and flip (>=) = (<=)
01:55:51 <cinimod> :t (fromMaybe True .) . liftM2 (<=)
01:55:53 <lambdabot> forall a1. (Ord a1) => Maybe a1 -> Maybe a1 -> Bool
01:55:59 <cinimod> Not too bad
01:57:38 <masm> I have a definition for factorial that when I try "drop 9499 (take 9500 primes)" it takes less than 1 seconds, and with "drop 9999 (take 10000 primes)" it doesn't seem to stop. What is happening?
01:58:49 <xerox> masm: primes grow! And also, the numbers you pass to take and drop sum up.
01:59:13 <int-e> why don't you use !! to get the n-th element of a list?
01:59:54 <masm> xerox, that would be an explanation if it took 2 seconds.
01:59:55 <int-e> and what do primes have to do with factorials :)
02:00:12 <xerox> hehe, yeah, you drop after the take. Do what int-e says :)
02:00:13 <masm> Oh.. not factorial, primes.
02:01:33 <masm> Oh... I understand what was appening.
02:02:46 <masm> What is a fast primes function that returns a list with all primes?
02:02:49 <masm> Faster than:
02:02:55 <masm> primes = let primes' (h:t) = h : primes' (filter (\x -> x `mod` h != 0) t)
02:02:55 <masm>          in primes' [2..]
02:03:24 <int-e> we have endless mailing list threads on that - do we have a wiki page?
02:03:54 <masm> Sorry.
02:04:03 <xerox> > let primes = 2 : 3 : [n | n <- [5,7..], all (\p -> mod n p /= 0) (takeWhile (\p -> p*p <= n) primes)] in primes !! 10000
02:04:05 <lambdabot>  104743
02:05:12 <roconnor> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
02:05:38 <cinimod> :t (\l u x = l >>= \m -> u >>= \n -> return ((x >= m) && (x <= n)))
02:05:40 <lambdabot> parse error on input `='
02:05:42 <int-e> http://www.haskell.org/haskellwiki/Prime_numbers
02:05:43 <lambdabot> Title: Prime numbers - HaskellWiki
02:05:52 <xerox> There's also one very fast on hpaste, written by wli.
02:06:05 <cinimod> :t (\l u x -> l >>= \m -> u >>= \n -> return ((x >= m) && (x <= n)))
02:06:08 <lambdabot> forall (m :: * -> *) a. (Ord a, Monad m) => m a -> m a -> a -> m Bool
02:06:17 <cinimod> @pl (\l u x -> l >>= \m -> u >>= \n -> return ((x >= m) && (x <= n)))
02:06:18 <lambdabot> (. ((. (((return .) .) . ap (flip . (((.) . (&&)) .) . (>=)) (<=))) . (.) . (>>=))) . (.) . (>>=)
02:09:34 <int-e> masm: btw I wasn't complaining about the question. I was looking for stuff to refer you to :)
02:28:29 <sebell> How do I view the associated patch with a bugfix on GHC TRAC?
03:16:04 <jedai> Pourquoi n'y a-t-il pas de DiffUArray Bool alors qu'il y a un IOUArray Bool ?
03:16:38 <jedai> Et est-ce facile Ã  corriger en dehors de la librairie ?
03:17:07 <ohub> kantsii kokeilla englanniksi niin sujuu paremmin :)
03:17:47 <sieni> ohub: <3
03:18:33 <ibid> :)
03:18:59 <ibid> piti tarkastaa kanavan nimi pari kertaa :)
03:20:15 <sieni> jedai: Je pense que englais peut etre un meilleur choix
03:20:29 <sieni> vai miten helevetissä toi sanotaan ranskaks
03:20:33 <sieni> ibid: joo samoin
03:20:45 <jedai> sieni: Ooops, didn't even realize I was speaking French ... ^^
03:20:53 <ohub> It's always good to get people confused ;)
03:21:15 <jedai> Why isn't there a DiffUArray Bool when there is an IOUArray Bool
03:21:33 <jedai> And is it easy to correct this outside of the library ?
03:21:34 <ibid> several years ago, it happened quite a few times on #debian-devel that the dutch started talking to each other in their native language
03:21:47 <ibid> my response was usually to start talking in finnish :)
03:22:08 <ibid> (the dutch in this case were long-time members of the project, not newbies:)
03:22:49 <sieni> jedai: I don't have anything against speaking french, I'm not just very good in it :-)
03:23:00 <jedai> ibid: I really didn't intend to speak French, it was just... you know I was a little frustrated by this strangeness (there might be an excellent reason for that, but all the others IOUArray have their Diff translation)
03:23:35 <ibid> jedai: i wasn't talking to you specifically, just relating a story that this episode reminded me of :)
03:23:48 <ibid> jedai: language oopses happen to everybody sometimes :)
03:24:05 <ohub> and confusing channels is pretty common
03:24:08 <jedai> sieni: Yeah, I understand that and I avoid it normally since I consider it rude to speak a language most of the others channel member don't understand :-/
03:26:32 <bluestorm_> and sieni, your french doesn't look so bad :)
03:27:03 <sieni> well, it's much worse than my swedish or italian
03:27:19 <ibid> the closest to the french language i've ever been is when my french coworker inhabits the same room
03:28:14 <jedai> sieni: Yes, considering French isn't easy to learn, you're pretty good (it's nice to speak a lot of language, seems useful and fun ! :-P )
03:28:24 <hpaste>  Diff pasted "m sort" at http://hpaste.org/2544
03:31:41 <Tibixe> how can I install Yi? configure, build and install was successful, I have /usr/local/lib/yi-vty-0.2/ghc-6.6/Yi, but where is the executable file?
03:31:49 <sieni> jedai: I don't think french is any more difficult than italian as far as grammar and such is concerned
03:32:59 <jedai> sieni: As I don't know italian I can't comment on that, most of my foreign friends seems to find there is too much exceptions in French though
03:34:10 <jedai> sieni: Well, as far as grammar is concerned, German has a much more complex grammar...
03:34:28 <TSC> In German you just run all the words together
03:34:32 <sieni> finnish on the other hand is pretty regular. you just have a fuckload of verb and noun forms
03:34:34 <bluestorm_> than french ? i wouldn't say so
03:34:49 <sieni> \o
03:34:52 <sieni> \o/
03:35:01 <sieni> Tero Pitkämäki \o/
03:35:33 <ibid> bluestorm_: 14 noun cases
03:36:02 <ibid> bluestorm_: add to that various suffixes (possession etc)
03:36:06 <bluestorm_> i was talking about german
03:36:14 <ibid> ah
03:36:17 <sieni> bluestorm_: not to speak of all the forms of verbs where you are using a verb as a noun
03:38:48 <jedai> bluestorm_: Are you german or did you learn german before french ?
03:39:00 <bluestorm_> hm
03:39:16 <bluestorm_> i'm french, and trying to learn german sometimes
03:39:33 <jedai> bluestorm_: The grammar in french isn't that hard, except there's a whole lot of exception to it... ^^
03:39:57 <bluestorm_> well, i think exceptions are the hard part of any grammar
03:40:04 <jedai> bluestorm_: And you find german grammar easier ? o_O
03:40:16 <hpaste>  Deff pasted "m sort 2" at http://hpaste.org/2545
03:40:20 <bluestorm_> because they are the ones you can't learn by just thinking about it for some time
03:41:47 <jedai> And with all that, nobody even commented on my initial question... :-(
03:43:47 <sebell> jedai: I looked at the module docs... had nothing to contribute though :)
03:44:08 <jedai> sebell: Well thanks for the thought still ! ^^
03:55:45 <Tibixe> please help me
03:55:48 <Tibixe> how can I install Yi? configure, build and install was successful, I have /usr/local/lib/yi-vty-0.2/ghc-6.6/Yi, but where is the executable file?
03:56:59 <sieni> /usr/local/bin/yi ?
03:58:49 <hpaste>  Naktibalda pasted "IO problem" at http://hpaste.org/2546
03:59:01 <Naktibalda> :)
03:59:09 <Naktibalda> nice
03:59:37 <Naktibalda> so I am trying to learn haskell and I have simple problem with types
03:59:37 <evir> Do not use let skicaiai, but skaiciai <-
03:59:39 <evir> In main.
03:59:53 <evir> Oh no.
04:00:13 <evir> You need.
04:00:15 <evir> return []
04:00:32 <Naktibalda> then how to convert IO [t] into [t] ?
04:01:05 <evir> Hm, what are you going to do with the list returned by skaiciai?
04:01:33 <Naktibalda> to use some numerical foldr operations
04:01:35 <xerox> Naktibalda: generally speaking, you can't. On the other hand, you can write a do block, calling iot :: IO [t] you have: do xs <- iot; ...
04:01:54 <xerox> There, xs :: [t], for the scoper of '...'
04:02:18 <evir> Well it looks as if use want to use askForNumbers as an IO action here. So you would need to "return []" and "return $ number : rest" and "rest <- askForNumbers"
04:02:24 <evir> You are mixing things up here. :-)
04:03:35 <Naktibalda> return $ ?
04:04:14 <hpaste>  (anonymous) annotated "IO problem" with "(no title)" at http://hpaste.org/2546#a1
04:04:25 <evir> Naktibalda: See the annotation.
04:05:14 <evir> Naktibalda: f $ x is just f x, to save parenthesis.
04:07:19 <evir> Naktibalda: Basically "<-" gets the "a" out of an "IO a" and return puts an "a" into an "IO a".
04:08:12 <evir> Where getting "a" out of an "IO a" means to execute the IO action and get their value.
04:08:26 <Naktibalda> this is exercise 3.10 from YAHT, so it should be simple :)
04:08:36 <evir> It is. :-)
04:08:44 <evir> It's just something to getting used to.
04:09:13 <evir> Naktibalda: As you can see from the annotation, it isn't very difficult: http://hpaste.org/2546#a1
04:10:29 <evir> Naktibalda: The problem in your source is, that you need to have actions inside of a do block. "number : rest" is no such IO action, but "return (number : rest)" is one.
04:10:38 <Naktibalda> yes
04:10:44 <evir> Same with "[]" versus "return []"
04:10:50 <Naktibalda> I found in further chapter, that return add IO to type
04:10:51 <Naktibalda> :)
04:11:04 <Naktibalda> but that doesn't helped for me
04:11:34 <Naktibalda> my first version was with return, but main function was without return :)
04:13:06 <Naktibalda> thank you for help
04:13:46 <evir> Naktibalda: You'll get more familiar with this kind of things starting from Chapter 9. ;-)
04:14:00 <evir> Expect to hang several days on that one. :->
04:14:30 <evir> But YAHT is nice.
04:15:35 <Tibixe> what do .hi files mean?
04:16:12 <evir> It's the interface description for object file. For example, it contains typing information of the functions in an .o files.
04:17:28 <Tibixe> thanks
04:23:34 <takamura> hi
04:52:14 <cinimod> @pl \l x -> l >>= \m -> return (x >= m)
04:52:14 <lambdabot> flip (fmap . (>=))
04:52:32 <cinimod> :t fmap
04:52:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:53:04 <cinimod> :t \l x -> l >>= \m -> return (x >= m)
04:53:06 <lambdabot> forall (m :: * -> *) a. (Ord a, Monad m) => m a -> a -> m Bool
05:14:16 <araujo> morning
05:20:39 <matthew-_> http://www.erlang.org/pipermail/erlang-questions/2007-September/028834.html
05:20:43 <lambdabot> Title: [erlang-questions] Erlang rocks..., http://tinyurl.com/2z6ogc
05:21:08 <matthew-_> err, this is a little worrying. I wonder what he found problematic?
05:22:47 <roconnor> matthew-_: maybe they was refering to network library support.
05:24:40 <matthew-_> could have just been the type system tbh.
05:28:46 <xerox> reffie
05:50:13 <jedai> Ok, I've read the source for Data.Array.Diff and I still don't see why there is no DiffUArray Bool ?
05:51:44 <jedai> Besides I don't see how to make a new instance of DiffArray from outside the library since you can't recode boundsDiffArray without access to the constructors of the type, or am I mistaken ?
05:52:35 <jedai> So is it broken or am I just being dumb ?
05:52:38 <thartman> would it help the commune if I volunteered my vps as a ghc head build bot? and is this feasible? only 4G disk space.
05:53:02 <jedai> thartman: I don't think it would hurt her at least
05:57:30 <Cale> jedai: I don't see a reason either. You could try copying and modifying the appropriate instances so that there is an instance for Bool
05:57:40 <Cale> It's probably just an oversight.
05:58:53 <jedai> Cale: Yep, it's what I would have liked to do, but another oversight is that you can't create other instances of IArray (DiffArray ...) because you don't have access to boundDiffArray
05:59:51 <Saizan> @source Data.Array.Diff
05:59:51 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/Diff.hs
05:59:54 <Cale> oh, heh
06:00:03 <jedai> Cale: You have the newDiffArray, the replaceDiffDArray and the readDiffArray which are allegedly there for the exact purpose of allowing to create new instances, but without boundsDiffArray it's all moot
06:00:17 <Cale> yeah
06:00:38 <jedai> Cale: since to write boundsDiffArray you need access to the internals of Diff...
06:01:08 <jedai> Cale: It might be there's a way to bypass that, but I don't know it
06:01:24 <xerox> At least it's in a package that you can darcs get, modify, build and install.
06:01:25 <Cale> Complain to libraries@  :)
06:01:44 <Cale> oh, it's separate now?
06:02:01 <xerox> Yup, everything (?) has been split.
06:02:37 <Saizan> containers
06:02:45 <jedai> xerox: Well maybe I'll try that, but for now I'll just leave it at that, it's not that important to me
06:02:59 <xerox> When you darcs get ghc you then have to 'perl darcs-all --extra get' to get all the code.
06:03:41 <jedai> What's strange is that such a big oversight seems to have been in the library for some time now
06:03:54 <jedai> Which is why I believe I'm missing something here
06:05:00 <jedai> I mean that DiffUArray Bool would be forgotten, ok, but that you can't do new instances with the stuff that's exported only for this purpose... I can't believe it
06:09:44 <jedai> Saizan: No it's in array, not containers, which by the way means lambdabot @source needs to be updated (the URL is no longer valid)
06:10:18 * Saizan nods
06:11:04 <jedai> Saizan: And the "oversight" is still there... It's really strange since it seems it would take a couple of seconds (!) to correct it. Is that really an oversight or am I victim of myopia o_O
06:18:33 <Saizan> might it have anything to do with the fact that UArray Bool is bitpacked?
06:25:22 <dcoutts> ibid: I don't see darcs-monitor on hackage yet... :-)
06:25:47 * dcoutts repeats the mantra "If it's not on Hackage it doesn't exist!"
06:26:21 <matthew-_> it would be useful if hackage's build system didn't use the broken haddock
06:26:37 <dcoutts> mattam: the broken haddock?
06:26:41 <matthew-_> in fact, what is the status with getting the new haddock into a releasable state?
06:26:44 <dcoutts> ibid: I wonder if we could/should use darcs-monitor rather than the current script we have on darcs.haskell.org
06:26:54 <dcoutts> matthew-_: oh, you mean haddock 2.0
06:27:02 <matthew-_> dcoutts: the "standard" haddock can't parse haskell
06:27:06 <dolio> That requires the unreleased GHC.
06:27:07 <matthew-_> which is slightly annoying
06:27:09 <dcoutts> @seen waern
06:27:09 <lambdabot> I saw waern leaving #ghc and #haskell 2d 12h 51m 30s ago, and .
06:27:22 <dcoutts> matthew-_: it can't parse GHC Haskell, it can parse H98
06:27:57 <matthew-_> dcoutts: Right. But that prevents hackage building documentation for a large number of packages
06:28:00 <dcoutts> matthew-_: yes, expect a haddock 2.0 release after ghc-6.8 is out
06:28:24 <dolio> Anyone know off hand if there's a list of all the fancy new -X GHC options, and what they do?
06:28:47 <dolio> I noticed that I now don't have nearly enough LANGUAGE pragmas in my libraries. :)
06:29:04 <dcoutts> dolio: yes, ghc --supported-languages
06:29:23 <dcoutts> though of course only in recent ghc-6.7
06:29:24 <dolio> Ah, handy.
06:29:26 <matthew-_> dolio: personally, I don't trust the LANGUAGE stuff. In GHC, some seem to just turn on glasgow-exts
06:29:35 <dcoutts> matthew-_: not anymore
06:29:42 <dolio> matthew-_: It used to do that, but not anymore.
06:29:51 <dolio> Hence why it used to compile fine, but now it blows up. :)
06:30:26 <matthew-_> oh super
06:30:51 <matthew-_> is 6.7 reasonably stable atm? I haven't worked with 6.7 for a couple of months now.
06:31:16 <dolio> Yeah, I just went through and added {-# OPTIONS_GHC -fglasgow-exts #-} to a bunch of files, but that gave me a naughty feeling.
06:31:20 <dcoutts> matthew-_: try it when the ghc-6.8 fork happens
06:31:29 <dcoutts> which will be in a few days
06:31:33 <dolio> It's worked fine every time I've managed to build it for the last few months.
06:31:48 <dcoutts> there will be a 6.8.1 RC then 6.8.1 in about a month
06:31:55 <dcoutts> there is no 6.8.0
06:32:09 <matthew-_> wow. I wasn't expecting that to happen so quickly
06:32:12 <dcoutts> just a month's worth of release candidates for 6.8.1
06:32:44 <matthew-_> have they got type synonynm families in and working now then?
06:32:58 <dcoutts> they're in but they will not be announced as a supported feature
06:33:04 <matthew-_> oh?
06:33:09 <dcoutts> think of them as being a preview :-)
06:33:12 <dcoutts> not finished yet
06:33:35 <matthew-_> is this because they really need a constraint solver engine in ghc?
06:33:47 <dcoutts> no, just because they're still work in progress
06:33:58 <matthew-_> (I'm guessing here from some comments on spj on bugs which are now marked for 6.10)
06:34:00 <dcoutts> they've been working hard on them for months now
06:34:13 <matthew-_> hmmm. were they expecting them to be this hard?
06:34:24 <dcoutts> dunno
06:34:32 <dcoutts> but they are known to be hard
06:34:58 <matthew-_> ok. I wish I'd gone to the anglo haskell talk to hear what spj said about the death of fundeps
06:35:08 <dcoutts> it was a fun talk
06:36:51 <matthew-_> are fundeps just going to be deprecated or fully removed by 6.8 or 6.10?
06:37:06 <dcoutts> no change in 6.8
06:38:49 <ibid> dcoutts: hackage has been in my mind :)
06:39:01 <ibid> dcoutts: let me know if there's something missing in darcs-monitor
06:39:01 <dcoutts> ibid: good good :-)
06:39:12 <mrd> do you really think associated types are that much simpler than fundeps?
06:39:27 <dcoutts> ibid: I'll take a look
06:39:45 <ibid> dcoutts: darcs send should work, as well :)
06:40:33 <dcoutts> ibid: you mean setting it as an apply hook?
06:40:45 <ibid> dcoutts: no, if you want to send patches :)
06:40:51 <dcoutts> oh right :-)
06:40:56 <evir> mrd: I find them definitively more intuitive to use.
06:41:31 <evir> At least, from what I read. I've not used associated types practically, yet.
06:41:46 <ibid> dcoutts: one problem it's inefficient for large repos currently
06:42:14 <ibid> dcoutts: but that's an algorithm problem i more or less know how to solve, hasn't just been on the top of my priority list yet :)
06:42:22 <mrd> I read through the new type families wiki page, but in the examples, it seemed to me that fundeps came out on top.
06:43:01 <dcoutts> ibid: why is that?
06:43:36 <dcoutts> ibid: our current script just remembers the hash of the last patch to be sent out and calls darcs changes to find the patches more recent
06:43:45 <ibid> dcoutts: it does a full darcs changes --xml and matches that to a list of already seen patches
06:43:55 <dcoutts> oh, hmm
06:43:56 <ibid> dcoutts: yes, that's the plan for this too :)
06:44:06 <ibid> dcoutts: for some reason i didn't see how to do that originally
06:44:12 <dcoutts> ok, you've seen the current script we use on darcs.h.o ?
06:44:28 <ibid> dcoutts: i've seen some script with your name on it :)
06:44:33 <dcoutts> ok :-)
06:44:38 <ibid> dcoutts: can't guarantee it's the same version you're now using
06:44:43 <mrd> associated types code was longer and required new constraint syntax like "a ~ B"
06:45:11 <ibid> dcoutts: ought to be a simple change, except for transitioning from the old to the new
06:45:27 <ibid> hm, actually, just figured out how to do that simply, too
06:48:21 <dcoutts> ibid: the current version we use on d.h.o : http://haskell.org/~duncan/darcs-commit-message.sh
06:48:33 <fasta> Is there a flag, s.t. the name a+b is also a valid variable name?
06:48:57 <fasta> Naming things a_plus_p, or aPlusB is inconvenient.
06:48:59 <dcoutts> no
06:49:04 <fasta> b'
06:49:06 <fasta> b*
06:50:00 <importantshock> Which is the standard, underscores or camelcase?
06:50:05 <importantshock> Seems like it's camelcase.
06:50:20 <fasta> camelcase is recommended by Igloo
06:50:34 <fasta> I use underscores.
06:50:52 <importantshock> sorry for the ignorance, but who - or what - is Igloo?
06:51:09 <fasta> importantshock: try tab completion and say hello
06:51:15 <evir> I use camelCase because the base libraries do. So programs look more regular.
06:51:26 <importantshock> Alright, thanks.
06:51:38 <jedai> importantshock: Ian Lynagh, like /whois would have tell you ?
06:51:55 <importantshock> My bad.
06:55:00 <fasta> There are editors that can adapt to style, IIRC, as long as it's consistent, which essentially makes it a non-issue.
06:55:34 <importantshock> Interesting.
06:56:01 <importantshock> If you mention that you like camelcase in a Ruby channel, you'll get flamed into oblivion. Haskellers are so much more relaxed. :P
06:56:40 <fasta> importantshock: Ruby used _?
06:56:45 <fasta> importantshock: uses*
06:56:59 <evir> .to_str and such.
06:57:14 <importantshock> fasta: Yes. Apparently it's easier for Japanese guys to read words separated by underscores rather than camelcase.
06:57:28 <fasta> importantshock: In Lisp there's -, which is the only good choice ;)
06:57:32 <evir> I like words seperated by dashes.
06:57:39 <fasta> importantshock: _ is stolen from '-"
06:57:43 <evir> But that's not possible in most languages. :-)
06:57:46 <fasta> importantshock: AFAIK
06:58:01 <kfish> importantshock, i wish japanese people would use spaces in japanese :-)
06:58:11 <fasta> importantshock: I used to use camelcase, but switched to _ after my experiences in the Lisp world.
06:58:18 <importantshock> fasta: Interesting. The readability of the dashes-paradigm is one of the reasons I like scheme
06:58:32 <dolio> Oleg sometimes uses ' to separate words. That can look interesting.
06:58:40 <dolio> call'with'current'continuation
06:59:03 <fasta> "Paradigm", that sounds like it's of some importance ;)
06:59:17 <evir> fasta: Hm. :-) I use - and if that is not available, I do camel case. I use _ in C, though.
06:59:21 <importantshock> \whois oleg
06:59:23 <importantshock> shit
06:59:24 <evir> But I write C once in a year or so.
06:59:31 <evir> Or even more seldom.
06:59:35 <dolio> Scheme also gives you 'predicate?' which is cute.
06:59:51 <evir> And shouting functions. "set!"
06:59:56 <importantshock> dolio: Yeah, Ruby took a page from Scheme and allows you to use ? and ! in functions
06:59:56 <fasta> dolio: right, that's what I miss a lot in Haskell.
07:00:09 <importantshock> you guys, wanna see a Ruby trick that will make some eyes bleed?
07:00:12 <evir> Ruby has also stolen ? and !. :-)
07:00:18 <dolio> Yeah. I like that about Ruby, too.
07:00:28 <importantshock> entering '!!??' w/o quotes evaluates to True
07:00:44 <fasta> For some stupid consistency rule '?' is not allowed in variables in Haskell.
07:01:04 <importantshock> fasta: well, ? and ! aren't allowed in Ruby variable names, just method names
07:01:06 <evir> Well in Lisp, everything is allowed.
07:01:12 <evir> You can name your variable (*)(*)
07:01:16 <fasta> "according to the unicode <bla bla bla> it's an operator. " or something like that was the argument.
07:01:25 <fasta> evir: not everything.
07:01:30 <evir> fasta: What not?
07:01:32 <importantshock> I prefer that...if I need to use ? in a variable name, i use hasFoo or isFoo
07:01:36 <evir> fasta: I can even use newlines.
07:01:43 <fasta> evir: See, the Scheme spec.
07:01:54 <DRMacIver> Or isCanHasFoo
07:01:55 <evir> fasta: Ah ok, I am more talking about CL. :-)
07:02:03 <rey_> evir: quoting is cheating! :)
07:02:04 <fasta> evir: And I would be very surprised if CL had no restrictions.
07:02:17 <evir> rey_: Isn't. :-P
07:02:33 <fasta> evir: is 912_ a variable name?
07:02:38 <evir> fasta: Yes.
07:02:38 <importantshock> canHasCheezburger?
07:02:49 <evir> fasta: Just need to quote it.
07:03:06 <importantshock> fasta: in my AP Computer Science class I once replaced every variable name with combinations of _
07:03:09 <rey_> 912_ doesn't even need quoting
07:03:19 <evir> True.
07:03:28 <DRMacIver> (Sorry, that was the result of a conversation with matthias the other day. Eclipse complains if you have predicates which don't start with is. They wanted a predicate that started with has. Linguistic hilarity ensued.)
07:03:49 <fasta> evir: ok, that's rather cool.
07:04:01 <evir> fasta: More or less ...
07:04:24 <fasta> evir: but CL has other problems.
07:04:28 <evir> fasta: Lots of.
07:04:29 <evir> :-)
07:04:50 <evir> I hate (funcall #'foo x y) and these things.
07:05:03 <importantshock> funcall *sucks*.
07:05:06 <evir> Sometimes it is nice to have multiple name spaces, but often it isn't.
07:05:56 <evir> But it reads nice. Just as you can write in O'Caml "map begin fun x -> blabla end"
07:06:01 <evir> :-)
07:06:10 <evir> I like the "begin fun"
07:06:10 <fasta> I often doubt how to name result in  result <- monadic_test in Haskell
07:06:27 <fasta> Not everything can be written point-free in a sane way.
07:06:53 <fasta> Naming is monadic_test is also not a good solution, since it shadows the name, if you want to use it again.
07:07:24 * EvilTerran is playing with infix tycons
07:07:41 <fasta> The only right name would be monadic_test?, but that's not an option, so you end up with the CL monadic_testp
07:07:47 <fasta> Which is horrible.
07:07:49 <EvilTerran> class Axiom a; data a :=: b; data a :+: b; infix  4 :=:; infixl 6 :+:
07:08:01 <EvilTerran> instance Axiom (a :+: Zero :=: a) etc
07:09:00 <EvilTerran> so far, it's looking to be potentially much easier to understand than the usual
07:10:27 <ivant_> is there some Haskell implementation of ODE-solution methods?
07:11:30 <EvilTerran> I'm hoping to end up with a full-blown logic system in the typesystem, complete with nice syntax ;)
07:12:28 <EvilTerran> although it occurs to me that "Axiom" isn't a very good name for what that is. i think i might call it "Holds" instead.
07:12:47 <evir> Or "Fact". ;-)
07:13:20 <EvilTerran> yes... i like that one.
07:13:27 <EvilTerran> i was thinking about "True", but that's taken
07:13:45 <EvilTerran> bonus: "fact" is one character shorter
07:13:48 <EvilTerran> ;]
07:13:55 <evir> It's stolen from Prolog. :-)
07:14:11 <dolio> instance Fact (Bears `Eat` Beets)
07:14:33 <EvilTerran> instance (Fact a, Fact b) => Fact (a :&&: b)
07:14:37 <EvilTerran> etc
07:14:54 <EvilTerran> although that's a prolog *rule* rather than a *fact*.
07:15:24 <dolio> Well, that describes an infinite number of facts. :)
07:15:48 * EvilTerran decides to go for a walk to better meditate on how to take this further. 
07:21:32 <fasta> Wouldn't it be a good time for GHC to switch to a full-blown theorem prover for type inference? Or would that be slower?
07:22:54 <Philippa> what exactly to you mean by "full-blown theorem prover"?
07:23:03 <Philippa> *do you
07:23:45 <fasta> Philippa: something like Otter.
07:24:42 <Philippa> for those of us not familiar with it?
07:25:05 <fasta> @go otter theorem prover
07:25:08 <lambdabot> http://www.mcs.anl.gov/AR/otter/
07:25:08 <lambdabot> Title: Otter: An Automated Deduction System
07:25:31 <Philippa> could you give me an overview of what's relevant for this discussion?
07:26:37 <fasta> From the website of the successor "an automated theorem prover for first-order and equational logic".
07:26:49 <Philippa> that's not sufficient useful info for this discussion
07:27:18 <fasta> Isn't that exactly what GHC tries to do when  undecidable instances are enabled?
07:27:31 <Philippa> or to put it another way, if that's all you can offer then the answer's no
07:28:20 <Philippa> approximately, albeit with a lot of steering via fundeps
07:28:38 <Philippa> though you might want to start by reading up on what's going on with associated types
07:29:50 <dolio> Making a theorem-prover level language/type system that's also convenient to write code in appears to be an open problem, to me.
07:30:51 <Philippa> no kidding
07:31:14 <dolio> Epigram is probably the closest I've seen, but the programs you get look like they're an order of magnitude more verbose than an equivalent Haskell solution, for instance.
07:31:17 <Philippa> and haskell's doing pretty well at exploring certain parts of the design space starting from "convenient to write code in"
07:31:36 <Philippa> yeah, although they contain a lot more info
07:31:52 <Philippa> you can be rather shorter if you don't want to prove that your code does what it's meant to :-)
07:31:54 <dolio> Yeah.
07:32:29 <dolio> I think the Epigram guys are looking into ways of reducing the ammount of stuff you have to say explicitly, though.
07:32:56 <hpaste>  tuxplorer pasted "I get this error, and am unable to understand the logic of it.." at http://hpaste.org/2548
07:32:58 <dolio> Like turning a bunch of clauses that look like a bunch of pattern equations in Haskell into a much more verbose system of nested cases and such.
07:33:48 <tuxplorer> variance :: (Fractional b, Real a) => [a] -> b
07:33:49 <tuxplorer> I don't get what is wrong in this definition..
07:34:03 <Lemmih> tuxplorer: cnt is of type Int.
07:34:34 <importantshock> dolio: Can you actually program in Coq, or is it just an assistant?
07:35:06 <Lemmih> tuxplorer: Use 'genericLength'
07:35:08 <tuxplorer> Lemmih: yes, but Int is a subset of Real right?
07:35:57 <dolio> importantshock: I've not played with it much. But you can write programs with it, and then extract Haskell/OCaml code.
07:36:11 <tuxplorer> ?hoogle genericLength
07:36:12 <lambdabot> List.genericLength :: Integral a => [b] -> a
07:36:12 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
07:36:51 <Lemmih> tuxplorer: That Int is an instance of Real doesn't mean that you can use it as 'Real a => a'.
07:37:35 <dolio> Although, one of the things you might do in Coq, I guess, is make a specification and then have it write the code/proof of that specification automatically.
07:37:48 <dolio> Possibly with some help from you.
07:37:59 <dolio> I don't know if you'd call that 'programming' or not.
07:39:18 <dolio> But I do get the impression that you can write programs by hand in the underlying language, and just use it to encode/prove more interesting things than you could easily do in Haskell's type system.
07:39:40 <tuxplorer> Lemmih: I should use Data.List.genericLength right? That's what I  did, and I still get that error..
07:40:33 <Saizan> tuxplorer: that's probably caused by the monomorphism restriction
07:41:55 <Saizan> tuxplorer: definitions like let cnt = genericLenght list .. (i.e. without formal parameters) are assumed to be monomorphic, so the numeric defaulting kicks in
07:42:21 <tuxplorer> oh!
07:42:44 <Saizan> tuxplorer: you have to give cnt an explicit type declaration
07:43:30 <Lemmih> tuxplorer: Change the type to 'Fractional i => [i] -> i'.
07:44:05 <Lemmih> Saizan: He's not hitting the monomorphism restriction.
07:44:21 <scook0> there doesn't seem to be anything converting as to bs
07:46:21 <tuxplorer> Lemmih: ya. it works now.. :D why did I complicate the type definition so much
07:47:06 <evir> scook0: unsafeCoerce, if you want to shoot yourself in the foot.
07:47:38 <scook0> evir: (it was in the context of tuxplorer's problem)
07:47:54 <evir> Oh.
07:47:54 <scook0> but I prefer (const undefined) for that purpose ;)
07:48:26 <tuxplorer> scook0: I didn't understand your point.. can you please tell me a lil more?
07:50:45 <tuxplorer> scook0: ah! ok.. now I get it..
07:51:12 <scook0> :)
08:06:20 <MarcWeber> @where text
08:06:20 <lambdabot> I know nothing about text.
08:15:10 <cognominal_> what is a prompt when people are talking continuation?
08:15:24 <gour> what do you recommend for working with sqlite3 databases?
08:19:10 <dcoutts> gour: hsdb-hsqlite3
08:19:25 <xerox> Any idea why this does stack overflow:
08:19:36 <xerox> take rows . unfoldr (Just . splitAt cols) . randoms
08:19:47 <dcoutts> gour: erm, hdbc-hsqlite3. sorry, name confusion :-)
08:19:47 <xerox> Where rows and cols are Ints.
08:19:59 <sorear> cognominal_: one of the standard delimited continuation operators, *very* loosely analagous to call/cc
08:20:21 <gour> dcoutts: is it better than takusen?
08:20:32 <dcoutts> gour: dunno
08:20:49 <matthew-_> I don't suppose anyone here has the conference proceedings for hot chips 19?
08:21:03 <gour> dcoutts: ok, will follow your advice
08:21:56 <cognominal_> sorear: is there a tutorial somewhere?  "A monadic framework for continuations" is way over my head
08:22:22 <sorear> cognominal_: Every resource I've seen is slightly over *my* head. :(
08:22:46 * sorear hopes that a nice tutorial will appear someday
08:23:08 <cognominal_> http://www.haskell.org/haskellwiki/Library/CC-delcont seems less scary
08:23:09 <lambdabot> Title: Library/CC-delcont - HaskellWiki
08:24:07 <cognominal_> kudos to people who contributes the the  haskellwiki
08:24:11 <puusorsa> hooray!
08:27:57 <hpaste>  NJD annotated "wrapping an IO action and returning its output" with "(no title)" at http://hpaste.org/2538#a1
08:30:45 <dolio> cognominal_: Let me know if anything on that page confuses you. I haven't had much input on how to make it better than it is.
08:31:36 <ivant_> @pl \a b -> map (a*) b
08:31:36 <lambdabot> map . (*)
08:32:08 <ivant_> @pl \a b -> zipWith (+) a b
08:32:09 <lambdabot> zipWith (+)
08:39:16 <LoganCapaldo> ivant_, really giving @pl a workout I see :)
08:40:40 <dolio> @pl \a b -> map (*a) b
08:40:40 <lambdabot> map . (*)
08:42:21 <LoganCapaldo> @unpl map . (*)
08:42:21 <lambdabot> (\ c -> map ((*) c))
08:42:29 <LoganCapaldo> @unpl map . (flip (*))
08:42:30 <lambdabot> (\ f -> map (\ c -> c * f))
08:42:37 <roconnor> @bab nl en Omschrijving
08:42:39 <lambdabot>   Description
08:42:58 <dolio> @pl flip (*)
08:42:58 <lambdabot> (*)
08:43:08 <LoganCapaldo> oh come on now
08:43:11 <LoganCapaldo> that's just dirty
08:43:19 <dolio> :)
08:43:29 <cognominal_> dolio++  -- it seems what I need
08:44:09 <LoganCapaldo> @pl (flip . flip) (*)
08:44:10 <dolio> cognominal_: I suspect the breadth-first search section might be a little confusing. I'm not certain I grok it fully myself.
08:44:10 <lambdabot> (*)
08:44:14 <LoganCapaldo> @pl (flip . flip) g
08:44:15 <lambdabot> g
08:44:23 <LoganCapaldo> @pl (flip .flip . flip) g
08:44:23 <lambdabot> flip g
08:45:04 <roconnor> @bab en nl geweigerd
08:45:05 <lambdabot>   geweigerd
08:45:12 <roconnor> @bab nl en geweigerd
08:45:13 <lambdabot>   refused
08:45:29 <roconnor> that's not good
08:45:53 <LoganCapaldo> @bab en nl refused
08:46:09 <lambdabot> Plugin `babel' failed with: IRCRaised thread killed
08:46:14 <LoganCapaldo> oops
08:46:20 <LoganCapaldo> @sorry
08:46:20 <lambdabot> Unknown command, try @list
08:48:41 <roconnor> @bab nl en uitgevoerd
08:48:42 <lambdabot>   carried out
08:48:46 <roconnor> that's better
08:51:57 <fasta> dolio: what are you talking about?
08:53:15 <dolio> The delimited continuation tutorial I wrote.
08:55:22 <LoganCapaldo> theres a delimited continuation tutorial!?!?!
08:55:24 <LoganCapaldo> where?
08:55:25 <LoganCapaldo> gimmie
08:55:32 <LoganCapaldo> we wants it precious
08:55:42 <dolio> cognominal posted the link above.
08:56:13 <ivant_> @pl \a b -> (a-b)**2
08:56:13 <lambdabot> flip flip 2 . ((**) .) . (-)
08:56:37 <Botje> :t flip 2
08:56:39 <lambdabot> forall a b c. (Num (a -> b -> c)) => b -> a -> c
08:56:40 <ivant_> @pl \a b -> (b-a)**2
08:56:40 <lambdabot> flip flip 2 . ((**) .) . subtract
08:57:05 <xerox> That's crazy.
08:57:09 <pjd> theory question:  what exactly is the formal connection between parameterized type constructors and "free" functors?
08:57:14 <xerox> ?type ((**2) .) . subtract
08:57:16 <lambdabot> forall a. (Floating a) => a -> a -> a
08:57:19 <xerox> ?type ((**2) .) . (-)
08:57:21 <lambdabot> forall a. (Floating a) => a -> a -> a
08:58:31 <pjd> that is, any algebraic data type with one parameter corresponds to a functor that "replaces" that type parameter
08:59:21 <pjd> (and any ADT with two parameters has a bifunctor replacing those two parameters, and so on)
09:07:06 <augustss> yo
09:07:34 <glguy> yo
09:07:36 <LoganCapaldo> is there a paper, tutorial, something out there that shows how to implement delimitted continuations in terms of "regular" continuations?
09:09:32 <dolio> I'm sure there are papers out there.
09:09:43 <LoganCapaldo> yeah I'm failing at the googling
09:09:50 <dolio> I forget who showed that you can do it, though.
09:10:21 <augustss> LoganCapaldo: perhaps http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615 ?
09:10:25 <lambdabot> Title: TR615: A Monadic Framework for Delimited Continuations, http://tinyurl.com/ytol8r
09:10:53 <dolio> Oh, yeah, I guess there is an implementation in that using an underlying continuation monad.
09:16:30 <LoganCapaldo> this seems interesting too in case anyone else is interested http://calculist.blogspot.com/2006/11/filinskis-implementation-of-shift-and.html
09:16:32 <lambdabot> Title: The Little Calculist: Filinski's implementation of shift and reset, http://tinyurl.com/ypttpy
09:17:45 <dolio> LoganCapaldo: It looks like 'Final Shift for Call/cc' has an implementation of shift and reset in terms of call/cc and mutable state.
09:19:03 <LoganCapaldo> dolio, agreed. Looks like that's what I was looking for
09:19:05 <LoganCapaldo> thanks
09:23:42 <mudge> hey anyone know of a good introduction to category theory on the web?
09:25:08 <Choko> i know one in danish :)
09:26:55 <phobes> Here's a link someone in here pointed me to:  http://www.di.ens.fr/~longo/download.html
09:26:57 <lambdabot> Title: Downloadable Publications
09:27:08 <phobes> mudge: that's for you :)
09:28:17 <mudge> phobes: thanks man
09:28:30 <Cale> Too bad about the typesetting there ;)
09:36:26 <glguy> if you haven't installed any ttf fonts
09:36:46 <glguy> then your fonts will look bad, like mine did when I first installed
09:37:07 <phobes> oh, is that what Cale was talking about :)
09:37:31 <glguy> oh... I think I typed that in the wrong channel :)
09:38:56 <ddarius> mudge: Where are you coming from and what do you want from such an introduction?
09:39:30 <Cale> No, it's just that the author of that PDF used Word or something to typeset it rather than LaTeX.
09:39:34 <Cale> http://www.cs.le.ac.uk/people/akurz/books.html
09:39:36 <lambdabot> Title: Electronically Available Books and Other Sources (mainly Category Theory)
09:40:05 <phobes> ah yes, that was the better link
09:40:30 <sfultong> alright, I'm new to testing... what's the purpose of HUnit vs quickcheck?
09:41:33 <byorgey> HUnit lets you specify "unit tests", i.e. this input should produce this output, and so on
09:41:42 <ddarius> I'm fond of this one: http://www.let.uu.nl/esslli/Courses/barr-wells.html
09:41:47 <lambdabot> Title: Courses: Barr / Wells
09:41:58 <byorgey> whereas quickcheck lets you specify *properties* that functions should satisfy, and the properties are tested with many randomly selected inputs
09:42:54 <byorgey> to give a gross oversimplification, HUnit lets you test corner cases you know about, and quickcheck helps you find new ones =)
09:43:04 <Cale> http://www.cs.man.ac.uk/~hsimmons/BOOKS/books.html has some books which would be of general interest to people here
09:43:06 <lambdabot> Title: Books
09:44:32 <sfultong> byorgey: so quickcheck would probably be more useful for test-driven-development?
09:44:56 <dcoutts> sfultong: yup, it's great for that
09:45:10 <dcoutts> write your spec as QC properties, iterate (code >> test)
09:45:28 <sfultong> ok, thank :)
09:46:15 <sfultong> as much as the idea of test-driven-development makes me impatient, I'm trying to give it a good try
09:47:25 <augustss> dcoutts: but writing properties is rather unlike writing tests (better, IMO)
09:47:41 <dcoutts> augustss: indeed
09:47:50 <dcoutts> shorter, more declarative
09:48:00 <dcoutts> and it makes you think more, helps the design
09:48:09 <augustss> you can write properties that are just tests, of course.  but they are not as powerful
09:48:20 <augustss> yes, properties make you think
09:48:58 <augustss> so they will never be popular
09:49:05 <phobes> heh
09:49:23 <mudge> is there like a category theory for dummies?
09:49:51 <sfultong> yeah, if I felt like I wasn't doing enough thinking, I'd be more inclined to try and learn to write properties
09:52:14 <MyCatVerbs> Heehee.
09:53:03 <MyCatVerbs> http://www.willamette.edu/~fruehr/haskell/evolution.html <-- this seems to be my favourite page on Haskell thus far. Every now and then I reread it and find it a little funnier, in direct proportion to how much more of it I understand. XD
09:53:07 <lambdabot> Title: The Evolution of a Haskell Programmer
09:55:02 <sfultong> xmonad was/is built using quickcheck properties, yes?
09:55:11 <MyCatVerbs> > pred 4
09:55:15 <lambdabot>  3
09:55:20 <araujo> http://lukeplant.me.uk/blog.php?id=1107301645
09:55:22 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
09:56:17 * ddarius didn't like Category Theory in Four Easy Movements.
09:58:40 <sfultong> araujo: beautiful
09:59:59 <mudge> hey is haskell based on category theory?  I'm reading about category theory and I'm noticing similarities
10:01:50 <MyCatVerbs> mudge: lambda calculus, near as I can tell.
10:02:20 <MyCatVerbs> mudge: but it's typed, so...
10:02:22 <ibid> mudge: no
10:02:46 <ibid> mudge: however, a significant feature was inspired by category theory
10:02:57 <mudge> what's the relation with haskell and category theory?
10:03:01 <aFlag> has anyone here made a String instance of Arbitrary class?
10:03:18 <taruti> aFlag: just make a Char instance of Arbitrary
10:03:22 <ibid> mudge: category theory has inspired some ideas that made into haskell
10:03:47 <mudge> such as?
10:03:55 <ibid> mudge: monads
10:03:56 <MyCatVerbs> mudge: a lot of category theory ideas do translate very directly to Haskell and ML-like languages in general (I've seen at least one textbook that uses ML to teach and illustrate category theory).
10:03:58 <ibid> mudge: arrows
10:04:01 <ibid> mudge: not much else
10:04:09 <aFlag> there's already a Char instance, it seems
10:04:27 <aFlag> unless my version of quickcheck doesn't have it
10:04:46 <MyCatVerbs> (And from there, translating ML code to Haskell is generally trivial.)
10:04:57 <ibid> mudge: of course, there's a lot of haskell that maps to category theory nicely, but thats's not because of any ancestry relation
10:05:20 <mudge> ibid: thanks
10:05:47 <aFlag> I know nothing about categories
10:05:50 <ibid> mudge: rather, it's a case of parallel evolution, mostly :)
10:05:56 <augustss> ibid: if you ignore certain parts of Haskell it maps nicely :)
10:06:08 <ibid> mudge: and, in some cases common ancestry
10:06:17 <ibid> augustss: that's what i said?
10:06:30 <EvirDrevo> Hm. In GHC, when I evaluate 9^(9^9) the result ends (some hours and gigabytes of memory later) in the digits 9 and 4.
10:06:38 <ibid> augustss: ah, didn't mean that haskell programs map nicely but that some parts of haskell do
10:06:38 <EvirDrevo> But that can't be. 9^9^9 is an odd number.
10:06:41 <EvirDrevo> Nut an even one.
10:07:14 <MyCatVerbs> 9^9^9 takes a long time to evaluate?
10:07:26 <Heffalump> what type did you evaluate it at?
10:07:31 <MyCatVerbs> Oh hey cool, it segfaulted1
10:07:36 <MyCatVerbs> s/1/!/
10:07:42 <Heffalump> that'll be gmp's fault
10:07:44 <EvirDrevo> Integer, the result is 350MB long, which is approximetialy right.
10:08:08 <EvirDrevo> Given that 10^9^9 has 387420490 digits.
10:08:21 <Heffalump> sounds like a gmp bug to me
10:08:22 <mudge> Hi augustss:  I heard that you win all the obfuscated haskell code contests
10:08:26 <augustss> EvirDrevo: do you need the whole number?
10:08:28 <EvirDrevo> The program is just: main = print $ 9^(9^9)
10:08:43 <augustss> mudge: that's a blatant lie :)
10:08:43 <EvirDrevo> augustss: Even if I wouldn't need it, this is a bug.
10:08:55 <EvirDrevo> 9^9^9 is not even.
10:09:00 <augustss> mudge: I've arranged one, and not participated in any
10:09:02 <MyCatVerbs> Heffalump: I am *way* too lazy to rebuild my whole system with debugging symbols just to be able to see whose code it crashed in. ;)
10:09:03 <EvirDrevo> The last two digits should be 89.
10:09:05 <ddarius> He wins all the obfuscated C code constests
10:09:11 <mudge> augustss:  oh,  :)
10:09:16 <ddarius> For small but not trivial values of all.
10:09:17 <EvirDrevo> The last digit is always either 1 or 9. But not 4.
10:09:19 <Heffalump> MyCatVerbs: I think gdb will tell you what library anyway.
10:09:40 <EvirDrevo> augustss: And yes, I need the whole number. :-)
10:09:42 <mudge> oh that's what it is.  That's pretty cool.   C code contests
10:09:45 <MyCatVerbs> I thought obfusticated Haskell contests were trivial? Just download your own copy of lambdabot, write any nontrivial program in continuation-passing style, then run the whole thing through @pl
10:09:46 <mudge> ddarius: thanks
10:10:01 <augustss> EvirDrevo: to memorize, no doubt
10:10:24 <EvirDrevo> Friend of mine gives away one big box of beer to the first person to deliver him the number. ;-)
10:10:38 <augustss> EvirDrevo: heh!
10:10:40 <ddarius> ibid: There's a bit more idea stealing from category theory than what you've mentioned.  And much more that could be done.
10:10:51 <EvirDrevo> Don't think I will get beer for a number that ends in a 4.
10:10:54 <aFlag> EvirDrevo, it's probably your intel's processor fault, it doesn't know how to count.
10:11:08 <EvirDrevo> aFlag: It's an AMD64. ;-)
10:11:12 <sfultong> damn processors are so buggy today...
10:11:23 <augustss> AMD64 ends in a 4...
10:11:23 <MyCatVerbs> Heffalump: you're right, 0x1caef3fc in __gmpn_kara_sqr_n
10:11:50 <Heffalump> I've had that happen before when I tried to compute something very large.
10:11:54 <MyCatVerbs> Heffalump: and there's another four levels of function calls above that, all beginning with __gmpn_foo in the backtrace.
10:11:57 <Heffalump> I think it just doesn't handle really huge things correctly.
10:11:57 <sfultong> what's gmp?
10:11:59 <Cale> EvirDrevo: Did he specify which base it had to be encoded in?
10:12:10 <Heffalump> the GNU multi-precision library. Used by GHC to implement Integer.
10:12:11 <MyCatVerbs> sfultong: high-precision arithmetic library.
10:12:21 <MyCatVerbs> *Any* precision, even.
10:12:28 <EvirDrevo> Cale: I've already tried that. :-)
10:12:33 <MyCatVerbs> Want 2000-bit floating point numbers? Sure thing, boss!
10:12:40 <sfultong> high-imprecision sounds more like it...
10:12:51 <MyCatVerbs> Heffalump: (w00t for OpenBSD though, all libraries have debugging symbols left in by default, unlike some of the more... evil Unixen.)
10:12:51 <Heffalump> I hadn't heard of it producing wrong results before.
10:12:56 <sorear> EvirDrevo: You want the last digit of 9^9^9 ?
10:13:01 <EvirDrevo> So now I have obviously found a bug in gmp and get no beer.
10:13:04 <mudge> I'm wondering:  I want to be really good at haskell,  I want to be very practical, being very capable with Haskell,  I wonder how much theory,   category theory, lambda calculus etc. I should learn or understand
10:13:05 <EvirDrevo> sorear: No, I *know* the last digit.
10:13:20 <MyCatVerbs> EvirDrevo: which is...?
10:13:20 <EvirDrevo> sorear: Which is why the result of 9^(9^9) that GHC gave me is obviously wrong.
10:13:25 <EvirDrevo> MyCatVerbs: It is 9.
10:13:34 <EvirDrevo> And the second last is 8.
10:13:36 <MyCatVerbs> EvirDrevo: w00t, my curiosity stands abated.
10:13:37 <aFlag> EvirDrevo, try to write your program using C and gmp directly
10:13:42 <Heffalump> any odd power of 9 ends in 9.
10:13:44 <aFlag> see if the same thing happens
10:13:46 <Cale> mudge: Learn it lazily as the need arises. The basic answer is that for practical work, you don't really need too much.
10:13:50 <slarba_> mudge: understanding the basics of lambda calculus surely doesn't hurt
10:13:54 <EvirDrevo> Heffalump: Yes.
10:14:05 <sorear> > (9 ^ ((9^9) `mod` 10000)) `mod` 10000
10:14:06 <lambdabot>  7289
10:14:07 <ibid> ddarius: ah?
10:14:22 <EvirDrevo> sorear: But I need the whole number. :-)
10:14:32 <mudge> Cale, slarba:  thank guys
10:14:34 <Heffalump> otherwise no beer for EvirDrevo
10:14:38 <EvirDrevo> Yeah.
10:14:47 <mudge> thanks*
10:15:05 <EvirDrevo> Ok I'll rewrite this in C+gmp now to see if GHC or gmp is the fault.
10:15:14 <aFlag> you could just not do any programs at all and buy yourself some beer :P
10:15:24 <sfultong> I like that solution
10:15:45 <MyCatVerbs> mudge: I'd recommend a quick skim of basic lambda calculus first, then dive into writing whatever programs seem fun to you at the time, while munching on chunks of category theory, graph theory, numerical analysis and so on as you go along. Basically anything fun.
10:15:57 <Cale> 2617004315060225040660196165699439754361026855266374036682906190174923494324178799359681422627177289
10:16:06 <Cale> that's the result modulo 10^100
10:16:32 <EvirDrevo> 127246416086963151179438406886301203839852769055220247401192070203737237617257599269311384805010594
10:16:36 <EvirDrevo> These are mine.
10:16:45 <slarba_> mudge: things get interesting when you start to learn type theory.
10:17:00 <pejo> MyCatVerbs, the little lambda calculus, graph theory and numerical analysis I know doesn't really help me - I'm still a shitty programmer.
10:17:13 <sfultong> yeah... just write a program to compute the modulo n part, and then increase n by 1 in iterations :)
10:17:15 <iguana_> too bad, google doesn't compute it :)
10:18:00 <sfultong> it'd be great if google's math calc used haskell
10:18:20 <MyCatVerbs> pejo: that makes two of us, though I probably know a lot less of the math than you. Hence, write programs. For fun, even!
10:18:25 <mudge> MyCatVerbs, slarba_,  thanks guys,  you guys in here are very helpful
10:18:45 <sfultong> slarba_: where's something interesting on type theory?  I've seen a tiny bit, but it didn't look interesting at quick glance
10:19:18 <slarba_> sfultong: a good starting point is simon thompson's "type theory and functional programming"
10:19:45 <sfultong> it's no fair... haskell makes me learn other stuff ;-(
10:20:59 <slarba_> sfultong: just google ttfp.pdf and you should find it
10:21:38 <MyCatVerbs> mudge: you think -that- is helpful, find Cale and try asking for help with mathematics. Eyyyyy.
10:22:45 <mudge> Simon Thompson's book on Haskell is such an easy read so far,  i wish other books were like that
10:23:47 <norpan> it should not be easy, then anybody can learn it!
10:24:29 <MyCatVerbs> norpan: but if everybody learns it, then it'll be impossible to coerce them into working within the confines of Java or C# or COBOL or Fortran or C++ or...
10:25:06 <MyCatVerbs> norpan: and then J2EE will just disappear for want of people to hack on it! Which'd surely be wonderful, no?
10:25:35 <SamB> norpan: I don't think it works that way
10:27:26 <mudge> norpan: yea, then there would be more haskell programmers
10:28:12 <mudge> Samb: how does it work?
10:28:50 <SamB> well, I don't think idiots can ever learn it
10:29:36 <mudge> haha
10:30:02 <mudge> SamB: That's one thing I learned about Haskell -- actually first learned about Lisp,  that it is full of smart people
10:30:36 <Modius> In haskell - does tail (tail (tail (tail ..... (tail somelist)))) technially memoize the original list but also keep the deep set of closures?  Are there coding practices that pertain to this sort of situation?  Is there a good link to an article that explores it?
10:30:57 <Heffalump> what do you mean by memoize the original list?
10:30:58 <mudge> And completely separate from the languages themselves you'll get smarter and be a programmer just by being connected to the smart community -- reading books by smart people etc.
10:31:22 <mudge> better programmer*
10:32:20 <Modius> Heff:  I should back up my question (as it's worded based on assumption) - I know that to implement tail(tail(tail(somelist))), where somelist was an in-memory list, this would result in a 3 level closure + the original list for lazy, or the tail of the list in eager evaluation.  I would like to know how this situatio plays out in practice in haskell
10:35:26 <Heffalump> Modius: sorry, getting dragged off for dinner. Will answer later if noone else does.
10:36:57 <roconnor> Modius: often somelist is itself a closure that generates a list.
10:37:33 <roconnor> or a thunk
10:37:36 <roconnor> or whatever it is called
10:40:02 <ddarius> Modius: Just graph reduce.
10:40:34 <EvirDrevo> Ok, now I am redoing 9^9^9 in C+gmp and see if the result is correct.
10:40:45 <EvirDrevo> Let's wait some hours, then. :->
10:41:14 <byorgey> EvirDrevo: too bad you don't have an account on some sort of supercomputer...
10:41:47 <pjd> Modius:
10:41:47 <pjd> foo somelist = (t1,t2)
10:41:47 <pjd>     where t1 = tail (tail (tail somelist)); t2 = tail (tail (tail somelist))
10:42:05 <pjd> are you asking whether t1 and t2 refer to the same shared tail?
10:42:32 <EvirDrevo> byorgey: Then everybody would earn his beer by calucating big numbers ... nah. :-)
10:42:42 <sjanssen> Modius: I wouldn't be surprised if GHC optimizes that to: case somelist of (_:_:_:xs) -> xs; _ -> error "tail: empty list"
10:43:49 <byorgey> EvirDrevo: how is your friend going to check that the numbers submitted to him are correct?  Has he already computed it?
10:44:23 <EvirDrevo> byorgey: That's his problem. But I think he'll spot when the last few digits are wrong, easily. :-)
10:44:38 <EvirDrevo> I think he is going to do a second run.
10:45:06 <EvirDrevo> The beer is mine until he has proven me wrong. ;-)
10:45:45 <b_jonas> 9^9^9 shouldn't take an unreasonable amount of time I think
10:46:07 <ddarius> 9^9^9 /= 9^(9^9)
10:46:14 <opqdonut> yeah
10:46:19 <EvirDrevo> Nah, ^ is right accociative.
10:46:25 <b_jonas> yep, I know
10:46:26 <EvirDrevo> 9^9^9 /= (9^9)^9
10:46:42 <MyCatVerbs> > (9^9)^9
10:46:44 <lambdabot>  196627050475552913618075908526912116283103450944214766927315415537966391196809
10:46:48 <MyCatVerbs> Nice.
10:46:54 <MyCatVerbs> > 9^9^9
10:46:57 <EvirDrevo> Getting the calucation done is just some minutes, the output takes a bit longer.
10:46:59 <lambdabot> Terminated
10:47:01 * MyCatVerbs hums...
10:47:07 <MyCatVerbs> Damn.
10:47:07 <byorgey> > 9 * logBase 10 (9^9)
10:47:09 <lambdabot>  77.29364326458531
10:47:20 <ddarius> Oops.
10:47:23 <byorgey> uh...
10:47:25 <b_jonas> it's 369693100 digits or so long
10:47:29 <EvirDrevo> Jup.
10:47:31 <b_jonas> that fits in memory
10:47:35 <MyCatVerbs> > last $ show (9^9)^9
10:47:37 <lambdabot>   add an instance declaration for (Num String)
10:47:39 <byorgey> > 9^9 * logBase 10 9
10:47:40 <b_jonas> and with fft multiplication and such
10:47:41 <lambdabot>  3.6969309963157034e8
10:47:47 <b_jonas> it can be done fast
10:47:47 <MyCatVerbs> > last $ show $ (9^9)^9
10:47:49 <lambdabot>  '9'
10:48:06 <EvirDrevo> b_jonas: Yes, the calucation is fast and doesn't even swap out. The output is slow.
10:48:08 <sfultong> (^) is right associative? weird
10:48:20 <byorgey> sfultong: why shouldn't it be?
10:48:22 <b_jonas> evirdrevo: you mean the output in base 10?
10:48:22 <ddarius> It makes sense, I just wasn't thinking.
10:48:27 <EvirDrevo> b_jonas: Yes.
10:48:33 <b_jonas> hmm. makes sense
10:48:37 <ddarius> (9^9)^9 = 9^(9*9)
10:48:40 <sfultong> byorgey: because I assumed it wasn't? :-P
10:48:53 <b_jonas> and what's the bet? do you need all digits?
10:48:53 <byorgey> sfultong: well in THAT case... =)
10:49:02 <ddarius> > 9^81
10:49:04 <lambdabot>  196627050475552913618075908526912116283103450944214766927315415537966391196809
10:49:05 <EvirDrevo> b_jonas: I've waited for or five hours the last time and it consumed several GiB of memory.
10:49:27 <EvirDrevo> b_jonas: And I got a number with the right number of digits. But it ends in the digit 4, which is impossible.
10:49:36 <b_jonas> ouch
10:49:49 <EvirDrevo> That's why I redo it with C and gmp now, to see if gmp or GHC is wrong.
10:49:55 <sfultong> why do we have to have associativity and infix and all that confusion? why can't we just standardize on postfix or prefix, and be done with it?
10:50:05 <sfultong> (it'd be easier to read)
10:50:13 <EvirDrevo> sfultong: Well, you can just use all operators prefix, if you like. ;-)
10:50:19 <EvilTerran> what're you trying to work out, here?
10:50:25 <integral> ((+) 1 2) -- don't we have prefix?
10:50:32 <b_jonas> it's a bit easier to verify it though, because you just have to divide the number with a random 10 digit integer and calculate 9^(9^9) modulo that integer and compare those for equalty, repeat
10:50:39 <EvilTerran> the last digit of 9^(9^9)?
10:50:49 <EvirDrevo> EvilTerran: No, all digits.
10:50:56 <EvirDrevo> In base 10.
10:51:13 <b_jonas> so you don't actually have to multiply two large numbers for it
10:51:22 <b_jonas> does that make sense?
10:51:25 * EvilTerran has a lazy little-endian instance Num [Int] that he used for one of the Project Euler problems...
10:51:36 <EvirDrevo> b_jonas: modular exponentiation ... but it doesn't help me in this case. :-)
10:51:42 <EvirDrevo> But yes, 9^9^9 mod 10 is fast.
10:51:54 <b_jonas> EvirDrevo: yep, but you know you won't be able to cheat
10:51:55 <ddarius> EvilTerran: The little-endian is a bit redundant.
10:52:04 <EvirDrevo> b_jonas: Hm. :-)
10:52:24 <b_jonas> that answers byorgey too
10:52:28 <EvilTerran> ddarius, is it? eh, i guess so...
10:52:35 <byorgey> b_jonas: I see, nice.
10:53:01 <b_jonas> obviously it's easy to calculate only the last few or first few digits
10:53:06 <byorgey> much easier to verify a proposed solution (with high probability) than to compute it.
10:53:27 <b_jonas> byorgey: maybe his friend knew this and that's why he betted
10:53:49 <ddarius> How are you supposed to give him the answer?
10:53:54 <byorgey> b_jonas: right.
10:54:26 <EvirDrevo> ddarius: Give him the file with the digits in base 10.
10:54:28 <b_jonas> ddarius: it's just a four hundred megs large file
10:55:11 <EvirDrevo> It's certainly doable. And I don't think he knew that libgmp would get it wrong.
10:55:30 <ddarius> Are you going to send it over the internet, or use a thumb drive/CD, or are you on a LAN with him?
10:55:50 <EvirDrevo> ddarius: We have 100MBit LAN through the whole town.
10:56:02 <EvirDrevo> So, the latter.
10:56:13 <sfultong> EvirDrevo: whoa, where do you live?
10:56:40 <EvirDrevo> ddarius: Getting the file to him is probably easier than getting that beer to me. :-)
10:56:49 <b_jonas> it's really weird if it gets it wrong. maybe file a bug report.
10:57:18 <b_jonas> how long did it take with gmp?
10:57:36 <ddarius> It'd have to take a pretty fucked up bug for either GHC or GMP to have screwed up.
10:58:39 <EvirDrevo> A whole new kind of bug, even. After heisenbugs and mandelbugs, there are now the beer stealing ones.
11:00:33 <EvirDrevo> sfultong: A town with lots of students.
11:00:59 * ddarius likes http://catb.org/jargon/html/S/schroedinbug.html
11:01:01 <lambdabot> Title: schroedinbug
11:03:38 <EvirDrevo> gmp actually gets the right result.
11:03:44 <EvirDrevo> So it is a bug in GHC.
11:04:32 <ddarius> EvirDrevo: At least you have a small example...
11:04:42 <fasta> :)
11:04:51 <EvirDrevo> main = print $ 9^9^9
11:04:52 <EvirDrevo> Yeah.
11:04:53 <EvirDrevo> ;-)
11:06:56 <EvirDrevo> The last 100 digits match those from Cale. Looks confident.
11:07:03 <Heffalump> on the plus side, you can get your beer
11:07:51 <byorgey> EvirDrevo: that was pretty fast!
11:08:24 <EvirDrevo> byorgey: Yup.
11:08:45 <EvirDrevo> byorgey: But my first try was using Commin Lisp with SBCL. That wouldn't even finish the calculation in two weeks on the same computer.
11:08:53 <byorgey> hehe
11:08:55 <EvirDrevo> GHC gets the calculation done quickly but somehow messes up the output.
11:09:11 <ddarius> monochrom: Tutorials about dependent typing talk about Clean?
11:09:13 <EvirDrevo> I didn't expect SBCL to be that slow, as it is one of the most aggressively optimizing CL compilers.
11:09:28 <monochrom> haha
11:09:40 <EvirDrevo> But GHC backened with libgmp has major advantages in number crunching.
11:09:49 <monochrom> Oops, not Clean. Something else.
11:09:49 <Heffalump> apart from correctness..
11:09:55 <EvirDrevo> hellige: :-)
11:09:57 <EvirDrevo> Err Heffalump.
11:10:01 <ddarius> EvirDrevo: SBCL uses it's own "bignum" implementation?
11:10:09 <EvirDrevo> ddarius: Yes.
11:10:15 <ddarius> Typical
11:10:25 <sfultong> it's better to get an answer than none... if it's incorrect, you can just process it until it's correct
11:10:36 <Heffalump> sfultong: hmmm...
11:11:03 <Heffalump> that's only true in certain limited circumstances
11:11:14 <SamB> sfultong: why not start at 0
11:11:20 <sfultong> good idea
11:11:38 <ddarius> "Let's assume the answer is 1 to a first approximation..."
11:11:40 <wli> I've no idea where the word "bignum" came from, though it is shorter than "arbitrary-precision arithmetic."
11:11:48 <SamB> big number
11:11:51 <SamB> duh
11:12:27 <wli> It's obvious what it abbreviates. It's not obvious where the term was introduced.
11:12:30 <fasta> Mystery solved! ;)
11:12:30 <SamB> same process as fixnum
11:12:53 <SamB> it certainly seems to be a lispy way to talk...
11:12:53 <monochrom> "bignum" the word is around for a long time. I first saw it 15 years ago or more.
11:13:09 <wli> I don't see "fixnum" used anywhere I read things, nor "bignum."
11:13:12 <fasta> I think big numbers were before "arbitrary-precision arithmetic".
11:13:13 <ddarius> monochrom: Well, yes.  The CL standard is older than 15 years.
11:13:21 <SamB> but I've no idea whether the lispers got it...
11:14:06 <ddarius> I'm pretty sure they made it.
11:14:11 <ddarius> Decades ago no doubt.
11:14:20 <fasta> Odd that Java doesn't have a ArbitraryPrecisionArithmeticManagerConstructorThreadPoolAnalyser...
11:14:28 <wli> That explains it.
11:14:39 <byorgey> http://www.jargon.net/jargonfile/b/bignum.html
11:14:41 <lambdabot> Title: jargon, node: bignum
11:14:49 <wli> I've never been into the Lisps (or anything dynamically typed).
11:15:01 <byorgey> originally from MIT MacLISP, it says.
11:15:08 <SamB> fasta: but what have threadpools to do with bignums?
11:15:32 <SamB> also I don't see why a thread pool shouldn't be "self-managing", as it were
11:15:51 <ddarius> byorgey: That sounds appropriate.
11:15:59 <SamB> oh, wait
11:16:05 <fasta> SamB: nothing, it was just a random concatenation of blurb words after a sensible name.
11:16:06 <SamB> I got the name mixed about...
11:16:09 <ddarius> Especially due to it's relationship to Macsyma
11:16:39 * SamB maybe shook it until it almost made sense
11:16:40 <ddarius> fasta: The sensible name being the empty one?
11:16:59 <fasta> ddarius: ArbitraryPrecisionArithmetic?
11:17:19 <SamB> fasta: wouldn't it be ArbitraryPrecisionNumber?
11:17:26 <ddarius> fasta: Even Java doesn't use that.
11:17:38 <wli> ArbitraryPrecisionInteger
11:17:42 <ddarius> So if they think it's not sensible, it must be true.
11:17:48 <wli> There are arbitrary-precision floating point numbers, too.
11:17:49 <SamB> and even then only for as long as it took them to come up with a better name
11:17:54 <fasta> ddarius: I mean that that name by itself is not non-sensible. Not that I would use it.
11:18:12 <SamB> wli: they're a bit more particular.
11:18:22 <fasta> SamB: This wasn't meant as a lesson in good naming.
11:18:33 <SamB> hmm, I just rememered that Java has no operator methods of any kind :-(
11:18:40 <SamB> ewwwwww
11:18:50 <ddarius> SamB: Now all you have to remember is that you don't program in Java.
11:18:57 <wli> I pretty much stop at the object-oriented part.
11:19:22 <SamB> of course, CL doesn't either :-(
11:19:33 <pjd> (Java actually uses BigInteger and BigDecimal, FWIW)
11:20:00 <ddarius> wli: What's wrong with OO?
11:20:56 <ddarius> Haskell names things correctly.
11:22:05 <wli> ddarius: Well, where do I start? The whole thing is just some hodgepodge of made-up garbage with no formal grounding. FP has been cleaning up after the semantic mess and they've literally been ignoring it all. etc.
11:22:06 <pjd> SamB: there are Java preprocessors for operator overloading
11:22:19 <pjd> jop.dev.java.net
11:22:28 <monochrom> ddarius: such as "data" defines a type, and "type" doesn't define a type? :)
11:22:59 <ddarius> pjd: Ah java.
11:23:30 <ddarius> wli: What about the work on grounding OO, e.g. Cardelli's sigma calculus?  (Which is not to say it's widely applied, but...)
11:23:57 <wli> ddarius: That's the bit about FP'ers cleaning up after the semantic mess the OO'ers made and the OO'ers ignoring it.
11:24:02 <b_jonas> EvirDrevo: did you measure how much time it took?
11:24:27 <EvirDrevo> b_jonas: Not longer than 30 minutes with the C version.
11:24:27 <monochrom> There are beginners who are puzzled about "I'm trying to define my own type. why does 'type' not work?"  Then we say "data".  Then he/she says "but I want to define a type, not a data."
11:24:55 <SamB> monochrom: maybe we should allow an optional occurence of "type" after "data" ;-)
11:25:07 <pejo> wli, would you count OOHaskell and O'Haskell as FP'ers or OO'ers?
11:25:08 <monochrom> I always forget that people take names very very seriously.
11:25:16 <ddarius> We could go to ML's datatype *blech*
11:25:20 <sfultong> does anyone use OOHaskell?
11:25:27 <SamB> ddarius: I meant like "data type Foo = Bar"
11:25:41 <b_jonas> wli: I think they're called bignum because "long integer" were used up already
11:25:43 <ddarius> SamB: Meaning data or type?
11:25:48 <SamB> ddarius: data
11:25:51 <sfultong> I don't like what I see as arbitrary structuring in my programs, and OO seems to be all about that
11:25:57 <monochrom> long long long long integer XD
11:26:05 <ddarius> SamB: I would say going to datatype would be more appropriate
11:26:06 <b_jonas> also, "bignum" is generic, it can mean bigint, bigfloat, bigrat etc
11:26:18 <EvirDrevo> bigrat *g*
11:26:19 <b_jonas> yep, we have long longs
11:26:26 <monochrom> bigcat chasing bigrat
11:26:28 <SamB> ddarius: if you want to break code, sure
11:26:29 <b_jonas> soon we'll have long long longs
11:26:34 <b_jonas> or long shorts
11:26:38 <b_jonas> and short longs
11:26:40 <SamB> b_jonas: how?
11:26:45 <ddarius> b_jonas: Yes, but bigints should be called integers and normal ones smallints or e.g. the Schemely fixednum.
11:26:46 <b_jonas> dunno
11:26:55 <b_jonas> the other option would be widenums
11:26:55 <monochrom> Someone should make a new language and call it bigcat. It's number type should be called bigrat.
11:27:09 <ddarius> stoutnums
11:27:14 <pjd> monochrom: there is Cat...
11:27:16 <pejo> sfultong, it's referenced every now and then in articles. There's someone still using O'Haskell although it's EOL'd since a long time iirc.
11:27:18 <sfultong> tallnum
11:27:19 <SamB> ddarius: I kind of like the truncation of integer standing for a truncated representation of integers...
11:27:28 <b_jonas> they shouldn't be called integers, that would just cause confusion
11:27:37 <ddarius> SamB: Which is why Haskell names things correctly.
11:27:38 <sfultong> ventinum
11:28:04 <b_jonas> they can be called integer in a programming language, but sometimes you have to refer specifically that you're using arbitary precision
11:28:15 <SamB> another language that gets it right is C--
11:28:15 <b_jonas> and then you need a word like bigint
11:28:16 <ddarius> pejo: OOHaskell /= O'Haskell
11:28:19 <wli> I almost never use Int
11:28:30 <wli> Integer all the way.
11:28:35 <sfultong> you purist
11:28:37 <ddarius> SamB: That's not surprising...
11:28:38 <pejo> ddarius, I know.
11:29:11 * SamB isn't sure if C-- gets floating-point right or not though
11:29:12 <monochrom> I almost never use state.
11:29:48 <wli> sfultong: Well, Z/2^32Z is not what I'm looking for most of the time and in a number of cases would actually give wrong answers.
11:30:21 <SamB> wli: yeah
11:30:24 <SamB> I know what you mean
11:32:28 <wli> The number of cases where Z/2^32Z gives wrong answers makes me quake with fear of what must be a far beyond massive number of integer overflow bugs in e.g. C.
11:33:24 <SamB> wli: I only tend to notice it doing project euler problems, except that array allocation problem of course...
11:34:21 <wli> I notice it elsewhere.
11:37:21 <b_jonas> I'm not saying integer should mean fixint by default either, only that it can mean anything, and I didn't want to imply anything about which one you should use.
11:37:35 <wli> Really it comes up almost any time you multiply things.
11:38:52 <sfultong> GoodEnoughInteger
11:38:59 <LoganCapaldo> DWIMInteger
11:39:24 <wli> And if you actually add overflow checks they are far beyond agonizing.
11:39:43 * sfultong wants to develop a language called GoodEnoughProgrammingLanguage
11:40:56 <monochrom> integer could mean algebraic integer such as 4+5i
11:40:57 <b_jonas> what about 64 bit integers?
11:40:59 <aFlag> have anyone used Map with QuickCheck? At ghc6.6 Map.hs Map seems to be a instance of Arbitrary, but when I write a prop as simple as prop_test s = id s where typ = s::(Map Int Int) it says it needs Map Int Int to be an instance of Arbitrary
11:41:15 <b_jonas> algebraic integer? that's very complicated
11:41:23 <monochrom> yes.
11:41:28 <LoganCapaldo> what's an algebraic integer?
11:41:44 <b_jonas> if you want to do calculations with roots of nth degree polynomials that can't even be written as surds, then you're stuffed
11:41:49 <monochrom> I have forgotten enough to define it! :)
11:41:55 <b_jonas> better get mathematica or something
11:41:59 <LoganCapaldo> (Integral a, Functor f) => f a ?
11:42:06 <monochrom> haha
11:42:18 <ddarius> That's what I'll do.  Make a language with Int being a Guassian integer.
11:42:27 <LoganCapaldo> Guassian Integer?
11:42:28 <sjanssen> aFlag: the arbitrary instance is commented out
11:42:32 <wli> b_jonas: Um, it's easy. Just Z[x]/(p(x)) where p(x) is the minimal polynomial.
11:42:36 <ddarius> Gaussian
11:42:52 <monochrom> Gaussian integer simply means <integer> + <integer>i
11:43:02 <wli> Z[i]
11:43:16 <b_jonas> wli: if you want to compare them for greater-then (assuming they're real) it's quite complicated.
11:43:27 <b_jonas> it's not trivial even with surd expressions
11:44:00 <monochrom> Take a field. Then a certain subset of it is so "nice", we find it useful and call it "the ring of integers of that field". I forgot now nice is nice, but if you apply this to the field Q you get Z again, so it kind of makes sense.
11:44:31 <b_jonas> I want to write a program once that can do calculations with expressions containing square roots and arithmetic operations
11:44:42 <monochrom> If you take Q[i] = { a+bi | a, b in Q } as the field, then it's ring of integers is the Gaussian integers.
11:45:29 <wli> I thought it had to do with monic polynomials over integers.
11:45:30 <monochrom> Hrm, I may be wrong about the last statement.
11:45:36 <monochrom> Yeah.
11:46:49 <EvirDrevo> So ... now I'll have a look at that ttfp.pdf mentioned earlier. :->
11:47:46 <EvirDrevo> It's so cool how Haskell shows one new things.
11:48:04 <EvirDrevo> I hate tearm breaks without learning new things. ;-)
11:59:36 <fasta> Why don't we have foo:: (Monad m) => (a1 -> a2 -> a3 -> m a) -> m a1 -> m a2 -> m a3 -> m a in the std. libs?
12:00:32 <dolio> @type ((join .) . ) . liftM3
12:00:34 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a3)
12:00:34 <lambdabot>     Probable cause: `liftM3' is applied to too many arguments
12:00:49 <dolio> @type (((join .) .) .) . liftM3
12:00:51 <lambdabot> forall a a1 a2 a3 (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> m a) -> m a1 -> m a2 -> m a3 -> m a
12:01:09 <fasta> dolio: heh, I had the exact same function
12:01:24 <LoganCapaldo> @type (liftM . ap . ap) -- does this work too?
12:01:26 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> b) -> m ((a -> a1) -> a) -> m ((a -> a1) -> b)
12:01:37 <LoganCapaldo> clearly not :)
12:01:41 <chessguy> @unpl (((join .) .) .) . liftM3
12:01:41 <lambdabot> (\ f k n q -> (liftM3 f k n q) >>= \ g -> g)
12:01:43 <SamB> @type ap
12:01:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:01:58 <LoganCapaldo> @type (ap . ap . liftM)
12:02:00 <lambdabot> forall a a1 r. (a1 -> r) -> (((a -> a1) -> a) -> a -> a1) -> ((a -> a1) -> a) -> r
12:02:06 <chessguy> \g -> g ?
12:02:08 <LoganCapaldo> I'm missing something
12:02:09 <LoganCapaldo> heh
12:02:32 <SamB> @unpl join
12:02:33 <lambdabot> (\ b -> b >>= \ a -> a)
12:02:34 <chessguy> @pl \g -> g
12:02:34 <lambdabot> id
12:03:04 <SamB> @. pl unpl (((join .) .) .) . liftM3
12:03:05 <lambdabot> flip flip id . ((flip . ((flip . ((>>=) .)) .)) .) . liftM3
12:03:20 * importantshock cowers in fear
12:03:22 <jbauman> that's not exactly optimal
12:03:29 <SamB> indeed
12:03:45 <fasta> I don't get you don't get bored by abusing @pl.
12:04:01 <fasta> It's not like we haven't seen that a thousand times already.
12:04:25 <SamB> @pl (((join .) .) .) . liftM3
12:04:25 <lambdabot> (((join .) .) .) . liftM3
12:04:25 <dolio> I suppose you could have a whole family of extends like there's a whole family of liftMs.
12:04:36 <fasta> dolio: I already have.
12:05:15 <dolio> The only one we have is extend = (=<<)
12:06:00 <jbauman> :t (\ f k n q -> join . (liftM3 f k n q))
12:06:02 <lambdabot> forall (m :: * -> *) a a1 a2 a3 a11. (Monad m) => (a1 -> a2 -> a3 -> m (m a)) -> (a11 -> a1) -> (a11 -> a2) -> (a11 -> a3) -> a11 -> m a
12:08:04 <chessguy> @type liftM3
12:08:06 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
12:11:12 <Botje> hu
12:11:14 <Botje> argh
12:12:31 <fasta> @type extend
12:12:33 <lambdabot> Not in scope: `extend'
12:12:42 <dolio> There's no function so named.
12:12:54 <fasta> dolio: who made it up? Wadler?
12:12:59 <dolio> But (=<<) is the function usually called 'extend' in the literature.
12:13:14 <fasta> dolio: yes, I already figured that.
12:13:49 <dolio> I can't remember what I've read that uses that particular one.
12:14:41 <dolio> Most use bind or join.
12:15:24 <dolio> But extend/coextend/fmap has more symmetry.
12:15:49 <dolio> (a -> b) -> (f a -> f b) ; (a -> m b) -> (m a -> m b) ; (w a -> b) -> (w a -> w b)
12:16:03 <dolio> Out of order.
12:16:07 <LoganCapaldo> calling it dnib would be more symetrical :)
12:16:13 <chessguy> wouldn't =<< be better called extendWith or something?
12:16:21 <chessguy> since it takes a f unction as the first argument
12:16:27 <chessguy> @type =<<
12:16:29 <lambdabot> parse error on input `=<<'
12:16:34 <chessguy> @type (=<<)
12:16:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:17:29 <fasta> dolio: but why would we choose >>= to be extend or coextend?
12:17:43 <fasta> dolio: what makes one "co" and the other not?
12:18:01 <LoganCapaldo> the one that came second is the co one
12:18:26 <fasta> So, you have a problem if you think of them both at the same time ;)
12:18:29 <dolio> >>= is bind = flip extend. It's more useful for writing imperative-looking sequenced code.
12:18:35 <jbauman> :t (join .) . liftM
12:18:37 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
12:18:48 <offender> 8 year old girl is screaming in agony while his dad is impaling her with a pocket knife and while his penis is in girl's vagina
12:18:50 <dolio> coextend is for comonads.
12:19:45 * SamB fights the urge to correct offender's grammar
12:19:58 <Auris-> that's really bad prose.
12:20:00 <dolio> extend/coextend is more convenient if you're thinking from the perspective of lifting functions to work in a monadic domain.
12:20:26 <dolio> So it shows up in papers where they have some operator notation for extend.
12:20:50 <dolio> Like if f :: (a -> m b), f* :: m a -> m b.
12:20:57 <dolio> So _* is extend.
12:22:42 <fasta> dolio: f and f* make zero sense to me.
12:23:27 <dolio> f* would be a special notation for 'extend f'.
12:24:03 <fasta> But then the type is still wrong, right?
12:24:16 <fasta> Oh, never mind
12:24:17 <dolio> Type of what?
12:24:36 <fasta> f* was a transformation of g by lifting a to the monadic level.
12:24:39 <fasta> er f
12:24:40 <dolio> It probably wouldn't be *, though. It'd be like a dagger, or something else I can't actually type.
12:27:11 <dolio> I think, for instance, Backus' FP language uses a similar notation for fmap.
12:27:46 <dolio> If f :: a -> b, f* :: [a] -> [b] (since he probably wasn't thinking about general functors).
12:29:21 <dolio> Oh, I guess it's a prefix alpha.
12:30:15 <dolio> Maybe it's squiggol that uses *. Or something else. :)
12:30:50 <jbauman> :t fmap
12:30:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:30:54 <jbauman> :t liftM
12:30:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:38:04 <Nucleo_> @src putTraceMsg
12:38:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:38:15 <Nucleo_> @src Debug.Trace.putTraceMsg
12:38:15 <lambdabot> Source not found. You type like i drive.
12:38:39 <chessguy> @hoogle Debug.Trace.putTraceMsg
12:38:40 <lambdabot> No matches, try a more general search
12:39:06 <Heffalump> http://www.improvedideas.com/files/repos.tar.gz
12:42:05 <aFlag> on quickcheck I'm trying to make a certain string to be more likely to be generated than others, but it won't let me do instanciate String as an instance of Arbitrary
12:44:19 <LoganCapaldo> Would -fallow-overlapping-instances or similar help?
12:44:48 * LoganCapaldo guesses theres already an instance for Char and an isntance for (Arbitrary a) => [a]
12:45:43 <aFlag> yeah, there is. I was hoping there was a better way of doing that
12:45:53 <aFlag> instead of having to instantiate String
12:46:23 <aFlag> I didn't try that overlapping-instances, though, let me try
12:47:17 <chessguy> @where zipper
12:47:17 <lambdabot> I know nothing about zipper.
12:47:24 <chessguy> @go haskell zipper
12:47:25 <Lemmih> aFlag: Use a newtype?
12:47:27 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Zippers
12:47:27 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
12:47:28 <Heffalump> oops, just noticed I mispasted that URL, sorry..
12:51:28 <chessguy> i'm trying to remember, there are tree-traversing algorithms that require you to pass state around as you traverse the tree, aren't there?
12:55:46 <ivant> does anyone know, is there some constraint on the maximum number of polyline segments in Cairo (gtk2hs)?
12:56:24 <tehgeekmeister> anyone want to explain sequence (or point me to a good explanation), i thot i was starting to get monads, but this one confuses me.
12:56:48 <Heffalump> @type sequence
12:56:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:57:05 <Heffalump> so, it takes a list of monadic actions, each of type m a.
12:57:52 <Heffalump> You can run such an action, getting out a value of type a. It does this for all the actions, and puts them in a list, i.e. [a]. This all happens within the monad, so we get m [a], i.e. a monadic action that produces [a].
12:57:56 <tehgeekmeister> right, i get that.  looking at it's definition i can't see where any of those actions ever take place -- all the monads i've looked at, the left hand side of the bind is an argument to the right hand side
12:58:13 <jbauman> @. pl unpl sequence . reverse
12:58:13 <lambdabot> sequence . reverse
12:58:33 <Heffalump> sequence is something build on top of bind
12:58:35 <chessguy> @src sequence
12:58:35 <lambdabot> sequence ms = foldr k (return []) ms
12:58:36 <lambdabot>     where
12:58:36 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:58:56 <EvirDrevo> Igloo: How about using a swap file? I neither have 8G of Ram.
13:00:05 <EvirDrevo> EvirDrevo: But I've created a bigger swap file to get it done. ;-)
13:00:44 <EvirDrevo> Err Igloo.
13:00:46 <tehgeekmeister> oh, so sequence is merely sequencing the computations
13:01:00 <tehgeekmeister> it's not actually evaluating them
13:01:01 <tehgeekmeister> is it?
13:01:21 * tehgeekmeister hopes he's gotten it finally
13:01:45 <EvilTerran> in order to do { x <- m; ... }, m has to be evaluated
13:02:37 <tehgeekmeister> this confuses me, because i've only seen the list and maybe monads so far, and i can't imagine this making any sense in terms of them.
13:04:06 <EvilTerran> sequence [m0, m1, ... mN] is the same as do { x0 <- m0; x1 <- m1; ... xN <- mN; return [x0, x1, ... xN] }
13:04:36 <tehgeekmeister> okay
13:04:51 <EvilTerran> > do { x <- [1,2]; y <- [3,4]; return (x,y) }
13:04:53 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
13:04:57 <tehgeekmeister> so, in other words, the same as m0 >>= m1...
13:05:09 <EvilTerran> > sequence [[1,2],[3,4]]
13:05:10 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
13:05:23 <EvilTerran> (sorry, "return (x,y)" should've been "return [x,y]")
13:05:35 <tehgeekmeister> (but with a return [x0,x1...] at the end.)
13:05:53 <EvilTerran> well, the same as m0 >>= \x0 -> m1 >>= \x1 -> ...
13:06:48 <tehgeekmeister> see, that's what i don't get
13:06:53 <tehgeekmeister> as far as i've seen
13:07:06 <tehgeekmeister> this would take \x0 -> m1 >>= \x1 -> ... and apply it to m0
13:07:34 <EvilTerran> kinda, yes.
13:07:43 <EvilTerran> it would apply it to the result of running m0
13:08:01 <EvilTerran> in the case of the list monad, that's each element of m0 in turn
13:08:22 <EvilTerran> @src [] (>>=)
13:08:23 <lambdabot> m >>= k     = foldr ((++) . k) [] m
13:08:29 <EvilTerran> hm.
13:08:53 <EvilTerran> m >>= f  =  concat (map f m)
13:09:22 <tehgeekmeister> ohhhhh!
13:09:26 <xerox> ?src concatMap
13:09:26 <lambdabot> concatMap f = foldr ((++) . f) []
13:09:27 <tehgeekmeister> i think i've gotten it!
13:10:11 <tehgeekmeister> so m0 is evaluated, and it's result is now available for m1, and so on down the line, hence being equivalent to actions evaluated in order in an imperative language
13:10:12 <tehgeekmeister> right?
13:10:45 <tehgeekmeister> and then the results, as the last action, are put into a list
13:10:50 <tehgeekmeister> in order of execution
13:16:13 <shapr> @yow !
13:16:13 <lambdabot> Here we are in America ... when do we collect unemployment?
13:16:28 <EvilTerran> indeed.
13:16:42 <shapr> So, what did I miss?
13:16:55 <EvilTerran> pretty much. although it's transformed so as to express it the same way for any length of list.
13:18:03 <tehgeekmeister> okay, cool.
13:18:13 <EvilTerran> sequence [] = return []; sequence (m:ms) = do { x <- m; xs <- sequence xs; return (x:xs) }
13:18:18 <tehgeekmeister> now to keep trodding through the rest of the monad tutorial.
13:18:23 <EvilTerran> ^ i prefer that to the @src version
13:18:35 <EvilTerran> *xs <- sequence ms
13:18:51 <tehgeekmeister> i like that one better, too.
13:18:55 <tehgeekmeister> it's clearer.
13:18:59 <wli> Unemployment insurance in the US? You must be thinking of a very different country.
13:19:08 <dolio> @pl \f -> return (f a)
13:19:09 <lambdabot> return . ($ a)
13:19:15 <tehgeekmeister> wli: washington state has it!
13:20:42 <wli> De jure; de facto it's so far from sufficient it's more of an insult than assistance.
13:21:35 <shapr> I always thought of contract work as unemployment insurance.
13:22:44 <shapr> Because it sort of pays, and is sort of like being unemployed at the same time.
13:23:07 <wli> Pardon me while I try to stop laughing and pick myself up off the floor.
13:23:25 <shapr> astrolabe: Hey, I wrote a simplistic binding to Selenium on Friday, it's not too bad.
13:23:38 <wli> What's Selenium?
13:24:17 <shapr> It's a web testing framework that runs as a firefox extension, so it's easy to test anything, ajaxy included.
13:25:01 <shapr> It's either elegant, or an ugly hack, maybe both.
13:25:14 <shapr> I think the high end of ugly hacks wraps around to the low end of elegance.
13:25:24 <EvilTerran> well, that sounds like firefox alright
13:30:31 <EvilTerran> (i think firefox is great -- the extension system, especially -- but let's be realistic here. it's written in *XML* and *javascript*.)
13:30:59 <allbery_b> and C++ that makes the other two look clean
13:31:59 <shapr> I occasionally wish for a browser written in Haskell.
13:32:09 <wli> That'd be nice.
13:32:15 <chessguy> hey shapr, how's the selenium stuff?
13:32:17 <shapr> But then I realize that I'd probably have to write it...
13:32:21 <chessguy> hackage-able soon?
13:32:22 <shapr> chessguy: It works, it's nice!
13:32:31 <shapr> Oh, I dunno. Depends on what license AlexJ gives it.
13:32:32 <Nafai> shapr: That's the problem with most software I want
13:32:34 <chessguy> sweet!
13:32:47 <xerox> I want an IRC client that lets people do collaborative editing, with files associated with rooms.
13:32:56 <Nafai> xerox: That would be cool!
13:33:25 <shapr> Plus I'd really like to have separate functions for each call, right now it's minimal: foo <- initSeleniumSession defaultSession (Just "http://localhost:8000/") ; seleniumCommand foo (Command "open" (Just "http://localhost:8000/blog/entryForm") Nothing)
13:33:30 <Nafai> shapr: If I want it, good chance is that I'd have to write it myself
13:33:31 <chessguy> i wonder if the zipper at http://haskell.org/haskellwiki/Zipper_monad could be parameterized with generalized state for stateful tree computations
13:33:32 <lambdabot> Title: Zipper monad - HaskellWiki
13:34:00 <Choko> xerox: like gobby
13:34:01 <chessguy> like data Loc c a s
13:34:28 <xerox> Choko: yeah, I am using it *right now* :)
13:34:29 <hpaste>  shapr pasted "How to simplify?" at http://hpaste.org/2550
13:34:33 <Nafai> Choko: Doesn't gobby use Jabber or something?
13:34:38 <shapr> There's got to be a way to make that simpler.
13:34:49 <xerox> Nafai: nope, it has got its own protocol I think.
13:34:53 <Choko> Nafai: it uses the obby protocol
13:34:54 <shapr> Yeah, libobby
13:34:57 <Nafai> Ah
13:35:10 <Nafai> I thought I had seen one of those that used Jabber, maybe I was dreaming
13:35:14 <xerox> Let's put a community obby server :)
13:35:37 <chessguy> shapr, hmm. looks like you want a map (maybe "")
13:35:39 <shapr> I'd have to write an emacs obby library then.
13:35:45 <chessguy> (at least)
13:35:52 * shapr tries that.
13:36:00 <shapr> I thought about zipWith (maybe "")
13:36:04 <shapr> But it didn't seem right.
13:36:46 <shapr> Maybe I want a fold?
13:37:07 <shapr> hiya Bobtree, learning Haskell?
13:37:23 <shapr> Guess not.
13:37:25 <jbalint> haha
13:37:34 <chessguy> lol
13:37:42 <chessguy> you scared him off :)
13:37:48 <xerox> shapr: there's a way.
13:37:57 <shapr> chessguy: Sometimes I wonder if I can be a bit too friendly :-)
13:38:12 <chessguy> shapr, nah, i'm sure it wasn't you. just a coincidence
13:38:20 <shapr> xerox: What is it?
13:38:29 <EvilTerran> @pl \s -> maybe (("&"++s++"=")++)
13:38:30 <lambdabot> maybe . (++) . ('&' :) . (++ "=")
13:38:46 <chessguy> wow, looks like perl :)
13:38:55 <xerox> > (maybeToList Nothing, maybeToList (Just "foo")) -- and then concatMap ?
13:38:56 <lambdabot>  ([],["foo"])
13:39:05 <shapr> hmm
13:39:08 <shapr> Yeah
13:39:27 <shapr> That is nicer.
13:39:54 <chessguy> hey xerox, any thought about my idea for that zipper?
13:40:32 <EvilTerran> concatMap maybeToList [target command >> "&1=", value command >> "&2=", sid >> "&sessionId="] -- shapr, ?
13:41:07 <shapr> ooh, I gotta try that.
13:41:09 <xerox> chessguy: the easy way is |StateT s Travel a|, else, just add 'userState :: s' to Loc.
13:41:15 <EvilTerran> sorry, that needs some (return)s, or rephrasing with liftM, or something, but you get the idea
13:41:35 <EvilTerran> @pl liftM . const
13:41:35 <lambdabot> fmap . const
13:41:35 <shapr> I kept thinking that a Monad instance for Maybe with the opposite semantics would be simpler, something like mplus?
13:41:55 <shapr> EvilTerran: Yeah, it's a good approach.
13:42:06 <EvilTerran> @. hoogle type liftM . const
13:42:08 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) a.'
13:42:09 <xerox> chessguy: ...or add a level of indirection with Travel { unT :: State (loc,userState) a }.
13:42:26 <EvilTerran> humph.
13:42:43 <EvilTerran> @hoogle a -> m b -> m a
13:42:44 <lambdabot> Prelude.asTypeOf :: a -> a -> a
13:42:45 <lambdabot> Prelude.const :: a -> b -> a
13:42:45 <lambdabot> Prelude.seq :: a -> b -> b
13:42:46 <Ben`> Could anyone help me optimise some code? It's for a Project Euler problem, but takes over a minute to run. I'm new to Haskell, so there may be silly mistakes.
13:43:01 <chessguy> sure Ben`, just hpaste it
13:43:03 <chessguy> @paste
13:43:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:43:06 <hpaste>  Ben` pasted "Problem 92" at http://hpaste.org/2551
13:43:45 <hpaste>  Saizan annotated "How to simplify?" with "my try" at http://hpaste.org/2550#a1
13:44:01 <xerox> shapr: what to do with (Just x) >>= f = case (f x) of Nothing -> (Just x); (Just y) -> ?
13:44:28 <ihope> @djinn a -> b -> c -> d -> e -> f -> (a,b,c,d,e,f)
13:44:28 <lambdabot> f a b c d e f = (a, b, c, d, e, f)
13:44:34 <ihope> I see that it's re-using "f".
13:44:39 <EvilTerran> ?type maybeToList
13:44:41 <lambdabot> forall a. Maybe a -> [a]
13:44:41 <xerox> Saizan: ++? is maybetoList
13:44:50 <xerox> More or less :)
13:45:26 <Saizan> but is nice!
13:45:35 <Saizan> *it's
13:51:42 <shapr> Saizan: That is pretty!
13:53:40 <Mr_Awesome> has anyone compiled fudgets with gcc 4.1.2? i keep getting erros
13:53:42 <Mr_Awesome> *errors
13:54:36 <Lemmih> Mr_Awesome: Try with -fasm?
13:57:45 <Mr_Awesome> Lemmih: ok. i have no idea how to go about doing that...
14:02:06 <ivant> @ty uncurry . uncurry
14:02:08 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
14:02:18 <ivant> @ty uncurry . uncurry . uncurry
14:02:20 <lambdabot> forall b c b1 a b2. (a -> b2 -> b1 -> b -> c) -> (((a, b2), b1), b) -> c
14:02:31 <ivant> @ty uncurry . (uncurry . uncurry)
14:02:33 <lambdabot> forall b c b1 a b2. (a -> b2 -> b1 -> b -> c) -> (((a, b2), b1), b) -> c
14:02:45 <ivant> @ty (uncurry . uncurry) . uncurry
14:02:47 <lambdabot> forall b c b1 a b2. (a -> b2 -> b1 -> b -> c) -> (((a, b2), b1), b) -> c
14:02:55 <ivant> hmm
14:03:28 <iguana_> function composition seems to be associative :)
14:04:10 <ivant> aha, I'm just thinking of a way to do (a -> b -> c -> d -> e) -> ((a,b),(c,d)) -> e
14:04:40 <Heffalump> @. pl djinn (a->b->c->d->e) -> ((a,b),(c,d)) -> e
14:04:42 <lambdabot> f = (`ap` snd) . (. fst) . (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .)
14:05:04 <ivant> forget about it :-)
14:05:06 <Heffalump> hmm...
14:05:09 <iguana_> wth?
14:05:15 <EvirDrevo> @djinn (a->b->c->d->e) -> ((a,b),(c,d)) -> e
14:05:16 <lambdabot> f a ((b, c), (d, e)) = a b c d e
14:05:56 <dolio> @type let flip3 f a b c = f c b a in flip . uncurry . flip3 . uncurry
14:05:58 <lambdabot> forall c a b a1 b1. (a1 -> b1 -> b -> a -> c) -> (a1, b1) -> (a, b) -> c
14:06:08 <Heffalump> nearly :-)
14:06:08 <dolio> @type let flip3 f a b c = f c b a in uncurry . flip . uncurry . flip3 . uncurry
14:06:10 <lambdabot> forall c a b a1 b1. (a1 -> b1 -> b -> a -> c) -> ((a1, b1), (a, b)) -> c
14:06:51 <dolio> @pl \f a b c -> f c a b
14:06:51 <lambdabot> (flip .) . flip
14:07:19 <dolio> Oh, I messed up flip3 there.
14:08:04 <wli> I thought there were 6 permutations of 3 elements.
14:08:10 <iguana_> disturbing, that
14:09:31 <dolio> You won't get a good solution from @pl because it doesn't use uncurry everywhere it's useful.
14:10:07 <dolio> Or curry, for that matter.
14:10:20 <dolio> @pl \f (a,b) -> f a b
14:10:20 <lambdabot> (`ap` snd) . (. fst)
14:10:44 <dolio> @pl \(a,b) -> [a,b]
14:10:45 <lambdabot> uncurry ((. return) . (:))
14:11:02 <wli> @pl \f (a,b,c) -> f a b c
14:11:03 <lambdabot> (line 1, column 8):
14:11:03 <lambdabot> unexpected ","
14:11:03 <lambdabot> expecting letter or digit, operator or ")"
14:11:03 <lambdabot> ambiguous use of a non associative operator
14:11:10 <wli> woops ;)
14:11:22 <dolio> Yeah, it doesn't like n-tuples for n > 2.
14:13:09 <sjanssen> partly because the standard library doesn't have the necessary tools to pointfree expressions using them
14:14:04 <dolio> Well, it doesn't even seem to be able to parse them, either.
14:14:23 <Ben`> can anyone help me optimise this code to run in under a minute? :) http://hpaste.org/2551
14:14:23 <augustss> yo
14:14:54 <Mr_Awesome> Lemmih: i tried it with -fasm and i got the same errors
14:15:14 <wli> re augustss
14:15:37 <Lemmih> Mr_Awesome: Same problem with gcc?
14:16:16 <dolio> Mr_Awesome: Use dynamic programming.
14:16:23 <dolio> Er, my bad.
14:16:25 <augustss> @djinn (a1 -> b1 -> b -> a -> c) -> ((a1, b1), (a, b)) -> c
14:16:25 <lambdabot> f a ((b, c), (d, e)) = a b c e d
14:16:31 <dolio> Ben` ^^
14:17:25 <Mr_Awesome> Lemmih: yes
14:18:15 <Lemmih> Mr_Awesome: That's weird. What errors are you getting?
14:18:58 <Mr_Awesome> expected â=â, â,â, â;â, âasmâ or â__attribute__â before âapply_optionsâ
14:19:29 <Ben`> dolio: ?
14:19:59 <Lemmih> Mr_Awesome: Guess you're out of luck.
14:20:01 <phobes> is there a way to instruct the compiler to memoize?
14:20:50 <xerox> Writing memoizing functions for one.
14:20:58 <augustss> phobes: no, not ingeneral
14:21:08 <phobes> Is there a memoizing version of fix for one parameter?
14:21:18 * integral has a prototype of one
14:21:28 * integral wonders whether to cabalise it for hackage
14:21:36 <xerox> Yup, here: http://haskell.org/haskellwiki/Memoization
14:21:37 <lambdabot> Title: Memoization - HaskellWiki
14:21:49 <Mr_Awesome> Lemmih: does this command line look right? gcc -DVERSION=\"SOCKET\ Version\ 1.3\" -DHAS_H_ERRNO -fasm -O    -c -o inet.o inet.c
14:22:02 <phobes> xerox, cool thanks
14:22:25 <augustss> phobes: you can make one if the parameter has enough constraints
14:22:32 <Lemmih> Mr_Awesome: It does not. -fasm it a flag for ghc.
14:23:20 <phobes> augustss: Ya I could write it... just curious if there was a standard way
14:23:23 <Mr_Awesome> i dont think ghc is being touched yet at this point
14:23:59 <augustss> phobes: and it has been done...
14:24:16 <sjanssen> @google okasaki memoizing fix
14:24:18 <lambdabot> http://www.cs.cmu.edu/afs/cs/user/fp/courses/95-lp/slides/lecture10.sml
14:24:40 <sjanssen> @google okasaki dynamic programming fix site:gmane.org
14:24:42 <lambdabot> No Result Found.
14:25:47 <sjanssen> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/
14:25:49 <lambdabot> Title: Gmane -- Mail To News And Back Again
14:25:51 <hpaste>  dolio annotated "Problem 92" with "memoizing" at http://hpaste.org/2551#a1
14:25:57 <mrd> does anyone still use lhs2TeX?
14:26:15 <dolio> Of course, an array of 10 million elements is pretty big.
14:26:34 <dolio> It might be better to use an infinite map.
14:27:02 <sjanssen> it seems as if you'll have to generate the whole thing anyway
14:27:06 <ramza3> anybody worked on this crazy project.  I want to write a java class loader (because I have to work with java unfortunately)
14:27:16 <mrd> it seems to be generating bad LaTeX output
14:28:17 <__nasa__> :t minFirst smlr [(x@(a, b)) : xs] cur
14:28:19 <lambdabot> Not in scope: `minFirst'
14:28:19 <lambdabot>  
14:28:19 <lambdabot> <interactive>:1:9: Not in scope: `smlr'
14:28:40 <Mr_Awesome> well, has anyone here compiled fudgets with gcc 4.1.2? id really like to use fudgets
14:29:52 <__nasa__> let minFirst smlr [(x@(a, b)) : xs] cur = if (smlr a (fst cur)) then minFirst xs x else minFirst xs cur in minFirst (<) [(1,'x'),(2,'d'),(-1,'s')] (1,'d')
14:29:55 <__nasa__> oops
14:30:01 <__nasa__> > let minFirst smlr [(x@(a, b)) : xs] cur = if (smlr a (fst cur)) then minFirst xs x else minFirst xs cur in minFirst (<) [(1,'x'),(2,'d'),(-1,'s')] (1,'d')
14:30:02 <lambdabot>  Couldn't match expected type `[(t, t1)]'
14:30:37 <shapr> ramza3: Which crazy project?
14:30:54 <shapr> ramza3: Can you use the jvm <-> haskell bridge?
14:30:54 <ramza3> shapr: no I said, I want to write a java class loader in haskell
14:31:13 <ramza3> shapr, that might be an option
14:32:17 <EvilTerran> @hoogle (a -> Bool) -> [a] -> Int
14:32:18 <lambdabot> No matches, try a more general search
14:32:21 <EvilTerran> @hoogle (a -> Bool) -> [a] -> Integer
14:32:21 <lambdabot> No matches, try a more general search
14:33:04 <phobes> dolio:  The code you hpasted has a recursive call to chain instead of calling f (the memoized version)
14:33:26 <dolio> Ah, so I did.
14:33:40 <__nasa__> @hoogle  Ord a => (a -> a -> Bool) -> [(a,b)] -> (a,b) -> (a,b)
14:33:41 <lambdabot> No matches, try a more general search
14:33:47 <EvilTerran> dolio et al, it seems to me that that project euler problem could be expressed as an unboxed array of Bools; that'd be fairly reasonably sized
14:34:03 <__nasa__> @hoogle  Ord a => (a -> a -> Bool) -> [(a,b)] -> (a,b)
14:34:04 <lambdabot> No matches, try a more general search
14:34:29 <dolio> Well, note that if you map the sum-square-of-digits function across [1..9999999] once, it compacts the number of solutions you have to find quite a bit.
14:34:48 <dolio> So you don't actually need a 10 million element array.
14:35:09 <EvilTerran> however, the strictness of UArrays would cause problems...
14:36:15 <dolio> If you have N digit numbers, the maximum value of the sum square is N * 9^2.
14:36:25 <dolio> > 7 * 9 * 9
14:36:26 <lambdabot>  567
14:36:54 <dolio> So you only need a 567 element array to find all the values for 1 .. 9999999
14:37:01 <dolio> Which is a lot better than bit packing. :)
14:37:25 <phobes> Don't you then just need 567 bits?
14:38:11 <EvilTerran> huh. you do then need to do a pass of the original to work out what maps to what in that first step
14:38:15 <EvilTerran> *still
14:38:21 <EvilTerran> but that's *clever*
14:38:23 <EvilTerran> dolio++
14:38:25 <dolio> Yeah, but 567 bits versus 4536 bits isn't going to break the bank.
14:38:42 <Ben`> dolio: thanks
14:38:53 <Ben`> dolio: but I don't understand what the f does in your chain definition
14:38:53 <dolio> Or whatever the boxed array of ints would be.
14:39:32 <__nasa__> Is there a nice way to find the minimum in a list [(x,y)] across just x's, then return the corresponding (x,y)?
14:39:47 <dolio> Ben`: It's supposed to be used for the recursive call. You should call 'f' instead of 'chain' in the last case, but I mistyped.
14:40:08 <Ben`> dolio: oh, ok
14:40:22 <dolio> @type minimumBy
14:40:24 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
14:40:34 <dolio> @type minimumBy (comparing fst)
14:40:36 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
14:40:50 <__nasa__> yeah, ok. I was trying (<) there. Thanks!
14:41:09 <Ben`> __nasa__: I think you can just use minimum
14:41:17 <augustss> @type minimumBy (compare `on` fst)
14:41:19 <lambdabot> Not in scope: `on'
14:41:23 <SamB> wli: what's the git equivalent of "darcs unrecord"?
14:41:30 <__nasa__> @type minimum
14:41:32 <lambdabot> forall a. (Ord a) => [a] -> a
14:41:52 <__nasa__> but (x,y) is not a member of Ord, is it?
14:42:04 <dolio> It is if both x and y are.
14:42:18 <dolio> > compare (1, 2) (1, 3)
14:42:18 <__nasa__> and it just runs lexicographically?
14:42:19 <lambdabot>  LT
14:42:23 <__nasa__> ok, cool.
14:42:26 <Ben`> > minimum [(2,2), (1,99999)]
14:42:28 <lambdabot>  (1,99999)
14:42:29 <__nasa__> Nice to know.
14:42:38 <__nasa__> Thanks!
14:42:54 <Ben`> :)
14:43:07 <wli> SamB: I'm not sure.
14:45:51 <__nasa__> SamB: I don't know if it has one. darcs is pretty unique in that regard, IIUC.
14:46:19 <__nasa__> @type minimumBy (comparing fst)
14:46:21 <Liskni_si> SamB: i'd say git-reset --soft, if i understand darcs' manpage correctly
14:46:22 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
14:46:28 <__nasa__> @type minimumBy (compare fst)
14:46:30 <lambdabot>     Couldn't match expected type `((a, b) -> a) -> Ordering'
14:46:31 <lambdabot>            against inferred type `Ordering'
14:46:48 <idnar> @tpye minimumBy (compare . fst)
14:46:49 <lambdabot> Maybe you meant: time type
14:46:55 <idnar> @type minimumBy (compare . fst)
14:46:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
14:46:57 <lambdabot>       Expected type: (a, b) -> (a, b) -> Ordering
14:47:12 <Liskni_si> (but it's not going to unrecord a patch in the middle of history)
14:47:27 <EvilTerran> @type minimumBy (comparing fst)
14:47:29 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
14:48:03 <__nasa__> so what _is_  comparing?
14:48:11 <__nasa__> @hoogle comparing
14:48:12 <lambdabot> No matches found
14:48:54 <SamB> wli: apparantly I wanted "git reset --soft HEAD"
14:50:04 <__nasa__> > minimumBy (comparing fst) [(1,Nothing),(2,Just 'x'),(-1,Just 'v')]
14:50:06 <lambdabot>  (-1,Just 'v')
14:50:06 <SamB> apparantly I'm destined to be sad almost whenever I use something that isn't basically darcs or svn ...
14:50:51 <__nasa__> is comparing in a module?
14:52:14 <Liskni_si> @type minimumBy ((\f -> ((.f).compare.f)) fst)
14:52:15 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
14:53:02 <__nasa__> perfect!
14:53:45 <Saizan> ?index comparing
14:53:46 <lambdabot> bzzt
14:53:54 <Saizan> ?type Data.Ord.comparing
14:53:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:54:09 <pjd> comparing p x y = compare (p x) (p y)
14:54:43 <idnar> @src comparing
14:54:43 <lambdabot> Source not found. You speak an infinite deal of nothing
14:54:44 <__nasa__> Saizan: Is there a way to find the module something is in with lambdabot?
14:54:48 <idnar> heh
14:54:55 <__nasa__> :-)
14:55:04 <Saizan> __nasa__: the command is @index but it doesn't always work
14:55:11 <__nasa__> ah
14:55:20 <Saizan> or hoogle
14:55:27 <Saizan> @hoogle comparing
14:55:28 <lambdabot> No matches found
14:55:32 <__nasa__> yeah, but comparing wasnt in hoogle
14:55:33 <__nasa__> yeah
14:55:44 <dcoutts> ivant: no limit as far as I know. Are you remembering to stroke the line?
14:55:55 <Saizan> i think lambdabot uses the same database for hoogle and index..
14:56:06 <__nasa__> mmm,
14:56:17 <__nasa__> well now it works.
14:56:19 <dolio> @index comparing
14:56:19 <lambdabot> bzzt
14:58:51 <__nasa__> another problem I have been having:
14:58:54 <TSC> comparing is in Data.Ord
14:59:32 <TSC> I should read the context first (:
14:59:33 <__nasa__> move [(Electron Pos Vect):es] = -- fails pattern matching
14:59:56 <__nasa__>  Couldn't match expected type `Electron' against inferred type `[a]'
15:00:34 <Saizan> [(Electron Pos Vect):es] matches a list of one element which is itself a list with an (Electron Pos Vect) as head
15:00:50 <__nasa__> doh
15:00:56 <__nasa__> wrong parens...
15:01:01 <__nasa__> thanks!
15:01:01 <Saizan> exactly
15:01:15 <TSC> You wouldn't be the first person to do that
15:01:19 <__nasa__> :-)
15:01:41 <shapr> Or the last.
15:01:56 <Saizan> many would have done [Electron Pos Vect]
15:08:25 <conal> have the rules changed about forall types in ghc 6.7 (HEAD) in the last few weeks?
15:12:28 <ivant> dcoutts, I call the stroke. I draw a very long polyline (moveTo and lots of lineTo's) and then do the stroke. The number of segments is thousands
15:12:56 <dcoutts> ivant: well, it's not impossible I suppose, have you tried a smaller number of segments?
15:13:03 <ivant> dcoutts, when I have the number of segments <= 20809, everything is fine
15:13:09 <dcoutts> ah ok
15:13:19 <dcoutts> looks like a limitation, report a cairo bug
15:13:22 <ivant> dcoutts, when it is 20810 or greater, I get Fatal IO error
15:17:35 <MyCatVerbs> ivant: movetos and linetos, are you sure that's Cairo? It sounds like postscript.
15:20:11 <ivant> MyCatVerbs, graphical primitives are all the same :-)
15:20:44 <MyCatVerbs> ivant: bullshit, you'll never display GTK+2 applications on a laserjet. ;)
15:21:16 <ivant> MyCatVerbs, I can imagine how to do that :-)
15:21:58 <MyCatVerbs> ivant: but the framerate would suck! Not to mention the amount of paper you'd waste due to things like push-button events.
15:23:25 <SamB> ivant: how would you click?
15:24:28 <MyCatVerbs> SamB: hold up a ruler to the sheet of paper and type the position you want the button press to be registed at into a terminal.
15:25:43 <augustss> Wow, sigfpe's new blog post makes my head hurt.
15:28:42 <aFlag> hm, I can't figure out how to define my own String instance of Arbitrary, using -fallow-overlapping-instances doesn't seem to solve it
15:29:07 <mrd> make a newtype
15:29:07 <aFlag> I want certain strings to have more priority than others
15:29:07 <aFlag> but if I make a newtype
15:29:10 <aFlag> I'll have to change my functions
15:29:13 <aFlag> won't I?
15:29:17 <mrd> use wrappers
15:29:37 <ivant> SamB, we were talking only about displaying :-)
15:29:40 <mrd> prop_foo (MyString s) = something s
15:29:49 <aFlag> hm
15:38:03 <Modius> Is there a Haskell function that splits a list down into sublists based on some predicate?
15:39:06 <dolio> @type partition
15:39:08 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:39:31 <dolio> > partition (>5) [1, 10, 6, 2, 3, 5, 8, 11, 4]
15:39:33 <lambdabot>  ([10,6,8,11],[1,2,3,5,4])
15:39:36 <Modius> I was after -> [[a]]
15:40:43 <Toxaris> Modius: how to split in multiple sublists using a single predicate?
15:40:51 <Modius> Yes
15:41:08 <Modius> Where each true dictates a split point (or something similar)
15:41:42 <LoganCapaldo> unfoldr of break
15:41:42 <Lemmih> @type groupBy
15:41:42 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:41:49 <LoganCapaldo> or um yeah groupby
15:43:41 <Toxaris> > groupBy (const (/= 3)) [1, 1, 1, 3, 1, 1, 1, 3, 1]
15:43:43 <lambdabot>  [[1,1,1],[3,1,1,1],[3,1]]
15:47:57 <SamB> wli: man, git is wierd...
15:49:05 <SamB> it doesn't have a simple model like darcs and svn do :-(
15:49:35 <wli> SamB: It is; I find it unusable.
15:49:44 <SamB> wli: I tend to agree
15:49:54 <LoganCapaldo> darcs has a simple model? I thought there was supposed to be some "theory of patches" thing or something
15:50:02 <SamB> I want to send linus an email asking how it is possible to use it
15:50:17 <SamB> LoganCapaldo: try using git and tell me darcs ain't simple at heart after you do
15:50:32 <LoganCapaldo> heh
15:50:39 <LoganCapaldo> I was just wondering
15:50:44 <SamB> the theory of patches is nice
15:51:11 <SamB> it might have some tricky parts, and bad performance characteristics (which it does)
15:51:13 <LoganCapaldo> darcs never actually struck me as complicated, but it seemed like there was supposed to be some sort of attempt to rigorously formalize revision control
15:51:37 <SamB> also it has a nice UI and a nice set of commands that let you deal with mistakes
15:51:57 <SamB> and "darcs send" isn't hard to get right
15:52:01 <idnar> LoganCapaldo: a repository is a partially ordered set of patches
15:52:14 <idnar> LoganCapaldo: that's about all there is to it, in terms of using it
15:52:30 <LoganCapaldo> mmm hmm
15:52:59 <idnar> you don't really need to understand anything about the theory of patches to use it
15:53:19 <LoganCapaldo> I got hooked on mercurial a while ago, although lately the only scm I've had contact with is perforce
15:53:32 <SamB> svn has a fairly simple two-layer model, too
15:53:45 <LoganCapaldo> idnar, I'm pretty sure I didn't have to know another about the theory of patches to use darcs :)
15:53:52 <SamB> hard to describe but easy to understand and use ;-)
15:53:55 <LoganCapaldo> s/another/anything/
15:54:31 <LoganCapaldo> Just like I don't have to know anything about spineless tagless g-machines or whatever to use ghc
15:54:51 <LoganCapaldo> doesn't mean it's not complicated
15:55:00 <LoganCapaldo> doesn't mean it is either of course
15:55:12 <SamB> LoganCapaldo: well, it's simple to see how you can use it
15:55:16 <LoganCapaldo> but theory of patches sounded complicated to me right off the bat :)
15:55:55 <LoganCapaldo> the term I mean
15:56:01 <SamB> ooh
15:56:02 <SamB> http://www.survey.net.nz/survey.php?94e135ff41e871a1ea5bcda3ee1856d9
15:56:07 <lambdabot> Title: Git User's Survey 2007, http://tinyurl.com/26774s
15:57:35 <shapr> I've been doing paid work with darcs for years, I like it.
15:59:10 <idnar> I think the first time I actually looked at any Haskell code, was when I started using darcs
15:59:33 <idnar> and I vaguely liked what I saw, although I didn't get around to actually checking Haskell out properly until just recently
16:01:19 <SamB> with me it was the reverse
16:01:37 <idnar> I definitely liked darcs right off the bat
16:01:44 <wli> darcs wasn't even started on when I started using Haskell.
16:02:38 <SamB> well, actually it was a while after I started with Haskell that I really got introduced to darcs...
16:05:27 <aFlag> SamB, what do you mean by simple model?
16:07:29 <aFlag> I like that branching system on git
16:09:51 <wli> git's kind of just hacked together like everything else besides (maybe) darcs.
16:13:00 <SamB> svn at least they got something fairly nice out of the process...
16:13:21 <SamB> I mean it's also fairly nasty, but it is still pretty usable
16:13:31 <MyCatVerbs> wli: huh? Git seems to have had a lot of hard thought into the process, particularly in making it fast.
16:13:44 <MyCatVerbs> wli: and, Hell, fine-grained.
16:13:54 <SamB> MyCatVerbs: my thinking is those might be the only things they thought about
16:14:27 <wli> MyCatVerbs: I'm not impressed with the methods it uses for that, either.
16:14:36 <SamB> and if they really wanted it fine-grained they'd have something like "darcs record"
16:14:49 <MyCatVerbs> wli: heehee.
16:15:34 <augustss> darcs has some features that I find it hard to live without.  but it also has some bugs that are a royal pain
16:15:51 <SamB> augustss: which kind of bugs/
16:16:20 <augustss> Like just consuming CPU for hours with nothing happening
16:16:36 <SamB> oh
16:16:41 <shapr> git came out of Linus trying darcs, yeah?
16:16:50 <SamB> shapr: I have no idea...
16:16:53 <augustss> And as soon as you get conflicts things start to get dodgy
16:16:54 <wli> Bugs in the theory of patches?
16:16:57 <shapr> I'm pretty sure that's how git started.
16:17:04 <Botje> git came out of linus being fed up with bitkeeper
16:17:09 <shapr> wli: recursive merges
16:17:13 <augustss> wli: I don't know where the bugs are
16:17:17 <shapr> Botje: Yeah, but Linus tried darcs among other things.
16:17:21 <Botje> yeah
16:17:31 <Botje> also, git 1.5 has an --interactive switch
16:17:44 <wli> It's been suggested that the theory of patches is flawed, leading to the CPU burn.
16:17:44 <Pseudonym> I can only imagine how badly darcs would scale with the linux kernel.
16:17:46 <shapr> If darcs had handled very large repos well... might be the vc of Linux.
16:17:54 <SamB> Pseudonym: horribly
16:18:07 <shapr> wli: I thought it was just the recursive merge problem?
16:18:12 <MyCatVerbs> shapr: VC?
16:18:15 <wli> Pseudonym: I've tried it. The box didn't stay up long enough to finish the initial import.
16:18:16 <shapr> version control
16:18:32 <SamB> Botje: and the "free" bitkeeper for open-source projects got it's license revoked...
16:18:33 <Pseudonym> Yeah, I'm not surprised.
16:18:54 <augustss> I've tried keeping local patches for ghc while pulling in HEAD.  after a while I just give up, and use diif&patch on a fresh repo
16:19:10 <SamB> wli: something like that, yeah...
16:19:21 <Pseudonym> It's tempting to blame Tridge, but the fact is, this is the problem with relying on software that you don't control.
16:19:25 <Pseudonym> You are at someone else's whim./
16:19:32 <Pseudonym> And that goes double if they're giving you a special deal.
16:19:39 <Pseudonym> "Pray I don't change it further."
16:20:09 <SamB> Pseudonym: I blame BitKeeper and/or Linus
16:20:19 <Pseudonym> I actually don't blame Linus.
16:20:32 <Pseudonym> At the time he chose bitkeeper, he didn't have a lot of options.
16:20:38 <SamB> okay, true
16:20:42 <SamB> So BitKeeper it is then
16:20:52 <Pseudonym> And he didn't do anything about it until it broke.
16:20:56 <Pseudonym> If it ain't broke, and all that.
16:21:29 <Pseudonym> A lot of the open source SCC systems arose precisely because Linus used bitkeeper.
16:22:38 <SamB> hmm?
16:22:45 <SamB> what were their goals?
16:22:51 <SamB> to entice him away?
16:22:59 <Pseudonym> No, it highlighted the need.
16:23:06 <SamB> ah.
16:23:07 <Pseudonym> Small OSS projects can cope with CVS.
16:23:14 <Pseudonym> Despite its limitations.
16:23:26 <Pseudonym> Big, highly-distributed projects can't.
16:23:30 <Pseudonym> And there weren't a lot of those.
16:23:57 <SamB> are there really any besides Linux?
16:24:08 <Pseudonym> Well there are big projects.
16:24:14 <Pseudonym> The Neo-BSDs and Mozilla, for example.
16:24:18 <SamB> yeah
16:24:21 <Pseudonym> They easily compete with Linux on line count.
16:24:26 <Pseudonym> But they aren't distributed.
16:24:32 <Pseudonym> They tend to have central repositories.
16:24:35 <SamB> yes.
16:25:09 <Pseudonym> So yeah, there weren't really any.  Partly because there COULDN'T be any.
16:25:30 <Pseudonym> Nobody really thought about decentralised repositories.
16:26:03 <SamB> I hope the next David Roundy comes around soon...
16:26:10 <__nasa__> X?
16:26:25 <Pseudonym> X wasn't decentralised eitehr.
16:26:34 <Pseudonym> Is it now?
16:26:41 <Pseudonym> Forks don't count. :-)
16:26:41 <SamB> it does use git...
16:26:49 <Pseudonym> You mean X.org?
16:26:50 <__nasa__> yaeh
16:26:51 <SamB> and Xorg is not a *real* fork
16:27:02 <Pseudonym> See, at the time, Xorg wasn't really there.
16:27:14 <Pseudonym> And IIRC, XFree86 was centralised.
16:27:22 <__nasa__> Yeah, I think so.
16:27:37 <SamB> Xorg is just what happened when XFree86 committed suicide
16:27:41 <Pseudonym> To be honest, I only ever interacted with the XFree guys once.
16:27:42 <__nasa__> Since they could control the distribution...
16:27:52 <Pseudonym> Xorg : XFree86 :: EGCS : Old GCC
16:28:02 <SamB> Pseudonym: no!
16:28:21 <shapr> ghc uses darcs successfully...
16:28:24 <SamB> this wasn't forked to make it better
16:28:32 <SamB> this was forked to keep the license
16:28:40 <Pseudonym> That counts as "better".
16:28:41 <shapr> I wonder how distributed ghc dev is?
16:28:50 <SamB> it's not a technical-reasons fork
16:28:57 <allbery_b> but arguably the old GCC folks had committed suicide
16:28:59 <Pseudonym> shapr: I suspect that there aren't many private forks of GHC.
16:29:11 <Pseudonym> And of those that do exist, almost none merge upstream.
16:29:13 <SamB> and it will never be called XFree86 again
16:29:15 <Nafai> Are there any GHC devs that hang out here?
16:29:24 <ari> ... I forgot how to do multiline comments in Haskell :(
16:29:27 <SamB> unlike EGCS
16:29:30 <__nasa__> {--}
16:29:31 <LoganCapaldo> {-
16:29:32 <Pseudonym> ari: {- -}
16:29:34 <ari> Thanks
16:29:45 <olsner> (stereo)
16:29:46 <Pseudonym> Has anyone used arch?
16:29:52 <SamB> @quote eat
16:29:53 <lambdabot> Cale says: Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
16:29:55 <SamB> @quote eat
16:29:55 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
16:29:57 <Pseudonym> Just curious if it's any good.
16:29:59 <ddarius> __nasa__: I don't think {--} would parse as a comment.
16:30:01 <SamB> @quote {-
16:30:01 <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"Invalid preceding regular expression")
16:30:03 <shapr> Pseudonym: I do wish GHC forks merged upstream.
16:30:06 <SamB> @quote \{-
16:30:07 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
16:30:16 <shapr> augustss: Isn't Bluespec roughly a GHC fork?
16:30:20 <SamB> oh, is that what that was.
16:30:31 <Pseudonym> Linux, though, is distributed by design.
16:30:32 <augustss> shapr: not at all
16:30:38 <SamB> Pseudonym: I didn't like arch much
16:30:41 <ddarius> Pseudonym: From what I here, it works but is relatively complicated to work with.
16:30:42 <Pseudonym> What we call "the Linux kernel" is actually Linus' tree.
16:30:45 <__nasa__> Yeah, you might be right, ddarius. It is interpreted in the context as {- Comment here -}.
16:30:48 <shapr> augustss: Oh, I heard that somewhere, never mind then.
16:30:48 <SamB> but now that I've tried git I might consider changing my mind
16:30:48 <ddarius> s/here/hear
16:30:49 <augustss> shapr: Bluespec was written from scratch
16:30:53 <shapr> Ah, I see.
16:30:54 <Pseudonym> Or whoever the patch manager for the release is.
16:30:57 <__nasa__> > {--} 4
16:30:59 <lambdabot>  4
16:31:03 <MyCatVerbs> SamB: Arch?
16:31:11 <SamB> MyCatVerbs: yeah.
16:31:12 <Pseudonym> Right.
16:31:12 <shapr> __nasa__: That looks like a bug.
16:31:17 <shapr> Oh, I see.
16:31:32 <Pseudonym> Actually, what would be nice is if svk functionality were built into svn.  And actually worked nicely.
16:31:40 <MyCatVerbs> SamB: ? I know of a distro called "Arch Linux", but are you referring to something else?
16:31:41 <__nasa__> That would be nice...
16:32:00 <Nafai> MyCatVerbs: There's a distributed version control system called arch
16:32:13 <Japsu> I just discovered git-svn, which would seem to be a svn client built into git that can check out svn repositories as local git repositories
16:32:28 <Pseudonym> Yes, arch is GNU's answer to bitkeeper.
16:32:34 <MyCatVerbs> Ah.
16:32:43 <Japsu> allowing you to work with svn repositories in the distributed fashion of git
16:32:44 <Pseudonym> Designed to be based along egalitarian principles.
16:32:45 <ddarius> tla
16:32:52 <Japsu> Sounds to me like a perfect replacement for svk.
16:32:53 <shapr> Nafai: arch is all about carpal tunnel syndrome, imho.
16:32:54 <Pseudonym> I suspect it's more politics than code.
16:33:02 <Pseudonym> Oh, nice!
16:33:07 * Pseudonym must try that
16:33:09 <LoganCapaldo> the arch website is updated _all the time_
16:33:13 <Nafai> shapr: Yeah, I didn't like its interface much
16:33:14 <LoganCapaldo> "It is somewhat well known, these days, that some of the core developers of the Linux kernel are using a revision control system which is not free software. There is a need to create a free software alternative to that system and to do so is one of the goals of the arch project"
16:33:19 <SamB> Japsu: that would be great if it were actually possible to use git :-(
16:33:22 <lloron> hello people the spanish speak please
16:33:23 <lloron> :)
16:33:28 <Japsu> SamB: well why isn't it?
16:33:34 <Pseudonym> shapr: Yeah, I think that checking out an arch repository requires writing an egalitarian manifesto.
16:33:36 <shapr> lloron: No hablo espanol, #haskell.es ?
16:33:38 <Nafai> I believe bzr is loosely based on arch ideas
16:33:39 <shapr> habla*
16:33:40 <shapr> eesh
16:33:43 <SamB> Japsu: if I knew that I might be able to use it!
16:33:47 <Japsu> wtf
16:34:01 <lloron> thanks
16:34:04 <shapr> ei puhun suomea, #haskell.fi
16:34:06 <SamB> Nafai: but I've heard it doesn't suck so much...
16:34:06 * shapr grins
16:34:09 <Japsu> shapr: ;D
16:34:09 <Pseudonym> Not that I disagree with egalitarianism, encessarily.
16:34:27 <Japsu> #haskell.fi doesn't seem very active :)
16:34:38 * ddarius disagrees with egalitarianism.
16:34:45 <Nafai> SamB: Yeah, the "user interface" if you will is much better
16:34:50 <Japsu> there's #lisp.fi in ircnet that has many haskell people, too
16:34:51 * Pseudonym is a meritocrat
16:34:51 <shapr> na tavla lojbo, #haskell.jbo
16:35:05 <SamB> Nafai: that's a very important aspect
16:35:24 <Nafai> Yeah
16:35:29 <MyCatVerbs> Bugger meritocracies
16:35:39 <shapr> Japsu: I didn't know that.
16:35:44 <__nasa__> Does the "Haskell is #13 on IRC" include foreign translations?
16:35:51 <shapr> __nasa__: nope
16:35:52 <ddarius> No it doesn't.
16:36:02 <shapr> Specifically #haskell is the 13th largest channel on freenode.
16:36:10 <MyCatVerbs> I, personally, believe in one and only one form of government: that in which the political power is given exclusively to cats, and the peace maintained by giving all of our nuclear weapons to goldfish.
16:36:15 <ddarius> There are many satellite channels of #haskell.
16:36:28 * wli doesn't believe anything can produce a desirable result.
16:36:51 <shapr> wli: What about alcohol?
16:37:03 <Japsu> nnnGh tlhIngan Hol, #haskell.tlh
16:37:04 <MyCatVerbs> See, that way, there'll still *be* nuclear weapons, but the goldfish won't actually ever *use* them (hence preventing any risk of nuclear war actually happening) because they're always too busy boinking other goldfish to work out how to push the big red buttons.
16:37:07 <shapr> MyCatVerbs: Whoa, I'll sign the charter!
16:37:11 <shapr> Japsu: bwahaha!
16:37:24 <Japsu> :)
16:37:34 <MyCatVerbs> shapr: heehee, also, kitties are sensible. Kitties understand the neccessities of life.
16:37:34 <wli> shapr: Not in the same category as meritocracy, plutocracy, egalitarianism, etc.
16:37:39 <oerjan> this allows parsec to prune many branches for efficiency, i believe
16:37:40 <shapr> Japsu: Man, I thought my lojban Haskell channel was cool, but you totally win with KLINGON!
16:37:50 <oerjan> wrong channel :(
16:37:54 <Japsu> note that "nnnGh" is completely made up
16:37:56 <Japsu> ;D
16:38:09 <shapr> Japsu: Did you know that there are Klingon error messages in the GHC sources?
16:38:14 <Japsu> nope ;D
16:38:14 <oerjan> (strangely enough :) )
16:38:14 <__nasa__> Wow!
16:38:27 <shapr> Of course, I won't tell you where.. that would be too easy.
16:38:31 <Japsu> ;D
16:38:59 <Japsu> meeeeoow purr? #haskell.meow
16:39:02 * shapr grins
16:39:38 <Pseudonym> MyCatVerbs: The problem with a felistocracy is that the army will turn up at your doorstep at 6pm every night, on the dot, demanding Iams.
16:40:06 <MyCatVerbs> Pseudonym: I fail to see how this would be a drawback.
16:40:17 <Pseudonym> Think daylight savings.
16:40:21 <shapr> Pseudonym: Actually, I think they'd just hover their evil little paws over the BIG RED BUTTON demaning iams be brought to them!
16:40:33 <MyCatVerbs> shapr: no, no, no, you forgot something there.
16:40:50 <MyCatVerbs> shapr: I already plan to give the nuclear buttons and all attached red buttons to goldfish, remember?
16:40:55 <Pseudonym> There would also be a mandatory year of national service, mostly involving the cleaning of litter trays.
16:40:59 <MyCatVerbs> s/nuclear buttons/nuclear warheads/
16:41:01 <shapr> MyCatVerbs: oh right
16:41:39 <__nasa__> At least the government would sleep most of the day, so it would be a remarkably free society.
16:41:50 <Mr_Awesome> Lemmih: apparently the version on the fudgets website is not the most recent. i found one that works on the creators website
16:41:53 <MyCatVerbs> Pseudonym: this is massively outweighed - by several orders of magnitude - by the massive subsidies that would become available for industries important to our civilisation. Such as dairy production.
16:41:55 <Japsu> launchMissiles :: IO () -- with serious international side-effects
16:41:57 <shapr> Lazy-Faire, they call that, right?
16:42:13 <MyCatVerbs> __nasa__: precisely! Cats are too busy to tie people up in paperwork.
16:42:33 <MyCatVerbs> In fact, if you put a bored and energetic cat in the same room as a load of paper, it'll shred it.
16:42:40 <Pseudonym> The one problem I see with this is in environmental policy.
16:42:40 <shapr> hiya spacebark
16:42:48 <shapr> spacebark: Learning Haskell?
16:42:55 <__nasa__> Japsu: I remember reading that somewhere -- what is it from again?
16:43:02 <__nasa__> oh
16:43:06 <Pseudonym> In particular, the cat's policy on the preservation of rare birds would be to scatter feathers all over the yard.
16:43:06 <__nasa__> the STM paper
16:43:07 <__nasa__> yeah
16:43:07 <Japsu> __nasa__: Some monad tutorial, can't remember which
16:43:10 <Japsu> Oh, that
16:43:12 <Japsu> yeah
16:43:15 <Japsu> exactly
16:43:29 <MyCatVerbs> _Precisely_ the opposite of the bureaucratic encroachment which helped topple the old Soviet Bloc countries. I cannot possibly imagine a set of circumstances under which this wouldn't work.
16:43:52 <shapr> @seen dons
16:43:52 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 1d 19h 41m 38s ago.
16:44:00 <shapr> Dons should be in the USA NOW!
16:44:09 <MyCatVerbs> shapr: more'n that.
16:44:17 <shapr> oh?
16:44:18 <MyCatVerbs> shapr: by rights, Dons should be omniscient and omnipresent by now.
16:44:22 <shapr> True that.
16:44:35 <Pseudonym> OK, how do you protect the goldfish from the cats?
16:44:50 <shapr> Speaking of dons, has anyone used Data.Binary to read an image file format?
16:44:52 <twanvl> Are you saying that in the soviet union the goldfish had political power while the cats had red buttons?
16:44:55 <Lemmih> Is he attending a conference in the US?
16:45:02 <shapr> Lemmih: Nah, galois hired him.
16:45:03 <sorear> shapr: I've heard of JPEG code
16:45:03 <MyCatVerbs> Pseudonym: also a trivial nonissue. Goldfish are underwater.
16:45:15 * Pseudonym is certain there's a Russian reversal joke in there somewhere
16:45:16 <shapr> Lemmih: Thanks for the cookie patches btw :-)
16:45:18 <MyCatVerbs> Pseudonym: cats don't like getting their paws wet, as the adage will tell you.
16:45:32 <sorear> How will you stop cats from inventing scuba gear?
16:45:37 <__nasa__> shapr: no, but I have plans.
16:45:46 <Pseudonym> MyCatVerbs: I had a cat who regularly got into the shower with me.
16:45:46 <shapr> Actually, there is a scuba cat, I think.
16:45:48 <shapr> Scuba dog too.
16:45:52 <MyCatVerbs> sorear: they would never wear it even if they had it - it'd be too uncomfortable.
16:46:10 <Lemmih> shapr: Holy crap. Has he relocated or is he just visiting?
16:46:14 <Pseudonym> And besides, you're assuming that the cats don't accidentally fall in, no doubt followed by a "I meant to do that" face.
16:46:19 <shapr> http://www.metacafe.com/watch/31059/scuba_kitty/
16:46:20 <MyCatVerbs> Pseudonym: blimey.
16:46:21 <lambdabot> Title: Scuba Kitty Video
16:46:28 <shapr> Lemmih: relocate
16:46:39 <MyCatVerbs> Pseudonym: heh, so they've already mastered international diplomacy, ;)
16:46:39 <dons> ?yow!
16:46:39 <lambdabot> I know th'MAMBO!!  I have a TWO-TONE CHEMISTRY SET!!
16:46:47 <shapr> DONS!
16:46:49 * dons waves from Oregon :)
16:46:52 <MyCatVerbs> dons!
16:46:53 * shapr CHEERS!
16:46:55 <Lemmih> shapr: Can't imagine his girlfriend is too happy about that.
16:47:02 <shapr> Lemmih: Dunno, ask him :-)
16:47:05 <wli> re dons
16:47:05 <dons> its hot here!
16:47:11 <dons> heya wli
16:47:13 <Pseudonym> Oh, so... hang on... if you're in Oregon... where's lambdabot?!
16:47:16 <Pseudonym> Unattended?
16:47:22 <wli> dons: I've not dared to leave the comfort of A/C all day.
16:47:23 <shapr> Portland is niftier than Seattle used to be, so I bet it's not that bad.
16:47:32 <dons> lambdabot's playing up while the cat's away
16:47:32 <lambdabot> Haha, suckers!
16:47:38 <__nasa__> > printStrLn "Here"
16:47:40 <lambdabot>   Not in scope: `printStrLn'
16:47:48 <SamB> dons: why are you still @*.unsw.edu.au?
16:47:49 <TSC> putStrLn ?
16:47:56 <dons> just got to get net setup in the apartment -- currently sitting in starbucks for net ;)
16:47:58 <__nasa__> yeah
16:48:00 <__nasa__> whoops
16:48:05 <SamB> dons: ah
16:48:06 <dons> SamB: yeah, for a while
16:48:09 <dibblego> dons, trying to escape the impending riots? :)
16:48:09 <SamB> that explains that
16:48:10 <MyCatVerbs> > mapM_ putStrLn ["foo","bar","baz"]
16:48:11 <dons> will be dons@galois.com in a few days
16:48:12 <lambdabot>  <IO ()>
16:48:16 <dons> dibblego: hehe
16:48:21 <dons> i even saw them on CNN, dibblego
16:48:31 <dibblego> dons, what are you doing at Galois
16:48:37 <SamB> dons: won't it be dons@dons'-machine.galois.com ?
16:48:40 <dons> working there on secret haskell haxoring :)
16:48:44 <shapr> yay haxoring!
16:48:44 <dibblego> dons, nice :)
16:48:46 <MyCatVerbs> Wait, where does lambdabot's stdout go when someone tells it to putStrLn...?
16:48:55 <SamB> dons: wait, secret?
16:49:00 <allbery_b> nowhere
16:49:00 <__nasa__> > putStrLn "Hello Test..."
16:49:02 <dons> MyCatVerbs: its intercetped, and redirected to a call to print "<IO>"
16:49:02 <lambdabot>  <IO ()>
16:49:05 <lambdabot> MyCatVerbs: Unfortunately, the answer isn't rated "G".
16:49:09 <SamB> I knew there had to be a downside to this whole "job" business!
16:49:19 <MyCatVerbs> dons: ah, sane.
16:49:23 <dons> anyone have a comcast cable/internet package, btw?
16:49:29 * dons tries to work out why it doesn't like dhcp
16:49:31 <SamB> dons: what?
16:49:36 <SamB> dons: you lie
16:49:40 <shapr> dons: comcast has a quote last I heard
16:49:44 <shapr> er, max quota
16:49:50 <SamB> dons: it just doesn't have code to run IO programs...
16:50:10 <dons> well, cable tv works, but the ethernet doesn't seem to want to dhcp, and i've no docs for it. hmm
16:50:22 <SamB> and instead has a Show (IO a) instance that prints <IO a>
16:50:38 <shapr> dons: My brother is using a standard dhcp client on ubuntu with comcast.
16:50:38 <dons> SamB: ah yes, that's it. the Show instance is provided which 'redirects'
16:50:45 <shapr> dons: But that's southeast USA.
16:50:45 <SamB> dons: didn't the guys come over to install it?
16:50:46 <dons> shapr: hmm, ok. intereesting.
16:50:47 <__nasa__> > lauchMissles -- lets hope it doesn't work...
16:50:48 <lambdabot>   Not in scope: `lauchMissles'
16:50:59 <dons> SamB: already set up when i arrived.
16:51:07 <SamB> dons: darn!
16:51:17 <mrd> dons: i use comcast internet with a normal router
16:51:23 <Pseudonym> __nasa__: I think you have to send a request to the goldfish.
16:51:29 <SamB> dons: call 'em on the phone and ask about the settings
16:51:33 <dons> mrd, and just dhcp to get an ip?
16:51:38 <dons> SamB: yeah, i'll do that.
16:51:46 <dons> stupid phone. so 1890s!
16:51:46 <mrd> you may need to input a username/password
16:51:49 <__nasa__> Pseudonym: either that or spell correctly ;-)
16:51:54 <dons> mrd, for dhcp?
16:52:00 <mrd> for access to cable
16:52:00 <SamB> when RCN came to set us up I asked if it worked like at college, they said yeah
16:52:01 <MyCatVerbs> __nasa__: EAPATHETICFISH
16:52:21 <dons> ok. gotta go. see you guys later. things to do!
16:52:23 <shapr> cya!
16:52:27 <dibblego> seeya!
16:52:28 <__nasa__> bye!
16:52:29 * dons wanders out into the hot heat
16:52:30 <Pseudonym> Splitter!
16:52:55 <MyCatVerbs> > getCurrentDirectory
16:52:57 <lambdabot>   Not in scope: `getCurrentDirectory'
16:52:58 <mrd> it appears I just have DHCP on mine, but I've seen other setups requiring user/pass
16:52:59 <MyCatVerbs> dons: have fun!
16:53:13 <dibblego> how do you pronounce galois?
16:53:21 <Pseudonym> Gal --- wah
16:53:22 <__nasa__> gal - wah
16:53:23 <__nasa__> yeah
16:53:23 <mrd> waaah
16:53:24 <olsner> could be PPPoE if it doesn't DHCP
16:53:42 <Pseudonym> Like all good French words, you basically only pronounce half the word.
16:53:50 <dibblego> that's what I thought
16:54:03 <__nasa__> is lambdabot == lambdabot2 (in haskell.es and haskell.fr and ...)?
16:54:39 <phobes> It's more than just not pronouncing part of it... you have to come up with 'wah' from 'ois'
16:55:00 <__nasa__> phobes: try jouaient...
16:55:19 <TSC> easy, joo-ay
16:55:31 <ari> > (1 + (1/0)) == (1/0)
16:55:33 <lambdabot>  True
16:55:44 <Pseudonym> > 1/0
16:55:45 <lambdabot>  Infinity
16:55:54 <ddarius> __nasa__: Same code, different instances, presumably different state.
16:56:10 <Pseudonym> > 1/0 - 1/0 == 1/0 - 1/0
16:56:11 <lambdabot>  True
16:56:13 <ddarius> __nasa__: lambdabot is on too many channels.
16:56:15 <Pseudonym> Woah.
16:56:18 <__nasa__> ah
16:56:20 <Pseudonym> Now that's jsut wrong.
16:56:23 <Pseudonym> > 1/0 - 1/0
16:56:24 <lambdabot>  0.0
16:56:28 <Pseudonym> Damn!
16:56:32 <Pseudonym> That's supposed to be NaN.
16:56:52 <mrd> my ghc head says NaN
16:57:17 <ari> So does ghci 6.6
16:57:18 <TSC> ghci-6.6.1 says NaN
16:57:20 <oerjan> > 0/0 - 0/0
16:57:20 <EvilTerran> english has its fair share of weird and arcane pronunciations...
16:57:22 <lambdabot>  0.0
16:57:28 <Pseudonym> What version is lambdabot running?
16:57:31 <mrd> ?version
16:57:32 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
16:57:32 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:57:34 <Pseudonym> Maybe it's some weird defaulting going on.
16:57:52 <EvilTerran> we've got a Milngavie in Glasgow. you'd never guess how to pronounce that if you didn't know...
16:57:55 <oerjan> > case undefined of x -> x-x :: Double
16:57:57 <lambdabot>  Undefined
16:58:00 <olsner> :t  1/0 - 1/0
16:58:02 <lambdabot> forall t. (Fractional t) => t
16:58:17 <mrd> > 1/0 - 1/0 :: Float
16:58:19 <lambdabot>  0.0
16:58:44 <MyCatVerbs> ...that should say NaN, surely.
16:58:50 <ari> > 2/0 - 1/0
16:58:51 <lambdabot>  NaN
16:58:58 <Pseudonym> ...
16:59:00 <mrd> super crazy optimization?
16:59:01 <MyCatVerbs> Huh.
16:59:03 <sioraiocht> is there a way to co-recursively define the list of primes?
16:59:05 <Pseudonym> > 1/0 - 1/0 :: Double
16:59:06 <lambdabot>  0.0
16:59:15 <MyCatVerbs> Perhaps it's an artifact of common subexpression elimination?
16:59:23 <Pseudonym> > (2-1)/0 - 1/0 :: Double
16:59:24 <lambdabot>  0.0
16:59:36 <oerjan> > nubBy ((>1).gcd) [2..]
16:59:37 <lambdabot>  Couldn't match expected type `a -> Bool'
16:59:38 <TSC> > 2/0 - 2/0 :: Double
16:59:39 <lambdabot>  0.0
16:59:50 <jbauman> > 1/0 - (1/0 :: Double)
16:59:51 <lambdabot>  0.0
16:59:54 <mrd> it's -O3
16:59:57 <oerjan> darn
16:59:58 <MyCatVerbs> oerjan: (((>1).).gcd)
17:00:01 <mrd> -O3 does it
17:00:13 <oerjan> > nubBy (((>1).)gcd) [2..]
17:00:14 <lambdabot>  Couldn't match expected type `a -> Bool'
17:00:21 <oerjan> > nubBy (((>1).).gcd) [2..]
17:00:23 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:00:26 <mrd> actually -O1 is sufficient
17:00:26 <twanvl> ?check \x -> x/0 - x/0 == (0.0 :: Double)
17:00:27 <phobes> > Infinity - Infinity
17:00:28 <lambdabot>  Falsifiable, after 0 tests: 0.0
17:00:28 <lambdabot>   Not in scope: data constructor `Infinity'
17:00:38 <twanvl> ?check \x -> x /= 0 ==> x/0 - x/0 == (0.0 :: Double)
17:00:40 <lambdabot>  Falsifiable, after 0 tests: 0.5
17:00:59 <twanvl> > 0.5/0 - 0.5/0
17:01:01 <lambdabot>  0.0
17:01:03 <jbauman> > 0.0 / 0.0 - 0.0 / 0.0
17:01:04 <lambdabot>  0.0
17:01:11 <ddarius> EvilTerran: I don't believe that's a "native" English word.
17:01:12 <MyCatVerbs> ?check \_ -> True
17:01:13 <lambdabot>  Add a type signature
17:01:21 <MyCatVerbs> Heh.
17:01:22 <mrd> remember lambdabot compiles your @run code in a small file
17:01:24 <MyCatVerbs> ?check \_ :: Integer -> True
17:01:25 <lambdabot>  Parse error
17:01:32 <twanvl> ?check True
17:01:33 <lambdabot>  OK, passed 500 tests.
17:01:35 <MyCatVerbs> ?check \(_ :: Integer) -> True
17:01:35 <lambdabot>  Parse error in pattern
17:01:38 <ddarius> sioraiocht: Is there a way not to?
17:01:41 <MyCatVerbs> Ah, buggerit.
17:01:49 <ari> @check False
17:01:51 <lambdabot>  Falsifiable, after 0 tests:
17:01:59 <EvilTerran> ddarius, eh, i guess proper nouns might be considered cheating. it does make a nice shibboleth for Glaswegians, though.
17:01:59 <Pseudonym> ?check \x -> let y = x+1 in True
17:02:00 <lambdabot>  Add a type signature
17:02:06 <Pseudonym> ?check \x -> let y = (x::Integer)+1 in True
17:02:08 <lambdabot>  OK, passed 500 tests.
17:02:26 <Pseudonym> ?check \x -> let y = (x::Integer) in True
17:02:27 <lambdabot>  OK, passed 500 tests.
17:02:29 <Pseudonym> OK, there.
17:03:27 <ari> ?check \x -> let y = (x::Integer) in False
17:03:28 <lambdabot>  Falsifiable, after 0 tests: 1
17:03:32 * ari nods
17:03:34 <EvilTerran> oerjan, i don't think that counts as corecursive
17:03:41 <mrd> turning off CSE fixes the problem
17:04:19 <MyCatVerbs> ?check \x y z -> (\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)
17:04:20 <lambdabot>  Add a type signature
17:04:23 * EvilTerran was under the impression that in order for something to be corecursive, it had to (speaking informally) "produce" something every time it recursed
17:04:58 <phobes> > 1.0 / 0.0 - 2.0 / 0.0
17:04:59 <MyCatVerbs> ?check \x y z -> (((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)) :: (Integer -> Integer -> Bool) -> Bool)
17:05:00 <lambdabot>  Couldn't match expected type `(Integer -> Integer -> Bool) -> Bool'
17:05:00 <lambdabot>  NaN
17:06:09 <oerjan> EvilTerran: right.  so you need to make use of an upper bound to the next prime, or something
17:06:49 <EvilTerran> that'd work.
17:06:50 <oerjan> using product primesSoFar + 1 doesn't seem very efficient...
17:07:06 <EvilTerran> but it'd probably be easier to just prove the existing one correct
17:07:07 <MyCatVerbs> ?check \x y z -> (((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)) :: Integer -> Integer -> Integer -> Bool
17:07:08 <lambdabot>  Unbalanced parenthesis
17:07:11 <oerjan> unless you can cleverly avoid actually evaluating all of it
17:07:13 <MyCatVerbs> ...arse!
17:07:17 <MyCatVerbs> ?check \x y z -> ((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)) :: Integer -> Integer -> Integer -> Bool
17:07:18 <lambdabot>  Couldn't match expected type `Integer
17:07:55 <MyCatVerbs> ?check \x y z -> (((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd))) :: Integer -> Integer -> Integer -> Bool
17:07:56 <lambdabot>  Couldn't match expected type `Integer
17:08:07 <MyCatVerbs> ?check (\x y z -> (((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)))) :: Integer -> Integer -> Integer -> Bool
17:08:08 <lambdabot>  Exception: Prelude.gcd: gcd 0 0 is undefined
17:08:28 <MyCatVerbs> ...gah
17:08:58 <MyCatVerbs> ?check (\(x-1) (y-1) (z-1) -> (((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)))) :: Integer -> Integer -> Integer -> Bool
17:08:59 <lambdabot>  Parse error in pattern
17:09:13 <MyCatVerbs> Damn, can't use n-k patterns?
17:10:00 <MyCatVerbs> ?check (\x y z -> (\p q r -> (((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)))) (x+1) (y+1) (z+1)) :: Integer -> Integer -> Integer -> Bool
17:10:02 <lambdabot>  Exception: Prelude.gcd: gcd 0 0 is undefined
17:10:28 <MyCatVerbs> ?check (\x y z -> (\p q r -> (((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)))) ((abs x)+1) ((abs y)+1) ((abs z)+1)) :: Integer -> Integer -> Integer -> Bool
17:10:29 <lambdabot>  Exception: Prelude.gcd: gcd 0 0 is undefined
17:10:50 <MyCatVerbs> Erk!
17:11:43 <oerjan> > map (\y -> let (x+(-1)) = y in x) [3,2,1,0]
17:11:44 <lambdabot>  Parse error in pattern
17:12:02 <oerjan> not that either
17:12:11 <sorear> Anonymous fool disabled n+k for you
17:12:41 <oerjan> > map (\y -> let (x+1)) = y in x) [3,2,1]
17:12:42 <lambdabot>  Unbalanced parenthesis
17:12:47 <oerjan> > map (\y -> let (x+1)) = y in x [3,2,1]
17:12:48 <lambdabot>  Parse error
17:12:48 <MyCatVerbs> How come (abs x)+1 isn't eliminating all numbers under zero, I wonder?
17:12:58 <oerjan> > map (\y -> let (x+1) = y in x) [3,2,1]
17:12:59 <lambdabot>  Parse error in pattern
17:13:11 <oerjan> > map (\y -> let x+1 = y in x) [3,2,1]
17:13:12 <lambdabot>   Not in scope: `x'
17:13:35 <MyCatVerbs> ?check (\x y z -> (((\f -> if ((f x y)&&(f y z)) then (f x z) else (not (f x z))) (((>1).).gcd)))) :: Integer -> Integer -> Integer -> Bool
17:13:36 <lambdabot>  Falsifiable, after 0 tests: -2, -1, 0
17:13:54 <oerjan> i don't understand what is this problem with x+n patterns - someone mentioned injection attacks?
17:15:26 <MyCatVerbs> Ahhh, no wonder, silly me.
17:15:28 <MyCatVerbs> ?check (\x y z -> (\p q r -> (((\f -> if ((f p q)&&(f q r)) then (f p r) else (not (f p r))) (((>1).).gcd)))) ((abs x)+1) ((abs y)+1) ((abs z)+1)) :: Integer -> Integer -> Integer -> Bool
17:15:30 <lambdabot>  Falsifiable, after 5 tests: -2, 4, 2
17:16:07 <MyCatVerbs> I can't even remember what it is I was trying to test now.
17:18:16 <jbauman> gcd(3,5) == 1, but gcd(3,3) == 3
17:19:48 <sorear> jbauman: yes.
17:19:51 <jbauman> also, gcd(2,6) == 2 and gcd(6,3) == 3, but gcd(2,3) == 1
17:20:05 <jbauman> so it can be false in a variety of cases
17:20:20 <sorear> what are people asking about?
17:20:56 <jbauman> nothing, atm
17:21:10 <EvilTerran> record systems!
17:23:32 <olliej> hmmm, is it possible to use some form of monad-fu to simplify backtracking?
17:23:42 <Pseudonym> olliej: Of course!
17:23:47 <Pseudonym> There's [] and NondetT.
17:23:58 <olliej> Pseudonym: ah ha
17:24:04 * olliej now googles nondett
17:24:18 <Pseudonym> Oleg's is the coolest.
17:24:32 <Pseudonym> I think he called it BacktrT, though.
17:25:01 <ddarius> LogicT
17:25:11 <Pseudonym> That's it.
17:25:12 <ddarius> Hinze's is BacktrT
17:25:18 <Pseudonym> Yeah.
17:25:21 <Pseudonym> And mine was NondetT.
17:25:28 <Pseudonym> Though confusingly, I also made one called LogicT.
17:25:39 <Pseudonym> But Oleg's is better,.
17:26:03 <Pseudonym> The difference between LogicT and NondetT/BacktrT is that LogicT has soft cut.
17:27:11 <olliej> Pseudonym: scary
17:27:21 <Pseudonym> Well, Hinze's one has red cuts.
17:27:37 <Pseudonym> So Haskell can be bug-for-bug compliant with Prolog. :-)
17:28:04 <Pseudonym> Soft cut is at least logical.
17:28:25 <olliej> Pseudonym: hehehe
17:28:43 <olliej> Pseudonym: just what i always wanted, to write prolog for ghc
17:28:57 <Pseudonym> Prolog was actually a shipped example with Gofer.
17:29:13 <Pseudonym> It wasn't full Edinburgh or ISO Prolog, but still.
17:29:22 <olliej> hehe
17:34:21 <MyCatVerbs> jbauman: I *think* I was trying to see if the relationship "\x y->x and y are coprime" was an equivalence relation or not.
17:35:21 <oerjan> it is not reflexive. nuff said.
17:35:35 <phobes> transitive you mean?
17:36:03 <ddarius> olliej: It is very easy to implement core Prolog in Haskell.
17:36:34 <MyCatVerbs> phobes: well yeah, so since transitivity is one of the requirements for an equivalence relation...
17:36:35 <SamB> if f is reflexive, f x x
17:36:35 <ddarius> x is not coprime to x
17:36:53 <SamB> ?
17:37:03 <oerjan> it is somewhat difficult to be transitive and symmetric (which it is) but not reflexive - the non-reflexive elements would have to be related to nothing.
17:37:10 <ddarius> SamB: Usually it is written ~ reflexive means x ~ k
17:37:14 <ddarius> s/k/x
17:37:17 <MyCatVerbs> ddarius: yeah, that should've been obvious. x_x
17:37:19 <EvilTerran> i think "x and y are not coprime" is an equivalence relation
17:37:45 <phobes> EvilTerran:  No
17:37:51 <ddarius> Not transitive
17:37:57 <EvilTerran> ...no, that doesn't work either. 2 ~~ 6, 3 ~~ 6, 2 /~ 3
17:38:01 <phobes> Sorry guys, that's what I thought he was asking
17:38:25 <oerjan> besides, 1 and 1 are coprime :)
17:39:24 <phobes> Yes, this reminds me of a conversation I once had...
17:40:14 <phobes> I came upon a conversation between two people wondering about triples of primes such that one was the sum of the other two
17:40:32 <__nasa__> (2,3,5),...
17:40:57 <wli> phobes: Try mod 2.
17:40:59 <__nasa__> all twin primes..
17:41:13 <phobes> Right, so I said this was equivalent to the twin prime question
17:41:33 <__nasa__> yep, it is.
17:41:38 <phobes> And then one of the two asked how many triples of primes there were such that one was the product of the other two
17:41:40 <phobes> I left
17:41:45 <__nasa__> :-)
17:41:49 <oerjan> :D
17:42:34 <TSC> Wait, how many are there?
17:42:35 <olliej> hmmm, what is the advantage of using "newtype Foo = MkFoo Integer" vs. "data Foo = MkFoo Integer"?
17:42:40 <wli> TSC: 0
17:42:44 <TSC> (:
17:42:54 <ddarius> olliej: Efficiency.  They also mean different things.
17:42:59 <TSC> olliej: I think the newtype is guaranteed to be efficient
17:43:11 <olliej> ah
17:43:14 <TSC> And you can get fancy newtype deriving with GHC
17:43:22 <oerjan> olliej: the newtype only affects the type of the value, but keeps the same internal representation.
17:43:29 <olliej> ah
17:43:40 <ddarius> olliej: A newtype has no runtime realization.  It's just a way to communicate with the typechecker.
17:43:52 <olliej> but curely the compiler should be able to do that when any data type with single constructor?
17:44:02 <olliej> s/curely/surely
17:44:03 <ddarius> olliej: As I said, they mean different things.
17:44:03 <oerjan> no, because of laziness
17:44:21 <oerjan> if you have a data type, MkFoo undefined is not undefined
17:44:30 <olliej> ah
17:44:31 <olliej> true
17:44:38 <oerjan> but for newtypes thore are explicitly identical
17:44:42 <oerjan> *those
17:44:45 <olliej> righto
17:44:55 <olliej> now i  understand
17:45:07 <ddarius> However, for MkFoo !Integer it certainly could do the same thing, though there is still a very minor subtle distinction.
17:45:09 * olliej had forgotten that an eval could be undefined
17:45:21 <EvilTerran> data Foo a = Foo a; foo = case undefined of Foo () -> "foo" -- foo = undefined
17:45:37 <EvilTerran> data Foo a = Foo a; foo = case undefined of Foo _ -> "foo" -- foo = undefined, rather
17:45:44 <EvilTerran> newtype Foo a = Foo a; foo = case undefined of Foo _ -> "foo" -- foo = "foo"
17:46:26 <oerjan> EvilTerran: what about Foo !a ?
17:46:47 <ddarius> oerjan: It's irrelevant in this case.  The behavior would be the same.
17:46:48 <EvilTerran> Â¯\(Âº_o)/Â¯
17:47:08 <EvilTerran> i think it'd act the same as data Foo a = Foo a in this case
17:47:34 <ddarius> There is no application of the Foo constructor so it doesn't matter whether it's strict or not.
17:47:41 <oerjan> ddarius: ah, since the constructor is used only for matching?
17:47:57 <EvilTerran> data Foo a = Foo a; foo = case Foo undefined of Foo _ -> "foo" -- foo = "foo"
17:48:02 <EvilTerran> data Foo a = Foo !a; foo = case Foo undefined of Foo _ -> "foo" -- foo = undefined
17:48:03 <EvilTerran> i think
17:48:07 <ddarius> Yes.
17:51:33 <olliej> ddarius/EvilTerran: that ! does what?
17:51:48 <ddarius> Makes Foo strict in that argument.
17:51:53 <olliej> ah
17:52:10 * ddarius has once again magically lost two picks.
17:52:28 <EvilTerran> it makes Foo undefined = undefined
17:53:18 <ddarius> which is exactly the definition of "strict"
17:54:40 <EvilTerran> "Foo _ = undefined" is the same as "Foo _ = Foo undefined" for both newtype...a and data...!a, but the for the newtype the match is successful, and for the strict data it isn't.
17:55:49 <__nasa__> > let f !a b = b in f bottom 4
17:55:49 <lambdabot>  Parse error in pattern
17:56:06 <dibblego> s/bottom/undefined I think
17:56:11 <__nasa__> ah
17:56:21 <__nasa__> > let f !a b = b in f undefined 4
17:56:21 <lambdabot>  Parse error in pattern
17:56:26 <ddarius> !a is not Haskell 98
17:56:43 <ddarius> Not for functions.
17:56:46 <__nasa__> ok
17:56:47 <oerjan> not in patterns
17:57:00 <oerjan> only for data definitions
17:57:13 <__nasa__> right.
17:57:22 <oerjan> which lambdabot doesn't allow either
17:57:35 <EvilTerran> let f :: !a -> b -> b; f a b = b in f undefined 4
17:57:37 <EvilTerran> > let f :: !a -> b -> b; f a b = b in f undefined 4
17:57:37 <lambdabot>  Parse error
17:58:03 <oerjan> i am not sure that is legal anywhere?
17:58:10 <dibblego> doubt it
17:58:39 <ddarius> That's not valid anywhere.
17:58:39 <ddarius> Except for Clean.
17:59:47 <__nasa__> > let f a b = b in f bottom 4
17:59:48 <lambdabot>   Not in scope: `bottom'
17:59:57 <oerjan> i don't quite recall, but the whole thing might not be legal in clean either since f does not use a?
18:00:01 <__nasa__> > let f a b = b in f undefined 4
18:00:03 <lambdabot>  4
18:00:20 <oerjan> and !a is a linearly used argument or something
18:13:20 <ddarius> What happened?  The people who thought up big ideas in CS knew what they were talking about and stated it from the get go, yet years, decades later people need to be told not to do the wrong thing.
18:16:09 <olsner> ddarius: what kinds of "wrong thing" are you refering to?
18:20:03 <hpaste>  llewyenoh pasted "Change battery information" at http://hpaste.org/2552
18:20:15 <sioraiocht> yeah ddarius, you sound pretty bitter, lol
18:20:45 <dibblego> sounds like a realistic observation to me
18:20:57 <olsner> there's a lot that is wrong in the world of software, indeed
18:21:20 <Pseudonym> But it's also true that some of the pioneers didn't understand.
18:21:25 <Pseudonym> Or, perhaps, had a simplistic understanding.
18:21:49 <Pseudonym> That's generally true of pioneers.
18:21:55 <dibblego> the Scala mailing list is having an argument over Option (nullable-type) and exceptions; not one of the participants knows what _|_ really means I suspect
18:21:57 <olsner> but all is not lost - this guy claims to have found the Silver Bullet: http://www.rebelscience.org/Cosas/Reliability.htm
18:22:01 <lambdabot> Title: The Silver Bullet
18:22:06 <dibblego> that supports ddarius' observation
18:22:29 <Pseudonym> Yeah, well.
18:22:32 <dolio> Many people who write software don't study the big ideas in CS and academic stuff.
18:22:53 <Pseudonym> Remember, the Curry-Howard isomorphism wasn't written down until the 80s.
18:22:55 * ddarius has been reading http://lambda-the-ultimate.org/node/2435
18:22:56 <lambdabot> Title: No Name: Just Notes on Software Reuse | Lambda the Ultimate
18:23:22 <olsner> what is the curry-howard isomorphism?
18:23:34 <ddarius> Someone populate @where ch
18:23:51 <dolio> In my experience there's a sizable segment of computer programmers who are rather anti-intellectual in some ways.
18:24:11 <dibblego> dolio, you mean below average intellect? I agree
18:24:28 <Pseudonym> ?google video.google.com wadler
18:24:31 <ddarius> Particularly sections 11 Parnas, 12 Liskov and Zilles, and 13 Johnson and Foote (so far)
18:24:32 <lambdabot> http://text.usg.edu:8080/tt/video.google.com/videosearch?q=type%3Atvshow&docid=8217580777305859563&num=10&so=0&start=70
18:24:32 <lambdabot> Title: type:tvshow - Google Video
18:24:40 <Pseudonym> Grm.
18:24:42 <Pseudonym> Hrm
18:24:43 <ddarius> @google "Lectures on the Curry-Howard"
18:24:52 <lambdabot> ftp://ftp.diku.dk/diku/semantics/papers/D-368.ps.gz
18:25:01 <Pseudonym> If you want a good overview, there's a Google video of Phil Wadler talking at Google.
18:25:04 <dolio> dibblego: I mean they look down on academics and formal education.
18:25:11 <Pseudonym> Unfortunately, my proxy is broken at the moment.
18:25:15 <olsner> now reading http://en.wikipedia.org/wiki/Curry-Howard_correspondence
18:25:16 <lambdabot> Title: CurryâHoward - Wikipedia, the free encyclopedia
18:25:24 * ddarius often looks down on formal education...
18:25:25 <dibblego> dolio, those that I encounter are under the delusion that it is irrelevant
18:25:50 <Pseudonym> I think that formal education isn't the impotant part.
18:26:02 <ddarius> dibblego: They are not completely off base with respect to many mainstream languages.
18:26:03 <wli> There are a lot of anti-intellectual kernel programmers.
18:26:08 <ddarius> Though that is changing for the better.
18:26:22 * ddarius is wearing his good code underwear!
18:26:32 <Pseudonym> And mind you, there are a lot of anti-kernel programmer intellectuals, too.
18:26:32 <dibblego> dolio, I had a funny camping trip last week where a friend claimed that the "travelling salesman problem" and the need to approximate it because it is in NP (I was explaining it to someone else who was interested) was irrelevant, while also using a GPS at the same time
18:26:34 <dolio> It probably isn't. But the topics it brings up can be important.
18:26:47 <__nasa__> lol
18:26:48 <Nafai> Academia seems out of touch so it's really hard to pay attention to academic and intellectual subjects
18:27:02 <Nafai> I believe that's why the Haskell community is an adjustment for me
18:27:10 <olsner> it seems to me that the construction of software involves many skills not related to the theory
18:27:16 <Pseudonym> Haskell is that rarest of things: It's on the cusp of good theory and good practice.
18:27:21 <ddarius> Haskell: Where Theory equals Practice
18:27:24 <Nafai> olsner: Indeed
18:27:29 <dibblego> Nafai, not only are the academics not out of touch with reality, it is mainstream that is out of touch
18:27:43 <Pseudonym> Practice without theory is arbitrarily restricted.
18:27:53 <Pseudonym> Theory without practice is... well, we know what that is.
18:28:00 <dibblego> gedanken
18:28:16 <Nafai> dibblego: Agreed, it's making my software development life hard :)
18:28:53 <dibblego> Nafai, I just find it amusing when the reality is the complete inverse of the herd dogma :)
18:29:14 <Nafai> Heh
18:29:35 <dibblego> Proof by Appeal to Minority
18:29:44 <Nafai> It's just hard to make the effort in the highly-intellectual stuff in the Haskell community
18:30:16 <Nafai> But I want to
18:30:59 <dolio> Anyhow, I skipped lots of class in college, so I'm not implying that lectures are the key to understanding.
18:31:06 <ddarius> Nafai: Your penultimate sentence barely parses for me in a meaningful way, though I believe I understood what you meant to say.
18:31:25 <dolio> But I imagine it'd be easy to jump straight into a Java job and never know about anything much beyond it.
18:31:39 <dolio> Although maybe stuff like Haskell is getting popular enough that that isn't true anymore.
18:32:02 <Nafai> dolio: Yeah, I jumped into a Java job without knowing Java and it's been "easy"
18:32:06 <Nafai> dolio: But painful :/
18:32:25 <dibblego> Nafai, teach them Scala (I work for a Java consultancy)
18:32:36 <dibblego> Nafai, Scala is midway between Java and Haskell
18:33:21 <Nafai> dibblego: Unfortunately I have doubts they would be interested :/
18:33:44 <dibblego> Nafai, they would if you could do everything that your 5 colleagues can quicker and with less bugs
18:34:17 <Nafai> Yeah, that's an interesting idea
18:34:18 <dibblego> Nafai, tell them it's a "configuration file"
18:34:30 <Nafai> Heh
18:40:24 <dolio> Of course, even in college there were people complaining that they'd never use the stuff they were learning.
18:40:40 <dolio> Which is probably true.
18:40:59 <phobes> Better than working with guys that haven't learned the stuff they're using
18:41:14 <ddarius> Crazy.  "Typing Break" configuration.
18:41:16 <dolio> Heh.
18:41:27 <SamB> dolio: I'd complain about that if they tried to teach me Java!
18:41:48 <ddarius> How about teaching your higher ranking coworkers how to use the stuff noone has used in the shop including yourself?
18:42:50 <dolio> Well, as I recall, it wasn't Java. It was petri nets or something. :)
18:43:57 <dons> yo yo what's up haskellers :)
18:44:07 * dons can haz internets!
18:44:20 <phobes> are you in the states now?
18:44:30 <dons> yeah
18:44:36 <dolio> I actually only had one course that required Java use, as I recall, and that was because it was a project involving the entire class.
18:44:57 <SamB> dolio: well, I can't imagine using that for anything but I think it'd be fun to learn personally
18:45:12 <phobes> dolio:  An enterprise "hello world" solution?
18:45:28 <ddarius> Another one bites the dust
18:45:33 <fnord123> dons are you in US now?
18:45:46 <dolio> The project was to create a tool to construct UML sequence diagrams from profiles of running Java programs.
18:45:51 <SamB> fnord123: yes he works here now
18:45:51 <dons> yeah, in Portland :) lovely and hot
18:45:55 <olsner> there was a contest on the thedailywtf forums to build the best Enterprise Hello World application, incidentally
18:46:07 <ddarius> we ownz him
18:46:19 <dons> SamB: had to power cycle the modem, and disconnect the battery, btw, and then dhcp worked :)
18:46:19 <SamB> fnord123: australia was a longish commute, so he decided to live here too
18:46:28 <dons> yeah, the commute was getting really tiresome
18:46:31 <SamB> dons: ... battery?
18:46:36 <fnord123> Dropped the phd?
18:46:42 <dons> in the cable box
18:46:49 <dons> fnord123: finished it -- almost.
18:46:54 <SamB> dons: I don't think mine has a battery
18:47:08 <dons> yeah, that was the trick. the batter was keeping the old settings up
18:47:21 <SamB> settings either ;-)
18:47:40 <dons> this is a fancy tv/phone/net bundle box, so maybe its a bit stateful
18:47:47 <SamB> oh
18:47:51 <SamB> one box for all that?
18:47:56 <SamB> mine just has a serial number...
18:48:11 <dons> yeah, one box, and everything goes through it
18:48:16 <fnord123> yours must have a battery or power cycling the thing would mean you need to re-enter your credentials, dmz, and ip forwarding settings each time
18:48:21 <dons> video on demand and so on
18:48:31 <SamB> we get phone from the same provider but with different lines
18:48:35 <SamB> and we don't get TV from them
18:48:58 <SamB> at least, we have different lines coming into the house
18:49:20 <olsner> I think I know what the curry-howard isomorphism is now... but is it useful? and if so, what for?
18:49:37 <SamB> olsner: in other languages it's used for proofs...
18:49:44 <SamB> not here, though, since undefined
18:50:11 <dons> :)
18:50:16 <dons> that's a bit more responsive...
18:50:22 <Pseudonym> olsner: Phil Wadler pointed out that the Curry-Howard double-barreled name predicts the existence of other double-barreled names.
18:50:27 <SamB> dons: heh
18:50:28 <SamB> it would be
18:50:31 <Pseudonym> e.g. Girard-Reynolds, Hindley-Milner
18:50:42 <thoughtpolice> hm, is there any good way to capture stdout? i'm looking at hDuplicate* but so far I've not gotten much luck
18:50:42 <SamB> dons: what was that about an orchestra?
18:50:59 <dons> that's the unsw domain for cluster boxes
18:51:02 <ddarius> olsner: Someone has made a register allocator via CH.
18:51:07 <olsner> Pseudonym: since the same thing can be discovered as a programming-thing and a logic-thing simultaneously?
18:51:12 <Pseudonym> The fact that proofs are programs and types are formulas probably isn't useful in and of itself.
18:51:12 <SamB> dons: you aren't identified are you?
18:51:14 <Pseudonym> olsner: Right.
18:51:16 <SamB> dons: strange name
18:51:19 <dons> hmm, i think so?
18:51:27 <SamB> --> dons (i=dons@pill01.orchestra.cse.unsw.EDU.AU) has joined #haskell
18:51:28 <SamB> --> dons (n=dons@c-76-105-222-72.hsd1.or.comcast.net) has joined #haskell
18:51:31 <dons> right.
18:51:32 <ddarius> olsner: The goal is to steal, steal, and steal some more from the logicians.
18:51:36 <dons> oh hmm
18:51:47 <olsner> ddarius: register allocation via CH? which kind of logic was abused to do that?
18:51:56 <dons> ghosted, SamB
18:51:57 <SamB> yeah, i stands for identified, n for not...
18:52:02 <Pseudonym> The thing is, most programming language concepts have been show to have logical interpretations.
18:52:49 <Pseudonym> Wadler's argument is that it's important because programming languages that have isomorphisms to logic are more natural.
18:52:54 <Pseudonym> Not in the sense of easier to program.
18:53:00 <Pseudonym> But in the sense of being part of nature.
18:53:16 <Pseudonym> And, consequently, easier to reason about./
18:54:02 <ddarius> olsner: http://www.pllab.riec.tohoku.ac.jp/~ohori/research/recent.html
18:54:03 <lambdabot> Title: Recent papers - Atsushi Ohori
18:54:53 <fnord123> Question: I have a need for heterogenous lists that I want to define up front (column decls and the row data for a gtk TreeView). I would prefer to have a structure where I don't need to cover my data in all sorts of extra words and I would also prefer to not have to maintain several tables at once. Is this possible or will I need to make a data type that can hold any of the types I intend to hold?
18:55:47 <ddarius> fnord123: Worst case scenario you can (probably) use Dynamics, though there is probably a better solution.
18:56:21 * olsner ponders a thesis generator that generates logic/programming isomorphisms
18:57:01 <Pseudonym> If you do that, you get a PhD.
18:57:20 <Pseudonym> Because there's one programming language construct that no corresponding logic has been found for yet.
18:57:20 <Pseudonym> And that's concurrency.
18:57:29 <fnord123> I suspect I will need to have something like rows = Branch (Leaf (RString "blah")) (Branch (Leaf (RInt 4)))
18:57:30 <olsner> concurrent logic eh?
18:57:30 <Pseudonym> You do that, you'll have discovered the most natural way to program in concurrency.
18:58:41 <sorear> Argh!  I missed it!
18:58:50 <olsner> Pseudonym: currently working on the halting problem though... I guess I'll tackle that problem later
18:59:05 <Pseudonym> Oh, the halting problem is in GHC HEAD.
18:59:05 <Lemmih> dons: Have you finished your PhD?
18:59:07 <SamB> olsner: hahahahaha
18:59:08 <TSC> Please do P=NP first
18:59:37 <SamB> P=NP is supposed to be easier than the halting problem, isn't it?
18:59:46 <fnord123> Lemmih: 02:41:34) dons: fnord123: finished it -- almost.
18:59:50 <Pseudonym> Well the halting problem doesn't have a solution.
18:59:58 <Pseudonym> Assuming the Church-Turing thesis.
19:00:05 <sorear> @quote halt
19:00:05 <dons> Lemmih, i'm still writing up
19:00:05 <lambdabot> No quotes match. Do you think like you type?
19:00:18 <Pseudonym> dons: Heard that one before.
19:00:23 <sorear> @remember Pseudonym the halting problem is [solved] in GHC HEAD
19:00:23 <lambdabot> Done.
19:00:28 <fnord123> I thought the halting problem was proven unsolvable
19:00:34 <ddarius> Pseudonym: Look at LolliMon.
19:00:49 <Pseudonym> Oh, hang on, it's not in GHC HEAD.
19:00:55 <Pseudonym> You need to get the latest version for hackage.
19:00:58 <Pseudonym> from
19:01:08 <Pseudonym> That's the standard answer around here, right?
19:01:46 <ddarius> Monadic linear logic for the win (to use this new fangled #haskell slang)
19:02:40 <olsner> isn't "ftw" from 4chan?
19:02:41 <dons> Pseudonym: heh
19:03:13 <phobes> "for the win" surely comes from hollywood squares
19:03:28 <fnord123> phobes gets the square
19:03:36 <ddarius> Pseudonym: That or "There's a Haskell Prime proposal for it."
19:04:49 <Pseudonym> I'm wondering if I should submit the implicit parameters thing as a bug.
19:05:14 <Pseudonym> f :: (Class a, ?arg :: a) => String
19:05:18 <Pseudonym> Accepted by hugs, not by GHC.
19:06:18 <__nasa__> Pseudonym: Does ?a "strictify" a in hugs?
19:06:31 <Pseudonym> No.
19:06:34 <__nasa__> or is it optional param?
19:06:41 <phobes> implicit param
19:06:41 <Pseudonym> It's an implicit parameter.
19:06:45 <__nasa__> oh
19:06:49 <__nasa__> cool
19:06:51 <Pseudonym> Basically, you get to pass a value as you would a typeclass.
19:07:41 <dons> huh, that's a weird type, Pseudonym.
19:07:49 <Pseudonym> Yeah, but I need it!
19:07:59 <ddarius> Pseudonym: Down with implicit parameters!!
19:08:07 <ddarius> s/!!/! despite effect
19:08:26 <Pseudonym> ddarius: Without real Oleg-style implicit configuration, it's all we have.
19:09:19 <olsner> is that definition similar to f :: (Class a) => a -> String?
19:09:32 <shapr> What's the status of hs-plugins again?
19:09:48 <shapr> I remembered why I wanted to use it...
19:09:59 <phobes> olsner: yes, but the parameter is "implicit", passed by name automagically
19:10:16 <phobes> olsner: it's kind of like a dynamic scoping mechanism
19:10:18 <Pseudonym> OK, let me describe my use case.
19:10:30 <Pseudonym> See if anyone else can think of a good solution.
19:10:35 <olsner> hmm... so (\arg -> g f) would give a value for arg inside f?
19:10:55 <Pseudonym> I want polynomials with arbitrary coefficients.
19:11:00 <Pseudonym> Including other polynomials.
19:11:21 <Pseudonym> The question is: How to print them out?
19:11:47 <Pseudonym> Remember, you have to be able to give the monomials a name, like x or y.
19:12:15 <Pseudonym> And how to do that, while also allowing these polynomials to be members of a class like Num.
19:12:40 <Pseudonym> And support operations like fromIntegral.
19:13:28 <oerjan> Pseudonym: and parametrizing over the type of monomials is not enough?
19:13:34 <oerjan> you even get a monad then!
19:13:42 <oerjan> well, almost
19:13:55 <oerjan> i guess you need Eq again
19:13:57 <Pseudonym> No, it's not enough, because the monomials aren't closed.
19:14:02 <Pseudonym> I should be able to concoct them at run-time.
19:15:21 <SamB> Pseudonym: hmm. like complicated type variables?
19:15:23 <olsner> hmm "sequential sequent calculus"
19:15:41 <SamB> how about "sequential sequent seq calculus"
19:15:44 <SamB> I want to see that one
19:16:26 <Pseudonym> SamB: Not necessarily.
19:16:30 <Pseudonym> Arbitrary strings would do.
19:16:43 <Pseudonym> And no, I don't want to reify Strings as Peano integers.
19:16:59 <ddarius> Pseudonym: You can't just attach a name to the polynomials when you build them?
19:17:12 <Pseudonym> ddarius: And how would you support fromInteger?
19:17:18 <oerjan> olsner: implicit parameters need to be bound by let or where, i think
19:17:25 <oerjan> so no lambdas
19:17:30 <Pseudonym> Or even (*)?
19:17:42 <Pseudonym> How would you make (*) statically type-correct?
19:17:43 <olsner> sounds like something you'd use macros for
19:18:03 <ddarius> fromInteger is tricky but I see a potential solution, (*) should be no problem.
19:18:10 <int-e> Pseudonym: reify them as binary numbers then :P
19:18:21 <olsner> #define f (f' arg)
19:18:31 <Pseudonym> ddarius: Go on.
19:18:45 <ddarius> I don't understand what you think the issue is with (*).
19:18:48 <Pseudonym> And BTW, Strings are just one example.
19:18:57 <Pseudonym> ddarius: What's your proposed Polynomial type here?
19:19:11 <phobes> I think he wants (1 + x)*(1+y) => ???
19:19:15 * SamB_XP_ stares at the output of running lspci on Windows
19:19:16 <int-e> data Poly a = Poly String [a] ?
19:19:19 <phobes> Is that a polynomial in x or y?
19:19:24 <SamB_XP_> hey!
19:19:29 <Pseudonym> phobes: That should be type-incorrect.
19:19:33 <SamB_XP_> I've got something from DEC in this computer!!!!
19:19:33 <phobes> ok
19:19:34 <SamB_XP_> coool
19:19:36 <ddarius> Just add a String (or whatever) as a component to the data structure representing polynomials.
19:19:51 <Pseudonym> ddarius: So what happens when you multiply two polynomials?
19:20:01 <SamB_XP_> 00:0f.0 PCI bridge: Digital Equipment Corporation DECchip 21152 (rev 03)
19:20:07 <Pseudonym> How do you statically ensure that you don't mix polynomials in different monomials?
19:20:11 <ddarius> They have to be over the same variable.
19:20:16 <Pseudonym> Or what happens?
19:20:20 <Pseudonym> It blows up at run-time?
19:20:23 <Pseudonym> Not acceptable.
19:20:24 <olsner> but is that something actually from DEC or just some device emulating something from DEC?
19:20:43 <ddarius> Okay, I didn't think that was a requirement.
19:20:57 <Pseudonym> And, BTW, this is not the only piece of information about a monomial that I need.
19:21:01 <SamB_XP_> olsner: with DEC's manufacturer ID?
19:21:06 <Pseudonym> But that's another story.
19:21:13 <ddarius> So what happens when we use a phantom type?
19:21:22 <Pseudonym> ddarius: Implement the Show instance.
19:21:35 <oerjan> Pseudonym: so keep polynomials parametrized over a type, and use some other mechanism to make that type runtime extensible?
19:21:47 <Pseudonym> oerjan: Like reifying Strings as types?
19:22:11 <Pseudonym> Or did you mean like implicit arguments?
19:22:15 <Pseudonym> :-)
19:22:23 <dolio> What's the implicit parameter solution look like? I haven't used them at all, really.
19:22:42 <Pseudonym> What I really want is for implicit paramters to work just like type classes.
19:22:50 <Pseudonym> I want to be able to write this:
19:22:57 <ddarius> instance Show (Poly v) where show poly = showPoly (showVar poly) poly  instance ShowVar X where showVar _ = "x"
19:22:59 <Pseudonym> showSomething :: (Show a, ?foo :: a) => String
19:23:03 <oerjan> hm, implicit arguments, now there's an idea. don't know if that would work.
19:23:04 <Pseudonym> showSomething = show ?foo
19:23:11 <Pseudonym> Or this:
19:23:24 <olsner> SamB: apparently, tulip network cards with many ports include their own pci bridge
19:23:26 <Pseudonym> instance (Show a, ?foo :: a) => Show Foo where { ... }
19:23:38 <SamB_XP_> olsner: interesting
19:24:04 <Pseudonym> But I can't do that in GHC.
19:24:14 <olsner> and iirc, the tulip is an often-emulated ethernet chipset
19:24:18 <Pseudonym> Either it's an arbitrary restriction, or there's some terribly good type-theoretic reason for disallowing it.
19:24:21 <SamB_XP_> come to think of it, what the heck does that bridge bridge to?
19:24:34 <olsner> a DEC ethernet controller?
19:24:35 <ddarius> Pseudonym: I vote for the former.
19:24:43 <Pseudonym> But the fact that I can simulate this, at least for ground types, using Oleg-style implicit configuration, I suspect the former, too.
19:24:52 <Pseudonym> So I _think_ it's a bug.
19:24:55 <SamB_XP_> olsner: I have a 3com controller, with one port...
19:25:26 <Pseudonym> ddarius: The problem with that is that you've got ShowVar X
19:25:33 <Pseudonym> Where X is, presumably, some concrete type.
19:25:38 <SamB_XP_> Pseudonym: couldn't it just be because implicit parameters are an abuse of the typechecker?
19:25:39 <Pseudonym> You can't manufacture that at run-time.
19:25:47 <Pseudonym> SamB: That's also possible.
19:26:12 <Pseudonym> But it's the closest thing we have to real implicit configuration.
19:26:28 <Pseudonym> I might add that Oleg et al's implementation of implicit configuration is neat, but it leaks.
19:26:35 <SamB_XP_> i.e. they make aspects of typeclass implementation show through that never would with typeclasses...
19:26:57 <olsner> SamB_XP_: apparently, even 3com produces tulip clones
19:27:09 <ddarius> Pseudonym: How do you want static checking and runtime specification of the variable?
19:27:10 <phobes> SamV_XP_:  example?
19:27:16 <SamB_XP_> olsner: I wouldn't be surprised if they used a real DEC chip...
19:27:31 <phobes> ddarius: I was wondering that myself
19:27:32 <ddarius> Though it should still be doable.
19:27:43 <Pseudonym> ddarius: Here's the type signature.
19:28:05 <SamB_XP_> olsner: but why bother for a single-port controller?
19:28:23 <Pseudonym> instance (Monomial m, ?monomial :: m, Num coeff) => Polynomial m coeff where {- ... -}
19:28:41 <Pseudonym> Right?
19:29:05 <olsner> you mean, why bother with the bridge?
19:29:30 <Pseudonym> That gives you static checking (you can't mix polynomials) AND runtime-specification.
19:29:45 <Pseudonym> By making the implicit parameter a precondition of the typeclass instance.
19:29:59 <Pseudonym> You can do that with implicit configuration.
19:30:35 <Pseudonym> Oh and, of course, m is a phantom type of Polynomial.
19:30:39 <SamB_XP_> olsner: precisely
19:31:02 <ddarius> Examples of what m would be instantiated to?
19:31:36 <Pseudonym> ddarius: Actually, even this might work.
19:31:45 <phobes> Pseudonym:  Can you make an "adapter type" for the monomial?
19:32:04 <Pseudonym> No, hang on, that doesn't work.
19:32:10 <Pseudonym> ddarius: Well, here's one example.
19:32:17 <Pseudonym> instance Monomial X where
19:32:20 <wli> I totally don't get what implicit parameters are doing here.
19:32:29 <Pseudonym>     showMonomial _ = showString "x"
19:32:31 <Pseudonym> Say.
19:32:44 <Pseudonym>     derivative = fromIntegral 1
19:33:01 <phobes> wli: They are storing the name and maybe value of the monomial upon which the polynomial is based
19:33:23 <shapr> ddarius: Could proof-directed decompilation allow for optimization of binaries?
19:33:45 <SamB_XP_> olsner: peculiar, here's an excerpt from lspci -t...
19:33:59 <SamB_XP_>            +-0f.0-[0000:02]--
19:34:32 <shapr> ddarius: Applying CH to machine code is very interesting.
19:34:40 <SamB_XP_> i.e. the bridge doesn't have any devices on the other side
19:34:51 <phobes> Pseudonym:  Would an "adapter type" not work?   as in:  instance (?monomial : MonomialDescriptor, num coeff) => Polynomial coeff where
19:35:06 <wli> I mean in Haskell in general.
19:35:09 <phobes> and MonomialDescriptor is a datatype with information about the monomial
19:35:36 <Pseudonym> phobes: It doesn't work in GHC because you can't use an implicit argument as a typeclass instance precondition.
19:35:36 <dolio> wli: Someone got a paper out of them. :)
19:35:40 <ddarius> shapr: Presumably.  There is some crazy binary analysis and optimization stuff out there.
19:35:47 <Pseudonym> So yeah, that might work.
19:36:00 <Pseudonym> If it worked.
19:36:22 <Pseudonym> Because, of course, you don't "need" typeclasses if you have higher-ranked types.
19:36:56 <olsner> SamB_XP_: weird
19:37:26 <phobes> I'm not sure I understand...  I thought the problem with GHC was the (?monomial: m) where m is a constrained type.  Or is it worse than that?
19:37:35 <ddarius> wli: They coopt the dictionary passing mechanism of typeclasses.
19:37:47 <Pseudonym> phobes: That's one problem.
19:38:26 <Pseudonym> Here's the thing, though.
19:38:31 <Pseudonym> instance
19:38:31 <Pseudonym>            (?monomial : MonomialDescriptor, num coeff) => Polynomial coeff
19:38:31 <Pseudonym>            where
19:38:33 <sioraiocht> can someone explain to me wtf _|_ is?
19:38:37 <Pseudonym> That's your suggestion, right?
19:38:50 <phobes> I'll say yes until you show that it doesn't work :)
19:38:51 <Pseudonym> But now, (*) isn't statically checked.
19:39:00 <Pseudonym> Even if you could give that as an instance.
19:39:18 <Pseudonym> You really need the phantom type to make (*) statically checked.
19:39:31 <ddarius> sioraiocht: _|_ is undefined.  undefined = undefined
19:39:47 <ddarius> That's an answer at one level.
19:40:01 <sioraiocht> ddarius: okay, so the value of _|_ is any undefined value for a type?
19:40:26 <ddarius> :t let undefined = undefined in undefined -- i.e. yes
19:40:29 <lambdabot> forall t. t
19:40:40 <sioraiocht> haha, okay thank you
19:41:27 <wli> Implicit parameters seem horrifically dangerous from the sw. eng. POV.
19:41:45 <ddarius> wli: They're similar to dynamic binding, QED.
19:42:13 <Pseudonym> If you think of it as passing a value as a typeclass, it makes more sense.
19:42:43 <ddarius> Not as bad as dynamic binding though.
19:42:43 <ddarius> dynamic scoping
19:42:43 <ddarius> (what the heck was going through my head)
19:42:56 <ddarius> Pseudonym: It making sense doesn't make it have nice software engineering properties.
19:43:19 <Pseudonym> The thing is, there should be a way to do what I want to do.
19:43:24 <wli> Well, I could agree from the POV of not liking OO. ;)
19:43:27 <Pseudonym> But at the moment, I don't see any way.
19:43:45 <ddarius> dynamic scoping is not OO.  My brain was dysfunctioning when I said dynamic binding.
19:43:52 <phobes> Pseudonym:  I'm still trying to understand why (*) doesn't type check
19:44:11 <Pseudonym> I basically want to attach information to a phantom type in such a way that I can manufacture this information at run-time.
19:44:38 <Pseudonym> phobes: What's the type of (*) here?
19:44:47 <ddarius> You need to make it less phantom.
19:44:58 <wli> I read it as "dynamic scoping" when you first wrote it; is was the correction that inspired me ot make the anti-OO crack. ;)
19:45:09 <Pseudonym> Oh, and I need to make it support operations like fromIntegral.
19:45:19 <Pseudonym> fromInteger
19:45:27 <ddarius> wli: I don't think dynamic scoping is even remotely common in OO languages.
19:45:40 <ddarius> Without HOFs it's mostly a non-issue.
19:45:41 <Pseudonym> I can't get around fromInteger, because that's an externally imposed interface.
19:46:35 <wli> ddarius: Yes, there was some stupid latching onto the misstatement to make anti-OO cracks.
19:47:50 <ddarius> Pseudonym: fromInteger is hard, and would be hard just about any way.  My earlier solution which might work here is to have such polynomials be polymorphic in the phantom type and to have them glom one way or another the "monomial" of the polynomial they are combined with.
19:48:23 <Pseudonym> ddarius: Interesting, but inconvenient.
19:48:37 <ddarius> Pseudonym: ?
19:48:44 <Pseudonym> The application is strongly-typed computer algebra.
19:48:53 <Pseudonym> Basically, what you're saying is make it less strongly-typed.
19:49:32 <ddarius> Pseudonym: 1 -is- naturally polymorphic in the monomial type and I'm not suggesting any run-time error cases.
19:49:49 <Pseudonym> What you're suggesting is something like this:
19:50:23 <Pseudonym> instance (Monomial m1, Monomial m2, Join m1 m2 m) => Mul m1 m2 m where
19:50:33 <Pseudonym>     (*) :: Polynomial m1 -> Polynomial m2 -> Polynomial m
19:50:47 <Pseudonym> (I ignored the coefficient arguments here for simplicity.)
19:50:52 <Pseudonym> Where:
19:51:13 <Pseudonym> instance (Monomial m1, Monomial m2, Monomial m) => Join m1 m2 m | m1 m2 -> m
19:51:19 <Pseudonym> Sorry, class, not instance.
19:51:22 <Pseudonym> But you get the idea.
19:51:34 <Pseudonym> I _think_ that's what you're suggesting.
19:51:37 <ddarius> Pseudonym: ?
19:51:37 <ddarius> If 1 :: forall m.Polynomial m then when you had 1*x, since x :: Polynomial X, 1 would become Polynomial X
19:51:49 <Pseudonym> ddarius: Sure, that's cool.
19:52:07 <phobes> Pseudonym:  I'm not very familiar with the rules here, but it looks to me that either your version of Polynomial will not prevent (*) from multiplying different monomial types, or mine will as well.
19:52:16 <Pseudonym> But we still haven't addressed how to manufacture monomials at run-time.
19:53:05 <ddarius> data Poly m coeff = K coeff | Poly somethingThatHoldsTheRuntimeSelectedStringForTheMonomial [coeff], K x * Poly a cs = Poly a (mul x cs)
19:53:22 <Pseudonym> phobes: Actually, I think you might be right, but you STILL can't put an implicit parameter in the context for a typeclass instance.
19:53:33 <Pseudonym> So your solution wouldn't work in GHC anyway.
19:53:34 <ddarius> All we need for the phantom type variables is that they be different.
19:54:04 <Pseudonym> ddarius: Habg on, let me parse that for a moment.
19:54:20 <ddarius> I'm not sure I can turn that into something useful.
19:55:56 <ddarius> It seems clear that somewhere or another we need an existential type.
19:56:02 <Pseudonym> Perhaps.
19:56:15 <ddarius> Perhaps something like runST.
19:56:26 <ddarius> (For a non-obvious meaning of "like")
19:56:33 <Pseudonym> ddarius: This is covered in the implicit configuration paper.
19:56:43 <ddarius> I probably need to reread that.
19:56:54 <Pseudonym> However, there are two implementations there.  One is unwieldy and the other leaks memory.
19:57:14 <oerjan> another thing: if you happen to read in two polynomials that _do_ have the same variable, how do you convince the type system they are compatible?
19:57:30 <ddarius> oerjan: That's (relatively) easy.
19:57:31 <Pseudonym> oerjan: I never mentioned "reading in".
19:57:56 <Pseudonym> My application doesn't require it.
19:58:02 <Pseudonym> It just requires manufacturing at run-time.
19:58:35 <ddarius> gensyms?
19:59:15 <Pseudonym> gensyms would allow you to attach a generated name, but not a specific name.
19:59:22 <Pseudonym> Or other arbitrary information, not just a name.
20:01:37 <Pseudonym> Anyway, regardless of the correct answer to my problem, I do think that these are arbitrary restrictions.
20:02:17 <phobes> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
20:02:20 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
20:02:25 <phobes> Look at section 7.4.6.1
20:02:35 <phobes> They give an explanation as to why it's illegal
20:02:40 <Pseudonym> phobes: Unfortunately, my proxy is broken at the moment.
20:02:47 <Pseudonym> But I'll look at it when I have a moment.
20:02:50 <phobes> But it seems to me that they've missed the point of what it would mean
20:03:00 <phobes>  You can't have an implicit parameter in the context of a class or instance declaration. For example, both these declarations are illegal:
20:03:00 <phobes>   class (?x::Int) => C a where ...
20:03:00 <phobes>   instance (?x::a) => Foo [a] where ...
20:03:00 <phobes> Reason: exactly which implicit parameter you pick up depends on exactly where you invoke a function. But the ``invocation'' of instance declarations is done behind the scenes by the compiler, so it's hard to figure out exactly where it is done. Easiest thing is to outlaw the offending types.
20:03:12 <ddarius> "In post-Fordism the worker is designed to act as a computer as well as a machine." ...  ... .
20:03:45 <Pseudonym> Right.
20:04:05 <phobes> The thing is that an instance declaration instance (?x :: Int) => C ... should mean "forall ?x ..." I think.  Right?
20:04:45 <phobes> So that reason doesn't seem to make much sense
20:06:20 <glguy> People in #archlinux crack me up, one guy asks: what is (some decimal number) * 100% ?
20:06:22 <Pseudonym> Yeah, I agree.
20:06:43 <Pseudonym> The thing is: If you can do it using Oleg et al-style implicit configuration, there's no reason to disallow it in implicit paramters.
20:06:46 <glguy> another asks: if this thing ticks once each 10 seconds, and it ticked X times, how long has it been running
20:07:11 <shapr> glguy: scary
20:07:19 <shapr> DRMacIver: Talar du svenska?
20:07:30 <ddarius> Simple arithmetic is no longer necessary.
20:07:42 <phobes> glguy:  they probably just don't know "if this is one where you do times or do divide"
20:08:06 <ddarius> glguy: Actually there's a uncountable infinity of answers to that second question.
20:08:13 <Pseudonym> Anyway, lunch time.
20:08:52 <phobes> ddarius:  I'm sure that's the response he got on archlinux
20:08:59 <glguy> ddarius, I'm nearly positive that wasn't the part of the question he was having trouble with
20:09:06 <dolio> Only if time isn't quantized.
20:09:29 <ddarius> dolio: If it is, there are nevertheless many many answers.
20:09:36 <dolio> True.
20:09:57 <SamB_XP_> ddarius: you could give them all
20:10:02 <SamB_XP_> could you not?
20:10:13 <ddarius> SamB_XP_: You could indeed give them all in both cases.
20:10:34 <SamB_XP_> of course it would be easier if you knew what X was
20:12:09 <SamB_XP_> hmm, is (10(X-1) s, 10(X+1) s) the answers?
20:12:55 <phobes> For X>0  :)
20:13:18 <SamB_XP_> neglecting the corner case
20:13:22 <SamB_XP_> (s)
20:15:29 * glguy wishes there was some kind of mutt initial configuration generator
20:15:50 <SamB_XP_> so CBV's "logo" is YY?
20:16:48 <wli> glguy: Well, hammering out a tty/pty -based MUA would be a lot easiser with an ncurses NIH in native Haskell without the foreign call signal blocking property...
20:17:46 <glguy> You mean it blocks signals that originate from foreign function calls?
20:17:47 <aFlag> ddarius, could you give me two answers for the second question glguy told us?
20:17:56 <phobes> I'm using ubuntu and my dvd drive is not acknowleding the dvd I've inserted.  Any suggestions?
20:18:12 <wli> glguy: I think whenever a foreign call is in progress signals get blocked all over the place.
20:18:16 <SamB_XP_> phobes: speak gently to it
20:18:27 <sebell> phobes: I suggest #ubuntu
20:18:42 <phobes> sebell:  excellent idea!
20:19:04 <wli> glguy: Or if not "everywhere" then some widespread manner.
20:19:26 <glguy> wli, has there been any discussion about this on the mailing list?
20:19:41 <wli> glguy: Well, it's documented.
20:19:55 <dons> glguy: hey :)
20:20:07 <glguy> Hi
20:20:13 <wli> re dons
20:20:14 <ddarius_> aFlag: If the thing has ticked X times, then 10X+1 and 10X+2 seconds are both possibilities for how long it has been running.
20:20:17 <glguy> dons, you in town yet?
20:20:22 <glguy> dons, I know you start wednesday
20:20:37 <Pseudonym> ?where dons
20:20:37 <lambdabot> http://www.cse.unsw.edu.au/~dons
20:20:48 <ddarius> Shameful lambdabot, shameful.
20:20:56 <dons> glguy: yeah, i'm in town :)
20:20:58 <SamB_XP_> glguy: you can't tell from his domain name?
20:21:03 <dons> lovely weather!
20:21:07 <lambdabot> Garbage in, garbage out, don't you know.
20:21:09 <glguy> dons, doing anythign fun tomorrow?
20:21:16 <aFlag> ddarius, I see your point, but our precision here is down to seconds, it doesn't make sense consider anything beyond that
20:21:21 <newsham> > f garbage
20:21:22 <lambdabot>   Not in scope: `garbage'
20:21:43 <dons> glguy: probably just finding some things, and settling in.
20:21:44 <SamB_XP_> ddarius: it's supposed to go to his website, not his physical location
20:21:47 <dons> glguy: tomorrow's a holiday?
20:21:48 <SamB_XP_> that's what where is for
20:21:57 <glguy> dons, yeah
20:22:02 <glguy> dons, Labor Day
20:22:16 <newsham> ?check \y -> let garbage x = x in garbage y == id y
20:22:17 <lambdabot>  Add a type signature
20:22:24 <SamB_XP_> dons: at my old old school, they celebrate it by ... having classes
20:22:24 <newsham> ?check \y -> let garbage x = x in garbage y == id (y :: Int)
20:22:26 <lambdabot>  OK, passed 500 tests.
20:22:32 <newsham> id == garbage!
20:22:57 <wli> The labor movement in the US has been exterminated anyway. The holiday is vestigial at best.
20:23:07 <glguy> but a holiday nonetheless
20:23:15 <SamB_XP_> I don't know what it celebrates even
20:23:27 <newsham> wli: thats why all the sysadmins and netops are on call tomorow :)
20:23:28 <glguy> it celebrates the labor march of 189x
20:23:32 <Pseudonym> It celebrates the history of obtaining meaningless holidays.
20:23:36 <Adamant> you busting your ass the other 364 days of the year
20:23:38 <glguy> and the subsequent mass unionization
20:24:05 <SamB_XP_> should be called unions day or something then ;-P
20:24:17 <dons> "no work day"
20:24:20 <sebell> It's `Labour Day' in Canada.
20:24:33 <SamB_XP_> dons: that's not very specific
20:25:01 <Adamant> is it "Labrador" or "Labradour"
20:25:12 <newsham> dons: welcome to america
20:25:16 <SamB_XP_> that covers Jan 1, Dec 25, July 4 mostly too...
20:25:23 <dons> newsham: thanks!
20:25:40 <sebell> Adamant: Is that a serious question?
20:25:51 <Adamant> sebell, decidely not. :)
20:25:51 <dons> newsham: nice country you have here. well done :)
20:25:55 <dibblego> ?type partition
20:25:57 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:25:59 <sebell> Adamant: *phew* :)
20:26:04 <wli> I've got to prep for clubbing.
20:26:11 <fnord123> Dons left the Commonwealth. *sniff sniff*
20:26:15 <newsham> dons: we've been working on it all week
20:26:35 <newsham> (dont forget to turn the lights off when you leave)
20:26:48 <Adamant> oh come on. it's not like he moved to INRIA and started working on OCaml
20:26:57 <SamB_XP_> fnord123: I'm not familiar with country .110
20:27:00 <dons> Adamant: yeah, that'd be really crazy!
20:27:02 <bos> could be worse. he could be working on LINQ.
20:27:11 <dons> hah
20:27:23 <dons> yeah, and committing monad comprehensions in to C#
20:27:27 <dons> something truly evil
20:27:36 <Adamant> yes, American is close enough to English
20:27:43 <ddarius> aFlag: The precision I used -was- seconds.
20:27:48 <wli> One more cig.
20:27:59 <newsham> bos: its not a long drive from portland to bellevue
20:28:41 * bos is learning all about javascript and jquery tonight. ungh.
20:28:50 <Adamant> bos, what's jquery?
20:28:55 <newsham> <script>alert('hi')</script>
20:29:00 <Pseudonym> dons: Just don't tell Americans that you have a pot plant.
20:29:08 <bos> @go jquery
20:29:08 <Pseudonym> They really get weird when you tell them that.
20:29:10 <lambdabot> http://jquery.com/
20:29:10 <lambdabot> Title: jQuery: The Write Less, Do More, JavaScript Library
20:29:40 <dons> Pseudonym: heh.
20:29:53 <dons> there's a huge pot plant in the lounge room though!
20:29:53 <Pseudonym> And say "light bulb" instead of "light globe".
20:30:08 <ddarius> They aren't globular
20:30:24 <ddarius> bos: javascript is -almost- a fairly nice language.
20:30:24 <Pseudonym> Nor are they bulbous.
20:30:28 <geezusfreeek> ddarius, they're bulbular?
20:30:35 <dons> well, they're kinda bulbous and globular
20:30:36 <dibblego> what's that function that is a tuple of takeWhile and dropWhile?
20:30:40 <SamB_XP_> Pseudonym: aren't they?
20:30:54 <SamB_XP_> globulous?
20:31:01 <wli> dibblego: span
20:31:02 <dibblego> ?hoogle xs p -> (takeWhile p xs, dropWhile p xs)
20:31:03 <lambdabot> Did you mean: Xs p -> (TakeWhile p Xs, DropWhile p Xs)
20:31:03 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
20:31:03 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
20:31:08 <dibblego> wli, that's it, thanks!
20:31:13 <Pseudonym> And it's "silver dollar pancakes", not "pikelets".
20:31:41 <ddarius> I don't know what a silver dollar pancake or a pikelet is.
20:31:52 <geezusfreeek> small pancakes
20:31:56 <bos> ddarius: yeah, javascript wants to be self when it grows up
20:32:01 <wli> Silver dollar pancakes are just small pancakes.
20:32:06 <ddarius> bos: Unfortunately not...
20:32:10 <geezusfreeek> as an american, i had no idea they went by any other name
20:32:15 <ddarius> bos: That'd be cool though.
20:32:21 <Pseudonym> Oh, and one more thing.
20:32:24 <SamB_XP_> bos: as long as it wasn't so slow
20:32:25 <ddarius> bos: It has insane scoping and no TCO yay!
20:32:31 <Pseudonym> There's a certain kind of water vessel that Americans refer to as a "pitcher".
20:32:40 <Pseudonym> You should patiently explain that in Australia, we call that a "bowler".
20:32:52 <SamB_XP_> even though it doesn't throw baseballs!
20:32:54 * Pseudonym nods seriously
20:32:54 <SamB_XP_> the horror!
20:33:03 <ddarius> SamB_XP_: Self was pretty good and if you are looking for speed in javascript your crackheaded.
20:33:05 <geezusfreeek> it doesn't roll bowling balls either!
20:33:15 <SamB_XP_> ddarius: I ran it on x86 once or twice
20:33:15 <bos> no TCO? total cost of ownership? like a desk?
20:33:23 <hpaste>  int-e pasted "for Pseudonym - polynomials?" at http://hpaste.org/2554
20:33:30 <Pseudonym> BTW, dons, if you ever need a care package, just ask.
20:33:32 <ddarius> tail call optimization
20:33:34 <Pseudonym> Vegemite, tim tams, whatever.
20:33:45 <ddarius> Can I get a vegemite care package?
20:33:51 <SamB_XP_> Pseudonym: is vegemite related to spinach?
20:33:52 <Pseudonym> Do you like vegemite?
20:33:54 <dibblego> didn't they ban vegemite in the US?
20:34:03 <ddarius> Pseudonym: I've never had vegemite.
20:34:18 <olsner> what is vegemite?
20:34:23 <ddarius> @google vegemite
20:34:25 <lambdabot> http://www.vegemite.com.au/
20:34:26 <lambdabot> Title: Vegemite
20:34:26 <Pseudonym> Vegemite is a very dark brown goo made from the dregs of the brewing process.
20:34:28 <Nafai> This weird Aussie stuff
20:34:31 <ramza3> dibblego, is that an australian dish or something...yes they banned it but for a strange reason, something folic acid or something
20:34:45 <ramza3> something to do with
20:34:46 <dibblego> ramza3, yes, it was folic acid and the effect on the unborn baby
20:34:54 <Pseudonym> Those who have had kids, think meconium, only brown, salty and edible.
20:35:37 <ddarius> I haven't had kids and I've experienced meconium.
20:35:47 <ramza3> mcdonalds chick mcnuggets are ok, but too much folic acid is not allowed
20:35:50 <Pseudonym> Right, well it's kinda like that.
20:35:58 <Pseudonym> Pretty close resemblance.
20:36:18 <dibblego> I hadn't thought of it like that, 'til now
20:36:25 <dibblego> but you're right
20:36:34 <phobes> sebell: #ubuntu ftw
20:37:45 <mnu> holy god, i've lost my sense of humor.
20:37:53 <mnu> what do I do now?
20:38:03 <Pseudonym> mnu: Quick, go post a comment on youtume!
20:38:05 <Pseudonym> youtube
20:38:38 * mnu goes on youtube, reads a comment or two
20:38:46 <olsner> apparently, that thing about vegemite being banned in the US was just a misunderstanding that got loose
20:38:47 <mnu> shit, now i'm unfunny and depressed.
20:38:53 <Hirvinen> mnu: Since the world must now appear a most bleak and joyless place for you, you might as well end your miserable existence.
20:39:11 <mnu> Hirvinen: :'(
20:40:03 <dibblego> ?hoogle (a -> Bool) -> a -> Bool
20:40:04 <lambdabot> No matches, try a more general search
20:40:19 <ddarius> #haskell: The premier place for psychological help
20:40:25 <Hirvinen> mnu: Alternatively, you might undertake the task of regaining your sense of humor.
20:40:26 <int-e> @type (not .)
20:40:29 <lambdabot> forall a. (a -> Bool) -> a -> Bool
20:40:40 <ddarius> Hirvinen: What do you need a sense of humor for?
20:41:08 <int-e> for survival.
20:41:24 <mnu> ddarius: like a foreskin, you don't know why you need it until you've lost it.
20:41:31 <mnu> see? unfunny...
20:41:59 <Hirvinen> ddarius: We humans have a tendency to derive enjoyment from it.
20:42:00 <int-e> mnu: you might still qualify for bash.org :P
20:42:16 <ddarius> Now even #haskell denizens don't think I'm human.
20:42:38 <Hirvinen> ddarius: Yes. You have failed the Turing test.
20:42:40 <olsner> I wonder if they have vegemite in the store here... probably not though
20:42:42 <mnu> ddarius: That really is low.
20:43:16 <mnu> int-e: that's like... well it's like something, surely.
20:44:22 <olsner> "In April 1984, Vegemite made grocery market history when a 115g jar became the first product in Australia to be electronically scanned at a checkout in a New South Wales' supermarket."
20:44:26 <Hirvinen> ddarius: Would you take pride in being human?
20:44:44 <ddarius> Hirvinen: Should I?  I guess compared to some things.
20:45:28 <Hirvinen> Do you think you should?
20:45:40 <ddarius> I certainly don't think I -should-.
20:47:34 <Hirvinen> True, humans have accomplished some things for which one could feel pride. But a lot of shameful things as well.
20:48:43 <ddarius> "Dijkstra: The general admission of the existence of the software failure in this group of responsible people is the most refreshing experience I have had in a number of years [...]" I <3 Dijkstra
20:49:14 <Hirvinen> Dijkstra <3
20:50:33 <glguy> anyone happen to know how to take a bootable .iso and boot it using a flash drive?
20:51:11 <SamB_XP_> glguy: I don't think it's that simple :-(
20:51:25 <glguy> bah, yeah... but you can't blame me for hoping :)
20:51:35 <SamB_XP_> I bet the reverse is much easier
20:51:36 <glguy> it works for floppy images
20:52:13 <SamB_XP_> oh, I suppose you could do the same thing if it's a floppy-style flashdrive
20:52:18 <olsner> just write the ISO out beginning on block 0?
20:52:24 <olsner> (*could* work)
20:53:48 <Pseudonym> int-e: I like.
20:54:10 <Pseudonym> Finally got to see your solution.
20:54:39 <glguy> here goes nothing :)
20:54:53 <int-e> Pseudonym: :) I take it as evidence that allowing implicit parameters in class contexts isn't entirely unsound.
20:55:21 <int-e> instance contexts.
20:55:27 <Pseudonym> Yeah.
20:55:42 <Pseudonym> I suspect that it's disallowed for the convenience of the compiler writer, not the programmer.
20:55:51 <Pseudonym> The "it's not obvious where to do it" argument.
20:55:59 <Pseudonym> Read: "It's not obvious where we'd implement it."
20:56:16 <ddarius> mkVar at a glance looks very much like what I was talking about with regards to runST
20:56:34 <Hirvinen> olsner: I believe that a BIOS sees a USB mass storage device as a hard drive, so it should have an MBR there.
20:58:05 <int-e> ddarius: yep. (although I hadn't read that comment.)
20:58:11 <Hirvinen> I mean it expects it to behave as a hard drive.
20:58:36 * ddarius is not trying to steal int-e's thunder.
20:59:14 <Pseudonym> Now I'll have to see if this scales to what I want to do with it.
20:59:42 <ddarius> My comment was also directly related to the "necessity" of existentials as mkVar (indirectly) is using an existential type.
21:20:41 <lucca> fungaaa
21:25:45 <dolio> Is that your catch phrase?
21:32:31 <mudge> hi fellow haskellers
21:32:59 <mudge> anyone want to play IRC tick tack toe?
21:33:18 <lambdabot> Sure! But I'll warn you, I play perfectly.
21:33:27 <mudge> haha!
21:33:38 <olsner> woa
21:33:48 <olsner> didn't know lambdabot did that
21:33:51 <mudge> how did lambdabot do that?
21:34:07 <oerjan> the AI keeps improving all the time.
21:34:27 <mudge> okay lambdabot let's play tick tack toe
21:34:44 <mudge> > play tick tack toe
21:34:45 <lambdabot>   Not in scope: `toe'
21:35:05 <mudge> hey I wrote a blog post
21:35:06 <ddarius> For many reasons, I guess lambdabot is technically Australian.
21:35:07 <lambdabot> If you want to shoot yourself in the foot, there are easier ways than tacking your toe.
21:35:34 <oerjan> ddarius: otherwise we'd be signing her up for the US presidential election
21:35:35 <lambdabot> I have no toes.
21:35:38 <mudge> woa,   that was pretty good
21:35:44 <lambdabot> Hey, count me in anyway!
21:35:46 <mudge> its a she?
21:35:50 <lambdabot> Robot '08!
21:36:01 <mudge> holy shit,  its a genius
21:36:07 <ddarius> she
21:36:15 <mudge> she
21:36:20 <mudge> yea, we need some girls in here
21:36:22 <int-e> lambdabot is a she, yeah
21:36:33 <ddarius> We have some women in here.
21:36:35 <lambdabot> Thank you for that clarification, guys.
21:36:42 <mudge> we do?  who?
21:37:08 <Pseudonym> mudge: You also don't know who is and isn't a dog.
21:37:46 <ddarius> mudge: You also don't know who is and isn't a human.  I'm apparently not human.
21:37:47 <int-e> I'm not a dog. (woof)
21:37:51 <oerjan> still got a bit work to do on the cats, though
21:38:20 <allbery_b> meow?
21:38:30 <Pseudonym> int-e: There's an easy way to tell.
21:38:30 <mudge> what are you ddarius?
21:38:35 <Pseudonym> All dogs know the answer to this question:
21:38:46 <oerjan> ddarius is of course dogbert.
21:38:46 <Pseudonym> IS HE A GOOD BOY?! YES?  IS HE A GOOD BOY!!
21:39:29 <ddarius> mudge: To answer in a roundabout way your earlier question, you can probably easily spot a few likely ones just from their nicks alone.
21:40:01 <Pseudonym> Like "lambdabot", for instance.
21:40:13 <[azoic]> ChanServ is a hot one
21:40:53 <mudge> ddarius: I don't see any nicks that say sara or jane or michelle or ..
21:41:41 <int-e> . o O ( let cat = unsafeCoerce# dog )
21:41:48 <ddarius> I know some females currently and not one of them is named Sara, Jane or Michelle.
21:42:15 <mudge> Oh
21:42:28 <ddarius> "Oh"?
21:42:40 <[azoic]> different timespace
21:43:44 <mudge> alright what nick name on haskell is girly?
21:43:49 <mudge> there's boy,  but no girl
21:44:11 <mudge> maybe dibblego
21:44:43 <newsham> phillipa?
21:45:14 <dibblego> you calling me girly?
21:45:14 <jbauman> acura
21:45:25 <sorear> We had Philippa, we have audreyt, there are probably many others
21:46:01 <Pseudonym> http://googlified.com/2007definition-of-math/
21:46:02 <ddarius> sorear: Did Philippa forget to end her IRC session before she died?
21:46:02 <int-e> @seen Philippa:
21:46:03 <lambdabot> Philippa: is in #haskell, #haskell-blah, #haskell-overflow, #haskell-soc and #scannedinavian. I last heard Philippa: speak 14h 14m 10s ago.
21:46:03 <lambdabot> Title: Definition of Math - Googlified
21:46:28 <sorear> ddarius: No, he just had a sex change operation and didn't change his nick.
21:46:59 <newsham> phillipa a sex change?  after arguing for hours with me how there are genders on irc?  I think not.
21:47:07 <sorear> http://lafalafu.com/krc/transition.html
21:47:09 <lambdabot> Title: Infrequently Asked Questions
21:47:10 <mudge> dibblego: sorry about that
21:47:22 <newsham> frequently unasked questions
21:47:29 <ddarius> sorear: That's not Philippa
21:47:43 <sorear> uhh...
21:47:44 <Pseudonym> No, it's catamorphism.
21:47:52 <sorear> *whack* *whack* *whack*
21:47:54 <Cale> sorear: you're maybe thinking of audreyt, who did change his nick when he became a she.
21:48:02 <ddarius> Cale: There's more than one.
21:48:06 <Pseudonym> Who isn't around at the moment.
21:48:16 <ddarius> The gender parity of the universe is balanced.
21:48:26 <Pseudonym> Catamorphism does show up occasionally.
21:48:31 <Cale> ddarius: more than one what?
21:48:33 <mudge> sorear:  yikes
21:48:39 <sorear> Binkley shows up more often.
21:48:55 <Heffalump> Catamorphism's nick is always Binkley, AFAIK.
21:49:52 <ddarius> Cale: transsexual
21:49:54 <Pseudonym> Oh, OK.
21:50:32 <Pseudonym> Heffalump: I get confused, since I stalk her (now him) in so many forums.
21:51:00 <newsham> there are no genders in ascii
21:51:10 <newsham> you're all 7bit blobs to me
21:51:27 <Pseudonym> newsham: Except for those who try to spam your terminal with unicode.
21:51:36 <newsham> my client doesnt do it :)
21:51:37 <Cale> I know a few female Haskell users in real life, none of them seem to be online at the moment.
21:51:49 <ddarius> EBCDIC here
21:52:03 <int-e> Pseudonym, you mean â and â ?
21:52:08 <allbery_b> anyone want to claim radix50?
21:52:32 <Pseudonym> Stop trying to hack my terminal!
21:53:07 <sorear> Why?  Isn't hacking a Good Thing here?
21:53:20 <ddarius> hacking a terminal isn't necessarily
21:53:36 <ddarius> Haskell hacking is good.  Terminal hacking isn't Haskell hacking.
21:53:53 <jbauman> unless your terminal is written in Haskell
21:53:54 <newsham> ebcdic is male, right?
21:54:13 * sorear cracks Pseudonym's terminal with U+06BC HEAVY IRON BALL
21:54:40 <SamB_XP_> sorear: lol
21:55:49 <newsham> does Vty count as {terminal,haskell} hacking?
21:56:13 <ddarius> Now we're hacking sets?!
21:56:18 <int-e> Pseudonym: scnr; that was a U+2640 FEMALE SIGN and U+2642 MALE SIGN
21:56:42 <int-e> (not in that order)
21:56:47 <newsham> ddarius: I see the world through my shell
21:57:18 <int-e> or maybe in that order.
21:57:25 <SamB_XP_> yes, they were
21:57:30 <SamB_XP_> mirror, shield+spear
21:57:45 * int-e hates it when he manages to confuse himself.
22:00:53 <ddarius> Bastard!
22:02:13 <int-e> so I guess newsham isn't human either.
22:03:16 <ddarius> "And the general conclusion is that one has to use contravariance when static type safety is really required [...]" ...
22:04:06 <ddarius> int-e: I vote for hermit crab.
22:06:42 <newsham> human?
22:07:43 <int-e> bipedal life form with little hair, proud for its ability to walk on two legs.
22:08:16 <Pseudonym> Oh, put that on your resume.
22:08:20 <Pseudonym> "Can walk on two legs."
22:08:23 <int-e> :)
22:08:31 <ddarius> "Most of the time..."
22:08:58 <ddarius> humans have quite a lot of hair compared to the vast majority of organisms.
22:09:14 <newsham> *nod* I understand the word, just wondering why I may or may not be human.
22:09:40 <int-e> "<newsham> I see the world through my shell"
22:09:54 <newsham> when you have a hammer everything looks like a nail.
22:10:00 <dibblego> is there a name for when a type parameter becomes monomorphic depending on its return type only?
22:10:16 <newsham> I use sh a lot, but still human (I think)
22:10:22 <ddarius> type parameters don't have return types.
22:10:32 <dibblego> it being the function
22:10:37 <dibblego> ?type read
22:10:39 <lambdabot> forall a. (Read a) => String -> a
22:11:04 <ddarius> dibblego: You mean "instantiated" for "becomes monomorphic" (?)
22:11:10 <dibblego> ddarius, yes
22:11:23 <ddarius> dibblego: No, because it's not anything special.
22:13:03 <ddarius> The answer's the same, but I think what you wanted to ask was "is there a term for when an instance is selected based purely on the return type of a method?"
22:15:41 <int-e> what is the return type of a method? :)
22:16:06 <int-e> if the type is a -> b -> c, is the return type (a -> b -> c), (b -> c) or c? or something else?
22:16:31 <jbauman> d
22:16:41 <ddarius> int-e: Touche
22:20:50 <dibblego> yeah the question doesn't make sense in a Haskell context; sorry for the blub :)
22:35:37 <earnest> hi haskellers
22:38:51 <sorear> ehllo earnest!
22:39:02 <earnest> hey sorear; what's up?
22:39:56 <sorear> dibblego: the subject of females in #haskell came up and mudge cited you as the only possible example :)
22:40:07 <sorear> uh, #haskell? :)
22:40:40 <ddarius> sorear: What the heck?
22:41:05 <takamura> hi
22:47:19 <glguy> would anyone happen to know a good tool for determining if anything is writing to a filesystem?
22:47:31 <allbery_b> lsof, fuser
22:48:00 <allbery_b> for windows, check on sysinternals.com (filemon?)
22:48:15 <glguy> I think fuser will do the trick
22:50:15 <shapr> glguy: strace?
22:50:26 <shapr> takamura: Hey, stop bouncing
22:50:28 <glguy> I'm running this linux install on a flash drive
22:50:44 <glguy> trying to minimize writes
22:50:48 <shapr> oh
22:51:14 <shapr> What about: tmpfs /tmp tmpfs defaults 0 0
22:51:25 <glguy> I have that already
22:51:26 <glguy> :)
22:51:50 <shapr> What about noatime,nodiratime,data=writeback for the flash mount?
22:51:59 <glguy> I only had noatime
22:52:05 <glguy> I'll add the others
22:52:15 <shapr> You can also set the commit time to something huge like 300s
22:52:26 <olsner> or copy everything to tmpfs on boot, copying it back on shutdown after remounting root readonly
22:52:33 <shapr> Yeah, that would be cool.
22:52:36 <glguy> olsner, how do I do that?
22:52:43 <takamura> shapr, sorry, I was trying to reproduce a bug in xmonad, and need to restart X
22:52:48 <shapr> takamura: ok
22:52:52 <glguy> takamura, run irssi in screen :)
22:53:08 <glguy> olsner, is there a good wiki article you know of somewhere maybe
22:53:14 <olsner> glguy: I think you'd need pretty much customization to pull that off though
22:53:15 <takamura> i will do, when I have time to configure it properly
22:53:23 <allbery_b> or $gui_irc_client_of_choice in vnc or freenx
22:53:33 <sorear> glguy: have you heard of kprobes
22:53:34 <sorear> ?
22:53:34 <takamura> for now, i will stick with xchat
22:53:42 <glguy> sorear, I haven't
22:54:12 * allbery_b keeps his xchat in a remote vnc, nobody knows when his DSL goes dodgy except that he may go silent all of a sudden
22:54:15 <sorear> glguy: look into that, it could be very informative (dunno just how recent a kernel you need; but think "safe, kernel breakpoints"
22:54:32 <glguy> sorear, I'm running a really recent kernel, this is an ArchLinux install :)
22:55:35 <shapr> Has anyone tried to figure out why Frag won't build on 64-bit linux?
22:56:19 <olsner> (actually, my suggestion might cause a net increase in the number of writes, since almost the entire flash would be rewritten on shutdown)
22:56:21 <glguy> shapr: where does the data=writeback go?
22:56:29 <glguy> olsner, good point
22:56:52 <shapr> /dev/sda6 / ext3 defaults,errors=remount-ro,noatime,nodiratime,data=writeback 0 1
22:56:52 <glguy> when I add that to my options list
22:56:54 <shapr> That's what I have.
22:57:00 <glguy> it seemed to fail
22:57:01 <glguy> hmm
22:57:15 <olsner> is it an ext3 filesystem?
22:57:32 <glguy> yeah
22:57:53 <glguy> shouldn't mount -o remount /
22:57:56 <glguy> work?
22:58:35 <olsner> I guess it could be ignoring some options when remounting, but that would be stupid
22:58:38 <shapr> yeah
22:59:13 <glguy> is unionfs the right way to mount a tmpfs over the top of a ext3 based one
22:59:18 <glguy> so that changes become temporary
22:59:24 <glguy> and only in memory
22:59:29 * shapr dunno
22:59:30 <olsner> sounds nifty
22:59:52 <olsner> and semantically equivalent (modulo bugs) to the copy-to-tmpfs suggestion, I guess
23:00:09 <glguy> olsner, well... i wouldn't be copy to filessytem when done
23:00:19 <glguy> it would be for things that I didn't care about across boots
23:01:19 <olsner> you could do something crazy like archiving the tmpfs onto a new file at the end of the flash ram when shutting down
23:02:00 * glguy tests something
23:02:07 <sorear> olsner: ever heard of jffs/jffs2/yaffs?  it's been done
23:02:28 <SamB_XP_> yet another f***in filesystem?
23:02:44 <ddarius> SamB_XP_: Gotta catch 'em all!
23:02:56 <olsner> sorear: now that you mention it, I have heard of those, just didn't think of them... I don't use flash a lot
23:03:17 <olsner> (it's much funnier to think of crazy init shell scripts)
23:05:31 <glguy> hmm... booting with those options set caused problems :)
23:05:38 <glguy> like it decided *not* to mount my /
23:05:46 <shapr> Oh, you need to boot with data=writeback too
23:06:18 <shapr> root=/dev/sda6 ro quiet rootflags=data=writeback
23:06:27 <shapr> That's what I have in menu.lst for grub.
23:06:34 <glguy> ah, maybe that's the trick
23:06:36 <shapr> But I think you'll only need to add rootflags=data=writeback
23:06:40 <glguy> adding those to my fstab makes my fstab not work
23:07:09 <glguy> the commit=300 worked though
23:07:50 <conal> has anyone here build ghc from sources?  the build isn't finding some cygwin include files, and i don't know how/where to say to look in my c:/cygwin/usr/include.
23:08:31 <shapr> glguy: Lots of nifty things to learn :-)
23:08:43 <shapr> glguy: I'm a fanatic about tunin my linux system, any tips I may have missed?
23:09:29 <glguy> I don't know much about tuning :)
23:09:40 <glguy> I'm just focusing on minimizing disk activity
23:09:48 <taruti> noatime.
23:09:56 <glguy> yeah, I had that one from the beginning
23:10:19 <glguy> anything important that I do on thsi machine is stored in a git or darcs repository
23:10:23 <glguy> and its a laptop
23:10:27 <glguy> so i have battery backup
23:10:38 <glguy> so I'm not worried about data loss as much
23:10:57 <glguy> (and its easy to keep a working backup image of a 4gig flash drive)
23:13:25 <shapr> I did get my memory to do 5-5-5-12 @ 800MHz with 1.95 volts. I ran 24 hours of memtest+ with no problems.
23:16:19 <earnest> 100% download debian cd 1!
23:16:30 <earnest> firefox lies actually
23:16:34 <shapr> earnest: Are you learning Haskell?
23:16:35 <earnest> it says 100% but it's downloading some bytes
23:16:43 <earnest> oh, im so sorry :)
23:16:48 <earnest> i'm speaking in the wrong channel :)
23:17:02 <earnest> but yeah, i am learning haskell
23:17:04 <shapr> Admittedly, I learned Haskell after installing Debian, so...
23:17:24 <earnest> hehe :) i bought a hard drive, a nic card...
23:17:34 <earnest> and hopefully i will be able to get on to a newer system
23:17:41 <earnest> i have been using freebsd 4.11 since 2002
23:17:54 <earnest> ghc wont even work in freebsd 4
23:18:11 <SamB_XP_> shapr: me too
23:18:13 <earnest> well, at least the ports won't even try
23:18:50 <shapr> earnest: Are you learning Haskell for business or pleasure?
23:19:57 * glguy would be running openbsd if this laptop would allow for it
23:20:14 <mudge> hi shapr
23:20:29 <shapr> hiya mudge, how's code?
23:20:57 <earnest> shapr: for both
23:21:07 <earnest> well, it depends on your point of view
23:21:10 <mudge> good,  recently been reading about algebriac types in Simon Thompsons's Haskell book
23:21:31 <earnest> shapr: what about you? did learn for biz or pleasure?
23:22:48 <mudge> shapr: I'm doing all the exercises in the Programming Haskell book, by Hutton,   i'm on chapter 8
23:22:56 <mudge> shapr: how's your projects?
23:23:09 <shapr> earnest: I learned Haskell for pleasure, but now it's my job!
23:23:28 <shapr> mudge: I got a working binding to Selenium written on Friday, I've been trying to make it pretty now.
23:23:54 <shapr> earnest: Are you getting a job doing Haskell also?
23:23:55 <earnest> shapr: hehe, you see what happens?
23:24:03 <earnest> shapr: no
23:24:10 <earnest> i don't really want to work as a programmer
23:24:25 <shapr> What's your job now?
23:24:33 <earnest> programmer :)
23:24:53 <shapr> What do you want to do?
23:25:05 <shapr> I got pretty sick of programming before I got a Haskell job.
23:25:11 <earnest> i'd like to study more and teach lots of things
23:25:15 <mudge> shapr: woop!   shapr, do you work at Galois?
23:25:27 <earnest> what you mean by sick?
23:25:37 <earnest> you mean like work sucked before you got a haskell job?
23:25:44 <earnest> that would make a lot of sense
23:25:48 <shapr> I was full of resentment because I had to implement low quality answers to the wrong questions!
23:25:53 <earnest> i feel pretty sick at work
23:26:01 <earnest> i am full of resentment lately
23:26:03 <shapr> mudge: Nah, I work for HAppS LLC, owned by alexj
23:26:22 <olsner> 'twould be cool to have a Haskell job
23:26:22 <mudge> shapr:  oh awesome,  working on a haskell web framework,    sweet
23:26:32 <shapr> mudge: Though I think Galois is the largest Haskell employer.
23:26:35 <earnest> what's resentment? i think it's something like a bad feeling towards... anger?
23:26:43 <shapr> yeah
23:26:50 <earnest> yeah, i'd like to have a haskell job
23:26:53 <earnest> in which my job would be:
23:27:02 <sorear> Wishing you had done something different in the past, approx
23:27:04 <earnest> learn from these great minds so that you can help them
23:27:10 <earnest> so that they can do something more interesting
23:27:15 <mudge> earnest: what kind of programming is your programming job?
23:27:40 <earnest> i fix bugs in an NDMP server written in C++
23:27:49 <earnest>               a NDMP
23:27:56 <int-e> an is fine
23:27:57 <shapr> wow
23:28:00 <earnest> it's a server for a backup application
23:28:16 <earnest> the whole system is disgusting, though
23:28:20 <olsner> an "en"DMP
23:28:36 <shapr> olsner: or "a network..."
23:28:37 <earnest> hehe, that's probably what caused my error :P
23:28:43 * ddarius thinks sorear is broken.
23:28:44 <olsner> disgusting code, or disgusting system?
23:28:52 <shapr> kanske
23:28:54 <earnest> probably both
23:29:03 <earnest> but i wouldn't dare to say the code is disgusting
23:29:09 <earnest> but it is a bit
23:29:24 <earnest> huge tabs, long lines... i hate that
23:29:33 <shapr> Is the code elegant?
23:29:33 <earnest> but i won't complain about aesthetics of code
23:29:44 <earnest> am I able to judge?
23:29:52 <mudge> shapr: is the happs code elegant?
23:29:55 <dibblego> @remember <shapr> Is the [C++] code elegant?
23:29:56 <lambdabot> Done.
23:30:00 <earnest> the system works in netware, windows, lots of unix systems...
23:30:08 <sorear> @forget <shapr> Is the [C++] code elegant?
23:30:09 <lambdabot> Done.
23:30:17 <sorear> @remember shapr Is the [C++] code elegant?
23:30:18 <lambdabot> Done.
23:30:23 <shapr> ah
23:30:24 <sorear> @quote <shapr>
23:30:25 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
23:30:29 <sorear> @quote
23:30:29 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
23:30:30 <shapr> I never said that!
23:30:35 <earnest> so there's a lot of wrapping in the code
23:30:46 <shapr> mudge: Yeah, HAppS is pretty good.
23:30:47 <earnest> but deep in the code you see lots of #ifdef
23:30:51 <sorear> @seen allbery_b
23:30:52 <lambdabot> allbery_b is in #xmonad, #ghc, #haskell-blah, #haskell-overflow, #perl6 and #haskell. I last heard allbery_b speak 36m 40s ago.
23:30:59 <mudge> i think sorear is broken
23:30:59 <olsner> working with unaesthetic code is akin to working in an ugly office... not good for motivation
23:31:00 <earnest> and i dont think there was much effort into avoiding them
23:31:10 <earnest> my office is horrible, really
23:31:15 <shapr> mudge: It could be better, but it's still 0.9.x so I think it's good enough.
23:31:15 <earnest> it's full of cubicles
23:31:28 <earnest> those white lights...
23:31:35 <shapr> Come back from the light!
23:31:36 <mudge> earnest: your work sucks
23:31:38 <olsner> although simply ignoring the ugliness of the code is likely to make it less demotivating
23:31:41 <SamB_XP_> earnest: it would be worse if you got rid of the cubicles
23:31:46 <SamB_XP_> then you'd just have a huge room
23:31:53 <earnest> the reason why i don't quite tomorrow is because i am close to paying my last semester (tuition)
23:31:54 <shapr> Actually, I like that.
23:32:07 <shapr> A big open room of programmers means communication is easy.
23:32:13 <earnest> olsner: true; i ignore that
23:32:17 <shapr> You can throw paperwads at someone to get their attention.
23:32:26 <SamB_XP_> shapr: might depend on how big...
23:32:31 <shapr> Yeah, true.
23:32:38 <int-e> paper airplanes then ;)
23:32:39 <SamB_XP_> shapr: and wouldn't nerf missles be easier to target?
23:32:39 <sorear> nerfguns, then
23:32:39 <earnest> i am not really around programmers
23:32:44 <mudge> throwing things sounds like fun
23:32:45 <earnest> the programmers work somewhere else
23:32:45 <olsner> then again, the amount of mental energy wasted on ignoring the ugliness of the code could drain you
23:32:45 <ddarius> shapr: It's much challenging and thus more entertaining to have to contend with the walls.
23:32:53 <earnest> i belong in some technical support group
23:32:58 <shapr> SamB_XP_: Yeah, but shirt and tie places often discourage the whole cubicle toy culture.
23:33:06 <mudge> shapr: how does happs display html?
23:33:12 <earnest> and people there dont program
23:33:18 <earnest> they just want to do their jobs and go home
23:33:29 <glguy> the nerf gun comes out regularly at my work
23:33:31 <SamB_XP_> earnest: what the heck are you there for?
23:33:33 <shapr> mudge: Right now each datatype is automatically converted into xml, and xslt is used to markup those xml results.
23:33:45 <earnest> olsner: true; it will drain me over time
23:33:50 <glguy> our CEO sent out a link to an office toys site to give people a fair chance at arming themselves
23:33:50 <earnest> olsner: but i will quit as soon as i can
23:33:51 <olsner> btw, why do shirt-and-tie workplaces exist? it just seems like oppressive and counter-productive regulation
23:33:52 <shapr> earnest: That's sad :-(
23:33:57 <earnest> SamB_XP_: i need to pay tuition :|
23:34:01 <SamB_XP_> shapr: anyway, my only point was that they fly truer than paperwads
23:34:01 <shapr> "Do the job and go home" is a very depressing thing.
23:34:07 <shapr> SamB_XP_: I completely agree.
23:34:09 <earnest> very depressing!
23:34:13 <mudge> shapr: cool
23:34:14 <ddarius> "But these arguments may still be too abstract for object-oriented practitioners."
23:34:32 <SamB_XP_> shapr: primarily because they have a higher mass/air resistance ratio
23:34:34 <shapr> earnest: Bug fixing is programming.
23:34:36 <int-e> ddarius: where are these quotes from?
23:34:41 <earnest> my days there are counted, tho
23:34:48 <mudge> glguy: i want to work where you work
23:34:49 <shapr> numbered?
23:35:04 <earnest> shapr: true; i take my job as serious as i can
23:35:08 <earnest> but it's very depressing
23:35:08 * ddarius enjoys going into work with no shirt and no tie.
23:35:12 <earnest> i know very little of the system
23:35:22 <shapr> I have to crawl all the way from my bed to my couch to work.
23:35:22 <earnest> no one answers my questions from a programmer's view
23:35:30 <earnest> even because the people i have there to ask are not programmers
23:35:30 <shapr> earnest: Wow, suck.
23:35:40 <earnest> i'm pretty new in the company
23:35:48 <earnest> so i have actually fixed very little stuff
23:35:49 <Adamant> I have no idea why anyone would make a programmer wear a shirt and tie, unless they are interacting with clients that expect it
23:36:02 <earnest> most of time is spent reading the code and understanding it
23:36:11 <ddarius> int-e: http://citeseer.ist.psu.edu/24009.html
23:36:13 <lambdabot> Title: Covariance and Contravariance: Conflict without a Cause - Castagna (ResearchInde ...
23:36:18 <shapr> Yeah, that's often the hardest part of any programming, understanding the code.
23:36:26 <earnest> true
23:36:27 <SamB_XP_> earnest: did they stick you with the wrong job description?
23:36:32 <earnest> yeah
23:36:35 <earnest> they did
23:36:42 <Tac-Tics> stupid hsql
23:36:45 <dons> http://programming.reddit.com/info/2l9g6/comments
23:36:45 <int-e> ddarius: thanks
23:36:46 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
23:36:46 <SamB_XP_> :-(
23:36:46 <Tac-Tics> segfault =-/
23:36:46 <lambdabot> Title: Hot off the press: Towards Open Type Functions for Haskell :: PDF (reddit.com)
23:36:48 <dons> cool stuff.
23:36:54 <earnest> for example
23:37:02 <SamB_XP_> hmm, I need to add "sleep" to mine...
23:37:03 <glguy> dons: isn't it about your bed time? ;-)
23:37:04 <shapr> earnest: So how'd you find #haskell ?
23:37:06 <glguy> ?localtime dons
23:37:07 <lambdabot> Local time for dons is Sun Sep  2 23:35:10 2007
23:37:13 <SamB_XP_> maybe if I did that I'd remember to sleep...
23:37:15 <earnest> i found haskell through the haskell cafe mail list
23:37:17 <mudge> shapr:  yea, I'd rather write stuff from scratch than have to maintain and add functionality to existing systems that I didn't write
23:37:34 <earnest> some guy posted how popular the channel has become
23:37:39 <shapr> mudge: I understand that feeling, so I try to write code in such a way that I would enjoy maintaining it.
23:37:42 <dons> glguy: yeah, though i'm not terribly tired yet. we're still a few hours shifted west :)
23:37:44 <ddarius> He probably found Haskell through incessant reddit posting.
23:37:45 <olsner> ?users
23:37:45 <earnest> i access the mail list through a cool free nntp service
23:37:45 <lambdabot> Maximum users seen in #haskell: 394, currently: 352 (89.3%), active: 15 (4.3%)
23:37:50 <SamB_XP_> earnest: you mean you found #haskell through that?
23:37:51 <dons> heya mudge
23:37:57 <mudge> hey dons
23:37:58 <SamB_XP_> earnest: you mean gmane
23:38:02 <olsner> huh? I thought we were just over 400 some time ago?
23:38:08 <earnest> SamB_XP_: yeah; that = the gmane-haskell-cafe-mail-list-nttpwise
23:38:11 <mudge> shapr: makes sense,  I want to maintain that code
23:38:11 <olsner> (lambdabot reset?)
23:38:13 <earnest> SamB_XP_: yeah :)
23:38:17 <SamB_XP_> olsner: lambdabot is very forgetful lately
23:38:17 <ddarius> olsner: Yes.
23:38:19 <earnest> gmane is very useful
23:38:23 <earnest> i hate mail lists nowadays
23:38:26 <dons> olsner: yeah, though lambdabot crashed :) 419 is the high score
23:38:28 <ddarius> olsner: 419 specifically
23:38:39 <olsner> (stereo ;-)
23:38:39 <SamB_XP_> okay, to bed now...
23:38:47 <shapr> mudge: I don't always succeed, but I do try.
23:38:48 <earnest> SamB_XP_: g'night
23:38:53 <dons> night shapr
23:38:54 <dons> SamB_XP_:
23:39:06 <olsner> mailing lists are instant time sinks
23:39:09 <shapr> mudge: And whenever I find code that wouldn't want to maintain, I try to figure out why I wouldn't want to maintain it.
23:39:20 <dons> unlike irc, hey olsner ? :)
23:39:33 <earnest> shapr: why? that helps you to work out the psychology of it?
23:39:42 <olsner> I remember when I subscribed to haskell-cafe... all I ever did was read haskell mails... point taken about IRC though ;-)
23:40:18 <mudge> dons: I wonder how many people find out about haskell through all the posts you put on reddit
23:40:28 <shapr> I was reading "The Practice of Programming" by Ritchie and Pike... and they mention higher order functions in chapter 3!
23:40:43 <shapr> earnest: Yeah, everything can be taken as either a good or bad example, and sometimes both in different places.
23:40:46 <earnest> i find IRC worse than mail lists for technical discussions; im slow; i need time to read and write calmly; having a long conversations on IRC is really difficult; and i like the archival of nntp (or a mail list)
23:40:53 <dons> mudge: yeah, unknown. but certainly useful. that's one of the few connections between the wealth of material produced by the haskell community, and the broader programming world
23:41:26 <mudge> dons: cool, to a good degree, I found out about haskell through reddit
23:42:19 * olsner suddenly recalled his first haskell project and subsequent first visit to #haskell
23:42:22 <shapr> earnest: Like, significant names are good is most places, but in 'pattern' functions like map and filter, single letters don't cover up the essence.
23:42:40 <earnest> single letters? give an example?
23:42:52 <shapr> @src map
23:42:53 <lambdabot> map _ []     = []
23:42:53 <lambdabot> map f (x:xs) = f x : map f xs
23:43:09 <earnest> and you think we should avoid f and x and perhaps xs too?
23:43:12 <earnest> we should write longer names?
23:43:29 <olsner> map function (element:elements) = function element : map function elements
23:43:33 <olsner> yay!
23:43:47 <glguy> rest_of_the_elements maybe?
23:43:50 <shapr> No, in 'traversal essence' functions like map and filter and etc, single letters expose the essence rather than hide it.
23:43:52 <glguy> every_thing_else
23:44:12 <glguy> the_function_to_be_applied_to_each_element perhaps?
23:44:15 * dblhelix 's favorite identifier is __
23:44:26 <int-e> olsner: unreadable :)
23:44:26 <olsner> :t \__ -> __
23:44:28 <johnnowak> the_elements_formerly_known_as_cdr
23:44:29 <lambdabot> forall t. t -> t
23:44:30 <shapr> earnest: map and filter are more like 'patterns for wiring your program together'
23:44:51 <earnest> shapr: i don't get how different it would be to use longer names in their definition, though
23:44:52 <olsner> int-e: exactly :)
23:44:58 * glguy is confused. Who was proposing we write longer names for f and x in map?
23:45:03 <earnest> shapr: but i prefer the single letters, btw
23:45:10 <earnest> shapr: at least in that case (map)
23:45:47 <shapr> glguy: I was saying that significant names are good in many places, but in traversal defining functions they don't add significance.
23:46:02 <shapr> glguy: Because the 'wiring pattern' is the significant part.
23:46:12 <earnest> what's to traversal define a function?
23:46:34 <olsner> is there a lambdabot command to list the instances of a type?
23:46:40 <glguy> ?instances-importing
23:46:41 <lambdabot> Plugin `instances' failed with: IRCRaised Prelude.last: empty list
23:46:45 <int-e> I also like ? as a generic binary operator. foldr (?) a (x:xs) = a ? foldr x xs; foldr (?) a [] = a
23:46:46 <ddarius> shapr: To me the relevant concern is the polymorphism.  What's a meaningful name for something that could be anything or any function?
23:46:46 <glguy> or ?instances for short
23:46:51 <olsner> ?instances Either
23:46:52 <lambdabot> Couldn't find class `Either'. Try @instances-importing
23:46:59 <olsner> ?instances-importing Either
23:47:00 <lambdabot> Couldn't find class `Either'. Try @instances-importing
23:47:10 <glguy> olsner, it operates on classes
23:47:17 <glguy> I think I misunderstood your question
23:47:22 <shapr> earnest: I mean that the very most basic code patterns are most significant for their pattern, rather than their specific use in one place.
23:47:23 <Adamant> the non-significant names is probably the part of Haskell that annoys me the most. It's interesting to see the reasoning why they have been adopted.
23:47:30 <glguy> and tells you what types are instances of that class
23:47:34 <takamura> mmm, odd, i cant post
23:47:35 <olsner> I want the classes a given type has an instance for.. the reverse of @instances, if you may
23:47:36 <takamura> oh
23:47:37 <earnest> shapr: i see
23:47:39 <takamura> now i can
23:47:43 <takamura> stupid xchat
23:47:48 <glguy> olsner, lambdabot doesn't do that, GHCi will with :i
23:47:55 <shapr> Adamant: What do you think? Is the insignificant names a good thing for map/filter/etc ?
23:48:18 <ddarius> Adament: What would be better names for the arguments of map (since that the current example)?
23:48:19 <glguy> olsner, Either isn't defined as a Monad on its own, mtl defines a broken version, MonadLib defines a better one
23:48:28 <earnest> shapr: i suppose that'd be the case of all ``too generic'' functions
23:48:30 <glguy> if you want to use it as a Maybe with error object
23:48:34 <Adamant> shapr, I see your reasoning. but not using significant names drives me nuts at this point in pretty much any language.
23:48:48 <takamura> When reading papers, I allways mentally change the letters to suit Spanish names
23:48:54 <olsner> glguy: wow, that was precisely the usage I was looking for more information on ;-)
23:48:57 <Adamant> it's a gut response, not a reasoned one.
23:49:01 <shapr> Adamant: May I suggest that filter and map at least, are using sufficiently significant names?
23:49:08 <dons> bed time, glguy :) night!
23:49:11 <takamura> sometimes it is very annoying
23:49:13 <glguy> olsner, long hours of IRC use gives one mind reading powers
23:49:16 <glguy> dons good night!
23:49:20 <ddarius> Adamant: 1) significant does not mean long
23:49:23 <earnest> Adamant: shapr: i actually think that the f in map is pretty significant
23:49:24 <takamura> good night
23:49:31 <shapr> earnest: Yeah, that's a good point.
23:49:36 <earnest> after all, mathematicians always choose f for function
23:49:38 <shapr> f usually means 'function'
23:49:39 <ddarius> 2) There is very little "significant" to attribute to names of polymorphic arguments.
23:49:55 <earnest> and map is really applying a function to a list of values
23:50:04 <int-e> compare to  map a (b:c) = a b : map a c; map _ [] = [] <-- bad style.
23:50:08 <glguy> naw, it is to lift a function into List :)
23:50:11 <ddarius> 3) type information provides much of the remaining
23:50:15 <ddarius> int-e: See SICP.
23:50:23 <ddarius> (or at least the video lectures)
23:50:26 <earnest> int-e: agreed; that's much less clear than @src map
23:50:43 <earnest> i look at ``a'' thinking ``that's a constant''
23:50:48 <earnest> it's sort of automatic already
23:50:56 <olsner> anyway, I think the convention of using one of Left or Right as an error message is a wtf in itself - there should be a separate Success a | Error String for that usage
23:51:04 <glguy> the f in map f (x:xs) is also a constant :)
23:51:22 <shapr> Everything is a constant in Haskell!
23:51:29 <earnest> glguy: hehe, i guess :)
23:51:52 <glguy> Haskell is value-oriented-programming, the first half of "voodoo"
23:51:55 <int-e> @quote back away
23:51:55 <glguy> err
23:51:56 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
23:52:00 <glguy> whatever :)
23:52:01 <shapr> @quote varying
23:52:02 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
23:52:03 <glguy> first third ;)
23:52:03 <shapr> aww
23:52:04 <olsner> (and possibly an Either type class with relevant instances, but I guess that could lead to lots of other headaches)
23:52:07 <earnest> yeah, everything is a constant, huh?
23:52:10 <earnest> that's very weird
23:52:19 <earnest> i have no practice of thinking of such things
23:52:20 <shapr> earnest: Well it makes sense...
23:52:26 <earnest> i think in imperative ways
23:52:39 * glguy is much more lazy
23:52:41 <olsner> earnest: everything is passed reference-to-const
23:52:49 <olsner> (to think of it in C++ terms)
23:52:50 <shapr> I really like the way PaulAJ described it, he said that whenever you overwrite a value in an imperative language, you're making a garbage collection decision.
23:52:56 <earnest> my ways of thinking comes from ``the c programming language''
23:53:04 <earnest> olsner: okay
23:53:15 <olsner> (or in some semantically mostly-equivalent way)
23:53:26 <glguy> reference-to-possibly-unevalutated-const
23:53:27 <glguy> ;)
23:53:49 <olsner> const thunk<T> &
23:54:07 <glguy> I wonder what would break if I mounted my root filesystem ro
23:54:13 <glguy> say.... right now
23:54:29 <olsner> you wouldn't be able to if files are open read-write I think
23:54:34 <glguy> hmm
23:54:35 <olsner> try it!
23:54:45 * jql watches quietly
23:54:47 <earnest> i currently have a task to do which i would choose my lovely AWK language to work on, but i will choose haskell to see if i can begin to catch on to the ways of haskell and get used to the syntax; i'm still pretty zero in everything; im reading hudak's book (SOE), but only writing my own code will get me there; i will explain my task after i get something to eat/drink; it's pretty easy to do; you guys can give me a functional way to look 
23:54:47 <earnest> roblem
23:54:51 <glguy> its busy :(
23:55:07 <glguy> I'd have to fuser -k a bunch of stuff
23:55:07 <olsner> fuser -> kill -> try again :P
23:55:14 <int-e> earnest: did that end in 'look at the problem'?
23:55:36 <earnest> int-e: you got it; my gnu emacs just cuts the message
23:55:46 <earnest> i should patch this software
23:55:56 <earnest> to cut at the last word and write a ``...''
23:55:59 <shapr> Are you using zenirc?
23:56:03 <earnest> i'm using rcirc
23:56:06 <glguy> if emacs doesn't work for you, try linux or openbsd maybe
23:56:09 <shapr> I'd suggest ERC
23:56:10 <earnest> hehe :)
23:56:20 * shapr smacks glguy with some elithp
23:56:23 <olsner> if it's an AWK task, (print . f . map words . lines) =<< getContents is probably a good start - just fill in f ;-)
23:56:36 <earnest> yeah, ERC is popular, but... i like rcirc... and it comes with the gnu emacs; i really like default things
23:56:44 <glguy> olsner, you trying to rewrite interact?
23:57:00 <olsner> :t interact
23:57:03 <lambdabot> (String -> String) -> IO ()
23:57:05 <earnest> yeah, interact is very useful :) but anyway, let me go get a pepsi and something to eat
23:57:16 <olsner> okay, interact (show . f . map words . lines)
23:58:08 * glguy permits earnest to get a Pepsi and something to eat
23:58:33 <earnest> thanks :)
23:58:37 <earnest> i will eat later
23:58:45 <earnest> i will fry some ribs later on
23:58:45 <olsner> it would be neat if there was an shellInteract (or similar) that does the action for stdin and all files named by non-dashed arguments
23:58:58 <earnest> you know, i just recalled the worst thing about the company i work for
23:59:09 <shapr> earnest: Do you live in the southeast USA?
23:59:11 <earnest> we don't really have internet access
23:59:14 <earnest> i like in new jersey
23:59:14 <glguy> olsner, I have one of those on hpaste somewhere
23:59:22 <earnest> shapr: what about you/
23:59:27 <earnest>                      ?
23:59:36 <earnest> s/like/live/
23:59:41 <glguy> olsner, in the spirit of Ruby maybe? (that's the example I saw it in)
23:59:55 <shapr> earnest: I live in Birmingham, Alabama. Ribs are popular here, so I wondered.
