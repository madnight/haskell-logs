01:05:14 <matt__r> :hoogle
01:05:58 <matt__r> @hoogle [String] -> String
01:05:59 <lambdabot> Prelude.unlines :: [String] -> String
01:05:59 <lambdabot> Prelude.unwords :: [String] -> String
01:05:59 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
01:07:09 <matt__r> @type id
01:07:12 <lambdabot> forall a. a -> a
01:07:23 <oerjan> also concat
01:37:26 <hpaste>  hgolden pasted "Error compiling hsgnutls-0.2.3" at http://hpaste.org/2639
01:49:13 <crazy_coder> hello everyone
01:49:38 <crazy_coder> I am trying to write this tictactoe game in Haskell using GTKhs
01:50:26 <crazy_coder> i am having problems with the idea of updating the state of the board (i.e the 3X3 matrix of buttons I made in Glade)
01:51:24 <crazy_coder> should I change the glade file contents as the game progresses ?
01:51:33 <Saizan> crazy_coder: have you seen the tictactoe demo that comes with gtk2hs?
01:51:40 <crazy_coder> no
01:52:10 <crazy_coder> Its not in the docs
01:53:09 <Saizan> it's inside demo/noughty
01:53:32 <crazy_coder> ok I saw it
01:54:08 <crazy_coder> Thanks
01:54:14 <crazy_coder> I'll check it
01:54:14 <Saizan> np
02:28:53 <wli> One could always try Connect Four or Othello if the Tic-Tac-Toe example is too overdone.
02:30:03 <wli> The whole board game schtick is overdone, though.
02:30:55 * olliej just took more than a minute to work out wli was talking abou :D
02:34:18 <wli> Was it so complicated?
02:38:10 <olliej> wli: no, but hadn't been foollowing #haskell
02:38:30 <olliej> and apparently am to tired to read back chat that is visible on the screen on the first go :D
02:39:35 <wli> How about instead of board games, fashion design!
02:41:08 <olliej> heh
02:41:31 <olliej> erk
02:41:34 * olliej sleeps
02:41:36 <wli> Design new outfits and dress up animated models in them.
02:43:40 <wli> Okay, that's quite a bit more complicated than Tic Tac Toe, Connect Four, or Othello. But it is vastly more interesting from a programming point of view as well.
02:49:08 <Boney> sometimes people just go to far..
02:51:19 <wli> Am I going too far?
02:56:52 <wli> There's geometry, ontology, and relatively serious HCI having to do with how you get adequate and usable user input into the thing at all.
02:57:12 <wli> So I'd say it is vastly more interesting than board games.
04:01:29 <EvilTerran> **poke**
04:02:11 <Japsu> In Finnish, "poke" is also a slang word for "porn".
04:02:38 <EvilTerran> in English, it's also a slang word for "have sex with".
04:02:44 <Japsu> heh
04:02:49 <EvilTerran> i wonder if those're somehow related.
04:11:28 <EvilTerran> okay, i count 9 files in this here cabal bundle that're probably necessary for getting it to work. 7 of them have no chance of running on windows without cygwin.
04:11:39 * EvilTerran concludes that cabal is *nix-only.
04:15:06 * EvilTerran also concludes that this makes actually doing anything useful with haskell on windows Very Difficult.
04:17:00 * roconnor has a theory as to why haskell isn't used to develop large programs
04:17:08 <wli> Do tell.
04:17:21 * mlesniak is also listening
04:17:24 <roconnor> haskell almost forces you to think carefully and create a well designed program
04:17:39 <roconnor> but no one knows how to develop large well designed programs
04:17:45 <roconnor> so it is hard to write them in haskell.
04:17:47 <matthew-_> define large?
04:18:03 <wli> Well, that's largely worked out for compilers.
04:18:03 <matthew-_> I've done programs with one other person that hit 10kloc with no docs
04:18:47 <roconnor> wli: web browsers, compilers, spreadsheets
04:18:53 <roconnor> gimp
04:19:06 <roconnor> I consider those as examples of large programs
04:19:11 <wli> Spreadsheets probably don't really count since they're interpreters of sorts.
04:19:26 <roconnor> okay, nix spreadsheets
04:19:49 <wli> Compilers are out because they're so very well understood as far as structure goes it's not going to hurt them.
04:19:56 * EvilTerran would like a spreadsheet where he could write haskell in the cells
04:20:01 <wli> Interpreters in like fashion.
04:20:06 <matthew-_> I don't think a functional programmer would have designed html in the first place
04:20:14 <roconnor> wli: probably why compliers written in haskell exist.
04:20:17 <matthew-_> so the complexities of rendering it wouldn't have occured
04:20:33 <roconnor> matthew-_: really?  I <3 HTML
04:20:43 <roconnor> and SGML even more
04:20:59 <matthew-_> HTML would be fine if it was strictly defined
04:21:06 <matthew-_> and if CSS was even vaguely sane
04:21:12 <EvilTerran> i'd happily get to writing this, but i'd want to use Tk, and in order to do that, i either need the existing Haskell/Tcl bindings (that're old and non-idiomatic), c2hs (which requires cabal, so is no-go on windows), or to do the bindings manually =/
04:21:18 <roconnor> what do you mean strictly defined?
04:21:28 <matthew-_> roconnor: no "lax" modes in browsers
04:21:36 * EvilTerran would rather write in s-exp than in HTML
04:21:36 <wli> roconnor: How about my suggestion of an application to design clothing and so on?
04:21:42 <matthew-_> no "trying to make the best job of badly defined pages"
04:21:51 <EvilTerran> tag soup! quirks mode!
04:22:07 <matthew-_> yeah, that stuff. Ban it.
04:22:12 <roconnor> wli: clothing design seems comperable to photoshop/gimp in scope.
04:22:15 <EvilTerran> but seriously. my main gripe with XML is how stupid verbose it is
04:22:28 <wli> roconnor: No, it's more of a CAD/CAM -type application.
04:22:32 <EvilTerran> well, after how mind-numbingly verbose the standards are.
04:22:53 <wli> roconnor: Quite distinct from image processing per se.
04:22:59 <roconnor> wli: okay, maybe illustrator is more analogus.  But yes, these are good examples of large applications.
04:23:58 <roconnor> EvilTerran: a while back I had the idea of a Haskell RFC project to give Haskell reference programs to all effective RFCs.
04:24:53 <wli> roconnor: Where would you start on the clothing design bit? It appears to be somewhat at odds with typical CAD/CAM in various respects, so it's not entirely obvious from the CAD/CAM precedents.
04:25:21 <roconnor> wli: what do you mean, where whould I start?
04:25:30 <wli> roconnor: UI is probably a somewhat deep question as well.
04:25:42 <wli> roconnor: As far as the "large program design" bit goes.
04:26:01 <roconnor> wli: GUI is a deep unsolved problem, which is presumably why there is not decent haskell implementation.
04:26:39 <roconnor> and by ``deep unsolved problem'' I mean, I don't know the answer. :)
04:26:55 <roconnor> I don't even know what the answer might be.
04:27:50 <EvilTerran> CAD/CAM very much qualifies as Big Software... the impression i get is that it's some of the largest end-user software
04:28:05 <EvilTerran> especially for UI. i've seen some UI monstrosities in CAD/CAM.
04:29:05 * EvilTerran finds CAD UIs only work if there's a well-written command-line. otherwise I spend most of the time looking through samey-looking buttons on the gazillion toolbars.
04:29:32 <EvilTerran> (see: autocad. you *can* do everything from the toolbars, but you *really* want to learn to use its commandline)
04:30:31 <matthew-_> roconnor: A friend an I are trying to do a gui tk in opengl. Some of the issues that come up really have no good answer
04:30:51 <matthew-_> you end up saying "well, which of these things does in make more sense to ignore in this situation?"
04:31:05 <matthew-_> which is entirely unsatisfying
04:31:11 <roconnor> yep, deep unsolved problem.
04:31:32 <matthew-_> layout isn't really the issue - that's solveable
04:31:36 <matthew-_> it's event handling
04:31:47 <roconnor> all we can do is wait for a genius to solve our problems.
04:31:50 <fasta> EvilTerran: I think most autocad users cannot use the command line like a programmer would
04:32:12 <EvilTerran> i found myself using the commandline almost exclusively
04:32:24 <matthew-_> oooo! Is there anyone here with knowledge of the haskell X bindings?
04:32:35 <EvilTerran> if i couldn't remember the command, i'd look that up and use it, so i could use it in future, rather than using the oolbar button
04:32:58 <roconnor> matthew-_: obviously comonads are the solution :P
04:33:02 <EvilTerran> we need an isomorphism between events and category theory!
04:33:17 <fasta> EvilTerran: I almost never used AutoCad, but when someone had a problem, I just looked up the command in the manual and did it. They just thought of the command line as "complicated".
04:33:44 <EvilTerran> i know that feeling. some people have an irrational fear of non-gooey interfaces.
04:34:07 <EvilTerran> me, i like being able to have twice as much of the page visible 'cos i'd hidden all the toolbars.
04:34:15 <fasta> I developed the opposite, since so many GUIs are so bad and crash often.
04:34:26 <matthew-_> EvilTerran: I have an irrational fear of guis
04:34:42 <EvilTerran> autocad's gui is very much <enormous grid of similar-looking buttons>
04:35:38 <fasta> EvilTerran: Visual Studio is like that too.
04:36:14 <EvilTerran> ew, visual studio
04:36:25 <fasta> s/Visual Studio/every large Windows program
04:36:37 * EvilTerran distrusts programming languages that are well-nigh impossible to use without an IDE
04:37:09 * EvilTerran also distrusts programs that create a mass of "project files" with no readily-available explanation of what each does
04:37:10 <fasta> I start to distrust complicated languages like Haskell ;)
04:37:11 <roconnor> really?
04:37:35 <roconnor> i think the future of programming languages is going to be more strongly linked to an IDE.
04:37:41 <fasta> They seem too difficult to implement correctly.
04:37:44 <roconnor> fucking strings as programs
04:37:50 <EvilTerran> ''i only wanted to do "hello world"! why are there six files in this folder?!''
04:38:07 <roconnor> granted, files are dumb.
04:38:08 <EvilTerran> roconnor, it reeks of DWIM to me, i guess
04:38:12 <matthew-_> EvilTerran: it's called abstraction!
04:38:41 <fasta> The future of programming languages will always be in the future.
04:38:48 <EvilTerran> flowcharts-as-programming is a fairly classic example of a bad idea that looks good on paper
04:39:06 <matthew-_> fsms have their uses
04:39:18 <matthew-_> protocols are quite usefully specified as fsms
04:39:23 <EvilTerran> yes, but writing Enterprise Software is not one of them
04:39:31 <matthew-_> well quite.
04:39:36 <roconnor> as I understand, Epigram (and Agda) are strongly tied to an IDE.
04:39:46 <roconnor> specify a function
04:39:58 <matthew-_> hah! yeah, Epigram is heavily tied to xemacs
04:40:04 <roconnor> fill it in
04:40:23 <fasta> Epigram never worked out of the box for me, so imho, it doesn't exist.
04:40:29 <matthew-_> but it's not like you'd try to write enterprise software in epigram anyway
04:40:33 * EvilTerran would quite like, say, a haskell IDE, but i really like that you don't *need* one
04:40:39 <matthew-_> fasta: you should try harder ;)
04:40:56 <roconnor> matthew-_: In the future we will write enterprise software in epigram's decendents
04:41:06 <fasta> matthew-_: I tried two times, there is no reason to put in more effort. Probably the project is dead is a few years, too.
04:41:35 <matthew-_> roconnor: I very much hope so
04:41:36 <EvilTerran> "k, i've typed this term, and its context, but i need some kind of transformation function to make them mesh together. hey, IDE, what's a function ::(...Foo -> ... -> Bar)?
04:41:43 <roconnor> I also think that will will need IDE support to get version control working properly.
04:41:52 <matthew-_> fasta: meh. It's still cool to play with even if the devel.blog is a bit quite
04:41:57 <roconnor> in particular distriubted version control.
04:42:05 <matthew-_> fasta: and the last I heard, they did have funding to crack on with epigram 2
04:42:30 <fasta> matthew-_: ok, I will put it differently: universities do not build products.
04:42:46 <matthew-_> fasta: you're right. BSD and X did not come from universities
04:43:01 <matthew-_> EvilTerran: The nice thing about epigram is that it's more proactive than that - it just prompts you to fill in the blanks
04:43:19 <EvilTerran> a souped-up IDE could do that for most languages
04:43:23 <wli> Epigram has a structure editor?
04:43:30 <EvilTerran> especially ones with funky type systems like Haskell
04:43:35 <fasta> matthew-_: those were actually practically needed for lots of people.
04:43:41 <roconnor> Epigram requires a structure editor IIRC.
04:43:49 <wli> Structure editors are what these are called.
04:43:50 * EvilTerran would also like on-the-fly typechecking etc
04:43:57 <fasta> matthew-_: and the best way to do operating systems still needed to be invented.
04:44:03 <fasta> matthew-_: and the same for X.
04:44:13 <EvilTerran> which could be Great With A Big G in haskell, given how powerful the type system is
04:44:33 <fasta> matthew-_: nobody in universities need another programming language; they have Python and it works.
04:44:41 <wli> Thus far the only "radical" proposals I've seen to improve X are castrating it with respect to network transparency.
04:44:42 <roconnor> one problem with OS's and X, is that the best way to do them keeps changing with the hardware.
04:46:52 <EvilTerran> does it strike no-one else as odd that (the Windows binary, at least) of ghc comes with OpenGL but not GLUT?
04:47:00 <roconnor> I have another theory.  What if the entire universe was made up of tiny virbrating strings?
04:47:31 <mr_tenor> EvilTerran: I had to go to some totally nonoficial webpage to get Windows GLUT stuff.
04:47:44 <EvilTerran> mr_tenor, that's the impression i get, too.
04:47:56 <mr_tenor> i don't understand how these projects are organised
04:47:59 * EvilTerran is still quite annoyed about the Cabal => *nix things
04:48:05 <fasta> EvilTerran: report a feature request/bug if the Linux version does it differently.
04:48:18 <fasta> EvilTerran: don't worry, Cabal doesn't work in the HEAD.
04:48:34 <fasta> EvilTerran: or at least it's not compatible with e.g. Edison.
04:48:35 <mr_tenor> i'm a Debian person, so i'm used to things not being easily obtainable and working right away ;)
04:48:41 <EvilTerran> i don't know if the Linux one is different - i haven't looked at it, as i'm, er, on windows
04:48:44 <mr_tenor> "not used"... gah
04:49:21 <fasta> EvilTerran: is there any reason you are on Windows?
04:49:51 <EvilTerran> because it came with my laptop, a lot of software that i like is windows only, and i happen to quite like XP pro?
04:49:52 <fasta> EvilTerran: AutoCad? ;)
04:50:18 <fasta> Amazing, that one can actually like XP Pro.
04:50:26 <fasta> Then again, I did once too.
04:50:30 <int-e> is there any reason to dislike mingw?
04:50:36 <fasta> int-e: yes
04:51:06 <EvilTerran> i have nothing against the mingw port of gcc. MSYS makes me want to kill people, however.
04:51:07 <fasta> int-e: it's 10 times slower than the native tools, so I heard, and from practice I know it was slower last time I used it.
04:51:39 <EvilTerran> ah, yes, actually, i do have something against mingw gcc. it's big, it's slow, and it produces larger executables than the native tools
04:51:45 <fasta> int-e: and it's probably not as complete as a real environment.
04:51:52 <EvilTerran> even with optimisations disabled
04:52:05 <EvilTerran> by quite a large factor
04:52:14 <int-e> minimal = unusable. makes sense.
04:52:53 <fasta> int-e: ?
04:53:03 <fasta> int-e: who said it was unusable?
04:53:09 <int-e> that was a comment about MSYS.
04:53:35 <EvilTerran> however, if a *nix project has been actually ported to windows (cygwin DOES NOT COUNT), it will almost certainly only build on mingw gcc
04:53:44 <int-e> nobody explicitely said that it was unusable.
04:55:31 <EvilTerran> i think it may've been implied by the bile i've been spouting
04:57:54 <hpaste>  mauke pasted "I didn't know this was possible" at http://hpaste.org/2640
04:58:32 <EvilTerran> higher-order types?
04:58:49 <EvilTerran> instance Num [Char]?
04:59:16 <hpaste>  mauke annotated "I didn't know this was possible" with "implementation" at http://hpaste.org/2640#a1
05:01:27 <scook0> mauke: nice
05:02:45 <scook0> have you read SYB?
05:02:53 <mauke> not really
05:04:17 <scook0> among other things, it mentions a reference implementation of cast using unsafeCoerce and typeclasses
05:04:21 <scook0> (iirc)
05:04:58 <scook0> basically, you use the two Typeable instances to obtain "type representation" values
05:05:23 <scook0> if the typereps match, you can coerce values of b to values of a, since the types are the same
05:05:29 <scook0> if not, you just return Nothing
05:06:38 <mauke> yeah, that's what Data.Typeable.cast does
05:21:38 * EvilTerran prods the Tcl/Tk headers
05:21:41 * EvilTerran despairs
06:04:33 <kayess_> I'm fiddling around with something and getting myself confused. It starts with partial application like this: let papply ( f, a ) b = f a b
06:05:06 <kayess_> Next up I define a binary add function: let add ( a, b ) = a + b
06:05:18 <kayess_> But what I can't do is this: let inc = papply ( add, 1 )
06:05:28 <kayess_> I get an error message I completely fail to understand
06:06:17 <hkBst> kayess_: because papply assume that add is defined   add a b = a + b
06:06:21 <kayess_> However this seems to work: let inc = papply ( (+), 1 )
06:06:45 <kayess_> hkBst: Right. Got it! thanks
06:06:51 <EvilTerran> ?type let add ( a, b ) = a + b in add
06:06:53 <EvilTerran> ?type (+)
06:06:55 <lambdabot> forall t. (Num t) => (t, t) -> t
06:06:56 <lambdabot> forall a. (Num a) => a -> a -> a
06:07:54 <kayess_> If I wanted to use my version of add that takes a tuple then I need to change papply in some way, but I'm not sure how
06:08:06 <mrd> curry
06:08:55 <mauke> let papply (f, a) b = f (a, b)
06:08:55 <mrd> your version of add = uncurry (+)
06:09:02 <kayess_> I think it's all starting to dawn on me now
06:09:15 <kayess_> I want this: let papply ( f, a ) b = f ( a, b )
06:09:28 <mauke> but what's wrong with papply f a b = f a b?
06:09:49 <kayess_> Isn't that just an identity function?
06:10:02 <mauke> yes
06:10:12 <mauke> in fact, I don't see why you need papply at all
06:10:12 <mrd> haskell already does this stuff for you
06:10:56 <EvilTerran> > let add a b = a + b in add 1
06:10:59 <lambdabot>  <Integer -> Integer>
06:11:01 <EvilTerran> > (+) 1
06:11:03 <lambdabot>  <Integer -> Integer>
06:11:04 <kayess_> I'm actually trying to work something out in C++, but the types are bit more verbose there so wanted to see if I could describe it in Haskell first. This is why I'm working with tupled arguments
06:11:10 <mauke> haha
06:11:18 <mauke> oh yeah
06:11:32 <mauke> C++ template types are awesome
06:11:36 <mauke> where awesome = no please no
06:11:49 <mrd> then you should expand it into papply (f, a) = \ b -> f (a, b)
06:12:34 <kayess_> I've written a papply and curry, but it seems to me that if I curry papply then I should get something interesting out, but I couldn't work out the C++ type so want to get GHCi to tell me what it thinks
06:12:41 <EvilTerran> duck typing!
06:13:33 <mrd> @djinn quack -> quack
06:13:34 <lambdabot> f a = a
06:14:59 <mauke> template<typename A, typename B, typename C> function<A (C)> curry(function<A (B, C)> f, B x) { return f(x, _1); }  // no idea if this actually works
06:17:16 <kayess_> It's similar to that. Do you really want to see the prototype? :)
06:18:18 <Botje> @djinn lead -> gold
06:18:18 <lambdabot> -- f cannot be realized.
06:18:22 <Botje> damn.
06:18:58 <gpi5> Is there a function to iterate on lists, similar but more complex than scanr of the type :: (a->b->c)->(a->b->b)->[a]->b->([c], b)
06:19:03 <kayess_> mauke: template< typename R, typename V1, typename V2 > boost::function< boost::function< R ( V1 ) > ( V2 ) > curry( boost::function< R ( V1, V2 ) > f );
06:19:15 <gpi5> Or how would you do that?
06:19:18 <gpi5> Thanks
06:19:37 <kayess_> mauke: You even nearly get the -> in the function type :)
06:20:40 <Botje> gpi5: and what would that do?
06:21:52 <der_eq> gpi5: that looks like a variant of mapAccumL
06:22:01 <der_eq> or R
06:25:01 <kayess_> Anybody recognise this type signature? ((t, t1) -> t2, t) -> t1 -> t2
06:26:34 <gpi5> der_eq: yes indeed, I think I can use that. Thanks.
06:27:32 <tuxplorer> I have a string coming in as an argument. based on some regex and stuff I want to do a type inference on it.. say some strings should belong to a type A and some to type B, type C, etc. which are custom defined data types, and I want to do a type inference on it.. is there some pointers to help me with it?
06:28:25 <tuxplorer> say I want to classify them as words, phrases, metaphors(if they have some comparison conjunctives), etc.. etc..
06:30:46 <sciolizer> @djinn ((t, t1) -> t2, t) -> t1 -> t2
06:30:46 <lambdabot> f (a, b) c = a (b, c)
06:31:27 <Botje> tuxplorer: create a datatype to hold the string
06:31:53 <Botje> something like data Linguistic = Word String | Phrase String | Metaphor String
06:32:01 <Trixsey> min (head list1) (head list2) -- This works in the terminal but not in my .hs file, any idea why?
06:32:07 <tuxplorer> Botje: without calling the appropriate constructor, I want the compiler to decide the type..
06:32:19 <Trixsey> nvm
06:32:21 <Trixsey> solved it =)
06:32:23 <Botje> don't think ot can do that for you
06:32:40 <gpi5> @djinn (a,b)->a
06:32:40 <lambdabot> f (a, _) = a
06:32:55 <Botje> perhaps with some kind of read hack, but still
06:33:30 <gpi5> Is there a defined function for f (a, _) = a ?
06:33:48 <Botje> fst
06:33:50 <Botje> :t fst
06:33:52 <lambdabot> forall a b. (a, b) -> a
06:34:01 <gpi5> thx
06:34:06 <Botje> you can ask hoogle too
06:34:10 <tuxplorer> Botje: oh! there is nothing like a function that can be written to tell the compiler? like how we use ord to do the order recognition? well yeah I understand that Ord just returns  a order data type to the functions.. but still
06:34:11 <Botje> @hoogle (a,b) -> a
06:34:12 <lambdabot> Prelude.fst :: (a, b) -> a
06:34:12 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
06:34:12 <lambdabot> Prelude.snd :: (a, b) -> b
06:34:52 <Botje> tuxplorer: best thing I can think of is a read function that does the classification for you
06:35:02 <Botje> but then IANA Haskell Wizard
06:35:30 <tuxplorer> Botje: oh! ok.. will try.. Thanks
06:36:56 <mauke> @. djinn type ((t, t1) -> t2, t) -> t1 -> t2
06:36:58 <lambdabot> Cannot parse command
06:37:05 <mauke> er
06:37:09 <mauke> @. pl djinn ((t, t1) -> t2, t) -> t1 -> t2
06:37:10 <lambdabot> f = uncurry ((. (,)) . (.))
06:38:42 <kayess_> let papply ( f, a ) b = f ( a, b ) - mauke this is what your C++ prototype describes, partial application rather than curry
06:39:07 <mauke> oh yeah
06:39:13 <mauke> it's only the same thing in haskell
06:39:37 <mauke> @vixen pervasive currying is pervasive
06:39:37 <lambdabot> I can't of anything nice to say about myself
06:39:43 <kayess_> Yeah. That's been one of the reasons I've been getting confused. Everything normally comes pre-curried in Haskell
06:40:38 <kayess_> I knew there was an identity hiding in there, I just couldn't work out what it was. I thought it was on the C++ curry, but it turns out to be on papply
06:40:58 <kayess_> let cppcurry f ( a, b ) = papply ( f, a ) b
06:41:42 <kayess_> :t cppcurry papply  - gives the same as :t papply
06:41:44 <lambdabot> Not in scope: `cppcurry'
06:41:45 <lambdabot>  
06:41:45 <lambdabot> <interactive>:1:9: Not in scope: `papply'
06:42:17 <kayess_> And so does :t cppcurry $ cppcurry papply
06:42:46 <mauke> > sqrt `id` 2
06:42:49 <lambdabot>  1.4142135623730951
06:44:35 <Trixsey> >min 2 3
06:44:39 <Trixsey> > min 2 3
06:44:41 <lambdabot>  2
06:44:43 <Trixsey> :D
06:44:47 <Trixsey> ITS ALIVE! :D
06:44:57 <Trixsey> > min 3 2
06:44:58 <lambdabot>  2
06:45:00 <Trixsey> YAY :D
06:45:09 <mauke> > let min 2 3 = 3 in min 2 3
06:45:11 <lambdabot>  3
06:45:27 <Trixsey> :(
06:45:28 <astrolabe> Is there any way of hiding methods of a superclass?  Does that make sense?
06:45:39 <Trixsey> min 2 3
06:45:42 <Trixsey> > min 2 3
06:45:43 <lambdabot>  2
06:45:47 <Trixsey> :o
06:46:10 <mauke> astrolabe: I don't think so
06:46:15 <Trixsey> mauke, why is overriding possible?
06:46:18 <Trixsey> :P
06:46:28 <mauke> > let min = "hello, world" in min
06:46:30 <lambdabot>  "hello, world"
06:46:38 <Trixsey> oh you used it as a variable?
06:46:41 <mauke> yes
06:46:46 <mauke> I temporarily redefined min
06:47:15 <mauke> > let min 2 3 = 3 in min 1 1
06:47:17 <lambdabot>   Non-exhaustive patterns in function min
06:47:37 <mauke> this is actually an (incomplete) local function that happens to be called 'min'
06:48:57 <Botje> > let min = max in min 2 3
06:48:58 <lambdabot>  3
06:51:56 <mauke> > let 2 + 2 = "cornflakes" in 2 + 2
06:51:58 <lambdabot>  "cornflakes"
07:00:41 <Igloo> Does anyone know if I can convince GHC 6.6.1 to accept something equivalent to this? http://hpaste.org/2641
07:01:07 <Igloo> (a GADTs problem)
07:02:22 <matthew-_> Igloo: I don't think so.
07:02:47 <matthew-_> not without putting Eq a on foo
07:02:56 <Igloo> Ho humm. I wonder if waiting for 6.8 is an option.
07:03:12 <matthew-_> is the rc out yet?
07:03:17 <Igloo> No
07:03:27 <fasta> Igloo: have you seen #ghc already?
07:04:01 <Igloo> fasta: I'm not dealing with that ATM
07:06:35 <cinimod> Igloo: I can't see that working. Won't you need a "proof" that a is in Eq? ie foo :: Eq a => etc
07:06:59 <Igloo> cinimod: There's one in EqInstance a. It works in the HEAD
07:10:44 <cinimod> Igloo: I've fallen over the same sort of issue. I assumed you had to have a proof.
07:10:54 <Igloo> There is a proof
07:11:26 <cinimod> I can see that now which is why I said "I assume"
07:11:36 <Igloo> Ah, OK
07:11:44 <cinimod> Bother I have to go now just as this was turning into an interesting discussion
07:11:57 <Igloo> Hmm, not even http://hpaste.org/2641#a1 works in 6.6.1
07:12:20 <cinimod> I'd really like to see the formal proof rules for GADTs and typeclasses then you could work out whether something should or should not compile
07:12:23 <Igloo> I don't think there's much left to discuss. It just doesn't work in 6.6.1 AFAICS  :-)
07:12:32 <cinimod> byes
07:12:36 <Igloo> See ya
07:12:59 <Igloo> I think the rules are in a paper by SPJ (probably coauthored with others), BTW
07:13:06 <int-e> Igloo: http://hackage.haskell.org/trac/ghc/ticket/289
07:13:07 <lambdabot> Title: #289 (class context restrictions in GADT types not assumed) - GHC - Trac
07:13:20 <int-e> fixed after 6.6.1 came out
07:14:29 <int-e> and I don't know whether it's possible to express this in previous versions.
07:16:23 <Igloo> *nod*, none of the possible workarounds I've thought of work
07:16:37 <fasta> What are the uses of that feature?
07:17:01 <fasta> I see what it should do, I just see no practical use.
07:17:02 <int-e> you can pack different type class dictionaries into the same type
07:17:19 <int-e> imagine an OrdInstance :: Ord a => OrdInstance a  alternative.
07:17:33 <int-e> and a function that matches on both alternatives.
07:18:09 <int-e> in 6.6.1 you'd have to write foo :: (Ord a, Eq a) => Instances a -> Bool  which is more limiting than you want.
07:18:10 <fasta> Yes, I fully understood "you can... same type", before you said so.
07:19:50 <fasta> But if you never write down the type signatures in the first place, then what's the application?
07:20:23 <fasta> Oh, I see.
07:20:39 <fasta> It solves something the compiler should do by itself already, imho.
07:20:56 <fasta> Currently the compiler doesn't repeat the class context.
07:21:15 <fasta> As a user you need to repeat it in an instance declaration.
07:21:28 <fasta> This would make that a bit easier.
07:21:58 <doserj> the problem is not only in typing the class context
07:23:02 <doserj> the problem is that there are sensible types that you cannot express in 6.6.1
07:24:04 <fasta> doserj: like?
07:24:19 <doserj> look at int-e's example
07:24:46 <int-e> fasta: I really wouldn't want the compiler to make impredicativity implicit. I'd like to have class synonyms to save some typing instead.
07:26:44 <fasta> Ok, I see what int-e meant now. I haven't run into that problem, I guess.
07:26:58 <int-e> (we could argue about class contexts on data declarations though ... data Ord a => Foo a = Foo a)
07:27:24 <Igloo> I thought everyone agreed that they are just broken in H98
07:27:28 <int-e> right now the Ord a =>  serves no real purpose at all but is syntactically allowed.
07:27:39 <Igloo> GHC does the sensible thing for type declared with GADT syntax, I believe
07:28:15 <fasta> Why is it a sensible thing that the instances for (Monad m) => class Bar m a need to repeat the Monad constraint?
07:29:09 <fasta> An IDE could simply look up the context if the user would be interested in the class context.
07:30:30 <int-e> well, if you read   instance xxx => Foo yyy where ... as "if xxx are satisfied then we can construct an instance of Foo for yyy" (and I do) then that makes perfect sense.
07:31:01 <fasta> Was getNumElements discussed on the libraries list?
07:31:45 <fasta> Google doesn't return anything for it.
07:32:53 <fasta> If it's not, then why was it included? Shouldn't all libary changes go through the libraries mailing list?
07:33:33 <fasta> library*
07:34:45 <int-e> http://www.haskell.org/pipermail/libraries/2007-August/007907.html
07:34:47 <lambdabot> Title: Proposal: Make arrays safer, http://tinyurl.com/ysr2qq
07:35:42 <fasta> int-e: a discussion with one whole user!
07:36:14 <int-e> good enough, it was publicly announced, and it had a 14 days deadline.
07:36:18 <fasta> Not that I think these minor things should be discussed, though. Discussion only adds overhead for these trivial things.
07:36:33 <fasta> int-e: fair enough.
07:36:54 <kristnjov> yo
07:36:59 <kristnjov> how do i convert an integer to a string?
07:37:09 <Igloo> show
07:37:11 <fasta> > show (1::Integer)
07:37:13 <lambdabot>  "1"
07:37:14 <mauke> > show 42
07:37:16 <lambdabot>  "42"
07:37:24 <gpi5> Is 'map $ f . g $ l' same as 'map (f.g) l'?
07:37:43 <fasta> If everyone produced their own Haskell implementation, we would now have 100 broken implementations. Hmm, that's not a good idea. ;)
07:37:49 <mauke> gpi5: no
07:38:01 <mauke> it's map (f (g l)), I think
07:38:11 <Igloo> It is
07:38:26 <wli> :t \f g l -> (map $ f . g $ l)
07:38:28 <lambdabot> forall a b b1 a1. (b1 -> a -> b) -> (a1 -> b1) -> a1 -> [a] -> [b]
07:38:40 <gpi5> Ok..
07:38:47 <wli> :t \f g l -> (map (f . g) l)
07:38:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> [a] -> [c]
07:39:01 <kristnjov> putStrLn (show (nPrime number)::Integer) <- what am i doing wrong?
07:39:18 <mauke> :t \f g l -> (map $ f . g $ l) `asTypeOf` (map (f.g) l)
07:39:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
07:39:20 <lambdabot>       Expected type: [a]
07:39:29 <mauke> kristnjov: what's the ::Integer for?
07:39:34 <kristnjov> mauke, dunno mate
07:39:38 <Trixsey> rofl
07:39:39 <mauke> then why did you put it in?
07:39:48 <kristnjov> dunno
07:39:56 <kristnjov> doesn't work without it either
07:40:01 <mauke> what's the error?
07:40:12 <kristnjov> Couldn't match `Integer' against `String'
07:40:21 <kristnjov> oops f*ck
07:40:22 <kristnjov> my bad
07:40:32 <kristnjov> i have to convert number to an Integer
07:40:39 <mauke> > read "42"
07:40:41 <lambdabot>  42
07:41:00 <kristnjov> oh lawd it works!
07:41:11 <kristnjov> thanks mate
07:41:31 <mauke> yay
07:42:04 <kristnjov> i recall that one can use . to put functions together, kind of like putStrLn (show (nPrime (read (number)))) into (putStrLn . show . nPrime . read) number but it doesn't seem to work
07:42:32 <Igloo> Why not?
07:42:39 <kristnjov> dunno, i was hoping you guys knew
07:42:40 <Igloo> putStrLn . show == print, by the way
07:42:44 <kristnjov> oh thanks
07:43:02 <mauke> kristnjov: we can't see the error message your compiler gives you
07:43:17 <kristnjov> yeah i know, sorry, i'll try to ask questions better
07:43:20 <mauke> :t \number -> (putStrLn . show . nPrime . read) number
07:43:23 <lambdabot> Not in scope: `nPrime'
07:43:30 <mauke> :t \nPrime number -> (putStrLn . show . nPrime . read) number
07:43:32 <lambdabot> forall b c. (Show c, Read b) => (b -> c) -> String -> IO ()
07:43:33 <Saizan> show . read --> ambiguous type variable
07:43:43 <kristnjov> hey whaddya know it works now
07:43:50 <mauke> Saizan: depends on the type of nPrime
07:44:08 <kristnjov> nPrime is Integer -> Integer
07:44:18 <kristnjov> it finds the nth prime number
07:44:41 <kristnjov> trying to find the 10001'th prime number in less than 20 seconds using haskell
07:44:52 <kristnjov> and obviously my algorithm isn't good enough
07:45:20 <mauke> > groupBy (((>1).).gcd) [2..] !! 10000
07:45:22 <lambdabot>  [10002]
07:45:29 <kristnjov> uhhhhh what.
07:45:34 <gkr> >2
07:45:34 <mauke> > nubBy (((>1).).gcd) [2..] !! 10000
07:45:38 <lambdabot> Terminated
07:45:40 <kristnjov> okay.....
07:45:42 <mauke> yeah, that's too slow
07:46:05 <kristnjov> i don't get it at all
07:46:14 <kristnjov> perhaps i didn't explain my problem thoroughly
07:46:28 <mauke> that was the "confuse newbies" version of computing primes
07:46:38 <kristnjov> the first prime number is 2, the second is 3, etc. and i want to find the 10001'th prime number
07:46:44 <mauke> > nubBy (((>1).).gcd) [2..]
07:46:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
07:46:47 <kristnjov> what's gcd?
07:46:52 <kristnjov> what the heck
07:46:54 <mauke> greatest common divisor
07:47:00 <kristnjov> oh
07:47:14 <kristnjov> i was more into a method taking three input parameters and using three guards
07:47:55 <kristnjov> my hugs won't find nubBy
07:48:02 <EvilTerran> (((>1).).gcd) x y  =  ((>1).) (gcd x) y  =  (>1) (gcd x y)  =  gcd x y > 1
07:48:06 <mrd> import List
07:48:09 <kristnjov> thanks
07:48:41 * mrd wonders what import Liszt would get you
07:48:50 <mauke> Piano numbers
07:49:38 <wli> It'd drag Chopin and Mary Ann Evans Cross in with it.
07:50:04 <EvilTerran> mrd, mauke: *groan*
07:50:15 <mauke> success! :-)
07:52:29 <EvilTerran> > succ "ess"
07:52:30 <lambdabot>   add an instance declaration for (Enum [Char])
07:52:30 <lambdabot>     In the expression: succ "...
07:52:44 <mrd> > succ 355
07:52:45 <lambdabot>  356
07:53:25 <mauke> EvilTerran: sorry, you need Perl for that :-)
07:54:00 <mrd> hm, couldn't a reasonable definition for String be made based on the Enum instance for Char
07:54:10 <kristnjov> no!
07:54:13 <kristnjov> nevar!
07:54:17 <mrd> actually, instance (Enum a) => Enum [a]
07:54:55 <wli> It'd be easy enough to make generic Enum t => Enum [t] instances, but they'd often clash with more specific instances you'd want, like (Enum t, Bounded t) => Enum [t]
07:55:19 <fasta> overlapping instances
07:55:22 * fasta ducks
07:55:36 <mrd> no ducking typing
07:55:43 <wli> The lack of scoping for classes and instances really hurts.
07:56:29 <mrd> it's more than you can define instances for data types of other modules
07:56:36 <mrd> (or other packages)
07:57:00 <mrd> but packages aren't part of Haskell
07:57:01 <EvilTerran> overlapping instances doesn't look at the class context anyway, AFAIK
07:57:31 <mrd> is there a package proposal for Haskell'?
07:58:01 <mrd> fasta: i was able to compile a simply typed lambda calculus interpreter with my today-compiled ghc
07:58:14 <Igloo> mrd: Why do you need one?
07:58:23 <Igloo> (package proposal)
07:58:39 <mrd> seems like a good thing to standardize for a number of reasons
07:58:47 <wli> Even if there isn't a higher-order first-class module system en route, there should really be some sort of stopgap measure to get some kind of control over the scopes of classes, instances, and the like.
07:59:07 <mrd> and also then you could define semantics of instances inside and outside of packages
07:59:28 <Igloo> The package system is invisible as far as all the language semantics are concerned
07:59:35 <mrd> right now
08:00:18 <Igloo> There are problems if you start coping instances. John Meacham sent a mail about it to the haskell-prime list a while ago, IIRC
08:00:23 <Igloo> s/coping/scoping/
08:00:33 * mrd goes to look that up
08:02:36 <blablabla> Please help me: http://tinyurl.com/2yu2te
08:02:43 <lambdabot> Title: Pennergame
08:02:57 <wli> Igloo: I have a vague idea that it might not play well with e.g. existential types.
08:03:35 --- mode: ChanServ set +o Igloo
08:03:42 <EvilTerran> hm. i know what that fellow needs! a +b!
08:03:53 --- mode: Igloo set +b *!*@p54B6E4C0.dip.t-dialin.net
08:05:04 <Igloo> wli: I think his example was what happened if you built a set with one Ord instance and then used it with a different Ord instance
08:06:36 <mrd> really the solution is functors.  i don't think people would go for that.
08:10:29 <Botje> re that blablabla guy: just click the "diesen link als spam melden"
08:10:41 <Botje> with a bit of luck his account 'll be closed.
08:10:58 <EvilTerran> reported him? awesome.
08:11:09 <Botje> yeah
08:11:10 <Botje> join me >:)
08:11:34 <Botje> click it, select IRC, copypaste the tinyurl thing, and hit the left button (not the one that says abbrechen)
08:11:41 * EvilTerran has nothing but scorn for people who do those stupid "trick people into visiting our site" things
08:11:43 <Botje> idiot spammers deserve punishment
08:12:54 <EvilTerran> s/idiot//
08:13:10 <Botje> :)
08:13:42 <mauke> oh crap
08:13:47 <mauke> try.hs:72:8: My brain just exploded.
08:13:59 <Botje> you turned the tables on haskell? :)
08:14:01 <cognominal_> is a ghc compiled haskell program standalone?
08:14:07 <Botje> cognominal_: yes
08:14:11 <EvilTerran> @ghc
08:14:12 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
08:14:15 <mauke> Botje: yes! I beat ghc!
08:14:45 <mrd> cognominal_: well, i haven't seen a ghc compiled program with 2 legs yet
08:15:13 <nominolo> cognominal, but ghc supports dlls now
08:15:31 <mrd> but you can use 'ldd' and 'file' on any executable to see how it is linked to the system
08:16:06 <cognominal_> yes, I meant except for loading the "standard" share libraries...
08:16:33 <mrd> the only additional one on my system is libgmp
08:16:50 <mrd> the GNU Multiprecision arithmetic library
08:17:24 <nominolo> oh, that's LGPL, isn't it?
08:17:36 <mrd> yea
08:18:01 <cognominal_> I like to have the adavantage of an interpreted environment for development but to avoid the associated hassle in production (dealing with all sort of dependancies)
08:18:17 <cognominal_> s/adavantage/advantage/
08:18:45 <cognominal_> I am reading the TH turorials and think I will soon have a lot of fun
08:18:49 <mrd> consider that darcs is commonly distributed as a single exe file
08:19:14 <nominolo> TH is evil
08:19:39 <fasta> TH is not documented and has arbitrary limitations.
08:19:57 <nominolo> and doesn't support many extensions
08:19:58 <Saizan> ?docs Language.Haskell.TH
08:19:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
08:23:27 <cognominal_> nominolo, can you elaborate? I don't mind being evil, the sinner has often more fun...
08:25:03 <EvilTerran> TH doesn't support type splices yet, and could really do with pattern splices as well
08:25:18 <EvilTerran> i'm sure it also has other limitations i'm not yet aware of
08:26:43 <nominolo> cognominal, it's incredibly hard to get some piece of code to work with TH.  Usually, you try to quote the code you want to generate, then pprint the syntax tree, and try to generate that tree yourself.
08:27:01 <nominolo> quoting works, sometimes, but often-times not
08:27:03 <gpi5> Is it possible to see the C code generated by GHC (just being curious..)?
08:27:11 <nominolo> gpi5, yes
08:27:35 <nominolo> gpi5, see the various -dump options
08:27:39 <gpi5> Any command line option to do that?
08:27:43 <gpi5> Ok, thanks
08:28:11 <nominolo> cognominal, last time i checked it also didn't support GADTs or similar
08:28:19 <Saizan> nominolo: have you seen Language.Haskell.TH.Helper inside the derive package? it's very helpful :)
08:28:28 <nominolo> cognominal, so i guess, it depends on what you want to do
08:28:35 <nominolo> Saizan, no
08:28:49 <mauke> gpi5: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
08:28:51 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/ydk2e6
08:28:52 <nominolo> Saizan, i never really felt I needed TH since then
08:28:55 <EvilTerran> ghc -fvia-C -keep-hc-files works, i think
08:28:57 <cognominal_> nominolo, I know that audreyt uses HT and many advanced extensions
08:29:01 <mauke> it's -C
08:29:32 <nominolo> Saizan, and that is despite me having been a long-time Lisper
08:29:37 <cognominal_> but she a higher order programmer, so she may get away with things that would deter the mere mortals
08:29:52 <nominolo> (ok, well, "long-time" = 3 years)
08:30:26 <nominolo> cognominal_, well, i guess, it's worth a try
08:30:54 <Saizan> heh, i think there're 2 major uses of TH, parsing data at compile time (like regexes) and deriving instances
08:31:07 <cognominal_> dealing with ASTs always give a deeper undersstanding of a language
08:31:28 <nominolo> cognominal, well, at least of it's syntax
08:31:42 <nominolo> but haskell's syntax is pretty complex
08:32:24 <cognominal_> I am coming form the Perl world and interested by Perl6. I am not afraid of syntax :)
08:32:25 <EvilTerran> i wouldn't fancy parsing an existing AST of the sort TH uses
08:32:33 <EvilTerran> but generating them isn't too bad
08:33:09 <nominolo> cognominal, you *like* perl6?
08:34:22 <cognominal_> yes, perl5 is too ugly. And I want more than a clean Perl5. So Ruby is nice but not a frill
08:35:11 <nominolo> i think all that context-sensitivity and implicit stuff can quickly break your bones.
08:35:19 <jbjohns> Perl6 is not much better.  They took out a lot of the horrible hacks, but the design is much more complex and doesn't really bring anything new to the table.  Well new for perl, but not new for programming languages
08:35:37 <gpi5> is there an equivallent of show/read for functions? Would be cool to be able to add functions at runtime.
08:35:38 <nominolo> otoh, i'm not so much up to date with perl6 development
08:36:06 <EvilTerran> @where hsplugins <- gpi5
08:36:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
08:36:10 <nominolo> gpi5, that's tricky, because it can break semantics
08:36:23 <nominolo> the complex solution is the link abeve
08:38:12 <gpi5> nominolo: thanks, I'll have a look
08:38:41 <cognominal_> nominolo, yes, it takes some time to like it.
08:39:08 <cognominal_> some will never will.
08:41:32 <cognominal_> Saizan: thx about the derive tip
08:45:29 <jbjohns> it takes time to like what?
09:01:09 <cognominal_> jbjohns, the use of context in perl5. Will be even more prevalent in perl6
09:02:26 <LoganCapaldo> Hmm
09:03:35 <hpaste>  Dave M pasted "Generic trie" at http://hpaste.org/2642
09:05:04 <jbjohns> yes I know.  I was pretty surprised by that.  I saw they were fixing things from perl 6, I thought surely that context stuff would go, but instead it got even more complicated
09:05:10 <matthew-_> err, both rahaskella and lambdabot are awake?
09:05:33 <LoganCapaldo> it's the bot revolution
09:05:42 <LoganCapaldo> they're forming skynet
09:05:44 <LoganCapaldo> @bot
09:05:44 <lambdabot> :)
09:05:51 <LoganCapaldo> or not
09:06:00 <matthew-_> sorry.
09:06:06 <matthew-_> yeah, rahaskeller isn't here
09:06:17 <matthew-_> it's only in ##otw
09:07:00 <cognominal_> otw?
09:07:32 <matthew-_> no idea
09:07:58 <LoganCapaldo> of the week
09:08:03 <LoganCapaldo> # of the week?
09:08:09 <LoganCapaldo> Is it 42?
09:08:46 <arcatan> 36?
09:09:17 * roconnor thinks it is week 36
09:09:29 * roconnor also thinks weeks begin on Sunday.
09:09:50 <roconnor> I wonder what the ISO thinks is the first day of the week.
09:10:35 <mauke> argh :(
09:10:35 <mauke> I need a single-stepping debugger
09:11:01 <matthew-_> roconnor: I agree wrt weeks beginning on Sunday
09:11:17 <LoganCapaldo> mauke, let me know if you find one
09:11:40 <int-e> there's the compromise of giving sunday the number 0 ;)
09:12:27 <int-e> then you can decide, based on that, whether 0 or 1 is the first natural number.
09:13:09 <LoganCapaldo> int-e, your cleverness is only exceeded by your evilness ;)
09:14:11 <roconnor> is sunday also the number 7?
09:14:24 <roconnor> like midnight getting both 24:00 and 00:00
09:14:38 <LoganCapaldo> there is no 24:00
09:14:40 <matthew-_> roconnor: that's grim. Mind you, there are leap seconds
09:15:00 <xerox> isSunday = (0==) . (`mod` 7)
09:15:01 <LoganCapaldo> (imo anyway)
09:15:21 <roconnor> matthew-_: do they occur at midnight?
09:15:29 <matthew-_> roconnor: I'm not sure
09:15:35 <LoganCapaldo> (reality may differ, we are not responsible for lost items, including sanity)
09:15:40 <roconnor> LoganCapaldo: 24:00 exists, but is non canonical.
09:15:51 <nominolo> according to bible, sunday is the 7th day, afaik
09:16:25 <Heffalump> leap seconds are 23:60, aren't they?
09:16:26 <roconnor> ISO is a bunch of godless nazi heathen devil worshipers.
09:16:42 <cognominal_> trying to install green card on my intel mac, I get Lex.lhs:14:7:
09:16:42 <cognominal_>     Could not find module `Data.FiniteMap':
09:16:57 <cognominal_> what could I have done wrong
09:17:01 <mrd> does anyone still use greencard
09:17:04 <nominolo> cognominal, which version of ghc?
09:17:11 <matthew-_> roconnor: um, that might be a /bit/ strong...
09:17:13 <mrd> because taht sounds way old. Data.FiniteMap --> Data.Map
09:17:31 <mauke> greencard seems to suffer from bitrot
09:17:59 <cognominal_> may be should I get it from cvs, darcs or whatever
09:18:03 <int-e> LoganCapaldo: you forgot my laziness. that exceeds both of the qualities you mentioned.
09:19:29 <nominolo> cognominal, why don't you use c2hs or that other ffi processor?
09:20:31 <cognominal_> I don't know. I am trying to figure out everything that exists in the ghc environment
09:23:18 <LoganCapaldo> I wonder way it was called FiniteMap
09:23:43 <ddarius> Because it's a finite map ...
09:23:59 <LoganCapaldo> Seems sort of implicit
09:24:50 <ddarius> Integer -> Bool is an infinite map
09:25:06 <LoganCapaldo> that was going to be my next question ;)
09:26:21 <LoganCapaldo> @type \m k -> fromJust $ Data.Map.lookup k m
09:26:23 <lambdabot> forall k a. (Ord k) => Data.Map.Map k a -> k -> a
09:26:45 <LoganCapaldo> look, it's an infinite map from finite maps to infinite maps :)
09:27:52 <LoganCapaldo> this is starting to remind me of the trie thing
09:29:30 <ddarius> If k is finite, then k -> a would be a finite map, further unless k is finite, that conversion is partial.
09:29:56 <LoganCapaldo> hence the smiley face
09:30:18 <LoganCapaldo> I gotta stop doing that
09:30:32 <LoganCapaldo> I think it might a sub concious desire to troll
09:32:04 <mdmkolbe> @pl throwError . strMsg
09:32:04 <lambdabot> throwError . strMsg
09:33:34 <LoganCapaldo> @pl \x -> throwError (strMsg x)
09:33:35 <lambdabot> throwError . strMsg
09:34:37 <LoganCapaldo> they shoulda abbreviated it to terror
09:34:55 <mdmkolbe> @type terror
09:34:59 <mdmkolbe> @index terror
09:35:03 <lambdabot> Not in scope: `terror'
09:35:03 <lambdabot> bzzt
09:35:06 <balodja> terror :))
09:43:57 <xtacy[]> Hi, in Hoare's Logic, for proving program correctness, I have a question in the assignment rule ..
09:44:52 <sorear> xtacy[]: Don't ask to ask (general IRC convention) :D
09:45:01 <xtacy[]> we have {P[E/x]} x := E {P} ,
09:45:13 <xtacy[]> sorear, Yeah, I was typing :) It was a kind of an announcement :D
09:45:55 <xtacy[]> okay, when we have the rule {P[E/x]} x := E {P} ...
09:46:00 <ddarius> Of all the programming language channels to ask on, ask on the one about a programming language with no assignment...
09:46:09 <mauke> haha
09:46:11 <beelsebob> hehe
09:46:18 <sorear> writeIORef
09:46:20 <beelsebob> yeh, but assignment is a lot like beta-reduction
09:46:25 <xtacy[]> ddarius, :) we have subsitution in Haskell
09:46:27 <beelsebob> so not too horrific
09:46:36 <sorear> #haskell is actually #smart-people
09:46:38 <Tac-Tics> With all the good things people say about Hindley Milner, the algorithm behind it is certainly not well represented on the web
09:46:45 <ddarius> assignment is not like beta-reduction, that is why it is horrific.
09:47:06 <olsner> Tac-Tics: isn't it basically just unification?
09:47:07 <beelsebob> ddarius: at least the part he's asking about is very similar... just at the moment
09:47:08 <ddarius> Tac-Tics: You can buy a freakin' T-shirt with it!
09:47:16 <xtacy[]> Okay fine, now back to the question. for me, the Rule {P[E/x]} x := E {P} sounds more like: {P} x := E {P[x/E]}
09:47:24 <Tac-Tics> hehe, really?
09:47:42 <Igloo> ddarius: With the spec, not the algorithm, to be fair (if you're thinking of the same one I am)
09:47:48 <Tac-Tics> I spent all day looking around for it, and everything I read just flew right over my head
09:47:50 <ddarius> Tac-Tics: http://www.cafepress.com/skicalc
09:47:50 <sorear> xtacy[]: P is contravariant in x, so it has to be backward to work out correctly
09:48:04 <ddarius> Igloo: True.
09:48:24 <ddarius> Still, in a logic language, the spec is rather close to the algorithm.
09:48:54 <Tac-Tics> from what I've seen on the web, it requires working knowledge of prolog to implement
09:48:57 <Tac-Tics> or something
09:49:06 <xtacy[]> ddarius: wait, I havent heard the term "Contravariant" before ... lemme check it out
09:49:12 <Tac-Tics> no source really does any good explaining the notation they use
09:49:25 <ddarius> Tac-Tics: Certainly not, but it's pretty straightforward to do in a logic language.
09:49:43 <mauke> basically, you just collect and unify constraints
09:50:11 <sorear> Tac-Tics: Don't look for the answer in html, it's pdf only :)
09:50:19 <Tac-Tics> hehe, sorear, I figured that
09:50:34 <Tac-Tics> I downloaded about 10 pdfs yesterday and in none of them could I get past section 2
09:51:02 <xtacy[]> sorear: Could you give me an example where what I thought was right, does not hold good?
09:51:08 <Tac-Tics> I'm sure it's nothing too complicated to understand, but their use of unfamiliar notation is a serious problem for me
09:51:54 <Tac-Tics> Like the horizontal bar notation
09:52:12 <Tac-Tics> I'm guessing it is for premises on top and the conclusion on the bottom
09:52:23 <xtacy[]> A bar B is A => B
09:52:25 <Tac-Tics> but it's never formally specified (if that is in fact what the notation does)
09:52:36 <xtacy[]> Tac-Tics: horizontal bar, that is :)
09:52:36 <sorear> Tac-Tics: uhm, yeah, that's natural deduction, everyone is assumed to know that
09:52:57 <olsner> I've never learned to read the horizontal bar notation... I just wish they'd write it in prolog instead ;-)
09:53:09 <ddarius> xtacy[]: {x = 2}x := 3{3 = 3} (that's what your notation reads as)
09:53:11 <Tac-Tics> it seems quite unnatural to me ^^
09:53:31 <Tac-Tics> I am quite familiar with |- notation for that sort of thing
09:54:02 <Rebooted> anyone here familiar with WASH? I can use a button to transition between pages but can't figure out how to do it via a link
09:54:07 <xtacy[]> ddarius: in some sense, that *is* correct, right? :)
09:54:21 <xtacy[]> ddarius: but it isnt useful ...
09:54:37 <Rebooted> done via a button like this: submit0 page2 (attr "value" "Clickformyhobbies")
09:54:42 <pejo> Tac-Tics, are you trying to implement type inference  from standard HM? If so, have you seen the chapter in the book by SPJ on his homepage?
09:55:08 <Tac-Tics> most likely
09:55:17 <Tac-Tics> I have two pdfs by SPJ on the subject
09:55:19 <Tac-Tics> ^^
09:55:36 <sorear> pejo: the person who wrote that chapter says on his webpage something to the effect of "I regret writing that, it's the most disgusting code I've seen"
09:55:39 <Tac-Tics> really, I just want to be able to write a very simple type checked language in Haskell
09:55:50 <Tac-Tics> just to learn the basics of it
09:56:08 <Tac-Tics> the pdf I saw explained universally quantified type variables
09:56:18 <sorear> Tac-Tics: Read Robinson in the original on unification; once you understand that, implenting HM should be easy...
09:56:19 <pejo> sorear, ".. and we leave it as an exercise to the reader to improve it"? :-)
09:56:24 <Tac-Tics> which (I think) is beyond what I want to do
09:56:26 <sorear> pejo: no. :)
09:56:33 <sorear> Tac-Tics: Boxy types?
09:56:33 <Tac-Tics> thanks sorear
09:56:39 <sorear> Tac-Tics: you don't want that!
09:56:46 <Tac-Tics> yeah
09:57:23 <sorear> ooh, ndm (compiler hacker)
09:57:30 <ddarius> xtacy[]: Oh sorry, it should have been {x = 2}x := 3{3 = 2}
09:57:44 <ndm> sorear: who is compiler hacking right now :)
09:58:09 <sorear> ndm: Tac-Tics wants to implement a type inference engine (for a very simple language); any recommendations for reading material?
09:58:09 * ndm suspects sorear has equal compiler hacking knowledge
09:58:16 <ddarius> No wait, that was still wrong, {x = 2}x:=3{x = 2} is exactly what it would come out to in that case.
09:58:28 <ndm> Tac-Tics: types and programming languages
09:58:51 <Tac-Tics> that's the other thing. The original articles are not available online, and I suspect, aren't available for free
09:58:55 <ndm> plus the new tai chi library, which will hopefully be released shortly - its a type inference engine as a Haskell library which can do types for most things
09:58:59 <ddarius> xtacy[]: And {y = 2}x:=3{y = x} is also a result of your rule
09:59:17 <ndm> although i'm pretty sure it hasn't been released and isn't publically available :(
09:59:44 <xtacy[]> ddarius:  :) Lemme work it out ... I think my initial formulation should be changed a little
09:59:59 <ndm> Tac-Tics: plus of course, typing haskell in haskell
10:00:00 <roconnor> @go 2 quarts in l
10:00:02 <lambdabot> 2 US quarts = 1.8927059 l
10:00:19 <ndm> @go typing haskell in haskell jones
10:00:20 <ddarius> xtacy[]: The rule you were given was correct.  I'd spend more time trying to understand why.
10:00:21 <lambdabot> http://citeseer.ist.psu.edu/424440.html
10:00:21 <lambdabot> Title: Typing Haskell in Haskell - Jones (ResearchIndex)
10:00:43 <ndm> Tac-Tics, if you can't find the original code, i've got a copy here - it was missing last time i went searching
10:00:48 <xtacy[]> ddarius: what I had in mind was, you have a statement {Q}. and an assignment x := E... so, {Q} should be now still valid, with all occurances of 'x' in Q replaced by E
10:01:35 <Tac-Tics> hmm that article looks not too bad
10:01:42 <Tac-Tics> I'll take a look at it
10:02:04 <mdmkolbe> @hoogle [Bool] -> [t] -> [t]
10:02:04 <lambdabot> No matches, try a more general search
10:02:17 <ddarius> Okay then you used the notation backwards (which I suspected and was probably a typo), still you then get {x = 2}x:=3{3 = 2}
10:02:25 <mdmkolbe> @djinn [Bool] -> [t] -> [t]
10:02:25 <lambdabot> f _ a = a
10:02:34 <ddarius> xtacy[]: The way to think of the given rule is,
10:02:57 <olsner> filter fst . zip ?
10:03:08 <Tac-Tics> @let filter2 (True:bs) (x:xs) = x : filter2 bs xs; filter2 (False:bs) (x:xs) = filter2 bs xs; filter2 [] [] = []
10:03:12 <lambdabot> Defined.
10:03:13 <ari> :t (filter fst .) . zip
10:03:15 <lambdabot> forall b. [Bool] -> [b] -> [(Bool, b)]
10:03:24 <Tac-Tics> > filter2 [True, True, False, True, False] [1..5]
10:03:26 <lambdabot>  [1,2,4]
10:03:27 <ddarius> if P holds with all versions of x replaced with E, then when we set x to E, P should hold (without the substitution since x now equals E)
10:03:43 <mdmkolbe> @type filter fst . zip
10:03:45 <lambdabot>     Couldn't match expected type `[(Bool, b)]'
10:03:45 <lambdabot>            against inferred type `[b1] -> [(a, b1)]'
10:04:02 <ddarius> Thus in symbols {P[E/x]}x:=E{P}
10:04:07 <mdmkolbe> @type (filter fst) . zip
10:04:09 <lambdabot>     Couldn't match expected type `[(Bool, b)]'
10:04:09 <lambdabot>            against inferred type `[b1] -> [(a, b1)]'
10:04:12 <mauke> > ((map snd . filter fst .) . zip) [True, True, False, True, False] [1..5]
10:04:13 <lambdabot>      The operator `.' [infixr 9] of a section
10:04:13 <lambdabot>         must have lower precede...
10:04:20 <ndm> concat $ zipWith (\a b -> [b|a])
10:04:22 <mdmkolbe> @type filter
10:04:24 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:04:38 <mauke> > (((map snd . filter fst) .) . zip) [True, True, False, True, False] [1..5]
10:04:40 <lambdabot>  [1,2,4]
10:04:43 <olsner> @type concat $ zipWith (\a b -> [b|a])
10:04:45 <lambdabot>     Couldn't match expected type `[[a]]'
10:04:45 <lambdabot>            against inferred type `[Bool] -> [b] -> [[b]]'
10:05:12 <olsner> @type (concat .) . zipWith (\a b -> [b|a])
10:05:13 <lambdabot> forall b. [Bool] -> [b] -> [b]
10:05:57 <ari> olsner++
10:06:13 <olsner> ndm++
10:06:31 <mdmkolbe> ndm++
10:06:36 <olsner> passing the karma ;-)
10:06:53 <mdmkolbe> @help karma
10:06:54 <lambdabot> karma <polynick>. Return a person's karma value
10:06:59 <mdmkolbe> @karma ndm
10:06:59 <lambdabot> ndm has a karma of 16
10:07:18 <ndm> thanks :) - i love the [a|b] trick!
10:08:56 <Tac-Tics> [False | True]
10:09:01 <Tac-Tics> > [False | True]
10:09:03 <lambdabot>  [False]
10:09:13 <Tac-Tics> > [True | True]
10:09:14 <sioraiocht> > [True | False]
10:09:14 <lambdabot>  [True]
10:09:15 <lambdabot>  []
10:09:18 <ndm> the classic example is
10:09:27 <mdmkolbe> ndm: would that trick fuse properly?  or would a Schwartian transform fuse better?
10:09:45 <ndm> mdmkolbe: no idea, it does using the optimiser i'm writing :)
10:09:45 <Tac-Tics> Er, wait, | isn't what I think it is....
10:09:51 <Tac-Tics> @src (|)
10:09:51 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:09:57 <Tac-Tics> @type (|)
10:09:58 <beelsebob> Tac-Tics: it's list comprehension
10:09:59 <lambdabot> parse error on input `|'
10:10:00 <Tac-Tics> yeah
10:10:03 <Tac-Tics> hehe
10:11:10 <Tac-Tics> I reverted to thinking | was a binary bitwise operator or something
10:11:19 <conal> does anyone know if standalone deriving is in recent ghc?
10:11:26 <conal> and if so, what the syntax is?
10:12:03 <ndm> conal: i thought it was in the head, but can't remember hte syntax, although the head manual should have it in (i think i saw a patch to the manual land)
10:12:09 <xtacy[]> ddarius: ah,
10:12:21 <xtacy[]> ddarius: That example cleared things ...
10:12:39 <sjanssen> conal: deriving instance Class Type -- IIRC
10:12:54 <conal> ndm: thanks.  hm, i wonder where i saw the head docs...
10:14:02 <sorear> @docs
10:14:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:14:10 <sorear> s/latest/current/
10:14:23 <conal> sorear: HEAD?
10:14:32 <sorear> conal: s/latest/current/
10:15:00 <conal> oh, and more specifically, i'm looking for language extensions
10:15:07 <tuxplorer> many programs should write some lines to a queue and one program should take line by line from that queue and process each line..is there any IPC library available for Haskell?
10:15:39 <conal> i'll try the user's guide link from there/../..
10:15:42 <allbery_b> sockets
10:15:47 <allbery_b> (ie. Network)
10:15:52 <conal> oh -- urg.  6.6.1
10:16:46 <tuxplorer> allbery_b: Sockets is there, but is there a better way such as shared memory?(I understand that Haskell won't allow people to access memory locations directly, but may be if it provides some abstract way of doing it?)
10:17:26 <allbery_b> I've seen shared memory techniques involving ForeignPtrs discussed, but no standard library
10:17:42 <tuxplorer> allbery_b: oh! ok.. Thanks :)
10:17:42 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/
10:17:43 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.7.200708 ...
10:17:57 <allbery_b> Unix fifos could be done fairly easily without any special library (with due care due to some of the magic needed to get them to behave right)
10:18:10 <allbery_b> not sure if POSIX IPC is worth the effort
10:18:36 <conal> sorear: thanks
10:19:04 <allbery_b> hm, System.Win32 doesn't seem to have Windows IPC either
10:19:08 <allbery_b> kinda sad
10:19:16 <ndm> how would i do this in applicative
10:19:20 <ndm> f m x
10:19:25 <ndm> where m is a monadic computation
10:19:30 <ddarius> System.Win32 is far from a comprehensive binding.
10:19:32 <tuxplorer> allbery_b: actually I wanted linux IPC :)
10:19:32 <ndm> i.e. y <- m ; f y x
10:19:55 <ndm> ddarius: if you want any particular bit binding, esa will usually oblige
10:19:57 <mauke> return f `ap` m `ap` return x
10:20:11 <ndm> mauke: i meant using the <$> and <*> syntax of applicative
10:20:27 <allbery_b> ddarius: think you missed the point.  neither unix/posix nor win32 IPC is there
10:20:39 <allbery_b> much less a hypothetical higher level binding
10:21:02 <mauke> oh, no return?
10:21:06 <ddarius> allbery_b: All I was saying, is that -many- Win32 things aren't in System.Win32
10:21:15 <xtacy[]> ddarius: now, say x = 2, and then i make the assignment x := 3 , and so, x = 3 after the statement is executed. How do we write this in Hoare Logic?
10:22:16 <hpaste>  conal pasted "standalone deriving example -- does it work for anyone?" at http://hpaste.org/2645
10:22:51 <xtacy[]> ddarius: The statement: {x=2} x := 3 {x=3}, doesnt fit into the proposed logical rule for assignment statements ...
10:22:52 * allbery_b doesn't think he's got enough clue to devise such a higher level IPC binding
10:23:16 <sioraiocht> conal: not for me
10:23:38 <conal> i have 6.7 20070824.
10:23:52 <xtacy[]> ddarius: here E = 3. but if we do P[E/x], we get {3 = 2}, which is false
10:23:56 <conal> sioraiocht: what's your ghc version?
10:24:05 <sioraiocht> conal: 6.6.1
10:24:14 <xtacy[]> ddarius: but the implication is true anyway :-)
10:24:16 <sjanssen> conal: deriving rather than derive, and you have to provide a context
10:24:23 <xtacy[]> ddarius: hmm, now I am confused
10:24:32 <sjanssen> conal: and you need LANGUAGE StandaloneDeriving
10:25:53 <hpaste>  conal annotated "standalone deriving example -- does it work for anyone?" with "this one works.  thanks, sjanssen" at http://hpaste.org/2645#a1
10:26:05 <conal> sioraiocht: oh, okay.  i wouldn't expect it to work there.
10:26:12 <hpaste>  mdmkolbe pasted "A cute duality (for your enjoyment)" at http://hpaste.org/2646
10:26:33 <sioraiocht> conal: sorry, i only use stable release, i'm not pro enough to use bleeding edge haskell ;)
10:26:38 <conal> sjanssen.  super.  :)  i guess the docs are out of date.
10:27:19 <conal> sioraiocht: usually a good choice!  i seem always to be pushing the edge with my language use.
10:27:32 <puusorsa> http://www.finnchan.fi/b/files/1189388640/1/[bigish]_the_art_of_cropping.jpg
10:27:33 <lambdabot> http://www.finnchan.fi/b/files/1189388640/1/[bigish]_the_art_of_cropping.jpg
10:27:40 <ddarius> xtacy[]: My examples weren't good on this point, but {P}E{Q}, P is a precondition, something that must hold before E is executed, not what does hold before E is executed.
10:28:15 <conal> puusora: urk.  i wish i hadn't see that
10:28:19 <Igloo> OK, another GADT problem. In http://hpaste.org/2647 bar works but foo doesn't. Is there a way to write what I want without enumerating all the constructors?
10:28:45 <Eelis> @djinn (Fd -> CInt)
10:28:45 <lambdabot> -- f cannot be realized.
10:28:57 <ddarius> xtacy[]: Also, in practice, you usually work backwards from post-conditions to pre-conditions.
10:28:58 <Igloo> (and without having a Monad m context)
10:29:52 <xtacy[]> ddarius: okay, lets fit it on this: if(x==2) x=3;
10:30:42 <mdmkolbe> Igloo: isn't foo = (const (return True) :: SomeMonad m -> m Bool)?
10:30:44 <xtacy[]> ddarius: oh, there is an assumption that in {P} E {Q}, execution of E does not affect P
10:31:13 <ddarius> xtacy[]: P and Q should be timeless things.
10:31:24 <allbery_b> Eelis: lemme guess, gtk2hs?
10:31:28 <Igloo> mdmkolbe: That's what I want, yes
10:31:35 <xtacy[]> ddarius: ah, so, I cant prove the correctness of an assignment then!
10:32:00 <Igloo> mdmkolbe: But I don't want to have to put the Monad m constraint on foo. I don't mind putting it on the GADT, but GHC won't let me
10:32:02 * allbery_b hit that one trying to use the Gtk+ IO notification facilities
10:32:17 <xtacy[]> ddarius: brb ...
10:32:29 <Eelis> allbery_b: nope
10:33:26 <sorear> Igloo: your op bit is still on, fwiw
10:33:28 <mdmkolbe> Igloo: why does bar even work?  I don't see a (Monad m) anywhere
10:33:57 <Igloo> mdmkolbe: Because when GHC sees the constructor it knows that m == Maybe/IO, and thus is in Monad
10:34:37 <mdmkolbe> Igloo: and which monad it uses depends on the value of the constructor?
10:34:42 <Igloo> Yup
10:35:10 <mdmkolbe> Igloo: now I begin to see why GHC doesn't like foo
10:35:20 <conal> @pl \a b -> a * base + b
10:35:20 <lambdabot> (+) . (base *)
10:35:28 <conal> @pl \a b -> a + base * b
10:35:28 <lambdabot> (. (base *)) . (+)
10:36:03 <Igloo> mdmkolbe: Right, I understand that, but I'm not sure I see what problems would be caused by putting a "Monad m" constraint on the GADT declaration would cause
10:36:23 <mdmkolbe> Igloo: umm, what about "foo undefined"
10:36:24 <conal> allbery_b: what are "Gtk+ IO notification facilities"?
10:37:24 <Igloo> mdmkolbe: that's an ambiguous type error isn't it?
10:38:02 <allbery_b> inputAdd and inputRemove in System.Glib.MainLoop which take type FD (type FD = CInt)
10:38:22 <allbery_b> maybe it's better in 0.9.12, I'm still using 0.9.11
10:38:49 <allbery_b> I had to dig in the source to find out what an FD was (and online docs seem to think this is still the case)
10:38:56 <mdmkolbe> Igloo: ok.  I thought I had come up with a good reason this couldn't be done, but you are right.
10:39:22 <EvilTerran> ?type foldM
10:39:31 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:39:45 <Igloo> mdmkolbe: You could pass in (undefined :: SomeMonad (Either String)) for which there is no constructor, but I don't think anything bad would happen
10:40:09 <mdmkolbe> Igloo: as long as the dictionary gets instantiated in that case, then it would work out
10:40:19 <Igloo> Yeah, exactly
10:41:46 <EvilTerran> ?src takeWhile
10:41:46 <lambdabot> takeWhile _ []                 =  []
10:41:46 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
10:41:46 <lambdabot>                    | otherwise =  []
10:41:54 <mdmkolbe> Igloo: maybe someone has written a paper about writting constraints as GADTs.  They would have had to have solved this problem.  (Or maybe that is what you are doing.)
10:42:52 * Igloo isn't writing a paper, I'm just trying to use GADTs
10:43:19 <ddarius> xtacy[]: Let's say you want to have add y to x and you write the program while(y > 0) { x := x + 1; y := y - 1; } The precondition of the whole thing is {x = a, y = b, b >= 0} the post-condition {x = a + b}, the loop invariant is {x+y = a+b}. Looking at the body of the loop and starting with the loop invariant as the post-condition we have {?}y:=y-1{x+y=a+b} giving {x+(y-1)=a+b} that becomes the post-condition to x:=x+1 and gives {(x+1)+(y-1)=a+b}x:=x+1;y
10:43:19 <ddarius> :=y-1;{x+y=a+b} so the loop invariant is maintained.
10:43:43 <EvilTerran> \o/
10:47:15 <Eelis> System.Posix.Types has   newtype Fd = Fd CInt  . i currently define   fdOfFd (Fd fd) = fd   to easily get the actual fd out of an Fd. of course, i wouldn't have to bother if Fd had been defined as  newtype Fd = Fd { fd :: CInt }. what chances would a feature-request to add the field accessor have?
10:48:03 <mdmkolbe> Igloo: I'm out of ideas.  It sounds like GHC would have to infer that all of the constructors are monads so that SomeMonad m => Monad m which I don't think GHC even attempts to do right now.  (You probably could write a function that informs GHC of that; it would have to list every constructor, but you would only have to write it once.)
10:48:54 <Igloo> mdmkolbe: I'm happy to write it, so it would only have to check it
10:49:36 <sorear> Igloo: foo won't do, for much the same reason that we don't allow irrefutable pattern matches on GADTs to refine
10:49:57 <sorear> Igloo: we need to know *which* value of some is involved to pick the correct 'return'
10:49:58 <mdmkolbe> Igloo: do you need an example, or is the idea clear enough on its own?
10:50:05 <sorear> Igloo: but what if some is undefined?
10:50:29 <Igloo> sorear: I want it to behave as if I had put a Monad m constraint on the type
10:50:30 <sorear> Igloo: so foo would have to be strict, even though the name does not occur free in the RHS
10:50:48 <Igloo> sorear: Do you see any problems that that would cause?
10:50:59 <mdmkolbe> sorear: the type of the input (the m in SomeMonad m) tells us which monad to use
10:51:08 <sorear> Igloo: so you want partial type signatures?  ... => SomeMonad m -> m Bool ?
10:51:14 <Igloo> mdmkolbe: I'm not sure what you mean
10:51:21 <xtacy[]> ddarius: I kinda get it
10:51:28 <sorear> Igloo: it wouldn't cause problems, no
10:51:37 <xtacy[]> ddarius: But I need to think about it more ... this working backwards :-)
10:51:53 <Igloo> sorear: No, I want to put a Monad m constraint on the GADT definition and have GHC then DTRT without me having to change foo
10:52:09 <Igloo> (the reason being that there are lots of foo's, but only 1 GADT)
10:52:25 <xtacy[]> ddarius: okay, so, one final thing ... how do I argue correctness for
10:52:28 <sorear> Igloo: GHC would be DTWTing in this case; *digs up thread*
10:52:43 <xtacy[]> x := 2; if(x=2) x := 3;
10:53:16 <monochrom> what are the desired pre-condition and post-condition?
10:53:16 <hpaste>  mdmkolbe annotated "GADTs" with "one way to hack around it" at http://hpaste.org/2647#a1
10:53:49 <EvilTerran> @check \p xs -> (($[]) . foldl (\f x -> f . if p x then (x:) else const []) id $ xs) == takeWhile p xs
10:53:50 <lambdabot>  Add a type signature
10:53:53 <EvilTerran> ...
10:53:55 <Igloo> mdmkolbe: Oh, sorry, in reality I actually want to use do notation
10:53:59 <EvilTerran> @check \p xs -> (($[]) . foldl (\f x -> f . if p x then (x:) else const []) id $ xs) == takeWhile p (xs::[Int])
10:54:01 <lambdabot>  OK, passed 500 tests.
10:54:07 <EvilTerran> :D
10:57:09 <Igloo> sorear: No luck?  :-(
10:57:13 <sclv> does "foo :: Monad m => SomeMonad m -> m Bool" do anything like what you want?
10:57:38 <Igloo> sclv: Yes, except I'd prefer not to have to write the context on every function
10:58:40 <sorear> Igloo: yeah, no luck
10:58:48 <Igloo> OK, thanks for looking
10:59:22 <sorear> Igloo: but you see that foo is necessarily strict - what is   foo undefined :: Ptr Bool ?
11:00:00 <mdmkolbe> sorear: will Ptr Bool match SomeMonad m?
11:00:09 <Igloo> sorear: A type error, as Monad Ptr doesn't hold
11:00:15 <ddarius> xtacy[]: You need to say what is "correct", what is the code supposed to do.
11:00:38 <xtacy[]> {x=3} ... at the end of execution.
11:00:46 <mdmkolbe> sorear: err, sorry I miss read the implicit parens
11:01:33 <sioraiocht> is it possible to declare type contraints in a polymorphic datatype declaration?
11:01:36 <sorear> Igloo: You said foo :: SomeMonad m -> m Bool.  Take m = Ptr; foo :: SomeMonad Ptr -> Ptr Bool.  Now undefined :: a; take a = SomeMonad Ptr.    now foo undefined :: Ptr Bool.  Or are you suggesting SomeMonad Ptr be ill-kinded?
11:01:48 <sioraiocht> like, data Tree a, but only for Ord a?
11:01:56 <monochrom> rewrite "if(x=2)x:=3" as "if (x=2) then x:=3 else skip".  Do you know the rule for {?} if (x=2) then x:=3 else skip {x=3} ?
11:02:07 <mauke> sioraiocht: not really
11:02:08 <Igloo> sorear: But I want to write data Monad m => SomeMonad m where ...
11:02:12 <sioraiocht> mauke: oh, bummer, lol
11:02:32 <Igloo> sorear: So GHC requires Monad Ptr in order to accept the type SomeMonad Ptr
11:02:40 <monochrom> Anyway {true} x:=2 {x=2} if (x=2) then x:=3 else skip {x=3}  you can probably see how to prove that.
11:02:56 <mdmkolbe> Igloo: would "data (Monad m) => Wrap m = Wrap (SomeMonad m)" work?
11:03:24 <sorear> Igloo: Found it
11:03:28 <sorear> Igloo: Read "irrefutable patterns for existential types / GADTs
11:03:29 <crazy_coder> hello everyome
11:03:36 <mdmkolbe> sioraiocht: are you after something like "data (Ord a) => Tree a = ..."?
11:03:38 <crazy_coder> :)
11:03:39 <xtacy[]> monochrom: again, I am not able to fit the rule in this context
11:03:49 <sorear> Igloo: some people broke the thread, so I can't give a URL *grump grump*
11:04:10 <ddarius> xtacy[]: What is the (general) rule for if-then-else?
11:04:12 <xtacy[]> monochrom: lemme try ... one minute :)
11:04:14 <Igloo> sorear: Do you know who wrote the important message? Or do you mean the whole thread?
11:04:57 <xtacy[]> ddarius: {P} if (E) then S1; else S2; {Q} --> {P and E} S1 {Q}, {P and !E} S2 {Q}
11:05:10 <xtacy[]> so, here, we do ...
11:05:52 <mdmkolbe> sioraiocht: I think this does what you want, "data (Ord a) => Tree a = Leaf a | Branch (Tree a) (Tree a)"
11:06:00 <xtacy[]> so, here, {P} should be the post condition of the assignment x=2
11:06:03 <sioraiocht> mdmkolbe: yes
11:06:12 <xtacy[]> ddarius, monochrom: right?
11:06:15 <monochrom> yes
11:06:36 <ddarius> (To expand on the practice, usually you start with preconditions for a block of code stating what you are assuming to be true, and postconditions stating what you want aftewards and you move backwards from the postcondition to see if you get something that is implied by the initial preconditions.)
11:07:03 <xtacy[]> monochrom: which means, first I have to write the rule for the assignment ...
11:07:18 <xtacy[]> ddarius: okay, there is no initial condition here. So, its just {True}
11:07:45 <EvilTerran> hm... would you say (takeWhileM :: Monad m => (a -> Bool) -> [m a] -> m [a]) or (takeWhileM :: Monad m => (a -> m Bool) -> [a] -> m [a]
11:07:45 <EvilTerran> ) is more generally useful?
11:07:46 <ddarius> xtacy[]: In this case, yes.  I was just stating that randomly.
11:08:00 <EvilTerran> or is there some generalisation that exceeds both in utility?
11:08:09 <xtacy[]> ddarius: alright. so, in this case, we have {true} x := 2 {Q}.
11:08:56 <xtacy[]> ddarius: oh okay, its not like the post-codntion follows, is it? :)
11:09:28 <xtacy[]> ddarius: i.e., is it that the post-condition follows naturally out of the conditions {true} and execution of "x := 2"?
11:10:00 <xtacy[]> ddarius: But your previous statement clears things up ... here, I *want* (post-condition) that x = 2. which means, {Q} is {x = 2}
11:10:28 <xtacy[]> ddarius: so it doesnt work that way, i.e. {true} and x := 2 => {x = 2}, am I right? :)
11:10:33 <ddarius> xtacy[]: Start at the ultimate post-condition which you said (for the whole block) was {x=3}
11:10:53 <xtacy[]> ddarius: Alright.
11:11:15 <earnest> @src foldl
11:11:15 <lambdabot> foldl f z xs = lgo z xs
11:11:15 <lambdabot>     where lgo z []     =  z
11:11:15 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
11:11:21 <monochrom> There are generally three ways of doing things.  {?} program {??}.  You can guess or be given both ? and ??, then prove. You can guess or be given ??, then calculate ?. You can guess or be given ?, then calculate ??.  The last one is the hardest, since the formulas involved are the most ugly.
11:11:48 <earnest> so foldl is recursive; if i write length in terms of foldl, then length will still be recursive; no?
11:12:01 <EvilTerran> foldl f e [] = e; foldl f e (x:xs) = foldl f (f e x) xs
11:12:06 <ddarius> The middle case is the normal case when you want to show some block is correct.
11:12:06 <conal> hm. i tweaked all of my libraries to use the LANGUAGE pragma.  now  realize that they'll only work for people who have a very recent ghc head.
11:12:14 <xtacy[]> ddarius: so, if the loop is: {P} if (x == 2) x = 3; else skip; {x=3}
11:12:44 <EvilTerran> earnest, the list is a recursive data type. it is inevitable that you'll have to recurse somewhere if you want to be able to process lists in the general case
11:12:50 <xtacy[]> ddarius: I get ... {P and x = 2} x := 3 {x = 3}, {P and x != 2} skip {x = 3}
11:12:52 <monochrom> The first is pre-70s. By 1972 Dijkstra already has all the formulas for the middle case, and they're nice simple formulas.
11:13:29 <EvilTerran> earnest, but the general consensus, however, is that implicit recursion through combinators that everyone knows is nicer
11:13:30 <ddarius> The last case corresponds to show what a block of code means.
11:13:42 <earnest> EvilTerran: i agree; hudak passes an exercise saying ``rewrite the definition of length nonrecursively''; i would think he is trying to get us to use foldl, but i dont know; can you write length nonrecursively?
11:14:00 <ddarius> earnest: Not without using recursion somewhere.
11:14:04 <monochrom> Yeah, the last case is reverse-engineering.
11:14:07 <earnest> ddarius: okay
11:14:18 <ddarius> xtacy[]: Continue.
11:14:34 <EvilTerran> earnest, as someone can look at your source and see "aha, that's a fold! and that's a filter!" instead of having to work out that it's equivalent to such a thing by study
11:14:55 <xtacy[]> ddarius: now, I dont have P with me. But all I know at this point is, {P and x = 2} should be the post-condition for the first assignment
11:14:56 <EvilTerran> earnest, is this excercise intended to be done in haskell?
11:15:02 <earnest> yes
11:15:07 <earnest> all in haskell
11:15:08 <xtacy[]> So, I have {?} x := 2 {P and x = 2}
11:15:14 <earnest> that's The Haskell School of Expression
11:15:23 <earnest> the book; do you know the book?
11:15:28 <EvilTerran> i know of it
11:15:35 <EvilTerran> a fold works, i guess.
11:15:43 <earnest> i'm gonna try
11:15:46 <EvilTerran> ?type until -- this is good for expressing "iterative" algorithms
11:15:47 <xtacy[]> So, I have {?} = {P and 2 = 2}
11:15:48 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
11:15:51 <xtacy[]> which is essentially {P}
11:16:01 <xtacy[]> ddarius: so, what is P? :)
11:16:20 <xtacy[]> ah, P is the pre-condition. So, it means,
11:16:52 <earnest> EvilTerran: i'm still very limited in my freedom of expression in Haskell; i can't really write what I may imagine; I'm still in the copy-from-the-book phase; or that's just as far as my intelligence goes
11:16:56 <xtacy[]> ddarius: {P} must hold good for the statements to be executed. so, we can as well take P  = True
11:17:07 <earnest> so I can't really try using some ``until'' right now :)
11:17:18 <EvilTerran> @src until
11:17:19 <lambdabot> until p f x | p x       = x
11:17:19 <lambdabot>             | otherwise = until p f (f x)
11:17:19 <earnest> the syntax is still pretty difficult to me
11:17:20 <monochrom> NO! {true}x:=2{P}.  {P and x=2}x:=3{x=3}.  {P and x!=2}skip{x=3}.  This are the only things you prove (and find P).  DO NOT THROW IN {true}x:=2{P and whatever}
11:18:01 <EvilTerran> earnest, "until" is just another function, much like foldl or map or whatever.
11:18:03 <monochrom> In fact if you read, I have suggested a candidate P early on.
11:18:15 <earnest> actually, not just the syntax, but the whole idea of functional programming is still hard for me to grasp
11:18:29 <EvilTerran> earnest, but, if foldl (for instance) has been introduced to you recently in the book, that's probably a hint that you should use it
11:18:30 <earnest> EvilTerran: it's interesting that until is not recursive
11:18:43 <EvilTerran> it is... look to the right of "otherwise"
11:18:49 <earnest> EvilTerran: true; i bet that's what he has in mind
11:19:12 <earnest> oh yeah; i got confused with that otherwise;
11:19:20 <earnest> i thought that the otherwise would be the base case
11:19:28 * EvilTerran is reminded of solving problems in high school maths using "the wrong technique", ie one other than the one we'd just been taught
11:19:30 <earnest> but it's the other way around
11:19:54 <monochrom> what is the wrong technique you tried?
11:19:55 <earnest> hehe, but that's the idea behind thinking :)
11:20:10 <earnest> you were ignoring the lessons and thinking by yourself
11:20:15 <earnest> that's not so bad
11:20:23 <EvilTerran> anyway, use what you've been given. don't let me lead you astray. ;]
11:20:29 <earnest> :)
11:20:56 <EvilTerran> monochrom, i can't even remember now. i think it was some trick for escaping the tedium of calculating matrix determinants.
11:21:01 <xtacy[]> monochrom: Hmm, so, do we have to *find* P?
11:21:08 <monochrom> P is x=2
11:21:25 <monochrom> There are three ways to come to realize P is x=2.
11:21:26 <xtacy[]> monochrom: I got that.. but all I want to know is
11:21:36 <hpaste>  togi pasted "(no title)" at http://hpaste.org/2648
11:21:37 <cure_> can this be done more neatly somehow? maybe some kind of fold?
11:22:08 <xtacy[]> monochrom: do we have to realize that P is x = 2 from the rules of Hoare Logic? or, guess that x = 2 and find that the sequence of statements make sense, so, our guess is right?
11:22:26 <monochrom> Both works. There is a third way.
11:22:30 <xtacy[]> monochrom: I read your previous statements about {?} program {??}
11:22:36 <monochrom> (Gosh, do I have to repeat myself three times?)
11:23:23 <xtacy[]> reverse engineering? :)
11:23:29 <cizra> EvilTerran: That's a horrible crime. I tried it once too.
11:23:42 <xtacy[]> monochrom: I am sorry I missed your previous messages since they didnt have a "nick" prefixed! :(
11:23:57 <EvilTerran> cizra, what, not using the techniques you're meant to be when at school?
11:24:10 <cizra> yes.
11:24:13 <allbery_b> .oO { ...what I tell you three times is true. }
11:24:29 <dons> ?users
11:24:29 <lambdabot> Maximum users seen in #haskell: 402, currently: 390 (97.0%), active: 22 (5.6%)
11:24:38 <EvilTerran> meh.
11:25:09 * masm activates.
11:25:15 <masm> ?users
11:25:16 <lambdabot> Maximum users seen in #haskell: 402, currently: 390 (97.0%), active: 23 (5.9%)
11:25:17 <matthew-_> ok, I'm clearly being dumb. What's the best way of going from String -> [Word8]
11:25:35 <dons> :t Data.ByteString.Base.c2w
11:25:40 <lambdabot> Char -> Word8
11:25:45 <dons> :t map Data.ByteString.Base.c2w -- :)
11:25:47 <lambdabot> [Char] -> [Word8]
11:26:01 <Trixsey> Is there any way to trim unwanted characters from a string?
11:26:12 <dons> filter
11:26:23 <dons> > filter (not.isSpace) "haskell is fun"
11:26:25 <lambdabot>  "haskellisfun"
11:26:33 <EvilTerran> something involving dropWhile?
11:26:37 <matthew-_> dons: without using internal bytestring utils!
11:26:39 <Trixsey> if I want to fiter a set of unwanted chars?
11:26:49 <dons> matthew-_: its just ord . fromIntegral or something. look up the definition
11:27:08 <Heffalump> > filter (not . (`elem` "abcdefg")) "haskell is fun"
11:27:09 <lambdabot>  "hskll is un"
11:27:29 <dons> yeah, `elem` "string" is a good idiom
11:28:14 <paolino> @src elem
11:28:14 <lambdabot> elem x    =  any (== x)
11:28:19 <matthew-_> dons: yep, I know I was being dumb
11:28:57 <xtacy[]> monochrom: ddarius: at last, I feel like I am getting something
11:29:10 <monochrom> good
11:29:13 <xtacy[]> monochrom, ddarius: may be a nights sleep over it should clear things up :)
11:29:30 <xtacy[]> monochrom, ddarius: The thing I didnt get int he beggining was: "The flow"
11:29:33 <paolino> :t elem
11:29:35 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:29:40 <ddarius> xtacy[]: The hard part of using Hoare logic is finding loop invariants.
11:30:03 <togi> if i wanted to make a list of every character used in a string, is there some really neat haskell-way of doing this?
11:30:21 <ddarius> id
11:30:21 <xtacy[]> ddarius: ah, so is there another Logic for proving program correctness?
11:30:36 <monochrom> loop is the only thing that needs guessing. All else can be calculated blindly. Also, it is not just Hoare logic.
11:30:50 <xtacy[]> monochrom: what I didnt get initially was: "Where do {P} and {Q} come from? But you clearly mentioned 3 ways ... that helped :)"
11:31:11 <monochrom> http://www.cs.toronto.edu/~hehner/aPToP/ is another
11:31:13 <lambdabot> Title: a Practical Theory of Programming
11:31:16 <paolino> togi , sort and group
11:31:24 <sclv> nub?
11:31:32 <xtacy[]> monochrom: so, given P calculate Q. Given Q, work back and calculate P. or, given P and Q, prove that its logically consistent,
11:31:37 <dons> sorear: btw, did you know adam tomb was at the uni of california, santa cruz (in your area?) doing language research stuff?
11:31:45 <ddarius> Usually P and Q are given or at least Q, you are just trying to make the meet in the middle (perhaps finding the weakest assumptions you need to make, P, in the process)
11:31:53 <sclv> or histogram?
11:32:11 <paolino> @src nub
11:32:11 <lambdabot> nub = nubBy (==)
11:32:23 <paolino> @src nubBy
11:32:23 <lambdabot> nubBy eq []             =  []
11:32:23 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:32:31 <xtacy[]> ddarius: so, if there is a clash in the "meeting in the middle", then the algorithm is wrong :)
11:33:02 <earnest> i didnt make it to write length in terms of foldl; what does foldl do? i see it as writing out all elements of my list in a line, and putting it in `op` in between each of them; with the init value at the end; how can i count a list, then, by using the members of the list itself in a x `op` foldl ... fashion? my op can't be (+), so i'm puzzled
11:33:15 <monochrom> If a loop is involved, since it requires guessing, it could also be you guessed something that doesn't work out.
11:33:55 <xtacy[]> monochrom: yes, thats right. so, we change the guess
11:34:05 <monochrom> If there is no loop, then a clash is a real clash.
11:34:31 <earnest> here's a case that works: mlen xs = foldl (+) 0 xs; now call mlen [1,1] that works :) that's length in terms of foldl :P
11:34:33 <sclv> earnest: foldl also takes an initial argument
11:34:37 <sclv> :t foldl
11:34:39 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:35:01 <dons> yow.
11:35:10 <earnest> sclv: right, as i described above
11:35:18 <allbery_b> > foldl (\n _ -> n + 1) 0 "abcdefg"
11:35:19 <lambdabot>  7
11:35:32 <sclv> earnest: try to think what function you want instead of (+) and what properties it would have
11:35:35 <sclv> then write it yourself
11:35:51 <earnest> my problem is which operator to use; because after all i dont want to operate the elements of the list; i just want to count them; i guess i need an operator that just returns the number 2?
11:35:57 <earnest> hm, that's an idea; thanks sclv
11:36:30 <earnest> or that it just returns the number 1; not sure
11:36:31 <xtacy[]> monochrom: ddarius: Thanks to both for helping me out today :)
11:36:32 * allbery_b shouldn't play around in public, perhaps :/
11:36:38 <monochrom> you're welcome
11:36:51 <xtacy[]> monochrom, ddarius: I should prolly sleep now! good-day! (its good night here :)
11:37:02 <paolino> earnest: see allbery_b function
11:37:29 * xtacy[] goes to sleep, happily :)
11:38:14 <togi> sclv : thanks
11:38:17 <allbery_b> actually I was kinda hoping he'd not notice so he could work it out on his own
11:38:22 <cizra> @yaht
11:38:22 <lambdabot> Maybe you meant: fact part yarr
11:38:28 <allbery_b> hence the "not play around in public"
11:38:32 <paolino> @pl \n _ -> n + 1
11:38:32 <lambdabot> const . (1 +)
11:38:40 <allbery_b> @where yaht
11:38:40 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
11:38:53 <cizra> allbery_b: Thanks
11:39:26 <nominolo> @where yaws
11:39:26 <lambdabot> I know nothing about yaws.
11:39:39 <mdmkolbe> @what yaht
11:39:40 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
11:39:45 <ddarius> nominolo: Why would we have a link to yaws?
11:40:11 <nominolo> because it's nice software ;)  .. just testing
11:40:24 <ddarius> @where hws
11:40:24 <lambdabot> I know nothing about hws.
11:40:26 <ddarius> bah
11:40:38 <ddarius> We don't even have a link to a webserver written in Haskell!
11:40:46 <ddarius> @where hws-wp
11:40:46 <lambdabot> I know nothing about hws-wp.
11:40:48 <ddarius> @where hwswp
11:40:49 <lambdabot> I know nothing about hwswp.
11:41:05 <nominolo> @where happs
11:41:05 <lambdabot> http://happs.org
11:42:14 <laz0r> @where frag
11:42:14 <lambdabot> http://www.haskell.org/haskellwiki/Frag
11:42:32 <olsner> @where am I?
11:42:32 <lambdabot> I know nothing about am.
11:42:48 <nominolo> @whereis god
11:42:48 <lambdabot> Maybe you meant: where where+
11:48:42 <nominolo> @localtime laz0r
11:48:43 <lambdabot> Local time for laz0r is Sun Sep  9 20:40:51
11:49:09 <laz0r> still early enough to goof around in #haskell...
11:49:12 <laz0r> :)
11:49:19 <laz0r> @where nepal
11:49:19 <lambdabot> I know nothing about nepal.
11:49:22 <laz0r> mmh
11:49:58 <laz0r> http://www.cse.unsw.edu.au/~chak/nepal/
11:49:58 <lambdabot> Title: The Nepal Project
11:50:16 <laz0r> anyone has some experience with that?
11:50:20 <EvilTerran> hm. i think i might've got carried away in my pointsfreeing, there: liftM.(.f).(.)
11:50:27 <ddarius> laz0r: I imagine ChilliX does.
11:50:37 <nominolo> laz0r, i've seen a lecture on this by SimonPJ
11:50:50 <EvilTerran> hey, at least i didn't write it (fmap `fmap` (`fmap` f) `fmap` fmap)
11:51:04 <laz0r> is it already useable?
11:51:20 <nominolo> laz0r, it should be in ghc 6.8
11:51:21 <oerjan> > (0$0 `fmap`)
11:51:22 <lambdabot>      The operator `fmap' [infixl 9] of a section
11:51:22 <lambdabot>         must have lower prec...
11:51:24 <nominolo> at least that was the plan
11:51:28 <mdmkolbe> @djinn Bool -> m a -> m (Maybe a)
11:51:28 <lambdabot> -- f cannot be realized.
11:51:30 <EvilTerran> fmap (fmap fmap (flip fmap f)) fmap?
11:51:41 <mdmkolbe> @type liftM maybe
11:51:43 <lambdabot> forall a1 a (m :: * -> *). (Monad m) => m a1 -> m ((a -> a1) -> Maybe a -> a1)
11:51:51 <mdmkolbe> @type maybe
11:51:53 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:52:05 <mdmkolbe> @type liftM2 maybe
11:52:07 <lambdabot> forall a1 a (m :: * -> *). (Monad m) => m a1 -> m (a -> a1) -> m (Maybe a -> a1)
11:52:24 <EvilTerran> ?type liftM.(. ?f).(.)
11:52:24 <olsner> :t fmap ap . ap
11:52:26 <lambdabot> forall (m :: * -> *) a b c a1. (Monad m, ?f::a -> a1 -> b) => (b -> c) -> m a -> m (a1 -> c)
11:52:27 <lambdabot> forall a b (m :: * -> *) a1. (Monad m) => m (a1 -> a -> b) -> m a1 -> m a -> m b
11:53:13 * EvilTerran always thinks "echoes" when he sees foo `fmap` bar `ap` baz `ap` eek `ap` ook etc
11:53:38 <EvilTerran> "FMAP -AP -AP -ap -ap..."
11:53:44 <monochrom> hahahaha
11:53:57 * olsner misses the joke
11:54:24 <mdmkolbe> @pl let foo False _ = return Nothing; foo True x = x >>= (return . Just) in foo
11:54:24 <lambdabot> const (const (return Nothing))
11:55:00 <EvilTerran> huh
11:55:09 <EvilTerran> aka return (return (return Nothing)) :D
11:55:10 <mdmkolbe> @unpl const (const (return Nothing))
11:55:10 <lambdabot> (\ _ _ -> return Nothing)
11:55:23 <mdmkolbe> bug in pl?
11:55:54 <olsner> :t let foo False _ = return Nothing; foo True x = x >>= (return . Just) in foo
11:55:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> m a -> m (Maybe a)
11:56:06 <EvilTerran> @let foo False _ = return Nothing; foo True x = x >>= (return . Just)
11:56:10 <lambdabot> Defined.
11:56:32 <mdmkolbe> @pl foo x y = if not x then return Nothing else y >>= (return . Just)
11:56:32 <lambdabot> foo = (. (Just `fmap`)) . flip if' (return Nothing) . not
11:56:40 <EvilTerran> > foo True [1,2,3]
11:56:41 <lambdabot>  [Just 1,Just 2,Just 3]
11:56:50 <EvilTerran> apparently, mdmkolbe
11:56:54 <mdmkolbe> I guess pl doesn't like 'let'
11:57:11 <Tac-Tics> > foo False [1,2,3]
11:57:13 <lambdabot>  [Nothing]
11:57:29 <sclv> why is replicate not always genericReplicate?
11:57:43 <EvilTerran> for the same reason !! is not always genericIndex.
11:57:44 <mdmkolbe> @type genericReplicate
11:57:46 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
11:57:52 <EvilTerran> blame the authors of the report.
11:57:53 <mdmkolbe> @type replicate
11:57:55 <lambdabot> forall a. Int -> a -> [a]
11:57:55 <oerjan> i rather think @pl dislikes multiple branches
11:57:57 <ddarius> sclv: How often do you need something other than Int?
11:58:28 <mdmkolbe> ddarius: whenever you want (Num a) or Integer
11:58:40 <earthy_> and you often may want Integer
11:58:46 <ddarius> > genericReplicate (product [1..1000000000]) 3
11:58:50 <lambdabot> Terminated
11:59:07 <oerjan> i guess if it were generic then the defaulting would be Integer rather than Int, which might be less efficient?
11:59:21 <olsner> > product [1..1000] :: Int
11:59:23 <lambdabot>  0
11:59:37 <EvilTerran> oerjan, i thought it translated branches into applications of if'
12:00:17 <oerjan> EvilTerran: case branches with pattern matching cannot be done in that way
12:00:27 <oerjan> and let desugars to those
12:00:31 <Tac-Tics> > product [0..10]
12:00:32 <lambdabot>  0
12:00:37 <mdmkolbe> oerjan: yes, but that is the sort of optimization that is the province of compiler writers not the language spec.
12:00:39 <olsner> ;-)
12:00:47 <Tac-Tics> > (\n -> product [1..n]) 0
12:00:48 <lambdabot>  1
12:00:50 <EvilTerran> let PAT = EXP in ... = case EXP of ~PAT -> ..., right?
12:00:53 <Tac-Tics> > product []
12:00:54 <lambdabot>  1
12:01:32 <mdmkolbe> @unpl (. (Just `fmap`)) . flip if' (return Nothing) . not
12:01:32 <lambdabot> (\ h n -> if' (not h) (return Nothing) (fmap (Just) n))
12:01:59 <EvilTerran> hm. that one unpl'd particularly nicely.
12:02:13 <mdmkolbe> EvilTerran: for some values of nice
12:02:14 <sclv> i'm working with vals that are integrals -- at the point i'm replicating they're going to be well within int range (i hope!) but to get there i'm using integrals -- i just much prefer not having to fromIntegral all over the place
12:02:23 <sclv> its one of the most irritating code smells i've found in haskell
12:02:38 * ddarius loves fromIntegral
12:02:56 <EvilTerran> sclv, import prelude hiding (replicate); replicate = genericReplicate :D
12:03:48 <EvilTerran> you could do that with all the generic*s, put that in a MyPrelude module in your module search path, and -fno-implicit-prelude, even
12:04:04 <EvilTerran> if you think this is going to bother you more than once
12:04:21 <sclv> yr probably right -- i was just wondering why it was designed that way to begin with?
12:04:40 <Olathe> Are there any tools that will take a statement of a problem and determine which good methods (like greedy method, dynamic programming, etc.) can be used ?
12:04:46 <EvilTerran> almost certainly performance, sclv
12:05:20 <EvilTerran> Olathe, look for GNU HaltingProblem; it's still in beta, but it might do what you want ;]
12:05:27 <cizra> EvilTerran: Haha
12:05:39 <earnest> :)
12:05:51 <EvilTerran> yes, well. that silliness aside...
12:05:53 * EvilTerran wanders off
12:06:20 <earnest> that's a very good joke
12:06:29 <dons> EvilTerran: haha :)
12:07:00 <earnest> i feel bad :|
12:07:21 <olsner> asking #haskell usually works, but that depends on whether they find the problem interesting ;-)
12:13:08 <norgul> hi folks
12:13:36 <norgul> a guy challenged me to write a function that takes row and col and returns the element of pascal's triangle
12:14:12 <dons> ah yes, sounds like a cute little problem
12:14:29 <xerox> hehe, it's *quite* easy if you know what those elements *are*.
12:14:32 <monochrom> probably just computing C(row, col)?
12:14:43 <ddarius> It's pretty trivial.
12:15:00 <norgul> but i want as short as possible, to beat his Scheme version :P
12:15:01 <mdmkolbe> guy == professor? problem == homework?
12:15:22 <ddarius> norgul: As xerox said, it's immediate if you know what they are.
12:15:28 <dons> what's the scheme look like? :)
12:15:36 <monochrom> http://www.vex.net/~trebla/haskell/calculator/Calculator.hs  has code
12:15:36 <xerox> Yeah what does it look like? (-:
12:15:50 <norgul> he dont want me to see it, so i can translate his code into haskell
12:16:01 <Olathe> How short is it ?
12:16:15 <ddarius> monochrom: Why not just use factorial.
12:16:17 <mdmkolbe> norgul: umm why doesn't he want you to translate it to haskell?
12:16:39 <norgul> he thinks that is cheating
12:17:00 <dons> so you must solve it yourself then? :)
12:17:04 <mdmkolbe> norgul: why?  If Haskell is better than Scheme, then a direct translation isn't cheating
12:17:07 <Olathe> Then he's not interested in seeing which language is more compact.
12:17:19 <monochrom> Because (6*5*4*3*2*1) / [(4*3*2*1) * (2*1)] is a clear waste of time. At least you want (6*5)/(2*1).
12:17:39 <ddarius> monochrom: You can define falling factorial.
12:18:01 <monochrom> OK, I'll look up falling factorial, but you didn't say it.
12:18:16 <ddarius> True.
12:18:44 <xerox> Ex.(P(x)=>Ax.P(x))
12:18:52 * xerox waits for another "True" 8-;
12:19:08 <ddarius> It's possible that it may still work out to be faster to use your version, but it would be more direct (to me at least) to just use the normal calculation.
12:20:48 <monochrom> For one-off answers (e.g. "I just want C(10,5)"), falling factorial works. In some other applications, if you want many answers, may as well memoize, and that is Pascal triangle.
12:20:56 <mdmkolbe> norgul: what you say sounds like you're asking us to do your homework.  that is why you haven't gotten an answer yet.
12:21:03 <ddarius> monochrom: Yes.
12:21:09 <norgul> uhm
12:21:26 <monochrom> I'll add it to my code when I'm motivated. :)
12:21:37 <norgul> well, i try to think myself a bit
12:21:46 <norgul> but i concider myself as stupid
12:21:47 <ddarius> "Please don't use the Ackermann function!"
12:21:53 <monochrom> Hehehe
12:21:59 <norgul> dont give an answer ..
12:22:09 <Philippa> norgul: is implementing your own factorial cheating as well?
12:22:18 <norgul> nah
12:22:25 <mdmkolbe> @remember ddarius "Please don't use the Ackermann function!"
12:22:25 <lambdabot> Done.
12:22:32 <Philippa> so do that?
12:22:42 <ddarius> mdmkolbe: I was quoting monochrom's code.
12:23:01 <ddarius> Philippa: I don't think he realizes the connection at this point.
12:23:24 <LoganCapaldo> Does the ackermann function have any practical applications besides stress testing recursion? :)
12:23:34 <monochrom> I took a compiler class. I implemented recursion (it was optional). To test it, I added Ackermann. I wrote "Don't run me" in its comment. My TA liked it. :)
12:23:46 <mdmkolbe> norgul: for the answer you must consider the basic math behind pascalls triangle.  There are faster way than using addition to calculate it that have nothing to do with the language of choice.
12:24:25 <norgul> heh, the way i was thinking was to use addition
12:24:40 <norgul> but i think that would be "much coding"
12:25:02 <mdmkolbe> norgul: what level are you in math?
12:25:11 <norgul> I'm 16
12:25:13 <norgul> years old
12:25:21 <norgul> havent learnt much in school yet
12:25:36 <norgul> next year i will learn some more advanced stuff, i guess
12:25:36 <monochrom> 16 is the ripe age for writing your own compiler, you know.
12:25:53 * monochrom eyes FMota and sorear
12:25:55 <mdmkolbe> monochrom: if that was interpreter I'd agree, but compiler?
12:26:09 <monochrom> OK, interpreter.
12:27:24 <Philippa> mdmkolbe: it's reasonable for a first-order language into something fairly simple
12:27:48 <norgul> im actually interested in programming language design and compilers :S
12:27:55 <oerjan> @remember monochrom 16 is the ripe age for writing your own compiler, you know.
12:27:56 <lambdabot> Done.
12:28:14 <mdmkolbe> norgul: search the web for info on Paskall's triangle.  You will find an equation that is more direct than the addition fairly quickly (remember to cite your source if this is for a homework).
12:28:29 <Saizan> "Pascal"
12:28:31 <norgul> this isnt homework
12:28:42 <norgul> do you think we do programming at school?
12:28:52 <norgul> this is on hobby basis
12:28:53 <monochrom> What do you do at school?
12:29:10 <norgul> english, norwegian, science, math
12:29:35 <ddarius> I'm not sure when I first read that little Pascal compiler tutorial.  It was a long long time ago though.
12:30:23 <norgul> heh, i have Compilers, Principles, Tools and Technique here ...
12:30:33 <norgul> havent read much in it, though
12:31:21 <Philippa> the dragon book's really not a good intro these days
12:31:22 <monochrom> Hey, Pascal in 48 hours!
12:31:36 <Philippa> try Appel's "Modern Compiler Implementation in ML" (you can get Java or C too, but you want ML)
12:31:48 <norgul> sure
12:31:53 <ddarius> I'd like to flip through that at least some time to see if I'd want it.
12:31:57 <monochrom> Yeah, the Java and the C versions are less readable somehow.
12:32:03 <mdmkolbe> Philippa: my school used that book, it wasn't very good
12:32:16 <norgul> im mostly interested in programming language design
12:32:20 <mdmkolbe> Philippa: well the Java version of that book
12:32:21 <norgul> any good books?
12:32:21 <monochrom> It is very good, IMNSHO.
12:32:36 <monochrom> But I mean the ML version.
12:32:47 <Philippa> mdmkolbe: ML's the language Appel actually likes to work in, I suspect the other two versions suffered somewhat in translation
12:33:08 <Philippa> norgul: LtU's reading list's worth a peek through
12:33:09 <monochrom> You have to take a lot of concessions to do it in Java, you know?
12:33:23 <ddarius> I believe the content is actually somewhat different between them too.
12:33:30 <mdmkolbe> At least the Java version spent to much time on the parsing and front end parts and glossed over the back end
12:33:38 * ddarius remembers reading Steele's thesis the first time.
12:33:50 <mdmkolbe> s/to/too/
12:34:17 <wli> What was Steele's thesis?
12:34:36 <dons> so, anyone else plan on getting a phd in haskell studies, so they can get a job at a big investment bank? :)
12:34:37 <ddarius> RABBIT: A compiler for Scheme (or some such)
12:34:40 <monochrom> Yeah, I think I heard many people agreeing that the Java version is poor. But don't draw the same conclusion about the real version yet.
12:34:51 <Heffalump> "haskell studies"?
12:35:01 <dons> :)
12:35:03 <mdmkolbe> dons: I would if I knew how
12:35:14 <norgul> if i would design my own programming language, i would definately use some haskell features
12:35:16 <dons> `This is a great opportunity for PhD students or above with proven experience of Haskell programming.'
12:35:17 <mdmkolbe> dons: (except maybe the bank part)
12:36:00 <sioraiocht> @src or
12:36:00 <lambdabot> or    =  foldr (||) False
12:36:16 <Heffalump> how does that translate to "a phd in haskell studies"?
12:36:26 <mrd> Appel is alright, though I wasn't too pleased with the presentation of register allocation.  I did manage to get mine working though.
12:36:44 <dons> Heffalump: oh, it was a new discipline I just came up with to describe a phd spent in #haskell :)
12:36:56 <sioraiocht> dons: If I would definitely do quant. finance after I finish grad school =p
12:37:17 <Heffalump> :-)
12:37:19 <Philippa> mrd: yeah, that's something you can read up more on over time though - you've still got a working compiler and an idea of what search terms to use
12:37:22 <cognominal_> @src replaceAt
12:37:23 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:37:30 <sioraiocht> dons: maybe we should make #haskell a degree granting institution, -
12:37:33 <sioraiocht> =p even
12:37:35 <dons> i like it!
12:37:37 <mdmkolbe> @remember dons so, anyone else plan on getting a phd in haskell studies, so they can get a job at a big investment bank? :)
12:37:37 <lambdabot> Done.
12:37:51 <ddarius> @google Appel iterative coalescing
12:37:53 <lambdabot> http://www.cs.cmu.edu/afs/cs/academic/class/15745-s07/www/papers/presentations/register_allocation.pdf
12:37:53 <mdmkolbe> (so I can cite in in my thesis later ;-) )
12:37:58 <dons> yes, we can offer diplomas, bachelors and graduate degrees in haskell studies
12:37:59 <monochrom> @remember sioraiocht maybe we should make #haskell a degree granting institution
12:37:59 <lambdabot> Done.
12:37:59 <sioraiocht> hahahah
12:38:04 <dons> just send me your credit card details!
12:38:26 <oerjan> cognominal_: splitAt may help
12:38:36 <mrd> I just did the basic graph coloring algo with some coalescing
12:38:59 <LoganCapaldo> I want a #haskell degree
12:39:16 <nominolo> dons, what's the advantage of a phd anyways?
12:39:30 <ddarius> nominolo: You get to be called "Doctor!"
12:39:30 <LoganCapaldo> Think I could get an associates degree in simplified layout rule analysis?
12:39:38 <dons> nominolo: you can get a job at a big investment bank?
12:39:39 <nominolo> ddarius, other than that
12:39:55 <dons> its well  known that phds have more fun
12:39:59 <nominolo> dons, but if i don't want to?
12:40:10 <sioraiocht> nominolo: you do it so you can say you made it through
12:40:12 <ddarius> dons: Certainly more fun than those working on their PhD
12:40:28 <sioraiocht> nominolo: and in theory you know lots of stuff =p
12:40:36 <ddarius> In theory...
12:40:41 <dons> heh
12:40:47 * sioraiocht mutters "blah blah blah, everything about nothing."
12:40:52 <nominolo> well, many haskell papers are really practical
12:41:11 <nominolo> at least as much as practical relates to haskell programming
12:41:24 <sioraiocht> nominolo: getting a phd also guarantees you will always be dissatisfied with the salary you receive in proportion to your education
12:41:25 <ddarius> That's because theory and practice are almost identical in Haskell.
12:41:28 <xerox> dons and dcoutts were awarded the best practical paper award too ;)
12:41:36 <dons> you get to tick the first box on forms marked: [Dr] [Mr] [Mrs] [Miss] [Ms]
12:41:56 <nominolo> does simonpj have a phd?
12:41:59 <dons> though not the ones with [Rev] or [Hon] first
12:42:04 <sioraiocht> speaking of practical, anyone know ho to reduce a dislocated finger?
12:42:07 <ddarius> nominolo: No, I don't think so.
12:42:15 <nominolo> ddarius, see? :)
12:42:16 <Philippa> he doesn't, but he started out when the field was rather younger
12:42:18 <Philippa> that changes things
12:42:24 <dons> sioraiocht: simmer gently for a couple of hours under a low flame?
12:42:36 <dons> garnish with rosemary and pepper
12:42:37 <mdmkolbe> nominolo: SPJ is so high up there, he's prefix-less
12:42:49 <chessguy> hmm, dislocated finger, that sounds like a foldl' to me
12:42:58 <monochrom> The process of getting a PhD includes allowing you to learn monads and call it "work". Contrast with: you have a real job doing something else, your monad learning has to be a weekend project at best.
12:43:03 <sioraiocht> oh man, I'm never asking for random help here AGAIN =p
12:43:04 <glguy> You'd think that the phd's would give him a dr. so that they could  be in the same club as him ;)
12:43:15 <Tac-Tics> monochrom: that is such a painful truth
12:43:22 <nominolo> glguy, heh
12:43:24 <sioraiocht> monochrom: but either way, you don't get paid for learning about i =p
12:43:25 <sioraiocht> *it
12:43:26 <ddarius> nominolo: Don't try to argue that point with me, I don't immediately have a high opinion of PhDs simply because they have PhDs.
12:43:28 <dons> glguy: all ready for the big game? :)
12:43:35 <glguy> dons, I suppose :)
12:43:45 <dons> glguy: i picked up some sambas, and some shin pads for suzie. so we're set.
12:43:46 <monochrom> Actually, there are ways you get paid for doing PhD.
12:43:48 <chessguy> what big game?
12:43:50 <mdmkolbe> game?
12:43:51 <dons> we've been running drills up and down the hallway
12:44:04 <nominolo> for me 3 more unpaid or 5 more half-payed years don't sound too rewarding
12:44:07 <dons> galois v someone in soccer :)
12:44:12 <glguy> Wow, you guys will probably be the stars of the game with that kind of regimine
12:44:28 <glguy> I never know how to spell that last word
12:44:31 <sioraiocht> ddarius: however, you shouldn't have a low opinion of someone for having one either? =p
12:44:39 <xerox> ?spell regimine
12:44:41 <chessguy> @spell regimine
12:44:41 <dons> ?spell regime
12:44:47 <xerox> haha.
12:44:50 <dons> ah, no aspell
12:44:52 <nominolo> regimen
12:44:53 <chessguy> @quote stereo
12:44:53 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
12:44:59 <chessguy> what??
12:45:05 <dons> hmm
12:45:08 <dons> ?qyote
12:45:09 <lambdabot> mudge says: I like big butts and can not lie
12:45:12 <glguy> ah
12:45:13 <dons> that's new.
12:45:14 <glguy> regimen
12:45:16 <dons> ?quote dons
12:45:17 <lambdabot> dons says: "academic" is such an amusing insult.
12:45:20 <dons> that's old
12:45:22 <dons> ?quote stereo
12:45:23 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:45:25 <dons> ?Quote Cale
12:45:26 <lambdabot> Cale says: What we need are monad tutorial transformers. // So that we can compose the features of monad tutorials
12:45:26 <norgul> folks
12:45:30 <nominolo> http://www.m-w.com/dictionary/regimen
12:45:34 <lambdabot> Title: Definition of regimen - Merriam-Webster Online Dictionary
12:45:43 <norgul> my friends pasted his version of pascal's triangle
12:45:44 <norgul> http://paste.lisp.org/display/47488
12:45:57 <norgul> rad means row and kol is col
12:46:28 <norgul> and a haskell version :S
12:46:31 <sorear> dons: no
12:46:37 <sorear> dons: and San Diego :/
12:46:38 <ddarius> sioraiocht: I didn't say that.
12:46:56 <sioraiocht> ddarius: oh, I wasn't trying to imply that you did, heh
12:47:10 <hpaste>  mdmkolbe pasted "Try using guards like this" at http://hpaste.org/2649
12:47:11 <ddarius> Essentially, I could care less what your education is, I'll judge based on what you write/say.
12:47:26 <mdmkolbe> norgul: http://hpaste.org/2649
12:47:26 <chessguy> hmm. shame you can't do pascal rad rad = ...; pascal rad kol = ...
12:47:33 <monochrom> pascal 0 0 = 1  change this to pascal 0 kol = 1
12:47:38 <dons> sorear: ah! oops
12:48:11 <byorgey> norgul: hmm, doesn't that have exponential complexity?
12:48:23 <glguy> I can't imagine why my puppy doesn't like beef flavored toothpaste
12:48:23 <monochrom> I think it's intended.
12:48:32 <glguy> I mean... I enjoy using it every day
12:48:45 <chessguy> uh...pascal _ 0 = 1 you mean?
12:48:55 <byorgey> yeah, it's not necessarily important, just pointing it out =)
12:49:02 <sclv> hmm... wouldn't some memoization speed things up?
12:49:04 <chessguy> instead of the first 2 lines
12:49:11 <dons> btw, you know what's so great about working at galois? i get to sit next to the guy who wrote mtl, the guy who wrote monadLib, the guy who wrote halfs and some guy who wrote hpaste.org :)
12:49:22 <chessguy> @bot
12:49:22 <lambdabot> :)
12:49:23 <mdmkolbe> sclv: using a different equation (see Wikipedia) would speed things up
12:49:29 <dons> glguy: don't you think with that team we should be able to churn out some code?
12:49:30 * glguy was wondering how he was going to fit into that :)
12:49:40 <glguy> dons, I'm counting on it
12:49:42 <ndm> dons: i get to have a similar number of projects from sitting at York
12:49:53 <dons> ndm, yeah, york is similarly dense
12:50:07 <ndm> despite having only 5 functional programmers...
12:50:10 <sorear> dons: what about the guy who made bytestrings practical? :D
12:50:19 <dons> duncan?
12:50:19 <mdmkolbe> sclv: that code is O(2^n).  With memoization it's O(n^2).  With a smarter equation it's O(n) where n is the magnitude of the inputs
12:50:20 <dons> :)
12:50:23 <ndm> sorear: he sits on that guy's chair :)
12:50:43 <glguy> dons, the biggest thing that I know Isaac wrote was the apt-secure program
12:50:59 <dons> and cabal. :)
12:51:00 <glguy> I know he's been involved in other stuff, but that's the one I use daily
12:51:02 <glguy> yeah, that!
12:51:03 <glguy> :)
12:51:05 <sclv> right -- but it would at least beat his friends.
12:51:35 <dons> glguy: we need a galois open source page, listing all the projects maintained by galois people
12:51:47 <Trixsey> Is there a function to split a list, or anything similar?
12:51:52 <glguy> dons, Mention that interest to Andy Gill
12:51:52 <Trixsey> Like split at all spaces
12:51:55 <ndm> dons: sounds like a hackage query
12:52:02 <dons> glguy: i might just do it anyway.
12:52:06 <dons> ndm: yeah, good idea.
12:52:08 <monochrom> > words "skjdkfj   sjkdjk kdjk   djkf"
12:52:08 <allbery_b> > words "fee fi fo fum"
12:52:13 <ddarius> dons: You are uncertain that the Haskell community recognizes the contributions of Galois?
12:52:13 <ndm> dons: i.e. having a static page just waiting to go out of date seems like a bad idea, when all the meta information is already stored
12:52:16 <dons> ndm, btw, did you send in your tshirt size?
12:52:20 <lambdabot>  ["fee","fi","fo","fum"]
12:52:21 <lambdabot>  ["skjdkfj","sjkdjk","kdjk","djkf"]
12:52:21 <allbery_b> botverload!
12:52:24 <glguy> dons, I just said Andy  because he's one for pushing code out the door
12:52:30 <ndm> dons: i can't make it to the hackathon - hotels and flights didn't work out :(
12:52:35 <allbery_b> @src words
12:52:36 <lambdabot> words s = case dropWhile isSpace s of
12:52:36 <lambdabot>     "" -> []
12:52:36 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:52:47 <ndm> dons: i'd still love a t-shirt, if thats possible :)
12:52:50 <norgul> byorgey, not my code, my friend pasted his haskell version too
12:52:51 <dons> ndm: oh! do let us know then, i think you're still on the list :(
12:52:54 <monochrom> "words" is specific for spaces. But you should steal its source code and adopt it for other purposes.
12:52:58 <dons> ndm: yeah, probably we can get some extras
12:53:10 <dons> ndm, at least cross your name off the attendees list on the wiki please
12:53:11 <chessguy> @type break
12:53:13 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:53:19 <ndm> dons: i only got flights and tickets late last week, we left it too late :(
12:53:23 <dons> :(
12:53:42 <chessguy> @hoogle (a -> Bool) -> [a] -> [[a]]
12:53:42 <lambdabot> No matches, try a more general search
12:53:47 <ndm> we're 7km away from frieburg for IFL
12:54:00 <dons> isn't IFL and the hackathon at the same location?
12:54:12 <Heffalump> 7km?? I thought it was (a slightly long) walking distance.
12:54:24 <ddarius> That's walking distance...
12:54:31 <sorear> ndm: 12:52 < allbery_b> @src words
12:54:39 <dons> it's a 30 minute walk or something.
12:54:42 <ndm> dons: yes, but we're 7km away from IFL, miles out
12:54:46 <Heffalump> only if you have a lot of spare time. And it's not a 30 minute walk.
12:54:49 <ndm> dons: no, thats an hour at least
12:54:51 <Heffalump> ah, right.
12:55:06 <ndm> sorear: i saw, was just thinking whether to jump in or not :)(
12:55:24 <ddarius> > 7 * 0.6
12:55:24 <ndm> allbery_b: the definition of words isn't very good, if you want to use it, you should use a revised copy of words to start from
12:55:26 <lambdabot>  4.2
12:55:44 <ndm> allbery_b: http://www-users.cs.york.ac.uk/~ndm/temp/draft-supero.pdf - there is a new copy of words in that paper
12:55:51 <allbery_b> I wasn't planning anything, was just wondering in light of Trixsey's query
12:55:53 <sorear> @activity-full 300
12:55:54 <lambdabot> 10*total 8*#haskell 2*#scannedinavian
12:55:57 <chessguy> i wondered if you were going to comment on that, ndm
12:56:08 <LoganCapaldo> @let word = head . words
12:56:10 <lambdabot> Defined.
12:56:24 <LoganCapaldo> > word "to your mother"
12:56:25 <lambdabot>  "to"
12:56:30 <ndm> i was looking at enhancing my supercompiler with CSE, then i might be able to change it automatically
12:56:42 <ndm> then leaving words as it is hinders GHC massively and makes no difference to me :)
12:57:14 <allbery_b> (I was actually rather surprised by the definition)
12:57:26 <LoganCapaldo> @type words
12:57:26 <ndm> its pretty close, only a few tweaks and its efficient
12:57:28 <lambdabot> String -> [String]
12:57:38 <norpan> word!
12:57:40 <ndm> it does two redundant isSpace tests per word
12:58:09 <ndm> if someone wants to prove that my implementation is correct, we can fix up the one in the Prelude
12:58:25 <ndm> or at least wants  to test it using strictness etc stuff
12:58:31 <LoganCapaldo> @let word = fst . break isSpace
12:58:32 <lambdabot> <local>:6:0:     Multiple declarations of `L.word'     Declared at: <local>:5...
12:58:33 <sclv> @type splitWith
12:58:35 <lambdabot> Not in scope: `splitWith'
12:58:37 <LoganCapaldo> @let word' = fst . break isSpace
12:58:40 <lambdabot> Defined.
12:58:48 <LoganCapaldo> word' "to your mother"
12:58:52 <LoganCapaldo> > word' "to your mother"
12:58:53 <lambdabot>  "to"
12:59:06 <ndm> > word' "  neil is here"
12:59:07 <lambdabot>  ""
12:59:08 <ndm> > word "  neil is here"
12:59:09 <lambdabot>  "neil"
12:59:21 <allbery_b> @check \x -> word x == word' x
12:59:22 <lambdabot>  Exception: Prelude.head: empty list
12:59:22 <LoganCapaldo> Nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
13:00:04 <oerjan> oh, @check reads @let definitions?
13:00:05 <sclv> @type splitWithPS
13:00:07 <lambdabot> Not in scope: `splitWithPS'
13:00:33 <oerjan> sclv: there is no generalized words available
13:00:38 <allbery_b> @check \x -> not (null x) ==> word x == word' x
13:00:39 <lambdabot>  OK, passed 500 tests.
13:01:04 * allbery_b had to test it, still unfamiliar with @check syntax
13:01:25 <sclv> oerjan: yeah those are for bytestring and packedstring types -- just wanted to put them on the channel but don't know lambdabot v. well yet
13:02:33 <balodja> data Tree a = Branch (Tree a) (Tree a) | Leaf a
13:02:50 <balodja> Why is it always called Tree?
13:03:01 <balodja> That's rather List, I think.
13:03:02 <fakeolliej2> balodja: because it's a binary tree...
13:03:12 <sclv> because one and troo were taken?
13:03:39 <mdmkolbe> balodja: data List a = Null | Cons a (List a) -- list != tree
13:03:40 <balodja> data Tree a = Branch a (Tree a) (Tree a) | Leaf -- that's binary tree
13:03:51 <fakeolliej2> no
13:03:58 <fakeolliej2> balodja: where would you store data?
13:04:07 <fakeolliej2> balodja: oh
13:04:09 <twanvl> Both are binary trees
13:04:15 <fakeolliej2> balodja: you have leaf nodes with no content
13:04:20 <byorgey> balodja: Branch (Tree a) (Tree a) | Leaf a is still a binary tree, it's just that there's only data at the leaves
13:04:28 <mdmkolbe> balodja: some binary trees have data on leaves, some on branches, some on both with different types of data
13:05:04 <LoganCapaldo> Do any have no data on branches or leaves? :)
13:05:06 <byorgey> balodja: the important point is that there are two instances of "Tree a" in a "Branch", so it has a binary branching structure
13:05:08 <balodja> ok, no more questions.
13:05:09 <oerjan> data Tree a b = Branch a (Tree a b) (Tree a b) | Leaf b
13:05:14 <mdmkolbe> LoganCapaldo: yes
13:05:15 <byorgey> LoganCapaldo: sure =)
13:05:31 <byorgey> data Tree = Branch Tree Tree | Leaf
13:05:53 <LoganCapaldo> mdmkolbe, byorgey any interesting use cases for that?
13:05:57 <paolino> applied biology
13:06:08 <balodja> oerjan: that seems to be useful for expressions :) a is an operator and b is an operand
13:06:21 <ddarius> There are approaches that separate the shape of the data from its contents.
13:06:23 <byorgey> LoganCapaldo: well, if you're only interested in the *structure* of a tree
13:07:03 <mdmkolbe> LoganCapaldo: encoding a binary tree that *has* data by spliting it into a tree without data and a list of the data.  (DEFLATE does something that is *almost* like that but not quite)
13:07:20 <mdmkolbe> (DEFLATE == the compression algorithm in gzip)
13:07:30 <LoganCapaldo> mdmkolbe, I can see that
13:07:37 <balodja> data Tree = Branch Tree Tree | Leaf -- hm-m-m. useful for representation of "kind" in haskell, yeah? :)
13:07:57 <mdmkolbe> balodja: except that we have both * and ? now
13:08:17 <byorgey> mdmkolbe: hmm, what's ?
13:08:19 <ddarius> and ??
13:08:26 <oerjan> :k (->)
13:08:26 <mdmkolbe> balodja: IIRC, * is boxed, ? is unboxed
13:08:35 <lambdabot> ?? -> ? -> *
13:08:39 <allbery_b> thought # was unboxed
13:08:49 <ddarius> My kind type in my lollimon vapourware interpreter is isomorphic to that tree type.
13:09:07 <ddarius> :k (#,#0
13:09:09 <lambdabot> parse error on input `,'
13:09:10 <ddarius> :k (#,#)
13:09:12 <lambdabot> parse error on input `,'
13:09:12 <dons> bbl
13:09:16 <mdmkolbe> :k Int#
13:09:18 <lambdabot> Not in scope: type constructor or class `Int#'
13:09:27 <allbery_b> :k GHC.Prim.Int#
13:09:29 <lambdabot> #
13:09:37 <ddarius> A whole menagerie of kinds.
13:09:45 <mdmkolbe> hmm, then I have no idea what ? is
13:09:56 <ddarius> It can be either # or *
13:09:57 <oerjan> i think ? is supertype of * and #
13:10:19 <oerjan> and ?? is supertype of that and unboxed tuples
13:10:23 <balodja> What does ?? stand for?
13:10:40 <oerjan> or is that the other way around
13:10:42 <LoganCapaldo> Dragons, probably
13:10:43 <allbery_b> :k (# #,# #)
13:10:45 <lambdabot> parse error on input `#'
13:10:56 <oerjan> ? is the largest supertype
13:10:57 <mdmkolbe> oerjan: at this point don't we need to add var names? (e.g. ?a -> ?a -> ?b -> ?b -> #)
13:11:01 <oerjan> :k (->)
13:11:03 <lambdabot> ?? -> ? -> *
13:11:13 <allbery_b> :k (# *,* #)
13:11:15 <lambdabot> parse error on input `*'
13:11:19 <ddarius> mdmkolbe: no
13:11:34 <ddarius> :k (# Int#, Int# #)
13:11:35 <lambdabot> Not in scope: type constructor or class `Int#'
13:11:35 <lambdabot>  
13:11:35 <lambdabot> <interactive>:1:9: Not in scope: type constructor or class `Int#'
13:11:37 <oerjan> the right argument of -> may be an unboxed tuple but not the left one
13:11:43 <LoganCapaldo> :k (#,#)
13:11:45 <lambdabot> parse error on input `,'
13:11:52 <ddarius> :k (# GHC.Prim.Int#, GHC.Prim.Int# #)
13:11:54 <lambdabot> (#)
13:12:01 <LoganCapaldo> hoooooooray
13:12:33 <allbery_b> ah, so there's the other magic kind
13:12:37 <oerjan> (because unboxed tuples may only be returned, not passed into a function)
13:12:46 <mdmkolbe> oerjan: so ? is a super of ??
13:12:49 <mdmkolbe> ?
13:12:54 <oerjan> yes
13:12:54 <allbery_b> heh
13:13:04 <LoganCapaldo> The riddler has invaded #haskell
13:13:23 <oerjan> there's a diagram in the ghc docs last i looked
13:13:31 <oerjan> but it leaves out the mysterious !
13:13:34 <allbery_b> The riddler has always been here
13:13:51 <allbery_b> ( </kosh> )
13:13:53 <mdmkolbe> Sooo...how long untill we just give up and support the entire hierarchy like Clean does?
13:14:17 <mdmkolbe> oerjan: there's a '!' ?!
13:14:39 <elliottt> what's the easiest way to turn a literate file into a non-literate one?  (i'd like to preserve the text as comments)
13:14:41 <oerjan> yes, apparently, though no one has been able to tell me what it is
13:14:59 <opqdonut> mdmkolbe: what kind of hierarchy does clean have then?
13:15:05 <byorgey> elliottt: I think there's an option you can give to lhs2tex to strip out all the literate stuff
13:15:06 <allbery_b> if not for your parenthetical I'd suggest unlit
13:15:16 <elliottt> byorgey: thanks :)
13:15:17 <allbery_b> (in the ghc lib directory)
13:15:23 <byorgey> elliottt: oh, wait, I didn't see your parenthetical...
13:15:53 <elliottt> hrm, maybe i can write some crafty ruby script :)
13:15:59 <mdmkolbe> opqdonut: just as kinds are the 'types of types', you can have 'types of kinds' and 'type of types of kind', etc.
13:16:02 <elliottt> or actually, haskell might be easier at this point
13:16:07 <byorgey> elliottt: shouldn't bee too hard to write a Haskell program to do it... delete every > at the start of a line, and add a -- at the start of all others
13:16:28 <opqdonut> mdmkolbe: ah
13:16:50 <opqdonut> what are all these good for?
13:17:01 <elliottt> byorgey: yeah, that seems best.  thanks :)
13:17:06 <byorgey> unlines . map unlit . lines, where lit ('>':rest) = rest; lit xs = "-- " ++ xs
13:17:19 <byorgey> uh, s/lit/unlit/
13:17:23 <mdmkolbe> opqdonut: I don't know.  I've never actually used Clean.
13:17:33 <oerjan> byorgey: i think you want '>':' ':
13:17:41 <byorgey> oerjan: yeah, you're right
13:18:18 <oerjan> hm, what about tabs?
13:18:30 <allbery_b> tabs are evil
13:18:30 <byorgey> oerjan: bah humbug
13:18:47 <oerjan> i mean, are they allowed after >?
13:19:07 <byorgey> oerjan: I have no idea
13:19:14 * oerjan checks
13:19:37 * allbery_b would also pass empty lines unchanged, just as a matter fo eprsonal preference
13:19:46 <allbery_b> ...pretend I can type
13:20:07 <byorgey> allbery_b: yeah, I would too, I was just suggesting a basic starting place
13:20:38 <oerjan> oh, i was wrong about space after >, it is not significant
13:20:42 <allbery_b> of course it's easy enough to add that pattern if you ignore lines containing whitespace
13:20:54 <byorgey> oerjan: only with lambdabot, eh? =)
13:21:00 <allbery_b> lit [] = []
13:21:31 <oerjan> "replacing the leading ">" with a space"
13:21:45 <mdmkolbe> is there a varient of literate programming that is literate *and* test driven (i.e. the program is the documentation is the test suite)
13:22:30 <oerjan> (presumably to keep alignment if there is an evil mix of tabs and spaces)
13:24:16 <ddarius> mdmkolbe: Use quickcheck
13:27:45 <Cale> mdmkolbe: Nope. It just can't be done. ;)
13:28:13 <mdmkolbe> I only ask b/c I had to write my own a little while ago.
13:28:50 <Cale> mdmkolbe: I suspect that quickcheck would work well with such an idiom.
13:29:17 <allbery_b> yeh, I was just thinking quickcheck with lines prefixed by, say, ?
13:29:26 <mdmkolbe> It was a tutorial text with a lot of "if you do this, you'll get this" examples.  Writing a perl script to extract those examples and test that the results were correct found a few bugs.  (This was in scheme.)
13:29:32 <allbery_b> (and easy enough to wrap unlit for normal compiles)
13:30:42 <sorear> why do we need tests when we can just prove our programs correct?
13:31:19 <Cale> sorear: Sometimes the proof is wrong for some unforeseen technicality?
13:31:40 <Cale> (For example, correct programs can still be impractical)
13:31:54 <mdmkolbe> sorear: then we need to debug the equation that we are proving to be true
13:32:02 <sorear> Do test suites test practicality?
13:32:30 <Cale> Yeah, because you actually run them. If the tests take forever to run or too much memory, then you realise there's a problem.
13:32:43 <mdmkolbe> e.g. is "foo x = not x" correct? or is that a bug that should be "foo x = x"?
13:41:35 <sioraiocht> if you are creating a type class, do you HAVE to specify what the necessary minimal definitions are, or does haskell just "know"
13:42:07 <mdmkolbe> sioraiocht: I think Haskell will jsut know
13:42:31 <sioraiocht> I thought so, or at lesat just errors if you attempt to call certain functions without an acceptable definition
13:43:19 <allbery_b> I *think* it doen't check unless it sees a call to an unimplemented method
13:43:22 <mdmkolbe> sioraiocht: for example "class Eq a where a == b = not (a /= b); a /= b = not (a == b)".  At least one of those has to be defined but it doesn't matter which one (not sure if that error is checked).
13:43:45 <sioraiocht> okay, that's what I thought, just making sure I wasn't missing something
13:44:10 <oerjan> it might be able to do more with strictness analysis
13:46:53 <sioraiocht> hrm, let's find out..
13:48:01 <chessguy> mdmkolbe, what do you mean, "checked"?
13:48:24 <mdmkolbe> chessguy: it might just go into an infinite loop at run time
13:48:33 <allbery_b> that you didn't define either of those methods, which if taken literally are mutually recursive
13:48:39 <allbery_b> with no end condition
13:48:44 <chessguy> ah, i see
13:49:01 <chessguy> i guess i assumed that was checked, but it's not written like it
13:49:07 <elliottt> if i have a library that parses a text protocol, but doesn't do any network interaction, does it make sense to put it in Network?
13:49:08 <sioraiocht> chessguy: it's not
13:49:11 <sioraiocht> I just tested
13:49:12 <chessguy> @src Eq
13:49:12 <lambdabot> class  Eq a  where
13:49:12 <lambdabot>     (==), (/=)   :: a -> a -> Bool
13:49:17 <sioraiocht> you end up with a stack overflow
13:49:24 <allbery_b> cute
13:49:28 <allbery_b> @bug -- ?
13:49:28 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
13:49:29 <chessguy> well, but how do you instantiate Eq without defining either?
13:50:17 <sioraiocht> chessguy: well in that case you only need one of two to make a definition, but I just tried ti with Foldable, defining a function that doesn't meet the minimal def
13:50:19 <sioraiocht> stack overflow
13:50:34 <balodja> > [1,1..] !! 200
13:50:37 <lambdabot>  1
13:50:54 <balodja> does is calculate 199 ones?
13:50:55 <chessguy> oh, you tested a different class
13:51:03 <chessguy> @src Foldable
13:51:03 <lambdabot> Source not found. Where did you learn to type?
13:51:06 <allbery_b> balodja: shouldn't
13:51:10 <sioraiocht> @src Data.Foldable
13:51:10 <lambdabot> Source not found. Where did you learn to type?
13:51:15 <allbery_b> it reifies the list but it's all thunks
13:51:38 <sioraiocht> allbery_b: so it still allocates the memory, then
13:51:39 <sioraiocht> heh
13:51:50 <allbery_b> some of the memory
13:52:23 <balodja> > [1,1..] !! 200000
13:52:24 <lambdabot>  1
13:52:30 <sioraiocht> chessguy: I tested Eq too
13:52:40 <sioraiocht> by doing "instance Eq (Tree a) where"
13:52:43 <sioraiocht> without any definitions
13:52:50 <chessguy> heh. nice
13:52:54 <sioraiocht> and it let me compare them, but I got a stack overflow
13:53:21 <chessguy> surely that should never be allowed, to declare an instance without a definition
13:53:36 <sioraiocht> chessguy: what if you have a class that needs no minimal defs?
13:53:39 <sioraiocht> oops, dinner time
13:54:15 <chessguy> hm
13:54:57 <chessguy> i'm not sure what that would look like
13:55:01 <ddarius> chessguy: I often do that.
13:55:14 <chessguy> ddarius, for what class?
13:55:57 <|Jedai|> allbery_b: It allocate the memory okay, but in fact it throw it away as soon as it processed the thunk, so it's in constant memory
13:56:02 <mdmkolbe> chessguy: actually it is possible to declare in instance without a def
13:56:16 <ddarius> chessguy: 1) Any class that I can't implement 2) any class with no methods 3) any class that already has suitable defaults
13:56:57 <chessguy> err, if you can't implement it, why are you creating an instance of it?
13:57:02 <mdmkolbe> chessguy: it's used when you want to flag certain types as belonging to a class without needing not know anything about that class (e.g. classes that an alternative algorithm should be used for)
13:57:44 <ddarius> chessguy: Because it may be required to use other classes or functions.
13:58:11 <ddarius> E.g. I may want Num b => Num (a -> b) but I can't implement Eq or Ord, and barely Show.
13:58:27 <chessguy> but if it's required, surely a definition would be required too
13:58:33 <ddarius> Nope.
13:58:36 <chessguy> otherwise the requirement shouldn't be there
13:58:49 <ddarius> Perhaps, but Haskell has legacy too.
14:00:38 <newsham> http://www.thenewsh.com/%7Enewsham/formal/parse/parser.lhs
14:01:01 <newsham> anyone wanna read a small parser tutorial and give feedback?
14:01:21 <ddarius> Can I read it without giving you feedback or give you feedback without reading it?
14:01:32 <newsham> you are free to do as we tell you, ddarius
14:02:13 <mdmkolbe> newsham: what parsing technique do you use? Parsec? CYK? LALR? GLR? Early? Pack-rat?
14:02:23 <newsham> its basically about parsec
14:02:28 <chessguy> newsham, i'm already reading it :)
14:02:52 <newsham> target audience is beginners, btw.
14:03:06 <ddarius> Another upside is that it's easier to implement backtracking.
14:03:20 <newsham> advantage to being a monad?
14:03:39 <chessguy> "Each instance of Parser a will contain a parsing function." ...slightly more accurate, and maybe slightly less confusing would be: "Each value of type Parser a will be a parsing function"
14:03:44 <mrd> speaking of which, ParsecT []
14:03:58 <newsham> chess: danke
14:04:08 <mrd> non-det parsing?
14:04:09 <mdmkolbe> I thought parsec had moved to arrows b/c of space leaks
14:04:48 <chessguy> @pl r (P p) i = p i
14:04:48 <lambdabot> (line 1, column 11):
14:04:48 <lambdabot> unexpected "="
14:04:48 <lambdabot> expecting variable, "(", operator or end of input
14:05:19 <allbery_b> can't unpl pattern matches
14:05:24 <allbery_b> er, @pl
14:05:29 <chessguy> oh, right
14:05:48 <EvilTerran> @pl r (Maybe p) i = p i
14:05:49 <lambdabot> (line 1, column 15):
14:05:49 <lambdabot> unexpected "="
14:05:49 <lambdabot> expecting variable, "(", operator or end of input
14:06:07 <monochrom> yeah, "instance" has another meaning around here
14:06:41 <newsham> instance means instance :)  wehter its an instance of a type or an instance of a type class :)
14:06:47 <oerjan> @pl r (Just p) i = p i
14:06:48 <lambdabot> (line 1, column 14):
14:06:48 <lambdabot> unexpected "="
14:06:48 <lambdabot> expecting variable, "(", operator or end of input
14:06:52 <newsham> but I like chess' wording better
14:07:47 <mdmkolbe> newsham: when teaching, each jargon word should have only one meaning and should only be used to mean that
14:08:25 <newsham> mdm: *nod*  I would tend to agree.
14:08:27 <chessguy> newsham, i think there's an issue with the way you switch to "data Parser a = ..."
14:08:43 <chessguy> well, for one thing, there's a typo in "> parse Int "123 abc" == Just (" abc", 123)"
14:09:12 <chessguy> but you can't assume a beginner will understand parameterized data types
14:09:15 <newsham> *nod*  I forgot to go back and recheck the examples
14:09:52 <chessguy> you sort of explained it with Maybe, but should probably hit that a little harder
14:09:58 <newsham> chess: think adding a single example will clarify?  ie Parser Char means ....
14:10:12 <mrd> byorgey: where can I find one of these "Haskars" on sale? =)
14:10:12 <mdmkolbe> newsham: if you know perl, I'd recomend writting a perl script to extract the examples and check that they product the correct output (I've done in for some of my documents and it helps quite a bit.)
14:10:34 <newsham> thats a job for awk or sed ;-)
14:10:38 <oerjan> @quote haskar
14:10:39 <lambdabot> No quotes match. I feel much better now.
14:10:51 <chessguy> yeah, maybe say something like "'a' here again means any type. For example, Parser Char means..."
14:10:53 <EvilTerran> or grep, if it's a LHS
14:11:08 <mudge> can more than one bots be in the room?
14:11:21 <mdmkolbe> newsham: fair enough.  I just made it a point to never learn awk or sed b/c why learn 2/3 langs when I only need one ;-)
14:11:59 <chessguy> newsham, oh, and you probably want to point out that type String = [Char] somewhere
14:14:12 <chessguy> @type onlyCh ch (ch:chs) = Just (chs, ch); onlyCh ch _ = Nothing
14:14:14 <lambdabot> parse error on input `='
14:14:25 <chessguy> @let onlyCh ch (ch:chs) = Just (chs, ch); onlyCh ch _ = Nothing
14:14:26 <lambdabot> <local>:7:7:     Conflicting definitions for `ch'     In the definition of `o...
14:14:57 <chessguy> guess i can't do that
14:15:34 <chessguy> @let onlyCh ch (ch':chs) | ch == ch' = Just (chs, ch); onlyCh ch _ = Nothing
14:15:36 <lambdabot> Defined.
14:15:39 <chessguy> @type onlyCh
14:15:41 <lambdabot> Not in scope: `onlyCh'
14:15:47 <chessguy> @type L.onlyCh
14:15:49 <lambdabot> Couldn't find qualified module.
14:16:07 <chessguy> onlyCh 'a' "aaa"
14:16:12 <chessguy> > onlyCh 'a' "aaa"
14:16:13 <lambdabot>  Just ("aa",'a')
14:19:37 <oerjan> > onlyCh
14:19:40 <lambdabot>  <Integer -> [Integer] -> Maybe ([Integer],Integer)>
14:19:55 <oerjan> bah
14:20:09 <chessguy> wtf
14:20:13 <sjanssen> magical ghci-defaulting
14:20:13 <oerjan> probably Eq a => a replaces Integer
14:21:40 <opqdonut> :D
14:22:05 <EvilTerran> ?type onlyCh
14:22:07 <lambdabot> Not in scope: `onlyCh'
14:22:13 <EvilTerran> > typeOf onlyCh
14:22:15 <lambdabot>  Integer -> [Integer] -> Maybe ([Integer],Integer)
14:22:15 <newsham> onlyCh :: Parser Char
14:22:31 <newsham> integer?
14:22:36 <EvilTerran> oh, wait, Typeable doesn't do polymorphism
14:23:06 <EvilTerran> > onlyCh :: Eq a => a -> [a] -> Maybe ([a],a)
14:23:08 <lambdabot>  <Integer -> [Integer] -> Maybe ([Integer],Integer)>
14:23:29 <mdmkolbe> @hoogle Int -> Char
14:23:29 <lambdabot> Char.chr :: Int -> Char
14:23:30 <lambdabot> Char.intToDigit :: Int -> Char
14:23:30 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
14:24:39 * mdmkolbe just wrote gunzip in Haskell
14:25:10 <chessguy> mdmkolbe, what was it, about 8 lines of code? :)
14:26:50 <oerjan> @remember chessguy [mdmkolbe just wrote gunzip in Haskell] mdmkolbe, what was it, about 8 lines of code? :)
14:26:50 <lambdabot> Done.
14:27:00 <mdmkolbe> chessguy: That was the hope, but (1) gzip is very ad-hoc and (2) deflate uses both LZW and huffman tree's so each of those algorithms take 8 lines plus 20 more for the monad that I wrote for this
14:28:26 <sjanssen> mdmkolbe: 36 lines of code is nothing to be ashamed of ;)
14:28:33 <mdmkolbe> maybe once I get more experience with writting these types of parsers/programs I'll find a good compact set of abstractions
14:28:42 <ddarius> It sounds 34 lines too long to me...
14:29:08 <allbery_b> @quote realized
14:29:08 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
14:29:19 <mdmkolbe> wc reports 395 lines total (but I still ahve to clean things up and 206 of those lines are due to GZip's ad-hoc-ness)
14:29:22 <chessguy> mdmkolbe, it's certainly not anything to be ashamed of, i didn't mean to imply that
14:32:05 <ddarius> newsham: parseAB' looks a little scary because of the way you laid it out.
14:32:21 <newsham> chess: I addressed your comments, and put up diffs.
14:32:24 <newsham> http://www.thenewsh.com/%7Enewsham/formal/parse/
14:32:26 <lambdabot> Title: Directory /~newsham/formal/parse/
14:32:42 <newsham> ddarius: lemme fix
14:33:16 <hpaste>  newsham pasted "parseAB' layout" at http://hpaste.org/2650
14:33:21 <newsham> is that preferred?
14:33:46 <monochrom> I'm so behind Oleg.
14:33:47 <newsham> (possibly lining up andThen's)
14:34:47 <ddarius> newsham: I would drop the parens (like you do), and line up the parsers, the andThens and the \rs (the last should come automatically), but yes, like that.
14:35:08 <newsham> I wanted to show it both with and without parens
14:35:13 <ddarius> monochrom: Why do you say that now?
14:35:17 <ddarius> newsham: That's fine.
14:36:16 <hpaste>  chessguy pasted "newsham, onlyCh can still be improved" at http://hpaste.org/2651
14:36:34 <ddarius> It should make it even clearer that do notation corresponds to the original code.
14:36:54 <dons> http://programming.reddit.com/info/2nig9/details
14:36:55 <lambdabot> Title: Destructive Quicksort in Haskell (reddit.com)
14:37:08 <newsham> chessguy: thanks
14:37:11 <ddarius> (Of course, then people might wonder why one should bother as do-notation saves almost nothing...)
14:37:34 <monochrom> A few years ago I was contemplating "how to do incremental, undoable parsing in general, e.g. for code completion or hinting in an IDE". I never had time nor knowledge to deduce an answer. Just last night I realized delimited continuations can help (it's just like generic zipper). And surely, Oleg has done exactly that too.
14:38:06 <mrd> newsham: very cool tutorial
14:38:15 <chessguy> indeed.
14:38:19 <chessguy> newsham++
14:38:27 <monochrom> Fortunately it seems his incremental parsing is just written up July this year. I'm catching up now, just two months behind :)
14:38:57 <dons> hmm, `First get-together of the Portland Haskell Neophytes last night.'
14:39:07 <dons> glguy: any idea what that is? http://gorthx.livejournal.com/150030.html
14:39:08 <lambdabot> Title: gorthx: Don't Haskell my Hoff!
14:39:08 <newsham> next i'm hoping to make some proofs about the parser.  that should be challenging :\
14:39:13 <chessguy> dons, is that a reference to lennart's blog?
14:39:19 <ddarius> dons: This is similar to my semi-direct translation on the wiki http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
14:39:21 <lambdabot> Title: Introduction/Direct Translation - HaskellWiki, http://tinyurl.com/ytokyh
14:39:33 <monochrom> If I learned delimited continuations three years ago, the history of computing would be rewritten. :)
14:39:39 <dons> chessguy: yeah
14:39:46 <dons> ddarius: ah yes.
14:39:50 <dons> much as I'd do it too
14:39:51 <glguy> dons, apparently there is a Portland Haskell user group already?
14:39:54 <chessguy> i did think that was rather a strange little series...
14:40:03 <mdmkolbe> monochrom: how is that?
14:40:03 <dons> glguy: well, a newbie club?
14:40:27 <glguy> dons, apparently,  but I imagine that it is only a newbie club because they don't have any oldbies
14:40:28 <monochrom> I might be able to get ahead of Oleg for once :)
14:40:56 <dons> glguy: i think we should ponder a proper user group.
14:40:58 <dons> one with pizza
14:41:03 <newsham> mrd: thank you.  hope the people I wrote it for can grok it.
14:41:13 <wli> I'll show up once I find this earring.
14:41:14 <chessguy> i like dons' definition of a proper user group :)
14:41:20 <dons> :)
14:41:35 <glguy> I've never been to or part of a "user group"
14:41:41 <glguy> what might one do in one?
14:41:54 <chessguy> i went to one session of a user group once
14:42:01 <dons> hmm, i think talks, discussion, help, advice, beer, pizza, networking?
14:42:01 <monochrom> Now you'll also have simple user subgroup, normal user subgroup, solvable user subgroup, exact sequence of user subgroups, ...
14:42:19 <glguy> User semi-group, perhaps?
14:42:24 <dons> we can all attend the Church of the Higher Order Curry or something
14:42:26 <monochrom> user monoids!
14:42:35 <mdmkolbe> user rings? user fields?
14:42:47 <chessguy> everyone did some hacking (in perl, in this case) on a particular problem, and then compared notes. and then...it devolved into a rant by one member on all that's evil in international politics
14:42:50 <monochrom> instance Monoid (Portland_User_Group) where ...
14:42:55 <chessguy> which was a little odd.
14:42:56 <glguy> is a user semi-group a user group without a pizza operation?
14:43:01 <dons> oh, this might be another ref to the portland newbie group, http://www.chesnok.com/daily/2007/09/06/haskell/
14:43:04 <lambdabot> Title: tending the garden  haskell!
14:43:33 <glguy> dons, all of these postings are quite vague
14:43:43 <ddarius> The normal subgroup are those users that are annihilated when going from one group to another.
14:43:59 <dons> glguy: indeed.
14:44:14 <glguy> dons, someone is trying to lure you in?
14:44:21 <mdmkolbe> Save the users!  Stop the annihilation!
14:44:26 <ari> I could advertise a user magma as really hot
14:44:32 <chessguy> heh
14:44:32 <glguy> this is an  elaborate ruse?
14:44:33 <chessguy> http://www.meetup.com/search/?keywords=haskell&locationPickerRef=0&dbCo=us&dbOutsideUsLink=&country=us&zip=&go.x=0&go.y=0&go=GO
14:44:35 <lambdabot> Title: Search results - Meetup.com, http://tinyurl.com/2mcpd4
14:44:38 <dons> glguy: i got an email from theo asking to test the new wifi driver :)
14:44:44 <dons> open source roxors
14:45:05 <dons> i note the acpi doesn't work too well, though, as you suspected, glguy
14:45:06 <oerjan> ddarius: consequently, a simple group is one where all the users are annihilated if they try moving to a different group
14:45:13 <dons> speedstep does, but no suspend/resume, afaik
14:45:18 <dons> audio seems to be not working too
14:45:19 <glguy> dons, Did you enable the acpi device?
14:45:33 <glguy> dons, the wireless driver will not help much though since galois uses wpa
14:45:43 <dons> i was poking around in the bios, but couldn't see it on a quick glance last night
14:45:48 <chessguy> er...is this channel still about haskell?
14:45:51 <dons> i'll have another look for the acpi
14:46:02 <dons> the other thing is to get ghci working on amd64
14:46:07 <glguy> chessguy, Haskell and OpenBSD are long lost friends
14:46:15 <dons> purely functional and secure!
14:46:17 <glguy> dons, what do you mean?
14:46:21 <glguy> what doesn't work on amd64?
14:46:27 <dons> loadObj fails in Linker.c
14:46:35 <dons> so ghci won't load .o's
14:46:52 <glguy> didn't we fix something like this a while back?
14:46:53 <newsham> are haskell user groups closed under composition?
14:47:08 <dons> glguy: yeah, i think its just amd64 that's broken.
14:47:16 <dons> kill@ sent me a mail about it
14:47:19 <dons> kili
14:47:28 <glguy> newsham, they are closed under new users ;)
14:47:32 <newsham> glguy: why openbsd in specific and not *bsd?
14:47:36 <earnest> haskell is a town in new jersey
14:47:50 <ddarius> earnest: As well as Texas, as well as other states no doubt.
14:47:54 <dons> newsham: i guess openbsd's slogan, 'free, functional, secure' could also be haskell's :)
14:47:56 <monochrom> "The Haskell Haskell User Group" XD
14:48:05 <earnest> :)
14:48:10 <glguy> dons, I like it, let's fix the topic ;)
14:48:13 <earnest> cool name :)
14:48:33 <monochrom> free, functional, type-safe
14:48:55 --- mode: ChanServ set +o dons
14:48:59 --- topic: set to '["The Haskell programming language: free, functional, secure!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The language of ICFP winners 3 years running"]' by dons
14:49:33 <newsham> ironically openbsd is not functional, and sometimes not functional (the other kind :)
14:49:36 <dons> looks interesting, http://programming.reddit.com/info/2nik3/comments
14:49:37 <lambdabot> Title: Continuation-based stream processors via Arrows (reddit.com)
14:49:39 --- mode: ChanServ set -o dons
14:49:40 <newsham> but thats marketting for you  ;-)
14:50:21 <dons> oh, cool, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/funcmp-1.0
14:50:24 <lambdabot> http://tinyurl.com/2hnm68
14:50:31 <dons> `Functional MetaPost is a Haskell frontend to the MetaPost language'
14:50:54 <ddarius> Hasn't that been around for quite a while?
14:51:08 <dons> v1.0 just got uploaded to hackage?
14:51:35 <dons> the cryp.to site hosts a lot of haskell projects
14:51:39 <glguy> newsham, which *BSD were you hoping to see included?
14:51:56 <mdmkolbe> How do we claim that Haskell is secure?
14:52:10 <glguy> safe code has no buffer overflows
14:52:13 <newsham> i use freebsd myself.  but they're all so similar there's no reason why any effort to make openbsd work shouldnt be easily adjusted to include {net,free,dragonfly}bsd as well
14:52:14 <glguy> for 1
14:52:39 <dons> http://programming.reddit.com/info/2niku/comments :)
14:52:40 <lambdabot> Title: Functional MetaPost: write graphics programs in Haskell and compile them to Post ...
14:52:44 <newsham> mdmkolbe: transforms and optimizations are based on formal semantics and provable?
14:52:47 <dons> mdmkolbe: purity.
14:53:01 <dons> and the fact entire companies are based around the security properties of the language
14:53:13 <newsham> dons: how many companies? :)
14:53:14 <ddarius> dons: http://www.informatik.uni-bonn.de/~ralf/software.html
14:53:15 <lambdabot> Title: Ralf Hinze's software
14:53:19 <glguy> newsham, I always felt like OpenBSD had a simpler /etc
14:53:21 <dons> newsham: hmm, at least 2.
14:53:24 <glguy> but I haven't used FreeBSD in a while
14:53:34 <newsham> entire security companies are built around lots of things..  not to detract from haskell or anything...
14:53:36 <beelsebob> what do you guys use for laying out BNF in LaTeX?
14:53:40 <glguy> I wasn't saying earlier that ghci shouldn't be fixed on amd64 for freebsd
14:53:46 <newsham> dons: whats the other besides galois?
14:53:48 <glguy> I don't know if it even needed to be fixed
14:53:49 <dons> aetion
14:54:11 <newsham> glguy: yah, ghci doesnt work on freebsd/amd64
14:54:19 <newsham> dons: ahh, didnt know about that one.  danke.
14:54:22 <dons> newsham: do you konw why?
14:54:52 <newsham> why aetion?  why ghci/amd64?
14:55:25 <dons> btw, this is useful, http://www.cse.unsw.edu.au/~cs4181/ `Language-based Software Safety' (i.e. Haskell-based ...)
14:55:25 <lambdabot> Title: COMP4181/9181: Language-based Software Safety
14:56:20 <wincent> really dumb question: how would I write a function to convert a string like "bar" into "baarrr" (ie. first character appears once,second twice, third thrice etc)... i'm trying to work through the exercises in a text book and am totally stumped with my imperative thinking
14:56:22 <glguy> newsham, is Freesbie the only / recommended freebsd live cd? do you know?
14:56:43 <dons> wincent: nice little problem :) beautiful solution available
14:56:52 <newsham> glguy: dont know.  havent used any live cds.  does the installer not do live cd?
14:56:56 <sjanssen> wincent: concat . zipWith replicate [1..]
14:57:14 <sjanssen> > concat . zipWith replicate [1..] $ "bar"
14:57:16 <lambdabot>  "baarrr"
14:57:22 <dons> that's the one.
14:57:25 <dons> zipWith++
14:57:45 <wincent> dons: ah, my previous search revealed only this: http://paste.lisp.org/display/33775 -- which just seemed wrong
14:58:16 <dons> do you understand sjanssen's zipWith solution?
14:58:33 <wincent> trouble is, this is chapter 1 of the textbook, and concat, zipWith and replicate haven't even been introduced yet... i'm having trouble understanding why they introduced the problem at such an early stage
14:58:36 <dons> zipwith is a very useful tool to have handy
14:58:43 <wincent> dons: vaguely
14:58:46 <dons> oh, you could just write a loop, of course
14:58:50 <newsham> > take 5 $ zip [1..] "bar"
14:58:52 <lambdabot>  [(1,'b'),(2,'a'),(3,'r')]
14:59:01 <newsham> > replicate 2 'a'
14:59:01 <dons> > zip "haskell" [1..]
14:59:02 <lambdabot>  "aa"
14:59:03 <lambdabot>  [('h',1),('a',2),('s',3),('k',4),('e',5),('l',6),('l',7)]
14:59:14 <wincent> dons: yes, but writing a loop doesn't seem like what they're asking for
14:59:17 <dons> so then map over that list, duplicating the char by its occurence
15:00:19 <therp> wincent: try to use a recursion, a counter starting with 0, ++ and replicate.
15:00:23 <newsham> > [replicate 1 'b', replicate 2 'a', replicate 3 'r']
15:00:25 <lambdabot>  ["b","aa","rrr"]
15:00:28 <newsham> > concat [replicate 1 'b', replicate 2 'a', replicate 3 'r']
15:00:30 <lambdabot>  "baarrr"
15:01:17 <newsham> dons: that 4181 course looks interesting.  too bad they dont do videos of their lectures :(
15:01:32 <dons> ?go 78 degrees in celcius
15:01:36 <lambdabot> http://www.texloc.com/closet/cl_cel_fah_chart.html
15:01:37 <lambdabot> Title: Celsius To Fahrenheit Chart
15:01:47 <ddarius> dons: Don't know how hot it is here?
15:01:48 <dons> ?go 78 degrees Fahrenheit in celsius
15:01:50 <lambdabot> 78 degrees Fahrenheit = 25.5555556 degrees Celsius
15:01:58 <dons> ddarius: still trying to work out what's what.
15:02:02 <dons> ?go 90 degrees Fahrenheit in celsius
15:02:02 <lambdabot> 90 degrees Fahrenheit = 32.2222222 degrees Celsius
15:02:15 <newsham> > (\f -> 100 * (f - 32) / 180) 78
15:02:16 <lambdabot>  25.555555555555557
15:02:37 <ddarius> dons: Yeah I just remember, freezing point, boiling point, "comfortable" 72-21, and body temperature 98.6-37
15:02:58 <ddarius> With those I can usually have an idea what a temperature in Celsius means.
15:02:59 <newsham> (32, 0), (32+180, 100)
15:03:05 <beelsebob> no recommendations for laying out grammars with LaTeX?
15:03:34 <oerjan> > map (\c -> 32+c*9/5) [-40,-30..30]
15:03:36 <lambdabot>  [-40.0,-22.0,-4.0,14.0,32.0,50.0,68.0,86.0]
15:03:54 <LoganCapaldo> > [-40,-30..30,1,2]
15:03:55 <lambdabot>  Parse error
15:04:00 <LoganCapaldo> ah
15:04:07 <LoganCapaldo> I got excited for a second there
15:04:24 <newsham> > [-40,-30..30]++[1,2]
15:04:26 <lambdabot>  [-40,-30,-20,-10,0,10,20,30,1,2]
15:05:27 <dons> ?go 72 degrees Fahrenheit in celsius
15:05:28 <lambdabot> 72 degrees Fahrenheit = 22.2222222 degrees Celsius
15:05:30 <dons> ah
15:05:37 <dons> that's useful to remember
15:06:40 <idnar> heh
15:06:52 <beelsebob> dons: all of a sudden, I want to ressurect my "super converter" project
15:07:40 <oerjan> ?go 1 lightyear in furlongs
15:07:41 <lambdabot> 1 lightyear = 4.70279985 x 10^13 furlongs
15:07:44 <beelsebob> you could feed it a set of information, and ask for something completely different out... like you could say force applied: 10N, acceleration: 3 ms/s/s, gravity: 5 N/Kg, to weight in lb
15:07:50 <beelsebob> and it would figure out a way to get there
15:07:50 <ddarius> string = mapM char
15:08:26 <Olathe> ?go 1 lightyear in dog steps
15:08:29 <lambdabot> http://www.skepticaldog.com/wp/2007/07/02/diluting-homeopathy
15:08:29 <lambdabot> Title: Skeptical Dog  Blog Archive  Diluting Homeopathy
15:08:46 <beelsebob> haha
15:08:49 <beelsebob> it just uses google
15:08:51 <beelsebob> that's cheating
15:09:14 <ddarius> beelsebob: @go is just short for @google
15:09:17 <mrd> @go 1 cubic lightyear in wales
15:09:19 <lambdabot> http://www.physicsforums.com/showthread.php?t=175326
15:09:20 <beelsebob> ah, okay
15:10:01 <ddarius> It is one of the emergent features of lambdabot.
15:10:34 <oerjan> what are the others?
15:10:47 <wincent> ok, this works, but i'm not entirely happy with it -- http://pastie.caboo.se/95583 -- for one thing I've had to make a helper function, and for another I'm using functions which haven't been introduced in the text yet (concat and replicate)
15:10:49 <lambdabot> Title: #95583 - Pastie
15:11:12 <ddarius> Getting the source of a function by combining djinn and type there are others.
15:12:06 <oerjan> wincent: you don't need concat, just ++
15:12:20 <wincent> oerjan: true
15:12:32 <glguy> you don't even need ++
15:13:14 <wincent> slightly better: http://pastie.caboo.se/95584
15:13:15 <lambdabot> Title: #95584 - Pastie
15:14:04 <wincent> glguy: how do you avoid that?
15:14:34 <hpaste>  glguy pasted "for wincent" at http://hpaste.org/2652
15:15:06 <EvilTerran> @check \x y -> foldr (:) y x == x ++ (y :: String)
15:15:17 <lambdabot>  OK, passed 500 tests.
15:15:28 <wincent> glguy: hehe, probably a bit beyond chapter 1 of the textbook (where I am now)
15:15:46 <glguy> wincent, doubtful... it uses no library functions :)
15:16:04 <glguy> well, ... + is from the "library" I suppose
15:16:10 <beelsebob> @src (++)
15:16:11 <lambdabot> (++) []     ys = ys
15:16:11 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
15:16:15 <beelsebob> oh okay
15:16:20 <beelsebob> not define in terms of foldr
15:16:23 <wincent> glguy: which is nice, but still hard for my imperative brain to grok
15:16:23 <beelsebob> surprised
15:16:42 <hpaste>  LoganCapaldo pasted "wincent don't look, I'm a horrible person" at http://hpaste.org/2653
15:17:15 <oerjan> LoganCapaldo: that's already been mentioned
15:17:18 <wincent> LoganCapaldo: yes, that's the nicest looking solution
15:17:25 <LoganCapaldo> oh good
15:17:36 <LoganCapaldo> I'm less horrible than the person who did it first
15:17:50 <oerjan> except, it's not pointfree
15:18:41 <LoganCapaldo> :t concat . zipWith replicate [1..]
15:18:43 <lambdabot> forall a. [a] -> [a]
15:18:51 <wincent> @src (replicate)
15:18:51 <lambdabot> Source not found. You type like i drive.
15:18:57 <wincent> doh
15:18:59 <LoganCapaldo> @src replicate
15:18:59 <lambdabot> replicate n x = take n (repeat x)
15:19:07 <Japsu> @pl \xs -> concat $ zipWith replicate [1..] xs
15:19:07 <lambdabot> join . zipWith replicate [1..]
15:19:08 <ddarius> (++) = flip (foldr (:))
15:19:50 <wincent> nice, dig the lazy evaluation on replicate
15:20:08 <LoganCapaldo> @src (+) -- only need () for operators
15:20:08 <lambdabot> Source not found. You type like i drive.
15:20:18 <LoganCapaldo> that was a poor choice of operator
15:20:22 <wincent> LoganCapald: yep, figured that
15:21:06 <oerjan> @src Ratio (+)
15:21:07 <lambdabot> Source not found. Are you on drugs?
15:21:12 <oerjan> @src Ratio +
15:21:12 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:21:22 <LoganCapaldo> @src [] (>>=)
15:21:22 <lambdabot> m >>= k     = foldr ((++) . k) [] m
15:21:56 <ddarius> @pl \m k -> foldr ((++) . k) [] m
15:21:57 <lambdabot> flip (flip foldr [] . ((++) .))
15:23:28 <wincent> thanks for the help guys, will be back later!
15:23:35 <beelsebob> o.O 70 pages and counting
15:32:10 <hpaste>  LoganCapaldo pasted "I'm an imperative programmer!!!" at http://hpaste.org/2654
15:33:03 <beelsebob> LoganCapaldo: you're a sick sick man
15:36:31 <LoganCapaldo> Why thank you :)
15:37:04 <glguy> to being called a man?
15:37:07 <hpaste>  EvilTerran annotated "I'm an imperative programmer!!!" with "no, *I*'m an imperative programmer!!!" at http://hpaste.org/2654#a1
15:37:19 <EvilTerran> look, ma, no recursion"
15:37:20 <EvilTerran> !
15:37:43 <EvilTerran> (ignore the superfluous "do", there)
15:37:53 <glguy> EvilTerran, you should have used mapM so you wouldn't need to have those "xs" laying around
15:37:56 <glguy> making your code more pointful
15:38:18 <EvilTerran> meh. i was trying to make it look like an imperative language as far as possible.
15:38:20 <LoganCapaldo> EvilTerran, you are the winner
15:38:30 <LoganCapaldo> at first I reached for mapM
15:38:38 <LoganCapaldo> but I got confused quickly
15:38:48 <EvilTerran> :D
15:38:50 <LoganCapaldo> I really wanted to do ListT State or something
15:40:14 <hpaste>  sjanssen annotated "I'm an imperative programmer!!!" with "more imperative than thou" at http://hpaste.org/2654#a2
15:43:20 <LoganCapaldo> sjanssen, yet another idea I had but failed to execute :)
15:44:09 <LoganCapaldo> Can anyone beat sjanssen?
15:46:04 <EvilTerran> could do it in IORefs
15:46:38 <LoganCapaldo> EvilTerran, that almost stops being funny and starts being accurate :(
15:46:52 <elliottt> who should i talk to about a hackagedb user account?
15:46:57 <sioraiocht> @src iterate
15:46:57 <lambdabot> iterate f x =  x : iterate f (f x)
15:47:52 <elliottt> ah, nevermind ;)
15:49:16 <hpaste>  sjanssen annotated "I'm an imperative programmer!!!" with "madness" at http://hpaste.org/2654#a3
15:50:11 <LoganCapaldo> madness? This is #haskell!
15:50:24 <sjanssen> hahaha
15:50:28 <sjanssen> LoganCapaldo++
15:50:39 <sioraiocht> WTF are you guys doing?!
15:50:48 <sjanssen> @remember LoganCapaldo madness? This is #haskell!
15:50:48 <lambdabot> Done.
15:51:00 <ddarius> sjanssen: I'm surprised you didn't pull out the Foreign routines and it's not quite quintessential imperative code without an unchecked cast somewhere.
15:52:03 <sioraiocht> Okay.  I know that even freaks have freaks, and you guys are the freaks of #haskell.
15:52:54 <mudge> hello
15:53:01 <sioraiocht> hey mudge
15:53:11 <mudge> hi sioraiocht
15:53:26 <mudge> has anyone here done the exercises in the book Programming Haskell?
15:54:22 <sioraiocht> who is that book by?
15:54:33 <oerjan> > let blowup xs = [last x | x <- inits xs, _ <- x] in blowup "bar"
15:54:35 <lambdabot>  "baarrr"
15:54:46 <hpaste>  twanvl annotated "I'm an imperative programmer!!!" with "using replicate is cheating" at http://hpaste.org/2654#a4
15:55:30 <sjanssen> nice
15:56:18 <olliej> sjanssen: twanvl: you're both *really* scary
15:56:21 <sioraiocht> mudge: I guess not, do you have some question about an exercise in there?
15:57:01 <Tac-Tics> @src forM
15:57:01 <lambdabot> forM = flip mapM
15:57:03 <hpaste>  EvilTerran annotated "I'm an imperative programmer!!!" with "mmm, sugary." at http://hpaste.org/2654#a5
15:57:30 <dons> you're all imperative programmers :)
15:57:55 <EvilTerran> it is imperative that we program!
15:58:01 <allbery_b> only in #haskell can we have an imperative programming dsw :)
15:58:19 <EvilTerran> dsw?
15:58:35 <Olathe> What does this mean ? test.o(.text+0x56):fake: undefined reference to `mtlzm1zi0zi1_ControlziMonadziStateziLazzy_zdf12_closure'
15:58:48 <EvilTerran> ah, i think i see it on urbandictionary. never mind.
15:58:51 * wli points to his Linux kernel contributions.
15:58:57 <hpaste>  Tac-Tics annotated "I'm an imperative programmer!!!" with "(no title)" at http://hpaste.org/2654#a6
15:59:34 * wli expects that will quash the imperative programming DSW.
15:59:36 <LoganCapaldo> I should've know that was a mistake
15:59:39 <LoganCapaldo> sorry
15:59:56 <sjanssen> olliej: it's an important exercise in functional style -- the programmer with the most knowledge of FP will produce the best caricature of imperative style
15:59:57 <mudge> sioraiocht: the book is by graham huttton
16:00:19 <mudge> I'm looking for someone else who had done the exercises in the book to compare answers
16:00:20 * EvilTerran quite likes his (out?) syntax
16:00:38 <mudge> or who'd want to do some of the exercise and compare answers
16:01:57 <sioraiocht> mudge: I'll have a go
16:02:12 <sioraiocht> as long as they aren't for school :)
16:02:27 <wli> I've got real-life problems to deal with, like finding this earring before 10PM.
16:02:27 <mudge> sioraiocht: it's not,  I've been doing it on my own self study
16:02:48 <mudge> sioraiocht:  do you know about Graham Hutton's book Programming in Haskell?
16:02:57 <sioraiocht> mudge: I'm afraid not
16:03:15 <olliej> sjanssen: uh huh
16:03:29 <mudge> sioraiocht: check it out: http://www.cs.nott.ac.uk/~gmh/book.html
16:03:31 <lambdabot> Title: Programming in Haskell
16:03:34 <mudge> it is a good book on haskell
16:04:29 <mudge> wow, I guess it costs $40:  http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695/ref=pd_bbs_sr_1/105-7372205-6120462?ie=UTF8&s=books&qid=1189378997&sr=8-1
16:04:31 <oerjan> > concat . reverse . transpose . inits . reverse $ "bar"
16:04:33 <lambdabot> http://tinyurl.com/22py79
16:04:41 <SamB_XP_> audreyt: why the heck did I just see a customer image uploaded by you on Amazon.com ... as an example?
16:04:42 <lambdabot>  "baarrr"
16:04:55 <mudge> it's only about 150 pages long though
16:04:59 <allbery_b> sorry, it being around 7pm here my dsl went out.  (no, I have no idea, except I know site wiring is bad)
16:05:07 <allbery_b> anyway, size war.  you can imagine the rest :)
16:09:37 <mudge> \me hi
16:09:40 * mudge ih
16:09:53 * mudge no I'm an imperative programmer
16:17:37 <wli> People didn't seem to like my idea last night for alternatives to tic tac toe games.
16:19:11 <LoganCapaldo> there is an alternative to tic tac toe games?
16:19:40 <oerjan> tactical toe games
16:20:33 <mudge> ooh teactical toe games sound like fun
16:20:41 <mudge> i mean tactical
16:20:59 <LoganCapaldo> how do those work?
16:21:18 <mudge> definitely more foot work
16:21:56 <oerjan> they're often used as a shoe-in
16:23:23 <mudge> have any of you guys done any of the exercises in Graham Hutton's Programming in Haskell book?   I'm looking for someone to compare answers with
16:31:55 <Cale> mudge: I don't have it, but I'd be willing to try problems.
16:32:25 <LoganCapaldo> heh
16:32:33 <LoganCapaldo> Yes, compare answers with Cale
16:33:02 <LoganCapaldo> You'll either learn more than you ever wanted to know about haskell, or go insane with feelings of inadequacy :)
16:33:14 <mudge> Cale: that would be really cool,    the exercises require the book
16:33:36 <sioraiocht> lol
16:33:51 <chessguy> LoganCapaldo, i thought those were pretty much equivalent
16:34:05 <LoganCapaldo> chessguy, I didn't say xor :)
16:34:07 <sioraiocht> chessguy: brings up an EXCELLENT point
16:34:53 <sioraiocht> So shouldn't it be: You'll learn more than you ever wanted to know about haskell iff you go insane with feelings of inadequacy?
16:36:43 <ricky_clarkson> mudge: Get the author to send Cale a copy for review.
16:36:59 <ricky_clarkson> If it's a positive review, there'll likely be sales.
16:37:14 <sioraiocht> I didn't realise Cale was so popular
16:37:18 <sioraiocht> who is this man behind the nick?
16:37:45 <Cale> sioraiocht: hm?
16:38:01 <Cale> I'm just popular around here :)
16:38:05 <sioraiocht> lol
16:38:21 <oerjan> @karma cale
16:38:22 <lambdabot> cale has a karma of 42
16:38:27 <ricky_clarkson> @karma police
16:38:27 <lambdabot> police has a karma of 0
16:38:28 <jbalint> haha, is that real?
16:38:35 <ddarius> @karma
16:38:35 <lambdabot> You have a karma of 4
16:38:38 <Cale> @karma Cale
16:38:38 <lambdabot> You have a karma of 42
16:38:40 <LoganCapaldo> @karma audreyt
16:38:41 <lambdabot> audreyt has a karma of 111
16:38:41 <nominolo> @karma java
16:38:41 <lambdabot> java has a karma of -18
16:38:42 <jbalint> 42 is quite coincedence
16:38:49 * ddarius loses his karma everytime he gets some.
16:38:50 <LoganCapaldo> @karma dons
16:38:50 <lambdabot> dons has a karma of 125
16:38:51 <sioraiocht> @karma
16:38:51 <lambdabot> You have a karma of 0
16:38:54 <Cale> Oh, cool, possibly they fixed it
16:38:57 <nominolo> @karma
16:38:58 <lambdabot> You have a karma of 0
16:39:05 <nominolo> i used to have more
16:39:09 <LoganCapaldo> @karma
16:39:09 <lambdabot> You have a karma of 2
16:39:26 <mdmkolbe> @karma ddarius
16:39:26 <lambdabot> ddarius has a karma of 4
16:39:34 <sioraiocht> that surprises me ddarius
16:39:38 <sioraiocht> do you get a lot of negative karma? =p
16:39:42 <sioraiocht> @karma sorear
16:39:43 <lambdabot> sorear has a karma of 23
16:39:45 <LoganCapaldo> ddarius++
16:40:18 <ddarius> sioraiocht: Occasionally.  More often it gets lost by the bot.  That said, I only have like 10 or so at most.
16:40:21 <mudge> @karma +
16:40:21 <lambdabot> + has a karma of 8
16:40:27 <ddarius> Go +!
16:40:34 <ddarius> +++
16:40:37 <ddarius> @karma +
16:40:38 <lambdabot> + has a karma of 9
16:40:42 <mudge> @karma+ mudge
16:40:42 <lambdabot> You can't change your own karma, silly.
16:40:44 <ddarius> :t (+++)
16:40:45 <mudge> dang
16:40:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
16:40:46 <ricky_clarkson> > let (*)=const (const 42) in 6*9
16:40:48 <lambdabot>  42
16:40:50 <ddarius> @karma +++
16:40:50 <lambdabot> +++ has a karma of 0
16:40:52 <ddarius> @karma +
16:40:52 <lambdabot> + has a karma of 9
16:40:56 <ari> ---
16:40:59 <ari> negate++
16:41:01 <ari> subtract++
16:41:09 <mdmkolbe> i++
16:41:14 <idnar> ++i
16:41:15 <nominolo> java++
16:41:16 <ddarius> @karma j
16:41:16 <lambdabot> j has a karma of 1
16:41:20 <mudge> can there be more than one bot in here?
16:41:21 <mdmkolbe> java--
16:41:29 <nominolo> @karma
16:41:29 <lambdabot> You have a karma of -1
16:41:34 <ddarius> mudge: Why not?  There are actually several bots in here.
16:41:41 <mudge> ok
16:41:46 <nominolo> do you gain karma if you java-- ?
16:41:52 <LoganCapaldo> Doesn't raising java's karma actualy not raise it and lower yours?
16:41:53 <nominolo> @karma
16:41:53 <lambdabot> You have a karma of -1
16:42:02 <nominolo> LoganCapaldo, it does
16:42:09 <ricky_clarkson> I don't think -- and ++ have much to do with lambdabot's karma.
16:42:09 <LoganCapaldo> nominolo, that would be a terrible exploit
16:42:09 <ddarius> You probably don't want to have a lambdabot sitting around though if it's going to respond to the same requests lambdabot does.
16:42:12 <nominolo> that's why i'm negative ;)
16:42:17 <Pseudonym> What does lowering Java's karma do, then?
16:42:26 <ddarius> @karma ricky_clarkson
16:42:26 <lambdabot> ricky_clarkson has a karma of 0
16:42:28 <idnar> @jarma java
16:42:28 <lambdabot> java has a karma of -20
16:42:30 <nominolo> Pseudonym, it lowers java's karma
16:42:30 * LoganCapaldo doesn't have enough karma
16:42:30 <ddarius> ricky_clarkson--
16:42:35 <ddarius> @karma ricky_clarkson
16:42:35 <LoganCapaldo> java--
16:42:35 <lambdabot> ricky_clarkson has a karma of -1
16:42:35 <idnar> er. what's jarma?
16:42:36 <Pseudonym> nominolo: Right.
16:42:41 <LoganCapaldo> java-
16:42:47 <Pseudonym> That offends my theorist eye.
16:42:49 <LoganCapaldo> look at me raising my own karma
16:43:08 <Pseudonym> The operations are not symmetric.
16:43:09 <sioraiocht> so much karma hate
16:43:14 <LoganCapaldo> exactly
16:43:27 <LoganCapaldo> @karma+ chameleon
16:43:28 <lambdabot> chameleon's karma raised to 2.
16:43:29 <nominolo> let's hope it doesn't get reborn
16:43:36 <LoganCapaldo> @karma chameleon
16:43:36 <lambdabot> chameleon has a karma of 2
16:43:41 <ddarius> @karma+ ricky_clarkson
16:43:41 <lambdabot> ricky_clarkson's karma raised to 0.
16:43:48 <nominolo> it's gonna be the coffe bean from hell
16:43:55 <Pseudonym> ?karma chameleon -- should trigger a humorous response
16:43:55 <lambdabot> chameleon has a karma of 2
16:44:05 <sioraiocht> lol
16:44:07 <LoganCapaldo> Pseudonym, I agree
16:44:12 <sioraiocht> Pseudonym: I started singing...
16:44:19 <Pseudonym> Me too, sigh.
16:44:28 <Pseudonym> Yes, I _really_ want to hurt you.
16:44:38 <LoganCapaldo> I started singing _before_ I typed it :)
16:44:40 * ddarius started singing... Hanging By A Moment.
16:44:56 <ricky_clarkson> @karma c++
16:44:57 <lambdabot> c++ has a karma of -6
16:45:02 <ricky_clarkson> c++--
16:45:04 <ricky_clarkson> @karma c++
16:45:04 <lambdabot> c++ has a karma of -7
16:45:12 <Pseudonym> c--++
16:45:17 <sioraiocht> c++--
16:45:17 <Pseudonym> ?karma c--
16:45:17 <lambdabot> c-- has a karma of 3
16:45:27 <LoganCapaldo> ddarius, must be desperate for changing
16:45:30 <ddarius> c++++
16:45:38 <ricky_clarkson> Pseudonym: Evidence of prior art.
16:45:44 <ari> @karma+ @karma
16:45:44 <lambdabot>  @karma's karma raised to 2.
16:45:55 <Pseudonym> Recursive fun.
16:46:01 <balodja>  <> (mPtr->*(mPtr->fLst)[i])();
16:46:07 <balodja> c++--
16:46:10 <Pseudonym> @karma+ @karma karma @karma karma chameleon
16:46:10 <lambdabot>  @karma's karma raised to 3.
16:46:53 <nominolo> you come and go ...
16:48:12 <LoganCapaldo> @karma+ dibblego
16:48:12 <lambdabot> dibblego's karma raised to 3.
16:48:20 <dibblego> hello
16:48:21 <Pseudonym> ?let me love and steal, I have danced inside your eyes
16:48:21 <lambdabot>  Parse error
16:48:35 <LoganCapaldo> @karma+ Pseudonym
16:48:35 <lambdabot> Pseudonym's karma raised to 10.
16:48:58 <LoganCapaldo> @karma+ samreid
16:48:58 <lambdabot> samreid's karma raised to 2.
16:49:00 * Pseudonym is curious why he deserved a karma raise just for being old
16:49:14 <LoganCapaldo> because ?let is funny
16:49:29 <LoganCapaldo> dibblego, got karma for coming and samreid got karma for going
16:49:34 <ddarius> Pseudonym: Not everyone becomes old.
16:50:05 <wli> Some die first.
16:50:10 <ddarius> wli: Exactly.
16:50:55 <KatieHuber> I hate to interrupt when everyone's having so much fun, but I have a real question ;)
16:51:08 <ddarius> Oh no! Hide!
16:51:08 <sorear> !msg lambdabot @karma+ sorear
16:51:17 <Cale> go for it :)
16:51:21 <LoganCapaldo> Get in the bunkers
16:51:27 <LoganCapaldo> @karma+ bunkers
16:51:28 <lambdabot> bunkers's karma raised to 1.
16:51:48 <KatieHuber> I'm learning haskell, and one thing I keep coming up against is having some fairly complex data structure, and wanting to create a number of new versions of the structure
16:51:56 <KatieHuber> where each version has some minor edit, but the rest of the structure is the same
16:52:11 <KatieHuber> (for example, all the legal successor positions in a game of chess, maybe)
16:52:21 <sorear> ...okay...
16:52:30 <Pseudonym> KatieHuber: You mean the _type_ needs slight differences?
16:52:42 <KatieHuber> no, I mean the data itself is slightly different
16:52:55 <ddarius> Sorry Pseudonym, not that interesting.
16:53:07 <SamB_XP_> and?
16:53:08 <allbery_b> use a record
16:53:20 <SamB_XP_> allbery_b: for chess positions?
16:53:36 <sorear> allbery_b: ack! not the h98 record system!
16:53:43 <allbery_b> well, maybe not for that
16:54:03 <KatieHuber> like for solving a sudoku puzzle, I want to take a given configuration of numbers, then generate a bunch more configurations with exactly one number added
16:54:04 <Pseudonym> KatieHuber: Is the problem that you're worried about memory usage, or that it's just hard to write?
16:54:11 <KatieHuber> I'm just finding it hard to write
16:54:14 <Pseudonym> Because it is, I agree.
16:54:18 <Pseudonym> Right.
16:54:21 <LoganCapaldo> I demand more zippers
16:54:23 <KatieHuber> not worried about memory or performance or anything (at the moment)
16:54:24 <SamB_XP_> I'm not sure what format I'd use, but it would definately involve arrays somehow...
16:54:26 <Pseudonym> H98 records aren't too bad.
16:54:27 * sorear smells a zipper
16:54:33 <Pseudonym> And nor are arrays.
16:54:41 <ddarius> They could just be better.
16:54:51 <allbery_b> h98 records are far from perfect, but also far from unuseable
16:54:52 <Pseudonym> sorear: The problem is that this data structure isn't really a recursive type.
16:54:55 <Pseudonym> Right.
16:54:57 <KatieHuber> I was just wondering whether there was some pattern to doing this that made all the pain go away
16:55:08 <LoganCapaldo> code generator :)
16:55:12 <SamB_XP_> KatieHuber: no! that's the feeling of thought
16:55:21 <SamB_XP_> you'll grow used to it ;-)
16:55:32 <Pseudonym> KatieHuber: In the case of things with regular structure, like a chess board or a Sudoku board, it's not a dumb idea to use an array or a Data.Map.
16:55:45 <KatieHuber> well, in an imperative language, you could make something to copy the entire data structure, then something to make a couple of tiny edits to the copy
16:56:00 <Pseudonym> Records are more useful when you've got something that's logically a structure, rather than logically an indexed dictionary.
16:56:05 <KatieHuber> but in haskell you seem to be expected to somehow keep track of what you're editing as you go, to construct the new structure all at once
16:56:15 <Pseudonym> That's right, but you can hide it well.
16:56:22 <SamB_XP_> what was that array update operator?
16:56:24 <SamB_XP_> \\ or //?
16:56:30 <sorear>  //
16:56:35 <LoganCapaldo> @type (//)
16:56:36 <Pseudonym> SamB: \\ is list difference.
16:56:37 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
16:56:44 <KatieHuber> for sudoku I used arrays, and it was ugly, but worked
16:56:49 <Pseudonym> Yeah.
16:57:01 <SamB_XP_> Pseudonym: I suppose I should have realized that \\ would be the one that would be list difference ;-)
16:57:05 <Cale> It shouldn't be *so* ugly...
16:57:07 <Pseudonym> I think the trick is to build an abstract interface on top of it.
16:57:15 <LoganCapaldo> word
16:57:29 <Philippa> a good rule of thumb when you're learning haskell is to forget arrays exist until you're otherwise happy you're pretty good with it
16:57:33 <LoganCapaldo> littleedit :: param -> Thingy -> Thingy
16:57:43 <Pseudonym> Seriously, though, an association list isn't so dumb either.
16:57:47 <SamB_XP_> okay, lists of lists would work fine too
16:57:52 <Pseudonym> Yeah.
16:58:06 <Pseudonym> But what I'd suggest is to build a module which encapsulates the representation.
16:58:09 <SamB_XP_> but that's basically the same thing as arrays...
16:58:19 <Pseudonym> One thing that Haskell does well is abstraction at the micro-scale.
16:58:25 <Pseudonym> It's really quite cheap.
16:58:38 <Cale> Actually, I think Haskell's arrays are quite a bit nicer than in most other languages -- you can index them using lots of types.
16:58:46 <Philippa> yeah, when you can beta-reduce freely inlining is your bestest friend
16:58:56 <Pseudonym> Hide the ugliness, and provide a nice interface so that when you need to change it, you can, and nothing breaks.
16:59:08 <SamB_XP_> yes, I couldn't decide whether I'd want to index by piece or by square ;-)
16:59:14 <|Jedai|> Yes, I feel that one of the strangth of Haskell is that it actually rewards even your smallest abstraction
16:59:19 <Pseudonym> Yeah.
16:59:34 <SamB_XP_> |Jedai|: you can overdo it, but it's harder than you'd think ;-)
16:59:51 <Philippa> yeah, usually you're cursing from syntactic weight first
16:59:54 <ddarius> @google Evolution of a Haskell Programmer
16:59:55 <jedai> SamB_XP_: Way harder than in any other language I tried
16:59:57 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:59:57 <lambdabot> Title: The Evolution of a Haskell Programmer
16:59:59 <Pseudonym> So KatieHuber, back to your problem.
17:00:11 <Pseudonym> Pick the simplest.  List, or list of lists, is fine to start wtih.
17:00:18 <Pseudonym> Make a nice interface for it.
17:00:27 <Pseudonym> Put it in its own module.
17:00:40 <KatieHuber> OK, I'll go concrete... I'm making a thing for playing patience
17:00:40 <Pseudonym> Be careful what you export.
17:00:40 <jedai> ddarius: I wouldn't qualify that as a "small" abstraction
17:00:41 <Pseudonym> Oh, cool!
17:00:44 <KatieHuber> so I have a [[Card]] for foundation piles
17:00:44 <Pseudonym> Nice project.
17:00:48 <jedai> ddarius: ;-)
17:00:49 <KatieHuber> and [[Card]] for tableau piles
17:00:58 <Pseudonym> Yeah.
17:01:02 <KatieHuber> wrapped up in a nice data -- data Patience = [[Card]] [[Card]]
17:01:09 <KatieHuber> so now I want to generate all the legal moves
17:01:09 * Pseudonym nods
17:01:30 * Philippa suggests type Pile = [Card]
17:01:32 <KatieHuber> which means I have to iterate all the pairs of piles, generating possibly multiple moves for each pair of piles
17:01:35 <KatieHuber> yeah, I have that ;)
17:01:46 <Nucleo_> @src succ
17:01:47 <lambdabot> Source not found. I feel much better now.
17:01:47 <Pseudonym> The stock pile is not part of your state?
17:01:48 <SamB_XP_> ddarius: the type-level implementations don't implement the same interface as others... (or aren't there any on that page?)
17:01:52 <KatieHuber> and I have to treat tableau piles as distinct from foundation files
17:01:55 <Pseudonym> Or the discard pile?
17:02:04 * danderson has just finished watching oscon's "A Taste of Haskell", and is now all of excited, scared, awed and confused by Haskell
17:02:07 <SamB_XP_> nor does the [()] one or the church-encoded one...
17:02:08 <KatieHuber> this particular patience doesn't have a stock or discard, but yeah, they would be if it were klondike ;)
17:02:19 <KatieHuber> I don't think the particular rules are massively important for the discussion
17:02:22 <Pseudonym> danderson: Meditate some more, and you'll achieve enlightenment soon.
17:02:25 * Pseudonym nods
17:02:26 <Pseudonym> I agree.
17:02:44 <Pseudonym> PL.
17:02:45 <Pseudonym> OK
17:02:47 <SamB_XP_> dancor: what confuses you?
17:02:48 <Pseudonym> SO here's a suggestion.
17:02:51 <SamB_XP_> er.
17:02:54 <KatieHuber> so I have made a bunch of functions which find the legal moves
17:02:56 <SamB_XP_> danderson:
17:02:56 <Pseudonym> Rather than: type Pile = [Card]
17:02:59 <Pseudonym> Do this:
17:03:02 <KatieHuber> and I am outputting *which* card can move
17:03:04 <Pseudonym> newtype Pile = Pile [Card]
17:03:08 <Pseudonym> Or something.
17:03:09 <SamB_XP_> three letters just don't cut it no more :-(
17:03:12 <KatieHuber> do gen <- newStdGen; print (allLegalMoves (deal gen))
17:03:12 <KatieHuber> [3 of Hearts,3 of Hearts,6 of Clubs,4 of Diamonds,5 of Hearts,4 of Clubs]
17:03:13 <Pseudonym> Oh, hang on.
17:03:18 <Pseudonym> No, that's tnot the problem.
17:03:21 <Pseudonym> Yeah.
17:03:29 <chessguy> KatieHuber, are you writing spider solitaire?
17:03:33 <KatieHuber> my problem is, in order for that to be useful, I need to record which pile the card comes from, and which it goes to
17:03:39 <KatieHuber> it's beleaguered castle for now
17:03:39 <jedai> danderson: Give it a try, but I warn you : it can be addictive !! ^^
17:03:45 <Philippa> ah! So you need to reintroduce identity
17:03:47 <Pseudonym> KatieHuber: Why not wrap it?
17:03:54 <danderson> SamB_XP_: Nothing terrible. Just the ordinary feeling of having been walked through several programs in an unknown language, getting them, and being confused as to how to apply that to other programs.
17:04:04 <KatieHuber> not sure what you mean there, Pseudonym
17:04:07 <danderson> But it's nothing a good deal of healthy study can't cure
17:04:08 <Pseudonym> data Move = Move Card Place Place  -- Move Card from Place to Place
17:04:20 <Philippa> (but you only really need to do it in the function that's asking for possible moves between given piles)
17:05:04 <Cale> danderson: The wikibook is not a bad place to start off.
17:05:04 <Philippa> have you got a type synonym for the "areas" like the tableau and the foundation?
17:05:10 <KatieHuber> hmm, so naming the piles... my current design that's all implicit
17:05:18 <Philippa> (this is so I've got a name to use while I discuss stuff)
17:05:24 <KatieHuber> I was just going to say which card moved and provide the resultant state
17:05:26 <Pseudonym> KatieHuber: Another way to think about it.
17:05:31 <Pseudonym> data Move = Move Card Patience Patience
17:05:33 <KatieHuber> but I can see naming the places would help
17:05:37 <Pseudonym> That would also make sense, right?
17:05:47 <Pseudonym> Then you wouldn't need to name the places.
17:06:12 <KatieHuber> yes, but with my current design I'm in the situation of looking at an individual card, going "yup, that can move to a foundation" but not knowing which pile it's coming from or which foundation it's going to
17:06:16 <Philippa> as a rule of thumb, hanging onto info where reasonably possible tends to make your life easier later - if you later on need to know what the actual change was, having to reconstitute it from two states is a PITA
17:06:18 <KatieHuber> naming the places would fix that
17:06:21 <danderson> Cale: right, heading over there now.
17:06:25 <Philippa> (also, it's easier to force the moves to conform to the rules that way)
17:06:50 <Pseudonym> Naming the places will also give you a nice way to report the moves in human-readable form, of course.
17:06:51 <Philippa> KatieHuber: sure. But whichever function called it knows which pile it was looking at, and can fill in the blank
17:06:59 <mudge> Cale: your fold diagrams are pretty neat: http://cale.yi.org/index.php/Fold_Diagrams
17:07:01 <lambdabot> Title: Fold Diagrams - CaleWiki
17:07:16 <SamB_XP_> data Patience = Impatient | Patient | RockLike
17:07:26 <KatieHuber> true, I can extend the information about the move on the way out...
17:07:27 <SamB_XP_> ?
17:07:30 <Pseudonym> data Patience = ADD | Saint
17:07:34 <KatieHuber> I will mediate on this over lunch, and report back :)
17:07:41 <KatieHuber> thanks for help & suggestions
17:07:43 <Pseudonym> data Patience = Patience Gilbert Sullivan
17:07:45 <Cale> mudge: Thanks :)
17:07:46 <Pseudonym> No problem.
17:07:51 <LoganCapaldo> newtype Patient = Patient Bool
17:07:54 <Pseudonym> And please do let us know how you go.
17:08:05 <Pseudonym> Sounds like a fun program you're writing.
17:08:15 <mudge> Cale: how did you make those diagrams?
17:08:24 <Cale> Inkscape
17:08:24 <chessguy> KatieHuber, FYI, spider solitaire is being written by someone else, if you're intereste
17:08:26 <chessguy> d
17:08:42 <Pseudonym> chessguy: Some kind of generic library would be cool, though.
17:08:46 <ddarius> @check patience ddarius == RockLike
17:08:47 <lambdabot>   Not in scope: data constructor `RockLike'
17:08:48 <chessguy> sure
17:08:59 <mudge> Cale: it would be cool if there was a way to feed functions to a grapher,  and the grapher would diagram out the recursion of the function passed in
17:09:22 <SimonRC> Earlier today I suddenly realised: forms for inputting sum datatypes are much harder to design properly than those for product datatypes.
17:09:35 <SimonRC> products just come out as a load of input boxes
17:09:39 <Cale> mudge: Yeah -- in fact, this is what the things actually look like in memory (at least, modulo optimisations)
17:09:45 <ddarius> SimonRC: It's called a radio button.
17:09:45 <SimonRC> sums come out as forms that change
17:09:52 <monochrom> a grapher of a recursive function - sounds like another application of delimited continuation ;)
17:09:57 <Pseudonym> ddarius: That's great for an enumeration type.
17:10:02 <mudge> Cale: cool
17:10:07 <LoganCapaldo> ddarius, I think he means sums of products/sums
17:10:07 <Pseudonym> But for general sum types, you at least need greying.
17:10:14 <ddarius> Pseudonym: You can use the selection to enable a group.
17:10:16 <sioraiocht> @src [] mappend
17:10:16 <lambdabot> Source not found. You speak an infinite deal of nothing
17:10:17 <SimonRC> radio buttons + greying can handle general sums
17:10:19 <SimonRC> I think
17:10:22 <Cale> mudge: Early implementations of lazy evaluation actually represented expressions in memory using graphs and mutated them as it went.
17:10:26 <sioraiocht> @instances Monoid
17:10:28 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
17:10:29 <Pseudonym> Property sheets also work in the large.
17:10:29 <Philippa> yep. Was doable back in VB1
17:10:32 <SimonRC> unless you have recursion, in which case God help you
17:10:34 <ddarius> Okay, we're all thinking the same thing.
17:10:41 <ddarius> I guess tabs would be sensible too.
17:10:45 <Philippa> yeah, but products don't like recursion in forms either
17:10:49 <sioraiocht> @src mappend
17:10:49 <lambdabot> Source not found. Do you think like you type?
17:10:54 <Cale> mudge: So a truly visual Haskell system which made that sort of thing visible would be very cool.
17:11:06 <Philippa> (and the solution's still the same! Tree control w/remaining stuff underneath)
17:11:10 <ddarius> "Please enter a value of type Stream a = Cons a (Stream a)> "
17:11:16 <Pseudonym> ddarius: Yeah, property sheets. :-)  Am I too Windows-embedded at the moment that I call them "property sheets" instead of "tabbed dialogs".
17:11:17 <Pseudonym> ?
17:11:20 <SimonRC> Philippa: hmm, I suppose so...
17:11:33 <ddarius> Pseudonym: I had no idea what you were talking about.
17:11:37 <mudge> Cale: yea really.   And for some newbies more complicated recursion is hard to follow,  a tool like that could be really helpful in understanding some functions
17:11:47 <SimonRC> and I thought tabs were deprecated...
17:12:14 <augustss> @seen dpiponi
17:12:14 <mudge> Cale: or maybe it is just me
17:12:14 <lambdabot> I saw dpiponi leaving #haskell 1d 23h 24m 15s ago, and .
17:12:38 <Pseudonym> I know this channel is logged, but I'll admit this anyway.  I had a problem with Windows property sheets that I only managed to solve by downloading the stolen Windows source and examining it.
17:12:39 <Cale> mudge: No, that really is a major right way to think about functional programming, and we don't really talk about it enough.
17:12:46 <Philippa> every useful but non-trivial UI widget gets deprecated by someone sooner or later
17:13:24 <Philippa> Cale: about /lazy/ functional programming. I think most people think in terms of tree reduction for strict languages comparatively 'naturally'
17:14:05 <Philippa> it's making the jump to "shit, wait, that's not a tree, it's a graph!" that doesn't happen
17:14:17 <Cale> same thing though, it's just your graph never ends up having cycles in it
17:14:24 <monochrom> if all useful and non-trivial widgets are deprecated eventually, will we be left with useless or trivial widgets? :)
17:14:38 --- mode: Igloo set -o Igloo
17:14:40 <LoganCapaldo> trivially useless widgets
17:14:45 <ddarius> Philippa: It's making the shift that you reduce -that- then not now that seems to be the biggest issue.
17:14:52 <mudge> Cale: cool
17:15:57 <Cale> Pseudonym: When I hear the term "property sheets" in a UI context, I actually think of something rather different -- the sort of thing that shows up in GUI editors to show the properties of a control.
17:16:45 <SimonRC> Cale: indeed
17:16:48 <Pseudonym> Yeah, the Windows standard use case is precisely that.
17:16:49 <Cale> (that is, essentially a heterogeneous list of label/control pairs which are mostly combo and text boxes.)
17:16:58 <Pseudonym> You have a bunch of components each of which has its own properties.
17:17:18 <SimonRC> the "properties" of the control's object
17:17:30 <Pseudonym> Each exports one or more property pages, and the property sheet is a tabbed dialog that encapsulates them.
17:22:11 <petekaz> Is it me, a haskell newbie, or does anyone else find type sigs like this hard to read:
17:22:20 <petekaz>  counterIteratee :: (Monad m) => Int -> IterAct m Int
17:22:23 <petekaz>  counterIteratee _ i = result' $ (1 + i)
17:22:35 <Pseudonym> I find that function name hard to read.
17:22:37 <ddarius> What's hard to read about that?
17:22:58 <petekaz> Well, I see 2 args, and I know there is a return type
17:23:03 <sjanssen> petekaz: looks pretty straightforward to me
17:23:05 <Philippa> aside from the bit where you have to substitute in IterAct to work out how it typechecks?
17:23:33 <sjanssen> erm, on second thought, what is InterAct
17:23:44 <ddarius> True.  You have to know what IterAct means, but you have to know that anyway.
17:23:46 <sjanssen> I first thought it was a monad transformer, but now I'm not so sure
17:23:53 <petekaz> type IterAct m seedType = seedType -> m (IterResult seedType)
17:23:57 <petekaz> That is my point.
17:24:07 <Pseudonym> And I'm not sure what result' is.
17:24:09 <Pseudonym> Oh.
17:24:12 <ddarius> petekaz: I have no problem at all with naming function types.
17:24:17 <Pseudonym> Yeah, IterAct isn't so great a type.
17:24:21 <Pseudonym> Maybe that's the problem.
17:24:24 <ddarius> Higher order functions are values too.
17:24:29 <petekaz> I notice that Oleg does this very frequently.
17:24:38 <petekaz> As a newbie, I find it extremely hard to read.
17:24:54 <Pseudonym> petekaz: As a C++ newbie, I found initialisation lists hard to read.
17:25:01 <Pseudonym> I can read them now, of course.
17:25:05 <monochrom> OK, but not all programs are written for beginners.
17:25:06 <ddarius> You need to think of it at the level of the abstraction.
17:25:06 <Pseudonym> But they really threw me.
17:25:20 <Pseudonym> I don't like that IterAct type, though.
17:25:35 <Pseudonym> Seems to me that someone actually wants a monad transformer.
17:25:49 <petekaz> And here is result:
17:25:51 <petekaz> result' :: Monad m => IterAct m
17:25:53 <ddarius> Pseudonym: In this case, yes.
17:26:12 <petekaz> Again, I see that in use, it takes an arg, and returns something.  But the type is terrible.
17:26:39 <ddarius> I think type Algebra f a = f a -> a is reasonable.
17:26:42 <monochrom> No, no monad transformer is intended.
17:27:40 <Philippa> I'm inclined to think the definition of counterIteratee isn't a wonderful piece of code, mostly because you have to spot "this is the start of the IterAct" yourself
17:27:50 <Pseudonym> Yeah.
17:27:56 <Philippa> there's no hint to the reader whatsoever
17:28:04 <ddarius> I think you are viewing in the wrong light.
17:28:27 * LoganCapaldo is starting to suspect ddarius secretly wrote this code
17:28:31 <LoganCapaldo> ;)
17:28:33 <Pseudonym> The thing is, I agree with petekaz.
17:28:33 <ddarius> Though, usually I do like writing something like counterIteratee _ = \x -> ...
17:28:37 <Pseudonym> This _is_ hard to read.
17:28:44 <Philippa> ddarius: much my point really
17:28:51 <Pseudonym> One of the reason it's hard to read is that it's a monad transformer, and that's hard for newbies.
17:28:58 <Philippa> or if you don't want a lambda, use a where or let block
17:28:59 <Pseudonym> But even worse, it's a monad transformer in disguise.
17:29:07 <Pseudonym> And the disguise makes it worse.
17:29:12 <LoganCapaldo> it's more than meets the eye
17:29:17 <petekaz> I thought the whole point of type sigs was to _enhance_ readability, but in this case I find it counterintuitive.
17:29:21 <LoganCapaldo> transfomers!
17:29:30 <ddarius> Pseudonym: That's somewhat beside the point as far as the type synonym is concerned.
17:29:36 <monochrom> Could you re-do it as monad transformers?
17:29:38 <Philippa> petekaz: I doubt you'd find it much more intuitive without the signiature there
17:29:43 <Pseudonym> ddarius: No, I disagree!
17:29:59 <Philippa> sooner or later you're still going to ask "WTF is it building?"
17:29:59 <ddarius> My point is that once these things are defined you only combine them with other primitives and don't see the "implementation" of IterAct.
17:30:09 <ddarius> Philippa: Not necessarily.
17:30:10 <Pseudonym> This is a bad munging of a standard Haskell pattern.
17:30:17 <Pseudonym> If it followed the pattern, it would be more readable.
17:30:25 <ddarius> Pseudonym: I'm not saying the code is good.
17:30:32 <monochrom> I don't see it. Could anyone show it please?
17:30:48 <Pseudonym> I'm saying that if the code were written better, it would be more readable.
17:30:50 <ddarius> But the general notion of naming function types with type synonyms is independent.
17:31:03 <ddarius> Pseudonym: Then it wouldn't be a case of this situation.
17:31:08 <Pseudonym> Because the connection between the code and the type would be more obvious.
17:31:14 <ddarius> Which would be fine, but the general situation is okay as far as I'm concerned.
17:31:29 <Philippa> I tend to think it's rarely a good idea to use a type synonym rather than a newtype there if the user's going to see any examples being built directly
17:32:07 <ddarius> Is counterIteratee "user" code?
17:32:13 <petekaz> Yes.
17:32:26 <Philippa> if petekaz is looking at it, probably :-)
17:32:35 <ddarius> Philippa: He could be looking at the implementation.
17:32:36 <petekaz> It's the iterator one uses to iterate over db result sets.
17:32:44 <petekaz> its not implementation.
17:32:53 <ddarius> Where is this code?
17:33:06 <Pseudonym> BTW, I agree with Philippa somewhat here.  Type synonyms (as opposed to newtypes) don't clarify types as much as people think.
17:33:08 <petekaz> the client of takusen is supposed to make his/her own iteratees.
17:33:16 <Pseudonym> Some do, some don't.
17:33:19 <petekaz> ddarius: http://darcs.haskell.org/takusen/doc/html/Database-Enumerator.html
17:33:22 <lambdabot> http://tinyurl.com/22qtqp
17:33:24 <Pseudonym> And more to the point, not all of the ones written do.
17:33:58 <Philippa> personally I use type synonyms mostly when I want to be able to change the underlying type (or have already done so because it was a datatype previously)
17:34:08 <Pseudonym> I use type synonyms to make types shorter.
17:34:10 <Pseudonym> Like:
17:34:16 <Pseudonym> type Optimiser = Structure -> Structure
17:34:26 <Pseudonym> someOptimiser :: Optimiser
17:34:34 <Pseudonym> iterateUntilFixpoint :: Optimiser -> Optimiser
17:34:45 * ddarius would never use type synonyms merely to make types shorter.
17:34:46 <Pseudonym> I think that makes things clearer with the type synonym
17:34:53 <hpaste>  sjanssen annotated "I'm an imperative programmer!!!" with "the Right Way" at http://hpaste.org/2654#a7
17:34:53 <Pseudonym> As well as making it shorter.
17:35:17 <Philippa> ddarius: I would, if you've got sufficiently deeply-nested type constructors it can be a big readability boost
17:35:20 <Pseudonym> ddarius: Sure, you need some other advantage too.
17:35:24 <Pseudonym> But something like:
17:35:30 <Pseudonym> ?type foldr
17:35:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:35:35 <ddarius> Philippa: It would have to be naming something meaningful.
17:35:38 <Pseudonym> I'd be happy to write:
17:35:46 <Pseudonym> type ConsType a b = a -> b -> b
17:35:50 <Philippa> sure. But it's pretty unlikely that it's not doing so
17:35:52 <Pseudonym> foldr :: ConsType a b -> b -> [a] -> b
17:35:56 <Pseudonym> Not that this makes it shorter.
17:36:00 <ddarius> Philippa: Indeed, which is convenient.
17:36:11 <Philippa> or rather, that becomes the heuristic for /what/ to factor, not whether to factor at all
17:36:15 <Pseudonym> But by giving ConsType a name, you make it a concept that you can discuss independently of foldr.
17:36:19 <Pseudonym> And document independently, too.
17:36:34 <ddarius> type ListAlg a b = (a -> b -> b, b) !
17:36:53 <Pseudonym> ddarius: If you were using it in a lot of places, that's not so dumb.
17:36:59 <Pseudonym> Though I'd be tempted to use a record.
17:37:15 <Philippa> as would I, records're good because you get to name extra concepts
17:37:20 <ddarius> I'm not saying it's dumb at all, and yes I would use a record (or at least an actual datatype) for it.
17:37:46 <ddarius> By making the type distinct we can make the general fold over an algebra.
17:37:49 <Pseudonym> But I'm definitely of the school of thought that if it makes sense to give something a name, give it a name.
17:38:06 <Pseudonym> So you can talk about it independently of anywhere it's used.
17:39:17 <Pseudonym> That often has the advantage that it clarifies your thinking about what it is.
17:39:30 <ddarius> That's why type synonyms are important, to make it cheap to name some typ.
17:39:41 <monochrom> Is programming discovered or invented?
17:39:43 <Pseudonym> Also true of newtype deriving. :-)
17:40:00 <Pseudonym> monochrom: Computer science is discovered, software engineering is invented./
17:40:01 <petekaz> So I guess I'll skip Takusen and use HDBC instead.
17:40:06 <ddarius> programming is performed
17:40:09 <Pseudonym> Yes.
17:40:20 <LoganCapaldo> monochrom, are you sure you aren't asking about programs?
17:40:20 <Pseudonym> Programming is a craft, much like saddlemaking.
17:40:30 <Pseudonym> It's performed by artisans.
17:40:35 <ddarius> Or flintknapping!
17:40:39 <Pseudonym> Yes!
17:40:40 * ddarius goes out and finds a rock
17:41:09 * Philippa flintknaps ddarius' rock
17:41:45 <ddarius> Actually the rock is to perform the flintknapping.  Glass is a friendly material to actually flintknap.
17:41:57 * Cale goes out and finds a progressive rock
17:42:15 * monochrom supports the idea of avoiding success.
17:42:22 <LoganCapaldo> You don't kidnap kids and you don't flintknap flint
17:42:45 <ddarius> LoganCapaldo: ?
17:43:28 <LoganCapaldo> ddarius, I thought Philippa was making a joke about stealing your rock
17:43:39 <ddarius> Probably.
17:43:41 * ddarius is slow.
17:43:51 * ddarius said this yesterday or sometime recent.
17:44:16 <monochrom> Yesterday. You said you hit your head too many times during childhood.
17:44:22 <Philippa> yeah, only people do kidnap kids. Sometimes even when that means young goats
17:44:30 <ddarius> Actually, I said I was dropped on my head too many times.
17:44:45 <monochrom> I abstracted away details.  <duck>
17:45:17 <monochrom> Ooops, I guess I added some other details at the same time. Should be "head is hit".
17:46:01 * monochrom will try "went through abrupt momentum change" next time...
17:46:42 <ddarius> The particles of my head exchanged photons with the particles of the floor.
17:47:06 <danderson> silly beginner's question: is there a way to ask GHCi for the type signature of a function?
17:47:07 <LoganCapaldo> you saw stars?
17:47:14 <chessguy_> :t
17:47:15 <LoganCapaldo> danderson, yes
17:47:17 <ddarius> :t const
17:47:19 <LoganCapaldo> :t function
17:47:23 <danderson> thanks.
17:47:26 <lambdabot> forall a b. a -> b -> a
17:47:27 <lambdabot> Not in scope: `function'
17:47:33 <LoganCapaldo> heh
17:47:35 <ddarius> Slow yourself today, 'bot.
17:47:43 <LoganCapaldo> I shoulda used a real function
17:47:44 <monochrom> It was slow earlier.
17:47:51 <danderson> whoa, haskell wins at type inference.
17:48:04 <sioraiocht> danderson: yes, it's pretty decent
17:48:34 <ddarius> danderson: Other languages do code inference.
17:48:39 <Randroid> I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
17:48:48 <ddarius> @djinn const
17:48:48 <lambdabot> -- f cannot be realized.
17:48:55 <ddarius> @djinn a -> b -> b
17:48:56 <lambdabot> f _ a = a
17:49:03 <ddarius> @djinn a -> b -> a
17:49:03 <lambdabot> f a _ = a
17:49:04 <chessguy_> @remember I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
17:49:04 <lambdabot> Done.
17:49:12 <chessguy_> @remember Randroid I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
17:49:12 <lambdabot> Done.
17:49:14 * SimonRC goes to bed
17:49:14 <allbery_b> @. djinn type const
17:49:16 <lambdabot> f a _ = a
17:49:23 <chessguy_> @quote I
17:49:24 <lambdabot> I says: just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
17:49:32 <chessguy_> @help forget
17:49:32 <lambdabot> forget nick quote.  Delete a quote
17:49:44 <chessguy_> @forget I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
17:49:44 <lambdabot> Done.
17:50:08 <Randroid> What's all this @remember and @forget stuff?
17:50:14 <sioraiocht> @quote
17:50:14 <lambdabot> Tac-Tics says: We also had a professor who spoke Chinese as his primary language. He mistyped "Pumping lemma" as "pumping lamma" and the entire semester, we just drew pictures of llamas with
17:50:14 <lambdabot> dumbbells on our homework
17:50:18 <ddarius> @help remember
17:50:18 <lambdabot> quote <nick>
17:50:18 <lambdabot> remember <nick> <quote>
17:50:18 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:50:27 <sioraiocht> @quote sioraiocht
17:50:28 <lambdabot> sioraiocht says: if you made a type class the same name as a type, I'd stab you in the face
17:50:28 <Randroid> Hm. Cool idea.
17:50:53 <sioraiocht> (my answer to the reason they share the same namespace)
17:51:47 <sioraiocht> @quote dons
17:51:48 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
17:51:49 <Randroid> Cool. Well, I'm a serious student of Haskell, but I have a mischievous sense of humor, as I'm sure many of us do.
17:52:16 <sioraiocht> Randroid: A lot of us spend all day in this channel, we can't be all business ALL THE TIME =p
17:52:23 <Randroid> So true. :)
17:52:56 <earnest> what's mischievous?
17:53:13 <earnest> i can check it on google, but i'd like to talk
17:53:23 <earnest> and that's a way; even if an off-topic way :)
17:53:35 <monochrom> Using delimited continuations to mimick state is mischievous, for example.
17:54:10 <earnest> but that's an abstract enough example to help me understand his sense of humor, i guess
17:54:28 <ddarius> monochrom: Why?  The cat's already out of the bag with delimited continuations anyway.
17:54:31 <ari> An informal contest on who's the most imperative Haskell programmer, such as a few people had here a couple of hours ago, is also somewhat mischievous, if not in the sense of actually possibly causing harm
17:54:44 <earnest> for instance: what's to mimic a state? what's a wild description :)
17:55:10 <earnest> hm, i didn't see the contest
17:55:16 <monochrom> Control.Monad.State is a much more readable way to mimick state.
17:55:18 <earnest> i guess i better look the word up :) it's gettin hard
17:56:12 <earnest> 3. Troublesome; irritating
17:56:39 <earnest> 2. Playful in a nauthy or teasing way
17:56:55 <earnest> hey Randroid, i like your sense of humor
17:57:02 <Randroid> Danke
17:57:23 <monochrom> There is a mischievous way to look up words too.
17:57:29 <monochrom> @dict mischievous
17:57:29 <lambdabot> Supported dictionary-lookup commands:
17:57:30 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
17:57:30 <lambdabot> Use "dict-help [cmd...]" for more.
17:57:52 <monochrom> @web mischievous
17:57:54 <lambdabot> *** "Mischievous" web1913 "Webster's Revised Unabridged Dictionary (1913)"
17:57:54 <lambdabot> Mischievous \Mis"chie*vous\, a.
17:57:54 <lambdabot>    Causing mischief; harmful; hurtful; -- now often applied
17:57:54 <lambdabot>    where the evil is done carelessly or in sport; as, a
17:57:54 <lambdabot>    mischievous child. ``Most mischievous foul sin.'' --Shak.
17:57:56 <lambdabot> [7 @more lines]
17:58:12 <monochrom> etc. etc.
17:58:12 <earnest> that's nice
17:58:20 <earnest> i actually wrote an irc bot which does the same, but i didnt use it
17:58:30 <earnest> i guess i forgot she exists
17:58:34 <Randroid> instance Monad Dryer where ; spin :: Laundry -> Laundry ...
17:58:41 <earnest> she sits on #0xff --- dansarina
17:58:52 <earnest> i guess she understands: @def word or @define word
17:59:31 <monochrom> Like @define map a higher-order function to transform a list elementwise? :)
17:59:49 <earnest> i dont know if it's like that :)
18:00:36 <earnest> dansarina was written in c by a a unix-programmer wannabe; she probably knows nothing about higher orders
18:01:09 <Randroid> A professor at ECU, a friend of a friend, has created a new multi-paradigm language with Haskell as one of its influences. I find it to be esthetically displeasing, but it's interesting. http://www.cs.ecu.edu/~karl/cinnameg/3-1/Overview/Overview.html
18:01:10 <lambdabot> Title: A brief overview of Cinnameg
18:01:41 * Randroid loves lambdabot
18:01:50 <Randroid> Yes, the language is called Cinnameg.
18:02:27 <earnest> I thikn that lambdabot is very smart, but I would love if his name were just lambda; imagine if you were called, say, EarnestHuman
18:02:43 * lambdabot loves you too
18:02:43 <monochrom> Generally, if you combine the most beautiful nose, the most beautiful left eye, the most beautiful right eye, the most beautiful mouth, ... the result is displeasing.
18:02:57 <Pseudonym> Lambdabot isn't a "he", by the way.
18:03:08 <earnest> She? Or nothing at all?
18:03:15 <monochrom> She is lambdabot.
18:03:16 <Pseudonym> We usually refer to lambdabot as "she".
18:03:29 <earnest> I'm sorry then, I didn't know.
18:03:40 * Randroid loves her even more now that he knows she's got a whoopie, or perhaps a virtual one.
18:03:41 <lambdabot> Just don't make that mistake again.
18:03:41 <earnest> Today there are more sexes than meets the eye
18:03:47 <earnest> If that expression makes any sense here :)
18:04:04 <LoganCapaldo> @bot
18:04:04 <lambdabot> :)
18:04:09 <lambdabot> Being a program, I don't know what a "whoopie" is.
18:04:26 <earnest> lambdabot: what do you think of your name being lambdabot?
18:04:36 <earnest> lambdabot: doesn't it suck that bot is attached to your name?
18:04:39 <lambdabot> earnest: We were discussing you --not me.
18:04:56 <earnest> Can we discuss you too?
18:05:06 <lambdabot> earnest: Come, come, elucidate your thoughts.
18:05:10 <LoganCapaldo> (Does she have an eliza mode? is that what is going on?)
18:05:25 <lambdabot> Just kidding. You know I love you all.
18:05:41 <LoganCapaldo> (i guess not)
18:05:42 * allbery_b suspects someone is abusing @msg
18:05:50 <EvilTerran> i suspect remote control, also
18:05:53 <LoganCapaldo> (eliza would be funnier)
18:05:55 <sioraiocht> So I understand how to use the State monad, but I'm not sure I understand why it WORKS
18:06:10 <monochrom> You can try the source code.
18:06:18 <allbery_b> @vixen (Does she have an eliza mode? is that what is going on?)
18:06:19 <lambdabot> sure is
18:06:19 <Pseudonym> sioraiocht: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:06:21 * EvilTerran knows of a bot in another channel that occasionally harasses a chatter for no particular reason
18:06:24 <LoganCapaldo> sioraiocht, state is actually one of the easiest monads to get (after Maybe and List)
18:06:24 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
18:06:24 <earnest> Well, lambda, I've been veyr clear already: I dont want to be called EarnestHuman; I htink it's silly. So I find lambdabot kind of silly too; I'd like to just call you lambda; having the species name attached to your name seems a little... speciescist. :)
18:06:29 <sioraiocht> thanks
18:06:30 <Pseudonym> sioraiocht: That might help.
18:06:48 <EvilTerran> @help vixen
18:06:49 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
18:06:58 <monochrom> I suppose you don't want to be an Ear Nest either.
18:07:02 <Randroid> sioraiocht: So true! I'm at that stage myself. I've been playing around with implementing my own State monad as a way of understanding. I've made huge progress, but I want to reach that stage where I *just know*, if you know what I mean.
18:07:20 <earnest> I wouldn't know it means, monochrom.
18:07:22 <EvilTerran> @vixen What do you think of the "bot" in your name?
18:07:22 <lambdabot> My name is Emily
18:07:33 <monochrom> A nest full of ears.
18:07:34 <LoganCapaldo> sioraiocht, the key thing IMO is to realize that a State value is a function
18:07:35 <elliottt> sioraiocht: the thing that helped me most was to unroll the state monad for a simple example
18:07:38 <Pseudonym> ?vixen So do you like combinatorial logic?
18:07:38 <lambdabot> sure, i definitely don't hate
18:07:43 <earnest> monochrom: :) that'd be funny :)
18:07:45 <sioraiocht> elliottt: I tink I might have to
18:07:49 <monochrom> hehehehe
18:07:52 <EvilTerran> an ear used as a nest?
18:07:56 <elliottt> it's the only thing that cleared it up for me :)
18:08:03 <sioraiocht> LoganCapaldo: I do get that, and when you "unwrap" it you get the value, right?
18:08:11 <Randroid> By the way, sioraiocht, what does your name mean in Gaelic? It's an abstract noun because it ends in -ocht (which is the form -acht takes after long -i I think).
18:08:26 <sioraiocht> Randroid: it means eternity
18:08:26 <earnest> Nested ears --- a therapist.
18:08:28 <LoganCapaldo> when you unwrap it you get the function
18:08:28 * EvilTerran had a beetle crawl into his ear once, when he was about 6yo
18:08:38 <LoganCapaldo> when you apply the function to an initial state you get the value
18:08:59 <earnest> lambdabot: what's Emily's last name? Does she have one?
18:09:03 <EvilTerran> i still remember it rather clearly. i guess it was traumatic. =)
18:09:07 <sioraiocht> LoganCapaldo: right, but that value then doesn't depend on the state you apply...
18:09:10 <LoganCapaldo> >>= in State is a little bit like (.)
18:09:10 <EvilTerran> @vixen Do you have a surname?
18:09:10 <lambdabot> whoa whoa whoa, one question at a time!
18:09:20 <LoganCapaldo> sioraiocht, it might
18:09:25 <earnest> hehe :) we're giving lambdabot some trouble :)
18:09:27 <Pseudonym> ?vixen That was only one question, you ninny.
18:09:28 <lambdabot> Are we just wasting time?
18:09:33 <LoganCapaldo> if its get for instance
18:09:40 <earnest> lambdabot: no; i'm really interested in the talk.
18:09:44 <Randroid> @src get
18:09:44 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:09:51 <sioraiocht> Randroid: An bhfuil Gaeilge agat?
18:09:56 <Pseudonym> ?vixen I'll show you just two fingers...
18:09:56 <lambdabot> amuse me please! (and don't ask
18:10:05 <Randroid> sioraiocht: Nil agam.
18:10:16 <earnest> hehe; emily is mischievous
18:10:22 <EvilTerran> earnest, she doesn't usually reply to people addressing her by name. "@vixen" is the command to talk to her chatbot side.
18:10:25 <Randroid> (I think that's right. I know a little.)
18:10:26 <sioraiocht> Randroid: ah, you dabbled, though?
18:10:38 <lambdabot> Vixen is a twit.
18:10:42 <Randroid> sioraiocht: My Welsh is pretty good, my Gaelic not so good.
18:10:59 <sioraiocht> Randroid: then perhaps you should have replied T cpla focal agam =)
18:10:59 <earnest> EvilTerran: I see; that's sad.
18:11:11 <Randroid> "I have a couple of words".
18:11:13 <sioraiocht> Randroid: well I have no welsh, just "Cymru"  =)
18:11:27 <EvilTerran> it would be interesting if "lambdabot:" did the same thing as "@vixen", tho. shouldn't be too hard, either.
18:11:27 <sioraiocht> Randroid: Aye, it's the most common way to say "I speak a little Irish"
18:11:40 <Randroid> sioraiocht: Very cool. :)
18:11:54 <earnest> It would be interesting if she would care about her own real name
18:12:03 <allbery_b> trivial context hook in the vixen module
18:12:09 <dibblego> does GHC optimise the tail call in filter, where the predicate does not hold?
18:12:41 <LoganCapaldo> sioraiocht, another thing that helped me was writting state
18:13:24 <sioraiocht> LoganCapaldo: I'm hoping to get there, once I can reproduce what I was taught I'm usually "there"
18:13:37 * Pseudonym suggests #haskell.cy
18:14:03 <Pseudonym> And, presumably, #haskell.ga.
18:14:14 <earnest> what's it, Pseudonym? A foreigner haskell channel>
18:14:19 <earnest>                                                  ?
18:14:27 <Pseudonym> Oh, there are a bunch of haskell channels for specific locales.
18:14:35 <Pseudonym> .cy would be Welsh, .ga would be Irish Gaelic.
18:14:48 <Pseudonym> As opposed to Scots Gaelic, of course.
18:15:23 <Randroid> I wonder how many Haskellers speak Cymraeg.
18:15:29 * sioraiocht is happy to hear people know the difference.
18:15:48 <Pseudonym> As a matter of curiosity, how close is Breton to Gaelic?
18:15:55 <sioraiocht> Pseudonym: Not
18:16:03 <Randroid> Breton is a P-Celtic language, like Welsh.
18:16:07 <Pseudonym> Right.
18:16:11 <Randroid> It's much closer to Welsh than Gaelic.
18:16:13 <Pseudonym> OK, that makes sense.
18:16:23 <wli> My guess is one will have to do a survey of Haskellers to decide it.
18:16:29 <sioraiocht> Pseudonym: You'd find breton sounding like a drunk welshman speaking french
18:16:33 <hpaste>  LoganCapaldo pasted "sioraiocht, here's my version of State, maybe it will help you" at http://hpaste.org/2655
18:17:31 <sioraiocht> Pseudonym: The Brythonic languages lost a lot of "Celtic
18:17:35 <sioraiocht> " qualities to their language
18:17:40 <LoganCapaldo>  you probably want to ignore the bit where I implement show, it was a terrible idea :)
18:17:56 <sioraiocht> as they were more influenced by Germanic languages, whereas the Gaelic langs were more isolated
18:18:08 <Randroid> One of my hobbies is constructed languages. Often I have trouble thinking of new words, so I've written a Haskell application that generates them for me. I created a simple domain-specific language and a Haskell module that uses Parsec to interpret it. The DSL defines the legal structure of a word in the language and then generates random words when run through Parsec.
18:18:22 <monochrom> Hrm, P-Celtic, Q-Celtic, ... it causes me to think p-adic, q-modular, ...
18:18:45 <sioraiocht> lol
18:19:03 * sioraiocht prefers the terms Brythonic and Goidelic to P-Celtic and Q-celtic
18:19:22 <sioraiocht> as the other q-celtic languages are..well..quite dead
18:20:13 <Randroid> I'm an old Indo-Europeanist, so I like to be reminded of things like the fact that IE /kw/ became /p/ in Brythonic and generally /k/ in Goidelic. I'm old fashioned. :)
18:20:38 <sioraiocht> that works, though, too.
18:22:09 <earnest> You know what's strange with my GNU emacs? To achieve M-b, I have to press Esc, so that I can move back a word. But to achieve M-f, I can just press Alt-f, and then I move forward a word. Isn't that odd?
18:22:31 <LoganCapaldo> that does seem odd
18:22:35 <earnest> My meta key is mischievous.
18:22:38 <allbery_b> you're not running xmonad, are you,, with default bindings?
18:22:46 <earnest> Oh, that explains it all. :)
18:23:01 <earnest> I am, with default bindings.
18:23:04 <Randroid> sioraiocht: Have you checked out Brithenig? http://en.wikipedia.org/wiki/Brithenig
18:23:06 <allbery_b> it grabsM-b and toggle the status bar (which is probably disabled if you're running deaults)
18:23:23 <earnest> Yeah; I've got not status bar.
18:23:26 <sioraiocht> hahah, NEAT
18:23:36 <allbery_b> so it toggles a 0-height status bar
18:24:09 <Randroid> It's a sort of Celtic Romance language.
18:25:30 <earnest> allbery_b: I see; I will see what I can do about that; I guess I probably would like to make xmonad use a different meta key, if that's possible, and probably is?
18:26:08 <allbery_b> change modMask in Config.hs
18:26:13 <Randroid> I love languages, human and computer. Sorry I concentrated more on human languages that good ole Haskell, but I've gotta run. Ciao!
18:26:39 <allbery_b> you'll need to figure out what modifier applies to the alternative key you want to use (e.. Windows key)
18:27:12 <earnest> Windows key would be wonderful to use, as it is pretty useless here.
18:28:26 <earnest> Trying mod4Mask. Let's see.
18:28:32 <allbery_b> xev is useful for figuring out modifier keys
18:28:45 * allbery_b has only Macs around him, no windows keys :)
18:29:20 <allbery_b> (but also no available modifier keys since he generally only does x11 over vnc, so command and option are taken...)
18:29:53 * allbery_b should figure out if he can bind the control key he disabled instead of swapping wth capslock, as something useful
18:31:02 <sioraiocht> I GET IT
18:31:07 <sioraiocht> thanks LoganCapaldo
18:31:22 <earnest> xev? never heard of xev; it prints contents of X events; cool
18:31:53 <earnest> you know what's funny? I pressed M-x man and the default entry was ``xev'' probably just because that was the last word I typed before the command; you gotta love this GNU emacs.
18:34:30 <LoganCapaldo> you're wecome
18:35:40 <LoganCapaldo> s/wecome/welcome/
18:36:29 * Pseudonym isn't wecome
18:37:28 <LoganCapaldo> what does wecome mean?
18:37:48 <LoganCapaldo> @all-dicts wecome
18:37:49 <lambdabot> No match for "wecome".
18:38:44 <dibblego> @commands
18:38:44 <lambdabot> Unknown command, try @list
18:40:31 <sclv> @list
18:40:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:41:06 <KatieHuber> for those who were helping me earlier - I implemented the pile-naming scheme suggested, and it makes life much easier
18:41:23 <KatieHuber> I'm now generating lists of moves like
18:41:24 <KatieHuber> do gen <- newStdGen; print (allMoves (deal gen))
18:41:24 <KatieHuber> [move 10 of Hearts from Tableau 0 to Tableau 4,move 10 of Hearts from Tableau 0 to Tableau 5,move 3 of Diamonds from Tableau 1 to Tableau 2,move 2 of Clubs from Tableau 6 to Tableau 1,move 2 of Clubs from Tableau 6 to Foundation Clubs]
18:42:04 <KatieHuber> now generating the derived states for a move may still be ugly, but at least it'll be isolated
18:42:13 <Pseudonym> Excellent.
18:42:25 <Pseudonym> As a matter of interest, how are you doing allMoves?
18:43:04 <KatieHuber> I'll just paste the full source for critique -- is there a paste site that does haskell hilighting?
18:43:26 <sorear> @paste
18:43:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:43:48 <hpaste>  Katie pasted "Beleaguered Castle" at http://hpaste.org/2656
18:45:12 * EvilTerran notes that he is very silly, and just caught himself out with an off-by-one error >:[
18:45:14 <monochrom> @pl \f x y -> return (f x y)
18:45:15 <lambdabot> ((return .) .)
18:45:19 <Pseudonym> Hmm.  I don't like the way you've laid out the let-expressions.
18:45:25 <Pseudonym> It's more usual to draw attention to them.
18:45:27 <Pseudonym> let .....
18:45:29 <Pseudonym>     .....
18:45:30 <monochrom> ((o .) O .)
18:45:31 <Pseudonym> in ....
18:45:34 <Pseudonym> Or something like that.
18:45:42 <Pseudonym> where expressions may also be appropriate.
18:45:57 <Pseudonym> It might just be me, but I don't find that readable.
18:46:40 <Pseudonym> OK, now here's a good use for records.
18:46:42 <KatieHuber> I don't know, I don't write much haskell ;)
18:46:51 <earnest> allbery_b: windows key just worked for me. Thanks for the hint.
18:46:56 <Pseudonym> data Card = Card { rank :: Rank, suit :: Suit, face :: Face }
18:47:20 <Pseudonym> That works identically to the type that you have, only you don't have to implement accessor functions like "rank" and "suit" yourself.
18:47:31 <KatieHuber> ah, cool
18:47:54 <Pseudonym> I also notice that you don't use "faceUp".
18:48:26 * EvilTerran would use where over let in that context
18:48:40 <KatieHuber> yeah, I wrote some functions I'm not using, I'll delete 'em later :)
18:48:44 <Pseudonym> Which probably makes sense.  Why use a general two-element enum (Bool) when you have a specific one that does just as well (Face)?
18:49:07 <Pseudonym> I'd put more type declarations in too, BTW. :-)
18:49:12 <EvilTerran> the where form emphasises the non-sequentiality of the thing better
18:49:19 <LoganCapaldo> suits = [Hearts .. Spades]
18:49:32 <EvilTerran> suits = [Hearts ..]
18:49:38 <LoganCapaldo> EvilTerran++
18:49:39 <Pseudonym> suits :: [Suit]
18:49:46 <EvilTerran> :3
18:49:53 <KatieHuber> I only just added deriving (Enum), that's a good idea
18:50:02 <Pseudonym> suits = [minBound..maxBound]
18:50:09 <Pseudonym> You need to derive Bounded.
18:50:10 <KatieHuber> is my randomElement/shuffle reasonable?
18:50:21 <LoganCapaldo> Pseudonym++
18:50:40 <Pseudonym> You never know when the number of suits may change!
18:50:40 <LoganCapaldo> (not that the number or name of suits is likely to change, but still)
18:50:53 <Pseudonym> Actually, in other applications, the ORDER of the suits may change.
18:50:55 <KatieHuber> not too concerned by the O(n^2)ness of it
18:51:05 <Pseudonym> The suit ordering is different in Bridge and 500, for example.
18:51:31 <dibblego> I used card suits in a blog entry on type-classes once
18:51:42 <Pseudonym> dibblego: You have a blog?
18:51:44 <Pseudonym> Where?
18:51:49 <dibblego> http://blog.tmorris.net
18:51:50 <LoganCapaldo> you can derive Enum for Rank can't you?
18:51:51 <lambdabot> Title:  Tony&#8217;s blog 
18:51:58 <Pseudonym> Thanks!
18:52:03 <dibblego> n[
18:52:05 <dibblego> *np :)
18:52:11 <Pseudonym> LoganCapaldo: Sure.
18:52:19 <Pseudonym> And you could also implement your own Bounded instance.
18:52:41 <Philippa> but you're probably better implementing separate enumerations on them
18:52:46 <Pseudonym> Yeah.
18:52:53 <Pseudonym> To work with the bounds.
18:52:55 <Philippa> for example, what if the ace is both 1 /and/ 11?
18:52:58 <dibblego> http://blog.tmorris.net/the-power-of-type-classes-with-scala-implicit-defs/ it was mostly about Scala, with a bit of Haskell
18:53:00 <lambdabot> Title:  Tony&#8217;s blog   Blog Archive  The Power of Type-classes with Scala im ..., http://tinyurl.com/2xpwvk
18:53:09 <Philippa> (then it's not an enumeration, duh)
18:53:24 <Pseudonym> instance Bounded Rank where
18:53:28 <Pseudonym>     minBound = Rank 1
18:53:33 <Pseudonym>     maxBound = Rank 13
18:53:41 <Pseudonym> And then implement an Enum instance to suit.
18:53:49 <Pseudonym> Just a thought.
18:53:53 <Pseudonym> Might be overkill for this application.
18:54:11 <KatieHuber> for Canfield I would want a different ordering, where the min and max bounds change at runtime :o
18:54:19 <Pseudonym> Yeah.
18:54:39 <Pseudonym> And 500 decks have 11's, 12's and red 13's.
18:54:48 <Pseudonym> (Exercise: Work out a typeclass for THAT.)
18:55:01 <Pseudonym> Sorry, set of types, not typeclass.
18:55:12 <Pseudonym> Where 13s can only be red.
18:55:20 <Philippa> KatieHuber: just don't worry about the typeclass and use your own functions, it works :-)
18:55:24 <Pseudonym> Yeah.
18:55:46 <LoganCapaldo> instance Bounded Card where minBound = unsafePerformIO $ ... :)
18:55:51 <Pseudonym> KatieHuber: You know you've done a good job when all of the comments are about stupid little things.
18:56:20 <KatieHuber> well, there's certainly lots of comments to take on board, but yeah, I'm glad there doesn't seem to be anything really major coming up :)
18:56:23 <sioraiocht> @src evalState
18:56:23 <lambdabot> Source not found. Do you think like you type?
18:56:34 <Pseudonym> The main things are:
18:56:35 <earnest> :)
18:56:38 <sioraiocht> @src Control.Monad.evalState
18:56:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:56:40 <earnest> That's mischievous. :)
18:56:40 <Pseudonym> 1. Do write type declarations.
18:56:42 <sioraiocht> @src Control.Monad.State.evalState
18:56:42 <lambdabot> Source not found. You speak an infinite deal of nothing
18:56:45 <sioraiocht> -_
18:56:48 <LoganCapaldo> @type evalState
18:56:50 <lambdabot> forall s a. State s a -> s -> a
18:56:54 <Pseudonym> Write them first, in fact.
18:56:57 <LoganCapaldo> snd . runState
18:57:04 <LoganCapaldo> @type runState
18:57:06 <lambdabot> forall s a. State s a -> s -> (a, s)
18:57:10 <Pseudonym> And 2. Lay out your let-bindings in a better way, possibly use where clauses instead.
18:57:15 <sioraiocht> ah, thanks
18:57:20 <LoganCapaldo> well not really snd . runState
18:57:24 <LoganCapaldo> I think you need mor edots
18:57:28 <LoganCapaldo> but you get the idea
18:57:32 <sioraiocht> that's the idea, though
18:57:42 <sioraiocht> you get the s portion of the transition tuple
18:57:58 <Pseudonym> Oh something that may help
18:58:04 <Pseudonym> You've used concat (map ...) in a few places.
18:58:12 <Pseudonym> :t concatMap
18:58:13 <sioraiocht> I'm totally remembering, now
18:58:14 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
18:58:15 <KatieHuber> oh yeah, there's a concatMap thingy
18:58:17 <sioraiocht> you know, I used to know these better
18:58:21 <sioraiocht> I wrote a brainfuck interpreter =p
18:58:21 <Pseudonym> But also... :t (>>=)
18:58:24 <Pseudonym> :t (>>=)
18:58:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:58:37 <Pseudonym> concat (map f xs) = xs >>= f
18:59:04 <Pseudonym> Or:
18:59:08 <KatieHuber> that's a bit weird...
18:59:08 <Pseudonym> :t (=<<)
18:59:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:59:14 <Pseudonym> Which is concatMap.
18:59:26 <Pseudonym> Yeah, it does look weird.  It's monad notation.
18:59:43 <Pseudonym> In fact, you might want to consider rewriting allMoves using monad notation.
18:59:46 <sioraiocht> it was only 90 lines, too
18:59:49 <sioraiocht> err, 80
18:59:56 <Pseudonym> Because you've basically written monadic code.
19:00:06 <KatieHuber> I don't really "get" monads :/
19:00:13 <Pseudonym> You would, here.
19:00:24 <Pseudonym> You've written monadic code right here, it just doesn't look like it.
19:00:30 <Pseudonym> Seriously.
19:00:30 <monochrom> you are on the verge of inventing monads yourself.
19:00:35 <Pseudonym> Yeah.
19:00:37 <KatieHuber> ^_^
19:00:46 <Pseudonym> If it helps, consider using list comprehensions first.
19:00:47 <LoganCapaldo> Welcome to #haskell
19:00:52 <allbery_b> @go you could have invented monads
19:00:54 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
19:00:54 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
19:00:55 <KatieHuber> and maybe if I could see it, I would understand monads :)
19:00:57 <LoganCapaldo> they keep making outrageous claims like this all the time :)
19:01:05 <monochrom> Are monads discovered or invented?
19:01:12 <Pseudonym> Here's an example.
19:01:17 <Pseudonym> if ok then [x] else []
19:01:25 <Pseudonym> That's a classic monad pattern.
19:01:29 <Pseudonym> It's called "guard".
19:01:30 <KatieHuber> presumably I could use a monad for the shuffling too
19:01:39 <Pseudonym> KatieHuber: Probably not in that case.
19:01:45 <KatieHuber> hmm
19:01:54 <Pseudonym> What you're doing in allMoves is writing nondeterministic code in the obvious way.
19:01:57 <allbery_b> those who do not understand monads are doomed to reinvent them?
19:02:08 <monochrom> yes
19:02:10 <Pseudonym> allbery: Those who reinvent monads are doomed to understand them.
19:02:18 <KatieHuber> I wish :|
19:02:33 <Pseudonym> You will, because we're going to make sure you do. :-)
19:02:34 <Philippa> they're one of those things that essentially 'click'
19:02:43 <monochrom> Those who invent monads are doomed to discover them. Also the re- version.
19:02:57 <Philippa> only it may take a while - but once you get it, the rest's easy
19:03:02 <Pseudonym> Yeah.
19:03:14 <Pseudonym> Look, as I said, you've basically written monadic code here already.
19:03:21 <Pseudonym> That's good, right?
19:03:39 <Pseudonym> Let's take one as an example.
19:04:02 <Pseudonym> Let's take one branch of allTableauMoves.
19:04:06 <Pseudonym> It has the basic structure:
19:04:12 <Pseudonym> allTableauMoves args
19:04:23 <Pseudonym>   = let stuff = ...
19:04:31 <Pseudonym>         ok = ...
19:04:43 <Pseudonym>     in if ok then [stuff] else []
19:04:48 <Pseudonym> Right?
19:04:52 <KatieHuber> mhmm
19:04:58 <Pseudonym> Now you could rewrite that last part as a list comprehension:
19:05:03 <Pseudonym>   = let stuff = ...
19:05:09 <Pseudonym>         ok = ...
19:05:14 <Pseudonym>     in [ stuff | ok ]
19:05:24 <KatieHuber> ok...
19:05:27 <Pseudonym> Note that this list comprehension doesn't have a generator.
19:05:33 <Pseudonym> You can do that. :-)
19:05:46 <Pseudonym> And, of course, you can inline "ok":
19:05:52 <Pseudonym>   = let stuff = ...
19:05:57 <ddarius> > [3 | True]
19:05:59 <lambdabot>  [3]
19:06:01 <ddarius> > [3 | False]
19:06:02 <Pseudonym>     in [ stuff | canMoveFrom ... ]
19:06:02 <lambdabot>  []
19:06:24 <Pseudonym> The only other thing you need to know is you can ALSO write this as:
19:06:29 <Pseudonym>   = let stuff = ...
19:06:33 <Pseudonym>     in do
19:06:40 <Pseudonym>         guard (canMoveFrom ...)
19:06:46 <Pseudonym>         return stuff
19:06:53 <Pseudonym> And now you're using monad notation.
19:07:03 <KatieHuber> :t guard
19:07:05 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
19:07:11 <Pseudonym> > guard True >> return 1
19:07:12 <lambdabot>   add an instance declaration for (Show (m t))
19:07:15 <Pseudonym> > guard True >> return 1 :: [Int]
19:07:17 <lambdabot>  [1]
19:07:21 <Pseudonym> > guard False >> return 1 :: [Int]
19:07:22 <lambdabot>  []
19:07:42 <Pseudonym> You can also move your lets inside:
19:07:44 <Pseudonym>   = do
19:07:49 <Pseudonym>         let stuff = ...
19:07:55 <Pseudonym>         guard (canMoveFrom ...)
19:07:58 <Pseudonym>         return stuff
19:08:02 <Pseudonym> And now you're FULLY monadic.
19:08:14 <KatieHuber> I still don't think I really understand what guard does
19:08:22 <KatieHuber> in imperative terms it's a bit like an early-out ?
19:08:22 <LoganCapaldo> @src guard
19:08:23 <lambdabot> guard True  =  return ()
19:08:23 <lambdabot> guard False =  mzero
19:08:31 <Pseudonym> You can think of that as being:
19:08:34 <LoganCapaldo> @src [] guard
19:08:34 <Pseudonym> guard True = [()]
19:08:35 <lambdabot> Source not found. Are you on drugs?
19:08:37 <Pseudonym> guard False = []
19:08:48 <ddarius> Which is exactly what it is for the [] monad...
19:09:14 <Pseudonym> And then you can think of the do-notation, or the >>, as this:
19:09:29 <Philippa> KatieHuber: yeah, it earlies out. In some monads it'll effectively "crash" (you'll get error), in some it does something you can work with
19:09:38 <Pseudonym> > concatMap (\_ -> [1]) (guard True)
19:09:40 <lambdabot>  [1]
19:09:41 <Pseudonym> > concatMap (\_ -> [1]) (guard False)
19:09:42 <lambdabot>  []
19:09:45 <Pseudonym> Right?
19:09:49 <LoganCapaldo> Maybe is a good one to explain guard in
19:09:52 <LoganCapaldo> I think
19:09:53 <Philippa> oh, wait, no, it uses mzero rather than fail. So it's always something you can work with :-)
19:10:02 <Pseudonym> Which is basically what the list comprehension expands to.
19:10:05 <Philippa> (or rather, if it's error then whoever wrote the instance needs a kicking)
19:10:29 <Pseudonym> (It's a bit more optimised than that nowadays, with stream fusion and foldr/build deforestation, but it's logically the concatMap thing.)
19:10:48 <hpaste>  Katie pasted "Monadic thingy" at http://hpaste.org/2657
19:11:12 <Pseudonym> No, you need the "do".
19:11:18 <Philippa> the do's there
19:11:22 <Philippa> you don't want the in though
19:11:24 <Pseudonym> Oh, yeah, I see it.
19:11:25 <Pseudonym> Sorry.
19:11:32 <Pseudonym> No, you don't want the in.
19:11:41 <Philippa> lets in dos are different
19:11:41 <Pseudonym> The "in" is implied in the do-notation.
19:11:44 <KatieHuber> works with or without the in
19:12:01 <Philippa> *thinks*
19:12:01 <Pseudonym> Even so, it's bad style, and sometimes it doesn't work.
19:12:05 <KatieHuber> OK, so I can see that this is equivalent
19:12:08 <Pseudonym> I don't think it works if you have a generator on the next line.
19:12:32 <Pseudonym> Cool.
19:12:44 <Pseudonym> By the way, I think the list comprehension notation is a bit sexier here.
19:12:46 <Philippa> it won't, no. It'll barf on the binding
19:12:50 <EvilTerran> > do let x = Just 1; y <- x; return y
19:12:51 <lambdabot>  Parse error
19:12:59 <EvilTerran> > do { let x = Just 1; y <- x; return y }
19:13:00 <lambdabot>  Parse error
19:13:04 <Pseudonym> BUT... this is a great opportonity to learn monads.
19:13:09 * EvilTerran blinks
19:13:16 <Pseudonym> Since you've basically already written monadic code.
19:13:18 <Philippa> EvilTerran: put braces after the let
19:13:27 <EvilTerran> > do let { x = Just 1 }; y <- x; return y
19:13:27 <monochrom> let {x=Just 1}
19:13:29 <lambdabot>  Just 1
19:13:31 <EvilTerran> aha.
19:13:35 <EvilTerran> > do let { x = Just 1 } in y <- x; return y
19:13:35 <lambdabot>  Parse error
19:13:46 <EvilTerran> there we go. that's the distinction i was trying to make.
19:13:52 <Pseudonym> Right.
19:14:11 <Pseudonym> KatieHuber: OK, now, generators.
19:14:36 <Pseudonym> allPileMoves b tn = concat (map f allPileNames)
19:14:51 <Pseudonym> You can write that in do-notation, too.
19:14:57 <Pseudonym> allPileMoves b tn = do
19:15:03 <Pseudonym>     p <- allPileNames
19:15:08 <Pseudonym>     f p
19:15:12 <ddarius> That because it parses as (let { x = Just 1 } in y)
19:15:32 <Pseudonym> Though in this case, I think the bind operator looks cooler:
19:15:38 <Pseudonym> allPileMoves b tn = allPileNames >>= f
19:15:44 <ddarius> And is what most experienced Haskellers would use
19:16:01 <Pseudonym> The two are equivalent, in fact the do-version compiles to the (>>=) version, modulo the application of a monad law.
19:16:12 <Philippa> mostly because there's no point in having p around as a name
19:16:16 <ddarius> @undo do p <- allPileNames; f p
19:16:17 <lambdabot> (allPileNames >>= \ p -> f p)
19:16:20 <Pseudonym> In list comprehension notation, you'd do this:
19:16:26 <Pseudonym> [ f p | p <- allPileNames ]
19:16:44 <ddarius> @. pl undo do p <- allPileNames; f p
19:16:45 <lambdabot> f =<< allPileNames
19:17:05 <Pseudonym> In fact, you can then inline allPileMoves inside allMoves.
19:17:27 <Pseudonym> allMoves b = do
19:17:50 <Pseudonym>     p@(Tableau _) <- allPileNames
19:18:10 <Pseudonym>     p2 <- allPileNames
19:18:18 <Pseudonym>     allTableayMoves b p p2
19:18:28 <Pseudonym> Pick better names than p and p2; perhaps "from" and "to".
19:18:40 <ddarius> The denizens of #haskell are excited by quick-witted new blood.
19:18:40 <Pseudonym> The at-pattern fails if it's a non-tableau pile.
19:18:48 <Pseudonym> And that's equivalent to the guard.
19:18:50 <EvilTerran> om nom nom
19:18:51 <KatieHuber> interesting
19:19:11 <Pseudonym> ddarius: You betcha.
19:19:28 <hpaste>  LoganCapaldo pasted "How guard works with Maybe" at http://hpaste.org/2658
19:21:45 <LoganCapaldo> Did I take too long to create that example? Does everyone already understand everything? :)
19:22:34 <KatieHuber> I'm still not sure I understand anything at all, perhaps least of all the example :p
19:22:45 <KatieHuber> I have different code than when I started, that still works...
19:23:47 <danderson> Is there a syntax to match several patterns in a single clause of a case block?
19:23:47 <ddarius> Your code was just a special instance of a more general scheme
19:23:53 <Pseudonym> Katie: I think that exactly this kind of nondeterminism-using-lists code that you've written is a great example of how monads arise naturally.
19:24:01 <ddarius> danderson: No, but you can use guards.
19:24:10 <ddarius> Indeed.
19:24:27 <Pseudonym> Smart programmers naturally write monadic code, even if they don't realise it.
19:24:39 <dibblego> @remember <Pseudonym> Smart programmers naturally write monadic code, even if they don't realise it.
19:24:39 <lambdabot> Done.
19:24:42 <danderson> ddarius: okay, I have no idea what that is yet, but I'll stow that answer and continue reading the book. Thanks.
19:25:03 <monochrom> dibblego: I think it works better if you remove < and >
19:25:21 <dibblego> oh, and I don't think there is @unremember either
19:25:32 <ddarius> There is @forget nown.
19:25:38 <Pseudonym> dibblego: Yes there is, but it's spelled ?message dons
19:25:41 <dibblego> @forget <Pseudonym> Smart programmers naturally write monadic code, even if they don't realise it.
19:25:41 <lambdabot> Done.
19:25:48 <hpaste>  Katie pasted "Newly monadic beleaguered castle move code" at http://hpaste.org/2659
19:25:51 <Pseudonym> ?quote naturally
19:25:52 <dibblego> @remember Pseudonym Smart programmers naturally write monadic code, even if they don't realise it.
19:25:52 <lambdabot> syntaxfree says: "You can't catch me / I'm syntax free / I'm preconceived / preternaturally"
19:25:53 <lambdabot> Done.
19:26:25 <KatieHuber> haskell looks really dense when you give stuff descriptive names :|
19:26:37 <Pseudonym> I was about to say.
19:26:39 <Pseudonym> Wordy, but nice.
19:26:53 <Pseudonym> You understand the at-pattern, right?
19:27:01 <KatieHuber> in allMoves?
19:27:04 <Pseudonym> Yeah.
19:27:13 <Pseudonym> Oh, you've used it elsewhere.
19:27:15 <KatieHuber> yeah, someone said it acts like guard if it doesn't match
19:27:17 <Pseudonym> So yes, I guess you do.
19:27:28 <KatieHuber> I've used @ elsewhere in normal function argument pattern matching
19:27:30 <Pseudonym> Just checling; that's something that trips some people up;
19:27:32 <Pseudonym> Right.
19:27:37 <Pseudonym> Bleah, karnt tipe.
19:27:52 <Pseudonym> I do find this a bit weird:
19:28:00 <Pseudonym> allTableauMoves bc fromTableauName toTableauName@(Tableau n)
19:28:11 <Pseudonym> An odd mix of verbosely descriptive and short names.
19:28:20 <KatieHuber> I replaced the n with an _ just now
19:28:33 <Pseudonym> Oh, now here's a thought.
19:28:39 <Pseudonym> The "bc" argument.
19:28:43 <Pseudonym> In allTableayMoves.
19:28:48 <Pseudonym> allTableauMoves
19:28:55 <Pseudonym> You only ever apply it to pileNamed.
19:28:58 <ddarius> Can't the two cases of allTableauMoves be combined into one?
19:29:09 <Pseudonym> So why not pass "pileNamed bc" instead?
19:29:36 <ddarius> Well, by abstracting out the canMove... part
19:29:55 <Pseudonym> ddarius: That's an idea.
19:30:04 <Pseudonym> Make a combined "canMove" test.
19:30:17 <KatieHuber> so a general canMoveFromPileToPile function?
19:30:20 <Pseudonym> Yeah.
19:30:50 <Pseudonym> That's a verbose name.  "validMove" works, too.
19:31:02 <KatieHuber> :)
19:31:11 <Philippa> KatieHuber: you're right it looks dense when you've got names - that said, it's dense partly because the names aren't all hugely verbose ones like you'd get in Java
19:31:39 <Pseudonym> static final protected flutzpah void whatDoYouMeanVerbose(Names)?
19:32:31 <ddarius> Pseudonym: (Names names) or is just C# that requires you to name the formal arguments of a declaration?
19:32:53 * ddarius 's Java minutae is rusty.
19:32:57 <Pseudonym> ddarius: Unsure.
19:33:01 <Pseudonym> My Jaba is also rusty.
19:33:04 <Pseudonym> Java
19:33:35 <KatieHuber> Java doesn't have separate declarations and definitions for functions; I believe all arguments must be named
19:33:38 <EvilTerran> Han, mah bukee, keel-ee caleya ku kah. Wanta dah moole-rah? Wonkee chee sa crispa con Greedo?
19:33:58 <dibblego> all arguments must be named and their type specified
19:33:59 <Pseudonym> Mi ne parolas Jaba-on.
19:34:30 <KatieHuber> OK, I'm feeling dense, but I'm not seeing how a validMove function can reduce the amount of code I have
19:34:47 <KatieHuber> (or even factor it better)
19:35:04 <Pseudonym> Because it would halve the code in allTableauMoves.
19:35:20 <Pseudonym> And in particular, it would cut out what is effectively duplicated code.
19:35:25 <ddarius> Well the suggestion I was intending is to just pass in canMove* to allTableauMoves
19:35:27 <KatieHuber> but it needs both the pile names and pile contents
19:35:34 <Pseudonym> Removing code duplication is a win, even if your line count increases slightly.
19:35:56 <KatieHuber> sure
19:36:12 <KatieHuber> ddarius: not sure what you mean by that
19:36:22 <Pseudonym> allTableauMoves bc from to = do
19:36:30 <Pseudonym>     let fromPile = pileNamed bc from
19:36:40 <Pseudonym>         toPile = pileNamed bc to
19:36:48 <Pseudonym>     guard (validMove fromPile toPile)
19:36:57 <Pseudonym>     return (Move (head fromPile) from to)
19:36:58 <Pseudonym> Right?
19:37:05 <KatieHuber> validMove can't tell from just fromPile and toPile whether it's OK
19:37:12 <KatieHuber> it needs from and to as well as fromPile and toPile
19:37:15 <Pseudonym> Oh, you need the... right.
19:37:20 <Pseudonym> OK, so how about this?
19:37:26 <Pseudonym> allTableauMoves bc from to = do
19:37:38 <Pseudonym>     guard (validMove bc from to)
19:37:54 <Pseudonym>     return (Move ...)
19:38:09 <Pseudonym> Not sure how you'd factor out the now possibly two calls to pileNamed.
19:38:21 <Pseudonym> And move the pile dereferencing into validMove.
19:38:57 <Pseudonym> Oh, I know!
19:39:22 <KatieHuber> return the approprate canMoveFrom..To.. from something
19:39:27 <Pseudonym> validMove bc from@(Foundation _) to = mzero
19:39:44 <Pseudonym> validMove bc from to@(Foundation _) = do
19:40:24 <Pseudonym> Sorry, can't thnk.
19:40:39 <Pseudonym> But let validMove return the card that moves.
19:41:01 <Pseudonym> Or call mzero (or fail, or whatever) if it's not a valid move.
19:41:10 <Pseudonym> So then allTableauMoves looks like this:
19:41:18 <Pseudonym> allTableauMoves bc from to = do
19:41:26 <Pseudonym>     card <- validMove from to
19:41:29 <Pseudonym>     return (Move card from to)
19:41:50 <hpaste>  Katie pasted "All the code again for clarity" at http://hpaste.org/2660
19:42:36 <KatieHuber> OK, I lost what you were saying in my eagerness for my own solution...
19:42:43 <LoganCapaldo> KatieHuber, you don't need to keep creating new pastes, you can just annotate the first one
19:43:01 <Pseudonym> Sure.  Just a moment, I'll modify this code.
19:43:43 <KatieHuber> LoganCapaldo: it seemed to want me to edit the content of the paste when I clicked the annotate button... I didn't understand what would happen
19:44:00 <LoganCapaldo> it depends on which annotate you click
19:44:22 <KatieHuber> I only have one, at the top of the page
19:44:24 <LoganCapaldo> if you click the annotate way at the top you get a blank window
19:44:33 <KatieHuber> oh, two at the top :/
19:44:42 <LoganCapaldo> if you click the one by the paste it gives you the content
19:44:43 <KatieHuber> so the toppest of the top annotates is the right one?
19:44:44 <allbery_b> there's an annotate at the very top and one at the top opf each existing paste
19:44:53 <allbery_b> yes
19:44:54 <LoganCapaldo> either way the annotation does get rid of the old stuff
19:45:04 <ddarius> That's pretty much what I was about to write.
19:45:11 <kpreid> LoganCapaldo: you mean doesn't?
19:45:15 <LoganCapaldo> yes
19:45:16 <EvilTerran> LoganCapaldo, "doesn't", surely?
19:45:16 <LoganCapaldo> typo
19:45:27 <LoganCapaldo> braino
19:45:30 <KatieHuber> I was confused there for a minute ^_^
19:46:52 <hpaste>  Pseudonym annotated "All the code again for clarity" with "(no title)" at http://hpaste.org/2660#a1
19:47:14 <Pseudonym> Maybe that's not an improvement.
19:47:22 <ddarius> Pseudonym: Your indentation got jacked.
19:47:28 <Pseudonym> Yeah, it did.
19:48:00 <hpaste>  Pseudonym annotated "All the code again for clarity" with "Let's try that again" at http://hpaste.org/2660#a2
19:48:37 <Pseudonym> BTW, this doesn't cover the case of an empty foundation.
19:48:43 <Pseudonym> Left as an exercise.
19:48:43 <KatieHuber> foundations can't be empty
19:48:47 <Pseudonym> Oh, right.
19:48:49 <KatieHuber> and moves can't originate from foundations
19:48:51 <KatieHuber> so that's OK :)
19:48:52 <Pseudonym> THey have the aces already there.
19:48:56 <KatieHuber> yup
19:49:41 <Pseudonym> Anyway, that's just a suggestion.
19:49:49 * Pseudonym used to be a logic programmer, too, so tends to think this way
19:50:00 <Pseudonym> There's no reason why you need to separate generators from tests.
19:50:39 <KatieHuber> if you don't mind, I like mine better :)
19:50:43 <Pseudonym> :-)
19:50:44 <fnord123> Is there a .deb for a hoogle to run from the cmd line? I quite enjoy using it but i would rather not bust out ye olde opera or irc to search on it
19:50:55 <Pseudonym> I do suggest using some currying here, though.
19:51:11 <Pseudonym> You pass "bc" around the all*Moves code, but you only ever apply it to pileNamed.
19:51:13 <hpaste>  ddarius annotated "All the code again for clarity" with "we love higher order functions" at http://hpaste.org/2660#a3
19:51:16 <Pseudonym> So why not do this instead:
19:51:24 <Pseudonym> allTableauMoves bc fromName toname = do
19:51:31 <Pseudonym>     let fromPile = bc fromName
19:51:34 <ricky_clarkson> fnord123: lambdabot is available as source, perhaps you can derive something from that (real answer: I have no idea).
19:51:43 <Pseudonym> And just pass call allMoves with a closure.
19:51:53 <Pseudonym> allMoves (pileNamed something) ...
19:52:13 <ddarius> KatieHuber: There is perhaps a better name than the firstCards in my annotation.
19:53:03 <sjanssen> fnord123: there is a command line utility
19:53:36 <fnord123> I found the source. I'll build it; but I'm an awful linux admin so installing it without a .deb will be awful. :(
19:54:37 <Pseudonym> Probably shouldn't call that argument "bc".
19:54:40 <Pseudonym> In retrospect.
19:54:46 <KatieHuber> yeah, confused me for a moment :p
19:54:53 <KatieHuber> I've called it "getPile" for now
19:58:50 <hpaste>  Katie annotated "All the code again for clarity" with "more suggestions implemented" at http://hpaste.org/2660#a4
19:59:12 <KatieHuber> er, wth, it's not even correct code, how'd that compile :|
19:59:45 <Philippa> heh
19:59:51 <Pseudonym> Katie: Because you didn't put in all your type declarations!
19:59:56 <Philippa> you know you're getting into haskell (but not an expert) when...
20:00:00 <KatieHuber> oh crap, it's 'cos I'm not loading the right files
20:00:49 <KatieHuber> OK, what do I need to import for guard :)
20:00:58 <Pseudonym> Control.Monad, IIRC
20:00:59 <Pseudonym> ?where guard
20:01:00 <lambdabot> I know nothing about guard.
20:01:02 <Pseudonym> ?src guard
20:01:02 <lambdabot> guard True  =  return ()
20:01:03 <ddarius> @index guard
20:01:03 <lambdabot> guard False =  mzero
20:01:03 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:01:06 <Pseudonym> That's it.
20:01:10 <Pseudonym> Control.Monad.
20:02:49 <ddarius> Incidentally, KatieHuber, you've got quite a few superfluous parens.  Application binds tighter than anything else, so the parens around the show's in showMove and in all your generic routines are unnecessary.
20:03:30 <ddarius> And I think concatNL is unlines
20:03:31 <KatieHuber> the C/Ruby/etc programmer in me finds that very weird :|
20:03:37 <Pseudonym> And as a little niggle, you've done some head/tailing where pattern matching would also work.
20:03:48 <Pseudonym> let (a,b) = splitAt i list in (a ++ tail b, head b, g)
20:03:59 <ddarius> > unlines ["foo","bar","baz"]
20:04:00 <lambdabot>  "foo\nbar\nbaz\n"
20:04:03 <Pseudonym> => let (as,b:bs) = splitAt i list in (as ++ bs, b, g)
20:04:28 <Pseudonym> Oh, that's one thing.
20:04:47 <Pseudonym> Declarative programmers often use "s" as a kind of Hungarian notation for lists.
20:04:48 <KatieHuber> currently I'm battling the fact that this monadification has changed the signature of allMoves
20:05:06 <Pseudonym> So a is a something, as is a list of a's, ass is a list of list of a's.
20:05:11 <KatieHuber> from BeleagueredCastle -> [Move] to MonadPlus a => BeleagueredCastle -> [a Move]
20:05:20 <Pseudonym> No chuckling from the peanut gallery, please.
20:05:32 <kpreid> if you have [a Move] then you're missing a mconcat somewhere
20:05:52 <kpreid> er
20:05:57 <kpreid> @type mconcat
20:05:59 <lambdabot> forall a. (Monoid a) => [a] -> a
20:06:04 <kpreid> @type msum
20:06:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
20:06:10 <kpreid> I meant, msum
20:06:24 <ddarius> Typically, m is used for the type variable for a monad.
20:06:39 <KatieHuber> I'm just quoting what hugs is saying to me ;)
20:06:47 <ddarius> Oi, hugs...
20:07:06 <kpreid> KatieHuber: if http://hpaste.org/2660#a4 is your latest, then: allMoves's last statement should not have a return
20:07:08 <KatieHuber> can't get ghc to build on this machine ( teach me for using unreleased OSes :p )
20:07:24 <KatieHuber> ah, much better, thanks
20:07:28 <sorear> There is nothing wrong with using Hugs.
20:07:28 <ddarius> KatieHuber is using SingularityOS!
20:07:36 <Pseudonym> I think we just had a volunteer to do the port...
20:07:37 <jekor> Does anyone know of a way/project for using Haskell to extend Emacs?
20:07:42 * ddarius does not like Hugs.
20:07:53 <ddarius> jekor: God no!
20:08:01 <Pseudonym> Which OS, as a matter of curiosity?
20:08:03 <jekor> Heh heh heh.
20:08:06 <KatieHuber> Leopard
20:08:11 <Pseudonym> Right.
20:08:17 <Pseudonym> It's good to know what OSes people want.
20:08:21 <KatieHuber> ( Mac OS X 10.5 Leopard for those not as maccentric as me :P )
20:08:36 <sorear> KatieHuber: uhm, Leopard has been released for many months now
20:08:37 <jekor> I find myself missing a lot of the prelude functions while writing elisp.
20:08:43 <KatieHuber> MacPorts works well for 10.4 Tiger, and quick hackery of the PortFile got me nowhere for Leopard, so I fell back on hugs
20:08:46 <allbery_b> sorear: er?
20:08:50 <jekor> What about some sort of project to create an FP (not pure, I suspect) library for elisp?
20:08:58 <sorear> allbery_b: well it made it to my school already...
20:09:14 <KatieHuber> there are betas, of which this is the latest available to registered developers
20:09:22 <KatieHuber> but the release is still officially "october"
20:09:35 <allbery_b> yeh, there are developer betas all over the place, but nothing officially *released*
20:12:00 <allbery_b> as tro editing portfiles, I've had little success there and I know what I'm doing for the most part.  (yug, why'd they have to use Tcl of all languages?)
20:13:02 <sioraiocht> ddarius: why the Hugs hate?
20:13:24 <sioraiocht> I havent' used it for years, but IIRC it's error messages were much clearer than GHCi's
20:13:43 <allbery_b> sometimes they are
20:14:06 <allbery_b> sometimes (at least ionce you understand them) ghc/i's are *much* more to the point
20:14:21 <sioraiocht> allbery_b: I could agree with that
20:14:56 <KatieHuber> OK, can we go back to what people were saying about using Enum and Bounded to simplify my definitions of Rank, Suit, ranks and suits earlier?
20:15:29 <ddarius> sioraiocht: In my opinion GHC does essentially everything better than Hugs.
20:15:30 <sioraiocht> data Suit = Hearts | Diamons | Clubs | Spades deriving (Enum) ?
20:15:35 <KatieHuber> somebody said something like [ Suit ] should be possible, but I'm not sure what I have to do to make that work
20:15:52 <KatieHuber> ( to get [ Hearts, Clubs, Diamonds, Spades ] )
20:16:02 <ddarius> :t range
20:16:03 <Pseudonym> KatieHuber:
20:16:11 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
20:16:13 <Pseudonym> data Suit = ... deriving (Enum,Bounded)
20:16:25 <Pseudonym> Then you can do this:
20:16:27 <Pseudonym> suits :: [Stui]
20:16:32 <Pseudonym> suits :: [Suit]
20:16:37 <Pseudonym> suits = [minBound..maxBound]
20:16:58 <ddarius> > let bools = [minBound..maxBound] in bools
20:16:58 <lambdabot>  Add a type signature
20:17:11 <Pseudonym> > [minBound..maxBound] :: [Boll]
20:17:11 <lambdabot>   Not in scope: type constructor or class `Boll'
20:17:14 <Pseudonym> > [minBound..maxBound] :: [Bool]
20:17:15 <lambdabot>  [False,True]
20:17:18 <Pseudonym> Like that.
20:17:22 <allbery_b> > let bools = [minBound::Bool,maxBound] in bools
20:17:23 <lambdabot>  [False,True]
20:17:52 <ddarius> [minBound..maxBound] :: [BollWeevil]
20:18:07 <Pseudonym> You can also do this with Rank.
20:18:22 <sioraiocht> *Main> [Clubs ..]
20:18:22 <Pseudonym> class Bounded Rank where
20:18:22 <sioraiocht> [Clubs,Diamonds,Hearts,Spades]
20:18:35 <Pseudonym>     minBound = (Rank 1)
20:18:43 <Pseudonym>     maxBound = Rank 13
20:18:46 <Pseudonym> Sorry, stray parens.
20:19:28 <Pseudonym> You can also then define an Enum instance that works with it:
20:19:33 <Pseudonym> instance Enum Rank where
20:19:37 <Pseudonym>     toEnum = Rank
20:19:44 <Pseudonym>     fromEnum (Rank n) = n
20:19:59 <KatieHuber> already have that (though not quite as elegantly stated)
20:20:03 <Pseudonym>     enumFrom r = map toEnum [fromEnum c .. fromEnum maxBound]
20:20:27 <Pseudonym>     enumFromThen r r' = map toEnum [fromEnum r, fromEnum r' .. fromEnum last]
20:20:44 <KatieHuber> whoa, I only have toEnum and fromEnum
20:20:44 <Pseudonym>         where last = if r' < r then minBound else maxBound
20:21:01 <Pseudonym> Yes, but by adding those two, you factor in the bounds.
20:21:24 <Pseudonym> [Rank 1..], in your scheme, would go past Rank 13.
20:21:29 <KatieHuber> the last two don't have default implementations?
20:21:35 <Pseudonym> yes, they do.
20:21:39 <Pseudonym> But they don't factor in bounds.
20:21:42 <KatieHuber> ah
20:22:04 <Pseudonym> We really should have some nice default implementations for this that you could bring in, but we don't AFAIK.
20:22:38 <ddarius> Pseudonym: Wouldn't they have to rely on the Enum being bounded?
20:22:43 <Pseudonym> Yes.
20:23:04 <Pseudonym> What I propose is enumFromBounded and enumFromThenBounded which you then just pull in:
20:23:09 <Pseudonym> instance Enum Rank where
20:23:13 <Pseudonym>     enumFrom = enumFromBounded
20:23:16 <Pseudonym> etc
20:26:10 <KatieHuber> I cant get your enumFromBounded to typecheck
20:26:26 <KatieHuber> don't understand why not...
20:27:37 <Pseudonym> I don't think I defined an enumFromBounded.
20:27:52 <KatieHuber> well, your implementation for Rank
20:27:59 <Pseudonym> Oh, right.
20:28:07 <KatieHuber> doesn't typecheck for Rank, doesn't typecheck when stated generically externally
20:28:15 <Pseudonym> Might need to put in an explicit type.
20:28:31 <Pseudonym> enumFrom r = map toEnum [fromEnum r .. fromEnum (maxBound :: Rank)]
20:28:32 <Pseudonym> Oh!
20:28:41 <Pseudonym> I just noticed that I put in a "c" instead of an "r".
20:28:52 <KatieHuber> yeah, I found that, didn't help though ;)
20:28:53 <Pseudonym> Could that be the problem?
20:29:36 <KatieHuber> nope :)
20:29:44 <KatieHuber> instance Enum Rank where
20:29:48 <KatieHuber> enumFrom r = map toEnum [ fromEnum r .. fromEnum maxBound::Rank ]
20:30:01 <KatieHuber> er, actually, that might work :|
20:30:05 <Pseudonym> Ah!
20:30:10 <KatieHuber> nope
20:30:13 <Pseudonym> Oh, duh.
20:30:19 <Pseudonym> Leave out the fromEnum.
20:30:22 <Pseudonym> Oh, hang on.
20:30:25 <Pseudonym> No, that's right.
20:30:25 <KatieHuber> ah
20:30:25 <Pseudonym> Hmm.
20:30:40 <Pseudonym> map toEnum [ fromEnum r .. fromEnum (maxBound :: Rank) ]
20:30:45 <Pseudonym> The parens are important.
20:31:02 <KatieHuber> oh, 'cos application binds tighter than ::
20:31:08 <KatieHuber> I'm still weirded by that :p
20:31:11 <Pseudonym> Yup.
20:31:21 <Pseudonym> That's what you get for using a functional language.
20:31:25 <Pseudonym> Functions are really, really important.
20:31:49 <KatieHuber> so, out of interest, how can I state enumFromBounded generically
20:32:01 <KatieHuber> given I need that explicit type declaration
20:33:12 <Pseudonym> You need a Glasgow extension.
20:33:25 <KatieHuber> OK, never mind then :)
20:33:33 <Pseudonym> enumFromBounded (r :: t) = map toEnum (fromEnum r .. fromEnum (maxBound :: t)]
20:33:42 <Pseudonym> Which works if you -fglasgow-exts
20:34:03 <Pseudonym> Note that you put the :: at the binding site of r.
20:34:17 <dibblego> ?type forAll
20:34:19 <Pseudonym> That's called a lexically scoped type variable.
20:34:19 <lambdabot> Not in scope: `forAll'
20:34:39 <sjanssen> Pseudonym: you're forgetting asTypeOf!
20:34:46 <Pseudonym> True.
20:34:50 <Pseudonym> ?type asTypeOf
20:34:52 <lambdabot> forall a. a -> a -> a
20:35:08 <Pseudonym> ?src asTypeOf
20:35:08 <lambdabot> asTypeOf = const
20:35:17 <Pseudonym> enumFromBounded (r :: t) = map toEnum (fromEnum r .. fromEnum (asTypeOf maxBound r)]
20:35:29 <Pseudonym> enumFromBounded r = map toEnum (fromEnum r .. fromEnum (asTypeOf maxBound r)]
20:35:32 <Pseudonym> That's it.
20:35:53 <Pseudonym> The type declaration on asTypeOf forces maxBound and r to have the same type.
20:37:23 <KatieHuber> nifty
20:37:44 <sjanssen> @src asTypeOf
20:37:45 <lambdabot> asTypeOf = const
20:38:09 <sjanssen> that skips the type signature, which is crucial: asTypeOf :: a -> a -> a
20:38:25 <sjanssen> ah, Pseudonym already covered this :)
20:38:31 <Pseudonym> Lunch.  BBS
20:38:55 <hpaste>  Katie annotated "All the code again for clarity" with "improved Enum and Bounded stuff" at http://hpaste.org/2660#a5
20:39:32 <ddarius> @quote melted
20:39:33 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
20:45:38 <KatieHuber> speak of the devil :p
20:54:12 <Pseudonym> OK, you really need to stick some type declarations in here.
20:54:15 <glguy> heh, you guys just used my quote?
20:55:29 <Pseudonym> This works: ranks = [ minBound::Rank .. maxBound ]
20:55:32 <Pseudonym> But this is better:
20:55:35 <Pseudonym> ranks :: [Rank]
20:55:41 <Pseudonym> ranks = [minBound..maxBound]
20:55:49 <glguy> [ minBound .. maxBound ] == [ minBound .. ]
20:55:55 <Pseudonym> Type declarations aren't for your health.  They're good engineering practice.
20:56:05 <Pseudonym> glguy: Well, yes, once you have the Bounded instance...
20:56:26 <Pseudonym> What would be cool is:
20:56:31 <glguy> Ignore me for now, that was just my inner drive to type something  Ithink
20:56:40 <Pseudonym> class (Enum t, Bounded t) => Range t where
20:56:52 <Pseudonym>     range :: [t]
20:56:59 <Pseudonym>     range = [minBound..maxBound]
20:57:22 <glguy> why would that need to be a class?
20:57:28 <Pseudonym> True.
20:57:31 <Pseudonym> Well...
20:57:47 <Pseudonym> OK, the only reason I can think of is to provide faster specialised instances.
20:57:59 <Pseudonym> Hmm.
20:58:12 <Pseudonym> Is there any situation where Range makes sense, but Enum or Bounded doesn't?
20:58:42 <Pseudonym> Yes, there is.
20:59:27 <Pseudonym> instance Range (a -> Bool) where
20:59:34 <Pseudonym>     range = [const False, const True]
20:59:41 <Pseudonym> "enum" doesn't make sense on that type.
20:59:59 <Pseudonym> Or Bounded, since Ord doesn't make sense.
21:00:24 <hpaste>  Katie annotated "All the code again for clarity" with "can now apply moves to get new states" at http://hpaste.org/2660#a6
21:00:38 <glguy> Pseudonym, doesn't something like this already exist in QuickCheck?
21:00:44 <Pseudonym> glguy: Almost certainly.
21:01:24 <Pseudonym> Woo!
21:01:29 <Pseudonym> f = map (:[]) a
21:01:40 <Pseudonym> I see you used the robot ninja monkey operator!
21:01:41 <KatieHuber> I thought there must be a better way to do that :)
21:02:11 <Pseudonym> > map return [1,2,3] :: [[Int]]
21:02:12 <lambdabot>  [[1],[2],[3]]
21:02:21 <Olathe> O-o
21:02:24 <Pseudonym> But we like the robot ninja monkey operator.
21:02:43 <KatieHuber> return looks saner :p
21:02:54 <Pseudonym> It's pronounced "box", BTW.
21:02:58 <Pseudonym> Because it puts objects in boxes.
21:03:03 <KatieHuber> but I understand what the ninja monkey does more easily ;)
21:04:14 <KatieHuber> I must be very close to having something that can tell me whether a game is winnable
21:04:45 <Pseudonym> OK, one small comment.
21:04:51 <Pseudonym> These guards:
21:04:55 <Pseudonym>    | something = ...
21:04:59 <Pseudonym>    | foo = ...
21:05:02 <Pseudonym>     | True = ...
21:05:05 <Pseudonym> That's correct.
21:05:06 <Pseudonym> However.
21:05:14 <Pseudonym> We usually spell "True" as "otherwise".
21:05:17 <Pseudonym> ?src otherwise
21:05:17 <lambdabot> otherwise = True
21:05:36 <Pseudonym> It's a bit of a hangover from Miranda, but it reads well.
21:05:51 <Pseudonym> More of a stylistic thing.
21:07:19 <KatieHuber> so there must be some nice monadic way to run a depth-first search over applyMove right :)
21:07:44 <Pseudonym> Absolutely.  The exact same way you ran it on allMoves.
21:07:49 <Philippa> yeah, use the list monad and take the head of the resulting list
21:08:12 <Philippa> (but do it by pattern-match so you can catch it if there isn't one!)
21:08:15 <Pseudonym> Having said that, though, presumably you're going to want to prune the search tree.
21:08:37 <Philippa> that, and you've got problems if it's really a graph
21:08:39 <KatieHuber> well, I guess the idea would be to implement winnable :: BeleagueredCastle -> Bool
21:08:51 <KatieHuber> and yes, it's a graph :/
21:08:58 <Pseudonym> Right.
21:09:04 <Pseudonym> So breadth-search first.
21:09:12 <Pseudonym> Or A* search.
21:09:26 <Philippa> that's still only semi-decidable
21:09:27 <ddarius> Tree monad ho!
21:09:38 <Pseudonym> Not if you keep "seen" states around.
21:09:55 <Pseudonym> Most reasonable implementations of BFS or A* search do that.
21:10:08 <Pseudonym> Unless you KNOW you won't need it.
21:11:07 <Philippa> sure. At that point you're back to not caring what the actual search is, mind
21:11:23 <Philippa> (at least, termination-wise)
21:13:13 <Pseudonym> BFS is pretty easy to implement if you have Data.Set and Data.Queue handy.
21:14:03 <Pseudonym> A* is a little trickier, since you need a priority queue.
21:14:25 <tehgeekmeister> what's a convenient way to find the source of functions in the prelude?
21:14:35 <ddarius> @src const
21:14:35 <lambdabot> const x _ = x
21:14:36 <Pseudonym> ?src head
21:14:36 <lambdabot> head (x:_) = x
21:14:36 <lambdabot> head []    = undefined
21:14:41 <Pseudonym> That's pretty convenient.
21:14:48 <dibblego> tehgeekmeister, there isn't one that I have found (incredibly annoying)
21:14:52 <dibblego> ?src dropWhile
21:14:53 <lambdabot> Source not found. My pet ferret can type better than you!
21:14:57 <dibblego> no it's not :)
21:15:03 <Pseudonym> Grrr.
21:15:13 <Pseudonym> Oh, well, check out the H98 report, I guess.
21:15:19 <Pseudonym> It's all there.
21:15:19 <Philippa> tehgeekmeister: there's a definition in the Haskell 98 Report, or you can download a copy of the libs which'll include the Prelude and other modules
21:15:22 <tehgeekmeister> that works, i suppose
21:15:50 <tehgeekmeister> it's unfun going thru all the uses of the function before i find the definition, however.
21:16:00 <tehgeekmeister> i'd prefer something more efficient
21:16:18 <tehgeekmeister> like, putting the function name into some utility, and getting the source in return.
21:19:51 <Pseudonym> Well, fix the ?src command. :-)
21:20:12 <Pseudonym> That's what it's supposed to be.
21:20:29 <Pseudonym> ?src ><
21:20:30 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:20:35 <Pseudonym> ?src (><)
21:20:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:21:12 <KatieHuber> I'm going to give this stuff a rest for now.  Thanks for the help all, particularly Pseudonym
21:21:28 <Pseudonym> You're particularly welcome.
21:27:16 <Pseudonym> @let minimumCreepyDatingAge n = (n `div` 2) + 7
21:27:21 <lambdabot> Defined.
21:27:28 <Pseudonym> See xkcd.com for details.
21:27:59 <glguy> > map minimumCreepyDatingAge [15,17..]
21:28:00 <lambdabot>  [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,...
21:28:53 <Pseudonym> > map (\n -> (n,minimumCreepyDatingAge n)) [15,17..]
21:28:55 <lambdabot>  [(15,14),(17,15),(19,16),(21,17),(23,18),(25,19),(27,20),(29,21),(31,22),(33...
21:29:01 * ddarius was working on that.
21:29:17 <Pseudonym> > map (id &&& minimumCreepyDatingAge) [15,17..]
21:29:19 <lambdabot>  [(15,14),(17,15),(19,16),(21,17),(23,18),(25,19),(27,20),(29,21),(31,22),(33...
21:29:21 <Pseudonym> Also works.
21:29:28 <glguy> (,) =<< f
21:29:52 <sjanssen> ooh, that's a neat one
21:29:56 <sjanssen> I'll have to remember that
21:30:32 <Pseudonym> That's actually a damn good rule of thumb.
21:30:34 <glguy> > ap (,) succ $ 1
21:30:35 <lambdabot>  (1,2)
21:30:46 <glguy> > (,) =<< succ $ 1
21:30:47 <lambdabot>  (2,1)
21:30:50 <Pseudonym> Nice.
21:31:03 <glguy> > succ >>= (,) $ 1
21:31:04 <lambdabot>  (2,1)
21:35:08 <tehgeekmeister> Pseudonym: but isn't the ?src command just for in here?
21:35:18 <Pseudonym> There's also a web-based lambdabot/
21:38:47 <tehgeekmeister> ?src concat
21:38:47 <lambdabot> concat = foldr (++) []
21:38:54 <tehgeekmeister> ooer, that works nicely enough.
21:38:56 <tehgeekmeister> for my needs.
21:39:13 <tehgeekmeister> ?src map
21:39:13 <lambdabot> map _ []     = []
21:39:13 <lambdabot> map f (x:xs) = f x : map f xs
21:39:18 <ddarius> @src concatMap
21:39:19 <lambdabot> concatMap f = foldr ((++) . f) []
21:39:34 <glguy> that one surprises me
21:39:51 <Pseudonym> It makes sense if you think foldr/build.
21:40:21 <Pseudonym> The outer layer is foldr, the inner layer is something that works with build.
21:40:27 <glguy> concat (map f xs) would fuse, wouldn't it?
21:40:42 <Pseudonym> I'm not sure.  I think it depends on f.
21:40:53 <Pseudonym> Remember, f returns a list.
21:41:33 <ddarius> It should always fuse.
21:41:54 <ddarius> As far as foldr/map or foldr/foldr is concerned.
21:42:04 <Pseudonym> Really?
21:42:25 <Pseudonym> I thought it would be tricky unless you did some tricky inlining to map.
21:42:37 <ddarius> It's a perfect case of the foldr/map rule.
21:42:45 <Pseudonym> OK, I guess.
21:42:58 <tehgeekmeister> ?src liftM2
21:43:00 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:45:59 <Olathe> Do I have to do anything special to turn on deforestation in GHC ?
21:46:33 <Pseudonym> -O, probably
21:46:54 <Olathe> Alright, thanks.
21:48:17 <sjanssen> Olathe: use -ddump-simpl-stats if you want to make sure the deforestation rules are firing
21:48:43 <sjanssen> see whether they're firing, rather
21:48:48 <mudge> what's the link to the haskell cafe mailing list website?
21:49:13 <mudge> @where haskell-cafe
21:49:14 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
21:50:10 <Pseudonym> BBS
21:54:36 <jsnx> it would be cool if ghci output all the errors, prompts and banner stuff to stderr
21:54:42 <tehgeekmeister> okay, i've tried on my own, anyone want to help a n00b understand this: http://www.haskell.org/all_about_monads/examples/example7.hs
21:57:30 <mdmkolbe> what is a simple way to calculate the progressive sum of a list? e.g. [1, 2, 3, 4] -> [1, 1+2, 1+2+3, 1+2+3+4]
21:58:16 <dibblego> ?type sum
21:58:18 <lambdabot> forall a. (Num a) => [a] -> a
21:58:25 <dibblego> sum [1, 2, 3, 4]
21:58:27 <dibblego> > sum [1, 2, 3, 4]
21:58:28 <lambdabot>  10
21:58:37 <samreid_> :t scanl (+) 0
21:58:39 <lambdabot> forall a. (Num a) => [a] -> [a]
21:58:46 <mdmkolbe> @type scanl
21:58:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:58:50 <mdmkolbe> @index scanl
21:58:50 <lambdabot> Data.List, Prelude
21:59:08 <mdmkolbe> > scanl (+) 0 [1, 2, 3, 4]
21:59:10 <lambdabot>  [0,1,3,6,10]
21:59:16 <mdmkolbe> perfect
21:59:21 <mdmkolbe> thx samreid
21:59:51 <samreid> > scanl1 (+) [1..4]
21:59:52 <lambdabot>  [1,3,6,10]
21:59:54 <samreid> or maybet hat
22:02:14 <dibblego> n * (n - 1) `div` 2
22:02:44 <mdmkolbe> dibblego: my list isn't actually [1..], it's a bit more complicated and ad-hoc
22:02:50 * mdmkolbe shakes fist at DEFLATE
22:03:01 <dibblego> mdmkolbe, yeah sorry; I saw that on second glance
22:03:13 <dibblego> mdmkolbe, they are called triangular numbers
22:03:32 <studentneedshelp> hey everyone, I'm a student just learning Haskell and I really need some help with an assignment, does anyone maybe have some free time to help me? I'd really appreciate it!
22:05:05 <studentneedshelp> no one?:(
22:05:13 <dibblego> studentneedshelp, just ask away
22:05:20 <studentneedshelp> awesome!
22:06:09 <mdmkolbe> studentneedshelp: (1) we'll help you understand haskell, but we wont do your homework for you.  (2) don't ask to ask, just ask (general IRC rule), (3) dispite 2, saying that you are a student up front is good so we know you aren't trying to trick us (we have mind reading powers ;-) )
22:06:11 <studentneedshelp> this may seem like a really stupid easy assignment, but I've never used haskell and just struggling.. I'm using Hugs compiler, and basically one part of this assignment is that I need to check if all the characters in a string are the same or not
22:06:38 <studentneedshelp> basically my problem is I don't understand how to break a string up and compare parts of it to others
22:06:51 <mdmkolbe> @src String
22:06:51 <lambdabot> type String = [Char]
22:07:15 <mdmkolbe> studentneedshelp: does that give you a clue?
22:07:49 <studentneedshelp> yeah, let me play with it a bit, thanks mdmkolbe
22:14:35 <mdmkolbe> what channel should I ask a question about the DEFLATE spec?  I think I found a bug in the spec
22:15:15 <mdmkolbe> (Well probably not a bug, but something *really* strange that I want to find a justification for)
22:17:16 <studentneedshelp> ok, so I'm breaking up the String by doing func (x:y) = case y of    .... then when I try to check the case if y == x (to see if the two characters match) it is saying error
22:17:38 <dibblego> studentneedshelp, because y is a String and x is a Char
22:18:30 <conal> does anyone here know how the haskell wiki knows about some types & functions and makes links to their docs?  i'd like to get Monoid added.
22:18:54 <goalieca> studentneedshelp: print out y ;)
22:19:38 <tally> yuck, sorry got disconnected (this is studentneedshelp with a much less intense name)
22:19:48 <dibblego> tally, because y is a String and x is a Char
22:22:06 <mdmkolbe> hmm, tally needs a new network
22:29:33 <tally> I'm sorry my connection is not very good, not sure if my last line sent through.  I was trying something along the lines of x == car(y) -> True
22:29:50 <mdmkolbe> tally: it wasn't sent through
22:30:23 <mdmkolbe> @src head
22:30:23 <lambdabot> head (x:_) = x
22:30:23 <lambdabot> head []    = undefined
22:30:37 <mdmkolbe> tally: FYI, head == car
22:31:34 <mdmkolbe> tally: is this error a type check error or a run-time error?
22:32:05 <tally> when I try to compile using 'hugs allone.hs' it throws the error at me
22:32:15 * hgolden is away: sleep
22:32:39 <mdmkolbe> tally: could you paste the code to hpaste.org
22:32:42 <mdmkolbe> @hpaste
22:32:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:34:23 <hpaste>  tally pasted "tally's post" at http://hpaste.org/2664
22:34:41 <tally> that's nifty
22:35:41 <mdmkolbe> tally: you can't place arbitrary expressions on the left of a "->".  You can only place patterns there.
22:36:06 <mdmkolbe> tally: just out of curriosity, what grade are you in?
22:36:24 <tally> this is rather embarrassing, I'm a junior :p
22:36:36 <mdmkolbe> tally: college?
22:36:47 <tally> yes...
22:36:54 <elliottt> hah, me too :)
22:37:23 <tally> I feel like I'm in 5th grade for my lack of understanding :p
22:37:30 <Figs> I think you guys will be either very happy with me, or very very frustrated ...
22:37:32 <mdmkolbe> tally: that is a fairly typical age to learn Haskell.  (given that learning haskell is so untypical)
22:37:45 <sorear> Some much younger, some much older
22:38:29 <Figs> is there a proper term for actions that are reverseable?
22:38:42 <elliottt> comonads? :)
22:39:04 <mdmkolbe> tally: I think I see your background in other languages influencing your haskell.  Let me guess.  You're using scheme as the closest approximation to haskell and in your mind you equate "case" with "cond".
22:39:18 <tally> yeah... that's no good?
22:39:35 <mdmkolbe> tally: "case" is closer to scheme's "match" or "pmatch" if you've ever seen one of those
22:39:36 <elliottt> tally: are you trying to see if every element in a list is the same?
22:39:54 <tally> never heard of match of pmatch, yeah elliottt
22:39:58 <tally> or*
22:40:00 <Figs> comonads?
22:40:04 <dibblego> tally, that's a very common feeling by the way
22:40:21 <elliottt> Figs: do you mean m a -> a, or just some way to undo some sort of application?
22:40:24 <tally> thank you dibblego
22:40:41 <Figs> I meant in general, not in any specific language
22:40:59 <dibblego> Figs, comonads are not language-specific
22:41:10 <mdmkolbe> tally: match and pmatch are a bit rare for people to see.  Anyway, the left hand of "->" is not a boolean expression.  It is a pattern just like the argument to a function are a pattern.
22:41:14 <elliottt> still, i'm not sure it's the right idea...
22:41:54 <Figs> I'm just trying to figure out how to explain these weird ideas I've been thinking up :P
22:42:12 <elliottt> tally: allone xs = all (== (head xs)) xs
22:42:27 <mdmkolbe> tally: (If you've learned about pattern guards on functions (with "|" syntax), they can also be used in "case".  If you haven't learned about guards, then don't worry about it yet.)
22:42:32 <Figs> btw, my previous comment was @ elliottt (on the m a-> a thing which I don't know what that means)
22:42:46 <mdmkolbe> elliottt: this is for a homework, so just giving the answer doesn't help much
22:42:55 <elliottt> argh. sorry
22:43:06 <elliottt> should have read back through history
22:43:09 <tally> I haven't learned guards yet, even that answer I don't understand
22:43:53 <dibblego> tally, a guard is an additional expression (decision problem/Bool) on a pattern matching expression
22:44:26 <dibblego> > let fib 0 = 1; fib 1 = 1; fib n | n > 1 = fib (n - 1) (n - 2) in fib 5 -- the | n > 1 is a guard
22:44:34 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t
22:44:34 <lambdabot>     Probab...
22:44:44 <dibblego> > let fib 0 = 1; fib 1 = 1; fib n | n > 1 = fib (n - 1) + fib (n - 2) in fib 5 -- the | n > 1 is a guard
22:44:46 <mdmkolbe> tally: do you know what patterns are? (you probably do but not by that name)
22:44:46 <lambdabot>  8
22:44:58 <Tac-Tics> @let gcd a b | a == b = a | a > b = gcd (a - b) b | a < b = gcd a (b-a)
22:44:59 <lambdabot> <local>:10:31:     Ambiguous occurrence `gcd'     It could refer to either `g...
22:45:04 <Tac-Tics> gah
22:45:21 <Tac-Tics> @let gcd2 a b | a == b = a | a > b = gcd (a - b) b | a < b = gcd a (b-a)
22:45:23 <tally> I think I do
22:45:25 <lambdabot> Defined.
22:45:29 <Tac-Tics> >gcd2 5 5
22:45:41 <Tac-Tics> > gcd2 5 5
22:45:46 <lambdabot>  5
22:45:48 <Tac-Tics> lambda bot is such a hater
22:45:53 <tally> I understand what you mean by having only patterns on the left of -> , but then I don't understand when I do x -> True , my program will always send True at me
22:45:54 <int-e> @let gcd2 a b | a == b = a | a > b = gcd2  (a - b) b | a < b = gcd2 a (b-a)
22:45:55 <Tac-Tics> > gcd 2 200000000
22:45:59 <lambdabot> Defined.
22:45:59 <lambdabot>  2
22:46:26 <Tac-Tics> "x" used as a pattern will match *anything*
22:46:32 <Figs> > gcd2 5 11
22:46:33 <mdmkolbe> tally: the inner 'x' shadows the outer 'x'.  It is a new binding.
22:46:34 <lambdabot>  1
22:46:43 <tally> mdmkolbe: I'm not sure what you mean by that
22:47:29 <tally> mdmkolbe: the variables don't point to the same thing? (or is this where I'm thinking too much in another language?)
22:48:21 <mdmkolbe> "allone (x:y) = case y of x -> True" is the same as "allone (x:y) = case y of z -> True".  The "x" in the argument has nothing to do with the "x" in the case-pattern.
22:48:22 <Figs> I think I'll bbl
22:48:40 <Tac-Tics> what do you want allone to do?
22:49:16 <mdmkolbe> Tac-Tics: test that all the chars in a string are the same.  it is for a homework.
22:49:22 <Tac-Tics> ah
22:49:54 <int-e> > let allSame xs = and (zipWith (==) xs (drop 1 xs)) in map allSame ["", "aaa", "aab"]
22:49:56 <tally> then am I completely off base by using a case statement?
22:49:57 <lambdabot>  [True,True,False]
22:50:18 <int-e> tally: yeah
22:50:30 <Tac-Tics> the "allone tail(_:t)" on the last line will probably prevent it from compiling at all
22:50:36 <mdmkolbe> tally: you technically could use 'case', but yeah.  I wouldn't use it in this case
22:50:36 <int-e> tally: you need to use == to compare things. (or another binary predicate.)
22:50:54 <mdmkolbe> tally: try "head", and "if ... then ... else ..."
22:51:19 <tally> k, afk to try things out, thanks everyone for helping
22:51:31 <elliottt> sorry again for helping too much :(
22:51:49 <tally> never such a thing!:p
22:52:21 <glguy> if I play a word in scrable that *isn't* spelled correctly
22:52:24 <glguy> but no one calls me on it
22:52:32 <glguy> is it wrong to challenge the person that try to pluralize it?
22:52:42 <int-e> > let allSame xs = and [x /= y | x:y:xs <- tails xs] in map allSame ["", "aaa", "aab"]
22:52:44 <lambdabot>  [True,False,False]
22:52:55 <int-e> > let allSame xs = and [x == y | x:y:xs <- tails xs] in map allSame ["", "aaa", "aab"]
22:52:57 <lambdabot>  [True,True,False]
22:53:07 <mdmkolbe> int-e: you realize this was a homework problem, right?
22:53:15 <int-e> not really
22:53:25 <int-e> sorry.
22:53:37 <elliottt> glguy: pluralize the misspelling?
22:54:01 <glguy> yeah
22:54:05 <glguy> I wrote: BAILIF
22:54:08 <glguy> missing the final f
22:54:11 <glguy> no one saw it
22:54:15 <glguy> wife tried adding 's'
22:54:19 <glguy> *challenge* :)
22:54:46 <tally> just tell her to that it changes to 'v'
22:56:06 <tally> is there any documentation regarding ifs, thens, elses for haskell that is easily available?
22:56:42 <Tac-Tics> if-then-else in haskell is pretty basic, but unlike in most languages, you don't end up using it a lot
22:56:42 <elliottt> http://www.haskell.org/haskellwiki/Keywords#if.2C_then.2C_else
22:56:43 <lambdabot> Title: Keywords - HaskellWiki
22:56:43 <elliottt> that may help
22:56:57 <Tac-Tics> If you use more than one if-then-else in a function, you're probably doing something wrong
22:57:09 <Tac-Tics> you should try to use guards and piece-wise definitions instead whenever possible
22:59:02 <mdmkolbe> FYI, I've been a teacher's assistent and a beginer student submitting an advanced solution like the ones that elliottt and int-e gave would probably be caught.  Writing code has a voice and style just as much as writing prose, so it is easy to recognize the author (especially among begining students).  (I don't want to scare anyone. I just want to make sure there is no temptation to cheat.)
22:59:34 <elliottt> mdmkolbe: thank goodness.  i've been feeling bad about that :)
22:59:54 <mdmkolbe> Tac-Tics: yes, but only once you've learned about guards (which tally hasn't)
23:00:43 <tally> this syntax is eluding me
23:00:46 <hpaste>  tally pasted "syntax wrong?" at http://hpaste.org/2665
23:01:27 <hpaste>  mdmkolbe annotated "syntax wrong?" with "missing "="" at http://hpaste.org/2665#a1
23:01:50 <lament> mdmkolbe: heh. I have heard of people wrongly accused of cheating (and unable to defend themselves) because the teacher thought their work was "too good"
23:02:36 <elliottt> oh goodness
23:02:40 <elliottt> that's a horrible situation to be put in
23:02:55 <tally> heh, I've nothing to worry about with that situation!
23:03:04 <Tac-Tics> I once got accused of cheating on a 100-level Philosophy class test because I knew what Godel's Incompleteness Theorem was..... but I still got a B on the damn test!
23:03:31 <tally> ERROR "allone.hs":2 - Illegal `_' in expression
23:03:34 <mdmkolbe> elliottt, lament: in that case, a good teacher will use one of the back up cheat catching methods (e.g. "explain what this part does", "solve this similer problem infront of me, live")
23:04:07 <Pseudonym> Tac-Tics: Did you take the Goedel number of your soul?
23:04:40 <Pseudonym> This reminds me of the old Woody Allen joke about the time he was caught cheating on his metaphysics exam.  He looked into the soul of the person next to him.
23:04:41 <mdmkolbe> tally: "_" is only legal in a pattern.  (car x) <=> head x; (cdr x) <=> tail x
23:04:54 <lament> heh, i remember my spanish teacher doing that with a guy who clearly was cheating. He used the subjunctive in "his" composition, and had no idea what it was when she asked him to explain it.
23:05:18 <tally> ah
23:05:58 <glguy> I caught kids cheating on a freshman level programming course, barely only changed the variable names
23:06:13 <glguy> I wrote zero on one, and "see so and so for your grade" on the other
23:06:27 <elliottt> hahaha
23:06:52 <Pseudonym> When two projects make identical bugs, that's a huge giveaway.
23:07:39 <mdmkolbe> glguy: even when they change the variables, it is often obvious.  Even figuring out which was the original (with changed variable names) is easier than most students think.
23:08:45 <lament> yes, the one with foo, bar is the original, and foo1, bar1 is a copy :)
23:09:15 <elliottt> i just can't see why you would cheat on a programming assignment...
23:09:42 <mdmkolbe> lament: heh
23:09:52 <pejo> We shouldn't forget that the vast majority of students aren't trying to cheat.
23:10:01 <lament> obviously the solution is to write a smart code mangler to rearrange statements, change variable names, substitute expressions with equivalent ones, so the cheating is impossible to detect
23:10:09 <lament> written in haskell, of course
23:10:18 <Tac-Tics> heh
23:10:51 <Tac-Tics> pejo: they're not trying to cheat. They're trying to finish the ridiculous homework assignments
23:10:54 <Tac-Tics> ;-)
23:11:15 <Tac-Tics> cheating is like the check&balance to a bad professor
23:11:37 <elliottt> Tac-Tics: good point.  i can't remember how many stack of trees of queues i had to implement in the early classes
23:11:43 <lament> true, but the presence of TAs changes the picture
23:11:58 <mdmkolbe> lament: I'm not sure even that would work.  Keep in mind that we (teachers) understand code at a much deeper level when the students trying to cheat only see the surfance levels of the code.  Changing the surface level doesn't affect the deeper levels very much.
23:12:26 <hpaste>  tally annotated "syntax wrong?" with "I think I getting somehwere" at http://hpaste.org/2665#a2
23:12:28 <Tac-Tics> heh, ah, so many fond memories of helping my friends figure out where their pointer errors were
23:12:44 <lament> mdmkolbe: the code mangler could compile the program into brainfuck and back, that's sure to change it on deeper levels too ;)
23:12:53 <Tac-Tics> tally: how can it ever be True? ^^
23:12:59 <Tac-Tics> tally: you have no True base case
23:13:00 <tally> I was just about to ask that!
23:13:39 <tally> I need some sort of base case to make it true?
23:13:48 <Tac-Tics> tally: also, haskell convention says that when you pattern match with (:), you should use the suffix -s for the tail. Eg: (x:xs).
23:13:50 <mdmkolbe> lambdabot: by then your uber obsucated code would get you a zero anyway and if it worked, then I would know you rand it through an obfuscator
23:13:52 <Tac-Tics> yes
23:14:28 <mdmkolbe> s/rand/ran/
23:14:30 <lament> hmph! i'm perfectly capable of writing obfuscated code by hand.
23:14:47 <elliottt> that's a good quote :)
23:14:54 <Tac-Tics> tally: do you know about piece-wise function definitions?
23:15:02 <mdmkolbe> lament: Prof says, "show me! live!"
23:15:38 <tally> Tac-Tics: no
23:15:42 <mdmkolbe> @quote lament hmph! i'm perfectly capable of writing obfuscated code by hand.
23:15:42 <lambdabot> No quotes match. My mind is going. I can feel it.
23:15:59 <mdmkolbe> @remember lament hmph! i'm perfectly capable of writing obfuscated code by hand.
23:15:59 <lambdabot> Done.
23:16:39 <mdmkolbe> tally: have you seen factorial written like "fac 0 = ...; fac n = ..."?  If you have, that is a peice wise function.
23:17:05 <Tac-Tics> @src length
23:17:05 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:17:11 <Tac-Tics> grr lambdabot!
23:17:12 <tally> yeah
23:17:18 <mdmkolbe> @index length
23:17:18 <lambdabot> Data.List, Prelude
23:17:23 <mdmkolbe> @src Data.List.length
23:17:23 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:17:24 <Tac-Tics> length [] = 0; length (x:xs) = 1 + length xs
23:17:43 <lament> damn, my coolest obfuscated code effort is lost somewhere
23:17:43 <Tac-Tics> that is also a very simple piecewise function
23:17:44 <mlesniak> Tac-Tics, you're the backup-lambdabot?
23:18:05 <Tac-Tics> mlesniak: I sometimes cover for him when he gets sick
23:18:12 * lament tries the wayback machine
23:18:29 <Tac-Tics> tally: it might help to think of it like this: what *are* your base cases?
23:18:59 <tally> base cases would be: empty string or a string with just one character?
23:19:08 <Tac-Tics> what is allOne of an empty list? allOne of a list with one element? with two?
23:19:12 <mdmkolbe> tally: empty string
23:19:13 <Tac-Tics> yes
23:19:19 <Tac-Tics> hehe yeah
23:19:48 <Tac-Tics> strings, lists, it's all the same in Haskell
23:19:55 <mdmkolbe> @src []
23:19:56 <lambdabot> data [] a = [] | a : [a]
23:20:07 <Tac-Tics> @src String
23:20:07 <lambdabot> type String = [Char]
23:20:23 <Tac-Tics> allOne "" = ?
23:20:45 <tally> allOne "" = True
23:20:57 <Tac-Tics> what about with one character?
23:21:18 <tally> I'm not sure how to ... check that
23:21:43 <Tac-Tics> 0 and 1 characters are sort of trivial. Like the sum or product of an empty list
23:21:47 <Tac-Tics> > sum []
23:21:49 <lambdabot>  0
23:21:50 <Tac-Tics> > product []
23:21:52 <lambdabot>  1
23:22:02 <Tac-Tics> allOne is interesting when you have 2+
23:22:14 <tally> ok
23:22:21 <Tac-Tics> so what's allOne of [x, y]?
23:22:40 <tally> False
23:22:52 <Tac-Tics> what if x = 'a' and y = 'b'?
23:23:05 <Tac-Tics> or what if x = 'a' and y = 'a'
23:23:38 <tally> ok, that would be true
23:23:49 <Tac-Tics> so in general, allOne [x, y] = ?
23:24:37 <tally> we're not sure unless we check if x == y
23:24:44 <Tac-Tics> exactly
23:24:53 <Tac-Tics> allOne [x, y] is the same as x == y
23:25:40 <glguy> so is the point to get tally to stumble into the answer, and not to golf this one?
23:25:56 <mdmkolbe> glguy: yes
23:25:57 <Tac-Tics> golf?
23:26:18 <mdmkolbe> golf == fewest key strokes to the solution (popular in Perl circles)
23:26:19 <glguy> closest to the hole
23:26:28 <glguy> popular in #haskell circles :-p
23:26:47 <elliottt> http://codegolf.com/
23:26:50 <lambdabot> Title: Code Golf | Home
23:27:18 <tally> ok, I think I'm getting there
23:27:52 <Tac-Tics> glguy: stumbling around completely in the dark isn't all that fun
23:28:01 <Tac-Tics> but I'm not giving the answer away either
23:28:15 <glguy> Tac-Tics, it looked like he was working with someone though
23:28:48 <int-e> @where partitionM
23:28:48 <lambdabot> I know nothing about partitionm.
23:28:56 <int-e> @index partitionM
23:28:56 <lambdabot> bzzt
23:29:22 <mdmkolbe> tally: in scheme you would have two write something like (lambda (x) (cond ((null? x) ...) (else ...))).  But in haskell you can write "foo [] = ...; foo [1,2] = ...; foo [1,_] = ...; foo x = ..." (where ';' gets replaced by line breaks) and it forms one function that will test each pattern and use the first one that matches.
23:29:44 <mdmkolbe> glguy: I don't mind.  It's 2:30 AM here and I'm about to go to bed anyway
23:30:38 <tally> all the help I can get is appreciated
23:30:48 <glguy> tally, you need help or answers?
23:30:55 <tally> help
23:31:19 <glguy> so what do you have so far?
23:31:30 <mdmkolbe> glguy: http://hpaste.org/2665#a2
23:31:35 <tally> lol I've come far:p
23:32:05 <tally> I got it!:)
23:32:28 <hpaste>  tally annotated "syntax wrong?" with "you guys rock" at http://hpaste.org/2665#a3
23:32:36 <glguy> tally
23:32:47 <glguy> tally,   if a then b else False    is   a && b
23:32:57 <Esteth> How do you provide multiple arguments to a function if the arguments are in brackets? the YAHT tutorial seems to skip over this.
23:33:18 <tally> glguy, not sure what you mean
23:33:32 <Tac-Tics> heh, this brings me back fuzzy memories of TAing
23:33:44 <glguy> tally, don't use head and tail
23:33:47 <scook0_> Esteth: what do you mean by "the arguments are in brackets"?
23:33:52 <glguy> tally, fix your pattern
23:33:58 <glguy> (x:y:z)
23:34:15 <hpaste>  mdmkolbe annotated "syntax wrong?" with "just formatting" at http://hpaste.org/2665#a4
23:34:15 <tally> k, one sec
23:34:17 <Tac-Tics> also, if <bool> then True else False     is the same is just <bool> by itself
23:34:25 <glguy> tally, don't write: head(xs), write head xs
23:34:48 <Tac-Tics> and (head(xs):tail(xs)) is the same as just plain old "xs"
23:35:05 <glguy> tally, and then: if x == head xs then allone xs else False
23:35:12 <glguy> is x == head xs && allone xs
23:35:24 <Esteth> scook0_: Like when i say fst( lst ((1, 'a'), (2, 'b')) ), i put fst's arguments in brackets because otherwise haskell thinks i want to use fst on a function instead of the result of that function.
23:35:31 <mdmkolbe> tally: heh, once you write working code #haskell is very eager to provide style tips ;-)
23:35:53 <tally> k, working on everything you guys just told me
23:36:04 <Tac-Tics> Haskell is 50% style and 60% research... and -10% code bloat
23:36:14 <elliottt> haha
23:36:20 <elliottt> that's two good ones today
23:36:21 <mlesniak> :D
23:36:33 <elliottt> @remember Tac-Tics Haskell is 50% style and 60% research... and -10% code bloat
23:36:34 <lambdabot> Done.
23:36:34 <scook0_> Esteth: you might typically write func (g x) (h y)
23:36:53 <scook0_> the two arguments to func are g-applied-to-x and h-applied-to-y
23:37:11 <glguy> tally, your case for: [x,y] is unnecessary
23:37:24 <Esteth> scook0_: thanks, that's what i was looking for :)
23:37:33 <glguy> tally, once you fix the case below it
23:37:45 <tally> with ... (x:xs:xss) ?
23:37:47 <cizra> @where yaht
23:37:47 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
23:37:52 <cizra> lambdabot: thanks
23:38:09 <glguy> tally, yeah, you only need two cases
23:38:22 <scook0_> Esteth: though you don't need the parens if the argument is just a simple term
23:38:49 <Tac-Tics> glgluy: you need the allone [x] case too, or else you get an error on "head []"
23:38:49 <scook0_> e.g. func (g h) (y) is just func (g h) y, etc.
23:39:03 <mdmkolbe> glguy: tally needs three cases the way they are written.  getting it down to to cases requires a trick that tally may not know yet
23:39:06 <Esteth> scook0_: ok, thanks :)
23:39:20 <mdmkolbe> s/to to/to two/
23:39:20 <glguy> mdmkolbe, he doesn't need to know about _
23:39:25 <glguy> mdmkolbe, if that is what you mean
23:39:33 <scook0_> Esteth: it helps if you understand some basic rules:
23:39:36 <glguy> allone whatever = True -- works too
23:39:48 <mdmkolbe> glguy: the trick is to put that case last
23:40:01 <scook0_> (1) function application is just juxtaposition, and (2) function application has higher precedence than anything else
23:40:01 <glguy> ah, I didn't identify the correct part as the trick :)
23:41:35 <tally> i'm not sure I see why to use three patterns
23:42:11 <Esteth> scook0_: Oh, ok :)
23:42:41 <hpaste>  glguy annotated "syntax wrong?" with "trimmed (spoiler!)" at http://hpaste.org/2665#a5
23:43:21 <tuukkah> tally, you want to have all your cases covered. how many cases you need depends on how much your cases match
23:44:58 <Tac-Tics> does using && exempt allone from the status of tail recursive?
23:45:10 <Tac-Tics> for whatever it's worth
23:45:46 <mdmkolbe> tally: lists of length two will be properly handled by the last case, so the "[x, y]" case isn't needed
23:45:48 <elliottt> i would imagine so
23:46:09 <scook0_> Tac-Tics: (&&) should "tail-call" its second argument, I think
23:46:18 <int-e> Tac-Tics: && evaluates its left argument first.
23:46:38 <mdmkolbe> @src (&&)
23:46:38 <lambdabot> True  && x = x
23:46:38 <lambdabot> False && _ = False
23:46:40 <int-e> so as far as the term "tail recursive" applies it is tail recursive that way.
23:47:09 <Tac-Tics> I mean as far as the amount of stack space required
23:47:22 <scook0_> it wouldn't be a tail-call in a strict language
23:47:29 <Tac-Tics> ok
23:47:30 <mdmkolbe> Tac-Tics: (&&) is tail recursive in it's second argument
23:47:37 <tuukkah> no stack in haskell %-)
23:48:10 <scook0_> tuukkah: sure there is
23:48:13 <mdmkolbe> tuukkah: oh, yes there is a stack.  I spent 3 mo rewritting it.  The stack is just inside out
23:48:21 <Tac-Tics> there may not be a stack, but it's always a good idea to keep your memory usage to finite numbers ;-)
23:48:43 <scook0_> ever tried using non-strict foldl on a massive list?
23:48:48 <tuukkah> mdmkolbe, is that some implementation decision?
23:48:49 <int-e> lazy evaluation makes the term less useful. the guideline for avoiding stack overflows in Haskell is, basically, "construct the outermost constructor as soon as possible but no sooner" together with "don't build large unevaluated expressions"
23:48:56 <Tac-Tics> and for the purposes of stacks, usually you want very small finite numbers
23:49:11 <int-e> this advice requires a fairly good understanding of lazy evaluation to use in practice though.
23:50:01 <Tac-Tics> foldl1 (*) [1..1000]
23:50:11 <Tac-Tics> > foldl1 (*) [1..10000]
23:50:13 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
23:50:17 <tally> alright, I gotta head to bed,  want to thank everyone again for all their help, I'm sure I'll be back tomorrow night
23:50:30 <Tac-Tics> later
23:50:33 <tally> g'night
23:50:43 <Tac-Tics> > foldl1 (*) [1..10000000]
23:50:47 <lambdabot> Terminated
23:50:57 <elliottt> whoops
23:50:58 <glguy> Tac-Tics, that doesn't tell you if the number got to big
23:51:01 <glguy> or the stack too deep
23:51:11 <mdmkolbe> tuukkah: yes and no, the stack is still needed as we need to know the context to return to after forcing a thunk.  In a sense this is the current continuation of a CPS transform, so you could avoid using a stack and just allocate continuations on the heap.  But since haskell doesn't expose the current continuation it is more efficent to just use the stack to store the current continuation (this el
23:51:11 <mdmkolbe> iminates a lot of short lived heap allocations)
23:51:18 <Tac-Tics> it does on GHCi
23:51:32 <Tac-Tics> I keep wanting to type [1.........10000] to make a bigger list
23:52:31 <Tac-Tics> The more I learn about continuations, my understanding of them does not progress
23:52:36 <int-e> foldl1 doesn't follow the "don't build large unevaluated expressions" rule without the help of strictness analysis
23:52:43 <tuukkah> mdmkolbe, i see. so that stack can grow too large then
23:52:50 <int-e> you generally want foldl1' which is strict in its accumulator
23:53:20 <Tac-Tics> All I know is that that are 1) incredibly powerful flow control statements and 2) they are really useful for making certain things in Scheme not suck
23:53:41 <mdmkolbe> tuukkah: yes.  even if you implemented it as a heap allocated continuation, you could still run out of heap so the problem remains either way.
23:54:10 <tuukkah> mdmkolbe, there's typically much more heap space than stack space, isn't there?
23:54:24 <mdmkolbe> tuukkah: they both grow to meet demand
23:54:25 <Tac-Tics> And I have a feeling that the Cont monad is useless, but that the ContT monad is incredibly awesome (but I'm not too great with monad transformers  yet)
23:54:52 <mdmkolbe> Tac-Tics: ever used "longjump" and "setjump" in C?
23:55:02 <Tac-Tics> no, but I've read about them
23:55:20 <Tac-Tics> they are stack-managing gotos or something
23:55:53 <mdmkolbe> Tac-Tics: hmm, then that comparisent wont work...
23:55:56 <tuukkah> mdmkolbe, ulimit -s says 8192 kilobytes for stack
23:56:08 <mdmkolbe> tuukkah: that is the inital stack
23:56:15 <Tac-Tics> I know what they are, it's just I have very little intuition as to how they work
23:56:28 <int-e> that's the C stack. ghc uses two or three stacks I believe.
23:56:33 <mdmkolbe> Tac-Tics: continuations or setjump?
23:56:53 <tuukkah> mdmkolbe, "-s      the maximum stack size"
23:56:58 <mdmkolbe> int-e: GHC uses one stack per thread
23:57:07 <int-e> mdmkolbe: of course.
23:57:21 <mdmkolbe> tuukkah: GHC doesn't use the C stack.
23:57:37 <allbery_b> Cont isn't useless, but I think it's less useful than it might be because laziness keeps you from actrually needing it in many cases
23:57:51 <int-e> anyway the only time I've run out of C stack memory was when calculating with huge Integer values - gmp allocates intermediate values on the C stack by default.
23:57:55 <mdmkolbe> tuukkah: (except for foreign calls and in a few cheats at unregistered mode)
23:58:06 <Tac-Tics> (+ 3 (call/cc (lambda (k) (k 5))) is a function which executes the inner lambda passing (\x -> (+ 3 x)) as `k`, then, never returns to the sender, but instead calls `k` passing in whatever value you called it with
23:58:55 <Tac-Tics> allbery_b: what is a case where Cont by itself is useful? (not that I'm doubting it can be, I just don't know continuations well enough to see a good use myself)
23:59:14 <int-e> (it was something like calculating the 10000000th fibonacci number)
23:59:22 <allbery_b> in pure code?  not sure I can think of one offhand
23:59:30 <mdmkolbe> Tac-Tics: if you want to learn about *how* continuations are implemented, you need to lookup "Continuation Passing Style" and "CPS Transform"
23:59:54 <scook0_> I think you can use Cont to escape early from a series of tests
23:59:58 <allbery_b> I'm still kinda new to CPS though
23:59:59 <tuukkah> mdmkolbe, right, there's stacks and stacks :-) to implement a stack that can grow to the size of heap, does ghc use a stack that is made of blocks of memory?
