00:05:23 <calvins> damn i am stupid: at some point while cutting and pasting the haddock-args and trying the args in different orders an extra "--" got cut and pasted. It works just fine.
00:09:40 <goalieca> sorry to be off topic but wtf is this crap: http://pastebin.bafserv.com/1482
00:17:10 <vegai> goalieca: seems like it's you trying to be funny :)
00:17:21 <vegai> but not very well ;/
00:18:01 <goalieca> well.. i'm too tired to be clever.
00:18:07 <goalieca> but vegai i tried
00:18:26 <goalieca> i still think she's a minor who needs help and i wanted to help
00:43:47 <Cale> Wow, that "seemingly impossible" article is really cool.
00:44:06 <Pseudonym> Which one?
00:49:19 <wnoise> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
00:49:23 <lambdabot> Title: Mathematics and Computation » Seemingly impossible functional programs, http://tinyurl.com/2umqwh
00:50:00 <wnoise> exhaustive searching of some infinite sets
00:51:15 <wnoise> Hey, this says "The next version of the definition of Haskell will have a built-in type of natural numbers."
00:51:45 <wnoise> Really?  Peano?  Isomorphic to a lazy list?
00:52:14 <profmakx> um
00:52:23 <profmakx> isnt it just integer > 0?
00:52:28 <profmakx> or >=
00:52:33 <profmakx> for computer scientists ;)
00:53:37 <wnoise> Yes, it is (>=0, any other definition is unnatural).  But I'm asking what sort of implementation it will have.
00:54:04 <ulfdoz> probably unsigned int.
00:54:15 <wnoise> There've been mutterings to have a standard "lazy" natural, where you could compute whether it was greater than 0, without needing to force the entire computation.
00:59:06 <wnoise> Ah: http://hackage.haskell.org/trac/haskell-prime/ticket/79
00:59:08 <lambdabot> Title: #79 (Natural numbers) - Haskell Prime - Trac
00:59:21 <wnoise> But the latest straw poll doesn't look like it has much support.
02:04:20 <dibblego> ?check \n -> (head fibs * fibs !! 2) == (fibs' !! 1) ^ 2 where fibs 1 : 1 : zipWith (\a b -> a + b) fibs (tail fibs); fibs' = drop n fibs
02:04:20 <lambdabot>  Parse error
02:05:01 <oerjan> let not where
02:13:56 <oerjan> @check let fibs=0:1:zipWith(+)fibs(tail fibs) in \m n -> (m<0) || (n<0) || fibs!!(m+n+1) == fibs!!m * fibs!!(n+1) + fibs!!(m+1) * fibs!!n
02:13:57 <lambdabot>  Falsifiable, after 0 tests: 0, 0
02:16:39 <oerjan> @check let fibs=0:1:zipWith(+)fibs(tail fibs) in \m n -> (m<0) || (n<0) || fibs!!(m+n+1) == fibs!!m * fibs!!n + fibs!!(m+1) * fibs!!(n+1)
02:16:40 <lambdabot>  OK, passed 500 tests.
02:17:02 <dibblego> ?check \n -> n >= 0 ==> let fibs = 1 : 1 : zipWith (\a b -> a + b) fibs (tail fibs); fibs' = drop n fibs in head fibs' * fibs' !! 2 == (fibs' !! 1) ^ 2 + if n `mod` 2 == 0 then 1 else (-1)
02:17:03 <lambdabot>  OK, passed 500 tests.
02:17:50 <dibblego> ?check \n -> n >= 0 ==> let fibs = 1 : 1 : zipWith (+) fibs (tail fibs); fibs' = drop n fibs in head fibs' * fibs' !! 2 == (fibs' !! 1) ^ 2 + if n `mod` 2 == 0 then 1 else (-1)
02:17:51 <lambdabot>  OK, passed 500 tests.
02:22:40 <oerjan> i think yours may follow from mine if you consider negative indices and m == -n
02:23:05 <oerjan> or something like it
02:24:09 <oerjan> @let testing = 1
02:24:11 <lambdabot> Defined.
02:24:24 <oerjan> @check testing == (1 :: Int)
02:24:25 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
02:24:36 <oerjan> MRMRMRMR
02:28:07 <oerjan> @let fibs = 0:1:zipWith(+)fibs(tail fibs); nfibs = 0:1:zipWith(-)nfibs(tail nfibs); fib n | n >= 0 = fibs!!n | otherwise = nfibs!!(-n)
02:28:09 <lambdabot> Defined.
02:28:56 <oerjan> @check \m n -> fib (m+n+1) == fib m * fib n + fib (m+1) * fib (n+1)
02:28:58 <lambdabot>  OK, passed 500 tests.
02:29:53 <goalieca> wow lambdabot does testing
02:30:13 <oerjan> in two different ways
02:30:17 <oerjan> @scheck \m n -> fib (m+n+1) == fib m * fib n + fib (m+1) * fib (n+1)
02:30:19 <lambdabot>   Completed 169 test(s) without failure.
02:30:44 <Cale> I wonder which 169 those were.
02:30:59 <goalieca> i'm assuming entirely numerical
02:31:05 <goalieca> and not just algorithmic analysis ;)
02:31:06 <Cale> goalieca: nope
02:31:19 <Cale> It can produce values of many different types
02:31:27 <oerjan> -6..6 on each of m and n, is my guess
02:31:29 <Cale> You can even test higher-order functions
02:31:38 <Cale> It will generate random function arguments
02:32:08 <oerjan> although it is indeed not doing any algorithmic analysis.
02:32:13 <goalieca> !praise lambdabot,
02:32:50 <oerjan> more than usual for ghc, anyhow.
02:32:59 <Cale> oerjan: that's a decent guess :)
02:33:15 <wnoise> I really like using a language where small snippets can be dragged around without requiring all sorts of context or boilerplate.
02:33:27 <kfish> @botsnack
02:33:27 <lambdabot> :)
02:33:56 <goalieca> haskell is concise and self-describing a lot of time
02:34:31 <wnoise> concise is quite nice, but I was mostly talking about the referential transparency...
02:35:06 <Cale> wnoise: yeah, it's nice isn't it? :)
02:35:34 <wnoise> (And not needing to be attached to objects, and ...)
02:35:49 <goalieca> OOp = object oriented pain
02:36:08 <oerjan> @scheck \m n -> m `elem` [-6..6::Int] && n `elem` [-6..6::Int] -- proof?
02:36:09 <lambdabot>   Completed 169 test(s) without failure.
02:36:17 <Zao> goalieca: Object Obsessed Programming?
02:36:38 <bakert> Anyone here know how to get regular expression matching against paths in HAppS like HPaste does?
02:37:14 <oerjan> @where hpaste
02:37:14 <lambdabot> I know nothing about hpaste.
02:37:18 <oerjan> er...
02:37:22 <bakert> example: h "/annotate/([0-9]+)$"       POST $ handlePostAnnotate ch
02:37:28 <conal> @hpaste
02:37:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:38:15 <hpaste>  bakert pasted "hpaste matching paths with regular expressions" at http://hpaste.org/2987
02:38:15 <oerjan> i'm sure it's in the source?
02:38:35 <bakert> oerjan: sadly i'm too thick to understand how it is being achieved!
02:38:41 <bakert> even with the source :(
02:38:56 <bakert> in that mainWith method it uses regexes
02:39:09 <bakert> but if I add a regex to my HAppS code, it ignores it :(
02:39:13 <glguy> has anyone seen an hpaste spam this week?
02:39:51 <bakert> not me.  glguy: do you do anything special to get regular expression matching for paths with HAppS, or does it work like that out of the box?
02:40:09 <glguy> bakert: Ummm :)
02:40:13 <oerjan> that h seems like something to look at...
02:40:16 <glguy> I don't know in the current API
02:40:40 <glguy> there should be an example in the hpaste-devel sources
02:40:45 <bakert> so perhaps my problem is that i have too *new* a version of HApps???
02:40:46 <glguy> where I match on the paste ID
02:41:09 <glguy> kakapo.scannedinavian.org/~eric/hpaste-devel
02:41:39 <bakert> aha!
02:42:03 <bakert> glguy: brilliant thanks i will copy slavishly!
02:42:20 <bakert> plus edit the tutorial :)
02:43:25 <hpaste>  bakert annotated "hpaste matching paths with regular expressions" with "How hPaste does regular expression path matching against latest version of HAppS" at http://hpaste.org/2987#a1
02:44:06 <glguy> bakert: I might be responsible for the having to use the re function to use a regex
02:44:39 <bakert> it's quite nice the way it is now ... it's just that the tutorial gives no hints :)  i will update it to mention this as well as Prefix.
02:44:54 <bakert> i was trying to copy an old version of hPaste and getting a bit upset :S
02:44:59 <glguy> ah
02:45:12 <glguy> yeah, I need to make it more clear that current development is in hpaste-devel
02:45:21 <oerjan> dibblego: 1 == fib (n-n+1) == fib(n) * fib(-n) + fib(n+1) * fib(1-n), and fib(-n) == fib n * if even n then -1 else 1
02:45:32 <glguy> darcs branching support is unfortunately adhoc
02:46:49 <wnoise> glguy: that's a feature, not a bug.
02:47:48 <glguy> wnoise: go on
02:48:19 <glguy> that sort of microsoft response to why stuff is broken needs to be elaborated upon to be meaningful ;)
02:48:24 <gour> i see that 2 of 3 real-world haskell book authors are using mercurial (not sure about dons :-)
02:48:37 <gour> what do you think about hg vs darcs?
02:48:37 <glguy> I'm selling dons on git at work
02:48:42 <wnoise> Having branching be ad-hoc enables all of the wonderful distributed features.
02:48:57 <gour> glguy: :-)
02:48:59 <glguy> selling / sold
02:49:00 <glguy> :)
02:49:05 <wnoise> Requiring a central catalog of branches somewhere brings in a huge mess of complexity.
02:49:19 <benny> no wonder I thought glguy was so sensible in the other channel... he is here. ;-)
02:49:37 <glguy> wnoise: oh, you don't need a central branch repository
02:49:44 <glguy> wnoise: that's more of an svn thing
02:50:02 <glguy> but you *can* if you want to (put branches in the central repo)
02:50:18 <glguy> but I agree that it would suck if you couldn't have local branches
02:50:26 <wnoise> branches-as-repos simplifies things immensely though.
02:50:34 <glguy> benny: the other "unnamed" channel? ;)
02:50:34 <bakert> What's better about hg than darcs?  (git I assume you like because of performance?)
02:50:55 <benny> glguy: exactly, the one that people want to forget. ;-)
02:51:09 <wnoise> hg doesn't have a worst-cases exponential merging algorithm?
02:51:11 <glguy> I like that in hg/git I can know that I'm looking at the same repository as someone else by comparing the top hash
02:51:29 <glguy> in darcs you need some kind of direct/indirect network access to verify that you hae the same patches
02:51:46 <glguy> and I like that git/hg make it easy to roll back to a specific point in time
02:51:53 <glguy> I still use darcs for somet things
02:52:01 <glguy> so I don't want to sound like I just hate it or something
02:52:05 <gour> bakert: exp. growth with conflicts
02:52:18 <glguy> darcs was not able to scale up to the project I'm on at work
02:52:22 <glguy> so we *had* to switch
02:53:24 <gour> glguy: i'm at the beginning of a project, so considering to start with hg not be bitten by exp. growth in darcs later
02:53:26 <bakert> mmm yeah i have experienced verrry slowww darcs at my last job.  but i do actually love it for my own personal stuff.  i should give mercurial a try at some point.
02:53:53 <glguy> I like git because I feel like I have an extreme amount of control over my repository
02:53:54 <wnoise> The specific point in time is an interesting feature, but now each patch needs a "merged into this repo date".
02:54:00 <glguy> kind of a linux vs windows feeling
02:54:08 <gour> bakert: i had problem, although i like it very much, with darcs even as single 'dev' working on some web-site
02:54:24 <glguy> wnoise: git makes it easy to reorder commits
02:54:35 <gour> glguy: git is, at first sight, way too complicated for me
02:54:37 <wnoise> And that interacts oddly with cloning repos by just sucking down all the patches.
02:54:54 <phlpp> hi
02:55:05 <gour> glguy: have you considered hg instead of git?
02:55:07 <wnoise> I do like lots about the git backend.  But the interface is ... overcomplicated.
02:55:09 <glguy> wnoise: I agree, the two models just enable different workflows
02:55:20 <bakert> the thing i like most about darcs is the way it takes you through the changes with all those options.  encourages commits that actually make sense rather than just "everything i've done since yesterday".  i suppose git and hg both do that too?
02:55:22 * gour thinks hg should be enough for his project
02:55:26 <glguy> the interface just appers complicated, imho
02:55:31 <glguy> because the whole api is exposed
02:55:37 <glguy> as commands in /usr/bin
02:55:46 <glguy> so that you can shell script it easily
02:55:50 <gour> too many 'commands'
02:56:09 <glguy> now that I feel like I know what si going on with git
02:56:18 <glguy> I enjoy the flexibility
02:56:27 <glguy> I agree that that can seem daunting
02:56:41 <glguy> but current git versions are much easier than the 1.4 and before
02:56:55 <glguy> darcs will happily destroy your working copy
02:57:03 <glguy> with a misplaced darcs pull
02:57:08 <glguy> I like that git stops that'
02:57:20 <glguy> also, it makes it easy to roll back, you never really "lose" anything
02:57:25 <glguy> thanks to the reflogs
02:57:29 <glguy> (I don't know if hg does that)
02:57:40 <glguy> I need to stop typing so much though :)
02:57:47 <glguy> I'm going to get a note on the irc stats page on ~dons
02:57:48 <gour> glguy: you didn't check hg?
02:58:05 <glguy> gour: most of my comparison of features above is git - darcs
02:58:12 <gour> i see
02:58:21 <glguy> you can add a lot of the functionality that git has
02:58:26 <gour> glguy: any news about haskell on arch?
02:58:28 <glguy> via different gh extentions
02:58:42 <glguy> gour: my arch install got busted today
02:58:52 <gour> :-(
02:58:53 <glguy> arch64 doesn't have enough users
02:58:56 <wnoise> Darcs just fits how I think.  So I use it for personal projects that I don't expect to get big.
02:59:18 <gour> glguy: many are just on arch, like myself
02:59:34 <wnoise> But I can't recommend it for anything larger, due to the conflict bug, and the many different repo formats.
02:59:36 <gour> wnoise: what about real-world prjs?
03:00:26 <glguy> wnoise: are there things that darcs does in particular for personal projects that you could enumerate
03:00:37 <wnoise> gour: I haven't exactly committed to anything, yet.  git and hg both seem usable.
03:00:37 <glguy> from your pov
03:01:01 <glguy> git seems to have less windows support
03:01:07 <glguy> which matters to some people
03:01:48 <wnoise> glguy: trivial repo hosting (slap the repo on a webserver), quick branch creation, selection of hunks to commit in each patch.
03:02:00 <glguy> wnoise: git has all ofthose :)
03:02:02 <glguy> by default
03:02:33 <wnoise> change-based, rather than version based.
03:02:57 <glguy> yeah, that's the fundamental difference
03:03:07 <wnoise> glguy: really?  If I modify a file and add two functions, I can commit just one?
03:03:12 <glguy> wnoise: yeah
03:03:21 <glguy> wnoise: part of the "interactive" mode
03:03:27 <glguy> also supported in git gui
03:03:36 <wnoise> Neat.
03:04:27 <glguy> git commit -i
03:04:27 <glguy> iirc
03:04:38 <glguy> or git add -i
03:04:45 <glguy> git add -i would be for adding hunks
03:05:11 <glguy> I didn't know about that one for a while
03:05:40 <glguy> I like how if I move a function from one file to another
03:05:44 <glguy> its commit history follows it
03:05:54 <glguy> when using git gui blame, for examle
03:06:39 <wnoise> It's a well-done heuristic hack.
03:06:45 <glguy> yup
03:06:48 <glguy> which is how it should be
03:06:54 <glguy> so that if the heuristic improves
03:07:00 <glguy> you get the benefits in your old repositories
03:10:41 <gour> just guy the following info in #mercurial - http://www.selenic.com/mercurial/wiki/index.cgi/RecordExtension
03:10:43 <wnoise> How did it get to be 4 am?  Good night.
03:10:43 <lambdabot> Title: RecordExtension - Mercurial
03:12:28 <glguy> gour: In a conversation with bos over OSCON I mentioned that that was one of the things i liked about darcs
03:12:32 <glguy> and wished hg had
03:12:41 <glguy> I'm sure he had it in mind without my mention
03:12:48 <glguy> but I like to imagine that I helped :)
03:13:12 <gour> cool
03:19:54 <araujo> dons, ping
03:21:04 <glguy> dons is inbound to freisberg
03:21:11 <glguy> or whatver that city is :)
03:21:57 <araujo> hi glguy ,  lambdabot follows your orders? :-)
03:22:16 <glguy> no, I lost my ops eitherwhen lambdabot crashed or when they found out that I had them
03:22:52 <araujo> oh, ok
03:22:53 <araujo> :-P
03:22:53 <glguy> I wasn't supposed to have them, and they later I didn't , so I never asked :)
03:22:57 <araujo> hi kosmikus
03:23:08 <kosmikus> hi araujo
03:27:44 <araujo> anybody with lambdabot power here?
03:27:45 <araujo> :-P
03:27:59 <glguy> ?bot
03:28:00 <lambdabot> :)
03:29:12 <gour> glguy: you did not take look at bazaar?
03:29:28 <glguy> bazaar seemed to suffer from similar performance issues
03:29:33 <glguy> but I didn't look at it too seriously
03:29:43 <glguy> one of the draws of git for me was the large dedicated user base
03:29:50 <glguy> care of the kernel
03:30:19 <glguy> gour: have you?
03:30:26 <glguy> could you make a good case for it?
03:30:54 <gour> glguy: nope. i'm not sure why i despised it in the past...probably darcs was too good then
03:31:30 <glguy> all I've heard about it was that it had a good feature set but was slow
03:31:41 <glguy> but I never verified those claims myself
04:06:30 <paolino> hi, anyone knows i there is an open mailing list server ?
04:06:43 <paolino> *if
04:07:19 <paolino> bit off topic I know
04:23:50 * serishema waves to the channel
04:24:22 <serishema> i think i'm just beginning to get it lol
04:24:36 <fax> morning
04:24:40 <serishema> morning
04:24:55 * serishema is a newbie working through the examples in "A gentle introduction to haskell" and "haskell for C programmers"
04:25:13 * gour waves to serishema 
04:25:17 <serishema> hi gour
04:25:18 <fax> oh I did half of A gentle introduction to haskell
04:25:44 <gour> serishema: welcome and good luck with haskell
04:25:49 <serishema> thankies
04:27:06 <serishema> i'm starting to think it could actually be a good language to do graphics experimentation in.
04:27:21 <fax> what kind of graphics?
04:27:27 <fax> kind(s)
04:27:28 <gour> serishema: see http://haskell.org/gtk2hs
04:27:30 <lambdabot> Title: Gtk2Hs
04:27:40 <serishema> raytracing, exprimental 3D stuff, that sort of thing.
04:28:20 <Pseudonym> http://andrew.bromage.org/haskrt.png
04:28:23 <gour> serishema: http://haskell.org/gtk2hs/screenshots/
04:28:24 <lambdabot> Title: Gtk2Hs » Screenshots
04:28:32 <serishema> will gtk2hs compile on mac os X, it's not mentioned on the list of operating systems.
04:28:45 <fax> Pseudonym: nice imag
04:28:53 <fax> very cool blur
04:29:03 * serishema likes
04:29:10 <Pseudonym> Some sampling bugs in this one:
04:29:13 <Pseudonym> http://andrew.bromage.org/out4.png
04:29:20 <Pseudonym> But that's definitely global illumination that you see.
04:29:49 <Pseudonym> Yeah, Haskell is good for experimentation. :-)
04:30:19 <serishema> oh i see it's in macports
04:30:54 * serishema downloads 
04:31:48 <serishema> is doing the actual displaying on the screen part going to involve confusing monads like dealing with stdin does?
04:32:20 <Pseudonym> No, it'll involve non-confusing monads. :-)
04:32:38 <Pseudonym> Also known in the Haskell community as "warm fuzzy things", which are completely non-threatening.
04:32:47 <serishema> haha
04:34:29 <serishema> well i no longer regard functional programming as a form of encryption, which i did until recently so i figure i can envetually understand monads too
04:34:34 <Pseudonym> Seriously, monads aren't that hard.  Which is why there are so many monad tutorials out there.
04:34:47 <Pseudonym> Once people learn them, they immediately want to write a tutorial.
04:34:48 <serishema> ah excellent
04:34:52 * serishema googles
04:35:20 <Pseudonym> http://haskell.org/haskellwiki/Learning_Haskell
04:35:21 <lambdabot> Title: Learning Haskell - HaskellWiki
04:35:22 <Pseudonym> Section 2.4
04:35:27 <Pseudonym> 2.5
04:35:37 <serishema> ah, sort of like how everyone that knows assembly has a tutorial on how to crack games.
04:35:46 <Pseudonym> Really?
04:35:51 * Pseudonym never wrote one
04:36:02 <Pseudonym> Mind you, I learned assembly partly to crack games...
04:36:13 <Pseudonym> This was 20 years ago, but still.
04:36:17 <Pseudonym> THe more things change...
04:37:08 <serishema> yeah.
04:37:18 <serishema> when fairly trivial CD checks were popular in windows 9x based games
04:37:26 <LoganCapaldo> I want a sudden influx of arrow tuorials
04:37:31 <serishema> everyone was writing tutorials on how to do the insert jmp instruction type cracks
04:38:24 <Olathe> I use monads to crack CD protection all the time !
04:38:47 <serishema> i was quickly bored with cracking things as a teenager and was more interested in making things.
04:39:19 <quicksilver> what about cracking things in order to see if you could make them again?
04:39:47 <serishema> reverse engineering?
04:40:08 <LoganCapaldo> Like eggs?
04:40:14 <serishema> haha
04:40:26 <quicksilver> LoganCapaldo: I tried that, with all the kings horses and all the kings men...
04:40:28 <quicksilver> LoganCapaldo: no luck :(
04:40:31 <serishema> haha
04:40:50 <serishema> hmm category theory.
04:41:02 * serishema vaugely remebers that being used to proove termination
04:41:28 <fax> of what?
04:41:43 <LoganCapaldo> of John Conner's life
04:41:47 <Olathe> Of Humpty Dumpty.
04:41:50 <serishema> C functions
04:42:04 <serishema> albiet in limited cases
04:42:13 <serishema> it's not a solution to the halting problem, no one's solved that yet (that i know of)
04:42:17 <LoganCapaldo> C functions don't terminate, they just fade away
04:42:28 <fax> Is the halting problem actually a problme?
04:42:35 <LoganCapaldo> nay
04:42:39 <puusorsa> cracking a500 games ftw!
04:42:52 <LoganCapaldo> it should be called the halting fact of life
04:42:57 <serishema> if you want to know if some code is going to go into an infinate loop before you call it, perhaps?
04:43:14 <LoganCapaldo> you can usually find tha tout
04:43:43 <LoganCapaldo> it's only useful if you need to know if some _arbitrary_ piece of code will go into an infinite lop
04:44:14 <serishema> sorry, I should clarify, i am talking about arbitary code.
04:44:15 <LoganCapaldo> if you need to know tha it sounds like a security problem to me, and you should just use some language that doesn't let you do that.
04:44:17 <LoganCapaldo> problem solved
04:44:37 <serishema> it was in the context of security, yes.
04:44:41 <serishema> But i don't program in C any more.
04:45:25 * serishema often claims that the C programming language is 1) responsible for every major computer security hole in existance and 2) significantly impreeded the progress of computer science.
04:45:31 <serishema> but it did a job at the time.
04:45:57 <puusorsa> c is nice portable assembler
04:46:51 <serishema> it cirtainly works for writing a boot loader or something like that in
04:47:59 <serishema> i think a lot of code is written in C that really shouldn't have been
04:48:07 <LoganCapaldo> @faq Can you write a bootloader in Hasell?
04:48:07 <lambdabot> The answer is: Yes! Haskell can do that.
04:48:31 <fax> @faq Can haskell raise the dead?
04:48:31 <lambdabot> The answer is: Yes! Haskell can do that.
04:48:34 <fax> haha
04:48:42 <serishema> heh
04:48:52 <fax> I better be careful :op
04:48:56 <serishema> of course you shouldn't have told me that
04:49:11 <serishema> now i'm going to try it (the boot loader that is, i'm not into necromancy)
04:49:33 <LoganCapaldo> It can raise the dead, but they can't escape the reanimation monad
04:49:36 <puusorsa> is it necromancy if you're doing UNdead?
04:49:53 <serishema> i tried to write a microkernel C# a while ago
04:50:05 <serishema> but it turned out i'm not as good at writing JITs as i thought i was
04:50:23 <LoganCapaldo> making things undead is pretty much the reason for necromancy
04:50:42 <puusorsa> oh sorry
04:50:55 <puusorsa> i'm not properly awake yet, underdosed on caffeine
04:51:02 <puusorsa> i was thinkin necrophilia :)
04:51:16 <LoganCapaldo> oh dear god
04:51:36 <fax> lol
04:52:04 <LoganCapaldo> @type pure
04:52:06 * serishema thought of it too, but she wasn't sure how kink friendly the channel was lol
04:52:06 <lambdabot>     Ambiguous occurrence `pure'
04:52:06 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
04:52:18 <LoganCapaldo> @type arr
04:52:20 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
04:52:27 <Pseudonym> What's the problem with arr?
04:52:45 <LoganCapaldo> the problem with arr?
04:52:56 <Pseudonym> Oh, I missed the context of the conversation.
04:52:57 <Pseudonym> nm
04:53:09 * serishema tries to figure out what this function actually does
04:53:17 <Pseudonym> Which function?
04:53:45 <Pseudonym> ?free myArr :: (a -> b) -> A a b
04:53:45 <lambdabot> Plugin `free' failed with: IRCRaised Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
04:53:49 <Pseudonym> Hmm.
04:53:49 * serishema realises this is a rather obfuscatory type definition
04:53:55 <Pseudonym> Yeah.
04:54:02 <LoganCapaldo> @instances Arrow
04:54:03 <lambdabot> (->), Kleisli m
04:54:03 <Pseudonym> Kinds make things complex.
04:54:17 <LoganCapaldo> @type Kleisli arr
04:54:19 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => Kleisli (a b) (b -> c) c
04:54:29 <LoganCapaldo> um
04:54:29 <Pseudonym> ?src Kleisli
04:54:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:54:47 * serishema ponders
04:54:56 <LoganCapaldo> oh that was silly of me
04:55:03 <LoganCapaldo> @src Kleisli arr
04:55:03 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:55:12 <Pseudonym> serishema: Ignore arrows for the moment.
04:55:31 <Pseudonym> Like monads, they're warm.  Unlike monads, they're not fuzzy.
04:55:40 <LoganCapaldo> ignore arrows for they are subtle and quick to anger
04:55:46 <LoganCapaldo> or something
04:55:47 <serishema> a function that takes b and c whatever they are plus a function and returns a function that takes yet more crap and another function?
04:56:05 <Pseudonym> An arrow is actually a generalisation of a function.
04:56:12 <ivanm> why are monads referred to being as warm and fuzzy, anyway... is there actually a reason behind those two adjectives?
04:56:15 <Pseudonym> Details not important right now.
04:56:23 <Pseudonym> ivanm: Yes, because you can cuddle up to them.
04:56:30 <Pseudonym> THey are not threatening in the slightest.
04:56:41 <LoganCapaldo> maybe keeps me warm on those dark winter nights
04:56:43 <ivanm> lol
04:57:01 <fax> serishema: lol @ yet more crap
04:58:18 <serishema> oh this is all lambda calculus stuff?
04:58:32 <LoganCapaldo> not especially
04:58:54 <serishema> i'm looking at one of the mondas tutorials
04:59:24 <serishema> f',g' :: Float -> (Float,String) looks like it comes straight from category theory
04:59:40 <Pseudonym> How about that!
04:59:48 <Pseudonym> You know some category theory?
05:00:11 <serishema> bits and peices, mostly on the context of modelling the possible states of something
05:00:12 <LoganCapaldo> serishema is vastly ahead of the game
05:00:14 <Pseudonym> You're gonna LOVE Haskell.
05:00:36 <Pseudonym> serishema: An arrow is a Freyd category.
05:00:43 <Pseudonym> So now you know!
05:00:58 <LoganCapaldo> plently of people myself included hadn't even heard the phrase "category theory" before they got here :)
05:01:25 <Pseudonym> The link between Haskell and category theory goes very, very deep.
05:01:33 <LoganCapaldo> case in point I have no idea wtf a Freyd category is
05:02:05 <serishema> hmm sounds like it might be a good idea for me to go back and revise some of it
05:02:28 <fax> What has morphisms got to do with Catagories/Catagory theory?
05:02:30 <Pseudonym> http://en.wikipedia.org/wiki/Abelian_category
05:02:31 <fax> if anything
05:02:31 <lambdabot> Title: Abelian category - Wikipedia, the free encyclopedia
05:02:47 <Pseudonym> In particular, the first reference at the end of that article.
05:03:33 <Pseudonym> fax: A "morphism" is, basically, what the -> means in category theory.
05:03:53 <ivanm> well, I've been reading a book called "category theory for computer scientists"... managed to bash along until I got to arrows, and then gave up :s
05:04:10 <Pseudonym> Nah, "arrows" in that sense isn't "arrows" in the Haskell sense.
05:05:36 <LoganCapaldo> @type Kleisli (const 3)
05:05:36 <Pseudonym> Another important link is that free theorems tend to be commutative squares.
05:05:44 <lambdabot> forall a (m :: * -> *) b. (Num (m b)) => Kleisli m a b
05:06:03 <ivanm> Pseudonym: yeah, I know
05:06:18 <LoganCapaldo> @type first $ Kleisli (const 3)
05:06:20 <lambdabot> forall d a (m :: * -> *) b. (Arrow (Kleisli m), Num (m b)) => Kleisli m (a, d) (b, d)
05:06:41 <ivanm> @type Kleisli
05:06:43 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
05:06:54 <LoganCapaldo> @type runKleisli $ first $ Kleisli (const 3)
05:06:56 <lambdabot> forall d a (m :: * -> *) b. (Arrow (Kleisli m), Num (m b)) => (a, d) -> m (b, d)
05:06:56 <serishema> ah gotcha so when you write some trivial type declartion like func a :: Integer -> String
05:07:02 <LoganCapaldo> zomg
05:07:07 <LoganCapaldo> sick
05:07:34 <serishema> are you saying category func for the class Integer has a morphism to the class String?
05:08:00 <serishema> in that categorys class of morphisims?
05:08:16 <Pseudonym> Haskell is itself a category.
05:08:24 <fax> I thought that is what you did when you write the actual func
05:08:25 <Pseudonym> The types are the objects, and functions are morphisms.
05:08:26 <fax> not just the type definition
05:09:01 <Pseudonym> So a function like f :: Int -> Int is an endomorphism.
05:09:41 <LoganCapaldo> while you're at it, what the heck is an endofunctor?
05:09:44 <serishema> ah gotchya
05:10:02 <Pseudonym> An endofunctor is a function mapping a category to itself.
05:10:28 <Pseudonym> Much like how an endomorphism maps an object to itself.
05:10:38 <LoganCapaldo> so Monads ae endofunctors because we stay i Hask?
05:10:41 <LoganCapaldo> *are
05:10:44 <LoganCapaldo> *in
05:10:47 <Pseudonym> In a sense, the Haskell "Functor" class is actually an endofunctor.
05:11:00 <Pseudonym> Because it actually maps Haskell functions to Haskell functions.
05:11:00 <serishema> if this stuff is how haskell actually works i can see that the potential for programming erros is going to a lot lower than with imperative languages.
05:11:10 <Pseudonym> Yeah.
05:11:12 <serishema> is that what arrow does?
05:11:35 <LoganCapaldo> as far as I can tell arrows are just a cool way to have combinators :)
05:11:41 <Pseudonym> Arrows are, essentially, subcategories.
05:11:49 <serishema> ah.
05:12:08 <Pseudonym> But they're well-behaved ones.
05:12:11 * serishema doesn't know specifically about subcategories and doesn't want to jump to conclusions about meaning
05:12:15 <Pseudonym> Sure.
05:12:19 <Pseudonym> Ignore arrows for now.
05:12:24 <Pseudonym> Learn monads, instead.
05:12:37 <LoganCapaldo> monads ae magically delicious
05:12:41 <LoganCapaldo> *are
05:12:54 <serishema> ah, wikipedia says it was what i thought it was
05:13:15 * serishema must stop getting distracted
05:13:52 <serishema> part of the reason i flunked out of computer science is because i always go off on random tangents like this and don't do what i should be doing
05:14:01 <puusorsa> serishema, same here
05:14:14 <fax> me too :D
05:14:18 <puusorsa> except i haven't flunked yet, just taking 7 years to get any kind of degree
05:14:22 <puusorsa> adhd for teh win!
05:14:44 <serishema> i'm doing an generic IT course at a polytechnic at the moment.
05:15:07 <Pseudonym> And you know category theory?
05:15:11 <Pseudonym> Man, are YOU in the wrong place!
05:15:11 <serishema> the idea is to get my undergrad done and get my peice of paper so i can go on to do stuff that actually interests me.
05:15:18 <Pseudonym> Yeah.
05:15:20 <Pseudonym> Fair enough.
05:16:01 <serishema> i often get told off by lecturers when they tell us to use what amounts to a brute force solution
05:16:12 <serishema> and i say or you could use <some random mathematical theory i picked up somewhere>
05:16:44 <fax> reminds me of maths in school :/
05:17:06 <integral> doesn't get any better even on some PG courses
05:17:07 <serishema> i'm hopeless at generic maths as taught in schools / undergrad uni
05:17:48 <serishema> i'm only interested in things like category theorgy, set theory, chaos theory, stuff like that
05:18:18 <LoganCapaldo> > map (left (const 0) >>> right (const 1)) [Left "a", Right EQ, Left "b", Right LT]
05:18:28 <lambdabot>  [Left 0,Right 1,Left 0,Right 1]
05:18:42 <integral> serishema: topology?
05:19:05 <LoganCapaldo> I'm sensing more uberness potential than either
05:19:17 <fax> :t (>>>)
05:19:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
05:19:33 <serishema> integral: I remeber being facinated by moubious strips when i was younger
05:19:35 <LoganCapaldo> > map (left (const 0) >>> right (const 1) >>> left (subtract 3)) [Left "a", Right EQ, Left "b", Right LT]
05:19:37 <lambdabot>  [Left (-3),Right 1,Left (-3),Right 1]
05:19:42 <LoganCapaldo> SICK!
05:19:45 <fax> :o
05:19:46 <integral> serishema: But not homology groups?
05:19:55 <serishema> not heard of those
05:20:01 <LoganCapaldo> I love this game
05:20:04 <fax> :t left
05:20:06 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
05:20:15 <fax> cool :D
05:20:17 <integral> serishema: that's one reason to do undergrad even if it's boring: you see a lot of stuff
05:21:44 <LoganCapaldo> @ty map (left (const 0) >>> right (const 1) >>> left (subtract 3)) [Left "a", Right EQ, Left "b", Right LT]
05:21:46 <lambdabot> forall t t1. (Num t1, Num t) => [Either t t1]
05:21:50 <serishema> in my 2nd year in CS i spent a lot of time being distracted by emergant properties in systems.
05:21:58 <LoganCapaldo> @ty map (left (const 0) >>> right (const 1) >>> left (subtract 3))
05:22:00 <lambdabot> forall t b t1 b1. (Num t1, Num t) => [Either b b1] -> [Either t t1]
05:22:06 <serishema> where you get a bunch of simple agents whos behaviour is defined by a few simple functions
05:22:16 <serishema> and put them in an increasingly complex environment and watch crazy stuff happen.
05:30:40 <serishema> i think haskell is the first programming language i've seen that allows a function to have multiple return values.
05:31:03 <fax> haskell doesn't allow multiple return values :|
05:32:19 <serishema> i should clarify, rather you can return more than one variables worth of data
05:32:33 <fax> like how?
05:32:36 <Pseudonym> What's a "variable"?
05:32:54 <Pseudonym> BTW, logic languages have real multiple-return-values.
05:32:56 <Pseudonym> e.g. Prolog
05:33:15 <jeffz> mzscheme has multiple return values
05:33:52 <serishema> something like: f :: Float -> (Float,String) / f a = (a / 1.5, "f was called")
05:34:10 <serishema> in the other languages i know you'd have to make some kind of data structure to be able to return a float and a string.
05:34:16 <fax> serishema: how's it different to (struct foo){0.53f, "hello"}; ?
05:34:27 <fax> :t (,)
05:34:29 <lambdabot> forall a b. a -> b -> (a, b)
05:34:42 <fax> ^ it makes a data structure from two datas
05:35:10 <serishema> ah, so this is the form structs take?
05:35:42 <fax> It's a tuple of Float * String, so a new data structure in itself
05:36:05 <Pseudonym> Haskell doesn't really have "structs".
05:36:07 <fax> Just the notation is really neat
05:36:43 <serishema> ah
05:39:35 <LoganCapaldo> @type either id id $ id +++ read
05:39:38 <lambdabot>     Couldn't match expected type `Either b b'
05:39:38 <lambdabot>            against inferred type `Either a String -> Either a a1'
05:39:57 <LoganCapaldo> @type either id id $ id +++ (read :: Int)
05:39:59 <lambdabot>     Couldn't match expected type `Int'
05:39:59 <lambdabot>            against inferred type `String -> a'
05:40:13 <LoganCapaldo> @type either id id . id +++ (read :: Int)
05:40:15 <lambdabot>     Couldn't match expected type `Int'
05:40:15 <lambdabot>            against inferred type `String -> a'
05:40:22 <fax> :t (+++)
05:40:24 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
05:40:29 <LoganCapaldo> @type either id id . (id +++ (read :: Int))
05:40:31 <lambdabot>     Couldn't match expected type `Int'
05:40:31 <lambdabot>            against inferred type `String -> a'
05:40:42 <LoganCapaldo> @type either
05:40:45 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:41:01 <serishema> what's this forall thing that keeps comming up?
05:41:10 <Zao> serishema: ghc extension.
05:41:26 <fax> I think forall a. a means just for any type
05:41:37 <fax> so like undefined is of any type at all
05:41:43 <LoganCapaldo> oh I'm so dumb
05:41:50 <Pseudonym> Right.
05:41:52 <LoganCapaldo> wait
05:42:01 <fax> :t undefined :: Int
05:42:03 <lambdabot> Int :: Int
05:42:12 <LoganCapaldo> id +++ (read :: Int) $ Left 3
05:42:13 <Pseudonym> And the free theorem for undefined is:
05:42:16 <LoganCapaldo> > id +++ (read :: Int) $ Left 3
05:42:16 <lambdabot>  Couldn't match expected type `Int'
05:42:17 <Pseudonym> ?free undefined
05:42:19 <lambdabot> f undefined = undefined
05:42:25 <Pseudonym> That's true for ANY function f.
05:42:34 <Pseudonym> So that should give you some idea what it means.
05:43:03 <Pseudonym> Well, not quite.
05:43:14 <LoganCapaldo> > id +++ (read :: String -> Int) $ Left 3
05:43:16 <lambdabot>  Left 3
05:43:25 <LoganCapaldo> > id +++ (read :: String -> Int) $ Right "4"
05:43:27 <lambdabot>  Right 4
05:44:05 <LoganCapaldo> @type either id id . (id +++ (read :: String -> Int))
05:44:07 <lambdabot> Either Int String -> Int
05:44:12 <LoganCapaldo> Sweet
05:44:51 <LoganCapaldo> @type either id read :: Either Int String -> Int
05:44:53 <lambdabot> Either Int String -> Int :: Either Int String -> Int
05:45:06 <geocalc> @lambdabot
05:45:06 <lambdabot> Unknown command, try @list
05:45:06 <LoganCapaldo> but +++ is cooler :)
05:45:12 <hpaste>  sek pasted "Parsec buildExpressionParser help" at http://hpaste.org/2988
05:45:27 <sek> hi, i asked about this yesterday if anyone has a minute to give me some ideas
05:45:53 <opqdonut> ?free fix
05:45:55 <lambdabot> f . g = h . f => f (fix g) = fix h
05:46:05 <fax> sek: Ideas about waht?
05:46:28 <sek> fax, what i put on hpaste. It works in itself, but i need it to do some extra things which i am unsure on how to implement
05:46:33 <opqdonut> ?free map
05:46:37 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
05:46:44 <Pseudonym> $map is the "standard" map, BTW.
05:46:47 <LoganCapaldo> you have to actually ask the question
05:46:49 <Pseudonym> Just in case you give it "map". :-)
05:46:55 <opqdonut> Pseudonym: ah :)
05:47:14 <Pseudonym> Here's my favourite:
05:47:22 <Pseudonym> ?free naturalTransformation :: F a -> G a
05:47:22 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
05:47:33 <sek> ok:) Well its a boolean expression parser, which i want to be able to also read other expressions such as +-*/ or anything else, but store these as a string
05:47:34 <Pseudonym> It assumes that F and G are functors.
05:48:41 <sek> so for example whenever it's passed "2+2" i want it to store it as CFreeForm "2+2". But i also want it to read things like "pow(2,2) == 4" which is a boolean expression, only that pow(2,2) should be stored as a string
05:48:42 <opqdonut> :)
05:49:23 <opqdonut> Pseudonym: does ?free provide theorems inferred from the type?
05:49:44 <Pseudonym> Yeah.
05:50:03 <Pseudonym> It can't handle typeclasses, unfortunately.
05:50:18 <Pseudonym> ?free return
05:50:20 <lambdabot> Expected variable or '.'
05:50:21 <Pseudonym> However:
05:50:27 <Pseudonym> ?free return :: a -> M a
05:50:27 <lambdabot> $map_M f . return = return . f
05:50:51 <fax> ?djinn a -> Not a
05:50:51 <lambdabot> -- f cannot be realized.
05:53:13 <xerox> ?djinn (a, Either (Not a) b) -> b
05:53:14 <lambdabot> f (a, b) =
05:53:14 <lambdabot>     case b of
05:53:14 <lambdabot>     Left c -> void (c a)
05:53:14 <lambdabot>     Right d -> d
06:15:45 <sek> what's short for \x -> [x] ?
06:16:41 <Olathe> @pl \x -> [x]
06:16:42 <lambdabot> return
06:16:46 <sek> > (:[]) 2
06:16:48 <lambdabot>  [2]
06:16:54 <Olathe> > return 2
06:16:55 <lambdabot>   add an instance declaration for (Show (m t))
06:16:59 <Olathe> :(
06:17:06 <Olathe> Bad @pl !
06:17:29 <sek> return wouldnt know what Monad to return since there is no context maybe
06:17:34 <Olathe> I know.
06:17:42 <sek> anyway, :[] works fine:) thnx
06:17:48 <Olathe> > (:[]) [2]
06:17:50 <lambdabot>  [[2]]
06:17:58 <Olathe> Neat.
06:18:02 <twanvl> return looks better
06:18:59 <sek> ah actually i did have context, so return is neater indeed, heh
06:19:57 <fax> > return 2 :: [Int]
06:19:58 <lambdabot>  [2]
06:20:06 <fax> :t return
06:20:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:20:16 <Olathe> > return 2 :: [a]
06:20:17 <lambdabot>   add (Num a) to the expected type of an expression
06:20:35 <LoganCapaldo>  no, you do it
06:20:45 <LoganCapaldo> lazy lambdabot
06:20:49 <fax> :t return 2
06:20:51 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
06:21:02 <fax> :t return 2 :: [Int]
06:21:04 <lambdabot> [Int] :: [Int]
06:21:08 <fax> argh!
06:21:23 <Olathe> :t return 3.5 :: [Int]
06:21:25 <lambdabot>     No instance for (Fractional Int)
06:21:25 <lambdabot>       arising from the literal `3.5' at <interactive>:1:7-9
06:22:01 <LoganCapaldo> Fractional Ints? Blasphemy!
06:22:12 <LoganCapaldo> > unsafeCoerce# 3.5 :: Int
06:22:13 <lambdabot>   Not in scope: `#'
06:22:24 <Olathe> 8/2 = o
06:22:36 <LoganCapaldo> huh?
06:22:45 <Olathe> The top half is gone.
06:22:53 <LoganCapaldo> lol
06:23:12 <LoganCapaldo> cut that 8 down to size
06:42:33 <sek> Dont know if anyone's interested, but i managed to hack that expression parser a bit and get it to do what I wanted http://hpaste.org/2989http://hpaste.org/2989
06:48:22 <sek> final quick question tough. Whats the best way to skip whitespace and/or comments at the beggining of the file? I have setup a lexer
06:49:13 <kayess> Can I get the type of a function as a data structure? e.g. ( typeof curry )
06:49:30 <fax> :t curry
06:49:31 <LoganCapaldo> kayess: import Data.Typeable
06:49:32 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:49:40 <LoganCapaldo> > typeOf curry
06:49:41 <lambdabot>  Add a type signature
06:49:44 <fax> you can store as text :)
06:50:01 <allbery_b> Typeable isn't very useful for that, it doesn't handle polymorphic functions
06:50:07 <allbery_b> (like, say, curry :)
06:50:11 <LoganCapaldo> > typeOf curry :: (Int, Int) -> Int -> Int -> Int
06:50:11 <lambdabot>  Couldn't match expected type `(Int, Int) -> Int -> Int -> Int'
06:50:16 <LoganCapaldo> gah
06:50:18 <LoganCapaldo> well
06:50:35 <LoganCapaldo> > typeOf (curry :: (Int, Int) -> Int -> Int -> Int)
06:50:35 <lambdabot>  Couldn't match expected type `(Int, Int)'
06:50:47 <LoganCapaldo> > typeOf (curry :: (Int, Int) -> Int -> Int -> Int -> Int)
06:50:48 <lambdabot>  Couldn't match expected type `(Int, Int)'
06:50:48 <kayess> Really stupid question now. How do I import in an interactive shell (GHCi)? Is it load?
06:50:51 <LoganCapaldo> lol
06:50:54 <allbery_b> the more general answer:  Haskell is not good at introspection.  ghc-api might be useful though (see the ghc wiki)
06:50:54 <LoganCapaldo> I suck
06:50:56 <Saizan> ?type curry
06:50:58 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:51:01 <LoganCapaldo> :m +Module.Here
06:51:04 <allbery_b> kayess:  :m + module
06:51:19 <LoganCapaldo> > typeOf (curry :: ((Int, Int) -> Int )-> Int -> Int -> Int)
06:51:21 <lambdabot>  ((Int,Int) -> Int) -> Int -> Int -> Int
06:51:36 <LoganCapaldo> @type typeOf (curry :: ((Int, Int) -> Int )-> Int -> Int -> Int)
06:51:37 <lambdabot> TypeRep
06:52:44 <kayess> Apparently :m works better if you do Data.Typeable rather than Date.Typeable.... dum de dum :)
06:54:10 <kayess> Does that mean I need to know the type signature in order to get it's type?
06:54:36 <dons> omg, http://programming.reddit.com/info/2usb8/details
06:54:37 <lambdabot> Title: For most programmers, learning Haskell will be no picnic... unless they read thi ...
06:54:46 <dons> who is this guy? :)
06:55:12 <Pseudonym> Someone on reddit, obviously.
06:55:42 <Olathe> It has lolbotz: http://www.lisperati.com/haskell/lolghc.png
06:56:04 <Olathe> That's totally not lolcatz.
06:56:10 <dons> ah, Conrad Barski
06:56:23 <dons> lolbotz look friendly enough
06:56:49 <lambdabot> o hai im in ur chanil, ansering ur kweshuns
07:00:14 <tuukkah> we need to unite the purely functional lolcode research community
07:02:48 <dons> anyone else in Freiburg ?
07:03:27 <dons> i've already seen hudak and fisher. a fair bit of galois is here now. are the oxford guys on their way yet? ndm et al, as well?
07:04:54 <gour> dons: hi, welcome to eu...you're (still) using darcs?
07:05:45 <Olathe> @unpl zip.repeat
07:05:46 <lambdabot> (\ c -> zip (repeat c))
07:06:01 <dons> gour: i am, though i must admit its got some competition these days
07:06:38 <chessguy> @type zip . repeat
07:06:40 <lambdabot> forall b a. a -> [b] -> [(a, b)]
07:07:05 <gour> dons: good, i was worried when i 'discovered' that two of three from Gang of Three (authors of RWH book) use mercurial
07:08:01 <dons> well, darcs isn't the end of revision control
07:08:08 <dons> and it could have a better implementation
07:08:37 <dons> its not moving as fast as we need it to, i suspect
07:09:24 <chessguy> moving in what sense?
07:09:52 * allbery_b keeps hearing complaints/comments about its inability to handle repos with large numbers of revisions
07:10:04 <allbery_b> (most recently in the context of the linux kernel)
07:10:06 <dons> that, for  example
07:10:12 <gour> yep, it got stuck a bit while competition was quie active
07:10:13 <dons> and it  breaks a lot
07:10:32 <gour> exponential-growth bites
07:10:35 <dons> it was kicking butt in 02-04, but i think the rest of the dvcs field is mowing it down pretty quickly now
07:12:16 <allbery_b> the other one I've heard about is that apparently some combinations of patches can cause it to fail to converge
07:12:18 <gour> dons: what's weather in germany?
07:12:33 <dons> sunny, but a bit cool (in southern germany)
07:12:41 <dons> allbery_b: merge issues.
07:12:56 <gour> dons: enjoy icfp and hack a lot
07:13:01 <dons> i hope to!
07:13:20 * LoganCapaldo thinks scms need to become language aware
07:13:43 <dons> i'd like to take the darcs api, remove half of it, and reimplement it from scrach
07:14:15 * gour notices that CosmicRay wrote hg-extension - http://www.selenic.com/mercurial/wiki/index.cgi/SendExtension
07:14:17 <lambdabot> Title: SendExtension - Mercurial
07:16:16 <Olathe> > (zip [3] (repeat 1), zip (repeat 3) [1])
07:16:21 <lambdabot>  ([(3,1)],[(3,1)])
07:16:49 <Olathe> @src zip
07:16:49 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:16:50 <lambdabot> zip _      _      = []
07:16:50 <LoganCapaldo> Rnadom question: is -fvia-C a viable distibution mechanism for sites that don't have ghc?
07:16:54 <Olathe> That's pretty neat.
07:17:30 <allbery_b> LoganCapaldo: don't think so
07:17:43 <Pseudonym> Time for bed, I think.
07:17:45 <allbery_b> doesn't -fvia-C depend on gcc output being popstprocessed by the evil mangler?
07:17:48 <Pseudonym> Enjoy Freiburg.
07:17:52 <Pseudonym> Anyone who's there.
07:17:56 <Pseudonym> Night.
07:17:58 <allbery_b> unregisterised might work but has its own issues
07:18:15 <chessguy> @pl \x y -> (zip [x] (repeat y), zip (repeat x) [y])
07:18:15 <lambdabot> ap (ap . ((,) .) . (. repeat) . zip . return) ((. return) . zip . repeat)
07:18:20 <Olathe> What's a b*** ?
07:18:21 <allbery_b> (and in either case you still need the libHs*.a files)
07:18:35 <Olathe> I can't think of any bad words that have four letters and start with b.
07:18:37 <chessguy> hm
07:18:39 <serishema> allbery_b: I read somewhere that if gcc is run with -o3 the EM will never actually do anything
07:18:41 <chessguy> looks arrow-ish
07:18:43 <LoganCapaldo> well I gues sits a good thing tha idea just popped into my head and I don't actually have to do it :)
07:19:11 <LoganCapaldo> Olathe: a pathological regexp?
07:19:15 <Olathe> Heheh
07:19:22 <serishema> though i'm working on a non-i386 machine so i think the EM doesn't run for me?
07:19:30 <dons> Igloo: should deriving typeable get an xFlagss ?
07:19:36 <dons> ?users
07:19:36 <lambdabot> Maximum users seen in #haskell: 420, currently: 371 (88.3%), active: 11 (3.0%)
07:19:56 <LoganCapaldo> How do you decide whose active you crazy lambdabot?
07:21:53 <LoganCapaldo> Think they make lambda shaped throwing stars?
07:22:28 * allbery_b randomly (and half awake-ly) wonders if those migh behave like boomerangs
07:22:42 <LoganCapaldo> that would be... unfortunate
07:22:54 <allbery_b> hm, boomerangs as a physical example of fix :)
07:23:06 <fax> ...lol
07:23:09 <LoganCapaldo> I was thinking of continuations actually
07:24:04 * kayess really needs to go through a Haskell tutorial to learn some basic syntax
07:24:07 <hunzinozinkon> hello people!
07:24:36 <dons> hello hunzinozinkon
07:24:42 <dons> kayess: good idea!
07:25:03 <sorear> @ty fromEnum
07:25:11 <lambdabot> forall a. (Enum a) => a -> Int
07:25:37 <fasta> It's kind of a paradoxal that coming up with an easy algorithm for problem is hard.
07:25:42 <kayess> dons: It isn't the principles that get me. There's just so much syntax in Haskell. I'm fairly happy with functional stuff up to monads - I used to do quite a lot of Miranda years ago
07:25:46 <fasta> for a*
07:26:17 <hunzinozinkon> jaredj: I read your grep2.lhs yesterday - great stuff!
07:26:19 <dons> so much syntax?
07:26:33 <fasta> C# has more, I guess.
07:26:46 <fasta> Or Cobol ;)
07:27:16 <kayess> Yeah. And the differences between what works in a .hs and GHCi isn't always immediately apparent. I think the biggest problem I have is just not being able to read the type expressions well enough yet and I guess that's all down to practice
07:27:40 <LoganCapaldo> kayess: ghci is like you are always inside a do in a .hs file
07:27:56 <LoganCapaldo> so if you can't do it there (in a do block) you can't do it in ghci
07:28:06 <kayess> Ahhh. That makes some sense put like that
07:28:19 <dons> `Obviously, Haskell is not a good choice. It has a complicated, strange syntax and it's designed by and for people with large experience in Computer Science'
07:28:39 <LoganCapaldo> yu say that like its a bad thing :)
07:28:43 <mrd> those silly computer scientists don't know anything about computers
07:28:48 <EvilTerran> "obviously"? proof by intimidation?
07:29:14 <serishema> hehe
07:29:30 <scook0> actually, is there a good way to become familiar with the more obscure corners of Haskell syntax, short of wading through the Report?
07:29:46 <serishema> the people who say that kinda thing should see the people in my IT course's programs
07:29:47 <Lycurgus> read a good app
07:29:55 <Lycurgus> like darcs
07:30:02 <allbery_b> <dons> `Obviously, Haskell is not a good choice. It has a complicated, strange syntax and it's designed by and for people with large experience in Computer Science'
07:30:08 <serishema> lets do selection sort or linear search on 1 million keys
07:30:11 <allbery_b> by that argument we should all be using cobol
07:30:22 <LoganCapaldo> mmm sweet sweet cobol
07:30:25 <serishema> "maria, why is my program so slow, i've done everything right"
07:30:34 <kayess> Or C++ (ducks)
07:30:40 <mrd> Lycurgus: darcs is scary!
07:30:44 <LoganCapaldo> mmm sweet sweet c++
07:30:44 <fax> Not a good choice for what?
07:30:50 <LoganCapaldo> for anything!
07:30:52 <mrd> "I fear of this darcs"
07:30:54 <LoganCapaldo> Obviously!
07:30:55 <serishema> the 3rd years often bug me with their project problems.
07:30:56 <fax> oh right yes
07:31:27 <serishema> "maria, would it run faster if i re-write it assembly" they ask
07:31:29 <fax> We certainly don't want people with any experience using computers
07:31:32 * LoganCapaldo is thoroughly convinced there is a lot of natural talent involved with CS
07:31:35 <Lycurgus> mrd: Haskell is not for the timid
07:31:41 * allbery_b randomly had someone pop into his office and ask him about his haskell experience yesterday
07:31:50 <fax> serishema: haha
07:31:54 <dons> dcoutts: ghc build broken due to cabal issue
07:31:58 <serishema> and of course i say "if you keep using a bad algorithm it won't go any faster"
07:31:59 <dons> allbery_b: sweet
07:32:10 <dons> care to elaborate?
07:32:28 <fasta> serishema: you said yes, I hope? (to increase the rate of the learning process)
07:32:31 <allbery_b> not much to elaborate on.  I'm not even sure who he was
07:33:27 <serishema> fasta: i'm not that cruel. I think for these guys there's more important stuff for them to be learning than assembly.
07:33:28 <allbery_b> student (don't even know if he was scs or ece, or undergrad / grad; he didn't identify himself).  he just wondered how long I'd been using it and if I'd released any programs/libraries (no... yet)
07:33:31 <fasta> I wonder how many hundreds lines of code were simplified by doing my algorithm in the right way.
07:34:13 <serishema> I remeber when i saw the two line mergesort in haskell that was when i first got curious.
07:34:26 <LoganCapaldo> theres a 2 line merge sort?
07:34:45 <allbery_b> @quote collapsed
07:34:45 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
07:34:51 <LoganCapaldo> where there semi-colons?
07:34:53 <allbery_b> hm, lost that state I guess
07:35:23 <serishema> quicksort maybe.
07:35:35 <LoganCapaldo> oh that one
07:35:54 <LoganCapaldo> I have a online merg sort :)
07:35:57 <LoganCapaldo> sort
07:36:08 <serishema> I remeber being told it wasn't very good
07:36:36 <LoganCapaldo> s/online/one line/
07:37:23 <serishema> don't you need the mergesort [] = [] line incase they sort an empty set?
07:37:26 <fasta> Can you explain why like >70% of the "random Haskell code" I see is written in an algorithmically insane way? It seems either those people are clueless or Haskell somehow encourages the misuse of lists and bad algorithms.
07:37:51 <fasta> This "random code" is written for "European research projects" in some cases.
07:38:00 <allbery_b> -cafe has had at least one thread about haskell supposedly encouraging the inappropriate use of lists
07:38:16 <Philippa> fasta: it definitely encourages misusing lists
07:38:26 <Philippa> I mean, I do it all the time, and I certainly know better
07:38:38 <Philippa> the algorithmic insanity is mostly "I just need something that works for now"
07:38:39 <fax> I bet I do right
07:38:43 <fax> I don't know a better way though
07:39:03 <fax> How can someone make sure to not misuse lists?
07:39:13 <mrd> misuse lists in what way?
07:39:16 <mrd> indexing into them?
07:40:05 <fasta> I use cycle [True, False] to act as a loop controller. I am assuming that's optimized away by the compiler, but since the compiler output is so opaque, I don't know for sure.
07:40:20 <dons> ok.
07:40:40 <mrd> sounds fine to me
07:40:51 <dons> the list has 2 elements, cycling it just links the ends together
07:41:15 <serishema> there are explicit loops in haskell?
07:41:21 <mrd> explicit recursion
07:41:22 <fasta> dons: the equivalent would be to write a loop that NOT's its argument.
07:41:28 <dons> there's recursion, and foldl, map, for, etc.
07:41:46 <dons> fasta: seems to be a constant factor though. what's the issue?
07:41:49 <fasta> dons: but I would hope that the compiler sees that or that there's an easy way to write a rule for that in some way.
07:41:54 <dons> you trying to optimise some low level code?
07:42:18 <fasta> dons: I would like to program in a language that does these things for me, s.t. I don't have to.
07:42:28 * serishema just looked up map and thinks its cool. 
07:42:37 <mrd> there is no overhead beyond a 2-elem list.  if you're worried about cache-coherency, well, maybe then
07:42:38 <scook0> serishema: there's always forM_ ;)
07:42:49 <dons> fasta: wouldn't we all: main = do it
07:42:57 <Philippa> SexStick: please change your nick, it's not appropriate for this chan
07:43:12 <dons> well spotted Philippa
07:43:17 <xerox> fasta: you could rewrite that as two mutually recursive definitions such as f True x = x : f False x; f False x = (x+1) : f True x
07:43:27 --- mode: ChanServ set +o dons
07:43:33 --- kick: SexStick was kicked by dons (change your nick please)
07:43:35 --- mode: ChanServ set -o dons
07:43:39 <dons> i counted to 20
07:43:50 <Philippa> heh
07:45:38 <fasta> dons: can one express that in the GHC rules language? Or more generally, is the rules language Turing-Complete?
07:45:45 <allbery_b> http://xkcd.com/322
07:45:47 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
07:46:02 * serishema bounces
07:46:30 <dons> fasta: i think so, and no.
07:46:49 <dons> f [True,False] = g .. something here ..
07:52:55 <kayess> I guess I can't have something like let f a = ...; f (a:[]) = f a; etc. without some sort of type declaration? Or is it not possible at all?
07:54:14 <doserj> not possible at all
07:54:54 * allbery_b looks confused
07:55:30 <kayess> OK thanks. That stops me from trying to work out which X solves "X a => a -> String" where I want Int or [Int]
07:55:54 <allbery_b> oh, I get it
07:56:03 <doserj> :t show
07:56:11 <lambdabot> forall a. (Show a) => a -> String
07:56:16 <allbery_b> although, maybe typeclass hackery
07:56:18 <kayess> I got the show, but I need to pre-process first
07:57:21 <kayess> Maybe it should be show anyway....
07:58:36 <kayess> Actually I'm pretty sure my idea is stupid to start with. Need to think a bit more
07:59:03 <Saizan> allbery_b: for simple type-recursion like that just normal use of typeclasses is fine, i think
08:00:18 <dbueno> Is there a simple way to turn an instance of Control.Monad.State.Lazy.State into a Reader?
08:01:20 <LoganCapaldo> instance MonadReader State where ask = get ?
08:01:28 <LoganCapaldo> @src MonadReader
08:01:28 <lambdabot> Source not found. Wrong!  You cheating scum!
08:01:37 <LoganCapaldo> Is there even such a class
08:01:45 <dbueno> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
08:01:46 <Saizan> yes there is
08:01:47 <lambdabot> http://tinyurl.com/y5j3az
08:02:20 <LoganCapaldo> and of course you could ReaderT State
08:02:58 <Saizan> dbueno: what do you want to do with this?
08:02:59 <LoganCapaldo> or maybe you want to use RWS instead
08:03:17 <dbueno> Saizan: I have a state I'm passing around mutually recursive functions, but one of those functions will never alter the state.
08:03:26 <dbueno> I'd like to encode that fact into the types of that function.
08:03:48 <dbueno> So before I call it, I'll stuff the state into a Reader, and write the function in terms of a Reader.  Does that make sense?
08:04:03 <Saizan> dbueno: ok, right, so you want that function to have a type like MonadReader r m => .. -> m a
08:04:19 <EvilTerran> could you just pass the state in as a parameter to that function?
08:04:43 <dbueno> EvilTerran: Yes, but then the compiler doesn't check for my that I haven't frobbed the state.  That's the point.
08:04:49 <dbueno> Saizan: That sounds about right.
08:04:56 <EvilTerran> hm.
08:05:19 <LoganCapaldo> dbueno: make it a pure function
08:05:29 <LoganCapaldo> foo :: s -> bar
08:05:38 <EvilTerran> then liftM foo bar
08:05:42 <EvilTerran> er, liftM foo get
08:06:00 <LoganCapaldo> word
08:06:13 <Saizan> dbueno: then you just make an instance MonadReader r (State r)
08:06:16 <dbueno> LoganCapaldo,  Hm.  Right.
08:06:36 <EvilTerran> Saizan, ooh, that's clever
08:06:46 <dbueno> LoganCapaldo:  Perhaps I'm missing the point of MonadReader?
08:06:51 <EvilTerran> although, would it work with local?
08:06:57 <LoganCapaldo> I dunno
08:06:59 <EvilTerran> i guess you could fankle it manually
08:07:06 <LoganCapaldo> I could be missing the point of monad reader
08:07:31 <dbueno> LoganCapaldo: Oh, right.  Ican't make it a pure function because it *has* to read the state.
08:07:37 <dbueno> It just will never alter it.
08:07:53 <dbueno> Oh. Wait.  YOu said s -> a
08:07:56 <dbueno> Sorry.
08:07:58 <LoganCapaldo> yeah but if it never alters the state you can pull out the state first
08:07:59 <EvilTerran> dbueno, why not get the state and pass it as a parameter?
08:08:00 <Saizan> EvilTerran: local f m = do x <- get; put (f x); a <- m; put x; return a
08:08:33 <EvilTerran> hm. true.
08:09:11 <LoganCapaldo> I think Reader is more for when you are passing the env to more functions than you are not passing it to
08:09:12 <chessguy> er, what line do i need in my program to allow MPTCs?
08:09:29 <EvilTerran> {-# LANGUAGE MultiParamTypeClasses #-}, iirc
08:09:37 <LoganCapaldo> if its just this one lonely little guy it seems to make way more sense to just make it parameter
08:09:54 <Saizan> i think the point is: if in this readonly function you need to read the state from different parts (such that you would use the Reader monad) then my approach might be prettier, if not just pass the state explicitly to a pure function
08:10:12 <chessguy> works for me. thanks, EvilTerran
08:10:26 <EvilTerran> yeah, that's the one. i think {-# OPTIONS -fglasgow-exts #-} works too, but also enables a load more stuff
08:10:55 * EvilTerran prefers to do everything in {-# LANGUAGE #-} rather than the equivalent {-# OPTIONS #-} when possible
08:11:20 * LoganCapaldo is too lazy for that
08:11:34 <LoganCapaldo> or perhaps i should say, I'm too strict
08:11:43 <LoganCapaldo> pull in way more stuff than I need :)
08:11:58 <dbueno> Saizan: So I could get it to work with instance MonadReader s (State s), as you said?
08:12:01 <EvilTerran> this way, i'm painfully aware of which extensions i'm using
08:13:48 <Saizan> dbueno: yes, your type will be MonadReader r m => .. m a and not Reader r a, however
08:14:40 <dbueno> Saizan, Okay.
08:15:08 <LoganCapaldo> heh
08:15:26 <LoganCapaldo> StateT s m is already an instance
08:15:46 <Saizan> LoganCapaldo: but with a MonadReader r m context i presume
08:15:46 <LoganCapaldo> if you use StateT Identity instead of State you don't have to write any code :)
08:16:08 <LoganCapaldo> oh dudh
08:16:11 <LoganCapaldo> you're right
08:16:21 <LoganCapaldo> iiiiignore me :)
08:17:20 <chessguy> @src Enum
08:17:20 <lambdabot> class  Enum a   where
08:17:20 <lambdabot>     succ                     :: a -> a
08:17:20 <lambdabot>     pred                     :: a -> a
08:17:20 <lambdabot>     toEnum                   :: Int -> a
08:17:20 <lambdabot>     fromEnum                 :: a -> Int
08:17:22 <lambdabot> [3 @more lines]
08:17:28 <chessguy> @more
08:17:28 <lambdabot>     enumFrom                 :: a -> [a]
08:17:28 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
08:17:28 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
08:17:48 <fax> > enumfromTo False True
08:17:50 <lambdabot>   Not in scope: `enumfromTo'
08:17:54 <fax> :/
08:18:13 <dmwit> > enumFromTo False True
08:18:14 <lambdabot>  [False,True]
08:18:21 <dmwit> capitalization
08:18:40 <chessguy> > enumFromTo False False
08:18:41 <lambdabot>  [False]
08:22:15 <Olathe> @pl isn't so good
08:22:16 <lambdabot> isn't so good
08:22:42 <dmwit> hahaha
08:23:00 <Olathe> > let a [] = 0; a (x:xs) = 1 + (a xs) in a [1, 2]
08:23:01 <lambdabot>  2
08:23:06 <Olathe> @pl let a [] = 0; a (x:xs) = 1 + (a xs) in a
08:23:06 <lambdabot> (line 1, column 7):
08:23:06 <lambdabot> unexpected "["
08:23:06 <lambdabot> expecting pattern or "="
08:23:34 <dmwit> length
08:23:38 <dmwit> Do I win?
08:23:40 <Olathe> @pl let a xxs = if (a == []) then 0 else (1 + (a (tail xxs)) in a
08:23:41 <lambdabot> (line 1, column 58):
08:23:41 <lambdabot> unexpected reserved word "in"
08:23:41 <lambdabot> expecting variable, "(", operator, "+", "-" or ")"
08:23:54 <Olathe> @pl let a xxs = if (a == []) then 0 else (1 + (a (tail xxs))) in a
08:23:54 <lambdabot> fix (ap ((.) . flip if' 0 . ([] ==)) (((1 +) .) . (. tail)))
08:24:02 <Olathe> It can do that, but not the original.
08:24:05 <dmwit> @pl \a xxs -> if (a == []) then 0 else (1 + a (tail xxs))
08:24:05 <lambdabot> ap ((.) . flip if' 0 . ([] ==)) (((1 +) .) . (. tail))
08:24:25 <Olathe> length is nice for this specific example, but not for @pl in general.
08:24:54 <iruew> I'm having trouble making an instance of a class using a list, anyone know what I'm doing wrong here?: http://hpaste.org/2990
08:25:47 <EvilTerran> what's the error?
08:26:07 <iruew> Syntax error in instance head (variable expected)
08:26:12 <EvilTerran> oh, wiat, it's in the comment. ignore meh.
08:26:16 <Saizan> iruew: in haskell98 you can't make an instance for [Int], only for [a], i.e. you can have only one type constructor and type variables
08:26:46 <EvilTerran> time to break out the -fglasgow-exts?
08:26:57 <bens> Saizan: is there a work around? I bumped into this today.
08:27:16 <EvilTerran> or, alternatively, newtype ListOfInt = LoI [Int]; instance ClassA ListOfInt where f _ = 0
08:27:17 <Saizan> bens: are you using hugs?
08:27:21 <bens> ghc
08:27:33 <Saizan> ah use -fglasgow-exts then
08:27:47 <bens> cool, thanks
08:28:07 <EvilTerran> newtypeing's the work-around. fglasgow-exts is the proper fix. ;)
08:28:12 <Saizan> EvilTerran: the LANGUAGE pragma is FlexibleInstances?
08:28:21 <EvilTerran> I don't know, for that one
08:28:29 <EvilTerran> @docs Language.Haskell.Extensions
08:28:29 <lambdabot> Language.Haskell.Extensions not available
08:28:31 <EvilTerran> @docs Language.Haskell.Extension
08:28:31 <lambdabot> Language.Haskell.Extension not available
08:28:47 <EvilTerran> yes, that seems likely, though
08:29:06 <EvilTerran> similarly, FlexibleContexts if you want to do the same trick in class contexts
08:29:22 <LoganCapaldo> ghc seems like a much nicer language than haskell98 :)
08:29:36 <iruew> Saizan, but what if I want to do something like this?: http://hpaste.org/2991
08:29:41 <bens> Saizan: I thought a newtype would do it, but having an extra constructor would have defeated the point of using the type class.
08:29:43 <iruew> I don't need to specify the data type?
08:30:32 <bens> I'll give -fglasgow-exts a whirl then. Hmm, it might be good to mention that flag in the error.
08:30:34 <EvilTerran> same problem, iruew. use a newtype, {-# LANGUAGE FlexibleInstances #-}, or -fglasgow-exts
08:33:16 <Saizan> the point is that having an instance for [T] easily leads to overlapping instances
08:35:59 <sorear> it's also just plain forbidden by the standard
08:38:06 <iruew> so something like this is what I should be doing?: http://hpaste.org/2992
08:40:14 <scook0> iruew: incidentally, you can use the "annotate" link to post stuff below an existing paste
08:40:31 <iruew> oh, sorry, thanks
08:41:22 <Saizan> iruew: yes, if you don't want to enable extensions
08:41:34 <hpaste>  chessguy pasted "not sure what the best design decision here is" at http://hpaste.org/2993
08:42:00 <chessguy> i'm trying to write a generalized typeclass structure for chess engines
08:42:30 <chessguy> so, it makes sense to have a function like moves :: m -> p
08:42:40 <fasta> chessguy: you should first write a specific one and then decide what to generalise, I think, unless you have a very good feeling for the domain(in which case you wouldn'.
08:42:45 <fasta> 't ask here)
08:42:46 <hpaste>  Saizan annotated "(no title)" with "this should also work" at http://hpaste.org/2992#a1
08:43:03 <chessguy> fasta, i have a very good feeling for the domain
08:43:51 <chessguy> fasta, i've written and read a lot of chess engine code
08:44:46 <fasta> chessguy: ok, then you should be in the best position to decide whether it is sane, or provide more details.
08:45:02 <LeCamarade> chessguy: So your name is literally ... Chess Guy?
08:45:05 <LeCamarade> :o)
08:45:46 <chessguy> what i'm not sure of is this: from a perspective of writing a useful alphabeta, it would be nice to have a tree of moves, as i have here. but from the persepective of the implementer, it makes more sense to define a moves function like p -> [m]
08:45:52 <chessguy> (as i have in the typeclass)
08:46:07 <chessguy> wow LeCamarade, you picked up on that one quick
08:46:31 <twanvl> What is the point of the Move class, how is it better than just a data type?
08:46:54 <chessguy> twanvl, it allows for different implementations of Move
08:47:18 <chessguy> twanvl, because different board representations may require different data structures for the move
08:48:13 <chessguy> and indeed, there may even be multiple useful move representations for a single board representation
08:48:55 <twanvl> Could you give an example? I can't think of anything besides (Square,Square), or a datatype that contains the same
08:49:25 <fax> Int
08:49:29 <chessguy> twanvl, well, that wouldn't be very useful in the case of promotions, for example
08:49:33 <ericlavigne> A move class should be flexible enough to work with games other than chess, which further makes me wonder whether what you are creating already exists.
08:50:30 <ericlavigne> Surely someone has already implemented alpha beta search in Haskell.
08:50:42 <chessguy> ericlavigne, i agree, but that's the point where i'm out of my area of expertise, and would take fasta's advice to generalize later
08:50:57 <chessguy> ericlavigne, indeed they have, but not quite like this
08:51:27 <chessguy> (where the type of board structure is parameterized)
08:52:23 <chessguy> also, while i've seen numerous implementations of AB in haskell, i've never seen a useful one that i like
08:52:59 <twanvl> chessguy: Then you need a datatype representing moves like: data Move = Move Square Square | Promotion .. | Castling .., why would you ever need something else?
08:53:35 <chessguy> twanvl, there's also the issue of, for example, ease of ability to tell whether a move is a capture, or a pawn move, or...whatever else
08:54:14 <chessguy> twanvl, these issues come up all the time later when selecting moves to investigate
08:54:24 <ericlavigne> Not that I'm necessarily recommending this, but a later implementation of Move might include strategic moves, rather than physical moves.
08:54:58 <fasta> I like the Linux kernel approach to generalization.
08:55:00 <ericlavigne> Starting a certain chess opening could be considered a move, with several counter moves that are worth considering.
08:55:20 <fasta> Only generalize those things for which there's an actual use.
08:56:12 <b_jonas> the problem with the linux kernel is that it's not generalizing (I'd say abstracting) useful things
08:56:14 <chessguy> i have every intention of using this extensively
08:56:17 <b_jonas> like some hardware interface
08:56:47 <b_jonas> till a few years ago, gpm and X both contained mouse drivers for example
08:56:58 <b_jonas> whereas now there's only one in the kernel
08:57:04 <ericlavigne> I agree with fasta on this. Even if I expect something to be generalized more, I often put the generalization off until later. That way I get the experience that will help me to choose the right abstractions. In other words, lazy evaluation is good for programmers too, not just their programs.
08:57:06 <b_jonas> but there are still areas where linux sucks here
08:57:42 <chessguy> ericlavigne, i have particular reasons for wanting this generalization now
08:57:46 <b_jonas> the sound driver interface sucks as well
08:57:49 <b_jonas> and lots of other things
08:58:16 <b_jonas> and the story with cd-writers, sata, and scsi is a schame as well
08:58:19 <fasta> b_jonas: I was referring to the idea(which one of the kernel developers talked about in some article). I don't actually know that much of the Linux kernel.
08:58:27 <ericlavigne> chessguy, I have no interest in pushing you in any particular direction. I am just curious to hear your reasons. Why do you want that generalization now?
08:58:44 <fasta> ericlavigne: he said he already tried several versions
08:58:52 <b_jonas> I mean, linux started off as a hack and at that stage, it made sense to only support common pc hardware
08:59:01 <b_jonas> but we're over that stage
08:59:06 <b_jonas> it's slowly getting beter though
08:59:20 <ericlavigne> fasta: versions of the alpha beta function? or versions of a chess program?
08:59:37 <fasta> ericlavigne: I think both.
08:59:52 <chessguy> ericlavigne, suffice it to say...i'm interested in automatic generation of chess engines. in which case it's nice to have much existing machinery in place
09:00:08 <fasta> Finding uses of Num(m Int) sucks...
09:00:17 <b_jonas> (btw, bsd folks refer to this when they praise their os)
09:00:23 <ericlavigne> chessguy: that sounds like a fun problem :)
09:00:30 <chessguy> ericlavigne, it is indeed
09:00:44 <fasta> b_jonas: BSD people also claim that problems do not exist.
09:01:05 <b_jonas> sure
09:01:16 <fasta> b_jonas: e.g. a keyboard crashing a kernel, and still claiming it's "rock-solid".
09:01:40 <dons> fasta: are you trolling? :) or just making random generalisations?
09:01:41 <fasta> And a few weeks later "Oh, yeah, we fixed that"...
09:01:51 <b_jonas> I'm a linux user, though I respect bsd
09:01:53 <araujo> dons, hi!
09:01:54 <fasta> dons: random generalizations
09:02:01 <chessguy> ericlavigne, i've been pondering a new type of chess engine design process for...oh, several years now
09:02:04 <fasta> dons: aren't they the best!?!?!?! ;)
09:02:07 <b_jonas> should we transit to #haskell-blah?
09:02:11 <dons> yes.
09:02:15 <dons> hey araujo
09:02:18 <chessguy> b_jonas, please
09:02:34 <araujo> dons, can we get lambdabot in here #haskell.es again? :-)
09:03:36 <chessguy> @src Num
09:03:36 <lambdabot> class  (Eq a, Show a) => Num a  where
09:03:36 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:03:36 <lambdabot>     negate, abs, signum     :: a -> a
09:03:36 <lambdabot>     fromInteger             :: Integer -> a
09:04:02 <sclv> chessguy: can't you find some sort of structure that gives you both?
09:04:15 <chessguy> oh that's right, i noticed this the other week. you can have a Num instances that's not an instance of Ord. very strange
09:04:16 <ericlavigne> @src Integer
09:04:16 <lambdabot> data Integer = S# Int#
09:04:17 <lambdabot>              | J# Int# ByteArray#
09:04:26 <chessguy> sclv, both what?
09:04:32 <ddarius> chessguy: Complex ...
09:05:18 <chessguy> @hoogle Complex
09:05:19 <lambdabot> Complex :: module
09:05:19 <lambdabot> Data.Complex :: module
09:05:19 <lambdabot> Data.Complex.Complex :: data Complex a
09:05:22 <ddarius> That said...
09:05:46 <ddarius> > (1 :+ 2) < (3 :+ 4)
09:05:47 <lambdabot>   add an instance declaration for (Ord (Complex t))
09:05:47 <lambdabot>     In the expression: (1...
09:05:51 <ddarius> Good.
09:06:06 <sclv> chessguy: just trying to wrap my head around what you're doing. you've got  a positionmove that has a moves function that yields a list of possible moves, and also a way to represent future moves from a position as a tree, right?
09:06:19 <sorear> @join #haskell.es
09:06:28 <chessguy> sclv, correct
09:06:38 <sclv> so the question you're trying to resolve is which representation to use? or the type of alphabeta?
09:07:26 <chessguy> sclv, well, the simplest, moste useful way to write alphabeta is with the type signature i have listed
09:08:03 <bakert> ?t |>
09:08:03 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:08:18 <chessguy> sclv, it returns the "PV" (principle variation -- what the engine believes is the best series of moves from the current position), and the value of the current position
09:08:24 <shachaf> @ty (|>) -- It's not defined, is it?
09:08:27 <lambdabot> Not in scope: `|>'
09:08:37 <bakert> odd.
09:08:45 <shachaf> I've seen it defined as (flip ($)).
09:08:58 <bakert> storeEntry entry = withPastes $ modify (|> [entry])
09:08:59 <chessguy> @type flip ($)
09:09:01 <lambdabot> forall a b. a -> (a -> b) -> b
09:09:34 <shachaf> As in "x |> f |> g |> h" == h (g (f x))
09:09:51 <shachaf> But that doesn't make sense here.
09:10:01 <sclv> chessguy: so the issue you're trying to resolve, though.. the choice you want to make is that maybe a fancier representation of alphabeta is in order?
09:10:02 <bakert> It's used in hpaste but does not seem to be defined in there.
09:11:01 <chessguy> sclv, well, the issue is that i've designed the typeclasses to be very natural for the chess engine implementer to instantiate, but there's a conflict between that and the type signature i want for alphabeta
09:11:11 <ddarius> @hoogle (|>)
09:11:11 <lambdabot> Did you mean: (|>)
09:11:12 <lambdabot> Prelude.undefined :: a
09:11:12 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
09:11:23 <ddarius> Bloody Hoogle
09:11:27 <ddarius> @index (|>)
09:11:27 <lambdabot> bzzt
09:11:37 <ddarius> Anyways, it should be defined in Data.Sequence
09:11:54 <shachaf> Oh, right.
09:12:02 * shachaf remembers now.
09:13:12 <Saizan> bakert: (|>) is from Data.Sequence
09:13:13 <chessguy> @where shyfp
09:13:13 <lambdabot> I know nothing about shyfp.
09:13:16 <chessguy> @where whyfp
09:13:17 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
09:13:32 <sclv> chessguy: not sure if i see the conflict?
09:13:37 <bakert> Saizan: thanks
09:13:48 <sclv> chessguy: (i am probably being dumm)
09:14:01 <chessguy> sclv, not necessarily.
09:14:30 <chessguy> sclv, so, the most natural tree to construct using moves :: p -> [m] is a tree of positions
09:15:08 <chessguy> where one position being a child of another means there is a legal move in the parent position that will result in the child position
09:15:30 <chessguy> but such a tree is not useful when what you want back from AB is the moves
09:15:55 <chessguy> you could store (position, move) pairs in the tree, but it quickly gets ugly
09:16:15 <sclv> chessguy: but the problem is that ab needs to evaluate the positions to "score" them or whatever, right?
09:16:43 <chessguy> sclv, that's not precisely the problem. because if you have the moves in the tree, you can easily get the position
09:18:35 <sclv> chessguy: could you write some function to just convert the positions back to the moves?
09:19:09 <sclv> or construct a datastructure that made storing position, move pairs seamless?
09:19:17 <Qerub> Is there any way to use local functions (defined with /where/) together with a function defined with many pattern matchers?
09:19:39 <Qerub> Er. Bad question. Let me write an example.
09:19:42 <chessguy> sclv, as in diff :: position -> position -> move?
09:19:58 <ddarius> Torsors, ho!
09:20:16 <sclv> yep -- essentially a function to produce the derivative of a list of positions
09:22:02 <chessguy> an interesting idea
09:22:18 <Qerub> Here we go: http://hpaste.org/2994
09:22:18 <Qerub> What's the nicest way to make /foobar/ accessible from those four defs but not from outside?
09:22:49 <ddarius> Qerub: You can just check the announce checkbox (or rather leave it checked) to have it announce it in this channel.
09:22:53 <allbery_b> I thought where worked that way anyway
09:23:11 <allbery_b> because pattern match defs like that desugar to a single function with a case
09:23:38 <ddarius> Qerub: Anyway, define a local function generateAlignments' that does it and have generateAlignments = generateAlignments' where ...
09:24:29 <Qerub> ddarius: Okay, I'll announce it that way next time.
09:24:42 <ddarius> wheres scope over guards not over patterns.  You can use the bound variables in the where.
09:24:50 <Qerub> allbery_b: Unfortunately not.
09:25:00 <ddarius> It would be insanity if it did.
09:25:07 <ddarius> Or useless.
09:25:15 <Qerub> s/^Unf/F/
09:25:16 <Qerub> :)
09:25:32 <Qerub> ddarius: I'll do it that way. Thank you.
09:29:27 <twanvl> chessguy: Another option is to store the moves in the position type, so you have  data WithMoves m p = WithMoves [m] p; instance Position p => Position (WithMoves m p)
09:30:05 <chessguy> hmm
09:30:17 <twanvl> Then the alphaBeta and moveTree functions only need to worry about positions, and if you want you can easily get back the move(s) that led to that position
09:30:35 <chessguy> interesting
09:35:16 <hpaste>  chessguy annotated "not sure what the best design decision here is" with "twanvl, like this?" at http://hpaste.org/2993#a1
09:36:34 <chessguy> err, typo on the data declaration
09:36:45 <chessguy> i missed the p at the end
09:38:02 <chessguy> twanvl, wouldn't alphabeta then have to make sure it got a WithMoves, and not a regular position?
09:39:10 <sek> i'm trying to write a parser that consumes anyChar up to a ";" or a "}", but without actually consuming the ; or }. Am i being stupid in thinking this isnt simple?
09:39:12 <twanvl> It could work with any position, I think. Maybe you should leave keeping track of the moves up to the position type entirely. Let me try something...
09:40:06 <fax> sek: Make it any char except ";" or "}"
09:40:46 <sek> > parseTest (manyTill anyChar (semi <|> string "}")) "abc;"
09:40:47 <lambdabot>   Not in scope: `string'
09:41:03 <sek> that returns "abc", but also consumes the ; unfortunately
09:41:49 <fax> > parseTest (noneOf "{;") "abc;"
09:41:50 <lambdabot>   Not in scope: `noneOf'
09:41:54 <fax> >:|
09:42:17 <chessguy> > :|
09:42:18 <lambdabot>   parse error on input `:|'
09:42:31 <fax> What is going on here?
09:42:51 <chessguy> fax, the bot doesn't have parsec in scope
09:42:56 <chessguy> @type noneOf
09:42:58 <lambdabot> Not in scope: `noneOf'
09:43:14 <sorear> fax: besides, parseTest is IO
09:43:48 <chessguy> @hoogle parseTest
09:43:49 <lambdabot> Text.ParserCombinators.Parsec.Prim.parseTest :: Show a => GenParser tok () a -> [tok] -> IO ()
09:43:49 <fax> > Text.ParserCombinators.Parsec.parse (Text.ParserCombinators.Parsec.noneOf "{;") "" "abc;"
09:43:49 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.noneOf'
09:44:13 <fax> arugh
09:44:17 <fax> @botsnack
09:44:17 <lambdabot> :)
09:45:33 <sek> ah
09:45:48 <sek> many1 (noneOf ";}"); seem to be it
09:46:38 <sek> thanks:)
09:49:10 <sek> fax, and since you know parsec, i asked before about using a lexer to skip over whitespace and/or comments at the beginning of a file. Any ideas?
09:50:25 <fax> Well what I've done is, use parsec to read a [Char] into a list of tokens (at this stage things like comments are removed) say [FooToken], then write another parse to parse [FooToken] into [FooAST]
09:51:03 <fax> I think this way is a little bit easier than trying to parse a String right into an AST in one step
09:52:06 <sek> hmm, can;t I use a neat combination of my lexer with something?:p
09:52:40 <fax> My idea is to use Parsec to Lex as well as to Parse
09:53:09 <fax> (but in two stages)
09:53:45 <sek> well it's all done for me using makeTokenParser, so i'm not sure i follow
09:54:05 <chessguy> twanvl, your lengthy pause is frightening me :)
09:54:29 <sek> my lexer skips whitespace and comments after parsing something of essence. If the file starts with comments though then i'm in trouble
09:55:03 <fax> Why?
09:56:07 <jcreigh> grr. all darcs repos should be "darcs send"able.
09:57:33 <sek> I have (symbol = StdToken.symbol lexer) and other such definitions. So when i read a symbol, any whitespace/comments are ignored until the next meaningfull thing
09:59:44 <pstickne> as all `do' constructs considered IO actions?
09:59:51 <sorear> no way
10:00:01 <sorear> > do { x <- [1,2,3]; return (2*x) }
10:00:03 <lambdabot>  [2,4,6]
10:00:18 <b_jonas> whoa. how's that typed?
10:00:23 <sorear> > (do { x <- (^2); return (2*x) })  10
10:00:24 <sek> I think i need to use this lexeme parser
10:00:24 <lambdabot>  200
10:00:41 <b_jonas> :t do { x <- [1,2,3]; return (2*x) }
10:00:43 <lambdabot> forall t. (Num t) => [t]
10:01:08 <b_jonas> what does the interpreter derive that the type is [] there?
10:01:16 <b_jonas> oh, I see
10:01:28 <b_jonas> you have a list on the right hand side of <-
10:01:29 <Japsu> @instances Monad
10:01:31 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:01:39 <b_jonas> that's why
10:01:41 <b_jonas> sorry
10:01:44 <Japsu> you can use all those with the do notation
10:02:16 <pstickne> I don't understand why it is => [t] and not just t.
10:02:20 <phobes> > do { x <- [1,2];  y <- [3,4];  return [(x,y)] }
10:02:21 <lambdabot>  [[(1,3)],[(1,4)],[(2,3)],[(2,4)]]
10:03:00 <phobes> > do { x <- [1,2];  y <- [3,4];   [(x,y)] }
10:03:02 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
10:03:18 <phobes> > do { x <- [1,2];  y <- [3,4];   return (x,y) }
10:03:19 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
10:04:14 <fax> > do { x <- [1..10];  y <- [1..10];  z <- [1..10]; if (x*x+y*y==z*z) then return [(x,y,z)] else return [] }
10:04:15 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
10:04:28 <fax> > do { x <- [1..10];  y <- [1..10];  z <- [1..10]; if (x*x+y*y==z*z) then return [(x,y,z)] else [] }
10:04:29 <lambdabot>  [[(3,4,5)],[(4,3,5)],[(6,8,10)],[(8,6,10)]]
10:04:43 <phobes> > do { x <- [1..10];  y <- [1..10];  z <- [1..10]; if (x*x+y*y==z*z) then return (x,y,z) else return [] }
10:04:43 <lambdabot>  Couldn't match expected type `(t, t, t)'
10:04:51 <phobes> > do { x <- [1..10];  y <- [1..10];  z <- [1..10]; if (x*x+y*y==z*z) then return (x,y,z) else [] }
10:04:53 <lambdabot>  [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
10:05:43 <phobes> is there a Monadic way of writing [] there?
10:05:50 <phobes> zero?
10:06:20 <phobes> @instances MonadZero
10:06:21 <lambdabot> Couldn't find class `MonadZero'. Try @instances-importing
10:06:38 <phobes> @instances MonadPlus
10:06:39 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:06:53 <phobes> @source MonadPlus
10:06:53 <lambdabot> MonadPlus not available
10:06:57 <fax> > 2^3
10:06:58 <lambdabot>  8
10:07:18 <fax> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if(x^4+y^4+z^4=w^4)then return (x,y,z,w) else []}
10:07:18 <lambdabot>  Parse error
10:07:31 <fax> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if (x^4+y^4+z^4==w^4) then return (x,y,z,w) else [] }
10:07:35 <lambdabot> Terminated
10:08:16 <phobes> That just checked for any w with w^4 = 3, right?
10:08:57 <fax> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if (x^4+y^4+z^4+w^4=(x+y+z+w)^4) then return (x,y,z,w) else [] }
10:08:57 <lambdabot>  Parse error
10:09:03 <fax> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if (x^4+y^4+z^4+w^4==(x+y+z+w)^4) then return (x,y,z,w) else [] }
10:09:07 <lambdabot> Terminated
10:09:20 <fax> I think I need y<-[1..x] ? :/
10:09:33 <phobes> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if (x == 1 or y==1 or z == 1 then return (x,y,z,w) else [] }
10:09:33 <lambdabot>  Unbalanced parenthesis
10:09:41 <phobes> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if (x == 1 or y==1 or z == 1) then return (x,y,z,w) else [] }
10:09:42 <lambdabot>      precedence parsing error
10:09:42 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
10:09:57 <phobes> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if ((x == 1) or (y==1) or (z == 1)) then return (x,y,z,w) else [] }
10:09:58 <lambdabot>  Couldn't match expected type `t -> t1 -> t2 -> t3 -> Bool'
10:10:01 <phobes> :t or
10:10:03 <lambdabot> [Bool] -> Bool
10:10:16 <phobes> :t ||
10:10:18 <lambdabot> parse error on input `||'
10:10:25 <phobes> heh, what's or?
10:10:37 <phobes> :t |
10:10:39 <lambdabot> parse error on input `|'
10:10:44 <ddarius> :t (||)
10:10:45 <lambdabot> Bool -> Bool -> Bool
10:10:49 <phobes> ah
10:10:53 <phobes> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if ((x == 1) || (y==1) || (z == 1)) then return (x,y,z,w) else [] }
10:10:55 <lambdabot>  [(1,1,1,1),(1,1,1,2),(1,1,1,3),(1,1,1,4),(1,1,1,5),(1,1,1,6),(1,1,1,7),(1,1,...
10:11:05 <phobes> > do {x<-[1..];y<-[1..];z<-[1..];w<-[1..];if ((x == 2) || (y==2) || (z == 2)) then return (x,y,z,w) else [] }
10:11:08 <lambdabot> Terminated
10:11:29 <phobes> You need the stream monad to enumerate (x,y,z,w)
10:13:20 <fax> > do {x<-[1..];y<-[1..x];z<-[1..y];w<-[1..z];if ((x == 2) || (y==2) || (z == 2)) then return (x,y,z,w) else [] }
10:13:22 <lambdabot>  [(2,1,1,1),(2,2,1,1),(2,2,2,1),(2,2,2,2),(3,2,1,1),(3,2,2,1),(3,2,2,2),(3,3,...
10:13:48 <phobes> that works :)
10:14:33 <hpaste>  twanvl annotated "not sure what the best design decision here is" with "moveTree on positions only" at http://hpaste.org/2993#a2
10:15:25 <fax> > do {x<-[1..];y<-[1..x];z<-[1..y];w<-[1..z];if (x^4+y^4+z^4+w^4==(x+y+z+w)^4) then return (x,y,z,w) else [] }
10:15:29 <lambdabot> Terminated
10:15:29 <twanvl> chessguy: sorry, I had to go for a while
10:16:04 <chessguy> twanvl, no problem
10:16:39 * Heffalump waves from Freiburg
10:16:48 <phobes> > do {x<-[1..];y<-[1..x];z<-[1..y];if (x^2+y^3==z^5) then return (x,y,z) else [] }
10:16:52 <lambdabot> Terminated
10:17:00 <fax> I cant find any solutions :/
10:17:09 <mrd> workshop tomorrow ?
10:17:12 <Heffalump> yep
10:17:20 <fax> > do {x<-[1..];y<-[1..x];z<-[1..y];if (x^3+y^3+z^3==(x+y+z)^3) then return (x,y,z) else [] }
10:17:23 <sek> fax, aparently the whiteSpace parser parses whitespace AND comments, as specified in makeTokenParser
10:17:24 <lambdabot> Terminated
10:17:26 <phobes> Fun problem is to find a solution to   x^2 + y^3 == z^5 on paper
10:17:31 <twanvl> You need a different monad for that
10:18:54 <hkBst> phobes: that's easy x=1, y=1, z=5rt(2)
10:18:59 <fax> phobes: I don't know how to approach that problem :|
10:19:06 <fax> I think it has to be integers :P
10:19:07 <phobes> heh ... x,y,z naturals > 1
10:19:10 <phobes> err, >0
10:19:24 <hkBst> :P
10:19:31 <phobes> It doesn't use anything fancy
10:21:50 <dbueno> I'm using QuickCheck -- is there a way to get an infinite list of Arbitraries?  My generator needs to generate only certain values based on other generators, so I want to generate until I find an element with particular property.
10:22:55 <ddarius> dbueno: It's probably better to set up a generator that generates things with the property by construction.
10:23:36 <dbueno> The generator I'm writing is trying to do that; you mean I shouldn't write it in terms of other generators?
10:25:06 <ddarius> dbueno: You can use other generators you should just build values that have the property directly instead of generating and filtering (unless that's the only easy way)
10:25:22 <twanvl> you could probably do something like:  f = do { x <- arbitrary ; if property x then return T x else f }
10:26:35 <newsham> morning
10:29:20 <dbueno> ddarius: the easy way to bulid the values directly will give me a terrible distribution
10:29:42 <dbueno> generating and filtering should be better, and easier.
10:29:47 <dbueno> twanvl: Trying that....
10:30:43 <ddarius> dbueno: You could build them with whatever distribution you wanted.
10:34:05 <fax> I'm stuck :|
10:34:17 <fax> phobes: can you give me a clue? :p
10:34:35 <phobes> hmm ok
10:35:23 <phobes> The idea is to carefully choose your x and y so that the effect of + is nice
10:36:22 <phobes> If that's too vague I can give you a better one :)
10:37:34 <pstickne> What exactly is the difference between String and [Char]?
10:37:37 <dbueno> ddarius; You're right, I want something else anyway.  Time to think more....
10:37:49 <pstickne> Isn't a String just a list of Chars?
10:38:02 <fax> @src String
10:38:02 <lambdabot> type String = [Char]
10:38:24 <pstickne> Then why does it say String sometimes and Char at others?
10:38:27 <pstickne> err, [Char]
10:38:47 <locomalo> Hello everybody!
10:38:55 <pstickne> "it" being ghci errors/:t
10:39:01 <phobes> I'
10:39:14 <phobes> I'm guessing it won't introduce String unless that's used in the context?
10:39:26 <phobes> :t "hello"
10:39:29 <lambdabot> [Char]
10:39:35 <phobes> :t "hello" :: String
10:39:37 <lambdabot> String :: String
10:39:45 <pstickne> :t show 10
10:39:46 <lambdabot> String
10:39:54 <phobes> :t show
10:39:56 <lambdabot> forall a. (Show a) => a -> String
10:39:58 <fax> :t "foo" ++ show 10
10:39:59 <lambdabot> [Char]
10:40:04 <phobes> :t ++
10:40:06 <lambdabot> parse error on input `++'
10:40:06 <phobes> :t (++)
10:40:08 <lambdabot> forall a. [a] -> [a] -> [a]
10:40:13 <monochrom> There is no simple explanation.
10:40:38 <phobes> monochrom:  Is it not just to do with whether "String" was used in a signature?
10:40:49 <locomalo> Is Chamlers-Lava an equivalent language to ACL2, http://www.cs.utexas.edu/users/moore/acl2/
10:40:50 <lambdabot> Title: ACL2 Version 3.2
10:40:54 <locomalo> ?
10:41:13 <monochrom> I believe that is only a contributing factor.
10:42:04 <phobes> :t  ((id :: [a] -> [a]) (show 10))
10:42:06 <lambdabot> [Char]
10:42:23 <fax> phobes: Can you give me another clue please?
10:42:51 <fax> I can't think of any properties which could be nice in this context :[
10:43:10 <phobes> fax:   hehe ok, lemme think of one that doesn't spoil it
10:43:33 <monochrom> :t ("A" :: String) ++ "B"
10:43:35 <lambdabot> [Char]
10:43:53 <monochrom> :t "A" ++ ("B" :: String)
10:43:55 <lambdabot> [Char]
10:43:59 <fax> :t "A" (++ :: String -> String -> String) "B"
10:43:59 <phobes> fax:  Exponentiation is repeated multiplication.  When would the addition be the same as a multiplication?
10:44:01 <lambdabot> parse error on input `::'
10:44:06 <monochrom> (++)
10:44:10 <fax> :t "A" ((++) :: String -> String -> String) "B"
10:44:12 <lambdabot>     Couldn't match expected type `t1 -> t2 -> t'
10:44:12 <lambdabot>            against inferred type `[Char]'
10:44:15 <monochrom> err, no.
10:44:15 <fax> blerk
10:44:24 <fax> :t ((++) :: String -> String -> String) "A" "B"
10:44:26 <lambdabot> String
10:44:37 <phobes> So far these are all intuitive to me!
10:44:39 <Baughn> phobes: That's what they tell you. How /do/ you multiply three point five times, anyhow?
10:45:05 <monochrom> I'm more interested in how to multiply pi times.
10:45:14 <phobes> Baughn:  Exponentiation by naturals is repeated multiplication :)
10:45:17 <dbueno> ddarius My problem boils down to generating n distinct random numbers.
10:45:32 <phobes> Then you algebraically extend to rationals and get to reals by continuity :)
10:45:47 <Baughn> phobes: Okay. So, pi? ^_^
10:46:05 <monochrom> "get to reals by continuity" is right there.
10:46:06 <phobes> Choose a cauchy sequence of rationals approaching it... :)
10:46:28 <chessguy> @pl \x -> (x, s x)
10:46:28 <lambdabot> ap (,) s
10:46:31 <monochrom> Then extend to complex and quaternions by insanity :)
10:47:06 <phobes> Or, you just write down exp(x) and proceed formally from there
10:47:15 <chessguy> @index ap
10:47:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
10:47:16 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
10:47:21 <Baughn> And infinitesimals by... oh, never mind the infinitesimals
10:47:31 <allbery_b> by reduction, of course
10:47:32 <monochrom> exp extends all the way to arbitrary square matrices
10:47:37 <fax> personally think the complex numbers and quaternions are much simpler than the reals
10:48:03 <Baughn> Anyone who's written a FPU would agree
10:48:50 <ddarius> fax: Simpler how, or do you mean something like Complex Rational?
10:49:37 <monochrom> Complex (Cauchy Rational) or Complex (DedekindCut Rational)
10:49:51 <allbery_b> once you have the reals, putting complex or quatwrnion on top is easy?
10:50:19 <Baughn> Sure, and reals are much harder to handle than complex numbers in the first place
10:50:32 <fax> (Complex Number) is much much simpler than (Real)
10:50:42 <fax> Where Number is Integer, Rational, Real etc
10:51:07 <fax> Likewise (Quaternion Number)
10:51:17 <hpaste>  chessguy pasted "I don't understand this MPTC error" at http://hpaste.org/2995
10:51:29 <ddarius> How can Complex Real be simpler than Real, it includes them.  (It does have some pluses like the fundamental theorem of algebra and some minuses like lack of total ordering)
10:51:55 <allbery_b> like I said, once uou have the basis, putting complex or quaternion rules on top is relatively easy
10:51:57 <ddarius> Quaternions lack commutativity as well which is a pretty big minus from a simplicity stand point.
10:52:01 <Baughn> ddarius: The complexity of Real has already been sunk. You don't have to think about it to implement Complex.
10:52:03 <fax> ddarius: You need only consider the properties of Number, and not Real or Integer or Rational themselves
10:52:15 <hpaste>  chessguy annotated "I don't understand this MPTC error" with "definition of successors" at http://hpaste.org/2995#a1
10:52:35 <fax> of course this is just my opinion.. somewhere else might find it harder or easier
10:52:47 <fax> hm opinion is the wrong word
10:53:09 <ddarius> fax: Sure you have to consider the properties of Real, Integer, or Rational.  A complex over reals has rather different properties to a complex over integers.
10:54:42 <ddarius> I do agree that it is a much smaller step to go from Complex Real from Real than to Real from Rational, but it's not fair to then say that Complex Real is simpler.
10:56:28 <hpaste>  adrian neumann pasted "randomu.hs" at http://hpaste.org/2996
10:56:58 <phobes> So how do you construct the complex numbers without first constructing the reals?
10:57:35 <DRMacIver> Algebraic closure of the rationals of transcendentality degree c? :)
10:57:58 <monochrom> nice :)
10:58:49 <chessguy> @pl s p = map (mm p) (m p)
10:58:50 <lambdabot> s = liftM2 map mm m
11:02:11 <dino-> I was looking at Control.Monad source and was wondering about something.
11:02:55 <dino-> in instance MonadPlus Maybe, one definition of mplus is:
11:03:11 <dino-> xs      `mplus` _ys = xs
11:03:26 <monochrom> @src Maybe mplus
11:03:27 <lambdabot> Nothing `mplus` ys  = ys
11:03:27 <lambdabot> xs      `mplus` _ys = xs
11:04:02 <dino-> I understand Nothing plus ys is ys. But the other one confuses me.
11:04:08 <dino-> And the _ too. :/
11:04:25 <mrd> well it's not being used
11:04:32 <mrd> the _ doesn't mean anything
11:04:37 <LoganCapaldo> mplus for Maybe is just give me the first non-Nothing value
11:04:47 <dino-> mrd: Intentionally, ok. And the _ is like (this could be _ alone, but let's just name it like we don't care about it)
11:04:47 <monochrom> If I write "xs `mplus` _ = xs", do you understand?
11:04:56 <mrd> basically
11:05:11 <LoganCapaldo> if everything is Nothing give me Nothing
11:05:12 <dino-> Ok, I was thinking something like that. Expressive naming, but wasn't sure.
11:05:27 <mrd> actually that source should change
11:05:41 <phobes> fax: I fear my last clue might have mislead you ... My point is that with a certain choice of x,y it becomes very easy to combine x^2 + y^3 into a single term
11:05:43 <mrd> because for i18n purposes i think leading a name with _ means "type or module name"
11:05:56 <LoganCapaldo> I think you might be right
11:06:05 <LoganCapaldo> sounds good anyway
11:06:32 <dino-> Thank you.
11:06:46 <twanvl> mrd: ?
11:07:33 <hpaste>  chessguy annotated "I don't understand this MPTC error" with "simplified MPTC problem, but still with an incomprehensible error" at http://hpaste.org/2995#a2
11:07:51 <mrd> twanvl: not all languages have a notion of "Capitalization"
11:08:13 <mrd> that creates a problem when naming types, classes, or modules in those languages
11:08:33 <monochrom> > let f _x _y = _x + _y in f 0 1
11:08:35 <lambdabot>  1
11:08:52 <mrd> i think it's just a proposal currently
11:08:55 <shachaf> chessguy: Use class Position p m | p -> m where ..., maybe?
11:09:14 <twanvl> chessguy: All functions in an MPTC need to use both type parameters (unless you have functional dependencies)
11:09:16 <chessguy> shachaf, i was just thinking of that
11:09:30 <chessguy> heh. adding the fundep works
11:10:05 <twanvl> mrd: as far as I know the proposal is that _ becomes 'caseless', i.e. _x is a varid, _X is a typeid
11:10:32 <allbery_b> meh
11:12:41 <monochrom> Scary!
11:12:45 <fax> phobes: I don't think I can do it without a computer :[
11:13:02 <phobes> fax:  Sorry I should have given you a better hint
11:13:13 <fax> nah, I should have a better brain :p
11:13:19 <Shimei> So there's a reddit thread asking "will Haskell as a first language cause brain damage". Someone in it mentioned that there are some universities that teach intro. courses using Haskell. Anyone know which ones off the top of their head?
11:13:23 <phobes> fax:  You choose x = w^3, y = w^2
11:13:34 <Shimei> (first year CS courses, I mean)
11:13:44 <phobes> Then you get x^2 + y^3 = 2*w^6
11:13:48 <monochrom> Perhaps Bird does it in Oxford.
11:13:54 <LoganCapaldo> theres one in the uk
11:13:58 <LoganCapaldo> at least
11:14:02 <monochrom> Chalmer is also likely.
11:14:04 <LoganCapaldo> the name escapes me
11:14:14 <fax> phobes: ohhhh my
11:14:15 <LoganCapaldo> but a few coworkers had experienced that
11:14:21 <fax> phobes: ok let my try from there
11:14:23 <phobes> ok
11:14:29 <beschmi> karlsruhe/germany did
11:15:00 <monochrom> I think TV causes way more damage than any programming language, even the worst ones.
11:15:03 <beschmi> i think we started with LC, then haskell, and then java in the first year course
11:15:04 <LoganCapaldo> they didn't seem especially brain damaged
11:15:07 <Shimei> Does Chalmers even have an undergraduate program?
11:15:16 <b_jonas> LC?
11:15:21 <mrd> brain damage is relative of course
11:15:26 <ddarius> monochrom: Let's ask Dijkstra!
11:15:33 <beschmi> lambda calculus with pen and paper ;)
11:15:42 <mrd> will you be unable to function normally in a code-monkey environment after learning Haskell? with high probability!
11:16:12 <mrd> and speaking of that, is anyone familiar with using Chernoff bounds
11:16:16 * Shimei is unfortunately stuck with using Java for his courses until next year
11:16:19 <beschmi> but most people who enrolled for CS already had experience with some PLs (mostly Pascal)
11:16:30 <monochrom> E.g., if you meet someone who says "I fall asleep with books, but I can sit through video lectures for days", you are talking to a victim of TV brain damage.
11:16:30 <Shimei> We're studying predicate calculus, but it won't extend into lambda abstractions as far as I can tell.
11:16:54 <mrd> depends on the book
11:16:55 <fax> monochrom: What if they are dyslexic
11:17:02 <mrd> some authors are obnoxiously boring
11:17:03 <ddarius> monochrom: I fall asleep with books upon occasion, that's a bad thing?
11:17:14 <monochrom> They are dyslexic because of TV, maybe?
11:17:23 <monochrom> occasion is ok.
11:17:24 <mrd> TV can make you sleepy too
11:17:27 <fax> monochrom: I don't think that's possible
11:17:34 <fax> maybe it is
11:17:39 <ddarius> monochrom: I think (know) that we are using "fall asleep" in different ways.
11:17:59 <phobes> I prefer a movie to a novel
11:18:03 <mrd> i would find video lectures to be pretty boring
11:18:04 <chessguy> @pl reptree f a = node a (map (reptree f) (f a))
11:18:04 <lambdabot> reptree = fix ((ap node .) . ((.) . map =<<))
11:18:12 <phobes> I'll spend my reading time with technical books
11:18:16 <ddarius> mrd: Unless presented by Eugenia Cheng!
11:18:33 <mrd> i much prefer the real thing, if the prof is any good
11:18:34 <monochrom> I mean consistently fall asleep, or consistently can't learn from books
11:18:59 <Shimei> Books make me fall asleep too, mainly when I get stuck on a particularly hard to grok part. e.g. when Feynman goes on about entropy in computation and zero energy computation...
11:19:33 <mrd> some people seem to be able to figure out all the consequences of facts stated in a book, abstractly.
11:22:44 <monochrom> Such people are the ones realizing that books are not supposed to be read passively. There are moments you should go do some of your own investigation before continuing reading.
11:23:24 <mrd> certainly.  but an example never hurt.
11:23:24 <phobes> Like when reading a murder mystery, you should go conduct your own blood spatter experiments
11:23:27 <ddarius> Usually, for technical content, it's best to read through once and then go back and read again more "actively" (and again and again...)
11:24:08 <monochrom> Yes, the book should give examples. On top of that, you should create even more yourself.
11:24:11 <mrd> without an example (or perhaps, an expert leaning over your shoulder) there's no way to know if you are capable of correctly applying the lesson.
11:24:28 <phobes> ddarius:  I don't know about that ...  in any sufficiently dense book I quick reach a point where without understanding the priors I'm getting no value out of continuing
11:24:36 <phobes> quickly*
11:24:41 <mrd> you can try to write a proof, but then you're stuck in the circular problem of verifying your own proof which might be incorrect
11:26:08 <Shimei> Then there's always Knuth's book which has Fermat's last theorem as an exercise.
11:26:23 <nomeata> is there a library that will nicely indent a show of a complex haskell type like State {assignments = [Assignment {assName = AssName "Blatt3", maxPoints = MaxPoints 4},Assignment {assName = AssName "Blatt 1", maxPoints = MaxPoints 20}], students = [Student {studentID = StudentID "123123", password = Password "", email = EMail ""}], handIns = [HandIn {hiStudentID = StudentID "123123", hiAssName = AssName "Blatt 1", hiPoints = Points 3},HandIn {hiStudentID =
11:26:23 <nomeata> StudentID "1233123", hiAssName = AssName "Blatt 1", hiPoints = Points 10}]}?
11:26:54 <sorear> Text.PrettyPrint
11:27:06 <sjanssen> nomeata: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ipprint-0.2
11:27:08 <ddarius> phobes: True.  Then you reread again from the beginning or you do the necessary background work.
11:27:09 <lambdabot> http://tinyurl.com/3y7598
11:27:17 <ddarius> phobes: Read Toposes, Triples and Theories.
11:28:13 <ddarius> mrd: Usually it's pretty clear whether you are understanding or not.
11:28:14 <nomeata> sorear: I canât see how I would use that. Iâd expect a function "Show a => a -> String".
11:29:02 <mrd> not necessarily
11:29:10 <mrd> it's very easy to "think" that you are understanding though
11:29:21 <ddarius> mrd: Not if you actually try to do the proofs.
11:30:00 * mrd is not a big fan of hand written proofs really
11:30:15 <mrd> there's so many ways to fudge things imperceptibly
11:30:44 <ddarius> mrd: That's fine, but usually it's pretty clear whether you are missing something big or not when you work on the proof.
11:30:45 <monochrom> Join us the calculational proof crowd! :)
11:31:08 <mrd> well now my "hand-written" proofs are usually based on some kind of machine proof if i can do it
11:31:20 <mrd> mechanized*
11:31:20 <ddarius> Usually, if only "subtle" things are (unknowingly) tripping you up, you're doing pretty well.
11:32:00 <ddarius> mrd: Also, besides proofs you can try actually applying the stuff.  If you can turn it into something useful, then you probably have a good grasp on it.
11:32:13 <fax> calculational proof ?
11:32:14 <mrd> ie. examples
11:32:15 <fax> What is this
11:32:20 <mrd> which is where i started =)
11:32:45 <monochrom> Bird's books exemplify calculational proofs.
11:32:46 <ddarius> mrd: Not necessarily and further, examples that -you- make which is what monochrom said.
11:33:08 <mrd> examples where you can lookup the correct answer are much better
11:33:14 <monochrom> Fokkinga's "a gentle introduction to category theory" also has calculational proofs.
11:33:17 <ddarius> mrd: For example, you can read books on linear algebra and apply that to digital signal processing.
11:33:35 <monochrom> Ralf Hinze's papers also use calculational proofs.
11:34:14 <monochrom> Graham Hutton too.
11:34:14 <ddarius> mrd: Hence, as I said, applying it.  It is usually clear whether something is working or not in an application.  If you don't understand the Fourier transform then you won't implement it correctly or get sane results.
11:34:53 <monochrom> I particularly like Hutton's recent "let's calculate a compiler for exceptions".
11:34:57 <lament> fokkin' a!
11:35:07 <mrd> sure, but that has a simple check (assuming you mean multiplication)
11:35:12 <mrd> and a concrete application
11:35:27 <ddarius> mrd: Concrete application is exactly what I'm talking about.
11:35:35 <mrd> writing a hand-written proof which you have no way of concretely applying or checking until the TA reads it is ... annoying
11:35:40 <arcatan> 23
11:35:42 <arcatan> sorry
11:36:21 <ddarius> mrd: Hence me saying "besides proofs"
11:36:50 <mrd> ah, well, screw that other stuff =)
11:37:10 <phobes> ddarius:  RE: Toposes, Triples, and Theories-   are you recommending it or just giving it as an example of a dense tome?
11:37:26 <ddarius> phobes: Both
11:37:34 <phobes> ok thanks
11:38:13 <ddarius> It's definitely something that takes multiple readings and depending on your background you'd probably have to restart somewhere in the middle, but it's definitely good information.
11:38:42 <ddarius> Some years after I first read it when it was bewildering, I was coming back to it because it had stuff I wanted.
11:39:27 <oerjan> @docs Text.PrettyPrint
11:39:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint.html
11:39:47 <phobes> ddarius:  cool,  I've added it to my list
11:40:32 <phobes> fax:  I'm semi-afk now ... so if you have any more questions about that problem I may not answer quickly
11:41:57 <fax> phobes: I got it now, really good problem thanks :D
11:42:03 <fax> I wish I could have solved it though
11:42:28 <chessguy> @pl f 0 a b p = (s p, p)
11:42:29 <lambdabot> f = const (const (const ((,) =<< s)))
11:42:45 <chessguy> nice
11:43:08 <nomeata> sjanssen: thx for the link. I had to copy the code (it only provided a pprint :: Show a => a -> IO (), while I needed pprint :: Show a => a -> String), but it works very nicely.
11:44:35 <mudge> what's up guys?
11:44:44 <oerjan> what about Language.Haskell.Pretty?
11:46:00 <chessguy> @src Num
11:46:01 <lambdabot> class  (Eq a, Show a) => Num a  where
11:46:01 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:46:01 <lambdabot>     negate, abs, signum     :: a -> a
11:46:01 <lambdabot>     fromInteger             :: Integer -> a
11:46:43 <mudge> chessguy: thanks for the comment on my blog
11:46:44 <oerjan> except of course Language.Haskell.Parser can only take complete modules, so you cannot easily construct the data structure :(
11:46:46 <nomeata> oerjan: it seems to need a syntax tree or something. wasnât very straightforward...
11:47:01 <mudge> chessguy: what kind of server runs server-side javascript?
11:47:01 <chessguy> mudge, thanks for the interesting blog :)  sorry about the double
11:47:01 <oerjan> indeed
11:47:20 <chessguy> @pl f x y = s x + s y
11:47:20 <lambdabot> f = (. s) . (+) . s
11:47:27 <mudge> chessguy: no problem,  i removed one of them
11:47:33 <nomeata> In fact, Iâd be satisfied by something that works on the string directly, indenting subexpressions and putting list elements on their own lines. but pprint works nicely.
11:47:49 <chessguy> mudge, we have a whole server-side js-based application framework
11:48:01 <chessguy> mudge, on top of which we have, for instance, a CMS module
11:48:31 <oerjan> nomeata: perhaps using lex to split up into tokens, then treat some tokens specially...
11:48:47 <oerjan> :t lex
11:48:49 <lambdabot> String -> [(String, String)]
11:48:54 <mudge> chessguys: rad,   is this technology that you guys yourself developed?
11:49:25 <chessguy> mudge, it is indeed
11:49:38 <chessguy> mudge, www.siteworx.com
11:49:47 <fax> > lex "1+1"
11:49:49 <lambdabot>  [("1","+1")]
11:49:58 <oerjan> > unfoldr (listToMaybe . lex) "Just (a, ["test", here]) -- what?"
11:49:59 <fax> @src lex
11:49:59 <lambdabot>   Not in scope: `test'
11:49:59 <lambdabot> Source not found. You type like i drive.
11:50:14 <chessguy> mudge, the actual technology is called axiom: http://www.axiomcm.com/
11:50:18 <oerjan> > unfoldr (listToMaybe . lex) "Just (a, [\"test\", here]) -- what?"
11:50:19 <lambdabot>  ["Just","(","a",",","[","\"test\"",",","here","]",")","--","what","?","","",...
11:50:20 <lambdabot> Title: Axiom Web Content Management System
11:50:40 <fax> wtf :|
11:50:45 <fax> @index lex
11:50:45 <lambdabot> Text.Read, Prelude, Text.Read.Lex
11:50:58 <chessguy> fax, not everything is in the @src database
11:51:12 <oerjan> > unfoldr (listToMaybe . lex) "Just [\"test\"] -- simpler"
11:51:13 <lambdabot>  ["Just","[","\"test\"","]","--","simpler","","","","","","","","","","","","...
11:51:28 <oerjan> darn, it doesn't stop
11:51:35 <mudge> chessguy: interesting
11:51:48 <oerjan> also, doesn't ignore comments
11:51:49 <monochrom> stuttering!
11:51:54 <mudge> chessguy: it must be nice to work with infrastructure that you made  yourself
11:52:13 <oerjan> but i guess takeWhile (not . null) is good enough
11:52:29 <chessguy> mudge, mmmm, somewhat. except that it's still under development. and what we do have was in place long before i got here :)
11:55:49 <mudge> chessguy: got you
11:56:45 <chessguy> @src Ord
11:56:45 <lambdabot> class  (Eq a) => Ord a  where
11:56:45 <lambdabot>     compare      :: a -> a -> Ordering
11:56:45 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
11:56:45 <lambdabot>     max, min         :: a -> a -> a
12:00:35 <mudge> @remember types A good type system is like a set of tests, except they're actuallly proofs
12:00:35 <lambdabot> Done.
12:00:52 <monochrom> who is types?
12:01:12 <mudge> @quote types
12:01:12 <lambdabot> types says: A good type system is like a set of tests, except they're actuallly proofs
12:01:36 <mudge> I don't know, because I don't really know what i'm doing
12:01:46 <monochrom> types is praising himself? :)
12:01:55 <mudge> @remember mudge A good type system is like a set of tests, except they're actuallly proofs
12:01:55 <lambdabot> Done.
12:02:01 <monochrom> hehe
12:02:01 <mudge> haha,  yea,  exactly
12:02:03 * oerjan thought of the types mailing list
12:02:10 <Zevv> wow, that's a good first sentence to hear when first visiting #haskell: I don't know, because I don't really know what i'm doing
12:02:16 <Zevv> hello all :)
12:02:30 <mudge> I'm an honest beaver
12:02:37 <fax> proofs?
12:02:39 <mudge> hi Zevv
12:02:46 <fax> I thought the programs were proofs of the types >:D
12:02:47 <oerjan> Zevv: the sad thing is it was not really about haskell
12:02:52 <fax> what are types proofs of?
12:03:01 <monochrom> data invariants
12:03:02 <Zevv> oerjan: ah, that's too bad. I hoped I was not alone
12:03:14 <mudge> fax: that certain bugs don't exist
12:03:36 <mudge> a good typing system is a set of proofs that certain bugs don't exist
12:03:39 <oerjan> Zevv: i don't think you'll have trouble finding people agreeing with you on that :D
12:03:45 <monochrom> "not True :: Bool" is a conclusion drawn from a proof that the answer is a boolean.
12:04:09 <Zevv> hehe, good to know. Anyway, I'm just planning to lurk around here for some time, hoping to pick up some magic from the pro's
12:04:40 <mudge> monochrom: that's good
12:04:55 <oerjan> @users
12:04:55 <lambdabot> Maximum users seen in #haskell: 420, currently: 381 (90.7%), active: 19 (5.0%)
12:05:28 <oerjan> Zevv: judging from the fraction of inactive users, you may not be alone in that either :)
12:06:05 <Zevv> Well, that good for my self-esteem :)
12:06:13 <koala_man> haha, damn straight
12:06:13 <monochrom> The notion that types are data invariants is even more visible in imperative languages. "var x : bool" and the compiler accepting your program means that during runtime, between every pair of consecutive statements, the assertion "x is an int" holds.
12:06:44 <monochrom> err, "x is a bool" holds.
12:07:07 <fax> hmm
12:07:15 <fax> types as invariants is fine
12:07:16 <mudge> monochrom: cool
12:07:20 <fax> I can't see how it is a proof though
12:07:36 <mudge> monochrom: I didn't think of types as proofs of data invariants, but I see that is true
12:07:47 <mrd> it's a proof of the property "is a bool" for x
12:07:59 <monochrom> OK, the compiler conducts the proof (type checking), then throws it away, keeping only the conclusion that "x is bool, y is int, ..."
12:08:11 <fax> ahh ok
12:08:12 <fax> that makes sense
12:08:48 <oerjan> is there some statistic of how many users in #haskell have never spoken?
12:09:00 <mudge> @unspoken
12:09:00 <lambdabot> Unknown command, try @list
12:09:05 <mrd> @where stats
12:09:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
12:09:07 <monochrom> You can see that in the foregoing I have carefully said "assertion" and "conclusion drawn from a proof", rather than just "proof".
12:09:14 <monochrom> @quote types
12:09:14 <lambdabot> types says: A good type system is like a set of tests, except they're actuallly proofs
12:09:46 <monochrom> You can also see that the quote carefully says "a type system is a set of proofs", not "a type annotation is a proof".
12:10:02 <monochrom> Therefore, we did not lie, and we weren't sloppy either.
12:10:20 <oerjan> eek, i'm already on the list of most active nicks :D
12:10:35 <mudge> monochrom: I was sloppy, buts still right
12:11:02 <mudge> monochrom: glad I don't have to change the quote
12:12:15 <fax> "lambdabot has quite a potty mouth. 0.0% words were foul language."
12:12:19 <mudge> types praising types,   the way it should be
12:12:26 <dons> i just bumped into kolmodin on the street
12:12:40 <monochrom> Did you annihilate him?
12:12:43 <misterbeebee> I finally figured out how to join today, and now I've spoken (a useless remark)
12:13:03 <dons> hi misterbeebee
12:13:04 <mudge> misterbeebee:  join what?
12:13:12 <misterbeebee> how to join this irc channel
12:13:14 <monochrom> this is a false statement.
12:13:42 <misterbeebee> I also updated the wiki page: http://en.wikibooks.org/wiki/Haskell/Monad_transformers#Transformers_are_cousins with a change I think has the right idea but probably has some non-straight thinking and misused vocab.
12:13:43 * mrd explodes
12:13:45 <lambdabot> http://tinyurl.com/2k2jfx
12:13:53 <mudge> dons, what do you think of this statement: @quote types
12:14:00 <mudge> @quote types
12:14:00 <lambdabot> types says: A good type system is like a set of tests, except they're actuallly proofs
12:14:12 <fax> needs more l's
12:14:22 <monochrom> cousins??!!
12:14:43 <mudge> funny that types has a lisp since lisp doesn't have any types
12:14:55 <fax> lisp has types
12:14:55 <misterbeebee> "cousins" was already there. I added the bottom half of that section, after the first table.
12:15:29 <mudge> fax: I know it does,  I guess I mean it is dynamically typed
12:15:43 <mudge> at least more or less
12:16:22 <dons> seems reasonable, mudge
12:16:24 <monochrom> untyped = unityped, just like unisex :)
12:17:38 <oerjan> the statistics don't seem to answer my question of how many never spoke, though
12:18:27 <mudge> these stats are pretty cool: http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html
12:18:27 <lambdabot> Title: #haskell @ freenode.org stats by dons
12:29:20 <pgavin> @seen dcoutts
12:29:20 <lambdabot> dcoutts is in #haskell-hac07, #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 20h 31m 43s ago.
12:31:30 <mudge> dons: how hard would it be to make stats that showed how often everyone in #haskell spoke?
12:32:35 <LoganCapaldo> @where stats
12:32:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
12:32:39 <LoganCapaldo> not hard
12:32:42 <LoganCapaldo> not hard at all
12:33:55 <LoganCapaldo> oh I guess a top 25 list isn't really everyone
12:34:22 <mudge> yea, it would be neat to see a list of people in Haskell who have never spoke
12:34:28 <LoganCapaldo> but for those 25 people it does tell you number of lines and number of words
12:34:31 <LoganCapaldo> lol
12:34:33 <LoganCapaldo> heh
12:34:49 <mudge> and a list showing how often everyone has spoken
12:34:58 <mudge> yea, the statistics are pretty cool
12:35:28 <dons> mudge: probably easy
12:35:35 <mudge> if I saw a list of people who haven't ever spoken in Haskell, I'd start talking to them,  to try to get them to say something
12:36:41 <pgavin> bots
12:36:43 <pgavin> all of them
12:36:45 <pgavin> bots
12:37:16 <Zevv> So am I
12:37:22 <Zevv> prove me wrong
12:37:25 <mudge> unspeaking bots?
12:37:31 <mrd> i'm a bot
12:37:38 <mrd> moist robot
12:37:38 <mudge> I'm a bottle of fun
12:37:41 <LoganCapaldo> No I am sparticus
12:37:41 <Japsu> @bot
12:37:42 <lambdabot> :)
12:37:44 <mrd> :)
12:37:51 <mudge> :)
12:37:53 <LoganCapaldo> itsthe reverse turing test
12:37:55 <Japsu> :)
12:37:57 <Zevv> haha
12:38:09 <LoganCapaldo> some of you guys have real slow processors ;)
12:38:18 <mrd> i'm already outmoded
12:38:19 <LoganCapaldo> @btosnack
12:38:20 <lambdabot> :)
12:38:22 <mrd> :)
12:38:23 <Japsu> :)
12:38:24 <fax> :)
12:38:26 <oerjan> i would be more interested in the number of users by frequency than a complete list
12:38:26 <mudge> :)
12:38:27 <n00b> I am trying to write a function to calculate the Middle value of three numbers
12:38:30 <fax> lol
12:38:39 <oerjan> or, at least, that's what i was trying to find
12:38:43 <LoganCapaldo> hmm spellc checker didn't throw them off
12:38:50 <mrd> n00b: middle meaning "median" or "average"?
12:38:51 <n00b> exampple mid 1 2 3  =  2
12:38:51 <fax> n00b: let middle x y z = (!!1) $ sort [x,y,z]
12:38:54 <LoganCapaldo> the problem is they can all just copy lb
12:39:04 <fax> > let middle x y z = (!!1) $ sort [x,y,z] in middle 1 2 3
12:39:06 <lambdabot>  2
12:39:08 <monochrom> :)
12:39:13 <int-e> fax: uh, why not  sort [x,y,z] !! 1  ?
12:39:19 <fax> int-e: Sure
12:39:23 <mrd> it's possible to find the median value of a list in O(n)
12:39:48 <mrd> but using sort is easier =)
12:39:49 <phobes> mrd:  what's the algorithm?
12:39:52 <Zevv> n00b: what's the middle of [1,1,2] ?
12:40:00 <n00b> 1
12:40:16 <Zevv> and [1, 3, 2] is also 2 ?
12:40:31 <mrd> phobes: there's a randomized version similar to qsort but you don't need to assemble the sorted lists back together
12:40:50 <phobes> mrd:  Is there a worst case O(n) algorithm?
12:40:56 <mrd> there's also a deterministic version which is a bit more involved but basically involves splitting the list up into groups of 5 elements and finding the medians of those
12:40:59 <mrd> yes
12:41:31 <ddarius> fax: Late, but types are proofs of kinds
12:41:44 <fax> mh
12:41:53 <fax> I don't know what kinds are :|
12:42:01 <mrd> basically you can prove that ~3n/10 of the elements will be eliminated as possible medians each time around
12:42:03 <phobes> mrd:  Splitting up the list into groups of 5 and then applying recursively would be O(n log n), wouldn't it?
12:42:07 <jaredj> "my god it's full of *'s"
12:42:19 <n00b> Is there something easier than the sort function ?
12:42:26 <int-e> phobes: hmm. for an easy algorithm with expected linear time, have a look at quick select. there are also deterministic algorithms with O(n) worst case bound, http://www.ics.uci.edu/~eppstein/161/960130.html , also, more recently, one based on soft heaps (see wikipedia for those, it has links to papers) and probably more.
12:42:27 <lambdabot> Title: Deterministic selection
12:42:41 <n00b> easier to understand and my teacher asn't reach that topic yet
12:42:56 <mrd> and by selection i mean "k-select" for the kth element of the list. median is just a special case.
12:42:58 <oerjan> n00b: simple if then else or guards?
12:43:05 <n00b> ok
12:43:35 <oerjan> n00b: i think people just went off the deep end in their explanations as usual here :D
12:44:02 <int-e> for 3 elements all that is not relevant.
12:44:13 <ddarius> :k Int
12:44:15 <lambdabot> *
12:44:43 <n00b> I think the median might work
12:44:48 <n00b> @type median
12:44:50 <lambdabot> Not in scope: `median'
12:44:51 <oerjan> :k (->)
12:44:53 <lambdabot> ?? -> ? -> *
12:45:06 <n00b> @google median
12:45:09 <lambdabot> http://en.wikipedia.org/wiki/Median
12:45:09 <lambdabot> Title: Median - Wikipedia, the free encyclopedia
12:45:31 <n00b> Is median a in-built function
12:45:38 <monochrom> No.
12:45:53 <mrd> haha yea, deep-end
12:45:59 <n00b> so how do I write a function for it???
12:46:03 <mudge> I think I finally understand Maybe
12:46:17 <mrd> sort n !! (length n `div` 2)
12:47:13 <monochrom> KISS. Since there are only three numbers, do the most naive thing.
12:47:38 <phobes> int-e - thanks, makes sense
12:47:39 <misterbeebee> heh, heh, k-select was a phone-screen question on my interview for my current job. I didn't come up with the "desired" solution, because I didn't like the randomness of quickselect for the problem as worded to me.
12:48:14 <lapthrick> http://en.wikipedia.org/wiki/Monads_in_functional_programming#Definition
12:48:16 <lambdabot> http://tinyurl.com/y586b9
12:48:27 <lapthrick> isn't 3. wrong in having 4 steps?
12:48:37 <n00b> can I use guards to fkind the middle value
12:48:38 <n00b> ??
12:48:40 <lapthrick> the double assembly there is strange
12:49:12 <dons> n00b: fkind?
12:49:23 <dons> http://pinderkent.blogsavy.com/archives/133 mm
12:49:24 <monochrom> You can use anything you want. I don't understand the question.
12:49:26 <lambdabot> Title: Haskell in industry: a surprising encounter!
12:49:27 <LoganCapaldo> I think he just accidentaly hit k
12:49:35 <phobes> I've asked people to explain what's wrong with the following 'proof' of merge sort being O(n) - By induction, you can sort 1 element in O(n), obviously.    Otherwise, sort each pile in O(n/2) and combine them in O(n), for a total of O(n).
12:49:43 <mrd> anyway it works based on the fact that: computing the medians for n/5 groups is n/5 time (since median of 5-elt list is constant-time), so finding the median of the medians is T(n/5) and then you can cut out 3n/10 of the elements leaving you with T(7n/10) to process
12:49:54 <mrd> 1/5 + 7/10 < 1 so the recurrence works out to O(n)
12:50:41 <n00b> find
12:50:58 <fax> > let med a b c = (a + b + c) - min [a,b,c] - max [a,b,c] in med 1 2 3
12:50:59 <LoganCapaldo> phobes: it's circular?
12:50:59 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
12:50:59 <lambdabot>     Pro...
12:51:00 <lapthrick> phobes: it assumes exactly 2 steps are needed for arbitrary N
12:51:10 <fax> :t min
12:51:11 <lapthrick> s/N/n/
12:51:12 <lambdabot> forall a. (Ord a) => a -> a -> a
12:51:22 <fax> > let med a b c = (a + b + c) - minimum [a,b,c] - maximum [a,b,c] in med 1 2 3
12:51:24 <lambdabot>  2
12:51:27 <phobes> lapthrick:  Where did it assume that?
12:51:31 <mrd> phobes: um, where's the recurrence?
12:51:47 <monochrom> Merge sort is O(1). Base case: sorting 1 element is O(1). Induction: sorting two halves takes O(1)+O(1), the merge takes O(1).  I still have to prove merging takes O(1), but it's the same induction proof.
12:52:18 <LoganCapaldo> insta-sort!
12:52:24 <int-e> yes, for all n, merge sorting n elements is O(1).
12:52:35 <phobes> hehe yes, that's the point
12:52:57 <phobes> noone ever gave me that answer during an interview
12:53:03 <monochrom> O(n) = n*O(1) = O(1) + O(1) + ... + O(1) = O(1).
12:53:05 <mrd> T(n) = 2T(n/2) + O(n)
12:53:28 <LoganCapaldo> you should be iring from #haskell clearly
12:53:37 <phobes> clearly :)
12:53:46 <monochrom> The moral of the story is, arithmetic on O(blah) is futile. Just never do it. It's totally invalid.
12:53:49 <lapthrick> anyway, what about that wikipedia link? Is it correct?
12:54:31 <int-e> lapthrick: it's container-centric but correct.
12:55:36 <mrd> the problem is that people use = O(...) instead of \in O(...)
12:55:39 <int-e> lapthrick: (take lists. xs >>= f for lists takes all elements of xs, applies f to them, then concatenates the resulting lists - which requires "piercing" those lists to get a result.)
12:55:40 <LoganCapaldo> someone was probably thinking about the list monad when they wrote it :)
12:55:52 <mrd> then you confuse it with real arithmetic
12:55:53 <lapthrick> int-e: hmm, but that reassembly thing is not really inherent for >>= definition, right?
12:55:54 <LoganCapaldo> damn I'm slow
12:57:19 <monochrom> I dislike "n+1 = O(n)" too.
12:57:21 <int-e> lapthrick: as I said it's tied to viewing monads as containers.
12:57:41 <wnoise> mrd: yeah.   It's usually okay to simplify and say "f(x) is O(n)" when talking loosely, but actual manipulations need to be kept straight.
12:57:48 <int-e> monochrom: the use of '=' is a confusing convention.
12:57:58 <monochrom> Note: "is" doesn't have to be "="
12:58:05 <int-e> monochrom: I'd prefer  n+1 in O(n)
12:58:41 <monochrom> "n+1 is O(n)" and "a car is an object" are both perfectly fine. Both do not intend to mean "=".
12:58:49 <int-e> monochrom: and the second thing people tend to forget is that the O(n) notation is tied to a limit. In computer science it's often n -> oo; in calculus the most common is x -> 0.
12:59:32 <LoganCapaldo> lol
12:59:33 <ddarius> int-e: I don't think anyone has an issue with confusing where the limit is going to.
12:59:33 <mrd> calculus deals with infinitesimals of course =)
12:59:35 <wnoise> monochrom: yes, but people have a hard time not replacing "is" with "=".
12:59:40 <lapthrick> int-e: so removing that reassembly step won't make it incorrect?
12:59:50 <LoganCapaldo> car = object // unsafe downcast for the  win!
12:59:52 <monochrom> haskell = cool :)
13:00:02 * mrd pukes all over downcasts
13:00:15 <int-e> lapthrick: it breaks the model; the piercing is required to get from [[a]] to [a].
13:00:16 <monochrom> people should just be replaced by intelligent machines.
13:00:29 <LoganCapaldo> but I like people
13:00:29 <mrd> monochrom: or just intelligent anything
13:00:48 <monochrom> yeah, bees will do
13:00:58 <ddarius> monochrom: People are intelligent machines.  Or at least machines.
13:01:12 <mrd> input: beer
13:01:30 <mrd> i process beer in O(n) time
13:01:41 <lapthrick> int-e: mhm, okay, so I'm gonna annotate it with ">>= might possibly manipulate the result in a way that makes sense for the given monadic type"
13:01:45 <fax> people are not machines
13:01:47 <LoganCapaldo> I process beer in constant time
13:02:04 <DRMacIver> How's xmonad's xinerama support?
13:02:10 <mrd> LoganCapaldo: lower bound is O(n)! you need to at least encounter all the beer!
13:02:10 <LoganCapaldo> xerrific
13:02:18 <monochrom> this gets dangerously close to "what is your definition of machine" :)
13:02:23 <LoganCapaldo> not if you don't drink
13:02:24 <kpreid> makes sense for the given monadic type?
13:02:31 <kpreid> now, this makes me wonder
13:02:34 <LoganCapaldo> but I do so you're right
13:02:40 <mrd> LoganCapaldo: malfunctioning !
13:02:45 <monochrom> I have a great definition! A machine is a monad...
13:02:48 <fax> ddarius: How do you reason that people are machines?
13:02:54 <DRMacIver> LoganCapaldo: Really? Or could you just not resist the pun? :)
13:02:58 <lapthrick> kpreid: well, I'm gonna phrase it in a way that makes sense for the given reader :)
13:03:05 <int-e> @type join
13:03:07 <phobes> I think a Monad is more like a program for a machine
13:03:07 <ddarius> fax: How do you reason that people -aren't- machines?
13:03:12 <LoganCapaldo> DRMacIver: teh second one
13:03:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:03:16 <LoganCapaldo> I have no idea
13:03:20 <LoganCapaldo> for real
13:03:24 <kpreid> what's a type for which the definition of >>= makes the least sense from the perspective of one thinking about the intent of the data structure?
13:03:25 <sjanssen> DRMacIver: xinerama support is good
13:03:30 <DRMacIver> LoganCapaldo: Ok. I thought suo. :)
13:03:37 <DRMacIver> sjanssen: Thanks.
13:03:38 <fax> ddarius: We're capable of thought and reason no machine could ever be
13:03:47 <fax> ddarius: Now can you answer me? :p
13:03:49 <monochrom> hahahahahahahha
13:03:59 <DRMacIver> sjanssen: Just in the sense that it works with it, or does it provide nice abstractions for using it?
13:04:06 <int-e> lapthrick: what step 3 and 4 describe is really the join operation. in terms of computations "take a computation that returns a computation. return a computation that runs that computation, and then runs the resulting computation as well."
13:04:12 <LoganCapaldo> fax: if we are machines than a machine is clearly capable of that kidn of thought and reason
13:04:19 <ddarius> fax: Are you defining "machine" to simply be something not capable of thought and reason?
13:04:19 <sjanssen> DRMacIver: I think it has a nice model for multiple screens
13:04:21 <fax> LoganCapaldo: Yes but we aren't
13:04:24 <DRMacIver> (I've just got my second monitor working under linux and am discovering that gnome has only the most rudimentary support)
13:04:25 <fax> ddarius: No
13:04:31 <sjanssen> of course I'm biased
13:04:32 <ddarius> fax: Define "machine"
13:04:35 <monochrom> We're capable of such stupidity that no machine could ever be. That probably proves that we are not machines. In fact we are below machines.
13:04:42 <DRMacIver> sjanssen: Ok. Thanks.
13:04:43 <LoganCapaldo> this argument is both a) unwinnable and b) probbaly belongs in -blah :)
13:04:52 <DRMacIver> I might check it out.
13:04:57 <fax> Let's not get into the definition bit, please can you tell me why you think we are machines
13:04:58 <LoganCapaldo> imo
13:05:09 <DRMacIver> (I've been meaning to anyway)
13:05:14 <int-e> lapthrick: in terms of lists, it's concat; in terms of arbitrary containers it's taking a container filled with containers and opens all the contained containbers.
13:05:16 <fax> I'm just curious of others thoughts, I know there is not right/wrong
13:05:23 <phobes> Aren't you supposed to prove that you're not a machine with some appeal to an incompleteness theorem?
13:05:32 <ddarius> fax: Because we fit a reasonably general definition well enough.  I don't see anything special about people.
13:05:45 <lapthrick> int-e: yeah
13:05:46 <int-e> lapthrick: in the image of the wikipedia container the outermost container isn't there, because it got removed in the first step.
13:05:46 <fax> alright, yeah
13:06:15 <int-e> lapthrick: woops. the first "container" should be "model"
13:06:17 <phobes> You are as unique as a slow flake... just like everybody else
13:06:47 <monochrom> I just want to put in an observation before I stop on this subject. Human minds are just as susceptible to Godel incompleteness as formal systems. They are incomplete (a person can't prove or disprove he's sane) or inconsistent (there are lots of self-contradictory people out there).
13:08:15 <ddarius> monochrom: I believe Girard of all people has thoughts contrary to that.  It's pretty sad.
13:09:07 <phobes> Well, the argument usually isn't that people are complete, but rather than a human won't be susceptible to a particular kind of incompleteness
13:09:32 <ddarius> phobes: But we either a) are, or b) inconsistent.
13:09:46 <phobes> ddarius:  I'm not disagreeing with you
13:10:11 <phobes> but I doubt that Girard is arguing that people are complete
13:10:28 <ddarius> phobes: Computers don't need to be consistent.
13:10:57 <phobes> The law isn't consistent
13:12:09 <phobes> The argument you hear is that people should be able to recognize their own godel sentence, because they recognize the pattern of generating godel sentences, not because they can reason completely
13:13:48 <jaredj> i can't recognize my own gÃ¶del sentence
13:16:03 <LoganCapaldo> I see dead goedel sentences
13:16:40 <fax> ooh
13:16:46 <fax> that reminds me of http://jaguar.it.miami.edu/~chris/formal_methods_in_the_movies/index.html
13:16:48 <lambdabot> http://tinyurl.com/2t5wzb
13:17:42 <mudge> question: can more than one constructor exist for a value?
13:17:56 <mudge> like in this example: data Tree = Leaf Int | Node Tree Int Tree
13:18:07 <omniscientIdiot> @src Maybe
13:18:08 <lambdabot> data Maybe a = Nothing | Just a
13:18:08 <fax> you could have two different values which are Equal
13:18:09 <mudge> Leaf and Node are constructor functions
13:18:17 <phobes> fax:  Wow, that was pretty lame :)
13:18:19 <fax> different values created by different constructors
13:18:29 <LoganCapaldo> so much potential
13:18:36 <fax> phobes: what LoganCapaldo said reminded me of it :p
13:19:06 <mudge> i mean can you have something like this: data sometype = constructor constructor value
13:19:19 <kpreid> mudge: what would that mean?
13:19:20 <phobes> o.O
13:19:22 <mudge> two constructors for one value?
13:19:36 <Saizan> no..
13:19:39 <kpreid> mudge: you want to use either one? or have to apply both to get a value?
13:19:44 <fax> You just want a single constructior, which has a space in it's name
13:19:52 <mudge> kpreid: apply both to get the value
13:20:01 <kpreid> mudge: well, you can fake that
13:20:10 <omniscientIdiot> mudge: what if someone only applied one?
13:20:11 <kpreid> data Bar = Bar
13:20:11 <kpreid> data Foo = Foo Bar Int
13:20:13 <clanehin> There does not seem to be an instance of MonadReader for State, why is this?
13:20:19 <kpreid> someValue = Foo Bar 43
13:20:24 * LoganCapaldo deja vu all over again
13:20:31 <kpreid> Foo is the constructor, but you always have to apply it to Bar
13:20:56 <mudge> omniscentIdiot:  applying only one is perfectly fine,  I"m just learning the language and am curious if in haskell there can be multiple constructor functions for one value
13:20:59 <phobes> mudge:  in your example, why did you want to put "Node Tree" instead of just "Node"?
13:21:27 <kpreid> well, that example looked like a normal binary tree
13:21:53 <phobes> As written it's a trinary three with middle branch Int
13:21:54 <mudge> phobes: it's just how I copied it out of the book,   no other reason
13:21:57 <phobes> oh, nm I'm an idiot
13:22:01 <phobes> :D
13:22:06 <mudge> phobes: that's right
13:22:24 <phobes> mudge:  You mean that I'm an idiot?
13:22:26 <phobes>  :)
13:22:36 <mudge> phobes: I mean your right about this: "As written it's a trinary three with middle branch Int"
13:22:48 <phobes> which is a binary tree
13:22:49 <phobes> heh
13:22:51 <mudge> right
13:23:02 <phobes> it's just a weird way of writing it
13:23:09 <phobes> usually you only have values in the leaves
13:23:13 <mudge> really?  how would your write it?
13:23:23 <oerjan> @instances-importing Control.Monad.Reader MonadReader
13:23:24 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
13:23:32 <phobes> well, nm
13:23:33 <oerjan> clanehin: sure there is
13:23:43 <phobes> Usually you have values in the nodes... again I'm an idiot
13:23:48 <oerjan> (for StateT that is)
13:24:10 <clanehin> I see, but not State.
13:24:11 <mudge> phobes:  at least it is entertaining,   but you're not an idiot
13:24:50 <oerjan> however, that instance is for when StateT transforms something which already is a MonadReader
13:24:51 <phobes> mudge:  Haskell syntax is still not second nature
13:25:01 <mudge> phobes:  yea,  not for me either
13:25:20 <mudge> looks good,  looks like there can only be one constructor function for a value
13:26:14 <oerjan> the reason why a State is not automatically a MonadReader is that you may want to use _both_ a Reader and a State for different things
13:26:15 <mudge> I know you can do this:   data sometype = constructor type | differentconstructor type
13:26:29 <oerjan> if you have some data that changes and some that doesn't
13:26:40 <phobes> Your example shows that with Leaf and Node
13:26:45 <mudge> but you can't do this: data sometype = constructor different constructory type
13:26:58 <phobes> oh you mean same type as a constructor parameter
13:26:59 * LoganCapaldo doesn't see why you'd want to
13:27:12 <mudge> i mean: but you can't do this: data sometype = constructordifferent constructory type
13:27:14 <oerjan> e.g. there is RWS that gives you reader, writer and state in one
13:27:27 <mudge> LoganCapeldo:  me either
13:27:51 <mudge> i mean: but you can't do this: data sometype = constructordifferent constructor type
13:28:01 <mudge> sorry, I'm kind of repeating myself
13:28:11 <mudge> just getting it right
13:28:47 <mudge> or more closely I mean: but you can't do this: data sometype = constructor different constructory value
13:29:00 <mudge> fudge, I give up
13:29:08 <omniscientIdiot> @slap mudge
13:29:08 <lambdabot> why on earth would I slap mudge
13:29:14 <mudge> haha
13:29:20 <clanehin> oerjan: I'm just thinking in terms of, I want to be able to show in the type annotation that some functions are read-only
13:29:25 <LoganCapaldo> heh, data Sometype = ConstructorDifferent Sometype Int | Constructor
13:29:37 <LoganCapaldo> ConstructDifferent Construct 3
13:29:44 <LoganCapaldo> *Constructor
13:29:56 <oerjan> clanehin: oh.  i recall there was a discussion of that on haskell-cafe a while ago
13:30:13 <fax> ConstructorDifferent ConstructorDifferent Constructor 2 2
13:30:18 <fax>  you can do that then though?
13:30:40 * LoganCapaldo shrugs
13:31:10 <omniscientIdiot> ConstructorDifferent (ConstructorDifferent Constructor 2) 2
13:31:56 <int-e> this? http://sigfpe.blogspot.com/2007/09/type-of-distinct-pairs.html
13:31:57 <lambdabot> Title: A Neighborhood of Infinity: The Antidiagonal
13:32:12 <LoganCapaldo> data Some b where Cons :: forall a. b -> a -> Some b
13:32:30 <LoganCapaldo> Cons "Fun" 4
13:33:46 <LoganCapaldo> that forall is probably wrong somehow
13:34:13 <LoganCapaldo> I wish I could test type decls with lb sometimes
13:34:47 <Saizan> it just means that you cannot use the second parameter anymore, afaiu
13:35:08 <LoganCapaldo> afaiu?
13:35:13 <LoganCapaldo> understand?
13:35:13 <omniscientIdiot> @vera afaiu
13:35:15 <lambdabot> No match for "afaiu".
13:35:16 <Saizan> yes
13:35:24 <mudge> i've heard Ada is pretty good, anyone tried that out?
13:35:36 <LoganCapaldo> well that was the idea
13:36:14 <mudge> what's the name of the off topic haskell channel?
13:36:17 * EvilTerran sometimes uses AFAI with a word, if it's not a common one... same with IANA (usually L for "i am not a lawyer")
13:36:23 <EvilTerran> #haskell-blah
13:36:44 <mudge> thanks
13:39:22 <clanehin> oerjan: I found it, thanks.  (I subscribe but I must have ignored it at the time)
13:40:29 <DRMacIver> Hm. unix-2.0 from hackage fails to compile on my system
13:40:34 <oerjan> you're welcome :)
13:44:25 <jaredj> AFAIANAL
13:44:51 <jaredj> IANALAFAIR
13:45:06 <hpaste>  DRMacIver pasted "unix-2.0 doesn't compile" at http://hpaste.org/2997
13:45:36 <DRMacIver> Any thoughts on why I'm getting this error? I assume if it's an official release in hackageDB the code isn't actually completely broken. :)
13:48:50 <sjanssen> DRMacIver: the unix should already be installed on your system, anyway
13:49:21 <sjanssen> s/unix/unix package/
13:49:45 <DRMacIver> Oh, so it is. Oops. :)
13:49:46 <DRMacIver> Thanks
13:49:52 <DRMacIver> (I'm still curious about the error though)
13:51:05 <DRMacIver> Well, there's xmonad installed. Now to figure out how to use it...
13:54:30 <Saizan> i wonder why there's no way to go from XmlTree to String in HXT without ending in the IO monad
13:57:49 <LoganCapaldo> maybe its secretly an imperative program and uses IORefs all over the place? :)
14:04:35 <newsham> it would rule to polute the haskell space with lots of translations of imperative programs ;-)
14:05:37 <phobes> simple transliterations into haskell seem to usually get bigger and uglier
14:05:54 <SamB_XP> Saizan: it lacks a pure instance of the requisite arrow classes?
14:05:59 <SamB_XP> or worse...
14:07:10 <newsham> phobes: which is why it would rule so much :)
14:09:33 <mudge> lisp people tell me that haskell and lisp are really different
14:09:37 <mudge> only like cousins
14:09:47 <mudge> I thought they shared a closer relationship
14:09:51 <bos> no
14:10:06 <mudge> Haskell isn't even part of the family of lisp languages?
14:10:41 <newsham> the style of coding you do in lisp is probably a lot closer t othe style you do in C.
14:10:44 <mrd> ugh PG's latest essay makes me cringe a bit.  but i'm too lazy to write to him.
14:10:51 <newsham> but lisp and haskell arent that close either.
14:10:52 <sjanssen> mudge: Haskell is more closely related to ML
14:10:54 <mrd> hmm that was meant for -blah
14:11:03 <newsham> pgriddy is a bit rabid at times :)
14:12:18 <SamB_XP> mudge: have they figured out that lisp isn't really a functional language yet?
14:12:48 <mrd> haskell attributes Lisp in the report
14:13:03 <SamB_XP> what's that on his arm?
14:13:04 <newsham> samb: functional implies purity?
14:13:05 <mrd> but pretty much every high level language does, i guess
14:13:12 <SamB_XP> newsham: not really
14:13:21 <SamB_XP> but CL is not functional
14:13:25 <newsham> in what way is cl not functional?
14:13:40 <SamB_XP> in #'this way
14:13:50 <kpreid> SamB: I think that's moving the goalposts...
14:14:00 <SamB_XP> kpreid: perhaps!
14:14:03 <mudge> #lisp people are now telling me that haskell is and is not part of the Lisp family of languages
14:14:18 <fax> You can do functional programming in lisp
14:14:25 <SamB_XP> you can
14:14:26 <fax> I wouldn't call it a functional language though
14:14:39 <fax> It's fundamentally procedural
14:14:46 <newsham> mudge: i guess it depends on how people draw family trees? :)
14:14:50 <fax> (unlike haskell)
14:15:19 <newsham> taxonomy is not an exact science :)
14:15:20 <omniscientIdiot> SamB_XP: I don't think it's his arm, but it looks like the Y combinator.
14:15:30 <SamB_XP> ah.
14:15:44 <ddarius> Haskell has certainly taken some things from Lisp and certainly Lisp was the originator of ideas used in many languages nowadays.
14:16:12 <ddarius> SamB_XP: That's not his arm.
14:16:15 <newsham> being an imperative programmer i would be inclined to lump haskell in with lisp.
14:16:26 <ddarius> I wouldn't.
14:16:33 <newsham> but i guess if you're from the functional side you might see more differences than similarities :)
14:16:44 <SamB_XP> newsham: did you not learn much lisp?
14:17:05 <newsham> i know scheme and lisp.  i havent written extensively with them
14:17:31 <newsham> prob most code I've written in my life is C, a litle bit C++, and some python.
14:17:49 <newsham> (lots of asm, perl, haskell, lisp, scheme, sh, awk, sed, etc. mixed in there)
14:17:54 <LoganCapaldo> I think theres probably at least 3 or 4 well definned subspecies
14:18:00 <mudge> interesting,  sounds like the boundaries are not explicitly defined
14:18:14 <LoganCapaldo> not just the lisp/not-lisp
14:18:20 <LoganCapaldo> but that's me of course
14:18:24 <newsham> mudge: its like categorizing music.  its done in retrospect and the perspective shifts and with it categories every few years
14:18:34 <LoganCapaldo> I'd stick haskell in with ML, Ocaml, etc.
14:18:39 <newsham> taxonomies are prob more a reflection on the person categorizing than on whats being categorized :)
14:18:46 <omniscientIdiot> many here I think would define the fp boundary at referential transparency.
14:18:56 <SamB_XP> LoganCapaldo: nobody is ever going to question the relationship there. I hope...
14:18:58 <newsham> the fact that there's so much diversity in the functional programming world (vs. the imperative languages) doesnt help
14:19:12 <LoganCapaldo> @remember newsham taxonomies are prob more a reflection on the person categorizing than on whats being categorized :)
14:19:12 <lambdabot> Done.
14:19:15 <newsham> omniscient: so only pure functional languages like clean and haskell and miranda?
14:19:16 <bos> imperative languages aren't diverse?
14:19:18 <ddarius> newsham: I see a lot more similarities between ruby and python and lisp than I do between lisp and haskell.
14:19:29 <LoganCapaldo> What about my desire to stick Lisp with Tcl? Will someone complain about that? :)
14:19:37 <ddarius> LoganCapaldo: No.
14:19:47 <newsham> ddarius: i cant argue much with that.. the imperative script languages hvae been slowly marching towards lisp
14:19:51 <bos> tcl is very much influenced by lisp. ousterhout never pretended otherwise.
14:20:04 <newsham> logan: wasnt ousterhout a big scheme person, not lisp?
14:20:12 <SamB_XP> ddarius: you know, I could prove you wrong now
14:20:15 <LoganCapaldo> I have no idea
14:20:24 <SamB_XP> I could complain about it
14:20:26 <newsham> i like itcl.
14:20:28 <LoganCapaldo> I'm doing this based on my impression with no knowledge of the history of tcl :)
14:20:51 <bos> no.
14:20:53 <ddarius> SamB_XP: You haven't yet.
14:20:58 <SamB_XP> LoganCapaldo: I don't think they are exactly related
14:21:06 <SamB_XP> but they might be lumpable...
14:21:51 <SamB_XP> isn't TCL the language with strings and commands as it's major abstractions?
14:22:10 <araujo> yes SamB_XP
14:22:25 <SamB_XP> though some of those strings may internally be represented differently
14:22:29 <newsham> http://hopl.murdoch.edu.au/taxonomy.html
14:22:29 <lambdabot> Title: Taxonomy of computer languages
14:22:30 <LoganCapaldo> I would also like to chop C++ up into several smaller languages so I could distribute it proerply. Some wold even end up in the vicinty of haskell ;)
14:22:55 <newsham> what about lazy evaluation lisps? :)
14:22:58 <SamB_XP> LoganCapaldo: that seems about as easy as chopping IO into several monads
14:23:20 <SamB_XP> newsham: there are a ton of lisp-syntaxed languages
14:23:31 <SamB_XP> possibly due to the fact that lisp has essentially no syntax...
14:23:44 <jaredj> easy parser to write
14:23:44 <SamB_XP> some may be pretty much the same as Haskell
14:23:48 <newsham> lisp == AST
14:23:55 <newsham> we'll write the front end later!
14:23:59 <dibblego> SamB_XP, has anyone tried or proposed chopping IO up like that?
14:24:02 <LoganCapaldo> I would also not put most other concatenative lanaguages in teh same pile as forth
14:24:06 <SamB_XP> jaredj: more like, easy to use it for something else ;-)
14:24:30 <ddarius> LoganCapaldo: Like it's type language.
14:24:42 <LoganCapaldo> ?
14:24:45 <SamB_XP> dibblego: lots of people would like to chop up IO, but you can't chop it up into several monads, since then you wouldn't be able to use the various aspects together...
14:24:46 <ddarius> re C++
14:24:51 <LoganCapaldo> yes
14:24:55 <dibblego> SamB_XP, ah right
14:25:08 <ddarius> SamB_XP: Sure you could.
14:25:20 <SamB_XP> ddarius: how?
14:25:24 <newsham> crazy lifting
14:25:40 <SamB_XP> um, what?
14:25:55 <jaredj> "heavy lifting"?
14:25:59 <newsham> lift all your io sub things into a more general io thing
14:26:10 <SamB_XP> I think I would have flashbacks of the just-pre-MTL days if I had actually been around then...
14:26:14 <SamB_XP> at this point
14:26:14 <phobes> As long as that relationship exists in the monads
14:26:17 <LoganCapaldo> I feel like you could remove IORefs from IO
14:26:31 <sorear> LoganCapaldo: you can
14:26:31 <newsham> logan: what about STM?
14:26:32 <phobes> LoganCapaldo, probably could - that's just state
14:26:47 <SamB_XP> oh, did everyone notice that Associated Type Synonyms were implemented a few days back?
14:26:51 <sorear> @go Purely functional state threads
14:26:53 <phobes> But a more interesting example would be  splitting IO and OpenGL or something
14:26:54 <lambdabot> http://www.dcs.gla.ac.uk/fp/papers/lazy-functional-state-threads.ps.Z
14:26:56 <LoganCapaldo> they';ve always creeped me out a little
14:27:00 <sorear> SamB_XP: I even saw the announcement!
14:27:02 <phobes> and that's where you'd run into problems I think
14:27:02 <sorear> LoganCapaldo: ^^^
14:27:10 <SamB_XP> sorear: I saw the bug close!
14:27:11 <newsham> http://en.wikipedia.org/wiki/Categorical_list_of_programming_languages
14:27:13 <lambdabot> Title: Categorical list of programming languages - Wikipedia, the free encyclopedia, http://tinyurl.com/2wmm7c
14:27:18 <locomalo> Hello, now that you are talking about lisp & haskell, I wonder if somebody here needed to use ACL2 (a lisp dialect) or Chamlers-Lava (a hardware description language based upon Haskell)
14:27:50 <LoganCapaldo> How about Liskell? :)
14:27:57 <sorear> locomalo: We've got a sizable chunk of the Chalmers FP group in channel
14:28:16 <SamB_XP> I'm wondering how to structure a circuit library that would support multiple clock domains
14:28:18 <SamB_XP> personally
14:30:00 <sorear> don't seem to have koen&friends though
14:31:02 <locomalo> sorear, great! I want to learn to verify hardware descritions formaly, I started with ACL2 because it is quite documented
14:31:46 <locomalo> sorear, but I know some haskell and I wonder if Chalmers-lava will do the same work as ACL2
14:31:57 <SamB_XP> what does ACL2 do?
14:32:36 <locomalo> is a boyer-more theorem prover
14:32:51 <locomalo> *boyer-moore
14:33:19 <SamB_XP> how do you write circuits in it?
14:33:28 <phlpp> hm, i'm studying this 'yet another haskell tutorial" thing.. is there a difference, when i have a if->then->else block, and i'm intending else to the level of the 'then' or if i'm intending else to the level of the 'if'?
14:33:34 <LoganCapaldo> very carefully
14:33:54 <jaredj> s/intending/indenting/?
14:33:59 <phlpp> in the tutorial, else is always intended in the same level as the 'else', but haskell-mode seems to like the if level more
14:34:00 <ddarius> phlpp: In some cases, yes.
14:34:01 <LoganCapaldo> phlpp: believe it or not, yes
14:34:02 <phlpp> jaredj: je
14:34:07 <phlpp> oh :D
14:34:08 <locomalo> SamB, yet I don't know
14:34:16 <phlpp> and what should i use now?
14:34:24 <phlpp> this else = same level as then thing? :>
14:34:31 <sorear> phlpp: indentation doesn't matter for if-then-else
14:34:35 <SamB> locomalo: Lava can't prove a thing, actually...
14:34:38 <phlpp> sorear: ok
14:34:46 <omniscientIdiot> phlpp: the if-then-else is layoutless, but remember if you're using it in a do block, that if you put the 'then' or 'else' at the same indentation, it'll break it apart.  (do blocks start new statements at the same indentation)
14:34:55 <SamB> what it can do is ship things off to provers for them to prove
14:34:59 <sorear> phlpp: however haskell-mode has a nastly habit of misindenting do's
14:35:10 <SamB> with a bit of guidance about how, I think...
14:35:24 <jaredj> hmm
14:35:36 <jaredj> where's hemacs?
14:36:02 <jaredj> is the parser and compiler too heavy for that?
14:36:02 <phlpp> thanks guys
14:36:06 <phlpp> i did not expected that much help :D
14:36:07 <SamB> jaredj: there is something called yi
14:36:12 <jaredj> BY THE POWER OF GREYSKULL... I AM HEMACS
14:36:16 <jaredj> oh ok
14:36:22 <jaredj> I AM YI??
14:36:32 <Japsu> I AM NOTEPAD
14:36:33 <Japsu> ...
14:36:35 <SamB> but that might be stalled
14:36:36 <Japsu> NO I'M NOT
14:36:55 <SamB> I haven't heard much about yi lately, at any rate
14:37:04 <omniscientIdiot> phlpp: usually people write 'if cond' on one line, and 'then expr' and 'else expr' on two subsequent lines, indented more than the 'if'
14:37:18 <LoganCapaldo> heheheh
14:37:21 <LoganCapaldo> hemacs
14:37:53 <phlpp> omniscientIdiot: oh ok, thats unusual to me
14:37:56 <jaredj> oo, by dons! cool
14:38:12 <jaredj> Hemacs: for real men
14:38:16 <SamB> dons doesn't seem to have much to do with yi these days
14:38:30 <sorear> yi is a nvi-clone written in Haskell
14:38:44 <sorear> if you want an ideologically pure Haskell setup, use it
14:38:54 <ddarius> jaredj: It was cool when dons was at the helm, but then he switch reins with Jean-Philippe Bernardy whose an emacs user...
14:39:03 <jaredj> oho
14:39:15 <ddarius> I didn't mix enough metaphors in that sentence.  I will have to try harder in the future.
14:39:24 <jaredj> hmm
14:39:42 <jaredj> i dunno, it seems metaphor-saturated
14:39:44 <jaredj> :)
14:39:57 <phobes> ddarius:  I was picturing a small wooden boat assembled over a horse ...
14:41:03 <MisterN> right
14:41:26 <phobes> did I really say 'trinary' earlier?  :D
14:41:37 <jaredj> not sure
14:41:45 <jaredj> er... NULL?
14:41:47 <fax> yes you did :P
14:43:01 <oerjan> phobes: as atonement, go and learn the Malbolge language, a properly trinary one if there ever was
14:43:56 <oerjan> your sin was not large enough that i will demand you actually write a working program :)
14:44:13 <locomalo> SamB, sorear, thank you very much, doy you know any mail-list where I can get in touch with people using lava?
14:45:14 * sorear bootstraps tri-intercal
14:45:33 <SamB> locomalo: afraid not
14:45:48 <SamB> @go reduceron
14:45:51 <lambdabot> http://www.cs.york.ac.uk/~mfn/reduceron/
14:45:52 <lambdabot> Title: The Reduceron
14:46:00 <SamB> you might find that to be interesting though
14:46:34 <locomalo> SamB: Ok thank you!
14:47:10 <phobes> oerjan:  interesting :)
14:49:39 <newsham> huh, neat.
14:50:07 * jaredj emails to college acm list
14:50:45 <SamB> jaredj: what are you emailing?
14:52:40 <jaredj> that reduceron link
14:55:19 <jaredj> anyone got a laptop not running windows? recommendations?
14:55:36 <jaredj> anti-recommendations?
14:55:36 <sorear> I've got a laptop with no OS at all
14:55:44 <MisterN> sorear: must be practical
14:55:46 <newsham> i recommend vmware ;-)
14:55:49 <bos> sorear toggles in the code using his mouse
14:55:56 <phlpp> amagad
14:56:02 <newsham> i thought sorear codes with pencil and paper
14:56:09 <bos> pure thought, actually
14:56:15 <newsham> neat
14:56:19 <Nafai> Dang bos beat me to the punch
14:56:27 <Nafai> Though I was going to say "pure neurons"
14:56:31 <phlpp> hate that do indentation bug in haskell-mode
14:56:51 <phlpp> :>
14:56:57 <jaredj> OH GOD
14:56:57 <jaredj> AIRCON IN MY ROOM AGAIN
14:56:57 <jaredj> I AM SAVED
14:56:58 <jaredj> MAHJONG IN MY ROOM AGAIN
14:57:03 <jaredj> -- amagad.com
14:57:09 <phlpp> ;)
14:57:10 <sorear> phlpp: use vim
14:57:12 <sorear> :P
14:57:16 <phlpp> :D
14:57:18 <jaredj> haa haa
14:57:32 <jaredj> oops, amagad.net
14:57:45 <jaredj> ah. ok. http://www.urbandictionary.com/define.php?term=Amagad
14:57:46 <lambdabot> Title: Urban Dictionary: Amagad
15:18:57 <mudge> what's wrong with this: data Tree a = Leaf a | Node Tree a Tree
15:19:24 <phobes> Node (Tree a) a (Tree a)?
15:20:30 <monochrom> kind error :)
15:20:46 <mudge> phobes:  ah, yea, that's it
15:20:49 <LoganCapaldo> you got to be cruel to be kind
15:20:53 <LoganCapaldo> In the right measure
15:21:03 <LoganCapaldo> Tree is not a type
15:21:10 <LoganCapaldo> Tree is a type constructor
15:21:26 <mudge> doesn't data declare types?
15:21:31 <monochrom> Tree is a member of the Plant Kingdom.
15:21:39 <LoganCapaldo> it does
15:21:44 <LoganCapaldo> Tree a is a type
15:21:49 <LoganCapaldo> Tree is a type constructor
15:21:53 <bebers> http://tubeimage.com/viewer.php?file=cpr097wo8xau0587v6z6.jpg
15:21:54 <lambdabot> Title: TubeImage.com | Free Image Hosting | Photo Sharing | Upload | Picture Gallery
15:21:54 <LoganCapaldo> follow?
15:21:54 <mudge> ah, I see, cool
15:22:02 <mudge> I'm learning so much today
15:22:24 <LoganCapaldo> You could have had for instant data Tree a = Tree (Tree Int) a
15:24:02 <jaredj> haha, HaskellVim.hs for Yi appears broken
15:24:32 <sorear> @seen Cale
15:24:32 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 12h 49m 25s ago.
15:24:36 <sorear> Cale: ping
15:24:50 <Cale> hi
15:25:03 <sorear> Cale: Bokoros is back with a new IP
15:25:24 <bos> bokoros?
15:26:00 <ddarius> bos: Just a person posting the same link as bebers just did.
15:26:14 <bos> ah
15:26:26 <sorear> bos: and got banned for it
15:26:44 <sjanssen> bebers: are you a bot?
15:26:47 <sorear> we have a very low threshold for random spamming
15:26:52 <bebers> no
15:26:54 <fax> bebers: That's pretty cool (a cat wearing a lime) but please not here
15:26:55 <Cale> heh, besides, what is lime cat compared to spacesuit cat? http://cale.yi.org/autoshare/Dscf0026.jpg
15:26:58 <fax> bebers: This is the wrong place
15:26:59 <sjanssen> bebers did it in #xmonad too
15:27:12 <bebers> funny cat imo
15:27:24 <bebers> why wrong place?
15:27:27 * sorear reports bebers to the freenode staff
15:27:28 <Cale> bebers: learning Haskell?
15:27:34 <bebers> [00:26:00] <fax> bebers: This is the wrong place
15:27:47 * omniscientIdiot prefers the "Going to the moon, brb" cat most
15:27:49 <sorear> bebers: do you know how to use IRC?
15:28:05 <bebers> more orl ess
15:28:17 <sieni> Cale: or schroedinger's cat: http://www.thecheezburgerfactory.com/completestore/128351432363906250OHHAIIcollap.jpg
15:28:19 <lambdabot> http://tinyurl.com/2qvmpk
15:28:22 <omniscientIdiot> This channel is for those learning the Haskell programming language
15:28:27 <Cale> sieni: haha
15:28:31 <sorear> bebers: with each channel is associated a topic-string
15:28:45 <sorear> bebers: that tells you the only appropriate topic
15:28:48 <kpreid> omniscientIdiot: I hope not!
15:28:52 <bebers> seems like a hard language
15:29:00 <bos> sorear: any idea what the rough planned release date of 6.8.1 is?
15:29:10 <sorear> bebers: if you run '/topic' in here, it will not say 'Posting cute random image links'
15:29:10 <omniscientIdiot> kpreid: well, and those who know and use it :)
15:29:24 <Cale> bebers: It's not really any harder than anything else. It's just different.
15:29:34 <sorear> bos: the 's' in sorear is not simon :)
15:29:50 <bebers> cale: i guess this is a new lang
15:29:55 <myxie> don't feed the trolls
15:29:57 <sorear> bebers: define new
15:30:05 <sorear> bebers: it's over 20 years old
15:30:11 <bebers> oh
15:30:20 <bebers> so not popular
15:30:25 <Cale> bebers: fairly new, it's been around since the 1980's, but only recently has it started to gain popularity
15:30:29 <mudge> looks like I can't do this:
15:30:29 <mudge> t :: Tree a
15:30:29 <mudge> t = Node (Node (Leaf 1) 3 (Leaf 4)) 5 (Node (Leaf 6) 7 (Leaf 9))
15:30:32 <shachaf> It's popular here. :-)
15:30:35 <jaredj> yeh ruby was three years old before many in the US knew about it
15:30:53 <kpreid> mudge: the type needs to be Num a => Tree a
15:30:55 <monochrom> Barbie thinks math is hard and shopping is cute. bebers thinks haskell is hard and pic sharing is cute.
15:30:58 <bos> sorear: yeah, but you're more active on #ghc than i am :-)
15:30:59 <omniscientIdiot> mudge: nope, the numbers force t to have a numeric type.
15:31:01 <jaredj> bebers: programming.reddit.com tends to get a lot of haskell links posted on it
15:31:02 <shachaf> jaredj: More than that, I think.
15:31:11 <omniscientIdiot> mudge: so 't :: Tree a' is too general
15:31:19 <Cale> Haskell was a research language for a long time, and now it's sort of sitting on the fence between the practical side and the research side and growing in both directions
15:31:24 <jaredj> shachaf: really? i thought it was two years old when i found it, ~ 1.6
15:31:37 <omniscientIdiot> mudge: you could have 't :: Num a => Tree a' or 't :: Tree Int'
15:31:38 <jaredj> shachaf: then rails, boom
15:31:43 <shachaf> jaredj: Isn't it from ~1993?
15:32:03 <SamB> hmm, was looking through my debian packages and I somehow just found out about a new Haskell-based HDL...
15:32:05 <LoganCapaldo> ruby is 10ish years old
15:32:08 <LoganCapaldo> I think 1995
15:32:17 <SamB> or at least one I don't remember knowing about...
15:32:17 <Cale> Well, Haskell 1.0 is from 1990
15:32:24 <Cale> but it had been around before that
15:32:29 <jaredj> when's haskell 98 from?
15:32:34 <LoganCapaldo> lol
15:32:35 <SamB> called Atom
15:32:36 <LoganCapaldo> guess
15:32:36 <Cale> and Miranda is practically the same
15:32:40 <MisterN> 97 i suppose
15:32:41 <Cale> 1999 :)
15:32:47 <jaredj> lol
15:32:54 <mudge> yea, thankss omniscientIdiot
15:33:03 <mudge> i have to do this:
15:33:03 <mudge> t :: (Num a) => Tree a
15:33:03 <mudge> t = Node (Node (Leaf 1) 3 (Leaf 4)) 5 (Node (Leaf 6) 7 (Leaf 9))
15:33:20 <Cale> (But February -- most of the work on it was done in 1998)
15:33:21 <mudge> or Tree Int  as you said
15:33:28 <jaredj> kk
15:33:34 <kpreid> mudge: always keep in mind that you don't *have* to write the type signature
15:33:40 <omniscientIdiot> mudge: or even Tree (Complex Double) :P
15:33:56 <mudge> kpreid: oh yea, thanks
15:33:57 <oerjan> or Tree Integer, which is the default if you leave it out (because of MR)
15:34:06 <LoganCapaldo> I find writing the type signature to be a very good sanity check
15:34:14 <mudge> so i could just do: t = Node (Node (Leaf 1) 3 (Leaf 4)) 5 (Node (Leaf 6) 7 (Leaf 9))
15:34:20 <bos> haskell is from the future. it has returned to 2007 to warn us against perl 6 and ruby on rails.
15:34:27 <mudge> oerjan: what's MR?
15:34:38 <oerjan> monomorphism restriction
15:34:41 <Cale> bos: haha
15:34:45 <omniscientIdiot> mudge: yep, that would infer Num a => Tree a, but the monomorphism restriction would default it to Tree Integer
15:34:46 <shachaf> The monomorphism restriction.
15:34:50 <blarz> bos: isn't pugs written in haskell?
15:34:50 <LoganCapaldo> if I can't write the type I don't understand the function
15:35:08 <LoganCapaldo> blarz: It's clearly failing in it's mission then
15:35:10 <mudge> wow, monomorphism is a big word
15:35:12 <jaredj> blarz: for a while it was the only way they got anything done, i think (;
15:35:15 <monochrom> I also practice type-oriented programming.
15:35:16 <kpreid> that's not MR, is it?
15:35:17 <Cale> http://www.math.rutgers.edu/~zeilberg/GT.html
15:35:18 <lambdabot> Title: Plane Geometry by Shalosh B. Ekhad XIV
15:35:25 <shachaf> mudge: Bigger than polymorphism?
15:35:28 <omniscientIdiot> mudge: "one-type", as opposed to polymorphic
15:35:29 <jaredj> mudge: i had that in college
15:35:33 <kpreid> or does defaulting only happen when MR applies?
15:35:39 <blarz> jaredj: I see
15:35:43 <blarz> LoganCapaldo: heh ;)
15:35:53 <jaredj> blarz: or was it a bacterial infection
15:36:19 <oerjan> kpreid: defaulting also happens when an intermediate type doesn't escape, i guess
15:36:30 <oerjan> like in x^2
15:36:30 <mudge> what is monomorphism restriction?
15:36:53 <oerjan> (the type of the 2 doesn't influence the type of the expression)
15:36:57 <kpreid> mudge: anything with neither parameters nor an explicit signature is assigned a monomorphic type
15:37:09 <monochrom> If you wrtie "x = 0" x is not polymorphic.
15:37:14 <kpreid> so if you write "x = 1" it will have some type other than Num a => a
15:37:20 <omniscientIdiot> @wiki Monomorphism restriction
15:37:20 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:37:25 <kpreid> it will have Integer if nothing else is inferred
15:37:36 <ddarius> monochrom is a TOP programmer.
15:37:39 <LoganCapaldo> @type let x = 1 in x
15:37:41 <lambdabot> forall t. (Num t) => t
15:37:52 <LoganCapaldo> she has it turned off doesn't she?
15:37:58 <Cale> The rule is basically that all pattern bindings without explicit type signatures must have monomorphic types.
15:38:12 <LoganCapaldo> oh wait
15:38:17 <Cale> It is a silly rule, and ought to be thrown out.
15:38:21 <LoganCapaldo> let introduces a polymorphic binding doesn't it?
15:38:30 <shachaf> Cale: Well, "x = []" works, and is polymorphic.
15:38:35 <oerjan> oh, and there are more details - it only applies to the type variables that have a type class restriction
15:38:42 <shachaf> This is specifically about type classes.
15:38:48 <Cale> yes
15:38:49 <LoganCapaldo> ah
15:38:52 <oerjan> thus shachaf's example - no type class involved
15:39:38 <oerjan> also, even if it _is_ monomorphic, it need not necessarily default - it may be restricted by the rest of the containing module
15:39:41 <mudge> that's interesting,  to make a function defintion overloaded you have to explicitly write the type declaration,   or it will assign the function a type,  because of monomphic restriction
15:39:47 <Cale> It's because the typeclass translation turns pattern bindings into function bindings which means that typeclass polymorphic pattern bindings which you might expect to be shared can end up turning into functions and not being shared.
15:40:03 <oerjan> (in ghc, hugs is buggy about that)
15:40:08 <LoganCapaldo> mudge: or you can pass -fno-monomorphism-restriction
15:40:16 <LoganCapaldo> in ghc
15:40:17 <SamB> locomalo: hmm, maybe http://groups.google.com/group/funhdl will be of interest?
15:40:18 <lambdabot> Title: FunHDL | Google Groups
15:40:23 <locomalo> SamB: I found in the haskell.org site Lava, Atom, Hawk and "Circuit Simulator" as hardware verification aplication/libraries list
15:40:32 <shachaf> mudge: Note that "let x = 1 in x" isn't the same as "let x () = 1 in x ()".
15:40:40 <oerjan> mudge: it does not apply to functions defined with parameters
15:41:00 <locomalo> SamB, I give it a look at it
15:41:05 <shachaf> This also means that "f x = x + 1" isn't the same as "let f = \x -> x + 1".
15:41:11 <SamB> locomalo: well, I found out that one package I had installed had been replaced twice, anyway...
15:41:14 <shachaf> (Ignoring the let.)
15:41:42 <SamB> I'm not sure what Hawk actually does
15:41:52 <monochrom> > let x=0 in (x :: Integer, x :: Int)
15:41:52 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
15:41:56 <mudge> thanks
15:41:57 <omniscientIdiot> shachaf: by "not the same", is there any difference besides requiring an explicit type on the second?
15:42:00 <monochrom> That is the monomorphism restriction
15:42:01 <SamB> Lava and Atom definately do something, at least ;-)
15:42:09 <shachaf> omniscientIdiot: No.
15:42:10 <monochrom> > let x :: Num t => t; x=0 in (x :: Integer, x :: Int)
15:42:11 <lambdabot>  (0,0)
15:42:19 <monochrom> That is the power of type signatures.
15:42:21 <shachaf> omniscientIdiot: It's just the inference.
15:43:04 <LoganCapaldo> MR is in the report right?
15:43:10 <monochrom> Yes.
15:43:11 <allbery_b> yes
15:43:42 <twanvl> That is not the power of type signatures, it is more like a way to work around the problems caused by the DMR
15:44:08 <LoganCapaldo> @type id . id . id . id
15:44:10 <lambdabot> forall a. a -> a
15:44:22 <shachaf> twanvl: DMR?
15:44:27 <mudge> why is it called monomorphism restriction?   it seems it has to do with overloading,  not morphism
15:44:48 <LoganCapaldo> monomorphic being the "opposite" of polymorphic
15:44:54 <allbery_b> because it restricts polymoorphism
15:44:56 <allbery_b> heh
15:45:01 <omniscientIdiot> mudge: I guess the upshot is if you define 'x = ...', you would expect it to only be calculate once and reused wherever you put an 'x', but if x were typeclass-polymorphic (ex: Num a => a), then you might need to calculate it more than once for each type used (ie. once for Double, Int, etc.)
15:45:03 <allbery_b> <-- slow today
15:45:11 <mudge> yea, but it also restricts,  overloading,  which is not polymorphism
15:45:29 <allbery_b> hm?  haskell overloading s implemented via polymorphism
15:45:32 <shachaf> Why not?
15:45:37 <twanvl> DMR = Dreaded Monomorphism Restriction
15:45:51 <mudge> omniscientIdiot: thanks, that makes a lot of sense
15:46:21 <mudge> allbery:  is that true, that the overloading is implemented via polymorphism?
15:46:22 <shachaf> Oh.
15:46:23 <omniscientIdiot> mudge: when you put the explicit type, you say "it's okay for it to be calculated more than once"
15:46:32 <allbery_b> "'Are you expected?'  'No, dreaded.'"
15:46:37 <omniscientIdiot> @type (+) -- mudge
15:46:39 <lambdabot> forall a. (Num a) => a -> a -> a
15:47:50 <mudge> so in the defintion of (+)  it is given an explicit type declaration that it is (Num a)  ?
15:47:51 <allbery_b> technically it would be more correct to say that polymorphism is implemented via overloading, I think, but they end up being 1-to-1 in any case
15:47:54 * sorear wants Hughes' binder proposal
15:48:05 <shachaf> sorear: Was that the one with :=?
15:48:16 <sorear> PATTERN := EXP   Monomorphic, guarantees sharing
15:48:30 <omniscientIdiot> mudge: (+) is in the Num class, each instance Num SomeType provides an implementation for (+)
15:48:32 <twanvl> I prefer monomorphic pattern bindings
15:48:33 <sorear> NAME [ARGS] = EXP   Polymorphic, guarantees no sharing even in the 0-arg case
15:48:48 <twanvl> (PATTERN) = EXP -- monomorphic
15:48:55 <sorear> but note that a NAME is a special case of a PATTERN
15:49:01 <mudge> omniscientIdiot: i see
15:49:20 <sorear> twanvl: ugh
15:49:35 <twanvl> You never need them anyway, and it adds no new syntax
15:50:11 <pstickne> colleges should be required to teach a pure functional language early on in a CS program (or at all) ^^
15:50:26 <ddarius> pstickne: Start lobbying.
15:50:26 <pstickne> all the CS programs I have seen are based about C++ or Java or some other crap.
15:50:49 <sorear> I'd like CS programs to teach CS
15:50:59 <oerjan> sorear: guaranteeing no sharing could break old programs couldn't it?
15:51:07 <bos> CS programs are vocational education. if you want to learn something interesting, instead of useful, get a math or physics degree.
15:51:07 <sorear> C++, Java, and Haskell belong in computer engineering, not CS
15:51:09 <pstickne> (and I'm saying it should be a requirement because it's a completely different concept than imperative programming :-/)
15:51:29 <sorear> oerjan: No.
15:51:41 <oerjan> if it really calculates it anew on each mention
15:51:55 <pstickne> bos, but they SHOULDN'T be
15:51:56 <twanvl> It only breaks some unsafePerformIO tricks
15:51:58 <sorear> oerjan: Haskell is pure, it wouldn't make a difference
15:52:09 <sjanssen> sorear: do you mean "guarantees no sharing" or "no guarantees of sharing"?
15:52:11 <bos> pstickne: shrug. that's no more likely to change than the colour of the sun.
15:52:19 <pstickne>  bos, there should be vocational classes, but it shouldn't be 4 years of training how to be a Java-ant
15:52:36 <sorear> sjanssen: I mean guarantees no sharing, from the standpoint of space/time semantics
15:52:58 <twanvl> sharing is not guaranteed by Haskell anyway
15:53:19 <sorear> twanvl: well haskell doesn't have a spacetime semantics yet :/
15:53:26 <pstickne> bos, it could be different elsewhere, but learning a particular language isn't making people (at my school) any smarter...
15:53:50 <sjanssen> sorear: I'd prefer that the compiler makes sharing choices for me
15:54:08 <bos> pstickne: that's because a CS degree is a vocational degree. it's not supposed to make you smart, it's supposed to turn you into programming cannon fodder.
15:54:09 <pstickne> (and it breaks my heart when people can't see past their VB.NET)
15:54:34 <pstickne> bos, I wish I knew that earlier... but I'm not all that interested in super-advanced math or physics
15:55:08 <monochrom> I want to move to Vulcus. The Vulcans are more logical. They are also more Haskell-friendly, but they wish I learn something even better.
15:55:20 <pstickne> monochrom, heh
15:55:52 <SamB> monochrom: have they told you it's name?
15:55:53 * pstickne goes to muse over IO/monads somemore
15:55:55 <monochrom> They use very good logics even for the most vocational, profit-making endeavours.
15:56:11 <sjanssen> s/Vulcus/Vulcan
15:56:43 <LoganCapaldo> mmm vulcus
15:56:47 <monochrom> Yes, but the name is too hard to remember for me.
15:57:24 <Cale> http://www.psy.ritsumei.ac.jp/~akitaoka/grapejuice.jpg :)
15:57:55 <mrd> what CS degree is vocational?
15:58:03 <monochrom> Why is Cale participating in pix sharing? Is his brain infected by that bebers troll?
15:58:07 <LoganCapaldo> my god it's like an animated gig
15:58:09 <LoganCapaldo> *gif
15:58:29 <Cale> monochrom: At least I'm linking from the original author's site :)
15:58:46 <allbery_b> oh, dear
15:58:52 <pstickne> LoganCapaldo, it's using a new compression technique--animated while downloading!
15:59:04 * allbery_b was able to make his eyes "freeze" it
15:59:17 <Cale> pstickne: no, it's not, the motion is an optical illusion
15:59:23 <allbery_b> (by going slightly out of focus, wwhich at the moment is rather easy for me)
15:59:37 <pstickne> Cale, heh, give me more credit than that :-/
15:59:38 <LoganCapaldo> you can make it change speeds too
15:59:52 <LoganCapaldo> or at least make it go slower
15:59:57 <Cale> pstickne: well, I have seen such tricks used to animate images
16:00:21 <omniscientIdiot> graphejuice.jpg?
16:00:27 <omniscientIdiot> s/h//
16:01:12 <LoganCapaldo> quote from a friend I send the link to: "good job human eyes you fail"
16:01:20 <LoganCapaldo> s/send/sent/
16:02:12 <omniscientIdiot> the human eyes are remarkably imprecise instruments.
16:02:51 <pstickne> would you really want the same view video circuitry gets?
16:03:09 <omniscientIdiot> I had much fun when I discovered the blind spots on the sides of either eye
16:03:18 <allbery_b> you never wanted IR vision?  (remember the Sony(?) "x-ray camera" scare a few years ago?)
16:03:43 <LoganCapaldo> My favorite was putting a hle in my hand witha  cardboard tube
16:03:48 <LoganCapaldo> s/hle/hole/
16:04:11 <lament> i want through-clothes vision, not IR vision
16:04:22 <allbery_b> that's essentially what the scare was about
16:04:36 <pstickne> lament, and may you be cursed with the inability to disable it O.o
16:04:38 <allbery_b> it was sufficiently sensitive to infrared (heat) that it could image stuff through clotyhes in some cases
16:05:06 <lament> sounds fun
16:05:34 <lament> (IR != heat)
16:06:30 <LoganCapaldo> Yes  green tinted underwear shots
16:06:38 <LoganCapaldo> the ultimate evolution in pornography
16:07:05 <monochrom> The other guy's underwear is always greener.
16:07:40 <lament> as soon as through-clothes vision aids become widespread, people will stop buying Hummers.
16:08:00 <lament> as everybody will be able to see that their penis isn't actually getting any bigger.
16:08:02 <omniscientIdiot> bahahahaha
16:08:52 <allbery_b> <lament> (IR != heat)
16:08:56 <allbery_b> yes, I was approximating
16:09:31 <allbery_b> this is #haskell, not #physics or #vision
16:09:39 <LoganCapaldo> -fno-pedant
16:10:13 <lament> ok, then let's just say the camera can see through clothes using magic-x omega superwaves :)
16:10:23 <lament> patented by sony!
16:11:28 <omniscientIdiot> someone write a SeeThroughClothes monad to bring this on-topic!
16:11:44 <lament> i bet dons has one already
16:11:51 <omniscientIdiot> I nominate Logan
16:12:28 <oerjan> class (Monad m, Fabric f) => MonadSeeThroughClothes m f where
16:12:31 <monochrom> The monad can't see through clothes. It can only get under clothes. Once in, you can't get out. Unless you have unsafePerformGetOut
16:13:01 <monochrom> However, for all practical purposes, getting under someone else's undies is more than enough.
16:13:55 <allbery_b> lift?
16:13:59 <LoganCapaldo> Maybe we need a SeeThroughClothes Arrow...
16:15:21 <lament> boobs >>= ogle
16:15:42 <LoganCapaldo> ogle =<< boobs
16:15:57 <LoganCapaldo> I like =<<
16:15:58 <ari> You can always bind a pure action to run on data you got from under somebody's clothes, but what's the fun in that?
16:16:15 <ari> *pure function, or something... I'm somewhat durnk
16:16:25 <LoganCapaldo> I wish I was durnk
16:16:28 <monochrom> There are extra impure actions. That's the fun.
16:16:39 <omniscientIdiot> I'm not as think as you drunk I am.
16:16:47 <allbery_b> also, gives new meaning to (.).(.)
16:17:02 <monochrom> For example launch_missile :: UnderClothes ()
16:17:13 <lament> oh god
16:17:20 <LoganCapaldo> the nukes can't excape the clothes
16:17:24 <LoganCapaldo> it's brilliant
16:18:03 <LoganCapaldo>  security thru tight jeans
16:18:06 <chessguy> what in the world are you guys talking about?
16:18:24 <monochrom> porn :)
16:18:27 <lament> being lonely on a saturday night
16:18:28 <EvilTerran> haskell, of course!
16:18:39 <lament> well, it's what these guys were talking about, i'm not even here
16:21:03 <EvilTerran> there's gotta be a joke about binding in here somewhere
16:21:25 <Japsu> @quote bind
16:21:25 <lambdabot> ghc says: Bindings in hs-boot files are not allowed
16:21:34 <Japsu> @quote bind
16:21:34 <lambdabot> ghc says: bindings for unlifted types aren't allowed
16:21:38 <lament> heh
16:21:39 <Japsu> @quote bind
16:21:40 <lambdabot> ghc says: Bindings in hs-boot files are not allowed
16:21:42 <Japsu> bah
16:22:02 * Japsu fails to see the @remember-worthiness in those
16:23:08 <LoganCapaldo> @quote >>=
16:23:08 <lambdabot> mauke says: >> is just >>= with alzheimer's
16:23:13 <LoganCapaldo> lol
16:23:24 <LoganCapaldo> @quote >>=
16:23:24 <lambdabot> mauke says: >> is just >>= with alzheimer's
16:23:28 <LoganCapaldo> @quote >>=
16:23:28 <lambdabot> mauke says: >> is just >>= with alzheimer's
16:23:33 <LoganCapaldo> must be the only one
16:24:21 <kpreid> you know, lb already has @more
16:24:36 <LoganCapaldo> @quote >>=
16:24:36 <lambdabot> mauke says: >> is just >>= with alzheimer's
16:24:40 <kpreid> if only @quote actually produced all matching quotes, but set an option to only show the first line.
16:24:41 <LoganCapaldo> @more
16:24:53 <kpreid> then you could use @more to get the rest of them.
16:25:30 <LoganCapaldo> there could still be more and I coupld just be really really really unlucky
16:25:31 <kpreid> as it is, @more is only used when there are, hm, 8 or so lines? which all the usual commands are set to avoid ever reaching
16:25:48 <lament> it should just weigh random qoutes by, among other things, how recently the quote appeared
16:25:59 <lament> so recent qoutes are less likely to appear again
16:27:08 <omniscientIdiot> @yow!
16:27:08 <lambdabot> Does someone from PEORIA have a SHORTER ATTENTION span than me?
16:27:32 <LoganCapaldo> doubtfu;
16:27:46 <LoganCapaldo> @yowch
16:27:46 <lambdabot> NATHAN ... your PARENTS were in a CARCRASH!!  They're VOIDED -- They
16:27:46 <lambdabot> COLLAPSED They had no CHAINSAWS ... They had no MONEY MACHINES ... They
16:27:46 <lambdabot> did PILLS in SKIMPY GRASS SKIRTS ... Nathan, I EMULATED them ... but
16:27:46 <lambdabot> they were OFF-KEY ...
16:28:01 * LoganCapaldo blinks
16:28:21 * omniscientIdiot isn't sure whether to laugh
16:28:42 <ddarius> omniscientIdiot: It's Zippy the Pinhead.  The answer is clear.
16:28:59 * ddarius pukes on Zippy.
16:32:38 <Yut> Voté Charles-Alexandre Deschamps (Pour qu'il peut aller en tournoi de skate-board) Vote pour Charche-Alexandre : http://islandproductions.org/blog/?page_id=355Q
16:35:19 <wnoise> I do believe that's the first IRC spam I've seen.
16:35:22 <jaredj> Vote contre Charche-Alexandre :P
16:35:43 <jaredj> wnoise: there was bebers a while ago
16:35:50 <ddarius> wnoise: Certainly not the first in #haskell
16:36:07 <jaredj> it's more... affronting in IRC
16:36:15 <jaredj> because i see *join* *spam* *leave*
16:36:21 <jaredj> instead of just *spam*
16:36:28 <jaredj> it's like, hey come back so i can slap you.
16:36:35 <idnar> I really don't get Zippy
16:36:49 <idnar> especially the RANDOM words IN uppercase
16:37:00 <jaredj> that's the POINT
16:37:18 <jaredj> it's like a machine-YIFFED madlib
16:40:11 <pstickne> indenting in emacs seems off (using the haskell-mode distributed with debian etch)
16:40:31 <lapthrick> how do you pronounce >>= ?
16:40:42 <pstickne> in particular, if .... then <- it says "Sole indentation" and makes the then align right under the if, any ideas?
16:41:10 <pstickne> greaterthangreaterthanequals? :)
16:41:12 * pstickne ducks
16:41:29 <dmwit> lapthrick: bound to
16:41:39 <lapthrick> aha
16:43:25 <allbery_b> pstickne: yeh, known bug
16:44:19 <allbery_b> zippy's still in one of the local newspapers, I think.  most people around here don't get it.
16:44:23 <kpreid> lapthrick: a common alphabetical name for >>= is "bind"
16:44:23 <pstickne> allbery_b, what's the work[around/ing] solution? newer version? .... wait, I should have hit emacs-wiki first :-/
16:44:40 <allbery_b> I haven't heard of a fix.  I just manually reindent
16:45:22 <allbery_b> there may beother solutions, but gettiong recent haskell-mode to play nice with my xemacs was torment enough
16:46:58 <pstickne> sucks. I'm also trying to but LoganCapaldo about it ^^
16:47:17 <LoganCapaldo> I don't do emacs :)
16:47:26 <glen_quagmire> in haskell, arithmatics is implemented in terms of church numerals?
16:47:38 <ddarius> Invoke emacs with a different commandline, namely: vim
16:47:41 <lapthrick> glen_quagmire: no
16:47:52 <glen_quagmire> alright
16:48:07 <LoganCapaldo> so no I don't have problems with haskell-mode :)
16:49:02 <allbery_b> and people think haskell is slow with math as it is...
16:49:03 <allbery_b> :)
16:49:42 <pstickne> LoganCapaldo, gah, I thought you were on my side of the fence on this one :-/
16:49:54 <pstickne> ddarius, ^^
16:49:57 <LoganCapaldo> sorry
16:51:05 <allbery_b> subethaedit?  </notserious>
16:51:28 <LoganCapaldo> SEE is fun
16:51:32 <pstickne> I just hate digging through elisp other people have created. it takes me a few days to get a graph on how it works...
16:51:50 <LoganCapaldo> I dunno how great it's Haskell support is but it works fairly well for prose :)
16:53:29 <kpreid> glen_quagmire: if you like, you can define them and define a Num instance
16:54:40 <allbery_b> I was actually underwhelmed by its haskell support
16:54:59 <LoganCapaldo> seems like the type system would not be condusive to church numerals... oh wait you wouldn't need to use a function to do it, you could just do data Church = Zero | Succ Church
16:55:22 <LoganCapaldo> s/a function/functions/
16:55:29 <allbery_b> didn't we just have this duscussion recently?
16:55:57 <LoganCapaldo> Don't we have this conversation every day? :)
16:56:02 <allbery_b> try looking for "data Nat"
16:56:04 <lament> that's not church. that's peano.
16:56:10 <allbery_b> true
16:56:17 <LoganCapaldo> alright
16:56:21 <nornagon> allbery_b: I read that as 'data hat' :/
16:56:28 <LoganCapaldo> assume I sad nothing after thos eelipses
16:56:30 <allbery_b> come to think of it, type system would be problematic
16:56:45 <allbery_b> church numerals assume untyped lambda calculus I think
16:56:55 <lament> yes
16:56:56 <ddarius> forall a. a -> (a -> a) -> a
16:56:59 <allbery_b> nornagon: that'd be oleg :>
16:57:11 <lament> a church numeral is a function
16:57:12 <kpreid> so define an untyped-lambda-term data type and build on that :)
16:57:19 <idnar> Zero is not the successor of any natural number.
16:57:24 <ddarius> You can easily get all positive algebraic data types with rank-2 polymorphism
16:57:30 <lament> you can define church numerals in terms of S and K
17:00:56 * idnar sees http://en.wikipedia.org/wiki/Church_numeral#Translation_with_other_representations
17:00:58 <lambdabot> http://tinyurl.com/242bof
17:01:55 <ddarius> type List a = forall x. x -> (a -> x -> x) -> x
17:02:18 <ddarius> type Tree a = forall x. (a -> x) -> (x -> x -> x) -> x
17:03:03 <ddarius> :t foldr
17:03:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:05:18 <desp> $seen shapr
17:05:26 <desp> @seen shapr
17:05:26 <lambdabot> I saw shapr leaving #haskell-blah, ##logic, #scannedinavian and #haskell 4h 10m 17s ago, and .
17:05:36 <desp> and ?
17:07:27 <jaredj> heh
17:07:58 <LoganCapaldo> @get-shapr
17:07:58 <lambdabot> shapr!!
17:08:08 <LoganCapaldo> I love that
17:22:07 <oscz> can you use haskell to get integral of a function ?
17:22:55 <lament> symbolically or numerically?
17:23:17 <LoganCapaldo> isn't the answer to both yes?
17:23:37 <oscz> symbolically i think
17:23:38 <lament> i dunno, good luck with symbolic integrals
17:23:40 <LoganCapaldo> I remmeber seeing that badass lib with the funky num instances
17:23:54 <LoganCapaldo> @faq can haskell do symbolic integrals?
17:23:55 <lambdabot> The answer is: Yes! Haskell can do that.
17:24:08 <dolio> There are tricks for getting derivatives easily.
17:24:12 <dolio> Integrals are probably harder.
17:24:15 <oscz> im not strong in math
17:24:39 <oscz> but at least for some form of equations that is trivial right ?
17:24:45 <dmwit> Sure!
17:24:56 <dmwit> For example, integrals of polynomials are easy in any language.
17:25:18 <oscz> eg.. linear acceleration fv a t = a*t
17:25:28 <dmwit> And I assume that you can eventually get Haskell to integrate any formula that, say, Mathematica can integrate.
17:25:58 <oscz> so can i integrate that to distance function s(t)
17:25:59 <oscz> ?
17:26:06 <dolio> For instance, there's an easy rule for D(uv) given Du and Dv, but no similar rule for integrals of products.
17:26:56 <dmwit> oscz: Definitely.
17:27:08 <dmwit> oscz: But surely you don't need Haskell to do that?
17:27:14 <oscz> no hehe
17:27:43 <oscz> im just trying to experiment.. and just crossed my mind if it can do this for say polynomials
17:27:50 <edwardk> symbolic integration is nontrivial because its more a case of pattern recognition and a series of semialgorithms, rather than something you can always do
17:28:03 <edwardk> but polynomials and a lot of special cases are easy
17:28:17 <oscz> was just thinking about it.. i think what you're saying
17:28:27 <oscz> i think i get what you're saying i mean
17:29:05 <dmwit> > let integrate polynomial = 0:zipWith div polynomial [0..] in integrate [1]
17:29:07 <lambdabot>  Exception: divide by zero
17:29:18 <dmwit> > let integrate polynomial = 0:zipWith div polynomial [1..] in integrate [1]
17:29:19 <lambdabot>  [0,1]
17:29:33 <dmwit> > let integrate polynomial = 0:zipWith div polynomial [1..] in iterate 2 integrate [1]
17:29:34 <lambdabot>  Couldn't match expected type `[t1] -> t'
17:29:40 <oscz> haskell "sees" it only as multiplication of two elements... so i have to supply at least what i integrate against
17:29:44 <dmwit> > let integrate polynomial = 0:zipWith div polynomial [1..] in iterate integrate [1]
17:29:46 <lambdabot>  [[1],[0,1],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,...
17:30:03 <dmwit> > let integrate polynomial = 0:zipWith (/) polynomial [1..] in iterate integrate [1]
17:30:05 <lambdabot>  [[1.0],[0.0,1.0],[0.0,0.0,0.5],[0.0,0.0,0.0,0.16666666666666666],[0.0,0.0,0....
17:30:46 <dmwit> There we go, symbolic integrals of polynomials. ;-)
17:31:01 <oscz> huh.. really? :P
17:31:23 <dmwit> Yup!
17:31:34 <oscz> i have a feeling im not ready for that yet :(
17:31:36 <dmwit> The polynomial ax^2 + bx + c is represented by the list [c,b,a]
17:31:51 <oscz> oh..
17:31:52 <pstickne> haha. at least temporarily fixed haskell-mode (don't know what else it broke ;))
17:32:56 <oscz> dmwit: where you give that list as parameter to some function ?
17:33:11 <pstickne> allbery_b, ~L1189, remove "then" and "else" from the regex
17:33:37 <pstickne> (it lets them cycle all indents)
17:34:46 <oscz> dmwit: is it [1..] ?
17:35:07 <dmwit> oscz: No, the parameter is at the end.
17:35:16 <dmwit> The final [1] is the thing we are repeatedly integrating.
17:35:46 <dmwit> So, we start with [1] (= 1), then get [0,1] (=x + 0), then [0,0,.5] (=x^2/2), then ...
17:37:10 <Cale> > let integrate polynomial = 0:zipWith (/) polynomial [1..] in iterate integrate [1] :: [Rational]
17:37:18 <lambdabot>  Couldn't match expected type `Rational' against inferred type `[a]'
17:37:26 <dmwit> oscz: So, for example, the integral of 4x^3+3x^2+2x+1 is just x^4+x^3+x^2+x, right?
17:37:32 <Cale> > let integrate polynomial = 0:zipWith (/) polynomial [1..] in iterate integrate [1] :: [[Rational]]
17:37:34 <lambdabot>  [[1%1],[0%1,1%1],[0%1,0%1,1%2],[0%1,0%1,0%1,1%6],[0%1,0%1,0%1,0%1,1%24],[0%1...
17:37:44 <dmwit> > let integrate polynomial = 0:zipWith (/) polynomial [1..] in integrate [1,2,3,4]
17:37:44 <omniscientIdiot> @let integrate polynomial = 0:zipWith (/) polynomial [1..]
17:37:46 <lambdabot>  [0.0,1.0,1.0,1.0,1.0]
17:37:48 <lambdabot> Defined.
17:38:33 <oscz> pretty neat huh..
17:39:03 <Cale> > let fac n = denominator . last . (!! n) $ iterate integrate [1] in fac 5
17:39:04 <lambdabot>  120
17:39:15 <oscz> > let integrate polynomial = 0:zipWith (/) polynomial [1..] in integrate [1,1,1]
17:39:16 <lambdabot>  [0.0,1.0,0.5,0.3333333333333333]
17:39:26 <sorear> I'm sure the Risch procedure would only be 100 lines or so
17:40:50 <dmwit> oscz: If you want more symbolism, you can introduce something like data Coeff a = Value a | Variable String | Product (Coeff a) (Coeff a), then have an instance (Num a) => Num (Coeff a) where ...
17:41:57 <dmwit> Then the above-defined integrate function would work just as written.  (I think.)
17:43:18 <oscz> is there a function that i could supply with the polynomial function i want to integrate and it'd actually return the integrated function definition ? of course i'd need to tell it what's the variable
17:44:26 <oscz> i read that functions can be returned but i guess this is different... as its a completely new definition ?
17:44:42 <Cale> > integrate [1 / product[1..n] | n <- [0..]]
17:44:44 <lambdabot>  [0.0,1.0,0.5,0.16666666666666666,4.1666666666666664e-2,8.333333333333333e-3,...
17:45:22 <dmwit> > integrate [product [1..n] | n <- [0..]]
17:45:24 <lambdabot>  [0.0,1.0,0.5,0.6666666666666666,1.5,4.8,20.0,102.85714285714286,630.0,4480.0...
17:45:35 <edwardk> oscz: the issue is that if you want to supply an arbitrary function and have me take the integral of it, i need to know that its a polynomial, so i can't just take any old function
17:45:44 <edwardk> coz i can't extract its coefficients, etc.
17:45:44 <Cale> It's purely formal :)
17:46:08 <edwardk> there are ways to take the derivative of an arbitrary function in kinda neat ways, i think lennart blogged something up on the topic recently
17:47:28 <edwardk> what you can do is take that polynomial and define a simple evaluation function for it that will turn that [0,1.0] kind of polynomial into a function, integrate the polynomial, and 'evaluate' the integrated polynomial instead, but once it gets baked into a function you are limited to numerical techniques.
17:47:33 <oscz> edwardk: yes i realize that.. i ment a function that would only take care of polynomials
17:49:20 <oscz> have you guys read the book Gödel, Escher, Bach - Eternal Golden Braid ?
17:49:50 <edwardk> > let evalPoly polynomial x = sum $ zipWith (*) polynomial (iterate (*x) 1) in evalPoly [0,1,1] 2
17:49:52 <lambdabot>  6
17:50:33 <edwardk> evalPoly somepolynomial     gives you a function from one of those list-like polynomials (there is probably a better definition than the one i just rattled, let the golf commence)
17:50:52 <oscz> in that book there's lots of talk about formal systems... is it that if i'd actually define a new function that would be "jumping out of the system"
17:51:42 <oscz> Cale: is that what you mean with formal ?
17:51:42 <Cale> oscz: yeah, I read it when I was in highschool, and it changed my life :)
17:52:00 <Cale> oscz: I just mean that this definition of the integral doesn't take convergence into account.
17:52:04 * edwardk now understands how Cale became the warped and twisted individual that he is today ;)
17:52:48 <edwardk> the influence of formal methods at too young an age, such a terrible tragedy ;)
17:52:53 <Cale> Well, to be honest, I liked mathematics well enough before reading it, but it made the decision for me, between mathematics, physics and CS.
17:52:56 <oscz> Cale: heh ok.. it's very interesting book.. i dont grasp all of it but have gathered a piece from here and there
17:53:10 <idnar> heh, I also read that book quite early on
17:53:10 <Pseudonym> For further credit, BTW, what is the difference between an integral and an anti-derivative?
17:53:14 <oscz> i dont have a strong mathematical background
17:53:22 <idnar> at the time, I had to read it several times to start making sense of most of it
17:53:22 <edwardk> i backdoored into mathematics through computer graphics
17:53:23 <newsham> indefinite integral?
17:53:26 <Pseudonym> I probably shouldn't admit this, but I picked my nick while reading that book.
17:53:27 <oscz> so it helps as it's written in a popular way :)
17:53:35 <Pseudonym> It's self-referential, you see.
17:53:39 <idnar> but in some sense a lot of my mathematical background stems from just that book :P
17:54:05 <idnar> (not that I have much of a mathematical background)\
17:54:18 <Pseudonym> If Hofstadter had told that anecdote, it'd be much funnier.
17:54:28 <edwardk> i kept needing more and more mathematics to understand the papers i was trying to read on visible surface determination algorithms coz i was obsessed with large high polygon count 3d scenes.
17:54:53 <idnar> Pseudonym: heh
17:55:01 <edwardk> Pseudonym: heh
17:55:08 <omniscientIdiot> Pseudonym: heh
17:55:15 <Pseudonym> Pseudonym: heh
17:55:22 <oscz> huh did i just stick bee's nest or what's the saying in english ;)
17:55:26 <lambdabot> Pseudonym: heh
17:55:43 <lambdabot> Peer group pressure, sorry.
17:55:58 <omniscientIdiot> It's okay, LB.
17:56:27 <monochrom> hahaha
17:56:36 <geocalc> @list
17:56:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:56:52 <Cale> Pseudonym: The difference has to do with the way in which the things come about.
17:57:23 <Cale> An antiderivative for a function f is explicitly a function F whose derivative is f.
17:57:43 <edwardk> @pl \p x = sum $ zipWith (*) p (iterate (*x) 1)
17:57:43 <lambdabot> (line 1, column 6):
17:57:43 <lambdabot> unexpected "="
17:57:43 <lambdabot> expecting pattern or "->"
17:57:45 <Pseudonym> Correct.
17:57:52 <edwardk> er
17:58:02 <Pseudonym> So an anti-derivative is an algebraic concept.
17:58:10 <edwardk> @pl \p x -> sum $ zipWith (*) p (iterate (*x) 1)
17:58:10 <lambdabot> (sum .) . (. flip (iterate . (*)) 1) . zipWith (*)
17:58:19 <Cale> An indefinite integral for f is a function F such that F(b) - F(a) is the definite integral from a to b of f.
17:58:22 <Pseudonym> Bingo.
17:58:38 <Pseudonym> The crucial thing is that an anti-derivative need not obey the fundamental theorem of calculus.
17:59:55 <oscz> somehow i get the feeling that you guys are a bit smarter than the folks who dwell in traditional programming channels ;)
18:00:08 <Pseudonym> This isn't traditional programming.
18:00:15 <oscz> or imperative that is
18:00:15 <monochrom> We are self-selecting.
18:00:16 <Pseudonym> OK, example:
18:00:35 <Pseudonym> f(x) = (x^4 - 3x^2 + 6) / (x^6 - 5x^4 + 5x^2 + 4)
18:00:37 <oscz> you got me wrong
18:01:05 <Pseudonym> An anti-derivative of this is:
18:01:19 <Pseudonym> F(x) = atan((x^3 - 3x) / (x^2 - 2))
18:01:26 <edwardk> haskell probably has the most pointy-headed userbase of any language i know.  well, possibly excepting pari/gp if you go by project euler.
18:01:30 <Pseudonym> If you differentiate F, you get f.
18:01:33 <Pseudonym> But it's _not_ an integral.
18:01:47 <Pseudonym> An integral is:
18:02:13 <Pseudonym> G(x) = atan((x^5 - 3x^3 + x)/2) + atan(x^3) + atan(x)
18:02:17 <Pseudonym> So there.
18:02:28 <LoganCapaldo> pointy headed?
18:02:38 <LoganCapaldo> you trying to say my head is pointed?
18:02:40 <mr_tenor> someone said something like "this is the only langauge where the intro tutorials have links to research papers" or something ;)
18:02:49 <Pseudonym> When I see "point-headed", I think of the PHB from Dilbert.
18:03:07 <monochrom> except h refers to hair instead
18:03:12 <LoganCapaldo> pointy haired boss
18:03:14 <Pseudonym> Still.
18:03:18 <mr_tenor> pointfree-headed
18:03:24 <LoganCapaldo> I do not have a pointy head
18:03:28 <LoganCapaldo> lawl
18:03:28 <edwardk> logan: yeah, and it slopes a little to the side, birth defect? or did you get hit by a truck? =)
18:03:39 <LoganCapaldo> yowch
18:03:49 <LoganCapaldo> unecessary insultery
18:03:52 <edwardk> sorry man
18:04:24 <idnar> Pseudonym: eh, that's what I was thinking too :P
18:04:54 <jaredj> @yowch ?
18:04:54 <lambdabot> Awright, which one of you hid my PENIS ENVY?
18:05:00 <edwardk> though i guess haskell-users would have pointfree heads, as mr_tenor pointed out.
18:06:34 <LoganCapaldo> that yow response seems somehow appropriate to pointy heads.
18:06:41 <edwardk> hah
18:07:02 <Cale> Ack! My head is a lattice in which finite meets distribute over arbitrary joins!
18:07:40 <LoganCapaldo> @remember Cale Ack! My head is a lattice in which finite meets distribute over arbitrary joins!
18:07:40 <lambdabot> Done.
18:08:03 <LoganCapaldo> aqnd now I shall watch the finite simple group of order 2 video for the 10th time tonight
18:08:13 <edwardk> how many users do you think would run screaming from a programming language with monads, but without static types?
18:08:38 <jaredj> LoganCapaldo: link?
18:08:52 <jaredj> AAAGAGHAHHGHHH
18:08:56 <sorear> edwardk: is it pure?
18:08:56 <LoganCapaldo> jaredj: http://youtube.com/watch?v=UTby_e4-Rhg
18:08:59 * jaredj runs away
18:09:00 <edwardk> sorear: yeah
18:09:00 <Cale> edwardk: I think a purified scheme with monadic IO would be cool
18:09:03 <oscz> this definitely isn't the usual "expert programming language channel" where the regulars spout out function signatures like some reference libraries... this stuff seems to go a lot deeper even though i dont yet understand it ;)
18:09:12 <edwardk> cale: right now its somewhere between haskell and erlang
18:09:37 <edwardk> you specify the arity of constructors, and they have default arity 0. anything starting with an uppercase letter is a constructor or anything with an arity declaration.
18:09:40 <edwardk> so
18:09:46 <dolio> We have a bot that tells you function signatures so we don't have to.
18:09:55 <monochrom> @type map
18:09:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:09:59 <edwardk> arity 2 Cons;; map f (Cons x xs) = Cons (f x) (map f xs)
18:10:06 <edwardk> map f Nil = Nil
18:10:19 <monochrom> We have a bot for spouting out function signatures like some reference libraries. :)
18:10:52 <LoganCapaldo> Cause all I see are zeroes its a cruel trap
18:10:57 <sorear> meh, languages without static types are PURE EVIL
18:11:01 <monochrom> Having delegated an intellectual activity to machines, we can better spend time on even higher intellectual activities.
18:11:06 <edwardk> i can kinda get monads to work, though they have some ambiguous transformer commutativity issues
18:11:55 <Cale> http://uk.youtube.com/watch?v=brdmnUBAS00
18:11:59 <edwardk> sorear: i basically want to see if a CATCH/ESC/Haskell like approach can analyze an 'omega-typed' language with just polymorphic variants like that enough to make it usable.
18:12:30 <oscz> dolio: but i guess it isnt fault of people in those channels in the end .. its the fault of some properties of imperative languages..
18:12:54 <edwardk> i.e. if i can detect a flow of a constructor into a function that doesn't pattern match that constructor, i can emit a compile time error. so flow-analysis serves as a poor-man's type system.
18:13:14 <monochrom> There is strange interaction between people who use language and language which used by people.
18:14:01 <jaredj> cale: ??
18:14:02 <monochrom> People design language. Language condition people. It is hard to separate them and do a "blame analysis".
18:14:13 <jaredj> TOS phaser?
18:14:26 <LoganCapaldo> LOL
18:14:29 <LoganCapaldo> I'm dying
18:14:44 <LoganCapaldo> "It's called electrical tape because it conducts electricity"
18:14:56 <monochrom> hahaha
18:15:03 <jaredj> bahaha
18:15:26 <monochrom> Sounds like someone used it for insulation and got a big surprise.
18:15:34 <Cale> http://uk.youtube.com/watch?v=dyii4nndOMM
18:15:40 <jaredj> ROFL
18:15:47 <jaredj> "9-volt batteries can be more difficult
18:15:49 <jaredj> "
18:16:02 <edwardk> faking typeclasses is a bit tricky, and monads have to rely on the monad laws and extending all of the runFoo functions to handle identity monad values flowing into them, etc. pattern matching needs to be changed to let you define extensions to the same function in multiple source files and to use a most-specific left-to-right match rule, but its starting to come together as a fun toy
18:16:35 <LoganCapaldo> LOL
18:16:45 <LoganCapaldo> "tiny dinosaurs eggs. No one cares"
18:16:49 <LoganCapaldo> *smash smash*
18:16:52 <jaredj> lol
18:17:08 <jaredj> nice socks dude
18:17:36 <jaredj> hahahahahaha
18:17:39 <oscz> im not familiar with monads.. only seen the index topic and lots of links to tutorials about them .. they are central to the language?
18:17:51 <n00b> I am suppose o write a haskell program for  a toll road
18:18:06 <oscz> are they the most difficult part to grasp when making the transition from imperative languages ?
18:18:10 <chessguy> oscz, they are a powerful mechanism for abstraction in the language
18:18:12 <edwardk> the only way i can think of to get haskell like mathematical operators is to make + * / etc into constructors and define an 'evaluation function' that looks like a typecast.
18:18:14 <edwardk> i.e.
18:18:23 <n00b> which calculates the toll  base on class
18:18:25 <Cale> oscz: Kind of. They're an important idiom which is used in the I/O system, and supported by some syntax.
18:18:37 <platypus> oscz: They are importent as they are the main way haskell abstracts I/O.
18:18:40 <ericlavigne> @faq can haskell do meeting scheduling?
18:18:40 <lambdabot> The answer is: Yes! Haskell can do that.
18:18:41 <edwardk> a + b : Int = mp_add (a : Int) (b : Int)
18:19:00 <oscz> Cale: your introduction was very good last time.. do you have any for this topic? :)
18:19:14 <platypus> @faq Can haskell solve the halting problem.
18:19:14 <lambdabot> The answer is: Yes! Haskell can do that.
18:19:17 <jaredj> oscz: anything with state tends to be made of monads.
18:19:22 <Cale> oscz: Sure :)
18:19:23 <n00b> @faq Can haskell calculate the toll
18:19:23 <lambdabot> The answer is: Yes! Haskell can do that.
18:19:44 <ericlavigne> I like lambdabot :-)
18:19:44 <edwardk> @faq can haskell do my laundry?
18:19:44 <lambdabot> The answer is: Yes! Haskell can do that.
18:19:49 <n00b> @faq how do I calculate the toll
18:19:49 <lambdabot> The answer is: Yes! Haskell can do that.
18:20:03 <ericlavigne> @faq What are lambdabot's capabilities?
18:20:04 <lambdabot> The answer is: Yes! Haskell can do that.
18:20:08 <Cale> oscz: In fact, I've written a number of tutorials. Let's start off by looking at how I/O is accomplished, and then look at the more general case. (However, I don't want to give too much of an impression that I/O-like things are all that monads are good for)
18:20:18 <n00b> @faq cab haskell fuck me
18:20:18 <lambdabot> The answer is: Yes! Haskell can do that.
18:20:40 <n00b> lambadot as errors
18:20:45 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
18:20:46 <lambdabot> Title: Introduction to IO - HaskellWiki
18:20:54 <oscz> Cale: ok.. i realize that IO input is different from functions as their outcome is not known
18:21:01 <Cale> Check that out if you will, it should only take a couple minutes to read
18:21:10 <oscz> sure
18:21:16 <Cale> (I wrote it :)
18:21:18 <n00b> @google calculating the toll in haskell
18:21:20 <lambdabot> http://www.cs.unc.edu/~search/calculating-mortgage-payment-after-taxes.html
18:21:20 <lambdabot> Title: Calculating Mortgage Payment After Taxes :: Loans, Lending and Lenders
18:22:00 <n00b> @google calculating toll in haskell
18:22:02 <lambdabot> http://www.cs.unc.edu/~search/calculating-mortgage-payment-after-taxes.html
18:22:02 <lambdabot> Title: Calculating Mortgage Payment After Taxes :: Loans, Lending and Lenders
18:25:36 <ericlavigne> @help
18:25:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:25:42 <wnoise> edwardk: Lots of list processing stuff is monadic, and I do get annoyed at the lack of static type analysis, but I muddle through.
18:26:03 <ericlavigne> @help list
18:26:03 <lambdabot> list [module|command]
18:26:03 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:26:26 <oscz> Cale: few minutes?? us mortals spend days digesting this :\
18:26:34 <Cale> okay
18:26:43 <Cale> Well, ask questions :)
18:27:18 <Cale> The idea is that values of type (IO t) are like imperative program scripts
18:27:18 <oscz> so.. when its not a real function
18:27:27 <oscz> IO type seem to be returned ?
18:27:36 <Pseudonym> It _is_ a real function.
18:27:44 <Pseudonym> That bit is important.
18:27:50 <Cale> putStrLn, for example
18:27:51 <oscz> oh.. ok
18:27:57 <Cale> is a function which takes a tring
18:28:00 <Cale> is a function which takes a String
18:28:00 <oscz> only the return value is funny ?
18:28:06 <oscz> but thats a normal type ?
18:28:08 <Cale> and gives an *action*
18:28:23 <Cale> And whenever you pass it the same string, it gives back the same action.
18:28:38 <scook0> (up to equivalence of actions)
18:28:40 <wnoise> One way of thinking about it is that haskell is inside out.  They call functions IO actions, and macros functions.  But the "macros" can get used at runtime.
18:28:41 <Cale> Namely, the action which represents printing the given string on the screen.
18:28:52 <Cale> wnoise: heh
18:29:49 <wnoise> (Not the _best_ way, but it'll give you some intuition.)
18:29:53 <oscz> oh... so say print "hello world" returns the "action" of printing "hello world"
18:29:54 <ericlavigne> @fortune
18:29:54 <lambdabot>   May I ask a question?
18:30:06 <scook0> oscz: yup
18:30:06 <Pseudonym> lambdabot: Sure!
18:30:13 <oscz> but.. what's it value ?
18:30:15 <chessguy> @dice 8
18:30:15 <lambdabot> 8 => 8
18:30:20 <Cale> oscz: Right, it returns a little program (which doesn't run yet) that says to print "hello world" on the screen.
18:30:20 <chessguy> @dice 8
18:30:20 <lambdabot> 8 => 8
18:30:27 <Pseudonym> ?dice 1d8
18:30:27 <oscz> and when the action is executed ?
18:30:27 <lambdabot> 1d8 => 2
18:30:36 <Pseudonym> ?dice d8 + d12
18:30:36 <lambdabot> unexpected "d": expecting number
18:30:40 <Pseudonym> ?dice 1d8 + 1d12
18:30:40 <lambdabot> 1d8 + 1d12 => 6
18:30:44 <Cale> When the action is executed, that string actually gets printed
18:30:54 <Cale> Pseudonym: what's up with all the noise?
18:31:51 <Cale> The only actions which get executed are those which you type into GHCi, or the action defined as main in a compiled program
18:32:16 <Cale> The RTS evaluates the action and as it works out what the action says to do, it carries it out.
18:32:23 <oscz> Cale: but say you have this kind of function.... and you have another function defined like foo = "what will be the text after this: " +  the_weird_io_function ?
18:32:44 <Cale> + ?
18:32:50 <scook0> the answer is "you can't do that directly"
18:32:51 <oscz> what will that be evaluated to ?
18:32:57 <Cale> That'll be a type error
18:33:06 <edwardk> oscz: well, then it'll try to apply + to a string on the left and an IO something on the right and the types won't match
18:33:08 <scook0> (incidentally, string concatenation is (++), not (+))
18:33:14 <oscz> Cale: oh sorry.. i ment like string concatenation if you know what i mean
18:33:16 <Cale> For example, suppose you have something like
18:33:23 <Cale> foo = "hello" ++ getLine
18:33:27 <Cale> that's still a type error
18:33:34 <Cale> Because getLine isn't a string
18:33:46 <Cale> It's an IO action which happens to return a String when it's run
18:33:47 <edwardk> but you could say foo = do x <- the_weird_io_function; return ("what will be the text after this" + x)
18:33:53 <edwardk> and explicitly order the two actions
18:34:02 <allbery_b> or use fmap
18:34:16 <allbery_b> or liftM
18:34:19 <scook0> allbery_b: hush! :)
18:34:25 <allbery_b> :)
18:34:34 <allbery_b> @quote brain.explod
18:34:35 <lambdabot> No quotes match. Wrong!  You cheating scum!
18:34:39 <allbery_b> hm
18:34:43 <allbery_b> too much lost state
18:34:46 <scook0> [besides, <$> is obligatory these days ;)]
18:35:06 <allbery_b> oh
18:35:09 <Cale> Let's use the basic combinators I actually introduced in the article ;)
18:35:10 <allbery_b> @quote head.explod
18:35:10 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
18:35:19 <tessier> heh
18:35:27 <edwardk> oscz: the issue at hand is what order would the getlines in getLine ++ getLine be called? and why isn't that equivalent to let x = getLine in x ++ x     if we want equational reasoning to hold we need to have someway to distinguish the two cases.
18:35:51 * allbery_b should really study Control.Applicative sometime
18:35:54 <Cale> So suppose the goal is to produce an action which when run will get a line from the user and return the string "hello" concatenated with whatever was typed
18:36:21 <Cale> So the first thing we want to do is getLine
18:36:24 <oscz> Cale: i couldnt absorb it all that quickly and i thought i might get it going through step by step like your last introduction
18:37:06 <oscz> ok..
18:37:07 <Cale> getLine >>= ...
18:37:19 <Cale> We want to use the result, so it must be >>= that we need
18:37:23 <oscz> whats >> ?
18:37:37 <edwardk> there are 3 interpretations of getLine ++ getLine that are reasonable, the monad syntax lets us figure out which one we mean. do  x <- getLine; y <- getLine; return (x ++ y)   vs.  do y <- getLine; x <- getLine; return (x ++ y)      vs. do x <- getLine; return x ++ x
18:37:40 <oscz> as in contrast to plain =
18:37:45 <Cale> If x and y are actions, then x >> y is the action which does x, then does y, returning the result of y
18:38:05 <allbery_b> @undo do x <- foo; putStrLn x
18:38:05 <lambdabot> (foo >>= \ x -> putStrLn x)
18:38:26 <Cale> This channel is a little noisy, care to move to #haskell-overflow?
18:38:29 <chessguy> edwardk, i think you mean return (x ++ x)
18:38:36 <edwardk> er yeah =)
18:38:36 <oscz> me ?
18:38:41 <Cale> yeah
18:38:44 <edwardk> i'll back off and let cale talk
18:39:17 <Cale> I'm trying to introduce the actual way to think about IO and not alternative possibilities ;)
18:39:30 <Cale> (though that might eventually help)
18:41:29 <edwardk> @seen ski
18:41:29 <lambdabot> ski is in #haskell-overflow, ##logic and #haskell. I don't know when ski last spoke.
18:44:39 <n00b> is there anyone who know how to write a program for the toll
18:44:53 <n00b> to calculate toll cost
18:45:00 <chessguy> n00b, you're going to have to give us some more detailed specifications
18:45:05 <n00b> class a, b,c
18:45:15 <mrd> toll on the turnpike
18:45:24 <edwardk> what turnpike? =)
18:45:45 <jaredj> and who assigned the question?
18:46:13 <n00b> here's the question my teacher gave me
18:46:43 <edwardk> always a dangerous way to lead into a description seeking help ;)
18:47:02 <n00b> toll charges for use of a highway are calculatd based on the class of the vehicle and the number of passengers in the vehicle
18:47:31 <mr_tenor> http://www.hcsw.org/XML.html doesn't take too long to mention S-expressions ;)
18:47:35 <lambdabot> Title: XML Sucks
18:47:55 <lzfn1> @src unwords
18:47:55 <lambdabot> unwords [] = ""
18:47:55 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
18:48:12 <n00b> class 1 vehicles (cars), flat fee of 50 for up to 4 pass. Additonal 10 for each excess, maximum of 8
18:48:58 <n00b> class 2 (bus & vans) 20 per pass. Maximum of 30 passs
18:50:00 <n00b> class 3 (trucks & amored tanks) flate fee 500 is charged irrespective of load carried , or numb of passengers
18:50:10 <jaredj> you let tanks through?!
18:51:32 <n00b> it is just a question
18:52:29 <jaredj> ok you have three classes
18:52:51 <n00b> yes
18:52:58 * platypus would (and others will correct me if I'm wrong) create a type representing the verious classes of vieachals and then have a patten match returning the verious tolls.
18:53:11 <jaredj> i would too.
18:53:31 <n00b> yeah i thought of that
18:53:56 <n00b> but what about the extra passengers for class 1 & 2
18:53:59 <mrd> vehicles and various
18:54:03 <mrd> and pattern
18:54:10 <edwardk> toll (Car passengers) | passengers <= 4 = 50 | otherwise = 50 + (passengers - 4) * 10
18:54:11 <mrd> Patten match hmm
18:54:18 <jaredj> your data constructors can take params
18:54:33 <edwardk> toll (Bus passengers) | passengers <= 30 = 20 * passengers
18:54:40 <jaredj> edwardk: sshh
18:55:01 <jaredj> you leave nothing to the imagination! ;/
18:55:28 <edwardk> well, he still has to figure out how to use those pattern guards and format that, and has to figure out how to construct the type, etc. ;)
18:55:37 <ddarius> You should @pl your answers first
18:55:40 <edwardk> heh
18:55:46 <jaredj> @what?
18:55:46 <lambdabot>  @where <key>, return element associated with key
18:56:24 <jaredj> yes - the type is the first question
18:56:24 <Korollary> @where my keys
18:56:25 <lambdabot> I know nothing about my.
18:58:26 <n00b> i already wrote  it
18:58:42 <edwardk> er and he'd have to fix the bug in my Car code
18:58:43 <platypus> ddarius: What is @pl?
18:59:29 <edwardk> @pl splitLines text = map lines (words text)
18:59:29 <lambdabot> splitLines = map lines . words
18:59:48 <edwardk> it transforms your code to use the 'pointfree' style, where the arguments are not mentioned explicitly
18:59:53 <jaredj> oh, that thing
19:00:12 <jaredj> i've always thought it ironic that making things pointfree introduces many (.)
19:00:26 <edwardk> jaredj: yeah
19:00:33 <chessguy> @type f [] = return []; f (x:xs) = do result <- x; results <- f xs; return result:results
19:00:35 <lambdabot> parse error on input `='
19:01:03 <chessguy> > let f [] = return []; f (x:xs) = do result <- x; results <- f xs; return result:results in f
19:01:04 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
19:01:04 <lambdabot>       Expected...
19:01:30 <n00b> how do I make it return the results with a dollar sign
19:01:42 <jaredj> wait what?
19:01:59 <edwardk> show the number, then manipulate the string
19:02:09 <ddarius> @help pl
19:02:09 <lambdabot> pointless <expr>. Play with pointfree code.
19:02:24 <chessguy> > "$" ++ show 42
19:02:28 <lambdabot>  "$42"
19:02:41 <edwardk> > '$':show 42
19:02:42 <lambdabot>  "$42"
19:02:53 <jaredj> ohhh
19:02:54 <n00b> i dont want it to be a  string
19:03:01 <jaredj> ur?
19:03:29 <chessguy> so what's wrong with my function above?
19:03:46 <n00b> it is a string
19:03:53 <edwardk> newtype Dollars = Dollars Int deriving (Num); instance Show Dollars where show (Dollars x) = '$':show x
19:03:57 <edwardk> then you can return Dollars ;)
19:04:22 <n00b> don't quite understand ???
19:04:55 <wnoise> You only need the "$" when it prints out.  At that point you do this show thing.
19:04:59 <edwardk> that would be the problem
19:05:59 <n00b> passengers <= 50 = "$" ++ show 50
19:06:10 <n00b> ??
19:07:45 <n00b> but when calculating a float results
19:08:14 <n00b> the final output would be a string ???
19:08:29 <dibblego> ?hoogle (a -> Bool) -> [a] -> ([a], [a])
19:08:29 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
19:08:29 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
19:08:29 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
19:08:34 <chessguy> @type f [] = return []; f (x:xs) = do result <- x; return result:(f xs)
19:08:36 <lambdabot> parse error on input `='
19:08:47 <chessguy> @type let f [] = return []; f (x:xs) = do result <- x; return result:(f xs) in f
19:08:49 <lambdabot> forall a. [[a]] -> [[a]]
19:08:52 <edwardk> n00b: you want two functions, one to compute the numerical toll, the other to format and print it nicely.
19:09:04 <n00b> ok
19:09:05 <edwardk> you're entangling the logic of these two steps
19:09:22 <chessguy> @type let f [] = return []; f (x:xs) = do { result <- x; return result:(f xs) } in f
19:09:24 <lambdabot> forall a. [[a]] -> [[a]]
19:09:31 * chessguy scratches his head
19:09:31 <n00b> Float -> Float -> String
19:10:17 <geocalc> > "$":show "pay PAY !!!"
19:10:18 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:10:51 <chessguy> geocalc, that's '$', not "$"
19:10:51 <wnoise> > '$':show "pay PAY !!!"
19:10:53 <lambdabot>  "$\"pay PAY !!!\""
19:11:00 <wnoise> > '$':"pay PAY !!!"
19:11:01 <lambdabot>  "$pay PAY !!!"
19:12:28 <jaredj> chessguy: do { result <- x; ... } considers x to be a list
19:12:36 <jaredj> i believe
19:13:00 <monochrom> I agree with edwardk.
19:13:03 <chessguy> jaredj, why would it do that?
19:13:31 <jaredj> chessguy: a list is (among other things) a monad
19:13:36 <monochrom> It is a notorious habit of imperative programmers to mix up, say, in their own terms, the business logic with the frontend tier.
19:13:36 <wnoise> List is the only monad that makes sense the way you used it.
19:13:38 <chessguy> jaredj, i'm well aware of that
19:13:46 <jaredj> k
19:13:48 <chessguy> but why would it assume that that's the monad i'm talking about
19:13:58 <allbery_b> because it's the only vsible monadic type
19:14:04 <allbery_b> in tat expression as written
19:14:10 <edwardk> monochrom:  =)
19:14:37 <chessguy> i would expect it to give me back the type [m a] -> m [a]
19:14:42 <allbery_b> if you don't specify a different monad in a type signature (or use of, say, functions in IO), it'll assume list
19:14:57 <allbery_b> hm, wonder if that's MR
19:15:01 <allbery_b> somehow
19:15:05 <edwardk> chessguy: you used a :
19:15:14 <edwardk> ah
19:15:16 <edwardk> hrm
19:15:17 <chessguy> @type let f ([] :: Monad m -> [m]) = return []; f (x:xs) = do { result <- x; return result:(f xs) } in f
19:15:19 <lambdabot>     Class `Monad' used as a type
19:15:19 <lambdabot>     In the type `Monad m'
19:15:26 <chessguy> @type let f ([] :: Monad m => [m]) = return []; f (x:xs) = do { result <- x; return result:(f xs) } in f
19:15:28 <lambdabot>     `m' is not applied to enough type arguments
19:15:28 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
19:15:39 <edwardk> @type sequence
19:15:40 <chessguy> @type let f ([] :: Monad m => [m a]) = return []; f (x:xs) = do { result <- x; return result:(f xs) } in f
19:15:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:15:43 <lambdabot>     All of the type variables in the constraint `Monad m' are already in scope
19:15:43 <lambdabot>         (at least one must be universally quantified here)
19:15:45 <chessguy> bah, do what i mean, not what i say
19:16:03 <chessguy> wtf is that error?
19:16:14 <allbery_b> you need a forall
19:16:22 <allbery_b> see the type for sequence
19:16:28 <allbery_b> (right above your error)
19:16:33 <wnoise> Hmm.  I misread.
19:16:47 <chessguy> @type let f ([] :: forall (m :: * -> *) a. Monad m => [m a]) = return []; f (x:xs) = do { result <- x; return result:(f xs) } in f
19:16:49 <lambdabot>     Cannot match a monotype with `forall (m :: * -> *) a.
19:16:49 <lambdabot>                                   (Monad m) =>
19:16:54 <chessguy> augh!
19:16:57 <jaredj> bahahaha
19:17:13 <chessguy> ok, i give up
19:17:33 <jaredj> i dunno dude. i'm surprised you need to drag kinds into it
19:17:45 <edwardk> @type let f [] = return []; f (x:xs) = do result <- x; do result' <- f x'; return (result:result') in f
19:17:47 <lambdabot> Not in scope: `x''
19:17:49 <edwardk> er
19:18:15 <chessguy> xs, not x'
19:18:34 <edwardk> type let f [] = return []; f (x:xs) = do result <- x; result' <- f xs; return (result:result') in f
19:18:48 <edwardk> @type let f [] = return []; f (x:xs) = do result <- x; result' <- f xs; return (result:result') in f
19:18:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:18:53 <edwardk> typos will be the death of me
19:18:54 <wnoise> @src sequence
19:18:54 <lambdabot> sequence ms = foldr k (return []) ms
19:18:54 <lambdabot>     where
19:18:54 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:19:09 <edwardk> you missed the second <-, so you weren't evaluating the tail
19:19:22 <chessguy> edwardk, hmm. i thought i tried that
19:19:44 * ddarius imagines some programmers on life-or-death medical equipment being in a situation where they are the consumers of it.
19:20:26 <monochrom> that would complete the recursion nicely
19:21:14 <chessguy> ah, i was doing (return result:result') instead of return (result:result')
19:21:24 * edwardk has terrifying visions of hacking your own programmable pacemaker or something.
19:21:31 <monochrom> don't you wish, say, msword programmers be put on lift support equipment based on msword and is virus-vulnerable.
19:22:07 <wnoise> Why would I be that hostile towards msword programmers, when I don't use msword?
19:22:11 <Philippa_> ddarius: wrong window there?
19:22:40 <monochrom> because it spreads viruses. it is a world-wide problem. everyone is affected, even non-users.
19:22:50 <ddarius> No.
19:22:56 <edwardk> @type foldr (liftM2 (:)) (return [])
19:22:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:23:02 <edwardk> better =)
19:23:03 <ddarius> Response to "typos will be the death of me"
19:23:14 <monochrom> It is like you are not a Burmese but you still wish the Burmese militant government steps down.
19:23:41 <chessguy> @undo do { x <- m; xs <- m'; return (x:xs) }
19:23:41 <lambdabot> (m >>= \ x -> m' >>= \ xs -> return (x : xs))
19:23:53 <monochrom> simply because those people are the shame of all humanity.
19:23:58 <chessguy> @pl k m m' = (m >>= \ x -> m' >>= \ xs -> return (x : xs)
19:23:58 <lambdabot> (line 1, column 8):
19:23:59 <lambdabot> unexpected "="
19:23:59 <lambdabot> expecting variable, "(", operator or end of input
19:23:59 <wnoise> The burmese have little choice in goverment.  Most people have sufficient choice in programs.
19:24:23 <edwardk> @src liftM2
19:24:24 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:24:31 <chessguy> @pl \m m' -> m >>= \ x -> m' >>= \ xs -> return (x : xs)
19:24:31 <lambdabot> liftM2 (:)
19:24:39 <ddarius> edwardk: I'd never want a "headjack" for these reasons.  I don't even trust -myself- to program that correctly.
19:24:45 <edwardk> ddarius: =)
19:24:51 <chessguy> i was trying to see if @pl could figure that out :)
19:24:54 <chessguy> apparently it can
19:25:08 <Philippa_> yeah, I trust them as strictly input devices but you can forget about them for output
19:25:11 <edwardk>  @pl is a better programmer than I am
19:25:20 <Philippa_> (that is, input to another system - equivalent to mouse, keyboard etc)
19:27:00 <edwardk> yeah as the garbage collector gets rid of my childhood to make room for more mp3s.
19:27:31 <monochrom> you store mp3s in your brain?!
19:27:54 <ddarius> The government will come and confiscate it when those DRM laws get passed!
19:28:31 <edwardk> monochrom: really improves the amount of storage you have in that phonological buffer
19:29:20 <monochrom> I used to take up a CD, look at it, and start singing its tunes.
19:31:10 <edwardk> Of course if i ever forget to pay the license fees to Fraunhofer LLC or whoever presses a patent claim, I guess it could go poorly for me.
19:31:15 <monochrom> Anyway, "author of X is put on lift support based on X" - is that hostile? If X is really reliable, you don't consider it hostile. If X is really flaky, you consider it hostile. Is it me who make it hostile, or is it the author himself/herself?
19:33:01 <monochrom> I think if you don't keep a decoder in your brain, you're fine.
19:33:29 <edwardk> monochrom: its the encoder that usually slams you with fees, no?
19:33:42 <monochrom> oh, don't keep an encoder either :)
19:34:34 * edwardk goes to switch his brain over to Ogg Vorbis, but dreads the inevitable transcoding artifacts.
19:35:13 <monochrom> We should find a baby and train him/her to encode and decode mp3s mentally. At the same time, train him/her to compile Haskell programs mentally, just so we stay on topic.
19:35:44 <edwardk> just raise the baby, and only speak haskell to them
19:36:04 <monochrom> Not just that. I want them to emit x86 code.
19:36:07 <Korollary> You don't find babies. You make them.
19:36:24 <monochrom> I don't want to do it to my own babies. Obviously. :)
19:36:57 <edwardk> i dunno, a kid who can enter kindergarten with a solid understanding of corecursion would be a fun project ;)
19:36:57 <Philippa_> Korollary: you damn breeders might :-)
19:36:57 <Korollary> So you wanna mess with someone else's baby? Good thing we have FBI agents in this channel.
19:37:43 <monochrom> I believe messing with my own baby carries the exact same charge.
19:37:56 <edwardk> As my wife is a proud member of cf_hardcore, it is unlikely that i'll be engaging in Korollary's version of this process.
19:39:22 <Korollary> The babies of the 21st century shall be born with 802.11g, bluetooth, and usb2.0.
19:40:03 <edwardk> i hope that the interface specs will have progressed from there somewhat ;)
19:40:33 <monochrom> "Software tycoons compete for bright young minds"
19:40:44 <edwardk> at this rate its more likely they'll be born with RFID 1.0 ;)
19:40:56 <Korollary> Those are neocon babies
19:47:34 <chessguy> @quote paperwork
19:47:34 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
19:47:45 <chessguy> i think Cale's trying to make this come true ^^
19:50:13 <misterbeebee> is there a *practical* and *simple* way to use something like a unique/linear type in haskell. That is, to create a structure, and pass it around, and mutate it, in a safe way (because there is never more than one reference to the structure)?  For example, if I want to create a large tree and mutate it via a sequence of operations.   If I were to use a monad to enforce encapsulate the mutability, how would I implement the efficient operati
19:50:47 <misterbeebee> (Is the answer to my question "Clean"?)
19:51:08 <chessguy> this is what the State monad is for
19:51:25 <chessguy> (if i understand you correctly)
19:51:40 <misterbeebee> Is State *efficient*, or merely logically equivalent?
19:52:01 <misterbeebee> I understand State to give the appearance of mutation, but does it allow "recycling" of pieces of a data structure on the heap?
19:52:20 <chessguy> that's an implementation question, not a language question
19:53:06 <misterbeebee> I'm not sure I understand that. You mean it depends on the implementation of State?
19:53:37 <chessguy> no, by implementation here, i mean GHC/Hugs/whatever
19:53:55 <chessguy> or did you mean that you want to do that explicitly?
19:54:02 <misterbeebee> right, so, in cases where GHC is not efficient for my problem, because it can't guess when to recycle,
19:54:14 <edwardk> misterbeebee: ST s is pretty efficient, State is plumbing
19:54:36 <misterbeebee> but *I* know when to recycle pieces of data, and I want to be explicit, but I can't do so with basic Haskell (nearly be definition)
19:55:01 <Cale> misterbeebee: GHC's GC is really good at cleaning up short-lived objects
19:55:02 <edwardk> ST s based say, union-find can run in optimal time, while if you do it with state you lose in the best case a logarithmic factor
19:55:18 <Cale> misterbeebee: especially if you've compiled with optimisations
19:55:51 <Cale> edwardk: does it need arbitrary numbers of mutable bits of state?
19:55:57 <misterbeebee> So, I'm definitely enough of a beginner to not know exactly, what I'm talking about, but, for a concrete example:
19:56:24 <chessguy> edwardk, what do you mean by plumbing, in this case?
19:56:26 <misterbeebee> Say I have a string, many megabytes, and I want to cut and paste, and chop and reassemble and insert and delete from the middle.
19:56:39 <misterbeebee> And this string is the centerpiece of my program, it's huge and unique,
19:56:40 <edwardk> cale: yeah, the traditional algorithm requires mutable pointers, hence the ST s version of it having a better asymptotic behavior than carrying a state of a Map or something
19:57:02 <Cale> misterbeebee: Data.Sequence :)
19:57:03 <edwardk> chessguy: the State or StateT monad is just plumbing, all it does it carry around an extra function argument for you you could have carried yourself
19:57:10 <edwardk> the ST monad gives you access to IO like mutation
19:57:18 <misterbeebee> Yes, I've looked at Data.Sequence
19:57:27 <Cale> misterbeebee: It has logarithmic splitting and concatenation
19:57:36 <misterbeebee> When I tried it, it seemed memory-expensive because there are boxed chars(?) at each element
19:57:50 <Cale> Yeah, that might be an issue.
19:57:51 <misterbeebee> but I want each chunk to be something like an arra
19:57:56 <misterbeebee> array
19:58:01 <Cale> Maybe a Data.ByteString?
19:58:07 <edwardk> misterbeebee: build it over a Sequence of Bytestrings or something
19:58:24 <misterbeebee> yeah, i started with that, then I think I exhausted my own haskell skill :)
19:58:34 <edwardk> the way that sjanssen and company want to implement 'Rope's
19:58:48 <misterbeebee> yeah, I've read a bit about that.
19:59:24 <misterbeebee> I had a crisis of confidence, thinking: if that's the answer, and it's not really hard, why isn't it done yet? (but maybe i'm biased to think my problems are universal and important)
19:59:36 <duryodhan222> http://www.lisperati.com/haskell/ht1.html   <--- I am trying to follow this tutorial (total noob to haskell) and I am getting "can't import Text.RegEx " when I try to load it in hugs
19:59:54 <edwardk> misterbeebee: procrastination
20:00:13 <duryodhan222> that tutorial asks to use ghc and not hugs , but it is too painful to get ghc compiled on my machine ...
20:00:15 <edwardk> misterbeebee: and there are various points in the design space that have different benefits
20:00:21 <chessguy> duryodhan222, the secend 'e' should be lowercase, not capital
20:00:23 <Cale> misterbeebee: There's only so much Haskell community to go around :)
20:00:40 <misterbeebee> so if i want something that works, but not something that's standard-library quality, it's not a fool's errand to try to make it myself?
20:00:41 <chessguy> @hoogle Regex
20:00:42 <lambdabot> Text.Regex :: module
20:00:42 <lambdabot> Text.Regex.Regex :: data Regex
20:00:42 <lambdabot> Text.Regex.Posix.regExtended :: Int
20:00:43 <duryodhan222> chessguy: it is lower case
20:00:49 <edwardk> i.e. you want to coalesce small bytestrings, etc to cut constant factors,
20:00:52 <duryodhan222> I screwed up while typing ...
20:00:55 <Cale> misterbeebee: Until recently, we were very tiny, it's just starting to get big.
20:00:55 <chessguy> ok
20:01:13 <misterbeebee> Cale: yep, I understand.
20:01:17 <duryodhan222> hugs version september 2006
20:01:32 <chessguy> hm, i haven't used hugs in a long time
20:01:47 <chessguy> ghc has a binary for most platforms. it shouldn't be hard to install
20:02:08 <edwardk> misterbeebee: i had started one, but i needed it to hold utf8 values, so mine isn't pleasant and was too slow for me to be happy with.
20:02:42 <duryodhan222> slackware linux .... there are no packages for it ...
20:02:57 <misterbeebee> what worries me when I write code is that, due to the.. subtleties.. of haskell, if I get stuck one something, there's usually no way to "hack around it" it requires studying up to a higher level of theoretical understanding to make progress... so i'm wary of starting on a task I dont' alread yunderstand very well.
20:04:52 <misterbeebee> I guess I'll try again using Data.Sequence + ByteString (plus new work to get access to the characters in the bytestring via functions on the Sequence), and see if i don't get flummoxed.
20:04:54 <misterbeebee> thankxz
20:05:24 <duryodhan222> Isn't there some way that I can get ghc to compile using a C compiler ?
20:05:35 <Cale> misterbeebee: You might also just try a Lazy ByteString and see whether it's too slow
20:05:35 <duryodhan222> it sez that it needs an older ghc to compile ..
20:05:37 <edwardk> if you get stuck feel free to ask for help
20:05:49 <duryodhan222> Isn't there support for make bootstrap like in gcc ?
20:05:49 <Cale> duryodhan222: -fvia-C
20:05:59 <Cale> duryodhan222: you're compiling GHC itself?
20:06:15 <Cale> duryodhan222: If you can avoid doing that, then avoid it.
20:06:18 <misterbeebee> edwardk thanks. now that I've found the irc channel, i might be able to get over humps  when I'm stuck, and get reinforcement when i'm on the right track
20:06:30 <duryodhan222> Cale : my platform doesn't seem to have packages ...
20:06:38 <Cale> duryodhan222: which platform?
20:06:44 <duryodhan222> Cale: Slackware Linux 12
20:06:54 <misterbeebee> (or maybe the Utrecht team will unveil a ropes library at ICFP next week... it seems they must have had one for the ICFP contest :) )
20:06:55 <Cale> Use the generic linux package
20:07:06 <edwardk> misterbeebee: heh
20:07:10 <Cale> http://haskell.org/ghc/download_ghc_661.html#x86linux
20:07:12 <lambdabot> Title: GHC: Download version 6.6.1
20:07:40 <monochrom> generally don't compile ghc yourself. takes too long.
20:08:36 <Cale> The only good reason is if you're going to hack on it. If there *really* isn't a package for your platform, you'll probably have to hack on it a bit anyway if you want it to work.
20:09:08 <duryodhan222> I am just wondering why there isn't a way to compile it like hugs ?
20:09:20 <duryodhan222> cos 34 MB is gonna take a helluva time on my net connection
20:09:42 <monochrom> how large is the source again?
20:09:58 <duryodhan222> the source is 5MB around
20:10:03 <duryodhan222> the binary package is 34MB
20:10:20 <monochrom> the binary package has both ghc and "extralibs"
20:10:26 <allbery_b> dude, unless you've got a hot build machine like dons does (or an old-fashioned modem connection), it'll take longer to compile than to download
20:10:30 <monochrom> how large is the source for extralibs?
20:11:04 <duryodhan222> around 9 MB
20:11:10 <monochrom> and I agree with allbery_b. you're looking at "8 hours to compile" vs "8 hours to download".
20:11:25 <duryodhan222> my university net connection has a limit on a single download of 20MB
20:11:37 <duryodhan222> so I will have to tunnel through a proxy or something to get the download working
20:11:39 <allbery_b> wow
20:11:44 <duryodhan222> yeah
20:12:04 <duryodhan222> and you thought I enjoyed compiling :)
20:12:04 <allbery_b> and people complain that CMU's limits are small...
20:12:33 <allbery_b> no, I gfigured you assumed the source would be muchj smaller (true) and compilation was fast (false)
20:12:55 <duryodhan222> naah fast compilation isn't necessary
20:13:10 <monochrom> there is also the bootstrapping question of "I don't have ghc, how do I compile ghc"
20:13:10 <duryodhan222> it probably wouldn't be longer than gcc
20:13:31 <bos> ha
20:13:36 <duryodhan222> thats why i said .. why doesn't it have a src with a make bootstrap option
20:13:45 <duryodhan222> like gcc
20:13:49 <bos> ghc takes hours to build, you can build gcc in maybe 2 minutes on a fast machine
20:13:56 <sorear> duryodhan222: what does gcc's make bootstrap do?
20:14:08 <sorear> duryodhan222: does make bootstrap work on a system without a C compiler?
20:14:13 <duryodhan222> no ...
20:14:17 <duryodhan222> what you do is ...
20:14:21 <sorear> duryodhan222: GHC is written in Haskell.
20:14:28 <duryodhan222> ohhh
20:14:30 <duryodhan222> ok ok
20:14:40 <duryodhan222> hugs is written in C ?
20:14:44 <allbery_b> yes
20:14:51 <duryodhan222> which one should I stick to now ?
20:14:58 <sorear> Hugs, since you have it.
20:15:03 <allbery_b> given your download issues, stick with hugs
20:15:16 <duryodhan222> naah I started ghc ... it will be over in around 8-9 hours
20:15:21 <duryodhan222> :)
20:15:30 <allbery_b> er?
20:15:37 <duryodhan222> the download ...
20:15:38 <sorear> And people doubt the purpose of sleep!
20:15:39 <allbery_b> so do you have a bootstrap ghc binary to build it with?
20:15:59 <duryodhan222> I am downloading the generic binary package ...
20:16:10 <allbery_b> it mioght work better to see if someone can put up a binary package split into smaller chunks you can download separately and cat together
20:16:20 <duryodhan222> no its ok ...
20:16:26 <duryodhan222> I will sleep through it ...
20:16:28 <chessguy> hmm, this is the first i've seen http://www.lisperati.com/haskell/
20:16:31 <allbery_b> heck, I can stuff that in my CMU web space if you tell me which binary package you need
20:16:35 <chessguy> an interesting, if complicated, tutorial
20:16:40 <duryodhan222> chessguy: prog. reddit.
20:17:13 <duryodhan222> allbery_b: thanks but I have started the download ... if it doesn't work out I will bug you :)
20:17:52 <duryodhan222> the reason I started with hugs is I found this old dusty book in my library .."Haskell : Craft of functional programming" ...
20:17:57 <duryodhan222> it said to use hugs ...
20:18:30 <duryodhan222> Is that book still good or should I try out the stuff online ?
20:18:52 <chessguy> that book is still good
20:19:04 <duryodhan222> ok ..
20:19:16 <duryodhan222> just that it was printed in '98 , so I wondered a litttle ...
20:19:23 <allbery_b> hugs misses some of the fancier neew stuff
20:19:29 <chessguy> though ghc is probably a better implementations in most senses of the word 'better'
20:19:34 <allbery_b> for learning haskell, haskell98 spec is fine
20:19:36 <sorear> Haskell hasn't changed officially since then
20:19:42 <duryodhan222> k
20:20:00 <allbery_b> (and it does support some p[ost-haskell98 extensions, just not the most recent ones from the past couple years)
20:21:06 <allbery_b> it also is an interpreter, so it doesn't produce fast programs.  it is I think still slightly faster than ghci (ghc's interpreter), but ghc com[piled code blows both away
20:21:45 <duryodhan222> for learning a compiler is good enough ...
20:21:53 <ddarius> allbery_b: It starts up faster than GHCi and maybe if you use GHCi as a source interpreter it's faster, but the interpretation done by GHCi is way faster than Hugs.
20:22:04 <sorear> a compiler is always good enough
20:22:05 <duryodhan222> s/compiler/interpreter
20:24:08 <sorear> certainly
20:37:32 <chessguy> @type mapAndUnzipM
20:37:34 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c])
20:37:46 <chessguy> never saw that one before :)
20:38:57 <ddarius> @index mapAndUnzipM
20:38:58 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:39:35 <ddarius> :t mapAndUnzipM return
20:39:37 <lambdabot> forall b c (m :: * -> *). (Monad m) => [(b, c)] -> m ([b], [c])
20:42:30 <chessguy> err, in the second-to-last line of code, near the bottom of the page, shouldn't it be return $ f `ap` x1 ... ?
20:43:46 <chessguy> oh, i guesss i should give the link i'm looking at
20:43:48 <chessguy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v%3Aap
20:43:51 <lambdabot> http://tinyurl.com/ykyqfl
20:44:55 <seafoodX> Hi guys. Look, I'm embarassed to be asking this question but what the hell is going on here?
20:44:56 <seafoodX> <stdin>: hGetContents: illegal operation (handle is closed)
20:45:24 <seafoodX> I'm using "s <- hGetContents stdin" as the first line in my main function
20:45:45 <chessguy> @type hGetContents
20:45:47 <lambdabot> Not in scope: `hGetContents'
20:45:57 <chessguy> @hoogle hGetContents
20:45:57 <lambdabot> IO.hGetContents :: Handle -> IO String
20:46:07 <seafoodX> Hey, it's not a type problem.
20:46:12 <seafoodX> The file compiles
20:46:27 <jcreigh> @paste
20:46:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:46:34 <shareu00> I just started learning haskell and chose "Scheme Interpreter in 48 hours" as a launch point. So there's a first program which just prints line. So I tried to compile it and ghc compiles it. When I start it it says Prelude(!!) index is too large. What is that ? How do I fix it ?
20:46:35 <jcreigh> seafoodX: show us your code
20:47:47 * ddarius watches mildly bemused.
20:48:01 <chessguy> shareu00, a warning: that may not be the best launch point. it's quite difficult as a first haskell tutorial
20:48:29 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2998
20:48:50 <chessguy> @get-slap
20:48:50 <lambdabot> shapr!!
20:49:00 <crazy_coder> whats the std function which converts Char to int and vice versa ? eg '1' -> 1 ?
20:49:18 <chessguy> @hoogle Char -> Int
20:49:18 <lambdabot> Char.digitToInt :: Char -> Int
20:49:18 <lambdabot> Char.ord :: Char -> Int
20:49:21 <shapr> hiya chessguy
20:49:37 <chessguy> shareu00, that said, what code are you using, exactly?
20:49:40 <crazy_coder> @hoogle Int -> Char
20:49:41 <lambdabot> Char.chr :: Int -> Char
20:49:41 <lambdabot> Char.intToDigit :: Int -> Char
20:49:41 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
20:49:52 <crazy_coder> Thanks
20:50:05 <crazy_coder> @src intToDigit
20:50:05 <lambdabot> Source not found. Do you think like you type?
20:50:10 <shareu00> chessguy, module Main where
20:50:10 <shareu00> import System.Environment
20:50:10 <shareu00>  
20:50:10 <shareu00> main :: IO ()
20:50:14 <shareu00> main = do args <- getArgs
20:50:17 <shareu00>           putStrLn ("Hello, " ++ args !! 0)
20:50:20 <shareu00>  
20:50:39 <crazy_coder> main "User"
20:50:51 <shareu00> chessguy, even if it's too difficult I think it would be more fun to develop something as a learning expirience.
20:51:22 <chessguy> shareu00, oh it's definitely fun, if you can do it. but not much fun if you can't :)
20:51:24 <hpaste>  seafood annotated "(no title)" with "hGetContents" at http://hpaste.org/2998#a1
20:51:48 <crazy_coder> btw, digitToInt and intToDigit are both in which module ?
20:51:59 <ddarius> shareu00: args !! 0 === head args.  It's complaining essentially because you didn't pass any commandline arguments to the program.
20:52:15 <shareu00> chessguy: Yeah, definitely. Now I stuck with this Prelude index problem. Can't google anything worthful :(
20:52:57 <ddarius> > [1,3,4] !! 0
20:52:58 <ddarius> > [1,3,4] !! 1
20:52:59 <lambdabot>  1
20:52:59 <chessguy> shareu00, you need to compile the program and pass the argument from the command line. main doesn't take a parameter, so you can't run it that way
20:53:00 <lambdabot>  3
20:53:06 <ddarius> > head [1,3,4]
20:53:07 <lambdabot>  1
20:53:10 <ddarius> > head []
20:53:12 <lambdabot>  Exception: Prelude.head: empty list
20:53:16 <seafoodX> So, getContents works in a small program that I wrote.
20:53:16 <ddarius> > [1] !! 1
20:53:18 <lambdabot>  Exception: Prelude.(!!): index too large
20:53:18 <shareu00> ddarius: Just tried. Works!
20:53:32 <seafoodX> But it mysteriously starts to fail when It's part of my larger program.
20:53:33 <shareu00> ddarius: Thank you a lot
20:53:36 <crazy_coder> btw, where can I learn how to use IORef ?
20:53:49 <shareu00> chessguy: Thanks! it works.
20:54:05 <ddarius> crazy_coder: Google "Tackling the awkward squad"
20:54:16 <ddarius> seafoodX: Do you somehow have some other thing (h)GetContentsing?
20:54:25 <seafoodX> Nah.
20:54:46 <seafoodX> My program compiles and when I run it I get the error <stdin>: hGetContents: illegal operation (handle is closed)
20:54:46 <chessguy> crazy_coder, now that's an example were i would point to the "write yourself a scheme in 48 hours"
20:54:57 <seafoodX> The handle should not be closed
20:55:05 <seafoodX> And I'm certainly not closing it anywhere.
20:55:10 <ddarius> seafoodX: You are not doing any redirection or anything.
20:55:19 <ddarius> ?
20:55:39 <seafoodX> In what way?
20:55:50 <ddarius> myprog < afile
20:56:32 <seafoodX> I was.
20:56:36 <seafoodX> But I've tried both thing.
20:59:52 <seafoodX> This is a *weird* bug.
21:00:18 <ddarius> strace?
21:00:42 <edwardk> heya shapr
21:13:12 <seafoodX> ddarius: I'm on Mac OS X
21:13:26 <crazy_code1> I want to write a function which takes a list of 64 elements and gives back a list of 8 lists each of 8 elements
21:15:06 <crazy_code1> how to do it without pattern recognition (i mean we can have a func. divide x1 x2 .. x64 = [[x1..x8],[x9..x16]... ]
21:15:33 <crazy_code1> there must be a better way to do it
21:18:39 <crazy_code1> something inverse of concat
21:22:20 <shapr> hiya edwardk
21:22:25 <sclv> write a function that takes a list of lists and divides each in half, and run it a few times
21:24:39 <crazy_code1> sclv: Thanks
21:24:41 <sclv> if you don't care about efficiency that is: i.e. (\x-> concatMap (\y -> let sz = div 2 $ length y in [take sz y, drop sz y])
21:24:43 <crazy_code1> Nice Idea
21:25:36 <segher_> fn x = if length x <= 8 then [x] else (take 8 x) : (fn (drop 8 x))
21:26:47 <newsham> isnt that an unfold?
21:27:08 <sclv> @src unfold
21:27:08 <lambdabot> Source not found. Where did you learn to type?
21:27:28 <sclv> @hoogle unfold
21:27:28 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
21:27:28 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
21:27:28 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
21:27:37 <sclv> @src unfoldr
21:27:37 <lambdabot> unfoldr f b  = case f b of
21:27:37 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
21:27:37 <lambdabot>    Nothing        -> []
21:30:43 <Syzygy-> vincenz: Magma is a computer algebra system specializing in noncommutative cases -- a lot of group theory et.c.
21:31:06 <shapr> and it's HOT!
21:31:14 <sclv> let t8 = (\(x:xs) y-> if length s < 8 then [y:x]:xs else [y]:x:xs) in foldr t8 [[]]
21:33:12 <sclv> @pl \[x:xs] y-> if length s < 8 then [y:x]:xs else [y]:x:xs)
21:33:12 <lambdabot> (line 1, column 2):
21:33:12 <lambdabot> unexpected "["
21:33:12 <lambdabot> expecting pattern
21:33:48 <sclv> @pl \(x:xs) y-> if length s < 8 then [y:x]:xs else [y]:x:xs)
21:33:49 <lambdabot> (line 1, column 56):
21:33:49 <lambdabot> unexpected ")"
21:33:49 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++" or end of input
21:33:59 <sclv> @pl \(x:xs) y-> if length s < 8 then [y:x]:xs else [y]:x:xs
21:34:01 <lambdabot> ap (ap (ap . (liftM2 (if' (length s < 8)) .) . flip . ((:) .) . flip flip [] . ((:) .) . flip (:)) ((flip ((:) . return) .) . (:)) . head) tail
21:34:09 <sclv> or not
21:35:22 <newsham> > unfoldr (\xs -> if null xs then Nothing else Just (take 8 xs, drop 8 xs)) "testing 1 2 3. hello world"
21:35:23 <lambdabot>  ["testing ","1 2 3. h","ello wor","ld"]
21:36:15 <sclv> @t span
21:36:15 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
21:36:20 <sclv> :t span
21:36:22 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:36:38 <sclv> :t take
21:36:40 <lambdabot> forall a. Int -> [a] -> [a]
21:36:41 <newsham> ?hoogle Int -> [a] -> ([a], [a])
21:36:42 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
21:36:45 <newsham> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 8 xs)) "testing 1 2 3. hello world"
21:36:46 <lambdabot>  ["testing ","1 2 3. h","ello wor","ld"]
21:37:17 <sclv> @pl \xs -> if null xs then Nothing else Just (splitAt 8 xs)
21:37:17 <lambdabot> ap (flip if' Nothing . null) (Just . splitAt 8)
21:37:34 <edwardk> @seen Cale
21:37:34 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 57m 10s ago.
21:37:40 <newsham> there should be a func     f g p x = if p x then Nothing else g x
21:37:52 <newsham> err  else Just (g x)
21:38:31 <edwardk> newsham: looking for a filter in the Maybe monad?
21:38:59 <sclv> ?hoogle (a->Bool) -> (a->b) -> Maybe b
21:39:00 <lambdabot> No matches, try a more general search
21:39:00 <edwardk> @type unless
21:39:00 <newsham> want func:   func splitAt (not.null) xs
21:39:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:39:24 <newsham> which would do    if (not.null) xs Just (splitAt xs) else Nothing
21:39:30 <newsham> (except I wanted (splitAt 8)  oops)
21:39:46 <Apocalisp> @type join
21:39:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:39:51 <Apocalisp> @type (.)
21:39:53 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:39:56 <Apocalisp> @type join (.)
21:39:58 <lambdabot> forall b. (b -> b) -> b -> b
21:40:06 <Apocalisp> I don't get it.
21:40:06 <newsham> lambdabot takes msgs
21:40:36 <edwardk> > join (.) (*2) 1
21:40:38 <lambdabot>  4
21:40:49 <edwardk> 'apply the function twice'
21:41:31 <edwardk> join in that context is in the 'implicit reader monad' (->)e
21:41:37 <newsham> ?src join
21:41:37 <lambdabot> join x =  x >>= id
21:42:05 <omniscientIdiot> @src (->) (>>=)
21:42:05 <lambdabot> f >>= k = \ r -> k (f r) r
21:42:21 <FMota> offtopic: _etc_ is better syntax than `etc`. But that's just me.
21:42:29 <omniscientIdiot> x >>= id = \ r -> id (x r) r = \ r -> x r r
21:43:23 <Apocalisp> offtopic: "That" takes a nominative.
21:43:53 <FMota> And `that` takes a character.
21:43:54 <Apocalisp> as in "that is"
21:44:11 <FMota> Which you shouldn't even be using.
21:44:42 * FMota is viciously offtopic. Yes, vicious. 3 lines vicious.
21:45:04 <edwardk> so you're basically saying that you'd prefer _ to be the infix quoting character?
21:46:04 <FMota> Yes.
21:46:19 <edwardk> main issue there is then you can't terminate or start an identifier with _ which mucks up c FFI.
21:46:20 <FMota> Which is, of course, how I'm going to do it in sei.
21:46:38 <FMota> well
21:46:42 <FMota> you can start one or end one
21:46:48 <FMota> but you can't have them both
21:47:03 <edwardk> right now i'm using _ as a qualified reference operator, so i understand wanting to steal it back ;)
21:47:07 <FMota> a, _a, a_ are all identifiers
21:47:16 <FMota> _a_ is an infixed a
21:47:39 <edwardk> i.e. if i have a namespace Foo and I want to access + in foo Foo.+ is not pretty infix but +_Foo looks fine and reads fine to someone with a latex background.
21:47:43 <segher_> so what is __ ?
21:47:51 <FMota> __ is also an identifier
21:47:54 <FMota> as is _
21:48:11 <Apocalisp> So, how does currying join with (.) work?  Where does (b -> c) -> (a -> b) -> a -> c fit into join's type?
21:48:18 <segher_> pretty darn irregular if you ask me
21:48:24 <FMota> although, _ is the wildcard, really
21:48:30 <edwardk> Apocalisp: there is a monad for (e->)
21:48:34 <FMota> and __ is kinda pointless
21:48:38 <FMota> hmm..
21:48:43 <FMota> or not, __ could have a use
21:49:08 <Apocalisp> so, join here is :: e -> (e -> a) -> e -> a
21:49:53 <edwardk> (e -> (e ->a)) -> e -> a
21:49:58 <FMota> __ could replace $. It makes sense if you think of __ as being _id_
21:50:34 <edwardk> i've been using ! as a replacement for $, looks more like . and the little convert $ to . rules come across fairly naturally in that context.
21:50:51 <omniscientIdiot> @type join (.)
21:50:56 <lambdabot> forall b. (b -> b) -> b -> b
21:50:58 <FMota> that works
21:51:13 <omniscientIdiot> join :: Monad m => m (m a), (.) :: (b->c) -> (a->b) -> (a->c)
21:51:19 <edwardk> can even flip its fixity to make Cale happy ;)
21:51:35 <omniscientIdiot> m is unified with both ((b->c) ->) and ((a->b) ->)
21:51:44 <FMota> hmm
21:51:46 <FMota> I like (!)
21:51:57 <FMota> ! x = flip id x
21:52:16 <edwardk> yeah, in my case combining it with allowing lists and arrays to be used directly as functions recovers its haskell meaning even ;)
21:52:38 <FMota> oh
21:52:41 <edwardk> f ! x = f x     even
21:52:46 <FMota> what's the meaning of ! in haskell?
21:52:51 <FMota> indexing?
21:52:53 <FMota> :o
21:52:53 <omniscientIdiot> (!) is usually index
21:52:57 <edwardk> > [1,2,3] ! 1
21:52:58 <lambdabot>  Couldn't match expected type `Array i e'
21:53:00 <edwardk> er
21:53:03 <omniscientIdiot> @index (!)
21:53:03 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
21:53:12 <edwardk> @type (!)
21:53:14 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
21:53:22 <omniscientIdiot> > M.map [(1,'a'), (2,'b')] ! 2
21:53:23 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
21:53:30 <edwardk> that one is !! i was thinking of first, ! is the equivalent in arrays
21:53:46 <FMota> :o
21:54:11 <edwardk> > listArray (1,5) [1..5] ! 2
21:54:12 <lambdabot>  2
21:54:40 <omniscientIdiot> > M.fromList [(1,'a'), (2,'b')] ! 2
21:54:41 <lambdabot>  Couldn't match expected type `Array i e'
21:55:08 <omniscientIdiot> > M.fromList [(1,'a'), (2,'b')] M.! 2 -- darned names!
21:55:09 <lambdabot>  'b'
21:55:17 <edwardk> omniscientIdiot: i think the ! has to be qualified... ah you got it
21:56:03 <FMota> :o
21:56:04 <edwardk> that use case there is why i'd like to steal back _ for infix operator namespace qualification. !_M
21:56:22 <edwardk> is more obviously infix
21:57:26 <FMota> hm
21:57:56 <Cale> So put the module path after the identifier with the components separated by underscores?
21:58:12 <FMota> I still think that       (\ x -> x * x) _map_ [1, 2, 3, 4, 5]    is a lot more elegant than     (\ x -> x * x) `map` [1,2,3,4,5]
21:58:44 <Cale> I kind of wish they hadn't chosen . as a module path separator.
21:58:57 <Cale> | makes a much better one
21:58:58 <edwardk> well, in the infix case saying that +_Foo.Bar = `Foo.Bar.+` and that you can then determine fixity by first character of the fully qualified identifier not having to pick off its qualifiers.
21:59:00 <dolio> _ isn't really any better than ` for infix, other than that it's a bit easier to type, because you still can't nest, and therefore still can't really support putting more complicated expressions in them.
21:59:05 <Cale> I suppose _ wouldn't be so bad either
21:59:07 <FMota> although, obv, if I had it my way (which I will), it'd be       (\ x : x * x) _map_ [1, 2, 3, 4, 5]
21:59:19 <Cale> edwardk: ah, okay
21:59:20 <wnoise> Cale: | bar is ugly, as is _.  : seems nice, but that's already spoken for.
21:59:38 <Cale> Control|Monad|sequence looks fine to me
21:59:50 <omniscientIdiot> \x. body
22:00:10 <omniscientIdiot> @ could work for qualification
22:00:10 <FMota> \x : body
22:00:17 <edwardk> dolio: there is a cheesy little hack to make infix complex expressions _: :_ style from cc shan.
22:00:29 <dolio> I know, I've seen it.
22:00:32 <wnoise> You have the aesthetic sense of chimpanzee on methamphetamines.
22:00:36 <edwardk> which would actually syntactically dovetail nicely with _ _'d infix operators
22:00:39 <FMota> also...   _( )_ works :o
22:00:40 <wnoise> (On this issue.)
22:00:48 <Apocalisp> hmm, I still don't quite get join (.)
22:00:48 <Cale> wnoise: what's wrong with it?
22:00:58 <dolio> edwardk: But then why have _ _ at all?
22:01:02 <edwardk> Cale: the | looks pretty noisy to me
22:01:17 <Cale> It's not as noisy as most characters
22:01:25 <wnoise> I want something that's easily distinguishable from identifiers.
22:01:27 <Apocalisp> I must be missing some preliminary understanding.
22:01:29 <edwardk> dolio: no idea, i was dropping it entirely in favor of the latter ;)
22:01:30 <Cale> It's about equally as noisy as /
22:01:39 <omniscientIdiot> Apocalisp: join :: Monad m => m (m a) -> m a, (.) :: (b->c) -> (a->b) -> (a->c)
22:01:44 <Cale> which we use for filesystem path separators :)
22:01:51 <FMota> wnoise: the large horizontal whitespaces around _map_ not big enough for you? ;)
22:02:03 <omniscientIdiot> Apocalisp: m is unified with both ((b->c) ->) and ((a->b) ->)
22:02:12 <Cale> wnoise: | can't be an identifier
22:02:14 <wnoise> That, I go meh.  But _ has a long tradition of being part of names.
22:02:40 <FMota> Right.
22:02:41 <Cale> Not really in Haskell
22:02:46 <wnoise> Cale: I know it can't, but the full vertical support makes it look like a capital, especially infixed.
22:02:48 <omniscientIdiot> Apocalisp: and since b is used in both places, a, b, and c are unified
22:02:52 <Cale> We always use camelCase
22:03:06 <dolio> It's part of identifiers in Haskell, too. It just isn't used often.
22:03:07 <wnoise> And it should mean or/alteration.
22:03:07 <FMota> But it still looks better than `
22:03:10 <dolio> Except on its own.
22:03:11 <edwardk> Apocalisp: there is a monad (->)e  which is basically what would be the (e->) section if that was legal at the type level. that is the monad over which join is operating
22:03:13 <omniscientIdiot> Apocalisp: so you get join (.) :: (b -> b) -> (b -> b)
22:03:20 <FMota> and _ always goes in the middle, so it's easy to differentiate.
22:03:41 <Cale> wnoise: It still would, in data declarations, but there would be enforced whitespace there
22:04:21 <Cale> wnoise: Also, it shows up in list comprehensions and guards, but those occurrences can also be made unambiguous by requiring whitespace on at least one side.
22:04:35 <Cale> (which is already there in almost all cases)
22:04:54 <omniscientIdiot> Apocalisp: do you understand how the value itself works, or are you just asking about type unification?
22:05:59 <wnoise> Being unambiguous to a computer is not the same as being unconfusing to a human.
22:06:25 <wnoise> Anyway, . works well for DNS, usenet, and most OO language usage.
22:06:27 <dons> ?users
22:06:27 <lambdabot> Maximum users seen in #haskell: 420, currently: 343 (81.7%), active: 14 (4.1%)
22:07:05 <wnoise> really, we should be using the Unicode "ring" operator for composition.
22:07:07 <omniscientIdiot> let the type m = (->) (b->b), join ((.) :: m (m (b->b))) :: m (b -> b)
22:07:14 <FMota> I think | is kinda noisy/ugly.
22:07:19 <FMota> But that's just me.
22:07:38 * FMota agrees with that.
22:08:15 <FMota> the problem with unicode is obvious, though.
22:08:17 <edwardk> cale: yeah i also find | too noisy, but then i want to steal it for the more math-like predicate subtype stuff anyways. f :: (x :: T | pre x) -> (y :: S | post x y)
22:08:32 <Korollary> dons, was 420 (max users) just a coincidence?
22:08:37 <Apocalisp> omniscientIdiot: I'm just talking about the type unification at this point.
22:08:54 <newsham> you think he rigged it to be more stoney?
22:08:54 <FMota> lol Korollary
22:08:57 <omniscientIdiot> Apocalisp: did you see my last comment?
22:09:15 <edwardk> (which would look better with { }'s stolen back, but can be parsed with just parentheses
22:09:42 <omniscientIdiot> m = ((b -> b) ->), a = (b -> b), join ((.) :: m (m a)) :: m a
22:09:45 <dons> Korollary: hmm?
22:10:15 <wnoise> The problem with unicode was obvious.  It's looking less and less obvious as time goes on.
22:10:41 <Apocalisp> omniscientIdiot: I saw it, but I don't comprehend it.
22:11:08 <omniscientIdiot> Apocalisp: well, join has type m (m a) -> m a, right?
22:11:14 <Apocalisp> right
22:11:39 <omniscientIdiot> that has to unify with (.)'s type
22:11:41 <Korollary> dons, it's a west coast thing: http://www.answers.com/topic/420-cannabis-culture
22:11:42 <lambdabot> Title: 420: Information and Much More from Answers.com
22:11:47 <wnoise> dons: 420 is slang for marijuana.  Korollary was asking whether getting it for the max users was somehow deliberate.
22:11:53 <omniscientIdiot> Apocalisp: we'll rewrite (.) using prefix
22:11:54 <edwardk> Apocalisp: start with the two patterns, (b -> c) -> (a -> b) -> a -> c and    (e -> (e -> d)) -> e -> d
22:11:58 <dons> oh, there you go.
22:12:16 <edwardk> you get three constraints from lining things up, e = b -> c, e = a -> b, d = a -> c
22:12:31 <edwardk> lining up e = b -> c, e = a -> b you get a = b and b = c, so a = b = c
22:12:41 <FMota> HAI GUISE. What do you think about this?    a / b : suc . / b ! a + b
22:12:44 <FMota> :o
22:12:47 <edwardk> so e = b -> b
22:12:57 <edwardk> d = b -> b
22:13:23 <edwardk> so join (.) :: e -> d = join (.) :: (b -> b) -> (b -> b)
22:13:55 <FMota> let's see.. in Haskell-ish, that'd be something akin to....
22:14:22 <FMota> a / b = suc . / b $ a + b
22:14:52 <omniscientIdiot> (e -> (e -> d)) -> (e -> d) is the type of join.  Here, the partial function type (e ->) is the monad, so it's the same as m (m d) -> m d, with m = (e ->)
22:15:02 <FMota> which makes a lot more sense as
22:15:12 <FMota> a / b - suc ((a + b) / b)
22:15:44 <edwardk> e -> (e -> d) is just (b -> c) -> ((a -> b) -> (a -> c)) is where i got those three constraints e = b -> c , e = a -> b and d = a -> c
22:17:02 <olsner> is there something I can say here about monads without any of my intelligence present?
22:18:35 <Apocalisp> edwardk: Ok, I follow that. Thanks a bunch!
22:18:41 <edwardk> Apocalisp: np
22:22:15 <olsner> > cycle []
22:22:16 <lambdabot>  Exception: Prelude.cycle: empty list
22:22:42 <olsner> > fix ([]++
22:22:42 <lambdabot>  Unbalanced parenthesis
22:22:48 <olsner> > fix ([]++)
22:22:49 <lambdabot>  Exception: <<loop>>
22:23:10 <olsner> haskell obviously sucks for my needs ^^
22:23:12 <edwardk> Cale: the explicit : Foo version of the monads is turning pretty verbose =/
22:23:30 <Cale> edwardk: perhaps you can clean it up using do-notation?
22:23:58 <edwardk> cale: the concern is that you wind up with a lot of pseudo-type stuff floating around. =/ its not even the >>= stuff that gets in the way
22:24:10 <Cale> edwardk: after all, a do-block should all be in the same monad, so you could have that pass the instances along
22:24:49 <edwardk> well, do desugars just fine in the non-algebraic version (or even in the algebraic version)
22:26:13 <edwardk> runOk (Ok x) = x;      Ok x : Id = Ok x;       x >>= f : Id = f (runOk (x : Id)) : Id
22:26:42 <edwardk> and the noise gets 'louder' when you have anything more complicated.
22:27:10 <edwardk> as opposed to Ok x >>= f  = f x    and a handy monad law to ensure that always works
22:27:30 <Cale> I was thinking return and (>>=) should perhaps at some level take the "typeclass dictionary" as parameters
22:27:46 <Cale> and have do-notation handle the passing of that dictionary
22:27:56 <edwardk> the problem with that is you have to plumb the dictionary through everything, thats why i switched away from it
22:28:19 <edwardk> i tried it as an implicit 'reader' as well, and it clutters up the definitions with the same amount of plumbing
22:28:45 <Cale> This is why dynamic typing kinda sucks... :)
22:28:47 <edwardk> i also tried using it through dynamic binding to change a pseudo-global.
22:29:18 <edwardk> well, the thing is the other version works quite well, except for the commutativity issues for monad transformers.
22:29:31 <edwardk> and i've been thinking about that a bit
22:30:43 <edwardk> what if we embraced the tags? so that you tag the data that you stick in a reader or writer or state monad and get/set by 'tag', then they can commute over each other (ala monadic coproducts) and a runState runReader or runWriter peels off a layer of the monad
22:31:21 <edwardk> it doesn't solve the ones that don't commute (ErrorT, etc.) but it handles the major workhorses
22:31:52 <edwardk> hrmm, maybe i should try to give a more concrete example/explanation
22:32:17 <hpaste>  (anonymous) pasted "join (.) unification" at http://hpaste.org/2999
22:32:39 <edwardk> lift can then take a 'tag' of the level to lift to for that matter.
22:34:51 <Cale> http://www.marriedtothesea.com/093007/old-lady-efficiency.gif
22:35:12 <edwardk> say i have a ReaderT m SomeTag a and i get an action of type Reader SomeTag a, i can promote it by reading the environment and returning it into the monad m. (which requires no dictionary using return = Ok) if its Reader SomeOtherTag a then i lift it
22:37:33 <edwardk> m doesn't actually ever get explicitly mentioned in the term, so you just have ReaderT Tag a as the constructed term or Reader Tag a as a constructed term, indicating whether the content is monadic or not and what lift tag is associated with it.
22:37:45 <narain> hi haskellers
22:37:53 <edwardk> get/set/put/ask can then be merged
22:37:55 <narain> i want to do an unfold but i also want the final value of the seed
22:37:56 <edwardk> er
22:38:03 <edwardk> set/put and get/ask  that is
22:38:12 <narain> do i have to write my own version of unfold?
22:38:34 <omniscientIdiot> narain: is the seed the same type as the resulting list elements?
22:38:42 <narain> no
22:39:08 <scook0> @hoogle unfoldr
22:39:08 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
22:39:09 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
22:39:15 <omniscientIdiot> narain: you could unfold into a [Either resultElements seedType]
22:39:33 <omniscientIdiot> and have a bunch of Lefts followed by the final Right seed
22:39:38 <scook0> so you want (a -> Maybe (b, a)) -> a -> ([b], a)?
22:39:46 <narain> scook0, yes
22:40:02 <narain> omniscientIdiot, i'd guess the unfold wouldn't stop then
22:40:15 <scook0> probably easier just to roll your own
22:40:19 <narain> because it wouldnt get a Nothing
22:40:27 <scook0> you can always refactor it later once you know what it looks like longhand
22:40:50 <narain> yes, i could do that
22:42:16 <omniscientIdiot> narain: so it'd be [Left x, Left y, Left z, Right finalSeed, Right finalSeed, Right finalSeed...
22:42:29 <omniscientIdiot> you could do something with that
22:42:59 <omniscientIdiot> write an f :: [Either a b] -> ([a], b)
22:43:27 <narain> ah yes, that seems workable
22:43:38 <pstickne> Does anyone have a reference to an indepth tutorial/documentation on creating new data types?
22:43:41 <omniscientIdiot> maybe not the prettiest...
22:44:10 <edwardk> runReader over a tower of monads would then try to peel out the action with the same tag and if it didn't find it would pretend it stripped it out, so runReader anyTag (Ok x) = const x    works.  runReader tag (Reader tag' f) | tag == tag' = f     works like the untagged case, and  | otherwise = Reader tag' . runReader tag f   by the commutativity law
22:44:15 <narain> omniscientIdiot, yes but it would probably work cleanly with just a couple of wrapper functions
22:44:30 <narain> thanks, that's an idea
22:44:42 <omniscientIdiot> you're welcome!
22:45:18 <edwardk> er there is a probably typo in that but the idea is what i meant to convey
22:45:32 <omniscientIdiot> leftsThenRight seems a good name :D
22:48:50 <narain> omniscientIdiot, i think i'll just make an unfold' that wraps unfold with the magic stuff :)
22:48:55 <hpaste>  scook0 pasted "unfold, retaining the final seed" at http://hpaste.org/3000
22:49:20 <scook0> woo, 3000! :)
22:49:35 <omniscientIdiot> or just have scook0 write it for you :D
22:50:14 <scook0> hey, it was fun
22:50:18 <narain> aw scook0, you shouldn't have :)
22:50:20 <narain> thanks!
22:50:28 <scook0> and I got an excuse to abuse an arrow combinator :)
22:50:45 <omniscientIdiot> first++
22:50:49 <narain> i think that's hardly "abuse" though
22:51:00 <narain> perfectly appropriate use
22:51:00 <scook0> well, not really, more like "use"
22:51:12 <scook0> I'm still not used to first/second though
22:51:15 <narain> scook0++
22:51:19 <omniscientIdiot> hey, the (->) Arrow is tremendously handy
22:51:19 <scook0> I still prefer (f *** id)
22:51:44 <narain> ?karma first
22:51:44 <lambdabot> first has a karma of 1
22:51:52 <scook0> I wish you could use the arrow combinators on Kleisli arrows without newtypes, though
22:52:32 <scook0> I guess I could reimplement them in a separate module ...
22:52:57 <omniscientIdiot> what would the instance header look like?
22:53:21 <omniscientIdiot> (->) a (m b) doesn't seem "fittable"
22:53:30 <scook0> omniscientIdiot: yeah, that's the problem
22:53:39 <scook0> especially since it would overlap with (->)
22:54:06 <scook0> but that's only a problem if you want to use the existing polymorphic combinators
22:54:22 <scook0> you could always define your own (***) etc. with the appropriate type
22:54:50 <omniscientIdiot> class ArrowButWithKleislisInMind a where ...
22:55:48 <scook0> I have been known to write let f .&&&. g = runKleisli $ Kleisli f &&& Kleisli g
22:55:58 <omniscientIdiot> oooh
22:56:42 <scook0> I suppose let k = Kleisli; rk = runKleisli might help a bit
22:57:07 <omniscientIdiot> f .&&&. g = rk (k f &&& k g)
22:57:49 <scook0> who is/was Kleisli, anyway? I've never seen that explained...
22:58:08 <scook0> (I'm assuming it's somebody's name)
22:58:24 <omniscientIdiot> @google Kleisli catgory
22:58:27 <lambdabot> http://www.mta.ca/~cat-dist/
22:58:27 <lambdabot> Title: Categories Home Page
22:58:36 <omniscientIdiot> oops typo
22:58:42 <omniscientIdiot> @google Kleisli category
22:58:44 <lambdabot> http://en.wikipedia.org/wiki/Monad_(category_theory)
22:58:45 <lambdabot> Title: Monad (category theory) - Wikipedia, the free encyclopedia
23:02:28 <stepcut> > toEnum (fromEnum (2 :: Pico)) :: Pico
23:02:29 <lambdabot>  -0.001454759936
23:02:30 <omniscientIdiot> > runKleisli (Kleisli (replicate 3) &&& Kleisli (\x -> [x,x+1,x+2])) 8
23:02:31 <lambdabot>  [(8,8),(8,9),(8,10),(8,8),(8,9),(8,10),(8,8),(8,9),(8,10)]
23:02:36 <stepcut> :(
23:02:49 <omniscientIdiot> @index Pico
23:02:49 <lambdabot> bzzt
23:02:53 <stepcut> should toEnum . fromEnum == id ?
23:03:05 <stepcut> omniscientIdiot: type Pico = Fixed E12, from Data.Fixed
23:03:16 <newsham> depends on the types
23:03:27 <newsham> > (toEnum.FromEnum) 'c' :: Char
23:03:28 <lambdabot>   Not in scope: data constructor `FromEnum'
23:03:32 <newsham> > (toEnum.fromEnum) 'c' :: Char
23:03:34 <lambdabot>  'c'
23:03:37 <newsham> > (toEnum.fromEnum) 'c' :: Int
23:03:38 <lambdabot>  99
23:03:52 <newsham> ?type toEnum
23:03:54 <lambdabot> forall a. (Enum a) => Int -> a
23:04:16 <omniscientIdiot> > fromEnum (2 :: Pico) -- does it fit in Int?
23:04:17 <lambdabot>  -1454759936
23:04:34 <newsham> whats a pico?
23:04:56 <omniscientIdiot> <!stepcut> omniscientIdiot: type Pico = Fixed E12, from Data.Fixed
23:04:57 <stepcut> 10^(-12)
23:05:26 <doserj> the Enum instances for Fixed are broken IMO
23:05:27 <stepcut> i think... milli, nano, micro, pico..
23:05:58 <stepcut> doserj: yes, I am thinking so too...
23:06:09 <omniscientIdiot> nano/micro might be flipped
23:06:15 <omniscientIdiot> @go 1 second in nanoseconds
23:06:16 <lambdabot> 1 second = 1,000,000,000 nanoseconds
23:06:21 <omniscientIdiot> @go 1 second in microseconds
23:06:21 <stepcut> omniscientIdiot: oops :)
23:06:21 <lambdabot> 1 second = 1,000,000 microseconds
23:06:28 <Korollary> lol
23:06:51 <omniscientIdiot> well, why not:
23:06:53 <Korollary> @go 1 picoseconds in seconds
23:06:54 <lambdabot> 1 picoseconds = 1.0 x 10^-12 seconds
23:07:05 <omniscientIdiot> I was gonna do that!
23:07:46 <Korollary> hmm
23:07:47 <dolio> @go 1 picosecond in attoseconds
23:07:48 <lambdabot> 1 picosecond = 1,000,000 attoseconds
23:07:54 <Korollary> @go 1 picosecond in nanometers
23:07:58 <lambdabot> http://www.lightner.net/lightner/bruce/enews_970901.html
23:07:58 <lambdabot> Title: Gigascale integration hitting the wall?
23:08:09 <omniscientIdiot> HOMIE DON'T PLAY THAT
23:09:00 <dolio> Whatever, you can interconvert by multiplying/dviding by various constants of nature. :)
23:09:48 <doserj> > [1..10]::[Pico] -- this is broken
23:09:49 <lambdabot>  [1.000000000000,1.000000000001,1.000000000002,1.000000000003,1.000000000004,...
23:09:54 <omniscientIdiot> @go 1 pound of feces in joules
23:09:56 <lambdabot> http://forum.physorg.com/index.php?act=Print&client=printer&f=22&t=18080
23:09:57 <lambdabot> Title: PhysOrgForum Science, Physics and Technology Discussion Forums [Powered by Invis ...
23:10:24 <sjanssen> @src Pico
23:10:25 <lambdabot> Source not found. You speak an infinite deal of nothing
23:10:48 <omniscientIdiot> @src Fixed enumFromTo
23:10:48 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:11:00 <swix> omniscientIdiot, get me a caloriometer you don't want any more, and I'll telll you how many joules in a lb of feces
23:11:33 <dolio> He didn't say what kind of feces, though.
23:11:38 <swix> actually, I've bet people have done research on digestive efficiency... so just look up the paper
23:12:27 <omniscientIdiot> doesn't matter what it's a pound of, E = mc^2, right?
23:13:35 <swix> lol
23:13:41 <swix> I've got the numbers on bat crap
23:13:47 <edwardk> omniscientIdiot: heh
23:14:00 <Korollary> swix, that's crazy
23:14:02 * omniscientIdiot powers a few major cities with his poop
23:14:08 <stepcut> lambdabot needs a frink plugin
23:14:14 <swix> I'm a bio major, this has yet to surprise me
23:14:33 <edwardk> omniscientIdiot: yeah, you just need to work out some sort of catalyst for that reaction and you'll be all set.
23:14:40 <Korollary> first bio major ever to grace #haskell?
23:14:45 <dolio> omniscientIdiot: To actually get that kind of conversion, you're going to need plenty of anti-feces, though.
23:15:25 <Korollary> You are hereby obligated to write the first protein monad.
23:15:26 <edwardk> i know plenty of people who are anti-feces. you could try to throw it at them and see if they explode.
23:15:52 <edwardk> i'll be hiding somewhere safe during the reaction however.
23:16:08 <omniscientIdiot> I... I can't breathe... laughing... too hard
23:17:02 <Korollary> There's already protein folding. Now you need protein fmapping.
23:17:12 <swix> 7 989 866.3 joules / pound in the mixed bat crap
23:17:27 <scook0> hooray for science
23:17:39 <Korollary> @go 8e6 jouls in kilowatt hours
23:17:42 <lambdabot> http://www.everything2.com/index.pl?node=October%2010%2C%202004
23:17:42 <lambdabot> Title: October 10, 2004@Everything2.com
23:17:46 * omniscientIdiot chokes on his bubblegum
23:17:47 <Korollary> @go 8e6 joules in kilowatt hours
23:17:48 <lambdabot> 8e6 joules = 2.22222222 kilowatt hours
23:17:59 <Korollary> not bad
23:18:07 <swix> enough to run a 100W light bulb for 22.2 hours
23:18:42 <swix> bats are horribly inefficient because they have rapid digestion because they can only hold 1-2g in their digestive tracts
23:18:51 <Korollary> ah
23:18:55 <swix> 20-30% efficient even
23:19:14 <jaredj> they aren't the fastest though
23:19:15 <Korollary> real fast food eh
23:20:06 <jaredj> some bird can do it in like 20 minutes?
23:20:47 <swix> bats are really fast, I think
23:20:56 <swix> I could read this paper more, but I'm lazy
23:21:06 <sorear> throw bat guano into a rapidly spinning black hole
23:21:17 <Randroid> I think I understand FunDeps. Simpler than I thought. (Unless I'm horribly mistaken ...)
23:21:25 <sorear> rig up an extractor with the Blandford-Zjanek process
23:21:35 <swix> my undergraduate degree has so far given me the most obtuse ways of measuring useless information.... like how to measure the relative volume increase of an errect penis using only a glass of water :P
23:21:44 <swix> we discussed that last night over drinks and a penis contest
23:21:49 * omniscientIdiot wins the "Best offtopic start evar" award
23:22:00 <jaredj> whow
23:22:08 <jaredj> @penis
23:22:08 <lambdabot> Unknown command, try @list
23:22:35 <Randroid> lol
23:23:45 <omniscientIdiot> Randroid: I think I understand them, too :)
23:24:08 <Korollary> Now you two can measure your understanding using a glass of water.
23:24:18 <Randroid> Or perhaps a penis contenst
23:24:20 <Randroid> *contest
23:24:21 <swix> lol, in my AI class we have to write a connect 4 playing bot
23:24:38 <jaredj> agh! late
23:28:38 <dolio> Heh, in my AI class, our teacher told us about a contest he entered once to write a bot to play some game or other...
23:29:18 <swix> dolio, and...?
23:29:34 <dolio> So, his strategy was to enter several bots, have one master, and have all the rest automatically lose to the master (using some code communicated via certain opening moves).
23:29:40 <swix> ours is in class tourney... but C4 is solved, so this could be bunch
23:29:42 <swix> bunk*
23:29:47 <dolio> And the only reason he didn't win, was that someone else did it too, and entered more bots than he did.
23:29:52 <dolio> He seemed pretty unhappy about it.
23:30:04 <Korollary> being outweaseled surely sucks
23:30:14 <jaredj> heh
23:32:14 <Korollary> L Hamilton wins F1 Japanese Grand Prix
23:32:23 <dolio> Linda?
23:32:41 <Korollary> heh
23:32:54 <Korollary> no terminator lady
23:33:13 <swix> does haskell have any nice ways to do matrix/vector math?
23:37:55 <wnoise>  Hmm.  One of the clone-proof election methods should largely defend against that attack.
23:38:10 <jaredj> huh
23:42:58 <xpika> what do people here use for graphing? R? GNUPLOT?
23:43:14 <jaredj> i've used R
23:43:23 <jaredj> gnuplot is cool, but not really GNU
23:43:44 <jaredj> matplotlib (for python) is quite cool
23:44:25 <jaredj> R was great because it did stats too
23:44:44 <jaredj> and it was easy to pick things out of lists with it
23:45:23 <xpika> I mainly just want the one which looks nicest :)
23:45:53 <jaredj> both R and matplotlib can put out vector graphics (eps/svg/etc)
23:46:13 <jaredj> matplotlib has a fun little window where you can zoom, move about, save and print
23:46:34 <jaredj> R and gnuplot show the graph in a window, or you switch the "display device" to a file
23:47:06 <jaredj> display of mathematical symbols is existent in all three, but slightly hackish
23:47:45 <jaredj> i've used R plots in my papers, and I have colleagues who've used matplotlib plots in papers
23:47:52 <hpaste>  duryodhan pasted "control stack overflow" at http://hpaste.org/3001
23:48:08 <duryodhan222> hey
23:48:17 <duryodhan222> umm dumb question I think ...
23:48:33 <duryodhan222> but why is maxSalesWeek 1 giving me control Stack overflow
23:49:01 <duryodhan222> Main> maxSalesWeek 0
23:49:01 <duryodhan222> 0
23:49:01 <duryodhan222> Main> maxiBySales 0 1
23:49:01 <duryodhan222> 1
23:49:19 <duryodhan222> I am sorry if above was too long ...
23:49:31 <duryodhan222> what I am trying to get at ...
23:49:44 <duryodhan222> it is working if I call the functions on my own ...but it doesn't through another function
23:49:52 <duryodhan222> is there something like a debugger :)
23:52:09 <scodil> is there any way to specify in the constraints of an instance declaration that two type variables are not the same?
23:52:15 <scodil> or that they are
23:52:33 <jaredj> scodil: give them different letters (or the same)
23:52:49 <jaredj> that probably missed something big
23:52:56 <jaredj> it sounded too easy
23:53:00 <scodil> same letter means same type, but i think different letters can be the same type
23:53:16 <scodil> so i guess i need to specify that they are different types
23:53:32 <jaredj> like (Num a, Num b) => ... perhaps?
23:53:43 <scook0> duryodhan222: hmm, I can't really see why it would fail for a=1...
23:53:50 <omniscientIdiot> maxSalesWeek = maximumBy (comparing sales), totalSales x = sum (map sales [0..x])
23:53:53 <scodil> yeah right but a = Int, b = Int satisfies that
23:54:06 <jaredj> ahh
23:54:24 <jaredj> so you don't mean independent you mean *different*
23:54:32 <scodil> right
23:54:46 <jaredj> i have nothing smart to say
23:55:41 <scodil> the thing i'm trying to do is fish through a list of types, built with something like `data C a b` looking for a specific type in that list.
23:56:28 <Cale> scodil: have you looked at HList?
23:56:36 <scodil> yeah that's too intense for me
23:57:07 <scodil> i mean, i've looked at it, and i'm aware it deals with things like that, but i don't know how it does it
23:57:35 <doserj> duryodhan222, maxSalesWeek a-1 is parsed as (maxSalesWeek a) -1, which may not be what you want...
23:57:44 <Cale> It does it by using instances with functional dependencies to permit a kind of functional/logic programming at the type level.
23:58:33 <scodil> yeah i've done a bit of that
