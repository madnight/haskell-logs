00:07:44 <glguy> the donkey kong arcade game is madening
00:08:22 <earthy> it's designed to be
00:08:27 <earthy> so you keep spending quarters. ;)
00:11:52 <glguy> you can tell it was  before they really figured out how to take your money though
00:11:56 <glguy> you can't buy more lives
00:12:00 <glguy> you have to start over
00:27:39 <icarroll> So here's a question that I can't find the answer to:
00:27:59 <icarroll> How did the word "String" come to be used in programming languages?
00:28:52 <icarroll> It apparently comes from linguistics, possibly through the SNOBOL or COMIT languages.
00:28:58 <Pseudonym> It was a mathematical term.
00:29:03 <icarroll> Cool
00:29:08 <icarroll> What branch of mathematics?
00:29:11 <Pseudonym> A sequence of symbols drawn from a set.
00:29:34 <Pseudonym> Well, most recently, there's a whole branch which deals with it.
00:29:36 <Pseudonym> Formal language theory
00:29:40 <icarroll> Right
00:29:51 <Pseudonym> But before that, the concept was used in combinatorics.
00:30:05 <scodil> why not just 'sequence'?
00:30:15 <Pseudonym> "Sequence" means soemthing else.
00:30:22 <Pseudonym> Like the Fibonacci sequence.
00:30:34 <scodil> is that not an infinite string of ints, tho?
00:31:10 <Pseudonym> The usual definition of "string" (or "word") is that the alphabet is finite.
00:31:28 <Pseudonym> So that wouldn't apply in the case of integer sequences.
00:31:31 <Pseudonym> Or real sequences.
00:31:33 <Pseudonym> Or whatever.
00:31:34 <icarroll> So which programming language first had a data type we'd recognize as a string, and which language (if different) first used the term "string" either in documentation or code?
00:31:36 <vincenz> sequence is an contiguously indexed collection
00:31:41 <vincenz> s/an/a
00:32:31 <Pseudonym> Ah, well.
00:32:36 <Pseudonym> That depends what you'd call a "string".
00:32:45 <Pseudonym> I personally don't believe that C strings are actually strings.
00:32:48 <Pseudonym> But that's just me. :-)
00:32:51 <icarroll> heh
00:33:34 <lament> "string" is probably a group-theoretic concept?
00:33:43 <icarroll> C character arrays are informally referred to as strings, so I think they count for this purpose.
00:34:02 <Pseudonym> lament: I think it's a combinatorial concept, but you can think of a string as an element of the free monoid over the alphabet.
00:35:02 <lament> Pseudonym: which is probably the definition everybody uses now?
00:35:26 <lament> regardless of what the combinatorics guys originally had
00:35:29 <Pseudonym> Nah, formal language theorists just use the obvious definition.
00:35:34 <lament> blah
00:35:38 <lament> what can be more obvious than that :D
00:36:56 <icarroll> For example, SNOBOL stands for "StriNg Oriented...", so obviously the concept was present by the early 60s.
00:37:15 <Pseudonym> Yeah.  I'm currently looking in the MATH-MATIC manual to see if it had strings.
00:37:39 <Pseudonym> The thing is, the MATH-MATIC _compiler_ must have dealt with strings.
00:38:09 <icarroll> good point
00:38:24 <Pseudonym> But it looks like it might have used fixed-length words, and it was basically how many ASCII (or whatever) characters you could cram into it.
00:38:40 <Pseudonym> And, I might add, COLOSSUS was a text processor.
00:38:46 <icarroll> Wikipedia says SNOBOL was a successor to COMIT, but I can't find any free information about it.
00:39:03 <Pseudonym> The answer is probably FORTRAN.
00:39:14 <icarroll> anybody have an ACM portal subscription? http://portal.acm.org/citation.cfm?doid=366274.366291
00:39:15 <lambdabot> Title: COMIT
00:39:19 <Pseudonym> I do.
00:39:58 <Pseudonym> That's not much help.
00:40:05 <icarroll> k
00:40:39 <Pseudonym> This, BTW, is one of the references in that paper, though: http://www.mt-archive.info/MT-1958-Yngve.pdf
00:40:42 <Pseudonym> From 1958
00:41:14 <Pseudonym> The word "string" does indeed appear there.
00:41:23 <icarroll> thanks
00:41:29 <icarroll> I'm looking through it
00:41:32 <Pseudonym> But it's not exactly a programming language data type as you know it.
00:41:40 <icarroll> it refers to a "string of letters"
00:41:48 <Pseudonym> That's its I/O.
00:41:51 <icarroll> k
00:42:39 <Pseudonym> OK, it looks to me like MATH-MATIC really only had characters packed into words.
00:42:54 <icarroll> did it read a word at a time from the input file?
00:43:06 <Pseudonym> Well, it was a predecessor of COBOL.
00:43:11 <Pseudonym> So it handled formatted input.
00:43:18 <z0d> Hello
00:43:19 <Pseudonym> But it really only operated on words.
00:43:26 <Pseudonym> Hi.
00:43:29 <icarroll> hi
00:43:49 <Pseudonym> Trying to discover if 1958-era Lisp had strings.
00:43:56 <Pseudonym> Atoms aren't exactly strings.
00:44:17 <Pseudonym> But they were kind of used as strings in the early days.
00:44:36 <Pseudonym> Oh, man!
00:44:49 <Pseudonym> "I suppose I should learn Lisp, but it seems so foreign."  -- Paul Graham, November 1983
00:45:01 <icarroll> heh
00:45:51 <icarroll> from foreign to fanboy in 10 years :)
00:46:08 <DRMacIver> ricky_clarkson: You'll have to be more specific. I have no idea what that's in reference to. :)
00:51:18 <Pseudonym> OK, it looks like IPL might be the winner.
00:51:43 <Pseudonym> http://en.wikipedia.org/wiki/Information_Processing_Language
00:51:44 <lambdabot> Title: Information Processing Language - Wikipedia, the free encyclopedia
00:53:26 <icarroll> so far it looks to me like paleo-lisp
00:55:11 <Pseudonym> The thing is this.
00:55:16 <Pseudonym> IPL-1 pre-dates Lisp.
00:55:25 <Pseudonym> But the only IPL manual I could find was fir IPL-V
00:55:30 <Pseudonym> Which post-dates Lisp.
00:55:33 <Gosha> $strput(luls) <-- soemthing like that ..
00:55:40 <Gosha> some*
00:57:11 <icarroll> Where do you see that IPL had strings?
00:57:34 <icarroll> I see that it had lists of symbols, but I don't see that it had lists of characters.
00:58:25 <Pseudonym> http://bitsavers.org/pdf/rand/ipl/Baker_IPL-704.pdf
00:58:28 <Pseudonym> It's mentioned there.
01:00:38 <wli> Well, Fortran predates Lisp by ca. 4 years at least.
01:00:41 <icarroll> page?
01:00:55 <Pseudonym> wli: But did the original Fortran have strings?
01:01:03 <Pseudonym> Or was it just a TRANslation of FORmulas?
01:01:23 <wli> Grace Hopper's A1 predates Fortran, but it borders on macro assembler.
01:01:40 <wli> (I should probably say Admiral Grace Hopper.)
01:01:54 <Pseudonym> She wasn't an Admiral at the time.
01:02:00 <wli> Granted.
01:02:19 <wli> A1 is 1951, Fortran 1954, Lisp 1958.
01:02:24 <Pseudonym> Yeah, that's why I looked up MATH-MATIC and FLOW-MATIC.
01:02:26 <icarroll> So in January of 1963 people were referring to strings when programming in IPL.
01:02:32 <Pseudonym> Both of which were Hopper project, IIRC.
01:02:47 <wli> spiffy
01:03:31 <wli> Hopper's in a lot of fundamental things people take for granted. She's got her fingers in a lot of pies.
01:03:55 <Pseudonym> The impression that I'm getting is that the "string" was a concept long before it appeared in a programming language.
01:04:03 <Pseudonym> It's how a magnetic tape was understood, for example.
01:04:11 <icarroll> interesting
01:04:23 <Pseudonym> So it was an idea that was waiting for the concept of a data type.
01:04:24 <wli> I think it goes back to the 1890's at least.
01:04:53 <wli> Likely further back into 19th-century punchcard sorting machines.
01:05:13 <icarroll> It makes sense because it was a math term, and a lot of the early programmers had a math background.
01:05:33 <Pseudonym> So the more relevant question is not "which was the first language with the string data type", it's "which was the first language with data types".
01:05:45 <icarroll> Do you have a reference about strings referring to magnetic tape? That sounds interesting.
01:05:53 <wli> Probably Fortran.
01:06:03 <Pseudonym> It seems to be implicit in MATH-MATIC.
01:06:19 <wli> icarroll: I suggest looking back into 19th-century punch card sorting machines used for census tabulation.
01:06:32 <icarroll> good idea
01:06:38 <Pseudonym> wli: Again, did the original FORTRAN have data types?
01:06:44 <Pseudonym> I'm guessing it probably did.
01:06:46 <wli> icarroll: The name "Hollerith" may be useful.
01:06:48 <Pseudonym> Without looking it up.
01:07:01 <wli> Pseudonym: I think Fortran H did.
01:07:15 <Pseudonym> God is REAL.  Unless declared INTEGER.
01:07:19 <icarroll> heh
01:07:36 <wli> Pseudonym: I only have passing familiarit with F77; Fortran H is too ancient for any direct exposure here.
01:08:05 <icarroll> Original fortran for IBM 704 had formatted IO statements, but I don't know if that counts.
01:08:06 <Pseudonym> Right.
01:08:19 <Pseudonym> Arguably, some of the machine-code programming that Turing was doing probably worked on strings.
01:08:26 <Pseudonym> And he may well have called them "string"s.
01:09:09 <wli> I suspect the ENIGMA cryptanalysts did indeed do string processing.
01:09:21 <koala_man> "a string of x" must have meant a series of x for hundreds of years
01:09:35 <Pseudonym> Well, as I mentioned, COLOSSUS was indeed a string processor (though that worked on FISH, not ENIGMA).
01:09:54 <icarroll> koala_man: Probably. What's the earliest reference you know of?
01:09:54 <Haru> @korean
01:09:55 <lambdabot> Unknown command, try @list
01:09:58 <wli> Computers are war machines. ;)
01:10:15 <Pseudonym> koala_man: Probably not as far back as you think.
01:10:19 <Haru> !korean
01:11:07 <koala_man> dictionary.com puts "string" since before 900. someone probably had the poetic insight to make that metaphor early
01:11:34 <koala_man> I mean, what with necklaces and all
01:11:44 <koala_man> a string of beads
01:13:00 <Pseudonym> The mathematical sense probably goes back no further than Euler.
01:13:21 <Pseudonym> And probably not that far.
01:13:25 <Pseudonym> I have to go.
01:13:26 <Pseudonym> Nytol!
01:13:36 <icarroll> thanks for your input
01:14:26 * mux notes LtU provides an online video course on monads, apparently oriented towards mathematicians though
01:15:42 <olsner> @where catsters
01:15:42 <lambdabot> I know nothing about catsters.
01:16:23 <wli> I wonder what it means to suddenly develop a craving for milk and dairy products.
01:16:36 <icarroll> Check your DNA for mutations.
01:16:48 <wli> Sorry, wrong channel.
01:16:50 <icarroll> heh
01:17:13 <icarroll> For those who were following the string conversation
01:17:35 <icarroll> Looks like the Colossus machines operated a character at a time, so didn't really have a strings.
01:21:16 <wli> Check punch card sorting machines. Mechanical (in fact, electric) implementations of radixsort date from prior to 1930.
01:21:35 <opqdonut> radixsort is cute :)
01:21:44 <opqdonut> as are bucket sort and counting sort
01:32:30 <Gosha> What editor should I use for haskell?  Notepad++ somehow makes my spaces into tabs
01:32:37 <icarroll> vim
01:33:19 <Gosha> Hmm
01:33:20 <Gosha> Kay
01:33:37 <icarroll> There's emacs as well, if you swing that way :)
01:34:02 <Gosha> Well, I'm on windows, so ..
01:34:17 <icarroll> vim works on windows very well
01:34:25 <Gosha> Yeah, but not emacs?
01:34:27 <icarroll> I think emacs does too, but I haven't used it for a long time.
01:34:48 <icarroll> lots of versions of emacs, I'm sure at least one works
01:34:54 <Gosha> ... I'll stick with vim <.<
01:34:57 <Gosha> Used it befor as well..
01:34:58 <icarroll> good idea :)
01:35:24 <mornfall> hm, i like haskell-mode in emacs :]
01:35:32 <mornfall> flame! ;-)
01:35:34 <mornfall> @yow
01:35:34 <lambdabot> When you said "HEAVILY FORESTED" it reminded me of an overdue CLEANING
01:35:34 <lambdabot> BILL ... Don't you SEE?  O'Grogan SWALLOWED a VALUABLE COIN COLLECTION
01:35:34 <lambdabot> and HAD to murder the ONLY MAN who KNEW!!
01:35:35 <earthy> ofcourse, if you swing wildly differently, you could go the Visual Studio route
01:35:43 <icarroll> @quote emacs
01:35:43 <lambdabot> dylan says: I run emacs for the games
01:36:05 <icarroll> earthy: watch your language :)
01:36:07 <earthy> a coworker absolutely will not use anything but Visual Studio and VSHaskell
01:36:11 <icarroll> wow
01:36:27 <Gosha> O_O ... Visual Haskell? ... o.o ... dnw.
01:36:47 <earthy> and yes, it does have type error squigglies.
01:36:50 <icarroll> I suppose it makes sense. After all, they're paying Simon PJ lots of money to work for them.
01:36:51 <icarroll> heh
01:37:00 <earthy> :)
01:39:02 <quicksilver> I'm not aware that SPJ was involved into the visual haskell project
01:40:20 <icarroll> I doubt he was.
01:40:37 <icarroll> Doesn't ruin the joke though, I hope.
01:40:43 <quicksilver> ;)
01:40:53 <quicksilver> You weren't far off, though
01:40:58 <quicksilver> Simon Marlow definitely was involved
01:40:59 <earthy> JaffaCake was involved though, right?
01:41:09 <quicksilver> and what's a Simon between friends?
01:41:10 <quicksilver> ;)
01:41:23 <icarroll> heh
01:41:25 <quicksilver> I've often wondered what editor SPJ uses
01:41:27 <icarroll> @quote simon
01:41:27 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
01:41:28 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
01:41:28 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
01:41:40 <quicksilver> I've never noticed him express a preference though
01:42:34 <opqdonut> cat(1) probably
01:42:46 <ibid> ed is the standard editor
01:42:54 <opqdonut> you are correct sir
01:43:20 <opqdonut> an ed-like editor with a functional command language would be cool
01:43:35 <opqdonut> something combinatoric maybe
01:43:53 <icarroll> just give it S and K and call it good
01:44:16 <ibid> S as in Simon, K as in ...?
01:44:16 <ibid> :)
01:44:24 <ibid> (yes, i know SK)
01:44:27 <icarroll> heh
01:44:36 <vincenz> Kelogg... I mean K-Oleg
01:44:47 <icarroll> naw, you only need 512 Olegs
01:45:06 * vincenz boggles at that quantity
01:45:14 <vincenz> you must be talking of micro-Olegs
01:45:26 <quicksilver> anyone have a theory on why Data.Sequence doesn't contain a 'toList' ?
01:45:27 <opqdonut> yeah i was thinking of SKI with editing combinators added
01:45:42 <quicksilver> is it because 'toList' is deprecated in favour of using Traversable?
01:45:56 <icarroll> opqdonut: there's lots of shiny evil you could do with something like that
01:46:29 <opqdonut> yep
01:46:34 <vincenz> quicksilver: I've wondered the same myself
01:47:26 <quicksilver> vincenz: I ended up using the mapM/forM from traversable
01:47:33 <quicksilver> vincenz: which, I guess, is perfectly sane
01:48:01 <quicksilver> vincenz: althouhg I missed having a '_' version
01:48:46 <vincenz> quicksilver: i had a slurping function based on viewL
01:49:31 <quicksilver> vincenz: the other thing that seems odd is not having 'map'
01:49:46 <quicksilver> vincenz: map :: (a->b) -> Seq a -> Seq b, I mean
01:49:50 <opqdonut> does it have a functor instance?
01:49:58 <quicksilver> ah, so it does
01:50:01 <quicksilver> opqdonut++
01:50:04 <opqdonut> there you go :)
01:50:09 <quicksilver> not very bright of me there
01:50:30 <quicksilver> it's always a bit confusing when the 'public API' of a type is partly in class instances though
01:50:36 <quicksilver> well, it's confusing for me :)
01:51:49 <quicksilver> oh
01:51:56 <quicksilver> mapM_ is in the Foldable instance
01:52:08 <quicksilver> of course
01:52:18 <quicksilver> consider my above comment about class instances repeated :)
01:53:27 <quicksilver> vincenz: Oh!!!
01:53:37 <vincenz> Eh?
01:53:44 <quicksilver> vincenz: there is a toList. It's a Foldable thing :)
01:54:01 * vincenz palmslaps
01:54:21 <quicksilver> toList = Foldable.foldr (:) [], presumable
01:54:55 <quicksilver> I did some google searches and learnt that there *used* to be a toList in Sequence, before foldable came along :)
01:54:58 <quicksilver> that was the clue
01:55:30 <quicksilver> and google found me this "There is a function toList in the opposite direction for all instances of the Foldable class, including Seq."
01:55:40 <quicksilver> which is actually in the docs for Data.Sequence but I was too blind to see it
01:59:45 <vincenz> @hoogle toList
01:59:46 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
01:59:46 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
01:59:46 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
01:59:53 <vincenz> @hoogle Foldablbe
01:59:53 <lambdabot> No matches found
01:59:55 <vincenz> @hoogle Foldable
01:59:55 <lambdabot> No matches found
01:59:58 <vincenz> heh
02:04:27 <quicksilver> counter intuitive to have mapM_ and mapM in different classes
02:05:16 <quicksilver> well, at least if you're used to thinking of mapM_ as being defined in terms of mapM
02:05:19 <quicksilver> which I was
02:06:08 <fasta> What happens when I run runInteractiveProcess "foo" in a loop? Will foo be looked up via the path multiple times?
02:06:29 <fasta> (that's what I need)
02:06:59 <icarroll> @hoogle runInteractiveProcess
02:07:03 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
02:07:11 <opqdonut> quicksilver: huh? so mapM is in monad and mapM_ in Foldable?
02:07:14 <icarroll> ouch
02:07:47 <vincenz> mapM is in traversable
02:07:53 <opqdonut> geh
02:08:36 <opqdonut> i've got no idea about Foldable, Traversable. been too long since i programmed something real in haskell
02:08:48 <opqdonut> moving too fast
02:08:59 <quicksilver> opqdonut: mapM is also in monad, but that's not the one I meant
02:09:14 <quicksilver> opqdonut: once you try to generalise beyond lists, it makes sense to separate
02:09:31 <quicksilver> because 'mapM' has to reconstruct a new structure of the same type as the old structure
02:09:39 <opqdonut> yeah i realise
02:09:44 <quicksilver> whereas mapM_ really doesn't; it just dumps the structure
02:09:56 <quicksilver> mind you, mapM_ is a terrible name when you think about it
02:10:00 <quicksilver> it's not a map at all
02:10:03 <opqdonut> mhmm :)
02:10:06 <quicksilver> it's just a 'foreach' or 'iteration'
02:10:07 <opqdonut> forM is better
02:10:15 <quicksilver> forM_ is better
02:10:22 <opqdonut> yeah with _
02:10:24 <quicksilver> but the forM (no _) reconstructs the structure
02:10:33 <quicksilver> it's just mapM with args reversed
02:10:35 <opqdonut> yeah yeah
02:10:44 <quicksilver> I think you could argue they should really have totally different names
02:11:16 <opqdonut> ?instances Foldable
02:11:17 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
02:11:37 <opqdonut> nah too new
02:12:28 <quicksilver> list, seq, set, tree, maybe, intmap
02:12:33 <quicksilver> are the interesting ones
02:12:42 <quicksilver> oh, and array and map
02:13:02 <quicksilver> they're all also traversable, except Set
02:32:23 <opqdonut> why is set foldable but not traversable?
02:35:00 <quicksilver> because, presumably, it's not safe to re-assemble the structure
02:35:10 <quicksilver> because of duplicate elimination
02:39:47 <roconnor> @let n = 2305843009213693951
02:39:50 <lambdabot> Defined.
02:40:05 <roconnor> > 2^n `mod` n
02:40:10 <lambdabot> Terminated
02:41:26 <opqdonut> quicksilver: ah, i see
02:41:54 <roconnor> > let a ^ 0 = 1; a ^ b = if odd b then a*(a^(b-1)) `mod` n else let c = a^(b `div` 2) in c*c `mod` n in 2^n `mod` n
02:41:55 <lambdabot>  2
02:42:01 <roconnor> > let a ^ 0 = 1; a ^ b = if odd b then a*(a^(b-1)) `mod` n else let c = a^(b `div` 2) in c*c `mod` n in 3^n `mod` n
02:42:03 <lambdabot>  3
02:42:47 <opqdonut> or how is it not safe? more like tedious?
02:42:53 <roconnor> > let isPrime x = let a ^ 0 = 1; a ^ b = if odd b then a*(a^(b-1)) `mod` n else let c = a^(b `div` 2) in c*c `mod` n in 2^x `mod` x == 2 && 3^x `mod` x == 3 in isPrime n
02:42:55 <lambdabot>  True
02:42:58 <opqdonut> pairwise equality checks etc
02:43:18 <roconnor> @let isPrime x = let a ^ 0 = 1; a ^ b = if odd b then a*(a^(b-1)) `mod` n else let c = a^(b `div` 2) in c*c `mod` n in 2^x `mod` x == 2 && 3^x `mod` x == 3
02:43:23 <lambdabot> Defined.
02:44:23 <quicksilver> opqdonut: 'not safe' as in 'fails to respect the kind of algebraic behaviour we expect from traversable'
02:44:42 <opqdonut> what sort of behaviour?
02:44:53 <opqdonut> like size invariancy?
02:44:56 <quicksilver> yes
02:45:10 <opqdonut> ah i see
02:45:18 <opqdonut> how is the folding order decided, then?
02:45:31 <opqdonut> or should the fold op be associative?
02:45:39 <roconnor> > isPrime 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF
02:45:42 <lambdabot>  False
02:45:43 <quicksilver> folds are done into monoids
02:45:50 <quicksilver> which are associative by definition
02:46:08 <quicksilver> that doesn't answer your question about order though
02:46:10 <roconnor> :/
02:46:12 <quicksilver> they aren't associative :)
02:46:14 <quicksilver> erm
02:46:17 <quicksilver> commutative
02:46:24 <quicksilver> I guess 'arbitrary order' is considered good enough
02:46:38 <opqdonut> hrmm
02:46:39 <quicksilver> or maybe, Sets are folding in increasing order
02:46:55 <roconnor> @type isPrime
02:46:57 <lambdabot> Not in scope: `isPrime'
02:47:05 <opqdonut> is there an Ord constraint then?
02:47:10 <opqdonut> on the fold?
02:47:11 <roconnor> @let isPrime :: Integer -> Bool; isPrime x = let a ^ 0 = 1; a ^ b = if odd b then a*(a^(b-1)) `mod` n else let c = a^(b `div` 2) in c*c `mod` n in 2^x `mod` x == 2 && 3^x `mod` x == 3
02:47:12 <lambdabot> <local>:6:28:     Multiple declarations of `L.isPrime'     Declared at: <loca...
02:47:19 <roconnor> @undef isPrime
02:47:21 <opqdonut> doesn't that need extensions
02:47:21 <lambdabot> Undefined.
02:47:25 <roconnor> @let isPrime :: Integer -> Bool; isPrime x = let a ^ 0 = 1; a ^ b = if odd b then a*(a^(b-1)) `mod` n else let c = a^(b `div` 2) in c*c `mod` n in 2^x `mod` x == 2 && 3^x `mod` x == 3
02:47:26 <lambdabot> <local>:1:95: Not in scope: `n'  <local>:1:137: Not in scope: `n'
02:47:35 <roconnor> oh right
02:47:35 <quicksilver> opqdonut: no, but Set has an Ord constraint
02:47:45 <roconnor> @let isPrime :: Integer -> Bool; isPrime x = let a ^ 0 = 1; a ^ b = if odd b then a*(a^(b-1)) `mod` x else let c = a^(b `div` 2) in c*c `mod` n in 2^x `mod` x == 2 && 3^x `mod` x == 3
02:47:46 <lambdabot> <local>:1:137: Not in scope: `n'
02:47:53 <roconnor> @let isPrime :: Integer -> Bool; isPrime x = let a ^ 0 = 1; a ^ b = if odd b then a*(a^(b-1)) `mod` x else let c = a^(b `div` 2) in c*c `mod` x in 2^x `mod` x == 2 && 3^x `mod` x == 3
02:47:57 <lambdabot> Defined.
02:47:58 <quicksilver> opqdonut: it's not entirely consistent, in my eyes
02:48:02 <roconnor> > isPrime 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF
02:48:04 <lambdabot>  True
02:48:06 <roconnor> :)
02:48:10 <quicksilver> opqdonut: we allow Functor instances which fail the 'size' property
02:48:20 <quicksilver> opqdonut: it's not entirely clear to me what the difference is, here
02:48:47 <quicksilver> opqdonut: Oh. Actualy we don't.
02:48:53 <quicksilver> opqdonut: Set isn't an instance of Functor.
02:49:22 <quicksilver> opqdonut: but it has its own 'map' definition to compensate
02:49:43 <roconnor> > isPrime 561
02:49:45 <lambdabot>  True
02:49:52 <roconnor> > 3 * 11 * 17
02:49:53 <lambdabot>  561
02:51:19 <wli> Try AKS vs. Rabin-Miller or some such.
02:51:50 <opqdonut> quicksilver: ok, i see
02:52:26 <opqdonut> ah, yes, set was Ord constrained and not Eq for efficiency reasons
02:52:41 <Gosha> Geez, I fail at Haskhell..
02:53:36 <Gosha> Prelude> do { n <- GetLine ; if n == "Hello" { strPutLn "Good job." } else { strPutLn "Failfag." } Error at 1:47 ... the ' " ' ?
02:54:48 <quicksilver> Gosha: if needs a 'then'
02:55:03 <quicksilver> Gosha: the {} don't mean quite what you want them to mean, either
02:58:28 <Gosha> .. mm, how should I put the then then? with a ; before?
02:59:43 <quicksilver> Gosha: if n == "Hello" then putStrLn "Nice work" else putStrLn "Wrong answer"
02:59:47 <quicksilver> Gosha: would be fine
03:00:33 <wli> Set could be made Eq constrained while remaining efficient by uee of intensional ordering.
03:00:50 <Gosha> Prelude> do { n <- GetLine ; if n == "Hello" then strPutLn "Good job" else strPutLn "Failfag."
03:00:50 <Gosha> <interactive>:1:85: parse error (possibly incorrect indentation)
03:01:00 <Gosha> ...
03:01:02 <Gosha> oh
03:01:04 <Gosha> putStrLn ..
03:01:05 <Gosha> fail
03:01:12 <quicksilver> Gosha: you forgot to close the } that you opened after the do
03:01:18 <quicksilver> Gosha: that's the parse error
03:01:41 <quicksilver> Gosha: and yes, you're right it's putStrLn but that would show up as a different kind of error
03:01:47 <opqdonut> wli: intensional ordering?
03:01:50 <quicksilver> Gosha: it's "getLine" not hGetLine, too
03:02:03 <opqdonut> you mean like using Ord if it is available?
03:02:06 <Gosha> Yay
03:02:06 <wli> opqdonut: Well, there are other alternatives, like polytypic ordering.
03:02:14 <Gosha> Thanks
03:02:21 <Gosha> It'll take some time to learn this .. hu..
03:02:24 <wli> opqdonut: No, like messing with the low-level representation of the structure.
03:02:32 <opqdonut> ah, i see
03:03:14 <opqdonut> but wouldn't you want some sort of correlation between the ordering's equivalence and the one from Rq?
03:03:17 <opqdonut> *Eq
03:03:20 <wli> opqdonut: You can sort of do it otherwise (barring function types) if you have some sort of way of peeling apart product and coproduct types.
03:04:47 <wli> opqdonut: Well, you get an equality from the usual trichotomy, so essentially nontrivial Eq instances end up being quotients on the equality relation you get from this default ordering.
03:05:02 <opqdonut> moi joel
03:05:21 <opqdonut> woopswrong chan
03:05:26 <opqdonut> i blame wlan lag
03:05:47 <opqdonut> wli: well yeah okay
03:05:51 <wli> opqdonut: That is, they have to give equality when the default ordering gives equality or otherwise the proof burden is unsatisfied, but they can yield equality in other instances.
03:09:44 <wli> It would actually be a sort of "deriving Ord" that works more often than the actual one in the polytypic case.
03:10:52 <wli> Essentially you don't really care whether the ordering makes any semantic sense, just whether any sort of ordering that makes sense is defineable.
03:11:41 <wli> So products and coproducts out the wazoo are orderable but not functions.
03:12:59 <wli> If Ord already works for arbitrary products and coproducts then Ord is it.
03:13:31 <wli> I think there's some case there where Ord refuses to derive on such.
03:16:24 <vincenz> coproduct = sum??
03:17:19 <opqdonut> ok
03:26:19 <EvilTerran> is it possible to write a constrained version of a State with a newtype? i'm running into trouble
03:27:06 <EvilTerran> I've got newtype Stack c a = Stack { stack :: State [c] a } deriving Monad
03:27:45 <EvilTerran> class Monad m => MonadStack c m | m -> c where push :: c -> m (); pop :: m c; empty :: m Bool
03:28:02 <EvilTerran> but i can't work out how to write instance MonadStack c (Stack c)
03:28:34 <EvilTerran> (that deriving's a GeneralizedNewtypeDeriving)
03:29:48 <quicksilver> EvilTerran: should be fine
03:30:17 <quicksilver> EvilTerran: which part of the MonadStack instance is hard to write?
03:30:23 <EvilTerran> okay, how do i write the body of, say, empty?
03:30:44 <EvilTerran> (liftM null get) doesn't work, 'cos the State's wrapped in a newtype
03:31:23 <quicksilver> empty = Stack $ do { .. } ?
03:31:46 <quicksilver> empty = Stack $ do { s <- get; return (null s) }
03:31:47 <quicksilver> I think
03:32:28 <EvilTerran> (Stack . liftM null get . stack) looks vaguely plausible, but doesn't actually work, 'cos the State's not actually a parameter to get
03:33:33 <EvilTerran> ah, i think i see...
03:33:38 <vincenz> simple, define MonadState for Stac
03:34:04 <EvilTerran> vincenz, but then people'll be able to do whatever they want with the state, and i'm trying to write a *restricted* State here
03:34:18 <EvilTerran> much like having a restricted IO monad or whatever
03:34:35 <vincenz> ah
03:34:45 * EvilTerran is still slightly confused by how State works exactly, TBH.
03:34:57 <vincenz> let me refresh my memory
03:35:02 <vincenz> lifting in and out of constructors is annoying
03:35:36 <vincenz> ah
03:35:52 <EvilTerran> quicksilver, well, that typechecks, which is further than i'd got before
03:36:07 <vincenz> Stack $ liftM null get
03:36:09 <vincenz> there you go :)
03:36:27 <vincenz> Stack is a state-action that's wrapped with the Stack contructor
03:37:39 <EvilTerran> yeah, it's all starting to make sense now
03:37:56 * EvilTerran forgot that the type of the do{} was State blabla
03:38:10 <vincenz> I just realized it while looking at the instance of one of my own monads
03:38:20 <vincenz> but it's a good way of thinking about it :)
03:42:21 <ndm> @seen mobes
03:42:21 <lambdabot> I haven't seen mobes.
03:42:24 <ndm> @seen mboes
03:42:24 <lambdabot> I saw mboes leaving #haskell 3d 16h 44m 18s ago, and .
03:43:42 <quicksilver> EvilTerran: it's safe to export 'Stack' because it's safe to turn a State into a Stack
03:43:55 <quicksilver> EvilTerran: you don't really want to export 'stack' because that's the reverse :)
03:44:11 <EvilTerran> yeah, this is all working now, AFAICT
03:44:13 <EvilTerran> quicksilver++
03:44:16 <EvilTerran> vincenz++
03:44:18 <EvilTerran> :)
03:44:20 <quicksilver> yay :)
03:44:36 <vincenz> \o/
03:50:20 <scook0> wouldn't exporting the constructor allow you to pattern-match out of Stack?
03:51:57 <EvilTerran> hm.
03:52:16 <EvilTerran> maybe I should rename stack to unStack, and have stack = Stack. or just not export Stack at all...
03:52:19 <scook0> (I seem to recall a Haskell-Prime ticket suggesting read-only constructor exports, to get around this)
03:52:26 <scook0> EvilTerran: that's what I was about to suggest
03:53:19 <EvilTerran> ?type lookup
03:53:20 <shteou> Aah, good morning teamsters!
03:53:21 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:54:04 <EvilTerran> ?type maybe
03:54:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:55:53 <[TWiSTED]> what does func1 >.> func2 do?
03:56:05 <EvilTerran> ?type (>.>)
03:56:06 <lambdabot> Not in scope: `>.>'
03:56:30 <[TWiSTED]> is it a variation of function composition
03:57:11 <mr_tenor> it's like a frustrated smilie
03:57:19 <[TWiSTED]> heh
03:57:41 <scook0> (:[]) -- my favourite
03:57:55 <scook0> the fact that it's a useful function is a bonus :)
03:58:10 <vincenz> > fix (:[])
03:58:11 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
03:58:11 <lambdabot>       Expected...
03:58:23 <scook0> > (:[]) 3
03:58:25 <lambdabot>  [3]
03:58:37 <vincenz> > let cookiemonster = (:[]) in map cookiemonster $ replicate 3 "lambda-cookie"
03:58:38 <lambdabot>  [["lambda-cookie"],["lambda-cookie"],["lambda-cookie"]]
03:59:06 <scook0> > (:[]) (<3)
03:59:08 <lambdabot>  [<Integer -> Bool>]
03:59:33 <vincenz> > map ($3) (:[]) (<3)
03:59:33 <lambdabot>      The section `(: [])' takes one argument,
03:59:34 <lambdabot>     but its type `[a -> b]' has...
03:59:41 <vincenz> > map ($3) $ (:[]) (<3)
03:59:42 <lambdabot>  [False]
04:11:16 <EvilTerran> :t guard
04:11:24 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:19:35 <[TWiSTED]> is there a special character for whitespace in haskell?
04:19:56 <Lemmih> [TWiSTED]: Other than ' '?
04:20:14 <[TWiSTED]> yeh
04:23:23 <Gosha> factorial n = if n == 0 then 1 else n * factorial (n - 1) <--- if n = 5 ... what would it calculate? ... 5*5*4? .. Doesn't add up to 120...
04:23:47 <ricky_clarkson> 5*factorial (4)
04:24:02 <Gosha> ... but wasn't factorial the function?
04:24:02 <ricky_clarkson> factorial 4 would be 4*factorial 3
04:24:05 <ricky_clarkson> Yes.
04:24:06 <Gosha> oh
04:24:08 <Gosha> Ooooh
04:24:20 <Gosha> so, 5*4*3*2*1?
04:24:37 <Gosha> I see
04:24:43 <Gosha> But why does it stop at 1?
04:24:59 <scook0> because that's the only sensible place to stop?
04:25:12 <scook0> if you stopped at 0, it would be boring
04:25:14 <Saizan> 'if n == 0 then 1'
04:25:15 <Gosha> ... I mean .. Any other language would keep looping? <.<
04:25:19 <scook0> and if you kept going, the sequence would diverge
04:25:24 <Gosha> Oh, now I get it
04:25:27 <Gosha> Gah, I'm stupid
04:25:29 <scook0> oh, you mean the implementation?
04:25:29 <Gosha> Wel, thanks
04:25:34 <EvilTerran> 0! = 1, isn't it?
04:25:40 <Gosha> ... Wait, what?
04:25:45 <Gosha> True ..
04:25:46 <Saizan> EvilTerran: yup
04:25:57 <EvilTerran> factorial n = product [1..n]
04:26:08 <EvilTerran> factorial 0 = product [1..0] = product [] = 1
04:26:13 <[TWiSTED]> is there a way to create a list of whitespaces for a specified number of elements? [' ' .. 8] ?
04:26:22 <EvilTerran> > replicate 8 ' '
04:26:27 <lambdabot>  "        "
04:26:28 <[TWiSTED]> thanks
04:26:55 <scook0> [TWiSTED]: you can often answer that sort of question with hoogle
04:27:16 <[TWiSTED]> ah ok
04:27:18 <[TWiSTED]> thanks
04:27:25 <scook0> @hoogle a -> Int -> [a]
04:27:26 <lambdabot> Prelude.replicate :: Int -> a -> [a]
04:27:33 <scook0> @go hoogle
04:27:35 <lambdabot> http://haskell.org/hoogle/
04:27:35 <lambdabot> Title: Hoogle
04:28:08 <scook0> though it can be stupid or incomplete sometimes
04:28:16 <scook0> which is when you ask #haskell :)
04:28:18 <Saizan> however there are too few questions on this channel lately. imo
04:28:23 <ricky_clarkson> Really?
04:28:58 <ricky_clarkson> hoogle is impressive, as is djinn.
04:29:07 <scook0> suffering from helpfulness-withdrawal?
04:29:25 <puusorsa> what's djinn good for
04:30:09 <scook0> @djinn Maybe a -> b -> (a -> b) -> b
04:30:09 <lambdabot> f a b c =
04:30:09 <lambdabot>     case a of
04:30:09 <lambdabot>     Nothing -> b
04:30:09 <lambdabot>     Just d -> c d
04:30:25 <scook0> puusorsa: deriving an implementation from a function type
04:30:30 <Saizan> scook0: more like learning by osmosis
04:30:38 * EvilTerran does that
04:30:54 <puusorsa> yeah, i know, kinda. i need to code more in haskell maybe i'll get it some day
04:30:57 <Gosha> perWeek ... ?
04:31:39 <EvilTerran> also, i've managed to get one of my mathmo friends hooked on haskell, so i've suggested he come on here to soak up the intelligence
04:32:30 <EvilTerran> (he's been given a programming project to do over the summer by his uni - something involving iterative approximation. they suggested C, but i said "no, use haskell!")
04:33:15 <mr_tenor> EvilTerran: yeah, i just keep #haskell irc open in the background most of the time and figure i'll unconsciously absorb the intelligence, like those hypnosis casettes
04:33:32 <EvilTerran> hehe
04:34:11 <EvilTerran> i think i learn quite a lot from trying to help randoms on here, as well as being a random who needs help on occasion ;)
04:34:26 <EvilTerran> yay, my MonadStack's working :D
04:34:53 <earthy> ;)
04:35:06 <koxinga> mr_tenor:  And does it work ?
04:35:10 <EvilTerran> *Main> runStack (push 1 >> push 2 >> op (*) >> peek >>= push >> op (^)) []
04:35:10 <EvilTerran> ((),[4])
04:35:19 <Saizan> yeah, how do you debug a Segmentation Fault?
04:35:24 <scook0> EvilTerran: it's Forth!
04:35:55 <scook0> Saizan: rewrite your program in Haskell? ;)
04:36:19 <EvilTerran> (op (?) = do x <- pop; y <- pop; push (y ? x))
04:36:20 <scook0> (though I've had a segfault in pure Haskell before ... something to do with SSE2 codegen)
04:36:34 <Saizan> scook0: it is :) just using ffi to bind a lacking documentation library
04:36:37 <scook0> I really should see about submitting a bug report for that
04:37:39 * EvilTerran thinks... is that (push =<< liftM2 (?) pop pop)?
04:38:03 <Saizan> EvilTerran: you need a flip
04:38:04 <scook0> EvilTerran: @pl ?
04:38:21 <EvilTerran> @. pl undo do x <- pop; y <- pop; push (y ? x)
04:39:10 <vincenz> @. pl undo do {x <- pop; y <- pop; push (y ? x) }
04:39:11 <EvilTerran> Saizan, ah, true. i'm doing it that way so "do push x; push y; op (-)", say, does what you'd expect
04:39:16 <Lemmih> scook0: Manual training is important for when you're stuck in the woods and need some pointless code.
04:39:26 <vincenz> @join #oass
04:39:26 <EvilTerran> @bot
04:39:28 <vincenz> @join #oasis
04:39:38 <earthy> dead... in the water...
04:39:49 <EvilTerran> @BOOOOT!
04:39:56 <vincenz> you mean @reboot
04:40:51 <vincenz> Lemmih: yeah, cause then you're definitely worrying about haskell code
04:41:08 <EvilTerran> </Roy Campbell> :P
04:41:15 <vincenz> "Hmm, let me write a haskell program to find me the safest and most direct route out of this unknown forest"
04:42:41 <EvilTerran> get ghc to do some deforestation!
04:43:07 <ricky_clarkson> It's just a [Tree]
04:45:44 * earthy nods
04:45:58 <scook0> then you can use the list monad to do some backtracking, and get out of there!
04:46:16 <EvilTerran> if we had some way of indexing the trees, we could make a map of the forest with Data.Map.fromList...
04:46:21 <vincenz> no, just consume the list, and then have GHC deforest
04:46:35 <vincenz> you're instantly transported to the edge
04:46:51 <scook0> unsafePerformIO $ burn forest -- playing with fire?
04:47:03 <earthy> map flatten forest?
04:47:05 * EvilTerran has visions of a Warcraft night-elf ancient hunched over a laptop coding haskell
04:47:24 <vincenz> unsafePerformIO $ reawaken dragon
04:47:30 * EvilTerran wonders if that's too obscure
04:47:34 <vincenz> is the magic incantation he typed
04:48:50 <EvilTerran> (the night-elves have living buildings called Ancients; if one gets damaged, you heal it by getting it to uproot, walking it to a nearby tree, and getting it to eat it)
04:49:02 <EvilTerran> (so "<vincenz> no, just consume the [trees]" made me think of that)
04:49:27 <dozer> am I in the wrong chat room???
04:49:47 <scook0> dozer: no, this is #haskell, same as always :)
04:49:51 <EvilTerran> not at all, dozer - the Ancient's writing haskell code!
04:50:06 <EvilTerran> anyway. enough of this silliness for now.
04:50:07 <Japsu> "this is wrong chat room" "no, this is #HASKEEEEEEEEEEEEEEEELLLLL"
04:50:11 * EvilTerran goes to have lunch
04:50:15 <EvilTerran> Japsu, rofl
04:50:18 <vincenz> has kill?
04:50:27 <EvilTerran> @remember Japsu "this is wrong chat room" "no, this is #HASKEEEEEEEEEEEEEEEELLLLL"
04:50:30 <dozer> gha! HXT isn't working how I want
04:50:35 <EvilTerran> aww, still no bot
04:50:39 <Japsu> :<
04:53:28 <opqdonut> :)
04:54:18 <Saizan> dozer: what's the problem?
04:54:21 <Japsu> Mui. opqdonut
04:54:39 <dozer> Saizan: deep seems to be returning just the first match for me, not all matches
04:54:53 <dozer> shall I paste something into pastebin?
04:54:56 <[TWiSTED]> say ive got show [2,3,4] which would output "[2,3,4]" how would i go about removing the square brackets?
04:55:21 <[TWiSTED]> filter?
04:56:09 <kpreid> > (intersperse ',' . map show) [2,3,4]
04:56:17 <scook0> concat . intersperse "," . map show $ [2,3,4] perhaps?
04:56:37 <scook0> or you could use filter
04:56:47 <earthy> isn't intercalate in the standard libs yet?
04:56:59 <kpreid> ah, yes, scook0's is right
04:57:18 <[TWiSTED]> ah yeh
04:57:52 <kpreid> [TWiSTED]: General programming advice -- "how do I take them out" is usually a bad idea; one should look for how to not have them put in
04:58:01 <hpaste>  dozer pasted "hxt deep problem" at http://hpaste.org/2778
04:58:21 <dozer> sorry - it's code I had in ghci, so it needs formatting :$
04:58:22 <[TWiSTED]> yeh but its for just formatting output in a particular way
04:58:26 <scook0> filter (not . (`elem` "[]")) "[1, 2, 3]" ==> "1,2,3"
04:58:35 <ricky_clarkson> [TWiSTED]: That doesn't make it not programming.
04:58:35 <scook0> but yeah, I'd try to avoid them in the first place
04:58:35 <[TWiSTED]> ohh right i see what you mean
04:58:53 <Saizan> dozer: deep doesn't recurse inside subtrees of matching nodes
04:59:00 <[TWiSTED]> thanks
05:01:21 <dozer> Saizan: sure - but there ar three Rule elements there that are siblings - shouldn't it be finding all 3?
05:01:52 <Saizan> dozer: how many does it find?
05:01:57 <dozer> for me, 1 - the first one
05:04:30 <Saizan> i think you want getChildren >>> instead of processChildren
05:05:42 <Saizan> because processChildren just alters the subtrees but the result is still the starting node, no?
05:05:52 <dozer> ah, thanks - that seems much better
05:06:25 * Saizan has never used processChildren before
05:07:06 <dozer> it's what you use when you want to do xslt-style edits I guess
05:55:45 <hkBst> does show support arbitrary bases for converting numbers to strings?
05:56:57 <EvilTerran> ?hoogle atBase
05:56:58 <Lemmih> hkBst: No.
05:57:07 <quicksilver> :t showIntAtBase
05:57:13 <EvilTerran> ?bot
05:57:20 <EvilTerran> damnit, still no \bot
05:57:22 <quicksilver> hkBst: yes
05:57:36 <Lemmih> showIntAtBase /= show.
05:57:42 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html#v%3AshowIntAtBase
05:57:50 <quicksilver> quite true
05:57:55 <quicksilver> but maybe that isn't what he meant :)
05:58:09 <hkBst> thanks quicksilver :)
06:00:28 <[TWiSTED]> how do you run a module with commandline arguments in winhugs?
06:00:29 <quicksilver> EvilTerran: peek >>= push was "dup" was it?
06:01:02 <quicksilver> [TWiSTED]: ghci has a :Set option for it
06:01:08 <Lemmih> [TWiSTED]: withArgs args fn
06:01:11 <quicksilver> [TWiSTED]: if winhugs doesn't have that, there is always "withArgs"
06:01:19 <dcoutts> or runhugs
06:01:19 <[TWiSTED]> ohh ok
06:01:36 <EvilTerran> quicksilver, indeed it was. why do you ask?
06:01:52 <quicksilver> EvilTerran: because it deserves a name :)
06:02:01 <quicksilver> EvilTerran: but I was checking that I understood
06:02:13 <quicksilver> EvilTerran: have you seen Joy (the programming language)?
06:02:24 <EvilTerran> peek's defined in terms of push and pop, anyway, iirc.
06:02:42 <EvilTerran> (although as a method w/ default in my thing)
06:02:47 <EvilTerran> i haven't, no. i'll have a looksie.
06:03:48 * EvilTerran wanders off again
06:53:42 <[TWiSTED]> withArgs isnt working
06:53:50 <[TWiSTED]> says undefined variable
06:54:08 <quicksilver> [TWiSTED]: you didn't import the appropriate module, perhaps?
06:54:15 <[TWiSTED]> do i use withArgs main args or withArgs module.hs args
06:54:35 <quicksilver> [TWiSTED]: check out the docs
06:54:38 <[TWiSTED]> ok
06:54:52 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
06:55:02 <[TWiSTED]> thanks
06:55:24 <puusorsa> when all else fails, read the documentation...
06:55:51 <EvilTerran> huh. newtype deriving is cool.
06:55:51 <Saizan> if there's one
06:56:11 <hpaste>  hkBst pasted "how to write factorial boilerplate" at http://hpaste.org/2779
06:56:24 * EvilTerran has an eerie sense of "that was too easy"
06:57:57 <EvilTerran> hkBst, using fact n = case n of 0 -> 1; 1 -> 1; ... would be a little terser
06:58:42 <EvilTerran> hkBst, however, if O(log n) lookup time's satisfactory (rather than your desired O(1) there), you could memoise with a Data.Map instead of a list
07:00:26 <hkBst> EvilTerran: how would I memoise with a Data.Map instead of a list?
07:00:28 <twanvl> If you compile with -O2 the intermediate list will never be constructed
07:01:03 <hkBst> twanvl: oh, so it's already optimal? how do you know?
07:02:39 <EvilTerran> @docs Data.Map
07:03:46 <vincenz> bot is dead
07:03:54 <opqdonut> again?
07:04:42 <hkBst> with the explicit list it actually seems to be about twice as slow as with the version that constructs a list of answers... :)
07:05:09 <twanvl> hkBst: The onyl way to know for sure is to examine the optimized code generated by ghc using the -ddump-simpl flag. But I am pretty sure code like this where a list is produced and directly consumed by standard functions wil be optimized.
07:12:49 <EvilTerran> hkBst, what you've got there doesn't memoize, AFAICT
07:13:05 <EvilTerran> (the one with factList and quickFact)
07:13:34 <hpaste>  EvilTerran annotated "how to write factorial boilerplate" with "now with memoization" at http://hpaste.org/2779#a1
07:16:04 <hkBst> EvilTerran: ah yes, the `limit' is quite useless :) I don't see any difference that would explain why your and mine version would differ in being memoized or not though.
07:16:25 <quicksilver> hkBst: it's to do with having a parameter
07:16:59 <quicksilver> hkBst: EvilTerran's factList doesn't have any parameters, thus once it's evaluated it stays around
07:17:07 <quicksilver> (unless the GC could prove it wasn't needed any more)
07:17:21 <EvilTerran> things are, generally, only stored once evaluated iff they're bound to a name.
07:17:32 <EvilTerran> and they're released again as soon as that name goes out of scope
07:17:32 <quicksilver> eight
07:17:33 <quicksilver> right
07:17:41 <quicksilver> not quite "as soon as"
07:17:44 <quicksilver> more like "some time after"
07:17:46 <quicksilver> but yes
07:17:56 <EvilTerran> okay, "no longer accessible..."
07:18:15 <EvilTerran> as in, if i moved my factList inside a where{} clause, it'd be useless again
07:18:52 <quicksilver> yes
07:19:09 <hkBst> ghc seems to memoize both, but as `limit' is useless anyway I'll eliminate it
07:23:20 <EvilTerran> anyone remember -- how does Data.Map behave when given infinite data structures?
07:23:28 <quicksilver> poorly
07:24:26 <EvilTerran> okay, it wouldn't really be appropriate here then
07:25:04 <quicksilver> depends on your performance characteristics
07:25:12 <quicksilver> you can certainly use a Map to memoise
07:25:25 <quicksilver> because, after all, only finitely many will be accessed in a given program run
07:25:29 <quicksilver> you just memoise those ones
07:25:47 <quicksilver> whether it's worth it depends how often you expect to get repeat queries
07:26:16 * EvilTerran notes that (fromDistinctAscList . zip [1..] . scanl (*) 1 [1..]) ! 0 appears to run forever
07:26:31 <aleator> Known or new: internal error: interpretBCO: unknown or unimplemented opcode 8637    (GHC version 6.6.1 for i386_unknown_linux
07:26:34 <EvilTerran> s/[1..])/$ [0..])/, rather
07:26:59 <dino-> > take 10 $ map (+ 1) [1..]
07:27:08 <EvilTerran> no bot
07:27:16 <EvilTerran> no dons, either
07:27:34 <twanvl> It has to, Data.Map uses a balanced tree, which can not be infinite for infinte data (unless it is in a finite range)
07:27:37 <quicksilver> EvilTerran: yes, maps are strict in their 'spine'
07:27:39 <dino-> (from ghci) Prelude> take 10 $ map (+ 1) [1..]
07:27:41 <dino-> [2,3,4,5,6,7,8,9,10,11]
07:28:07 <dino-> dons still in bed :D
07:28:36 <EvilTerran> quite. are there any structures with O(log n) amortized access that work for infinite maps integral->a?
07:28:55 <shapr> @localtime dons
07:28:58 <shapr> @localtime shapr
07:29:00 <shapr> hmm
07:29:06 <shapr> lambdabot: @botsnack
07:29:14 <EvilTerran> yeah, that's why we're trying to contact him, shapr
07:29:18 <shapr> I see
07:29:21 <EvilTerran> i've left a message with memoserv
07:30:10 <EvilTerran> (that is, O(log n) where n is either the index of each lookup or the largest index you're going to use in the program - which you presumably don't know beforehand, otherwise you could use a finite map)
07:31:55 <quicksilver> EvilTerran: it's not a problem to make lazy-infinite trees
07:32:02 <quicksilver> EvilTerran: it *is* a problem to balance them ;-.
07:32:04 <twanvl> EvilTerran: Tries
07:32:05 <quicksilver> ;-/
07:32:33 <EvilTerran> twanvl, yeah, that could work
07:33:09 <EvilTerran> you could also do something with [Array Integer a], where each array in the list is twice as long as the one before...
07:33:22 <quicksilver> yes
07:33:29 <twanvl> data IntTrie a = Trie { value :: a, t2n :: IntTrie a, t2n1 :: IntTrie a }
07:33:30 <quicksilver> but that's not very efficiently sparse
07:33:39 <quicksilver> arrays are strict in their spines too
07:33:42 <EvilTerran> mmmhmm
07:33:44 <vincenz> @bot
07:33:44 <oasisbot> :)
07:33:46 <b_jonas> infinite maps?
07:34:03 <b_jonas> I agree with tries, yes
07:34:34 <EvilTerran> do we have a trie module?
07:34:38 <b_jonas> or if it's very sparse and has really big Integers as keys, then you can use a patricia tree I think, but I'm not sure if that would work
07:34:48 <EvilTerran> there's a thought
07:34:53 * EvilTerran goes to see if Data.IntMap'll work
07:35:08 <b_jonas> how would you generate the data for such a tree?
07:35:11 <twanvl> There is no way to define a general Trie type in haskell
07:35:52 <EvilTerran> b_jonas, lazily!
07:35:55 <opqdonut> btw what's @ in the -ddump-simpl output?
07:36:12 <b_jonas> well, quicksilver is right in that unmodified balanced trees like b-trees or treaps or red-black-trees wouldn't work
07:36:19 <b_jonas> EvilTerran: sure, but I mean
07:36:26 <b_jonas> in increasing order by keys?
07:36:34 <EvilTerran> that's what i was thinking, ye
07:36:34 <twanvl> @ is type application
07:36:54 <opqdonut> ?
07:36:54 <b_jonas> or do you just have a function that cen give the value for any key?
07:36:56 <EvilTerran> that's why I was using fromDistinctAscList in my Data.Map attempt
07:37:08 <quicksilver> b_jonas: yes, but it's slow
07:37:12 <quicksilver> b_jonas: and he's trying to memoize it
07:37:14 <opqdonut> twanvl: so it's kid of like asTypeOf?
07:37:35 <b_jonas> you could also use an infinite sequence of trees, for each order of magnitude
07:37:36 <quicksilver> b_jonas: he's tring to lazily but efficiently memoize f : Integer -> Integer (say)
07:38:00 <b_jonas> that would still be log(n) size because you find the right tree in the list in log(n) time and each tree is of log(n) size
07:38:07 <twanvl> You can read it that way. GHC core is based on System F, where types are handled explicitly.
07:38:28 <EvilTerran> I suggested using a list of arrays, each doubling in size, likewise
07:38:47 <b_jonas> or, you might want to just use a normal finite tree but modify it every time
07:38:57 <b_jonas> so it only ever has a finite number of values
07:39:01 <EvilTerran> a list of trees would've better sparseness, i guess
07:39:03 <opqdonut> twanvl: ok
07:39:18 <EvilTerran> something unsafePerformIO-flavoured?
07:39:25 <b_jonas> I think if the generation of values is slow, that might be better than trying to generate the tree at once
07:39:40 <b_jonas> because you might have to calculate lots of values forward to know the shape of the tree
07:39:41 <yaarg> hello people!
07:39:44 <opqdonut> twanvl: can i get ghc to output some intermediate state in something that resembles haskell?
07:39:48 <opqdonut> oh hi yaarg
07:40:04 <twanvl> no, this is the intermediate stage
07:40:09 <drigz_> @hoogle mod :: Real
07:40:09 <oasisbot> hoogle: Hoogle.Parser.readType: ([mod,::,Real],BItem ::)
07:40:10 <oasisbot>  
07:40:13 <b_jonas> but if you just insert new values to a tree (or non-tree mapping), you only need to calculate as many values as you need
07:40:33 <quicksilver> opqdonut: it does "resemble" haskell :)
07:40:36 <quicksilver> opqdonut: it just isn't
07:40:36 <drigz_> web hoogle breaks if you use ::
07:40:43 <b_jonas> however, if the set of values you want to cache is dense, then an infinite trie is the way to go I think
07:40:54 <drigz_> @seen ndm
07:40:55 <oasisbot> ndm is in #haskell. I don't know when ndm last spoke.
07:41:05 <opqdonut> quicksilver: yeah okay it resembles
07:41:09 <EvilTerran> hm. my virus scanner was using 450MB of RAM a little while ago. that bothers me.
07:41:11 <opqdonut> i'm just having a hard time reading it
07:41:27 <ndm> @seen drigz_
07:41:27 <oasisbot> drigz_ is in #haskell. I last heard drigz_ speak 33s ago.
07:41:33 <EvilTerran> i'm gonna have to restart, everything's horribly lagged up
07:41:34 <drigz_> EvilTerran: think, all the ram it is using can't contain a virus. it's just another safety measure
07:41:44 <quicksilver> opqdonut: maybe you should ask "can I get opqdonut to input something that resembles haskell core?"
07:41:45 <EvilTerran> yay for rubbish OS memory management!
07:41:59 <ndm> drigz_: that bug will be fixed in the new version of Hoogle, I've fixed that, just have a bit more to do and it will all be sorted
07:42:06 <opqdonut> quicksilver: :D yeah that'd solve the problem too
07:42:21 <opqdonut> but i'm afraid that question isn't so easy to answer
07:42:29 <drigz_> ndm: can't wait :D
07:42:35 <opqdonut> (pointers for reading core are welcome)
07:42:39 <pejo> EvilTerran, atleast under unix it's quite common that even if you free() memory, libc doesn't return it to the OS.
07:42:58 <drigz_> ndm: will it do what i wanted, i.e. check name for mod and type for Real?
07:43:16 <ndm> drigz_: it will take about a week, once i get a week free - i'm hoping for Christmas
07:43:32 <ndm> drigz_: you'd have to type mod :: Real -> Real -> Real
07:43:45 <ndm> but yes, it will search by name and by type at the same time
07:45:45 <glen_quagmire> > (1.0 :: Float) + 0.00000001
07:45:47 <oasisbot>  1.0
07:45:49 <glen_quagmire> (1.0 :: Float) + 0.0000001
07:45:56 <glen_quagmire> > (1.0 :: Float) + 0.0000001
07:45:57 <oasisbot>  1.0000001
07:46:28 <drigz_> ndm: sounds superb, keep up the good work
07:46:34 <ndm> will do :)
07:46:46 <glen_quagmire> how should I explain that behavior? why 8 decimal digits?
07:47:09 <glen_quagmire> for single precision, exponent is 8 bits and fraction is 23 bits
07:47:19 <drigz_> > 2 ^ 23
07:47:20 <oasisbot>  8388608
07:47:31 <drigz_> that's about 10 digits :p
07:48:05 <glen_quagmire> > log (2^23)
07:48:06 <oasisbot>  15.942385152878742
07:48:07 <quicksilver> > ln (2^23)
07:48:07 <drigz_> > ((1.0 :: Float) + 0.00000001) - 1.0
07:48:07 <oasisbot>   Not in scope: `ln'
07:48:08 <oasisbot>  0.0
07:48:17 <quicksilver> > log (2^23) / log (10)
07:48:18 <oasisbot>  6.923689900271567
07:48:27 <quicksilver> glen_quagmire: it's actually more like 7 digits
07:48:30 <quicksilver> glen_quagmire: apparently :)
07:48:40 <Saizan> ?docs Foreign.Marshal
07:48:40 <oasisbot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal.html
07:48:48 <glen_quagmire> > (1.0 :: Float) + 0.9999999
07:48:49 <oasisbot>  1.9999999
07:49:45 <drigz_> > 1.0 / (2.0 ^ 23)
07:49:46 <oasisbot>  1.1920928955078125e-7
07:50:06 <drigz_> that is the smallest number you can represent with the mantissa
07:50:25 <drigz_> which is about 0.0000001
07:50:31 <glen_quagmire> oh?
07:50:39 <shapr> IEEE 754, yeah?
07:50:48 <shapr> The reason Ratio exists...
07:50:51 <drigz_> > 0.0000001
07:50:52 <oasisbot>  1.0e-7
07:51:08 <glen_quagmire> but in IEEE754, things are denormalized right?
07:51:21 <drigz_> glen_quagmire: they're normalized most of the time
07:51:33 <drigz_> if the number is really small, it will be denormalised, but that doesn't apply to this case
07:51:55 <glen_quagmire> oh maybe it's because leading 1 in 1.0 ?
07:52:05 <glen_quagmire> > (0.0 :: Float) + 0.00000001
07:52:06 <oasisbot>  1.0e-8
07:52:54 <drigz_> so you're adding 1.(23 0s) * (2 ^ 0) + (approx) 1.(23 0s) * (2 ^ -23)
07:53:02 <drigz_> and you get 1.(22 0s)1 * (2 ^ 0)
07:53:14 <glen_quagmire> > (0.0 :: Float) + 0.0000000000000000000000000000000000001
07:53:15 <oasisbot>  1.0e-37
07:53:32 <drigz_> glen_quagmir(0.0 +) = id
07:53:36 <glen_quagmire> > (0.0 :: Float) + 0.000000000000000000000000000000000000000000001
07:53:37 <oasisbot>  1.0e-45
07:53:54 <drigz_> glen_quagmire: that's probably denormalised
07:53:55 <glen_quagmire> oh
07:54:13 <drigz_> the issue is that because the answer is about 1, it means that the exponent will be
07:54:16 <drigz_> 0
07:54:45 <glen_quagmire> (0.0 +) is really just id ?
07:54:57 <osfameron> for Floats
07:55:06 <drigz_> glen_quagmire: maybe ghc doesn't know, but the addition function will check at the start
07:55:07 <glen_quagmire> or are they different computation but semantically same?
07:55:13 <drigz_> if a == 0 then b
07:55:21 <puusorsa> maybe it's just nothing
07:55:21 <glen_quagmire> oh i see
07:55:33 <quicksilver> glen_quagmire: if you go via C then I'm sure 0.0 + will be optimised out
07:55:39 <drigz_> glen_quagmire: the spec says that (0.0+) = id
07:55:42 <quicksilver> glen_quagmire: gcc is fairly agressive with numerical optimisations
07:55:49 <puusorsa> hooray!
07:55:52 <glen_quagmire> drigz_: where can I find the spec?
07:55:56 <quicksilver> ghc's ntive code gen might well generate a floating point op
07:56:04 <glen_quagmire> 98 report?
07:56:09 <drigz_> glen_quagmire: i remember it took me a long time, they hide it
07:56:41 <drigz_> but if you are interested, you should read http://docs.sun.com/source/806-3568/ncg_goldberg.html
07:56:48 <drigz_> or at least relevant parts, it's pretty long :p
07:56:52 <drigz_> oasisbot...
07:56:56 <drigz_> tell the man the title
07:57:04 <olsner> @bot
07:57:04 <oasisbot> :)
07:57:11 <drigz_> ok, since the bot is being lazy, it's called What Every Computer Scientist Should Know About Floating-Point Arithmetic
07:57:12 <glen_quagmire> yah i gave up on that doc
07:57:17 <glen_quagmire> i'll retry
07:57:27 <drigz_> it has a lot more than the actual spec
07:57:36 <drigz_> or you can find a software implementation and read that :)
07:57:48 <puusorsa> the source is the documentation!
07:57:54 <puusorsa> it has comments, doesnt it? :)
07:58:01 <drigz_> probably not
07:58:06 <drigz_> :)
07:58:39 <drigz_> software float libs tend to be written for embedded systems, and people don't comment embedded code because you can't afford the space :p
07:58:49 <puusorsa> oh, right.
07:58:58 <puusorsa> that makes sense!
07:59:05 <quicksilver> now, if only we had a system whereby the code was translated before execution
07:59:09 <drigz_> it depends who it was written by
07:59:13 <quicksilver> then that translation could remove the comments...
07:59:19 <quicksilver> we could call it 'compilation'!
08:00:07 <olsner> or compression
08:02:37 <phobes> @unpl \x -> f x
08:02:37 <oasisbot> \ x -> f x
08:02:44 <phobes> @pl \x -> f x
08:02:44 <oasisbot> f
08:02:52 <phobes> @pl \f -> f x
08:02:53 <oasisbot> ($ x)
08:06:41 <hpaste>  twanvl pasted "Memoizing Integers, if anyone is still interested" at http://hpaste.org/2780
08:06:47 <nomeata> Hi. Im considering to write a web app with haskell. What are my options if I want the data storage to be take care of by some haskell library?
08:06:59 <dino-> nomeata: HAppS!
08:07:00 <nomeata> I found HApps, but I wonder what else there is.
08:07:33 <nomeata> Or is HApps the way to go and the best thing around? :-)
08:07:38 <Saizan> wash? fastcgi?
08:07:55 <nomeata> Saizan: do they help me with data storage?
08:07:56 <shapr> I  like HAppS.
08:08:14 <dino-> What's the deal with those, you basically figure out storage yourself. Which could be SQL db?
08:08:18 <sjanssen> shapr is, of course, not biased at all :)
08:08:18 <Saizan> nomeata: i don't think so
08:08:21 <shapr> nomeata: At the moment, HAppS serializes via Read/Show, XML, or Binary.
08:08:22 <nomeata> HApps doesnt make a great impression, dead links from the main page (http://happs.org/auto/apidoc-0.8.8/index.html)...
08:08:26 <dylan> fastcgi + some other bits (Text.XHtml, for instance).
08:08:33 <quicksilver> nomeata: I'm of the impression that only HAppS has the total data storage tie-up thing
08:08:36 <shapr> nomeata: I'm biased, HAppS is my full-time job :-)
08:09:01 <nomeata> dino-: SQL is quite a bit of hassle, converting to and from haskell and catching all the errors and stuff...
08:09:14 <quicksilver> nomeata: Wash has/had some kind of automatically transactional SQL link but I think wash might be slightly abandonware
08:09:15 <shapr> nomeata: The front page will be updated really soon, there's a new webpage that's nearly ready, and the new code is nearly ready for public announce.
08:09:20 <dino-> nomeata: I think this is generally the bitch about SQL from everywhere, not just Haskell.
08:09:55 <nomeata> shapr: sounds good. What happens with my stored state if I upgrade from one version to another of my code, changing the type. Can I specify a conversion function?
08:10:07 <Saizan> yes
08:10:55 <puusorsa> somehow having all the data in some sql db would seem safer
08:11:13 * dylan realls like living inside postgresql.
08:11:16 <dino-> This migration issue is supposed to addressed to some degree with the newer happs 0.9.x, right?
08:11:19 <dylan> *really.
08:12:28 <Saizan> dino-: there are migration examples in HAppS-Begin
08:13:01 <earthy> whoa...
08:13:23 <dino-> puusorsa: Some co-workers and I built an experimental service for work recently. I was unable to corrupt the data even beating the shit out of it with kill -9's and things during heavy data insert/retrieval.
08:13:28 <dino-> It was impressive.
08:13:29 <earthy> here I am, just reading up parts of the Java Language Spec to be more authorative when teaching Java to newbies tomorrow
08:13:38 <earthy> and I run into a ref to TaPL... :)
08:13:45 <dino-> ^ with happs, I mean
08:14:21 <hkBst> earthy: this http://www.cis.upenn.edu/~bcpierce/tapl/ tapl?
08:14:22 <nomeata> so I guess HAppS is what I want... Anything else to read besides the tutorial?
08:14:22 <oasisbot> Title: Types and Programming Languages
08:14:31 <earthy> hkBst: that tapl. :)
08:15:42 <Saizan> nomeata: i don't think there's a 0.9.x tutorial, yet
08:15:54 <dino-> I'm planning on using 0.9.1 for any further work as it's the future. Hopefully will have time this week to continue going through the page for that: http://happs.org/HAppS/HAppS-Begin/public/
08:15:54 <oasisbot> Title: How To Make a blog using HappS
08:16:13 <dino-> We can all maybe help each other out.
08:16:17 <nomeata> so should I not use 0.8.8?
08:16:52 * olsner should read tapl some day
08:16:57 <dino-> shapr: I should probably edit that 0.9.1 page with dep installation order and whatever else comes up. You guys accept some docs input?
08:19:06 <dino-> nomeata: It's all in a state of extreme new-ness, but it really is amazing when you see the happs doing its thing.
08:19:28 <puusorsa> hooray!
08:19:46 <puusorsa> still, if any other app needs that same data, what then?
08:20:07 <dino-> puusorsa: Could write an http handler to feed the data back to whomever is asking for it.
08:20:15 <dino-> In some format that the other side would like to see.
08:20:17 <puusorsa> hhm, true
08:20:19 <nomeata> dino-: I dont mind beta-quality as long as it, for the most part, works.
08:20:28 <puusorsa> ok maybe sql is obsolete :)
08:21:08 <dino-> nomeata: Well, I can't speak about 0.9.1 yet, only just starting out with it. But it's where some of the important newer developments are getting done now like data migration and scalability.
08:21:43 <nomeata> but when I do it in 0.8.8 now, I wont have to comletely rewrite the app for 0.9.1, will I?
08:21:55 <dino-> shapr? Can you answer that better?
08:22:19 <hkBst> earthy: maybe write something about TaPL? http://en.wikipedia.org/wiki/Types_and_Programming_Languages
08:22:45 <alexj> I didn't see the original question but the general answer is yes, you will have to do substantial rewrite to switch from 0.8.8 to 0.9.1 of happs.
08:23:08 <alexj> we hope to be doing an actual release of 0.9.1this week maybe even today.
08:23:09 <dino-> I had read something good about types and PLs recently.. http://cdsmith.twu.net/types.html
08:23:10 <oasisbot> Title: What To Know Before Debating Type Systems
08:23:35 <nomeata> alexj: a stable release?
08:24:05 <alexj> its 0.9.1 not 1.0 but yes.  no major api changes in the forseeablye future.
08:24:18 <alexj> the main thing to be added next will be sharding.
08:24:40 <nomeata> ok, so for a newcomer to experiment, 0.9.1 is the version to try.
08:26:35 <dino-> alexj: I keep trying to send people to read the stuff you have at the end of the older happs page http://happs.org/HAppS/  discussing hypothetical numbers with 50M users and 1k of data, etc..
08:26:37 <oasisbot> Title: HAppS -- Haskell Application Server (version 0.8.8 )
08:27:01 <dino-> I think the natural tendency is to freak out about the RAM storage.
08:27:38 <dino-> You tell people maybe SQL isn't always necessary and it's admitting you're a baby-killer.
08:27:46 <dino-> it's like admitting
08:28:02 <puusorsa> what's wrong with killing babies?
08:28:15 <alexj> dino: yes, I've been meaing to write about that at some point.  But here is the short version: real life web apps can't afford to pay a 9ms of throughput for each access.
08:28:36 <alexj> so real life web apps kep their databases substantially in RAM anyway.  e.g. memcache.
08:28:51 <dino-> And lots of replication
08:28:52 <alexj> happs is just taking that idea to its logical conclusion.
08:30:05 <alexj> the happs bet is that 3 copies of ram is cheaper than the number of replocated disks plus programmer + ops you need for a highly active web site.
08:31:04 <alexj> replicated disks are a major maintenance headache as they have a high MTBF.  programmers now have more coding complexity in dealing with data that is replicated in ram and on multiple disks.
08:31:21 <quicksilver> 'high MTBF' ?
08:31:40 <alexj> mean time between failure.  moving mechanical parts fail much faster than solid state electronics.
08:31:47 <quicksilver> right
08:31:51 <quicksilver> so you meant "low MTBF" ?
08:31:57 <coffeemug> I wonder what the size of an average medium-high traffic website database is
08:32:07 <alexj> yes low MTBF.  high failure rate.
08:32:12 <quicksilver> :)
08:32:24 <coffeemug> I bet most of them are lower than a gig
08:32:32 <quicksilver> coffeemug: the median is certainly 1 or 2 machines, few 100 meg
08:32:38 <coffeemug> though I've known for being wrong before :)
08:32:39 <quicksilver> coffeemug: the average would be hard to even guess at
08:32:47 <quicksilver> coffeemug: very very one-tailed distribution
08:33:13 <quicksilver> coffeemug: with Google at one stupid tip of the tail, and sites like online casinos pretty far down the tail
08:33:26 <coffeemug> eh
08:33:29 <quicksilver> (oline casiones have 100s of servers and TB of data)
08:33:35 <coffeemug> online casinos don't interest me, frankly :)
08:33:46 <coffeemug> TB of data?
08:33:49 <quicksilver> they're pretty interesting from an engineering perspective
08:33:53 <coffeemug> wtf do they store
08:34:00 <quicksilver> coffeemug: they collect every bet in every hand
08:34:14 <coffeemug> hmm
08:34:15 <quicksilver> coffeemug: and run 1000s of hands simultaneously 24/7
08:34:22 <coffeemug> yes
08:34:23 <quicksilver> every bet, every turn of every card, is recorded
08:34:28 <coffeemug> but that data is mostly historical
08:34:30 <vincenz> it's a log file tho
08:34:32 <quicksilver> true
08:34:39 * vincenz says the same as coffeemug 
08:34:49 <coffeemug> what they need at any given point is the state of the current game
08:34:55 <quicksilver> (games)
08:34:57 <quicksilver> true
08:34:59 <coffeemug> right
08:35:04 <coffeemug> and that isn't that much information
08:35:05 <quicksilver> and the state of the players
08:35:12 <quicksilver> and the chat rooms, and the tournaments
08:35:20 <vincenz> still not a lot
08:35:23 <quicksilver> it's not *that* much, no, but it might be a bit more than you'd guess
08:35:43 <vincenz> assume 10k people playing, so you need their money: 1 int, their cards in a game : let's say worst-case really-bad-boundary of 10 cards...
08:35:46 <coffeemug> I'm a big proponent of keeping data in RAM
08:35:51 <coffeemug> and just having a log file
08:36:00 <vincenz> 1 int + 10 bytes = 14, rounded, 16bytes/person
08:36:00 <quicksilver> oh yes, I think alexj's arguments are good ones
08:36:16 <coffeemug> vincenz: that's a very conservative estimate :)
08:36:21 <Saul_> I'm having some problems with the module system :(
08:36:23 <quicksilver> vincenz: betting subdivided by rounds, timeout counters, side-pots
08:36:25 <coffeemug> vincenz: you also need to store the nickname
08:36:26 <vincenz> then the chat-text ain't much, just look at irc
08:36:34 <vincenz> fine, 100bytes per person
08:36:37 <quicksilver> Saul_: what kind of problems?
08:36:38 <sjanssen> Saul_: what's going wrong?
08:36:38 <vincenz> that's still < 1MB
08:36:46 <Saul_> Basically if I put everything in one file it's working fine
08:36:58 <Saul_> But if I split it up I get a bunch of errors
08:37:12 <sjanssen> Saul_: we'll need more details to help you ;)
08:37:19 <Saul_> The main problem being making an instance of a class in another file
08:37:27 <quicksilver> Saul_: start each file with module Foo where ...
08:37:36 <quicksilver> and everything will be exported by default
08:37:41 <Saul_> I have
08:37:42 <quicksilver> and import all the Foos from the other files that need them
08:37:51 <quicksilver> make sure the filename matches the module name
08:38:49 <Saul_> I have done all that, but still I can't make instances of the class
08:38:52 <Saul_> Could not deduce (Field a1 a)
08:38:52 <Saul_>       from the context (Field (TextField a) a, Read a, Show a)
08:38:52 <Saul_>       arising from use of `defaultCheck' at DefaultFields.hs:15:24-35
08:38:52 <Saul_>     Possible fix:
08:38:52 <Saul_>       add (Field a1 a) to the class or instance method `check'
08:38:53 <Saul_>     In the first argument of `processValue', namely `defaultCheck'
08:38:57 <Saul_>     In the expression: processValue defaultCheck
08:38:59 <Saul_>     In the definition of `check': check _ = processValue defaultCheck
08:39:40 <sjanssen> I don't think that is an error with the module system
08:39:50 <sjanssen> Saul_: perhaps you made a copy-paste-o?
08:40:15 <Saul_> sjanssen: Maybe, but I doubt it
08:41:54 <Saul_> If I cut-paste the instance declaration from one file to the other (with the class declaration) it works perfectly
08:42:39 <Saul_> even though the class with the type declaration doesn't even know the function that is going wrong
08:43:54 <sjanssen> Saul_: which module is producing the error?
08:43:56 <Saul_> oh wait, I forgot to save
08:44:19 <Saul_> Now it is bitching that it doesn't know the function
08:44:35 <sjanssen> you probably need to import it from somewhere
08:44:43 <Saul_> the importing file (which is where the instance declaration is)
08:46:16 <Saul_> sjanssen: Yeah it can't find the function because it's in the parent file, and I've tried to move the instance declaration to the child
08:47:05 <sjanssen> you need to add "import Parent" inside the Child module
08:47:08 <Saul_> But if I put the instance declaration in the parent file (with the class declaration in the child), I get the error I pasted above
08:47:36 <Saul_> But I want the instance declaration in the parent, not in the child
08:47:42 <Saizan> if i've struct Foo { .. char str[LEN]; ..}, can i read that str with a get hook? with {#get Foo->str #} f >>= peekCString i get a segfault because it's treating it like char * str
08:47:47 <sjanssen> are other instances defined in other modules?
08:48:03 <Saul_> no
08:48:22 <sjanssen> Saul_: the error message you pasted is not related to modules, you must have some other mistake
08:48:43 <Saul_> hmmz
08:49:16 <Saul_> I'll put my files somewhere, maybe it's clearer then
08:49:20 <coffeemug> man, I wish I were born 20 years
08:49:29 <coffeemug> then I could go to grad school and work on Lisp/Scheme
08:49:34 <coffeemug> those days were awesome :)
08:49:46 <dino-> coffeemug: FP is back, baby!
08:49:50 <coffeemug> err
08:49:56 <coffeemug> I mean I wish I were born 40 years ago
08:50:00 <coffeemug> then 20 years ago I'd be 20
08:50:07 <coffeemug> and would be able to go to grad school :)
08:50:14 <coffeemug> dino-: it is and it isn't :)
08:50:21 <coffeemug> there aren't very many groups working on it
08:50:45 <coffeemug> perhaps in EU/AU
08:50:47 <coffeemug> but not US
08:50:54 * byorgey has sadly noticed this while applying to grad schools =(
08:51:22 <coffeemug> byorgey: are you going for PhD or MS?
08:52:04 <byorgey> coffeemug: PhD.
08:52:35 <byorgey> coffeemug: are you applying now too?
08:52:51 <coffeemug> byorgey: I am considering it
08:52:59 <coffeemug> byorgey: I have a fairly peculiar situation
08:53:04 <coffeemug> I had low grades in undergrad
08:53:08 <earthy> coffeemug: and the problem with moving to EU for graduate studies is?
08:53:19 <therp> a bit off-topic, how much do you charge (per hour let's say; before taxes) when you don't find any Haskell related work, still very skilled and educated, but when you are offered to work on .NET code. high-level moderate interesting stuff, no code monkey GUI building.
08:53:21 <coffeemug> so it's hard for me to apply to good schols
08:53:29 <coffeemug> earthy: family situation
08:53:29 <byorgey> coffeemug: ah, I see
08:53:57 <therp> to start with a number. 50EUR/h is what a college of mine charges for his python web development stuff..
08:54:07 <earthy> coffeemug: OGI still does quite a bit with functional programming
08:54:16 <coffeemug> therp: I'd say around $80/hour
08:54:19 <earthy> (they're in Portland, Oregon)
08:54:34 <earthy> therp: that *really* depends on your taxation situation
08:54:35 <coffeemug> earthy: yeah
08:54:41 <byorgey> coffeemug: I think schools will still consider you if you have good test scores and show strong interest/promise in research
08:54:52 <earthy> strong interest/promise really really helps yeah
08:54:57 <coffeemug> byorgey: which schools are you applying to?
08:54:58 <therp> coffemug: you are from the US, right?
08:55:00 <Saul_> sjanssen: http://www.dysfunctionalprogramming.org/Field.hs http://www.dysfunctionalprogramming.org/CustomizationFunctions.hs http://www.dysfunctionalprogramming.org/DefaultFields.hs
08:55:07 <coffeemug> therp: I'm in US right now :)
08:55:08 <therp> earthy: before taxes, I'd say.
08:55:23 <Saul_> sjanssen: The last file is supposed to be the parent
08:55:24 <therp> earthy: kinda business-to-business price.
08:55:38 <coffeemug> moving to EU for grad school would have been awesome
08:55:48 <earthy> in .nl I'd charge between EUR 75 and EUR 100 / hour then
08:56:12 <earthy> probably more on the order of EUR 100, if it really is involved stuff.
08:56:37 <coffeemug> it also depends on the duration of the project
08:56:42 <byorgey> coffeemug: I haven't firmly decided yet, probably PSU, Yale, MIT, CMU, UMD, maybe a few others
08:56:47 <sjanssen> Saul_: DefaultFields should be a parent of all the other modules?
08:56:54 <earthy> simple code monkeying already gets EUR 60 to 70/hour
08:56:58 <therp> earthy: yes, they were talking about custom VB4 code translations to VB5. so building a kinda parser/compiler with VB5 as target
08:57:00 <coffeemug> you'd normally charge more for shorter projects as you have overhead of looking
08:57:13 <Saul_> sjanssen: Well it uses code of both of those modules
08:57:19 <earthy> therp: that sounds like the 'run away' type of project
08:57:28 <coffeemug> byorgey: do you contact professors first, or do you just apply?
08:57:55 <earthy> plus, VB4? VB5? isn't that like ages old?
08:57:56 <Saul_> sjanssen: Maybe my whole modulization scheme is faulty
08:58:06 <byorgey> coffeemug: I've contacted a few, but it depends.  Some professors on their website specifically say "don't contact me, just mention me in your personal statement and I'll get to read your app."
08:58:21 <therp> earthy: I'll add a markup for extra ugliness :).. and also if I don't get freshly squeezed orange juice at my workplace (as I would at Google, not that they offered my a job, but .. :))
08:58:30 * earthy grins
08:58:33 <byorgey> especially those from bigger schools who probably get lots of e-mail
08:58:43 <phobes> @instances Monad
08:58:43 <oasisbot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:58:52 <earthy> byorgey: also depends on if you want to go for a PhD or a master's
08:59:01 <earthy> if you want to go for a master's I'd say just apply
08:59:12 <therp> earthy: but the problem is there are rarely other projects around here..
08:59:15 <byorgey> earthy: yes, that's true.
08:59:25 <earthy> if you want to go for a PhD, politely inquire at the graduate office of a university if there's a professor willing to talk to you
08:59:32 <earthy> unless you're in .nl
08:59:46 <earthy> (or large parts of .eu anyway)
09:00:01 <earthy> in which case phd positions tend to be much like jobs and you apply as you would for a job
09:00:16 <earthy> therp: ya. that's Teh Suck
09:00:31 <sjanssen> Saul_: okay, the reason you can't move the instance from DefaultFields to Field is because you use things from CustomizationFunctions
09:01:03 <sjanssen> Saul_: do you see why that is the case?
09:01:09 <Saul_> sjanssen: No
09:01:27 <sjanssen> Saul_: check _ = processValue defaultCheck
09:01:36 <sjanssen> processValue is defined in CustomizationFunctions
09:01:49 <sjanssen> Field.hs does not import CustomizationFunctions
09:01:57 <coffeemug> well, masters is easy
09:01:59 <coffeemug> you just apply
09:01:59 <sjanssen> Saul_: make sense now?
09:02:12 <Saul_> sjanssen: a little :)
09:02:33 <sjanssen> Saul_: on the off chance, are you trying to treat modules/imports as C #includes?
09:02:39 <phobes> Does anyone know anything about   (a -> P) -> P  as an instance of Monad?  (a is the Monad value type, P is any other type)
09:02:53 <Saul_> sjanssen: I've never really used C
09:04:15 <nomeata> Im having trouble with the sample app in http://happs.org/HAppS/HAppS-Begin: When I start it, I can for example read the index file via http://localhost:8000/series. But once I enter an invalid url, it seems, I always get back the stderr output of SearchPath...
09:04:25 <balodja> phobes: that's continuation monad
09:04:32 <Saul_> sjanssen: It's always something I seem to have trouble with though, in any language
09:04:51 <nomeata> ah, I always get back the content of public/log
09:04:57 <quicksilver> phobes: it's often called the CPS monad, I believe
09:04:57 <Saul_> sjanssen: I've used php a while (shame on me), so I guess I still have that in my head
09:05:03 <nomeata> which seems to be the error handler...
09:05:10 <quicksilver> phobes: google for 'CPS Monad' some of the hits look like good papers
09:05:11 <phobes> balodja, quicksilver, thanks
09:05:18 <sjanssen> Saul_: ah, I bet PHP's module system works much like C includes
09:05:54 <balodja> phobes: http://www.haskell.org/all_about_monads/html/contmonad.html
09:05:55 <oasisbot> Title: The Continuation monad
09:06:04 <sjanssen> Saul_: in Haskell, a module is a set of declarations (types, functions, classes, instances) which are exported
09:06:08 <Saul_> sjanssen: To call it a module system is giving it too much praise, it just inserts the code of the imported file and then compiles everything
09:06:30 <sjanssen> Saul_: exactly -- Haskell's system is totally different
09:07:13 <sjanssen> Saul_: other modules use an import statement to bring names defined in other modules in to scope
09:08:34 <Saul_> sjanssen: So you can have two files that import eachother?
09:08:54 <Saul_> sjanssen: Or is that bad practice?
09:08:56 <sjanssen> so when we've got "processValue defaultCheck" inside the Field module, and processValue is defined in a module (CustomizationFunctions) that isn't imported inside the Field module, we get a scoping error
09:09:24 <olsner> I don't think even haskell can resolve circular dependencies...
09:09:33 <sjanssen> Saul_: technically yes, but GHC doesn't support cyclic modules very well so it's a big PITA
09:09:59 <sjanssen> olsner: Haskell can, the implementations that exist today can't :)
09:11:05 <Saul_> sjanssen: So do you have any suggestions for me?
09:11:13 <olsner> why not just outright disallow circular dependencies?
09:12:05 <byorgey> olsner: why should circular dependencies between functions in the same module be allowed, but between functions in different modules disallowed?
09:12:27 <sjanssen> Saul_: I combined your modules into one but I still get the same error
09:12:45 <byorgey> IMO, disallowing circular dependencies seems to go against the spirit of Haskell.
09:13:04 <sjanssen> Saul_: my suggestion is to figure out what you changed while splitting it into modules, then fix that :)
09:13:29 <Saul_> sjanssen: I'll try that :)
09:14:20 <nomeata> hmm. Now, when I try http://localhost:8000/blog/entryForm and enter something, I get Server error: resType, but no idea whats wrong...
09:15:02 <Saul_> sjanssen: Hmmz I also get the same error :S
09:15:20 <Saul_> sjanssen: I guess I will need to do some debugging then
09:16:34 <olsner> since it evidently was hard enough/underspecified enough/not useful enough to actually be implemented, I'm getting scepticism from all sensors.. not to say that it actually is a bad idea
09:19:59 <oerjan> mostly it specified as simply merging the files. but there is at least one underspecified exception.  what happens if the monomorphism restriction kicks in with a module-crossing binding group, especially if they have different default declarations...
09:20:11 <oerjan> *it is specified
09:20:25 <Saul_> sjanssen: Okay I found the error
09:20:43 <olsner> module-crossing binding group?
09:20:56 <Saul_> sjanssen: I restricted my function too much, it didn't need (Field a b) at all
09:21:00 <oerjan> mutually cyclic definitions.
09:21:33 <oerjan> mutually recursive, even.
09:21:41 <Saizan> olsner: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
09:21:42 <oasisbot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
09:22:29 <oerjan> i am not talking about what ghc does, but about what the report doesn't specify even for a perfect implementation.
09:23:56 <Saul_> sjanssen: Okay it works perfectly now (in one file), thanks for your help
09:27:28 * earthy laughs
09:27:31 <Saul_> sjanssen: It works in multiple files as well, you were right, it's not a moduling problem
09:27:37 <earthy> 'Elsevier is committed to publishing your article as quickly as possible'
09:27:40 <Saul_> sjanssen: Thanks again for your help
09:27:42 <Saizan> ?seen dcoutts
09:27:42 <oasisbot> dcoutts is in #haskell. I don't know when dcoutts last spoke.
09:27:49 <sjanssen> Saul_: no problem
09:27:50 <earthy> that's for an article written and presented in november 2005...
09:27:56 <earthy> (oktober, even)
09:30:41 <phobes> Anyone know of any work that's been done on using continuations as an alternative to Monads?
09:31:39 <flux> hmm.. isn't continuations the old io framework for haskell, and monads the new?
09:32:12 <flux> so one would think that no, not much work is done to that direction.. but I could be wrong :)
09:32:25 <allbery_b> everything old is new again :)
09:32:44 <oerjan> more lately, it's been proved that delimited continuations can do everything monads can.
09:32:56 <olsner> isn't the (\x -> ...) part of (m >>= \x -> ... ) just a simple continuation?
09:32:58 <phobes> oerjan: Yes, that's the kind of result I'm interested in
09:33:36 <oerjan> don't remember the reference, though
09:33:54 <oerjan> but someone here must know.
09:39:20 <phobes> Does anyone understand why Word and OpenOffice wait until you press space after the next word before converting -- into a solid dash?
09:40:13 <olsner> OO probably does it because Word does it
09:40:30 <twanvl> So you can change your mind?
09:40:31 <ski_> olsner : it is a partial continuation
09:40:44 <hkBst> olsner: why would it be a continuation?
09:41:23 <koala_man> phobes: otherwise it would interfer when you write morse code
09:41:28 <hkBst> ski_: http://en.wikipedia.org/w/index.php?title=Partial_continuation&action=edit
09:41:29 <oasisbot> http://tinyurl.com/2ejlx6
09:41:36 <phobes> koala_man, of course
09:42:12 <DRMacIver> phobes: Generally whenever I try to figure out why Word does somethign the conclusion I inevitably reach is "malice"
09:42:44 <ski_> hkBst : http://en.wikipedia.org/wiki/Delimited_continuation
09:42:56 <phobes> DRMacIver: "malice" sums up how I feel about word
09:43:12 <vincenz> @bot
09:43:12 <oasisbot> :)
09:43:26 <ski_> hkBst : http://community.schemewiki.org/?composable-continuations-tutorial
09:43:28 <oasisbot> http://tinyurl.com/yy2eux
09:43:37 <DRMacIver> phobes: I'm with you on thatone. :)
09:44:47 <hkBst> thanks ski_ :)
09:45:58 <ski_> oerjan,(olsner,hkBst) : Andrzej Filinski, "Representing Monads" <http://citeseer.ist.psu.edu/filinski94representing.html>, "Representing Layered Monads", <ttp://citeseer.ist.psu.edu/filinski99representing.html>
09:46:19 <phobes> ski_: thanks!
09:46:35 <ski_> np
09:52:31 <pete1> hi, is something like this
09:52:31 <pete1> if (not $null lst) &&  (head $tail lst) > 2 then "yes" else "no"
09:52:31 <pete1> safe in haskell; i.e. is the order of boolean expr. evaluation defined and stopped as soon as the result is known?
09:52:53 <oerjan> yep
09:53:01 <pete1> thanks
09:53:15 <sjanssen> this is actually more easily explained in Haskell than other languages
09:53:19 <sjanssen> @src (&&)
09:53:19 <oasisbot> True  && x = x
09:53:19 <oasisbot> False && _ = False
09:55:22 <pete1> ok; I see; just found it in the report, heh, did not realize it may be defined there as a 'non-builtin' function :)
09:55:42 <Cale> pete1: Even the values True and False aren't built in :)
09:55:46 <sjanssen> pete1: the magic of laziness ;)
09:56:04 <pete1> yeah; I'm ashamed :)
10:00:41 <Shurique> @pl \ a b -> length a == length b
10:00:41 <oasisbot> (. length) . (==) . length
10:02:15 <oerjan> aka (==) `on` length
10:02:35 <allbery_b> clearly @pl needs to be upgraded :)
10:03:07 <phobes> Cale, I saw you posted to that Axiom of Choice Paradox blog (linked from Reddit) ... Do you really think 'people don't have good memories' is the resolution to that ?
10:03:52 <Cale> phobes: Well, the prisoners who used the axiom of choice to pick a sequence from each equivalence class have to remember uncountably many such sequences.
10:04:18 <Cale> That's not just an infinite amount of information, it's an uncountably infinite set of things to remember.
10:04:44 <phobes> Cale:  I agree it's a problem that would prevent us from testing this in real-life, I just don't think it's the crux of the matter
10:04:55 <phobes> since we can't really test anything having to do with infinity
10:04:59 <Cale> I think it's what's causing the unintuitiveness
10:05:18 <phobes> Well, I think you could rephrase it without memories being involved
10:05:34 <Cale> sure, but then it won't seem all that strange anymore
10:05:40 <phobes> I think it will
10:05:50 <phobes> Suppose you take an infinite string of coin flips
10:06:03 <phobes> And they are supposed to be random and independent
10:06:47 <phobes> You can define a function f over naturals such that f depends only on the proper tail of the sequence from that point
10:07:01 <Cale> naturals?
10:07:25 <phobes> Yes... Basically, I'm just numbering the flips
10:07:31 <phobes> That's not important
10:07:43 <EvilTerran> link? i'm not seeing it on the reddit page
10:08:19 <phobes> http://cornellmath.wordpress.com/2007/09/13/the-axiom-of-choice-is-wrong/
10:08:22 <oasisbot> Title: The Axiom of Choice is Wrong  The Everything Seminar, http://tinyurl.com/2czgkq
10:08:31 <desp> phobes: flamebait ;)
10:08:45 <phobes> desp: huh?
10:08:54 <phobes> oh the link title :)
10:08:54 <oerjan> f x = x is the binary expansion of a rational number
10:08:56 <desp> phobes: does intuition apply when prisoners have infinite memories
10:08:58 <desp> ?
10:09:00 <desp> yeah :)
10:09:33 <desp> oh, I see this has already been said.
10:09:35 <desp> pardon me
10:10:42 <Cale> That's my argument. These prisoners are allowed to look at the *infinitely many* other prisoners, identify which of the uncountably many possible equivalence classes they're in, and remember the sequence they're supposed to have agreed on for that equivalence class.
10:11:09 <Cale> Intuition just can't apply in something like that.
10:11:48 <Cale> You've never met anyone who can communicate or store an uncountably infinite amount of information.
10:12:26 <sjanssen> speak for yourself
10:12:30 <phobes> Cale:  But just because it doesn't happen doesn't mean that's the resolution of the paradox
10:12:45 <Cale> phobes: There is no paradox.
10:12:53 <phobes> perceived paradox :)
10:12:59 <Cale> In the world of ZFC, these people can very well do that.
10:13:10 <phobes> Cale:  I agree
10:13:18 <Cale> Maybe it's unintuitive, but that just means that you're unfamiliar with ZFC.
10:14:06 <phobes> Cale:  I don't even find it all that unintuitive - I just don't think limited memory is the crux of the problem
10:14:17 <Cale> What do you think is?
10:15:19 <phobes> I think it's just a funny property of infinite sequences
10:15:34 <conal> does anyone know what LANGUAGE extension enables "import GHC.Base (unsafeCoerce#)" to be parsed?
10:15:43 <dons> -fglasgow-exts :)
10:15:55 <dons> there should be -Xunboxed-thingies or some such
10:16:04 <phobes> If you assume the game master is assigning colors randomly, then you get a funny distribution on the naturals
10:16:24 <conal> dons: thanks.
10:16:36 <Cale> aren't these real numbers?
10:16:40 <phobes> Ask, "what is the probability that the Nth natural is the first number that agrees with all of the following numbers in my equivalence class"?
10:16:46 <Cale> ah, okay
10:16:47 <phobes> Cale:  Essentially, yes
10:16:53 <dons> conal: -fglasgow-exts works, but i don't know of the LANGUAGE pragma for it
10:17:13 <phobes> Anyway, this distribution is funny- it's not countably additive
10:17:31 <conal> dons: i'm using -fglasgow-exts now.  when i see OPTIONS in my code, i've been changing to LANGUAGE.
10:17:44 <oerjan> ultrafilters ftw!
10:17:46 <phobes> P({n}) = 0 for any n (by easy argument), but P(N) = 1 by the argument of the link
10:18:22 <conal> oerjan: ultrafilters?
10:19:25 <oerjan> {0,1}-valued non-countably additive measures, essentially
10:20:34 <oerjan> defined on _all_ subsets
10:21:17 <oerjan> (more commonly, the family of sets for which this measure is 1)
10:21:43 <conal> the {0,1} restriction avoids the banach-tarski paradox?
10:22:12 <oerjan> no one said anything about invariance under rotations.
10:22:22 <conal> oh
10:22:47 * conal just found http://hackage.haskell.org/cgi-bin/haskell-prime/trac.cgi/wiki/HaskellExtensions
10:22:50 <oasisbot> Title: HaskellExtensions - Haskell Prime - Trac, http://tinyurl.com/yrponq
10:22:57 <lambdabot> Title: HaskellExtensions - Haskell Prime - Trac, http://tinyurl.com/yrponq
10:23:23 <oerjan> oh, and to be clear, {0,1} is just the two numbers 0 and 1, not the interval between them.
10:23:43 <conal> oerjan: i figured that part
10:24:18 <conal> oerjan: so what's cool about {0,1}-valued measures?
10:24:29 <dons> ?userrs
10:24:29 <oasisbot> Maximum users seen in #haskell: 371, currently: 368 (99.2%), active: 13 (3.5%)
10:24:29 <lambdabot> Maximum users seen in #haskell: 407, currently: 368 (90.4%), active: 5 (1.4%)
10:24:48 <oerjan> well, they're a sort of generalized points.  and they require the axiom of choice.
10:24:59 <dons> vincenz: i need ops for oasisbot, as a general courtesy, please :)
10:25:01 --- mode: ChanServ set +o dons
10:25:04 --- kick: oasisbot was kicked by dons (thanks)
10:25:07 --- mode: ChanServ set -o dons
10:25:42 <conal> what are irc channel modes about?
10:25:51 <oerjan> and are useful in general topology
10:26:20 <oerjan> +c means we cannot use insane color coding here
10:26:26 <phobes> ultrafilters are also used in applying topology to logic
10:26:36 <oerjan> +n means people outside the channel cannot message it
10:26:44 <oerjan> +t means only ops can set the topic
10:26:50 <oerjan> iirc
10:28:52 <dons> Igloo: around?
10:29:02 <thorkilnaur> vincenz, Did you ask about Freiburg travel on #haskell-hac07? The closest airport is Basel, 1 hour from Freiburg, according to my sister who lives in Freiburg
10:29:46 <Igloo> dons: Yup
10:30:06 <dons> is darcs.haskell.org:/srv/darcs/testsuite the url if I want to push patches over ssh to the testsuite?
10:31:12 <Igloo> dons: I think it's officially /home/darcs/testsuite
10:31:15 <dons> ah
10:32:04 <dons> down to 6 test failures on amd64/openbsdd
10:32:58 <dons> i've also 2 patches for the unix lib to help out openbsd
10:33:04 <dons>   * check for shm_open/shm_unlink (for archs like OpenBSD without them)
10:33:13 <dons> or we get undefined symbol errors
10:33:26 <dons> and the semaphore.h needs to be linked against -lpthreads
10:34:56 <vincenz> dons: ok, will fix
10:35:01 <vincenz> dons: want me to kick Oatschool ?
10:35:02 <vincenz> erm
10:35:03 <vincenz> oasisbot
10:35:11 <dons> done
10:36:14 <vincenz> done, you've got ops
10:36:20 <vincenz> yay for making that a runtime file and not a compilation thing
10:39:57 * EvilTerran reads about Banach-Tarski
10:40:07 * EvilTerran 's head explodes
10:41:26 * EvilTerran goes back to his monad transformers. nice easy subject. ;]
10:44:40 <ski> Model M !
10:49:11 <Cale> http://golem.ph.utexas.edu/category/2007/09/the_catsters_on_youtube.html -- these monad videos are quite nice :)
10:49:13 <lambdabot> Title: The Catsters on YouTube | The n-Category Caf&#xE9;, http://tinyurl.com/2an7kx
10:50:36 * balodja rather looked at the performer, that at the board :)
10:50:46 * merus loved every second of 'em.
10:51:48 <EvilTerran> wow.
10:52:09 <shapr> CT as explained by cute chix, I love it!
10:52:13 <EvilTerran> deriving (Monad, MonadTrans) just ... works. that was slightly unexpected.
10:52:23 <EvilTerran> hooray for newtype deriving!
10:52:29 <Cale> It just copies the implementation
10:52:57 <Cale> newtype doesn't actually change the implementation of your thing at runtime
10:52:59 <EvilTerran> deriving MonadState doesn't work, though; something to do with type parameters.
10:53:07 <Cale> MonadState s
10:53:26 <EvilTerran> ah...
10:53:47 <ski> <slava> Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment. Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:53:56 <EvilTerran> still, it's remarkably useful
10:59:15 <EvilTerran> hm... if you want automatic lifting, do you have to write the instances yourself?
10:59:33 <EvilTerran> *implicit lifting, whatever it's usually called
11:04:21 <dons> dcoutts: grumble. *.Base -> *.Internal breaks every project I work on :)
11:05:03 <twanvl> EvilTerran: what do you want to lift?
11:06:18 <EvilTerran> I mean the equivalents to instance MonadState s m => MonadState s (ContT|ErrorT|ReaderT|... m)
11:06:29 <Igloo> dons: Serves you right for using internal interfaces  :-
11:06:33 <Cale> EvilTerran: yes
11:06:34 <EvilTerran> for my monad class in place of MonadState
11:06:46 <EvilTerran> okay
11:07:20 <dons> Igloo: but they're _my_ internal interfaces! :)
11:07:47 <Igloo> :-)
11:08:16 <byorgey> "Of course, a language feature would not be worthy of the name ``class'' without supporting inheritance. " -- from the Python tutorial. umm...
11:08:29 <phobes> byorgey: heh
11:08:35 <dons> Eq a => Ord a :-) close enough
11:09:19 <byorgey> dons: yeah, it's similar, I know.  I was just laughing at how "OO-centric" the statement was =)
11:09:47 <phobes> byorgey:  The thing is, there are plenty of OO people who would also consider that statement nonsense
11:10:20 <byorgey> phobes: really?
11:10:57 <phobes> byorgey:  maybe plenty is overselling it, but there's quite a few who would (under the mantra 'inheritance breaks encapsulation')
11:11:31 <ibid> and there are some OO people who will try to talk you out of that silly "class" idea :)
11:11:39 <byorgey> phobes: interesting.  are there any examples of OO languages which do not feature inheritance?
11:12:29 <phobes> I can't think of one offhand :)
11:12:45 <ibid> well, i can think of a couple that are also missing classes
11:13:01 <byorgey> ibid: such as?
11:13:02 <phobes> the prototype languages don't have classes, but they generally have something akin to inheritance
11:13:14 <ibid> kevo comes first to mind, i'd have to look up some others
11:13:20 <ibid> but i know there are others
11:13:31 <ibid> javascript, but i'm not sure if they have something they call classes :)
11:13:35 <phobes> Cecil is the only one I've looked at in any detail
11:13:55 <phobes> oh ya and Javascript
11:14:10 * byorgey had never heard of "prototype-based languages".
11:14:17 * byorgey reads the WP page...
11:14:22 <phobes> I think 'squeak' smalltalk also
11:14:39 <araujo> byorgey, check Io, NewtonScript
11:14:53 <phobes> nm about squeak, don't know where I'd heard that
11:14:58 <araujo> phobes, Smalltalk is not prototype-based
11:15:11 <araujo> neither Squeak afaik
11:15:13 <SamB_XP> Squeak isn't itself prototype-based, but has some wierd prototype-based thing built in it
11:15:33 <phobes> araujo:  Ya, I thought I'd heard that Squeak was a prototype based version of smalltalk, but a quick search proved that wrong
11:16:04 <SamB_XP> it actually creates new classes when you clone objects, I think...
11:16:07 <byorgey> see, this is what I love about #haskell.  Sometimes I feel like I could just post a random, ungrammatical utterance, and someone would say, "you know, that reminds me of..." and I'd end up learning something =)
11:16:09 <phobes> oh, there's apparently some GUI component 'tweak' for Squeak that's prototype based
11:16:45 <SamB_XP> aaaargh!
11:16:47 <shapr> Squeak was intended to be a clone of Self, right?
11:16:57 <SamB_XP> shapr: not really
11:17:15 <SamB_XP> they did immitate the GUI framework, and called it by the same name, though
11:17:43 <byorgey> from the WP page for Prototype-based programming (in a list of prototype-based languages): "...Squeak when using the Viewer framework to manipulate Morphic components"
11:17:48 <byorgey> whatever that means
11:18:11 <SamB_XP> Morphic is the name of the GUI framework
11:20:21 <ibid> byorgey: also see abado & cardelli's sigma calculus ('a theory of objects'). that is classless
11:25:34 <ekidd> What are some good events for meeting other Haskellers in person?
11:25:50 <ekidd> I may not be able to make the ICFP this year.
11:26:18 <dolio> You could interview at Galois.
11:26:29 <dons> Hmm, the Hackathon (also in Freiburg). SF haskell group? AmeroHaskell? POPL (in SF in January)
11:26:55 <shapr> ekidd: Are you in the Southeast USA?
11:27:05 <ekidd> Northeast.
11:27:51 <dons> oh, NYC FP group?
11:28:01 <dons> hmm, I should add all these to the user groups page..
11:28:09 <ekidd> dons: The Hackathon is after the ICFP this year?
11:28:19 <dons> yep
11:28:41 <ekidd> Hmm.
11:29:05 <phobes> How much $$ is it to get into one of those POPLs anyway
11:29:06 <phobes> ?
11:29:36 <ekidd> I could speak at the CUFP workshop on the 4th, and stay for the Hackathon.
11:29:51 <ekidd> That would presumably be cheaper than the ICFP, and probably more fun. :-)
11:30:16 <SamB_XP> @where hug
11:30:17 <lambdabot> I know nothing about hug.
11:30:18 <dons> phobes: oh, $100+
11:30:32 <dons> that's right, you're speaking at CUFP, eric?
11:30:35 <phobes> dons: but $100 ish
11:30:42 <dons> around that.
11:30:47 <phobes> cool, thanks
11:30:58 <dons> POPL is fairly expensive, ICFP is cheaper, Haskell workshop ~$60 or so
11:31:03 <dons> there are student rates too
11:31:38 <ekidd> dons: I'm scheduled to, but HW+ICFP+CUFP+hotel+plane was looking more expensive than a really nice laptop.
11:31:52 <ekidd> dons: With only one day of real Haskell stuff.
11:32:16 <ekidd> But if the Hackathon is right after CUFP, then I get a lot more Haskell hacking for my money. :-)
11:32:30 <dons> and its free :)
11:32:35 <dons> but register quick so you get a tshirt!
11:33:12 <ekidd> Maybe I should get some kind of nicely modular probability library into shape for the Hackathon...
11:33:28 <ekidd> Any hotel recommendations for the Hackathon?
11:33:32 <pejo> phobes, if you're interested in research it's quite an experience to go to popl though,might well be worth it.
11:33:46 <dons> ekidd: there's a couple listed on the hackathon attendees page
11:33:50 <dons> but nothing `recommended'
11:33:58 <pejo> Bit of a strange audience in this channel, where half has a phd already and find going to popl 'normal'.
11:34:35 <dons> we're programmers :) and popl is about programming, right? :)
11:36:15 <pejo> dons, heh. Yeah. Like Mads Dam, "Decidability and Proof Systems for Language-Based Noninterference Relations".
11:36:38 <dons> looks good.
11:36:55 <dons> we want to understand our job, right?
11:36:57 <dolio> Elementary stuff. All programmers should know that. :)
11:37:04 <dons> 'zactly.
11:37:25 <dons> anything 'Language-based' is worthwhile :)
11:38:33 <pejo> I used to work with the NetBSD/Vax port maintainer. Not sure he would read such a paper. (He's the reason to the fuss on slashdot over pcc too)
11:40:35 <ekidd> dons: Is a composable probability monad library worth bringing to the Hackathon, or should I get up to speed on something else?
11:40:59 <earthy> ekidd: do release that if you can!
11:49:50 <astrolabe> ekidd: How is that probability monad going?  Did you publish the paper?
11:50:35 <ekidd> astrolabe: No, it got caught in the big HW submission crunch this year. Or that's what I tell myself to cheer myself up. :-)
11:51:21 <ekidd> astrolabe: I'm going to revise and publish a version sometime soon.
11:51:27 <astrolabe> :)  I want probability monads in a standard library somewhere.
11:51:35 <astrolabe> I look forward to it.
11:51:54 <ekidd> Getting married took away a lot of my Haskell time this summer. :-D
11:52:07 <astrolabe> Congratulations
11:52:53 <ivancerosi> has anyone tried to use haskell for web development
11:53:48 * SamB_XP gestures at the skeletons in the corner
11:54:02 <ekidd> ivancerosi: Not personally, but there's a bit list here: http://www.haskell.org/haskellwiki/Applications_and_libraries/Web_programming
11:54:04 <lambdabot> Title: Applications and libraries/Web programming - HaskellWiki, http://tinyurl.com/yrdc54
11:55:23 <dino-> ivancerosi: There's the infamous hemp clothing store web app: http://article.gmane.org/gmane.comp.lang.haskell.cafe/21159
11:55:25 <lambdabot> Title: Gmane -- Mail To News And Back Again
11:55:41 <dino-> And we've been talking a lot around here lately about HAppS, which hpaste runs on.
11:58:01 <dino-> Does haskellwiki use Haskell yet?
12:00:37 <sjanssen> dino-: no, it uses MediaWiki
12:00:55 <dino-> I figured no, but was hopeful.
12:03:48 <ndm> ivancerosi: i wrote hoogle in haskell http://haskell.org/hoogle
12:03:50 <lambdabot> Title: Hoogle
12:05:43 <ivancerosi> ndm: what server did you used?
12:05:55 <augustss> And the hemp guy got a job from doing that web site. :)
12:06:03 <ndm> ivancerosi: just anything with CGI, and make it into a binary
12:06:19 <heisenbug_> ekidd: still here?
12:06:50 <ekidd> heisenbug_: Yup.
12:07:10 <heisenbug_> you are of Dylan fame?
12:07:35 <heisenbug_> drifting in direction of Haskell too?
12:08:34 <heisenbug_> I am going to ICFP, if you make it we could chat a bit
12:08:50 <fasta> How do I compile a binary with ghc _6.4_?
12:08:59 <fasta> ghc --make Main doesn't link.
12:09:02 <slarba_> argh. bytestrings crash (ghc-6.6.1)
12:09:06 <slarba_> is this a known problem?
12:09:14 <Baughn> slarba_: Define "crash"
12:09:16 <sjanssen> slarba_: crash how?
12:09:36 <slarba_> just a moment
12:09:45 <ekidd> heisenbug_: Yup, I'm a Dylan geek. :-)
12:09:55 <ekidd> Are you the one who e-mailed me?
12:10:15 <heisenbug_> when? I read your thesis
12:10:49 <heisenbug_> I even think you mentioned me in the thesis :-)
12:12:46 <fasta> What does "link(batch): upsweep (partially) failed " mean?
12:15:41 <ekidd> heisenbug_: It looks like I'll be skipping ICFP itself, and just going to CUFP and the Hackathon.
12:16:08 <ekidd> heisenbug_: I've heard from another Dylan hacker ("Hannes") who also wants to meet up in Freiburg.
12:16:48 * dylan contemplates timetravel and preventing apple from choosing that name for the language.
12:16:53 <heisenbug_> anyway, drop me a note, I'll stay till PLPV (Friday)
12:17:12 <heisenbug_> are you involved in CUFP?
12:17:47 <fasta> Never mind
12:21:22 <ekidd> heisenbug_: How can I get in touch?
12:21:46 <heisenbug_> ekidd: gabor@mac.com
12:32:24 <fnord123> @Adam Turoff
12:32:25 <lambdabot> Unknown command, try @list
12:33:20 <fnord123> hm, does anyone know if the author of this blog post lurks here: http://notes-on-haskell.blogspot.com/2007/02/ffi-in-haskell.html
12:33:21 <lambdabot> Title: Notes on Haskell: FFI in Haskell
12:34:43 <DRMacIver> Noone owned up to it last time I saw it mentioned.
12:40:31 <fnord123> It's kinda hard to look up 'haskell guid' or 'haskell uuid' so I think it's worth asking him to submit it to some sort of haskell wiki page
12:41:36 <oklopol> > let rt [] = []; rt x:xs = xs+[x] in rt [1,2,3]
12:41:37 <lambdabot>  Parse error in pattern
12:41:51 <oklopol> > let rt [] = []; rt (x:xs) = xs ++ [x] in rt [1,2,3]
12:41:53 <lambdabot>  [2,3,1]
12:42:55 <oklopol> > let rt _ [] = []; rt 0 xs = xs; rt n (x:xs) = rt (n-1) $ xs ++ [x] in 5 `rt` [1..10]
12:42:56 <lambdabot>  [6,7,8,9,10,1,2,3,4,5]
12:43:02 <oklopol> hmm... slow.
12:43:40 <oklopol> how do i take sublists?
12:44:56 <oklopol> > takeFrom 5 [1..10]
12:44:57 <lambdabot>   Not in scope: `takeFrom'
12:45:09 <oklopol> > takeFrom [1..10] 10
12:45:09 <lambdabot>   Not in scope: `takeFrom'
12:45:17 <oklopol> hmmm
12:45:35 <oklopol> > [1..10]!![3..6]
12:45:36 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
12:45:47 <oklopol> > [1..10]!!(3,4,6)
12:45:48 <lambdabot>  Couldn't match expected type `Int'
12:45:52 <oklopol> :P
12:45:56 <oklopol> i'll guess it soon!
12:46:15 <balodja> sec . splitAt? :)
12:46:26 <balodja> snd . splitAt
12:47:11 <balodja> > snd . splitAt 5 [1..10]
12:47:12 <lambdabot>  Couldn't match expected type `a -> (a1, b)'
12:47:43 <oklopol> > splitAt 5 [1..10]
12:47:45 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
12:47:57 <oklopol> > (snd . splitAt) 5 [1..10]
12:47:58 <lambdabot>  Couldn't match expected type `(a, b)'
12:48:00 <byorgey> > snd . splitAt 5 $ [1..10]
12:48:02 <lambdabot>  [6,7,8,9,10]
12:48:08 <oklopol> ah
12:49:02 <oklopol> > splitAt 0 [1,2,3]
12:49:03 <lambdabot>  ([],[1,2,3])
12:49:12 <byorgey> > let takeFrom n = snd . splitAt n in takeFrom 5 [1..10]
12:49:13 <lambdabot>  [6,7,8,9,10]
12:49:32 <oklopol> > let rt _ [] = []; rt n l = f ++ s where (f,s)=splitAt n l in 5 `rt` [1..10]
12:49:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:49:40 <oklopol> > let rt _ [] = []; rt n l = s ++ f where (f,s)=splitAt n l in 5 `rt` [1..10]
12:49:42 <lambdabot>  [6,7,8,9,10,1,2,3,4,5]
12:50:05 <oklopol> > let rt _ [] = []; rt n l = s ++ f where (f,s)=splitAt (n `mod` length l) l in 5 `rt` [1..10]
12:50:07 <lambdabot>  [6,7,8,9,10,1,2,3,4,5]
12:50:13 <oklopol> > let rt _ [] = []; rt n l = s ++ f where (f,s)=splitAt (n `mod` length l) l in (-1) `rt` [1..10]
12:50:15 <lambdabot>  [10,1,2,3,4,5,6,7,8,9]
12:50:29 <byorgey> > splitAt 5 []
12:50:30 <lambdabot>  ([],[])
12:50:49 <oklopol> </another random haskell experiment>
12:51:27 <byorgey> > let rt = (flip uncurry (++) .) . splitAt in 5 `rt` [1..10]
12:51:28 <lambdabot>  Couldn't match expected type `(a, b)'
12:51:31 <oklopol> > -1 `mod` 7
12:51:32 <lambdabot>  -1
12:51:40 <oklopol> oh.
12:51:47 <Pastorn_> byorgey: what's wrong with drop?
12:51:55 <oklopol> > splitAt (-1) [1,2,3,4]
12:51:57 <lambdabot>  ([],[1,2,3,4])
12:52:13 <byorgey> > let rt = ((flip uncurry (++)) .) . splitAt in 5 `rt` [1..10]
12:52:13 <oklopol> > splitAt (0) [1,2,3,4]
12:52:15 <lambdabot>  Couldn't match expected type `(a, b)'
12:52:16 <lambdabot>  ([],[1,2,3,4])
12:52:19 <oklopol> > splitAt (-2) [1,2,3,4]
12:52:20 <lambdabot>  ([],[1,2,3,4])
12:52:39 <oklopol> > (-1) `mod` 7
12:52:40 <lambdabot>  6
12:52:44 <oklopol> ah it was about that.
12:53:15 <byorgey> Pastorn_: hm, you mean for takeFrom?  good point. =)
12:53:18 <byorgey> > drop 5 [1..10]
12:53:19 <lambdabot>  [6,7,8,9,10]
12:54:02 <balodja> @src splitAt
12:54:02 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
12:54:07 <balodja> :)
12:54:25 <oklopol> ah.
12:54:29 <oklopol> @src take
12:54:30 <lambdabot> take n _      | n <= 0 =  []
12:54:30 <lambdabot> take _ []              =  []
12:54:30 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:54:50 <oklopol> uh that's the stuff
12:55:35 <oklopol> i don't like that negativity test.. why isn't that just strictly defined for only numbers of type Z+...
12:55:40 <oklopol> (is it Z+ :))
12:55:46 <oklopol> (i think it is..)
12:58:15 <oklopol> i guess you can never have the type be the exact domain of the function
12:58:24 <oklopol> because it'd be hell writing programs
12:58:45 <byorgey> oklopol: yeah, Haskell doesn't have a nice built-in Z+ type
12:58:54 <byorgey> oklopol: you can easily define one but it's usually not worth it
13:03:14 <byorgey> oklopol: in some sense, having types reflect the exact intended domains for functions is the ultimate goal, since it means the type system will catch more bugs for you
13:03:50 <byorgey> but in practice it's a tradeoff between expressiveness of types and the amount of time it takes you to set up all the types and write the code.
13:11:01 <b_jonas> yes, both because you have to create those types, and because you have to convert between similar types like Z and Z+
13:11:16 <b_jonas> that's even more true for objects
13:11:48 <b_jonas> I often feel OO languages overwhelm me in some applications because I have to spend more time to devise classes and objects then writing actual code
13:12:22 <b_jonas> (this applies to c++ and ruby, but not always, and I'm improving in avoiding this problem)
13:13:11 <ndm> is Olivier Boudry in IRC?
13:21:14 <drigz> @source Data.Fixed
13:21:14 <lambdabot> Data.Fixed not available
13:21:33 * nomeata has his second try to get started with HApps.
13:21:54 <alexj> we may be releasing 0.9.1 very very soon.
13:22:17 <nomeata> Im trying that, from darcs.
13:27:28 <alexj> if I want a descending list from Data.Map, any idea what function to call
13:27:30 <alexj> ?
13:27:46 <hpaste>  aluno321 pasted "error" at http://hpaste.org/2783
13:28:04 <Botje> alexj: Data.List has a sort.
13:28:09 <fax> hiya
13:28:26 <alexj> Botje, yes, but it appears only to want to give me ascending list.
13:28:28 <aluno321> hello, i pasted http://hpaste.org/2783, can anyone help me? i put the code and the error
13:28:35 <Botje> alexj: so reverse? :)
13:28:56 <dylan> @hoogle sortBy
13:28:56 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
13:28:57 <alexj> then you  endup reversing a potentially big list as opposed to traversing the tree backward which is what I want.
13:29:07 <fax> aluno321: I think you want like, media list = (foldl (+) 0 list) / (foldl (\n _ -> n + 1) 0 list)
13:29:16 <aluno321> btw, i want to get the mean value of the numbers in list
13:29:22 <Botje> aluno321: it doesn't work that way
13:29:28 <fax> aluno321: because otherwise you are dividing functions
13:29:43 <Botje> aluno321: you need to explicitly pass the list to both functions before dividing
13:29:56 <dylan> @type sortBy (flip compare)
13:29:57 <fax> @pointless (\l->sum l/length l)
13:29:58 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:29:58 <lambdabot> liftM2 (/) sum length
13:30:03 <Botje> aluno321: or use a little trick. liftM2 (/)  (foldl (+) ...) (foldl (...))
13:30:07 <fax> aluno321: average = liftM2 (/) sum length
13:30:12 <dylan> aluno321: sortBy (flip compare)
13:30:13 <dylan> rtt
13:30:15 <dylan> *err
13:30:19 <dylan> wrong a-tab name
13:30:30 <dylan> alexj: sortBy (flip compare)
13:30:31 <Botje> but you need to import Control.Monad and Control.Monad.Reader for that
13:31:09 <ndm> alexj: do you always want to get the list out in reverse, or just sometimes?
13:31:14 <oklopol> can you use Data.List with lambdabot
13:31:14 <oklopol> ?
13:31:16 <aluno321> fax, i can't use the sum and length since it was asked so at my class =] that's why i'm tryin' with foldl
13:31:27 <fax> aluno321: just implement sum and length then
13:31:29 <kpreid> aluno321: use botje's then
13:31:31 <fax> with slightly different names
13:31:38 <aluno321> Botje, and how do i declare the media :: stuff?
13:31:51 <Botje> aluno321: the type stays the same
13:31:55 <kpreid> aluno321: but if you're looking to do it without naming the list, then liftM2 is the way to go
13:31:57 <alexj> dylan: I am trying to add orderBy and rOrderBy to IxSet.  IxSet stores the index in a Data.Map.  I don't want to unpack everything just to get the highest value on a particular field.
13:32:02 <aluno321> fax, that's what i did! =D thanks anyway
13:32:09 <kpreid> if you're trying to be simple, use \l -> sum l / length l
13:32:25 <Botje> aluno321: the liftM2 is a dead giveaway you didn't write it yourself though
13:32:49 <aluno321> what is the listM2? sorry, but i suck at haskell =[ so everything is new to me
13:32:58 <Botje> aluno321: yes, so don't use it if this is homework.
13:33:01 <oklopol> only lambdabot knows
13:33:18 <Botje> aluno321: it involves the ((->) r) mo^wwarm fuzzy thing instance
13:33:39 <dylan> alexj: well, coverting to a list isn't that big of a deal, right?
13:33:48 <Botje> aluno321: personally, i'd write it as media l = sum / length where sum = ...; length = ...
13:34:09 <Botje> you could do it in one fold if you're a bit clever.
13:34:31 <aluno321> Botje, like "rewriting" the foldl part?
13:34:39 <alexj> dylan: if the number of items is large then it requires an entire list traversal to get the highest value in the list even though it is O(log n) to get it from Data.Map
13:34:46 <nomeata> does HApps need a specifc version of syb-with-class? I get: /HAppS/Data/Default.hs:114:0:
13:34:46 <nomeata>     No instance for (Data DefaultD BSC.ByteString)
13:34:54 <Botje> aluno321: i'd put the separate foldl's into sum and length and then just sum / length
13:35:00 <Botje> it's the most clear
13:35:17 <alexj> nomeata: what are you doing to produce that error?
13:35:38 <nomeata> alexj: just import HAppS.Server
13:35:43 <aluno321> Botje, hmm i'll try, just a sec
13:35:52 <alexj> are you using searchpath?
13:35:52 <kpreid> @pl foldl (\((s,c) v -> (s + v,succ c)) (0,0)
13:35:52 <lambdabot> (line 1, column 16):
13:35:52 <lambdabot> unexpected "v"
13:35:53 <lambdabot> expecting operator or ")"
13:36:03 <nomeata> alexj: using a darcs export of some of HAppS and the 0.3 release from syb-with-class
13:36:04 <kpreid> @pl foldl (\(s,c) v -> (s + v,succ c)) (0,0)
13:36:04 <lambdabot> foldl (uncurry ((. succ) . flip . ((,) .) . (+))) (0, 0)
13:36:39 <alexj> nomeata, the easiest way to get started is probably to export HAppS-Begin and edit it.
13:37:13 <kpreid> @pl foldl (\t v -> ((+ v) *** succ) t) (0,0)
13:37:13 <lambdabot> foldl (flip ((*** succ) . (+))) (0, 0)
13:37:27 <aluno321> Botje, i got a "inferred type is not general enough"
13:37:33 <Botje> aluno321: can you hpaste?
13:37:34 <nomeata> alexj: I tried that but it looked too scary (mostly because of the also-new record types), so Im trying to get started from scratch. But I guess I should use the searchpath program that comes with it...
13:37:37 <kpreid> @pl foldl (\t v -> (succ *** (+ v)) t) (0,0)
13:37:38 <lambdabot> foldl (flip ((succ ***) . (+))) (0, 0)
13:37:42 <aluno321> Botje, roger!
13:38:01 <alexj> the new record types?
13:38:30 <hpaste>  aluno321 annotated "error" with "error 2.0" at http://hpaste.org/2783#a1
13:38:54 <nomeata> alexj: at least I didnt really figure out how the Entry type works
13:39:15 <oklopol> anyone wanna try to explain liftM2? :)
13:39:22 <aluno321> Botje, did it!
13:39:31 <Botje> aluno321: ah,yes
13:39:34 <alexj> oh.  it is actually the standard haskell datatype.  the wrapping just allows automatic generation and parsing of Xml for it.
13:39:35 <Botje> :t (/)
13:39:35 <dylan> @src liftM2
13:39:38 <oklopol> lift stuff into a Monad and does some random function application?
13:39:39 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:39:40 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:39:49 <Botje> is only defined on fractional type
13:39:58 <Botje> num is more general than fractional
13:40:05 <Botje> so use Fractional a instead of Num a in your type
13:40:08 <drigz> oklopol: it does what the type signature says?
13:40:08 <nomeata> alexj: http://happs.org/HAppS/HAppS-Begin/haskell/Types.hs was confusing, but maybe I should try harder
13:40:23 <Botje> do you see why?
13:40:25 <drigz> oklopol: what confuses you?
13:40:33 <Botje> Num also includes integers
13:40:40 <oklopol> drigz: not on the level where haskell code is as clear as english to me, but i'll try and see if i get that :P
13:40:52 <kpreid> oklopol: liftM2 turns 2-arg function into a monad operation
13:41:07 <kpreid> @type liftM2 (+)
13:41:09 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
13:41:29 <aluno321> Botje, let's see if i got it. if i use Num, maybe the result would end up in a Fractional type and then i would get an error. am i right?
13:41:44 <Botje> yes.
13:41:51 <alexj> nomeata, can you tell me what is confusing?  I'll help.
13:41:54 <Botje> eg 4.25 can't fit into an Int or Integer
13:43:01 <aluno321> Botje, okay! thank you very very much =D it was a great help
13:43:12 <Botje> you're welcome
13:43:13 <nomeata> alexj: basically I wonder where the record is defined? There seems to be something about indices at the bottom which seems to involve template haskell. And I wonder how Atom.hs plays a role there.
13:44:26 <nomeata> alexj: Or is Atom.hs the basic definition of the Entry?
13:45:28 <alexj> Atom defines Entry.
13:45:44 <alexj> the TH defines a collection of them that is indexed properly.
13:46:01 <alexj> type type of that collection is Entries.
13:46:48 <nomeata> hmm, ok, so I guess that is where constructors like GetEntries come from then.
13:46:50 <oklopol> i guess what i don't get is why (sum [1.0,2.0,3.0]) and (length [1.0,2.0,3.0]) are okay, and (6.0/3) is okay, but (length [1.0,2.0,3.0])/(sum [1.0,2.0,3.0]) gives some type error
13:47:05 <drigz> @type sum
13:47:07 <lambdabot> forall a. (Num a) => [a] -> a
13:47:08 <drigz> @type length
13:47:09 <lambdabot> forall a. [a] -> Int
13:47:14 <oklopol> > sum [1.0,2.0,3.0]
13:47:16 <lambdabot>  6.0
13:47:20 <oklopol> > length [1.0,2.0,3.0]
13:47:21 <kpreid> oklopol: because / requires its args to have the same type.
13:47:21 <lambdabot>  3
13:47:26 <nomeata> alexj: is there some documentation on inferIxSet? google only finds this example HAppS file :-)
13:47:27 <oklopol> ah.
13:47:29 <kpreid> oklopol: perhaps you'd like genericLength.
13:47:40 <kpreid> > genericLength [1.0,2.0,3.0] :: Double
13:47:42 <lambdabot>  3.0
13:47:51 <alexj> nomeata: yeah, we are short documentation.
13:48:00 <oklopol> > (\l -> sum l / (genericLength l) :: Double) [1..10]
13:48:02 <lambdabot>  5.5
13:48:14 <drigz> oklopol: you don't need the :: Double there i don't think
13:48:21 <oklopol> > (\l -> sum l / (genericLength l)) [1..10]
13:48:22 <lambdabot>  5.5
13:48:27 <oklopol> > (\l -> sum l / length l) [1..10]
13:48:28 <lambdabot>   add an instance declaration for (Fractional Int)
13:48:28 <lambdabot>     In the expression: (su...
13:48:32 <kpreid> numeric defaulting is handy.
13:48:38 <oklopol> yeah
13:48:41 <kpreid> @type /
13:48:43 <lambdabot> parse error on input `/'
13:48:46 <kpreid> @type (/)
13:48:48 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:48:55 <nomeata> alexj: next problem (if you dont mind): going to http://localhost:8000/blog/entries gives my the content of public/log. I assume it should list the prestent entries?
13:48:57 <kpreid> (... / length ...) will never work
13:49:06 <drigz> it's really nice getting the benefits of strong typing without writing any types at all
13:49:09 <kpreid> because / implies Fractional and Int isn't Fractional
13:49:13 <oklopol> > 6 / length [1..3]
13:49:13 <lambdabot>   add an instance declaration for (Fractional Int)
13:49:13 <lambdabot>     In the expression: 6 /...
13:49:17 <oklopol> i see
13:49:24 <oklopol> > 6 // length [1..3]
13:49:25 <lambdabot>  Couldn't match expected type `[(i, e)]' against inferred type `Int'
13:49:35 <drigz> oklopol: it's called `div` in haskell
13:49:40 <alexj> nomeata, are you using sh deploy/dev-start.sh?
13:49:48 <drigz> // updates an array
13:49:50 <oklopol> oh
13:49:52 <oklopol> indeed it is
13:49:53 <nomeata> alexj: yes
13:49:56 <oklopol> "updates"?
13:50:03 <alexj> and what is the content of your public/log?
13:50:05 <drigz> oklopol: more or less
13:50:09 <nomeata> alexj: and I thought it worked before...
13:50:15 <drigz> oklopol: it creates a new one with updated values
13:50:16 <oklopol> i don't know what that means.
13:50:21 <oklopol> i see
13:50:27 <hpaste>  nomeata pasted "public/log" at http://hpaste.org/2784
13:50:28 <alexj> note: it only gives public/log if it is present.  public/log shows whatever your current compiler error is until there is none.
13:50:45 <alexj> yeah, it is rebuilding.
13:50:46 <fax> how do you know which Monad to use ?
13:50:49 <alexj> try again and it should work.
13:50:51 <fax> for a given task
13:50:58 <drigz> oklopol: if you're on a pentium and you want it to run fast, `quot` is faster than `div`
13:51:06 <drigz> and works the same (i think?) for positive inputs
13:51:14 <nomeata> alexj: ah, I see. tricky :-)
13:51:29 <b_jonas> drgiz: lol. (isn't that true for all cpus except mmix though?)
13:51:36 <drigz> @check \a b -> a >= 0 && b >= 0 ==> a `div` b == a `quot` b
13:51:38 <lambdabot>  Add a type signature
13:51:50 <b_jonas> and yes, it's the same for positive inputs
13:51:50 <drigz> @check \a b -> (a::Double) >= 0 && b >= 0 ==> a `div` b == a `quot` b
13:51:51 <lambdabot>   add an instance declaration for (Integral Double)
13:52:01 <drigz> @check \a b -> (a::Int) >= 0 && b >= 0 ==> a `div` b == a `quot` b
13:52:03 <lambdabot>  Exception: divide by zero
13:52:09 <oklopol> :P
13:52:27 <nomeata> alexj: ok, that was the point when I gave up last time, because I had no idea how to debug it: when I try to add an entry using http://localhost:8000/blog/entryForm, I get Server error: resType
13:52:28 <oklopol> @check \a b -> (a::Int) >= 0 && b > 0 ==> a `div` b == a `quot` b
13:52:29 <lambdabot>  Arguments exhausted after 317 tests.
13:52:59 <oklopol> @src (==>)
13:53:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:53:03 <oklopol> :)
13:53:13 <nomeata> @check \a b -> abs a `div` abs b == abs a `quot` abs b
13:53:14 <lambdabot>  Add a type signature
13:53:22 <nomeata> @check \a b -> abs (a::Int) `div` abs b == abs a `quot` abs b
13:53:23 <lambdabot>  Exception: divide by zero
13:53:37 <nomeata> @check \a b -> b /= 0 ===> abs (a::Int) `div` abs b == abs a `quot` abs b
13:53:38 <lambdabot>   Not in scope: `===>'
13:53:41 <nomeata> @check \a b -> b /= 0 ==> abs (a::Int) `div` abs b == abs a `quot` abs b
13:53:43 <lambdabot>  OK, passed 500 tests.
13:54:10 <oklopol> what's the exhausted thing?
13:54:37 <oklopol> that it tried all the possible combinations of a and b in 317 tests? :)
13:54:40 <drigz> http://lists.osuosl.org/pipermail/darcs-devel/2005-April/001776.html
13:54:42 <lambdabot> Title: [darcs-devel] Re: QuickCheck, I assume?, http://tinyurl.com/ysgzbk
13:54:56 <nomeata> oklopol: it only tries so many numbers, and too many failed to satisfy the precondition.
13:55:26 <alexj> nomeata: just pushed some updates to the docs.
13:55:47 <alexj> nomeata, attempting to reproduce now.
13:55:54 <hpaste>  Mr_Awesome pasted "dt" at http://hpaste.org/2785
13:55:55 <drigz> oklopol: a ==> b = (not a) || b
13:56:09 <oklopol> defined in check then?
13:56:10 <drigz> oklopol: i.e. only check b if a is true
13:56:12 <Mr_Awesome> could someone tell me if that is correct use of IORef?
13:56:15 <drigz> oklopol: yeah
13:56:27 <oklopol> i see
13:57:55 <kpreid> Mr_Awesome: It's not wrong. It's odd that it takes an action though.
13:58:19 <twanvl> You create a new reference in each call
13:58:21 <kpreid> Mr_Awesome: I'd expect dt :: IORef Integer -> IO Integer
13:58:37 <Mr_Awesome> twanvl: i do? thats what i was afraid of
13:58:40 <kpreid> twanvl: only if 'time' does.
13:58:48 <kpreid> Mr_Awesome: No, you aren't.
13:58:50 <Mr_Awesome> oh
13:58:56 <kpreid> Mr_Awesome: You're doing whatever 'time' does.
13:59:09 <kpreid> Like I said, it probably ought to be :: IORef Integer -> IO Integer
13:59:15 <Mr_Awesome> ah, youre right
13:59:34 <alar> what library should I use to generate HTTP requests / parse HTTP responces ?
13:59:38 <Mr_Awesome> next time i should listen to the type system rather than just change the types to appease it ;)
13:59:40 <Mr_Awesome> thanks kpreid
14:04:21 <alexj> nomeata: confirmed blog example is broken.
14:04:53 <nomeata> alexj: ok, thanks, then at least I know its not me
14:05:59 <byorgey> alar: there's this, for one: http://varsztat.com/projects/curl/
14:06:00 <lambdabot> Title: Haskell bindings for libcurl
14:06:28 <byorgey> alar: unfortunately there's no one "canonical" library to do that sort of thing in Haskell (yet)
14:06:43 <byorgey> alar: search around and you might find some other things as well.
14:07:50 <alar> thanks
14:08:03 <fax> :t (>>=)
14:08:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:08:16 <alar> noncanonical would fit as long as it's easy to use
14:09:51 <oerjan> @src Monad
14:09:51 <lambdabot> class  Monad m  where
14:09:52 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:09:52 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:09:52 <lambdabot>     return      :: a -> m a
14:09:52 <lambdabot>     fail        :: String -> m a
14:11:18 <ndm> alar: i'm not aware of anything even "acceptable"
14:13:20 <b_jonas> that def is truncated though
14:14:58 <alar> google says there is "Network.HTTP"
14:17:09 <alexj> nomeata: found the bug, I think.  fromXml now is either Flexible or Rigid and withData should use Flexible.
14:17:17 <alexj> checking if fix works.
14:21:18 <Paczesiowa> is there function for escaping strings?
14:21:57 <P_D> there's.. unEscapeString
14:22:04 <P_D> and escapeString!
14:22:09 <P_D> hoogle for String -> String.
14:23:22 <Paczesiowa> they need predicate when to escape character
14:23:33 <fax> so write that predicate
14:23:36 <Paczesiowa> that's the only problem:D
14:23:41 <P_D> ((=) "\\") ?
14:24:04 <Paczesiowa> shouldEscape = (`elem` ['&','"'])
14:25:02 <Paczesiowa> is there a list of characters which should be escaped?
14:25:27 <P_D> find the RFC for whatever format you're talking about
14:27:17 <Vulpyne> What are you trying to escape it for?
14:27:20 <Paczesiowa> or second option, for now just escape what I need, and fix it later after something brokes killing hundreds of thousands:P
14:27:40 <nomeata> alexj: Im wondering how I can create a very simple state (lets say, a number). Am I right to assume that HAppS knows about the kind of state I want to keep by the statefuns passed to stdMain? And I create statefuns by using $[expose ] somehow?
14:27:42 <Paczesiowa> I use runCommand so I think it's for bash
14:27:53 <Vulpyne> @pl duh = (\x -> or (map (==x) "\\\"'"))
14:27:54 <lambdabot> duh = or . flip map "\\\"'" . (==)
14:28:04 <alexj> look at State.hs
14:28:15 <alexj> and you can look at prior versions of State.hs
14:28:23 <alexj> in State/State_000.hs etc.
14:29:37 <nomeata> alexj: ah, good idea. But how do I register the state with HAppS? is the name State special?
14:29:46 <fax> if you some function of type (MonadState Int t) => Tree -> t Int
14:29:56 <fax> how do you get the Int out after calling it?
14:30:05 <alexj> nope.
14:30:33 <Paczesiowa> and escapeString is deprecated
14:31:27 <P_D> what do you mean by calling it?
14:31:37 <P_D> runState?
14:31:38 <fax> I do like, sumLeavesM myTree
14:32:06 <fax> ah cool thanks
14:32:13 <sorear> @ursers
14:32:13 <lambdabot> Maximum users seen in #haskell: 407, currently: 382 (93.9%), active: 16 (4.2%)
14:32:55 <hpaste>  fax pasted "sumLeavesM" at http://hpaste.org/2786
14:33:15 <fax> so I got this sumLeavesM (Branch x y)
14:33:31 <fax> can you do this sort of thing without 'z <- get ; return z' though?
14:34:11 <fasta> fax: just get
14:34:27 <P_D> do you need to get at all?
14:34:38 <pejo> fax, you have a Monad Int and want to use the Int?
14:34:42 <fax> just get gives me (19,19)
14:34:49 <fax> and without I get (17,19)
14:34:54 <fax> so 19 is fine in both cases
14:34:55 <fasta> If you read the state, no
14:35:01 <fasta> Otherwise, yes.
14:35:04 <fax> pejo: yeah I think so..
14:35:17 <fasta> But it's a contrived example
14:35:18 <P_D> sure, you have the state and the return value
14:35:29 <Mr_Awesome> anyone here familiar with yampa at all?
14:35:32 <fasta> Since, you can trivially do this in a better way.
14:35:51 <fax> I will use this technique for something other than summing values of a tree though
14:36:39 <fax> see how (runState $ sumLeavesM testTree) 0  (19,19)
14:36:56 <fax> is there something which you can just use like: f $ sumLeavesM testTree  19
14:37:08 <fasta> fax: evalState
14:37:34 <fax> ah cool
14:37:37 <fax> so when I do (evalState $ sumLeavesM testTree) 0
14:37:39 <gpi5> :t showHex
14:37:44 <fax> 0 is like the inital value of the state?
14:37:44 <lambdabot> forall a. (Integral a) => a -> String -> String
14:37:59 <gpi5> @index showHex
14:38:00 <lambdabot> Numeric
14:38:03 <P_D> check the definition for evalState
14:40:20 <fax> ah I do need get
14:40:51 <fax> pretty cool you can change a single + into a : and it lists the leaves instead of summing them :D
14:42:48 <hpaste>  fax annotated "sumLeavesM" with "using evalState" at http://hpaste.org/2786#a1
14:43:01 <b_jonas> how does that work? don't you need to change 0 to [] as well or something?
14:43:07 <fax> b_jonas: yeah that too
14:43:23 <fax> It's neat though
14:43:34 <ekidd> OK, CUFP and the Haskell Hackathon it will be!
14:43:45 <fax> does what I annotated there have any redundancy?
14:45:16 <Lemmih> @seen Igloo
14:45:16 <lambdabot> Igloo is in #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 3h 37m 12s ago.
14:45:53 <Saizan> mmh it's a bit pointless to have sumLeavesM return something different than ()
14:46:17 <fax> but like
14:46:22 <fax> how do I get the answer otherwise?
14:46:30 <Saizan> ?type evalState
14:46:31 <byorgey> fax: it's stored in the state.
14:46:36 <lambdabot> forall s a. State s a -> s -> a
14:46:44 <Saizan> ?type execState
14:46:44 <byorgey> fax: I think you can remove the 'return y' and the 'get' from the end of sumLeavesM.
14:46:46 <lambdabot> forall s a. State s a -> s -> s
14:46:54 <fax> byorgey: that would be cool
14:46:55 <byorgey> then use execState.
14:47:38 <hpaste>  fax annotated "sumLeavesM" with "perfect!" at http://hpaste.org/2786#a2
14:47:42 <fax> thanks so much :D
14:48:57 <fax> So why is there all these different ways to exec/run/eval the state?
14:49:04 <Saizan> sumLeavesM (Leaf x) = modify (x+)
14:49:22 <fax> :o
14:49:23 <byorgey> fax: it depends on whether you want the final state, the final returned value, or both.
14:49:23 <fax> cool!
14:49:39 <fax> byorgey: ah ok
14:51:19 <byorgey> fax: in your case, you care about the final state (the accumulated sum of all the leaves), so you use execState
14:51:30 <byorgey> @type execState
14:51:33 <lambdabot> forall s a. State s a -> s -> s
14:51:57 <fax> what is a ?
14:51:59 <fax> in that
14:52:04 <fax> Int?
14:52:15 <Saizan> it's () now
14:52:31 <fax> oh ok so s is something which has Int inside it's type?
14:52:34 <int-e> a is the return value of your monadic operation
14:52:46 <int-e> s is the type of the state.
14:53:12 <nomeata> alexj: ok, I think I figured out that I can access the state with a regular ask. My own state type is now a instance of Read, Show, StartState and Default, but I still get type errors. Do I need more instances?
14:53:24 <fax> cool
14:53:43 <byorgey> in your case, s is Int, and a is ().  Try loading your code into ghci or hugs and querying the type of sumLeavesM.
14:54:00 <alexj> you need $(inferStartState) and ($inferRecordUpdaters)
14:54:24 * byorgey -> home
14:54:39 <nomeata> alexj: I cant do it by hand, without TH, to just get to know the system better?
14:54:48 <Baughn> To what degree will GHC actually reuse storage in the State monad?
14:55:08 <ndm> @seen Igloo
14:55:08 <lambdabot> Igloo is in #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 3h 47m 4s ago.
14:55:10 <alexj> you can.  I don't know how myself.  I just use the TH.
14:55:10 <int-e> Baughn: it won't
14:55:32 <nomeata> alexj: ok, thanks nevertheless
14:55:35 <int-e> @src State
14:55:36 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:55:40 <ndm> Baughn: remember, memory allocation in Haskell is nearly free, and garbage collection is free if the information is not longer required
14:55:47 <int-e> @src Control.Monad.State.State
14:55:47 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:55:51 <fax> "memory allocation in Haskell is nearly free" ?
14:55:53 <fax> What how?! :D
14:56:17 <ndm> fax: in all GC'd languages its a handful of instructions to allocate memory
14:56:22 <Baughn> ndm: Other way around. Memory allocation is a simple pointer increment, deallocation requires a gc
14:56:34 <ddarius> fax: Stack allocation usually isn't viewed as expensive (or costing anything for that matter)
14:56:39 <int-e> it's just a pointer increment. the real cost comes later though - the memory won't be in the cache.
14:56:42 <alexj> nomeata: the easiest thing to do really is mutate HAppS-Begin
14:56:50 <ndm> Baughn: no, deallocation is free,  if the memory is no longer used
14:57:03 <ndm> Baughn: what you pay for is residency, memory which is still used at garbage collection time
14:57:09 <Baughn> ndm: Hmm. Copying GC, then
14:57:10 <alexj> nomeata: eventually we will have nice docs, but for now that is the sanest way to go.
14:57:23 <Baughn> ndm: And you account the GC at allocation?
14:57:28 <ndm> Baughn: all high performance GC's are copying and collecting
14:57:37 <ndm> Baughn: no, since typically allocation doesn't require a GC
14:57:39 <nomeata> alexj: IMHO, HAppS-Begin is already too complex for a fresh start... the tutorial for 0.8.8 was quite good, for example.
14:58:06 <alexj> nomeata: that is useful feedback.  it was supposed to be simpler.  I kept putting things in it to test different aspects of functionality.
14:58:07 <Baughn> ndm: Garbage collection is fascinating, but this is getting off track. STArray at least reuses the memory, right?
14:58:18 <ndm> Baughn: that does, yes
14:58:44 <Baughn> ndm: Good. Now I just have to figure out why this FFI thingy copies my memory (literally) a thousand times.
14:58:56 <nomeata> alexj: best would be to see the development from a 5-line-hello world over a 20-line hello-world with a really simple state (e.g. a string) to more.
14:59:41 <nomeata> alexj: maybe darcs can be used there, by adding tags to the various stages. then when you make changes to the simple example, the more complex are updated as well... (just brainstorming here)
15:00:03 <Baughn> ndm: Even having an array index copied on increment is expensive when I'm iterating over a 700K image
15:01:20 <ndm> Baughn: i can imagine! personally, for iterating over a 700K image I'd use C, but hey :)
15:02:05 * ddarius would personally use machine code.
15:02:21 <nomeata> alexj: I also think that template haskell is everything but transparent if you havent at least seen once the generated boilerplate code (and their types)  I very much enjoy the help I get from reading the types of functions when figuring out how something works.
15:02:21 <Baughn> ndm: It /shouldn't/ be, though. I'm just trying to write a nice, simple image loader...
15:02:59 <psnively> An image loader in Haskell?
15:03:11 <ddarius> psnively: Why not?
15:03:12 <matthew-_> Baughn: that could be useful if you do it.
15:03:18 <sorear> Baughn: I'd use STUArray.  If it's still too slow, use Ptr.  If it's still too slow, use the FFI.
15:03:27 <matthew-_> Baughn: I pretty much dislike almost everything out there
15:03:35 <ddarius> If it's still too slow, use machine code!
15:03:43 <Baughn> sorear: The only "slow" bit is getting the data into haskell. *pouts*
15:03:52 <sorear> bytestring ftw
15:03:54 <psnively> ddarius: It doesn't exactly play to Haskell's strengths. :-)
15:03:55 <Baughn> sorear: I've been using IOArray, actually
15:04:08 <matthew-_> actually, I don't care about speed, just so long as it'll load tiffs and allow me to output rgba8, that'd be fine
15:04:19 <sorear> Baughn: you realize IOArray will not update elements in place?
15:04:21 <Baughn> matthew-_: It's an imagemagick binding - it'll load *anything*.
15:04:35 <Baughn> sorear: Ah, right. IOUArray, I mean.
15:04:40 <Baughn> sorear: been a while since I looked at it
15:04:42 <matthew-_> Baughn: hmmm. I have tiffs that imagemagick blows up on
15:04:51 <Baughn> matthew-_: Then this will blow up too
15:04:57 <ddarius> I have white noise that imagemagick blows up on.
15:05:29 <Baughn> matthew-_: I've actually got some very primitive pre-prototype-type code working, but a complete rewrite sounds good. Even the C code looks fugly.
15:05:54 <ddarius> fugly C code, I don't believe you!
15:06:07 <Baughn> ddarius: It calls abort() every other line
15:06:11 <fax> Baughn: rewriting imagemagick?
15:06:16 <Baughn> fax: No, binding
15:06:22 <fax> ah
15:06:23 <ndm> Baughn: wrap it in a monad :)
15:06:39 <ddarius> Damn, ndm got to it too quick (or maybe he's talking about something else)
15:06:44 <Baughn> ndm: Nah, a combinatory library sounds better. ;)
15:06:49 <Baughn> *combinator
15:06:59 <ndm> i meant the C code :)
15:07:06 <Baughn> Ah. I am.
15:07:14 <Baughn> It's very nicely wrapped in the IO monad. ^^
15:07:16 <ndm> or more standard, use #define's everywhere
15:07:25 <ddarius> Baughn: I think you are completely missing his intent...
15:07:37 <Baughn> ddarius: I'm not sure I want to grasp his intent
15:07:44 <ddarius> Baughn: Probably best.
15:08:18 <Baughn> Which reminds me - is there a standard way to link with C libraries?
15:08:28 <ddarius> The FFI ... ?
15:08:34 <Baughn> No, the GCC command line
15:08:35 <Baughn> I'm doing some ./configure hackery at the moment
15:08:38 <ddarius> Use GHC
15:08:45 <Baughn> Well. GHC command line.
15:08:52 <Baughn> For getting the right -l tags and such, I mean
15:09:30 <Baughn> http://brage.info/~svein/repos/imageIO/configure -- good, bad or ugly?
15:09:52 <fax> :t (-ne)
15:09:54 <lambdabot> Not in scope: `ne'
15:10:27 <Baughn> fax: Nope, no naming symbols "-anything" in haskell.
15:10:37 <Baughn> fax: Minus is a bit of a wart.
15:10:54 <Cale> :t -?ne
15:10:55 <lambdabot> parse error on input `-?'
15:10:58 <Cale> :t - ?ne
15:11:00 <lambdabot> forall a. (Num a, ?ne::a) => a
15:11:31 <fax> you can't define postfix ops in haskell?
15:11:35 <fax> (not that I want to)
15:11:40 <Philippa> nope, all operators are binary
15:12:19 <Paczesiowa> I'd love to have (:/) operator
15:12:43 <Philippa> hmm. Wonder if you can reconstitute the lot with only postfix ops?
15:12:53 <Baughn> let (:/) = (+) in 4 :/ 2
15:12:59 <Baughn> > let (:/) = (+) in 4 :/ 2
15:13:00 <lambdabot>   Not in scope: data constructor `:/'
15:13:01 <Philippa> so (1 +) wouldn't be a section, and (1 + 1) = ((1 +) 1)
15:13:15 <Paczesiowa> I want unary postfix (:/)
15:13:17 <Paczesiowa> (:/) :: String -> a
15:13:19 <Igloo> ndm: ?
15:13:27 <Paczesiowa> msg :/ = error msg
15:13:36 <ndm> Igloo: for mailing list admin do i hit Jaffacake or you?
15:13:46 <Igloo> What sort of admin?
15:14:32 <balodja> What sort is operator (-) of?
15:14:34 <balodja>  > let f x = (-x) in f 3
15:14:35 <ndm> Igloo: deleting hoogle@
15:14:43 <balodja> > let f x = (-x) in f 3
15:14:44 <lambdabot>  -3
15:14:57 <balodja> looks like unary operator
15:14:58 <ndm> balodja: use negate instead if that is your intention
15:15:08 <Paczesiowa> - is special I think
15:15:10 <Igloo> I think we can both do that
15:15:10 <ndm> balodja: its special, and not particularly pleasant
15:15:21 <Paczesiowa> and they want to get rid of it
15:15:32 <ndm> i emailed Jaffacake, since he's still listed as the mailing list person
15:15:48 <ndm> was just curious if you were the new guy for that
15:15:50 <fax> > let f x = (- x) in f 3
15:15:51 <lambdabot>  -3
15:16:13 <dolio> (:/) is the name of a constructor.
15:16:29 <Philippa> is that for general mailman@haskell.org stuff?
15:16:40 <dolio> So you can't bind it to any arbitrary function.
15:16:48 <Paczesiowa> I think you cant use : in constructors
15:16:51 <Igloo> ndm: I can do it, but I'm happy for Simon M to do so instead  :-)
15:17:07 <dolio> > 2 :+ 3
15:17:09 <ndm> Paczesiowa: you can, if an operator starts with a : it is a constructor
15:17:09 <lambdabot>  2.0 :+ 3.0
15:17:40 <Paczesiowa> right, I remembered that there was somethin special about :
15:17:59 <Paczesiowa> can constructors be postfix?
15:18:10 <fasta> Paczesiowa: H98, no.
15:18:13 <dolio> Also, the unary postfix operator extension of GHC requires parentheses around them.
15:18:46 <balodja> @hoogle (:+)
15:18:46 <lambdabot> Did you mean: (:+)
15:18:46 <lambdabot> Prelude.undefined :: a
15:18:46 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:19:20 <balodja> Oh, regex.
15:19:38 <balodja> @hoogle (:\+)
15:19:39 <lambdabot> Did you mean: (:\+)
15:19:39 <lambdabot> Prelude.undefined :: a
15:19:39 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:19:49 <balodja> damn it
15:19:59 <int-e> @type \(?) a -> (a ?)
15:20:01 <lambdabot> forall t t1. (t -> t1) -> t -> t1
15:20:45 <opqdonut> oh it's an extension?
15:20:49 <dolio> And I don't think you can define them postifx, either. So the definition would have to be '(&) foo = whatever' and the usage would always be '(foo &)'.
15:20:54 <ddarius> It's easy enough to simulate postfix, prefix, crazy fix in Haskell.
15:21:03 <dolio> Where & is replaced with whatever you're using.
15:21:15 <opqdonut> > let (&) = (+1) in (2 &)
15:21:16 <int-e> opqdonut: with Haskell98 the type would be (a -> b -> c) -> a -> b -> c
15:21:17 <lambdabot>  3
15:21:29 <opqdonut> int-e: ok
15:25:58 <LoganCapaldo> ddarius: you were not kidding. I had no freaking idea wtf was going on :)
15:28:13 <ndm> @hoogle :+
15:28:13 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':+'
15:28:59 <opqdonut> ?hoogle (:+)
15:29:01 <lambdabot> Did you mean: (:+)
15:29:01 <lambdabot> Prelude.undefined :: a
15:29:01 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:29:07 <opqdonut> :D
15:29:10 <opqdonut> great
15:29:22 <opqdonut> :t (:+)
15:29:27 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
15:29:32 <opqdonut> that looks like a weird smiley btw
15:29:49 <dolio> Did you mean what you typed? :)
15:30:04 <ddarius> Glad to help.
15:30:12 * ddarius has no idea what LoganCapaldo is talking about.
15:30:18 <opqdonut> :D
15:30:24 <balodja> @hoogle (:\\\\\\\\+)
15:30:24 <lambdabot> Did you mean: (:\\\\\\\\+)
15:30:25 <lambdabot> Prelude.undefined :: a
15:30:25 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:30:30 <LoganCapaldo> ddarius: heh
15:30:32 <opqdonut> i've got no ide about nuthin atm
15:30:38 <opqdonut> +spelling
15:30:50 <balodja> that's something... unexpected :)
15:30:52 <LoganCapaldo> the Monad videos
15:30:59 <ndm> stop breaking hoogle!
15:31:14 <ddarius> LoganCapaldo: Oh! They were lighter than I expected.
15:31:19 <balodja> ndm: what's up with it?
15:31:39 <ndm> balodja: the parsing in 3.0 isn't very good, the parsing in 4.0 is perfect, but the rest isn't finished yet
15:36:58 <EvilTerran> heh, crazyfix
15:44:26 <oerjan> > runStateT (do x <- get; y <- lift [1,2]; put 5; return (x+y)) 3 -- demonstrating for oklopol
15:44:28 <lambdabot>  [(4,5),(5,5)]
15:46:38 <LoganCapaldo> @type lift
15:46:41 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
15:47:12 <LoganCapaldo> @src StateT
15:47:13 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:47:23 <LoganCapaldo> lambdabot: mean.
15:47:36 <LoganCapaldo> @source StateT
15:47:37 <lambdabot> StateT not available
15:48:04 <smashor> hello
15:48:08 <Saizan> :t runStateT
15:48:10 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:48:21 <Saizan> hello smashor
15:49:29 <smashor> How do you distinguish between user input? If I type a, fct1 is called, if I type b, fct2, and so on. Is there a case statement in Haskell or do I have to do several if/elseif statements ?
15:49:48 <LoganCapaldo> is there a case statement in haskell?
15:49:50 <LoganCapaldo> Hah!
15:49:51 <opqdonut> yeah
15:49:57 <opqdonut> smashor: use case
15:50:14 <LoganCapaldo> case is the only statement in haskell ;)
15:50:27 <LoganCapaldo> (except its not a statement)
15:50:52 <ddarius> there is no statement
15:51:08 <opqdonut> > (\x ->  case x of 1 -> "Foo"; 2 -> "Bar") `map` [1,2]
15:51:10 <lambdabot>  ["Foo","Bar"]
15:51:11 <Olathe> "This is not a statement."
15:51:29 <LoganCapaldo> "This is a string literal."
15:51:40 <idnar> "This string literal is false."
15:51:47 <smashor> sorry, I meant switch statement instead of case statement.
15:51:50 * ddarius breaks out Tcl.
15:52:13 <Olathe> "This string is visible only because you're hallucinating."
15:52:15 <idnar> what's the difference between a switch statement and a case statement?
15:52:16 <LoganCapaldo> "String literals can't be False, they are :: [Char] not :: Bool"
15:52:35 <LoganCapaldo> idnar: teh first one only works on integral values :)
15:52:36 <ddarius> LoganCapaldo: Try asking Tcl that.
15:52:50 <ddarius> idnar: There is no switch statement.
15:52:51 * LoganCapaldo checks channel name
15:53:18 * ddarius hasn't actually touched Tcl with a ten-foot pole.
15:53:22 <jatqceer> :t case
15:53:24 <lambdabot> parse error (possibly incorrect indentation)
15:53:32 <Saizan> > (\input -> case input of 'a' -> "fct1"; 'b' -> "fct2") 'b'
15:53:34 <lambdabot>  "fct2"
15:53:50 <LoganCapaldo> ddarius: Oh drat. I was gonna ask you where tcl stood on "" vs. "false" vs. "true"
15:53:54 <jatqceer> :t (case of)
15:53:56 <lambdabot> parse error on input `of'
15:53:57 <smashor> Saizan: thanks
15:54:10 <LoganCapaldo> jatqceer: it's not a function
15:54:20 * ddarius doesn't want to know the answer to that question.
15:54:33 <oerjan> :t (do x <- get; y <- lift [1,2]; put 5; return (x+y))
15:54:34 <jatqceer> LoganCapaldo: i thought everything ought to be a function
15:54:35 <lambdabot> forall (t :: (* -> *) -> * -> *) t1. (MonadState t1 (t []), Num t1, MonadTrans t) => t [] t1
15:55:13 <LoganCapaldo> jatqceer: case isn't a function the same way "data" isn' a function
15:55:26 <LoganCapaldo> not everything ought to be a function
15:55:41 * ddarius believes case should be id and all data types Church encoded.
15:55:48 <LoganCapaldo> not unless you are a real glutton for punishment
15:55:52 <opqdonut> ddarius: :D
15:56:03 <LoganCapaldo> ddarius: it would be cool if it was syntactic sugar for that :
15:56:06 <LoganCapaldo> ::)
15:56:24 <jatqceer> "data" is a perfect function with type String, no?
15:56:35 <jatqceer> :t "data"
15:56:37 <lambdabot> [Char]
15:56:43 <LoganCapaldo> oy vey
15:56:53 <jatqceer> he prefers [Char] though
15:57:01 <Saizan> jatqceer: he meant the kayword data in e.g. data Bool = True | False
15:57:21 <Saizan> *keyword
15:57:23 <jatqceer> :t data
15:57:24 <lambdabot> parse error on input `data'
15:57:50 <LoganCapaldo> jatqceer: what type would data have, were it a function?
15:58:41 <jatqceer> SomeDefinition -> Type
15:58:48 <oerjan> :t runStateT
15:58:51 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:59:00 <LoganCapaldo> data F a = F a
15:59:27 <Saizan> LoganCapaldo: Name -> [Dec] -> Q Dec obviously :)
16:00:27 <LoganCapaldo> Saizan: what's Q?
16:00:37 <Saizan> LoganCapaldo: TH monad
16:00:43 <LoganCapaldo> heh
16:01:10 <dbueno> What's a short way to take the square root of an Int, and produce an Int?
16:01:31 <LoganCapaldo> @hoogle sqrt
16:01:32 <lambdabot> Prelude.sqrt :: Floating a => a -> a
16:01:35 <Saizan> ?type round . sqrt . fromIntegral
16:01:37 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
16:01:53 <dbueno> LoganCapaldo: sqrt says "no instance for (Floating Int)"
16:02:08 <LoganCapaldo> dbueno: I was going to go on to do what Saizn did
16:02:19 <LoganCapaldo> I just wasn't sure if the function's name was sqrt :)
16:02:25 <dbueno> LoganCapaldo:  Ah. =]  My bad.
16:02:44 <dbueno> LoganCapaldo, Saizan:  Many thanks.
16:03:07 <dbueno> It's hard for me to find my way around the numeric hierarchy of type classes.
16:03:25 <jatqceer> is there any difference between sqrt and (**0.5)?
16:03:44 <Saizan> ?type (**)
16:03:46 <lambdabot> forall a. (Floating a) => a -> a -> a
16:03:59 <fax> > (**0.5) 2
16:04:03 <lambdabot>  1.4142135623730951
16:04:05 <Saizan> uhm sqrt is probably more efficient
16:04:27 <int-e> > 2 ** 0.5 - sqrt 2
16:04:29 <lambdabot>  9.6710833785707e-17
16:04:38 <jatqceer> @check sqrt == (**0.5)
16:04:39 <lambdabot>   add an instance declaration for (Eq (a -> a))     In the expression: sqrt =...
16:05:10 <fax> @check (sqrt :: Float) == (**0.5)
16:05:10 <Saizan> @check \x -> sqrt (x ::Double) ==  x ** 0.5
16:05:11 <lambdabot>  Couldn't match expected type `Float' against inferred type `a -> a'
16:05:12 <lambdabot>  Falsifiable, after 0 tests: -3.0
16:05:17 <balodja> @src build
16:05:17 <lambdabot> build g = g (:) []
16:05:18 * LoganCapaldo would be amused if sqrt r = r ** 0.5
16:05:20 <balodja> @type GHC.Exts.build
16:05:22 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
16:05:45 <sorear> balodja: DEEP BLACK MAGIC WARNING
16:05:47 <balodja> that type is amazing to me :(
16:06:01 <LoganCapaldo> WTF
16:06:20 <int-e> @check \x -> x >= 0 ==> sqrt (x ::Double) ==  x ** 0.5
16:06:22 <lambdabot>  OK, passed 500 tests.
16:06:28 * LoganCapaldo goes to weep in a corner
16:06:30 <balodja> sorear: what's wrong? :(
16:07:09 <int-e> > 2 ** 0.5 == sqrt 2 -- hmm
16:07:11 <lambdabot>  False
16:07:19 <jatqceer> > sqrt 2 == 2 ** 0.5
16:07:20 <lambdabot>  False
16:07:29 <LoganCapaldo> using == to compare floats is bad mmkay
16:07:41 * balodja can't match (a -> b -> b) -> b -> b to (:) in mind
16:07:45 <int-e> LoganCapaldo: not if you want to test for exact equality :P
16:08:09 <jatqceer> how come "@check" passed?
16:08:18 <int-e> no idea :/
16:08:20 <balodja> b = [c]; a -> b -> b = c; ? that's nonsense
16:08:21 <fax> it said Falsifiable
16:08:23 <Saizan> you've to match (forall b. (a -> b -> b)) to (:)
16:08:31 <fax> I think that means it didn't work for -3
16:08:38 <jatqceer> @check \x -> x >= 0 ==> sqrt (x ::Double) ==  x ** 0.5
16:08:39 <Saizan> and [] with b
16:08:40 <lambdabot>  OK, passed 500 tests.
16:08:42 <int-e> fax: well NaN != NaN, that's cheap
16:08:44 <fax> :o
16:08:55 <int-e> @check \x -> sqrt (x::Double) == sqrt x
16:08:56 <lambdabot>  Falsifiable, after 0 tests: -2.0
16:09:01 <sorear> jatqceer: @check isn't exhaustive
16:09:05 <fax> > sqrt -1
16:09:06 <lambdabot>   add an instance declaration for (Num (a -> a))
16:09:06 <lambdabot>     In the expression: sqrt ...
16:09:22 <fax> > (**2) $ (**0.5) 2
16:09:23 <lambdabot>  2.0000000000000004
16:09:26 <Saizan> ?type \g -> g (:) []
16:09:27 <lambdabot> forall a a1 t. ((a -> [a] -> [a]) -> [a1] -> t) -> t
16:10:01 <jatqceer> @check \x -> x >= 0 ==> (^2) sqrt (x ::Double) ==  x
16:10:02 <lambdabot>        add an instance declaration for (Num (Double -> Double))
16:10:13 <jatqceer> @check \x -> x >= 0 ==> (^2) $ sqrt (x ::Double) ==  x
16:10:13 <lambdabot>   add an instance declaration for (Num Bool)
16:10:21 <LoganCapaldo> @check (\y -> let x = y * y in sqrt x == x ** 0.5) :: Double -> Bool
16:10:23 <lambdabot>  OK, passed 500 tests.
16:10:29 <jatqceer> @check \x -> x >= 0 ==> ((^2) $ sqrt (x ::Double)) ==  x
16:10:30 <lambdabot>  Falsifiable, after 2 tests: 4.666666666666667
16:10:48 <balodja> Saizan: thank you. that's a good cause to mdeitate :)
16:10:59 <LoganCapaldo> @type abs
16:11:01 <lambdabot> forall a. (Num a) => a -> a
16:11:15 <LoganCapaldo> @check (\y -> let x = abs y in sqrt x == x ** 0.5) :: Double -> Bool
16:11:17 <lambdabot>  OK, passed 500 tests.
16:11:28 <fax> @check (\(x :: [(Int,[Char])]) -> False)
16:11:28 <lambdabot>  Parse error in pattern
16:11:33 <LoganCapaldo> @src sqrt
16:11:34 <lambdabot> Source not found. It can only be attributed to human error.
16:11:38 <LoganCapaldo> @source Prelud
16:11:39 <lambdabot> Prelud not available
16:11:42 <LoganCapaldo> @source Prelude
16:11:42 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
16:12:03 <fax> @check (\x -> False) :: [(Int, [Char])] -> Bool
16:12:04 <lambdabot>  Falsifiable, after 0 tests: []
16:12:23 <fax> @check (\x -> if (x == []) then True else False) :: [(Int, [Char])] -> Bool
16:12:24 <lambdabot>  Falsifiable, after 1 tests: [(-2,"\997753"),(3,"\356465\170863"),(0,"\442245...
16:12:29 <fax> :O
16:12:33 <fax> how does it make test data
16:13:29 <dbueno> fax: http://www.cs.chalmers.se/~rjmh/QuickCheck/manual.html
16:13:41 <Saizan> balodja: the type of build is imposing a restriction on g, that it must work with every b, so you can apply g when b = [a] but you are also able to fuse with a foldr passing the parameters directly to g
16:13:55 <dbueno> fax: As a matter of fact, I'm trying to deal with QuickCheck at the moment.
16:14:22 <balodja> Saizan: yeah, I've missed the fact, that g is an arguement, not function itself :)
16:14:36 <oerjan> > runStateT (do x <- get; y <- lift [1,2]; put (y+5); return (x+y)) 3 -- variation
16:14:38 <lambdabot>  [(4,6),(5,7)]
16:14:43 * balodja sometimes goes crazy
16:15:20 <Saizan> balodja: well it's quite a confusing type :)
16:21:53 <oerjan> @undo do x <- get; y <- lift [1,2]; put (y+5); return (x+y)
16:21:54 <lambdabot> (get >>= \ x -> lift [1, 2] >>= \ y -> put (y + 5) >> return (x + y))
16:23:12 <oerjan> > runStateT (get) 3 :: [(Integer,Integer)]
16:23:23 <lambdabot>  [(3,3)]
16:23:46 <oerjan> > runStateT (get >>= \ x -> lift [1, 2]) 3 :: [(Integer,Integer)]
16:23:48 <lambdabot>  [(1,3),(2,3)]
16:23:49 <balodja> yeah, "DEEP BLACK MAGIC", 'build' just blows me up
16:24:09 <oerjan> > runStateT (get >>= \ x -> lift [1, 2] >>= \ y -> put (y + 5)) 3 :: [(Integer,Integer)]
16:24:10 <lambdabot>  Couldn't match expected type `Integer' against inferred type `()'
16:24:18 <oerjan> > runStateT (get >>= \ x -> lift [1, 2] >>= \ y -> put (y + 5)) 3 :: [((),Integer)]
16:24:20 <lambdabot>  [((),6),((),7)]
16:24:46 <oerjan> > runStateT (get >>= \ x -> lift [1, 2] >>= \ y -> put (y + 5) >> return (x+y)) 3 :: [(Integer,Integer)]
16:24:48 <lambdabot>  [(4,6),(5,7)]
16:27:27 <ddarius> :t build
16:27:29 <lambdabot> Not in scope: `build'
16:27:33 <ddarius> @index build
16:27:33 <lambdabot> Data.Graph.Inductive.Internal.Heap, Distribution.Simple.Build, GHC.Exts
16:31:06 <scodil> is there a way to get ghci to un-abbreviate types? Like if i have 'type Y a = X a a' and 'type Z a = Y (Y a)', can i query type of Z to find 'X (X a a) (X a a)' (or whatever it ends up being.)
16:33:00 <ddarius> scodil: Force a type error?
16:35:32 <scodil> All the errors i'm getting always use the abbreviated types. Whatever the type of the value/function is declared as. So if I say 'f :: Z a -> Z b' then my errors refer to Z, not X (X ..)
16:40:44 <ddarius> There is not yet a way to get it to expand them in general I don't believe.
16:41:22 <SamB_XP> say, who wants to join the sith?
16:48:38 <luqui> Should I be able to define an instance of (Comonad m) => ArrowApply (CoKleisli m) ?
16:48:51 <luqui> since ArrowApply is equivalent to monad
16:58:48 <balodja> > let g f b = f 32 (g f b) in let build g = g (:) [] in build g
16:58:56 <lambdabot>  [32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,...
16:59:12 <balodja> looks like (fix ((:) 32)) :)
17:00:11 * balodja can't implement the same using 'build' and 'fix'
17:01:08 <balodja> > let build g = g (:) [] in build (\f b -> fix (f 32)) -- but here 'b' is useless, that's not correct, I think
17:01:10 <sorear> balodja: but why!  you aren't supposed to know about build
17:01:10 <lambdabot>  [32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,...
17:01:25 <sorear> balodja: besides, your implementation is wrong
17:01:33 <balodja> sorear: :)))
17:02:12 <balodja> sorear: could you bring some light to this black magick? :)
17:02:37 <oklopol> > repeat 5
17:02:38 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
17:02:44 <oklopol> > repeat 5 ++ [6]
17:02:45 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
17:03:02 <oklopol> > drop Infinity $ repeat 5 ++ [6]
17:03:02 <lambdabot>   Not in scope: data constructor `Infinity'
17:03:07 <sorear> @go A Short-Cut to Deforestation
17:03:10 <lambdabot> http://citeseer.ist.psu.edu/gill93short.html
17:03:10 <lambdabot> Title: A Short Cut to Deforestation - Gill, Launchbury, Jones (ResearchIndex)
17:03:16 <oklopol> > drop (1 / 0) $ repeat 5 ++ [6]
17:03:17 <lambdabot>   add an instance declaration for (Fractional Int)
17:03:24 <oklopol> > drop (1.0 / 0.0) $ repeat 5 ++ [6]
17:03:25 <lambdabot>   add an instance declaration for (Fractional Int)
17:03:28 <oklopol> ...
17:03:33 <oklopol> bad haskell!
17:03:36 <luqui> oklopol, sometimes I wish haskell understood ordinals:  (repeat 5 ++ [6,7]) !! (w+1)
17:03:52 <oklopol> haha :)
17:04:15 <balodja> Oh, ghc has no built-in AI. Anyway, I hope so...
17:04:19 <sorear> @remember luqui oklopol, sometimes I wish haskell understood ordinals:  (repeat 5 ++ [6,7]) !! (+1)
17:04:19 <lambdabot> Done.
17:04:36 <Botje> *whoosh*
17:04:44 <luqui> sorear, uh, you forgot the omega
17:04:53 <Botje> no he didn't
17:05:01 <luqui> oh, then my irc client sucks :-)
17:05:06 <oklopol> can it only remember one piece of text per person?
17:05:11 <Botje> nawh
17:05:11 <sorear> no
17:05:15 <Botje> @quote stereo
17:05:16 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
17:05:29 <Botje> we should re-add it.
17:07:04 <oklopol> @quote oklopol
17:07:05 <lambdabot> oklopol says: you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
17:07:08 <oklopol> @quote oklopol
17:07:08 <lambdabot> oklopol says: you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
17:07:11 <oklopol> oh
17:07:13 <balodja> sorear: how to construct '[1..]' with 'build'?
17:07:24 <oklopol> > build 1
17:07:25 <lambdabot>   Not in scope: `build'
17:08:13 <sorear> @ty GHC.Exts.build (\ cons nil -> fix (\fun i -> i `cons` fun (i+1)) 1)
17:08:15 <lambdabot> forall a. (Num a) => [a]
17:09:07 <balodja> > let build g = g (:) [] in build (\ cons nil -> fix (\fun i -> i `cons` fun (i+1)) 1)
17:09:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:09:15 <balodja> Fantastic!
17:09:25 <balodja> @karma+ sorear
17:09:25 <lambdabot> sorear's karma raised to 24.
17:10:17 <z0d> What was the stereo quote?
17:10:35 <LoganCapaldo> @quote stereo
17:10:35 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
17:10:41 <LoganCapaldo> hehe
17:11:14 <ari> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:11:42 * EvilTerran wonders if ari will say ":)" if he says "@bot"
17:11:48 <Cale> ari: oh great.
17:12:07 <EvilTerran> ...
17:12:07 <EvilTerran> @bot
17:12:08 <lambdabot> :)
17:12:38 <ari> Cale: Sorry about that
17:12:41 <LoganCapaldo> @remember z0d What was the stereo quote?
17:12:42 <lambdabot> Done.
17:12:57 <Cale> ari: hehe, it's all right
17:13:37 <LoganCapaldo> No more stereo feels like the end of an era
17:14:05 * oklopol wonders if ari will say "string1" if he says "arbitrary command"
17:14:07 <oklopol> ...
17:14:09 <oklopol> arbitrary command
17:14:15 <oklopol> :P
17:15:21 <ari> oklopol, EvilTerran: Don't make me bring in rahaskella :p
17:16:04 <oklopol> it she a bot?
17:16:29 <sorear> oklopol: she isn't just a bot, she's a LAMBDAbot :)
17:16:48 * sorear wonders how many lambdabots are on FN
17:16:51 <oklopol> my bot <3
17:17:04 <oklopol> she's shy
17:17:15 <LoganCapaldo> sorear: You mean they don't coordinate? :)
17:17:23 <Botje> LoganCapaldo: .. YET :)
17:17:39 <ddarius> I believe there are at least three in constant use.
17:18:30 <balodja> Lambdabot propagates through the mind of infected haskell users.
17:18:50 <LoganCapaldo> It's in my head
17:18:54 <LoganCapaldo> get it out!!!!
17:19:05 <luqui> a carnivorous lambdabotwig
17:20:10 <LoganCapaldo> @botsnack
17:20:11 <lambdabot> :)
17:20:32 <LoganCapaldo> @botmeal
17:20:33 <lambdabot> Unknown command, try @list
17:20:58 <ddarius> conor's on LtU
17:21:31 * allbery_b wonders if he should send lopbot over here to join the bot party
17:21:40 <allbery_b> (do we have a #lambdaparty yet?)
17:28:59 <dons> some more stepcut tuts! http://programming.reddit.com/info/2qlyw/comments
17:29:00 <lambdabot> Title: Learn Haskell in 5 minutes a day: Lesson 2: IO, variable binding, and more (redd ...
17:29:06 <dons> and http://programming.reddit.com/info/2qlzj/comments
17:29:07 <lambdabot> Title: Learn Haskell in 5 minutes a day: Lesson 3: case, data and pattern matching (red ...
17:30:58 <SamB_XP> http://apps.facebook.com/jedi_vs_sith/invited.php?ui=791687424&side=2
17:31:00 <lambdabot> Title: Facebook | Incompatible Browser, http://tinyurl.com/2b7fcf
17:31:22 <SamB_XP> aww, facebook! can't you even give a title?
17:32:21 <LoganCapaldo> SamB_XP: You want to give me your username and pass so I can see that page ? ;)
17:32:50 <SamB_XP> LoganCapaldo: but I already joined the sith
17:32:58 <SamB_XP> you need to sign up if you want to join too ;-P
17:34:38 <LoganCapaldo> lambdabot needs a facebook acount
17:41:42 * FMota concurs.
17:43:11 <FMota> fun -> http://www.newgrounds.com/portal/view/365143#
17:43:12 <lambdabot> Title: The Impossible Quiz
17:43:13 <unmarshal> does a function exist that takes a list of elements: [1,2,3,4,5,6] and can group it into n groups? [[1,2], [3,4], [5,6]] ?
17:44:38 <balodja> inits, tails etc
17:45:30 <unmarshal> k, just curious, didn't want to duplicate work
17:45:30 <unmarshal> thanks
17:45:56 <sjanssen> > unfoldr (\xs -> if null xs then Nothing else Just $ splitAt 2) [1..6]
17:45:56 <fax> :t inits
17:45:58 <lambdabot>  Couldn't match expected type `(a1, [a])'
17:45:59 <lambdabot> forall a. [a] -> [[a]]
17:46:41 <sjanssen> > unfoldr (\xs -> if null xs then Nothing else Just $ splitAt 2 xs) [1..6]
17:46:42 <lambdabot>  [[1,2],[3,4],[5,6]]
17:47:32 <JohnnyL> where is haskell heading?
17:47:50 <unmarshal> thanks sjanssen
17:47:51 <Saizan> sjanssen: 'group it into n groups'
17:48:03 <sjanssen> oh, n groups, not groups of n
17:48:05 <Pseudonym> JohnnyL: Same place as Java, according to SPK.
17:48:07 <Pseudonym> SPJ
17:48:11 <unmarshal> no
17:48:13 <unmarshal> that's what i wanted
17:48:13 <JohnnyL> SPK?
17:48:13 <JohnnyL> SPJ?
17:48:14 <unmarshal> i misspoke
17:48:15 <unmarshal> thanks
17:48:25 <Pseudonym> Simon Peyton-Jones.
17:48:28 <sjanssen> JohnnyL: it seems to be gaining popularity
17:48:48 <Pseudonym> Just in the last three or so years, Haskell is cool.
17:49:03 <FMota> Java :/
17:49:18 <Pseudonym> I should explain that comment.
17:49:31 <Pseudonym> For those who haven't seen the several videos or talks where he explained this.
17:49:45 <FMota> you mean the nirvana thing?
17:49:49 <Pseudonym> Yeah.
17:49:53 <FMota> :o
17:50:00 <FMota> Java != Nirvana
17:50:01 <Pseudonym> Java is going from useful/dangerous to useful/safe.
17:50:10 <Pseudonym> And Haskell is going from useless/safe to useful/safe.
17:50:19 <Philippa> Java is never going to get there
17:50:25 <Pseudonym> No, it likely won't.
17:50:32 * FMota concurs with Philippa 
17:50:33 <Philippa> No, it definitely won't
17:50:43 <Philippa> too many baked-in design decisions that prevent it
17:50:45 <Pseudonym> But in general, modern languages are going that way.
17:50:50 <Pseudonym> C# is, too.
17:50:56 <Pseudonym> They haven't yet approached safe.
17:50:58 <Pseudonym> Or beautiful.
17:51:04 <Philippa> or non-shitty?
17:51:23 <Pseudonym> All programming languages suck.  Some just suck less.
17:51:32 <Philippa> I'm bitter though, I had to use Java for things it was definitely unsuited for
17:52:06 <Philippa> and others suck so much they eat black holes for breakfast?
17:52:23 <FMota> I like Python :)
17:52:29 <Pseudonym> Python REALLY sucks.
17:52:32 <FMota> it s by no means perfect
17:52:34 <Pseudonym> But I think most of that is the implementation.
17:52:41 <FMota> ut it doesnt get in the way, like so many others to
17:52:50 <Philippa> it would get in my way
17:52:51 <FMota> *but
17:52:51 <Saizan> python at least has first class functions
17:52:52 <FMota> *do
17:53:08 <FMota> I think the best thing about python is the error reporting
17:53:15 <FMota> it REALLY makes the language usable.
17:53:40 <fax> haskell doesn't suck
17:53:46 <fax> neither does Prolog or lisp
17:53:56 <fax> there's probably others that don't suck
17:53:59 <Philippa> Prolog sucks
17:54:00 <Pseudonym> Haskell sucks in its own way.
17:54:03 <Pseudonym> And Prolog seriously sucks.
17:54:12 <FMota> all of those suck
17:54:18 <FMota> :)
17:54:19 <Pseudonym> Lisp sucks, too.  Scheme sucks less, but it still sucks.
17:54:20 <Philippa> yeah, I've wanted extensible variants enough in Haskell lately
17:54:26 <JohnnyL> catch you guys on the flipside.
17:54:26 <fax> What do you expect?
17:54:26 <FMota> Every language sucks. English suck
17:54:30 <FMota> *sucks too
17:54:33 <fax> It's not like they're magic
17:54:33 <FMota> but we use it every day
17:54:34 <Pseudonym> English truly sucks.
17:54:42 <Philippa> English'll do anything you like so long as you pay enough, didn't you know?
17:54:54 <Pseudonym> Yeah, I heard that about English.
17:54:57 <Pseudonym> It gets around.
17:56:43 <Saizan> i want an existentially quantified case, so i can write something like print $ case foo of 'a' -> 1; 'b' -> Just 3
17:56:51 <Adamant> every language sucks, every OS sucks, every natural language sucks
17:57:13 <Pseudonym> That's not true about every OS.
17:57:14 <fax> Adamant: That's ridiculous..
17:57:23 <FMota> what we need is a brain-computer interface for programming :)
17:57:23 <Pseudonym> Emacs is a fine OS.  It's just a crappy text editor.
17:57:36 <LoganCapaldo> Saizan: I don't get it
17:57:43 <dolio> That joke sucks. :)
17:58:05 <Saizan> LoganCapaldo: the types of the brances are different but still Show-able
17:58:13 <LoganCapaldo> Ah
17:58:27 <LoganCapaldo> why do you want that?
17:58:47 <Philippa> because someone can't be arsed to pack first
17:59:00 <Saizan> because now i've to write case foo of 'a' -> print 1; 'b' -> print $ Just 3
17:59:22 <LoganCapaldo> I clearly didn't make my question specific enough :)
17:59:42 <LoganCapaldo> What's the scenario that you're finding youself doing that?
17:59:49 <LoganCapaldo> I'm just curious\
18:00:26 <Saizan> lambdabot: foo is a command from the user, the other are the results
18:16:58 <balodja> sorear: could you give some useful links on papers and articles about 'fix', please? :)
18:17:23 * balodja seems not to understand, how to use it
18:17:35 <Saizan> > fix ((1:) . scanl (+) 1)
18:17:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:21:40 <Saizan> balodja: http://en.wikipedia.org/wiki/Fixed_point_combinator may be a start
18:22:43 <balodja> Saizan: as I understand, in above example with 'build' 'fix' is used to construct a function -- that totally confuses me
18:24:41 <Saizan> balodja: yes, because fix is used for anonymous recursion
18:25:20 <Saizan> > let fac self n = if n == 0 then 1 else n * self (n-1) in fix fac 5
18:25:31 <lambdabot>  120
18:26:05 <balodja> Great!
18:27:35 <balodja> Saizan: thanks, now I understand, what's going on :)
18:28:01 <Saizan> fix f = f (fix f), so there fix fac 5 = fac (fix fac) 5 = 5 * (fix fac) 4 = 5 * fac (fix fac) 4 = 5 * 4 * (fix fac) 3 = ..
18:28:34 <LoganCapaldo> fix fac, tic tacs
18:28:49 <jfredett> mhm
18:29:19 <jfredett> Excellent rhyming, Capaldo.
18:30:53 <LoganCapaldo> that doesn't rhyme...
18:31:12 <jfredett> it's a feminine rhyme
18:31:20 <jfredett> /approximate rhyme
18:33:40 <LoganCapaldo> if you say so
18:51:09 <LoganCapaldo> @type let list `at` 0 = head list ; (_:xs) `at` (n+1) = xs `at` n in at -- too sugary?
18:51:11 <lambdabot> forall a t. (Integral t) => [a] -> t -> a
18:51:33 <LoganCapaldo> `` and n+k pattern in a single definition
18:51:50 * LoganCapaldo eagerly awaits being shown u
18:51:53 <EvilTerran> what's wrong with (!!)?
18:51:56 <LoganCapaldo> *up
18:51:57 * SamB_XP wonders how lambdabot would know what friend requests to accept if she had a facebook account...
18:52:14 <LoganCapaldo> EvilTerran: nothing
18:52:50 <kpreid> does n+k ever get used with k /= 1?
18:53:32 <EvilTerran> well, it has to be a constant...
18:53:40 <dolio> > let fib 0 = 1 ; fib 1 = 1 ; fib (n + 2) = fib (n + 1) + fib n in fib 10
18:53:40 <lambdabot>  Parse error in pattern
18:53:43 <kpreid> well, yes
18:53:56 * FMota is interested in (humane) total functional programming.
18:54:31 <LoganCapaldo> > let fib 0 = 1 ; fib (n+2) = fib (n+1) + fib n in fib 10
18:54:31 <lambdabot>  Parse error in pattern
18:54:46 <LoganCapaldo> mysterious
18:54:49 <EvilTerran> ?type  let fib 0 = 1 ; fib (n+2) = fib (n+1) + fib n in fib
18:54:51 <lambdabot> forall t t1. (Integral t, Num t1) => t -> t1
18:55:04 <EvilTerran> the syntax checker > uses is neurotic
18:55:08 <oerjan> LoganCapaldo: no n+k patterns in @run
18:55:14 <EvilTerran> doesn't support (n+k) for some reason
18:55:20 <LoganCapaldo> mmmph
18:55:49 <balodja> May be because (+) is not a constructor?
18:56:24 <LoganCapaldo> balodja: n+k only works with +...(and -?)
18:56:53 <LoganCapaldo> @type f (n-1) = n
18:56:56 <lambdabot> parse error on input `='
18:57:03 <LoganCapaldo> @type let f (n-1) = n in f
18:57:05 <lambdabot> Parse error in pattern
18:57:10 <P_D> this is where you bust out numbers where + IS a constructor =)
18:57:29 <oerjan> not possible
18:57:47 <oerjan> constructor operators must start with :
18:58:10 <P_D> oh just drop the operator
18:58:21 <P_D> Add(n,k) is just as good
18:58:25 <Cale> However, you can define a constructor Plus and set (+) = Plus
18:58:53 <Cale> Or just use :+: or some such
18:59:18 <oerjan> you cannot get Add(n,2) to pattern match the same as Add(Add(n,1),1)
18:59:54 <fax> Add?
18:59:57 <fax> Succ :)
19:00:04 <P_D> yes thank you fax
19:00:19 <LoganCapaldo> If this were prolog and not haskell you could :)
19:00:36 <EvilTerran> can you do it with type families?
19:01:12 <EvilTerran> ...probably not, thinking about it; if you took the right view proposal, you could, though
19:01:18 <LoganCapaldo> I don't think type failies would magically give you different pattern matching, do they?
19:01:36 <EvilTerran> anyway, oerjan, you can't say f(n+1+1) = ... in the current system either
19:01:53 <balodja> LoganCapaldo: prolog knows, how to turn functions into? :)
19:01:58 <EvilTerran> ...or is that not what you meant?
19:02:08 <P_D> not really a useful criticism regardless terran
19:02:37 <oerjan> :t f ((n+1)+1) = 2 in f
19:02:42 <lambdabot> parse error on input `='
19:02:50 <oerjan> :t let f ((n+1)+1) = 2 in f
19:02:52 <lambdabot> Parse error in pattern
19:03:14 <oerjan> strange, not allowed?
19:04:42 * balodja imagines: > let f (even n) = n in f True
19:04:50 <dolio> Well, then, screw Haskell. I'm going to use Ultimate++.
19:05:10 <fax> balodja: Prolog!
19:05:19 <oerjan> ah, indeed not
19:06:27 <dolio> Yeah, but in Prolog you'd have to write: f(N,N) :- even(N).
19:06:42 <EvilTerran> balodja, wait, what?
19:07:29 <fax> ?- even(N). will show you every N which is even
19:07:29 <lambdabot> Maybe you meant: . v
19:07:43 <balodja> EvilTerran: (+) is a function, isn't it? It may be even overloaded, as I remember
19:07:44 <dolio> Or, wait, I was reading that wrong.
19:08:03 <balodja> > let 1 + 1 = 4 in 1 + 1
19:08:05 <EvilTerran> yes...
19:08:06 <lambdabot>  4
19:08:12 <balodja> so...
19:08:21 <EvilTerran> your types are all funny
19:08:33 <fax> > let 1 + x = 1+1/x in 1+1+1+1+1+1+1
19:08:34 <lambdabot>  Exception: <<loop>>
19:08:37 <fax> bah
19:08:51 <fax> > let 1 + x = 1/x-(-1) in 1+1+1+1+1+1+1
19:08:52 <lambdabot>   Non-exhaustive patterns in function +
19:09:03 * fax gives up :|
19:09:26 <dolio> > let 1 + x = 1 Prelude.+ 1/x in 1+1
19:09:28 <lambdabot>  2.0
19:09:37 <Cale> > let 1 & x = 1+1/x in 1 & 1 & 1 & 1 & 1 & 1 & 1
19:09:38 <lambdabot>   Non-exhaustive patterns in function &
19:09:44 <LoganCapaldo> > let 1 + x = 1 Prelude.+ 1 / x in 1 + 1 + 1 + 1 + 1
19:09:46 <lambdabot>   Non-exhaustive patterns in function +
19:09:50 <balodja> If I type > let 1 + 1 = 4 in let f (n + 1) = n, than I archive an ambiguity
19:10:00 <wli> You need x + y = 1/x + 1/y or similar.
19:10:22 <LoganCapaldo> > let 1 + x = 1 Prelude.+ 1 / x in 1 + (1 + (1 + (1 + 1)))
19:10:24 <lambdabot>  1.6
19:10:27 <Cale> > let 1 & x = 1+1/x in 1 & (1 & (1 & (1 & (1 & (1 & 1)))))
19:10:29 <lambdabot>  1.6153846153846154
19:10:36 <oerjan> > let 1 + x = 1 Prelude.+ 1 / x; infixr 9 (+) in 1 + 1 + 1 + 1 + 1
19:10:37 <lambdabot>  Parse error
19:10:37 <balodja> So, how to use (+) in patterns in that way then?
19:10:49 <fax> > let x + 1 = 1 Prelude.+ 1 / x in 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
19:10:50 <lambdabot>  1.618034447821682
19:10:57 <oerjan> > let 1 + x = 1 Prelude.+ 1 / x; infixr 9 + in 1 + 1 + 1 + 1 + 1
19:10:58 <lambdabot>  1.6
19:11:01 <P_D> series for golden ratio?
19:11:16 <P_D> partial fraction anyway or whatever
19:11:17 <Cale> yeah, continued fraction expansion
19:11:35 <wli> > let x & y = 1/x + 1/y in take 20 $ iterate (1 &) 1
19:11:37 <lambdabot>  [1.0,2.0,1.5,1.6666666666666667,1.5999999999999999,1.625,1.6153846153846154,...
19:11:45 <fax> nice
19:11:47 <P_D> is there a systematic way to generate those expansion from an analytic function?
19:11:58 <wli> P_D: Yes, Euler's inversion formula.
19:12:04 <wli> P_D: See wikipedia.
19:12:55 <balodja> Just a square equation.
19:13:15 <LoganCapaldo> > foldr g 1 [1,1..] where g x acc = x + acc / x
19:13:16 <lambdabot>  Parse error
19:13:37 <LoganCapaldo> > let g x acc = x + acc / x in foldr g 1 [1,1..]
19:13:40 <lambdabot>  Exception: stack overflow
19:13:54 <LoganCapaldo> > let g x acc = x + acc / x in foldr g 1 (replicate 100 1)
19:13:56 <lambdabot>  101.0
19:13:56 <wli> See the fundamental recurrence relation.
19:14:04 <LoganCapaldo> I done messed it up
19:14:24 <fax> x-1 = 1/x  x = 1+1/1+1/1+1/...
19:14:35 <sorear> balodja: I'd suggest learing about fixed point combinators, domain theory, Kleeene's fixed point theorem, and for good measure Tait's strong normalization theorem for the simply-typed lambda calculus
19:14:49 <sorear> balodja: Curry's Paradox is also relevant
19:14:55 <LoganCapaldo> > let g x acc = acc + x / acc in foldr g 1 (replicate 100 1)
19:14:57 <lambdabot>  14.284064040284603
19:15:05 <LoganCapaldo> still done messed it up
19:15:11 <wli> http://holomorphy.com/~wli/ContFrac.hs
19:15:30 <wli> That's not all mine but it takes care of the details.
19:15:42 <sorear> and yes I DID mis-spell Stephen Kleene's last name
19:15:54 <balodja> sorear: thanks again
19:16:13 <FMota> > let g x acc = 1 + 1 / x in foldr g 1 (replicate 100 1)
19:16:15 <lambdabot>  2.0
19:16:21 <FMota> :o right
19:17:02 <EvilTerran> balodja, the use of "+" in n+k patterns is completely independent of the use of it as a (redefinable) infix operator
19:17:31 <EvilTerran> it just happens to act all prolog-y and magic if you don't redefine (+)
19:18:04 <balodja> So, there are at least 2 different (+)? A bit confusing
19:18:30 <nburlett> anyone have a suggestion for how to fix: No instance for (Data.Time.Format.Parse.ParseTime Day)
19:18:43 <nburlett> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Format.html clearly says there is one
19:18:45 <lambdabot> http://tinyurl.com/35mu4q
19:18:56 <sorear> nburlett: You didn't import it
19:19:03 <sorear> nburlett: Find the right module
19:19:21 <nburlett> sorear: I have import Data.Time.Format (readTime)
19:19:28 <nburlett> sorear: how do I import just the instance?
19:19:33 <sorear> well, that's obviously wrong.
19:19:42 <sorear> there is some module you need to import.
19:19:50 <sorear> No, hoogle won't find it for you
19:19:55 <sorear> grep is your friend
19:19:56 <sorear> :(
19:20:09 <sorear> s/hoogle/haddock/
19:20:19 <LoganCapaldo> mmm fish
19:20:22 <EvilTerran> balodja, n+k patterns are contraversial syntactic sugar
19:20:27 <Cale> It's probably Data.Time.Calendar
19:20:39 <sorear> haddock tells you WHAT instances exist, but not WHERE they are defined
19:20:44 <sorear> you have to find that yourself
19:20:45 <EvilTerran> depending on how you want to look at it, it may help to think of the + in n+k patterns as always being Prelude.+
19:21:10 <nburlett> sorear: aha! System.Time.Day != Data.Time.Calendar.Day
19:21:32 <LoganCapaldo> Cale: do you come in a standalone command line version?
19:21:41 <Cale> LoganCapaldo: heh
19:21:58 <nburlett> huzzay
19:22:30 <Cale> Yeah, but I'm not sure you have enough memory to run me.
19:22:51 <oerjan> @remember LoganCapaldo Cale: do you come in a standalone command line version?
19:22:52 <lambdabot> Done.
19:23:14 <Cale> Ever heard of Echelon?
19:23:21 <ddarius> n+k patterns have been "discouraged" since at least Haskell 1.3
19:28:02 <dons> the oxford guys like 'em, I'm told
19:28:23 <EvilTerran> Bird didn't mention 'em when he was lecturing us, iirc
19:28:52 <dons> oh, that's interesting
19:28:54 <LoganCapaldo> what's with you people and getting to learn haskell from lectures? :)
19:29:01 <dons> heh
19:29:10 <dons> yeah, gee, learning stuff at school. that's for dummie! :)
19:29:18 * ddarius wonders what feature for what language has longest been "semi-officially deprecated".
19:29:19 <dons> s.
19:29:24 <dons> heh
19:29:32 <dons> ddarius: dynamic scope in lisp?
19:29:46 <dons> circa 1958 or some such.
19:29:46 <ddarius> dons: I was thinking something like that too.
19:30:06 <dons> bit fields in C?
19:30:08 <ddarius> CL and Scheme did get rid of it for the most part, though elisp carries the torch.
19:30:14 <dons> go elisp!
19:30:38 <TSC> For C, what about old-style argument declarations for functions?
19:30:40 <Cale> Yeah! Maintain that confusing misfeature!
19:30:49 <Adamant> bit fields are still used
19:31:03 <ddarius> n+k patters are still used
19:31:54 <LoganCapaldo> Bit fields are definitely still used
19:32:01 * LoganCapaldo twitch
19:32:08 <Adamant> :)
19:32:43 <phobes> Bit fields are deprecated?
19:33:11 <LoganCapaldo> The question isn't are they deprecated, its are they "semi-officially deprecated"
19:33:49 <LoganCapaldo> Like n+k in haskell, or prototypes in perl
19:34:10 <phobes> So bit-fields are semi-officially deprecated?
19:34:17 <LoganCapaldo> I dunno
19:34:18 <shteou> n+k? :o
19:34:31 <wli> I'd actually like m*n+k patterns, never mind n+k.
19:34:59 <wli> f (3*n) = ... ; f (3*n+1) = ... ; f (3*n+2) = ...
19:35:12 <sjanssen> wli: you're nuts
19:35:12 <LoganCapaldo> I'd like f k patterns, never mind n+k :)
19:35:40 <wli> sjanssen: What's so nuts about it?
19:35:43 <LoganCapaldo> Make the patterns powerful enough and I won't have to write any programs anymore :)
19:36:12 <wli> sjanssen: It's how people actually write things.
19:36:12 <sjanssen> wli: too much computation on the LHS
19:36:26 <Pseudonym> Yeah, there's the "write the program for you" pattern.
19:36:46 <phobes> Prime factorization patterns would help everyone write toy programs easier
19:36:51 <sjanssen> wli: it makes the language larger without a large enough gain, IMO
19:36:54 <wli> sjanssen: For the most part you can flag anything that isn't a simple case like what I wrote as an error.
19:36:54 <phobes> p * n = ...
19:37:16 <P_D> if you can specify a sufficiently general set of trivially invertible 1-to-1 functions, why not
19:37:21 <Cale> I want RSA patterns
19:37:44 <FMota> <3 Bob Marley + FP
19:37:49 <wli> sjanssen: e.g. if the multiplier m doesn't match in all branches.
19:38:56 <sjanssen> IMO, case divMod x 3 of (n, 1) -> -- is good enough
19:39:44 <wli> f x | (q, r) <- x `quotRem` 3 = case r of { 0 -> ... ; 1 -> ... ; 2 -> ... ; _ -> error "wtf?" } is crap.
19:40:02 <ddarius> Is parsing left to right?  What does let m*n+k = ... in ... bind?
19:40:06 <sjanssen> pattern guards only complicate the code there
19:40:20 <sjanssen> wli: I think the case example I provided is perfectly clear
19:40:36 <wli> sjanssen: Only r is pertinent to the case statement.
19:40:37 <balodja> P_D: iirc, patterns are used to uncover thunks in lazy computations, and following this idea function calls should be totally deprecated there
19:40:37 <LoganCapaldo> If only there was someway to amke Haskell's syntax more complicated...
19:41:14 <LoganCapaldo> Will TH make it into Haskell' ?
19:41:20 <ddarius> God no.
19:41:27 <wli> ddarius: let m*n+k = x in ... desugars to let (n, k) = x `quotRem` m in ...
19:41:30 <P_D> that makes sense.  I don't really know what I'm talking about, still new to haskell.
19:41:33 <sjanssen> wli: I think this is a slippery slope, first n+k, then m*n+k, what next?
19:42:00 <ddarius> wli: Why not a definition of * or +?
19:42:16 <sjanssen> wli: that desugaring is faulty, you need to use a case or guard in case the pattern doesn't match
19:42:21 <wli> sjanssen: Nothing. Anything much more complex gets you into implicit integer linear equation problems.
19:43:17 <ddarius> Do I have to write m*n+0 for factors of m?
19:43:46 <wli> sjanssen: The m in m*n+k has to be explicitly provided at all times save for when it's 1.
19:43:50 <sorear> omega test ftw
19:44:32 <wli> The m*n+k patterns as I conceive of them are truly dirt simple.
19:45:23 <shteou> Goodnight all :)
19:45:28 <sjanssen> they're as simple as n+k patterns (which are nearly universally despised)
19:45:31 <shteou> Tired of waiting for TF2 beta release ;)
19:46:13 <phobes> What have you been waiting about 10 years?
19:46:43 <wli> sjanssen: Why are they despised?
19:47:21 <ddarius> wli: Because even the "dirt simple" n+k patterns aren't actually all that simple.
19:47:22 <wli> AFAICT they do what a great deal of other Haskell syntax does; they make the code look sexy.
19:47:26 <shteou> phobes, I've been waiting for about 3 hours... I'm just getting teasted by Valve :(
19:47:36 <shteou> I only want to see the soft particle effects on the pyro's flamethrower heh
19:47:44 <wli> ddarius: Where is the hidden complexity in n+k patterns?
19:47:44 <ddarius> Most other Haskell syntax is either consistent or independent.
19:48:04 <shteou> teasted... half way between teased and tested :x
19:48:08 <shteou> Cya'll later.
19:48:32 <sjanssen> wli: it's a rarely used special case
19:48:54 <wli> sjanssen: But where is the hidden complexity?
19:48:56 <ddarius> wli: One area is how it interacts when nested and defining +, another is it's seemingly arbitrary limitations, a third is the inconsistency + isn't a constructor, a fourth is why just +.
19:49:05 <sjanssen> wli: perhaps if there were a general way to describe computations on the LHS (like views), they'd be okay
19:49:52 <sjanssen> wli: does (0+n) work?
19:50:51 <sjanssen> wli: should ((n+1)+1) work?
19:51:46 <phobes> Do those two not work currently?
19:52:07 <sjanssen> wli: ((x :+ k) + 1)?
19:52:16 <sjanssen> phobes: not in ghci
19:52:36 <ddarius> I think Simon Marlow had some "nice" examples of extremely confusing parses.
19:53:57 <wli> sjanssen: 0 + n should probably flag a warning. ((n+1)+1) should work. ((x :+ k) + 1) should work.
19:54:10 <sjanssen> wli: none of them do
19:55:04 <ddarius> wli: let f (n+1) = n in f 0 -- Should that match or fail?
19:56:57 <sjanssen> more: (n + 0.5), (n + (1 :+ 0))
19:57:18 <wli> ddarius: Fail.
19:57:34 <wli> sjanssen: n+k should puke on non-integral types.
19:58:03 <phobes> wli:  why should ddarius' example fail?
19:58:30 <wli> phobes: Inexhaustive pattern match.
19:58:47 <EvilTerran> shouldn't n become -1?
19:59:38 <wli> EvilTerran: Plausibly; however, the desugaring should generate a case statement with inexhaustive pattern matches.
20:00:13 <EvilTerran> alrighty then
20:00:26 <sorear> wli: how about just adding the omega test as a library with Simon's lightweight views proposal?
20:00:28 <wli> I should clarify that the failure be runtime in the f (n+1) = n case.
20:00:48 <wli> sorear: That would be even nicer.
20:01:08 <phobes> sorear:  Do you have a link to this proposal?
20:01:19 <sorear> @ghcwiki ViewPatters
20:01:21 <lambdabot> No Result Found.
20:01:34 <sorear> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
20:01:37 <lambdabot> Title: ViewPatterns - GHC - Trac
20:01:38 <phobes> thanks
20:02:25 <wli> I have nothing against even more general methods of implementing all this.
20:04:05 <ddarius> wli: How do you desugar f (n+1) = n into a case?
20:07:58 <phobes> Why do we want  n + k to turn into a case?   Why not produce negative matches and use earlier cases to gaurd?
20:07:59 <wli> ddarius: There's no base case because it lacks a clause with a constant argument, so it ends up degenerate.
20:08:04 <phobes> guard *
20:09:15 <phobes> wli: That doesn't sound very simple :)
20:09:44 <ddarius> wli: I just want to see the output.
20:09:57 <phobes> I see, you want   f 4 = .... ;  f (n+1) = ... ;    with 0 - 3 remaining undefined?
20:10:06 <wli> f const1 = ... ; f const2 = ... ; ... ; f (n + k) = ... --> case x of { const1 -> ... ; const2 -> ... ; ... ; _ -> let n = x - k in ... }
20:10:35 <wli> Where const1, const2, ..., k must all be constants or literals.
20:10:54 <phobes> wli:  ok, that sounds simple
20:13:15 <ddarius> wli: So following that scheme my code would be f x = case x of  _ -> let n = x - k in ... There is no inexhaustive pattern match here.
20:14:35 <wli> ddarius: True, though I'm not happy with letting it pass so easily. Might as well ignore the "problem" since it seems to have the intended effect.
20:19:29 <DukeDave> I have a complaint! :)
20:20:03 <DukeDave> Why when defining a class do you have to give the entire minimal specification in one block?
20:20:37 <DukeDave> (I realise that probably sounds like a rather strange issue to have)
20:20:56 <dibblego> what do you propose as the alternative?
20:21:11 <ddarius> DukeDave: ?  You have to provide all the defaults in the class declaration anyway... ?
20:22:06 <DukeDave> You could have, for example "class Foo a where" appearing in two files, each containing different function name / type signatures
20:22:36 <phobes> DukeDave:  Can you do what you want with an auxillary typeclass(es)?
20:23:32 <sjanssen> DukeDave: yes, that is a very strange issue to have
20:23:36 <DukeDave> phobes: An auxiliary typeclass?
20:23:52 <phobes> class HalfOfFoo a where ...
20:24:04 <phobes> Then have HalfOfFooa => Foo a later
20:24:26 <DukeDave> I don't actually 'need' a solution, but I was wondering if there is a good technical reason why it's not possible?
20:25:17 <DukeDave> phobes: Ah I see, unfortunately not in my case..  It's more of an extensibility issue, so someone could come along and add extra funcs to a typeclass & provide their own implementations
20:25:42 <DukeDave> (Without having to modify any of 'my' module)
20:25:50 <sjanssen> DukeDave: how can you know that the user intends to extend the class and not just introduce another of the same name
20:26:06 <phobes> DukeDave:  Anyone knowing about the new operations could know about the new typeclass?
20:27:01 <DukeDave> sjanssen: May be would could have something nice like "class Foo a continues"  :)
20:27:34 <sjanssen> DukeDave: I think you've spent too much time with Ruby or something :)
20:27:38 <phobes> If I want to go add a **!!**!! operator to Monad, then why wouldn't I just put it in a new ExtremeMonad class and then be able to indicate any function that relies on this operator by using the correct class?
20:27:39 <DukeDave> phobes: Not sure I understand, it is an odd situation by the way
20:28:40 <phobes> DukeDave:  Ya, I'm just trying to understand the situation where it would be useful
20:28:47 <ddarius> DukeDave: And what if I "continue" a class later?  How is all the rest of the code going to know what to do?
20:29:05 <ddarius> I don't know what the instances are and they don't know what I've added to the class.
20:29:27 <DukeDave> ddarius: Do we have 'later' in Haskell?
20:29:47 <DukeDave> ddarius: Being that it's all declarative so order shouldn't matter?
20:30:08 <Cale> DukeDave: we have it at the module level
20:30:09 <sjanssen> DukeDave: we don't have a later, which makes it even worse :)
20:30:14 <ddarius> DukeDave: The problem is if I import a module containing a class and make some instances I don't know what happens in some other module.
20:30:15 <sjanssen> we have some bizarre tree like structure
20:30:24 <sjanssen> graph like, even
20:30:26 <ddarius> Directed Cyclic Graph.
20:30:33 <DukeDave> I guess 'continues' is a bad notation then, just allowing multiple 'where' would be useful here
20:31:09 <sjanssen> DukeDave: I think we all want to hear what your use case is
20:31:27 <phobes> DukeDave:  There's two parts to classes - class definitions and instance definitions.  Instances have to define every method defined by the class.  What happens to all other instances if you add a new method?  Are you thinking there would be a "default" implementation in terms of the other methods?
20:32:46 <DukeDave> phobes: Yes that's more or less it, I'll just type down an explanation...   :)
20:33:50 <phobes> Haskell does have default method definitions doesn't it?
20:33:50 <ddarius> You could just define a function that uses the class in that case.
20:33:55 <ddarius> phobes: It does.
20:34:27 <phobes> ddarius: but then you couldn't override it for particular instance :)
20:34:41 <ddarius> phobes: You shouldn't want to "default methods" is a bit of a misnomer.
20:34:50 <ddarius> phobes: A "default" should always work.
20:35:12 <phobes> ddarius:  oh, I actually meant 'default' but overrideable... does haskell not allow you to do that?
20:35:30 <ahanwadi> hi, I need some help in using the Parsec library
20:36:06 <ddarius> phobes: You can override it, but you should never need to unless the default declarations are circular and you need to break the cycle (the usual case).  That case never happens with DukeDave's situation.
20:36:16 <ahanwadi> I am trying to parse identifiers for ASN.1 notations. The rules state that identifier is composed of letter or digit or '-' and it cannot end in a '-'
20:36:21 <DukeDave> I'm dealing with different underlying representations so my type class abstracts the representation away. I'm providing a 'starter kit' of functions over these representations (so the current minimal def and a set of implementations for each representation).     Later someone might want to extend my basic set with a new function, but if they want there function to work with more than one of the representations then they h
20:36:21 <DukeDave> ave to modify my given minimum definition (i.e. in my .hs file)
20:36:34 * DukeDave reads back
20:36:36 <ahanwadi> Is there any way to specify the rule that identifier should not end in a hypen?
20:36:59 <ddarius> ahanwadi: Yes, two ways.
20:37:31 <vagif> Hello, I need to write a small script, and I thought I could use haskell instead of python. BUt i'm not sure if all the libraries i need are there.
20:37:41 <vagif> I need:
20:37:42 <ddarius> The "proper" way would be to make it parseIdentifier >> parseEveryIdentifierLetterButHyphen
20:38:04 <vagif> Db library - HDBC works fine for me.
20:38:15 <sjanssen> DukeDave: do you always have a default implementation for these new functions?
20:38:27 <vagif> file / folder manipulation (folder creation, file copying etc.) ?
20:38:43 <vagif> sending emails
20:39:07 <ddarius> Yes, and yes albeit I believe you have to do a bit of digging for the email stuff.
20:39:43 <ddarius> vagif: See hackage.haskell.org and..
20:40:03 <ddarius> http://www.haskell.org/haskellwiki/Applications_and_libraries and a few other places if those don't do you
20:40:04 <lambdabot> Title: Applications and libraries - HaskellWiki
20:40:15 <DukeDave> sjanssen: Forgive me, I'm not quite clear on what you mean by 'default', do you mean does every instance always have an definition of each function in the class def?
20:40:19 <vagif> thx i'll try that
20:40:40 <sjanssen> DukeDave: does the class definition have defaults for all the functions
20:40:49 <sjanssen> eg. class Foo a where foo :: a -> a; foo = id
20:40:53 <DukeDave> sjanssen: Or hang on, no, you mean a definition of the function in the class definition
20:40:56 <DukeDave> Right :)
20:41:08 <DukeDave> Answer: No
20:41:13 <sjanssen> okay
20:41:15 <ddarius> Good.
20:41:20 <sjanssen> DukeDave: I think you want separate classes
20:41:29 <sjanssen> class Foo a where foo :: ...
20:41:30 <phobes> DukeDave:  And you don't just want a new class FooWithNewOperator ?
20:41:32 <wli> I've started turning on all warnings and they spit out something whenever defaulting rules are actually used. I explicitly assign a monomorphic type to resolve all such warnings.
20:41:50 <sjanssen> class Foo a => FooWithBar a where fooWithBar :: ...
20:41:50 <ahanwadi> ddarius, I tried that. It doesn't work. It matches empty input.
20:42:06 * phobes agrees with sjanssen
20:42:09 <wli> This works well for me, though I can't remember where I actually got burned by defaulting rules.
20:42:37 <ddarius> ahanwadi: It can't match empty input for a reason meaning going from the names.  If nothing else, parseEveryIdentifierLetterButHyphen parses exactly one character.
20:43:04 <DukeDave> sjanssen: Ah yes I see how that would be possible now
20:43:22 <ddarius> But perhaps that name is misleading, how about satisfy (\c -> isIdentifierLetter c && c /= '-')
20:44:04 <ahanwadi> Actually, for the second parse, I used 'many', combinator as the first letter has to be a upper case letter
20:44:53 <ddarius> ahanwadi: Write parseEverythingButTheLastLetterOfAnIdentifier >> parseLastLetterOfIdentifier
20:45:13 <ahanwadi> the first parser is like this: (u <- upper; md <- many (alphaNum <|>  char '-'); return ([u]++md)
20:46:08 <ddarius> [u]++md = u:md, but this is irrelevant.
20:47:24 <ahanwadi> Since, the first parser, consumes atleast a single character, I cannot use 'many1 (alphaNum)' for the second parser
20:49:06 <ddarius> ahanwadi: You don't need to parse "the rest" just the last character, however the constraint that the first character is uppercase brings up a slightly kink.
20:50:39 <ddarius> ahanwadi: So you have liftM (:[]) upper <|> (do u <- upper; md <- many (alphanum <|> char '-'); ml <- alphanum; return u:md++[ml])
20:50:58 <ddarius> Except with Parsec, that needs a little help since that requires two characters of lookahead.
20:51:05 <oerjan> ignoring collecting the result, what about many alphaNum >> many (char '-' >> many1 alphaNum)
20:52:33 <ddarius> (At least in theory, in practice if <|> is biased...)
20:52:34 <oerjan> not ignoring, liftM2 (++) (many alphaNum) (liftM2 (:) (char '-') (many1 alphaNum))
20:53:52 <oerjan> this should not require extra lookahead
20:55:15 <oerjan> er, forgot a many
20:55:35 <oerjan> liftM2 (++) (many alphaNum) (many (liftM2 (:) (char '-') (many1 alphaNum)))
20:56:36 <ddarius> oerjan: Won't that fail to parse Foo--?
20:56:45 <oerjan> is that allowed?
20:57:29 <oerjan> the identifier should not end in a -
20:57:46 <oerjan> oh wait, see what you mean
20:57:46 <ddarius> Sorry, add an x at the end Foo--x
20:58:02 <oerjan> liftM2 (++) (many alphaNum) (many (liftM2 (:) (many1 (char '-')) (many1 alphaNum)))
20:58:23 <ddarius> Need to shift (:) to (++)
20:58:30 <oerjan> liftM2 (++) (many alphaNum) (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))
21:00:11 <ddarius> With liftM (:) upper  tacked to the beginning, that looks like it should also work.
21:00:26 <oerjan> i don't think some of the others work
21:00:59 <oerjan> the problem is that the last character fits the pattern of the others
21:01:11 <oerjan> so it will be gobbled up by that
21:03:43 <ddarius> oerjan: Huh?
21:04:55 <oerjan> when using the parser many (alphanum <|> char '-'), it will gobble up everything including the last character.  Parsec does no backtracking in this case.
21:06:10 <ddarius> oerjan: I did say that it needs help due to requiring two character lookahead though admittedly I was thinking of something else.
21:06:23 <oerjan> ok
21:07:07 <ddarius> Having a parseRegex :: String -> Parser String would likely be ideal for this case.
21:08:29 <ahanwadi> None of the above attempt worked.
21:08:47 <oerjan> oh?
21:08:56 <ahanwadi> I might try use the token parser. Is that portable?
21:09:29 <oerjan> what went wrong with liftM2 (++) (many alphaNum) (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))
21:09:47 <oerjan> (apart from missing the uppercase beginning)
21:09:50 <Cale> http://www.marriedtothesea.com/091807/penpals.gif
21:10:31 <fax> aw nice Cale!
21:10:57 <oerjan> liftM (:) upper (liftM2 (++) (many alphaNum) (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum))))
21:11:03 * fax saves for some reason
21:12:02 <ahanwadi> It gave the following error:.parse (liftM2 (++) (many alphaNum) (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))) "" "a"
21:12:02 <ahanwadi>  
21:12:02 <ahanwadi> <interactive>:1:38:
21:12:02 <ahanwadi>     Couldn't match expected type `Char' against inferred type `[Char]'
21:12:05 <ahanwadi>       Expected type: GenParser Char () [Char]
21:12:08 <ahanwadi>       Inferred type: GenParser Char () [[Char]]
21:12:11 <ahanwadi>     In the third argument of `liftM2', namely
21:12:14 <ahanwadi> 	`(many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))'
21:12:17 <ahanwadi>     In the first argument of `P.parse', namely
21:12:21 <ahanwadi> 	`(liftM2
21:12:23 <ddarius> I think the vast majority of the use cases for email is nothing like "penpals".
21:12:24 <ahanwadi> 	    (++)
21:12:27 <ahanwadi> 	    (many alphaNum)
21:12:30 <ahanwadi> 	    (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum))))'
21:12:39 <Weremanatee> ddarius: Spampals?
21:13:01 <oerjan> oh, right
21:13:31 <oerjan> liftM (:) upper (liftM2 (++) (many alphaNum) (liftM concat (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))))
21:13:34 <ddarius> Weremanatee: I didn't even think of that, but yes.
21:13:42 <Weremanatee> > length $ filter (&&) [True, False, True]
21:13:43 <lambdabot>  Couldn't match expected type `Bool'
21:14:03 <Weremanatee> > length $ filter (&& True) [True, False, True]
21:14:05 <lambdabot>  2
21:14:09 <Weremanatee> seems convoluted
21:14:53 <ahanwadi>  
21:14:53 <ahanwadi> *ASN1> P.parse (liftM (:) upper (liftM2 (++) (many alphaNum) (liftM concat (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))))) "" "abc"
21:14:53 <ahanwadi>  
21:14:53 <ahanwadi> <interactive>:1:15:
21:14:56 <ahanwadi>     Couldn't match expected type `GenParser tok () a'
21:14:59 <ahanwadi> 	   against inferred type `[a1] -> [a1]'
21:15:02 <ahanwadi>     In the first argument of `liftM', namely `(:)'
21:15:05 <ahanwadi>     In the first argument of `P.parse', namely
21:15:05 <Pseudonym> Hey, you're working with ASN.1?
21:15:08 <ahanwadi> 	`(liftM
21:15:08 <oerjan> please _don't_ paste that much!
21:15:11 <ahanwadi> 	    (:)
21:15:14 <ahanwadi> 	    upper
21:15:18 <ahanwadi> 	    (liftM2
21:15:20 <JBGood> > length $ filter id [True, False, True]
21:15:21 <ahanwadi> 	       (++)
21:15:22 <lambdabot>  2
21:15:23 * Weremanatee just discovered the liftM functions. They rock.
21:15:24 <ahanwadi> 	       (many alphaNum)
21:15:27 <ahanwadi> 	       (liftM
21:15:27 <Pseudonym> hpaste, !where
21:15:30 <ahanwadi> 		  concat (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum))))))'
21:15:34 <ahanwadi>     In the expression:
21:15:35 <Pseudonym> Erm.
21:15:36 <ahanwadi> 	P.parse
21:15:39 <Pseudonym> ?where hpaste
21:15:40 <lambdabot> I know nothing about hpaste.
21:15:41 <ahanwadi> oerjan: okay
21:15:44 <Cale> !paste
21:15:44 <ahanwadi> Pseudonym: Yes, I am trying to build an ASN.1 parser as a learning project.
21:15:44 <hpaste> Haskell paste bin: http://hpaste.org/
21:15:49 <Pseudonym> That's it.
21:15:50 <Pseudonym> Cool!
21:15:54 <oerjan> i'll get it to typecheck myself first
21:16:02 <Pseudonym> drtomc is sick at the moment, but he was doing that too.
21:16:13 <Pseudonym> Which encoding?
21:16:27 <Pseudonym> IMO, some ASN.1 stuff would be an excellent thing for hackage.
21:16:31 <Pseudonym> Anyway.
21:16:34 <Pseudonym> !paste
21:16:34 <hpaste> Haskell paste bin: http://hpaste.org/
21:16:37 <Pseudonym> Please paste there.
21:16:48 * Pseudonym can't read all that in /msg form
21:16:56 <ahanwadi> Pseudonym: Right now, I am not thinking about encoding/decoding yet. I just want to parse SNMP modules first
21:17:01 <Pseudonym> OK
21:17:08 <ahanwadi> Laster, I will try to implement SNMP stack.
21:17:13 <Pseudonym> That would be BER, then?
21:17:21 <ahanwadi> Yes
21:17:24 <oerjan> oh right
21:17:42 <oerjan> liftM2 (:) upper (liftM2 (++) (many alphaNum) (liftM concat (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))))
21:18:06 <pjd> flat is better than nested
21:18:15 <hpaste>  ahanwadi pasted "(no title)" at http://hpaste.org/2787
21:18:41 <ddarius> bigger is better
21:19:26 <FMota> and natural division is bogus.
21:19:47 <Pseudonym> ?unpl liftM2 (:) upper (liftM2 (++) (many alphaNum) (liftM concat (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))))
21:19:48 <lambdabot> (upper >>= \ b -> ((many alphaNum) >>= \ g -> (liftM concat (many ((many1 (char '-')) >>= \ l -> (many1 alphaNum) >>= \ k -> return (l ++ k)))) >>= \ h -> return (g ++ (++))) >>= \ a -> return ((:)
21:19:48 <lambdabot> b a))
21:20:02 <Pseudonym> Ouch.
21:20:05 <Pseudonym> Too many parens.
21:20:15 <FMota> learn lisp first :o :/
21:20:21 <oerjan> @. redo unpl liftM2 (:) upper (liftM2 (++) (many alphaNum) (liftM concat (many (liftM2 (++) (many1 (char '-')) (many1 alphaNum)))))
21:20:22 <lambdabot> ((do { b <- upper; a <- (do { g <- (many alphaNum); h <- (liftM concat (many (do { l <- (many1 (char '-')); k <- (many1 alphaNum); return (l ++ k)}))); return (g ++ (++))}); return ((:) b a)}))
21:20:27 <ahanwadi> oerjan: thanks, it is working. Cool.
21:20:32 <oerjan> :)
21:20:59 <oerjan> the parentheses sort of escalated.
21:21:18 <ddarius> oerjan: That's what the Lispers said.
21:21:18 <dibblego> can dropWhile be written in terms of foldr?
21:21:24 <Pseudonym> I particularly like this bit: return (g ++ (++))
21:21:26 <wli> Let's see. I need STV via Meek's method before moving to CPO-STV.
21:21:32 <Pseudonym> I'm still scratching my head over that one.
21:21:42 <JBGood> :t   (liftM2 (++) (many1 (char '-')) (many1 alphaNum))
21:21:44 <lambdabot> Not in scope: `many1'
21:21:44 <lambdabot>  
21:21:44 <lambdabot> <interactive>:1:33: Not in scope: `many1'
21:21:47 <oerjan> eek
21:22:04 <JBGood> oh
21:22:27 <ddarius> Pseudonym: Probably some kind of mis-pretty print (?)
21:22:35 <Pseudonym> Most likely.
21:22:45 <Pseudonym> Pretty-printing in the presence of operators is actually quite tricky.
21:22:53 <Pseudonym> I had two goes at it before I got ?free working correctly.
21:23:10 <ddarius> Pseudonym: Are you sure ?free works correctly?
21:23:14 <Pseudonym> Yes.
21:23:19 <Pseudonym> Well, the pretty printing part does.
21:23:37 <Pseudonym> I have a wastepaper basket full of crumpled-up paper to prove it.
21:23:42 <Pseudonym> Or at least I did.
21:24:46 <ddarius> Proof by Appeal to Garbage?
21:24:57 <Pseudonym> Proof by Exhaustion, I suspect.
21:25:38 <oerjan> liftM2 (:) upper . liftM2 (++) (many alphaNum) . liftM concat . many . liftM2 (++) (many1 (char '-')) $ many1 alphaNum -- unparenthesized
21:25:51 <ddarius> Happy pjd?
21:26:17 <Pseudonym> ?. redo unpl liftM2 (:) upper . liftM2 (++) (many alphaNum) . liftM concat . many . liftM2 (++) (many1 (char '-')) $ many1 alphaNum
21:26:17 <lambdabot> ((do { b <- upper; a <- (do { g <- (many alphaNum); h <- (liftM concat (many (do { l <- (many1 (char '-')); k <- (many1 alphaNum); return (l ++ k)}))); return (g ++ (++))}); return ((:) b a)}))
21:26:24 <Pseudonym> Still got that g ++ (++)
21:26:37 <Pseudonym> ?unpl liftM2 (:) upper . liftM2 (++) (many alphaNum) . liftM concat . many . liftM2 (++) (many1 (char '-')) $ many1 alphaNum
21:26:37 <lambdabot> (upper >>= \ b -> ((many alphaNum) >>= \ g -> (liftM concat (many ((many1 (char '-')) >>= \ l -> (many1 alphaNum) >>= \ k -> return (l ++ k)))) >>= \ h -> return (g ++ (++))) >>= \ a -> return ((:)
21:26:37 <lambdabot> b a))
21:28:44 <pjd> ddarius: :D
21:29:45 <ddarius> Kuso.
21:29:50 * ddarius turns in for the night.
21:31:04 <wli> I basically have n candidates and a vote consists of an ordered subset of the n candidates, so there are \sum_{k=1}^n k! possible votes. Relatively easy to say that the set of candidates should be Bounded and Enum but there doesn't appear to be a good type for votes.
21:31:39 <Pseudonym> There probably isn't a good static type.
21:31:56 <wli> [Candidate] it is.
21:32:53 <Pseudonym> There is, though, a representation that has a simple static check.
21:33:17 <Pseudonym> Think of a vote as a selection.
21:33:39 <Pseudonym> And after selecting, you remove the candidate from the list.
21:34:03 <Pseudonym> So then it's a list where the first element is in the range [1..n], the second is in the range [1..n-1] and so on.
21:34:10 <Pseudonym> Now reverse that list.
21:34:17 <wli> Pseudonym: This is preferential voting (STV via Meek's method) so each vote is a list of candidates.
21:34:23 <Pseudonym> The first element is in the range [1..1], the second is in the range [1..2] and so on.
21:34:30 <Pseudonym> wli: Sure.
21:34:34 <Pseudonym> It's a complete list, right?
21:34:45 <wli> Pseuonym: It's not required to be, no.
21:34:47 <Pseudonym> Ah.
21:34:50 <Pseudonym> OK, never mind, then.
21:34:57 <FMota> I hate being self-plugging, but I'd love to have some of #haskell's opinion on the question I posted on my blog.
21:35:10 <wli> Pseudonym: AIUI it must be a nonempty list.
21:35:10 <Pseudonym> And your blog is where?
21:35:15 <Pseudonym> wli: Right.
21:35:21 <FMota> Feel free to ignore if you dislike me: http://odi-sei-a.blogspot.com/2007/09/total-functional-programming-and.html
21:35:23 <lambdabot> Title: odiseia: Total functional programming and implied domains., http://tinyurl.com/yw74b7
21:35:25 <Pseudonym> FWIW, I moonlight as a polling official in a country that uses STV.
21:35:42 <Pseudonym> So I know how it works very well, sadly.
21:35:44 <wli> Pseudonym: I'm attempting to hammer out CPO-STV.
21:35:57 <Pseudonym> Having been knee-deep in ballot papers.
21:36:00 <wli> Pseudonym: I think only NZ uses Meek's method.
21:36:12 <Pseudonym> Yeah, Australia uses Clark-Hare.
21:36:59 <wli> Pseudonym: I basically want CPO-STV via Meek (and I think Droop fits in somewhere like the initial bootstrapping).
21:36:59 <Pseudonym> I _think_ that for a sufficiently large whatever, all of those versions are equivalent.
21:37:42 <wli> Pseudonym: Well, the odds of a case arising where they make a difference are miniscule for sufficiently large electorates or some such.
21:37:56 <Pseudonym> Right.
21:38:14 <Pseudonym> (BTW, I think someone got a Nobel Prize in economics for studying the properties of sufficiently large whatevers.)
21:38:33 <wli> Pseudonym: I only know about Ken Arrow.
21:38:45 * Pseudonym is joking, honestly.
21:39:29 <wli> Economics is wrong in numerous precepts so I don't put much stock in it anyway.
21:39:46 <Pseudonym> Lots of things are correct if something is sufficiently something.
21:40:53 <oerjan> you can have your cake and eat it too, if it's just large enough!
21:41:33 <Pseudonym> Exactly!
21:43:04 <wli> Anyway, the way to write Haskell programs is to get a very good idea of how something works ahead of time and then write down the formulae, so I have to do that for Meek's method, then CPO-STV (which uses Meek as a subroutine of sorts).
21:43:47 <kfish> FMota, corange eh?
21:44:00 <FMota> :p
21:45:24 <kfish> how did turner handle pred?
21:45:35 <FMota> turner?
21:46:16 <kfish> http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf
21:46:19 <lambdabot> http://tinyurl.com/2fcfrr
21:46:32 <FMota> ah yes
21:46:42 <FMota> I was checking to see if that's what you meant
21:46:46 <FMota> I think he ignores it
21:47:28 <FMota> He talks about head and tail, but not about pred. :o
21:47:39 <FMota> (assuming it's a he, ofc)
21:49:01 <Heffalump> anyone know what's up with the nightly ghc 6.8 snapshot builds? The last one was on the 13th and they've been failing with some missing directory ever since
21:51:38 <hpaste>  dolio pasted "for dibblego" at http://hpaste.org/2788
21:52:04 <dibblego> ah thanks; I thought it might be something like that
21:52:18 <dibblego> after a few initial failures
21:52:30 <dolio> Took me a while. :)
21:52:54 <dolio> That tupple match should probably be lazy, too.
21:54:09 <dolio> Otherwise you get a stack overflow.
21:54:45 <dolio> On infinite lists and such, that is.
21:58:39 <kfish> FMota, so eg "when: a > b" introduces a dependency on the type signature?
21:59:24 <FMota> yes
21:59:43 <FMota> well
21:59:44 <FMota> sort of
22:00:56 <FMota> it restricts the application of the verses/definitions above it
22:01:14 <FMota> and the thing that actually determines the type of a function is the definitions
22:03:16 <kfish> FMota, cool, are you familiar with dependent types (ie. from type theory other than haskell)?
22:03:23 <FMota> yes
22:03:44 <FMota> i.e. Vec Nat Type -> Type
22:05:06 <kfish> eg. the discussion of dependent types in ttfp introduces pred similarly
22:06:18 <fax> hm
22:06:47 <fax> say you like traverse a tree
22:07:04 <FMota> ttfp?
22:07:05 <fax> and some condition maybe you want to signal failure..
22:07:17 <fax> do you think you'd use callCC for that?
22:07:20 <kfish> FMota, http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
22:07:21 <lambdabot> Title: Type Theory and Functional Programming
22:07:28 <FMota> thank you :)
22:07:30 <fax> and would it combine with state monad ok?
22:09:47 <fax> you generally keep different monads separate?
22:11:41 <fax> hm it's tricky to decide what should be implicit and what shouldn't
22:20:35 <timthelion> imagine that f takes a string... wouldn't it be cool if f could patern match like {f "^Project: " name "\nAuthor: " author = } and you could call {f "Project: Foo\nAuthor: Bar" } and the "Project: " and the "Author: " would be deleted, and the remaining two strings would be patern matched into name and author?
22:20:42 <timthelion> does that exist?
22:20:51 <timthelion> that kind of regex patern matching?
22:22:02 <shapr> Doesn't harp do that?
22:22:12 <shapr> Or some sort of regex pattern matching.
22:24:35 <timthelion> looks interesting
22:25:13 <sjanssen> timthelion: you could probably come up with something nice with pattern guards and one of the conventional regex libraries
22:25:54 <timthelion> sjanssen: now that I know the term patern guards, the clouds are parting in the heavens.
22:26:01 <timthelion> but I'm still writting in bash :(
22:26:37 <kfish> @botsnack
22:26:38 <lambdabot> :)
22:30:43 <sorear> @go Haskerl
22:30:46 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
22:30:46 <lambdabot> Title: The Haskerl index
22:30:54 <sorear> timthelion: it's been proposed
22:31:07 <sorear> timthelion: mind you, it was on Apr 01
22:31:28 <Nafai> timthelion: Whatcha writing in bash?
22:31:54 <sjanssen> sorear: regular expressions for Haskell data types was seriously proposed in a paper too
22:32:50 <sjanssen> sorear: http://www.haskell.org/pipermail/haskell/2004-May/014070.html
22:32:51 <lambdabot> Title: [Haskell] ANNOUNCE: HaRP (Haskell Regular Patterns) version 0.1
22:34:06 <jcreigh> heh. Just like a Haskeller. "What? Why only lists of *characters*?"
22:37:17 <Pseudonym> Boost does the same, FWIW.
22:51:05 <hpaste>  Weremanatee pasted "pnpoly" at http://hpaste.org/2789
22:51:36 <Weremanatee> I've pasted an implementation in Haskell, of PNPOLY: http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
22:51:54 <FMota> that pretty much sums up what I dislike about Haskell
22:52:04 <Weremanatee> It's not as fast as I'd like, and it gives a stack overflow for very large polygons.
22:52:53 <Weremanatee> I am soliciting tips on any obvious ways to improve it.
22:58:04 <Weremanatee> FMota: What do you mean?
22:58:37 <FMota> The code is generally oblique.
22:59:15 <FMota> I don't think it's a problem specific to Haskell, but Haskell doesn't help.
22:59:25 <Cale> FMota: that's not so oblique, I think it's just that the algorithm isn't obvious :)
22:59:30 <fax> hm
22:59:37 <fax> I should rewrite my polygon thing in haskell
23:00:15 <Weremanatee> I don't think the C code above makes the algorithm any more obvious.
23:00:28 <FMota> no, it wouldn't
23:00:41 <fax> I don't see why an implementaiton is required
23:00:41 <FMota> I think the python version would be easier to follow, though
23:00:48 <fax> http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/
23:00:48 <lambdabot> Title: Determining if a point lies on the interior of a polygon
23:00:50 <fax> Just have a picture like that
23:00:58 <fax> It's very much clearer
23:01:00 <Cale> I think the python version would look quite a lot like the C version
23:01:05 <Weremanatee> I'm certain that it's possible to write a much more legible Haskell version of this than I have.
23:01:22 <Cale> yeah, I wouldn't have translated the C code into that :)
23:04:19 <Pseudonym> Weremanatee: Just a suggestion, but Haskell is a good candidate for precomputing the half-plane data.
23:04:27 <Pseudonym> Because it's lazy.
23:06:28 <hpaste>  Weremanatee annotated "pnpoly" with "Shorter version" at http://hpaste.org/2789#a1
23:06:42 <hpaste>  Pseudonym annotated "pnpoly" with "(no title)" at http://hpaste.org/2789#a2
23:07:00 <Pseudonym> Ouch.
23:07:07 <Pseudonym> The f $ g $ h $ x burns my eyes!
23:07:31 <Weremanatee> why?
23:07:51 <FMota> $ does not a happy reader make
23:08:02 <Weremanatee> I just think of it as a reverse pipe
23:08:17 <Pseudonym> Weremanatee: Whereas I think of it as low-precedence application.
23:08:23 <Weremanatee> sure
23:08:30 <Weremanatee> what's better?
23:08:36 <Pseudonym> f . g . h $ x
23:08:44 <wayg>  http://st-pitch.miniville.fr/
23:08:44 -wayg(i=Fywqif@modemcable028.216-200-24.mc.videotron.ca)-  http://st-pitch.miniville.fr/
23:08:46 <lambdabot> Title: Miniville
23:08:46 <lambdabot> Title: Miniville
23:09:35 <dolio> @check \l -> filter (&& True) l == filter id l
23:09:37 <lambdabot>  OK, passed 500 tests.
23:10:08 <Pseudonym> Weremanatee: A summary of my thoughts is here.
23:10:11 <Pseudonym> http://www.mail-archive.com/haskell-cafe@haskell.org/msg12549.html
23:10:12 <lambdabot> Title: Re: [Haskell-cafe] Why is $ right associative instead of left associativ, http://tinyurl.com/2c9p68
23:12:13 <dolio> Does one of the popular tutorials use 'f $ g $ h $ x' a lot?
23:14:02 <fax> does anyone know of a solver for some game that uses monads? (for like backtracking or state or something)
23:14:11 <hpaste>  Weremanatee pasted "reader-friendly pnpoly" at http://hpaste.org/2790
23:14:18 <fax> or a list of solvers
23:14:21 <Botje> the [] monad is quite handy for backtracking purposes
23:14:38 <sjanssen> fax: there's a bunch of sudoku solvers on the haskellwiki
23:14:38 <dolio> There's a bunch of sudoku solvers on the wiki, some of which use monads.
23:14:58 <Pseudonym> http://www.haskell.org/haskellwiki/Sudoku
23:14:59 <lambdabot> Title: Sudoku - HaskellWiki
23:15:14 <fax> great, cheers
23:15:28 <fax> Botje: do you have an example?
23:15:39 <Pseudonym> fax: Look at the sudoku solvers.
23:15:46 <fax> ok
23:16:11 <Pseudonym> http://andrew.bromage.org/darcs/sudoku/ -- This is mine, also uses [] as a backtracking monad.
23:16:12 <lambdabot> Title: Index of /darcs/sudoku
23:16:44 <fax> cool :D
23:17:11 * Pseudonym should add that to the wiki
23:18:47 <fax> can you have a function which uses two monads?
23:19:01 <Pseudonym> Sure.
23:19:10 <hpaste>  Cale annotated "pnpoly" with "direct translation" at http://hpaste.org/2789#a3
23:19:29 <fax> I might want to do that
23:21:13 <Cale> Weremanatee: have a good test?
23:21:54 <quicksilver> Pseudonym: Pseudonym == ajb ?
23:22:17 <Pseudonym> Yup.
23:22:25 <Cale> quicksilver: based on his username, I'd guess that :)
23:22:25 <Pseudonym> For some values of ajb.
23:22:35 <Korollary> as long as ajb is another pseudonym
23:22:37 <quicksilver> ah, there you go.
23:22:39 <hpaste>  dolio annotated "pnpoly" with "eliminate the middleman :)" at http://hpaste.org/2789#a4
23:22:40 <Weremanatee> Thanks, Cale
23:22:45 <Weremanatee> That looks rather nice.
23:22:50 <quicksilver> another mailing list <-> irc linkage in my head :)
23:22:53 <Cale> Weremanatee: I've only tested it with a square :)
23:23:09 <kfish> dolio, yeah, i was wondering when arrow operators were going to come into that :-))
23:23:12 <Cale> Weremanatee: If you have a good stress test, you might see how it does :)
23:23:34 <Weremanatee> alright
23:23:46 <Weremanatee> mine takes 6 seconds for a million points
23:23:50 <Weremanatee> :-(
23:26:25 <dolio> That's bad?
23:26:29 <Cale> We could also try making it tail recursive, which would probably help.
23:27:58 <Weremanatee> Yours takes about five and a half.
23:29:07 <hpaste>  Cale annotated "pnpoly" with "w/tail recursion" at http://hpaste.org/2789#a5
23:30:41 <Cale> is that any better?
23:32:07 <fax> hm ok
23:32:17 <fax> is there any automatic tools for giving you tips on your haskell code?
23:32:49 <fax> like "Don't use so many $" or something
23:33:54 <dolio> Like an intercal interpreter?
23:34:22 <shapr> fax: Yeah, there's #haskell
23:35:19 <Weremanatee> ooh
23:35:31 <fax> heh
23:35:59 <Cale> Weremanatee: is that one any better?
23:37:18 <Weremanatee> no, it's slightly worse
23:37:23 <Cale> interesting
23:37:32 <Weremanatee> about as fast as mine
23:37:34 <Cale> oh, btw, how are you compiling these?
23:37:41 <Cale> are you compiling with -O2 ?
23:37:49 <Weremanatee> no, let me try that
23:37:52 <Cale> oh, heh
23:37:57 <Cale> that makes a huge difference
23:38:00 <Weremanatee> oopsie
23:38:01 <sjanssen> oh god, somebody is asking about object factories on haskell-cafe
23:38:20 <Weremanatee> Haha!
23:38:21 <dolio> Heh, yeah, that was a good one.
23:38:32 <Weremanatee> I can sympathize with object factory workers.
23:39:34 <fax> ok well can I ask abot style then for this function..
23:39:35 <FMota> oh geez
23:39:41 <FMota> I just created an...interesting
23:39:45 <FMota> fp language
23:39:48 <FMota> esoteric
23:39:56 <Korollary> now, no one will talk to you. Well done.
23:40:27 <fax> FMota: By accident? :p
23:40:35 <Pseudonym> I hate it when that happens.
23:40:36 <FMota> sorta, yep
23:40:43 <Korollary> Did you yell "It's alive!"
23:40:44 <fax> lets see?
23:40:52 <fax> btw is (try $ do { ... ; ... ; ... ; }) <|> ... ok?
23:40:52 <FMota> idk if its complete, though
23:41:07 <Cale> fax: yeah
23:41:07 <fax> um with 1 less ;
23:41:16 <fax> ok that's nice to know, thanks
23:42:01 <dolio> You can, most likely, omit the curly brackets.
23:42:02 <FMota> http://pastebin.com/d115b6f2b
23:42:22 <FMota> anyoe want to try to figure it out? /shudder/
23:42:32 <fax> o mh
23:42:35 <Cale> FMota: that came up blank for me
23:42:44 <FMota> XD
23:42:46 <Cale> use hpaste :)
23:42:47 <hpaste>  fax pasted "do { ; example" at http://hpaste.org/2791
23:42:56 <FMota> that's when you know you have a good bit of obscurity
23:43:01 <fax> Do you think I should remove all { ; and } in this kind of case?
23:43:14 <FMota> okay,   a b    is functional application
23:43:17 <Cale> fax: yeah, why not? :)
23:43:19 <FMota> it applies a to b
23:43:35 <FMota> it's left associative
23:43:42 <FMota> so you have to have some way of currying things
23:43:53 <Cale> fax: You're already aligning the block in the right way
23:43:58 <FMota> that's what the vertical alignment is for
23:44:14 <fax> ok I'll remove all those, It should read better
23:44:24 <Weremanatee> Compiling with O2 makes all the difference.
23:44:49 <Cale> Weremanatee: I thought it might :)
23:44:51 <wli> Nah, algorithms do.
23:44:57 <Weremanatee> 2 seconds for a million points. All three implementations are roughly the same.
23:45:03 <Cale> ah, okay
23:45:18 <Weremanatee> Thanks for the insight though.
23:45:23 <Cale> How well does that compare to the C implementation?
23:45:55 <kfish> FMota, interesting, reads like a right-to-left version of hangul characters :-)
23:46:04 <FMota> hangul?
23:46:08 <kfish> korean
23:46:12 <FMota> lol
23:46:28 <kfish> except that instead of korean, it's lisp without parentheses :-)
23:46:53 <FMota> you say you want to get rid of parantheses... well, I got rid of them :o
23:47:39 <FMota> I'll prolly pur this on esolang tomorrow :p
23:48:19 <Weremanatee> hmm... I don't have a ready test for the C implementation.
23:48:38 <Cale> Weremanatee: ah, never mind then :)
23:50:33 <z0d> Is there a blog engine written in Haskell? I can't see one at haskell.org.
23:50:40 <Cale> z0d: There's Hope
23:50:48 <FMota> I put >> in there for good measure:  http://pastebin.com/d68d8a63d
23:50:54 <Cale> http://hope.bringert.net/about
23:51:01 <shapr> and there's a blog demo in HAppS
23:51:08 <FMota> really just for clarity, so perhaps it's easier to understand.
23:51:29 <z0d> Cale: Thank you.
23:52:17 <Cale> FMota: does application have to be backwards like that? :)
23:52:24 <FMota> not really
23:52:31 <FMota> it just came to me that way
23:52:41 <FMota> I'm looking at it the opp way now
23:53:45 <Cale> It looks kind of like it could be ambiguous, but I suppose that's handled by preferring travelling left to travelling down.
23:53:47 <FMota> it looks a lot more reasonable the other way, though.
23:54:42 <FMota> random fun is fun
23:54:47 <FMota> hmm
23:54:52 <FMota> I believe the correct meme is
23:54:56 <FMota> random fun is random
23:56:12 <FMota> I dont see how it can be ambiguous
23:57:24 <FMota> you take you're arguments from the left and down until some the/a function below you is taking your arguments
23:57:28 <FMota> *your
23:57:35 <FMota> wow, I should head to bed
23:57:44 <FMota> nighty night folks.
23:57:48 <Cale> g'night
23:57:51 <FMota> (you know you
23:58:08 <FMota> *you're tired when you start inventing esoteric languages BACKWARDS)
23:59:15 <olsner> sounds like forth
