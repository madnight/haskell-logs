00:01:26 <axm> when you want a text editor, you want easy reachable and easy rememberable shortcuts for often used functions. in that respect, both vim and emacs fail. i worked with both of them for years now but still feel more comfortable around that windows edit standard
00:02:11 <shapr> I want an editor that I can reconfigure easily so that I can try out new ways of doing things.
00:04:48 <earthy> axm: actually, vim doesn't fail in that respect. it is, however, modeless
00:05:00 <earthy> not modeless taht is
00:05:37 <axm> sorry, i break my finger typing ESC-:sth-Enter to do a simple shortcut
00:05:38 <earthy> and therefore the operations that you might do are not necessarily those that you'd expect with windows edit
00:06:02 <earthy> ah, but you're defaulting to insert mode
00:06:13 <earthy> whereas vim is designed to be used in edit mode
00:06:22 <earthy> and insert mode is something you might want to use sometimes
00:07:42 <earthy> so, adding a bit of text is 'itypetypetypeESC'
00:08:13 <earthy> (or o, or a or... ;))
00:08:46 <glguy> I find myself using things like cw
00:08:47 <pejo> axm, Esc isn't located at exactly the same spot on all keyboards. Some have it closer to the q.
00:08:48 <glguy> or
00:08:48 <axm> yep. but my mind stays in insert mode, cause thats the thing i do the most - writing
00:08:52 <glguy> ci'
00:08:53 <glguy> a lot
00:09:15 <axm> my point is the number of keys you have to press to yank
00:09:28 <axm> or similar often used functions
00:09:49 <glguy> oh, like Y
00:10:14 <axm> and i am sure there was some command to go the beginning of the line, i have used it i know, but what the damn was it again?
00:10:25 <glguy> 0 to beginning
00:10:26 <olsner> Home ;-)
00:10:28 <glguy> ^ to first non space
00:10:29 <glguy> :)
00:10:35 <glguy> I to start inserting there
00:10:44 <axm> might be a bad example there, mom
00:10:46 <glguy> g0 to beginning of this logical line
00:10:47 <glguy> :)
00:11:03 <axm> ok, you got me ;)
00:11:21 <olsner> but ^ is shift-key space on my keyboard, so that's pretty unusable for me
00:11:24 <axm> but i am even unsure that it is that simple
00:11:36 <glguy> that was is that simple?
00:11:43 <axm> home
00:11:52 <axm> to get to the beginning of the line
00:11:55 <olsner> Home/End have the proper bindings in my vim
00:11:58 <glguy> oh, home works assuming your terminal is setup right
00:12:02 <axm> i would have expected a letter in edit mode
00:12:18 <axm> and i do not want to change modes that often when typing
00:12:30 <glguy> home and end work in INSERT mode
00:12:36 <axm> or do it just by holding one key down and leave when released
00:12:46 <glguy> I have escape on my footpedal
00:12:56 * sjanssen has escape on capslock
00:13:00 <axm> you are joking right?
00:13:04 <olsner> foot pedal? nice setup!
00:13:04 <glguy> i have control on caps lock
00:13:17 <glguy> Kinesis keyboard is "for the win"
00:13:43 <glguy> if you didn't know I had the pedal it might look like magic :)
00:14:17 <olsner> most of vim probably looks like magic even with Esc on the keyboard
00:14:34 <glguy> especially if you incorporate a large subset of the commands
00:14:52 <glguy> if you are just using x and i
00:14:58 <glguy> it probably looks awful :)
00:15:44 <scodil> happy hacking keyboards put esc where ~ usually is. it's awesome
00:16:00 <glguy> the kinesis keyboard has built in key remapping
00:16:07 <glguy> so you can press remap from to remap
00:16:09 <glguy> and you are done
00:16:13 <scodil> but it _says ESC_!
00:16:18 <glguy> ? so
00:16:22 <glguy> who looks at the keyboard?
00:16:25 <scodil> and capslock says _Control_!
00:16:27 <glguy> people watching you type?
00:16:33 <scodil> you're not getting it :)
00:17:02 <glguy> hm, you're right. please, go on ;)
00:17:07 <olsner> movable key-caps let me have almost any keyboard layout (as long as remapped keys are the same shape.... Caps Lock and Ctrl are differently-shaped though
00:17:29 <scodil> oh ok. that's pretty cool
00:17:32 <scodil> like old model-Ms
00:17:47 <glguy> almost all of the keys on mine are slightly different
00:17:51 <scodil> i used to re-arrange the keys on the old PS/2s in the labs at school
00:17:53 <glguy> that'd be a disaster :)
00:17:58 <olsner> scodil: yeah, this is an '87 1391401
00:18:29 <olsner> (i.e. Model M)
00:18:54 * olsner runs to work
00:19:07 <scodil> those things are awesome. if i had more money i'd shell out for the nice happy-hacking with model-m-like keys
00:19:14 <scodil> but they're like $200+
00:19:28 <glguy> its worth it if the keys feel right
00:19:39 <glguy> I haven't found one at a best buy that had decent key feel
00:19:45 <glguy> or similar retail outlets
00:19:56 <scodil> i'm pretty flexible. enough so that i can't justify that kind of money on something i might spill coffe into
00:20:14 * Japsu had escape on capslock but then he bought a Lenovo Ultranav keyboard that does not have a Windows key, so he rebound CapsLock to Win
00:20:37 <glguy> seems like a better solution would be to not use windows in that specific case ;)
00:20:44 * platypus has a nice Sun type 6 at work "Thought the type 5 is better"
00:20:52 <Soliah> anyone know any other way to switch between split windows in vim other than ctrl+w ctrl+w?
00:21:04 <scodil> ctrl-w h/j/k/l
00:21:09 <glguy> ^W hjkl
00:21:11 <nornagon> Soliah: #vim :)
00:21:21 <pejo> platypus, I found that once you gotten used to the shorter keypresses the type 6 is great.
00:21:21 <Soliah> Well, with all the talk of vim and stuff.. :p
00:21:23 <glguy> I use tabs more than split windows
00:21:27 <glguy> then you have gt and gT
00:21:41 <scodil> no way this is a great place to ask vim questions. most of my vim problems are haskell related anyway
00:21:47 <nornagon> heh
00:21:53 <glguy> the new mac keyboards (the super thin aluminum ones) have *short* key travel
00:22:16 <glguy> I'd like one for display
00:22:18 <pejo> glguy, are they similar to the laptop ones?
00:22:25 <glguy> but I couldn't see myself typing on one
00:22:30 <nornagon> i've got my eye on a macbook pro (the 15" one)
00:22:31 <glguy> pejo: no, the laptop ones are useable
00:22:36 <nornagon> they have pretty nice keyboards
00:22:47 <nornagon> but not something i'd want to spend 10 hours a day on
00:22:53 <glguy> nornagon: at least my powerbooks keyboard was useable
00:22:59 <glguy> I don't like the new macbook keyboards either
00:23:13 <pejo> nornagon, have an extra usb keyboard. I use my type 6 with my macbook, and it works like a charm. Even the volume-keys.
00:23:31 <nornagon> heh, i wouldn't be running osx ;)
00:23:51 <KatieHuber> I have one of the new Apple keyboards at work, and even after using it since the week after they became available, I'm still regularly mistyping on it
00:23:52 <nornagon> also, carrying around keyboards is sort of annoying
00:24:04 <glguy> KatieHuber: do you feel like your hands drift around on it?
00:24:05 <KatieHuber> it *feels* nice, but it's nowhere near as productive as the old pro keyboard
00:24:10 <wnoise> I just wish apple would take the fingerworks touchstream tech and make actual keyboards, not this lame ass touchpad and ipod/phone interfaces
00:24:18 <pejo> nornagon, do you often carry around your computer on those 10 hour days?
00:24:18 <scodil> work bought be a laptop, and i was so excited because i could move around and not have to sit at my desk, then i got sick of the keyboard and plugged in an old one, then i got sick of having to push the screen back so far to make room for the keyboard, so i plugged in a monitor. now i'm stuck at my desk again.
00:24:29 <glguy> I tried typing on one, and I couldn't get a sense of where my hands were. The keys are big and flat
00:24:30 <nornagon> pejo: good point :)
00:24:38 <nornagon> I have a Microsoft Natural Keyboard, a newer one
00:24:41 <nornagon> it's pretty good
00:24:47 <nornagon> the only thing i can use atm, due to wrist issues
00:24:51 <KatieHuber> I like the feel, but the space bar in particular isn't responsive
00:25:13 <KatieHuber> then again, I like the macbook keyboards, so my taste probably doesn't mean anything to you ;)
00:25:15 <glguy> nornagon: I liked the new one, but I felt that the keypress was kind of soft
00:25:37 <nornagon> i like a soft keypress
00:25:41 <glguy> I like when my fingernails are just barely too long and needing to be cut when I'm typing on my macbook
00:25:43 <nornagon> the less effort per keystroke, the better
00:25:50 <glguy> makes a clicking
00:26:12 <nornagon> this natural keyboard is just a little too hard a keypress for me
00:26:28 <glguy> I like keys that aren't mushy
00:26:33 <nornagon> smaller key travel would be nice
00:26:43 <glguy> the kinesis has the keys that have more resistance at the beginning
00:26:44 <nornagon> i hate having to slam keys
00:26:48 <glguy> and then they get easy to press
00:26:51 <nornagon> the quieter my typing the better
00:26:53 <glguy> but aren't squishy
00:27:06 <glguy> and you don't have to push the key all the way down
00:27:10 <glguy> I hate hitting the bottom
00:27:20 <glguy> just have to push it past the click
00:27:29 <nornagon> yeah, you have to hit the bottom on this keyboard
00:27:45 <nornagon> keypress is about 5mm
00:27:57 <glguy> the old white mac keyboards were like that
00:28:04 <glguy> you had to push all the way down
00:28:09 <glguy> jarring :-/
00:28:14 <nornagon> yeah
00:28:26 <nornagon> also this keyboard has no win key on the right-hand side
00:28:38 <lament> terrible
00:28:43 <nornagon> so it's hard to switch to workspaces 7-9
00:29:11 <glguy> I've never managed to adopt a workspace based workflow
00:29:17 <nornagon> what do you use?
00:29:21 <glguy> more monitors
00:29:25 <nornagon> heh :)
00:29:33 <Soliah> nice philosophy :)
00:29:40 <lament> i just use windows :)
00:29:41 <pastorn> @src randomR
00:29:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
00:29:48 <Soliah> what monitors have you got setup?
00:29:49 <nornagon> I use a lot of workspaces
00:29:51 <pastorn> @src System.Random.randomR
00:29:51 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:29:53 <lament> (maximized, lots of them, and alt-tab between them)
00:29:56 <Soliah> I really want a dual 24" setup
00:29:56 <nornagon> because i usually have several things running at once
00:30:04 <glguy> Soliah: usually just a laptop screen and a 19" lcd
00:30:15 <pastorn> @where System.Random
00:30:15 <lambdabot> I know nothing about system.random.
00:30:19 <pastorn> yay
00:30:31 <glguy> that's enough to have two vertically maximized terminals on the lcd
00:30:37 <glguy> and whatever else I need on the laptop
00:30:51 <nornagon> often two or three hacking projects, some PDFs, a LaTeX document, plus IRC and web
00:31:20 <nornagon> lambdabot: you need xmonad :)
00:31:22 <nornagon> er.
00:31:27 <nornagon> lament, even.
00:31:28 <scodil> hah
00:31:35 <scodil> lambdabot totally needs xmonad
00:31:37 <nornagon> i'm not sure lambdabot would get much use from it.
00:31:39 <lament> nornagon: no, i don't, that's the point :)
00:31:57 <lambdabot> Someone needs to write an X11 server plugin for me first.
00:32:09 <pastorn> hehe
00:32:10 <scodil> yeah, i'm with lament. i used xmonad for a while and thought "this is great" until i realized i was only ever using roundy's tabbed mode
00:32:15 <nornagon> lambdabot is clippy!
00:32:16 <glguy> ?seen dons
00:32:16 <lambdabot> dons is in #haskell-hac07, #xmonad and #haskell. I last heard dons speak 4h 33m 22s ago.
00:32:21 <glguy> ?seen sorear
00:32:21 <lambdabot> I saw sorear leaving ##logic, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 2h 2m 10s ago, and .
00:32:34 * glguy doesn't know who else sock-puppet's lambdabot
00:32:41 <sjanssen> @activity-all
00:32:41 <lambdabot> 3*total 3*#haskell
00:32:48 <nornagon> ,\ --( It looks like you're trying to factorise large primes in the type-system, would you like some help? )
00:32:50 * glguy points at sjanssen
00:32:54 <sjanssen> glguy: wasn't me
00:33:11 <Pseudonym> ?seen
00:33:18 <Pseudonym> Sometimes you can see from there.
00:33:22 <glguy> ?seen
00:35:19 <hpaste> test
00:36:18 <scodil> does anyone know of a library or a program that contains code for points, vectors, matrices and transformations in 2 and 3 dimensions? with an emphasis on performance (ie, not list-based)? I'm looking for something to compare benchmarks with.
00:39:58 <astrolabe> scodil: I think there is a haskell wrapper of part of LAPack, but I guess you'd consider that cheating?
00:40:24 <Pseudonym> It's also inefficient if everything is 3D at the most.
00:41:27 <scodil> 4D at the most
00:41:30 <scodil> but yeah
00:42:52 <scodil> i've actually abused dimension-independent geometry libraries to solve small systems, 8x8 or so. didn't bother to compare to, say, GSL, as far as speed. but its easier to code, usually.
00:43:14 <scodil> although the gsl haskell bindings are slick
00:48:07 <astrolabe> Pseudonym: inefficient compared to anything in particular?
01:02:39 <DRMacIver> Hmph. Why do people think licensing libraries under the GPL is socially acceptable behaviour?
01:02:49 <glguy> same reason they use ruby
01:05:02 <DRMacIver> That seems something of a non sequitur.
01:05:07 <Cale> glguy: hm?
01:05:29 <koala_man> DRMacIver: it means "Because they're sociopaths."
01:06:00 <DRMacIver> Ha
01:06:27 <Cale> Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
01:06:44 <glguy> ?remember Cale Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
01:06:45 <lambdabot> Done.
01:08:12 <glguy> DRMacIver:  I don't much like either ruby nor gpl, but I don't think that your statement nor mine were meant to be answered :)
01:08:29 <DRMacIver> Yeah. I use Ruby a little bit at work and it tentatively seems pleasant.
01:08:42 <DRMacIver> glguy: I wouldn't *mind* a good answer to my question. :)
01:08:47 <DRMacIver> I just don't expect one.
01:09:10 <osfameron> what's wrong with GPL ?
01:09:22 <glguy> every time I learn more about ruby, I get more of a sense that it's one kludge built on another
01:09:39 <glguy> I've seen people write neat things using it
01:09:46 <glguy> just don't like the language
01:10:23 <DRMacIver> osfameron: Its viral nature.
01:10:39 <osfameron> I just get put off by the syntax - |parameters,between,pipes,wtf?|
01:10:56 <glguy> I think that that is straight out of smalltalk
01:11:28 <DRMacIver> osfameron: I've no problem with it for applications (although I don't especially like it there either), but GPLed libraries are evil.
01:11:29 <roconnor> the GPL restricts what people can do with your software.
01:12:17 <osfameron> DRMacIver: expecting people to use your software with restrictions is not unreasonable (like "Pay me $dollahz!" or "Your code must be GPL")  After all, if you don't like the restriction you just don't use it.
01:12:40 <osfameron> But I'm not a gpl fanatic (I default to Perl Artistic license usually)
01:13:06 <glguy> yeah, I think that its disingenuous to call it "free software" and toss the term "freedom" around
01:13:18 <DRMacIver> osfameron: The fact that restrictions can be reasonable is not an argument that restrictions are reasonable. :) "You must punch babies in order to use this software" is not a reasonable restriction.
01:13:22 <glguy> its "software island"
01:13:58 <DRMacIver> And I don't consider "No derivative of your work ever may be proprietary" to be particularly reasonable. (Particularly given glguy's point about freedom)
01:13:59 <osfameron> DRMacIver: true.  And I certainly wouldn't use babyviolenceware (unless I was in a really bad mood).
01:14:07 <Cale> glguy: It's an island that did manage to get enough things on the boat though.
01:14:32 <glguy> Cale: I'm not suggesting that it isn't successful :)
01:14:35 <DRMacIver> Cale: I don't think glguy is objecting to the island nature so much as the "You're not free unless you're on our island!" advocacy.
01:14:37 <roconnor> osfameron: adding restrictions isn't necessarily unreasonable, but it is wrong. :)
01:15:38 <roconnor> I guess it depends if you are one of those, the ends justify the means people.
01:15:40 <Cale> Of course, ee also don't want the kind of software where source code just isn't made available at all.
01:16:02 <Cale> we*
01:16:27 <glguy> right, we want the kind that comes with a reasonable license, not proprietary/gpl
01:16:28 <lament> does the state really limit my freedom by not allowing me to become a slave?
01:16:31 <glguy> :-p
01:16:43 <Cale> lament: right
01:17:33 <DRMacIver> Cale: I disagree. I'm entirely happy to allow the kind of software where source code isn't made available at all.
01:17:40 <DRMacIver> But again, applications rather than libraries.
01:17:49 <Cale> It comes from the protectionary viewpoint that in order for free software to compete, it has to have some provision for not being reabsorbed continually into proprietary systems
01:18:18 <Cale> That might not be true anymore, I'm not sure.
01:18:25 <glguy> and then, hypocritically, they do that very thing to OpenBSD, for example
01:18:29 <Cale> But that's where the idea comes from.
01:18:38 <roconnor> Cale: Of course that argument never made any sense to begin with
01:18:39 <osfameron> I think it's probably a good thing that GPL has existed as a counterpoint to other systems
01:18:49 <Cale> roconnor: It makes some sense.
01:19:03 <roconnor> Cale: it's not like existing versions become magically unavailable when it is absorbed into proprietary works.
01:19:32 <Cale> roconnor: Right, but the GPL isn't just looking to coexist with commercial software, it's looking to supplant it.
01:19:35 <glguy> that RMS is the leader of the cause doesn't help it any either
01:20:05 <Cale> roconnor: That is, to compete with it, and win.
01:20:31 <lament> i thought the idea of GPL was "copyright laws are completely broken, but while they're around, we're gonna subvert them in a nasty way"
01:20:44 <Cale> lament: heh, that too :)
01:21:27 <Cale> But I think it could be argued that their standard use is nastier than the subverted use.
01:21:59 <roconnor> Cale: I agree it make sense in terms of competing with proprietary software, hence what I said about if you think the ends justifying the means.
01:22:08 <Cale> roconnor: yeah
01:22:30 <lament> i fought the law and the law won
01:22:38 <roconnor> *sigh* I've just never heard RMS put it that way.
01:22:44 <Cale> In this case, I think it's a good part of the culture of open software.
01:22:55 <glguy> yeah, just imagine if commercial interests absorbed GPLd code and produced a superior product!
01:22:59 <glguy> who would want to use the free stuff??
01:23:18 <lament> glguy: so like Darwin?
01:23:36 <lament> oh wait, darwin is still free
01:23:41 <roconnor> RMS, should be more honest and say that the GPL restricts people as part of a battle with priopretary software.
01:24:18 <lament> isn't that what he's saying?
01:24:19 <wnoise> RMS is honest about that.  But what he says it restricts people from doing things he considers to be immoral.
01:24:19 <Cale> I think he's pretty clear about what he thinks of proprietary software.
01:24:50 <glguy> What license is Darwin available under?
01:24:57 <lament> bsd prolly
01:25:10 <Cale> My friend's parents are friends of RMS.
01:25:14 <glguy> similar to the freebsd userland that os x uses?
01:25:50 <Cale> heh, and RMS hit on my ex-girlfriend once
01:25:51 <roconnor> wnoise: sounds like what evangelical cristians want
01:25:59 <koala_man> Cale: did he succeed?
01:26:00 <lament> RMS? hit on somebody?
01:26:04 <Cale> koala_man: no
01:26:06 <roconnor> wnoise: well, maybe that isn't quite the same
01:26:13 <lament> RMS hits on people?
01:26:14 <wnoise> And I don't see hypocrisy on the side of people who import OpenBSD code into GPL projects.
01:26:29 <koala_man> if RMS hit on me, he would
01:26:53 <wnoise> The OpenBSD project is fine with people closing their code completely.  So why should they mind a partial closing?
01:27:02 <wnoise> The only thing that makes sense to me is sour-grapes.
01:27:04 <Cale> lament: Apparently he asked her on a date.
01:27:07 <glguy> wnoise: no, the GPL people are about open code
01:27:22 <glguy> and then they close their code to the hand that feed them
01:27:29 <lament> Cale: how sweet
01:27:38 <roconnor> lament: I think RMS always phases the restriction on people as enhancing their freedom, ... you know, war is peace, freedom is slavery, ignorace is strength sort of deal.
01:27:45 <wnoise> They keep it open by their own definition of open -- which is the one they care about.
01:27:50 <Cale> This was before I knew her -- I'm just saying what she told me.
01:28:14 <wnoise> And the one I care about.  I don't care if someone has the freedom to close code.  I do care that the users can read and modify the code they run.
01:28:47 <koala_man> wnoise: those aren't compatible.
01:29:06 <wnoise> How are they not compatible?
01:29:16 <koala_man> if someone closes the code, then other users can't read or modify it
01:29:20 <lament> roconnor: reminds me of the whole american civil war situation.
01:29:41 <wnoise> Right.  So I'm saying I don't think that's a freedom worth defending.  The BSD people in general, do.
01:29:46 <roconnor> lament: in what way?
01:30:26 <wnoise> The GPL is not about maximizing developer freedom, but user freedom.
01:31:09 <lament> roconnor: the individual states' freedom of not being able to leave the union
01:31:31 <glguy> "freedom of not being able to"
01:31:39 <platypus> The freedom to own slaves.
01:31:46 <wnoise> Hah.  The southern states were not about state's rights except in two areas: their ability to leave the union, and their ability to keep slaves.
01:31:47 <roconnor> I'm more interested in the best software becoming available as quickly as possible.
01:32:21 <roconnor> Even if it means that the best software is produced by incoprorating my software into a proprietary product
01:32:33 <roconnor> Because the faster we develop better software
01:32:40 <lament> roconnor: that's because you don't have an ideological agenda. And RMS does.
01:32:45 <roconnor> the faster our general technology will be enhanced
01:32:56 <wnoise> roconnor: even if it means the best software is produced by incorporating your software into GPL software?
01:33:02 <roconnor> and medicine will advance faster
01:33:09 <platypus> lament: Having an ideological agenda isn't neccery a bad thing.
01:33:14 <roconnor> and the chances of me living forever increases.
01:33:16 <wnoise> lament: no, he just has a /different/ ideological agenda.
01:33:19 <lament> platypus: did i say it was?
01:33:38 <roconnor> wnoise: yes, I don't mind my software being incorporated into GPL software either.
01:33:41 <platypus> lament: No you didn't, but its a common assumtion.
01:33:54 <lament> RMS is an idealist. Proprietary software should not exist. Therefore, the situation of "incorporating my software into proprietary software" shouldn't even arise.
01:34:39 <wnoise> The southern states supported massive federal intrusions into the northern states.  The fugitive slave acts grossly undercut states' rights.
01:34:47 <lament> since we can't overturn the government right away, we'll just create our happy little utopia (GPL) fenced off from the evil world of capitalism.
01:35:11 <roconnor> I also agree that proprietary software probably shouldn't exist.
01:35:18 <lament> oh yeah, and once you're in, you can't leave (just like the union :))
01:35:27 <wnoise> And were massively unfair in terms of evidentiary procedures, and incentives.  The judges were paid more for every person ruled an escaped slave and shipped south.)
01:35:31 <platypus> I don't think that RMS thinks that capitalism is evil, just code hording.
01:36:03 <glguy> http://icanhascheezburger.com/
01:36:04 <lambdabot> Title: I CAN HAS CHEEZBURGER?
01:36:28 <therp> glguy: no please don't
01:36:30 <platypus> Of cause in a post scarsity world both capilism and conunism become irrelvent.
01:36:42 <DRMacIver> @remember lambdabot I CAN HAS CHEEZBURGER?
01:36:42 <lambdabot> Done.
01:36:50 <therp> glguy: maybe an hour of GHC hacking was lost due to me falling of my chair on i can has cheezburger
01:36:58 <wnoise> Ain't no such thing as a post-scarcity world.  And capitalism is very, very effective.
01:37:19 <platypus> wnoise: Yet.
01:37:20 <kaol> 10 out of 10 wedge fund managers agree
01:37:28 <therp> http://clemens.endorphin.org/TypeSystem.jpg <- soon to be seen on my blog :)
01:37:47 <glguy> If you give people everything they want, they'll notice their neighbor has it too and think of new things to want
01:38:00 <wnoise> speed-of-light limits space to geometric expansion, while population can grow exponentially.
01:38:14 <kfish> therp, lol
01:38:21 <lament> wnoise: capitalism has its issues, certainly.
01:38:33 <lament> wnoise: "effective" can have many different metrics
01:38:52 <roconnor> platypus: isn't software post scarsity?
01:38:56 <lament> wnoise: the relative importance of which depends on your philosophy
01:39:30 <oklopol> > snd $ tail [(1,2),(3,4),(5,6)]
01:39:31 <lambdabot>  Couldn't match expected type `(a, b)'
01:39:36 <oklopol> why?
01:39:47 <wnoise> lament: sure.  And what we have anywhere isn't a pure capitalist system.
01:39:47 <oklopol> and how can i specify the type?
01:39:50 <glguy> because a list isn't a tuple
01:39:55 <oklopol> ...
01:39:57 <oklopol> yeah
01:39:59 <oklopol> sorry xD
01:39:59 <wnoise> Choosing and enforcing the right set of regulations is /hard/.
01:40:59 <oklopol> glguy: thanks, i'll try not to be an idiot next time
01:41:09 <wnoise> software is a non-rival good.  That's not quite the same thing as post-scarcity.
01:41:49 <roconnor> wnoise: oh, ... I don't get it.
01:41:57 <wnoise> Programmer time to make the right programs is rival, however.
01:42:02 <lament> wnoise: software isn't a good, it's a service :)
01:42:10 <kfish> software is an expression of intelligence, which is a finite resource; only the /reproduction/ of software is non-scarce
01:42:13 <wnoise> lament: exactly.
01:42:51 <lament> i suppose it's also a good.
01:43:14 <DRMacIver> No, it's usually pretty bad.
01:43:14 <roconnor> so, we are saying that isn't isn't a lot of (different) software, but it can be easily replicated.
01:44:13 <wnoise> Yes.  And I'm saying that "post-scarcity" is only applicable when there are no scarce goods (or services).
01:44:41 <lament> which, in software world, would mean "once we have strong AI that can write programs rilly quickly"
01:44:58 <wnoise> lament: you advocate slavery?
01:44:59 <lament> computer, write me a game!
01:45:03 <lament> ok, now with more sex, please!
01:45:13 <lament> wnoise: of AI? sure
01:45:14 <glguy> sex with the computer :-/
01:45:55 <lament> wnoise: i prefer to resolve philosophical problems as they arise, and not beforehand when there's insufficient information :)
01:46:29 <platypus> wnoise: If the AI was created in such a way that being enslaved was its prefered mannor of existence then I would find no ethical problems with this.
01:46:41 <lament> once we have strong AI, we'll see if the term "slavery" is applicable to it or not.
01:47:05 <wnoise> platypus: would you object to a breeding program to create a race of docile humans suitable for slavery?
01:47:17 * glguy already read that book
01:47:34 <lament> wnoise: you mean, like women?
01:47:42 <lament> badum-ts
01:47:42 <koala_man> haha
01:47:43 * glguy ponders @remembering that
01:47:55 <glguy> seems like a lot of setup though
01:47:56 <wnoise> That's incredibly offensive.
01:48:21 <koala_man> not to mention hillarious
01:48:35 <wnoise> not really.
01:48:45 <platypus> wnoise: I would object to such a breeding program.
01:49:11 <wnoise> do you object to the ends, or just the means?
01:49:12 <lament> wnoise: are you actually offended?
01:49:48 <oklopol> i can't imagine anyone being offended by that
01:50:07 <wnoise> lament: Yes, I am.  Broad insults to half the human race are rather offensive, yes.
01:50:11 <b_jonas> hi. could you please point me to an explanation of what newtype does and how it's not just a special case of data?
01:50:13 <platypus> wnoise: The means.
01:50:57 <wnoise> Suppose brain-scanning works, and a copy of you is extracted and digitally altered to enjoy being a slave.  Is that wrong?
01:51:15 <DRMacIver> I'd be ok with it.
01:51:16 <koala_man> wnoise: what if a woman had said "like men?"
01:51:20 <kfish> hi b_jonas
01:51:42 <platypus> wnoise: If I concented to the coping then its not wrong.
01:51:59 <glguy> platypus: after the copy you are no longer the same person though
01:52:03 <wnoise> koala_man: Yes, that would also be offensive.
01:52:04 <glguy> does that matter?
01:52:20 <platypus> glguy: Otherwise its a breach of my pivacy.
01:52:33 <platypus> And possably copyrights.
01:52:35 <glguy> any more than identical twins are the same after they start dividing
01:52:58 <lament> wnoise: then it must be people like you who corrupt the English language with monstrosities like "he/she" and "salesperson". Ugh.
01:52:59 <glguy> can't very well have one condemn the other to slavery
01:53:44 <wnoise> lament: You can grep the logs for me using those words, if you wish.
01:53:58 <mux> what's this channel and what have you guys done with #haskell ?
01:54:11 <quicksilver> I was just wondering that
01:54:15 <lament> point
01:54:17 <Zao> #haskell is busy evaluating f = f
01:54:25 <wnoise> Zao: hah.
01:55:13 <wnoise> the only sexual language change I advocate is for use of singular they to no longer be considered wrong.
01:55:23 <lament> f is f. But what is f? Let's see.. it's f, right? Okay, so what's f? Aha, it's f. Which is... f. I think I remember that one, it's, yes, f.
01:55:47 <kfish> b_jonas, the haskell98 report simply describes newtype's purpose as "datatype renaming"
01:55:48 <lament> *head spins*
01:55:52 <kfish> http://haskell.org/onlinereport/decls.html#user-defined-datatypes
01:55:53 <lambdabot> Title: The Haskell 98 Report: Declarations
01:56:11 <Vq^> lament: keep on and you have the answer soon
01:56:42 <wnoise> doesn't the GHC runtime detect blackholes this simple?
01:57:03 <Zao> The reason I mentioned it was because I was reading a thread on it on haskell-cafe
01:57:05 <mux> it detects some for sure
01:57:09 <mux> > let foo = foo in foo
01:57:11 <lambdabot>  Exception: <<loop>>
01:57:20 <Zao> Where ghci had detected it, and the OP was wondering what happened.
01:58:33 <lament> mux: the halting problem, finally solved!
01:58:45 <mux> you'd wish :-)
02:00:00 <wnoise> @src fix
02:00:01 <lambdabot> fix f = let x = f x in x
02:00:12 <wnoise> > fix id
02:00:14 <lambdabot>  Exception: <<loop>>
02:00:21 <lament> <lament> > tail twinPrimes
02:00:27 <lament> <lambdabot> Exception: <<loop>>
02:00:45 <b_jonas> kfish: "datatype renaming" is just a name. it doesn't mean much to me.
02:00:46 <lament> * lament gets the Fields medal
02:00:55 <wnoise> Heh.
02:01:23 <quicksilver> b_jonas: newtype is a strict version of data, with only one field
02:01:32 <quicksilver> b_jonas: the advantage over data is that it has zero runtime overhead
02:01:46 <quicksilver> b_jonas: the semantic difference is that there is no room for an extra bottom
02:02:06 <lament> just like siamese twins joined at the hip!
02:02:09 <quicksilver> KatieHuber: you'll be pleased to know I've banished the openGL primitives
02:02:13 <b_jonas> quicksilver: is it more strict (or less room for bottom) than a data with a single constructor than a single strict (banged) field?
02:02:33 <b_jonas> or is there any other difference form that?
02:02:34 <quicksilver> b_jonas: no, it's the same as strictness as that
02:03:03 <quicksilver> b_jonas: however, single constructor with strict field might still have a runtime overhead
02:03:09 <quicksilver> b_jonas: newtype is guaranteed not to
02:03:51 <quicksilver> KatieHuber: wrote myself a .OBJ loader! :)
02:04:01 <b_jonas> I imagine an optimzer would probably easily recognize such a strict datatype construcor anyway, so it would have no overhead
02:04:22 <quicksilver> b_jonas: that's a plausible thing to imagine
02:04:35 <quicksilver> b_jonas: strict datatype constructors aren't h98, I don't think?
02:04:39 <b_jonas> is it something like "register" in old c, that is, a hint for stupid compilers?
02:04:42 <quicksilver> b_jonas: whereas newtype is
02:04:58 <lament> it seems strange to have a whole keyword just for hints to compilers
02:05:03 <b_jonas> I think strict constructors are
02:05:28 <DRMacIver> It's also for hints to programmers. :)
02:05:40 <DRMacIver> (And there's generalised newtype deriving as a language extension)
02:05:56 <b_jonas> note how the complex constructor (:+) is in h98 as well
02:06:21 <b_jonas> DRMacIver: ah yes, that's true
02:06:34 <quicksilver> you're right, !constructors are h98
02:06:38 <quicksilver> it's !patterns that aren't
02:06:39 <b_jonas> but it differs only for a few classes
02:07:01 <quicksilver> ?
02:07:04 * DRMacIver disappears. Back in a bit
02:07:08 <quicksilver> generalized newtype deriving?
02:07:11 <b_jonas> I mean, Eq would probably derive the same for a strict datatype I think
02:07:20 <quicksilver> yes, Eq would
02:07:25 <quicksilver> but generalise newtype works for all classes
02:07:31 <quicksilver> even those which can't normally be derived
02:07:35 <quicksilver> that's the clever part :)
02:07:44 <quicksilver> like Monad, or MonadReader, or MyCustomClass
02:08:17 <b_jonas> quicksilver: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#newtype-deriving
02:08:19 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
02:08:35 <b_jonas> quicksilver: it works for _all classes_?
02:08:35 <b_jonas> ah, I see
02:08:37 <b_jonas> that makes sense
02:08:46 <quicksilver> yes, all classes
02:08:53 <quicksilver> it just wraps and unwraps the newtype
02:09:17 <b_jonas> plus, it says (and I can belive that) it could be more efficent than if you write the instance functions by hand
02:09:47 <quicksilver> well, in the case that you newtype a type which has hand-written specialisms, yes
02:10:29 <quicksilver> for example, consider sum :: (Num a) => [a] -> a
02:10:40 <quicksilver> sum is speciliased for Int (I believe so, anyway)
02:10:45 <quicksilver> in the ghc runtime
02:10:57 <quicksilver> if you newtype an Int and right the Num instance by hand, you'll lose that
02:11:09 <quicksilver> if you newtype an Int and use deriving it should get correctly translated
02:11:12 <quicksilver> or, I think that happens
02:11:33 <Saizan> uhm RULES are based on types..
02:12:00 <b_jonas> that still dones't give much of a reason for newtype's existance to me: this deriving thing could've been done with data as well
02:12:06 <quicksilver> Saizan: but newtype deriving re-uses the old dictionary rather than making a new one
02:12:51 <quicksilver> hmm
02:13:18 <Saizan> quicksilver: yes, but i don't think that matters, however i know almost nothing on this..
02:13:46 <quicksilver> Saizan: I'm talking abotu SPECIALIZE, not RULES
02:13:54 <quicksilver> Saizan: and I think SPECIALIZE is based on the dictionary
02:13:58 <quicksilver> Saizan: but I could easily be wrong :)
02:14:13 <b_jonas> ok, anyway, this must mean I'm not missing something obviously important about newtype
02:14:39 <quicksilver> not obvious to me, certainly
02:14:47 <quicksilver> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg01492.html
02:14:47 <lambdabot> Title: Re: Haskell 1.3 (newtype)
02:14:54 <quicksilver> ^^ this thread is a discussion of the subject
02:15:39 <Saizan> !paste
02:15:40 <hpaste> Haskell paste bin: http://hpaste.org/
02:16:29 <quicksilver> b_jonas: it looks like newtype also makes pattern matches lazy
02:16:35 <quicksilver> b_jonas: that is, irrefutable
02:16:43 <hpaste>  Saizan pasted "a difference between strict data and newtype" at http://hpaste.org/2941
02:17:22 <b_jonas> I see
02:17:34 <quicksilver> ah, which Saizan conveniently just demonstrated :)
02:18:29 <Saizan> :)
02:19:03 <b_jonas> so newtye makes calling the constructors strict in their argument but matching on their constructors in a let lazy?
02:19:32 <b_jonas> I'm not sure I understand all this lazyness thing that goes on in haskell, even without newtype or bangs.
02:19:34 <Saizan> it's more like the constructor is not really there at all
02:20:38 <Saizan> in fact when i loaded that code i got a pattern overlapped warning for the newtype
02:20:40 <b_jonas> awit no
02:20:46 <b_jonas> it can't be what I said
02:21:01 <b_jonas> because a functoin argument is matched as in like a case, not as in a let
02:21:16 <b_jonas> I mean
02:21:39 <quicksilver> basically because the compiler knows statically that there is only one case for a newtype
02:21:47 <quicksilver> it doesn't bother to do the case match
02:21:55 <quicksilver> there's only one possibility so there is no need to check
02:21:58 <b_jonas> data T = C Int; f C x = (); -- f undefined will diverge
02:22:22 <quicksilver> whereas with a data, it always checks
02:22:43 <yaarg> morning
02:22:57 <quicksilver> from reading that thread, at least, I read that there was plenty of opposition to newtype :)
02:23:24 <b_jonas> > let f (x :: Int, y :: Int) = ()
02:23:24 <lambdabot>  Parse error in pattern
02:23:34 <b_jonas> > let f ((x :: Int), (y :: Int)) = ()
02:23:34 <lambdabot>  Parse error in pattern
02:23:48 <quicksilver> type annotations in patterns are a ghc extension
02:24:02 <b_jonas> > let f :: (Int, Int) -> ()
02:24:02 <lambdabot>  Parse error
02:24:29 <b_jonas> > let f :: (Int, Int) -> (); f (x, y) = ()
02:24:29 <lambdabot>  Parse error
02:24:30 <quicksilver> > let f :: (Int,Int) -> () ; f (x,y) = () in f (1,2)
02:24:32 <lambdabot>  ()
02:24:45 <b_jonas> > let f :: (Int, Int) -> (); f (x, y) = () in f undefined
02:24:47 <lambdabot>  Undefined
02:24:53 <b_jonas> that's it
02:25:15 <b_jonas> we can't try with strict data or newtype here
02:25:36 <quicksilver> but, compare to
02:25:46 <quicksilver>  > let f :: (Int, Int) -> (); f _ = () in f undefined
02:25:52 <quicksilver> > let f :: (Int, Int) -> (); f _ = () in f undefined
02:25:54 <lambdabot>  ()
02:26:12 <quicksilver> it was the implicit 'case' in your equation for f which provoked the undefined
02:26:27 <quicksilver> with a newtype, even that wouldn't happen
02:26:58 <b_jonas> hmm
02:27:20 <b_jonas> yes, exactly
02:27:32 <b_jonas> because a function definition can have multiple patterns
02:28:20 <b_jonas> while 'let (x, y) = undefined' doesn't diverge
02:28:38 <quicksilver> not until you try to access x or y, right
02:28:59 <b_jonas> so that answers how newtype has a different semantics
02:29:05 <quicksilver> yes
02:29:21 <quicksilver> newtype is like a single struct data which is always implicitly matched with ~
02:29:23 * mux didn't know about differences in strictness of pattern matching between data/newtype
02:29:32 <quicksilver> s/struct/strict/
02:29:37 <quicksilver> there is also a further, subtle different
02:29:43 <quicksilver> you can newtype *anything*
02:29:49 <quicksilver> but there are, I think some things you can't !
02:30:02 <b_jonas> like what? a function?
02:30:03 <quicksilver> at least I just read that, but there wasn't an example
02:30:11 <quicksilver> soI'm not sure :)
02:30:18 <b_jonas> I mean, you can seq anything, can't you?
02:30:21 <b_jonas> :t seq
02:30:23 <lambdabot> forall a t. a -> t -> t
02:30:42 <quicksilver> yes, you can
02:30:53 <b_jonas> I mean, it won't even fail or something
02:31:01 <quicksilver> the dirty truth is that newtype is really an implementation thing
02:31:19 <quicksilver> the point about newtype, in an STG-like machine, is that the representation is exactly the same
02:31:23 <quicksilver> no tag to check
02:31:47 <quicksilver> I guess they thought it was an important enough implementation thing to put in the language, though
02:31:57 <b_jonas> STG?
02:32:09 <quicksilver> because it's the key reason why adding an extra layer of indirection (like newtype'ing IO)
02:32:10 <mux> spineless tagless g-machine
02:32:17 <quicksilver> is not a performance problem
02:32:20 <mux> the execution model of GHC
02:32:23 <mux> unless I'm mistaken
02:32:31 <quicksilver> right
02:32:43 <b_jonas> I thought data declarations would be implemented in like five different ways depending on their form and types anyway
02:33:29 <b_jonas> is g-machine like some pointer machine?
02:33:41 <mux> @where STG
02:33:41 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
02:33:43 <b_jonas> one that has cons cells or something like that instead of addresses
02:33:53 <quicksilver> it's quite a bit cleverer than that
02:33:58 <quicksilver> but it's along those general lines
02:34:02 * mux is still reading this paper
02:34:24 <b_jonas> people want to define a machine for every higher-level language
02:34:29 <mux> the cool thing with haskell is that since I started programming with it, I've never been short on stuff to read while in the subway going to work :-)
02:34:41 <b_jonas> there's one for prolog, one for lisp, one for forth
02:35:44 <b_jonas> I can understand the lisp and forth ones because 1. they exist in hardware 2. they use them to argue about garbage collection so they don't have to mention all lisp primitives, only all lisp machine primitives
02:36:18 <quicksilver> the STG machine is a compilation technique
02:36:29 <quicksilver> or that's one important way of looking at it
02:36:56 <quicksilver> it's a rather efficient one, but I'm no expert on the various ways of compiling lazy languages
02:36:57 <b_jonas> that's what they say about prolog as well :)
02:39:09 <b_jonas> I can belive it about forth because I've seen a table on how the primitives of (a certain) forth machine map to 386 istructions
02:39:37 <b_jonas> but others just seem like a bytecode thing, rather than compilation to machine code
02:40:01 <quicksilver> one way of looking at the STG machine (and I'm no expert here) is to look at how paramters are passed
02:40:06 <b_jonas> they can of course be the most efficent way to compile that language as well
02:40:11 <quicksilver> compared with, say, compiling haskell naively into C
02:40:13 <quicksilver> and then compiling the C
02:40:28 <quicksilver> the STG machine goes to considerable contortion to not actually 'pass' anything
02:40:34 <quicksilver> data stays in the same place
02:40:43 <quicksilver> and everything dances around the data
02:40:53 <b_jonas> uh huh
02:41:02 <quicksilver> as contrasted with C where everything is forever being stuff onto stacks and popped off
02:42:18 <quicksilver> the SPJ paper is very readable, I recommend it
02:43:11 <b_jonas> I think I want to learn haskell first and not the implementation of it
02:43:21 <quicksilver> I think that's a reasonable idea :)
02:43:22 <quicksilver> but you did ask...
02:43:38 <b_jonas> yeah
02:43:53 * DRMacIver adds the paper to his list of things to read.
03:01:08 <SamB_XP> quicksilver: I'm not seeing that happen
03:01:19 <quicksilver> SamB_XP: which part?
03:01:35 <SamB_XP> the part where GHC makes some effort to avoid the stack
03:01:45 <SamB_XP> I mean, sure, it avoids the *C* stack
03:04:07 <quicksilver> SamB_XP: it's entirely possible that my comprehension of the model is flawed
03:04:34 <quicksilver> ;)
03:05:29 <SamB_XP> of course, since apparantly GHC's current STG is neither spineless nor tagless, not to mention not having any particular resemblance to the G machine, maybe that's not the STG machine exactly ;-P
03:05:55 <quicksilver> that could also be an issue
03:08:10 <joelr1> good morning!
03:08:31 <joelr1> dons: do you have an embedded specialization these days?
03:15:08 <DRMacIver> Why is GHC so far from a G-machine?
03:15:33 <DRMacIver> (Or a spineless tagless one for that matter)
03:15:56 <quicksilver> SamB_XP: can you reference the suggestion that GHC's STG isn't tagless?
03:16:30 <SamB_XP> quicksilver: I don't remember the name of the paper...
03:16:41 <quicksilver> SamB_XP: was it an SPJ paper?
03:16:50 <SamB_XP> oh, probably...
03:16:55 <quicksilver> ok, I'll look on his website
03:16:56 <quicksilver> thanks :)
03:17:50 <quicksilver> SamB_XP: http://research.microsoft.com/research/pubs/view.aspx?id=2056&type=inproceedings ?
03:17:52 <lambdabot> Title: Faster laziness using dynamic pointer tagging, http://tinyurl.com/37ccn8
03:20:15 <SamB_XP> quicksilver: that's the one
03:22:35 <quicksilver> SamB_XP: thanks
03:24:05 <quicksilver> SamB_XP: hmm. I already have that one on my hard disk
03:24:18 <SamB_XP> hehe
03:24:20 <quicksilver> SamB_XP: maybe I've already read it and already forgotten it :)
03:43:58 <zith_> is there a smooth and easy way to do element-wise matrix addition of an int matrix in haskell?
03:44:13 <zith_> where the matrix is just a list of lists of ints
03:44:28 <sieni> yes
03:45:08 <dolio> > zipWith (zipWith (+)) [[1,2,3],[4,5,6]] [[7,8,9],[10,11,12]]
03:45:09 <lambdabot>  [[8,10,12],[14,16,18]]
03:45:11 <EvilTerran> zipWith (zipWith (+))
03:45:16 <EvilTerran> hm.
03:45:35 <KatieHuber> darn, beaten :/
03:45:58 <zith_> thanks!
03:46:59 <quicksilver> > (zipWith.zipWith) (+) [[1,2,3],[4,5,6]] [[7,8,9],[10,11,12]]
03:47:00 <lambdabot>  [[8,10,12],[14,16,18]]
03:47:11 <quicksilver> I'm rather fond of the zipWith.zipWith form
03:47:16 <quicksilver> because it reminds one of map.map
03:47:17 <opqdonut> ah
03:47:19 <opqdonut> nice indeed
03:47:20 <quicksilver> which is a 2-deep map
03:47:25 <opqdonut> yep
03:47:48 <quicksilver> KatieHuber: You probably missed my comments to you earlier, if you don't automatically scrollback for your highlights...
03:48:07 <KatieHuber> ah, I hadn't noticed
03:48:18 <KatieHuber> but yay for OBJ loading ^_^
03:48:26 <KatieHuber> did you use parsec or something?
03:49:13 <quicksilver> KatieHuber: no, it's too easy for that
03:49:17 <quicksilver> KatieHuber: just case-matching
03:49:43 <KatieHuber> the f lines are a bit tricky in C with scanf
03:50:04 <quicksilver> 73 LOC, apparently
03:50:15 <KatieHuber> to match an arbitrary number of i/i/i or i/i
03:50:20 <hpaste>  quicksilver pasted "OBJ loader" at http://hpaste.org/2942
03:50:40 <quicksilver> to be fair, I only match quads and tris
03:50:48 <quicksilver> I'm pretty sure blender will only produce quads and tris
03:50:58 <quicksilver> but it would not be hard to generalise
03:51:17 * KatieHuber shudders at the thought of blender
03:51:36 <quicksilver> I've nly been using blender for a few days
03:51:43 <quicksilver> and last time I used a modeller was about 15 years ago on a mac
03:51:45 <quicksilver> but it seems OK to me
03:51:53 <KatieHuber> If you haven't tried it, Wings3D is worth a look
03:52:05 <KatieHuber> about 50% of people think it is great, the other 50% hate it totally
03:52:12 <KatieHuber> obviously I'm in the former camp ;)
03:52:25 <KatieHuber> fewer features than blender, but much easier to just model stuff in
03:52:33 <KatieHuber> also, written in erlang = automatic coolness points
03:52:59 <quicksilver> I'm finding blender easy to model in, but then I'm doing simple stuff so far
03:53:11 <KatieHuber> see, I have trouble making a cube in blender, so... ;)
03:53:25 <quicksilver> I might one day use blender's animation stuff, too
03:53:34 <quicksilver> although then I'd need a better file format...
03:53:46 <KatieHuber> yeah, then file formats start to be the problem
03:53:56 <KatieHuber> I think there's a decent MD5 (doom 3) exporter for blender
03:54:05 <KatieHuber> and that's another simple text format
03:54:40 <quicksilver> not quite sure which eye-candy route to follow
03:54:57 <quicksilver> not sure if I should use mapped texture graphics for everything
03:55:16 <quicksilver> or if I should have some other techniques too like multiple Gl renders with different settings
03:56:43 <quicksilver> for highlights, translucency and stuff
03:57:05 <quicksilver> even reflections...
04:06:03 <dcoutts> pgavin-away: yes, gtk2hs-0.9.12 does need a patch to compile with latest glib version
04:12:29 <b_jonas> The GHC user's guide says at http://www.haskell.org/ghc/docs/latest/html/users_guide/introduction-GHC.html that "GHC supports numerous language extensions, including "..." exceptions, "..."These are all described in Chapter 7, GHC Language Features."
04:12:31 <lambdabot> Title: Chapter 1. Introduction to GHC, http://tinyurl.com/3a929x
04:12:54 <b_jonas> But in that Chapter 7, there seems no mention of exceptions.
04:13:08 <b_jonas> How come?
04:14:03 <Cale> b_jonas: I suppose they're documented well enough by the documentation for Control.Exception
04:15:15 <b_jonas> I see. It's still a minor doc bug though because it says "all"
04:15:29 <doserj> i.e., exceptions are just a library, not a language extension
04:16:01 <Cale> Well, they are also a language extension to some extent.
04:16:27 <quicksilver> doserj: they are a language extension; you can't define "throw" or "catch" in terms of something simpler
04:16:40 <quicksilver> however, a very limited kind of exception is in H98: that is "error"
04:17:19 <Cale> There's ioError
04:17:21 <Cale> and catch
04:17:57 <nornagon> what's wrong with using the Either monad for exceptions?
04:19:35 <Cale> nornagon: Not much except that nesting monads is a little awkward.
04:19:51 <nornagon> alas :(
04:20:08 <Cale> It's better to have the IO monad itself provide a mechanism for failure
04:20:13 <sieni> or ErrorT?
04:20:28 <quicksilver> nornagon: I think the awkward squad paper gives some justification for the existance of imprecise exceptions
04:20:34 <quicksilver> as distinct from explicit error types
04:20:41 <Cale> Well, even when you're using monad transformers, it's better to newtype them
04:20:47 <nornagon> it'd be nice to have pure IO actions that you can guarantee will never fail
04:20:56 <quicksilver> personally I quite like explicit error types
04:21:01 <Cale> So you might imagine that IO has been ErrorT'd and then newtyped again :)
04:21:02 <b_jonas> funny how innocent questions like this can spawn such a discussion or irc
04:21:20 <quicksilver> and I view the awkwardness of nesting monads as an interesting problem to try to solve
04:21:26 <quicksilver> rather than the reason to avoid it :)
04:21:32 <quicksilver> but it's certainly a real problem
04:21:36 <Cale> Well, it really is a properly interesting problem
04:21:39 <nornagon> IO = ErrorT IO'?
04:21:48 <Cale> Take two programming languages, combine their functionality
04:22:03 <Cale> That's essentially the problem of combining monads.
04:22:42 <quicksilver> yes
04:22:52 <quicksilver> but solving it in certain cases may be simpler than a general solution :)
04:23:59 <Cale> Monad transformers are a pretty good solution, given the difficulty. However, I'd usually want even less automation of lifting.
04:24:25 <Philippa_> <nornagon> it'd be nice to have pure IO actions that you can guarantee will never fail <- no such thing
04:24:46 <Cale> putStrLn ?
04:24:46 <laziest> where can I get a copy of "Predictive parser combinators need four values to report errors", JFP 6(2): 355-364, 1996? It does not seem to be online.
04:24:49 <Philippa_> once you're in IO, you've got to worry not only about launching your own missiles but about getting hit by the other guy's
04:26:04 <b_jonas> lol
04:26:38 <quicksilver> dodgeIncoming $ safeAction
04:26:59 <quicksilver> laziest: by going to a library which holds copies of JFP or contacting the authors, I fear
04:27:05 <Philippa_> which'll throw a CantDodgeWorldwideNuclearBarrageException
04:27:13 <quicksilver> damn
04:27:15 <quicksilver> well played
04:28:01 <Philippa_> really the best you can do in IO is "this shouldn't throw an error unless something outside my program has Gone Wrong"
04:28:57 <quicksilver> which is, sort-of, the flaw in the java "throws" clause
04:29:09 <quicksilver> although having a throws clause is a really nice idea
04:29:19 <quicksilver> in practice there is stuff you can't statically anticipate
04:29:24 <Philippa_> and the equivalent in pure code would be a really good idea
04:30:01 <quicksilver> Philippa_: sin't that isomorphic to Either (throws clause) (result) ?
04:30:43 <b_jonas> quicksilver: it's not a flaw
04:31:07 <b_jonas> throws only means that if you get an exception other than that, you may not be able to recover from it without problems
04:31:36 <b_jonas> that is, you may not be able to unroll the stack properly and deallocate all memory and other resources and stuff, and existing objects can be in an invalid state
04:32:06 <Philippa_> quicksilver: give or take. We don't have a neat way of merging sets of possible exceptions at the moment
04:32:08 <b_jonas> you may still get such an exception and in some cases try to do something franatically before exitting
04:32:16 <quicksilver> "existing objects can be in an invalid state" is a death-knell
04:32:33 <quicksilver> I don't much want to have a reachable situation where my stuff is invalid
04:32:43 <quicksilver> that is impossible to recover from in general
04:32:45 <b_jonas> quicksilver: yeah, but it's really only the objects you've touched
04:33:02 <b_jonas> you can still have a few things set aside that you use only when you handle such an exception
04:33:06 <quicksilver> Philippa_: Yes, point taken.
04:33:20 <b_jonas> of course, you can't handle two such exceptions or such an exception very early
04:41:37 <wli> Everyone's asleep on #haskell-blah :(
04:42:00 <kaol> no they aren't
04:42:11 <kaol> oh, ok, they are
04:54:45 <simedw> Hi, Like everyone else I'm currently learning haskell while making opengl application (and other stuff). But I come across a poblem that I can't solve. I want the user to be able to press multi keys at the same time (like the arrows to move and space to shot), but keyboardMouseCallback (Graphics.UI.GLUT.Callbacks.Window) executes for both keys only once, then it choosen one key to repeate (globalKeyRepeat $= GlobalKeyRepeatOn). But I want
04:54:45 <simedw> to repeate both (or more).
04:56:22 <Lemmih> In SDL that's usually done by pulling the keyboard state.
05:00:58 <EvilTerran> can you bind to "key down" and "key up" rather than "key press", and maintain your own "is this key down" variable?
05:01:16 <EvilTerran> (key press repeats, key down doesn't, iirc)
05:02:23 <EvilTerran> i haven't done GLUT, so i'm not sure if that's the case. but that's how other UI thingies i've used do it.
05:05:11 <simedw> thanks, sounds a bit ugly but it'll do the job
05:15:55 <fasta> How is popen called in Haskell?
05:16:18 <mux> :t runInteractiveCommand
05:16:21 <lambdabot> Not in scope: `runInteractiveCommand'
05:16:23 <mux> damn
05:16:28 <mux> @hoogle interactive
05:16:28 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
05:16:28 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
05:17:27 <fasta> The  type argument  is a pointer to a null-terminated string which must be either "r" for reading or "w" for writing.
05:17:44 <fasta> How is that difference implemented in runInteractiveCommand?
05:18:46 <mux> runInteractiveCommand is not really like popen, but I think there's a popen function in lambdabot that should be closer to it
05:19:01 <mux> with runInteractiveCommand you get Handles for stdin,out, and err
05:19:12 <mux> so you can do bi-directional stuff if you so wish
05:19:36 <mux> and if you want to do read-only or write-only, it's just a matter of using the appropriate Handle
05:19:43 <b_jonas> you could always try to emulate popen with pipe, dup2, close, fork, exec; though I've no idea what the haskell equivalents of those are
05:20:45 <mux> I think it'd be easier and saner to base it off runInteractiveCommand
05:20:50 <mux> and more portable, probably
05:21:34 <b_jonas> (and wait* to implement pclose)
05:22:12 <fasta> What's the difference between "w" and "r" anyway(yes, I know what they stand for)?
05:22:59 <fasta> Never mind.
05:27:57 <b_jonas> (and fdopen which I've forgot)
05:29:58 <b_jonas> :source String
05:58:47 <blakkino> eclipsefp doesn't start a ghci session when i click run.. any idea? (sorry for that out of topic question)
05:59:27 <earthy> that is not out of topic
05:59:43 <earthy> but I don't have any ideas
05:59:53 <earthy> on that particular subtopic
06:06:01 <dmead> blakkino, on linux?
06:06:24 <dmead> you might need to set up your paths in options
06:08:13 <blakkino> dmead, ghc work
06:08:15 <blakkino> ghci doesn't
06:08:29 <blakkino> sure it is a path problem?
06:08:42 <blakkino> anyway i will take a look at eclipse preferences
06:15:45 <dmead> i think it worked by default for me
06:15:49 <dmead> as ghci
06:16:10 <dmead> anyway, emacs is still better for fp  IMHO
06:24:36 <ttfh> hello
06:47:35 <iguana_> is there a function that, given "abcdef" and "c", returns Just ("ab", "def")?
06:48:43 <mrd> break / tail
06:48:49 <beelsebob> @hoogle splitAt
06:48:50 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
06:48:50 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
06:48:50 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
06:49:07 <beelsebob> ah no
06:49:09 <beelsebob> not that
06:49:14 <beelsebob> @hoogle splitOn
06:49:14 <lambdabot> No matches found
06:49:16 <beelsebob> bah
06:49:17 <mrd> > (second tail) (break (=='c') "abcdef")
06:49:22 <lambdabot>  ("ab","def")
06:49:52 <mrd> or you can use the regex library splitRegex .. etc
06:49:57 <iguana_> yeah
06:51:24 <iguana_> @src second
06:51:24 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:52:09 <mrd> second is an arrow function which, in this case, has the nice property of applying a function to the second element of a pair
06:53:20 <quicksilver> nice function poorly named :)
06:53:57 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2946
06:54:09 <iguana_> it's a four liner :)
06:55:18 <quicksilver> > (\n -> splitAt (n+1) "abcdef") `fmap` findIndex (=='c') "abcdef"
06:55:20 <lambdabot>  Just ("abc","def")
06:55:32 <quicksilver> bah, not quite.
06:55:44 <iguana_> quicksilver: I need a string as separator, not a char
06:56:09 <quicksilver> you can change =='c' to ("c" `isPrefixOf`)
06:56:21 <quicksilver> oh, no you can't
06:56:26 <quicksilver> then you need to use tails
06:57:15 <quicksilver> > (\n -> splitAt (n+1) "abcdef") `fmap` findIndex ("cd" `isPrefixOf` ) (tails "abcdef")
06:57:16 <lambdabot>  Just ("abc","def")
06:57:29 <quicksilver> but it's doing something a bit funny with the separator part :)
06:57:39 <iguana_> the n+1, I presume
06:57:45 <quicksilver> right
06:59:10 <quicksilver> iguana_: the only point of the stupid way I'm doing it
06:59:16 <quicksilver> iguana_: was to get the 'Just' you asked for :)
07:21:42 <laz0r> hi #haskell, i am having problems with installing the zlib cabal package
07:21:55 <laz0r> anyone here care to help?
07:22:11 <laz0r> Setup.hs: zlib.cabal:14: Invalid syntax (no colon after field name)
07:22:16 <laz0r> ^ thats my problem
07:22:22 <mux> can you show the relevant line here?
07:22:44 <laz0r> flag bytestring_in_base
07:23:01 <laz0r> thats line 14, tried to change it to 'flag: bytestring_in_base'
07:23:03 <mux> hmmm
07:23:04 <laz0r> didnt help
07:23:12 <mux> I'm not sure flag is a valid cabal field
07:23:18 <mux> can you paste the whole file on hpaste.org?
07:23:25 <laz0r> ok
07:23:26 <mux> and also, are you running GHC 6.8?
07:23:38 <laz0r> no, i think im running 6.6
07:23:39 <mux> GHC 6.8 has Cabal 1.2, which introduced some incompatibilities
07:23:45 <mux> hmm
07:23:45 <laz0r> do i need 6.8?
07:23:50 <mux> no
07:23:55 <mauke> is 6.8 out?
07:24:11 <mux> there's a RC of it, IIRC
07:24:37 <hpaste>  laz0r pasted "zlib.cabal" at http://hpaste.org/2948
07:25:51 <mux> hmm, sorry but I don't know this cabal syntax, so I don't know how to fix it
07:25:59 <mux> presumably, other people in here will be able to help you
07:26:28 <laz0r> mmh, ok
07:26:54 <laz0r> thanks anyways, i'll try around with it a little more, maybe i get it to work
07:30:07 <doserj> laz0r: you do not need ghc 6.8, but you do need cabal 1.2
07:31:09 <pastorn> if i make a game or something in haskell and have daLoop :: World -> IO World
07:31:27 <pastorn> how does that work with the garbage collector each loop?
07:31:46 <laz0r> doserj, how can i upgrade cabal seperatly?
07:32:19 <pastorn> does it throw out the old world from the memory with each loop?
07:32:22 <laz0r> doserj, nevermind, i think i found out myself
07:32:30 <byorgey> good morning #haskell!
07:35:17 <matthew_-> it's 3:32pm
07:35:22 <Olathe> Good morning !
07:35:29 <Olathe> It's 3:32 PM in evilland !
07:36:03 <matthew_-> no, iran's a fair bit ahead
07:36:42 <phobes> pastorn:  If you do things that way, then probably on average it would garbage collect one world per frame, though note there can be shared values between worlds
07:39:14 <pastorn> phobes: what do you mean by shared values?
07:40:45 <phobes> pastorn:  If you reuse a value from the old world when constructing the new world, then that value will be shared
07:41:11 <pastorn> oh, pointers?
07:41:23 <phobes> That's likely how it will be implemented yes
07:41:35 <phobes> So if you have a giant table of game data in your world
07:41:55 <fasta> pastorn: suppose you have a character foo, then in the next frame you call raise hand, then the new character will be built from the old character.
07:42:10 <pastorn> yeah
07:42:10 <phobes> and you just pass that along from the old world to the new, then that will not be implemented as a copy and a garbage collection - it will just be a pointer move
07:42:11 <fasta> pastorn: it will not create a completely new character.
07:44:09 <pastorn> fasta: does this work differently for non-IO functions? eg. modify :: Model -> Action -> Model
07:44:18 <phobes> no
07:44:26 <phobes> it works the same way
07:44:57 <fasta> This is something that needs to explained better, I guess.
07:45:14 <pastorn> nah, i think i get it :)
07:45:23 <fasta> Something with about 10 examples showing how the sharing process algorithm exactly works.
07:45:38 <quicksilver> pastorn: in practice, large chunks tend to be shared
07:45:47 <fasta> I read it in a book, but I haven't seen it on the web.
07:45:56 <phobes> if you have   updateActor (Actor pose appearance) = Actor (updatePose pose) appearance
07:45:59 <quicksilver> pastorn: especially since tree and list-like structures can share 'part' of their structure
07:46:11 <phobes> Then the value appearance there is shared
07:46:23 <fasta> quicksilver: and graph like structures too
07:46:30 <quicksilver> fasta: absolutely
07:47:09 <pastorn> so if i have something that is going to be modified it happendes like this: f char action = 1) copy char to mem_x 2) apply action to mem_x 3) return value at mem_x
07:47:49 <pastorn> phobes: cool :D
07:47:52 <quicksilver> hmm not really
07:47:54 <phobes> pastorn:  Copying never happens - this process of sharing values happens recursively to the lowest levels
07:48:05 <quicksilver> pastorn: there is very little/no redundnat copying
07:48:18 <quicksilver> pastorn: new values are created in a new memory location, based on old value in old locations
07:48:31 <quicksilver> pastorn: but new value may in fact consist mostly of pointers to old
07:48:47 <pastorn> okay
07:49:09 <Tac-Work> sweet, I finally, after several weeks of poking figured out on my own how to do factorial with the Cont monad!
07:49:22 <quicksilver> pastorn: for example "goodbye" ++ (drop 5 "hello world")
07:49:30 <hpaste>  Tac-Work pasted "Factorial, brought to you by Cont" at http://hpaste.org/2949
07:49:35 <quicksilver> pastorn: the bit of memory containing 'world' is shared between the two
07:49:45 <Tac-Work> now if I can only figure out *why* my code works
07:50:02 <quicksilver> Tac-Work: why it works? because it type checks, of course :)
07:50:31 <Tac-Work> Haskell's type checker is so advanced, it only compiles the program you INTENDED to write
07:50:38 <pastorn> Tac-Work: swell :D
07:50:48 <Tac-Work> Hurray imperativity!
07:51:32 <pastorn> quicksilver: ok, coolerz
07:51:50 <EvilTerran> take 5 "hello world", on the other hand, does cause copying
07:52:23 <pastorn> yeah, cause you can't share a part of a list
07:52:26 <EvilTerran> because you need a new 'o' cell with [] as its tail, and you need a new 'l' cell pointing to that, and so on
07:52:47 <EvilTerran> you can share list tails, but not list inits.
07:53:05 <pastorn> what? that's just plain confusing
07:53:13 <EvilTerran> see what quicksilver said above about "goodbye" ++ (drop 5 "hello world")
07:53:24 <EvilTerran> x:xs and y:xs can share xs.
07:53:56 <EvilTerran> x:xs and x:ys can share x.
07:54:09 <pastorn> ah
07:54:10 <EvilTerran> in both instances, each has its own (:) cell
07:54:41 <pastorn> but why not just point at the head and say "start sharing here"?
07:54:41 <EvilTerran> but, because of this, take 5 "hello world" can't share with "hello world", but drop 6 "hello world" can
07:54:52 <quicksilver> pastorn: starting sharing is fine
07:55:00 <quicksilver> pastorn: the problem is there is no way to stop sharing
07:55:13 <quicksilver> pastorn: (because *everythign* is shared, there is no control structure outside)
07:55:32 <quicksilver> pastorn: so if you share the "he.." part, then you are shared all the way down to "hello world"
07:55:42 <quicksilver> becaue the 'e' cell contains a pointer to the first 'l'
07:55:47 <quicksilver> and that contains a pointer to the second 'l'
07:55:48 <quicksilver> etc etc
07:56:20 <quicksilver> if you want to be really precise I'm actually talking about the (:)-cells
07:56:23 <quicksilver> not the chars themselves
08:00:32 * pastorn reads and tries to understand...
08:00:49 <pastorn> are the lot of you GHC devs or what?
08:01:44 <mauke> I doubt that
08:06:19 <quicksilver> no, none of the people in that conversation were GHC devs
08:06:31 <quicksilver> sharing is subtle until you get the hang of it, but it's not unique to haskell
08:06:41 <quicksilver> ML and lisp both support sharing-style coding
08:06:54 <quicksilver> (although lisp has updateable cons cells which make it a complete mess)
08:07:16 <mauke> so does C :-)
08:07:21 <mauke> but lack of automatic memory management makes it a pain in C
08:07:25 <Tac-Work> Why doesn't Haskell have something like a container class: class Container c a where { elem :: c -> a -> Bool; notElem :: c -> a -> Bool; notElem = not elem}
08:07:40 <mauke> that's not a generic container
08:07:41 <sjanssen> Tac-Work: see edison
08:07:53 <Tac-Work> Didn't he die long ago?
08:08:05 <mauke> @where edison
08:08:05 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
08:08:06 <quicksilver> Tac-Work: because it requires MPTCs
08:08:18 <quicksilver> Tac-Work: and, there turn out to be some interesting design choices to make
08:08:23 <mux> could be reimplemented using ATs I guess
08:08:26 <quicksilver> Tac-Work: there are two or more libraries out in the wild using it, though
08:08:34 <Tac-Work> MPTC = multiparameter typeclasses?
08:08:35 <quicksilver> mux: it's a textbook AT, yes
08:08:38 <quicksilver> Tac-Work: yes
08:08:51 <Tac-Work> do MPTC cause any problems with the type system?
08:09:00 <Tac-Work> or are they something that are due to be standardized?
08:09:02 <quicksilver> mux: class Containter c where { type Element; ... }
08:09:07 * mux nodes at quicksilver 
08:09:10 <mux> nods, rather
08:09:15 <sjanssen> MPTCs don't really cause problems, functional dependencies do
08:09:18 <quicksilver> Tac-Work: no problems; yes they will probably be standardised
08:09:31 <quicksilver> they just weren't in haskell 98
08:09:35 <Tac-Work> Yeah, I can't keep all the type extensions straight in my head
08:10:22 <fasta> I am still not convinced that ATs can do everything FDs can.
08:10:22 <quicksilver> @where containers
08:10:22 <lambdabot> I know nothing about containers.
08:10:23 <sjanssen> MPTCs are a nightmare for type inference, you really need fundeps to resolve ambiguities
08:10:43 <sjanssen> fasta: there's a desugaring presented in one of the papers
08:10:45 <mux> fasta: I think I've read something saying ATs subsume FDs
08:11:04 <quicksilver> Tac-Work: there is also a library called containers but I can't find it, I thought it was different from Edison
08:11:04 <fasta> Ok, good.
08:11:07 <quicksilver> not sure
08:11:23 <sjanssen> quicksilver: it's called collections IIRC
08:12:18 <quicksilver> ah
08:12:29 <quicksilver> containers is just the new-style name for Data.Map, Data.Set and some other stuff
08:12:32 <quicksilver> I think
08:12:35 <quicksilver> ghc-pkg name for it
08:13:42 <quicksilver> sjanssen: "MPTCs are a nightmare for type inference" suggests that there is somehow some way in which they make the algorithm more complex
08:13:48 <quicksilver> sjanssen: IMO the algorithm is just fine :)
08:13:59 <quicksilver> sjanssen: it's just that it quite often can't resolve the ambiguity
08:14:16 <sjanssen> quicksilver: nightmare from the user's perspective
08:14:19 * quicksilver nods
08:14:23 <quicksilver> right
08:14:26 <Tac-Work> what if it just used a choice function to resolve ambiguities?
08:14:35 <quicksilver> it does somethiing quite sane
08:14:36 <Tac-Work> hehe
08:14:38 <quicksilver> it just complains
08:14:43 <quicksilver> and asks for an explicit type signature
08:14:48 <quicksilver> I think that's fine, personally :)
08:15:08 <EvilTerran> without fundeps or something else to resolve ambiguities, you do end up using more type sigs, though
08:15:16 <quicksilver> and in some cases where you think "Well it's *obvious* which one I wanted", then, perhaps, a fundep will solve it.
08:15:30 <EvilTerran> quite. like that FunctorOf class i had earlier
08:15:33 <Tac-Work> The Haskell compiler is something like a very very brilliant, but extremely irritable old man
08:15:34 * sjanssen invites quicksilver to add type signatures to "head . tail . head . tail . head . tail"
08:15:39 <quicksilver> I normally start with no fundeps
08:15:57 <quicksilver> and then put them in later if it becomes obvious to me which ones I wanted.
08:16:08 <fasta> How can I turn a TimeDiff into the number of seconds it represents?
08:16:16 <quicksilver> it's an instance of Num, IIRC
08:16:33 <EvilTerran> (class FunctorOf a fa b fb | a fa b -> fb, a fa fb -> b, a b fb -> fa, fa b fb -> b where fomap :: (a -> b) -> fa -> fb, iirc)
08:16:38 <quicksilver> so, realToFrac or round.
08:17:04 <EvilTerran> (ugly hack to get around the lack of partially-applied type synonyms)
08:17:13 <quicksilver> ah
08:17:21 <quicksilver> so you can make (,b) a functor?
08:17:21 <quicksilver> nice
08:17:38 <fasta> quicksilver: was that for me?
08:17:49 <quicksilver> fasta: realToFrac or round was for you
08:17:59 <EvilTerran> instance FunctorOf a a b b where fomap = id; instance (FunctorOf a fa b fb, Functor g) => FunctorOf a (g fa) b (g fb) where fomap = fmap . fomap
08:18:10 <fasta> quicksilver: they don't appear to work, since it says those instances do not exist.
08:18:23 <quicksilver> :t realToFrac
08:18:29 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
08:18:32 <quicksilver> should work
08:18:42 <quicksilver> DiffTime is an instance of REal
08:18:54 <EvilTerran> the magic of type inference means it can work out how many functors deep it needs to go based on the function you give it
08:18:57 <quicksilver> and Num, and Fractional.
08:18:59 <fasta> quicksilver: I said TimeDiff
08:19:08 <fasta> quicksilver: where do you get DiffTime?
08:19:13 <quicksilver> Data.Time.Clock
08:19:47 <quicksilver> System.Time is I think deprecated
08:19:53 <quicksilver> in favour of Data.Time.*
08:20:28 <EvilTerran> it does require that horrible mess of fundeps to be workable, though
08:20:30 <fasta> Oh, great. Why isn't it marked as such then...
08:20:41 <fasta> quicksilver: thanks
08:20:42 <quicksilver> I don't know.
08:20:46 <quicksilver> I have wondered the same.
08:21:00 <fasta> quicksilver: here's your change to open a bug report :)
08:21:04 <quicksilver> certainly System.Time appears to have holes in its API
08:21:06 <fasta> chance*
08:21:12 <quicksilver> and Data.Time appears to have a better one
08:22:34 <quicksilver> http://www.nabble.com/System.Time-tf1678534.html#a4551918
08:22:36 <lambdabot> Title: Nabble - System.Time
08:31:40 <dcoutts> laz0r: you need cabal-1.2
08:32:15 <dcoutts> laz0r: you're using the darcs version of my zlib library right?
08:44:50 <dons> ?users
08:44:50 <lambdabot> Maximum users seen in #haskell: 420, currently: 387 (92.1%), active: 13 (3.4%)
08:45:05 <puusorsa> 4:20
08:45:06 <puusorsa> hooray!
08:45:10 <dons> oh, new high score.
08:45:21 <puusorsa> _high_ score.. right ..
08:45:40 <puusorsa> sorry, that was/is stupid
08:59:07 <chessguy> it's clearly too quiet in here. i need to stir up some trouble
08:59:42 <Tac-Work> chessguy: Type safetype is worthless
08:59:47 <Tac-Work> (I'm helping ;-)
08:59:50 <Tac-Work> err
08:59:53 * chessguy giggles
08:59:53 <Tac-Work> typesafety
09:00:29 <Tac-Work> My poorly spelled, poorly thought out insults towards your precious language will bring about much debate in the chat room
09:01:01 <chessguy> sounds like "i fart in your channel's general direction"
09:01:36 <Olathe> Everyone knows that nonfunctional languages don't work.
09:01:58 <Tac-Work> something like that... only it would be a much more nerdy insult than any found in a monty python skit
09:02:12 <chessguy> true
09:02:18 <Tac-Work> (though it's hard to believe something could be nerdier than that)
09:03:05 <osfameron> @src groupBy
09:03:06 <lambdabot> groupBy _  []       =  []
09:03:06 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:03:06 <lambdabot>     where (ys,zs) = span (eq x) xs
09:03:10 <chessguy> "i fart in a vector that will intersect with your path within n units, for sufficiently small n"
09:03:14 <iguana_> why can't I section the tuple operator?
09:03:25 <iguana_> (1,) is a syntax error
09:03:33 <ToRA> > ((,) 1)
09:03:34 <lambdabot>  Add a type signature
09:03:37 <chessguy> @type ((,) 1)
09:03:39 <lambdabot> forall t b. (Num t) => b -> (t, b)
09:03:55 <iguana_> oh well
09:04:17 <Tac-Work> tuples can't be sectioned, iirc
09:04:22 <quicksilver> iguana_: because people like to write big tuples on multiple lines
09:05:38 <quicksilver> iguana_: and it was felt that if "having an extra trailing comma on the last line" turned it into a section
09:05:47 <quicksilver> iguana_: that would be confusing and give confusing errors
09:05:57 <quicksilver> I don't particularly agree, but there you go :)
09:06:07 <Tac-Work> > [1,2,3,]
09:06:07 <lambdabot>  Parse error
09:06:11 <Tac-Work> You can't do it with lists either
09:06:18 <quicksilver> right
09:06:20 <Tac-Work> in python, that would simply eval to [1,2,3]
09:06:27 <quicksilver> :t (1:2:3:)
09:06:29 <lambdabot>     The operator `:' [infixr 5] of a section
09:06:30 <lambdabot>         must have lower precedence than the operand `(:)' [infixr 5]
09:06:37 <quicksilver> that's broken IMO ;P
09:06:56 <quicksilver> but it would be weird in some ways if it worked, I admit
09:07:04 <quicksilver> because it would be a 'deep section'
09:07:08 <mrd> > ([1,2,3]++)
09:07:09 <lambdabot>  <[Integer] -> [Integer]>
09:07:23 <Tac-Work> sections are pretty close to obfuscation as it is
09:07:37 <Tac-Work> anyone who knows how to use @pl knows that
09:07:39 <mrd> (1+) is obfuscated?
09:07:45 <quicksilver> one mans obfuscation is another mans beautiful syntax
09:07:45 <Tac-Work> no, but it's also trivial
09:07:50 <Tac-Work> hehe
09:08:00 <quicksilver> simple sections are really nice
09:08:08 <quicksilver> here 'simple' is a subjective choice though :)
09:08:12 <Tac-Work> yeah
09:08:17 <mrd> > (second tail) (break (=='c') "abcdef")
09:08:19 <lambdabot>  ("ab","def")
09:08:20 <quicksilver> I don't much like the double-. sections
09:08:27 <Tac-Work> I just wish haskell did negative Num literals right
09:08:27 <quicksilver> :t ((map.).)
09:08:29 <lambdabot> forall a b a1 a2. (a2 -> a1 -> a -> b) -> a2 -> a1 -> [a] -> [b]
09:08:38 <Tac-Work> > (-1) 3
09:08:39 <lambdabot>   add an instance declaration for (Num (t -> a))
09:08:39 <lambdabot>     In the expression: (- 1)...
09:08:45 <Tac-Work> > (1-) 3
09:08:46 <lambdabot>  -2
09:08:54 <Tac-Work> > (+1) 3
09:08:55 <lambdabot>  4
09:08:58 <Tac-Work> > (1+) 3
09:08:59 <lambdabot>  4
09:09:01 <mrd> someone proposed (`-`1) for that
09:09:14 <allbery_b> -1 is an anomaly in haskell parsing.  (subtract 1) is the current hack
09:09:26 <chessguy> > (subtract 1) 3
09:09:28 <lambdabot>  2
09:09:33 <Tac-Work> Haskell should just use a different character for negation or something to that degree
09:09:40 <quicksilver> yes, I'd prefer that
09:09:45 <Tac-Work> ~3 or something
09:09:45 <mrd> SML does. but it's a contentious topic.
09:09:51 <quicksilver> but it was considered too newbie-unfriendly
09:10:33 <mrd> > - - 1
09:10:33 <lambdabot>  Parse error
09:10:34 <sebell> Does anyone have a one's complement checksum function handy? (eg. ICMP)
09:11:11 <Tac-Work> A Hasekllian newbie unfriendliness issue??? egads!!
09:11:44 <quicksilver> Tac-Work: surprising as it might seem, many of haskell's design decisions were made for that reason
09:11:50 <mrd> unfortunately
09:11:53 <quicksilver> Tac-Work: monomorphic 'map' and '++' for example
09:12:06 <mrd> and no monad comprehensions
09:12:14 <Tac-Work> monomorphic map and ++?
09:12:20 <mrd> non generic you mean
09:12:31 <Tac-Work> how would they be more general?
09:12:39 <quicksilver> map would be fmap
09:12:41 <Tac-Work> (I can imagine how, but what was it originally planned to be?)
09:12:42 <quicksilver> and ++ would be mappend
09:12:43 <mrd> functors
09:12:45 <Tac-Work> ah
09:12:51 <Tac-Work> functor is too scary a name
09:13:00 <quicksilver> > [1,2,3] `mappend` [4,5,6]
09:13:01 <mrd> functor is super awesome scifi name
09:13:02 <lambdabot>  [1,2,3,4,5,6]
09:13:05 <mauke> no, it isn't
09:13:09 <mauke> even C++ has functors
09:13:10 <Tac-Work> Haskell is full of scifi names
09:13:17 <Tac-Work> C++ has bologna =-P
09:13:18 <mrd> yea except C++ is dumb
09:13:25 <mrd> =)
09:13:31 <Tac-Work> functors are the C++ term for function pointers, right?
09:13:39 <mauke> no, function-like objects
09:13:45 <_fang> hello, i was given an exercise in my class that asked to show the numbers in a list from 0 to 100 that ended with x, eg. ends 7 l, would return 7, 17, 27, 37, etc. it was also asked that the function should be ends :: Int -> [Int]. i worked with the solution pasted below, but i get Int -> [a] -> [b]. if i comment out the function type it is ok. any tips?
09:13:46 <Tac-Work> which is the assembly level term for First order functions
09:13:47 <mrd> I wish we had ML functors sometimes though
09:13:49 <mauke> i.e. stuff that overloads operator()
09:13:57 <hpaste>  _fang pasted "ends" at http://hpaste.org/2950
09:14:16 <mrd> _fang: it was more than just that.. there were type classes right?
09:14:36 <quicksilver> mauke: I don't think functor is a very good name for those though :)
09:14:36 <Tac-Work> _fang: what is aux in your code?
09:14:41 <ToRA> @type concatMapM
09:14:43 <lambdabot> Not in scope: `concatMapM'
09:14:47 <Tac-Work> I never undrestood what a functor actually is
09:14:51 <mauke> Tac-Work: (a-x) `mod` 10
09:14:54 <Tac-Work> I've tried to read through the category theory page
09:15:00 <quicksilver> mauke: at least ML functors and haskell functors have some relation to cat theory
09:15:11 <mauke> lolcat theory?!
09:15:12 <_fang> Tac-Work: variable to check if it ends with the number i want
09:15:12 <Tac-Work> but it's dry technical lame-math X-(
09:15:18 <Tac-Work> ah
09:15:24 <Olathe> gorycat theory
09:15:24 <Tac-Work> err
09:15:27 <quicksilver> Tac-Work: a functor is a mapping between two things, which preserves the structure of the things
09:15:32 <mrd> _fang: make that a side function and do, endsHelper x [1..100]
09:15:50 <_fang> mrd: wich part as a side function?
09:15:58 <Tac-Work> _fang: if aux is declared outside of the function, it has to be constant. Which means aux == 0 will ALWAYs return the same value
09:16:04 <Tac-Work> wait
09:16:05 <Tac-Work> sorry
09:16:06 <Tac-Work> laugh
09:16:08 <chessguy> _fang, why not just use a filter?
09:16:12 <Tac-Work> I'm being dumb, it's in the where clause
09:16:17 <mrd> what you currently call ends. but yea you can probably rewrite the whole thing.
09:16:20 <mauke> isn't that ends :: (Integral a) => a -> [a] -> [a]?
09:16:31 <_fang> chessguy: i'm a total noob, i don't think i know how to use it! xD
09:17:07 <Tac-Work> _fang: but it does look like you are shadowing your global variable l
09:17:36 <hpaste>  mrd annotated "ends" with "(no title)" at http://hpaste.org/2950#a1
09:17:36 <_fang> mrd: but will i be able to run through the whole list this way?
09:17:46 <Tac-Work> quicksilver: so a functor is a a one-to-one onto function?
09:18:11 <dmead> Tac-Work, a functor is a function you pass as a variable
09:18:25 <quicksilver> Tac-Work: no, it's more than that
09:18:31 <quicksilver> Tac-Work: it preserves some kind of structure
09:18:39 <quicksilver> dmead: no it's not
09:18:39 <chessguy> > let ends n = filter (\x -> (x `mod` 10) - n == 0) [1..100] in ends 4
09:18:41 <lambdabot>  [4,14,24,34,44,54,64,74,84,94]
09:18:51 <quicksilver> Tac-Work: for example 'Maybe' is a functor
09:19:02 <chessguy> @pl \x -> (x `mod` 10) - n == 0
09:19:02 <lambdabot> (0 ==) . subtract n . (`mod` 10)
09:19:05 <quicksilver> Tac-Work: which preserves the structure of functions
09:19:08 <mrd> > ends x = filter (\ y -> last (show y) == x) [1..100]
09:19:08 <lambdabot>  Parse error
09:19:09 <Tac-Work> because Just x and x contain the same information?
09:19:18 <quicksilver> Tac-Work: if you have a function Int -> Int, you can make a function from Maybe Int -> Maybe Int
09:19:21 <mrd> > let ends x = filter (\ y -> last (show y) == chr x) [1..100] in ends 7
09:19:22 <lambdabot>  []
09:19:23 <quicksilver> Tac-Work: yes, that's the right intuitiion
09:19:27 <mrd> oops
09:19:36 <Tac-Work> so for Lists
09:19:40 <mrd> > let ends x = filter (\ y -> [last (show y)] == show x) [1..100] in ends 7
09:19:41 <lambdabot>  [7,17,27,37,47,57,67,77,87,97]
09:19:51 <Tac-Work> how is a list a functor?
09:20:03 <chessguy> _fang, ^^ several working versions
09:20:03 <hpaste>  mrd annotated "ends" with "oops" at http://hpaste.org/2950#a2
09:20:14 <Tac-Work> [x] ~ x, but that's just for singletons
09:20:14 <_fang> chessguy: what's the filter stuff?
09:20:16 <mauke> Tac-Work: if you have Int -> Int, you can make [Int] -> [Int]
09:20:24 <Tac-Work> ah
09:20:28 <quicksilver> Tac-Work: take a typical function (+1) in Ints
09:20:30 <chessguy> _fang, it removes items from a list that don't match a particular predicate
09:20:37 <quicksilver> Tac-Work: it's easy to see how to make that a function from [Int] to [Int]
09:20:42 <quicksilver> Tac-Work: you 'apply it everywhere'
09:20:45 <chessguy> > filter isUpper "HaSkElL"
09:20:47 <lambdabot>  "HSEL"
09:20:54 <Tac-Work> ok
09:20:57 <mrd> _fang: a common pattern of recursion.  it tests every element of a list against a supplied function, and only retains those for which it returns True.
09:20:58 <mauke> > filter odd [1 .. 10]
09:20:59 <lambdabot>  [1,3,5,7,9]
09:20:59 <Tac-Work> I might understand that a little
09:21:06 <_fang> chessguy: and the 'in ends 7'?
09:21:06 <Tac-Work> And similarly, sets are functors
09:21:19 <chessguy> _fang, that just says what i'm actually evaluating
09:21:27 <_fang> mrd, chessguy: it seems to help a loot! lol
09:21:38 <_fang> chessguy: i'll try it, thank you very much =D
09:21:42 <mauke> let <variable> = <definition> in <body>
09:21:46 <Tac-Work> I have a book on real analysis, actually, and the first time I saw the notation f(S) (where f : R -> R and S : set of R), I was so confused
09:22:00 <chessguy> _fang, usually when you find yourself doing raw recursion like that, you're missing something :)
09:22:00 <Tac-Work> but f(S) is actually fmap(f, S), then?
09:22:02 <mauke> yeah, math notation does automapping
09:22:08 <Tac-Work> or something along those lines
09:22:16 <chessguy> at least as a newb
09:22:21 <mauke> { f(x) | x <- S }
09:22:22 <quicksilver> math notation tends to 'miss out things which are obvious'
09:22:32 <quicksilver> where, unfortunately, 'obvious' is very much a subjective notion :)
09:22:35 <Tac-Work> math notation is anything but rigorous ^^;
09:22:43 <Tac-Work> well, I actually found it explained in the first chapter
09:22:54 <Tac-Work> but since it was a chapter on basic set theory, I skimmed over it
09:23:13 <tcr> Tac-Work: I've seen the notation f[S] to be used for that.
09:23:29 <_fang> chessguy: so, the best way to go into a list recursion is using filter, as far as i could get. i'm having lots of trouble with the exercises since my teacher knows not much more than me! and it isn't hard to find out that i suck in haskell xD
09:23:38 <mrd> in "Real Haskell", (.) = fmap = liftM subsuming map
09:23:45 <chessguy> _fang, well, not always
09:23:52 <chessguy> _fang, it depends what you're doing with the list
09:24:12 <Tac-Work> It's a very well-written book by Dover
09:24:40 <chessguy> _fang, in this case you want to take some members of the list, and leave others out, depending on a particular predicate. which is exactly what filter is for
09:24:41 <Tac-Work> It's all there, but reading it is like trying to drink honey through a straw
09:24:57 <mrd> well, it is a math text..
09:25:00 <chessguy> _fang, if you want to, e.g., do something to every member of a list, you can use map
09:25:04 <mrd> not exactly "light reading"
09:25:44 <chessguy> _fang, if you want to somehow apply every member of a list to a value, and wind up with a new value, you probably want some kind of fold
09:25:45 <Tac-Work> There's certainly ways to write math in a "light" style
09:25:52 <Tac-Work> and preserve most of the important information
09:26:14 <Tac-Work> It's mostly the proofs seem quite skimpy and the notation is never consistent with other books, even on the same topics
09:26:48 <Tac-Work> subscripts and superscripts everywhere, non-lambda greek characters, brackets and semi colons where parenthesis and commas should be.
09:26:55 <Tac-Work> it's all quite indimidating
09:27:26 <mrd> really, what you want is for proofs where you can select "light" or "heavy" detail depending on what you want
09:27:44 <_fang> chessguy: x.x i'm totally lost! can you tell me any good tutorial or book or anything?
09:27:45 <mrd> but dead trees don't really admit that kind of presentation...
09:27:53 <Tac-Work> they don't
09:28:14 <tcr> Tac-Work: non-lambda greek characters? What makes lambda special except that you happen to know that one.
09:28:33 <Tac-Work> tcr: because I know that one =-P
09:28:41 <chessguy> @where YAHT
09:28:42 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
09:28:46 <chessguy> _fang, ^^
09:28:56 <mrd> i think what annoys me the most is poor layout / spacing
09:29:00 <Olathe> How do I do the inverse of fold ?
09:29:07 <mrd> unfold?
09:29:08 <chessguy> @hoogle unfold
09:29:12 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
09:29:12 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
09:29:12 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
09:29:17 <Tac-Work> But like, one example. The difference between a bound set and a totally bound set. I have two books on the subject and neither really gives a good example of when a set is bound but not totally so
09:29:31 <Tac-Work> they give the technical definitions, but you're on your own for developing intuition over it
09:29:32 <chessguy> @hoogle+
09:29:32 <lambdabot> Data.Tree.unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
09:29:32 <lambdabot> Data.Tree.unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
09:29:32 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
09:29:41 <chessguy> i like unfoldTree, myself
09:29:52 <Tac-Work> and mathematical intuition is just as important as the proofs
09:29:58 <Olathe> I mean like invfold (\y -> div y 10) 1032 == [1032, 103, 10, 1, 0, 0, 0, ...]
09:30:04 <fasta> Is Shim abandonware?
09:30:05 <Tac-Work> (and if you're a computer science major like I am... intuition is MORE important than the proofs)
09:30:07 <Olathe> Or something.
09:30:21 <chessguy> @type iterate
09:30:26 <lambdabot> forall a. (a -> a) -> a -> [a]
09:30:26 <Olathe> @hoogle (a -> a) -> a -> [a]
09:30:27 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
09:30:27 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
09:30:27 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
09:30:30 <Olathe> Ahh.
09:30:50 <Olathe> Thanks :)
09:30:56 <chessguy> Tac-Work, way more
09:32:03 <_fang> chessguy: guess i'll be entertained for a few days now! lol
09:32:07 <_fang> chessguy: thanks again!!!
09:32:39 <chessguy> _fang, yes, and the rabbit hole just keeps getting deeper :) . welcome to the insanity
09:33:02 <_fang> chessguy: i'll TRY to make myself at home! =D
09:33:22 <chessguy> _fang, this is a great place to get help
09:34:03 <chessguy> @pl \y -> div y 10
09:34:03 <lambdabot> flip div 10
09:34:10 <chessguy> that's what i thought
09:34:47 <quicksilver> chessguy: (`div` 10)
09:34:57 <chessguy> that too
09:35:00 <chessguy> Olathe, ^^
09:35:17 <chessguy> i wonder why @pl doesn't do that
09:35:18 <_fang> chessguy: i'm quite positive about that. everytime i came here asking for something, i was promptly answered!
09:35:25 <Olathe> > let ends x = ends' (10^(length (takeWhile (\y -> y > 0) (iterate (\y -> div y 10) x)))) x where ends' m x = filter (\y -> (mod y m) == x) in ends 72 [1..1000]
09:35:27 <lambdabot>  [72,172,272,372,472,572,672,772,872,972]
09:35:37 <Olathe> @pl let ends x = ends' (10^(length (takeWhile (\y -> y > 0) (iterate (\y -> div y 10) x)))) x where ends' m x = filter (\y -> (mod y m) == x) in ends
09:35:37 <lambdabot> (line 1, column 107):
09:35:37 <lambdabot> unexpected "="
09:35:37 <lambdabot> expecting variable, "(", operator, ";" or "in"
09:35:44 <Olathe> Okey dokey
09:35:52 <chessguy> what in the world
09:36:01 <quicksilver> pointless can't do lets
09:36:04 <chessguy> oh
09:36:18 <Olathe> @pl ends' (10^(length (takeWhile (\y -> y > 0) (iterate (\y -> div y 10) x)))) x where ends' m x = filter (\y -> (mod y m) == x)
09:36:18 <lambdabot> (line 1, column 94):
09:36:18 <lambdabot> unexpected "="
09:36:18 <lambdabot> expecting variable, "(", operator or end of input
09:36:18 <chessguy> no, i was trying to figure out what Olathe was trying to accomplish. i see now
09:36:26 <Olathe> Bah.
09:36:28 <puusorsa> nussitaaks?!?!
09:36:36 <puusorsa> sorry wrong channel
09:36:39 <quicksilver> or wheres, indeed
09:36:49 <EvilTerran> bindings
09:37:11 <EvilTerran> only expressions
09:37:22 <mauke> :t (filter . (. show)) . (isSuffixOf . show) 72
09:37:24 <lambdabot>     Couldn't match expected type `String -> Bool'
09:37:24 <lambdabot>            against inferred type `Bool'
09:38:21 <chessguy> :t (filter . (. show)) . (isSuffixOf . show) 72 [1..]
09:38:23 <lambdabot>     Couldn't match expected type `a -> String -> Bool'
09:38:23 <lambdabot>            against inferred type `Bool'
09:39:42 <chessguy> oh well. back to the real world.
09:40:28 <quicksilver> EvilTerran: well, not even all expressions
09:40:35 <mauke> > (filter . (. show) . isSuffixOf . show) 72 [1 ..]
09:40:36 <lambdabot>  [72,172,272,372,472,572,672,772,872,972,1072,1172,1272,1372,1472,1572,1672,1...
09:40:37 <quicksilver> EvilTerran: just a particular subdialect of haskell with a simple AST
09:40:53 <Olathe> > let ends = (filter .) =<< flip . ((==) .) . flip mod . (10 ^) . length . takeWhile (> 0) . iterate (flip div 10) in ends 72 [1..1000]
09:40:54 <lambdabot>  [72,172,272,372,472,572,672,772,872,972]
09:41:00 <Olathe> There :)
09:41:01 <quicksilver> I'm afraid mauke just won
09:41:16 <quicksilver> read back a couple of lines :)
09:41:29 <Tac-Work> @src isSuffixOf
09:41:30 <Olathe> show is the work of SATAN ;)
09:41:30 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
09:41:39 <Tac-Work> @info isSuffixOf
09:41:39 <lambdabot> (isSuffixOf)
09:41:50 <Tac-Work> @index isSuffixOf
09:41:50 <lambdabot> Data.List
09:41:53 <mauke> @info Tac-Work
09:41:53 <lambdabot> (Tac - Work)
09:42:06 <Tac-Work> @info mauke's face
09:42:06 <lambdabot> (mauke's face)
09:42:22 <Tac-Work> @hpaste
09:42:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:42:34 <mauke> @info do { x <- y; x }
09:42:34 <lambdabot> (y >>= \ x -> x)
09:42:42 <Olathe> Does currying like that do the 10^ part only once ?
09:42:54 <Olathe> And, if so, does the pointless version only do it once ?
09:44:07 <Tac-Work> food time!
09:44:10 <Tac-Work> laterall
09:44:18 <mauke> sub ends { my $x = shift; grep /\Q$x\E\z/, @_ }
09:45:11 <quicksilver> surely you mean sub e{shift;grep/\Q$_\E\z/,@_}
09:45:40 <mauke> no, because that ignores its first argument
09:45:47 <EvilTerran> > (\x -> map ((x+).(fromJust find (x<) (map (10^) [0..]) *)) [0..]) 72
09:45:48 <lambdabot>  Couldn't match expected type `Maybe a'
09:45:56 <EvilTerran> > (\x -> map ((x+).(fromJust (find (x<) (map (10^) [0..])) *)) [0..]) 72
09:45:57 <quicksilver> doesn't shift shift into $_?
09:45:58 <lambdabot>  [72,172,272,372,472,572,672,772,872,972,1072,1172,1272,1372,1472,1572,1672,1...
09:46:01 <mauke> quicksilver: no
09:46:10 <EvilTerran> only in the condition of a while loo
09:46:11 <EvilTerran> p
09:46:13 <quicksilver> ah well, I'm a lousy golfer then :P
09:46:26 <mauke> there's only one thing that assigns to $_, and that's a while loop whose condition is a single readline()
09:46:27 <tcr> What's the best way to express 0 <= x <= 10?
09:46:42 <EvilTerran> sub e{shift;grep/\Q$_\E\z/,@_ for shift} would work
09:46:57 <EvilTerran> er, minus that first shift
09:47:11 <quicksilver> tcr: 0 <= x && x <= 10 ?
09:47:20 <EvilTerran> @type inRange
09:47:22 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
09:47:37 <mauke> @src Int inRange
09:47:37 <lambdabot> Source not found. You type like i drive.
09:48:07 <EvilTerran> @src inRange
09:48:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:48:34 <tcr> It's in Array.
09:49:33 <quicksilver> I think 0 <= x && x <= 10 looks nicer than inRange (0,10) x
09:49:36 <quicksilver> your preference may vary
09:49:51 <Olathe> > let ends = iterate =<< (+) . (10 ^) . length . takeWhile (> 0) . iterate (flip div 10) in ends 72
09:49:53 <lambdabot>  [72,172,272,372,472,572,672,772,872,972,1072,1172,1272,1372,1472,1572,1672,1...
09:49:59 <Olathe> Much quicker.
09:50:02 <tcr> quicksilver: x is an expression in my case.
09:52:30 <Olathe> @pl is quite nice :)
09:52:31 <lambdabot> (line 1, column 16):
09:52:31 <lambdabot> unexpected ")"
09:52:31 <lambdabot> expecting white space or simple term
09:52:47 <quicksilver> tcr: ah, that does change things a bit
09:53:15 <quicksilver> @pl \x -> 0 <= x && x <= 10
09:53:15 <lambdabot> liftM2 (&&) (0 <=) (<= 10)
09:53:20 <quicksilver> cute
09:53:41 <quicksilver> I think I'd almost be prepared to use that, if I gave liftM2 (&&) a name
09:53:48 <puusorsa> ltap ittes ohomo
09:53:55 <quicksilver> let (<&&>) = liftM2 (&&)
09:54:58 <mauke> :t flip all [(0 <=), (<= 10)] . flip id
09:55:00 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
09:55:39 <mauke> :t and . sequence [(0 <=), (<= 10)]
09:55:41 <lambdabot> forall t. (Num t, Ord t) => t -> Bool
09:56:24 <quicksilver> :t all `fmap` [(0 <=),(<= 10)]
09:56:25 <fasta> How to round 5.434343 to 2 decimals?
09:56:26 <lambdabot> forall a. (Num a, Ord a) => [[a] -> Bool]
09:56:29 <quicksilver> I lose
09:56:35 <quicksilver> fasta: showFFloat, showEFloat
09:56:51 <mauke> fasta: printf
09:56:55 <quicksilver> I should just accept that mauke is a better golfer than me and stop playing :P
09:57:00 <tcr> quicksilver: What's the monad that operates in?
09:57:07 <quicksilver> tcr: the reader monad
09:57:12 <mauke> the list monad
09:57:12 <quicksilver> tcr: a.k.a functions
09:57:26 <mauke> :t all `map` [(0 <=),(<= 10)]
09:57:28 <lambdabot> forall a. (Num a, Ord a) => [[a] -> Bool]
09:57:37 <quicksilver> yes, but mine was broken :)
09:57:42 <quicksilver> your working one with sequence
09:57:45 <quicksilver> was in the reader monad
09:57:50 <mauke> yeah
09:57:58 <fasta> 97.0% 40.7% - GHC loads a module... 20 seconds.
09:58:02 <ddarius> :t sequence [(0<=),(<=0)] all
09:58:04 <lambdabot>     No instance for (Ord ((a -> Bool) -> [a] -> Bool))
09:58:04 <lambdabot>       arising from use of `<=' at <interactive>:1:10-14
09:58:22 <fasta> Correction 1 minute.
09:58:56 <puusorsa> huarrrrrraaaaaaaaah
10:02:03 <fasta> threadDelay uses next to zero CPU, right?
10:05:51 <fasta> What is "field width" in Text.Printf(printf)?
10:06:32 <oerjan> > printf "%5d" (3::Int) :: String
10:06:40 <lambdabot>  "    3"
10:06:58 <ddarius> So you can output ASCII tables because people do that.
10:07:10 <fasta> Ok
10:07:22 <puusorsa> vittu ootte huoni
10:07:48 <fasta> > printf "%1d" (30::Int) :: String
10:07:50 <lambdabot>  "30"
10:08:24 <idnar> > printf "%05d" (30::Int) :: String
10:08:26 <lambdabot>  "00030"
10:08:38 <idnar> you don't need to be outputting ASCII tables to want that form ;)
10:12:26 <fasta> Do you run out of heap space for ghci occasionally?
10:13:16 <fasta> (I set the limit to 400MB, but even that is not enough)
10:13:20 <dons> i've not had that happen, unless the code is buggy
10:13:35 <dons> or allocates a lot on the heap...
10:13:59 <fasta> It's ghci that stop during the loading of a module.
10:14:04 <fasta> stops*
10:14:24 <fasta> AFAIK, it should reuse it's own memory.
10:14:27 <dons> ah right. a very large module set?
10:14:39 <dons> i think i've seen that when repeatedly loading lambdabot in ghci
10:14:44 <dons> (~90 modules)
10:15:15 <fasta> dons: well, the reflexive transitive closure is about 80 modules.
10:15:33 <fasta> But it shouldn't touch all those other modules, AFAIK.
10:15:47 <fasta> I changed only one thing in one module.
10:20:01 <pgavin> @seen dcoutts
10:20:01 <lambdabot> dcoutts is in #haskell-hac07, #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 28m 2s ago.
10:20:07 <dcoutts> hia pgavin
10:20:12 <pgavin> hi
10:20:17 <dcoutts> pgavin: thanks for posting the dep code recently
10:20:29 <pgavin> your welcome :)
10:20:53 <pgavin> I was going to put an enhancement request on trac with a copy of the patch
10:20:59 <pgavin> unless you have a better idea
10:21:30 <dcoutts> pgavin: that seems sensible
10:21:41 <dcoutts> pgavin: we'll hack on it at the hackathon
10:21:44 <pgavin> ok, I'll do that
10:21:52 <pgavin> what date is that on?
10:22:04 <tcr> fmap (1+) (1,2) => (1,3); is there something to return (2,3)?
10:22:31 <oerjan> > join (***) (+1) (1,2) -- did that yesterday
10:22:33 <lambdabot>  (2,3)
10:23:20 <mauke> > uncurry (join (liftM2 (,)) (+1)) (1,2)
10:23:20 <dcoutts> @google Hackathon II
10:23:21 <psnively> That's what I love about this channel: people use "reflexive transitive closure" in casual conversation.
10:23:21 <lambdabot>  Couldn't match expected type `b -> c'
10:23:22 <lambdabot> http://blogs.feedburner.com/feedburner/archives/001514.html
10:23:22 <lambdabot> Title: Burning Questions &#8226; Hackathon II - Night of the Living Hack
10:23:31 <dcoutts> @google Haskell Hackathon II
10:23:33 <lambdabot> http://haskell.org/haskellwiki/Hac_2007_II
10:23:33 <lambdabot> Title: Hac 2007 II - HaskellWiki
10:23:38 <dcoutts> pgavin: ^^
10:23:42 <mauke> oh, d'oh
10:23:53 <pgavin> aha, thanks :)
10:24:14 <pgavin> well, I won't be anywhere near there
10:24:16 <pgavin> :)
10:24:32 <pgavin> I was hoping to go to AmeroHaskell though
10:24:50 <pgavin> since it's supposed to be in the southeastern US
10:31:21 <dons> ?users
10:31:22 <lambdabot> Maximum users seen in #haskell: 420, currently: 394 (93.8%), active: 15 (3.8%)
10:31:32 <matthew_-> I'm active too.
10:31:33 <matthew_-> sorta.
10:31:43 <DRMacIver> I'm quite passive.
10:31:50 <matthew_-> you write java
10:31:51 <psnively> Ob. comment here.
10:32:07 <oerjan> 420? when did that happen?
10:32:09 * mrd is passively active
10:32:33 <oerjan> for that matter, why?
10:34:54 <DRMacIver> matthew_-: What's that got to do with the price of fish?
10:35:00 <puusorsa> alot'
10:36:14 <maxeuler> Hi. Has anyone here worked through chp 8 of Hutton's "Programming in Haskell"?
10:37:01 <fasta> @where Anyone
10:37:02 <lambdabot> I know nothing about anyone.
10:37:43 <fasta> @where+ See #debian !anyone entry for dpkg
10:37:43 <lambdabot> Done.
10:37:51 <fasta> @where+ Anyone See #debian !anyone entry for dpkg
10:37:51 <lambdabot> Done.
10:37:58 <fasta> @where+ anyone See #debian !anyone entry for dpkg
10:37:59 <lambdabot> Done.
10:38:17 <mauke> @where See
10:38:17 <lambdabot> #debian !anyone entry for dpkg
10:38:18 <fasta> @where+ See I know nothing about See
10:38:18 <lambdabot> Done.
10:38:24 <mauke> haha
10:38:34 <fasta> @where See
10:38:35 <lambdabot> I know nothing about See
10:38:42 <mauke> @where+ See
10:38:42 <lambdabot> Done.
10:38:47 <fasta> @where See
10:38:48 <mauke> @where See
10:38:53 <Paczesiowa> is it possible to make this work http://hpaste.org/2951 ? it works with png files
10:39:10 <mrd> @where wolf
10:39:11 <lambdabot> I know nothing about wolf.
10:40:02 <fasta> Paczesiowa: you convert the file to a jpg file or you find another library.
10:40:03 <allbery_b> Paczesiowa:  what do you mean "make this work"?
10:40:12 <allbery_b> oh
10:40:27 <fasta> Paczesiowa: but I am surprised it doesn't work out of the box.
10:40:38 <allbery_b> depends on how the system gtk foo was built
10:40:46 <allbery_b> ours does gif and png, probably jpg as well
10:40:53 <Paczesiowa> could one of you compile&run it?
10:41:11 <fasta> Paczesiowa: no, because you left out the imports and we are lazy.
10:41:18 <Paczesiowa> and tell me your verions of gtk
10:41:27 <Paczesiowa> import Graphics.UI.Gtk
10:41:51 <kscaldef> how seriously should I take the memory use numbers from ghci with ":set +s"?  Should I believe this: (241.33 secs, 10733619652 bytes)?
10:42:08 <kscaldef> I mean, it's not like I have 10GB in this machine
10:42:24 <olsner> kscaldef: you can allocate the same byte many times
10:42:26 <Paczesiowa> it's probably total size of allocs
10:42:43 <Paczesiowa> memory gets garbagecollected and allocated again
10:42:51 <Tac-Work> What laws does Functor.fmap need to satisfy?
10:43:02 <kscaldef> that's pretty terrifying regardless
10:43:09 <mauke> @free map
10:43:11 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:43:20 <mrd> Tac-Work: stealing and murder is prohibited
10:43:20 <twanvl> fmap id == id
10:43:32 <mauke> fmap f . fmap g == fmap (f . g)
10:43:38 <Paczesiowa> and sex with minors:>
10:44:05 <Tac-Work> so fmap f. fmap g == fmap (f .g ) and fmap id == id?
10:44:35 <twanvl> Yes
10:45:13 <oerjan> that's nearly the category theory definition of a functor
10:46:00 <oerjan> restricted to only one category, Haskell types and functions
10:47:12 <oerjan> :t fmap
10:47:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:47:35 <EvilTerran> if any instance of Functor a categorical functor, or is it fmap (or fmap f) that's the functor?
10:48:01 <oerjan> f is the object map, fmap the morphism map
10:48:48 <oerjan> usually you include both
10:53:12 <EvilTerran> er?
10:53:27 <kscaldef> so, assuming it's true that this program is allocating 10GB of memory, how do I debug that?  Is there a tool to track down the largest sources of memory allocation?
10:54:00 <oerjan> a categorical functor includes two mappings, one from objects to objects and one from morphisms (arrows) to morphisms.
10:54:05 * EvilTerran doesn't get the chance to be taught category theory for a year at least, maybe two (depending on the mood of the computer lab)
10:54:06 <Cale> kscaldef: Where are you pulling that number from? There are places which give numbers for raw allocation (i.e. what it would use if there were no GC)
10:54:26 <Cale> kscaldef: The profiler is a good way to see
10:54:27 <kscaldef> Cale: ghci, ":set +s"
10:54:37 <Cale> ah, yeah, that's raw allocated bytes
10:54:38 <EvilTerran> ah, i see
10:54:47 <kscaldef> Cale: (241.33 secs, 10733619652 bytes)
10:55:09 <Cale> The GC is really very good at reclaiming short-lived objects
10:55:24 <kscaldef> Cale: this is from HXT, reading and validating a 22KB XML doc
10:56:01 <Cale> That's imaginable.
10:56:14 <kscaldef> no, it's completely awful
10:56:25 <psnively> EvilTerran: Check out "Basic Category Theory for Computer Scientists." Slim, cheap, and available from Amazon.
10:56:48 <Cale> Yeah, just noticed the time :)
10:56:59 <Cale> Compile with -prof -auto-all
10:57:01 <EvilTerran> also available from my college library, iirc! :)
10:57:09 <Cale> and run the program with +RTS -p
10:57:13 <psnively> :-D
10:57:49 <EvilTerran> (try before you buy, i say. i don't like to pay for something if i'm not confident it's going to be useful long-term)
10:58:23 <kscaldef> Cale: run with options?  You mean in ghci or from the command line?
10:58:30 <Cale> From the commandline
10:58:30 <bos> kscaldef: on the command line
10:58:38 <EvilTerran> (but i might buy it anyway if i decide i like it)
10:59:02 <Cale> GHC-compiled executables will all accept RTS options in that form
10:59:04 <EvilTerran> kscaldef, are you compiling it? if you do so with optimisations, that might do good things to memory usage (and running time), iirc.
10:59:21 <kscaldef> EvilTerran: just ghci at the moment
10:59:33 <Cale> +RTS marks the start of a set of rts options and -RTS will mark the end of them, but it's not necessary so long as you put those last.
10:59:34 <bos> it's a toss-up. when strictness analysis kicks in, it's often brittle.
10:59:59 <Cale> -p tells the runtime system to generate profiling information
11:00:02 <kscaldef> EvilTerran: but this is a simple test program to debug a problem discovered in a larger problem, which still has this issue when run compiled
11:00:07 <EvilTerran> i don't recall if ghci does deforestation at *all*, for instance
11:00:33 <Cale> Oh, yeah, definitely try compiling with simply -O2
11:00:46 <Cale> and maybe the problem will simply disappear
11:00:47 <kscaldef> Cale: ahh, I did not know that about RTS options
11:01:21 <Paczesiowa> fasta: could you run it? http://hpaste.org/2951#a1
11:01:26 * EvilTerran still finds it slightly disconcerting that a compiler flag can change the asymptotic memory use
11:01:37 <hpaste>  eyeris pasted "I need a vim script to help with this indentation" at http://hpaste.org/2952
11:01:43 <kscaldef> sigh... compiling with -prof fails because HXT doesn't install profiling libraries
11:01:52 <kscaldef> EvilTerran: me too
11:01:55 <bos> kscaldef: you'll need to rebuild HXT then
11:02:36 * kscaldef has a plane to catch
11:02:57 <kscaldef> maybe by the time I land the HXT authors will have had a chance to look into this
11:03:27 <Cale> eyeris: Well, you have the indentation right, but I don't know of a script to do that, unfortunately. I usually use (expanded) tabs to get somewhere in the ballbark and then use backspace/spacebar to get it right.
11:03:53 <Cale> kscaldef: Try just -O2 and see
11:06:17 <kscaldef> Cale: running...
11:07:44 <oerjan> eyeris: what about using data Room = Room { as the first line? then the rest should be easy enough.
11:09:05 <oerjan> this is not a case when haskell demands precise layout, anyhow
11:09:34 <Cale> oerjan: Yeah, but you still want it to look nice :)
11:11:58 <Tac-Work> > fmap (+1) (Right 0)
11:11:58 <Tac-Work> > fmap (+1) (Left 0)
11:12:00 <lambdabot>  Right 1
11:12:01 <lambdabot>  Left 0
11:12:02 <kscaldef> Cale: no change with -O2.  Still 240s.  Still 10.7GB (925MB scavenged by the GC)
11:13:08 <Cale> kscaldef: huh. Yeah, I suppose you'll just have to get profiling information. I seem to recall HXT's parser not being very good with large XML files, but 22K doesn't seem that bad.
11:13:09 <mrd> you are supplying RTS option -sstderr?
11:13:54 <kscaldef> mrd: yes
11:13:56 <sjw> re
11:14:01 <eyeris> oerjan That would work. I though that the constructor name had to be on the next line if it was a multi-line definition.
11:14:05 <Cale> kscaldef: One problem is that XML is pretty much designed to be as memory intensive to parse as possible.
11:14:09 <mrd> kscaldef: what % of time is GC taking
11:14:15 <kscaldef> Cale: the problem appears to be the validator, not the parser
11:14:26 <kscaldef> mrd: 3.5%
11:14:27 <eyeris> That was just inferred from the wikibook though. No surprise I was wrong :)
11:14:39 <Cale> With a 22K file, that seems more likely. I haven't ever used the validator.
11:14:40 <mrd> kscaldef: then memory isn't the issue
11:14:49 <Tac-Work> Cale: you're help paid off. I got the Cont-based factorial working the way I had originally intended: http://www.hpaste.org/2949
11:15:12 <Cale> Tac-Work: hehe
11:15:14 <oerjan> eyeris: only things in do, let, where and of blocks need to be carefully aligned
11:15:30 <oerjan> (also top level, which counts as a where)
11:15:43 <eyeris> ok
11:16:15 <oerjan> otherwise, just make sure to indent more than the enclosing such block
11:16:16 <Tac-Work> though the Continuation I save in the STRef "r" has a type which requires me to pass it something at the end ("rv nv") and return something in callCC ("return 0")
11:17:16 <kscaldef> Cale: yes, it appears that the idea of _validating_ XML is fairly novel to the haskell community.  HXML doesn't do it, HaXML claimed every single element and attribute in my documents was invalid, and HXT does... this
11:17:22 <Tac-Work> really, I think it makes more sense to make it a Cont r ()  or something
11:17:33 <kscaldef> sorry to be snarky, but this is very frustrating
11:17:36 <Cale> I suppose it counts as a 'do', but the indentation of if-then-else can matter inside of a do-block (which means you should probably indent it the right way everywhere)
11:17:52 <Cale> kscaldef: heh
11:18:14 <Cale> kscaldef: Despite all the work on XML libraries, I don't think they've yet seen all that much use.
11:19:04 <Cale> kscaldef: Most Haskell programmers are content to use read/show instances rather than XML for storing things like configuration data.
11:19:49 <dcoutts> @tell shapr give cabal-setup another go
11:19:49 <lambdabot> Consider it noted.
11:20:01 <kscaldef> Cale: yes, it's the rest of the world that has other opinions.  read/show instances will not get you far on the web :-)
11:20:10 <Cale> kscaldef: right :)
11:20:18 <Tac-Work> The haskell way to do configuration data, to me at least, would seem to be to write your own DSL using Haskell's wonderful parser combinator libraries
11:20:33 <Tac-Work> why needs XML when you can write your own language for each project ^^
11:20:37 <Cale> Tac-Work: That too.
11:21:28 <puusorsa> why ask why just shut up and die
11:21:44 <Cale> I think the financial people like generating s-expressions.
11:21:44 <newsham> amusing bug in your favorite functional language: http://www.theregister.co.uk/2007/09/26/excel_2007_bug/
11:22:14 <Cale> newsham: That's, like, two days old. ;)
11:22:28 <kscaldef> yes, well given that my whole goal is to write a validating web spider, I don't have much choice about using XML/HTML.  But, at least when I'm done I should have an interesting blog post about it
11:22:49 <Cale> kscaldef: You might even consider working on making the validator practical ;)
11:23:42 <kscaldef> Cale: that's crazy talk
11:24:15 <kscaldef> Cale: but we'll see
11:24:28 <Cale> and er, fixing the spelling errors in the library: validateWithSpezification :: Attributes -> String -> String -> IOSArrow XmlTree XmlTree
11:24:36 <puusorsa> sexpressions!!!!!!!1
11:25:03 <kscaldef> yeah, the creative spelling definitely stands out for me as I read through the code
11:25:14 <kscaldef> removeDoublicates
11:25:17 <iguana_> german coders?
11:25:29 <kscaldef> I believe so
11:25:35 <puusorsa> wannna????
11:25:57 * kscaldef must go pack
11:26:00 <iguana_> but should be spezifikation then :)
11:26:17 <Cale> It's Germlish
11:26:20 <nominolo> ze german coderz are ze best
11:26:36 <puusorsa> you slut ze
11:26:38 <puusorsa> <3
11:27:40 <mrd> icfp is going on soon?
11:27:48 <nominolo> next week
11:27:50 <Cale> mrd: already?
11:28:13 <Cale> Is it biannual now, or is my sense of the passage of time really messed up?
11:28:29 <mrd> latter
11:28:44 <Cale> okay :)
11:28:52 <mrd> if we accept LEM
11:28:53 <nominolo> hac is biannual now
11:29:22 <Cale> See, it's not messed up, the last contest was in July
11:29:27 <mrd> You're either crazy, or you're not.
11:29:35 <mrd> contest happens 3 months before conf
11:29:40 <Cale> ah
11:29:44 <nominolo> hehe
11:29:46 <nominolo> it always is
11:29:47 <Cale> okay, that makes more sense then
11:29:55 <mrd> next week is big anticipation moment -- winner is announced
11:30:20 <pejo> I've been in germany for 5 hours, and they've already asked me twice if I live here, and apparently I managed to order a latte without them realizing I wasn't speaking german.
11:30:32 <nominolo> is anyone here in close consideration?
11:30:36 <mrd> latte? get a beer!!!!
11:31:00 <nominolo> pejo, "ein latte bitte"?
11:31:06 <nominolo> *eine
11:31:09 <eyeris> Can I call a function in a guarD?
11:31:16 <Adamant> you don't go to Germany for the coffee
11:31:17 <mrd> eyeris: anything
11:31:20 <nominolo> eyeris, sure
11:31:36 <nominolo> Adamant, what for do you go?
11:31:37 <pejo> nominolo, I was speaking english though!
11:31:40 <mrd> i'm going to visit germany some day... for a drinking tour
11:31:49 <Adamant> nominolo, for the beer! among other things!
11:31:51 <eyeris> Ok. is there an "in" operator/function for lists? There must be.
11:32:03 <Adamant> not that their coffee is bad or anything
11:32:04 <pejo> eyeris, elem
11:32:31 <nominolo> Adamant, right.  if you go to thuringia, you have to get "roster" (bratwurst)
11:32:36 <pejo> Adamant, I just took the first thing that appeared to still be open. It was .. "Starbucks".
11:32:36 <mrd> though when galois people show up they may be unimpressed; portland has the most breweries of any city in the world.
11:33:01 <nominolo> > 'a' `elem` "abcd"
11:33:02 <kscaldef> most breweries per capita
11:33:03 <lambdabot>  True
11:33:12 <mrd> oh i guess, whatever
11:33:41 <kscaldef> and actually, despite that, the local beer is not as pervasive as you'd think due to fascist liquor laws
11:34:03 <nominolo> eyeris, using hoogle you can search for functions via type signature:
11:34:15 <nominolo> @hoogle a -> [a] -> Bool
11:34:16 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
11:34:16 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
11:34:27 <nominolo> eyeris, there it is
11:34:33 <eyeris> That is AWESOME
11:35:04 <nominolo> but try using the hoogle website, not the channel for doing so :)
11:35:25 <Cale> Hoogle would be more awesome without the bugs :)
11:35:52 <eyeris> It would be more awesome with a favicon.ico so I could put it in my toolbar
11:36:15 <kscaldef> Cale: if I'm rebuilding HXT with profiling, do I just add the options to ./setup build?
11:36:15 <Cale> It has one, just not a unique one.
11:36:31 <byorgey> eyeris: if you're using firefox, you can easily add it as a custom search engine in the upper-right
11:36:32 <eyeris> At least it has a custom FF search definition
11:36:34 <nominolo> eyeris, in firefox you can rightclick on the search field and add it as a search keyword
11:36:39 <byorgey> beat me to it =)
11:36:58 <Cale> kscaldef: um, hmm, good question. Someone more familiar with cabal would know... :)
11:37:11 <nominolo> eyeris, i can type "ho elem" in the location bar, and it issues a hoogle search
11:37:36 * nominolo got rid of the search field
11:38:11 <eyeris> I see
11:38:16 <Cale> nominolo: One thing I like about the search field is that I can search for the same thing in multiple places without editing the text of my query.
11:38:47 <Cale> --enable-library-profiling
11:38:57 <Cale> kscaldef: ^^
11:39:00 <nominolo> Cale, never felt the need to do so :)
11:39:11 <mrd> kscaldef: argh they have that too?
11:39:24 <mrd> kscaldef: here liquor has to be sold in state stores
11:39:28 <pixl> I ran into a little problem: I have a func "displaydata :: Connection -> CGI CGIResult" "displaydata = output (renderHtml genhtml)". What I need to do is put a "do" into that displaydata block, like "displaydata = do dat <- getDataFromDatabase; output (renderHtml (genhtml dat))". However, ghc complains that the return type is wrong for "displaydata"
11:39:32 <Cale> nominolo: I do it all the time with {Wikipedia,MathWorld,PlanetMath} and various torrent search engines.
11:39:49 <pastorn> @src transpose
11:39:50 <lambdabot> transpose []             = []
11:39:50 <lambdabot> transpose ([]   : xss)   = transpose xss
11:39:50 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
11:39:56 <pastorn> yay....
11:40:09 <nominolo> Cale, i use google, hoogle, and some dictionary
11:40:11 <kscaldef> Cale: that's in the configure step?
11:40:29 <Cale> pixl: what's the type of getDataFromDatabase
11:40:42 <Cale> kscaldef: I think so
11:40:56 <pixl> it returns a list of data types
11:40:58 <Cale> yes
11:41:09 <Cale> pixl: hm?
11:41:15 <pixl> [Projects]
11:41:20 <kscaldef> mrd: it's not quite that bad... stores are independently owned, but all distribution is controlled by the state.  Most local breweries don't have a distribution license, so the only way to get them is at the brewpub
11:41:21 <Cale> pixl: so it's a list?
11:41:27 <pixl> yea
11:41:39 <Cale> In particular, it's not a CGI computation?
11:41:47 <omniscientIdiot> it has to be CGI [Projects] to be used in a CGI do block
11:41:52 <pixl> it reads a few entries from database and returns a list of structures
11:42:00 <pixl> ah
11:42:07 <omniscientIdiot> is it IO [Projects]?
11:42:09 <Cale> pixl: In order to do that reading, it must at least be in IO
11:42:30 <mrd> kscaldef: perversely, i think that law may have caused the density of breweries
11:42:33 <oerjan> pixl: when we here in #haskell ask "what's the type of" we are often more interested in the monad than the value :D
11:42:55 <Cale> an (IO Integer) is not an Integer
11:42:59 <kscaldef> mrd: perhaps... and it rains a lot, so what else are you going to do?
11:43:03 <Cale> It's nothing even remotely like an Integer :)
11:43:11 <mrd> well in seattle they drink lattes
11:43:30 <pastorn> are h and t local to their respective list comprehensions i the transpose source?
11:43:33 <pastorn> @src transpose
11:43:33 <lambdabot> transpose []             = []
11:43:33 <lambdabot> transpose ([]   : xss)   = transpose xss
11:43:33 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
11:43:34 <Cale> It's a representation for a program which if it was to be run, would produce an Integer
11:43:37 <pixl> Cale, yeah it is an IO
11:43:47 <mrd> and in SF they drink their own farts ;)
11:43:48 <pixl> though changing it to CGI doesnt help
11:43:48 <omniscientIdiot> @hoogle IO a -> CGI a
11:43:48 <lambdabot> No matches, try a more general search
11:44:02 <Cale> pixl: Okay, CGI is an instance of MonadIO, so you can use liftIO to turn it into a CGI computation
11:44:11 <Cale> pixl: and that should fix your problem
11:44:17 <pixl> Cale: getData :: Connection -> IO [Projects]
11:44:24 <pixl> ok
11:44:28 <oerjan> pastorn: yes
11:44:32 <pixl> hmm
11:44:45 <omniscientIdiot> liftIO (getData conn) :: CGI [Projects]
11:44:48 <kscaldef> mrd: seattle public transit is not as good, so they have to stick with coffee ;-)
11:44:49 <pastorn> oerjan: thanks :)
11:45:15 <mrd> there's an article in the NY times today about portland dining, wine and beer
11:45:28 <kscaldef> that'll piss of the locals
11:45:37 <kscaldef> piss them off, even
11:45:50 <mrd> or they get pissed
11:46:04 <omniscientIdiot> piss
11:46:04 <mrd> and have a shout
11:46:31 <kscaldef> if it's like the last time they ran a profile like that, it'll tell new yorkers how to come to portland and spend thousands of dollars shopping at the same stores they have in every city in the country
11:46:50 <mrd> and portland has a problem with people spending moneyin their city?
11:47:02 <kscaldef> oddly, it seems a lot of them do
11:47:25 <omniscientIdiot> pixl: did that fix your problem?
11:47:41 <kscaldef> actually, it's that they'd rather they spend money in the unique and locally owned stores, rather than Pottery Barn and William Sonoma
11:48:35 <mrd> i hate the chain stores too but ... around here ... there's little else.
11:48:36 <pixl> well, im trying to figure out how to stick liftIO into my code :P
11:49:02 <Cale> pixl: apply it to something which is an IO computation, but you'd like to be a CGI computation
11:49:54 <Cale> pixl: We're sort of hoping that you understand the basic idea behind using monads in Haskell. If you'd like, I could give you a run-down on how it works though.
11:50:47 <pixl> yeah sure, i read a few wikis on monads, but its still a little fussy :D
11:50:58 <Cale> pixl: In this case, your 'getDataFromDatabase' was an IO computation, but you wanted to put it in a do-block with other CGI computations, so you need to turn it into a CGI computation.
11:51:01 <oerjan> pixl: using your example above, dat <- liftIO $ getDataFromDatabase
11:51:46 <pixl> Couldn't match expected type `CGIT IO t'
11:51:46 <pixl>            against inferred type `IO Statement'
11:51:52 <oerjan> (actually the $ is unnecessary there)
11:52:03 <Cale> pixl: In which expression?
11:52:09 <pixl> thats when changing that line as oerjan said
11:52:20 <Cale> pixl: That means there's still another problem
11:52:21 <pixl> using liftIO
11:52:38 <pixl> well I think its something to do with my "do" statement
11:52:46 <omniscientIdiot> pixl: what does ':i getDataFromDatabase' say in ghci?
11:52:53 <Cale> That seems to indicate that you need another liftIO
11:52:54 <pixl> I want the functio to return the return type of "output" function
11:52:55 <omniscientIdiot> :t, rather
11:54:40 <Cale> pixl: Okay, let's do a review of how IO works in Haskell. Haskell separates pure functions from computations where side effects must be considered by encoding those side effects as values of a particular type.
11:55:16 <pixl> ah nm.. the problem was that I changed return type of getDataFromDatabase from IO [Projects] to CGI [Projects] and then forgot about it :P
11:55:16 <kscaldef> mrd: the most appalling thing was when the NYT instructed people to visit Portland and go to the Saks.  wtf?
11:55:25 * mrd boggles
11:55:40 <Cale> In the case of I/O side effects, a value of type (IO a) is used to represent an action which if executed would produce a value of type a.
11:55:51 <kscaldef> I hear they have one of those in new york too...
11:55:53 <mrd> perhaps its like when people go to Germany and visit the Starbucks ;)
11:56:05 <kscaldef> haha
11:56:13 <pixl> yeah i sort of understand that io functions are sortof like nuklear waste that infects pure code making it imposible to use io functions in pure functions
11:56:15 <Cale> So you could almost imagine that a value of type IO Integer is the source code for a C program which returns an Integer
11:56:23 <mrd> well I wouldn't go to the Saks whether it be in NY or Portland
11:56:28 <Cale> Yeah, you read the bad tutorial :)
11:56:31 <Cale> hehe
11:56:34 <pixl> :P
11:56:47 <Cale> We've been sort of hoping to replace that one for a while
11:57:10 <omniscientIdiot> pixl: if you put the liftIO directly in the definition of getDataFromDatabase, the you would type as CGI [Projects].  It doesn't matter where you put it though.
11:57:13 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO -- read this, it should only take a couple of minutes, and should impart the right perspective
11:57:14 <lambdabot> Title: Introduction to IO - HaskellWiki
11:57:44 <pixl> omniscientIdiot: I fixed that one for now :)
11:59:04 <kscaldef> maybe that explains my HXT problems.  I collected too much nuclear waste and it went critical. ;-)
11:59:07 <olsner> try this address: http://tiger.cpsc.ucalgary.ca/ - do you get "WebGrid III" or an apache installation page?
11:59:08 <lambdabot> Title: WebGrid III
11:59:26 <olsner> apparently the page doesn't work in denmark, but works elsewhere ;-)
12:00:07 <Olathe> They're looking for Danish people to check that Apache is installed correctly.
12:00:38 <pixl> Cale, why do I have to use liftio in: cgimain conn =
12:00:38 <pixl>     do
12:00:38 <pixl>         dat <- liftIO (Projects.getAllProjects conn)
12:00:38 <pixl>         output (renderHtml (projs))
12:01:03 <olsner> Olathe: I think serving the correct page would be a better display of apache being installed correctly :P
12:01:06 <Botje> what's the type of getAllProjects?
12:01:10 <Botje> :t liftIO
12:01:11 <oerjan> olsner: i get an apache installation page, in norwegian.
12:01:12 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:01:18 <omniscientIdiot> pixl: output :: something -> CGI ()?
12:01:26 <pixl> yeah
12:01:38 <Cale> pixl: Because IO computations are not CGI computations
12:01:41 <omniscientIdiot> pixl: that fixes the monad for the do block to CGI
12:01:49 <pixl> so it returns the correct type (the same type as cgimain)
12:01:55 <Cale> pixl: CGI computations carry around extra data and are chained together differently
12:02:13 <Tac-Work> What can CGI not do that IO can?
12:02:14 <Cale> pixl: Did you read the short article I pointed you at?
12:02:15 <pixl> ah ok so i cant mix different monads in the same do block?
12:02:18 <Tac-Work> what does CGI restrict you to doing?
12:02:19 <omniscientIdiot> pixl: so you must change the (getAllProjects conn :: IO a) to :: CGI a
12:02:20 <Cale> right
12:03:21 <olsner> oerjan: wow, crazy... what's the IP adress for that name from your side? does this page http://136.159.7.57/ (IP-address from my end) give the contents or the installation page?
12:03:21 <lambdabot> Title: WebGrid III
12:03:43 <Cale> Tac-Work: newtype CGIT m a = CGIT { unCGIT :: ReaderT CGIRequest (WriterT Headers m) a }
12:03:52 <oerjan> olsner: http://tiger.cpsc.ucalgary.ca/index.html.en works for me, i think it is a language selection issue
12:03:52 <lambdabot> Title: WebGrid III
12:04:03 <omniscientIdiot> CGI = CGIT IO?
12:04:07 <Cale> yeah
12:04:20 <oerjan> http://tiger.cpsc.ucalgary.ca/index.html.no -- testing
12:04:21 <lambdabot> Title: Testside Apache-installasjon
12:04:30 <Cale> heh, and like a sucker, someone explicitly wrote out the Monad and other instances rather than using newtype-deriving
12:04:49 <olsner> ah, I see... they've not bother deleting index.html.* and just replaced the index.html
12:05:12 <olsner> or index.html.en even
12:07:09 <Cale> pixl: I highly recommend that Introduction to IO article I pointed you at, as well as http://www.haskell.org/haskellwiki/Monads_as_computation (being that I wrote both of them, I suppose that's unsurprising :)
12:07:10 <lambdabot> Title: Monads as computation - HaskellWiki
12:07:40 <byorgey> I highly recommend them as well, which may be somewhat less unsurprising. =)
12:07:52 <puusorsa> methcore <3
12:08:02 <Cale> puusorsa: huh?
12:08:33 <puusorsa> sorry i should try being sober sometime
12:09:11 <pixl> ok thanx Cale
12:09:33 <mrd> puusorsa: overrated
12:09:41 <puusorsa> true
12:09:47 <puusorsa> wanna???
12:10:35 * Cale realises he's been listening to the same 1970's Dutch progressive rock band for days now, and drops a Steely Dan album on to Audacious.
12:10:50 * byorgey is going to invent a genre of music called 'mathcore'
12:11:00 <arcatan> isn't it invented already?
12:11:01 <sebell> byorgey: Too late.
12:11:06 <byorgey> *sigh*
12:11:11 <arcatan> *core is mostly annoying
12:11:12 <Cale> http://en.wikipedia.org/wiki/Mathcore
12:11:29 <Botje> how about some mc plus plus instead?
12:11:35 <Cale> That's nerdcore
12:11:54 <byorgey> oh, but they don't sing about math?  how dumb.
12:12:38 <omniscientIdiot> Duh-nuh-nuh-nuh-nuh-nuh-nuh-nuh MONADS!!!!!
12:13:21 <byorgey> for some reason my brain wants to hear that to the tune of the 'Batman' theme song
12:13:33 <arcatan> it's awful
12:13:53 <Cale> Betta watch your back when I'm packin a nine / I'll pump you full of holes like the rational line
12:13:53 <arcatan> monadcore
12:14:06 <omniscientIdiot> not enough nuh-nuh-nuh-nuhs
12:14:18 <Cale> Mathematical gangsta rap
12:14:29 <Cale> Now there's a niche market
12:14:35 <omniscientIdiot> Cale++ just because
12:16:39 <eyeris> Why does ghci tell me that 'f' is not in scope when I type 'f :: String -> IO()'?
12:17:03 <Cale> eyeris: you're trying to give a type declaration for f on the GHCi commandline?
12:17:16 <eyeris> Yeah, to see if it is valid
12:17:33 <eyeris> The real type decl I was trying was: String -> IO(Maybe [String])
12:17:43 <omniscientIdiot> you introduce definitions in ghci with 'let'
12:17:45 <Cale> eyeris: Have you defined a function called f?
12:18:05 <Cale> eyeris: GHCi basically only evaluates expressions
12:18:14 <eyeris> No, I haven't. I thought I had to make the type decl before the definition
12:18:17 <Cale> eyeris: If you want to make declarations, you have to put them in a file.
12:18:21 <omniscientIdiot> if it has multiple cases, or you want to give the type, you must seperate each with semicolon on the same line.
12:18:21 <eyeris> ok
12:18:41 <omniscientIdiot> let f :: String -> (); f = ...
12:18:43 <Cale> (that's kind of a lie, but not really)
12:18:46 <omniscientIdiot> ^^ that'd work in ghci
12:19:11 <omniscientIdiot> but it'd get lost whenever you load or reload a file
12:19:14 <Cale> You can use let on the ghci commandline, but it's really better just to stick everything in a file, unless you're a fan of losing work.
12:19:41 <Tac-Work> Hehe, yeah
12:19:49 <Tac-Work> So many python scripts typed into the interpreter
12:20:03 <Tac-Work> if you mess up on the last line of a 7 line function, you have to retype it from scratch
12:20:16 <Cale> Also, there are lots of declarations which you can't even make inside a let
12:20:18 <Tac-Work> (or type up up up up up up enter up up up up up enter up up up up enter up up up enter ...)
12:20:23 <idnar> Tac-Work: or use ipython :P
12:20:30 <Tac-Work> ipython?
12:20:45 <phobes> or wing ide
12:22:34 <fasta> [Obvious troll]I never heard of an IDE in the Haskell world. [/Obvious troll]
12:22:37 <idnar> Tac-Work: it's an enhanced python REPL, essentially
12:23:23 <phobes> Apparently this one is being developed:  http://haskell.org/haskellwiki/Yi
12:23:24 <lambdabot> Title: Yi - HaskellWiki
12:23:38 <idnar> you can do something like "%edit", type in some function definitions; then later do "%edit foo" and modify the definition of foo
12:24:02 <fasta> phobes: you mean "was developed"?
12:24:33 <idnar> and then save it out to a file once you're done fiddling
12:25:02 <phobes> fasta:  My understanding was that it's currently somewhat lacking
12:25:24 <fasta> phobes: that would be consistent with my view
12:25:44 <phobes> (but I really don't know anything about it other than what I've heard on here)
12:25:59 <fasta>  ELisp
12:26:00 <fasta>     Dynamically scoped, Dynamically typed, ugly, old. 'Nuff said
12:26:21 <fasta> That's a short summary!
12:26:55 <fasta>  ELisp again
12:26:56 <fasta>     Haskell is a lot cleaner to write, especially because of the large number of libraries.
12:27:09 <fasta> I doubt Haskell has more libraries.
12:27:31 <tcr> Who the heck are you arguing with? :)
12:27:50 <fasta> http://haskell.org/haskellwiki/Yi
12:27:51 <lambdabot> Title: Yi - HaskellWiki
12:27:53 <idnar> Tac-Work: I guess you can achieve something similar with :edit in ghci
12:28:11 <idnar> well, :edit / :reload or whatever
12:28:25 <Tac-Work> yeah, I've been using :edit quite a bit
12:28:28 <Tac-Work> it's very cool
12:28:34 <mrd> reinke posted some nice ghci macros
12:29:18 <omniscientIdiot> link?
12:29:30 <mrd> haskell-cafe or c.l.haskell
12:29:51 <sjw> fasta: I wrote that summary, I think it misses nothing about the joy that is elisp
12:30:28 <fasta> sjw: writing elisp is arguably easier for a newbie than Haskell.
12:30:49 <fasta> sjw: one reason being the excellent integration
12:30:51 <sjw> mayyyyybe
12:31:04 <idnar> new to what?
12:31:08 * Heffalump finds elisp impossible to understand
12:31:08 <mrd> interactivity helps
12:31:18 <mrd> emacs has a nice help system too
12:31:21 <sjw> fasta: but if Haskell is integrated into Yi, then ...
12:31:56 <sjw> but also, I think newbies find elisp less easy to use
12:32:01 <fasta> sjw: then still it has about 200K functions lacking.
12:32:19 <sjw> fasta: so send dons a patch :)
12:32:46 <sjw> fasta: but I like and use emacs
12:32:59 <tcr> Heffalump: Uhm, why?
12:33:03 <fasta> People shouldn't recommend tools that do not work(see EclipseFP).
12:33:04 <sjw> despite elisp
12:33:19 <mrd> imperative programming is impossible to understand
12:33:49 <mrd> you have to master Hoare or Separation logic before you can write a program in an imperative language.
12:34:04 <pixl> anyone know of a large website written entirely in haskell? Just curious to see what can be done with haskell on the web development front..
12:34:47 <omniscientIdiot> hpaste.org is small website written in haskell
12:34:48 <sjw> mrd: troll :)
12:34:53 <omniscientIdiot> there's also an online store
12:35:03 <Zao> Haskell Server Pages! :)
12:35:09 <mrd> sjw: it's a good counter whenever someone says "but you have to master category theory to use Haskell IO!"
12:35:28 <sjw> use /= reason about
12:35:34 <mrd> what's the difference
12:35:45 <sjw> about 3 years of university>
12:35:52 <mrd> if you can't reason about it, you're not using it -- you're abusing it
12:35:55 <fasta> mrd: you need to understand that anyway.
12:36:10 <fasta> mrd: otherwise the State/ST monad would be pointless.
12:36:30 <omniscientIdiot> @wiki Applications and libraries
12:36:30 <lambdabot> http://www.haskell.org/haskellwiki/Applications_and_libraries
12:36:32 <omniscientIdiot> ^^ pixl
12:37:07 <sjw> mrd: people manage to speak english without understanding it's grammar :)
12:37:35 <augustss> pixl: http://braintreehemp.com.au/ if you count it as big
12:37:35 * mrd has not mastered Cat Theory, because he is allergic to cats.
12:37:50 <mrd> I regularly abuse Haskell IO =)
12:38:32 <phobes> mrd:   You have to master Hoare logic to write a program in an imperative language?   I agree with sjw - troll :)
12:39:19 <mrd> it's an acceptable excuse not to understand elisp!
12:39:40 <sjw> understand is a rather powerful word
12:39:50 <sjw> do you understand Haskell's type system?
12:40:03 <mrd> '98?
12:40:11 <mrd> or unspecified extensions
12:40:17 <sjw> take your pick
12:40:26 <Tac-Work> @let x (...) y = [x..y]
12:40:27 <lambdabot> <local>:8:13:     Occurs check: cannot construct the infinite type:       t =...
12:40:40 <ulfdoz> ocaml's type system is much  more complicated imho.
12:40:45 <Tac-Work> @let (...) x y = [x..y]
12:40:50 <lambdabot> Defined.
12:40:51 <mrd> pretty sure i understand '98 and some extensions.
12:40:56 <Tac-Work> > 1...5
12:40:57 <lambdabot>  [1,2,3,4,5]
12:41:04 <Cale> @let x ... y = [x..y]
12:41:04 <lambdabot> <local>:8:0:     Warning: Pattern match(es) are overlapped              In th...
12:41:10 <Cale> @undef
12:41:10 <lambdabot> Undefined.
12:41:12 <Cale> @let x ... y = [x..y]
12:41:13 <lambdabot> Defined.
12:41:19 <Tac-Work> elipsis really should always be written with three dots ;-)
12:42:00 <sjw> @let x -- y = [x..y]
12:42:00 <lambdabot>  Parse error
12:42:06 <mrd> comment, sjw
12:42:08 <sjw> meh
12:42:24 <byorgey> > [1...5] -- oops
12:42:25 <lambdabot>  [[1,2,3,4,5]]
12:42:33 <Heffalump> lol
12:42:42 <Heffalump> > [1....5]
12:42:43 <lambdabot>   Not in scope: `....'
12:42:48 <Heffalump> @type (...)
12:42:50 <lambdabot> Not in scope: `...'
12:43:09 <Heffalump> odd.
12:43:14 * omniscientIdiot . o O (... = undefined, if ... were special-cased to not require parens, then you could use ... for unfinished parts!)
12:43:14 <scv> > [1... .. [5]]
12:43:14 <lambdabot>  Parse error
12:43:21 <byorgey> Heffalump: @let and @type don't talk to one another.
12:43:29 <omniscientIdiot> Heffalump: (....) /= (...)
12:43:53 <Cale> > map (1...) [1..5]
12:43:54 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:43:56 <Tac-Work> @let _ .!@#$ u = "hperl"
12:43:58 <lambdabot> Defined.
12:44:10 <Tac-Work> 3 .!@#$ 4
12:44:14 <mrd> > inits [1..5]
12:44:15 <Tac-Work> > 3 .!@#$ 4
12:44:15 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:44:16 <lambdabot>  "hperl"
12:44:33 <byorgey> > map (1...) [0..5]
12:44:35 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:44:51 <Heffalump> omniscientIdiot: I know. Was just experimenting, not having read scrollback.
12:45:23 <mrd> omniscientIdiot: i'd rather use _|_ for undefined.
12:45:32 <Tac-Work> @let x + y = undefined
12:45:34 <lambdabot> Defined.
12:45:38 <byorgey> @let x .... y = map (x...) (x...y)
12:45:39 <lambdabot> Defined.
12:45:41 <Tac-Work> > map (+1) [1..3]
12:45:41 <mrd> sometimes people use __ = undefined
12:45:42 <lambdabot> Terminated
12:45:48 <byorgey> @let x ..... y = map (x....) (x....y)
12:45:49 <lambdabot> <local>:5:25:     Occurs check: cannot construct the infinite type: a = [a]  ...
12:46:01 <byorgey> > 1 .... 5
12:46:03 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:46:07 <scv> >1+2
12:46:18 <Tac-Work> > 1+2
12:46:19 <lambdabot> Terminated
12:46:24 <byorgey> scv: need a space after >
12:46:25 <mrd> lol
12:46:30 <omniscientIdiot> > 1 ..... 3
12:46:31 <lambdabot>   Not in scope: `.....'
12:46:35 <Tac-Work> can lambdabot unbind individual identifiers?
12:46:39 <phobes> omniscientIdiot: Just use  ... ... ...
12:47:03 <byorgey> how would you generalize .... to .....?
12:47:04 <phobes> I guess that doesn't work either
12:47:14 <mrd> ... . ...
12:47:18 <scv> > head (1:(1+2):[])
12:47:18 <lambdabot> Terminated
12:47:30 <phobes> mrd:  it's still a parse error
12:47:58 <Tac-Work> @unlet
12:48:00 <lambdabot> Defined.
12:48:01 <byorgey> @let x ..... y = map (map (x ....)) (x .... y)
12:48:03 <lambdabot> Defined.
12:48:03 <Tac-Work> @undef
12:48:05 <lambdabot> Undefined.
12:48:08 <Tac-Work> > 1+2
12:48:09 <lambdabot>  3
12:48:13 <Tac-Work> the tyrany is over
12:48:20 * omniscientIdiot . o O (or maybe _ = undefined, since _ is the universal match, it could be the universal expression!  I think JHC does this)
12:48:30 * byorgey scowls at Tac-Work 
12:48:42 <Tac-Work> I'm sorry
12:48:47 <Tac-Work> Tac-Work--
12:48:58 <byorgey> s'ok =)
12:49:14 <omniscientIdiot> @karma- omniscientIdiot
12:49:15 <lambdabot> You can't change your own karma, silly.
12:49:26 <omniscientIdiot> Tac-Work: ^^
12:50:26 <Tac-Work> @let x ... y = [x..y]
12:50:26 <Tac-Work> @let x .... y = map (x...) (x...y)
12:50:26 <Tac-Work> @let x ..... y = map (x....) (x....y)
12:50:28 <lambdabot> Defined.
12:50:30 <lambdabot> Defined.
12:50:30 <lambdabot> <local>:3:25:     Occurs check: cannot construct the infinite type: a = [a]  ...
12:50:40 * omnIdiot tries a shorter nick
12:50:46 <byorgey> @let x .... y = map (map (x....)) (x....y)
12:50:47 <lambdabot> <local>:3:11:     Occurs check: cannot construct the infinite type: a = [[a]]...
12:50:54 <byorgey> @let x ..... y = map (map (x....)) (x....y)
12:50:56 <lambdabot> Defined.
12:51:00 <byorgey> > 1 ..... 5
12:51:01 <lambdabot>  [[[[1]]],[[[1]],[[1],[1,2]]],[[[1]],[[1],[1,2]],[[1],[1,2],[1,2,3]]],[[[1]],...
12:51:03 <byorgey> whee
12:51:05 <idnar> heh
12:51:55 <Tac-Work> There's no "flatten" function in Haskell is there?
12:52:08 <Tac-Work> that would probably be too dynamic of a type to be allowable
12:52:11 <Botje> Tac-Work: it's called concat
12:52:19 <Botje> but only does one level
12:52:22 <Tac-Work> yeah
12:52:53 <Tac-Work> @let flatten xs = (concat . concat . concat) xs
12:52:55 <lambdabot> Defined.
12:52:59 <Taejo> is there a builtin way to take the nth iterate of a function (a -> a)
12:53:00 <Tac-Work> > flatten  1..... 5
12:53:01 <lambdabot> Terminated
12:53:14 <Tac-Work> > concat 1 ..... 5
12:53:14 <lambdabot>   add an instance declaration for (Num [a])
12:53:20 <omnIdiot> > flatten (1 ..... 5)
12:53:21 <lambdabot> Terminated
12:53:23 <xerox> Tac-Work: the multi-level flatten can be defined.
12:53:24 <oerjan> > iterate (+1) 1
12:53:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:53:32 <byorgey> Taejo: you could just do (iterate f x) !! n
12:53:36 <Tac-Work> iterate flatten?
12:53:50 <xerox> Tac-Work: no, some milliolegs of type hackery.
12:54:05 <scv> flatten [[1],[2]]
12:54:21 <scv> > flatten [[1],[2]]
12:54:21 <lambdabot> Terminated
12:54:28 <scv> > flatten [1,2]
12:54:28 <lambdabot> Terminated
12:54:33 <Tac-Work> hmm
12:54:37 <Taejo> byorgey, thx
12:54:38 <Tac-Work> > flatten []
12:54:38 <lambdabot> Terminated
12:54:40 <byorgey> you'd have to create a type class which encompasses [a], [[a]], [[[a]]], and so on
12:54:46 <scv> :t (concat . concat . concat)
12:54:48 <lambdabot> forall a. [[[[a]]]] -> [a]
12:54:53 <byorgey> then somehow get around the overlapping instances to have it pick the "deepest" one
12:54:55 <byorgey> or something
12:54:58 <quicksilver> byorgey: the problem is encompassing the fact that "a is not of the form [b]"
12:55:02 <Tac-Work> > concat []
12:55:03 <lambdabot>  []
12:55:05 <byorgey> Taejo: you're welcome
12:55:08 <Tac-Work> > (concat . concat) []
12:55:10 <lambdabot>  []
12:55:11 <byorgey> quicksilver: right.
12:55:17 <quicksilver> byorgey: but if you know how to abuse overlapping instances I believe it can be done
12:55:20 <Tac-Work> > (concat . concat . concat) []
12:55:21 <lambdabot>  []
12:55:25 <quicksilver> I've always considered that evil and not tried to do it :)
12:55:29 <Tac-Work> > flatten []
12:55:29 <lambdabot> Terminated
12:55:37 <idnar> :t flatten
12:55:38 <lambdabot> forall a. Tree a -> [a]
12:55:40 <byorgey> well, *I* don't, but I'm pretty sure I've seen something like it done
12:55:43 <quicksilver> you could certainly do it for a particular set of 'a's though
12:55:44 <xerox> actually I've done that for m (m (m ... a ...)) -> m a
12:55:49 <xerox> deep'join
12:56:08 <idnar> > concat . concat . concat $ 1 ..... 5
12:56:08 <quicksilver> e.g. a = Int, Char, Integer, Double, and any tuples of those
12:56:09 <lambdabot>  [1,1,1,1,2,1,1,1,2,1,1,2,1,2,3,1,1,1,2,1,1,2,1,2,3,1,1,2,1,2,3,1,2,3,4,1,1,1...
12:56:49 <scv> > nub (concat . concat . concat  $ 1 ..... 5)
12:56:51 <lambdabot>  [1,2,3,4,5]
12:56:57 <omnIdiot> :D
12:57:14 <scv> :t histogram
12:57:16 <lambdabot> Not in scope: `histogram'
12:57:36 <omnIdiot> > map (head &&& length) . group . sort (concat . concat . concat  $ 1 ..... 5)
12:57:37 <lambdabot>  Couldn't match expected type `a -> [a1]'
12:57:52 <omnIdiot> > map (head &&& length) . group . sort $ (concat . concat . concat  $ 1 ..... 5)
12:57:54 <lambdabot>  [(1,35),(2,20),(3,10),(4,4),(5,1)]
12:58:06 <byorgey> hey! tetrahedral numbers!
12:58:10 <idnar> heh
12:58:40 <scv> > map (head &&& length) . group . sort $ (concat . concat . concat  $ 1 ..... 10)
12:58:41 <lambdabot>  [(1,220),(2,165),(3,120),(4,84),(5,56),(6,35),(7,20),(8,10),(9,4),(10,1)]
12:59:41 <omnIdiot> @let hist xs = map (head &&& length) . group . sort $ xs
12:59:44 <lambdabot> Defined.
12:59:47 <byorgey> > let fac n = product [1..n]; binom n k = fac n `div` (fac k * fac (n-k)) in map (flip binom 3) [9,8..0
12:59:47 <lambdabot>  Parse error
12:59:50 <byorgey> > let fac n = product [1..n]; binom n k = fac n `div` (fac k * fac (n-k)) in map (flip binom 3) [9,8..0]
12:59:52 <lambdabot>  [84,56,35,20,10,4,1,0,0,0]
13:00:41 <Tac-Work> @let m = Map.fromList [(i, k) | (i, k) <- zip [1..] [1..5]]
13:00:41 <lambdabot> <local>:6:4: Not in scope: `Map.fromList'
13:00:43 <omnIdiot> interesting
13:00:49 <Tac-Work> @let m = fromList [(i, k) | (i, k) <- zip [1..] [1..5]]
13:00:50 <lambdabot> <local>:6:4: Not in scope: `fromList'
13:00:53 <byorgey> > map (head &&& length) . group . sort $ (concat . concat  $ 1 .... 10)
13:00:53 <lambdabot>   add an instance declaration for (Num [a])
13:01:01 <Tac-Work> @let m = Data.Map.fromList [(i, k) | (i, k) <- zip [1..] [1..5]]
13:01:02 <lambdabot> <local>:6:4: Not in scope: `Data.Map.fromList'
13:01:04 <Tac-Work> bah!
13:01:12 <omnIdiot> M.
13:01:18 <Tac-Work> @let m = M.fromList [(i, k) | (i, k) <- zip [1..] [1..5]]
13:01:21 <lambdabot> Defined.
13:01:23 <Tac-Work> thank you
13:01:29 <Tac-Work> > fmap (+1) m
13:01:30 <lambdabot>  fromList [(1,2),(2,3),(3,4),(4,5),(5,6)]
13:01:32 <Tac-Work> > m
13:01:33 <lambdabot>  fromList [(1,1),(2,2),(3,3),(4,4),(5,5)]
13:01:54 <Tac-Work> wtf
13:02:01 <Tac-Work> ghc is giving me a different answer!
13:02:21 <byorgey> Tac-Work: what answer is it giving you?
13:02:26 <Tac-Work> Prelude Data.Map> let m = fromList [(i, k) | (i, k) <- zip [1..] [1..5]]
13:02:26 <Tac-Work> Prelude Data.Map> fmap (+1) m
13:02:26 <Tac-Work> fromList [(1,3),(2,3),(3,3),(4,3),(5,3)]
13:02:52 <Tac-Work> which is wrong....
13:03:07 <byorgey> that's... odd
13:03:23 <Tac-Work> fmap id m works correctly though
13:03:39 <omnIdiot> what about just m?
13:03:39 <sjw> works for me
13:03:47 <Tac-Work> and (subtract 1) works
13:04:03 <sjw> what about (+1) 1?
13:04:05 <oerjan> Tac-Work: been redefining +?
13:04:13 <omnIdiot> do you have a (+) defined somewhere?
13:04:17 <Tac-Work> only in the channel =-)
13:04:23 <Tac-Work> I didn't do that on my interpreter
13:04:33 <byorgey> > 1 + 5
13:04:34 <lambdabot>  6
13:04:45 <omnIdiot> try 1 + 1 in ghci
13:04:51 <Tac-Work> weird
13:04:52 <Tac-Work> ok
13:04:56 <Tac-Work> i restarted and it works right now
13:05:06 <Tac-Work> I thought I was taking crazy pills for a second
13:05:08 <omnIdiot> get 3?
13:05:09 <omnIdiot> :)
13:05:20 <Tac-Work> oh
13:05:21 <Tac-Work> hah
13:05:25 <Tac-Work> I found the problem
13:05:32 <byorgey> ?
13:05:39 <Tac-Work> I did a let x + y = 3 a long time ago when I was futzing with the operator nonsense
13:05:50 <omnIdiot> THERE'S ALWAYS A LOGICAL EXPLANATION FOR THESE THINGS.
13:06:04 <omnIdiot> THE TRUTH IS OUT THERE
13:06:06 <Tac-Work> Just because something is logical doesn't mean it makes sense
13:06:08 <byorgey> Tac-Work, looks like you were taking crazy pills after all. =)
13:06:09 <scv> > let crazy = 3; pills = [1..5]; in take crazy pills
13:06:10 <lambdabot>  [1,2,3]
13:06:23 <Tac-Work> Operator overloading is the crazy pills
13:06:34 <omnIdiot> %)
13:06:38 <Tac-Work> not the most useful feature of haskell, imo X-D
13:07:05 <omnIdiot> I beg to differ!
13:07:14 <Tac-Work> at least on the basic arithmetic stuff
13:07:54 <scv> if it was real overloading instead of overriding otoh.
13:08:38 <scv> > let 1+1=3 = in 1+1
13:08:39 <lambdabot>  Parse error
13:08:54 <scv> > let 1+1 = 3 in 1+1
13:08:56 <lambdabot>  3
13:09:08 <omnIdiot> @let x + y = x * y
13:09:11 <lambdabot> Defined.
13:09:15 <scv> here we go again
13:09:20 <omnIdiot> mwahaha, I've set a dastardly trap!
13:09:32 <kolmodin> > let fs = ["fear", "anger", "hate", "suffering"] in unwords . map (\(x:xs,y) -> toUpper x : xs ++ " leads to " ++ y ++ ".") $ zip fs (tail fs)
13:09:34 <lambdabot>  "Fear leads to anger. Anger leads to hate. Hate leads to suffering."
13:09:56 <omnIdiot> kolmodin: I read the same article
13:10:01 <kolmodin> aye :)
13:10:11 <kolmodin> I think he did it a lot harder than it is
13:10:17 <omnIdiot> kolmodin: could use a little streamlining, but it shows a good start.
13:10:51 <kolmodin> what could?
13:11:00 <omnIdiot> the article
13:11:03 <kolmodin> yes
13:11:12 <scv> > let fs = ["emptiness", "cleanliness", "holiness", "godliness"] in unwords . map (\(x:xs,y) -> toUpper x : xs ++ " is " ++ y ++ ".") $ zip fs (tail fs)
13:11:14 <lambdabot>  "Emptiness is cleanliness. Cleanliness is holiness. Holiness is godliness."
13:11:15 <kolmodin> many of the things he wrote are already in the prelude
13:11:22 <byorgey> > 2 + 2
13:11:23 <lambdabot> Terminated
13:11:28 <omnIdiot> figuring out how to write the library functions before you know they exist builds confidence in them
13:11:56 <kolmodin> yes. or reimplement them in the article and say that they are in the prelude
13:12:25 <kolmodin> like the  zip x (tail x)    is a quite common thing
13:12:28 <omnIdiot> I got the impression that he was a fresh greenhorn and just didn't know their existence.
13:12:36 <kolmodin> yes, probably
13:12:37 <omnIdiot> yeah
13:12:40 <kolmodin> I got the same impression
13:15:22 <dolio> @pl map (\(a,b) -> e) $ zip c d
13:15:22 <lambdabot> map (const e) (zip c d)
13:15:41 <omnIdiot> http://www.kirit.com/Yoda%20speaks%20Visual%20Haskell for anyone interested
13:15:44 <lambdabot> Title: Yoda speaks Visual Haskell  kirit.com
13:16:08 <omnIdiot> @pl map (\(a,b) -> f a b) (zip c d)
13:16:08 <lambdabot> zipWith f c d
13:16:20 <Botje> neat.
13:16:34 <Botje> is that an actual rewrite rule?
13:16:43 <dolio> Ah, so it is smart enough if you actually use them. :)
13:17:44 * Botje is pondering a LOLCODE interpreter in haskell
13:17:54 <omnIdiot> oh god
13:17:56 <Botje> now that I thought of it, has it been implemented yet? :)
13:18:17 <idnar> LOLHASKELL
13:18:24 <idnar> or, uhm, hasklol?
13:20:29 <scv> > let visible = printLn in visible "cheezburger"
13:20:36 <lambdabot>   Not in scope: `printLn'
13:20:51 <xerox> > ap (zipWith ((++) . (++ " leads to "))) tail ["fear", "anger", "hate", "suffering"]
13:20:52 <lambdabot>  ["fear leads to anger","anger leads to hate","hate leads to suffering"]
13:20:55 <sorear> @snap Botje
13:20:56 * lambdabot smacks Botje about with a large trout
13:21:10 <Botje> awwh :(
13:21:17 <Botje> i won't release it! I promise!
13:21:48 <Botje> i'd use ICANHASKELL as codename :P *ducks*
13:22:03 <omnIdiot> #defined I_CAN_HAS import
13:22:17 <sorear> omnIdiot: something corrupted your escient
13:22:19 <omnIdiot> s/defined/define/
13:22:29 <omnIdiot> I did
13:22:54 * omnId goes even shorter
13:23:15 <augustss> How about oid?
13:23:22 <sorear> just 'o'
13:23:33 <kolmodin> augustss: I see you too have gone shorter
13:23:48 <sorear> nah, o is taken, use i
13:24:15 <sorear> kolmodin: augustss is longer than lennart...
13:24:35 <kolmodin> yes, but shorter than augustsson
13:24:39 <oI> oy!
13:24:40 * sorear wonders if kolmodin is the reason augustss no longer uses that nick
13:24:41 <augustss> kolmodin: augustss has been my Unix uid since 1980 :)
13:25:04 <kolmodin> augustss: ah, fair enough :) I was not born in 1980
13:25:38 <kolmodin> augustss: so will I see you next week ?
13:25:57 <augustss> If you're in Freiburg you probably will.
13:26:08 <kolmodin> I am. great
13:26:20 <sorear> Will anyone *recognize* anyone else there?
13:26:34 <kolmodin> I will recognize a few :)
13:26:35 <xerox> Yup :)
13:26:49 <kolmodin> the swedes and the ones from the last hackathon... and a few more
13:27:07 <Botje> just wear tshirts with the name of the monad tutorial you wrote :)
13:27:13 <kolmodin> hah :)
13:27:46 <augustss> but what about those of us who have not written one? :(
13:27:55 <Olathe> Make up a title.
13:28:06 <kolmodin> augustss: then you write the name of your compilers
13:28:20 <Botje> that or the name of your generic library.
13:28:26 <augustss> kolmodin: ok
13:28:31 <kolmodin> :)
13:28:46 <augustss> then there's also the name tags :)
13:28:47 <njbartlett> Has anybody written an arrows/applicatives tutorial yet?
13:28:52 <kolmodin> augustss: will you be able to fit that on a tiny name tag? :D
13:28:54 * Heffalump hasn't written anything really.
13:29:14 <Heffalump> But I expect a large enough number of people will know me that it won't be too hard to get to know the rest.
13:29:57 <kolmodin> I think we should bring our own name tags to the hackathon?
13:30:04 <kolmodin> will there be name tags at ICFP?
13:30:04 <olsner> Heffalump: are you famous?
13:30:15 <kolmodin> define famous :)
13:30:27 <Botje> Heffalump is going to do an impression of the Quantum monad.
13:30:42 <dons> Heffalump's fairly famous.
13:30:49 <dons> more so if he brings candies
13:30:50 <kolmodin> aye
13:30:53 <kolmodin> :D
13:31:01 <njbartlett> Heffalump's head is in the bottem left corner of http://www.londonhug.net/2007/09/24/better-video-for-games-in-haskell/
13:31:03 <njbartlett> :-)
13:31:04 <lambdabot> Title: ondon HUG  Blog Archive  Better Video for Games in Haskell, http://tinyurl.com/26m86z
13:31:13 <njbartlett> Bottom, even.
13:32:23 <dons> here's a photo of Heffalump, with me in the background
13:32:25 <dons>   http://www.algorithm.com.au/albums/snowbird2004/IMG_2528.sized.jpg
13:32:26 <lambdabot> http://tinyurl.com/2or3ct
13:32:39 <dons> it was cold that day
13:32:58 <njbartlett> So why can't lambdabot handle the lambda in that HTML page title?
13:32:59 <augustss> brrrrrr
13:33:10 <olsner> wow, looks cold... and I didn't recognize either of you from anywhere ;-)
13:33:10 <dons> here's dcoutts, he's also cold:
13:33:11 <dons>   http://www.algorithm.com.au/albums/snowbird2004/IMG_2526.sized.jpg
13:33:12 <kolmodin> dons: nice hat!
13:33:12 <lambdabot> http://tinyurl.com/33343h
13:33:33 <Lemmih> dons: Where is that?
13:33:40 <kolmodin> yes, he looks fairly... um.. normal
13:33:42 <Botje> dons: that is a very scary photo.
13:33:49 <Cale> hehe, that's a great picture
13:33:54 <kolmodin> :D
13:34:10 <Botje> "hey, do you think this axe is sharp?"
13:34:42 <Heffalump> Lemmih: a cable car in Snowbird, at ICFP 2004
13:35:08 <kolmodin> utah
13:35:10 <augustss> was it that cold?  i don't remember that
13:35:35 <dons> it was up in snowbird, utah. but we climbed up the moutain to hidden peak
13:35:39 <dons> and got caught in a blizzard
13:35:45 <dons> it was -10F or something.
13:35:46 <augustss> ah
13:36:03 <Heffalump> I decided I wanted to see the top and persuaded several other people that this was a good idea, IIRC.
13:36:44 <kolmodin> dcoutts without a beard! shocking!
13:37:03 <Heffalump> I found the idea of him with a beard quite shocking for a while.
13:37:11 <kolmodin> hah :D
13:37:17 <dons> http://www.algorithm.com.au/albums/snowbird2004/IMG_2514.sized.jpg  ah, 20 degress F
13:37:17 <Heffalump> We need to shave Igloo sometime, for real shock value.
13:37:18 <lambdabot> http://tinyurl.com/2up4oc
13:37:30 <kolmodin> that's why I grew back mine for the icfp and hackathon events :)
13:38:34 <kolmodin> although it would have shocked less people...
13:38:51 <olsner> @google 20 degrees fahrenheit in centigrade
13:38:52 <lambdabot> 20 degrees Fahrenheit = -6.66666667 degrees Celsius
13:38:52 <kolmodin> I would not recognize Igloo without his beard
13:39:07 <Heffalump> when I first met him it was somewhat shorter.
13:39:17 <Heffalump> but I've never known him without it
13:39:24 <kolmodin> I hardly recognize myself when I go from the one state to the other!
13:39:33 * EvilTerran gets that occasionally
13:39:43 <Botje> kolmodin: you shouldn't mutate yourself, it's bad!
13:39:51 <Heffalump> http://urchin.earth.li/photopub/display?photo=/users/ganesh/banana/675&thumb=640x640
13:39:53 <lambdabot> http://tinyurl.com/2j3bp5
13:40:06 <xerox> ?google -20 degrees fahrenheit in centigrade
13:40:07 <kolmodin> Botje: I can't help it :)
13:40:07 <lambdabot> (-20) degrees Fahrenheit = -28.8888889 degrees Celsius
13:40:18 <dons> so that's a little cold.
13:40:40 <kolmodin> ah, yes. slightly colder than my average day
13:40:53 <sorear> wow, 1 significant figure F corresponds to 9 C?
13:41:03 <Heffalump> sorear: it's based at 32
13:41:29 <Heffalump> as in freezing point is there.
13:41:42 <sjw> for some silly reason
13:41:43 <Heffalump> but 9F = 5C, generally.
13:41:44 <dons> because my Fahrenheit was crazy
13:41:47 <EvilTerran> @go 0 F in C
13:41:48 <lambdabot> 0 degrees Fahrenheit = -17.7777778 degrees Celsius
13:41:51 <EvilTerran> @go 0 C in F
13:41:52 <lambdabot> 0 degrees Celsius = 32 degrees Fahrenheit
13:41:56 <ihope> How many degrees below zero?
13:41:58 <sjw> and where is the boiling point of water?
13:41:59 <Heffalump> it's not silly, there's some good historic reason to do with the way Fahrenheit measured temperature
13:42:02 <Heffalump> sjw: 212
13:42:03 <lucca> @go -40 C in F
13:42:04 <lambdabot> (-40) degrees Celsius = -40 degrees Fahrenheit
13:42:08 <sjw> see!!!
13:42:08 <EvilTerran> @go 1/(once in a blue moon)
13:42:09 <lambdabot> 1 / once in a blue moon = 2.71542689 years
13:42:12 <EvilTerran> :D
13:42:16 <dons> Heffalump: to do with the body temperature of Fahrenheit's wife, iirc
13:42:25 <dons> and her running a constant fever, hence 100 degrees F is a bit high
13:42:29 <oI> water boiling point is 212 deg F
13:42:31 <sorear> Heffalump: yeah, I know the formula; I just think Google is inventing significant figures in the -2 x 10^1 => -2.888888889 x 10^`
13:42:55 <Heffalump> sorear: oh, I see what you mean
13:43:05 <Heffalump> well, it's obviously just calculating a fraction. But yeah.
13:43:14 <sjw> @go 0 C in Kelvin
13:43:14 * Cale doesn't really understand why anyone uses Fahrenheit.
13:43:15 <lambdabot> 0 degrees Celsius = 273.15 kelvin
13:43:18 <lucca> @go c in furlongs per fortnight
13:43:19 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
13:43:24 <njbartlett> @go 1 euro in yen
13:43:25 <lambdabot> 1 Euro = 161.54287 Japanese yen
13:43:38 <njbartlett> Cool!
13:43:39 <Heffalump> historic reasons, like the rest of the imperial system
13:43:39 * omniscientIdiot doesn't understand why anyone doesn't use Kelvin :P
13:43:44 <sjw> @go CA$1 in USD
13:43:46 <byorgey> @go the meaning of life, the universe, and everything F in C
13:43:46 <lambdabot> http://ask.metafilter.com/68321/Best-exchange-rate-for-regular-US-to-CA-transactions
13:43:46 <lambdabot> Title: Best exchange rate for regular US$ to CA$ transactions? | Ask MetaFilter
13:43:49 <lambdabot> http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything
13:43:49 <lambdabot> Title: Answer to Life, the Universe, and Everything - Wikipedia, the free encyclopedia
13:43:51 <Botje> wikipedia lists _SIX_ different stories for farenheit scale
13:43:57 <Heffalump> I don't understand human body temperatures in anything but Fahrenheit.
13:44:04 <Heffalump> everything else, I only understand in Celsius.
13:44:06 * sorear gets very peeved when he sees stuff like 1000 mi (1603 km) in textbooks
13:44:27 <Cale> Heffalump: 37 degrees C
13:44:32 <kolmodin> hmm
13:44:43 <kolmodin> @go 1 haskell in C
13:44:45 <lambdabot> http://www.haskell.org/~pairwise/intro/section1.html
13:44:45 <lambdabot> Title: Haskell for C Programmers
13:44:58 <Cale> @go human body temperature
13:45:00 <lambdabot> http://hypertextbook.com/facts/LenaWong.shtml
13:45:00 <lambdabot> Title: Temperature of a Healthy Human (Body Temperature)
13:45:01 <Heffalump> sorear: a friend of mine has a story about a teacher marking him wrong when he said that 6mn Kelvin was 6mn Celsius (or something along those lines)
13:45:08 <Cale> @go human body temperature in Celcius
13:45:10 <lambdabot> http://hypertextbook.com/facts/LenaWong.shtml
13:45:10 <lambdabot> Title: Temperature of a Healthy Human (Body Temperature)
13:45:13 <Cale> huh
13:45:16 <sorear> Heffalump: 6mn?
13:45:22 <Heffalump> Cale: IM an intuitive understanding of what's a dangerous temperature.
13:45:26 <Heffalump> sorear: 6 million
13:45:29 <Cale> Google calculator actually does know that.
13:45:36 <Cale> @go 1 human body temperature in Celcius
13:45:38 <lambdabot> http://hypertextbook.com/facts/LenaWong.shtml
13:45:38 <lambdabot> Title: Temperature of a Healthy Human (Body Temperature)
13:45:40 <Cale> nope
13:45:41 <Cale> hmm
13:46:07 <sorear> maybe you have to spell celsius differently?
13:46:20 <sorear> @go 1 human body temperature in celsius
13:46:20 <lambdabot> 1 * human body temperature = 37 degrees Celsius
13:46:22 <Cale> oh, damn :)
13:46:41 <EvilTerran> @go human body temperature in F =
13:46:41 <Cale> Yes, Celsius.
13:46:42 <lambdabot> human body temperature = 98.6 degrees Fahrenheit
13:46:49 <sorear> @go 2 human body temperature in celsius
13:46:50 <lambdabot> 2 * human body temperature = 347.15 degrees Celsius
13:47:06 <Cale> nice, it gets it right :)
13:47:37 <olsner> but... 2*37 /= 347? or does it perform multiplication on kelvins?
13:47:53 <Heffalump> olsner: it does it on kelvins, those being the only thing it makes sense to scale like that
13:47:56 <sjw> @go 2 human body temperature in kelvin
13:47:57 <lambdabot> 2 * human body temperature = 620.3 kelvin
13:48:12 <sjw> @go 1 human body temperature in kelvin
13:48:13 <lambdabot> 1 * human body temperature = 310.15 kelvin
13:48:13 <Cale> Heffalump: well, anything more than about a degree off of that is unhealthy
13:49:45 <KatieHuber> wow, Intel Core 2 Duo processors seem *much* faster at running GHC-compiled code than Core Duo... even taking into account the clock speed bump
13:51:48 <tarrybone> sorear: http://blog.plover.com/physics/precision-2.html
13:51:48 <Heffalump> Cale: well, I still find it easier to understand Fahrenheit. 98s = fine, 99s = a bit ill, 100s = don't go to work, 102+ = feeling really bad, 104+ = think about medical attention
13:51:49 <lambdabot> Title: The Universe of Discourse : 1219.2 feet
13:51:58 <Heffalump> the key point being that 100 is a useful cut-off.
13:52:14 <kolmodin> good night!
13:53:13 <njbartlett> My wife had a temperature of 40 degrees C a few weeks ago. What's that in old money?
13:53:29 <sjw> ask @go
13:53:33 <njbartlett> @go 40 degrees C in F
13:53:33 <Heffalump> @go 40 celsius in fahrenheit
13:53:33 <Lemmih> ?go 40c in f
13:53:33 <lambdabot> 40 degrees Celsius = 104 degrees Fahrenheit
13:53:34 <lambdabot> 40 degrees Celsius = 104 degrees Fahrenheit
13:53:35 <lambdabot> 40 degrees Celsius = 104 degrees Fahrenheit
13:53:37 <Heffalump> oops..
13:53:39 <EvilTerran> good lord!
13:53:42 <Heffalump> njbartlett: quite a lot.
13:54:00 <njbartlett> Okay, then your scale sounds about right.
13:54:02 <sjw> njbartlett: how accurate was the thermometer
13:54:02 <tarrybone> sorear: sorry, i meant to link you here: http://blog.plover.com/physics/precision.html
13:54:04 <lambdabot> Title: The Universe of Discourse : Excessive precision
13:54:04 <Cale> @go 100 F in C
13:54:06 <lambdabot> 100 degrees Fahrenheit = 37.7777778 degrees Celsius
13:54:21 <njbartlett> sjw: Good question. It was digital, at least
13:55:15 <Heffalump> Fahrenheit also provides a more useful resolution with a single dp.
13:58:00 <KatieHuber> @paste
13:58:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:58:01 <njbartlett> So, to talk about Haskell again for a minute... I'm looking for ideas for the next London HUG. (as always!)
13:58:11 <sjw> did we figure out what 0 F relates to?
13:58:30 <hpaste>  Katie pasted "optimization help?" at http://hpaste.org/2954
13:58:40 <KatieHuber> hey announce is working again :)
13:59:08 <Botje> KatieHuber: what's the alternative to [c] ?
13:59:14 <sjw> 2/3? really?
13:59:16 <Botje> []?
13:59:21 <sjw> what else does it do?
13:59:26 <Heffalump> that looks tricky to optimise.
13:59:26 <KatieHuber> either empty or longer
13:59:42 <Heffalump> I guess you could make a smart datatype that caches that info, but the overhead is likely to outweigh the saving.
13:59:49 <KatieHuber> actually I don't think it can be empty
13:59:51 <Heffalump> I suggest calling it less.
14:00:16 <KatieHuber> each call is for something different, so caching won't work
14:00:18 <Heffalump> why does it take a parameter it ignores?
14:00:23 <Botje> KatieHuber: SingleCardInHand _ (x:xs) = null xs
14:00:36 <KatieHuber> it's part of a generic  system
14:00:52 <Heffalump> IM caches the info in the sense that you have a datatype like data CardList a = Single a | Other [a]
14:00:53 <sjw> are you sure that the list isn't being forced, thus resulting in lots of computation?
14:00:54 <KatieHuber> there are other functions which do use the first argument, which get used in the same place
14:01:04 <Heffalump> so you immediately see from the Single constructor that it is a single card.
14:01:40 <Heffalump> so it's being used as a higher-order parameter? I.e. inlining won't help?
14:01:47 <KatieHuber> the list is generated by taking all sublists of a list, so I think special-casing a single-element list there'd be worse...
14:02:12 <KatieHuber> it could be inlined I suppose
14:02:22 <KatieHuber> should try with -O2, though that usually seems to make stuff slower
14:02:24 <kscaldef> it seems like using --enable-library-profiling with cabal only adds -prof to the compile args.  Is there a way to get -auto-all as well?
14:02:50 <Heffalump> what is the type of c?
14:02:57 <Lemmih> kscaldef: GHC-Prof-Options in the cabal file.
14:03:10 <kscaldef> Lemmih: thanks
14:03:15 * kscaldef boards plane
14:03:28 <KatieHuber> c is data FacingCard = FaceUp { card::Card } | FaceDown { card::Card } and data Card = Card Rank Suit and....
14:03:32 <sorear> tarrybone: I can't access that page
14:03:46 <fasta> KatieHuber: paste profile output
14:04:05 <KatieHuber> oops just overwrote it with results from a -O2 build :/
14:04:06 <Cale> sorear: I can
14:04:29 <sorear> Funny, since I can access all the *other* pages on the site.
14:05:08 <KatieHuber> yeah at -O2 it gets inlined
14:05:28 <KatieHuber> completely vanishes from the profile
14:05:39 <Heffalump> and are things faster?
14:05:48 <KatieHuber> no idea :)
14:06:04 <sjw> KatieHuber: does having card twice work?
14:06:17 <sjw> (in the def of FacingCard)
14:06:19 <KatieHuber> I use random input so I need to implement in-program timing
14:06:40 <KatieHuber> yeah, they have to have the same type and occur within different cases of the same data, but it works
14:08:47 <KatieHuber> so, as I traverse a big long lazy list, what would be a good way to get an elements-per-second count or something?
14:09:49 <bos> KatieHuber: there isn't one, really
14:09:57 <KatieHuber> I'm currently doing putStr $ show $ filter interestingElements $ generateBigLongLazyList
14:10:20 <bos> you can cobble something together yourself, but that's about it
14:13:27 <eyeris> The Prelude documentation says that elem is usually written `x elem xs', but if I try that in a guard, I get a type mismatch error. Is infix syntax illegal in guards?
14:14:00 <Cale> x `elem` xs
14:14:11 <Cale> The backticks matter
14:14:16 <eyeris> ahh
14:17:16 <EvilTerran> KatieHuber, the "correct" way of doing it would be to use a Control.Concurrent.SampleVar and multiple threads, i think
14:19:37 <KatieHuber> whoa
14:22:34 <EvilTerran> you might be able to do something easier with a timer
14:22:53 <EvilTerran> anything of that sort involves weaving IO into your code, though
14:23:59 <kpreid> you can still start with the lazy list!
14:24:00 <EvilTerran> (as in, "if (a second's passed since the last update) then (update) else (process another item)"
14:24:15 <kpreid> you only need to weave IO or concurrency into the traversal operator
14:24:52 <EvilTerran> wait, do you mean you want this info while the thing's running (progress bar kinda thing), or just at the end? 'cos the latter's a bit easier
14:25:04 <kpreid> you could make it look just like mapM_
14:25:11 <kpreid> (except for being constrained to IO)
14:25:12 <EvilTerran> (as in, start timing, force everything you want timed, stop timing)
14:25:13 <KatieHuber> just at the end would be fine, but it needs to come out even with ctrl-c
14:25:22 <EvilTerran> exceptions \o/
14:25:51 <KatieHuber> 'cos there are a bunch of problems that I can't compute in time (and it seems unlikely I will be able to)
14:26:01 <KatieHuber> exponential problem and all that :/
14:31:37 <fasta> How is mv or moveFile called in the libraries for Unix?
14:32:29 <Zao> fasta: Some kind of rename?
14:33:03 <fasta> Zao: renameFile, thanks
14:34:02 <eyeris> Do optional function parameters exist in haskell?
14:34:09 <mrd> Maybe
14:34:16 <eyeris> ah!!
14:34:47 <eyeris> I was wracking my brain trying to figure out how to do with with pattern matching or guards :)
14:35:05 <wolverian> lists work too, if you want that kind of a thing
14:35:38 <mrd> haskell functions only accept one argument
14:36:57 <Zao> foo :: a -> b -> c applied to an a yields a function :: b -> c
14:37:48 <opqdonut> well f :: (a,b) -> c takes multiple arguments in the mathematical sense :)
14:38:29 <eyeris> If the haskell makers go to such lengths to implement the -> syntax to hide the currying, why does everyone want to point it out seemingly every chance they get?
14:38:45 <mrd> nobody's hiding the curry
14:39:11 <mrd> it's just so ubiquitous that the smell has permeated your senses
14:40:02 <eyeris> s/hide/automate/
14:40:20 <Botje> eyeris: because it allows you to do nice shortcuts.
14:40:33 <Botje> eg map (flip divMod 2) [1..10]
14:40:51 <Botje> in scheme you'd have to write something like map (lambda (x) (divMod x 2))
14:41:36 <eyeris> ahh
14:42:04 <sjanssen> eyeris: the -> syntax doesn't hide currying, it exposes it
14:42:41 <sorear> In Clean, you have types like Int Int -> Int.  Now *that* hides curry.
14:43:19 <eyeris> ok
14:43:25 <mrd> that is distinctly "unclean"
14:43:56 <fasta> Find f: (id::Integer->Integer) (f(3::Int))
14:44:08 <phobes> I'm not sure tupled notation would be so bad if you just had a ? placeholder that you could use for easy partial application
14:44:33 <phobes> something like   f a, b, ?, d
14:44:47 <sjanssen> fasta: could be fromIntegral
14:44:59 <fasta> sjanssen: thanks
14:45:11 <sjanssen> @type (id::Integer->Integer) (?f(3::Int))
14:45:13 <lambdabot> (?f::Int -> Integer) => Integer
14:45:36 <fasta> sjanssen: no, it can't.
14:46:15 <sjanssen> @type fromIntegarl :: Int -> Integer
14:46:17 <fasta> Never mind
14:46:17 <lambdabot> Not in scope: `fromIntegarl'
14:46:18 <EvilTerran> phobes, there's a proposal somewhere to allow you to miss out only some elements in a tuple, so (a,) or (,b) or whatever would work
14:46:29 <DRMacIver> phobes: I find that notation a bit annoying.
14:46:33 <mrd> named currying in general would be ok
14:47:05 <DRMacIver> phobes: Scala does something similar, and it works fine and isn't too ugly but somehow rubs me the wrong way. I think it's just a little too ad hoc.
14:47:25 <mrd> like for example, if the notation { a = ..., b = ..., ...} would be a function if you left out some fields
14:47:30 <mrd> i guess
14:53:22 <tcr> What's the nick of Neil Mitchell again?
14:53:31 <bos> ndm
14:53:44 <tcr> Not here, alright, thanks, bos
15:07:14 <phobes> DRMacIver:  I don't think it's too bad... it allows you to reverse paren associativity so you don't need to use compose as ubiquitously
15:07:36 <DRMacIver> I understand the appeal.
15:07:37 <phobes> DRMacIver:  I also think it's generally easier for the general populace to grok
15:07:42 <DRMacIver> It just annoys me for some reason. :)
15:07:47 <DRMacIver> Yes, that's true.
15:10:40 <sjanssen> the problem I have with ? is not knowing where the lambdas go
15:11:29 <DRMacIver> How do you mean?
15:11:39 <sjanssen> you can always attach them to the nearest function application, but you lose some power that way
15:11:45 <obsethryl> ok something nutty
15:11:47 <sjanssen> f(g(?, x))
15:12:03 <obsethryl> is there a place where somebody could contribute to web - oriented haskell?
15:12:18 <obsethryl> there are lots of links that are kind of in disarray from what i see
15:12:19 <sjanssen> f(\y -> g(y, x)) or \y -> f(g(y, x))
15:12:25 <obsethryl> what do you guys know about this
15:12:57 <sjanssen> you want to contribute to a project involved with web application programming?
15:13:35 <obsethryl> well i would like to know first  what has already been done, but the information related to this is kind of scarse
15:13:45 <obsethryl> so even for a simple thing i dont know where to look
15:14:06 <obsethryl> i was looking for an alternative to various web solutions i dont like :s
15:14:12 <ddarius> http://www.haskell.org/haskellwiki/Applications_and_libraries/Web_programming
15:14:13 <lambdabot> Title: Applications and libraries/Web programming - HaskellWiki, http://tinyurl.com/yrdc54
15:14:21 <obsethryl> ddarius: yeah i seen that
15:14:29 <obsethryl> is that it for now?
15:14:41 <sjanssen> obsethryl: HAppS seems to be the big contender
15:15:10 <obsethryl> sjanssen: ddarius: practically seeking people right?
15:16:43 <obsethryl> anyway i never thought of looking in haskell through web glasses up to this day
15:17:02 <obsethryl> might be more of an advantage in the end
15:17:04 <rcy> Hi.  I get the following error when running ghc from OpenBSD ports: Loading package base ... linking ... /usr/local/lib/ghc-6.2.2/HSbase_cbits.o: unknown symbol `__errno' \n ghc-6.2.2: unable to load package `base'
15:17:38 <sjanssen> obsethryl: I know that HAppS has several employees that hang out in this channel
15:17:47 <ddarius> rcy: Why are you even bothering with 6.2.2?
15:18:14 <obsethryl> sjanssen: i have added this into my todo list, i will get informed better about it
15:18:29 <obsethryl> thanks for the start
15:18:38 <obsethryl> really this is something that just hit me :)
15:18:39 <rcy> ddarius: well its what is in ports in the latest openbsd.  alternatively I could compile the latest from source.  im just starting out with haskell, I didnt think it would make a huge difference at this point
15:18:57 <Botje> rcy: it does
15:19:28 <rcy> ok, ill try to get the latest up and running.
15:19:53 <ddarius> rcy: You should be able to just download a binary.
15:20:03 <Taejo> is ghc-6.6 latest? it's what's in ubuntu feisty
15:20:08 <sjanssen> openbsd doesn't have 6.4 or 6.6?
15:20:10 <sjanssen> dons: is that right?
15:20:23 <sjanssen> Taejo: 6.6.1 is the latest stable version
15:20:36 <ddarius> http://www.haskell.org/ghc/distribution_packages.html#netbsd
15:20:37 <lambdabot> Title: GHC: Distribution packages
15:20:52 <ddarius> 6.8 is about to be released
15:21:01 <dons> sjanssen: it has 6.6 and 6.4 (and 6.8 works too)
15:21:06 <dons> 6.6.1 is in the ports tree
15:21:13 <ddarius> As it should be.
15:21:20 <dons> rcy: you need an updated ports tree
15:21:31 <dons> ghc 6.6.1 that (grab a snapshot, perhaps)
15:22:50 <rcy> dons: yeah, ill figure something out... thanks everyone
15:24:32 <dons> rcy: i'm using amd64/openbsd ghc 6.6.1 binary from the packages snapshot
15:26:16 <tehgeekmeister> what's fmap used for?
15:26:38 <dons> mapping over functors
15:27:18 <tehgeekmeister> gah, i probably should try to figure out what functors are, first, then.  do i need to grok monads pretty well first?
15:28:38 <bos> no.
15:28:38 <tehgeekmeister> oh, actually, if i remember right, a functor maps arrows in one category to arrows in another, correct?
15:28:58 <DRMacIver> Yes.
15:29:32 <rcy> dons: did you just point your PKG_PATH to the snapshot ftp dir and pkg_add it?  i havent mixed packages from different releases before
15:29:38 <tehgeekmeister> and would i be right in guessing that arrows in haskell are essentially just functions?
15:29:56 <DRMacIver> Yes, although confusingly there's somethign else called an arrow. :)
15:30:05 <tehgeekmeister> that is confusing.
15:30:12 <sorear> tehgeekmeister: beware of s
15:31:07 <tehgeekmeister> sorear: ?  i'm not sure exactly what i'm meant to get out of that.  i figured it was generally a good idea to beware of them.
15:32:01 <tehgeekmeister> (bottom values, that is.  and how'd you type that symbol?)
15:32:11 <sorear> tehgeekmeister: Hask fails to be a category due to subtle strictness properties of (.).  In particular, there is no identity arrow as required by CT, because undefined . id = const undefined /= undefined
15:32:22 <sorear> tehgeekmeister: Control-Shift-22A5
15:32:52 <tehgeekmeister> sorear: i have a mac.
15:32:58 <tehgeekmeister> sorear: no such luck, i suppose.
15:33:18 <KatieHuber> you can get it in "special characters" on the mac, but there's no shortcut for it
15:33:27 <KatieHuber> if fax was here he'd tell you how to make a shortcut :)
15:33:31 <sorear> there is no standard keyboard shortcut for this even among linux terminal emulators
15:33:46 <sorear> so the fact that you have a mac is, sadly, irrelevant
15:34:23 <sorear> besides, you asked what *I* typed, not what *you* should type :P
15:34:32 <tehgeekmeister> fine, fine.
15:34:33 <tehgeekmeister> i did.
15:34:54 <tehgeekmeister> hanyway, basically what that means is that i can think of fmap as map for functors, and excepting bot, i'll be fine?
15:35:12 <sorear> yeah
15:35:48 <DRMacIver> It's even literally true that fmap is map for Functors. It's just that Haskell Functors aren't category theory ones. :)
15:35:52 <KatieHuber> ah neat you can use the "unicode hex input" keyboard on the mac to have opt-22a5 type bottom: 
15:36:28 <tehgeekmeister> KatieHuber: nice!
15:36:44 <dons> rcy: oh, i wouldn't mix packages from different releases
15:36:48 <dons> probably wouldn't work
15:37:00 <KatieHuber> now all ya gotta do is memorize the unicode codes for each character you want to type :p
15:37:13 <KatieHuber> I think fax's shortcut software is probably more useful ;)
15:37:27 <tehgeekmeister> i just asked in ##mac if there's a way to remap the special chars available via option and option + shift
15:37:45 <ddarius> GHC requires(required?) the compiler versions to be exactly the same so it quite definitely wouldn't work.
15:39:20 <sorear> I've already memorized the unicode hex codes!
15:39:44 <ddarius> sorear: All of them?
15:40:06 <sorear> *thinks* Yes.
15:40:28 <ddarius> Have you also memorized the mapping between them and glyphs?
15:40:29 <LoganCapaldo> Do you need to memorize all of them? Don't you just need to memorize which ones you can't use?
15:40:44 <sorear> aww, you got it :(
15:40:45 <sorear> :)
15:41:22 <LoganCapaldo> unicode isn't contiguous right?
15:41:28 <bos> right
15:42:08 <bos> unicode has some wonderful character names.
15:42:37 <bos> for example http://www.fileformat.info/info/unicode/char/2c22/index.htm
15:42:38 <lambdabot> Title: Unicode Character 'GLAGOLITIC CAPITAL LETTER SPIDERY HA' (U+2C22)
15:43:58 <bos> oops
15:46:38 <pgavin> so I have a fromJust in my code somewhere that's getting called with nothing.. is there an easy way with GHC to find out what line it's happening at?
15:47:53 <LoganCapaldo> just don't use fromJust :)
15:48:44 <ddarius> pgavin: You can compile with profiling and pass the runtime option -xc and you will get a stack trace like thing.
15:49:34 <pgavin> ddarius: cool, thanks
15:49:52 <pgavin> LoganCapaldo: well, it's not ever supposed to recieve Nothing :)
15:50:02 <pgavin> err, receive even
15:51:36 <LoganCapaldo> if it can''t ever receive nothing why are you using Maybe at all?
15:52:24 <pgavin> LoganCapaldo: I'll better be able to answer that when I figure out where it happens, but you have a good point
15:52:36 <phobes> sjanssen:  nearest lambda might have problems in expressions like 1 + 2 + ? + 4... I think nearest enclosing parens might be better
15:53:09 <pgavin> LoganCapaldo: I've probably hung on to the maybe after I already know its not Nothing
15:53:16 <pgavin> using isJust
15:53:56 <phobes> sjanssen:  Of course then you probably want to make exception for when there aren't parens around ...
15:54:39 <phobes> (or you require them)
15:56:28 <phobes> Of course if you do it at parens then you'd start to see cruft like this:     cos ? + sin ((pi * ?) ?)
15:57:09 <phobes> well, that doesn't make sense actually  :)
15:57:27 <phobes> Suffice it to say that I agree with you that there are issues :)
15:57:29 <fasta> How can a function f have type <short type> in module B (where it is defined) and <long type> in another module importing B?
15:58:35 <LoganCapaldo> fasta, example?
16:02:33 <fasta> Never mind
16:18:49 <dons> http://programming.reddit.com/info/2twv9/comments
16:18:50 <lambdabot> Title: Haskell in the Hallway: Simon Peyton Jones talks about FP :: video (reddit.com)
16:18:51 <dons> video rules
16:19:02 <Pseudonym> Oh, that's the one with the diagram?
16:19:52 <dons> nope
16:20:02 <dons> someone sneaked an interview in at OSCON
16:24:15 <sjw> hmm, that isn't a small file
16:25:37 <Pseudonym> Last time I was at OSCON, Microsoft was nowhere to be seen.
16:36:27 <shapr> Hi! What's going on?
16:36:27 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
16:37:11 <Pseudonym> Stunned silence, apparently.
16:37:14 <sjw> dons: lambdabot should really msg that ...
16:37:17 <Pseudonym> Or everyone is watching the SPJ video.
16:37:57 <phobes> I just see a red X in box when I try to view it
16:38:00 <phobes> What's it about?
16:38:04 <Pseudonym> http://port25.technet.com/videos/haskell.mp4
16:38:09 <Pseudonym> Try the direct link.
16:39:15 <phobes> Nope
16:49:10 <psnively_> SPJ is always so fun to watch/listen to.
16:49:43 <phobes> What is the jist of that video?
16:50:02 <phobes> side-effects are bad, mmm kay
16:51:37 <psnively_> What else is there to say, really?
16:52:03 <tehgeekmeister> http://www.serpentine.com/blog/2007/09/25/what-the-heck-is-a-wide-finder-anyway/ <== what is M in the first haskell snippet here, (and, come to think of it, what's this syntax that looks like methods in an OO language, too?)
16:52:05 <lambdabot> Title: teideal glic deisbhalach  Blog Archive  What the heck is a Wide Finder, anyw ..., http://tinyurl.com/2mcz47
16:52:14 <sjw> bbk
16:52:57 <sjanssen> tehgeekmeister: M stands for Monad
16:53:15 <sjanssen> tehgeekmeister: which part looks like methods to you?
16:53:16 <phobes> It's just a module shorthand
16:53:32 <mauke> M looks like Data.Map to me
16:53:38 <tehgeekmeister> sjanssen: M.empty, LB.readfile
16:53:42 <sjanssen> oh
16:53:53 <phobes> M. and LB. are shorthands for module names
16:53:59 <sjanssen> that M is a synonym for Data.Map -- qualified module access
16:54:11 <tehgeekmeister> okay
16:54:24 <phobes> He presumably has those defined at the top :)
16:54:45 <tehgeekmeister> yeh, i would've gotten it if i saw the imports
16:55:14 <tehgeekmeister> which module is LB shorthand for, then?
16:55:23 <Pseudonym> I'm guessing lazy bytestring.
16:55:27 <sjanssen> tehgeekmeister: Data.ByteString.Char8.Lazy, probably
16:55:38 <sjanssen> erm, Data.ByteString.Lazy.Char8
16:55:42 <tehgeekmeister> hokay
16:55:43 <tehgeekmeister> thanks.
17:01:54 <bos> sjanssen is correct.
17:02:04 <bos> i just didn't bother including the wad of imports.
17:07:29 <dancor> easiest way to split file path into directory vs filename
17:09:10 <tehgeekmeister> ?src count
17:09:10 <lambdabot> Source not found. Take a stress pill and think things over.
17:10:35 <tehgeekmeister> bos: good to know, what's count in this context, if you don't mind?  i don't find any definitions of count in hoogle that seem appropriate
17:11:34 <bos> tehgeekmeister: it's a locally defined function
17:11:35 <mauke> er. it's defined right there
17:11:42 <tehgeekmeister> gah!
17:11:43 <tehgeekmeister> it is.
17:11:48 <tehgeekmeister> i need to look better next time.
17:11:51 <tehgeekmeister> sorry.
17:12:15 <tehgeekmeister> i didn't notice the second def in the where clause
17:21:07 <ihope> So, I guess I want to use Haskell to run a program and grab its stdin, stdout and stderr.
17:25:20 <LoganCapaldo> @hoogle popen
17:25:20 <lambdabot> No matches found
17:25:52 <LoganCapaldo> @hoogle String -> [IO Handle]
17:25:52 <lambdabot> No matches, try a more general search
17:26:09 <LoganCapaldo> @hoogle String -> (IO Handle, IO Handle, IO Handle)
17:26:09 <lambdabot> No matches, try a more general search
17:26:12 <sorear> LoganCapaldo: you seriously expected haskell to use a familiar name?
17:26:18 <sorear> ewww, IO inside (,,)
17:26:31 <LoganCapaldo> sorear: not seriously
17:26:39 <sorear> @ty System.Cmd.runInteractiveProcess
17:26:41 <lambdabot> Not in scope: `System.Cmd.runInteractiveProcess'
17:26:44 <sorear> @ty System.Process.runInteractiveProcess
17:26:45 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, System.Process.Internals.ProcessHandle)
17:26:49 <ihope> My.
17:26:50 <LoganCapaldo> I'm pretty sure I remmebr seeing it and thinking how utterly unlike popen it's name was
17:26:55 <ihope> @docs System.Process
17:26:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
17:27:58 <shapr> @yow !
17:27:58 <lambdabot> You should all JUMP UP AND DOWN for TWO HOURS while I decide on a NEW CAREER!!
17:28:06 <shapr> I like this quote.
17:28:14 <shapr> Aww, I missed whitenoise.
17:28:51 <dancor> how to apply a function to the elements of a tuple
17:29:04 <LoganCapaldo> @type uncurry
17:29:06 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
17:29:25 <LoganCapaldo> @type first
17:29:27 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
17:29:39 <LoganCapaldo> @type (&&&)
17:29:41 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:29:50 <LoganCapaldo> that's not it
17:29:54 <LoganCapaldo> @type (***)
17:29:56 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:30:53 <LoganCapaldo> > uncurry (+) (2,3)
17:30:54 <lambdabot> Terminated
17:31:02 <LoganCapaldo> terminated?
17:31:13 <mauke> > uncurry (+) (2, 3)
17:31:14 <lambdabot> Terminated
17:31:19 <mauke> > ()
17:31:21 <lambdabot>  ()
17:31:27 <mauke> ok then!
17:32:34 <LoganCapaldo> > (+) 2 3
17:32:35 <lambdabot> Terminated
17:32:40 <Lemmih> They redefined (+).
17:32:45 <LoganCapaldo> oh
17:32:47 <dancor> i'm trying to get   map2 f (a, b) = (f a, f b)
17:32:50 <dancor> good old state
17:32:52 <Lemmih> > 2 Prelude.+ 3
17:32:53 <lambdabot>  5
17:33:05 <LoganCapaldo> @type join (***)
17:33:07 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
17:33:33 <LoganCapaldo> > let map2 = join (***) in map2 (* 2) (3, 7)
17:33:35 <lambdabot>  (6,14)
17:33:51 <mauke> > (L.+)
17:33:53 <lambdabot>  <Integer -> Integer -> Integer>
17:34:15 <mauke> > (L.+) 2 2
17:34:17 <lambdabot>  4
17:35:21 <LoganCapaldo> @type let map2 f = first f >>> second f in map2
17:35:23 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
17:35:40 <LoganCapaldo> arrow combinators are fun!
17:36:22 <mauke> @let (+) x = (Prelude.+) x
17:36:22 <lambdabot> <local>:7:0:     Equations for `+' have different numbers of arguments       ...
17:36:33 <LoganCapaldo> @undefine
17:36:35 <lambdabot> Undefined.
17:36:53 <LoganCapaldo> > (+) 2 3
17:36:54 <lambdabot>  5
17:37:05 * LoganCapaldo uses bazooka to kill mosquito
17:37:57 <mauke> > 4 + 0
17:37:58 <lambdabot> Terminated
17:38:05 <LoganCapaldo> dammit
17:38:18 <mauke> > 4 + 0
17:38:19 <lambdabot>  4
17:38:27 <LoganCapaldo> HUH
17:39:41 <LoganCapaldo> > 4 + 0
17:39:43 <lambdabot>  4
17:41:33 <sorear> > 4 + 0
17:41:34 <lambdabot>  4
17:41:49 <sorear> > 2
17:41:50 <lambdabot>  2
17:41:51 <sorear> > 2
17:41:52 <lambdabot>  2
17:41:53 <sorear> > 2
17:41:54 <lambdabot>  2
17:48:56 <Choko_> fuck her
17:49:02 <olliej> ?
17:49:10 <Choko_> jeg vil have din krop, allbery_b
17:49:17 <Choko_> jeg vil have din krop, olliej
17:49:20 <Choko_> mente jeg
17:49:59 <allbery_b> gesundheit
17:50:19 <Tac-Tics> allbery_b: I never knew how to spell that word
17:50:22 <Tac-Tics> but now I know
17:50:32 <LoganCapaldo> it's pretty phoenitic
17:50:47 <LoganCapaldo> err phonetic
17:50:53 <LoganCapaldo> the irony
17:50:58 <LoganCapaldo> oh the irony
17:51:06 <allbery_b> heh
17:58:27 <Tac-Tics> FUNCTIONS!!!
17:58:31 <Tac-Tics> /bored
17:58:49 <EvilRanter> record systems!
17:58:57 <EvilRanter> monomorphism restriction!
17:58:59 <EvilRanter> fail!
17:59:08 <hpaste>  dancor pasted "how to properly wait for io to finish?" at http://hpaste.org/2957
17:59:16 <allbery_b> are you trying to summon Cale or something?
17:59:43 <EvilRanter> trying to prompt conversation by *someone*, anyway.
18:00:10 <reffie> dancor maybe you need an hFlush?
18:00:12 <Tac-Tics> EvilRanter: Usually this one does it....
18:00:16 <EvilRanter> dancor, you can force reading by forcing the length of the string, i think
18:00:24 <Tac-Tics> Naive Set theory is more elegant than ZFC!
18:00:31 <EvilRanter> dancor, or by using the non-lazy IO
18:00:44 <EvilRanter> which is probably more appropriate in this case
18:00:51 <Tac-Tics> Strict typing adds nothing to programming
18:01:22 <Pseudonym> Why aren't we all programming in Ada?
18:01:40 * EvilRanter quite likes classy set theory as a concept
18:02:03 <EvilRanter> temporal instability!
18:02:15 <dancor> is the problem that i need some strictness before the hPutStr
18:02:25 <Pseudonym> I prefer bedraggled set theory, personally.
18:02:33 <dancor> or can this be done properly with just something after the hPutStr
18:02:42 <EvilRanter> dancor, the problem is that hGetContents is broken.
18:02:50 <sjw> worldweary set theory is my cup of tea
18:02:59 <dobblego> dancor, are you reading a file, then closing the file handle and expecting the list to still be there?
18:03:21 <dancor> dobblego: well i'm not explicitly closing the file
18:03:25 <EvilRanter> dobblego, for "file", read "child process stdout", but it's something to that effect, yes
18:03:28 <sjanssen> I think dancor is using hGetContents correctly
18:03:34 <dancor> which i've heard you aren't supposed to do with hGetContents
18:03:36 <dobblego> ah ok
18:04:02 <sjanssen> dancor: try an hFlush at the end, as has been suggested
18:04:02 <EvilRanter> sjanssen, i'm not sure if it works nicely with pipes, though
18:04:16 <EvilRanter> I may be mistaken, mind
18:04:30 <dancor> flush the pipe after the hPutStr?
18:04:36 <sjanssen> EvilRanter: the hPutStr is demanding the output
18:04:44 <sjanssen> dancor: flush the file handle
18:04:56 <sjanssen> dancor: hFlush h -- to be exact
18:05:16 <EvilRanter> oh right...
18:05:33 <dancor> ok that seems to work
18:05:56 <EvilRanter> don't the parameters to hPutStr get forced at the hPutStr?
18:06:07 <sjanssen> yes
18:06:09 <dancor> so the hGetContents and the hPutStr just set up the lazy action of writing to the file
18:06:27 <dancor> i guess i don't understand why things aren't flushed at the end
18:06:32 <dancor> automagically
18:06:36 <sjanssen> dancor: GHC buffers the output -- you need to flush the buffers before you exit
18:06:36 <sjw> hSetBuffering hdl NoBuffering
18:06:51 <sjanssen> dancor: this is a standard programming practice
18:06:52 <EvilRanter> oh, i see. i was thinking flushing it was demanding the output. i missed your line earlier.
18:06:55 <sjw> ... will stop GHC buffering
18:07:01 <Tac-Tics> is runInteractiveCommand something like popen?
18:07:06 * EvilRanter goes to bed
18:07:46 <sjw> dancor: is there a newline at the end of the hPutStr?
18:07:48 <EvilRanter> hm
18:07:49 <sorear> Tac-Tics: read up
18:08:03 <sorear> 'yes' would be shorter, hmm
18:08:25 <dancor> sjw: there is a newline at the end of the resulting file
18:08:35 <dancor> sjw: the string it is printing there does end in a newline
18:08:45 <dancor> (unlines does that)
18:08:51 <sjanssen> sjw: IIRC, the default mode for files is block buffering, not line buffering
18:09:08 <sjw> ok
18:09:26 <sjw> I guess you want nobuffering then
18:11:06 <dancor> am i doing anything else poorly in that program
18:11:08 <omniscientIdiot> or just flush it
18:11:08 <dancor> just curious
18:11:37 <sjanssen> dancor: there is the slight risk that the stderr pipe will fill up, making your program stall
18:11:40 <omniscientIdiot> dancor: looks good, you might put some of the small one-off functions in where clauses of the functions they're used in.
18:12:08 <sjanssen> dancor: also, I'd consider doing the directory walking in Haskell rather than calling find
18:12:28 <dancor> sjanssen: really?
18:12:43 <dancor> it's so concise
18:13:16 <dancor> unless there is like a haskell find build-in :)
18:13:36 <sjanssen> the Haskell equivalent shouldn't be too long, and it's 100% more portable
18:28:07 <LoganCapaldo>  100% more portable? Why not 200% more portable?
18:28:11 <LoganCapaldo> gah
18:28:37 <sjanssen> infinitely portable?
18:29:00 <LoganCapaldo> sorry pet peeve
18:29:12 <tehgeekmeister> what precedence does function application have?
18:29:27 <LoganCapaldo> it binds tightest of all
18:29:28 <Tac-Tics> hmm
18:29:45 <LoganCapaldo> barring parens
18:29:45 <mauke> ITS POWER IS MAXIMUM
18:29:55 <Tac-Tics> I have gtk2hs installed, but I don't have the Graphics.UI.Gtk.OpenGL module....
18:29:58 <Tac-Tics> how does that happen?
18:30:04 <tehgeekmeister> so f g x is equivalent to f (g x)?
18:30:09 <LoganCapaldo> no
18:30:14 <sjanssen> tehgeekmeister: (f g) x
18:30:15 <LoganCapaldo> ((f g) x)
18:30:33 <LoganCapaldo> it's left associative
18:30:38 <tehgeekmeister> okay.
18:30:41 <tehgeekmeister> that's sensible.
18:31:12 <LoganCapaldo> the other way you'd have to parenify things like f 1 2
18:31:32 <tehgeekmeister> oh, yes, currying.
18:31:36 <tehgeekmeister> thanks.
18:31:38 <Tac-Tics> thank god for Ubuntu's Synaptic Package manager
18:31:39 <LoganCapaldo> or get strange erros about how 1 isn't a function
18:31:44 <LoganCapaldo> > 1 2
18:31:45 <lambdabot>   add an instance declaration for (Num (t -> a))
18:31:45 <lambdabot>     In the expression: 1 2
18:31:45 <lambdabot>  ...
18:31:52 <LoganCapaldo> or rather
18:32:00 <LoganCapaldo> how a function isn't a num
18:32:05 <LoganCapaldo> heh
18:33:20 <mauke> *Main> 1 2
18:33:20 <mauke> 1
18:33:33 <mauke> problem solved!
18:34:46 <LoganCapaldo> not 2?
18:35:29 <LoganCapaldo> instance Num a => Num (a -> a) where fromInteger n = (n *) :)
18:36:00 <sarehu> ugh
18:36:36 <phobes> 1 f x = f x.    2 f x = f f x.    1 2 = 2.
18:36:38 <sarehu> give me instance Num a => Num (a -> a) where fromInteger n = const n or give me death.
18:37:25 <sorear> sarehu: not (*)?
18:37:34 <sorear> sarehu: 5 x would typecheck that way
18:37:49 <LoganCapaldo> that's what I said
18:37:53 <sorear> oh, that was mentioned
18:38:27 <mauke> instance (Num a, Applicative f, Eq (f a), Show (f a)) => Num (f a) where fromInteger = pure . fromInteger
18:38:27 * sorear reads a SML wiki and notices with amusement (notice that 'a t, return, and >>= form a monad!)
18:44:18 <wli> sarehu: You mean instance Num t => Num (t' -> t) where fromInteger n = const n?
18:45:54 <sarehu> wli: maybe... or how about const (fromInteger n)
18:46:13 <wli> sarehu: oh yeah
18:46:26 <mauke> (note that pure = const here)
18:48:58 <tehgeekmeister> in this line: (fromIntegral . fileSize) `fmap` getFileStatus path (from here: http://www.serpentine.com/blog/2007/09/25/what-the-heck-is-a-wide-finder-anyway/), fmap is, in essence, getting the FileStatus value out of the IO monad, no?
18:49:00 <lambdabot> http://tinyurl.com/yt53vs
18:49:40 <sjanssen> @type fmap
18:49:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:50:11 <wli> It used to be called "map" until H98 :(
18:50:12 <sjanssen> so, given that f is IO: (a -> b) -> IO a -> IO b
18:50:56 <sjanssen> we can read that as "given a function from a to b, and an IO action that produces an a, yield an IO action the produces a b"
18:51:03 <sclv> is there a nice combinator way to express the following function:
18:51:04 <sclv> tcon [a,b,c] [a',b',c'] = [a++a',b++b',c++c']
18:51:16 <sjanssen> "that produces a b"
18:51:21 <sjanssen> sclv: zipWith (++)
18:51:27 <SamB_XP> sclv: what he said
18:51:30 <SamB_XP> he's too fast for me
18:51:54 <omniscientIdiot> @type zipWith (++)
18:51:56 <lambdabot> forall a. [[a]] -> [[a]] -> [[a]]
18:52:24 <SamB_XP> sclv: with the added bonus that it works on lists of all sizes, not just 3 ;-P
18:52:28 <tehgeekmeister> oh!  i wasn't reading the type signature right.
18:52:37 <sclv> oh duh -- i stop messing with haskell for a week and i forget everything!
18:52:59 <LoganCapaldo> use it or loose it
18:52:59 <tehgeekmeister> i read it as (a -> b) -> (f a -> f b)
18:53:12 <tehgeekmeister> -> would be left associative, too, wouldn't it?
18:53:27 <SamB_XP> If I could avoid it for a month I'd still remember that ;-P
18:53:29 <omniscientIdiot> tehgeekmeister: that's the same.
18:53:41 <SamB_XP> (but that's a BIG if ;-)
18:53:43 <mauke> tehgeekmeister: no, -> is right associative
18:53:43 <phobes> currying strikes again
18:53:45 <sjanssen> tehgeekmeister: (a -> b) -> f a -> f b is the same as (a -> b) -> (f a -> f b)
18:54:00 <sclv> SamB: well, i just started picking it up, so my brain isn't permanently altered yet.
18:54:02 <SamB_XP> I suspect the only way to avoid it would be to be marrooned on the ocean
18:54:09 <SamB_XP> sclv: right ;-)
18:54:54 <SamB_XP> they do say that the amount of time it takes to forget something is proportional to how long you learned it for or something like that
18:55:25 <phobes> so if you did tupled style, would map deserve to be   (a->b) -> (f a -> f b),   or (a->b), fa -> f b?
18:55:53 <sjanssen> phobes: hard to say :)
18:56:08 <sjanssen> this is why we program in the Curry style ;)
18:56:17 <phobes> hehe ya
18:56:20 <ihope__> How easy is Haskell for real-time computing?
18:56:35 <SamB_XP> ihope__: you gots to write a compiler
18:56:47 <LoganCapaldo> Like taking candy from a baby
18:56:53 <ihope__> I would have to write a compiler for Haskell?
18:56:56 <ihope__> Hmm.
18:57:04 <phobes> Like taking candy from a baby without candy
18:57:10 <LoganCapaldo> An activity, which in addition to real time computing I have never done
18:57:10 <sjanssen> @google real time haskell
18:57:14 <lambdabot> http://mikeburrell.wordpress.com/2007/02/01/real-time-haskell/
18:57:14 <lambdabot> Title: Real-time Haskell?  Closure Sale
18:57:29 <tehgeekmeister> i'm utterly lost as regards fmap, still.  I'm not even sure i understand what arguments it takes yet.
18:57:48 <tehgeekmeister> i'm sure it takes at least a function
18:57:55 <tehgeekmeister> and returns a new function
18:58:10 <phobes> it's a generalization of map
18:58:14 <omniscientIdiot> tehgeekmeister: that's right
18:58:37 <omniscientIdiot> @type fmap
18:58:38 <tehgeekmeister> i think the issue is that i don't understand all the ins and outs of type signatures yet
18:58:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:58:54 <phobes> map 'maps' a function over a list.   fmap 'maps' a function over a more general data structure
18:58:58 <omniscientIdiot> @type fmap (+1)
18:59:01 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
18:59:03 <sjanssen> tehgeekmeister: are you comfortable with do notation?
18:59:08 <omniscientIdiot> @type (fmap (+1)) [1..5]
18:59:10 <lambdabot> forall a. (Num a, Enum a) => [a]
18:59:13 <tehgeekmeister> yes
18:59:14 <wli> It did not come about as a generalization of map; Functor's method (now called fmap) was originally called "map" and there was no specialized list function.
18:59:16 <sclv> hmm okay and if I want to do the same thing with tuples?
18:59:42 <sclv> i.e. tcon (a,b,c) (a',b',c') = (a++a',b++b',c++c')
18:59:46 <sjanssen> tehgeekmeister: you can write IO's fmap as: fmap f mx = do x <- mx; return (f x)
18:59:55 <phobes> wli:  does haskell's map predate the list map in lisp?
19:00:10 <wli> This state of affairs was too right and beautiful; enter H98.
19:00:27 <LoganCapaldo> oh is it still bash H98 week?
19:00:37 <SamB_XP> LoganCapaldo: it's been that all year
19:00:37 <wli> LoganCapaldo: Absolutely.
19:00:44 <phobes> wli:  I agree it seems silly to rename the more general function just to introduce a specialized version that does the same thing on lists
19:01:12 <sjanssen> wli has been complaining about this every few hours, it seems :)
19:01:17 <LoganCapaldo> SamB_XP: yeah seems more often the past few days though
19:01:17 <phobes> yes :)
19:01:44 <SamB_XP> LoganCapaldo: so?
19:01:47 <tehgeekmeister> hmm, well, as a newbie, it made my life a lot easier.  i already understood map as being list specific, if map had been what fmap now is when i started learning haskell, i may not have put enough effort in to stick with it at all.
19:01:48 <sclv> no simple combinators for zipping over tuples, right?
19:01:55 <SamB_XP> I will now begin complaining
19:01:57 <LoganCapaldo> so, that's why I chose "week" as my time unit
19:01:57 <SamB_XP> MR!
19:02:01 <wli> sjanssen: Nah, I was complaining about (++) getting castrated from the MonadPlus method and that was 16 hours ago or so.
19:02:21 <ihope__> sclv: aren't there?
19:02:22 <LoganCapaldo> sclv: zipping over tuples?
19:02:31 <SamB_XP> MonadZero!
19:02:50 <ihope__> ihope__: as in (a -> b -> c) -> [(a,b)] -> [c]?
19:03:24 * dmwit thinks of four or five things that could reasonably called "zipping over tuples"
19:03:28 <wli> tehgeekmeister: They need to use Helium or some such for newbies.
19:03:36 <sclv> i.e. to write \(a,b,c) (d,e,f,) -> (a+d,b+e,c+f)
19:03:51 <LoganCapaldo> why would you use tuples for that?
19:03:52 <dmwit> :t zipWith
19:03:55 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
19:04:14 <dmwit> > zipWith (+) [1,2,3] [4,10,69]
19:04:15 <lambdabot>  [5,12,72]
19:04:18 <sclv> i need tuples because a b and c are all different
19:04:22 <SamB_XP> we need a helpful type-hinter layer that aids in interpretation of type errors
19:04:30 <omniscientIdiot> @pl \f -> map (\(x,y) -> f x y)
19:04:34 <lambdabot> map . (`ap` snd) . (. fst)
19:04:35 <LoganCapaldo> but you're applying the same function to all of them?
19:04:37 <mauke> sclv: then you can't apply the same function to all of them
19:04:41 <mauke> haha
19:04:52 <sclv> i can if they're lists and i'm concating them
19:05:00 * omniscientIdiot blinks
19:05:01 <mauke> no, you can't
19:05:03 <tehgeekmeister> wli: i've never used helium yet.  started with hugs, cos the book i was using recommended it, ghci since then because it seemed a bit more standard.
19:05:30 <mauke> > (\f -> (f "a" "b", f [1] [2])) (++)
19:05:30 <lambdabot>   add an instance declaration for (Num Char)
19:05:30 <lambdabot>     In the expression: 2
19:05:40 <sclv> ok, i get it. the types constrict me to writing it explicitly.
19:05:50 <wli> tehgeekmeister: AIUI Helium simplifies the language and is not just an alternate implementation.
19:06:32 <tehgeekmeister> sjanssen: as far as i can see, that'd still return a value in the IO monad, which doesn't make sense in the context of the line i'm trying to make sense of.
19:06:37 <wli> tehgeekmeister: It's meant to help students like yourself, making compromises like what you mentioned to help them along.
19:06:44 <sjanssen> tehgeekmeister: which line?
19:07:05 <tehgeekmeister> (fromIntegral . fileSize) $ getFileStatus path
19:07:22 <sjanssen> I assume fmap is at the beginning there?
19:07:29 <tehgeekmeister> gah
19:07:30 <sjanssen> fmap (fromIntegral . fileSize) $ getFileStatus path
19:07:31 <tehgeekmeister> !!!
19:07:32 <tehgeekmeister> wrong line
19:07:32 <tehgeekmeister> sorry
19:07:47 <tehgeekmeister> (fromIntegral . fileSize) `fmap` getFileStatus path
19:07:53 <sjanssen> okay
19:08:11 <mauke> would you feel better with `liftM` instead of `fmap`?
19:08:24 <sjanssen> say (fromIntegral . fileSize) :: ByteString -> Int
19:08:32 <omniscientIdiot> (fmap (f :: a -> b) (x :: f a)) :: f b
19:08:44 <tehgeekmeister> mauke: perhaps?  i'm not horribly comfortable with liftM yet.  i've only read about it, i've never used it yet.
19:08:47 <sjanssen> getFileStatus path :: IO FileStatus
19:08:57 <mauke> @src liftM
19:08:57 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:09:00 <tehgeekmeister> this is the first time i've tried to read anything but contrived examples in haskell
19:09:01 * wli explodes in a puff of Haskell 1.4 revanchism.
19:09:08 <omniscientIdiot> fmap and liftM are the same function, just different names
19:09:09 <mauke> now inline that into your example
19:09:15 <sjanssen> and fmap :: (a -> b) -> (IO a -> IO b)
19:09:30 * omniscientIdiot sweeps away the pieces of wli
19:09:56 <sjanssen> fmap (fromIntegral . fileSize) :: IO FileStatus -> IO Int
19:09:58 <wli> :t liftM
19:10:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:10:01 <wli> :t fmap
19:10:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:10:14 <tehgeekmeister> that helps!
19:10:16 <sjanssen> fmap (fromIntegral . fileSize) (getFileStatus f) :: IO Int
19:10:42 <wli> (fmap and liftM are distinguished by their types)
19:10:52 <SamB_XP> omniscientIdiot: or would be if only we had Functor as a superclass of Monad...
19:11:02 <mauke> :t fmap `asTypeOf` liftM
19:11:04 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b) -> f a -> f b
19:11:19 <sclv> :t asTypeOf
19:11:20 <lambdabot> forall a. a -> a -> a
19:11:26 <mauke> @src asTypeOf
19:11:27 <lambdabot> asTypeOf = const
19:12:00 <SamB_XP> sclv: it's just a way to tell the typechecker "these two things should have the same type". Oh, and get the first of the two back ;-)
19:12:00 <wli> class Functor m => Monad m where { unit :: t -> m t ; join :: m (m t) -> m t } anyone? =)
19:12:04 <phobes> What would the overlap problem be with making all Monads subclass Functor?
19:12:21 <sjanssen> phobes: there is no overlap problem
19:12:29 <phobes> So why isn't it done?
19:12:43 <SamB_XP> we... don't know?
19:12:47 <phobes> hmm
19:12:50 <sjanssen> some people whine about the extra boilerplate of "instance Functor M where fmap f x = x >>= return . f"
19:12:52 <LoganCapaldo> its a mystery
19:12:57 <sjanssen> those people are stupid and wrong
19:13:01 <mauke> sjanssen: too complicated
19:13:12 <mauke> sjanssen: instance Functor M where fmap = liftM
19:13:13 <SamB_XP> sjanssen: I will continue to complain about this
19:13:24 <SamB_XP> regardless of the superclassness of Functor
19:13:32 <dmwit> SamB_XP: That's fine, you are just stupid and wrong. ;-)
19:13:37 <sjanssen> mauke: liftM would not exist if Functor was a superclass of Monad ;)
19:13:46 <mauke> it should
19:13:55 <sjanssen> mauke: of course we can provide it in a library if people demand it
19:14:05 <hpaste>  omniscientIdiot pasted "liftM" at http://hpaste.org/2958
19:14:06 <SamB_XP> until someone devises a scheme that lets you not actually define the Functor instance explicitly that isn't horribly annoying
19:14:06 <sjanssen> I'd probably call it fmapViaMonad
19:14:10 <wli> I've at least gone as far to crack open the ghc sources and scratch my head at how the heck to change the compiler intrinsics to be decent.
19:14:11 <mauke> I need it to implement Functor!
19:14:39 <SamB_XP> sjanssen: I think liftM = fmap would be defined
19:14:42 <sjanssen> SamB_XP: you're stupid and wrong :)
19:14:52 <SamB_XP> sjanssen: just to go with liftM2 and so on
19:14:56 <wli> Functor could probably be derived, never mind the rest.
19:14:58 <SamB_XP> to make the code prettier
19:15:07 <tehgeekmeister> so, tell me if i'm wrong: we're using fmap here instead of $ because the value of getFileStatus is in the IO monad, and so we've gotta lift whatever we apply to that value into the monad, right?
19:15:24 <mauke> yeah
19:15:35 <omniscientIdiot> yep
19:15:35 <tehgeekmeister> okay, i get it then.
19:15:36 <sjanssen> SamB_XP: I agree that Haskell could use a system to compact instances for these hierarchy of classes.  However, just because we don't have this mechanism yet isn't enough justification against Functor as a superclass of Monad
19:15:51 <jaredj> concatRL :: RL (RL a) C(x z) -> RL a C(x z)
19:15:51 <SamB_XP> sjanssen: quite so
19:15:58 <tehgeekmeister> and i'm right to think there's absolutely no way to get something out of the IO monad?  (makes sense, in order to contain the side effects)
19:15:58 <SamB_XP> I said I'd complain either way
19:16:04 <jaredj> what are the C()'s?
19:16:08 <wli> Just get some derivation stuff for Functor into the compiler intrinsics.
19:16:23 <sjanssen> that is another interesting idea
19:16:28 <mauke> tehgeekmeister: no good way. there is an evil way, though
19:16:34 <dmwit> tehgeekmeister: To a first approximation, you are correct.
19:16:58 <SamB_XP> sjanssen: because, as I understand it, it's actually necessary to define Functor already. but sometimes people forget, making more work for them later...
19:17:07 <dmwit> jaredj: Looks like C is a type constructor, and (x z) is a type.
19:17:27 <tehgeekmeister> hmm, coming from imperative languages it seems like it'd be quite a pain to lift all those operations into the IO monad.  does it really end up being that annoying in practice?  oh!  wait.  do notation does that for you, doesn't it?
19:17:36 <sjanssen> SamB_XP: I say we make it impossible for them to forget first, then work to make it easier to write
19:17:42 <wli> Functor is essentially done via structural induction 99% of the time anyway.
19:17:57 <wli> That can be programmed. So program it in with the rest of the derivations.
19:18:01 <SamB_XP> sjanssen: that does seem to be the appropriate order of priorities
19:18:06 <dmwit> tehgeekmeister: One approach is to do everything in the pure world, then lift a single final function into the IO world.
19:18:07 <omniscientIdiot> tehgeekmeister: say there was a function (unsafe :: IO a -> a), if you applied (unsafe getChar :: Char), which Char would it be?  Remember, function outputs in Haskell are *totally* defined by their input, and may not return different things each time.
19:18:07 <phobes> I'm still confused.  Why dont we just add a blanket  "instance Monad m => Functor m ..." ?   There wouldn't be any new overhead to adding a new Monad then would there?
19:18:14 <mauke> tehgeekmeister: yeah
19:18:21 <SamB_XP> but I'll complain about them having to implement it whether or not they are allowed to forget ;-)
19:18:21 <wli> phobes: That goes the wrong direction.
19:18:37 <mauke> wli: ?
19:18:52 <wli> mauke: It should be instance Functor m => Monad m
19:18:58 <dmwit> no
19:19:00 <mauke> that would be wrong
19:19:03 <phobes> Every Monad is a Functor
19:19:09 <mauke> not every Functor is a Monad
19:19:11 <sjanssen> wli: it isn't possible to write that instance
19:19:36 <phobes> So if you go down that path, where do you hit the extra boilerplate?
19:19:40 <wli> Every monad is a functor, therefore functor is a prerequisite of monad.
19:19:42 <phobes> or rather, why not do that?
19:19:49 <phobes> wli:  That's the class definition
19:19:52 <omniscientIdiot> the report even says, implicitly, that it Monad must subclass Functor, even though that's not the case: "Instances of both Monad and Functor should additionally satisfy the law: fmap f xs = xs >>= return . f"
19:19:56 <mauke> phobes: requires overlapping instances
19:20:04 <dmwit> wli: No, every monad is a functor, therefore you can extract a functor from any monad.
19:20:06 <mauke> and probably undecidable instances
19:20:21 <SamB_XP> wli: notice the "instance" keyword ;-)
19:20:22 <phobes> wli:  I think you're mixing up the semantics of => for class and instances
19:20:34 <wli> Yes I'm thinking of the class definition.
19:20:40 <tehgeekmeister> omniscientIdiot: right, i get that.  my question, then, would be, what really IS the problem there?  it's hard for me to grasp -- i'm sure there's a good reason, i'm not trying to flamebait about side effects, i just want to know.  would it muck up things for the language internals?  is it just not how we want to do things?  what difficulty/badness do those sort of side effects entail?
19:21:07 <tehgeekmeister> i can see why state is, in it's way, evil, and imperative programming is messy, but i'm not sure i get it with side effects.
19:21:25 <mauke> tehgeekmeister: laziness and side effects don't mix
19:21:37 <jaredj> tehgeekmeister: side effects bring state into everything
19:21:44 <SamB_XP> tehgeekmeister: side effects can be okay sometimes
19:21:46 <jaredj> er.
19:22:03 <scodil> so, i get these errors that say "Cannot deduce (SomeClass a, AnotherClass b c d, ..." etc, but all of the type variables in the error are unique and consistent with the type variables in my instance declarations and type signatures, i.e., i can just copy and paste the error into the code to make it work. Since the compiler knows what needs to be done, is there any way I can make it do that on its own?
19:22:08 <SamB_XP> I don't mind Debug.Trace, for instance
19:22:23 <SamB_XP> that's got some fairly clearly defined semantics...
19:22:39 <omniscientIdiot> tehgeekmeister: Haskell assumes all functions are referentially transparent (i.e. outputs depend only on inputs and results don't change), so compilers are free to, for example, eliminate repeated calls and move stuff around.
19:22:55 <wli> While we're complaining about the Prelude being screwed up we might as well dredge up the numeric hierarchy.
19:22:55 <dmwit> weirdResult = [print 3, print 5, print 7] -- tehgeekmeister: Given lazy evaluation, we don't know what order 3,5,7 will be printed in... or even if they will be printed at all!
19:23:29 * jaredj finds a numeric hierarchy at the bottom of the river
19:23:32 <SamB_XP> well, I mean, there's the coarse-grained "trash stderr / traverse trace output strings" semantics, at least ;-)
19:23:57 <mauke> A REFRESHING DESERT IN THE OASIS OF REFERENTIAL TRANSPARENCY
19:24:12 <SamB_XP> mauke: what, Debug.Trace?
19:24:13 <phobes> mauke:  Ok, why would that require overlapping instances?
19:24:32 <SamB_XP> jaredj: quick, lets put it in Haskell'
19:24:43 <jaredj> oo!
19:24:46 <mauke> phobes: because I could create my own Functor instance for a type that's already a Monad
19:24:50 <jaredj> *jam*
19:25:16 <sjanssen> whatever happened to Haskell'?
19:25:20 <wli> I get the distinct impression that Haskell' will be vastly too conservative to deal with any of these things but haven't read the mailing list, so...
19:25:49 <jaredj> sjanssen: isn't that what ghc is?
19:25:56 <jaredj> ... compiling?
19:26:11 <SamB_XP> so who is with me in thinking that a numeric heirarchy that jaredj found at the bottom of a river is probably better than the one we have now?
19:26:26 <wli> SamB_XP: The ayes have it.
19:26:31 <jaredj> whow
19:27:29 <ddarius> It appears that Haskell' has essentially sputtered out and died.  We need to start Haskell''
19:27:32 <phobes> mauke:  ... but you can't give two instance declarations for Functor the way you guys are talking about doing it, can you?  How is this different?
19:27:47 <SamB_XP> ddarius: lol
19:27:59 <sclv> any way to golf this shorter: break (not . flip elem ['1'..'9']) ?
19:28:05 <mauke> what?
19:28:25 <mauke> sclv: (`notElem` ['1' .. '9'])
19:28:35 <sjanssen> sclv: span (`elem` ['1'..'9')
19:28:46 <omniscientIdiot> span f = break (not . f) I think
19:28:49 <sjanssen> @src break
19:28:49 <lambdabot> break p =  span (not . p)
19:28:51 <wli> I need a little handholding to get started on desugaring... sometime this weekend maybe might be good depending on how busy my friends keep me.
19:29:08 <sclv> ooh. thanks
19:29:09 <SamB_XP> @src span
19:29:09 <lambdabot> Source not found. Where did you learn to type?
19:29:23 <SamB_XP> 'twould have been funny if it said...
19:29:27 <omniscientIdiot> odd
19:29:42 <SamB_XP> span p = break (not . p)
19:29:46 <phobes> mauke:  I'm comparing two approaches to making every Monad a Functor.  Approach 1) Make class Functor => Monad.  2) instance Monad => Functor.   I'm saying that neither approach will let you define two instances of Functor for the same type, right?
19:29:55 <sjanssen>  @src only includes short definitions, span must be too long
19:30:21 <omniscientIdiot> @src lex
19:30:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:31:00 <wli> I honestly don't see any reason to muck with the core language outside of maybe grafting on a higher-order module system and some instance scoping (both of which are so far beyond me I don't care to get involved at all). Compiler intrinsics bits, so long as there's no significant investment of time or effort, OTOH...
19:31:35 <mauke> phobes: with 2: data Foo a = Foo a; instance Monad Foo where {...}; instance Functor Foo where {...} -- overlapping instances for Functor
19:31:48 <tehgeekmeister> i've noticed chunks of do notation where you'll see a <- on one or two lines, but not all the rest, are all the operations until the first return done inside the monad
19:31:55 <tehgeekmeister> or is it something else?
19:32:25 <mauke> huh? 'return' isn't special (and not part of do notation)
19:32:31 <jaredj> tehgeekmeister: everything in the do is inside the monad
19:32:38 <ddarius> phobes: Nothing will let you define two instances for the same type anyway.
19:32:40 <jaredj> tehgeekmeister: just return tends to happen last
19:32:45 <phobes> mauke:  Ahhh, so the problem is just that if you already have a type that is an instance of Functor, you can't extend it to Monad
19:32:53 <sjanssen> tehgeekmeister: the lines without <- are just actions that you don't need the result of
19:33:06 <tehgeekmeister> mauke: i hadn't seen an example yet where return wasn't in the last line, but i understand now.
19:33:10 <tehgeekmeister> it's everything indented, then?
19:33:30 <phobes> ddarius:  Does my last explanation sound right?
19:33:31 <mauke> > do []; return 1; return 2; return 3
19:33:33 <lambdabot>  []
19:33:35 <sjanssen> for example "do x <- getLine; putStrLn x", no <- in the second line because putStrLn just returns ()
19:33:35 <omniscientIdiot> do syntax uses layout for {;}, yes
19:34:02 <wli> return is kind of screwy; it'd probably be less misleading if it had been left named unit.
19:34:07 <mauke> phobes: and if you have an instance of Monad, you can create an overlapping instance for Functor
19:34:08 <omniscientIdiot> mauke: !!  shouldn't that be [3]?
19:34:17 <mauke> omniscientIdiot: no, it loops 0 times
19:34:30 <jaredj> wli: it used to?
19:34:30 <phobes> mauke:  ... so don't do that?
19:34:34 <omniscientIdiot> oh, right
19:34:41 <tehgeekmeister> wli: yeh, seems really weird to me.  it's got a very established meaning in other languages, it's confusing to have it be so different here.
19:34:50 <tehgeekmeister> (return, that is.)
19:34:57 <mauke> phobes: yeah, which is why H98 doesn't allow instance Foo a => Bar a
19:35:00 <phobes> mauke:  If you did what I was suggesting, then if you had an instance of Monad you wouldn't need to define the instance of Functor - it would come for free
19:35:05 <omniscientIdiot> > return 1 :: [Int]
19:35:07 <lambdabot>  [1]
19:35:26 <phobes> mauke:  oh, that's right... that's probably the main reason - I'd forgotten that was an extension!
19:35:29 <tehgeekmeister> sorry to bombard you all with so many questions, i just happen to be learning from a smattering of what resources are available online, and so i end up missing some of these details in the process.
19:35:47 <sclv> > return 1 :: Maybe Int
19:35:49 <lambdabot>  Just 1
19:36:20 <kfish> http://www.lexxe.com/main.cfm?sstring=when+is+it+necessary+to+define+functor+for+monads%3F
19:36:20 <mauke> 'return' is a generic constructor, not a control structure
19:36:26 <wli> > maybe (return 1) (fmap (+1)) (Just 2)
19:36:27 <lambdabot>   add an instance declaration for (Num (f a))
19:36:33 <lambdabot> Title: Lexxe Search Engine: [Q:] when is it necessary to define functor for monads?&nbs ..., http://tinyurl.com/2wa8dw
19:36:38 <ddarius> tehgeekmeister: There are some solid resources available online, you should use them.
19:36:46 <wli> > maybe (return 1) (+1) (Just 2)
19:36:47 <lambdabot>   add an instance declaration for (Num (m t))
19:36:50 <wli> gah
19:36:56 <mauke> > maybe 1 succ (Just 2)
19:36:57 <lambdabot>  3
19:37:32 <wli> > maybe (return 1) (Just . (+1)) (Just 2)
19:37:34 <lambdabot>  Just 3
19:37:38 <mauke> maybe == runMaybe
19:38:46 <mauke> > fmap (+1) (Just 2) `mplus` return 1
19:38:48 <lambdabot>  Just 3
19:39:11 <omniscientIdiot> @src Maybe mplus
19:39:11 <lambdabot> Nothing `mplus` ys  = ys
19:39:11 <lambdabot> xs      `mplus` _ys = xs
19:40:49 <tehgeekmeister> ddarius: the biggest problem i find is simply figuring out what to learn when, tutorials are sporadic, at best, in their coverage, i've found.
19:41:16 <jaredj> tehgeekmeister: as soon as you learn what's going on with monads you have to write a tutorial
19:41:25 <jaredj> tehgeekmeister: it's a rule :)
19:41:33 <tehgeekmeister> gah
19:41:38 <tehgeekmeister> i'm almost there, how daunting.
19:41:47 <tehgeekmeister> okay, well, i think i am.  but i've thot that for a while.
19:41:53 <jaredj> i'm like two steps ahead of you, no more
19:42:09 <jaredj> bagh and my page won't load.
19:42:23 <jaredj> i think it's http://dingoskidneys.com/~jaredj/grep.lhs
19:42:41 <jaredj> a leetle one
19:43:02 <omniscientIdiot> 404 :(
19:43:08 <tehgeekmeister> http://dingoskidneys.com/~jaredj/grep2.lhs.txt
19:43:15 <tehgeekmeister> that's the link from your main page
19:43:16 <tehgeekmeister> and it works.
19:43:21 <jaredj> ah thx
19:44:12 <jaredj> my friend is an ipv6 zealot, and my box is configured enough to try to use it, failing badly
19:46:17 <omniscientIdiot> needle `isIn` haystack = any (needle `isPrefixOf`) (tails haystack)
19:46:38 <mauke> that looks like isInfixOf
19:46:53 <omniscientIdiot> 'tis
19:47:02 <jaredj> yeap
19:48:32 <xtacy[]> is this a nice place to ask about simulations? :) I dont know if #math is a better place! (okay, I know about the "dont ask to ask!" rule!)
19:49:25 <omniscientIdiot> I suppose.  I probably can't help you but some here will likely try :)
19:50:43 <xtacy[]> Ah okay, the problem is I have to model a traffic network. I have a single lane, but should allow two way traffic by constructing sidings at intermediate checkpoints.
19:50:50 <xtacy[]> I was wondering if, this is equivalent to:
19:51:40 <ddarius> tehgeekmeister: There are some rather comprehensive tutorials was my point.
19:51:51 <xtacy[]> Forgetting about one side of the traffic altogether, and then modeling it as a queueing process, in which vehicles queue up in sidings, and each of them have a service time,
19:52:50 <tehgeekmeister> ddarius: care to name one or two?  i don't doubt their existence, but i've yet to find a really comprehensive one yet, imho.
19:52:54 <kfish> xtacy[], what about deadlock?
19:53:36 <xtacy[]> kfish: I have to route traffic such that there is no deadlock. So if I can detect that a deadlock can occur, route only one side.
19:53:58 <xtacy[]> But in the second model, that I had thought of, deadlocks arent possible. Hmm..
19:54:38 <tehgeekmeister> ddarius: i've already finished most of a gentle introduction to haskell and all about monads.
19:57:08 <ddarius> tehgeekmeister: YAHT is often recommended, but I haven't read it myself all the way and wasn't too keen on what I did read years and years ago.  Similarly for the Haskell Wikibook.
19:57:09 <dmwit> tehgeekmeister: You could have invented monads... and maybe you already did!
19:57:34 <dmwit> (One of my two favorite monad tutorials.)
19:57:48 <tehgeekmeister> dmwit: oh, read that too, forgot to mention.
19:58:05 <tehgeekmeister> ddarius: it's on my to read list, just want to finish the ones i'm on first.
19:58:08 <ddarius> There's a whole section on Learning Haskell on haskell.org, a "metatutorial" to help pick through them and a page on "all" books and tutorials.
19:58:21 <tehgeekmeister> oh, i'd forgotten about that
19:58:26 <tehgeekmeister> hadn't seen it for a few years
19:58:30 <tehgeekmeister> i'll look it over again
19:58:30 <omniscientIdiot> tehgeekmeister: I suppose the next step is writing something!  I wrote an implementation of False, a tiny Forthlike, with InterpreterState -> IO InterpreterState types all over the place.  Changing it to StateT InterpreterState IO () was educational! :)
19:59:08 <omniscientIdiot> False: http://wouter.fov120.com/false/  It looks like line noise, but it's a very simple little language.
19:59:09 <lambdabot> Title: Wouter's False page
19:59:43 <ddarius> omniscientIdiot: shapr was (is) rather keen on Wouter's various languages.
20:00:02 <tehgeekmeister> ddarius: thank you for reminding me of that, this is mostly what i needed.
20:01:29 <sclv> ok so I have my : span (`elem` ['1'..'9'])
20:01:45 <sclv> which breaks on the first non-numeric character
20:02:07 <sclv> now supposing i want to break on the first non-numeric character or the 10th character, whichever comes first
20:02:24 <sclv> i can write a dozen hacky ways to do this, but is there an especially elegant one?
20:03:07 <omniscientIdiot> maybe break on the first non-numeric, then cut it at 10 using take and drop
20:03:35 <omniscientIdiot> (and are you forgetting '0'?)
20:03:36 <sclv> right, and append the rest to the 2nd of the returned tuple
20:03:50 <ddarius> :t splitAt
20:03:52 <lambdabot> forall a. Int -> [a] -> ([a], [a])
20:04:47 <omniscientIdiot> (\(xs, ys) -> let (xs', xs'') = splitAt 10 xs in (xs', xs'' ++ ys))
20:05:45 <omniscientIdiot> (\(xs, ys) -> (take 10 xs, drop 10 xs ++ ys)) -- is surprisingly clearer :)
20:06:53 <omniscientIdiot> > (\(xs, ys) -> (take 10 xs, drop 10 xs ++ ys)) (['a'..'n'], ['m'..'z'])
20:06:54 <lambdabot>  ("abcdefghij","klmnmnopqrstuvwxyz")
20:07:06 <omniscientIdiot> > (\(xs, ys) -> (take 10 xs, drop 10 xs ++ ys)) (['a'..'c'], ['d'..'z'])
20:07:08 <lambdabot>  ("abc","defghijklmnopqrstuvwxyz")
20:07:52 <omniscientIdiot> uh-oh, repeated "mn"
20:08:17 <omniscientIdiot> er, that was my problem
20:08:20 <omniscientIdiot> > (['a'..'n'], ['m'..'z'])
20:08:21 <lambdabot>  ("abcdefghijklmn","mnopqrstuvwxyz")
20:08:36 <jaredj> hehe
20:08:47 * omniscientIdiot blushes in shame
20:09:04 * omniscientIdiot goes back to third grade
20:09:17 <jaredj> you can sit next to me
20:09:32 <omniscientIdiot> =)
20:10:49 <jaredj> waiwait, this False page is about False, not about the haskell implementation
20:11:46 <omniscientIdiot> yeah, I've not released it
20:11:50 <jaredj> oh
20:12:41 <SamB_XP> man, this pi program from the ioccc is bizzare...
20:13:04 <jaredj> bah. i don't really grok stack based languages
20:13:33 <jaredj> people complain about how easy it is to mess up lisp, but you can see parenthesis problems in a nice editor
20:13:47 <jaredj> parenthesis problems in a stack language are conceptual, not typographic
20:14:47 <jaredj> i guess it comes with use
20:14:51 <omniscientIdiot> yeah, stack languages are on the completely opposite end of the functional-imperative spectrum :)
20:14:57 <omniscientIdiot> nothin' but state
20:16:00 <mauke> you should write a HQ9+ interpreter
20:16:12 <jaredj> *google*
20:16:25 <omniscientIdiot> I don't think I could manage it %D
20:16:56 <omniscientIdiot> that language is *way* high-level!
20:17:29 <sclv> i cut some of my programming teeth on the hp48 with rpl. that was sort of both at once -- anyone else remember it?
20:17:41 <mauke> @where+ hq9+ http://www.cliff.biffle.org/esoterica/hq9plus.html
20:17:42 <lambdabot> Done.
20:17:53 <jaredj> sclv: i have one. never did anything decently complex though
20:18:06 <jaredj> just 10 3 +
20:18:57 <sclv> languagewise, its pretty awesome -- closures on a stack at its base
20:20:27 <KatieHuber> heh, HQ9+ is fantastic... but what about the logical evolution, which contains single-character instructions for passing the "great computer language shootout" ;)
20:20:42 <mauke> http://mauke.ath.cx/stuff/perl/hq9+.pl
20:20:45 <jaredj> ...! so... beautiful!
20:24:45 <omniscientIdiot> Oh god, "The function of a particular word is determined by the score one would receive for playing that word in Scrabble."
20:24:45 <omniscientIdiot> http://www.cliff.biffle.org/esoterica/beatnik.html
20:24:46 <lambdabot> Title: Beatnik
20:25:16 <jaredj> what? crap!
20:25:20 <dmwit> Heh.
20:25:22 <jaredj> debian doesn't have a curl doc package?
20:25:40 <dmwit> Incidentally, did you know there is an #esoteric?
20:25:45 <jaredj> yeah the example Beatnik program was epiphanous. uh, diaphanous. something.
20:25:53 <ddarius_> @google sortle
20:25:56 <jaredj> no i didn't
20:25:56 <lambdabot> http://esolangs.org/wiki/Sortle
20:25:56 <lambdabot> Title: Sortle - Esolang
20:25:56 <dmwit> I'm sure that your comments are appreciated here, too, but you might find more replies there. ;-)
20:26:35 <omniscientIdiot> what?  There's other channels besides #haskell?!
20:26:49 <ddarius_> omniscientIdiot: There's #haskell-blah and #haskell-overflow
20:27:57 <jaredj> blah?
20:28:28 <omniscientIdiot> @topic-tell #haskell-blah
20:28:28 <lambdabot> Anything BUT Haskell (especially SEX!) -|- add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html -|- lambdabot's first words: "Ooh, functional programmers
20:28:28 <lambdabot> are so hot" -|- current topic: "Watch out for the chigger! (Seasick Steve)"
20:41:33 <hpaste>  Katie pasted "HQ9+" at http://hpaste.org/2959
20:41:54 <omniscientIdiot> @slap KatieHuber
20:41:54 * lambdabot smacks KatieHuber about with a large trout
20:41:58 <KatieHuber> heh
20:42:35 <mauke> you should ignore other chars
20:42:41 <omniscientIdiot> doesn't HQ9+ just ignore invalid chars?
20:42:53 <KatieHuber> ah, I didn't read the document that carefully ^_^
20:43:03 <mauke> also, you need to increment the accumulator on +
20:43:16 <KatieHuber> but there's no way to observe the result afaict
20:43:19 <jaredj> 'whitespace' does
20:43:37 <jaredj> but that's one for #esoteric i guess
20:44:02 <omniscientIdiot> '+' isn't incrementing the accumulator!  I call foul!
20:44:03 <KatieHuber> I don't see the page saying that it ignores invalid chars
20:44:03 <mauke> I recommend StateT Int IO
20:44:10 <omniscientIdiot> and you're cutting it off at the first '\n'?  What about robust programs!
20:44:36 <KatieHuber> \n isn't a legal character, so that's justified
20:44:49 <KatieHuber> not incrementing the accumulator is, in the spirit of haskell, supremely lazy :p
20:45:04 <shachaf> Also, you should implement HQ9++.
20:45:25 <mauke> that'll be harder
20:45:28 <shachaf> Or better yet, HQ9+-.
20:45:29 <omniscientIdiot> KatieHuber: lol
20:45:35 <mauke> OOHaskell, anyone?
20:45:37 <jaredj> HQ9+0x?
20:46:35 <jaredj> w00p
20:46:46 <shachaf> Hmm, "3. When preceded by Q, it enters the infinite recursion (a good implementation will crash when out of stack). ".
20:46:54 <shachaf> Haskell is not ideal.
20:47:17 <jaredj> haha
20:47:20 <jaredj> take a while
20:48:05 <shachaf> > 1 / 0
20:48:06 <lambdabot>  Infinity
20:48:10 <shachaf> Also not ideal.
20:48:15 <ddarius> shachaf: Shhh, they don't know that.  They have to wait forever to be sure.
20:48:52 <mauke> willHalt :: (a -> b) -> a -> Bool; willHalt f x = True
20:49:37 <shachaf> Not to mention that the spec distinguishes between infinite recursion and an infinite loop.
20:49:59 <omniscientIdiot> mauke++ congratulations! A Nobel prize is in order!
20:50:24 <mauke> sweet
20:50:50 <shachaf> willHalt :: a -> Bool is nicer.
20:51:12 <ddarius> @hoogle isBottom
20:51:13 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
20:51:26 <sclv> shachaf: but more confusing to new users. :-(
20:51:36 <omniscientIdiot> :O!!!
20:51:36 <jaredj> willHalt willHalt?
20:51:54 <omniscientIdiot> = True :)
20:51:57 <mauke> <(a -> b) -> Bool>
20:52:08 <jaredj> omniscientIdiot: you are regurgitating cigars?
20:52:10 <shachaf> > Test.QuickCheck.Batch.isBottom Test.QuickCheck.Batch.isBottom
20:52:11 <lambdabot>   Not in scope: `Test.QuickCheck.Batch.isBottom'
20:52:20 <jaredj> i will regurgitate pipes
20:52:21 <shachaf> Of course, it isn't. :-)
20:52:23 <jaredj> :O????
20:52:30 <mauke> @let willHalt :: (a -> b) -> a -> Bool; willHalt f x = True
20:52:31 <lambdabot> Defined.
20:52:45 <mauke> > willHalt willHalt
20:52:46 <lambdabot>  Add a type signature
20:52:58 <shapr> hah
20:52:59 <jaredj> > willHalt willHalt 0
20:53:00 <lambdabot>   add an instance declaration for (Num (a -> b))
20:53:02 <ddarius> > willHalt willHalt :: ()
20:53:03 <lambdabot>  Couldn't match expected type `()'
20:53:09 <ddarius> Stupid bot.
20:53:15 <shachaf> > fix willHalt
20:53:16 <ddarius> :t willHalt
20:53:16 <lambdabot>  Add a type signature
20:53:18 <lambdabot> Not in scope: `willHalt'
20:53:52 <omniscientIdiot>  @type doesn't see @lets
20:54:13 <ddarius> Indeed, hence me forcing a type error
20:54:40 <sclv> > willHalt willHalt (+1)
20:54:40 <lambdabot>  True
20:55:17 <omniscientIdiot> excellent
20:55:18 <shachaf> > willHalt willHalt (fix id)
20:55:20 <lambdabot>  True
20:55:24 <sclv> > willHalt willHalt willHalt
20:55:25 <lambdabot>  True
20:55:34 <sclv> sync;sync;sync;
20:55:46 <omniscientIdiot> will willHalt halt?
20:55:55 <omniscientIdiot> will "will willHalt halt" halt?
20:56:36 <mudge> hi good people of haskell
20:56:47 <jaredj> "hi"
20:56:55 <mudge> sometimes I feel like Haskell is a country
20:56:57 <ddarius> mudge: Not going to say hi to the bad people?
20:57:06 <mudge> and some people are from Haskell
20:57:06 <omniscientIdiot> > "hello" >>= replicate 5
20:57:06 <lambdabot>  "hhhhheeeeellllllllllooooo"
20:57:11 <mudge> I don't know any bad people from haskell
20:57:28 <jaredj> aw. *smarm*
20:57:36 <mudge> i have a high opinion of haskellers
20:58:03 <mudge> I mean just look at haskell.org
20:58:25 <jaredj> oo - question
20:58:42 <jaredj> there's a cflags that makes a cflags file for vim (or emacs if you swing that way) to look at
20:58:45 <jaredj> is there an hsflags?
20:59:29 <sclv> > sequence ((iterate willHalt) (willHalt willHalt)) willHalt
20:59:30 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
21:00:29 * omniscientIdiot 's head explodes
21:00:34 <Olathe> > let f x = f (x + 1) in willHalt f 2
21:00:35 <lambdabot>  True
21:01:32 <sclv> willHalt (sequence ((iterate willHalt) (willHalt willHalt))) willHalt
21:01:37 <sclv> > willHalt (sequence ((iterate willHalt) (willHalt willHalt))) willHalt
21:01:39 <lambdabot>  True
21:01:46 <Olathe> > let f x = f (x + 1) in f 2
21:01:49 <lambdabot> Terminated
21:01:56 <Olathe> I guess it was right.
21:01:59 <Olathe> It terminated.
21:02:08 <shachaf> > willHalt Olathe
21:02:09 <lambdabot>   Not in scope: data constructor `Olathe'
21:02:15 <Olathe> False
21:02:17 <omniscientIdiot> =D
21:02:37 <omniscientIdiot> @. elite run let f x = f (x + 1) in f 2
21:02:40 <lambdabot> +eR/\/\ina+Ed
21:03:25 <shachaf> @. elite run fix id
21:03:26 <lambdabot> eXC3ption: <<1oop>>
21:03:41 <shachaf> @elite black hole
21:03:41 <lambdabot> bLAxx hoL3
21:06:03 <sclv> are there any simple library functions for parsing hex/oct numbers?
21:06:39 <mauke> @hoogle hex
21:06:40 <sclv> i see something in parsec
21:06:40 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
21:06:40 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
21:06:40 <lambdabot> Numeric.readHex :: Integral a => ReadS a
21:06:47 <omniscientIdiot> @hoogle read hex oct
21:06:47 <lambdabot> Did you mean: Read Hex Oct
21:06:48 <lambdabot> Prelude.undefined :: a
21:06:50 <lambdabot> Test.QuickCheck.Batch.bottom :: a
21:06:53 <shachaf> @ty readIntAtBase
21:06:55 <lambdabot> Not in scope: `readIntAtBase'
21:07:03 <shachaf> Hmm.
21:07:06 <ddarius> > read "0xff"
21:07:06 <mauke> > readHex "10"
21:07:07 <dmwit> > read "0x32"
21:07:08 <lambdabot>  [(16,"")]
21:07:08 <lambdabot>  255
21:07:10 <lambdabot>  50
21:07:14 <omniscientIdiot> @index readHex
21:07:14 <lambdabot> Numeric
21:07:25 <mauke> > readOct "10"
21:07:26 <lambdabot>  [(8,"")]
21:07:35 <omniscientIdiot> @docs Numeric
21:07:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
21:07:35 <jaredj> buh?
21:07:36 <dmwit> > reads "0x32"
21:07:37 <lambdabot>  [(50,"")]
21:07:38 <ddarius> > read "010"
21:07:40 <lambdabot>  10
21:07:46 <sclv> oh cool
21:08:47 <ddarius> @hoogle scanf
21:08:48 <lambdabot> No matches found
21:10:38 <ddarius> We should be able to make a scanf-like function a la (Haskell's) printf.  Why you'd want to use it, I have no idea.
21:10:55 <jaredj> 
21:11:10 <bos> it's only useful if it enables stack overflow attacks
21:13:04 <omniscientIdiot> > let ds = ['0'..'9']++['a'..'z'] in readInt 36 (`elem` ds) (fromJust . flip elemIndex ds) "halp"
21:13:05 <lambdabot>  [(806893,"")]
21:13:46 <jaredj> ogh
21:13:54 <jaredj> U+2245 APPROXIMATELY EQUAL TO
21:14:07 <jaredj> U+2246 APPROXIMATELY BUT NOT ACTUALLY EQUAL TO
21:14:08 <sclv> ddarius: i'm almost done with my scanf function. that's what my stupid questions have been about all night
21:14:20 <jaredj> U+2247 NEITHER APPROXIMATELY NOR ACTUALLY EQUAL TO
21:14:23 <sclv> getting late though, i'll probably finish it up tomorrow
21:14:25 <jaredj> unicode rocks
21:14:46 <omniscientIdiot> @let readInt' digits = readInt (length digits) (`elem` digits) (fromJust . flip elemIndex digits)
21:14:47 <lambdabot> Defined.
21:14:55 <sclv> it's crazy simple to write
21:15:03 <dmwit> jaredj: http://www.inference.phy.cam.ac.uk/cjb/codepoints.html
21:15:04 <lambdabot> Title: Chris Ball: : Favourite Unicode Codepoints
21:15:11 <omniscientIdiot> > readInt' ['a'..'z'] "canhascheezburger"
21:15:12 <lambdabot>  [(-159719271,"")]
21:15:38 <shapr> cjb shows up here sometimes, I think.
21:15:59 <jaredj> dmwit: people say i know so many random things
21:16:04 <jaredj> dmwit: i kneel in your dojo
21:16:10 <dmwit> hahaha
21:16:19 <shapr> jaredj: You're in the right community then...
21:16:25 <ddarius> (['0'..'9']++['a'++'z'])
21:16:33 <dmwit> syntax error
21:16:33 <shapr> That is, #haskell is the source of knowing of many random things.
21:17:03 <jaredj> BAHAHAHA
21:17:48 <ddarius> I get to write letters like that if I learn Thai?
21:18:10 <shapr> Man, I want to be able to put 'HEAVY BLACK HEART' in my email signature.
21:18:19 <jaredj> DONG SIGN
21:18:19 <jaredj> yeah i need to go to bed
21:18:38 <shapr> I gotta figure out how to set all my emails to utf-8 and see if any fonts in debian/unstable support that.
21:19:23 <hpaste>  sclv pasted "scanf so far (about half done)" at http://hpaste.org/2960
21:20:35 <ddarius> sclv: No, no, no.  It should parse the parse string based on the type of the output to check it's correctness.
21:21:16 <sclv> ddarius: huh? i don't follow. the type of which output?
21:21:30 <shachaf> sclv: Its return type.
21:22:05 <sclv> i'm lost now. i don't know which return type people are talking about even
21:22:34 <shachaf> sclv: scanf's?
21:22:37 <ddarius> The return type of scanf
21:22:40 * shachaf may be misunderstanding.
21:23:24 <ddarius> scanf "%d" "23.4" :: Double should do what I want (the format string may be jacked since I never use scanf and virtually never printf)
21:23:30 <sclv> you want scanf polymorphic on return type, like =~  is?
21:24:12 <ddarius> Yes.
21:24:29 <shachaf> ddarius: Can you make it even more clever so it can also work with :: IO Double?
21:24:46 <shachaf> Or with any MonadReader?
21:24:54 <sclv> don't think its possible -- we had a discussion here this morning. it could work if we only allowed a fixed set of return types, but we could return, theoretically, anything.
21:25:08 <sclv> i.e. the specification could request five strings, two ints, and three doubles
21:25:38 <sclv> =~ is implemented with a large but fixed set of return types -- scanfs are sort of infinite
21:25:57 <omniscientIdiot> right, so the user of scanf would be responsible for typing the result correctly
21:26:38 <omniscientIdiot> (though /me wouldn't know where to start with that)
21:27:15 <sclv> hence the lists -- i'm sure some haskell-fu on top of this could special case it for returning a single int or double or etc, but i don't know any way to specify an infinitely polymorphic return type
21:27:42 <sclv> hmmm... once i get the basics of this down though, a few particular return types could be next
21:29:03 <ddarius> shachaf: It should be able to be set up a la PrintF
21:29:03 <shachaf> Well, you could have a class ScanfType, which can either be Int/Char/etc. or (ScanfType a, ScanfType b) => (a,b), and then return something like (Int,(Char,(Double,Char))). Maybe?
21:31:02 <sclv> hmmm... there is the hlistlike solution. i don't understand what it buys you though.
21:31:26 <sclv> if you ask for a double, you'll either get a double in the right place in the returnval or nothing, the way i have it set up.
21:33:08 <sclv> so a more magic solution doesn't seem to get you any more type power.
21:35:25 <sclv> using Maybe on the other hand might be the most expressive way to handle a partial match
21:37:39 <shachaf> ddarius: What are you suggesting that its type would look like?
21:46:54 <sclv> regexp uses fundeps to handle polymorphism in the return types. i've been meaning to play with those anyway, so...
21:47:03 <sclv> enough for tonight though.
22:07:15 <narain> ?users
22:07:15 <lambdabot> Maximum users seen in #haskell: 420, currently: 357 (85.0%), active: 6 (1.7%)
22:10:15 <omniscientIdiot> @. elite keal
22:10:15 <lambdabot> tH3 [NsA] EvEn /\/\4KE |I9h7 Gr33N BO+h WAYS 0NCe
22:12:54 <omniscientIdiot> @. . . elite elite elite protontorpedo
22:12:54 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "1337"
22:13:56 <omniscientIdiot> @. elite . elite . elite protontorpedo
22:13:56 <lambdabot> \/\/Hy \/\/0U|d u Wri73 a IN73Rpr3+3r 4 p3Rl IN |-|45X3||?
22:16:10 <bos> any ghci users on windows around?
22:16:33 * omniscientIdiot is a windows loser.
22:16:45 <bos> omniscientIdiot: does ghci do tab completion on windows?
22:16:56 <omniscientIdiot> nar
22:16:58 <bos> ok
22:18:00 <narain> i recently noticed that car and cdr on pairs in lambda calculus are defined in terms of true and false
22:18:42 <narain> it feels like that should mean something significant
22:18:54 <narain> does it? some sort of category-theoretic duality perhaps?
22:20:07 <Tac-Tics> True and False are more than that in LC
22:20:12 <Tac-Tics> they are selector functions
22:20:27 <narain> i know, true = \x y -> x and all that
22:20:28 <Tac-Tics> (well, they aren't MUCH more)
22:20:57 <narain> but is that all? nothing more interesting?
22:21:21 <Tac-Tics> I wouldn't think so
22:21:24 <shachaf> narain: It doesn't have to be implemented that way.
22:21:26 <Tac-Tics> they are pretty basic concepts
22:21:43 <Tac-Tics> and CS basically knows all it's gonna know about booleans and conses
22:21:50 <tuomov> Sigh.
22:22:02 <tuomov> The GHC package system is the most utterly and totally fucked up mess that the earth carries
22:22:25 <narain> Tac-Tics, cs surely does, but i probably don't
22:22:28 <Tac-Tics> heh
22:22:41 <tuomov> I had to remove hsplugins support from riot because of it, and I guess it's time to put the hscurses code back into riot as well
22:23:15 <tuomov> /usr/bin/ld: cannot find -lHShscurses-1.1
22:23:22 <tuomov> yeahyeah, it's there you stupid fucked up bitch
22:23:57 <Tac-Tics> calm down now ^^;
22:24:05 <Tac-Tics> Everyone has those issues with haskell
22:25:28 <tuomov> why the _fuck_ does it need a fucking package system of its own?
22:25:28 * notsmack didn't think ld was written in Haskell
22:25:47 <tuomov> talk about over-engineering and reinventing the wheel (just like the whole module mega-hierarchy)
22:26:38 <Tac-Tics> What's not to like about a package system where a handful of modules have but a single definition in them?
22:29:42 <kosmikus> tuomov: I even might agree with some of your points if they were presented calmly, so I suggest you to present your criticism in a more rational and systematic form
22:30:05 <Tac-Tics> kosmikus: He's not looking for agreement, he's venting =-P
22:30:19 <bos> tuomov: be polite, please
22:30:20 <kosmikus> tuomov: there'll be a Hackathon after ICFP where Cabal is on the topic list by tradition, so if you make helpful suggestions now, they might be implemented soon
22:30:45 <tuomov> I'm not talking about Cabal (which is fucked up too), but the whole module registration shit
22:30:54 <tuomov> s/module/package/
22:30:58 <tuomov> -llibrary should do...
22:31:16 <tuomov> along with paths etc.
22:31:20 <tuomov> no point in reinventing the wheel
22:31:36 <bos> tuomov: the package system is actually pretty well thought out, though it takes some getting used to.
22:31:40 <tuomov> doe sit even support user-registration of packages?
22:31:43 <bos> yes
22:31:44 <tuomov> last time I checked, it didn't
22:31:53 <kosmikus> I think it always did
22:31:55 <bos> you can install packages either systemwide, or as yourself.
22:31:59 <tuomov> bos: it's complicated over-engineergin
22:32:00 <bos> it's quite well documented, too.
22:32:08 <tuomov> that _never_ works
22:32:18 <bos> tuomov: it's actually possible to have a different opinion than you. shocking, i know.
22:32:19 <kosmikus> what?
22:32:20 <tuomov> bos: but not without being root?
22:32:39 <bos> tuomov: yes, you can install a package as yourself, without being root.
22:32:50 <bos> runghc Setup configure --user --prefix=$HOME
22:32:59 <tuomov> well, at least that's been fixed..
22:33:04 <tuomov> but it's still fucked up
22:33:06 <kosmikus> tuomov: or without Cabal. ghc-pkg ... --user ...
22:33:08 <tuomov> and convirus is fucke dup
22:33:16 <bos> convirus?
22:33:18 <kosmikus> tuomov: please, language
22:33:21 <tuomov> anything that depends on it is shit to the power of n
22:33:30 <tuomov> autoconf
22:33:33 --- mode: ChanServ set +o bos
22:33:44 <bos> tuomov: i'm going to kick you if you keep being an ass
22:34:06 <tuomov> go ahead, I've learn to expect people to be arseholes on this channel
22:34:15 --- kick: tuomov was kicked by bos (bos)
22:34:18 <Tac-Tics> @info RWS
22:34:19 <lambdabot> (RWS)
22:34:20 <bos> ok, then.
22:34:27 <Tac-Tics> when will I learn @info is broken??
22:34:29 <shachaf> Tac-Tics: @info -> @undo
22:34:30 <Tac-Tics> I'm so dumb
22:34:35 <Tac-Tics> @undo RWS
22:34:36 <lambdabot> (RWS)
22:34:36 <shachaf> OK. :-)
22:34:38 <Tac-Tics> ?
22:34:54 <shachaf> @undo do { x <- a; y <- b; f x y }
22:34:54 <lambdabot> (a >>= \ x -> b >>= \ y -> f x y)
22:35:14 <Olathe> @undo C++
22:35:14 <lambdabot> (C ++)
22:35:23 <kosmikus> bos: sad that this kick had to happen. I wouldn't have done it (yet), but I can see your point.
22:35:25 <Tac-Tics> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html
22:35:27 <lambdabot> http://tinyurl.com/ye2tnb
22:35:33 <Tac-Tics> finding links like ^^^^ makes me sad
22:35:41 <shachaf> @quote hearts
22:35:41 <lambdabot> No quotes match. That's something I cannot allow to happen.
22:36:15 <shachaf> Tac-Tics: Click on the link?
22:36:29 <bos> hang on
22:36:31 <shachaf> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS-Lazy.html seems to be more useful.
22:36:32 <lambdabot> http://tinyurl.com/2lfnco
22:36:43 <Tac-Tics> why are there blank versions of the library docs?
22:36:52 <Tac-Tics> that was the one hoogle linked me to
22:36:53 <bos> sad, i can remember how to op myself, but not how to drop ops
22:36:56 <Tac-Tics> the one I posted
22:37:09 <dolio> It's not blank. It says it's the same as the .Lazy version.
22:37:24 <shachaf> bos: It's just the reverse, isn't it?
22:37:33 <kosmikus> bos: op #haskell -yournick
22:37:36 <puusorsa> well, he kinda had a point. or a few, actually
22:37:37 <bos> kosmikus: tuomov is a well-known troll
22:37:42 <Tac-Tics> what is the .Lazy module for then?
22:37:46 <dolio> And it's, presumably, there because in previous versions, .RWS was the module, and .Lazy and .Strict didn't exist.
22:37:49 <puusorsa> just don't read the nasty words
22:37:51 <shachaf> Oh, not through ChanServ.
22:37:53 <Tac-Tics> I see
22:37:58 <bos> he wasn't going to stop being a wanker.
22:38:02 <dolio> So, backwards compatibility.
22:38:24 <kosmikus> bos: well, tuomov is difficult, but unlike many other trolls, he does know a lot and can actually say useful things once in a while
22:38:54 <Tac-Tics> even the Lazy docs aren't so useful, because the link on it is broken, and there's no explanation for the functions or types it defines >____>
22:39:05 <puusorsa> i don't think he's a troll, more like just impolite
22:39:06 <bos> if he wants to be an ass, he can go flame his window manager users.
22:39:25 <shachaf> Tac-Tics: It's just R, W, and S combined. :-)
22:39:48 <shachaf> @ty runRWS
22:39:50 <lambdabot> forall r w s a. RWS r w s a -> r -> s -> (a, s, w)
22:40:03 * sjanssen greps for tuomov in the logs
22:40:12 <puusorsa> though "go ahead, I've learn to expect people to be arseholes on this channel" is just so wrong, one of the nicest channels i've seen
22:40:27 <kosmikus> bos: you really make him appear worse than he is
22:40:29 <Tac-Tics> shachaf: I figured it was something like that
22:40:35 <Tac-Tics> also, what is the Transformer version of ST?
22:40:37 <Tac-Tics> STT?
22:40:40 <sjanssen> 07.09.14:05:10:25 <tuomov_> bah, I think I'll just use C
22:40:41 <sjanssen> 07.09.14:05:10:28 <tuomov_> this haskell is worth nothing
22:40:54 <dolio> Tac-Tics: There isn't one.
22:40:57 <eck> how can I compute the nth root of a number? it looks like (^) only accepts integral powers
22:40:59 <sjanssen> Tac-Tics: there isn't one -- it must be the base of a monad stack, just like IO
22:40:59 <Tac-Tics> whaaa?
22:41:08 <kosmikus> sjanssen: it such a statement a crime? ;)
22:41:10 <Tac-Tics> that's crazy talk
22:41:12 <bos> kosmikus: i've read a lot of what he's written.  i think i'm being quite nice about him.
22:41:14 <shachaf> @ty (^^)
22:41:16 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
22:41:17 <Tac-Tics> is there a reason for that?
22:41:17 <shachaf> @ty (**)
22:41:20 <lambdabot> forall a. (Floating a) => a -> a -> a
22:41:32 <dolio> Tac-Tics: With a transformer, you can't guarantee that the state is used in a single-threaded manner, so you'd lose the ability to do in-place update.
22:41:37 <kosmikus> bos: me too. but let's stop the discussion and agree to disagree.
22:41:39 <eck> thanks
22:41:42 <sjanssen> kosmikus: no, but it's clearly whiny and baiting
22:41:51 <bos> kosmikus: sounds good.
22:47:03 <Tac-Tics> so what is RWS useful for?
22:47:03 <Tac-Tics> I thought S was basically RW anyway
22:47:11 <omniscientIdiot> nah
22:47:19 <omniscientIdiot> the R doesn't change like S
22:47:20 <dolio> Well, they're all separate in RWS.
22:48:02 <dolio> It's like a ReaderT r (WriterT w (State s)) stack.
22:48:05 <omniscientIdiot> the State is threaded through, the Reader is provided once, and the Writer is only written to, never read.
22:48:12 <shachaf> Tac-Tics: W is used very differently from S.
22:48:38 <Tac-Tics> I'm looking at the Yi source
22:48:40 <Tac-Tics> RWS () [Update] FBuffer a
22:48:55 <Tac-Tics> that would read from () (aka, it's not used), write to a list of Updates
22:49:01 <Tac-Tics> and keeps a state of a FBuffer?
22:49:11 <shachaf> Hmm, it writes to a list?
22:49:28 <Tac-Tics> yes
22:49:29 <shachaf> When you use W, you often want something like DList.
22:49:48 <Tac-Tics> DList?
22:49:55 <shachaf> @where dlist
22:49:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
22:50:17 <sjanssen> @unmtl RWS () [Update] FBuffer a
22:50:17 <lambdabot> () -> FBuffer -> (a, FBuffer, [Update])
22:50:42 <Tac-Tics> what does unmtl do?
22:51:00 <shachaf> MTL -> Monad Transformer Library.
22:51:00 <omniscientIdiot> @help unmtl
22:51:00 <lambdabot> unroll mtl monads
22:51:10 <Tac-Tics> ah
22:51:19 <sjanssen> @src RWS
22:51:19 <lambdabot> Source not found. That's something I cannot allow to happen.
22:52:00 <omniscientIdiot>  @src seems somewhat random with its choices
22:52:19 <quicksilver> it is
22:52:29 <quicksilver> manual intervent is required
22:52:47 <sjanssen> @src State
22:52:48 <lambdabot> Source not found. It can only be attributed to human error.
22:52:54 <quicksilver> Tac-Tics: you're right that 'S' subsumes R and W
22:53:10 <quicksilver> Tac-Tics: but RWS is a better type, in principle
22:53:18 <sjanssen> it has only been run on base, apparently
22:53:20 <quicksilver> Tac-Tics: because it decalres in the type which parts we don't intend to change
22:53:32 <quicksilver> @src State (>>=)
22:53:32 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:53:34 <sjanssen> quicksilver: not quite true, Writer has different strictness properties
22:53:43 <Tac-Tics> quicksilver: the () type, right?
22:54:00 <quicksilver> Tac-Tics: well in the Yi case, we declare that we only produce Updates, we never inspect old Updates
22:54:08 * bos tries to think of a common right-associative operator
22:54:18 <quicksilver> Tac-Tics: that's not the most exciting thing but there you go
22:54:23 <Tac-Tics> k
22:54:25 <shachaf> bos: (:)?
22:54:27 <bos> ah, ++
22:54:39 <quicksilver> ++ is associative, really
22:54:42 <dolio> ($)?
22:54:44 <shachaf> (++) is associative.
22:54:46 <quicksilver> the infixr is more efficient
22:54:51 <quicksilver> but it's only efficiency, not semantics
22:55:02 <shachaf> dolio: Don't let Ca_e hear you.
22:55:15 <dolio> Yeah, well, I'm not happy about it. :)
22:56:07 <shachaf> (:) is nice, I think.
22:57:25 <pixl> anyone know how I can set attributes for html elements defined in Text.XHtml module? For example i want to set "class = "something"" for a table element
22:59:19 <thetallguy> pixl:!
23:02:09 <thetallguy> Sorry, I can't find my example
23:02:21 <thetallguy> Look at the library page and follow the link to Andy Gill's paper
23:02:27 <thetallguy> He gives examples there.
23:05:32 <Tac-Tics> Monoid are just Groups less the inverse condition, right?
23:06:55 <pixl> thetallguy: that page no longer exists
23:09:10 <shachaf> Tac-Tics: Yes.
23:12:12 <Tac-Tics> I understand groups ^^
23:12:21 <Tac-Tics> I get Monoid confused with MonadPlus
23:12:29 <Tac-Tics> MonadPlus is the one I don't undrestand
23:13:01 <quicksilver> MonadPlus is a monad 'm' with the property that for every type 'a', 'm a' is a Monoid.
23:13:18 <quicksilver> and furthermore, all these Monoids 'm a' are in some sense 'the same' or 'compatible'.
23:13:45 <omniscientIdiot> (for a specific 'm'?)
23:13:53 <quicksilver> yes, for a specific m
23:13:59 <quicksilver> for a specific MonadPlus instance, to be precise
23:14:27 <quicksilver> for example, lists. [a] is a Monoid, irrespective of the type 'a'
23:14:42 <Tac-Tics> quicksilver: is there a slightly more rigorous version of that second part (all "the same"?)
23:14:44 <quicksilver> and moreover this works "in the same way" without any reference to the internals of a.
23:15:02 <quicksilver> Tac-Tics: Yes. Given a function f from a -> b
23:15:14 <quicksilver> Tac-Tics: then 'f' will commute with 'mappend'
23:15:31 <quicksilver> Tac-Tics: so (f a) `mappend` (f a') == f (a `mappend` a')
23:15:54 <quicksilver> and a similar property for the identity mempty
23:15:54 <Tac-Tics> oh neat
23:16:02 <Tac-Tics> That kind of stuff I understand
23:16:06 <Tac-Tics> sorta
23:16:23 <quicksilver> and some boring propertly about how it all relates to >>= in the obvious way, I think.
23:16:49 <Tac-Tics> is the last property a consequence of the other two?
23:16:52 <quicksilver> no
23:16:55 <Tac-Tics> ah crap
23:16:57 <Tac-Tics> hehe
23:17:14 <quicksilver> the first two just make it a "FunctorPlus"
23:17:29 <quicksilver> which is not a defined type class
23:17:35 <Tac-Tics> yeah
23:18:04 <Tac-Tics> There's so much to learn about Haskell, I'm surprised anyone has the time to actually write programs in it
23:18:50 <quicksilver> :)
23:18:59 <quicksilver> you don't really need to understand this kind of thing
23:19:04 <quicksilver> it's just interesting, if you're so inclined
23:19:32 <quicksilver> there are actually two different kinds of MonadPlus, but the libraries don't reflect this
23:19:40 <quicksilver> there are 'exception-catch' kinds
23:19:42 <Tac-Tics> I read that somewhere
23:19:48 <quicksilver> and 'nondeterminism' kinds
23:19:49 <quicksilver> roughly
23:19:53 <dolio> Yeah, there's a proposal somewhere for MonadOrElse or something.
23:21:04 <Tac-Tics> I remember someone, maybe Cale, talking a long while ago about the "fail" method of Monads and how if the IO monad were defined as a Monoid or a MonadPlus or something like that, it would be cleaner
23:21:12 <Tac-Tics> does that ring a bell to anyone?
23:21:19 <Cale> Yep
23:21:23 <Tac-Tics> hah
23:21:27 <Cale> MonadZero
23:21:33 <dolio> Well, IO is MonadPlus somewhere.
23:21:38 <Cale> Which unfortunately no longer exists.
23:21:38 <dolio> In Control.Exception or something, probably.
23:21:40 <thetallguy> pixl:     prettyHtml page
23:21:40 <thetallguy>         where page = header << thetitle << "David's Colors"
23:21:40 <thetallguy>                      +++ body ! [bgcolor' "#ffffff"]
23:21:40 <thetallguy>                          << colorChips
23:21:42 <omniscientIdiot> fail is a kludge for pattern-match failure in do blocks
23:22:38 <quicksilver> Tac-Tics: right. "mempty" for the MonadPlus monoid (or more correctly mzero) is supposed to be the same as 'fail' roughly
23:22:47 <shachaf> Tac-Tics: You mean as a MonadZero?
23:23:00 <quicksilver> Tac-Tics: although it doesn't take an error message as a parameter, and therein lies an annoying mess
23:23:06 <Tac-Tics> yeah
23:23:07 * shachaf is late again.
23:23:16 <Tac-Tics> aww, poor shachaf
23:23:31 <shachaf> quicksilver: You could move fail to MonadZero, at least.
23:23:42 <dolio> Yeah. They can always ignore the string.
23:23:50 <quicksilver> yes, I agree
23:24:19 <Tac-Tics> If you're program fails, that's what debuggers are for, not stderr =-P
23:24:34 <Tac-Tics> especially in a language where print debugging is impossible
23:24:39 <Tac-Tics> well
23:24:42 <Tac-Tics> much harder
23:24:49 <dolio> There's trace.
23:24:55 <dolio> Which uses unsafePerformIO, of course.
23:25:00 <shachaf> Tac-Tics: Well, fail isn't usually error.
23:25:12 <shachaf> Tac-Tics: Just by default.
23:27:17 <quicksilver> I've never used a debugger with haskell :)
23:27:29 <quicksilver> I find the ability to run functions independently from ghci
23:27:31 <quicksilver> on test data
23:27:32 <Tac-Tics> I downloaded and built the latest version of GHC to try it out
23:27:35 <Tac-Tics> it was kinda neat
23:27:40 <quicksilver> enables me to pin down problems quickly enough
23:27:44 <Tac-Tics> it was like a regular debugger, only weird
23:27:58 <Tac-Tics> ghci debugging is awesome too
23:28:27 <Tac-Tics> but loading large projects into ghci for debugging doesn't work
23:28:38 <Tac-Tics> but for single file programs, yeah, ghci all the way
23:34:03 <quicksilver> I've loaded "fairly large" projects into ghci
23:34:07 <quicksilver> say, 6-10 files
23:34:16 <quicksilver> seems fine to me :)
23:34:28 <Tac-Tics> I mean, for example, I'm poking around with Yi
23:34:29 <quicksilver> it encourages you to develop test cases and stuff though
23:34:35 <Tac-Tics> I can't so easily load Yi into GHCI
23:34:46 <Tac-Tics> yeah
23:35:16 <Tac-Tics> Haskell would be a really easy language to test, because if it managed to compile, chances are the person who wrote it wrote it right
23:38:49 <Tac-Tics> how does ByteString work that makes it fast?
23:40:24 <sjanssen> @src ByteString
23:40:24 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:40:26 <sjanssen> drat
23:40:48 <sjanssen> Tac-Tics: it's implemented as an unboxed array of bytes (ForeignPtr Word8)
23:41:42 <Tac-Tics> so is it just really fast random access?
23:41:47 <Tac-Tics> are appends any faster?
23:42:15 <sjanssen> the memory representation is much more compact which helps alot
23:42:25 <sjanssen> Tac-Tics: in most cases yes
23:42:51 <Tac-Tics> neat
23:42:53 <sjanssen> m++n is O(m), Data.ByteString.append m n is O(m+n)
23:43:03 <sjanssen> but with a much much better constant factor
23:43:21 <Tac-Tics> isn't O(m) = (m + n) in general?
23:43:32 <Tac-Tics> obviously the constant factor matters though
23:43:46 <Tac-Tics> O(m+n)*
23:43:47 <sjanssen> Tac-Tics: no, fix m at 1
23:44:04 <sjanssen> O(1) and O(1 + n)
23:44:12 <Tac-Tics> ok
23:44:27 <sjanssen> then there are lazy ByteStrings, which have an even faster append
23:44:51 <sjanssen> O(m)
23:49:01 <Tac-Tics> Are there any lazy pure functional languages for the working man?
23:49:11 <sjanssen> Haskell?
23:49:20 <Tac-Tics> Well, the not so hard working man
23:50:16 <Tac-Tics> Something slightly more intuitive perhaps, that might stir more interest in Haskell and friends?
23:50:40 <Tac-Tics> Only the truly insane programmers would dare put the energy required to learn this language in and out
23:50:45 <Tac-Tics> (and they all hang out in #haskell)
23:51:50 <sjanssen> I think Haskell is one of the only pure and lazy languages
23:51:51 <jmob> Haskell is compilation for HaXml 1.13.2 so noisy?
23:51:51 <kaol> I thought "truly insane" was a requirement for being a programmer
23:52:00 <jmob> Is it indicative of a bad software package?
23:52:14 <Tac-Tics> kaol: I think it's a requirement for being a "good" programmer
23:52:47 <sjanssen> Tac-Tics: purity is especially rare, most of the other languages sell out
23:52:55 <Tac-Tics> yeah
23:53:08 <sjanssen> OCaml, Lisp, Scheme, Scala, etc.
23:53:09 <jmob> sjanssen: purity is often impracticle
23:53:16 <Tac-Tics> but purity is so very nice though for testing things work
23:53:19 <jmob> sjanssen: scheme wasn't intended to be pure
23:53:35 <Tac-Tics> even if it was something as simple as you had to declare your functions impure or something like that
23:54:03 <sjanssen> jmob: I think practicality is debateable
23:54:28 <Tac-Tics> basically, a very lightweight haskell with a more C-like syntax and instead of monads, you just have something a lot like IO
23:55:20 <jmob> sjanssen: people typically want to do things with computers, rather than just sitting around talking about them in Universities
23:55:24 <Tac-Tics> then people would go "wow, this infinite list stuff is pretty neat" and Haskell would be more accessible to smart programmers who don't know what a monad is
23:55:34 <sjanssen> jmob: I'm sure scheme wasn't supposed to be pure, I'm just pointing out languages that support the functional style but "make a deal with the devil"
23:55:47 <olsner> you really don't have to understand *Monads* to do IO in haskell
23:55:57 <sjanssen> jmob: people write real programs in Haskell all the time.  I wrote a window manager in Haskell
23:56:02 <Tac-Tics> olsner: that's exactly the point ^^
23:56:12 <jmob> olsner: it certainly helps to have passable understanding
23:56:21 <sjanssen> jmob: I think the evidence shows that your ivory tower argument doesn't hold water
23:56:42 <jmob> olsner: otherwise the amount of time you spend "flailing" just to get something work would make the other benfits of haskell mute
23:57:29 <Tac-Tics> I think a kindler, gentler lazy language would be pretty swift
23:57:36 <Tac-Tics> it could even be written in Haskell ;-)
23:58:02 <jmob> sjanssen: I'm not sure who has the ivory tower, but "non-pure" typically does the just good enough
23:58:23 <jmob> sjanssen: and good enough is the amount of effort most people expend
23:58:35 <Tac-Tics> trying to eat all of Haskell at once is really hard. There should be a language which is a "step up" from Lisp or ML
23:58:52 <sjanssen> there was a lazy ML
23:59:01 <olsner> isn't the "step up" from ML just Haskell?
23:59:01 <Tac-Tics> oh?
23:59:26 <Tac-Tics> I think Haskell has more concepts that have come about because of it than all other languages I've learned combined
23:59:45 <jmob> Speaking of lazy, how do you debug large haskell programs?
23:59:45 <sjanssen> Tac-Tics: yeah, it might be really obscure.  I just know that an old Haskell compiler was bootstrapped with a LML compiler
