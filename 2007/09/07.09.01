00:33:02 <mudge> dons: how do you find so many good haskell blog posts?
00:34:03 <ivanm> mudge: because he's got nothing better to do? :p
00:45:46 <iguana_> mudge: does he collect them?
01:33:36 <augustss_> @users
01:33:37 <lambdabot> Maximum users seen in #haskell: 394, currently: 336 (85.3%), active: 4 (1.2%)
01:33:44 <augustss_> so quiet
01:36:13 <glguy> shh, baby's sleeping
01:52:17 <taruti> There is no BSD-licensed public-key crypto package available in Haskell?
01:52:49 <roconnor> @hackage crypto
01:52:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/crypto
01:53:09 <roconnor> hmm
01:53:12 <taruti> roconnor: that is GPL for the RSA parts (and by extension of static linking to everything)
01:54:00 <roconnor> ok
01:54:11 <roconnor> I guess I should rewrite the RSA parts.
02:07:30 <joelr1> morning!
02:07:44 <Vq^> morning mr J1
02:07:45 <masak> joelr1: good morning
02:07:56 <joelr1> dons: ping
02:08:06 <Vq^> s/J/R/
02:09:43 <joelr1> do you guys install the macports version of ghc 6.7 to compile and recompile the development tree?
04:05:50 <dcoutts> @seen brad_
04:05:50 <lambdabot> I saw brad_ leaving #haskell 3h 45m 38s ago, and .
04:06:10 <dcoutts> @tell brad_ did you discover Data.ByteString.Char8 ?
04:06:10 <lambdabot> Consider it noted.
04:07:03 <wli> There's a rotation and translation involved.
04:08:54 <wli> <x, Ax> + <b, x> + c -> <Qy, AQy> + <b, Qy> + c -> <y, Dy> + <Q^t b, y> + c so doing the rotation first helps.
04:09:50 <Japsu> <x, Ax> is the inner product?
04:09:54 <wli> Yes.
04:09:57 <Japsu> k
04:10:01 * Japsu prefers AxÂ·x
04:10:18 <wli> I'm bringing <x, Ax> + <b, x> + c to normal form.
04:10:22 <Japsu> yeah
04:13:21 <taruti> dons: ping
04:20:41 <njd> @uses
04:20:41 <lambdabot> Maximum users seen in #haskell: 394, currently: 338 (85.8%), active: 10 (3.0%)
05:02:11 <roconnor> @bab nl en Ten name van
05:02:12 <lambdabot>   At nasty of
05:02:26 <roconnor> hmm
05:02:29 <hpaste>  Japsu pasted "Why does this end up outputting "Ã–rÃ¶r" in ISO-8859-1 even though the source and locale are UTF-8?!" at http://hpaste.org/2540
05:02:57 <Japsu> (GHC 6.6.1)
05:03:44 <opqdonut> Japsu: in that paste at least it looks like the string is 8859-1 and the function name is utf-8
05:03:57 <opqdonut> or something
05:05:16 <Japsu> opqdonut: hpaste broke that
05:05:19 <Japsu> wait a sec,
05:05:43 <Japsu> https://pajukanta.fi/temp/Hmm.hs
05:06:14 <Japsu> japsu@hinaaja ~ % file Web/temp/Hmm.hs
05:06:14 <Japsu> Web/temp/Hmm.hs: UTF-8 Unicode text
05:12:15 <roconnor> Japsu: putStr trucates each character to a byte and outputs that byte.
05:12:20 <Saizan> Japsu: the source is interpreted as UTF-8, but literal strings are converted to unicode codepoints, in fact the length of that will be 4, then the standard IO functions output the 8 less significant bits of each codepoint
05:12:47 <roconnor> putStr is broken.
05:12:49 <Saizan> so you end up with latin-1 for the first 256 characters
05:13:24 <Saizan> you've to transform the string in one that is represented as utf-8
05:13:56 <roconnor> @google haskell UTF-8
05:13:58 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg20432.html
05:13:58 <lambdabot> Title: [Haskell] Re: ANN: encoding-0.1 release
05:14:06 <roconnor> @google utf8.hs
05:14:11 <lambdabot> http://ogi.altocumulus.org/~hallgren/Talks/LHiH/base/lib/UTF8.hs
05:14:11 <lambdabot> Title: UTF8.hs
05:14:13 <Saizan> @hackage utf8-string
05:14:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
05:14:22 <roconnor> oooh
05:14:56 <matthew-_> what should you do then in that case? Convert to [Word8] and then hPutBuf?
05:15:38 <Eelis> no, use System.IO.UTF8's putStr
05:16:00 <Saizan> matthew-_: i've used to convert to [Word8] than back to String with map (fromIntegral . ord) and then putStr
05:16:20 <matthew-_> right.
05:19:28 <MyCatVerbs> Word8 is shit, use StarOffice instead. ;)
05:19:49 <Japsu> hmm
05:19:54 <matthew-_> @slap MyCatVerbs
05:19:55 <lambdabot> why on earth would I slap MyCatVerbs
05:19:58 <matthew-_> grrr!
05:20:07 <Japsu> Eelis: thanks
05:20:13 <Eelis> welcome
05:21:00 <Japsu> hmm
05:21:06 <Japsu> ...but there is no System.IO.UTF8
05:21:15 <Japsu> oh
05:21:16 <Japsu> nvm
05:21:17 <Eelis> it's in http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
05:21:20 <lambdabot> http://tinyurl.com/3cjhwj
05:21:20 <Japsu> yeah
05:22:53 <Japsu> works
05:26:19 <Saizan> i think the haddocks of that package are a bit misleading, putStr doesn't print an utf8 string, it rather converts your string to utf8 before printing
05:26:55 <Saizan> unless by utf8 string you mean the bytes on stdout
05:41:13 <mrd> mudge: "C macros" are processed by cpp prior to compilation.  supply -cpp to ghc and you get them there too.
05:42:00 <DRMacIver> Hm. What an annoyingly ambiguous format...
05:42:24 <Heffalump> DRMacIver: English?
05:43:01 <DRMacIver> Heffalump: May as well be.
05:43:21 <Eelis> Saizan: i agree.
05:44:00 <DRMacIver> Heffalump: I'm trying to parse Mozilla's text dump of its email folders in order to do some trivial scripting, and the delimeters between emails are not particularly well defined. :)
05:45:08 <Heffalump> so it's not mbox?
05:45:50 <MyCatVerbs> Heffalump: nyoep, it's not mbox. It's some weird, fucked-up semibastardisation of it.
05:46:14 <DRMacIver> I wouldn't know. I don't know the first thing about email formats. :)
05:46:22 <mrd> mbox is pretty fucked up
05:46:33 <Heffalump> mbox is unambiguous, isn't it?
05:46:43 <mrd> the delimiter between e-mails is the regex "^From "
05:46:44 <MyCatVerbs> mrd: this is true, it's never been formally specified anywhere, ever...
05:47:09 <Heffalump> "From foo" starts a new email, and you escape any string beginning "(>){n}From" with an extra >
05:47:10 <MyCatVerbs> Heffalump: by dint of sheer luck, yes. Just.
05:47:39 <Heffalump> I think the only problem is that clients differ on what constitutes a valid thing in the "foo", and thus what they escape
05:47:49 <mrd> they don't escape, they munge
05:49:50 <DRMacIver> It's possible that this is unambiguous too. I just need to figure out how it handles the edge cases.
05:50:44 <DRMacIver> (I guess I can't think of anything easy for which there *won't* be some sort of edge case, but it's still annoying)
05:52:54 <MyCatVerbs> DRMacIver: yes you can. Octet-stuffing, metacharacters with escaping... unambiguous formats are really trivial if the people involved actually stop and *think* about them rather than just shit the first thing that comes to mind out onto disk. :/
05:53:17 <DRMacIver> Yeah, I guess.
05:56:14 <DRMacIver> Fuckit. Can't be bothered with doing this properly. It's just a one-shot scripting task. :)
05:56:21 * DRMacIver decides not to worry about ambiguities.
05:58:21 <Saul_> I just tought myself how to use the State monad :D
05:58:25 <Saul_> I'm very proud
05:59:06 <Heffalump> now teach yourself to spell "taught" ;-)
05:59:09 <hpaste>  Saul_ pasted "First try at the State monad" at http://hpaste.org/2541
05:59:44 <joelr1> g'day
05:59:47 <joelr1> dons: ping
05:59:53 <Saul_> Heffalump: Ah yeah I wasn't actually sure it was correct, thanks
06:00:39 <Saizan> Saul_: f x = return $ Node x
06:00:43 <joelr1> do you guys compile the ghc dev tree with the macports ghc 6.7? anyone doing this?
06:01:11 <Saul_> Saizan: thanks
06:01:56 <Saul_> Saizan: That really makes it more readable
06:02:05 <Saizan> unsquashM (Leaf _) = do (x:xs) <- get; put xs; return $ Leaf x
06:02:50 <Saizan> Saul_: yeah, you usually don't need to use the State constructor
06:03:36 <Saul_> Saizan: I see
06:03:53 <Saul_> Saizan: It think it helped to understand though
06:05:12 <Saul_> s/It/I
06:05:50 <Saizan> Saul_: yes, i also understand monads better if i look at the internals
06:08:48 <xerox> joelr1: no I use the haskell.org/ghc binary build of 6.6.1 for building darcs.haskell.org/ghc
06:09:17 <joelr1> xerox: ah, ok then. i just noticed there's a ghc/devl 6.7 in macports
06:09:40 <xerox> joelr1: yeah there is. Did you build ghc with macports?
06:10:38 <joelr1> xerox: no, i was just wondering. i usually install ghc from macports w/o problems.
06:11:03 <xerox> joelr1: hmm, is there a binary in macports ghc?
06:11:57 <joelr1> xerox: no binaries, just sources and appropriate patches
06:12:27 <xerox> joelr1: okay thanks. Ah, question, have you been at this year's anglohaskell in cambridge?
06:12:53 <joelr1> xerox: no, or you would have recognized me :) see pic at http://wagerlabs.com
06:12:54 <lambdabot> Title: Tenerife Skunkworks
06:13:50 <xerox> joelr1: hehe okay. There was someone interested in Poker that somebody wanted to find again. Nevermind.
06:34:58 <user317> anyone know apt well? the ubuntu mtl package seems to have busted my system, http://rafb.net/p/FECmAd45.html , anything that i try to do i keep getting the same stuipid error
06:35:00 <lambdabot> Title: Nopaste - No description
06:35:59 <DRMacIver> My parsec skills are distressingly weak. How would I create a Parser () which matches a line which doesn't start with some phrase?
06:36:04 <DRMacIver> s/phrase/string/
06:36:19 <qwr> user317: vi /var/lib/dpkg/info/libghc6-mtl-dev.prerm
06:36:30 <qwr> user317: insert exit 0 as first line :)
06:36:49 <tuxplore1> which package has math functions like variance SD, etc for lists?
06:36:55 <holst> so parsec is more used than happy?
06:37:59 <DRMacIver> (Bah. I'd be done by now if I just employed some really dumb line oriented reading. But I'd like to make this work with parsec)
06:38:33 <tuxplore1> I mean which module..
06:39:37 <user317> qwr, that worked, thanks, what did i just do?
06:40:08 <holst> you disabled the script
06:41:00 <user317> should i reinstall mtl?
06:41:44 <holst> the only reason i knew that is because I saw jonathan oxers video about debian packing =D
06:41:52 <joelr1> anyone seen dons today?
06:42:02 <Lemmih> DRMacIver: not (string prefix)?
06:42:10 <qwr> user317: all that it seems to do is /usr/bin/ghc-pkg6 unregister mtl-1.0
06:42:32 <qwr> since it complained about unexistance of this... shouldn't matter
06:42:52 <DRMacIver> Lemmih: There doesn't seem to be a 'not' combinator for parsec...
06:43:37 <user317> qwr, well, i want mtl, so i guess  right now it thinks its not there?
06:43:39 <DRMacIver> Lemmih: Either that or I'm being totally blind. :) (Well, I mean it's obviously not going to be called 'not' anyway)
06:44:18 <Lemmih> DRMacIver: 'try (string prefix >> mzero)' ?
06:44:33 <qwr> user317: hopefully it _now_ thinks that it is there. prerm - pre-remove script
06:44:55 <mrd> notFollowedBy perhaps
06:45:19 <qwr> user317: dpkg likes to remove old package version before installing new one
06:45:57 <DRMacIver> Lemmih: Hmm. Something like that could work. Thanks.
06:46:45 <user317> ok, well everything seems to be working at the moment
06:47:11 <DRMacIver> Lemmih: But I'm not quite sure how to make it do what I want. I'm trying to skip a bunch of lines until I find one which matches a specified prefix.
06:47:12 <qwr> user317: btw 'ghc-pkg6 list' shows installed ghc packages
06:47:54 <DRMacIver> Gah. I think I just don't understand parsec very well. :)
06:48:44 <user317> i was trying to  upgrade to gutsy's ghc packages by building them from source, but that didn't work out well
06:49:06 <Lemmih> DRMacIver: Are you sure you wanna use parsec?
06:49:15 <DRMacIver> No, not really.
06:49:53 <DRMacIver> But I've used it before, it seemed like a nice potential application of it and I was hoping to brush up on my parsec knowledge. :)
06:50:15 <DRMacIver> Especially given how everyone waxes lyrical about how great parsec is for dealing with awkward formats...
06:50:36 <DRMacIver> And it shouldn't be hard to make it do this dammit. I'm sure I'm just missing something.
06:51:12 <DRMacIver> "skip some lines until you find one which matches this" should not be a hard rule to deal with in any sane world. :)
06:55:11 <Lemmih> DRMacIver: manyTill anyChar (try (string prefix)) ?
06:56:24 <user317> can i "lift" Maybe?  like, (liftM doStuff) mymaybe === if isJust mymaybe then doStuff $ fromJust mymaybe else Nothing
06:56:59 <DRMacIver> Lemmih: Yeah, I've got that now. (Except that it's try (do {newline; string prefix; }). Thanks.
06:57:21 <ibid> > liftM (*2) (Just 2)
06:57:22 <Lemmih> > liftM even $ Just 10
06:57:22 <lambdabot>  Just 4
06:57:24 <lambdabot>  Just True
06:57:31 <ibid> > liftM (*2) Nothing
06:57:32 <lambdabot>  Nothing
06:57:44 <user317> sweeeeeeet
06:58:51 <LoganCapaldo> > return "a monad" :: Maybe String
06:58:52 <lambdabot>  Just "a monad"
06:59:21 <LoganCapaldo> @src Maybe (>>=)
06:59:21 <lambdabot> (Just x) >>= k      = k x
06:59:21 <lambdabot> Nothing  >>= _      = Nothing
07:00:18 <tuxplore1> is there any existing funtion for calculating SD or variance for a list? I'm abt to write one, but wanted to make sure that I'm not redoing things.. lazy programming;)
07:01:01 <user317> thats pretty usefull, you can push all the "null"
07:01:06 <user317> checking to the top
07:01:23 <Saul_> Is there a way to use read and return (Just result) or Nothing, based on whether read was able to parse the string?
07:01:40 <LoganCapaldo> :t reads
07:01:42 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:02:09 <LoganCapaldo> :t listToMaybe . map fst . reads
07:02:10 <lambdabot> forall a. (Read a) => String -> Maybe a
07:02:21 <LoganCapaldo> Yes
07:02:23 <LoganCapaldo> :)
07:02:28 <Japsu> @src read
07:02:28 <lambdabot> read s = either error id (readEither s)
07:03:34 <Saul_> ok thanks, both
07:03:42 <Saul_> @src readEither
07:03:42 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:04:27 <user317> i wish there was an optional way to control memory allocation, like some kind of heap monad
07:05:08 <LoganCapaldo> Why?
07:05:46 <LoganCapaldo> Also I think there are way to malloc C arrays and similar
07:05:55 <LoganCapaldo> @hoogle CArray
07:05:55 <lambdabot> Foreign.Marshal.Array.mallocArray :: Storable a => Int -> IO (Ptr a)
07:05:55 <lambdabot> Foreign.Marshal.Array.reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)
07:05:55 <lambdabot> Foreign.Marshal.Pool.pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
07:05:58 <jbauman> :t readEither
07:06:00 <lambdabot> Not in scope: `readEither'
07:06:05 <user317> because there is no way to be deterministic about memory usage, which makes haskell unusable for lots of applications
07:06:50 <LoganCapaldo> user317, it would be pretty hard to make haskell's memory usage deterministic given lazy evaluation etc.
07:08:00 <user317> LoganCapaldo, thats why i was thinking something like a language extension, so within some scope i get a heap i can malloc/free myself, but outside of that scope the heap is garbage collected by the runtime
07:08:31 <LoganCapaldo> well you have mallocArray etc. as I pointed out above
07:08:46 <LoganCapaldo> but that scope would be really odd
07:09:07 <user317> LoganCapaldo, but i cant force everything else that i will use that array with not to allocate any more memory
07:09:18 <LoganCapaldo> yes
07:09:22 <LoganCapaldo> but again
07:09:26 <LoganCapaldo> even something like x = 1
07:09:43 <LoganCapaldo> you can't say for sure what that will allocate
07:10:28 <LoganCapaldo> (well you can if you know the innards of your haskell implemenation)
07:10:53 <LoganCapaldo> but that's not necessarily gonna give you a 32bit int or whatever
07:11:16 <user317> yea, i agree, i think you would need a language extension, i wonder how the harpy guys  dealth with this  issue
07:11:36 <LoganCapaldo> I think you would need a different language, not a language extension
07:12:27 <MyCatVerbs> Hmmmm. Is there any statically-typed language on Earth which lets one construct infinite types t: a -> (t, b)?
07:13:00 <user317> have you looked at harpy?  if you can use x86 assembly within haskell, you should be able to implement a deterministic way to manage memory
07:13:27 <MyCatVerbs> I ran into that problem while pissing about with silly crap the other day and am just curious as to whether it's solvable without just resorting to throwing static typing away altogether (it's trivial in Scheme, for example.)
07:13:43 <LoganCapaldo> Um you're not using x86 within haskell, it's a dsl that fills up a buffer with x86 machine code
07:13:53 <LoganCapaldo> and that you can do with the alloc c array stuff
07:14:28 <LoganCapaldo> You don't need deterministic memory to write a compiler
07:15:08 <Saizan> MyCatVerbs: not exactly an answer but: you can probably emulate that in haskell using a recursive type
07:16:39 <MyCatVerbs> Saizan: what, chasing down a data structure for my flow control rather than passing functions?
07:17:20 <xerox> I think infinite types can asily give rise to inconsistencies. Haskell Curry has got a paper on that, if I decrypted it right :)
07:18:19 <Heffalump> MyCatVerbs: presumably you don't actually have an infinite type, just one where the length of the unfolding is runtime determined?
07:18:44 <MyCatVerbs> Contrived example, I had: funa fx fy p q l evaluating to if (p l) then (funa fx fy p q, (fx l)) else (funa fy fx q p, (fy l))
07:19:56 <Heffalump> why would this ever terminate?
07:20:02 <MyCatVerbs> The idea being that the function calling it rips the lambda out of the first bit of the tuple and applies it over and over to the second part of the tuple to get different values of l. fx and fy being functions that transform l in some way.
07:20:06 <matthew-_> err, don't infinite types just prevent type checking from terminating?
07:20:47 <MyCatVerbs> matthew-_: infinite types do prevent unifiers from terminating, yes. AFAIK that's why the error that ghc gives you is headed by the phrase "Occurs Check"
07:21:08 <Heffalump> it's headed by that phrase because that's the name of the check it does :-)
07:21:17 <MyCatVerbs> Heffalump: it doesn't - same way "iterate f l" doesn't terminate.
07:21:32 <LoganCapaldo> Isn't there another strategy besides unification? It's name escapes me, constraints checking or something?
07:21:38 <Heffalump> MyCatVerbs: ok, but at some point you presumably do let it terminate?
07:21:51 <Heffalump> LoganCapaldo: functional logic programming uses a more complicated type checking system
07:22:01 <Heffalump> oh, not type checking, evaluation, but same kind of idea in that setting.
07:22:14 <MyCatVerbs> Heffalump: no, I just take advantage of the laziness and dump take a finite subset of the infinite list of l's values it produces.
07:22:17 <LoganCapaldo> Could that terminate or infinite types?
07:22:23 <Heffalump> you can also treat unification problems as constraint satisfaction problems
07:22:23 <LoganCapaldo> s/or/on/
07:22:51 <Heffalump> MyCatVerbs: you can just wrap it up in a datatype, btw
07:23:54 <Heffalump> LoganCapaldo: not sure. I think what you actually meant was doing type checking by treating it as a constraint satisfaction problem, anyway. Which I think is equivalent in computational power, just nicer in other ways like error reporting.
07:24:01 <matthew-_> from comments on certain bugs, I get the impression that ghc 6.10 is going to be one large constraint solver. I wonder if infinite types will be permitted at that point.
07:24:24 <LoganCapaldo> Heffalump, ah ok
07:25:27 <matthew-_> I wonder if the solvers in Epigram can deal with infinite types.
07:26:10 <MyCatVerbs> Heffalump: please elaborate?
07:26:25 <Heffalump> just trying it out to confirm I'm not talking nonsense, hangon :-)
07:27:08 <hpaste>  Heffalump pasted "recursive type" at http://hpaste.org/2542
07:27:21 <Heffalump> that's valid H98
07:27:52 <Heffalump> (sorry, I should have mentioned this to begin with, it only occurred to me half-way through that you can always make a recursive type by just breaking the recursion at a data constructor)
07:27:56 <IvdSangen> What is the easiest way to check if a string matches a regular expression?
07:28:10 <Heffalump> IvdSangen: there's a regex library
07:28:29 <MyCatVerbs> Heffalump: ahhhh.
07:28:36 <Heffalump> regex-tdfa is the one I was pointed at when I asked for the current "standard" one
07:28:59 <IvdSangen> that's included in GHC?
07:29:18 <Heffalump> IvdSangen: no, you need to install it
07:29:54 <Heffalump> I have to admit it took me a little while to figure out which of the many ways it can be used was what I actually wanted.
07:29:57 <Heffalump> but it seems to work ok
07:30:10 <pejo> Heffalump, was that comment about constraint satisfaction and power of the type checker in some context?
07:30:27 <IvdSangen> let's hope it work on OpenBSD
07:31:06 <MyCatVerbs> IvdSangen: I'm running ghc-6.6 on OpenBSD 4.0 right now. Installing Haskell libraries Just Worked for me.
07:31:10 <Heffalump> pejo: it was in response to LoganCapaldo asking about something like that at [15:20] my time.
07:31:23 <MyCatVerbs> IvdSangen: (as in, on this machine upon which I are bee typing.)
07:31:34 <IvdSangen> MyCatVerbs, okay, I am still running GHC 6.2
07:31:49 <MyCatVerbs> Heffalump: that seems... deceptively easy.
07:31:52 <Heffalump> why doesn't hackage automatically include the haddock for the package?
07:31:58 <Heffalump> MyCatVerbs: I know. Feels like magic, doesn't it? :-)
07:32:18 <MyCatVerbs> Heffalump: better yet, feels like Haskell, comrade. XD
07:32:21 <Heffalump> MyCatVerbs: I have to admit not being able to quite put my finger on an intuitive explanation of why that's ok but doing it directly isn't.
07:33:09 <Heffalump> I think it's to do with the fact that the recursive aspect of the type is clearly explained in the datatype declaration, and that said declaration provides a convenient place for the type checker to stop and say "ok, now I just need to check that the other side comes out the same"
07:33:25 * MyCatVerbs nods.
07:34:44 <jbauman> Heffalump, that's the basic idea, yes
07:34:49 <matthew-_> Heffalump: hackage does now seem to include the haddock, if it is able to build the package
07:35:19 <Heffalump> matthew-_: oh, right.
07:35:22 <MyCatVerbs> Even though the data structure's *exactly* equivalent to the tuple, it doesn't violate the no-occurs constraint?
07:35:41 <matthew-_> Heffalump: it's just that haddock is rubbish so it blows up when building the docs for many many packages...
07:35:58 <matthew-_> its inability to parse Haskell being the main issue
07:36:05 <Heffalump> so why isn't hackage on hackage? :-)
07:36:24 <MyCatVerbs> IvdSangen: upgrading from the OpenBSD-supplied 5.something to 6.6 was also trivial, practically nowt more than a normal ./configure;gmake;gmake install (required gmake, rather than BSD make, though) it just took forever to compile. ;)
07:37:02 <Heffalump> MyCatVerbs: well, it's not exactly equivalent cos the data constructor causes a runtime overhead. But you can change it to newtype if you tuple up the arguments and it still works.
07:37:13 <DRMacIver> Hm. I wonder what I'm doing wrong. It still feels like a struggle every time I try to write something non-trivially large (i.e. more than a few lines).
07:37:15 <matthew-_> Heffalump: if hackage was on hackage then hackage would have all its bandwidth eaten by google trying to navigate an infinite address space ;)
07:37:19 <MyCatVerbs> IvdSangen: apparently 6.6.1 builds a *lot* quicker than 6.6 did though, which will be awesome, as soon as I once more own a machine with enough disk space to actually build ghc rather than just install it.
07:37:29 <Heffalump> matthew-_: :-)
07:37:40 <MyCatVerbs> Heffalump: okay, that is kinda mind-blowing. XD
07:37:47 <matthew-_> DRMacIver: using Java?
07:37:58 <jbauman> MyCatVerbs, well, the types are different, which makes type-checking easier
07:38:15 <jbauman> although the end result would be the same
07:38:18 <Ben`> how can I get the output of `system "fortune"` as a string?
07:38:24 <DRMacIver> matthew-_: No. Haskell. All programs in Java are non-trivially large.
07:38:34 <Heffalump> while they may be exactly equivalent, the type constructor provides the type checker with a place to stop, which it doesn't have with type aliases.
07:38:58 <DRMacIver> Well, I mean I often feel like it's a struggle to write Java too. But it's a different sort of struggle.
07:39:12 <Heffalump> DRMacIver: do you mean you don't like the results, or that you struggle to actually produce anything at all?
07:39:20 <MyCatVerbs> Heffalump: ahhh, ookie.
07:40:38 <DRMacIver> Heffalump: Bit of both. More the latter than the former though.
07:41:08 <matthew-_> DRMacIver: but that's a good thing: it means you don't mindlessly write code which you later realise is all rubbish
07:41:14 <Heffalump> well, if you have some samples of something you have produced, you could stick it on hpaste or the web and let people comment?
07:41:26 <matthew-_> I find that I have to think a lot before starting to write code in Haskell.
07:41:34 <DRMacIver> I mean, I usually get something done in the end. And I'm generally not dissatisfied with the results. But it feels like the way to there is paved with lots of annoying frustrations.
07:41:55 <DRMacIver> Heffalump: I do that occasionally. The problem is that by the time I have something I can show people I'm usually no longer struggling. :)
07:42:18 <DRMacIver> matthew-_: No, not really.
07:42:19 <matthew-_> DRMacIver: it sounds like you may not be using the Power of the Libraries to their full extent
07:42:30 <Heffalump> I think there is very little documented "good practice" or "recommended techniques" for designing the structure of Haskell programs/datatypes etc.
07:42:39 <MyCatVerbs> DRMacIver: that sounds more than a little bit like a sign that you're learning in the process. >>
07:42:42 <Heffalump> So it can be a little hard to get started because of the wealth of choice available.
07:42:57 <Heffalump> I just tend to dive in and go back and rewrite if I decide I was wrong.
07:43:06 <DRMacIver> matthew-_: No, not really to that too. :) For example I'm struggling with parsec at the moment.
07:43:18 <matthew-_> parsec is lovely!
07:43:26 <matthew-_> I rather like working with parsec.
07:43:30 <DRMacIver> matthew-_: I mean, I agree with you that Haskell forces me to think about what I write. But that's ok, and not what I'm talking about.
07:44:00 <DRMacIver> And yes, my last experience with parsec was rather pleasant. And it's a very nice concept.
07:44:05 <DRMacIver> But I'm still struggling for some reason. :)
07:44:09 <MyCatVerbs> DRMacIver: have a quick peek at the Hitchhiker's Guide to Haskell, there's a good example of parsec's use right there.
07:44:25 <MyCatVerbs> More or less idiomatic, even.
07:45:32 <DRMacIver> I'll take a look. I've written parsec code before though, so if it's just a basic example I don't know how much it will help. Thanks though. :)
07:46:38 <matthew-_> um, so the manual for parsec has a decent reference section. I just normally search through there to find what I'm after.
07:46:38 <MyCatVerbs> It's a pretty basic example. But it makes the in-depth documentation a lot clearer than it'd be if one tried reading it all straight-off.
07:51:29 <DRMacIver> Like I say, it's not like I don't understand basic parsec (I'm not very good at it, but I can at least use it some). I've written non-trivial programs using it before. Parsec is not the problem here.
07:51:56 <matthew-_> do you know what the problem is?
07:52:09 <DRMacIver> < DRMacIver> Hm. I wonder what I'm doing wrong.
07:52:17 <DRMacIver> So, no. :)
07:53:42 <DRMacIver> But the fact that I am struggling now is an instance of the fact that I generally seem to struggle at writing any non-trivial quantity of Haskell. So specific features of what I'm struggling with are red herrings. :)
07:53:49 <mrd> Don't Panic!
07:56:51 <MyCatVerbs> mrd: see? I told 'im the Hitchhiker's Guide was probably best! ;)
07:58:13 <shapr> @seen dons
07:58:13 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 10h 56m 1s ago.
07:58:24 <shapr> Is dons still in the air?
07:58:29 <MyCatVerbs> @seen dead_people
07:58:30 <lambdabot> I haven't seen dead_people.
07:58:33 <Heffalump> I imagine so
07:59:14 <importantshock_> hahahaha
07:59:24 <importantshock_> @seen enough
07:59:24 <lambdabot> I haven't seen enough.
07:59:31 <importantshock_> How sad.
08:01:55 <LoganCapaldo> @seen anything
08:01:56 <lambdabot> I haven't seen anything.
08:02:01 <LoganCapaldo> @seen everything
08:02:02 <lambdabot> I haven't seen everything.
08:02:23 <LoganCapaldo> @seen something
08:02:23 <lambdabot> I haven't seen something.
08:02:30 <importantshock_> @seen my_feet_in_years
08:02:30 <lambdabot> I haven't seen my_feet_in_years.
08:02:39 <delYsid> this bot doesnt pass the turing test :-)
08:02:48 <shapr> hiya delYsid!
08:02:51 <LoganCapaldo> If only nicks could have spaces...
08:03:03 <delYsid> hi shapr, ltns
08:03:07 <shapr> delYsid: What brings you to #haskell?
08:03:09 <LoganCapaldo> @seen my\ feet\ in\ years
08:03:10 <lambdabot> I haven't seen my\.
08:03:10 <importantshock_> @seen lambdabot
08:03:10 <lambdabot> Yes, I'm here. I'm in #happs, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc and #
08:03:10 <lambdabot> darcs
08:03:31 <LoganCapaldo> that's a bug in the line wrapping right there
08:03:36 <delYsid> shapr: voyeurism :-)
08:03:43 <shapr> delYsid: Heh, ok
08:03:47 <importantshock_> Why the fuck is lambdabot in #unicycling?
08:04:03 <LoganCapaldo> @seen shapr
08:04:03 <lambdabot> shapr is in #haskell. I last heard shapr speak 19s ago.
08:04:04 <shapr> importantshock_: Are you learning Haskell?
08:05:09 <shapr> importantshock-: Are you learning Haskell?
08:05:10 <EvilTerran> importantshock, several haskellers are also keen unicyclists.
08:05:33 <importantshock-> shapr: I'm trying, yes.
08:05:40 <importantshock-> EvilTerran: How intriguing.
08:05:53 <shapr> importantshock-: Are you learning for business or pleasure?
08:06:00 <importantshock-> shapr: Pleasure.
08:06:08 <shapr> Ah, nifty.
08:06:11 <shapr> How's it going so far?
08:06:14 <importantshock-> I love learning new languages, especially those which boggle my mind.
08:06:27 <importantshock-> Pretty well. I picked up The Haskell School of Expression, and I like it a lot.
08:06:37 <shapr> Yeah, Haskell can have a lot of boggle.
08:07:26 <shapr> importantshock-: Got any specific questions?
08:08:03 <importantshock-> shapr: No, other than "Why aren't all people on IRC this nice?"
08:08:39 <shapr> Well, most people on #haskell are really nice.
08:08:57 <LoganCapaldo> except for lambdabot
08:09:09 <jbauman> importantshock-, http://www.penny-arcade.com/comic/2004/03/19
08:09:09 <LoganCapaldo> @src happiness
08:09:10 <lambdabot> Source not found. You type like i drive.
08:09:10 <lambdabot> Title: Penny Arcade! - Green Blackboards (And Other Anomalies)
08:09:19 <LoganCapaldo> @src joy
08:09:20 <lambdabot> Source not found. Where did you learn to type?
08:09:27 <jbauman> luckily, many people here aren't anonymous
08:09:34 <EvilTerran> a lot of #haskell are academics, city professionals, etc
08:09:37 <LoganCapaldo> @src insultMeSomeMorePlease
08:09:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:10:00 <importantshock-> shapr: You might have seen http://tinyurl.com/yo35nu - that's my blog
08:10:03 <lambdabot> Title: &#8220;Haskell Curry? Yes, I dated his daughter.&#8221; « Important Shock
08:10:34 <shapr> importantshock-: That's a very funny blog post.
08:10:54 * DRMacIver kicks self. What a stupid mistake.
08:10:59 <importantshock-> shapr: Thank you. It's a small world.
08:11:50 <shapr> Yeah, the computer science community seems highly connected.
08:12:21 <Heffalump> or very small
08:12:30 <shapr> On the other hand, that means that if you make a bad impression, it can stick forever.
08:12:56 <importantshock-> shapr: The only reasonably complicated program I've written in Haskell is an HQ9+ parser.
08:13:11 <olsner> "parser" :P
08:13:20 <LoganCapaldo> You need a parser for hq9+? and it was _complicated_?
08:13:30 <shapr> importantshock-: That's a good way to start.
08:13:31 <LoganCapaldo> How many language extensions did you add? :)
08:13:50 <importantshock-> LoganCapaldo: Don't hate. Getting an accumulator monad right was hard for me to wrap my brain around.
08:14:06 <Heffalump> what is the point of the accumulator?
08:14:11 <Heffalump> you don't seem able to read it..
08:14:22 <DRMacIver> What is hq9?
08:14:23 <LoganCapaldo> seriously, just optimize those + calls :)
08:14:32 <Heffalump> DRMacIver: google finds it
08:14:56 <importantshock-_> DRMacIver: http://www.cliff.biffle.org/esoterica/hq9plus.html
08:14:57 <lambdabot> Title: HQ9+
08:15:00 <DRMacIver> Heffalump: Yes. But I assumed hair removal products were probably not what was being talked about.
08:15:15 <Heffalump> the top result for HQ9+ for me was that URL
08:15:35 <MarcWeber> Have you heard of a three catch method (scope of transactions ) ?
08:16:17 <DRMacIver> So it is. Interesting. I was under the impression that google ignored non-alphanumeric characters. (I searched for hq9)
08:16:47 <shapr> MarcWeber: Never heard of it, is it new?
08:17:54 <DRMacIver> (Also, please take appropriate snark about how annoying "google for it" answers are as read. Thanks)
08:18:01 <MarcWeber> shapr: I don't think so... Someone who is programming php did tell me about it.. Maybe he talked about catching Dirty Reads, Nonrepeatable Reads und Phantom Reads  ..) I think so.
08:19:39 <shapr> oh
08:23:05 <Ben`> how do you pronounce "monad"?
08:23:29 <importantshock-_> Ben`: like 'gonad', but with an m. is that wrong?
08:23:58 <masak> no, that's correct
08:24:08 <jbauman> i have to admit, it does seem somewhat disturbing when you put it that way
08:24:22 <Ben`> ah, ok
08:24:27 <Ben`> thanks :)
08:24:27 <mrd> I think I've said 'monad' out loud more times than 'gonad'
08:27:14 <importantshock-_> mrd: definitely.
08:27:21 <Cale> That's not quite how I pronounce it. The 'o' sound is more like 'ah'
08:27:29 <Cale> Similar to monoid.
08:28:09 <Cale> monad is a portmanteau between monoid and triad
08:28:28 <jbalint> how do you pronounce monoid
08:28:48 <Cale> mah-noid
08:28:59 <mrd> though, mo' noid sounds funnier
08:29:06 <Cale> hehe
08:30:27 <Cale> I suppose it's really mon' oid
08:30:44 <Cale>  /ËˆmÉ’nÉ”Éªd/
08:31:38 <Cale> Heh, Dictionary.com defines it with just a link to Groupoid, which is pretty wrong.
08:32:10 <Cale> haha, and it defines groupoid as "an algebraic system closed under a binary operation. Also called monoid. Compare group (def. 9), semigroup."
08:32:14 <taruti> Is it possible to easily recompile base for an existing ghc-installation?
08:32:14 <Cale> oops!
08:34:20 <Cale> I think that definition of groupoid sucks anyway. A better term for that is magma. "Groupoid" is a term better reserved for a small category in which all arrows have inverses.
08:35:34 <ddarius> Yay abstract algebra
08:35:36 <Cale> taruti: Somehow I expect that it's more difficult than it should be.
08:35:38 * importantshock-_ is lost
08:36:51 <Cale> importantshock-_: The mistake of the dictionary is that monoids are also required to have an identity element, so they're not quite the same thing as what they're calling a groupoid.
08:37:08 <importantshock-_> ah.
08:37:36 <Cale> Groupoid is an old term for what is now more often called a magma, the term groupoid has been stolen away by something which is a lot more group-like.
08:38:44 <taruti> hmm, ok.
08:39:15 <importantshock-_> still kinda confused, but i start advanced-ish math classes soon.
08:40:38 <Cale> Okay, a magma is just a set M together with a binary operation on it: (*) :: M -> M -> M, in Haskell-speak
08:40:51 <Cale> (and it's defined for every pair)
08:41:03 <ibid> no axioms?
08:41:08 <Cale> Right.
08:41:10 <ibid> ok
08:41:17 <importantshock-_> Cale: Alright, I get it so far.
08:41:36 <Cale> A semigroup is a magma which is required to satisfy the property that for all a,b,c in M, we have (a*b)*c = a*(b*c)
08:41:43 <Cale> that is, it's an associative magma
08:41:43 <ibid> Cale: why is it called a magma?
08:42:06 <Cale> ibid: I don't know - it's a name that Bourbaki came up with.
08:42:16 <ibid> Cale: bourbaki. 'nuff said :)
08:42:37 <ibid> Cale: never heard the term before, though, which is a bit of a surprise given it's a bourbaki term
08:43:11 <Cale> A monoid is a semigroup which has an identity element.
08:43:35 <Cale> That is, there is some element 1 in M such that for any a in M, we have a*1 = 1*a = a
08:43:43 <ibid> (then again, i haven't studied abstract algebra beyond the mandatory freshman course)
08:43:58 <roconnor> @go 1 pound in grams
08:43:58 <Cale> A good example of a monoid is lists under concatenation, with the empty list being the identity.
08:43:59 <lambdabot> 1 pound = 453.59237 grams
08:44:25 <Cale> Also, integers under either addition (with identity 0) or multiplication (with identity 1)
08:44:42 <Cale> importantshock-_: follow that?
08:44:58 <importantshock-_> Cale: yes.
08:45:11 <importantshock-_> thank you *so much*. haskellers are so damn nice it amazes me.
08:45:18 <Cale> Okay, so a group is a monoid where every element has an inverse.
08:45:47 <Cale> That is, it's a monoid G such that for any a in G, there is some b in G such that a*b = b*a = 1
08:46:04 <Cale> (where that 1 is the identity)
08:47:14 <Cale> The integers under addition are a group, but under multiplication, they aren't, because there aren't inverses.
08:47:30 <Cale> (under addition, the inverse of 3 is (-3), for example)
08:47:44 <LoganCapaldo> what about the rationals under multiplication?
08:47:57 <Cale> The rationals under multiplication are almost a group
08:48:06 <LoganCapaldo> ah
08:48:08 <LoganCapaldo> stupid zero
08:48:08 <Cale> 0 fouls things up a bit, because it's not invertible
08:48:17 <Cale> So if you remove 0, you'll have a group
08:48:47 <mudge> good morning
08:48:53 <importantshock-_> Cale: Alright, I get it.
08:48:54 <ibid> good evening
08:48:58 <Cale> Another example of a group is the set of moves that you can make on a Rubik's cube, under composition.
08:49:06 <LoganCapaldo> woah woah woah
08:49:15 <LoganCapaldo> now you're just messing with me :)
08:49:34 <Cale> For example, if you turn a face once, you can turn it back the other way.
08:49:42 <Cale> (and that's the inverse)
08:49:48 <LoganCapaldo> does that hold only for 3x3 cubes or for NxN cubes in general?
08:49:53 <Cale> In general.
08:49:54 <ibid> and do-nothing move is identity?
08:50:04 <Cale> In fact, any puzzle which you can't "break" is a group.
08:50:08 <Cale> right
08:50:13 <LoganCapaldo> and the inverse of the do nothing move is....
08:50:17 <LoganCapaldo> the do nothing move
08:50:18 <LoganCapaldo> :)
08:50:19 <Cale> right
08:50:31 <Cale> and it's obviously associative
08:50:45 <MyCatVerbs> Cale: I need to start logging this channel already. And you need to start TA-ing at the very least. :)
08:50:49 <Cale> hehe
08:51:18 <ibid> doesn't everybody already log everything in every channel they inhabit? :)
08:51:20 <MyCatVerbs> Monads are not always monoids, then?
08:51:32 <Cale> Monads are a funny generalisation of monoids
08:51:55 <Cale> In order to understand exactly the sense in which the definition of monoid has been generalised, you need a bit of category theory.
08:52:01 <gkr> Generalisation how?
08:52:03 <gkr> Ahp.
08:52:10 <MyCatVerbs> ibid: no, I stopped logging a while back because I used to occupy a channel in which the inhabitants were obsessed with discussing (in graphic terms) their sex lives. Which consisted mainly of themselves and their dogs.
08:52:12 * EvilTerran specifically copied down Cale's bit about the heirarchy a few minutes ago
08:52:20 <pjd> MyCatVerbs: Monad + Monoid = MonadPlus
08:52:26 <Cale> Well, actually, hmm, it's not quite a generalisation so much as transplantation
08:52:30 <MyCatVerbs> pjd: ah, handy.
08:52:32 <EvilTerran> o.Ã³
08:52:55 <Cale> You can generalise a monoid (in the category of sets), to a monoid-object (in an arbitrary category)
08:53:10 <phobes> I used to ask non math people "If you start with a solved rubix cube, and rotate the top face clockwise, then the left face clockwise, and repeat that forever, do you ever return to the solved cube?"
08:53:21 <Cale> and then a monad is a monoid object in the category of endofunctors on a fixed category.
08:53:31 <Cale> phobes: yes.
08:53:33 <phobes> It makes a good question
08:53:40 <importantshock-_> Cale: So what's the controversy/application of/for/by monoids/groups/etc.?
08:54:21 <ibid> MyCatVerbs: that would have been reason for me to leave the channel, not stop logging :)
08:54:23 <Cale> Well, groups are very important throughout mathematics, because just as numbers measure magnitudes, they measure symmetries.
08:54:42 <importantshock--> Interesting.
08:55:19 <MyCatVerbs> ibid: I did. And I've just started logging again - though restricted exclusively to #haskell 'cuz I don't feel like burning the disk space to store everything else.
08:55:19 <pjd> MyCatVerbs: re. what i wrote above, all monads are also monoids in a different sense
08:55:22 <importantshock--> off topic - my internet connection keeps crapping out, so i never disconnect from IRC properly. is there a way to kick all the ghosts that are hogging my nick?
08:55:27 <pjd> which is what Cale is talking about, IIUIC
08:55:53 <ibid> MyCatVerbs: well, none of my business. it was a joke anyway :)  (that everybody does it, that is.  *i* do it.)
08:55:55 <Cale> importantshock--: /msg nickserv ghost <nick> <password>
08:56:01 <MyCatVerbs> importantshock--: /msg nickserv ghost nick password
08:56:11 <importantshock--> Thanks
08:56:28 <MyCatVerbs> importantshock--: better yet, in most IRC clients, /alias ghost msg nickserv ghost importantshock yourpassword
08:56:51 * MyCatVerbs has it bound to, uh, /harikari, if memory serves. :)
08:57:56 <Cale> Thoughout mathematics, we study various kinds of objects, and structure preserving maps between them. For example, sets and functions, vector spaces and linear transformations, groups and group homomorphisms (which I haven't yet introduced), topological spaces and continuous maps, and so on.
08:58:52 <Cale> If we restrict our attention to a single such object and just consider the structure-preserving maps from that object to itself, we get in some sense the collection of symmetries of that thing.
08:59:00 <Cale> Those symmetries form a group.
08:59:03 <ddarius> categories and functors ...
08:59:11 <Cale> ddarius: right.
08:59:37 <ddarius> Cale: + isomorphism
08:59:49 <ddarius> Otherwise you'd get a monoid.
09:00:06 <Cale> Yeah, sorry, right :)
09:00:22 <Cale> The collection of *invertible* structure-preserving maps
09:00:42 * MyCatVerbs is somewhat lost.
09:00:47 <phobes> structure-preserving maps with structure-preserving inverses :)
09:00:48 * MyCatVerbs rereads.
09:01:22 <MyCatVerbs> phobes: the inverses would surely have to be structure-preserving too, otherwise they wouldn't be inverses. Shurely?
09:01:30 <phobes> not so!
09:01:42 <Cale> phobes: depends on your perspective here
09:01:58 <MyCatVerbs> How can the inverse of a structure-preserving operation not be structure-preserving?
09:02:10 <Cale> MyCatVerbs: when treated as a plain old function
09:02:24 <Cale> MyCatVerbs: there might be an inverse which isn't structure preserving anymore
09:02:36 * phobes tries to construct an example
09:02:41 <Cale> For example, there's a continuous map from an interval to the circle
09:02:53 <phobes> ya that works
09:02:54 <Cale> Say, the interval [0,1)
09:03:08 <MyCatVerbs> Map? Mapping?
09:03:08 <Cale> and it's got an inverse as a plain function
09:03:46 <phobes> Cale: I was just trying to be pedantic ... but ya if you say "structure preserving map" that seems to imply that you are considering more general maps
09:03:47 <Cale> Just send t in [0,1) to (cos(2 pi t), sin(2 pi t))
09:04:13 <Cale> Then that's invertible as a function, but not invertible as a continuous map.
09:04:30 <Cale> Because to go back, you have to "tear" the circle.
09:05:27 <MyCatVerbs> Huh?
09:05:40 <Cale> Sorry if that makes no sense, it's just a pedantic point anyway :)
09:05:49 <mrd> is that really structure preserving going forward?
09:06:02 <ddarius> mrd: Yes.
09:06:05 <phobes> mrd:  if your structure is continuous functions
09:06:23 <ddarius> You can take a string and lay it on a circle, you can't take a circle and lay it on a string.
09:06:38 <mrd> to take a string and lay it on a circle you have to make a connection
09:06:53 <Cale> mrd: right, but that's still allowed by continuity
09:06:59 <mrd> what you're saying is "connection"-making is one-way
09:07:11 <phobes> continuity requires that all points in a small neighborhood map to points in a small neighborhood
09:07:22 <Cale> So you have to be a little careful about what's considered an isomorphism
09:07:25 <phobes> points in neighborhoods of the endpoints of the string don't include the opposite ends of the string
09:07:41 <Cale> We want structure-preserving maps which have structure-preserving inverses, as phobes pointed out.
09:07:46 <phobes> but going the other way, neighborhoods of each point of a circle include points on either side
09:09:26 <Cale> okay, so back to what I was trying to say, you can form a group out of those maps from an object to itself which are structure preserving and have structure preserving inverses
09:09:42 <Cale> and intuitively, these in some sense capture the "symmetries" of that object
09:10:20 <Cale> To make that more concrete, we could take our objects to be figures drawn in the plane, and structure-preserving maps to be functions which preserve the distances between points.
09:10:26 <Cale> (isometries)
09:10:39 <mrd> like rotation
09:10:42 <Cale> right
09:10:47 <Cale> and flipping the figure over
09:11:15 <Cale> The collection of such maps which send a figure to itself is exactly what we normally think of as its symmetries.
09:11:54 <Cale> If you have a triangle, there are six symmetries -- three rotations, and three flips.
09:12:04 <mrd> translation preserves the distance between points
09:12:20 <Cale> (where one of the rotations is nothing at all)
09:12:55 <Cale> mrd: yes, but unless the figure you've drawn is infinitely large, translation won't send it back to itself
09:12:56 <phobes> mrd:  in general you are right, but in cales example of taking some figure in the plane to itself, your figure would have to have infinite extents for translation to be a symmetry
09:13:24 <mudge> morning
09:13:27 <mudge> or evening to some
09:13:33 <Cale> Indeed, that idea really does capture the symmetries of tilings.
09:13:51 <conal> mudge: morning :)
09:14:34 <mudge> question: does anyone know what the c-like macros are about in ghc haskell source?
09:14:40 <Cale> So in one sense, groups are really important because they let us take things which are large and complicated and say "well, all those features are the same as this one, under symmetry"
09:14:44 <mrd> it runs it through the c preprocessor, mudge
09:15:21 <ddarius> They provide a weaker notion of "the same".
09:15:28 <Cale> and really formalise the ways in which things can be symmetrical
09:15:43 <mrd> the rational numbers under multiplication?
09:15:58 <Cale> mrd: without zero?
09:16:01 <MyCatVerbs> mrd: provided you remove zero? :)
09:16:05 <mudge> mrd:  interesting,   is this a usual thing?   when you compile haskell code,  does GHC run the code throught the C pre-processor?
09:16:08 <mrd> er yea
09:16:09 * MyCatVerbs abuses the pageup key. ;0
09:16:11 <MyCatVerbs> ;)
09:16:18 * mrd was thinking of the positive rationals
09:16:30 <mrd> mudge: -cpp option
09:16:34 <Cale> Yeah, you can think of those as scaling factors, if you'd like.
09:16:36 <phobes> mrd: forming a group?
09:16:46 <mrd> mudge: cpp is a standalone program
09:16:48 <mudge> but haskell has its own macros,  template macros,   why doesn't it use this?
09:16:54 <mudge> mrd:  oh interesting
09:17:11 <Cale> IIRC, it uses a slightly modified cpp though.
09:17:23 <mrd> phobes: yes
09:17:34 <Cale> I seem to recall that there was some issue with string gaps, or something like that
09:17:43 <mrd> yea something
09:17:58 <ddarius> mudge: TH isn't portable, is overkill and would be trickier and more annoying to use.
09:18:09 <mrd> also TH wasn't around way back
09:18:25 <mudge> ddarius:  oh, that makes sense
09:19:13 <EvilTerran> Cale, there'd also be difficulties with things such as comment markers appearing in code
09:19:25 <Cale> Monoids seem a bit less important than groups to mathematicians (at least on their own), but they're a favourite of computer scientists because of the ways in which they show up in the theory of formal languages.
09:19:54 <ddarius> Cale: Particularly state machines.
09:20:01 <Cale> yeah
09:20:21 * mrd did some work with transition monoids last semester
09:20:25 * EvilTerran is reminded of someone he knows trying to use cpp for HTML templates, and wondering why everything on a line with a URL after the "http:" kept disappearing
09:21:03 <ibid> EvilTerran: using a c99 or c++ cpp? :
09:21:11 <ibid> )
09:21:37 <mrd> @where logs
09:21:37 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
09:21:45 <EvilTerran> indeed. the solution happened to be to write better HTML, and quote your attributes.
09:22:03 <EvilTerran> <a href=http://oh dear everything else is a comment
09:22:35 <EvilTerran> <a href="http://..."> works fine, though, as well as being better practice
09:22:47 <ddarius> And required by xhtml
09:23:05 <Cale> Also, once you know what monoids and groups are, it's really easy to summarise what a ring is. (which is a way of formalising what we mean by 'number')
09:23:12 <EvilTerran> indeed.
09:23:54 * EvilTerran imagines there'd be a more-in-the-spirit-of-XML solution involving XSL
09:24:07 <ibid> a ring is an object that people give to each other to signify marriage. i can see how groups come into that, but monoids?
09:24:11 <ibid> :)
09:24:21 <ddarius> Hmm, ring == bicartesian category with one object?
09:24:35 <EvilTerran> <xslt:embed href="..."> or something
09:24:37 <Cale> A ring is something which is both an Abelian (commutative, a+b = b+a) group under an operation called addition, and a monoid under an operation called multiplication, such that a*(b+c) = (a*b) + (a*c) and (a+b)*c = (a*c) + (b*c)
09:24:46 <mrd> perhaps mathematician marriages begin as monoids
09:25:08 <ddarius> semiring or some such, not ring?
09:25:28 <mrd> do you compute roots of unity on the first date?
09:25:29 <Cale> So it's simultaneously a group and a monoid, and the monoid behaves nicely with respect to the group.
09:25:32 <wli> It's not a monoid under multiplication; identities are not required.
09:25:41 <Cale> wli: yes they are!
09:25:45 * ddarius computes roots of unity before the first date.
09:25:55 <wli> I refer you to Hungerford.
09:26:28 <Cale> wli: I know about the various generalisations, and I believe we've had this argument before, but I'd prefer to call such things ideals.
09:26:40 <MyCatVerbs> ibid: polygamy is a monoid. Just define (*) as "is-married-to" and the identity element as "nobody"
09:26:44 <wli> And can dredge up more (albeit slowly, since it's months between trips to the library).
09:27:05 <wli> Cale: Your preferences have no bearing on what I actually see done.
09:27:17 <EvilTerran> what about fields?
09:27:18 <ibid> MyCatVerbs: so nobody is married to nobody, making everybody married to somebody? :)
09:27:31 * mrd notes that precisely one year ago this moment, he was also chatting about random crap on #haskell
09:27:39 <MyCatVerbs> ibid: reducto ad absurdium! XD
09:27:53 <Cale> In precisely none of my courses that I've ever taken has it ever been important to include things with no identity under multiplication as rings.
09:27:53 <ibid> MyCatVerbs: the very thing :)
09:27:55 <MyCatVerbs> mrd: I strongly doubt it.
09:27:55 <ddarius> EvilTerran: What about fields?
09:28:22 <MyCatVerbs> mrd: I would bet at least one beer that you're six hours out because you forgot to take into account the fact that one year is ~365.25 days, not 365 :)
09:28:22 <ibid> MyCatVerbs: hum, how can is-married-to produce a person?
09:28:23 <Cale> (and I've taken courses in noncommutative algebra and such)
09:28:33 <mrd> MyCatVerbs: sidereal or solar?
09:28:41 <EvilTerran> ddarius, how do they relate to rings etc?
09:28:55 <MyCatVerbs> ibid: it doesn't, it produces a marriage. Just view single people as married to nobody. :)
09:28:57 <Cale> There seem to be a few mathematicians which generalise in that way, but there aren't so many, and it breaks lots of nice things.
09:29:09 <wli> Cale: A generalization would be a distinct concept,, e.g. semirings.
09:29:09 <phobes> EvilTerran:  With a field, the non-zero elements form a group under multiplication
09:29:22 <MyCatVerbs> mrd: sidereal?
09:29:32 <mrd> by-the-stars
09:29:41 <EvilTerran> so a field is a ring with multiplicative inverses?
09:29:44 <Cale> wli: yeah, in this case, the generalisation is to ideals or if you want, pseudo-rings.
09:29:47 <wli> Cale: There's no generalization involved; a ring is a ring and it need not necessarily have a multiplicative unit.
09:29:48 <ibid> MyCatVerbs: no, i mean, (*) :: Person -> Person -> Person.  so sue is-married-to mike produces somebody
09:29:50 <phobes> EvilTerran:  yep
09:29:53 <ibid> MyCatVerbs: their child perhaps?
09:29:58 <Cale> wli: You're just being difficult :)
09:30:02 <ibid> MyCatVerbs: but then marriages have only one child :)
09:30:05 <Cale> (so am I, of course)
09:30:17 <MyCatVerbs> ibid: you evidently haven't met my grandparents.
09:30:22 <Cale> But I'm at least following the standard which most people go by.
09:30:23 <ibid> MyCatVerbs: do tell
09:30:29 <EvilTerran> differences in terminology are irrelevant!
09:30:29 <wli> Cale: You could call it bad terminology like the screwups with Haskell's Prelude but the convention is non-negotiable.
09:30:38 <ddarius> EvilTerran: Except for a == 0
09:30:44 <EvilTerran> define your ambiguous terms before you start, then everyone's happy!
09:30:45 <wli> Cale: The standard is that rings need not have identities.
09:30:46 <EvilTerran> geez.
09:30:48 <Cale> wli: My convention is the one which everyone around here uses.
09:30:51 <ddarius> A field is a commutative division ring.
09:31:11 <phobes> wli:  Ya, I've frequently heard people say "henceforth, when I say 'ring', I mean 'ring with identity'."
09:31:13 <MyCatVerbs> ibid: four aunts+uncles on one side of the family and six on the other. That is *not* one child per marriage. :)
09:31:30 <ibid> MyCatVerbs: hence, another absurdum for your theory :)
09:31:47 <MyCatVerbs> ibid: cu-er, I mean, good thought.
09:32:01 <wli> Cale: Yes. It would save people the pain of doing that if the standard were that rings had identities, but it is not.
09:32:06 <EvilTerran> could the powerset of people be a group under marriage?
09:32:34 <ibid> EvilTerran: ah, nice!
09:32:47 <MyCatVerbs> EvilTerran: well, if we married _everybody_, the result would be entirely compatible with the observation that powersets are always much bigger than the original set. :)
09:32:52 <Cale> wli: Apart from a few books and a fairly small subset of mathematicians it really is the standard to include 1
09:34:16 <wli> Cale: That is not in the definition of a ring. That is merely what's worked with. One could argue that it was a mistake not to insist that rings be unital when the convention was devised but not that rings are defined so that all rings are unital.
09:34:18 <MyCatVerbs> mrd: how do sidereal years differ from solar years, anyway? I'd've thought you'd come out with exactly the same time period either way, save maybe for some error thirteen or so orders of magnitude on account of the fact that the galaxy we're in is rotating.
09:34:27 <EvilTerran> wli, Cale, I'm sure i've seen you two have this argument several times before. it seem that you each operate in circles with subtly different standard meanings of "ring", and no amount of debate between you two is going to affect what your associates do. I don't see the need to flog that dead horse any further (except maybe on #haskell-blah ;] ).
09:35:00 <MyCatVerbs> EvilTerran: no, they operate in _rings_ with different meanings of "ring", which is sillier.
09:35:07 <Cale> wli: It's not like there's some central committee standardising the definitions in mathematics.
09:35:16 <EvilTerran> MyCatVerbs, hehe.
09:35:18 <Cale> wli: It's really okay for things to have different definitions.
09:36:05 <Cale> For example, whether the natural numbers include 0 or not.
09:36:08 <mrd> MyCatVerbs: well what do you measure the solar year by?
09:36:21 <Cale> or this point about whether rings have a multiplicative identity or not
09:36:32 <mrd> MyCatVerbs: the time from aphelion to perihelion and back?
09:36:38 <phobes> And we can use pi for 2pi (ie pi = 6.28...)
09:36:52 <Cale> They're things which are defined differently in different contexts, but in most contexts, the naturals include 0, and rings include an identity.
09:36:56 <MyCatVerbs> mrd: stick a camera on each of the poles, see when each hits its respective 24-hour-night and 24-hour-day.
09:37:00 <mrd> that is a few minutes off from the sidereal year which is measured using the stars as a fixed reference
09:37:16 <mrd> MyCatVerbs: they spend 24-hours in night and day for many months
09:37:25 <phobes> The number theorists don't include 0 in the nats
09:37:30 <Cale> phobes: right
09:37:38 <Cale> phobes: (and it's pretty much only them)
09:38:12 <Cale> I think the people who like rings not to require an identity are mostly analysis people.
09:38:15 <MyCatVerbs> mrd: track the Sun's position properly then, to work out exactly which day happens to be the summer solstice.
09:38:30 <wli> That's an irritating inconsistency I don't have a way to deal with. There is a solid bloc with a variant convention.
09:38:47 <MyCatVerbs> (As in, look at the angle it makes with the horizon and see which day that angle was greatest upon, across the year.)
09:39:01 <Cale> (because all the examples I've seen where that's a natural generalisation to make have been examples in analysis)
09:39:19 <mrd> I think I prefer the apsides method
09:39:39 <Cale> wli: The solution is just to write down which definition it is that you're using each time.
09:39:52 <mrd> MyCatVerbs: also keep in mind that the orbit of the earth does change over time
09:40:25 <MyCatVerbs> mrd: this is true, but measuring it to the nearest day provides sufficiently little precision that I wouldn't care either way for a looooong time :0
09:40:25 <Cale> Or just indicate the convention with "The naturals are taken herein to include 0."
09:40:30 <MyCatVerbs> s/:0/:)/
09:40:38 <Cale> At least, if it's potentially an issue.
09:41:45 <Cale> Another "big" one is the axiom of choice. About 1% of all mathematicians don't want to use it -- so usually they have to say something about that.
09:42:18 <Cale> Heh, my noncomm prof said that if you don't accept the axiom of choice, you're not a mathematician, you're a logician.
09:42:37 <phobes> And if you don't accept the law of the excluded middle, you're an idiot :)
09:43:07 <Cale> Well, probably logician would again be the right term :)
09:43:14 <mrd> bastards!
09:43:33 <psykotic> logician or computer scientist :)
09:43:34 <mrd> ZF may be independent of C but not all logical systems are
09:43:55 <phobes> mrd:  not all are independent of C?
09:44:04 <psykotic> leaving out excluded middle is useful in a lot of contexts
09:44:06 <mrd> well inconsistent with
09:44:19 <psykotic> for example, in epistemological logics
09:44:25 * mrd excludes the excluded middle
09:44:34 <phobes> (the idiom comment was a joke all :)
09:44:58 <mrd> I can still be an idiot though.
09:45:39 <phobes> And there's a difference between studying systems with no excluded middle and then not believing that it's true
09:46:00 <psykotic> it's not even clear what "believing it is true/false" means as a statement about reality
09:46:15 <phobes> yes, I realize I'm in murky waters with that
09:46:30 <Cale> Of course, none of it is "true" in any greater sense than in the particular contexts in which we define truth.
09:47:13 <Cale> As far as I'm concerned "truth" and "falsity" have no existence apart from being formal labels which we apply to some statements, usually in some coherent fashion.
09:47:44 * mrd sticks to formalism
09:48:02 <Cale> That is, I'm even a bit of a formalist when it comes to the "real" world.
09:48:10 <psykotic> you're not a mathematical realist?
09:48:16 <Cale> Not at all.
09:48:40 <Cale> However, I will defend some conventions in the appropriate contexts.
09:48:52 <Cale> Because I think they're worthwhile conventions.
09:49:01 <psykotic> the problem with a purely formalistic view is that it doesn't help explain all the "coincidences"
09:49:09 <dolio> Cale: You looked at "What Is Mathematics, Really?" at all?
09:49:17 <psykotic> in a sense, you're not explaining anything by it
09:49:23 * dolio skimmed through it at the bookstore.
09:49:25 <Cale> What is there to explain?
09:49:29 <phobes> Certainly you can redefine true / false to mean whatever you like... but the real world is what it is
09:49:40 <mrd> what is it?
09:49:40 <psykotic> the "unreasonable effectiveness of mathematics" as it were
09:49:47 <phobes> what it is
09:50:08 <phobes> psykotic: and the "unreasonable effectiveness of the law of the excluded middle"
09:50:12 <psykotic> hehe
09:50:30 <Cale> Oh, that's more to do with science picking the right structures out of mathematics, and the definitions and conventions that we choose to study being based on the applications which we'd eventually like to treat.
09:50:51 <mrd> physicists and engineers play fast-and-loose with math
09:51:04 <SamB_XP_> and mathematics being explored, believe it or not, based partly on usefulness...
09:51:09 <mudge> mrd: where's your blog/website?
09:51:10 <mrd> my favorite is when my physics teacher looks at a term and says "ok, that's insignificant -cross out-"
09:51:13 <ddarius> Scientists picked the right structures out of mathematics because mathematics was originally made to deal with the things physics (particularly) deals with.
09:51:15 <Cale> SamB_XP_: right
09:51:20 * ddarius found http://www.amazon.com/Where-Mathematics-Comes-Embodied-Brings/dp/0465037704 interesting.
09:51:25 <lambdabot> http://tinyurl.com/27j7bw
09:51:45 <mrd> mudge: i sometimes post things to sequence.complete.org
09:51:50 <ddarius> mrd: That's the secret of physics.
09:52:22 <mrd> ddarius: it does make life a lot easier!
09:52:25 <wli> ddarius: Hmm. That's primarily analysis (esp. integrodifferential calculus).
09:52:37 <Cale> I don't think there's any really deep magic going on there. I suppose the most subtle point is that the things that we find natural as mathematicians are at least somewhat biased by our own humanity, and hence by the real world, even irrespective of direct physical applications.
09:52:52 <Cale> Mathematics is not something which exists without us though.
09:52:58 <ddarius> wli: You are going to tell me geometry didn't come out of understanding the physical world?
09:52:58 <psykotic> cale: well, take euclidean geometry for example.
09:53:05 <psykotic> cale: there is something objectively simple about it.
09:53:25 <Cale> psykotic: It's actually pretty complicated when you get down to formalising it completely.
09:53:26 <mudge> mrd: oh cool
09:53:26 <wli> ddarius: I would say yes, but that it's below a level that should be deemed physics.
09:53:41 <psykotic> cale: i know, i've formalized hilbert's book in coq. :)
09:53:50 <Cale> (the classical 5 axioms are not quite enough)
09:53:51 <psykotic> it's quite simple, comparatively speaking.
09:53:57 <Cale> yeah
09:53:59 <mrd> Cale: excluding parallel?
09:54:05 <Cale> mrd: including
09:54:07 <phobes> Cale:  My point is that you can write down your formal system that doesn't allow for the law of the excluded middle to apply.  But then you will turn around and apply that law informally when studying your system at a meta level.  ie you will make judgements such as "well, either I can prove this statement or I can't".
09:54:10 <psykotic> euclid is of course complete bollocks
09:54:15 <psykotic> i mean the original treatment.
09:54:20 <ddarius> mrd: Parallel is the "fifth"
09:54:28 <psykotic> even the first proposition doesn't follow from the axioms :)
09:54:32 <Cale> phobes: Not necessarily ;)
09:54:42 <psykotic> actually, i mean the first construction. the one where he construct an equilateral triangle on a given segment.
09:54:56 <Cale> phobes: But I'll admit that doing that is astoundingly uncommon.
09:55:02 <SamB_XP_> psykotic: hmm?
09:55:10 <psykotic> SamB, hmm what?
09:55:32 <ddarius> psykotic: Have you considered that Euclidean geometry is easy to formalize because significant aspects of it are built into the systems we use to formalize them?
09:55:37 <SamB_XP_> I don't remember the axioms :-(
09:55:43 <Cale> There's no guarantee that the circles intersect to form the point off the segment.
09:55:46 <psykotic> the construction proceeds by drawing equi-radial circles centered at the segment end points
09:55:48 <mrd> phobes: it's a distinction between proof and truth.  in your formal proofs, you don't apply excluded middle.  but that doesn't mean you can assert a proposition to be both true and false simultaneously.
09:56:14 <Cale> mrd: You can construct systems in which statements are both true and false.
09:56:24 <psykotic> he implicitly uses that the circles can be made to intersect off the line itself, which does not follow from his axioms
09:56:34 <Cale> mrd: Any classical-like such system will be boring though.
09:56:38 <mrd> Cale: incomplete ones
09:56:45 <Cale> Inconsistent ones.
09:56:47 <phobes> mrd:  Inconsistent you mean :)
09:56:48 <mrd> and those
09:56:52 <Cale> Incomplete is good, we like incomplete :)
09:57:07 <mrd> you didn't say simultaneously ;)
09:57:17 <ddarius> The logic corresponding to Haskell types is complete.
09:57:31 <Cale> Well, yeah, sometimes completeness is preferable.
09:57:38 <psykotic> ddarius, you mean propositional logic?
09:57:42 <psykotic> (regarding your question)
09:57:49 <mrd> an independent proposition could  be added to an incomplete system either as true or false
09:57:55 <Cale> When you're talking about a system in which to do mathematics though, completeness tends to give you inconsistence.
09:57:57 <Cale> y*
09:57:59 <ddarius> psykotic: Yes (and the logics built on it)
09:58:24 <ddarius> Cale: Completeness gives you inconsistency in Haskell's case too.
09:58:42 <phobes> Cale:  Of course to even talk about completeness you need to have a model in mind ... many systems are complete when viewed with one semantics, and incomplete with another
09:58:51 <Cale> ddarius: but inconsistency is perhaps not as large a problem, because it's not classical logic
09:59:34 <ddarius> Cale: The inconsistency in Haskell is exactly the same problem?!  And adding classical aspects would not make it any worse.
09:59:43 <ddarius> (Or would it... ?)
09:59:50 <ddarius> Nah.
09:59:59 <ddarius> Not in this regard at least.
10:00:06 * EvilTerran has never been happy with the idea of euclidean geometry. it seems to me that that sort of thing would be *impossible* for fully formalise
10:00:12 <Cale> Oh, right, bottom :)
10:00:20 <Cale> So everything is true.
10:00:25 <ddarius> Yep.
10:00:30 <lelf> oh
10:01:01 <wli> Ultimately it comes down to whether truth and falsity are the significant aspects or whether other things are.
10:01:02 <Cale> I was thinking about the case which excludes bottom as a proof, but of course, it's not quite right to do that.
10:01:24 <Cale> I suppose in Haskell's case it doesn't matter so much that all things are true because it's the proofs that we're really concerned with.
10:01:32 <wli> In a number of intuitionistic contexts truth and falsity are not the interesting parts so you can do that.
10:01:36 <Cale> Not all proofs are considered equal here.
10:01:54 <ddarius> Hence Curry-Howard correspondence and not Curry-Howard isomorphism.
10:02:39 <psykotic> ddarius, to get back to the larger point i was trying to make, the fact that the logical approach works at all is not clear. it seems inevitable, doesn't it? why isn't there even anything like an alternative? there's something strangely metaphysical about that.
10:02:45 <Cale> Whereas in mathematics, at some level you don't care about how things are proved, but simply what is true. (Perhaps that's not entirely right to say though, since people really do care about how nice their proofs are.)
10:02:54 <psykotic> err, s/is not clear/it isn't clear why that is/
10:03:11 <mrd> which is why excluded-middle is generally accepted in math
10:03:23 <ddarius> Cale: Until dependent types make there entrance...
10:03:26 <psykotic> ddarius, so unless you put it down to a physiological limitation of our brains as evolved, etc, it seems hard to explain. and i find the biological explanation unsatisfying and unlikely.
10:03:33 <Cale> psykotic: There are alternatives, but people agree on one because it eases communication.
10:04:01 <Cale> psykotic: I have no doubt that *very* different looking logics and mathematics could be just as applicable.
10:04:04 <psykotic> cale: what are the alternatives? even though there are different logical systems, they still share their character in common. it's not like constructivism is not mathematics.
10:04:15 <phobes> Cale:  For example :)
10:04:17 <wli> Some of the physiological limitations of the brain are really stupid.
10:04:17 <psykotic> but it would still be mathematics and would look much like mathematics, as much as i can envision it.
10:04:21 <mrd> i always felt that character was the need to preserve consistency
10:04:31 <psykotic> notwithstanding silly things that wolfram has said :)
10:04:33 <ddarius> psykotic: There is the very way we look at truth too.
10:04:38 <wli> For instance, people can largely only track 5 or 6 moving objects at a time.
10:04:58 <psykotic> wli: but we can still conceive of a million moving objects at once.
10:05:09 <psykotic> well, in some abstract sense.
10:05:13 <Cale> I think it's mostly that people don't feel a need to strike out on their own and start a new system because the system we have has lots of interesting things to work on inside it already.
10:05:21 <mrd> wli: but the brain can distinguish those objects and categorize them, which computers still cannot really do
10:05:48 <wli> mrd: Well why not 10? Or 500?
10:05:50 <ddarius> mrd: We expect too much of computational intelligence.
10:05:57 <psykotic> cale: so you're essentially saying that our current mathematical landscape and its overall character is just a queer provincialism?
10:06:02 <phobes> Cale:  I disagree.  Logic didnt form because some guys wrote down some axioms at random ... they followed their intuition about the way things are
10:06:04 <Cale> psykotic: yep
10:06:15 <psykotic> that just seems utterly wrong to me.
10:06:17 <Cale> psykotic: But not that strange, if you think about it.
10:06:17 <mrd> Cale: I don't think some alternate axiomization would change fundamentals
10:06:19 <psykotic> but of course if you're right, that's what i would feel :)
10:06:30 <ddarius> phobes: Our intuition is largely shared, in large part because of our shared experiences with reality.
10:06:45 <psykotic> mrd: when i'm referring to "alternatives" i'm thinking of something that isn't deductive, axiomatic, whatever
10:06:48 <wli> mrd: It seems to be due to dumb physical limitations like the size of the head at birth vs. the female hip and carrying the weight of the head on the neck.
10:06:53 <phobes> ddarius:  Right, which is why this is like the question of "define universe and give three examples"
10:06:54 <psykotic> something completely different in character, not just particulars
10:06:55 <ddarius> psykotic: Exactly.
10:07:06 <mrd> wli: lots of evolutionary baggage, sure
10:07:17 <Cale> psykotic: oh, I'm still thinking of at least moderately formal alternatives.
10:07:35 <psykotic> i'm thinking of something much more exotic.
10:07:49 <mrd> psykotic: do you think you could design more powerful computational devices just by "thinking differently"?
10:07:49 <Cale> psykotic: Things which you might be able to shoehorn into considering them to be string rewriting systems, if a little awkwardly.
10:07:58 <psykotic> before you get to particular mathematical applications, you have to answer why the axiomatic method is so successful to begin with.
10:07:59 <ddarius> psykotic: It's quite possible you would not even consider such a thing mathematical.
10:08:08 <psykotic> ddarius: i know. and that's sort of the point.
10:08:23 <wli> mrd: Not baggage. Physical limitations. And they go on, for instance, the brain burns a lot of calories, and supporting it in terms of heat dissipation, getting glucose to it, etc. make for similar sorts of physical limitations as supporting its weight and getting the thing through females' hips.
10:08:24 <phobes> Cale:  There are certainly lots of consistent formal systems.  Could you just pick one of these and call it "another math"?
10:08:31 <Cale> phobes: yes
10:08:53 <phobes> Cale: I don't see the value in that.  Our math is special :)
10:08:55 <ddarius> phobes: But that already (arguably) has some of the "old math" built into it.
10:09:02 <mrd> wli: of course. the brain also imposes a great cost on the use of resources in the body.
10:09:06 <Cale> Our math is special only because we've worked on it so much.
10:09:25 <Cale> and we already know lots about what's inside it, and have named lots of the parts
10:09:30 <ddarius> Cale: I'd say it's special for reasons somewhat stronger than that.
10:09:31 <psykotic> but you're using "our math" in a narrow sense
10:09:53 <psykotic> the particular axiomatization of plane geometry or whatever--sure, in many cases that's an accident.
10:09:56 <Cale> I could use it in a somewhat wider sense without harming things.
10:09:58 <psykotic> and there are in fact numerous alternatives.
10:10:10 <Cale> I could mean all formal systems which we've explored.
10:10:12 <psykotic> but once you get to the very foundations
10:10:15 <psykotic> okay
10:10:16 <mrd> wli: it's evolutionary baggage in the sense that "this is how we developed" instead of appearing out of incubation tanks in which case things might be different
10:10:17 <wli> mrd: The answer I've seen come out of this seems to be that human cognitive capabilities have hard limits in evolutionary contexts.
10:10:29 <Cale> Those ones are special by virtue of the fact that we know something about them already.
10:10:29 <phobes> Cale:  Well, it corresponds with reality.  Like if early man started trying to count in Z_5, it just wouldn't have worked
10:11:02 <ddarius> Indeed, with 5 fingers, Z_6 is the right way to go!
10:11:12 <phobes> hehe ya I meant Z_6 :)
10:11:16 <psykotic> right, so that's a great example.
10:11:17 <Cale> phobes: sure -- but that's something for science to figure out.
10:11:22 <psykotic> wouldn't you agree there is something inevitable about natural numbers
10:11:29 <Cale> You've picked a mathematical model, and it has limitations.
10:11:35 <wli> mrd: The discussions I've seen suggested that a number of artificial assistance measures like incubation tanks would be insufficient because there are too many different kinds of limits involved.
10:11:36 <psykotic> it falls out whenever you can discretize anything
10:12:03 <mrd> wli: i didn't mean incubation tanks now -- after we evolved to be born from woman -- but entirely
10:12:18 <Cale> The natural numbers absolutely do not correspond exactly to real world counting.
10:12:29 <ddarius> psykotic: If we lived in a universe with only a (perhaps relatively small) number of things, natural numbers may well not have arisen.
10:12:38 <mrd> the matter is not the natural numbers but countable sets
10:12:40 <psykotic> ddarius, it would still exist in potentia as a completion
10:12:44 <Cale> There are natural numbers which are far larger than the number of particles in the observable universe.
10:12:48 <psykotic> as a limit if nothing else
10:13:02 <ddarius> psykotic: Define "exist".  The limit of counting would be counting everything.
10:13:11 <phobes> Cale: Why limit yourself to counting particles?
10:13:31 <psykotic> whether or not its denizens could conceive of it, i would say the natural numbers as a concept is latent in any context that admits discretization, even if imperfect
10:13:36 <mrd> count combinations of particles -- there, infinite
10:13:47 <mrd> kleene closure of the set of particles
10:13:59 <Cale> What if the universe was so simple that it could not permit the axiomatisation of the natural numbers to exist?
10:14:16 <psykotic> right, i can conceive of that in some sense
10:14:26 <psykotic> but there is something inevitable once you get to a certain level of complexity
10:14:30 <phobes> Then it wouldn't be a complicated enough system to support self reflective life
10:14:34 <psykotic> and there is also the question of internal vs external viewpoints
10:14:37 <Cale> I don't really think it's inevitable
10:14:41 <ddarius> phobes: Probably not.
10:15:24 <Cale> Maybe in some universes, counting is unimportant.
10:15:37 <psykotic> cale: well, inevitable means unavoidable, so not in that sense. but in the same way that the natural numbers arise naturally in "mathematics", that's what i mean.
10:15:47 <wli> Another good question might be what the real numbers are doing here.
10:15:48 <ddarius> If you couldn't distinguish anything from anything, that would be one case.  You'd have 1 and that's it.
10:15:52 <Cale> Certainly in some societies, counting isn't percieved as important.
10:16:14 <wli> If the universe is discrete, real numbers are essentially figments of people's imaginations.
10:16:21 <Cale> I can imagine a society which has something like graph theory, but no natural numbers.
10:16:22 <ddarius> wli: Yes.
10:16:26 <mrd> wli: what's "pi" then?
10:16:28 <psykotic> wli: right, but they still arise as idealizations.
10:16:29 <phobes> alright, I have to leave.  Let me know if you guys work out the nature of existence :)
10:16:32 <ddarius> Mathematics is built on the figments of our imagination.
10:16:41 <wli> mrd: That's part of the question.
10:16:45 <Cale> ddarius: Exactly
10:16:53 <psykotic> and just like there isn't an actual infinity, we can still conceive of a potential one. so i don't find these arguments about the limitation of the "universe" too convincing.
10:16:58 <Cale> It's something which *seems* natural to us.
10:17:06 <ddarius> Cale: Our imagination is built on our perception of reality.
10:17:07 <EvilTerran> Cale, surely, if you've got the concept of graphs, you've got the concept of different nodes
10:17:09 <Cale> Because we've formalised all the ideas which seem natural to us :)
10:17:25 <phobes> Cale: And I can imagine some guy inventing the naturals and making a killing off of them in that society
10:17:33 <EvilTerran> and then, from that, the desire to enumeate a bunch of nodes unambiguously becomes interesting
10:17:35 <Cale> But it's really not easy to say the extent to which that *must* happen.
10:17:55 <Cale> With very different kinds of creatures, perhaps very different kinds of "mathematics" would arise.
10:18:16 <ddarius> Cale: I do think that large chunks of mathematics will be rather "universal".
10:18:29 <ddarius> But it would be interesting to be mistaken.
10:18:40 <psykotic> ddarius, if there is anything ultimately universal, then you're still left with an explanatory burden as far as this overall question is concerned, i think
10:18:47 <EvilTerran> the sort of stuff abstract algebraists think about
10:18:58 <Cale> It might be that they have no concept of the natural numbers, but do have other concepts which adequately take their place.
10:19:00 <ddarius> psykotic: The universe is universal.
10:19:04 <psykotic> :)
10:19:13 <psykotic> i mean as far as mathematics is concerned
10:19:19 <mrd> only answer questions which are formally posed ;)
10:19:34 <psykotic> if you claim it is just a point of view question, well, then there's no reason certain structures would recur isomorphically
10:19:49 <psykotic> of course it's not clear what isomorphism would mean there
10:19:49 <Cale> For example, perhaps they have something which *we'd* recognise as being the natural numbers, but they don't even see that it's happening.
10:19:59 <ddarius> If mathematics arises out of our perception of the universe, then assuming roughly the same perceiving devices and that we are right in that the "laws of physics" are "universal" then they should arrive at similar conclusions.
10:20:01 <Cale> Perhaps they haven't thought to name it.
10:20:06 <mrd> Cale: there'd be a structure preserving map between our systems!
10:20:20 <wli> There's the anthropic principle to consider as well.
10:20:20 <ddarius> psykotic: I believe in reality.
10:20:25 <psykotic> mrd: hah. but the problem is that we can't look "reify" the structure, since we're looking at it from the inside.
10:20:27 <Cale> mrd: That's actually fairly unlikely
10:20:42 <fasta> If I want to construct a value of generic type of the same type as another variable, is it completely evil to just use == on them in something that won't ever be evaluated?
10:20:44 <Cale> even if you can properly say what you mean by that
10:20:47 <fasta> Is there a better way?
10:20:47 <ddarius> What language would the "structure preserving map" be described in?
10:21:02 <EvilTerran> @src asTypeOf
10:21:02 <lambdabot> asTypeOf = const
10:21:03 <xerox> This channel is scrolling up really fast :)
10:21:07 <EvilTerran> @type asTypeOf
10:21:10 <lambdabot> forall a. a -> a -> a
10:21:17 <wli> If the laws of nature were sufficiently different then life would not be possible, so similar laws of nature will be there for life capable of making observation to observe, so they would have similar perceptions etc.
10:21:19 <EvilTerran> fasta, that.
10:21:37 <Cale> ddarius: Maybe if there are overall similarities, we could admit something like string-rewriting as a common foundation -- it might be considerably harder than that though.
10:21:39 <mrd> Cale: they'd have the notion of countable sets and that is isomorphic to the natural numbers
10:21:55 <Cale> mrd: How do you know that?
10:22:04 <Cale> How do you know that they even allow infinite sets?
10:22:06 <psykotic> mrd: if we could agree on the universality of "countable sets" we wouldn't be having this discussion :)
10:22:07 <Cale> Or sets? :)
10:22:28 <ddarius> mrd: The issue is how do you know their "countable sets" are countable sets?
10:22:35 <Cale> It took us thousands of years to come up with our formalisation of sets.
10:22:58 <mrd> that just makes them primitive not different
10:23:04 <Cale> Not necessarily
10:23:15 <mrd> are there any finite sets which are not countable?
10:23:15 <Cale> they could just have ended up with something very different from sets
10:23:30 <Cale> mrd: "countable" usually means "countably infinite"
10:23:31 <wli> Cale: Categories? ;)
10:23:34 <mrd> yea yea
10:23:48 <Cale> wli: sure, that's an example *from our own experience*
10:24:01 <mrd> because its irrelevant to talk about countably finite ;)
10:24:18 <psykotic> http://plato.stanford.edu/entries/mathphil-indis/
10:24:19 <lambdabot> Title: Indispensability Arguments in the Philosophy of Mathematics (Stanford Encycloped ...
10:25:53 <Cale> Maybe they haven't even conceived of the idea of discretisation, because their perception of the world is so different.
10:25:56 <mrd> the only thing i can see from a different formalization of math is that some problems will change in difficulty to prove
10:25:57 <ddarius> psykotic: I think such issues have much simpler explanations without asserting the Platonic-like existence of mathematical entities.
10:26:19 <ddarius> Halting solution.
10:26:41 <mrd> I don't think that an alien civilisation will have more powerful computational devices just because they think differently.
10:26:49 <Cale> I think when you really get down to it, it's best not to assume anything about what the mathematics of alien beings would be like. :)
10:27:11 <ddarius> Until we start meeting some
10:27:28 <psykotic> ddarius, the quine-putnam argument is, roughly, that if you "commit" to the existence of such apparently physical concepts as quarks and electrons and what not, then you should do the same for certain mathematical concepts as well
10:27:29 <mrd> any aliens on #haskell would like to chime in?
10:27:46 <psykotic> ddarius, and you said you "believe in the universe" so i assume you believe in the "existence" of electrons
10:27:57 <mrd> perhaps monads are not so mysterious on alien worlds
10:28:06 <psykotic> haha
10:28:18 <psykotic> well, there are many monad tutorials involving radioactive monsters in spacesuits
10:28:23 <psykotic> maybe they have an opinion
10:28:55 <Cale> psykotic: Except that I don't commit to the absolute truth of the existence of those things. They're parts of a (mathematical) model of "the universe around us"
10:29:28 <ddarius> psykotic: I'd have to read it.  That said, I don't necessarily believe in the existence of electrons for perhaps as strong a meaning of "existence" intended, and I may well believe in mathematical things at about the same level as physical concepts.
10:29:39 <ddarius> Or what Cale said.
10:29:40 <psykotic> cale: okay, fine. but that's getting dangerously close to relativism :)
10:29:51 <ddarius> psykotic: It is close to relativism.
10:29:56 <Cale> psykotic: I don't believe in any absolute truths at all.
10:30:03 * mrd stops believing in electrons and explodes into a ball of proton/neutron gas
10:30:03 <Cale> (even that one :)
10:30:18 <psykotic> everyone in a relativist in theory, and an absolutist in practice :)
10:30:21 <psykotic> *is a
10:30:34 <fasta> EvilTerran: isn't it commonly used as variable_to_force_type `asTypeOf` existing_variable?
10:30:40 <Cale> The reason being that if you had an absolute truth, how would you know it?
10:30:41 <psykotic> this reminds me of one of perhaps the best paper ever written on philosophy
10:30:42 * dolio is a fan of coherentism.
10:30:48 <fasta> EvilTerran: the types sahy it should be exactly the other way around
10:30:58 <psykotic> robert nozick's knowledge and skepticism
10:31:01 <fasta> EvilTerran: since the const ignore the first argument
10:31:08 <fasta> EvilTerran: ignores*
10:31:18 <ddarius> psykotic: I don't believe we can necessarily understand the universe, though we may be able to understand our perception of it (which is certainly good enough if it's good enough).
10:31:20 <Cale> I don't know of any way to tell that some statement is absolutely true, and it even seems a little silly to do so anyway, because it's just a string of symbols.
10:32:05 <psykotic> well, i'm fine as long as i can get you to agree that certain physical "things" are as real as mathematical "things" :)
10:32:19 <Cale> psykotic: Which is to say, not at all ;)
10:32:35 <ddarius> psykotic: Well when they themselves are mathematical "things" then it isn't too hard...
10:32:37 <psykotic> well, but your ontological commitment to the two are tied together
10:32:43 <Cale> right
10:32:50 <psykotic> which is probably the best we can say
10:33:06 <mrd> life on a neutron star probably doesn't believe in electrons
10:33:11 <psykotic> haha
10:33:12 <Cale> If I'm working within a mathematical system, then suddenly I can say things like that 0 "exists", and have that make sense.
10:33:20 <Cale> Same goes for "quarks exist"
10:33:27 <mrd> also, said life is "very dizzy"
10:33:39 <ddarius> and "very flat"
10:33:47 <Cale> But outside that system, asking about its truth makes about as much sense as asking whether my chair is true.
10:33:54 <psykotic> sure, i agree
10:34:01 <ddarius> Cale: Is your chair true?
10:34:09 <mrd> is True true?
10:34:13 <psykotic> as a practical matter, i think that's also what quine and putnam thought. they were part of a movement called "pragmatism" for a reason :)
10:34:38 <Cale> ddarius: That's the point, it doesn't make sense to even ask - it's a simple noun, not a statement to which one can assign truth or falsity.
10:34:47 <ddarius> I just asked!
10:34:50 <mrd> it's a metaphysical question -- complete nonsense!
10:35:04 <Cale> ddarius: The answer is mu.
10:35:07 <psykotic> haha
10:35:09 <psykotic> i was just thinking of zen too
10:35:42 <psykotic> i want the chair to be happy
10:35:57 <ddarius> psykotic: Perhaps you should stop sitting on it.
10:36:08 * psykotic stands up and apologizes profusely to the chair.
10:36:10 <ddarius> There are very few people I would enjoy sitting on me.
10:36:24 <mrd> you are not a chair, I presume
10:36:49 <ddarius> Perhaps sitting on the chair gives it a sense of fulfilment.
10:36:51 <Cale> Heh, there's an idea, a chair that lets out a satisfied sigh whenever it's sat on.
10:37:02 <mrd> a sofa perhaps
10:37:09 <psykotic> ddarius, i wish our existential angst could be solved so easily.
10:37:20 <psykotic> to be a chair.
10:37:32 <psykotic> to be or not to be... a chair.
10:37:32 <mrd> a sufficiently large person sitting on your head would probably resolve your existential angst
10:37:41 <psykotic> i see what hamlet had in mind.
10:37:49 <phobes> to be a chair or to be a not chair
10:38:17 <phobes> I see this conversation has almost reached its logical conclusion
10:38:26 <mrd> Q.E.D.?
10:38:40 <mrd> time to get back to work or go outside
11:02:39 <thoughtpolice> anybody seen this? http://video.google.com/videoplay?docid=4575567975642725150
11:02:40 <lambdabot> Title: Advanced Topics in Programming Languages: Transactional Memory at Sun
11:03:04 <wli> I wonder if Sun is getting into Haskell at all.
11:03:11 <Japsu> hmm
11:03:25 <ddarius> Transactional memory has been around for a while.
11:06:06 <thoughtpolice> yes, I saw spj's video, I was just wondering if anybody had come across this one (i'm wondering if it addresses transactional memory in their new rock processors or somesuch)
11:07:33 <EvilTerran> fasta, um, const ignores the second argument...
11:07:46 <EvilTerran> @src const
11:07:46 <lambdabot> const x _ = x
11:08:28 <EvilTerran> so x `asTypeOf` y = x...
11:09:01 <fasta> EvilTerran: right, I was confusing something.
11:09:06 <fasta> EvilTerran: thanks
11:09:12 <EvilTerran> np :)
11:10:23 <FMota> @src ap const const
11:10:24 <lambdabot> Source not found. It can only be attributed to human error.
11:10:34 <FMota> lol. Yes, it is.
11:10:57 <FMota> > ap const const
11:10:58 <lambdabot>  Add a type signature
11:11:01 <FMota> :/
11:11:14 <FMota> ap const const 1
11:11:23 <FMota> > ap const const 1
11:11:24 <lambdabot>  1
11:11:26 <FMota> :)
11:13:33 <EvilTerran> > const const const 1
11:13:35 <lambdabot>  Add a type signature
11:15:00 <EvilTerran> ?type const const const 1
11:15:02 <lambdabot> forall a b. (Num a) => b -> a
11:15:23 <EvilTerran> whups. ignore me.
11:15:36 * EvilTerran wanders off again
11:23:00 <ddarius> I = SKK
11:38:15 <_roconnor> @go 140 F in C
11:38:16 <lambdabot> 140 degrees Fahrenheit = 60 degrees Celsius
11:38:28 <phobes> @go -40 F in C
11:38:29 <lambdabot> (-40) degrees Fahrenheit = -40 degrees Celsius
11:44:23 <desp> what does Data.Typeable.cast do?
11:45:01 <taruti> @type Data.Typeable.cast
11:45:02 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
11:45:04 <desp> > cast "1" :: Integer
11:45:05 <lambdabot>  Couldn't match expected type `Integer'
11:45:15 <desp> > cast "1" :: Maybe Integer
11:45:16 <lambdabot>  Nothing
11:45:17 <taruti> takes one value of type 'a' and casts it into type 'b'.
11:45:26 <desp> taruti: yes, that much I can see for myself
11:45:28 <desp> :)
11:45:31 <taruti> and returns either Just the value or Nothing.
11:45:55 <desp> do you know what determines the resulting value?
11:46:41 <taruti> desp: yes. compare the Typeable typeOf and if they match it is the same value (and there are dirty ways to coerce it)
11:47:03 <desp> > typeOf "1"
11:47:04 <lambdabot>  [Char]
11:47:08 <desp> typeOf 1
11:47:11 <desp> > typeOf 1
11:47:12 <lambdabot>  Integer
11:47:22 <desp> so, they can only match 100%?
11:47:37 <sorear> yes
11:47:46 <sorear> > cast 1 :: Maybe Integer
11:47:47 <phobes> cast is just an untagging mechanism I think
11:47:48 <lambdabot>  Just 1
11:48:04 <desp> > cast (1 :: Int) :: Maybe Integer
11:48:05 <lambdabot>  Nothing
11:48:08 <desp> okay
11:48:12 <desp> odd.
11:48:25 <taruti> cast :: forall a b. (Typeable a, Typeable b) => a -> Maybe b
11:48:35 <sorear> @src cast
11:48:35 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:48:48 <desp> is there any case where a /= b?
11:49:03 <phobes> I think you're asking how you would use this mechanism
11:49:07 <sorear> yes, and in those cases cast always fails
11:49:23 <desp> sorear: right. thanks
11:49:28 <taruti>  cast x = if typeOf x == typeOf res then Just res else Nothing where res :: b; res = unsafeCoerce# x
11:49:32 <desp> phobes: that's a valid question as well
11:49:48 <desp> so, why would one use this function?
11:49:59 <the_mushroom_man> good evening
11:50:17 <sorear> intensional type analysis
11:50:35 <phobes> I think the point is that you can make a type "[forall a. (Typeable a) => a]"
11:50:35 <phobes> and then cast out the various values
11:50:44 <taruti> desp: e.g. when one has an environt of Typeable values (wrapped in something like data TObj = forall t. Typeable t => TObj t) and needs to cast them to a specific type.
11:50:49 <sorear> > let{ foo x = cast x == 1 }  in foo 1
11:50:50 <lambdabot>   add an instance declaration for (Num (Maybe b))
11:50:56 <sorear> > let{ foo x = cast x == Just 1 }  in foo 1
11:50:57 <lambdabot>  True
11:50:58 <ClaudiusMaximus> desp: i'm guessing so you can have f::Typeable a => a -> Either b c
11:51:00 <sorear> > let{ foo x = cast x == Just 1 }  in foo "x"
11:51:02 <lambdabot>  False
11:51:08 <desp> interesting, thanks
11:52:48 <dolio> When people come in here and ask, "How do I tell if a function was called with an Integer?" cast (or something like it) is the answer. Of course, it's also not what they actually want.
11:55:27 <the_mushroom_man> can I ask a dumb newbie (functional prog.) question?
11:55:59 <chrismbrown> the_mushroom_man: shoot
11:56:52 <the_mushroom_man> well, cough, I am a Java programmer by profession ....  tadaa ... would Haskell be good language to pick up to move into functional programming?
11:57:13 <chrismbrown> yes
11:57:21 <ddarius> desp: With some constructs we can forget the type of something.  cast just tells the typechecker what it is again, verifying that it is the case.
11:57:28 <dolio> If you want to stick close to Java, Scala or Cal might be worth looking at.
11:57:35 <chrismbrown> I guess it depends on what you are wanting to do... what are your aspirations
11:57:45 <dolio> Cal is, reportedly, a lot like Haskell, but runs on the JVM.
11:57:47 <ddarius> the_mushroom_man: It's a functional language and in particular it's a purely functional language.
11:57:56 <the_mushroom_man> well, I'd like to work on my own web framework (for learning purposes)
11:58:37 <the_mushroom_man> ddarius: the "pure" part kind of makes me think that is Haskell still practical
11:59:16 <ddarius> the_mushroom_man: Java likes to pretend that it is a "pure object oriented" language, is Java practical?
11:59:52 <the_mushroom_man> well, Java is practical, but I'm beginning to see that many of the "great innovations" are just workarounds for the deficiencies of the paradigm
11:59:55 <monochrom> I want a "pure practical" language. XD
12:00:19 <monochrom> congratulations for the disillusion. :)
12:00:24 <wli> monochrom: What does "practical" mean?
12:00:48 <monochrom> I don't know yet.
12:01:02 <ddarius> OO isn't that bad.  The trick is to find an OO language.
12:01:16 <shachaf> the_mushroom_man: Haskell would probably be good to learn even if it wasn't practical.
12:01:57 <the_mushroom_man> shachaf: I agree with that ... just trying to make sense of all the options
12:02:30 <tuxplorer> std_deviation :: [Num] -> Num
12:02:30 <tuxplorer> std_deviation list = sqrt (variance list)
12:02:30 <tuxplorer> gives error :     Class `Num' used as a type    In the type `Num'    In the type `[Num]'    In the type `[Num] -> Num'.. I don't understand the reason.. variance is a function of type [Num] -> Num too
12:02:36 <desp> ddarius: right
12:02:47 <sorear> tuxplorer: Num isn't a type, it's a class
12:03:04 <the_mushroom_man> IMHO object orientation is overhyped
12:03:40 <tuxplorer> sorear: then how do I generalise that it can be any of the types that correspond to the Num class
12:03:54 <sorear> Num a => [a] -> a
12:04:03 <sorear> :t (+)
12:04:04 <lambdabot> forall a. (Num a) => a -> a -> a
12:04:10 <sorear> :t sum
12:04:12 <lambdabot> forall a. (Num a) => [a] -> a
12:04:12 <tuxplorer> sorear: ah! ok..
12:04:15 <phobes> OO = Object Identity + State + Encapsulation + Inheritance + Templates
12:04:41 <mrd> phobes: you'll always find exceptions to that formula
12:04:47 <dolio> Templates?
12:04:56 <mrd> the only sure bet is Object Identity
12:04:58 <phobes> dolio: Yes, that was the joke
12:05:08 <dolio> Ah, of course. :)
12:05:08 <monochrom> A class is a template for many many objects.
12:05:20 <sorear> tuxplorer: the trick is that the two a's have to be the same; if Haskell supported [Num] -> Num, then it would be plausible for std_deviation to take a bunch of integers and return a quaternion, which doesn't make sense.
12:05:23 <the_mushroom_man> phobes: yes, but it goes far beyond that too in practise ... patterns, domain driven design, etc
12:05:33 <phobes> Yes, I forgot those
12:05:47 <phobes> OO = Object Identity + State + Encapsulation + Inheritance + Templates + Patterns
12:05:50 <mrd> don't forget "Re-usability"
12:05:56 <phobes> OO = Object Identity + State + Encapsulation + Inheritance + Templates + Patterns + Reusability
12:06:34 <SamB> what's with the inheritence
12:06:35 <the_mushroom_man> lol @ mrd
12:06:36 <tuxplorer> sorear: I actually want to do that only :)
12:06:37 <sorear> Haskell has patterns!  > let (n + 2) = 5 in n
12:06:39 <monochrom> I think the reusability, in fact the only reusability, comes from inheritance, and only inheritance.
12:06:46 <mrd> nah
12:06:49 <SamB> monochrom: eh?
12:06:49 <mrd> prototype OO!
12:06:55 <jbauman> the five, no six keys of object oriented design are ...
12:06:58 <mrd> ie. POO
12:07:08 * phobes considers inheritance harmful
12:07:11 <SamB> monochrom: that's totally stupid
12:07:22 * sorear considers OO harmful
12:07:33 * phobes considers sorear right
12:07:35 <the_mushroom_man> inheritance requires certain amount of judgment
12:07:40 <wli> sorear: Join the club.
12:07:46 <dolio> sorear: That's the good kind of pattern, though. :) (or, maybe not, since it's an n+k pattern :))
12:07:53 <mrd> inheritance breaks encapsulation
12:07:57 <monochrom> POOH = prototype-oriented object hierarchy :)
12:07:59 <phobes> yep
12:08:26 <monochrom> Isn't prototype a kind of inheritance?
12:08:35 <the_mushroom_man> it is
12:09:02 <the_mushroom_man> just different way ... no dualism between Platonic classes and objects
12:09:26 <monochrom> Nice! Someone knows the Platonic duality.
12:09:41 <monochrom> Wait, shouldn't it be Aristotle's?
12:09:46 <the_mushroom_man> no
12:10:13 <the_mushroom_man> you may confuse it with Aristotles logic stuff
12:10:24 <monochrom> Anyway, Nice! Someone knows some duality!
12:11:00 <the_mushroom_man> does anyone use Haskell at work for projects?
12:11:11 <phobes> The guys writing haskell compilers do
12:11:35 <monochrom> shapr works for an employer who uses Haskell for web stuff.
12:11:49 <sorear> the_mushroom_man: Learn Haskell.  And SML, and Prolog, and at least one of the major proof assistants.
12:12:25 <the_mushroom_man> sorear: thanks for the suggestions, but if I'm completely honest, I have time only for 1 additional language besides Java
12:12:27 <wli> SML is mostly valuable for the module system; otherwise Haskell is the premier representative of the family.
12:12:38 <phobes> sorear:  You'd recommend Haskell+SML over Haskell + Common Lisp?
12:12:55 <monochrom> I would.
12:13:01 <wli> I would also.
12:13:10 <sorear> Does CL have first-class modules?
12:13:18 <monochrom> Now, if you replace Lisp by Scheme, that is different.
12:13:28 <the_mushroom_man> I kind of liked the Lisp macros
12:13:28 <mrd> sorear: doesn't have modules
12:13:45 <phobes> I think sorear was asking rhetorically
12:13:46 <mrd> sorear: packages are first-class, kinda, but they do something different
12:13:46 <ddarius_> shapr: Works for an employer writing Haskell web frameworks.
12:13:57 * mrd wasn't following the discussion
12:14:00 <the_mushroom_man> ddarius, cool
12:14:33 <ddarius> There's also galois.com and aetion.com
12:14:43 <ddarius> And various others to various extents.
12:15:20 <ddarius> http://www.haskell.org/haskellwiki/Haskell_in_industry
12:15:21 <lambdabot> Title: Haskell in industry - HaskellWiki
12:15:27 <tuxplorer> wats wrong with (Num a) => [a] -> Float  ? even if the output is Int, it can always be typecasted to Float right? Still I get the error     Could not deduce (Floating ([a] -> Float)) from the context (Num a)
12:15:48 <the_mushroom_man> how difficult Haskell is to learn, compared to f.ex. Scheme
12:16:18 <wli> Haskell has more depth to it.
12:16:33 <monochrom> You need fromIntegral to convert Int to Float. But this will constraint your type to (Integral a) => [a] -> Float.
12:16:33 <sorear> Not too hard, esp. if you have a mathematical inclination
12:17:00 <sorear> monochrom: or realToFrac, which is less constraining
12:17:13 <monochrom> You need realToFrac to convert Int, Float, Double, ... to Float. But this will constrain your type to (Real a) => [a] -> Float.
12:17:28 <ddarius> the_mushroom_man: You have to learn most of the same big ideas in Scheme in Haskell as well plus a bunch of type related stuff.
12:17:40 <ddarius> You don't need to worry about call/cc though.
12:17:41 <phobes> Has anyone pursued a style of programming whereby no non-free types are used?
12:18:00 <phobes> Where all types are just free and constrained with typeclasses?
12:18:00 <the_mushroom_man> I tend to like the ML-type syntax better than Lisp/Scheme parentheses
12:18:09 <monochrom> If you ask, can (Num a) => [a] -> Float be implementable, ever? The answer is clearly no, you can't blindly convert a complex number or a vector or a matrix to Float.
12:18:25 * LoganCapaldo wishes he knew what phobes was talking about
12:18:49 <tuxplorer> monochrom: sorear: Oh! I forgot abt that point.. I just forgot abt the complex numbers itself :-P
12:18:50 <ddarius> > let f :: Num a => [a] -> Float; f _ = pi in f [3]
12:18:51 <lambdabot>  3.1415927
12:18:55 <LoganCapaldo> monochrom, you can so blindly convert those things to floats, that's the problem :)
12:19:11 <mrd> phobes: no monotypes?
12:19:13 <sorear> monochrom: some information leaks, there's the size of the list, and all the stuff you get from the Eq and Show superclasses
12:19:18 <phobes> mrd: yes
12:19:24 <monochrom> Don't you love "practical" languages like C which allow you to do that? :)
12:19:25 <sorear> Î± is a monotype
12:19:46 <sorear> it's not a closed monotype, but it's still a monotype
12:19:56 <ddarius> Î± is a Greek letter
12:20:02 <phobes> lol that's what I was thinking
12:20:08 <monochrom> I am a monochrom.
12:20:19 <tuxplorer> sorear: but still, even if I make it (Real a) => [a] -> Float, I still get the same error..
12:20:20 <mrd> ? is a question mark
12:20:28 <mrd> @type sum . map realToFrac :: Real a => [a] -> Float
12:20:30 <lambdabot> Real a => [a] -> Float :: forall a. (Real a) => [a] -> Float
12:20:32 <phobes> sorear: so in  f :: a->a,  a is a monotype?
12:20:45 <monochrom> Yeah you need to insert "realToFrac" somewhere.
12:20:48 <Anand_k> how to type alpha ?
12:20:53 <monochrom> Explicit cast FTW
12:21:04 <sorear> Control-Shift-3B1
12:21:19 <monochrom> control-alt-space, then \alpha
12:21:24 <monochrom> on my setup anyway
12:21:41 <mrd> ah cool, so THAT's how you use UIM
12:21:42 <ddarius> Copy and paste what sorear typed
12:21:51 <Anand_k> doesn't work here
12:22:01 <monochrom> I use SCIM.
12:22:08 <mrd> Î±
12:22:11 <tuxplorer> monochrom: =-O
12:22:24 <sorear> Î± Î² Î³ Î´ Îµ Î¶ Î· Î¸ Î¹ Îº Î» Î¼ Î½ Î¾ Î¿ Ï€ Ï Ï‚ Ïƒ Ï„ Ï… Ï† Ï‡ Ïˆ Ï‰
12:22:33 <shachaf> monochrom: Doesn't SCIM just need ctrl-space?
12:22:39 <mrd> ok, i could see everything up to Î¿
12:22:45 * shachaf has had a lot of trouble with using SCIM as an X input method.
12:22:57 <monochrom> âˆ€Î±. (Num Î±) â‡’ [Î±] â†’ Float
12:23:07 <mrd> what encoding are you using monochrom?
12:23:09 <phobes> Î± there isn't a monotype, right?
12:23:49 <mrd> it says "ISO 14755 mode" when I hit Ctrl-Shift
12:23:54 <monochrom> UTF-8. Everyone else is using it. OK, not everyone else, but in the above all those who enter Greek letters are using the same encoding as mine (since I can use the letters fine), which is UTF-8.
12:24:10 <mrd> well I can see the greek letters but not what you typed
12:24:31 <monochrom> There are also fonts to take care of, if your setup is old enough.
12:24:31 <phobes> âˆ€ it's the mrd cloaking symbol?
12:24:46 <mrd> debian unstable
12:24:51 <mrd> maybe I don't have all the fonts
12:24:54 <phobes> âˆ€ mrd, can you read this?
12:25:02 <mrd> only mrd onwards
12:25:08 <phobes> ok
12:25:10 <monochrom> OK, try to enforce UTF-8.
12:25:23 <phobes> That symbol is forall btw
12:25:23 <mrd> i set irssi term charset to utf-8 and i'm using urxvt
12:25:46 <elliottt> i'm using gnome-terminal with irssi, and i can see them
12:25:48 <elliottt> (if that helps at all)
12:25:50 <monochrom> I use no funny terminal or text-mode client for IRC. Too much trouble.
12:25:56 <shachaf> sorear: How do you type the Unicode ->?
12:26:01 <sorear> 2192
12:26:14 <shachaf> â†’ â†’
12:26:27 <shachaf> There's also "keycap insert mode", it seems.
12:26:38 <mrd> shachaf: yea
12:26:45 <dolio> mrd: The default monospace on mine (probably Bitstream) doesn't have the forall symbol, either.
12:26:47 * shachaf hasn't really used that.
12:26:58 <monochrom> All major OSes come with some "character palette" applet for you to point and click Unicode characters.
12:27:34 <monochrom> Including English letters. :)
12:27:47 <shachaf> Can I bind handier things to the keys in that mode? l or \ for Î», for example?
12:27:49 <monochrom> You can basically answer emails without the keyboard ever.
12:27:56 <LoganCapaldo> usually the character palette lets you point and click characters period, not necessarily unicode ones, or ones using a unicode encoding :)
12:28:12 <sorear> http://members.cox.net/stefanor/1188674779.png <- urxvt doesn't display great, but at least I can read it
12:28:27 <sorear> LoganCapaldo: Your system supports non-Unicode characters?
12:28:52 <mrd> sorear: from pi onwards, my screen is borked
12:28:59 <mrd> otherwise it looks the same
12:29:17 <mrd> what font packages do you have?
12:29:25 <shachaf> That Î» is very ugly.
12:29:28 <sorear> all of them I think...
12:29:29 * shachaf has the same one.
12:30:01 <monochrom> Here is a little secret. Windows since 2000 uses Unicode internally. Only particular applications can declare "I use so-and-so charset and encoding" and Windows puts up a translation interface between that application and internals.
12:30:03 <ddarius> How do you jack lambda up that much?
12:30:30 <shachaf> sorear: What font do you use?
12:30:32 <LoganCapaldo_> I miss any exciting "proving me wrong" comments?
12:30:32 <monochrom> Thus if you say "my Windows uses ISO-8859-1" or some such, that's a lie.
12:30:54 * sorear doesn't know
12:30:57 <ddarius> monochrom: What if they're using Windows 3.1?
12:31:23 <monochrom> OK, "my Windows 3.1 uses ISO-8859-1" is also a lie. :)
12:31:27 <LoganCapaldo_> did the channel miss my comment about guessing there are some characters in some encodings out there that aren't in unicode?
12:31:39 <shachaf> monochrom: Windows 98, then?
12:31:45 <b_jonas> yep, win 31 uses 1250 or 1252 or somesuhc, depending on the version
12:31:57 <LoganCapaldo_> ie maybe theres a character in tron that doesn't exist in unicode
12:32:05 <LoganCapaldo_> or something
12:32:10 <LoganCapaldo_> wild speculation
12:32:16 <ddarius> LoganCapaldo_: It could be put there.
12:32:17 <shachaf> Most Windows 98 installations I've seen have used ISO-8859-8, though.
12:33:08 <monochrom> Windows 98 is the biggest barrier to Unicode, since so many bloody people still cling on to it.
12:33:08 <LoganCapaldo_> ddarius, it could, but if its not in there _now_ and somewhere theres a character palette app for a mjor os that supports that encoding... <g>
12:33:30 <LoganCapaldo_> Of course reality may not conform to my hypothesis
12:33:56 <monochrom> It is not just users. Many users can't tell anyway. It is those evil programmers who go "I want my program to run on Windows 98, therefore it will not do Unicode."
12:34:33 <monochrom> Programmers are the world's biggest producer of bugs.
12:35:01 <mrd> weird.  i can type in characters 3b1 thru 3bf into irssi Î±Î¿, but 3c0 Ï€Ï€ comes out mangled in irssi.  but it is ok in other terminals.
12:35:08 <shachaf> Are there different? â‡¥ â†’
12:35:12 <shachaf> Yes, they are.
12:35:35 <LoganCapaldo> monochrom, who are the second biggest producers of bugs? :)
12:35:38 <shachaf> Which should I use?
12:35:52 <monochrom> Probably users, but I don't blame them.
12:36:07 <LoganCapaldo> You think users produce bugs?
12:36:26 <mrd> they produce bug reports!
12:36:36 <monochrom> Some users are employers and managers. Although they don't use the programs, they use the programmers.
12:36:38 <LoganCapaldo> I guess if the user writes the spec and theres a bug in the spec
12:36:54 <monochrom> Yes, that's also one way.
12:37:10 <shachaf> If a bug exists in code that is never executed, is it really buggy?
12:37:22 * LoganCapaldo claps with one hand
12:37:25 <monochrom> But I don't blame users. It takes two parties to dance.
14:36:12 --- topic: '["A Taste of Haskell: http://blip.tv/file/324976 http://www.blip.tv/file/325646/ ","The Haskell programming language: got types?","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The language of ICFP winners 3 years running"]'
14:36:12 --- topic: set by glguy on [Wed Aug 15 19:40:40 2007]
14:36:12 --- names: list (clog gogonkt_ jfredett leo2007 lde johnnowak ski__ moonlite byorgey clanehin tizoc NichardRixon Pupeno3 importantshock jao spoop masm LoganCapaldo drigz_ obsethryl fdr- tehgeekmeister LunohoD Pastorn LPhas evir prb OceanSpray blakkino Lycurgus ddarius Anand_k koxinga gds Mitar ramza3 Nshag mordaunt andyjgill sorear slipstream-- ToRA joed dfeuer judahj monochrom fadec mfunebre progexp98 thoughtpolice kayess sjanssen Averell palgolak dje_)
14:36:12 --- names: list (thecrypto fxr dolio Kahdloc ptx ergot MarcWeber hvr nominolo jcreigh _Stinger_ roconnor sad0ur takamura Blwood gkr EvilTerran IvdSangen AtnNn cods kryptisk boyscared nich |Jedai| edwinb maskd twanvl kpreid mav user317 pirroh Nucleo_ der_eq CRathman ingeB0RG beelsebob iblechbot v0|d matthew_- BCoppens njd noteventime MyCatVerbs laz0r kenn_ viblo chris2 kdunn__ FZ b_jonas borism_ phr__ InfinityB JaffaCake mauke birkenfeld sharkk paolino)
14:36:12 --- names: list (bengordon therp mudge bluestorm_ Giraph reffie alvarezp qwwqe gigamonkey_ blazzy dxl_ z` ttmrichter newsham davidL piggybox elasticdog Olathe ortmag1 ozo FMota cognominal_ idnar mr_ank balodja geezusfreeek_ bgeron rey_ phobes Nanar Apocalisp Spark jbauman holst pjd mathrick [1]Wajs integral samreid Hirvinen tizoc[w] trurl dblog Xgc GeoBesh bens Tigge nothingmuch hpaste opqdonut_ cmhh metaperl Metabol lispy largos_ lucca dons Vulpyne)
14:36:12 --- names: list (jql ramkrsna TSC osfameron stevan fnordus mornfall vsmatck tessier lament DRMacIver Syzygy- Maddas jewel lambdabot cmeme fluctus Saizan thedatabase tessier_ kolmodin SimonRC GNU\caust1c allbery_b dcoutts Chris gattocarlo Oatmeat Poeir crabstick acura jjore jbalint wli olsner Heffalump xerox @ChanServ liyang andun matthew-_ drbean Eelis koala_man ichor jjore-w ClaudiusMaximus orbitz mm_freak eno Philippa felipe ashwino_ Plareplane Modius)
14:36:13 --- names: list (wajs NiTM earthy Vq^ netx kilimanjaro pgavin Shimei arjanoosting eivuokko atsampson _joshua Lemmih scs puusorsa Lunar^ wolverian dfranke jmob gvdm_other Prip Japsu ozone cameron jwp_ benomatic Nucleo dcoutts_ zamez noj pejo pragma_ nasloc__ thetallguy desp hellige arguile_ fuxxx thedward elliottt seafood profmakx Baughn SamB_XP_ dibblego norpan ShockSMX bdash bockmabe1 mux xian kosmikus agemo saccade zbrown Nafai nnunley_ klugez Igloo)
14:36:13 --- names: list (scook0 dionoea chr1s kalven Liskni_si shachaf mrd audreyt ray nornagon xsdg Altair^ caust1c ksandstr iguana_ taruti dylan jamesjb Thas Davemon Excedrin Choko cognominal Eidolos petekaz` jle dgriffi3 gog SamB mattam dropdrive moconnor delYsid Lunchy psykotic Shurique quasisane Cale data arkx Botje slarba_ qz jwp encryptio JohnMeacham Khisanth yahooooo Lamperi keturn Adamant benny purplepenguins trip__ Mat^ Laney yango cinimod noclouds)
14:36:13 --- names: list (xinming tarrybone tmoertel_away kpk qwr thorkilnaur Smokey`_ segher sieni ohub opqdonut ibid Boney ricky_clarkson Shoragan dogmaT quicksilver eyck Auris- ski_ flux _frederik_ smkl deemon kaol magagr tuukkah hhg)
14:37:35 <SamB> leo2007: that's a funny sort of question
14:37:39 <LoganCapaldo> define big?
14:37:49 <SamB> we have this tiny WM
14:38:03 <shachaf> leo2007: GHC?
14:38:04 <SamB> and I think that's probably the app we are the proudest of
14:38:24 <LoganCapaldo> ghc is forever a good example that I always forget
14:38:24 <importantshock> leo2007: xmonad is a good example.
14:38:28 <geezusfreeek> yeah, we're proud of xmonad because it's small though :)
14:38:51 <importantshock> well, it's big by haskell standards
14:38:51 <wli> I think we need more apps.
14:38:56 <importantshock> small by window manager standards.
14:39:04 <importantshock> wli: i might try writing my next Cocoa app in HOC
14:39:21 <importantshock> perhaps it will be famous!
14:39:22 <geezusfreeek> i'm making a web app in haskell
14:39:23 <importantshock> :P
14:39:37 <geezusfreeek> planning to extract a library out of it if it gets anywhere
14:39:46 <ddarius> xmonad is small even by Haskell standard.
14:39:50 <LoganCapaldo> is darcs big?
14:39:56 <wli> We could probably get relatively far relatively quickly by just turning some of the math stuff we have going around into a CAS.
14:40:24 * MyCatVerbs wants to start writing videogames in Haskell for the next month.
14:40:37 <geezusfreeek> MyCatVerbs, me too, but i haven't the time :\
14:40:45 <ddarius> darcs is sizeable.
14:41:03 <geezusfreeek> haskell would be a fun language to try making games in just because i don't think that territory has been explored much in functional programming yet
14:41:13 <leo2007> not many apps are written in haskell at the moment, right?
14:41:20 <MyCatVerbs> Since I'll more or less have month between now and when term starts (aside from the fact that I'll want to get work for as much of that as possible).
14:41:29 <wli> There are apps but they're not large or widespread.
14:41:34 <geezusfreeek> leo2007, no, not a whole bunch of popular ones yet anyway
14:41:39 <LoganCapaldo> @where haclage
14:41:39 <lambdabot> I know nothing about haclage.
14:41:40 <Saizan> if your apps is large you probably need to decompose it in libraries to put on hackage
14:41:44 <LoganCapaldo> @where hackage
14:41:44 <lambdabot> http://hackage.haskell.org/trac/hackage
14:42:44 <geezusfreeek> i think because of the nature of haskell and the haskell community that even a huge amount of built up library code would still remain very general, powerful, and safe... so we should get cracking :)
14:43:13 <geezusfreeek> although i personally haven't found the libraries to be all that lacking
14:43:29 <pjd> geezusfreeek: you know Frag?
14:43:34 <geezusfreeek> i've seen it
14:43:46 <drigz_> geezusfreeek: really? we don't even have ssl with http
14:43:51 <geezusfreeek> it was a nice experiment, but in my mind i see it as a bit of a failure
14:44:34 <geezusfreeek> drigz_, that's actually the biggest complaint i've seen about it yet though
14:44:51 <geezusfreeek> and the fact that there isn't an awesome hash table implementation
14:45:04 <drigz_> ssl about the libraries, or libraries about haskell?
14:45:17 <geezusfreeek> ssl about libs
14:45:44 <geezusfreeek> or that's what i meant anyway, though i think both are true
14:45:54 <drigz_> i just find that when i compare it to python, which has such a huge body of libraries by standard
14:46:43 <geezusfreeek> the way i see it, haskell is one of those languages that makes it so easy to reimplement a lot of functionality by just composing two functions together that it isn't really worth putting so much into the library
14:46:56 <geezusfreeek> it's a feature and a flaw at the same time
14:47:22 <wli> geezusfreak: Not at all; it just means real algorithms and data structures are what are worthy of libraries.
14:48:04 <wli> geezusfreak: Are people really going to slap together their own SVD implementations?
14:48:23 <wli> geezusfreak: Or LR(1) state machine constructors?
14:49:37 <LoganCapaldo> why just yesterday I slapped together an SVD implementation using my home brewed LR(1) state machine constructor :)
14:49:52 <LoganCapaldo> All I had to do was compose some of the functions in the prelude :)
14:49:57 * LoganCapaldo is joking
14:50:05 <mrd> oh
14:50:09 <mrd> I believed you!
14:50:15 <geezusfreeek> wli, that's a little outside the bounds of what i was talking about
14:50:36 <geezusfreeek> " it just means real algorithms and data structures are what are worthy of libraries" << i agree with that
14:52:07 <tehgeekmeister> what about happs?  what does everyone think about that?  i've never used it or seen much about it, but it seems interesting to me.
14:52:25 <geezusfreeek> supposedly, it's awesome, but i haven't actually used it
14:53:20 <geezusfreeek> for my own web app i'm following a significantly different design strategy, so happs wasn't a good fit for me
14:55:00 <tehgeekmeister> i intend to use haskell for a web app later, but i'd like to use a framework rather than building from scratch (especially as i've never conquered any major project before, unless you want to count a basic blog in rails).
14:57:09 <Weremanatee> Is there a generic method for converting a recursion to a fold?
14:57:29 <wli> Not all recursions are equivalent to such.
14:57:30 <shachaf> Weremanatee: Not all recursion can be converted to folds.
14:57:49 <Weremanatee> f n (x:xs) = div n x : f (mod n x) xs
14:58:16 <shachaf> Weremanatee: What about f n []?
14:58:22 <Weremanatee> = []
14:59:23 <drigz_> snd . foldl (\(n,ys) x -> ((n `mod` x), n `div` x : ys)) xs (i think)
14:59:27 <byorgey> hm, that looks like a mapAccumL?
14:59:37 <byorgey> @type mapAccum:
14:59:39 <byorgey> @type mapAccumL
14:59:40 <drigz_> i forgot the initial state, but you can guess
14:59:40 <lambdabot> parse error (possibly incorrect indentation)
14:59:42 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:00:05 <Weremanatee> It seems like such a simple recursion, but any translation to fold that I can come up with is convoluted.
15:00:32 <drigz_> Weremanatee: i think that you need two items in the fold state because the function takes two arguments
15:00:41 <Weremanatee> Ok, thanks, I will look at this.
15:00:55 <byorgey> @type div &&& mod
15:00:58 <lambdabot> forall a. (Integral a) => a -> (a -> a, a -> a)
15:01:05 <sjanssen> @type divMod
15:01:07 <byorgey> @type divMod
15:01:07 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
15:01:09 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
15:01:18 <sjanssen> @type mapAccumL
15:01:20 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:01:36 <Weremanatee> @src mapAccumL
15:01:37 <lambdabot> mapAccumL _ s []        =  (s, [])
15:01:37 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
15:01:37 <lambdabot>    where (s', y ) = f s x
15:01:37 <lambdabot>          (s'',ys) = mapAccumL f s' xs
15:02:17 <byorgey> I think it's basically mapAccumL divMod
15:02:28 <byorgey> to a first-order approximation
15:02:48 <Weremanatee> That's interesting. The recursion is so much simpler. :-)
15:02:49 <geezusfreeek> @pl f n (x:xs) = div n x : f (mod n x) xs
15:02:50 <lambdabot> f = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (((.) . (:)) .) . div) . (. mod) . (.))
15:02:54 <geezusfreeek> woo yay
15:02:56 <xerox> ?type mapAccumL divMod
15:02:58 <lambdabot> forall acc. (Integral acc) => acc -> [acc] -> (acc, [acc])
15:03:22 <byorgey> you might have to do something to extract what you want from the output of course
15:03:38 <Weremanatee> right
15:03:53 <byorgey> > mapAccumL divMod 500 [2,3,4]
15:03:55 <lambdabot>  (20,[0,1,3])
15:04:05 <byorgey> Weremanatee: have an example we can try it on?
15:04:22 <Weremanatee> > mapAccumL divMod 99 [10,5,1]
15:04:23 <lambdabot>  (1,[9,4,0])
15:05:08 <|Jedai|> Why isn't there a insertWith' in IntMap ?
15:05:24 <byorgey> > mapAccumL divMod 5412 [1000,100,10,1]
15:05:25 <Weremanatee> f 99 [5,1] ==> [19, 4]
15:05:26 <lambdabot>  (0,[412,5,0,0])
15:05:32 <BobFunk> anybody here using the MissingH debian package?
15:05:52 <BobFunk> trying to use the System.Time.ParseDate module
15:05:57 <byorgey> > mapAccumL divMod 99 [5,1]
15:05:59 <xerox> > mapAccumL divMod 31337 (replicate 5 10)
15:05:59 <lambdabot>  (19,[4,0])
15:06:00 <lambdabot>  (0,[7,3,3,1,3])
15:06:36 <byorgey> Weremanatee: well, it's something to play with at least =)
15:06:36 <BobFunk> and on my laptop where i have installed it from source just using import System.Time.ParseDate works fine
15:06:40 <sjanssen> @type snd . mapAccumL ((uncurry (flip (,)) .) . divMod)
15:06:42 <lambdabot>     Couldn't match expected type `(a, b)'
15:06:42 <lambdabot>            against inferred type `[a1] -> (a1, [a1])'
15:06:46 <Weremanatee> Ok, I think I'm getting at least that I need (,)
15:06:57 <BobFunk> but when installing from apt-get on my host that doesn't seem to work
15:06:57 <sjanssen> @type (snd .) . mapAccumL ((uncurry (flip (,)) .) . divMod)
15:06:59 <lambdabot> forall a. (Integral a) => a -> [a] -> [a]
15:07:23 <byorgey> ah, we want modDiv?
15:07:36 <BobFunk> ghc can't find the package
15:08:04 <Weremanatee> Can it be done with higher-order functions only, and not (,) ?
15:08:09 <byorgey> ah right, so we do
15:08:17 <Weremanatee> Just wondering out loud, really.
15:08:35 <BobFunk> any tips?
15:08:55 <idnar> BobFunk: what's the exact name of the package you installed?
15:09:17 <wli> What does mapAccumL divMod do?
15:09:19 <byorgey> Weremanatee: the problem is we want mapAccumL modDiv (if such a thing as modDiv existed), i.e. the result of divMod but flipped around
15:09:28 <monochrom> If you adopt CPS, yes. mydivmod x y k :: Int -> Int -> (Int -> Int -> r) -> r, e.g., mydivmod 5 2 k = k 2 1
15:10:10 <wli> Or whatever that is?
15:10:14 <monochrom> Unless I'm confusing two discussions into one.
15:10:17 <BobFunk> idnar: libghc6-missingh-dev
15:11:23 <byorgey> wli: it has something to do with... uh... base conversion?
15:12:12 <byorgey> wli: Weremanatee asked whether a particular function could be expressed using some sort of fold or other recursion combinator
15:12:23 <ddarius> Weremanatee: You can do (,) with higher order functions only...
15:12:51 <Weremanatee> wli: f n (x:xs) = div n x : f (mod n x) xs
15:12:54 <byorgey> @pl \f g x y -> (f x y, g x y)
15:12:55 <lambdabot> liftM2 (liftM2 (,))
15:13:21 <wli> Not sure how it relates to base conversion given that it operates on a list.
15:13:36 <byorgey> wli: yeah, I'm not sure either. =)
15:13:51 <|Jedai|> snd *** fst . mapAccumL modDiv ?
15:14:09 <wli> uncurry (flip (,)) vs. snd *** fst
15:14:26 <takamura> For functions, >>> is like . but operates backwards. There is a built-in notation for the backwards equivalent of $ ?
15:14:28 <byorgey> I think you want mapAccumL (snd *** first . divMod)
15:14:30 <EvilTerran> modDiv = (uncurry (flip (,)) .) . divMod
15:14:38 <idnar> BobFunk: hmm, let me try install that here
15:14:45 <idnar> BobFunk: which distribution of Debian?
15:14:55 <EvilTerran> that'd be mapAccumL (((snd *** first) .) . divMod), i think
15:15:06 <BobFunk> idnar: hmm - found out that it works with MissingH.Time.ParseDate
15:15:10 <byorgey> EvilTerran: ah, right
15:15:22 <EvilTerran> hooray for multi-parameter pointlessness!
15:15:23 <ddarius> :t local
15:15:24 <byorgey> takamura: I don't think so, just use flip ($)
15:15:26 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
15:15:27 <BobFunk> now I just need to figure out where Data.Hash.MD5 is hiding
15:15:33 <drigz_> (\(a,b)->(b,a)) is shorter and clearer IMO
15:15:41 <jedai> wli: If you take into account the necessary import, uncurry flip is shorter (but then I just discovered Arrow and I already find them really useful for small things like that)
15:15:41 <idnar> BobFunk: System.Time.ParseDate works for me, but I'm running sid (unstable)
15:16:06 <BobFunk> idnar: Running etch here
15:16:25 <idnar> BobFunk: I guess etch has an older version or something
15:16:40 <idnar> BobFunk: dpkg -L libghc6-missingh-dev | grep MD5 might help
15:16:42 <byorgey> > let swap = snd *** fst; modDiv = (swap .) . divMod in mapAccumL modDiv 99 [5,1]
15:16:43 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
15:16:43 <lambdabot>       Expec...
15:16:59 <BobFunk> tried both stable, testing and unstable - and yeah - seems like it's a bit older - unstable is 0.16.0
15:17:01 <shachaf> > snd &&& fst $ (3,4)
15:17:03 <lambdabot>  (4,3)
15:17:37 <shachaf> byorgey: (***) works on each part of the tuple individually; you need (&&&).
15:17:39 <byorgey> > let swap = snd &&& fst; modDiv = (swap .) . divMod in mapAccumL modDiv 99 [5,1]
15:17:41 <lambdabot>  (0,[19,4])
15:17:51 <ddarius> fst&&&snd == id, one triangle equality
15:18:02 <byorgey> shachaf: right, thanks
15:18:29 <wli> Well, where does this list fit into radix conversion?
15:18:58 <shachaf> @let swap = snd &&& fst
15:19:03 <lambdabot> Defined.
15:19:12 <byorgey> > let swap = snd &&& fst; modDiv = (swap .) . divMod in mapAccumL modDiv 9952 [10,10,10,10]
15:19:14 <lambdabot>  (2,[995,0,0,0])
15:19:14 <shachaf> @let modDiv = (swap .) . divMod
15:19:16 <lambdabot> Defined.
15:19:26 <drigz_> does @let last forever?
15:19:37 <shachaf> drigz_: Until the next @undefine.
15:19:39 <ddarius> @undefine
15:19:40 <byorgey> wli: it doesn't really, I was just guessing.  Weremanatee didn't say what the function is for.
15:19:40 <lambdabot> Undefined.
15:19:44 <shachaf> @let swap = snd &&& fst
15:19:45 <lambdabot> Defined.
15:19:45 <shachaf> @let modDiv = (swap .) . divMod
15:19:48 <lambdabot> Defined.
15:19:57 <shachaf> > mapAccumL divMod 9952 [10,10,10,10]
15:19:59 <lambdabot>  (0,[2,5,9,9])
15:20:08 <shachaf> Is that what you meant?
15:20:50 <byorgey> shachaf: right, that makes more sense re: radix conversion, but that's not what Weremanatee wanted
15:21:03 <Weremanatee> It's a money changer.
15:21:40 <byorgey> aha, a greedy change dispenser, eh?
15:22:03 <byorgey> > mapAccumL modDiv 99 [10,5,1]
15:22:05 <lambdabot>  (0,[9,1,4])
15:22:17 <ddarius> A greedy change dispenser would dispense no change.
15:22:17 <byorgey> nine dimes, one nickel, and four pennies =)
15:22:48 <Weremanatee> ddarius: Au contraire, a lazy one would dispense no change until you needed to spend it.
15:23:00 <Weremanatee> Which, by that time, would be too late.
15:23:27 <Weremanatee> nice, byorgey.
15:23:39 <byorgey> ddarius: hehe. =)  of course, I meant "greedy" as in "using a greedy algorithm"...
15:23:54 <drigz_> Weremanatee: it's not very internationalisation friendly - the people who complain about using [a-z] in regular expressions would be upset
15:24:24 <Weremanatee> drigz_: How's that?
15:24:35 <drigz_> Weremanatee: the greedy algorithm isn't optimal
15:24:46 <drigz_> although it is for the US coinage
15:24:58 <Weremanatee> Example?
15:24:58 <byorgey> drigz_: are there any currency systems in actual use where the greedy algorithm doesn't work?
15:25:11 <drigz_> > mapAccumL modDiv 63 [50,20,1]
15:25:12 <lambdabot>  (0,[1,0,13])
15:25:27 <drigz_> byorgey: probably, but i don't have an example
15:26:09 <Weremanatee> I'm not sure it could deal with florins, sovereigns and shillings, but hey.
15:26:27 <Weremanatee> Shekels?
15:26:28 <monochrom> There seems to be some theorem about "superincreasing sequence iff greedy works optimally", but I never learned the details or the truth.
15:26:29 <wli> > second (take 20) $ (mapAccumL divMod) 9952 (replicate 20 10)
15:26:31 <lambdabot>  (0,[2,5,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
15:26:55 <drigz_> @type second
15:26:57 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
15:27:35 <wli> Looks like divMod doesn't need swapping here.
15:27:52 <byorgey> drigz_: for the (->) arrow instance, second f (a,b) = (a, f b)
15:28:26 <byorgey> wli: I'm not sure what you mean.
15:29:54 <drigz_> byorgey: wow
15:30:08 <shachaf> byorgey: Hmm, also fmap, right? For the (a,) Functor?
15:30:16 <shachaf> > fmap (take 20) $ mapAccumL divMod 9952 (replicate 20 10)
15:30:17 <lambdabot>  (0,[2,5,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
15:30:33 <byorgey> > fmap (+1) (1,2)
15:30:34 <shachaf> Although second is probably clearer.
15:30:35 <lambdabot>  (1,3)
15:30:50 <byorgey> shachaf: huh.  I never knew that. =)
15:31:31 <shachaf> fmap :: (a -> b) -> f a -> f b
15:31:43 <shachaf> fmap :: (a -> b) -> (e,a) -> (e,b)
15:32:00 <byorgey> shachaf: right, it makes sense, I just didn't know there was a Functor instance for (a,).
15:33:55 <EvilTerran> that's related to Writer, isn't it?
15:34:23 <shachaf> (e,) isn't a Monad, right?
15:34:31 <shachaf> But it is a Comonad.
15:34:36 <ddarius> :t return 3 :: (Endo Int, Int)
15:34:39 <lambdabot>     No instance for (Monad ((,) (Endo Int)))
15:34:39 <lambdabot>       arising from use of `return' at <interactive>:1:0-7
15:35:02 <ddarius> You should be able to make it into an instance of a Monad.
15:35:40 <EvilTerran> I thought (e,) was a monad...
15:35:43 <shachaf> ddarius: How?
15:37:00 <byorgey> hm, you'd have to have return x = (undefined,x)
15:37:10 <ddarius> instance Monoid w => Monad ((,) w) where return = (,) mempty; (w1,a) >>= f = let (w2,b) = f a in (w1 `mappend` w2,b)
15:37:36 <byorgey> ah, with a Monoid, ok
15:37:43 <ddarius> @src Writer
15:37:44 <lambdabot> Source not found. stty: unknown mode: doofus
15:37:46 <ddarius> @src WriterT
15:37:47 <lambdabot> Source not found. You type like i drive.
15:37:48 <byorgey> but that's basically the Writer monad
15:38:25 <EvilTerran> i thought so
15:38:41 <EvilTerran> @docs Control.Monad.Writer.Lazy
15:38:41 <lambdabot> Control.Monad.Writer.Lazy not available
15:38:45 <EvilTerran> @docs Control.Monad.Writer
15:38:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
16:03:11 <wli> Orthogonals.lhs is having trouble diagonalizing.
16:06:44 <BobFunk> have a little haskell program that connects to two different REST services and combine the results - and am wondering if it would be worth the trouble parallelizing the two downloads
16:07:28 <BobFunk> any tips on how to go about this?
16:08:00 <ddarius> BobFunk: It should be fairly straightforward with any of the concurrency mechanisms provided.
16:08:05 <Lemmih> BobFunk: ForkIO + MVar?
16:08:36 <matthew-_> right, so they knitted the lorenze manifold. We should knit some haskell programs.
16:09:32 <ddarius> matthew-_: I have some crochet hooks and I should have needles somewhere, if not I can improvise (again...)
16:10:02 <matthew-_> I never learnt to crochet, but I can knit a tiny bit
16:10:11 <ddarius> matthew-_: Crochet is stupid easy.
16:10:13 <BobFunk> any good tutorials on haskell concurrency out there?
16:10:28 <ddarius> @google Tackling the awkward squad
16:10:30 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
16:10:30 <lambdabot> Title: Simon Peyton Jones: papers
16:10:31 <ddarius> That's a good start
16:10:53 <matthew-_> probably the basic hindley-milner type inference rules could be knitted into a jumper...
16:11:00 <matthew-_> maybe crochet the lambda cube?
16:12:32 <Adamant> Lambda the Ultimate Knitting Needle
16:13:02 <matthew-_> or just create a type system for knitting
16:15:26 <ddarius> knitting/crochet patterns could use HOFs
16:16:09 <ddarius> I should add more to my hyperbolic disc.
16:17:36 <ddarius> Thank God for safety pins.
16:20:47 <wli> The matrix multiplication in the bloody Orthogonals.lhs is royally screwed up.
16:21:02 <ddarius> How do you screw up matrix multiplication?
16:22:03 <wli> ddarius: It apparently needs the transpose of the left multiplicand taken to compute a correct matrix product.
16:23:56 <wli> The eigensolver is broken in/around repeated eigenvalues.
16:24:13 <wli> I'm not even talking about defective matrices here.
16:25:02 * ddarius is still in the top 10 repliers for programmersheaven.com
16:25:45 <augustss> wli: you'd better fix it then :)
16:27:31 <wli> augustss: It's looking more like I rewrite from scratch. I can't make heads or tails of all the quantum mechanics weirdness.
16:28:09 <augustss> wli: No, I'm not sure why that's there.
16:29:08 <wli> For example:
16:29:08 <wli> >> eigenkets ([[0, 1/2, 1/2], [1/2, 0, 1/2], [1/2, 1/2, 0]] :: [[Double]]) [1, -0.5, -0.5]
16:29:08 <wli> [[1.0,0.9999999999999999,1.0],[-2.0,1.0,1.0],[-2.0,1.0,1.0]]
16:29:20 <wli> augustss: Why what's where?
16:29:21 <sorear> @botsnack
16:29:21 <lambdabot> :)
16:29:54 <wli> Maple yields:
16:29:55 <wli> > linalg[eigenvectors]([[0, 1/2, 1/2], [1/2, 0, 1/2], [1/2, 1/2, 0]]);
16:29:55 <wli>                         [-1/2, 2, {[-1, 1, 0], [-1, 0, 1]}], [1, 1, {[1, 1, 1]}]
16:29:55 <lambdabot>  Parse error
16:30:07 <augustss> wli: The QM stuff in the matrix code.
16:30:55 <wli> augustss: It was the last linear algebra library left standing after various things didn't port to current ghc; now it looks like even this is toast.
16:31:43 * ddarius may read Boquist's thesis finally.
16:32:49 * ddarius has way too much stuff to read.
16:40:00 <wli> I think I'm stuck writing matrix code from scratch indeed.
16:45:07 <wli> I've never written much in the way of array code. This could hurt.
16:47:16 <ddarius> wli: What are you looking for in this matrix code?
16:49:14 <wli> ddarius: Usability, eigenvalues and eigenvectors, not much.
16:50:01 <wli> Usability is stuff like not requiring a massive porting effort.
16:51:17 <qwwqe> when in a do block, does an if/then/else sequence end that block?
16:51:28 <glguy> it can
16:51:36 <byorgey> qwwqe: not necessarily
16:51:55 <glguy> if you don't indent then else
16:51:59 <glguy> it will blow up
16:52:23 <qwwqe> but it does make it neccessary to put another do inside the if and else?
16:52:39 <byorgey> qwwqe: that depends.
16:52:52 <byorgey> qwwqe: if you're having trouble with some particular code you can paste it for people to have a look
16:52:54 <byorgey> @hpaste
16:52:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:53:07 <ddarius> qwwqe: if is always an expression form.  do blocks are expressions.
16:53:17 <ddarius> There is no special if in do.
16:53:17 <qwwqe> i'm just reading the haskell wikibook
16:53:30 <qwwqe> and wondering why there's a do after the if and else in the guessnumber code
16:53:48 <glguy> because they wanted to use do notation inside the if branch
16:56:27 <ddarius> qwwqe: do x <- m; stmts ~> m >>= \x -> do stmts do m; stmts ~> m >> stmts  do m ~> m  Those are the rules (sligtly simplified) for desugaring do-notation.
16:56:45 <ddarius> There is nothing that pushes that into the branches of an if.
16:57:27 <ddarius> do m; stmts ~> m >> do stmts
16:58:06 <ddarius> @google foo
16:58:08 <lambdabot> http://en.wikipedia.org/wiki/Foo
16:58:08 <lambdabot> Title: Foo - Wikipedia, the free encyclopedia
17:04:16 <fnord123> Is there a heuristic import order? in C++ (which used copy/paste macros for a module system) one includes the most local headers first.
17:05:51 <Lemmih> fnord123: I don't think import order matters in Haskell.
17:07:39 <ddarius> It doesn't.
17:08:51 <mudge> ah, hey guys, guess what? I understand the sequencing operator now >>=
17:09:00 <monochrom> Fortunately, importing is different from including. :)
17:09:11 <monochrom> Congrats mudge.
17:09:12 <shachaf> fnord123: imports in Haskell are like function definitions; you can even have files import each other.
17:09:16 <mudge> thanks
17:09:28 <LoganCapaldo> (sequencing operator?)
17:09:41 <drigz> @type (>>=)
17:09:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:10:16 <drigz> it's how you 'modify' the contents of a monad
17:10:27 <drigz> maybe i needed more 's there
17:10:27 <LoganCapaldo> I know
17:10:38 <LoganCapaldo> but why "sequencing"?
17:10:45 <mudge> well I mean I understand it some now
17:10:52 <shachaf> LoganCapaldo: Do-notation?
17:11:22 <mudge> LoganCapaldo  because you can use it to combine functions in a certain sequence in a certain way
17:11:23 <LoganCapaldo> shachaf, care to elaborate?
17:11:54 <LoganCapaldo> mudge, I'm just not sure what you mean by sequence
17:11:58 <shachaf> LoganCapaldo: do { s; t; u } -- This looks like s, then t, then u.
17:12:23 <LoganCapaldo> f . g . h is a sequence too yet I wouldn't call (.) the sequencing operator
17:12:24 <shachaf> LoganCapaldo: The order doesn't always matter, though.
17:12:38 <mudge> LoganCapaldo:  you have more controll on how you combine functions with the sequencing operator,  than with the . operator
17:12:42 <monochrom> >>= is more general than .
17:12:52 <mudge> this is the sequence operator:  >>=
17:12:55 <mudge> that's what I mean
17:12:59 <mudge> oh thanks monochrom
17:13:00 <monochrom> of course you can even consider >>> to be sequencing
17:13:09 <mudge> I think I'm understanding one use of it
17:13:25 <LoganCapaldo> Am I making any sense?
17:13:40 <monochrom> You are.
17:13:49 <dolio> LoganCapaldo: dpiponi would agree with you, so don't feel bad. :)
17:13:52 <monochrom> But this does not contradict someone else's understanding.
17:14:36 <monochrom> A group of blind people are exploring an elephant for the first time of their lives.
17:14:48 <monochrom> One says "oh, so an elephant is like a water hose!"
17:15:02 <monochrom> Another one says "no, it's like a big flap!"
17:15:08 <LoganCapaldo> heh
17:15:16 <monochrom> Question (1). Are they making sense?
17:15:23 <monochrom> Question (2). Are they wrong?
17:16:31 <tehgeekmeister> what's >>>?  i assume it's something to do with monads, but google wouldn't be too useful to answer that one.
17:16:41 <dolio> It's arrow composition.
17:16:42 <monochrom> Look for arrows.
17:16:48 <tehgeekmeister> thanks.
17:16:53 <shachaf> @ty (>>>)
17:16:55 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
17:16:55 <monochrom> (You'll have even less luck with that. :) )
17:17:24 <monochrom> Haskell people are great at using names that completely defies searching. :)
17:17:29 <shachaf> For the Kleisli arrow, it would be :: (a -> m b) -> (b -> m c) -> (a -> m c).
17:17:36 <shachaf> @where arrows
17:17:36 <lambdabot> http://www.haskell.org/arrows/
17:18:00 <shachaf> @go haskell arrows
17:18:01 <lambdabot> http://www.haskell.org/arrows/
17:18:01 <lambdabot> Title: Arrows: A General Interface to Computation
17:18:18 <shachaf> it doesn't seem especially hard to find.
17:18:32 <monochrom> Our business seems to be "generalizing computations".
17:18:53 <tehgeekmeister> monochrom: a few properly placed "s and i got good results with arrow composition.
17:18:54 <monochrom> As though "computations" is not already vague enough to include everything under the sun.
17:19:07 <monochrom> Ah, congrats.
17:19:08 <tehgeekmeister> monochrom: but the operators are a pain to search for, as always.
17:19:30 <holst> try another search engine
17:19:32 <shachaf> tehgeekmeister: There's Hoogle.
17:20:02 <shachaf> You could just look in the documentation of the module they're in.
17:20:12 <tehgeekmeister> shachaf: wow!  hoogle ftw!
17:20:43 <mudge> why is there so much syntax in haskell?
17:20:49 <mudge> its perlish
17:21:14 <wli> get off it
17:21:54 <dolio> Haskell doesn't have that much syntax, does it?
17:22:14 <mudge> okay, I thought might be treading thin ground with that,   but thought someone might have a comment on that,  I'm not saying its bad,   just a curiosity
17:22:20 <LoganCapaldo> it has a rich, creamy syntax
17:22:39 <tehgeekmeister> ooh, creamy syntax.  that's a good one.
17:22:50 <mudge> like vanilla ice cream
17:23:18 <LoganCapaldo> Plus most of the things that make it look "perlish" are actually defined and definable in libraries (eg: >>> >>= <$> etc.)
17:23:21 <johnnowak> cream makes you fat
17:23:45 <LoganCapaldo> So you could definitely use a syntax-lite dialect of haskell in your own code
17:24:03 <ddarius> @let add = (+)
17:24:05 <lambdabot> Defined.
17:24:17 <mudge> cool
17:24:35 <monochrom> Haskell *seems* to have much syntax. It allows you to define many user-defined operators.
17:24:40 <shachaf> LoganCapaldo: ">>> >>= <$>"? How would that work?
17:24:49 <shachaf> LoganCapaldo: Oh, you meant that as three different tokens.
17:24:52 <monochrom> Perl does have much syntax. It comes with many built-in operators.
17:24:55 <mudge> and lots of syntaxtic sugar
17:25:12 <mudge> can be useful,  and make code more expressive and shorter
17:25:15 <LoganCapaldo> shachaf, sorry I should have used the , operator :)
17:25:17 <monochrom> So far there are only monad's do and arrow's proc.
17:25:24 <dolio> Yeah, I don't really consider infix operators syntax in Haskell.
17:25:46 <dolio> At least, beyond the fact that it has infix operators at all.
17:26:20 <ddarius> > let f --> g = g . f in (1+) --> (2*) -- always fun for syntax highlighters
17:26:22 <lambdabot>  <Integer -> Integer>
17:26:23 <monochrom> If you write "x $ y #$ z $#%&*^% k" the parser is only thinking "ok so you're calling four library functions..."
17:26:44 <monochrom> Sorry, I can't count. Just three there. :)
17:26:52 <sorear> nah, seven! :)
17:27:01 <monochrom> OK, that too. :)
17:27:30 <mudge> rad, maybe we should enter Haskell in the obfusicated C coding contest
17:27:46 <ddarius> @where iohcc
17:27:46 <lambdabot> I know nothing about iohcc.
17:27:58 <nasa> > (\x -> x x)
17:27:59 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
17:27:59 <lambdabot>     Probab...
17:27:59 <ddarius> lambdabot you're being useless today
17:28:08 <shachaf> @wiki Obfuscation
17:28:08 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
17:28:10 <shachaf> I think?
17:28:27 <sorear> mudge: augustss won three times
17:28:45 <mudge> wow, "Haskell is (perhaps surprisingly) an excellent language for code obfuscation"
17:28:51 <mudge> there's three contests for it too
17:29:00 <nasa> I like the prize names :-)
17:29:12 <sorear> mudge: I mean, augustss won the IOCCC three times :)
17:29:30 <mudge> sorear: cool
17:29:32 <sorear> @quote bad.C
17:29:32 <lambdabot> No quotes match. Just what do you think you're doing Dave?
17:29:33 <sorear> @quote bad.c
17:29:34 <lambdabot> No quotes match. It can only be attributed to human error.
17:29:35 <sorear> @quote bad
17:29:35 <lambdabot> kilimanjaro says:  the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in
17:29:35 <lambdabot> like 10 days!"
17:29:37 <sorear> @quote bad
17:29:37 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
17:29:42 <mudge> sorear: who is augustss?
17:30:00 <kilimanjaro> mudge, augustss goes by the name "augustss"
17:30:17 <sorear> mudge: Lennart Augustsson, inventor of the lazy compiler and something of a community god
17:31:08 <mudge> oh him!   I've seen his name around, definititely
17:32:12 <mudge> is there special syntax for haskell parsers?
17:32:30 <mudge> so you don't have to use the sequencing operator?
17:32:47 <shachaf> mudge: What do you mean?
17:32:53 * monochrom is becoming a secret fan of augustss.
17:32:58 <shachaf> mudge: (You can call it (>>=), if you mean that.)
17:33:10 * Pseudonym suspects now that it's logged, it's no secret
17:33:24 <mudge> well I'm reading this book and it says "Haskell provides a special syntax for such parsers, allowing them to be ..."
17:33:25 <monochrom> There is no special syntax for Haskell parsers. Unless you mean the do-notation.
17:33:33 <mudge> and it seems a little funky
17:33:34 <shachaf> mudge: Oh, that's do-notation?
17:33:46 <shachaf> mudge: Is this Programming in Haskell?
17:33:52 <monochrom> Then that is just do-notation, which is applicable to all monads. Most parsers are monads.
17:34:29 <mudge> the first example it gives is like this: p1 >>= \av1 -> p2 >>= \a2   and so on
17:35:09 <mudge> and then it uses the do notation for "special parser" syntax: "do x <- item and so on
17:35:20 <mudge> shachaf:  yes this is Programming in Haskell,  page 77
17:35:24 <monochrom> Yes.
17:35:52 <mudge> monochrom,  okay,  so its for all monads
17:36:23 <mudge> so you could use the sequencing operator or the do notation
17:36:35 <monochrom> > do { x <- [1..5]; return (x+1) }
17:36:37 <lambdabot>  [2,3,4,5,6]
17:36:39 <monochrom> hehehe!
17:36:49 * monochrom hugs the [] monad.
17:37:23 * ddarius spits on the [] monad.
17:37:48 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs  uses the do-notation for lists.
17:37:50 <lambdabot> http://tinyurl.com/26xt9x
17:37:58 <mudge> [x + 1 <- [1..5]]
17:38:09 <mudge> > [x + 1 <- [1..5]]
17:38:09 <lambdabot>  Parse error
17:38:20 <monochrom> [ x+1 | x<-[1..5] ]  try that
17:38:37 <mudge> > [ x+1 | x<-[1..5] ]
17:38:38 <lambdabot>  [2,3,4,5,6]
17:38:49 <mudge> thanks
17:39:56 <mudge> which book do you guys like most:  Programming in Haskell,   the Thompson book on Haskell,   or Hudac's book on Haskell?
17:41:18 <sorear> Hudak
17:41:19 * ddarius hasn't read any of them.
17:41:28 <nasa> Hmm, I have only read Hudak's. I liked it.
17:41:35 <monochrom> I have only read Hudak and Bird.
17:41:36 <mudge> ddarius: wow, how did you learn Haskell?
17:41:43 * monochrom hugs his copy of Bird.
17:41:51 <sorear> mudge: I like http://www.tunes.org/~nef/logs/haskell  the best :D
17:41:51 <mudge> what's bird?
17:41:51 <monochrom> I love Bird's the most. :)
17:41:55 <lambdabot> Title: Index of /~nef/logs/haskell
17:41:57 <wli> monochrom: The Algebra of Programming?
17:42:04 <ddarius> There's tons of stuff online.
17:42:10 <monochrom> Richard Bird, "An Introduction to Functional Programming using Haskell"
17:42:20 <sorear> I think I probably just read the report
17:42:29 <monochrom> I love The Algebra of Programming too, but it's OT for the moment.
17:42:50 <nasa> Not to forget Write Yourself a Scheme in 48 Hours...
17:42:59 * dolio thinks he used the Gentle Intro...
17:43:17 <tehgeekmeister> i'm about to try the scheme one!  anyone have any opinions?
17:43:21 <ddarius> I started with the Gentle Intro and followed up with hundreds upon hundreds of papers and theses.
17:43:52 <mudge> ddaruis: wow
17:43:58 <nasa> Gentle Intro is nice. tehgeekmeister, if you like Scheme, it will be good.
17:44:17 <ddarius> Well, I knew Haskell well before I got into the hundreds of papers...
17:44:39 <tehgeekmeister> nasa: i'm just finishing the gentle intro and some other topic specific stuff, and scheme's always interested me (tho i can't claim to know it well at all).
17:45:23 <mudge> monochrom: so the bird is pretty good huh?
17:45:50 <dolio> Clearly the best Haskell book is the evil bird book.
17:46:03 <mudge> why that one?  what makes it so good?
17:46:10 <dolio> The cover.
17:46:38 <mudge> that alone, can't make it the best,  the cover
17:46:41 <dolio> http://tinyurl.com/34z8ve
17:46:45 <mudge> like seriously
17:47:06 <dolio> Well, it's in Japanese, so I don't know how good the actual book is.
17:47:29 <monochrom> I learned Haskell from the Gentle Introduction, then added monads from the monadic parser paper and the Wadler monad lectures. Note how all of them is subsumed by Bird's book. Plus Bird's book has monad transformers.
17:47:37 <mudge> here's the book: http://vig.prenhall.com/catalog/academic/product/1,4096,0134843460,00.html
17:47:38 <lambdabot> Title: Introduction Functional Programming, 2/E - Prentice Hall Catalog, http://tinyurl.com/32e7wc
17:48:35 <monochrom> Bird's course is not a bird course!
17:48:39 <mudge> this monad stuff seems pretty complex,  do you think it brings a lot of power?
17:49:01 <monochrom> It is not complex and it is not very powerful. It's just sweet.
17:50:00 <ddarius> Depending on what you mean by "powerful" it can either be viewed as -very- powerful or very not powerful.
17:50:08 <monochrom> It's certainly pervasive, i.e., everyone talks about it and uses it. But that's just a consequence of being sweet. Or cute, or convenient.
17:50:48 <mudge> oh,  so its like a good thing
17:51:11 <mudge> but doesn't it mix purely functional goodness with evil state changingness?
17:51:11 <Pseudonym> The thing about monads... you have to understand the principle behind category theory.
17:51:14 <monochrom> Viz. Perl is not really that complex or powerful, but it's certainly very convenient for some things, and that is why lots of sysadmins swear by it.
17:51:24 <Pseudonym> Category theory is to maths what design patterns are to software design.
17:51:43 <Pseudonym> You find things that keep showing up.
17:51:46 <mudge> should I study and understand category theory then?
17:51:47 <mrd> a workaround for poorly thought out programming languages?
17:51:57 <Pseudonym> So you abstract them away from any specific application.
17:52:08 <Pseudonym> Give them a name, you can talk about them independently.
17:52:12 <sorear> mathematicians are even lazier than programmers!
17:52:19 <Pseudonym> mudge: YOu should study category theory, yes, but not for this reason. :-)
17:52:25 <mrd> sorear: even haskell programmers?
17:52:27 <mudge> for what reason then?
17:52:29 <Pseudonym> You should because it's good for the soul.
17:52:29 <byorgey> mudge: *one* of the possible applications of monads is to encapsulate changing state in a functional setting, but that's not what monads *are*.
17:52:39 <Pseudonym> Right.
17:52:53 <mudge> what are monads?
17:52:55 <monochrom> The axiom of choice is a helluva thunked up computation.
17:53:03 <Pseudonym> The reason why monads are powerful is that they encapsulate a pattern that keeps showing up.
17:53:18 <sorear> mudge: Monads are monoid objects in endofunctor categories.
17:53:26 <Pseudonym> Two obvious examples are list comprehensions and mutable state passing.
17:53:42 <sorear> The joys of category theory ... concise definitions like that one
17:53:55 <mudge> list comprehensions are monads?
17:53:58 <Pseudonym> Sure.
17:54:04 <mudge> list comprehensions are sweet!
17:54:13 <sorear> mudge: Without the abstraction, a monad is a type of mathematical structure.
17:54:13 <mrd> it used to be called monad comprehensions
17:54:16 <Pseudonym> [ f x | x <- xs ] == do { x <- xs; return (f x) }
17:54:27 <sorear> mudge: Are you familiar with groups, rings, fields, etc?
17:54:39 <mudge> nope
17:54:48 <mudge> Pseudonym:  wow, I see that they are the same
17:54:48 <byorgey> == (xs >>= f)
17:54:50 <fnord123> >zip (uncurry (+)) [(x, y) | x <- [0..], y <- [1, 2, 3]]
17:55:03 <fnord123> oops
17:55:11 <Pseudonym> byorget: xs >>= return . f
17:55:12 <mudge> Pseudonym:  so is the list comprehnsions just syntaxic surgar for the do notation?
17:55:19 <byorgey> Pseudonym: erm, right =)
17:55:27 <Pseudonym> mudge: No, but it'd be nice if they were.
17:55:30 <Pseudonym> IN fact, they were once.
17:55:39 <Pseudonym> But that was dropped for H98.
17:55:45 <fnord123> > map (uncurry (+)) $ zip [0..] [1,2,3]
17:55:46 <lambdabot>  [1,3,5]
17:55:59 <Pseudonym> List comprehensions only work on the list monad, unfortunately.
17:56:10 <dolio> > zipWith (+) [0..] [1,2,3]
17:56:11 <lambdabot>  [1,3,5]
17:56:34 <mudge> Pseudonym: thanks
17:56:35 <Pseudonym> But the point is, list comprehensions are one example of this monad pattern.
17:56:43 <Pseudonym> THere are other examples.
17:56:44 <fnord123> @type zipWithM
17:56:46 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
17:56:54 <mudge> a list comprehnsion is a monad though?
17:57:01 <Pseudonym> Yeah, more or less.
17:57:19 <Pseudonym> It's a monad, but it's not exactly a Haskell capital-M Monad.
17:57:27 <Pseudonym> It's actually a MonadPlus in general.
17:57:33 <mudge> ok
17:57:38 <nasa> a list is a monad, at least how I understand it. the comprehension itself is syntax for monadic operation, no?
17:57:39 <Pseudonym> But even then, remember it's only the list monad.
17:57:44 <Pseudonym> nasa: Right.
17:57:45 <byorgey> mudge: probably more correct to say that a list is a monad, and the semantics of the Monad instance for lists is the same as list comprehensions
17:57:49 <idnar> @type zipWith
17:57:51 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:57:57 <Pseudonym> Yeah, that's a better way of putting it.
17:58:03 <fnord123> @hoogle zipWithM
17:58:03 <lambdabot> Monad.zipWithM :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a [d]
17:58:04 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
17:58:04 <lambdabot> Monad.zipWithM_ :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a ()
17:58:16 <Pseudonym> The thing is, one good way to understand monads is to understand list comprehensions.
17:58:25 <Pseudonym> If you understand those, you're 80% of the way to understanding monads.
17:58:40 <Pseudonym> Try translating your favourite list comprehensions into do-notation.l
17:58:47 <fnord123> good coz i understand them. :)
17:58:53 <mudge> oh cool
17:59:05 <Pseudonym> [ x | x <- xs, p x ] == do { x <- xs; guard (p x); return x }
17:59:09 <Pseudonym> :t guard
17:59:11 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:00:23 <Pseudonym> Make sense?
18:00:44 <Pseudonym> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) } :: [Int]
18:00:45 <lambdabot>  Couldn't match expected type `Int' against inferred type `(a, b)'
18:00:51 <Pseudonym> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) } :: [(Int,Int)]
18:00:53 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:00:58 <mudge> Pseudonym: yea, makes sense
18:01:25 <mudge> i see the simiarlity between list comprehensions and do notation with generators
18:04:41 <mudge> can you use do notation for everything you could use the sequencing operator for?
18:04:58 <qazwsx> anyone here familiar wth hasekell fpga hacking? I've seen a few papers on it, but now I want to try it ... anyone has good tutorials/inks?
18:05:36 <mudge> ejsy
18:05:43 <mudge> what's fpga?
18:05:53 <nasa> I am interested in it.
18:06:10 <nasa> qazwsx -- have you read the Lava primer?
18:07:24 <nasa> Here is a link to the Lava HDL introduction I read: http://raintown.org/lava/
18:07:25 <lambdabot> Title: The Lava Hardware Description Language
18:11:18 <qazwsx> nasa: got it; thanks!
18:25:43 <stepcut> anyone know where to find those graphs showing the increasing amount of traffic on the mailing lists? Or hits to the haskell.org site ? I found a graph on total unique users on #haskell per year, and GHC bug reports per day, but not those other ones
18:27:36 <sorear> ?where stats
18:27:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
18:27:44 <sorear> ?where darcs-graph
18:27:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/darcs-graph.html
18:28:04 <stepcut> I should start a wiki page
18:32:17 <Pseudonym> Sorry, back.
18:32:21 <Pseudonym> Had to do some kid herdig.
18:32:24 <Pseudonym> herding
18:42:54 <ddarius> monochrom: What about Haskell programmers on Windows?
18:46:07 <monochrom> Some things you learn in Unix carry over to Windows too, e.g., file descriptors, buffering, process spawning and death.
18:58:17 <wli> I've not even started to look at monad comprehensions yet.
18:58:48 <wli> It's doubtful I'll get anywhere with them, either, to be honest.
19:01:24 <newsham> wli: monad comprehensions arent implemented in current haskell compilers, are they?
19:02:31 <Cale> No, but do-notation is.
19:03:52 <ihope_> Not even with a flag in GHC?
19:03:56 <newsham> i've heard of that :)
19:04:34 <SamB> ihope_: you can do it if you want ;-)
19:12:01 <levi13> Hi, Is someone able to help me with a happs compilation problem?
19:13:37 <sorear> Yes.
19:14:36 <ddarius> It should be almost trivial to modify GHC to translate list comprehensions into monad comprehensions.
19:14:46 <levi13> I'm trying to compile happs-data
19:14:57 <SamB> the tricky bit being the typechecker
19:15:01 <levi13> src/HAppS/Data/Default.hs:114:0:
19:15:01 <levi13>     No instance for (Data DefaultD BSC.ByteString)
19:15:01 <levi13>       arising from the superclasses of an instance declaration
19:15:01 <levi13>       at src/HAppS/Data/Default.hs:114:0
19:15:01 <levi13>     Possible fix:
19:15:02 <levi13>       add an instance declaration for (Data DefaultD BSC.ByteString)
19:15:04 <levi13>     In the instance declaration for `Default BSC.ByteString'
19:15:28 <Saizan> levi13: do you have the darcs version of syb-with-class?
19:15:55 <ddarius> SamB: Well, with GHC's desire to typecheck as close to the given syntax, yes, though still pretty trivial.
19:16:18 <levi13> no I don't I have 0.3 from hackage
19:16:25 <ddarius> The hardest part would just be figuring out what all you needed to change and where it was in the codebase.
19:16:28 <levi13> what is the url of the darcs repos?
19:16:40 <Saizan> http://www.happs.org/HAppS/syb-with-class
19:16:40 <levi13> (Didn't see it on hackage)
19:16:46 <levi13> k, thanks. I'll try that
19:18:47 <Saizan> but list comprehensions are not simply translated to the list monad, are they?
19:18:59 <ddarius> I doubt it, but it's possible.
19:19:04 <levi13> thanks, the latest syb-with-class worked
19:21:16 <chessguy> @type groupBy
19:21:18 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
19:22:00 <Saizan> levi13: also, don't pull the last patch on HAppS-Begin
19:22:12 <chessguy> @hoogle (a -> b) -> [a] -> [[a]]
19:22:13 <lambdabot> No matches, try a more general search
19:23:23 <Saizan> chessguy: what are you looking for?
19:23:55 <chessguy> Saizan, just surprised something like this clusterBy thing doesn't exist: http://blog.moertel.com/articles/2007/09/01/clusterby-a-handy-little-function-for-the-toolbox
19:23:59 <lambdabot> Title: ClusterBy: a handy little function for the toolbox, http://tinyurl.com/yu2zsv
19:24:00 <fnord123> i read a lot about using monads but i havent seen any nice tutorials on monad design.. i.e. if I would like to create monads. hudak has a chapter late in the book on using monads but still not much on design
19:24:18 <chessguy> Saizan, apparently it's a more general version of groupBy
19:24:46 <jbauman> @pl \x -> [x]
19:24:46 <lambdabot> return
19:25:06 <jbauman> :t const return
19:25:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => b -> a -> m a
19:25:50 <dolio> It's not more general. Just different.
19:26:06 <chessguy> well yeah, i guess
19:26:16 <ddarius> fnord123: Most of the time you want to use existing monad (transformers).
19:28:49 <dolio> It does do what people frequently expect groupBy to do before they actually play with it.
19:30:48 <twanvl> ?type \f -> let {groupOn f = groupBy (\a b -> f a == f b) ; sortOn f = sortBy (comparing f) }  in  map (map snd) . groupOn fst . sortOn fst . map (f &&& id)
19:30:50 <lambdabot> forall a c. (Ord c) => (a -> c) -> [a] -> [[a]]
19:32:01 <Saizan> uhm why does he use < instead of /= in ucombos?
19:32:26 <twanvl> To prevent duplicates
19:33:13 <Saizan> well (/=) would have prevented them as well
19:34:09 <twanvl> If you use (/=) you get both ["NORTH CAROLINA","SOUTH DAKOTA"] and ["SOUTH DAKOTA","NORTH CAROLINA"]
19:35:04 <Saizan> uhm, yeah
19:36:46 <Saizan> > let ucombos xs = [[x,y] | (x,ys) <- zip xs (tail . tails $ xs), y <- ys ] in ucombos [1..3] --btw
19:36:48 <lambdabot>  [[1,2],[1,3],[2,3]]
19:38:52 <dolio> > let combos xs = [ [x, y] | (x:ys) <- tails xs, y <- ys ] in combos [1..3]
19:38:53 <lambdabot>  [[1,2],[1,3],[2,3]]
19:41:46 <elliottt> @where mapM_
19:41:47 <lambdabot> I know nothing about mapm_.
19:41:54 <elliottt> @src mapM_
19:41:55 <lambdabot> mapM_ f as = sequence_ (map f as)
19:42:00 <dolio> @index mapM_
19:42:01 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:42:06 <elliottt> thank you :)
19:54:34 <elliottt> has anyone used yampa with ghc 6.6?
19:57:16 <tehgeekmeister> oh, i didn't know hudak helped in making haskell, i guess that's a really good point for his book.
19:57:25 <elliottt> hehe :)
20:00:08 <tehgeekmeister> anyone know if the ghc in macports supports multicore by default?
20:00:23 <elliottt> yeah, the book is great, i'm just trying to figure out how to incorporate the frp ideas into my own project
20:00:45 <tehgeekmeister> frp?
20:00:59 * tehgeekmeister is new to haskell/functional programming
20:01:10 <elliottt> functional reactive programming
20:01:22 <Nafai> elliottt: What's that?
20:01:24 <sjanssen> tehgeekmeister: probably
20:01:31 <elliottt> it ends up with a really elegant syntax to describe some rather complex event handling
20:01:35 <sjanssen> tehgeekmeister: try compiling something with -threaded
20:02:05 <elliottt> Nafai: it's a way of writing programs that appear to react to events, rather than wait for them
20:02:51 <tehgeekmeister> sjanssen: tehgeekmeisters-computer% ghc -threaded prime.hs                                                                                 20:01~/code/hs/exercises
20:02:52 <tehgeekmeister> _ZCMain_main_closure
20:02:52 <tehgeekmeister> ___stginit_ZCMain
20:02:52 <tehgeekmeister> collect2: ld returned 1 exit status
20:03:06 <tehgeekmeister> the code compiles fine without -threaded
20:03:36 <tehgeekmeister> (what's the convention on pasting multiple lines in #haskell?  at what point do you put it in hpaste?)
20:03:59 * Nafai reads about frp
20:04:05 <sjanssen> tehgeekmeister: you generally see that message when you haven't defined main
20:04:27 <tehgeekmeister> sjanssen: err, okay, i've only used it from ghci, that's probably the issue.
20:04:45 <Nafai> Interesting
20:04:47 * tehgeekmeister goes off to define a main
20:04:48 <elliottt> Nafai: this has a whole bunch of intersting papers :) http://haskell.org/haskellwiki/Research_papers/Functional_reactive_programming
20:04:51 <lambdabot> Title: Research papers/Functional reactive programming - HaskellWiki, http://tinyurl.com/jsfmb
20:05:07 * Nafai looks
20:05:16 <sjanssen> tehgeekmeister: the fact that GHC didn't complain about -threaded should mean that the build has the threaded RTS
20:05:32 <tehgeekmeister> sjanssen: okay
20:07:05 <tehgeekmeister> sjanssen: yes, it's working fine.  thanks
20:07:47 <sjanssen> tehgeekmeister: when you want to run a program on multiple cores, use +RTS -Np, where p is the number of cores you have
20:09:16 <sorear> s/have/want it to use/
20:50:06 <bos> @pl \row -> getRows >>= return . (row:)
20:50:06 <lambdabot> (`fmap` getRows) . (:)
20:58:39 <ddarius> Stupid crazy syntax.
20:59:06 <ddarius> But I see that it is consistent...
21:03:40 <FMota> :/
21:57:35 <reffie> xerox
21:59:23 <mudge> hello
21:59:26 <mudge> anyone here?
22:02:02 <bos> yep
22:08:39 <elliottt> yes
22:22:35 <elliottt> > uncurry (++) . unzip $ [(1,2),(3,4)]
22:22:37 <lambdabot>  [1,3,2,4]
22:52:48 <kolmodin> @yarr
22:52:48 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
23:18:13 <takamura> hi
23:18:35 <kfish> takamura, hi
23:39:34 <sorear> *grumble* HTML on the mailing list!
23:42:09 <sorear> multipart/alternative is fine, but does this Peter guy realize that he has zero chance of getting a response from me (and probably thus many others) because we can't figure out where his quotes are?
