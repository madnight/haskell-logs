00:12:17 <Sizur> ukewaza
00:16:44 <tuxplorer> dons: Thanks.. will check out
00:17:21 <dons> sjw: hey
00:17:32 <sjw> dons: hi
00:18:43 <dons> doing some haskell haxoring?
00:19:00 <dons> how's APEC?
00:19:11 <sjw> dons: nah, wanted to hassle kfish about his monadreader article ;)
00:19:17 <dons> ah hehe
00:19:18 <sjw> dons: over
00:19:35 <dons> you survived?
00:20:05 <sjw> yeah, only real problem was that the city was empty, and I guess those going on holidays sat in lots of traffic
00:21:17 <sjw> dons: how is working for the man?
00:21:39 <dons> the man shot me with a nerf gun today!
00:21:54 <dons> hard yakka :)
00:22:42 <sjw> yeah, .us has some pretty cool Nerf materiel
00:23:01 <dons> sjw, its fun though!
00:23:11 <Pseudonym> dons: I assume you saw The Chaser clips.
00:23:20 <dons> Pseudonym: heard about them, yeah. :)
00:23:53 <sjw> those guys are going to get shot one of these days
00:24:13 <dons> this was probably the closest they came, i guess
00:24:44 <Pseudonym> The weird thing is, they expected to get turned away at the first checkpoint.
00:25:00 <Pseudonym> It was only after they got through two and close to The Forbidden Zone(tm) that they decided they should probably turn around.
00:25:03 <dons> yeah, hmm. that was interesting.
00:25:13 <Pseudonym> And THAT'S when the authorities noticed.
00:28:02 <Pseudonym> Anyway, must away.
00:28:04 <Pseudonym> Nytol!
00:30:34 <kfish> sjw, heya
00:31:03 <sjw> kfish: why the MonadR article?
00:31:25 <sjw> btw, the PhD comics talk was cool
00:32:05 <kfish> why? i dunno, seemed like fun at the time :-)
00:32:18 <dons> sjw: oh, cool you got to go.
00:32:33 <dons> sjw: you're going to have to write one now
00:32:48 <dons> sjw, how about some Isabelle + Haskell fun? swiert will love you for it
00:33:31 <sjw> hmmm, there was the CiC thing I just wrote, but that is perhaps not so interesting
00:33:35 <sjw> and rather hacky in parts :)
00:33:50 <dons> implementing a small theorem prover in haskell would make a great article
00:33:57 <sjw> although it is monad heavy :)
00:34:10 <dons> good monads or bad ones?
00:34:44 <sjw> type TCMonad s = ErrorT (TCError s) (ReaderT (Context s) (State Int))
00:34:54 <dons> ok, good monads :)
00:34:55 <sjw> You decide!
00:35:02 <dons> yeah, there good ones.
00:35:11 <kfish> yay heavy lifting
00:35:18 <sjw> although I should use DeBruijn, which would make things simpler
00:35:31 <sjw> the state is only there to give fresh variables
00:35:32 <dons> see, that's half a TMR article right there.
00:35:47 <kfish> sjw, damn, i misread that as fresh vegetables
00:36:00 <dons> mmm. well typed and delicious!
00:36:06 <sjw> kfish: that's what the ReaderT is there for :)
00:36:18 <sjw> an infinite supply of carrots
00:39:51 <kfish> see, the real reason i wrote that article was because of dons poking me about six months ago
00:40:00 <sjw> ahh
00:40:15 <kfish> poke poke poke
00:41:05 <kfish> nah, so the real reason is that there's not much (introductory) stuff out there explaining the type syntax
00:41:25 <kfish> and trying to learn about eg. monads, without being able to read the type syntax, is just silly
00:41:42 <sjw> makes sense
00:41:50 <kfish> so really, it's a monad tute in disguise, and doesn't mention monads once
00:42:55 <kfish> the closest it gets is "With a solid understanding of type and type-class parameterization, type constraints and dependencies, you should be well on your way to understanding the interfaces of interesting and useful types."
00:42:55 <sjw> covert monads
00:43:45 <kfish> sshhhh, covert monads!
00:44:15 <Sizur> rename Monad.Reader to ExtendedTypes.Reader ;P
00:44:21 <Caelum> is this article online?
00:44:40 <kfish> ?where tmr
00:44:40 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
00:44:54 <kfish> Caelum, in the latest issue of the monad reader :-)
00:45:16 <Caelum> cool, thank you :)
00:45:30 <Sizur> kfish: keep up the good work!
00:45:37 <kfish> also for this article, i've set up talk etc. pages: http://haskell.org/haskellwiki/User:ConradParker/InstantInsanity
00:45:38 <lambdabot> Title: User:ConradParker/InstantInsanity - HaskellWiki
00:45:44 <kfish> Sizur, cheers :-)
00:55:40 <dons> @seen Heffalump
00:55:40 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 3h 13m 3s ago.
01:22:20 <Itkovian> @seen vincenz
01:22:21 <lambdabot> I saw vincenz leaving #haskell 12h 1m 33s ago, and .
01:29:10 <v0|d> @dice 2 4
01:29:10 <lambdabot> 2 4 => 24
01:29:27 <osfameron> ooo, the London HUG talk on Tron sounds fun
01:29:37 <ari> ... wait, what
01:29:39 <ari> @help dice
01:29:39 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
01:29:46 * osfameron wants to read the papers afterwards!  (Don't think I'll make it London on 20th)
01:30:03 <ari> @dice 3d6 3d6
01:30:03 <lambdabot> unexpected "d": expecting digit, "+" or end
01:30:12 <ari> @dice 3 3
01:30:12 <lambdabot> 3 3 => 33
01:30:24 <v0|d> @dice 1
01:30:24 <lambdabot> 1 => 1
01:30:29 <v0|d> @dice 6
01:30:29 <lambdabot> 6 => 6
01:30:31 <v0|d> @dice 6
01:30:31 <lambdabot> 6 => 6
01:30:41 <v0|d> @dice 6 1
01:30:41 <lambdabot> 6 1 => 61
01:30:45 * ari nods
01:30:45 <v0|d> @dice 6 2
01:30:46 <osfameron> that's a bit pish
01:30:46 <lambdabot> 6 2 => 62
01:30:54 <v0|d> hmm.
01:30:58 <osfameron> it said it accepted an expression
01:31:03 <osfameron> @dice "3d6"
01:31:04 <lambdabot> unexpected "\"": expecting number
01:31:09 <osfameron> silly bot
01:32:42 <allbery_b> @dice 4d20
01:32:42 <lambdabot> 4d20 => 45
01:32:56 <opqdonut> "no dice"
01:42:03 <nornagon> @nodice 1d6
01:42:03 <lambdabot> 1d6 => 2
01:42:22 <nornagon> @botsnack
01:42:22 <lambdabot> :)
01:42:28 <nornagon> @karma lambdabot
01:42:28 <lambdabot> lambdabot has a karma of 44
01:46:16 <cizra> @karma Siddharta Gautama
01:46:16 <lambdabot> Siddharta has a karma of 0
01:46:47 <opqdonut> nornagon: :D!
01:53:01 <v0|d> @karma- lambdabot
01:53:01 <lambdabot> lambdabot's karma lowered to 43.
01:53:52 <fxr> @karma- lambdabot
01:53:52 <lambdabot> lambdabot's karma lowered to 42.
01:58:58 <haxplorer> @vixen lambdabot! I missed you so much :)
01:58:59 <lambdabot> Are we just wasting time?
01:59:36 <quicksilver> any haskell/GL users around?
02:07:45 <haxplorer> map ("what" =~ ) ["what is your name", "how are you", "What do u think"]
02:07:51 <haxplorer> what is wrong in the above statement?
02:08:08 <oerjan> :t (=~)
02:08:14 <lambdabot> Not in scope: `=~'
02:08:25 <haxplorer> oerjan: its in Text.Regex.Posix
02:08:32 <haxplorer> I've loaded that module
02:09:12 <oerjan> is there some error?
02:09:27 <haxplorer> oerjan: oops..
02:09:36 <haxplorer> I found something..
02:10:00 <haxplorer> the elements in the list should come before the (=~) and the pattern after that
02:10:08 <haxplorer> How should I map that way?
02:10:21 <laziest> map (=~ "what")
02:10:51 <haxplorer> laziest:
02:10:59 <haxplorer> map (\x -> x =~ "what" ) ["what is your name", "how are you", "What do u think"] :: [Bool]
02:11:00 <haxplorer> worked
02:11:04 <haxplorer> Thanks :)
02:11:16 <laziest> but (=~ "what") should also work.. did it now?
02:11:34 <haxplorer> laziest: ya. That too works.. so its more simpler.. Thanks!!
02:13:09 <haxplorer> But the odd thing is that I get a result [True,False,False]
02:13:18 <laziest> caps!
02:13:22 <haxplorer> whereas I should have got [True, False, True]
02:13:30 <haxplorer> ah!
02:13:35 <therp> totally offtopic, but is there some kind of 'flip' for the shell? flip "cp -a /destdir" producing a command that can be handed to xargs -n 1?
02:14:23 <int-e> perl ;-)
02:14:41 <laziest> write one: flip() { first="$1"; second="$2"; shift 2; "$2" "$1" "$@" }
02:15:13 <laziest> oh, no, not to xargs...
02:15:23 <int-e> therp: seriously though, use xargs -I?
02:15:31 <laziest> but yes, if you put this in a file.
02:17:58 <haxplorer> laziest: any idea where I should add options like case insensensitive, etc in the regex?
02:20:34 <laziest> I have not used regex ever.. so no idea...
02:20:45 <haxplorer> ok
02:20:49 <laziest> I mean in haskell yet
02:21:00 <quicksilver> haxplorer: it's all in the docs. The option to ignore case is compIgnoreCase
02:21:02 <haxplorer> ya. I understood  :)
02:21:24 <therp> oh, right, thanks int-e
02:21:47 <haxplorer> quicksilver: oh! Thanks :)
02:21:55 <laziest> it's in the regexmaker
02:22:03 <laziest> ya, quicksilver said it
02:23:22 <quicksilver> to be fair, the network of typeclasses used by the regex libraries is pretty nasty
02:23:43 <quicksilver> but I think you want to call makeRegexOpts to make one with non-default options
02:24:34 <opqdonut> i think the polymorphism in the match return value is very weird, ugly and perl-like
02:25:00 <haxplorer> ya. quicksilver, The function compIgnoreCase returns CompOption type value, but the compiler expects a source type after the =~ operator.. searching for a function that can do the job.. Otherwise will have to go for the makeRegexOpts ffi..
02:34:55 <ToRA> with 'ghci -e' is there a flag to give module names to import / put in scope? (e.g. Control.Arrow)
02:39:22 <doserj> not on the command line, but you can add source files to the comman, which then may contain import statements
02:39:27 <doserj> *command
02:43:39 <alexeevg> hi
02:51:52 <muh__> I want a function that takes a (STArray Int Int) and returns its bounds. How do I do that? I don't understand how to use getBounds
02:53:26 <muh__> > test =runST ( do arr <- newArray (0,5) 0::(ST s (STArray s Int Int)); getBounds arr)
02:53:26 <lambdabot>  Parse error
02:53:28 <oerjan> @hoogle getBounds
02:53:29 <lambdabot> No matches found
02:53:56 <ari> getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
02:54:00 <malcolmw> @hoogle STArray Int Int -> (Int,Int)
02:54:01 <lambdabot> No matches, try a more general search
02:54:19 <muh__> test return (0,5), as expected
02:54:27 <muh__> *returns
02:54:45 <oerjan> > runST ( do arr <- newArray (0,5) 0::(ST s (STArray s Int Int)); getBounds arr)
02:54:47 <lambdabot>   Not in scope: `getBounds'
02:54:56 <oerjan> right...
02:55:06 <muh__> at least on my machine
02:55:42 <muh__> but I want a general function
02:55:44 <oerjan> well it is monadic
02:57:58 <muh__> I thought, since it is in the State Monad, I could get a pure value with runST
02:58:14 <quicksilver> that's not the state monad
02:58:22 <quicksilver> runST is totally different from State
02:58:28 <muh__> oh
02:58:39 <oerjan> except each runST essentially gives a new incompatible state
02:58:51 <quicksilver> you're quite right that you can use runST to run getBounds
02:59:17 <oerjan> the problem is you can only use it on an array created within the same runST, iiuc
02:59:19 <quicksilver> but you can't use the same STArray in more than one runST
02:59:28 <quicksilver> you could of course freeze it
02:59:51 <muh__> why is it so complicated, the bounds are after all static
03:00:10 <muh__> imho there should be a pure function to get them
03:03:31 <oerjan> i suppose whoever wrote the overloaded getBounds method didn't want to rule out resizable arrays
03:04:43 <oerjan> anyway what is the big deal?  if you have an STArray you _will_ be inside a runST anyway, so you can run getBounds there
03:05:53 <ari> unsafePerformIO . unsafeSTToIO -- it might be somewhat unsafe but maybe it works :p
03:06:18 <quicksilver> I think oerjan's point is good, though
03:06:38 <quicksilver> STArrays are totally useless baggage, outside of the runST
03:06:50 <quicksilver> so you might as well use getBounds
03:07:37 <muh__> Yesterday I wrote some functions to write Windows Bitmaps. I made an "Image" typeclass and instatiated an immutable Array. It all works quite nice, only that actually manipulating the image will be slow. So I thought I could simply use a mutable Array instead
03:08:39 <muh__> however, it seems quite hard, if not impossible, to use the same typeclass
03:10:04 <muh__> I thought I could pass around a mutable array as if it was immutable and only use the mutability inside of the manipulation functions
03:11:20 <oerjan> use thaw and (unsafe)Freeze, i guess
03:11:29 <quicksilver> or use IO instead of ST
03:11:39 <quicksilver> you have to guarantee sequencing somehow
03:11:48 <quicksilver> IO has a single global guaranteed sequence
03:12:03 <quicksilver> ST allows you to break out of that simplistic model, and have multiple interleaved sequences
03:12:45 <quicksilver> but the price you pay is that your mutable blobs aren't usefully 'exportable' outside of the context they were made in
03:13:26 <quicksilver> the correct thing to do is to use freeze and thaw
03:13:49 <quicksilver> it would be nice if someone made a copy-on-write version of freeze
03:13:58 <quicksilver> but in practice memory copying is damn fast anyway
03:15:02 <quicksilver> thre are unsafe versions of course but you have to be sure you know what you're doing for that :)
03:15:36 <muh__> hm, I will try freeze and thaw then
03:15:45 <muh__> but, first I need some food
03:16:00 <quicksilver> mutation is over-rated anyway
03:16:24 <quicksilver> there is no reason why a function which constructs a new IArray from an old IArray need be slow
03:16:44 <quicksilver> the only time mutation would be a big win is if you're just changing one or two pixels
03:18:02 <quicksilver> DiffArrays are supposed to be the solution to this problem
03:18:13 <quicksilver> but, allegedly, they're not all that fast because the implementation is suboptimal
03:18:16 <quicksilver> I've not tried to benchmark
03:19:43 <oerjan> my impression from a discussion we had here is that the speed is ruined because of thread locking
03:20:17 <quicksilver> I think all this stuff is a good example of premature optimization
03:20:26 <quicksilver> don't assume something is slow until you've proved it is
03:20:43 <quicksilver> but design your interfaces cleanly so it's easy to slot in an improved component if that is indeed necessary
03:25:23 <gip> I'd like a haskell module to export only selected functions, not all of them. How to do that? Thx
03:25:48 <oerjan> module MyModule (function1, function2) where
03:25:58 <quicksilver> gip: http://www.haskell.org/onlinereport/modules.html
03:25:59 <lambdabot> Title: The Haskell 98 Report: Modules
03:26:09 <SamB_XP_> gip: a very sensible thing to wish ;-)
03:26:28 <oerjan> I CAN HAS EXPORT LISTS?
03:26:44 <SamB_XP_> iCan ?
03:26:50 <SamB_XP_> is that for holding iSoda?
03:27:06 <beelsebob> iDon'tKnow
03:27:08 <oerjan> possibly
03:27:21 <oerjan> but iThink not
03:29:42 <SamB_XP_> man there are too many things called iClass
03:31:29 <beelsebob> bad apple for starting at least one fassion
03:31:32 <beelsebob> in the mean time...
03:31:40 <beelsebob> hugs98 for iPhone is attempting to compile
03:31:59 <oerjan> yay!
03:32:07 <beelsebob> trying to get hugs to cross compile is surprisingly hard
03:32:17 <beelsebob> mostly because the configure script is designed to trip you up
03:33:29 <SamB_XP_> what sort of configure script is it?
03:33:48 <gip> > (read "1") :: Rational
03:33:52 <lambdabot>  Exception: Prelude.read: no parse
03:33:59 <gip> Why is it not working?
03:34:13 <beelsebob> SamB: # Generated by GNU Autoconf 2.59 for Hugs98 1.0.
03:34:17 <opqdonut> > show (1 :: Rational)
03:34:18 <oerjan> (read "1%1") :: Rational
03:34:19 <lambdabot>  "1%1"
03:34:25 <opqdonut> yep, 1%1 is the format
03:34:33 <oerjan> > (read "1%1") :: Rational
03:34:35 <lambdabot>  1%1
03:34:39 <gip> ok
03:34:40 <SamB_XP_> it's kind of disgusting that "1" doesn't read too...
03:34:51 <opqdonut> not really, no
03:35:10 <oerjan> Read is not designed to parse all Haskell constants, alas
03:35:13 <quicksilver> the read thing with numbers is pretty inconsistent
03:35:23 <quicksilver> > (read "1") :: Double
03:35:24 <lambdabot>  1.0
03:35:27 <oerjan> the only rule is that show . read = id
03:35:33 <quicksilver> > (read "1.1") :: Fraction
03:35:34 <oerjan> er, read . show
03:35:34 <lambdabot>   Not in scope: type constructor or class `Fraction'
03:35:39 <quicksilver> > (read "1.1") :: Rational
03:35:41 <lambdabot>  Exception: Prelude.read: no parse
03:35:48 <opqdonut> > toRational . read $ "1.1"
03:35:50 <lambdabot>  Exception: Prelude.read: no parse
03:35:57 <gip> I'd like the read function to parse things like "0.1" to Rational.
03:35:57 <opqdonut> hmm, interesting?
03:36:02 <gip> How can I do?
03:36:08 <SamB_XP_> gip: see, that's exactly what I mean!
03:36:30 <gip> > (read "0.1%1") :: Rational
03:36:30 <opqdonut> that's not what read is supposed to do
03:36:31 <SamB_XP_> well first of all say something to the H' committee
03:36:32 <lambdabot>  Exception: Prelude.read: no parse
03:36:35 <oerjan> hm, that _is_ pretty awkward, since 0.1 notation is _defined_ using Rational
03:36:44 <quicksilver> it's very odd
03:36:46 <quicksilver> IMO
03:38:19 <quicksilver> > toRational (read "0.1" :: Double)
03:38:20 <lambdabot>  3602879701896397%36028797018963968
03:38:26 <quicksilver> you will note that that is wrong
03:38:31 <quicksilver> most frustrating
03:38:31 <SamB_XP_> heh
03:38:33 <gip> :)
03:38:33 <SamB_XP_> yes
03:38:39 <quicksilver> the conversion to binary messes it up
03:38:46 <opqdonut> yep
03:38:52 <SamB_XP_> @hoogle ReadS Rational
03:38:53 <lambdabot> No matches, try a more general search
03:38:53 <quicksilver> gip: I'm afraid you'll have to write a parser for it. Fortunately it's not very hard.
03:38:54 <opqdonut> ugly indeed
03:38:55 <SamB_XP_> @hoogle ReadS n
03:38:56 <lambdabot> Text.ParserCombinators.ReadP.readP_to_S :: ReadP a -> ReadS a
03:38:56 <lambdabot> Prelude.readParen :: Bool -> ReadS a -> ReadS a
03:38:56 <lambdabot> Text.ParserCombinators.ReadPrec.readPrec_to_S :: ReadPrec a -> Int -> ReadS a
03:39:30 <SamB_XP_> @hoogle Int -> ReadS n
03:39:31 <lambdabot> Text.ParserCombinators.ReadPrec.readPrec_to_S :: ReadPrec a -> Int -> ReadS a
03:39:31 <lambdabot> Prelude.readsPrec :: Read a => Int -> ReadS a
03:39:46 <SamB_XP_> @doc Numeric
03:39:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
03:40:23 <gip> quicksilver: ok, thanks. Would be cool to have that though
03:40:40 <oerjan> ah, readFloat
03:41:09 <oerjan> > readFloat "1.0" :: (Rational, String)
03:41:11 <lambdabot>  Couldn't match expected type `(Rational, String)'
03:41:17 <SamB_XP_> @src Rational read
03:41:18 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:41:26 <SamB_XP_> @src Rational
03:41:27 <lambdabot> type Rational = Ratio Integer
03:41:29 <oerjan> :t realFloat "1.0"
03:41:31 <lambdabot> Not in scope: `realFloat'
03:41:36 <oerjan> :t readFloat "1.0"
03:41:38 <lambdabot> forall a. (RealFrac a) => [(a, String)]
03:41:41 <oerjan> ah
03:41:44 <SamB_XP_> @doc Data.Ratio
03:41:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
03:41:47 <oerjan> > readFloat "1.0" :: [(Rational, String)]
03:41:49 <lambdabot>  [(1%1,"")]
03:41:56 <oerjan> there you are :)
03:42:02 <opqdonut> hmm nice
03:42:06 <quicksilver> > readFloat "0.1" :: [(Rational, String)]
03:42:07 <gip> Nice :)
03:42:08 <lambdabot>  [(1%10,"")]
03:42:17 <quicksilver> yay, it does the right thing :)
03:42:24 <quicksilver> > readFloat "0.172" :: [(Rational, String)]
03:42:26 <lambdabot>  [(43%250,"")]
03:42:43 <quicksilver> > readFloat "x0.172" :: [(Rational, String)]
03:42:45 <lambdabot>  []
03:42:45 <opqdonut> > let [(x,"")] = readFloat "0.123" in x
03:42:47 <lambdabot>  0.123
03:42:54 <quicksilver> why is it [] and not Maybe ?
03:42:55 <SamB_XP_> the Real class is messed up :-(
03:42:57 <gip> > readFloat ("0."++replicate 1000 '0'++"1") :: [(Rational, String)]
03:42:57 <opqdonut> > let [(x,"")] = readFloat "0.123" in (x :: Rational)
03:42:58 <lambdabot>  [(1%100000000000000000000000000000000000000000000000000000000000000000000000...
03:42:59 <lambdabot>  123%1000
03:43:12 <gip> > readFloat ("0."++replicate 10 '0'++"1") :: [(Rational, String)]
03:43:13 <lambdabot>  [(1%100000000000,"")]
03:43:25 <opqdonut> > let [(x,"")] = readFloat "0."++cycle "123" in (x :: Rational)
03:43:26 <lambdabot>  Couldn't match expected type `(t, [Char])'
03:43:29 <opqdonut> :P
03:43:36 <opqdonut> > readFloat "0."++cycle "123"
03:43:37 <lambdabot>  Couldn't match expected type `(a, String)'
03:43:47 <opqdonut> ah
03:43:50 <gip> @t cycle
03:43:50 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:43:51 <opqdonut> > readFloat $ "0."++cycle "123"
03:43:53 <opqdonut> stupid mee
03:43:55 <lambdabot> Terminated
03:43:57 <gip> @index cycle
03:43:57 <lambdabot> Data.List, Prelude
03:44:04 <opqdonut> > "0."++cycle "123"
03:44:07 <lambdabot>  "0.1231231231231231231231231231231231231231231231231231231231231231231231231...
03:44:36 <gip> > readFloat ("0."++ cycle "0") :: [(Rational, String)]
03:44:40 <lambdabot> Terminated
03:45:09 <gip> @index readFloat
03:45:09 <lambdabot> Numeric
03:45:13 <twanvl> > fromRational $ 123%999
03:45:15 <lambdabot>  0.12312312312312312
03:46:28 <oerjan> hm...
03:46:41 <oerjan> > readFloat "Infinity" :: [(Double, String)]
03:46:42 <lambdabot>  [(Infinity,"")]
03:48:49 <hpaste>  fasta pasted "DrIFT does not derive instance NFData" at http://hpaste.org/2683
03:49:01 <fasta> Ignore the '-'
03:49:01 <opqdonut> :D
03:51:15 <SamB_XP_> > readFloat "Infinity" :: [(Rational, String)]
03:51:17 <lambdabot>  [(1%0,"")]
03:51:23 <fasta> Odd, the example from the website does seem to work.
03:51:32 <oerjan> O_o
03:51:34 <SamB_XP_> > readFloat "-Infinity" :: [(Rational, String)]
03:51:35 <lambdabot>  []
03:51:39 <SamB_XP_> !
03:51:56 <oerjan> > 1%0
03:51:57 <lambdabot>  Exception: Ratio.%: zero denominator
03:52:13 <SamB_XP_> > show (- read "Infinity")
03:52:14 <lambdabot>  Exception: Prelude.read: no parse
03:52:34 <SamB_XP_> > show (- read "Infinity" :: Double)
03:52:36 <lambdabot>  "-Infinity"
03:52:38 <fasta> Hmm, when I place that definition in a file solely, it also works...
03:52:41 <oerjan> > 1/0 :: Rational
03:52:42 <lambdabot>  Exception: Ratio.%: zero denominator
03:53:07 <gip> readFloat gives [(a, String)].. I'd need [a]. How do I do?
03:53:08 <quicksilver> readFloat must cheat
03:53:15 <quicksilver> and bypass the safe constructor
03:53:24 <oerjan> indeed
03:53:25 <SamB_XP_> but how?
03:53:33 <oerjan> ghc optimization gone awry?
03:53:44 <oerjan> the report version uses 1/0
03:54:43 <quicksilver> gip: well actually there are only at most 1 a, so it's not really a list anyway
03:54:58 <quicksilver> gip: although the literal answer to your question as asked is 'map fst'
03:55:00 <takamura> @pl map ($ x y) [f, g, h]
03:55:00 <lambdabot> map ($ x y) [f, g, h]
03:55:21 <oerjan> > let [(inf,"")] = readFloat "Infinity" :: Rational in recip inf
03:55:22 <lambdabot>  Couldn't match expected type `Rational'
03:55:38 <takamura> @pl ($ x y) f
03:55:38 <lambdabot> f (x y)
03:55:49 <oerjan> > let [(inf,"")] = readFloat "Infinity" in recip (inf::Rational)
03:55:51 <lambdabot>  0%1
03:56:16 <quicksilver> takamura: ($ x y) may not mean what you think it means :)
03:56:22 <gip> quicksilver: forgot to mention -- now I'm assuming I've got a list of rationals separated by space...
03:56:39 <quicksilver> > readFloat "1.0 2.0 0.3" :: [(Rational, String)]
03:56:41 <lambdabot>  [(1%1," 2.0 0.3")]
03:56:52 <quicksilver> gip: nonetheless readFloat only (tries to) read the first one at most :)
03:57:26 <gip> how can I iterate to get all the rational in an array?
03:57:59 <LoganCapaldo> > words "1.0 2.0 3.0"
03:58:00 <lambdabot>  ["1.0","2.0","3.0"]
03:58:05 <beelsebob> that's a wery declarative question
03:58:08 <oerjan> > map readFloat . words $ "1.0 2.0 0.3"
03:58:10 <lambdabot>  [[(1.0,"")],[(2.0,"")],[(0.3,"")]]
03:58:22 <opqdonut> nice data structure :)
03:58:31 <gip> ok, thx
03:59:22 <LoganCapaldo> > map read . words $ "1.0 2.0 3.0"  :: [Rational]
03:59:24 <lambdabot>  Exception: Prelude.read: no parse
03:59:33 <oerjan> > unfoldr (listToMaybe . readFloat) "1.0 2.0 0.3" :: [Rational]
03:59:35 <lambdabot>  [1%1,2%1,3%10]
03:59:44 <beelsebob> > map (fst . read) . words $ "1.0 2.0 3.0"  :: [Rational]
03:59:45 <lambdabot>  Add a type signature
03:59:54 <beelsebob> I did! Bastard!
04:00:07 <LoganCapaldo> oerjan, you get the clever points
04:00:07 <beelsebob> > (map (fst . read) . words $ "1.0 2.0 3.0") :: [Rational]
04:00:08 <lambdabot>  Add a type signature
04:00:14 <oerjan> :)
04:00:17 <beelsebob> > (map (fst . readFloat) . words $ "1.0 2.0 3.0") :: [Rational]
04:00:18 <lambdabot>  Couldn't match expected type `(a, b)'
04:00:19 <LoganCapaldo> @type read
04:00:21 <lambdabot> forall a. (Read a) => String -> a
04:00:23 <beelsebob> bah
04:00:24 <LoganCapaldo> *cough*
04:00:27 <beelsebob> oh, it's lists
04:00:37 <beelsebob> > (map (fst . head . readFloat) . words $ "1.0 2.0 3.0") :: [Rational]
04:00:39 <lambdabot>  [1%1,2%1,3%1]
04:00:59 <fasta> Anyone familiar with DrIFT? It seems that in a more complicated Haskell file it doesn't see my definitions.
04:01:41 <fasta> All the trivial stuff works, but when I add one such a trivial definition to a valid GHC Haskell file, it stops working.
04:02:00 <fasta> No errors.
04:02:08 * beelsebob suggests using Haskell
04:02:12 <beelsebob> not GHC Haskell
04:02:19 <beelsebob> sorry
04:02:23 <beelsebob> that was useless
04:02:30 <beelsebob> should have kept my mouth shut
04:04:01 <fasta> This module only uses ST and is dependent on instances that are available via undecidable instances and I use cpphs. No really fancy things.
04:05:26 <kfish> beelsebob, you still owe lambdabot a snack for calling her a bastard back there ;-)
04:05:38 <beelsebob> hehe
04:05:38 <beelsebob> true
04:05:43 <beelsebob> @botsnack
04:05:43 <lambdabot> :)
04:05:51 <fasta> @slap lambdabot
04:05:51 * lambdabot slaps lambdabot
04:06:04 <malcolmw> fasta: DrIFT is fairly sensitive to odd Haskell syntax.  Usually it is best to put the data decl + DrIFT annotation in a file on its own, separate from everything else
04:06:28 <beelsebob> wait... she *is* a bastard -- I don't see dons' wife hanging about claiming lambdabot as her spawn
04:06:49 <fasta> malcolmw: ok, although I would have wanted to hear that DrIFT always worked perfectly, this helps me further. Thanks
04:07:42 <kfish> beelsebob, dons adopted her from Pseudonym
04:08:10 <beelsebob> good point -- still, same applies with s/dons/pseudonym/
04:09:04 <kfish> i guess by that definition, all code is bastard code. Makes sense ...
04:09:30 <beelsebob> all sentient code that is :P
04:09:40 <beelsebob> don't go comparing lambdabot to just any old code
04:10:01 <kfish> @botsnack ph3ar
04:10:01 <lambdabot> :)
04:11:30 <quicksilver> does sven panne ever IRC, as far as anyone knows?
04:12:09 <fasta> malcolmw: It seems to be related to using _ in names
04:13:15 <malcolmw> quicksilver: unlikely, I would think.  If he does, then it would outside german working hours.
04:15:25 <quicksilver> malcolmw: *nod*
04:15:40 <quicksilver> malcolmw: opengl is some of the most frustrating code in the world to debug
04:15:55 <beelsebob> haha, tell me about it
04:16:06 <malcolmw> I'm writing some OpenGL code at the moment
04:16:10 <quicksilver> do something wrong, and you just get nothing on-screen at all
04:16:19 <beelsebob> quicksilver: I have some code that I add to debug --
04:16:21 <malcolmw> but I just stick to the simple stuff
04:16:26 <beelsebob> it draws a set of rings
04:16:34 <beelsebob> that allow you to figure out which way the camera is oriented
04:16:46 * quicksilver nods
04:16:50 <beelsebob> (i.e. coloured tick marks round the rings)
04:16:52 <quicksilver> I got my 3D camera sorted (now)
04:16:59 <quicksilver> but I have a problem with drawing 2D stuff
04:17:04 <quicksilver> rasterPos doesn't appear to work
04:17:05 <beelsebob> oh?
04:17:11 <quicksilver> my first call to renderString is fine
04:17:12 * EvilTerran just solved a PE problem in PM with lambdabot ^^
04:17:14 <quicksilver> and I see the text
04:17:20 <ToRA> rasterPos moves with each renderString call
04:17:23 <quicksilver> but then the raster position moves, obviously
04:17:26 <quicksilver> that's supposed to happen
04:17:33 <quicksilver> but when I call 'rasterPos' to reset it
04:17:36 <quicksilver> it doesn't do what I say
04:17:55 <beelsebob> that is somewhat odd
04:18:34 <quicksilver> the starting position of raster pos is 0 0 0 1
04:18:38 <quicksilver> and that draws nicely
04:18:49 <fasta> malcolmw: ok, it is.
04:18:50 <quicksilver> when I call "rasterPos $ Vertex4 0 0 0 1"
04:18:53 <quicksilver> in an attempt to re-set it
04:18:59 <fasta> > let _abc = 3 in _abc
04:19:01 <lambdabot>  3
04:19:04 <quicksilver> it ends up (a) not changing the x coordinate
04:19:08 <fasta> That is valid Haskell 98, right?
04:19:10 <quicksilver> (b) setting the w coordinate to 0
04:19:33 <quicksilver> if you set the w coordinate to 0 everything gets clipped. not good.
04:19:41 <beelsebob> quicksilver: what happens if you use the 2D versoin instead?
04:19:46 <quicksilver> but also it isn't changing the x coordinate as requested, either
04:19:51 <quicksilver> beelsebob: same behaviour
04:19:53 <malcolmw> fasta: yep, that is valid H'98.  But IIRC, DrIFT predates H'98, so it might not recognise that properly
04:20:09 <beelsebob> quicksilver: :/
04:20:26 <beelsebob> quicksilver: how are you finding what the values of the raster pos are?
04:20:34 <quicksilver> get currentRasterPosition
04:20:53 <beelsebob> you calling a glFlush inbetween?
04:21:02 <quicksilver> no
04:21:07 <beelsebob> try that?
04:21:13 <quicksilver> ok
04:21:23 <beelsebob> It really shouldn't have any effect
04:21:23 <ttfh> hmm, couldn't there be a Set monad, so you could have set comprehensions?
04:21:25 <beelsebob> but it's worth a try
04:21:50 <quicksilver> beelsebob: no change
04:22:04 <beelsebob> conclusion: that's weird
04:22:44 <quicksilver> ttfh: it's a bit harder than you might hope, because Set requires an Ord context
04:23:54 <ttfh> so a general Set monad would not work
04:23:57 <ttfh> ?
04:24:09 <quicksilver> ttfh: it is possible, but considerable fiddling is required to get aruond that isue
04:24:10 <malcolmw> fasta: found it - in DrIFT/src/ParseLib2.hs, it defines lowercase as "sat isLower", but it should probably be "sat (\c-> isLower c || c=='_')"
04:24:19 <quicksilver> someone wrote a blog post on it
04:24:31 <fasta> malcolmw: right
04:24:58 <beelsebob> malcolmw: wouldn't that identify "_"
04:25:16 <fasta> beelsebob: for valid input it would work
04:25:18 <malcolmw> beelsebob: yeah, but for the purposes of DrIFT, that wouldn't matter
04:25:34 <fasta> beelsebob: since by definition _ is not valid :)
04:25:43 <beelsebob> malcolmw: oh, okay, I assumed you wanted to avoid the wildcard case
04:25:51 <quicksilver> I would have thought that, syntactically, _ is an identifier. It just has special properties.
04:26:01 <fasta> beelsebob: no, we wanted to include _foo
04:26:20 <ttfh> quicksilver: I think I found the post, thank you
04:26:31 <fasta> malcolmw: do you push the patch to JohnMeacham?
04:26:53 <malcolmw> fasta: you could darcs send it
04:27:06 <fasta> malcolmw: right, that's what I thought.
04:27:24 <quicksilver> beelsebob: if I minimise my example would you look at it and see if I'm doing something really daft?
04:27:37 <beelsebob> quicksilver: sure
04:28:03 <beelsebob> quicksilver: it might be a good idea to try and run the same gl calls in a small C program too, and see if it's a bug in the Haskell bindings
04:28:51 <fasta> malcolmw: the name should be different then.
04:31:08 <fasta> malcolmw: in that file I don't see lowercase defined.
04:32:05 <fasta> malcolmw: I use the darcs version from yesterday
04:36:37 <fasta> malcolmw: never mind, it's called lower
04:37:01 <hpaste>  quicksilver pasted "rasterPos misbehaving" at http://hpaste.org/2684
04:37:10 <quicksilver> beelsebob: there you go
04:37:19 <quicksilver> beelsebob: if you comment out that call to rasterPos you will see some text
04:37:31 <quicksilver> beelsebob: but if you leave it in, you'll only see it if you have very sharp eyesight
04:48:41 <fasta> malcolmw: would killing all the tab characters be a good idea?
04:49:08 <fasta> I always kill them, but tabs are a religious topic.
04:51:17 <beelsebob> quicksilver: I don't see any reason why it shouldn't work
04:51:32 <beelsebob> the only thing I tend to do is I don't usually use the ID transform matrix for 2D
04:51:47 * EvilTerran uses tabs at the start of lines, but never after other characters on a line
04:51:49 <beelsebob> I usually load an iso transformation matrix
04:52:17 * beelsebob uses and editor that automatically inserts spaces when I press tab
04:52:40 <beelsebob> trying to use any language that has a layout rule when there's a mix of tab and space is horrific
04:52:42 <EvilTerran> and i use spaces if i want to line two characters up exactly
04:52:56 <fasta> malcolmw: how can I build DrIFT?
04:53:02 <fasta> malcolmw: it seems to be missing some files.
04:53:09 <EvilTerran> eg, i indent the |s in guards after the first one with spaces
04:53:33 <EvilTerran> but there might be tabs before the spaces if the definition's in, say, a where{}
04:53:39 <EvilTerran> >:]
04:55:10 <kjdf> in GHC, when I get a type error
04:55:22 <kjdf> what does "inferred type" and "expected type" mean?
04:56:02 <oerjan> > map "x" "y"
04:56:04 <lambdabot>  Couldn't match expected type `a -> b'
04:56:25 <beelsebob> kjdf: inferred type is the type that GHC has inferred for something, the expected type is the type the type signature said it should be
04:56:31 <beelsebob> if they don't match, there's a problem
04:57:17 <GyroL> what is the shortest way of creating an eps (postscript) file using haskell?
04:57:33 <kjdf> actually that map example is a good one, thank oerjan
04:57:39 <EvilTerran> GyroL, by hand. there's no library for it, afaik
04:58:22 <Botje> GyroL: there's a PDF library though. maybe you can steal from taht
05:00:24 <beelsebob> GyroL: main = do writeFile "doom.eps" "%!PS-Adobe-1.0 EPSF-1.0"
05:00:38 <beelsebob> it create's "an" EPS file
05:00:42 <beelsebob> it might not be the one you want though
05:01:10 <GyroL> EvilTerran, Botje: thanx I will ook ta the PDF library
05:01:21 <oerjan> kjdf: "x" is of type String, while the slot for map _ "y" requires type a -> b, i thought inferred was for the type from the "inside", so to speak, while expected is what the context wants.  but i am not sure.
05:01:46 <GyroL> beelsebob: no I meant more putting the actual drawing commands and figuring out the optimal bounding box
05:02:26 <oerjan> confusingly, both may be inferred somehow.
05:04:45 <ToRA> quicksilver:     rasterPos (Vertex4 0 (0::GLint) (-5) 1)
05:04:47 <ToRA> try that
05:07:46 <quicksilver> ToRA: thank you; one moment
05:08:51 <quicksilver> beelsebob: I don't think the iso matrix matters; but certainly I don't understand how it works the first time but explicitly breaks if I call rasterpos
05:09:26 <ToRA> quicksilver: if that works (it does here), i guess it's because your explictly calling rasterPos with a z co-ord right on a clipping plane
05:09:37 <ToRA> but how the gl logic works it out like that i have no idea
05:09:56 <malcolmw> fasta: sorry, been to lunch.  I guess DriFT needs you to run autoconf or autoreconf, then configure, then make.
05:10:55 <quicksilver> ToRA: maybe it's a floating representation iss
05:11:05 <quicksilver> ToRA: maybe the 0.0 was actually -0.0000001
05:11:13 <quicksilver> ToRA: but my explicit 0.0 is really 0.0.
05:12:08 <quicksilver> ToRA: certainly that makes the text display consistently! thanks you. I don't understand why it's displaying at 400 300 and not at 0 0
05:12:15 <quicksilver> ToRA: but at least I can see it
05:13:32 <quicksilver> is there an implicit (2D) transform that is different?
05:14:00 <quicksilver> ah, 400 300 is the middle of my screen. Some implicit 2D transform puts the 2D origin at the center of your screen?
05:14:30 <int-e> opengl does that
05:14:37 <ToRA>   ortho2D 0 (fromIntegral w) 0 (fromIntegral h)
05:14:47 <ToRA> i usually do that before playing with text
05:14:52 <ToRA> makes things easier to think about
05:15:06 <ToRA> i assume the 4d co-ord you give is in world co-ordinates
05:15:14 <ToRA> and 0,0,(-5) is in the middle of the screen
05:15:23 <quicksilver> well what I don't understand is that I explicit set the position to 0 0
05:15:26 <quicksilver> and then query the position
05:15:31 <quicksilver> and it answers "400 300"
05:15:33 <Zao> The raster position will be transformed.
05:15:50 <quicksilver> seems strange that the 'set raster position' and 'get raster position' are not in sync
05:15:59 <quicksilver> I'd expect them to both work in the same coord system
05:16:02 <quicksilver> transformed or otherwise
05:16:16 <ToRA> is there are currentRasterPosition $=
05:16:24 <ToRA> which is different to rasterPos ?
05:16:36 <quicksilver> ToRA: very possibly. Let me try that
05:16:40 <ToRA> the latter may just be a utility function to do the transform for you
05:17:33 <quicksilver> there is, but it has the same behaviour
05:17:41 <quicksilver> you call (currentRasterPosition $= 0 0 -5 1)
05:17:45 <quicksilver> and then 'get' it
05:17:53 <quicksilver> and the answer is 400 300 0.888 5.0
05:18:21 <quicksilver> sounds like it might be a haskell bindings bug
05:19:02 <quicksilver> HEH
05:19:08 <quicksilver> oops, didn't mean caps. Heh.
05:19:20 <quicksilver> currentRasterPosition is defined just to use the 'setter' rasterPos
05:19:46 <ToRA> indeed
05:19:48 <ToRA> mmm
05:20:50 <kjdf> does specifying type constraints in type declarations make any sense?
05:20:52 <kjdf> like this:
05:20:53 <quicksilver> GetCurrentRasterPosition somes from QueryUtils.hs
05:20:55 <kjdf> newtype Monad m => AutomatonM m a b = AutoM (
05:20:55 <kjdf>    a -> m (b, AutomatonM m a b)
05:20:55 <kjdf>  )
05:21:10 <quicksilver> which is not an exported file, bother
05:21:54 <quicksilver> seems like it's some direct hook into the state machine internals
05:22:01 <quicksilver> GetCurrentRasterPosition -> Just 0xb07
05:22:04 <quicksilver> scary stuff
05:22:26 <ToRA> looks like the only way to set it in c gl is via the transforms tho
05:22:29 <ToRA> http://www.opengl.org/documentation/specs/man_pages/hardcopy/GL/html/gl/rasterpos.html
05:22:31 <lambdabot> http://tinyurl.com/2uxd3e
05:23:00 <quicksilver> ToRA: not sure I follow what you mean?
05:23:34 <ToRA> so from the c man page, the rasterPos call will transform by the current modelview etc matrices
05:23:53 <ToRA> and there doesn't seem to be a related link to a call to set it in just window co-ordinates
05:24:03 <ToRA> wheras the getter is designed to give it back in window co-ordinates
05:24:12 <quicksilver> hmm
05:24:23 <ToRA> so if you want to set in window co-ords, you'll need to use an ortho2D projection setup call first
05:24:26 <quicksilver> but your 0 0 call certainly isn't transforming by my modelView co-ords
05:24:32 <ToRA> yes it is
05:24:38 <quicksilver> my modelView is all twisted
05:24:43 <ToRA> you do a loadIdentity in the example just before it
05:24:46 <quicksilver> something lying in the x/y plane would be flat
05:25:15 <ToRA> it's rendering a bitmap on the screen
05:25:32 <ToRA> it's just projecting a point from 3d to 2d, and using that point as the bottom-left corner of the text
05:25:50 <quicksilver> hmm
05:25:57 <VerbalDK> take picrures in game and use for wallpaper?
05:26:13 <VerbalDK> or spray paint
05:26:21 <quicksilver> ToRA: that doesn't seem to be true
05:26:34 <quicksilver> ToRA: but maybe I'm misunderstanding something
05:26:49 <ToRA> mmm, maybe not bottom-left, but it is some fixed point for the alignment of the text
05:27:20 <quicksilver> that's not the bit I'm questioning
05:27:29 <quicksilver> I'm not sure it's really using "world coordinates" and a 3d project like you suggest
05:27:37 <quicksilver> oh
05:27:38 <quicksilver> doh
05:27:43 <quicksilver> I have an extra loadIdentity in there
05:27:46 <ToRA> camera is at 0,0,0
05:27:46 * quicksilver sighs
05:27:47 <quicksilver> of course
05:27:47 <ToRA> yeah
05:27:48 <ToRA> :)
05:27:54 <quicksilver> I cancelled my 'lookAt'
05:28:26 <quicksilver> actually that's useful, because I wanted to know how to attach 2D text to the 3D world
05:28:29 <quicksilver> now I know how :)
05:28:33 <ToRA> yeah
05:28:47 <quicksilver> thanks for all your help!
05:28:49 <ToRA> np
05:29:40 <quicksilver> what is the purpose of the w coordinate?
05:29:54 <ToRA> no idea
05:30:06 <quicksilver> :)
05:30:14 <ToRA> but if you set it to non-1.0 everything goes very bad
05:30:19 <quicksilver> ;)
05:31:23 <laziest> exit
05:31:33 <laziest> sorry... too much of command line perhaps..
05:39:43 <dcoutts_> @seen dons
05:39:44 <lambdabot> I saw dons leaving #xmonad and #haskell 4h 40m 52s ago, and .
05:39:48 <dcoutts_> @seen bos
05:39:49 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 6h 59m 22s ago.
05:47:15 <shapr> Good morning #haskell
05:53:21 <dcoutts_> good morning shapr
05:53:36 <masak> morning, shapr
05:53:39 <shapr> How's code?
05:54:10 <kfish> bastardly
05:55:20 <olsner> bastardly, indeed
05:56:23 <dcoutts_> hmm, new intel and amd cpus have indirect branch predictors, should speed up STG code significantly
05:56:31 <nornagon> @spell parentheses
05:56:39 <dcoutts_> since STG uses indirect branches for almost everything
05:56:55 <nornagon> @spell aoeupyiqjiai
05:57:09 <nornagon> @spell your_face
05:57:09 <shapr> dcoutts_: Barcelona or what?
05:57:17 <nornagon> @botsmack
05:57:18 <lambdabot> :)
05:57:20 <dcoutts_> shapr: yes
05:57:23 <olsner> oh, that's cool
05:57:25 <shapr> Hm, maybe I should get one.
05:57:29 <dcoutts_> shapr: and core 2 from intel
05:57:31 <kfish> nornagon?
05:57:41 <shapr> dcoutts_: spiffy, was about to ask that.
05:57:46 <nornagon> kfish?
05:57:58 <dcoutts_> shapr: I intend to get an amd quad next year when they come out in desktop versions
05:58:04 <shapr> cool!
05:58:13 <earthy> didn't mrchebas' optimisations that go into 6.8 actually remove quite a lot of the indirect branches and speed up the predictionmisses?
05:58:26 <shapr> I wish we had a haskell.org build farm for benchmarking and optimization.
05:58:45 <dcoutts_> shapr: and one of those nice small solid state hard drives to put the OS on, should speed up application loading etc
05:59:02 <dcoutts_> shapr: aye, that'd be nice, and to run builds of hackage packages
05:59:20 <dcoutts_> we run hackage builds atm, though I don't know on which box
05:59:33 <shapr> Yeah, I found a bug in the hxt-7.3 recently, emailed the author.
05:59:38 <shapr> Couldn't remember my trac login :-)
06:02:03 <fasta> When I load module Foo exporting symbols bar and zork, but also containing definitions for abc and cde, shouldn't :t abc return the type of abc and not "not in scope"?
06:02:25 <fasta> For once, I found a reproducable bug in GHCi :)
06:02:32 <EvilTerran> how did you load it?
06:02:45 <fasta> EvilTerran: :l
06:02:56 <fasta> EvilTerran: and ghci <file>
06:03:14 <EvilTerran> does it have the * next to it in the prompt?
06:03:35 <fasta> EvilTerran: Prelude DataP>  (so, no)
06:03:54 <EvilTerran> hm.
06:04:40 <EvilTerran> :m *DataP?
06:04:53 <olsner> @pl (\f g h -> ((h `g`) `f`))
06:04:53 <lambdabot> (.)
06:05:23 <fasta> EvilTerran: module 'DataP' is not interpreted
06:05:33 <fasta> EvilTerran: that must be the problem
06:05:35 <EvilTerran> ah, there's the problem
06:05:43 <EvilTerran> it can't see unexported stuff in compiled modules
06:05:46 <olsner> @type \f g h -> (f . g) h
06:05:46 <fasta> EvilTerran: question would be how to solve it now?
06:05:49 <olsner> @type (.)
06:05:54 <EvilTerran> 'cos such stuff might even be compiled out of existence, say
06:05:56 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:05:56 <fasta> EvilTerran: since I am loading the source file
06:05:57 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:06:04 <EvilTerran> hm
06:06:35 <fasta> EvilTerran: I find it enough material for a bug report.
06:06:58 <EvilTerran> if just a user-interface bug.
06:07:26 <fasta> EvilTerran: do you know a way to work around it then? I assume deleting the compiled files?
06:07:27 <EvilTerran> "this isn't a bug, <blah>'s how you do it!" "well, then it's either a UI bug or a documentation one"
06:07:44 <pejo> earthy, you mean the tagging optimisations? If so, then yeah, the paper claimed it removed about half of the indirect branches in code.
06:08:02 <EvilTerran> that would work, i imagine
06:08:39 <quicksilver> fasta: touch the text file, so it's newer
06:08:42 <quicksilver> fasta: and I agree it's a bug
06:08:53 <quicksilver> fasta: funnnily enough I discovered it myself just yesterday :)
06:11:38 <fasta> quicksilver: did you already report it?
06:12:27 <fasta> If everyone reported all their problems, it would soon be quality software instead of a mine field of bugs.
06:13:00 <mrd> actually it would be a mine field of known bugs
06:13:28 <quicksilver> fasta: no, I was offline and I intended to report it today but haven't actualy done so
06:13:39 <EvilTerran> at least the mines all have little flags on them in that case
06:13:46 <Igloo> It's documented behaviour
06:13:59 <quicksilver> Igloo: but highly unintuitive
06:14:07 <ricky_clarkson> Please don't expand that menu.  That is the domain of bugs.
06:15:09 <quicksilver> Igloo: the functionality that ":load Foo.hs" will actually *ignore* my request and load "Foo.o" if that is newer, and enter a less useful mode in which many tasks are impossible.... seems like a curious feature :)
06:15:27 <quicksilver> Igloo: if I wanted to load Foo.o, wouldn't I type ":load Foo.o" ?
06:16:18 <olsner> if ghci is to be usable as a debugging tool, it should be able to ignore that some things are hidden and just access everything
06:16:46 <olsner> at least I use it more like a debugger than a REPL
06:17:31 <quicksilver> of course I appreciate that if Foo depends on Bar, it will load the compiled version of Bar if possible
06:17:37 <quicksilver> that makes good sense, it can be a lot faster
06:17:44 <Lemmih> olsner: Hidding things? Like things that aren't exported from installed packages?
06:17:49 <quicksilver> but the compiled version of Foo itself doesn't seem useful
06:18:15 <quicksilver> Lemmih: if there is a .o file of the file you try to explicitly load, it loads that instead and you can't query non-exported symbols
06:18:46 <Lemmih> quicksilver: And I'm glad it does so.
06:18:57 <quicksilver> Lemmih: why? how is that feature useful?
06:19:06 <EvilTerran> speed?
06:19:31 <quicksilver> if speed was the reason, I woul dbe happy to type :load Foo.o
06:19:36 <quicksilver> if that was, indeed, what I wanted to happen
06:19:43 <olsner> Lemmih: for example - but it's mostly unexported symbols from modules I wrote that are interesting
06:20:00 <Lemmih> quicksilver: How about just deleting the .hi files?
06:20:04 <Lemmih> Same to olsner.
06:20:28 <Lemmih> Or use -fforce-recomp?
06:20:31 <quicksilver> Lemmih: yes, I could. Or I could delete the .o files.
06:20:39 <quicksilver> but that's not what I am saying
06:20:48 <quicksilver> I am saying "why is this a useful feature?"
06:20:54 <quicksilver> "why would I ever want this?"
06:21:09 <Lemmih> Why would you ever want to load your code fast?
06:21:21 <quicksilver> if I ask to load a .hs file
06:21:25 <VerbalDK> to get more time for programming
06:21:26 <quicksilver> then sure I want the .hs file
06:21:32 <quicksilver> I"m trying to debug/explore it, surely?
06:21:36 <quicksilver> that's what ghci is for
06:22:20 <quicksilver> witness the fact that various editor modes have a keystroke to :load the current buffer
06:22:42 <quicksilver> a keystroke which "fails" when there is a new .o file lying around. "fails" in the sense that it changes behaviour to a less helpful behaviour.
06:23:07 <fasta> quicksilver: If one would be really an ass one would now say that the editor modes don't first delete the .o files.
06:23:09 <Lemmih> quicksilver: That behaviour isn't obviously superior, imho.
06:23:14 <EvilTerran> it does seem very odd to me that it'll load the .o when you tell it to load the .hs
06:23:24 <EvilTerran> if you want the .o, you can tell it to load the .o
06:23:46 <quicksilver> I agree with EvilTerran
06:23:59 <quicksilver> (.o is even one character fewer to type)
06:24:07 <quicksilver> I'm not disputing that the ability to load a .o is useful
06:24:08 <VerbalDK> EvilTerran for precident
06:24:10 <Lemmih> Why .o and not .hi?
06:24:14 <VerbalDK> president*
06:24:25 <quicksilver> (although I do dispute that it's more useful than the ability to interpret a .hs)
06:24:51 <quicksilver> but I don't understand why it should be considered a feature to transparently rewrite my explicit request to load a .hs file
06:24:52 <EvilTerran> likewise, i'm sure you can explicitly load the .hi
06:24:54 <quicksilver> into something else
06:25:46 <fasta> So, there are three people on one side and one undecided.
06:26:19 <fasta> And one claiming that because it's documented, it's legal to put a mine somewhere.
06:26:26 <Lemmih> Who's the undecided one?
06:26:34 <fasta> Lemmih: you
06:26:44 <fasta> Lemmih: "not obviously superior"
06:27:27 <EvilTerran> still no-where near quorum
06:27:44 <Lemmih> Oh, I'm mildly against it. That is, I wouldn't mind a flag for it.
06:28:10 <doserj> count me in the "if i load a file, i want its contents in scope"-camp
06:29:04 <Lemmih> Thank goodness we're not in a democracy (:
06:29:19 <quicksilver> indeed, the decision will be taken by the ghc maintainers
06:29:30 <quicksilver> but they will undoubtedly listen to the arguments presented in well-written bug reports
06:29:33 <Lemmih> No, the decision will be taken by any GHC hacker.
06:29:48 <quicksilver> now you are arguing with me for the sake of arguing
06:30:05 <Lemmih> Go ahead and write. I'll assure you they won't turn away a decent patch.
06:30:06 <quicksilver> that is not incompatible with what I said
06:30:35 <quicksilver> is it a requirement, now, that to submit a bug report for ghc you have to be prepared to write a patch?
06:30:38 <quicksilver> that never used to be the case
06:30:58 <Lemmih> I'm saying that it's not obviously superior so you most likely have to write it yourselves.
06:31:56 <Lemmih> Some people think (.) should have its arguments reversed. Submitting a bug report won't likely get that "fixed".
06:34:29 <quicksilver> submitting a patch wont get that "fixed" either :)
06:34:47 <quicksilver> I would be content with submitting a decent bug report and seeing if the ghc team agree with my analysis
06:37:58 <fasta> quicksilver: http://hackage.haskell.org/trac/ghc/ticket/1682
06:38:00 <lambdabot> Title: #1682 (ghci Foo.hs should load the Foo.hs file interpreted) - GHC - Trac
06:38:21 <VerbalDK> pretty handy bot
06:38:27 <VerbalDK> :)
06:38:32 <fasta> Everyone vote there to use your democratic(?) powers by adding your e-mail address.
06:38:52 <fasta> s/to use/by using
06:39:37 <fasta> Oh, great, my newlines were ignored.
06:40:11 <fasta> (yes, I know I should use other syntax)
06:48:23 <ricky_clarkson> VerbalDK: The bot is a better Haskeller than me. ;)
06:49:53 <ricky_clarkson> @pl \a b c -> a*b+c*b+a*c
06:49:54 <lambdabot> ap (flip . (liftM2 (+) .) . (`ap` (*)) . (((.) . (+)) .) . (*)) (*)
06:52:11 <EvilTerran> i would dispute the claim that that is "better"
06:52:27 <puusorsa> @type ap
06:52:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:52:40 <EvilTerran> ap = liftM2 ($)
06:52:52 <puusorsa> hooray!
06:52:55 <ricky_clarkson> For that one I'd actually hope some kind of permutation function.
06:52:59 <EvilTerran> @src ap
06:52:59 <lambdabot> ap = liftM2 id
06:53:04 <EvilTerran> hoorj~!
06:53:25 <pastorn> @type liftM2
06:53:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:54:44 <chr1s_> hey everyone!
06:55:26 <quicksilver> ricky_clarkson: let l = [a,b,c] in sum $ zipWith (*) l (tail.cycle l)
06:55:47 <EvilTerran> > (liftM2 zip id (liftM2 (:) last init)) [1,2,3]
06:55:48 <lambdabot>  [(1,3),(2,1),(3,2)]
06:56:01 <chr1s> In what version of GHC is Control.Monad.Writer.Strict available?
06:56:06 <EvilTerran> hm. quicksilver's is better. "tail.cycle"... that's a clever one.
06:56:15 <chr1s> it's not in 6.6, but is it in 6.6.1?
06:56:37 <EvilTerran> > (sum . liftM2 zipWith (*) id (liftM2 (:) last init)) [1,2,3]
06:56:37 <opqdonut> > let l = [1,2,3] in sum . zipWith (*) $ l (drop 1 $ cycle l)
06:56:38 <lambdabot>  Couldn't match expected type `[b -> c]'
06:56:39 <lambdabot>  Couldn't match expected type `[a]'
06:56:41 <ricky_clarkson> :t tail.cycle
06:56:43 <lambdabot> forall a. [a] -> [a]
06:56:45 <opqdonut> EvilTerran: hi five :)
06:56:52 <EvilTerran> woo!
06:57:23 <opqdonut> > let l = [1,2,3] in sum . zipWith (*) $ l (tail $ cycle l)
06:57:24 <lambdabot>  Couldn't match expected type `[a]'
06:57:32 <crazy_coder> hello everyone
06:57:47 <opqdonut> eh, what gives
06:57:55 <EvilTerran> > sum . liftM2 (zipWith (*)) id (tail.cycle) $ [1..3]
06:57:56 <lambdabot>  11
06:57:57 <quicksilver> opqdonut: you rewrote my $ to a .
06:58:00 <quicksilver> opqdonut: incorrectly :)
06:58:25 <quicksilver> opqdonut: cos zipWith (*) takes two arguments
06:58:37 <Saizan> > let l = [1,2,3] in sum . ap (zipWith (*)) (tail . cycle) $ l
06:58:38 <lambdabot>  11
06:58:48 <opqdonut> > let l = [1,2,3] in sum $ zipWith (*) l (tail $ cycle l)
06:58:49 <opqdonut> yeh
06:58:50 <lambdabot>  11
06:59:59 * EvilTerran tries to work out why ap does that there
07:00:07 <int-e> > let f xs = sum [a*b | a:bs <- tails xs, b <- bs] in f [1,2,3]
07:00:09 <lambdabot>  11
07:00:26 <EvilTerran> > sum . liftM2 id (zipWith (*)) (tail.cycle) $ [1..3]
07:00:28 <lambdabot>  11
07:00:31 <opqdonut> nice int-e
07:00:33 <quicksilver> EvilTerran: ap in the (->) monad gives you a kind of 'before and after' effect
07:00:41 <xerox> ?pl liftM2 id
07:00:41 <lambdabot> ap
07:00:44 <EvilTerran> whoa...
07:00:56 <xerox> It is just the S combinator.
07:01:00 <EvilTerran> liftM2 id f g = liftM2 f id g in (e->)?
07:02:00 <xerox> ?djinn (e -> a -> b) -> (e -> a) -> (e -> b)
07:02:00 <lambdabot> f a b c = a c (b c)
07:02:15 <EvilTerran> int-e, that one's good; it's a better expression of permuations in general rather than what we're doing
07:02:17 <int-e> > let q xs = (sum xs^2 - sum (map (^2) xs)) `div` 2 in q [1,2,3]
07:02:18 <lambdabot>  11
07:02:27 <EvilTerran> (consecutive pairs is less useful...)
07:02:38 <quicksilver> > (,) `ap` (*2) $ 3
07:02:40 <lambdabot>  (3,6)
07:02:52 <quicksilver> EvilTerran: that's what I mean by 'before and after'
07:03:12 <quicksilver> EvilTerran: although the binary function doesn't have to be (,). It's just easy to show the effect if it is
07:03:19 <EvilTerran> yeah, i figured. i'm still trying to work out why it does that.
07:03:27 <int-e> opqdonut: well it's different, both have their uses. I just like the  y:ys <- tails xs  idea :)
07:03:48 <opqdonut> yeah that exactly
07:06:26 <int-e> > let g xs = sum [a*b | a:b:_ <- tails (xs ++ take 1 xs)] in g [1,2,3]
07:06:28 <lambdabot>  11
07:07:46 <ricky_clarkson> Is there a relationship between the sum of all the permutations of [x,y,z] and x*y*z?
07:08:02 <ricky_clarkson> Er, the sum of all the multiples of the permutations of [x,y,z].
07:08:13 <quicksilver> there are relationships, yes
07:08:19 <quicksilver> I've forgotten what they're called
07:08:34 <quicksilver> a good text on polynomial analysis will explain them
07:08:41 <int-e> symmetric polynomials
07:08:46 <quicksilver> you're talking about relationships between sums and products of roots
07:08:51 <quicksilver> (of a cubic polynomial)
07:09:05 <int-e> elementary symmetric polynomials that is
07:09:36 <ricky_clarkson> Maths is great, first you have to rephrase your question in bigger words, then you get to spend a day on Wikipedia. ;)
07:10:47 <opqdonut> :)
07:10:52 <quicksilver> ricky_clarkson: http://mathforum.org/library/drmath/view/61024.html
07:10:52 <int-e> but your question wasn't very clear, maybe you meant something different.
07:10:53 <lambdabot> Title: Math Forum - Ask Dr. Math
07:11:35 <quicksilver> ricky_clarkson: your numbers are the coefficients of the polynomial which has those roots
07:12:01 <ricky_clarkson> quicksilver: I'm struggling to see how my question relates to solving polynomials.
07:12:08 <int-e> that would be prettier if they used monic polynomials all the way :/
07:12:12 <quicksilver> it doesn't directly
07:12:26 <quicksilver> it's just a fact that the relationships between the sums and products you are talking about
07:12:40 <quicksilver> has been studied in detail because they *are* in fact the coefficients of the cubic with those roots
07:12:59 <quicksilver> that's the historical reason that the relationships between those numbers was found interesting
07:13:04 <ricky_clarkson> foldl (+) 0 (map (*) $ allPerms [3,10,12]) - is there a shortcut to the answer that doesn't involve computing allPerms?
07:13:10 <ricky_clarkson> That's my question, roughly.
07:13:31 <ricky_clarkson> Where allPerms is [a] -> [(a,a)]
07:13:57 <int-e> what does allperms do exactly?
07:14:25 <ricky_clarkson> Returns a list of all possible pairs from the list (reversed pairs not included)
07:14:42 <ricky_clarkson> ..and equal pairs not included.
07:14:51 <int-e> ah. these are combinations of 2 elements of the list.
07:15:15 <ski> (pairs of elements at equal position, itym)
07:15:51 <ricky_clarkson> [1,2,3] would give [(1,2),(1,3),(2,3)]
07:15:54 <int-e> ricky_clarkson: I gave a formula above. let S be that sum, then 2*S + sum (x_i^2) = (sum x_i)^2 where the x_i are the elements of the list and the sums range over the whole list.
07:16:54 <EvilTerran> it gets all the nC2 pairs from the list, then
07:17:16 <EvilTerran> allCombs would be a more accurate name, methinks
07:17:19 * ricky_clarkson has some reading to do, thanks.
07:20:04 <haxplorer> data Bot = Bot { socket :: Handle }
07:20:24 <haxplorer> In the above statemnet I don't understand the socket::Handle part
07:20:59 <quicksilver> haxplorer: would you understand data Bot = Bot Handle ?
07:21:15 <haxplorer> quicksilver: ya.
07:21:27 <quicksilver> haxplorer: it's the same
07:21:27 <quicksilver> except the field is now named
07:21:34 <quicksilver> and you get to use special syntax if you want
07:21:46 <quicksilver> Bot { socket = foo }  as a value instead of simply Bot foo
07:22:03 <quicksilver> and 'socket' works as a selector function
07:22:14 <haxplorer> so, I can have any name in that place?
07:22:18 <quicksilver> so if b :: Bot then you cahn write 'socket b' for "get b's socket"
07:22:25 <quicksilver> yes, it's just an identifier
07:22:31 <haxplorer> ok.
07:22:42 <haxplorer> Now I get it.. Thanks :)
07:40:00 <bos> @seen dcoutts_
07:40:01 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 1h 26m 2s ago.
07:40:16 <dcoutts_> hia bos, I was wondering if I was on the reviewers ml
07:40:33 <bos> if you haven't been spammed yet, you're not
07:40:34 <bos> :-)
07:40:34 <dcoutts_> ok :-)
07:40:59 * shapr subscribed
07:41:01 <bos> but feel free to add yourself
07:41:07 <dcoutts_> bos: ok
07:45:17 <haxplorer> import Control.Exception hiding (catch)
07:45:17 <haxplorer> import IO
07:45:17 <haxplorer> I've imported Control.Exception hiding catch. but still ghci tells me that "Ambiguous occurrence `catch' It could refer to either `catch', imported from IO at server.hs:1:0-8 or `catch', imported from Control.Exception at server.hs:9:0-23" What is wrong here?
07:49:06 <fasta> haxplorer: paste complete code to hpaste.org
07:49:20 <haxplorer> fasta: ya. 1 min
07:49:22 <fasta> haxplorer: either you use a compiler with a bug or it's you
07:50:36 <quicksilver> haxplorer: you import Control.Exception a second time at line 9 ?
07:52:46 <haxplorer> quicksilver: oh! Thanks.. Didn't notice that..
07:53:18 <hpaste>  Visitor967 pasted "Overview" at http://hpaste.org/2686
07:53:25 <hpaste>  Visitor497 pasted "Position" at http://hpaste.org/2687
07:56:18 <fasta> Oh, cool, spam.
07:57:06 <swiert> shapr: Do you still have a copy of the hawiki somewhere?
07:58:21 <fasta> Is it possible to ask how much memory evaluating exp takes and if it takes more than 5MB abort the computation?
07:58:29 <fasta> (In GHC)
07:59:08 <fasta> This,  to test strictness properties.
07:59:38 <cjeris> there's _pastebin_ spam now?  that's really sad
08:00:17 <fasta> cjeris: it's not even commercial
08:00:32 <quicksilver> fasta: I think you can run ghc in a subprocess with heap size limits
08:01:23 <cognominal_> @src length
08:01:24 <lambdabot> Source not found. Do you think like you type?
08:01:25 <quicksilver> fasta: I'm not aware if there are any ghc API flags for it, it's not impossible
08:02:24 <kfish> fasta, cjeris, hpaste has been hit by spam before, this stuff looks like someone is testing a linkspam bot (eg. google result rank info)
08:03:01 <shapr> swiert: probably
08:03:01 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
08:04:12 <shapr> Can't find it at the moment though.
08:04:26 <fasta> If #haskell would be hosted in Europe and we would ban any non-EU connections, we would be able to sue all the spammers.
08:04:32 <swiert> shapr: Ok. I'd like to move over TMR content to the new wiki.
08:04:45 <puusorsa> fasta, hooray!
08:04:47 <swiert> I'm not entirely sure what the easiest way to do it is...
08:05:33 <shapr> swiert: You know about http://www.haskell.org/tmrwiki/ ?
08:05:34 <lambdabot> Title: FrontPage - TmrWiki
08:05:54 <shapr> That has issues two through five
08:05:55 <swiert> shapr: No! Thanks for the link.
08:06:07 <shapr> Issue One was on hawiki though, I think.
08:06:20 <swiert> shapr: Yeah. I found Issue 1 on the way back machine.
08:06:29 <olsner> :t (//)
08:06:32 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
08:06:41 <shapr> swiert: Sounds like you have everything then.
08:07:47 <swiert> shapr: Yep. Thanks for your help.
08:07:59 <swiert> Is there some easy way to convert MoinMoin to MediaWiki markup?
08:08:45 <masak> what's the difference between an Ix and a positive integer?
08:09:52 <kfish> swiert, heh, I was going to ask about converting it to latex :-)
08:10:29 <fasta> masak: There meta types don't match.
08:10:34 <fasta> masak: Their*
08:10:42 <mnislaih> what's the name of f when you use explicit recursion as in > let fac x = fix \f -> if x==0 then 1 else x * f (x-1)
08:10:44 <fasta> masak: Integer is a type, Ix is a type class
08:10:51 <mnislaih> is it recursion knot ?
08:11:07 <vincenz> @remember fasta masak: Their meta types don't match
08:11:07 <lambdabot> Done.
08:11:13 <quicksilver> masak: you can index arrays by other things than integers
08:11:21 <quicksilver> masak: the most common example is pairs of integers
08:11:27 <quicksilver> masak: so you get 2D arrays
08:11:37 <fasta> masak: A more common word for meta type is 'kind'.
08:12:00 <fasta> masak: oh, wait, that's non-sense.
08:12:03 <swiert> kfish: I can try... html2latex might work.
08:12:43 <fasta> masak: You can also make String an instance of Ix
08:13:00 <fasta> masak: for example "1" can be interpreted as 1 etc.
08:13:26 <fasta> masak: but you can also use "0" "1" "10" etc
08:13:40 <fasta> I don't think other people reading your code would love you for that, though.
08:14:29 <fasta> masak: does that make sense to you?
08:14:32 <mboes_> @seen ndm
08:14:32 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 51m 27s ago, and .
08:15:08 <fasta> I know a much more terrible form of spam, though.
08:15:43 <fasta> The only reason it didn't invade IRC channels, I guess, is that A) it doesn't make money B) People don't like to have their ISP ban them.
08:16:04 <fasta> It involves getting questions from previous IRC discussions and asking them again.
08:16:19 <fasta> With public IRC logs, this is extremely easy to do.
08:17:00 <quicksilver> I doubt it's (B)
08:17:05 <quicksilver> spammers don't use their own machines
08:17:17 <quicksilver> not good spammers, anyway :)
08:17:29 <quicksilver> (A) is always the key.
08:17:37 <fasta> quicksilver: A is not always the key
08:17:44 <quicksilver> But ircops are pretty good at clamping offenders pretty quickly
08:17:46 <quicksilver> no, not always
08:17:50 <quicksilver> most of the time then :)
08:18:00 <fasta> quicksilver: see Frost and you will understand
08:18:27 <fasta> quicksilver: there is or was a person that spammed all the boards.
08:18:50 <fasta> quicksilver: and without a way to find out who it was, you have a nightmare spam problem.
08:19:26 <fasta> The only way to fight it is to store all the messages sent in a database, but that doesn't scale terribly good.
08:19:43 <fasta> Since deciding whether something is spam will be a function dependent on time.
08:19:45 <puusorsa> the best way to fight spam is to kill all spammers
08:19:48 <puusorsa> twice
08:19:51 <puusorsa> so they stay dead.
08:20:21 <fasta> So, let's say in 2000 years, when Haskell is the sole programming language of choice, one could still repeat this discussion.
08:20:24 <fasta> ;)
08:20:53 <int-e> I hope we have something better by then.
08:20:54 <fasta> And you need to be able to do it in real-time.
08:21:02 <int-e> Haskell is neat but it's not without flaws.
08:21:14 <beelsebob> its biggest flaw is that no one uses it
08:21:23 <fasta> int-e: heh, you don't need to convince me of that.
08:21:31 <int-e> fasta: I'm aware of that.
08:36:22 <shapr> SHAZAM!
08:41:57 <shapr> So, what's going on?
08:43:20 <shapr> Anybody writing Haskell code?
08:43:33 <quicksilver> if only
08:44:14 <dylan> no, sadly.
08:44:15 <conal> shapr: i am!  getting eros into shape.  updating helper libs & doces
08:44:19 <conal> (docs)
08:44:33 * dylan is writing lua code to generate C to use from lua...
08:45:09 <shapr> conal: That's cool!
08:45:13 <shapr> dylan: That's cool too.
08:45:24 <dylan> shapr: it looks like a DSL too.
08:45:29 <danderson> I'd like to write haskell, to get to know it better, but I can't find any project to do.
08:45:39 <dylan> method 'name' [[ C code ]]...
08:45:43 <shapr> danderson: You could write a simple lambdabot plugin to get started.
08:45:58 <shapr> dylan: Yeah, sounds like it.
08:46:08 * dylan just wants vty to become thread safe.
08:46:33 <shapr> conal: Oh you asked me before about what I wanted to use hs-plugins for.. and I remembered! And I think it may have something to do with Eros even.
08:46:48 <conal> shapr: yeah??
08:47:02 <shapr> conal: I wanted to have a shared 3D space like #haskell, have you seen OpenCroquet for example?
08:47:26 <shapr> And I wanted to be able to create 3D objects (or load BSPs, or whatever) and attach code to those objects.
08:47:42 <conal> i have seen OC.  yes! let's do the shared 3D space.  i've been thinking about very similar app.
08:48:04 <conal> shared visual space with downloadable interacting toys.
08:48:23 <danderson> shapr: interesting. I'll have to look into that.
08:48:36 <shapr> I figured I'd start with Frag, but it doesn't build on 64-bit systems, and it's not easy to fix.
08:48:41 <shapr> conal: Exactly!
08:49:09 <conal> shapr: if you're serious, i'd love to collaborate.  i have a bunch of relevant experience & ideas.
08:49:29 <shapr> I'm not sure if I'm serious or not right now.
08:49:39 <shapr> But it is a deeply fascinating idea.
08:50:08 <conal> shapr: well, if/when you are, let me know.  btw, going to freiburg?
08:50:13 <shapr> Nah, can't afford it.
08:50:25 <conal> i understand.  oh well.
08:51:48 <shapr> Anyway, hs-plugins would be perfect for writing new code and then attaching it to objects.
08:52:46 <conal> shapr: exactly what i was thinking.  nice to be on the same wavelength :)
08:54:40 <kfish> i was asking about running bytecode for this reason a few months back
08:54:54 <kfish> eg. in croquet, the object code is distributed, and computation is replicated on each client
08:55:38 <shapr> You've been hacking on the same idea?
08:55:42 <kfish> yeah
08:55:49 <shapr> Did you start with something like Frag?
08:55:58 <shapr> Do you have some sort of 3D environment that works on 64-bit systems?
08:56:08 <kfish> no, i'm more interested in the replication side of things
08:56:51 <shapr> Did you see musasabi's HsJoin stuff in one of The Monad.Reader issues?
08:57:10 <kfish> nope, sounds good
08:57:13 * kfish digs
08:58:50 <kfish> http://www.haskell.org/tmrwiki/JoinHs
08:58:51 <lambdabot> Title: JoinHs - TmrWiki
08:59:32 <kfish> cool, did that get developed any further?
09:00:58 <kfish> these previous tmr articles are great :-)
09:01:56 <olsner> what are the bitwise operators called in haskell?
09:02:19 <mauke> @index (.&.)
09:02:20 <lambdabot> Data.Bits, Foreign
09:02:53 <mauke> @docs Data.Bits
09:02:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
09:12:25 <olsner> yes! thanks ;-)
09:16:47 <balodja> @where yaht
09:16:47 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
09:32:02 <dons> ?users
09:32:03 <lambdabot> Maximum users seen in #haskell: 402, currently: 388 (96.5%), active: 7 (1.8%)
09:33:09 * quicksilver continues his vicious and unwarranted anti-Binary campaign in the cafe.
09:35:03 <vincenz> quicksilver: why are you anti-binary?
09:35:23 <quicksilver> vincenz: I'm not, actually. It's an awesome library.
09:35:36 <Shurique> assuming I have an IO action foo that prints to the screen indefinitely, how would I go about writing a program that runs foo in a separate thread while waiting for input in the main thread, and terminates when input is received?
09:35:46 <quicksilver> vincenz: I blush admit that I have a slight vice in terms of gentle trolling to get a reaction.
09:35:49 <Shurique> I'm looking at Control.Concurrent, but I'm not really sure where I should start
09:36:00 <mauke> tid <- forkIO foo
09:36:04 <mauke> getLine
09:36:08 <mauke> killThread tid
09:36:18 <quicksilver> vincenz: I am trying to prod people into understanding the difference between transient serialisation and a long-term defined file format.
09:37:56 <vincenz> quicksilver: versioning et al?
09:38:01 <vincenz> quicksilver: with migration
09:38:01 <vincenz> ?
09:38:03 <quicksilver> vincenz: right
09:38:10 * vincenz is looking to do something like that in the lua thing he spun
09:38:18 <quicksilver> vincenz: and the fact that Data.Binary doesn't magically solve those problems (nor is it intended to)
09:38:30 <vincenz> no lowlevel serialization can deal with that
09:38:35 <quicksilver> right
09:38:39 <vincenz> migrations have semantical meaning that can only be addressed by the developer
09:38:46 <quicksilver> although, a lowlevel serialization could give you tools to help
09:38:47 <vincenz> that being said, you should make it easy to migrate
09:38:49 <quicksilver> like a version stamp
09:38:55 <vincenz> right, we're saying the same thing :)
09:39:06 <quicksilver> for example, suppose the Data.Binary guys decided to alter the way they serialise [a]
09:39:20 <vincenz> or let's say your app now has an extra field in a record
09:39:26 <quicksilver> different problem
09:39:27 <quicksilver> :P)
09:39:36 <quicksilver> also a problem, but orthogonal to the one I was talking abot
09:39:38 <vincenz> yes, but that also needs to be addressed by the lib
09:39:41 * quicksilver nods
09:39:44 <vincenz> since Data.Binary will not be able to load it anymore
09:39:49 <vincenz> you need to migrate prior to casting
09:39:55 <quicksilver> yes
09:40:03 <vincenz> and I don't presume there's functionality for that
09:40:07 <quicksilver> I have a simple binary format for one of my projects
09:40:12 <quicksilver> I didn't use Data.Binary at all
09:40:14 <quicksilver> just hPutChar
09:40:21 * vincenz also rolled his own for a logging format he made in oaml
09:40:24 <quicksilver> (which should really be called hPutByte cos that's what it does)
09:40:27 <vincenz> it has proper versioning :)
09:40:31 <vincenz> o'caml
09:40:33 <quicksilver> yes, so does mine
09:40:40 <vincenz> it's actually really cool
09:40:44 <quicksilver> I would actually have used Data.Binary.Put and Get
09:40:45 <vincenz> it also encodes byte-ordering
09:40:47 <quicksilver> but I didn't know about them
09:40:55 <vincenz> cause c++ is what dupms and ocaml is what loads
09:41:09 <vincenz> so the header has a byte-ordering field :)
09:41:19 <vincenz> and the reader checks this to determine how to read bytes
09:41:31 <quicksilver> part of my gentle trolling crusade is to wake people up to the two 'levels' of Data.Binary
09:41:39 <Shurique> mauke: hmm, I only seem to get the output from the first iteration of running the infinite action
09:42:00 <Shurique> after that, nothing happens until I hit return to terminate the program
09:42:15 <_Zaph0d_> <newbie question> Could someone explain the 'repeat' prelude function please?
09:42:21 <mauke> @src repeat
09:42:22 <lambdabot> repeat x = xs where xs = x : xs
09:42:26 <quicksilver> > repeat 1
09:42:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:42:39 <_Zaph0d_> specifically how is 'xs' getting an initial value?
09:42:39 <quicksilver> _Zaph0d_: you mean, explain what it does? or how it works?
09:42:48 <mauke> _Zaph0d_: from x :
09:42:53 <quicksilver> _Zaph0d_: it doesn't get an initial value
09:43:03 <quicksilver> _Zaph0d_: 'xs' is a recursive call to repeat
09:43:10 <_Zaph0d_> so the first iteration of xs = x:xs
09:43:13 <scandal> is Data.ByteString the only way to read raw bytes from a Handle?
09:43:16 <_Zaph0d_> what is xs?
09:43:25 <dons> scandal: you can use getChar
09:43:26 <quicksilver> :t hGetChar
09:43:28 <vincenz> _Zaph0d_: it's only evaluated when asked for, at which point you know xs = x:xs
09:43:28 <lambdabot> Not in scope: `hGetChar'
09:43:29 <int-e> _Zaph0d_: the result list
09:43:29 <dons> or hGetBuf
09:43:34 <mauke> _Zaph0d_: there is no iteration
09:43:38 <int-e> _Zaph0d_: and simultaneously the tail of the result list
09:43:39 <dons> or foreign import fgets :)
09:43:48 <_Zaph0d_> in x:xs. I assume it must be [], but how does it get that value
09:43:53 <mauke> _Zaph0d_: it isn't
09:44:00 <dons> scandal: bytestrings are probably the easiest way
09:44:22 <quicksilver> _Zaph0d_: that's a stupid way to define it
09:44:27 <quicksilver> _Zaph0d_: here is a better one:
09:44:32 <quicksilver> _Zaph0d_: repeat x = x : repeat x
09:44:43 <Saul__> _Zaph0d_: It helps to see repeat as: repeat x = x : (repeat x)
09:44:45 <_Zaph0d_> ah, thanks
09:44:46 <scandal> What I'm doing is reading from /dev/urandom, but it just seems `wrong' to go ByteString -> Word8 -> Word -> Int
09:44:51 <quicksilver> _Zaph0d_: do you find that easier to read?
09:44:52 <Saul__> :D
09:44:57 <_Zaph0d_> yes. thanks again
09:44:58 <mauke> List xs = { x, &xs };  /* C code */
09:45:01 <mnislaih> has a translation of Instant Insanity (TMR8) to type families been attempted yet ?
09:45:06 <quicksilver> _Zaph0d_: they are the same, it's just that 'xs' is a temporary name for 'repeat x'
09:45:11 <quicksilver> helps it share some stuff
09:45:12 <fasta> dons: how do you verify that when you read a file from memory and then use that to build some data structure, all the work is done before e.g. a call to getCPUTime for benchmarking?
09:45:15 <quicksilver> but that's not very important
09:45:17 <lament> why is repeat defined the way it is?
09:45:25 <quicksilver> lament: sharing
09:45:47 <int-e> _Zaph0d_: xs is initially an unevaluated thunk, that, when evaluated, evaluates to a list with x as its head and xs as its tail. Now once xs is evaluated, the unevaluated thunk is *replaced* by the result. At this point it actually forms a cyclic list in memory.
09:45:48 <fasta> dons: that is: I don't want to count the time it takes to build the data structure, but want to count everything after it.
09:46:11 <fasta> dons: I believe I introduced sufficient strictness, but I don't _know_.
09:46:23 <dons> let me find you my benchmark script
09:46:45 <int-e> _Zaph0d_: the whole procedure is a little mind-bending. It's really the core of lazy evaluation though.
09:46:52 <dons> generally, i allocate a top level CAF with unsafePerformIO, that reads the data at startup and forces it
09:46:56 <_Zaph0d_> int-e: so in effect the empty list is never appended?
09:46:57 <dons> then i just reuse that strict buffer
09:47:08 <int-e> _Zaph0d_: no, there is no empty list at all.
09:47:20 <int-e> _Zaph0d_: just a transition from unevaluated to evaluated.
09:47:23 <dons> fasta: have a look at the unsafePerformIO's in http://darcs.haskell.org/bytestring/tests/BenchUtils.hs
09:47:23 <lament> _Zaph0d_: there's not an empty list anywhere in sight.
09:47:33 <dons> and the class Forceable which strictifies  them
09:47:34 <fasta> dons: "forces it", do you mean convert to rnf?
09:47:38 <hpaste>  mauke pasted "interrupting a thread" at http://hpaste.org/2688
09:47:43 <dons> as used in the script: http://darcs.haskell.org/bytestring/tests/Bench.hs
09:47:48 <lament> _Zaph0d_: empty lists occur at the end of lists. But this list is infinite, so it doesn't have an end.
09:47:48 <dons> fasta: deep seq
09:47:55 <fasta> dons: right, that's the same.
09:47:56 <mauke> Shurique: http://hpaste.org/2688 works here
09:48:01 <_Zaph0d_> just my understanding that lists always ended in [], I guess except when they are infinite
09:48:10 <fasta> dons: but... how do you know it's deepseq'ed.
09:48:16 <_Zaph0d_> *mind clicks* thanks
09:48:18 <fasta> dons: especially for stuff in the ST monad.
09:48:34 <dons> equational reasoning? :)
09:49:10 <fasta> dons: and your unsafeperformio only works for one input file.
09:49:19 <hpaste>  mnislaih pasted "Instant insanity with type families" at http://hpaste.org/2689
09:49:23 <fasta> dons: e.g. when you want to run on thousands of files, it breaks down.
09:50:21 <dons> i don't see any reason why, given a deep seq class, you can't control precisely the evaluation and reuse of buffers
09:50:22 <Shurique> mauke: I tested a similar action, and that worked... Perhaps there's something weird about the actual action I'm using
09:50:35 <dons> i've not had any problems doing this across a range of projects, so i'm sure you can work it out
09:51:49 <fasta> dons: force v = P.length v `seq` return T
09:51:59 <fasta> dons: that only forces the spine of the structure btw
09:52:19 <fasta> dons: unless length does something special.
09:52:35 <dons> what's the type :)
09:53:17 <fasta> dons: ByteString?
09:53:31 <dons> well, even if it is Char, there's little work to do
09:53:38 <fasta> dons: strict fields, probably?
09:56:38 <Shurique> mauke: it seems the problem is that I'm calling the shell command "sleep" in the IO action to produce delays
09:56:55 <Shurique> it works if I use threadDelay, but that doesn't seem nearly as accurate
09:57:58 <fasta> dons: to answer your remark: deepseq does not work for ST structures.
09:58:21 <mauke> wtf
09:58:48 <fasta> dons: but never mind, I probably already have solved it, I am just overly cautious.
09:58:50 <dons> wouldn't you just force the result of runST ?
09:59:26 <int-e> or the individual elements when writing to arrays, or the contents for refs?
09:59:30 <fasta> dons: example: numbers <- readFile; runST (return numbers)
09:59:39 <fasta> dons: add a return
09:59:57 <fasta> dons: now, AFAIK, the execution of numbers ands runST is interleaved.
10:00:00 <fasta> dons: i.e. lazy
10:00:08 <dons> let x = runST (return numbers) in force x
10:00:30 <fasta> force x = x `seq` x?
10:00:36 <fasta> @src force
10:00:37 <lambdabot> Source not found. Where did you learn to type?
10:00:39 <int-e> x `seq` x = x
10:00:39 <dons> depends on the type
10:00:39 <Naktibalda> force sex
10:00:44 <dons> look at the Forceable class
10:01:00 <dons> force (x :: [a] = last x `seq` x
10:01:51 <Igloo> I hope you have a [] case too
10:01:56 <fasta> Ok, I see your definition of forcing now.
10:02:05 <fasta> It's rather hackish, imho to use length.
10:02:34 <fasta> Duplicating NFData is also pointless.
10:38:23 <blakkino3> i have changes in darcs changes but i see nothing in the working dir.. what should i do?
10:38:24 <blakkino3> :)
10:38:43 <mrd> they are recorded
10:38:54 <blakkino3> yes
10:39:00 <mrd> what do you want to do then?
10:39:09 <blakkino3> i want to see them
10:39:30 <mrd> like as in 'darcs diff'?
10:39:37 <blakkino3> no.. like a file in the file system
10:40:04 <mrd> you have a _darcs/ but nothing else?
10:40:18 <blakkino3> ah yes i have understood the problem
10:40:18 <blakkino3> yes
10:40:24 <blakkino3> eclipse messed up the pristine dir
10:40:36 <mrd> ah well then, there's your problem
10:40:36 <blakkino3> and i have done a record.. and last patch has remove all files
10:41:08 <Saizan> unpull?
10:41:23 <araujo> eclipse--
10:41:27 <mrd> or unrecord
10:41:32 <blakkino3> y
10:41:51 <mrd> + revert I guess
10:45:00 <scandal> is there any sort of introspection on numeric types?  if I have a function   f :: (Integral a) => Int -> a   can I compute the number of bits that `a' requires in the function?
10:45:51 <sjanssen> scandal: see Data.Bits
10:45:59 <int-e> well you can play with toInteger
10:49:28 <hpaste>  scandal pasted "random numbers from /dev/urandom" at http://hpaste.org/2690
10:50:01 <scandal> what I'd like is for the genRand' function to automatically compute the argument that I have to manually pass in genRand
10:50:25 <scandal> ie, it should read the proper amount of bytes based on the return type
10:51:24 <Cale> bitSize :: a -> Int
10:51:24 <Cale> Return the number of bits in the type of the argument. The actual value of the argument is ignored. The function bitSize is undefined for types that do not have a fixed bitsize, like Integer.
10:53:49 <dbueno> Is there a standard, or at least easy, way to test the consistency of two Show and Read instances?  Should I just use QuickCheck to verify read $ show $ read x == x?
10:53:52 <Cale> So with Integer, you might have a little trouble, since obviously you can't generate a uniformly distributed random Integer.
10:54:21 <scandal> Cale: yeah, you will still have to specify the size for some types
10:54:28 <Cale> dbueno: read (show x) == x
10:54:45 <Cale> dbueno: That's about all you can do, aside from proving it by hand.
10:54:46 <scandal> I seem to have a chicken-and-egg problem with genRand' though, since I need the size of the type of the *return* value
10:55:46 <dbueno> Cale: together with an instance of the appropriate QuickCheck class that generates a bunch of random data structures of the appropriate type?
10:55:49 <Cale> scandal: that's okay. Just pass in bitSize n
10:56:11 <Cale> scandal: It doesn't actually use the value of n.
10:57:00 <vincenz> bitSize (undefined :: Type) : )
10:57:05 <Cale> dbueno: yeah. If you want to get really fancy, you can also do it the other way around, and test show (read x) = x, by generating lots of strings which the read instance should be able to parse.
10:57:34 <Cale> vincenz: He might need scoped type variables if he wanted to do it that way here.
10:58:45 <doserj> Cale: show (read x) = x is a bit too strong
10:59:24 <Cale> doserj: sometimes, yeah.
10:59:36 <Cale> (especially if there are spaces involved)
10:59:55 <doserj> and read (show x) = x already generates a lot of strings, which the read instance should be able to parse :)
11:00:24 <Cale> Yeah, but it only generates those which come from show.
11:00:42 <dbueno> Cale: Yeah, I didn't want to do that because of the spaces issue.
11:00:59 <doserj> well, if your require show (read x) = x, then that is all you need
11:01:22 <dbueno> That's true.
11:01:39 <Cale> doserj: hm?
11:02:19 <vincenz> Cale: ahright
11:02:26 <doserj> Cale: if show (read x) = x, then read only has to parse those strings, that are generated by show
11:02:28 <vincenz> bitSize (undefined `asTypeOf` n)
11:02:52 <vincenz> at least you're guaranteed the value's not being used :D
11:03:10 <doserj> (otherwise show (...) /= x)
11:03:12 <Cale> doserj: don't you mean the other way around?
11:03:20 <Cale> Like dbueno was hinting at before, you could test the "closure operator" type properties: show (read (show x)) = show x
11:03:43 <doserj> that makes more sense, yes
11:03:49 <Cale> (that might require some additional type signatures to make it work)
11:04:36 <Cale> However, that doesn't test that the full range of inputs you might want read to be able to read are properly read.
11:05:02 <Cale> It only tests that the outputs of show are properly read.
11:05:42 <Cale> (which as you pointed out, are not all the possible valid inputs to read)
11:06:30 <doserj> but you cannot specify generically, that whitespace shouldn't matter for read :(
11:06:52 <doserj> (well you could, perhaps)
11:07:04 <doserj> read x = read (trim x)
11:07:09 <hpaste>  scandal annotated "random numbers from /dev/urandom" with "attempt to use bitSize" at http://hpaste.org/2690#a1
11:07:37 <doserj> with a suitable trim
11:07:38 <Igloo> doserj: Internal shitespace and parens etc can also be used
11:07:49 <Igloo> Err, whitespace
11:07:57 <scandal> I annotated getRand' showing what I would *like* to do.  It is invalid, though, because the return value is not in scope where I would like it to be.
11:08:07 <vincenz> shouldn't that be "annotated scandal" ?
11:08:09 <doserj> II didn't say that trim would be easy to write :)
11:08:30 <vincenz> Igloo: nice slip of tongue
11:09:08 <allbery_b> paging Dr. Freud...
11:09:22 <scandal> vincenz: sorry, I do not follow
11:09:24 <doserj> and if you can write a correct trim, than you can probably as easily write a correct read...
11:26:51 * Heffalump appears briefly
11:30:45 <ari> @users
11:30:45 <lambdabot> Maximum users seen in #haskell: 402, currently: 400 (99.5%), active: 14 (3.5%)
11:32:14 <bos> golly
11:32:39 <_bellatrix_> hi all
11:32:47 <ari> pragma__: score!
11:32:52 <_bellatrix_> which is a great book for learning haskell?
11:32:57 <Tac-Work> > ["The Haskell programming language: free, functional, secure!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The language of ICFP winners 3 years running"]
11:32:59 <lambdabot>  ["The Haskell programming language: free, functional, secure!","Home: http:/...
11:33:25 <Tac-Work> it's awesome when the channel topic is a valid haskell expression
11:33:32 <ari> @where yaht
11:33:32 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
11:33:55 <_bellatrix_> ...and a real-paper one? ;-)
11:34:58 <ari> Having never read any real-paper Haskell books, I don't really know
11:35:25 <ari> I guess the ones at http://haskell.org/haskellwiki/Books_and_tutorials are recommended, though
11:35:26 <lambdabot> Title: Books and tutorials - HaskellWiki
11:35:31 <ari> @users
11:35:32 <lambdabot> Maximum users seen in #haskell: 405, currently: 405 (100.0%), active: 16 (4.0%)
11:38:46 <allbery_b> woo?
11:39:06 <ari> Not a significant one, but woo :)
11:40:02 <hpaste>  scandal annotated "random numbers from /dev/urandom" with "func's for each return type (ugly)" at http://hpaste.org/2690#a2
11:41:03 <hpaste>  tuxplorer pasted "Error: Not in scope data constructor Db " at http://hpaste.org/2691
11:42:43 <Lemmih> tuxplorer: Db is a type, not a data constructor.
11:43:24 <tuxplorer> ok. so, I need to define a data constructor as well for creating elements of that type?
11:44:17 <Tac-Work> Why is it that the Report says "deriving" only works for Eq, Ord, Enum, Bounded, Show, and Read, but yet some code will say deriving Monad, Functor, etc?
11:44:24 <Tac-Work> Is that a GHC-specific extension?
11:44:27 <mauke> that's an extension
11:44:30 <Tac-Work> or is it a common extension?
11:44:32 <mauke> and it only works for newtypes
11:44:45 <Tac-Work> so it's GHC-only?
11:44:55 <mauke> (because a newtype is just a wrapper around an existing type)
11:44:56 <Lemmih> tuxplorer: I'm not sure why you want to do so.
11:45:06 <tuxplorer> Lemmih: How do I use the connect to database step as a monad instead of threading it across all the functions?
11:45:19 <Tac-Work> is there a name for that extension?
11:45:27 <allbery_b> 'newtype deriving'
11:45:55 <mauke> http://www.haskell.org/ghc/dist/current/docs/users_guide/type-extensions.html#newtype-deriving
11:45:58 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/25mnwa
11:46:07 <Tac-Work> thanks!
11:46:32 <allbery_b> dunno if hugs/nhc98/yhc/etc. support it
11:47:01 <Lemmih> tuxplorer: 'ReaderT Connection IO', 'do conn <- ask; liftIO $ quickQuery conn "your sql"'
11:47:40 <mauke> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
11:47:45 <tuxplorer> Lemmih: Can you please help me understand the LiftIO part? I don't understand the usage of liftIO
11:48:20 <ddvlad> hi, can you recommend simple haskell application which I can read along with the documentation?
11:48:26 <Lemmih> tuxplorer: 'quickQuery' is an IO action. 'liftIO' takes that IO action and turns in into an 'ReaderT Connection IO' action.
11:48:38 <Lemmih> *turns it
11:49:20 * dmhouse rarghs by way of hello
11:50:41 <tuxplorer> Lemmih: ok. Thanks :)
11:53:07 <Mitar> i am reading Parsec documentation and I do not understand why does buildExpressionParser example "compute" the value of the expression
11:53:41 <Mitar> where does it compute? I see that in table they return functions
11:58:33 <_bellatrix_> ari: you said yaht is a good guide for beginners?
12:00:11 <ari> _bellatrix_: I have no idea, I never read it, but I hear it's often recommended
12:00:22 <_bellatrix_> ok thanks
12:01:31 <xerox> _bellatrix_: come in #haskell.it too! (:
12:01:54 <_bellatrix_> xerox: hi, nice to meet you again ;-)
12:02:14 <xerox> hi there :)
12:03:21 <hpaste>  tuxplorer pasted "Lemmih: I get this error now.. " at http://hpaste.org/2692
12:03:44 <Cale> Mitar: Well, look at where the combining functions are passed to binary, postfix and prefix.
12:04:10 <Cale> (*), (+), (div), (-), negate, and (+1) are passed in as parameters.
12:04:30 <Mitar> i see this: Infix (do{ string s; return f}) assoc
12:04:39 <Mitar> so it returns simply a function
12:04:42 <Mitar> am I correct?
12:04:45 <Cale> right
12:04:59 <Cale> and buildExpressionParser uses that function to combine the left and right subtrees.
12:05:14 <Mitar> hmm, is that anywhere in documentation?
12:05:43 <Mitar> Infix (do{ string s; return f}) assoc
12:05:45 <Mitar> ups
12:05:49 <Mitar> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#buildExpressionParser
12:05:52 <lambdabot> http://tinyurl.com/2p5p89
12:05:52 <Cale> Well, sort of, scroll up a bit to the documentation for Operator
12:06:29 <Cale> An infix operator specifies a function of type (a -> a -> a)
12:07:06 <Mitar> a little bit hard thing to see for a beginner :-)
12:07:07 <Cale> There's really only one sane thing that buildExpressionParser could be doing with that function.
12:07:36 <Mitar> thanks ...
12:07:41 <Cale> (which is, applying it to the values parsed on the left and right of the input)
12:08:35 <Cale> If you were to replace the mathematical operators there with the constructors of an appropriate expression type, you'd end up with the parse tree.
12:09:46 <Mitar> yes, i understand this now ... it is only hard to get it if you just read the documentation
12:10:35 <Mitar> or, it would be the only sane thing to predict, but i do not like to predict such basic behaviour when i am learning something ... because it can be often wrong
12:10:54 <Cale> Here, the type system sort of justifies it :)
12:11:36 <Cale> There's no way for the result to do the requested parsing and end up with a value of type a if it doesn't apply those functions it's getting.
12:11:38 <matthew-_> any .za-ers here? - 'tis a good match.
12:12:31 <Mitar> yes, i agree, but maybe the parsec monad would be doing this in this special case and would be collapsing this parse tree
12:13:06 <Mitar> i have another question
12:13:11 <Mitar> later on they define: whiteSpace= P.whiteSpace lexer
12:13:25 <Mitar> but P.whiteSpace does not take any parameter?
12:13:30 <Mitar> what is then this lexer?
12:13:33 <Cale> no, it does
12:13:55 <Cale> whiteSpace is a field of a TokenParser record
12:14:07 <Cale> So it's also a function which extracts that field.
12:14:26 <Mitar> it is this: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#whiteSpace
12:14:29 <lambdabot> http://tinyurl.com/2p5p89
12:14:49 <mauke> The following functions are all members of the TokenParser record
12:14:53 <Cale> right
12:15:03 <Mitar> ahh
12:15:05 <Mitar> yes ..
12:15:07 <Mitar> sorry, thanks
12:15:09 <Cale> That could probably be made clearer ;)
12:16:18 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#TokenParser
12:16:20 <lambdabot> http://tinyurl.com/2p5p89
12:16:38 <Cale> It would have perhaps been better to stick the documentation into the middle of that :)
12:16:46 <sorear> .
12:17:00 <Cale> ..
12:17:05 <Mitar> yes, the problem is if you read the documentation, just click on the link and see what you see (and do not scroll up)
12:17:12 <Cale> right :)
12:17:42 <Cale> Seeing as it's trying to document them as top-level functions, it could have given the proper type signatures for them, as top-level functions.
12:18:06 <Cale> They'd all take a parameter of type TokenParser st
12:18:15 <Mitar> ok, let's read on :-)
12:18:25 <Cale> Maybe that'd be worth emailing Daan about.
12:18:30 <mauke> :t (read `on`)
12:18:32 <lambdabot> Not in scope: `on'
12:18:51 <Mitar> maybe, i am reading it for the first time and otherwise it is good
12:19:09 <Mitar> this are the only "weak" points I got to
12:19:12 <Cale> Yeah, it is actually a pretty good piece of documentation.
12:19:52 <Cale> I usually recommend it even for people who aren't going to use Parsec, but some other parser combinator library, because they're all pretty similar.
12:20:27 <Mitar> i thought that this is "the one"?
12:20:34 <Mitar> should i check any other?
12:25:48 <Cale> Mitar: ReadP is also pretty good
12:25:55 <Cale> Mitar: and it comes with GHC as well
12:25:57 <Mitar> differences?
12:26:28 <Cale> Well, it's a little less polished overall, but it's better in some ways -- you don't have to use try, for example.
12:27:25 <Mitar> hmm
12:28:02 <dolio> It's somehow better than ReadS, though, no?
12:28:13 * dolio can never remember the difference.
12:36:32 <sioraiocht> why isn't there a haskell shell?
12:37:05 <reffje> because you haven't written one
12:37:10 <sioraiocht> touch
12:37:19 <fasta> sioraiocht: there is one
12:37:28 <Cale> There are a few, actually
12:37:29 <sioraiocht> fasta: what is it called?
12:37:32 <sioraiocht> orly?
12:37:38 <Cale> In various states of disrepair.
12:37:47 <sioraiocht> ah
12:38:21 <sioraiocht> HSH has the worst syntax ever
12:38:28 <Cale> The HSH library could be considered a shell, I suppose.
12:38:33 <sioraiocht> run $ ["ls","-l"] is not my idea of a shell
12:38:44 <Cale> It's actually got pretty good syntax, but not for a user shell.
12:38:52 <sioraiocht> well
12:38:54 <sioraiocht> that's what I meant, lol
12:39:11 <sioraiocht> for system() sort of function that's fine
12:39:41 <jvoorhis> hi
12:39:44 <sioraiocht> I like the notion of using >>= as |
12:40:01 <Cale> There's hashell, which looks like a traditional shell.
12:40:33 <Cale> and has a few quoting mechanisms for interspersing Haskell code with shell stuff.
12:41:18 <Cale> araujo: That was written by you, right?
12:41:51 <shapr> sioraiocht: I like that idea.
12:42:22 <Cale> http://www.cs.chalmers.se/~dave/Courses/Topics/SavedProjects/2006-Haskal/
12:42:25 <lambdabot> Title: Haskall, http://tinyurl.com/3yhala
12:42:30 <Cale> There's another attempt
12:43:06 <Cale> There's also http://www.cse.unsw.edu.au/~dons/h4sh.html, which you could just use along with bash, or any shell to get various haskellish things going.
12:43:06 <lambdabot> Title: h4sh
12:43:18 <byorgey> hi jvoorhis.
12:43:59 <jvoorhis> hi byorgey
12:44:19 <jvoorhis> does anyone here have any experience with computer music in haskell?
12:44:35 <shapr> I'd guess Cale and yaxu
12:44:51 <Cale> yaxu much more than me
12:45:47 <Cale> http://doc.gold.ac.uk/~ma503am/alex/haskellmusic
12:45:50 <lambdabot> Title: Haskell music | Alex McLean
12:46:07 <Cale> er, http://doc.gold.ac.uk/~ma503am/alex/
12:46:09 <lambdabot> Title: Alex McLean | hacking music
12:46:33 <jvoorhis> oh, i might have seen that
12:47:23 <byorgey> jvoorhis: there's also the haskell-art mailing list, some people with Haskell computer music experience on there too
12:47:28 <shapr> jvoorhis: yaxu uses the supercollider binding from Slave Pianos
12:47:52 <jvoorhis> nice, i haven't used supercollider yet
12:50:07 <jvoorhis> thanks for the tip on haskell-art, i hadn't heard of it
12:50:34 <dons> bos, can i get my new email address into the serpentine mailing system/
12:52:19 <reffje> i don't understand what's so cool about this sound thing
12:52:48 <jvoorhis> well, i had been interested in computer music before i started playing with haskell
12:53:01 <reffje> it makes no sense :(
12:54:24 <jvoorhis> what doesn't make sense about it?
12:54:48 <chr1s> hey all
12:55:00 <dons> hey chr1s
12:55:02 <araujo> yes Caelum
12:55:05 <araujo> yes Cale
12:55:07 <chr1s> I'm looking for the Control.Monad.Writer.Strict module
12:55:07 <araujo> :-)
12:55:17 <chr1s> it's supposed to be in http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer-Strict.html#v%3A%3E%3E
12:55:19 <lambdabot> http://tinyurl.com/ywrwnb
12:55:26 <dons> chr1s: right, its on hackage.haskell.org
12:55:29 <dons> ?hackage mtl
12:55:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
12:55:37 <chr1s> hm, I just installed mtl
12:55:55 <chr1s> dons: or do I need the svn version?
12:56:08 <dons> hmm, possibly its in the darcs version, yeah.
12:56:15 <dons> darcs.haskell.org/packages/mtl most likely
12:57:31 <chr1s> ah, see if that is going to work
12:58:42 <araujo> @where hashell
12:58:43 <lambdabot> haskell.org/hashell
12:58:52 <araujo> sioraiocht, ^^
12:59:17 <puusorsa> hash-hell
13:00:29 <araujo> sounds like fun ;-)
13:00:29 <chr1s> so I've got a cabal file that depends on mtl
13:01:15 <chr1s> but GHC says this:
13:01:15 <chr1s>     Could not find module `Control.Monad.Writer.Strict':
13:01:16 <chr1s>       it is a member of package mtl-1.0.1, which is hidden
13:01:38 <chr1s> is there a way to make sure my darcs version of mtl overrides my previously installed mtl?
13:01:45 <dons> just build and install it
13:01:47 <chr1s> i.e. make it not hidden
13:01:55 <fasta> chr1s: -package mtl ?
13:01:58 <dons> ghc-pkg list mtl -- might give some info
13:01:59 <sjanssen> chr1s: using Cabal?
13:02:34 <chr1s> well, I'd rather remove the old package, I'll see if I can figure that out
13:02:47 <fasta> Is there a function that turns an Integer expressing picoseconds to an English rendering of the number of seconds, minutes, hours, etc in a String?
13:03:11 <dons> yeah, if not in System.Time, then in the data package
13:04:13 <chr1s> hm, after a "sudo ghc-pkg hide mtl-1.0"
13:04:26 <chr1s> and "sudo ghc-pkg expose mtl-1.0.1"
13:04:40 <chr1s> it's still complaining mtl-1.0.1 is hidden
13:04:55 <dons> maybe just explicitly set mtl-1.0.1 as a dependency?
13:04:59 <dons> or remove the other mtl?
13:05:11 <sjanssen> chr1s: add mtl to your build-depends
13:05:28 <chr1s> sjanssen: it's already there
13:06:15 <dons> sjanssen: classic tuomo, [bug report received] .. "That piece of crapware ..."
13:06:30 <sjanssen> dons: yeah, I saw that one
13:06:41 <kjdf> is there a standard function "ifM c t f = do flag <- c; if flag then t else f" ?
13:06:50 <shapr> sjanssen: Where's that?
13:06:57 <sjanssen> shapr: ion3 mailing list
13:07:08 <shapr> Should I ask what he said?
13:07:57 <axm> main = (return 5) >>= showM >>= putStrLn where showM x = return $ show x
13:08:09 <sjanssen> shapr: ion doesn't handle kpdf's fullscreen mode, tuomov calls it crapware
13:08:15 <axm> i am trying to get rid of the showm, should not be too hard, but seems i am stuck
13:08:20 <axm> some sort of lift?
13:08:30 <shapr> sjanssen: Interesting.
13:08:31 <allbery_b> kpdf, last I checked, was pretty lame
13:08:50 <allbery_b> i.e. did lotsof things wrong or poorly
13:09:05 <sjanssen> allbery_b: when did you check?  The interface has gotten pretty nice recently
13:09:24 <oerjan> kjdf: no, but one often defines the function bool t e f = if f then t else f
13:09:39 <oerjan> then you can do c >>= bool t e
13:09:46 <kjdf> axm: main = (return 5) >>= putStrLn . show
13:09:46 <allbery_b> font rendering and pdf formatting badly lagged xpdf as of about 6 months ago
13:09:55 <axm> thx
13:09:57 <Cale> let (n,k) = divMod 2374839201312987473821903892139821 (10^12) in normalizeTimeDiff (diffClockTimes (TOD n k) (TOD 0 0))
13:10:05 <allbery_b> I admit I've not looked more recently but I have no idea if/when our KDE will be updated :/
13:10:07 <oerjan> i _think_ bool might make it into Data.Bool eventually
13:10:16 <oerjan> if it hasn't already
13:10:19 <Matyo> Pls click on him afterwards you may quit:
13:10:20 <Matyo> http://www.nicefaces.eu/?link=select&id=1896&voks=10
13:10:26 <lambdabot> Title: Beauty Contest On The Internet, nice faces, win by photo's, free part in big pri ...
13:10:51 <Cale> uhh...
13:11:18 <allbery_b> irc spam...
13:11:27 <Cale> Matyo: this channel is about the Haskell programming language only.
13:11:37 --- mode: ChanServ set +o Cale
13:11:38 --- mode: ChanServ set +o shapr
13:11:38 --- mode: ChanServ set +o dons
13:11:44 <shapr> wow
13:11:54 --- kick: Matyo was kicked by shapr (Kicked by shapr)
13:12:23 --- mode: ChanServ set -o dons
13:12:28 --- mode: shapr set -o shapr
13:12:36 <oerjan> @src print -- axm
13:12:37 --- mode: Cale set -o Cale
13:12:37 <lambdabot> Source not found. stty: unknown mode: doofus
13:12:42 <oerjan> @src print
13:12:44 <lambdabot> print x = putStrLn (show x)
13:13:49 <Cale> fasta: did you catch that?
13:13:53 <fasta> Cale: no
13:13:54 <Cale> let (n,k) = divMod 2374839201312987473821903892139821 (10^12) in normalizeTimeDiff (diffClockTimes (TOD n k) (TOD 0 0))
13:13:57 <bos> dons: yeah, of course
13:14:04 <kjdf> oerjan: thanks for that "bool" suggestion
13:14:04 <axm> even nicer
13:14:13 <bos> do you have a "home" email address now?
13:14:56 <Cale> (normalizeTimeDiff has a bug where it doesn't normalise the picosecond part, unfortunately, so you have to do that bit manually)
13:14:59 <oerjan> kjdf: also sometimes if' f t e = if f then t else e ( lambdabot's @pl uses that ) but for your purpose bool fits better
13:18:18 <ptolomy> Hmm.. I created ST replacement for Data.HashTable because I wanted something that I can freeze/unfreeze and make use of for lookups in pure contexts, and instead of using whatever IO-based bucketing system that Data.HashTable uses, I just stuck Data.Maps in there, and it seems faster. I did it because it was easy and seemed like it'd be good for the theoretical worst case...  are there any...
13:18:19 <ptolomy> ...other ST Hashtable implementations that I can look at for ideas?
13:18:47 <fasta> ptolomy: I don't think so.
13:18:59 <sjanssen> ptolomy: it's well known that Data.HashTable is slow
13:19:13 <ptolomy> sjanssen: ... and nobody has gotten around to fixing it?
13:19:19 <DRMacIver> Hm. And I was just considering using it for something. :)
13:19:31 <fasta> ptolomy: but... if you use Maps, it isn't a hash table anymore, right?
13:19:38 <ptolomy> Sure it is. :)
13:19:49 <sjanssen> ptolomy: I don't think anybody cares -- purely functional Maps are nicer to use
13:20:12 <sjanssen> just use Data.IntMap, it provides O(1) lookup and insert
13:20:27 <sorear> people who say they want hash tables, are wrong.
13:20:33 <ptolomy> I was initially using a list of [(Key,Value)] for the bucket chains.. then I thought, "hmm.. I should keep those sorted.." then I thought "hmm.. I could just use Map"
13:20:55 <ptolomy> sorear: Why?
13:21:02 * ptolomy supposes that Tries are pretty close.
13:21:22 <fasta> monochrom would love this discussion
13:21:23 <lament> i usually want a data structure where i can keep stuff indexed by a key, and i don't care about how it's implemented :)
13:21:49 <ptolomy> Data.Map is significantly slower than my hashtable for some basic uses.
13:24:20 <Cale> Hash tables are overrated anyway
13:24:29 <Cale> hehe
13:24:40 <gpi5> In a do construct, I've got something like w <- getWidget. What is the type of w and what is it scope?
13:24:54 <Cale> gpi5: What is the type of getWidget?
13:25:00 <gpi5> No, of w
13:25:04 <puusorsa> @type getWidget
13:25:06 <lambdabot> Not in scope: `getWidget'
13:25:12 <dolio> With type functions in 6.8, we're on the verge of generalized tries anyway, no? :)
13:25:17 <Cale> gpi5: I'm asking you what the type of getWidget is, so that I can answer you.
13:25:38 <Cale> The scope of w is over the rest of the do-block, unless it is shadowed by another binding to w.
13:26:07 <Cale> The type of w is the result type of getWidget (that is, if getWidget :: m a, then w :: a)
13:26:24 <gpi5> Oh, sorry :) Something like bla -> bla -> IO widget
13:26:58 <Cale> In that case, supposing that you've supplied the other parameters to getWidget to make it typecheck, w :: widget
13:27:14 <fasta> ptolomy: I think it's great that you made the theoretical faster hash table (on average) faster in practice than Data.Map.
13:27:34 <fasta> ptolomy: the idea that hash tables are useless is rather prevalent in #haskell
13:27:42 <Cale> gpi5: w <- getWidget means to run the action getWidget and bind the result to the name w.
13:27:49 <gpi5> Cale: thanks. w is a variable I guess (like a static in C)?
13:28:12 <oerjan> gpi5: an immutable variable
13:28:14 <Cale> It's like a lambda parameter.
13:28:21 <fasta> Most fast, practical code is written in a monad, anyway.
13:28:39 <Cale> Really, that's translated into   getWidget >>= \w -> do { <rest of do block> }
13:28:56 <gpi5> Botton line is: why can I not reuse w after 'where' (I need to pass it as a parameter and it is weird)
13:29:09 <fasta> ptolomy: will you release it?
13:29:21 <Cale> gpi5: you can have let-statements in a do-block though.
13:29:25 <Cale> For example...
13:29:28 <sorear> ptolomy: Does it work multi-threaded?
13:29:40 <vincenz> do { x <- bla; let y = x * x; return y}
13:29:41 <Cale> do w <- getWidget; let { n = name w }; ...
13:29:43 <ptolomy> fasta: Not likely. I was just doing it for the fun of implementing Hashable instances for various datatypes and benchmarking. :)
13:29:54 <gpi5> Cale: so each time you use w in an expression you call the lambda function?
13:30:10 <ptolomy> sorear: Well, when it is all mutable and stuff, it runs in ST, so sorta?
13:30:29 <gpi5> Cale: Thanks, I'll use the let construct, looks cool.
13:30:37 <sorear> ptolomy: oh, if it's in ST, that's fine
13:30:47 <Cale> gpi5: No, it's a parameter to a function which is implicitly defined -- it's like the rest of the do-block is the body of a function which is called with the result of getWidget as its parameter
13:31:10 <sorear> ptolomy: Data.HashTable is slow in no small part because it must handle locking
13:31:12 <ptolomy> I don't think my toy hashtable implementation is really worth much of anything; I was just surprised to see it match or better the library HT in some basic tests. I presume library authors to be demigods of code.
13:31:25 <fasta> ptolomy: how long is this implementation?
13:31:28 <oerjan> @undo do w <- getWidget; let { n = name w }; ...
13:31:28 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 68}) "Parse error"
13:31:34 <ptolomy> sorear: really? Last I checked, it just uses IORefs and comments "we should use MVars.."
13:31:38 <Cale> gpi5: Do-notation is syntax sugar for a bunch of (>>=)'s and lambdas
13:31:42 <fasta> ptolomy: I would guess that it's at least 500 lines for something good.
13:31:43 <sorear> oh.
13:31:44 <ptolomy> I just did a once-over, though, could be wrong.
13:31:46 <oerjan> @undo do w <- getWidget; let { n = name w }; whatever w
13:31:46 <lambdabot> (getWidget >>= \ w -> let { n = name w} in whatever w)
13:32:05 <Cale> like that :)
13:32:25 <Cale> The translation rules are (roughly)
13:32:25 <bos> sorear: HashTable doesn't use the locking form of IORef modification
13:32:29 <vincenz> or better
13:32:30 <Cale> do { x } = x
13:32:34 <vincenz> liftM name getWidget
13:32:53 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
13:33:01 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
13:33:05 <bos> it uses its own cheezy version of modifyIORef that avoids locks
13:33:06 <ptolomy> fasta: It's surprisingly short, because everything is just a wrapper on Data.Map... so all I have to do is hash the key parameter, find the right array location, then make Data.Map do the other stuff.
13:33:19 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
13:33:22 <vincenz> Cale: not quite
13:33:37 <Cale> vincenz: I'm aware.
13:33:38 <vincenz> do { x ; <stmts>} = x >> const do no?
13:33:44 <Cale> vincenz: no
13:33:45 <vincenz> @type (>>)
13:33:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:33:51 <vincenz> I thought it took a function and...never mind
13:34:03 <fasta> ptolomy: well, there are different kinds of way to implement hashing, it all depends on what you did.
13:34:15 <Cale> There is something I'm leaving out, but it's something I'd rather not get into ;)
13:34:21 <EvilTerran> (>> do {...}) = (>>= const do {...})
13:34:24 <fasta> There are extremely complex ways that probably takes thousands of lines.
13:34:40 <fasta> They are the best theoretically, though.
13:34:50 <fasta> s/though/of course
13:34:53 <EvilTerran> Cale, would that be fail?
13:34:54 <ptolomy> For strings, I used a simple hashing algo I stole from Sedgewick, I think. Today I was playing around with trying to implement hsieh hash in haskell..
13:34:56 <Cale> EvilTerran: yeah
13:35:02 * EvilTerran doesn't like fail
13:35:28 <Cale> gpi5: Does that make some sense? (Even if you don't know what >>= is yet)
13:35:31 * fasta doesn't like the fail discussion
13:35:35 <fasta> It's getting old.
13:35:48 <Cale> fasta: nothing's being done about it
13:35:48 <EvilTerran> okok. i won't start it, then
13:35:52 <EvilTerran> record systems!
13:35:56 <Cale> heh
13:36:07 <EvilTerran> monomorphism restriction!
13:36:17 <Cale> gpi5: So the next thing to the understanding is to know what >>= is.
13:36:19 <EvilTerran> oopsie =/
13:36:26 <EvilTerran> re fasta
13:36:27 <fasta> :)
13:36:40 <mauke> numeric classes in the Prelude!
13:36:42 <ptolomy> Where can I see what the auto-derivable typeclasses for GHC are?
13:36:51 <EvilTerran> class Show a => Num a!
13:36:56 <fasta> ptolomy: in the manual
13:36:56 <Cale> gpi5: x >>= f, where x is an action, like getWidget, and f is a function from possible results of x, to further actions to take, combines these into a new action.
13:37:05 <gpi5> Cale: indeed :) I guess that's the work haskell gurus came with: monads...
13:37:16 <ptolomy> fasta: Makes sense.
13:37:21 <Cale> gpi5: The new action will first run x, then pass its result to the function and run the result of that.
13:37:24 <dolio> fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
13:37:37 <fasta> dolio: great :)
13:37:47 <mauke> ptolomy: I think it's H98 classes + Typeable + Data + newtype deriving
13:37:56 <EvilTerran> that one should be in the topic ;p
13:38:03 <Cale> gpi5: and the result of the new action is the result of that continuation.
13:38:26 <Cale> Remember that   x >>= f = do { v <- x ; f v }
13:38:42 <oerjan> @remember dolio fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
13:38:42 <lambdabot> Done.
13:38:43 <Cale> If it helps to follow the above ;)
13:38:51 <gpi5> Cale: one question -- all actions must be 'linked' to each other to have something consistent, right? So a pure function cannot execute such an action?
13:39:05 <dolio> Oh great. Now I'll get pinged every time someone tries to quote Cale. :)
13:39:07 <Cale> gpi5: Only actions can cause other actions to run.
13:39:28 <Cale> gpi5: But actions are also allowed to use pure code.
13:39:45 <gpi5> All actions are linked to each other, the root being 'main'?
13:39:48 <Cale> yeah
13:39:51 <fasta> I think the @remember command is way overused.
13:40:02 <Cale> Essentially, the only action which ever runs in a compiled program is main
13:40:03 <fasta> I was remembered twice _today_!!
13:40:05 <mauke> well, you can have an "unlinked" action, but it will just be a value (not executed)
13:40:10 <Cale> but it's built up from lots of smaller things
13:40:11 <oerjan> @remember fasta I think the @remember command is way overused.
13:40:12 <lambdabot> Done.
13:40:18 <Cale> other actions, and pure code.
13:40:20 <byorgey> oerjan: aww, beat me to it =)
13:40:22 <dolio> Perhaps you're just too quotable for your own good.
13:40:23 <fasta> oerjan: so, predictable.
13:40:47 <byorgey> @quote fasta
13:40:48 <lambdabot> fasta says: masak: Their meta types don't match
13:40:50 <vincenz> they should rename @remember to @oerjan
13:40:55 * oerjan likes being the clown
13:41:00 <byorgey> well, that's a silly quote
13:41:03 * ptolomy wants to see if he can hack Brian O'Sullivan's Data.SuffixTree module to make Data.Dawg
13:41:06 <byorgey> @quote fasta
13:41:07 <lambdabot> fasta says: masak: Their meta types don't match
13:41:43 <fasta> lambdabot purposely forgets my quotes!
13:41:54 <fasta> @quote fasta
13:41:55 <lambdabot> fasta says: dozer: but you need HEAD
13:42:08 <fasta> @quote fasta
13:42:08 <lambdabot> fasta says: Ok, this is great, now it all appears to work. :(
13:42:12 <Cale> gpi5: So that all makes sense?
13:42:13 <fasta> @quote fasta
13:42:13 <lambdabot> fasta says: dozer: but you need HEAD
13:42:15 <fasta> @quote fasta
13:42:15 <lambdabot> fasta says: dozer: but you need HEAD
13:42:16 <fasta> @quote fasta
13:42:16 <lambdabot> fasta says: masak: Their meta types don't match
13:42:16 <gpi5> Cale: It would have been simpler to say: main starts, then pass the 'execution rights' to another actions, and so on until it comes back to main. People would understand that easily.
13:42:18 <fasta> @quote fasta
13:42:19 <lambdabot> fasta says: I think the @remember command is way overused.
13:42:22 <fasta> @quote fasta
13:42:22 <lambdabot> fasta says: masak: Their meta types don't match
13:42:28 <fasta> Never mind, there should be more.
13:42:31 <Cale> gpi5: Possibly. :)
13:42:36 <gpi5> Cale: thanks anyway, much appreciated
13:42:41 <Cale> gpi5: However, we really do think of actions as being values
13:42:43 <fasta> Or does it forget them every time it's rebooted?
13:42:46 <fasta> @uptime
13:42:47 <lambdabot> uptime: 4d 4h 19m 4s, longest uptime: 1m 10d 23h 44m 29s
13:43:26 <Cale> gpi5: It's very possible to stick a bunch of IO actions into a data structure, and then have another function come along and combine them in some way.
13:43:48 <dolio> Wow, she made it over one month at one point?
13:43:49 <oerjan> fasta: i think someone has to do @flush, possibly
13:43:58 <Cale> This is actually how we get most of our control structures :)
13:44:02 <oerjan> and i cannot recall anyone doing that much lately
13:44:29 <fasta> @flush
13:44:30 <lambdabot> Not enough privileges
13:44:34 <Cale> The simplest example is probably sequence:
13:44:34 <fasta> I guessed so
13:44:39 <Cale> sequence [] = return []
13:44:54 <Cale> sequence (x:xs) = do { v <- x ; vs <- sequence xs; return (v:vs) }
13:45:16 <Cale> It takes a list of actions, and produces the action which runs each in turn, giving a list of the results.
13:45:23 <oerjan> @help flush
13:45:23 <lambdabot> flush. flush state to disk
13:45:35 <Cale> Many kinds of loops can be constructed with this.
13:45:36 <fasta> Cale: this getCPUTime appears to be massively broken.
13:45:48 <Cale> forM xs f = sequence (map f xs)
13:45:54 <Cale> This is a for-each loop
13:45:56 <fasta> Cale: it seems to get the time when I loaded the GHCi session.
13:46:09 <gpi5> Cale: do you have a non-trivial example to understand the usefullness of associating actions?
13:46:17 <fasta> Cale: i.e. when I evaluate it at the start of the program it returns about 4 minutes.
13:46:22 <Cale> gpi5: associating?
13:46:48 <gpi5> sorry, 'combinning'
13:47:01 <mauke> ;
13:47:10 <Cale> gpi5: well, I just gave one, but it might need some more explanation
13:47:38 <Cale> gpi5: Basically, what would be control structures requiring special language support in other languages, become simple library functions in Haskell.
13:47:48 <gpi5> Let me think about me then (for me it was trivial, but now I doubt it :)
13:48:31 <Cale> It's both trivial and somewhat surprising at the same time :)
13:48:59 <fasta> Cale: but Haskell already has language support for monads ;)
13:49:32 <Cale> fasta: Right, we only need something which is very general, not all these little features.
13:49:36 <mauke> control flow is just a special case of monads
13:50:27 <fasta> Haskell has no syntactical abstraction.
13:51:24 <oerjan> :t filterM . doesFileExist
13:51:27 <lambdabot> Not in scope: `doesFileExist'
13:51:28 <fasta> That's why there's DrIFT and TH. Things that would go in a library in Scheme.
13:51:39 <oerjan> :t filterM . System.Directory.doesFileExist
13:51:40 <fasta> Well, TH is a libary ;)
13:51:42 <lambdabot>     Couldn't match expected type `a -> m Bool'
13:51:42 <lambdabot>            against inferred type `IO Bool'
13:52:02 <fasta> Well, for some value of library.
13:52:16 <oerjan> :t filterM System.Directory.doesFileExist
13:52:19 <lambdabot> [FilePath] -> IO [FilePath]
13:52:54 <Cale> fasta: TH is the rough equivalent of scheme macros.
13:53:05 <Cale> (quite rough)
13:53:30 <oerjan> gpi5: there's an example, using filterM to make an action that finds the filepaths in a list that actually exist
13:53:32 <Cale> However, Haskell needs macros a whole lot less than Scheme.
13:53:47 <Heffalump> and they work a lot less well due to the type system
13:54:01 <Cale> Heffalump: hm?
13:54:05 <EvilTerran> :t fileExists
13:54:07 <lambdabot> Not in scope: `fileExists'
13:54:13 <Cale> :t doesFileExist
13:54:15 <lambdabot> Not in scope: `doesFileExist'
13:54:21 <Cale> :t System.Directory.doesFileExist
13:54:23 <lambdabot> FilePath -> IO Bool
13:54:33 * EvilTerran finishes reading the scrollback
13:54:50 <Heffalump> Cale: TH compared to Scheme macros
13:54:55 <fasta> EvilTerran: don't try to read to the end.
13:55:12 <Cale> Heffalump: How does the type system get in the way?
13:55:13 <EvilTerran> Cale, i was going to say; laziness and typeclasses are also roughly equivalent to quite a lot of scheme macro-y-ness
13:55:22 <Cale> EvilTerran: right
13:55:27 <EvilTerran> in that they're used to solve the same problemn
13:55:29 <EvilTerran> *s
13:55:49 <gpi5> oerjan: what would you write with filterM to make that work?
13:56:08 <Heffalump> hmm, actually I guess it doesn't exactly, the problem is more to do with compilation units
13:56:18 <gpi5> Oh this: :t filterM System.Directory.doesFileExist
13:56:22 <Cale> gpi5: right
13:56:23 <oerjan> right
13:56:55 <Cale> Heffalump: and the fact that Haskell's syntax is fairly complicated :)
13:57:35 <Cale> Macros work well in scheme because the syntax is fairly trivial.
13:57:51 <Heffalump> yeah.
13:58:54 <ptolomy> Anyone know if the pointer tagging stuff will be in 6.8?
13:59:08 <Cale> Basically all the domain-specific language applications of macros, we don't need macros for, because we have laziness.
13:59:37 <sorear> ptolomy: Igloo would
13:59:41 <therp> cale: you need macros to make DSL comfortable to read
13:59:42 <Excedrin> is there a good reason to have complicated syntax?
13:59:49 <therp> cale: the abuse of infix operators is horrible in haskell
13:59:53 <Cale> therp: not really, just higher-order functions.
13:59:58 <Igloo> ptolomy: Yup, it will
14:00:07 <ptolomy> Igloo: Neat. :)
14:00:15 <Cale> Excedrin: yes, it's more readable.
14:00:17 <therp> cale: macros are in no way meant to replace laziness nor higher-order functions
14:00:30 <Cale> therp: They commonly replace laziness.
14:00:59 <EvilTerran> therp, do{} and lazy HOFs do an admirable job of making an acceptable DSL, IMO
14:01:01 <Cale> The whole reason you usually need macros is to avoid evaluating expressions too early.
14:01:26 <therp> cale: most macros that I have written in common lisp have not been about either of those concepts (at least for one concept it's pretty obvious, as CL certainly know higher order functions)
14:01:27 <Cale> (for a simple example, consider the macro implementation of if)
14:01:41 <fasta> Cale: can you take something less trivial?
14:02:03 <fasta> I agree with therp.
14:02:09 <therp> evilterran: I respectfully disagree. monads syntax and infix operators might not be the best way to express your DSL
14:02:16 <Cale> Well, any control-structure-like thing.
14:02:20 <sorear> therp: yeah, but CL makes HOFs fairly painful - (LAMBDA (x) y) vs \x -> y
14:02:41 <EvilTerran> may not be the *best* way, sure.
14:02:43 <dolio> Higher-order abstract syntax is a lot less painful in Haskell than it is in CL or Scheme.
14:02:47 <Cale> and basically any DSL that doesn't rely on things like loading separate files at compile time
14:02:47 <EvilTerran> but you can't please all the people all the time.
14:03:15 <therp> sorear: there is a benefit of uniform syntax, I hope to produce a screencast to demonstrate that very point soon. I was about to test ffmpeg today..
14:03:19 <EvilTerran> and the inter-DSL consistency offered by shoehorning 'em all into monadic form has its advantages
14:03:26 <Cale> yep
14:03:27 <therp> sorear: and yes, lambda is too long as keyword for higher order functions.
14:03:35 <Excedrin> when I was first learning Haskell I thought that the syntax was almost as ugly/linenoise as Perl
14:03:44 <joelr1> good evening
14:03:53 <Cale> The classification of combinator libraries is a rather nice project :)
14:04:08 <Excedrin> I'm sort of used to it now, but it still seems like there's too much sugar
14:04:11 <therp> sorear: using the unicode lambda sign would be much nicer.. but (.\ (x) y) might just do as well (but this is a bit crappy to parse as \ is usually the escape sign)
14:04:18 <Cale> Excedrin: like what?
14:04:27 <EvilTerran> you get used to using \ for lambda pretty quickly
14:04:44 <therp> sugar isn't bad. sugar that bloats your grammar is
14:04:55 <EvilTerran> i do, anyway.
14:05:18 <Heffalump> Haskell doesn't let you overload enough stuff to be a really good DSL language.
14:05:27 <Heffalump> s/really good/perfect/
14:05:32 <Cale> Heffalump: how so?
14:05:40 <ptolomy> I think it is more a matter of scope that makes things hard.
14:05:44 <Heffalump> and I mean "DSEL" of course.
14:05:46 <Cale> There's something that you can't do with typeclasses?
14:05:52 <Heffalump> overload if..
14:06:01 <dolio> Overloaded booleans and such, I imagine.
14:06:03 <Heffalump> or string literals (until Lennart got at GHC)
14:06:04 <Cale> (or won't be able to do with typeclasses soon enough? :)
14:06:16 <Heffalump> do-notation is particularly tricky
14:06:22 <Cale> You can write your own overloaded if.
14:06:30 <Cale> You just can't call it if.
14:06:44 <dolio> You can't get the nice Haskell if syntax, either. :)
14:06:50 <Cale> right
14:06:52 <Heffalump> or make it be nicely ternary infix
14:06:59 <Heffalump> similarly case
14:07:07 <Igloo> I don't think there would be anything difficult about making if overloadable
14:07:08 <Cale> How would you overload case?
14:07:14 <EvilTerran> i should be possible to write something like (foo `then` bar `else` baz)...
14:07:26 <EvilTerran> (except not with those names)
14:07:30 <Heffalump> I'm not certain. You need some notion of higher-order patterns first, probably.
14:07:46 <Excedrin> Cale: things related to lists mostly, but do notation, layout (the else indent thing bugs me)
14:07:48 <EvilTerran> foo ?? bar ?: baz; magicks with fixities.
14:08:02 <Cale> Excedrin: the else indent thing?
14:08:10 <Heffalump> EvilTerran: hence "nicely"
14:08:29 <Cale> Excedrin: would you get rid of do-notation?
14:08:45 <Heffalump> oh yes, list syntax/list comprehensions
14:09:12 <Cale> I don't mind that list syntax isn't overloaded, personally, though I would like to have monad comprehensions sometimes.
14:09:19 <EvilTerran> data TernaryPart a = a :? a; (??) :: Bool -> TernaryPart a -> a; True ?? (x :? _) = x; False ?? (_ :? y) = y; infixr 0 ??, :?; -- :D
14:09:26 <dmhouse_> I think I'd prefer to have monad comps over do-notation
14:09:39 <Cale> hmm, I wouldn't always prefer them
14:09:41 <dmhouse_> It feels more functional, which is both a good and a bad thing.
14:09:46 <Excedrin> I'd like to get rid of all syntax and have sexp (or something) with some sort of nice syntax for types
14:09:52 <Cale> For IO, it would often be weird.
14:10:01 <dmhouse_> They emphasise different aspects of the monadic framework.
14:10:05 <Cale> dmhouse_: right.
14:10:37 <EvilTerran> Excedrin, it should be fairly straightforward to make an interpreter/compiler for a hindley-milner-typed s-expression language in haskell
14:10:46 <EvilTerran> well, there's always
14:10:48 <EvilTerran> @where liskell
14:10:49 <lambdabot> http://clemens.endorphin.org/liskell
14:11:06 <Excedrin> I wonder if therp knows anything about that
14:11:14 <dmhouse_> I kinda like Lisp's syntax. It's got a simplistic beauty to it.
14:11:14 <Cale> Excedrin: by 'the else indent thing', do you mean if-then-else inside a do-block?
14:11:21 <sorear> Excedrin: ahem, therp *is* clemens
14:11:27 <dmhouse_> It also makes it easy to write really cool tools for working with the syntax.
14:11:33 <Cale> Excedrin: If that's giving you trouble, you're probably not indenting if-then-else correctly.
14:11:38 <Excedrin> sorear: I know that :)
14:11:41 <Cale> (in general)
14:11:44 <dmhouse_> But then I like Haskell's syntax, too.
14:12:01 <Cale> the 'then' and 'else' are parts of the 'if', so they should be indented further than it.
14:12:07 <Excedrin> Cale: yea, I'm aware of how to indent it, it just bothers me sometimes
14:12:30 <Cale> I actually use Haskell's convention in other languages. It's particularly well-suited to bash.
14:12:42 <EvilTerran> i'm more bothered by some of the weirder consequences of some of the syntax rules
14:13:03 <Cale> My biggest syntax issue really isn't a syntax issue.
14:13:18 <Cale> I bet everyone here can guess what it is :)
14:13:33 <sjanssen> fixity of $
14:13:36 <Cale> yeah
14:13:49 <phobes> Is there a way to specify that certain partial evaluation should be done at compile time if you try to do macros with laziness?
14:13:53 <dolio> Oh, I was going to guess fail again, since that's actually related to syntax. :)
14:13:54 <EvilTerran> like things that look like one word that should be broken into two tokens if you take the report literally, owing to the "extend as far to the right as possible while still producing a valid parse" rules
14:13:55 <ptolomy> Cale: What is wrong with the fixity of $?
14:14:05 <Cale> ptolomy: Its associativity is backwards.
14:14:15 <EvilTerran> phobes, {-# INLINE #-}, iirc
14:14:31 <Cale> ptolomy: It ought to be left-associative like function application, but instead it associates to the right.
14:14:41 <EvilTerran> http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#inline-pragma -- phobes
14:14:43 <lambdabot> Title: 7.10. Pragmas, http://tinyurl.com/ysbfs7
14:14:47 * ptolomy tries to imagin ghe practical impact of that..
14:14:48 <Cale> ptolomy: As a result, we can't remove parens from as many expressions as we'd otherwise be able to.
14:14:53 <ptolomy> Ah. :)
14:15:03 * therp wonders why google doesn't hand out liskell.org
14:15:04 <dmhouse_> Cale: can you give an example? I can't remember what that disallows.
14:15:14 <therp> (hand out first)
14:15:17 <Cale> Basically all current uses of repeated ($)'s can be rewritten to use (.)
14:15:25 <SamB_XP_> ptolomy: $! points out the problem wonderfully
14:15:28 <Cale> f $ g $ h $ x becomes f . g . h $ x
14:15:40 <EvilTerran> phobes, altho be sure to profile first; beware of premature optimisation ;]
14:15:46 <Cale> However, we can't remove the parens from f (g x) (h y)
14:16:05 <Cale> If ($) was left associative, we could write that as:  f $ g x $ h y
14:16:19 * ptolomy imagines such a world.
14:16:22 <ptolomy> Magical.
14:16:38 <ari> @quote agenda
14:16:38 <lambdabot> Cale says: Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
14:16:58 <ari> Not a very hidden one methinks :p
14:16:59 <Cale> haha
14:17:22 <Japsu> Premature evil is the root of all optimization.
14:17:26 <fasta> therp: Implemenetation, bug on liskell.org
14:17:42 <EvilTerran> doesn't the precedence of (.) potentially cause trouble when switching from ($)s to (.)s, cale?
14:17:43 <oerjan> now if we could also get ($ x $ y) to work as a section...
14:17:56 <Cale> Yeah, the place where it *really* gets annoying is with $!, which is almost unusable if you have more than one parameter to strictify.
14:18:00 <EvilTerran> infixr 0 $; infixr 9 .
14:18:05 <therp> fasta: liskell.org is not as polished as it should be, *sigh*, thanks though
14:18:16 <Cale> EvilTerran: only where you have subexpressions involving other infix operators.
14:18:25 <Cale> (that produce functions)
14:18:30 <Cale> which is fairly rare
14:18:42 <EvilTerran> &&&, ***, etc?
14:18:53 <Cale> yeah, I suppose those would be the main cases
14:19:18 <dolio> > id &&& (+1) . (*2) $ 5
14:19:20 <lambdabot>  (5,11)
14:19:26 <Cale> Also, it's arguable that parens for those clarify the situation without really harming much, since typically those bits are short, rather than long chains.
14:19:36 <EvilTerran> > (,) `ap` (1:) . (2:) $ [3,4]
14:19:37 <lambdabot>      precedence parsing error
14:19:37 <lambdabot>         cannot mix `ap' [infixl 9] and `(.)' [i...
14:19:39 <EvilTerran> > (,) `ap` (1:) $ (2:) $ [3,4]
14:19:41 <lambdabot>  ([2,3,4],[1,2,3,4])
14:20:16 <EvilTerran> i'm playing devil's advocate here, mind. i agree that $ going the other way would be nice.
14:20:24 <Cale> Using ap infix seems a bit contrived of course :)
14:20:46 <Cale> hmm, perhaps not, actually
14:20:51 <EvilTerran> just sayin', the "basically" in "<Cale> Basically all current uses of repeated ($)'s can be rewritten to use (.)" is understating slightly
14:20:57 <Cale> right
14:21:01 * EvilTerran almost invariably uses ap infix
14:21:13 * dmhouse_ almost invariably doesn't use ap
14:21:25 <EvilTerran> well, yes.
14:21:25 <Cale> heh
14:21:34 <Cale> I use ap to mean S, for the most part.
14:21:37 <EvilTerran> the Applicative equivalent, tho
14:21:52 <dolio> > (,) <*> (1:) . (2:) $ [3,4]
14:21:53 <lambdabot>  ([3,4],[1,2,3,4])
14:21:58 <Cale> > map (ap (,) (^2)) [1..10]
14:21:59 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
14:22:01 <EvilTerran> <*> and <$> are both infixl 4
14:22:24 <ptolomy> @type ap
14:22:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:22:30 * ptolomy weeps.
14:22:30 <dmhouse_> > [ (x, x^2) | x <- [1..10]]
14:22:32 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
14:22:45 * EvilTerran wants another one, <@>, say, with the same fixity properties
14:22:48 <Cale> ptolomy: In this case, m = (->) e, so ap :: (e -> a -> b) -> (e -> a) -> e -> b
14:22:51 <EvilTerran> f <@> x = f <*> pure x
14:23:09 <Cale> ptolomy: that is to say that  ap f g x = f x (g x)
14:23:18 * ptolomy unweeps.
14:23:24 <ptolomy> Cale: Thanks. :)
14:23:41 <EvilTerran> if we had another one, say f <?> x = f x, we could please Cale too
14:24:06 <EvilTerran> @src <*>
14:24:06 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:24:07 <dmhouse_> > [ (sqrt x, x) | x <- [1..100::Float], fromIntegral (floor (sqrt x)) == sqrt x ]
14:24:08 <lambdabot>  [(1.0,1.0),(2.0,4.0),(3.0,9.0),(4.0,16.0),(5.0,25.0),(6.0,36.0),(7.0,49.0),(...
14:24:11 <oerjan> <?> is used in Parsec.  and btw its associativity is wrong too
14:24:12 <Cale> EvilTerran: I'd still really like it if people used (.) more and ($) less though.
14:24:17 <EvilTerran> @type (<*>)
14:24:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:24:33 <Cale> ($) induces the wrong kind of thinking relative to (.)
14:24:52 <EvilTerran> Control.Function vs Data.Function ;)
14:25:06 <Cale> Haskell's a functional programming language, and function composition is really the right way to think about things.
14:25:38 <phobes> Over function application?
14:25:41 <Cale> yep
14:25:56 <Cale> Over repeated function application
14:26:02 <phobes> Is it easy to explain why?
14:26:10 * dolio may have to lay off his Functor => Applicative => Monad push.
14:26:15 <Cale> Because function application is fundamentally asymmetric
14:26:39 <Cale> When you compose two functions, you get a function
14:26:41 <dolio> I'm having trouble figuring out how to write an Applicative instance for the delimited continuation monad without falling back on ap. :)
14:26:58 <Cale> With function application, you're applying a function to a value, to get another value.
14:27:12 <mauke> dolio: why can't you use ap?
14:27:32 <CosmicRay> does anybody have experience using quickcheck to repeat the same test code over numerous instances of a typeclass?
14:27:32 <Cale> Function composition has the nice property that (f . g) . h = f . (g . h), which isn't really reflected by a similarly simple property for application
14:27:37 <dolio> mauke: I can currently. But if Applicative is made a superclass of Monad, you have to define Applicative before you define Monad.
14:27:39 <CosmicRay> this seems to be an absurdly difficult proposition
14:27:57 <oerjan> dolio: i don't think that's a problem?
14:28:00 <mauke> dolio: "before"? definitions can be mutually recursive
14:28:05 <Cale> This fact makes it easier to refactor code which is written in the form of composition -- that law gives you lots of 'subexpressions' to play with.
14:28:09 <gpi5> What's the name of a function [a] -> a -> Bool (I would call it isPartOf but I forgot real name)
14:28:19 <Cale> gpi5: elem
14:28:19 <mauke> @hoogle [a] -> a -> Bool
14:28:20 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
14:28:20 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
14:28:21 <oerjan> gpi5: elem
14:28:22 <SamB_XP_> dolio: dude, Functor isn't a superclass of Monad yet...
14:28:24 <dolio> mauke: Can they? Oh, well, then. Never mind.
14:28:30 <Cale> x `elem` xs
14:28:41 <phobes> Maybe you should do more with an operator that takes   a -> (() -> a)
14:28:42 <gpi5> Great, didn't know hoogle..
14:29:13 <Cale> phobes: does that make any sense? I can try to clarify it
14:29:24 <phobes> Cale: Ya it makes sense
14:29:36 <EvilTerran> CosmicRay, you have to make a polymorphic property, then create a test from it for each instance, i beliece
14:29:46 <Cale> With  f $ g $ h $ x,  g $ h is not a subexpression, nor does it typecheck on its own
14:29:49 <dolio> SamB_XP_: I know. but if you're going to fix the hierarchy, why not fix it once, instead of fixing it part way, and then fixing it again later?
14:29:50 <EvilTerran> *typos
14:30:01 <phobes> Cale:  ok, good point
14:30:15 <Cale> With  f . g . h $ x, you have g . h is effectively a subexpression which typechecks and means the right thing.
14:30:32 <EvilTerran> h $ x isn't any more tho!
14:30:35 <SamB_XP_> dolio: isn't Control.Applicative rather ... new?
14:30:45 <Cale> EvilTerran: It's not?
14:30:50 <EvilTerran> well, it is, kinda. but it's not a subexpression in terms of the AST
14:30:54 <EvilTerran> never mind, carry on.
14:30:56 <CosmicRay> EvilTerran: yes, it is not hard to make a polymorphic property, but manually coding up a test for every instance (there are many) smells way too much of java
14:31:07 <Cale> EvilTerran: we're using the associativity of (.) here anyway :)
14:31:10 <Igloo> Cale: In   add 1 2   you have   1 2   which isn't a subexpression either
14:31:18 <Cale> Igloo: right
14:31:34 <EvilTerran> CosmicRay, it's an unfortunate effect of not being able to summon a list of all instances of a type from within haskell, i guess
14:31:34 <gpi5> @hoogle Bool -> Bool -> Bool
14:31:35 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
14:31:35 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
14:32:01 <CosmicRay> EvilTerran: I don't mind writing code to do this *once*, where I could pass test properties to.  but I can't make it work, even with rank-n polymorphism
14:32:03 <SamB_XP_> EvilTerran: maybe you can make some kind of a group of tests that you can use at different types or something?
14:32:17 <Cale> To pull that out, you'd have to write something like ($ 2) . ($ 1)
14:32:26 <Japsu> :t ($1$2)
14:32:32 <lambdabot> forall b b1. (Num (Integer -> b1)) => (b1 -> b) -> b
14:32:37 <Cale> nope :)
14:32:42 <Cale> :t ($ 2) . ($ 1)
14:32:44 <lambdabot> forall a b a1. (Num a, Num a1) => (a1 -> a -> b) -> b
14:32:53 <Japsu> :t ($1) . ($2)
14:32:55 <lambdabot> forall a b a1. (Num a, Num a1) => (a1 -> a -> b) -> b
14:33:28 <Cale> > ($ "world") . ($ "hello") $ (++)
14:33:31 <dolio> SamB_XP_: How new is new? Besides, conal, for example, is using it heavily, I think.
14:33:33 <lambdabot>  "helloworld"
14:33:55 <EvilTerran> CosmicRay, what's your setup? do you have instance Foo a => Arbitrary a?
14:33:56 <dolio> SamB_XP_: And it's in the base libraries. And it's, categorically, in between Functor and Monad. So why not put it there?
14:34:18 <CosmicRay> EvilTerran: I have, yes.
14:34:19 <Cale> > ($ "world") >>> ($ "hello") $ (++)
14:34:20 <lambdabot>  "worldhello"
14:34:31 <Japsu> hmm
14:34:59 <oklopol> > 1 >>> 2
14:35:00 <lambdabot>   add an instance declaration for (Show (a b d))
14:35:05 <CosmicRay> EvilTerran: the pitfalls are many.  If I have a function testAll that takes Arbitrary x, ListLike a b => x -> (x -> a) -> (x -> [b]) -> Bool... to build a Testable...
14:35:07 <oklopol> > Show 1 >>> Show 2
14:35:07 <lambdabot>  Illegal character ''\168''
14:35:10 <oklopol> > Show 1 >>> Show 2
14:35:10 <lambdabot>   Not in scope: data constructor `Show'
14:35:32 <CosmicRay> the problem is that I must manually cast (x -> a) and (x -> [b]) for each of the instances.  And doing so causes a typing error.
14:35:37 <EvilTerran> ah, MPTCs?
14:35:41 <CosmicRay> make that -> [Bool]
14:35:48 * oerjan wonders what oklopol thinks >>> does
14:35:48 <CosmicRay> yes
14:35:53 <Japsu> ;)
14:35:56 <oerjan> :t (>>>)
14:35:58 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
14:35:59 <Cale> oklopol: (>>>) :: (Arrow (~>)) => (a ~> b) -> (b ~> c) -> (a ~> c)
14:36:07 <Japsu> oklopol: for functions, f >>> g == g . f
14:36:25 <Japsu> oklopol: but >>> is more general than that.
14:36:28 <Japsu> @where arrow
14:36:29 <lambdabot> I know nothing about arrow.
14:36:30 <Japsu> @where arrows
14:36:30 <lambdabot> http://www.haskell.org/arrows/
14:36:31 <CosmicRay> EvilTerran: so then I tried testAll :: (forall x a b. Arbitrary x, ListLike a b => (x -> a)) -> (forall x b. (x -> [b])) -> [Bool]
14:36:34 <CosmicRay> which works for some things
14:36:42 <dolio> SamB_XP_: Unless you're anticipating API changes or something. I guess some nicer looking operators than <*> would be nice. But that would probably be part of nailing down all the redundancies in the libraries.
14:36:44 <CosmicRay> but does not work for things like (:) where the result type depends on the input type
14:36:51 <CosmicRay> which unfortunately are many of the things I need to test.
14:37:36 <Japsu> @wiki comonad
14:37:36 <lambdabot> http://www.haskell.org/haskellwiki/comonad
14:37:48 <EvilTerran> hm. sorry, i don't think i'm familiar enough with QC to be able to help you. seems you should be able to do something, with typed undefined parameters if nothing else.
14:38:18 <oerjan> @wiki idontcheckwhatyouwrite
14:38:18 <lambdabot> http://www.haskell.org/haskellwiki/idontcheckwhatyouwrite
14:38:48 <mauke> wiki = ("http://www.haskell.org/haskellwiki/" ++)
14:38:49 <CosmicRay> I have tried that too, and unfortunately it has led me down a dead end as well.
14:38:51 <lambdabot> Title: Haskell - HaskellWiki
14:40:25 <Japsu> :E
14:40:46 <mauke> unknown command ':E'
14:40:46 <mauke> use :? for help.
14:41:04 <oerjan> @go site:haskell.org/haskellwiki comonad
14:41:07 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows
14:41:07 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki
14:53:54 <oerjan> @pl return f `ap` convert g
14:53:55 <lambdabot> f `fmap` convert g
15:00:02 <gpi5> @hoogle [a] -> (a -> Bool) -> [a]
15:00:03 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
15:00:03 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
15:00:03 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
15:02:36 <oerjan> you may also like span, break and partition, which combine both the included and the dropped parts in a tuple
15:03:00 <oerjan> @hoogle  [a] -> (a -> Bool) -> ([a],[a])
15:03:02 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
15:03:02 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:03:02 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
15:03:59 <idnar> @src break
15:03:59 <lambdabot> break p =  span (not . p)
15:04:02 <idnar> @src span
15:04:02 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:04:06 <idnar> heh
15:04:23 <idnar> what does span do?
15:04:37 <ddarius> idnar: The same thing as break pretty much.
15:04:44 <oerjan> :D
15:04:47 <mauke> > span even [2,4,4,3,2,5]
15:04:49 <lambdabot>  ([2,4,4],[3,2,5])
15:04:58 <mauke> > span odd [2,4,4,3,2,5]
15:05:00 <lambdabot>  ([],[2,4,4,3,2,5])
15:05:13 <ddarius> > break even [2,4,4,3,2,5]
15:05:15 <lambdabot>  ([],[2,4,4,3,2,5])
15:05:19 <idnar> > partition even [2,4,4,3,2,5]
15:05:19 <ddarius> > break odd [2,4,4,3,2,5]
15:05:21 <lambdabot>  ([2,4,4,2],[3,5])
15:05:21 <lambdabot>  ([2,4,4],[3,2,5])
15:05:58 <gpi5> @hoogle (a->[b])->[a]->[b]
15:05:59 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
15:05:59 <lambdabot> Control.Parallel.Strategies.parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
15:06:13 <idnar> partition is like filter, span is like takeWhile, break is like dropWhile?
15:06:58 <hpaste>  scandal annotated "random numbers from /dev/urandom" with "use dummy argument to get bit size of return type" at http://hpaste.org/2690#a3
15:08:42 <oerjan> idnar: actually, span is takeWhile + dropWhile
15:08:58 <idnar> yeah, that analogy doesn't quite work
15:09:02 <oerjan> while break reverses the predicate tested
15:09:23 <idnar> span splits before the predicate turns false, break splits before the predicate turns true (?)
15:09:32 <oerjan> right
15:23:32 <oerjan> @docs Data.Map
15:23:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
15:24:08 <ari> @hoogle Char -> Word8
15:24:12 <lambdabot> No matches, try a more general search
15:24:28 <oerjan> :t fromIntegral . fromEnum
15:24:30 <lambdabot> forall b a. (Num b, Enum a) => a -> b
15:25:32 * ari nods, and awaits IsString
15:27:20 <oerjan> > maxBound :: Char
15:27:22 <lambdabot>  '\1114111'
15:28:26 <beelsebob> > maxBound :: Float
15:28:27 <lambdabot>   add an instance declaration for (Bounded Float)
15:28:27 <lambdabot>     In the expression: maxB...
15:28:56 <ari> > maxBound :: Word8
15:28:57 <lambdabot>  255
15:30:48 <LoganCapaldo> I still find the names of the WordN types (i don't want to say unintuitive, because of course they can't be intuitive) but unintuitive
15:34:08 <gpi5> Is it possible to rewrite following function without lambda?      normbin = filter (\a -> elem a "01")
15:34:20 <idnar> @pl normbin = filter (\a -> elem a "01")
15:34:20 <lambdabot> normbin = filter (flip elem "01")
15:34:47 <KatieHuber> what does @pl stand for?
15:34:47 <gpi5> What is @pl ?
15:34:49 <oerjan> > filter (`elem` "01") ['0'..'9']
15:34:51 <lambdabot>  "01"
15:34:53 <LoganCapaldo> @help pl
15:34:53 <lambdabot> pointless <expr>. Play with pointfree code.
15:35:07 <dons> @wiki Pointfree
15:35:08 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
15:35:17 <dons> gpi5: is a good introduction to this style
15:35:25 <LoganCapaldo> It's an optimizier that removes "points" (arguments with names) from your code
15:35:29 <idnar> oerjan's version is probably more understandable
15:35:41 <dons> ?pl \x -> x
15:35:41 <lambdabot> id
15:35:44 <dons> ?pl \x -> x + 1
15:35:44 <lambdabot> (1 +)
15:35:48 <dons> ?pl \x -> x + x
15:35:49 <lambdabot> join (+)
15:36:07 <gpi5> Interesting, thanks. Can I use it in ghci?
15:36:21 <LoganCapaldo> @where GOA
15:36:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
15:36:25 <LoganCapaldo> ^
15:36:32 <dons> though that's not well maintained
15:36:48 <LoganCapaldo> hypothetically :)
15:36:50 <dons> you can use it locally though, yes.
15:36:57 <dons> i use lambdabot locally with vim bindings to @pl
15:37:07 * LoganCapaldo never managed to build lambdabot 
15:37:48 * sorear can build lambdabot, but hates doing it
15:38:02 * lambdabot never managed to build LoganCapaldo
15:38:22 <LoganCapaldo> My dependencies are a pain in the neck :)
15:38:23 <bos> why has lambdabot this reputation of horror?
15:38:47 <sorear> bos: it's fairly horrid code, with an even more horrid build system
15:38:48 <dons> its not too bad, but it does stretch cabal a little
15:39:04 <LoganCapaldo> I must admit I didn't really try all that hard
15:39:36 <LoganCapaldo> and this was a while ago, where the list of things I didn't know about haskell/ghc/cabal/etc was slightly longer than it is now
15:40:12 <oerjan> LoganCapaldo: are you sure the list hasn't grown faster than you learned it? :D
15:40:16 <idnar> I got lambdabot built eventually, but spent quite a while running around after all the dependencies
15:40:32 <LoganCapaldo> oerjan, dammit. You're probably right.
15:41:03 <LoganCapaldo> The problem with that list is I don't even know what's on it ;)
15:41:31 <jbalint> hi, can i check a pkg from cabal, or something? need to sort this: Setup.lhs: cannot satisfy dependency binary>=0.3
15:42:04 <sorear> @hackage binary
15:42:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
15:42:19 <jbalint> i mean, is there any way to see if its installed ?
15:42:23 <jbalint> or if theres a less version
15:42:35 <sorear> no, not with cabal, BUT
15:42:40 <gpi5> @pl \x -> x
15:42:41 <lambdabot> id
15:42:44 <sorear> you can sidestep cabal and ask GHC directly
15:42:50 <sorear> $ ghc-pkg list
15:42:54 <sorear> $ ghc-pkg describe binary
15:42:56 <jbalint> Ok, thanks.
15:43:00 <gpi5> @pl \x y z -> x y z
15:43:00 <lambdabot> id
15:43:09 <gpi5> @pl \x y z -> x y
15:43:09 <lambdabot> (const .)
15:43:15 <gpi5> @pl \x y z -> x
15:43:15 <lambdabot> const . const
15:43:26 <gpi5> @t const
15:43:27 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
15:43:35 <gpi5> @index const
15:43:35 <lambdabot> Prelude
15:43:40 <LoganCapaldo> @type const
15:43:44 <LoganCapaldo> :t const
15:43:50 <lambdabot> forall a b. a -> b -> a
15:43:50 <lambdabot> forall a b. a -> b -> a
15:43:53 * sorear thinks ghc-pkg should be made part of Cabal and work uniformly across compilers!
15:43:55 <LoganCapaldo> you need to use at least ty with @
15:43:59 <LoganCapaldo> :t is special
15:44:01 <lambdabot> Not in scope: `is'
15:44:01 <lambdabot>  
15:44:01 <lambdabot> <interactive>:1:3: Not in scope: `special'
15:44:21 <chessguy> @hoogle special
15:44:21 <lambdabot> Language.Haskell.Syntax.Special :: HsSpecialCon -> HsQName
15:44:22 <lambdabot> Language.Haskell.Syntax.HsSpecialCon :: data HsSpecialCon
15:44:22 <lambdabot> System.Console.Readline.getSpecialPrefixes :: IO String
15:44:37 <gpi5> @type id
15:44:39 <lambdabot> forall a. a -> a
15:44:52 <gpi5> @pl \x y -> x y
15:44:52 <lambdabot> id
15:44:59 <gpi5> I don't get this
15:45:20 <gpi5> \x->x is id.   Not \x y -> x y ??
15:45:34 <sjanssen> @pl \x y z -> x y z
15:45:34 <lambdabot> id
15:45:47 <pjd> gpi5: \x y -> x y is a more specific id
15:45:51 <LoganCapaldo> gpi5, x :: c -> d, a can be = c -> d
15:46:00 <pjd> where x == (x -> y)
15:46:04 <sorear> LoganCapaldo: You *always* need to use ty with lambdabot. :P
15:46:07 <oerjan>  @pl does some simplifications, sometimes replacing a function by a more generally typed version
15:46:10 <ddarius>  @pl has the tendency to generalize types.
15:46:25 <LoganCapaldo> sorear, joke? I don't get it
15:46:38 <sorear> LoganCapaldo: ty is also std abbrev for 'thankyou' :)
15:46:44 <LoganCapaldo> heh
15:46:46 <LoganCapaldo> @bot
15:46:46 <lambdabot> :)
15:46:57 <oerjan> @thanks
15:46:58 <lambdabot> you are welcome
15:47:08 <beelsebob> @bot
15:47:08 * ddarius totally didn't get it either, but he hates net slang.
15:47:08 <lambdabot> :)
15:47:30 <gpi5> @tired?
15:47:31 <lambdabot> Unknown command, try @list
15:48:06 <oerjan> @pl \x -> [x] -- example
15:48:07 <lambdabot> return
15:48:32 <LoganCapaldo> @pl (:[]) -- I wonder
15:48:32 <lambdabot> return
15:48:43 <LoganCapaldo> that answers that question
15:49:05 <oerjan> @pl Just -- now i wonder
15:49:05 <lambdabot> Just
15:49:19 <LoganCapaldo> Is this part of the reason pl doesn't always come up with the "optimal" solution?
15:49:42 <gpi5> @pl \x y -> y x
15:49:42 <lambdabot> flip id
15:50:04 <gpi5> @pl \x y -> y . x
15:50:05 <lambdabot> flip (.)
15:50:07 <oerjan> perhaps, if it changes it to a more general version which a simplification doesn't work for
15:50:27 <gpi5> @pl \x y -> y ++ x
15:50:27 <lambdabot> flip (++)
15:50:37 <gpi5> @pl \x y -> x ++ y
15:50:37 <lambdabot> (++)
15:51:07 <gpi5> @type flip
15:51:09 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:51:19 <oerjan> @src flip
15:51:20 <lambdabot> flip f x y = f y x
16:09:55 <KatieHuber> how do I find out what the -> monad does?
16:10:01 <KatieHuber> google is distinctly unhelpful
16:10:55 <astrolabe> the '->' monad?
16:11:11 <KatieHuber> guess I got my terminology wrong ^_^
16:11:21 <KatieHuber> I had this:
16:11:22 <KatieHuber> \patience -> map ((,) patience) (allMoves patience)
16:11:29 <KatieHuber> so I used @pl with lambdabot
16:11:35 <KatieHuber> and it said
16:11:36 <KatieHuber> liftM2 map (,) allMoves
16:11:39 <KatieHuber> which is cool
16:11:53 <KatieHuber> but it has an additional type constraint which isn't satisfied
16:11:56 <KatieHuber> Monad ((->) a)
16:12:17 <KatieHuber> and I have no idea what it wants of me :)
16:12:30 <astrolabe> hmmm
16:12:51 <astrolabe>   Maybe the monad is ((->) a) though.
16:13:15 <astrolabe> still pretty cryptic
16:13:22 <Botje> KatieHuber: the ((->) a) monad is in Control.Monad.Reader
16:13:27 <Botje> *monad instance
16:13:38 <Botje> so you need to import that module
16:13:44 <Botje> and possibly control.monad too
16:13:50 <idnar> Control.Monad.Instances?
16:14:00 <Botje> @src (>>=) ((->) e)
16:14:01 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:14:01 <KatieHuber> ooh, works, thanks :)
16:14:07 <Botje> @src ((->) e) (>>=)
16:14:08 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:14:15 <Botje> grar. I could never get that right
16:14:18 <Botje> @help instance
16:14:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:14:27 <Botje> @instance Monad ((->) e)
16:14:27 <lambdabot> Maybe you meant: instances instances-importing
16:14:31 <Botje> bugger.
16:14:34 <Botje> oh well
16:14:36 <Botje> i'm off to bed
16:15:25 <ari> @src Reader (>>=)
16:15:25 <lambdabot> Source not found. stty: unknown mode: doofus
16:15:52 <idnar> @instances Monad ((->) e)
16:15:53 <lambdabot> Couldn't find class `Monad ((->) e)'. Try @instances-importing
16:16:00 <idnar> @instances-importing Monad ((->) e)
16:16:00 <oerjan> @instances Monad
16:16:01 <lambdabot> Couldn't find class `e)'. Try @instances-importing
16:16:02 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:16:12 <idnar> oh, of course
16:16:30 * ari foreheadslaps
16:17:56 <oerjan> @src (->) (>>=)
16:17:57 <lambdabot> f >>= k = \ r -> k (f r) r
16:18:05 <oerjan> wow, it worked
16:18:49 <stepcut> did some recently write a collateBy function that is like groupBy + sortBy rolled into one nice function? Or am I imagining things
16:19:11 <oerjan> i vaguely recall that too
16:20:00 <LoganCapaldo> Was it named groupOn?
16:20:06 * LoganCapaldo he vaguely wonders
16:20:24 <oerjan> something like (head &&& length) . groupBy ...
16:21:00 <oerjan> was involved
16:21:00 <stepcut> my specific problem is, I have a bunch of Network.URI, and I want to group them by regName (aka, hostname)
16:21:02 <jbalint> does cabal packages install include the docs by default, or you have to generate them manually?
16:21:38 <stepcut> I have code, but it is not pretty enough ;)
16:22:05 <LoganCapaldo>     groupOn f = groupBy ((==) `on` f) . sortBy (compare `on` f) ?
16:22:20 <stepcut> LoganCapaldo: yes! that is perfect *and* pretty
16:22:24 <LoganCapaldo> http://www.google.com/codesearch?hl=en&lr=&q=lang%3Ahaskell+groupOn&btnG=Search
16:22:25 <lambdabot> Title: lang:haskell groupOn - Google Code Search, http://tinyurl.com/2dnz7v
16:22:28 <oerjan> darn beat me to it
16:22:30 * stepcut forgot about on
16:22:52 <oerjan> :)
16:23:09 <stepcut> is 'on' in a library yet ?
16:23:30 <LoganCapaldo> Maybe?
16:24:07 * stepcut notes that 'on' is a hard function to search for on google
16:24:13 <LoganCapaldo> Data.Function apparently
16:24:14 <oerjan> Data.Function but whether that's gone through i don't know
16:24:20 <LoganCapaldo> http://www.google.com/codesearch?hl=en&lr=&q=lang%3Ahaskell+%60on%60&btnG=Search
16:24:22 <lambdabot> Title: lang:haskell `on` - Google Code Search, http://tinyurl.com/29gvzz
16:24:29 <LoganCapaldo> I cheated and searched for `on`
16:25:14 <LoganCapaldo> man, google code search rules
16:25:28 <LoganCapaldo> Although I supose I could have hoogled for the type
16:25:54 <LoganCapaldo> @hoogle (a -> a -> b) -> (c -> a) -> c -> c -> b
16:25:58 <lambdabot> No matches, try a more general search
16:26:12 <gpi5> @index parseFloat
16:26:13 <lambdabot> bzzt
16:26:26 <LoganCapaldo> @hoogle parseFloat
16:26:27 <lambdabot> No matches found
16:26:44 <LoganCapaldo> > read "3.4" :: Float
16:26:44 <gpi5> @hoogle readFloat
16:26:45 <lambdabot> Numeric.readFloat :: RealFloat a => ReadS a
16:26:45 <lambdabot> Numeric.readFloat :: RealFrac a => ReadS a
16:26:48 <stepcut> LoganCapaldo: how do I limit my search by language ?
16:26:50 <lambdabot>  3.4
16:26:59 <LoganCapaldo> stepcut, lang:*whatvever*
16:27:33 <oerjan> it would be nice if ghc would optimize away the double evaluations when using on
16:28:18 <ddarius> oerjan: Double evaluation?
16:28:28 <LoganCapaldo> oerjan, how mean you? What get's evaluated more than once?
16:28:55 <oerjan> sortBy (comparing `on` f) will re-evaluate f each time an element is compared
16:29:12 <oerjan> *compare
16:29:33 <LoganCapaldo> sortBy foo where foo = comparing `on` f ?
16:30:05 <oerjan> right (with compare)
16:30:40 <LoganCapaldo> it really doesn't do that already?
16:30:47 <LoganCapaldo> @src sortBy
16:30:47 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:30:49 <oerjan> i have no idea :)
16:30:56 <LoganCapaldo> I mean cmp
16:31:13 <ddarius> oerjan: I'm still lost wondering what you think will be reevaluated.
16:31:30 <LoganCapaldo> yeah
16:31:34 <LoganCapaldo> I don't see it
16:31:39 <stepcut> to type signature for groupOn is neat, had to think about what it meant for a few seconds -> groupOn :: (Ord b) => (a -> b) -> [a] -> [[a]]
16:31:47 <oerjan> compare `on` f = \x y -> f x `compare` f y
16:32:23 <oerjan> sorting will typically compare some elements to others several times
16:32:53 <ddarius> oerjan: This has nothing to do with on.
16:32:55 <oerjan> but if you are not clever, that would mean evaluating f x each time
16:33:15 <oerjan> _despite_ that being the same each time
16:33:27 <ddarius> compare `on` memo f
16:36:24 <oerjan> hm, i guess this might be one of those premature optimizations
16:43:40 <mrd> > fix (\ f -> 1:scanl (+) 1 f)
16:43:42 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:50:47 <dbueno> I'm using quickCheck on my own AST and the compiler complains that there is "No instance for (Arbitrary Char)" inside a module where I have imported Test.QuickCheck, which provides such an instance.  What am I missing?
16:54:17 <dons> dbueno: you sure you've got the Quickcheck that actually has an Arbitrary Char instance?
16:54:26 <dons> it wasn't included in QC until version 2.0, iirc
16:55:06 <dbueno> dons: No.  Is there a programmatic way to know which QuickCheck I'm using?
16:55:26 <dons> ghc-pkg list QuickCheck
16:55:26 <dbueno> dons: I'm using GHC 6.6.1.
16:55:33 <dons> I don't think it comes with a Char instance
16:55:41 <dons> only the darcs version of QuickCheck
16:55:44 <dbueno> dons: Oh, 1.0.1.  I see.
16:55:51 <dons> if you were using cabal as your buidl system, you could specify QuickCheck>=2.0
16:56:07 <dbueno> dons:  I am.  Are you saying cabal will download it for me?
16:56:32 <sorear> dbueno: no, but it will fail the build if deps are not satisfied
16:57:10 <sorear> dbueno: cabal is very roughly like rpm or dpkg, it's a "low level" tool - cabal-install/aptage is in charge of downloading
16:57:52 <sjw> dons: reffje
16:57:55 <sjw> or re
16:58:08 <sjw> stupid emacs tab complete
16:59:08 <dons> heya sjw
17:00:24 <dons> sjw, ChilliX: I gave a 1 hr talk about xmonad today, you might be interested, www.cse.unsw.edu.au/~dons/tmp/xmonad.ps
17:00:44 <dons> and other haskell fans, if they're in this channel
17:00:44 <dons> ?users
17:00:44 <lambdabot> Maximum users seen in #haskell: 407, currently: 371 (91.2%), active: 16 (4.3%)
17:00:44 <dons> oh, a few
17:01:58 <ddarius> dons: ? You don't think other haskell fans are in the channel?
17:02:12 <dons> ;)
17:02:19 <dibblego> cool logo!
17:02:26 <dons> damn straight.
17:05:51 <dons> oh hmm `Haskellian' might be a good reply to `Pythonic'
17:06:24 <conal> i'm reading xmonad.ps.  inspiring!
17:06:26 <sjw> dons: you need a few more babelfish translations in your slides :)
17:06:39 <dons> conal: oh, wonderful. i'll turn it into a blog post by the weekend I think.
17:06:46 <dons> sjw: they rock, don't you think?
17:06:47 <sjw> In the Church of Curry?
17:06:54 <conal> dons: do!
17:07:17 <LoganCapaldo> Claim: The reader monad seems like the most useful to port to other languages monad.
17:07:18 <dons> conal: my HW demo will be a stripped down version of that talk, I suspect
17:07:36 <dons> LoganCapaldo: hmm, maybe. or maybe Maybe ?
17:07:39 <conal> fun.  how much time do you have for the demo?
17:07:44 <dons> 15 mins
17:07:48 <dons> I think?
17:08:09 <LoganCapaldo> I think Maybe is the one that is the most unwittingly used
17:08:18 * EvilTerran sniggers at page 15 of dons' xmonad talk
17:08:25 <ChilliX> Hi dons!
17:08:34 <dons> hey
17:08:35 <LoganCapaldo> foo = getobj(); if( foo ) ... do stuff ..
17:08:45 <EvilTerran> (the Programming Reddit screenshot)
17:08:48 <dons> ah heh
17:09:53 <LoganCapaldo> but people don't tend to fake reader like that, ime, they either pass their env around explicitly everywhere or they use globals
17:10:32 <sjw> dons: why newtype over type for X?  You want to add instancees for other classes?
17:10:59 <dons> $ uname -msr
17:11:02 <dons> OpenBSD 4.2 amd64
17:11:04 <dons> :)
17:11:46 <KatieHuber> what is QuickCheck?
17:12:25 <LoganCapaldo> The future of testing
17:12:28 <dons> its a property-based testing library for Haskell
17:12:45 <dons> ?go QuickCheck
17:12:48 <sjw> + automatic test-case generation
17:12:50 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
17:12:50 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
17:13:12 <dons> ?check \xs -> reverse (reverse xs) == (xs :: [Int])
17:13:17 <lambdabot>  OK, passed 500 tests.
17:13:23 <dons> that's QuickCheck running
17:14:05 <sjw> are there rewrite rules for reverse . reverse?
17:14:10 <dons> KatieHuber: make sense? it generates input to generic testing properties
17:14:19 <dons> sjw, laziness says no :)
17:14:43 <sjw> dons: you or the language? :)
17:14:45 <LoganCapaldo> > reverse (reverse [1..])
17:14:49 <lambdabot> Terminated
17:14:54 <LoganCapaldo> > [1..]
17:14:55 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:15:02 <dons> "its a refinement" duncan would say :)
17:15:20 <sjw> too strict
17:15:42 <LoganCapaldo> Can you write a lazier reverse?
17:16:01 <dons> ?src reverse
17:16:01 <lambdabot> reverse = foldl (flip (:)) []
17:16:02 <conal> just finished xmonad.ps.  go xmonad!
17:16:09 <dons> :) cheers conal
17:16:10 <sjw> no, I mean that reverse is too strict to get rid of reverse . reverse
17:16:49 <dons> > let s = 1 : undefined  in head (reverse (reverse s)) == head s
17:16:51 <lambdabot>  Undefined
17:16:57 <KatieHuber> so it's like writing unit tests, only you write a meta-test, a pattern that describes what a valid test might look like
17:18:09 <KatieHuber> seems nifty, I've written special-case stuff like that in imperative languages before now (usually for checking threaded code)
17:20:53 <ddarius> KatieHuber: Unit tests come out as a special case.
17:30:39 <dbueno> Is not http://darcs.haskell.org/packages/QuickCheck/ the quickcheck repo?  I tried configuring in there and the version is 1.0.1.
17:30:41 <lambdabot> Title: Index of /packages/QuickCheck
17:30:55 <dons> try grabbing the version from hackage
17:30:58 <dons> ?hackage QuickCheck
17:30:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck
17:31:09 <dons> or are you looking for the unreleased darcs version?
17:31:30 <dbueno> dons: Yes, the unreleased one.
17:31:44 <dons> i think that's darcs.haskell.org/QuickCheck ?
17:32:00 <dbueno> I found a mismatch between my version of QuickCheck and the manual I was reading.  Perhaps I should read an older manual?
17:32:24 <dons> well, its improved since the papers were published
17:32:30 <dons> your best docs are the haddock ones on haskell.org
17:32:34 <dons> since they match the version you're using
17:32:52 <dbueno> dons: Okay.
17:33:20 <sjw> dons: btw, did you see the CFG zipper paper?
17:33:28 <sjw> (Ramsey and Dias)
17:33:29 <dbueno> dons: Oh yeah, saw those.  The problem is there's no english-language documentation.  Just the haddock-generated stuff.
17:33:53 <dons> sjw, yeah, very nice stuff
17:34:04 <dbueno> dons: I was reading the manual, which haskell.org points to, and apparently is a later version of QuickCheck.
17:34:19 <dons> home time!
17:34:24 * dons -> train
17:44:06 <stepcut> so, I find I have a lot of code that looks like, case expr of (SomeConstructor _ _ _ _ _ _ _ _) | (SomeOtherConstructor _ _ _ _ _) | ...
17:44:37 <Igloo> You can say SomeConstructor {} if you don't want to match /any/ of the arguments
17:45:00 <LoganCapaldo> that's a neat trick
17:45:09 <LoganCapaldo> record syntax works for anything?
17:45:11 <stepcut> Igloo: awesome! I only care about the Constructor
17:46:01 <Igloo> Personally I view it as an ugly hack  :-)   but then I don't like using records on the LHS to bind fields anyway
17:46:05 <LoganCapaldo> @type (\x -> case x of Just {} -> True ; _ -> False)
17:46:07 <lambdabot> forall t. Maybe t -> Bool
17:46:15 <Igloo> And yeah, it works even if the constructor wasn't declared as a record
17:46:33 <stepcut> I am using records, so I can access the fields if I need them
17:46:45 <LoganCapaldo> wow
17:46:49 <LoganCapaldo> good trick
17:46:58 <stepcut> excellent trick, I should have asked years ago ;)
17:47:57 <phobes> so what's going on there?
17:48:34 <LoganCapaldo> We're learning about the secret use of record syntax
17:48:43 <Igloo> phobes: If you have data Foo = Foo {x :: Int, y :: Char} then you can say f (Foo { x = a }) = print a
17:48:50 <phobes> @type (\x -> case x of Either {} -> True; _ -> False)
17:48:51 <lambdabot> Not in scope: data constructor `Either'
17:48:58 <phobes> @type (\x -> case x of Left {} -> True; _ -> False)
17:49:00 <lambdabot> forall t t1. Either t t1 -> Bool
17:49:04 <Igloo> The above just does the same thing, but has no fields in the {}
17:49:54 <Igloo> Foo { x = a } as a pattern desugars to Foo a _
17:50:20 <phobes> You mean to Foo a _ ... _ as needed, right?
17:50:53 <Igloo> Well, in the concrete example above it's Foo a _
17:50:53 <phobes> Nm :)
17:50:57 <phobes> ya
17:51:00 <Igloo> But in general, any fields not bound get _s, yes
17:51:56 <phobes> @type (\x -> case x of Left _ -> True; _ -> False)
17:51:59 <lambdabot> forall t t1. Either t t1 -> Bool
17:52:28 <phobes> Hmm, I guess I didn't understand stepcut's original question .. why not just use one _?
17:52:44 <Igloo> But I find Foo { x = a } confusing on the LHS, and the "binding precedence" of the { ... } also scares me
17:52:58 <Igloo> Because he only wants to match certain constructors
17:53:11 <Igloo> And they have lots of arguments
17:54:10 <phobes> @type (\x -> case x of (,) _ -> True; _ -> False)
17:54:12 <lambdabot>     Constructor `(,)' should have 2 arguments, but has been given 1
17:54:12 <lambdabot>     In the pattern: (,) _
17:54:24 <phobes> @type (\x -> case x of (,) {} -> True; _ -> False)
17:54:26 <lambdabot> forall t t1. (t, t1) -> Bool
17:54:30 <phobes> I see
17:55:00 <stepcut> so, {} is like a _ that matches an unbounded number of arguments to the constructor
17:55:40 <stepcut> the "I really don't care" symbol
17:55:51 <stepcut> :)
17:56:20 <LoganCapaldo> @type \(,) {} -> True
17:56:22 <lambdabot> forall t t1. (t, t1) -> Bool
17:56:26 <LoganCapaldo> @type \(,,) {} -> True
17:56:28 <lambdabot> forall t t1 t2. (t, t1, t2) -> Bool
17:56:34 <LoganCapaldo> @type \(,,,) {} -> True
17:56:35 <lambdabot> forall t t1 t2 t3. (t, t1, t2, t3) -> Bool
17:56:45 <phobes> Is there an easy way to desugar records?  or is that a core part of the type system?
17:57:01 <LoganCapaldo> just use them in order
17:57:12 <LoganCapaldo> data Foo = Foo { x :: Int , y :: Int }
17:57:18 <LoganCapaldo> Foo 1 2 -- works
17:57:25 <phobes> and vice-versa
17:57:44 <phobes> @type (\x -> case x of (,) { x :: Int, y :: Int } -> True; _ -> False)
17:57:46 <lambdabot> parse error on input `::'
17:57:56 <phobes> @type (\x -> case x of (,) { x, y } -> True; _ -> False)
17:57:57 <lambdabot> parse error on input `,'
17:58:03 <LoganCapaldo> well that's not desugaring, that's sugaring
17:58:20 <phobes> ya
17:58:29 <LoganCapaldo> and not valid syntax besides
17:58:40 <LoganCapaldo> even if (,) were a record
17:58:41 <phobes> So Haskell doesn't support record subtyping?
17:59:00 * LoganCapaldo punts to someone who knows what that means
17:59:05 <dolio> With the exception of {}, record syntax only works with types declared as records.
17:59:15 <Igloo> No, Haskell records are extremely simple
17:59:27 <phobes> dolio:  So {} really is a special catch-all notation?
17:59:28 <dolio> And, records are just sugar for algebraic datatypes, so no, no subtyping.
17:59:43 <phobes> ok
18:00:01 <Igloo> It's not particularly special, it just falls out frmo the way the desugaring works
18:01:05 <LoganCapaldo> Igloo, IOW it would be more work to make {} not work for non-records?
18:02:26 <Igloo> Well, it just depends on the details of how you define it
18:07:18 <ddarius> There's nothing special about records that makes them more "subtypeable".
18:07:30 <phobes> ya, just reading the haskell report about them
18:08:18 <ddarius> My point is that there is no reason to have just record subtyping.
18:08:53 <phobes> And not have more general subtyping you mean?
18:10:11 <ddarius> Yes.
18:10:46 <LoganCapaldo> well record subtyping let's you not have to worry about the ordering of the fields, but I guess the compiler can always reorder the fields
18:15:56 <dolio> Record subtyping adds back in names associated with the fields, though, no?
18:17:00 <LoganCapaldo> I dunno
18:17:07 <LoganCapaldo> I'm just saying stuff
18:17:09 <LoganCapaldo> heh
18:18:11 <phobes> Ya I just brought up record polymorphism because I thought I'd heard something about it in here before... I really had no idea of how it would fit in with Haskell's other features
18:18:20 <phobes> turns out it doesn't!
18:19:17 <falconair_> if i want to introduce real-world time in the standard list operations, does it make sense to have fold/map/filter functions make their current thread 'sleep'?  Say I have [(time,message)], could I write a map function which displays "message" only after waiting "time" seconds?
18:19:50 <sjanssen> falconair_: map isn't able to display a message
18:20:27 <LoganCapaldo> @type forM
18:20:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
18:20:32 <falconair_> sjanssen...right, I meant if I do it monadically (mapM for example)
18:20:47 <dolio> phobes: There have been proposals for polymorphic/extensible records and variants. But nobody's implemented them.
18:21:14 <LoganCapaldo> @type (forM \(time, message) -> threadDelay time >> putStrLn message)
18:21:16 <lambdabot> parse error on input `\'
18:21:22 <sorear> ddarius: Is there a sound and complete type inference algorithm for HM augmented with an arbitrary computable subtyping relation?
18:21:31 <LoganCapaldo> @type (forM (\(time, message) -> threadDelay time >> putStrLn message))
18:21:33 <lambdabot> Not in scope: `threadDelay'
18:21:42 <LoganCapaldo> @hoggle threadDelay
18:21:43 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
18:21:52 <LoganCapaldo> @type (forM (\(time, message) -> Control.Concurrent.threadDelay time >> putStrLn message))
18:21:54 <lambdabot>     The lambda expression `\ (time, message) -> ...' has one argument,
18:21:54 <lambdabot>     but its type `[a]' has none
18:22:08 <falconair_> basically I want to introduce actual time to list operations which are obviously useful ... catamorphisms and data/codata seem to have rich theory behind them ... has anyone worked time in that theory?
18:22:10 <LoganCapaldo> eh you get the idea
18:22:36 <LoganCapaldo> @type (mapM (\(time, message) -> Control.Concurrent.threadDelay time >> putStrLn message))
18:22:36 <lambdabot> [(Int, String)] -> IO [()]
18:22:36 <falconair_> LoganCapaldo: is there a reason you tuple the two arguments, does currying cause problems here?
18:23:11 <LoganCapaldo> falconair, you said "Say I have [(time,message)], could I write a map function which displays "message" only after waiting "time" seconds?"
18:23:24 <falconair_> oh... :)
18:23:52 <ddarius> sorear: I don't know off hand.
18:24:17 <LoganCapaldo> @type (mapM_ (\(time, message) -> Control.Concurrent.threadDelay time >> putStrLn message))
18:24:18 <Arnia> Hm... I'm having problems getting namespaces to work in HXT. I am generating a document which includes a lot of qnames (its RDF/XML) and when it is output they show up nicely prefixed but the root element doesn't have any @xmlns:* attributes
18:24:19 <lambdabot> [(Int, String)] -> IO ()
18:25:42 <falconair_> does any one know if the new lightweight-concurrency work will alter the concurrency interface for haskell programmers, or is it all back-end stuff?
18:25:47 <ddarius> "Still, although complete algorithms for polymorphic subtype inference exist"
18:26:19 <ddarius> falconair_: If nothing else, it's not as backend as before.
18:26:43 <Philippa> sorear: there isn't for arbitrary, have you read the existing work on HM(X) though? The extended version of the ATTaPL chapter's good (and about as good as you're going to get in terms of what's been done)
18:27:17 <sorear> Philippa: I tried to read up on HM(X), but there seems to be no free description of what it even is, much less its properties
18:27:38 <ddarius> Isn't there papers linked from the Chameleon guys?
18:28:14 <falconair_> ddarius: i'm just wondering if it is worth learning thread handling in haskell if it is going to change in near-future versions (not including data-parallel stuff)
18:30:03 <sjanssen> falconair_: I don't think you'll see any major changes any time soon
18:30:15 <falconair_> sjanssen: thanks
18:30:18 <sjanssen> forkIO and MVars should be around for a long while
18:30:34 <sjanssen> they might even be in the next Haskell standard
18:30:49 <ddarius> falconair_: The stuff will make new frontends possible without having to break everything else.
18:30:55 <ddarius> falconair_: Nothing is going away.
18:31:15 <sjanssen> falconair_: you can also check out STM for a refreshing take on the shared state problem
18:31:16 <phobes> sorear:  I have a paper on HM(X) that I got for free
18:31:23 <phobes> I haven't read it yet
18:31:28 <phobes> so not sure it's what you're looking for
18:31:30 <sorear> phobes: Can I get it for free too?
18:31:41 <falconair_> ddarius: i've been reading about it and it look very interesting ... i'm a little disappointed that it won't be in ghc 6.8
18:32:28 <phobes> sorear:  Looks like it's on citeseer:  http://citeseer.ist.psu.edu/16814.html
18:32:29 <lambdabot> Title: Type Inference with Constrained Types - Odersky, Sulzmann, Wehr (ResearchIndex)
18:33:37 <ddarius> As I said, the Chameleon people.
18:34:34 <Philippa> sorear: look for that ATTaPL chapter, it's also free
18:34:42 <Philippa> and it's 100+ pages of tutorial
18:35:10 <Philippa> http://cristal.inria.fr/attapl/
18:35:39 <ddarius> 100+ page chapter, yay!
18:38:36 <Philippa> I really should read through all of it properly sometime - I've got some stuff I'm starting to toy with
18:38:54 <Philippa> (though I probably just jinxed my chances of having anything worth showing in the next year)
18:40:08 <drtomc> Hi All! I'm just reading http://www.cse.unsw.edu.au/~chak/papers/Cha99.html and have a couple of questions. Has anyone here read it?
18:40:09 <lambdabot> Title: Research Papers of Manuel Chakravarty
18:41:04 <dons> drtomc: which one is that?
18:41:11 <drtomc> fast lexing
18:41:12 <dons> is that the lexer?
18:41:13 <dons> ah yes.
18:41:20 <dons> i've read it, and worked on the code
18:41:33 <dons> ChilliX also has read it (being the author of the paper ;)
18:42:23 <drtomc> So, he has a function joinActions which merges actions.
18:42:46 <drtomc> If presented with two actions, it errors.
18:43:42 <drtomc> This means, considering, say a C lexer, you can't define "int" (the keyword) as a separate token to identifier.
18:44:12 <dons> hmm, that seems odd, isn't it somethiing like:   string "int" <+> ...
18:44:28 <dons> look in c2hs, there's actually a C lexer written in these combinators
18:44:44 <drtomc> The alternative, that I'm contemplating is to make it prefer the left hand alternative.
18:45:03 <drtomc> That way, you can write all your keyword tokenizers then identifier.
18:45:03 <dons> do you have the CTKlight code as well as the paper?
18:45:11 <dons> yeah
18:45:19 <dons> i've done that actually, in another project
18:45:27 <dons> modified it to not error, and instead take the left most
18:45:30 <drtomc> You forsake commutativity, but there's no such thing as a free lunch.
18:45:30 <dons> or right most, one of them
18:45:36 <Pseudonym> That's pretty much the same semantics as lex, of course.
18:45:46 <drtomc> Ja.
18:45:49 <dons> ah, join is <|> ?
18:45:59 * dons tries to remember the ctk combinators
18:46:51 <drtomc> I'm just working off the paper which has latexisms instead of ascii
18:47:16 <Pseudonym> You mean you don't have a space cadet keyboard?
18:47:25 <drtomc> :-)
18:47:52 <drtomc> I'd love one! I'm a closet typography nerd.
18:48:02 <Pseudonym> Ah.
18:48:03 <dons> i think half this channel is :)
18:48:05 <Pseudonym> It's in footnote 2.
18:48:17 <drtomc> Ah, so it is.
18:48:41 <drtomc> I must say, I was taken by the cute hack of making ?, * and + infix.
18:49:00 <dons> they're not just normal infix operators?
18:49:13 <drtomc> Oh, I mean the RE operators.
18:49:59 <drtomc> And I mean binary, not infix (though they are infix as well).
18:50:38 <LoganCapaldo> oh
18:50:43 <drtomc> It's kind of like CPS for regular expressions
18:51:31 <LoganCapaldo> so like 'a' ? 'b' is a?b
18:51:33 <LoganCapaldo> ?
18:51:44 <drtomc> Exactly.
18:51:54 <LoganCapaldo> that is pretty clever
18:52:05 <Pseudonym> Except that ?b means something else if -fglasgow-exts
18:52:06 <drtomc> It means you can translate "a ? b" into "ab|b"
18:52:28 <drtomc> Yes, I'm talking in terms of normal RE notation.
18:52:36 <Pseudonym> Yeah, and it makes sense because every RE must be followed by an action otherwise it's useless.
18:52:48 <dons> so its a type error to do , say, * x
18:52:51 <dons> which is nice.
18:53:05 <Pseudonym> So even REs that end in E? have to have something following.
18:53:16 <drtomc> Kleene + is simple too: a+b == a(a*b)
18:53:33 <ChilliX> drtomc: CPS for regular expressions.  That's a nice way to describe it.  Never thought of that.
18:54:03 <drtomc> I've been trying to come to grips with stream processor arrows, so CPS is on the brain. :-)
18:54:03 <Pseudonym> Well, it's a special case of a general idea of getting the algebra right, then realising it with context passing.
18:54:20 <ChilliX> drtomc: ah, ic :)
18:54:28 <ddarius> @google Type Quote/AntiQuote
18:54:35 <lambdabot> http://www.smlnj.org/doc/quote.html
18:54:35 <lambdabot> Title: SML/NJ Quote/Antiquote
18:54:44 <ddarius> @google Typed Quote/AntiQuote
18:54:45 <lambdabot> https://mail.cs.uu.nl/pipermail/stc/2006q1/000185.html
18:55:44 <ddarius> LoganCapaldo and perhaps drmtomc: See the paper with that title by Ralf Hinze.
18:58:15 <drtomc> Got it, now I just need 3 weeks to read it (my normal length of time for a Hinze paper). :-)
18:58:16 <sorear> @go Functional pearl typed LR antiquote
18:58:18 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
18:59:05 <drtomc> On the other hand, the small startup where I hack Haskell for money is about to go broke, so I'll have plenty of time. :-(
19:00:04 <ChilliX> drtomc: WHich startup is that?
19:00:23 <Pseudonym> drtomc: BTW, this channel is logged.
19:00:36 <Pseudonym> FWIW
19:00:44 <drtomc> Sure. I don't think it's an issue.
19:00:53 * Pseudonym nods, but thought he'd mention it anyway
19:01:22 <drtomc> It's a digital media business.
19:01:32 <sorear> it's in the topic
19:02:12 <ChilliX> And can you say what Haskell is used for?
19:02:26 <LoganCapaldo> hey look at that
19:02:34 <LoganCapaldo> CPS parsing
19:02:37 <drtomc> Sure. I'm writing a text indexing engine.
19:03:02 <drtomc> You may have seen a few mentions of STM and BTrees on haskell-cafe
19:03:52 <chessguy> BTrees? like the ones for spatial information?
19:04:09 <drtomc> Well, the ones used for indexing in general.
19:04:24 <ChilliX> drtomc: How did they (or you?) come to choose Haskell?
19:04:33 <drtomc> I've been implementing Kim Larsen's relaxed balance version.
19:04:34 <LoganCapaldo> chessguy, maybe you are thinking of K(D?)-Trees?
19:04:40 <chessguy> oh, i was thinking of R-trees
19:04:40 <chessguy> http://en.wikipedia.org/wiki/R-tree
19:04:41 <lambdabot> Title: R-tree - Wikipedia, the free encyclopedia
19:05:01 <Pseudonym> R-trees are kind of obsolete, aren't they?
19:05:12 <drtomc> My choice. Most of the code is python, which does not like threads.
19:05:14 <chessguy> Pseudonym, replaced with what?
19:05:35 <drtomc> So, I did an inital implementation in python, but it was too slow.
19:06:12 <drtomc> The serial haskell is faster, and with STM should be much more scalable on multi-core hardware.
19:06:16 <ChilliX> drtomc: ah, ic, that's interesting
19:06:24 <Pseudonym> chessguy: UB-trees, IIRC.
19:06:38 <Pseudonym> But I could be wrong.
19:06:41 <drtomc> The main problem with python is that it has a global interpreter lock.
19:06:44 <ChilliX> When you say faster, how much roughly?
19:06:52 <drtomc> x2
19:07:21 <ChilliX> And did you have much experience with Haskell before you started on that project?
19:07:35 <drtomc> Only toy.
19:07:44 <ChilliX> ok, cool
19:07:53 <drtomc> On the other hand, my PhD was with Mercury, so I know declarative programming.
19:07:54 <Pseudonym> Lots of declarative experience, though.
19:07:57 <Pseudonym> Yeah.
19:08:09 <ChilliX> drtomc: What's the interpreter lock for?
19:08:34 <Pseudonym> ChilliX: Implementor convenience.
19:08:40 <ChilliX> drtomc: Yeah, but performance optimisation in Haskell is still quite different from Mercury, I'd think.
19:08:49 <drtomc> Very.
19:08:59 <drtomc> Very extremely, even.
19:09:03 <ChilliX> drtomc: :)
19:09:38 <ChilliX> drtomc: One reason I am asking is because we have made the experience that we can produce extremely efficient code in haskell, see eg dons projects.
19:09:38 <drtomc> Writing stuff *without* accumulators still feels funny. :-)
19:10:03 <ChilliX> But it always makes me wonder how much you have to know about the implementation to get there.
19:10:10 <ChilliX> drtomc: :)
19:10:37 <Pseudonym> I think, perhaps, this is as much a comment about Python as about Haskell.
19:11:01 <ChilliX> Pseudonym: it probably is, but what angle do you have in mind?
19:11:14 <drtomc> Yes, it is. It is surprising that a relatively modern language should be so hostile to threads.
19:11:20 <ddarius> ChilliX: I think the "typical" Haskeller could/will get better once it's more clearly taught how to program in a lazy language.
19:11:26 <KatieHuber> if you think python's bad about threads, try ruby :/
19:11:44 <Pseudonym> ChilliX: Like Tom says, hostile to threads.
19:11:46 <ChilliX> drtomc: yes, it surprised me a little to hear that
19:11:58 <Pseudonym> Python doesn't really have threads.  It's got something closer to coroutines.
19:12:14 <drtomc> Yes - python coroutines are *really* nice.
19:12:23 <drtomc> Nearly as good as lazy evaluation.
19:12:25 <KatieHuber> at least python allows python code to run on multiple OS threads, even if it doesn't much like it... ruby forces all interaction with the interpreter to occur on the same OS thread
19:12:29 <ChilliX> ddarius: I agree
19:12:55 <ChilliX> KatieHuber: oh, that's bad
19:12:57 <sorear> Meanwhile, GHC supports as much threading as you wand
19:13:20 * LoganCapaldo would like to point out both jython and jruby have real threads 
19:13:28 <sorear> funny how the major implementations of Python and Ruby are called Python and Ruby respectively
19:13:40 <sorear> while Haskell and GHC make a point of distinguishing the two
19:14:02 <Pseudonym> Well, Haskell was designed as a unification and consolidation of differeng implementations.
19:14:04 <ddarius> Haskell was never really a single implementation language.
19:14:08 <ChilliX> sorear: I guess it is because Haskell started as a language, which got subsequently implemented
19:14:19 <dons> what a crazy idea :)
19:14:24 <ChilliX> whereas Python and RUby started as implementations
19:14:27 <ddarius> Also Haskell is not "one person's" language.
19:14:40 <Pseudonym> Haskell really started life as a bunch of related but distinct languages implemented by different people.
19:14:45 <ddarius> Is there any document defining what Ruby and Python are?
19:14:58 <LoganCapaldo> also I think sydney had real threads and maybe suby (both being forks of the c ruby code)
19:15:01 <drtomc> I think it reflects Haskell's origins in the research community and the other languages' origins as pragmatic integration layer languages.
19:15:08 <sorear> +in English or another natural language
19:15:11 <KatieHuber> ddarius: yeah, the source code to the primary interpreters for each ;)
19:15:12 <sjanssen> ddarius: the source code? :P
19:15:14 <LoganCapaldo> ddarius, there are retroactive attempts for ruby
19:15:16 <ChilliX> drtomc: yep
19:15:20 <LoganCapaldo> I dunno about python
19:15:26 <ddarius> KatieHuber, sjanssen: My point.
19:16:02 <KatieHuber> I have an entirely unrelated question
19:16:05 <LoganCapaldo> http://www.headius.com/rubyspec/index.php/Main_Page
19:16:06 <KatieHuber> I have this function:
19:16:07 <lambdabot> Title: Main Page - RubySpec
19:16:08 <joed> Stupid question, but last nights discourse over KatieHuber 's stuff was really educational, would that be worth putting on a Wiki?
19:16:09 <KatieHuber> rAnd p h r0 r1 = (r0 p h) && (r1 p h)
19:16:14 <ddarius> Oh no! Topicality
19:16:24 <LoganCapaldo> it burnsss
19:16:27 <Philippa> joed: if you think so, grab the log off the web and do so?
19:16:29 <KatieHuber> ignore the silly names for now :p
19:16:38 <ddarius> What about the superfluous parens?
19:16:39 <Pseudonym> joed: You know where the logs are...
19:16:45 <ddarius> and the wiki
19:16:51 <Pseudonym> Oh, licensing.
19:16:51 <KatieHuber> but I think I should be able to write this without p h in the definition
19:16:54 <Pseudonym> Dammit.
19:17:00 <joed> Philippa: Yeah, Pseudonym Thanks for the monad tutorial :)
19:17:06 <ddarius> Point.
19:17:08 <ari> @type \ p h r0 r1 -> (r0 p h) && (r1 p h)
19:17:10 <KatieHuber> and generalize so it doesn't rely on Bool and &&
19:17:11 <lambdabot> forall t t1. t -> t1 -> (t -> t1 -> Bool) -> (t -> t1 -> Bool) -> Bool
19:17:12 <ddarius> Where's that page on the wiki?
19:17:38 <LoganCapaldo> kinda looks like on2
19:17:44 <Pseudonym> ?free \p h r0 r1 -> r0 p h && r1 p h
19:17:44 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:17:46 <KatieHuber> asking lambdabot to @pl it gives something very funny :)
19:17:52 <ari> KatieHuber: What type should the generalised version have?
19:17:53 <Pseudonym> ?free \r0 r1 -> r0 p h && r1 p h
19:17:53 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:18:00 <Pseudonym> ?pl \r0 r1 -> r0 p h && r1 p h
19:18:01 <lambdabot> (. flip ($ p) h) . (&&) . flip ($ p) h
19:18:05 <Pseudonym> Ouch.
19:18:09 <Pseudonym> Don't use that version.
19:18:23 <Pseudonym> ?pl \p h -> r0 p h && r1 p h
19:18:23 <lambdabot> ap (ap . ((&&) .) . r0) r1
19:18:26 <Pseudonym> Or that.
19:19:03 <ddarius> Ah, HaskellUserLocations was migrated (unrelated to the page I'm looking for)
19:19:07 <Pseudonym> ?pl \op p h -> op (r0 p h) (r1 p h)
19:19:07 <lambdabot> (`ap` r1) . (ap .) . (. r0) . (.)
19:19:55 <Pseudonym> That's... actually, oddly pretty.
19:19:58 <Pseudonym> If opaque.
19:20:08 <drtomc> :-)
19:20:35 <LoganCapaldo> > join (,) (\f -> f p h)
19:20:36 <lambdabot>   Not in scope: `h'
19:20:46 <LoganCapaldo> > \p h -> join (,) (\f -> f p h)
19:20:47 <lambdabot>  Add a type signature
19:20:53 <ddarius> Ah, this one http://www.haskell.org/haskellwiki/Haskell_Cafe_migration
19:20:54 <LoganCapaldo> @type \p h -> join (,) (\f -> f p h)
19:20:54 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
19:20:55 <lambdabot> forall t t1 t2. t -> t1 -> ((t -> t1 -> t2) -> t2, (t -> t1 -> t2) -> t2)
19:21:17 <Pseudonym> zipWith (&&) (uncurry r0 &&& uncurry r1)
19:21:26 <Pseudonym> Uhm.
19:21:26 <LoganCapaldo> @type \p h r0 r1  -> first r0 >>> second r1 $  join (,) (\f -> f p h)
19:21:29 <lambdabot> forall t t1 c c1 t2. -> t1 -> (((t -> t1 -> t2) -> t2) -> c) -> (((t -> t1 -> t2) -> t2) -> c1) -> (c, c1)
19:21:34 <Pseudonym> curry (&&) (uncurry r0 &&& uncurry r1)
19:21:38 <Pseudonym> Or something.
19:22:08 <KatieHuber> :t (&&&)
19:22:10 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:22:15 <ddarius> Don't open the box!
19:22:16 * KatieHuber blinks
19:22:26 <Pseudonym> > (id &&& (+1)) 2
19:22:28 <lambdabot>  (2,3)
19:22:33 <ddarius> You're not supposed to look behind the curtains!
19:22:42 <ddarius> @instances Arrow
19:22:43 <lambdabot> (->), Kleisli m
19:23:11 <Pseudonym> :t on2
19:23:13 <lambdabot> Not in scope: `on2'
19:23:18 <LoganCapaldo> I made it up
19:23:19 <ddarius> :t on3
19:23:21 <lambdabot> Not in scope: `on3'
19:23:31 <LoganCapaldo> didn't make that one up
19:23:35 <LoganCapaldo> :)
19:23:43 <Pseudonym> :t on
19:23:45 <lambdabot> Not in scope: `on'
19:23:49 <ddarius> @index on
19:23:49 <lambdabot> bzzt
19:24:00 <KatieHuber> what needs importing for &&&?
19:24:05 <LoganCapaldo> @docs Data.Function
19:24:05 <lambdabot> Data.Function not available
19:24:05 <Pseudonym> Control.Arrow
19:24:11 <ddarius> @index (&&&)
19:24:11 <lambdabot> Control.Arrow
19:24:33 <Pseudonym> The other thing that'd be useful to move out of an obscure library into the prelude is...
19:24:41 <Pseudonym> ?index (><)
19:24:41 <lambdabot> Data.Graph.Inductive.Query.Monad, Data.Graph.Inductive.Query, Data.Graph.Inductive
19:24:49 <ddarius> :t (><)
19:24:51 <lambdabot> Not in scope: `><'
19:24:53 <Pseudonym> :t (Data.Graph.Inductive.><)
19:24:54 <lambdabot> forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:25:06 <ddarius> :t (***)
19:25:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:25:16 <Pseudonym> Or that.
19:25:33 <Pseudonym> Someone fix Data.Graph.Inductive, then.
19:26:08 <ddarius> Control.Arrow probably didn't exist when the code for Data.Graph.Inductive was written
19:27:12 <LoganCapaldo> @src (->) (***)
19:27:12 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
19:27:20 <LoganCapaldo> woah
19:27:26 <LoganCapaldo> irrefutable
19:27:37 <LoganCapaldo> that's kinda surprising
19:27:42 <LoganCapaldo> why they do that?
19:27:47 <Pseudonym> Because of loop.
19:27:54 <LoganCapaldo> ?
19:27:59 <Pseudonym> ?src loop
19:27:59 <lambdabot> Source not found. I feel much better now.
19:28:12 <Pseudonym> :t Control.Monad.loop
19:28:14 <lambdabot> Not in scope: `Control.Monad.loop'
19:28:19 <Pseudonym> What's it called?
19:28:29 <drtomc> Control.Arrow.loop
19:28:34 <Pseudonym> Duh.
19:28:42 <Pseudonym> ?src (->) Control.Arrow.loop
19:28:42 <lambdabot> Source not found. My pet ferret can type better than you!
19:29:01 <LoganCapaldo> @source Control.Arrow
19:29:01 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
19:29:11 <sorear> Any refutable tuple match is probably wrong.
19:29:25 <Pseudonym> The thing is, loop introduces cycles.
19:29:36 <LoganCapaldo> loop f b = let (c,d) = f (b,d) in c
19:29:37 <ari> (f *** g) x = (f (fst x), g (snd x)) <- note that since fst and snd are lazy, this is equivalent to the definition with the irrefutable tuple match, whereas the refutable one is stricter
19:29:52 <Pseudonym> And it's perfectly reasonable to loop a call to (***).
19:30:11 <LoganCapaldo> @source Data.Graph.Inductive
19:30:11 <lambdabot> http://darcs.haskell.org/packages/fgl/Data/Graph/Inductive.hs
19:30:29 <Pseudonym> Imagine loop (f *** g), expand it, and you'll see why the ~ makes sense.
19:30:30 <drtomc> Why is it not the case that all single constructor matches are irrefutable?
19:30:35 <ari> *a refutable one would be stricter
19:31:10 <drtomc> That is matches on types with a single constructor.
19:31:23 <ari> drtomc: _|_
19:31:54 <LoganCapaldo> data.graph.inductive is wrong then
19:31:56 <LoganCapaldo> :(
19:32:03 <ddarius> It's irrefutable, because that is The Right Way to write that.
19:32:29 <LoganCapaldo> sorry
19:32:34 <LoganCapaldo> at leasts hugs's is
19:33:13 <Pseudonym> Basically, if you don't put in the ~, then loop (f *** g) ends up in a black hole.
19:33:20 <LoganCapaldo> ghc tooo
19:34:12 <LoganCapaldo> @source Data.Graph.Inductive
19:34:13 <lambdabot> http://darcs.haskell.org/packages/fgl/Data/Graph/Inductive.hs
19:34:13 <ddarius> > (id***id) undefined `seq` 3 -- let's make something more defined
19:34:18 <lambdabot>  3
19:34:59 <Pseudonym> Even without undefined.
19:35:00 <ddarius> That said, I think I got it backwards and that the refutable pattern is arguably wrong.
19:35:14 <Pseudonym> > loop (id***id) 3
19:35:15 <lambdabot>  3
19:35:25 <LoganCapaldo> (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:35:25 <LoganCapaldo> (f >< g) (x,y) = (f x,g y)
19:35:29 <ddarius> One would like id***id to equal id
19:35:35 <LoganCapaldo> http://darcs.haskell.org/packages/fgl/Data/Graph/Inductive/Query/Monad.hs
19:35:35 <lambdabot> http://tinyurl.com/ysrj2h
19:35:36 <LoganCapaldo> :(
19:35:45 <ddarius> Instead id *** id > id
19:36:10 <LoganCapaldo> @type (id *** id)
19:36:11 <lambdabot> forall a a1. (a, a1) -> (a, a1)
19:36:44 <LoganCapaldo> > (id *** id) (1, undefined)
19:36:46 <lambdabot>  Undefined
19:37:01 <LoganCapaldo> > id (1, undefined)
19:37:02 <lambdabot>  Undefined
19:37:24 <ddarius> > id undefined `seq` 3
19:37:25 <lambdabot>  Undefined
19:37:32 <ddarius> > (id *** id) undefined `seq` 3
19:37:34 <lambdabot>  3
19:37:36 <LoganCapaldo> I somehow thought it would do (1, ...error out ehre....
19:37:53 <sorear> Sadly, no.
19:38:02 <ddarius> Tuple show too strict?
19:38:14 <LoganCapaldo> lists do that don't they?
19:38:17 <sorear> Nah, just lambdabot line-buffers output.
19:38:27 <sorear> LoganCapaldo: false
19:38:37 <sorear> > [1..10] ++ undefined
19:38:39 <lambdabot>  Undefined
19:38:58 <ddarius> LoganCapaldo: Tuples do too in GHCi.
19:39:03 <sorear> dons: any chance of getting hSetBuffering stdout NoBuffering in runplugs?
19:39:08 <LoganCapaldo> yeah
19:39:12 <LoganCapaldo> it's all lambdabot's fault
19:39:19 * LoganCapaldo weeps
19:39:22 <ddarius> Well, that was my GHCi usage for the month.
19:39:40 <ddarius> Another person brought to tears by lambdabot.
19:39:43 <LoganCapaldo> I went to check in ghci and this was the error message I got
19:40:03 <LoganCapaldo> <interactive>:1:0: parse error on input `>'
19:41:09 <LoganCapaldo> cause I typed >
19:41:12 <dons> sorear: seems reasonable. send a patch
19:41:13 <LoganCapaldo> force of habit
19:41:28 <dons> little surprised we didn't do it already
19:44:57 <kfish> morning all
19:45:55 * sorear waves
19:48:01 <dons> heya kfish
19:48:38 <KatieHuber> @hoogle a -> b -> (a -> b -> c -> d -> (e, f)) -> ((e, f) -> g) -> (a -> b -> g)
19:48:39 <lambdabot> No matches, try a more general search
19:48:39 <KatieHuber> :p
19:49:02 <KatieHuber> er, I was wrong anyway :|
19:49:08 <KatieHuber> @hoogle a -> b -> (a -> b -> c -> d -> (e, f)) -> ((e, f) -> g) -> (c -> d -> g)
19:49:08 <lambdabot> No matches, try a more general search
19:49:14 <KatieHuber> still not surprised
19:49:29 <sioraiocht> my undergrad university had TWO professors die this summer
19:49:45 <dolio> @djinn a -> b -> (a -> b -> c -> d -> (e, f)) -> ((e, f) -> g) -> (c -> d -> g)
19:49:46 <lambdabot> f a b c d e f =
19:49:46 <lambdabot>     case c a b e f of
19:49:46 <lambdabot>     (g, h) -> d (g, h)
19:50:31 <LoganCapaldo> go djinn
19:50:38 <sioraiocht> what is djinn?
19:50:46 <KatieHuber> whoa, what just happened :|
19:50:50 <Pseudonym> sioraiocht: A theorem prover.
19:50:55 <LoganCapaldo> for free!
19:50:57 <LoganCapaldo> no charge
19:51:02 <sioraiocht> Pseudonym: how does it work?
19:51:07 <Pseudonym> You give it a theorem, and it finds a proogf.
19:51:11 <dolio> That case is a bit superfluous, unless you want the strictness.
19:51:13 <Olathe> Does it come with cupholders ?
19:51:14 <Pseudonym> Via Curry-Howard.
19:51:26 <LoganCapaldo> @djinn Bool -> a -> a -> a
19:51:27 <sioraiocht> how is a type signature a theorem?
19:51:27 <lambdabot> f a b c =
19:51:27 <lambdabot>     case a of
19:51:27 <lambdabot>     False -> c
19:51:27 <lambdabot>     True -> b
19:51:36 <kfish> mmm, curry
19:51:46 <Pseudonym> sioraiocht: Curry-Howard isomorphism.
19:51:46 <sjw> sioraiocht: replace the -> by --> (== implication)
19:51:51 <Pseudonym> Right.
19:51:57 <ddarius> sjw: Usually => is used.
19:52:05 <sjw> meh
19:52:06 <Pseudonym> So if you want to prove that A & B implies A, for example.
19:52:11 <Pseudonym> ?djinn (a,b) -> a
19:52:11 <lambdabot> f (a, _) = a
19:52:12 <sioraiocht> Pseudonym: isomorphism? isn't that some category theory term?
19:52:14 <Pseudonym> There's your proof.
19:52:22 <ddarius> sioraiocht: Yes and no.
19:52:23 <sjw> ddarius: for some reason Isabelle uses => for function arrow
19:52:24 <LoganCapaldo> (a, b) is and, and Either a b is or
19:53:07 <sioraiocht> @djinn a -> b -> (a->b)
19:53:08 <lambdabot> f _ a _ = a
19:53:12 <sioraiocht> weird
19:53:18 <dolio> @djinn a -> Not (Not a)
19:53:19 <lambdabot> f a b = b a
19:53:33 <Olathe> @djinn a -> (Not a)
19:53:33 <lambdabot> -- f cannot be realized.
19:53:39 <Olathe> Why Not ?
19:53:44 <ddarius> @. pl djinn a -> Not (Not a)
19:53:44 <lambdabot> f = flip id
19:53:47 <Pseudonym> ?djinn Not (Not a) -> a
19:53:48 <lambdabot> -- f cannot be realized.
19:53:51 <sorear> @djinn-env
19:53:52 <Pseudonym> Note!
19:53:52 <lambdabot> data () = ()
19:53:52 <lambdabot> data Either a b = Left a | Right b
19:53:52 <lambdabot> data Maybe a = Nothing | Just a
19:53:52 <lambdabot> data Bool = False | True
19:53:52 <lambdabot> data Void
19:53:54 <lambdabot> type Not x = x -> Void
19:53:56 <lambdabot> class Eq a where (==) :: a -> a -> Bool
19:53:57 <dolio> You want to prove that a implies its own negation?
19:53:58 <Pseudonym> Constructive logic.
19:54:11 <Pseudonym> ?djinn (a, Not a)
19:54:11 <lambdabot> -- f cannot be realized.
19:54:14 <Olathe> @djinn (a -> (Not a -> a))
19:54:14 <lambdabot> f a b = void (b a)
19:54:18 <Pseudonym> ?djinn Either a (Not a)
19:54:19 <lambdabot> -- f cannot be realized.
19:54:26 <sioraiocht> @djinn Either a (Not (a))
19:54:26 <Olathe> So, void means what ?
19:54:27 <lambdabot> -- f cannot be realized.
19:54:35 <sjw> ?djinn Either a (Not a)
19:54:35 <lambdabot> -- f cannot be realized.
19:54:40 <ddarius> Olathe: From falsity, anything.
19:54:41 <sjw> spoilsport
19:54:41 <ari> @. djinn type callCC
19:54:44 <lambdabot> Cannot parse command
19:54:45 <Pseudonym> sjw: Constructive logic.
19:54:58 <Pseudonym> a \/ not a is not a theorem.
19:55:01 <sjw> Pseudonym: yeah, I know
19:55:11 <Olathe> It isn't ?
19:55:17 <Olathe> Oh.
19:55:21 <ddarius> Not in Intuitionistic Logic.
19:55:22 <sorear> It's not true
19:55:35 <ari> @djinn ((a -> m b) -> m a) -> m a
19:55:35 <lambdabot> -- f cannot be realized.
19:55:51 <ari> :p
19:56:04 <ddarius> ari: forall m. is too general
19:56:07 <sorear> @djinn-add type CC r a = (a -> r) -> r
19:56:16 <LoganCapaldo> @djinn (a -> b) -> (b -> r) -> r
19:56:16 <lambdabot> -- f cannot be realized.
19:56:16 <ari> ddarius: true dat
19:56:24 <sorear> @djinn ((a -> CC r b) -> CC r a) -> CC r a
19:56:24 <lambdabot> f a b = a (\ c _ -> b c) b
19:57:00 <LoganCapaldo> @djinn (a -> b) -> (b -> r) -> (a -> r)
19:57:01 <lambdabot> f a b c = b (a c)
19:57:17 <sjw> @djinn (forall a. p a) -> p b
19:57:17 <lambdabot> -- f cannot be realized.
19:57:18 <ddarius> @. compose pl djinn type
19:57:18 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "type\n"
19:57:41 <dons> oh, that's a pity
19:57:42 <ddarius> sjw: It doesn't do higher-rank types, I don't believe.
19:57:48 <ddarius> @. compose pl djinn type const
19:57:50 <lambdabot> f a _ = a
19:57:50 <dons> no, very simple h98 subset
19:57:53 <dons> type classes are new
19:58:02 <ddarius> dons: They are very, very hackily added.
19:58:12 <dons> ?djinn Eq a => a -> a -> Bool
19:58:12 <lambdabot> Cannot parse command
19:58:14 <ari> @. pl . djinn type const
19:58:14 <dons> yep
19:58:14 <ddarius> Only type classes too.
19:58:15 <sjw> so constructive propositional logic only?
19:58:16 <lambdabot> f = const
19:58:40 <LoganCapaldo> ari++
19:59:26 <dons> "  Djinn interprets a Haskell type as a logic formula using the
19:59:26 <dons> Curry-Howard isomorphism and then uses a decision procedure for
19:59:26 <dons> Intuitionistic Propositional Calculus.  This decision procedure is
19:59:26 <dons> based on Gentzen's LJ sequent calculus, but in a modified form, LJT,
19:59:26 <dons> that ensures termination."
19:59:40 <dons> The decision procedure has been extended to generate a proof object
19:59:40 <dons> (i.e., a lambda term).  It is this lambda term (in normal form) that
19:59:40 <dons> constitutes the Haskell code.
19:59:50 <dons> http://www.dcs.st-and.ac.uk/~rd/publications/jsl57.pdf
20:00:07 <sjw> lots of fun
20:00:14 <dons> yeah, its a candy bag
20:00:37 <dons>   Since Djinn handles propositional calculus it also knows about the
20:00:37 <dons> absurd proposition, corresponding to the empty set.  This set is
20:00:37 <dons> called Void in Haskell, and Djinn assumes an elimination rule for the
20:00:37 <dons> Void type:
20:00:37 <dons>   void :: Void -> a
20:00:38 <sioraiocht> wtf is intuitionistic logic---nevermind, I don't want to know, that path leads to the Dark Side..or something
20:00:51 <dons> to theorem proving
20:00:55 <dons> same thing.
20:01:03 <ddarius> @quote Dark.Side
20:01:03 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
20:01:06 <ddarius> @quote Dark.Side
20:01:06 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
20:01:10 <ddarius> Darn.
20:01:15 <chessguy> isn't that the same type as foo :: a -> b?
20:01:51 <ddarius> @quote theorem.proving
20:01:52 <lambdabot> No quotes match. My mind is going. I can feel it.
20:01:59 <ddarius> @quote monochrom
20:02:00 <KatieHuber> if I write my function as
20:02:02 <KatieHuber> rAnd f r0 r1 p h = f (r0 p h) (r1 p h)
20:02:03 <lambdabot> monochrom says: Power doesn't corrupt you. No no no. Power makes you INSANE! Absolute power makes you absolutely insane! BWAHAHAHAHAHA...
20:02:09 <KatieHuber> then lambdabot can fix it:
20:02:12 <KatieHuber> @pl rAnd f r0 r1 p h = f (r0 p h) (r1 p h)
20:02:12 <lambdabot> rAnd = (liftM2 ap .) . (.) . (.)
20:02:19 <KatieHuber> only... that's a lot of dots
20:02:29 <sioraiocht> what's pl do?
20:02:32 <dons> heh
20:02:35 <KatieHuber> it's pointless ^_^
20:02:36 <dolio> Heh, fix it.
20:02:41 <dons> sioraiocht: it does a pointfree refactoring
20:02:44 <chessguy> KatieHuber, @pl sometimes creates....very unreadable code
20:02:46 <ddarius> @pl rAnd p h = f (r0 p h) (r1 p h)
20:02:47 <lambdabot> rAnd = ap (ap . (f .) . r0) r1
20:03:00 <dons> there's some good examples on ?wiki/Pointfree
20:03:15 <chessguy> @wiki Pointfree
20:03:15 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
20:03:16 <dons> however, f (r0 p h) (r1 p h)  looks arrows-ish
20:03:46 <sorear> especially if you can tuple them!
20:04:15 <sioraiocht> @pl f x  = x + 1
20:04:15 <lambdabot> f = (1 +)
20:04:22 <sioraiocht> weird, ow does it KNOW? =p
20:04:26 <sioraiocht> *how
20:04:35 <shachaf> That (+) is commutative?
20:04:48 <dons> ?pl \x -> x + 1
20:04:48 <lambdabot> (1 +)
20:04:54 <dons> ?pl \x -> 2 * 3
20:04:54 <lambdabot> const 6
20:04:59 <chessguy> @pl f x = x - 1
20:04:59 <lambdabot> f = subtract 1
20:05:00 <sioraiocht> or how to refactor anything?
20:05:04 <sioraiocht> *boggles*
20:05:13 <dolio> curry (r0 &&& r1 >>> uncurry f) ?
20:05:19 <dons> it parses the expression, then applies a term rewriting engine
20:05:20 <Olathe> ?pl \x -> [1..x]
20:05:20 <lambdabot> enumFromTo 1
20:05:33 <ddarius> @pl \x -> map f (map g x)
20:05:33 <lambdabot> map (f . g)
20:05:34 <dons> dolio: though can we avoid the >>> ?
20:05:34 <dolio> Oh, wait, you need to uncurry r0 and r1, too.
20:05:37 * sioraiocht is humbled.
20:05:56 <dons> sioraiocht: it helps that its a purely functional language
20:05:59 <dolio> dons: Yeah, but the precedence of >>> is probably better.
20:06:01 <dons> so we can refactor like crazy
20:06:15 <dolio> Better than (.), that is.
20:06:17 <dons> dolio: interesting idiom, i rarely use >>> in these games. good idea
20:06:36 <dons> ?wiki Pointfree
20:06:36 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
20:06:41 <dons> has an extended story, sioraiocht
20:06:42 <dolio> I assume (f &&& g >>> h) == ((f &&& g) >>> h)...
20:06:48 <sioraiocht> oh?
20:06:58 <dolio> Whereas I think (f &&& g . h) == (f &&& (g . h))
20:07:21 <dons> i wish the rules engine in @pl was dynamically extensible
20:07:43 <ddarius> (f . h &&& g . h)
20:07:57 <sioraiocht> @pl fact n = foldr (*) [1..n]
20:07:58 <lambdabot> fact = foldr (*) . enumFromTo 1
20:08:17 <dons> we have some good tools here in haskell land
20:08:18 <shachaf> You mean foldr (*) 1?
20:08:27 <sioraiocht> shachaf: yeah, whatever =p
20:08:29 <ddarius> Like #haskell
20:08:32 <sioraiocht> @pl fact n = foldr1 (*) [1..n]
20:08:32 <lambdabot> fact = foldr1 (*) . enumFromTo 1
20:08:35 <sioraiocht> there =p
20:08:59 <shachaf> > let fact n = foldr1 (*) [1..n] in fact 0
20:09:01 <lambdabot>  Exception: Prelude.foldr1: empty list
20:09:04 <Olathe> What does pointfree mean ?
20:09:08 <Olathe> @help pl
20:09:08 <lambdabot> pointless <expr>. Play with pointfree code.
20:09:10 <shachaf> > let fact n = foldr (*) 1 [1..n] in fact 0
20:09:12 <lambdabot>  1
20:09:29 <shachaf> Olathe: A "point" is a named argument.
20:09:34 <dons> http://haskell.org/haskellwiki/Pointfree#But_pointfree_has_more_points.21
20:09:36 <lambdabot> Title: Pointfree - HaskellWiki, http://tinyurl.com/2poemf
20:09:47 <Olathe> Oh.
20:09:54 <Olathe> Can all functions be made pointfree ?
20:10:02 <KatieHuber> hehe if I unpl what pl does to my function it gets worse ^_^
20:10:03 <dolio> Yes.
20:10:07 <shachaf> Olathe: Given some primitives.
20:10:10 <KatieHuber> and worse again if I pl that...
20:10:12 <dons> KatieHuber: haha
20:10:20 <shachaf> Olathe: Not functions that do pattern matching, for example.
20:10:29 <dons> yes, it gets bad pretty quickly once @pl brings in the (-> a) monad
20:10:29 <Pseudonym> But you can Church encode your data types.
20:10:36 <sioraiocht> @pl (:)
20:10:36 <lambdabot> (:)
20:10:40 <sioraiocht> damn, heh
20:11:00 <Pseudonym> What you can do is remove all lambdas.
20:11:05 <KatieHuber> aww, it stopped
20:11:12 <KatieHuber> pl likes rAnd = flip flip (flip (fmap . (. ((. (return .)) . (>>=))) . (>>=))) . (((.) . (>>=)) .) . (.) . (.)
20:11:13 <dons> fix point found?
20:11:17 <dons> nice
20:11:18 <Olathe> Heheh
20:11:27 <dolio> Wow.
20:11:33 <sioraiocht> lol
20:11:41 <dons> have to be careful the type is still the same. @pl might have non-type preserving bugs
20:11:56 <KatieHuber> unpl thinks it's rAnd y f o = (\ s v -> y (f s v)) >>= \ i -> fmap (\ au -> i >>= \ ax -> au >>= \ ba -> return (ax ba)) o
20:12:09 <Pseudonym> dons: Or type-generalising non-bugs.
20:12:18 <dolio> @pl \f r0 r1 -> curry (uncurry r0 &&& uncurry r1 >>> uncurry f)
20:12:19 <lambdabot> ((curry .) .) . flip (flip . ((>>>) .) . (. uncurry) . (&&&) . uncurry) . uncurry
20:12:19 <dons> yeah
20:12:25 <Pseudonym> ?pl \x y -> x y
20:12:25 <lambdabot> id
20:12:28 <Pseudonym> For example.
20:12:45 <Olathe> @unpl id
20:12:45 <lambdabot> (\ a -> a)
20:12:54 <Pseudonym> ?src curry
20:12:55 <lambdabot> curry f x y = f (x, y)
20:13:03 <Pseudonym> ?src uncurry
20:13:03 <lambdabot> uncurry f p = f (fst p) (snd p)
20:13:13 <Olathe> What's the difference between @ and ? for lambdabot ?
20:13:16 <dolio> @pl \f x y -> f (x, y)
20:13:16 <lambdabot> (. (,)) . (.)
20:13:32 <ddarius> Olathe: Nothing.
20:13:42 <Olathe> Oh.
20:14:22 <Pseudonym> ?pl \f r0 r1 -> (\f' x' y' -> f' (x',y')) ((\f' p' -> f' (fst p') (snd p')) r0 &&& (\f' p' -> f' (fst p') (snd p')) r1 >>> (\f' p' -> f' (fst p') (snd p')) f)
20:14:23 <lambdabot> ((((. (,)) . (.)) .) .) . flip (flip . ((>>>) .) . (. flip (ap . (. fst)) snd) . (&&&) . (`ap` snd) . (. fst)) . (`ap` snd) . (. fst)
20:15:01 <Pseudonym> :t \f r0 r1 -> curry (uncurry r0 &&& uncurry r1 >>> uncurry f)
20:15:03 <lambdabot> forall a b a1 b1 c. (a1 -> b1 -> c) -> (a -> b -> a1) -> (a -> b -> b1) -> a -> b -> c
20:15:05 <KatieHuber> pl really does like .
20:15:21 <Pseudonym> ?free f :: (a1 -> b1 -> c) -> (a -> b -> a1) -> (a -> b -> b1) -> a -> b -> c
20:15:21 <lambdabot> (forall x. k . f1 x = f2 (g x) . h) => (forall y. g . f3 y = f4 (p y) . q) => (forall z. h . f5 z = f6 (p z) . q) => k . f f1 f3 f5 u = f f2 f4 f6 (p u) . q
20:16:06 <chessguy> @fix \f x y -> f (x, y)
20:16:06 <lambdabot> Maybe you meant: faq ft id thx
20:16:10 <chessguy> @help fix
20:16:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:16:45 <ddarius> unsw guys, know Norman Wildberger?
20:17:04 <dolio> @thx
20:17:04 <lambdabot> you are welcome
20:33:55 <ddarius> ...
20:36:18 <monochrom> let x ... y = x . x . x . y = (sin ... id) 1
20:36:21 <monochrom> > let x ... y = x . x . x . y = (sin ... id) 1
20:36:22 <lambdabot>  Parse error
20:36:26 <monochrom> boo
20:37:10 <dolio> I think you have an = instead of an 'in'.
20:38:38 <dolio> > let x ... y = x . x . x . y in (sin ... id) 1
20:38:39 <lambdabot>  0.6784304773607402
20:39:40 <monochrom> oops
20:52:21 <Pseudonym> > let x ... y = x . x . x . y in (((+) =<< sin) ... id) 3
20:52:22 <lambdabot>  3.141592653589793
20:52:57 <Pseudonym> > let x ... y = x . x . x . y in (ap (-) tan ... id) 3
20:52:58 <lambdabot>  3.141592653589793
20:53:00 <Pseudonym> Woo.
21:03:33 <Pseudonym> 2 * 1.6543612251060553e-24 * 2^16
21:03:45 <Pseudonym> > 2 * 1.6543612251060553e-24 * 2^16
21:03:46 <lambdabot>  2.168404344971009e-19
21:03:46 <Pseudonym> Erm.
21:05:07 <drtomc> Hey, another question about the lexer paper: the definition of the function "action" (pg 13) is buggy - 'l' occurrs free in the second equation. The correct equation isn't obvious. Anyone?
21:07:19 <Pseudonym> > 1.8815731582632217e9 / 2^30
21:07:21 <lambdabot>  1.752351558081081
21:07:57 <Pseudonym> > 2^30 / 1.8815731582632217e9
21:07:58 <lambdabot>  0.5706617461481609
21:08:05 <dolio> Are there some new constants I need to learn or something?
21:08:19 * Pseudonym should really use ghci rather than lambdabot
21:14:22 <dibblego> does GHC optimise the tail call in filter?
21:14:22 <dibblego> if so, how?
21:14:22 <dolio> @src filter
21:14:22 <lambdabot> filter _ []     = []
21:14:22 <lambdabot> filter p (x:xs)
21:14:22 <lambdabot>     | p x       = x : filter p xs
21:14:22 <lambdabot>     | otherwise = filter p xs
21:14:22 <dibblego> otherwise = filter p xs -- that one
21:14:22 <dolio> Well, it won't overflow the stack.
21:14:22 <dolio> > filter (< 1) [1..]
21:14:22 <lambdabot> Terminated
21:14:22 <dibblego> yeah, I'm writing filter for a strict list
21:14:22 <dibblego> I can't think of how to do it without having to reverse afterward
21:14:42 <sjanssen> dibblego: in a strict setting, you have the choice of using O(n) heap or stack
21:15:05 <dibblego> sjanssen, how do I do it in O(n) heap, since I will have to reverse afterward?
21:15:31 <sjanssen> O(n) heap is the cost when you reverse afterward
21:15:41 <dibblego> ah yes
21:15:49 <sjanssen> ie. you have to create that list and toss it away
21:17:02 <dibblego> I guess foldl', then reverse it
21:17:20 <monochrom> I'm thinking if there is a continuation trick.
21:17:40 <sjanssen> my intuition says it isn't possible
21:17:45 <dibblego> mine too
21:17:57 <dolio> > let filter' p l = filter'' id l where filter'' f [] = f [] ; filter'' f (x:xs) | p x = filter'' (f . (x:)) xs | otherwise = filter'' f xs in filter' (<5) [1..10]
21:17:59 <lambdabot>  [1,2,3,4]
21:18:11 <sjanssen> dibblego: you should just use a lazy list
21:18:26 <sjanssen> dibblego: oh, you can do it if mutation is allowed
21:18:38 <monochrom> A continuation trick would still use O(n) heap. It just looks cuter.
21:18:41 <dibblego> mutation is allowed
21:19:00 <monochrom> Nice.
21:19:04 <sjanssen> dibblego: then just keep a pointer to the last cell in the list, and update the tail as you go along
21:19:16 <dibblego> sjanssen, yeah, I think I will, thanks
21:19:33 <dolio> > let filter' p l = filter'' id l where filter'' f [] = f [] ; filter'' f (x:xs) | p x = filter'' (f . (x:)) xs | otherwise = filter'' f xs in filter' (<1) [1..]
21:19:37 <lambdabot> Terminated
21:20:57 <_Zaph0d_> Hi. Trying to learn from "Haskell Craft of Functional Programming" I'm stuck on an exercise - define  total :: (Int -> Int) -> (Int -> Int)  so that total f n = f 0 + f 1 + ... + f n
21:21:03 <_Zaph0d_> I came up with total f = \n -> foldr (+) 0 ( map f [0..n] )
21:21:10 <_Zaph0d_> but I think it's too ugly
21:21:37 <_Zaph0d_> Can any one help please?
21:21:45 <sjanssen> _Zaph0d_: you can use sum instead of (foldr (+) 0)
21:21:53 <Pseudonym> @let agm = let f (a,b) = (0.5*(a+b),sqrt(a*b)) in fst . (!!10000) . iterate f
21:21:57 <lambdabot> Defined.
21:22:04 <_Zaph0d_> yep, that would clean it up thanks
21:22:23 <Pseudonym> > let n = 100000 in (pi / (2*agm (1,4/n)), log n)
21:22:24 <dolio> Generally you'd say 'total f n = ...', too. Not split up the parameters.
21:22:24 <lambdabot>  (11.512925469175398,11.512925464970229)
21:22:47 <KatieHuber> how do record selectors work?  I thought I could just use 'em like normal functions?
21:22:57 <KatieHuber> maybe my exports are screwed up or something :|
21:23:10 <sjanssen> KatieHuber: yes, you can use them like normal functions
21:23:18 <KatieHuber> ... or maybe I just can't remember what I called em :/
21:23:29 <sjanssen> KatieHuber: what does your export list look like?
21:23:59 <KatieHuber> it's OK, it was just that I'd called 'em one thing in one file and something completely different in the next
21:24:10 <KatieHuber> tends not to help when you do that :|
21:26:39 <monochrom> And IDE with code completion would help.
22:00:49 <kfish> hi OceanSpray, mudge
22:07:25 <OceanSpray> hi kfish
22:08:12 <kfish> OceanSpray, had a chance to read the monad.reader?
22:08:46 <OceanSpray> no
22:08:49 <OceanSpray> what's that?
22:09:00 <kfish> a magazine about haskell
22:09:15 <kfish> i wrote a tutorial intro to the type system, and i'd be interested in your comments :-)
22:09:25 <kfish> ?where tmr
22:09:26 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
22:09:31 <kfish> ?where insanity
22:09:32 <lambdabot> http://haskell.org/haskellwiki/User:ConradParker/InstantInsanity
22:14:59 <OceanSpray> oh sorry, I was in the restroom
22:15:11 <OceanSpray> magazine about haskell, eh?
22:15:22 <monochrom> internet access coming to your restroom soon :)
22:15:46 <monochrom> TMR is great restroom reading :)
22:23:40 <ttmrichter> help unignore *had
22:36:11 <OceanSpray> oh wow, kfish
22:53:35 <kfish> OceanSpray, how's it?
22:58:13 <OceanSpray> kfish, I have to go to sleep now
22:58:30 <OceanSpray> but I'll dinish reading it tomorrow
22:58:35 <OceanSpray> *finish
23:01:01 <kfish> ok :-) night!
23:17:31 <vincenz> @where hac
23:17:31 <lambdabot> http://haskell.org/haskellwiki/HAC
23:18:55 <vincenz> @where hackathon
23:18:56 <lambdabot> I know nothing about hackathon.
23:19:02 <vincenz> dcoutts_: ping
23:22:02 <vincenz> @seen dons
23:22:02 <lambdabot> I saw dons leaving #xmonad and #haskell 2h 54m 24s ago, and .
23:23:14 <vincenz> Anyone know how to get the mac of one's interfaces under linx?
23:23:50 <vincenz> nm, it's shown in ifconfig, just not under 'MAC'
23:55:02 <ChilliX> Is hpaste dead?
23:55:12 <ChilliX> ah, now it worked
23:55:18 <hpaste>  chak annotated "Instant insanity with type families" with "Wow!" at http://hpaste.org/2689#a1
23:55:25 <hpaste>  chak annotated "Instant insanity with type families" with "Wow!" at http://hpaste.org/2689#a2
23:58:47 <kfish> mmm, type families :-)
23:59:17 <ChilliX> kfish: nice TMR article btw!
23:59:23 <sjanssen> ChilliX: one trick is to use Data.Typeable.typeOf
23:59:33 <kfish> ChilliX, cheers, thanks :-))
