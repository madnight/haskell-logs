00:05:46 <quicksilver> Pseudonym: I understand the question, but I don't know the answer
00:07:58 <quicksilver> Pseudonym: my gut feeling is that no monads are prime; all non-trivial monads have an infinity of non-isomorphic adjunctions which give rise to them
00:18:37 <Cale> I'd thought about that problem before as well, it's interesting to see it pop up on the mailing list :)
00:22:24 <quicksilver> Cale: wrong mailing list though. I daresy if posted to cat, an answer would be forthcoming :)
00:31:50 <Mitar> hpaste is down?
00:32:38 <glguy> hpaste: url
00:32:57 <hpaste> Haskell paste bin: http://hpaste.org/
00:33:03 <Mitar> http://pastebin.com/d6050470c
00:33:10 <Mitar> any help ...
00:33:17 <Mitar> ok, now it connected
00:34:34 <glguy> Mitar: String isn't a Monad
00:34:42 <glguy> but semant :: Expr -> String
00:35:00 <glguy> so you can't say: if _ then return _
00:35:05 <Mitar> aghhh
00:35:06 <Mitar> :-)))
00:35:07 <glguy> Unless
00:35:10 <glguy> you actually meant
00:35:12 <glguy> to use the list monad
00:35:14 <Mitar> no no
00:35:22 <Mitar> i just meant e1' there
00:35:26 <Mitar> without return ..
00:35:34 <Mitar> i was doing parsec all day yesterday :-)
00:35:37 <glguy> correction: string isn't the monad you wanted, rather :)
00:35:47 <Mitar> i was too long in a monadic world
00:35:50 <Mitar> i have to get back
00:36:27 <Mitar> but ... i am making a function to check types of a parsed tree
00:36:53 <Mitar> is there better (more haskell way) then having a bunch of if types_match then type else error?
00:37:12 <glguy> Maybe Type
00:40:02 <Mitar> hm, what would this accomplish, would not it be then just if types_match then Just type else Nothing
00:41:26 <glguy> guard (t1 == t2) >> return t1 ?
00:44:33 <takamura> hi
00:46:05 <Cale> hello
00:46:31 <Mitar> hmm, thanks, i will check
00:47:38 <Vq^> good morning mr Gibbard
00:48:34 <Cale> Very early morning here :)
00:48:46 <Cale> I might go back to sleep
00:49:05 <Vq^> @localtime Cale
00:49:06 <lambdabot> Local time for Cale is Thu Sep 13 03:47:39
00:49:26 <Vq^> yeah, thats a bit early, it's 09:48 over here
00:49:56 <takamura> @localtime takamura
00:49:56 <lambdabot> Local time for takamura is Thu Sep 13 09:49:19
00:49:57 <Vq^> through the magic of timezones :o)
00:50:07 <takamura> nice :)
00:51:06 <kfish> @localtime vodka
00:51:09 <Vq^> it suggests that the world is cylindrical instead of flat
00:52:08 <dolio> Obviously it's a cube.
00:52:13 <takamura> @localtime lambdabot
00:52:14 <lambdabot> I live on the internet, do you expect me to have a local time?
00:52:42 <takamura> @localtime ChanServ
00:53:38 <quicksilver> the world is, of course, a Lambda Cube
00:53:52 <dolio> Anyone who says otherwise has been educated stupid.
00:55:37 * Vq^ checks the satelite pics: http://evilsuperbrain.com/gallery/finished/index.php?image=links_poster
00:55:40 <lambdabot> Title: evilsuperbrain.com - galleries, http://tinyurl.com/2oy6aj
00:55:44 <quicksilver> Mitar: guards often look nicer than ifs
00:56:02 <quicksilver> Mitar: that's mostly a trivial syntactic transform, but it does look nicer
00:56:04 <Mitar> yes, but i have to use them later on
00:56:16 <quicksilver> have to use which?
00:56:44 <Mitar> semant (If t e1 e2) | semant t == "int" && semant e1 == semant e2 = semant e1
00:56:59 * quicksilver nods
00:57:05 <quicksilver> I think that looks slightly nicer than the if
00:57:11 <quicksilver> but it's a question of choice
00:57:18 <Mitar> yes, but i have twice "semant e1"
00:57:29 <quicksilver> you can use 'where' with guards
00:57:34 <quicksilver> or ,at least, I think you can
00:58:02 <dolio> Yes, you can.
00:58:16 <quicksilver> > let { f | x == 1 && y == 2 = "foo" } where {x = 1; y=2}
00:58:16 <lambdabot>  Parse error
00:58:35 <quicksilver> > let { f | x == 1 && y == 2 = "foo" ; where {x = 1; y=2} }
00:58:35 <lambdabot>  Parse error
00:58:38 <quicksilver> > let { f | x == 1 && y == 2 = "foo" ; where {x = 1; y=2} } in f
00:58:38 <lambdabot>  Parse error
00:58:42 <quicksilver> > let { f | x == 1 && y == 2 = "foo" } where {x = 1; y=2} in f
00:58:43 <lambdabot>  Parse error
00:58:45 <quicksilver> bah :P
00:58:49 <Mitar> i think not ...
00:58:56 <Mitar> i tried not and nop
00:59:08 <dolio> > let { f | x == 1 && y == 2 = "foo" where { x = 1 ; y = 2 } } in f
00:59:10 <lambdabot>  "foo"
00:59:16 <quicksilver> dolio++
00:59:57 <Mitar> with quards it is also a problem how to make an error message useful (otherwise I will just have at the end one big: type check failed, figure it out
01:00:25 <quicksilver> giving good error messages in type checkers is hard
01:00:38 <quicksilver> giving good error messages and keeping the code looking elegant is even harder :)
01:01:41 <Mitar> :-)
01:01:56 <Mitar> but I could at least tell them it is in if clause :-)
01:02:06 <Mitar> (tell me, i am making it for myself)
01:02:41 <quicksilver> Mitar: I think you can do it all with guards, myself
01:02:59 <quicksilver> | e1' /= e2 = fail "then/else don't match"
01:03:10 <quicksilver> | t' /= "int" = fail "cond is not int"
01:03:41 <hpaste>  Mitar pasted "Like so?" at http://hpaste.org/2716
01:04:25 <quicksilver> no
01:05:47 <quicksilver> Mitar: annotating, 1 sec
01:06:36 <hpaste>  quicksilver annotated "Like so?" with "where scopes over guards" at http://hpaste.org/2716#a1
01:06:42 <quicksilver> Mitar: there you are
01:07:27 <Mitar> ohhh
01:07:31 <Mitar> thanks a lot
01:09:08 <quicksilver> Mitar: of course it's still not really type-correct
01:09:28 <quicksilver> Mitar: it's just returning strings and you want it to return some kind of error-carrying monad
01:09:38 <quicksilver> Mitar: otherwise the fail is meaningless
01:10:08 <Cale> There's also MonadError
01:10:16 <Mitar> why is meaningless?
01:10:29 <quicksilver> Mitar: because "fail" is a monad method
01:10:35 <quicksilver> Mitar: and the monad you're using is String
01:10:43 <quicksilver> Mitar: and fail in String doesn't do what you hope it does :)
01:10:53 <quicksilver> > fail "magical vanishing error message" :: String
01:11:01 <Cale> String isn't a monad
01:11:04 <lambdabot>  ""
01:11:07 <quicksilver> yes it is
01:11:12 <Cale> List is a monad :)
01:11:19 <quicksilver> bah
01:11:26 <quicksilver> It's much to early for kind errors
01:11:30 <Cale> hehe
01:11:41 <quicksilver> I reserve the right to use incorrect terminology to facilitate exposition
01:13:21 <Mitar> ohhh
01:13:27 <Mitar> it is so true ...
01:13:32 <quicksilver> Mitar: the quick hack would be 'error'
01:13:41 <quicksilver> Mitar: but then you'd only be able to catch your type errors in IO
01:14:07 <Mitar> i do not want to catch anything
01:14:12 <Mitar> :-)
01:14:13 <quicksilver> Mitar: the more sensible hack would be a better error carrying monad, so semant :: Expr -> (Either String String)
01:14:30 <quicksilver> where by Either String String I really mean Either Error Type
01:14:35 <quicksilver> but you're using strings for everything :)
01:14:51 <quicksilver> however, your code becomes more complex, inevitably
01:15:07 <quicksilver> you wouldn't be able to say "e1' = semant e1" any more
01:15:12 <quicksilver> you'd have to move it into a do block
01:15:16 <quicksilver> and say e1' <- semant e1
01:15:23 <sjw> re
01:15:26 <Mitar> yes ...
01:15:49 <Mitar> and because it is a small project for myself (and my course) I will just throw an error and die
01:16:03 <quicksilver> then s/fail/error/g
01:16:08 <Mitar> but thanks ... in some other situation i will use something better as you proposed
01:16:10 <Mitar> thanks
01:16:31 <Mitar> (i thought fail is something like error)
01:17:19 <Mitar> where it is defined?
01:18:14 <mux> yay for GHC 6.8.1 release candidate
01:18:22 <mux> does this release contains ATs?
01:19:13 <quicksilver> Mitar: fail is a method of Monad
01:19:18 <quicksilver> Mitar: much to many people's disgust
01:19:28 <osfameron> why the disgust?
01:19:52 <quicksilver> because there is no reason why a monad should have a zero
01:19:54 <Mitar> no no, error?
01:20:03 <quicksilver> Mitar: error is a primitive
01:20:24 <quicksilver> Mitar: it has no definition other than error = secretPrimitiveThrowExceptionWithString
01:20:32 <mux> quicksilver: is there a Haskell' proposal to fix this issue? ie, with a MonadFail type-class?
01:20:47 <quicksilver> mux: there are a number of proposal, none will make it into haskell'
01:20:52 <osfameron> is a "zero" the same as a fail ?
01:20:59 <quicksilver> osfameron: in the context of monads, yes
01:21:04 <dolio> It was already fixed in 1.4. :)
01:21:09 <dolio> And then unfixed. :)
01:21:10 <mux> quicksilver: too bad, I would have thought this issue to be simple enough that it'd get fixed in Haskell'
01:21:16 <quicksilver> mux: it isn't simple at all
01:21:39 <mux> can you explain what makes it complicated?
01:21:43 <quicksilver> one of the unpalatable consequences is that the type of a 'do' expression would vary depending whether or not it contained pattern bindings which might fail
01:21:52 <mux> ah
01:21:56 <mux> that's annoying indeed
01:22:15 <quicksilver> and whether or not a binding can fail is not a trivial property to observe, for a new programmer
01:22:21 <tuxplorer> line <- hGetLine h throws   parse error on input `<-'
01:22:21 <tuxplorer> Is there anything wrong in this part? or is it something to do with some other part of the program? (if so I would hpaste the whole program)
01:22:46 <quicksilver> ("a <-" clearly can't fail, and "Just a <-" clearly can fail, but "Foo a <-" depends on if Foo is newtype or data)
01:23:09 <quicksilver> tuxplorer: maybe you tried to use it not in a do block?
01:23:21 <KatieHuber> and just to add to the confusion, if I have 5 modules I keep having to import, is there some way I can make it so I don't have to copy & paste those 5 import lines everywhere?
01:23:36 <quicksilver> KatieHuber: you can reduce them to one line
01:23:44 <tuxplorer> I use it in a function, which is being called in a do block..
01:23:47 <quicksilver> KatieHuber: by making a meta-module which imports and re-exports them all
01:23:51 <quicksilver> tuxplorer: that's not the same thing
01:23:57 <KatieHuber> that'd be an improvement
01:24:02 <quicksilver> tuxplorer: <- is a syntactic thing, it's only valid inside a do-block
01:24:29 <tuxplorer> quicksilver: oh! ok..
01:24:45 <KatieHuber> quicksilver: do I have to reexport all the stuff from all the modules, or?
01:25:05 <mux> quicksilver: what solutions have been proposed?
01:25:09 <quicksilver> KatieHuber: trying to remember the syntax
01:25:31 <quicksilver> mux: another problem is that fail taking "String" is pretty arbitrar
01:25:40 <oklopol> you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
01:25:41 <mux> right
01:25:43 <quicksilver> mux: but a more general solution like MonadError uses MPTCes and fundeps
01:26:08 <mux> quicksilver: we could get rid of MPTCs and fundeps with ATs I guess
01:26:17 <ari> @remember oklopol you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
01:26:18 <lambdabot> Done.
01:26:32 <mux> having an associated type for defining the parameter of fail
01:27:13 <quicksilver> KatieHuber: I think you just write module BigCollection( module One, module Two, module Three) where import One ; import Two ; import Three
01:27:15 <dolio> Associated types are even newer and less implemented than fundeps, though.
01:27:17 <hpaste>  tuxplorer pasted "In line 39, Couldn't match expected type `IO' against inferred type `(->) Conn'" at http://hpaste.org/2717
01:27:27 <quicksilver> KatieHuber: I think listing 'module One' in an export list exports it all
01:27:31 <quicksilver> KatieHuber: but I'm not 100% sure :)
01:27:33 <mux> quicksilver: but I don't quite get how pattern failures can change the type of a do-block
01:27:34 <KatieHuber> quicksilver: that appears to work, thanks
01:27:36 <mux> :t fail
01:27:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
01:27:43 <quicksilver> mux: because they call fail
01:27:54 <mux> it still returns m a?
01:28:00 <quicksilver> mux: so  do block without any ways to fail would have type Monad m =>
01:28:12 <quicksilver> mux: yes, but if it was fixed to return MonadFail m => m a
01:28:20 <quicksilver> mux: then that would change the type of the do block :)
01:28:21 <mux> aaaah, ok!
01:28:31 <mux> pretty damn annoying indeed. :-)
01:28:51 <quicksilver> damn, why doesn't hpaste number lines?
01:28:52 <quicksilver> :)
01:28:57 <dolio> It does.
01:29:08 <quicksilver> dolio: d'oh
01:29:10 <quicksilver> dolio: thanks :)
01:29:29 <dolio> :) Of course, it's not easy to see how.
01:30:01 <quicksilver> tuxplorer: well, classify is using 'ask'
01:30:20 <quicksilver> tuxplorer: so, presumably, the type of classify is in the Db monad
01:30:29 <quicksilver> tuxplorer: but 'talk' is in the plain old IO monad
01:30:37 <quicksilver> tuxplorer: so you need to do some work to interface them
01:31:09 <tuxplorer> quicksilver: any suggestions on how to do that?
01:31:51 <quicksilver> tuxplorer: yes
01:32:03 <quicksilver> tuxplorer: didn't I go through this with you about this time yesterday? :)
01:32:15 <quicksilver> tuxplorer: 'runReaderT' allows you to run a Db action inside the IO monad
01:32:22 <tuxplorer> yes. you helped me.. and I made some changes following it..
01:32:28 <quicksilver> (this is because Db is defined as a ReaderT over IO)
01:32:57 <quicksilver> so, instead of 'classify line' you want, I think, conn runReaderT (classify line)
01:33:02 <quicksilver> erm
01:33:07 <quicksilver> words in wrong order
01:33:13 <quicksilver> runReaderT conn (classify line)
01:33:17 <quicksilver> :t runReaderT
01:33:20 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
01:33:25 <quicksilver> no, still wrong
01:33:26 <quicksilver> I suck
01:33:31 <quicksilver> runReaderT (classify line) conn
01:33:44 <quicksilver> (obviously to 'run' something in the Db monad you need to supply the implicit conn)
01:36:19 <tuxplorer> quicksilver: Thanks.. I tried that..  Now getting an error like  "Couldn't match expected type `ReaderT r IO a'           against inferred type `Conn -> ()' "
01:37:34 <quicksilver> tuxplorer: incidentally your code doesn't make sense to me if I view it as a whole
01:37:55 <quicksilver> tuxplorer: classify looks designed to run over DB connections
01:38:02 <quicksilver> tuxplorer: but you're trying to connect it to 'accept'
01:38:09 <quicksilver> tuxplorer: which just works over raw TCP sockets
01:38:36 <quicksilver> tuxplorer: however, if you want me to fix the latest error, please hpaste the whole error :)
01:39:19 <mux> quicksilver == debugger over irc
01:41:15 <opqdonut> heuristic debugger :)
01:41:26 <opqdonut> "your code does not make sense, please redo from scratch"
01:42:29 <mux> heh
01:43:30 <tuxplorer> quicksilver: I want to get a string from the network socket and based on the boolean output of isQuestion function, put it into two different tables in the database.  (right now I'm inserting into just one table for experimenting.. ignore that).. I'm pasting the full error on hpaste..
01:43:56 <ulfdoz> lol
01:45:47 <quicksilver> tuxplorer: excellent. I understand your intention now.
01:45:59 <quicksilver> tuxplorer: you're not calling 'getDbConn' anywhere at the moment.
01:46:22 <hpaste>  (anonymous) annotated "In line 39, Couldn't match expected type `IO' against inferred type `(->) Conn'" with "(no title)" at http://hpaste.org/2717#a1
01:46:26 <quicksilver> tuxplorer: I was misleading you when I suggesting passing 'conn' to the runReaderT; what the runReaderT actually needs is your dbconn
01:46:37 <quicksilver> tuxplorer: but you don't have a dbconn as far as I can see
01:49:19 <tuxplorer> quicksilver: I read Monad as control of side effects section of http://www.alpheccar.org/en/posts/show/60 and thought that even without calling getDbConn, Haskell can assume the values of dbconn as getDbConn is the only place where some value of data type Conn is return
01:49:20 <lambdabot> Title: A newbie in Haskell land or another monad tutorial
01:50:26 <quicksilver> tuxplorer: I'm not familiar with that tutorial but if it gave you that impression, it mislead you
01:50:42 <quicksilver> tuxplorer: all haskell variables must be bound somewhere
01:53:09 <tuxplorer> quicksilver: if I call it in the talk function, when getting the value of conn, then it gets repeated everytime when a string comes in thru the socket.. can I call it in acceptconnections, and would conn get the connection everytime I 'ask' for it?
01:53:34 <quicksilver> tuxplorer: I think you should call it just after the fork, personally
01:53:45 <quicksilver> tuxplorer: you can't safely share a dbconn between threads anyway
01:54:04 <quicksilver> tuxplorer: so you should open a new connection for each accept you do
01:55:06 <scandal> @hoogle hGetBuf
01:55:06 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
01:55:06 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
01:55:06 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
01:56:52 <tuxplorer> quicksilver: I would attempt to add the call in the catch block, and if I have any problem, will get back to take your help :) Thanks a lot
02:03:45 <scandal> @hoogle unsafePerformIO
02:03:49 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
02:19:05 <KatieHuber> anyone know what the difference between mapAccumL and mapAccumR is?  they seem to have the same type signature, and lambdabot only knows the source to mapAccumL AFAICT
02:19:26 <taruti> from Left and from Right.
02:19:53 <quicksilver> @src mapAccumL
02:19:53 <lambdabot> mapAccumL _ s []        =  (s, [])
02:19:53 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
02:19:53 <lambdabot>    where (s', y ) = f s x
02:19:53 <lambdabot>          (s'',ys) = mapAccumL f s' xs
02:20:06 <takamura> There is some program or editor option to count the number of function definitions on a haskell file (or directory)?
02:20:32 <taruti> > mapAccumL (\a b -> (a+b,a+b)) 0 [1..5]
02:20:34 <lambdabot>  (15,[1,3,6,10,15])
02:20:39 <taruti> > mapAccumR (\a b -> (a+b,a+b)) 0 [1..5]
02:20:40 <lambdabot>  (15,[15,14,12,9,5])
02:20:47 <quicksilver> KatieHuber: mapAccumR effectively works from the right hand end of the list
02:20:55 <KatieHuber> OK, thanks
02:21:03 <quicksilver> KatieHuber: IMO they are both deprecated
02:21:11 <KatieHuber> in favor of?
02:21:18 <quicksilver> KatieHuber: they're just a funny way of writing mapM in a stateMonad
02:21:19 <quicksilver> I thnk
02:21:25 <quicksilver> :t mapAccumL
02:21:27 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:21:38 <taruti> quicksilver: but useful in some places.
02:21:40 <KatieHuber> I was looking at Control.Monad.State but not seeing how it was going to help me :/
02:22:16 <taruti> that works also.
02:22:27 <idnar> :t mapM
02:22:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:22:58 <KatieHuber> I can't even describe what I want to do intelligibly :(
02:23:26 <KatieHuber> I just get the feeling that once I can somebody here will go "oh, you just go <X> with <Y> monad and it's like 2 lines of code"
02:23:35 <quicksilver> almost certainly :)
02:24:19 <taruti> mapAccumL f s l = flip $ runState (mapM (\x -> do acc <- get; let (acc',y) = f acc x; put acc'; return y) l) s
02:24:29 <KatieHuber> maybe if I just start at a high level, I can talk down to the point where actual code is involved... if people are willing to listen to me ramble :)
02:24:31 <taruti> or somesuch
02:24:44 <quicksilver> or, to be more concrete:
02:24:56 <quicksilver> > runState (mapM (\x -> do { s <- get; put (s+x); return (s+x); }) [1..5]) 0
02:24:58 <lambdabot>  ([1,3,6,10,15],15)
02:25:12 <quicksilver> that's taruti's first mapAccumL example, rewritten in the state monad
02:25:18 <quicksilver> ok, granted, it's actualy longer and uglier
02:25:24 <quicksilver> but it's also easier to generalise :)
02:25:37 <KatieHuber> I'm writing a solitaire card game, and currently working on dealing out the initial set of cards
02:25:47 <KatieHuber> so I have a [Card] which I've shuffled up, being the deck
02:25:56 <mux> > runState (mapM (\x -> update (+x) >>= return (s+x)) [1..5]) 0
02:25:57 <lambdabot>   Not in scope: `s'
02:26:02 <KatieHuber> and I have a description of what piles the cards should go into
02:26:09 <mux> > runState (mapM (\x -> update (+x) >> get >>= return (s+x)) [1..5]) 0
02:26:10 <KatieHuber> and how many in each pile, and which way up they should be
02:26:10 <lambdabot>   Not in scope: `s'
02:26:11 <mux> err
02:26:18 <mux> > runState (mapM (\x -> update (+x) >> get >>= \s -> return (s+x)) [1..5]) 0
02:26:18 <lambdabot>   Not in scope: `update'
02:27:18 <mux> > runState (mapM (\x -> modify (+x) >> get >>= return) [1..5]) 0
02:27:19 <lambdabot>  ([1,3,6,10,15],15)
02:27:23 <KatieHuber> so the description is like [PileDescription] and the deck is like [Card] and I want to make a [Pile] where each Pile is some function of the particular PileDescription, and the first <some> cards from the deck... and then those cards aren't available for the next pile
02:27:34 <mux> slightly shorter, but not really more beautiful
02:27:53 <mux> oh, wait
02:27:57 <quicksilver> mux: isn't the >>= return superfluous?
02:27:58 <mux> > runState (mapM (\x -> modify (+x) >> get) [1..5]) 0
02:28:00 <lambdabot>  ([1,3,6,10,15],15)
02:28:02 <mux> quicksilver: yes :-)
02:28:18 <mux> I hoped to correct it before someone would notice :-P
02:28:47 <mux> that's still a bit more cumbersome than using mapAccumL
02:28:54 <quicksilver> KatieHuber: yes, so your "state" is the [Card]
02:29:02 <quicksilver> mux: but more generalisable IMO
02:29:04 <KatieHuber> yup
02:29:07 * mux nods
02:29:31 <quicksilver> KatieHuber: and, if you grok the state monad
02:29:52 <quicksilver> KatieHuber: you can write a function PileDescription -> State [Card] [Pile]
02:30:21 <quicksilver> KatieHuber: which says "given a pile description, I can take a [Card] ste, give you a Pile and a new [Card] state"
02:30:28 <quicksilver> might be Pile not [Pile] actually
02:30:36 <KatieHuber> ok...
02:30:43 <osfameron> ooo, card game in haskell?  Sounds like a good learning exercise.
02:30:55 <KatieHuber> ( but note that I *definitely* don't grok the state monad ;) )
02:31:09 <quicksilver> if you don't like to explicitly use state, it's just PileDescription -> [Card] -> ([Card],Pile)
02:31:13 <quicksilver> which is actually the same thing
02:31:19 <quicksilver> with the wrapping type removed
02:31:58 <quicksilver> osfameron: yes, I find games to be very good exercises
02:32:15 <quicksilver> osfameron: I'm currently writing a chess-like game with openGL display and eventualy network play :)
02:32:35 <KatieHuber> and torturing yourself with HOpenGL?
02:32:43 * KatieHuber shudders
02:33:20 <osfameron> quicksilver: cool, I'm starting to write a clone of DopeWars... I'm hoping it will introduce me to situations painful enough to realise that understanding monads would make said sitautions easier...
02:34:25 <quicksilver> HOpenGL is nicer than any other openGL
02:34:38 <quicksilver> because haskell is so much better at abstraction than (say) C++
02:35:39 <nornagon> tbh, hopengl is pretty much a direct binding
02:35:52 <nornagon> with mutable state and all
02:36:14 <KatieHuber> I think I wouldn't have a problem with it if it were a direct binding
02:36:15 <ToRA> preservingMatrix $ do is a lot nicer than push/pop tho
02:36:36 <KatieHuber> I just want it to look like OpenGL :p
02:37:12 <quicksilver> I agree with all five of those comments :)
02:37:25 <quicksilver> it is pretty much a direct binding, but preservingMatrix is much nicer than push and pop
02:37:37 <quicksilver> and the point is with first class actions you can abstract bits so much more nicely
02:37:37 * mux loves doing cairo code with haskell and gtk2hs and the Render monad
02:37:52 <quicksilver> just have mapM gets you streets ahead of C++
02:38:13 <ToRA> i sometimes think it's a shame the GL calls arn't in a seperate monad to IO
02:38:19 <quicksilver> all openGL code in C/C++ is full of stupidly repeated boilerplate which is 99% copy/paste with 1 change
02:38:26 <quicksilver> ToRA: hell yeah
02:38:27 <ToRA> since i want to say, this can do GL code, but not general IO
02:38:41 <quicksilver> ToRA: I don't like the fact that my GL callbacks can modify any IORef they want, for example
02:38:56 <quicksilver> ToRA: I want to *know* that a GL callback can only alter real GL state
02:38:59 <osfameron> could you put them in a different monad ?
02:39:07 <KatieHuber> GL doesn't have callbacks :|
02:39:20 <quicksilver> KatieHuber: ?
02:39:26 <ToRA> i assume glut callbacks
02:39:35 <quicksilver> ah yes, that is what I mean
02:39:38 <KatieHuber> GLUT and GLU do, I guess, but I don't count them as part of GL :)
02:39:44 <quicksilver> idle, display, keyboard/mouse
02:40:21 <KatieHuber> (incidentally, /me is a professional OpenGL programmer, so if you have GL questions as opposed to HOpenGL questions I can probably help)
02:40:36 <quicksilver> cool. If I get stuck again, I'll ask :)
02:41:07 <nornagon> ToRA: preservingMatrix is the same thing, only you don't have to write noLongerPresvingMatrix
02:41:15 <ToRA> yeah
02:41:24 <nornagon> it's not exactly fantastically novel
02:41:49 <nornagon> i think the real advantages lie in the monad manipulations
02:41:58 <nornagon> particularly the list monad
02:42:08 <ToRA> but it's just the way that because you can pass a closure in haskell you get something like a scoping construct for free
02:42:11 <ToRA> (if that makes any sense)
02:43:16 <nornagon> KatieHuber: hi, i want to draw a text grid (like a terminal) in opengl at a decent framerate, how do i do it without using up 40%cpu? >.>
02:43:41 <KatieHuber> depends what CPU you have ;)
02:43:50 <nornagon> ha
02:43:52 <KatieHuber> I'd put the alphabet into a texture
02:43:55 <nornagon> yep
02:44:07 <KatieHuber> then use texture coordinates to select portions of the texture for each quad
02:44:14 <nornagon> yep, already doing that
02:44:26 <KatieHuber> and probably use a VBO to store the vertex data
02:44:37 <nornagon> i tried writing the same thing in python and in C++, and got the same performance
02:44:40 <KatieHuber> are you on an Intel GMA or a real video card?
02:44:45 <nornagon> real video card
02:44:58 <KatieHuber> so VBOs would give a nice performance boost
02:45:02 <nornagon> nvidia geforce 6600 go
02:45:08 <nornagon> vertex buffer?
02:45:13 <KatieHuber> yeah
02:45:24 <nornagon> hmm, is that where you draw all your vertices into a buffer and push the whole lot at the card each frame?
02:45:35 <quicksilver> erm that's really odd
02:45:50 <KatieHuber> that's where you put all your vertices in GL-controlled memory so it can put it in a more efficient place than application memory
02:45:53 <quicksilver> A screen with 80x50 quads, or whatever, drawing from a single texture
02:46:02 <quicksilver> should *not* take 40% CPU on a modern machine/card
02:46:06 <quicksilver> that's really odd
02:46:13 <KatieHuber> no, I'd expect immediate mode to be plenty fast enough really
02:46:23 <quicksilver> what's your definition of 'decent framerate' ?
02:46:31 <quicksilver> are you redisplaying every millisecond or something?
02:46:36 <int-e> 1000 frames per second and more? ;)
02:46:49 <nornagon> quicksilver: try it :)
02:46:53 <nornagon> not that fast, int-e
02:47:15 <KatieHuber> presumably you're on linux, with that video card?
02:47:29 <KatieHuber> so profiling options are kinda limited :p
02:47:34 <nornagon> 10fps
02:47:36 <nornagon> yes, linux
02:47:43 <KatieHuber> I think oprofile is supposed to be OK but I never understood it
02:47:57 <nornagon> well, i wrote the same thing in fast C++
02:48:06 <nornagon> with similar performance
02:48:06 <quicksilver> sounds like you're running software MesaGL to me :P
02:48:13 <nornagon> so it's definitely the GL calls taking up the time
02:48:24 <nornagon> nup, everything's set up fine
02:48:37 <KatieHuber> want to paste the c++ code somewhere?
02:48:40 <quicksilver> have you got the haskell code handy? I'll run it here if it's not too complicated to compile
02:48:58 <nornagon> nah, i didn't write it in haskell :P
02:49:05 <nornagon> i think i've deleted the C++ code, i'll have a look
02:49:17 <nornagon> yeah, gone
02:49:25 <nornagon> and the python is huge and horrid and ugly
02:49:45 <KatieHuber> and I'd have to install goodness-only-knows-what to run it anyway :)
02:49:54 <nornagon> exactly :)
02:50:19 <nornagon> plus it's full of line-of-sight/field-of-view calculations that slow it down to 100%cpu
02:50:57 <KatieHuber> well, the NVidia linux drivers are good, they do a good job of making even atrocious immediate-mode code go fast, so I think there must be something else funny happening
02:51:36 <nornagon> well, my code is pretty normal; i keep a list of display lists for each letter around and call the relevant ones
02:51:53 <KatieHuber> oh, well, there y'go :p
02:51:57 <nornagon> and the DLs are your standard begin, texcoord, vertex, texcoord, vertex, end
02:52:09 <KatieHuber> try getting rid of the display lists
02:52:24 <KatieHuber> and the begin & end per letter
02:52:24 <nornagon> i think i did once, with little difference
02:52:34 <KatieHuber> begin/end are really expensive
02:52:38 <nornagon> hmm
02:52:46 <nornagon> that might be an idea
02:53:00 <KatieHuber> where by "really" I mean "not *really* really" but could be enough to cause problems
02:53:46 <KatieHuber> in general, with OpenGL, your CPU overheard you pay "per draw call"
02:54:00 <KatieHuber> where a draw call is CallList, DrawElements, End, etc.
02:54:25 <KatieHuber> CallList is particularly expensive
02:54:48 <nornagon> anyway, dinner now
02:54:53 <KatieHuber> and DLs are very hard for vendors to optimize due to their flexibility
02:54:58 <nornagon> *nod*
02:55:00 <nornagon> bye!
02:55:06 <KatieHuber> bye
02:55:06 <nornagon> (and thanks)
02:56:28 <dcoutts> mux: want to write a tutorial on gtk2hs/cairo/render?
02:57:00 <KatieHuber> I would also be interested in such a thing... at some point my card game is going to need a GUI :)
02:57:30 <osfameron> meh, make it textmode, that way we can play it at work :-)
02:57:35 <quicksilver> dcoutts: mux was wondering about how to have callbacks in a custom monad. I pointed him to my tunneling article.
02:57:46 <dcoutts> quicksilver: oh good
02:57:55 <dcoutts> g'morning malcolmw
02:58:03 <quicksilver> dcoutts: I think a tidied up version of my tunneling code could be a useful adjunct to these GUI librarys
02:58:22 <malcolmw> @arr
02:58:22 <lambdabot> I'll crush ye barnacles!
02:58:33 <dcoutts> @yarr!
02:58:33 <lambdabot> Arrr!
02:58:58 <dcoutts> quicksilver: we should see some examples converted to that style and see how they look
02:59:05 <dcoutts> quicksilver: you can write a tutorial too :-)
02:59:25 <dcoutts> http://haskell.org/gtk2hs/docs/tutorial/
02:59:26 <lambdabot> Title: Index of /gtk2hs/docs/tutorial
02:59:39 <dcoutts> quicksilver, mux: we're trying to build a collection here ^^
02:59:54 <dcoutts> the glade one is lovely
03:00:02 <dcoutts> oh, reminds me, there's a new intro one
03:00:16 <quicksilver> dcoutts: I've not actually used gtk2hs yet
03:00:24 <quicksilver> dcoutts: I'm playing with GL at the moment :)
03:00:32 <dcoutts> ah right
03:00:32 <quicksilver> dcoutts: but there are callbacks involved here too
03:00:38 <dcoutts> yes
03:00:47 <quicksilver> dcoutts: the general pattern is the same; you hand over your mainloop to something else
03:01:05 <dcoutts> and then have trouble managing program state
03:01:24 <quicksilver> right
03:01:30 <quicksilver> well you get lazy and stick everything in IORefs
03:01:44 <quicksilver> and then you have no guarantee that your callbacks don't modify them when they shouldn't
03:01:58 <quicksilver> really you want the type of the callback to indicate whether or not it can make state changes
03:02:05 <quicksilver> (or even something finer grained)
03:03:15 <ToRA> quicksilver: so i currently pass my callbacks an MVar to (MyMainGameMonad ()), and give them an api of things they can put into it - and then in the mainloop I try and read from that mvar and execute the code contained therein
03:03:38 <ToRA> so i know when in the loop my callbacks are actually happening, and what they can do
03:04:15 <quicksilver> ToRA: yes, that's a nice appraoch
03:04:31 <quicksilver> ToRA: I noted in my tunneling article that you can do realy nice stuff with MVars but I didn't explore it properly
03:05:09 <ToRA> it works quite nicely with glut if you don't enter the glut  mainLoop, but just call mainLoopEvent in your own loop
03:05:25 * mux curses $REAL_WORK that's preventing him to experiment with quicksilver's tunneling stuff right now
03:05:58 <DRMacIver> ToRA: All ready for next week's talk? ;)
03:06:55 <quicksilver> ah, that's a relief.
03:07:02 <quicksilver> I wasn't incorrect for spelling tunnelling with two 'l's
03:07:09 <quicksilver> google made me think I was
03:07:21 <quicksilver> how embarassing it was to be top google hit for a mispelt phrase :)
03:08:22 <ToRA> DRMacIver: not yet
03:09:06 <osfameron> http://tunnelers.wordpress.com/tag/spelling/ # same with traveller/traveler
03:09:08 <lambdabot> Title: Spelling « Writing
03:09:31 <osfameron> good ole English language...
03:09:37 <quicksilver> osfameron: *nod* my dictionary has it as British
03:11:44 <quicksilver> I wonder if the released AMD GPU specs will mean we can soon run haskell on AMD GPUs :)
03:12:40 <ricky_clarkson> "modeling" seems a strange US spelling to me.  I read it as "mode ling".
03:13:15 <ToRA> DRMacIver: tho we have made sure all the gl stuff we want to show works on a mac. which is good, because some of it no longer works under linux :s
03:13:27 <int-e> quicksilver: not with the specs they released so far.
03:13:32 <quicksilver> Yes, a modeling is a small goblin-like creature, slightly smaller but more intelligent than a nibelung
03:14:12 <osfameron> but less tasty than a nibbling
03:16:18 <ricky_clarkson> It turns out that colocation facilities have better security than nuclear power plants.
03:16:24 <ricky_clarkson> (or at least more obvious security)
03:16:29 <KatieHuber> OK, where do I go from here:
03:16:41 <KatieHuber> map State (map splitAt [ 3, 1, 4, 2])
03:16:51 <ricky_clarkson> :t splitAt
03:16:53 <lambdabot> forall a. Int -> [a] -> ([a], [a])
03:17:30 <ricky_clarkson> What is the Int there for?
03:17:37 <KatieHuber> I would like to I dunno, run that on say [1..] to get [[1,2,3],[4],[5,6,7,8],[9,10]]
03:17:57 <KatieHuber> I'm just randomly typing stuff really :|
03:19:25 <quicksilver> :t map SplitAt [3,1,4,2]
03:19:27 <lambdabot> Not in scope: data constructor `SplitAt'
03:19:33 <quicksilver> :t map splitAt [3,1,4,2]
03:19:35 <lambdabot> forall a. [[a] -> ([a], [a])]
03:20:23 <quicksilver> :t map ($[1..])(map splitAt [3,1,4,2])
03:20:25 <lambdabot> forall t. (Num t, Enum t) => [([t], [t])]
03:20:30 <quicksilver> > map ($[1..])(map splitAt [3,1,4,2])
03:20:31 <lambdabot>  [([1,2,3],[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
03:20:38 <quicksilver> > map ($[1..10])(map splitAt [3,1,4,2])
03:20:40 <lambdabot>  [([1,2,3],[4,5,6,7,8,9,10]),([1],[2,3,4,5,6,7,8,9,10]),([1,2,3,4],[5,6,7,8,9...
03:20:41 <therp> is there a way to call visual basic apis (direct or indirect via C wrappers) via Haskell FFI (under ghc windows)? (bash me if that question doesn't make sense, as I have no clue of visual basic interfaces)
03:20:45 <opqdonut> sequence . map splitAt [1,2,3,4] $ [1..10]
03:20:47 <quicksilver> KatieHuber: not quite what you want :)
03:20:48 <opqdonut> > sequence . map splitAt [1,2,3,4] $ [1..10]
03:20:49 <lambdabot>  Couldn't match expected type `a -> [m a1]'
03:20:56 <KatieHuber> not quite, no :p
03:21:05 <opqdonut> hmm not quite yes
03:21:15 <KatieHuber> hence my feeling that the state monad was coming into this somehow
03:21:53 <therp> I don't think state is necessary
03:23:33 <osfameron> I thought state was never necessary, but sometimes convenient ?
03:25:15 <quicksilver> osfameron: that's probably true
03:25:29 <quicksilver> osfameron: much like variable names are never neessary but sometimes convenient
03:25:56 <ricky_clarkson> osfameron: In pure code, perhaps, but when you have to deal with native libs, etc., sometimes state is necessary.
03:26:50 <ndm> and remember that data structures are never necessary, but that its mind-blowingly complicated without them
03:26:54 <osfameron> :D
03:27:09 <osfameron> I guess necessary vs convenient is a fine line...
03:31:34 <gip> Hi. I have to write a lot of s0 <- newIORef undefined, s1 <- newIORef undefined,... In perl, I would use a loop and put s0, s1, s2... in an array. In Haskell?
03:32:44 <ari> gip: In Haskell you call map ;)
03:35:04 <therp> mapM in this case
03:35:39 <gip> > replicate 10 undefined
03:35:40 <lambdabot>  Undefined
03:35:58 <ToRA> mmm
03:36:02 <ToRA> s> runState (mapM (\n -> (gets (splitAt n) >>= (\(h,t) -> (put t >> return h)))) [3,1,2,4]) [1..20]
03:36:05 <ToRA> > runState (mapM (\n -> (gets (splitAt n) >>= (\(h,t) -> (put t >> return h)))) [3,1,2,4]) [1..20]
03:36:06 <lambdabot>  ([[1,2,3],[4],[5,6],[7,8,9,10]],[11,12,13,14,15,16,17,18,19,20])
03:36:07 <ToRA> even
03:36:12 <ToRA> is that what someone wanted?
03:36:19 <gip> > [undefined, undefined]
03:36:20 <lambdabot>  Undefined
03:36:57 <quicksilver> gip: that's actually not true
03:37:05 <quicksilver> gip: that's lambdabot being too clever and getting it wrong
03:37:38 <quicksilver> if it really is undefined each time, you could write:
03:37:59 <quicksilver> [s0,s1,s2,s3....] <- replicateM 10 (newIORef undefined)
03:38:10 <quicksilver> I don't think that newIORef undefined is a good idiom though
03:38:56 <gip> quicksilver: thanks, nice solution..
03:39:28 <quicksilver> and it seems very odd and non-haskelly to have a whole load of similarly named variables of the same type
03:39:40 <quicksilver> I have to question why it isn't a list or possibly an array
03:40:30 <gip> Well, it is not a list because I need named elements (to reuse them later according to some rule)
03:41:31 <quicksilver> you can name the elements of lists :)
03:45:55 <gip> With the index you mean? Yes, but I really need a name to remember what each signal is really. I'm programming the GUI part, that's not easier in haskell than C..
03:49:40 <quicksilver> no, you can name them with a name :)
03:49:54 <Sizur> do we have any i18n module?
03:50:07 <quicksilver> l@[s0,s1,s2,s3,...] <- replicateM 10 (newIORef undefined)
03:50:20 <quicksilver> now l is the whole lists and s0, s1... are the elements
03:50:45 <quicksilver> gip: why are you using 'undefined' ratehr than a sensible initial value?
03:53:07 <gip> quicksilver: wow, I didn't know the l@[] stuff.. I use undefined because the actual value is defined later (by a using writeIORef)
03:53:14 <ivanm> With STM... is that an actual concurrency lib, or is it meant to be used with forkIO (with STM just providing a safer/better way of sharing memory)?
03:56:15 <mauke> STM is just variables
03:57:38 <ivanm> *nod*
03:57:56 <Sizur> variables for scalable modular concurrency
03:58:05 <ivanm> I thought it was a complete concurrency lib, but was wondering how you created new threads and why the simple example used forkIO :s
04:05:35 <hpaste>  Katie pasted "Look, it does what I want, and it's easy... but isn't this built-in somewhere?" at http://hpaste.org/2718
04:06:37 <mauke> a list builder. this says unfoldr to me
04:07:43 <mauke> wait, what's a function called that both deconstructs and constructs a list? some kind of -morphism
04:08:39 <mux> mauke: catamorphism
04:08:39 <ivanm> is that some kind of mapAccum?
04:08:54 <mux> no, wait, that's not this one
04:09:04 <mux> paramorphism I think, or hyolomorphism
04:09:10 <Sizur> monad
04:09:17 <Sizur> :P
04:09:25 <KatieHuber> bah, that's always the answer :p
04:09:29 <ndm> @hoogle mapAccum
04:09:30 <lambdabot> Data.IntMap.mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
04:09:30 <lambdabot> Data.Map.mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
04:09:30 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
04:09:31 <KatieHuber> which monad, and how ;)
04:09:32 <mux> I should re-read the "functional programming with bananas..." paper
04:09:56 <ndm> mux: paramorphism does that, but at each step can view the entire data structure
04:10:15 <ndm> catamorphism is like a paramorphism, but can only view the components at that point
04:11:54 <mauke> :t snd $ mapAccumL (\z x -> (snd &&& fst) $ splitAt x z) [1..] [3,1,4,2]
04:11:56 <lambdabot> forall a. (Num a, Enum a) => [[a]]
04:12:01 <mauke> > snd $ mapAccumL (\z x -> (snd &&& fst) $ splitAt x z) [1..] [3,1,4,2]
04:12:03 <lambdabot>  [[1,2,3],[4],[5,6,7,8],[9,10]]
04:12:20 <mauke> @. pl djinn (a, b) -> (b, a)
04:12:21 <lambdabot> f = uncurry (flip (,))
04:21:09 <KatieHuber> I'm having trouble turning this into something with the same signature as my "run" :|
04:21:18 <masak> @seen lambdabot
04:21:18 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc and #darcs
04:21:47 <masak> @tell dons seems lambdabot has fallen out of #bioclipse...
04:21:47 <lambdabot> Consider it noted.
04:21:55 <mauke> :t \f -> snd $ mapAccumL (\z x -> (snd &&& fst) $ f x z)
04:21:57 <lambdabot>     Couldn't match expected type `(a, b)'
04:21:57 <lambdabot>            against inferred type `b1 -> [x] -> (b1, [a1])'
04:22:13 <mauke> :t \f -> (snd .) . mapAccumL (\z x -> (snd &&& fst) $ f x z)
04:22:15 <lambdabot> forall x a b. (x -> b -> (a, b)) -> b -> [x] -> [a]
04:22:32 <KatieHuber> thanks :)
04:23:08 <mauke> @pl \f -> (snd .) . mapAccumL (\z x -> (snd &&& fst) $ f x z)
04:23:09 <lambdabot> ((snd .) .) . mapAccumL . (((snd &&& fst) .) .) . flip
04:24:01 <KatieHuber> having got there at last I'm not at all sure it's an improvement ^_^
04:25:05 <mauke> :t \f s xs -> snd $ mapAccumL f s xs
04:25:07 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> [y]
04:25:40 <mauke> but you'll have to flip arguments to use it with splitAt
04:32:00 <mux> ndm: ok, thanks!
04:33:15 <KatieHuber> mauke: thanks for the help, that is much cleaner :)
04:40:51 <Mitar> how can i match a pattern on the subset possibilities of the data type? for example data Foo = One | Two | Three | Four and I would like to match One and Two
04:45:07 <lemmih> Mitar: There's no special way of doing that.
04:45:34 <puusorsa> for both cases something where something = ...
04:45:45 <puusorsa> does that make any sense? probably not. don't listen to me.
04:45:55 <ibid> it's close
04:46:13 <ibid> foo One = doOneAndTwo ; foo Two = doOneAndTwo ; ...
04:47:10 <ibid> can't use where, unfortunately, as its scope includes only one alternative
04:47:26 <mauke> foo x | x == One || x == Two = ...
04:47:39 <ibid> works if Foo is in Eq
04:48:02 <mauke> ... deriving (Eq, Ord, Show, Enum, Bounded)
04:48:13 <ibid> not always possible :)
04:49:05 <puusorsa> foo x = case x of One -> oneandtwo; Two -> oneandtwo; where oneandtwo = ... ?
04:49:21 <opqdonut> ibid: why is it not always possible?
04:49:37 <opqdonut> if we're talking about Enum-type data declarations (no args to constructors)
04:49:53 <puusorsa> oh well i'm complete newbie so probably not making anysense
04:50:03 <tuxplorer> I want to setup a versioning system. I'm the only person who would handle the code. But I want different versions of it to remain, so that whenever I get a working version, I commit it and proceed, so that I can revert back to the previous checkpoint. Which would help me in this aspect? would darcs be helpful for this? or something even simpler? I don't need any concurrency support.. just versioning.. I use emacs for all Haskell programm
04:50:18 * EvilTerran wonders if it'd be possible to make a magic TH function that utilised GHC's existing derivations
04:50:27 <puusorsa> darcs is good
04:50:30 <opqdonut> tuxplorer: practically any vcs will let you do that
04:50:37 <opqdonut> you can always check out a previous version
04:50:59 <EvilTerran> so you could $(derive ''Foo ''Enum) or something after-the-fact
04:51:06 <ibid> opqdonut: because we're not always talking about enumerations :)
04:51:36 <tuxplorer> Thanks opqdonut puusorsa. Which is easiest to setup?
04:52:02 <ibid> darcs is very simple
04:52:04 <opqdonut> ibid: yeah i realize the example he pasted might be simplified :)
04:52:05 <puusorsa> i'd use darcs
04:52:08 <quicksilver> mauke: if Foo is, in fact, in Eq then foo x | x `elem` [One,Two] is arguably prettier and definitely more scalable
04:52:14 <puusorsa> it's the one i dislike the least
04:52:16 <opqdonut> i'd probably use git but darcs is simpler :)
04:52:32 <tuxplorer> Thanks ibid and puusorsa will try darcs.
04:52:37 <quicksilver> however it is definitely a missing feature (shared body between multiple equations)
04:52:42 <EvilTerran> "arguably" ;]
04:52:53 <quicksilver> I pointed it out once and SPJ said there is no good reason not to have it
04:53:00 <quicksilver> it's just tthat we don't
04:53:07 <EvilTerran> how would you write it?
04:53:29 <quicksilver> my suggestion was empty body after the =
04:53:31 <quicksilver> I think
04:53:36 <quicksilver> since that has no current meaning
04:53:42 <ibid> opqdonut: also, it isn't always so that the Eq instance does the right thing here. for example, if you have data Formula = ... | Forall String Formula | Exists String Formula, there are situations where you want to handle Forall and Exists identically
04:54:15 <EvilTerran> so fact 0 =; fact 1 = 1; fact n..., or something?
04:54:18 <opqdonut> ibid: ok, true
04:54:23 <quicksilver> ibid: yes, sometimes you want an enumeration class which contains the names of the constructors
04:54:56 <quicksilver> ibid: I.e. for data Formula you also have data CFormula = Forall | Exists deriving Enum
04:55:02 <Sizur> but if you need to have a common body, doesnt that imply that your datatype needs to have a common ancestor?
04:55:11 <quicksilver> ibid: I suggested that to ndm once as a possible derive rule
04:55:17 <quicksilver> EvilTerran: yes
04:55:23 <EvilTerran> wouldn't there be a problem with pattern-matching?
04:55:39 <EvilTerran> foo xs [] = foo [] ys = ... -- okay, now what?
04:55:39 <ibid> quicksilver: i haven't found that very useful :)
04:55:42 <quicksilver> you can't really re-use the same name in the same module
04:55:54 <quicksilver> but they could be in different modules, or namespaced with a 'C' or something
04:56:15 <quicksilver> EvilTerran: yes they'd have to bind the same set of names
04:56:24 <quicksilver> EvilTerran: (at the same types)
04:56:41 <EvilTerran> and those names'd be bound to the same types, which could be munged into the inference, i guess
04:56:45 <quicksilver> right
04:56:56 <Sizur> data OneTwo = One | Two; data Data = OneTwo | Three;
04:57:19 <EvilTerran> (foo xs [] = foo [] xs = xs) forces (typeOf xs == typeOf ys) kinda thing
04:57:31 <quicksilver> or, data Data = One | Two | Three; oneTwo One = True; oneTwo Two = True; oneTwo _ = False
04:57:36 <ibid> Sizur: that's not always convenient :)
04:57:47 <quicksilver> then you can have f n | oneTwo n = ...
04:57:56 <EvilTerran> views!
04:58:27 <Mitar> is it possible to use some kind of a state monad to store some data and then derivate Eq class which would use that stored data to determine equality?
04:58:40 <ibid> no
04:58:45 <ibid> Eq is stateless
04:59:10 <ibid> but you can of course define a StatefulEq :)
04:59:46 <Mitar> (i am making a semantic analyzer for an abstract tree and I would like to store declared types in a state and then use Eq between type data to check if they are equal (deep equality))
05:00:12 <quicksilver> well you can use Eq on the actual types, clearly
05:00:21 <EvilTerran> liftM2 (==)?
05:00:22 <quicksilver> you just need a function to fetch the types out of your symbol table
05:00:42 <quicksilver> in the simplest case liftM2 (==) (get "foo") (get "bar")
05:00:44 <quicksilver> might be enough
05:01:07 <Mitar> yes, but it is ugly to write everythim: (corceTo env t1 t2) when t1 == t2 would be enough
05:01:55 <Mitar> so i have to go all structure of types and check if they are the same, if there is some idetifier i have to get it from env
05:02:06 <EvilTerran> (=$=) = coerceTo env?
05:03:11 <oklopol> > let (%%%%%) = (+) in 5 %%%%% 2
05:03:13 <lambdabot>  7
05:03:24 <oklopol> > let (-) = (+) in 5 - 2
05:03:26 <lambdabot>  7
05:03:36 <oklopol> > let (-) = (+); (+) = (-) in 5 + 2
05:03:37 <lambdabot>  Exception: <<loop>>
05:03:41 <oklopol> ah of course
05:04:17 <oklopol> > let a = (+); (-) = (+); (-) = a in 5 - 2
05:04:17 <lambdabot>      Conflicting definitions for `-'
05:04:17 <lambdabot>     In the binding group for: a, -, -
05:04:22 <oklopol> :P
05:04:37 <quicksilver> > let (-) = (+) in let (+) = (Prelude.-) in 5 + 2
05:04:38 <lambdabot>  3
05:04:38 <oklopol> is there a way to swap them?
05:04:42 <oklopol> oh
05:04:43 <lemmih> > let (-) = (Prelude.+); (+) = (Prelude.-) in 5 + 2 - 10
05:04:44 <Mitar> but env is not global, but a parameter to recursive call of the function ..
05:04:45 <lambdabot>  13
05:04:49 <nornagon> > let a = (-) in let { (+) = (-); (-) = a } in 1 + 2
05:04:49 <EvilTerran> > case ((+),(-)) of ((-),(+)) -> (1 + 2, 1 - 2)
05:04:51 <lambdabot>  (-1,3)
05:04:52 <lambdabot>  -1
05:04:55 <Mitar> i am talking nonsense now, thanks :-)
05:04:58 <quicksilver> Mitar: that's ok, make =$= a local definition
05:05:01 <nornagon> > let a = (-) in let { (+) = (-); (-) = a } in 1 - 2
05:05:03 <lambdabot>  -1
05:05:28 <oklopol> cool
05:05:33 <oklopol> haskell owns
05:07:05 <Mitar> quicksilver, yes, i figured :-)
05:07:10 <Mitar> thanks
05:07:48 <Mitar> ahh, i noticed why this is not possible
05:08:25 <Mitar> i have many many defintions (for different possible combinations of Expr type) because of the patterns and quards
05:08:46 <Mitar> i would have to define this (=$=) again and again
05:09:28 <quicksilver> Mitar: but there is only one env
05:09:42 <Mitar> no, it is a parameter ...
05:09:43 <quicksilver> Mitar: so there should be a scope in which env is visible that you can use to define =$=
05:09:54 <Mitar> i will paste, sec
05:09:56 <quicksilver> Mitar: however I think you are complaining about something which is, in fact, a non-problem
05:10:08 <quicksilver> it's entirely appropriate to mention the env in the comparison
05:10:23 <quicksilver> it reminds you that you cannot compare t1 and t2 in isolation, but only in the context of an environment :P
05:11:47 <hpaste>  Mitar pasted "env" at http://hpaste.org/2720
05:13:46 <quicksilver> Mitar: you write it like this:
05:14:36 <quicksilver> typecheck te ve e = typecheck' te ve e
05:14:55 <quicksilver> where (=$=) t t' = corceTo env t t'
05:15:07 <quicksilver>   typecheck' ..... (your current definitions here)
05:15:25 <quicksilver> erm where I rwote "env" I should have written 'te' or 've' or both
05:15:30 <quicksilver> I'm not sure which env you're after
05:15:34 <Mitar> both :-)
05:15:56 <Mitar> but the problem is that in typecheck' te and ve changes ...
05:16:14 <Mitar> hmm
05:16:23 <Mitar> oh, i understand ...
05:16:29 <Mitar> the best would be
05:16:36 <Mitar> typecheck te ve e = typecheck' e
05:16:44 <quicksilver> you can do it that way if you like
05:16:51 <quicksilver> the point is, there's plenty you can do with scopes :)
05:16:55 <Mitar> where (=$=) t t' = corceTo te ve t t'
05:17:14 <Mitar>   typecheck' e = ..
05:17:31 <EvilTerran> is "te" "type environment", and "ve" "variable/value environment"?
05:17:35 <Mitar> yes
05:17:43 <EvilTerran> you could have a different operator for each
05:18:28 <EvilTerran> (=:=) = coerceTo te; (=$=) = coerceTo ve -- or something
05:21:04 <quicksilver> EvilTerran: well, types may only need the type context
05:21:12 <quicksilver> EvilTerran: but values need the type context as well as the value context
05:21:22 <EvilTerran> okay. i haven't actually looked at the paste...
05:21:33 <quicksilver> well that's the general case in type inference
05:24:27 <EvilTerran> true
05:28:52 <Mitar> thanks to all :-)
05:30:58 <gip> @index cycleM
05:30:58 <lambdabot> bzzt
05:31:03 <gip> @index cycle
05:31:03 <lambdabot> Data.List, Prelude
05:31:24 <quicksilver> gip: infinite stuff in monads tends not to be safe :)
05:31:32 <quicksilver> gip: that's probably why there isn't a cycleM
05:31:45 <oerjan> sequence_ . cycle
05:32:09 <quicksilver> well sequence . cycle would be more natural
05:32:16 <quicksilver> that would at least have a *chance* of being productive
05:32:26 <oerjan> well, yeah, in some monads
05:32:33 <quicksilver> but many interesting monads have at least some kind of "strictness in side-effects"
05:32:36 <int-e> I missed partitionM a while ago.
05:32:42 <gip> I see:) So I cannot write [s0, s1,..., s9] <- replicateM 100 (whatever)  ?
05:33:04 <gip> I thought it would just compute the list 10 times because of lazyness?
05:33:23 <oerjan> nope, because monad executions are not always lazy
05:33:27 <int-e> it depends on the monad
05:33:29 <oerjan> especially IO
05:33:45 * EvilTerran still thinks takeWhileM is a particularly notable omission
05:33:49 <quicksilver> also not that, even if it did work, it would throw an exception on the 10th element
05:33:55 <quicksilver> erm 11th element
05:34:13 <quicksilver> > let [s0,s1,s2] = [1..] in s0
05:34:17 <lambdabot>   Irrefutable pattern failed for pattern [s0, s1, s2]
05:34:30 <quicksilver> you are promising that list has only 10 (or 3) elements
05:34:37 <int-e> > let (s0:s1:s2:_) = [1..] in s0 -- but this works
05:34:38 <lambdabot>  1
05:34:44 <quicksilver> however, what you can certainly do safely is something like this:
05:35:02 <oerjan> well _that_ could be fixed with a liftM (take 10)
05:35:07 <quicksilver> [s0,s1,....,s9] <- sequence . take 10 $ ( ... infinite list here .. )
05:35:14 <mux> quicksilver: I'm thinking it would probably be valuable to have your InterleavableIO type-class in gtk2hs or, even better, in some hackage module
05:35:21 * EvilTerran wants "takeWhileM (not.null) (repeat getLine)", say
05:35:31 <quicksilver> mux: I agree
05:35:42 <oerjan> EvilTerran: yeah, i've noticed that too
05:35:47 <quicksilver> mux: I was hoping that my posting would stimulate discussion and/or improvement
05:35:49 <gip> mux: agreed, I'm actually using gtk2hs :)
05:35:49 <EvilTerran> @paste
05:35:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:35:58 <quicksilver> mux: it didn't. it stimulated silence.
05:36:01 <hpaste>  EvilTerran pasted "takeWhileM" at http://hpaste.org/2721
05:36:04 <int-e> EvilTerran: yes, that omission is strange. (even though it wouldn't be lazy in IO)
05:36:06 <mux> quicksilver: I'm also this >< close to suggesting having an operator for constructing callbacks in a less noisy manner
05:36:22 <quicksilver> mux: I suspect it's just not an idiom you recognise until you've tried to do it :)
05:36:31 <oerjan> int-e: sure it would
05:36:36 <EvilTerran> int-e, as i've written it there, it's lazy in IO; if i'm understanding you correctly, anyway.
05:36:40 <oerjan> well, not lazy but halting
05:36:50 <mux> yeah, it's fairly specific to coding with libraries that are extensively in IO
05:37:08 <int-e> EvilTerran: lazy in the evil getContents sense.
05:37:19 <EvilTerran> oh, right. well, that's evil, so i'm cool with that.
05:37:44 <EvilTerran> ...maybe that (a -> Bool) parameter should be (a -> m Bool); i've never needed that myself, but it *would* be more general
05:37:48 <quicksilver> mux: also, for all that people talk about writing code in custom monads
05:37:58 <quicksilver> mux: I don't think people have much experience in combining different custom monads
05:38:09 <quicksilver> mux: how do you make custom monads into reusable components?
05:38:19 <quicksilver> mux: under what circumstances can you lift one through another?
05:38:29 <quicksilver> mux: I don't think these questions have been explored much
05:38:35 * EvilTerran would quite like some kind of syntactic sugar for "withFoo $ \x -> do"
05:38:42 <EvilTerran> or whatever
05:38:43 <quicksilver> mux: did you read twanvl's blog post about "functional references"
05:38:52 <mux> quicksilver: yep, did so yesterday
05:39:06 <quicksilver> mux: that is relevant, insofar as he shows how to compose them
05:39:13 <oerjan> EvilTerran: i think that _is_ the syntactic sugar
05:39:17 <quicksilver> mux: and that's how you pull a small state monad out of a big one
05:39:32 <twanvl> the idea is not mine
05:39:35 <quicksilver> mux: and gives you a hint on how you can compbine two state monads into one bigger one etc
05:40:05 <quicksilver> mux: something else I didn't explore, but is obviously a good thing, is lifting a reader action into a state monad
05:40:09 <mux> quicksilver: in any case, you greatly rekindled my desire of going on with my gtk2hs code :)
05:40:18 <dcoutts> @arr!
05:40:18 <lambdabot> Arrr!
05:40:19 <EvilTerran> writing "\x -> do { ... }" as "do x -> { ... }" or something
05:40:24 <quicksilver> mux: then you can indicate in a type system that a particular action can't modify the state
05:40:34 <quicksilver> mux: (by making it reader not state)
05:40:36 <mux> I was mightily annoyed to have to abandon the oh-so-convenient State monad
05:40:39 <oerjan> dcoutts: just 6 days left...
05:40:44 <EvilTerran> seeing as "\x->do..." is quite a common idiom
05:40:55 <mux> quicksilver: hmm, but couldn't you already do that with ReaderT State?
05:40:56 <dcoutts> oerjan: 6 days left before what?
05:41:02 <EvilTerran> then you'd get forM [1..10] do x -> ...
05:41:11 <mux> quicksilver: providing only specific primitives to restrict the use of any of those?
05:41:20 <quicksilver> mux: I'm talking about reading the same state
05:41:26 <int-e> is there a branch of Data.Binary out there that works with ghc head?
05:41:27 <mux> oh
05:41:28 <quicksilver> mux: not have a read-only portion and a state portion
05:41:29 <EvilTerran> oerjan, do you see?
05:41:30 <mux> gotcha
05:41:36 <oerjan> http://www.talklikeapirate.com/
05:41:36 <quicksilver> mux: but having an action which only reads from the state portion
05:41:37 <lambdabot> Title: Talk Like A Pirate Day - September 19
05:41:46 <dcoutts> int-e: not yet
05:41:51 <dcoutts> oerjan: ooh, that
05:41:53 <dcoutts> @yarr!
05:41:53 <lambdabot> Avast!
05:41:54 <ToRA> quicksilver: do you have a url for the blog post?
05:42:09 <quicksilver> readerToState :: MonadReader m r, MonadState n r => m a -> n a
05:42:10 <quicksilver> I think
05:42:10 * mux ponders what a good module name for quicksilver's code would be
05:42:14 <quicksilver> ToRA: one moment
05:42:17 <[TWiSTED]> ive got a list of tuples ie [(a,b)]  and i want to apply the function words to just a, how do i go about doing that?
05:42:23 <mux> Conrol.Monad.Interleavable ?
05:42:34 <quicksilver> [TWiSTED]: map (f . fst)
05:42:35 <gip> How do I test that a value is not 'undefined' ?
05:42:37 <mux> (without the obvious typo :)
05:42:43 <quicksilver> [TWiSTED]: well map (words . first)
05:42:45 <quicksilver> gip: you don't
05:42:45 <ToRA> @type fst . unzip
05:42:53 <lambdabot> forall a b. [(a, b)] -> [a]
05:42:55 <quicksilver> gip: that's why I tried to tell you not to use undefined
05:42:56 <[TWiSTED]> thanks
05:42:58 <quicksilver> gip: (part of the reason)
05:43:19 <quicksilver> ToRA: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
05:43:22 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
05:43:24 <ToRA> quicksilver: ta
05:43:36 <gip> quicksilver: I see:) But I think you don't have a choice when using gtk2hs
05:43:40 <mux> quicksilver: I think that using MVars, you could probably end up with something similar to your code, but which would be thread-safe
05:43:44 <quicksilver> gip: I'm quite sure you do :)
05:43:50 <quicksilver> gip: use the correct type for the IORef
05:43:53 <mux> (and less efficient)
05:43:58 <quicksilver> gip: if you think that sometimes it might be 'empty'
05:44:03 <quicksilver> gip: then use a Maybe type
05:44:10 <quicksilver> mux: yes, I make that comment at the end of the post
05:44:14 <quicksilver> mux: it would be very nifty
05:44:16 <mux> d'oh
05:44:23 <mux> sorry for not reading to the end yet :D
05:44:25 <quicksilver> mux: shows you how to 'fork' a StateT monad, too
05:44:31 <quicksilver> mux: which you otherwise can't do
05:44:38 <oerjan> EvilTerran: you miss a $ before the do.  all you are saving is a \
05:44:46 <ndm> quicksilver: patches welcome :)
05:44:51 <EvilTerran> meh.
05:44:57 <quicksilver> ndm: to which?
05:44:58 <EvilTerran> i still find it odd that that $ is necessary.
05:45:12 <EvilTerran> > fromJust do return 1
05:45:13 <lambdabot>  Parse error
05:45:13 <oerjan> although someone did propose to make the $'s optional, that would apply to the original too
05:45:23 <ndm> quicksilver: type classes and stuff
05:45:28 <matthew_-> @seen KatieHuber
05:45:28 <lambdabot> I saw KatieHuber leaving #haskell 42m 58s ago, and .
05:45:47 <EvilTerran> i guess. i'm just trying to make the function implicit so it looks more like an imperative language ;]
05:46:15 <mux> quicksilver: do you have no intent to cabal-ize your code for now?
05:46:53 <quicksilver> ndm: I don't know what the right answer is yet :)
05:47:16 <quicksilver> mux: I'm not plannign to right now. Until I've used it in a real program I won't know if I have the API right
05:47:30 <quicksilver> mux: I might try out some of the techniques in my opengl program I'm writing
05:47:45 <quicksilver> mux: if you think you can get it right, you have my blessing to go ahead :)
05:49:20 <mux> quicksilver: I'll use it in my code and will see how things go :)
05:49:33 <oerjan> EvilTerran: before long you would want a general solution for moving things into lambdas, say whatever >>=
05:49:48 <oerjan> er, now that one actually is supported
05:49:50 <oerjan> :D
05:50:02 <quicksilver> oerjan: clever :)
05:50:11 <EvilTerran> IDGI
05:50:25 <EvilTerran> you still need either an explicit function or pointsfree
05:50:27 <oerjan> actually it was my foot cleverly entering my mouth when i pressed enter
05:50:55 <EvilTerran> or do{}, i guess, but that doesn't quite work here.
05:51:13 <quicksilver> foot-in-keyboard?
05:51:24 * EvilTerran was trying to come up with something akin to the "case of"-as-lambda proposal
05:51:37 <quicksilver> ndm: curiously, noticing problems is several orders of magnitude easier than noticing answers
05:51:46 <quicksilver> I might call this the 'Kibitz Syndrome'
05:52:03 <EvilTerran> ((case of [] -> ...; x:xs -> ...) :: [a] -> whatever)
05:52:07 <pejo> quicksilver, but have you understood the problem if you don't know the answer?
05:52:21 <[TWiSTED]> hm that map (words . first) isnt quite working, ive first used a list comprehension to generate the list of tuples
05:53:07 <quicksilver> [TWiSTED]: fst not first
05:53:11 <oerjan> [TWiSTED]: it should be first words
05:53:17 <quicksilver> [TWiSTED]: something quite different
05:53:29 <[TWiSTED]> ok
05:53:30 <oerjan> (and requires Control.Arrow)
05:53:52 <oerjan> [TWiSTED]: fst or first depends on whether you want to keep the b part
05:53:55 <quicksilver> > map (words . fst) [("foo bar baz",1),("apple orange pear",2)]
05:54:04 <lambdabot>  [["foo","bar","baz"],["apple","orange","pear"]]
05:54:07 <quicksilver> > map (first words) [("foo bar baz",1),("apple orange pear",2)]
05:54:08 <lambdabot>  [(["foo","bar","baz"],1),(["apple","orange","pear"],2)]
05:54:16 <quicksilver> almost, but not quite, the same
05:54:24 <quicksilver> I assume words . fst is what you wanted
05:54:29 <quicksilver> but maybe it was first words :)
05:54:41 <[TWiSTED]> yeh i want to keep the b part
05:54:52 <quicksilver> then you want map (first words)
05:54:58 <quicksilver> and you import Control.Arrow.
05:55:00 <[TWiSTED]> ah thats not quite the output i require
05:55:03 <quicksilver> :)
05:55:30 <[TWiSTED]> it should be [("foo",1),("bar",1),("baz",1),("apple",2), etc]
05:55:40 <hpaste>  Mitar pasted "compile error" at http://hpaste.org/2722
05:56:06 <Mitar> any solution?
05:56:13 <oerjan> perhaps a list comprehension is cleaner
05:56:23 <ToRA> [TWiSTED]: what's the type sig of the function you want?
05:56:28 <EvilTerran> Mitar, ah... equality doesn't work like that
05:56:34 <oerjan> [(w,b) | (a,b) <- l, w <- words a]
05:56:37 <[TWiSTED]> yeh
05:56:41 <Mitar> i notice :-)
05:56:42 <quicksilver> that looks definitely like a case for a list comprehension
05:56:45 <quicksilver> oerjan: has it
05:56:50 <[TWiSTED]> ah ok
05:57:36 <quicksilver> Mitar: you can actually use a GHC extension, pattern guards, for that
05:57:42 <quicksilver> Mitar: I'm not sure it's the best answer though
05:57:45 <hpaste>  EvilTerran annotated "compile error" with "(no title)" at http://hpaste.org/2722#a1
05:57:55 <ndm> quicksilver: its not just a GHC extension, its also in Yhc and nhc now
05:58:20 <hpaste>  EvilTerran annotated "compile error" with "better, actually" at http://hpaste.org/2722#a2
05:58:23 <ndm> I've also been using a typeclass, Eq1 recently
05:58:26 <quicksilver> ndm: ah that's right. excellent news.
05:58:46 <ndm> x `eq1` TyRecord undefined     would do the right thing
05:58:49 <Mitar> i make a case ... of test :-)
05:59:05 <EvilTerran> Mitar, there's also something called pattern guards that might do what you want, but this is H98, and those're an extension
05:59:10 <quicksilver> ndm: just testing top-level constructor?
05:59:11 <EvilTerran> @wiki PatternGuards
05:59:11 <lambdabot> http://www.haskell.org/haskellwiki/PatternGuards
05:59:14 <ndm> quicksilver: yes
05:59:22 <quicksilver> ndm: that's interesting
05:59:31 <EvilTerran> @wiki Pattern guard
05:59:31 <lambdabot> http://www.haskell.org/haskellwiki/Pattern_guard
05:59:34 <quicksilver> ndm: that's isomorphic to the thign I was talking to you about some months back
05:59:36 <EvilTerran> even
05:59:52 <quicksilver> ndm: about associating to each type the (enumerated) type of its top-level constructors
05:59:53 <ndm> quicksilver: well, it actually tests all up to subexpressions of the same type in my current implementation
06:00:06 <quicksilver> ah, well that's a bit different :)
06:00:15 <ndm> quicksilver: i think Derive has a liberalised Enum deriving, where toEnum x == toEnum y means the constructors are equal
06:00:23 * quicksilver nods
06:00:31 <ndm> depending on the data type, it can be awfully close
06:00:32 <quicksilver> I think you could argue that's a perversion of enum though
06:00:37 <ndm> it is :)
06:00:37 <quicksilver> and it would be better to call it something else
06:00:48 <quicksilver> and that "Something else" is what I'm talking about
06:01:06 <ndm> I'd like to add eq1 and eqSub to the Eq class
06:01:07 <quicksilver> there is also (takeWhile /= " ") . show
06:01:15 <quicksilver> if the type can derive Show :)
06:01:35 <ndm> [1] == [] in that logic
06:02:04 <ndm> something needs to be done about "shallow Eq", and i'd love someone to do it
06:02:27 <ndm> i've been using uniplate and replacing all children with some default term
06:02:28 <oerjan> ndm: huh? [1] and [] don't have the same constructor
06:02:47 <EvilTerran> stealth (:)!
06:02:59 <ndm> oerjan: but under quicksilver's scheme [] [1] [2] will give the wrong answer for something
06:03:18 <quicksilver> yup
06:03:25 <quicksilver> my scheme doesn't work for cooky syntax
06:03:27 <quicksilver> like lists :)
06:03:36 <quicksilver> it only works for nice regular algebraic datatype syntax
06:03:40 <quicksilver> it's a hack anyway
06:04:11 <quicksilver> incidentally, I think "show [1,2,3,4]" should possibly be "1:2:3:4:[]"
06:04:17 <quicksilver> but that wouldn't actually solve the problem
06:04:21 <quicksilver> (no infix support in my hack)
06:08:48 <ndm> yep
06:08:56 <ndm> but you could do it properly with Data.Generics
06:09:30 <ndm> i am tempted to give implementations of all classes in terms of Data.Generics, its certainly possible
06:10:39 <EvilTerran> (~~) = (==) `on` toConstr?
06:12:10 <quicksilver> > toConstr (Just 3)
06:12:12 <lambdabot>   Not in scope: `toConstr'
06:12:16 <quicksilver> this is odd
06:12:22 <ndm> EvilTerran: yes, i think so
06:12:24 <quicksilver> Data.Generics> toConstr (Just 3) == toConstr [3]
06:12:26 <quicksilver> True
06:12:35 <oerjan> > [1,3..] -- no, this is odd
06:12:37 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
06:12:42 <EvilTerran> um
06:12:59 <quicksilver> toConstr (Just 3) is Just, and toConstr [3] is (:)
06:13:03 <quicksilver> but they're equal :)
06:13:14 <quicksilver> because it just compares by constructor number, I think?
06:13:32 <Japsu> quicksilver: they're both "return 3"
06:13:47 <Japsu> quicksilver: "Just 3" is in the Maybe monad, "[3]" in the List monad
06:13:57 <int-e> dcoutts: ok. got it to work (but doing this while preserving backward compatibility will be ugly)
06:13:58 <oerjan> Japsu: no way that is relevant
06:14:02 <Japsu> ok
06:14:06 <Japsu> just a guess
06:14:31 <dcoutts> int-e: binary you mean?
06:14:44 <quicksilver> it's only safe to compare 'Constr' if they relate to the same type
06:14:51 <EvilTerran> (~~) `on` (showConstr.toConstr) works
06:14:52 <quicksilver> btu that isn't really expressed in the type
06:15:10 <quicksilver> arguably 'Constr' should be parametric
06:15:13 <EvilTerran> altho then we're back to tossing strings around
06:15:13 <quicksilver> 'Constr a'
06:15:45 <EvilTerran> (~~) :: Data a => a -> a -> Bool; (~~) = (==) `on` toConstr; -- this is safe
06:15:45 <quicksilver> EvilTerran: that doesn't work if you have module Foo.Just and module Bar.Just
06:15:47 <quicksilver> EvilTerran: I think
06:15:54 <quicksilver> EvilTerran: ah yes, good point
06:16:23 <quicksilver> EvilTerran: I also think the Eq instance for Constr does seem a bit broken :)
06:16:43 <EvilTerran> yeah. as you said, there's argument for Constr being parameterised on type
06:16:53 <EvilTerran> altho that might partly defeat the object of Data.Generics
06:17:04 <quicksilver> EvilTerran: or just have the Eq instance take 'datatype' into account
06:17:15 <quicksilver> EvilTerran: the information is in there, according to :info in my ghc
06:17:20 <EvilTerran> true
06:17:38 <EvilTerran> that *is* weird, then
06:17:44 <EvilTerran> bug report time?
06:18:50 <smashor> hello
06:18:51 * EvilTerran would think a == b ==> show a == show b, for starters
06:18:52 <int-e> dcoutts: yeah
06:19:08 <EvilTerran> or even s/show/f/g
06:19:27 <quicksilver> EvilTerran: yes, you'd hope it was some kind of observable equivalent
06:19:37 <EvilTerran> @where SYB
06:19:37 <lambdabot> I know nothing about syb.
06:20:51 <pejo> @where+ SYB http://www.cs.vu.nl/boilerplate
06:20:51 <lambdabot> Done.
06:22:29 <smashor> I'm a newbee and am learning Haskell with a text book about Haskell. There is one exercise I cannot cope with: one shall write a function "shortestAndLargest" with type: shortestAndLargest :: [String] -> (String, String) . The result shall be the shortest and longest string in the list of Strings. Could you give me any hints how to solve that problem, I think this is a simple one for you. Please only hints, not implementations!
06:23:07 <lemmih> smashor: Sort the strings by length?
06:23:35 <smashor> lemmih: thats a starting point. will think about it, thanks!
06:23:40 <quicksilver> smashor: work through the lists keeping a record of shortest-so-far and longest-so-far ?
06:25:13 <smashor> quicksilver: ok, two approaches, we'll see if I got it. Thanks, too.
06:25:50 <EvilTerran> look at the Prelude functions 'til it becomes trivial? ;)
06:26:05 <EvilTerran> (i find this is a very common approach for me)
06:27:29 <quicksilver> EvilTerran: I'm not sure that's the correct approach when solving an exercise though
06:27:34 * lemmih is etching to write the pretty one-liner.
06:27:52 <EvilTerran> i guess that's true
06:27:52 <quicksilver> EvilTerran: I presume the author of the book is viewing it as an exercise in explicit recursion
06:28:36 <EvilTerran> in that case, the sort version wouldn't really be appropriate either
06:28:59 * EvilTerran is itching to write the efficient but unintelligable one-liner
06:29:46 <puusorsa> we need obfuscated haskell contest!
06:30:11 <smashor> well, nice to amuse you with my question :D
06:30:58 <EvilTerran> i think the sort() approach would win golf on this one easily
06:31:10 <smashor> and yes, i think the exercise shall train recursion
06:32:43 <swiert> smashor: you could also try to write two functions: shortest and longest, and combine them somehow.
06:33:44 <quicksilver> or you could try to write a function "best" which takes a parameter to indicate what "metric" it should use to decide bestness
06:33:56 <quicksilver> and then run it twice, once on 'shortness' and once on 'longness'
06:35:05 <smashor> problem is i have the C solution in mind. I loop over all elements in the list, keep in mind the longest one, and update it if necessary.
06:35:46 <smashor> quicksilver: how do i "keep a record of shortest-so-far" ?
06:35:57 <quicksilver> smashor: normally as a parameter to the function
06:36:04 <quicksilver> smashor: which calls itself, either again with that same parameter
06:36:08 <quicksilver> smashor: or with the new shortest
06:36:23 <smashor> ok, than i need kind of an auxiliary function
06:36:45 <quicksilver> yes, you will
06:38:07 <therp> smashor: you could either have an auxiliary function as toplevel or embed it with let/where into the body of your solution. (later is nicer imho)
06:38:20 <therp> s/as toplevel/at toplevel/
06:46:06 * EvilTerran ponders... is there a way of writing minOnLength, maxOnLength :: [a] -> [a] -> [a] that works as long as at least one of the lists is finite-length?
06:46:26 <EvilTerran> there's something involving zip, but i'm not sure what it is
06:47:18 <hpaste>  smashor pasted "(no title)" at http://hpaste.org/2723
06:47:45 <smashor> this is my current solution...
06:48:11 <smashor> therp: the thing with "let" was my first thought, but I didnt get it to work.
06:48:40 <quicksilver> EvilTerran: I don't even know what you mean?
06:48:58 <smashor> next thing is to combine shortestOne and largestOne into one function.
06:49:02 <EvilTerran> minOnLength xs ys = if zipWith (const(const ()) xs ys == map () xs then xs else ys -- i think this works
06:49:17 <therp> smashor: is it specified that shortestAndLongest [] = ("","") ?
06:49:33 <therp> smashor: I would remove that case actually.
06:49:36 <smashor> therp: no, that was my "idea"
06:49:46 <EvilTerran> (zipWith (const $ const ()) xs ys) will be finite-length if at least one of xs and ys is finite-length
06:49:53 <quicksilver> EvilTerran: you want the shortest of the two lists? given that one might be infinite?
06:50:01 <EvilTerran> so comparing that for equality will always terminate
06:50:09 <EvilTerran> yes
06:50:12 <EvilTerran> or the longest.
06:50:29 <therp> smashor: ah and btw, there are two versions of this. the "tail-recursive" version with an "accumulator" argument and one that does the computation when walking "backwards". I can post a little example of sum [1,2,44] = 46, if you like to see the difference
06:50:47 <EvilTerran> which would be maxOnLength xs ys = if zipWith (const $ const ()) xs ys == map (const ()) xs then ys else xs -- i guess
06:50:48 <smashor> therp: well, but than I get an exception if i call the function with an empty list...
06:51:02 <therp> smashor: I would say shortAndLongest [str] = (str,str), and remove the [] case. It's just a partial function with [] being unspecified. but I guess that's not the important point here
06:51:03 <EvilTerran> (correcting the mistakes in my defn of minOnLength above)
06:51:12 <quicksilver> EvilTerran: would be more elegant written as a primitive recursion
06:51:18 <therp> smashor: that's ok I think. there is no maximum/minimum of an empty list
06:51:36 <[TWiSTED]> what does function1 :: Eq a => [a] -> [a]   mean?
06:51:36 <smashor> therp: no, it really isnt the important point. would be kind if you could post your sum example
06:51:45 <[TWiSTED]> a is of data type Eq ?
06:51:57 <quicksilver> [TWiSTED]: a is of some data type which implements the class Eq
06:52:12 <[TWiSTED]> ah ok thanks
06:52:15 <roconnor> > foldl min maxBound [-1,2,0]
06:52:23 <lambdabot>  Add a type signature
06:52:27 <quicksilver> EvilTerran: but, that's quite a cool hack
06:52:30 <roconnor> > foldl min maxBound [-1,2,0] :: Int
06:52:35 <lambdabot>  -1
06:52:39 <quicksilver> EvilTerran: I prefer (\_ _ -> ()) to (const $ const ()) though
06:52:57 <EvilTerran> minOnLength xs ys = f xs ys where f [] _ = xs; f _ [] = ys; f (_:xs') (_:ys') = f xs' ys'; -- that what you mean?
06:53:02 <hpaste>  therp annotated "(no title)" with "little guide" at http://hpaste.org/2723#a1
06:53:13 <quicksilver> EvilTerran: yes
06:53:23 <EvilTerran> that's shorter as well as less esoteric. neat!
06:53:38 <roconnor> > join (const ()) 5 25
06:53:39 <lambdabot>  Couldn't match expected type `b -> t1 -> t'
06:54:09 <roconnor> oh wait, join goes the wrong way
06:54:14 <roconnor> > cojoin (const ()) 5 25
06:54:16 <lambdabot>   Not in scope: `cojoin'
06:54:24 <therp> smashor: these are two version of the sum function for integers. you can write two functions for shortAndLongest too: 1. tail recursive using an accumulator argument for the results so far 2. recursive operating on the results from the recursion as you see in the function 'sum' (compare with sumTC)
06:54:36 <EvilTerran> "cojoin"?
06:54:53 <roconnor> cojoin :: w a -> w (w a)
06:55:08 <EvilTerran> isn't that just return?
06:55:13 <EvilTerran> so, in this case, const?
06:55:17 <therp> ah, TC was my abbreviation for tail-recursive call
06:55:24 <roconnor> return :: a -> m a
06:55:35 <EvilTerran> ah, w is a comonad.
06:55:36 <quicksilver> roconnor: comonads don't have return though
06:55:45 <quicksilver> hmm meant that for EvilTerran  :)
06:55:46 <roconnor> quicksilver: hence the m
06:55:49 <quicksilver> I know
06:55:50 <roconnor> ah
06:56:00 <quicksilver> still, cojoin is very boring
06:56:04 <quicksilver> even more boring than join
06:56:10 <quicksilver> it's just "duplicate the environment"
06:56:15 <Mr_Awesome> more boring than join? blasphemy!
06:56:18 <roconnor> quicksilver: have you ever used tails?
06:56:28 <quicksilver> roconnor: sonic is much better
06:56:35 <roconnor> ;)
06:56:36 <Mr_Awesome> i prefer knuckles
06:57:09 <quicksilver> roconnor: yes, occasionally I've used tails
06:57:14 * Mr_Awesome leaves
06:57:23 <quicksilver> roconnor: is that cojoin for some comonad?
06:57:54 <smashor> therp: ok. whereby the sum function is much more intuitive for me...
06:58:11 <therp> smashor: btw your version is tail recursive (which is actually good performance wise, but usually for cases where performance doesn't matter the non-TR version is preferred because most people can read it more easily
06:59:18 <roconnor> quicksilver: yep
06:59:31 <roconnor> tails :: [a] -> [[a]]
06:59:42 <roconnor> head :: [a] -> a
06:59:58 <roconnor> map :: (a -> b) -> ([a] -> [b])
07:00:22 <roconnor> actually [a] should be replaced by Stream a
07:01:02 <roconnor> or at the very least, non-empty lists.
07:01:59 <smashor> therp: honestly, I dont know how to do it the other way...
07:02:08 <smashor> therp: ah, ive got an idea
07:02:08 <nominolo> @seen syntaxninja
07:02:08 <lambdabot> I saw syntaxninja leaving #haskell-soc, #haskell-blah and #haskell 13h 46m 5s ago, and .
07:04:32 <smashor> therp: hm, no, that was a dead end
07:04:59 <smashor> therp: could you tell me how to it in a not TC way?
07:05:53 <quicksilver> roconnor: yes, understood that it's really non-empty
07:05:56 <quicksilver> roconnor: interesting
07:12:18 <fasta> What's the primitive in GHC to run a computation only for a maximum of X seconds?
07:12:30 <quicksilver> there is none
07:12:43 <fasta> " GHC only, it is possible to place a time limit on each test"
07:12:56 <quicksilver> I suspect it forks to do that
07:12:59 <mrd> just spawn two threads
07:12:59 <quicksilver> lambdabot forks
07:13:43 <int-e> http://www.haskell.org/haskellwiki/Timing_out_computations
07:13:44 <lambdabot> Title: Timing out computations - HaskellWiki
07:15:21 <therp> smashor: have you unified the two solutions?
07:15:23 <quicksilver> I think I'm right in suggesting that that required some assumptions about the computation
07:15:40 <quicksilver> isn't it the case that a tight loop which doesn't allocate memory will never be interrupted?
07:15:50 <quicksilver> (as compiled by GHC)
07:16:02 <smashor> therp: no. just thought about the tail-recursive stuff etc.
07:16:05 <Philippa> if you're not using a threaded RTS, yes
07:16:12 <mrd> if you're talking about lambdabot, then, it uses ulimit and runs it in a separate process
07:16:16 <therp> smashor: let's just concentrate on the shortestOne
07:16:36 <therp> smashor: what would you return when get a singleton list?
07:16:37 <mrd> the OS is in charge of termination
07:16:48 <therp> smashor: shortestOne [a] = ?
07:17:22 <smashor> therp: (a, a)
07:17:44 <smashor> therp: ah no, forget it
07:17:45 <smashor> mom
07:17:48 <therp> smashor: well let's just concentrate one the shortestOne :: [String] -> String
07:18:12 <hpaste>  hkBst pasted "how should I write this instead?" at http://hpaste.org/2724
07:18:14 <smashor> therp: then it should be just a
07:18:30 <smashor> therp: i.e. shortestOne [a] = a
07:18:48 <Frederick> yo folks, folks wich is now a days the best avaliable book on haskell?
07:19:12 <therp> smashor: right :) .. and how would you decide what return value to give if you have a single element, x, and you KNOW that shortest element of an existing list xs is shortestOfXs
07:20:36 <smashor> therp: i compare shortestOfXs with x
07:21:04 <therp> assume you have the helper function "minString a b | length a < length b = a | otherwise = b"
07:21:28 <therp> right
07:21:42 <quicksilver> Frederick: for beginners, Hutton is well received
07:22:25 <therp> smashor: try to connect the idea for the case that's still missing, namely "shortest (x:xs) =\n let shortestOfXs = shortest xs\n in <compare shortestOfXs with x>"
07:22:25 <ndm> @karma+ mboes
07:22:25 <lambdabot> mboes's karma raised to 1.
07:22:42 <mboes> :)
07:22:55 <Frederick> quicksilver: is it still worthy to buy a book nw that the wiki is soooo bigger and better?
07:23:04 <hkBst> do I have to resort to template Haskell to do it?
07:23:06 <fasta> Frederick: yes
07:23:28 <Frederick> and is there and ultimate reference for haskell like k&r is for c?
07:23:45 <therp> frederick: the haskell 98 language report
07:23:58 <Frederick> therp: bust this is open avaliable on the net isnt it?
07:24:08 <oerjan> @where report
07:24:08 <lambdabot> http://www.haskell.org/onlinereport/
07:24:45 <Frederick> oerjan: I just googled it :)
07:26:16 <quicksilver> Frederick: it's not worth buying a book unless, for you, the book is better than the web
07:26:29 <quicksilver> Frederick: pop in a bookstore, read a bit of it, decide if you think it would be useful
07:26:33 <quicksilver> I don't have any haskell books...
07:27:16 <puusorsa> i can't read...
07:27:30 <bakert> say there are 9 playing cards.  3 are in your hand.  3 are in your opponents hand.  he has 3 of the 6 unknown cards.  there's (6 choose 3) = 20 ways your opponents hand can be structured.
07:27:42 <fasta> Frederick: note that all Haskell books teach idiomatic Haskell for very simple programs.
07:28:13 <smashor> therp: i.e. shortestOne (x:xs) =\n let shortestOfXs = shortest xs\n in minString shortestOfXs x
07:28:16 <bakert> each card is better or worse than each other card.  how can you work out the chance your opponent will play each of the six unknown cards next turn?
07:28:25 <puusorsa> isn't idiomatic better than idiotic?
07:28:28 <therp> smashor: yes, that's your non-tail recursive solution
07:28:42 <smashor> therp: hm, it just took me almost 10 minutes :D
07:28:52 <oerjan> puusorsa: depends on the idiom, doesn't it? </idiotic response>
07:28:53 <smashor> therp: with your help... argh
07:28:57 <fasta> puusorsa: compilers don't turn idiomatic Haskell into blazingly fast code, yet.
07:29:02 <quicksilver> puusorsa: they're much the same to someone who can't read
07:29:07 <therp> smashor: you know how to destructure on tuples? -- then you should be able to do the same thing for shortestAndLongest in combination
07:29:17 <therp> smashor: don't worry :) -- progress is what counts at the end
07:29:19 <fasta> puusorsa: see language shoot-out
07:30:04 <bakert> i can write down on paper what you need to do.  but my brain won't turn it into a nice recursive function.
07:30:24 <smashor> therp: destructure on tuples? I think thats new ...
07:30:25 <bakert> there's kind of two levels of recursion and that is what is confusing me
07:30:33 <therp> smashor: destructure on tuples means: let (minimum, maximum) = shortestAndLongest somelist\n in <here you have two variables available with with destructured return value of shortestAndLongest>
07:30:34 <smashor> therp: how does it look like?
07:30:36 <quicksilver> fortunately, of course, blazingly fast code is not a big problem for most people
07:30:42 <quicksilver> whilst idiomatic code is a powerful thing to learn
07:31:11 <bakert> for (6 choose 3) there are (5 choose 2) combinations that have a particular card in them
07:31:11 <therp> smashor: destructuring = look inside an object, most of the time it means, giving variable names to subcomponents
07:31:19 <bakert> so that's the basic number.
07:31:30 <therp> smashor: (x:xs) is a destructuring on lists, giving you the head and the tail.
07:31:35 <smashor> therp: ok, got it. so that i have access to the elements of the tuple
07:31:42 <bakert> if it's the best card, then (5 choose 2) / (6 choose 3) is the chance of that card being played
07:32:04 <bakert> but for the cards that are worse i need to account for better cards "masking" them
07:32:09 <bakert> so i have a function:
07:32:12 <therp> smashor: right, "let" lets you do that destructuring. in haskell that's also called pattern matching which can do a bit more than pure destructuring
07:32:13 <bakert> masked x n m
07:32:32 <bakert> where x is the number of cards better than the one in question
07:32:44 <bakert> and n is 5 and m is 2 as in (5 choose 2)
07:33:27 <bakert> so say you call "masked 1 5 2" ... meaning I'd like to know how many times out of the (5 choose 2) combinations involving this card it is in a hand with the 1 card better than it.
07:33:37 <smashor> therp: ok, the "let" construct is kind of new to me, although it's kind of variable declaration in other languages
07:33:38 <bakert> and even that is fairly straightforward
07:33:51 <bakert> masked 1 5 2 = choose 4 1
07:33:54 <smashor> therp: will go for lunch now, thanks for your many explanations and hints
07:34:02 <therp> smashor: nevermind :) welcome to haskell
07:34:14 <bakert> but once i get another layer deep, i get confused :~
07:34:44 <oerjan> bakert: you know about conditional expectations?
07:34:48 <bakert> the third best card needs to account for both the times it is in the hand with the best card (easy)
07:34:53 <bakert> oerjan: no what are they?
07:34:53 <oerjan> er, probabilities
07:35:11 <bakert> oerjan: i know about combinatorics because i looked it up to do this but that's about as far as i go
07:35:24 <oklopol> > []
07:35:27 <lambdabot>  []
07:35:33 <cognominal_> @src flip
07:35:33 <lambdabot> flip f x y = f y x
07:35:54 <quicksilver> @type flip
07:35:55 <smashor> therp: thanks for inviting me :D bye!
07:35:56 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:36:00 <quicksilver> @. djinn type flip
07:36:02 <lambdabot> f a b c = a c b
07:36:24 <oerjan> basically, you can start by calculating the probability that your opponent plays the best unknown card
07:36:26 <bakert> the third best card also needs to account for the times it is in the same hand as the second best hand BUUUUT it mustn't count the times it is in the had with the second best AND the best card else those hands will be counted twice
07:36:33 <bakert> oerjan: right
07:36:38 <bakert> that i can do!
07:36:55 <bakert> what next???
07:36:58 <bakert> :)
07:37:04 <oerjan> then, if not, you calculate the probability that he plays the second best _given_ that you know he doesn't play the best
07:37:13 <bakert> ok makes sense
07:37:35 <bakert> so the chance he plays the second best is (6 choose 3) - (5 choose 2)
07:37:43 <bakert> but how do i go a layer deeper than that?
07:37:47 <fasta> @src RealWorld
07:37:48 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:38:11 <oerjan> then you calculate the probability for the third best given that you know neither of the two best are played
07:38:16 <bakert> hmm
07:38:39 <bakert> which is (6 choose 3) - (5 choose 2) - ((5 choose 2) - (4 choose 1)) ... i think
07:39:00 <bakert> but it's about here that my ability to code this up breaks down because i can't work out the recursion
07:39:03 <oerjan> however to get the real, non-conditional probability you must multiply the conditional one with the probability of the condition
07:39:28 <bakert> ok no i see.  i'm making it perhaps more complicated than needs be
07:39:34 <bakert> i literally disregard the earlier card
07:39:36 <oerjan> so, P(X and Y) = P(X) * P(Y given X)
07:39:42 <bakert> once i have the probability for it
07:39:45 <oerjan> yep
07:41:40 <bakert> oerjan: thanks ... let me think about this for a bit.  thanks so much for jumping me out of my rut!
07:41:55 <oerjan> you're welcome :)
07:45:04 <bakert> OK, simple example.  cards are ABCD.  hands are of 3 cards.
07:45:26 <bakert> so the three possible hands for my opponent are ABC, ABD or BCD
07:45:34 <bakert> so there is a 2/3rds chance he will play A
07:45:55 <bakert> (obviously otherwise he will play B but bear with me here)
07:46:00 <bakert> what's the next calculation?
07:46:26 <bakert> remove A.  and say what is the chance he will play B with hands of 2 cards and BCD as the cards?
07:46:32 <oerjan> the next calculation is then 1/3*chance he will play B, given he doesn't play A
07:46:53 <bakert> but isn't that 2/3rd * 1/3rd?
07:47:06 <bakert> which is less than 1/3rd??
07:47:15 <oerjan> no, it is 1/3* 1, because if he doesn't play A you _know_ he plays B
07:47:29 <bakert> well yes i know i _know_ that but I don't know why i know it!!!!
07:47:37 <bakert> :)
07:48:00 <bakert> what i wonder is, can i do this without enumerating all the hands?
07:48:09 <oerjan> sure
07:48:16 <bakert> (because of course the real world version of this plan is much bigger :)
07:48:43 <oerjan> note that the subproblem _is_ just ignoring A
07:48:46 <bakert> so ... in the simple example we are doing (4 choose 3)
07:48:52 <bakert> for total possible hands
07:48:56 <bakert> and (3 choose 2)
07:49:01 <bakert> is the number of times A is in a hand
07:49:02 <bakert> fine
07:49:14 <bakert> so then how do we calculate how many times B is in a hand?
07:49:22 <bakert> (3 choose 2) again?
07:49:34 <bakert> but just * 1/3rd this time for the remaining probablility?
07:49:46 <bakert> aha!  i may have grasped elementary probablility!
07:50:03 <cognominal_> @src fisrt
07:50:03 <lambdabot> Source not found. It can only be attributed to human error.
07:50:17 <cognominal_> @src first
07:50:18 <lambdabot> Source not found. Wrong!  You cheating scum!
07:50:50 <oerjan> @src Arrow
07:50:51 <lambdabot> class Arrow a where
07:50:51 <lambdabot>     arr, pure   :: (b -> c) -> a b c
07:50:51 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
07:50:51 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
07:50:51 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
07:50:53 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
07:50:55 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
07:51:52 <bakert> So ... probability of playing A is (3 choose 2) / (3 choose 2)
07:52:06 <oerjan> that's 1
07:52:08 <bakert> oops
07:52:08 <bakert> no
07:52:11 <cognominal_> thx oerjan
07:52:21 <bakert> P(A) = (3 choose 2) / (4 choose 3)
07:52:35 <bakert> P(B) = (1 - P(A)) * (3 choose 2) / (4 choose 3)
07:52:45 <oerjan> actually when i think of it...
07:52:57 <oerjan> you want to calculate P(B and not A)
07:53:09 <bakert> yes
07:53:11 <bakert> i suppose
07:53:20 <bakert> but i thought that was accounted for in our multiplying
07:53:27 <bakert> P(A) = 0.75 above
07:53:47 <bakert> which is right
07:53:49 <oerjan> you are not ignoring A properly in the second equation
07:53:55 <koala_man> how can you find something like >>= on hoogle by signature?
07:54:07 <bakert> oerjan: no
07:54:11 <oerjan> koala_man: you can't because hoogle is buggy with monads
07:54:33 <koala_man> aww. anything else I can use to avoid bugging you guys all day?
07:55:14 <conal> oerjan: is the hoogle thing a monad issue or a TC issue or what?
07:55:15 <oerjan> browsing Control.Monad is one start :)
07:55:17 <bakert> P(B) = (1 - P(A)) * (2 choose 1) / (3 choose 2)
07:55:19 <bakert> ???
07:55:31 <Sizur> even though quicksilver will disagree with me, the only stupid question is the one you dont ask
07:55:31 <oerjan> i guess type class
07:55:36 <bakert> nope
07:55:38 <bakert> :(
07:56:07 <conal> hm.  i didn't know about that limitation.
07:56:11 <oerjan> (1 - P(A)) * (2 choose 2)/(3 choose 3), i think
07:56:30 <oerjan> you select as many cards but you throw away one to select _from
07:56:33 <oerjan> _
07:58:26 <bakert> let's try that with another set of cards: A-E, hand is 4 cards.
07:59:00 <bakert> P(A) = (4 choose 3) / (5 choose 4) = .8
07:59:10 <oerjan> i would suggest hand 3 cards, otherwise the subproblem will be trivial again
07:59:21 <bakert> P(B) = (3 choose 3) / (4 choose 4) = 1 (* .2 = .2)
07:59:33 <bakert> i'm trying to make it small enough to check by hand!
07:59:35 <bakert> :)
08:00:02 <oerjan> bakert: you know about quickcheck?
08:00:13 <bakert> i've looked at it a little
08:00:25 <bakert> our formula is wrong i'm afraid.
08:00:47 <bakert> A = .6, B = .3, C = .1 according to my hand written version.
08:00:53 <bakert> not .8/.2
08:00:55 <oerjan> you forgot to multiply by .2
08:01:10 <bakert> P(B) = (3 choose 3) / (4 choose 4) = 1 (* .2 = .2)
08:01:24 <bakert> in fact am i just being thick?
08:01:26 <bakert> hang on!
08:01:39 <bakert> yes i am
08:01:40 <bakert> :(
08:01:45 <oerjan> er, or i am just not reading properly?
08:01:49 <bakert> i have hand written 5 choose 3 not 5 choose 4
08:01:50 <bakert> !!!
08:01:59 <bakert> let's do that then!
08:02:27 <bakert> P(A) = (4 choose 2) / (5 choose 3) = .6
08:04:05 <bakert> P(B) = (3 choose 2) / (4 choose 3) * .4 = 3 / 4 * .4
08:04:41 <bakert> P(B) = 0.3
08:04:43 <bakert> lookin' good
08:04:57 <bakert> P(C) = (2 choose 2) / (3 choose 3) * .1 = .1
08:04:59 <bakert> magic
08:05:09 <oerjan> :)
08:05:14 <bakert> oerjan: you are a genius.  or at least i am an intellectual midget in your shadow :)
08:05:21 <bakert> thanks!
08:05:34 <bakert> i knew i should have listened to that bayes theorem stuff in college
08:05:35 <bakert> :)
08:05:42 <bakert> i knew it at the time!
08:05:45 <bakert> ye gods
08:06:48 <oerjan> well, i didn't remember bayes's theorem either (although it is a trivial consequence of what we were using here)
08:14:56 * byorgey sings the probability song
08:15:28 <byorgey> prob-a-biliteee-eeee, woah yeah
08:16:34 <MyCatVerbs> byorgey: huh? Who composed that?
08:16:48 <byorgey> MyCatVerbs: Stravinsky
08:18:14 * MyCatVerbs googles.
08:19:34 <byorgey> MyCatVerbs: it was a joke, I just made it up =)
08:19:54 <Sizur> just put a page in wikipedia
08:20:04 <byorgey> hehe
08:20:51 <MyCatVerbs> byorgey: damn you.
08:21:19 <MyCatVerbs> byorgey: it sounds much more like something you'd expect Lehrer to come up with, anyway. :)
08:21:38 <quicksilver> "Create" v. tr. To cause something to exist; i.e. to publish an entry for it in wikipedia. Since the 21st Century, Wikipedia has been accepted as the correct criterion for existence.
08:21:47 <Sizur> MyCatVerbs: did you just put a page up for Lahrer in wikipedia?
08:21:52 <Sizur> ;)
08:22:04 <byorgey> MyCatVerbs: that's true... for all I know Tom Lehrer might actually sing such a song!
08:22:28 <MyCatVerbs> Sizur: no, but now you mention it, I'm very glad I didn't think of that.
08:22:39 * MyCatVerbs hums the Masochism Tango.
08:22:50 * quicksilver poisons pigeons in the park.
08:23:07 <quicksilver> actually 'Poisoning Pigeons in the Park' would be a good name for a blog.
08:27:39 <DukeDave> An observation: An instance declaration doesn't *have* to provide definitions for all the functions in the class declaration. Whilst I enjoy this it does seem a little, wrong?
08:28:10 <gip> > 1:[1]
08:28:15 <lambdabot>  [1,1]
08:28:22 <gip> > [1]:1
08:28:23 <lambdabot>   add an instance declaration for (Num [[t]])
08:28:38 <gip> I don't get that?
08:29:04 <quicksilver> DukeDave: it's because there is no way to tell it "this is the minimal subset you need"
08:29:09 <DukeDave> :t (:)
08:29:11 <lambdabot> forall a. a -> [a] -> [a]
08:29:14 <quicksilver> DukeDave: and classes can contain default definitions
08:29:22 <quicksilver> DukeDave: at least I think that's related
08:29:26 <MyCatVerbs> quicksilver: I'm tempted to go check blogspot to see if anyone's actually registered any variations on that yet.
08:29:36 <byorgey> gip: for [1]:1 to make sense, 1 has to be of type Num a => [[a]], right?
08:29:46 <DukeDave> quicksilver: Is there a way to say "Look you really do have to  define this to be an instance" in a class definition?
08:29:58 <quicksilver> DukeDave: sadly not
08:30:13 <byorgey> gip: the numeral 1 by itself has type Num a => a.  so if there actually was an instance of Num [[t]] it would work.
08:30:24 <DukeDave> Ah well, I  suppose I'll just have to trust people to implement then
08:30:27 * DukeDave shudders
08:30:28 <gip> byorgey: ok, I thought ':' was just an operator to add an element to a list
08:30:37 <quicksilver> gip: I think you should ignore all the comments about Num
08:30:38 <gip> But that's a function
08:30:41 <araujo> DukeDave, why wrong?, that's the way most class systems work
08:30:47 <quicksilver> gip: let's go to some non-overloaded type
08:30:54 <quicksilver> > 'a':['b']
08:30:56 <lambdabot>  "ab"
08:31:00 <quicksilver> > ['b'] : 'a'
08:31:01 <lambdabot>  Couldn't match expected type `[[Char]]'
08:31:11 <quicksilver> gip: possibly a better error message
08:31:18 <byorgey> gip: ok, sorry, I misunderstood your confusion
08:31:36 <gip> Yes, thanks to both, I get it now
08:31:36 <byorgey> gip: ':' is an operator to add a single element onto the *front* of the list
08:31:57 <DukeDave> araujo: Maybe I'm just too used to Haskell being fussy about things ;)
08:32:08 <quicksilver> gip: you could, of course, define one to add things to the back of a list
08:32:15 <quicksilver> gip: call it >: or something :)
08:32:36 <quicksilver> gip: and it would expect a list as first parameter and an element as second
08:32:40 <byorgey> *sigh*... the misleading 'add an instance declaration' error message strikes again...
08:32:42 <quicksilver> presumably
08:32:51 <oerjan> gip: because lists are linked lists, adding things to the front is much cheaper
08:33:08 <araujo> DukeDave, Haskell will be fussy _only_ when it is needed ;-)
08:33:14 <oerjan> and (:) is simply the constructor for the data type
08:33:21 <oerjan> to add a link, so to speak
08:33:31 <byorgey> DukeDave: you can of course compile with -Wall or something of that nature
08:33:43 <quicksilver> I don't really accept araujo's explanation
08:33:52 <quicksilver> I don't know what "most class systems" means
08:33:53 <oerjan> > [1,2,3] ++ [4]
08:33:55 <lambdabot>  [1,2,3,4]
08:34:00 <quicksilver> "most programming languages" are dynamically typed
08:34:05 <quicksilver> that's not a reason for haskell to be so
08:34:12 <gip> oerjan: well, I _hoped_ ghc would not implement the list when compiling as not really needed
08:34:14 <araujo> uh?
08:34:25 <quicksilver> the C++ class system certainly complains if you don't implement a method you said you would
08:34:33 <araujo> quicksilver, i said a 'class system' .. or if you want .. 'class system design'
08:34:45 <oerjan> gip: well, haskell itself does not define any optimizations
08:35:11 <DukeDave> I'd like to state also that personally I *like* the fact that you don't have to given that the "undefined member" error is verbose enough. But it still surprises me :)
08:35:14 <quicksilver> and the Java interface system, IIRC, complains if you fail to implement a method in your implementation
08:35:36 * araujo doesn't count java as a sane example for anything
08:35:37 <oerjan> gip: i think ghc might optimize away ++ too, if it does :
08:35:52 <quicksilver> ghc can optimise away ++ in some cases, yes
08:35:57 <oerjan> (i'm not into the details of that)
08:36:10 <quicksilver> ghc will optimise away ++ on two constant lists
08:36:26 <araujo> But in the main idea, a class system will usually offer just the hierarchy without a default restrictions for the set of components defined through it.
08:36:28 <quicksilver> at least, it does on strings. I assume it's not string spefic.
08:36:52 <quicksilver> araujo: are we at cross purposes?
08:37:04 <araujo> It's the point of having a hierarchy after all
08:37:08 <quicksilver> araujo: I'm saying if class Foo a where bar :: a -> Int
08:37:15 <quicksilver> araujo: then all Foo's should define bar
08:37:20 <quicksilver> araujo: this has nothing to do with hierarchy
08:37:27 <araujo> quicksilver, i am talking about DukeDave comment
08:37:32 <quicksilver> araujo: yes, so am I
08:37:36 <quicksilver> araujo: he's talking about undefined methods
08:37:39 <quicksilver> like my undefined bar
08:37:49 <araujo> quicksilver, he wants to restrict a sub-set of operations
08:38:05 <araujo> or at least, force the definition of a sub-set of operations
08:38:12 <quicksilver> he is saying "why does haskell not throw an error if you declare a Foo instance without defining 'bar'"
08:38:15 <araujo> Haskell doesn't offer that
08:38:17 <quicksilver> that has nothing to do with hierarchies
08:38:21 <araujo> Because there is no need for that
08:38:30 <araujo> Of course it does.
08:38:47 <quicksilver> "class Foo a where bar :: a -> Int" isn't in a hierarchy
08:38:49 <araujo> It's the way to keep a flexible 'is-a' or 'has-a' relationship.
08:38:56 <araujo> c'mon, that's basic OO theory
08:39:05 <quicksilver> haskell classes have very little to do with OO
08:39:10 <araujo> omg
08:39:21 <quicksilver> anyhow, if type 'Baz' is an instance of Foo
08:39:27 <quicksilver> then surely the intention is it should define 'bar'
08:39:33 <quicksilver> that's what the class Foo declaration means
08:39:34 <araujo> quicksilver, what OO languages have you used?
08:39:43 <quicksilver> I agree with DukeDave that this is a strange behaviour
08:40:02 <quicksilver> araujo: C++, Java, Python, Perl, Javascript
08:40:12 <Sizur> araujo: let's be friendly here. quicksilver knows enough OO
08:40:20 <araujo> Sizur, i doubt it
08:40:24 <araujo> Seriously.
08:40:44 <araujo> Considering he just started babbling about something he barely understands.
08:40:49 <araujo> And i am being friendly.
08:41:03 <quicksilver> that's not friendly
08:41:25 <araujo> Plus i think he started being rude. Not me.
08:41:30 <Sizur> araujo: i think i missed something. he stated that haskell's classes are not OO, and that is correct
08:41:35 <quicksilver> to be honest I think we're having communication difficulties
08:41:58 <quicksilver> (a) I don't understand your point about hierarchies and how it relates to this particular issue which is about one single class
08:42:10 <quicksilver> (b) I don't see how you think other class systems permit you to leave methods undefined
08:42:17 <araujo> Sizur, No, he said it has nothing to do with OO , which is incorrect
08:42:30 <quicksilver> most of the 'strong' ones I can think of (C++,Java) do force you to define the methods you promise to.
08:42:38 <Sizur> araujo: ok point taken, but let's stay friendly please
08:42:54 <quicksilver> 'very little' was my phrase, actually.
08:42:54 <mauke> "very little" /= "nothing"
08:43:01 <araujo> Sizur, It has something to do, it offers a hierarchy similar to OO systems, where you can implement similar design ideas like operator overloading for instance , or inheritance
08:43:08 <araujo> mauke, indeed
08:43:25 <quicksilver> OK, so let's return to DukeDave's point
08:43:28 <araujo> hah
08:43:31 <quicksilver> I agree with him that it's surprising you don't get an error
08:43:36 <quicksilver> if you fail to define a method
08:43:38 <araujo> quicksilver, dude, use a real OO system first before talking
08:43:42 <araujo> And then chat about it
08:43:43 <quicksilver> why don't you think that's surprising?
08:43:43 * araujo off
08:43:56 <mauke> yeah, operator overloading, the core of OO!
08:44:20 <quicksilver> araujo: I have some years of experience of OO systems and I think you should not escalate a simple failure to communicate effectively into an indictment of my abilities
08:44:51 <mauke> quicksilver: let him define "real OO system" first
08:45:06 <Sizur> guys, friendly please
08:48:36 <cognominal_> I see in Control.Arrow    instance Arrow (->) where
08:48:53 <cognominal_> I would expect to be able to type   :t (->) in ghci
08:49:08 <cognominal_> but it does not accept it.
08:49:11 <quicksilver> cognominal_: woudl you?
08:49:13 <mauke> why? (->) is not a value; it doesn't have a type
08:49:16 <cognominal_> where is my confusion
08:49:17 <quicksilver> cognominal_: can you type :t Maybe in ghci ?
08:49:23 <quicksilver> cognominal_: or :t Either ?
08:49:30 <mauke> can you type :t Int?
08:49:58 <cognominal_> I am confusing types and data constructors?
08:50:14 <quicksilver> I think you're confusing types and values ?
08:50:24 <quicksilver> but of course, data constructors (like 'Just') are also values
08:50:30 <quicksilver> so that does help the confusion along
08:50:33 <mauke> -> doesn't really have a constructor
08:50:47 <quicksilver> what *is* annoying is that you can't type :i (->)
08:50:52 <quicksilver> that realy should work
08:51:08 <Sizur> @type (->)
08:51:11 <lambdabot> parse error on input `->'
08:51:18 <quicksilver> :k (->)
08:51:20 <lambdabot> ?? -> ? -> *
08:51:22 <quicksilver> but that's not very informative really
08:51:32 <quicksilver> in fact, I'd say it's pretty UN-informative
08:51:40 <quicksilver> since it begs the question about what ?? and ? mean :)
08:51:54 <Sizur> @type let a -> b =a in 1 -> 2
08:51:55 <lambdabot> parse error on input `->'
08:51:58 <cognominal_> unknown kinds?
08:52:12 <quicksilver> no, they're specific boxedness/unboxedness kinds
08:52:13 <mux> polymorphic kinds? =)
08:52:20 <quicksilver> they're part of GHC, not of Haskell proper
08:52:26 <mux> it looks like a regexp
08:52:31 <mux> which is a bad sign
08:53:29 <gnomnain> why (->) is not of kind * -> * -> * ?
08:53:37 <Sizur> they look like wildcards not regexp
08:53:47 <mux> like shell patterns, if you prefer
08:53:54 <mux> it's still some kind of a regexp
08:54:02 <Sizur> wouldnt that imply all three to be of the same type?
08:54:13 <phobes> I think there is a strong relationship between haskell typeclasses and standard OO subtyping
08:54:25 <mux> * -> * -> * is a parameterized type taking two types as parameters
08:54:31 <mux> I don't think it describes (->) correctly
08:55:07 <mux> ooor, actually maybe so..
08:55:26 <mauke> gnomnain: because ghc as a few non-standard extensions
08:55:37 <mauke> s/as/has/
08:55:43 <phobes> except that Haskell typeclasses don't suffer from many of the problems that are present with OO subtyping (because it's not subtyping)
08:55:47 * mux leaves before he spouts more crap, time to sleep &
08:55:57 <quicksilver> phobes: I think the clearest relationship is between ad-hoc overloading and typeclasses
08:56:07 <Sizur> personally i dont like the whole type theory (it leads to infinite complexity), but currently we dont have a better set theory.
08:56:20 <quicksilver> phobes: so I think when araujo was talking about operator overloading, that was a good link
08:56:46 <quicksilver> phobes: you mean equating 'sub-typeclasses' with subtyping?
08:56:58 <quicksilver> phobes: and thus with 'inheritance' ?
08:57:00 <phobes> quicksilver, I think ad-hoc overloading is superficially similar, but because of the power of Haskell typeclasses it's much more akin to subtyping in OO, when you look at what you'd use it for
08:57:10 <phobes> quicksilver, yes
08:57:14 * quicksilver nods
08:57:32 <quicksilver> the thing is there are quite a few different ways you can consider mapping other OO languages to haskell
08:57:43 <quicksilver> and "class => typeclass" is not obviously the best
08:57:59 <phobes> yep, and moreover it's not even clear what you mean when you talk about mapping to OO
08:58:01 <quicksilver> in fact, I'd go as far as to say, it's definitely not the best :)
08:58:08 <phobes> well there are lots of aspects of OO
08:58:15 <phobes> object identity maps more closely to Monads
08:58:25 <quicksilver> phobes: java/objective C interfaces are quite like typeclasses
08:58:28 <phobes> Some things map to existential types
08:58:54 * mux likes how benjamin pierce takes system F omega + subtyping, adds in records and polymorphic update, and gets a nice core calculus for an OO language
08:59:00 <phobes> quicksilver, that's the aspect I was intending to compare, yes
08:59:10 <mux> it needs existential types too
08:59:23 <mauke> heh, I read that as "existential typos"
08:59:27 * phobes thinks trying to emulate OO with haskell is getting it backwards :)
08:59:37 <quicksilver> phobes: yes, and there's the O'Haskell mapping
08:59:45 <quicksilver> phobes: but that is somehow not a very satisfying one :)
08:59:57 <quicksilver> although it's clever from a technical perspective
09:00:04 <quicksilver> in terms of demonstrating what can be done
09:00:17 <phobes> I haven't looked at it in any depth yet, but it's on my list
09:00:28 <quicksilver> I've read the paper but not played with it
09:00:31 <quicksilver> and that was a long time ago
09:00:35 <quicksilver> memory slightly hazy :)
09:00:45 <quicksilver> I remember think 'very very clever but eeuch'
09:00:49 <phobes> hehe
09:00:57 <quicksilver> not an entirely uncommon reaction to Olegisms for me
09:01:41 <phobes> I do think OO languages do get something right that Haskell gets wrong... (I'm trying to formulate my ideas on that currently)
09:01:58 <Sizur> as a sidenote, i wouldnt call javascript oo ;)
09:02:09 <quicksilver> Sizur: javascript has some quite interesting OO features
09:02:16 <quicksilver> Sizur: although most JS authors don't use them
09:02:25 <quicksilver> Sizur: it has a prototype-based object system
09:02:33 <quicksilver> and you can mutate the prototypes at runtime
09:03:08 <Sizur> quicksilver: encapsulation? polymorphism is not how you expect normally too
09:03:50 <krishn_bhakt> any good books on learning statistics using haskell
09:03:55 <quicksilver> Sizur: yes, polymorphism via prototypes
09:04:19 <quicksilver> Sizur: but the 'method dispatch table' belongs to the object itself at runtime
09:04:36 <quicksilver> Sizur: so if you change the prototypes later, the method dispatch of existin objects isn't affected
09:04:45 <quicksilver> Sizur: as I say, though, you don't often see this used in JS programs :)
09:05:10 <quicksilver> Sizur: maybe actionscript coders use it more. actionscript is also ECMAscript, so essentially the same
09:05:21 <quicksilver> Sizur: but since flash is a non-free toolchain I've never played with it :)
09:07:57 <ddarius> You can easily simulate class-based OO in a prototyped-based OO language.
09:08:13 <hpaste>  mlesniak pasted ""Show"-ing a Tree" at http://hpaste.org/2725
09:08:24 <mlesniak> I have a (probably) simple problem
09:08:48 <mlesniak> ghc gives me type errors and I supoose it's a simple syntax error which I can't find...
09:09:36 <quicksilver> mlesniak: helps to see the error on your part, too :)
09:09:37 <Sizur> quicksilver: i still think encapsulation is a must for OO. in perl atleast you can hide internals, but not in ecma
09:09:51 <mlesniak> quicksilver, :)
09:09:54 <quicksilver> Sizur: I'd think you can hide things as much in ecma as in perl
09:10:03 <quicksilver> Sizur: in each case it's "voluntary" hiding
09:10:13 <quicksilver> Sizur: you can say to consumers 'please don't poke around in my internal structures'
09:10:19 <quicksilver> Sizur: but you can't actually prevent it
09:11:10 <Sizur> well, you cannot prevent it in Eiffel nor in Java, so i guess ultimately they are same
09:11:56 <quicksilver> mlesniak: looks to me like it could be a layout error
09:12:23 <mlesniak> quicksilver: why? i indented after the where?
09:12:30 <Sizur> end of workday. see yall later
09:12:38 <quicksilver> mlesniak: oh
09:12:40 <quicksilver> it's not that
09:12:45 <mlesniak> quicksilver: ghc tells me, Tree is not applied to enough type arguments
09:12:55 <quicksilver> mlesniak: yup
09:12:58 <quicksilver> mlesniak: I just tried it
09:13:02 <mlesniak> quicksilver, but if I add Tree a, another error message pops up ;)
09:13:09 <quicksilver> mlesniak: you want instance Show (Tree a)
09:13:18 <quicksilver> mlesniak: in the show instance
09:13:25 <quicksilver> Show is a typeclass on fully-applied types
09:13:25 <mlesniak> quicksilver, argh :) yes
09:13:29 <quicksilver> not on type constructors
09:13:33 <quicksilver> (/families)
09:13:58 <mlesniak> thanks for your help :)
09:14:58 <gip> @hoogle (a->x->[y])->a->[x]->(a, [y])
09:14:59 <lambdabot> No matches, try a more general search
09:15:03 <DukeDave> We should write a lambdabot plugin which automatically gives karma when someone says "thanks" to someone :)
09:15:15 <gip> @hoogle (a->x->y)->a->[x]->(a, [y])
09:15:15 <lambdabot> No matches, try a more general search
09:15:18 <quicksilver> in a language without a powerful type checker, encapsulation is just an engineering technique
09:15:30 <quicksilver> as in "good programmers do it like this"
09:15:38 <hkBst> @karma+ DukeDave
09:15:39 <lambdabot> DukeDave's karma raised to 1.
09:15:49 <gip> @hoogle (a->x->(a,y))->a->[x]->(a, [y])
09:15:49 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
09:15:50 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
09:15:50 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:15:51 <ddarius> quicksilver: Encapsulation is not reliant on type checking at all.
09:16:02 <gip> @hoogle (a->x->(a,[y]))->a->[x]->(a, [y])
09:16:03 <lambdabot> No matches, try a more general search
09:16:19 <CosmicRay> > Data.Map.deleteAt 0 (Data.Map.fromList [(0::Int, 0::Int), (1,1), (2, 2), (3, 3)])
09:16:20 <lambdabot>   Not in scope: `Data.Map.fromList'
09:16:20 <quicksilver> ddarius: no, but it *is* very nice when you have a type checker which can prove some of your encapsulation properties for you
09:16:32 <CosmicRay> bah
09:16:37 <CosmicRay> Prelude Data.Map> Data.Map.deleteAt 0 (Data.Map.fromList [(0::Int, 0::Int), (1,1), (2, 2), (3, 3)])
09:16:37 <CosmicRay> fromList []
09:16:41 <DukeDave> Lol, erm, thanks :)
09:16:42 <CosmicRay> I believe that deleteAt is b0rked.
09:16:43 <quicksilver> ddarius: safe newtype wrappers with non-exported constructors, and so on
09:17:08 <ddarius> quicksilver: It is no trouble to build an abstract type in, say, Scheme.
09:17:11 <CosmicRay> Prelude Data.Map> Data.Map.elemAt 0 (Data.Map.fromList [(0::Int, 0::Int), (1,1), (2, 2), (3, 3)])
09:17:11 <CosmicRay> (0,0)
09:17:14 <CosmicRay> elemAt does the right thing.
09:17:52 <quicksilver> ddarius: making it abstract by concealing it inside a lambda?
09:18:02 <sioraiocht> @karma
09:18:02 <lambdabot> You have a karma of 0
09:18:14 <ddarius> quicksilver: And "exporting" the relevant operations, yes.
09:18:42 <quicksilver> ddarius: yes. That's another way of getting a static guarantee
09:18:44 <Igloo> Won't http://www.formula1.com/ be the first with accurate info, or am I overly optimistic?
09:18:45 <lambdabot> Title: The Official Formula 1 Website
09:18:47 <quicksilver> ddarius: just not one wich comes from a type system
09:18:48 <Igloo> Ooops
09:19:06 <quicksilver> CosmicRay: I can certainly replicate your result
09:20:21 <quicksilver> > deleteAt
09:20:22 <lambdabot>   Not in scope: `deleteAt'
09:20:28 <quicksilver> > Map.deleteAt
09:20:29 <lambdabot>   Not in scope: `Map.deleteAt'
09:20:38 <CosmicRay> it seems to work with indexes other than 0
09:20:47 <CosmicRay> and things like elemAt do the right thing with 0
09:20:48 <quicksilver> CosmicRay: updateAt seems similarly borken
09:21:12 <CosmicRay> quicksilver: I'm not surprised, since the docs say deleteAt is implemented in terms of updateAt
09:21:44 <CosmicRay> I ahve submitted this to http://hackage.haskell.org/trac/ghc/ticket/1691
09:21:45 <quicksilver> CosmicRay: right, that's why I checked it :)
09:21:46 <lambdabot> Title: #1691 (Data.Map.deleteAt broken with index 0) - GHC - Trac
09:22:48 <CosmicRay> this caused me lots of grief yesterday.  Kept trying to figure out what was wrong with my code ("nah, this call to deleteAt is doing the right thing...")
09:23:45 <quicksilver> CosmicRay: it's broken for other values too
09:24:05 <quicksilver> Data.Map.deleteAt 2 (Data.Map.fromList [(0::Int, 0::Int), (1,1), (2, 2), (3, 3)])
09:24:08 <quicksilver> fromList [(3,3)]
09:24:21 <quicksilver> CosmicRay: where it breaks is hard to predict because it's due to Map's internal structure
09:24:45 <quicksilver> well, hard for me to predict because I don't understand the bug yet
09:24:58 <quicksilver> I suspect it's a bug in 'glue'
09:27:38 <quicksilver> CosmicRay: I suspect you can fix it by turning the call to 'glue' into 'merge' in updateAt (Nothing case)
09:27:57 <quicksilver> CosmicRay: but I don't properly understand the balancing algorithm, and I think that makes the complexity worse
09:32:27 <kjdf> greetings
09:32:43 <kjdf> is there a library for convenient interacting with external programs?
09:32:57 <kjdf> if I wanted to write a rather not sophisticated "shell script"
09:34:25 <quicksilver> there is 'HSH' by our very own CosmicRay
09:34:28 <quicksilver> that's quite cute
09:34:32 <quicksilver> might be what you're looking for
09:34:51 <quicksilver> @where hsh
09:34:52 <lambdabot> I know nothing about hsh.
09:35:32 <puusorsa> http://www.informatik.uni-bonn.de/~ralf/software/examples/Hsh.html
09:35:34 <lambdabot> Title: Hsh.hs, http://tinyurl.com/2udchk
09:35:38 <quicksilver> http://software.complete.org/hsh
09:35:40 <lambdabot> Title: HSH
09:35:46 <quicksilver> @where+ hsh http://software.complete.org/hsh
09:35:46 <lambdabot> Done.
09:35:53 <quicksilver> kjdf: take a look at that
09:36:34 <kjdf> thank you
09:38:12 <RegexGuy> hi, I'm wondering if there is some way to get automatic parallelization from a haskell program?
09:38:37 <ddarius> Sure there is.
09:38:56 <RegexGuy> how is it done?
09:39:13 <hpaste>  sclv pasted "Mutable data and hashtables?" at http://hpaste.org/2726
09:39:51 <ddarius> I'm not sure any extant implementation does it, because it's not a good idea, but all you need to do is run each argument of a function in parallel essentially.
09:40:03 <ddarius> But I have to leave.
09:40:20 <shapr> ghc 6.6.1 does parallelization.
09:40:35 <RegexGuy> I have 6.6.1
09:40:38 <shapr> You need to explicitly fork and run with +RTS -N2 -RTS for example
09:40:51 <RegexGuy> um... what?
09:41:02 <shapr> swiert wrote a parallel sudoku solver, lemme find it...
09:41:20 <shapr> http://programming.reddit.com/info/2gjbz/comments
09:41:21 <lambdabot> Title: A parallel Sudoku solver in Haskell using transactional memory (reddit.com)
09:41:47 <Cale> shapr: That's not automatic parallelisation though
09:41:55 <shapr> No, only NDP does that.
09:41:58 <sclv> any help with the newb question i put on hpase?
09:42:10 <Cale> and even that's somewhat explicit
09:42:17 <sclv> s/hpase/hpaste
09:42:19 <shapr> RegexGuy: If you want automatic parallelization, you can use the nested data parallel stuff.
09:42:38 <sclv> I'm trying to understand how mutable data works in the io monad
09:42:59 <sclv> but the inserts into the hashtable don't seem to "stick"
09:43:04 <RegexGuy> looking at NDP...
09:43:21 <Cale> sclv: Just an aside, Data.HashTable sucks and should be removed from the libraries.
09:43:27 <shapr> RegexGuy: It's in ghc 6.8.1, but not yet 'pretty'
09:43:52 <sclv> would my code work with another mutable collection type then?
09:44:35 <Cale> sclv: I haven't yet read your code ;) It's just that Data.HashTable is much slower than our existing immutable collection types
09:44:54 <kjdf> Cale: is it idea or the implementation that sucks?
09:45:09 <Cale> kjdf: Both to some extent, but really the implementation.
09:45:46 <quicksilver> sclv: your paste doesn't seem to include any actual code to do inserts ?
09:45:54 <fasta> Cale: both? Someone recently beat Data.Map with an implementation in the ST monad.
09:46:05 <quicksilver> sclv: I mean, I see 'insRec' but I don't see you calling it
09:46:17 <fasta> Cale: (of a hash table)
09:46:18 <sclv> its called in getRec
09:46:40 <Cale> fasta: Yeah, which is fine if you don't mind writing your entire hashtable using computation in ST.
09:46:45 <quicksilver> sclv: but you dont' actually call it from myRC? which I assume is the main function there?
09:47:17 <sclv> quicksilver: myRC is just to create a default RecCache to play with
09:47:35 <sclv> quicksilver: i've been doing most of the testing in ghci
09:47:41 <quicksilver> sclv: what I'm saying is, your paste doesn't actually include a program fragment which demonstrates the failure :)
09:48:08 <quicksilver> sclv: so it's a bit hard to tell you what you're doing wrong
09:48:10 <sclv> quicksilver: gotcha -- i'll cook one up
09:48:44 <Cale> fasta: for only a logarithmic speedup :)
09:49:03 <quicksilver> sclv: in fact that code doesn't even compile :)
09:50:10 <agocorona> Finaly the problems of hs-plugins in Windows where solved?
09:50:49 <quicksilver> sclv: I'm guessing you were creating a new RecCache each time
09:50:54 <quicksilver> sclv: that's what it looks like from that code
09:51:14 <quicksilver> sclv: you pass getRec and insRec an act which they then run, to get an IORef
09:51:25 <quicksilver> sclv: if you pass myRC to getRec and insRec then they run it every time
09:51:29 <quicksilver> fresh RecCache each time
09:51:49 <sclv> quicksilver: hmmm.. sounds possible
09:52:25 <gip> @type mapAccumR
09:52:27 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:53:02 <gip> I want to use mapAccumR, the type of acc being [Char]. Is that going to work?
09:53:03 <agocorona> Dons ?
09:53:23 <quicksilver> gip: sure. acc can be any type,
09:53:50 <byorgey> wow, I've never seen an actual use for mapAccumR
09:53:59 <hpaste>  gip pasted "Type question" at http://hpaste.org/2727
09:54:11 <Cale> gip: yes, sure
09:54:21 <quicksilver> gip: helps to paste the error too :)
09:54:40 <gip> Then please have a look to hpaste, it must be very easy but I couldn't find
09:54:50 <hpaste>  sclv annotated "Mutable data and hashtables?" with "Yep it was that obvious" at http://hpaste.org/2726#a1
09:55:17 <sclv> @karma+ quicksilver
09:55:17 <lambdabot> quicksilver's karma raised to 4.
09:55:53 <Cale> gip: It's saying that ch is a character, but l is a list of list of characters
09:56:06 <Cale> gip: So it doesn't make sense to do (ch : l)
09:58:29 <gip> Cale: right, but I don't have a clue what it thinks l is a list of list
09:59:14 <kjdf> what happens if I install an older version of ghc library from debian
09:59:31 <kjdf> then manually install a never version in /usr/local
09:59:41 <kjdf> will I have to recompile other libraries that depend on it?
10:00:21 <kjdf> s/never/newer :)
10:00:38 <Cale> gip:  let v = val a b c ch  -- the val in that code doesn't look like a function of 4 parameters to me.
10:01:20 <Cale> Let's fix that one first :)
10:01:46 <gip> Oups, right :) Tough to relate this to the error message though..
10:02:14 <Cale> gip: It's inferring from that application, I think, that a :: [t] for some t
10:02:25 <Cale> which means that [a,b,c] :: [[t]]
10:02:30 <Cale> and so l :: [[t]]
10:03:39 <sclv> without a hashtable though, there's no collection that provides essentially O(1) lookup, right?
10:03:59 <gip> It works now, but this was very tricky. Thanks
10:04:14 <Cale> val actually returns a number, but numbers are polymorphic (why it didn't complain about the lack of an instance of Num for [Char] -> [Char] -> Char -> [Char] instead, I don't know.
10:04:38 <Cale> sclv: There's DiffArray
10:04:48 <Cale> sclv: Well, arrays in general.
10:05:03 <dylan> I know someone that wrong a DiffHash
10:05:09 <dylan> I dunno if he went anywhere with it
10:05:46 <sclv> Cale: right, but then to translate a mapping that's not over a contiguous set of Ix then you're just rolling your own hashfunction?
10:06:13 <Cale> Yeah, if you're trying to do that :)
10:06:40 <Cale> Then again, if you're just being practical, Data.Map is really nice
10:06:53 <Cale> and it has only logarithmic lookup and update times.
10:07:15 <Cale> which are essentially constants (and small ones at that)
10:10:18 <sclv> if i want to look at the source for data.hashtable to see how it works for myself, where is that in a default ghc installation"?
10:10:29 <sclv> or do i need to crawl around the web?
10:10:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html -- click the source link in the upper right corner
10:10:47 <lambdabot> http://tinyurl.com/yum6zr
10:11:12 <sclv> thanks!
10:11:14 <Cale> But seriously, consider using Data.Map :)
10:13:03 <kjdf> there really should be something like cabal-get ...
10:13:34 <Cale> kjdf: That's the plan
10:13:52 <Cale> kjdf: I think it may already be in some state of readiness.
10:14:37 <sjanssen> sclv: I recommend keeping a darcs checkout of GHC around, it tends to be very handy
10:15:05 <sjanssen> kjdf: I've used cabal-install, it works fairly well
10:16:25 <sclv> is the speed slowdown in the hashtable due to the IOArray its based on?
10:16:44 <sclv> (i.e. mutable data generally == slow)?
10:18:20 <sclv> ok here's another newb question
10:18:29 <Cale> dons had a funny little graph of the performance of various collection types... where was that again?
10:19:12 <sclv> my getRec function returns something of type IO (Maybe TestRec)
10:19:39 <sclv> so to print the results from the main loop I'm doing (x<- getRec...) followed by (print x)
10:19:50 <sclv> there's got to be a cleaner way, right?
10:20:14 <dv^^> getRec >>= print ?
10:21:50 <sjanssen> or print =<< getRec
10:22:02 <sjanssen> if you squint hard enough, it looks like normal function application :)
10:22:44 <sclv> yep -- that works. anything that's more "sugared" in do notation, or is that always the appropriate way?
10:23:17 <sjanssen> that's the only way without naming the result of getRec
10:23:37 <Philippa> but you can do get =<< getRec in a statement in a do block
10:23:52 <Philippa> er, print =<< getRec even
10:24:12 <sclv> another related question:
10:24:52 <sclv> so I have "f<- recLookup x rc" and then "case f of"
10:25:06 <sclv> is there  a way to get rid of that extraneous binding too?
10:25:21 <sjanssen> not in general
10:25:32 <puusorsa> case (recLookup x rc) of .. ? is that legal?
10:25:54 <sjanssen> puusorsa: legal, but probably not useful
10:25:57 <sclv> it returns an IO (Maybe TestRec)
10:26:05 <sclv> instead of just the Maybe TestRec I want to match on
10:26:21 <sjanssen> case getLine of "foo" -> ... -- isn't going to typecheck
10:26:54 <sjanssen> sclv: in the case of Maybe, you can use maybe
10:26:57 <sjanssen> @type maybe
10:26:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:27:36 <sjanssen> flip fmap recLookup $ maybe (branch for Nothing) (\x -> branch for Just)
10:28:12 <sjanssen> actually, you'll probably want: recLookup >>= maybe (branch for Nothing) (\x -> branch for Just) anyway, which is a bit cleaner
10:28:12 <Cale> http://ircbrowse.com/cdates.html?channel=haskell -- heh, this is a nice graphical representation of #haskell activity
10:28:17 <lambdabot> Title: Meme Channel haskell by Dates
10:30:02 <kjdf> cabal-related question:
10:30:03 <kjdf> Setup.lhs: Warning: Unknown field 'build-type'
10:30:03 <kjdf> Setup.lhs: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly
10:30:10 <kjdf> anything I can do about it?
10:30:20 <kjdf> (this is darcs version of cabal-install)
10:31:07 <sjanssen> kjdf: it might need the recently released Cabal 1.2.0
10:31:34 <sjanssen> kjdf: I forgot to mention that cabal-install itself is a bit of a dependency nightmare
10:31:47 <kjdf> :)
10:34:21 <sclv> oooh -- thanks for the tips. i'm starting to get the sense that do notation is more trouble than its worth about half the time
10:36:12 <dons> sclv: its certainly useful to be able to move between do-syntax, and its desugaring
10:36:12 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
10:36:29 <perspectivet> is anyone here using yi as their editor for haskell?
10:37:04 <nominolo> perspectivet, most likely noone
10:37:19 <sjanssen> perspectivet: plenty of people, do you have a question?
10:37:19 <nominolo> perspectivet, at least not seriously
10:37:28 <nominolo> what?
10:37:39 <sjanssen> oh, _y_ i :)
10:37:48 <nominolo> heh
10:37:56 <sjanssen> I thought nominolo was trolling
10:38:02 <perspectivet> sjanssen: yeah, yi
10:38:11 <nominolo> perspectivet, why you're asking
10:38:15 <sjanssen> perspectivet: in that case, no, probably not
10:38:32 <perspectivet> I'm finding the emacs haskell mode kind of annoying
10:38:38 <perspectivet> And I'm too lazy to fix it
10:38:39 <nominolo> the yi people would welcome any help
10:38:44 <nominolo> heh
10:38:51 <nominolo> perspectivet, what annoys you?
10:38:53 <perspectivet> yeah, it looks like an interesting project
10:39:09 <dons> ?join #bioclipse
10:39:25 <perspectivet> nominolo: the auto-intent mode seems pretty broken when using arrows
10:40:02 <nominolo> yeah, it doesn't know about prog and mdo
10:40:25 <sclv> auto-indent settings seem pretty easy to play with though, no?
10:40:39 * nominolo hasn't tried
10:41:11 <perspectivet> sclv: 10:38 <perspectivet> And I'm too lazy to fix it
10:41:55 <perspectivet> I'd be more interested in investing in improving a haskell based editor than wanking elisp
10:42:16 <perspectivet> just from a scratching-the-itch standpoint
10:42:53 <sclv> i just mean i go to customize in the haskell menu and i can navigate graphically to this handy indent after keywords bit
10:43:10 <sclv> no actual elisp required
10:43:50 <kjdf> how long approximately does full GHC compilation take? :)
10:44:06 <dons> can be as short as 3 mins.
10:44:11 <dons> but usually 10-20x that
10:45:23 <nominolo> kjdf, try setting mk/build.mk to quickest
10:45:26 <sjanssen> kjdf: a default build on my core duo is about 45 min.
10:45:50 <nominolo> sjanssen, do you use make -j4 for this?
10:45:55 <sjanssen> nominolo: yes
10:46:01 <nominolo> that's long
10:46:23 <sjanssen> nominolo: that's with the default "release quality" flags
10:46:54 <sjanssen> nominolo: is that still slow?
10:46:56 <nominolo> ok, i never timed
10:47:09 <dons> dcoutts: tshirt size?
10:47:20 <nominolo> i usually go do something else anyways ;)
10:47:22 <dcoutts> dons: erm, medium I guess
10:47:37 <dcoutts> dons: ta :-)
10:47:43 <dons> ok. done.
10:47:48 <nominolo> dcoutts, i think my wifi problems are solved
10:48:01 <dcoutts> nominolo: yay, more hacking then? ;-)
10:48:10 <dons> dcoutts: i'm getting a business card. feels weird :)
10:48:13 <dcoutts> nominolo: what was the problem in the end?
10:48:16 <dcoutts> dons: hah hah
10:48:23 <nominolo> dcoutts, let me write a better collab editor first ;)
10:48:29 <dcoutts> dons: "Dons. Professional Hacker."
10:48:36 <nominolo> dcoutts, i think it was the gui thingy
10:48:41 <dcoutts> nominolo: heh
10:48:45 <sjanssen> dons: you should put the xmonad logo on it!
10:48:53 <nominolo> dcoutts, it didn't work initially because i had to reboot
10:49:08 <sjanssen> dons: btw, do we have a vectorized version of the logo somewhere?
10:49:14 <nominolo> dcoutts, but i'm really not sure.
10:49:38 <nominolo> ?where xmonad
10:49:39 <lambdabot> http://xmonad.org/
10:49:47 <opqdonut> ?where urmom
10:49:48 <lambdabot> I know nothing about urmom.
10:50:52 <CosmicRay> someone was asking about hsh earlier?
10:51:01 <Esteth> do i need to write a new function if i want to "loop over" a list?
10:51:17 <sjanssen> Esteth: nope, use map, mapM, or forM
10:51:29 <nominolo> :t forM
10:51:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
10:51:35 <Esteth> sjanssen: thanks :)
10:51:42 <sjanssen> or maybe foldr, foldl, or foldM
10:51:48 <sjanssen> there are many sorts of loops ;)
10:51:49 <CosmicRay> Esteth: see map, foldl, foldr, etc...
10:52:12 <perspectivet> sclv: thanks for the tip
10:52:37 <Esteth> sjanssen: That syntax means nothing to me. i don't know anything about monads, arrows, stars, or equal arrows yet. Working through YAHT though, and not finding it too difficult (yet)
10:52:55 <nominolo> :t map
10:52:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:53:07 <nominolo> better? :)
10:53:20 <Cale> Esteth: which syntax?
10:53:40 <Esteth> nominolo: Kind of. i think i get the idea.
10:53:54 <sjanssen> Esteth: most of that type signature is unnecessary junk that ghc prints when extensions are on, "(Monad m) => [a] -> (a -> m b) -> m [b]" is the short version
10:53:55 <Esteth> Cale: "forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]"
10:54:08 <Cale> Esteth: yeah, the whole first part of that is ignorable :)
10:54:25 <Cale> (Monad m) => [a] -> (a -> m b) -> m [b]
10:54:34 <dons> sjanssen: yeah, we do have a proper .svg version david did
10:54:36 <dons> for the tshirt
10:54:59 <cognominal_> :t (:[])
10:55:00 <lambdabot> forall a. a -> [a]
10:55:06 <Cale> That means that it's a function taking a list of values of type a, and a function from values of type a to computations returning a value of type b
10:55:16 <sjanssen> dons: I can't find a link to it anywhere
10:55:18 <Cale> and produces a computation returning a list of values of type b
10:55:33 <kjdf> great. with new cabal cabal-install builds, but missingH won't :)
10:55:38 <Esteth> Cale: That says: "forall is a monad we call m. we take to arguments, a and b. we apply the monad to a, and end up with something of type b" ?
10:55:42 <CosmicRay> what's the problem with missingh?
10:55:49 <cognominal_> @src (:[])
10:55:49 <lambdabot> Source not found. It can only be attributed to human error.
10:55:57 <puusorsa> good morning dave
10:56:06 <Cale> Esteth: The forall quantifies the variables in the type (if you know logic, it's the same forall)
10:56:37 <Cale> It says that for all types a, b, and type constructors m, if m is a monad, then forM has the type ...
10:56:39 <jatqceer> hi, what's the best data type for calculating inverse of a matrix of size 10 times 10?
10:56:50 <nominolo> Esteth, "forall a" speaks "for any type 'a' ..."
10:57:29 <Cale> jatqceer: a matrix of size 10 by 20? :)
10:57:51 <Esteth> Cale: My math ability only reaches final year of high-school stuff so far, unfortunately. I think i understand now, though :)
10:58:08 <jatqceer> Cale: oh, i mean 10 by 10, or something similar
10:58:13 <b_jonas> hello
10:58:24 <b_jonas> so if I want to learn haskell, which document should I read?
10:58:31 <b_jonas> I like language references in general,
10:58:47 <b_jonas> but not the c99-style standards
10:58:49 <Cale> jatqceer: That's a little bit jokingly -- the common way to compute the inverse is to extend the matrix with an identity matrix of the same size, and then do Gaussian elimination
10:58:54 <dons> @seen benl
10:58:55 <lambdabot> I haven't seen benl.
10:59:03 <hpaste>  kjdf pasted "missingH with cabal 1.2" at http://hpaste.org/2728
10:59:27 <CosmicRay> oh, something changed in Cabal 1.2?
10:59:28 <perspectivet> Cale: I usually just use an appropriate blas/lapack binding
10:59:42 <jatqceer> Cale: right.  that's what i'm going to do.  i'm not sure which data type i should use?
10:59:55 <CosmicRay> jkdf: looks like you could put "Right $" before the problem and have it work
10:59:58 <nominolo> kjdf, let me take a look
11:00:01 <kjdf> CosmicRay: maybe I have broken something in the meanwhile, but a short while ago I have successfully build missingH
11:00:09 <nominolo> CosmicRay, the cabal hook interface is completely unstable
11:00:14 <CosmicRay> ah, blah
11:00:20 <kjdf> CosmicRay: since that time I have only installed cabal 1.2
11:00:34 <b_jonas> hmm, http://haskell.org/haskellwiki/Learning_Haskell is a meta-docs, perhaps that's what I should search for in
11:00:35 <lambdabot> Title: Learning Haskell - HaskellWiki
11:00:36 <nominolo> kjdf, yes, that won't work
11:00:47 <b_jonas> that sentence didn't make sense, but still
11:00:58 <nominolo> kjdf, let me see if what the setup.lhs does can be expressed using configurations
11:01:30 <Cale> jatqceer: I suppose it depends on just how efficient you need to be. Plain immutable arrays should do just fine, but having to write a new array for each step of Gauss-Jordan might be considered too costly (though it shouldn't be so bad for such a tiny matrix)
11:02:03 <CosmicRay> nominolo: I would accept a patch for this if it still works with ghc6.6 as it ships in the box
11:02:26 <CosmicRay> cpp is already used in missingh so if we have to revert o tthat, that's ok too
11:02:28 <nominolo> kjdf,well .. unfortunately that won't work
11:02:31 <sclv> for something that small, a list would probably even work fine?
11:02:33 <Cale> jatqceer: If it is too costly though, you could write the algorithm in a mutable way with STArrays, and use runSTArray to get back to an ordinary one.
11:02:52 <nominolo> kjdf, it will require cabal-1.2
11:04:00 <jatqceer> Cale: thanks, i'll try them out
11:04:03 <sclv> you can think of basic gauss steps as folds over a list of rows, i mean
11:04:06 <kjdf> nominolo: what will require cabal 1.2?
11:04:21 <kjdf> nominolo: I think the problem is precisely that I am using cabal 1.2 ...
11:04:29 <Cale> sclv: indeed, you could use lists :)
11:04:32 <jatqceer> sclv: folds over a list of rows?
11:05:07 <nominolo> kjdf, the patch i'll send you in a minute will require cabal-1.2 and break on any older cabal version
11:06:03 <sclv> well, you could for example write a step function that takes the head of a list of rows and maps a function over the rest that eliminates their first term through addition to a multiple of the head...
11:06:44 <sclv> and you could fold that function over a list of terms to be eliminated
11:06:47 <sclv> or something similar
11:07:19 <jatqceer> sclv: actually what you said sounds appealing, since i don't have to write some loop functions over the array
11:07:22 <sclv> anyway, play around with it and poof! explicit-iteration-free(ish) array operations
11:07:57 <jatqceer> what is explicit-iteration-freeish?
11:08:08 <sclv> or recursion-free i should have said
11:09:00 <jatqceer> using array without recursion?  how could that be achieved?
11:09:03 <sclv> anyway my point is just that if you're going to be iterating over the array in some fashion, there's no advantage to the lookuptimes of an array over a linked list
11:09:38 <sclv> explicit recursion -- i.e. you use the built-in recursive functions of map fold, iterate, etc, instead of writing your own
11:09:51 <jatqceer> i second that.  usually i do prefer lists
11:09:56 <hpaste>  esteth pasted "(no title)" at http://hpaste.org/2729
11:10:07 <stepcut> is there a function like, uneither :: [Either a b] -> ([a],[b]), already ?
11:10:19 <kjdf> actually, now that cabal-install is installed, I think I could just move back to cabal-~1.1.6
11:10:46 <Esteth> Could anyone tell me why the code in that paste errors with "Couldn't match expected type `[a]' against inferred type `IO ()'" ?
11:11:25 <hpaste>  nominolo pasted "MissingH.cabal-1.2" at http://hpaste.org/2730
11:11:40 <Cale> Esteth: let numbers = getNumbers just defines numbers to be the same IO action as getNumbers
11:11:58 <dons> ?users
11:11:58 <Cale> To actually run getNumbers, you want  numbers <- getNumbers
11:11:59 <lambdabot> Maximum users seen in #haskell: 407, currently: 389 (95.6%), active: 22 (5.7%)
11:12:02 <nominolo> kjdf, try that
11:12:19 <Cale> Esteth: does that make sense?
11:12:35 <Esteth> Cale: ahh. so "=" actually means "is equal to", wheras "<-" is "assign the value to" ?
11:12:51 * stepcut finds 6 distinct hits for  [Either a b] -> ([a],[b]) on google code search :)
11:12:51 <opqdonut> <- is "execute action and assign value"
11:12:53 <kjdf> a stale question:
11:12:53 <kjdf> Is anyone here familiar with Control.Arrow.Transformer.Automaton from arrows package?
11:12:53 <kjdf> I don't know how to build a non trivial automaton without access to constructor, that is
11:12:53 <kjdf> how to switch states
11:12:53 <kjdf> (I could build a switching combinator using automaton constructor, but it isn't exported)
11:12:55 <Cale> Well, v <- x means "run x and call the result v"
11:13:03 <nominolo> dcoutts, any idea how to fix those kinds of build problems?
11:13:22 <nominolo> dcoutts, i think we want versioned setup.lhs and .cabal files
11:13:24 <Esteth> Cale: Ok, thanks for the help :)
11:13:25 <byorgey> stepcut: I remember it being discussed in here at some point, but I don't think it's already in the libraries
11:13:45 <Cale> v isn't really a mutable cell -- it's just a variable which will be bound to the result of running x for the rest of the do-block (or until it's shadowed by another binding to v, though we don't tend to do that)
11:14:04 <nominolo> dcoutts, ie, Setup.1.2.lhs requires Cabal-version >= 1.2
11:14:22 <byorgey> stepcut: I think someone came up with a super-slick implementation using arrows and applicative functors, or somesuch =)
11:14:32 <nominolo> dcoutts, or make the hooks be versioned
11:16:12 <kjdf> nominolo: this doesn't seem to do anything.. I get exactly same error
11:16:15 <nominolo> kjdf, oh, and the setup.hs file should be the default setup file
11:16:28 <nominolo> http://darcs.haskell.org/cabal/DefaultSetup.lhs
11:16:35 <olsner> :t either
11:16:37 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:18:08 <stepcut> the slickest implementation I have seen is:
11:18:10 <kjdf> nominolo: now it works. thanks!
11:18:13 <stepcut> > let catEithers es = ([x | Left x <- es], [x | Right x <- es]) in catEithers [Left 1, Right 2, Left 3, Right 4]
11:18:15 <lambdabot>  ([1,3],[2,4])
11:18:18 <stepcut> by bringert
11:18:25 <hpaste>  DukeDave pasted "GADTs and list processing" at http://hpaste.org/2731
11:18:39 <olsner> > foldr (either (first . (:)) (second . (:))) ([],[]) [Left 1, Right 2, Left 3, Right 4]
11:18:40 <lambdabot>  ([1,3],[2,4])
11:18:43 <stepcut> not the most efficient though, as I assume it requires two passes
11:18:58 <stepcut> (bringerts, that is)
11:19:14 <DukeDave> Hey could someone take a quickly look at that paste for me, I'm  troubled by it and running out of time for the project :(
11:20:08 <olsner> > foldr (either (first . (:)) (second . (:))) ([],[]) (repeat (Left 1))
11:20:10 <lambdabot>  ([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:20:32 <olsner> Lo! 'twas lazy ;-)
11:21:07 <nominolo> kjdf, you can of course try hiding cabal-1.2
11:22:07 <EvilTerran> DukeDave, could you just unwrap the [(Double,Double)] from the newtype, pass it to the existing function, when wrap it again?
11:23:04 <sclv> DukeDave: write yr own special dfcons function?
11:23:25 <hpaste>  EvilTerran annotated "GADTs and list processing" with "something like this" at http://hpaste.org/2731#a1
11:23:30 <DukeDave> EvilTerran: Yeah that's my current fix, junction is part of an instance declaration so I've renamed junction to junction' and then junction is just an unwrapper
11:23:49 <DukeDave> sclv: That's an interesting way to look at it
11:24:07 <DukeDave> Essentially it's just me not thinking it's a nice solution :)
11:24:31 <EvilTerran> meh, that's what i'd do
11:25:14 <DukeDave> Ah a lot neater with the record(?) name
11:25:44 <EvilTerran> using newtype DF = DF { df :: [(Double,Double)] } means you could unwrap fairly succinctly within the defn of junction, if you preferred
11:26:30 <EvilTerran> and it's mildly shorter than writing df (DF x) = x seperately, altho i get the impression that idiom is a bit disliked by some
11:26:35 <EvilTerran> anyhow
11:26:36 <EvilTerran> away!
11:26:58 <DukeDave> Woop thanks kindly both :)
11:26:59 <DukeDave> EvilTerran++
11:27:08 <DukeDave> sclv++
11:31:20 <Armor_Azrael> Hey. How do I get a backtrace after an error is set?
11:32:00 <Cale> Armor_Azrael: You can get something sort-of backtrace-ish by compiling with -prof -auto-all and running the program with +RTS -xc
11:32:10 <quicksilver> @seen tora
11:32:10 <lambdabot> I saw tora leaving #haskell 11m 35s ago, and .
11:32:15 <quicksilver> bah! timing
11:32:40 <quicksilver> Cale: You know the idea of newtype'ing IO to partition some class of effects into its own type?
11:32:46 <Cale> quicksilver: yeah
11:33:03 <quicksilver> Cale: have you seen the typeclass trick so that you don't need explicit 'runFoo's all around?
11:33:59 <Cale> Well, you could make a typeclass with the operations you want and then write polymorphic code...
11:34:10 <Armor_Azrael> Cale: How does one tell cabal to add -prof -auto-all
11:34:11 <quicksilver> no, it's simpler than that
11:34:12 <Cale> (where IO is an instance of your class)
11:34:12 <Armor_Azrael> y?
11:34:29 <quicksilver> Cale: ok, I'll post it to haskell-cafe
11:34:31 <Armor_Azrael> *?
11:34:36 <quicksilver> Cale: I wasn't sure if it was totally obvious or not :)
11:34:57 <Cale> Armor_Azrael: I think maybe  Ghc-options: -prof -auto-all
11:35:02 <Cale> (in the .cabal)
11:35:12 <Cale> quicksilver: what is it?
11:35:47 <hpaste>  quicksilver pasted "MonadGL" at http://hpaste.org/2732
11:35:57 <quicksilver> Cale: there :)
11:36:07 <quicksilver> Cale: code is at the bottom you don't need to read the words
11:37:22 <Cale> Um, isn't that what I just described?
11:37:30 <quicksilver> probably, yes :)
11:37:42 <Cale> Er, I suppose it's slightly different
11:37:44 <quicksilver> Cale: but it's not what I understood from what you said
11:37:54 <quicksilver> Cale: I thought your typeclass was going to have the whole bunch of operations
11:38:22 <quicksilver> this method lets you add operatons using unsafeIOToGL (which is presumably private to some chunk of the module hierarchy)
11:38:34 <Armor_Azrael> Cale: I know this is somewhat random, but do you happen to know how to enable profiling for HSSL? It doesn't appear to be on in the regular package
11:38:38 <quicksilver> and outside that chunk, where it's hidden, it is safe
11:39:14 <Cale> Armor_Azrael: nope, I haven't played around with that package at all
11:40:10 <Armor_Azrael> Cale: OK, thanks anyways... this is going to take forever to find
11:40:20 <Cale> Armor_Azrael: what error are you getting?
11:41:04 <Armor_Azrael> flat: nonconformant matrices in liftMatrix2'
11:41:21 <Armor_Azrael> Which more or less means I'm multiplying matrices of the wrong dimensions somewhere.
11:41:27 <Cale> okay
11:41:45 <Armor_Azrael> I just was hoping not to have to check all of the multiplications manually
11:41:50 <Cale> Is that error coming from library code, or from your own code?
11:42:07 <Armor_Azrael> The library issues it
11:42:15 <Armor_Azrael> (It's a GSL wrapper)
11:44:39 <Cale> Calls to error really are a pain in the ass. Things should use Maybe more often.
11:45:13 <Cale> (Though I can see how making matrix multiplication use Maybe might be somewhat annoying ;)
11:46:18 <Cale> Armor_Azrael: The next version of GHC will include a nice debugger in GHCi which is supposed to be able to catch such things. It's still a little buggy, but you might try it if you're desperate.
11:47:18 <Cale> Armor_Azrael: How large is the piece of code that you're working on? I could perhaps help try to find the problem.
11:48:21 <Armor_Azrael> It's not that big I don't think
11:48:39 <Cale> Could you put it on HPaste?
11:48:41 <Armor_Azrael> It's also not particularly useful, nor will it ever be. It's really just a toy--I'd hate to waste your time
11:49:58 <Armor_Azrael> It's about 1500 lines. If you actually want to look, I'm putting it on hpaste now
11:50:02 <Cale> okay
11:50:19 <Cale> That might be a little large for HPaste -- you might have to chop it into sections.
11:50:23 * byorgey scratches head.  1500 lines == "not that big" ?
11:50:32 <Cale> 1500 lines is a fairly large Haskell program :)
11:50:47 <Armor_Azrael> It's a 3d renderer without video card
11:50:54 <stepcut> that's 3 times bigger than my window manager ;)
11:51:04 <Armor_Azrael> If you want I can serve it up in a tarball
11:51:09 <Cale> At least, I've written 600 line Haskell programs which would have been 15000 line C programs :)
11:51:14 <byorgey> hmm, I wonder what WM stepcut is using? =)
11:51:19 <fax> hiya
11:51:20 <stepcut> xmonad of course
11:51:32 <byorgey> hi there fax
11:51:51 * byorgey should actually get around to trying xmonad at some point...
11:52:20 <Armor_Azrael> Cale: If I could get tips on how to write in haskell better, that'd be great too, one moment while I tar it up and upload
11:53:46 <Esteth> why would "input <- getLine" inside a do-block throw a "parser error on input <-" ? I can't see anything wrong :S
11:54:08 <Cale> Esteth: perhaps indentation?
11:54:21 <Armor_Azrael> http://www.its.caltech.edu/~maurer/FrozenRender-0.1.tar.gz
11:54:26 <Heffalump> check it's lined up with the rest of the do-block
11:54:26 <Cale> Esteth: make sure there are no tab characters in your source file
11:55:09 <fax> Which is the best written Prolog in Haskell I could find?
11:55:12 <Esteth> Cale: There's no tab characters. Perhaps 4 spaces is not right?
11:55:17 <fax> er.. that you've seen
11:55:55 <Cale> Esteth: If it's lined up with the rest of the do block, and it's not the last line of the do-block, it should be okay.
11:56:22 <Esteth> Cale: it is, i'll pastie the file, just a sec
11:56:48 * stepcut used his first n+k pattern ;)
11:56:56 <hpaste>  esteth pasted "input <- parse error" at http://hpaste.org/2733
11:57:16 <fax> stepcut: :o you've been seduced by the Dark Side@
11:57:24 <byorgey> stepcut, you should be ashamed of yourself ;)
11:57:33 <fax> hehe
11:57:57 <stepcut> but it made so much sense! http://www.haskell.org/pipermail/glasgow-haskell-users/2007-September/013073.html
11:57:58 <heanol> -> http://uptr.pl/jg
11:57:59 <lambdabot> Title: ANNOUNCE: GHC 6.8.1 Release Candidate, http://tinyurl.com/328f6s
11:58:00 <lambdabot> Title: ANNOUNCE: GHC 6.8.1 Release Candidate
11:58:00 <sjanssen> Esteth: "let numbers <- getNumbers" is wrong
11:58:13 <Cale> Esteth: yeah, that let is spurious :)
11:58:22 <fax> ugh @ heanol
11:58:49 <sjanssen> Esteth: also, you'll have trouble with the putStrLns directly below that
11:59:19 <astrolabe> Hey.  Dons is famous :) http://gnuvince.wordpress.com/2007/09/12/celebs-on-reddit/
11:59:21 <lambdabot> Title: Celebs of Reddit « Occasionally sane
11:59:31 <astrolabe> and augustss
12:00:07 <Esteth> sjanssen / Cale: Thanks, and yeah, i'm having trouble with the putStrLns. I suppose it's because num is some kind of function that lets me get an integer, but isn't actually an integer?
12:00:49 <Cale> Esteth: it's because you need some parens
12:01:05 <fax> hm, so no one know of a particular prolog written in idiomatic haskell?
12:01:14 <Ben`> are there any smaller-than-HAppS web frameworks for Haskell?
12:01:15 <Cale> Esteth: putStrLn "The sum is " ++ (foldr (+) numbers) is the same as: (putStrLn "The sum is ") ++ (foldr (+) numbers)
12:01:43 <Cale> also  foldr takes more parameters than that
12:01:48 <stepcut> Ben`: hope ?
12:01:54 <Cale> You probably want foldr (+) 0 numbers
12:02:18 <Ben`> stepcut: thanks
12:02:28 <Cale> putStrLn ("The sum is " ++ (foldr (+) 0 numbers))
12:02:30 <Cale> should work
12:02:31 <stepcut> Ben`: in someways the answer is no. You can start with the simple CGI library, but by the time you integrate databases, etc, you are probably bigger than HAppS ?
12:02:42 <Cale> Or:  putStrLn $ "The sum is " ++ foldr (+) 0 numbers
12:02:59 <Cale> actually, the inner parens aren't needed in the first case either
12:03:11 <Cale> er, also
12:03:15 <Cale> blah :)
12:03:22 <Cale> The number needs to be converted to a string
12:03:25 <Esteth> Cale: Okies. This takes a lot of getting used to from ruby :(
12:03:34 <fax> I think I found a small project to do then :D
12:03:36 <Cale> putStrLn ("The sum is " ++ show (foldr (+) 0 numbers))
12:03:41 <Ben`> stepcut: hmm, ok
12:03:43 <Cale> or:
12:03:49 <Cale> putStrLn ("The sum is " ++ show (sum numbers))
12:03:57 <Ben`> problem is I can't get some of the HAppS deps to compile
12:04:03 <Cale> since sum is already a Prelude function :)
12:04:06 <Cale> (as is product)
12:05:10 <Esteth> Cale: ahh, cool. Is there some kind of "Every single function in the haskell standard library" reference?
12:05:18 <Armor_Azrael> HHL
12:05:36 <Armor_Azrael> Haskell Hierarchical Libraries
12:05:44 <sjanssen> @docs
12:05:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:05:48 <sjanssen> Esteth: ^^^
12:06:03 <Esteth> sjanssen: Thanks :)
12:06:05 <quicksilver> cale
12:06:26 <stepcut> Esteth: also try http://haskell.org/hoogle
12:06:27 <lambdabot> Title: Hoogle
12:06:30 <quicksilver> well not that original then
12:06:32 <Cale> quicksilver: yes?
12:06:36 <quicksilver> :)
12:06:42 <quicksilver> but might provoke some thought
12:06:47 <stepcut> Ben`: which version of HAppS ? the 0.8.x or 0.9.x ?
12:07:01 <Ben`> stepcut: the one from darcs
12:07:03 <quicksilver> there is definitely not wide enough understanding of good ways to combine haskell libraries
12:07:09 <Cale> quicksilver: Oh, yeah, that trick is useful, for sure :)
12:07:10 <quicksilver> (especially callbacks + custom monads)
12:07:36 <Esteth> stepcut: Thanks :)
12:07:43 <Cale> I think the explicitness is usually a good thing.
12:08:32 <Cale> Though if we wanted a fully stratified IO with every imaginable type of effects split off and recognisable by the type, then we'd have issues :)
12:09:08 <quicksilver> yes, it's not clear how well it scales
12:09:13 <quicksilver> openGL is a rather clear-cut example
12:09:23 <quicksilver> openGL is a well defined 'mini-state machine'
12:09:46 <quicksilver> and it's certainly incapable of file IO and stuff
12:10:13 <Cale> Right, it's a fairly well-defined monad unto itself -- you can almost imagine running it in some other context altogether :)
12:10:49 <quicksilver> like on a graphics card
12:10:50 <fax> I thought GL is a really big state machine :S
12:10:54 <quicksilver> or against a remote server
12:11:05 <quicksilver> or 'recording' the calls and playing them back later
12:11:33 <Cale> Esteth: oh, I should also point out: http://haskell.org/onlinereport/standard-prelude.html
12:11:33 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
12:11:48 <Cale> Esteth: that's worth reading on its own
12:11:53 <Lemmih> Ben`: What dependency?
12:12:16 <Ben`> Lemmih: default
12:12:32 <Esteth> Cale: ooh, thanks. Such a friendly community here :
12:12:39 <Esteth> s/ :/ :)
12:13:06 <Ben`> Lemmih: I get, "No instance for (Data DefaultD BSC.ByteString)"
12:13:37 <Saizan_> Ben`: you need the darcs version of syb-with-class
12:13:59 <Ben`> oh, ok
12:14:02 <Ben`> I'll give that a go
12:14:05 <Ben`> thanks
12:16:23 <sioraiocht> Cale: Will the prelude be reworked in Haskell'?
12:16:44 <Cale> sioraiocht: I kind of hope so, but maybe not.
12:17:08 <sioraiocht> cuz there's some strange stuff in there in terms of what gets put in/not put in
12:17:14 <Cale> I just hope it's eventually reworked. I don't care if it's reworked and then standardised.
12:17:30 <Cale> Personally, I don't really care much for this overstandardisation :)
12:17:41 <sioraiocht> lol
12:17:51 <Cale> It makes it hard to change things out from under everyone :)
12:18:01 <sioraiocht> is a standard prelude really even necessary?
12:18:33 <Cale> Well, it's necessary if you have the rest of the standard, but it could be made smaller
12:18:57 <sioraiocht> like I think most list stuff (the folds, null, etc) shoudl be taken out
12:19:00 <Cale> (though I really like having a large and useful prelude, I just wish it was more flexible to change)
12:19:36 <Cale> List stuff is kind of crucial to the way people program in Haskell.
12:19:46 <Cale> Lists are effectively our loops.
12:20:58 <Cale> While I understand the desire to generalise list syntax to other sequence types, it also kind of rattles me, because lists really are special. No other data structure captures linear recursion in quite the way that they do.
12:21:20 <sioraiocht> I know
12:21:24 <sioraiocht> but lots of tings are Foldable
12:21:29 <sioraiocht> Traversable, etc
12:21:32 <Cale> right
12:21:59 <sioraiocht> it's be nicer if imports of functions like foldr could be hierarchical, and GHC coudl resolve name conflicts
12:22:10 <Ben`> Saizan_: that worked, but now generic-xml won't compile, it says "`H.Content' is not applied to enough type arguments"
12:22:32 <idnar> HAppS seems rather eccentric
12:23:22 <sioraiocht> i.e. all definitions of foldr arise from Data.Foldable, and if you import List you get Data.Foldable's definitions, but if you import Foldable for another purpose there's no conflict
12:23:33 <sioraiocht> would be nice, dunno if that's possible, certainly non-trivial
12:23:42 <Cale> Esteth: You might find it strange at first that actions aren't run automatically when used as parameters to other functions (as is the case in basically every other language), but it has some very nice consquences which make up for the inconvenience.
12:24:31 <dolio> Generalizing foldr/etc. to Data.Foldable is one thing. Making '[1..3]' and such polymorphic is another.
12:24:58 <sioraiocht> dolio: you don't think .. should generalise to Enum?
12:25:04 <Saizan_> idnar: happs has been recently refactored and it mostly needs documentation
12:25:15 <Cale> sioraiocht: no, he's talking about the sequence type involved
12:25:18 <dolio> It is generalized to Enum. I mean generalizing it beyond [].
12:25:24 <sioraiocht> OH
12:25:31 <sioraiocht> yeah that would be dumb
12:25:50 <sioraiocht> so you could have .. generate a Tree of enums, for example?
12:25:51 <sioraiocht> lame
12:26:05 <Cale> Or [1,2,3]
12:26:14 <dolio> Well, Data.Sequence and Data.Set would be more realistic examples.
12:26:18 <matthew-_> now, assume I have an image in any "standard" format (jpeg, png, tiff, gif). What's the easiest way, in Haskell, to load that image into a matrix of rgb(a) values?
12:26:35 <sioraiocht> dolio: sorry, right, either way, i agree that notation belongs in the list and only list
12:27:04 <dolio> I can't say I've made up my mind, but I'd probably lean that way right now.
12:27:17 <augustss> List notation should be overloadable.
12:27:30 <augustss> IMO
12:27:46 <dolio> Although I want lots of other stuff to be more polymorphic, so maybe I should want list listerals to be so, too. :)
12:28:13 <sioraiocht> dolio: what other sorts of stuff?
12:28:26 <Cale> Perhaps with a defaulting rule like we have for numbers it would be okay.
12:28:27 <Esteth> Cale: I suppose it means we can make variable names point to functions/actions, but wouldn't it be more 'normal' to let the programmer make that explicit, instead of the other way around?
12:28:43 <dolio> map/fold/(++)... list comprehensions => monad comprehensions...
12:29:29 <Cale> Esteth: Because actions don't run automatically when you pass them to functions, it means that you can have functions which take a bunch of actions and combine them in some way -- that is, you can write your own control structures.
12:29:51 <Esteth> Cale: ohh, cool!
12:29:56 <dolio> Generally, I'd take all the prelude functions that are generalized in Data.Whatever and replace them with the latter.
12:30:28 <sioraiocht> dolio: so you want like... map :: Mappable t => (a -> b) -> t a -> t b ?
12:30:39 <Cale> Esteth: a simple example of this which I think illustrates it nicely is the function  sequence  which takes a list of actions and combines them into a single action which will run them all and produce a list of results.
12:30:41 <dolio> Although, you have to make some tough choices in some cases. Like, is (++) MonadPlus or Monoid?
12:30:44 <Cale> sequence [] = return []
12:30:55 <dolio> sioraiocht: map :: Functor f (a -> b) -> f a -> f b
12:31:01 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs)
12:31:05 <dolio> Er, put a => in there.
12:31:06 <Cale> er }
12:31:13 <sioraiocht> :t fmap
12:31:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:31:20 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
12:31:38 <sioraiocht> :t ap
12:31:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:32:01 <dolio> @type Data.Foldable.mapM_
12:32:02 <Cale> To give a more restrictive type than necessary:  sequence :: [IO a] -> IO [a]
12:32:02 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => (a -> m b) -> t a -> m ()
12:32:06 <dolio> There's another.
12:32:16 <Esteth> Cale: Nice, i can definitely see that sort of stuff being useful. Thanks for the help :)
12:32:54 <Cale> Esteth: Haskell doesn't come with a for-each loop, for instance, but you can easily write one. (And there is one in the hierarchical libraries)
12:33:05 <Cale> forM xs f = sequence (map f xs)
12:33:36 <Cale> Here xs is the list to iterate over, and f is the loop body, which is a function from an element of the list, to an action to be performed.
12:33:49 * Esteth hugs the code. It's so elegant :D
12:34:00 <roconnor> @type mapM
12:34:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:34:07 <Cale> So map f xs will apply f to each element of the list, getting a list of actions, and then sequence puts that list of actions together into a loop.
12:34:07 <roconnor> @type forM
12:34:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
12:34:18 <roconnor> @src forM
12:34:18 <lambdabot> forM = flip mapM
12:34:56 <roconnor> @src mapM
12:34:57 <lambdabot> mapM f as = sequence (map f as)
12:35:41 <idnar> @src mapM_
12:35:41 <lambdabot> mapM_ f as = sequence_ (map f as)
12:36:04 <Cale> The _ versions just throw the list of results away
12:36:28 <Cale> So might save some memory, but otherwise they're the same thing.
12:43:00 <Mitar> i would like to map a list of data Foo = Foo Bar Kar, where Bar and Kar are also data types, but I would like only to use Kar in a map
12:43:16 <Mitar> map (dosomething . getKar) listFoos
12:43:27 <Mitar> what would be simple getKar?
12:44:21 <ClaudiusMaximus> Mitar: getKar (Foo _ k) = k ?
12:44:30 <roconnor> data Foo = Foo { getBar :: Bar, getKar :: Kar }
12:45:02 <roconnor> in either case you end up with getKar :: Foo -> Kar
12:46:00 <Mitar> thanks
12:55:56 <boyscared> the haskell book i'm working through uses div on hugs in this manner: 4 'div' 0
12:56:08 <Heffalump> those are probably backquotes: `div`
12:56:12 <Heffalump> but dividing by 0 seems a bit odd.
12:56:16 <boyscared> but div :: Int -> Int on my install
12:56:25 <Heffalump> it should be Int -> Int -> Int
12:56:32 <boyscared> yes, that
12:56:56 <Heffalump> yes, that to what? The backquotes or the type?
12:57:01 <fax> blerk
12:57:03 <boyscared> the type
12:57:10 <Saizan_> > 4 `div` 0
12:57:12 <lambdabot>  Exception: divide by zero
12:57:13 <Heffalump> ok, so do you know what backquotes do?
12:57:13 <fax> emacs mode for haskell is impossible to use right now
12:57:28 <Saizan_> fax: why?
12:57:39 <boyscared> oh, i thought those were single quotes
12:57:40 <boyscared> thanks :)
12:57:42 <fax> tabs and spaces are all messed up
12:58:56 <boyscared> i can guess what they do now.. infix notation, i presume
12:59:02 <Heffalump> yep
12:59:25 <kjdf> is there a way to automatically build haddock docs when installing cabalized package?
12:59:36 <gwern> > :t (^)
12:59:37 <lambdabot>   parse error on input `:'
13:00:26 <Saizan_> kjdf: runhaskell Setup haddock
13:00:26 <gwern> kjdf: sure. there's even a cabal command for that
13:00:40 <gwern> > 1 ^ (1/3)
13:00:41 <lambdabot>  Add a type signature
13:00:46 <kjdf> thanks
13:00:55 <Saizan_> :t (^)
13:00:57 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:01:09 <kjdf> btw thanks, sjanssen, cabal-install seems to work nice
13:01:14 <gwern> ...what? 1 is integral, and 1/3 is a number
13:01:37 <sjanssen> gwern: look more closely
13:01:40 <Armor_Azrael> gwern: Look the order
13:02:10 <gwern> oh. why is the type of the second argument given first? o.0
13:02:11 <Armor_Azrael> gwern: If you're trying to exponentiate, you prolly want **
13:02:31 <sjanssen> gwern: the types of the arguments are given in order
13:02:48 <sjanssen> x ^ y is (^) x y
13:03:07 <Armor_Azrael> sjanssen: I think he's referring to the typeclass qualifiers
13:03:08 <gwern> sjanssen: what I men is I was confused, since the forall goes a-b, and the currying goes a-b, but the constraints goes b-a!
13:03:46 <sjanssen> oh, the constraint orders are probably alphabetical order
13:04:27 * gwern thinks that is ridiculous. does anyone know why it is done like that, whether it can be changed?
13:05:05 <sjanssen> gwern: it's just the way GHC prints it out
13:05:06 <kjdf> Running Haddock for MissingH-0.18.6...
13:05:06 <kjdf> haddock: /usr/share/ghc-6.6/html/libraries/unix/unix.haddock: openBinaryFile: does not exist (No such file or directory)
13:05:09 <sjanssen> the order doesn't matter
13:05:25 <Armor_Azrael> kjdf: Then install haddock?
13:05:29 <gwern> I see. should I file a bug or something?
13:05:33 <sjanssen> gwern: no
13:05:35 <kjdf> I remember successfully running haddock manually on my own code
13:05:46 <sjanssen> gwern: IMO, at least -- it doesn't seem like a problem
13:05:58 <gwern> (because that really annoys me that I misunderstood because of a totally arbitrary and pointless break in consistency)
13:05:59 <Armor_Azrael> kjdf: Type "which haddock"
13:06:09 <Armor_Azrael> Then symlink that to the location provided in that error msg
13:07:26 <fax> grr
13:07:39 <fax> I want to write a Prolog in haskell... but I can't find any formal definition of the syntax
13:07:46 <fax> (to make a parser with Parsec)
13:07:52 <gwern> sjanssen: so cabal-install is supposed to automatically download cabalized/on-hackage packages? so one could go cabal-install xmonad and it would dl/install x11, x11-extras, and then xmonad?
13:08:01 <sjanssen> gwern: yes
13:08:38 <dolio> Prolog isn't too tough, is it?
13:08:56 <fax> I guess not.. could always just change stuff when tests break
13:09:03 <dolio> atoms: [A-Za-z][A-Za-z0-9]* ...
13:09:18 <fax> I got ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_"
13:09:27 <gwern> sjanssen: does it integrate with one's system-wide package manager or is everything installed locally?
13:09:35 <dolio> predicates: atom(atom [, atom ...])
13:09:44 <sjanssen> gwern: it doesn't integrate with the package manager
13:09:51 <sjanssen> gwern: it install into $HOME by default
13:10:09 <dolio> I guess variables start with a capital, so take that out of the atoms.
13:10:48 <gwern> that makes sense. kind of pointless to duplicate the package manager and also require root
13:11:07 <kjdf> haddock (ran from within Setup.hs) seems to run out of stack space. How to remedy that?
13:11:29 <Armor_Azrael> +RTS K128M
13:11:31 <Armor_Azrael> or similar
13:11:36 <Armor_Azrael> err
13:11:40 <Armor_Azrael> +RTS -K128M
13:11:42 <Armor_Azrael> or similar
13:11:43 <Armor_Azrael> :P
13:11:45 <fax> dolio: What baffles me is the ISO standard draft doesn't have a definition of the syntax!
13:11:50 <fax> so I keep searching :S
13:11:52 <dolio> Heh.
13:12:16 <kjdf> Armor_Azrael: but how to pass that on to haddock?
13:12:58 <Armor_Azrael> Oh
13:13:00 <agocorona> Dons: Finally was solved the hs-plugins problem with Windows?
13:13:37 <Armor_Azrael> This is a hack, but the best plan I have would be to remove that symlink and replace it with a shell script that grabs its arguments, and does
13:13:37 <Armor_Azrael> haddock $args +RTS -K128M
13:13:53 <psnively> That reminds me: does anyone understand under what circumstances GHC stack-allocates? I'm getting a fair amount of flak for darcs running out of stack space (not heap space!) when manipulating large-ish files.
13:14:03 <kjdf> Armor_Azrael: sounds ok
13:15:33 <sjanssen> psnively: AFAIK, only the call stack is on the stack
13:16:05 <psnively> So the implication is that darcs is doing something perhaps nastily recursive over files?
13:16:08 <Armor_Azrael> So if your diff between files in for example, conflict resolution, is recursive, on large files...
13:16:12 <Armor_Azrael> Yes
13:16:24 <psnively> Gotcha, thanks!
13:16:28 <Armor_Azrael> (I've experienced what
13:16:28 <sjanssen> psnively: yeah, or maybe something like (foldr (+))
13:16:42 <Armor_Azrael> you're talking about with darcs, and for me it was in conflict resolution on a large data file)
13:16:46 <psnively> sjanssen: Good point.
13:17:20 <psnively> We got stack overflows just adding a handful (6-8) of 3.5M binary files.
13:17:30 <psnively> The team here is pretty disillusioned with darcs.
13:17:41 <kjdf> haddock: Data.Binary.getWord8: end of file
13:17:45 <psnively> Which, IMHO, is a shame, but there's little I can do about it.
13:17:58 <kjdf> I must be doing something wrong :)
13:18:10 <Heffalump> it has a lot of warts, but a very cool underlying model that works really nicely when you're not hitting the warts
13:19:17 <psnively> Yeah. My argument is: we learned we need to set GHCRTS appropriately and ulimit -s. It's pokey over SSH. But isn't it nice how it works once you know that?
13:19:42 <psnively> The team's response is along the lines of: 20 seconds to push is too long.
13:20:11 * psnively shrugs.
13:22:24 <Heffalump> it runs very slowly for us on Windows, too. Often for random undiscernible reasons.
13:22:36 <Heffalump> But it's still much nicer to use than Clearcase, which is unpleasant and painful every single time.
13:22:42 <quicksilver> Heffalump: it's not clear the underlying model *does* work realy nicely
13:22:54 <Heffalump> "when you're not hitting the warts"
13:22:57 <quicksilver> Heffalump: it is suspected that it may have non-terminating behaviour
13:22:58 <pejo> psnively, is pushing that common?
13:23:04 <Heffalump> not non-terminating, exponential.
13:23:08 <psnively> pejo: Multiple times per day.
13:23:09 <quicksilver> Heffalump: or possibly "just" double exponential blow-up
13:23:11 <Heffalump> But droundy is hot on the case.
13:23:14 <quicksilver> Heffalump: has that been proven?
13:23:24 <Heffalump> there's no reason it'd be double-exponential.
13:23:26 <phobes> psnively, what team are you on?
13:23:27 <hpaste>  eck pasted "simple question" at http://hpaste.org/2734
13:23:36 <conal> agocorona: what have you heard about hs-plugins & windows.  i'm very interested in that combo.
13:23:39 <psnively> phobes: http://www.virgincharter.com
13:23:39 <quicksilver> Heffalump: I know that roundy believes he knows the solution, and I hope he's right
13:23:40 <lambdabot> Title: Virgin Charter
13:23:41 <eck> can someone explainto me how to get that to work how i think it should work>
13:23:51 <Heffalump> he's described it to me and I mostly believe in it
13:23:56 <quicksilver> Heffalump: but it's certainly not simple enough to be obvious :)
13:24:21 <psnively> I think everyone's satisfied that the double-exponential algorithm is terminating (although I'm tempted to model it in Coq and prove it). :-)
13:24:37 <oerjan> eck: add . fromIntegral to the end
13:24:40 <Heffalump> I think it actually has some real error cases too.
13:24:46 <eck> oerjan: thanks
13:24:54 <Heffalump> but it doesn't loop, it just errors out, then.
13:24:58 <oerjan> @quote fromIntegral
13:24:59 <fax> How do you actually model some haskell code in Coq?
13:24:59 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
13:25:14 <phobes> psnively:  are you the rocket scientist?  the captain of industry?  or one of the MBAs?  ;)
13:25:43 <psnively> fax: You don't; you model the algorithm (and then extract Haskell code if you wish).
13:25:52 <fax> how?
13:25:54 <psnively> phobes: Mercifully, none of the above. :-)
13:26:01 <psnively> fax: What do you mean, "how?"
13:26:29 <quicksilver> psnively: it's possible to make the algorithm pretty much just a straightforward syntactic transform of the haskell code, though
13:26:33 <quicksilver> psnively: or, vice versa
13:26:57 <psnively> Right: the critical thing is to actually have an algorithm. :-)
13:27:23 <Igloo> psnively: I'm pretty sure it would be easy to prove termination by structural induction
13:27:39 <psnively> igloo: My point exactly.
13:28:23 <psnively> fax: To answer your perfectly good question, actually, see http://coq.inria.fr
13:28:24 <lambdabot> Title: The Coq proof assistant
13:28:45 <psnively> Er, http://www.labri.fr/perso/casteran/CoqArt/index.html
13:28:46 <lambdabot> Title: Coq'Art Home page
13:28:52 <fax> thank you
13:29:06 * sorear wants an easy to use polynomial time VCS
13:29:08 <psnively> That's a whole book on the subject, but you can start with the Coq tutorials, actually.
13:30:55 <Heffalump> what does ARR_WORDS mean in a -hd heap profile?
13:31:13 <psnively> One sentence answer: Thanks to the Curry-Howard Isomorphism, you can think of Coq as a pure dependently-typed functional language with guaranteed termination, so if you can model the algorithm in Coq without embedding general recursion, then the algorithm terminates.
13:31:38 <psnively> And then, as a bonus, Coq proofs can be extracted to Scheme, OCaml, or Haskell coe.
13:31:40 <psnively> Code, even.
13:31:45 <sorear> Heffalump: that's the #defined name for the (Mutable)ByteArray# tag
13:32:08 <Heffalump> hmm. I wonder why I've got 400M of it while processing a 600K file, then.
13:32:29 <Heffalump> I'd been assuming it was a closure.
13:32:36 <sorear> Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe.
13:32:53 <Heffalump> sorear: it could if you added time steps to your model
13:32:59 <sorear> Heffalump: someone foolishly using cons on bytestrings as if it was O(1)
13:33:15 <sorear> ?
13:33:20 <Heffalump> that sounds like the kind of stupid thing I'd be doing, yes.
13:33:22 <psnively> sorear: Right. That's a software engineering problem, not a computer science problem. ;-)
13:33:51 <psnively> Yeah, there's some initial work on measuring runtime complexity in Coq.
13:34:14 <Heffalump> so what'll happen when you use cons? Will you get a quadratic blowup up to the point where a fresh block gets allocated, and sharing (of the old full block) beyond that point?
13:34:32 <phobes> sorear:  I meant to ask:  In the terminology you mentioned the other day, Coq is a strong proof system, yes?  What is a good example of a weak proof system?
13:35:06 <sorear> phobes: strong and weak specification are different approaches for using the same system
13:35:07 <oerjan> @remember sorear Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer science problem. ;-)
13:35:08 <lambdabot> Done.
13:35:23 <Heffalump> that's clearly a CS problem, though
13:35:32 <psnively> :-D
13:36:16 <sjanssen> Heffalump: yeah, you'll use O(n^2) time
13:36:26 <Heffalump> sjanssen: but is the n bounded by the block size?
13:36:29 <sjanssen> and O(n^2) space if you hold on to the old ByteStrings
13:36:36 <sjanssen> Heffalump: oh, you're using .Lazy?
13:36:39 <Heffalump> that's what I'd intuitively expect, since once you fill one up you can share them.
13:36:43 <sjanssen> cons is O(1) for those
13:36:49 <Heffalump> ah, ok.
13:36:57 <Heffalump> In any case, I don't think I'm actually using cons, now I look at my code.
13:37:19 <Heffalump> certainly not directly.
13:38:20 <phobes> Here's a problem I'm seeing with using Coq - maybe someone can tell me what I'm missing.  It seems to me that if you were using it in as a programming language, that because you have to embed type information in your terms, you have to decide what properties you want to prove as you build your function
13:38:54 <b_jonas> so python's got the idea of list comprehensions from haskell?
13:39:02 <psnively> b_jonas: Yes.
13:39:02 <phobes> And that seems like it would make it hard to invoke your functions in different places with different levels of proof
13:39:10 <phobes> if that makes sense...
13:39:10 <b_jonas> I see
13:39:20 <hpaste>  Saul_ pasted "Type Class for html forms" at http://hpaste.org/2735
13:39:39 <b_jonas> though as python doesn't have convenient lambdas, it obviously needs list comprehensions more
13:40:04 <hpaste>  (anonymous) annotated "Type Class for html forms" with "(no title)" at http://hpaste.org/2735#a1
13:40:10 <psnively> phobes: Generalizing wildly, it's true that using Coq as a programming language is trickier even than, say, Epigram.
13:40:32 <Saul__> I have a small problem, see the paste
13:40:36 <oerjan> phobes: i thought weak proof was basically adding proofs as afterthought, so it is possible
13:40:36 <dolio> That's because Epigram is actually designed with programming in mind, more or less. :)
13:40:55 <Saul__> I have a type class used to build fields in an html form
13:41:13 <Saul__> each field can contain other fields as well
13:41:26 <phobes> oerjan: interesting, thanks
13:41:53 <Saul__> It works pretty well and nice, but I'm having a small problem with the fact that the two functions in the type class sort of overlap a little
13:41:58 <dolio> Whereas Coq is, presumably, trying to be a proof environment first, and a programming language second (if at all).
13:41:59 <phobes> psnively:  thanks ... maybe I should look into Epigram then instead of Coq..
13:42:28 * b_jonas is reading "A Gentle Introduction to Haskell, Version 98"
13:42:33 <oerjan> phobes: don't quote me on it though, it is just my impression
13:43:20 <Saul__> The problem is that the render function (which makes html for each field) actually needs the Violations (basically user input errors) to render the error messages
13:44:01 <psnively> phobes: If you're interested in dependently-typed functional programming vs. theorem-proving with extraction, absolutely.
13:44:02 <Saul__> the violations are calculated by the check function (or the value of the field if there are no errors)
13:44:54 <dolio> phobes: You should read the Epigram mailing list archives. They have interesting discussions there. :)
13:45:32 <Saul__> but calling the check function in every call to the render function (so for each field in the tree) seems inefficient, and not general enough
13:45:54 <Saul__> does anyone have a suggestion on how to generalize this?
13:46:09 <Saul__> (Is anyone even reading this?)
13:46:27 <oerjan> Saul__: trying :)
13:46:39 <dolio> Not much activity lately, though...
13:47:48 <phobes> So does epigram have an IDE yet?
13:47:57 <Saul__> oerjan: If anything is unclear (which is probable) please ask
13:48:04 <psnively> Of course: EMACS
13:48:13 <phobes> Figured
13:48:17 <fax> I thought you use some X windows setup for epigram
13:48:18 <dolio> Epigram 1 runs through XEmacs.
13:48:21 <fax> seeing as its like 2D
13:48:34 <psnively> EMACS is 2D.
13:48:49 <scandal> @src mfix
13:48:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:49:09 <b_jonas> does :: have very low precedence?
13:49:10 <scandal> @hoogle mfix
13:49:11 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
13:50:17 <oerjan> Saul__: actually i don't quite understand it, but are you sure check is actually expensive to use if you consider laziness?
13:50:31 <oerjan> i.e. if you use it just for calculating violations
13:50:41 <Saul__> oerjan: No I'm not sure at all
13:51:25 <Saul__> oerjan: I think I should add some instances of Field a b, maybe that will clear things up a little?
13:51:34 <oerjan> ok
13:51:40 <bparkis> I was using SAS the other day and I noticed a funny thing:  you set up a data set, and then further instructions (like plotting data or doing a regression) implicitly operate on it.  You don't have to pass the data set as an argument each time.
13:52:18 * byorgey screams and runs away at the mention of SAS
13:52:35 <bparkis> It struck me that this could be generalized so that a function may take its arguments from the most recent return value of a matching type of some other function
13:53:09 <oerjan> b_jonas: yes, lower than all real operators
13:53:19 <b_jonas> thanks
13:53:32 <bparkis> so that instructions like plotting values implicitly take their "data" argument from the most recent return value of type "data"
13:53:40 <byorgey> bparkis: of course, that would only work in a language where the evaluation order is explicitly specified
13:53:52 <Cale> Very offtopic: does anyone here live in an area where mixed-member proportional voting is used, and what do you think about it?
13:53:54 <bparkis> yes it would all have to be in a monad or something like it--sequential evaluation
13:54:06 <byorgey> bparkis: actually, Perl does something like that with the $_ variable
13:54:09 <bparkis> but it would save typing without restricting meaning
13:54:14 <bparkis> yes I was thinking about it in relation to perl
13:54:25 <bparkis> but that doesn't work with several types
13:54:50 <bparkis> i.e. if f1 sets $_ to "hello" and f2 sets $_ to 3, then a third function that takes a string argument can't take input from $_
13:54:51 <byorgey> bparkis: well, inasmuch as Perl "scalars" actually encompass several types...
13:54:54 <bparkis> because the types don't match
13:54:57 <byorgey> but yes, I know what you mean
13:55:11 <bparkis> but there's no reason for that to fail because you could specify that it looks for the last value of a matching type
13:55:24 <bparkis> so if f3 wants a string it gets a string even if the last returned value was an integer
13:55:28 <byorgey> hm, a stack of values?
13:55:36 <bparkis> yeah, one stack per type
13:56:02 <byorgey> interesting
13:56:02 <bparkis> and you wouldn't have to store them all the way back infinitely far, just as far as a function needs to read
13:56:10 <byorgey> well, code it up in a monad! =)
13:56:22 <bparkis> yes I wonder, can that be done?
13:56:28 <igli> sorear: you're back! guess what lambdabot2 is doing! :-)
13:56:40 <Cale> Ontario is holding a referendum to change the system from single member district plurality to mixed member proportional, and I'd be interested in getting opinions from smart people living in areas using MMP. Apparently Germany does?
13:56:46 <sorear> igli: dons is that-a-way
13:57:00 <scandal> @hoogle IORef
13:57:03 <lambdabot> Data.IORef :: module
13:57:03 <lambdabot> Data.IORef.IORef :: data IORef a
13:57:03 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
13:57:10 <igli> ah thanks, neither of you was around, sorry to bother you man
13:57:17 <igli> dons: ping :)
13:57:22 <oerjan> bparkis: a list of existentially quantified Typeables, maybe
13:57:45 <igli> lb2 needs to ignore friendlyToaster and i have no perms, dons
13:58:02 <sorear> Cale: you might have better luck in #haskell-blah, things stay visible longer :)
13:58:37 <hpaste>  Saul__ annotated "Type Class for html forms" with "Maybe this is a little clearer" at http://hpaste.org/2735#a2
13:59:37 <Saul__> oerjan: This won't really clear things up, since those two instances are pretty simple (they basically are wrappers for adding additional constraints on input and for making a field optional)
14:00:22 <Saul__> oerjan: I don't really have the more complex ones ready at the moment, I can make those in maybe 15 minutes or so
14:00:37 <igli> man this channel is too busy see you all later, sorear drop by #friendly-coders sometime, we haven't seen you for ages :)
14:00:44 <Heffalump> is Control.Monad.State.Strict new in ghc 6.7/6.8?
14:00:51 <sjanssen> what is #friendly-coders?
14:02:41 <sm> a non language-specific programmer's channel
14:04:59 <oerjan> Saul__: given that none of those actually tell _how_ render would be using check...
14:05:15 <Saul__> oerjan: Yeah that's coming up :)
14:05:50 * sorear ponders what a "lazy logic programming language" would be
14:06:01 <lament> #friendly-coders? A channel for oxymoron lovers?
14:06:21 <Olathe> Heheh
14:06:31 <psnively> Oz?
14:06:45 <psnively> Not lazy enough, I guess.
14:06:46 <Saul__> oerjan: I'm now defining two new fields, called Pretty and TextField (the former adds a nice title and description to a field, and also shows error messages (which is where check comes in), the latter is sort of an html input field)
14:07:18 <Saul__> oerjan: Those are a bit more complex though
14:07:49 <ddarius> sorear: I think there is something that makes sense.  I've thought about it before, but I forget what all I came up with.
14:08:13 <ddarius> psnively: Oz isn't a purely logic language.  I.e. Curry is lazy too, but Curry is a functional logic language.
14:08:33 <psnively> Hi Derek! Yeah, I was being semi-facetious.
14:08:58 <psnively> I'm actually still not convinced of the general value of being "pure."
14:09:08 <oerjan> Saul__: it does seem to me like the important point is to ensure that check doesn't calculate a value until you look inside the Right constructor
14:09:32 <oerjan> so that it does the part of the job render needs as cheaply as possible
14:09:58 <oerjan> lazy evaluation should make this possible
14:10:37 <Saul__> You should actually not ever need the value in Right while rendering
14:11:04 <ddarius> psnively: I meant it the same way as "pure OO" is usually used (if that's wasn't clear), but the point was it's clear what laziness means in the other paradigms.
14:11:04 <Saul__> but you need to check if it is Right (and you need the value in a Left constructor)
14:11:10 <oerjan> indeed, so ensure check does not calculate it until something looks under the hood of Right
14:11:32 <psnively> ddarius: Yes, of course. I'm just being snarky. :-)
14:12:07 <oerjan> or as little of it as possible
14:17:15 <hpaste>  Saul__ annotated "Type Class for html forms" with "Now with Pretty, TextField still underway" at http://hpaste.org/2735#a3
14:17:29 <Saul__> oerjan: I now have the pretty
14:18:10 <Saul__> oerjan: I'll add the TextField with some pseudo-code, it will take too long otherwise
14:18:16 <Philippa> psnively: I'd join you in being snarky about purity, only that's how #haskell-blah happened
14:18:48 <pejo> Philippa, impure offspring?
14:18:49 <oerjan> Saul__: as far as i can see, the check for Pretty is also lazy
14:19:07 <oerjan> so it should be no problem
14:19:23 <psnively> Hi, Philippa! Actually, though, as I mentioned the other day, Delimited continuations in operating systems struck me as sufficiently compelling to actually being to learn Haskell...
14:19:56 <psnively> More generally, the observation (that I still can't find the source of!) that, approximately, from memory, "Monads turn control flow into data flow, and data flow is subject to the type system."
14:20:15 <oerjan> for both Pretty and Optional, check looks only as far as needed to produce Left or Right
14:20:40 <phobes> Is there a reason that Epigram doesn't have something like type classes?
14:20:48 <Philippa> pejo: you know anyone pure who has offspring? :-)
14:20:52 <oerjan> i think Constrained too
14:20:52 <phobes> (I'm sure there is a reason - rather is that reason that dependent types replace them somehow?)
14:20:59 <hpaste>  Saul__ annotated "Type Class for html forms" with "Pseudocode for TextField" at http://hpaste.org/2735#a4
14:21:24 <psnively> Philippa: You remind me of a bumper sticker in my tax guy's office: "Celibacy isn't hereditary."
14:21:24 <Philippa> psnively: yeah. I don't think I've ever phrased it quite as pithily, but it's a useful observation
14:22:11 <psnively> I had one of those "Dammit! Now I have to understand that!" reactions to it, you know, that "Crap, there goes the next decade or two of my life" things.
14:22:25 <Saul__> oerjan: And will it also be okay if I start have more than one child field inside a field?
14:23:03 <Philippa> heh. It doesn't take that long
14:23:06 <Saul__> s/have/having
14:23:24 <oerjan> Saul__: i see no reason why not
14:23:28 <psnively> Philippa: Well, when you account for the fact that I'm talking about grokking Oleg's work... ;-)
14:23:44 <Saul__> oerjan: Okay, then I guess I will leave it like this
14:23:48 <Philippa> it doesn't take that /long/, you just need a good supply of hallucinogens ;-)
14:24:19 <Philippa> (HHOS: back when I was doing a lot more active learning I was also a lot more sleep deprived on average...)
14:24:27 <Saul__> oerjan: Thanks for your help, I think that was the final true hurdle for this html form project
14:24:35 <xwx> Hello. Is "Fundamental Algorithms - The Art of Computer Programming - Vol. 1 Second Edition" by Donald E. Knuth, published by Addison Wesley a good book? Is it relevant to haskell?
14:24:50 <psnively> Philippa: Quite. I'm hampered by job, wife, etc. ;-)
14:25:38 <phobes> I know Knuth has released a version "Fundamental Algorithms - The Art of Computer Programming in C++" - not sure about a Haskell version
14:25:39 <Philippa> could be worse. One of the reasons my relationships take the form they do is I'm unlikely to be able to afford the space I'd need for a live-in relationship any time soon
14:25:47 <lament> xwx: most people would say it's a good book.
14:25:54 <lament> xwx: most people haven't read it, though.
14:25:55 <dolio> psnively: That quote about monads sounds like Oleg on the OCaml mailing list.
14:25:55 <Philippa> but that's heading rapidly -blahwards
14:26:13 <psnively> Philippa, I assure you, I accept the trade-offs happily to the extent I even am serious about experiencing them.
14:26:32 <psnively> Philippa: I'm sorry.
14:26:40 <psnively> dolio: It does, at that.
14:26:40 <Philippa> *nod* - didn't mean to say otherwise
14:26:52 <lament> xwx: algorithms are algorithms, it doesn't matter what programming language you use.
14:27:31 <Philippa> anyway, I should find more ways to let my thinking turn into useful code and articles. Summer of Code went well like that
14:27:31 <oerjan> Saul__: you're welcome :)
14:27:48 <psnively> Coding is hard. Let's go to the mall.
14:28:13 <fasta> lament: in theory no, in practice, yes.
14:28:30 <fasta> lament: take Python: stack limits.
14:28:52 <lament> fasta: well, wasn't that knuth's own justification in making up his own programming language instead of using some existing one?
14:28:57 <fasta> lament: take Stackless Python: you must wrap recursive calls in "call" e.g. call(factorial)
14:29:06 <dolio> psnively: http://caml.inria.fr/pub/ml-archives/caml-list/2007/07/9858139a356468fa638746aacf111682.en.html <-- source
14:29:06 <heanol> -> http://uptr.pl/kn
14:29:07 <lambdabot> Title: Archives of the Caml mailing list > Message from oleg@p...
14:29:07 <fasta> lament: no
14:29:08 <lambdabot> Title: Archives of the Caml mailing list > Message from oleg@p..., http://tinyurl.com/yvfhnf
14:29:24 <xwx> lament: this book seems really heavy, using it's own made up assembly language. reading the whole book and going through all the examples will take months. aren't there any more modern books that teach algorithms in a better  way?
14:29:24 <fasta> lament: he used his own, because machine languages don't change that fast.
14:29:28 <lament> fasta: these things are fairly trivial in comparison to the actual work of designing an algorithm.
14:29:38 <bparkis> knuth made up his own programming language so that he could exactly quantify the cost of an algorithm
14:29:46 <bparkis> beyond an asymptotic bound
14:29:59 <fasta> lament: AFAIK, nobody every designed an algorithm
14:30:10 <fasta> lament: algorithm books try to teach you that
14:30:16 <fasta> lament: that's not how it works
14:30:29 <psnively> Ah, right. Oleg's response to me on the OCaml list. No wonder it sounded familiar. :-)
14:30:33 <fasta> lament: people have a good idea and they write it up in an article.
14:30:35 <Philippa> psnively: I actually have as much if not more trouble getting to the mall :-)
14:30:37 <fasta> lament: or book
14:30:39 <pejo> xwx, some exercises will take months alone, or are open research problems.
14:30:41 <dolio> :)
14:30:41 <lament> fasta: nevertheless algorithms exist as separate entities from programming languages
14:30:48 <lament> (and from programs)
14:30:49 <bparkis> xwx: my algorithms textbook is cormen, leiserson, rivest, stein
14:30:50 <fasta> lament: sure
14:30:53 <bparkis> "introduction to algorithms"
14:30:58 <lament> merge sort is merge sort
14:31:07 <lament> whether you're using haskell or brainfuck
14:31:12 <fasta> lament: ever*
14:31:14 <psnively> Philippa: Yes, I gather that you have some unusual challenges.
14:31:24 <bparkis> it is a thorough 1-volume text and I'm glad I have it
14:32:05 <xwx> pejo: so is it worth it to give this book a serious read, going page by page and through all the exercises?
14:32:24 <Philippa> one of the reasons I gave that talk was I figure a lot of them're larger versions of things I hear a lot of coders complain about anyway. Unfortunately I really needed more time to cover more of the "and these ways of dealing with it work! And these languages interact with those techniques in the following nifty ways!" stuff
14:32:31 <Philippa> still, I know that for next time
14:32:44 <Armor_Azrael> lament: Algorithms in brainfuck are actually different though, because you don't have O(1) arrays :P
14:33:03 <sorear> you don't have O(1) arrays in Haskell either...
14:33:06 <oerjan> @quote complexity
14:33:06 <lambdabot> qwe1234 says: check out 'complexity theory', it's all there.
14:33:08 <oerjan> @quote complexity
14:33:09 <lambdabot> jmelesky says: I've figured out the problem. qwe1234 has different definitions of "functional programming", "compiler", "complexity theory", "math", and "optimization" than everybody else who deals
14:33:09 <lambdabot> with computers or computer science.
14:33:10 <sorear> (mutable)
14:33:11 <Armor_Azrael> sorear: DiffArrays
14:33:25 <pejo> xwx, if you are into algorithms it's a very solid foundation for it. "Introduction to algorithms" is probably an easier read though, and enough to give you a fair overview of the field (used as textbook in many undergraduate algorithms courses).
14:34:09 <bparkis> it's also used as a textbook in grad courses
14:34:17 <fasta> sorear is talking about Haskell 98, I think.
14:35:10 <oerjan> @quote ghc.*complexity
14:35:11 <lambdabot> No quotes match. My mind is going. I can feel it.
14:35:15 <ddarius> @quote mall
14:35:15 <lambdabot> shapr says: I was chatting with someone who writes Haskell and at some point they said they're not an academic, and I said that too. And then there was what I perceived to be a small disbelieving
14:35:16 <lambdabot> silence...
14:35:25 <Twan> There is no reason why the haskell 98 array couldn't be a DiffArray
14:35:49 <fasta> Twan: yes, there is.
14:35:53 <ddarius> @quote hard.*[lL]et's.go
14:35:54 <lambdabot> samc says: monads are hard, let's go shopping
14:36:03 <sorear> @vixen math
14:36:03 <lambdabot> i really hate arabs!
14:36:26 <ddarius> Al Khwarizmi
14:36:36 * ddarius probably butchered that.
14:36:53 <psnively> LOL
14:37:29 <Twan> fasta: What would that reason be? I can't think of anything
14:37:50 <phobes> I just read the Oleg post that was linked... does anyone know of an example where Monad transformers don't work because of 'fixed order of layers'?
14:37:53 <psnively> @quote heat death
14:37:53 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
14:37:59 <psnively> @quote psnively
14:38:00 <lambdabot> sorear says: Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer
14:38:00 <lambdabot> science problem. ;-)
14:38:18 <dolio> phobes: Look for his paper on implementing dynamically scoped variables using delimited continuations.
14:39:13 <psnively> @quote heat-death
14:39:13 <lambdabot> sorear says: Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer
14:39:13 <lambdabot> science problem. ;-)
14:39:18 <psnively> OK, I get it now.
14:39:22 <dolio> phobes: http://okmij.org/ftp/papers/DDBinding.pdf <-- that's the one
14:39:34 <oerjan> psnively: you can use regexes, but no spaces
14:39:40 <phobes> dolio: thanks
14:39:42 <psnively> Gotcha.
14:39:45 <scandal> @hoogle replicate
14:39:45 <lambdabot> Prelude.replicate :: Int -> a -> [a]
14:39:46 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
14:39:46 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
14:39:53 <sorear> @quote heat.death
14:39:53 <lambdabot> sorear says: Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer
14:39:53 <lambdabot> science problem. ;-)
14:39:57 <sorear> @quote heat
14:39:58 <lambdabot> sebazzz says: * sebazzz sabe que emonk es un negro sucio y cheatero
14:40:20 <psnively> Heh.
14:40:53 <Armor_Azrael> Hey, if I already know a bit about programming in haskell, but would like to learn more about haskell style (naming convention, when to separate modules and when not to, etc.), does anyone know of a good resource?
14:40:56 <ddarius> psnively: http://web.maths.unsw.edu.au/~norman/views2.htm
14:40:56 <lambdabot> Title: A/Prof N J Wildberger Personal Pages
14:41:24 <fasta> Twan: never mind, it could be implemented as a DiffArray
14:42:08 <psnively> Derek: Oh goody. More controversy over set theory.
14:42:18 <ddarius> psnively: Not exactly...
14:42:25 <ddarius> @google inurl:haskellwiki Haskell style
14:42:29 <lambdabot> http://haskell.org/haskellwiki/Pointfree
14:42:30 <lambdabot> Title: Pointfree - HaskellWiki
14:42:40 <ddarius> Um... not that, but maybe a link from there?
14:42:57 <oerjan> there is controversy over set theory? that doesn't involve one of the parties being insane?
14:42:59 <psnively> ddarius: I'll see that and raise you http://www.math.tulane.edu/~tipler/theoryofeverything.pdf
14:43:00 <Philippa> Armor_Azrael: I don't know there's much written specifically about module separation. Naming convention's a bit hodgepodge, try inferring stuff from the standard libs? But we generally use camelCase
14:43:04 <psnively> http://www.math.tulane.edu/~tipler/theoryofeverything.pdf
14:43:04 <dolio> phobes: http://www.mail-archive.com/haskell-cafe%40haskell.org/msg26173.html <-- He talks about it there, too.
14:43:06 <lambdabot> Title: [Haskell-cafe] Re: Playing with delimited continuations, http://tinyurl.com/2ye2fs
14:43:23 <psnively> oerjan: Only in the sense that both parties are insane.
14:43:36 <dc_> hey
14:43:47 <scandal> @hoogle typeOf
14:43:48 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
14:43:48 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
14:43:48 <lambdabot> Data.Typeable.typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
14:44:47 <oerjan> @src Typeable
14:44:47 <lambdabot> Source not found. Are you on drugs?
14:44:58 <fax> hmmm
14:44:59 <dc_> I'm trying to install the cgi cabal pkg, but it's not found with -package cgi..
14:45:10 <fax> Is there any parser that you prefer to Parsec?
14:45:15 <ddarius> psnively: The "Why real numbers are a joke" section, is actually rather entertaining.
14:45:27 <dc_> it's trying to look for Network/CGI.hs, but in the package the lib is CGI.hs..
14:45:39 <dc_> or does ghc-pkg rename it on installation?
14:45:47 <Philippa> fax: opinions vary - there're good reasons to prefer other libraries for specific classes of grammar or parsing problem though
14:46:05 <Saizan_> are there introductory resources on continuations that use haskell as language? i'd like to know about shift/reset,prompt etc..
14:46:46 <fax> I wonder what to use for parsing Prolog :|
14:46:53 <psnively> Eh. Dude needs to read up on Surreal Numbers.
14:46:59 <fax> I starting with Parsec but I'm not sure ..
14:47:00 <dolio> Saizan_: I wrote one on the wiki, and would welcome critiques.
14:47:12 <Philippa> Parsec ought to work fine
14:47:15 <oerjan> Prolog has definable precedence, not?
14:47:46 <oerjan> so you definitely wants something that can adapt the syntax on the fly
14:47:54 <Philippa> mmm. Parsec handles stuff like that better than most libs do without a second pass - remind me if it's possible for a precedence declaration to occur after an operator it applies to in Prolog?
14:47:55 <nuncanada> ddarius, i have my problems with cantor theory too but that seems too radical
14:47:57 <Saizan_> dolio: oh, where?
14:48:00 <dolio> Saizan_: http://www.haskell.org/haskellwiki/Library/CC-delcont
14:48:01 <lambdabot> Title: Library/CC-delcont - HaskellWiki
14:48:05 <ddarius> Strict finitism ho!
14:48:21 <nuncanada> I am almost an adept, havent made my mind yet :)
14:48:26 <oerjan> Philippa: i doubt it
14:48:26 * Philippa did have some rather twisted thoughts about using ParsecT Cont for handling it when the precedence declarations come later
14:48:27 <fax> yeah you can using op
14:48:36 <dolio> Saizan_: That tries to explain delimited continuations more than abortive continuations. There might be more entries on the latter on the wiki (look for Cont(T)).
14:48:37 <Philippa> oerjan: I ask because it's legit in Haskell
14:48:44 <nuncanada> But assuming that MOST of mathematics is like that, unrigorous... Is far too much
14:48:46 <oerjan> prolog seems to be imperative about such matters
14:49:13 <oerjan> i know
14:49:28 <cognominal_> I know the name of an operator (say ++), is there a standard way to find its name as a function (here: concat)
14:49:33 <cognominal_> ??
14:49:40 <Philippa> cognominal: ++ isn't concat
14:49:46 <Saizan_> dolio: thanks!
14:49:48 <Philippa> @type concat
14:49:52 <lambdabot> forall a. [[a]] -> [a]
14:49:53 <Philippa> @type (++)
14:49:55 <lambdabot> forall a. [a] -> [a] -> [a]
14:50:36 <dolio> Saizan_: No problem. Tell me if something is confusing. I haven't done much polishing, or had much outside input.
14:50:54 <oerjan> cognominal_: in haskell, operators don't have alphanumeric equivalents
14:51:05 <cognominal_> okay, my example is bad. But the question stays
14:51:24 <fax> > concat ["abc", "def", "ghi"]
14:51:26 <lambdabot>  "abcdefghi"
14:51:29 <cognominal_> for example for monad, bind has a operator notation
14:51:39 <oerjan> instead, you can convert freely between them: (++) can be used as if it were alphanumeric, `map` as if it were an operator
14:51:40 <fax> > foldr (++) ""  ["abc", "def", "ghi"]
14:51:42 <lambdabot>  "abcdefghi"
14:52:12 <Japsu> Hmm
14:52:16 <fax> concat = foldr (++) "" ?
14:52:24 <elliottt> @source choose
14:52:25 <lambdabot> choose not available
14:52:28 <Japsu> Programming in C can be strangely refreshing at times
14:52:50 <Philippa> like drinking vinegar?
14:52:54 * Japsu and co. are translating tp-fancontrol from shell script to C
14:53:10 <Adamant> C is fun. programming only in C for every program is not fun.
14:53:13 <cognominal_> Philippa, when pinned on a cross :)
14:53:30 <oerjan> cognominal_: are you really asking about how operators are pronounced?
14:53:55 <Japsu> It's also been fun to refresh my memory with all these unix thingies... So far I've managed to write daemonization and other boilerplate code, and the real work is still ahead ;)
14:54:06 <oerjan> there's nothing _in_ haskell that determines it
14:54:09 <Japsu> Which is, of course, implementing the sensor reading and fan controlling functions
14:54:39 <Japsu> The code's at http://pajukanta.fi/git/hurina.git, tho there isn't much to see yet ;)
14:54:42 <lambdabot> Title: Index of /git/hurina.git
14:55:37 <psnively> I think programming in C can be fun. Sometimes it's nice to be reminded what it's like to bang on the metal.
14:55:48 <Japsu> ;D
14:55:58 <psnively> But yeah, the mass, multi-decade delusion that C is an appropriate "general-purpose programming language" has got to, dear Christ in heaven, END.
14:56:10 <dbueno> Are there or-patterns in haskell?  Suppose some function returns the same value in three different cases; is there syntax that lets me match all three cases and write the return value just once?
14:57:31 <oerjan> dbueno: not directly, but you could combine naming the value with a case branch...
14:57:40 <xwx> > let foo x | x == 1 || x == 3 = 1 in foo 3
14:57:42 <lambdabot>  1
14:57:43 <Philippa> dbueno: no, but you can pass them into a local function
14:58:32 <nuncanada> ddarius, there is famous sentence by Djisktra about similar issues
14:58:49 <dbueno> oerjan, Philippa: Thanks.  Is this lack for any technical reason, or just because there are plenty of reasonable work-arounds?
14:59:03 <xwx> dbueno: see what i just wrote
14:59:32 <Igloo> dbueno: It would be a bit unpleasant. You'd have to require that both patterns had the same set of variables with the same types, or something
14:59:35 <dbueno> xwx: You're not matching on an algebraic data type, though.
14:59:49 <xwx> oh
15:00:09 <dbueno> Igloo:  Yes, but often that is the case.  (OCaml has or-patterns, and they do require both binding the same variables & the same types for those variables.0
15:00:14 <cognominal_> oerjan, I guess my question would have an answer if haskell kept trace of synonymous var
15:00:16 <stepcut> dbueno: you want something like, case expr of A | B | C -> return "foo" ; D | E | F -> return "bar"  ?
15:00:22 <cognominal_> plus = (+)
15:00:35 <cognominal_> ... and given one I would like to have the other
15:00:43 <dbueno> stepcut: Yes, assuming you meant "return" in the "evaluate to" sense and not the monad sense.
15:00:48 <stepcut> dbueno: Haskell is lacking ocaml-style or patterns, but possibly because nobody thought to add them
15:00:55 <oerjan> cognominal_: right. except it doesn't and plus doesn't actually exist
15:00:58 <oerjan> :t plus
15:01:00 <stepcut> dbueno: I believe simon peyton jones liked the idea
15:01:00 <lambdabot> Not in scope: `plus'
15:01:15 <dbueno> stepcut:  Ah, okay.  Count me in with him, then. =]
15:01:33 * Igloo isn't sure if I like it or not
15:01:44 <dbueno> It's not so bad to use "where" to name the result of the cases that all have the same return value ... but I think it's clearer code if you can say "if it matchis this pattern or this or this..."
15:01:48 <cognominal_> I suppose that it is a common occurence to define an operator as synonymous as a function. It would be nice to find one from the other
15:02:44 <oerjan> hm...
15:02:44 <dbueno> Igloo: in my current application I'm not even using variables; just writing an equivalence relation that partitions the set of my data constructors.
15:03:33 <oerjan>  @. hoogle type might work in some cases
15:04:06 <oerjan> but since hoogle is broken with type classes, this probably won't work:
15:04:06 <ddarius> cognominal_: Not in Haskell it isn't.
15:04:19 <oerjan> @. hoogle type (<$>)
15:04:21 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *). ('
15:04:41 <oerjan> @type (<$>)
15:04:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:04:51 <oerjan> and that, too :(
15:04:58 <shachaf> @hoogle forall a. a -> a
15:04:59 <lambdabot> Did you mean: Forall A. a -> a
15:04:59 <lambdabot> Prelude.id :: a -> a
15:04:59 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
15:05:08 <shachaf> Hoogle understands forall, but not kinds?
15:05:39 <cognominal_> thx oerjan
15:10:04 <scandal> @hoogle Ptr a -> a
15:10:04 <lambdabot> No matches, try a more general search
15:10:37 <Saizan_> @hoogle Ptr a -> IO a
15:10:38 <lambdabot> No matches, try a more general search
15:10:43 <ddarius> :t peek
15:10:45 <lambdabot> Not in scope: `peek'
15:10:54 <ddarius> :t Foreign.Storable.peek
15:10:56 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
15:11:59 * ddarius considers unsafeCoercing some StablePtrs and having some fun!
15:13:27 <dbueno> I have a main function whose last statement is a call to "verboseCheck" from quickcheck -- is there a way I can get the binary to exit with a non-0 exit code in the case that a test fails?
15:13:56 <sjanssen> @hoogle verboseCheck
15:13:56 <lambdabot> Test.QuickCheck.verboseCheck :: Testable a => a -> IO ()
15:14:28 <fax> @hoogle Int -> Char
15:14:28 <lambdabot> Char.chr :: Int -> Char
15:14:29 <lambdabot> Char.intToDigit :: Int -> Char
15:14:29 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
15:14:54 <dbueno> And if I'm not testing in the REPL, what is the best policy for ensuring that if a test fails, I'll be able to see the test case for which it fails?  Just use verboseChek all the time?  (In case you all haven't inferred, I'm a Haskell newbie. =])
15:16:11 <sjanssen> dbueno: quickCheck already prints out the failing input
15:16:28 <sjanssen> @check (\x -> (x :: Int) == 0)
15:16:30 <lambdabot>  Falsifiable, after 0 tests: 2
15:16:35 <dbueno> sjanssen:  Ah, okay.  Thanks.  For some reason I thought it didn't.
15:16:49 <eck> is there a floating point data type with more precision than Double?
15:17:35 <sorear> eck: CLDouble
15:18:02 <sorear> :k Foreign.C.Types.CLDouble
15:18:04 <lambdabot> *
15:18:15 <eck> thanks
15:19:13 <sjanssen> dbueno: as far as giving an exit code, you might want to look at Test.QuickCheck.Batch
15:19:15 <fax> Can you write do { something ; return () } shorter?
15:19:38 <hpaste>  scandal pasted "hack to get size of underlying type in (Ptr a)" at http://hpaste.org/2737
15:20:11 <nornagon> fax: sequence_ [something]?
15:20:16 <oerjan> something >> return ()
15:20:23 <nornagon> or something >> return ()
15:20:29 <nornagon> er.
15:20:33 <nornagon> @quote stereo
15:20:34 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
15:20:34 <scandal> can someone look at that fragment.  will the "result <- peek buf" actually be executed since `result` is not used other than to determine its size?
15:20:41 <nornagon> @quote stereo
15:20:42 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
15:20:49 <nornagon> oh. blah.
15:20:49 <fax> Thanks guys :)
15:20:50 <oerjan> :t <* ?something
15:20:52 <lambdabot> parse error on input `<*'
15:21:07 <sorear> scandal: sizeOf?
15:21:08 <ddarius> nornagon: You thought it was lying?
15:21:14 <nornagon> i hoped :(
15:21:19 <sjanssen> scandal: yes, it will be executed
15:21:31 <dbueno> sjanssen:  Ah, thank you.
15:21:45 <sorear> scandal: ah, I see
15:21:58 <oerjan> :t () <* ?something
15:22:00 <lambdabot>     Couldn't match expected type `f a' against inferred type `()'
15:22:00 <lambdabot>     In the first argument of `(<*)', namely `()'
15:22:05 <sorear> scandal: the Best Way (tm) is to use the GHC ScopedTypeVariables extension
15:22:10 <oerjan> :t (<*)
15:22:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
15:22:28 <scandal> sorear: yeah. someone else gave me another solution using mfix, but I don't understand it :/
15:22:49 <sorear> mfix, heh
15:23:07 <scandal> http://hpaste.org/2736
15:23:17 <oerjan> :t const()<$> ?something
15:23:19 <lambdabot> forall a (f :: * -> *). (?something::f a, Functor f) => f ()
15:23:30 <Saizan_> scandal: sizeOf doesn't use it's argument, so you just have to give it an undefined of the right type
15:23:41 <ddarius> The Haskell 98 way is to use asTypeOf and maybe some trickery.
15:23:42 <Saizan_> s/it's/its/
15:24:06 <sjanssen> dbueno: many projects end up with a bunch of quickcheck driver boilerplate, you could steal that from eg. xmonad
15:24:27 <sjanssen> that should be added to QC itself, probably
15:24:30 <scandal> Saizan_: what I have a is a (Ptr a) and I want to call  sizeof (undefined :: a)
15:24:40 <scandal> which i guess is what that extension is for
15:25:31 <Saizan_> ?type let f :: Ptr a -> a; f = undefined; in \x -> sizeOf (f x)
15:25:33 <lambdabot> Not in scope: type constructor or class `Ptr'
15:25:33 <lambdabot>  
15:25:33 <lambdabot> <interactive>:1:45: Not in scope: `sizeOf'
15:25:39 <oerjan> :t ()<$ ?something -- ah
15:25:39 <mauke> dereference :: Ptr a -> a; dereference = undefined; ... sizeOf (dereference ptr)
15:25:41 <lambdabot> forall (f :: * -> *) b. (?something::f b, Functor f) => f ()
15:25:44 <fasta> I wonder why lots of people use Python for something it's not suitable for (recursion) in all implementations of Python.
15:25:48 <ddarius> Exercise: Without using a type annotation or (`asTypeOf` id) give undefined the type a -> a
15:26:08 <oerjan> fax ^^
15:26:22 <mauke> head [undefined, id]
15:29:02 <ddarius> mauke: You can't use id or an equivalent expression at all, but nice try.
15:29:40 <EvilTerran> you didn't say that
15:30:24 <ddarius> EvilTerran: I was hoping it didn't need to be said, but I like mauke's solution, I'm just narrowing down to a more particular one.
15:30:27 <Saizan_> ?type let f = undefined; x = undefined; _ = f x == x in f
15:30:29 <lambdabot> forall a. a
15:30:53 <mauke> you have been let-polymorphized
15:30:54 <EvilTerran> i tried that one too, Saizan_. not sure why the monomorphism restriction didn't catch that
15:31:07 <EvilTerran> let-polymorphized/
15:31:07 <oerjan> EvilTerran: because there are no type classes
15:31:07 <EvilTerran> ?
15:31:16 <EvilTerran> ah.
15:31:19 <ddarius> let's are polymorphic
15:31:26 * EvilTerran doesn't like the MR. yay mess of special cases.
15:32:22 <EvilTerran> ?type let f = (+1) in (f (1::Int), f (1::Float)) -- ddarius, huh?
15:32:24 <lambdabot>     Couldn't match expected type `Int' against inferred type `Float'
15:32:24 <lambdabot>     In the first argument of `f', namely `(1 :: Float)'
15:32:39 <EvilTerran> oerjan's explanation kinda makes sense for me, tho
15:32:45 <oerjan> :t case undefined of f -> case \x -> f x == x of _ -> f
15:32:45 <scandal> mauke: wow, cool. thanks for the deref example. works great.
15:32:47 <lambdabot> forall a. (Eq a) => a -> a
15:32:56 <oerjan> ah, not quite
15:33:07 <ddarius> You can use asTypeOf
15:33:16 <oerjan> ddarius: no, that was forbidden
15:33:16 <EvilTerran> ddarius, anyway, to answer your excercise, "undefined undefined". the first one has type a->a.
15:33:18 <mauke> :t asTypeOf undefined
15:33:20 <lambdabot> forall a. a -> a
15:33:37 <ddarius> EvilTerran: No it doesn't, it has type a -> b
15:33:45 <EvilTerran> hm. true.
15:33:51 <ddarius> oerjan: I said (`asTypeOf` id) was forbidden.
15:33:53 <mauke> what do I win?
15:34:02 <oerjan> :t case undefined of f -> case \x -> [x,f x] of _ -> f
15:34:04 <lambdabot> forall t. t -> t
15:34:14 <EvilTerran> do we need an expression of type a->a, or just an expression where there is an undefined of type a->a?
15:34:16 <ddarius> mauke: Nothing, because undefined has type a in that.
15:34:26 <mauke> aw
15:34:36 <ddarius> EvilTerran: It should be no trouble to do both.
15:34:36 <EvilTerran> 'cos it seems like we're aiming for a moving target here
15:34:48 <oerjan> i won :)
15:34:53 <fasta> To answer my own question: Python has a sh*t-load of libraries.
15:35:00 <ddarius> Okay, return the undefined value with type a -> a
15:35:02 <EvilTerran> arbitrarily changing the rules when someone presents an answer is kinda annoying.
15:35:17 <EvilTerran> even if you insist you're "clarifying" them
15:35:19 <ddarius> I've only changed the rules once.
15:35:40 <ddarius> And I accepted mauke's initial answer as pretty good, just not what I was trying to induce.
15:35:44 <fasta> New rules: "There are no rules". ;)
15:35:59 <sjanssen> ddarius: it has to be _|_, and not \_ -> _|_?
15:36:51 <ddarius> sjanssen: I don't really mind.  My original statement said, "give undefined the type a -> a", so it can be a subexpression, but it's important that -undefined- has that type, not the whole expression.
15:37:13 <mauke> :t undefined `asTypeOf` (asTypeOf undefined)
15:37:16 <lambdabot> forall a. a -> a
15:37:52 <EvilTerran> looks like mauke's covers both problems, there. unless you're gonna say we're only allowed one asTypeOf now. ;]
15:38:01 <ddarius> Bloody mauke, that just barely gets by my added rules.
15:38:15 <mauke> laziness++
15:38:17 <sjanssen> @type undefined :: a -> a
15:38:18 <oerjan> EvilTerran: what was wrong with may last one?
15:38:19 <lambdabot> a -> a :: forall a. a -> a
15:38:30 <oerjan> :t case undefined of f -> case \x -> [x,f x] of _ -> f -- da capo
15:38:32 <lambdabot> forall t. t -> t
15:38:40 <oerjan> *my
15:38:51 <EvilTerran> look, if you want to show us some clever trick you've come up with, just show us it, ddarius
15:39:11 <ddarius> EvilTerran: It's not a trick I've come up with, but I'm starting to get that way.
15:39:21 <ddarius> It's interesting to see what other people come up with though.
15:39:44 <ddarius> oerjan kinda has the right idea, just a round about way of stating it.
15:40:09 <ddarius> The thing with a -> a is that the input type is the same as the result type, so just say that.
15:40:28 <EvilTerran> fix undefined?
15:40:47 <EvilTerran> ?type fix
15:40:48 <ddarius> EvilTerran: That is essentially it.
15:40:49 <lambdabot> forall a. (a -> a) -> a
15:41:03 <oerjan> :t fix undefined
15:41:05 <lambdabot> forall a. a
15:41:25 <sjanssen> :t let f = undefined `seq` (f . f) in f
15:41:27 <lambdabot> forall c. c -> c
15:41:43 <ddarius> EvilTerran: There are times when you write "circular" programs just to grab the type of something.
15:42:16 <mauke> :t iterate undefined
15:42:18 <lambdabot> forall a. a -> [a]
15:42:25 <ddarius> :t let f = undefined where r = f r in f
15:42:27 <lambdabot> forall t. t -> t
15:42:30 * EvilTerran tends to use explicit types for that
15:42:52 <EvilTerran> unless i'm misunderstanding you; can you give a more useful example?
15:42:56 <ddarius> EvilTerran: You can't always without scoped type variables which are an extension.
15:43:07 <oerjan> :t head . iterate undefined
15:43:10 <lambdabot> forall a. a -> a
15:43:26 <ddarius> EvilTerran: I've seen it come up and it has come up in my code upon occasion, but I can't think of a good example off-hand.
15:44:03 <EvilTerran> hmm
15:44:21 * EvilTerran wanders orf
15:59:02 <KatieHuber> is there anything for extracting bits of a triple like fst and snd for pairs?
15:59:20 <oerjan> nope
16:00:13 <ddarius> Just pattern matching.
16:00:19 <KatieHuber> 'k
16:00:38 <fax> > (\(x,_,_) -> x) (1,2,3)
16:00:43 <oerjan> even Data.Tuple only contains pair functions (from the Prelude even)
16:00:46 <lambdabot>  1
16:00:47 <ddarius> (You could of course define them -or- using an extra indirection use nested pairs)
16:01:47 <byorgey> > fst . fst $ ((1,2),3)
16:01:48 <lambdabot>  1
16:08:44 <hpaste>  fnord123 pasted "Static Analysis of ghoji" at http://hpaste.org/2738
16:19:55 <fax> parsing programming languages is hard unless you're making it up as you go :"|
16:20:08 <fax> not so much hard as tedious actually
16:20:53 <Saizan_> that's why there are things like alex and happy
16:22:43 <fax> I can't find a proper BNF though
16:23:14 <fax> so I have still to rewrite it all, before adding in AST making stuff
16:23:15 <Armor_Azrael> fax: I've found Parsec was very smooth for that
16:23:27 <oklopol> > 4 & 5
16:23:28 <lambdabot>   Not in scope: `&'
16:23:33 <fax> yeah, I used parsec before for a logo
16:23:36 <fax> now doing prolog
16:23:49 <fax> got 1/3 done :|
16:23:52 <Armor_Azrael> ?
16:24:10 <Armor_Azrael> Are we talking about the same parsec?
16:24:13 <fax> yes
16:24:17 <oerjan> > 4 .&. 5
16:24:19 <lambdabot>  Add a type signature
16:24:25 <fax> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
16:24:26 <oerjan> > 4 .&. 5 :: Int
16:24:26 <Armor_Azrael> Ah, we're not
16:24:28 <lambdabot>  4
16:24:30 <fax> oh? :o
16:24:41 <oklopol> oerjan: binary and?
16:24:45 <Armor_Azrael> Err, yes we are, sorry
16:24:46 <oerjan> yep
16:24:49 <oklopol> darn
16:24:53 <oklopol> i was gonna make that
16:24:59 <fax> ah ok, parsec is nice
16:25:04 <oklopol> you big fun-ruiner!
16:25:08 <oerjan> i thought you were looking for it
16:25:11 <oklopol> :P
16:25:15 <fax> but the problem is no one writes syntax definitions properly
16:25:15 <Armor_Azrael> I just thought we weren't b/c you talked about a logo
16:25:29 <fax> I wrote a logo interpreter first
16:25:34 <fax> turtle graphics
16:25:36 <Armor_Azrael> o
16:25:42 <oklopol> o
16:25:54 <fax> is logo some other thoing?
16:26:32 <Armor_Azrael> I assumed you meant logic language or similar because you talked about prolog immediately afterwards
16:26:33 <oerjan> non-programmers occasionally use the word for something different, yes :)
16:26:43 <fax> ah hehe
16:27:32 <oklopol> > (\a b c->a b c) (\a b->a b) (\a -> a) 1
16:27:34 <lambdabot>  1
16:28:05 <oklopol> > 34 .|. 124
16:28:06 <lambdabot>  Add a type signature
16:28:09 <oklopol> > 34 .|. 124 :: Int
16:28:10 <lambdabot>  126
16:28:20 <oklopol> > 34 :: Int .|. 124
16:28:20 <lambdabot>  Parse error
16:28:25 <oklopol> > (34 :: Int) .|. 124
16:28:26 <lambdabot>  126
16:28:34 <KatieHuber> that's an... interesting-looking operator
16:28:39 <oklopol> well yes
16:28:42 <oklopol> nice and phallic
16:28:48 <oerjan> :t  (.|.)
16:28:50 <lambdabot> forall a. (Bits a) => a -> a -> a
16:28:50 <sorear> @quote smil
16:28:50 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
16:29:00 <mauke> (_|_)  <- bottom
16:29:07 <sorear> @quote mauke
16:29:07 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
16:29:16 <sorear> @quote _|_
16:29:16 <lambdabot> ghc says: eval_thunk_selector: strange selectee
16:29:18 <sorear> @quote _\|_
16:29:18 <fax> :t (fmap fix)
16:29:18 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
16:29:19 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
16:29:34 <sorear> fmap fix return is return . fix, duh
16:29:47 <oklopol> > let (^__^) a b = 1 in 1 ^__^ 2
16:29:47 <lambdabot>  Parse error
16:29:47 <oerjan> _|_ is not a legal identifier
16:29:49 <oklopol> oh
16:29:50 <oklopol> _
16:29:55 <oklopol> darn
16:29:57 <mauke> sorear: fix . return
16:30:20 <oerjan> use hyphen instead
16:30:33 <oklopol> > let (:|) a b = 1 in 1 :| 2
16:30:34 <lambdabot>   Not in scope: data constructor `:|'
16:30:46 <oklopol> > let (;|) a b = 1 in 1 ;| 2
16:30:47 <lambdabot>  Parse error
16:30:51 <sorear> mauke: uh...
16:30:53 <oklopol> > let (=|) a b = 1 in 1 =| 2
16:30:54 <lambdabot>  1
16:31:12 <oklopol> > let (=/) a b = 1 in 1 =/ 2
16:31:14 <lambdabot>  1
16:31:25 * sorear was thinking fmap fix . return
16:31:39 <oklopol> all the good smileys are illegal :<<
16:32:05 <oklopol> > let a ¤ b = a * b - b in 5 ¤ 2
16:32:05 <lambdabot>  Illegal character ''\164''
16:32:11 <sorear> > let (=<) = 2 in (=<)
16:32:13 <lambdabot>  2
16:32:59 <oklopol> > let (^\/^) = 5 in (^\/^)
16:33:00 <lambdabot>  5
16:33:02 <oklopol> xD
16:33:21 <oklopol> > let (^\../^) = 5 in (^\../^)
16:33:23 <lambdabot>  5
16:33:28 <fax> lol
16:33:35 <oerjan> ¤ is probably technically legal but unsupported
16:33:53 <ricky_clarkson> :t (.) (.)
16:33:55 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
16:34:04 <fax> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
16:34:06 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -
16:34:06 <lambdabot> > t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z,
16:34:06 <lambdabot>  t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39)
16:34:31 <oklopol> > let ^-^ b = 4 in ^-^ 1
16:34:31 <lambdabot>  Parse error
16:34:31 <LoganCapaldo> madness
16:34:33 <oklopol> hmm...
16:34:54 <oerjan> operators need parentheses unless used binary
16:35:01 <oklopol> oh
16:35:07 <oklopol> you can't make prefix operators?
16:35:08 <ricky_clarkson> Sometimes it's disappointing when a problem turns out to be solvable in a line of code or 5.  You want it to be more interesting.
16:35:09 <oklopol> hmm...
16:35:11 <oklopol> > -5
16:35:13 <lambdabot>  -5
16:35:13 <oerjan> nope
16:35:26 <ricky_clarkson> oklopol: Named functions are effectively prefix operators.
16:35:28 <oklopol> that's... dissapponting :<
16:35:32 <oklopol> well yeah...
16:35:35 <oklopol> but...
16:35:36 <oerjan> that's the only exception.
16:35:37 <oklopol> > -3544
16:35:38 <sorear> :t let { a = a; b = (a,a); c = (b,b); d = (c,c); e = (d,d); f = (e,e); g = (f,f); h = (g,g) } in (h,h)
16:35:38 <lambdabot>  -3544
16:35:39 <kpreid> oklopol: - is an unfortunate special case.
16:35:40 <oklopol> oh
16:35:40 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49
16:35:41 <lambdabot> t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98
16:35:41 <lambdabot> t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115 t116 t117 t118 t119 t120 t121 t122 t123 t124 t125 t126 t127 t128 t129 t130 t131 t132 t133 t134 t135 t136 t137 t138
16:35:41 <lambdabot> t139 t140 t141 t142 t143 t144 t145 t146 t147 t148 t149 t150 t151 t152 t153 t154 t155 t156 t157 t158 t159 t160 t161 t162 t163 t164 t165 t166 t167 t168 t169 t170 t171 t172 t173 t174 t175 t176 t177
16:35:43 <lambdabot> t178 t179 t180 t181 t182 t183 t184 t185 t186 t187 t188 t189 t190 t191 t192 t193 t194 t195 t196 t197 t198 t199 t200 t201 t202 t203 t204 t205 t206 t207 t208 t209 t210 t211 t212 t213 t214 t215 t216
16:35:45 <oklopol> i guess it's okay then
16:35:46 <lambdabot> [11 @more lines]
16:35:48 <fax> woah
16:35:57 <mauke> sorear: you're doing it right!
16:36:16 <oklopol> :t (,)
16:36:18 <lambdabot> forall a b. a -> b -> (a, b)
16:36:23 <oklopol> :t (,,)
16:36:25 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
16:36:37 <oklopol> > (,,,) 1 2 3 4
16:36:38 <lambdabot>  (1,2,3,4)
16:36:39 <ari> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
16:36:41 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -
16:36:41 <lambdabot> > t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z,
16:36:41 <lambdabot>  t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39)
16:36:44 <sorear> :t (,).(,).(,).(,).(,).(,).(,)
16:36:46 <lambdabot> forall b b1 b2 b3 b4 b5 a b6. -> b -> (b1 -> (b2 -> (b3 -> (b4 -> (b5 -> (b6 -> (a, b6), b5), b4), b3), b2), b1), b)
16:37:14 <sorear> :t (***).(***)
16:37:16 <lambdabot> forall b' c' (a :: * -> * -> *) b c b'1 c'1. (Arrow a) => a b c -> (b' -> c') -> (a b'1 c'1, b') -> (a (b, b'1) (c, c'1), c')
16:37:21 <fax> haha
16:37:27 <sorear> :t (***).(***).(***).(***).(***).(***)
16:37:28 <oklopol> :t (***)
16:37:29 <lambdabot> forall b' c' b'1 c'1 b'2 c'2 b'3 c'3 b'4 c'4 (a :: * -> * -> *) b c b'5 c'5. (Arrow a) => a b c -> (b' -> c') -> (b'1 -> c'1, b') -> ((b'2 -> c'2, b'1) -> ((b'3 -> c'3, b'2) -> ((b'4 -> c'4, b'3) ->
16:37:29 <lambdabot> ((a b'5 c'5, b'4) -> (a (b, b'5) (c, c'5), c'4), c'3), c'2), c'1), c')
16:37:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:37:34 <oklopol> hmm...
16:37:38 <sjanssen> enough with the flooding
16:37:52 <oklopol> how did it convert into point-free?
16:38:02 <oerjan>  @pl
16:38:03 <sorear> @pl let { a = a; b = (a,a); c = (b,b); d = (c,c); e = (d,d); f = (e,e); g = (f,f); h = (g,g) } in (h,h)
16:38:03 <lambdabot> (line 1, column 5):
16:38:04 <lambdabot> unexpected "{"
16:38:04 <lambdabot> expecting natural, identifier or "in"
16:38:12 <sorear> @pl let a = a; b = (a,a); c = (b,b); d = (c,c); e = (d,d); f = (e,e); g = (f,f); h = (g,g) in (h,h)
16:38:28 <fax> your gonna kill lambdabot!
16:38:40 <oklopol> @pl let f a = a*4 in f 2
16:38:46 <oklopol> hmm...
16:38:47 <oerjan> @bot
16:38:59 <sorear> @activity-full
16:39:01 <fax> busy computing explosive stuff
16:39:33 <Saizan_> no time limit on @pl?
16:39:52 <sjanssen> that terminates very quickly on my machine
16:40:15 <sorear> I suspect someone is hogging the bot in /msg
16:40:37 <mauke> @hug
16:40:53 <glen_quagmire> hug me instead
16:41:20 <oklopol> glen_quagmire: i saw you hit on peter's wife today
16:41:24 <lambdabot> Plugin `pl' failed with: IRCRaised thread killed
16:41:24 <lambdabot> 8
16:41:24 <lambdabot> :)
16:41:24 <lambdabot> 4*total 4*#haskell
16:41:28 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:41:38 <sjanssen> @activity-full
16:41:39 <lambdabot> 9*total 6*#haskell 3*Armor_Azrael
16:41:39 <sorear> @activity 900
16:41:40 <lambdabot> 90*total 64*#haskell 25*private 1*#perl6
16:41:49 <sorear> @activity-full 900
16:41:49 <lambdabot> 91*total 65*#haskell 22*Armor_Azrael 3*scandal 1*#perl6
16:42:10 <oklopol> @pl let f a = a*2 in f 3
16:42:10 <lambdabot> 6
16:42:14 <oklopol> oh :)
16:42:28 <oklopol> @pl (\ z -> z*2)
16:42:28 <lambdabot> (2 *)
16:42:28 <sjanssen> sorear: which command can hang the bot that long?
16:42:39 <fax> @pl (\(x,_,_)->x)
16:42:40 <lambdabot> (line 1, column 7):
16:42:40 <lambdabot> unexpected ","
16:42:40 <lambdabot> expecting operator or ")"
16:42:40 <lambdabot> ambiguous use of a non associative operator
16:42:50 <oerjan> there _could_ have been just lag...
16:42:58 <fax> > (\(x,_,_)->x) $ (,,) 1 2 3
16:43:00 <lambdabot>  1
16:43:05 <sorear> sjanssen: nothing can hang the bot CPU-wise, because it's threaded to the point of reliably experiencing concurrency bugs
16:43:06 <fax> @pl (\(x,_,_)->x) $ (,,)
16:43:07 <lambdabot> (line 1, column 7):
16:43:07 <lambdabot> unexpected ","
16:43:07 <lambdabot> expecting operator or ")"
16:43:07 <lambdabot> ambiguous use of a non associative operator
16:43:10 <fax> >:|
16:43:21 <sorear> sjanssen: but if someone asked for 22 lines of data, it would hold the bot for 44 seconds
16:43:24 <oerjan> will someone @flush it?
16:43:28 <sorear> sjanssen: IRC flood control is EVIL
16:43:32 <sorear> @flush
16:43:35 <sjanssen> sorear: ah, right
16:43:36 <dons> ?bot
16:43:37 <lambdabot> :)
16:44:01 <oklopol> hmm... is pattern matching the only way to get something out of a tuple?
16:44:13 <oerjan> oklopol: except for pairs
16:44:19 <sjanssen> oklopol: yes
16:44:22 <dons> oklopol: or define a catamorphism for the type, and use that instead
16:44:39 <fax> catamorphism? :|
16:44:47 <sjanssen> oklopol: pattern matching, or things defined in terms of pattern matching
16:44:49 <dons> when we get a new cat, i'm going to lobby for `catamorph' as its name
16:45:05 <dons> fax, elimination functions for the type
16:45:18 <fax> oh ok
16:45:19 <dons> they're a cat-astrophe for the value when you apply them , is how i remember which it is
16:45:24 <fax> hehe
16:45:30 <fax> I didn't know this was possible
16:45:34 <dons> :t maybe -- for example
16:45:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:46:04 <mauke> I know "cata" means down and "ana" means up, but that doesn't help me remember which is which :/
16:46:24 <sjanssen> fax: maybe, either, foldr and uncurry are the catamorphisms defined in the Prelude
16:46:30 <oklopol> > 4 .^. 2
16:46:31 <lambdabot>   Not in scope: `.^.'
16:46:38 <mauke> > 4 `xor` 2
16:46:38 <oklopol> hmm... is there a zor?
16:46:39 <lambdabot>  Add a type signature
16:46:40 <oklopol> ...
16:46:42 <oklopol> zorro
16:46:46 <mauke> > 4 `xor` 2 ::Int
16:46:48 <lambdabot>  6
16:46:54 <oklopol> ah i see
16:47:01 <oerjan> @docs Data.Bits
16:47:01 <dons> what's the catamorphism for () ?
16:47:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
16:47:06 <oklopol> > 3 `or` 4
16:47:06 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Bool'
16:47:13 <sjanssen> dons: const
16:47:15 <dons> (() -> b) -> () -> b
16:47:16 <oklopol> > 3 `or` 4 :: Int
16:47:17 <lambdabot>  Couldn't match expected type `t -> Int'
16:47:20 <sjanssen> hrm, maybe not
16:47:27 <oklopol> that's kinda dissappointing too :<
16:47:32 <dons> ?djinn (() -> b) -> () -> b
16:47:33 <lambdabot> f a = a
16:47:35 <sjanssen> dons: flip const
16:47:39 <dons> ?. pl djinn (() -> b) -> () -> b
16:47:39 <lambdabot> f = id
16:47:47 <fax> :t djinn
16:47:48 <mauke> it shouldn't be (() -> b)
16:47:49 <lambdabot> Not in scope: `djinn'
16:47:52 <dons> yeah, that's the id == const use of id
16:47:58 <oklopol> xor is being ostracised
16:48:05 <sjanssen> no, changed my mind again -- const
16:48:07 <oerjan> :t or
16:48:09 <lambdabot> [Bool] -> Bool
16:48:26 <oklopol> ah, those are list operators
16:48:30 <nominolo> > 4 .|. 1 :: Int
16:48:31 <lambdabot>  5
16:48:32 <oerjan> :t xor
16:48:33 <oklopol> or functions, but anyway
16:48:34 <lambdabot> forall a. (Bits a) => a -> a -> a
16:48:39 <oerjan> except xor
16:48:44 <fax> @hoogle ([a] -> b) -> a -> a -> b
16:48:45 <oklopol> > True
16:48:45 <lambdabot> No matches, try a more general search
16:48:46 <sjanssen> @type maybe
16:48:46 <lambdabot>  True
16:48:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:48:58 <oklopol> > and [True, True..]
16:48:58 <lambdabot>  Parse error
16:49:01 <oklopol> hmm :P
16:49:01 <sjanssen> () is the same as data Maybe = Just
16:49:06 <oklopol> > and repeat True
16:49:07 <lambdabot>  Couldn't match expected type `[Bool]'
16:49:09 <sjanssen> erm, data Maybe = Nothing
16:49:14 <oklopol> > repeat 4
16:49:16 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
16:49:19 <oklopol> > repeat True
16:49:20 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
16:49:27 <oklopol> > and repeat True
16:49:28 <lambdabot>  Couldn't match expected type `[Bool]'
16:49:34 <fax> > repeat $ repeat []
16:49:34 <oklopol> > and repeat (True :: Bool)
16:49:35 <lambdabot>  Couldn't match expected type `[Bool]'
16:49:36 <lambdabot>  [[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
16:49:38 <sjanssen> so we cut out the Just parts related from maybe's type, and come up with "unit :: a -> () -> a"
16:49:49 <nominolo> > and (repeat True)
16:49:51 <lambdabot>  Exception: <<loop>>
16:50:24 <nominolo> > and (take 42 (repeat True))
16:50:25 <oklopol> ah, left-associative function application
16:50:26 <lambdabot>  True
16:50:29 <oklopol> i always forget
16:50:45 <oklopol> > and (repeat True) === True!
16:50:46 <lambdabot>   parse error on input `}'
16:50:51 <oklopol> i own you, lambdabot
16:51:12 <fax> > repeat $ iterate (\(x,y) -> (y+1,x+y)) (0,1)
16:51:14 <lambdabot>  [[(0,1),(2,1),(2,3),(4,5),(6,9),(10,15),(16,25),(26,41),(42,67),(68,109),(11...
16:51:14 <oklopol> i guess he did what haskell's supposed to, though
16:51:54 <fax> > (,) $ take 2 (repeat (map fst $ iterate (\(x,y) -> (y+1,x+y)) (0,1)))
16:51:55 <lambdabot>  Add a type signature
16:52:04 <oklopol> wow, iterate is like the most beautiful function i ever saw
16:52:17 * nominolo never used iterate
16:52:17 <oklopol> > iterate (\a -> a+1) 1
16:52:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:52:23 <EvilTerran> i'm not sure... does the report guarantee the presence of bottoms in various places, or merely their absence in others?
16:52:23 <sorear> dons: seq
16:52:23 <oerjan> oklopol: lambdabot is generally considered a she hereabouts :)
16:52:26 <fax> :t (iterate repeat)
16:52:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
16:52:28 <lambdabot>       Expected type: a -> a
16:52:32 <fax> damn!
16:52:39 <kpreid> oklopol: check this out:
16:52:49 <kpreid> > iterate succ minBound :: Integer
16:52:50 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
16:52:56 <kpreid> er...
16:52:59 <kpreid> > iterate succ minBound :: [Integer]
16:53:01 <lambdabot>   add an instance declaration for (Bounded Integer)
16:53:02 <sorear> > (seq :: () -> a -> a) () 12
16:53:03 <lambdabot>  12
16:53:07 <kpreid> *sigh*
16:53:09 <kpreid> > iterate succ minBound :: [Int]
16:53:10 <oklopol> tell me when to check out :P
16:53:10 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
16:53:14 <oklopol> oh
16:53:16 <kpreid> > iterate succ minBound :: [Char]
16:53:17 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
16:53:22 <kpreid> > iterate succ minBound :: [Bool]
16:53:23 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
16:53:32 <kpreid> heh. not so widely applicable.
16:53:35 <EvilTerran> ie, would it be correct for an implementation to produce True when asked to evaluate and (repeat True)?
16:53:45 <dons> http://programming.reddit.com/info/2p9ru/comments
16:53:46 <lambdabot> Title: Building an ecosystem of smart hackers (reddit.com)
16:53:54 <EvilTerran> > takeWhile (/=maxBound) $ iterate succ minBound :: [Bool]
16:53:56 <lambdabot>  [False]
16:53:59 <nominolo> > iterate succ (toChar 128)
16:54:00 <lambdabot>   Not in scope: `toChar'
16:54:10 <EvilTerran> > enumFrom minBound :: [Bool]
16:54:12 <lambdabot>  [False,True]
16:54:13 <oklopol> > chr 128
16:54:14 <lambdabot>  '\128'
16:54:14 <nominolo> @ho Int -> Char
16:54:14 <lambdabot> Maybe you meant: hoogle hoogle+ . bf echo ft ghc id pl rc show thx v wn yow
16:54:15 <EvilTerran> > enumFrom minBound :: [Char]
16:54:16 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
16:54:19 <EvilTerran> > enumFrom minBound :: [Int]
16:54:20 <oerjan> EvilTerran: i think somewhere it is specified that recursion gives the least fixedpoint, which is often bottom
16:54:20 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
16:54:22 <oklopol> or
16:54:28 <nominolo> > iterate succ (chr 128)
16:54:29 <lambdabot>  "\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\144\145\14...
16:54:30 <oklopol> > toEnum 128 :: Char
16:54:31 <lambdabot>  '\128'
16:54:32 <EvilTerran> oerjan, oh, okay
16:54:47 <nominolo> i want unicode!
16:55:08 <oklopol> > 5 + _|_
16:55:08 <lambdabot>  Parse error
16:55:11 <oklopol> > 5 + (_|_)
16:55:11 <lambdabot>  Parse error
16:55:15 <oklopol> > (_|_)
16:55:15 <lambdabot>  Parse error
16:55:18 <EvilTerran> nominolo, kpreid, etc: might enumFrom be better than (iterate succ), as it behaves better when it runs out of elements?
16:55:18 <oklopol> hmm
16:55:27 <kpreid> EvilTerran: yes, it is...
16:55:30 <nominolo> @let _|_ = undefined
16:55:31 <lambdabot>  Parse error in expression
16:55:33 <kpreid> I just wanted a more general iterate
16:55:34 <EvilTerran> oklopol, bottom is written "undefined"
16:55:37 <nominolo> @let (_|_) = undefined
16:55:37 <lambdabot>  Parse error
16:55:46 <sorear> Î±, Î², Î³, Î´, Îµ, Î¶, Î·, ..
16:55:58 <oklopol> ah
16:56:00 <oklopol> hmm...
16:56:06 <EvilTerran> you can't have a value called _|_, 'cos | is a punctuation mark and _ is a letter
16:56:08 <kpreid> @src undefined
16:56:09 <oklopol> i recall seeing _|_ used somewhere
16:56:09 <EvilTerran> ;)
16:56:09 <nominolo> @cookie for sorearbot
16:56:09 <lambdabot> undefined =  error "Prelude.undefined"
16:56:09 <lambdabot> Unknown command, try @list
16:56:21 <fax> > foldr (+) 1 [2,3,4]
16:56:23 <lambdabot>  10
16:56:24 <sorear> @quote _._
16:56:25 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
16:56:25 <oklopol> is it just like a general "bottom" sign?
16:56:27 <fax> > foldr (,) 1 [2,3,4]
16:56:28 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
16:56:28 <lambdabot>       Expec...
16:56:30 <kpreid> oklopol: _|_ is used as an ascii substitute for the inverted-T symbol
16:56:36 <sorear> aww, the mauke quote is gone
16:56:39 <EvilTerran> oklopol, it's used in literature, sometimes in pseudo-haskell snippets therein, but you can't use it in real haskell
16:56:43 <sorear> â¥ !
16:56:44 <fax> > (1,(2,(3,4)))
16:56:46 <lambdabot>  (1,(2,(3,4)))
16:56:53 <fax> Why can't I foldr (,)? :/
16:56:58 <EvilTerran> type!
16:57:00 <EvilTerran> :t foldr
16:57:01 <oerjan> oklopol: someone mentioned (_|_) earlier, almost got me to protest
16:57:02 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:57:08 <mauke> :t (,)
16:57:11 <lambdabot> forall a b. a -> b -> (a, b)
16:57:11 <EvilTerran> the first parameter of foldr has to be (a->b->b)
16:57:11 <oerjan> but the channel went too fast
16:57:21 <fax> ah ok
16:57:24 <mauke> b = (a, b)
16:57:24 <mauke> NO BUS NO
16:57:26 <kpreid> fax: if you define it as a typeclass instead you can have it!
16:57:27 <oklopol> > (|)
16:57:27 <lambdabot>  Parse error
16:57:30 <nominolo> fax, because the types are differnt for each application of (,)
16:57:34 <EvilTerran> but (,) doesn't return something of the type of its first parameter
16:57:37 <EvilTerran> *second
16:57:39 <kpreid> wait...no.
16:57:39 <oklopol> > let (|) = "vagina" in (|)
16:57:39 <lambdabot>  Parse error
16:57:42 <oklopol> hmm
16:57:45 <oklopol> | is illegal?
16:57:47 <oklopol> oh
16:57:49 <EvilTerran> | is guards
16:57:49 <oklopol> indeed.
16:57:51 <sorear> right, reservedop
16:57:51 <oklopol> yep
16:58:10 <oklopol> you could've made _|_ otherwise
16:58:34 <nominolo> kpreid, nono, type family
16:58:38 <oklopol> let _I_ = "bottom" in _I_
16:58:44 <oklopol> > let _I_ = "bottom" in _I_
16:58:46 <lambdabot>  "bottom"
16:58:51 <kpreid> nominolo: that's the NDP-support thing right?
16:59:11 <nominolo> kpreid, that's AT + ATS
16:59:21 <nominolo> not sure what NDP stands for :)
16:59:31 <mauke> nested data parallelism
16:59:31 * kpreid is not up on the latest type system hackery
16:59:34 <oklopol> what, i've been playing with the bot for almost an hour?!?
16:59:36 <oklopol> :|
16:59:44 <oklopol> gotta go to sleep i guess...
16:59:54 <nominolo> kpreid, no, it's associated types (synonyms)
17:00:21 <EvilTerran> functions for types, if you prefer.
17:00:34 <EvilTerran> altho it's more like relations. ish. i guess.
17:00:35 <nominolo> kpreid, see the @cafe thread with C++ in the title
17:00:37 <fax> > let q f l = (case l of [] -> [] ; [x:xs] -> x) in q 4 [[[5]]]
17:00:47 <lambdabot>  [5]
17:00:54 <nominolo> @where associated types
17:00:54 <lambdabot> I know nothing about associated.
17:01:14 <nominolo> @where chak
17:01:14 <lambdabot> I know nothing about chak.
17:01:28 <oklopol> http://kontsevoy.blogspot.com/2007/09/self-organizing-armies-of-hackers.html <<< "Are good programmers cost more?" is that intentional or do i fail miserably at english..?
17:01:30 <lambdabot> Title: Ev's Rants: On Ecosystems of Smart Hackers, http://tinyurl.com/ywg2hq
17:01:47 <fax> can you write a func like foldr which works wityh (,) ?
17:01:50 <sorear> @go Manuel M T Chakravarty
17:01:51 <lambdabot> http://www.cse.unsw.edu.au/~chak/
17:01:52 <lambdabot> Title: Manuel M T Chakravarty
17:02:05 <sorear> aka ChilliX, if you want fast answers
17:02:08 <sorear> (but not now)
17:02:26 <oerjan> fax: you can do something with type classes
17:02:28 <nominolo> http://haskell.org/haskellwiki/GHC/Type_families
17:02:29 <lambdabot> Title: GHC/Type families - HaskellWiki
17:02:34 <fax> without type classes?
17:02:39 <EvilTerran> fax, yes. kinda. as others've said, it involves type class hackery.
17:02:40 <nominolo> yep
17:02:44 <oerjan> no
17:02:59 <EvilTerran> you might be able to do something with existentials, but it'd be useless.
17:03:25 <fax> I can't do this with typeclasses
17:03:26 <mauke> haha
17:03:28 <nominolo> type instance ... :)
17:03:29 <EvilTerran> why not?
17:04:20 <nominolo> instance TList (); instance TList a => instance TList (b,a);
17:04:57 <nominolo> instance TFoldr () () where tfoldr _ = ()
17:05:28 <nominolo> well, sort of
17:05:37 <EvilTerran> needs moar hackery
17:05:42 <EvilTerran> someone call Oleg
17:05:51 <nominolo> just google for HList
17:05:56 <mauke> who you gonna call?
17:06:09 <nominolo> HCons a l   is isomorphic to (a,l)
17:06:18 <oerjan> @quote who.*call
17:06:18 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
17:06:21 <nominolo> oleg kiselyov
17:06:46 <nominolo> i think i mispeled him
17:06:59 <mauke> @where oleg
17:06:59 <lambdabot> http://okmij.org/ftp/
17:07:13 <EvilTerran> nay, that's right.
17:07:16 <EvilTerran> *nah
17:07:33 <EvilTerran> i hope "mispeled" was deliberate, though.
17:07:56 <oerjan> one should always misple that.
17:08:18 <nominolo> i always mispel misspell
17:08:25 <fax> :t read "[]" :: [[[[[Int]]]]]
17:08:27 <lambdabot> [[[[[Int]]]]] :: [[[[[Int]]]]]
17:08:54 <nominolo> > read "[]" :: [[[[[Int]]]]
17:08:55 <lambdabot>  Parse error
17:09:03 <nominolo> > read "[]" :: [[[[[Int]]]]]
17:09:08 <lambdabot>  []
17:09:20 <fax> > read "[]" :: [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[Int]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
17:09:21 <mauke> > read "[]" :: [Char]
17:09:21 <lambdabot>          let
17:09:22 <lambdabot>           nwi = read "[]" ::
17:09:22 <lambdabot>                   [[[[[[[[[[[[[[[[[...
17:09:22 <lambdabot>  ""
17:09:32 <EvilTerran> crikey.
17:09:45 <nominolo> ?
17:09:51 <fax> what happened
17:09:57 <EvilTerran> you broke it!
17:10:00 <fax> :(
17:10:02 <mauke> > read "[]" :: [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[Int]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
17:10:04 <lambdabot>          let
17:10:04 <lambdabot>           jdk = read "[]" ::
17:10:04 <lambdabot>                   [[[[[[[[[[[[[[[[[...
17:10:08 <EvilTerran> @vixen are you okay over there?
17:10:08 <lambdabot> yes, still here
17:10:16 <mauke> > read "[]" :: [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[Int]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
17:10:18 <lambdabot>          let
17:10:18 <lambdabot>           zru = read "[]" ::
17:10:18 <lambdabot>                   [[[[[[[[[[[[[[[[[...
17:10:29 <EvilTerran> @vixen what's with the TLA variable names?
17:10:29 <lambdabot> let's don't talk about that
17:10:37 <EvilTerran> huh. you heard the lady.
17:10:37 <mauke> ok, it uses random identifiers of length 3
17:11:21 <balodja> that's part of hs-plugins, i think
17:11:29 <sorear> nah, just runplugs
17:11:38 <sorear> cf @v
17:11:41 <mauke> still, wtf is going on here
17:11:48 <sorear> laziness
17:11:54 <nominolo> @yow
17:11:55 <lambdabot> Where does it go when you flush?
17:11:56 <sorear> > v
17:11:57 <lambdabot>   Not in scope: `v'
17:11:58 <Igloo> It's part of an error:
17:11:58 <Igloo>     Context reduction stack overflow; size = 20
17:11:58 <Igloo>     Use -fcontext-stack=N to increase stack size to N
17:12:01 <chessguy> 'evening
17:12:08 <sorear> @v
17:12:08 <lambdabot> Just 'J'
17:12:09 <sorear> @v
17:12:09 <lambdabot> "\"#$%&'()*+,\""
17:12:11 <sorear> @v
17:12:11 <lambdabot> "\"#$%&'()*+,\""
17:12:12 <sorear> @v
17:12:13 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
17:12:13 <sorear> @v
17:12:14 <lambdabot> "\"#$%&'()*+,\""
17:12:16 <sorear> @v
17:12:16 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
17:12:21 <EvilTerran> @help v
17:12:21 <lambdabot> let v = show v in v
17:12:24 <sorear> > let v = show v in show v
17:12:25 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:12:26 <mauke> > fix show
17:12:28 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:12:32 <EvilTerran> oy
17:12:34 <oklopol> @v
17:12:35 <lambdabot> Exception: <<loop>>
17:12:37 <oklopol> @v
17:12:37 <lambdabot> Exception: <<loop>>
17:12:39 <oklopol> @v
17:12:40 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
17:12:41 <sorear> > let v = head v in v
17:12:42 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:12:42 <EvilTerran> evenin' chessguy
17:12:42 <lambdabot>       Expected...
17:12:43 <oklopol> what...?
17:12:44 <sorear> > let v = v in v
17:12:45 <fax> :|
17:12:45 <lambdabot>  Exception: <<loop>>
17:12:45 <mauke> @list v
17:12:46 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
17:12:53 <mauke> @yhjulwwiefzojcbxybbruweejw
17:12:54 <sorear> > let v = take 10 (show v) in v
17:12:54 <lambdabot> "\"#$%&'()*+,\""
17:12:55 <fax> @ yhjulwwiefzojcbxybbruweejw
17:12:55 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\"
17:12:55 <EvilTerran> so, what does @v actually do?
17:13:05 <chessguy> anybody tried this Vital GUI yet?
17:13:23 <EvilTerran> ah, it's part of @quote. still, weird...
17:13:37 <shapr> chessguy: Pivotal is the successor
17:13:41 <EvilTerran> "yhjulwwiefzojcbxybbruweejw"? what is that, welsh?
17:14:09 <dbueno> If I want to batch-run (using Test.QuickCheck.Batch in GHC) a bunch of property checking, how can I make one list of all my property-checking functions, since their concrete types differ so wildly?
17:14:12 <chessguy> oh, interesting
17:14:16 <Saizan_> @brain
17:14:16 <lambdabot> But where are we going to find a duck and a hose at this hour?
17:14:24 <kpreid> EvilTerran: @v produces text that can be produced by poking the old "v" bug in lambdabot
17:14:33 <EvilTerran> the v bug?
17:14:38 <kpreid> once upon a time,
17:14:48 <mauke> it's in the logs somewhere
17:14:57 <EvilTerran> o/` it's pinky, it's pinky and the brain brain brain brain braaiinn... o/`
17:15:04 <nominolo> @v for vendetta
17:15:04 <oerjan> dbueno: existential type
17:15:04 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
17:15:08 <kpreid> lambdabot wrapped the eval-string in:
17:15:18 <kpreid> let v = show (YOUR CODE HERE) in v -- or something like this, I forget the motivation
17:15:23 <fax> > iterate (\(x,y,z,w)->(y,z,w,x)) (1,2,3,4)
17:15:25 <lambdabot>  [(1,2,3,4),(2,3,4,1),(3,4,1,2),(4,1,2,3),(1,2,3,4),(2,3,4,1),(3,4,1,2),(4,1,...
17:15:32 <kpreid> so if you made reference to v in your code, you'd get entertaining results
17:15:34 <dbueno> oerjan ... seriously?  I guess I'll have to look into those.  I have no idea how they work.
17:15:44 <kpreid> for example, "> v" works out to being fix show
17:15:50 <EvilTerran> ah. intriguing.
17:16:06 <kpreid> or "> Just (head v)" gives you Just 'J'
17:16:17 <EvilTerran> "\"#$%&'()*+,\""?
17:16:22 <kpreid> before I figured it out I was thinking, this is a mighty freaky value
17:16:23 <fax> wow
17:16:29 <fax> Why does it print out random stuff though?
17:16:34 <kpreid> for example, "> head v" would die
17:16:50 <chessguy> @where plugins
17:16:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
17:16:51 <kpreid> because the Char instance of Show is overly strict
17:16:58 <kpreid> it requires that the char be defined to print the initial '
17:17:05 <oklopol> @v
17:17:05 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
17:17:06 <kpreid> > fix (head . show)
17:17:08 <lambdabot>  Exception: <<loop>>
17:17:08 <oklopol> @v
17:17:08 <lambdabot> "\""
17:17:15 <oklopol> what's @v?
17:17:22 <kpreid> fax: @v is one of the family of random-quote commands
17:17:30 <oklopol> oh
17:17:33 <kpreid> just like @vixen and @palomer and @protontorpedo
17:17:37 <oklopol> @palomer
17:17:37 <lambdabot> Hrmph
17:17:40 <EvilTerran> oklopol, kpreid just explained. it's in the scrollback.
17:17:40 <kpreid> @protontorpedo
17:17:40 <oklopol> @palomer
17:17:40 <lambdabot> Blargh!
17:17:41 <lambdabot> i have a win xp box
17:17:48 <fax> let v = show "v" in v
17:17:48 <kpreid> @keal
17:17:49 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
17:17:53 <fax> > let v = show "v" in v
17:17:55 <lambdabot>  "\"v\""
17:18:02 <fax> > let v = show v in v
17:18:04 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:18:05 <EvilTerran> @help quote
17:18:05 <lambdabot> quote <nick>
17:18:05 <lambdabot> remember <nick> <quote>
17:18:05 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:18:06 <kpreid> > let v = show (head v) in v
17:18:08 <fax> Why the \\\ ?
17:18:08 <lambdabot>  Exception: <<loop>>
17:18:13 <EvilTerran> @list quote
17:18:13 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
17:18:16 <kpreid> fax: quoted quoted quote
17:18:17 <oklopol> @quote oklopol
17:18:17 <lambdabot> oklopol says: you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
17:18:20 <fax> ahh
17:18:22 <fax> ok
17:18:33 <fax> > let v = show v in drop 10 v
17:18:34 <kpreid> > ["\"", show "\""]
17:18:34 <lambdabot>  "\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
17:18:36 <lambdabot>  ["\"","\"\\\"\""]
17:18:48 <kpreid> > iterate show ""
17:18:50 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
17:18:55 <oerjan> > fix (('\'').head.show.tail)
17:18:56 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Char'
17:18:58 <EvilTerran> vixen isn't just a random phrase generator, is it?
17:19:01 <fax> > concat $ iterate show ""
17:19:03 <lambdabot>  "\"\"\"\\\"\\\"\"\"\\\"\\\\\\\"\\\\\\\"\\\"\"\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\...
17:19:12 <EvilTerran> @vixen you're much more sophisticated than that, aren't you?
17:19:13 <lambdabot> me?
17:19:22 <EvilTerran> @vixen yes, you
17:19:22 <lambdabot> i thought so
17:19:36 <EvilTerran> i think i've upset her =//
17:19:38 <Saizan_> @help vixen
17:19:38 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
17:19:43 <oerjan> > fix (('\'':).tail.head.show)
17:19:44 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
17:19:51 <fax> @vixen concat $ iterate show ""
17:19:52 <lambdabot> Why is magenta on blues clues a boy while blue is a girl? what has this world come to and what is wrong with the government, blues clues should be stopped while its ahead!!
17:19:58 <oerjan> > fix (('\'':).tail.map show)
17:20:00 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
17:20:07 <EvilTerran> er.
17:20:12 <fax> lol
17:20:13 <oerjan> argh
17:20:42 <dbueno> oerjan: That is total magic.  Thanks for telling me.
17:20:47 <EvilTerran> what's @yhjulwwiefzojcbxybbruweejw, then? is that what v got renamed to to reduce the odds of collision?
17:21:07 <fax> let yhjulwwiefzojcbxybbruweejw = v in yhjulwwiefzojcbxybbruweejw
17:22:12 <mauke> EvilTerran: look in 06.04.29
17:22:18 <EvilTerran> @where logs
17:22:18 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
17:22:32 <EvilTerran> that needs updated, the second link's moved
17:22:43 <chessguy> anybody know what this means when trying to do a runghc Setup.lhs configure?
17:22:44 <chessguy> checking for C compiler default output file name... configure: error: C compiler
17:22:44 <chessguy>  cannot create executables
17:23:13 <gwern> chessguy: sounds like you may not have permission to run GCC. I know some systems restrict compilation to root. bastille for example offers to do that
17:23:39 <chessguy> nah, i'm the only user on the system
17:23:42 <chessguy> i think
17:23:51 <chessguy> it's just cygwin under windows
17:23:53 <EvilTerran> > (+) (3,4)
17:23:54 <lambdabot>   add an instance declaration for (Num (t, t1))
17:23:54 <lambdabot>     In the expression: (+) (3...
17:23:56 <gwern> (as part of its hardening process, since it makes life easier on people attempting local privilege escalation if they can compile their sploits)
17:24:26 <fax> f (,) [1..] = [(1,2),(3,4),(5,6),...] ?
17:24:29 <oerjan> > fix (('\'':).tail.concatMap show)
17:24:31 <lambdabot>  "'\\'''\\\\''\\'''\\'''\\'''\\\\''\\\\''\\'''\\'''\\\\''\\'''\\'''\\'''\\\\'...
17:24:32 <gwern> chessguy: oh, windows? I was just about to say that all unix systems have root and a bunch ofother users and that you probably aren't and shouldn't be running as root
17:24:33 <fax> is there something already which does that
17:24:34 <EvilTerran> mauke, sorry, is that yy.mm.dd? i see one mention ofit there, and it doesn't seem very explanatory
17:24:49 <fax> @hoogle (a -> b) -> [a] -> [b]
17:24:50 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
17:24:50 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
17:24:50 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
17:25:05 <fax> @hoogle (a -> a -> b) -> [a] -> [b]
17:25:06 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
17:25:06 <lambdabot> Control.Parallel.Strategies.parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
17:25:06 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
17:25:14 <EvilTerran> > (zipWith (,) `ap` tail) [1..]
17:25:15 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
17:25:27 <fax> > scanl1 (,) [1..]
17:25:27 <EvilTerran> > (filter (odd.head) . zipWith (,) `ap` tail) [1..]
17:25:28 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
17:25:28 <lambdabot>       Expec...
17:25:28 <lambdabot>      precedence parsing error
17:25:28 <lambdabot>         cannot mix `(.)' [infixr 9] and `ap' [i...
17:25:42 <mauke> EvilTerran: http://tunes.org/~nef/logs/haskell/06.04.29 contains at least 12 instances of yhjulwwiefzojcbxybbruweejw
17:25:50 <EvilTerran> > (filter (odd.head) . (zipWith (,) `ap` tail)) [1..]
17:25:51 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, b)'
17:26:01 <EvilTerran> > (filter (odd.fst) . (zipWith (,) `ap` tail)) [1..] -- :P
17:26:03 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
17:26:09 <fax> > zipWith (,) [1..] (reverse [1..])
17:26:13 <lambdabot> Terminated
17:26:17 <EvilTerran> ah, whups; sorry mauke, misclick on my part.
17:26:43 <EvilTerran> i was looking at the 27th for some reason
17:27:08 <oerjan> fax: reversing infinite lists is generally a bad idea :D
17:27:17 <fax> hehe
17:27:32 <fax> why doesn't it just write [(1,99999999999............. :P
17:28:45 <EvilTerran> > fix (show . map succ)
17:28:47 <lambdabot>  "\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]]^^__``aabb...
17:29:07 <EvilTerran> that's damn weird.
17:29:24 <oerjan> heh
17:29:28 <fax> wtf
17:29:37 <fax> oh wait I get it
17:29:51 <oerjan> it gets derailed at the backslash
17:30:08 <shachaf> > succ '"'
17:30:09 <lambdabot>  '#'
17:30:48 <LoganCapaldo> aroo
17:31:04 <oerjan> hm...
17:31:14 <LoganCapaldo> oh
17:31:18 <LoganCapaldo> I get it
17:31:20 <LoganCapaldo> tee hee
17:31:36 <dbueno> > :t fix
17:31:36 <lambdabot>   parse error on input `:'
17:31:41 <fax> > concat $ iterate reverse ['a'..'z']
17:31:42 <lambdabot>  "abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvw...
17:31:51 <dbueno> :t fix
17:31:53 <lambdabot> forall a. (a -> a) -> a
17:31:56 <shachaf> dbueno: @type or just :t.
17:32:01 <fax> > concat $ iterate (reverse . tail) ['a'..'z']
17:32:03 <lambdabot>  Exception: Prelude.tail: empty list
17:32:05 <dbueno> shachaf: Thanks.
17:32:18 <balodja> > pred '\NUL'
17:32:19 <lambdabot>  Exception: Prelude.Enum.Char.pred: bad argument
17:32:23 <fax> > let tail [] = [] in concat $ iterate (reverse . tail) ['a'..'z']
17:32:24 <lambdabot>   Non-exhaustive patterns in function tail
17:32:33 <fax> >:|
17:32:44 <sorear> Parse error
17:32:49 <mauke> > concat $ iterate (reverse . drop 1) ['a' .. 'z']
17:32:53 <lambdabot> Terminated
17:33:01 <fax> [x] = [x]
17:33:15 <oerjan> fax: use drop 1
17:33:28 <sorear> > cycle $ ap (++) reverse $ ['a'..'z']
17:33:29 <lambdabot>  "abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvw...
17:34:16 <oerjan> although actually that won't work either, as concat breaks when it reaches an infinite list of []'s
17:34:21 <fax> > take (25*24/2) concat $ iterate (reverse . drop 1) ['a' .. 'z']
17:34:22 <lambdabot>  Couldn't match expected type `[a]'
17:34:33 <fax> > take (25*24/2) $ concat $ iterate (reverse . drop 1) ['a' .. 'z']
17:34:34 <lambdabot>   add an instance declaration for (Fractional Int)
17:34:46 <fax> > take (25*24 `div` 2) $ concat $ iterate (reverse . drop 1) ['a' .. 'z']
17:34:47 <lambdabot>  "abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcbbcdefghijklmnopqrstuvwxy...
17:35:52 <oerjan> fax: takeWhile (not.null) is nice to put in there
17:36:43 <nominolo> > cycle $ ap (++) reverse $ ['a'..'d']
17:36:44 <lambdabot>  "abcddcbaabcddcbaabcddcbaabcddcbaabcddcbaabcddcbaabcddcbaabcddcbaabcddcbaabc...
17:37:07 <nominolo> :t ap
17:37:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:37:09 <atp> hey guys, how do i associate a module with a particular file?  i'm using ghc(i)
17:37:23 <ddarius> atp... you have no choice...
17:37:29 <ddarius> (in practice)
17:37:30 <oerjan> atp: name the file Module.hs
17:37:43 <atp> ah, i see, it looks for a file with the same name?
17:37:49 <oerjan> yep
17:37:50 <atp> because i know that if i load it first,
17:37:56 <atp> ghci will recognize it
17:38:18 <atp> i thought maybe there was a command line option or something
17:38:24 <oerjan> if there are dots in the module name you need to use subdirectories
17:38:41 <atp> i see, so haskell actually enforces some filesystem related stuff, huh
17:38:53 <oerjan> yep
17:38:56 <ddarius> No.  Implementations do.
17:39:07 <ddarius> That said.  -All- implementations do.
17:39:09 <mauke> IIRC jhc is more flexible
17:39:12 <atp> ddarius: good to know :)
17:39:22 <ddarius> Well all practical implementations.
17:39:23 <oerjan> and also unusable :D
17:39:36 * ddarius knows nothing about JHC and some of the other new implementations.
17:39:40 <shachaf> nominolo: ap is S, in this case.
17:39:41 <atp> it would be nice if ghc had some dynamic command line options to preload particular files into the name space
17:40:08 <atp> but no biggy, for now i'll just make my files and module names the same
17:40:18 <atp> thanks for the info
17:40:23 <nominolo> :t ap (++) reverse $ ['a'..'d']
17:40:25 <lambdabot> [Char]
17:40:27 <kpreid> atp: try "ghci whatever.hs"
17:40:33 <nominolo> :t ap (++) reverse
17:40:35 <lambdabot> forall a. [a] -> [a]
17:40:35 <kpreid> atp: you'll be in ghci with that file loaded
17:40:39 <oerjan> well, you can load at least one file that way, can't you?
17:40:45 <shachaf> nominolo: s x y z = x z (y z)
17:40:51 <atp> kpreid: oh, i know.  actually, you can type ghci, and then use :l to load files
17:40:58 <atp> kpreid: once they're loaded, it will find them
17:41:07 <atp> but that's kind of cumbersome
17:41:10 <nominolo> shachaf, i never really got SK(I)
17:41:35 <shachaf> nominolo: not_s x y z = x z (y z) -- Better? :-)
17:41:38 <nominolo> shachaf, pointless/-froo style on steroids
17:41:53 <nominolo> s/froo/free
17:42:17 * shachaf was already wondering what froo style was...
17:42:47 <atp> well, it has nothing to do with froo software, anyway.
17:42:55 <nominolo> didn't haskell curry do some stuff related to combinatoric logics or sth?
17:43:01 <ddarius> nominolo: Yes.
17:43:07 <ddarius> That was his thing.
17:43:24 <oerjan> shachaf: it's named after how your brain sizzles after programming unlambda
17:43:37 <nominolo> i was born on his death day - but i don't want to continue his legacy ...
17:43:42 <nominolo> not really my thing ..
17:44:40 <ddarius> nominolo: It was a reductionist programme.
17:44:41 <shachaf> nominolo: ap (++) reverse xs = xs ++ reverse xs, anyway.
17:46:12 <ddarius> > let powerset [] = return []; powerset (x:xs) = ap (++) (map (x:)) xs in powerset "abc"
17:46:13 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
17:46:13 <lambdabot>       Expected...
17:46:30 <nominolo> so, ap (++) reverse == (++) . uncurry . second reverse . curry
17:46:36 <ddarius> > let powerset [] = return []; powerset (x:xs) = ap (++) (map (x:) . powerset) xs in powerset "abc"
17:46:36 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:46:36 <lambdabot>       Expected...
17:46:42 <ddarius> Whatever.
17:47:07 <nominolo> :t (++) . uncurry . second reverse . curry
17:47:09 <lambdabot>     Couldn't match expected type `(d, [a])'
17:47:09 <lambdabot>            against inferred type `a1 -> b -> c'
17:47:16 <nominolo> :t (++) . curry . second reverse . uncurry
17:47:18 <lambdabot>     Couldn't match expected type `(d, [a])'
17:47:18 <lambdabot>            against inferred type `(a1, b) -> c'
17:47:35 <nominolo> :t uncurry (++) . second reverse . curry
17:47:37 <lambdabot>     Couldn't match expected type `(d, [a])'
17:47:37 <lambdabot>            against inferred type `a1 -> b -> c'
17:47:43 <nominolo> whatever
17:47:56 <mauke> > filterM (return $do x <- [minBound .. maxBound]; return x) "abc"
17:48:01 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
17:48:07 <balodja> @src null
17:48:07 <lambdabot> null []     = True
17:48:07 <lambdabot> null (_:_)  = False
17:48:14 <balodja> What's that?
17:48:21 <mauke> a function
17:48:53 <oerjan> > null [1,2,3]
17:48:54 <motus> > filterM (const [True, False]) [1..3]
17:48:54 <lambdabot>  False
17:48:55 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
17:48:56 <balodja> Seems to be so
17:49:09 <atp> mauke: that's a great example of where >>= would be rather more readable
17:49:19 <mauke> atp: wtf
17:49:19 <fax> > iterate (\(x:y)->y++[x]) "abc"
17:49:20 <lambdabot>  ["abc","bca","cab","abc","bca","cab","abc","bca","cab","abc","bca","cab","ab...
17:49:34 <atp> mauke: ?
17:49:45 <atp> mauke: it was just a suggestion, no need to be rude :(
17:49:53 <mauke> atp: motus already gave the non-obfuscated version
17:49:58 <mauke> how would >>= make it more readable?
17:50:25 <atp> mauke: [minBound .. maxBound] >>= return ?
17:50:28 <fax> > concat $ iterate (\(x:y)->y++[x]) "abc"
17:50:30 <lambdabot>  "abcbcacababcbcacababcbcacababcbcacababcbcacababcbcacababcbcacababcbcacababc...
17:50:41 <mauke> atp: (>>= return) is the identity
17:50:51 <mauke> I think that destroys the joke
17:50:57 <motus> can someone help me with FFI? I have a C function that takes a C callback, and I need to map it into haskell. Anyone has any examples?
17:51:00 <atp> atp: oh, i see, i didn't even think about it :p
17:51:12 <atp> mauke: sorry, i didn't even think about it :p
17:51:29 <atp> mauke: i must have missed some earlier bit of the conversation, my bad
17:51:51 <motus> here's the actual function: int ydbm_traverse (ydbm_t* y, YdbmTraverseFunc callback, void* userArg, int flags); and it takes typedef void (*YdbmTraverseFunc) (const YdbmTraverseInfo* info, void* userArg, int* halt);
17:52:00 <mauke> holy crap
17:52:36 <atp> motus: what are ydbm_t and YdbmTraverseFunc ?
17:52:44 <oerjan> motus: i vaguely recall that C callbacks are done with wrapper. (alas that is about all i know about the ffi)
17:52:56 <oerjan> *callbacks to haskell
17:52:59 <atp> motus: nevermind, i know nothing about FFI, best not tell me :p
17:53:03 <sorear> motus: foreign import safe ccall "ydbm_traverse" ydbm_traverse :: Ptr YdbmHandle -> FunPtr YdbmTraverseFunc -> Ptr () -> CInt -> IO Int
17:53:11 <mauke> ydbm_traverse :: Ptr Ydbm_t -> FunPtr (Ptr YdbmTraverseInfo -> Ptr a -> Ptr CInt -> IO ()) -> Ptr a -> CInt -> IO CInt
17:53:15 <motus> ydbm_t is just a ptr to some internal structure, like FILE*. I've got it covered
17:53:40 <mauke> hah, I win!
17:54:53 <chessguy> @src const
17:54:53 <lambdabot> const x _ = x
17:55:07 <fax> :t const
17:55:09 <lambdabot> forall a b. a -> b -> a
17:55:19 <fax> @hoogle a -> b -> b
17:55:20 <lambdabot> Prelude.const :: a -> b -> a
17:55:20 <lambdabot> Prelude.seq :: a -> b -> b
17:55:20 <lambdabot> Control.Parallel.par :: a -> b -> b
17:55:47 <fax> ((flip const) _) = id
17:55:50 <chessguy> @src filterM
17:55:52 <lambdabot> Source not found. I feel much better now.
17:56:04 <motus> sorear: Thank you! That's what I have so far, though, and I need a haskell foreign EXPORT function to be called from inside the ydbm_traverse
17:56:14 <chessguy> @type filterM
17:56:33 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:57:33 <mauke> filterM _ [] = return []; filterM f (x : xs) = do c <- f x; (if c then liftM (x :) else id) (filterM f xs)
17:58:47 <motus> sorear: i.e. I want to have a function that takes a regular user-provided haskell  function and returns an exported function I can feed into ydbm_traverse
17:59:11 <motus> sorear: ydbm_t is just a ptr to some internal structure, like FILE*. I've got it covered
17:59:21 <oerjan> motus: i think that's the wrapper thing
17:59:31 <chessguy> @type const [True, False]
17:59:33 <oerjan> foreign wrapper something
17:59:33 <lambdabot> forall b. b -> [Bool]
17:59:41 <ddarius> foreign import "dynamic" or foreign import "wrapper" (is that it? I forget) Read the FFI addendum.
18:00:16 <mauke> why is it "I forget" instead of "I forgot"?
18:00:35 <oerjan> mauke: it is? i forget.
18:00:39 <chessguy> (const [True, False]) 1
18:00:41 <chessguy> > (const [True, False]) 1
18:00:45 <fax> > repeat "I forget "
18:00:46 <lambdabot>  [True,False]
18:00:47 <lambdabot>  ["I forget ","I forget ","I forget ","I forget ","I forget ","I forget ","I ...
18:01:03 <Armor_Azrael> > repeat "I don't recall"
18:01:04 <lambdabot>  ["I don't recall","I don't recall","I don't recall","I don't recall","I don'...
18:01:21 <fax> > concat $ iterate reverse "I forgot "
18:01:23 <lambdabot>  "I forgot  togrof II forgot  togrof II forgot  togrof II forgot  togrof II f...
18:01:30 <motus> oerjan: can you recall any code examples? any OS project that does such thing?
18:02:19 <oerjan> don't ask me, i said that was all i know didn't i? :D
18:02:24 <ddarius> mauke: I was still forgetting.
18:02:53 <mauke> foreign import ccall "wrapper" mkCallback :: YourTypeHere -> IO (FunPtr YourTypeHere)
18:03:01 <oerjan> @where ffi
18:03:02 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
18:03:02 <ddarius> It's likely mildly non-standard but pretty common.
18:03:20 <mauke> ddarius: to me, "forget" is a singular event, like "delete"
18:03:33 <mauke> it's not a state or long process
18:03:48 <mauke> (at least that's how it works in German)
18:03:55 <acura> Why should one want to defice factorial like this: fac :: Integer -> Integer
18:03:57 <acura> fac 0     = 1
18:03:59 <acura> fac (n+1) = product [1..(n+1)]
18:04:10 <ddarius> mauke: To many there is a subtle distinction (though not always) between "I forgot" and "I forget", but yes, you're probably right.  As I said, it's likely non-standard.
18:04:15 <mauke> acura: to confuse people
18:04:25 <oerjan> @src product
18:04:26 <lambdabot> product = foldl (*) 1
18:04:37 <mauke> ddarius: hah. I see it all the time on IRC
18:04:50 <acura> I was thinking about the (n+1)
18:05:00 <acura> mauke: Okay =D
18:05:12 <ddarius> mauke: "I forget" implies that you still don't remember, whereas "I forgot" often implies that you remember now.
18:05:16 <mauke> fac n = product [1 .. n]  -- end of story
18:05:19 <oerjan> acura: it seems like mixing two ways of defining it, in a nonsensical way
18:05:35 <fax> fac n = foldl (*) 1 $ reverse [1 .. n]
18:05:37 <fax> :P
18:05:39 * ddarius breaks out the Gamma function!
18:05:46 <fax> :t gamma
18:05:48 <lambdabot> Not in scope: `gamma'
18:05:58 <chessguy> > concatMap (const [True, False]) $ \c -> (if' c (liftM (x:)) id) (filterM f xs)
18:05:58 <lambdabot>   Not in scope: `xs'
18:05:58 <oerjan> ddarius: not Integral :D
18:06:54 <chessguy> > concatMap [True, False] $ \c -> (if' c (liftM (x:)) id) (filterM f xs)
18:06:55 <lambdabot>   Not in scope: `xs'
18:06:59 <fax> > ((+) 1 3)
18:07:01 <lambdabot>  4
18:07:05 <chessguy> > concatMap [True, False] $ \c -> (if' c (liftM (x:)) id) (filterM f [2,3])
18:07:05 <lambdabot>   Not in scope: `x'
18:07:11 <motus> mauke: yeah, wrapper is what I need, thanks
18:07:15 <chessguy> > concatMap [True, False] $ \c -> (if' c (liftM (1:)) id) (filterM f [2,3])
18:07:16 <lambdabot>   Not in scope: `if''
18:07:24 <atp> hehe
18:07:27 <fax> > (tail ((:) 1 ((:) 2 [])))
18:07:28 <lambdabot>  [2]
18:07:44 <chessguy> > concatMap [True, False] $ \c -> (if c then (liftM (1:)) else id) (filterM f [2,3])
18:07:45 <acura> @pl (\n -> product [1..n])
18:07:45 <lambdabot> product . enumFromTo 1
18:07:45 <lambdabot>  Couldn't match expected type `a -> [b]'
18:07:48 <atp> fax: haskell-lisp
18:07:49 <mauke> (cdr (cons 1 (cons 2 '())))
18:07:58 <fax> lispskill
18:08:10 <chessguy> atp, it's called liskell, and it's been done
18:08:17 <chessguy> @where liskell
18:08:17 <lambdabot> http://clemens.endorphin.org/liskell
18:08:21 <fax> > (map + ((:) 1 ((:) 2 [])))
18:08:22 <lambdabot>  Couldn't match expected type `(a -> b) -> [a] -> [b]'
18:08:25 <fax> Boo
18:08:33 <mauke> (cdr (1 `cons` 2 `cons` '()))
18:08:33 <oerjan> fax: need (+)
18:08:38 <fax> ah yeah
18:09:40 <atp> it's kind of neat how quickly prime factorization algorithms hit a complexity wall
18:10:21 <atp> it goes from instant response to lengthy computation with one order of magnitude
18:11:11 <dolio> That could depend on what extactly you're factoring.
18:11:35 <fax> powers of two
18:13:06 <atp> dolio: i'm talking about generic algorithms here, not specific to particular classes of numbers.
18:13:35 <fax> Do you think it's possible to write a generic algorithm which builds a parser out of some source code files? :/
18:14:14 <dolio> Ah.
18:15:21 <ddarius> fax: There are things that attempt less ambitious goals along that line.
18:16:01 <atp> doesn't happy do the equivalent of lex and yacc for haskell?
18:16:02 <atp> (i've never used it)
18:17:25 <ddarius> http://www.cs.vu.nl/grammars/ge/
18:17:27 <lambdabot> Title: Semi-automatic Grammar Recovery
18:17:37 <ddarius> atp: Alex and Happy
18:17:51 <ddarius> Though there are many variants and other approaches.
18:18:05 <fax> ooh
18:18:25 <mauke> yes! grammar inference!
18:21:18 <ddarius> fax: There are no doubt references to other approaches in the bibliography of that.
18:22:08 <BMeph> @pl (\x flist -> map ($ x) flist)
18:22:08 <lambdabot> map . flip id
18:22:57 <mauke> <3 flip id
18:24:12 <BMeph> Hm, that does NOT do what I want. >:p
18:24:42 <mightybyte> his
18:24:48 <BMeph> Has anyone heard of a function that works like map in converse?
18:24:54 <mightybyte> Oops, mistype
18:25:11 <fax> what?
18:25:13 <oerjan> what's it supposed to do?
18:25:19 <fax> :t map
18:25:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:25:21 <mauke> > sequence [(+1), (*2), sqrt] 2
18:25:23 <lambdabot>  [3.0,4.0,1.4142135623730951]
18:25:34 <fax> @hoogle [b] -> [a] -> (a -> b)
18:25:34 <lambdabot> No matches, try a more general search
18:25:40 <atp> that's pretty cool... flip id i mean
18:26:23 <oerjan> BMeph: can you give an example use?
18:27:02 <BMeph> oerjan: I think mauke got it, but thanks. mauke: THAT looks like what I'm aiming for, thanks.
18:27:35 <oerjan> > (map . flip id) 2 [(+1), (*2), sqrt]
18:27:38 <lambdabot>  [3.0,4.0,1.4142135623730951]
18:28:18 <BMeph> Of course, if only works because List is an instance of Monad, but a cheap  trick that works... ;)
18:28:19 <ddarius> atp: flip id == flip ($) == \x -> ($ x)  indeed \x -> (? x) == flip (?) for any operator ?
18:28:21 <atp> that's so cool.  sequence = flip (map . flip id) ?
18:28:27 <oerjan> although sequence is certainly simpler.
18:28:28 <ddarius> atp: No.
18:28:29 <ddarius> :t sequence
18:28:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:28:39 <atp> ah, yes, i suppose not.
18:28:43 <oerjan> BMeph: actually the monad is (->) e
18:29:35 <atp> ddarius: sequence operates on a generic monad, whereas map . flip id only works on lists, right?
18:29:45 <BMeph> oerjan: Mmm, yes, you're right.
18:29:47 <mauke> s/lists/functions/
18:30:00 <ddarius> atp: As others have said, the monad isn't lists.  Sequence operates on lists too.
18:30:10 <oerjan> > [(+1), (*2), sqrt] *> 2
18:30:11 <lambdabot>   add an instance declaration for (Num [b])
18:30:32 <atp> ddarius: ah, i see.
18:30:57 <atp> ddarius: thanks for the explanation :)
18:31:13 <BMeph> (map . flip id.flip) [(+1), (*2), sqrt] 2
18:31:17 <mauke> *Main> [(+1), (*2), sqrt] *> 2
18:31:18 <mauke> [2,2,2]
18:31:35 <BMeph> (map . flip id . flip) [(+1), (*2), sqrt] 2
18:32:02 <BMeph> (map . flip id . flip id) [(+1), (*2), sqrt] 2
18:32:11 <oerjan> > [(+1), (*2), sqrt] <*> pure 2
18:32:12 <lambdabot> Terminated
18:32:18 <atp> BMeph: (flip $ map . flip id) maybe?
18:32:27 <oerjan> ?
18:32:49 <oerjan> > [(+1), (*2), sqrt] `ap` return 2
18:32:51 <lambdabot>  [3.0,4.0,1.4142135623730951]
18:33:02 <oerjan> _that_ uses the list monad
18:33:28 <fax> > sqrt -1
18:33:29 <lambdabot>   add an instance declaration for (Num (a -> a))
18:33:29 <lambdabot>     In the expression: sqrt ...
18:33:30 <BMeph> :)
18:33:40 <fax> > sqrt (0-1)
18:33:41 <lambdabot>  NaN
18:33:45 <fax> hmpf
18:33:50 <mauke> > sqrt (-1) :: Complex Double
18:33:52 <lambdabot>  -0.0 :+ 1.0
18:33:56 <atp> :t ap
18:33:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:34:10 <fax> > iterate sqrt ((-1) :: Complex Double)
18:34:12 <lambdabot>  [(-1.0) :+ -0.0,-0.0 :+ 1.0,0.7071067811865476 :+ 0.7071067811865475,0.92387...
18:35:18 <atp> does anyone know if there's a generic "sieve of erastosthenes" for UFDs other than Z?
18:35:29 <atp> like, in particular, i'd like to compute eisenstein primes
18:35:46 <atp> the lack of ordering seems to make most sieve functions unworkable ...
18:36:52 <oerjan> atp: order by modulus?
18:38:11 <atp> oerjan: hm, i'll have to think about it
18:44:48 <sjanssen> @remember ChilliX PS: And, no, you won't be able to set breakpoints in type-level programs...
18:44:49 <lambdabot> Done.
18:45:12 <mauke> what!
18:45:19 <oerjan> hah, it's only a matter of time :)
18:45:33 <mauke> then how am I supposed to debug my type declarations?!
18:45:35 <sjanssen> I demand a type-level debugger for GHC 7! ;)
18:45:52 <ddarius> @google "type debugger"
18:45:54 <lambdabot> http://www.comp.nus.edu.sg/~sulzmann/chameleon/
18:45:54 <lambdabot> Title: Chameleon
18:46:36 <sjanssen> it would be really fun to watch GHC typecheck a program
18:46:56 <mauke> in 3D!
18:47:01 <sjanssen> naturally
18:47:16 <mauke> opengl logging backend now
18:48:13 <mauke> hmm, with special effects for "My brain just exploded"
18:52:35 <FMotAFK> :/
18:52:40 <FMotAFK> I dislike reddit vandals.
18:52:51 <ddarius> I dislike vandals.
18:52:56 <fax> I like vandals
18:53:03 <FMotAFK> fax: how dare you :o
18:53:15 <lambdabot> I am a vandal.
18:53:22 <FMota> :)
18:53:37 <FMota> Are you a reddit vandal, lambdabot?
18:53:41 <BMeph> I think lambdabot is actually a Goth. ;)
18:53:42 <sjanssen> @vixen are you a vandal?
18:53:42 <lambdabot> i truely am
18:53:46 <fax> hehe
18:53:56 <FMota> Oh dear, I don't like you then.
18:53:57 <sjanssen> @vixen are you a reddit vandal?
18:53:57 <lambdabot> i truely am
18:54:27 <fax> > concat $ repeat "I am sorry, I will not do it again, "
18:54:28 <KatieHuber> apparently not only is she a vandal, but she can't spell... suppose that goes with the territory
18:54:29 <lambdabot>  "I am sorry, I will not do it again, I am sorry, I will not do it again, I a...
18:54:55 <FMota> yep.
18:55:27 <dolio> @vixen a/s/l
18:55:28 <lambdabot> 19/f/California
18:55:48 <pgavin> lol
18:55:51 <Pseudonym> ?vixen You liar, you're not in California.
18:55:51 <lambdabot> cool
18:56:07 <dolio> California sounds cooler than Oregon.
18:56:10 <ddarius> Pseudonym: Sometimes she is, but she's definitely not yet 19.
18:56:19 <Pseudonym> Maybe in dog years.
18:56:30 <ddarius> She's older than 19 in dog years.
18:56:46 <lambdabot> I'm even older in Internet years.
18:56:47 <pgavin> be careful, lambdabot might really be that guy on the TV
18:56:53 <fax> hehe
18:57:11 <pgavin> don't go to lambdabot's house
18:57:21 <Pseudonym> I'm sure that's a clever and insightful reference to something or other on your local TV.
18:57:36 <pgavin> actually, not really clever or insightful
18:57:44 <pgavin> not local TV, either
18:57:49 <pgavin> actually, USian TV
18:58:01 <oerjan> that's pretty local :D
18:58:04 <Pseudonym> That's what I mean by "local".
18:58:06 <pgavin> ok
18:58:17 <Pseudonym> If it's not shown outside one continent, it's local.
18:58:19 <pgavin> well, it's not really worth going into :)
18:58:32 <pgavin> you might've heard of it actually
18:58:38 <Pseudonym> Doubtful.
18:58:48 <pgavin> ok, well, whatever :)
19:00:02 <dolio> If you go to lambdabot's house, dons might capture you and force you to write several libraries and post them to hackage before he lets you go.
19:00:18 <pgavin> that wouldn't be too bad
19:00:25 <pgavin> where's lambdabot live?
19:00:33 <ddarius> @where lambdabot
19:00:33 <Pseudonym> If he pays for your food while you're there, sounds like a good deal.
19:00:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:00:38 <pgavin> lol
19:00:39 <ddarius> @time lambdabot
19:00:39 <sorear> dolio: she's still in AU
19:00:39 <lambdabot> I live on the internet, do you expect me to have a local time?
19:00:44 <drtomc> How do I get there? A trip to Portland sounds nice.
19:00:50 <dolio> Ah. I guess it's safe, then. :)
19:00:53 <sorear> dolio: don doesn't live tere anymore...
19:01:25 <dolio> Yeah. I wasn't sure if dons took her with him or not.
19:01:25 <Pseudonym> drtomc: Can you walk on water, or was that the other guy?
19:01:47 <dolio> I guess leaving her on university servers is a better idea.
19:01:59 <pgavin> Pseudonym: that was peter sellers
19:02:15 <drtomc> Well, I can float. Does that count?
19:02:25 <drtomc> But I can't double. ;-)
19:02:35 <Pseudonym> Well, it's a long swim across the Pacific.
19:02:43 <pgavin> I hope that wasn't too local, peter sellers is pretty well known, right? :)
19:02:49 <Pseudonym> Yes.
19:02:52 <Pseudonym> Being British.
19:02:58 <pgavin> exactly
19:03:04 <pgavin> but it was an american movie
19:03:21 <pgavin> well, that he walked on water in, anyhow
19:28:18 <dino-> top
19:30:46 <mrd> _|_
19:31:03 <sorear> â¥ â¤
19:37:00 <dons> ?remember ChilliX This is GHC after all, it tries to gently nudge you in the right direction, but if you insist, it happily let's you drill arbitrarily large holes in your foot.
19:37:00 <lambdabot> Done.
19:40:24 <dons> so how are we going to talk over the world today guys?
19:40:25 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:40:58 <reffie> talk over teh worrld?
19:41:12 <fax> same way we do everyday, dons? :)
19:41:12 * ddarius uses GSM.
19:41:19 <dons> fax, ah yes. that's right!
19:41:21 <dons> ?brain
19:41:22 <lambdabot> They've turned into giant Swiss leaderhosen-clad dancing yodelers. Talk about unpredictable!
19:41:55 <ddarius> That's not unpredictable at all.
19:42:09 <dolio> @b52s
19:42:09 <lambdabot> Some say she's from Mars, or one of the seven stars that shine after 3:30 in the morning. WELL SHE ISN'T.
19:42:18 <LoganCapaldo> or is she?
19:42:30 <dons> she isn't, no.
19:42:52 <dons> @b52s
19:42:52 <lambdabot> You belong in Ripley's Believe It Or Not
19:43:07 <dons> @proto
19:43:08 <lambdabot> how can haskell automate ftp?
19:43:44 <dolio> Automatic ftp is a killer feature.
19:43:48 <dons> yeah, totally
19:44:14 <dons> we've not seen gschuett, the above troll, for months and months now
19:44:59 <dolio> I remember him coming in a while back. Someone picked him out pretty fast.
19:45:55 <dons> yeah, he's pretty easy to spot, then its just fun
19:46:15 <ddarius> I remember that.  It was weird.
19:46:55 * ddarius is not used to seeing dons vicious.
19:47:13 <dons> i enjoy kicking trolls, that's true
19:47:26 <reffie> trolls don't die unless you use fire or acid
19:47:28 <mauke> forced part is funner
19:47:38 <dons> i've heard silver bullets also work, reffie
19:47:45 <ddarius> dons: You didn't kick him for a while.
19:48:01 <dolio> Not in D&D.
19:48:03 * ddarius 's experience is that bullets work.  Bullets always work.
19:48:14 <dons> ddarius: oh, you've got the logs handy?
19:48:47 <ddarius> dons: No.
19:49:25 <ddarius> I could probably find it pretty fast by grepping for "kick"
19:57:09 <LoganCapaldo> I read somewhere or heard it in a movie that bullets actually made of silver would make for lousy bullets
19:57:48 <dolio> They might be a bit soft.
19:58:18 <monochrom> Indeed, that's why in Underworld they invented a bullet with some other casing and put silver nitrate inside.
19:58:55 <ddarius> monochrom: It wouldn't really matter if they're soft for that purpose.
19:58:57 <monochrom> or maybe a silver-mercury mixture, to keep it in liquid form.
19:59:18 <monochrom> Yes, supposedly the casing is good
20:00:41 <monochrom> No wonder software people want silver bullets. They're soft.
20:02:10 <dino-> mrd: hehe _|_
20:03:16 <kpreid> LoganCapaldo: I read a story where someone disputed that .. roughly 'after all, lead is even softer'
20:03:23 <Modius> Winchester Silvertips would probably have sufficed :)  And technically the lead is soft, the silver hard
20:04:17 <LoganCapaldo> kpreid, I don't recall if softness was actually the reason
20:04:20 <ddarius> It's convenient to be able to shoot through walls...
20:04:45 <LoganCapaldo> dolio brought up the soft thing :)
20:04:48 <ddarius> LoganCapaldo: I'd assume it wasn't as it's kind of a ridiculous reason.  If I shoot you with a silver bullet you still die.
20:04:50 <LoganCapaldo> I blame him
20:04:54 <dolio> It was a shot in the dark.
20:05:14 <dolio> I did think of lead being soft afterwards.
20:06:10 <dolio> Lead is more dense. Although not that much.
20:07:32 <LoganCapaldo> looks like silver is perfectly cromulent bullet material http://en.wikipedia.org/wiki/Silver_bullet#Actual_silver_bullets
20:07:48 <LoganCapaldo> if you can believe wikipedia anyway
20:08:06 <fax> Is it the only way you can have user defined operators when parsing with parsec is to pass a list of them as a parameter to the function which makes the parser
20:08:08 <dolio> They seemed fine in Constantine.
20:08:11 <dolio> :)
20:08:14 <fax> seems like what I should do..
20:08:28 <ddarius> Silver has anti-septic qualities.  You want your enemies to get gangrene if they don't die from the bullet shot.  (Actually, no you don't, at least for a particular class of values of 'you')
20:08:48 <Modius> Revolver/shotgun can shoot anything.  Unless the density (and consequently, ballistics/recoil) are made near identical this would make unmodified autoloading weapons unreliable
20:09:24 <LoganCapaldo> ddarius, you're mean
20:09:31 <LoganCapaldo> :(
20:10:03 <sorear> I recommend nuclear hand grenades
20:10:16 <LoganCapaldo> seems counterproductive those
20:11:02 <ddarius> LoganCapaldo: I fall into that class of values of 'you' that is not supposed to (in some sense).
20:11:27 <Pseudonym> Guys, #haskell-blah please.
20:12:07 <Pseudonym> As interesting as metallurgy is, unless you're simulating metal properties in Haskell...
20:12:17 <ddarius> Hey... !
20:12:26 <ddarius> That'd be pretty cool actually.
20:12:30 <Pseudonym> It would.
20:12:44 <Pseudonym> I did a really hacky Ising model simulator once.
20:12:50 <LoganCapaldo> type safe smelting?
20:16:03 <monochrom> fax: using Parsec's buildExpressionParser? You can have user-defined operators, i.e., not known when you write the parser. Just decide what are valid characters that make up an operator and tell buildExpressionParser. In the TokenParser record, the field "operator" is a parser that fetches and returns a user-defined operator.
20:17:48 <fax> ahh cool
20:17:53 <fax> thanks, that beats what I had in mind
20:31:10 <ddarius> @let limit :: (Integer -> (Integer -> Integer)) -> (Integer -> Integer); limit = join
20:31:15 <lambdabot> Defined.
20:32:10 <ddarius> > map (limit const) [1..10]
20:32:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:32:54 <ddarius> > map (limit (+)) [1..10]
20:32:55 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
20:34:51 <fax> > map (limit (+)) [1..10] ++ [10..1]
20:34:53 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
20:35:22 <fax> what...
20:35:30 <oerjan> > [10..1]
20:35:32 <lambdabot>  []
20:35:35 <fax> augh!
20:35:43 <oerjan> > [10,9..1]
20:35:45 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
20:35:47 <fax> > map (limit (+)) [1..10] ++ [10,9..1]
20:35:49 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,10,9,8,7,6,5,4,3,2,1]
20:36:02 <fax> > map (limit (+)) $ [1..10] ++ [10,9..1]
20:36:04 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,20,18,16,14,12,10,8,6,4,2]
20:36:34 <fax> I don't get limit
20:36:42 <mauke> > join (+) 5
20:36:44 <lambdabot>  10
20:36:44 <mauke> > join (*) 5
20:36:46 <lambdabot>  25
20:36:50 <mauke> > join (^) 5
20:36:51 <lambdabot>  3125
20:37:21 <fax> :t join
20:37:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:38:35 <mauke> :t join . asTypeOf
20:38:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
20:38:37 <lambdabot>     Probable cause: `asTypeOf' is applied to too many arguments
20:38:42 <mauke> oh, right
20:39:41 * ddarius wants instance Num b => Num (a -> b) again.
20:39:47 <oerjan> :t join . ($)
20:39:50 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
20:42:32 <mauke> . ($) looks useless
20:43:11 <ddarius> f . id = f
20:43:27 <oerjan> except that it forces the (->) monad
20:44:11 <mauke> ddarius: take http://mauke.ath.cx/stuff/haskell/fun.hs and paste it in your Prelude :-)
21:00:15 * ChilliX -> lecture
21:01:32 <sioraiocht> I really need to get on with school again
21:01:39 <sioraiocht> I just submitted an image to icanhascheezburger
21:08:29 <Weremanatee> Is it possible to use let in case analysis?
21:09:39 <sorear> > case let x = 24 in x == x of True -> "x"; False -> "y"
21:09:41 <lambdabot>  "x"
21:09:43 <sorear> yes.
21:09:55 <Weremanatee> how about in a pattern match?
21:10:45 <mauke> example please
21:11:13 <hpaste>  Apocalisp pasted "contrived example" at http://hpaste.org/2739
21:11:32 <Weremanatee> can I say let x = abs x in ...
21:11:36 <Weremanatee> :-)
21:17:01 <hpaste>  Apocalisp annotated "contrived example" with "(no title)" at http://hpaste.org/2739#a1
21:22:49 <KatieHuber> what kind of language has whole academic *papers* on how to write depth-first search >:(
21:23:03 <fax> Prolog
21:23:15 <KatieHuber> prolog just does it for you...
21:23:36 <sorear> haskell has long papers on breadth first search
21:25:20 <Spark> prolog has thousands of papers on whether or not the "not" operator is a good idea
21:25:37 <sorear> how many on cut?
21:25:51 <johnnowak> it's not not a good idea
21:25:53 <dolio> Too many.
21:25:59 * fax is writing a Prolog in haskell :)
21:26:30 <Spark> i had to wrote a prolog in java once
21:26:41 * sorear wrote Prolog in Haskell, but with a completely different syntax and no standard library
21:26:55 <Spark> mine was more like datalog actually
21:29:56 <fax> The most irritating thing is Infix operators
21:35:41 <Weremanatee> is there anything that parses haskell and prints out haskell formatted according to definable style rules?
21:35:57 <fax> hm well
21:36:06 <fax> I found some C code which parses haskell based on the ISO std
21:36:18 <fax> you could probably make it output some other format with a little effort
21:36:56 <fax> http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/code/parsing/lp/0.html
21:36:56 <heanol> -> http://uptr.pl/lV
21:36:58 <lambdabot> Title: Package: lang/prolog/code/parsing/lp/
21:36:58 <lambdabot> Title: Package: lang/prolog/code/parsing/lp/, http://tinyurl.com/27nhtg
21:37:00 <ddarius> ISO standard?
21:37:09 <sjanssen> Weremanatee: there's a pretty printer in Language.Haskell
21:37:24 <fax> blah
21:37:31 <fax> I read "is there anything that parses Prolog"
21:37:37 <sjanssen> Weremanatee: GHC also has a pretty printer, but I don't know if you can run it on an arbitrary piece of code
21:37:37 <fax> sorry
21:41:33 <sorear> GHC has a pretty printer, but it outputs broken haskell
21:41:48 <sorear> class Foo a | where  -- fundep manglage
21:41:56 <sorear> foo = + 1 2 -- infix operator manglage
21:42:36 <sorear> both fixed in the template-haskell copy; kids, this is why you should never use cp -r on source code :)
21:44:05 <sjanssen> sorear: is this pretty printer somehow different from the printer used in error messages?
21:44:49 <sorear> sjanssen: I don't know
21:45:11 <sjanssen> sorear: how do you use the GHC pretty printer?
21:45:53 <sorear> -ddump-parsed
21:47:04 <Weremanatee> @pretty f x = case let x = 24 in x == x of True -> "x"; False -> "y"
21:47:04 <lambdabot>  f x  = case let x = 24 in x == x of
21:47:05 <lambdabot>             True -> "x"
21:47:05 <lambdabot>             False -> "y"
21:47:10 <Weremanatee> ooh!
21:47:38 <sjanssen> sorear: I don't see those problems with -ddump-parsed on 6.6.1
21:50:01 <Weremanatee> what do you do with a drunken sailor who nests wheres and lets several levels down?
21:50:48 <mauke> (take &&& shake) him
21:51:50 <Weremanatee> @arr
21:51:50 <lambdabot> I want me grog!
21:52:45 * sorear is not drunken and not a sailor
22:33:13 <scodil> are there any kind of tricks to avoid infinite types for side-effecting finite state machines? As in, a set of IO actions of the type T = Token -> IO T, that return the action to be taken to consume the next token? In C this would be something like updating a function pointer while in the pointed-to function. Can it be done without IORefs?
22:34:16 <mauke> newtype T = T (Token -> IO T)
22:35:44 <scodil> and it doesn't complain about it being cyclic?
22:36:14 <mauke> no
22:36:23 <mauke> as long as you use newtype or data, it's ok
22:37:33 <fax> do you know any particularly good examples of a AST?
22:38:05 <scodil> great. incidentally, how do I try stuff like this out quickly in ghci? I can't fingure out how to do data or newtype declarations interactively
22:38:21 <fax> scodil: You can put them in a file and :load it though
22:39:25 <scodil> but there's no way to just quicky put "data X = X Int" into it?
22:41:15 <fax> Is it usual to just do this data Exp = App Exp Exp | K | ... kind of thing for any AST?
22:41:19 <fax> as in http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/Unlambda.hs
22:41:21 <lambdabot> http://tinyurl.com/yofvpu
22:42:14 <P_D> as opposed to?
22:42:29 <fax> well I'm not sure
22:43:35 <P_D> I know very little about haskell, but I've used that no frills data declaration for two ASTs
22:43:58 <fax> alright, I'll just go with it
22:58:59 <dibblego> in the dynamic programming solution for the coin problem, what do you do if 1 is not a coin denomination?
22:59:24 <sjanssen> fail to make change for certain denominations
23:00:12 <dibblego> as you progress up the stored values, it seems that, if you have just computed a value and the next is not defined, then you should jump your minimum denomination
23:02:24 <sjanssen> I wonder if the usual algorithm is still correct without a 1 coin
23:02:52 <dibblego> well, in my reading, it seems to inadvertently make 1 a base case
23:03:01 <dibblego> although it states 0 as the base case
23:04:25 <sjanssen> 1 isn't really the problem
23:04:58 <dibblego> but do you not just increment by one as you go?
23:04:59 <sjanssen> the problem is that there are amounts that you can't make with the coins you've got
23:05:19 <dibblego> it seems silly to be able to compute say n, with a smallest denomination of 2, then try to compute n + 1
23:06:18 <sjanssen> actually, the usual algorithm isn't dynamic, it's greedy
23:06:31 * sjanssen was confused for a moment
23:06:34 <dibblego> the greedy one does not always work
23:06:44 <sjanssen> right, it needs super-increasing denominations
23:06:59 <dibblego> the greedy algorithm for say 1, 4, 5 to find 8 will result in 1, 1, 1, 5
23:07:50 <sjanssen> I think the DP algorithm works fine without a 1 coin, you just won't be able to make certain amounts
23:08:00 * bos met sigfpe tonight
23:08:16 <dibblego> I don't think you can make certain amounts, regardless of DP or greedy?
23:09:23 <sjanssen> dibblego: your algorithm is "change x = minimum [change (x - y) | y <- coins, y <= x]"?
23:09:40 <sjanssen> that counts the number of coins used
23:10:17 <dibblego> sjanssen, I have none yet; just reading
23:15:52 <fax> @hoogle String -> Int
23:15:53 <lambdabot> No matches, try a more general search
23:16:11 <fax> can you provide read with a radix?
23:16:47 <fax> like read (base 2) "101010" -> 42
23:18:09 <olsner> :t readInt
23:18:11 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
23:18:20 <olsner> in the Numeric module
23:18:56 <dibblego> after setting the base case to 0, it even seems silly to start at 1; you should start at the lowest denom
23:19:07 <fax> thanks a lot!
23:19:11 <olsner> > readInt 2 isDigit digitToInt "101010"
23:19:13 <lambdabot>  [(42,"")]
23:20:58 <sjanssen> dibblego: you might find it easier to start top-down rather than bottom-up
23:21:18 <dibblego> sjanssen, you mean, starting at n instead of 0?
23:21:22 <sjanssen> yes
23:22:14 <sjanssen> then it's just recursion+memoization
23:22:28 <dibblego> why isn't it that, starting at 0?
23:22:52 <dibblego> oh
23:23:02 <dibblego> I know what you mean
23:49:13 <fax> damn..
23:49:40 <fax> looks like I have to spend a lot of time reordering the parsec rules to make this work :/
23:52:37 <fax> "The preferred solution to this problem is to left-factor the grammar by merging common prefixes."
23:52:44 <fax> agh :S
23:52:57 <fax> 300 lines of parsec to fix
23:53:37 <RogerTaylor> Hello everyone! Has anyone looked at Unicode issues in HSQL / HaskellDB?
23:53:48 <ari> fax: Just be a lazy bottom and use try ;)
23:53:57 <fax> I'll try
23:54:05 <fax> oh... god.. I didn't mean that
23:54:12 <fax> I will give that shot, thanks :)
23:54:24 <ari> @type Text.ParserCombinators.Parsec.try
23:54:27 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
23:54:49 <RogerTaylor> ... and is it just me, or is the CGI library a bit over-specialised wrt character encodings?
23:59:02 <quicksilver> fax: shame we don't have an automatically left-factoring parser library :)
23:59:32 <fax> That would be really nice
