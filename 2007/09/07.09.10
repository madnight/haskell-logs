00:00:34 <allbery_b> so the only usefuul uses I can think of involve ContT IO, where you can't reliably get away with using laziness to shortcircuit stuff
00:00:48 <hpaste>  tomppa pasted "Trying to store typeclass in record" at http://hpaste.org/2666
00:01:09 <tomppa> what is wrong with this?
00:01:21 <allbery_b> not sure you can do that; types tend to need to be concrete at that level
00:01:33 <allbery_b> same way you can't make a list of a typeclass (barring HList)
00:01:35 <Tac-Tics> wouldn't it be possible to have a Transformed monad with a continuation state or something? Like how you can do in scheme where the current cont is "saved" to a variable?
00:02:05 <mdmkolbe> tuukkah: the stack that haskell code runs on is not in the %esp register, but it is continguous, downward-growing, made-of-frames adjacent to each other, and otherwise looks just like a regular C stack (ok, the frame layout is completely different)
00:02:40 <tomppa> hmm, so what if I need to store a bunch Nums, for example, in a record or list?
00:03:00 <glguy> data NumHolder = NumHolder { num :: forall a. Num a => a }
00:03:14 <tuukkah> was that called existential types?
00:03:30 <mdmkolbe> tuukkah: (the layout is [args, return addr, local saves] instead of the C style [return addr, args, local saves])
00:03:30 <glguy> there isn't much you can do with those, however
00:03:39 <Tac-Tics> Continuations are something that someone really should write an amazing and clear tutorial on, because they are just very weird
00:04:00 * allbery_b would like to see one since he's still shaky on them
00:04:12 <scook0_> for some typeclasses, you can make the existential wrapper an instance of the class itself (as I recently learned on -cafe)
00:04:35 <mdmkolbe> Tac-Tics, allbery_b: maybe after I finish my "Monads in Scheme" paper ;-)
00:05:06 <tuukkah> mdmkolbe, i think i should read the code to understand how to implement something like that wrt virtual memory
00:05:41 <allbery_b> like I said earlier I don't see a lot of use for Cont in  pure code (wouldn't a computation in theMaybe monad work better?)
00:05:44 <tomppa> I'm trying to implement a simple Asteroids like, I'm storing the gamestate in a record. Among other things that record would need to hold a list of Sprite typeclassed objects
00:05:47 <mdmkolbe> tuukkah: for some reason that isn't parsing in my mind
00:05:56 <tomppa> asteroids like game, that is
00:06:18 <int-e> tomppa: make a wrapper for a single number, data WrapNum where WrapNum :: Num a => a -> WrapNum. Then stuff that into a list.
00:06:31 <tomppa> great, I'll try that
00:07:00 <Tac-Tics> I swear, the "Meet the Monads" tutorial is the most confusing introduction to monads ever
00:07:01 <tuukkah> mdmkolbe, how to implement a downwards-growing continuous region in the presence of an OS and virtual memory
00:07:07 <int-e> tomppa: but it doesn't work in ghc up to 6.6.1
00:07:22 <mdmkolbe> tuukkah: maybe you refer to the need for "sbrk"
00:07:45 <allbery_b> er?  sbrk grows up
00:07:59 <tuukkah> exactly
00:08:09 <int-e> data NumHolder = forall a . Num a => NumHolder { num :: a }  works in 6.6.1
00:08:41 <allbery_b> int-e: but can you usefully extract from it?
00:09:08 <int-e> yes. you can define, for example, useNH (NumHolder x) = show x
00:09:32 <int-e> (Show is a superclass of Num - for historical reasons I guess)
00:10:30 <mdmkolbe> allbery_b: really?  well, in any case there *are* ways to ask the OS to map a particular page to a fresh memory frame.  How you do that may be OS specific and was beyond the scope of my changes (the "garbage collector" was in charge of getting more stack whenever it ran out)
00:11:15 <allbery_b> sbrk(N) grows the process's heap (data segment) by N
00:11:17 <scook0_> there's not much you can do with a single existential Num
00:11:54 <tuukkah> mdmkolbe, allbery_b, we could try to read the implementation in ghc :-)
00:11:56 <int-e> scook0_: oh you can, say, double it, square it, add integer constants to it ... and finally print it. it's not completely useless.
00:12:20 <allbery_b> stack growth is traditionally done by stack probes and a special page fault handler in the kernel that detects the probes walking backwards off the stack and allocating more space to it
00:12:29 <scook0_> true, I had a few of those in mind
00:12:43 <allbery_b> (C stack, that is)
00:13:01 <allbery_b> managing per-thread stacks is traditionally somewhat painful...
00:13:03 <mdmkolbe> allbery_b: haskell stack is done with explicit checks for stack overflow
00:13:48 <hpaste>  tuxplorer pasted "Trying to modify irc bot and got error 2668" at http://hpaste.org/2667
00:14:05 <mdmkolbe> allbery_b: my guess is that since the haskell stack is in the data segment, the GC would extend the data segement length, and then move the stack.  since the haskell stack is doubled each time it runs out (this I know for sure), the amoitized time works out favorably.
00:14:15 <tuxplorer> Error in http://hpaste.org/2668
00:15:04 <tuukkah> mdmkolbe, oh there's gc on that level involved. that explains a lot
00:15:18 <mdmkolbe> allbery_b: every function begins with "if (Sp - 4 < SpLim) { call gc(need more stack); }"
00:16:12 <tuxplorer> what should I give for t to be able to print it into the socket lh ?
00:16:31 <int-e> tuxplorer: if you put eval :: String -> Net ()  back, does the error move to a different position in the code?
00:17:23 <int-e> tuxplorer: it's generally a bad idea to remove type signatures to try to make code work
00:17:29 <mdmkolbe> tuukkah: well, gc == "any call back to the run-time-system that could include thread yields, stack check failures, heap check failures, and other things at which time the rts might switch thread, move the stack or collect or extend the heap depending on what it thinks need to be done".  so in that sence yes the GC is involved
00:18:07 <tuxplorer> int-e: it moves to line 67..
00:18:42 <int-e> tuxplorer: note also that hpaste truncates after 5k of text - so we don't see what you changed process to.
00:18:52 <int-e> (the last thing is the removed type signature of process)
00:19:31 * allbery_b was thinking the type of process wasn't what was expected, yeh
00:19:33 <tuukkah> mdmkolbe, esp. the "move the stack" part which wouldn't typically be possible
00:20:02 <allbery_b> if you know what the stack contains with reliability, you can repoint it
00:20:35 <tuxplorer> int-e: process s = classi_write s ""
00:20:37 <allbery_b> if every function needs only 4 stack cells this suggests it's relatively easy to repoint if needed
00:21:14 <mdmkolbe> tuukkah: you could put it in the signal handler (unless you're worried about time limits).
00:21:29 <tuxplorer> int-e: now it compiles.. let me check.. I had used the port number in the position of "" before.. Now when I changed it to a string, it compiled
00:21:45 <elliottt> tuxplorer: is process really commented out?
00:21:57 <elliottt> nevermind.  my irssi was scrolled up :)
00:22:13 <tuxplorer> *** Exception: connect: does not exist (Connection refused)
00:22:23 <mdmkolbe> allbery_b: the frame layouts are specified by a special table (the "info table") attached to teach return point so from the return address you can find the layout of the above frame.
00:22:24 <pejo> mdmkolbe, put a long running operation in the signal handler?
00:22:59 <tuukkah> that kind of voodoo =)
00:23:03 <tuxplorer> elliottt: only the type signature was commented out..  I uncommented it now..
00:23:04 <mdmkolbe> tuukkah: either way, I think we both agree and I'm too tired to arguee anyway
00:23:28 <tuukkah> mdmkolbe, sure. thanks for a peek to the ghc implementation!
00:23:54 <hpaste>  tuxplorer pasted "Modified code.. throws runtime error *** Exception: connect: does not exist (Connection refused) " at http://hpaste.org/2669
00:24:31 <elliottt> are you running a server on localhost that will accept connections on 12345?
00:24:54 <mdmkolbe> tuukkah: np.  the ghc model breaks quite a few things that are just assumed in the C model.
00:25:04 <tuxplorer> elliottt: oops!! sorry.. forgot to start one :D
00:25:07 <elliottt> :)
00:25:16 <tuukkah> int-e, how would i add a constant integer to a NumHolder?
00:25:50 <int-e> tuukkah: add1 (NumHolder x) = NumHolder (x+1)
00:25:58 <int-e> @type 1
00:26:00 <lambdabot> forall t. (Num t) => t
00:26:41 <int-e> tuukkah: (effectively using fromInteger from the Num class)
00:27:49 <allbery_b> tuxplorer: I suggest you want to add some better error handling to the connect calls, just to make it more obvious what's failing
00:28:10 <tomppa> "My brain just exploded. I can't handle pattern bindings for existentially-quantified constructors.", maybe I'll reconsider my approach...
00:28:11 <tuxplorer> allbery_b: Thanks. I'll do..
00:28:17 <tuukkah> int-e, right. i forgot to put the result back into NumHolder and tried to call show on it directly
00:28:21 <idnar> heehee
00:29:12 <int-e> tuukkah: that should work, too.
00:29:37 <tuukkah> it does
00:29:45 <tuukkah> so what stupid thing did i try then
00:30:07 * allbery_b is a bit paranoid about error handlin
00:31:02 <int-e> be sure to read http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification , especially the part about the restrictions.
00:31:04 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
00:31:12 <tuukkah> int-e, ok, i forgot the show. can't go from NumHolder to Num =)
00:36:52 <tuukkah> ghc doesn't know how to derive Show but it's trivial
00:37:02 <int-e> you can implement  applyNH :: (forall a . Num a => a -> b) -> NumHolder -> b  though. Then, add1 = applyNH (NumHolder . (+1))
00:37:50 <int-e> (the implementation of applyNH is trivial, applyNH f (NumHolder x) = f x)
00:37:53 <Tac-Tics> I still can't figure out what to use Cont for =-(
00:38:12 <Tac-Tics> but I think I "get" it a little more from the Haskell side
00:39:01 <tuukkah> int-e, applyNH has one weird type, have to think about this for a while
00:39:59 <scook0_> yes, it has a higher-rank (Rank 2) type
00:40:43 <tomppa> int-e: oh, that's how I should do it :)
00:45:09 <tuukkah> is applyNH of some practical use?
00:46:47 <int-e> hmm, the point is arguable. it doesn't do more than the pattern match on a Numholder does.
00:47:13 <int-e> but (forall a . Num a => a -> b) is a function type and functions can be composed. that's harder with pattern matches.
00:48:00 <int-e> oh and the function allows you, in principle, to make the NumHolder type abstract.
00:48:36 <tuukkah> for that, wouldn't you want to put the wrapping inside applyNH too?
00:50:22 <int-e> tuukkah: you can provide an applyNH' :: (forall a . Num a => a -> a) -> NumHolder -> NumHolder  too. or just provide a (trivial) makeNH function.
00:51:01 <int-e> tuukkah: the practical use is a bit limited, it's more of an alternative view on what's going on.
00:52:00 <int-e> it's also a matter of taste. I like rank 2 types.
00:52:56 <tuukkah> hmm, applyNH' :: (forall a b. (Num a, Num b) => a -> b) -> NumHolder -> NumHolder
00:53:30 <scook0_> I see an issue there...
00:53:53 <tuukkah> can i ever construct a function of the argument type ?-)
00:54:16 <scook0_> well, undefined ;)
00:54:28 <tuukkah> also (+1) etc. but non-trivial ?-)
00:54:29 <scook0_> but other than that, nope
00:54:34 <tuukkah> ok
00:54:41 <scook0_> no, not even (+1) will work
00:55:14 <scook0_> that would require the ability to convert from one unknown Num instance to another
00:55:16 <int-e> @type fromIntegral . sum . map ord . show
00:55:18 <lambdabot> forall b a. (Num b, Show a) => a -> b
00:55:31 <int-e> silly things like this
00:55:49 <doserj> why not just read. show ?
00:55:59 <int-e> because Read is not a superclass of Num.
00:56:04 <int-e> while Show is.
00:56:11 <doserj> oh, true.
00:56:12 <scook0_> fromInteger . read . show
00:56:12 <int-e> @type fromIntegral . sum . map ord . show . (+1)
00:56:14 <lambdabot> forall b a. (Num b, Num a) => a -> b
00:57:15 <scook0_> though piping the output of show back into fromInteger is cheating, and won't actually work in the general case
00:59:17 <scook0_> actually, I realised another (not-very-useful) class of inhabitants of that type
00:59:34 <scook0_> @type const (fromInteger 1)
00:59:36 <lambdabot> forall a b. (Num a) => b -> a
00:59:42 <tuukkah> ok one nice thing about applyNH is that applyNH' show doesn't work
01:00:08 <scook0_> @type const (fromInteger 1) :: forall a b. (Num a, Num b) => b -> a
01:00:10 <lambdabot> forall a b. (Num a, Num b) => b -> a :: forall b a. (Num b, Num a) => b -> a
01:01:08 <tuukkah> also works :-) applyNH (const False)
01:13:55 <vincenz> is it possible to have an operator named ...
01:14:05 <vincenz> > let a ... b = a + b in 1 ... 2
01:14:07 <lambdabot>  3
01:14:08 <vincenz> that answers my question
01:28:37 <vincenz> mudge: ping
01:42:01 <Sizur> ukewaza!!
01:43:16 <tuukkah> vincenz, not .. though :-/
01:44:27 <vincenz> nope
01:44:50 <vincenz> special syntax
01:47:54 <tuukkah> i think ruby had .. and ... but i don't remember how to start a ruby shell
01:48:15 <ibid> .. is a reserved word, just like where :)
01:48:42 <masklinn> tuukkah, the ruby shell is irb
01:49:06 <tuukkah> masklinn, my system is clean ;-) "-bash: irb: command not found"
01:49:23 <masklinn> tuukkah, not even `gem`?
01:49:44 <tuukkah> nope
01:50:00 * ibid ponders lunch
01:50:03 <masklinn> wait, you can't even get irb via gems, it's part of the base ruby install
01:50:03 <tuukkah> i gave in and am apt-getting irb
01:50:05 <masklinn> I think
01:53:18 <tuukkah> perl also had some weird way to start a shell
01:55:12 <oerjan> tuukkah: `like this`
01:55:14 <pejo> tuukkah, for CPAN you mean? perl -MCPAN -e shell
01:55:29 <tuukkah> i mean for a read-eval-print loop
01:55:33 <oerjan> oh
01:56:37 <osfameron> perl doesn't really have a decent repl - though recently there's Devel::REPL which is getting hthere
01:57:11 <tuukkah> haskell gets this so right with ghci
01:57:15 <integral> the old way was to use the debugger: perl -d -e1
01:58:36 <tuukkah> integral, yes that one...
02:00:22 <tuukkah> although ghci needs support for data, type etc. and multi-line expressions
02:04:51 <vincenz> that's rather difficult
02:05:28 <tuukkah> lambdabot can do the first part
02:05:35 <vincenz> data?
02:05:40 <tuukkah> yeah
02:05:44 <vincenz> since when
02:06:26 <vincenz> going ot back up that claim with an example?
02:07:13 <tuukkah> oh, perhaps it can't then. but it easily could, since it compiles a file for each expression
02:07:50 <scook0> is there anything fundamentally difficult about data-in-ghci, other than the fact that datas aren't valid in do blocks?
02:08:18 <tuukkah> scook0, data can't be interpreted as an expression
02:08:20 <vincenz> tuukkah: not really
02:08:27 <vincenz> tuukkah: it accepts an expression, not a definition
02:08:43 <vincenz> the problem with data-in-ghci is that if you can do data, you can also change data
02:08:46 <tuukkah> vincenz, well, @data
02:08:46 <vincenz> assume this
02:08:50 <vincenz> data Foo = Foo | Bar
02:08:53 <vincenz> function ...blabla
02:08:57 <vincenz> (using Foo)
02:09:00 <vincenz> data Foo = Foo | Bar | Bla
02:09:06 <vincenz> and now call that function..
02:09:06 <scook0> vincenz: ah, that's the kind of answer I was looking for
02:09:18 <vincenz> what happens?
02:09:32 <tuukkah> function isn't in scope anymore?
02:09:38 <vincenz> tuukkah: yes it is
02:09:40 <scook0> I can think of a few possibilities offhand, but I assume they all have their problems
02:09:43 <oerjan> mutual recursive data structures cannot be easily defined if everything is immediately interpreted
02:09:52 <tuukkah> vincenz, we could define it to not be
02:09:53 <vincenz> one option: don't allow modifications of data-declarations
02:09:58 <vincenz> but then just put them into a file and load the file
02:10:06 <vincenz> tuukkah: then you change scoping rules to suit your needs
02:10:11 <tuukkah> oerjan, hence multi-line input
02:10:12 <scook0> oerjan: true, but that by itself is not a reason to disallow non-mutually-recursive ones
02:10:19 <vincenz> tuukkah: you're special casing scoping rules, not a good idea
02:10:52 <vincenz> the point is that data-declarations change little enough, and the loading of a file is easy enough, that you can just load the file with the declarations
02:11:10 <scook0> vincenz: that works if you've already put the declarations in the file
02:11:29 <scook0> but I often find myself wanting to define throwaway types interactively
02:11:35 <vincenz> scook0: example?
02:11:58 <scook0> I don't have one off the top of my head, sorry
02:12:38 <vincenz> then you might want to change your claim "I often find myself .."
02:12:47 <Sizur> lol
02:12:57 <tuukkah> there are special things in ghci, but i think it would be intuitive to definitions that depend on a previous declaration of data to disappear
02:13:05 <scook0> vincenz: my claim stands; I just can't demonstrate it to anyone other than myself ;)
02:13:22 <vincenz> tuukkah: you'd seriously fuck up scoping rules
02:13:28 <vincenz> right now it's rather simple
02:13:32 <vincenz> top-level ghci is a monadic-scope
02:13:36 <tuukkah> vincenz, you wouldn't have to think of it as "scoping rules"
02:13:39 <vincenz> hence the 'let'
02:14:00 <vincenz> tuukkah: what you defined are custom scoping-rules
02:14:04 <tuukkah> you can also have non-monadic expressions
02:14:23 <tuukkah> vincenz, more like custom interpretation-sanity rules
02:14:35 <vincenz> tuukkah: yes, and I think that's making things a lot more complex for little gain
02:15:08 <Eelis> like scook0, i too find myself often wanting to define throwaway types interactively. and like scook0, i don't remember the specific cases, i just remember being annoyed that it wasn't possible
02:15:26 <vincenz> vim scratch
02:15:28 <vincenz> ghci
02:15:29 <vincenz> :l scratch
02:15:30 <tuukkah> can't really say ghci is a haskell repl when it doesn't support top-level declarations
02:15:35 <vincenz> :reload scratch
02:15:52 <ibid> simplest would be to allow data declarations but forbid redefinition unless cleared by :clear or something like that
02:15:58 <ibid> like :load does
02:16:08 <scook0> vincenz: yeah, that's pretty close to what I had in mind
02:16:17 <tuukkah> yeah but :clear would be boring because then you lose everything else too
02:16:28 <ibid> tuukkah: yeah, but that's how it works already :)
02:16:29 <scook0> with a little bit more UI-sugar on top
02:16:34 <ibid> tuukkah: with :reload
02:16:45 <vincenz> hence my point :)
02:17:07 <tuukkah> ibid, :reload doesn't help since we don't have files in this context
02:17:17 <ibid> tuukkah: no, i'm talking analogues
02:17:24 <scook0> the sugar is the important part, I think
02:17:34 <vincenz> anywho, back to useful work
02:17:40 <tuukkah> ibid, right, it's boring already ;-)
02:17:53 <ibid> tuukkah: anyway, i can't really figure any better rule than that
02:18:04 <ibid> tuukkah: when recursive definitions are allowed
02:18:16 <ibid> tuukkah: except perhaps that the new definition hides the old one :)
02:18:31 <tuukkah> why are recursive definitions an issue?
02:18:34 <ibid> tuukkah: and so any function that refers to that old definition is effectively unusable
02:19:04 <ibid> hm, they aren't. still my point stands
02:19:14 <tuukkah> ibid, the old definition could still be usable, you just couldn't refer to it by name
02:19:31 <ibid> tuukkah: that's what i said
02:19:41 <ibid> i think :)
02:19:47 <tuukkah> the functions could very well be usable
02:19:49 <ibid> hide the old definition, don't make it go away
02:20:30 <ibid> tuukkah: yeah, if the type is not in the function's signature (and even then if you have some way of making data of that type without referring to that type explicitly)
02:20:47 <tuukkah> what does it matter if it's in the signature?
02:21:04 <ibid> tuukkah: i was thinking of parameters, for return values it doesn't matter
02:21:59 <tuukkah> i could easily imagine having a value of the type already bound to a variable
02:22:01 <ibid> mh, ok. of course, the data constructors would not be hidden except if new data constructors with the same names are defined
02:22:15 <ibid> tuukkah: yes, hence "if you have some way of making data of that type without referring to that type explicitly"
02:22:17 <tuukkah> oh, even that :-)
02:22:39 <tuukkah> (it was too important to be parenthetical)
02:22:53 <ibid> (
02:22:57 <ibid> bah, humbug!
02:22:57 <ibid> )
02:23:09 <tuukkah> ;-)
02:23:58 <tuukkah> so each entry in the interpreter would be run in a new module that imports the previous one
02:24:19 <vincenz> meaning no redefinition
02:24:49 <tuukkah> well if something is redefined then it's not imported, to avoid ambiguity
02:25:07 <tuukkah> or is imported "qualified"
02:25:43 <vincenz> I love it how you keep changing system
02:25:47 <vincenz> then keep adding if-clauses
02:25:59 <vincenz> it's obvious that it's not a simple problem with a simple solution ;)
02:26:05 <vincenz> and it's not the first time it's been asked for.
02:26:10 <vincenz> with similar discussions to ensue
02:28:25 <tuukkah> i hope i didn't claim it was trivial to add this feature to ghci. i meant it would be useful
02:30:25 <vincenz> tuukkah: and the opposing claim is that the usefulness does not weigh against the complexity
02:30:33 * mux wonders what are the relative merits of substructural (linear) type systems and just having with* functions
02:30:37 <vincenz> especially since :l is rather easy
02:31:24 <mux> I can see the use of ordered type systems for stack management for instance, but I don't see much point in linear type systems given that it should be possible to always achieve the same thing using with*-like APIs
02:32:02 <tuukkah> vincenz, to me, it would seem to be worth it. but i acknowledge i'm not the best person to design ghci or anything haskell-related
02:33:19 <vincenz> tuukkah: about one year ago, I was on the same side :P
02:37:45 <vincenz> is there some way of doing unary symbolic data-ops?
02:39:28 <oerjan> ghc has postfix operators
02:39:37 <oerjan> as sections
02:45:27 * vincenz nods
03:20:31 <laz0r> is there a way to import and use haskell code at runtime?
03:21:18 <Japsu> @where hsplugins
03:21:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
03:21:39 <laz0r> thanks, i'll take a look at that
03:22:27 <MrEggEater> Hello, folks!
03:25:09 <MrEggEater> http://pastebin.com/m55952d7e -> Hey guize, what's up with my Haskell code? It doesn't work; I get "unexpected ';' at line 8"!
03:25:45 <MrEggEater> My friends, are you here!?
03:25:58 <Eelis> patience, young jedi
03:26:30 <roman> you don't have '='
03:26:38 <MrEggEater> Where?
03:26:43 <int-e> MrEggEater: remove line 5
03:26:56 <int-e> (what is it supposed to do?)
03:27:02 <MrEggEater> Call the function? :(
03:27:20 <int-e> try  main = print (maxord k 0)
03:28:09 <MrEggEater> Now I'm getting unexpected "|"
03:28:11 <MrEggEater> at line 11
03:28:52 <laz0r> MrEggEater, i think every if must have an else case too
03:30:51 <MrEggEater> Should I only put an else with nothing after it?
03:30:53 <MrEggEater> or wh00t?
03:31:23 <MrEggEater> if __ then __ else
03:31:28 <MrEggEater> like that? seems kinda weird to me :S
03:31:55 <Sizur> what happends if IF will be false?
03:32:00 <Boney> MrEggEater: What's the purpose of an if without "something or something else"?
03:32:08 <int-e_> if a then b else c  is an expression. if a is true it evaluates to b otherwise to c
03:32:10 <Boney> why include the condition at all.
03:32:23 <int-e_> you don't have any effects, so an if without else makes no sense.
03:32:32 <scook0> taking a step back, the problem is that the "if" and "let" aren't doing what you think they're doing
03:32:59 <laz0r> when x > longest, the function should return length x, if not length x > longest, the function should just return longest
03:33:09 <nornagon> :t when
03:33:11 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:33:16 <int-e> another note. "empty" does not exist. I think you mean "null".
03:33:21 <int-e> nornagon: hush :)
03:33:56 <nornagon> @src when
03:33:56 <lambdabot> when p s = if p then s else return ()
03:34:43 <Botje> :t () :: [Int]
03:34:45 <lambdabot>     Couldn't match expected type `[Int]' against inferred type `()'
03:34:45 <lambdabot>     In the expression: ()
03:34:48 <Botje> damn :)
03:35:19 <oerjan> Botje: () and [] are not the same thing
03:35:30 <Botje> i know, i know
03:35:47 <Botje> I was thinking of undefined
03:35:51 <nornagon> :t ():():[]
03:35:53 <lambdabot> [()]
03:36:18 <nornagon> :t ():():undefined
03:36:19 <lambdabot> [()]
03:36:49 <MrEggEater> laz0r: yeah but it has to be recursive though.. I figured what you said was what I wrote :(
03:37:11 <MrEggEater> I mean on two last lines of code
03:37:22 <quicksilver> MrEggEater: there are quite a few confusions in that code
03:37:28 <quicksilver> MrEggEater: 'x' is a single character
03:37:33 <nornagon> Eelis: i think 'padawan' is the word you were looking for :)
03:37:35 <quicksilver> MrEggEater: ah, no, my mistake
03:37:42 <quicksilver> MrEggEater: 'and' is written &&
03:37:48 <Eelis> nornagon: better, yes
03:37:48 <laz0r> MrEggEater, well, i think you should first get rid of the let, you can't 'set' longest to a new value, that would be a side effect
03:38:33 <MrEggEater> what do you mean by side effect? .. I can't override longest at all? I have to use a new variable for the current value?
03:38:37 <quicksilver> MrEggEater: what laz0r says is the most important point. You don't modify variables (like longest) in haskell
03:38:41 <laz0r> you just have the function return the value you want, based solely on the input
03:38:54 <quicksilver> MrEggEater: you just choose return the one you want to return
03:39:00 <quicksilver> MrEggEater: presumably, the larger of the two
03:39:08 <int-e> @quote slowly
03:39:09 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
03:39:09 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
03:39:20 <MrEggEater> Thats what I did in my two cases though?
03:39:47 <MrEggEater> Either I pass length x to the method again, or I pass the old length
03:39:53 <quicksilver> yes the other three cases look sensible
03:39:58 <nornagon> variables are something i wish i'd never learned about :)
03:40:10 <quicksilver> I b elieve you meant to say "if length x > longest then length x else longest"
03:40:12 <int-e> MrEggEater: yes but that doesn't change the value of longest - it creates a new binding to a variable with the same name
03:40:16 <MrEggEater> ohh
03:40:21 <MrEggEater> you mean I should return longest in the first case?
03:40:41 <quicksilver> yes, I think you should, in the first case
03:40:46 <Boney> @source max
03:40:47 <lambdabot> max not available
03:40:56 <quicksilver> I also think the first case is not necessary, incidentally
03:41:01 <int-e> you could just drop the first case
03:41:02 <quicksilver> the second case will cover it
03:41:10 <MrEggEater> quicksilver: even for empty lists?
03:41:15 <int-e> > length []
03:41:16 <lambdabot>  0
03:41:17 <quicksilver> you don't need to do anything 'different' just because x is ""
03:41:24 <Boney> > let max x y = if x > y then x else y in max 3 4
03:41:25 <lambdabot>  4
03:41:46 <Sizur> :t max
03:41:48 <lambdabot> forall a. (Ord a) => a -> a -> a
03:42:02 <nornagon> > let max x y = if x > y then x else y in foldr max 0 [1,7,3,12,1]
03:42:04 <lambdabot>  12
03:42:24 <nornagon> > foldr max 0 [1,7,3,12,10]
03:42:24 <Boney> Haskell is like Lego
03:42:25 <lambdabot>  12
03:42:37 <roconnor> > maximum [1,7,3,12,10]
03:42:38 <nornagon> @remember Boney Haskell is like Lego
03:42:38 <lambdabot> Done.
03:42:39 <lambdabot>  12
03:42:53 <nornagon> @src maximum
03:42:53 <lambdabot> maximum [] = undefined
03:42:53 <lambdabot> maximum xs = foldl1 max xs
03:42:55 <Boney> Haskell is like Lego - you just plug functions togeather.
03:42:56 <roconnor> > 12
03:42:58 <lambdabot>  12
03:43:13 <nornagon> roconnor: that's a pretty cool optimisation!
03:43:19 <oerjan> MrEggEater: actually your function won't work for empty lists in any case
03:43:32 <int-e> oerjan: maximum isn't defined for empty lists
03:43:37 <int-e> so that's ok
03:43:48 <oerjan> er, right
03:44:16 <roconnor> > maximum [-1,-7,-3,-12,-10]
03:44:17 <lambdabot>  -1
03:44:28 <int-e> (ok, you can define it as 0 for empty lists in this particular case)
03:44:29 <roconnor> > let max x y = if x > y then x else y in foldr max 0 [-1,-7,-3,-12,-1]
03:44:30 <lambdabot>  0
03:44:38 <nornagon> roconnor: good catch
03:44:43 <Boney> > maximum {]
03:44:43 <lambdabot>  Parse error
03:44:46 <Boney> > maximum []
03:44:47 <lambdabot>  Exception: Prelude.maximum: empty list
03:45:16 <roconnor> > let max x y = if x > y then x else y in foldr max (-(1/0)) [-1,-7,-3,-12,-1]
03:45:18 <lambdabot>  -1.0
03:45:25 <MrEggEater> oerjan: why not? :(
03:45:29 <scook0> well, maxord already takes an accumulator, so it should be ok with empty lists
03:45:31 <MrEggEater> I could just make a case
03:45:43 <nornagon> > let max x y = if x > y then x else y in foldr1 max [-1,-7,-3,-12,-1]
03:45:43 <MrEggEater> | [] 0 = longest
03:45:44 <MrEggEater> ?
03:45:45 <lambdabot>  -1
03:46:07 <nornagon> > foldr1 max []
03:46:07 <oerjan> MrEggEater: er, forget what i said, as int-e said
03:46:08 <lambdabot>  Exception: Prelude.foldr1: empty list
03:46:16 <nornagon> > maximum []
03:46:17 <lambdabot>  Exception: Prelude.maximum: empty list
03:46:18 <quicksilver> MrEggEater: yes, but you don't need a | for that
03:46:22 <quicksilver> MrEggEater: that would be sensible
03:46:26 <nornagon> er, hm
03:46:29 <quicksilver> MrEggEater: maxord [] longest = longest
03:46:33 <nornagon> i spot a disparity between @src and real life
03:46:36 <nornagon> > undefined
03:46:38 <lambdabot>  Undefined
03:46:55 <quicksilver> MrEggEater: maxord (x:xs) longest { your other cases here }
03:46:57 <nornagon> shouldn't maximum [] spit Undefined instead of an exception?
03:47:00 <Sizur> @go real life
03:47:04 <lambdabot> http://www.reallifecomics.com/
03:47:04 <lambdabot> Title: Real Life Comics - The Online Comic ©1999-2006 Greg Dean
03:47:21 <nornagon> ew, you got copyright notices in my #haskell
03:47:22 <roconnor> > undefined
03:47:24 <lambdabot>  Undefined
03:47:30 <quicksilver> nornagon: @src isn't canonical
03:47:38 <roconnor> I think Undefined is some lambdabot weirdness
03:47:38 <nornagon> quicksilver: ah, i see
03:47:42 <nornagon> where does it come from?
03:47:50 <quicksilver> nornagon: it's more pedagogical
03:47:53 <scook0> and ultimately, a traceable error is better than "Prelude: undefined"
03:48:00 <roconnor> Prelude> undefined
03:48:00 <roconnor> *** Exception: Prelude.undefined
03:48:02 <oerjan> nornagon: @src sometimes uses report source, sometimes ghc
03:48:02 <nornagon> scook0: truth :)
03:48:19 <nornagon> oerjan: how's it generated?
03:48:43 <oerjan> by "hand", i hear
03:50:43 <MrEggEater> is there a function empty that returns true if something is empty?
03:50:52 <Botje> :t null
03:50:54 <lambdabot> forall a. [a] -> Bool
03:50:55 <tuukkah> undefined *is* an exception?
03:50:58 <EvilTerran> @src null
03:50:59 <lambdabot> null []     = True
03:50:59 <lambdabot> null (_:_)  = False
03:51:06 <EvilTerran> @djinn [a] -> Bool
03:51:07 <lambdabot> f _ = False
03:51:13 <EvilTerran> bah. cheat.
03:51:17 <tuukkah> @src undefined
03:51:18 <lambdabot> undefined =  error "Prelude.undefined"
03:51:23 <EvilTerran> surely that's :: a -> Bool?
03:51:55 <quicksilver> tuukkah: undefined happens to be implemented as an exception
03:51:57 <oerjan> EvilTerran: @djinn _still_ does not do lists
03:52:06 <EvilTerran> oh yeah.
03:52:50 <EvilTerran> i figured it'd manage if the type didn't require actually doing anything recursive with the recursive type. er, or something.
03:53:13 <EvilTerran> @remember djinn does not do lists
03:53:14 <lambdabot> Done.
03:53:15 <quicksilver> it doesn't look at the strucutre of types and analyse them, as far as I know
03:53:26 <quicksilver> it simply has proof rules for a few simple algebraic types
03:53:36 <int-e> @quote djinn
03:53:36 <lambdabot> djinn says: does not do lists
03:54:01 <roconnor> does not compute!
03:54:12 <EvilTerran> meh. it could view [x] as (Maybe x), and only distinguish between [] and (x:_}
03:54:25 <roconnor> @djinn Maybe a -> Bool
03:54:26 <lambdabot> f a =
03:54:26 <lambdabot>     case a of
03:54:26 <lambdabot>     Nothing -> False
03:54:26 <lambdabot>     Just _ -> True
03:54:34 <EvilTerran> (that's what i was thinking wrt "not actually doing anything recursive with the recursive type"
03:57:15 <MrEggEater> maxord xs (length x) <- It says (length x) is of the type boolean, it's supposed to be Int!? :'(
03:57:36 <EvilTerran> altho then you'd get funny things like @djinn (a -> b) -> [a] -> [b] coming up with f g [] = []; f g (x:_) = [g x] or something
03:58:01 <EvilTerran> MrEggEater, can you paste some more context?
03:58:03 <EvilTerran> @paste
03:58:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:58:08 <oerjan> MrEggEater: probably it means that you have placed length x somewhere it expects a Bool
03:58:21 <quicksilver> EvilTerran: yes, I knew what you mean
03:58:29 <EvilTerran> yes, that's likely. does maxord maybe expect a Bool in the second parameter?
03:58:38 <quicksilver> EvilTerran: the point I'm trying to make is that @djinn isn't clewver. It doesn't look at types.
03:58:39 <oerjan> look out for somewhere you call maxord with a bool
03:58:45 <MrEggEater> EvilTerran: http://pastebin.com/m66d7a6a8
03:58:49 <quicksilver> EvilTerran: it doesn't look at anything, it just has one short list of proof rules which are hardwires
03:58:50 <MrEggEater> There you go, my dear sir :')
03:58:58 <scook0> EvilTerran: it shouldn't, but in the original paste the signature was commented out
03:59:02 <oerjan> @djinn-env
03:59:03 <lambdabot> data () = ()
03:59:03 <lambdabot> data Either a b = Left a | Right b
03:59:03 <lambdabot> data Maybe a = Nothing | Just a
03:59:03 <lambdabot> data Bool = False | True
03:59:03 <lambdabot> data Void
03:59:04 <scook0> so the wrong type could easily be inferred
03:59:05 <lambdabot> type Not x = x -> Void
03:59:07 <lambdabot> class Eq a where (==) :: a -> a -> Bool
03:59:23 <oerjan> quicksilver: not hard-wired, you can add more i think
03:59:38 <quicksilver> MrEggEater: http://pastebin.com/m18b37397
03:59:39 <oerjan> @help djinn-add
03:59:39 <lambdabot> djinn-add <expr>.
03:59:39 <lambdabot> Define a new function type or type synonym
03:59:57 <quicksilver> MrEggEater: simple fix but hard to explain in words. I swapped around two lines and deleted a |
04:00:11 <EvilTerran> quicksilver, yeah. i know roughly how it works. i figured you could add vaguely sensible non-recursive rules for lists somehow, but i'm sure there's more interesting things to be done to \bot than that...
04:00:21 <int-e> MrEggEater: you'd have gotten a better error if you'd uncomment the type signature for maxword
04:01:37 <MrEggEater> quicksilver: thank you sir!!!
04:01:40 <int-e> MrEggEater: by using maxord in a guard (| maxord [] longest) it derived the type maxord :: [a] -> b -> Bool  for maxord (where a and b are types that are still unknown)
04:01:49 <scook0> yeah, if you don't have many explicit type signatures, your type errors tend to show up in ridiculous places
04:01:56 <scook0> thanks to the magic of inference
04:02:08 <EvilTerran> MrEggEater, in general, if you get a type error you don't understand, add types to things you know the type of 'til the type errors start making sense.
04:03:34 <int-e> MrEggEater: and later it found that the Bool should also be an Int ... which obviously doesn't work.
04:04:25 <EvilTerran> i do that. i get quite a lot of odd type errors, actually; probably something to do with my fascination with Olegian type hacks...
04:04:37 <scook0> type errors have a habit of showing up as "<term> was expected to have <ridiculous type>, but it had <sensible type> instead! oh noes!"
04:05:09 <oerjan> @remember EvilTerran i get quite a lot of odd type errors, actually; probably something to do with my fascination with Olegian type hacks...
04:05:10 <lambdabot> Done.
04:05:19 <EvilTerran> :D
04:07:29 <EvilTerran> that reminds me, i've been meaning to have another go at my instance Num TH.Type...
04:07:51 <oerjan> o_O
04:08:30 <EvilTerran> oh yeah, i remember why i gave that up. even with it, you wouldn't be able to say $(23) in a type and have it work, 'cos TH's type splices're unimplemented :(
04:09:55 <roconnor> In coq one often gets term0 has type exp0 when it is expected to have type exp0. ... stupid hidden implicit arguments...
04:10:48 <MrEggEater> Thanks guize!
04:10:51 <MrEggEater> Time for lunch, cyaz!
04:11:35 <iguana_> what is the reason for having the monomorphism restriction in the first place?
04:11:41 <int-e> implicit arguments are evil anyway
04:12:16 <roconnor> int-e: Start passing in all your type parameters to polymorphic functions.  Let's see how long you last :P
04:13:01 <scook0> @wiki Monomorphism restriction
04:13:02 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:13:15 <scook0> iguana_: there's some mention of it there
04:14:25 <int-e> roconnor: I'll admit that I was speaking in a haskell context.
04:15:16 <roconnor> :D
04:15:28 <Saizan> roconnor: no type reader monad?:)
04:20:08 <quicksilver> iguana_: because in lazy languages people like to assume that CAFs are shared
04:20:12 <quicksilver> iguana_: annoying, though
04:37:28 <muh__> I have a problem with encode from Data.Binary
04:37:40 <muh__> *Types> encode $ replicate 10 (0::Word8)
04:37:41 <muh__> LPS ["\NUL\NUL\NUL\NUL\NUL\NUL\NUL\n\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL"]
04:37:50 <muh__> why is there a \n in there?
04:38:30 <Japsu> > toEnum $ fromEnum '\n' :: Int
04:38:32 <lambdabot>  10
04:38:39 <Japsu> that's why
04:38:57 <Japsu> first there's the length of your list in 8 bytes
04:39:07 <Japsu> thats 10
04:39:09 <muh__> ah
04:39:13 <muh__> I understand
04:39:15 <muh__> thank you
04:39:16 <Japsu> then there's the data of your list
04:39:20 <Japsu> no problem
04:52:42 <swiert> The Monad.Reader is out:
04:52:53 <swiert> Rosalie Iemhoff
04:52:56 <swiert> http://www.haskell.org/haskellwiki/The_Monad.Reader
04:52:57 <lambdabot> Title: The Monad.Reader - HaskellWiki
04:52:58 <swiert> woops.
05:00:59 <muh__> say I have a list of monadic actions: [putStrLn "h",putStrLn "e", putStrLn "lllo"]. Is there a function to execute the actions in the order of the list as if they were written in do notation?
05:01:17 <vincenz> muh__: sequene
05:01:22 <vincenz> sequence even
05:01:22 <muh__> thanks
05:01:26 <vincenz> @hoogle sequence
05:01:26 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
05:01:26 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
05:01:26 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
05:01:37 <vincenz> _the second one most likel, unless you care about the return values
05:06:10 <EvilTerran> which is unlikely in this case, given that they'll be [(),(),()]
05:06:48 <Saizan> well you can save those ()s for later, you never know..
05:07:58 <vincenz> yes, it helps to have a supply of ()
05:08:03 <vincenz> that is why I start all my programs with
05:08:12 <vincenz> the_source = repeat ()
05:08:23 <lscd> so that's where all my ()'s were going; i thought someone was hoarding them :/
05:08:30 <vincenz> I would name it "The Source"(TM) but that goes against lexical conventions.
05:09:33 <puusorsa> laser pointer == remote control for a cat
05:09:59 <vincenz> a 1KW one?
05:10:24 <kfish> swiert, w00t :-)
05:10:26 <vincenz> mudge: ping
05:12:15 <puusorsa> vincenz, nope, and not co2 either
05:12:38 <puusorsa> silly wireless pen mouse thingy with laser ppoiinter
05:12:48 <swiert> kfish: yep.
05:13:09 <swiert> I'm quite happy with the final result.
05:13:55 <puusorsa> aaawww she's so cute <3 ...  cats are teh bestest!
05:14:18 <puusorsa> THIS IS AWESOME!! IT'S MADE OF INTERNETS AND CAPSLOCK! (sorry)'
05:16:38 <vincenz> KTHNXBYE
05:16:55 <vincenz> IM IN YOUR LOOP
05:17:06 <vincenz> oh wait, IM IN YR LOOP
05:17:37 <nominolo> ugh
05:17:53 <nominolo> i can't open TMR8 in evince
05:18:05 <vincenz> tmr8?
05:18:05 <nominolo> it just hangs
05:18:06 <swiert> nominolo: Oh dear.
05:18:12 <swiert> That's odd.
05:18:33 <nominolo> the preview in nautilus works
05:18:40 <nominolo> that's really odd
05:18:41 <kfish> hmm, works for me in evince
05:18:51 <nominolo> kfish, which version?
05:18:56 <Sizur> LUP
05:19:11 <kfish> nominolo, GNOME evince 0.8.1
05:19:13 * nominolo has Evince 0.8.1
05:19:25 <nominolo> hmm...
05:19:48 <kfish> (on ubuntu 7.4)
05:20:09 <nominolo> same here
05:20:36 <nominolo> ok, i closed all open documents and tried again
05:20:39 <nominolo> now it works
05:20:44 <nominolo> weird...
05:20:48 <kfish> yaygnome
05:21:13 * mux has evince 0.8.3 and now problem reading TMR8
05:21:15 * Saizan has evince 0.8.3 and can't open any pdf
05:21:19 <mux> hah.
05:21:27 <mux> s/now/no/
05:21:40 <Saizan> :D
05:21:42 <vincenz> tmr8 == ?
05:21:45 <vincenz> oh, monad reader
05:21:46 <swiert> nominolo: Let me know if you keep experiencing problems.
05:21:50 <vincenz> I thought that was html based
05:21:55 <kfish> http://www.haskell.org/haskellwiki/The_Monad.Reader
05:21:56 <lambdabot> Title: The Monad.Reader - HaskellWiki
05:21:59 * mux is actually quite pleased with evince
05:22:17 <mux> it was really tiring to only have xpdf or acroread, "back in the days"
05:22:30 <vincenz> mudge:  you forgot 'nz' at the nd
05:22:30 <laziest> what do you expect from:
05:22:31 <vincenz> end
05:22:33 <laziest> main = seq (putStrLn "abcd") (putStrLn "efgh")
05:22:46 <vincenz> efgh
05:22:51 <quicksilver> I expect to see "efgh" printed
05:22:53 <laziest> and why?
05:22:56 <vincenz> the first isn't print
05:23:00 <vincenz> you force the value to a monadic action
05:23:00 <laziest> I mean why not "abcd"?
05:23:01 <nominolo> swiert, i will come back to you regarding the TMR special issue
05:23:05 <quicksilver> because all 'seq' does is force the value
05:23:05 <vincenz> you don't actually sequence the action into the io-line
05:23:14 <quicksilver> it doesn't cause IO actions to be evaluated
05:23:14 <laziest> ah!
05:23:21 <laziest> where can I get this exact information?
05:23:27 <vincenz> think of io as one long line going through your program :)
05:23:30 <puusorsa> from teh internets??
05:23:34 <vincenz> you're not putting that first action on the line
05:23:43 <quicksilver> laziest: which exact information?
05:23:45 <swiert> nominolo: Sure. Let me know if you have any questions.
05:24:04 <laziest> that 'seq' forces only the value and not io action?
05:24:46 <quicksilver> laziest: http://www.haskell.org/onlinereport/basic.html
05:24:48 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
05:24:52 <quicksilver> laziest: section 6.2 :)
05:25:03 <laziest> Is it that IO actions have to go through ">>="?
05:25:06 <quicksilver> admittedly that may not seem all that helpful to you, but that *does* actually define it
05:25:16 <doserj> and the fact that it is called 'seq' and not 'unsafeSeq'
05:25:18 <laziest> in order to perform the actions?
05:25:21 <quicksilver> laziest: no
05:25:26 <quicksilver> laziest: even that doesn't perform the action
05:25:36 <quicksilver> laziest: that just forms a bigger action by joining together two smaller ones
05:25:51 <quicksilver> laziest: there is only one way in haskell to perform an IO action; that is to attach it to 'main'
05:26:01 <laziest> and then the "system" asks the evaluation of "main"?
05:26:05 <quicksilver> yes
05:26:07 <laziest> ah, you just said it.
05:26:13 <quicksilver> although evaluation is not the right word
05:26:17 <quicksilver> but that's the right idea
05:26:21 <ciw6002> is there a way to overload functions in haskell with the same number of parameters, only with different types?
05:26:27 <quicksilver> the runtime system causes the main action to evaluated
05:26:37 <quicksilver> ciw6002: yes, but I don't recommend it
05:26:39 <quicksilver> ciw6002: typeclasses
05:26:50 <beelsebob> quicksilver: unsafePerformIO introduces an action
05:26:53 <vincenz> quicksilver: join!
05:26:58 <laziest> I did not actually mean to get trace through it; I just wanted to see if I can trick it out...
05:27:04 <quicksilver> beelsebob: fortunately, unsafePerformIO is not haskell
05:27:22 <quicksilver> vincenz: join?
05:27:23 <laziest> But yes, I am not the laziest entity...
05:27:26 <vincenz> quicksilver: #oasis
05:27:31 <ciw6002> quicksilver: I would like to have a getMax Table -> Int -> Int and getMax SimpleTable _> Int -> Int, is there some way to check what argument type the first one is?
05:27:32 <vincenz> you filter invitations?
05:27:44 <quicksilver> vincenz: no, I just hadn't looked yet in that window
05:27:56 <vincenz> lazy bastard :)
05:27:59 <quicksilver> indeed
05:28:05 <beelsebob> quicksilver: ah, wow, long time since I've seen someone in here make the destinction between Haskell and something very similar to Haskell with other stuff added
05:28:07 <ciw6002> i.e.     x <- SimpleTable or something?
05:28:08 <quicksilver> so lazy I was too busy explaining haskell semantics :)
05:28:18 <vincenz> beelsebob: clean?
05:28:19 <quicksilver> beelsebob: well it's important for pedagogy
05:28:35 <quicksilver> beelsebob: to introduce unsafe at this stage would almost have seemed to tacitly recommend its use
05:28:35 <beelsebob> quicksilver: I agree -- I just didn't expect someone other than me to make the destinction
05:28:55 <beelsebob> vincenz: no, the odd language that's talked about in here for 99% of the time
05:28:59 <beelsebob> that most people call Haskell
05:29:03 <vincenz> oh
05:29:04 <beelsebob> but isn't actually anything to do with Haskell at all
05:29:05 <vincenz> you mean ghc :)
05:29:08 <beelsebob> exactly
05:29:17 <vincenz> hmm, you're from the jhc or nhc team?
05:29:22 <ciw6002> any idea how to check what type var1 is?
05:29:24 <beelsebob> no, hat
05:29:29 <vincenz> with ndm?
05:29:42 <beelsebob> no, ndm works on yhc and other funky phd related tools
05:29:45 <beelsebob> I work on hat
05:29:48 <vincenz> ah
05:29:48 <vincenz> ok
05:29:52 <quicksilver> ciw6002: that does sound like an time when typeclasses would be right
05:30:05 <beelsebob> but yes, another tool that works with Haskell
05:30:08 <quicksilver> ciw6002: you make Table and SimpleTable both instances of 'TableWithMax'
05:30:16 <beelsebob> rather than the odd language ghc compiles
05:30:16 <quicksilver> ciw6002: (or some better name for the typeclass)
05:30:19 <ciw6002> quicksilver: ok, I will check the subject, thank you.
05:30:29 <laziest> another question: what are the 'haskell' alternative when you require runtime polymorphism?
05:30:40 <quicksilver> ciw6002: and then in each instance gives the correct defn of getMax
05:30:49 <quicksilver> laziest: what kind of polymorphism?
05:31:19 <laziest> like I have a list of items which derive from the same basic type; and I want to act on all of them according to some common rule
05:31:28 <vincenz> yes
05:31:30 <quicksilver> laziest: typeclasses
05:31:31 <vincenz> you want existentials
05:31:35 <vincenz> and typeclasses
05:31:55 <laziest> typeclass I know, and they have to be static. You won't get a list of different typed objects
05:32:05 <laziest> How much would you recomment existentials?
05:32:13 <laziest> recomment->recommend
05:32:25 <vincenz> only when required :)
05:32:29 <vincenz> like all things for that matter
05:32:42 <laziest> Can you restrict the the "super" type of things with existentials?
05:32:52 <vincenz> eh
05:32:53 <vincenz> ?
05:32:57 <beelsebob> laziest: tbh, I'd say "use an either type"
05:32:59 <vincenz> existential are bound by a class
05:33:13 <vincenz> and classes are bound by their left-context, or whatever that's called
05:33:19 <laziest> ah.
05:33:19 <beelsebob> if you know the set of types that can be there, wrap them up in a big Either that means something
05:33:23 <laziest> Ya. Got it.
05:33:30 <quicksilver> well not really a big Either
05:33:35 * vincenz thinks Either should've been called :+
05:33:39 <quicksilver> a big disjnctive type
05:33:43 <beelsebob> no, but something that does disjunction
05:33:49 <quicksilver> which you can give a suitable name to
05:33:51 * quicksilver nods
05:33:52 <beelsebob> disjunctive tuples!
05:33:54 <beelsebob> *hidse*
05:33:59 <quicksilver> I'm all for them
05:34:00 <laziest> Either will still require case by case analysis
05:34:15 <beelsebob> laziest: just some pattern matching :)
05:34:15 <mux> or using either
05:34:17 <mux> :t either
05:34:17 <quicksilver> laziest: yes, but you can encapsulate that pretty simply
05:34:18 <laziest> I should be able to add types dynamically, and the parent behaviour should be the same
05:34:21 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:34:28 <quicksilver> laziest: then you do indeed want an existential
05:34:49 <laziest> yes indeed, quicksilver; I will go for exintential.
05:35:00 <mux> > either read id (Either 2 "foo")
05:35:01 <lambdabot>   Not in scope: data constructor `Either'
05:35:11 <laziest> Are existentials "Haskell"?
05:35:12 * beelsebob runs away to see olaf
05:35:12 <mux> eh?
05:35:19 <laziest> I mean they are not haskell 98
05:35:20 <EvilTerran> exiStentials
05:35:30 <vincenz> reminds me of that movie
05:35:31 <beelsebob> mux: the constructors of Either are Left and Right
05:35:32 <vincenz> existence
05:35:33 <beelsebob> not Either
05:35:36 <mux> existentials require explicit universal quantifiers
05:35:41 <mux> beelsebob: ouch, I need sleep
05:35:53 <mux> > either read id (Left 42)
05:35:54 <lambdabot>   add an instance declaration for (Num String)
05:36:05 <mux> > either read id (Left 42) :: String
05:36:05 <lambdabot>   add an instance declaration for (Num String)
05:36:10 * vincenz wrinkles
05:36:14 <ddarius> There are additive products...
05:36:20 <beelsebob> mux: you're trying to call read on 42
05:36:23 <mux> oh, whatever
05:36:31 <mux> yeah, I'm doing it all backwards
05:36:32 <vincenz> ddarius: yes, but they're not healthy, that's why nowadays they sell 100% natural stuff
05:36:39 <beelsebob> mux: yep :)
05:36:40 <quicksilver> > map (either read id) [Left 2, Right "43"]
05:36:41 <lambdabot>   add an instance declaration for (Num String)
05:36:49 <quicksilver> > map (either id read) [Left 2, Right "43"]
05:36:49 <vincenz> duh!
05:36:51 <lambdabot>  [2,43]
05:36:52 <vincenz> :)
05:36:57 <mux> and it's contagious
05:36:59 <mux> :D
05:37:01 <quicksilver> mux: is that what you were trying to demonstrate? :)
05:37:07 <mux> yes :-)
05:39:32 <mux> I'm surprised there aren't fromLeft and fromRight functions, similar to fromMaybe
05:39:41 <mux> fromLeft = either id
05:39:44 <mux> fromRight = flip either id
05:39:59 <ddarius> We likes our folds.
05:40:21 <quicksilver> it is widely thought that Data.Either is a bit sparse
05:40:41 <ddarius> You need Left, Right, and either what more do you want?
05:40:52 <quicksilver> :t \l -> ([a | Left a <- l],[a | Right a <- l])
05:40:55 <lambdabot> forall t t1. [Either t t1] -> ([t], [t1])
05:41:01 <quicksilver> many people would like that one, apparently
05:41:23 <mux> @src Either (>>=)
05:41:23 <lambdabot> Left  l >>= _ = Left l
05:41:23 <lambdabot> Right r >>= k = k r
05:43:05 <mux> have any of the XML libraries been updated to use ByteStrings yet?
05:43:31 <EvilTerran> Data.Tuple could use some more stuff, too
05:44:53 <quicksilver> there's quite a lot you could do with tuples
05:45:00 <quicksilver> not least, a tuple typeclass
05:45:04 <quicksilver> I'm not convinced it's worth it, though
05:45:10 <quicksilver> I've certainly never needed it
05:45:22 <EvilTerran> first and second wouldn't be out of place in it, for starters. things equivalent to (and &&& fst) and join (,) would be nice, too
05:45:34 <quicksilver> (arguably HList is 'quite a lot you can do with tuples')
05:45:38 <EvilTerran> *(snd &&& fst), rather
05:46:50 <mux> yeah, like mapPair = join (***)
05:47:37 <mux> but that would require bringing Control.Arrow in
05:48:15 <quicksilver> yes it certainly *is* a bit weird that all the cool tuple manipulation stuff is in Control.Arrow
05:48:25 <quicksilver> one gets the impression that arrows are just about 2-tuples
05:48:32 <quicksilver> which really isn't the point ;)
05:51:04 <ndm> someone messaged me, but i accidentally shut down IRC before i could read it - do scream again!
05:51:17 <Boney> exit
05:52:09 <aleator> Hey. Does x f (a,b) = (f a, f b) have a name?
05:52:39 <xerox> aleator: what mux said some lines above
05:52:53 <EvilTerran> > join (***) (+1) (2,3)
05:52:58 <lambdabot>  (3,4)
05:53:20 <aleator> xerox: oops. Wasn't reading :)
05:53:51 <xerox> aleator: coincidence :)
05:53:58 <EvilTerran> it bothers me slightly that, in order to do funk like that, we need to bring in hairy concepts like arrows and Monad (e->)
05:54:21 <ddarius> > join (\x y -> concat ["(",show x,",",show y,")"]) ("f "++) ("a","b")
05:54:22 <lambdabot>  Couldn't match expected type `t1 -> t'
05:54:27 <EvilTerran> which was why i think it'd be nice to have equivalents in Data.Tuple. keep the error messages sane for the newbies.
05:54:46 <quicksilver> yar
05:54:53 <ddarius> Oops, that's not going to work.
05:54:57 <quicksilver> doesn't even need reimplementing
05:55:05 <quicksilver> can just be join (***) but with a more precise type
05:55:12 <ddarius> :t (***) -- not a friendly enough type?
05:55:14 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
05:55:20 <quicksilver> agreed
05:55:24 <EvilTerran> meh. i'd be inclined to write it with nice source.
05:55:47 <vincenz> :t join (***)
05:55:48 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
05:55:50 <quicksilver> but fmapPair :: (a->b)->(a,a)->(b,b) ; fmapPair = join (***) is fine
05:55:54 <EvilTerran> forall ((~>) :: * -> * -> *) b c b' c'. (Arrow (~>)) => b ~> c -> b' ~> c' -> (b, b') ~> (c, c') -- i'd consider this acceptable
05:56:06 <ddarius> Only two articles in TMR ...
05:56:15 <ndm> ddarius: then write one for next time :)
05:56:25 <ddarius> ndm: I very likely will.
05:56:29 <EvilTerran> but it's still getting hairy advanced concepts involved when some poor newbie looks at the source of our new, improved Data.Tuple
05:56:50 <ndm> i might as well, or the one after that
05:57:12 <ddarius> I've been meaning to; I've just been lazy.
05:57:34 <ndm> seq (tmr by ddarius)
05:58:07 <xerox> :: a -> a
05:58:17 <ndm> ddarius: have you emailed wouter? its a good first step towards action
05:58:50 <ddarius> ndm: No, but then I've been meaning to since like TMR 3.
06:10:01 <muh__> does anyone know what http://hoogle.com/ is?
06:10:03 <lambdabot> Title: HOOGLE.COM
06:10:57 <ddarius> Looks like an empty blog.
06:11:40 <mrd> @where hoogle
06:11:40 <lambdabot> http://haskell.org/hoogle
06:20:53 <ndm> it used to be a bondage porn site
06:21:03 <ndm> but hoogle.com is nothing to do with the haskell hoogle
06:21:17 <muh__> srsly?
06:23:45 <ndm> or maybe it was hoogle.net
06:24:01 <ndm> certainly when i first started hoogle, googling for hoogle gave you a porn site at the top
06:25:39 <bdash> ndm: http://web.archive.org/web/20050512005222/http://www.hoogle.net/
06:25:41 <lambdabot> Title: Bondage Accessories. Over 250 HQ photos!!!.... WARNING: Page contents ADULT mate ...
06:26:14 <bdash> hoogle.com looks to have always been filled with ads
06:26:42 <quicksilver> maybe 'hoogle' is some euphemism of which we innocent types are unaware
06:26:56 <matthew_-> and suddenly #haskell is nsfw!
06:27:26 <ndm> hoogle (before me) was for people who mistyped google
06:39:00 <gleb> @index GenParser
06:39:01 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
06:58:27 <hpaste>  esteban2 pasted "applying functions recursively" at http://hpaste.org/2671
06:59:04 <esteban2> hey can anyone help me out with this? this function should apply a list of functions to a list, but its not working
06:59:26 <esteban2> i had pasted it here before.. someone said it seemed correct but i can't figure out how to make it work properly in haskell
06:59:47 <quicksilver> esteban2: looks odd to me
07:00:29 <quicksilver> esteban2: can you explain what you're trying to do in the final line?
07:00:58 <quicksilver> esteban2: in fact, the type signature looks odd to me too
07:01:04 <esteban2> composing functions
07:01:21 <quicksilver> String -> [String->String] -> String
07:01:25 <doserj> the first line probably should be 'func xs [] = xs'
07:01:26 <esteban2> i compose the head with calling the function with "fs" as the argument
07:01:34 <quicksilver> it takes a String, a list of functions String -> String
07:01:39 <esteban2> yes, quasisane
07:01:43 <esteban2> yes, quicksilver
07:01:43 <quicksilver> what is it supposed to do with the list of functions
07:01:49 <quicksilver> it has only one string
07:01:54 <quicksilver> but a whole list of functions
07:01:54 <esteban2> well there're other functions that do stuff on strings
07:01:57 <esteban2> but thats not important
07:02:15 <quicksilver> no, you're not answering my question
07:02:20 <quicksilver> your first argument is a String
07:02:23 <esteban2> yes
07:02:27 <quicksilver> your second argument is a list of functions String -> String
07:02:37 <quicksilver> what are you expecting to do with the list of functions?
07:02:44 <esteban2> the list of functions should be applied to that string, and return that string as a result
07:02:54 <quicksilver> but that would give a list of results, surely?
07:03:01 <esteban2> no
07:03:07 <quicksilver> you have one string, then suppose you have 5 functions
07:03:11 <quicksilver> then you get 5 string results
07:03:13 <esteban2> it does this: (.) f1 f2 f3 f4 (x:xs)
07:03:23 <esteban2> it composes all the functions
07:03:28 <quicksilver> ah, ok
07:03:37 <quicksilver> what you just wrote is nonsense, by the way
07:03:41 <esteban2> why
07:03:44 <quicksilver> (.) takes two arguments
07:03:52 <quicksilver> not four :)
07:04:05 <esteban2> yes.. the first is the head of the list and the second is calling the function
07:04:12 <esteban2> maybe theres a parentisis issue
07:04:20 <quicksilver> no, there is a nonsense issue
07:04:28 <quicksilver> in your example you have four functions f1 f2 f3 f4
07:04:31 <esteban2> > (.) (*3) (*2) 3
07:04:33 <lambdabot>  18
07:04:34 <quicksilver> you cannot compose them all with just one dot
07:04:40 <quicksilver> you can only compose two functions with one dot
07:04:41 <twanvl> If you want to compose functions you need to write: (f1 . f2 . f3 . f4) xs
07:04:50 <esteban2> > (.) (*3) (*2) (*4) 3
07:04:51 <lambdabot>   add an instance declaration for (Num (a -> a))
07:04:54 <quicksilver> the normal way would be to write the . infix
07:04:54 <esteban2> damn
07:04:58 <quicksilver> as twanvl says
07:05:00 <quicksilver> (f1.f2.f3.f4)
07:05:17 <esteban2> > (*3).(*2).(*3) 3
07:05:18 <lambdabot>   add an instance declaration for (Num (a -> b))
07:05:20 <kjdf> is there a standard function mapPair f (a,b) = (f a, f b) ?
07:05:40 <esteban2> > (*2.*4.*5.*6) 3
07:05:41 <lambdabot>   Not in scope: `.*'
07:05:43 <esteban2> > (*2.*4.*5.*6)
07:05:44 <lambdabot>   Not in scope: `.*'
07:05:55 <esteban2> so i should use the infix operator
07:06:19 <twanvl> > ((*2) . (*4) . (*5) . (*6)) 3
07:06:20 <lambdabot>  720
07:06:34 <esteban2> this is no good :(
07:06:45 <esteban2> how would this be considered in an exam? :(
07:06:57 <ibid> >(*2).(*4).(*5).(*6)$3
07:06:57 <earthy> > foldr1 (.) [(*3),(*2),(*4)] 3
07:06:59 <lambdabot>  72
07:07:11 <ibid> > (*2).(*4).(*5).(*6)$3
07:07:13 <lambdabot>  720
07:07:36 <twanvl> ?type ap (***)
07:07:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c -> a b' c') -> a b c -> a (b, b') (c, c')
07:08:46 <earthy> kjdf: what you want is ill-typed
07:08:57 <earthy> it would only work if both elements of the tuple have the same type
07:08:58 <twanvl> ?type join (***)
07:09:00 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:09:18 <earthy> so in general, no, there is no mapPair
07:09:39 <earthy> however, mapPairWithEqualType = join (***)    as twanvl so helpfully provides. :)
07:09:55 <ibid> couldn't it take a universally quantified function type? (not h98, but...)
07:10:07 <twanvl> That would be pretty useless
07:10:15 <earthy> ibid: yeah, but then the f wouldn't be very interesting, now would it? :)
07:10:18 <ibid> :)
07:10:44 <earthy> id or const something  :)
07:11:11 <ibid> earthy: as useful as mapping the same function over two different types can be :)
07:11:25 * earthy laughs
07:11:33 <earthy> true enough
07:11:42 <esteban2> so how would this be? f.(func (x:xs) fs)
07:11:53 <ibid> earthy: though, is it not possible to constrain the quantified type with a typeclass?
07:12:06 <hpaste>  esteban3 pasted "yet not working" at http://hpaste.org/2672
07:12:10 * ibid is too lazy to look it up
07:13:20 <twanvl> esteban2: you don't need (.)
07:13:41 <earthy> ibid: yah, but then you'd add the constraint over the mapPair itself and then you're almost as bad as constraining both elements of the pair to be of equal type
07:13:53 <twanvl> You would need intersection types to make it really interesting
07:13:56 <doserj> esteban2: and you don't need the final (x:xs)
07:14:29 <ibid> earthy: true enough
07:14:55 <quicksilver> esteban2: it's strange to use (x:xs) at all
07:15:04 <quicksilver> esteban2: you never inspect the internal structure of that string
07:15:10 <quicksilver> esteban2: you could just call it "s"
07:15:11 <doserj> esteban2: and the base case is just wrong :)
07:15:30 <quicksilver> esteban2: (and if you just call it "s" it will work for empty strings too, which is a benefit)
07:16:31 <bos> @seen ddarius
07:16:31 <lambdabot> I saw ddarius leaving #haskell-blah, #haskell-overflow and #haskell 40m 12s ago, and .
07:16:33 <hpaste>  byorgey annotated "yet not working" with "what about something more general?" at http://hpaste.org/2672#a1
07:16:34 <esteban2> i need to apply it to the whoe list
07:16:52 <quicksilver> esteban2: are you responding to me?
07:16:56 <esteban2> what needs to be inspected is the list of functions
07:16:59 <quicksilver> esteban2: (x:xs) is your String, not your list
07:17:10 <esteban2> the list of chars
07:17:19 <quicksilver> esteban2: there is no need to break the string up into "First character" (x) and "other chars" (xs)
07:17:25 <quicksilver> esteban2: you don't use either of those anyway
07:17:30 <quicksilver> esteban2: and it stops it matching empty strings
07:17:42 <quicksilver> esteban2: simpler and clearer to just use a name for the whole string
07:17:52 <esteban2> yes
07:18:05 <quicksilver> esteban2: of course you *do* need to break up f and fs. I totally agree there.
07:18:09 <esteban2> but my question is just about the composition
07:18:28 <quicksilver> esteban2: the answer is f (func (x:xs) fs)
07:18:31 <quicksilver> esteban2: as you wrote it
07:18:49 <hpaste>  (anonymous) annotated "yet not working" with "(no title)" at http://hpaste.org/2672#a2
07:18:51 <esteban2> so using a non infix operator was bad? :(
07:18:59 <quicksilver> esteban2: using (.) was wrong
07:19:07 <quicksilver> esteban2: because you don't actually have something to (.) with
07:19:15 <quicksilver> esteban2: here is the solution with (.) :
07:19:25 <esteban2> da*n
07:19:32 <quicksilver> f . (\l -> func l fs) $ (x:xs)
07:19:43 <quicksilver> or, if you prefer to use non-infix
07:19:53 <quicksilver> (.) f (\l -> func l fs) (x:xs)
07:20:13 <quicksilver> but I don't think that's easier to understand than the non-. version
07:20:15 <esteban2> ok.. thanks for the help
07:20:23 <esteban2> but im already fucked up :(
07:21:46 <esteban2> i had an exam of all of this.. i wrote the composition using a non infix operator and it works only for two functions.. i did apply the concept of function composition anyway but it wouldn't work in haskell
07:23:50 <esteban2> i guess i'll do better in next opportunity
07:39:04 * hgolden is back
07:41:25 <crazy_coder> Hello everyone
07:41:39 <crazy_coder> can anyone explain me the use of IORef ?
07:41:56 <Lemmih> crazy_coder: Sure.
07:42:16 <quicksilver> crazy_coder: create a new one with newIORef. pass around the handle you get from that.
07:42:25 <quicksilver> crazy_coder: read it, write it, enjoy the pain of mutable state
07:42:47 <Tac-Work> pain of mutable state? how negative =-P
07:42:50 <Lemmih> crazy_coder: An IORef is a mutable cell containing a boxed value.
07:43:02 <Tac-Work> Mutability is like what Peter Parker's Uncle told him when he was a kid
07:43:13 <Tac-Work> "With great power comes great responsibility."
07:43:23 <crazy_coder> heh
07:43:34 <Lemmih> And great bugs.
07:43:40 <crazy_coder> oh ok
07:43:59 <quicksilver> No, mutability is more like Lord Acton.
07:44:08 <quicksilver> "Power corrupts, absolute power corrupts absolutely"
07:44:14 <crazy_coder> but what all is required to be encapsulated in the state ?
07:44:16 <sjanssen> crazy_coder: the correct answer is "don't" :)
07:44:19 <kjdf> is there a standard function swap (a,b) = (b,a)?
07:44:35 <sjanssen> @type uncurry (flip (,))
07:44:37 <lambdabot> forall b a. (a, b) -> (b, a)
07:44:37 <quicksilver> crazy_coder: eh?
07:44:44 <crazy_coder> i mean, how to decide what all represents a state ?
07:44:54 <quicksilver> surely that's up to you, the programmer :)
07:45:05 <quicksilver> 99% of the time, an IORef is actually the wrong answer anyway
07:45:15 <quicksilver> but without knowing a bit more about the class of problem you're trying to solve...
07:45:48 <crazy_coder> I am using GTK2hs and it requires using IORef to pass the state of the game I am writting
07:46:09 <quicksilver> realy? how does it require that?
07:46:40 <dcoutts_> because of the inverted control flow
07:46:42 <crazy_coder> In all the tutorials i read and the demo programs, they have used it
07:46:49 <Tac-Work> orly?
07:46:55 <crazy_coder> ??
07:47:14 <quicksilver> crazy_coder: well typically you define a custom type which represents your game's state, and pass that, I guess
07:47:22 <crazy_coder> yeah
07:47:33 <dcoutts_> crazy_coder: so, yes, usually an IORef with a record containing your state
07:47:49 <dcoutts_> or you can use threads and channels
07:48:03 <quicksilver> sounds like a good use case for my article on monadic tunneling :)
07:48:30 <dcoutts_> and you can make that nicer by using state monad like functions that hide the IORef
07:48:55 <crazy_coder> ok I'll see
07:48:56 <crazy_coder> Thanks
07:49:07 <quicksilver> doesn't even have to be state monad-like
07:49:11 <quicksilver> it can actually be the state monad :)
07:49:32 <quicksilver> mkWrapper :: IORef s -> IO a -> State s a
07:49:38 <quicksilver> erm
07:49:40 <quicksilver> that's backwards
07:49:51 <quicksilver> mkWrapper :: IORef s -> State s a -> IO a
07:50:15 <quicksilver> use that whenever you're asked to pass a callback to the flow inversion
07:50:27 <quicksilver> and it wil bundle your nice clean state actions into IO
07:50:32 <quicksilver> unless I'm missing something
07:51:39 <dcoutts_> so you could make your IORef at the same time you build your GUI widgets and then when you attach the signal callbacks, use mkWrapper
07:52:10 <quicksilver> yes, that is what I'm trying to say
07:52:14 <dcoutts_> quicksilver: that's fairly nice for a lightweight approach, are you going to write about this?
07:52:16 <quicksilver> albeit slightly clumsily :)
07:52:19 <quicksilver> dcoutts_: I already did
07:52:26 <quicksilver> dcoutts_: although I wasn't talking about gtk2hs specifically
07:52:33 <dcoutts_> quicksilver: it is one of the main problems gui users run into early
07:52:51 <quicksilver> @go haskell-cafe monadic tunnelling
07:52:53 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
07:52:53 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ...
07:53:09 <dcoutts_> that they suddenly have to use rather imperative stuff for threading state between their signal handlers
07:53:14 * quicksilver nods
07:53:27 <quicksilver> I note that you can thread the reader monad too
07:53:35 <quicksilver> and with a little care you can classifiy your callbacks
07:53:39 <quicksilver> maybe some only need to be readers
07:53:42 <dcoutts_> it's the primary problem many high level GUI libs try to solve
07:53:46 <quicksilver> (needs a slightly different version of mkWrapper)
07:53:56 <quicksilver> then your type system is giving you more information
07:54:10 <quicksilver> which actions actually do change the state and which don't
07:54:27 <quicksilver> if you want to get really fancy, you can have some actions acting only on part of the state
07:54:33 <quicksilver> (and declaring that in their types)
07:58:20 <Tac-Work> What is the point of a reader exactly?
07:58:27 <Tac-Work> A state or a writer, I can understand
07:58:38 <Tac-Work> but a reader seems like a syntax heavy parameter as far as I can tell
07:59:02 <Tac-Work> what advantages do they provide over making an argument a parameter?
08:00:18 <ToRA> Tac-Work: you don't need to thread that parameter around to inter-related functions?
08:00:33 <sjanssen> Tac-Work: it's usually easier to compose functions with Reader
08:00:35 <dcoutts_> Tac-Work: when you have 20+ parameters? :-)
08:01:10 <Tac-Work> oh cool, it's like I can pick whichever answer sounds best!
08:01:11 <Tac-Work> hehe
08:01:43 <ToRA> dcoutts_: I was going to say that, but in both cases wouldn't you just use a record-syntax struct?
08:02:25 <waern> you don't have to pass the value around
08:03:02 <waern> oh, that was already said ;)
08:03:37 <dcoutts_> ToRA: we have this example in cabal where we have a bunch of params that we currently bundle into a record, but now some of those components need to be in Show and others cannot be in Show, so we'd need at least 2 record types
08:03:49 <Tac-Work> if this were a test, I'd probably choose dcoutts answer, because the first two essentially say the same thing
08:04:14 <Tac-Work> and the professor was probably looking for #3 even though I don't feel it's the *most* correct answer ;-)
08:04:17 <ToRA> dcoutts_: what's wrong with creating a projection function to move from one context to another?
08:06:41 <hkBst> what is the haskell convention for predicates?
08:07:04 <hkBst> how would I name `palindrome?' ?
08:07:23 <quicksilver> isPalindrome, perhaps
08:07:30 <quicksilver> that's the closest to a convention I've see
08:07:32 <quicksilver> :t isDigit
08:07:38 <lambdabot> Char -> Bool
08:08:58 <int-e> :t odd
08:09:00 <lambdabot> forall a. (Integral a) => a -> Bool
08:09:05 <sjanssen> @type null
08:09:07 <lambdabot> forall a. [a] -> Bool
08:09:24 <int-e> well, digit is a noun, odd is an adjective. it makes sense.
08:09:56 <int-e> null, however, doesn't really fit.
08:09:58 <hkBst> int-e: so I should use `palindromal' :) ?
08:10:27 <int-e> if you must.
08:12:23 <Tac-Work> @let palin x = x==reverse x
08:12:27 <lambdabot> Defined.
08:12:41 <Tac-Work> > palin "redrummurder"
08:12:42 <lambdabot>  True
08:13:11 <Tac-Work> > palin "palindrome"
08:13:12 <lambdabot>  False
08:13:36 <Tac-Work> Nonautodescriptive words are sad words indeed
08:14:22 <nominolo> > palin "palindromordnilap"
08:14:24 <lambdabot>  True
08:14:49 <nominolo> > palin "palinilap" -- sounds better
08:14:51 <lambdabot>  True
08:15:58 <quicksilver> > odd . length $ "odd"
08:16:00 <lambdabot>  True
08:16:03 <quicksilver> > even . length $ "even"
08:16:05 <lambdabot>  True
08:16:10 <quicksilver> freaky
08:16:12 <nominolo> that's odd
08:16:39 <nominolo> > prime . length "prime"
08:16:40 <lambdabot>   Not in scope: `prime'
08:16:44 <fasta> If I force the spine of a list containing (Int, Int), those Ints won't be forced then, right?
08:17:05 <fasta> And if the list contained simple Ints, they would be forced?
08:17:19 <nominolo> i don't think so
08:17:42 <fasta> > last $ reverse [1, undefined]
08:17:44 <lambdabot>  1
08:17:46 <nominolo> only unboxed arrays have this behaviour
08:17:56 <araujo> hello
08:18:01 <sjanssen> fasta: no, they won't be forced
08:18:02 <fasta> Ok, that answers the question.
08:18:13 <sjanssen> fasta: unless construction of the list is somehow strict in the elements
08:18:37 <fasta> sjanssen: if I apply rnf then it will. I will just do that.
08:19:09 <sjanssen> for example, you can define "mycons x xs = x `seq` (x:xs)", and always use mycons instead of (:)
08:19:28 <sjanssen> fasta: keep in mind that rnf tends to be quite expensive
08:19:44 <fasta> sjanssen: why is it expensive?
08:20:04 <fasta> sjanssen: or rather more expensive than using seq?
08:20:04 <sjanssen> fasta: for [Int], it performs O(n) seqs
08:20:22 <fasta> sjanssen: but those costs will be made anyway.
08:20:50 <fasta> sjanssen: I want to benchmark code.
08:20:52 <sjanssen> fasta: probably.  Definitely avoid using rnf twice on the same input
08:21:02 <vincenz> mycons isn't ideal
08:21:05 <fasta> sjanssen: (without printing it)
08:21:18 <olsner> what's rnf?
08:21:22 <fasta> sjanssen: since printing to terminal is rather slow.
08:21:28 <sjanssen> olsner: reduce to normal form
08:21:49 <olsner> is it the same as or different from seq?
08:21:52 <sjanssen> fasta: right, bechmarking is a good use for rnf
08:21:56 <sjanssen> olsner: different
08:22:00 <olsner> another name for deepSeq?
08:22:07 <sjanssen> olsner: yes, it's deepSeq
08:22:40 <hkBst> > foldl1 and [True]
08:22:42 <lambdabot>  Couldn't match expected type `[Bool] -> [Bool]'
08:24:00 <sjanssen> vincenz: what isn't ideal about mycons?
08:24:06 <quicksilver> hkBst: and is already folded
08:24:12 <quicksilver> hkBst: perhaps you meant (&&) ?
08:24:13 <sjanssen> vincenz: just the fact that you've got to use a different name?
08:24:17 <vincenz> sjanssen: never mind, I misread it
08:24:31 <vincenz> sjanssen: thoguht it was forcing the cons but not the element
08:24:33 <vincenz> my bad
08:25:12 <hkBst> quicksilver: ah, thanks :)
08:26:20 <fasta> How can I read the input for an IntMap from a file, create the IntMap and completely evaluate the IntMap and then do something else e.g. start a timer?
08:26:48 <sjanssen> rnf the input before starting the timer
08:27:02 <fasta> I.e. write an instance NFData IntMap ;)
08:27:12 <fasta> sjanssen: yes, that wasn't the problem.
08:27:25 <sjanssen> map <- evaluate $ rnf $ parseToIntMap blah
08:27:45 <sjanssen> @src IntMap
08:27:45 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:27:59 <fasta> sjanssen: what is evaluate?
08:28:23 <sjanssen> fasta: roughly equivalent to \x -> x `seq` return ()
08:28:29 <sjanssen> it's in Control.Exception
08:29:11 <sjanssen> fasta: IntMap is already key and spine strict, so you can just seq the elems
08:30:22 <fasta> sjanssen: I should do map (\elem -> elem `seq` ()) elems?
08:30:30 <fasta> sjanssen: elems map *
08:30:36 <sjanssen> rnf = IntMap.fold seq () -- should do the trick
08:31:09 <quicksilver> or rnf elems ?
08:31:18 <quicksilver> rnf = rnf . elems
08:32:23 <fasta> Why would evaluate $ parseToIntMap blah not work?
08:32:25 <sjanssen> fasta: "map (\elem -> elem `seq` ())" won't do the trick
08:32:37 <fasta> sjanssen: because the list is still lazy?
08:32:45 <sjanssen> fasta: correct
08:33:17 <sjanssen> fasta: because that's only strict in the keys and the spine
08:34:17 <fasta> Docs for evaluate say: "Forces its argument to be evaluated"
08:34:23 <fasta> Evaluated to what?
08:34:27 <sjanssen> fasta: seq
08:34:31 <sjanssen> WHNF
08:34:36 <fasta> Ok
08:49:41 <hkBst> is there a vector type?
08:50:05 <hkBst> something of arbitrary length with O(1) access to each element
08:50:15 <byorgey> hkBst: there are arrays
08:50:24 <sjanssen> hkBst: Data.Sequence
08:50:30 <byorgey> oh yeah, that too
08:50:59 <twanvl> Data.Sequence doesn't have O(1) random access
08:51:43 <Esteth> I'm following YAHT, but after trying out the roots function, i get a tuple pair of NaN instead of roots :S
08:52:09 <Shurique> you might have given it an equation with no solutions :)
08:52:21 <Shurique> (real solutions)
08:54:10 <Esteth> hmm. x^2 + 2x + 2 should have solutions? x = 1, x = 1
08:56:29 <conal> Igloo: ping
08:57:13 <Shurique> Esteth: nope, you get -4 as the discriminant
08:57:24 <quicksilver> Esteth: why don't you try it?
08:57:31 <quicksilver> Esteth: 1^2 + 2*1 + 2 = 5
08:57:34 <quicksilver> Esteth: that's not zero :)
08:57:36 <twanvl> > let x = 1 in x^2 + 2*x + 2
08:57:44 <lambdabot>  5
08:59:21 <Esteth> thought lapse. I assumed x^2 + 2x + 2 was solveable. doh!
08:59:25 <twanvl> > let x = (-1) :+ 1 in x^2 + 2*x + 2
08:59:27 <lambdabot>  0.0 :+ 0.0
09:00:13 <Igloo> conal: pong
09:01:04 <chessguy> @type (:+)
09:01:06 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
09:07:18 <gip> @t writeIORef
09:07:18 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:07:35 <gip> @type writeIORef
09:07:37 <lambdabot> Not in scope: `writeIORef'
09:08:04 <sjanssen> @hoogle writeIORef
09:08:04 <lambdabot> Data.IORef.writeIORef :: IORef a -> a -> IO ()
09:08:47 <conal> Igloo: thanks for the pointer to STABLE.   I guess I don't know what HEAD & STABLE mean.Â  I thought all the recent goodies were just in HEAD.Â  Is there a description somewhere of "head" vs "stable" somewhere?Â 
09:09:14 <quicksilver> I wish that the forbidden IO types were in-scope for @type even though they're obviously not for eval
09:09:18 <Philippa> presumably HEAD is "actively being hacked on" and STABLE is in some sense "known good"
09:09:46 <chessguy> @type Data.IORef.writeIORef
09:09:47 <lambdabot> forall a. GHC.IOBase.IORef a -> a -> IO ()
09:09:58 <quicksilver> ah! :)
09:11:43 <aivil> ciao a tutti
09:12:24 <byorgey> @babel it en ciao a tutti
09:12:25 <lambdabot>   hello to all
09:12:34 <byorgey> ciao aivil =)
09:13:16 <aivil> ciao byorgey
09:13:48 <aivil> buena noche a todo
09:14:18 <aivil> guter Abend zu allen
09:14:26 <gip> Bonne nuit aivil
09:15:13 <gip> What conditional construct should I use for IO monads?
09:15:18 <gip> it/then/else?
09:15:35 <quicksilver> yes, in most cases
09:15:48 <gip> thanks
09:16:00 <aivil> geht es wie das Leben?
09:16:33 <hkBst> aivil: genau, immer scheisse ;)
09:17:09 <aivil> ok
09:17:48 <byorgey> @type guard
09:17:53 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:17:59 <byorgey> @type when
09:18:01 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:19:05 <liyang2> if/then/else are a pain to lay out nicely. I prefer case / of.
09:19:23 <quicksilver> I've never found laying out if/then/else very hard
09:19:28 <fasta> When I build a doubly linked list in the ST monad and use it as elements in an IntMap, then how do I force the doubly linked list completely?
09:20:31 <liyang2> quicksilver: I may have more demanding aesthetic targets. :-/
09:20:39 <fasta> This is about the only part of Haskell that's opaque for me; there are no tools to see whether something got completely forced nor a good tutorial to "get the hang of it".
09:22:13 <quicksilver> liyang: I don't find an extra space before the 'then' and 'else' unaesthetic
09:22:29 <quicksilver> liyang: in fact, I find it rather appropriate
09:22:38 <quicksilver> liyang: mind you, I do quite like to use | instead
09:26:03 <gip> Can I write: when (test) do {...} ?
09:26:13 <quicksilver> you can indeed, yes
09:26:21 <Lemmih> gip: when test $ do ...
09:26:41 <quicksilver> that is the same thing as if (test) then do {...} else return ()
09:26:49 <quicksilver> but, if that is what you mean, then it is shorter
09:27:04 <byorgey> @src when
09:27:04 <lambdabot> when p s = if p then s else return ()
09:27:22 * osfameron was sure he'd had difficulty with if..then..else layout, but now can't recreate it...
09:28:19 <quicksilver> osfameron: the problem is when you line up the 'then' with the 'if' inside a layout block
09:28:35 <quicksilver> osfameron: that makes it start a new statement instead of being part of the old statement
09:29:16 <osfameron> quicksilver: yes, that must have been what I'd done.  The error message isn't very nice, but I agree that spacing the "then" is sensible
09:29:46 <quicksilver> osfameron: a workaround for the haskell parser has been suggested. I think it might even be inrecent ghces I'm not sure
09:30:15 <quicksilver> I very rarely have if/thens in the middle of do blocks though
09:30:23 <quicksilver> indeed, I very rarely have long do blocks at all
09:30:45 <quicksilver> I'm more likely to factor out the if/then, and then it's not in a do block and not layout sensitive anymoose
09:32:11 <byorgey> my if/thens are not layout sensitive to moose either.
09:33:17 * ddarius rarely has if-thens or long do-blocks.
09:39:36 <laz0r> i recently got into the habit of writing long do blocks when working with lists
09:41:23 <fasta> sjanssen: rnf returns a Done value, should I use it like this: let a = [1,2,3,4] in rnf a `seq` a ?
09:41:51 <sjanssen> `seq` (), I think
09:41:58 <sjanssen> type Done = () IIRC
09:42:17 <quicksilver> sjanssen: but presumably he wants the value to be a :)
09:42:18 <fasta> sjanssen: but I want to have the list returned
09:42:26 <sjanssen> oh, right
09:42:34 <sjanssen> then your code is correct
09:42:52 <fasta> sjanssen: and how about forcing ST monad structures?
09:43:10 <sjanssen> fasta: you'll have to do that monadically
09:43:22 <fasta> sjanssen: e.g. the typical doubly linked list implemented with links and a sentinel?
09:43:56 <sjanssen> fasta: hmm, how are you creating a mutable structure without fully evaluating it?
09:44:00 <ddarius> I would just force them as they were built.
09:44:16 <ddarius> sjanssen: The elements could be unevaluated.
09:44:21 <sjanssen> oh, of course
09:44:24 <fasta> sjanssen: I am not saying I am not. I don't know what GHC exactly does when I evaluate ST actions ;)
09:44:45 <fasta> sjanssen: and indeed the elements are probably not evaluated.
09:45:00 <dons> morning all.
09:45:02 <sjanssen> fasta: hopefully you've defined some kind of traversal function?
09:45:15 <fasta> sjanssen: yes. I have.
09:46:13 <sjanssen> fasta: then it should just be a matter of traversing the list and seqing the contents
09:47:07 <fasta> sjanssen: but suppose I have do a <- readValue cell, how do I force the a?
09:47:08 <sjanssen> fasta: I think ddarius has good advice here
09:47:20 <dons> ?users
09:47:20 <lambdabot> Maximum users seen in #haskell: 402, currently: 390 (97.0%), active: 14 (3.6%)
09:47:23 <quicksilver> fasta: ghc does nothing special when you execute an ST action
09:47:31 <sjanssen> fasta: you'll need an equivalent to 'evaluate' for the ST monad
09:47:34 <quicksilver> ST actions (and IO actions) are not special w.r.t to forcing
09:47:49 <quicksilver> just like any other construct in haskell they force only what they need
09:47:51 <sjanssen> stEvaluate x = x `seq` return () -- should work
09:51:49 <fasta> Still, even if I have written the correct code, there is no way for me to verify that I have.
09:52:15 <fasta> Other than putting (repeat []) in data structures.
09:52:20 <fasta> I.e. trial and error.
09:52:23 <quicksilver> depends what you're trying to verify I suppose
09:52:30 <quicksilver> surely you verify correct code by tests?
09:52:39 <quicksilver> and lazy evaluation doesn't harm the ability to run tests.
09:53:00 <quicksilver> if the crux is that you're trying to evaluate performance rather than correctness
09:53:12 <quicksilver> then it's not normally that hard to build sensible examples to test performance on
09:53:20 <fasta> quicksilver: I mean correct code w.r.t. evaluating before I need too.
09:53:22 <fasta> to*
09:53:23 <gip> @type when
09:53:25 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:53:38 <quicksilver> fasta: you may be interested in teh techniques than dons and dcoutts_ have used to test strictness
09:53:40 <gip> @index when
09:53:40 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:53:47 <quicksilver> fasta: I"m not familiary with it myself, I'm afraid
09:53:56 <fasta> quicksilver: dons told me about it a bit.
09:54:01 <quicksilver> fasta: I believe they used it to check for accidental over-strictness in bytestring
09:54:19 <quicksilver> ah, good
09:54:23 <fasta> Ok, suppose I have a data Foo = Foo Int Int. How do I write rnf for this type?
09:54:49 <sjanssen> fasta: rnf (Foo x y) = x `seq` y `seq` ()
09:55:27 <sjanssen> actually, it's more consistent to write rnf (Foo x y) = rnf x `seq` rnf y
09:55:28 <dcoutts_> quicksilver: accidental over (or under) strictness in our reimplementation of the list library actually
09:55:46 <fasta> sjanssen: that last solution is indeed what I had in mind.
09:55:48 <dons> dcoutts_: we should write this stuff up
09:55:49 <gip> Why can i not use _ as a pattern in a case of construct?
09:55:52 <dons> and put it on hackage
09:55:52 <dcoutts_> quicksilver: since we know that bytestring is stricter in many cases, just due to the data representation being stricter
09:55:59 <dcoutts_> dons: I should put it in my thesis :-)
09:56:08 <dons> dcoutts_: good idea!
09:56:11 <dcoutts_> @arr!
09:56:11 <lambdabot> Avast!
09:56:14 <quicksilver> gip: you can
09:56:30 <leonid> @type sum
09:56:32 <lambdabot> forall a. (Num a) => [a] -> a
09:56:33 <quicksilver> > let f n = case n of _ -> "foo" in f 1
09:56:36 <lambdabot>  "foo"
09:56:41 <quicksilver> gip: ta-da!
09:56:45 <leonid> @"foo"
09:56:45 <lambdabot> Unknown command, try @list
09:56:56 <sjanssen> fasta: DrIFT can derive these instances, btw
09:57:05 <leonid> @print "foo"
09:57:05 <lambdabot> Not enough privileges
09:57:12 <gip> quicksilver: ta-da ?? What does that mean?
09:57:17 <gip> :)
09:57:45 <leonid> >
09:57:46 <quicksilver> gip: "and there you are, you see!"
09:57:57 <quicksilver> gip: it's a transcription of a trumpet sound
09:58:02 <Apocalis1> voila!
09:58:14 <quicksilver> gip: as used in circuses etc
09:58:31 <gip> Ok, I'm a bit deaf, sorry :)
09:58:49 <gip> doesn't work here :(
09:59:13 <sjanssen> gip: it's probably an error elsewhere in your code?  can you paste the whole thing?
09:59:18 <sjanssen> @paste
09:59:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:00:03 <gip> ARGGGGGG it was an indent issue. This *feature* is really boring! Thanks anyway.
10:01:40 <Apocalis1> I'm looking for a data structure that is an unordered set of heterogeneous name-value pairs (i.e. the types of values are not the same), indexed by name. Is there such a thing implemented somewhere?
10:02:28 <quicksilver> Apocalis1: short-answer, no
10:02:36 <Apocalis1> :-(
10:02:41 <quicksilver> Apocalis1: alternative short answer, try Map String Dynamic
10:03:20 <quicksilver> Apocalis1: annoyingly smug answer: I really don't think that's what you want to do. Types are there to help you. Hetergeneous collections are normally bad design.
10:03:35 <ClaudiusMaximus> Apocalis1: i would create a new type that tags all the types you plan to use, like data Foo = FooInt Int | FooFloat Float | ...  and use Map String Foo but that only works if you know all the types before hand
10:03:59 <Apocalis1> what I really want is an unordered set of triples (name, type, value).
10:05:57 <quicksilver> Apocalis1: Map String Dynamic then
10:06:05 <quicksilver> Apocalis1: dynamics implicitly have their types
10:06:22 <quicksilver> Apocalis1: although I maintain my reservations about whether this is likely to be good design :)
10:06:48 <sjanssen> Apocalis1: isn't your usual nick Apoca _lisp_ ?
10:07:07 <sjanssen> Apocalis1: you must recant your dynamicly typed ways! :P
10:07:11 <Apocalis1> Looks like that's already taken
10:07:35 <Apocalis1> sjanssen: I want to be convinced!
10:08:10 <gip> Any way to write elegantly: f (x:xs) = case x of '0' -> [x]++f xs    '1' -> [x]++f xs     _ -> f xs                  ??
10:08:27 <Philippa> Apocalis1: short answer - you can't do that, types aren't terms
10:08:35 <sjanssen> Apocalis1: can you describe what you want to achieve with this heterogenous map?  Perhaps we can find a more Haskell-ish solution
10:08:47 <Philippa> longer answer: Haskell-level type, or domain-level type?
10:09:25 <Apocalis1> Philippa: Ah-hah. Domain-level it is.
10:09:34 <quicksilver> gip: f ('0':xs) = '0':f xs ; f ('1':xs) = '1':f xs ; f (x:xs) = f xs ?
10:09:35 <gip> Man, it works here
10:09:48 <sjanssen> gip: f (x:xs) | not (x `elem` "01") = f xs; | otherwise = x : f xs
10:10:12 <Philippa> Apocalis1: right, ClaudiusMaximus's solution's effectively equivalent, you'll have to pattern-match on the type to get the value out but that makes sure you always know what you're dealing with
10:10:43 <gip> quicksilver, sjanssen : thanks, looks indeed good.
10:10:53 <Apocalis1> That's not a bad idea. Although I do want to be able to support user-created types.
10:11:07 <quicksilver> Apocalis1: if you have domain-level types, then you have some (haskell) type 'Entity' which represents all possibilities (I imagine)
10:11:23 <quicksilver> Apocalis1: and you're likely to want a function 'myTypeOf :: Entity -> ApocaType'
10:11:28 <Philippa> presumably user-created types're built with some algebra over a bunch of primitives?
10:11:29 <quicksilver> and so on
10:12:25 <Philippa> in which case you can have eg data Value = VInt Int | ... | Record [(FieldName, Value)]
10:12:33 <beelsebob> Does anyone have a good reference for graph reduction based functional language implementations
10:13:29 <Nafai> beelsebob: Wjat
10:13:31 <Nafai> Er
10:13:37 <Nafai> beelsebob: What's "graph reduction based"?
10:13:46 <Philippa> beelsebob: SPJ's book, the G machine paper and references from each?
10:14:12 <beelsebob> Philippa: hmm, I guess so, but the G machine is a rather complex implpmentation of graph reduction, no?
10:14:55 <beelsebob> Nafai: implementations of functional languages that are based on creting graphs of expressions and reducing them
10:15:06 <dons> dcoutts_: you have a tshirt size, btw?
10:15:30 <Nafai> beelsebob: Interesting
10:16:05 <beelsebob> Nafai: of note, GHC's implementation of Haskell is based on the STG machine (the spineless tagless Graph machine
10:16:16 <Philippa> beelsebob: chase the reference chain :-)
10:16:22 <beelsebob> Philippa: fair enough
10:16:34 <beelsebob> was wondering if someone had a nice "original" reference
10:16:35 <Philippa> the G machine's more "obvious" than STG, at least
10:16:47 <beelsebob> or a good review of such things
10:16:51 <beelsebob> Philippa: true indeed
10:16:59 <beelsebob> the STG machine boggled my mind for a long time
10:17:23 <beelsebob> not sure I've managed to understand it yet either
10:17:29 <Philippa> STG makes more sense if you already grok ANF
10:18:26 <hpaste>  fasta pasted "Strictness doubly linked list" at http://hpaste.org/2673
10:19:09 <bos> @seen ddarius
10:19:09 <lambdabot> I saw ddarius leaving #haskell-blah, #haskell-overflow and #haskell 16m 24s ago, and .
10:19:55 <fasta> sjanssen: any idea why it stops working when I remove the unsafePerformIO?
10:20:06 <fasta> sjanssen: i.e. in that case it does terminate.
10:20:10 <gip> How would you write a function that inserts an element to a list every n elements?
10:20:38 <fasta> gip: are you asking for perfectness or something that works?
10:21:19 <sjanssen> fasta: presumably value == _|_
10:21:27 <gip> fasta: something elegant
10:21:39 <fasta> sjanssen: yes, value is bottom
10:22:01 <fasta> sjanssen: the intention is that it should not terminate
10:22:04 <gip> I'm doing it with take and reverse at the moment, it's not nice
10:22:06 <sjanssen> fasta: unsafePerformIO (print value) is therefore also _|_, because executing print on _|_ is _|_
10:22:31 <Lemmih> gip: Split the list into pieces of n and concat with intersperse.
10:22:41 <fasta> sjanssen: oh, I see the problem.
10:22:42 <sjanssen> fasta: however, 'print _|_' alone isn't _|_, it's just an action that will fail when executed
10:22:48 <dons> http://programming.reddit.com/info/2nt8a/comments
10:22:49 <lambdabot> Title: The Monad Reader Magazine, Issue 8: Generating Multiset Partitions, Type-Level I ...
10:22:51 <fasta> sjanssen: no, that's not what I meant.
10:22:53 <dons> get your TMR!
10:22:54 <gip> @t split
10:22:54 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:23:04 <gip> @type split
10:23:06 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
10:23:12 <fasta> sjanssen: the problem is that seq on the value doesn't turn it into rnf.
10:23:35 <fasta> sjanssen: it only evaluates a tiny bit of the spine of the list.
10:23:47 <fasta> sjanssen: I should replace it with rnf
10:24:10 <oerjan> :t splitAt
10:24:12 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:24:44 <fasta> sjanssen: hmm, that's still not enough
10:25:01 <sjanssen> fasta: does "let !_ =" actually work?
10:25:15 <iguana_> @src splitAt
10:25:15 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
10:25:22 <fasta> sjanssen: yes
10:25:32 <fasta> sjanssen: It's an idiom I found out some time ago.
10:25:48 <sjanssen> that's a bit evil
10:26:40 <oerjan> takeWhile (not . null) . unfoldr (Just . splitAt 4) $ "testing ho"
10:26:46 <oerjan> > takeWhile (not . null) . unfoldr (Just . splitAt 4) $ "testing ho"
10:26:49 <lambdabot>  ["test","ing ","ho"]
10:27:09 <hpaste>  fasta annotated "Strictness doubly linked list" with "Attempt 2 still failing" at http://hpaste.org/2673#a1
10:27:34 <oerjan> > concat . intersperse "," . takeWhile (not . null) . unfoldr (Just . splitAt 4) $ "testing ho"
10:27:35 <lambdabot>  "test,ing ,ho"
10:27:59 <fasta> sjanssen: I would really expect that the infinite list would be evaluated now, but test_strictness still returns with 1.
10:29:26 <Lemmih> fasta: (rnf value) is never executed.
10:29:34 <hpaste>  sjanssen annotated "Strictness doubly linked list" with "does this work?" at http://hpaste.org/2673#a2
10:30:10 <twanvl> Why not use evaluate?
10:30:20 <sjanssen> twanvl: ST monad
10:30:23 <twanvl> ah
10:30:33 <dons> swiert: great TMR issue :) love the editorial
10:30:47 <fasta> sjanssen: it does.
10:30:58 <sjanssen> fasta: do you understand why?
10:31:08 <fasta> sjanssen: moment
10:31:28 <oerjan> :t evaluate
10:31:30 <lambdabot> Not in scope: `evaluate'
10:31:35 <oerjan> @src evaluate
10:31:35 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
10:31:51 <oerjan> is there any reason why that isn't defined for ST as well?
10:32:20 <sjanssen> oerjan: it certainly could be
10:32:25 <Igloo> I can't think of a reason
10:32:56 <sjanssen> oerjan: it's more useful in the IO monad, because you can catch exceptions raised by the evaluation
10:33:07 <oerjan> ic
10:33:59 <fasta> sjanssen: mapM_ does not care for the return value?
10:34:08 <sjanssen> fasta: exactly
10:34:16 <puusorsa> http://www.teslamotors.com/
10:34:18 <lambdabot> Title: Tesla Motors
10:34:19 <oerjan> btw, would return $! rnf value work?
10:34:33 <sjanssen> oerjan: yes
10:35:12 <oerjan> that might work in many (but probably not all) monads
10:35:48 <oerjan> since some might not even look at the final return
10:36:05 <oerjan> (as in action, not value)
10:36:52 <fasta> What is (# and #) in  (# s, a #)?
10:36:58 <oerjan> unboxed tuple
10:36:58 <sjanssen> fasta: unboxed tuple
10:37:23 <sjanssen> oerjan: it will work in all monads where (>>=) is strict in the first argument
10:37:28 <fasta> When I intend to use something unboxed, is it better to use those?
10:37:32 <liyang> quicksilver: I've no problem with ocassional single-line if/then/elses; it's when they need to span several lines (esp. with monadic syntax) that if/then/else looks ugly. Much nicer to write with case/of instead, when you need to go multi-line. The problem with using | guards is that the compiler can't warn you about missing cases... (but yes, it does sometimes makes things look nicer.)
10:37:37 <fasta> Or should I just go for portable code?
10:37:50 <fasta> Or will H' include unboxed tuples?
10:38:02 <sjanssen> fasta: they'll cause more trouble than they're worth, most likely
10:38:23 <oerjan> sjanssen: unless there is something earlier than the return
10:39:19 <oerjan> fasta: i think the option -unbox-strict-fields is commonly used for datatypes
10:39:40 <oerjan> but it may not unbox the _whole_ value, just the fields
10:39:57 <oerjan> *-funbox-strict-fields i guess
10:40:12 <puusorsa> fun-box!
10:41:55 <Apocalisp> Thanks for the help. I have a better idea about how to implement this sort of thing in Haskell now.
10:44:11 <Apocalisp> Any haskell-specific literature on implementing strongly typed compilers?
10:44:40 <fasta> Apocalisp: EHC?
10:44:46 <Philippa> I don't know of much. You can start with literature aimed at ML though, and a lot of Scheme stuff ports
10:45:11 <Philippa> compiler for a strongly-typed language, or a compiler that's as strongly-typed as possible? The latter's still something of a research effort
10:46:38 <Apocalisp> A compiler for a strongly-typed language.
10:47:43 <Philippa> most of it's steady application of the same old same old - you'll find monads are very much your friend, for example, and you'll have algebraic datatypes everywhere
10:49:08 <Apocalisp> not unexpectedly
10:49:27 <CosmicRay> does anyone use quickcheck to test stuff in the IO monad or is it pure only?
10:50:07 <fasta> CosmicRay: shapr says QuickCheck2 can do that.
10:50:14 <fasta> CosmicRay: I only used it for pure stuff.
10:51:01 <fasta> I think it's better if someone would write something that is not just research, but that's actually used and then releases that.
10:51:30 <CosmicRay> I have always used hUnit in the past but I find quickcheck interesting
10:51:50 <CosmicRay> I wonder, though, if it knows as much about corner cases as I do
10:52:12 <CosmicRay> for instance, when testing functions that work on lists, will it always make sure to test it on lists of length 0, 1, and 2, in addition to longer ones?
10:52:41 <sjanssen> CosmicRay: you might check out SmallCheck
10:52:59 <fasta> CosmicRay: In my experience a combination of SmallCheck and QuickCheck work very good.
10:53:07 <fasta> CosmicRay: that is when it is pure code.
10:53:38 <CosmicRay> most of my stuff for this particular project is pure
10:53:42 <CosmicRay> but not all
10:53:57 <CosmicRay> some parts are specificall I/O utilities and thus cannot be pulled out of the I/O monad
10:54:27 <fasta> @src State#
10:54:28 <lambdabot> Source not found. My mind is going. I can feel it.
10:55:08 <oerjan> @src IO
10:55:09 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
10:55:58 <oerjan> @src ST
10:55:59 <lambdabot> newtype ST s a = ST (STRep s a)
10:56:05 <oerjan> @src STRep
10:56:06 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
10:56:11 <beelsebob> gyargh!
10:56:16 <beelsebob> fucking journals
10:56:44 <beelsebob> anyone able to get hold of an online copy of "A new implementation technique for applicative languages" by David Turner?
10:57:29 <oerjan> @index State#
10:57:29 <lambdabot> bzzt
10:57:39 <oerjan> @index STRep
10:57:39 <lambdabot> bzzt
10:57:42 <oerjan> @index ST
10:57:43 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
10:59:11 <fasta> sjanssen: Ok, I now also implemented ddarius technique, but I wonder whether it will be completely strict now, since the strict st monad has also still some lazyness. My test_strictness works on it, however. It's difficult to express what exactly I want to know.
10:59:20 <Apocalisp> puusorsa: Wow, this is the first e-car that I've actually wanted.
11:18:37 <smoofra> is it possible declare duplicate instances and have the compiler decide which one to use based on a some kind of precedence rule?
11:19:30 <oerjan> smoofra: overlapping instances, where the most precise one is chosen
11:19:55 <fasta> How fast is DrIFT? Is it noticable when compared to what GHC does to a source file?
11:20:04 <oerjan> there's a ghc option for it
11:37:29 <fasta> Is drift-ghc in Debian very old? It doesn't even have a --help flag.
11:38:37 <fasta> Never mind
11:39:01 <smoofra> oerjan: you can't explicitly specify a precedence though?
11:39:25 <oerjan> smoofra: not that i know of
11:39:38 <oerjan> not that i know too much about this either
11:48:43 <fasta> How can I simply call two preprocessors on the GHC command line? If I know how to run cpphs and then cat it would already be fine.
11:49:10 <fasta> I already know the option to call one preprocessor. The only thing that matters is the combination.
11:49:18 <fasta> Simply piping it doesn't appear to work.
11:51:54 <dons> Heffalump: around?
11:52:28 <oerjan> fasta: write a script to run the pipe?
11:52:38 <fasta> oerjan: yes, already considered that.
11:52:47 <fasta> oerjan: I always like the difficult solution ;)
11:55:41 <oerjan> "Additional arguments to the pre-processor can be passed in using the -optF option"
11:58:34 <oerjan> fasta: it seems like -cpp and -F can be combined
12:00:19 <fasta> oerjan: heh, I considered that too. It now appears to work with cat
12:00:41 <oerjan> but it seems like -F may be awkward to use without making a script, because of argument passing
12:00:42 <fasta> oerjan: the drift-ghc script however is "ambiguous"
12:01:10 <fasta> oerjan: argument passing can be done with -opt<something>
12:01:20 <fasta> oerjan: but indeed a separate script is better
12:01:36 <oerjan> i mean the three arguments that are _always_ passed, and may not be in the right place or format
12:09:09 <Heffalump> dons: am now
12:20:29 <sorear> JaffaCake++  FIX #903: mkWWcpr: not a product
12:24:17 <sjanssen> sorear: what's the significance of that bug?
12:24:26 <newsham> unzip . map (head && length) . group . sort
12:24:27 <newsham> nice
12:24:35 <sorear> sjanssen: it prevents GHC itself from being cabalized
12:24:48 <newsham> > (unzip.map (head&&length).group.sort) "testing"
12:24:50 <lambdabot>  Couldn't match expected type `Bool'
12:25:01 <sjanssen> sorear: I think you (or JaffaCake) mean #930
12:25:02 <newsham> > (unzip.map (head&&&length).group.sort) "testing"
12:25:03 <lambdabot>  ("eginst",[1,1,1,1,1,2])
12:25:04 <sorear> sjanssen: now that it's fixed, fptools can die
12:27:07 <newsham> caballed (ie. "cobbled") sounds cooler than "cabalized"
12:28:56 <newsham> > concat $ zipWith replicate "eginst" [1,1,1,1,1,2]
12:28:57 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
12:29:16 <newsham> > concat $ zipWith replicate [1,1,1,1,1,2] "eginst"
12:29:18 <lambdabot>  "eginstt"
12:33:24 <Adkron> sorry about this guys
12:33:51 <fasta> Somebody shoot Adkron ;)
12:34:00 * Zao grabs /bin/tar and feathers.
12:34:11 <newsham> ?seend adkron
12:34:12 <lambdabot> adkron is in #haskell. I last heard adkron speak 45s ago.
12:35:08 <EvilTerran> CTCP AWAY? wtf is that?
12:35:41 <EvilTerran> and why would someone join just to send it?
12:35:50 <EvilTerran> ...and apologise first?
12:36:08 <EvilTerran> Â¯\(Âº_o)/Â¯
12:36:11 <newsham> obviously a degenerate spammer perl programmer
12:36:17 <pastorn> dÃ¶h eÃ¶yya -p oyÃ¶nnab orm otpckÃ¶p mÃ¶e Ã¶yy ekrpatcboy-nny yabiÃ¶byxrpe
12:36:25 <wli> Permaban the /16 and get it over with.
12:36:43 <EvilTerran> why perl?
12:36:54 <wli> And what would tar(1) be doing in /bin/ anyway? Should be /usr/bin/
12:37:07 <sorear> wli: system recovery?
12:37:13 <EvilTerran> I agree with the "degenerate spammer" part, but the "perl programmer" bit just looks like an opportunistic dig
12:37:49 <wli> They seem morally equivalent to me.
12:38:29 <EvilTerran> ...
12:38:29 <newsham> evilterran: are you now or have you ever been a member of the perl users group?
12:38:42 <EvilTerran> I use perl quite heavily, yes.
12:38:50 <sjanssen> s/perl users group/communist party
12:38:58 <EvilTerran> that too, sjanssen ;]
12:40:12 <newsham> ?blacklist add evilterran
12:40:12 <lambdabot> Unknown command, try @list
12:40:39 <sorear> Adkron: hhm, what was that earlier?>
12:40:40 <sorear> @bot
12:40:40 <lambdabot> :)
12:40:46 <sorear> Adkron: ours is perfectly health
12:40:48 <sorear> +y
12:41:32 <EvilTerran> newsham, wli: i thought #haskell was famous for its tolerance of the misguided. I guess i was mistaken...
12:41:43 <oerjan> sorear: well, sometimes she needs to lie down a bit
12:42:22 <newsham> evil: just kidding w/ you
12:42:32 <newsham> man, I didnt even call you french yet.
12:46:16 <roconnor> @hoogle realfrac
12:46:17 <lambdabot> Prelude.RealFrac :: class (Real a, Fractional a) => RealFrac a
12:46:27 <roconnor> @hoogle realToFrac
12:46:28 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
12:51:33 <EvilTerran> don't worry, i was just playing along, anyway
12:51:43 <fasta> DrIFT: ***Error: no DrIFT directives found
12:51:53 <fasta> Anyone using DrIFT?
12:57:03 <sorear> JohnMeacham even fixed the repository?
12:57:06 <sorear> @seen JohnMeacham
12:57:06 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. I don't know when JohnMeacham last spoke.
12:57:39 <fasta> sorear: referring to DrIFT?
12:57:47 <sorear> yes.
12:57:52 <fasta> sorear: this is the Debian version
12:58:08 <fasta> sorear: is it fixed in darcs?
12:58:27 <sorear> fasta: you can't even download darcs
12:59:00 <fasta> sorear: ?
12:59:10 <fasta> sorear: I just did
12:59:19 <fasta> sorear: darcs get http://repetae.net/john/repos/DrIFT
12:59:21 <lambdabot> Title: Index of /john/repos/DrIFT
12:59:46 <sorear> great
12:59:54 <sorear> I didn't expect he'd ever fix the repo
13:00:37 <fasta> sorear: do you know anything about the error I encountered?
13:00:59 <sorear> No.
13:02:19 <fasta> sanitycheck [] = error "***Error: no DrIFT directives found\n"
13:02:35 <fasta> Very smart idea....
13:04:03 <JohnMeacham> sorear: should be fyxed.
13:04:07 <JohnMeacham> or fixed.
13:05:44 <fasta> JohnMeacham: applying DrIFT to a file containing no DrIFT commands generates an error. What's the recommended way to use DrIFT when one has multiple files where some do use DrIFT and some do not?
13:09:15 <JohnMeacham> fasta: it should not do so.
13:09:54 <JohnMeacham> fasta: I just use the options "-pgmF drift-ghc -F" as arguments to ghc and it all just magically works.
13:10:18 <fasta> JohnMeacham: I also use cpphs
13:10:24 <fasta> JohnMeacham: maybe that's the problem?
13:11:14 <JohnMeacham> hmm.. chances are something is getting in there that is confusing the parser, which doesn't recover well from errors. I should switch to to a frisby parser or something else more robust.
13:11:42 <JohnMeacham> does it work if you add a stub deriving directive?
13:12:14 <fasta> JohnMeacham: ok, now it seems to work magically here too.
13:12:39 <JohnMeacham> yay!
13:12:47 <JohnMeacham> magic.
13:12:49 <fasta> JohnMeacham: I.e. I haven't actually used any DrIFT command yet, but with zero commands it works.
13:22:11 <paolino> @hoogle (a -> Bool) -> a -> Maybe a
13:22:12 <lambdabot> No matches, try a more general search
13:23:00 <Heffalump> @djinn (a -> Bool) -> a -> Maybe a
13:23:00 <lambdabot> f a b =
13:23:00 <lambdabot>     case a b of
13:23:00 <lambdabot>     False -> Nothing
13:23:00 <lambdabot>     True -> Just b
13:24:08 <paolino> eh
13:24:12 * Igloo should look into how djinn works some time. I wouldn't have thought it would have come up with that
13:24:52 <Heffalump> Igloo: it uses a decision procedure for first-order logic. According to Lennart's talk about it, it's not trivial to find a fast one, so it's probably not trivial to understand what it does either.
13:24:53 <EvilTerran> it tries to come up with an implementation where the requested type is the most general possible for that implementation, isn't it?
13:24:54 <paolino> \pl \a b -> (>>= a) . (>>= b)
13:25:14 <paolino> @pl \a b -> (>>= a) . (>>= b)
13:25:15 <lambdabot> (. (=<<)) . (.) . (=<<)
13:25:24 <Igloo> Fair enough  :-)
13:25:29 <EvilTerran> so, for that one, it'd have to return something different in each branch, otherwise the branch'd be superfluous
13:26:04 <Heffalump> @djinn (a -> b) -> a -> b
13:26:05 <lambdabot> f a = a
13:26:10 <Heffalump> @djinn a -> a
13:26:11 <lambdabot> f a = a
13:26:15 <EvilTerran> and in order to branch given only an a and a Bool is by patternmatching on the Bool, but the only place it can actually get that bool is my applying the first param to the second
13:26:18 <Heffalump> EvilTerran: if it does, it doesn't try very hard :-)
13:26:22 <ari> @. djinn type (.)
13:26:28 <lambdabot> f a b c = a (b c)
13:26:34 <paolino> @pl \a b -> iterate $ (>>= a) . (>>= b)
13:26:34 <lambdabot> (iterate .) . (. (=<<)) . (.) . (=<<)
13:26:49 <EvilTerran> Heffalump, is anything other than identity or const _|_ possible for that first one, tho?
13:26:53 <ari> So, when will @src be replaced with @. djinn type? :p
13:27:06 <Igloo> EvilTerran: f a b = a b
13:27:23 <EvilTerran> eh, true. tighter typed id.
13:28:14 <oerjan> :t join (.)
13:28:16 <lambdabot> forall b. (b -> b) -> b -> b
13:28:27 <oerjan> bah
13:31:13 <oerjan> @pl \p a -> guard (p a) >> return a
13:31:14 <lambdabot> (`ap` return) . (((>>) . guard) .)
13:33:50 <gpi5> Looks like I cannot match a rational by a%b in a pattern. Any other way ?
13:34:43 <Igloo> a :% b, if it's exported
13:35:50 <gpi5> @index :%
13:35:51 <lambdabot> bzzt
13:35:57 <monochrom> It is not exported.
13:36:02 <gpi5> @type :%
13:36:04 <lambdabot> parse error on input `:%'
13:36:11 <monochrom> use "numerator" and "denominator"
13:36:38 <gpi5> Yes, but would be easier in a pattern. Thx anyway
13:37:22 <monochrom> f r = n + m where {n = numerator r; m = denominator r} is an acceptable substitute.
13:39:39 <EvilTerran> could write numDen = numerator &&& denominator for terseness; indeed, could approximate patterns with pattern guards.
13:39:56 <oerjan> > let numDen = numerator &&& denominator in numDen (2%3)
13:40:02 <lambdabot>  (2,3)
13:40:16 <EvilTerran> > f x | (1,2) <- numDen x = ... | (2,3) <- numDen x = ...; ...
13:40:17 <lambdabot>  Parse error
13:40:27 <gpi5> @index numerator
13:40:28 <lambdabot> Data.Ratio
13:40:34 <oerjan> EvilTerran: darn, you beat me to it
13:41:14 <EvilTerran> oh. i thought you'd just copied that defn from me to demo it. that's uncanny. O.o
13:41:45 <oerjan> although i was inspired by someone just mentioning &&& for something similar in haskell-cafe :)
13:41:46 <EvilTerran> this is also a place where views would be good
13:42:20 <EvilTerran> instance View (Ratio a) (a,a) where view = numerator &&& denominator; ...; f (->(1,2)) = ...
13:43:07 * EvilTerran is still vaguely amused by the type that "f (->x) = ..." would get
13:43:42 <EvilTerran> (View a v => a -> ..., ie "anything that can be viewed", assuming it didn't get made any more specific in the body)
13:45:29 <gpi5> How do I convert Integer to Int?
13:45:45 <dons> fromIntegral
13:45:54 <sior|away> haha
13:46:09 <byorgey> @type fromIntegral
13:46:10 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:46:11 <sior|away> fromIntegral (6000000000000 :: Integer) :: Int
13:46:18 <sior|away> > fromIntegral (6000000000000 :: Integer) :: Int
13:46:19 <lambdabot>  -69312512
13:46:28 <sior|away> can we just put that answer in the topic, pls?
13:46:33 <dons> :)
13:46:37 <byorgey> thus, "fromIntegral" is the answer to the question, "How do I convert * to _?", where * is an Integral type
13:47:02 <oerjan> unless _ is an Enum
13:47:24 <sior|away> or have lambdabot just answer it every time "convert" appears in chat
13:47:24 <byorgey> you're right, I should add "and _ is any Num type"
13:48:56 <oerjan> > 1e10000000000000000000000 -- sorry, just have to try
13:49:00 <lambdabot>  ghc: failed with error code 9
13:49:45 <wincent> @src replicate
13:49:45 <lambdabot> replicate n x = take n (repeat x)
13:49:58 <monochrom> "Avoid success at all cost." Heed the old man's wisdom. We are now too successful, and look at the consequence: people ask us about numeric conversion all day long.
13:50:12 <wincent> @src take
13:50:12 <lambdabot> take n _      | n <= 0 =  []
13:50:13 <lambdabot> take _ []              =  []
13:50:13 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:50:27 <wincent> @src repeat
13:50:27 <lambdabot> repeat x = xs where xs = x : xs
13:50:29 <monochrom> (The other question is: why don't tutorials tell them already?)
13:50:37 <sorear> right, we should ban people immediately for asking that
13:50:40 <sorear> ops?
13:50:59 <byorgey> hehe
13:51:05 <njbartlett> Hey, it's battle of the trolls over on programming.reddit today
13:51:20 <monochrom> No, we use either (A) ban people who make us successful; or (B) ban people who write tutorials and not include numeric conversions. :)
13:51:51 <njbartlett> In one thread there's a series of comments by qwe1234 and slava_pestov that are all hidden from so many downmods. I didn't know trolls could feed each other.
13:51:53 <Tac-Work> The arrangement of my bits is superior to the pathetic arrangement of you bytes
13:52:11 <monochrom> We bytes.
13:52:22 <oerjan> byte me!
13:52:25 <monochrom> Err, but we don't byte!
13:52:44 <Tac-Work> Your bytes don't make a bit of sense!
13:52:46 <oerjan> just a bit?
13:52:50 <Heffalump> bastard filters at work have blocked reddit :-(
13:52:51 <monochrom> "Come on in, learn Data.Binary, we don't byte!"
13:53:13 <Tac-Work> what a lie!
13:53:31 * Heffalump has been making a .pdb reader and writer
13:53:45 <monochrom> "Char supports Unicode --- because we don't byte!"
13:54:06 <njbartlett> Heffalump: No reddit at work? Damn, maybe you'll actually have to work then... ;-)
13:54:09 <newsham> heffalump: isnt that thing basically an entire filesystem?
13:54:12 <Tac-Work> Why do they call them "Monads"? Because every time some tries to learn how they work, they react the same way they would to a stray football to the groin, "ack! monads!"
13:54:44 <Tac-Work> someone*
13:54:50 <Tac-Work> wow my typing is off today
13:54:56 <monochrom> It's ok.
13:55:01 <Tac-Work> maybe I should do work or something X-D
13:55:25 <Heffalump> newsham: not really, though most of the structure is specific to particular types of data, so a generic PDB reader doesn't do all that much
13:55:43 <Heffalump> njbartlett: hah, I've submitted a business case for unblocking it!
13:56:21 <gpi5> Disclaimer: I didn't read the tutorials. And if this IRC channel would not exist, I would have given up haskell long ago..
13:56:37 <gpi5> Haskell doc is too complex and sucks
13:56:43 <Tac-Work> Haskell actually has quite a few good tutorials out there
13:56:47 <Tac-Work> but haddock does suck just a bit
13:57:21 <Philippa> haddock itself isn't too bad (though it's got some conventions I don't like) - but it's not sufficient for a lot of libs unless some real work goes into it
13:57:36 <Tac-Work> Docs should be written by hand. If you don't take time separately to explain your API, then you'll end up the only user
13:57:38 <Philippa> and even then, often it's not perfect
13:58:05 <Philippa> certainly an overview needs to be written by hand
13:58:34 <njbartlett> And the overview should not just be a link to a paper published in 1993
13:59:11 <Philippa> not in the long run, no. Unfortunately that sort of thing's often necessary to get a first release out of the door
13:59:13 <monochrom> Does anyone ever expect that English dictionaries teach you English? Does anyone expect that library docs teach you Haskell?
13:59:15 <njbartlett> Where the API no longer remotely resembles the API described in the paper...
13:59:29 <gpi5> I'm sure they are few good tutorials. But haskell is complex and you start learning when you actually program..
13:59:49 <Philippa> monochrom: there's this thing called domain knowledge, you may've heard of it?
13:59:50 <gpi5> And without this channel you spend hours browsing the docs
13:59:59 <monochrom> Yes Philippa.
14:00:42 <monochrom> There is no conflict between "tutorials" and "actually program". In fact some tutorials force you to actually program.
14:00:44 <newsham> learning haskell is an exercise in finding and reading academic articles
14:01:18 <Philippa> yeah, it should be less so - "textbook" material is a good thing
14:01:19 <Tac-Work> Haskell is *not* a good learn-by-doing language
14:01:20 <gpi5> monochrom: I don't think so. Tutorial is like a holliday destination.
14:01:25 <monochrom> The thing is if you look at docs and say they aren't organized around teaching, well you're barking up the wrong doc.
14:01:26 <Philippa> Tac-Work: depends
14:01:36 <roconnor> is there a priority queue in the libraries?
14:01:44 <monochrom> Dude, look for "Scheme in 48 hours".
14:01:47 <Philippa> monochrom: lib docs need to help teach the lib
14:02:30 <newsham> instance And True True True where and = bottom
14:02:39 <newsham> heh, neat
14:02:54 <Tac-Work> a thorough specification of what all the functions do, sorted by importance to the library, and examples on basic functionality
14:02:58 <Tac-Work> that's what I think a good doc should have
14:03:06 <EvilTerran> roconnor, i don't think pure languages really lend themselves to that sort of thing
14:03:11 <newsham> tacw: someone should write an oreilly book
14:03:24 <Philippa> haddock simply isn't enough to learn Parsec, for example
14:03:30 <Tac-Work> for haskell? someone actually is currently, I read somewhere
14:03:34 <Philippa> and that's if you already know a lot about parsing
14:03:45 <roconnor> EvilTerran: really?
14:03:55 <EvilTerran> roconnor, actually, Data.Set seems to have quite good asymptotic complexities for that
14:04:31 <EvilTerran> the min/max operations are all O(log n)
14:04:45 <roconnor> oh right. Data.Map and Data.Set have accessors for smallest and largest elements
14:04:48 <newsham> philippa: i agree that the current parsec docs arent good, but someone could write a good haddock page for parsec if they wanted to
14:05:18 <EvilTerran> and toAscList alledgedly gives you the elements in ascending order in O(n)
14:05:27 <EvilTerran> amortised constant time per element! :D
14:05:27 <Philippa> the current parsec docs are a lot better than what you'd get from haddock alone without a lot of work
14:05:35 <Philippa> they're also /big/
14:05:51 <Philippa> the biggest problem with them's that they're out of sync with the library in a few places
14:06:07 <newsham> the haddock docs are?
14:06:25 <monochrom> Philippa: OK, I agree and disagree. I think a complete set of doc of a library should be two parts: one part teaches the domain, the other part is non-hand-holding reference material, like an English dictionary.
14:06:46 <newsham> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html  looks pretty reasonable to me
14:06:48 <lambdabot> http://tinyurl.com/27k2zj
14:06:50 <newsham> (just too sparse)
14:07:03 <Philippa> monochrom: sure. The non-hand-holding stuff still needs to include an overview of the lib's semantics (Parsec's LL(1)-by-default behaviour being a prime example)
14:07:13 <newsham> oh, you mean the parsec tutorial out of date wit hthe parsec code/haddock
14:08:02 <Philippa> I mean this: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
14:08:19 <Philippa> which is still "the parsec documentation"
14:08:29 <newsham> *nod*  you're right.
14:08:38 <gpi5> The haddock problem is that something like: (bla => bla)-> [a] -> b-> (c->([d], [a])->f->IO () doesn't explain anything, really
14:08:52 <newsham> philippa: btw, did you read my excelleint parsec intro?  ;-)
14:09:05 <EvilTerran> you *can* add introduction-esque bits into the haddock of a module
14:09:17 <newsham> what ET said
14:09:19 <Philippa> I don't recall if I did. I forget when you first showed up here: it's possible I was using Parsec before you wrote your first line of haskell :-)
14:09:30 <monochrom> har har har
14:09:41 <Philippa> yeah, but Literate Haskell is a lot more appropriate for that kind of documentation at present
14:10:11 <Tac-Work> Literate Haskell makes me ill
14:10:13 <Tac-Work> X-D
14:10:32 <newsham> ph: brand new.  comments welcome.  http://www.thenewsh.com/%7Enewsham/formal/parse/parser.lhs
14:11:03 <Philippa> Tac-Work: ever read the results of a LaTeX-based .lhs file? It's nice
14:11:29 <newsham> good latex/.lhs example:  http://www.thenewsh.com/%7Enewsham/formal/khjk/khjk-fingerd.pdf
14:11:32 <Tac-Work> I don't really like the idea of executable LaTeX =-/
14:11:33 <newsham> (not mine)
14:11:38 <Philippa> and often even the raw source is pretty readable, which is great if you want to document implementation as well as interface
14:12:42 <Philippa> newsham: ah, I had read it recently. You might want to explain towards the end that the lib you're building has already been built!
14:12:45 <monochrom> I don't think haddock's markup language is ever intended for the teaching part; it has always been for the reference part. And next, if you ask, what should be designed for the teaching part? Well I think there is nothing new you can do. There is no rigid structure to teaching material. It seems the only known structure and format common to all teaching materials is general markups such as LaTeX or DocBook or HTML etc.
14:13:00 <newsham> ph: good point.  thanks.
14:13:39 <Philippa> especially as Parsec does a number of things your exampe doesn't (do you actually have try there? Otherwise your lib only does LL(1) grammars)
14:14:14 <Philippa> monochrom: having haddock and literate haskell coexist nicely is a good thing though
14:14:28 * Philippa still wants to be able to supply top-level annotations without it resulting in things being documented, too
14:14:46 <newsham> no, alternation does much higher lookahead than LL(1).  but i understand your point
14:15:53 <Philippa> *re-reads* - ah, you just don't have that parsec behaviour at all
14:16:08 <Philippa> semantically, your lib isn't a subset of parsec
14:16:31 <Philippa> it's a different breed of monadic parsing
14:16:50 <monochrom> newsham: where is it again? your tutorial we're talking about just now.
14:16:59 <wolverian> damn those monads, breeding like rabbits..
14:17:10 <newsham> ph: brand new.  comments welcome.  http://www.thenewsh.com/%7Enewsham/formal/parse/parser.lhs
14:17:16 <monochrom> You mean breeding like 1, 1, 2, 3, 5, 8, ...
14:17:16 <newsham> ^^ mono
14:17:40 <Philippa> I'm a bit braindead to read it through from scratch again tonight, FWIW
14:17:41 <wolverian> monochrom, we should name the sequence 'rabbits' instead of the boring 'fibs' I guess
14:17:56 <Philippa> I mean, I know I'm doing a good emulation of an intelligent and conscious human being
14:18:46 <monochrom> haha
14:21:52 <hpaste>  conal pasted "some comments for newsham" at http://hpaste.org/2675
14:22:00 <mboes> hi everyone, does anyone know if cabal does dependency analysis, or does it just get GHC to do the analysis instead?
14:23:03 <Igloo> It doesn't do it yet, but there are plans for it to do so
14:23:34 <newsham> philippa: http://www.thenewsh.com/%7Enewsham/formal/parse/parser.lhs.diff6   ?
14:23:34 <mboes> Igloo: me would like to build the yhc libraries using cabal :)
14:24:11 <Igloo> I think there's even code to do so now, but I don't know what the exact status is
14:25:04 <mboes> Igloo: do you know where that code is?
14:25:12 <Igloo> No
14:25:16 <Philippa> newsham: it'd be a good idea to mention the different behaviour of >>= and the existance of try
14:25:27 <Igloo> Probably either the Cabal repo or cabal-dev list
14:25:28 <newsham> conal: I've avoided using "liftM" even though I kind of wanted to.
14:25:56 <newsham> ph: can you explain the different behavior of >>= ?
14:26:57 <Philippa> newsham: see comment about braindeadness. It commits after the first token succeeds, and you need try in order to provide backtracking
14:27:01 <conal> newsham: too bad.  parsers rarely seem to really need the full monad interface and are "more functional" looking with liftM, liftM2, etc instead of do / >>= .
14:27:04 <Philippa> and I think I'm going to bed
14:27:19 <elliottt> enewsh.com/%7Enewsham/formal/parse/parser.lhs.diff6   ?
14:27:19 <elliottt> 14:02 < mboes> Igloo: me would like to build the yhc libraries using cabal :)
14:27:21 <conal> or just use the Applicative interface instead of Monad.
14:27:25 <newsham> philippa: ahh, yes.  danke.
14:29:16 <conal> newsham: if you're wanting to show that the Monad interface makes parser defs more elegant, you can one step further to Applicative style.
14:30:08 <alexj> mboes: seachpath does dependency analysis.
14:30:17 <newsham> conal: I agree, but I'm just worried about putting too much info out there for beginners.
14:30:26 <newsham> I know that when I was first learning, liftM scared the hell out of me
14:30:51 <elliottt> conal: is there already an Applicative instance for Parsec?
14:30:59 <newsham> ph: edited slightly (diff7)
14:31:04 <conal> newsham: sure.    though i wonder what if you'd been taught the simpler Applicative interface before the more complex Monad.
14:31:16 <EvilTerran> elliottt, there's the general Monad instance
14:31:27 <newsham> conal: good point..  I wonder.
14:31:33 <elliottt> EvilTerran: cool, thanks :)
14:31:43 <EvilTerran> ?src Monad (<*>)
14:31:44 <lambdabot> Source not found. You speak an infinite deal of nothing
14:31:47 <conal> newsham: i don't know. if not, just use the standard one: "instance Applicative Foo where { pure = return; <*> = ap }
14:32:05 <conal> oh -- that last comment was to go to elliottt.
14:32:47 <conal> afaict, it's purely a historical accident that people are learning &  using monads when they could first learn & use AFs with less mental strain.
14:32:56 <conal> and less of a departure from the usual functional stye.
14:32:58 <conal> style.
14:33:21 <elliottt> conal: i'd agree with that.  it seems like there would be less of a jump to make
14:33:23 <conal> i'd like to see that Monad inertia redirected.
14:33:54 <newsham> conal: *shrug* writing IO stuff w/ do-notation is pretty easy for imperative programmers
14:34:07 <conal> parsing is a particularly good case.  i don't know if i've ever seen a monadic parser that isn't more clearly expressed applicatively.
14:34:19 <newsham> got some short examples of some IO with 5 or six IO actions using applicative style?
14:34:21 <conal> newsham: i'm not talking about IO stuff.
14:34:31 <sorear> mboes: yhc does dependancy analysis!
14:34:57 <sorear> s/!/./
14:34:59 <mboes> sorear: does it work? because currently the dependencies are hardcoded in the build files!
14:35:16 <newsham> i have to admit i've not used ap much myself.
14:35:30 <mboes> alexj: interesting. hmake does dependency analysis too, so either might be useful here.
14:35:34 <sorear> mboes: it should, because it's a documented feature
14:36:06 <sorear> mboes: probably, we still use hard deps because nhc98 had no depanal
14:36:07 <conal> newsham: i might be able to dig up some IO examples, though i really meant other monads.
14:36:14 <newsham> *nod*
14:36:37 <conal> newsham: ap is less commonly useful than liftM, liftM2, liftM2, ...
14:37:06 <conal> once you start using them more & more, i bet you'll like your programs better.  assuming you like functional style.
14:38:01 <newsham> i'm still somewhere between imperative and functional :)
14:38:06 <newsham> working on it
14:38:09 <alexj> mboes: I avoid using cabal in favor of searchpath.
14:38:15 <conal> newsham: as simon pj said in his "hair shirt" talk, IO has become our "sin bin".
14:38:56 <alexj> mboes: largely because if I use cabal, I end up with libraries out of sync and I don't want manually to have to download and install all dependencies.
14:39:00 <conal> newsham: then i'd particularly encourage you to practice with the more functional style: more liftM2 & less "do"/>>=
14:39:56 * Philippa likes pointed functional style
14:39:56 <newsham> yah, i'm fairly comfortable with those these days
14:40:17 <newsham> i mostly avoid them only when trying to write code for my friends who arent as comfortable w/ them
14:40:20 <Philippa> so I mostly use lifting to wrap constructors around things I've matched, things like that
14:40:55 <conal> newsham: sure.
14:41:47 <newsham> i think one thing about haskell is that I often read these really strange programs that people write up and write papers about
14:42:02 <newsham> but only rarely get to see a more "normal" program that does the kinda thing I normally write
14:42:14 <newsham> so I'm still not very well read on haskell
14:42:17 <conal> newsham: (if you feel like making another pass over your parser and using applicative style, i'd be happy to read it over and give some more feedback. )
14:42:29 <newsham> where as my other programming languages, most of the code I see on a normal basis is the normal type.
14:42:58 <newsham> conal: perhaps, but not right now.
14:43:04 <conal> normal, as in doing unsurprising tasks?  or doing tasks in unsurprsing ways.
14:43:07 <conal> newsham: np
14:43:20 <newsham> i guess normal for me would be like small networking daemons, unix utils, etc...
14:43:25 <newsham> not a lot of algorithmic intensity
14:43:46 <newsham> a good example is the onion router dns server I saw recently in haskell.
14:44:01 <newsham> darcs would prob be another good example
14:44:03 <conal> newsham: i missed that one.
14:44:17 <psnively> newsham: Did you see Oleg Kiselyov's most recent "Haskell as OS" paper?
14:44:36 <psnively> The whole Zipper thing seems quite well-suited to those sorts of tasks.
14:45:04 <newsham> psnively: not sure.  prob not.  got an url?
14:45:23 <psnively> One sec.
14:45:46 <psnively> http://okmij.org/ftp/Computation/Continuations.html#context-OS
14:45:47 <lambdabot> Title: Continuations and delimited control
14:46:51 <newsham> tordns: www.lava.net/~newsham/tordnsel.tar.gz
14:47:20 <newsham> http://www.haskell.org/pipermail/haskell-cafe/2007-June/026801.html
14:47:23 <lambdabot> Title: [Haskell-cafe] TorDNSEL, http://tinyurl.com/2up72c
14:47:28 <newsham> psn: danke
14:47:33 <psnively> Doesn't onion routing imply, er, a router? :-)
14:47:50 <newsham> psn: yah, but I guess there's some dns support involved as well?
14:47:58 <newsham> i dont really know much about tor.  one of my friends pointed it out to me
14:48:05 <ddarius> Oh hey, it's Paul.
14:48:07 <newsham> the code is very well written though.
14:48:16 <psnively> Ah, right. Yes, you don't want traffic analysis done on name lookups. :-)
14:48:21 <psnively> Darius, as in Bacon??
14:48:32 <ddarius> Unfortunately not.
14:48:37 <ddarius>  /whois ddarius
14:49:01 <ddarius> He's been here a few times which is why I don't use Darius (he does).
14:49:04 <psnively> Oh, Derek!
14:49:18 <psnively> Who knew there were so many Darii?
14:49:49 <psnively> Yes, I'm afraid Oleg's latest has convinced me that I have to take the plunge.
14:50:01 <ddarius> latest?
14:50:16 <psnively> http://okmij.org/ftp/Computation/Continuations.html#context-OS
14:50:17 <lambdabot> Title: Continuations and delimited control
14:51:01 <ddarius> I saw that, but I thought that was an older paper from like May or so.
14:51:19 <psnively> I can't recall where I read it--perhaps in that paper, even--but I recently read that "monadic delimited continuations turn control flow into data flow; once it's data flow, it's subject to the type system."
14:51:34 <psnively> I groaned and thought: OK, I HAVE to get my head around that.
14:51:46 <psnively> Well, June, apparently.
14:51:57 <newsham> how about just making a type system for control flow? ;-)
14:52:05 <newsham> <- babbles on incomprehensibly
14:52:25 <psnively> Aren't all computational monads "types for control flow?"
14:53:05 <newsham> psnively: dont a lot of different control flow structures map to the same type?
14:53:13 <newsham> ie. when and while ?
14:53:39 <mboes> sorear: if i say yhc Foo.hs, will it automatically compile Bar.hs and Baz.hs as well, if Foo.hs depends on them? ( i ask cuz it's pretty tough to get even get a working YHC installation on my system atm!)
14:53:41 <psnively> I don't know about "a lot," but IIRC when and while were indeed proven equivalent in some strong sense.
14:53:59 <ddarius> psnively: Did you see/look at the paper "On Typing Delimited Continuations: Three New Solutions to the Printf Problem" that I linked on LtU?
14:54:10 <newsham> hmm.. why are when and while equivalent?
14:54:14 <psnively> I saw it, made a note to read it later.
14:54:46 <ddarius> psnively: The "punch line" is sweet.
14:54:55 <psnively> No doubt.
14:55:09 <psnively> newsham: You would ask me that mere days after I read something about it... and can't recall where.
14:55:25 <sorear> mboes: It works.  (I just tested it)
14:55:53 <ddarius> If we had a partiality monad when and while wouldn't have the same type...
14:56:16 <KatieHuber> what does "Illegal export of a lone data constructor" mean?
14:56:37 <ddarius> KatieHuber: You're exporting a data constructor but not the type maybe?
14:56:47 <newsham> katie: wild guess -- are you exporting one constructor and not one of its alternative constructors?
14:56:51 <mboes> sorear: cool. thx :)
14:56:59 <KatieHuber> I am exporting the type, and all its constructors, AFAICT...
14:57:19 <ddarius> What's the syntax you are using for exporting them?
14:57:31 <sorear> mboes: ooc, what are you using that breaks?  it's supposed to be pretty portable, especailly now that GMP is optional
14:57:34 <sorear> +and libffi
14:57:42 <KatieHuber> module Card (Face, FaceUp, FaceDown) where data Face = FaceUp | FaceDown
14:57:52 <sorear> KatieHuber: Card (Face(..)) where
14:57:55 <conal> does anyone know how to scale up pdfs while printing: bigger print & smaller margins?
14:58:00 <sorear> KatieHuber: or just Card where
14:58:23 <KatieHuber> ta
14:58:23 <hpaste>  scandal pasted "generate a password" at http://hpaste.org/2676
14:58:41 <ddarius> Or if you did want to explicitly list them (say if you only wanted to export some), Face(FaceUp, FaceDown)
14:58:51 <scanda1> seeking comments on style/etc for a small program to generate random passwords.  be gentle, i'm a newbie ;)
14:59:09 <ddarius> @paste
14:59:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:59:34 <scanda1> http://hpaste.org/2676
15:00:13 <psnively> Are all Haskell programmers English? ;-)
15:00:44 <sorear> psnively: far from it
15:00:52 <sorear> psnively: I think most are Australian
15:01:02 <psnively> Heh. Good point.
15:01:41 <psnively> We yanks don't say "ta," is all.
15:02:36 <ricky_clarkson> We brits don't say "is all".
15:03:11 <ddarius> scanda1: There are some inefficiencies that don't really matter, but as far as style or structure is concerned it looks good.
15:03:13 <monochrom> We are all over the world. Actually the US is under-represented.
15:03:44 <ddarius> psnively: There is a phalanx of non-English #haskell channels.
15:03:56 <Saizan> scanda1: your shuffle function is suboptimal, an easy improvement is to use splitAt to get the i-th element and the two halves of the list at the same time
15:04:07 <psnively> I was riffing on the fact that I'm American, but it seems most Haskellers aren't. :-)
15:04:15 <ddarius> The US is so under-represented that we are importing Haskellers from other countries.
15:04:22 <psnively> A phalanx! Greek, then. ;-)
15:04:23 <KatieHuber> OK, I'm feeling really stupid now... how do I make hugs let me use functions from two modules (newStdGen from Random as well as my own code)
15:04:38 <psnively> KatieHuber: You're not stupid.
15:04:48 <scanda1> Saizan: ah, cool. thanks for the tip
15:04:52 <monochrom> Look for :also
15:05:06 <KatieHuber> I tried :also already without success?
15:05:22 <Igloo> I never understood hugs' handling of modules. ghci's is much simpler IMO
15:05:25 <oerjan> KatieHuber: hugs doesn't support this, alas
15:05:33 <KatieHuber> oo
15:05:34 <ddarius> hugs is a steaming pile...
15:05:46 <KatieHuber> so I need to make a new module which imports both, and :load that
15:05:51 <KatieHuber> how silly :)
15:06:17 <ddarius> oerjan: Did Hugs stop doing that?  I thought it did handle that, though I haven't used Hugs in years.
15:06:47 <psnively> What's wrong with Hugs, Derek?
15:07:15 <mboes_> sorear: argh, sorry, am getting random disconnections from irc atm
15:07:20 <ddarius> It's worse than GHC(i) in almost every way and has some annoying issues.
15:07:27 <oerjan> hey, maybe i'm wrong :)
15:07:38 <psnively> GHCI runs like molasses in January, however.
15:07:50 <ddarius> psnively: Starting it does.
15:08:04 <psnively> Hmmm. OK, I'll have another look at it.
15:08:12 <scanda1> is there already a function that does something like    f g (x:y:[]) = g x y  ?
15:08:28 <sorear> scanda1: no
15:08:31 <scanda1> I want to take the output of splitAt and call (++) on the first two elements
15:08:33 <ddarius> scanda1: Not in any sane way and I'm pretty sure not in any insane ways either.
15:08:47 <oerjan> ah no, it didn't work
15:08:49 <sorear> scanda1: usually, fixed length lists are indicative of design flaws...
15:09:04 <monochrom> KatieHuber: If your file already imports Random, just by :load your file you already have access to both. If your file doesn't import Random, I wonder why you need access to both - I mean you can wish anything you want, but this one is a very rare use-case.
15:09:35 <ddarius> monochrom: If you want to generate random input for the stuff in the module...
15:09:52 <shapr> hiya psnively
15:10:12 <psnively> Hello Shae!
15:10:14 <monochrom> then one should write a separate tester file anyway
15:10:16 <scanda1> sorear: see http://hpaste.org/2676 for context. specifically the shuffle function.  the suggestion was to use splitAt instead of my manual  take /drop.
15:10:21 <psnively> (Hello, Joe. Hello, Mike.)
15:10:22 <shapr> psnively: Haven't seen you here before, are you checking out Haskell?
15:10:46 <psnively> It's true--I was just telling Derek that Oleg's delimited continuations in OSes stuff pushed me over the edge.
15:10:49 <sorear> psnively: we've got a confirmed Chinese (ccshan), a couple from England (malcolmw, ndm, etc), plenty from the US (sorear, newsham, stepcut, etc), Italy (xerox), Uganda (LeCamerade), Brazil (syntaxfree), Sweden (former shapr), and a bunch of others that I don't have confirmation for
15:10:57 <scanda1> i need to remove one randomly selected element of a list
15:11:17 <shapr> Though I'm now in the USA for good.
15:11:23 <psnively> sorear: no doubt. I really had intended to poke fun at myself. :-)
15:11:32 <ddarius> Damn.  That HaskellUserLocations was on HaWiki wasn't it.  Was it migrated?
15:11:37 <shapr> Don't think so.
15:11:40 <psnively> shapr: Probably more for our good than yours. ;-)
15:11:40 <ddarius> shapr: What happened?
15:11:49 <monochrom> REPLs can only get you so far. Even if you point at very advanced REPLs like those of Perl, Allegro Lisp, SML/NJ, ...
15:11:54 <shapr> psnively: true that.
15:12:00 <psnively> :-D
15:12:14 <sorear> monochrom: Smalltalk?
15:12:48 <psnively> Eh, I dunno. I really like interactive development. That's why I was a Lisper for so many years: I thought all non-Lisp/Smalltalk languages were edit/compile/link/test/crash/debug.
15:13:13 <ddarius> psnively: Looked at factor?
15:13:40 <psnively> No; I haven't been able to get excited about the concatenative languages.
15:14:03 <thoughtpolice> i've been wanting to get into factor some for a while
15:14:03 <monochrom> In no way did I say REPLs should be eliminated, OK?
15:14:10 <sorear> psnively: All languages are edit/compile/link/test/crash/debug, it's just that Scheme forces you to do it a line at a time. :D
15:14:14 <psnively> Fair enough, monochrom.
15:14:14 <ddarius> factor does look like the nice parts of Forth with the nice parts of e.g. Joy.
15:14:50 <psnively> It's the nice parts of stack-based that I don't see, I guess.
15:14:53 <oerjan> > let (before,x:after) = splitAt 3 "testing" in before++after -- scanda1
15:14:55 <lambdabot>  "tesing"
15:15:00 <Nafai> psnively: What do you mean?
15:15:02 <ddarius> That said, the image environment is... annoying.
15:15:11 <EvilTerran> why is that a scandal, oerjan?
15:15:14 <EvilTerran> hm.
15:15:19 <Nafai> ddarius: Why?
15:15:26 <psnively> I mean concatenative, Nafai. :-)
15:15:42 * EvilTerran just tried to tab-complete "scandal" without thinking about it, and then had a "wait, what?" moment when it worked
15:15:49 <ddarius> Nafai: Because I like my editor and my window manager, etc. and I want to use them, not Factor's.
15:16:19 <Nafai> ddarius: Factor's image isn't like Squeak's
15:16:20 <psnively> Oh, it's another all-or-nothing environment? <emily_litella>Nevermind.</emily_litella>
15:16:23 <mboes_> gah, looking at the logs seems none of the text i was sending landed on the channel. evil disconnects.
15:16:29 <Nafai> ddarius: You still use your own external editor, etc
15:16:34 <mboes_> sorear: was asking, how is gmp optional? what do you use for arithmetic?
15:16:52 <mboes_> also, for libffi, i saw patch comments to the effect that it was optional, but having a look at the source code that doesn't seem to be the case.
15:17:12 <sorear> mboes_: Int.  (ndm's idea not mine)
15:17:14 <ddarius> Nafai: I didn't really explore much.
15:17:49 <sorear> mboes_: can you hpaste your scrollback then?
15:18:38 <ddarius> Nafai: That said that isn't immediately obvious to me, though I'm sure you could edit source in a separate window.  Then the image seems like an IDE and I don't like those either.
15:19:00 <ks> is there continuation in haskell ?
15:19:20 <ddarius> ks: Assuming you mean call/cc, no.
15:19:20 <psnively> There are great delimited continuations available for Haskell.
15:19:27 <oerjan> ks: there are monads for it
15:19:27 <sorear> ks: Easily
15:19:28 <mboes_> sorear: didn't say much more than that. Was just mentioning that my system is freebsd, and the problem with yhc is the build system breaking in several and very odd ways, like not finding gmp, not finding endianness properly, not setting the type sizes properly, etc..
15:19:39 <sorear> ks: CPS is quite natural in Haskelll
15:19:43 <oerjan> @docs Control.Monad.Cont
15:19:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
15:19:55 <sorear> mboes_: can you hpaste your scrollback then?
15:20:23 <ddarius> Both monads and CPS require global transformations and in that regard every language has first-class continuations.
15:20:24 <sorear> mboes_: oh, I see
15:20:47 <ks> hm thanks
15:21:15 <psnively> But at least Haskell's libraries are chock full o' monadic goodness. I tried Oleg's parser-inside-out thingy with his monadic delimited continuations for OCaml, and failed because the libraries aren't monadic.
15:21:20 <hpaste>  mboes pasted "mboes's scrollback" at http://hpaste.org/2677
15:21:21 <bos> ddarius: in response to your earlier question: http://www.realworldhaskell.org/blog/2007/09/10/coming-soon-early-content-for-reviewers/
15:21:23 <lambdabot> Title: Real World Haskell » Blog Archive » Coming soon: early content for reviewers, http://tinyurl.com/3bor49
15:21:27 <monochrom> native continuations, i.e., messing with the machine stack or even the VM stack --- No.  Turn everything into CPS (you don't have to do it yourself), yes, that's Control.Monad.Cont.
15:21:32 <ddarius> bos: Thanks.
15:21:38 <psnively> ks: See http://okmij.org/ftp/Computation/Continuations.html#zipper
15:21:40 <lambdabot> Title: Continuations and delimited control
15:23:47 <ks> thanks
15:23:49 <monochrom> We don't have a parser library that takes a monadic callback as input stream, or a callback (doesn't have to be monadic) as semantic action. So we kind of don't have a hole to invert.
15:24:18 <newsham> hole?  invert?
15:24:21 <psnively> Hmmmm, interesting point.
15:24:45 <oerjan> the new ParsecT doesn't support it?
15:24:56 <monochrom> OCaml works because you can give a function (implicitly monadic, I admit) as input stream.
15:25:08 <ddarius> bos: The natives* were getting restless and I thought I'd carry their torch for them.  Personally, I have the patience of a stone. * Actually it was the outsiders, though I'm sure some natives were too.
15:25:37 <monochrom> And Oleg also gets some SSAX parser to work because it takes a callback as semantic action, so you just sneak in your shift there.
15:25:53 <psnively> Sneaky and shifty.
15:26:06 <Philippa> monochrom: you can do it with the version xerox's produced, though currently you get back the old space leak problems in return
15:26:13 <monochrom> Our parsers straightly go from String -> ParseTree or something, no loophole to exploit.
15:26:38 <bos> ddarius: people were grumbling here? or elsewhere?
15:26:57 <ddarius> bos: Here.
15:27:03 <bos> interesting.
15:27:03 <Philippa> supporting callback-generated streams was an explicit goal
15:27:06 <monochrom> I suppose ParsecT (CC whatever) will work.
15:27:38 <monochrom> Is xerox doing the ParsecT part?
15:27:38 <psnively> It was just an example, albeit an interesting one, IMHO.
15:29:11 <Saizan> he has finished it, afaik
15:29:25 <ddarius> Summer is over.
15:29:31 <monochrom> I wonder if I could pierce a hole into the pure String input with a does of unsafePerformIO and unsafeInterleaveIO.  hee hee hee ...
15:29:58 <monochrom> s/does/dose/
15:30:05 <monochrom> (talk about invertion)
15:30:22 <psnively> Yech. I think I'm going to hurl. ;-)
15:30:36 <Saizan> well that's roughly what you do when you use the output of readFile as input
15:31:41 <psnively> Hmmm.
15:33:31 <hpaste>  scandal annotated "generate a password" with "updated password gen" at http://hpaste.org/2676#a1
15:33:55 <ddarius> monochrom: With enough effort, yes.
15:34:20 <ddarius> readFile isn't too bad as far as lazy input goes.
15:34:21 <scanda1> oerjan: thanks, i created a removeAt function with your suggestion
15:34:21 <newsham> you're going to rely on System.Random to generate your passwords?
15:35:00 <scanda1> I'm just learning haskell.  Not using this for anything real.
15:35:20 <newsham> ok.  just so you know, PRNG is not good for security.
15:35:40 <mauke> for a password?!
15:35:50 <mauke> how are you going to exploit that
15:36:15 <monochrom> PRNG is good for national security. Meaning if all criminals just use PRNG, the government can protect us from them effectively.
15:36:55 <elliottt> @pl \f xs -> zipWith ($) (repeat f) xs
15:36:56 <lambdabot> zipWith id . repeat
15:37:15 <mboes_> sorear: yhc AnyYHCBaseSourceFile.hs gives me: yhc: getOutEdges: there is no node #2 in the graph
15:37:56 <sorear> mboes_: Funny.
15:37:58 <sorear> @seen ndm
15:37:59 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 8h 14m 54s ago, and .
15:38:01 <oerjan> elliottt: you know that is map, right? :)
15:38:17 <mboes_> so i guess there are still some rough edges to sort out before using yhc for dependency analysis for building base libraries
15:39:15 <oerjan> (guess you are looking at applicatives?)
15:39:17 <sorear> mboes_: I'd ask ndm; it sounds like a build issue, since it works for me.
15:39:29 <hpaste>  Saizan annotated "generate a password" with "saving a (!!)" at http://hpaste.org/2676#a2
15:39:45 <mboes_> sorear: ok, will do. Me going to bed now. Thanks for your help!
15:40:56 <newsham> mauke: build a list of all possible seeds, reproduce algorithm to generate finite list of potential passwords, try each password until you have one that works
15:41:59 <scanda1> Saizan: thanks, now i see what you meant with your first response (lol)
15:42:54 <scanda1> is there a haskell binding to libssl yet? ;)
15:43:15 <newsham> see also: libraries/random/System/Random.hs  "mkStdRNG".  built on getCPUTime and getClockTime.
15:43:21 <mauke> > 2^48
15:43:24 <lambdabot>  281474976710656
15:44:41 <mauke> > 2^48 /60 /60 /24 /365
15:44:43 <lambdabot>  8925512.960129883
15:44:53 <mauke> takes too long at 1s per password
15:45:06 <newsham> mauke: I can guess the seed in less than 2^48 guesses.
15:45:16 <KatieHuber> that's less than 9m years, what're you complaining about?
15:45:25 <mauke> how?
15:45:37 <newsham> by making reasonable guesses for getClockTime
15:45:50 <newsham>     ct          <- getCPUTime
15:45:51 <newsham>     (TOD sec _) <- getClockTime
15:45:51 <newsham>     return (createStdGen (sec * 12345 + ct + o))
15:45:52 <newsham> o == 0
15:45:55 <mauke> ah, but my actual password generator uses perl's rand :-)
15:46:05 <mauke> which is seeded from /dev/urandom
15:46:09 <newsham> and what did you see perl's rand with?
15:46:49 <newsham> and you're just generating one password per seed?
15:47:32 <mauke> huh?
15:47:47 <newsham> are you seeding the generator and generating a single password?
15:47:53 <newsham> or are you generating multiple passwords at once?
15:48:00 <mauke> a single password
15:48:19 <newsham> why not just get your passwords from /dev/rand?
15:48:30 <newsham> er urandom
15:48:46 <mauke> because I like to have passwords I can actually type
15:48:59 <newsham> and....
15:49:01 <mauke> urandom is binary garbage
15:49:10 <newsham> yah, but why use perl's rand() func?
15:49:13 <monochrom> you can mime64 it, you know
15:49:26 <mauke> newsham: because it's easy to use
15:49:48 <mauke> monochrom: that restricts the output character set
15:50:15 <monochrom> and "I can actually type" doesn't restrict the output character set further?
15:50:16 <newsham> btw, isn't perl's rand() the same thing as rand(3)?  that only has 32 bits of entropy
15:50:33 <mauke> my program has a configurable charset with a default of 'a-zA-Z0-9!$%.,'
15:50:44 <newsham> (acutally 31 bits of entropy)
15:50:54 <monochrom> See, that's narrower than mime64's.
15:51:01 <mauke> (hmm, I should probably remove y and z from that)
15:51:13 <KatieHuber> and if you're on a BSD then it's much less than 31 bits of randomness
15:51:25 <monochrom> It sounds like you're just making up all sorts of rationalizations.
15:51:29 <newsham> mauke: if you're using perl rand() I dont think you're getting 48bits of entropy
15:51:33 <mauke> newsham: depends. perl's Configure selects a system rng
15:51:42 <mauke> IIRC it defaults to drand48
15:51:59 <newsham> ahh, FAQ I found must be dated
15:52:18 <thoughtpolice> is there a parsec function to test for the empty input?
15:52:26 <newsham> (I would still consider 48-bits weak, but if you're aware of that and fine with that, I dont have a problem with it :)
15:52:26 <oerjan> thoughtpolice: eof
15:52:35 <thoughtpolice> oerjan: thanks. :)
15:53:48 <sorear> I use gpw
15:54:21 <LoganCapaldo> @type gpw
15:54:24 <lambdabot> Not in scope: `gpw'
15:54:34 <LoganCapaldo> @type sorear
15:54:36 <lambdabot> Not in scope: `sorear'
15:54:41 <mauke> monochrom: it's not about how many characters are in my set; the point is that it should be a runtime option
15:55:34 <mauke> monochrom: and the defaults are all characters that are in the same position on american and german keyboards
15:55:56 <newsham> mauke: want to publish your password generation algorithm, your username and the ip address and port of your ssh server?
15:56:05 <mdmkolbe> mauke: defaults for what?
15:56:29 <mauke> mdmkolbe: the character set from which it builds passwords
15:56:49 <mauke> newsham: sure
15:57:25 <mauke> http://rafb.net/p/XjafnM42.html
15:57:27 <lambdabot> Title: Nopaste - No description
15:59:40 <mauke> my current ip address is 90.128.77.237
16:00:31 <newsham> usrename?
16:01:01 <mauke> mauke
16:01:13 <newsham> you gen your pw with this prog and def args?
16:01:20 <mauke> no
16:01:40 <olsner> @pl (\l -> zip l (tail l))
16:01:40 <lambdabot> ap zip tail
16:01:43 <mauke> I never claimed that :-)
16:02:05 <newsham> so your trust in this prog isnt very high?
16:02:25 <mauke> no, it's just that I wrote it after I created this account
16:02:39 <newsham> makes sense
16:03:50 * mdmkolbe uses /dev/rand passed through a randomness purifying function and mapped to 14 chars taken from the 96 printable characters
16:04:19 * thoughtpolice is having a rainy day...
16:04:21 <geezusfreeek> hello djancak
16:04:22 <mauke> how can you purify randomness?
16:04:24 <thoughtpolice> perfect to code, I suppose. :)
16:04:26 <reffje> randmoness purifying function?
16:04:33 <newsham> hash?
16:04:36 <thoughtpolice> lots of unsafe stuff!
16:05:12 <djancak> i coi do djizysfrik
16:05:27 <newsham> > (log 96 / log 2) * 14
16:05:29 <lambdabot>  92.18947501009619
16:06:13 <mdmkolbe> mauke: simplest example is if you have a biased coin, how do you get an unbiased random result.  The answer is to not measure when the coin is heads or tails, but rather to take lots of measurements, group then into pairs and treat [head,tail] as 1 and [tail, head] as 0 and ignore the others.  The result is a uniform (unbiased) random number.
16:06:41 <newsham> do you get biased data from /dev/rand?
16:06:46 <mdmkolbe> pairs = [1, 2, 3, 4, 5, 6] --> [1, 2], [3, 4], [5,6]
16:07:18 <mdmkolbe> newsham: I'm not absolutely sure, but an extra purifiying pass never hurts.
16:07:43 <newsham> unless your samples are correlated and you happen upon a weakness in the source :)
16:07:48 <mdmkolbe> If I were any more paranoid, I'd make my passwords by flipping a coin.
16:07:53 <newsham> oops, transitions are biased.. doh.
16:08:17 <EvilTerran> mdmkolbe, rig up a geiger counter!
16:08:45 <monochrom> gig, gig, gig, gig, gigigigigigg....
16:08:46 <EvilTerran> i hear you can get a good radiation source & detector out of smoke alarms.
16:08:46 <mdmkolbe> The hardest part is that the passwords are real finger twisters
16:09:11 <monochrom> Indeed.
16:09:49 <newsham> why not start with a deck of 256 cards, then swap the first card with the ith card where i is based on your first key character, then swap the 2nd character with i+j mod 256 where j is based on your second key, and keep repeating until you've swapped all 256 cards
16:09:59 <newsham> then start using the cards in order as random values
16:10:43 <newsham> (you could always put your web cam on a lava lamp and hash the output)
16:11:16 <mdmkolbe> though the finger twisting aspect is an advantage against (some) rubber hose attacks.  since I only know my passwords by mussle memory, anyone who beats up my hands to get my password is out of luck. ;-J
16:11:34 <newsham> depends on what you're protecting.
16:11:54 <newsham> if you're protecting yoru body, for example, its prob a disadvantage :)
16:12:20 <sorear> I keep my passwords on scraps of paper under my monitor - anyone who can get that close doesn't need them.
16:12:27 <mdmkolbe> newsham: true, but being a programmer, my hands are my (second) most valuable asset
16:13:00 <mauke> sorear: even with encrypted partitions?
16:13:00 <mdmkolbe> (well maybe third, after brain and eyes)
16:13:01 <newsham> sorear: i'm with you.  physical attacks arent important in my threat model
16:13:21 <EvilTerran> yes, quite. that's why i don't have a password on my BIOS.
16:13:50 <EvilTerran> i reason that, if someone can get my computer for long enough to put a liveCD in and get the data off my HD that way, a BIOS password really isn't going to help
16:14:13 <sorear> mdmkolbe: there are blind #haskellers, but I doubt many brainless ones ;)
16:14:17 <EvilTerran> as removing the hard drive, or making off with the whole box, wouldn't take that much longer.
16:14:24 <newsham> sorear: working on it
16:14:37 <sorear> ?
16:14:50 <newsham> killing my brain slowly with alcohol.
16:19:42 <ddarius> Code should be efficiently writeable without one's hands.
16:20:25 <lament> without a penis, on the other hand, things get tricky.
16:20:44 <KatieHuber> oi!
16:21:21 <ddarius> Yes! Have kids and dictate to them!
16:22:22 <mdmkolbe> ddarius: that'll just give me the vocal equivalent of "gurrilla arm" or RSI of the vocal chords
16:23:17 <lament> ah come on
16:23:27 <lament> not having hands is not a huge impediment
16:23:44 <lament> you could type morsecode with any part of your body
16:23:55 <lament> and there's already software for that
16:24:09 <miraage> You are one sick fuck!
16:24:23 <mdmkolbe> lament: ok, fair enough.  You can get what 30 WPM with that?
16:24:32 <lament> miraage: hi!
16:24:51 <ddarius> mdmkolbe: 30 WPM should be good enough.
16:24:53 <lament> mdmkolbe: you can certainly get enough for it not to be the bottleneck.
16:25:04 <lament> 30 wpm sounds pretty impressive actually
16:25:16 <miraage> lament: Hey! Don't think that because I'm idling in this channel, I did anything interesting with Haskell while you were gone ;P
16:25:37 <mdmkolbe> then the next task is to develop, F1-F12, Ctrl, and Alt morse codes
16:26:39 <ddarius> Yeah... I think you would actually have to kill someone to make them incapable of communicating.
16:26:49 <ddarius> Or put them in a coma or some such I guess.
16:27:39 <lament> even killing is not effective, according to some.
16:27:45 <tty56> hi, what does $ mean in io $ mkUnmanagedWindow d scr (rootw st) ?
16:28:02 <mdmkolbe> ddarius: (1) in coma, telepathy ;-J.  (2) it's communication rate that I'm concerned about
16:28:05 <lament> @source $
16:28:05 <lambdabot> $ not available
16:28:11 <lament> @source ($)
16:28:11 <lambdabot> ($) not available
16:28:14 <lament> blah
16:28:17 <Botje> tty56: $ is just for lazy people who don't want to write parentheses.
16:28:32 <ddarius> mdmkolbe: I know, but I'm pretty sure you can get a decent rate with things that are necessary for survivial.
16:28:40 <Botje> foo (bar 1) is equal to foo $ bar 1
16:28:40 <ddarius> Like breathing...
16:28:42 <mdmkolbe> tty56: a b $ c d $ e f ==> a b (c d (e f))
16:28:48 <LoganCapaldo> we don't need $ for that
16:28:50 <ddarius> @src ($)
16:28:50 <lambdabot> f $ x = f x
16:28:53 <kpreid> @src $
16:28:53 <lambdabot> f $ x = f x
16:29:11 <tty56> Botje: aaaahhh, but very very confusing... ;)
16:29:12 <lament> oh, what does @source do?
16:29:19 <LoganCapaldo> > concat `id` map (repeat 3) [1,2,3]
16:29:22 <ddarius> @source Data.List
16:29:23 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:29:27 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[t]'
16:29:28 <mdmkolbe> @source length
16:29:28 <lambdabot> length not available
16:29:34 <mdmkolbe> @source List.length
16:29:34 <lambdabot> List.length not available
16:29:47 <Botje> tty56: it's confusing at first. but your wrists will thank you for it :)
16:29:51 <LoganCapaldo> hmm
16:30:06 <ddarius> It takes exactly as much typing.
16:30:11 <ddarius> In theory.
16:30:16 <LoganCapaldo> > concat $ map (repeat 3) [1,2,3]
16:30:17 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[t]'
16:30:21 <LoganCapaldo> oh good
16:30:30 <LoganCapaldo> I was just plain wrong
16:30:39 <mdmkolbe> difficulty(SPACE) < difficulty(PAREN)
16:30:40 <Botje> ddarius: do explain.
16:30:44 <LoganCapaldo> > concat `id` map (replicate 3) [1,2,3]
16:30:45 <lambdabot>  [1,1,1,2,2,2,3,3,3]
16:30:54 <LoganCapaldo> see we don't need $ to remove parens
16:31:04 <ddarius> f $ x y is just as much typing as f (x y)
16:31:13 * Botje defines $ as id .. oh.
16:32:15 <tty56> heh, now my next (dumpb ;) question: waht does "st <- get" do?
16:32:48 <mauke> it reads the current value of the state and binds it to the variable st
16:32:50 <tty56> ehm dumb
16:33:11 <LoganCapaldo> tty56, http://hpaste.org/2655
16:33:19 <LoganCapaldo> :)
16:33:19 <ddarius> @undo do st <- get; return st
16:33:20 <lambdabot> (get >>= \ st -> return st)
16:34:33 <tty56> thanks :) haskell is definitly the hardest language that I learned up to now, even after some reading I still do not understand even simple programs
16:34:47 <ari> @. pl undo do st <- get; return st
16:34:47 <lambdabot> get
16:34:51 <mauke> warning: short =/> simple
16:35:14 <lament> tty56: you think haskell is hard, try perl!
16:35:33 <lament> but, you can only look at perl golf programs for examples :)
16:36:06 <tty56> lament: with perl I found it rather easy to understand simple programs... no black magic
16:36:06 <mauke> perl -wpe '$n=qr/-?\d+(?:\.\d*)?/;1while s;($n)\s+($n)\s+([+\-*/])(?!\S);"$1$3$2";gee'
16:36:09 <tty56> ;)
16:36:13 <mauke> o rly?
16:36:32 <tty56> mauke: yeah. but most programs are written much more understandable
16:36:32 <lament> tty56: simple programs are easy to understand in any language, it's short programs that are challenging :)
16:36:36 <ddarius> Haskell is one of the least magical languages ever.
16:36:49 <mauke> ddarius: I strongly disagree
16:36:57 <mdmkolbe> tty56: haskell just comes from a different language family.  if you had done ML, it might seem more familiar
16:36:59 <lament> ddarius: i disagree too, that's wishful thinking.
16:37:08 <mauke> anything that lets you overload ";" is pretty magical
16:37:22 <ari> No, overloading ; isn't magical
16:37:26 <ari> n+k patterns, however, are
16:37:37 <ddarius> And Haskell doesn't let you overload ; so everything is dandy.
16:37:39 <lament> i was just about to mention that
16:37:43 <ddarius> n+k patterns are a sin.
16:37:44 <lament> (n+k)
16:37:44 <tty56> mdmkolbe: I did already some ocaml, which is somewhat new, but simpe, programs are ok, haskell seems to be much more expressive
16:37:57 <tty56> s/simpe,/simple
16:38:00 <EvilTerran> mauke, that... does something involving reading decimal numbers, with an optional minus sugn.
16:38:13 <olsner> is there a nice short function or operator for f^n or repeated composition? besides doing it myself with foldl (.) id (repeat n f)?
16:38:15 <mauke> EvilTerran: you're on the right way :-)
16:38:39 <EvilTerran> i think you've got a parse error at "1while", and if not there, one immediately after "while s;($n)", though.
16:38:40 <augustss> olsner: the fold is the way, i think
16:38:58 <mauke> EvilTerran: no, it compiles and runs
16:39:21 <LoganCapaldo> @type \f n -> foldl (.) id (repeat n f)
16:39:27 <lambdabot>     Couldn't match expected type `t -> [a -> a]'
16:39:27 <lambdabot>            against inferred type `[a1]'
16:39:27 <EvilTerran> ah, wait, that \'s the enreference operator
16:39:29 <augustss> olsner: it's not a very common thing to do
16:39:33 <EvilTerran> it's deliberate obfuscation, tho
16:39:35 <olsner> unfortunately, the fold is less readable than what I have now ... just (mutate . mutate . mutate)
16:39:37 * Tac-Tics demands (x++xs) patterns
16:39:40 <LoganCapaldo> @type \f n -> foldl (.) id (replicate n f)
16:39:41 <lambdabot> forall a. (a -> a) -> Int -> a -> a
16:39:47 <mauke> :t \f n -> (!! n) . iterate f
16:39:50 <lambdabot> forall a. (a -> a) -> Int -> a -> a
16:39:53 <EvilTerran> ah, wait! "s;"!
16:39:54 <EvilTerran> gotcha!
16:39:56 <olsner> :t repeat
16:39:57 <lambdabot> forall a. a -> [a]
16:40:10 <ddarius> Tac-Tics: Erlang has them I believe.
16:40:13 <LoganCapaldo> olsner, you'll note I made the same mistake a few minutes ago :)
16:40:18 <EvilTerran> still deliberate obfu.
16:40:43 <mauke> EvilTerran: only slightly
16:40:51 <mauke> just insert a few spaces
16:41:20 <olsner> LoganCapaldo: your fault then - I was unsure so I figured I was lucky that someone had just used that function :P
16:41:28 <dibblego> what is the time complexity of fib n = fib (n - 1) + fib (n - 2) ?
16:41:31 <olsner> missed the type error below that line though
16:41:38 <ddarius> dibblego: fib n
16:41:42 <mauke> dibblego: OVER 9000
16:41:50 <dibblego> wtf?
16:41:54 <mauke> it never returns
16:42:02 <sorear> dibblego: Too high
16:42:05 <dibblego> with the base cases as well of course
16:42:12 <dibblego> I know it's too high, but what is it?
16:42:17 <ddarius> fib n
16:42:18 <sorear> dibblego: at least O(phi^n)
16:42:32 <sorear> dibblego: specifically, nfib(n)
16:42:46 <olsner> and phi^n ~= fib n, right?
16:42:47 <EvilTerran> mauke, using ; as the s/// separator hardly counts as "slight" obfu
16:42:59 * thoughtpolice loves parsec
16:43:02 <mauke> EvilTerran: syntax coloring should make it obvious
16:43:03 <sorear> dibblego: which I *think* is about the same same as fib n
16:43:12 <thoughtpolice> didn't start using it until about 10 minutes ago and I have a bit of an IRC parser done. :)
16:43:15 <dibblego> ok, cheers
16:43:17 <EvilTerran> unfortunately, i don't have that in my IRC client. surprisingly.
16:43:30 <EvilTerran> also, s///ee is a dirty trick
16:44:10 <mauke> obfuscation starts with alphanumeric delimiters for s
16:44:16 <mauke> or control characters
16:44:38 <EvilTerran> don't tell me that's what your perl looks like when you're not deliberately being obtuse.
16:45:03 <EvilTerran> if that's the case, that reflects more on you than it does on perl ;]
16:45:35 <mauke> this was just a short joke. I didn't try to golf/obfuscate it
16:45:50 <newsham> et: I think it reflects appropriately on perl as well
16:47:26 <EvilTerran> nah. i'm sure with a bit of work i could make that valid haskell
16:47:48 <mauke> including the eval?
16:48:01 <EvilTerran> it wouldn't do the same thing, mind
16:48:25 <EvilTerran> (probably. you never know)
17:06:24 <tehgeekmeister> ?src flip
17:06:24 <lambdabot> flip f x y = f y x
17:07:54 <tehgeekmeister> ?src lookup
17:07:55 <lambdabot> lookup _key []          =  Nothing
17:07:55 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
17:07:55 <lambdabot>                         | otherwise = lookup key xys
17:16:50 <Tac-Tics> how can you convert a float to an int?
17:17:06 <ddarius> Tac-Tics: Many ways, it depends on what you want.
17:17:15 <Tac-Tics> just a truncating round
17:17:39 <Tac-Tics> heh, truncate
17:17:39 <ari> :t truncate
17:17:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:17:55 <ddarius> @src RealFrac
17:17:55 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
17:17:55 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
17:17:55 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
17:21:11 <mauke> > properFraction 3.14
17:21:13 <lambdabot>  (3,0.14000000000000012)
17:29:35 <LoganCapaldo> @type properFraction
17:29:44 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
17:30:03 <LoganCapaldo> Why RealFrac and not Fractional?
17:30:27 <LoganCapaldo> > properFraction (4%3)
17:30:32 <lambdabot>  (1,1%3)
17:30:36 <LoganCapaldo> oh
17:30:47 <LoganCapaldo> RealFrac clearly doesn't mean what I thought
17:30:50 <LoganCapaldo> I'm silly
17:31:02 <LoganCapaldo> Real vs. imaginary
17:31:30 <tehgeekmeister> ?src words
17:31:30 <lambdabot> words s = case dropWhile isSpace s of
17:31:30 <lambdabot>     "" -> []
17:31:30 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:50:13 * Pseudonym laughs
17:50:21 <Pseudonym> >lambdabot< ?users
17:50:21 <Pseudonym> [lambdabot] Maximum users seen in pseudonym: 0, currently: 0 (NaN%), active: 0
17:50:22 <Pseudonym>            (NaN%)
17:50:25 <Pseudonym> Eeeuuw.
17:52:37 <tehgeekmeister> what's this mean:
17:52:39 <tehgeekmeister> tehgeekmeisters-computer% ghc prime.hs                                                                                           17:51~/code/hs/exercises
17:52:39 <tehgeekmeister> _ZCMain_main_closure
17:52:39 <tehgeekmeister> ___stginit_ZCMain
17:52:42 <tehgeekmeister> collect2: ld returned 1 exit status
17:53:12 <mdmkolbe> tehgeekmeister: that you have a broken GHC build?
17:53:22 <tehgeekmeister> ouch.
17:53:40 <mdmkolbe> tehgeekmeister:  _ZCMain_main_closure is the GHC equivalent of "_main"
17:54:08 <mdmkolbe> tehgeekmeister: does prime.hs have a "main"?
17:54:16 <tehgeekmeister> yes
17:54:21 <tehgeekmeister> but i'm not sure if it's defined properly
17:54:26 <mauke> does prime.hs contain "module"?
17:54:30 <tehgeekmeister> i've never wrote a main before
17:54:38 <tehgeekmeister> yes, it does.
17:54:56 <mauke> can you paste the surrounding line?
17:55:21 <tehgeekmeister> to the module bit?
17:55:45 <mauke> yes
17:55:54 <tehgeekmeister> module Prime
17:55:55 <tehgeekmeister> where
17:56:03 <tehgeekmeister> that, then the definitions of the rest of the program
17:56:04 <mdmkolbe> tehgeekmeister: use hpaste
17:56:09 <mdmkolbe> @hpaste
17:56:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:56:13 <mauke> the problem is that you don't have a Main.main
17:56:25 <tehgeekmeister> i'll paste the whole thing real quick
17:57:33 <tehgeekmeister> it's pasting.
17:57:35 <hpaste>  tehgeekmeister pasted "prime.hs" at http://hpaste.org/2679
17:58:10 <LoganCapaldo> tehgeekmeister, you have to do module Main where ... or ghc prime.hs -main-is Prime
17:58:41 <tehgeekmeister> LoganCapaldo: okay, thanks.
17:59:51 <hpaste>  mauke pasted "interesting code" at http://hpaste.org/2680
18:12:29 <DannoHung> Hello
18:18:38 <dolio> @remember slava I will continue not using Python just as I have been not using it for the last 10 years.
18:18:39 <lambdabot> Done.
18:33:11 <thoughtpolice> vroom. my irc parser is working on the real stuff. :) parsec = rocks.
18:33:54 <Nafai> thoughtpolice: IRC parser?  What are you writing?
18:34:11 <thoughtpolice> Nafai: a bot, but the last version of it used some really ad hoc parsing code that was tough as hell to work with
18:34:32 <thoughtpolice> so I opted to try something new, parsec. :) worked very well, actually.
18:34:43 <Nafai> thoughtpolice: Cool; I hear good things about parsec
18:35:44 <thoughtpolice> i like it. i was able to port over the little BNF in the IRC RFC with little to no effort and it worked better than I thought it would.
18:35:53 <thoughtpolice> granted it might be kinda ugly parsec code but i'm happy, at least.\
18:36:26 <Nafai> Nice
18:36:37 <Tac-Tics> why do people hate guards?
18:37:00 <Tac-Tics> http://www.haskell.org/haskellwiki/Things_to_avoid#Guards
18:37:02 <lambdabot> Title: Things to avoid - HaskellWiki
18:37:09 <Tac-Tics> http://www.haskell.org/haskellwiki/Syntactic_sugar/Cons#Syntactic_heroin
18:37:12 <lambdabot> Title: Syntactic sugar/Cons - HaskellWiki, http://tinyurl.com/ynscfv
18:40:10 <thoughtpolice> Nafai: i'd recommend you try it sometime. makes parsing fun. :)
18:42:48 <sjanssen> Tac-Tics: I don't think that's a mainstream opinion
18:42:56 * sjanssen has a sneaking suspicion who wrote that
18:42:59 <Tac-Tics> but but... it's on the wiki!
18:43:03 <Tac-Tics> heh, who?
18:43:39 <sjanssen> oh, looks like the history predates the current wiki
18:43:53 <sior|away> sjanssen: there are a group of users that are x against syntactic sugar x
18:44:53 <sjanssen> the advice about 'if' is just plain wrong IMO
18:45:02 <sjanssen> if over guards, that is
18:45:25 <Tac-Tics> yeah
18:45:30 <sior|away> sjanssen: I agree
18:45:32 <Tac-Tics> if is horribly butchered in Haskell
18:45:37 <Tac-Tics> but it is butchered for a good reason
18:45:42 <Tac-Tics> because you have better options in haskell
18:45:58 <sior|away> There are SOME places where if just makes a more concise statement
18:47:13 <mauke> if should be a library function
18:47:46 <sioraiocht> mauke: you mean just like... if :: Bool -> a -> a ?
18:47:49 <sioraiocht> err
18:47:55 <Tac-Tics> if is just really clunky
18:47:57 <sioraiocht> mauke: you mean just like... if :: Bool -> a -> a -> a ?
18:48:05 <Tac-Tics> a function would be nice
18:48:22 <sioraiocht> it would make more sense, imo
18:48:27 <mauke> yes
18:48:51 <Pseudonym> Oh, man.
18:48:55 <sioraiocht> I mean, I guess you could even have if :: Bool -> a -> b -> c
18:48:59 <Pseudonym> Just reading that "avoid guards" thing.
18:49:06 <Pseudonym> "Use product instead!"
18:49:12 <thoughtpolice> @djinn Bool -> a -> a -> a
18:49:12 <lambdabot> f a b c =
18:49:12 <lambdabot>     case a of
18:49:12 <lambdabot>     False -> c
18:49:12 <lambdabot>     True -> b
18:49:16 <Pseudonym> Well, next time I'm writing a factorial, I will.
18:49:24 <thoughtpolice> hm. well there you go. :)
18:49:36 <Pseudonym> Meantime, back in the real world...
18:49:52 <sioraiocht> I mean, it's true, you should probably always have an "otherwise"
18:49:54 <sioraiocht> > otherwise
18:49:55 <Tac-Tics> @let if' b x y | b = x | otherwise = y
18:49:57 <lambdabot>  True
18:49:59 <Pseudonym> ?src otherwise
18:50:00 <lambdabot> Defined.
18:50:00 <lambdabot> otherwise = True
18:50:18 <Tac-Tics> > (if' False if' (not . if')) False 0 1
18:50:19 <lambdabot>  Couldn't match expected type `Bool'
18:50:23 <Pseudonym> Even more useful than if', though, is:
18:50:25 <Pseudonym> @src maybe
18:50:26 <lambdabot> maybe n _ Nothing  = n
18:50:26 <lambdabot> maybe _ f (Just x) = f x
18:50:44 <Pseudonym> It even allows a value to be associated with the equivalent of True!
18:50:49 <mauke> if' is just maybe for Bools
18:51:07 <Pseudonym> ?remember mauke if' is just maybe for Bools
18:51:08 <lambdabot> Done.
18:51:08 <mauke> ("pattern matching in a box")
18:51:16 <Pseudonym> That sounds like an Eliza response.
18:51:31 <sioraiocht> @src if
18:51:32 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:51:34 <sioraiocht> @src if'
18:51:35 <lambdabot> Source not found. Are you on drugs?
18:51:47 <Tac-Tics> > if' True 0 1
18:51:48 <lambdabot>  0
18:51:58 <sioraiocht> @stab
18:51:58 * lambdabot beats up
18:52:06 <sioraiocht> @stab lambdabot
18:52:06 * lambdabot smacks lambdabot about with a large trout
18:52:11 <Tac-Tics> @stab his lovely self
18:52:11 * lambdabot beats up his lovely self
18:52:27 <mauke> @shapr sioraiocht
18:52:27 * lambdabot slaps sioraiocht
18:52:35 <sioraiocht> hahahahaah
18:52:43 <Tac-Tics> laf
18:53:08 <allbery_b> oops
18:53:12 <sioraiocht> (n+k) patterns are the worst invention ever, imo
18:53:42 <Tac-Tics> (n+k) makes me a bit ill
18:53:45 <phobes> Have you played with my m*n + k pattern extension?
18:54:12 <mauke> I'd rather have p++s patterns
18:54:17 <allbery_b> wrong pathj
18:54:36 <phobes> and matrix patterns
18:54:50 <Tac-Tics> wouldn't p++s patterns require a nondeterministic approach of some sort?
18:55:05 <mauke> no, p is a constant
18:55:12 <Tac-Tics> ah
18:55:39 <phobes> If either p or s is constant it's deterministic though
18:56:19 <phobes> Data structures admitting multiple inductions would be nice
18:57:52 <Pseudonym> phobes: Example?
18:58:16 <phobes> Pseudonym:  Peeling elements off the back of a list is probably the simplest example
18:58:26 <Pseudonym> phobes: Check out Edison.
19:01:57 <phobes> Pseudonym: Thanks for the reference
19:02:11 <Pseudonym> No problem.
19:03:09 <phobes> This is another example to me of how pattern matching should integrate with the typeclass mechanism
19:03:19 <phobes> (Edison that is)
19:03:49 <phobes> Edison has the concepts of destructors, but it doesn't benefit from the built-in pattern matching syntax
19:04:10 <Pseudonym> Campaign for views to be added.
19:04:31 <phobes> My campaigning consists of periodic suggestions to this forum :)
19:09:56 <KatieHuber> I've just realized how completely bizarre the list-as-monad thing y'all helped me with yesterday is :|
19:10:32 <phobes> bizarre?
19:10:38 <KatieHuber> do evens <- [ 0, 2, 4 ]; odds <- [ 1, 3, 5]; return (evens, odds)
19:10:43 <KatieHuber> how the heck does that work o_O
19:10:53 <Pseudonym> KatieHuber: Do you know any Prolog?
19:10:58 <KatieHuber> yea
19:11:18 <Pseudonym> Well it's that.
19:11:22 <KatieHuber> backtracking?
19:11:25 <Pseudonym> Yeah.
19:11:31 <mauke> <- [ ... ] is a for loop
19:11:47 <Pseudonym> A Prolog and operator (comma) looks like a Pascal statement separator (semicolon), but it's actually not quite.
19:11:51 <Pseudonym> For deterministic code, it's the same.
19:11:56 <Pseudonym> For nondeterministic code, it's not quite.
19:12:01 <Pseudonym> Well, that's also true of monad bind.
19:12:04 <ari> > [0,2,4] >>= (\evens -> [1,3,5] >>= \odds -> (return (evens, odds)))
19:12:05 <lambdabot>  [(0,1),(0,3),(0,5),(2,1),(2,3),(2,5),(4,1),(4,3),(4,5)]
19:12:13 <Pseudonym> It looks like straight-line code, but it's actually a backtracking and.
19:12:28 <phobes> It's multi-valuedness.   With list,  x<-[...] means evaluate the following code with x bound to each of these.
19:12:28 <ari> @src [] (>>=)
19:12:29 <lambdabot> m >>= k     = foldr ((++) . k) [] m
19:12:49 <phobes> (and then flatten)
19:12:50 <Pseudonym> @src concatMap
19:12:50 <lambdabot> concatMap f = foldr ((++) . f) []
19:13:04 <Pseudonym> For comparison.
19:13:45 <KatieHuber> my poor imperative-mindedness that wants <- to be an assignment operator is jumping up and down and yelling and running around falling over things in my head
19:13:55 <ari> KatieHuber: That's the way I prefer to look at monads - rewrite them in desugared form and think in terms of the actual implementation of (>>=) for the monad in question
19:14:08 <Pseudonym> KatieHuber: <- is no more assignment than Prolog unification is.
19:14:35 <mauke> for evens in [0,2,4]: for odds in [1,3,5]: collect (evens, odds)
19:14:42 <Pseudonym> See, the beauty of monads is they generalise all of these things that LOOK like straight-line code.
19:14:52 <Pseudonym> That's not the only use for them, of course.
19:15:00 <Pseudonym> But that's the reasoning behind do-notation.
19:15:27 <Pseudonym> One thing that might help is not doing: x <- [1,2,3]
19:15:34 <Pseudonym> I tend to use this:
19:15:42 <Pseudonym> choose :: (MonadPlus m) => [a] -> m a
19:15:44 <Pseudonym> choose [] = mzero
19:15:51 <Pseudonym> choose (x:xs) = return x `mplus` choose xs
19:15:55 <Pseudonym> Then:
19:15:58 <Pseudonym> x <- choose [1,2,3]
19:16:11 <Pseudonym> "choose" is the implementation of the axiom of choice in Haskell.
19:16:13 <phobes> I do the same thing with 'branch' :)
19:16:20 <Pseudonym> That's why I call it "choose".
19:16:25 <dolio> Been reading Oleg?
19:16:29 <Pseudonym> Yup,.
19:16:33 <dolio> :)
19:16:36 <Pseudonym> Hey, I'm referenced in that paper!
19:16:41 <ari> :t msum . map return
19:16:43 <Pseudonym> You bet I read it.
19:16:54 <dolio> You're famous! :)
19:16:57 <Pseudonym> :-)
19:16:58 <ari> @bot
19:17:03 <lambdabot> :)
19:17:05 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
19:18:37 <phobes> I like 'branch' better than 'choose' ... for the same reason that I think describing list as capturing 'multivaluedness' is better than 'nondeterminism'
19:18:39 <oncenull> @bot
19:18:40 <lambdabot> :)
19:18:50 <pjd> KatieHuber: try reading that as "for even in [ 0, 2, 4 ]: for odd in [1, 3, 5]: return (evens, odds)"
19:18:58 <oncenull> :t map
19:19:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:19:11 <Pseudonym> phobes: The thing is, "branch" only makes sense in a truly branching monad.
19:19:15 <pjd> err, "(even, odd)"
19:19:20 <Pseudonym> It doesn't make so much sense for Maybe, for example.
19:19:23 <oncenull> :t filter
19:19:25 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:19:34 <Pseudonym> Or other MonadPluses.
19:19:49 <ari> I'd rather like amb as a name for msum . map return
19:20:04 <Pseudonym> amb?
19:20:14 <pjd> Pseudonym: as in Lisp
19:20:14 <ari> http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-16.html#node_chap_14
19:20:17 <lambdabot> Title: Teach Yourself Scheme in Fixnum Days, http://tinyurl.com/hyw76
19:20:18 <Pseudonym> Ah, right.
19:20:23 <pjd> McCarthy's operator
19:20:37 <Pseudonym> It's just cryptic enough to be a Lisp operator, too.
19:20:53 <dolio> 'choose' also has the danger of being confused with the combinatorial operator, but I suppose you have to make decisions like that.
19:20:55 <pjd> ambiguous, even :)
19:21:26 <Tac-Tics2> So, let's say I'm *still* trying to compile Yi from source. Cabal is looking for regex-base-0.72. Hackage only offers 0.71, 0.83, and 0.9+
19:21:29 <Pseudonym> Perhaps "choice" is better.
19:21:30 <Tac-Tics2> what do I do?
19:21:35 <Tac-Tics2> it's looking for exactly 0.72
19:21:36 <Pseudonym> Make a nondeterministic choice from these values.
19:22:44 <phobes> I dunno... I still like 'branch'.   I think it makes sense with Maybe too... List is the monad that explores all branches, Maybe just the first one
19:23:38 <sorear> .
19:23:46 <pjd> phobes: Maybe is just List specialized to length 0 or 1
19:24:05 <phobes> pjd: right?
19:24:14 <dibblego> data List a = EmptyList | ListWithOne a
19:24:24 <dolio> I belive Cale uses "option" in his sudoku solver.
19:24:51 <dibblego> Option is Maybe in Scala
19:24:57 <pjd> phobes: Nothing == [], Just x == [x]
19:25:05 <dolio> ML, too, I think.
19:25:21 <dibblego> http://www.scala-lang.org/docu/files/api/scala/Option.html
19:25:22 <lambdabot> Title: class Option in scala
19:25:23 <dolio> 'Maybe a' is 'a option'
19:25:28 <mauke> type 'a option = None | Some of 'a
19:25:33 <phobes> pjd: I think I understand... did I say something wrong that you're disagreeing with?
19:25:44 <Pseudonym> Anyway, whatever this function is called (bikeshed and all that), it should probably go in Control.Monad or something.
19:26:07 <pjd> phobes: no, i'm just saying Maybe is really no different to List :)
19:26:46 <phobes> pjd:  The resolution case of branch (Just x) (just y) is interesting... there are really two choices
19:26:49 <pjd> i.e. Maybe also explores all branches, exactly like List
19:27:13 <phobes> pjd:  No - it picks one whenever there are two non-nothing branches
19:27:39 <pjd> phobes: oh, in terms of msum?
19:27:40 <pjd> right
19:28:07 <phobes> ya
19:28:14 <pjd> i was only talking about the Monad instance, sorry
19:28:44 <Pseudonym> Lunch.  BBS
19:28:47 * pjd returns to the peanut gallery
19:32:32 <BMeph> pl \l a -> catA ( fmap (hasText) l) a
19:34:07 <mauke> catA . fmap hasText
19:34:38 <BMeph> Well, thank you.
19:34:52 <sorear> Tac-Tics2: Why do you want yi?
19:34:59 <sfultong> @bot
19:34:59 <lambdabot> :)
19:35:18 <sorear> hello sfultong
19:35:27 <sfultong> hello sorear
19:35:41 <sfultong> > "hi everyone" >>= id
19:35:42 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Char'
19:35:55 <sfultong> > return "everyone" >>= id
19:35:57 <BMeph> @pl \l a -> catA ( fmap (hasText) l) a
19:35:57 <lambdabot>  "everyone"
19:35:58 <lambdabot> catA . fmap hasText
19:36:21 <sfultong> how's the current level of sorear-ness?
19:36:58 <CosmicRay> ok, I feel silly about this, but what is the way to make this do its intended thing?
19:37:02 <CosmicRay> test4 :: forall a. Eq a => (a -> a -> Bool) -> Bool
19:37:02 <CosmicRay> test4 f = f (1::Int) (2::Int)
19:37:16 <CosmicRay> I know what the problem is here....
19:37:42 <CosmicRay> 'a' must obviously be some specific type, but any type, and Int is a specific type
19:38:23 <ramza3> hmm, I didnt know vim could open webpages
19:38:24 <CosmicRay> what I really want is to be able to take a function that can take Eq a => (a -> a -> Bool) and call it with specific values of different types, all Eq, and return a list of results.
19:38:42 <sfultong> does anyone think it's poor form to pass an STM block through a TChan to be evaluated in another STM block?
19:39:12 <CosmicRay> test4 :: forall a. Eq a => (a -> a -> Bool) -> [Bool]
19:39:12 <CosmicRay> test4 f = [f 1 (2::Int), f 5 (5::Integer)]
19:39:14 <phobes> test4 :: (forall a. Eq a => a -> a -> Bool) -> Bool
19:39:19 <mauke> test4 :: (forall a. a -> a -> Bool) -> Bool
19:39:28 * CosmicRay tries
19:39:36 <CosmicRay> now where would I have learned about that?
19:40:04 <phobes> You need to have the extensions enabled that allow higher rank types
19:40:08 <tehgeekmeister> ?isHexDigit
19:40:08 <tehgeekmeister> errr
19:40:08 <CosmicRay> I do
19:40:08 <lambdabot> Unknown command, try @list
19:40:15 <tehgeekmeister> ?src isHexDigit
19:40:15 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:40:17 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#universal-quantification
19:40:19 <sfultong> > (repeat . repeat) 'a' >>= id
19:40:19 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
19:40:20 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
19:40:33 <CosmicRay> phobes: type inference can not figure this out if I leave off the type signature as well.
19:40:39 <mauke> sfultong: >>= id is join
19:40:40 <kfish> @botsnack
19:40:40 <lambdabot> :)
19:40:50 <CosmicRay> phobes: I thought that I could cheat by leaving off the type signature and then use :t in ghci, but it didn't like it
19:40:56 <sfultong> mauke: oh! huh, handy to know that
19:41:04 <mauke> CosmicRay: rank-n type inference is undecidable
19:45:34 <phobes> CosmicRay: Ya, because rank-n type inference is undecidable, ghc doesn't even try AFAICT
19:45:58 <CosmicRay> ah.
19:46:27 <phobes> If you just write 'test4 f = f 1::Int 2::Int', you'll get test4 :: (Int -> Int -> a) -> a
19:46:29 <mauke> rank-2 is decidable but too complicated
19:46:54 <CosmicRay> right
19:48:46 <sorear> rank-2 is decidable?
19:48:58 <sfultong> > join . repeat . repeat $ 'a'
19:49:10 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
19:49:16 * Caelum is really liking the "programming in haskell" book, though only a third of the way through so far...
19:50:38 <phobes> sorear:  According to wikipedia (http://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Rank-1_.28Prenex.29_Polymorphism) "Type reconstruction for rank-2 polymorphism is decidable, but reconstruction for rank-3 and above is not."
19:50:40 <lambdabot> http://tinyurl.com/5nzkq
19:51:09 <sorear> phobes: Does the Wikipedia language include let-expressions?
19:51:24 <sorear> phobes: Rank-1 with let is equivalent to rank-2 without
19:51:57 <phobes> sorear: I think you can imagine what the wikipedia article says about let-expressions
19:52:22 <sorear> ?
19:53:19 <phobes> sorear:  nm... so rank-2 with let is undecidable?
19:53:28 * sfultong can't imagine what wikipedia says about let-expressions
19:53:36 <sorear> phobes: don't know
19:59:42 <tally> is it possible to keep adding to a String using recursion?
20:00:21 <sfultong> tally: sure, with recursion everything in possible; Everything.
20:00:53 <tally> lol, basically within my recursion I have if if x < 'a' then x:""
20:01:09 <tally> (yes, I'm making something to grab all of the capital letters)
20:01:51 <tally> but it seems that it will only keep one capital letter at a time
20:03:23 <sfultong> > filter (< 'a') "I'm a Sentence with Many Capitals"
20:03:25 <lambdabot>  "I'  S  M C"
20:03:25 <monochrom> Like you pass in "AbCCd" it returns "ACC"?
20:03:37 <tally> yeah
20:03:51 <tally> we haven't learned filter yet, I think he wants us to basically write filter
20:04:06 <sfultong> silly formal education
20:04:08 <monochrom> If you do not want to use library code (filter), if you want to write one yourself, here is the right approach.
20:04:20 <monochrom> f "" = ""
20:04:28 <ramza3> I want to do some haskell development in work (secure environment), but need ghc that doesnt require an install of if I need admin rights.  Ideally I was looking to use ghc.  Anybody know where I download one and just run the compiler/interpreter?
20:04:33 <ramza3> on win32?
20:04:54 <monochrom> f (c:cs) = if upper c then c : f cs  else f cs
20:05:16 <monochrom> I have to make sure "upper" is the right name for that test-for-uppercase
20:05:41 <TSC> isUpper ?
20:05:49 * sfultong should make a Prelude functions flashcard-type program
20:05:50 <monochrom> it's called "isUpper". You have to "import Data.Char".
20:06:25 <monochrom> Anyway, you see the idea is not "let me keep a String state, and keep appending to it". No, no, no no no.
20:06:38 <tally> ah, and that is what I'm trying to do I think
20:06:49 * araujo wonders if someone knows a program to calculate integral equations
20:07:29 <monochrom> Rather, it is: "let me return c : f cs, c is the first character I want to appear in the list, f cs is the rest of the list"
20:07:53 <sorear> araujo: irssi works for me
20:07:56 <tally> so.. I need to make a whole new function?
20:08:11 <monochrom> No, it's f again.
20:08:37 <monochrom> "f cs" is a recursive call to yourself.
20:08:58 <araujo> sorear, irssi? ... the irc client? :-P
20:09:46 <sfultong> "recursive call to yourself" -- self conscious?
20:10:05 <tally> what is link to that hpaste thing? because I think I'm kinda doing what you're saying but I'm not sure
20:10:12 <monochrom> @paste
20:10:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:10:14 <Caelum> that's what self consciousness is
20:10:46 <monochrom> walmart ??? !!!   <scary>
20:10:54 <sfultong> yeah, and self-conscious is inherently dangerous because of that
20:11:17 <hpaste>  tally pasted "is it the " at http://hpaste.org/2681
20:11:17 <jbauman> araujo, octave, maybe? i've never used it, though
20:11:53 <araujo> jbauman, i am looking something to work with differential equations mainly
20:12:02 <monochrom> if x<'a' then x:uppers xs else <you're right in this part>
20:12:11 <jbauman> expensive or free?
20:12:16 <phobes> Is there anyway to write a partially inferenced declaration like:    foo f :: (forall a. a->a->a) x = f 0 x            ?
20:12:54 <sorear> phobes: Yes.
20:12:57 <tally> awesome, I see, thanks monochrom!
20:13:08 <sorear> phobes: foo (f :: forall a. a -> a -> a) x = f 0 x
20:13:09 <araujo> jbauman, free software of course
20:13:24 <phobes> sorear: ah thanks, couldn't get the syntax right
20:13:30 <jbauman> i don't know of any then, sorry
20:13:45 * araujo just found euler
20:14:00 <monochrom> How's his eyes lately? :)
20:16:47 <araujo> jbauman, octave seems enough good
20:17:51 * araujo wanted something ... more haskell'ish
20:19:08 <Hrumph> hi
20:19:16 <Hrumph> does haskel have restricted execution?
20:19:30 <Hrumph> sandboxing or whatever you want to call it
20:19:39 <araujo> uh?
20:20:01 <Hrumph> is haskel compiled or interpreted?
20:20:07 <jbauman> either
20:20:22 <Hrumph> ok for interpreted haskel can you run it in a mode that restricts what can be done
20:20:30 <araujo> Hrumph, there are either Haskell interpreters and compilers
20:20:31 <jbauman> i guess you could not put code in the io monad
20:20:41 <araujo> Hrumph, compilers being the most popular ones
20:20:41 <dibblego> lambdabot is effectively sandboxed
20:20:43 <ari> Hrumph: Both for interpreted and compiled, yes
20:21:05 <Hrumph> where can i learn more of lambdabot?
20:21:16 <ari> @where lambdabot
20:21:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:21:16 * araujo doesn't understand this question
20:21:30 <ari> > print "hello" -- safely handled
20:21:42 <lambdabot>  <IO ()>
20:22:05 <Adamant> by restricting IO monad use, lambdabot is sandboxed, just not in the traditional manner
20:22:20 <sfultong> outside the IO monad, nothing exists
20:22:27 <Hrumph> can i easily embed this thin i a gtk window?
20:22:42 <araujo> uH?
20:22:53 <Hrumph> like i said
20:23:17 <Hrumph> editor isn't perfectly clear
20:23:21 <Hrumph> ok like a gtktextview
20:23:23 <sfultong> Hrumph: I believe some elaboration on what you're trying to attain is necessary
20:23:33 <newsham> the chakravarty/comp4181 slides are great.  too bad there's no video recording.  someone at unsw should recommend it :)
20:35:05 <market_hacker_> test
20:36:01 <sorear> market_hacker_: eeeaawwweeeeaaawwww
20:36:53 <reffje> can anyone read chinese
20:40:22 <Tac-Tics2> @where (+++)
20:40:23 <lambdabot> I know nothing about (+++).
20:40:30 <Tac-Tics2> you wouldn't
20:40:34 <Tac-Tics2> @src (+++)
20:40:34 <lambdabot> Source not found. You type like i drive.
20:40:51 <allbery_b> @source (+++)
20:40:51 <lambdabot> (+++) not available
20:40:58 <allbery_b> oh, duh
20:41:02 <allbery_b> @source Control.Arrow
20:41:02 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
20:41:31 <Tac-Tics2> I think this is the parser I'm looking at
20:42:03 <mauke> @index (+++)
20:42:04 <lambdabot> Control.Arrow, Text.Html, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
20:46:16 <KatieHuber> is there a built-in function that distributes the elements of a list as new heads of the lists in a list of lists?
20:46:20 <KatieHuber> was that even English?
20:46:41 <newsham> can you explain (example?)?
20:46:46 <mauke> [1,2,3] -> [[1],[2],[3]]?
20:46:48 <KatieHuber> and if there was, how would I know there was?  can I somehow look up functions by signature? ([a] -> [[a]] -> [[a]])
20:47:09 <newsham> ?hoogle [a] -> [[a]] -> [[a]]
20:47:09 <mauke> @hoogle [a] -> [[a]] -> [[a]]
20:47:13 <lambdabot> No matches, try a more general search
20:47:13 <lambdabot> No matches, try a more general search
20:47:22 <KatieHuber> like, [1, 2, 3] -> [[4], [5], [6]] -> [[1, 4], [2, 5], [3, 6]]
20:47:38 <mauke> :t zipWith (:)
20:47:40 <lambdabot> forall a. [a] -> [[a]] -> [[a]]
20:47:52 <KatieHuber> neat :)
20:48:00 <KatieHuber> thanks
20:48:09 <allbery_b> > zipWIth [1,2,3] [[4],[5],[6]]
20:48:10 <lambdabot>   Not in scope: `zipWIth'
20:48:18 <allbery_b> > zipWith [1,2,3] [[4],[5],[6]]
20:48:19 <lambdabot>  Couldn't match expected type `a -> b -> c'
20:48:24 <allbery_b> durr
20:48:25 <newsham> zipwith takes a function
20:48:27 <allbery_b> can't type tonight
20:48:33 <allbery_b> > zipWith (:) [1,2,3] [[4],[5],[6]]
20:48:35 <lambdabot>  [[1,4],[2,5],[3,6]]
20:48:47 <kfish> KatieHuber, the search engine Hoogle can find functions and documentation by type signature or name, which is useful
20:49:00 <kfish> KatieHuber, but #haskell goes a step further and solves the problem for you, often in stereo
20:49:16 <newsham> zipWith == super vector lifter doodad
20:49:47 <newsham> vectorCons!
20:51:37 <newsham> ?let vlift = map
20:51:41 <lambdabot> Defined.
20:51:42 <newsham> ?let vlift2 = zipWith
20:51:46 <lambdabot> Defined.
20:52:19 <mauke> ?let liftM1 = liftM
20:52:20 <lambdabot> <local>:18:9:     Ambiguous type variable `m' in the constraint:       `Monad...
20:52:20 <newsham> > vlift head $ vlift (:) [1,2,3] [[4], [5,6], []]
20:52:21 <lambdabot>  Couldn't match expected type `[[t]] -> [[a]]'
20:52:27 <newsham> > vlift head $ vlift2 (:) [1,2,3] [[4], [5,6], []]
20:52:28 <lambdabot>  [1,2,3]
20:52:36 <mauke> ?let liftM1 x = liftM x
20:52:40 <lambdabot> Defined.
20:52:43 <mauke> ?let liftM0 x = return x
20:52:48 <lambdabot> Defined.
20:53:12 <newsham> > vlift2 (+) [1,2,3] [5,5,1]
20:53:13 <lambdabot>  [6,7,4]
20:53:35 <mauke> > liftM2 (+) [1,2,3] [5,5,1]
20:53:37 <lambdabot>  [6,6,2,7,7,3,8,8,4]
20:54:28 <newsham> you got your cartesian in my vector
20:55:14 <mauke> *Main> ZipList [1,2,3] + ZipList [5,5,1]
20:55:14 <mauke> ZipList [6,7,4]
20:55:32 <newsham> whats that?
20:55:37 <mauke> powered by http://mauke.ath.cx/stuff/haskell/fun.hs
20:56:15 <newsham> ZipList [1,2,3] : ZipList [[4], [5,6], []]    ?
20:56:44 <mauke> type error
20:57:04 <mauke> newtype ZipList a = ZipList {getZipList :: [a]}
20:57:31 <newsham> > [1,2,3] `zipWith (:)` [[4], [5,6], []]
20:57:32 <lambdabot>  Parse error
20:57:47 <mauke> `` wants identifiers
20:57:56 <newsham> yah, that woulda been too easy. :\
20:58:55 <newsham> > let zcons = zipWith (:) in [1,2,3] `zcons` [[4], [5,6], []]
20:58:58 <lambdabot>  [[1,4],[2,5,6],[3]]
21:02:10 <newsham> err.. meant vcons not zcons..
21:04:42 <KatieHuber> can a haskell class have two types?
21:05:00 <mauke> two parameters you mean?
21:05:00 <KatieHuber> never mind, yes :)
21:05:08 <KatieHuber> like Data.Map
21:05:18 <mauke> not in H98
21:05:21 <mauke> that's not a class
21:05:29 <KatieHuber> oh, neither it is :|
21:06:42 <KatieHuber> I don't think I even know what I'm wanting :|
21:07:27 <KatieHuber> like, class IndexableCollectionOfInts c i where index :: c -> i -> Int
21:07:56 <KatieHuber> seems like there must be a better way to describe that
21:08:06 <mauke> you probably want a functional dependency there
21:08:31 <mauke> class IntMap c i | c -> i where lookup :: c -> i -> Int
21:12:00 <KatieHuber> looks like what I want, but what does it mean?
21:12:28 <mauke> "c -> i" means: c uniquely determines i
21:13:19 <mauke> http://haskell.org/haskellwiki/Functional_dependencies
21:13:20 <lambdabot> Title: Functional dependencies - HaskellWiki
21:26:20 <tehgeekmeister> ?src foldM
21:26:20 <lambdabot> foldM _ a []     = return a
21:26:20 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
21:27:35 <KatieHuber> thanks mauke that's exactly what I was after :)
21:38:11 <dons> ?users
21:38:11 <lambdabot> Maximum users seen in #haskell: 402, currently: 367 (91.3%), active: 7 (1.9%)
21:42:36 <Heffalump> morning
21:42:46 <kfish> moin
21:46:45 <tehgeekmeister> ?src group
21:46:45 <lambdabot> group = groupBy (==)
21:46:53 <tehgeekmeister> ?src groupBy
21:46:53 <lambdabot> groupBy _  []       =  []
21:46:53 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:46:53 <lambdabot>     where (ys,zs) = span (eq x) xs
21:55:24 <tehgeekmeister> ?src span
21:55:24 <lambdabot> Source not found. Where did you learn to type?
21:58:37 <goalieca> ?src lambdabot
21:58:37 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:58:45 <goalieca> :(
22:03:56 <TSC> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot (:
22:03:57 <lambdabot> Title: Index of /~dons/lambdabot
22:04:30 <Pseudonym> The (: is important.
22:04:39 <Pseudonym> darcs doesn't work unless you smile.
22:06:33 <kfish> @botsnack
22:06:33 <lambdabot> :)
22:08:14 <dons> ?version
22:08:14 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
22:08:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:23:17 * hgolden is away: sleep
22:23:29 <tehgeekmeister> Pseudonym: darcs doesn't work unless you smile?!
22:38:28 <TSC> Fortunately, darcs makes you smile anyway
22:40:26 <bos> that's a rictus, not a smile.
22:48:30 <tehgeekmeister> ?src foldM
22:48:31 <lambdabot> foldM _ a []     = return a
22:48:31 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
23:06:23 <takamura> morning
23:22:01 <dancor> what is the best way to get into quickcheck.  it seems odd that the cabal package doesn't come with http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck
23:22:24 <Pseudonym> dancor: I tend to just write a "doCheck" function.
23:23:45 <Cale> dancor: Are you talking about installing quickcheck? It comes with GHC, typically.
23:27:04 <dancor> i'll keep playing around.  here is another question, am i tool for wanting to do   import qualified Data.Maybe as Myb
23:33:10 <Pseudonym> Why do you want to do that?
23:35:46 <dancor> Pseudonym: i want to be able to easily go from a function to where it is defined
23:36:04 <dancor> i want it to be obvious if i have imported something that i later don't need
23:36:17 <mauke> ghc will warn you about that anyway
23:36:18 <dancor> things like that
23:37:03 <dancor> mauke: ghc 6.6 does not seem to
23:37:23 <mauke> try -Wall
23:37:52 <dancor> ah, i had to touch the file before recompiling
23:38:02 <allbery_b> if using --make, sure
23:38:12 <dancor> allbery_b: not using make
23:38:18 <allbery_b> hm
23:38:20 <dancor> pima ~/p/hs/Test ghc -Wall src/Main.hs
23:38:20 <dancor> compilation IS NOT required
23:38:32 <allbery_b> didn't think it did recomp checks in normal mode
23:38:46 <dancor> it's that into laziness
23:50:45 <tuxplorer> Any pointers to any tutorials as to how to write out XML with HaXML?
23:54:25 <dons> tuxplorer: there's some blog articles about it on haskell.org
23:54:31 <dons> look for XML under 'blog articles'
