00:00:01 <Lycurgus_> or to confirm the lack/use of straight make and the like
00:00:49 * Lemmih doesn't know what ant or asdf are.
00:01:09 <Lycurgus_> the java and lisp build utilities respectively
00:02:06 <Lemmih> And Cabal is not equivalent?
00:03:14 <osfameron> ant is the (verbose) equivalent of make
00:03:27 <coffeemug> Lycurgus_: but asdf serves a different purpose
00:03:31 <osfameron> the lack of a version of make written in $language isn't really a big problem, given that make exists
00:03:45 <coffeemug> Lycurgus_: CL doesn't manage dependencies automatically, while Haskell and Java do
00:04:40 <coffeemug> Lycurgus_: other than that you can simply use Cabal
00:04:56 <Lycurgus_> yeah, on second look I guess maybe Cabal is the Haskell cognate
00:06:14 <Lycurgus_> coffeemug: CL doesn't but asdf does
00:06:59 <Lycurgus_> every lang culture has norms that heavily impact this activity
00:07:37 <Lycurgus_> lisp is extremely fractious which impacts it there
00:09:48 <Lycurgus_> fractious wasn't the right word, can't think of appropriate one
00:15:19 <Pseudonym> ?pl \f -> join . fmap f . return
00:15:19 <lambdabot> id
00:15:25 <Pseudonym> That's some optimisation.
00:16:28 <Pseudonym> ?pl join . return
00:16:28 <lambdabot> id
00:16:47 <fax> yucky :(
00:16:56 <fax> I had to add a boolean to one my parsers, withComma
00:22:46 <paolino> why maximum is in terms of foldl and overflows stack eventually ?
00:28:02 <fax> paolino: maximum with foldr [1..], is like max 1 (max 2 (max 3 ....
00:28:27 <fax> so it needs more and more space.. It can't evaluate any of the max's until it's at the end of the list
00:28:54 <fax> Whereas maxmimum with foldl [1..] is like max (max ... (max 1 2) 3) ...
00:29:32 <fax> So when it's evaluated you start with max 1 2, then max <that> 3, max <that> 4... It only uses up constant space instead of linear in relation to the length of the list
00:30:33 <fax> paolino: Did that make sense
00:31:48 <eck> if it uses constant space then how would it overflow the stack?
00:32:17 <fax> It doesn't and that's why it doesn't overflow the stack
00:32:28 <fax> foldr does, foldl doesn't
00:33:04 <fax> er I meant, It doesn't overflow the stack because It uses constant space
00:33:33 <doserj> foldl does overflow when the strictness analyzer doesn't jump in.
00:41:27 <doserj> @src maximum
00:41:28 <lambdabot> maximum [] = undefined
00:41:28 <lambdabot> maximum xs = foldl1 max xs
00:45:00 <wli> Gah, there's no point in writing maximum [] = undefined
00:45:21 <wli> One should write something like maximum [] = error "maximum of empty list undefined"
00:45:44 <fax> > case maximum [] of undefined -> "test"
00:45:46 <lambdabot>  "test"
00:45:49 <wli> At least drop a hint as to what the offending call was.
00:45:51 <fax> hm
00:46:01 <fax> :t undefined
00:46:03 <lambdabot> forall a. a
00:46:17 <igel> how can you apply pattern-matching to undefined?
00:46:23 <igel> its no constructor, is it?
00:46:56 <wli> You don't get to do tests like that on compiled programs that crap out on people at runtime.
00:47:19 <wli> Even supposing it's actually valid or otherwise works for whatever reason.
00:48:33 <igel> > case undefined of undefined -> "test"
00:48:35 <lambdabot>  "test"
00:48:44 <lament> > undefined == undefined
00:48:45 <lambdabot>  Undefined
00:48:47 <fax> @type let f [] = error "foo" ; f x = [1] in f
00:48:49 <lambdabot> forall t t1. (Num t1) => [t] -> [t1]
00:48:50 <igel> > case error "" of (error _) -> "test"
00:48:51 <lambdabot>  Parse error in pattern
00:48:59 <igel> > case error "" of error -> "test"
00:49:00 <lambdabot>  "test"
00:49:10 <igel> > case error "" of undefined -> "test"
00:49:11 <lambdabot>  "test"
00:49:22 <igel> this is weird...
00:49:25 <fax> :t error ""
00:49:27 <fax> :t undefined
00:49:27 <lambdabot> forall a. a
00:49:29 <lambdabot> forall a. a
00:49:46 <igel> @src undefined
00:49:46 <lambdabot> undefined =  error "Prelude.undefined"
00:49:50 <igel> ^^
00:49:52 <lament> :t error
00:49:54 <lambdabot> forall a. [Char] -> a
00:50:18 <lament> @src error
00:50:18 <lambdabot> error s = throw (ErrorCall s)
00:50:29 <lament> :t ErrorCall
00:50:31 <lambdabot> Not in scope: data constructor `ErrorCall'
00:50:50 <igel> this should be a constructor of Exception
00:51:03 <lament> :t Exception.ErrorCall
00:51:05 <lambdabot> Couldn't find qualified module.
00:51:10 <lament> blah :)
00:51:17 <igel> :)
00:54:08 <paolino> and foldl makes sense ?
00:57:18 <paolino> @src foldl
00:57:18 <lambdabot> foldl f z xs = lgo z xs
00:57:18 <lambdabot>     where lgo z []     =  z
00:57:18 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
00:57:40 <paolino> @src foldr
00:57:40 <lambdabot> foldr k z xs = go xs
00:57:40 <lambdabot>     where go []     = z
00:57:40 <lambdabot>           go (y:ys) = y `k` go ys
00:58:45 <cmcq> > foldl1 max [1..1000000]
00:58:56 <lambdabot>  1000000
00:59:57 <cmcq> > foldr1 max [1..1000000]
00:59:59 <lambdabot>  Exception: stack overflow
01:00:11 <fax> > foldl1 max (reverse [1..1000000]) -- :D
01:00:13 <lambdabot>  1000000
01:00:27 <fax> not the same is it?
01:00:31 <fax> as foldr1?
01:02:31 <paolino>  > foldl1 max (map (+1) [1..300000])
01:02:56 <paolino> > foldl1 max (map (+1) [1..300000])
01:02:58 <lambdabot>  300001
01:03:08 <paolino> mmhh
01:03:42 <paolino> fax, they both overflows here
01:04:10 <fax> > (+1)$ foldl1 max [1..300000]
01:04:11 <lambdabot>  300001
01:04:12 <swix> how is foldr1 different from foldr? only one item?
01:04:37 <wli> Try foldl1'
01:04:40 <paolino> @src foldl'
01:04:40 <lambdabot> foldl' f a []     = a
01:04:40 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
01:05:09 <paolino> wli foldr can't be strict right ?
01:05:56 <wli> Not sure to be honest. My wild guess is you could make a strict version, but it would be a problem because it doesn't really work the right way for strictness.
01:07:12 <wli> You'd have to unwind a stack for a strict foldr the same way a non-strict foldl has to.
01:07:29 <wli> Or so it seems to me upon cursory examination.
01:09:00 <paolino> > foldl1 max (map (+1) [1..3000000])
01:09:02 <lambdabot>  3000001
01:09:38 <wli> > foldl1' max $ map (+1) [1..3000000]
01:09:40 <lambdabot>  3000001
01:09:44 <fax> > foldl1 (\x y-> max ((+1) x) ((+1) y)) [1..3000000]
01:09:46 <lambdabot>  3000001
01:38:31 <tibbe> could someone describe some use cases of fmap to me
01:38:34 <tibbe> I never use it
01:38:36 <tibbe> :t fmap
01:38:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:38:55 <tibbe> use it with monads since they are functors?
01:39:11 <tibbe> but for what?
01:40:59 <oerjan> note that for monads, fmap = liftM
01:41:24 <wli> Well, the type constraints are different.
01:41:33 <wli> :t fmap
01:41:34 <wli> :t liftM
01:41:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:41:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:41:41 <oerjan> and you often use the latter instead to avoid an extra constraint
01:42:14 <sieni> @src fmap
01:42:15 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:42:20 <wli> Since there's no class Functor m => Monad m constraint (or vice-versa) they're both sort of specialized to their own domain.
01:42:20 <sieni> @src liftM
01:42:20 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:42:23 <oerjan> @src Functor
01:42:24 <lambdabot> class  Functor f  where
01:42:24 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
01:42:29 <sieni> aa
01:43:11 <wli> The practical reality, of course, is that Monad m is typically accompanied by Functor m and fmap and liftM coincide.
01:47:46 <paolino> @pl \(x1,y1) (x2,y2) -> (x1*x2,y1*y2)
01:47:47 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (*)) . flip . (((.) . (,)) .) . (*))
01:48:04 <sieni> how lovely
01:48:15 * paolino doesn't believe pl
01:48:26 <sieni> @unpl uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (*)) . flip . (((.) . (,)) .) . (*))
01:48:26 <lambdabot> uncurry (\ ab f -> (\ p x -> ((,)) (ab * (fst p)) (f * x)) >>= \ ag -> snd >>= \ af -> return (ag af))
01:48:27 <fax> sometimes pointless is not better
01:48:42 <wli> :t \(x1,y1) (x2,y2) -> (x1*x2,y1*y2)
01:48:44 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1) -> (t, t1) -> (t, t1)
01:48:50 <fax> @pl uncurry (\ ab f -> (\ p x -> ((,)) (ab * (fst p)) (f * x)) >>= \ ag -> snd >>= \ af -> return (ag af))
01:48:50 <lambdabot> uncurry (flip flip ((snd >>=) . (return .)) . ((>>=) .) . (. (*)) . flip . (((.) . (,)) .) . (. fst) . (*))
01:49:33 <fax> Is there some expression which gets bigger every time you @pl @unpl it?
01:53:05 <tibbe> alright
01:53:11 <oerjan> > uncurry (join(liftM2(***))(*)) (1,2) (5,10)
01:53:12 <lambdabot>  Couldn't match expected type `(t1, t2) -> t'
01:53:19 <oerjan> darn
01:53:24 <wli> @src (***)
01:53:24 <lambdabot> f *** g = first f >>> second g
01:54:50 <oerjan> oh wait
01:55:12 <oerjan> > curry (join(liftM2(***))(flip id(*))) (1,2) (5,10)
01:55:13 <lambdabot>  Couldn't match expected type `(a, b)'
01:55:43 <oerjan> there _was_ something like this
01:56:03 <oerjan> > uncurry (join(liftM2(***))(flip id(*))) (1,2) (5,10)
01:56:03 <lambdabot>  Couldn't match expected type `(t1, t2) -> t'
01:58:10 <oerjan> > (uncurry (***) . join (***) (*)) (1,2) (5,10)
01:58:11 <lambdabot>  (5,20)
01:59:09 <oerjan> essentially uncurry (***) and join (***) are the applicative <*> and fmap for (a,a)
01:59:30 <wli> :t curry $ \((x1,y1),(x2,y2)) -> join (***) (uncurry (*)) ((x1, x2), (y1, y2))
01:59:32 <lambdabot> forall a. (Num a) => (a, a) -> (a, a) -> (a, a)
02:02:33 <oerjan> > (join (***) (uncurry (*))) (1,2) (5,10)
02:02:34 <lambdabot>  Couldn't match expected type `t1 -> t'
02:03:57 <wli> @pl \((x1, x2), (y1, y2)) -> ((x1, x2), (y1, y2))
02:03:58 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (,) . (((.) . (.) . (,)) .) . (,)))
02:04:33 <wli> Not terribly promising.
02:04:44 <oerjan> you could say that :D
02:05:36 <wli> Thus far I have \(x1,y1) (x2,y2) -> join (***) (uncurry (*)) ((,) ((,) x1 x2) ((,) y1 y2))
02:05:51 <mux> the output of @pl makes me think that programming in FP must be quite horrible; though I never used this language myself I think it is all about function composition etc, and that you can't name arguments, right?
02:05:57 <oerjan> you didn't see my solution?
02:06:03 <wli> oerjan: No.
02:06:19 <oerjan> > (uncurry (***) . join (***) (*)) (1,2) (5,10)
02:06:24 <lambdabot>  (5,20)
02:07:02 <oerjan> oerjan> essentially uncurry (***) and join (***) are the applicative <*> and fmap for (a,a)
02:07:33 <wli> oerjan: uncurry (***) . join (***) (*) is slick.
02:07:45 <oerjan> but i've seen something like it before by someone else.
02:08:12 <wli> oerjan: Any tips on pointfree quaternion multiplication? ;)
02:08:22 <oerjan> argh!
02:08:59 <wli> oerjan: Octonion multiplication? ;)
02:09:04 <oerjan> use lists and a matrix
02:09:09 <mux> hasn't point-free code with more than 3 parameters been forbidden by the high council for programming sanity?
02:09:16 <mux> :)
02:09:30 <wli> Not that I'm aware of.
02:09:56 <quicksilver> pointfree code is mostly only attractive when there is one running parameter
02:09:59 <oerjan> mux: it only applies to those who are sane.
02:10:00 <quicksilver> i.e. pipeline style
02:10:28 <mux> quicksilver: yeah, I fully agree
02:11:02 <mux> with more than one parameter, it generally amounts to obfuscation
02:11:43 <wli> I think it's something like \(c1, i1, j1, k1) (c2, i2, j2, k2) -> (c1 * c2, j1 * k2 - j2 * k1, k1 * i2 - i1 * k2, i1 * j2 - i2 * j1)
02:11:44 <oerjan> i think it is somewhat limited by the fact there is no pointfree handling of 3-tuples etc.
02:11:56 <wli> oerjan: Oh, hang on.
02:12:17 <wli> http://holomorphy.com/~wli/Untuple.hs
02:13:06 <wli> oerjan: Not sure what else is needed for pointfree handling of higher tuples.
02:13:08 * oerjan almost expected a Sith in there.
02:13:17 <liyang> Hm. Morning.
02:13:51 <oerjan> i guess in principle that is enough
02:15:37 <oerjan> i think that should be c1 * c2 - i1*i2 - j1 * j2 - k1 * k2 or something
02:16:12 <wli> Okay, done.
02:16:21 <wli> oerjan: refresh
02:16:35 <wli> oerjan: Duh, thanks.
02:17:00 <oerjan> oh, and c1*i2 + c2*i1 added to the second one, etc.
02:17:19 <wli> oerjan: with analogues all the way through
02:18:09 <oerjan> essentially every two terms are multiplied somewhere
02:18:24 <wli> \(c1, i1, j1, k1) (c2, i2, j2, k2) -> (c1 * c2 - i1 * i2 - j1 * j2 - k1 * k2, c1 * i2 + c2 * i1 + j1 * k2 - j2 * k1, c1 * j2 + c2 * j1 + k1 * i2 - i1 * k2, c1 * k2 + c2 * k1 + i1 * j2 - i2 * j1)
02:19:19 <wli> I could still have signs wrong.
02:19:40 <wli> oerjan: I added curry and uncurry for higher tuples to Untuple.hs
02:19:58 <oerjan> yeah
02:20:13 <oerjan> now you need the analogies to *** and &&& >:)
02:20:41 <wli> oerjan: Well, there aren't n-ary operators, so *** and &&& analogues don't look quite so pretty.
02:21:06 <wli> oerjan: There also need to be analogues of first, second, (|||), etc.
02:21:18 <oerjan> :t (|||)
02:21:20 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
02:21:38 <wli> (|||) gets thorny because a sort of standard n-ary coproduct doesn't exist.
02:22:16 <wli> Do (***) and (&&&) have non-symbolic names?
02:22:26 <oerjan> no idea
02:23:03 <quicksilver> haskell.org is now serving HS files as text/x-haskell
02:23:15 <quicksilver> which seems sensible enough, but my firefox doesn't want to display them as text :(
02:23:30 <oerjan> quicksilver: i have the same problem in IE
02:23:53 <quicksilver> I'm sure it used to work, either the mime type changed or my browser changed
02:23:55 <oerjan> i solved it by making vim the default program for Haskell files
02:24:23 <DRMacIver> quicksilver: Firefox has always been bad about that, so presumably the mime type changed
02:24:25 <wli> My solution is to stop reading haskell.org
02:24:44 <quicksilver> I find it convenient to browse library source sometimes
02:24:44 <quicksilver> hmph
02:24:46 <oerjan> @remember wli My solution is to stop reading haskell.org
02:24:47 <lambdabot> Done.
02:25:54 <wli> I need to get more work done anyway, so letting Haskell activity go progressively more to the wayside is a solution for me.
02:27:03 <oerjan> afk
02:27:03 <doserj> there is an "open in browser" firefox extension to handle that
02:27:25 <doserj> http://www.spasche.net/mozilla/
02:27:26 <lambdabot> Title: Mozilla stuff
02:27:37 <wli> doserj: Any analogues for IE? I pretty much need to leave my laptop in bloze to handle my wireless modem.
02:28:16 <doserj> wli: you will have to ask someone else :)
02:28:41 <wli> Figures.
02:28:44 <totimkopf> :t (||)
02:28:46 <lambdabot> Bool -> Bool -> Bool
02:29:14 <totimkopf> nobody minds if i probe lambdabot?
02:29:19 <wli> I should investigate wireless modems through other ISP's to see if there are any that don't have idiot dongle-style authentication software.
02:29:20 <totimkopf> just to learn some basic syntax?
02:29:39 <totimkopf> :t (|)
02:29:40 <wli> totimkopf: It happens all the time anyway. If you want to keep the noise level down /msg lambdabot
02:29:41 <lambdabot> parse error on input `|'
02:29:42 <Cale> totimkopf: nope, go right ahead
02:29:45 <totimkopf> ok
02:29:50 <totimkopf> yeah that'd be better
02:29:54 <Cale> totimkopf: | is typically a guard
02:30:10 <Cale> It also occurs in data declarations to separate constructors
02:30:14 <wli> totimkopf: The bitwise operator from Data.Bits is (.|.)
02:30:34 <quicksilver> wli: just because you're running windows is no reason to run IE
02:30:34 <totimkopf> :t (.|.)
02:30:36 <lambdabot> forall a. (Bits a) => a -> a -> a
02:30:37 <Cale> and in list comprehension syntax to set off the constructed element from the generators
02:30:52 <quicksilver> wli: in fact, I'm not sure there's any good reason to run IE, unless you enjoy malware and viruses
02:31:27 <wli> quicksilver: I've never noticed much of a difference between it and the other browsers, to be honest.
02:31:45 <wli> quicksilver: The menus look a little different but I rarely use them anyway.
02:32:36 <osfameron> it used to be shite
02:32:49 * DRMacIver glares at wli
02:33:01 <osfameron> I think nowadays it is useful to run it if you care about your website working in 99% of your users' computers
02:33:11 <osfameron> but if you don't care about that, no reason to use it really
02:33:17 <wli> The big irritation about bloze is largely the Window manager sucking.
02:33:41 <osfameron> yeah, same for osx
02:34:07 <wli> Yeah, same thing in OS X (which I also have floating around).
02:34:34 <merus> Hmm, now that I have a sane GHC I should try to get xmonad to play with OS X's X server.
02:35:09 <wli> Oh, another irritation is trying to figure out where all the disk space went and how to recover it.
02:35:23 <osfameron> treesize!
02:35:44 <merus> all your disk space are belong to us.
02:35:49 <osfameron> which I can't compile on my ubuntu cos it claims I havne't got gtk+-2.0, bah
02:36:21 <wli> osfameron: treesize doesn't seem to exist.
02:36:42 <osfameron> for osx?
02:37:03 <wli> osfameron: No, for bloze. OS X doesn't seem to be leaking space like a sieve.
02:37:32 <osfameron> http://www.jam-software.com/freeware/index.shtml  freeware for windows, I *think* this is the version we used to use
02:37:33 <lambdabot> Title: JAM Software - Windows Freeware
02:38:35 <osfameron> oooo, filelight is packaged for ubuntu though
02:42:50 <masak> @tell dons do you think you could re-invite lambdabot into #bioclipse? we miss it...
02:42:50 <lambdabot> Consider it noted.
02:50:17 * wli looks around for Haskell implementations of diff(1) and patch(1) not buried in the guts of darcs and thereby tied to various of its internals.
02:51:14 <wli> (Actually I've written my own diff(1) in Haskell but patch(1) seems much harder.)
02:51:35 <osfameron> really?  I find the LCS algorithm quite confusing.
02:51:47 <osfameron> I thought patch was a largely mechanical process in comparison
02:52:21 <wli> Okay, something is wrong here.
02:56:09 <quicksilver> osfameron: erm, no :)
02:56:20 <quicksilver> osfameron: diff is mechanical, patch(1) is fiendishly clever
02:56:29 <osfameron> oh :-)
02:56:29 <SamB_XP> osfameron: you've never read the GNU documentation, have you?
02:56:37 <quicksilver> osfameron: patch(1) is probably larry wall's greatest gift to the world
02:56:52 <quicksilver> simple ed-style diffs can, of course, be applied with ed
02:56:54 <osfameron> I've heard that said
02:57:04 <quicksilver> the complex stuff is fuzzy patching
02:57:10 <quicksilver> applying a patch to a different version of a file
02:57:48 <osfameron> SamB_XP: nope, in general GNU documentation seems to say "Hah!  manpage?  Fuck you, to read this manual you must first learn how to use 'info'".  But, er, no, I think I've only glanced at it to work out how to apply a single patch...
02:58:10 <roconnor> I wonder how omake can ``not suck'' if it has ``syntax similar to make utilities''
02:58:12 <osfameron> ah, ok
02:58:36 <osfameron> that said, I don't understand the LCS algorithm at the basis of diff either.  I'll study it properly at some point...
02:58:40 * SamB_XP learned how to use info in Windows 95, er, DOS...
03:00:18 <SamB_XP> roconnor: perhaps it has better semantics?
03:07:26 * KatieHuber tries to think of a joke involving omake and お負け but fails
03:07:36 <trez> what a joke
03:08:16 <SamB_XP> o-make, not o-ma-ke!
03:09:02 <njbartlett> Well it's kind of a freebie
03:09:14 <njbartlett> no, I can't think of a good joke either :-(
03:10:16 <quicksilver> Anyone by any chance used indexed color images in haskell/OpenGL ?
03:10:27 <quicksilver> it seems to ignore my color map :(
03:10:32 <SamB_XP> quicksilver: why would you want to do that?
03:10:34 <KatieHuber> indexed color images should not be expected to work on modern hardware
03:10:55 <quicksilver> SamB_XP: I'm constructing a little bitmap icon, and I want to vary the color of part of it
03:11:06 <KatieHuber> everyone went truecolor in 2002 or 2003 and didn't look back
03:11:11 <quicksilver> KatieHuber: not even with drawPixels?
03:11:25 <KatieHuber> well then you'd be calling drawpixels :p
03:11:27 <quicksilver> my buffer is truecolor
03:11:38 <quicksilver> but I'm trying to drawPixels and indexed image into my truecolor buffer
03:11:48 <quicksilver> It's supposed to use a color map I give it
03:11:49 <roconnor> SamB_XP: interesting theory.  Potentially confusing, but perhaps new semantics would be more good than bad.
03:11:51 <quicksilver> or that's what I thought :)
03:12:07 <KatieHuber> I really wouldn't expect it to work, whether the spec and docs say it should or not
03:12:12 * quicksilver nods
03:12:14 <quicksilver> ah, ok
03:12:21 <quicksilver> maybe it's not my fault then :)
03:12:38 <quicksilver> monochrome bitmaps work though, with rgab scaling multipliers
03:13:12 <KatieHuber> I did colorization of portions of images back in 2002 using ARB_texture_env_combine
03:13:21 <KatieHuber> but these days a quick fragment shader is probably a lot easier
03:14:29 <KatieHuber> and incidentally, drawpixels is very very slow
03:15:00 <quicksilver> KatieHuber: what's the right way to put bits of 'bitmap' images into your 3D scene then?
03:15:13 <KatieHuber> textures
03:15:34 <SamB_XP> shaders have a tendancy to use textures
03:15:46 <KatieHuber> if you need 'em screen-aligned you can either switch the projection matrix briefly, or you can "billboard" your quads
03:15:49 <quicksilver> KatieHuber: but then I have to go the effort of billboarding
03:15:56 <quicksilver> and getting the scale right
03:16:17 <quicksilver> switching the projection matrix *sounds* better
03:16:17 <KatieHuber> switching the projection matrix doesn't have that issue, though it does have potential issues with the depth buffer
03:16:32 <quicksilver> btu then, switching the projection matrix loses me the ability to use scene coordinates
03:16:40 <beelsebob> KatieHuber: that's easy, draw it last, and flush the z buffer before hand
03:16:58 <KatieHuber> if what you need is that it overlaps everything in the scene, ys
03:17:14 <quicksilver> I want to draw a 2D icon over the 'head' of a 3D object
03:17:30 <KatieHuber> do you want the icon to go behind obstacles when the head does?
03:17:33 <chris2> are there uses of parsec to operate on datastructures and not character streams? (think ometa)
03:17:39 <beelsebob> and you want it to be constant size quicksilver?
03:17:43 <beelsebob> or shrink with depth?
03:18:04 <quicksilver> KatieHuber: no, I'm happy for it to be always in front
03:18:20 <quicksilver> beelsebob: I want it to be 1 pixel per pixel
03:18:25 <EvilTerran> isn't there an "overlay" or something that draws as the screen surface?
03:18:25 <quicksilver> beelsebob: it's a pixel-perfect icon
03:18:35 <KatieHuber> then switching the projection matrix is probably easiest
03:18:36 <quicksilver> drawPixels does all these things :)
03:18:55 <EvilTerran> @docs Graphics.UI.GLUT.Overlay
03:18:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/GLUT/Graphics-UI-GLUT-Overlay.html
03:19:02 <quicksilver> chris2: there are uses of in on other streems, which aren't necessarily char streams
03:19:11 <SamB_XP> quicksilver: test with stereo glasses, says nvidia...
03:19:19 <KatieHuber> switch to ortho, turn off depth testing, and draw a nice screen-aligned quads
03:19:36 <quicksilver> KatieHuber: then how to I convert from 3D scene coords to ortho coords? can I apply the matrix by hand somehow?
03:19:41 * KatieHuber mixes up singular and plural
03:19:46 <chris2> quicksilver: a string being an infinite list?
03:19:57 <KatieHuber> gluProject would be an easy way to do it, but you could just do the matrix multiplication by hand
03:19:58 <quicksilver> chris2: well it could be token streams
03:19:59 <beelsebob> quicksilver: I've got it
03:20:05 <quicksilver> chris2: or any other custom types
03:20:10 <beelsebob> modify the projection matrix
03:20:11 <beelsebob> don't binit
03:20:14 <chris2> i see, nice
03:20:18 <beelsebob> modify it so it 0s all z coords
03:20:27 <beelsebob> then everything will draw the same size, but in the right place
03:20:39 <SamB_XP> chris2: I wouldn't use it to parse arbitrary binary files though
03:20:43 <chris2> so with a bit of generic magic of some way, one could do ometa with parsec as well?
03:20:45 <quicksilver> beelsebob: it won't be 1 for 1 pixel for pixel though
03:20:48 <SamB_XP> maybe BASIC files
03:20:55 <beelsebob> quicksilver: it will be if the z-coord is 0
03:21:06 <quicksilver> beelsebob: oh, will it?
03:21:09 <KatieHuber> not true
03:21:17 <chris2> i'm not interested in parsing data, but matching data structures with PEGs
03:21:24 <beelsebob> (well, assuming you get the size of the poly right)
03:21:53 <beelsebob> wait no... it won't
03:21:58 <beelsebob> it'll scale
03:22:00 <EvilTerran> hm... I've got a class with a lot of methods that can be defined in terms of each other. is the norm to define the big, complicated, all-encompassing methods in terms of the simple ones, or the simple ones in terms of the all-encompassing ones?
03:22:08 <beelsebob> you can get the x-y position from that
03:22:19 <beelsebob> if you can grab the result of the matrix mult out thouh
03:22:25 <quicksilver> KatieHuber: didn't know about gluProject, that helps :)
03:22:29 <oerjan> EvilTerran: Ord does it in both directions, sort of
03:22:58 <oerjan> you can define either compare or <=
03:23:18 <EvilTerran> hm.
03:23:38 <quicksilver> KatieHuber: I'm surpised that drawpixels doesn't just use a texture behind the scenes
03:24:49 <SamB_XP> if it were possible, for Eq and Ord together you would be able to define just (==) and (<=) or compare
03:24:58 <KatieHuber> I'm not quite sure why it's so slow, except perhaps that games don't use it ;)
03:25:37 <SamB_XP> what's drawpixels' api?
03:25:54 <paczesiowa> how can I create Image from String (or ByteString) using gtk2hs? there are only functions to load image from file
03:26:11 <quicksilver> SamB_XP: pointer to a bunch of pixel data, some flags to indicate how the data is stored
03:26:18 <EvilTerran> instance Ord a => Eq a where ... (==) = ((EQ==).).compare -- would work with OverlappingInstances
03:26:34 <SamB_XP> well, I can guess why it might not be used too often...
03:27:11 <SamB_XP> it, um, requires uploading the data to the GPU every time you use it...
03:27:14 <KatieHuber> to be fair, it might not be any worse than TexImage2D immediately followed by drawing a quad, and then never using the texture again
03:27:36 <KatieHuber> but generally you'll manage to use the texture again, and therefore go nice and fast the second time at least ;)
03:28:00 <beelsebob> KatieHuber: depends if he puts it in a display list or not
03:28:15 <beelsebob> if this is a commonly drawn simple thing, I would be shoving the whole thing onto the graphics card
03:28:41 <SamB_XP> I don't suppose you can pass textures to shaders?
03:28:48 <KatieHuber> DLs aren't a panacea
03:28:58 <KatieHuber> yes, you can use textures from shaders
03:29:20 <SamB_XP> pass to, I said
03:29:23 <SamB_XP> not use from
03:29:48 <KatieHuber> difference being?
03:30:06 <SamB_XP> as parameters?
03:30:51 <KatieHuber> I'm really not sure what distinction you're trying to make between what and what
03:31:17 <EvilTerran> ?type Data.Map.insert
03:31:23 <lambdabot> forall k a. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
03:31:28 <KatieHuber> you bind your shader, set its "uniform" parameters (which can include textures), then draw your geometry with that shader
03:31:29 <EvilTerran> ?type Data.Map.insertWithKey
03:31:31 <lambdabot> forall k a. (Ord k) => (k -> a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
03:31:37 <EvilTerran> ?type Data.Map.insertWith
03:31:39 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
03:31:48 <EvilTerran> is there really any need for insertWithKey?
03:31:51 <SamB_XP> KatieHuber: okay, so you can pass textures to shaders. cool.
03:32:07 <EvilTerran> it seems a bit redundant, seeing as you know the key anyway
03:32:33 <EvilTerran> seems to me insertWithKey f k = insertWith (f k) k
03:32:51 <SamB_XP> quicksilver: you could write a shader that does colormapping ;-)
03:32:59 <quicksilver> KatieHuber: problem is/was that it's a custom icon
03:33:09 <quicksilver> KatieHuber: as in generated dynamically
03:33:21 <quicksilver> KatieHuber: but maybe I'm going to do it a different way :)
03:33:30 <SamB_XP> quicksilver: from what?
03:33:31 <SamB_XP> when?
03:33:33 <oerjan> EvilTerran: except it's actually defined the other way around
03:33:40 <quicksilver> SamB_XP: I don't really want to restrict myself to GLSL-capable systems
03:33:56 <quicksilver> SamB_XP: (I also don't want to program in GLSL :P)
03:34:00 <KatieHuber> well, GLSL goes back quite a way
03:34:04 <EvilTerran> insertWith f = insertWith (const f)?
03:34:11 <SamB_XP> KatieHuber: how far?
03:34:12 <EvilTerran> insertWith f = insertWithKey (const f), even?
03:34:20 <oerjan> insertWith' f k x m           = insertWithKey' (\k x y -> f x y) k x m
03:34:22 <KatieHuber> and hey, GLSL's better than ARB_fragment_program which is a million times better than its predecessors ;)
03:34:25 <beelsebob> quicksilver: make your shader hunt for a colour in the icon and replace it with another one
03:34:35 <KatieHuber> GeForce 5200, Radeon 9500, GMA 910
03:34:35 <oerjan> um, same without '
03:34:38 <SamB_XP> how can you tell if you have GLSL support in X?
03:34:54 <KatieHuber> glxinfo should report ARB_shading_language_100 in the extensions list
03:34:58 <EvilTerran> hm
03:35:04 <quicksilver> KatieHuber: I have a couple of Radeon 9250s :)
03:35:13 <matthew_-> but you can also just use the haskell hopengl getExtensions stuff?
03:35:15 <matthew_-> -?
03:35:24 <quicksilver> matthew_-: yes
03:35:45 <matthew_-> though beware that there's one in glut and one in gl and they give different answers ;)
03:36:08 <KatieHuber> hm?
03:36:47 <SamB> don't have it
03:36:47 <quicksilver> beelsebob: yes, but I don't want to write a shader :) This is a simple task I'm doing.
03:36:56 <quicksilver> I think I'll draw it with openGL primitives instead :P
03:37:30 <matthew_-> there's glExtensions :: GettableStateVar [String] in StringQueries and there's gluExtensions :: GettableStateVar [String] in GLU.Initialization (err, that's glu, not glut)
03:38:17 <KatieHuber> wacky HOpenGL inventing functions that don't exist >:(
03:39:18 <matthew_-> KatieHuber: err, you've spotted that there's no vertexPointer, colorPointer, normalPointer, texturePointer etc right? Just one arrayPointer which takes an ArrayDescriptor?
03:39:50 <KatieHuber> I've spotted that the whole thing bears no resemblance at all to the spec, if that's what you're hinting at, yes
03:40:01 * quicksilver grins
03:40:12 <quicksilver> there is resemblence to the spec, if you look at it the right way
03:40:22 <quicksilver> but quite a few nice type-system powered shortcuts
03:40:23 <KatieHuber> call me crazy, but I kinda think language bindings should strike some kind of balance between reflecting the language and reflecting the API :p
03:40:39 <quicksilver> well it does strike "a" balance :)
03:40:48 <matthew_-> right, I think that improving the spec within the purity of Haskell is definately a good thing ;)
03:40:57 <quicksilver> I quite like it, but then I've never done any openGL programming before
03:41:30 * beelsebob would like to implement a somewhat different graphics library in Haskell
03:41:40 <beelsebob> one that's rather more abstract
03:41:50 <beelsebob> and probably acts just as a wrapping for HOGL
03:43:16 <KatieHuber> I'm thinking GL3 should help since it's got a lot less state and a lot more immutable objects
03:43:39 <beelsebob> plausable
03:44:01 <KatieHuber> speaking of which, we're running out of september!
03:44:10 <beelsebob> o.O
03:44:17 <quicksilver> as it happens, I think the current haskell openGL api is rather interesting
03:44:17 <laz0r> hi #haskell, is it possible to have ghc load libs from a custom dir?
03:44:28 <quicksilver> becaue it explores the design space of "very stateful" librarys and haskell
03:44:44 <quicksilver> it presents interesting expressiveness solutiosn
03:45:06 <quicksilver> everyone is talking about how openGL 3 will be "better because it's object oriented"
03:45:11 <quicksilver> a phrase which makes me feel rather ill :P
03:45:28 <beelsebob> quicksilver: yeh, on the other hand, I think it would be much more "haskellish" to say, have data Scene = (composition of lots of primitives), and have a function render :: Scene -> Time -> IO ()
03:46:07 <quicksilver> beelsebob: absolutely. That's a different debate.
03:46:46 <quicksilver> beelsebob: it's quite hard to get that right though
03:46:51 <beelsebob> true
03:47:16 <quicksilver> beelsebob: because clever GL effects involve all kinds of stateful things like changing blending modes, rendering more than once, depth sorting, carefully choosing which order to render
03:47:25 <beelsebob> yep
03:47:25 <DRMacIver> KatieHuber: Is there really a useful notion of a cross language API? Particularly when the languages are as different as e.g. C and Haskell.
03:47:31 <quicksilver> beelsebob: if you did it wrong, you'd strip most of that flexibility
03:47:39 <quicksilver> beelsebob: of course, if you did it right, it would be lovel :)
03:47:39 <beelsebob> quicksilver: yeh, I agree
03:48:02 <quicksilver> beelsebob: also, openGL often involves compromise
03:48:06 <beelsebob> yep
03:48:12 <quicksilver> beelsebob: transparency is very hard to do *right* in full generality
03:48:13 <beelsebob> which is somewhat odd
03:48:15 <quicksilver> beelsebob: (for example)
03:48:31 <beelsebob> because Open GL is designed (in theory) to describe a world, and have it render
03:48:40 <quicksilver> beelsebob: but in a particular case, you can normally say "ok, well render in *this* order, turn off the depth buffer at *this* point, etc"
03:48:44 <beelsebob> (as opposed to D3D which is designed to expose current graphics card functionality)
03:49:03 <quicksilver> beelsebob: however, a generic 'Scene' library which supported transparent primitives would have to attempt the general solution
03:49:10 <beelsebob> yep
03:49:16 <KatieHuber> DRMacIver: well, I dunno about Haskell, but every other language I've used has bindings for OpenGL which bear some resemblance to the C API (even other functional languages)
03:49:22 <beelsebob> but it could in theory do a lot of pre-calculation
03:49:27 <quicksilver> yes
03:49:31 <KatieHuber> I haven't used any other lazy pure languages though :p
03:49:39 <quicksilver> I'd love to work out the tangile values stuff
03:49:44 <beelsebob> quicksilver: also, it doesn't necessarily have to be a "you render 1 scene and 1 scene only" type library
03:49:48 <quicksilver> because so much of my programming is tweaking parameters
03:49:52 <quicksilver> (and then recompiling)
03:50:01 <oerjan> laz0r: http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#search-path
03:50:04 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/2y3hr6
03:50:07 <quicksilver> it would be lovely to make those parameters tangible and tweak them interactively instead
03:50:14 <beelsebob> being able to string them together in a monad would allow for open-gl tweakyness, but still make it relatively nice
03:51:44 <quicksilver> beelsebob: anyhow, as my program grows I'm thinking about how to make it more haskell-like
03:52:00 <quicksilver> beelsebob: I've got a copule of different animation types, for example
03:52:48 <quicksilver> runAnim :: (s -> GLdouble -> IO s) -> Int -> s -> Animation
03:53:06 <quicksilver> beelsebob: 's' is the animation's own internal state, 'Int' is how many frames to run it over
03:53:27 <quicksilver> beelsebob: then the animation gets "called" with values from [0..1] in the GLdouble parameter
03:53:40 <quicksilver> beelsebob: i.e. the animation just gets "time" it doesn't know how many frames it is
03:53:45 <beelsebob> quicksilver: I think if I were writing that, I would replace the Int for frames, with a Double for time
03:53:59 <quicksilver> beelsebob: it is double for time :)
03:54:10 <quicksilver> beelsebob: it's only the "outer wrapper" that knows about frames
03:54:17 <beelsebob> (run it over 10 seconds, now render a frame for what it should look like after 2.435 seconds)
03:54:17 <quicksilver> beelsebob: and it conversts to a time value
03:54:23 <quicksilver> yes, it works like that :)
03:55:13 <quicksilver> however what I haven't got right, yet, is being able to put the animation somewhere in the 'rendering' order
03:55:21 <quicksilver> as it stands, animations are always rendered last
03:55:30 <quicksilver> which is fine for particle effects which are "suposed to be on top"
03:55:45 <beelsebob>   yeh
03:55:53 <beelsebob> but if you want it behind some water, it's useless
03:55:56 * quicksilver nods
03:56:51 <beelsebob> problem really comes when you want the object to come *through* some water
03:56:57 <vincenz> lo
03:57:17 <beelsebob> so it has to calculate where to chop the polys itself
03:59:57 <quicksilver> beelsebob: right, and the problem with your Scene idea is that sovling these problems in general makes simple things slower than they need to be
04:00:26 <quicksilver> beelsebob: meanwhile 'automaticaly' upgrading to a more complex rendering set up when the Scene contains some particular behaviour is surprising for users who don't understand
04:00:35 <quicksilver> beelsebob: it's not easy to get the API sweet spot :) not easy at all.
04:01:02 <beelsebob> yep
04:01:36 <quicksilver> beelsebob: I want to write a perlin-style noise library soon
04:01:45 <beelsebob> o.O
04:01:49 <quicksilver> beelsebob: I want to be able to do 'CPU-side' procedural textures
04:02:00 <quicksilver> beelsebob: where you render (once only) to a static texture
04:02:05 <quicksilver> beelsebob: and then just get openGL to map the texture
04:02:24 <beelsebob> fun
04:02:41 <quicksilver> but then perlin-style noise is also great for things like particle effects
04:02:53 <quicksilver> creating small natural looking un-even-ness in, e.g., flames or smoke
04:04:10 <quicksilver> so it's a very handy primitive to have around
04:11:23 <patrik77> hi
04:14:39 <axm> hi
04:15:30 <b_jonas> hi. I'll continue my flow of stupid haskell questions
04:15:53 <b_jonas> basically, in haskell, you usually have to use foldr instead of foldl, right?
04:16:02 <quicksilver> we will endeavour to continue the flow of stupid answers
04:16:33 <quicksilver> foldr is generally the right choice if the operator which you're folding is 'lazy' and can return useful 'partial answers'
04:16:41 <b_jonas> yep
04:16:46 <quicksilver> such as, if the foldr produces a list
04:16:54 <b_jonas> and if it's strict, then foldl' is the best, right?
04:17:03 <quicksilver> if your fold is to a single summary value, then you want a strict fold
04:17:07 <quicksilver> probably foldl'
04:17:19 <quicksilver> the compiler can often spot simple strictness
04:17:27 <quicksilver> (meaning you don't need the ')
04:17:37 <patrik77> slt
04:18:28 <pjd> foldr is nice because it's the natural catamorphism
04:18:50 <quicksilver> pjd: that's more of an aesthetic than practical point, though
04:18:53 <quicksilver> true though it is
04:19:09 <pjd> who says aesthetics isn't practical? :)
04:30:29 <bakert> is the #happs group used much?  or do people tend to discuss it on here?
04:32:42 <EvilTerran> foldr is also kinda strict in the accumulator, because of the outside-to-inside aspect of laziness
04:33:33 <EvilTerran> foldr f e (x:xs) = f x (foldr f e xs) -- the evaluation of f starts before the evaluation of (foldr f e xs)
04:34:10 <EvilTerran> foldl f e (x:xs) = foldl f (f e x) xs -- the evaluation of foldl starts first, and so on for all elements of the list, so you end up with a massive thunk in the accumulator
04:40:01 <bakert> has anyone written a happs-for-dummies?  say "how to build a blog in happs" type thing?
04:40:14 <bakert> i could really do with that :)
04:40:31 <bakert> perhaps i will write one today
04:40:38 <bakert> if i can work out how to build a blog in happs :)
04:45:54 <pixl> how can I convert return value of CGI.getInput to a string in 'paragraph << CGI.getInput "proj_title"'? GHC gives No instance for (HTML (m (Maybe String)))
04:46:08 <pixl> liftM of some sort?
04:47:44 <pixl> getInput returns CGI (Maybe String)  i think
04:48:21 <quicksilver> what's '<<' ?
04:48:32 <quicksilver> do you mean =<< ?
04:50:24 <pixl> no its an operator of Html elements used to nest them
04:50:28 <quicksilver> ah
04:50:37 <quicksilver> that's a very poor choice of name :)
04:50:47 <quicksilver> you could try:
04:51:02 <quicksilver> (paragraph <<) `fmap`  CGI.getInput "proj_title"
04:51:15 <quicksilver> but the best you can hope for is Maybe HTML...
04:51:18 <pixl> hmm isnt fmap like ordinary map?
04:51:28 <quicksilver> it's a way of pushing the work inside the Maybe
04:51:37 <pixl> ah
04:51:40 <quicksilver> so if CGI.getInput returns Just "foo"
04:51:41 <quicksilver> you get
04:51:53 <quicksilver> Just (paragraph << "foo")
04:52:01 <quicksilver> bit if it returns nothing, you get Nothing
04:52:14 <quicksilver> more likely, you want to supply a default
04:52:18 <quicksilver> :t fromMaybe
04:52:20 <lambdabot> forall a. a -> Maybe a -> a
04:52:30 <EvilTerran> @src Maybe fmap
04:52:30 <lambdabot> fmap _ Nothing       = Nothing
04:52:30 <lambdabot> fmap f (Just a)      = Just (f a)
04:53:00 <quicksilver> oh, and you have CGI too
04:53:05 <quicksilver> I didn't unlayer that for you :)
04:53:08 <pixl> hmm no I cant get it to work with fmap
04:53:17 <quicksilver> yeah, I didn't account for the CGI part
04:53:32 <pixl> i wish you could do it like paragraph << (String) CGI.getInput "foo" :P
04:54:14 <quicksilver> I'd use do notaiton
04:54:20 <quicksilver> you have two separate questiosn here
04:54:24 <quicksilver> (1) how to get out of CGI
04:54:26 <quicksilver> (2) how to get out of maybe
04:54:29 <quicksilver> :t fromMaybe
04:54:30 <pixl> I think its both "maybe" and the fact that getInput is an io operation thats cousing problems
04:54:31 <lambdabot> forall a. a -> Maybe a -> a
04:54:41 <quicksilver> I would suggest that fromMaybe is a good way out of maybe
04:54:47 <quicksilver> and do notaiton is a good way out of CGI
04:54:58 <pixl> well liftIO can get me out of cgi i think
04:55:16 <quicksilver> so I'd try: do inp <- CGI.getInput "proj_title"; return (paragraph << fromMaybe "no title" inp)
04:59:29 <b_jonas> good. the program now compiles. now I have to figure out how to use the debugger of ghc.
05:01:48 <pixl> hmm cgiVar :: String -> String
05:01:48 <pixl> cgiVar name =
05:01:48 <pixl>     do
05:01:48 <pixl>         inp <- CGI.getInput name
05:01:48 <pixl>         return (fromMaybe "none" inp)
05:01:52 <pixl> this gives Couldn't match expected type `Char' against inferred type `[Char]'
05:01:52 <pixl>     In the first argument of `return', namely `(fromMaybe "none" inp)'
05:02:28 <quicksilver> pixl: you can't possibly make it String -> String
05:02:38 <b_jonas> does ghc(i) have an interactive debugger?
05:02:44 <quicksilver> pixl: it will be String -> CGI String
05:03:33 <pixl> hmm but then i get another problem No instance for (HTML (CGI String))
05:03:33 <pixl>       arising from use of `<<' at Main.hs
05:03:49 <pixl> so I have to somehow get rid of the CGI bit
05:03:57 <quicksilver> impossible
05:03:58 <quicksilver> you can't do
05:04:03 <quicksilver> you can't 'get rid' of monads
05:04:05 <quicksilver> :)
05:04:09 <quicksilver> what you do, is work inside them
05:04:27 <pixl> :S but how do I make << operator accept that cgi string?
05:04:33 <quicksilver> you don't
05:04:37 <quicksilver> the << operator accepts strings
05:04:40 <quicksilver> so you give it a string
05:05:12 <pixl> well it obviosly doesnt work if I give it a "CGI String"
05:05:16 <quicksilver> title <- cgiVar "proj_title" ; return (paragraph << title)
05:05:32 <pixl> and I can only get as far as CGI String when it comes to getting cgi arguments
05:05:48 <quicksilver> the only way you an 'unwrap' a CGI is to use '<-'
05:05:50 <quicksilver> inside the do-block
05:05:59 <quicksilver> and the consequence is that CGI gets re-wrapped afterwards
05:06:38 <EvilTerran> monads \o/
05:09:22 <vincenz> quicksilver: feel like golfing something?
05:10:13 <pixl> so do I now have to wrap all of my code into do blocks? :S
05:10:43 <pixl> since I can not use any function that uses a do block outside a do block, or?
05:10:59 <EvilTerran> @type Data.Map.deleteFindMin
05:11:01 <lambdabot> forall k a. Data.Map.Map k a -> ((k, a), Data.Map.Map k a)
05:11:04 <EvilTerran> @type Data.Map.minView
05:11:06 <lambdabot> forall k a (m :: * -> *). (Monad m) => Data.Map.Map k a -> m (Data.Map.Map k a, (k, a))
05:11:14 <quicksilver> pixl: well you don't actually need to use 'do blocks'
05:11:19 <quicksilver> pixl: but you need to use monads, yes
05:11:26 <quicksilver> pixl: it's not all your code though
05:11:34 <EvilTerran> those do the same thing, AFAICT, except one works inside a monad. any particular reason their return values are flipped relative to each other?
05:11:34 <quicksilver> pixl: you can write most of your code without CGI/IO
05:12:08 <quicksilver> pixl: and then you just 'use' the pure code inside some top-level IO/CGI driver
05:12:21 <quicksilver> pixl: normally very little of the code is in the monad
05:13:40 <EvilTerran> in terms of how it's run, yes, a lot of it will end up running with a do{} "on the stack", as it were, but lexically, you can still have mostly pure functions
05:14:36 <quicksilver> pixl: for example, in my code, (paragraph << title) is totally pure
05:14:42 <quicksilver> pixl: and that's a typical situation
05:15:09 <bakert> pixl: the way i think of it, you have the bit that has to be in CGI in CGI, then you unwrap stuff there and pass it from there into pure non-Monadic functions that do most of the work.  so most of what you write doesn't have to cope with monads.
05:15:09 <quicksilver> pixl: monadic code sets up some initiliasation, gets some values from somewhere, and then calls  pur code to the algorithmic work
05:15:46 <pixl> how do I make pure code like | otherwise = paragraph << "error" evaluate to return CGIT IO Html instead of Html?
05:16:12 <quicksilver> return (purecode)
05:18:35 <roconnor> @bab en nl capers
05:18:49 <roconnor> @bot
05:18:51 <lambdabot> Plugin `babel' failed with: IRCRaised thread killed
05:18:51 <lambdabot> :)
05:19:14 <pixl> hmm No instance for (HTML (CGI String))
05:19:14 <pixl>       arising from use of `<<'
05:19:22 <quicksilver> pixl: can you hpaste
05:19:32 <pixl> << paragraph << cgiVar "proj_title"
05:19:35 <pixl> hpaste?
05:19:43 <quicksilver> title <- cgiVar "proj_title"
05:19:49 <quicksilver> return (paragraph << title)
05:20:04 <quicksilver> I already answered that one! :)
05:20:19 <pixl> yess!!! thnks :D
05:20:41 <vincenz> Syzygy-: Que es magma?
05:20:44 <quicksilver> once you get the hang of it, you start rewriting those things
05:20:47 <pixl> yeah i put a return there, but I didnt change the getVar to the variable :P
05:21:01 <quicksilver> you could write (paragraph <<) `fmap` cgiVar "proj_title"
05:21:04 <quicksilver> which is the same thing
05:21:09 <pixl> ok
05:21:41 <roconnor> @bab nl en Kappertjes
05:21:42 <lambdabot>   Capers
05:22:14 <sieni> @bab nl en sinaasappelsaap
05:22:16 <lambdabot>   orange monkey
05:22:49 <koeien> you made a typo :)
05:23:02 <sieni> @bab nl en sinaasappelsap
05:23:03 <lambdabot>   orange juice
05:23:20 <sieni> I don't even know dutch :-)
05:23:23 <bakert> i think it would be nicer with orange monkey
05:23:29 <bakert> orange juice is passe
05:23:45 <sieni> like an orangutan?
05:23:48 <b_jonas> how do you debug a haskell program?
05:23:53 <b_jonas> is there an interactive debugger
05:23:58 <b_jonas> that can single-step and stuff?
05:24:09 <quicksilver> b_jonas: you test functions in ghci
05:24:16 <bakert> b_jonas: there's some unsafe command that let's you print out stuff as it is happening.  i forget the name.
05:24:18 <quicksilver> b_jonas: and see which ones are working as expected
05:24:26 <bakert> fairly crude but occasionally effective.
05:24:28 <scook0> bakert: Debug.trace?
05:24:33 <bakert> scook0: that's it
05:24:39 <quicksilver> b_jonas: there is an interactive debugger in ghc CVS, but not in the released version
05:24:46 <b_jonas> uh huh
05:24:48 <b_jonas> pity
05:24:50 <quicksilver> I can honestly say I've never used or wanted Debug.trace :P
05:24:50 <xerox> Debug.Trace.trace
05:24:54 <b_jonas> is hugs or something better?
05:24:58 <xerox> GHC *darcs* (:
05:25:03 <quicksilver> ;)
05:25:06 <scook0> yeah, Debug.Trace.trace
05:25:21 <quicksilver> b_jonas: single-stepping lazily functional code is quite strange
05:25:28 <quicksilver> b_jonas: it wouldn't feel much like you expect :)
05:25:38 <quicksilver> however, it is an interesting idea and they are working on it
05:25:46 <b_jonas> yeah, I guess that's true
05:25:50 <quicksilver> BUT, personally I think ghci function-by-function debugging is much more suited
05:25:55 <quicksilver> and really quite convenient
05:26:13 <quicksilver> I've written moderately large (1000s of lines) haskell programs and never really felt the lack of debugger as a problem
05:26:31 <Pseudonym> Debug.Trace helps sometimes.
05:26:42 <Pseudonym> But, again, its output can be confusing.
05:26:45 <b_jonas> ok, I'll try to call the functions
05:27:12 <quicksilver> even better of course is to debug by writing quickcheck properties :)
05:27:20 <DRMacIver> I've felt the lack of debugger to be vaguely annoying in one instance (doing some ad hoc parsing and having a horrible time making it work right), but Debug.Trace and ghci were mostly a good enough substitute.
05:27:22 <EvilTerran> ?where hat
05:27:22 <lambdabot> http://www.haskell.org/hat/
05:27:29 <quicksilver> then you end up with something approximating a specification of your code and regression tests
05:27:56 <roconnor> I've noticed the lack of a debugger, but I miss it less than you'd think.
05:29:16 <beelsebob> there are several Haskell debuggers
05:29:27 <beelsebob> just very few people in this channel write Haskell
05:30:02 * EvilTerran observes that "sortBy (comparing `on` snd)" is surprisingly close to english
05:30:13 <DRMacIver> Are you making a point about the fact that the debuggers are targetted for H98, or actually about the amount of code we write in Haskell? :)
05:30:23 <EvilTerran> *compare `on` snd, rather
05:30:33 <beelsebob> DRMacIver: that they're all targetting a standard, rather than a moving target, yes
05:30:54 <xerox> EvilTerran: "comparing snd" also does it
05:30:56 <roconnor> EvilTerran: yeah, but it should be sortBy (compare `ing` snd) :)
05:31:09 <EvilTerran> O.o
05:31:22 <roconnor> @type comparing
05:31:25 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:31:29 <EvilTerran> `ing`. now there's an odd choice of operator name.
05:31:29 <DRMacIver> beelsebob: Fair point.
05:31:30 <roconnor> :)
05:31:44 <roconnor> @karma+ xerox
05:31:44 <lambdabot> xerox's karma raised to 27.
05:31:45 <DRMacIver> beelsebob: But I think the extensions to the standard are more useful than the debuggers would be. :)
05:31:54 <xerox> yay!
05:32:20 <DRMacIver> I think a debugger wouldn't be particularly helpful when the problem lies in pure code anyway.
05:32:26 <quicksilver> I think "compare `on` snd" is to be preferred to "comparing snd"
05:32:29 <beelsebob> DRMacIver: possibly... to some people, but I've only met one situation where I've actually wanted to use an extension, and that was MPTCs
05:32:40 <beelsebob> which will be standardised soon enough
05:32:48 <beelsebob> and the debuggers should handle pretty easily straight off
05:32:52 <quicksilver> because it is not much longer, and shows how to generalise
05:32:59 <quicksilver> beelsebob: pattern guards are handy
05:33:41 <DRMacIver> beelsebob: I don't use them much either (although I'm intrigued by open function types, and like the idea of higher ranked types without having felt a need to use them). But then I wouldn't use a debugger much either. :)
05:34:23 <beelsebob> DRMacIver: I agree with you -- a debugger for Haskell is to some extent a tool for the stupid
05:34:25 <DRMacIver> beelsebob: I'm slightly burned on this point from Java. One of the common barriers to language extension there is people whining "Oh noes! You'll break all our cool tools!"
05:34:39 <beelsebob> in that it's primary purpose is not to find bugs in code, but bugs in the logic on which you built your code
05:34:47 <DRMacIver> beelsebob: So I think it's important that improving the language comes before making the tools reliable.
05:35:03 <beelsebob> DRMacIver: yes, but improving doesn't necessarily mean adding things
05:35:08 <DRMacIver> Agreed.
05:35:23 <beelsebob> Haskell was originally designed as being a small language, and a lot of the design committy think that even H98 is too big
05:35:43 <DRMacIver> But whether you're adding, unifying or removing it's still the same effect.
05:35:50 <beelsebob> true
05:36:10 <beelsebob> oh well, hopefully Haskel' will sort out problems with people not using the standard
05:36:12 <beelsebob> but I doubt it
05:36:20 <DRMacIver> Seems unlikely.
05:36:25 <beelsebob> Haskell is primarily a research language, and people will always add cool toys to it
05:37:40 <beelsebob> DRMacIver: of note, I'm not saying that extensions should not be added -- I'm saying you shouldn't complain about not having a debugger, if you're going to use cool toy x that isn't part of the standard
05:37:49 <quicksilver> I don't think it would be right ot want that to stop, either
05:37:49 <beelsebob> because you do have a debugger, if only you use the standard
05:38:12 <quicksilver> of course, if the debugger understands Fc, then it can cope with extensions
05:38:20 <quicksilver> it just may not know how to display them in an attractive wa
05:38:20 <quicksilver> way
05:38:23 <beelsebob> not really
05:38:36 <DRMacIver> beelsebob: Fair point. :)
05:38:39 <beelsebob> there's a lot of extensions that add semantic constructs that the debugger has no idea how to deal with
05:40:06 <beelsebob> quicksilver: noting that a debugger for a functional language should not be a stepping one
05:40:15 <beelsebob> especially for a lazy functional language
05:41:05 <quicksilver> beelsebob: indeed
05:41:10 <quicksilver> a 'graph visualizer' would be a nice tool to have
05:41:20 <beelsebob> pretty-hat :D
05:41:23 <EvilTerran> what's Fc?
05:41:27 <quicksilver> but more because it would be cool
05:41:32 <quicksilver> than because it would be useful for finding bugs
05:41:33 <beelsebob> it's actually surprisingly not as useful as you would expect
05:41:47 <beelsebob> it's very useful for debugging the debugger
05:41:53 <beelsebob> but not useful for debugging a program
05:42:02 <jykiv>  http://st-pitch.miniville.fr/env
05:42:02 -jykiv(i=Tervuv@modemcable144.186-201-24.mc.videotron.ca)-  http://st-pitch.miniville.fr/env
05:42:04 <lambdabot> Title: Miniville
05:42:04 <lambdabot> Title: Miniville
05:42:07 <quicksilver> useful for seeing space leaks
05:42:17 <EvilTerran> banhammer?
05:42:24 <quicksilver> banhammer?
05:42:38 <EvilTerran> ... it's what you hit people with when you ban 'em
05:42:42 <beelsebob> quicksilver: I guess it would be, yes... if Hat kept info on the garbage collector
05:42:47 <quicksilver> EvilTerran: after the fact, though :)
05:43:04 <quicksilver> beelsebob: well yes, one of the key things in a graph visualizer would be a reachability marker
05:43:05 <EvilTerran> he might be back, though
05:43:32 <beelsebob> quicksilver: I'd wondered a bit about combining pretty-hat and hat-anim actually
05:43:41 <beelsebob> to show which bits of the graph are present at any one time
05:43:59 <beelsebob> the graph layout is very hard though
05:44:05 <beelsebob> because you've got to layout a 4D graph essentially
05:44:27 <cognominal_>  "100% safe to take, with NO side effects!", one has to be sick to bite the haskell pill? :)
05:44:31 <quicksilver> beelsebob: yes, it's very hard
05:45:01 <quicksilver> beelsebob: you might imagine some heuristics for particular classes of examples though
05:45:02 <beelsebob> at some point I'll probably look at it
05:45:09 <beelsebob> but not as part of my PhD
05:45:29 <quicksilver> beelsebob: for example, I'd like to see an animation of what it's like to traverse a lazily-built list-of-lists
05:45:47 <quicksilver> beelsebob: and then I'd like to show people an animation of traversing it with a 'transpose' thrown in
05:46:05 <beelsebob> quicksilver: yeh, we have some good layouts for the whole graph (including reduction)... the problem is doing the animation... you have to have a good layout early on, that still gives space for other bits to expand into
05:46:12 <ivanm> OK, this isn't strictly haskell, but more fp in general... does anyone know of any "cool fp" papers/etc that deal with replacing data with functions? (e.g. exact real arithmetic, combinator parsers)
05:46:15 <beelsebob> quicksilver: hehe, that sounds pretty
05:50:32 <fasta> Is there a foldM variant in the libraries that does terminate on this?  foldM (\a b -> return (a || b))  False (repeat True)
05:50:37 <pjd> ivanm: as in catamorphisms?
05:51:04 <ivanm> pjd: depends... since I don't know what catamorphisms are, I can't tell :p
05:51:13 <EvilTerran> ?type foldM
05:51:16 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:51:29 <pjd> ivanm: replacing data (constructors) with functions
05:51:41 <ivanm> pjd: ummm... maybe...
05:51:53 <EvilTerran> fasta, not AFAIK. foldM has a bind for every (:), iirc
05:51:57 <scook0> @google bananas lenses barbed wire
05:52:00 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
05:52:00 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
05:52:04 <EvilTerran> O.o
05:52:14 <ivanm> pjd: for a project I'm doing, I'm meant to be finding examples that support my professor's view that all data can be replaced with functions, e.g. replacing booleans with functions to test
05:52:16 <pjd> ivanm: yes, check out that paper
05:52:23 <Pseudonym> ivanm: Church encoding.
05:52:31 <Pseudonym> But you need higher-ranked types in general.
05:52:42 <pjd> ivanm: hmm, ok, that's replacing in a different sense
05:52:44 <ivanm> Pseudonym: yes, that's one simple example, but I want more practical/useful examples
05:52:45 <Pseudonym> Which GHC, luckily, provides.
05:52:49 <scook0> catamorphisms are very much related to church encodings
05:52:57 <ivanm> pjd: yes, but more like church encoding
05:53:02 <pjd> cata/anamorphisms are folds and unfolds
05:53:09 <Pseudonym> ?google ralf hinze backtracking monad transformers
05:53:11 <lambdabot> http://citeseer.ist.psu.edu/hinze00deriving.html
05:53:11 <lambdabot> Title: Deriving Backtracking Monad Transformers - Hinze (ResearchIndex)
05:53:14 <fasta> Pseudonym: Why do you need higher-ranked types? I can think of encoding that doesn't need them.
05:53:21 <fasta> +an
05:53:28 <Pseudonym> fasta: OK, give the the Church encoding of lists.
05:53:28 <scook0> since you can encode algebraic data types as their fold
05:53:40 <Pseudonym> data List a = Nil | Cons a (List a)
05:53:58 <Pseudonym> Oh, hang on
05:54:00 <Pseudonym> Bad example.
05:54:10 <fasta> Pseudonym: who said I was thinking of the Church encoding?
05:54:10 <scook0> foldr!
05:54:22 <Pseudonym> fasta: Good point.
05:54:31 <ivanm> scook0: that's exactly what I'm meant to be doing... expressing data as functions, and then giving a fold-based representation of them
05:55:00 <Pseudonym> ivanm: Check out that Ralf Hinze paper.  You'll recognise the types of the monad transformers that he derives.
05:57:15 <ivanm> to be more specific, these are the papers which I'm meant to be finding supporting evidence for: http://www.itee.uq.edu.au/~paul/tfp-papers/
05:57:15 <lambdabot> Title: TFP Summary
06:00:31 <scook0> foldr, maybe and either are all "useful" catas
06:01:00 <maitscha> hi! I have a more generell question about the \-kalkl. I do not really understand the fix point operator Y
06:01:59 <scook0> maitscha: "\-kalkül" == "lambda calculus", I presume?
06:02:15 <maitscha> yes, correct
06:02:25 <maitscha> \-calculus
06:02:44 <b_jonas> properFraction is like modf, only with a wierd name, right?
06:02:45 <scook0> what's giving you trouble?
06:05:40 <maitscha> I do not understand why Y s = s (Y s)
06:07:21 <scook0> Y = λf·(λx·f (x x)) (λx·f (x x))
06:07:55 <profmakx> maitscha, mainly it is because Y is _defined_ that way
06:08:11 <profmakx> the surprising thing being that this can actually be done
06:08:15 <profmakx> sort of
06:08:22 <scook0> actually, it might be helpful to first look at (λx -> x x) (λx -> x x)
06:08:46 <Liskni_si> uh, misc-fixed has a very ugly lambda
06:08:52 <scook0> (which is essentially Y with all the fs taken out)
06:10:27 <scook0> if you evaluate (λx -> x x) (λx -> x x), [which I believe is called omega] by hand, you'll soon see that it evaluates to itself
06:10:56 <maitscha> isn't (xx) the identity function?
06:10:56 <scook0> Y essentially takes this trick and tries to make it a bit more useful
06:11:09 <profmakx> maitscha  no its x applied to x
06:11:18 <scook0> (\x. x x) applies its argument to itself
06:11:27 <maitscha> and what does "x applied to x" mean?
06:11:30 <scook0> if you apply it to itself, it applies itself to itself
06:11:38 <profmakx> if tou are not used to lambda-expressions it might be confusing
06:12:19 <scook0> yeah, if that's the case you might want to play around with simpler stuff before jumping into Y head-on
06:13:06 <fox86> does emacs come with haskell-mode by default?
06:13:08 <maitscha> no, normally I understand lambda expressions (e.a. \x -> yx or \x -> x or something similar)
06:13:20 <profmakx> maitscha thats a lambda abstraction
06:13:21 <fasta> fox86: no
06:13:32 <maitscha> (x x) is the application
06:13:33 <profmakx> a lambda-expression is slightly more subtile
06:13:34 <maitscha> x applied to x
06:13:51 <maitscha> x is applied to the function x
06:14:09 <scook0> the function (bound to) x is applied to itself
06:14:33 <doserj> maitscha: don't be ashamed, haskell doesn't understand it either :)
06:15:39 <alexeevg> fox86: it's likely haskell-mode can be installed by your distro's package manager
06:15:50 <fox86> all right. thanks
06:24:25 <vincenz> @join #oasis
06:31:01 <boegel> I'm attending a keynote at the IISWC conference on workload characterization, and the keynote speaker today just made a very cool comment on Haskell
06:31:44 <fox86> boegel: what was that?
06:31:52 <boegel> someone asked if transactional memory, what he (Maurice Herlihy) was talking about will provide a solution for future manycore (100+ cores) systems
06:32:24 <boegel> and his answer was: "Not likely, probably functional languages like Haskell are the most promising approach in that field"
06:32:26 <boegel> coolness
06:32:34 <fox86> nice
06:32:36 <boegel> that were not his exact words, but it boils down to that
06:32:47 <scook0> but haskell has TM! :)
06:33:11 <boegel> scook0: yeah, but he's seeing other oppurtunities probably
06:33:55 <boegel> scook0: he says TM will not be the solution probably, but Haskell might be the first to come up with something which is suited to implement massively parallel programs
06:34:22 <scook0> yeah, but it's kind of funny that some of the same factors that lead to haskell being good for TM will also probably lead to those other approaches
06:34:54 <scook0> e.g. purity
06:35:05 <boegel> why is it "funny"
06:35:09 <boegel> I'd say it's interesting
06:35:25 <scook0> that's more or less what I meant by "funny"
06:35:35 <boegel> scook0: ah ok :-)
06:35:55 <fasta> boegel: and who is that keynote speaker and why do you think he knows what he is talking about?
06:35:58 <boegel> scook0: I'll try to get my advisor into using Haskell in his research, because he's highly interested in TM and other stuff
06:36:02 <boegel> although I'm not :P
06:36:31 <boegel> fasta: Maurice Herlihy, and because they invited him :-) he seems to know very well what he's talking about
06:36:37 <roconnor> TM?
06:36:43 <scook0> transactional memory
06:36:43 <boegel> roconnor: transactional memory
06:36:47 <roconnor> ah
06:36:50 <boegel> scook0: heh, I was first! :P
06:36:56 <roconnor> we are dropping the S now?
06:37:15 <doserj> if you do HTM or STM is an implementation detail
06:37:16 <roconnor> I understand dropping the N from NMRI, but software?
06:37:41 <scook0> a lot of people are interested in HTM these days, apparently
06:37:52 <roconnor> doserj: oh
06:39:37 <scook0> the nice thing about TM in haskell is that the type system effectively gives you strong atomicity "for free"
06:39:58 <scook0> since you can't read transactional variables outside of a transaction anyway
06:40:19 <boegel> scook0: cool
06:41:20 <scook0> whereas achieving strong atomicity in general seems to impose significant performance penalties on non-transactional code
06:42:00 <scook0> (alternatively, you could say that in haskell, strong and weak atomicity are indistinguishable)
06:42:07 <boegel> scook0: that issue was raised her just now too
06:43:04 <boegel> scook0: I'm nowhere near an expert, I just find it interesting how Haskell is popping up here
06:43:08 <boegel> anyway, I need to go
06:43:47 <boegel> bye
07:16:44 <kpreid> Is there an option to make ghci not print its banner?
07:26:55 <EvilTerran> -v0 (for "no verbosity")
07:31:11 <fasta> EvilTerran: I think there's a newer flag too, now.
07:31:29 <fasta> EvilTerran: someone asked for it in Trac and it was implemented.
07:31:49 <EvilTerran> okay
07:45:01 <iguana_> foo 3 "ab" -> "ababab"
07:45:03 <iguana_> what's foo?
07:45:35 <iguana_> is there anything except concat.replicate?
07:45:38 <quicksilver> iguana_: concat . replicate
07:46:09 <Japsu> @pl concat . replicate
07:46:09 <lambdabot> join . replicate
07:46:16 <Japsu> ...bah
07:46:22 <quicksilver> well really it's (concat .) . replicate
07:46:46 <quicksilver> the former was a convenient shorthand :)
07:46:59 <quicksilver> > concat . replicate 3 $ "ab"
07:47:01 <lambdabot>  "ababab"
07:47:08 <quicksilver> > ( (concat.) . replicate) 3 "ab"
07:47:09 <lambdabot>  "ababab"
07:47:17 * quicksilver . . o o O ( magic! )
07:47:41 <iguana_> > fromRational 1%2 :: Int
07:47:42 <lambdabot>  Couldn't match expected type `Int' against inferred type `Ratio a'
07:47:51 <iguana_> > toInteger 1%2 :: Int
07:47:51 <lambdabot>  Couldn't match expected type `Int'
07:47:53 <iguana_> grml
07:47:58 <iguana_> I never get these right
07:48:01 <byorgey> iguana_: what are you trying to do?
07:48:01 <fasta> > (concat . take 3 . cycle) "ab"
07:48:02 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
07:48:08 <iguana_> > floor 1%2 :: Int
07:48:09 <lambdabot>  Couldn't match expected type `Int' against inferred type `Ratio b'
07:48:11 <fasta> > (concat . take 3 . cycle) ["ab"]
07:48:12 <lambdabot>  "ababab"
07:48:20 <iguana_> byorgey: get an int out of a rational
07:48:31 <byorgey> iguana_: I think you need parentheses
07:48:31 <fasta> > (concat . take 3 . cycle.return) "ab"
07:48:32 <lambdabot>  "ababab"
07:48:38 <byorgey> > floor (1%2) :: Int
07:48:39 <lambdabot>  0
07:48:42 <iguana_> ah
07:48:46 <iguana_> sorry
07:48:48 <byorgey> otherwise the floor only applies to the 1
07:48:52 <iguana_> silly me
07:49:09 <byorgey> function application has highest precedence
07:49:45 <byorgey> no need to apologize =)
07:50:08 <iguana_> well, I should know *that* by now
07:51:12 <byorgey> ah, well, give yourself a good smack on the forehead then =)
07:54:31 <axm> is is someway possible to have a collection of unknown length where the element types are known to be instances of certain type classes but their concrete types differ?
07:55:30 <sjanssen> axm: yes, you'll need to introduce an existential wrapper
07:56:03 <sjanssen> say you want to wrap elements that are instances of Show
07:56:31 <sjanssen> introduce the wrapper type: data Showable = forall a. Show a => Showable a
07:57:04 <axm> hm, i think i tried something in that direction, let me see what my problem was
07:57:06 <sjanssen> then you can write [Showable 3, Showable "foo", Showable ()]
07:58:03 <axm> ah, yes, in my context it is a little bit ugly to do that, but i guess no way around it
07:58:35 <axm> thanks
07:59:20 <fasta> Auto-existentials would be nice too. I.e. ["foo", 1, ()] has type intersection of the type classes they belong too.
07:59:58 <axm> yeah, i was hoping for something like that
08:00:23 <fasta> I wonder what the implications of that are for the rest of the system.
08:00:50 <sjanssen> fasta: seems like a big change
08:01:11 <phobes> It would be smaller if Haskell explicitly supported existentials
08:01:12 <axm> trying to do code evaluation from string insertion while trying to stay as clean as possible is nothing i would say haskell is easy for
08:01:29 <fasta> sjanssen: that's easy to say, but why? :)
08:01:42 <quicksilver> fasta: there would be a problem when unwrapping them, too
08:01:53 <phobes> It would have to invent that Showable type?
08:01:59 <quicksilver> fasta: the explicit constructor gives a lexical location within which you can 'access' the existentially bound type
08:02:05 <sjanssen> fasta: intuition, you'd have to ask one of the type-heads for real proof
08:02:18 <quicksilver> fasta: if you somehow make that implicit you have an interesting inference problem
08:02:46 <quicksilver> ...people have suggested variations on 'case' for unwrapping anonymous existentials
08:02:52 <quicksilver> but they all looked a bit ugly at first sight
08:03:01 <fasta> quicksilver: it could automatically define ShowableFooAble
08:03:07 <jfredett> is there a channel for yi? or will I have to take my ranting to haskell-blah?
08:03:18 <quicksilver> fasta: yes, I can imagine what it might do on wrapping
08:03:25 <quicksilver> fasta: it's the unwrapping I was talking about
08:03:45 <phobes> Why not just add a canonical existential type:   exists a.  C1 a, C2 a... => a
08:03:55 <quicksilver> phobes: for the reasons I just explained
08:04:01 <quicksilver> phobes: you need a syntax for unwrapping it
08:04:13 <phobes> You do?
08:04:17 <quicksilver> yup
08:04:29 <fasta> quicksilver: What are we unwrapping exactly?
08:04:30 <quicksilver> otherwise you have no way of bringing the existential type variable 'back in scope'
08:04:30 <phobes> why?
08:04:42 <quicksilver> well, how do you show a Showable?
08:04:44 <quicksilver> like this:
08:04:54 <quicksilver> showShowable a = case s of Showable x -> show x
08:05:02 <quicksilver> s/s/a/; sorry
08:05:38 <quicksilver> you have to get from 'a' which has existential type
08:05:38 <phobes> You just make some type an instance of Show
08:05:49 <phobes> and then allow any instance of Show to be cast to an existential
08:05:50 <quicksilver> to 'x' which has type Show b => b
08:06:06 <fasta> quicksilver: Well, you could use compile time reflection and ask for the list of type classes that it needs.
08:06:23 <quicksilver> you could auto-promote all classes over an existential
08:06:27 <quicksilver> that might do the trick
08:06:32 <phobes> I think that must be what I'
08:06:36 <phobes> m suggesting
08:06:41 <quicksilver> when auto-making Showable, you automatically make instance Showable Show
08:06:49 <quicksilver> yeah, that might be good enough in fact
08:06:52 <phobes> I'm saying skip that step
08:07:04 <phobes> Well, I guess you would need a wrapper type under the covers
08:07:09 <phobes> but that's an implementation detail
08:07:26 <phobes> The programmer would never see or know anything about Showable
08:07:27 <quicksilver> unfortunately those implementation details tend to be observable
08:07:33 <phobes> why?
08:07:40 <quicksilver> since you can normally observe how many ways there are of getting _|_
08:07:50 <quicksilver> slightly frustrating but not the end of the world
08:08:21 <phobes> I don't think that would apply here would it?
08:08:30 <sjanssen> why does haskellwiki's search suck so badly?
08:09:18 <quicksilver> phobes: well, what you're really doing is boxing up a tuple (Show Dictionary, Value)
08:09:35 <phobes> quicksilver:  right, that's why you need the wrapper type in the implementation
08:09:39 <quicksilver> phobes: I think you might be able to observe the difference between "whole thing is _|_" and "dictionary exists but value is _|_"
08:09:45 <phobes> hmm
08:10:17 <fasta> Hmm, I wonder why it doesn't link....
08:10:22 <quicksilver> at least, for some type classes you can observe that
08:10:29 <quicksilver> if the type class contains some non-strict functions
08:10:41 <quicksilver> but, I don't think it breaks the idea completely
08:10:52 <quicksilver> it just makes it not quite transparent, to the skilled eye
08:11:00 <phobes> I'm sure you could hide that problem
08:11:10 <phobes> If they go to access the dictionary, first try to evaluate the VAlue
08:11:49 <puusorsa> :se noai
08:11:49 <puusorsa> ab:se ai
08:11:58 <quicksilver> but that changes the semantics
08:12:01 <puusorsa> .. nice mispaste, sorry
08:12:07 <quicksilver> why should we forbid (Dictonary,_|_)
08:12:25 <quicksilver> that screws up things like sizeof (undefined :: Int)
08:12:43 <phobes> true ... I'm not sure I even understand the problem
08:12:50 <quicksilver> I don't think it is a problem
08:12:59 <quicksilver> I was just pointing out that you couldn't hide the wrapper tyep completely
08:13:15 <quicksilver> someone with a deep understanding of haskells semantics would be able to 'observe' the wrapper
08:13:24 <quicksilver> I think you might want to give the wrapper a name for error messages anyway
08:13:47 <phobes> well, wait...  sizeof (undefined :: Int) works without a wrapper class, right?
08:18:38 <vincenz> > sizeof (undefined ::Int)
08:18:40 <lambdabot>   Not in scope: `sizeof'
08:18:51 <quicksilver> phobes: yes, it does
08:19:05 <quicksilver> phobes: but suppose I wanted to do stuff like that in your existential?
08:19:05 <roconnor> @bab nl en kapucijners
08:19:07 <lambdabot>   marrowfats
08:19:14 <quicksilver> phobes: I might want a list-of-undefineds :)
08:19:24 <quicksilver> phobes: acting as a stand-in for a list of types, basically
08:19:53 <mauke_> > sizeOf (undefined :: Int)
08:19:54 <lambdabot>   Not in scope: `sizeOf'
08:20:28 <roconnor> oops, I missed when shopping
08:20:39 <quicksilver> [undefined::Int,undefined::Double] :: [Storableable]
08:21:27 <phobes> quicksilver:  sizeof comes from Storableable?
08:21:34 <mauke_> @index sizeOf
08:21:35 <lambdabot> Foreign.Storable, Foreign
08:21:36 <phobes> (or Storable :) )
08:21:38 <quicksilver> phobes: sizeof comes from Storable
08:21:48 <quicksilver> phobes: Storableable was the existential we were discussing :)
08:21:49 <phobes> ok, that's a good example then...
08:22:04 <phobes> hmm
08:22:13 <quicksilver> [undefined::Int,undefined::Double] :: [exists x . Storable x => x]
08:22:16 <quicksilver> if you prefer
08:22:23 <phobes> ya ok
08:22:57 <phobes> So this example seems to me to shows why you don't want to force evaluation of Value when accessing the dictionary
08:23:28 <phobes> What's an example of where converting to the existential visibly changes behavior?
08:24:29 <phobes> You could simplify to just    [undefined::Int] <: [undefined::exists x. Storable x => x]
08:24:35 <phobes> err
08:24:37 <phobes> that was all wrong :)\
08:24:40 <quicksilver> well if a :: exists x . Sotrable x => x
08:24:46 <jfredett> is there a channel for yi? or will I have to take my ranting to haskell-blah?
08:24:48 <quicksilver> then a itself can be non-_|_
08:25:01 <quicksilver> (because you can run sizeof on it)
08:25:06 <quicksilver> but the 'thing' inside a is _|_
08:25:19 <quicksilver> and if you run one of the other, more strict methods, you'll see it is
08:25:29 <phobes> but you can already run sizeof on _|_, right?
08:25:34 <quicksilver> so the existential 'proves' it has another level of _|_-ness
08:25:51 <quicksilver> phobes: yes, but this new thing would be something you could run seq on
08:25:57 <quicksilver> thuse proving it's not _|_
08:26:01 <shapr> Pull the other one, it's got bottoms on!
08:26:03 <quicksilver> and you could run sizeof on it
08:26:07 <quicksilver> (thus provign it's useful)
08:26:11 <quicksilver> but if you ran a strict method on it
08:26:14 <quicksilver> it would diverge
08:26:19 <quicksilver> so it's _|_ in some sense, but not others
08:26:25 <quicksilver> this is not a *problem* per se
08:26:30 <quicksilver> it's just an observable difference
08:26:36 <quicksilver> you can witness the exists x .
08:27:53 <sjanssen> quicksilver: can't this difference be avoided?
08:28:02 <phobes> I don't even see the difference
08:28:04 <quicksilver> sjanssen: I don't think so, but I may be wrong.
08:28:21 <phobes> sizeof can be run on undefined, existential or not, right?
08:28:34 <quicksilver> phobes: right
08:28:47 <quicksilver> phobes: but 'seq' could be run on the existential
08:28:50 <sjanssen> have the compiler tag these existential wrappers specially, make seq dereference beyond the dictionary
08:29:06 <quicksilver> phobes: however 'seq' cannot be run on the underlying thing
08:29:10 <phobes> quicksilver:  What is the source for 'seq'?
08:29:19 <phobes> If it's a built-in, then just change behavior for seq
08:29:37 <quicksilver> sjanssen: maybe. I can't convince myself if that has unpleasant consequences or not.
08:29:53 <sjanssen> quicksilver: I'm not sure either
08:29:59 <mauke_> @ssrc seq
08:29:59 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:30:09 <quicksilver> phobes: seq is built-in, it can't have source
08:30:21 <phobes> quicksilver:  that's what I thought
08:30:28 <quicksilver> phobes: seq a b is _|_ if a is _|_ otherwise it is b
08:30:33 <phobes> ya
08:31:40 <phobes> It seems like 'seq' on an existential type should evaluate the 'value'... since we're hiding the data constructor for this wrapper type, you'd have no other way to do so
08:32:03 <quicksilver> yes, that's what sjanssen was suggesting
08:32:12 <phobes> right, I'm just concurring :)
08:32:20 <quicksilver> it's not obvious to me that that is OK. But it might be.
08:32:39 <phobes> It's obvious to me that it is OK.  But it might not be.  :^)
08:33:11 <phobes> I'm not really serious with that... it's not obvious, but intuitive
08:34:05 <phobes> but I don't know GHC internals well enough for anything to be obvious
08:34:42 <phobes> ok, thanks for the discussion quicksilver.  bbl
08:37:57 <Ben`> if I have a list of strings, how can I find which string is longest?
08:38:35 <sjanssen> Ben`: maximumBy (comparing length)
08:38:53 <sjanssen> is the simplest way
08:39:35 <Ben`> what module is comparing in?
08:39:41 <sjanssen> or you can avoid computing length repeatedly (potentially expensive)
08:39:42 <sjanssen> Data.Ord
08:39:47 <dylan> @hoogle comparing
08:39:48 <lambdabot> No matches found
08:39:56 <Ben`> sjanssen: ok, thanks
08:40:14 <sjanssen> map snd . sort . map (\x -> (length x, x))
08:40:39 <byorgey> sjanssen: what's that called again?  "the ____ transform"?
08:40:46 <ari> Schwartzian
08:40:47 <sjanssen> byorgey: schwartzian
08:40:49 <byorgey> ah yes
08:41:15 <xerox> :t fst . maximumBy (comparing snd) . map (ap (,) length)
08:41:17 <lambdabot> forall a. [[a]] -> [a]
08:41:22 <quicksilver> not often do we learn useful FP techniques from a perl programmer :)
08:41:30 <byorgey> hehe =)
08:41:50 <maitscha_> hmm... what is the benefit of the lambda-notation and why is it used in some newer object-oriented languages?
08:41:53 <byorgey> yes, I was just reading an article by MJD on infinite streams in Perl
08:42:02 <byorgey> and I was like, "why on earth does he not know Haskell?"
08:42:06 <quicksilver> maitscha_: expressivenees/conciseness
08:42:07 <sjanssen> finally, a version that can cope with an infinite list: lenCmp [] [] = EQ; lenCmp (_:xs) (_:ys) = lenCmp xs ys; lenCmp [] _ = LT; lenCmp _ [] = GT; sortBy lenCmp
08:43:24 <sjanssen> maitscha_: higher order functions (like map, foldr, filter) are very useful.  Lambda makes these functions easier to use
08:43:28 <quicksilver> sjanssen: then there is the version which you can 'fold' with because it returns the longest, and is O(n) instead of O(n log n)
08:44:13 <quicksilver> maitscha_: java libraries have been written with higher order functions, but the overhead of creating a fresh class for every anonmous function make them feel clumsy to use
08:44:17 <Olathe> > (map snd . sortBy (comparing fst) . map ((,) =<< length)) ["test", "a", "ab"]
08:44:18 <lambdabot>  ["a","ab","test"]
08:44:19 <quicksilver> maitscha_: and clumsy to type, too :)
08:45:12 <EvilTerran> @src until
08:45:13 <lambdabot> until p f x | p x       = x
08:45:13 <lambdabot>             | otherwise = until p f (f x)
08:46:15 * EvilTerran was almost expecting (until p f = head . dropWhile (not.p) . iterate f)
08:46:35 <quicksilver> EvilTerran: yes, I've always used dropWhile for that
08:46:44 <EvilTerran> @pl until p f = head . dropWhile (not.p) . iterate f
08:46:44 <lambdabot> until = ((head .) .) . (. iterate) . (.) . dropWhile . (not .)
08:46:55 <EvilTerran> mmm. let's not.
08:47:33 <maitscha_> so it's only the syntax of the lambda-notation which have object-oriented languages overtaken
08:47:47 <maitscha_> the use of anonymous functions
08:48:04 <quicksilver> yes, because it's so convenient
08:48:07 <maitscha_> which are, by default, not available in oo-languages
08:48:09 <quicksilver> > map (+1) [1,2,3]
08:48:11 <lambdabot>  [2,3,4]
08:48:15 <EvilTerran> i think hindley-milner's better than OO-style polymorphism, too
08:48:16 <maitscha_> ok
08:48:20 <quicksilver> while that's a toy exacmple, it's very handy
08:48:23 <quicksilver> to say things like that
08:48:39 <quicksilver> mapM_ (moveShip >> drawShip) allShips
08:48:59 <quicksilver> ^^ in classic java, that is a 6 line loop instead of a one-line command
08:49:12 <idnar> I haven't seen an imperative programming language that actually has a convenient lambda syntax though
08:49:14 <byorgey> mapM_ (armMissile >> launchMissile) allMissiles
08:49:15 <EvilTerran> "hindley-milner"? sorry, i'm sure i'm abusing terminology. typeclasses! whatever the technical term for type systems with typeclasses is
08:49:16 <quicksilver> well, four lines maybe :)
08:49:31 <EvilTerran> idnar, perl has sub{...}
08:49:41 <maitscha_> and some oo-languages have now functions like list.map(...), I think its also only the name and the concept what this functions do.
08:49:47 <Philippa_> EvilTerran: "type classes"
08:50:06 <EvilTerran> lua has "function (...) ... end", iirc, which is pretty terse
08:50:06 <idnar> in Haskell, for example, you have currying, and function calls basically have zero punctuation to delimit them, so invoking map is very concise
08:50:13 <byorgey> python has lambda x : blah blah, which isn't too bad
08:50:14 <Philippa_> H-M's just the basic parametric polymorphism stuff, no classes
08:50:16 <idnar> so you just say "map (+1) somelist"
08:50:36 <idnar> in Python, that's "map(lambda x: x + 1, somelist)" which is really clunky IMO
08:50:47 <idnar> (of course, in real Python code, you'd write that [x + 1 for x in somelist])
08:50:52 <quicksilver> lots of little things add up
08:50:59 <quicksilver> lambdas help
08:51:03 <mauke> map $_+1, @list
08:51:07 <quicksilver> having a 1-char symbol for lambda helps
08:51:13 <idnar> in JavaScript, that's "map((function (x) { return x + 1; }), somelist);" which is even worse
08:51:16 <EvilTerran> Philippa_, yeah, i realised that after i hit enter. i was just wondering if there was a name for type-system-with-typeclasses, other than the obvious.
08:51:17 <quicksilver> sections help
08:51:19 <mauke> who needs lambdas if your language has builtin support for map? :-)
08:51:42 <idnar> mauke: sure, but map and filter aren't the only higher-order functions :P
08:51:43 <quicksilver> mauke: perl is annoyingly non uniform; in some cases you can use the nice $_ pseudo-lambda
08:51:52 <quicksilver> mauke: but then when you try to nest two, you get in a mess
08:52:07 <mauke> idnar: ok, and sort
08:52:32 <EvilTerran> sort { $b <=> $a } @list; :P
08:52:53 <mauke> reduce { $a * $b } 1, @list  # product
08:52:59 <maitscha_> hmm... i thought java does not have higher order functions
08:53:16 <quicksilver> maitscha_: it has a particularly unpleasant possibility of going via anonymous classes
08:53:25 <EvilTerran> maitscha_, it fakes it with anonymous classes that implement Runnable, iirc
08:53:52 <maitscha_> oh, ok, only a work-arround
08:53:58 <quicksilver> map ( new Runnable { run1 (x) { return x + 1; } } , list )
08:54:14 <quicksilver> something along those lines
08:55:15 <byorgey> yuck =P
08:56:32 <fax> Needs more inferrable types to be declared explicitly :)
09:01:42 <b_jonas> I'll have to rewrite some functions
09:06:38 <fax> Curry looks quite nice
09:06:51 <fax> http://www.informatik.uni-kiel.de/~mh/curry/examples/
09:06:52 <lambdabot> Title: Curry Examples
09:07:10 <quicksilver> people have put much prettier front-ends onto java, though
09:07:15 <quicksilver> groovy has some nice tricks
09:11:42 <dons> ?users
09:11:43 <lambdabot> Maximum users seen in #haskell: 420, currently: 379 (90.2%), active: 15 (4.0%)
09:12:07 <pjd> hashkell
09:12:32 <mrd> the best preprocessor for java is rm
09:13:27 <fax> Interesting having lazy evaluation meet logic programming
09:14:36 <pejo> fax, you at IFL?
09:14:56 <fax> I don't think so, what is IFL?
09:15:14 <JohnnyL> are there templates in haskell?
09:15:16 <pejo> fax, conference. There was someone talking about Curry and .. something earlier today.
09:15:24 <fax> ah, sadly I missed that
09:16:20 <mrd> JohnnyL: what sort of templates
09:16:31 <JohnnyL> mrd, akin to lisp macros.
09:16:38 <mrd> template haskell
09:16:42 <JohnnyL> oh ok
09:16:52 <mauke> liskell
09:16:54 <mrd> mind you that 90% of the use of lisp macros isn't necessary in haskell
09:17:58 <JohnnyL> it seems to be a nice way of making websites that require frequent changes.
09:19:00 <axm> mh, there is no way to make a function type with an unknown parameter count, right?
09:19:14 <allbery_b> @source Text.Printf
09:19:14 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
09:19:14 <quicksilver> axm: there is, but you probably dont' want to :)
09:19:21 <allbery_b> read.  weep.
09:19:25 <axm> oh, believe me :)
09:19:26 <phobes> axm:  The parameter count is always 1
09:19:49 <mrd> oh it's not that bad
09:20:20 * wli needs some way to blog where most of the blog content is LaTeX -generated stuff.
09:21:03 <mrd> wli: research paper
09:21:09 * mrd ducks
09:21:13 <fax> yikes
09:21:26 <fax> These curry example codes put me to shame :/
09:21:45 <wli> fax: URL?
09:21:45 <jonathanv> currying is awesome
09:22:01 <fax> http://www.informatik.uni-kiel.de/~mh/curry/examples/
09:22:01 <lambdabot> Title: Curry Examples
09:22:20 <axm> you have a point there phobes, but currying in dynamic code is sth i haven't thought about yet. i am a bit intimidated, but lets see
09:23:48 <phobes> axm:  Haskell's type system isn't really strong enough to (conveniently) support that
09:24:42 <axm> i figured that out after a couple of days, not having anything done functional before, yes
09:25:36 <axm> but as long as i could not explain why, i am not quite confident with myself
09:26:36 <axm> *content
09:27:48 <Saizan> wli: sjassen started working on that using pandoc+happs
09:28:04 <wli> Saizan: Very nice.
09:28:31 <wli> Saizan: I'm very interested in volunteering to be a test victim at some point.
09:29:52 <sjanssen> correction, sjanssen talked about wanting to do that, but never did anything
09:29:55 <sjanssen> :)
09:34:34 <Saizan> ah :D
09:34:57 <quicksilver> axm: for variable arguments, a function which takes a list is a lot more sane, normally :)
09:35:53 <axm> yip, but i would need to map that to the curried notation, so thats what led me to the question
09:36:01 <axm> still reading printf
09:36:51 <crazy_coder> has anyone implemented the minmax algo ?
09:37:21 <Saizan> uhm i need >0 arguments.. any suggestions for minimal uglyness?
09:38:46 <axm> crazy_coder, have you precised that specification (say, added type signatures)?
09:40:36 <jMCg> Uh..
09:40:48 <jMCg> Hello boys and girls.
09:41:01 <axm> hm, i do not think that is a correct english word, damn you wine. *made more precise
09:43:12 <shapr> hiya jMCg, are you learning Haskell?
09:44:28 <jMCg> shapr: nope.. bored from PHP compile and I wondered if I could compile ghc + pugs6 faster than php
09:44:35 <jMCg> I appear to have failed.
09:44:55 <profmakx> why compile it yourself in the first place?
09:45:07 <pjd> profmakx: it's the civilized thing to do
09:45:11 <jMCg> profmakx: ubuntu doesn't have ghc.
09:45:16 <shapr> Really?
09:45:17 <shapr> I thought it did.
09:45:20 <mauke> then you can't compile ghc
09:45:24 <shapr> jMCg: Did you try to install ghc6?
09:45:26 <shapr> or just ghc?
09:45:34 <profmakx> ubuntu does have ghc
09:45:35 <mauke> ghc needs ghc to compile
09:45:36 <profmakx> snf
09:45:42 <axm> jMCg, it does
09:45:46 <axm> running here
09:45:58 <profmakx> and, imho, normally compiling oneself is an utter waste of time
09:47:13 <jMCg>   apt-cache search ghc | grep -c ghc -> 0
09:47:58 <profmakx> for one its aptitude, and then probably you didnt include universe or however it is called
09:48:24 <byorgey> you don't have to use aptitude profmakx
09:48:44 <axm> aptitude = apt-* plus remove unused packages on update for example
09:49:18 <byorgey> jMCg: go to System > Administration > Software Sources and enable universe
09:49:29 <jMCg> grep verse /etc/apt/sources.list | grep -v '^#' | grep -v 'src' -> deb http://at.archive.ubuntu.com/ubuntu/ feisty universe multiverse  non-free
09:49:30 <lambdabot> Title: Index of /ubuntu
09:50:17 <byorgey> jMCg: apt-get install ghc doesn't work?
09:50:34 <byorgey> jMCg: I'm running Ubuntu and I definitely have a ghc package installed.
09:50:44 <byorgey> or maybe apt-get install ghc6
09:50:57 <byorgey> I think ghc is a virtual package or somesuch
09:51:00 <axm> strange, it tells me it is not installed here. works fine though
09:51:00 <jMCg> byorgey: which version?
09:51:34 <byorgey> of Ubuntu? feisty
09:51:43 <axm> just, assuring, updated?
09:51:56 <axm> edgy has only 6.4, so that would be a reason to compile
09:52:14 <byorgey> of ghc, 6.6
09:53:27 <jMCg> Damn... PHP compile done and I'm still far far away from ghc, letalone pugs.
09:54:20 <byorgey> jMCg: what happens when you do apt-get install ghc6?
09:55:09 <jMCg> byorgey: E: Couldn't find package ghc6
09:56:03 <byorgey> bizarre
09:56:04 <maitscha_> hmmm ... I do not understand what an expression like \x.(e(xx)) \x.(e(xx)) means... somebody has an real example... ???
09:56:31 <mauke> what's the e for?
09:56:55 <byorgey> jMCg: on my system: apt-cache search 'ghc' | grep -c ghc -> 63
09:57:15 <pastorn> maitscha_: paste?
09:58:03 <byorgey> jMCg: I assume you've done an apt-get update recently? (grasping at straws here)
09:58:14 <byorgey> I guess that's done automatically anyway...
09:58:47 <maitscha_> the is an expression
09:59:09 <maitscha_> it's the Y-kombinator for recursiv function in the lambda-calculus
09:59:21 <maitscha_> the e is an expression
09:59:53 <Saizan> maitscha_: the Y combinator is \f. (\x. f (x x)) (\x. f (x x))
10:00:08 <axm> byorgey, not by the command line tools
10:00:28 <byorgey> axm: what's the difference?
10:00:39 <Saizan> maitscha_: your expression is what you get when you beta-reduce from (Y e)
10:00:59 <axm> i think the gui does an update each startup, or what do you mean?
10:01:29 <jMCg> byorgey: I'm looking into it. I do wonder if I fucked up something in /etc/apt/sources.list.
10:02:11 <jMCg> On my Debian server this works perfectly fine.
10:02:21 <byorgey> that's a possibility
10:02:29 <axm> there was a major update not long ago. i wonder if that is why my ghc is not listed as installed anymore. probably not a good time to try and find out ;)
10:02:50 <byorgey> axm: the ghc package isn't listed as installed on my system either, it's ghc6
10:02:59 <axm> thats what i mean
10:03:03 <byorgey> ah, ok
10:03:17 <Saizan> Y e = (\f. (\x. f (x x)) (\x. f (x x))) e = (\x. e (x x)) (\x. e (x x)) = e ((\x. e (x x)) (\x. e (x x))) so you can see that Y e = e (Y e)
10:04:22 <jMCg> byorgey: aaaaaaaanyways... In order to build pugs6, I need 6.6.1, which failed on me.
10:04:45 <jMCg> Hum
10:05:01 <byorgey> ah, I see.  well, I've never built ghc myself, so I'm afraid I'm not of much help
10:05:02 <jMCg> And I do wonder where pear has gotten.
10:07:36 <jMCg> I still/again feel the urge to kill PHP devs. brb.
10:08:19 <axm> jMCg, i tried to compile 6.6 with 6.4, gave no errors, but the build was fucked up for reasons i still do not know, took me long to find out as well, so if it is not for fun, let me add my bit of discouragement
10:10:28 <jMCg> axm: compiling dodgy software is a private hobby of me, which I do almost profesionally.
10:11:04 <axm> ok, feel free to ignore me :)
10:11:29 <maitscha_> hmmm...
10:11:38 <jMCg> axm: there's *always* a reason.
10:11:43 <maitscha_> and what does the expression (x x) ?
10:11:45 <jMCg> axm: unless you're compiling PHP.
10:11:51 <axm> for ignoring me? ;)
10:12:02 <axm> why is that?
10:12:05 <jMCg> axm: for fucked up compiles.
10:12:09 <maitscha_> I can't imagine what (x x) does, what would it do in an, say ... oo-world ?
10:12:27 <mauke> you've never seen a function call?
10:12:29 <jMCg> axm: php-5.2.4 % wc -l configure -> 116707 -- go figure.
10:13:11 <axm> thanks, i'll skip on that fun
10:13:25 <xerox> > let x = \_ x -> x in (x x) 1 -- maitscha_
10:13:26 <lambdabot>  1
10:14:44 <b_jonas> but it's not called with itself there
10:14:56 <b_jonas> there the two x-s in (x x) have different types
10:15:05 <b_jonas> or not?
10:15:07 <axm> can that be?
10:15:20 <xerox> > fix (\_ x -> x) "no"
10:15:21 <lambdabot>  "no"
10:15:29 <fax> :t \x -> x x
10:15:31 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:15:32 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:15:46 <b_jonas> @type x = \_ x -> x
10:15:48 <lambdabot> parse error on input `='
10:15:53 <b_jonas> @type \_ x -> x
10:15:55 <lambdabot> forall t t1. t -> t1 -> t1
10:16:36 <fax> @djinn ((a, b) -> c) -> a -> b -> c
10:16:36 <lambdabot> f a b c = a (b, c)
10:16:47 <fax> @djinn a -> b -> c -> ((a, b) -> c)
10:16:47 <lambdabot> f _ _ a _ = a
10:17:00 <xerox> fax: you need parens around the first argument
10:17:07 <fax> oops
10:17:08 <xerox> ...'s type
10:17:30 <fax> @djinn (a -> b -> c) -> (a, b) -> c
10:17:31 <lambdabot> f a (b, c) = a b c
10:17:45 <mauke> @. pl djinn (a -> b -> c) -> (a, b) -> c
10:17:45 <lambdabot> f = (`ap` snd) . (. fst)
10:18:17 <fax> > let asdf (x, y) = x+y in ((`ap` snd) . (. fst) asdf) 1 2
10:18:18 <lambdabot>   add an instance declaration for (Num (a, b))
10:18:20 <int-e> @type uncurry
10:18:23 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:18:57 <fax> > let asdf x y = x+y in ((`ap` snd) . (. fst) asdf) (1, 2)
10:18:57 <lambdabot>  Couldn't match expected type `b1 -> b'
10:20:23 <maitscha_> hui
10:20:26 <fax> @src uncurry
10:20:26 <lambdabot> uncurry f p = f (fst p) (snd p)
10:21:37 <maitscha_> is x a function or a variable?
10:21:42 <mauke> same thing
10:22:22 <fax> variable
10:22:46 <mauke> that's like asking "is i an int or a variable?"
10:23:25 <vincenz> that's answerable :)
10:23:26 <fax> Is Bruce a person or a name?
10:23:34 <int-e> > let x f = f + 1 in x 2
10:23:35 <maitscha_> same
10:23:38 <lambdabot>  3
10:23:40 <int-e> > let f x  = x + 1 in f 2
10:23:41 <lambdabot>  3
10:23:50 <vincenz> type Answer a b = Either a (Either b (a, b))
10:23:59 <int-e> (the first version will make mathematicians cringe, but that's merely a convention)
10:24:01 <xerox> maitscha_: a function is something whose type is a result of appying the function type constructor (->) to type variables I'd say?
10:24:14 <maitscha_> yes ok
10:24:54 <b_jonas> a function is something that doesn't give a compile-time error if you try to call it
10:25:06 <DRMacIver> int-e: Eww. Unclean, unclean!
10:25:14 <jaredj> > let f f = f + 1 in f 2
10:25:16 <lambdabot>  3
10:25:38 <vincenz> jaredj: nasty
10:25:49 <xerox> b_jonas: like my dog, most of the time.
10:26:00 <int-e> jaredj: let f f = f where f = 42 in f 23. :)
10:26:32 <b_jonas> > let f f = f where f = 42 in f 23
10:26:33 <lambdabot>  42
10:26:37 <b_jonas> yay
10:26:49 <fax> >:D
10:27:41 <maitscha_> but isn't is so, that e.a  f x  means that the variable x is applied to the function f?
10:27:48 <fax> > let id id = id where id = id in (id id) ()
10:27:50 <lambdabot>  Exception: <<loop>>
10:27:53 <fax> aw :/
10:28:04 <jaredj> id-iotic :)
10:28:08 <omniscientIdiot> where id = id is a black hole
10:28:44 <b_jonas> and I'm writing in case statement
10:29:15 <b_jonas> pity this x f thing is quite irrelevant to what maitscha_ asked
10:29:19 <mauke> maitscha_: no, it means f is applied to x
10:29:37 <fax> > cycle "(id id) id "
10:29:38 <lambdabot>  "(id id) id (id id) id (id id) id (id id) id (id id) id (id id) id (id id) i...
10:29:41 <mauke> maitscha_: both of them are variables. f must contain a function (x doesn't have to)
10:30:12 <jaredj> so maybe
10:30:28 <jaredj> > let f = (\x -> x + 1) in f 42
10:30:29 <lambdabot>  43
10:30:51 <maitscha_> perhaps I miss-understand the application
10:31:24 <b_jonas> I also learned today that 'undefined :: a -> b' and '\x -> undefined :: a -> b', while behave the same wrt function call, behave differently if you seq them
10:31:44 <mauke> yeah, const undefined /= undefined
10:32:35 <mauke> maitscha_: functions are values
10:32:45 <mauke> variables refer to values
10:32:59 <b_jonas> ARGH. I typed 'end' as a keyword. nasty habits in my fingers.
10:33:52 <maitscha_> jkfla
10:34:02 <maitscha_> (sorry, a fly)
10:34:11 <jaredj> lol
10:34:18 <maitscha_> :O
10:34:25 <mauke> don't swallow it!
10:34:37 <b_jonas> how did "f" get in there?
10:34:51 <jaredj> with a
10:34:52 <jaredj> ?
10:34:58 <maitscha_> no, i tried to strike it dead
10:35:29 <jaredj> two handed i suppose
10:35:32 <jaredj> 1. right hand
10:35:34 <jaredj> 2. left hand
10:35:38 <jaredj> ... 3. enter
10:35:46 <jaredj> argh, over-analyzing!
10:36:10 <b_jonas> jaredj: oh yeah, it's an "a" not an a with umlaut
10:36:24 * jaredj googles keyboard layouts
10:37:21 <b_jonas> so in 'let x = \_ x -> x in (x x) 1'
10:37:29 <b_jonas> what types are all the different x-s?
10:37:39 <b_jonas> > let x = \_ y -> y in (x x) 1
10:37:41 <lambdabot>  1
10:37:46 <b_jonas> I assume that means the same
10:38:04 <byorgey> yes, that's the same
10:38:16 <mauke> x :: a -> b -> b
10:38:39 <mauke> where a = c -> d -> d
10:38:52 <mauke> b = Integer
10:39:55 <b_jonas> so are the two xs in parenthesis of the same type?
10:39:56 <maitscha_> i think my problem is that I think to object-orientated
10:40:06 <byorgey> b_jonas: yes, they are the same
10:40:13 <byorgey> they refer to the same value
10:40:22 <b_jonas> nope, it's a generic
10:40:45 <byorgey> b_jonas: ?
10:40:59 <b_jonas> > let f x = (x, 5) in (f 1/2, f "foo")
10:41:00 <lambdabot>   add an instance declaration for (Fractional (t, t1))
10:41:00 <lambdabot>     In the expression:...
10:41:03 <omniscientIdiot> (because of the MMR, I think they might be the same type)
10:41:07 <b_jonas> > let f x = (x, 5) in (f (1/2), f "foo")
10:41:08 <lambdabot>  ((0.5,5),("foo",5))
10:41:19 <b_jonas> there, the two fs on the rhs are clearly not of the same type
10:41:30 <byorgey> maitscha_: yes, it can take a while to learn to think functionally if you're used to something else
10:41:30 <b_jonas> if the two xs were the same type, that type had to be recursive
10:41:47 <b_jonas> which would raise a compile error, woudln't it?
10:42:01 <omniscientIdiot> oh, right
10:42:12 <byorgey> oh, I see, you are referring to the specific types at which they are instantiated
10:42:17 <jaredj> b_jonas: would it?
10:42:59 * jaredj fails to be gnomic
10:43:20 <DRMacIver> Be kdeic instead.
10:43:24 <b_jonas> jaredj: I think it would
10:43:33 <b_jonas> it would be directly recursive, without data
10:43:39 <omniscientIdiot> jaredj: yep, the first x :: a -> Integer -> Integer.  If the second x had that type, then that would try to equate a and (a -> Integer -> Integer), infinite type
10:43:41 <b_jonas> but I can be wrong somewhere
10:44:38 <maitscha_> I thought I have the 3 types NAMES (identifier, e.a. p), ABSTRACTION (like a function definition with a parameter, e.a. \p.p+3 ) and APPLICATION (execution of a function with a variable p, e.a. f p)
10:44:40 <byorgey> well, from that perspective, the x's in (x x) above have types (a -> b -> b) -> c -> c and (a -> b -> b), respectively.
10:44:46 <omniscientIdiot> (so the MMR only applies to typeclass-bounded polymorphism?)
10:46:27 <omniscientIdiot> maitscha_: names can refer to values of any type, including abstractions.  Expressions consist of a tree of applications.
10:46:29 <b_jonas> :t let { x = \_ y -> y; x1 = x; x2 = x; d = (x1 x2) } in (x1, x2)
10:46:31 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t1, t2 -> t3 -> t3)
10:46:45 <b_jonas> that doesn't help because x1 is still generic
10:46:58 <omniscientIdiot> cool!
10:47:32 <omniscientIdiot> why isn't t unified with (t2 -> t3 -> t3)?
10:47:53 <omniscientIdiot> nvm
10:48:07 <omniscientIdiot> it's only that type at the particular instantiation
10:55:06 <elliottt> does anyone know of a library that parses the iso8601 date format?
10:56:15 <maitscha_> \x.(xx) means an abstraction, where x is bound to the application (xx), right?
10:56:45 <pstickne> Meh, going to try and learn Haskell ... again ^^
10:56:46 <pstickne> We have a really small project in Automata and the teacher said "language of choice". Normally you're restricted to C or Java or some other BS.
10:56:48 <byorgey> maitscha_: right.
10:57:39 <byorgey> although in Haskell that would be written \x -> (x x)
10:57:55 <byorgey> pstickne: cool, have fun! =)
10:58:20 <pstickne> byorgey, I'll try ... time to dig out YAHT.
10:58:38 <omniscientIdiot> (\x -> x x) blah = blah blah, i.e. you replace each 'x' with the argument, 'blah'
10:59:09 <maitscha_> ok. i understand so far
10:59:23 <byorgey> pstickne: ask in here if you have any questions, of course
11:00:00 <maitscha_> so the application (x x) "copies" the x to (x x)
11:00:19 <maitscha_> more or less
11:00:36 <byorgey> maitscha_: sure, that's one way to think about it
11:00:39 <pstickne> byorgey, of course. but after some reading and TIAS
11:01:01 <igel> :t (\x -> x x)
11:01:06 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:01:06 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:01:10 <byorgey> TIAS?  um... Trying It And Stuff?
11:01:27 <omniscientIdiot> @vera tias
11:01:28 <lambdabot> No match for "tias".
11:01:42 <byorgey> @help vera
11:01:42 <lambdabot> I perform dictionary lookups via the following 13 commands:
11:01:42 <lambdabot> all-dicts ... Query all databases on dict.org
11:01:42 <lambdabot> devils ...... The Devil's Dictionary
11:01:42 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
11:01:42 <lambdabot> elements .... Elements database
11:01:44 <lambdabot> [9 @more lines]
11:02:12 <omniscientIdiot> vitual emporium for relavent acronyms or some such
11:02:37 <byorgey> cool
11:02:44 <int-e> @devils lawyer
11:02:45 <lambdabot> *** "LAWYER" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
11:02:45 <lambdabot> LAWYER, n.  One skilled in circumvention of the law.
11:02:45 <lambdabot>  
11:02:53 <byorgey> hm, Try It And See?
11:03:14 <omniscientIdiot> @vera fubar
11:03:15 <lambdabot> *** "fubar" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
11:03:15 <lambdabot> FUBAR
11:03:15 <lambdabot>      Fouled / Fucked Up Beyond All Recognition / Repair
11:03:15 <lambdabot>      (telecommunication-slang, Usenet, IRC)
11:03:15 <lambdabot>  
11:03:19 <maitscha_> so \x.(x x) is reduction in the other direction
11:03:26 <byorgey> or Target Identification & Acquisition System
11:03:33 <maitscha_> not reduction, but duplication
11:03:52 <maitscha_> more or less...
11:03:58 <byorgey> maitscha_: sure.
11:04:12 <maitscha_> does it have a special name?
11:04:38 <omniscientIdiot> it's just an ordinary lambda abstraction
11:04:40 <byorgey> you mean, does the function \x. (x x) have a special name?  Not that I know of.
11:04:47 <maitscha_> ok
11:04:56 <maitscha_> i call it "duplication" :)
11:05:02 <vincenz> \x.(x x) is not welltyped
11:05:23 <Japsu> @type \x -> x x
11:05:25 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:05:25 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:05:29 <byorgey> hm, you're right
11:05:43 <vincenz> of course I am :P
11:05:49 <dolio> @type (\x -> x x :: (forall b. b -> a) -> a)
11:05:51 <lambdabot>     Occurs check: cannot construct the infinite type:
11:05:51 <lambdabot>       t = t -> (forall b. b -> a) -> a
11:06:28 <byorgey> maitscha_: are you reading some sort of tutorial or something?
11:06:44 <dolio> @type ((\x -> x x) :: (forall b. b -> a) -> a)
11:06:46 <lambdabot> forall a. (forall b. b -> a) -> a
11:06:54 <maitscha_> yes, I'm reading some slides about recursion with lambda-calculus
11:07:06 <vincenz> though curiously: _|_ is not the ionly inhabitable value
11:07:28 <vincenz> const const .... id id
11:07:30 <maitscha_> and i am very new to lambda and haskell
11:08:12 <omniscientIdiot> have you used any language with first-class functions?
11:08:23 <byorgey> IMO learning about the Y combinator is not the easiest way to start learning about the lambda calculus and Haskell =)
11:08:27 <maitscha_> and I'm very interesting on it because rubby has some elements from haskell, like lambda notation
11:08:55 <maitscha_> I'm a java programmer
11:09:25 <maitscha_> since a lot of years, and very new to rubby
11:10:50 <fax> rubby
11:10:57 <fax> ?
11:11:10 <byorgey> ruby, probably
11:11:13 <omniscientIdiot> ruby
11:11:20 <byorgey> maitscha_: well, welcome =)
11:11:20 <fax> lets see what he says
11:11:33 <maitscha_> I do not understand why there isn't a programming language which combines the best features of both worlds (oo and functional)
11:11:56 <byorgey> because there aren't any good features of OO  ;)
11:11:59 <elliottt> well, there's ocaml :)
11:12:04 <Nafai> maitscha_: I believe Scala attempts that
11:12:25 <lemmih_> @seen ndm
11:12:26 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 3d 18h 30m 59s ago, and .
11:12:30 <maitscha_> scala?
11:12:34 <maitscha_> never heared about
11:12:49 <axm> maitscha_, of course there is always lisp :D
11:13:32 <vincenz> lets not forget scheme
11:13:37 <maitscha_> isn't lisp a little bit to old?
11:13:44 <fax> maitscha_: for what?
11:13:55 <vincenz> fax: for young programming of course :)
11:14:04 <maitscha_> I also need a programming language which has a gui-framework
11:14:23 <axm> does it support clos or something?
11:14:24 <olsner> common lisp has gui bindings
11:14:27 <ttt-> lisp is so amazing, you can build one in 2 minutes
11:14:27 <fax> maitscha_: to old for what?
11:14:49 <omniscientIdiot> I don't know much about Scala, but I think it's an fp on top of the jvm.
11:14:55 <Nafai> omniscientIdiot: Yes
11:15:01 <omniscientIdiot> purposefully javaesque syntax
11:15:03 <DRMacIver> It's not really much of a funtional programming language in my opinion. :)
11:15:05 <maitscha_> really? hmm... perhaps I should take a look at it...
11:15:35 <fax> maitscha_:please answer my queston
11:15:38 <DRMacIver> It's a better functional language than e.g. Ruby or Javascript.
11:15:46 <maitscha_> fax: for gui-programming
11:15:55 <maitscha_> ruby is not a function language
11:16:02 <DRMacIver> Right. :)
11:16:03 <maitscha_> is pure object-orientated
11:16:08 <DRMacIver> Uh huh
11:16:15 <DRMacIver> See 'blocks' for details.
11:16:30 <maitscha_> :)
11:16:43 <omniscientIdiot> javascript and the prototypal inheritance languages it's descended from are arguably purer :)
11:16:48 <glguy> Yeah, Ruby has all sorts of poorly implemented features
11:17:00 <glguy> Javascript as a language isn't all that bad
11:17:01 <b_jonas> 2 minutes I don't belive
11:17:08 <b_jonas> but 60 minutes maybe
11:17:09 <glguy> its just that the DOM is a mess
11:17:13 <b_jonas> I've recently made a simple one
11:17:16 <DRMacIver> glguy: This wasn't intended as a slight against either language.
11:17:42 <DRMacIver> All I'm saying is that Scala is closer to a very good OO language with decent FP support than it is a real functional language.
11:17:48 <vincenz> GPL is like a monad, there's only a way in, never out!
11:18:08 <pjd> it binds you
11:18:25 <vincenz> exactly
11:18:35 <pjd> you have to join the collective :)
11:18:48 * omniscientIdiot doesn't like the popular "You can't escape from a monad!" falacy.
11:18:58 <omniscientIdiot> sure, there's no general m a -> a, but that doesn't preclude specific ones!
11:18:59 <vincenz> omniscientIdiot: unsafePerformLaunchNuke?
11:19:09 <maitscha_> I can't believe that the gui of lisp could bear comparision with one of c# or java
11:19:09 <omniscientIdiot> head, for instance
11:19:11 <omniscientIdiot> @type head
11:19:13 <lambdabot> forall a. [a] -> a
11:19:16 <mauke> unsafePerformGPL
11:19:16 <DRMacIver> head is a bad example.
11:19:20 <omniscientIdiot> m = []
11:19:26 <pjd> omniscientIdiot: you can escape from the GPL too, if you're the copyright owner
11:19:31 <axm> fromGPL
11:19:31 <vincenz> mauke: that can result in jails being set up around your value
11:19:34 <omniscientIdiot> sum, then
11:19:40 <pjd> but again, there is no general way
11:19:42 <fax> :t fromGPL
11:19:44 <lambdabot> Not in scope: `fromGPL'
11:19:57 <glguy> maitscha_: Did you have some questions about Haskell?
11:20:04 <DRMacIver> runState might be a better example.
11:20:13 <DRMacIver> Anyway, time for me to disappear now.
11:20:29 <maitscha_> not about haskell, but about the lambda calculus
11:20:40 <glguy> Oh, OK. What were they?
11:21:08 <maitscha_> with haskell recursion is not so difficult, because I have named functions. but the \-calculus only has anonymous functions...
11:21:16 <maitscha_> and that is my problem
11:21:26 <sjanssen> maitscha_: Y
11:21:33 <maitscha_> so far, I understand what (x x) means
11:21:47 <vincenz> omniscientIdiot: and regarding 'can't escape from a monad'.  It's bad practice to demonadize a value until you've -run- the monad... you don't head inside a list-monad, you wait until you have the result and then 'head' tht
11:21:52 <b_jonas> Monad `instance` GPL where { >>= = ...
11:21:57 <maitscha_> better \x.xx (not well-typed, I know now)
11:22:08 <vincenz> b_jonas: what syntax is that?
11:22:28 <b_jonas> it's re "GPL is like a monad, there's only a way in, never out!" and "it binds you"
11:22:34 <glguy> maitscha_: it is well typed, just not express-able in Haskell because Haskell doesn't allow recursive types.
11:22:35 <maitscha_> yes, the ultimative Y combiner
11:22:43 <vincenz> b_jonas: no... "what syntax is that"
11:22:49 <maitscha_> ok.
11:22:53 <vincenz> I doubt you can infix keywords
11:23:07 <b_jonas> sure you can't
11:23:23 <glguy> > (fix (\f n -> if n == 0 then 1 else n * f (n-1))) 5
11:23:24 <lambdabot>  120
11:23:30 <vincenz> instance Monad GPL where { (>>=) = rms}
11:23:37 <maitscha_> is the Y combiner something like a "reproducer"
11:23:49 <maitscha_> something that makes from one two?
11:24:14 <maitscha_> because Y e => e (Y e)
11:24:27 <fax> maitscha_: fixed point
11:25:26 <pjd> maitscha_: it calls e with a function that calls e with a function that calls e with a function that ...
11:26:14 <maitscha_> but that would be infinite
11:26:20 <pjd> right
11:26:45 <_4> hi
11:26:53 <maitscha_> it must stop ... at any time
11:27:05 <mauke> the details of Y depend on whether your lambda calculus is strict or not
11:27:49 <pjd> maitscha_: with non-strict evaluation, it only starts if it needs to
11:27:56 <vincenz> is Y typable?
11:28:02 <_4> can you tell me s.th. about IRC?
11:28:11 <vincenz> _4: ask on #freenode
11:28:16 <fax> :t let y f = f (y f) in y
11:28:19 <lambdabot> forall t. (t -> t) -> t
11:29:05 <Tac-Tics> what is the best way in Haskell to do a Scheme-style COND statement?
11:29:14 <b_jonas> The Y combinator reminds me to recursive acronyms (like http://www.gnu.org/fun/jokes/gnu-overflow.html or god over djinn)
11:29:15 <lambdabot> Title: GNU-Overflow - GNU Project - Free Software Foundation (FSF)
11:29:15 <Tac-Tics> nested if-elses are cramping my style
11:29:37 <mauke> Tac-Tics: case () of _ | cond1 -> ...
11:29:42 <dmwit> :t let if' cond t f = if cond then t else f in if'
11:29:44 <lambdabot> forall t. Bool -> t -> t -> t
11:29:48 <b_jonas> that's it, the bar syntax
11:29:56 <Tac-Tics> mauke: thanks.. but that's still quite ugly ^^;
11:30:02 <Tac-Tics> but I'll try it
11:31:27 <maitscha_> hmm.. here in my slide I have \x . ( f ( x x ) ) ... perhaps I should try to understand this expression
11:32:01 <pjd> maitscha_: \ x -> f (x x), in Haskell
11:32:13 <Tac-Tics> :t \x -> f (x x)
11:32:16 <lambdabot> Not in scope: `f'
11:32:26 <pjd> :t \x -> ?f (x x)
11:32:28 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:32:29 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:32:35 <maitscha_> \f ( \x . ( f ( x x ) ) \x . ( f ( x x ) ) )
11:33:11 <maitscha_> the holy Y combiner
11:33:36 <b_jonas> see, that's what I said.
11:33:41 <b_jonas> you need a data to do that
11:33:44 <mauke> \f -> (\x -> f (x x)) (\x -> f (x x))
11:33:46 <fax> @djinn (t -> t) -> t
11:33:47 <lambdabot> -- f cannot be realized.
11:33:50 <mauke> (in sane syntax)
11:34:31 <b_jonas> it can be solved with a data: http://www.math.bme.hu/~ambrus/pu/olvashato/t2n.sml
11:35:10 <mauke> "solved"? what's the problem?
11:35:13 <b_jonas> this doesn't have the Y combinator exactly, only something similar
11:35:18 <b_jonas> mauke: recursive types
11:35:31 <mauke> lambda calculus does recursive types
11:35:32 <b_jonas> "Occurs check: cannot construct the infinite type"
11:35:38 <b_jonas> mauke: sure it does
11:35:43 <b_jonas> but if you want to do that in haskell
11:36:22 <dmwit> Isn't this a recursive type? data List a = Nil | Cons a (List a)
11:36:33 <b_jonas> dmwit: yes,
11:36:42 <b_jonas> you can create a recursive type with a data
11:36:46 <maitscha_> \x . xx gets xx, but what gets \x. f(xx) ?
11:36:47 <b_jonas> but not without a data in between
11:37:09 <maitscha_> f applied to (xx) ?
11:37:11 <mauke> maitscha_: what do you mean by "gets"?
11:37:29 <maitscha_> I mean with the reduction, I get (x x)
11:37:29 <mauke> f(x(x))
11:37:53 <dmwit> b_jonas: I'm not sure I follow you.  The infinite type restriction is pretty unrelated to recursive types.
11:38:19 <mauke> (\x -> x x) z ==> (z z)
11:38:21 <b_jonas> I think it is related
11:38:29 <b_jonas> but that's not really important
11:38:52 <b_jonas> what I'm saying is that
11:38:55 <mauke> (\f -> \x -> f (x x)) g z ==> (\x -> g (x x)) z ==> (g (z z))
11:39:20 <b_jonas> the Y combinator and similar things
11:39:21 <b_jonas> like
11:39:26 <b_jonas> @type \x -> xx
11:39:29 <b_jonas> @type \x -> x x
11:39:32 <lambdabot> Not in scope: `xx'
11:39:34 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:39:34 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:39:50 <b_jonas> can not simply be written in haskell because infinite types are forbidden
11:40:04 <b_jonas> but if you define some data, you can write something very close
11:40:14 <b_jonas> that packs and unpacks some function to a data at some places
11:40:41 <b_jonas> that data needs to be recursive of course
11:40:50 <dolio> You can write it in GHC, though.
11:41:16 <vincenz> dolio: you should go to hac!
11:41:32 <dolio> Where is it?
11:43:38 <maitscha_> @type \f -> f f f
11:43:40 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t -> t1
11:43:40 <lambdabot>     Probable cause: `f' is applied to too many arguments
11:43:53 <dolio> @type ((\x -> x x) :: (forall b. b -> a) -> a)
11:43:55 <lambdabot> forall a. (forall b. b -> a) -> a
11:43:56 <vincenz> dolio: Freiburg
11:43:58 <vincenz> germany
11:44:04 <phobes> What is the >>= glyph supposed to look like anyway?
11:44:14 <vincenz> dolio: http://www.haskell.org/haskellwiki/Hac_2007_II
11:44:15 <lambdabot> Title: Hac 2007 II - HaskellWiki
11:44:42 <maitscha_> \f -> f
11:44:55 <maitscha_> @type \f -> f
11:44:57 <lambdabot> forall t. t -> t
11:45:27 <dolio> Ah. Well, that'd be cool, but I need to become a bit wealthier before I can take trips to Germany. :)
11:46:17 <olsner> @src (>>)
11:46:17 <lambdabot> m >> k      = m >>= \_ -> k
11:46:54 <olsner> @pl \m -> (m >>=) const
11:46:54 <lambdabot> (const =<<)
11:47:03 <olsner> @pl \m -> (m >>=) . const
11:47:04 <lambdabot> (. const) . (>>=)
11:58:36 <axm> damn. if that dell lappy would have arrived already i would not have an excuse not to go there besides lack of experience
11:58:46 <maitscha_> hehe ... this is what oo-programmers think about it: ((lambda (x) (+ x 1)) 6)
11:58:52 <mauke> ETOOMANYNEGATIONS
11:59:11 <maitscha_> perhaps http://www.ececs.uc.edu/~franco/C511/html/Scheme/ycomb.html is a good introduction to the Y combinator
11:59:13 <lambdabot> Title: Y Combinator
11:59:18 <mauke> maitscha_: huh? what does that have to do with OO?
11:59:53 <maitscha_> I don't know, but someone told me oo-programmers have to think a little different about functions
11:59:54 <dmwit> maitscha_: Parse error: I wasn't expecting a ')' here!
11:59:59 <dmwit> ;-)
12:00:16 <dmwit> Oh, wait, I miscounted, never mind.
12:00:25 <maitscha_> hehe
12:00:32 <mauke> sub { my $x = shift; $x + 1 }->(6)
12:00:42 <mauke> lambdabot needs an embedded perl interpreter
12:04:45 <hpaste>  sek pasted "Parsec buildExpressionParser problem" at http://hpaste.org/2983
12:06:07 <sek> ive written that expression parser for boolean expressions. But due to a stupidly defined data type, this is supposed to read ANY kind of expression, but if it is not boolean then it stores it as a CFreeForm String. I'm puzzled as to how to implement this
12:07:45 <greenrd> Is it possible to profile Template Haskell code running "inside" GHC?
12:08:17 <greenrd> My compile time for a few files suddenly jumped to about 2 minutes
12:08:39 <greenrd> and I suspect it's got something to do with my code that's running in a Template Haskell splice
12:09:08 <greenrd> (this is on a quad core AMD64 box, by the way, so it's not lack of hardware power)
12:10:32 <maitscha_> \x -> f x is a little bit strange. isn't it the same as \x -> f ?
12:10:57 <sek> why not just f
12:10:59 <jaredj> same as f
12:11:37 <dmwit> maitscha_: \x -> f (x x) is quite different, however.
12:11:37 <kpreid> @pl \x -> f
12:11:38 <lambdabot> const f
12:11:45 <kpreid> @pl \x -> f x
12:11:45 <lambdabot> f
12:11:47 <dmwit> (If you'r still looking at the Y combinator.)
12:12:29 <maitscha_> yes, the Y combinator :/
12:16:19 <maitscha_> it's really hard to understand
12:16:52 <maitscha_> I think all essential is that the lambda-calculus uses a duplicator ( \x -> x x ) and higher ordered functions.
12:16:55 <elliottt> maitscha_: have you read "The why of Y"?
12:17:13 <maitscha_> no, i read http://www.ececs.uc.edu/~franco/C511/html/Scheme/ycomb.html
12:17:13 <lambdabot> Title: Y Combinator
12:17:55 <elliottt> http://www.dreamsongs.com/Files/WhyOfY.pdf
12:18:08 <phobes> You don't need Y to do recursion
12:18:48 <Cale> I prefer the definition  y f = f (y f),  or  y f = let x = f x in x
12:18:58 <omniscientIdiot> not in haskell, since its function names scope of the function body
12:19:02 <Cale> Of course, you can't write those in the pure lambda calculus
12:19:23 <Saizan> maitscha_: i think you should read a more rigorous/formal definition of lambda calculus first, like the one on wikipedia
12:19:54 <maitscha_> hmm... ok.
12:20:37 <phobes> You can setup recursion without Y if you write in a style where functions take the recursive parameters they need
12:20:55 <omniscientIdiot> (let f x = body in expr) is like ((\x -> expr) body), with the exception that the f is in scope in the let's body, but not in the lambda's arg
12:21:42 <Cale> The typing rules are also different
12:21:50 <maitscha_> perhaps it's allready to late to understand anything .. I will try it tomorrow again. the pdf looks also very great... my reading material for this night.
12:21:54 <phobes> f = \f.  ... (f f) ... (f f) ...
12:21:56 <phobes> F = (f f)
12:23:27 <maitscha_> thx a lot for all your help
12:26:33 <hunzinozinkon> hello people
12:27:05 <hunzinozinkon> I don't understand this Just type. Where can I find an explanation of this?
12:27:15 <ari> @src Maybe
12:27:15 <lambdabot> data Maybe a = Nothing | Just a
12:27:24 <vvv_> kloeri> Hi, can you help me with a problem?..
12:28:03 <hunzinozinkon> ari: yeah, this is what I don't understand. What is the meaning/use of Maybe/Just?
12:28:16 <hpaste>  dolio pasted "y-combinator" at http://hpaste.org/2984
12:28:17 <vvv_> kloeri> /me looks at freenode.net FAQ, section "a recommended way of setting up IRC nickname"
12:28:26 <jaredj> hunzinozinkon: if you're not sure you'll have a value you use maybe
12:29:16 <pjd> hunzinozinkon: it represents a value that's optional, in some sense
12:29:43 <idnar> > elemIndex 5 [1..10]
12:29:44 <lambdabot>  Just 4
12:29:48 <idnar> > elemIndex 15 [1..10]
12:29:49 <lambdabot>  Nothing
12:30:03 <jaredj> e.g. myDiv x 0 = Nothing; myDiv x y = x `div` y
12:30:06 <jaredj> oops
12:30:10 <jaredj> e.g. myDiv x 0 = Nothing; myDiv x y = Just (x `div` y)
12:30:14 <omniscientIdiot> > elemIndex 20 [1..10]
12:30:15 <lambdabot>  Nothing
12:30:45 <omniscientIdiot> myDiv :: Num a => a -> a -> Maybe a
12:31:07 <omniscientIdiot> er, Integral a =>
12:31:43 <jaredj> this makes explicit the fact that myDiv may have nothing useful to return
12:31:52 <jaredj> (div makes an exception when you div by 0)
12:32:19 <omniscientIdiot> @let myDiv x 0 = Nothing; myDiv x y = Just (x `div` y)
12:32:23 <lambdabot> Defined.
12:32:27 <phobes> > 1 `div` 0
12:32:28 <lambdabot>  Exception: divide by zero
12:32:30 <omniscientIdiot> > myDiv 6 2
12:32:32 <lambdabot>  Just 3
12:32:37 <phobes> :type `div`
12:32:41 <omniscientIdiot> > myDiv 3 0
12:32:43 <lambdabot>  Nothing
12:32:46 <phobes> @type `div`
12:32:47 <jaredj> :t div
12:32:48 <lambdabot> parse error on input ``'
12:32:50 <lambdabot> forall a. (Integral a) => a -> a -> a
12:33:05 <hpaste>  dolio annotated "y-combinator" with "alternate" at http://hpaste.org/2984#a1
12:33:07 <vvv_> Is there any IRC staffer here?
12:33:36 <Cale> vvv_: why?
12:34:14 <vvv_> Cale: I just want a staffer to drop `vvv' nickname.
12:34:26 <Cale> vvv_: Can't you ghost it yourself?
12:34:44 <omniscientIdiot> he's not auth'd
12:34:51 <vvv_> Cale: How could I?
12:34:56 <Cale>  /msg nickserv help ghost
12:35:15 <vvv_> Cale: I'll try. Thanks.
12:35:27 <omniscientIdiot> if you've registered vvv with a password, you can /msg nickserv ghost <nick> <password>
12:35:33 <shachaf> Cale: "vvv...End of WHOWAS"
12:35:45 <omniscientIdiot> that'll kill <nick>
12:35:53 <oerjan> vvv is no longer on
12:36:46 <oerjan> vvv_: maybe you mean you want to register a nick that someone else owns but which hasn't been used for 60 days?
12:37:00 <vvv_> oerjan: That's right!
12:37:03 * oerjan got his nick in that way.
12:37:50 <shachaf> vvv_: Maybe try #freenode?
12:37:51 <oerjan> but i don't remember how i found the name of a staffer...
12:37:56 * shachaf isn't sure that's the right channel.
12:38:28 <shachaf> Oh.
12:38:33 <oscz> hi! im trying to learn haskell but have trouble adapting the new approach... do you have any tips or like for a beginner coming from imperative background ? :)
12:38:49 <vvv_> oerjan: According to http://freenode.net/faq.shtml#nicksetup , the staffer is `kloeri'..
12:38:50 <lambdabot> Title: freenode: frequently-asked questions
12:38:55 <omniscientIdiot> @go haskell for c programmers
12:38:56 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
12:38:56 <lambdabot> Title: Haskell for C Programmers
12:39:09 <vvv_> oerjan: ..but he seems to be away right now.
12:39:13 <shachaf> vvv_: Try /who freenode/staff/*, maybe.
12:39:42 <oscz> thanks, looking good!
12:39:45 <Cale>  /stats p  doesn't turn up any right now
12:39:50 <omniscientIdiot> oscz: which tuts have you read?
12:40:25 <shachaf> Cale: But the /who command seems to work (if you're in #freenode, they say).
12:40:25 <oscz> omniscientIdiot: ive been reading "Yet another haskell tutorial "
12:40:27 <oerjan> kloeri is in this channel?  is that a strange coincidence?
12:41:06 <Cale> oscz: Figure out the list functions really well, since they're responsible for replacing most of your looping constructs.
12:41:24 <omniscientIdiot> oscz: ask questions here when you don't understand something
12:41:24 <Cale> oscz: Also, understanding the type system makes things go a lot faster.
12:41:33 <Cale> and yeah, ask lots of questions :)
12:41:44 <vvv_> kloeri: Hello, are you here?
12:41:53 * dolio pouts.
12:41:58 <omniscientIdiot> @seen kloeri
12:41:58 <dolio> No Y without unsafeCoerce, I guess.
12:41:58 <lambdabot> kloeri is in #haskell. I don't know when kloeri last spoke.
12:42:04 <oscz> i guess i kind of get how statements are evaluated at some superficial level
12:42:31 <Cale> oscz: They're evaluated outermost first
12:42:37 <hunzinozinkon> ok, Nothing makes explicit the fact that this function may return Nothing, but what use is Just? isn't 3 = Just 3. In other words, if I ommit the Just type from the declaration it wouldn't change anything.. would it?
12:42:56 <oscz> but when i'd have to really write something in haskell when trying to solve some problem
12:43:02 <jaredj> hunzinozinkon: the type has to have constructors
12:43:04 <oscz> thats where i have trouble
12:43:05 <shachaf> vvv_: Maybe you didn't /j #freenode before /who-ing?
12:43:07 <sorear> dolio: you can't write Y in haskell without data types or explicit recursion
12:43:10 <omniscientIdiot> hunzinozinkon: Just 3 :: Maybe Int, 3 :: Int, they're incompatible
12:43:10 <phobes> dolio:  Isn't that known to be true from CH?
12:43:14 <shachaf> vvv_: So you didn't get the full list.
12:43:17 <Cale> But expressions which came from having duplicate occurrences of a function parameter in the body of the function are shared, which means that when one copy is computed, they're all updated to share the result.
12:43:18 <jaredj> hunzinozinkon: if you wrote 3, there's no way to know it's a Maybe Int.
12:43:26 <jaredj> which everyone just said at once i bet. *reads*
12:43:27 <dolio> sorear: http://hpaste.org/2984
12:43:38 <vvv_> shachaf: I did joined #freenode. :)
12:43:59 <shachaf> vvv_: Oh. So why kloeri specifically?
12:44:06 <Cale> oscz: If you want, I can give my usual demo of various evaluation mechanisms :)
12:44:06 <sorear> dolio: getting rid of the coercion is *impossible*
12:44:10 <omniscientIdiot> hunzinozinkon: you use pattern matching to deconstruct a (Maybe a) value, and choose what to do if it's Nothing, or Just something
12:44:18 <phobes> sorear:  that follows from CH, right?
12:44:19 <sorear> dolio: at least if you continue to avoid data
12:44:29 <jaredj> oscz: there's a grep at http://dingoskidneys.com/~jaredj/grep2.lhs.txt
12:44:33 <dolio> No ammount of higher-ranked typing?
12:44:34 <sorear> phobes: No, that follows from the strong normalization theorem
12:44:40 <vvv_> shachaf: You mean _any_ staffer can drop an inactive nick?
12:44:48 <Heffalump> if you can make a type of rank infinity, you can do it
12:44:51 <oscz> mapping some problem at hand to a single function using recursion seems a bit tricky to me :(
12:45:01 <phobes> sorear: oh, right, haskell lets you construct "false" types all over the place
12:45:10 <oscz> Cale: sure please
12:45:13 <Cale> phobes: hehe, whenever I hear "CH", I always think "Continuum Hypothesis", and not "Curry-Howard" as is probably more suitable here :)
12:45:13 <sorear> dolio: higher ranked types won't cut it, because GHC uses a variant of Girard's F, which shares the SN property
12:45:16 <Cale> oscz: okay
12:45:24 <dolio> Ah, okay.
12:45:27 <Cale> oscz: So we'll look at the program  double x = x + x
12:45:42 <Cale> And evaluate the expression  double (double 5)
12:45:44 <phobes> Cale:  hehe, I should probably spell it out :)
12:46:02 <Cale> Under strict evaluation, which is most likely what you're used to:
12:46:06 <Cale> double (double 5)
12:46:09 <omniscientIdiot> oscz: it's a good exercize to write many of the recursive patterns yourself when starting out, but eventually you'll find that just about all of the useful patterns are already implemented in the libs
12:46:10 <Cale> = double (5 + 5)
12:46:14 <Cale> = double 10
12:46:17 <Cale> = 10 + 10
12:46:19 <Cale> = 20
12:46:41 <Cale> That's innermost (leftmost) evaluation.
12:46:54 <sorear> aka "applicative order"
12:46:55 <Cale> Under outermost first evaluation:
12:46:55 <phobes> You should add @Cale <tutorial search string> to lambdabot
12:47:00 <hunzinozinkon> omniscientIdiot: so Just and Nothing are constructors of the type Maybe?
12:47:02 <Cale> double (double 5)
12:47:08 <shachaf> vvv_: How did you decide on kloeri?
12:47:11 <Cale> = double 5 + double 5
12:47:16 <Cale> = (5 + 5) + double 5
12:47:17 <omniscientIdiot> hunzinozinkon: yep.
12:47:20 <Cale> = 10 + double 5
12:47:24 <phobes> when Cale finishes a lecture on here, someone can instruct lambdabot to remember it
12:47:25 <Cale> = 10 + (5 + 5)
12:47:30 <Cale> = 10 + 10
12:47:32 <Cale> = 20
12:47:34 <omniscientIdiot> hunzinozinkon: more precisely, the type (Maybe a), for some type 'a'
12:47:52 <Cale> Note that we wasted some work there: we computed double 5 twice.
12:47:57 <kloeri> vvv_: hiya
12:48:02 <hunzinozinkon> omniscientIdiot: Thanks :)
12:48:10 <Cale> So lazy evaluation modifies this approach
12:48:14 <vvv_> shachaf: <pre>/join #freenode; /who freenode/staff/* | grep #haskell</pre>
12:48:18 <kloeri> shachaf: I look suspicious I guess :)
12:48:42 <vvv_> kloeri: You did, shady person! :)
12:48:43 <Cale> Whenever you have a parameter to a function which is duplicated in the body -- like in double x = x + x, where the x occurs twice in the body of the function
12:48:56 <Cale> It will share the results of computing x between the two copies
12:49:04 <shachaf> vvv_: Why grep #haskell (I guess it doesn't matter now)?
12:49:08 <Cale> (or all the copies in general)
12:49:14 <kloeri> vvv_: I swear I'm a good guy :)
12:49:15 <Cale> So under lazy evaluation, we have:
12:49:19 <Cale> double (double 5)
12:49:28 <Cale> = let x = double 5 in x + x
12:49:36 <Cale> = let x = 5 + 5 in x + x
12:49:39 <Cale> = let x = 10 in x + x
12:49:42 <Cale> = 20
12:49:57 <Cale> and we're back down to the same number of steps as the strict evaluation took
12:49:58 <vvv_> kloeri: So, you aren't a Staffer, are you? (Could you just drop that damned `vvv' nick away))
12:50:02 <omniscientIdiot> (you left out (let x = 10 in x + x) = (10 + 10))
12:50:39 <Cale> omniscientIdiot: yeah, but 10 doesn't need any further evaluation, so showing that it's shared doesn't really help much :)
12:50:58 <Cale> omniscientIdiot: er
12:51:02 <kloeri> vvv_: I happen to be a staffer, yes
12:51:08 <Cale> omniscientIdiot: you mean doing the substitution from the let?
12:51:23 <Cale> omniscientIdiot: I left that out because it's not really a step
12:51:29 <omniscientIdiot> yeah
12:51:34 <kloeri> vvv_: change nick to vvv if you want me to drop it
12:51:54 <Cale> The 'let' here is just a representation of multiple pointers pointing to the same thing
12:51:56 <vvv_> kloeri: it's password-protected
12:52:07 <sorear> vvv_: you can still do it
12:52:07 <oscz> Cale: let me chew that a bit
12:52:11 <omniscientIdiot> okay
12:52:20 <vvv> see?
12:52:31 <axm> imposter
12:52:32 <oscz> Cale: impressing stuff .. thanks for taking the time to explain this
12:52:51 <vvv> the real vvv could issue a command to boot me off the net now
12:52:52 <vvv__> three can play that
12:53:04 <vvv_> vvv: :)
12:53:10 <Cale> oscz: By evaluating programs using that method, you can understand how lazy evaluation works -- that's really all there is to it. You evaluate the outermost thing which you can on each step, and share results which come from duplicated function parameters.
12:53:11 <vvv> but until he shows up, or a staffer gets a whim, NOTHING will happen
12:53:19 <vvv___> hay guise
12:53:27 <vvv____> yo, what up?
12:53:30 <jaredj> oh noes
12:53:31 <vvv_> Stop vvvlooding this chat, girls!
12:53:32 <vvv> there's an autokill feature, but it's not enabled in freenode
12:53:45 <vvv___> you started it, jared!
12:54:09 <_vvv> vvv___: No, sorear started it.
12:54:13 <oscz> Cale: can you give some concrete and as simple as possible example what you mean by this "sharing"?
12:54:14 <Cale> oscz: No problem by the way -- let me know if you have any questions.
12:54:14 <vvv_> sorear: And now the moment of truth -- how did you do that?
12:54:18 <jaredj> whew dodged that bullet
12:54:23 <sorear> vvv_: /nick vvv
12:54:26 <Cale> oscz: well, I thought that I just did :)
12:54:50 <Cale> oscz: Remember in the plain outermost first evaluation example how double 5 got computed twice?
12:54:52 <oscz> i didnt absorb all that yet.. you explain faster than learn hehe :P
12:54:57 <gh_> hi, how can i compile a program for Hat , using GHC ? is there a GHC flag that directly does this ?
12:55:04 <kloeri> vvv: you can register it now
12:55:04 <vvv> "Damn, I'm good." (c) Duke Nukem
12:55:12 <Cale> This is because it was a parameter to double
12:55:16 <Cale> and double x = x + x
12:55:38 <astrolabe> gh: There used to be instructions on the hat website
12:55:45 <Cale> So when double is applied to some expression expr, it results in the expression  expr + expr
12:55:52 <omniscientIdiot> oscz: instead of computing (5 + 5) twice, each occurance of (5 + 5) is replaced with a pointer to the code that evaluates it.  When the code is run, it replaces itself with code that just returns 10.  AFAIU
12:56:02 <gh_> astrolabe, they give instructions for hmake only
12:56:07 <Cale> which means that under plain outermost-first evaluation, it will be computed twice then
12:56:34 <sek> i have a (Parser [[A]]) value and want to call concat on [[A]]. Is there a concatM or something equivalent?
12:56:40 <Cale> So rather than doing that, we remember that the two copies of the expression came from duplicating the same variable -- and so they must have the same value
12:56:48 <shachaf> fmap?
12:56:53 <axm> gh_, http://www.haskell.org/hat/tutorial1.html would be a start
12:56:54 <lambdabot> Title:
12:56:55 <omniscientIdiot> sek: fmap concat
12:57:08 <axm> ok, you found that, sry
12:57:12 <omniscientIdiot> sek: of liftM if it's not a Functor instance
12:57:15 <astrolabe> gh_:Ah.  I did get it to work somewhat, but I had to change so much in my code that it wasn't helpful to me.  Have you considered the ghci debugger?
12:57:16 <sek> ah thank you
12:57:21 <omniscientIdiot> or*
12:57:23 <shachaf> > let x = Just [[1,2],[3,4]] in concat <$> x
12:57:28 <lambdabot>  Just [1,2,3,4]
12:57:29 <vvv> kloeri: And a chosen password will be for any channel on chat.freenode.org, am I right?
12:57:37 <shachaf> (concat <$>) may look nicer.
12:57:38 <oscz> double 5 (double 5) become double 5 + double 5 i dont understand...
12:57:48 <sek> yikes, what is <$> ?
12:57:51 <xerox> fmap
12:57:51 <Cale> double (double 5) --> double 5 + double 5
12:57:54 <shachaf> sek: fmap
12:57:57 <sek> ok:)
12:57:58 <shachaf> @src <$>
12:57:58 <lambdabot> f <$> a = fmap f a
12:58:07 <Cale> We're evaluating the *outermost* thing first
12:58:08 <omniscientIdiot> sek: you could also write liftM yourself: do { x <- (yourParser :: Parser [[A]]) ; return (concat x) }
12:58:24 <sek> omniscientIdiot, you like the hard way eh?:p
12:58:24 <kloeri> vvv: the password applies to the nick registration and doesn't have anything to do with channels
12:58:30 <oscz> yeah made a mistake
12:58:35 <shachaf> oscz: You have an extra 5 there.
12:58:35 <xerox> > (:) <$> Just 'h' <*> Just "ello"
12:58:37 <lambdabot>  Just "hello"
12:58:40 <omniscientIdiot> @src liftM
12:58:40 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:58:43 <Cale> We have double (double 5), and that matches double x = x + x, with x = double 5
12:58:46 <gh_> astrolabe, no, i've never used it, but if it's a convenient solution, i'll give a try
12:58:54 <sorear> vvv: nicks and channels are unrelated on IRC
12:59:02 <Cale> So we produce double 5 + double 5
12:59:08 <Cale> Does that make sense?
12:59:12 <sorear> sorry, couldn't resist :)
12:59:15 <astrolabe> gh_: I can't attest the the ghci debugger, but I found hat to be a pain in the arse.
12:59:20 <oscz> Cale: but to evaluate the outermost double i have to evaluate the expression inside parentheses fight ?
12:59:25 <oscz> first ^^
12:59:26 <Cale> oscz: no
12:59:35 <astrolabe> gh: which is a real shame.
12:59:39 <sorear> astrolabe: you should read ndm's comments on it...
12:59:39 <vvv`> sorear: &^%#&$!
12:59:41 <Cale> oscz: That's what's different from strict evaluation
12:59:55 <Cale> oscz: In strict evaluation, you always evaluate the *innermost* first thing
12:59:59 <gh_> astrolabe, too bad there isn't a trace option directly in ghc
13:00:02 <oscz> Cale: ohh!! i see.. i think
13:00:07 <gh_> like the profiling option , which is very cool
13:00:22 <Cale> oscz: You just stick the expression that it's applied to into the body of the function wherever the parameter occurs
13:00:29 <omniscientIdiot> > "dmwit" >>= replicate 3
13:00:30 <lambdabot>  "dddmmmwwwiiittt"
13:00:36 <dddmmmwwwiiittt> he
13:00:37 <dddmmmwwwiiittt> hehe
13:00:40 <oscz> Cale: so body of the function is like a template ?
13:00:45 <Cale> oscz: yeah
13:01:19 <omniscientIdiot> oscz: it's kinda mathy, you substitute definitions
13:01:29 <Cale> Right, it's just like in mathematics
13:01:52 <shachaf> > ap (>>=) (replicate . length) "shachaf
13:01:52 <lambdabot>  Improperly terminated string
13:01:55 <shachaf> > ap (>>=) (replicate . length) "shachaf"
13:01:56 <lambdabot>  "ssssssshhhhhhhaaaaaaaccccccchhhhhhhaaaaaaafffffff"
13:02:00 <pstickne__> do all function calls have a higher precedence than operators?
13:02:09 <Heffalump> yes
13:02:31 <Cale> If I know that f(x) = x^2, and I have the expression f(5+7), I can either decide to evaluate 5+7 to get f(12) first, and then plug in the definition of f to get 12^2, or I can plug in f first, and get (5+7)^2
13:02:35 <Heffalump> where "function call" is where you apply a function by juxtaposition
13:02:52 <omniscientIdiot> pstickne__: but be careful not to confuse precedence (grouping) with evaluation order
13:02:57 <oscz> Cale: i dont have strong mathematical background so that might cause trouble too :(
13:02:59 <dmwit> shachaf: Very nice.
13:03:05 <pstickne__> omniscientIdiot, err... :-/
13:03:08 <Cale> oscz: Don't worry too much about that.
13:03:42 <dmwit> pstickne__: Function application has precedence over every operator, but not over parens.
13:03:43 <omniscientIdiot> pstickne__: precedence just shows where to put the parens.  The actual order that functions are called doesn't matter.
13:03:43 <Cale> oscz: It can help to have a mathematical background, but only in a pretty abstract way -- Haskell "feels like" mathematics, but you don't really need all that mathematics to use it.
13:03:54 <Cale> all that much*
13:04:17 <dmwit> pstickne__: So, f a b . g = (f a b) . g
13:04:35 <pstickne__> The best thing to learn haskell is likely the un-knowledge of other programming languages...
13:04:44 <Cale> oscz: So, getting back to this lazy evaluation stuff, under lazy evaluation, you don't quite naively substitute the expression into the body
13:04:51 <oscz> so maybe if i grasp haskell i find it easy to learn mathematics? :P
13:04:57 <oscz> easier
13:04:59 <Cale> oscz: yeah, possibly
13:05:15 <astrolabe> sorear: I think I have, he helped me get as far as I did.
13:05:16 * omniscientIdiot has noticed something to that effect ;)
13:05:21 <pstickne__> dmwit, okay, that makes sense
13:05:31 <astrolabe> gh: I agree about the profiler.
13:06:07 <pstickne__> how can I use function composition with multiple function parameters? say I start with length (filter Char.isUpper "Hello World")
13:06:22 <Cale> oscz: So whenever that would end up copying the expression to multiple places, what you do instead is to make all the duplicates really be pointers to the same thing, so that if one copy gets evaluated, they're all evaluated.
13:06:25 <pstickne__> and I'd like to get length . filter or such (I think)
13:06:39 <dmwit> pstickne__: (length .) . filter
13:06:48 <Cale> oscz: does that make some sense? :)
13:06:48 <dmwit> pstickne__: But prefer to actually write what you want, instead.
13:07:01 <shachaf> > ((length .) . filter) isUpper "Hello World"
13:07:03 <lambdabot>  2
13:07:12 <shachaf> > (length . filter isUpper) "Hello World"
13:07:14 <lambdabot>  2
13:07:23 <dmwit> pstickne__: length (filter f x) is better.
13:07:39 <omniscientIdiot> oscz, Cale: I almost never consciously think about what order expressions are evaluated in.  It was tremendously disorienting at first, but now I think "why should I have to worry about such a trivial thing?"
13:07:49 <pstickne__> How oes the ((f .) . g) bit work?
13:07:49 <shachaf> dmwit: What's wrong with (length . filter f), when you know the function in advance?
13:07:51 <pstickne__> *does
13:08:05 <dmwit> shachaf: I have no problem with that, I find that plenty readable.
13:08:32 <omniscientIdiot> pstickne__: ((f .) . g) x y = (f .) (g x) y = (f . g x) = f (g x y)
13:08:33 <dmwit> pstickne__: It's an exercise for the reader. ;-)
13:08:42 <Cale> omniscientIdiot: of course, you're justified in doing so, because lazy/outermost-first evaluation has the property that if any order of evaluation terminates to produce a result, then they will, and will produce the same result.
13:09:18 <Cale> The only time it *really* matters what order things are being evaluated in is when you're trying to understand how efficient a program is.
13:09:19 <omniscientIdiot> Cale: in the absense of side-effects, of course ;)
13:09:27 <nomeata> What datatype or library can most likely model relational data. In my case, I have basic types (Assignments, Students) and I want to store data for each Assignment, for each Student, and for each pair.
13:09:28 <Cale> omniscientIdiot: What side effects? ;)
13:09:50 <omniscientIdiot> pstickne__: did you understand that?
13:09:52 <pstickne__> Composed of always only works with one argument (?) at a time then?
13:10:04 <oscz> Cale: im thinking about the function definition:  when we have double x = x+x, this actually defines a "symbolic transformation" x -> x+x AND the actual meaning of the body x+x: adding something to itself
13:10:08 <pstickne__> omniscientIdiot, kinda. I can use it get somewhere at least ^^
13:10:18 <shachaf> @src (.)
13:10:18 <lambdabot> (.) f g x = f (g x)
13:10:21 <dmwit> pstickne__: Composition is just a function, not syntax.
13:10:25 <shachaf> pstickne__: If that helps.
13:10:26 <Cale> oscz: yeah
13:10:34 <dmwit> pstickne__: So you can do partial application, just like (+ 1) or so.
13:10:43 <shachaf> dmwit: It couldn't really do any better if it was syntax.
13:10:51 <oscz> oscz: what are these parts called ?
13:10:59 <dmwit> shachaf: I definitely agree!
13:11:00 <omniscientIdiot> oscz: that's how most people reason through it.  The implementation details are probably more complex, but that is a perfectly acceptable view.
13:11:08 <oscz> oscz: dont ask me
13:11:22 <pstickne__> shachaf, that does, thanks.
13:11:23 <oscz> StackOverflow!!
13:11:24 <Cale> oscz: Well, the meaning of x+x is the definition of the function (+)
13:11:37 <Cale> and the meaning of double is its definition, I suppose
13:12:10 <omniscientIdiot> It's functions all the way down!
13:12:41 <omniscientIdiot> (well, with pattern-matching on data at the bottom) :)
13:12:45 <augustss> omniscientIdiot: it sure is in lambda calculus!
13:13:12 <Cale> Yeah, the definition of (+) will pattern match on its two parameters and return a result based on that.
13:13:21 <augustss> omniscientIdiot: you can translate data type and pattern matching to functions too
13:13:43 <Cale> (well, not really with the Integer type, since that's built in and does something more low-level, but that's just an implementation detail)
13:13:46 <omniscientIdiot> augustss: I'm aware, but not of the details
13:14:36 <augustss> omniscientIdiot: the details are pretty easy.  but you can find them when you need them
13:14:40 <oscz> huh.. if a bowl of spaghetti had consciousness i'd know how it would feel :( i've had some wine too, i guess it doesn't help here ;)
13:14:46 <shachaf> Cale: You mean (+) isn't defined: 0 + 0 = 0; 0 + 1 = 1; 0 + 2 = 2; ...?
13:14:53 <Cale> shachaf: hehe :)
13:15:16 <Cale> oscz: :)
13:15:20 <shachaf> I guess it would have to be 0 + 0 = 0; 0 + 1 = 1; 0 + (-1) = -1; (-1) + 0 = 0; ...
13:15:55 * omniscientIdiot mumbles something about peano numbers
13:16:18 <ddarius> Why do people always drink before asking for explanation from Cale?
13:16:21 <Cale> Yeah, you could use something like a pair of Peano naturals to represent an Integer
13:16:28 <Cale> ddarius: hahaha
13:16:50 <augustss> Cale: or a Bool and a Nat
13:16:55 <oerjan> ddarius: to build courage, perhaps?
13:17:06 <oscz> ddarius: hehe i didnt expect to get information this good :P
13:17:06 <dmwit> potvaliance
13:17:16 <astrolabe> A sober mind would be driven insane.
13:17:29 <augustss> we're all insane here anyway
13:17:32 <dmwit> oscz: Good information is always a danger here. =)
13:18:01 <shachaf> Of course, (-1) + 0 shouldn't be = 0...
13:18:08 <vvv> Does anyone connect to IRC through jabber?
13:18:10 <vvv> Could you tell me a jabber server name? (I have only 80 and 443 ports open in the office's firewall.)
13:18:50 <oscz> Cale, omniscientIdiot : thanks for the help.. really appreciated.. i'll try to think about it for some time (maybe not tonite ;-) and i'll return later on with more questions ;)
13:18:59 <Cale> oscz: great :)
13:19:22 <Cale> oscz: You're quite welcome
13:20:10 <vvv> oscz: And thank you (for being me). ;)
13:20:32 <jmob> vvv: set up an SSH server on port 80 and do a dynamic proxy through it
13:21:38 <nominolo> @src (->) (>>=)
13:21:38 <lambdabot> f >>= k = \ r -> k (f r) r
13:22:03 <nominolo> @src (->) return
13:22:03 <lambdabot> return = const
13:22:27 <jmob> @pl join s tok = foldr (++) [] $ intersperse tok s
13:22:28 <lambdabot> join = (foldr (++) [] .) . flip intersperse
13:22:56 <shachaf> > return <*> undefined $ 5
13:22:57 <lambdabot>  5
13:23:57 <augustss> jmob: do you realize that 'foldr (++) []' already has the name join? :)
13:24:05 <nominolo> > ((+1) >>= (*2) ) 42
13:24:06 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
13:24:06 <lambdabot>     Probabl...
13:24:09 <augustss> > join [[1],[2,3]]
13:24:09 <EvilTerran> concat?
13:24:10 <lambdabot>  [1,2,3]
13:24:20 <augustss> And concat
13:24:36 <jmob> augustss: ORLY, cool
13:24:46 <augustss> :t join
13:24:48 <omniscientIdiot> > join (Just (Just 5)) -- join is more general, tho
13:24:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:24:49 <lambdabot>  Just 5
13:24:58 <EvilTerran> ?t concat
13:24:59 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
13:25:02 <EvilTerran> :t concat
13:25:04 <lambdabot> forall a. [[a]] -> [a]
13:25:25 <augustss> :t intercalate
13:25:27 <lambdabot> Not in scope: `intercalate'
13:25:34 <EvilTerran> intersperse?
13:25:56 <dmwit> :t translateToIntercal -- EvilTerran, no, this ;-)
13:25:58 <lambdabot> Not in scope: `translateToIntercal'
13:26:10 <EvilTerran> O.o
13:26:11 <omniscientIdiot> EvilTerran: intercalate = (concat .) . intersperse
13:26:29 <nominolo> > ((+3) >>> (*3)) 42
13:26:31 <lambdabot>  135
13:26:41 <vvv> jmob: Look. Here am <I:80,443>. There is a huge <Web> between me and <6667:IRC>..
13:26:50 <vvv> jmob: ..You want me to find a <80:Host> somewhere in the Web to run ssh tunneling through, am I right?
13:27:14 <augustss> omniscientIdiot: you're back to your long name
13:27:21 <jayimbo> could someone please point me to a documentation of the @ operator?
13:27:24 <omniscientIdiot> yeah :)
13:27:38 <omniscientIdiot> @where report
13:27:38 <lambdabot> http://www.haskell.org/onlinereport/
13:27:46 <dibblego> jayimbo, look up as-patterns
13:28:01 <augustss> jayimbo: @ is not an operator
13:28:23 <oerjan> > let x@(y:z) = "hello" in (x,y,z)
13:28:24 <lambdabot>  ("hello",'h',"ello")
13:28:25 <omniscientIdiot> should be here somewhere: http://www.haskell.org/onlinereport/exps.html#sect3.17
13:28:25 <lambdabot> Title: The Haskell 98 Report: Expressions
13:28:55 <augustss> Or even more likely in the pattern section
13:29:09 <jayimbo> thank you
13:29:25 <jayimbo> it's just a little hard to google for @
13:29:34 <jayimbo> or search the wiki
13:29:42 <omniscientIdiot> augustss: that is the patterns section :P
13:30:12 <augustss> omniscientIdiot: so it is!
13:30:44 <omniscientIdiot> "case e of { xs@(x:rest) -> if x==0 then rest else xs }   is equivalent to:   let { xs = e } in case xs of { (x:rest) -> if x==0 then rest else xs }"
13:30:56 <jmob> vvv: why not your home machine?
13:31:07 <jayimbo> lambdabot: you're right, it's in the Expressions
13:31:23 <dibblego> jayimbo, lambdabot is always right
13:31:38 <augustss> @botsnack
13:31:38 <lambdabot> :)
13:31:41 <omniscientIdiot> @vixen Are you always right?
13:31:41 <jmob> augustss: I thought concat was the same thing cat (++) apparently I was mistaken
13:31:41 <lambdabot> correct
13:32:25 <augustss> @vixen hello, sexy
13:32:25 <lambdabot> sexy is such an over used word. be more descriptive
13:32:48 <omniscientIdiot> lol
13:33:02 <jmob> @vixen hello, scrumptious
13:33:03 <lambdabot> hello there
13:33:04 <omniscientIdiot> @vixen hello, extemely sexy
13:33:04 <lambdabot> sexy or sexy bitch?
13:34:05 <augustss> @vixen hello bitch
13:34:06 <lambdabot> Calm down there and take it easy!
13:34:15 <vvv> jmob: I'm a poor guy, living in forest and eating bugs... Well, the only machine I have is a laptop. It's with me at home (now) and in the office (where only 2 ports are open outside)...
13:34:36 <augustss> @quote
13:34:36 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
13:34:59 <jaredj> buh?
13:36:03 <jmob> vvv: sucks
13:37:24 <augustss> hmmm, I wonder who came up with the "tying the knot"?
13:37:56 <ddarius> It's not an unreasonable name.
13:37:57 <sorear> probaly wadler
13:38:08 <augustss> not the name, the trick itself
13:39:03 <oerjan> could be older than haskell...
13:39:14 <augustss> oh, it's older
13:39:30 <jaredj> wait, what?
13:39:35 <jaredj> what's "tying the knot"?
13:39:44 <jaredj> most people manage to get married without goat blood...
13:39:54 <augustss> different knot
13:40:28 <augustss> > let fibs = 1:1:zipWith(+) fibs (tail fibs) in take 10 fibs
13:40:33 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
13:40:36 <augustss> that kind
13:40:52 <omniscientIdiot> putting a loop in the call graph, i.e. recursion.
13:40:53 <augustss> a recursive (non-function) value defined in terms of itself
13:40:59 * JohnnyL barks tail is not magical!
13:41:40 <omniscientIdiot> Though I think that comment might have to do with the 'loeb' function that (I think) ndm used.  It's an unusual kind of recursion.
13:41:58 <omniscientIdiot> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
13:42:00 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
13:42:13 <jMCg> omniscientIdiot: loeb - as in Andrew Loeb?
13:42:23 * omniscientIdiot doesn't know
13:42:44 * jMCg bee reading the Cryptonomicon
13:43:36 <sorear> jMCg: as in some Löb guy important in modal logic
13:45:07 <ddarius> sigfpe/dpiponi
13:45:41 <omniscientIdiot> right, Dan.  Not Neil.  Silly me.
13:50:31 <dmwit> jMCg: I just read that book myself; pretty fun!
13:50:58 <jMCg> dmwit: /me's still reading it
14:11:45 <sjanssen> is the error printing format that GHC uses available as a library?
14:13:48 <pejo> sjanssen, you mean the stuff for "The impossible happened"?
14:14:17 <Qerub> Can I rewrite f x y = foo $ bar baz x y to pointfree form somehow?
14:14:29 <mauke> @pl f x y = foo $ bar baz x y
14:14:29 <lambdabot> f = (foo .) . bar baz
14:14:34 <sjanssen> pejo: I was actually talking about the convention that GHC compiled programs use
14:14:56 <dino-> mauke: Aw, I was trying to reason it out myself. :(
14:15:03 <Qerub> mauke, lambdabot: Thanks.
14:15:36 <dino-> You.. you gave my job to lambdabot?
14:16:16 <omniscientIdiot> ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
14:16:44 <shachaf> omniscientIdiot: Is that just from your history? :-)
14:17:06 <omniscientIdiot> shachaf: nah, I had an error in it last time :P
14:17:13 <omniscientIdiot> forgot the 'y' once
14:18:03 <shachaf> Hmm, that's true.
14:21:57 <dino-> in that original function, does baz :: a -> b -> c  i.e. two arguments, it's consuming both x and y ?
14:22:32 <omniscientIdiot> bar baz :: a -> b -> c
14:22:41 <Saizan> in the original function bar takes baz x and y as arguments
14:22:44 <omniscientIdiot> bar baz x y :: c
14:23:00 <dino-> Ok, application binding tightly, bar takes everything to the right of it.
14:23:12 <Saizan> err, baz, x and y
14:23:21 <omniscientIdiot> so 'bar baz' would take the place of 'g' in the above rewrite
14:23:22 <Saizan> exactly
14:25:25 <Qerub> @pl f x y = foo bar (baz x y)
14:25:25 <lambdabot> f = (foo bar .) . baz
14:26:55 <omniscientIdiot> in ((f.).g), you can think of it like, g takes a param and results in a *function*, that function is passed to (f.), which tacks 'f' onto it.
14:32:27 <CoScO> hi i looking for Pretorians invite pls can someone help me i have good offer
14:49:20 <omniscientIdiot> @yow!
14:49:20 <lambdabot> Did you move a lot of KOREAN STEAK KNIVES this trip, Dingy?
14:50:26 <geocalc> @wow!
14:50:26 <lambdabot> I feel like a wet parking meter on Darvon!
14:51:08 <geocalc> @lol!
14:51:08 <lambdabot> Unknown command, try @list
14:51:29 <omniscientIdiot> @yarr
14:51:29 <lambdabot> Aye
14:56:16 <oerjan> @instances-importing Text.Printf PrintfType
14:56:17 <lambdabot> (a -> r), IO a, [c]
14:56:48 <oerjan> i just had a realization: there should be a Maybe [c] in there
14:57:21 <omniscientIdiot> what sort of printf "..." ... call would result in Nothing?
14:57:47 <oerjan> anything that would give an error in the other cases
14:58:08 <omniscientIdiot> printf "%d" "notaninteger"?
14:58:09 <sorear> omniscientIdiot: none, Maybe isn't in the type
14:58:27 <oerjan> yeah
14:58:28 <omniscientIdiot> sorear: re: oerjan's comment
14:58:28 <dmwit> > printf "%d" "notaninteger"
14:58:29 <lambdabot>  Add a type signature
14:58:50 <omniscientIdiot> > printf "%d" "notaninteger" :: String
14:58:52 <lambdabot>  Exception: Printf.printf: bad argument
14:59:04 <omniscientIdiot> makes sense
14:59:19 <omniscientIdiot> I don't know if it's terribly useful
14:59:34 <oerjan> well, you could use catch, but only from IO
14:59:47 <mauke> you're not supposed to catch those errors
14:59:52 <dmwit> > printf "%d" "not" :: [String]
14:59:53 <lambdabot>   add an instance declaration for (IsChar [Char])
14:59:53 <lambdabot>     In the expression: prin...
15:00:38 <oerjan> @instances-importing Text.Printf IsChar
15:00:39 <lambdabot> Char
15:00:50 <xerox> > printf "%s" "not" :: String -- maybe?
15:00:51 <lambdabot>  "not"
15:01:21 <omniscientIdiot> > printf "%s" 12 :: String -- does it automatically show?
15:01:23 <lambdabot>  Exception: Printf.printf: bad argument
15:02:11 <dmwit> :t printf
15:02:13 <lambdabot> forall r. (PrintfType r) => String -> r
15:02:20 <dmwit> hmph
15:02:26 <oerjan> omniscientIdiot: cannot mix Show instances with printf's type hackery
15:02:27 <augustss> :)
15:03:11 <augustss> there could have been an automagic show, but i decided not to
15:03:42 <dmwit> I like it better without automatic show.
15:03:47 <oerjan> augustss: overlapping instance?
15:03:49 <omniscientIdiot> is instance PrintfType [c] restricted by IsChar c?
15:04:28 <omniscientIdiot> augustss: it's magic enough for my needs, no worries :)
15:04:30 <augustss> oerjan: no, just an extra conversion when the formatting char is 's' and the argument is an integer
15:04:49 <augustss> omniscientIdiot: yes
15:05:02 <augustss> printf is totally H98
15:05:07 <omniscientIdiot> augustss: re: IsChar?
15:05:25 <augustss> IsChar only has one instance, for Char
15:05:41 <omniscientIdiot> @src IsChar
15:05:41 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:05:44 <olsner> @type printf "%d" 12
15:05:47 <lambdabot> forall t t1. (Num t, PrintfType (t -> t1)) => t1
15:05:49 * omniscientIdiot looks in the docs
15:05:56 <augustss> It's because you can't do 'instance PrintfType [Char]'
15:06:15 <augustss> with H98
15:06:24 <omniscientIdiot> oh, right, because of the T a b c thing
15:06:29 <augustss> yes
15:07:38 <omniscientIdiot> @source Text.Printf
15:07:38 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
15:08:25 <augustss> Hmmm, I have a bunch of bug fixes and improvements of printf.  I should send them to someone
15:09:54 <geocalc> augustss-> join #ghc
15:10:14 <mauke> augustss: http://hackage.haskell.org/trac/ghc/ticket/1548
15:10:17 <lambdabot> Title: #1548 (printf bugs) - GHC - Trac
15:10:33 <augustss> mauke: I know
15:15:08 <augustss> @quote
15:15:08 <lambdabot> hongos_malos says: Esta ingestin provoca una enfermedad mortal llamada ergotismo, que en la Edad Media era conocida como fuego de San Antonio.
15:15:37 <Heffalump> couldn't have put it better myself
15:17:29 <omniscientIdiot> @babel es en Esta ingestión provoca una enfermedad mortal llamada ergotismo, que en la Edad Media era conocida como fuego de San Antonio.
15:17:30 <lambdabot>   This ingestión causes a mortal disease called ergotismo, that in the Average Age was well-known like fire of San Antonio.
15:17:46 <olsner> LSD?
15:19:46 <augustss> magic mushrooms, it seems :)
15:20:44 <augustss> or at least poisonous
15:20:59 <oerjan> http://en.wikipedia.org/wiki/Ergotism
15:21:01 <lambdabot> Title: Ergotism - Wikipedia, the free encyclopedia
15:22:35 <augustss> I liked "Average Age".  If you translate it literraly to Swedish you get exactly the right word.
15:23:21 <olsner> "The ergot sclerotium contains high concentrations (up to 2% of dry mass) of ergotamine, a complex molecule consisting of a tripeptide-derived cyclol-lactam ring connected via amide linkage to a lysergic acid (ergoline) moiety"
15:23:59 <augustss> Just what I was about to say.
15:24:22 <oerjan> exercise: what was easiest to understand of what olsner quoted, and Lamperi's parting message?
15:24:22 <omniscientIdiot> moiety has too many consecutive vowels for my tastes
15:24:54 <SamB> omniscientIdiot: how about queue
15:25:10 <omniscientIdiot> or onomatopoeia
15:25:19 <olsner> omniscientIdiot: there's a swedish word that ends with "stskt"
15:25:36 <SamB> how else would you spell onomatapoeia?
15:25:42 <omniscientIdiot> SamB:  we 'merkins say 'line' :)
15:26:05 <omniscientIdiot> SamB: I dunno
15:26:09 <SamB> I don't remember reading about delines...
15:26:09 <sgillespie> hello
15:26:33 <omniscientIdiot> greets!
15:26:35 <sgillespie> In the context of an functional abstract machine...what is a spine
15:27:03 <sgillespie> as in a "spineless tagless g-machine" or "The Three Instruction Machine is spineless"
15:27:07 * omniscientIdiot facefaults, then runs away
15:27:26 <omniscientIdiot> It always backs out of a fight
15:27:29 <olsner> omniscientIdiot: facefault?
15:27:49 <omniscientIdiot> olsner: anime term, apologies
15:27:59 <sgillespie> Then why would a spineless machine be preferrable??
15:28:19 <SamB> sgillespie: apparantly it isn't ;-)
15:28:41 <SamB> they put the spine back into STG.
15:28:46 <SamB> recently, the tags are back.
15:29:02 <SamB> and I also hear that it bears little resemblence to the G machine...
15:29:04 <sgillespie> tags are my next question
15:29:44 <oerjan> @remember SamB they put the spine back into STG. / recently, the tags are back. / and I also hear that it bears little resemblence to the G machine...
15:29:45 <lambdabot> Done.
15:30:05 <SamB> https://research.microsoft.com/users/simonpj/papers/ptr-tag/index.htm
15:30:06 <lambdabot> http://tinyurl.com/ypdwpy
15:30:21 <SamB> umm, don't ask why that's https
15:30:41 <augustss> Oh, I dunno, I think it's getting more like the G-machine again. :)
15:30:54 <sgillespie> so what is a spine?
15:31:16 <SamB> sgillespie: I'm not exactly sure...
15:31:27 <SamB> I got this second hand from sorear, I think
15:31:54 <kpreid> Second-Hand Semantics
15:31:56 <SamB> maybe dons
15:33:22 <augustss> sgillespie: it's the chain of application nodes from the top to the next redex
15:33:49 <sgillespie> augustss: so how can something be spineless?
15:33:51 <sjanssen> @hoogle exit
15:33:52 <lambdabot> System.Exit :: module
15:33:52 <lambdabot> System.exitFailure :: IO a
15:33:52 <lambdabot> System.exitWith :: ExitCode -> IO a
15:34:06 <olsner> so, is that somewhat similar to CPS?
15:34:28 <augustss> sgillespie: only spineless in the sense that it didn't store the spine separately when traversing it
15:34:37 <sgillespie> I see
15:35:03 <sgillespie> and that means the spine would be only in the stack?
15:35:10 <augustss> hmmm, I'd say it's unrelated to CPS
15:35:28 <augustss> sgillespie: not even on the stack
15:35:45 <augustss> except for a few select places
15:36:01 <sgillespie> Well you have to store the application nodes somewhere...
15:36:08 <olsner> http://research.microsoft.com/research/pubs/view.aspx?id=383&type=inproceedings this one's informative
15:36:10 <lambdabot> Title: The Spineless G-machine, http://tinyurl.com/32k5dm
15:36:12 <augustss> they are already stored in the graph
15:36:27 <olsner> (not), I should add
15:36:50 <augustss> the name is only of historical importance
15:36:51 <sgillespie> oh yeah
15:37:19 <augustss> if you want to understand then name, you first should take a look at the G-machine, and then STG
15:37:43 <sgillespie> I'm reading through SPJ's book "implementing a functional language: a tutorial"
15:37:50 <augustss> excellent reading!
15:37:57 <sgillespie> Just made my way through the g-machine
15:37:58 <Guest97623> hey guys i need some help with a problem
15:38:11 <sgillespie> yes, very interesting
15:38:26 <Guest97623> the fromInt function is not working in Winhugs 2006 Edition
15:38:42 <Guest97623> is there any other way to convert a Int to a Float ???
15:38:45 <mauke> fromIntegral
15:38:47 <omniscientIdiot> @type fromInt
15:38:49 <lambdabot> Not in scope: `fromInt'
15:39:00 <byorgey> @pl concatMap sequence
15:39:00 <lambdabot> (sequence =<<)
15:39:03 <mauke> > sqrt (fromIntegral (length "butter"))
15:39:04 <lambdabot>  2.449489742783178
15:39:14 <omniscientIdiot> > fromIntegeral (5 :: Int) :: Float
15:39:15 <lambdabot>   Not in scope: `fromIntegeral'
15:39:16 <augustss> sgillespie: but I think the earlier book is better
15:39:22 <Guest97623> @type fromIntegral
15:39:24 <lambdabot> forall a b. (Num b, Integral a) => a -> b
15:39:32 <omniscientIdiot> > fromIntegral (5 :: Int) :: Float
15:39:33 <lambdabot>  5.0
15:39:34 <sgillespie> "The Implementation of Functional Languages"?
15:39:37 <augustss> yes
15:39:38 <byorgey> Guest97623: I think fromInt is deprecated.  fromIntegral should be used instead.
15:39:58 <augustss> Yes, fromInt was a mistake.  Sorry about that.
15:40:03 <sgillespie> That one is on my radar too...This one just looked a bit funner
15:40:07 <olsner> "Parallel graph reduction with the (v, G)-machine"?
15:40:32 <augustss> olsner: what about it?
15:40:33 <Guest97623> fromIntegral (floor 7.89) + 4.6
15:40:43 <olsner> augustss: is that the "original" G-machine?
15:40:45 <mauke> > fromIntegral (floor 7.89) + 4.6
15:40:46 <lambdabot>  11.6
15:40:59 <augustss> olsner: no, that's a parallel one
15:41:00 <oerjan> :t (sequence =<<)
15:41:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [m a] -> m [a]
15:41:55 <sgillespie> so in a regular g-machine, you are storing the spine in the heap?
15:42:28 <augustss> olsner: "Thomas Johnsson: Efficient compilation of lazy evaluation."
15:42:55 * sorear re-materializes
15:43:05 <augustss> sgillespie: the spine is always there.  the question is how you treat it while finding the next redex
15:43:10 <araujo> "on the queue" , "onto the queue"
15:43:15 <araujo> how it sounds better?
15:43:21 <olsner> augustss: ah, that's the one! thanks ;-)
15:43:25 <allbery_b> I would say onto
15:43:35 <sgillespie> I see
15:43:48 <allbery_b> actually, I would usually say into for a programming queue
15:43:52 <byorgey> @pl concatMap
15:43:52 <lambdabot> (=<<)
15:44:03 <araujo> allbery_b, good, thanks
15:44:08 <augustss> enqueue
15:44:21 <sgillespie> So how do we treat it in a regular g-machine?
15:44:45 <sorear> Very elegantly
15:45:02 <sorear> there is a function UNWIND
15:45:07 <oerjan> :t concatMap sequence
15:45:08 <sorear> UNWIND looks at the current node
15:45:10 <lambdabot> forall a. [[[a]]] -> [[a]]
15:45:10 <sorear> if it'
15:45:14 <augustss> olsner: "Lennart Augustsson, Thomas Johnsson: The Chalmers Lazy-ML Compiler." describes it too
15:45:30 <sorear> s an application, push the ARGUMENT onto a astack
15:45:39 <sorear> when you get to a function, execute it
15:45:48 <sorear> the arguments will be the top N on the stack
15:45:55 <olsner> it's like functional forth!
15:46:01 <sorear> in the absense of seq, there will ALWAYS be enough arguments
15:46:20 <sorear> and you can do normal tail calls, etc
15:47:04 <augustss> you can't just push the arguments during UNWIND though, because you need to find the node to update when the result has been computed
15:47:48 <augustss> so there are variations on how you find the place to update.  that's one difference between the G-machine and the STG
15:48:23 <sorear> sgillespie: oh, and incase you haven't figured it out yet, augustss is the cited L.Augustsson
15:50:34 <sgillespie> does it have anything to do with storing an application node on the heap?
15:50:40 <n00b> what can I use to convert a float to Int
15:50:45 <n00b> ???
15:50:53 <omniscientIdiot> @src RealFrac
15:50:54 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
15:50:54 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
15:50:54 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
15:51:12 <omniscientIdiot> n00b: ^^
15:51:14 <sgillespie> As is shown in SPJ's g-machine...
15:51:35 <omniscientIdiot> > floor (2.7) :: Int
15:51:40 <lambdabot>  2
15:51:43 <LoganCapaldo> > floor 3.6 :: Int
15:51:44 <lambdabot>  3
15:51:44 <lambdabot> LoganCapaldo: You have 1 new message. '/msg lambdabot @messages' to read it.
15:51:45 <n00b> ok
15:51:53 <LoganCapaldo> I do?
15:52:01 <augustss> sgillespie: the application nodes are always in the heap.  it's the contents of the stack that's interesting
15:52:06 <sorear> sgillespie: spj didn't make the gmachine
15:52:23 <n00b> I am working the problem of the Tower of Hanoi in school
15:52:24 <sgillespie> I know he didn't make it...I mean the one he presents
15:52:26 <sorear> sgillespie: he didn't do much at all of note until the early 90's
15:52:44 <n00b> but my teach says no Lambda blah...
15:53:05 <LoganCapaldo> I suck at doing the tower of hanoi
15:53:17 <LoganCapaldo> I can do it for real
15:53:22 <sorear> i suck too, that's why I have my computer do it for me
15:53:25 <LoganCapaldo> but I always screw up trying to write the program
15:53:28 <n00b> I have to write a iterative and recursive function that outputs the results
15:53:38 <sgillespie> so, when we reach a MkApp instruction, we are pushing the arguments onto the stack
15:53:46 <sorear> no!
15:54:02 <olsner> iiuc, the vertebrate g-machine has an Unwind operation that takes an expression tree and transforms it into a stack... I'm guessing the next few papers I read will show how to skip that step and do it automagically on the run
15:54:12 <LoganCapaldo> veterbrate?
15:54:13 <sgillespie> we are pushing the node onto the stack
15:54:19 <LoganCapaldo> Is there a version with an exoskeleton?
15:54:29 <sgillespie> no??
15:55:01 <sgillespie> I'm looking at the wrong instruction...
15:55:02 <olsner> vertebrate = spineful /= spineless
15:55:22 <augustss> sgillespie: yes, because MkApp builds a graph
15:55:31 <n00b> no one can solve the tower of hnoi ???
15:55:45 <sgillespie> okay...
15:56:11 <mauke> n00b: I wrote a version in LETploki,ploki+1 once
15:56:21 <olsner> LoganCapaldo: as opposed to the evertebrate/spineless G-machine (as in STG)
15:56:22 <sgillespie> when we reach Unwind, it looks like we are pushing the first argument onto the stack
15:56:22 <augustss> sgillespie: i recommend working through some simple examples with the transition rules
15:56:30 <n00b> I want a version in haskell
15:56:37 <mauke> n00b: then write one
15:56:40 <LoganCapaldo> olsner: I think a exoskeleton version would be funnier
15:56:44 <n00b> it should be simple
15:57:01 <n00b> If Knew how to I wouldn't be asking
15:57:07 <augustss> sgillespie: I think the earlier book explains things better, actually
15:57:22 <mauke> n00b: oh, you're asking something?
15:57:35 <dcoutts> @seen dons
15:57:35 <lambdabot> dons is in #haskell-hac07, #xmonad and #haskell. I last heard dons speak 5h 55m 12s ago.
15:57:36 <byorgey> n00b: we don't do your homework for you here.  if you have some specific questions we'd be happy to help.
15:57:51 <LoganCapaldo> We don't do your homework here, for free
15:57:57 <byorgey> hehe
15:57:59 * LoganCapaldo is joking
15:58:10 <olsner> there's probably a model out there that would correspond to an exoskeleton... the functional community seems to love theze crazy names ;-)
15:58:11 <omniscientIdiot> we require payment in the form of lambdas
15:58:16 <olsner> *these
15:58:19 <Philippa> you wouldn't do homework /here/ at all, right?
15:58:49 <n00b> I don't want a lambdas version
15:58:50 <byorgey> omniscientIdiot: i.e. church numerals?
15:59:03 <n00b> prurely recursive /iterative
15:59:21 <mauke> n00b: do you even know what lambda is?
15:59:41 <LoganCapaldo> I do! It's a letter!
15:59:52 <n00b> yes
15:59:55 <omniscientIdiot> no lambdas!  Oh noes!  How will we maek teh funkshuns!!!
15:59:57 <sgillespie> But TIM doesn't have an unwind, but an enter
16:00:00 <n00b> but we haven't reached that
16:00:06 <LoganCapaldo> I can has lambda?
16:00:19 <sgillespie> and that doesn't traverse the application node
16:00:20 <Philippa> LoganCapaldo: I recently had cause to tell someone "on the bright side, you can carry on thinking of lambda as a greek letter first"
16:00:20 <n00b> my teacher specifically said no lambdas
16:00:38 <augustss> sgillespie: TIM is different :)
16:00:40 <sgillespie> is that close??
16:00:40 <Apocalis1> lambda-chop!
16:00:42 <LoganCapaldo> n00b no lambdas at all?
16:00:45 <sgillespie> closer*
16:00:45 <sjanssen> lambda discrimination?
16:00:56 <byorgey> I suppose your teacher meant no anonymous lambda expressions?
16:00:57 <LoganCapaldo> so just name every anonymous function you want to use
16:01:05 <augustss> n00b: what about beta?
16:01:12 <LoganCapaldo> with clever names like
16:01:14 <n00b> he is following a syllabus
16:01:15 <mauke> well, as Guido van Rossum will tell you, you can always use a named local function instead
16:01:35 <LoganCapaldo> thisWouldBeAnonymousButMyTeacherIsAnExPythonProgrammerOrSomething x = ...
16:01:39 <byorgey> > let noLambdasHere x = x + 1 in map noLambdasHere [1,2,3]
16:01:51 <lambdabot>  [2,3,4]
16:01:51 <mauke> > map succ [1,2,3]
16:01:53 <lambdabot>  [2,3,4]
16:02:01 <n00b> here's a version a friend wrote but i dont understand it
16:02:02 <n00b> hanoi h = hanoi' h 'f' 't' 'r'
16:02:03 <n00b> hanoi' 0 _ _ _ = []
16:02:03 <n00b> hanoi' h f t r = (hanoi' (h-1) f r t) ++ (f, t) : (hanoi' (h-1) r t f)
16:02:07 <sgillespie> is that what makes TIM spineless?
16:02:25 <LoganCapaldo> No, TIM running away from all his problems is what makes TIM spineless
16:02:25 <n00b> can you annotate it for me
16:02:35 <byorgey> n00b: no.
16:02:53 <byorgey> n00b: you need to at least go try to write your own version first.  ask your professor if you need help.
16:02:57 <sgillespie> how many times am I going to see that joke today? :)
16:03:13 <LoganCapaldo> sgillespie: I'm not the first? :(
16:03:16 <sorear> i have a version of the towers of hanoi in a dependent language; i don't *have* to run it
16:03:17 <sjanssen> @remember LoganCapaldo thisWouldBeAnonymousButMyTeacherIsAnExPythonProgrammerOrSomething x = ...
16:03:18 <lambdabot> Done.
16:03:21 <sgillespie> sadly, you are not...
16:03:25 * LoganCapaldo feels derivative and unoriginal
16:04:05 <omniscientIdiot> cheer up, Logan, you got a good quote there
16:04:13 <mauke> heh, do it in the type system!
16:04:23 * omniscientIdiot made the joke first, nyah-nyah-nyah nyaah nyaah!
16:05:00 <sgillespie> alright, i have to go search for a movie to watch
16:05:26 <sgillespie> thanks for enlightening
16:06:34 <n00b> hey do you know any good movie download sites
16:06:38 <n00b> or forums
16:06:57 <n00b> @type roots
16:06:59 <lambdabot> Not in scope: `roots'
16:07:21 <n00b> @type fromIntegral
16:07:23 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:09:08 <olsner> hmm... haskell's 'let' is the same as what's also called 'letrec', right?
16:09:22 <oerjan> olsner: yes
16:09:25 <omniscientIdiot> yep
16:10:23 <n00b> how do find how much root is in a quadratic equation by writing a function
16:10:29 <n00b> is that even possble
16:10:32 <n00b> ???
16:10:51 <omniscientIdiot> use the quadratic formula
16:11:07 <geocalc> #math
16:11:21 <n00b> understand that part, but how do i find how much root is in it
16:11:31 <Apocalis1> numeric prelude?
16:11:33 <byorgey> n00b: you want to know the number of real roots?
16:11:39 <omniscientIdiot> "how many roots"?  check if the discriminant is (< 0), (== 0), or (> 0)
16:12:40 <n00b> ax^2+bx+c=0
16:13:12 <omniscientIdiot> discriminant = b^2 + 4*a*c, iirc, it's been a while
16:13:19 <omniscientIdiot> (-), maybe?
16:13:21 <phobes> -
16:13:28 <phobes> it's the part under the radical in the QF
16:13:58 <n00b> her are the parmeters that the teacher gave me
16:14:23 <n00b> two real roots, if b^2 > 4.0 * a * c
16:14:39 <byorgey> that's right
16:14:44 <n00b> one real roots, if b^2 == 4.0 * a * c
16:14:57 <n00b> no real roots, if b^2 < 4.0 * a * c
16:15:33 <n00b> and a error clause if equal to zero
16:16:05 <phobes> n00b, First you'll want to construct the reals in haskell's type system
16:16:09 <n00b> so how do I go about calculating this >>>
16:16:17 <n00b> ok
16:16:21 <mauke> step 1: you write a program
16:16:26 <SamB> n00b: how many milli-olegs does he need?
16:16:27 <SamB> er.
16:16:30 <SamB> phobes:
16:16:38 * SamB is tired
16:17:01 <omniscientIdiot> realRootCount a b c = let d = b^2 - 4*a*c in ...
16:17:22 <LoganCapaldo> Tommorow is Sat. Maybe you can sleep late(?)
16:17:29 <LoganCapaldo> @ SamB
16:17:53 <SamB> yes. maybe.
16:18:16 <SamB> but I have homework due at 10:30 tonight that I still need to finish...
16:18:30 <n00b> roots (a,b,c) = (x1, x2) where
16:18:30 <n00b> x1 = e + sqrt d / (2 * a)
16:18:30 <n00b> x2 = e - sqrt d / (2 * a)
16:18:30 <n00b> d = b * b - 4 * a * c
16:18:30 <n00b> e = - b / (2 * a)
16:18:32 <oerjan> SamB: surely this would be micro-olegs?
16:18:37 <n00b> how does that look ???
16:18:42 <SamB> oerjan: he said IN THE TYPE SYSTEM
16:18:51 <SamB> doesn't that usually take milli-olegs?
16:19:00 <LoganCapaldo> at least
16:19:14 <oerjan> SamB: oh, i didn't read phobes's comment
16:19:21 <oerjan> indeed, then.
16:19:36 <omniscientIdiot> n00b: looks great, but you should probably use an if expression to guard against sqrt of negative number (i.e. no real roots)
16:19:50 <LoganCapaldo> @type sqrt
16:19:55 <lambdabot> forall a. (Floating a) => a -> a
16:20:02 <omniscientIdiot> = if d < 0 then [] else if d == 0 then e else (x1, x2)
16:20:03 <n00b> ok
16:20:12 <LoganCapaldo> @instances Floating
16:20:13 <lambdabot> Double, Float
16:20:16 <omniscientIdiot> = if d < 0 then [] else if d == 0 then [e] else [x1, x2]
16:20:20 <LoganCapaldo> I was afraid of that
16:21:14 <omniscientIdiot> LoganCapaldo: it'll just unify a, b, and c to Floating
16:21:21 <n00b> roots (a,b,c) = if d < 0 then error "sorry" else (x1, x2)
16:21:21 <n00b> where x1 = e + sqrt d / (2 * a)
16:21:21 <n00b> x2 = e - sqrt d / (2 * a)
16:21:21 <n00b> d = b * b - 4 * a * c
16:21:21 <n00b> e = - b / (2 * a)
16:21:40 <LoganCapaldo> omniscientIdiot: I was hoping for -> Complex
16:21:40 <n00b> thanks
16:21:42 <omniscientIdiot> n00b: that'll work
16:22:06 <oerjan> @instances-importing Data.Complex Floating
16:22:07 <lambdabot> Complex a, Double, Float
16:22:13 <LoganCapaldo> aha
16:22:18 <LoganCapaldo> nvm then
16:22:25 <augustss> > sqrt (-1 :+ 0)
16:22:25 <omniscientIdiot> n00b: but if d == 0, then x1 == x2, so you'll really only have one real root, twice
16:22:26 <lambdabot>      precedence parsing error
16:22:26 <lambdabot>         cannot mix prefix `-' [infixl 6] and `(...
16:22:45 <augustss> > sqrt ((-1) :+ 0)
16:22:46 <lambdabot>  0.0 :+ 1.0
16:23:11 <omniscientIdiot> > (0 :+ 1) ^ 2
16:23:11 <LoganCapaldo> huzzah
16:23:12 <lambdabot>  (-1.0) :+ 0.0
16:23:30 <LoganCapaldo> Once again Haskell demonstrates its sanity
16:23:30 <byorgey> > (0 :+ 1) ** (0.5)
16:23:31 <lambdabot>  0.7071067811865476 :+ 0.7071067811865475
16:23:33 <n00b> ok
16:24:02 <omniscientIdiot> > 0.5 :: Complex Double
16:24:04 <lambdabot>  0.5 :+ 0.0
16:24:28 <n00b> I worote a tail-recursive factorial function to calculate factoial 10000000
16:24:29 <omniscientIdiot> it's been a long time since I've done complex multiplication
16:25:02 <n00b> but I get a garbage collection error
16:25:14 <n00b> or sometimes a  Stack oveflow
16:25:21 <n00b> what is wrong ??
16:25:23 <mauke> > sqrt (-1) :: Complex Double
16:25:24 <lambdabot>  -0.0 :+ 1.0
16:25:32 <n00b> do I need a supercomputer ???
16:25:42 <sjanssen> n00b: welcome to laziness :)
16:25:44 <mauke> n00b: no, just strictness
16:25:57 <oerjan> > product [1..10000000]
16:26:00 <lambdabot> Terminated
16:26:09 <oerjan> a bit too large perhaps
16:26:15 <oerjan> > product [1..1000000]
16:26:19 <sjanssen> n00b: the compiler is building up a big chain of suspended computations which will fill the heap
16:26:19 <lambdabot> Terminated
16:26:31 <sjanssen> n00b: your problem will probably go away if you compile with -O
16:26:41 <mauke> here's a hanoi program: http://rafb.net/p/pWCtfs16.html
16:26:42 <lambdabot> Title: Nopaste - No description
16:26:42 <n00b> ???
16:26:56 <omniscientIdiot> I think he's using Hugs
16:27:08 <sjanssen> oh
16:27:51 <omniscientIdiot> mauke: is that False?
16:27:55 <mauke> yes
16:28:00 <Saizan> ?src product
16:28:00 <lambdabot> product = foldl (*) 1
16:28:04 <oerjan> > product [1..100000]
16:28:08 <mauke> (I also have a false interpreter if you need one)
16:28:08 <lambdabot> Terminated
16:28:18 <oerjan> wait a moment...
16:28:32 <omniscientIdiot> mauke: I've written three =D
16:29:00 <omniscientIdiot> in Io, windows JScript, and Haskell
16:29:01 <n00b> I use the function product [1..n] to calculate factorial, but it rises my CPU usage
16:29:37 <omniscientIdiot> it's my try-out-a-language problem of choice :)
16:29:41 <P_D> > foldl' (*) 1 [1..100000]
16:29:45 <lambdabot> Terminated
16:29:50 <mauke> n00b: try foldl' (*) 1
16:30:09 <mauke> omniscientIdiot: http://rafb.net/p/pWCtfs16.html
16:30:09 <lambdabot> Title: Nopaste - No description
16:30:29 <oerjan> > sum $ map (logBase 10) [1..10000000]
16:30:33 <lambdabot> Terminated
16:30:42 <oerjan> sheesh
16:31:17 <omniscientIdiot> she cannae du eet, cap'n!  She ain't gott th'powah!
16:31:18 <n00b> @type logBAse
16:31:21 <lambdabot> Not in scope: `logBAse'
16:31:22 <n00b> @type logBase
16:31:24 <lambdabot> forall a. (Floating a) => a -> a -> a
16:31:32 <byorgey> > logBase 2 16
16:31:33 <n00b> @type logBase
16:31:33 <lambdabot>  4.0
16:31:35 <EvilTerran> > foldl' (+) 0 $ map (logBase 10) [1..10000000]
16:31:35 <lambdabot> forall a. (Floating a) => a -> a -> a
16:31:39 <lambdabot> Terminated
16:31:56 <byorgey> hm, ten million?
16:32:03 <mauke> foldl' is futile. lambdabot uses -O anyway
16:32:15 <EvilTerran> doodies.
16:32:18 <byorgey> ten million is, like, a lot.
16:32:20 <omniscientIdiot> that's probably somewhat large :)
16:32:33 <EvilTerran> > sum [1..8] --:P
16:32:34 <lambdabot>   Not in scope: data constructor `P'
16:32:38 <EvilTerran> > sum [1..8] -- :P
16:32:39 <lambdabot>  36
16:32:39 <oerjan> i was just trying to find out how large it was...
16:32:57 <oerjan> > sum $ map (logBase 10) [1..1000000]
16:33:00 <lambdabot>  5565708.917186656
16:33:03 <EvilTerran> > map (logBase 10) [1..10000000]
16:33:04 <lambdabot>  [0.0,0.30102999566398114,0.47712125471966244,0.6020599913279623,0.6989700043...
16:33:18 <EvilTerran> wait... i was thinking of something else. nvm.
16:33:33 <oerjan> ok, so 1000000! has more than 5 million digits
16:33:38 <P_D> log N! ~ N log N - N
16:34:00 <omniscientIdiot> ~ is approx equals?
16:34:05 <segher_> n! =~ (n/e)**n
16:34:22 <EvilTerran> same asymptotic tendencies
16:34:25 <byorgey> Prelude Data.List> foldl' (+) 0 $ map (logBase 10) [1..10000000]
16:34:25 <byorgey> 6.5657059080059275e7
16:34:34 <segher_> evilterran: yes
16:34:35 <P_D> yes, there's a series which converges to it, look up stirlings appropximation
16:34:50 <n00b> product [1..1000000]
16:35:01 <oerjan> 65 million digits?
16:35:25 <omniscientIdiot> n00b: prefix expressions with '> ', but this particular one is futile.  LB has a limit of 3 seconds.
16:35:44 <oerjan> and it didn't manage 100000 even
16:36:00 <ddarius> So use a different method to calculate it.
16:36:04 <n00b> ok
16:36:08 <EvilTerran> gamma function?
16:36:12 <Tac-Tics2> @src liftM
16:36:13 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:36:16 <n00b> product [1..10]
16:36:21 <Tac-Tics2> @src liftM2
16:36:21 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:36:54 <Tac-Tics2> > product [1..]
16:36:56 <oerjan> last time we tried splitting the product
16:36:59 <lambdabot> Terminated
16:37:06 <n00b> &type max
16:37:12 <EvilTerran> @google gamma
16:37:15 <lambdabot> http://en.wikipedia.org/wiki/Gamma
16:37:15 <lambdabot> Title: Gamma - Wikipedia, the free encyclopedia
16:37:18 <EvilTerran> @hoogle gamma
16:37:18 <lambdabot> Test.QuickCheck.Poly.GAMMA :: type GAMMA
16:37:19 <lambdabot> Test.QuickCheck.Poly.OrdGAMMA :: type OrdGAMMA
16:37:19 <EvilTerran> :O
16:37:24 <EvilTerran> *:P
16:37:30 <EvilTerran> damnit, i fail at typing this evening
16:37:49 <n00b> @google toer of hanoi
16:37:52 <lambdabot> http://www.huntington-indiana.com/mycomputerbuddies/games/TowerHanoi/tower.htm
16:37:52 <lambdabot> Title: Toer Of Hanoi Game
16:37:52 <n00b> @google tower of hanoi
16:37:55 <lambdabot> http://www.cut-the-knot.org/recurrence/hanoi.shtml
16:37:55 <lambdabot> Title: Tower of Hanoi
16:37:58 <omniscientIdiot> n00b: if you want to play with LB, she listens to /msg
16:38:25 <omniscientIdiot> try @list and @help <command>
16:40:27 <n00b> @help foll
16:40:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:40:31 <n00b> @help fodl
16:40:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:40:33 <EvilTerran> @let gamma z = fst . head . takeWhile (uncurry (/=)) $ zip l (tail l) where l = [product [1..n] * (n**z) / product (map (z+) [0..n])
16:40:33 <lambdabot>  Parse error
16:40:44 <n00b> @help list
16:40:44 <lambdabot> list [module|command]
16:40:44 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:40:46 <cognominal_> >  [1..6 ] >>>  [(1+), (2*)]
16:40:47 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:40:48 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:40:54 <Pseudonym> Woo!
16:40:59 <Pseudonym> Bug report.
16:41:06 <EvilTerran> @let gamma z = fst . head . takeWhile (uncurry (/=)) $ zip l (tail l) where l = [product [1..n] * (n**z) / product (map (z+) [0..n]) | n <- [1..]]
16:41:08 <lambdabot> Defined.
16:41:16 <EvilTerran> > map gamma [1..]
16:41:17 <lambdabot>  [0.5,0.16666666666666666,8.333333333333333e-2,5.0e-2,3.333333333333333e-2,2....
16:41:24 <EvilTerran> hm.
16:41:32 <EvilTerran> > gamma
16:41:32 <Pseudonym> > gamma (1 :+ 1)
16:41:34 <lambdabot>   add an instance declaration for (Enum (Complex t))
16:41:34 <lambdabot>     In the expression: g...
16:41:34 <lambdabot>  <Double -> Double>
16:42:01 <n00b> @type system
16:42:03 <EvilTerran> must've done that wrong
16:42:03 <lambdabot> Not in scope: `system'
16:42:05 <oerjan> you do realize gamma of 10000000 is far outside the bounds of Double?
16:42:27 <P_D> What?  I doubt that
16:42:41 <byorgey> it has 65 million digits!
16:42:47 <n00b> @type ma
16:42:48 <n00b> @type max
16:42:49 <lambdabot> Not in scope: `ma'
16:42:50 <lambdabot> forall a. (Ord a) => a -> a -> a
16:42:59 <EvilTerran> i'd've hoped to get close values for gamma 1 etcetera, though.
16:43:09 <EvilTerran> > gamma 1
16:43:10 <lambdabot>  0.5
16:43:12 <n00b> (12 max 4) max 34
16:43:17 <EvilTerran> > product [1..0]
16:43:19 <lambdabot>  1
16:43:24 <EvilTerran> bit different ;)
16:43:31 <P_D> Hm ok, only 20ish bits of exponent.
16:43:33 <byorgey> > (12 `max` 4) `max` 34
16:43:34 <lambdabot>  34
16:43:39 <n00b> (12 `max` 4) `max` 34
16:43:41 <P_D> need 25 or so
16:43:44 <byorgey> > maximum [12, 4, 34]
16:43:45 <lambdabot>  34
16:43:50 <idnar> > [1..0]
16:43:52 <lambdabot>  []
16:44:08 <P_D> > logBase 2 65000000
16:44:09 <lambdabot>  25.953936382352627
16:44:10 <EvilTerran> (i took that from http://en.wikipedia.org/wiki/Gamma_function#Alternative_definitions)
16:44:12 <lambdabot> http://tinyurl.com/qhjun
16:44:29 <EvilTerran> oh, wait
16:44:31 <EvilTerran> @undef
16:44:32 <lambdabot> Undefined.
16:44:41 <EvilTerran> @let gamma z = snd . head . dropWhile (uncurry (/=)) $ zip l (tail l) where l = [product [1..n] * (n**z) / product (map (z+) [0..n]) | n <- [1..]]
16:44:44 <lambdabot> Defined.
16:44:47 <cognominal_> >  [1] >>>  []
16:44:47 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:44:48 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:44:49 <EvilTerran> > map gamma [1..]
16:44:53 <lambdabot> Terminated
16:44:55 <EvilTerran> > gamma 1
16:44:59 <lambdabot> Terminated
16:45:02 <EvilTerran> >:[
16:45:08 <EvilTerran> @undef , I give up
16:45:09 <lambdabot> Undefined.
16:45:14 <cognominal_> >  [1] >>>  0
16:45:15 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:45:15 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:45:40 <byorgey> cognominal_, how'd you do that?
16:45:56 <n00b> hey guys thanks bye
16:46:03 <Pseudonym> Please submit that as a GHC bug.
16:46:22 <cognominal_> I don't know how to register in trac
16:46:49 <Pseudonym> http://www.haskell.org/mailman/listinfo/glasgow-haskell-bugs
16:46:57 <lambdabot> Title: Glasgow-haskell-bugs Info Page
16:47:05 <Pseudonym> Don'
16:47:11 <Pseudonym> t need to join, just mail them.
16:47:22 <cognominal_> ok
16:47:55 <laz0r> are you guys trying to come up with a gamma function? i ask because some time ago i just took the one from 'Numerical Recipes in C', translated it to haskell and put it somewhere in the wiki...
16:48:34 <oerjan> @instances-importing Control.Arrow Arrow
16:48:35 <lambdabot> (->), Kleisli m
16:48:40 <byorgey> hey, what do you know: http://haskell.org/haskellwiki/Gamma_and_Beta_function
16:48:41 <lambdabot> Title: Gamma and Beta function - HaskellWiki
16:48:48 <oerjan> > [1] >>> 0
16:48:49 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:48:49 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:48:55 <oerjan> :t (>>>)
16:48:57 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
16:48:59 <byorgey> that definitely shouldn't even typecheck
16:49:20 <P_D> numerical recipes is notoriously poor
16:49:30 <P_D> be careful if you're doing real work
16:49:33 <oerjan> > "a" >>> "b"
16:49:34 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
16:49:39 <laz0r> ok
16:49:45 <laz0r> i'll make a mentasl note about that
16:49:54 <oerjan> > [a] >>> "b"
16:49:55 <lambdabot>   Not in scope: `a'
16:49:59 <byorgey> lists are not instances of Arrow.
16:50:01 <oerjan> > [a] >>> 0
16:50:02 <lambdabot>   Not in scope: `a'
16:50:15 <omniscientIdiot> byorgey: they aren't even kinded right
16:50:20 <byorgey> yup.
16:50:23 <oerjan> i know, i was wondering what phase broke it
16:50:30 <LoganCapaldo>     well they should be, gosh darn it
16:50:33 <mauke> > "" >>> ""
16:50:34 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
16:50:44 <oerjan> :t [1] >>> 0
16:50:46 <lambdabot> <command line>:
16:50:46 <lambdabot>     Could not find module `L':
16:50:56 * byorgey nominates LoganCapaldo to write the instance of Arrow for lists
16:50:57 <oerjan> hm...
16:51:11 <oerjan> :t ([1] >>> 0)
16:51:11 <mauke> > ([] :: [Char]) >>> []
16:51:13 <lambdabot> <command line>:
16:51:13 <lambdabot>     Could not find module `L':
16:51:13 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
16:51:24 <oerjan> :t ([1] >>> 0)
16:51:25 <mauke> > ['a'] >>> []
16:51:27 <lambdabot> <command line>:
16:51:27 <lambdabot>     Could not find module `L':
16:51:27 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:51:27 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:51:46 <LoganCapaldo> instance Arrow [a] where pure _ = undefined
16:51:51 <byorgey> weirdness... is that a bug in GHC, or LB?
16:52:03 <omniscientIdiot> definitely ghc
16:52:03 <mauke> ghc
16:52:12 <byorgey> ok =)
16:52:19 <mauke> :t 42
16:52:20 <byorgey> LoganCapaldo: nice try
16:52:21 <lambdabot> forall t. (Num t) => t
16:52:31 <omniscientIdiot> Prelude> [1] Control.Arrow.>>> []
16:52:31 <omniscientIdiot> : panic! (the 'impossible' happened)
16:52:31 <omniscientIdiot>   (GHC version 6.6.1 for i386-unknown-mingw32):
16:52:31 <omniscientIdiot>         nameModule it{v aIB}
16:52:31 <omniscientIdiot> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
16:52:34 <lambdabot> Title: ReportABug - GHC - Trac
16:52:47 <LoganCapaldo> I am to please :)
16:52:53 <LoganCapaldo> s/am/aim/
16:53:25 <byorgey> yup, I get the panic too... but I only have ghc 6.6
16:53:29 <omniscientIdiot> LoganCapaldo: unfortunately you'll get "[] isn't * -> * -> *!!!!!" errors before it even looks at the instance.
16:53:59 <LoganCapaldo> Hmm
16:53:59 <oerjan> > [x|x <- [1..10]] >>> 0
16:54:00 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:54:00 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:54:12 <oerjan> > [1..10] >>> 0
16:54:13 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:54:13 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:54:25 <oerjan> > (1:2:[]) >>> 0
16:54:25 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
16:54:27 <LoganCapaldo> @src Arrow
16:54:27 <lambdabot> class Arrow a where
16:54:27 <lambdabot>     arr, pure   :: (b -> c) -> a b c
16:54:27 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
16:54:27 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
16:54:27 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
16:54:29 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
16:54:32 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
16:54:37 <mauke> this bug is bizarre
16:55:01 <oerjan> > [1,3 .. 10] >>> 0
16:55:02 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:55:02 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:55:12 <oerjan> everything with [...]
16:55:17 <byorgey> > (return 1) >>> 0
16:55:18 <lambdabot>   add an instance declaration for (Show (a b d))
16:55:23 <oerjan> but not equivalent ones with :
16:55:29 <mauke> or ""
16:55:29 <sorear> > [] >>> 0
16:55:29 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
16:55:31 <byorgey> > (return 1 :: [Int]) >>> 0
16:55:31 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
16:55:43 <LoganCapaldo> instance Arrow [b -> c] where pure f = [f] ? I wonder what you could do with that
16:55:43 <oerjan> oh, not [] alone?
16:55:46 <mauke> > ([1] :: [Int]) >> 0
16:55:47 <lambdabot>   add an instance declaration for (Num [b])
16:55:57 <sorear> > [1] >>> 0
16:55:58 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:55:58 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:56:00 <sorear> > [1] >>> []
16:56:00 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:56:01 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:56:08 <sorear> > (>>>) [1] []
16:56:08 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:56:09 <mauke> > ([1] :: Num a => [a]) >> 0
16:56:09 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:56:09 <lambdabot>   add an instance declaration for (Num [b])
16:56:12 <sorear> > (>>>) [1]
16:56:13 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:56:13 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:56:18 <mauke> wtf
16:56:21 <sorear> > (>>>) ['a']
16:56:21 <byorgey> lol
16:56:22 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:56:22 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:56:23 <mauke> a type signature fixes it
16:56:26 <sorear> > (>>>) "a"
16:56:27 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
16:56:31 <LoganCapaldo> Is that the bug I reported?
16:56:31 <Pseudonym> > (+) ['A']
16:56:32 <lambdabot>   add an instance declaration for (Num [Char])
16:56:32 <lambdabot>     In the expression: (+) ['A...
16:56:36 <oerjan> > [1] >>> a
16:56:36 <lambdabot>   Not in scope: `a'
16:56:57 <omniscientIdiot> oh lawd!  (>>>) ['a'] gets it but not (>>>) "a"!!
16:56:58 <Pseudonym> > (>>=) ['A']
16:56:59 <lambdabot>  Add a type signature
16:57:00 <oerjan> > flip (>>>) 0 [1]
16:57:00 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:57:01 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:57:23 <oerjan> > map (>>>) [[1]]
16:57:24 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:57:24 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:57:33 <oerjan> > map (>>>) [['a']]
16:57:33 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:57:33 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:57:36 <tehgeekmeister> ?src forM
16:57:36 <lambdabot> forM = flip mapM
16:57:39 <oerjan> > map (>>>) ["a"]
16:57:40 <lambdabot>  Couldn't match expected type `a b' against inferred type `[]'
16:57:47 <tehgeekmeister> ?src mapM
16:57:47 <lambdabot> mapM f as = sequence (map f as)
16:57:49 <byorgey> > let out = (>>>); noes = 1 in flip out 0 [noes]
16:57:50 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
16:57:50 <lambdabot>   (GHC version 6.6 for i386-unkn...
16:58:13 <LoganCapaldo> http://hackage.haskell.org/trac/ghc/ticket/1376
16:58:15 <lambdabot> Title: #1376 (panic caused in ghci by the following code involving monad transformers)  ...
16:58:17 <LoganCapaldo> it seems very similar
16:58:32 <LoganCapaldo> scrool down to the bottom to see the smart people discussion
16:58:42 <omniscientIdiot> > (>>>) (0,0) -- seems related to [...] syntax
16:58:43 <lambdabot>   add an instance declaration for (Arrow (,))
16:58:43 <lambdabot>     In the expression: (>>>) (0...
16:58:52 <Pseudonym> s/smart/knowledgable/
16:59:26 <Pseudonym> Right, so it's in code generation.
17:00:22 <skaslev> @src Arrow
17:00:23 <lambdabot> class Arrow a where
17:00:23 <lambdabot>     arr, pure   :: (b -> c) -> a b c
17:00:23 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
17:00:23 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
17:00:23 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
17:00:24 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
17:00:26 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
17:00:54 <oerjan> > let h :: f a b -> f a b; h = id in h [1]
17:00:55 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
17:00:56 <lambdabot>   (GHC version 6.6 for i386-unkn...
17:01:32 <oerjan> (adapting the last trac example)
17:01:44 <omniscientIdiot> > let h :: f a b -> f a b; h = id in h (1:[])
17:01:44 <lambdabot>  Couldn't match expected type `f a' against inferred type `[]'
17:01:56 <omniscientIdiot> right, desugaring
17:02:49 <oerjan> it seems to happen when something tries to match the type of an [...] expression to a type constructor with more than one argument...
17:03:26 <omniscientIdiot> GHC BUGS OH NOES!!
17:03:43 <ddarius> 6.6 was pretty buggy
17:04:13 <FMota> Well, Haskell is dead. You'd expect some bugs.
17:04:24 <FMota> Haskell Curry, that is.
17:04:42 <chessguy> let's not be disrespectful
17:04:52 <ddarius> FMota: He might've been cremated.
17:05:04 <FMota> You're right...
17:05:15 <FMota> Although that would have side effects.
17:05:29 <FMota> Hence, unsafe.
17:05:31 <oerjan> and we cannot have that.
17:06:51 <LoganCapaldo> dman
17:07:14 <LoganCapaldo> the date on that bug report implies I've been learning haskell for at least 5months
17:07:41 <LoganCapaldo> and I still feel like a noob :)
17:08:08 <chessguy> i'm over a year, and i still feel like a newb
17:08:09 <byorgey> LoganCapaldo: welcome to the club! =)
17:08:30 <chessguy> LoganCapaldo, the trick is to be a Terrible Programmer
17:08:31 <omniscientIdiot> I've been here for three centuries, newb
17:08:55 <chessguy> LoganCapaldo, http://kickin-the-darkness.blogspot.com/2007/09/confessions-of-terrible-programmer.html
17:08:59 <lambdabot> Title: Kickin' the Darkness: Confessions of a Terrible Programmer, http://tinyurl.com/2xbc44
17:09:04 <LoganCapaldo> yeah I saw that
17:09:12 <byorgey> wow.  what did you run Haskell on, before there were computers?
17:09:22 <P_D> real computer scientists work on pencil and paper
17:10:03 <Philippa> not necessarily. Not everyone's actually comfortable with a pencil - personally it's painful when I write
17:10:27 <phobes> What's the largest amount of code you've written without running it through a compiler?
17:10:30 <FMota> I like pen :)
17:10:32 <omniscientIdiot> I scribbled beta-reductions in the sand with a rock.
17:10:51 <FMota> lol.
17:10:51 <pgavin> phobes: probably 2000 lines :)
17:11:19 <phobes> pgavin:  I wrote a first pass at a 5K line module (granted, this was C++) without ever trying to run it :)
17:11:29 <phobes> (it ended up being 15K)
17:11:31 * byorgey cringes in horror
17:11:54 <phobes> It's not as bad as it sounds
17:12:00 <pgavin> sometimes I have to force myself to run the compiler :)
17:12:02 <phobes> Things were surprisingly easy to debug
17:12:04 <paczesiowa> 99% was some static char[] :>
17:12:20 <phobes> hehe no, it was real code :)
17:12:30 <pgavin> it gets to the point that I'm afraid of the bugs/compiler errors I'm going to have to deal with
17:12:55 <LoganCapaldo> don't fear the compiler
17:13:00 <LoganCapaldo> trust the compiler
17:13:08 <LoganCapaldo> the compiler is your friend
17:13:22 <phobes> doing things without a compiler forces you to keep the design in your head, though, which can be nice
17:13:24 <pgavin> true
17:13:31 <Philippa> it's better to check often, then you don't build big tangles of error and confusion
17:13:41 <LoganCapaldo> it doesn't force you to keep the design in your head
17:14:01 <Philippa> about the only thing that does is not having any more permanent medium to inscribe the design in
17:14:01 <phobes> well, true ... but if you don't then you'll be writing pages of nonsense :)
17:14:12 <LoganCapaldo> it forces you to keep minutiae in your head that distracts you from keeping the design in your head
17:14:28 <ddarius> phobes: And so...
17:14:35 <pgavin> since I started using haskell, I realized the designs I had weren't working in other languages because I wasn't using the wrong language
17:14:37 <phobes> I'm not actually recommending this...
17:14:48 <phobes> I'm on board with incremental test cycles and all
17:14:54 <pgavin> s/wrong/right/ :)
17:14:58 <augustss> not compiling, just designing and writing code leads to better programs.  according to some studies
17:15:05 <phobes> I'm just saying, everyone cringes in horror, but it's not that bad ....
17:15:45 <phobes> augustss:  I think that's a good idea, but you should stop and test each module after having wrtten it
17:15:46 <augustss> instead of compiling it, you have to convince your collegues that it does the right thing
17:15:58 <LoganCapaldo> lol
17:16:11 <omniscientIdiot> whiteboard + colleague = gravy
17:16:15 <augustss> phobes: the testers should not be the programmers
17:16:17 <Philippa> sure, in a lot of languages that's going to work out modulo syntax errors
17:16:31 <augustss> IBM has used this to design very high quailty software
17:16:31 <phobes> augustss:  initial tester is always the programmer :)
17:16:48 <augustss> IBM did not let the programmers use a compiler at all
17:16:50 <LoganCapaldo> that is a much richer and complex test than checking if it compiles, but  I don't know its a more accurate one, or that it tests the code so much as your communication skils and your colleagues comprehension skills
17:16:53 <phobes> tester:  "Hey augustss, I found a syntax error"
17:17:01 <phobes> augustss:  wow...
17:17:13 <Philippa> do you know which language they were working in, OOI?
17:17:22 <Philippa> the "get it past the other programmers" bit's a good idea anyway
17:17:48 <Philippa> and testing's going to catch any trivial syntax errors
17:18:01 <phobes> "Well, it was crashing, so I put this if(x==NULL) return; line and that seemed to fix it.  Sold?"
17:18:32 <phobes> I love hearing that from a colleague during a code review for a bug fix
17:18:34 <LoganCapaldo> someone just checked in code like that today
17:18:54 <LoganCapaldo> I pretended I didn';t see it
17:19:43 <Philippa> that's quite literally worse than failure
17:20:12 <sorear> people actually do that?
17:20:15 <LoganCapaldo> although in this case I think the interface was supposed to be such that NULL was optional
17:20:24 <LoganCapaldo> err rather the string was optional
17:20:25 <chessguy> i saw a great piece of javascript code once. it was something like this: try { if (x.foo && x){ bar(x.foo) } catch(e) {}
17:20:37 <Philippa> sorear: people do that and far worse
17:21:23 <Philippa> if that's doing what I think it is, it should be if (x && x.foo)...
17:21:30 <Philippa> (checking they're both non-null)
17:21:42 <chessguy> certainly
17:22:09 <P_D> javascript has pointers?
17:22:12 <chessguy> and then they wouldn't have needed the try/catch block, which they almost certainly put in there because it was crashing, and they didn't know why
17:22:33 <chessguy> P_D, not pointers at such
17:22:33 <P_D> I thought java was supposed to be better typed than that
17:22:42 <Philippa> javascript != java
17:22:46 <Philippa> and references != pointers
17:22:50 <chessguy> P_D, first of all, javascript is WAY WAY cooler than java
17:22:52 <Philippa> (you can't do reference arithmetic, for example)
17:22:57 <chessguy> and yes, it has references, not pointers
17:23:07 <P_D> ok, how do you get a null reference?
17:23:13 <Philippa> yeah, but the average star's core is WAY WAY cooler than java
17:23:16 <idnar> there is a value "null" in javascript
17:23:17 <chessguy> you don't, you get an undefined value
17:23:28 <idnar> there's also a value "undefined"
17:23:42 <P_D> default for maps and such?
17:23:54 <chessguy> e.g., if i do "var foo;", foo's value is undefined
17:23:55 <idnar> if you try and access an attribute of an object that doesn't exist, you get undefined
17:24:02 <P_D> mm ok.
17:24:05 <platypus> idnar: It can be argued that undefined is not a value but the lack of one.
17:24:21 <sorear> haskell is so much cooler, we have Maybe
17:24:33 <idnar> platypus: well, in practical terms, it's just a special value
17:24:37 <omniscientIdiot> and undefined! :)
17:24:46 <idnar> more interesting is the type undefined
17:24:52 <chessguy> > let 3 = undefined in 3
17:24:54 <lambdabot>  3
17:24:59 <chessguy> boo!
17:25:10 <idnar> nonexistent local variables have the type "undefined" even though trying to access them produces an exception, not the value undefined
17:25:16 <omniscientIdiot> chessguy: 3 is a constructor, let 3 = ... is a pattern match
17:25:23 <chessguy> blah blah blah
17:25:30 <LoganCapaldo> lawl
17:25:34 <idnar> > let fromInteger 3 = undefined in 3
17:25:35 <lambdabot>  3
17:25:40 <LoganCapaldo> I can has pattern match?
17:26:17 <chessguy> > let i = undefined in i can has pattern match
17:26:18 <lambdabot>   Not in scope: `match'
17:26:30 <idnar> heh
17:26:45 <Philippa> > i can has pattern match
17:26:45 <lambdabot>   Not in scope: `match'
17:26:54 <Philippa> thought as much (odd!)
17:27:00 <chessguy> ok, i need to not write haskell code tonight, apparently
17:27:08 <Philippa> ...well, not so odd, I'm just used to LL parsers
17:27:45 <chessguy> i'm glad i discovered that before breaking open my chess engine code
17:28:09 <Philippa> > let canHaz = const true; cheezBurger = undefined in canHaz cheezBurger
17:28:10 <lambdabot>   Not in scope: `true'
17:28:15 <Philippa> ...D'oh!
17:29:25 <ddarius> Haskell isn't cooler for having maybe, it's cooler for not having NULL.
17:29:47 <Philippa> right, when you screw up in Haskell it just moons you instead
17:36:30 <tehgeekmeister> ?src sequence
17:36:30 <lambdabot> sequence ms = foldr k (return []) ms
17:36:30 <lambdabot>     where
17:36:30 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
17:40:50 <byorgey> @type replicateM_
17:40:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
17:41:23 <byorgey> @type replicateM
17:41:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:54:05 <tehgeekmeister> ?src foldM
17:54:06 <lambdabot> foldM _ a []     = return a
17:54:06 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
17:54:47 <tehgeekmeister> doesn't this essentially make foldM and sequence equivalent?
17:54:53 <tehgeekmeister> or is there a subtle difference i'm not catching?
17:57:20 <dolio> @type foldM
17:57:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:57:24 <dolio> @type sequence
17:57:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:58:39 <LoganCapaldo> You gotta know when to holdM, know when to foldM
17:59:08 <Cale> @remember LoganCapaldo You gotta know when to holdM, know when to foldM
17:59:08 <lambdabot> Done.
17:59:44 <dolio> @type foldM (\b -> liftM (:b)) []
17:59:46 <lambdabot> forall a1 (m :: * -> *). (Monad m) => [m a1] -> m [a1]
18:05:49 <byorgey> @source StateT
18:05:49 <lambdabot> StateT not available
18:06:03 <byorgey> @info StateT
18:06:03 <lambdabot> (StateT)
18:06:14 <byorgey> grr
18:06:20 <byorgey> in what module is StateT defined?
18:06:35 <sorear> @index StateT
18:06:35 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
18:06:40 <byorgey> oh, @index!
18:06:46 <byorgey> forgot about that one =)
18:06:52 <byorgey> thanks sorear
18:13:02 <byorgey> when putting {-# LANGUAGE blah blah #-} at the top of a .lhs file, should a > be placed before it or not?  does it matter?
18:14:58 <byorgey> ok, turns out the > is required
18:22:35 <chessguy> ?hoogle hold
18:22:35 <lambdabot> No matches found
18:22:44 <chessguy> pf, no hold, much less holdM
18:24:45 <Cale> Mathematica has a Hold
18:24:52 <Cale> (and HoldForm)
18:25:25 <P_D> for dynamic scoping?
18:26:00 <LoganCapaldo> Hold Form? Does that prevent someone from casting polymorph on the target?
18:26:35 <Cale> heh
18:26:58 <LoganCapaldo>  
18:27:10 <Cale> For preventing evaluation
18:28:27 <Cale> Mathematica has a really insane evaluation mechanism.
18:28:59 <LoganCapaldo> This is madnes
18:29:09 <sorear> Is it really more insane than call-by-need?
18:29:13 <LoganCapaldo> Thos is mathematica!!!!
18:29:55 <Cale> sorear: You can make a definition like Cos[x] ^= 2, and that becomes part of the definition of x.
18:30:11 <Cale> (not of Cos)
18:30:26 <sorear> what's ^=?
18:30:37 <sorear> declaration of equality?
18:30:48 <Cale> lhs^=rhs assigns rhs to be the value of lhs, and associates the assignment with symbols that occur at level one in lhs.
18:31:03 <P_D> (As opposed to Cos[x_] := 2)
18:31:58 <Cale> After doing that,  UpValues[x]  will report  {HoldPattern[Cos[x]] :-> 2}
18:32:47 <Cale> (and of course, Cos[x] will evaluate to 2, but Cos[y] won't)
18:33:03 <Cale> You can only do that one level deep though.
18:33:30 <Cale> For some reason (probably complexity), they don't provide for deeper upvalues.
18:33:52 <tehgeekmeister> ?src (++)
18:33:52 <lambdabot> (++) []     ys = ys
18:33:52 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
18:34:44 <LoganCapaldo> > let xs ++ ys = foldr (:) ys xs in [1,2,3] ++ [4,5,6]
18:34:45 <lambdabot>  [1,2,3,4,5,6]
18:35:37 <KatieHuber> Does anyone here know about HOC (The Haskell-ObjectiveC bridge)?
18:36:04 <KatieHuber> I have built it successfully, but am getting compilation errors I don't understand on some of the examples
18:36:22 <Cale> I know of it, and I know the guy who wrote it, but I've never used it.
18:36:23 <SamB> KatieHuber: from what compiler?
18:36:35 <KatieHuber> It's GHC yelling
18:36:45 <KatieHuber> it doesn't like $(declareClass .....................)
18:36:46 <SamB> what does it say?
18:36:58 <KatieHuber> TVUtilities.hs:60:0: parse error on input `$'
18:37:07 <LoganCapaldo> Isn't that TH?
18:37:09 <KatieHuber> oddly, one of the examples does build and run
18:37:26 <KatieHuber> but I don't see the difference between the working and nonworking ones
18:38:17 <KatieHuber> there was an obvious "import HOC" in the one that was working and not in the one that wasn't, but adding it changed nothing
18:38:59 <Cale> KatieHuber: is it being compiled with -fth ?
18:39:15 <byorgey> @pl \x -> [x,x]
18:39:15 <lambdabot> ap (:) return
18:39:22 <KatieHuber> cale: HOC itself, or the exampel?
18:39:28 <KatieHuber> example is built with ghc --make -fglasgow-exts Main.hs -odir build -hidir build -O -o Browser
18:39:38 <Cale> KatieHuber: the file which is giving the error
18:39:53 <KatieHuber> then the answer is no :)
18:40:01 <Cale> maybe try adding that flag
18:41:36 <KatieHuber> that does indeed fix the error (though I get an apparently unrelated one later)
18:41:43 <KatieHuber> what does it mean?
18:42:06 <SamB> it means "this file code uses TH, you idiot!"
18:42:13 <Cale> heh
18:42:24 <KatieHuber> TH stands for?
18:42:29 <SamB> Template Haskell
18:42:30 <Cale> $( ... ) is Template Haskell syntax
18:42:33 <KatieHuber> ah, I see
18:42:49 <KatieHuber> I saw HOC doing something with that as it built itself
18:44:11 <KatieHuber> so... it's a bit like a lisp or dylan syntax macro?
18:44:29 <SamB> yeah, but more complicated
18:46:24 <Cale> I really ought to re-read some stuff on TH and see if I can sort out exactly why it has those strange module restrictions.
18:46:27 <KatieHuber> cool thanks
18:46:36 <KatieHuber> got all but one example working with that
19:10:40 <pangwa> hello everybody,
19:10:50 <pangwa> Does anyone know how to embed haskell(or other fp language) into a C++ system?
19:11:05 <sorear> @where ffi
19:11:06 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
19:11:08 <sorear> pangwa: Via C.
19:11:10 <pangwa> we're going to optimize the performace of our application on the muliti-processor machines.
19:11:17 <pangwa> we think FP may be helpful, what's your opinions on that?
19:11:24 <pangwa> a, thnaks
19:11:30 <sorear> probably not a good idea
19:11:44 <sorear> parallelism is promising, but it's definitely distant
19:12:14 <pangwa> aha?
19:12:25 <sorear> usual practice is to use haskell for bits that DON'T need to be fast, since it's less work for programmers
19:15:20 <pangwa> so, is there any other fp langauge which can have a good performance in parallelism system?
19:15:48 <sclv> hey all. with allow undecidable instances on, is there any way to "hint" to the compiler that you prefer one choice over another, or are overlapping instances insurmountable?
19:17:31 <pangwa>  -- so, is there any other fp langauge which can have a good performance in parallelism system?
19:17:31 <pangwa>  
19:17:53 <sclv> i.e. if i want to "force" an instance to have low precedence, can i do this, or do i just need to find some way to rewrite my code?
19:18:21 <chessguy> erlang?
19:19:18 <byorgey> sclv: I'm not aware of any way to make the compiler prefer one instance over another.
19:20:54 <phobes> sclv:  I asked that and they told me to make a newtype
19:22:18 <hpaste>  sclv pasted "Problem with undecidable instances" at http://hpaste.org/2986
19:23:34 <byorgey> sclv: yeah, that's hard, because what you really want to say is "for any type a which isn't a tuple"...
19:23:37 <sclv> phobes: the problem is newtype needs an extractor, right?
19:23:55 <byorgey> but doing that is difficult in Haskell's type system
19:24:29 <byorgey> actually, I'm not even sure if it's possible...
19:26:08 <byorgey> sclv: as phobes suggests, you could make a type like 'newtype Single a = Single a'
19:26:11 <sclv> hmmm... maybe i could find something else useful to return in the first instance instead. returning a single element list is possible but hacky
19:26:21 <ddarius> byorgey: Erlang is designed for concurrency not parallelism
19:26:22 <byorgey> then have instance (ReadMe a) => Tuple (Single a)
19:26:47 <sclv> or yeah, a newtype, but then i need to extract it, which is equally hacky, right?
19:26:50 <byorgey> but that's obviously ugly in some ways
19:26:52 <byorgey> yeah
19:28:29 <sclv> hmm... i think i've got an easy solution. redefine the range of my answers so that every returned value is at least a tuple.
19:28:51 <pangwa> <ddarius> sorry, but I'm not quite clear on what the differece between concurrency and parallelism
19:29:39 <sclv> thanks all
19:29:45 <OceanSpray> Me neither.
19:29:47 <OceanSpray> explain?
19:30:36 <ddarius> parallelism is semantics preserving and usually done for speed/scalability, concurrency is a definite semantic artifact and is used for a variety of reasons primarily to accurately model the system
19:36:42 <LoganCapaldo> ddarius: good explanation
19:37:51 <SamB> and it's nice if you can get some parallelism with your concurrency
19:38:07 <LoganCapaldo> I want cake
19:38:44 <ddarius> and it's ugly if you get some concurrency with you parallelism
19:39:40 <pangwa> what do you mean by ugly?
19:40:13 <ddarius> concurrency means non-determinism means (more) difficult to reason about
19:41:09 <SamB> I want milk
19:41:12 <SamB> but we ran out
19:41:23 <LoganCapaldo> I am also out of milk
19:41:34 <SamB> I also want a time machine so I can finish this assigment and submit it before the deadline
19:41:36 * ddarius doesn't know when the last time he's drank a cup of straight milk was
19:41:40 <SamB> which was about ten minutes ago...
19:41:50 <LoganCapaldo> the other day I boght a carton
19:42:02 <LoganCapaldo> but I live by myself
19:42:08 <LoganCapaldo> so my milk keeps going bad
19:42:12 * LoganCapaldo moves to blah
19:42:21 <SamB> huh
19:42:29 <SamB> around here we drink about a gallon a day
19:42:32 <byorgey> SamB: use the time-travel monad
19:42:40 <ddarius> SamB: Operative word "we"
19:42:40 <SamB> but there are like four of us...
19:43:00 <scook0> use call/cc when you get the assignment
19:44:28 <SamB> what?
19:44:39 <SamB> the software still accepts submissions...???
19:44:49 <ddarius> Why not?
19:48:32 * byorgey is writing a Befunge interpreter in Haskell =D
19:48:54 <LoganCapaldo> Not a haskell interpreter in befunge?
19:49:10 * SamB really wishes he wasn't in so many lab classes...
19:49:20 <byorgey> LoganCapaldo: that's next.
19:49:49 <SamB> how much heap can you fit on an IBM's screen?
19:50:14 <byorgey> LoganCapaldo: actually, in college my friend and I wrote a C -> Befunge compiler, so I could theoretically use that to generate a Haskell interpreter in Befunge =)
19:50:27 <LoganCapaldo> lol
19:50:33 <LoganCapaldo> awesome
19:50:41 <byorgey> it was totally silly but a lot of fun
19:54:15 <sclv> ooh... -fallow-overlapping-instances actually solves my original problem
19:55:29 <byorgey> sclv: it does?
19:55:34 <byorgey> neat
20:08:26 * SamB wishes he could get even 120% time on his homework...
20:26:34 <dbueno> Why doesn't Foldable provide map? Or Foldable extend Functor?  Or even Data.Set implement Functor?
20:27:26 <dolio> Data.Set cannot implement Functor due to restrictions on element type that don't gel in the type system.
20:27:50 <dbueno> Huh.  Okay.  Are those documented somewhere in case I get the courage to try to understand them?
20:28:41 <dolio> Hmm, I don't know. There have been many mailing list threads about why Set doesn't currently implement Monad, the same issue applies to Functor.
20:28:45 <dolio> So you could search there.
20:28:45 <Jedai> dbueno: All elements of a set (or a map) must be instance of Ord
20:29:07 <Jedai> dbueno: A functor should be able to contain any element
20:29:29 <Pseudonym> And "fmap" would have to be Ord-preserving for it to make sense.
20:29:29 <lambdabot> Pseudonym: You have 1 new message. '/msg lambdabot @messages' to read it.
20:29:47 <Pseudonym> ?seen ddarius
20:29:47 <lambdabot> ddarius is in #haskell-overflow, #haskell-blah and #haskell. I last heard ddarius speak 27m 44s ago.
20:29:55 <Pseudonym> ddarius: Good point, I'll fix that.
20:30:00 <dolio> I'm not sure why Foldable doesn't have Functor as a requirement. Traversable does.
20:30:07 <dbueno> Pseudonym: It couldn't just call Set.map?  Oh, right, Set.map requires Ord.
20:31:00 <dolio> Maybe there are things you can fold that aren't functors.
20:38:41 <dolio> "Will learning Haskell first damage your brain?"
20:39:21 <dbueno> Jedai, dolio, Pseudonym: thanks for the help.
20:43:06 <newsham> hi
20:43:21 <newsham> dolio: it might ruin your appetite
20:43:37 <dolio> :)
21:40:16 <Randroid> Wow, this place is hoppin'. I guess Haskellers *do* have social lives.
21:41:12 * Randroid just returned from a vacation in Jamaica. No computer, no internet, no Haskell.
21:41:57 <shachaf> Randroid: You can't escape Haskell that easily.
21:42:15 <bos> it watches you, like in that police song.
21:42:23 <glguy> I don't know... my honeymoon was in Jamaica, and we didn't have any Haskell there either :)
21:42:27 <shachaf> It follows you in your head.
21:42:51 <Randroid> Well, I did think about Haskell just a bit while I was there. But I went to one of those all-inclusive resorts (Sandals Negril), and after enough free drinks, I couldn't think about much of anything.
21:43:46 <Randroid> I tried to think more about FunDeps while I was there, but I'm just beginning with that aspect of the language, and booze, sunshine, and constant offers of "ganja, mon?" don't help much in that area.
21:50:51 <goalieca> hmm. i should just bother asking math questions in here from now on
21:52:44 <Cale> goalieca: hm?
21:56:14 <Randroid> How weird, I was just talking about math over in #dylan.
21:56:31 <Randroid> The fact that people automatically assume that programmers are good at it. Not necessarily.
21:56:41 <goalieca> programmers are more pragmatic maybe
21:56:51 <goalieca> pure math people can be too anal for teacher
21:56:54 <Cale> There are programmers good at mathematics in here
21:57:19 <Randroid> I came to programming through linguistics, so my interest has always been syntactic rather than engineering/mathemical. I'm not particularly good (or bad) at math.
21:57:29 <Cale> Of course, functional programmers are basically applied logicians.
21:57:52 <sorear> I was a programming fan until I found CH, now my main interest is math!
21:58:01 <goalieca> well i'm in engineering. i'm not interested in all the details all the time. sometimes it is enough for me to know something i can use
21:58:09 <Cale> sorear: Curry-Howard that is?
21:58:13 <sorear> yes
21:58:23 <Cale> I should just assume it means that in this channel ;)
21:58:28 <Randroid> My main interest is grammar, whether of human languages or programming languages.
21:58:34 <shachaf> sorear: When was that?
21:58:50 <ddarius> Cale: As opposed to?
21:58:51 <goalieca> Randroid, my lab is right beside the natural language processing people's
21:58:56 <goalieca> and they do a lot of cog sci stuff
21:58:59 <Cale> ddarius: Continuum Hypothesis
21:59:08 <ddarius> Cale: Ah.
21:59:15 <Cale> ddarius: Which is what I always think of first when I hear CH :)
21:59:30 * ddarius doesn't find the continuum hypothesis all that interesting.
21:59:42 <Randroid> goalieca: Yeah, I got into Lojban (the "logical language") when I was into stuff like that, but it's a very complex thing, and while Lojban is interesting, it's not particularly well-suited to natural language processing.
21:59:59 <Cale> I think I've wanted it to be true more often than I've wanted it to be false.
22:00:11 <Randroid> http://www.lojban.org
22:00:14 <lambdabot> Title: Lojban : Home Page
22:00:16 <Cale> But most set theorists seem to feel the opposite way about it.
22:00:59 <Cale> actually, I think I'd be reasonably happy with V=L
22:02:13 <coffeemug> hey, would you guys mind giving me some UI feedback?
22:02:20 <Cale> sure
22:02:21 <coffeemug> http://68.237.11.45:8080/
22:02:22 <lambdabot> Title: Weblocks Demo - A Technology Demonstration
22:02:42 <coffeemug> the table of employees has a Details link
22:02:53 <coffeemug> if you click on it, you get details for a given employee that you can modify
22:03:00 <coffeemug> the question is
22:03:15 <coffeemug> If I completely remove the details link and let the user simply click on a row
22:03:20 <coffeemug> would that be a good idea?
22:03:34 <sorear> I can't seem to click on rows
22:03:48 <bos> rows already look clickable, but nothing happens.
22:03:49 <coffeemug> sorear: yeah, sorry, there's a pointer but JS yet
22:03:55 <Cale> If you're not going to make the rows clickable for details, you shouldn't highlight them like that
22:04:08 <Randroid> I'd leave the Details link. It looks clearer for Lusers.
22:04:08 <coffeemug> I shouldn't have added the pointer :)
22:04:15 <sorear> coffeemug: "a pointer but JS yet"?
22:04:25 <shachaf> coffeemug: "Details" is a bit confusing if that doesn't show any more details.
22:04:28 <coffeemug> sorear: I mean I set CSS to change the mouse pointer to a hand
22:04:31 <Cale> Changing the sort field seems less responsive than I'd expect.
22:04:39 <Cale> But I suppose it doesn't really matter.
22:04:53 <coffeemug> Cale: you mean it's slow?
22:04:56 <Cale> yeah
22:05:01 <Cale> It takes a whole second
22:05:01 <Randroid> coffemug: Homer Simpson lives in New Jersey? Is that where the mythical Springfield is? :)
22:05:05 <sorear> coffeemug: ah well, as an elinks fanatic I didn't notice
22:05:21 <Cale> Sorting a list of 3 elements doesn't seem like it should take so long :)
22:05:33 <sorear> coffeemug: I just can't give up a chance to help stop the prolifiration of buzzword-compliant unussable websites
22:05:33 <coffeemug> Cale: I think it's more of a bandwidth issue
22:05:34 <ddarius> Rename "Details" to "Edit" and don't change the pointer to a hand .
22:05:36 <coffeemug> this is on my home machine
22:05:43 <ddarius> (over the rows that is)
22:05:48 * bos ratchets his cpu temperature up to 92C by building ghc with both cores
22:05:51 <Cale> also, now my session's timed out and I can't change the sort order
22:06:07 <Cale> Oh, is it sorting on the server side?
22:06:11 <coffeemug> Cale: hmm, just refresh
22:06:14 <coffeemug> Cale: yeah
22:06:17 <shachaf> You do the sorting on the server?
22:06:18 <shachaf> Why?
22:06:29 <Cale> This looked AJAXy enough that I'd expect that to be done on the client :)
22:06:32 <shachaf> As long as everything is so JS-heavy...
22:06:39 <coffeemug> well, it would make sense to do it on the client
22:06:45 <coffeemug> only if there are few items
22:06:49 <coffeemug> if there is a thousand...
22:06:52 <coffeemug> and it's paged
22:07:01 <Cale> What's the selection for?
22:07:01 <coffeemug> btw, if you turn off JS
22:07:04 <coffeemug> everything scales back
22:07:06 <Cale> ah, okay
22:07:10 <coffeemug> Cale: deleting
22:08:11 <coffeemug> hmm
22:08:18 <coffeemug> basically if the link is gone
22:08:22 <coffeemug> and people can just hit on a row
22:08:31 <coffeemug> it is cleaner, but it seems unusual
22:08:40 <coffeemug> for the web
22:08:45 <coffeemug> not sure if it will be clear enough
22:08:50 <coffeemug> on the other hand, a link per each row
22:08:52 <coffeemug> seems wasteful
22:09:19 <Cale> There's another problem, the cursor is already changing to a hand over the text in the rows, but clicking doesn't work
22:09:43 <coffeemug> Cale: yes, sorry, I changed the CSS but didn't implement clicking
22:09:46 <coffeemug> I was just playing around
22:09:46 <Cale> It's kind of like the G-Mail UI
22:09:49 <coffeemug> it's work in progress
22:09:59 <Cale> If you make clicking in the middle open the record.
22:10:10 <coffeemug> ahh, connections timed out because people hit the debug reset button in lower left
22:10:13 <coffeemug> I should have turned it off
22:10:17 <coffeemug> this resets sessions for everyone
22:10:19 <coffeemug> sorry :)
22:10:41 <Cale> hehe
22:11:56 <ramza3> is anybody using hunit, or is a better unit testing framework out there
22:12:15 <ddarius> ramza3: There's quickcheck but they are complementary.
22:12:38 <swix> is... warren burton in here?
22:12:44 <coffeemug> Cale: so what do you think, keep the link or not?
22:13:06 <Cale> coffeemug: I think take it out and make the rows selectable
22:14:03 <ddarius> I don't think opening an edit dialog is the obvious behavior of clicking on a row and personally would prefer a link (and have the rows be static or have it do something else).
22:14:06 <coffeemug> Cale: right, making them clickable would be a prerequisite :)
22:14:24 <shachaf> ddarius: I thought QC could do anything HUnit could.
22:14:30 <coffeemug> ddarius: well, one option is to keep both the link and the clickable rows
22:14:49 <shachaf> coffeemug: You could at least call the link "edit".
22:15:59 <coffeemug> shachaf: sure, I'll rename it
22:16:09 <ddarius> shachaf: For monadic things, HUnit seems nicer and it also has a lot of convenient combinators and such.
22:16:21 <hpaste>  sclv annotated "scanf so far (about half done)" with "A working scanf with type magic" at http://hpaste.org/2960#a1
22:16:21 <coffeemug> ok, renamed
22:16:26 <coffeemug> you guys are killing me :)
22:17:00 <Cale> Put the Add and Delete buttons at the top
22:17:16 <ddarius> coffeemug: As I said, I don't find clicking on the row popping open an edit dialog intuitive and would prefer it to do something else or nothing.
22:17:40 <ddarius> Having two ways of doing the same thing would be even worse.
22:17:46 <coffeemug> ddarius: hmm, ok
22:20:54 <ddarius> coffeemug: I'm not a user interface design expert and I'm only one person so...
22:23:09 <coffeemug> ddarius: I got 5 different opinions from 5 different people
22:23:20 <coffeemug> it's both very useful and very distracting :)
22:23:21 <ddarius> coffeemug: That sounds about right.
22:23:39 <coffeemug> I'll play around and settle on one thing, I was just hoping for some concensus
22:23:40 <coffeemug> but alas
22:24:33 <ddarius> I like simple and obvious (to use a less loaded and clearer word than "intuitive")
22:24:50 <coffeemug> well
22:25:05 <coffeemug> unfortunately this isn't a universal concept
22:25:37 <coffeemug> to some people moving a mouse over a row they want to edit and seeing a highlighting and an mouse hand cue suggests that the simple and obvious thing is to click on it
22:25:47 <coffeemug> to others it doesn't suggest anything at all
22:26:03 <ddarius> Yes, it is simple and obvious that you should click on it, but that it leads to an edit dialog is not simple and obvious.
22:26:17 <coffeemug> what would you expect it to lead to?
22:26:47 <coffeemug> how about a more detailed presentation with a "modify" link?
22:26:56 <Cale> I think that's simple enough, given that it's non-destructive.
22:27:08 <ddarius> I would expect it to lead to a more detailed page of some sort.
22:27:48 <coffeemug> yeah
22:27:52 <coffeemug> this is likely what I'll do
22:28:06 <ddarius> I never really offered what it -should- do (except perhaps nothing), just that what it does (or would if you'd implemented it) do is -not- what I expect.
22:28:47 <Cale> I'd expect that to edit it.
22:28:48 <coffeemug> right
22:29:11 <Cale> Given that it's an interface designed for editing records.
22:29:30 <ddarius> Cale: Is that obvious from the page, it wasn't to me, but maybe I missed it?
22:29:50 <coffeemug> well, this interface is generated generically from the data model
22:30:10 <coffeemug> so it isn't really designed for anything but a rapid prototyping of CRUD
22:30:13 <Cale> I thought so
22:30:38 <Cale> Maybe not for everyone though :)
22:31:07 <ddarius> Cale: If the page was obviously an editting page, i.e. had a title like "Edit Records" or something equally overt then I'd thoroughly agree.  But without the Edit links and especially as it was to start without the Add/Delete buttons as well it's not at all clear.
22:31:41 <Cale> I'm sort of curious how this design will scale up
22:32:14 <Cale> If there are 50 records displayed, putting the edit controls at the bottom of the page doesn't seem like the right thing to do.
22:32:30 <coffeemug> Cale: yes
22:32:32 <ddarius> I agree with that.
22:32:38 <coffeemug> Cale: they should be moved to the top
22:32:53 <coffeemug> and if there are more than some threshold of records they should perhaps be duplicated at the bottom
22:32:58 <Cale> Or maybe clicking on a field could turn the fields into edit boxes/dropdowns
22:33:04 <Cale> er, a row
22:33:30 <ddarius> That would be more acceptable to me, though still not necessarily ideal.
22:33:40 <Cale> Or of course, you could just have a separate page.
22:33:46 <coffeemug> Cale: yeah, that's an option
22:33:50 <coffeemug> Cale: just edit in place
22:34:03 <ddarius> Or you could have all the fields and such just be textboxes/dropdowns in the first place.
22:34:12 <Cale> That's true
22:34:17 <coffeemug> I think eventually clicking will open a separate page or a mini-dialog
22:34:30 <coffeemug> I just don't have call/cc functionality in place yet
22:34:42 <coffeemug> so I try not to do complex flow yet :)
22:34:47 <Cale> I suppose whether in-line editing makes sense depends on how many columns you have per-record
22:35:13 <Cale> If there are more columns than can be displayed in the table like that, then it makes sense to pull that out into a separate interface.
22:35:44 <Cale> Oh, another possible design: stick the editing tools in a table cell immediately after the row when it's clicked on.
22:36:00 <Cale> (shifting the rest down)
22:36:14 <ddarius> You can use some crazy CSS to do it!
22:36:57 <coffeemug> another issue is that I specially design stuff to scale down in case user doesn't have JS enabled
22:37:03 <coffeemug> or uses a screen reader
22:37:08 <Cale> Is this a continuation-based framework?
22:37:15 <coffeemug> Cale: it isn't yet, but it will be
22:37:24 <ddarius> coffeemug: Indeed, so why do all this craziness and not use the "standard" components.
22:37:28 <coffeemug> Cale: I plan to use coroutines to implement control flow
22:37:36 <Cale> I noticed the funky hashed action URLs.
22:37:52 <coffeemug> ddarius: it's nice to give users with JS some extra goodies
22:38:03 <coffeemug> Cale: those just link back to closures in a hashmap
22:38:56 <brad_> tell me something new and amusing about the haskell world, i am waiting for llvm to compile
22:39:21 * ddarius tends to prefer (when making a webpage) straight XHTML/CSS with as little javascript as possible (usually none)
22:39:49 <jmob> So, why does 2/3 => 0.3333... instead of 0 in Haskell, 2 and 3 are integers, shouldn't they produce the same type of result?
22:40:02 <ddarius> 2 and 3 are not integers
22:40:05 <coffeemug> ddarius: so turn off JS :)
22:40:11 <Cale> jmob: using / means they're Floating point
22:40:14 <sclv> > 2 `div` 3
22:40:16 <lambdabot>  0
22:40:17 <brad_> use noscript if you use js
22:40:18 <Cale> (or at least some Fractional type)
22:40:26 <sjanssen> @type 1 -- see the polymorphism, jmob?
22:40:28 <lambdabot> forall t. (Num t) => t
22:40:29 <ddarius> coffeemug: Not everyone shares my views, so that doesn't help we with other pages.
22:40:35 <Cale> @type 2/3
22:40:37 <lambdabot> forall t. (Fractional t) => t
22:40:47 <coffeemug> ddarius: good pages should scale down
22:40:50 <brad_> ddarius - noscript lets you whitelist js domains
22:40:52 <Cale> > (2 :: Integer) / (3 :: Integer)
22:40:52 <lambdabot>   add an instance declaration for (Fractional Integer)
22:40:52 <lambdabot>     In the expression:...
22:41:02 <sjanssen> jmob: the literal '1' has *any* numeric type
22:41:05 <Cale> Trying to divide integers with / gives a type error
22:41:13 <jmob> sjanssen: oh
22:41:25 <ddarius> coffeemug: I obviously failed to clarify (despite explicit effort).  I'm talking about pages -I- make.
22:41:28 <Cale> That's a genuinely different kind of operation, so it's given the name div
22:41:38 <jmob> sjanssen: unlike having to specify 2.0 to get a "fractional" type?
22:41:41 <Cale> There's also mod, to get the remainder
22:41:42 <coffeemug> ddarius: ahh, sorry
22:41:46 <coffeemug> I missed that
22:41:46 <sjanssen> @type 2.0
22:41:49 <lambdabot> forall t. (Fractional t) => t
22:42:08 <sjanssen> jmob: the 2.0 trick works in Haskell too, but you usually don't have to use it
22:42:20 <brad_> does anyone here use yi? i tried it out....seems its got a ways to go
22:42:24 <Cale> 2 is strictly more general than 2.0
22:42:31 <jmob> What does the ``forall t.'' mean in lambdabot's output?
22:42:35 <Cale> brad_: yeah
22:42:43 <Cale> jmob: for any type t
22:42:51 <sjanssen> jmob: you can ignore it, GHC spits it out when extensions are turned on
22:42:54 <brad_> i thought it would properly indent haskell code - nope!
22:43:03 * ddarius prefers the explicit foralls.
22:43:08 <jmob> Cale: and Fractional is a type class?
22:43:13 <Cale> jmob: yeah
22:43:27 <jmob> k... just making sure I have the terminology correct.
22:43:35 <Cale> jmob: That roughly says, for any type t, if t is a Fractional type, then t could be the type of 2.0
22:43:43 <ddarius> brad_: My understanding is that nothing properly indents Haskell code for some values of "properly"
22:44:01 <brad_> fair enough ddarius, although i have to say the emacs mode seems to work for me
22:44:07 <sorear> brad_: it's a tiny proof-of-concept editor, maybe usable as a nvi replacement if you had lots of ram... I wouldn't recommend using it for anything
22:44:18 <jmob> Cale: (could be => if there's an instance that implements Fractional'ness for that type)
22:44:21 <Cale> The emacs indenting mode pisses me right off. ;)
22:44:28 <brad_> agrees with sorear
22:44:43 * sorear wants to know who pointed brad_ at yi
22:44:44 * ddarius uses autoindent in vim and is happy.
22:44:57 * sorear uses noautoindent in vim and is happy.
22:44:58 <brad_> my web page is in a race with sorear's for most stripped down page - yes i actually visited your site tonight sorear!
22:45:06 <jmob> brad_: it doesn't work when I want to indent if statements
22:45:14 <shachaf> sorear: What's wrong with autoindent?
22:45:15 <Cale> jmob: Well, the "could be" there refers to the fact that in the end, you'll probably pick some specific type
22:45:28 <Cale> jmob: otherwise the calculations can't actually take place :)
22:45:43 <jmob> Cale: right.. :)
22:45:43 <brad_> jmob: yes i sometimes manually indent
22:45:50 <Cale> But you could also take it to mean that 2.0 has *every* Fractional type
22:46:01 <sorear> shachaf: it's insufficiently predictable for my feeble mind, I have to check how much indent was inserted (which takes as long as manually intenting it)
22:46:26 <shachaf> sorear: Why? It's just as much as the last line.
22:46:33 <shachaf> sorear: No?
22:46:48 <jmob> So... literals take on different types based on the context they're used in.
22:46:59 <Cale> sorear: can't you see how much was inserted based on where your cursor is?
22:47:06 <ddarius> jmob: 1 is parsed as fromInteger 1
22:47:06 <Cale> jmob: yep
22:47:30 <sorear> shachaf: exactly
22:47:30 <Cale> and 2.0 is fromRational (2%1)
22:47:37 <shachaf> ddarius: Which is fromInteger (fromInteger 1)?
22:47:46 <sorear> shachaf: if my brain was that powerful, it wouldn't be a problem
22:48:03 <Cale> shachaf: no, it's more like fromInteger (1 :: Integer)
22:48:10 <sorear> shachaf: but I can't compute "leftmost non-whitespace in current line" in realtime at typing-speed
22:48:11 <shachaf> sorear: As long as you're indenting to that level anyway, why does it matter?
22:48:18 <shachaf> Cale: I know, I know. :-)
22:48:24 <ddarius> 1 clearly has type Integer in fromInteger 1 anyway
22:48:42 <shachaf> Yes, I understood what you meant.
22:48:53 <ddarius> sorear: You can't see the previous line?
22:49:40 <sjanssen> clearly 1 is parsed as (fromInteger (S# 1#)) ;)
22:50:46 <shachaf> sorear: You could highlight whitespace up to that point.
22:52:52 <sclv> what would be nice is a simple way to autodelete trailing whitespace from lines. i'm sure there's one in emacs i just don't know about
22:53:16 <ddarius> sclv: In any edit, you should be able to search and replace it.
22:54:36 <shachaf> sclv: :%s/\s\+$//?
22:55:42 <sclv> hmmm.. i guess if i hooked the search and replace into the emacs save function or something then it would be pretty handy. i always liked how eclipse had a whole set of autoformatting that could be enabled on save.
22:56:52 <ddarius> I'd be pretty surprised if you -couldn't- do that with emacs.
22:57:19 <coffeemug> sclv: funny, I always hated that
22:57:35 <coffeemug> emacs doesn't know the phrase "couldn't"
22:57:59 <sclv> ddarius: btw, the scanf code i pasted has a type closer, i think, to what you were suggesting. you can do, e.g. scanf "num%dstr%s %s" "num45345strasdf ddd" :: (Int,String,String) or as (Float, String, String) or etc. and it works out fine.
22:58:38 <ddarius> sclv: Yep. I noticed that.
22:59:09 * ddarius personally agrees with coffeemug about "autoformatting on save"
22:59:23 <coffeemug> brb
23:01:53 <sclv> i'm a compulsive autoformatter so it works for me, except there's no decent way to tell it how to format various types of anonymous classes nicely (especially with the double-bracket initialization trick).
23:05:01 <ddarius> sclv: When I say save, I want it to save what is written, not go on to make a bunch of arbitrary other changes.
23:05:59 <coffeemug> heh
23:06:02 <coffeemug> clear and simple :)
23:07:25 <ddarius> "the next version of the definition of Haskell will have a built-in type of natural numbers"
23:07:27 <sclv> ddarius: i guess its just because Java creates such messy long lines (at least how i do it) that i appreciate more than usual when they get cleaned up for me into something mildly more readable.
23:08:36 <sclv> ddarius: plus its even handy for it to alphebetize the dozen+ stupid getters and setters i've ended up autogenerating along the way. in a fun, concise language on the other hand...
23:15:26 <ddarius> sclv: I have no problem with the autoformatting, I have a problem with it happening on save.
23:30:00 <Cale> ddarius: nice
23:30:06 <Cale> (the Natural numbers thing)
23:34:31 <dancor> is it generally decided that yampa is the right way to do events in haskell?  are there alternatives
23:42:58 <ddarius> Cale: I'm wondering where the person who wrote that got that idea.
23:43:34 <Cale> ddarius: Oh, so you're not saying that it's official.
23:44:28 <ddarius> No, it's not as far as I know.  Certainly that quote wasn't from an "official" source.
23:48:03 <ddarius> Cale, I imagine you have ops on #math ?
23:49:33 <Cale> ddarius: yeah
23:53:26 <calvins> Anybody know how to get haddock generated docs to link to online html in base? I'm using Cabal (1.1.6.2), and am trying to configure like: runhaskell Setup.hs configure --user --prefix=$HOME --haddock-args="--use-package=base --source-base=http://protempore.net/rdf4h/ --  --read-interface=http://www.haskell.org/ghc/docs/latest/html/libraries/base,/usr/share/doc/ghc-6.6.1/html/libraries/base/base.haddock"  Configure works, but when
23:53:26 <calvins> I try to run the haddock target, it says "openFile: does not exist (No such file or directory)". But the file it's complaining about is on my filesystem at the given location. Any ideas?
23:54:03 <calvins> I believe --read-interface is supposed to be sufficient, but I'm not having any luck.
23:54:23 <calvins> I saw an online discussion about with no solution from back in March, but couldn't find anything else online.
23:55:55 <calvins> I've also tried without source-base and with and without use-package.
