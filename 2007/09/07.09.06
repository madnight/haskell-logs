00:02:08 <scook0_> making a Unique outside of IO would violate referential transparency
00:02:18 <Tac-Tics> I understand that
00:02:24 <scook0_> :)
00:07:43 <Tac-Tics> when you import a module in Haskell, do the modules imported by that module come into the current module's namespace?
00:08:10 <oerjan> no
00:08:18 <Tac-Tics> that's good to hear
00:08:19 <Tac-Tics> hehe
00:08:42 <oerjan> however a module can reexport other module's contents under its own name
00:08:48 <oerjan> *modules
00:08:51 <oerjan> *modules'
00:09:06 <Tac-Tics> why is the export syntax so ugly in haskell?
00:09:13 <Tac-Tics> X-(
00:11:54 <oerjan> commas and parentheses are ugly?
00:12:16 <Tac-Tics> just having to retype the name of everything you want to export
00:12:28 <Tac-Tics> instead of having an export annotation where the function is declared
00:13:10 <wli> An export annotation where functions are declared would be nicer, yes.
00:13:17 <oerjan> i think there is some idea that the import/exports of a file could be found without reading the whole file
00:13:41 <oerjan> which is probably why those are the only declarations that cannot be moved freely about
00:14:49 <oerjan> *around
00:14:54 <Tac-Tics> but Haskell is so terse :-) the cost of reading a the first 40 lines is on the same order as reading in the whole sourcefile
00:16:13 <oerjan> if your import/export lists are 40 lines then the rest of the module certainly won't be...
00:18:28 <wli> I don't see why one would bother trying to make import/export lists do that.
00:21:24 <Tac-Tics> I would go to sleep, but the sooner I do that, the sooner I have to program in PHP
00:25:12 <OpenSpace> hello, I'm new to haskell, just to pick up some references to begin: is there any ide independent of .net studio so I can use it on linux to browse libraries, docs, debug, profile... easily?
00:25:54 <Tac-Tics> if there is, I might like to hear about it too
00:26:16 <OpenSpace> ok, thanks
00:27:25 <Sizur> shell+(any text editor)? there's a haskell plugin for eclipse
00:27:29 <eck> OpenSpace: not sure if this is what you are looking for, but there is a haskell mode for emacs and also a set of scripts for working with haskell in vim
00:27:33 <quicksilver> the only free IDE remotely comparably to visual studio is eclipse
00:27:41 <quicksilver> personally I use emacs, which is very powerful
00:27:44 <quicksilver> but it's different :)
00:27:51 <quicksilver> not a drop-in replacement by any means
00:28:25 <quicksilver> there's no haskell editor yet with intellisense-style code smarts, which is a real shame
00:28:29 <quicksilver> but people are working on that
00:29:00 <wli> What's intellisense?
00:29:11 <Sizur> shouldnt be hard to have a read ide for haskell. definitely not as hard as for perl ;)
00:29:22 <reffie> just use vi
00:29:43 <quicksilver> wli: type-aware code completion
00:29:56 <eck> omni-complete in vim is similar to intellisense
00:30:04 <Tac-Tics> wli: the devil to programmers ;-)
00:30:07 <quicksilver> I don't think it is
00:30:10 <Tac-Tics> I can't stand intellisense most of the time
00:30:13 <quicksilver> becaue it isn't type-aware
00:30:21 <flux> ocaml's tuareg-mode has an excellent compiler-assisted feature: you can point cursor at any expression and get its type
00:30:22 <quicksilver> that's the really clever part, if you do it right
00:30:32 <quicksilver> any text editor can do textual completion
00:30:36 <flux> my adventures with haskell would've fared better with that too ;)
00:30:43 <quicksilver> (dabbrev-expand or hippie-expand in emacs, say)
00:30:49 <flux> that is: not just top-level expressions, or "whole" expressions, but any subexpression also
00:31:09 <quicksilver> flux: yeah; such things are being worked on for emacs/haskell
00:31:17 <Tac-Tics> Haskell is the kind of language a Supersmart IDE would really speed up learning for
00:31:29 <Sizur> i'd love to be able to move to function definition by clicking on a function name
00:31:39 <quicksilver> although, conversely, it needs a supersmart IDE much less
00:31:48 <Tac-Tics> heh
00:31:53 <Sizur> how about ability to rewrite any function to it's lowest components
00:31:54 <quicksilver> java benefits so much from IDEs because it's so verbose
00:32:01 <flux> sizur, isn't there a TAGS-generator for haskell?
00:32:04 <Tac-Tics> The Wikipedia page for Haskell describes that really well
00:32:08 <quicksilver> a good IDE stops you having to keep writing boring boilerplate
00:32:24 <Tac-Tics> What makes Haskell so great makes it very inaccessible to beginners
00:32:35 <quicksilver> haskell is quite a lot less verbose, so this is less necessary
00:32:44 <quicksilver> but it would still be nice to have a msart editor for other reasons
00:32:50 <OpenSpace> plenty of things... I am going to learn haskell as java and c are not so abstract
00:32:53 <quicksilver> there is a TAGS generator
00:33:00 <Sizur> being less verbose, yet being more strict
00:33:50 <glguy> hasktags
00:33:54 <glguy> comes with ghc
00:34:07 <DRMacIver> I occasionally think automated in editor support for refactoring would be nice. :)
00:34:11 <DRMacIver> Not really needed, but nice.
00:34:46 <quicksilver> flux: I think the current version of shim can do types of subexpressions but I'm not sure
00:34:58 <Sizur> refactoring haskell code is a little different from other langs. can you come up with some generic refactorings?
00:35:16 <quicksilver> sure
00:35:18 <quicksilver> lifting out local subrotines
00:35:27 <quicksilver> even global rename is handy to have
00:35:39 <DRMacIver> Sizur: Extract expression, make local variable and rename still work as usual. Extract submodule. Lift/unlift lambdas.
00:35:44 <flux> how about this: converting a set of function arguments into a separate record
00:36:00 <flux> renaming functions, values
00:36:01 <quicksilver> yeah, tupling/untupling
00:36:06 <quicksilver> (of argments)
00:36:15 <flux> I was thinking named record, but I guess it's the same
00:36:15 <quicksilver> and return values, indeed
00:36:23 <DRMacIver> A lot of the really boilerplatey ones become totally unneccessary, sure, but there are still plenty of good ones.
00:36:24 <quicksilver> CPS transform
00:36:39 <Sizur> okey dokey, i'm down ;) there are plenty
00:36:48 <quicksilver> there is less of a need than java
00:36:51 <quicksilver> but still nice to have
00:37:02 <quicksilver> @where shim
00:37:02 <Tac-Tics> hey, what is the flag on cabal to allow overlapping definitions?
00:37:03 <lambdabot> http://shim.haskellco.de/trac/
00:37:16 <DRMacIver> Yeah, definitely. I don't really feel the lack as painful so much as think that its presence would be pleasant. :)
00:37:42 <DRMacIver> Whileas Java without automated refactoring makes me sad. :)
00:39:36 <quicksilver> another thing that the good java IDES help you do is navigate the stupendously huge standard library
00:39:44 <quicksilver> and, whilst our standard lib isn't so stupidly big yet
00:39:54 <quicksilver> it's starting to get quite big and that kind of thing would be nice
00:40:35 <osfameron> yeah!  I like the way IDE's help you learn a library.. sometimes it's clearer than reading just the docs
00:40:46 <matthew-_> yeah, a personal hoogle++ would be nice
00:41:01 <Tac-Tics> quicksilver, you seem to be a pretty solid member of this channel. What is your opinion on this. True/False: Haskellers are going to try to take over the world.
00:41:22 <quicksilver> world domination. it's the only goal worth striving for.
00:41:29 <Tac-Tics> cool!
00:41:44 <quicksilver> seriously I'm not sure 'haskellers' have any partcicular commonality of purpose
00:41:46 <matthew-_> quicksilver: you realise that Tac-Tics is a reporter for reuters right?
00:42:09 <quicksilver> matthew-_: all the better. My google vanity searches are really dull at the moment.:P
00:42:31 <quicksilver> but I think functional programming may be something whose time has finally (almost) come
00:42:34 <quicksilver> we'll see
00:43:15 <Pseudonym> Reuters will publish anything without checking it.
00:43:36 <Tac-Tics> What is Distribution.Setup and why don't I have it?
00:43:40 <Tac-Tics> grr
00:43:46 <matthew-_> where as murdock/fox will only publish stuff that's wrong
00:44:39 <wli> "Wrong" is not quite it.
00:44:52 <wli> There is deliberate disinformation to it.
00:45:10 <reffie> http://www.youtube.com/watch?v=VATmgtmR5o4
00:45:41 <Pseudonym> Oh, not Nessun Dorma.
00:45:43 <Pseudonym> Not again.
00:45:56 <matthew-_> yep. Anything which is the exact opposite to professional journalistic investigation
00:46:04 <Pseudonym> Did he ever do Au fond du temple saint?
00:46:25 <matthew-_> mind you, not much in the uk comes under good investigative journalism these days.
00:47:57 <xpika> does anyone here write templates in haskell?
00:51:50 <earthy> in what sense, xpika?
00:51:59 <Pseudonym> Phew.
00:52:12 <earthy> in the StringTemplate sense?
00:52:18 <earthy> or in the Template Haskell sense?
00:52:47 <quicksilver> I suspect xpika means in the "chunk of HTML with interpolating variables/loops" sense
00:52:52 <osfameron> quicksilver: true, some seem to bemoan the fact that haskell is not already massive, others want it to stay small
00:52:56 <earthy> the StringTemplate sense
00:53:19 <quicksilver> osfameron: fortunately, what they want (either camp) is not that likely to affect what actually happens ;)
00:53:48 <matthew-_> xpika: you can do that with the Chunks library which is on hackage
00:53:55 <matthew-_> though it is not StringTemplate
00:54:04 <glguy> way to go firefox... after failing to download adblock plus due to "download error" firefox kindly shut itself down
00:54:22 * earthy was playing with implementing StringTemplate actually
00:54:36 <matthew-_> firefox is pretty poor. there are cases where konqueror is much better
00:54:43 <earthy> the hard part there is understanding the StringTemplate syntax
00:54:48 <matthew-_> the only advantage to firefox is it's javascript engine
00:54:59 <matthew-_> damn, no apostrophy.
00:55:12 <osfameron> quicksilver: very true :-)
00:55:16 <matthew-_> and that's not how you spell apostrophe...
00:55:36 * earthy gives matthew a nice cup of hot, steaming coffee
00:55:38 <glguy> matthew-_: but it is how you spell it ;)
00:55:56 * matthew-_ chugs the coffee
00:56:05 * matthew-_ twitches slightly
01:00:11 <Pseudonym> OK, someone give me a polynomial-type expression involving exp x and tan x.
01:00:23 <wli> exp x * tan x
01:00:27 <Pseudonym> Like, say, (e^x)62 (tan x)^2
01:00:29 <Pseudonym> OK, good one.
01:00:45 <Pseudonym> Errr...
01:00:55 <Pseudonym> Actually, I think that one doesn't have an elementary integral.
01:00:56 <Pseudonym> Try again.
01:01:20 <wli> You want one with an elementary integral?
01:01:23 <wli> exp x + tan x then
01:01:35 <Pseudonym> tan x doesn't have an elementary integral.
01:01:43 <Pseudonym> No, I want one that's MORE complex than that.
01:01:53 <xpika> that chunks looks interesting but i was reffering to template haskell templates
01:01:54 <Pseudonym> tan x doesn't have an elementary integral, but tan^2 x does.
01:02:08 <Pseudonym> "Elementary" here meaning "expressible in terms of exp and tan".
01:02:11 <DRMacIver> Hm. Seeing data declarations that won't fit on my screen makes me twitch slightly.
01:02:14 <wli> tan x has integral ln(sec(x)) which is indeed elementary.
01:02:38 <Pseudonym> Interestingly, no.  "Elementary", here, means something specific.
01:02:52 <Pseudonym> e^(-x^2) has an integral in terms of erf().
01:02:53 <xpika> i think i want to write a patq
01:03:00 <DRMacIver> Pseudonym: Yes, and it includes logs. :)
01:03:25 <DRMacIver> The elementary functions are the closure of the rational functions under logarithmic and exponential extensions.
01:03:27 <wli> You're probably misreading it if it's standard literature; logarithms of such things are included in the standard definition.
01:03:27 <Pseudonym> DRMacIver: log, actually, isn't a problem.  But I haven't implemented the rational part yet.
01:03:57 <Pseudonym> Yes, logarithms are elementary by definition.
01:04:26 <DRMacIver> And compositions of elementary functions are elementary. Hence so is log(tan(x))
01:04:42 <Pseudonym> Here's an example that does work:
01:04:44 <Pseudonym> Integral[x^2*(e^x)^2] = (1/2*x^2 + 1/2*x + 1/4)*(e^x)^2 + Integral[0]
01:04:51 <Pseudonym> Note taht Integral[0] is, of course, a constant.
01:05:02 <Pseudonym> That bit isn't implemented yet either.
01:05:42 <wli> Pseudonym: What algorithm are you implementing?
01:05:43 <DRMacIver> Are you using one of the standard algorithms or doing this in an ad hoc way? :)
01:05:57 <Pseudonym> DRMacIver: Risch algorithm is less standard than you might think.
01:06:01 <Pseudonym> Most people use Risch-Norman.
01:06:36 <Pseudonym> Maxima only implements Risch-Norman, for example.
01:06:57 * DRMacIver doesn't know much about the computational side of the subject to be honest.
01:07:02 <wli> I'm not sure what the distinction between Risch and Risch-Norman is.
01:07:05 <Pseudonym> I'm just trying to invent some functions to throw at it.
01:07:24 <Pseudonym> wli: The full Risch algorithm can integrate anything that has an elementary integral, or prove that it can't.
01:07:35 <Pseudonym> Risch-Norman is faster, easier to implement, and can't quite handle everything.
01:07:37 <wli> And Risch-Norman?
01:07:51 <Pseudonym> So naturally I'm not interested.
01:07:57 <wli> No wonder I've always ignored Risch-Norman.
01:08:40 <Pseudonym> Anyway, has someone got a curly function?
01:08:49 <ivant> have anyone experience in making functional MP work?
01:09:19 <Pseudonym> I haven't tried nested stuff yet.  It should work.
01:09:43 <Pseudonym> Except that nested functions tend not to have elementary integrals.
01:10:02 <wli> exp(tan(x))*sec(x)^2
01:10:07 <reffie> when was the last time you cried
01:10:08 <Pseudonym> Can't handle sec yet.
01:10:15 <Pseudonym> I'
01:10:22 <Tac-Tics> What is GHC.Interactive?
01:10:25 <Pseudonym> I'd actually implement sec as tan using the half-angle formula.
01:10:40 <Pseudonym> But that requires rationals, and I haven't done that yet.
01:11:03 <Pseudonym> Got another one?
01:11:11 <DRMacIver> That's probably not such a good idea anyway.
01:11:17 <DRMacIver> Makes cancellations non-obvious.
01:11:37 <Pseudonym> When you have the structure theorem handy, cancellations become obvious.
01:11:43 <DRMacIver> ok. :)
01:11:47 <DRMacIver> sin^3(x) exp(cos x)
01:11:52 <Pseudonym> Don't have sin either.
01:11:53 <Pseudonym> Or cos.
01:11:55 <Pseudonym> Only tan.
01:11:57 <Tac-Tics> Yi/Boot.hs:25:28: Not in scope: data constructor `GHC.Interactive'
01:12:07 <Tac-Tics> what does that even mean?
01:12:17 <Tac-Tics> well, besides the obvious =-)
01:12:26 <DRMacIver> (1 + tan^2(x)) exp(tan x)
01:12:51 <Pseudonym> OK, let's try that one.
01:13:13 <DRMacIver> (Assuming I've got my maths right that should give exp(tan(x)). But my mental calculus is a bit rusty. :) )
01:13:29 <Pseudonym> Yes, it does.
01:13:45 <Pseudonym> But given that I haven't tried nested functions yet, it's a good test.
01:14:29 <DRMacIver> I assume you've tried things like x e^(x^2), etc?
01:15:07 <osfameron> eeek!  fundeps are obsolete!  an I never even understood what they were!
01:15:08 <Pseudonym> No, I've only just got it working properly. :-)
01:15:22 <reffie> they were fun
01:15:31 <reffie> they will be missed
01:15:34 <osfameron> the clue is in the name!
01:15:34 <DRMacIver> osfameron: That's ok. They've been replaced with something that looks nicer. :) (to me anyway)
01:15:59 <DRMacIver> (Not that I really understood them either. But I got the general concept)
01:16:30 <wli> I don't see why one should bother with Risch-Norman when it isn't 1973 anymore and regular Risch doesn't break down anywhere near as often.
01:19:24 <Pseudonym> Woo!
01:19:32 <Pseudonym> Integral[(tan x^2 + 1)*e^(tan x)] = e^(tan x) + Integral[0]
01:19:34 <Pseudonym> It works!
01:19:58 <Pseudonym> Unfortunately it takes about 10 mins to enter every example, because I have to build a set of field extensions by hand.
01:20:35 <DRMacIver> Ha
01:21:08 <Pseudonym> derivTETX = polynomialDeriv (fraction (polyx 2 <+> rone) rone *> polyx 1)
01:21:18 <Pseudonym> That's just the derivative operation for exp(tan x).
01:21:41 <Pseudonym> And the type declaration for that is...
01:21:48 <Pseudonym> derivTETX :: (Monomial m1, Monomial m2, Field f)
01:21:49 <Pseudonym>         => (RatPoly f m1 -> RatPoly f m1)
01:21:49 <Pseudonym>             -> Polynomial (RatPoly f m1) m2 -> Polynomial (RatPoly f m1) m2
01:21:58 <Pseudonym> Seems like I really need some code reuse.
01:23:24 <Pseudonym> Anyway, must away.
01:23:25 <Pseudonym> Nytol!
01:35:25 <aleator> Hey, what do you call foo f g x y = f (g x y) ?
01:36:07 <xerox> (.) . (.)
01:36:42 <TSC> @pl \f g x y -> f (g x y)
01:36:42 <lambdabot> (.) . (.)
01:36:54 <TSC> Or strange ASCII art
01:37:01 <xerox> (:.)
01:37:21 <xerox> Where the last row of dots tell you the number of arguments of the right function.
01:37:48 <xerox> Or was it (.:), (:.) makes a constructor.
01:38:19 <xerox> It also scales.
01:38:43 <xerox> ?. djinn type (.) . (.) . (.)
01:38:45 <lambdabot> f a b c d e = a (b c d e)
01:38:47 <xerox> ?. djinn type (.) . (.) . (.) . (.)
01:38:49 <lambdabot> f a b c d e f = a (b c d e f)
01:40:24 <aleator> i fear to as, does it have a name?
01:40:29 <aleator> ask
01:41:56 <xerox> If you want, 'c' :) http://hpaste.org/2143
01:43:29 <osfameron> can djinn scan arbitrary code libraries?
01:43:49 <xerox> djinn takes a type and returns a function, when it can.
01:43:54 <osfameron> i.e., could you pipe a call to it from your vim session and have it guess functions as you type the types?
01:44:38 <xerox> Yeah, dons has some code that calls GHCi and typifies all your functions, I guess you could use it backwards and functionize all your types XD
01:45:44 <osfameron> it would be a rather cool autocomplete...
01:46:04 <xerox> Be aware that it doesn't work with recursive types.
01:46:07 <osfameron> actually, I'd like something like SLIME for Haskell... but I guess ghci+vim is enough to be getting on with
01:46:18 <osfameron> ok
01:49:03 <quicksilver> osfameron: shim is "somethign liek slime" for haskell
01:49:10 <quicksilver> osfameron: it's not finished, though
01:49:19 <osfameron> cool, ta
01:51:48 <osfameron> I particularly like that shim works with vim and so doesn't require me to suffer pain with emacs
01:53:33 <osfameron> http://www.haskell.org/haskellwiki/IDEs links to http://shim.haskellco.de/trac/wiki which appears to be wrong
01:53:34 <lambdabot> Title: IDEs - HaskellWiki
01:53:53 <osfameron> google finds http://swik.net/shim which is more or less contentless
01:53:54 <lambdabot> Title: shim - SWiK
02:01:23 <osfameron> and broken
02:02:00 <osfameron> @where shim
02:02:00 <lambdabot> http://shim.haskellco.de/trac/
02:02:05 <osfameron> NO IT'S NOT
02:02:29 * osfameron gives up and reads http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/vim.html instead
02:02:32 <lambdabot> Title: Vim as a Haskell IDE, first steps, http://tinyurl.com/yvxl52
02:15:28 <araujo> morning
02:16:44 <Sizur> araujo: hi
02:17:19 <alexeevg> morning
02:17:35 <alexeevg> sort of morning
02:17:44 <arcatan> morning
02:20:21 <xpika> does anyone else find that the sugar template haskell allows you to write isnt particulary sweet
02:20:26 <araujo> hello, how it goes? :-)
02:20:54 <wli> I've never used TH.
02:20:55 <xpika> $(func "lajdslasdj
02:23:52 <alexeevg> xpika: I've never used TH, but in examples I've seen there often was $(keyword ....lots of stuff .......). It's debatable, but it can be good to see that you invoke a macro
02:27:16 <wli> If you can see that it's happening, it's no abstraction at all.
02:27:37 <quicksilver> well it violates referential transparency
02:27:43 <quicksilver> and alpha-conversion
02:27:56 <quicksilver> and everything else that is remotely sane about haskell
02:28:02 <quicksilver> so personally I'd rather see it :)
02:28:08 <quicksilver> with big read flashing warnings
02:28:14 <quicksilver> **THIS VIOLATES YOUR EXPECTATIONS**
02:29:49 <alexeevg> wli: every time you hide some details you get an abstraction.
02:30:43 <DRMacIver> It doesn't really violate referential transparency. It's just that you're operating on an expression of a different type thank you thought you were. :)
02:32:46 <quicksilver> DRMacIver: well referentially transparent at the meta-level gives you plenty of room to violate r.t. at the haskell level
02:32:58 <quicksilver> DRMacIver: and that is why I would be opposed to 'hiding' it so it looked like just hasell
02:33:13 <quicksilver> DRMacIver: however, doesn't runIO mean you violate r.t. even at the meta-level?
02:37:11 <quicksilver> ajb++ # knowing the answer to my monadplus ramblings
02:37:54 <DRMacIver> quicksilver: Sure. I agree that template Haskell shouldn't look like a function application. :) But you're right, I'd forgotten about runIO.
02:38:25 <DRMacIver> 'though I suppose compilation could be regarded as a function :: Source -> IO Program, so maybe that's ok... :)
02:39:22 <wli> You surely mean String -> [OpCode]
02:43:10 <quicksilver> wli: no it's doing IO at compile time
02:43:17 <quicksilver> wli: it's not a pure function at all
02:44:33 <wli> Pray tell, why is there IO done at compile-time?
02:44:51 <wli> Apart from the trivial instances.
02:45:45 <IvdSangen> quicksilver, why is compilation not a pure function?
02:46:13 <quicksilver> wli: because that is a TH functionality, which we are discussing
02:46:19 <quicksilver> IvdSangen: it is normally
02:46:28 <quicksilver> IvdSangen: it only isn't if you're using TH and its runIO ability
02:50:28 <IvdSangen> but, some source will always result in the same program right, so then it is a pure function
02:51:04 <quicksilver> IvdSangen: normally yes
02:51:06 <IvdSangen> wait, I am misunderstanding you
02:51:09 <quicksilver> IvdSangen: if you're using TH then no
02:51:23 <IvdSangen> I had the cases the other way around
02:51:24 <quicksilver> (well only if you use runIO)
02:52:51 <phobes> So a TH program can prompt a user "Hey, pick a number" during compilation?
02:54:32 <quicksilver> phobes: indeed it can
02:54:44 <quicksilver> I'm not claiming it's recommended in most cases :)
02:54:46 <quicksilver> but it's possible
02:55:15 <quicksilver> I can think of some excellent uses for it though, such as querying a live database
02:56:28 <quicksilver> to get a schema
02:56:34 <quicksilver> which then determines your types
02:56:48 <phobes> yes, there are probably many uses for that
02:57:13 <phobes> embedding something about the local configuration into the compiled code
02:57:50 <phobes> (I haven't looked much at TH yet)
02:58:27 <wli> Ultimately use cases that are worth anything should be taken out of there.
02:58:44 <quicksilver> wli: eh?
02:58:51 <quicksilver> wli: taken out of where? and put where?
03:01:18 <wli> Taken out of TH/runIO and integrated into some sort of proper language feature.
03:14:36 <quicksilver> wli: I don't really agree
03:14:51 <quicksilver> wli: I don't think haskell should get "real language features" doing that kind of metaprogramming
03:15:02 <quicksilver> even the current deriving support makes me feel pretty queasy
03:15:12 <quicksilver> I think metaprogramming should be in a cage with warning labels
03:15:15 <vincenz> =1
03:15:17 <vincenz> +1 even
03:15:17 <quicksilver> like a poisonous snake
03:15:26 <vincenz> unsafePerformMeta
03:15:52 <quicksilver> someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
03:16:05 <vincenz> reminds me of the movie "The fly"
03:16:41 <quicksilver> http://en.wikipedia.org/wiki/Metamorphosis_I
03:16:49 <quicksilver> like that but with a haskell theme :)
03:16:52 <wli> It's a simple program.
03:16:55 <vincenz> quicksilver: like the movie, the fly :)
03:16:59 <quicksilver> right
03:17:01 <vincenz> quicksilver: especially the unsafe part
03:17:07 <wli> First, let usage cases arise from metaprogramming facilities.
03:17:11 <quicksilver> I'd say becoming a fly was fairly unsafe
03:17:19 <Adamant> Liskell!
03:17:34 <wli> Second, figure out the most common use cases and package them up.
03:17:40 <Adamant> now if I can only sneak it past my hardened compiler....
03:18:16 <SamB_XP_> quicksilver: probably the most useful thing I've heard of is reading Objective C headers...
03:18:46 <osfameron> quicksilver: what's wrong with deriving?
03:19:08 <osfameron> it seems to avoid all the boilerplate like in Java where you have to implement your own hashcode for every class... yuck
03:20:00 <pjd> @remember quicksilver someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
03:20:01 <lambdabot> Done.
03:21:01 <SamB_XP_> osfameron: well, newtype deriving is ... you know, dangerous!
03:23:00 <quicksilver> osfameron: it breaks various sensible kinds of code equivalence
03:23:10 <quicksilver> osfameron: for example, deriving Show breaks alpha-conversion
03:23:55 <phobes> In a non-subtle way
03:23:58 <SamB_XP_> quasisane: huh?
03:24:01 <SamB_XP_> er.
03:24:04 <SamB_XP_> quicksilver: ?
03:24:35 <quicksilver> SamB_XP_: if you derive Show then, merely by renaming a type constructor, you change the semantics of your program
03:24:49 <SamB_XP_> quicksilver: oh, that
03:25:04 <SamB_XP_> quicksilver: well you should kind of expect THAT...
03:25:11 <quicksilver> yes, it's perfectly expected
03:25:22 <quicksilver> but it is a major violation of a law which FP languages are assumed to obey
03:25:26 <SamB_XP_> it's usually desired...
03:25:42 <SamB_XP_> you did change the part of your code that defined Show, after all...
03:25:53 <quicksilver> most people assume without thinking that in a high-level the language the names of stuff don't matter
03:25:58 <SamB_XP_> (for that type)
03:26:02 <quicksilver> and that renaming is a safe kind of re-factoring
03:26:23 <quicksilver> similarly, deriving Ord makes your code sensitive to the order of your constructors!
03:26:26 <quicksilver> that's OBSCENE!
03:26:26 <SamB_XP_> it isn't safe in C, you know...
03:26:28 <quicksilver> ;)
03:26:49 <quicksilver> off-hand I can't think of a law violated by deriving Eq, though
03:26:54 <matthew-_> but isn't it obvious that if you're outputting stuff and you change what you're outputting then you've got two different programs?
03:27:00 <quicksilver> matthew-_: yes it is
03:27:03 <matthew-_> or have I utterly misunderstood the point?
03:27:05 <quicksilver> matthew-_: all of this is obvious
03:27:11 <matthew-_> oh ok.
03:27:16 <quicksilver> but despite being obvious it's not really appreciated
03:27:21 <quicksilver> alpha-conversion is a lovely property
03:27:30 <quicksilver> giving it up without really thinking about it is nasty
03:27:40 <matthew-_> right. Personally I think it's not really appreciated that maths is man-made
03:27:48 <matthew-_> once we get past that issue...
03:27:50 <quicksilver> the ability to re-order constructors is such an obvious thing
03:27:56 <quicksilver> that many people would do it without thinking about it
03:28:03 <quicksilver> but it changes the semantics of your Ord and Binary instances
03:28:11 <SamB_XP_> whoaaa
03:28:13 <SamB_XP_> hold up!
03:28:15 <matthew-_> yeah, I don't think you should derive Binary
03:28:26 <SamB_XP_> you can't "deriving (Ord, Binary)"
03:28:42 <matthew-_> there's a script to generate Binary instances though
03:28:53 <SamB_XP_> and if you have some other specialer way to derive Binary you should know how dangerous it is
03:28:58 <quicksilver> true
03:28:59 <Japsu> Data.Derive can make Binary instances, too
03:29:11 <quicksilver> but people have advocated putting deriving Binary into ghc
03:29:22 <SamB_XP_> oh?
03:29:22 <quicksilver> and I'm not even particularly opposed to that idea
03:29:26 <SamB_XP_> I too.
03:29:28 <quicksilver> I'm just pointing out what you lose
03:29:29 <Japsu> cool
03:29:46 <quicksilver> I think the metaprogramming afforded by deriving is very useful
03:29:52 <SamB_XP_> my suggestion would be to port GHCi everywhere ;-)
03:29:53 <matthew-_> woe. Binary does not seem good enough yet for ghc
03:29:55 <quicksilver> but I just don't think that people are sufficiently clear about the tradeoff
03:30:48 <quicksilver> you can do some fairly surprising stuff just with Show
03:30:57 <quicksilver> Show gives you "almost-reflection"
03:31:00 <SamB_XP_> would you believe that struct field names in C actually affect whether two struct types are considered compatible?
03:31:06 <matthew-_> quicksilver: I'm sure I've said before that the fact that Ordering derives Ord scares me
03:31:34 <quicksilver> > let constr x = takeWhile (/=" ") . show in constr (Just 3)
03:31:35 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
03:31:44 <quicksilver> > let constr = takeWhile (/=" ") . show in constr (Just 3)
03:31:45 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
03:32:04 <quicksilver> > let constr = takeWhile (/=' ') . show in constr (Just 3)
03:32:06 <lambdabot>  "Just"
03:32:10 <quicksilver> sorry for the noise
03:32:25 <quicksilver> look at that! deriving Show gets you the ability to navigate down constructor trees
03:32:28 <quicksilver> (almost)
03:32:53 <matthew-_> only on the third attemp ;)
03:32:59 <quicksilver> :P
03:33:00 <osfameron> quicksilver: what's alpha conversion?
03:33:12 <quicksilver> osfameron: the ability to rename stuff without affecting semantics
03:33:29 <SamB_XP_> quicksilver: do you want us to add a mandatory "forfeiting" clause after "deriving" clauses?
03:33:32 <matthew-_> is that the same as "de brugn indexes of two programs are the same"
03:33:55 <quicksilver> matthew-_: that's more like "a way to prove alpha-conversion"
03:34:07 <matthew-_> right, but it's an iff between the two and not an if ?
03:34:31 * matthew-_ wishes his irc client did ligatures
03:34:35 <SamB_XP_> so you could have "deriving (Eq, Ord, Show) forfeiting (AlphaConversion, ...)"
03:35:02 <SamB_XP_> where ... is whatever you call the ability to reorder constructors willy-nilly
03:35:25 <quicksilver> SamB_XP_: no, not really :) I just want people to think about what they're losing when they do this.
03:35:30 <matthew-_> ReordingConstructorsWillyNilly
03:35:49 <SamB_XP_> quicksilver: wouldn't that make them at least wonder what they are giving up?
03:35:55 <quicksilver> yes, that's true
03:36:00 <matthew-_> quicksilver: Haskell is probably already unique in programming languages in its ability to make people think!
03:36:33 <SamB_XP_> I figured this was the best way to make people think about what they're losing ;-)
03:36:51 <SamB_XP_> of course, TH kinda messes the plan up...
03:37:21 <matthew-_> "deriving (Testosterone) forfeiting (Virility)"
03:37:57 <vincenz> deriving (Sex) forfeiting (Virginity)
03:38:04 <quicksilver> deriving (Satisfaction) forfeiting (Moral High Ground)
03:38:15 <SamB_XP_> quicksilver: umm...
03:38:29 <matthew-_> deriving (C) forfeiting (Life)
03:38:30 <SamB_XP_> at least say "Moral (High Ground)"
03:39:18 <SamB_XP_> deriving (C) risking (NasalDaemons)
03:39:32 <vincenz> deriving (C) into (Oblivion)
03:40:00 <matthew-_> deriving (C) forfeiting (TypeChecker)
03:40:15 <matthew-_> deriving (C++) forfeiting (TerminatingTypeChecker)
03:40:38 * matthew-_ stops before it goes /too far/
03:40:58 <vincenz> frustrations is what brings most people to this channel :P
03:41:56 <SamB_XP_> matthew-_: of course with C++ nasal daemons are even more likely
03:42:16 <SamB_XP_> there's so many more things to forget about in C++ :-(
03:43:51 * ihope__ ponders
03:44:34 <ihope__> deriving (BF) forfeiting
03:45:12 <ihope__> By analogy with "import everything", assuming I'm remembering the "import something" syntax correctly.
03:45:28 <SamB> ihope: hmm?
03:45:49 <ihope__> Would this be "deriving BF forfeiting everything"?
03:46:10 <SamB> hmm, that wasn't how I was thinking.
03:46:31 <ihope__> What were you thinking?
03:47:08 <SamB> hmm. I guess it sorta makes sense though.
03:47:11 <vincenz> ihope__: dangerous question
03:47:14 <SamB> in a wierd kind of way...
03:47:47 <SamB> but I'd rather put a (..) after "forfeiting", somehow ;-)
03:47:56 <ihope__> So, Ordering derives Ord? I'm guessing is equal to is equal to is equal to.
03:48:03 <SamB> by analogy with importing all constructors of a type or methods of a class...
03:48:14 <SamB> ihope__: yes
03:48:15 <ihope__> Indeed.
03:48:26 <SamB> > sort [LT,EQ,GT]
03:48:27 <lambdabot>  [LT,EQ,GT]
03:48:33 <osfameron> quicksilver: I see how Show is affected by renaming, but not how that affects semantics.  Unless you mean that someone later on orders the stringified result?
03:48:56 <SamB> osfameron: it certainly affects the semantics of Show!
03:49:03 <SamB> on that type
03:49:26 <osfameron> in that it outputs something different?  I'm not sure you would want it to do anything else?
03:49:26 <quicksilver> osfameron: well the semantics of a program which does "print (Just 3)"
03:49:37 <quicksilver> osfameron: I wouldn't want it to do anything different, really
03:49:43 <quicksilver> osfameron: but that *is* a semantic change
03:49:50 <quicksilver> and it was caused by 'mere' alpha-renaming
03:49:55 <SamB> for instance, if you also derive Read, and you've put some data in a file, you won't be able to read it out if you change the names in between...
03:49:56 <osfameron> yeah, I'd want it to output the string that can be fed back into ghci to produce it
03:49:59 <vincenz> quicksilver: alpha renaming applies to variables not constructor names
03:50:00 <quicksilver> and alpha-renaming is supposed to be semantically neutral
03:50:10 <quicksilver> vincenz: constructor names are symbols
03:50:14 <quicksilver> vincenz: I don't see the difference
03:50:21 <SamB> vincenz: an interesting point
03:50:22 <vincenz> quicksilver: they are symbols with semantical meaning
03:50:22 <quicksilver> vincenz: 'Just' is a function
03:50:35 <SamB> quicksilver: it's more than a function
03:50:41 <quicksilver> yes, I didn't say it wasn't
03:50:41 <vincenz> quicksilver: namely the meaning you placed on them by giving them a specific name
03:50:45 <quicksilver> but it *is* a function
03:50:57 <quicksilver> vincenz: I claim that is not true, in the absence of deriving Show
03:51:14 <quicksilver> vincenz: in the absence of metaprogramming a constructor's choice of name has *no* semantic significance
03:51:27 <quicksilver> and it would be perfectly safe to rename 'Just' to 'Some' globally
03:51:32 <quicksilver> if you preferred the ocaml name
03:51:37 <SamB> quicksilver: true
03:51:46 <SamB> however you can't DO global renames...
03:51:49 <quicksilver> I'd call that alpha-conversion
03:52:41 <SamB> quicksilver: did you know that it *isn't* safe to rename struct fields according to the C standard?
03:53:01 <quicksilver> I have some vague memory of some quirk along those lines
03:53:07 <quicksilver> I don't remmeber the details :)
03:53:14 <Eelis> SamB: not safe in what sense?
03:53:25 <SamB> I can only assume it's for the benefit of C interpreters...
03:53:53 <SamB> Eelis: in the sense of it affecting the compatability of two struct types
03:54:04 <Eelis> SamB: i see.
03:55:25 <Eelis> i think that was fixed in C++
03:55:39 <vincenz> quicksilver: so you're saying that "in the absence of IO, semantics is kept.  But IO is what is ruining your semantics"
03:55:58 <SamB> Eelis: "fixed", hmm?
03:56:38 <Eelis> SamB: "fixed" in the sense that names do not affect compatible-ness of POD structs
03:56:50 <SamB> hmm, apparantly even the struct tag affects the compatability of two struct types...
03:57:05 <SamB> (if any)
03:57:28 <quicksilver> vincenz: I don't think I'm saying that
03:57:34 <quicksilver> vincenz: IO has nothing to do with show?
03:57:49 <vincenz> quicksilver: hmm, point
03:57:58 <matthew-_> but now we get into bisimulation
03:58:02 <quicksilver> the culprit is deriving Show, quite simply
03:58:08 <vincenz> quicksilver: was trying to take a different look at it.
03:58:09 <matthew-_> if the show instances change but they're not observable
03:58:19 <quicksilver> it applies in the purely functional program "foo = show (Just 3)"
03:58:22 <matthew-_> then is it still Î±-compatible?
03:58:27 <vincenz> quicksilver: to see where the boundary lies
03:58:30 * quicksilver nods
03:58:32 <SamB> interestingly, the order of members in a union does not matter
03:58:52 <quicksilver> SamB: I'm not too fussed about that, since IMO different types shouldn't really ever be compatible
03:59:00 <quicksilver> SamB: you should actually be using the same type :)
03:59:08 <quicksilver> but C doesn't really get that concept very clearly
03:59:33 <SamB> perhaps what they are defining is whether "two" "types" count as the same type?
03:59:38 <quicksilver> in haskell data Module1.Foo = Foo Int and data Module2.Foo = Foo Int are, after all, totally different
03:59:41 * quicksilver nods
03:59:59 <vincenz> quicksilver: hmm, there's more than just constructor renaming
04:00:05 <vincenz> quicksilver: like newtypes with different names
04:00:15 <vincenz> but the same contents
04:01:07 <SamB> vincenz: huh?
04:01:21 <kfish> -fimplicit-extensionality
04:01:25 <vincenz> or maybe that's not correct, since you can only alpha-rename up to a name that isn't used.
04:01:35 <vincenz> still, trying to find out what the root essence is
04:02:14 <osfameron> quicksilver: you said in the absence of metaprogramming - I'd never thought of serialization as a type of metaprogramming before... but I guess it is
04:03:01 <SamB> osfameron: not serialization per-se, but the definition of it in terms of the type declaration...
04:03:34 <vincenz> quicksilver: btw, there are two separate issues at play
04:03:42 <vincenz> quicksilver: one is alpha-renaming, the other is constructor-reordering
04:04:12 <vincenz> quicksilver: for pure serialization, if you encode constructors as numbers, then alpha-renaming isn't an issue
04:11:33 <roconnor> data Nat = O
04:11:33 <roconnor>            | S Nat deriving (Prelude.Show)
04:11:41 <roconnor> Not in scope: type constructor or class `Show'
04:11:46 <roconnor> What's the problem?
04:11:47 <smashor> hello! i want to learn haskell and read some code in vim. I want to use tags like ctags in C, and I've heard something about hasktags which does the job for Haskell. How can i get it and how do i install / use it?
04:11:53 <vincenz> roconnor: drop the Prelude.
04:12:02 <roconnor> vincenz: prelude is imported qualified.
04:12:10 <vincenz> roconnor: classes are never qualified
04:12:12 <roconnor> import qualified Prelude
04:12:14 <roconnor> oh
04:12:22 <vincenz> that wouldn't work well, iirc
04:12:23 <roconnor> what?
04:12:54 <roconnor> same error :(
04:13:09 <vincenz> hmm
04:13:29 * roconnor hmmms
04:15:35 <roconnor> oh
04:15:37 <roconnor> formatting error
04:16:02 <roconnor> deriving must be on a new line or something
04:16:57 <scook0> smashor: I think hasktags ships with GHC ... it's on my system, and I never installed it specifically
04:17:33 <quicksilver> roconnor: deriving is part of layout, yes
04:17:49 <quicksilver> roconnor: at least, I think it is
04:17:51 <smashor> scook0: ouch... you're right.
04:18:24 <scook0> there's a short section in the manual: http://www.haskell.org/ghc/docs/latest/html/users_guide/utils.html
04:18:25 <lambdabot> Title: Chapter 10. Other Haskell utility programs, http://tinyurl.com/yttywz
04:18:36 <scook0> (never used it myself)
04:18:47 <roconnor> > Prelude.show (unsafeCoerce (NotH Prelude.undefined)::())
04:18:47 <roconnor> "Segmentation fault (core dumped)
04:18:49 <lambdabot>   Not in scope: data constructor `NotH'
04:19:00 <roconnor> I guess segfaulting here is fair.
04:19:34 <smashor> scook0: well, already found this page, but PBKAC... sorry for making so much noise!
04:19:43 <scook0> heh
04:19:52 <wli> I wonder when people started saying "segfault" instead of "dump core."
04:20:27 <scook0> that said, sometimes you get the opposite problem: stuff that ships with GHC gets split up by distro packagers
04:21:07 <scook0> wli: well, the segfault is the fundamental problem
04:21:33 <wli> I wrote a few utilities that have been ignored in favor of perl/etc. reimplementations.
04:22:23 <wli> Patchbombing mailing thingie, some trivial FPOS for splitting a diff into individual hunks, etc.
04:22:53 <roconnor> dependent inductive types don't extract from coq to haskell.
04:22:59 <roconnor> :(
04:23:12 <quicksilver> wli: I still know people who say 'tilt' :)
04:24:45 <roconnor> Tilt (core dumped)
04:28:44 <wli> The abbreviation "segfault" is kind of new, too.
04:29:30 <wli> ISTR "SIGSEGV" and other such things being said before that seems to have started going around.
04:38:48 <vincenz> http://wilk4.com/humor/humorm223.htm
04:38:49 <lambdabot> Title: Computer Sayings
04:40:32 <vincenz> Haha: A computer scientist is someone who, when told to "Go to Hell," sees the "go to," rather than the destination, as harmful.
04:41:44 <ibid> i know lots of people who prefer hell to heaven
04:41:50 <ibid> (because heaven is so dull)
04:43:19 <wli> Except for Linux programmers, who like the goto as well.
04:46:10 <roconnor> "To know recursion, you must first know recursion"
04:48:38 <vincenz> ibid: Yeah, heaven only has people that only had marital sex..
04:57:35 <xpika> whats the advantage of using data.stream over []?
04:59:01 <wli> Eternity singing hosannas with a bunch of jesus freaks and never having sex is a rather close approximation to Hell for me as well.
05:10:23 <quicksilver> xpika: it's mostly documentation, isn't it?
05:10:32 <quicksilver> xpika: just "Admitting" that you expect the stream to be infinite
05:10:44 <quicksilver> xpika: and not having to take care of an 'empty list' case you know can never happen
05:25:02 <alexeevg> ?where Data.Stream
05:25:02 <lambdabot> I know nothing about data.stream.
05:25:07 <alexeevg> ?where Stream
05:25:08 <lambdabot> I know nothing about stream.
05:25:12 <alexeevg> ?index Stream
05:25:12 <lambdabot> Network.Socket
05:25:19 <alexeevg> ?index Data.Stream
05:25:20 <lambdabot> bzzt
05:26:00 <gordo> Is it possible to create a new type class with no class function (i.e. empty where clause) mandating that the type of the class belongs to two or more classes as well?
05:28:27 <quicksilver> gordo: yes
05:28:43 <quicksilver> notice that the definition of the Num class includes an Eq context
05:28:49 <quicksilver> that mandates that all Nums must be Eqs
05:28:52 <quicksilver> you can do that same thing
05:29:16 <gordo> quicksilver: I should've thought about that...
05:29:19 <gordo> quicksilver: thx
05:30:05 <quicksilver> it doesn't free you from writing the instances, though
05:30:17 <quicksilver> even though the instances are empty you still have to write them :-/
05:31:00 <gordo> quicksilver: That's annoying...
05:32:01 <quicksilver> otherwise you'd just be talking about a 'typeclass synonym'
05:32:11 <quicksilver> typeclass synonyms would be a lovely thing to have, though
05:32:30 <quicksilver> and some people think they are a prerequisite for havbing a fine-grained class library
05:32:56 <matthew_-> who's read the "lightweight concurrency paper" ?
05:33:06 <quicksilver> I have but I can't remember much about it :)
05:33:29 <matthew_-> ahh, I've just been reading it. The HECs do look quite nice for running on bare metal
05:34:00 <gordo> quicksilver: thx, I'm skimming through the Hugs' Prelude...
05:34:01 <matthew_-> you could, with a little effort, I think, turn it into a quite nice microkernel
05:35:05 <quicksilver> yes
05:37:21 <gordo> quicksilver: In the Hugs' prelude Num I see no empty where clause for Num...
05:40:52 <quicksilver> gordo: no, Num isn't empty
05:41:09 <quicksilver> gordo: what I was saying though is that you *could* do the same thing Num does (Eq constraint) and leave the where clause empty
05:41:23 <quicksilver> gordo: it was just an example of a class which mandates another class
05:41:56 <roconnor> @bab de en Forschungsseminar Theoretische Informatik
05:41:57 <lambdabot>   Research seminar theoretical computer science
05:42:07 <gordo> quicksilver: Oh I see... so an empty where clase is legal... I thought it was not...
05:42:56 <matthew_-> oh no, I have many many empty classes. It's one way of getting the type checker to do real computation for you
05:43:27 <quicksilver> gordo: yes, empty where clauses are quite legal
05:43:39 <quicksilver> it's just a way of denoting collections of types in the loosest sense
05:44:07 <gordo> quicksilver: thx... it worked... I asked 'cos I remembered it wasn't legal and didn't even try...
05:52:23 <glen_quagmire> is there IEEE745 floating point number type in haskell?
05:53:13 <Saizan> ?type isIEEE
05:53:18 <lambdabot> forall a. (RealFloat a) => a -> Bool
05:53:23 <quicksilver> glen_quagmire: "sort of"
05:53:38 <SamB> > isIEEE (1.0 :: Double)
05:53:41 <lambdabot>  True
05:53:47 <quicksilver> glen_quagmire: technically the haskell semantics don't guarantee that kind of detail about the floating point numbers
05:54:01 <glen_quagmire> > 0.1
05:54:03 <lambdabot>  0.1
05:54:03 <quicksilver> glen_quagmire: in practice, all implementations I'm aware of do in fact use underlying machine floating point
05:54:14 <quicksilver> which is generally based on one IEEE standard or another
05:54:25 <SamB> glen_quagmire: if isIEEE returns true for a given type, it's supposed to be an IEEE-based type...
05:54:36 <glen_quagmire> how can I print 0.1 for real?   in python, 0.1 is printed as 0.10000000000000001
05:54:57 <SamB> if it fails to typecheck, you're not even dealing with a type in the right class to be one...
05:55:09 <quicksilver> of course there are fiddly details like some machines storing 64 bit numbers in memory and 80 bit in register
05:55:14 <pjd> glen_quagmire: in python?  use str instead of repr
05:55:37 <SamB> pjd: I think he wants the read . show identity...
05:55:39 <wli> Not so. Those are formatting issues. You have to issue the proper command for rounding as you want it to.
05:55:42 <quicksilver> which is technically not going to pass IEEE conformance I don't think
05:55:52 <SamB> for things that aren't NaN or infinity, anyway
05:55:55 <quicksilver> wli: he's looking for the command to 'not round' I think :)
05:55:57 <doserj> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html#v%3AshowFFloat
05:55:59 <lambdabot> http://tinyurl.com/yjng6j
05:56:01 <quicksilver> > toRational 0.1
05:56:03 <lambdabot>  3602879701896397%36028797018963968
05:56:04 <pjd> SamB: ah, right
05:56:11 <SamB> > show 0.1
05:56:11 <wli> Oh, read . show and he will break.
05:56:13 <lambdabot>  "0.1"
05:57:03 <pjd> glen_quagmire: i think Python's float repr() is a bit clever
05:57:20 <SamB> quicksilver: I don't think isIEEE indicates that the type implements an IEEE 754 single-precision or double-precision format...
05:57:29 <pjd> it figures out what the minimal decimal string is for the float value
05:57:43 <SamB> pjd: hmm...
05:57:46 <glen_quagmire> given a float, I want to print that in binary (being it 32bits or 64)
05:58:06 <quicksilver> SamB: no, but what I'm tryign to say is that if the implementation can at an arbitrary time depending on compilation details round from 80bit to 64bit
05:58:15 <quicksilver> SamB: then, that isn't IEEE 80-bit or IEEE 64-bit
05:58:15 <doserj> : floatToDigits
05:58:20 <quicksilver> SamB: but some unholy mess
05:58:22 <doserj> :t floatToDigits
05:58:25 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
05:58:31 <wli> quicksilver: Welcome to Intel.
05:58:39 <doserj> > floatToDigits 2 0.1
05:58:41 <lambdabot>  ([1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,...
05:58:46 <quicksilver> wli: right. I'm not claiming it's new. Just making the point.
05:58:46 <glen_quagmire> @index floatToDigits
05:58:47 <lambdabot> Numeric
05:58:57 <SamB> quicksilver: oh, that
05:59:11 <SamB> isn't that called -fexcess-precision?
05:59:27 <quicksilver> yes
05:59:31 <quicksilver> in ghc, at least
05:59:32 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3ARealFloat
05:59:34 <lambdabot> http://tinyurl.com/ovjef
05:59:43 <quicksilver> glen_quagmire: the details of the "parts" of a float number are there ^^
06:00:00 <quicksilver> decodeFloat is the important bit
06:00:08 <quicksilver> and floatRadix and floatDigits
06:00:20 <glen_quagmire> thanks. i gave up on reading "what every computer scientists shoudl know about floating point numbers"
06:00:20 <wli> Okay, let's get an eigensolver going.
06:00:36 <wli> Because this is far too much for me.
06:00:43 <doserj> "don't use them"?
06:00:45 <glen_quagmire> i was looking for some easy way to understand floating point numbers..possibly via programming
06:01:18 <quicksilver> programming languages tend to hide the details of IEEE
06:01:21 <wli> Let's see where I screwed up matvec.
06:01:26 <quicksilver> I can quite understand why
06:01:29 <quicksilver> the truth is ugly
06:01:30 <quicksilver> :)
06:02:21 <wli> matvec :: (Monad m, MArray a t m, Num t) => a (Int, Int) t -> a Int t -> m (a Int t)
06:04:57 <wli> Something subtle happens with typing.
06:06:15 <quicksilver> that's a strange type
06:06:22 <quicksilver> I'm not familiar really with the array typeclasses
06:06:39 <quicksilver> but I would have thought the monad only came in if you were updating in place?
06:07:00 <alexeevg> MArray is mutable
06:07:02 <Saizan> MArray is for Mutable
06:07:17 <quicksilver> ah
06:07:22 <wli> It's supposed to be mutable, just not mutated there.
06:08:49 <scook0> reading from an MArray still requires the monad, though
06:09:38 <quicksilver> yes, for sequencing reasons
06:09:47 <quicksilver> otherwise you'd need to take an immutable copy
06:09:53 <quicksilver> or have some clever copy-on-write semantics
06:10:02 <quicksilver> which would be possible, but not trivial to implement
06:10:17 <scook0> well, DiffArrays are COW
06:15:40 <EvilTerran> DiffArrays are sloooow
06:16:00 <quicksilver> someone said DiffArrays had a rather poor implementation
06:16:10 <quicksilver> but I have no personal knowledge of that
06:18:25 <wli> What should I do then? Try to do list-based linear algebra?
06:19:16 <quicksilver> no, I think MArrays is fine
06:19:23 <quicksilver> you should just find out what the problem was :)
06:19:35 <quicksilver> your type looked ok once I understood it correctly
06:24:40 <wli> It's some dumb issue getting things past the typechecker.
06:31:29 <alexeevg> wli: just curious, what is the problem with matvec?
06:32:11 <wli> My writing it stupidly or something.
06:32:55 <wli> The typechecker seems convinced that the types of the matrix' and vector's indices should coincide.
06:33:14 <quicksilver> paste some, if you like
06:39:48 <mrd> wli: where is the code
06:40:21 <mrd> you do "a (Int , Int) t" and "a Int  t" in the same type annotation
06:44:20 <HairyDude> @djinn Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:44:20 <lambdabot> Cannot parse command
06:44:42 <HairyDude> so Djinn doesn't grok classes?
06:44:50 <quicksilver> I don't think so, no
06:45:04 <quicksilver> djinn only groks a fairly small number of types
06:45:20 <quicksilver> not, for example, including lists
06:45:24 <HairyDude> ah
06:45:50 <balodja> looks like monad transformer for lists
06:46:58 <HairyDude> it's zipWithM
06:47:35 <esteban2> Cale: your prototipes helped a lot, i solved my problems.. thanks
06:48:13 <esteban2> and right now i'm having another one :S i'm going to try to solve it myself first
06:50:35 <Tac-Tics> @index Interactive
06:50:35 <lambdabot> bzzt
06:55:15 <quicksilver> :t zipWithM
06:55:21 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:55:24 <quicksilver> :t :t \f l1 l2 -> sequence $ zipWith ($) (map f l1) l2
06:55:27 <lambdabot> parse error on input `:'
06:55:31 <quicksilver> :t \f l1 l2 -> sequence $ zipWith ($) (map f l1) l2
06:55:31 <HairyDude> oh, it already exists?
06:55:34 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a2 -> a1 -> m a) -> [a2] -> [a1] -> m [a]
06:55:38 <quicksilver> yes, it's in Control.Monad
06:55:40 <HairyDude> ah
06:55:57 <quicksilver> I was just experimenting with rewriting it using zipWith ($) and map
06:56:03 <quicksilver> @pl \f l1 l2 -> sequence $ zipWith ($) (map f l1) l2
06:56:04 <lambdabot> (((sequence .) . zipWith id) .) . map
06:56:08 <esteban2>  >
06:56:39 <HairyDude> eugh, I hate sections of (.) :)
06:57:31 <quicksilver> but that was silly
06:57:37 <quicksilver> I can combine the zipwith and the map
06:57:54 <quicksilver> :t \f l1 l2 -> sequence . zipwith f $ l1 l2
06:57:57 <lambdabot> Not in scope: `zipwith'
06:58:01 <quicksilver> :t \f l1 l2 -> sequence . zipWith f $ l1 l2
06:58:04 <lambdabot>     Couldn't match expected type `[m a]'
06:58:04 <lambdabot>            against inferred type `[b] -> [c]'
06:58:20 <quicksilver> :t \f l1 l2 -> sequence $ zipWith f l1 l2
06:58:22 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a1 -> b -> m a) -> [a1] -> [b] -> m [a]
06:58:28 <quicksilver> @pl \f l1 l2 -> sequence $ zipWith f l1 l2
06:58:28 <lambdabot> ((sequence .) .) . zipWith
06:58:34 <quicksilver> nice
06:58:50 <quicksilver> @unpl ((sequence .).)
06:58:51 <lambdabot> (\ b e h -> sequence (b e h))
06:59:11 <quicksilver> the .).) part is really just composition for a three-arg function
06:59:15 <quicksilver> so it's not *that* scaray
07:00:57 <esteban2>  > length [1,2,3]
07:01:10 <quicksilver> esteban2: don't put the space before the >
07:01:15 <esteban2> > length [1,2,3]
07:01:16 <lambdabot>  3
07:01:24 <esteban2> > length ['1','2','3']
07:01:25 <lambdabot>  3
07:01:57 <esteban2> > tail [1,2,3]
07:01:59 <lambdabot>  [2,3]
07:02:04 <esteban2> > tail ['1','2','3']
07:02:06 <lambdabot>  "23"
07:08:06 <dino-> @seen shapr
07:08:07 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 7h 49m 37s ago.
07:16:03 <esteban2> > length "bla"
07:16:05 <lambdabot>  3
07:17:14 <earthy> > genericLength "bla"
07:17:16 <lambdabot>  3
07:17:30 <osfameron> genericLength ?
07:17:42 <int-e> @type genericLength
07:17:42 <sioraiocht> @t length
07:17:42 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:17:44 <lambdabot> forall b i. (Num i) => [b] -> i
07:17:47 <EvilTerran> heh
07:17:50 <int-e> @type length
07:17:51 <esteban2> hey
07:17:53 <lambdabot> forall a. [a] -> Int
07:17:53 <sioraiocht> @type length
07:17:55 <esteban2> paste it
07:17:55 <lambdabot> forall a. [a] -> Int
07:17:56 <esteban2> >paste
07:18:00 <esteban2> > paste
07:18:00 <lambdabot>   Not in scope: `paste'
07:18:02 <sioraiocht> @type genericLength
07:18:04 <lambdabot> forall b i. (Num i) => [b] -> i
07:18:11 <esteban2> how do i show that paste thing?
07:18:17 <EvilTerran> @paste
07:18:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:18:21 <sioraiocht> IMO, length should be genericLength
07:18:32 <EvilTerran> > -- is only for running haskell snippets
07:18:33 <lambdabot>   parse error on input `}'
07:18:35 <esteban2> sioraiocht, whys tht?
07:19:16 <sioraiocht> esteban2: length is in the standard prelude, genericLength isn't, and length is a better abstraction
07:19:25 <int-e> > length [1..2^32]
07:19:30 <lambdabot> Terminated
07:20:02 <sioraiocht> int-e: my problems, at least, have been what you do next with the value, not the overflow problem
07:20:29 <EvilTerran> same here
07:22:04 <EvilTerran> if i've got a function expecting an Integer, i don't want to have to sprinkle with fromIntegral or whatever 'til it works
07:22:22 <sioraiocht> EvilTerran: EXACTLY
07:22:29 <EvilTerran> ?type Int -> a
07:22:31 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
07:22:32 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
07:22:32 <lambdabot>  
07:22:34 <EvilTerran> er.
07:22:39 <EvilTerran> ?hoogle Int -> a
07:22:40 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
07:22:40 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
07:22:40 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
07:22:51 <EvilTerran> bah.
07:23:03 <sioraiocht> I had that problem writing functions to produce check numbers if IBAN account numbers
07:23:13 <togi> hi
07:23:21 <sioraiocht> hi togi
07:23:40 <togi> i'm having some problems with types
07:24:12 <EvilTerran> ?paste
07:24:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:24:13 <togi> i'm trying to do something like  1 / (length "foo")
07:24:19 <esteban2> whats the opposite of == ?
07:24:23 <togi> /=
07:24:27 <esteban2> oh thanks
07:24:32 <EvilTerran> ?type (/)
07:24:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:24:39 <EvilTerran> ?type length "foo"
07:24:39 <mauke> togi: Int doesn't support /
07:24:41 <lambdabot> Int
07:24:46 <togi> right
07:24:55 <togi> so i'm trying to make it into float
07:25:00 <togi> but how do i do that?
07:25:03 <mauke> > 1 / fromIntegral (length "foo")
07:25:04 <lambdabot>  0.3333333333333333
07:25:09 <togi> ah
07:25:12 <togi> thanks
07:25:23 <sioraiocht> > 1 / genericLength "foo"
07:25:25 <lambdabot>  0.3333333333333333
07:25:35 <togi> oooh
07:25:39 <togi> thanks guys!
07:25:50 <EvilTerran> that's a coincidence...
07:25:53 <mauke> > 1 % (length "foo")
07:25:55 <sioraiocht> EvilTerran: what were we saying again? h
07:25:55 <lambdabot>  1%3
07:26:07 <sioraiocht> mauke: you had to have the last word didn't you? =ppp
07:26:37 <quicksilver> > (1/genericLength "foo") :: Rational
07:26:39 <lambdabot>  1%3
07:27:55 <togi> haha, i think i'm in love with lambdabot :P
07:28:15 <roconnor> @vixen what do you think of togi?
07:28:16 <lambdabot> i dunno...
07:28:37 <roconnor> togi: better woo her some more.
07:30:03 <hpaste>  togi pasted "(no title)" at http://hpaste.org/2595
07:30:24 <mauke> why Float? :(
07:30:24 <togi> why isn't this working? :(
07:30:39 <togi> this code is not complete currently
07:30:39 <sioraiocht> togi: use Double instead of Flaot
07:30:41 <EvilTerran> what's happening?
07:30:44 <sioraiocht> *Float
07:30:49 <EvilTerran> or Rational?
07:31:03 <mauke> togi: Integer doesn't support /
07:31:31 <quicksilver> togi: (fromIntegral cnt)
07:31:32 <togi> but it's supposed to find out number of non-matching characters divided by the length of the string
07:31:45 <mauke> fromIntegral cnt / fromIntegral (length x)
07:31:55 <quicksilver> togi: and never ever use Float
07:32:01 <togi> ok :P
07:32:02 <quicksilver> Float is worse than Double in every way
07:32:09 <quicksilver> except memory consumption which nobody cares about
07:32:15 <quicksilver> (especially not if they're using haskell :P)
07:32:18 <sioraiocht> haha
07:32:25 <mauke> '| x == y  =' better written as '| otherwise ='
07:32:38 <roconnor> quicksilver: actually if you grok floating point, Float is useful.
07:32:49 <quicksilver> roconnor: in which circumstance?
07:33:06 <mauke> or even = loop xt yt (cnt + if x == y then 0 else 1)
07:33:12 <togi> ah!
07:33:33 <roconnor> quicksilver: I once saw that some root finding algorithm or something was much more stable with a combination of Float and Double than with just Float or just Double.
07:33:49 <roconnor> quicksilver: but I don't grok floating point, so I don't have any further details :(
07:34:26 <quicksilver> roconnor: ok. That's a rather rare circumstance
07:34:27 <sioraiocht> @type fromIntegral . length
07:34:29 <lambdabot> forall b a. (Num b) => [a] -> b
07:34:30 <EvilTerran> loop xt yt (cnt + 1 - fromEnum (x == y)) ;]
07:34:36 <togi> :P
07:34:41 <quicksilver> togi: I prefer your version to mauke's change
07:34:43 <wli> genericLength?
07:34:43 <EvilTerran> loop xt yt (cnt + fromEnum (x /= y)), even
07:34:48 <sioraiocht> @src genericLength
07:34:48 <lambdabot> genericLength []    = 0
07:34:48 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:34:55 <quicksilver> togi: I think two clauses is much easier to read than an embedded if
07:34:56 <roconnor> quicksilver: perhaps.  But I came away with the impression that it was generally useful for people who know what they are doing.
07:34:59 <EvilTerran> length = genericLength :: [a] -> Int
07:35:13 <quicksilver> roconnor: s/generally/occasionally in some special circumstances/ :)
07:35:16 <roconnor> quicksilver: ie those people who take advantage of the fact taht (a + b) - b) /= a
07:35:22 * quicksilver nods
07:35:39 <mauke> EvilTerran: that's what I'd do in C :-)
07:35:44 <esteban3> hey, can anyone have a look at this piece of code? what i'm basically trying to do is tell a function do something giving it a function, but i can't figure out how to generalize because 2 of those functions as parameters are String->Int and String->String
07:35:45 <roconnor> everyone else probably shouldn't be using floating point anyways.
07:36:01 <hpaste>  esteban3 pasted "functions as parameter" at http://hpaste.org/2596
07:36:16 * roconnor still thinks that a floating point licence makes a certain amount of sense.
07:36:22 <quicksilver> roconnor: well Double has the advantage of being moderately fast
07:36:30 <esteban3> so it only works with one of those functions, unless i change the type of parameters in func
07:36:30 <quicksilver> roconnor: I think that is a valid reason
07:36:35 <wli> roconnor: Programming license, even.
07:36:38 <quicksilver> roconnor: although it's admittedly not that common that you need speed
07:36:39 <EvilTerran> mauke, yeah, i guess that's my dynamically-typed-langauges side showing through
07:36:40 <roconnor> quicksilver: very quickly gives you the wrong answer :)
07:36:47 <roconnor> quicksilver: like programming in C :D
07:37:09 <roconnor> that being said, even I use it for optimising functions.
07:37:12 <sioraiocht> esteban3: why not func :: Show b => [a] -> (a -> b) -> [String]
07:37:15 <SamB> roconnor: depends on what you are doing
07:37:22 <roconnor> and I don't have a floating point licence.
07:37:36 <SamB> sometimes the wrong answer is okay
07:37:45 <esteban3> sioraiocht: if i do that in func, should i change the types in the first two functions as well?
07:37:56 <SamB> as long as you know how wrong it can be
07:38:24 <esteban3> i'm probably the newbiest in this room, btw
07:38:32 <sioraiocht> esteban3: you can't, because you compare x to Char, so the type of the input HAS to be a String
07:38:40 <sioraiocht> :t x == 'a'
07:38:43 <lambdabot> Not in scope: `x'
07:38:54 <Sizur> SamB: right answer with acceptable error margin
07:39:00 <mauke> :t \x -> x == 'a'
07:39:02 <lambdabot> Char -> Bool
07:39:02 <sioraiocht> :t let x = 'b' in x == 'a'
07:39:05 <lambdabot> Bool
07:39:05 <roconnor> SamB: of course if you are running a stock market, perhaps it isn't okay: http://www5.informatik.tu-muenchen.de/persons/huckle/Vancouv.pdf
07:39:12 <sioraiocht> wow, i'm RETARDED, lol
07:39:15 <sioraiocht> what mauke said
07:39:18 <roconnor> SamB: actually I don't know if that was a floating point issue.
07:40:17 <roconnor> but it was certainly a fraction rounding issue.
07:40:35 <esteban3> sioraiocht: so is there a way to generalize types?
07:40:52 <patc> hi all --- I know this is off topic, but does anoyone know of a good sml/ocaml tutorial?  Thx!
07:40:54 <sioraiocht> esteban3: not of the first two functions
07:41:06 <sioraiocht> and esteban3: I'm not sure why you'd want to
07:41:12 <roconnor> SamB: (re: as long as you know how wrong it can be) I have no idea how wrong the results from my optimizer are.
07:41:12 <esteban3> well this is the problem:
07:41:18 <Cale> esteban3: Sorry, just got here, generalise which types?
07:41:27 <esteban3> i'm going to explain what the problem is
07:41:29 <Cale> esteban3: There are polymorphic types in Haskell, of course.
07:41:34 <EvilTerran> patc, #sml and #ocaml probably do
07:41:45 <sioraiocht> Cale: http://hpaste.org/2596
07:42:53 <Cale> esteban3: By the way, this hasn't bitten you yet, but it's going to, so I'll warn you now -- it's best to have your editor convert tabs into spaces for you
07:42:54 <patc> it's taken a few mintutes for them to wak up - thanks
07:43:03 <sieni> patc: http://www.cs.cmu.edu/~rwh/smlbook/online.pdf
07:43:20 <esteban3> sinCons is a function that takes a string and returns the string without its vowels. sinVoc does the opposite of sinCons but it return its length. I have to make a function that given a list of strings and one of the first two functions, ir returns a list of any of the possible results of the first two functions..
07:43:26 <esteban3> http://hpaste.org/2596
07:44:03 <esteban3> but i can't figure out how to generalize the types
07:44:22 <osfameron> Cale: gah, yes, that was one of my worries about whitespace sensitivity (Even if haskell's is relatively pain-free)
07:44:22 <esteban3> i think that the type 'a' should be for this
07:45:22 <doserj> func::[String]->(String->a)->[a]
07:45:49 <Cale> hmm
07:45:58 <doserj> is a sensible type, but you code for func isn't...
07:46:01 <esteban3> i think i tried that, but didn't work
07:46:10 <EvilTerran> doserj, that looks like map to me
07:46:19 <EvilTerran> ?djinn [a] -> (a -> b) -> [b]
07:46:23 <lambdabot> -- f cannot be realized.
07:46:26 <EvilTerran> pah.
07:46:26 <doserj> i think that is what he wants
07:46:46 <Rebooted> I'm pretty sure this http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Not_all_Functions_in_Strict_Languages_are_Strict is wrong
07:46:48 <lambdabot> http://tinyurl.com/yxxgb8
07:46:59 <esteban3> ERROR file:C:\Documents and Settings\Administrador\Mis documentos\Paradigmas\a4.hs:16 - Inferred type is not general enough
07:47:00 <esteban3> *** Expression    : func
07:47:00 <esteban3> *** Expected type : [String] -> (String -> a) -> [a]
07:47:00 <esteban3> *** Inferred type : [String] -> (String -> Integer) -> [Integer]
07:47:12 <Cale> (Num a, Ord a) => [t] -> (t -> a) -> [String] ?
07:47:25 <EvilTerran> esteban, can you give an example of what func should be doing?
07:47:30 <esteban3> EvilTerran: ok
07:47:38 <EvilTerran> func sinCons ["foo","bar","baz"] = ???
07:47:39 <SamB> roconnor: I have one function that I have implemented with floating point that I really hope is always right ;-)
07:47:44 <EvilTerran> func sinVoc ["foo","bar","baz"] = ???
07:48:01 <doserj> esteban3, if you want func to work with both sinVoc and sinCons, than you cannot use "f x > 0"
07:48:22 <esteban3> func ["abc","cde"] sinCons = ["a","e"]
07:48:28 <Cale> func obviously can't take sinCons as a parameter because it'll compare the result of sinCons with 0, but that would be a string.
07:48:34 <esteban3> func ["abc","cde"] sinVoc = [2,2]
07:48:49 <EvilTerran> Cale, that's what i was thinking
07:49:02 <esteban3> yes, something else is wrong in that func
07:49:12 <quicksilver> Rebooted: which part of it is wrong?
07:49:17 <doserj> func = flip map
07:49:45 <esteban3> the problem is that the function as parameter that func receives can be string->int or string->string
07:50:26 <patc> sieni --- thanks exactly what I wanted !
07:50:38 <quicksilver> I think the problem might be that you are trying to look 'inside' the function in a way you can't do
07:50:43 <quicksilver> but then I'm not sure what you're trying to do
07:50:43 <EvilTerran> esteban3, as an incidental point, "is x a vowel?" can be quite succinctly written as (x `elem` "aeiou")
07:50:48 <sieni> patc: you're welcome :-)
07:50:58 <EvilTerran> i don't think it'd be quite as efficient, but it does look snazzy ;]
07:51:10 <Rebooted> quicksilver: I'm going to post something to the discussion page, i might be wrong though
07:51:11 <Cale> You could write a function which has the type  (Show a) => [t] -> (t -> a) -> (a -> Bool) -> [String]
07:51:40 <esteban3> hmmm..
07:51:52 <esteban3> brb..
07:51:58 <Rebooted> quicksilver: but ML has my behaviour, not the one in the article, and so does the language with 'error' in TAPL
07:52:00 <EvilTerran> actually, it would be just as efficient as what you've got there
07:52:29 <quicksilver> Rebooted: which behaviour are you talking about? the boxed text
07:52:31 <quicksilver> Rebooted:  ?
07:53:08 <EvilTerran> it might be less efficient than (case x of 'a' -> True; 'e' -> True; ...; _ -> False), though
07:53:53 <quicksilver> EvilTerran: it would be slightly less efficient even than what he has there, since `elem` "aeiou" has to navigate the list spine
07:54:06 <quicksilver> EvilTerran: although that's fairly efficient
07:54:06 <Rebooted> quicksilver: yes
07:54:17 <EvilTerran> okay. it'd still be O(n) in the number of vowels, tho ;]
07:54:30 <EvilTerran> while the case version could use a lookup table and be O(1)
07:54:47 <EvilTerran> ...not that the number of vowels is going to change very often :P
07:54:51 <quicksilver> Rebooted: it certainly looks correct as written, but of course most strict languages don't define a handy 'undefined'
07:55:17 <Cale> heh, because it's not so handy :)
07:55:21 <Rebooted> quicksilver: I don't think it has anything to do with strict languages being non-strict in function arguments, its that lambdas are normal forms
07:55:59 <quicksilver> Rebooted: functions aren't necessarily lambdas though
07:56:17 <quicksilver> you could write letrec inf_loop x = inf_loop x
07:56:21 <Rebooted> quicksilver: yes, and if it isn't, it will be evaluated
07:56:21 <quicksilver> and use that as 'undefined'
07:57:01 <quicksilver> hmph
07:57:14 <quicksilver> but lambda terms can be bottom
07:57:20 <Rebooted> quicksilver: wait a second, i'll write it
07:57:43 <Rebooted> quicksilver: yes, and if they are, then f _|_ = _|_, still i think
07:57:51 <quicksilver> Rebooted: no
07:57:56 <quicksilver> Rebooted: not in a strict language
07:58:07 <quicksilver> Rebooted: my inf_loop above is a lambda term
07:58:11 <quicksilver> Rebooted: and its bottom
07:59:05 <Rebooted> quicksilver: I don't think it is...
07:59:14 <Rebooted> quicksilver: inf_loop isn't
07:59:25 <Rebooted> quicksilver: inf_loop x is
08:01:36 <quicksilver> sure it's bottom?
08:01:41 <quicksilver> what other denotation could it have?
08:01:53 <quicksilver> remember it's supposed to be a function from Integer -> Bool
08:02:01 <quicksilver> what function do you think it is?
08:02:38 <quicksilver> of course it's worse in a strict untyped language, since you can actually have unterminating reduction sequences "at any type"
08:02:47 <quicksilver> since you don't have a notion of type to start with
08:02:56 <quicksilver> like \x . x x
08:03:09 <Rebooted> quicksilver: isn't infloop = \x -> _|_
08:03:33 <quicksilver> I'm talking about denotational semantics
08:03:48 <Tac-Work> Is there an easy way to find out given a particular Heirarchial Module what package(s) contain(s) it?
08:03:48 <quicksilver> in a strict language there isn't a _|_ in Bool
08:04:08 <quicksilver> so \x -> _|_ doesn't represent a function Integer -> Bool
08:04:34 <quicksilver> in a strict language you "try" to keep the bottoms away
08:04:49 <quicksilver> but, unless you're willing to restrict yourself to total functions, you can't keep them out of function types
08:04:57 <Rebooted> right
08:05:24 <Rebooted> i'm not that familiar with denonational semantics but i'm pretty sure the operational semantics suggested there is wrong
08:06:21 <Rebooted> they say const1 (undefined :: Integer) = _|_,  const1 (undefined :: Integer -> Bool) = 1
08:06:30 <quicksilver> well !> const1 (undefined :: Integer) doesn't make sense in "normal" strict langauges
08:06:48 <quicksilver> because "normal" strict languages don't have anything like (undefined :: Integer)
08:06:57 <quicksilver> some MLs have exceptions
08:07:09 <quicksilver> but I think that screws up their semantics doesn't it?
08:07:14 <Rebooted> yeah, the behaviour with exceptions is not the same
08:07:27 <Rebooted> neither is it with a language in TAPL, which has undefined
08:07:28 <quicksilver> so maybe what's confusing about the boxed example is exactly that
08:07:38 <quicksilver> that there aren't really languages like that
08:07:58 <quicksilver> the observations about manual thunking and () -> are important, though
08:08:04 <Rebooted> and if you use non-termination, then clearly both = _|_
08:08:21 <Rebooted> yeah, but i'm saying that isn't to do with types
08:09:03 <Rebooted> in an ML/Haskell-like language, isn't evaluation completely independent of type information anyway?
08:10:02 <quicksilver> yes, it is really
08:10:14 <quicksilver> it's just, as you correctly said earlier, that it stops at a lambda
08:10:14 <Rebooted> so it can't be right
08:10:24 <quicksilver> and of course only function-types can end up in that form
08:10:27 <Rebooted> but thats because lambda is a value
08:10:31 <Rebooted> yeah
08:10:38 <quicksilver> of your reduction sequence stops at a lambda you must have function type
08:10:46 <quicksilver> that'st he connection between reduction strategies and types
08:10:58 <quicksilver> an eager language will evaluate the parameters first
08:11:03 <quicksilver> but 'evaluate' stops at a lambda
08:11:06 <Pastorn> if i want to learn about algorithms, what should i read?
08:11:16 <quicksilver> meaning that an eager language will 'discover' any bottoms lukring in a non-function type
08:11:23 <Rebooted> but it doesn't mean the behaviour for _|_ : Int -> Int should change
08:11:24 <quicksilver> but it won't discover them in a function type
08:12:32 <sioraiocht> Pastorn: I'm a fan of http://www.amazon.com/Introduction-Theory-Computation-Second-Michael/dp/0534950973/ref=pd_bbs_sr_1/002-1235636-4606444?ie=UTF8&s=books&qid=1189091465&sr=8-1
08:12:36 <lambdabot> http://tinyurl.com/yo55du
08:13:47 <quicksilver> Rebooted: I think it would be good to haveyour thoughts on the discussion page
08:13:53 <quicksilver> Rebooted: this is a very fiddly area
08:14:15 <quicksilver> Rebooted: due to the slightly different concepts of strict, non-strict, lazy, eager, normal order, depth-first, etc.
08:14:38 <Rebooted> quicksliver: ok
08:16:14 <dons> ?users
08:16:14 <lambdabot> Maximum users seen in #haskell: 402, currently: 387 (96.3%), active: 20 (5.2%)
08:16:25 <quicksilver> @localtime dons
08:16:27 <lambdabot> Local time for dons is Thu Sep  6 08:15:15 2007
08:16:41 <quicksilver> eh
08:16:52 <quicksilver> dons \not \in .au :)
08:19:45 <dons> :)
08:21:36 <Cale> I wonder why Reddit's display of all new articles is so nondeterministic. It seems every time I refresh the page, I get a slightly different subset.
08:22:01 <niklasso> Any FreeBSD users here?
08:22:08 <shapr> Good morning #haskell!
08:23:13 <masak> good morning, shapr
08:25:16 <Nafai> Morning shapr!
08:26:58 <shapr> hej masak
08:27:03 <shapr> hiya Nafai
08:27:14 <shapr> What sort of nifty code are people working on today?
08:32:43 * shapr is hacking on SearchPath
08:33:12 <Rebooted> quicksilver: http://en.wikibooks.org/wiki/Talk:Haskell/Denotational_semantics
08:33:14 <osfameron> woss SEarchPath ?
08:33:50 <shapr> osfameron: It's something alexj wrote when he didn't like some of the shortcomings of cabal-install, http://searchpath.org/
08:33:51 <lambdabot> Title: SearchPath
08:33:54 <osfameron> Cale: different db slaves?  or deliberate shuffling to make it look "fresher" (this is $work's tactic on refresh of homepage)
08:34:10 <Cale> huh?
08:34:11 <nomeata> dcoutts: hi again. I got some build logs where Iâd like to hear your (or anyone elses in here) comment:
08:34:12 <osfameron> eeeek! "Searchpath does automatic import chasing across the Internet for Haskell modules."
08:34:18 <osfameron> 17:21 <Cale> I wonder why Reddit's display of all new articles is so nondeterministic. It seems every time I refresh the page, I get a slightly
08:34:18 <dcoutts> nomeata: ok
08:34:21 <nomeata> http://buildd.debian.org/fetch.cgi?pkg=gtk2hs;ver=0.9.12-1;arch=ia64;stamp=1189066042
08:34:22 <osfameron>              different subset.
08:34:23 <lambdabot> Title: buildd.debian.org: log of gtk2hs_0.9.12-1/ia64 received Thu Sep 6 08:07:22 2007, http://tinyurl.com/2ykhx6
08:34:24 <Cale> osfameron: ah
08:34:29 <nomeata> ehm. thatâs the only one :-)
08:34:46 <osfameron> that's quite scary.
08:35:10 <shapr> osfameron: If cabal-install allowed one to install from a local directory of darcs repos as well as from Hackage, SearchPath wouldn't be necessary.
08:35:47 <nomeata> dcoutts: most architectures went fine, though: http://buildd.debian.org/pkg.cgi?pkg=gtk2hs
08:35:48 <lambdabot> Title: buildd.debian.org: gtk2hs in the unstable wanna-build databases
08:35:56 <osfameron> yeah.  that's something that's only recently being addressed in CPAN I think
08:36:07 <shapr> The downside of searchpath is that it doesn't support any versioning, it just grabs the source files from the remote darcs repo and builds with those.
08:36:07 <dcoutts> nomeata: so the hsc2hs calls are failing with this odd error about file number 2
08:36:20 <quicksilver> Rebooted: nicely explained
08:36:43 <nomeata> dcoutts: yes, Iâve never seen such an error, though
08:36:43 <Rebooted> quicksilver: thanks
08:36:56 <shapr> osfameron: So if I could give cabal-install a list of darcs repos to fetch via http and then install them in the correct order, it'd be nicer than searchpath.
08:36:57 <quicksilver> Cale: care to look at rebooted's comments?
08:37:05 <shapr> osfameron: What do you think?
08:37:08 <dcoutts> nomeata: yeah, me neither, it's pretty odd looking
08:37:40 <dcoutts> nomeata: you'd need access to an ia64 box to debug it though, to run that failing command manually with -v
08:37:40 <nomeata> dcoutts: do you know if others sucessfully built gtk2hs on ia64?
08:38:02 <dcoutts> nomeata: I've built some haskell stuff on ia64 but not gtk2hs
08:38:26 <dcoutts> nomeata: I think older versions built on debian on ia64
08:38:30 <nomeata> dcoutts: maybe I can get you access on http://db.debian.org/machines.cgi?host=merulo, Iâd have to ask
08:38:32 <lambdabot> Title: Debian Project -- debian.org Developer Machines
08:39:21 <dcoutts> nomeata: you could see if 0.9.11 now fails where it previously worked, that'd show it was a platform bug
08:39:22 <Cale> quicksilver: hmm
08:39:27 <Cale> quicksilver: Which comments?
08:39:39 <Cale> quicksilver: The ones at the bottom of that talk page?
08:39:46 <quicksilver> yeah
08:40:01 <nomeata> dcoutts: failed as well, but for other reasons: http://buildd.debian.org/fetch.cgi?pkg=gtk2hs;ver=0.9.11-2;arch=ia64;stamp=1188526704
08:40:03 <lambdabot> Title: buildd.debian.org: log of gtk2hs_0.9.11-2/ia64 received Fri Aug 31 02:18:24 2007, http://tinyurl.com/2sq9gt
08:40:07 <dcoutts> nomeata: 0.9.10 built on ia64 apparently according to packages.debian.org
08:40:25 <Cale> Actually, there is a little problem with erasing types in Haskell -- you have to make sure to do the typeclass translation first.
08:40:41 <dcoutts> nomeata: ah yes, that bug.
08:40:57 <Cale> Which code actually gets compiled can depend on the types of things via typeclasses.
08:41:04 <nomeata> dcoutts: ah, earlier version has the same bug that we have now: http://buildd.debian.org/fetch.cgi?pkg=gtk2hs;ver=0.9.10.5-1;arch=ia64;stamp=1177305228
08:41:08 <lambdabot> Title: buildd.debian.org: log of gtk2hs_0.9.10.5-1/ia64 received Mon Apr 23 05:13:48 20 ..., http://tinyurl.com/2clpvj
08:41:12 <dons> wow. /another/ bank looking for FP people!
08:41:15 <nomeata> dcoutts: I canât find a sucessful build log, though.
08:41:34 <dcoutts> dons: aye, nice
08:41:53 <shapr> dons: Who is it this time?
08:41:58 <njbartlett> Hey, I'm an FP person looking for a bank :-)
08:41:59 <dons> for those who didn't see it, http://article.gmane.org/gmane.comp.lang.haskell.general/15549
08:42:01 <lambdabot> Title: Gmane -- Mail To News And Back Again
08:42:11 <dons> njbartlett: hehe.
08:42:12 * roconnor wonders if reddit comments should be downmodded in the context of the comment being responded to, or in the context of that and the topic article.
08:42:29 <dons> http://www.orgtel.com ?
08:42:31 <lambdabot> Title: Orgtel providers of recruitment solutions
08:43:01 <dcoutts> nomeata: you'd want to run the failing command with -v, probably another flag to keep the intermediate temp files and try and get a reproducible test case
08:43:07 <osfameron> shapr: sounds cool - I somehow got the idea that searchpath searched for random haskell files across the internet and installed them (which scared me :-)
08:43:09 <dcoutts> nomeata: not much fun.
08:43:16 <njbartlett> Interesting, I wonder what would constitute "proven experience of functional programming languages"
08:43:24 <dons> you wrote a haskell compiler?
08:43:30 <quicksilver> njbartlett: you have to supply a Coq proof of your experience
08:43:45 <nomeata> dcoutts: hmm. personally, Iâm not really interested enough at the moment. Maybe when someone complains...
08:44:23 <njbartlett> Darn, well that's me eliminated. Ho hum
08:46:45 <coffeemug> there has been no IronHaskell work, has there?
08:46:59 <coffeemug> ahh, there is H$
08:47:02 <coffeemug> H#
08:47:45 <coffeemug> not very clear how much work they've done though
08:48:44 <osfameron> ooo, if I did take a study break after contract in November, I could try a haskell compiler on parrot
08:50:44 <dons> so do we yet say: haskell is widely used in the finance industry? :)
08:51:16 <dons> where every lambda counts
08:51:20 <osfameron> ah, there's already a Jhc->Grin->Parrot compiler
08:51:21 <quicksilver> "haskell is used by some wide boys in the finance industry" -- Donald Bruce Stewart, a notorious Haskell Hippy
08:51:29 <dons> heh
08:52:29 <phobes> Haskell is largely Eurpoian, right?
08:52:49 <dons> i'm not so sure anymore.
08:52:52 <nomeata> dcoutts: the problem seems to have appeared in 0.9.10.5 (wasnât there in 0.9.10).
08:52:53 <shapr> phobes: About as much as C is largely South American, I think.
08:52:58 <dons> :)
08:53:36 <quicksilver> I've often thought Java was largely Indonesian
08:53:40 <phobes> shapr:  Is your point that Haskell is not in fact largely European, or that it's not a good question?
08:53:42 <coffeemug> ah
08:53:43 <quicksilver> fortunately, wikipedia backs me up on this point.
08:53:44 <patc> most of the people i've taked to about h are american (or canadian)
08:53:46 <coffeemug> google still sucks sometimes
08:53:48 <coffeemug> c-- for example
08:53:49 <quicksilver> http://en.wikipedia.org/wiki/Java_(island)
08:53:53 <coffeemug> returns nothing related to c--
08:53:57 <nomeata> phobes: Haskell is basically Swiss: Small, Efficient, and itâs fun to explore the higher parts.
08:54:02 <quicksilver> coffeemug: they hack in punctuation exceptions
08:54:14 <quicksilver> coffeemug: but only for members of the secret google international government
08:54:22 <quicksilver> coffeemug: which is why C# works
08:54:30 <dcoutts> nomeata: do you think that is due to platform changes or gtk2hs changes or ghc changes? soo many variables :-(
08:54:43 <dons> nomeata: lovely :)
08:54:44 <quicksilver> coffeemug: in general, though, google ignores punctuation or interprets it specially
08:55:04 <phobes> ya, is there a way around that?
08:55:09 <shapr> phobes: I think Haskell is a bit more academic in Europe and more commercial in North America.
08:55:11 <phobes> some kind of quoting mechanism?
08:55:19 <nomeata> dcoutts: no idea either
08:55:23 <phobes> shapr: ok, that agrees with my stereotype :)
08:55:40 <dons> you're more likely to get it in comp1A outside the US, than in, I think.
08:55:53 <dons> but you're more likely to get employed to write it in the US
08:55:55 <patc> Haskell is basically French - elegant, but large, and baroque ...
08:56:05 <coffeemug> yeah
08:56:07 <quicksilver> phobes: not that I've found, in a considerable amount of time wasted searching :)
08:56:13 <shapr> Hm, Haskell seems quite small to me.
08:56:16 <coffeemug> C-- should be a special case, damn it!
08:56:19 <phobes> quicksilver: annoying
08:56:39 <phobes> You'd think quotes would work...
08:56:49 <dons> shapr: like a go board: small, seemingly simple, but a lot of combinations..
08:56:54 <shapr> Very little of Haskell is nailed down such that you can't change it. If you really want to redefine stuff, you can.
08:56:57 <shapr> dons: Ooh, I like that.
08:57:06 <shapr> @quote rules of go
08:57:06 <lambdabot> No quotes for this person. It can only be attributed to human error.
08:57:49 * dons off to work making lambdas for the man. ciao!
08:57:53 <shapr> heh
08:58:23 <shapr> Let's see, how many commercial Haskell users here? dons, Lemmih, Igloo, shapr, SyntaxNinja, .. umm?
08:58:41 <dcoutts> dons: you've arrived then? how long have you been there now?
08:58:44 <esteban3> whats the difference?
08:58:50 <shapr> esteban3: Between what and what?
08:58:54 <dons> dcoutts: 4 days or so. today is day 2 at work
08:58:59 <esteban3> commercial haskell and some other version
08:59:01 <esteban3> free maybe
08:59:01 <dcoutts> dons: yay :-)
08:59:07 <dons> new address is dons@galois btw
08:59:11 <phobes> esteban: he means using it for commercial purpose
08:59:12 <dcoutts> right'o
08:59:16 <esteban3> oh..
08:59:18 <esteban3> well not me
08:59:24 <shapr> esteban3: Oh, I mean whether someone is making money doing Haskell.
08:59:28 <dons> the unsw one will redirect there
08:59:33 <esteban3> i didn't know there was haskell jobs
08:59:38 <shapr> esteban3: Yeah sure!
08:59:46 <dons> esteban3: http://article.gmane.org/gmane.comp.lang.haskell.general/15549 just this morning
08:59:46 <lambdabot> Title: Gmane -- Mail To News And Back Again
08:59:47 <pjd> @remember nomeata Haskell is basically Swiss: Small, Efficient, and itâs fun to explore the higher parts.
08:59:48 <lambdabot> Done.
08:59:50 <esteban3> as well as smalltalk?
08:59:52 * shapr hugs delYsid 
08:59:53 <phobes> esteban3:  There are five of them... see shapr's list
09:00:04 <dons> glguy
09:00:09 <shapr> andyjgill
09:00:22 <dons> heffalump, lennart
09:00:24 <shapr> All the peeps at Galois
09:00:27 <quicksilver> SPJ has a haskell-related job
09:00:29 <quicksilver> ;)
09:00:33 <quicksilver> so does JaffaCake
09:00:36 <esteban3> that must be cool
09:00:36 <shapr> Oh yeah, the Credit Suisse guys
09:00:40 <phobes> How many people are on SPJ's team ?
09:00:40 <shapr> and the Microsoft Research guys
09:00:49 <dons> that's just in channel
09:00:57 <esteban3> i find it cool to program in haskell, than any other language
09:01:05 <dons> if we count people outside, all the other banks, there's a few more.
09:01:09 <esteban3> even though im still learning
09:01:19 <dons> oh, stepcut, thetallguy
09:01:24 <shapr> Yeah, the bluespec guys, and I've heard rumors that Xilinx and Intel have some Haskell jobs.
09:01:31 <shapr> Right, the Linspire/Freespire guys.
09:02:04 <shapr> HAppS, of course..
09:02:13 <phobes> Who made HAppS?
09:02:29 <shapr> alexj, musasabi, lemmih, igloo, and me.
09:02:46 <phobes> working for whom?
09:02:50 <shapr> Working for alexj
09:02:56 <quicksilver> I never knew igloo was involved in HAppS
09:03:04 <phobes> You guys are stateside?
09:03:20 <quicksilver> not many people on SPJ's team that I know of
09:03:23 <shapr> phobes: .us, .dk, .uk, and a former worker .fi
09:03:26 <dcoutts> hia SyntaxNinja, Cabal-1.2.0 is out the door!
09:03:34 <quicksilver> at least, not many directly involved in haskell, at least
09:03:41 <dcoutts> SyntaxNinja: nominolo will be sending the announcement shortly
09:03:52 <quicksilver> obviously MSR is a big-ish place, but I think it's mainly SPJ, JaffaCake and the occasional intern
09:03:55 <quicksilver> who actually make ghc commits
09:04:07 <quicksilver> there will be other haskell-relevant research going on there, though
09:04:15 <quicksilver> and some will filter back into code at some point
09:04:46 <phobes> shapr:  What's the business model there?
09:05:00 * dons >>= work
09:05:08 <shapr> Oh, there are more Haskell jobs if you count some half research stuff like Oleg's employer and the Portland OS kernel group.
09:05:34 <quicksilver> is MT Chak employed by MSR, perhaps?
09:05:39 <shapr> phobes: Write something better than RoR, then implement lots of website ideas.
09:05:47 <shapr> quicksilver: Nah, he's unsw
09:05:50 <quicksilver> ah yes
09:05:51 <xerox> shapr: who's Oleg's employer? Was it the Oceanography stuff?
09:05:54 <shapr> quicksilver: and he's ChilliX on #haskell
09:05:58 <shapr> xerox: Yeah, the Navy
09:06:05 <quicksilver> shapr: oh, I never knew that :) live and learn
09:06:11 <njbartlett> There's some people using it at Google. of course they won't say how many or what for.
09:06:16 <xerox> shapr: ah-ha.
09:06:20 <quicksilver> njbartlett: "what for" is obvious
09:06:25 <quicksilver> njbartlett: world domination. What else.
09:06:25 <phobes> shapr:  So the idea is that once you get this great framework, you'll be able to do webstuff more efficiently than the other guys?  So HAppS is just a tool and not a product?
09:06:28 <shapr> I think some people at Yahoo is are using Haskell.
09:06:56 <jedai> What's the most mature DB link for haskell ? HSQL, HDBC or HaskellDB ?
09:07:05 <shapr> phobes: It's somewhat a product too. The benefit of giving it out to the community under the BSD3 license is that other people find bugs, contribute code, and generally improve the framework. Plus they can use it too :-)
09:07:13 <dcoutts> jedai: HDBC I think
09:07:30 <phobes> shapr:  Cool
09:07:55 <quicksilver> shapr: do you sell support? (not because I want some, but because I'm interested in your business model ;)
09:07:57 <jedai> dcoutts: It seems it's a more active project anyway
09:08:09 <shapr> quicksilver: I'm sure we would if someone wanted it.
09:08:20 * quicksilver nods
09:08:24 <quicksilver> I was just curious
09:08:34 <quicksilver> jedai: I have some misgivings about HDBC and lazy IO
09:08:41 <shapr> Several companies have investigated HAppS for a RoR replacement, not sure if anyone is seriously using it though.
09:08:54 <quicksilver> jedai: the author is aware of my misgivings and is, I think, seriously considering an alternative interface
09:09:09 <quicksilver> but certainly it has a responsive (and very smart) author
09:09:11 <quicksilver> and that helps a lot
09:09:21 <jedai> quicksilver: And what would you counsel inbetween ?
09:09:30 <quicksilver> using HDBC and being aware of the laziness issues :)
09:09:39 <jedai> Ok ^^
09:10:06 <quicksilver> CosmicRay: <--- there he is :)
09:10:14 <quicksilver> @seen CosmicRay
09:10:14 <lambdabot> CosmicRay is in #haskell-blah, #darcs and #haskell. I don't know when CosmicRay last spoke.
09:10:22 <quicksilver> not around for a bit though
09:10:27 <quicksilver> hopefully busy writing a superb haskell book
09:12:39 <esteban3> hey, whats supposed the "foldl" function to do? foldl (+) 1  [2,2,2]
09:12:47 <esteban3> > foldl (+) 1  [2,2,2]
09:12:49 <lambdabot>  7
09:12:54 <shapr> esteban3: Do you understand how map works?
09:12:57 <esteban3> yes
09:13:09 <esteban3> it applies the function given to each element of the list and return the list
09:13:13 <shapr> map takes a function that takes one input, and gives back one input.
09:13:21 <shapr> Fold takes a function that takes two inputs, and gives back one input.
09:13:33 <shapr> Can you guess what that does to the list?
09:13:43 <esteban3> i'm a bit confused
09:13:46 <EvilTerran> @src foldl
09:13:46 <lambdabot> foldl f z xs = lgo z xs
09:13:46 <lambdabot>     where lgo z []     =  z
09:13:46 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
09:13:53 <esteban3> what is the second parameter for?
09:13:56 * EvilTerran glares at lambdabot
09:14:00 <esteban3> > foldl (+) 3  [2,2,2]
09:14:01 <lambdabot>  9
09:14:20 <shapr> > foldl1 (+) [3,2,2,2]
09:14:21 <lambdabot>  9
09:14:22 <mauke> esteban3: the start value
09:14:37 <mauke> > foldl (+) 42 []
09:14:39 <lambdabot>  42
09:14:43 <esteban3> it seems to sum that parameter with the result of applying the function to all the elements.. ?
09:14:56 <esteban3> > foldl (+) 3  [1,1,1]
09:14:57 <lambdabot>  6
09:15:00 <EvilTerran> foldl (#) e [x0, x1, ..., xN] = ((...((e # x0) # x1) # ...) # xN)
09:15:14 <quicksilver> esteban3: because (+) takes two parameter it has to start somewhere
09:15:19 <quicksilver> that extra number gives it a start
09:15:28 <esteban3> ohh
09:15:40 <EvilTerran> foldl f e [] = e; foldl f e (x:xs) = foldl f (f e x) xs
09:15:42 <esteban3> > foldl (+) 1  [1,1,1]
09:15:43 <lambdabot>  4
09:15:45 <esteban3> i got it now
09:15:54 <esteban3> thanks
09:16:07 <EvilTerran> > foldl (++) "initial" ["one", "two", "three"]
09:16:09 <lambdabot>  "initialonetwothree"
09:16:24 <esteban3> i just thought that function would be of help to solve the problem of a function as a parameter.. i'm still stuck on it, trying to figure it out myself
09:16:35 <shapr> > scanl1 (+) [1,1,1]
09:16:36 <lambdabot>  [1,2,3]
09:16:51 <shapr> esteban3: What problem?
09:16:58 <esteban3> http://hpaste.org/2596?
09:17:23 <esteban3> this "func" function takes a function as a value, but this function can have different type of parameters
09:17:40 <EvilTerran> what is "f (x) >0" meant to do when f = sinCons?
09:18:01 <esteban3> func ["abc","cde"] sinCons = ["a","e"]
09:18:11 <esteban3> func ["abc","cde"] sinVoc = ["2","2"]
09:18:30 <esteban3> that func only works for the second function, but its wrong
09:18:43 <EvilTerran> that doesn't answer my question
09:20:23 <hpaste>  EvilTerran annotated "functions as parameter" with "how about this?" at http://hpaste.org/2596#a1
09:20:48 <esteban3> i dont understand your question :(
09:20:49 <esteban3> :S
09:20:54 <esteban3> let me see what you just posted
09:22:31 <EvilTerran> you can't have "f x > 0" when f returns a string
09:22:56 <esteban3> yeah.. thats one of the problems
09:23:16 <EvilTerran> i don't understand what that line's supposed to achieve, even when f returns a number
09:23:31 <esteban3> the result is a list
09:23:35 <EvilTerran> because it doesn't seem to do anything in the examples you're giving me
09:23:43 <Cale> EvilTerran: but that doesn't do the filtering
09:23:57 <Cale> It would need to take a second function parameter for the test.
09:24:37 <EvilTerran> or the parameter function could return Maybe a
09:24:47 <esteban3> with the example i posted you can do something like this: func ["abc","cde"] sinVoc
09:24:55 <esteban3> it returns ["2","2"]
09:25:23 <esteban3> but can't work for sinCons
09:25:54 <phobes> esteban3: Is this just for your understanding or is there something you're trying to accomplish?
09:26:11 <esteban3> understanding how to generalize parameters
09:26:15 <Cale> func ["abc","cde","aou"] sinVoc would give ["2","2"] again, right?
09:26:17 <esteban3> parameters types
09:26:21 <esteban3> yes
09:26:26 <esteban3> thats the number of not vowels
09:26:29 <esteban3> no no.
09:26:41 <esteban3> func ["abc","cde","aou"] sinVoc = [2,2,0]
09:26:52 <Cale> but then f x == 0 for that last one
09:26:57 <Cale> so the element is dropped
09:27:17 <esteban3> func ["abc","cde","aou"] sinCons = ["a","e","aou"]
09:27:33 <Cale> That testing for positivity is what prevents you from applying func with sinCons
09:27:46 <phobes> esteban3:  Writing down two functions of different types and then trying to come up with a third function that can use either of them seems backward to me.  Why not come up with something that makes sense that requires polymorphism and then see if you can implement it?
09:27:57 <esteban3> yeah.. but then how do i know that f(x) returned a value?
09:28:09 <Cale> f x is always going to be something
09:28:37 <esteban3> ok.. let me think a liltle bit more
09:28:45 <esteban3> i wouldn't want the answer right away
09:28:55 <Cale> I think you might actually just want the function map
09:29:12 <Cale> map sinCons ["abc","cde","aou"] = ["a","e","aou"]
09:29:22 <Cale> map sinVoc ["abc","cde","aou"] = [2,2,0]
09:29:44 <esteban3> ooo..
09:29:48 <Cale> map :: (a -> b) -> [a] -> [b]
09:29:56 <esteban3> i know how map works..
09:30:00 <esteban3> but didn't think of it
09:30:25 <Cale> It's this testing for greater than 0, and the show which is confusing everyone :)
09:31:01 <Cale> Those imply things about the types which make func less polymorphic.
09:31:04 <esteban3> Cale: that testing was meant to work only with the function that returns an int, then i needed to adapt it for the 2nd function.. and thats where i got the prob
09:31:26 <SyntaxNinja> w00t
09:31:53 <SyntaxNinja> dcoutts: w00h00 on the release!!
09:32:04 <dcoutts> @yarr!
09:32:05 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
09:32:15 <dcoutts> lambdabot: don't be so rude!
09:33:09 <mornfall> @yow
09:33:09 <lambdabot> My uncle Murray conquered Egypt in 53 B.C.  And I can prove it too!!
09:35:35 <hpaste>  (anonymous) annotated "functions as parameter" with "(no title)" at http://hpaste.org/2596#a2
09:35:50 <esteban3> now it works!
09:36:25 <DRMacIver> Anyone know anything about graph layout algorithms? I have a 6000 odd node graph (it's moderately sparse. Each node has O(10) attached edges). I'd like an algorithm that places these 'nicely' inside a square in a reasonable amount of time. :)
09:36:29 <EvilTerran> what about func f [], esteban3?
09:36:36 <DRMacIver> With the emphasis more on "reasonable amount of time" than "nicely"
09:37:06 <esteban3> EvilTerran: the func is not recursive.. so i didn't need it?
09:37:15 <esteban3> at least the definition of func isn't
09:37:24 <EvilTerran> i mean, why are you writing "func (x:xs) f = map f (x:xs)"?
09:37:33 <EvilTerran> that will break if anyone passes [] as the first parameter
09:37:43 <EvilTerran> why not "func xs f = map f xs"?
09:37:51 <esteban3> well yeah
09:37:55 <doserj> "func = flip map"
09:38:12 <doserj> I think, I said that a few hours ago... :)
09:38:15 <esteban3> map f xs.. thats not taking the head of the list??
09:39:45 <hpaste>  esteban3 annotated "functions as parameter" with "(no title)" at http://hpaste.org/2596#a3
09:40:36 <EvilTerran> "map f xs" is *not* taking the head of the list
09:40:44 <EvilTerran> that would be "map f (x:_)"
09:40:57 <esteban3> yeah, but what i did works too
09:40:59 <aleator> DRMacIver: How about the silly spring-inspired what was it name thingy?
09:41:01 <esteban3> what would the dif be?
09:41:25 <EvilTerran> yours is longer
09:41:35 <EvilTerran> and has different semantics wrt _|_s
09:41:47 <EvilTerran> (i think)
09:42:24 <EvilTerran> (but you don't need to worry about that just now)
09:42:30 <esteban3> too late lol
09:42:40 <esteban3> oh.. you mean about that semantic stuff?
09:42:46 <EvilTerran> yeah, the semantic stuff
09:42:52 <esteban3> well not really
09:42:53 * glguy mistakenly wore old contacts to work today... and can't see
09:42:59 <glguy> (his monitor)
09:43:33 <EvilTerran> i think the important bit is that dealing with the [] and the (:) cases seperately is repeating yourself
09:43:52 <EvilTerran> and what's great about functional programming is that you don't have to
09:43:59 <EvilTerran> (part of what's great)
09:44:18 <esteban3> well not really
09:44:21 <EvilTerran> because you can factor out the bit that involves repetition
09:44:29 <esteban3> i just pasted that... didn't mean to
09:44:51 <esteban3> i'll modify the code as you said
09:45:03 <EvilTerran> okay
09:45:07 <DRMacIver> aleator: Hm. I'm not sure I've tried that actually. It's worth a go.
09:45:58 <EvilTerran> esteban3, have you looked at any haskell tutorials?
09:46:03 <esteban3> yes
09:46:11 <esteban3> the yaht
09:46:16 <DRMacIver> Hm^2. It turns out that what I'm using is a *bad* implementation of the FR algorithm. Fixing that might help. :)
09:46:48 <esteban3> but some problems are just particular to me
09:47:51 <aleator> DRMacIver: Luckily you seem to know what I'm referring to. Can't remember what it is called.
09:49:17 <luqui> are there ghc win32 binary snapshots available?
09:50:56 <DRMacIver> aleator: I can't remember what it's formally called, but the graph library I'm using has a SpringLayout implementation and I assume it's just a simple force directed layout algorithm.
09:53:22 <Cale> I'm somewhat interested in symmetric graph drawing algorithms which would make use of a specified group action acting on the graph.
09:56:21 <DRMacIver> aleator: The spring layout results seem to be quite bad. It gets itself into a tangled mess with this many nodes.
09:56:35 * DRMacIver is going to try to fix the implementation of the algorithm he's currently using.
10:02:02 <aleator> DRMacIver: Might be. Tried fiddling with the parameters of it?
10:02:09 <shapr> SHAZAM!
10:02:18 * shapr turns into CAPTAIN LAMBDA!
10:04:08 <Adamant> S for S-K combinator, H for Haskell Curry, ...
10:04:14 <DRMacIver> aleator: I think for now I'm goign to try fixing this algorithm, 'cause I know it produces quite nice results. (And it would be a nice patch to submit back to the authors. :) )
10:05:40 <xerox> shapr: you might put this one on yout captain lambda suit! http://malde.org/~ketil/Hazard_lambda.svg
10:06:43 <aleator> DRMacIver: Cool. Is it in haskell?
10:09:09 <DRMacIver> Alas, no.
10:09:26 <DRMacIver> But #haskell is a more useful channel for academic programming questions than any of the others I'm in. ;)
10:11:06 <esteban3> so true
10:12:35 <dcoutts> Has everyone noticed the new Cabal 1.2 release ?
10:12:36 <dcoutts> http://www.haskell.org/pipermail/libraries/2007-September/008116.html
10:12:37 <lambdabot> Title: ANNOUNCE: Cabal 1.2.0 released, http://tinyurl.com/2xn5zu
10:12:47 <dcoutts> http://haskell.org/cabal/
10:12:47 <lambdabot> Title: The Haskell Cabal
10:13:43 <scandal> suppose you have a type:    data Foo = A Int | B String   are there any predefined functions that would allow checking for existence of an "B" in a list of Foo?  i want to do something sort of like this:    has_an_a :: [Foo] -> Bool  without having to writing a has_a_* for each of the possible choices for type Foo
10:15:11 <Cale> scandal: Well, you could use any, along with a predicate that tests if the thing is an A
10:15:24 <scandal> the specific context has to do with parsing optional command line argumentst where you want to provide a default value for an option the user did not specify
10:15:26 <Cale> any isA
10:16:11 <Cale> but you need isA and isB, which aren't provided automatically
10:16:41 <scandal> Cale: well, thats a lot better than what i have now ;)
10:16:54 <scandal> thanks!
10:17:57 <bos> dcoutts++!  cabal 1.2.0 FTW!
10:35:42 <esteban3> > any(>1) [1,2,3]
10:35:43 <lambdabot>  True
10:36:01 <tibbe> > all (>1) [1,2,3]
10:36:02 <lambdabot>  False
10:40:51 <dcoutts> bos: :-)
10:42:42 <esteban3> > all (True) [1>2,3>1]
10:42:43 <lambdabot>  Couldn't match expected type `a -> Bool'
10:42:49 <esteban3> > all (==True) [1>2,3>1]
10:42:50 <lambdabot>  False
10:42:55 <EvilTerran> @src and
10:42:56 <lambdabot> and   =  foldr (&&) True
10:43:07 <EvilTerran> @src all
10:43:07 <lambdabot> all p =  and . map p
10:43:29 <cognominal_> @src any
10:43:30 <lambdabot> any p =  or . map p
10:43:42 <EvilTerran> also, (==True) is the identity
10:45:24 <cognominal_> I have written a function that gives me the indices of the first element in a list that verify a predicate. It is using zip. Can someone give me a less convoluted way if doing that?
10:45:43 <mauke> @hoogle (a -> Bool) -> [a] -> Int
10:45:43 <oerjan> @src findIndex
10:45:44 <lambdabot> No matches, try a more general search
10:45:44 <lambdabot> findIndex p     = listToMaybe . findIndices p
10:45:56 <oerjan> @src findIndices
10:45:56 <mauke> @hoogle (a -> Bool) -> [a] -> [Int]
10:45:57 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
10:45:57 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
10:46:13 <oerjan> apparently not :)
10:46:53 <cognominal_> boy, I am amazed that just by giving a type, one can zero in to a given function
10:47:51 <oerjan> indeed, zip is a standard idiom for adding indices to lists, it seems
10:47:59 <EvilTerran> ?djinn a -> b -> ((a,b) -> c) -> c
10:48:00 <lambdabot> f a b c = c (a, b)
10:48:16 <EvilTerran> cognominal, yeah, it's magic :D
10:48:42 <cognominal_> I will like Haskell once I will get used to it
10:49:15 <cognominal_> there no better demo of the power of types
10:50:29 <cognominal_> @hoogle (a -> Bool) -> [a] -> Maybe Int
10:50:30 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
10:52:12 <cognominal_> @hoogle   [a] -> (a -> Bool) -> Maybe Int
10:52:13 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
10:52:46 <cognominal_> whoa, it even tries the permuations of type arguments
10:54:15 <oerjan> sometimes it tries a bit too hard.
10:56:02 <oerjan> @users
10:56:03 <lambdabot> Maximum users seen in #haskell: 402, currently: 382 (95.0%), active: 12 (3.1%)
10:57:16 <cognominal_> @help
10:57:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:02:34 <byorgey> hola, #haskell
11:12:12 <esteban3> hola?
11:12:31 <esteban3> hablas español?
11:12:52 <cognominal_> @djinn (a -> Bool) -> [a] -> [Int]
11:12:53 <lambdabot> -- f cannot be realized.
11:13:12 <oerjan> djinn doesn't do lists
11:13:15 <cognominal_> @djinn (a -> b) -> [a] -> [c]
11:13:16 <lambdabot> -- f cannot be realized.
11:13:28 <EvilTerran> @djinn can't do algebraic types at all
11:13:28 <cognominal_> thx oerjan
11:13:28 <lambdabot> -- f cannot be realized.
11:13:42 <oerjan> @djinn a -> Maybe a
11:13:43 <lambdabot> f = Just
11:13:49 <EvilTerran> um
11:13:55 <Saizan> EvilTerran: s/algebraic/recursive/
11:14:00 <EvilTerran> ah, that's the one.
11:14:10 <byorgey> esteban3: not really, although I'd like to learn =)
11:16:13 <esteban3> learning haskell is much easier than leanring spanish :P
11:16:31 <mauke> huhu
11:16:40 <esteban3> learning*
11:16:41 <luqui> Haskell is much more different from other programming languages than spanish is from other natural languages
11:16:47 <oerjan> that _may_ depend on the person learning, i expect
11:16:52 <Japsu> learning new programming languages in general is a lot easier than learning new natural languages
11:16:59 <mauke> new function for computing square roots!
11:17:11 <mauke> foo y = do { x <- get; put $ (x + y / x) / 2; return x }
11:17:20 <Japsu> !
11:17:25 <Japsu> which monad is that? :E
11:17:34 <mauke> the backwards time monad
11:17:41 <Japsu> wtf
11:17:45 <balodja> State, obviously
11:17:54 <Japsu> @type do { x <- get; put $ (x + y / x) / 2; return x }
11:17:57 <lambdabot> Not in scope: `y'
11:18:04 <Japsu> @type do { x <- get; put $ (x + ?y / x) / 2; return x }
11:18:06 <lambdabot> forall (m :: * -> *) a. (?y::a, Fractional a, MonadState a m) => m a
11:18:31 <roconnor> Wow, reddit trolls really do exist.  I didn't believe it before because I always blame ingroance for what looks like malice.
11:18:53 <roconnor> I guess I was pretty naive.
11:19:13 <dcoutts> dons: I'm just about to push the lazy bytestring representation change...
11:21:03 <EvirDrevo> mauke: That doesn't calculate the square root unless you iterate it.
11:21:42 <mauke> *Main> runPosi 1 (foo 2)
11:21:43 <mauke> (1.414213562373095,1.414213562373095)
11:21:50 <byorgey> roconnor: is ingroance kind of like inbreeding?  =)
11:22:13 <EvirDrevo> mauke: Ok, you tricked. What is runPosi?:-)
11:22:22 <EvirDrevo> runState (foo 9 >> foo 9 >> foo 9 >> foo 9) 1
11:22:22 <EvirDrevo> (3.023529411764706,3.00009155413138)
11:22:34 <mauke> EvirDrevo: evil magic
11:22:46 <roconnor> byorgey: more like ibnreeding
11:22:53 <byorgey> roconnor: ah, I see.
11:23:20 <EvilTerran> H1 D00DZ IM B1FF!!!1
11:23:50 <allbery_b> @keal
11:23:51 <lambdabot> are there full body recognition files for sorting art?
11:24:21 <roconnor> @. leet kool
11:24:22 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "leet"
11:24:33 <roconnor> @. eleet kool
11:24:34 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "eleet"
11:24:37 <roconnor> :(
11:24:43 <allbery_b> compose doesn't do edit distance foo
11:24:54 <allbery_b> @. elite keal
11:24:54 <lambdabot> wiLl it RetURn [] if /\/\AP GIVeS FpU inphInI73 1Is+?
11:25:47 <roconnor> @. elite kool
11:25:48 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "kool"
11:25:57 <roconnor> ah
11:26:19 <byorgey> @help keal
11:26:20 <lambdabot> keal. Talk like Keal
11:26:32 <roconnor> @unelite H1 D00DZ IM B1FF!!!1
11:26:32 <lambdabot> h1 D00DZ I/\/\ b1phph!!!1
11:27:02 <arcatan> @. unelite elite keal
11:27:03 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "unelite"
11:27:12 <EvilTerran> @help elite
11:27:12 <lambdabot> elite <phrase>. Translate English to elitespeak
11:28:55 <oerjan> @help unelite
11:28:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:29:07 <oklokok> > o
11:29:09 <lambdabot>   Not in scope: `o'
11:29:09 <oerjan> there isn't one, it is corrected back to elite
11:29:15 <roconnor> @. elite bab nl en Vertaal Engels naar elitespeak
11:29:15 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "bab"
11:29:21 <oklokok> @o=0
11:29:22 <lambdabot> Unknown command, try @list
11:29:26 <byorgey> translating from leetspeak to english is NP-complete
11:29:26 <oklokok> @o = 0
11:29:27 <lambdabot> Maybe you meant: offline oldwiki . v
11:29:33 <oklokok> hmm...
11:29:34 <roconnor> @. elite (bab nl en Vertaal Engels naar elitespeak)
11:29:34 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "(bab"
11:29:36 <oklokok> @let o = 0
11:29:42 <oklokok> > o
11:29:43 <lambdabot> Defined.
11:29:44 <lambdabot>  0
11:29:47 <oklokok> \o/
11:29:52 <roconnor> :D
11:30:10 <oerjan> @help babel
11:30:10 <shapr> mmm code!
11:30:11 <lambdabot> babel <lang1> <lang2> <phrase>.
11:30:11 <lambdabot> Translate a phrase in lang1 to lang2.
11:30:11 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
11:30:18 <roconnor> @. elite babel nl en Vertaal Engels naar elitespeak
11:30:19 <lambdabot> 7rAN5latE 3nGlIzh tO elI+e$P3Ax
11:30:27 <roconnor> w00t
11:30:38 <byorgey> awesome
11:32:00 <oklokok> what languages does it know?
11:32:16 <oklokok> @. elite finnish fi käännäpäs tämäkin
11:32:16 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "finnish"
11:32:28 <oerjan> oklokok: see above
11:32:33 <oklokok> hmm...
11:32:46 <oklokok> that can't really be the list if there's also "elite babel"
11:32:53 <oklokok> or?
11:32:57 <oklokok> whooops
11:32:59 <lambdabot> oklokok: Finnish was too hard to learn. /-:
11:33:10 <oklokok> :<
11:33:12 <Japsu> haha
11:33:22 <oerjan> that's the composition of two commands, @elite and @babel
11:33:34 <Japsu> lambdabot: mitÃ¤s vaikeeta suomessa muka on, ei taida tyhmÃ¤ botti vaan osata ;)
11:33:35 <oklokok> oerjan: i realized that
11:33:42 <oklokok> (oklokok) whooops <<< the sound of me realizing
11:33:55 <roconnor> @babel fi en mitÃ¤s vaikeeta suomessa muka on, ei taida tyhmÃ¤ botti vaan osata
11:33:56 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language fi not supported
11:34:01 <Japsu> ;D
11:34:19 <Japsu> "what's difficult with Finnish, I think the stupid bot just lacks the skill" ;)
11:34:21 <roconnor> @babel sw en mitÃ¤s vaikeeta suomessa muka on, ei taida tyhmÃ¤ botti vaan osata
11:34:22 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language sw not supported
11:34:28 <roconnor> @babel se en mitÃ¤s vaikeeta suomessa muka on, ei taida tyhmÃ¤ botti vaan osata
11:34:29 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language se not supported
11:34:30 <Japsu> Finnish isn't easily machine-translated
11:34:36 <Japsu> roconnor: it was "fi"...
11:34:49 <roconnor> Yeah, but I figured I could substitute sweedish :)
11:34:53 <Japsu> :DD
11:34:57 <Japsu> no, you can't ;D
11:35:00 <reffie> weed?
11:35:01 <roconnor> awww
11:35:02 <shapr> They're rather different!
11:35:16 <roconnor> but the countries are right next to each other
11:35:17 <Japsu> Swedish, Danish and Norwegian are all pretty close to each other, but Finnish is way different
11:35:21 <oklokok> swedish is much closer to english than finnish...
11:35:37 <shapr> it a something ? Finnish is, not knowing ? the bot ? ?
11:36:01 <allbery_b> finnish is more like hungarian than scandinavlian languages
11:36:05 <shapr> I'm not much better than lambdabot when reading Finnish.
11:36:07 <allbery_b> scaninavian even
11:36:11 <shapr> hah
11:36:14 <shapr> scandalavian!
11:36:17 <shapr> scannedinavian!
11:36:21 <allbery_b> (which at least share a common heritage with English)
11:36:23 <oklokok> @help
11:36:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:36:24 * allbery_b cannot type today
11:36:25 <allbery_b> feh
11:36:29 <oklokok> @list
11:36:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:37:27 <oklokok> @elite oko
11:37:28 <lambdabot> oxO
11:37:33 <oklokok> @. elite elite oko
11:37:33 <lambdabot> 0ko
11:37:48 <oklokok> @. . elite elite elite oko
11:37:48 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "e1itE"
11:37:51 <oklokok> hmm
11:37:56 <oklokok> @. elite . elite elite oko
11:37:57 <lambdabot> 0x0
11:38:29 <oklokok> @figlet figlet
11:38:29 <lambdabot> Couldn't run the figlet command.
11:38:32 <Vq^> @. eliete . elite elite mwmwm
11:38:33 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "eliete"
11:38:33 <oklokok> @figlet okoko
11:38:33 <lambdabot> Couldn't run the figlet command.
11:38:40 <Vq^> @. elite . elite elite mwmwm
11:38:41 <lambdabot> m\/\//\/\\/\//\/\
11:38:46 <luqui> can someone give me an interesting use example of mfix?
11:38:59 <qwr> @hoogle (Num a, RealFrac b) => a -> b
11:39:00 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
11:39:00 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
11:39:00 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
11:39:10 <oklokok> @unlambda ``ksk
11:39:10 <lambdabot>  fd:21: hClose: resource vanished (Broken pipe)
11:39:14 <oklokok> darn
11:40:17 <lambdabot> You break it, you buy it. You own me a new pipe.
11:40:37 <shapr> luqui: Have you read the mark jones paper about mfix and friends?
11:40:47 <Saizan> owe?
11:40:48 <luqui> shapr, no, i'll look
11:41:30 <shapr> luqui: Check out http://www.cse.ogi.edu/PacSoft/projects/rmb/mdo.pdf for some goodies.
11:41:39 <luqui> shapr: thanks
11:42:33 <lambdabot> Saizan: My spelling plugin must be broken.
11:43:41 <oklokok> owe
11:43:55 <oklokok> owe?
11:44:10 <shapr> uwe?
11:44:41 <shapr> luqui: If you want *lots* of goodies, check out http://leventerkok.googlepages.com/erkok-thesis.pdf
11:44:53 <shapr> "Value Recursion in Monadic Computations"
11:45:00 <luqui> excellent
11:45:23 <shapr> But the mark jones paper(s?) give the best explanation, imho.
11:48:00 <shapr> hej rickardg
11:48:48 <rickardg> hej
11:54:08 <esteban3> > foldl (+) 1 [1,2,3]
11:54:10 <lambdabot>  7
11:54:58 <esteban3> > (>1) 2
11:55:00 <lambdabot>  True
11:55:03 <esteban3> > (1>) 2
11:55:04 <lambdabot>  False
11:55:06 <byorgey> shapr: which mark jones paper is that?  the link you gave was Levent Erkok and John Launchbury.
11:55:31 <aFlag> does anyone know about that "real world haskell" book? Are they plaining publishing the first chapter any time soon?
11:55:54 <oklokok> > < >
11:55:54 <lambdabot>  Parse error
11:55:56 <oklokok> > 1 >
11:55:57 <lambdabot>   parse error on input `}'
11:56:00 <esteban3> hey, i have one question.. the same way i can do " (>1) 2 and (1>) 2", can this be done with a function?
11:56:02 <byorgey> aFlag: I haven't heard any news
11:56:03 <oklokok> hmm...
11:56:05 <oklokok> > (1 >)
11:56:06 <mrd> > (1 >)
11:56:08 <lambdabot>  <Integer -> Bool>
11:56:11 <lambdabot>  ghc: failed with error code 9
11:56:19 <mrd> erp
11:56:33 <byorgey> esteban3: yes, although not quite in the same way
11:56:37 <hpaste>  esteban3 pasted "max and min" at http://hpaste.org/2599
11:56:39 <Vulpyne> esteban3: Yes, it can be.
11:56:47 <oklokok> > (>) >
11:56:48 <lambdabot>   parse error on input `}'
11:56:52 <oklokok> > (>) (>)
11:56:52 <lambdabot>        add an instance declaration for (Ord (a -> a -> Bool))
11:56:52 <lambdabot>     In the expr...
11:56:56 <byorgey> esteban3: the (1>) sort of syntax only works for operators.
11:56:56 <esteban3> this function i just pasted works the other way around.. it should get max and min from a list
11:57:16 <mrd> > (maximum &&& minimum) [1,2,3,4]
11:57:18 <lambdabot>  (4,1)
11:57:34 <esteban3> well i'm trying to do that without other functions
11:57:37 <EvilTerran> what is this "f"?
11:57:47 <esteban3> f can be (>) or (<)
11:57:56 <esteban3> mom [1,2,3,4] (>) = 4
11:58:01 <esteban3> but it returns 1
11:58:09 <hpaste>  byorgey annotated "max and min" with "(no title)" at http://hpaste.org/2599#a1
11:58:10 <shapr> byorgey: Sorry, I got confused. I was thinking of "Functional Programming with Overloading and Higher-Order Polymorphism"
11:58:19 <mrd> maximumBy and minimumBy?
11:58:25 <esteban3> yes
11:58:29 <shapr> But I don't think that paper mentions value recursion anywhere.
11:58:34 <esteban3> but i dont want to use those functions
11:58:38 <doserj> > map (`elem`[1,2,3]) [1..10]
11:58:39 <lambdabot>  [True,True,True,False,False,False,False,False,False,False]
11:58:52 <mrd> @src maximumBy
11:58:53 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:58:59 <byorgey> esteban3: with a named function, you can just apply it to only one argument, like (f x)
11:59:08 <hpaste>  EvilTerran annotated "max and min" with "tidying" at http://hpaste.org/2599#a2
11:59:45 <esteban3> like (*3) 2
11:59:48 <EvilTerran> ah, beaten to the punch by byorgey there
11:59:49 <esteban3> > (*3) 2
11:59:51 <lambdabot>  6
12:00:07 <byorgey> esteban3: right, but * is an operator, so the syntax is different
12:00:19 <esteban3> oh
12:00:20 <byorgey> > div 7 2
12:00:21 <lambdabot>  3
12:00:24 <byorgey> > div 7
12:00:26 <lambdabot>  <Integer -> Integer>
12:00:48 <byorgey> esteban3: see, div 7 by itself is a function which takes an Integer and divides 7 by it
12:00:54 <oerjan> > (/ 7) 2
12:00:56 <lambdabot>  0.2857142857142857
12:01:13 <oklokok> ((\a -> a * 4) &&& (\a->a-3)) 5
12:01:14 <oerjan> > (/) 7 2
12:01:16 <lambdabot>  3.5
12:01:16 <oklokok> > ((\a -> a * 4) &&& (\a->a-3)) 5
12:01:17 <lambdabot>  (20,2)
12:01:19 <esteban3> yes
12:01:28 <reffie> http://bugzilla.gnome.org/show_bug.cgi?id=472370
12:01:31 <lambdabot> Title: Bug 472370 - crash in Movie Player: starting new mpeg (totem)
12:01:32 <reffie> look for "received SIGSEGV signal, RIP"
12:01:42 <mauke> old news is old
12:01:47 <esteban3> those functions that returns functions right?
12:01:59 <byorgey> esteban3: right.
12:02:18 <byorgey> esteban3: all multi-parameter functions in Haskell are really just single-parameter functions that return another function.
12:02:23 <EvilTerran> reffie, o.Ã³
12:02:45 <byorgey> esteban3: putting an operator with an argument in parentheses like that (for example (*3)) is called an "operator section".
12:03:13 <byorgey> esteban3: it's just a convenient way to partially apply an operator, but you could also write something like (*) 3
12:03:36 <EvilTerran> altho "flip (*) 3" would be more accurate here ;]
12:03:48 <byorgey> EvilTerran: I was just about to say that =)
12:03:49 <esteban3> well none of whats been posted works :(
12:04:34 <byorgey> esteban3: is it a syntax error, or it just gives incorrect results?
12:04:49 <esteban3> incorrect results
12:04:52 <esteban3> the same as what i did
12:04:55 <Toxaris> esteban3: I think you want (flip f x) instead of (f x)
12:05:05 <esteban3> flip is to change order of parameters??
12:05:11 <mauke> a.k.a. (`f` x)
12:05:20 <Toxaris> esteban3: yes
12:05:29 <EvilTerran> ?src flip
12:05:29 <lambdabot> flip f x y = f y x
12:06:19 <byorgey> esteban3: right, so flip f x is a way of partially applying f to its second parameter
12:06:57 <Toxaris> esteban3: and I think you want to use a different algorithm :)
12:07:29 <esteban3> first i wanna fix this
12:08:41 <byorgey> esteban3: as mauke pointed out, you can also make a named function (like f) into an "infix operator" (like +) by enclosing it in backquotes
12:08:48 <byorgey> > div 7 3
12:09:00 <lambdabot>  2
12:09:01 <byorgey> > 7 `div` 3
12:09:03 <lambdabot>  2
12:09:07 <esteban3> ohh
12:09:19 <byorgey> so then you can also express flip f x as (`f` x)
12:10:22 <byorgey> esteban3: conversely, you can change an infix operator into a prefix function by enclosing it in parens
12:10:27 <byorgey> > 5 + 7
12:10:28 <lambdabot>  12
12:10:31 <byorgey> > (+) 5 7
12:10:32 <lambdabot>  12
12:10:43 <esteban3> 1 `+` 1
12:10:45 <esteban3> > 1 `+` 1
12:10:45 <lambdabot>  Parse error
12:10:52 <esteban3> > `1`+ `1`
12:10:52 <lambdabot>  Parse error
12:10:54 <byorgey> + is already infix
12:10:56 <mauke> don't cross the streams!
12:11:10 <esteban3> > 1 `+` 1
12:11:10 <lambdabot>  Parse error
12:11:15 <esteban3> damn
12:11:24 <esteban3> > 1 + 1
12:11:25 <lambdabot>  2
12:11:31 <byorgey> esteban3: backquotes are for making prefix functions into infix, but + is already infix
12:11:41 <bos> @seen dcoutts
12:11:41 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 36m 39s ago.
12:11:52 <doserj> > let f = (+) in 1 `f` 1
12:11:53 <lambdabot>  2
12:11:55 <bos> dcoutts: is cabal 1.2 intended to work with ghc 6.6.1 as well as 6.8.1?
12:11:56 <esteban3> > 1 `mod` 2
12:11:57 <lambdabot>  1
12:12:24 <mauke> > 'o' `elem` "aeiou"
12:12:26 <lambdabot>  True
12:12:37 <esteban3> (elem) 'd' "abcde"
12:12:40 <esteban3> > (elem) 'd' "abcde"
12:12:41 <lambdabot>  True
12:13:02 <byorgey> esteban3: in that case you don't need the parens
12:13:08 <esteban3> why not?
12:13:08 <byorgey> > elem 'd' "abcde"
12:13:10 <lambdabot>  True
12:13:19 <mauke> > (sqrt) (2)
12:13:20 <esteban3> oh.. i didn't say anything :)
12:13:20 <lambdabot>  1.4142135623730951
12:16:19 <oerjan> > (2 `sqrt`)
12:16:21 <lambdabot>  1.4142135623730951
12:16:38 <oerjan> >:)
12:17:00 <doserj> that's a liberal interpretation of the standard :)
12:17:09 <mauke> s/liberal/awesome/
12:18:06 <doserj> > let (!) n = product [1..n] in (10!)
12:18:08 <lambdabot>  3628800
12:18:40 <oerjan> > let (n!) = product [1..n] in (10!)
12:18:41 <lambdabot>  Parse error in pattern
12:18:47 <oerjan> hmph
12:20:05 <Toxaris> > let (?) = 42 in (?)
12:20:06 <lambdabot>  42
12:20:34 <byorgey> > let (?) = 42 in 4 ? 5
12:20:35 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
12:20:35 <lambdabot>     In the expression:...
12:20:51 <b_jonas> try prefix?
12:21:29 <Toxaris> > let (?) = '!' in 'A' ? 'B'
12:21:29 <lambdabot>  Couldn't match expected type `Char -> Char -> t'
12:21:36 <Toxaris> as expected
12:22:34 <Cale> > let (!) = product . enumFromTo 1 in (10!)
12:22:36 <lambdabot>  3628800
12:22:40 <jedai> Toxaris: What would you like it to do ?
12:23:20 <Cale> > scanl (*) 1 [1..] !! 10
12:23:21 <lambdabot>  3628800
12:24:21 <byorgey> > fix ((1:) . zipWith (*) [1..]) !! 10
12:24:23 <lambdabot>  3628800
12:24:42 <Toxaris> jedai: I don't want anything, thank you :) I'm just happy to see nullary operators in Haskell for the first time thanks to someone pointing out unary operators, wich I wasn't aware of either
12:26:06 <jedai> Toxaris: Ok, I understand, but in fact it's just that you can affect anything to a symbol but you can't use it without putting it in parens :)
12:26:30 <jedai> > let (?) a b c = c in (?) 'A' 'B' 'C'
12:26:32 <lambdabot>  'C'
12:26:54 <mauke> <integral> GumbyBRAIN: Warning, the maths courses may be suspiciously close to real maths
12:26:57 <mauke> <GumbyBRAIN>  crack and weed.
12:27:01 <roconnor> > let (?) a b c = c in 'A' ? 'B' 'C'
12:27:02 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Char'
12:27:05 <mauke> (GumbyBRAIN is a markov bot)
12:27:10 <roconnor> > let (?) a b c = c in 'A' ? 'B' $ 'C'
12:27:12 <lambdabot>  'C'
12:27:19 <jedai> Toxaris: Except if it's binary and you use it as an operator or in a section (and the unary thing is a liberal interpretation of the section syntax)
12:27:30 <byorgey> roconnor: hehe, nice
12:27:44 <Toxaris> jedai: yeah, that's what I figured out
12:28:42 <jedai> > let (?) a b c = if a then b else c in False ? False $ True
12:28:43 <lambdabot>  True
12:28:52 <Toxaris> jedai: and given how non-operator-variables are treated in Haskell, it's clear that it must be this way, but that wasn't enough to make me realize that it actually is.
12:28:57 <jedai> Oh a ternary condition... ;-)
12:29:59 <shapr> byorgey: Do you know of other papers on value recursion?
12:33:00 <Toxaris> > let (?) f g x = if f x then g x else x in (even ? const 2) . (odd ? const 1) $ 13
12:33:02 <lambdabot>  1
12:35:33 <roconnor> > let (?) a b c = if a then b else c; let (|) = ($) in False ? False | True
12:35:34 <lambdabot>  Parse error
12:35:55 <jedai> roconnor: | is reserver
12:35:58 <jedai> roconnor: | is reserved
12:36:01 <roconnor> oh
12:36:23 <jedai> roconnor: beside you have too much lets
12:37:02 <oerjan> lastly, you would need to adjust fixities
12:37:07 <oerjan> er, wait
12:37:14 <jedai> > let (?) a b c = if a then b else c; (!) = ($) in True ? True ! False
12:37:16 <lambdabot>  True
12:37:21 <oerjan> no you don't
12:37:54 <byorgey> shapr: no...
12:38:04 <oerjan> > (0$0 `test`)
12:38:05 <lambdabot>   Not in scope: `test'
12:38:20 <oerjan> > (0$0 `foldr`)
12:38:21 <lambdabot>      The operator `foldr' [infixl 9] of a section
12:38:22 <lambdabot>         must have lower pre...
12:39:34 <oerjan> > (0$0 `?test`)
12:39:35 <lambdabot>  Parse error
12:39:50 <oerjan> :t (`?test`)
12:39:52 <lambdabot> parse error on input `?test'
12:43:28 <oklokok> :t o
12:43:30 <lambdabot> Not in scope: `o'
12:43:35 <oklokok> :<
12:43:48 <oklokok> > o
12:43:49 <lambdabot>  0
12:43:53 <byorgey> :t L.o
12:43:55 <lambdabot> Couldn't find qualified module.
12:44:01 <oklokok> :t "u"
12:44:03 <lambdabot> [Char]
12:44:31 <byorgey> oklokok: I think the evaluation plugin and the type-inference plugin don't talk to one another.
12:49:12 <mornfall> is this supposed to work?  filterM doesFileExist =<< getDirectoryContents backups -- or i am doing something wrong?
12:49:26 <oerjan> :t filterM
12:49:29 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:50:04 <oerjan> :t getDirectoryContents
12:50:06 <lambdabot> Not in scope: `getDirectoryContents'
12:50:23 <oerjan> @hoogle getDirectoryContents
12:50:24 <lambdabot> Directory.getDirectoryContents :: FilePath -> IO [FilePath]
12:50:41 <oerjan> @hoogle doesFileExist
12:50:41 <mornfall> well, it typechecks, but it gives empty list
12:50:42 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
12:50:51 <mornfall> and the dir is not empty
12:51:55 <mnu> is there a library with which I can write images by coords and a color?
12:52:47 <mornfall> oh
12:52:48 <mornfall> OH
12:52:52 <mornfall> it's so obvious
12:53:08 <oerjan> mornfall: i think getDirectoryContents only gives filename parts
12:53:32 <mornfall>   backups <- filterM (doesFileExist . (backup++)) =<< getDirectoryContents backup
12:53:35 <mornfall> indeed
12:53:58 <mornfall> or better
12:54:00 <mornfall> from the other end
12:59:30 <ketil> Evening!  Any idea what "parse error in doc string: [haddock: EOF token" means?
13:00:19 <sorear> It means you have an unbalanced ' or / in your haddock comment.
13:00:46 <ketil> Ah.  No slashes, eh?
13:01:08 <ketil> Grazie!
13:02:44 <CosmicRay> slashes are for bolding, iirc
13:02:55 <CosmicRay> {- | This is a /really/ cool function -}
13:03:07 <ibid> slashes are for italics
13:03:11 <ketil> (Usually slanting/italicizing but hey)
13:03:14 <ibid> asterisks are fold bolding
13:03:20 <ibid> for
13:03:22 <sorear> I think it's italics, but I really can't tell the difference
13:03:25 <CosmicRay> oo, fold bolding, sounds fun ;-)
13:03:39 <ketil> Anyway - I'm missing link destinations for a goodly amount of stuff - any way out?
13:03:39 <ibid> at least in common nettish :)
13:03:46 <ibid> dunno about haddock
13:03:48 <sorear> ketil: <> ?
13:03:54 <ketil> I.e. bytestring, etc.
13:03:57 <CosmicRay> well, we are talking about haddock ;-)
13:04:04 <ibid> yeah, i just jumped in :)
13:04:10 <ibid> read the backlog after
13:04:16 <ketil> Let's just say it's for emphasis.
13:04:44 <ibid> but anyway, i cannot read /stuff/ as anything other than italics, in plain text
13:10:36 <roconnor> http://tools.ietf.org/html/rfc1896
13:10:38 <lambdabot> Title: RFC 1896 The text/enriched MIME Content-type
13:11:45 <roconnor> oh, nevermind
13:11:57 <roconnor> I thought it defined things like *foo* and /bar/
13:12:51 <nominolo> @seen syntaxninja
13:12:52 <lambdabot> syntaxninja is in #haskell, #haskell-blah and #haskell-soc. I last heard syntaxninja speak 3h 40m 58s ago.
13:15:35 <esteban3> :src (>)
13:15:41 <esteban3> > src (>)
13:15:41 <lambdabot>   Not in scope: `src'
13:15:51 <esteban3> how do i see a src?
13:15:53 <nominolo> @src (>)
13:15:53 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
13:15:56 <esteban3> thanks
13:16:38 <ketil> Thanks for the help, people, and good night.
13:16:46 <nominolo> esteban3, i think only :t is special-cased
13:17:29 <esteban3> > flip (>) 2 3
13:17:30 <lambdabot>  True
13:17:38 <esteban3> > flip 2 > 3
13:17:38 <lambdabot>   add an instance declaration for (Num (b -> a -> c))
13:17:49 <esteban3> > flip 2 + 3
13:17:50 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
13:17:59 <esteban3> > flip (+) 3 / 2
13:18:00 <lambdabot>   add an instance declaration for (Fractional (a -> a))
13:18:00 <lambdabot>     In the expression...
13:18:01 <nominolo> > flip $ 2 + 3
13:18:02 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
13:18:09 <sioraiocht> :t (2+3)
13:18:11 <nominolo> oh, sure
13:18:11 <lambdabot> forall t. (Num t) => t
13:18:19 <sioraiocht> :t flip
13:18:21 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:18:49 <esteban3> what if i do a flip to a function thats (int->int->bool) ?
13:18:51 <nominolo> > (flip (-)) 4 5
13:18:53 <lambdabot>  1
13:19:15 <sioraiocht> > flip (>) 4 5
13:19:16 <lambdabot>  True
13:19:17 <sioraiocht> you mean like that?
13:19:19 <sioraiocht> it swaps the args..
13:19:26 <sioraiocht> :t (flip (>))
13:19:28 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:19:29 <sioraiocht> the type would look the same, though
13:19:47 <esteban3> here: http://hpaste.org/2587 i still have the problem of this function thats doing the opposite action
13:20:10 <esteban3> i was told flip would change the params
13:20:33 <nominolo> esteban3, (flip f x)
13:20:41 <nominolo> instead of (f x)
13:20:49 <sioraiocht> :t any
13:20:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:21:01 <nominolo> you don't need the parens around the x btw
13:21:05 <sioraiocht> > any (>5) [1,2,4]
13:21:06 <lambdabot>  False
13:21:10 <sioraiocht> > any (>5) [1,2,4,6]
13:21:11 <roconnor> you dont need the == True btw
13:21:12 <lambdabot>  True
13:21:14 <sioraiocht> hrm
13:21:21 <sioraiocht> didn't know about hat function
13:21:31 <oerjan> esteban3: i don't think you want x: in (x:xs)
13:21:42 <sioraiocht> oerjan: why not?
13:22:33 <oerjan> what if f is (>=), say?
13:22:58 <oerjan> you are comparing x to itself
13:23:14 <sioraiocht> oh you mean in THAT part...
13:23:17 <sioraiocht> yes, you're right, hehe
13:23:18 <esteban3> thanks, nominolo
13:23:21 <sioraiocht> i thought you mean't in the pattern
13:23:28 <sioraiocht> *meant*
13:23:30 <oerjan> er, right
13:23:36 <esteban3> still i need to work a bit more on flip
13:23:47 <esteban3> the parents sometimes confuse me
13:24:03 <esteban3> when to put them and when not
13:24:45 <roconnor> parens in functional languages are a bit odd.
13:24:48 <nominolo> esteban3, just remember that "f x y z = (((f x) y) z)"
13:24:56 <roconnor> in that they are not needed for function application.
13:25:11 <nominolo> roconnor, erlang needs them
13:25:27 <roconnor> nominolo: oh?
13:26:18 <roconnor> I guess erlang isn't functional :P
13:26:50 <nominolo> well, it's a prolog-derivative
13:26:55 <nominolo> but pretty functional
13:26:59 <luqui> hmm, interesting, (== True) = id
13:27:08 <nominolo> ie, no backtracking or cuts
13:27:28 <nominolo> luqui, no, only for guards
13:27:47 <roconnor> @scheck \x (== True) x == id x
13:27:48 <lambdabot>  Parse error in pattern
13:27:51 <oerjan> you mean for Bools
13:27:54 <roconnor> @scheck \x -> (== True) x == id x
13:27:56 <luqui> of course
13:27:59 <luqui> doesn't type check otherwise
13:28:01 <lambdabot>   Completed 2 test(s) without failure.
13:28:17 <roconnor> @scheck (== True) x == id
13:28:17 <lambdabot>  Not in scope: `x'
13:28:21 <roconnor> @scheck (== True) == id
13:28:22 <lambdabot>  add an instance declaration for (Eq (Bool -> Bool))
13:28:22 <lambdabot>     In the expression: (...
13:28:28 <esteban3> > any (==2) [1,2,3,4]
13:28:30 <lambdabot>  True
13:28:45 <luqui> > any ((== True) . (== 2)) [1,2,3,4]
13:28:46 <lambdabot>  True
13:29:02 <roconnor> @scheck (== True) === id
13:29:03 <lambdabot>  Not in scope: `==='
13:29:17 <esteban3> luqui: whats that supposed to do?
13:29:27 <luqui> nothing special
13:29:29 <luqui> I'm just being silly
13:29:46 <oerjan> esteban3: you probably want to use dropWhile instead of any somehow, otherwise you duplicate a lot of work
13:30:13 <esteban3> i can't use other stuff
13:30:35 <esteban3> this course i'm in focuses on the functional paradigm
13:30:49 <esteban3> im not sure if i use something else that will be considered
13:30:55 <Heffalump> dcoutts: (or any other Data.Binary developer) ping?
13:30:57 <esteban3>  a lil bit limited
13:31:11 <oerjan> any isn't any better than dropWhile
13:31:28 <oerjan> drop it while you can :)
13:31:38 <esteban3> but we can use 'any'. In this case i should ask if i can use dropwhile
13:32:22 <luqui> @hoogle [a] -> Maybe a
13:33:11 <oerjan> @bot
13:33:25 <oerjan> eek
13:33:41 <oerjan> (btw the answer is listToMaybe, iirc)
13:33:47 <Heffalump> well, in case you read this in scrollback. I'm using Binary.Put, and it would be convenient to have a "skipTo" function that jumps forwards to an absolute position in the output, padding with a user-supplied character
13:34:30 <luqui> > let fany p = listToMaybe . dropWhile (not . p) in fany (== 2) [1,2,3,4]
13:34:52 <Heffalump> it seems that Builder nearly keeps track of its current position, and probably can be made to do so consistently (I hacked it, but in one case I haven't found yet it seems to lose track). Do you think this is something that's appropriate for it, or should I just implement my own position tracking on top of it?
13:35:54 <oerjan> lambdabot seems to be taking a nap.
13:40:29 <dons> dcoutts: oh, exciting. test suite running?
13:42:37 <sorear> @botsnack
13:42:54 <dons> oh
13:42:59 <sorear> @quit
13:43:21 <opqdonut> @bot
13:43:27 <opqdonut> @urmom
13:43:35 <dons> oh, looks like cse is down
13:43:40 <dons> i can't log in anyway
13:44:05 <dons> my unsw website is also down. so some unsw issue, they can fix.
13:44:14 <dons> if you have a bot handy, feel free to have it join
13:44:50 <Heffalump> are you planning on keeping hosting lambdabot there?
13:45:43 <thoughtpolice> i have a lambdabot build sitting here if it's any use. actually works almost fully it seems, too.
13:45:45 <dons> i'll move it to community.haskell.org, along with my web stuff
13:45:45 <SamB> dons: and they wouldn't have terminated your account?
13:45:55 <dons> SamB: not for 12 months or so
13:45:57 <thoughtpolice> guess some of the more recent patches fixed up a lot of stuff.
13:46:39 <ari> @bot
13:46:39 <rahaskella> :)
13:49:47 <peter_12> is there a particular Haskell book that is considered "The Definitive Guide"?
13:49:58 <bos> not really
13:50:00 <peter_12> like K&R for C?
13:50:01 <peter_12> ahh
13:50:07 <bos> no, definitely not in that case.
13:50:13 * Japsu has ordered SoE
13:50:20 <Japsu> I
13:50:33 <bos> there are several good intro haskell books, but they tend to be intro programming books too.
13:50:34 <Japsu> *I've heard that's a good book, not a definitive guide though
13:50:34 <newsham> see comment #13: http://freakonomics.blogs.nytimes.com/2007/09/05/a-little-math-puzzle-to-ponder/
13:50:41 <sorear-lambdabot> Title: A Little Math Puzzle to Ponder - 1000 Freakonomics - Opinion - New York Times Bl ..., http://tinyurl.com/ynphsg
13:51:04 <peter_12> what is SoE?
13:51:22 <mainland> school of expression
13:51:28 <opqdonut> haskell school of expresseion, book
13:51:38 <sorear> > 2 + 2
13:51:40 <elliottt> Japsu: i liked soe.  i also read the craft of functional programming, and liked it just fine :)
13:51:41 <sorear-lambdabot>      Failed to load interface for `Control.Parallel':
13:51:41 <sorear-lambdabot>       Use -v to see a l...
13:51:48 <sorear> oh well.
13:51:50 <ari> ...
13:51:56 <ari> > 2 + 2
13:51:57 <sorear-lambdabot>      Failed to load interface for `Control.Parallel':
13:51:57 <sorear-lambdabot>       Use -v to see a l...
13:52:00 <rahaskella>  4
13:52:02 <peter_12> What about Graham Hutton's book?
13:52:16 <sorear> ari: lambdabot really is deterministic! :D
13:52:43 <yax1> peter_12: it's a very good introduction imho
13:52:50 <peter_12> yax1: thanks
13:52:52 * sorear would love to see a lambdabot-like program that doesn't break when you have fifteen different versions of GHC installed
13:53:57 <bos> sorear: just install 15 xen virtual machines, so they won't interfere.
13:54:05 <pgavin> lol
13:54:33 <pgavin> that would take a bit to set up
13:55:01 <bos> ach, it's just typing.
13:56:56 <Tac-Work> Does anyone have any idea why my regex-posix-0.92 package isn't providing a haskell instance for RegexLike Regex ByteString?
13:57:16 <sorear> @seen TuringTest
13:57:16 <sorear-lambdabot> I haven't seen TuringTest.
13:57:17 <rahaskella> I haven't seen TuringTest.
13:57:31 <dons> is it in base?
13:57:36 <dons> i'd imagine it would be in regex-base
13:57:37 <Tac-Work> It exposes Text.Regex.Posix.ByteString, but when I load that module in GHCi, it doesn't acknowledge the instance
13:57:53 <sorear> rahaskella: @version
13:57:53 <rahaskella> lambdabot 4p545, GHC 6.6 (Linux i686 1800+)
13:57:53 <rahaskella> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:57:58 <sorear> sorear-lambdabot: @quit
13:58:03 <newsham> ?where TuringTest
13:58:03 <rahaskella> I know nothing about turingtest.
13:58:14 <shapr> rahaskella: @listchans
13:58:14 <rahaskella> ##otw #haskell #omp weird# shadowworld:#ecco-the-dolphin
13:58:21 <sorear> ari++
13:58:28 <Tac-Work> It's not defined in the regex-base either, it seems
13:58:54 <shapr> ari: It works with multiple irc networks at the same time?
13:59:08 <sorear> shapr: Yes!
13:59:12 <shapr> neato
13:59:18 <Japsu> er
13:59:19 <Japsu> > 1+1
13:59:20 <newsham> ?seen droidsYouSeek
13:59:20 <rahaskella> I haven't seen droidsYouSeek.
13:59:21 <rahaskella>  2
13:59:24 * sorear added that feature
13:59:24 <ari> shapr: Aye, it's cool
14:00:20 <Tac-Work> I don't get why these instances aren't defined anywhere
14:00:31 <Tac-Work> it finds the module just fine from the looks of it
14:00:44 <Tac-Work> and it defines RegexLike Regex String
14:00:56 <Tac-Work> but not an instance for ByteString =-[
14:01:49 <newsham> ?seen TheRemote
14:01:49 <rahaskella> I haven't seen TheRemote.
14:02:48 <Tac-Work> building things from source really shouldn't be this difficitult
14:02:58 <Tac-Work> *sigh*
14:05:44 <chrisz2> http://palagyik.act4trees.com/
14:06:29 <shapr> Bet that's spam.
14:06:42 <sorear> @bot
14:06:43 <rahaskella> :)
14:13:51 <ari> @url-on
14:13:52 <rahaskella> Url enabled
14:14:12 <newsham> has anyone worked on making lambdabot work with other chat nets recently?
14:15:12 <bos> other chat nets exist?
14:15:21 <newsham> bos: its true.
14:15:25 <newsham> i've seen them
14:15:50 <reffie> is milk in bags cheaper than regular milk
14:16:43 <newsham> the kind that come in sweaters seem to be very pricey
14:18:05 <elliottt> newsham: that paints a disgusting picture :)
14:23:10 <sorear> newsham: Lambdabot works on essentially all IRC networks.
14:23:50 <newsham> *nod*  i meant like jabber, silc, etc.
14:25:40 <sorear> @seen stepcut
14:25:40 <rahaskella> I haven't seen stepcut.
14:26:04 <sorear> stepcut has ported (pre-multiserver) lambdabot to jabber
14:26:40 <newsham> awesome.  do his changes happily coexist with irc code?  folded back into lambdabot darcs yet?
14:27:15 <sorear> no, and no.
14:28:59 <shapr> Is his repo available?
14:30:14 <sorear> yes
14:31:12 <newsham> at some point would be nice to separate out irc logic from the guts of lambdabot.  alas, doesnt look that simple..  I was going to attempt it once but I've been a lazy bottom.
14:32:11 <newsham> (the fact that ghc doesnt properly work on my main platform isnt helping.. *sigh*)
14:36:10 <thoughtpolice> newsham: what's your main platform?
14:39:12 <newsham> freebsd/amd64
14:39:55 <newsham> ironically it sounds like people use it on openbsd/amd64 and I don't see much difference in the src tree.
14:40:42 <mainland> hm, i'd like to see it working on freebsd/amd64 too
14:40:48 <mainland> then i could switch from i386
14:41:28 <newsham> there's a binary for freebsd/amd64 that makes ghc work but ghci still not supported, and the patches for said binary arent in ghc's darcs yet
14:42:24 <newsham> i imagine with enough effort you could run the 386 version on amd64, too.
14:43:15 <mainland> with enough effort one could get ghci to work on amd64 :)
14:43:46 <newsham> that too.
14:44:34 <newsham> I took a lazy whack at it and got bogged down in some of the build system details
14:44:58 <dcoutts> dons: yes, all tests passing
14:45:06 <dcoutts> Heffalump: pong
14:45:40 <dcoutts> bos: yes, cabal should work with all ghc back to 6.2, I've been developing it with ghc-6.6.1
14:45:51 <dcoutts> bos: having problems?
14:49:38 <kscaldef> Hi.   I've been trying to use HXT and wrap my head around arrows, and I'm having some difficulty figuring something out.  Basically, I have a function that I want to make into an arrow, but the function produces values in the IO monad.   Since all the arrows I'm working with are IOStateArrows, it seems like I should be able to make this work, but I can't figure out how.  Does that make sense?
14:50:18 <kscaldef> In short, I guess I'm looking for a function like "arr", but with this signature: (b -> IO c) -> IOStateArrow b c
14:53:26 <hpaste>  dfranke pasted "Single-elimination tournament pairings" at http://hpaste.org/2600
14:53:26 <dfranke> Hah, lazy evaluation FTW:
14:53:49 <dfranke> you can pass that 62 as an arguemnt and it'll actually start outputing results.
14:53:49 <lambdabot>  /home/dons/lib/ghc-6.6/package.conf: openFile: does not exist (No such file ...
14:53:52 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
14:53:52 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
14:53:52 <lambdabot> :)
14:53:52 <lambdabot> :)
14:54:21 <ari> @bot
14:54:21 <rahaskella> :)
14:54:23 <newsham> kscaldef: you can make an arrow for any monad.
14:54:53 <newsham> ?src Kleisli
14:54:53 <rahaskella> Source not found. The more you drive -- the dumber you get.
14:55:36 <kscaldef> ahh, found what I was looking for in the HXT docs.   Once I stated what I was looking for in terms of the signature, somehow it got easier for me to search for it
14:55:51 <kscaldef> the answer being: arrIO
14:59:39 <sorear> dons_!!
15:00:52 <sorear> stepcut: poke
15:01:03 <sorear> 14:13 < newsham> has anyone worked on making lambdabot work with other chat nets recently?
15:01:07 <sorear> 14:25 < sorear> stepcut has ported (pre-multiserver) lambdabot to jabber
15:02:11 <Tac-Work> stupid packages
15:02:13 <dcoutts> dons_: pushing now... take a look :-)
15:07:01 <pgavin> dcoutts, my gtk2hs patch bounced :)
15:07:21 <dcoutts> pgavin: hmm, not just held for moderation?
15:07:30 <pgavin> well, yeah, that's what I meant :)
15:07:37 <pgavin> it was 45k :)
15:07:47 <pgavin> that's the gstreamer patch
15:08:02 <pgavin> I'll put up the cabal patch later (maybe tonight)
15:10:10 <sorear> pgavin: the moderators are alive, it just takes them a few weeks
15:10:21 <pgavin> lol
15:10:35 <pgavin> it's only been a couple minutes :)
15:20:22 <Saizan> ?where Cabal
15:20:22 <rahaskella> http://www.haskell.org/cabal
15:24:22 <Saizan> uhm, so cabal-install should or shouldn't build with Cabal-1.1.7?
15:33:20 <pgavin> Saizan, probably not
15:33:30 <pgavin> Saizan, I think it needs a lot of work
15:49:41 <dcoutts> Saizan: I think it builds, it just doesn't work fully
15:51:05 <bos> dcoutts:  had some problems with the 1.1.7 branch, will try 1.2.0
15:51:27 <dcoutts> bos: what problem ? we've not changed much in 1.2.0
15:52:17 <bos> dcoutts: the register.sh script was calling ghc-pkg register with the wrong number of arguments
15:52:34 <dcoutts> bos: oh yes, we fixed that a while ago (I think)
15:52:43 * bos will take a look in a few moments
15:54:30 <byorgey> Is there a canonical package to use if I want to read a web page from a URL?
15:54:48 <byorgey> it seems like Network.CGI can do it but that seems like overkill if I'm not writing a CGI program
15:54:51 <pgavin> byorgey, you can use gnomevfs :)
15:55:17 <bos> byorgey: there's a curl package on hackage
15:55:28 <byorgey> pgavin: aha =)
15:55:33 <bos> also, desp has another curl binding mostly finished
15:55:36 <byorgey> bos: ok, thanks, I'll look at that too
15:55:49 <bos> desp's one uses bytestrings
15:56:17 <byorgey> mmm, bytestrings
15:56:40 <Saizan> lazy ones?
15:56:44 <bos> yes
16:00:47 <byorgey> bos: hmm, I can't seem to find a curl package on hackage
16:01:04 <bos> oh, i think it's on galois.com somewhere
16:01:13 <byorgey> bos: oh, ok, I'll go look there
16:01:17 <bos> also http://varsztat.com/projects/curl/darcs
16:01:20 <rahaskella> Title: Index of /projects/curl/darcs
16:13:10 <esteban2> one question, here: http://hpaste.org/2596
16:13:29 <esteban2> in the last post, can that function be written in a different way?
16:13:39 <esteban2> i mean.. i'm doing " func (x:xs) = ... "
16:13:53 <esteban2> but it can be handled in separated ways
16:14:01 <bos> esteban2: map (show . f) xs
16:14:11 <bos> er, not that
16:14:22 <esteban2> i tried doing this: func (x:_) = map f (x)
16:14:37 <pjd> minor point;  those types would usually be written with spaces:  func :: [String] -> (String -> a) -> [a]
16:14:38 <bos> esteban2: map (show . f) . filter ((>0) . f)
16:14:54 <esteban2> but the problem there is that it takes a string, not a char
16:15:14 <esteban2> in the post, i handle all the list
16:15:24 <esteban2> but i need to handle each element to check something
16:15:39 <pjd> esteban2: that func looks like "flip map", by the way
16:15:40 <bos> it's just a normal list filter
16:16:38 <esteban2> i need to apply a function to each element
16:16:47 <pjd> that's what map does :)
16:16:49 <bos> esteban2: see the code i wrote above
16:17:11 <bos> also, sinVoc is just length (filter (`elem` "aeiou"))
16:17:26 <esteban2> yes, i was pointed that out before..
16:17:30 <bos> er, length . filter (`elem` "aeiou")
16:18:02 <Vulpyne> Dvorak user, eh?
16:18:05 <bos> esteban2: it's much cleaner to use function composition than to write your own inductive definition
16:18:06 <esteban2> so in this case what i have to do is compose functions
16:18:26 <esteban2> each element has to verify two conditions
16:18:27 <bos> you don't have to, it's just far easier to read and understand
16:18:50 <pjd> Vulpyne: that's the canonical ordering, not aoeui :)
16:19:04 <esteban2> bos: what dont i have to?
16:19:16 <Vulpyne> I figured it was a slightly modified layout.
16:19:21 <shachaf> > sort "aeiou"
16:19:23 <rahaskella>  "aeiou"
16:19:49 <shachaf> @botsnack
16:19:50 <rahaskella> :)
16:22:54 <dcoutts> Saizan: I just fixed cabal-install to build with latest Cabal
16:23:11 <dcoutts> so darcs pull cabal-install
16:23:24 <Saizan> ooh, nice
16:23:51 <dcoutts> however the dep resolution is currently broken
16:24:04 <dcoutts> it'll only install one package at a time
16:24:18 <dcoutts> that's waiting for it to be updated to take configurations into account
16:24:22 <dcoutts> nominolo: ping :-)
16:25:07 <nominolo> pong
16:25:44 <dcoutts> nominolo: 'sok we don't need to fix this immediately but at some point we should look at it
16:26:00 <dcoutts> nominolo: cabal-install and configurations that is
16:26:01 <joelr1> good evening!
16:26:08 <nominolo> i talked about that problem with bringert a while ago
16:26:09 <Saizan> any thoghts on using it to handle darcs repos? (probably a common question)
16:26:24 <joelr1> would someone kindly tell me why you can't do data types in ghci?
16:26:46 <opqdonut> because that would be such a bother :)
16:26:54 <mauke> because ghci only likes expressions and bindings
16:32:19 <Tac-Tics2> you're the one who's splitting, Cale
16:32:19 <nominolo> Cale, one day we will have a working ghc-api-using haskell editor
16:32:24 <__nasa__> nope :-)
16:32:24 <Cale> __nasa__: two of the servers which the irc network is composed of disconnected from one another.
16:32:25 <pjd> __nasa__: http://en.wikipedia.org/wiki/Netsplit
16:32:25 <rahaskella> Title: Netsplit - Wikipedia, the free encyclopedia
16:32:36 --- mode: irc.freenode.net set +o ChanServ
16:32:37 <mgsloan> __nasa__: yeah, first time I saw that happen I thought that nuclear war had started
16:32:47 <__nasa__> yeah, just wikied it.
16:32:47 <dcoutts> Saizan: as urls on the cabal-install command line? how should their deps be found?
16:32:49 <dcoutts> Saizan: supposing a dep is in another darcs repo, or would we not support that?
16:32:49 <ndm> have the nickserv got split off as well?
16:32:55 <joelr1> nominolo: that's what i'm thinking about
16:33:17 <EvilTerran> joelr1, because commands typed at the ghci prompt are, for the most part, the same as lines in a do{} block
16:33:21 <nominolo> joelr1, oh, you've got a year of spare time to code that?
16:33:29 <Cale> joelr1: In case you missed that, GHCi isn't really thought of as an interpreter in and of itself -- it's more thought of as a debugger/tester which you load a file into, and then evaluate expressions based on that. In particular, apart from a limited capacity for function and pattern bindings, you can't make declarations at all from the GHCi prompt.
16:33:30 <joelr1> nominolo: why a year?
16:33:31 <Saizan> dcoutts: well, it could read .cabal files in repos, even if that'll probably mean you've to darcs get everything :\
16:33:49 <EvilTerran> (the special case being things that aren't IO _ get passed to print())
16:33:55 <mgsloan> an interpreter would be cooler
16:33:55 <joelr1> Cale: would it be possible via the GHC API?
16:34:04 <Cale> One issue is that declarations are generally allowed to be mutually recursive.
16:34:04 <opqdonut> hugs is more interpreter-like
16:34:10 <nominolo> joelr1, because that's what it takes to do it Right (tm)
16:34:20 <mgsloan> actually, coolest would be a shell style haskell interpreter
16:34:25 <Cale> opqdonut: Interface-wise it's even more restrictive than GHCi.
16:34:32 <joelr1> is there an editor that does proper haskell indenting, apart from emacs?
16:34:48 <nominolo> vim?
16:34:57 <Cale> joelr1: If you can call what emacs does proper indenting... :)
16:34:59 <nominolo> visualhaskell
16:35:02 <joelr1> Cale: ghc api is even more restrictive?
16:35:15 <nominolo> Cale, isn't it?
16:35:17 <Cale> joelr1: Hugs is
16:35:39 <Cale> nominolo: I was always annoyed at its indentation choices.
16:35:49 <Cale> Maybe it's improved since I last used it.
16:36:05 <nominolo> well, there're different indentation modes
16:36:11 <joelr1> would a ghci-like thing built with the ghc api have the same restrictions as ghci?
16:36:15 <Cale> I ended up turning off the smart indenting and going with simple.
16:36:19 <joelr1> as far as declaring new types goes
16:36:25 <Cale> I don't really mind vim's indenting at all.
16:36:41 <Cale> joelr1: Well, if you're talking about writing new software, then no. :)
16:36:56 <ndm> anyone have a good reference on unification?
16:37:05 <Cale> You could probably handle at least not-mutually-recursive declarations.
16:37:08 <joelr1> Cale: so you could potentially have a proper OCaml-style toplevel, right?
16:37:14 <ndm> in particular i'm after an algorithm to find the most specific generalisation of two terms
16:37:15 <joelr1> i wonder why it hasn't been done before
16:37:47 <sjanssen> joelr1: I don't think there's much demand
16:37:59 <Cale> joelr1: Well, it's not reasonable to have an interactive interpreter which will accept any valid Haskell file at the prompt.
16:38:12 <sjanssen> ghci+vim has always been enough for me
16:38:22 <joelr1> Cale: why not? ocaml does it
16:38:26 <Cale> Because Haskell declarations are allowed to be mutually recursive -- so you can base definitions on things which haven't been defined yet.
16:38:33 <pjd> Cale: yay, out of order execution
16:38:35 <joelr1> Cale: oh
16:38:43 <joelr1> laziness
16:38:48 <pjd> print x
16:38:48 <Cale> Not laziness really.
16:38:49 <mgsloan> edit/save/compile gets old
16:38:49 <EvilTerran> Cale, that'd be ghc /dev/tty ;]
16:38:51 <pjd> x = 5
16:39:21 <Cale> It doesn't really have anything to do with evaluation so much as interpretation of declarations.
16:39:23 * nominolo goes read some papers while ghc compiles
16:39:28 <Cale> I can write things like:
16:40:01 <augustss_> I think ghci has a crap top level.  you can do much better and accept declarations
16:40:20 <joelr1> augustss_: hi lennart
16:40:28 <joelr1> augustss_: me want ocaml toplevel
16:40:32 <Cale> evens = 0 : map (+1) odds; odds = map (+1) evens
16:40:34 * mgsloan agrees
16:40:37 <Saizan> you could allow mutually recursive decs in a "transaction"
16:40:40 <dons> dcoutts: looks good, the new representation.
16:40:43 <Cale> Or even something similar on the type-level.
16:40:48 <dons> any idea on performance yet? spec constr should kick that thing
16:40:50 <jbalint> decs?
16:41:02 <dcoutts> dons: not yet
16:41:03 <joelr1> augustss_: question... why did csfb go with haskell vs ocaml? performance had the backseat? what took the front?
16:41:07 <Saizan> declarations
16:41:13 <Cale> data Even = Zero | SuccE Odd; data Odd = SuccO Even
16:41:36 <augustss_> joelr1:CS hired two Haskell people, so they got Haskell :)
16:41:43 <joelr1> dons: hi don
16:41:51 <joelr1> augustss_ :D
16:41:53 <Cale> You might do something like require mutually recursive groups to be squashed all on to one line.
16:41:57 <coffeemug> heh
16:41:59 <dcoutts> dons: but time to try tuning that lazy sumfile again I think, trying to get specconst to give a nice loop with unboxed args
16:42:05 <coffeemug> I had an interview in a startup today
16:42:31 <augustss_> Cale: Or do what hbi did, require {} around mutually recursive declarations
16:42:38 <coffeemug> they offered me pre-IPO options but refused to say what percentage of the company that is "because investors don't like to reveal that information"
16:42:50 <coffeemug> you gotta love startup games :)
16:42:53 <augustss_> coffeemug: that's typical
16:42:55 <joelr1> coffeemug: smug!
16:42:56 <dons> hey joelr1. have't had time to look at your thing yet -- busy with new job
16:43:00 <dons> dcoutts: ah yes.
16:43:03 <dons> that's the test
16:43:04 <joelr1> dons: what's that /job/?
16:43:21 <augustss_> I saw that there was another London investment bank job on the Haskell mailing list today
16:43:37 <augustss_> Looks like BarCap
16:43:43 <bos> yes, i initially thought it was yours, augustss
16:43:46 <dcoutts> augustss_: you've got competition for recruitment :-)
16:43:51 <coffeemug> augustss_: how so? Without knowing the percentage the number of shares is meaningless because they'll split or reverse-split at IPO to hit a $10-$20 mark
16:43:52 <joelr1> augustss_: how did i miss that? not that i'm looking to move from tenerife
16:44:05 <joelr1> augustss_: you ought to host a haskell meetup here
16:44:06 <dons> joelr1: i have a real haskell job now :)
16:44:18 <Cale> joelr1: I think the real reason it hasn't been done is that everyone just keeps their editor open alongside ghci.
16:44:20 <joelr1> dons: where, where??? new zealand?
16:44:25 <dons> augustss_: ah, it could be barcap, yes.
16:44:30 <augustss_> coffeemug: I'm not saying I like it, just that they are very tight lipped about these things
16:44:38 <dons> augustss_: they do use haskell, i'm told
16:44:47 <joelr1> where are those real haskell jobs?
16:44:56 <augustss_> Yes, they use Haskell for a payout language
16:44:59 <bos> yes, barcap does use haskell
16:45:04 <dcoutts> joelr1: city of london
16:45:15 <joelr1> dons: you moved to london?!
16:45:16 <augustss_> Canary Wharf
16:45:17 <coffeemug> augustss_: well, it may be typical to try to rip people off but it's certainly a very shady business practice
16:45:22 <dons> joelr1: galois. i'm in portland, or
16:45:27 <augustss_> coffeemug: agreed
16:45:29 <coffeemug> effectively they give you a contract you can't possibly valuate
16:45:33 <joelr1> dons: ah!
16:45:40 <bos> coffeemug: it's not terrible unusual for startups to withhold that sort of thing, alas.
16:45:45 <coffeemug> I'm not even sure that it's legal
16:45:50 <joelr1> dcoutts: what about the city of london?
16:45:51 <bos> of course it is.
16:45:58 <augustss_> coffeemug: I'm sure it is
16:46:03 <coffeemug> it's legal to give you a contract you can't valuate?
16:46:15 <augustss_> You couldn't anyway
16:46:41 <coffeemug> I know, but without knowing a % of share you really know nothing
16:46:51 <dcoutts> joelr1: london financial firms I mean, though as augustss_ says, they're not actually all within the square mile
16:47:04 <coffeemug> wouldn't that be the same thing as saying you may get anywhere from 1 to 10,00,000 dollars at random
16:47:13 <bos> yes.
16:47:21 <coffeemug> without giving you information about the distribution, even :)
16:47:28 <augustss_> dcoutts: no, they are not.  many investment banks are at canary wharf
16:47:32 <joelr1> dcoutts: oh, apologies. i either missed the beginning of the conversation or i initially asked where dons was moving.
16:47:40 <bos> dude, if you think that knowing how much you own gives you any actionable information, you're being very naive.
16:47:55 <bos> 10% of a pre-IPO startup is worthless.
16:48:18 <coffeemug> not so
16:48:20 <augustss_> bos: not worthless.  It's like a lottery ticket
16:48:46 <coffeemug> if you have 10% of a pre-IPO startup, it's merely your opinion on whether it will succeed and how much it will be worth
16:48:59 <dons> anyone know a Jurgen Nicklisch?
16:49:02 <bos> well, let's say it can't be evaluated. it's worthless in the sense that you can't do anythin with it.
16:49:10 <coffeemug> if you have x shares of a startup, it doesn't matter whether you think it'll succeed or how much it will be worth
16:49:13 <coffeemug> it's a huge difference
16:49:37 <coffeemug> first one is a risk you elect to take
16:49:41 <coffeemug> second one is a scam
16:50:10 <coffeemug> and I'm not sure how the second one can possibly be legal
16:50:14 <coffeemug> if it is legal, it shouldn't be
16:50:29 <bos> shrug.
16:50:45 <bos> how many people are there at this startup?
16:50:49 <coffeemug> I think I'll send an angry email to the founder :)
16:50:51 <ndm> coffeemug: you can always apply to companies house and get their share agreements, which will tell you how many shares there are
16:51:02 <joelr1> i think i'm afraid of hhaskell
16:51:05 <phobes> coffeemug:  Why wouldn't it be legal?
16:51:11 <bos> ndm: not outside the UK, you can't
16:51:14 <phobes> I think that's a very common scam
16:51:24 <ndm> bos: oh, is this not a UK firm?
16:51:27 <phobes> and are we talking about legal in the UK or US?
16:51:29 <coffeemug> phobes: same reason pyramid schemes shouldn't be elgal
16:51:33 <Tac-Tics2> joelr1: the fear is normal. It helps protect you from the True Terror of Haskell
16:51:34 <coffeemug> I'm in the US
16:51:43 <coffeemug> there are about 20 people I think
16:51:44 <bos> coffeemug is on a verizon line , so he's not in the UK
16:51:50 <joelr1> i mean, just took a look someone's post re: the ghc api and they say the executables with even part of the functionality are huge
16:51:55 <coffeemug> supposedly funded by delicious and flickr guys
16:52:11 <ndm> joelr1: using the GHC API is not pleasant, its massive, undocumented and unstable
16:52:16 <phobes> coffeemug: (I'm also in the US)  I think this is different than a pyramid scheme and there are laws that make those illegal
16:52:31 <ndm> but of course, the only way it will become pleasant and documented is by people using it...
16:52:47 <coffeemug> phobes: I'm just saying, giving out such a contract is effectively the same as preying on people's ignorance
16:52:50 <coffeemug> it's borderline scam
16:52:51 <phobes> this is just a simple case of offering something that can be of low value if you read the fine print
16:52:55 <phobes> and think about it
16:52:59 <bos> coffeemug: if you're not one of the first few people on board, and the company is anything less than an incredible insane success, you don't stand to make much money, so don't stress over the stock options.
16:53:01 <ndm> pyramid schemes are illegal in the UK, but there are millions of ways round them
16:53:08 <phobes> There are *lots* of contracts that have that feature, using one ploy or another
16:53:11 <joelr1> ndm: but what else would you use if you were trying to bootstrap an IDE, for example? wouldn't you want to do it with a built-in extension language, sort of like emacs and elisp?
16:53:22 <augustss_> coffeemug: I'm sure they'll tell you your salary.  Anything else is just an unspecified bonus
16:53:25 <coffeemug> bos: yep
16:53:35 <coffeemug> salary they mentioned
16:53:41 <ndm> joelr1: i wouldn't want to do that :) - but yeah, GHC API is what i would use
16:53:55 <sebell> What about hint?
16:53:56 <ndm> coffeemug: they may be malicious in hiding it, or they may just be a tad incompetent
16:54:07 <coffeemug> yeah
16:54:09 <augustss_> It totally normal
16:54:15 <coffeemug> I'll send an email to the founder
16:54:19 <coffeemug> with my concerns :)
16:54:30 <phobes> It doesn't have to be malicious or incompetence
16:54:36 <joelr1> ndm: maybe i said it wrong. assume you are building a game or some kind of an app.
16:54:44 <coffeemug> phobes: it's a "why not" kind of thing
16:54:47 <coffeemug> they tried it
16:54:53 <coffeemug> I could have been stupid enough to sign up
16:55:01 <coffeemug> I'm sure many people that did sign up were
16:55:10 <phobes> I'm sure as well
16:55:13 <coffeemug> because it's not illegal there is no reason for them not to try it
16:55:16 <ndm> joelr1: i'd implement LISP in about 25 lines of Haskell and be happy enough with that
16:55:25 <joelr1> ndm :D
16:55:35 <phobes> Well, you can image circumstances where someone could in good faith make such an offer
16:55:36 <ndm> coffeemug: pissing off your employees before they've even got through the door is never in a companies best interest
16:55:49 <phobes> It's hard to offer a fixed percentage if you don't know up front how many participants there will be
16:55:53 <coffeemug> ndm: yeah
16:56:13 <coffeemug> phobes: sure, but they should disclose how many shares are outstanding
16:56:15 <shapr> @seen SyntaxNinja
16:56:16 <rahaskella> I saw SyntaxNinja leaving #haskell 1h 42m 41s ago, and .
16:56:19 <shapr> foo
16:56:30 <joelr1> ndm: if you were to use haskell for interactive cocoa (mac) development, for example, you would need to let the cocoa run loop take over thread #1 and run your ghci session in thread #2
16:56:46 <joelr1> i don't even know if that's possible. somehow i don't think it is.
16:56:55 <ndm> that sounds painful, even if it is possible
16:57:09 <augustss_> coffeemug: you seem to think there's some transparency in the startup business.  there's not.  they all seem to be crazy secretive as far as i can tell.
16:57:22 <phobes> coffeemug: I agree that more disclosure is better, and I suspect when you find out the details it will sound even more suspicious - I'm just saying it *could* be legit
16:57:52 <sorear> ndm: google has been my friend, unification-wise
16:58:07 <coffeemug> augustss_: in that case they're shooting themselves in the foot
16:58:11 <ndm> sorear: yes, i can find plenty on unification, but nothing on most specific generalisation
16:58:20 <bos> coffeemug: you haven't been through any startups before, eh?
16:58:23 <coffeemug> phobes: yeah, could be, but it's not a likely scenario :)
16:58:25 <sorear> ndm: are your terms ground?
16:58:31 <coffeemug> bos: I have, I was burned once
16:58:36 <coffeemug> and saw people get burnt
16:58:41 <coffeemug> so this time I'm careful :)
16:58:42 <ndm> sorear: apart from a 1987 book, which i've got by my side, and its not particularly fun to read it (very confusing)
16:58:46 <augustss_> coffeemug: maybe so
16:58:47 <bos> happens all the time, alas.
16:59:06 <ndm> sorear: no, they have free variables
16:59:25 <EvilTerran> what do you guys suggest for a general introduction to category theory?
16:59:27 <augustss_> ndm: you could always read Robinson's paper
16:59:39 <coffeemug> category theory for computer scientists is pretty good
16:59:52 <bos> coffeemug: don't expect anything good to come from your attempts to pry more information out
17:00:07 <joelr1> how many people are using haskell on a mac here?
17:00:12 <ddarius> EvilTerran: Any math background?
17:00:17 <coffeemug> bos: well, I'll try, if they're forthcoming, good, if not we'll just part ways
17:00:19 <augustss_> joelr1: I am
17:00:43 <bos> joelr1: i've installed ghc 6.6.1 on a mac. it's painful.
17:00:47 <EvilTerran> ddarius, nothing beyond the maths in the first year of my CS degree
17:00:53 <LoganCapaldo> I didn't find installing 6.6.1 to be painful
17:01:01 <sebell> joelr1: I
17:01:02 <LoganCapaldo> maybe I'm insane
17:01:12 <bos> LoganCapaldo: did you install from macports, or binaries?
17:01:15 <ndm> augustss_: "A Machine-Oriented Logic Based on the Resolution Principle" ?
17:01:26 <joelr1> bos: no way! i have done that over and over and it's simple with macports, trivial even. i have also done it from source
17:01:27 <bos> the binaries are awful. macports was fine, although it took forever.
17:01:28 <LoganCapaldo> I used the binaries
17:01:40 <LoganCapaldo> I don't have macports installed
17:01:44 <augustss_> ndm: could be.  ca 1965
17:01:51 <EvilTerran> coffeemug, is that the Benjamin C. Pierce one? i'm seeing several books with vaguely similar names
17:01:51 <ndm> augustss_: yeah, thats the one
17:01:55 <augustss_> ndm: He invented unification
17:02:08 <sebell> I bootstrap from the binaries on haskell.org/ghc, and build a static libgmp and without some of the unused libraries
17:02:13 <coffeemug> EvilTerran: yep, that's the one
17:02:24 <joelr1> dcoutts: are you and dons hacking ghc internals?
17:02:36 <ndm> hmm, i can't get that from home :(
17:02:45 <ddarius> EvilTerran: I like Barr and Wells' ESSLLI lecture notes
17:02:49 <joelr1> i wonder how many people are working on native, non gcc code generation for haskell
17:03:15 <augustss_> ndm: if I remember right, it's not a great paper to learn unification from.  But it's what I used
17:03:33 <dcoutts> joelr1: there's at least two doing that full time
17:03:40 <__nasa__> I am using it on a mac.
17:03:41 <EvilTerran> @go  Barr and Wells' ESSLLI lecture notes
17:03:48 <rahaskella> http://www.let.uu.nl/esslli/Courses/barr-wells.html
17:03:48 <rahaskella> Title: Courses: Barr / Wells
17:03:49 <augustss_> joelr1: I've done that a few times
17:04:01 <dcoutts> joelr1: and no, dons and I are not hacking ghc internals
17:04:03 <ndm> augustss_: i'm after most specific generalisation, rather than general unification - and i don't want to understand it, i just want something precise enough to implement it without a million back links through a non-searchable book
17:04:15 * EvilTerran downloads
17:04:25 <joelr1> augustss_: done what exactly?
17:04:26 <EvilTerran> okay, that should be enough to keep me busy for a little while
17:04:35 <joelr1> dcoutts: ah, i thought you were optimizing something
17:04:36 <ddarius> EvilTerran: There is a PDF version elsewhere if that's preferable to you.
17:04:42 <augustss_> joelr1: worked on native code generation from Haskell
17:04:47 <EvilTerran> postscript is fine
17:04:56 <dcoutts> joelr1: yes, bytestring
17:05:02 <joelr1> augustss_: was that with the assembler-generation library recently?
17:05:29 <joelr1> augustss_: what were the results of your working on native code generation from haskell?
17:05:36 <ddarius> joelr1: hbc
17:05:46 <sorear> joelr1: augustss_ wrote the first compiler for a lazy language (LMLC), and one of the first optimizing compilers using the same backend
17:05:53 <augustss_> well, that was a quick hack.  I was referring to hbc with backends for about all known platforms. :)  In the early 90s
17:05:56 <sorear> *optimizing haskell compilers
17:06:14 <joelr1> ddarius: what's that? /hbc/
17:06:24 <Rebooted> EvilTerran: Categories, Types and Structures is quite good
17:06:30 <Rebooted> free pdf now
17:06:33 <augustss_> joelr1: The first Haskell compiler
17:06:52 <augustss_> The one they bootstrapped GHC with
17:06:53 <__nasa__> @google hbc
17:06:54 <rahaskella> http://www.hbc.com/
17:06:55 <rahaskella> Title: Welcome to Hbc.com - Great things for Canada
17:06:56 <ddarius> joelr1: The Haskell B. Compiler  augustss_ wrote.
17:06:57 <EvilTerran> oh right **downloads that, too**
17:07:06 <joelr1> sorear: i hold augustss_ in very high esteem! as well as all of the other people in this channel. you y'all are far smarter than i!
17:07:16 * sorear googles "[Augustsson 1984]" and counts the results
17:07:22 <njbartlett> joelr1: I'm not
17:07:30 <ddarius> EvilTerran: There's quite a bit of stuff online for CT.  About half of it is rather good.
17:08:08 * ndm complains about only getting 15Mb web space quota at computer science...
17:08:22 <augustss_> Crap!  I'm no longer the first hit when googling Lennart. :(
17:08:48 <joelr1> i wonder if i just just stop being a chicken and try to hack ghc. i can't seem to come up with any decent business idea anyway.
17:08:51 * sorear has 10MB
17:08:54 <EvilTerran> okay then. thanks, guys. **starts reading the Barr/Wells slides**
17:09:02 <joelr1> i yearn for that my-head-is-gonna-explode-now feeling
17:09:25 <augustss_> joelr1: why would you want to hack ghc?  better ghci?
17:09:26 * joelr1 has ... ugh... 3 mac laptops with lots of disk space
17:09:49 <LoganCapaldo> Doesn't even look like you are on the first page :(
17:09:59 <coffeemug> ok
17:10:00 <sorear> well, everyone calls you Augustsson nowadays
17:10:00 <joelr1> augustss_: it's a zen thing. i meant just trying to contribute
17:10:05 <coffeemug> off to do great things :)
17:10:20 <sorear> if you want your first name to have more google juice, stop being quite so legendary
17:10:21 <joelr1> augustss: it's a zen thing. i meant just trying to contribute.
17:10:38 <sorear> well, everyone calls you Augustsson nowadays
17:10:50 <njbartlett> (1) Hack GHC (2) ??? (3) Profit!!
17:11:16 <augustss> joelr1: OK.  I've thought of making a new ghci front and now and then
17:11:20 <joelr1> whenever i stop doing hands-on development and start doing something like sales /did for a year/ i start fretting that i need to hack on something
17:11:30 <ddarius> augustss: Do it!  I might actually use GHCi then.
17:11:46 <joelr1> since my technical side wants to be put to use
17:11:48 <ndm> just wait for GuiHaskell, it will meet all your needs
17:12:04 <mauke> will it run in a terminal?
17:12:10 <augustss> ddarius: I might use it too if I did.
17:12:11 * ddarius is with mauke.
17:12:41 <sebell> Something like SLIME would be excellent
17:12:41 * augustss is with mauke too. :)
17:12:43 * EvilTerran is still amused by the pronunciation of "gui" as "gooey"
17:12:45 <ndm> mauke: my guess is that if you tried it, you'd realise you don't want it to run in a terminal
17:12:48 <joelr1> augustss: i miss my wall st. days
17:12:50 <EvilTerran> **snerk** gooey haskell...
17:14:07 <augustss> joelr1: who did you work for?
17:14:47 <sorear> ndm: Will it support good fonts?  ISO 14755 text entry?  Copy&paste?  Searchable scrollback?  Any of the half-gazillion other things urxvt already does for every program I run in it?
17:14:54 <Rebooted> sebell: I've been thinking the same thing for a while
17:14:58 <joelr1> augustss: oh... lots of places. i exited as director of prime brokerage technology at deutsche in ny, in the summer of '99. i was 24 at the time and can't claim i was too good
17:15:07 <ndm> sorear: yes, plus it will have buttons!
17:15:12 <joelr1> augustss: http://wagerlabs.com/resume.pdf
17:15:16 * ddarius hates that pronunciation
17:15:31 <Rebooted> sebell: there must be enough ppl interesting in making something like SLIME for haskell
17:15:36 <joelr1> augustss: i had a long and not necessarily distinguishing career in securities lending technology, before expanding into equity finance in general
17:15:51 <sorear> @go SHIM
17:15:53 <rahaskella> http://en.wikipedia.org/wiki/Shim
17:15:53 <rahaskella> Title: Shim - Wikipedia, the free encyclopedia
17:17:03 <dibblego> joelr1, do you ride a Yamaha R1?
17:17:03 <reffie> http://liarpedia.org/wiki.cgi/Shim
17:17:08 <ddarius> EvilTerran: When the lecture notes start talking about representable functors pay very very close attention.
17:17:11 <joelr1> dibblego: no, why?
17:17:20 <EvilTerran> um. okay.
17:17:25 * joelr1 rides a white horse
17:17:25 <dibblego> joelr1, because I think of a Yamaha R1 every time I see r1
17:17:40 <joelr1> dibblego: what's the r1 that you are seeing?
17:17:47 <dibblego> joelr1
17:17:55 <joelr1> dibblego: ah!
17:17:56 <dibblego> joel is a name (my brother's even)
17:18:04 <dibblego> r1 is a motorcycle :)
17:18:21 <joelr1> dibblego: no, r is for my last name and 1 is because joelr is often taken
17:18:40 <sebell> "Joel Reymont the First"
17:18:41 <dibblego> R1 is popular because it is based on Valentino Rossi's bike
17:18:59 <omp> rossi rossi rossi
17:19:55 <segher> say i have a double-recursive function, like in the fibonacci series.  is there some simple way to make haskell memoize previous values?
17:21:23 <dibblego> ?where memoization
17:21:23 <rahaskella> I know nothing about memoization.
17:21:49 <LoganCapaldo> rahaskella, lambdabot, is that you?
17:21:54 <EvilTerran> ?bot
17:21:55 <rahaskella> :)
17:22:03 <augustss> > 1+2
17:22:07 <rahaskella>  3
17:22:26 <dibblego> ?where+ memoization http://www.haskell.org/haskellwiki/Memoization
17:22:26 <rahaskella> Done.
17:22:27 <augustss> It could be a human faking as a bot ;)
17:22:38 <ddarius> @wiki Memoization
17:22:38 <rahaskella> http://www.haskell.org/haskellwiki/Memoization
17:22:43 <joelr1> augustss: are you guys with central it or part of a business unit?
17:22:47 <segher> it's the hive brain :-)
17:23:03 <njbartlett> Some kind of reverse Turing test is required
17:23:23 <LoganCapaldo> the reverse turing test has to be a _lot_ harder
17:23:28 <LoganCapaldo> to administer
17:23:36 <augustss> we're not IT.  we're part of the group that contain the quants for all the business units
17:23:46 <joelr1> augustss: ah!
17:24:03 <pgavin> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:24:04 <rahaskella>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:24:09 <segher> @botsnack
17:24:10 <rahaskella> :)
17:24:19 <augustss> augustss: so we're front office.  for good and bad :)
17:24:33 <segher> i know how to do zips like that, it's just not very handy for what i'm doing
17:24:43 <pgavin> it usually isn't :)
17:24:51 <pgavin> but it's neat anyhow
17:24:57 <segher> it's funky though :-)
17:25:01 <segher> yah
17:26:43 <joelr1> augustss: if you were to develop a new ghci where would you start?
17:26:49 <LoganCapaldo> wouldn't you really need to stick a memoized function inside State (or ST or IO)?
17:27:10 <augustss> joelr1: By looking at the old ghci
17:27:15 <ddarius> LoganCapaldo: No.
17:27:18 <joelr1> augustss: also, do you see haskell used in high-frequency trading any time soon? program trading? algos?
17:27:23 <idnar> :t $!
17:27:26 <rahaskella> parse error on input `$!'
17:27:31 <ddarius> :t ($!)
17:27:32 <joelr1> augustss: i assume you are doing modeling but i may well be mistaken
17:27:34 <rahaskella> forall a b. (a -> b) -> a -> b
17:27:40 <idnar> :src ($!)
17:28:03 <joelr1> augustss: that is, i assume your code is not being hooked up to algos as it is
17:28:08 <Toxaris> LoganCapaldo: you can exploit lazyness for memoization. updating of thunks is enough state modification.
17:28:14 <idnar> well, that didn't work
17:28:17 <idnar> what does $! do?
17:28:21 <augustss> joelr1: well, I don't do modelling.  I do infrastructure for the modellers.  And I don't see any of the things you mentioned happening at CS any time soon.
17:28:22 <ddarius> @src ($!)
17:28:22 <rahaskella> Source not found. I feel much better now.
17:28:26 <LoganCapaldo> Toxaris, that assumes a lot about the implentation though doesn't it?
17:28:36 <ddarius> f $! x = x `seq` f x
17:28:37 <joelr1> augustss: why not?
17:28:50 <idnar> ah, right
17:29:25 <ramza3> I am complete haskell noob, does anyone have an example on reading data from a binary file, so far I got as far as openBinaryFile, but can't read the bits?
17:29:31 <ddarius> LoganCapaldo: It assumes that it is call-by-need, which is not specified and that it doesn't break the sharing none of which is specified but in practice robust enough.
17:29:32 <augustss> joelr1: It's difficult enough as it is to deploy Haskell.  Right now we do it it a rather risk free way.
17:29:54 <augustss> joelr1: There's lots of momentum in a large organization.
17:30:31 <LoganCapaldo> Ok, but if you wanted to be _sure_ you'd have to have an explicit cache right?
17:30:52 <joelr1> augustss: so what would you suggest be done to make haskell deployment easier? is this something missing in ghc?
17:30:57 <ramza3> hGetBuf sounds good
17:31:00 <ddarius> LoganCapaldo: Or a primitive that was specified to do it.
17:31:12 <LoganCapaldo> k
17:31:25 <augustss> joelr1: Dynamically linked apps and dlls for windows would help.
17:31:31 <ddarius> call-by-name is a completely legal implementation of non-strictness for Haskell
17:31:38 <augustss> joelr1: better integration with Visual Studio.
17:31:50 <pgavin> ugg
17:31:51 <augustss> joelr1: a .NET backend
17:32:00 <joelr1> augustss: i thought that haskell did produce dynamically-linked apps... ugh... doesn't ghc use shared libraries?
17:32:11 <pgavin> joelr1, not yet
17:32:19 <pgavin> well, maybe windows dlls actually
17:32:23 <pgavin> they don't need pic afaik
17:32:26 <joelr1> hmmm
17:32:29 <joelr1> right
17:32:38 <pgavin> but definitely not on unix etc
17:32:39 <augustss> joelr1: no, windows dlls are monolithic monsters
17:32:47 <Toxaris> but since memoization is optimization, I think a little bit of implementation dependence should be ok
17:33:23 <joelr1> i see
17:33:33 <augustss> The ghc RTS needs to be dynamically linked too
17:33:33 <Toxaris> what's the point of optimizing some code for a not-yet-existing-but-legal special case implementation?
17:33:38 <njbartlett> augustss: Either a CLR or JVM back-end would be an incredibly useful thing...
17:34:06 <augustss> njbartlett: absolutly.  A good one, that is
17:34:10 <joelr1> oh, well
17:34:15 <joelr1> thank you guys for the chat
17:34:19 <LoganCapaldo> Toxaris, well I'm concerned (in general) with optimizing based on "unobservable" implementation details
17:34:21 <joelr1> 1:33am in tenerife
17:34:23 <njbartlett> Yes. There have been lots of attempts, but nothing worth using for real
17:34:24 <joelr1> over and out
17:34:36 <dibblego> he does ride!
17:34:39 <LoganCapaldo> I'd feel ok using an implemntation specific memomization primitive
17:35:03 <LoganCapaldo> not so hot on relying on the evaluation strategy
17:35:08 <LoganCapaldo> esp. in haskell
17:35:22 <LoganCapaldo> but that's just my feelings
17:36:26 <pgavin> LoganCapaldo, you could cheat by using unsafePerformIO
17:36:48 <pgavin> combined with explicit memoization
17:36:50 <ddarius> LoganCapaldo: In most cases you are relying on a) a call-by-need (i.e. lazy) implementation and b) that the particular expression you want isn't inlined.
17:36:52 <njbartlett> One almost wishes MS would try to capitalize a little on their investment in Simon* and GHC...
17:37:11 <ddarius> njbartlett: Who says they aren't?
17:37:30 <ddarius> (Well, not GHC... well... not that I know of...)
17:37:54 <pgavin> does MS actually use haskell for anything?
17:37:58 <njbartlett> Hmm i suppose they're trying to pull ideas into C# and so on. But that's not exactly what I meant :-)
17:38:25 <idnar> H#!
17:38:35 <idnar> (heh)
17:40:36 <LoganCapaldo> I'm sure it's fine for the specific case of haskell given the relatively small number of implementations and that for most (all?) the source is viewable. But those assumptions can both change (relatively) silently even if its unlikely, so as a rule I don't like those kinds of assumptions
17:40:52 <Toxaris> LoganCapaldo: you would prefer a well-defined but formaly unportable memoization-extension over a informally defined but practically portable use of laziness?
17:41:16 <LoganCapaldo> I think so yes :)
17:41:50 <ddarius> LoganCapaldo: Something close enough to laziness is practically guaranteed for any real implementation.
17:41:53 <LoganCapaldo> At least if I needed to be sure my function was being memoized
17:42:06 <sorear> pgavin: yes, they use it to bribe SPJ into staying (and once in a while he contributes massively to C#, which is why they keep him)
17:42:22 <LoganCapaldo> ddarius, yeah like I saidfor the specific case of haskell...
17:42:38 <LoganCapaldo> but in general, no
17:42:40 <EvilTerran> isn't laziness actually guaranteed by the Report?
17:42:45 <ddarius> EvilTerran: No.
17:43:10 <EvilTerran> er.
17:43:33 <LoganCapaldo> It guarantees "non-strict" evaluation, right?
17:43:37 <Toxaris> LoganCapaldo: maybe it would help if laziness would be formally defined as a extension, so that implementations could state formally that they implement non-strictness as laziness
17:43:40 <ddarius> LoganCapaldo: I'm saying laziness at least is something that you can unquestioningly rely on.  You write recursive loops, no?  The Report doesn't guarantee TCO either.
17:44:33 <LoganCapaldo> ddarius, again, it works well for haskell because theres almost no other sane way to do it :)
17:44:50 <Toxaris> no sane way known and implemented at the moment
17:44:54 <ddarius> LoganCapaldo: Okay.  That's not what you said earlier.
17:45:01 <sorear> GHC is NOT lazy
17:45:05 <Toxaris> most programmers don't think Haskell is sane
17:45:28 <sorear> GHC uses a completely unpredictable evaluation order, which happens to be lazy in some cases.
17:45:36 <sorear> But other times, it's applicative.
17:45:37 <EvilTerran> okay, i meant the report guarantees non-strict semantics
17:45:46 <sorear> Still other times, it's call by name.
17:45:57 <ddarius> EvilTerran: Yes, but call-by-name is a valid implementation of it.
17:46:07 <LoganCapaldo> I was trying to get across my feelings in general about the idea of relying on "things like this" in general
17:46:13 <LoganCapaldo> Sorry
17:47:19 <LoganCapaldo> I may be especially sensitive to the issue because I just got burned by "relying" on "a thing like this" today
17:47:30 <LoganCapaldo> (in C++, not Haskell)
17:47:41 <ddarius> You never rely on anything in C++!
17:47:45 <LoganCapaldo> yeah
17:47:51 <LoganCapaldo> I was accidently relying on something
17:47:55 <LoganCapaldo> not on purpose :)
17:48:05 <ddarius> LoganCapaldo: That's what usually happens.
17:49:40 <sorear> @users
17:49:40 <rahaskella> Maximum users seen in #haskell: 398, currently: 373 (93.7%), active: 14 (3.8%)
17:50:46 <esteban3> parents do make me go insane :(
17:50:55 <esteban3> no no..
17:51:00 <esteban3> parentesis
17:51:10 <esteban3> sorry.. my english sometimes doesn't obey me :(
17:51:10 <Igloo> parentheses?
17:51:47 <esteban3> too much for today.. i practised all that i had
17:51:51 <idnar> heh
17:51:58 <ddarius> I don't know, parents do make me go insane too quite often.
17:52:07 <esteban3> well, that too, ddarius
17:56:40 <esteban2> one more thing
17:56:46 <esteban2> (.) f(a) func fs a
17:56:49 <esteban2> is this correct?
17:57:11 <dibblego> no wonder they're driving you crazy :)
17:57:12 <esteban2> i want to apply a list of functions to one element
17:57:26 <esteban2> this is the proto: func::[(a->b)]->Int->Int
17:57:54 <esteban2> example: func [(*3),(*2)] 2 = 12
17:57:57 <esteban2> just a hint :)
17:58:10 <scandal> how are you combining the values of each function?
17:58:22 <ari> > map ($ 1) [succ, id, pred]
17:58:23 <Toxaris> > [(* 3), (* 2)] <*> [2]
17:58:24 <rahaskella>  [2,1,0]
17:58:25 <rahaskella>  [6,4]
17:58:35 * idnar doesn't understand where 12 comes from
17:58:57 <hpaste>  esteban3 pasted "list of functions applied to one element" at http://hpaste.org/2601
17:59:31 <Toxaris> esteban3: what's wrong with infix notation for operators?
17:59:36 <sorear> foldr!
17:59:38 <Toxaris> f a . func fs a
17:59:42 <dibblego> missing func []
17:59:52 <Toxaris> no need for parens :)
17:59:57 <esteban2> oh.
17:59:59 <idnar> :foldr ($) 2 [(*3),(*2)]
18:00:08 <esteban2> i forget about the infix notation
18:00:11 <sorear> > foldr (.) id [ (*3), (*2) ] 2   -- esteban2
18:00:12 <rahaskella>  12
18:00:18 <idnar> er yeah, that
18:00:35 <olsner> is rahaskella the replacement-lambdabot of the evening?
18:01:02 <ari> olsner: That would seem to be the case
18:01:02 <idnar> @pl \fs x -> foldr ($) x fs
18:01:03 <rahaskella> flip (foldr id)
18:01:13 <sorear> olsner: Yes.  ari++
18:01:38 <olsner> why does lambdabot disappear so often?
18:01:39 * sorear wonders why there were no such questions back in the sorear-lambdabot days a few months ago
18:01:45 <nominolo> @karma ari
18:01:45 <rahaskella> ari has a karma of 2
18:03:20 <esteban2> whats the diff between foldr and foldl? left and right what?
18:03:39 <esteban2> left and right evaluation?
18:04:04 <esteban2> yes.. it seems so
18:04:07 <sjanssen> @whois rahaskella
18:04:08 <rahaskella> Unknown command, try @list
18:04:09 <Toxaris> esteban2: "folding direction"
18:04:20 <pgavin> @src foldr
18:04:20 <rahaskella> foldr k z xs = go xs
18:04:20 <rahaskella>     where go []     = z
18:04:20 <rahaskella>           go (y:ys) = y `k` go ys
18:04:23 <pgavin> @src foldl
18:04:23 <rahaskella> foldl f z xs = lgo z xs
18:04:23 <rahaskella>     where lgo z []     =  z
18:04:23 <rahaskella>           lgo z (x:xs) = lgo (f z x) xs
18:04:23 <esteban2> yes.. i noticed that
18:04:27 <SamB_XP_> sorear: because we already knew it was because lambdabot is more unstable than Windows?
18:04:28 <esteban2> > foldr (/) 3 [1,2,3]
18:04:30 <rahaskella>  0.5
18:04:32 <esteban2> > foldr (\) 3 [1,2,3]
18:04:32 <rahaskella>  Parse error
18:04:36 <esteban2> > foldl (/) 3 [1,2,3]
18:04:38 <rahaskella>  0.5
18:04:42 <SamB_XP_> ... not that that's hard anymore ;-)
18:04:42 <esteban2> > foldr (/) 3 [1,2,3]
18:04:44 <rahaskella>  0.5
18:04:51 <sorear> esteban2: it's not random
18:04:54 <esteban2> > foldl (/) 2 [1,2,3]
18:04:56 <rahaskella>  0.3333333333333333
18:04:56 <esteban2> > foldr (/) 2 [1,2,3]
18:04:58 <rahaskella>  0.75
18:04:59 <sorear> esteban2: it gives the same answer every time
18:05:06 <esteban2> no..
18:05:09 <esteban2> look
18:05:11 <esteban2> > foldr (/) 2 [1,2,3]
18:05:12 <pgavin> esteban2, externally, they're the same
18:05:12 <rahaskella>  0.75
18:05:14 <esteban2> > foldl (/) 2 [1,2,3]
18:05:16 <rahaskella>  0.3333333333333333
18:05:26 <sorear> 18:03 < esteban2> > foldr (/) 3 [1,2,3]
18:05:36 <sorear> 18:04 < esteban2> > foldr (/) 3 [1,2,3]
18:05:37 <esteban2> with 3 it gives the same answer
18:05:41 <esteban2> not with 2
18:05:44 <esteban2> > foldl (/) 2 [1,2,3]
18:05:45 <rahaskella>  0.3333333333333333
18:05:46 <esteban2> > foldr (/) 2 [1,2,3]
18:05:47 <pgavin> yes, because / isn't associative
18:05:48 <rahaskella>  0.75
18:05:52 <idnar> that's basically coincidental
18:06:16 <pgavin> ((2/1)/2)/3
18:06:18 <pgavin> > ((2/1)/2)/3
18:06:19 <rahaskella>  0.3333333333333333
18:06:42 <pgavin> > 2/(1/(2/3))
18:06:44 <rahaskella>  1.3333333333333333
18:06:57 <pgavin> I did that wrong :)
18:07:23 <pgavin> > 1/(2/(3/2))
18:07:25 <rahaskella>  0.75
18:07:30 <pgavin> there we go :)
18:07:58 <LoganCapaldo> > 1/2/3/4
18:08:00 <rahaskella>  4.1666666666666664e-2
18:08:33 <esteban2> > foldr (.) id [ (*3), (*2) ]
18:08:35 <rahaskella>  <Integer -> Integer>
18:08:38 <esteban2> > foldr (.) id [ (*3), (*2) ] 2
18:08:40 <rahaskella>  12
18:08:41 <ddarius> @where foldr
18:08:41 <rahaskella> I know nothing about foldr.
18:09:08 <esteban2> what is "id" supposed to mean in > foldr (.) id [ (*3), (*2) ] 2 ?
18:09:15 <ddarius> @src id
18:09:15 <idnar> :t id
18:09:15 <rahaskella> id x = x
18:09:18 <rahaskella> forall a. a -> a
18:09:37 <LoganCapaldo> @where+ foldr http://foldr.com/
18:09:37 <rahaskella> Done.
18:09:52 <pgavin> lol
18:10:06 <esteban2> lol
18:10:14 <pgavin> @where foldl
18:10:14 <rahaskella> I know nothing about foldl.
18:10:24 <idnar> heh cute
18:10:30 <ramza3> I have an allocated array, something along the lines of  "buf <- allocaArray n"  ... how would I access elements in buf.  I tried ...buf(0, 1) for example
18:10:31 <LoganCapaldo> @where+ foldl http://foldl.com/
18:10:31 <pgavin> @where+ foldl http://foldl.com/
18:10:31 <rahaskella> Done.
18:10:31 <rahaskella> Done.
18:10:40 <pgavin> lollerskates
18:11:08 <_joshua> oh god now i have to click forever
18:11:13 <idnar> hahaha
18:11:25 <Olathe> Make a program to click forever for you.
18:11:39 <_joshua> that will take forever to write!
18:11:44 <esteban2> lol
18:11:55 <idnar> _joshua: no, just to run
18:11:56 <esteban2> thats cool
18:12:20 <_joshua> idnar: no, i have a program that will tell me if another program will take forever to run and if so, not run it.
18:13:02 <idnar> _joshua: what happens when that program takes forever to run!
18:13:13 <LoganCapaldo> wasn't there a site with pretty diagrams too?
18:13:23 <LoganCapaldo> I can't find it now
18:13:30 <sorear> @go Cale fold diagarams
18:13:31 <rahaskella> http://en.wikipedia.org/wiki/Image:Fold-diagrams.svg
18:13:39 <_joshua> it returns immediately
18:13:55 <_joshua> i would paste the source code, but there isn't room here
18:14:01 <idnar> heh
18:14:01 <LoganCapaldo> sorear, yeah
18:14:18 <LoganCapaldo> but I thought there was a page with just those diagrams...
18:14:30 <ddarius> @where fold
18:14:30 <rahaskella> I know nothing about fold.
18:14:47 <sorear> @go fold diagarams site:cale.yi.org
18:14:48 <rahaskella> No Result Found.
18:15:02 <LoganCapaldo> :(
18:16:05 <nominolo> > let ts = 2 : 3 : 4 : zipWith3 (\x y z -> x + y + z) ts (tail ts) (drop 2 ts) in take 10 ts
18:16:07 <rahaskella>  [2,3,4,9,16,29,54,99,182,335]
18:16:09 <byorgey> ramza3: use !
18:16:18 <byorgey> ramza3: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html#3
18:16:19 <rahaskella> http://tinyurl.com/yet7dx
18:16:23 <ramza3> byorgey, hmm, why does it say it is out of scope
18:16:39 <LoganCapaldo> http://cale.yi.org/index.php/Fold_Diagrams
18:16:42 <LoganCapaldo> :)
18:16:42 <rahaskella> Title: Fold Diagrams - CaleWiki
18:16:57 <LoganCapaldo> Oh sure
18:17:02 <byorgey> ramza3: maybe paste the code you are having trouble with on hpaste?
18:17:05 <LoganCapaldo> just when I find it is when he joins
18:17:08 <ddarius> @where+ fold http://cale.yi.org/index.php/Fold_Diagrams
18:17:08 <rahaskella> Done.
18:17:09 <byorgey> @hpaste
18:17:10 <rahaskella> Haskell pastebin: http://hpaste.org/new
18:17:41 <nominolo> > let ts = 1 : 2 : 3 : 4 : zipWith4 (\x y z o -> x + y + z + o) ts (tail ts) (drop 2 ts) (drop 3 ts) in take 13 ts
18:17:43 <rahaskella>  [1,2,3,4,10,19,36,69,134,258,497,958,1847]
18:18:07 <byorgey> of course, none of these @where+ additions are going to be saved when the real lambdabot comes back...
18:18:34 <LoganCapaldo> but the real lambdabot has them already, doesn't she?
18:18:36 <nominolo> > let ts = 1 : 2 : 3 : 4 : zipWith4 (\x y z o -> x + y + z + o) ts (tail ts) (drop 2 ts) (drop 3 ts) in scan sum $ take 10 ts
18:18:37 <rahaskella>   Not in scope: `scan'
18:18:42 <LoganCapaldo> @quote
18:18:42 <rahaskella> kolmodin says: I would rather lose my left arm than write it in Java
18:18:43 <nominolo> > let ts = 1 : 2 : 3 : 4 : zipWith4 (\x y z o -> x + y + z + o) ts (tail ts) (drop 2 ts) (drop 3 ts) in scanl sum $ take 10 ts
18:18:43 <rahaskella>      Occurs check: cannot construct the infinite type: a = b -> [a]
18:18:44 <rahaskella>     Proba...
18:18:52 <nominolo> :t scanl
18:18:54 <rahaskella> forall a b. (a -> b -> a) -> a -> [b] -> [a]
18:19:01 <byorgey> LoganCapaldo: oh, I didn't know that, ok
18:19:10 <nominolo> :t scanr
18:19:12 <rahaskella> forall a b. (a -> b -> b) -> b -> [a] -> [b]
18:19:13 <LoganCapaldo> well I'm not sure
18:19:17 <LoganCapaldo> I'm just guessing
18:19:29 <LoganCapaldo> but it seems like something she would've accumlated already
18:19:30 <byorgey> Cale: you should make one of those diagrams for mapAccumL
18:21:15 <hpaste>  ramza3 pasted "(no title)" at http://hpaste.org/2602
18:21:32 <ramza3> byorgey, http://hpaste.org/2602
18:25:05 <byorgey> ramza3: in that code, buf is a list, not an array, so you should use !!
18:25:31 <byorgey> ramza3: but in any case you can't put buf !! 1 there anyway, since it isn't an IO action
18:25:32 <ramza3> oh
18:25:44 <byorgey> maybe you mean something like putStrLn (buf !! 1)?
18:26:21 <ramza3> byorgey, I was trying to take the first byte from the loaded file
18:26:48 <byorgey> ramza3: well in that case you want (buf !! 0)  =)
18:26:57 <ddarius> Better known as head
18:28:19 <byorgey> ramza3: if that's all you want to do, you really don't need all that crazy foreign/marshalling stuff
18:28:46 <byorgey> ramza3: at least, I don't think you do
18:28:50 <dibblego> ?check \xs -> xs !! 0 == head (xs :: [Int])
18:28:51 <rahaskella>  Exception: Prelude.(!!): index too large
18:29:02 <dibblego> ?check \xs -> not (null xs) ==> xs !! 0 == head (xs :: [Int])
18:29:04 <rahaskella>  OK, passed 500 tests.
18:29:37 <byorgey> ramza3: you can just use things like hGetContents, hGetChar, and so on
18:30:10 <byorgey> unless there's some problem with reading files in binary vs. text mode?  anyone please feel free to jump in and correct me =)
18:30:54 <_fang> hello all!!!
18:31:10 <byorgey> hi _fang!
18:31:35 <_fang> i'm in need of a integer square root function to take to the class but couldn't manage to put anything to work in haskell
18:31:49 <_fang> can anyone give me a hint?
18:32:05 <dibblego> ?src sqrt
18:32:05 <rahaskella> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:32:45 <_fang> i need the integer square root, not the ordinary one xD
18:32:55 <dibblego> ?type sqrt
18:32:57 <rahaskella> forall a. (Floating a) => a -> a
18:33:25 <_fang> it was kinda easy to make it the imperative way, but i just can't think in haskell xD
18:33:32 <Cale> byorgey: good idea
18:33:36 <ddarius> hpaste your imperative code
18:34:36 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2570#a2
18:35:11 <tphyahoo> caker: seems like there are no swaps.
18:35:12 <hpaste>  _fang pasted "isqrt" at http://hpaste.org/2603
18:35:26 <_fang> http://hpaste.org/2603
18:35:26 <_fang> oops
18:35:26 <_fang> xD
18:35:26 <_fang> sry
18:36:10 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2570#a3
18:36:56 <_fang> there are some restrictions to use functions like floor and sqrt from prelude
18:37:19 <tphyahoo> caker: http://hpaste.org/2570#a3
18:37:35 <tphyahoo> disregard that, wrong channel
18:38:19 <hpaste>  ddarius annotated "isqrt" with "imperative to functional fact" at http://hpaste.org/2603#a1
18:38:42 <ddarius> _fang: You mean "not to use"?
18:39:23 <_fang> ddarius: yes =]
18:39:36 <ddarius> _fang: At any rate, the code I pasted takes an imperative C implementation of factorial and produces a functional equivalent.  You should be able to see how to do it for your problem.
18:40:06 <ddarius> (there's actually a slight issue with the Haskell code, but I'm going to ignore it at this point)
18:40:33 <byorgey> _fang: after you do that, as an improvement you may want to see if you can do it without using floating-point numbers =)
18:40:51 <byorgey> _fang: that way it would work for arbitrarily large integers; with floating-point there is a limit
18:42:36 <_fang> well... i couldn't figure out.... from where did the var "i" come from???
18:43:04 <ddarius> _fang: ?
18:43:15 <_fang> fact n = fact' 1 1
18:43:15 <_fang>     where fact' acc i
18:43:39 <ddarius> _fang: That where clause is defining a function fact' with parameters acc and i.
18:45:20 <_fang> hmmm
18:46:16 <_fang> it's getting clearer =D
18:47:43 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2570#a4
18:52:23 <ddarius> :t until
18:52:25 <rahaskella> forall a. (a -> Bool) -> (a -> a) -> a -> a
18:52:58 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2570#a5
18:53:30 <ddarius> > let fact n = fst $ until ((<=n) . snd) (\(acc,i) -> (i*acc,i+1)) (1,1) in fact 5
18:53:31 <rahaskella>  1
18:53:45 <ddarius> > let fact n = fst $ until ((>n) . snd) (\(acc,i) -> (i*acc,i+1)) (1,1) in fact 5
18:53:47 <rahaskella>  120
18:54:38 <mudge> hello
18:57:07 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/2570#a6
18:58:02 <Cale> how informative
18:58:09 <mudge> @seen novaburst
18:58:09 <rahaskella> I haven't seen novaburst.
18:58:34 <mudge> was I asking you rahaskella?
18:58:43 <mudge> I was asking lambdabot
18:58:56 <mudge> novaburst: you around?
18:58:57 <sorear> mudge: Why are you upset?
18:59:05 <sorear> mudge: rahaskella *is* lambdabot!
18:59:09 <mudge> haha!
18:59:18 <mudge> no, I'm not upset
18:59:28 <sorear> @listservers
18:59:28 <rahaskella> freenode worldirc
18:59:43 <mudge> does lambdabot have a new name now?
19:00:00 <sorear> Yes.
19:00:04 <sorear> And a new operator.
19:00:22 <mudge> who's the new operator?
19:00:26 <LoganCapaldo> she's a smooth operator
19:00:37 <mudge> what's the new operator?
19:00:38 <sorear> Ari Rahikkala
19:00:39 <ddarius> infinitely differentiable
19:03:22 <mudge> hey,  i was looking for any females in this channel,  and the only one I can tell from looking at the nicks is audreyt
19:03:52 <mudge> interesting,  I just found out today that audreyt is the person who wrote pugs,  the perl system
19:04:01 <mgsloan> yeah, pretty hardcore
19:04:02 <[azoic]> nowai
19:04:11 * allbery_b notes that troolling IRC channels is the wrong way to pick up checks :)
19:04:18 <allbery_b> chicks, even
19:04:47 <Cale> mudge: What about Philippa?
19:05:24 <mudge> yea,  but i also found out that audreyt is only kind of a girl,    she's a transvestite,  got physically changed
19:06:01 <mudge> Cale: ah yea, maybe Philippa
19:06:22 <chessguy> hi gang
19:06:28 <chessguy> @bot
19:06:28 <rahaskella> :)
19:06:33 <chessguy> @seen lambdabot
19:06:33 <rahaskella> I saw lambdabot leaving #haskell 4h 12m 11s ago, and .
19:07:04 <mudge> hi chessguy
19:07:14 <Philippa> mudge: she's not a transvestite, I suspect you don't quite know what the word means
19:07:16 <mudge> i feel like lambdabot died, and now we have a new pet
19:07:25 <mudge> Philippa,  yea maybe
19:07:53 <mudge> Philippa:  my undertanding is that she was a man,  and got some physical changes to be more of a girl
19:08:19 <sorear> transvestites is AIUI a fancy word for cross-dresser
19:08:26 <mudge> oh, i see
19:08:31 <mudge> what's this called then?
19:08:46 <mainland> transexual
19:08:52 <allbery_b> transgendered?
19:08:55 <mainland> or that
19:09:07 <__nasa__> How do you pronounce the new lambdabot?
19:09:07 <Philippa> TG's an umbrella term, can mean a whole bunch of things
19:09:11 <mudge> oh yea,  that's what I meant,  transexual
19:09:25 <mudge> Philippa,  are you a woman?
19:09:27 <Igloo> Please take this somewhere it's on-topic
19:09:37 <sorear> mudge: there's also mux, I don't know any guys named Maxime but I suppose it could happen
19:09:55 <sorear> #haskell-blah definitely qualifies
19:10:33 <mudge> sorear: thanks
19:10:57 <Philippa> mudge: you've been told that already
19:11:20 <mudge> Philippa: oh okay
19:11:26 <mgsloan> doesn't really matter all that much anyway, does it?
19:11:26 <_fang> http://hpaste.org/2603#a2
19:11:40 <_fang> i got a unresolved overloading there...
19:11:45 <mudge> mgsloan: no it doesn't
19:14:22 <Cale> _fang: is it an integer square root, or a floating point one?
19:14:28 <shapr> Is lambdabot gone for good?
19:14:33 <Cale> _fang: the comparison with 0.5 is what's confusing it
19:15:09 <_fang> Cale: meh! i forgot the 0.5 lol!!! thanks =DDDD
19:15:54 <dibblego> @join #jtiger
19:15:54 <rahaskella> Not enough privileges
19:16:04 <sorear> ari: ping
19:16:19 <_fang> Cale: i used the 0.5 to test the floating point one and forgot about that!!!! thanks a lot!!! =D
19:16:29 <Cale> _fang: no problem :)
19:29:49 <mudge> anyone doing any webprogramming with haskell right now?
19:29:49 <shapr> I'm hacking on HAppS, does that count?
19:29:49 <mudge> shapr: always counts ;)
19:29:49 <mudge> shapr: how big is happs?  how many lines of code?
19:29:49 <shapr> mudge: About 7k
19:29:49 <mudge> shapr: cool   I really want to write my own web server in haskell,   I wonder if happs might be something good for me to study to learn more about writing webservers and stuff in haskell
19:29:49 <shapr> I don't know. Have you written any network servers in Haskell?
19:29:49 <mudge> shapr: no I haven't,   I'm jumping the gun talking about learning to write webservers as I'm not doing that yet,  I'm doing all the exercises in the book Programming in Haskell,   but I'm keeping abreasts of web projects to study in the future
19:29:49 <mudge> abreast
19:29:49 <shapr> Good idea
19:29:49 <ddarius> I don't know... a simple webserver is about the simplest network server you could write.
19:29:49 <mudge> ddarius, thanks
19:29:49 <mudge> i've got a list of webserver projects to study: * jcreigh googles
19:29:49 <mudge> http://del.icio.us/mudgen/haskell%2Bwebserver
19:29:49 <rahaskella> Title: mudgen's bookmarks tagged with "haskell+webserver" on del.icio.us
19:29:49 <ari> sorear: pong
19:29:49 <mudge> there's a paper by simon marlow about webservers in haskell,  but i don't know where it is on the web
19:29:55 <sorear> @go Haskell web server
19:29:59 <rahaskella> http://darcs.haskell.org/hws/
19:29:59 <rahaskella> Title: Index of /hws
19:30:11 <sorear> @go Tackling the awkward squad
19:30:13 <rahaskella> http://research.microsoft.com/users/Cambridge/simonpj/Papers/marktoberdorf/
19:30:13 <rahaskella> Title: Simon Peyton Jones: papers
19:31:39 <ari> Oh, I see
19:32:34 <shapr> Is there some way I can run multiple subshells at once from a single shell script, and have them all die when I hit C-c ?
19:32:34 <newsham> are there docs for runhaskell/runghc cmd line usage?
19:32:35 <sfultong> @bot
19:32:36 <rahaskella> :)
19:32:58 <shapr> if I do ( command ) in a bash script, it waits for that to return.
19:33:13 <shapr> if I do ( command & ), then it doesn't die when I kill the top level script.
19:33:23 <sorear> shapr: ( command) &  ?
19:33:28 <shapr> hm, might work!
19:33:45 <FMota> Cale's diagrams rock.
19:34:03 <Cale> FMota: thanks! :)
19:34:07 <FMota> ;)
19:34:11 <newsham> is there a way to specify a -main-is for runhaskell?
19:34:47 <thoughtpolice> i thought that the file you invoke it on was implied to be Main?
19:35:32 <newsham> newsham@lenoxp2$ runhaskell HttpParsec.hs
19:35:32 <mudge> sorear: thanks for the webserver doc
19:35:32 <newsham> <interactive>:1:80: Failed to load interface for `Main':
19:36:35 <mgsloan> Inkscape ftw
19:36:42 <goalieca> :-)
19:37:00 * mgsloan just finished up an inkscape related project - http://mgsloan.nfshost.com/boolops/
19:37:01 <rahaskella> Title: Boolean Operations Project
19:37:31 <thoughtpolice> newsham: from a quick test seemed to work for me
19:37:43 * LoganCapaldo karma vampires off of Cale
19:38:00 <newsham> thought: even if your file doenst have "module Main" in it?
19:38:13 <thoughtpolice> newsham: yeah, just tried it with and without
19:38:24 <newsham> doesnt work on my system using 6.6.1
19:38:25 <sfultong> what's the effect of being a karma vampire on one's karma?
19:38:39 <LoganCapaldo> I think nothing
19:38:47 <LoganCapaldo> no that's not true
19:39:01 <LoganCapaldo> now Cale can't submit the link himself to get the karma
19:39:18 <Cale> submit?
19:39:20 <LoganCapaldo> to be honest i was surprised it went thru, I thought for sure dons woulda posted it at some point :)
19:39:42 <LoganCapaldo> Cale, I put your fold diagrams on programming.reddit
19:39:46 <Cale> Oh
19:39:50 <thoughtpolice> newsham: http://pastebin.com/m43abda25
19:39:52 <Cale> heh, I've mentioned them in comments before
19:40:10 <Cale> I never really thought to submit them, since there isn't really very much text there.
19:40:21 <newsham> yours says "module Main"
19:40:27 <newsham> oh, wait, the other one doesnt
19:41:19 <newsham> thought: try this?  http://www.thenewsh.com/%7Enewsham/HttpParsec.hs
19:41:30 <newsham> you're using 6.6.1?
19:41:33 <shapr> sorear: seems to work!
19:41:43 <thoughtpolice> newsham: just a sec,
19:42:32 <newsham> oh, you're only runghc'ing a modle that says"module Main" in it!
19:43:08 <thoughtpolice> newsham: it's because the module decl at the file is "module HttpParsec where..."
19:43:27 <newsham> yah, my question is how to specify to execute the main from that
19:43:37 <thoughtpolice> hm oh right.
19:43:53 <newsham> isn't that what -main-is is for?
19:45:57 <sfultong> @seen
19:46:07 <thoughtpolice> newsham: hm yes, let's you specify main module and func
19:48:55 <thoughtpolice> newsham: -main-is works fine with just ghc or --make but apparently it's not recognized by runghc/runhaskell
19:49:07 <reffie> http://www.bat-test.com/
19:49:08 <rahaskella> Title: Bionic Assessment Test
19:49:35 <Pseudonym> Quick, Robin!  To the Bat Test!
19:49:43 <reffie> heh.
19:50:58 <thoughtpolice> newsham: the HEAD docs specify you can give a "--" to runghc to specify where the runghc flags end and the ghc flags begin, but I guess only the HEAD version supports it. :/
19:52:30 <ddarius> reffie: The first one is even more twisted with a dvorak layout.
19:52:58 <goalieca> they should do a mythbusters on dvorak
19:53:25 <newsham> hmm
19:53:34 <dons> ?yow
19:53:35 <rahaskella> Couldn't find fortune file
19:53:46 <newsham> ?farber
19:53:47 <rahaskella> Unknown command, try @list
19:53:52 <dons> fixing..
19:53:54 <Pseudonym> You mean did he realy write his 9th Symphony?
19:58:16 <shapr> goalieca: Dvorak works for me since 1992.
19:58:45 * sfultong is also a dvorak user
19:59:08 <goalieca> shapr: what i'm suggesting is that dvorak probably doesn't save any time in real-world conditions
19:59:48 <Olathe> It's nice for confusing people that sit at your computer, though.
20:00:09 <goalieca> but are there any ergonomic differences?
20:00:41 <shapr> goalieca: Yeah, there are.
20:00:54 <ddarius> goalieca: My experience is that I do not type much faster, but it does feel noticeably more comfortable.
20:01:11 <shapr> goalieca: The most used vowels are on the left hand home row, and the most used consonants are under the home row right hand.
20:01:29 <shapr> aoeu <- left hand home row, htns <- right hand home row.
20:01:53 <pgavin> anyone here using erc?
20:02:00 <shapr> To me, it looks like qwerty users are jumping all over the keyboard to get anything done.
20:02:02 <shapr> pgavin: I use it.
20:02:14 <pgavin> I just installed it... seems pretty cool
20:02:16 <goalieca> see.. comfort is something i can agree on. Why the hell is e all the way up there on qwerty. I end up using the top row and pounding my fingers in
20:02:26 <pgavin> now I can do everything I need to from emacs
20:02:43 <pgavin> plus now multi-tty works
20:02:46 <pgavin> :)
20:02:48 <mudge> i've been studying Programming in Haskell,   and one thing I've had some difficulty is figuring out how some of the recursive functions work,   I was wondering if there is a system or a tool that shows iterations of recursive functions so you can understand exactly how it works
20:03:20 <coffeemug> wow
20:03:23 <coffeemug> Luciano Pavarotti passed away :(
20:03:25 <pgavin> yeah, its amazing... even my programming languages teacher seems to have a hard time with recursion
20:04:02 <shapr> Seems strange to me that iteration seems easier than recursion for most people.
20:04:06 <pgavin> coffeemug: and who will sing at his funeral? :)
20:04:13 <mudge> and the recursions seems to get more abstract when you enter in the monad do notation
20:04:16 <coffeemug> heh
20:04:18 <coffeemug> that's evil :)
20:04:41 <goalieca> shapr: same with me. iteration is tricky. but then again i have a math background
20:04:52 <shapr> goalieca: The original dvorak layout had the left and right halves of the numbers swapped, because zero and one are the most common numbers.
20:05:02 <shapr> I have an art background...
20:05:04 <mudge> shapr: maybe you're natively recursive
20:05:13 * shapr calls himself to find out...
20:05:14 <pgavin> mudge: eventually monads get to be just as easy (easier even) as plain C or scheme
20:05:25 <shapr> easier!
20:05:29 <shapr> very much easier!
20:05:33 <Pseudonym> I'm natively (I'm natively (I'm natively (I'm natively (...))))
20:05:33 <pgavin> yes
20:05:34 <Olathe> Whenever I call myself, it turns out I'm busy :(
20:05:42 <shapr> Olathe: I have two phones :-)
20:05:50 <Olathe> Oh, that was the bug.
20:05:51 <sorear> 19:15 < dibblego> @join #jtiger
20:05:51 <sorear> 19:15 < dibblego> @join #jtiger
20:05:53 <sorear> 19:15 < dibblego> @join #jtiger
20:05:55 <sorear> 19:15 < dibblego> @join #jtiger
20:05:55 <sorear> 19:15 < dibblego> @join #jtiger
20:06:00 <shapr> sorear: um?
20:06:10 <sorear> misalignment :(
20:06:11 <mudge> you guys are funny
20:06:22 * shapr aligns sorear at an eight bit boundary.
20:06:35 * sorear goes and replaces the batteries in his mouse
20:06:35 <mudge> no but do you guys know of some tool or method,   like maybe UML for recursion?
20:06:43 <shapr> My brain is small, you see.. that's why it's not aligned at 32 or 64 bits...
20:06:51 <shapr> mudge: Have you seen the length function?
20:06:53 <goalieca> mudge: look at a tree.
20:06:54 <mudge> when your are trying to figure out something really recursive,  how do you figure it out?
20:07:14 <mudge> a tree?
20:07:16 <sorear> ghci
20:07:19 <hpaste>  _fang pasted "error!!!" at http://hpaste.org/2604
20:07:23 <goalieca> mudge: ya a tree. how do you traverse a tree
20:07:28 <_fang> can someone help me with this???
20:07:30 <mudge> yea, I've seen a definition of a length function
20:07:40 <pgavin> mudge: think about the last thing your function needs to do
20:07:54 <pgavin> mudge: for length, it will be calculating the length of []
20:08:00 <pgavin> mudge: which is zero :)
20:08:06 * goalieca often thinks about recursion as induction
20:08:08 <sorear> _fang: Yes.
20:08:15 <pgavin> goalieca: of course :)
20:08:23 <mudge> okay
20:08:23 <sorear> _fang: dias == 1 should be x == 1, etc.
20:08:27 <Philippa> goalieca: well yeah, primitive recursion /is/ induction
20:08:54 <sorear> Well-founded recursion is complete induction
20:09:21 <_fang> sorear: duh!!! >.< quite an easy one!!! i'll try somethin' more difficult next time xD
20:09:21 <shapr> mudge: Most recursion is 1) Do I stop now? 2) get one step closer to stop.
20:09:32 <_fang> sorear: thank you!!! o/
20:09:45 <mudge> thanks
20:09:48 <shapr> base case; step
20:09:59 <mudge> you guys know the easiest,  best monad tutorial?
20:10:24 <shapr> mudge: I'd suggest sigfpe's "You could have invented monads, (you may have already!)
20:10:51 <mudge> shapr: thanks
20:11:28 <Cale> heh, did mapAccumL
20:11:34 <Cale> Let me export it :)
20:11:37 <pgavin> shapr: its funny, because I didn't understand monads until I accidentally implemented one :)
20:12:12 <goalieca> mudge: take the towers of hanoi. the solution is to solve the problem with one less disk
20:12:15 <Cale> http://cale.yi.org/autoshare/mapAccumL.png
20:12:19 <goalieca> roughly speaking of course
20:12:27 <Cale> Still needs a little cleaning up
20:13:05 <sorear> http://members.cox.net/stefanor/hanoi.v -- recursion is induction
20:14:44 <mudge> thanks
20:14:58 <mudge> I like the approach of inventing monads to understand them
20:16:13 <mudge> Cale: thanks for the image,  gives me an idea of how to visualize recursion
20:16:53 <byorgey> Cale: neat =)
20:19:12 * idnar scratches his head
20:19:13 <byorgey> sorear: what language is that?
20:19:52 <sorear> byorgey: Coq, one of several dependantly typed total functional languages created to exploit the Curry-Howard isomorphism.
20:19:55 <pgavin> @seen dcoutts
20:19:55 <rahaskella> dcoutts is in #haskell. I last heard dcoutts speak 3h 14m 59s ago.
20:20:03 <idnar> these curvy arrows are confusing ;)
20:20:23 <byorgey> sorear: ah, that's what I was going to guess.
20:20:31 <shapr> pgavin: Yeah, that's a good way to learn monads.
20:20:43 * byorgey intends to get around to learning Coq sometime Real Soon Now.
20:21:45 <shapr> Does MacOS X support inotify, or something like it?
20:22:32 <byorgey> Cale: maybe add an annotation that f x acc = (f1 x acc, f2 x acc)?
20:22:37 <Cale> yeah
20:23:00 <byorgey> or else you can explain that in some accompanying text I suppose
20:23:20 <araujo> yaaaayyay
20:23:37 * araujo l0ves the Haskell language
20:24:04 <goalieca> shapr: yes
20:24:08 <goalieca> i can't remember what it is called
20:24:09 <mainland> shapr: it might support kqueue?
20:24:19 <mainland> ala freebsd
20:24:41 <allbery_b> http://www.kernelthread.com/software/fslogger for example
20:24:46 <araujo> so beautiful to just code in your mind, throw the code in the keyboard, and get the thing properly working right away
20:24:50 <allbery_b> I think it uses a Mach port, but don't quote me
20:25:03 <allbery_b> (roughly similar to kqueue)
20:25:27 * araujo makes a forbidden lambda sacrifice 
20:29:09 <byorgey> araujo: =)
20:34:38 <Cale> http://cale.yi.org/autoshare/mapAccumR.png
20:35:08 <Cale> That's getting a little tricky to wire :)
20:36:13 <Cale> f's parameters for mapAccumR are "backwards"
20:36:57 <Cale> of course, they align with the parameters for f in mapAccumL, but that's not necessarily the right thing.
20:38:45 <Tac-Tics2> Cale, you've got a broken link on your site
20:38:46 <Tac-Tics2> http://www.haskell.org/hawiki/HaskellNewbie_2fObjectOrientedVsFunctionalProgramming
20:38:47 <rahaskella> http://tinyurl.com/27offf
20:39:00 <Tac-Tics2> it sounds interesting, I'm wondering if it was just moved?
20:39:08 <Cale> Tac-Tics2: yeah, there's not much I can do about it but remove the link
20:39:33 <Cale> hawiki is gone, and I'm not sure if that got moved -- it included text from someone who wasn't me as well.
20:39:38 <Tac-Tics2> It feels like the majority of Haskell-related web pages have broken links, sadly
20:39:51 <Cale> Yeah, they really should put hawiki back.
20:40:22 <Cale> There's not much that can be done to move most of the text that was on it because it was not explicitly licensed.
20:45:24 <ari> dons: ping
21:07:23 <mudge> err,  I don't get how this unzip function works: http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html#let
21:07:25 <rahaskella> Title: Tour of the Haskell Syntax, http://tinyurl.com/kf5wj
21:08:00 <Cale> mudge: what are you stuck on?
21:08:20 <mudge> i'm stuck on the let
21:08:36 <mudge> how let works with the recursion in unzip
21:08:43 <Cale> Okay, so it defines (as,bs) as the pair which is obtained by applying unzip to rest
21:09:01 <Cale> and then the result is (a:as, b:bs)
21:10:00 <Cale> So for example
21:10:19 <Cale> If unzip is applied to [(1,10),(2,20),(3,30)]
21:10:39 <mudge> yea,   so if you had   [(1,2), (3,4)]   the first part would make it into    [1,3], [2,4]
21:10:40 <Cale> then  (as,bs) = unzip [(2,20), (3,30)]
21:10:58 <mudge> yea ...
21:11:02 <Cale> in (1:as, 10:bs)
21:11:26 <Cale> of course, as = [2,3] and bs = [20,30]
21:11:41 <Cale> So the result is ([1,2,3],[10,20,30])
21:12:24 <Cale> Does that make sense now?
21:12:51 <mudge> but how does the as, bs get the rest of the items of each tuple?
21:13:18 <Cale> By applying unzip recursively to the tail.
21:13:53 <Cale> unzip [(2,20), (3,30)] = let (as,bs) = unzip [(3,30)] in (2:as, 20:bs)
21:13:57 <Cale> and then
21:14:24 <Cale> unzip [(3,30)] = let (as,bs) = unzip [] in (3:as, 30:bs)
21:14:32 <Cale> but unzip [] = ([],[])
21:14:47 <Cale> so unzip [(3,30)] = (3:[], 30:[])
21:15:03 <Cale> unzip [(2,20), (3,30)] = let (as,bs) = unzip [(3,30)] in (2:as, 20:bs)
21:15:14 <Cale> and we know what unzip [(3,30)] is now
21:15:24 <Cale> it's ([3],[30])
21:15:30 <Cale> so,
21:15:41 <Cale> unzip [(2,20), (3,30)] = (2:[3], 20:[30])
21:15:54 <Cale> and then finally,
21:16:22 <Cale> unzip [(1,10), (2,20), (3,30)] = let (as,bs) = unzip [(2,20), (3,30)] in (1:as, 10:bs)
21:16:46 <Cale> and since we now know what unzip [(2,20), (3,30)] is, we can fully evaluate that too
21:17:04 <Cale> it's (1:[2,3], 10:[20,30])
21:17:15 <Cale> Or ([1,2,3],[10,20,30])
21:17:24 <Cale> Follow all that?
21:18:08 <Cale> You don't necessarily have to be able to follow the complete recursion in order to understand unzip, because you can just trust that unzip does its job correctly on the tail.
21:18:10 <mudge> kind of,   does each (a:as, b:bs)  cause the let function to run?
21:18:18 <newsham> does parsec work with ByteString?  do ByteString optimizations work well with a parsec-type parser?
21:18:28 <Cale> as and bs are only worked out if they're really needed
21:18:59 <Cale> That is, if later on, you come along and demand to know what the third element of the first part of the result is, it'll cause that evaluation to actually occur.
21:19:02 <bos> newsham: parsec does not work with bytestring
21:19:28 <newsham> any reason why it hasnt been made to yet? seems fairly straightforward
21:19:41 <mudge> so that it is like: (num1: num3: num5:[], num2: num4: num36: [])
21:19:48 <bos> sjanssen ported it, but it's not fast
21:20:07 <sjanssen> xerox did/is doing some work on that
21:20:09 <newsham> so the current fusion methods dont integrate well with parsec-style parsing?
21:20:14 <mudge> thanks Cale
21:20:26 <Cale> It's actually just like it reads -- you get something which looks like (a:as, b:bs), where as and bs are pointers to code which will evaluate to a list
21:20:34 <sjanssen> newsham: I think it would be very hard to do fusion on parsing
21:21:00 <newsham> so are there any advantages to using ByteStrings for parsing?  smaller representation?
21:21:14 <sjanssen> dcoutts very recently made some changes to lazy ByteStrings that might speed up my 15 min. parsec hack considerably
21:21:26 <newsham> 15min parsec hack: http://www.thenewsh.com/%7Enewsham/MyParsecBS.hs
21:21:46 <bos> there are disadvantages to using bytestrings for parsing, not many advantages
21:21:52 <Cale> another way you could write it would be:
21:22:15 <mudge> is the (as, bs)  like the name of a function so that,  each time (a:as, b:bs) is ran, the function is called?
21:22:23 <bos> bytestrings are not text strings, and treating them as such is not a good idea
21:22:39 <newsham> bos: in many contexts characters are bytes
21:22:39 <Cale> unzip ((a,b):rest) = let xs = unzip rest in (a : fst xs, b : snd xs)
21:22:56 <bos> newsham: only in the US and europe
21:23:09 <newsham> for example the HTTP rfc is defined on octets with value 0 .. 0xff
21:23:20 <bos> those are not characters, they're octets
21:23:23 <Cale> The unzip rest won't happen unless the value of xs is demanded
21:23:30 <newsham> bos: they are the characters of the HTTP protocol
21:23:39 <Cale> which will only happen if you look beyond the first element of the returned lists
21:24:09 <newsham> for example "GET /foo HTTP/1.0" is a string of 8-bit characters
21:24:19 <newsham> according to the RFC
21:24:54 <mudge> thanks
21:24:56 <Cale> mudge: In some sense, the only thing in Haskell which ever causes any evaluation to occur is case, which is what all pattern matching gets turned into.
21:25:17 <newsham> btw, many other text protocols are similarly defined in terms of byte-sized characters.
21:25:35 <newsham> you can call it euro centric if you want, but thats the way it is
21:25:40 <mudge> Cale: pattering matches get turned into a case statement,   is that what pattern matching is doing?
21:25:52 <Cale> a case-expression
21:26:03 <Cale> It's in deciding whether a pattern matches with some expression that the expression gets evaluated.
21:26:04 <mudge> oh right
21:26:13 <mudge> i get it
21:26:22 <scook0_> bot?
21:26:35 <scook0_> meh
21:26:52 <Cale> case unzip [(1,10),(2,20),(3,30)] of [] -> 0; (x:xs) -> 1
21:27:08 <Cale> This code will cause unzip to be evaluated (by one step)
21:27:24 <Cale> but the recursive case won't get used, because we don't end up using xs
21:27:41 <mudge> Cale: i see
21:27:54 <wli> What of IO?
21:28:11 <Cale> That is, the (as,bs) = unzip rest part of the unzip will just be thrown away
21:28:47 <Cale> Now, you might well ask -- "hey, isn't that (as,bs) = ... a pattern match?"
21:28:59 <Cale> But in fact, there's a little bit of sneakiness here.
21:29:18 <Cale> When you make a pattern binding using let, or where, or at the top level
21:29:37 <Cale> That is, like we have here -- defining some pattern to be equal to some expression
21:29:56 <Cale> Then it makes the pattern match happen lazily
21:30:20 <Cale> So only if you demand one of the variables matched will it actually go and see if the pattern really matches.
21:30:47 <dons> ari?
21:30:59 <bos> evening dons
21:31:07 <Cale> > let [x,y,z] = [10,20] in 5
21:31:09 <rahaskella>  5
21:31:12 <Cale> > let [x,y,z] = [10,20] in x
21:31:14 <rahaskella>   Irrefutable pattern failed for pattern [x, y, z]
21:31:25 <Cale> > let [x,y,z] = [10,20,30] in x
21:31:27 <rahaskella>  10
21:31:38 <thoughtpolice> even in the case of (x:xs) in a case or somesuch it's still WHNF, right (since you're only evaluating so far as to see you can turn the list into a cons like that)?
21:31:55 <ari> dons: I was wondering if lambdabot's ready to return
21:32:17 <Cale> thoughtpolice: yeah, it'll only evaluate the thing as far as it needs to in order to determine if the pattern matches or now
21:32:18 <Cale> not*
21:32:52 <thoughtpolice> cool. just making sure i'm not insane (laziness is still really growing on me.) :)
21:33:07 <Cale> mudge: that might be a lot to take in all at once, but I hope it makes some sense :)
21:33:11 <thoughtpolice> although I appreciated it a bit today in a small little exercise I did.
21:33:16 <mudge> Cale: yea, thanks
21:34:56 <thoughtpolice> hm looks like sleep time.
21:36:08 <mudge> Cale: does (a:as, b:bs) act as a function call?
21:36:28 <mudge> each time (a:as, b:bs) is seen,  it recalls unzip
21:37:00 <mudge> yes, I know,  only if the value is being used or called for,    lets say it is
21:37:00 <Cale> not quite -- it'll only call unzip when something tries to pattern match as or bs against some pattern
21:37:28 <Cale> So it's more like as and bs act like function calls.
21:37:41 <mudge> I get it,  so when something tries to evaluate the as or bs,  then the function call is made
21:37:46 <Cale> right
21:37:56 <mudge> Cale: it is almost like the values as and bs are a function call
21:38:10 <Cale> and it's only made once, if both are eventually evaluated, the result of the unzip rest is shared
21:38:24 <mudge> Cale: it makes sense because the only way to find the values of the as and bs is to make more of the recursive function calls
21:38:33 <Cale> yeah
21:39:19 <oerjan> mudge: these function calls are called "thunks"
21:39:35 <Cale> In fact, in memory (assuming GHC), every variable is a code pointer -- it points to code which runs to return a value. After it runs the first time, that code is replaced with code that just immediately returns the computed result.
21:41:15 <mudge> so the code is changed each time a recursive call is made, to give a different result each time?
21:41:38 <mudge> i got this part:  In fact, in memory (assuming GHC), every variable is a code pointer -- it points to code which runs to return a value
21:41:46 <Cale> nope, it's changed to return the same result :)
21:41:46 <oerjan> actually it is more like a tuple of a further code pointer + arguments
21:41:49 <Cale> (but faster)
21:42:07 <Cale> Because variables never change their value
21:42:19 <Cale> When you define x = 5 + 5
21:42:34 <Cale> The first time x is used, the code for 5 + 5 is run
21:42:48 <Cale> and it builds the value 10
21:42:52 <dibblego> ?instances Monad
21:42:54 <rahaskella> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:43:08 <mudge> Cale: yea...
21:43:08 <Cale> but just before 10 is returned, it replaces the code for x with code that just returns 10 directly
21:43:27 <Cale> So x can only get evaluated at most once
21:43:35 <mudge> makes sense
21:44:06 <mudge> how does it work in the recursive example we're talking about with let?
21:44:53 <Cale> So in our example
21:45:01 <Cale> (as,bs) = unzip rest
21:45:21 <Cale> the first time either as or bs is needed, the code for unzip rest is executed
21:45:31 <mudge> yep ....
21:45:33 <Cale> and it returns some pair as a result
21:45:54 <Cale> and replaces the code which just ran with code that returns that pair immediately
21:46:05 <mudge> makes sense
21:46:05 <Cale> So suppose as is needed first
21:46:11 <Cale> unzip rest is computed
21:46:13 <oerjan> however, the _elements_ of the pair are still pointers to code
21:46:45 <Cale> then when bs is needed, the code just returns that result it computed the first time
21:47:22 <Cale> (and the second component is extracted from it, rather than the first)
21:47:47 <Cale> It's really pretty clever :)
21:49:42 <mudge> okay,  so the unzip is executed one time  giving the result for as,     at this point the code is replaced with code that directly gives gives the value for as
21:50:06 <mudge> then when bs is called for,  it runs the same direct code, but gives the bs value instead of the as
21:50:21 <mudge> right?
21:51:15 <Cale> replaced with code that directly gives the result for (as,bs) actually
21:51:33 <Cale> (that is, the result for  unzip rest)
21:51:48 <mudge> Cale: okay, that makes sense,
21:52:12 <mudge> Cale:  and then what about the next recursion?
21:52:29 <Cale> well, it defines a separate (as,bs)
21:53:06 <mudge> and then does the process again?   finds the value for as, bs   replaces it with direct code,    then goes onto the next recursion?
21:53:15 <Cale> If necessary
21:53:27 <mudge> right,  lazyness
21:53:45 <Cale> Of course, if you're printing out the result of the top-level unzip or something, then it'll eventually force it to evaluate the whole thing
21:53:50 <mudge> if necessary  as in,   if  the as and bs values are being called again?
21:54:14 <mudge> right
21:54:33 <Cale> well, yeah, if a pattern match or something needs to determine whether they're [] or (x:xs)
21:54:43 <mudge> its interesting,  because its like, in this example,  the values are function calls,     like you said,  pointer to code
21:55:05 <Cale> This whole thing about sharing just means that by the time you've finished printing the first component of the returned pair, the second component is already computed and just waiting to be printed out.
21:55:11 <mudge> hey!  so like,   all   the values are functions!
21:55:14 <Cale> (at least, to the point of the list structure)
21:55:26 <Cale> yes, all values
21:55:37 <oerjan> er, that is actually incorrect
21:55:58 <oerjan> computing (as,bs) does not directly imply computing either as or bs
21:55:58 <Cale> oerjan: all boxed values? :)
21:56:08 <mudge> Cale:  is there actually any "sharing"  or are the values just ready to be printed to the screen?
21:56:08 <Cale> oerjan: right
21:56:20 <oerjan> since each of them are still left as further function calls
21:56:52 <mudge> oerjan:  yea,  but what if there are no more function calls,  you reach end of the list?
21:57:01 <Cale> oerjan: but since the pattern match is lazy, you'll have to demand either as or bs in order to cause that to pattern match anyway
21:57:30 <oerjan> yes, at least one
21:57:34 <Cale> right
21:57:36 <mudge> woa,  pattern matches are lazy too,  neat,    this language is lazy
21:58:11 <Cale> mudge: well, pattern matches which occur in pattern bindings
21:58:22 <Cale> that is when you write something of the form   <pattern> = <expression>
21:58:30 <goalieca> lol. i'm reading this math paper that keeps relying on the concept  "almost everywhere"
21:58:35 <goalieca> what a great concept
21:58:40 <mudge> pattern bindins like (as,bs) = let ....
21:58:41 <Cale> as opposed to  f <pattern> = <expression>, which is a function binding
21:58:46 <oerjan> goalieca: yep :)
21:59:14 <Cale> goalieca: It just means that the complement of the set where the property holds has measure zero.
21:59:58 <mudge> Cale,  makes sense,   is that because a function pattern binding must be evaluated to see if the function definition indicated by the pattern should be run?
22:00:33 <Cale> mudge: Well, it's just by choice, because that's basically always what you want.
22:00:57 <Cale> Lazy pattern matches never "fail"
22:01:27 <mudge> what do you mean it is by choice?
22:01:48 <mudge> Cale,  it makes sense to have it be lazy,  but I see it doesn't have to be,  is this what you mean?
22:01:52 <Cale> The compiler sticks a little ~ on to the start of patterns in pattern bindings.
22:02:12 <Cale> Which is the marker that tells the pattern to match lazily.
22:02:37 <Cale> Lazy matching is slightly dangerous, because it doesn't tell right away whether the match succeeds or not.
22:03:10 <Cale> It just says "yep, it matches, whatever", and then only if the variables bound are actually needed does it really do the work to check that the thing actually matched.
22:03:16 <Cale> If it didn't, you get an exception.
22:03:36 <Cale> > let f ~(x:xs) = 0 in f []
22:03:37 <rahaskella>  0
22:03:55 <Cale> See, that (x:xs) there doesn't really match, but it accepted the []
22:04:14 <Cale> but since we never used x or xs, it never had to find that out :)
22:04:21 <Cale> > let f ~(x:xs) = x in f []
22:04:22 <rahaskella>   Irrefutable pattern failed for pattern (x : xs)
22:04:41 <Cale> Yeah, another name for these lazy patterns is irrefutable patterns
22:04:49 <Cale> that's because they always succeed
22:05:27 <Cale> In function bindings, you usually want to be able to write multiple cases depending on what thing matches
22:05:31 <mudge> Cale: wow, this is really neat,   I get it
22:05:39 <Cale> So function parameter patterns are not lazy by default
22:06:22 <mudge> Cale: makes sense,   so if you used lazy pattern matching for functions,  it would be like turning off compile time type checking
22:06:30 <Cale> nope
22:06:43 <oerjan> lazy patterns are safer for tuples and other one-constructor data types, however.
22:06:46 <Cale> It would be turning off the mechanism that lets you decide which right hand side to take
22:06:49 <Cale> (at runtime)
22:07:10 <Cale> > let f [] = 0; f (x:xs) = 1 + f xs in f [1,2,3]
22:07:12 <rahaskella>  3
22:07:15 <Cale> > let f ~[] = 0; f (x:xs) = 1 + f xs in f [1,2,3]
22:07:16 <mudge> Cale: oh, that makes sense
22:07:17 <rahaskella>      Warning: Pattern match(es) are overlapped
22:07:17 <rahaskella>              In the definition...
22:07:22 <Cale> heh
22:07:31 <Cale> damn compiler outsmarting me :)
22:07:39 <Cale> > let f ~[] = 0 in f [1,2,3]
22:07:40 <rahaskella>  0
22:07:54 <Cale> Well, it would be like that if the patterns were lazy
22:08:03 <Cale> You couldn't even write the length function :)
22:09:10 <Cale> The first pattern would just always match, and you'd be stuck with it.
22:09:48 <Cale> So you usually don't want lazy pattern matches with function parameters, though there is the rare case where it comes in very handy.
22:10:04 <Binkley> any FFI experts around?
22:10:28 <Cale> I don't think I can be called an expert on FFI :)
22:11:31 <Binkley> or even anyone who's ever used the FFI? :-)
22:11:35 <mudge> the ~ makes the [] lazy?
22:11:48 <Cale> yeah
22:11:57 <Cale> Binkley: I've used it :)
22:12:49 <Binkley> ok -- I'm trying to declare a Haskell datatype to correspond to a C struct type that has fields with type char[] (not char*)
22:12:58 <Binkley> and I can't figure out what type to use for the array fields in Haskell
22:13:08 <Binkley> I can use (Ptr CChar), but then the layout is all wrong
22:13:13 <Binkley> any clues?
22:13:32 <mudge> Cale: thanks a lot
22:13:40 <Cale> mudge: no problem :)
22:13:51 <Cale> mudge: let me know if you have any more questions about it :)
22:14:12 <Cale> Binkley: I'll have a look in the FFI spec and see if it says anything in particular about arrays like that.
22:14:29 <reffie> http://people.freebsd.org/~ssouhlal/stuff/lol2.jpg
22:14:31 <reffie> woops
22:14:35 <reffie> disregard that
22:14:59 <Binkley> so far as I can tell, it doesn't, but I may be missing something
22:15:09 <sebell> How can I? The IRC client on this machine displays images inline ;)
22:15:17 <Binkley> haha
22:16:06 <fxr> :)
22:16:34 <reffie> /clear
22:16:37 <Binkley> In fact, the FFI spec doesn't even seem to say anything about struct types
22:16:40 <Cale> Binkley: Could you remind me how the layout of char[] differs from a char* ?
22:17:01 <Cale> Isn't it just a pointer to the array?
22:17:07 * bos makes sad faces over AJAX
22:17:08 <Binkley> Cale: It doesn't, but if I have a char* as a field in a struct, that means that that field occupies 4 bytes in the struct
22:17:16 <Cale> oh
22:17:20 <Binkley> whereas if I have a char[100] (say) as a field, that means it occupies 100 bytes
22:17:22 <Binkley> AFAIK, anyway
22:17:27 <ClaudiusMaximus> Binkley: maybe you have to write your own Storable instance and helper functions with hsc2hs or so?
22:17:35 <Cale> You'll want to write your own instance of Storable, yes
22:17:44 <Binkley> OK
22:19:28 <Cale> and when you go to write the peek, you actually read out the bytes for the array, rather than a pointer.
22:20:20 <sorear> Binkley: the FFI doesn't do structs, period.  you're supposed to use (hs)c2hs
22:20:32 <Binkley> sorear: well, I am using hsc2hs... sorry that wasn't clear
22:20:36 <Binkley> I wanted to know how to do it using hsc2hs
22:20:56 <sorear> #{peek} and a lot of painful boilerplate
22:21:15 <sebell> (and a calculator)
22:21:18 <Binkley> Basically I should just be able to declare some type Foo, make it an instance of Storable, and define sizeOf to return the array size, right?
22:21:39 <Binkley> well, except for copying strings into the resulting fields, that's a bit more bothersome
22:23:18 <Cale> You'll probably actually define an instance for the whole struct type
22:23:39 <Binkley> that's what I'd been hoping to avoid :-)
22:23:58 * ari `ap` bed -- I gave the usual suspects admin on rahaskella so they can kick it out gracefully if lambdabot returns
22:25:15 <mudge> I miss lambdabot
22:25:31 <mudge> does everybody know about haskell the dragon?
22:25:44 <sebell> Lived by the sea?
22:26:21 <Binkley> oh, I think I was doing something absolutely stupid
22:27:00 <Binkley> I can't just define a record with a bunch of fields and pass a Ptr to it to a C function, and assume that the layout will be right, right?
22:27:03 <coffeemug> Puff, the magic dragon
22:27:05 <coffeemug> or
22:27:09 <coffeemug> puff the magic dragon
22:27:14 <coffeemug> we shall never know :(
22:27:17 <Binkley> I have to actually define a Storable interest that has a poke method that copies each field of the record into each field of the struct
22:27:42 <Binkley> er, instance
22:27:46 <Binkley> not "interest"
22:27:50 <sorear> ari++ thanks for the bot, and goodnight
22:28:19 <dibblego> how do I find out what source file instance Monad Either is in?
22:28:30 <sorear> ask #haskell
22:28:36 <sorear> Control.Monad.Error
22:28:40 <mudge> i love this dragon: http://www.tellmeastory.com/haskell/pages/page1.cfm
22:28:49 <dibblego> yeah, I'm getting tired of that; isn't there a way of figuring it out?
22:29:10 <sorear> read and remember the libraries source code?
22:29:14 <sorear> :info might work
22:29:20 <sorear> grep is your frient
22:29:21 <dibblego> ok thanks
22:29:46 <dibblego> it is, but the debian package puts them in .gz for some reason
22:30:18 <OceanSpray> whoah, what
22:30:25 <sorear> uhm... why does the debian package have source code?
22:30:33 <sorear> besides, zgrep ftw
22:30:48 <dibblego> ghc6-libsrc - Library Sources of GHC, the Glasgow Haskell Compilation system
22:31:05 <ClaudiusMaximus> Binkley: yeah, you do have to do a lot of manual boilerplate Storable instance writing with hsc2hs (at least in my experience)
22:31:16 <OceanSpray> I don't get that story
22:31:19 <Binkley> ClaudiusMaximus: yeah, I think I get it now
22:31:35 <sorear> huh, I just use darcs get http://darcs.haskell.org/ghc
22:31:37 <rahaskella> Title: Index of /ghc
22:31:41 <Binkley> are there any tools that aren't bit-rotted that will automate this for me?
22:31:47 <Binkley> I'm not sure what the different FFI tools do
22:31:50 <sorear> c2hs I think
22:31:53 <sorear> @seen dcoutts
22:31:53 <rahaskella> dcoutts is in #haskell. I last heard dcoutts speak 5h 26m 57s ago.
22:32:10 <Binkley> ah, c2hs looks good
22:32:15 <OceanSpray> Somehow, it seems like there's a sinister and disturbing message hidden under all that coloring and Comic-Sans
22:32:23 <OceanSpray> I just can't figure it out.
22:32:40 <Binkley> comic sans is always sinister and disturbing
22:36:07 <Cale> Big Grandma is watching you
22:36:52 <Cale> But it's okay, because she's just going to give you cake anyway.
22:37:36 <OceanSpray> Yes, that fixes everything, doesn't it.
22:37:43 <byorgey> no, she gave the cake to the dragon!
22:37:55 <Cale> The whole cake? :)
22:38:35 <byorgey> well, I suppose you could assume that the dragon will share it
22:38:51 <OceanSpray> It is irrelevant whether she was silently observing this young boy without his knowledge for God knows what reasons, as long as she provides a sugar-laden, diabetes-inducing piece of pastry.
22:40:38 * byorgey `ap` bed
22:41:06 <Cale> Of course, because it is a child who can't be expected to take care of himself, the reasons were probably benign anyway. ;)
22:41:37 <OceanSpray> Because we can all just assume that a grandmotherly maternal figure has no indecent or harmful intentions, don't we?
23:01:34 <kfish> ?where hatching
23:01:34 <rahaskella> I know nothing about hatching.
23:01:34 <kfish> ?where+ hatching http://www.tellmeastory.com/haskell/pages/default.cfm
23:01:34 <rahaskella> Done.
23:28:18 <kfish> Cale++ nice fold diagrams!
23:29:16 <mudge> kfish: don't you love the haskell dragon?
23:29:39 <kfish> mudge, yeah, it's a very cute story :-)
23:29:57 <mudge> i think haskell the dragon should be the haskell mascot
23:30:14 <mudge> you know, like linux has tux
23:52:25 <goltrpoat> evening.
23:53:20 <sebell> Evening goltrpoat
23:55:01 <Pseudonym> Woah, nice!
23:55:13 <Pseudonym> http://www.eecs.harvard.edu/~nr/pubs/zipcfg-abstract.html
23:55:14 <rahaskella> Title: An Applicative Control-Flow Graph Based on Huet's Zipper (Abstract)
23:55:19 <Pseudonym> Oddly elegant.
23:55:32 <reffie> i'm kinda tired of these bots
23:55:43 <RifR> Who isn't?
23:55:59 --- mode: ChanServ set +o Pseudonym
23:56:14 <Pseudonym> Whose is rahaskella?
23:56:20 <reffie> ari's bot
23:56:23 <Pseudonym> Right.
23:56:47 <rahaskella> This is a test.
23:56:49 <Pseudonym> Woo!
23:56:51 <Pseudonym> I can remote it!
23:56:58 <reffie> pwn it
23:57:33 <fax> haahaha
23:57:46 --- mode: Pseudonym set -o Pseudonym
23:57:54 <Pseudonym> So I guess I won't be needing +o, then.
23:58:22 <rahaskella> I am a poor imitation of the true lambdabot.
23:58:34 <oklopol> what's the logic for that?
23:58:41 <oklopol> not needing +o
23:58:49 <Pseudonym> Oh, I can make it shut down if I want to.
23:58:52 <Pseudonym> Or leave the channel.
23:58:59 <Pseudonym> Because I have admin privileges.
23:59:00 <oklopol> ah
23:59:07 <Pseudonym> ?part #haskell
23:59:13 <reffie> how come you have admn privileges
23:59:17 <Pseudonym> See??
23:59:34 <int-e> it's in the default lambdabot configuration file.
23:59:38 <Pseudonym> Yeah.
23:59:42 <Pseudonym> I put it in there. :-)
