00:05:21 <dons> night all. happy lambda dreams
00:22:25 <opqdonut> :)
00:23:42 <xpika> is software a secondary industry or tertiary industry
00:24:01 <wli> Tertiary.
00:24:12 <xpika> wli: thanks
00:34:15 <hpaste>  (anonymous) annotated "My favorite piece of code today" with "(no title)" at http://hpaste.org/2764#a1
01:04:31 <hpaste>  pjd annotated "My favorite piece of code today" with "comprehensively" at http://hpaste.org/2764#a2
01:06:25 <pjd> sometimes points pay :)
01:10:47 <KatieHuber> wow, nice
01:11:02 <KatieHuber> I never think of list comprehensions :(
01:12:21 * ddarius isn't particularly fond of list comprehensions except, perhaps, in highly stylized cases.
01:12:49 <scook0> I find they're great when you want to do something slightly non-trivial
01:13:14 <scook0> for trivial stuff, you just use HOFs
01:13:24 <scook0> and more complex stuff you write out in a longer form
01:13:33 <scook0> but comprehensions are a nice middle ground
01:13:57 <opqdonut> yeah they can greatly clarify a filter-map combo
01:14:13 <opqdonut> filter-map-zip
01:14:15 <scook0> especially when they eliminate ugly-looking lambdas
01:14:39 <opqdonut> yup
01:21:33 <cinimod> KatieHuber: or maybe a list monad - I suspect ddarius would be even less fond
01:22:46 <pjd> list comprehension is pretty much list monad
01:22:56 <cinimod> exactly my point
01:33:39 <wli> Monad comprehensions would be nice.
01:35:36 <opqdonut> indeed
01:35:45 <opqdonut> what's the status on Haskell'
01:35:54 <opqdonut> is there a newsletter or something i could subscribe to?
01:38:41 <wli> Haskell' is a conservative extension of Haskell 98, not what we're looking for.
01:50:36 <KatieHuber> when I go "import qualified Data.Map as Map", it hides (!) away as (Map.!) -- is there some way to get it back again?
01:51:20 <matthew-_> KatieHuber: yes
01:51:26 <matthew-_> do a second import line
01:51:32 <matthew-_> "import Data.Map (!)"
01:51:49 <matthew-_> that'll just grab the (!) function without the qualification
01:52:15 <KatieHuber> hmm, it doesn't complain about the import, but it does complain about the ! :|
01:52:22 <matthew-_> oh
01:52:26 <matthew-_> "import Data.Map ((!))"
01:52:39 <KatieHuber> oh wait, it does complain about the import
01:52:49 <KatieHuber> yea, that works, ta
01:53:00 <matthew-_> (the outer brackets allow you to list which functions you want. The inner brackets are as ! is infix)
01:53:52 <matthew-_> KatieHuber: did you read that you do a lot of opengl work, professionally?
01:54:22 <KatieHuber> yes, I do
01:54:36 <matthew-_> can I ask you about vertex buffer objects?
01:54:42 <KatieHuber> sure
01:54:53 <opqdonut> wli: oh, okay
01:55:15 <opqdonut> so no (.) = fmap, no monad comprehensions, no infix exps?
01:55:33 <wli> opqdonut: Nope.
01:55:35 <opqdonut> how about class-hierarchy changes?
01:55:50 <wli> opqdonut: Unlikely where not backward-compatible.
01:55:52 <matthew-_> ok, so I have two questions: 1) I have large arrays which are interleaved with vertex and colours, the gpu or driver moans when it runs out of memory, but it only gives a warning. Performance degrades but it doesn't crash. Is this because it's just using normal ram rather than on the GC ?
01:56:03 <opqdonut> wli: okay
01:56:42 <opqdonut> but i'd still be interested in some summary/changelog for checking on how it's progressing
01:56:52 <opqdonut> i've read a few drafts and that's all
01:57:23 <matthew-_> the second q is: if I have a large texture (8092 by 4096), and I know that I'll never have > half rendered at the same time, will it be faster for me to subdivide it, use borders and tile it together, or just keep it as one texture ?
01:58:37 <KatieHuber> to 1), the implementation is required to work whatever you throw at it, within reason.  The data has to end up on the GPU at some point, so my guess is it's paging it through.
01:58:54 <KatieHuber> but really, it could be doing anything, and you're not supposed to care as long as it works ;)
01:59:17 <matthew-_> sure. And of course, there's no way to find out when it runs out of RAM is there?
01:59:25 <KatieHuber> to 2), first, 8192x4096 is *massive*... you've got a GeForce 8800?
01:59:31 <matthew-_> err, yes
01:59:39 <matthew-_> but it needs to work on lots of cards
01:59:51 <KatieHuber> then you've got no choice but to cut it down
02:00:02 <matthew-_> right.
02:00:13 <matthew-_> with something that big, would you suggest doing manual mipmapping?
02:00:16 <KatieHuber> borders are a bad idea, since nobody uses them
02:00:21 <matthew-_> oh?
02:00:46 <KatieHuber> they're fairly likely to run you into driver bugs, or possibly push you off the hardware path
02:01:08 <matthew-_> the manual mipmapping idea: simply because it means you can keep the different levels as different objects, and thus keep them off the card when they're not needed
02:01:19 <Botje> cool.
02:01:28 <Botje> Data.Array is implemented with ST
02:01:40 <Botje> I didn't know that :)
02:01:51 <matthew-_> it would mean there'd be very noticeable jumps between the textures, but it might save memory?
02:02:21 <KatieHuber> well, 8192x4096 isn't *that* much VRAM, if it's 32-bit color...
02:02:30 <matthew-_> rgba8
02:02:36 <KatieHuber> but it's like 128M, isn't it, which might rule out your "lots of cards"
02:02:48 <matthew-_> yes, 128M.
02:03:24 <matthew-_> if I prepare lower res versions, and only load bits of it at a time, I could get it down to 32MB loaded at any one time...
02:04:06 <matthew-_> so if I don't use borders, is it just going to look really crap where the edges meet up?
02:04:17 <KatieHuber> though if you know no more than half will be rendered at a time, you could tile it into eight 2048x2048 chunks, each mipmapped normally, and just render those in the usual manner
02:04:34 <KatieHuber> if you don't use borders, you can do the same trick by pretending there's a border
02:04:53 <matthew-_> eh?
02:05:33 <KatieHuber> so use 2^n-2 sized images, with the extra line of pixels on each edge coming from the neighbor texture
02:05:47 <KatieHuber> feel free to try borders on the cards you care about, maybe they'll work
02:05:48 <matthew-_> ahh, ok, I wondered if that was what you were meaning.
02:06:03 <KatieHuber> but my instinct is that you'll find cards/drivers where they don't
02:06:23 <KatieHuber> again, depends on your definition of "lots of cards" ;)
02:07:36 <matthew-_> finally, the interleaved arrays will end up being  x y z s t nx ny nz which is 8 floats, or 32 bytes. But currently I don't have the normals so it's just x y z s t which is 20 bytes. How common is it, do you think, that cards will prefer me to bad to either a 24 or 32 byte boundary?
02:07:58 <matthew-_> s/bad/pad/
02:08:16 <KatieHuber> I benchmarked various vertex formats on NVidia 7800/linux and Radeon X1600/Mac and didn't find any differences
02:08:38 <matthew-_> ahh, interesting.
02:08:59 <KatieHuber> I kinda expected 32-byte vertices to be best, but couldn't find any performance penalty even for really odd-sized vertices
02:09:18 <matthew-_> before I switched to interleaved, I had separate VBOs for vertexes and colours, and the performance was the same
02:09:29 <matthew-_> even though I expected it would result in more memory transfers
02:09:34 <KatieHuber> yeah, I also tried interleaved vs. planar and didn't find any differences
02:09:46 <wli> What are you using to do rendering here? What are you rendering?
02:10:00 <matthew-_> opengl, large vertex arrays
02:10:07 <matthew-_> I guess it depends on how wide the memory system is
02:10:09 <KatieHuber> possibly just because actually getting vertex load to matter on a modern GPU is quite hard ;)
02:10:14 <wli> On a higher level.
02:10:22 <KatieHuber> you'll almost always end up fill-limited
02:10:25 <wli> OpenGL via what lib (if any)?
02:10:34 <wli> Large vertex arrays representing what?
02:10:37 <matthew-_> wli: haskell, hopengl
02:10:46 <matthew-_> wli: representing a lot of triangles!
02:10:56 <wli> matthew-: Even higher-level, on both counts.
02:10:57 <opqdonut> :D
02:11:35 <matthew-_> KatieHuber: err, the highest lod gives me 500MB of data
02:11:49 <matthew-_> KatieHuber: == 250 MB of vertexes and 250MB of colour
02:12:04 <KatieHuber> yikes
02:12:09 <matthew-_> but again, never more than half will be rendered
02:12:14 <KatieHuber> even so
02:12:18 <matthew-_> the lowest LoD is just 50MB
02:12:31 <KatieHuber> 256M isn't rare today, but it might not be "lots" of cards
02:12:41 <matthew-_> it's very funny - I wrote a memory management unit, and the lod is determined by framerate
02:12:45 <KatieHuber> and even within 256M, you need space for color buffers, etc.
02:13:13 <matthew-_> the 8800 crashed the memory management unit becase the frame rate was so high that it tried to switch to the highest lod with 50% of the thing on screen
02:13:50 <matthew-_> because the memory management unit never expected that to be the case. So now I have to check that the chosen LoD can actually fit in ram before trying to load it!
02:13:52 <wli> What do the triangles represent?
02:13:56 <matthew-_> the earth
02:14:30 <matthew-_> basically, you can get a height map of the earth in 2 minute intervals
02:14:45 <matthew-_> which give 10800 points of longitude and 5400 points of latitude
02:15:00 <matthew-_> I down sample those with a (poor) mesh decimation algo
02:15:05 <matthew-_> to give 4 different LoDs
02:15:19 <matthew-_> and now I'm trying to texture map on top of that
02:15:43 <KatieHuber> why you sending vertex colors?
02:16:13 <matthew-_> because currently, colour is determined by height above or below sea level
02:16:37 <matthew-_> but with the texture map, that'll kinda go away
02:16:59 <matthew-_> (although the texture maps don't have interesting colours for the sea bed, so I might keep the colours)
02:18:33 <matthew-_> without the down sampling, you get 10800 * 5400 * 2 {- 2 tris per quad -} * 3 {- 3 points per tri -} * 6 {- 6 floats per point (colour + pos) -} * 4 {- 4 bytes per float -}
02:19:04 <matthew-_> which is 8GB
02:20:33 <KatieHuber> need a 64-bit machine ;)
02:20:41 <matthew-_> I also tried having colours as 8-bit ints. But performance suffered badly
02:20:48 <matthew-_> so much seems tuned to 32-bit floats
02:20:53 <KatieHuber> not the most efficient representation of the data though
02:21:17 <matthew-_> oh true, it's horribly redundant - every point gets repeated many times
02:21:39 <KatieHuber> well you can fix that with DrawElements and an index array
02:21:43 <matthew-_> but with the decimation, there's really no choice but have a big mess of triangles rather than trying to have stripes
02:22:04 <matthew-_> oh really? I've not looked at that *at all*
02:22:24 <KatieHuber> if you could require geforce 8 you could use a geometry shader, which (if the performance was OK) might save you a lot of memory
02:22:32 <matthew-_> err no
02:24:25 * matthew-_ has now read DrawElements.
02:25:02 <matthew-_> Ahh, super. and performance won't suffer? Do GPUs have caches and prefetching etc so that hopping around the array is unlikely to matter?
02:26:05 <KatieHuber> yes
02:26:27 <KatieHuber> they also have a post-transform cache which avoids running the vertex processing twice on a vertex
02:26:58 <matthew-_> neat. so I'm really just likely to save ram here and not affect performance.
02:26:58 <KatieHuber> obviously, staying local will be better, but you shouldn't see large penalties for hopping around
02:27:13 <KatieHuber> DrawElements is always the preferred way to draw stuff
02:27:32 <matthew-_> right, the red book doesn't tend to give such information...
02:28:05 <KatieHuber> nope
02:28:48 <KatieHuber> such knowledge is gleaned from interminable years dissecting every sentence said by engineers employed by the various involved companies :/
02:28:55 <nornagon> :/
02:29:25 <matthew-_> ok, and finally (!), what's the deal with opengl and vista? I've heard bad things.
02:30:01 <KatieHuber> There was a scare when MS promised to ensure that OpenGL and their fancy new GUI, whatever it's called, couldn't coexist
02:30:09 <KatieHuber> they backed off that, and AFAIK there are no issues
02:30:23 <matthew-_> I've heard that opengl performance under vista is terrible when compared to d3d
02:30:37 <matthew-_> you think I've heard wrong?
02:30:40 <KatieHuber> I haven't heard that, indeed I've heard the opposite
02:30:50 <matthew-_> oh ok. I must be mistaken then.
02:31:01 <matthew-_> cool, well I've got some work to do then. Many thanks for your time.
02:31:08 <KatieHuber> np
02:32:12 <KatieHuber> bah, I refactored my app, and now it chews through gigabytes of memory in seconds, prints nothing, grinds the computer to a halt, prints nothing, until I ctrl-C :'(
02:32:22 <KatieHuber> guess my refactoring wasn't so much with the semantics-preserving
02:34:12 <scook0> space leak?
02:35:05 <wli> I wonder how many video games actually make money.
02:35:30 <wli> I'm going to guess very few; the rest are propped up by VC hoping for the next GTA:SA.
02:35:37 <KatieHuber> AAA games, very very few
02:35:38 <scook0> you've probably introduced some extra laziness, or precluded some compiler optimization
02:35:47 <KatieHuber> saw the stats on GamaSutra sometime recently
02:36:03 <KatieHuber> I think the average AAA game loses several million dollars
02:36:17 <wli> KatieHuber: AAA?
02:36:26 <KatieHuber> big-budget commercial stuff
02:37:04 <wli> So I'm not far off.
02:38:20 <wli> So the whole zero replay value thing the AAA games are pulling is essentially a losing tactic but they keep doing it anyway. OTOH it may not be the dominant effect.
02:39:03 <KatieHuber> I think that if you look at less-publicized stuff, "casual games" in particular, it's pretty profitable
02:39:39 <KatieHuber> I mean, a game which one developer + one artist can make in 3-6 months and appeals to millions is hard to go wrong with ;)
02:40:11 <wli> KatieHuber: Casual games? Basically it works for the low-budget stuff because basically the number of people who will try it out randomly and get burned is enough to float the whole thing the way the odds go?
02:40:22 <scook0> no wonder Nintendo's trying to go down the casual, low-budget route
02:40:40 <matthew-_> wli: introversion have made a fair amount of money
02:40:51 <matthew-_> and they produce no game content (artwork) at all
02:41:22 <mr_tenor> scook0: i reckon their iTunes-like online sales will work. make it easy for people to give you money on a whim
02:41:29 <matthew-_> wli: look up defcon and darwinia - both pretty famous, cheap to produce and very popular
02:42:40 <KatieHuber> doh, I made this exact bug once before :/
02:42:41 <wli> I've been laid up several days with an eye infection. I couldn't read but I could play video games. Hence all the thought about video games recently. ;)
02:43:22 <KatieHuber> much better, no longer powering through the GB :)
02:45:04 <matthew-_> KatieHuber: do you do much opengl work in Haskell?
02:45:10 <KatieHuber> none at all
02:45:20 <KatieHuber> I'm just learning haskell for fun on the side
02:45:42 <matthew-_> ahh. so what do you work in? Just C++ or do you use stuff like Ogre?
02:45:44 <KatieHuber> currently doing GL work in Ruby
02:45:48 <matthew-_> oh.
02:45:52 <KatieHuber> and ObjC
02:45:59 <KatieHuber> C++ in the past, but wouldn't really want to go there again
02:46:18 <matthew-_> is the ObjC due to Mac influences?
02:46:29 <KatieHuber> yeah, we're building for Mac only
02:46:43 <KatieHuber> you're in the UK, you know the BBC's new(-ish) weather graphics?
02:47:11 <matthew-_> yep
02:47:18 <matthew-_> the stuff that made everyone seasick
02:47:22 <matthew-_> it was YOU!
02:47:24 <KatieHuber> well, large amounts of the C++ and GL code in that is my fault
02:47:29 <matthew-_> cool
02:47:33 <KatieHuber> note that the look and feel are *not* my fault ;)
02:47:39 <KatieHuber> we have graphic designers for that
02:47:55 <matthew-_> was that directly done in house by the beeb or did they subcontract it out?
02:48:16 <KatieHuber> it's a commercial product called "Weatherscape XT"
02:48:34 <KatieHuber> which drives another dozen or so TV stations' weather graphics worldwide
02:48:34 <wli> Where do people put most of the work into video games? I have a vague idea things like raytracing and physics engines are mostly canned affairs people use libs for.
02:48:46 <KatieHuber> nobody raytraces in games ;)
02:48:59 <KatieHuber> rendering used to be tricky, but pretty much isn't any more
02:49:08 <KatieHuber> physics used to be tricky but you pretty much buy a library these days
02:49:23 <KatieHuber> the rest isn't all that easy though :)
02:49:24 <wli> Sorry, rendering.
02:49:37 <KatieHuber> the problem is, it can be hard to factor nicely
02:49:47 <KatieHuber> tends to be everything has its fingers in every other pie
02:49:48 <matthew-_> even in Haskell ;)
02:49:57 <KatieHuber> I'd love to try in Haskell at some point
02:50:15 <matthew-_> yeah, it's um, easy to make mistakes in the design
02:50:26 <KatieHuber> I get the impression that lots of factoring problems would just melt away with Haskell
02:51:14 <matthew-_> a lot of problems do go away, that's true. But the "one little thing's just changed and now I need to create a whole new game state because of it" problem remains
02:51:23 <Mitar> how can i check the type of the function with lambdabot?
02:51:35 <matthew-_> @type \x y -> x * y
02:51:37 <lambdabot> forall a. (Num a) => a -> a -> a
02:51:41 <Mitar> @type map
02:51:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:51:45 <Mitar> @type mapM
02:51:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:52:11 <Mitar> @type (liftM . map)
02:52:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
02:52:17 <DRMacIver> matthew-_: I'm looking forward to your talk on the subject. :)
02:53:18 <Mitar> @type mapMaybe
02:53:20 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
02:53:57 <wli> matthew-: I'm probably not looking to become a direct participant in all this but I do wonder what the devil is going on with the things whenever I look at them.
02:54:39 <matthew-_> DRMacIver: err yeah. Me too
02:55:53 <DRMacIver> you don't sound very convinced. :)
02:58:25 <DRMacIver> Hm. I might have a play with some open GL stuff today actually. Is HOpenGL the right library to be looking at? (The fact that its last release was 2003 makes me nervous)
02:58:41 <matthew-_> yeah, it's the right thing
02:58:49 <DRMacIver> ok
02:59:40 <matthew-_> KatieHuber: ahh, so you have a separate VBO for the vertices and the indexes with the GL_ELEMENT_ARRAY_BUFFER and then just tell it to get on with it?
02:59:51 <KatieHuber> yup
03:01:35 <matthew-_> sheesh, opengl is so un-functional
03:01:45 <KatieHuber> yup :)
03:02:19 <KatieHuber> well, fragment programs have a somewhat declarative feel about them, despite being written imperatively
03:04:40 <wli> Fragment programs?
03:05:24 <KatieHuber> pixel shaders a more familiar name?
03:08:24 <matthew-_> err, is it a bad idea to use things like ThreeBytes as the index mode ?
03:08:48 <matthew-_> I have a hard limit of 202500 elems per array. Which is annoyingly more than 2^16
03:08:51 <wli> yeah
03:08:58 <matthew-_> and a 32-bit int seems overkill
03:11:30 <matthew-_> oh ignore that, it's not permitted anyway.
03:11:34 <Mitar> if I have a function which takes two arguments and returns Bool
03:11:37 <wli> What do these things use for rendering if not raytracing? Surely not radiosity.
03:11:44 <Mitar> how can I easily define negation of this function?
03:12:07 <mauke> (not .) . f
03:12:23 <Mitar> uh, what is this first .?
03:12:33 <KatieHuber> wli: straightforward boring scanline rasterization of triangles, with a depth buffer, and possibly per-pixel lighting equations
03:12:33 <mauke> function composition
03:12:45 <KatieHuber> nothing nearly as general or correct as raytracing or radiosity
03:13:03 <wli> KatieHuber: Does it have a name?
03:13:03 <mauke> (not .) . f  ==  \x -> not . f x  ==  \x y -> not (f x y)
03:13:54 <wli> KatieHuber: Sorry, I missed scanline rasterization. Okay, that I understand.
03:15:43 <wli> KatieHuber: With hardware advances I wonder if they could move to things like raytracing (in fact, I thought they already had).
03:16:30 <KatieHuber> both real-time raytracing and real-time radiosity are still a while off
03:16:47 <KatieHuber> at this stage I wouldn't like to call which one'll arrive first
03:17:20 <KatieHuber> probably some new technique nobody's ever thought of before, really ;)
03:17:30 <lola> hey! I am running ghci version ghc-6.6.1 under Debian Lenny, and the package Quickcheck is not found... anybody who knows how to solve this? I have installed libghc6-quickcheck-dev
03:17:42 <wli> I'd think the heat equation is a bit further off than more ad hoc methods like raytracing.
03:18:24 <KatieHuber> perhaps you don't mean by radiosity what graphics programmers do :)
03:18:58 <wli> AFAIK radiosity is solving the heat equation.
03:19:17 <wli> Or approximations thereof (where the brutal hacks graphics programmers use come in).
03:19:43 <KatieHuber> this is what I mean by it: http://en.wikipedia.org/wiki/Radiosity
03:19:45 <lambdabot> Title: Radiosity - Wikipedia, the free encyclopedia
03:20:07 <TSC> lola: Isn't the package called QuickCheck (uppercase)?
03:20:12 <wli> Well, I've got graphics programming textbooks.
03:20:27 <wli> So I can refer to those (dead trees) if need be.
03:20:45 <lola> TSC yep.. sorry thats what I meant ;)
03:22:22 <TSC> lola: If you run ghci and enter "Test.QuickCheck.quickCheck (\x -> x == x)", what does it say?
03:29:43 <Mitar> how could i get a monadic version of mapMaybe? is there already defined somewhere?
03:31:36 <Lemmih> What would its type be?
03:33:02 <Mitar> @type mapMaybe
03:33:05 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
03:33:26 <Mitar> forall a b. (a -> m Maybe b) -> [a] -> m [b]
03:33:41 <Mitar> @type map
03:33:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:33:48 <Mitar> @type mapM
03:33:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:34:10 <Mitar> @type (liftM . map)
03:34:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
03:34:13 <Mitar> is not OK
03:34:32 <mauke> :t (liftM catMaybes .) . mapM
03:34:34 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m (Maybe a)) -> [a1] -> m [a]
03:35:17 <KatieHuber> magic mauke strikes again :|
03:35:20 <mauke> :t liftM (liftM (liftM catMaybes)) mapM
03:35:21 <Mitar> :-)
03:35:22 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m (Maybe a)) -> [a1] -> m [a]
03:35:35 <mauke> CAN'T HAVE TOO MANY LIFTMS
03:35:40 <Mitar> lol
03:35:49 <pjd> liftM catMaybes `dot` mapM
03:36:03 <ricky_clarkson> :t catMaybes
03:36:05 <lambdabot> forall a. [Maybe a] -> [a]
03:36:19 <Mitar> but the problem is that resulting list is not of type a
03:36:26 <Mitar> i have to have b
03:37:03 <mauke> I'm not sure how to answer that
03:37:08 <pjd> Mitar: the type name is just accidental
03:37:13 <Lemmih> Mitar: a1 -> a  is the same as  a -> b.
03:37:16 <pjd> a1 and a are still distinct
03:37:23 <Mitar> ahh, yes
03:37:35 <pjd> s/type/type variable/
04:01:18 <DRMacIver> Hm. So I continue to struggle with parsec despite my initial experiments with it being rather successful. :-/
04:01:22 <hpaste>  DRMacIver pasted "Trivial coordinate parser" at http://hpaste.org/2765
04:01:43 <DRMacIver> Anyone see why this doesn't work? It's supposed to parse a line separated list of pairs of doubles.
04:01:50 <DRMacIver> But it only gets the first line.
04:02:41 <DRMacIver> (It's really annoying when things that were supposed to be quick hacks to just get the real code under way end up sucking up disproportionate amounts of time. :) )
04:03:10 <Lemmih> What's with the 'return x'?
04:03:21 <DRMacIver> Uh
04:03:25 <DRMacIver> I have no idea how that got in there.
04:03:26 <DRMacIver> One second...
04:04:07 <DRMacIver> That's not the code I was actually testing with, sorry. :) I was playing around with it to try to make it work and versions/testing code got jumbled.
04:04:25 <hpaste>  matthew-_ annotated "Trivial coordinate parser" with "(no title)" at http://hpaste.org/2765#a2
04:04:46 <matthew-_> DRMacIver: would be my guess, though untested and that might be the wrong words!
04:05:02 <matthew-_> oh, actually, that may be utter crap by me
04:05:33 <DRMacIver> matthew-_: Doesn't compile. :)
04:06:28 <DRMacIver> I don't think that's right anyway. But maybe I'm totally misunderstanding.
04:07:11 <Lemmih> DRMacIver: pointsParser = many pointParser
04:07:24 <Heffalump> oh, you're using parsec. I'd just use read :-)
04:07:44 <Heffalump> unlines the list, stick "(" and ")" round each elem, then map read over it
04:08:18 <matthew-_> DRMacIver: pointsParser = eof <|> (pointParser >>= \p -> newline >> pointsParser >>= \ps -> return $ p:ps)
04:08:26 <matthew-_> though it looks grim as a one liner
04:08:42 <DRMacIver> Lemmih: Hm. That seems to work (once I add the newline to the pointParser). Weird. I thought I'd tried that.
04:08:42 <Lemmih> DRMacIver: 'float tokenParser' skips trailing spaces and newlines.
04:08:53 <DRMacIver> Oh!
04:09:19 <TSC> I thought they skipped leading whitespace, not trailing
04:09:29 <Lemmih> DRMacIver: 'parseTest (someParser >> getInput) "testInput"' is graet for debugging.
04:10:01 <Heffalump> > map (read . ("(" ++) . (++ ")")) $ lines "5.3,2.5\n6.4,1.2" :: [(Double, Double)]
04:10:04 <lambdabot>  [(5.3,2.5),(6.4,1.2)]
04:10:42 <DRMacIver> Lemmih: Ah. Nice trick. Thanks.
04:11:12 <DRMacIver> Heffalump: Yeah, I *could* do that. But I try to use parsec every chance I get in the hopes of eventually becoming fluent in the damn thing. :)
04:11:24 <DRMacIver> (Only inching my way there so far though)
04:11:32 <ricky_clarkson> Afternoon, DRMacIver.
04:12:16 <DRMacIver> Hi ricky_clarkson. How goes?
04:13:13 <ricky_clarkson> Not bad.  Reading something by EWD, that manages to debunk TDD about 25 years before it happened.
04:13:20 <ricky_clarkson> http://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD361.html
04:13:21 <lambdabot> Title: E.W.Dijkstra Archive: Programming as a discipline of mathematical nature (EWD 36 ...
04:14:34 <DRMacIver> I try not to get involved in programming politics. I find it very tedious. ;)
04:17:55 <fax> hiya
04:20:55 <TSC> Hi, fax
04:29:37 <EvilTerran> so... i have to do a 30min talk next term, to first- and second-year undergraduates, of both maths and computer science. subject of my choice, but it's got to be maths-(or CS-)related, accessible to the audience, and preferrably off-syllabus.
04:29:47 <EvilTerran> any suggestions?
04:30:37 <fax> fractals are pretty.. and there is a lot of good math there
04:30:56 <EvilTerran> someone else's already nabbed fractals, unfortunately. basic game theory, likewise.
04:31:47 <Heffalump> cryptography?
04:32:40 * EvilTerran has a look at the email thread where we've been discussing topics
04:32:43 <KatieHuber> coding theory maybe slightly easier
04:33:22 <KatieHuber> 30 mins isn't very long, you'd only scrape the surface of whatever you choose
04:35:16 <EvilTerran> hm. no-one's specifically claimed cryptography yet, but one of the mathmos did an essay on it last term, iirc, and the tutor suggested the mathmos spin their essays into their talks.
04:35:27 <DRMacIver> Stupid question. How do I convert from a Double to a Float?
04:35:52 <DRMacIver> Oh, just realToFrac?
04:36:06 <EvilTerran> believe me, those were the first ones i thought of; game theory, fractals, and crypto are everyone's favourite pop maths subjects ;]
04:36:07 <fax> maybe (fromRational 1.5) :: Double
04:36:30 <KatieHuber> surely Double isn't Rational
04:36:32 <EvilTerran> ?type fromRational
04:36:34 <lambdabot> forall a. (Fractional a) => Rational -> a
04:36:38 <EvilTerran> ?type realToFrac
04:36:39 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
04:36:47 <EvilTerran> @instances Fractional
04:36:48 <lambdabot> Double, Float
04:36:51 <EvilTerran> @instances Real
04:36:52 <lambdabot> Double, Float, Int, Integer
04:36:55 <DRMacIver> realToFrac seems to work. It seems like the wrong way to do it though.
04:37:28 <KatieHuber> hugs has Hugs.Prelude.fromDouble but not Hugs.Prelude.fromFloat :|
04:37:35 <EvilTerran> coding theory would be possible...
04:37:54 <DRMacIver> I mean, I guess I could just convert all my uses of Double to be arbitrary reals. That's probably a good idea anyway.
04:38:07 <DRMacIver> But this seems like the sort of thing that should be really easy. :)
04:40:56 <DRMacIver> Oh, no I can't. At least not without writing my own parser for Float which returns a double.
04:41:01 <DRMacIver> Bah. I'll just use realToFrac. :)
04:42:16 <oklopol> > 7*"f"
04:42:17 <lambdabot>   add an instance declaration for (Num [Char])
04:42:17 <lambdabot>     In the expression: 7 * "f"...
04:42:30 <EvilTerran> > replicate 7 'f'
04:42:32 <lambdabot>  "fffffff"
04:43:17 <oklopol> > let (a :: Num) * (b :: [Char]) = replicate a b in (7*"oko")++"o"
04:43:18 <lambdabot>  Parse error in pattern
04:43:22 <fax> > (read "5.3) :: Double
04:43:22 <lambdabot>  Improperly terminated string
04:43:28 <fax> > (read "5.3") :: Double
04:43:30 <lambdabot>  5.3
04:43:46 <EvilTerran> > let (*) = replicate in (7 * "oko") ++ "o"
04:43:47 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
04:43:56 <oklopol> > let (a :: Num) * (b :: [Char]) = replicate a b in (7 * "oko") ++ "o"
04:43:56 <lambdabot>  Parse error in pattern
04:43:59 <EvilTerran> > let (*) = (concat .) . replicate in (7 * "oko") ++ "o"
04:44:00 <lambdabot>  "okookookookookookookoo"
04:44:27 <EvilTerran> maybe call it `x` rather than *, though
04:44:27 <oklopol> > let (*) = (concat .) . replicate in (7 * "ok") ++ "o"
04:44:29 <lambdabot>  "okokokokokokoko"
04:44:30 <oklopol> concat?
04:44:35 <KatieHuber> there's a furniture store specializing in wacky beds near my work called okooko :|
04:44:38 <EvilTerran> @src concat
04:44:39 <lambdabot> concat = foldr (++) []
04:44:41 <oklopol> > "asfdg" `concat` "asdf"
04:44:43 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
04:44:51 <fax> hehe
04:44:52 <oklopol> hmm
04:45:17 <fax> > concat ["asdf", adfs"]
04:45:17 <lambdabot>  Improperly terminated string
04:45:20 <EvilTerran> > repeat "abc"
04:45:21 <oklopol> > `concat` ["asdf", "asdf"]
04:45:21 <lambdabot>   parse error on input ``'
04:45:22 <lambdabot>  ["abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","ab...
04:45:25 <EvilTerran> > concat (repeat "abc")
04:45:26 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
04:45:37 <EvilTerran> > foldr (++) [] (repeat "abc")
04:45:38 <oklopol> > concat ["asdf", "asdf"]
04:45:38 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
04:45:39 <lambdabot>  "asdfasdf"
04:46:09 <fax> this is nice http://www.haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
04:46:11 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2868t9
04:48:20 <KatieHuber> you need to add brainfuck, fax :)
04:48:49 <KatieHuber> oh, it's there... but not as short as yours :)
04:49:04 <fax> about 500x bigger >:o
04:49:20 <fax> then again, I didn't implement ,
04:50:14 <fax> I can't find any which use Parsec and deal with infix [and maybe prefix/postfix] operators
04:51:08 <fax> does anyone have one that does that?
04:52:17 <c9s>  > `concat` [ "asdf" , "asdf" ]
04:52:30 <c9s> > `concat` [ "asdf" , "asdf" ]
04:52:31 <lambdabot>   parse error on input ``'
04:52:40 <fax> concat is not a infix operator
04:52:50 <fax> (remove `'s)
04:53:02 <c9s> > concat ( repeat "abc" )
04:53:07 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
04:53:07 <c9s> fax: thanks :)
04:53:15 <fax> > (`concat`) [ "asdf" , "asdf" ]
04:53:15 <lambdabot>  Parse error
04:53:26 <fax> grr
04:53:31 <twanvl> > cycle "abc"
04:53:33 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
04:54:00 <hkBst> > 1 `(+)` 1
04:54:00 <lambdabot>  Parse error
04:54:17 <c9s> > 1 + 2
04:54:18 <lambdabot>  3
04:54:59 <hkBst> (`mod`) 10 3
04:55:03 <hkBst> > (`mod`) 10 3
04:55:03 <lambdabot>  Parse error
04:55:15 <cinimod> > mod 10 3
04:55:16 <lambdabot>  1
04:55:28 <hkBst> weird :)
04:55:32 <cinimod> > 10 `mod` 3
04:55:33 <fax> > (const `mod`) 10 3
04:55:34 <lambdabot>  1
04:55:34 <lambdabot>        add an instance declaration for (Integral (a -> b -> a))
04:55:34 <lambdabot>     In the ex...
04:55:56 <cinimod> :t mod
04:55:57 <lambdabot> forall a. (Integral a) => a -> a -> a
04:59:33 <fax> oh so pugs perl6 is using parsec
05:05:11 <fax> any idea where to find a large list of things using Parsec?
05:07:08 <twanvl> http://www.google.com/codesearch?q=import+Text.ParserCombinators.Parsec&hl=en
05:07:13 <lambdabot> Title: import Text.ParserCombinators.Parsec - Google Code Search, http://tinyurl.com/yu28lw
05:07:19 <fax> ohhh clever
05:07:20 <fax> thank you
05:09:18 <DRMacIver> Hm. Looks like parsec's float doesn't handle negative floating point literals.
05:09:45 <DRMacIver> (I guess they're not really literals)
05:12:16 <EvilTerran> they *could* be
05:12:32 <EvilTerran> then we could take out the special case for unary (-)!
05:13:31 <shteou> Morning team.
05:15:54 <fax> good morning
05:16:15 <crazy_coder> g'morning fax
05:17:07 <fax> @pointless (\x y-> f "f" [x,y])
05:17:08 <lambdabot> (f "f" .) . (. return) . (:)
05:19:50 <ricky_clarkson> Someone said djinn doesn't do lists.  Is it just monads in general it doesn't do?
05:19:58 <ricky_clarkson> ..and is there a reason?
05:21:08 <ari> ricky_clarkson: It doesn't do recursive types
05:21:59 <ari> @djinn a -> Bool -> Maybe a
05:22:00 <lambdabot> f a b =
05:22:00 <lambdabot>     case b of
05:22:00 <lambdabot>     False -> Nothing
05:22:00 <lambdabot>     True -> Just a
05:22:06 <ricky_clarkson> ari: Gotcha.
05:22:24 <fax> What is djinn?
05:22:31 <fax> just invent some code for a type?
05:22:35 <ari> @help djinn
05:22:36 <lambdabot> djinn <type>.
05:22:36 <lambdabot> Generates Haskell code from a type.
05:22:36 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
05:22:47 <ari> curry-howard++
05:22:53 <fax> hehe
05:23:00 <fax> @djinn (a -> b) -> [a] -> [b]
05:23:00 <lambdabot> -- f cannot be realized.
05:23:04 <dmhouse> fax: it's a "theorem-prover", in the sense of Curry-Howard.
05:23:05 <fax> >:|
05:23:10 <dmhouse> fax: HOFs are hard.
05:23:17 <dmhouse> ?djinn-env
05:23:18 <lambdabot> data () = ()
05:23:18 <lambdabot> data Either a b = Left a | Right b
05:23:18 <lambdabot> data Maybe a = Nothing | Just a
05:23:18 <lambdabot> data Bool = False | True
05:23:18 <lambdabot> data Void
05:23:20 <lambdabot> type Not x = x -> Void
05:23:20 <fax> that's cool
05:23:22 <lambdabot> class Eq a where (==) :: a -> a -> Bool
05:23:34 <int-e> @djinn (a -> b) -> Either a a -> Either b b
05:23:34 <lambdabot> f a b =
05:23:34 <lambdabot>     case b of
05:23:34 <lambdabot>     Left c -> Left (a c)
05:23:34 <lambdabot>     Right d -> Left (a d)
05:23:36 <fax> It should query you for advice when the proof is hard :p
05:23:57 <dmhouse> fax: or rather, it doesn't understand recursive datatypes. Or something. Don't remember.
05:24:09 <dmhouse> ?djinn-add data List a = Nil | Cons a (List a)
05:24:17 <dmhouse> ?djinn (a -> b) -> List a -> List b
05:24:18 <lambdabot> Cannot parse command
05:24:18 <lambdabot> -- f cannot be realized.
05:25:05 <dmhouse> Hmm, I wonder why it couldn't parse my list datatype.
05:25:25 <int-e> ?djinn Not (Not (((a -> b) -> a) -> a))
05:25:25 <lambdabot> Cannot parse command
05:25:25 <lambdabot> f :: Not (Not (((a -> b) -> a) -> a))
05:25:25 <lambdabot> f a =
05:25:25 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
05:25:32 <dmhouse> fax: but yeah, int-e just used it to prove that if a implies b, then (a or a) implies (b or b).
05:25:42 <dmhouse> ?djinn-env
05:25:42 <lambdabot> data () = ()
05:25:42 <lambdabot> data Either a b = Left a | Right b
05:25:42 <lambdabot> data Maybe a = Nothing | Just a
05:25:43 <lambdabot> data Bool = False | True
05:25:45 <lambdabot> data Void
05:25:46 <fax> cool
05:25:47 <lambdabot> type Not x = x -> Void
05:25:49 <lambdabot> class Eq a where (==) :: a -> a -> Bool
05:25:51 <lambdabot> Error: Recursive types are not allowed: List
05:26:09 <dmhouse> There we go. It can't do recursive types.
05:26:21 <fax> @djinn Not a -> b
05:26:21 <lambdabot> Cannot parse command
05:26:21 <lambdabot> -- f cannot be realized.
05:26:49 <ricky_clarkson> Did function-level programming get anywhere?
05:27:10 <dmhouse> ?djinn-del data List a = Nil | Cons a (List a)
05:27:10 <lambdabot> Cannot parse command
05:27:11 <crazy_coder> great
05:27:13 <ricky_clarkson> (also known as tacit programming, I think, and supported by the J programming language (and APL?))
05:28:03 <twanvl> Instead of defining the list data type you could try adding all the Data.List functions as axioms
05:28:42 <dmhouse> ?djinn Not (Not a) -> a
05:28:42 <lambdabot> -- f cannot be realized.
05:29:07 <int-e> ?djinn a -> Not (Not a)
05:29:08 <lambdabot> f a b = b a
05:29:13 <dmhouse> (Demonstration that C-H links type theory and _intuitionistic_ logic, so you don't get double negation elimination.)
05:29:27 <dmhouse> ?djinn-add data Pair a b = Pair a b
05:29:48 <dmhouse> ?djinn Pair a b -> a
05:29:49 <lambdabot> f a =
05:29:49 <lambdabot>     case a of
05:29:49 <lambdabot>     Pair b _ -> b
05:29:53 <ricky_clarkson> @djinn Integer -> a
05:29:53 <lambdabot> -- f cannot be realized.
05:29:58 <int-e> ?djinn Not (Not (Either a (Not a)))
05:29:58 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
05:30:19 <dmhouse> ?djinn Pair a (Not a) -> b
05:30:20 <lambdabot> f a =
05:30:20 <lambdabot>     case a of
05:30:20 <lambdabot>     Pair b c -> void (c b)
05:30:29 <fax> :t void (a (Right (\ b -> a (Left b))))
05:30:33 <lambdabot> Not in scope: `void'
05:30:33 <lambdabot>  
05:30:33 <lambdabot> <interactive>:1:6: Not in scope: `a'
05:30:35 <dmhouse> (A and ¬A allows you to prove anything.)
05:30:48 <opqdonut> ?djinn-env
05:30:49 <lambdabot> data () = ()
05:30:49 <lambdabot> data Either a b = Left a | Right b
05:30:49 <lambdabot> data Maybe a = Nothing | Just a
05:30:49 <lambdabot> data Bool = False | True
05:30:49 <lambdabot> data Void
05:30:51 <lambdabot> type Not x = x -> Void
05:30:53 <lambdabot> class Eq a where (==) :: a -> a -> Bool
05:30:55 <int-e> ?djinn Not (a, Not a)
05:30:55 <lambdabot> data Pair a b = Pair a b
05:30:57 <lambdabot> f (a, b) = b a
05:31:00 <fax> dmhouse: doesn't that mean proof by contradiction is unsound :)
05:31:02 <ricky_clarkson> I'm struggling to see how djinn proves things.
05:31:02 <int-e> :)
05:31:15 <dmhouse> ricky_clarkson: you need to read up on Curry-Howard.
05:31:29 <ricky_clarkson> I have.
05:31:37 <dmhouse> ricky_clarkson: basically think of types as propositions, Either as 'or', pairs as 'and', and functions as implication.
05:32:01 <dmhouse> ricky_clarkson: being able to find an expression with a given type amounts to proving the proposition expressed by that type.
05:32:19 <dmhouse> ricky_clarkson: so we ask djinn to prove propositions (types) by finding expressions with those types.
05:32:32 <ricky_clarkson> Hmm.
05:32:44 <dmhouse> ?djinn Pair a (a -> b) -> b
05:32:44 <lambdabot> f a =
05:32:44 <lambdabot>     case a of
05:32:44 <lambdabot>     Pair b c -> c b
05:32:50 <dmhouse> There, it just proved modus ponens.
05:33:22 <opqdonut> what's "void"
05:33:23 <dmhouse> You can get the list of axioms by doing ?djinn-env, and add/remove them with ?djinn-{add,del}.
05:33:34 <dmhouse> opqdonut: data Void; void :: Void -> a; void = undefined
05:33:38 <ricky_clarkson> So if you convert an expression into some function type, then find an expression that satisfies the function type, you've found a proof for the original expression?
05:33:52 <dmhouse> opqdonut: Void corresponds to falsity. Falsity implies anything.
05:34:05 <opqdonut> ah, yes
05:34:15 <kjdf> is there a library support or a common idiom for a perl-like string interpolation?
05:34:16 <dmhouse> ricky_clarkson: yep.
05:34:34 <dmhouse> kjdf: could you give an example of what perl-like string interpolation is?
05:34:40 <ricky_clarkson> dmhouse: Interesting.  Suppose I wanted to prove a+b-a==b, how would I do that?
05:34:52 <urkud> ?djinn a -> ((b -> c) -> ((a -> b) -> (a -> c)))
05:34:52 <lambdabot> f a b c _ = b (c a)
05:34:57 <ricky_clarkson> Or even just a-a==0
05:35:02 <fax> kjdf: Hopefully there's a better way than "foo " ++ (show foo) ++ ", bar " ++ (show bar)
05:35:08 <fax> but I don't know it :|
05:35:15 <dmhouse> ricky_clarkson: you need to codify addition, subtraciton, equality and numerals.
05:35:17 <kjdf> or any string interpolation :)
05:35:18 <int-e> you'd start by encoding natural numbers in the type level
05:35:21 <kjdf> printf-like
05:35:32 <fax> printf exists for haskell
05:35:33 <dmhouse> kjdf: well, there is Text.Prinf.
05:35:39 <int-e> Coq works that way.
05:35:45 <dmhouse> *Printf.
05:36:09 <ricky_clarkson> int-e: So suppose I have Zero and Succ.  Then what?
05:36:10 <dmhouse> ?djinn-add data Z = Z
05:36:19 <dmhouse> ?djinn-add data S a = S a
05:36:29 <ricky_clarkson> (I've read the intro to Coq but didn't follow enough of it)
05:36:49 <fax> ricky_clarkson: which intro?
05:36:52 <kjdf> thanks
05:37:14 <EvilTerran> @where haskerl
05:37:14 <lambdabot> I know nothing about haskerl.
05:37:20 <scook0> I suppose you could conceivably do (proper) string interpolation with TH, but I'm not aware of anyone actually having written a module to do it
05:37:39 <EvilTerran> yeah, that should be quite easy, actually
05:37:39 <dmhouse> ?djinn-add class TEq a b where teq :: a -> b; teq' :: b -> a
05:38:02 <ricky_clarkson> fax: http://coq.inria.fr/V8.1/tutorial.html
05:38:02 <ari> Augh, equality witnesses
05:38:08 <fax> ok thanks
05:38:12 * ari always looks away when they come on screen
05:38:17 <dmhouse> ?djinn-add instance TEQ Z Z where teq = id; teq' = id
05:38:17 <lambdabot> Cannot parse command
05:38:18 <EvilTerran> although you'd either have to wrap each string you wanted to interpolate on or your whole module in $(... [|...|])
05:38:28 <dmhouse> ?djinn-add instance TEq Z Z where teq = id; teq' = id
05:38:28 <lambdabot> Cannot parse command
05:38:38 <dmhouse> Hmm. Well, yeah, that should work.
05:38:38 <ricky_clarkson> fax: I haven't given up on understanding it, it just needs some closer attention than I gave it.
05:38:39 <int-e> djinn can't express this anyway.
05:39:02 <scook0> EvilTerran: yeah, them's the breaks
05:39:06 <dmhouse> You have that instance, and instance (TEq a b) => TEq (S a) (S b)
05:39:23 * EvilTerran would quite like some kind of "preprocess this whole file" thing for TH
05:39:52 <urkud> Hello! I'm new to haskell. I saw in some other (non strictly typed) functional languages types allowing something like the following: a = { b = { a = True; }; c = False; }; After that a.b == { a = True; }, a.c == False. Is there any analogue?
05:39:53 <EvilTerran> other than having to wrap everything, given how ugly that is
05:40:13 <dmhouse> urkud: records.
05:40:24 <urkud> dmhouse: Thank you.
05:40:39 <dmhouse> urkud: data Record = R { field1 :: Int, field2 :: Bool, field3 :: String }
05:40:55 <dmhouse> urkud: then let x = R { field1 = 5, field2 = True, field3 = "foo" }
05:41:07 <dmhouse> urkud: you can build on existing records: let y = x { field2 = False }
05:41:30 <EvilTerran> $$(...) or something.
05:41:35 <dmhouse> urkud: pattern matching: f (R { field1 = n }) = "field1 is " ++ show n
05:42:04 <dmhouse> urkud: and extract stuff: let z = field1 x
05:42:06 <opqdonut> has there been research on extending the type system with fixed points?
05:42:12 <opqdonut> like [[[[[[...]]]]]]]
05:42:35 <EvilTerran> maybe if a splice appeared above the module decleration,,, $(foo bar baz);module Foo where ... could be equivalent to $(foo bar baz [| module Foo where ... |])
05:42:35 <urkud> dmhouse: Thanks a lot.
05:42:54 <dmhouse> opqdonut: you can do newtype Mu f = In (f (Mu f))
05:42:56 <ricky_clarkson> I remember taking a Pascal compiler and seeing how many ((((())))) it could cope with before crashing.  I think 256.
05:43:16 <opqdonut> dmhouse: ah, of course
05:43:27 <opqdonut> because the typesystem is not strictly typed
05:43:41 <opqdonut> gah, that turned out wrong
05:43:49 <slarba_> opqdonut :)
05:43:55 <opqdonut> rather, because there is no meta-typesystem
05:44:33 <dmhouse> opqdonut: then, e.g., data ListF f a = Nil | Cons a (f a); type List a = Mu ListF a
05:44:40 <EvilTerran> i've seen, somewhere, a "kind" decleration syntax
05:44:54 <dmhouse> EvilTerran: yeah, kinds exist in Haskell.
05:44:57 <opqdonut> :D
05:45:02 <EvilTerran> i mean within haskell
05:45:05 <opqdonut> kind & =
05:45:18 <EvilTerran> but i can't for the life of me remember where i saw it, what it looked like, or what it did
05:45:22 <ari> @kind StateT
05:45:27 <ari> @kind (->)
05:45:27 <lambdabot> * -> (* -> *) -> * -> *
05:45:29 <lambdabot> ?? -> ? -> *
05:45:31 <EvilTerran> only that it introduced "kind ... = ..." as a decleration
05:45:38 <dmhouse> They're pretty basic. Anything of the form data TyCon = ... has kind *, anything data TyCon a = ... is * -> *, anything data TyCon a b c = * -> * -> *, etc.
05:45:38 <ari> Kinds look scary :(
05:45:59 <EvilTerran> i know (-.-)
05:46:11 <ari> Actually, I'm still somewhat unclear on what the question marks in (->)'s kind actually mean
05:46:13 <dmhouse> EvilTerran: ah, that's what you're talking about. Yeah, I remember that paper.
05:46:24 <dmhouse> ari: they're a GHC-specific thing.
05:46:28 <dmhouse> Lemme find the reference.
05:46:42 <idnar> @kind newtype Mu f = In (f (Mu f))
05:46:44 <lambdabot> parse error on input `newtype'
05:47:07 <EvilTerran> Mu :: * -> *
05:47:14 <dmhouse> ari:  http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes
05:47:17 <lambdabot> Title: IntermediateTypes - GHC - Trac, http://tinyurl.com/y76qhn
05:47:27 <dmhouse> where	*    [LiftedTypeKind]   means boxed type
05:47:27 <dmhouse> 	#    [UnliftedTypeKind] means unboxed type
05:47:27 <dmhouse> 	(#)  [UbxTupleKind]     means unboxed tuple
05:47:30 <dmhouse> 	??   [ArgTypeKind]      is the lub of *,#
05:47:33 <dmhouse> 	?    [OpenTypeKind]	means any type at all
05:48:35 <dmhouse> idnar: presumably it'd be (* -> *) -> *
05:48:37 <ricky_clarkson> :t lub
05:48:39 <lambdabot> Not in scope: `lub'
05:48:43 <EvilTerran> would it?
05:48:48 <dmhouse> ricky_clarkson: lowest upper bound.
05:48:51 <EvilTerran> so it is
05:48:55 <ricky_clarkson> Thanks.
05:48:59 <dmhouse> EvilTerran: well, fix :: (a -> a) -> a.
05:49:48 * ari sees
05:49:50 <DRMacIver> Hm. I'm quite happy with that. :)
05:50:01 <dmhouse> DRMacIver: with what?
05:50:07 <fax> @hoogle (a -> a -> a) -> [a] -> [a]
05:50:08 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
05:50:08 <lambdabot> Prelude.scanr1 :: (a -> a -> a) -> [a] -> [a]
05:50:08 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
05:50:46 <DRMacIver> dmhouse: Code I've just been playing with. It's very toy, but the results are satisfying nonetheless.
05:50:56 <DRMacIver> dmhouse: Reads in a list of points, constructs a quad tree out of them and displays that tree.
05:50:56 <dmhouse> DRMacIver: what does it do?
05:51:26 <ricky_clarkson> DRMacIver: Did you decide on a scripting language?  Is there a reason why it needs to be dynamically typed?  Perhaps Haskell is easier to lock down than some.
05:52:06 <dmhouse> DRMacIver: what library does it use for the output?
05:52:13 <DRMacIver> dmhouse: HOpenGL
05:52:41 <DRMacIver> ricky_clarkson: It needs to interoperate with Java and be easy for non programmers to use. I also need to be able to suggest it without being laughed at. ;)
05:52:49 <DRMacIver> ricky_clarkson: But we decided on JRuby anyway.
05:53:33 <crazy_coder> :)
05:53:47 <DRMacIver> Very exciting images that result from my toy code: http://img134.imageshack.us/img134/3312/quadtreens7.png
05:55:17 <matthew-_> DRMacIver: I've got an implementation of OctTrees if you want it
05:56:14 <DRMacIver> matthew-_: Thanks. At some point I might well ask you for that. I definitely will if I try to do anything serious. :) Right now I'm just playing.
05:56:33 <dmhouse> DRMacIver: so each input point becomes a point at where four edges meet?
05:56:43 <matthew-_> yeah, mine's pretty heavily optimised and in use in real situations
05:57:06 <matthew-_> dmhouse: no, it should be that each square contains 0 or 1 points.
05:57:11 <DRMacIver> dmhouse: Nah. The input points lie somewhere inside a square. Actually, they're supposed to be rendered on that image. I'm not sure why they're not.
05:57:37 <dmhouse> matthew-_: ah.
05:58:12 <matthew-_> dmhouse: is just a multi-dimension binary tree
05:58:22 <crazy_coder> heh
05:58:48 <crazy_coder> I just created mybot
05:58:53 <DRMacIver> matthew-_: Yeah, my implementation is hilariously non optimised. Like I say, it's just a toy. :)
05:59:17 <crazy_coder> by reading the tutorial ie
05:59:42 <crazy_coder> anyways gtg
05:59:49 <crazy_coder> goodbye everyone
06:05:36 <fax> In Parsec, why don't prefix and postfix ops take a (left/none/right) associativity?
06:07:04 <opqdonut> ah, for something like "-#x!?"
06:07:12 <opqdonut> where - and # are prefix and ! and ? postfix
06:07:15 <fax> yeah :p
06:07:38 <opqdonut> i think the relevant word is precedence here
06:08:10 <opqdonut> or do you mean (x!)? vs x(!?) ?
06:08:16 <DRMacIver> (Hm. It looks like not only is my code non-optimised, it's also wrong. How sad.)
06:08:59 <fax> I think it's like
06:09:04 <fax> fy 2 yf ≡ fy (2 yf)
06:09:27 <fax> where fy is a right associative prefix, and yf is a left associative postfix op
06:09:46 <olsner> DRMacIver: incorrect code? and it compiles? can't be!
06:09:54 <opqdonut> thadthat doesn't make senese
06:09:56 <fax> actually.. I think I might need to just re-read some things :|
06:09:56 <opqdonut> -e
06:10:14 <wli> DRMacIver: You mentioned some structural subtyping issues...
06:10:39 <wli> DRMacIver: Is structural subtyping really OO?
06:10:51 <opqdonut> "(fy 2) yf" vs "fy (2 yf)" is a matter of precedence not associativity
06:11:10 <hpaste>  fax pasted "ops table" at http://hpaste.org/2767
06:11:35 <fax> That's what I have describing the xfy type things
06:12:09 <opqdonut> you've misunderstood associativity
06:12:32 <opqdonut> it doesn't apply to unary operations
06:13:08 <fax> if + is left associative, a+b+c+d ≡ (((a+b)+c)+d), and if its right associative (a+(b+(c+d)))?
06:13:44 * LoganCapaldo nods
06:14:08 <wli> Enter octonions. ;)
06:17:15 <fax> opqdonut: It's from the ISO prolog specification :|
06:17:40 <fax> I think this just means I can't use buildExpressionParser.. have to deal with each case manually
06:18:44 <fax> it looks like they use the associativity of monadic operators to cope with precedence though
06:22:33 <DRMacIver> ok. The code seems to be ok. It was the data I was feeding it that was wrong. :)
06:22:48 <DRMacIver> wli: I don't think I said 'structural'.
06:23:36 <DRMacIver> wli: And no, subtyping isn't inherently connected to OO. The OOesque code I tend to write in other languages tends to look more like an attempt at a first class module system than related to subtyping. :)
06:23:39 <wli> DRMacIver: Where does structural subtyping fit in?
06:24:14 <DRMacIver> Beats me. :)
06:24:22 <DRMacIver> Placating the dynamic typing advocates? ;)
06:25:25 <wli> Oh, I like it as a thing unto itself actually.
06:25:44 <pejo> People interpret OO in too many ways. Some think C++, others think Smalltalk.
06:25:46 <DRMacIver> Yes, so do I. It was a cheap shot. :)
06:28:04 <DRMacIver> Really I think structural typing is most strongly connected to record types, which are pretty much orthogonal to imperative/functional, but not really very object orientated despite the superficial resemblance.
06:28:15 <DRMacIver> (i.e. objects aren't just records of functions. :) )
06:28:55 <pejo> DRMacIver, what more do you want, state?
06:29:56 <DRMacIver> pejo: The point is that records expose their data and provide no other means of operating on it. Objects hide their data and *only* provide means for operating on it.
06:30:14 <wli> DRMacIver: I find structural subtyping most useful when applied to coproducts.
06:30:15 * DRMacIver mumbles something about data, codata and duality
06:30:19 <DRMacIver> Of course, a lot of languages blur the lines between these things. (e.g. public fields).
06:30:22 <Philippa> DRMacIver: build your record from inside a let statement
06:30:28 <Philippa> objects /aren't/ codata
06:31:05 <Philippa> not mutable ones, not as such
06:31:31 <Philippa> fields that aren't methods are an irrelevance anyway, no?
06:31:53 <Philippa> that is, it's just sugar for a bunch of operations again
06:32:25 <wli> I don't give a hoot about records or methods. Structural subtyping as applied to coproducts rocks my world.
06:32:34 <opqdonut> coproducts?
06:32:39 <Philippa> "sums"
06:32:44 <Philippa> and yeah, I could use that at the moment
06:32:57 <wli> data Coproduct = A ... | B ... | C ... | ...
06:33:09 <opqdonut> ah
06:33:21 <DRMacIver> Philippa: Sure. You can create an object system from anonymous functions. This isn't really news. :) (And fair point about mutable objects. I was thinking of immutable ones)
06:34:01 <DRMacIver> Also fair point about fields. I guess what I really had in mind is that they're a sign of objects being used as data. Anyway, I don't really know what I'm talking about here, so I'll shut up. :)
06:34:36 <wli> t <= t' if things of type t can be used anywhere things of type t' can be used, so t is a coproduct with all the constructors of t' and possibly more.
06:34:59 <DRMacIver> wli: Good point. :)
06:35:23 <wli> Or I have it backward.
06:35:35 <wli> Either way it's relatively obvious why it's really bloody useful.
06:36:30 <DRMacIver> Yeah
06:37:23 <DRMacIver> (You can of course more or less do that in Haskell by making your sum types type classes instead. It's just a little annoying. :) )
06:39:42 <olsner> isn't this what Views are supposed to do?
06:41:06 <wli> I don't think views are about the same thing.
06:41:43 <wli> They seem to be a more original concept.
06:45:09 <wli> DRMacIver: Those sorts of encodings are for various sorts of proofs, not for humans to program in.
06:47:23 <DRMacIver> Well, this instance isn't that annoying for humans to program in.
06:48:04 <DRMacIver> But it would be nicer to have language support for it, yes. :)
06:48:10 <QuietPurple> hey, i am using the GLUT library, and i'd like to change my window size---do i use the windowSize command as "windowSize (600,600)"
06:48:15 <QuietPurple> ?
06:48:32 <Japsu> why don't you just try
06:48:34 <QuietPurple> ('cos it don't work)
06:48:36 <Japsu> right.
06:49:34 <QuietPurple> the documentation says "windowSize :: StateVar Size"
06:49:49 <EvilTerran> windowSize $= (600,600), i think
06:49:56 <QuietPurple> ok
06:50:09 <EvilTerran> ?type Graphics.UI.GLUT.$=
06:50:11 <QuietPurple> so windowSize is a name, not a function
06:50:11 <lambdabot> parse error on input `Graphics.UI.GLUT.$='
06:50:34 <EvilTerran> if it were a function, it would have a -> in its name
06:50:38 <EvilTerran> *type, rather
06:50:39 <QuietPurple> yeah
06:50:50 <EvilTerran> windowSize :: Size -> IO (), or something
06:51:29 <QuietPurple> but it doesn't make sense having a name that changes! change implies temporality
06:52:15 <EvilTerran> @docs Graphics.Rendering.OpenGL.GL.StateVar
06:52:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
06:52:42 <EvilTerran> ($=) :: s a -> a -> IO ()
06:53:03 <EvilTerran> specialising, ($=) :: StateVar Size -> Size -> IO ()
06:53:07 <DRMacIver> Anyway, I've spent far too much time in front of the computer this weekend.
06:53:11 * DRMacIver goes cycling
06:53:20 <EvilTerran> > cycle "DRMacIver"
06:53:22 <lambdabot>  "DRMacIverDRMacIverDRMacIverDRMacIverDRMacIverDRMacIverDRMacIverDRMacIverDRM...
06:53:47 <DRMacIver> Ha
06:54:16 <QuietPurple> >cycle "cycling is environmentally friendly"
06:54:30 <QuietPurple> > cycle "cycling is environmentally friendly"
06:54:31 <lambdabot>  "cycling is environmentally friendlycycling is environmentally friendlycycli...
06:54:59 <EvilTerran> QuietPurple, so ($=) is function which takes a value identifying a "StateVar", and a new value for the StateVar, and returns an IO action that (presumably) updates the StateVar when run
06:55:17 <wli> I'm relatively sure there's a point at which the encoding becomes awkward.
06:55:46 <QuietPurple> ok, so StateVar and $= are tied up with monsters to allow change to occur
06:55:53 <wli> I think it has to do with when there are numerous distinct anonymous upper bounds.
06:56:09 <EvilTerran> note that the section (windowSize $=) :: Size -> IO (), which is what you apparently expected windowSize itself to be
06:56:17 <wli> Or lower bounds.
06:56:44 <wli> Or both, really.
06:57:00 * QuietPurple thinks he understands
06:57:07 <QuietPurple> perhaps..
06:57:30 <QuietPurple> i will go test it
06:58:20 <wli> Consider, for instance, data Coproduct = A { a1 :: t_a1, ... } | B { b1 :: t_b1, ... } | ...
06:58:44 <wli> You can get a bunch of lower and upper bounds going at once there.
06:59:02 <QuietPurple> ok, now it won't accept (600, 600) as a valid Size
06:59:12 <QuietPurple> i've tried (600,600)::Size
06:59:26 <EvilTerran> QuietPurple, it's like you could write the action (hPutStr stderr "blarg im ded") as (stderr `hPutStr` "blarg im ded"), if you wanted
06:59:34 <wli> The class encoding requires you to name most that occur, or otherwise set up classes where otherwise you'd not have to do anything at all.
06:59:43 <EvilTerran> hm. it's likely Size /= (Int,Int)
07:00:16 <QuietPurple> yes, so (600,600) aught to be fine...
07:00:31 <QuietPurple> oh, sorry, /=
07:00:32 <EvilTerran> er, (/=) means "not equal" in haskell
07:00:48 <EvilTerran> as well as upside-down nonplussed guy
07:00:58 <QuietPurple> why should Size /= (Int,Int)
07:01:25 <EvilTerran> @docs Graphics.Rendering.OpenGL.GL.CoordTrans
07:01:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-CoordTrans.html
07:01:37 <EvilTerran> "data Size = Size !GLsizei !GLsizei"
07:01:53 <kpreid> so, Size 600 600
07:01:58 <EvilTerran> "GLsizei" is just another integer type, so you don't need to worry about that particularly
07:02:01 <fax> What does the ! mean?
07:02:07 <allbery_b> strict
07:02:22 <EvilTerran> the "!"s means the constructor is strict in each parameter - you don't need to worry about that particularly either
07:02:31 <fax> Why?
07:02:44 <EvilTerran> as kpreid says, "Size 600 600" should work
07:02:47 <fax> I mean it will get calculated when it's need anyway, won't it?
07:03:03 <kpreid> fax: the !s mean there is no such value as "Size 100 undefined", for example
07:03:16 <fax> oh ok
07:03:20 <QuietPurple> so, windowSize $= Size 600 600
07:03:20 <EvilTerran> if either side is bottom, the whole thing is
07:03:24 <fax> seems a bit strange
07:03:28 <EvilTerran> yeah, try that, QP
07:03:28 <kpreid> QuietPurple: yes
07:03:35 <QuietPurple> ok, will do
07:04:09 <EvilTerran> fax, i guess it's because the whole thing is useless if either parameter is, so this merely makes the inevitable failure happen sooner
07:04:19 * QuietPurple does a little dance of celebration
07:05:03 <fax> seems bizarre
07:05:23 <kpreid> I sometimes think the GL bindings go a little overboard with type distinctions
07:05:28 <fax> it doesn't make interaction with the FFI easier does it?
07:06:07 <mrd> ghc can unbox strict types like that too
07:06:17 <EvilTerran> it adds sanity checking, too
07:06:19 <fax> ahh
07:06:23 <fax> that's reasonable
07:06:34 * QuietPurple is looking at a 600 by 600 image of the mandelbrot set!
07:06:34 <EvilTerran> stops you getting the position and size parameters of a function with a gazillion parameters swapped
07:07:22 * EvilTerran inserts parentheses around "a function ... parameters"
07:07:24 <allbery_b> -funbox-strict-fields optimization?
07:07:44 * EvilTerran goes out
07:17:55 <dmhouse_> Wow, there's actually a datastructure called the 'DAWG': http://en.wikipedia.org/wiki/Directed_acyclic_word_graph
07:17:56 <lambdabot> Title: Directed acyclic word graph - Wikipedia, the free encyclopedia
07:19:21 <QuietPurple> ahhhh! fractal geometry... who needs LSD when you have the complex plane?
07:19:44 <Japsu> @remember QuietPurple ahhhh! fractal geometry... who needs LSD when you have the complex plane?
07:19:45 <lambdabot> Done.
07:21:11 <QuietPurple> that's quite cool---how do you get lambdabot to repeat things it remembers?
07:21:26 <fax> Look up Beyond the Minds Eye on YouTube :)
07:21:41 <QuietPurple> hmmm
07:22:20 <wolverian> @quote QuietPurple
07:22:21 <lambdabot> QuietPurple says: ahhhh! fractal geometry... who needs LSD when you have the complex plane?
07:22:46 <QuietPurple> @quote wolverian
07:22:46 <lambdabot> No quotes match. I feel much better now.
07:22:56 <QuietPurple> @quote evilterran
07:22:56 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
07:22:57 <wolverian> I'm boring.
07:23:12 <QuietPurple> @quote fax
07:23:12 <lambdabot> No quotes match. stty: unknown mode: doofus
07:23:18 <fax> mine got erased
07:23:28 <QuietPurple> oh, that's a pity
07:23:56 * fax got quoted saying something like "I woke up with a headache after dreaming all night about Monads and stuff"
07:23:59 <fax> which I did >:|
07:24:34 <opqdonut> @quote lambdabot
07:24:35 <lambdabot> lambdabot says: @quote lambdabot
07:24:40 <opqdonut> ;D
07:24:42 <opqdonut> @quote lambdabot
07:24:43 <lambdabot> lambdabot says: tERmIN473d
07:25:06 <Saizan> @quote saizan
07:25:07 <lambdabot> No quotes match. stty: unknown mode: doofus
07:25:11 <Saizan> @quote Saizan
07:25:11 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
07:25:25 <opqdonut> :))
07:25:29 <opqdonut> @quote opqdonut
07:25:30 <lambdabot> No quotes match. Are you on drugs?
07:25:33 <opqdonut> probably
07:25:48 <QuietPurple> hehe
07:26:12 <Saizan> (it was new year's eve.. and i was also asking in which dimension they were)
07:28:43 * allbery_b is somewhat obsessively @flush-ing his lambdabot after some failures which he suspects lost state
07:40:19 <shapr> @yow !
07:40:20 <lambdabot> In 1962, you could buy a pair of SHARKSKIN SLACKS, with a "Continental
07:40:20 <lambdabot> Belt," for $10.99!!
07:41:00 <shapr> It's really irritating that libcurl3 is broken in debian/unstable! grr!
07:52:53 <Lemmih> shapr: Install from source?
08:05:17 <EvilTerran> @quote EvilTerran
08:05:18 <lambdabot> EvilTerran says: look for GNU HaltingProblem; it's still in beta, but it might do what you want
08:05:20 <EvilTerran> 'tis case sensitive, methinks
08:12:30 * EvilTerran notes that he has a text file open that reads "-- TODO: BF interpreter"
08:13:11 <olsner_> BF interpreter? doesn't sound too hard
08:13:23 <EvilTerran> yes, quite
08:13:38 <fax> if you want hard.. write something which takes a string and outputs the shortest bf program which outputs that string
08:13:58 <EvilTerran> wondering if i should make it :: String -> String rather than doing IO
08:14:37 <EvilTerran> ("it" = the end result of processing the BF source)
08:16:10 <kpreid> yes
08:16:26 <kpreid> or how about MonadReader + MonadWriter?
08:16:46 <shapr> Lemmih: Tried that
08:16:48 <EvilTerran> i'm in the process of looking those up to see if they're appropriate
08:16:51 <kpreid> er, wait, I forget again that Reader isn't a stream thing.
08:16:52 <kpreid> hmf.
08:18:52 * EvilTerran has the impression from somewhere that reader is like having a stack
08:19:10 <EvilTerran> that may be appalingly wrong
08:19:45 <olsner_> don't BF's looping constructs essentially use a stack?
08:19:54 <fax> more like a goto
08:20:12 <Heffalump> the reader monad is closest to having implicit parameters, really
08:20:16 <EvilTerran> local to "push", ask to "peek"
08:20:22 <oerjan> olsner_: they could
08:20:30 <EvilTerran> and implicit popping when you leave the local
08:21:01 <Heffalump> well, it's a stack that mirrors the evaluation stack (ignoring laziness)
08:21:06 <Heffalump> so not a very general-purpose one
08:21:46 <oerjan> although branch and goto is enough for compiling bf looping
08:21:48 <EvilTerran> quite. for a general one, you'd need State, i guess
08:23:12 <shapr> Lemmih: You wouldn't happen to have libssh2-0* in /var/cache/apt/archives would you?
08:24:11 <Lemmih> shapr: Nope.
08:24:40 <QuietPurple> sheesh, my mum is demanding. she wants me to show her the mandelbrot set using \z -> z^8 + c (instead of z^2 like normal)
08:25:19 <EvilTerran> push x = modify (x:); pop = do { x:xs <- get; put xs; return x }; peek = liftM head get
08:25:32 <QuietPurple> we think it will have 7 axes of symmetry
08:27:03 <EvilTerran> intuitively, raising it to an ever-higher power should make it tend towards a circle...
08:27:22 <fax> QuietPurple: rotational symmetry
08:28:29 <lord_sesshomaru> join #scheme
08:28:52 <EvilTerran> no thanks
08:28:58 <Philippa> no. Don't walk in here and just paste ads like that
08:29:17 <fax> I think it was an accident..
08:29:19 * EvilTerran suspects that was supposed to have a leading /, but still
08:29:25 <lord_sesshomaru> sorry, I missed the slash
08:29:43 <monochrom> quit
08:29:47 <QuietPurple> aaargh! my program has just died
08:29:59 <QuietPurple> i am also late for choir practice
08:30:02 <monochrom> (I'm advertising for real life :) )
08:30:37 <QuietPurple> fax: yes, it will have rotational symmetry, but there are also 7 conventional axes of symmetry
08:30:50 <QuietPurple> see y'all
08:30:53 <fax> really
08:31:01 <oerjan> 7, not 8?
08:31:10 <fax> I think he's wrong
08:31:11 <fax> http://classes.yale.edu/Fractals/MandelSet/MandelDef/HigherMandels/HigherMandels.html
08:31:11 <oerjan> ah he left
08:31:12 <EvilTerran> hmm
08:31:13 <lambdabot> Title: Fractal Geometry, http://tinyurl.com/27htlz
08:31:40 <EvilTerran> fax, that agrees with him
08:32:01 <fax> oh so a rectangle has two axis of symmetry
08:32:04 <oerjan> hey, yeah he's right
08:33:03 <fax> hm
08:33:12 <fax> I mean you an only fold z^8+c in half once
08:33:21 <fax> but there's 7 different places you can fold it up
08:33:52 <wli> Cyclotomy?
08:36:46 <crazy_coder> hello everyone
08:36:49 <oerjan> (z/w)^8+c/w = z^8/w^8+c/w = (z^8+c)/w if w=w^8 <=> w^7=1
08:37:23 <oerjan> so it is not so hard to see
08:41:59 <EvilTerran> is there any functional difference between @tell and @ask?
08:42:30 <oerjan> they are complete opposites?
08:42:47 <EvilTerran> @help @tell
08:42:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:42:48 <oerjan> er wait
08:42:49 <EvilTerran> @help @ask
08:42:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:42:58 <oerjan> didn't see the @'s :)
08:43:05 <EvilTerran> sorry, i'm not talking about Reader any more ;]
08:43:36 <EvilTerran> (or Writer, for that matter)
08:43:38 <oerjan> maybe lambdabot delivers the message in a different way
08:43:48 <oerjan> @tell EvilTerran Like this
08:43:48 <lambdabot> Consider it noted.
08:43:55 <oerjan> @ask EvilTerran Or like this?
08:43:55 <EvilTerran> ...
08:43:56 <lambdabot> EvilTerran: You have 1 new message. '/msg lambdabot @messages' to read it.
08:43:56 <lambdabot> Consider it noted.
08:44:00 <EvilTerran> @messages
08:44:00 <lambdabot> oerjan said 12s ago: Like this
08:44:00 <lambdabot> oerjan asked 5s ago: Or like this?
08:44:05 <EvilTerran> ah, i see.
08:44:35 <fasta> Anyone familiar with R?
08:44:37 * EvilTerran notes that we have memoserv as well as lambdabot's message service
08:44:53 <crazy_coder> has anyone written an IRC client running in console in Haskell ?
08:46:33 <EvilTerran> not AFAIK. is there a curses binding? it might be a little awkward without
08:46:56 <crazy_coder> EvilTerran: is this to me ?
08:47:04 <EvilTerran> yes
08:47:39 <crazy_coder> Ok . I am writing one
08:47:44 <olsner_> IRC clients have been written in haskell; there's lambdabot for example... but it doesn't include a console interface obviously
08:48:59 <crazy_coder> hsColor has limited colors
08:49:11 <olsner_> and there was someone in #haskell working on an IRC parser in parsec pretty recently
08:49:31 <crazy_coder> what is parsec
08:50:11 <fax> parsec is a combinator parser
08:50:23 <fax> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
08:50:42 <fax> I'm using it just now.. It's very good
08:53:12 <crazy_coder> is there a random number generator function in Haskell ?
08:53:48 <EvilTerran> @docs Data.Random
08:53:49 <lambdabot> Data.Random not available
08:53:54 <EvilTerran> um, wait
08:53:56 <EvilTerran> @hoogle Random
08:53:57 <lambdabot> Random :: module
08:53:57 <lambdabot> System.Random :: module
08:53:57 <lambdabot> System.Random.Random :: class Random a
08:54:03 <EvilTerran> @docs System.Random
08:54:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
08:54:05 <EvilTerran> there we go
08:54:26 <EvilTerran> i seem to recall it's not very highly regarded, though
08:55:41 <EvilTerran> i can't remember what sort of generator it is
08:58:14 <wli> Yeah, we need a Mersenne Twister -based System.Random
08:59:51 * EvilTerran realises that fmap appears to be associative across instances
08:59:55 * EvilTerran 's brain explodes
09:00:22 <oerjan> EvilTerran: you could have made . a synonym for it
09:00:40 <oerjan> except someone claimed you cannot, for some reason he never explained here
09:00:56 <EvilTerran> (map (f.g) xs = map f (map g xs), so fmap (fmap f g) xs = fmap f (fmap g xs))
09:01:36 <EvilTerran> yeah, i'm just reading the Mark P Jones higher-order polymorphism book/paper/whatever it is
09:01:41 <EvilTerran> which mentions this
09:02:22 <EvilTerran> I don't see a problem with doing so, oerjan, beyond "oh no the newbies will get confused"
09:03:26 * EvilTerran thinks the core of a language should be designed without excess regard for newbie-friendliness, and maybe you could have a simplified version for beginners if necessary.
09:03:57 * conal agrees
09:04:02 <EvilTerran> ie, let's have monad comprehensions, no monomorphism restriction, (.) = fmap, etcetc.
09:04:12 <conal> amen
09:04:29 <oerjan> = map :)
09:04:37 <conal> i miss (++) = mappend :(
09:04:51 <EvilTerran> then add an -fnewbie flag, with other flags to switch things off piecewise as the newbie learns the fancy bits
09:04:57 <EvilTerran> *off/on
09:05:01 * oerjan wonders what ** should generalize to
09:05:23 <wli> Well, we've got the bloody source. Where is all this hardwired in ghc?
09:06:07 <EvilTerran> ... in the source? **ducks**
09:06:36 <EvilTerran> conal, indeed. make all the list functions monady where it makes sense to do so.
09:06:39 <EvilTerran> [] = mzero?
09:07:32 <conal> EvilTerran: and/or monoidy
09:07:37 <EvilTerran> indeed
09:07:59 <conal> my current projects have lots of monoid code
09:08:02 * EvilTerran wants a group theory class heirarchy
09:08:11 <EvilTerran> with the numeric types in terms of it
09:08:20 <allbery_b> isn't one of the issues that comes up that there are multiple appropriate monoids in many cases?
09:08:33 <allbery_b> and haskell doesn't handle that well
09:08:48 <conal> allbery_b: yes.  other classes as well, but especially monoid
09:08:54 <wli> Monad comprehensions are enough.
09:08:57 <EvilTerran> yeah, you've got to use newtypes
09:09:01 <oerjan> > mconcat . map Sum $ [1..10]
09:09:04 <lambdabot>  Sum {getSum = 55}
09:09:07 <oerjan> > mconcat . map Product $ [1..10]
09:09:09 <lambdabot>  Product {getProduct = 3628800}
09:09:10 <EvilTerran> dependent types'd be good
09:09:40 <conal> EvilTerran: how's that?
09:09:57 <EvilTerran> they just would be :D
09:10:17 <conal> EvilTerran: i bet you're right.
09:10:19 <wli> This is somewhere in desugaring, right?
09:10:58 <EvilTerran> oerjan, that particular example could be remedied with instance Num a => Num (Sum a) etc, but i guess that wouldn't work in general
09:11:11 <oerjan> probably also in typing, since i hear that is done before desugaring
09:11:11 * EvilTerran finds the ZipList newtype issue particularly painful
09:11:58 <conal> EvilTerran: for Applicative?
09:12:02 <EvilTerran> yeah
09:12:14 <oerjan> someone add zap = zipWith id
09:12:55 <Japsu> hmm?
09:12:56 <Japsu> so...
09:13:14 <Japsu> > let zap = zipWith id in zap [(+1),(+2)] [1,2,3]
09:13:15 <lambdabot>  [2,4]
09:13:45 <Japsu> doesn't make sense to me. what's the purpose of zap?
09:14:06 <Japsu> oops
09:14:06 <oerjan> it's the applicative <*> for zipping
09:14:06 <Japsu> nvm
09:14:32 <Japsu> > let zap = zipWith id in zap [(+1),(+2)] [5,6] -- let's not have longer ys confusing me
09:14:34 <lambdabot>  [6,8]
09:14:49 <EvilTerran> thing is, if you only want to express the instance associated with the newtype in one place, instead of having to wrap all the values with the newtype, you're back to passing the instance's methods around as values
09:15:28 <EvilTerran> @let zap = zipWith ($); infixl 4 `zap`
09:15:33 <lambdabot> Defined.
09:15:50 <oerjan> hey, you managed to add fixity
09:16:01 <Japsu> hmm
09:16:03 <EvilTerran> > repeat (,,) `zap` [1..10] `zap` ['a'..'j'] `zap` repeat ()
09:16:04 <oerjan> for some reason i couldn't get that right
09:16:05 <lambdabot>  [(1,'a',()),(2,'b',()),(3,'c',()),(4,'d',()),(5,'e',()),(6,'f',()),(7,'g',()...
09:16:14 <EvilTerran> no more zipWithN!
09:16:24 <Japsu> > (+1) `id` 3
09:16:25 <lambdabot>  4
09:16:27 <Japsu> lol
09:16:28 <Philippa> > Prelude.(+)
09:16:29 <lambdabot>   Not in scope: data constructor `Prelude'
09:16:32 <EvilTerran> oerjan, i imagine it has to be part of the same @let
09:16:43 <Japsu> never realized that ($) is practically id
09:16:43 <Philippa> fine...
09:16:49 <oerjan> i did that, but i recall i put the infixl first
09:16:52 <Philippa> @let id = "hah"
09:16:54 <lambdabot> Defined.
09:16:55 <Philippa> > id
09:16:56 <lambdabot> Terminated
09:17:03 <Philippa> ...
09:17:11 <Philippa> @let id = \x->x
09:17:12 <lambdabot> <local>:6:0:     Multiple declarations of `L.id'     Declared at: <local>:5:0...
09:17:15 <oerjan> > (Prelude.+)
09:17:17 <lambdabot>  <Integer -> Integer -> Integer>
09:17:23 <Philippa> oerjan: d'oh, yeah
09:17:26 <EvilTerran> Japsu, think about it: (id f = f), so (id f x = (id f) x = f x)
09:17:35 <Philippa> > L.id
09:17:37 <lambdabot>  "hah"
09:17:37 <Japsu> yeah
09:17:42 <Japsu> cool
09:17:51 <Philippa> okay, good, it's resilient to what I was testing :-)
09:17:57 <EvilTerran> likewise, f $ x = f x; ($) f x = f x;  ($) f = f; ($) = id
09:18:20 <conal> Philippa: what's L here?
09:18:33 <EvilTerran> it's the namespace @let things go into, iirc
09:18:46 <conal> oh
09:18:58 <conal> is that a ghci thing or a lambdabot thing?
09:18:58 <EvilTerran> > L.zap
09:18:59 <lambdabot>  Add a type signature
09:19:03 <EvilTerran> lambdabot
09:19:08 <conal> ah
09:19:09 <EvilTerran> @type L.zapp
09:19:11 <lambdabot> Not in scope: `L.zapp'
09:19:11 <EvilTerran> @type L.zap
09:19:13 <lambdabot>     Interface file inconsistency:
09:19:13 <lambdabot>       home-package module `L' is mentioned,
09:19:18 <omniscientIdiot> :O
09:19:18 <EvilTerran> good lord!
09:19:28 <EvilTerran> actually, it might be an hsPlugins thing
09:20:01 <oerjan>  @type doesn't communicate with @let
09:20:25 <oerjan> > [L.zap,()]
09:20:26 <lambdabot>  Couldn't match expected type `[a -> b] -> [a] -> [b]'
09:20:37 * EvilTerran thinks zap should be in Data.List, given that it's the most common instance of Applicative that you need a newtype to get at otherwise
09:21:17 <oerjan> especially given that all the zipWith*s are already there
09:21:26 <EvilTerran> > zipWith8
09:21:27 <lambdabot>   Not in scope: `zipWith8'
09:21:33 <oerjan> well, many of them :D
09:21:35 <EvilTerran> quite
09:21:46 <EvilTerran> the first few of a countable infinity ;]
09:22:01 <omniscientIdiot> zap is ZipList's ap?
09:22:20 <EvilTerran> @src ZipList (<*>)
09:22:20 <lambdabot> Source not found. Do you think like you type?
09:22:26 <conal> minus the newtype wrapping/unwrapping
09:22:26 <oerjan> ZipList's <*>, ap is Monad's <*>
09:22:32 <EvilTerran> what oerjan said
09:22:37 <omniscientIdiot> yeah, same thing :P
09:22:46 <mrd> :t (<*>)
09:22:48 <EvilTerran> i don't think zipping is a valid monad
09:22:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:22:50 <oerjan> just thought the name fit
09:22:54 <omniscientIdiot> you say liftM, I say fmap
09:23:14 <EvilTerran> oerjan, the paper that introduced Applicative called it `zapp`, iirc.
09:23:45 <omniscientIdiot> EvilTerran: I believe it is.  join would be taking the diagonal, return = repeat
09:23:56 <EvilTerran> bind?
09:24:08 <omniscientIdiot> join + fmap, as usual
09:24:12 <conal> speaking of which, i prefer fmap & <*> over liftM & ap, because then i get to see whether my code works on Applicative rather than just Monad.  it's helped me generalize.
09:24:14 <oerjan> oh :)
09:24:16 <EvilTerran> hm.
09:24:29 <EvilTerran> conal, what about <$> over fmap?
09:25:00 <conal> EvilTerran: a wash.  depends on whether i want to use infix.
09:25:08 <EvilTerran> i see =]
09:25:16 <omniscientIdiot> too many names for precisely the same thing.  Too confusing for newbies.
09:25:24 <conal> though i associate <$> with Applicative even though i know better, so i lean toward fmap
09:25:37 <EvilTerran> @src (<$>)
09:25:37 <lambdabot> f <$> a = fmap f a
09:25:43 <conal> omniscientIdiot: growing pain.  the more general names came later
09:26:02 <EvilTerran> we should just call 'em all (.) and have done with it
09:26:05 <omniscientIdiot> I realize that
09:26:40 <conal> EvilTerran: it's short
09:27:06 <conal> yo dons
09:27:13 * Philippa hands EvilTerran a single combinator base
09:27:26 <EvilTerran> ooh, ooh, which one do i get?
09:27:30 <dons> hey
09:27:47 <Philippa> That would be telling :-)
09:28:00 <oerjan> conal: + no class aliases so it's awkward to use the same name everywhere
09:28:25 * EvilTerran hopes it's (\x.x S K)
09:28:27 <conal> oerjan: what's the class alias connection?
09:28:56 <wli> compiler/deSugar/DsListComp.lhs looks pertinent.
09:29:05 <oerjan> conal: you could then say define fmap for Monad without requiring an extra instance
09:29:31 <oerjan> or explicitly writing it down every time
09:29:51 <conal> with a class alias?  how?
09:30:37 <oerjan> well, that's how understand the class alias proposal - things for superclasses can be defined in the class or instance declarations for the subclass
09:30:55 <oerjan> *things needed for
09:31:02 <conal> oerjan: that'd be great
09:31:48 <EvilTerran> class Functor m => Monad m where fmap f x = return f =<< x --?
09:31:58 <oerjan> EvilTerran: someting like that
09:32:10 <EvilTerran> that'd be great
09:32:17 <EvilTerran> whoa, that's creepy...
09:32:24 <conal> yeah
09:32:28 <conal> ;)
09:32:30 * EvilTerran prods conal with his clone detector
09:32:44 * EvilTerran prods himself with it
09:32:47 * conal prods back in exactly the same way
09:32:50 <EvilTerran> **beepbeepbeepbeep**
09:33:34 <oerjan> relax, you're just identical twins separated at birth
09:34:39 <LoganCapaldo> first, stereo now clones
09:34:39 <olsner_> A clone by any other name ...
09:34:44 <dons> ?users
09:34:44 <oerjan> the only problem is finding out who is the good and who is the evil twin
09:34:45 <lambdabot> Maximum users seen in #haskell: 407, currently: 378 (92.9%), active: 18 (4.8%)
09:34:54 <EvilTerran> <.<  >.>
09:35:05 <LoganCapaldo> too late
09:35:08 <tehgeekmeister> how does one transform a definition of an infinite list (fib, primes, some integer sequence, just for the sake of something concrete), and use it to find some extremely large element of the list without running out of memory because of all of the intermediate elements remaining in memory?
09:35:13 <GoodTerran> aww
09:35:15 <oerjan> ah yes, that _was_ easy in this case :D
09:35:55 <oerjan> tehgeekmeister: as a first approximation, make sure your infinite list is not globally referenced
09:36:22 <oerjan> so that while searching down it, the parts already seen can be garbage collected
09:36:46 <tehgeekmeister> oerjan: i'm very not used to languages with GC, so are there any non-obvious ways something could be globally referenced?
09:36:50 <conal> MarcWeber: how's it going?
09:37:10 <LoganCapaldo> couldn't this be an application of those stream thingies used in bytestring?
09:37:21 <EvilTerran> tehgeekmeister, is it in a where{} block, or a toplevel?
09:37:28 <EvilTerran> in the latter case, it's probably not GCd
09:37:31 <tehgeekmeister> yes, it is.
09:37:38 <MarcWeber> conal: Thanks fine
09:38:07 <tehgeekmeister> also, i really don't know how to get it out of the top level.  does being in a module count?
09:38:11 <SamB_XP> tehgeekmeister: you could do a retainer profile
09:38:24 <oerjan> however whether this works may depend on the infinite list - if calculating the next element requires looking at _much_ earlier ones, this won't work
09:38:41 <tehgeekmeister> in fact, i can't think of a time i've ever defined something anywhere but the top level.  how does that work in haskell?
09:38:59 <oerjan> tehgeekmeister: let or where
09:39:12 <SamB_XP> tehgeekmeister: ah, a complete beginner ;-)
09:39:17 <tehgeekmeister> oerjan: that's ugly, that requires duplicating code.
09:39:27 <oerjan> > let fibs = 1:1:zipWith(+)fibs(tail fibs) in fibs !! 1000 -- not top level
09:39:29 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
09:39:38 <SamB_XP> tehgeekmeister: what's in your list?
09:39:45 <tehgeekmeister> oh!
09:39:45 <EvilTerran> > millionthFib = fibs !! (10^6-1) where fibs = ... -- fibs may be GCd as you go
09:39:46 <lambdabot>  Parse error
09:40:01 <tehgeekmeister> so i can just use let, then.  okay.
09:40:02 <EvilTerran> fibs = ...; millionthFib = fibs !! (10^6-1) -- fibs probably won't be GCd as you go
09:40:03 <tehgeekmeister> *tests
09:40:20 <fax> > map fst $ iterate (\(x,y) -> (y,x+y)) (0,1)
09:40:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:40:34 <LoganCapaldo> mm
09:40:36 <SamB_XP> tehgeekmeister: so, what's your real program?
09:40:52 <dcoutts> dons, bos: people seem to be enormously confused by Data.Binary I think we need to do something about it, perhaps at the hackathon
09:40:57 <MarcWeber> conal: Doesn't seem that you've got my private messages, have you?
09:41:12 <bos> yeah
09:41:17 <tehgeekmeister> oh, i'm just trying to learn how to do it.  i don't have any (useful) program i need to know this for.
09:41:24 <SamB_XP> dcoutts: what confuses them? the worst confusion I've had was trying to import that instead of Data.Bits ;-)
09:41:26 <LoganCapaldo> fax: that's cool. and it generalizes to a function based on the last N values too, doesn't it?
09:41:58 <dcoutts> SamB_XP: the purpose, low level vs persistence etc.
09:42:02 <tehgeekmeister> just i normally use fib/prime generators as a programming exercise in a new language, and i've been impressed with haskell's power in both of these, except as far as memory consumption goes.
09:42:10 <SamB_XP> dcoutts: ah.
09:42:40 <fax> LoganCapaldo: you'd have to change fst to something else but otherwise yes
09:42:46 <dcoutts> bos: indeed, I wonder if using two different packages for the low level guaranteed format vs serialising Haskell values would be a good idea
09:42:52 <SamB_XP> you could just put an overview of each module and it's purpose in the docs for Data.Binary...
09:43:18 <LoganCapaldo> fax: I almost said "assuming you have an equivalent fst" :)
09:43:23 <dons> more docs at least, dcoutts
09:43:40 <dcoutts> dons: certainly, and proper IEEE float stuff
09:43:44 <dons> yep
09:43:45 <fax> > map (!!0) $ iterate (\[x,y] -> [y,x+y]) [0,1]
09:43:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:43:47 <oerjan> tehgeekmeister: prime sieves will probably be harder since those _do_ require looking at the first elements of the list
09:43:50 <fax> ahh ok great
09:44:18 <dcoutts> dons: and there is always this temptation to use the Binary class to try and produce a custom format
09:44:34 <dons> right. which is like using Show/Read for that.
09:44:35 <dcoutts> dons: and that bites people, especially for list etc
09:44:48 <dons> yep, newtype hackers only
09:44:50 <tehgeekmeister> oerjan: ouch.  i'd forgotten that it was accessing the beginning.  well, it wasn't working nicely for triangulars, either, so its useful there.
09:45:01 <dcoutts> dons: I've seen people very surprised that putting a list uses a length prefix
09:45:04 <bos> dcoutts: yes, +1 for better docs
09:45:41 <fax> @pointless (\n->(n*(n+1)) `div` 2)
09:45:42 <lambdabot> (`div` 2) . ap (*) (1 +)
09:45:42 <SamB_XP> dcoutts: you have to admit it is rather wierd
09:45:50 <bos> perhaps doing a put of a list could use a chunked encoding; that way, you could stream part of an infinite list without forcing it
09:45:58 <fax> > map ((`div` 2) . ap (*) (1 +)) [1..]
09:45:59 <SamB_XP> considering the structure of lists, I mean
09:45:59 <dcoutts> SamB_XP: it's not weird at all, if you think what it's for.
09:45:59 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
09:46:23 <dcoutts> SamB_XP: how can you read it back if there's no indication of length, or no terminator element
09:46:43 <dcoutts> bos: yes, I think that's a good idea
09:46:55 <SamB_XP> okay, the people who just expect it to write each element are obviously being silly
09:46:56 <dcoutts> bos: ndm and I talked about that before
09:47:17 <dcoutts> SamB_XP: right, but those are exactly the people we need to make things clearer to
09:47:25 <SamB_XP> clearly you need some indication of how long the list is
09:47:41 <bos> nah, you just need to know whether you're at the end or not
09:47:49 <pgavin> dcoutts: I had something to ask you...
09:48:01 <dcoutts> bos: nhc similar binary lib uses a single byte for length prefixing each chunk, with the last one being 0 of course
09:48:05 <SamB_XP> dcoutts: sorry, got distracted by thinking how wierd it is to have to have the whole list in the first place ;-)
09:48:24 <dcoutts> bos: though if we do that we can't do an 4/8-byte aligned format
09:48:44 <oerjan> > scanl (+) 1 [2..]
09:48:46 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
09:48:47 <SamB_XP> bos: I didn't say the indication needed to be at the beginning, did I?
09:49:18 <pgavin> dcoutts: what would be the best way to start getting my dependency code into cabal?
09:49:21 <ddarius> put fibs
09:49:25 <oerjan> tehgeekmeister: that should be good for triangulars
09:49:49 <fax> @src scanl
09:49:49 <lambdabot> scanl f q ls = q : case ls of
09:49:49 <lambdabot>     []   -> []
09:49:49 <lambdabot>     x:xs -> scanl f (f q x) xs
09:49:58 <SamB_XP> ddarius: I hope you aren't going to write that to an ordinary file!
09:50:15 <dcoutts> pgavin: get it so that it doesn't need many modifications to core code in Cabal HEAD, and if it does need any then make those separate patches so we can see and review that clearly
09:50:23 <oerjan> (of course the explicit formula is faster)
09:50:34 <EvilTerran> @docs Data.Binary
09:50:34 <lambdabot> Data.Binary not available
09:50:48 <fax> > scanl (+) 0 [1,1..]
09:50:50 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
09:50:56 <pgavin> dcoutts: well, I managed to get it all into a single module... I posted that to the cabal list, but no one seemed interested (other than you, of course) :)
09:51:10 <Japsu> @where Data.Binary
09:51:10 <lambdabot> I know nothing about data.binary.
09:51:16 <Japsu> @where Binary
09:51:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
09:51:37 <dcoutts> pgavin: I don't mind if it's better structured as multiple modules, that's up to you. The main thing is what the impact on existing code is.
09:51:55 <pgavin> dcoutts: it pretty much plugs right in :)
09:52:09 <dcoutts> pgavin: excellent
09:52:23 <dcoutts> pgavin: so you sent that patch to the list already?
09:52:42 <pgavin> yeah, I think so... I've made some changes to the algorithm since then though
09:52:59 <pgavin> and it seems to work well enough to build glib
09:53:07 <pgavin> I'm working on gtk right now
09:53:20 <dcoutts> pgavin: ok, well make sure whatever patch you want applied has been sent to the cabal-devel list
09:53:49 * SamB wonders how to make circuits involving 6502-style memory busses
09:53:53 <dcoutts> pgavin: and then tell me, as my email is in a bit of a mess at the moment since I'm offline at home and so having to use terrible webmail from work.
09:54:01 <pgavin> dcoutts: ok, I'll send an up to date patch
09:54:06 <pgavin> dcoutts: ah, ok :)
09:54:21 <dcoutts> pgavin: great. so does it need any changes to other modules?
09:54:43 <pgavin> dcoutts: well, there's some non-exported code that I've duplicated in my module
09:55:07 <pgavin> but nothing strictly requires modification
09:55:20 <dcoutts> pgavin: ok, good good
09:55:47 <dcoutts> pgavin: btw, we'll not put the code into gtk2hs yet until it's ready to switch the whole lot over to using cabal
09:55:58 <pgavin> dcoutts: right
09:56:02 <dcoutts> pgavin: so we might need a fork of the gtk2hs repo for experimenting with
09:56:36 <Haru> when we say Integer->(Integer->Integer) it means a function that takes integer for input and returns a function of type (int -> int) ?
09:56:58 <Olathe> Yes.
09:56:58 <fax> Haru: Yes, it's exactly the same as without the paranthesis
09:57:07 <pgavin> dcoutts: ok... I posted a patch for gstreamer and gnomevfs that can go in as well
09:57:34 <pgavin> dcoutts: those ones are good to go... someone was wanting to try the gstreamer code
09:58:32 <dcoutts> pgavin: oh yes, I saw that. I didn't apply it immediately since it modifies some files not under gnomevfs or gstreamer and I didn't have enough time to review it at the time.
09:58:46 <pgavin> dcoutts: ok :)
09:59:34 <dons> dcoutts: so for the upcoming ghc release, it looks like Igloo has to do a release on hackage of bytestring 0.9 (at d.h.o/packages/*) -- the package extracted from base, while we maintain a separate branch (d.h.o/bytestring) in darcs for now
09:59:41 <dons> dcoutts: which would be come 0.95 or something..
09:59:58 <dons> and presumably Igloo imports our branch into ghc's core packages now and again
10:00:11 <Igloo> dons: Those two repos are the same (a symlink)
10:00:19 <dcoutts> dons: ghc HEAD uses d.h.o/bytestring
10:00:30 <dcoutts> dons: GHC 6.8 use d.h.o/ghc-6.8/packages/bytestring
10:00:43 <dcoutts> dons: and at the moment those have more or less the same set of patches in them
10:00:43 <dons> ah ha. ok, that's sensible
10:01:02 <dons> dcoutts: but ghc 6.8 doesn't have the representation change for lazy bytestrings?
10:01:22 <dcoutts> dons: though I just noticed that we don't have an api for searching in lazy yet, and we should do so we can put in a high speed impl without breaking api later
10:01:42 <dcoutts> dons: we should do an api review asap so there's still time to merge into 6.8.1
10:01:43 <Haru> fax, also is this correct?  interleave (x:xs) : b -> a : interleave (b : xs)
10:01:47 <dons> so though, for the longer term, bytestring in darcs will be exactly the version ghc head uses?
10:01:54 <dons> meaning we can't break things, for one :)
10:01:58 <dcoutts> dons: yes, ghc-6.8 has the lazy data rep change
10:02:09 <dcoutts> dons: yes, ghc HEAD uses bytestring HEAD
10:02:13 <Igloo> Yeah, any changes should be validated
10:02:16 <fax> I think you want = instead of -> ?
10:02:20 <dcoutts> Igloo: yes of course
10:02:21 <dons> oh, ok. that snuck in , in time, dcoutts.
10:02:26 <Haru> fax: yeah
10:02:35 <Haru> but is that syntactically okay?
10:02:46 <dons> so just  the fusion stuff to get into the head branch then, I guess. and we can of course up load new releases to hackage after the fact
10:02:59 <ddarius> Haru: Without some larger context, that makes no sense.
10:03:10 <Haru> ermm ok
10:03:11 <dcoutts> dons: we should check that the 4 modules, strict, lazy, strict.char8, lazy.char8 are exporting the right apis
10:03:13 <fax> no
10:03:18 <dons> hmm yes.
10:03:28 <wli> Looks like list comprehension desugaring is a big chunk of code to rewrite.
10:03:31 <dcoutts> dons: yes, so the better fusion stuff will go in later
10:03:34 <wli> Bigger than xmonad.
10:03:39 <oerjan> Haru: yeah, where's the a from?
10:03:43 <dons> wli: that's about right
10:03:57 <ddarius> wli: ? Just desugar to monad stuff ?
10:04:02 <Haru> oerjan: its the head of the list
10:04:04 <wli> ddarius: Yeah.
10:04:11 <oerjan> Haru: also that cannot possibly be well-typed
10:04:13 <dons> Igloo: are you ok to push the amd64 patches into the 6.8 branch, btw?
10:04:33 <Igloo> dons: Yup, I'll look at the tomorrow
10:04:53 <fax> Haru: What's interleave supposed to do?
10:04:55 <dons> there  are still some issues with flags relating to -I/usr/local/include -L/usr/local/lib getting propagated everywhere they need to go, though
10:05:06 <oerjan> Haru: actually it isn't syntactic correct either - the precedence of : messes things up
10:05:30 <Haru> fax: its basically [[a]] -> [a], combines the lists in
10:05:31 <Haru> a given list of lists by cycling through the lists, picking one element at a time
10:05:51 <Haru> oerjan: i should prolly read more before trying this :)
10:05:52 <ddarius> concat . transpase
10:06:00 <ddarius> s/transpase/transpose
10:06:00 <fax> so you want from [[1,2,3],[4,5,6]] into [1,4,2,5,3,6] ?
10:06:08 <Haru> fax: yes
10:06:20 <ddarius> > concat . transpose $ [[1,2,3],[4,5,6]]
10:06:29 <lambdabot>  [1,4,2,5,3,6]
10:06:32 <Haru> that short
10:06:33 <Haru> wow
10:06:41 <omniscientIdiot> @src transpose
10:06:42 <lambdabot> transpose []             = []
10:06:42 <lambdabot> transpose ([]   : xss)   = transpose xss
10:06:42 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
10:06:48 <oerjan> @quote entire.program
10:06:48 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
10:06:49 <lambdabot> for your entire program.")
10:06:55 <omniscientIdiot> the hard work's already done :)
10:07:18 <fax> transpose is neat
10:07:34 <ddarius> omniscientIdiot: But the thing is, transpose is not written with interleaving in mind.
10:08:28 <oerjan> > concat . transpose $ [[1],[2,3,4],[5,6],[7,8,9]]
10:08:30 <lambdabot>  [1,2,5,7,3,6,8,4,9]
10:09:58 <oerjan> works well even if the lists don't line up :)
10:12:55 <wli> Now see what it does when the lists are infinite. ;)
10:12:57 <fax> Is it bad form to use type constructors as symbols?
10:13:13 <oerjan> > concat . transpose $ [[1],[2..],[5,6],[7,8,9]]
10:13:15 <lambdabot>  [1,2,5,7,3,6,8,4,9,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
10:13:37 <LoganCapaldo> that's a neat trick
10:13:43 <SamB> @lastlog conal
10:13:43 <lambdabot> Unknown command, try @list
10:13:50 <LoganCapaldo> there should be Haskell magic shows
10:13:51 <SamB> erg.
10:14:20 <LoganCapaldo> where Haskell luminaries get on stage and perform dazzling one liners for the amusement and education of the audience
10:14:32 <int-e> fax: I think it's fine for constructors of the same type, in particular for newtypes, and bad style otherwise.
10:14:54 <fax> well yes it's only possible for constructors of the same type
10:15:03 <SamB> conal: do you know of an Arrow library without that pesky pure method on the base class?
10:15:28 <oerjan> fax: data A = B B; data B = A A is perfectly possible :D
10:15:39 <int-e> fax: I mean, data Foo = Foo x | Bar y  is ok, data Foo = Xyzzy; data Bar = Foo; is bad style.
10:15:44 <shapr> SamB: I think someone at chalmers wrote such a version.
10:15:58 <LoganCapaldo> oerjan: ow
10:16:09 <SamB> shapr: I was hoping he'd know the repo/page URL ;-)
10:16:26 <ddarius> Type safe symbols all the way!
10:16:39 <oerjan> (in fact i think i've used such bad style :D)
10:17:08 <oerjan> but only where what was _inside_ the Foo data constructor was of Foo type
10:18:27 <monochrom> data Foo = Foo Foo
10:18:28 <oerjan> (and it seemed perfectly reasonable at the time)
10:18:54 <SamB> oerjan: is it bad style really?
10:19:13 <LoganCapaldo> what about module A where data Foo = Foo Something and module B where import A; data Bar = Foo Foo
10:19:14 <oerjan> SamB: someone just claimed so didn't they? ;)
10:19:20 <SamB> oerjan: yes.
10:19:43 <SamB> but I think it might only be bad style if you're going to want to do it twice ;-)
10:19:45 <omniscientIdiot> LoganCapaldo: that'd should be fine, but I think you'd have to manage name clashing
10:19:52 <tehgeekmeister> why is this definition of triangulars getting a stack overlow exception around the millionth triangular? let triangulars = 1 : zipWith (+) [2..] triangulars in triangulars !! 100000
10:20:11 <fax> tehgeekmeister: try 100000*(1+100000)/2
10:20:13 <LoganCapaldo> omniscientIdiot: I think you need to reevaluate your definition of "fine" <g>
10:20:26 <fax> 1+ or (-1).. not sure
10:20:55 <oerjan> tehgeekmeister: laziness probably, all the actual calculation is deferred until you look at the element
10:21:14 <allbery_b> that message about records sounded good until the very end
10:21:25 <SamB> I mean what if I am making a microlanguage, and I want to do something like this:
10:21:43 <monochrom> @where stackoverflow
10:21:43 <lambdabot> I know nothing about stackoverflow.
10:21:50 <SamB> data Lit = Integer Integer | Char Char | String String
10:21:51 <ddarius> @wiki Stack overflow
10:21:52 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
10:22:01 <ddarius> Though it doesn't really cover this case explicitly.
10:23:17 <ddarius> tehgeekmeister: Since you don't need any of the elements before the 100000 until you actually try to print that element, they never get evaluated and that element is a thunk of the form 1+(2+(3+(4+ ... 100000 ...)))
10:23:28 <Haru> what does [ t | (h:t) <- xss] mean ?
10:23:46 <Haru> like in transpose
10:23:53 <omniscientIdiot> all t's such that (h:t) is drawn from xss
10:23:54 <SamB> Lava goes nicely with Arrow (->), doesn't it?
10:23:56 <fax> > [t | (h:t) <- [[1,2,3],[4,5,6]]]
10:24:07 <lambdabot>  [[2,3],[5,6]]
10:24:08 <Heffalump> it's another way of writing map tail xss
10:24:08 <omniscientIdiot> map tail xss, essentially
10:24:09 <fax> Haru: It matches (h:t) on each element of xss
10:24:16 <fax> Haru: and gives you a list of all the t's
10:24:20 <Haru> ohh ok
10:24:22 <Haru> thanks
10:24:39 <ddarius> It can also be written: map tail . filter (not . null)
10:24:52 <pjd> Haru: read as "the tail of each xs in xss"
10:25:05 <fax> @pointless (\xss -> [ t | (h:t) <- xss])
10:25:05 <ddarius> "each non-empty xs"
10:25:05 <lambdabot> return . ((t | (h : t)) <-)
10:25:10 <fax> hm
10:25:20 <ddarius> It doesn't do list comprehensions.
10:25:30 <fax> are they just really hard?
10:25:42 <Heffalump> no, it just doesn't do them
10:25:45 <fax> or are they like impossible
10:25:50 <LoganCapaldo> > [ xs | xs@(_:2:_) <- [[1,2,3,4], [2,3,4], [0,2,0]] ] -- does this work?
10:25:50 <Heffalump> someone just needs to teach it the desugaring
10:25:51 <pjd> ddarius: does the comprehension automatically skip pattern match failures?
10:25:52 <lambdabot>  [[1,2,3,4],[0,2,0]]
10:25:57 <LoganCapaldo> SWEET
10:25:58 <ddarius> pjd: Yes.
10:26:11 <ddarius> pjd: Same as in do-notation.
10:26:30 <oerjan> with pattern match failures, there isn't much @pl can do
10:26:34 * EvilTerran would be amused if "return . ((t | (h : t)) <-)" worked
10:26:49 <fax> Oh it doesn't?
10:27:00 <omniscientIdiot> > do (_:2:_) <- [[1,2,3,4], [2,3,4], [0,2,0]]; return xs
10:27:01 <lambdabot>   Not in scope: `xs'
10:27:06 <fax> hm doesn't like |
10:27:17 <EvilTerran> | and <- are both reserved
10:27:20 <omniscientIdiot> > do xs@(_:2:_) <- [[1,2,3,4], [2,3,4], [0,2,0]]; return xs
10:27:21 <lambdabot>  [[1,2,3,4],[0,2,0]]
10:27:30 <LoganCapaldo> awesome
10:27:31 <pjd> ddarius: so list comprehensions sort of have an implicit fail, as []
10:27:45 <ddarius> pjd: Yes, exactly like do notation.
10:28:10 <LoganCapaldo> So when a pattern match fails in a monad it invokes fail?
10:28:16 <pjd> well, i mean have a hardcoded one, unlike do notation
10:28:18 <allbery_b> yes
10:28:24 <ddarius> LoganCapaldo: That is why fail is there.
10:28:25 <pjd> LoganCapaldo: s/monad/do notation/
10:28:31 <omniscientIdiot> LoganCapaldo: in the desugaring of do notation yes
10:28:40 <LoganCapaldo> Hmm
10:28:53 <ddarius> pjd: Even if it wasn't hard coded, you can't overload it because list comprehensions only work on one type, lists.
10:29:19 <pjd> ddarius: you could have hypothetically provided another instance of fail? :)
10:29:39 <pjd> not that it could really do anything sensible, probably
10:29:39 <LoganCapaldo> > [[1,2,3], [2]] >>= (\(xs@(_:2:_)) -> return xs) -- so this won't work?
10:29:42 <lambdabot>   Non-exhaustive patterns in lambda
10:29:47 <LoganCapaldo> boooooo
10:29:50 <LoganCapaldo> hissssss
10:29:53 <LoganCapaldo> ;)
10:30:02 <EvilTerran> @where LambdaMatch
10:30:02 <lambdabot> I know nothing about lambdamatch.
10:30:03 <omniscientIdiot> http://www.haskell.org/onlinereport/exps.html#sect3.14
10:30:04 <lambdabot> Title: The Haskell 98 Report: Expressions
10:30:16 <EvilTerran> @go lambda-match haskell-prime
10:30:18 <lambdabot> http://www.haskell.org/pipermail/haskell-prime/2006-October/001797.html
10:30:18 <lambdabot> Title: proposal: introduce lambda-match (explicit match failure and fall-through)
10:30:46 <fax> @pointless (\x y-> Left [x,y])
10:30:46 <lambdabot> (Left .) . (. return) . (:)
10:30:54 <LoganCapaldo> ahhah
10:31:05 <LoganCapaldo> @undo has been omitting a step
10:31:06 <lambdabot> (has been omitting a step)
10:31:14 <omniscientIdiot> lol
10:31:17 <allbery_b> heh
10:31:31 <omniscientIdiot> @bot
10:31:32 <lambdabot> :)
10:31:38 <omniscientIdiot> such an obedient bot
10:31:50 <oerjan> @undo do (x:y) <- t; return (x,y)
10:31:51 <lambdabot> (t >>= \ a -> case a of { (x : y) -> return (x, y); _ -> fail ""})
10:32:12 <LoganCapaldo> or it hasn't?
10:32:14 <oerjan>  @undo handles fail just fine
10:32:15 <omniscientIdiot> looks right
10:32:29 <oerjan> but it leaves them out in things that cannot fail, i guess
10:32:40 <LoganCapaldo> I jsut never bothered to try it wit an expression that could fail I guess
10:32:44 <oerjan> @undo do (x,y) <- t; return (x:y)
10:32:45 <lambdabot> (t >>= \ (x, y) -> return (x : y))
10:33:09 * EvilTerran wants lambda-match (as above), damnit
10:33:28 <LoganCapaldo> @undo do { xs@(_:2:_) <- [[1,2,3], [2]]; return xs }
10:33:28 <lambdabot> ([[1, 2, 3], [2]] >>= \ a -> case a of { xs@(_ : 2 : _) -> return xs; _ -> fail ""})
10:33:34 <dons> Igloo: i note cabal in the head configures less verbosely. that should be good for xmonad (and other apps used by non haskellers) since people won't get scared by warnings about PFE and greencard
10:33:52 <ddarius> Maybe when should allow the fat bar
10:33:52 <oerjan> > ([[1, 2, 3], [2]] >>= \ a -> case a of { xs@(_ : 2 : _) -> return xs; _ -> fail ""})
10:33:55 <lambdabot>  [[1,2,3]]
10:33:58 <ddarius> s/when/we
10:34:02 <LoganCapaldo> I'm sorry I cast aspersions upon you, @undo. Please forgive me.
10:34:46 <EvilTerran> @where+ lambdamatch http://hackage.haskell.org/trac/haskell-prime/ticket/114
10:34:46 <lambdabot> Done.
10:34:53 <EvilTerran> @where+ lambda-match http://hackage.haskell.org/trac/haskell-prime/ticket/114
10:34:53 <lambdabot> Done.
10:35:27 <dons> mm, 64 bit multi-processor openbsd on a laptop. feels like christmas
10:37:06 <ddarius> "Now that I have a version of GHC with type classes" ?  What the hell?
10:37:30 <dons> upgraded from 0.03?
10:37:34 <pgavin> lol
10:37:46 <dons> maybe he meant type families?
10:37:49 <LoganCapaldo> did ghc ever not have type classes?
10:38:02 <dons> in 1989, I suspect it lacked them
10:38:19 <olsner> has ghc been around since 1989!?
10:38:20 <dons> though hard to be sure..
10:38:25 <monochrom> See? Avoid success at all cost. Lest you have all sorts of illiterate programmers commenting on stuff.
10:38:41 <dons> ah monochrom. my bitter coffee in the morning :)
10:39:42 * EvilTerran tinkers with MonadWriter
10:42:13 <dons> hey njbartlett. how's code?
10:43:42 <dons> category theory/monads on youtube! http://golem.ph.utexas.edu/category/2007/09/the_catsters_on_youtube.html
10:43:44 <lambdabot> Title: The Catsters on YouTube | The n-Category Caf&#xE9;, http://tinyurl.com/2an7kx
10:46:49 <LoganCapaldo> AWESOME
10:46:59 <LoganCapaldo> I know what I'm watching on the train tommorow
10:47:18 <LoganCapaldo> dons++
10:47:29 <dons> alphecar found it, i just saw the link on reddit
10:47:35 <LoganCapaldo> alphecar++
10:47:52 <dons> i suspect he must have an rss feed for the keyword 'category theory'
10:49:31 <ddarius> I doubt it looks anything like the way category theory/monads are used in Haskell...
10:49:43 <LoganCapaldo> that's what I'm hoping
10:50:39 <ari> alpheccar++ (two cS)
10:51:23 <LoganCapaldo> I've been coming at this monad / category thing from a a haskell POV for so very long, it'll be nice to get a different POV in a nice easy to digest video chunk
10:51:34 <LoganCapaldo> alpheccar++
10:52:55 <omniscientIdiot> @karma alpheccar
10:52:55 <lambdabot> alpheccar has a karma of 3
10:53:00 <ddarius> LoganCapaldo: ... good luck...
10:53:55 <lament> Learn quantum mechanics and general relativity in one nice, easy to digest video chunk! Bonus video: category theory and monads.
10:54:50 <LoganCapaldo> ddarius: what's the worse that could happen? I don't learn anything? :)
10:54:52 <tehgeekmeister> ?src $!
10:54:52 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:55:08 <tehgeekmeister> ?src ($!)
10:55:09 <lambdabot> Source not found. Where did you learn to type?
10:56:24 <dons> f $! x  = x `seq` f x
10:56:28 <ddarius> LoganCapaldo: It depends on your background, but your Haskell background is not really going to help at all.
10:58:00 <LoganCapaldo> So if I do't get it, I don't get it
10:58:33 <LoganCapaldo> it still won't be a waste of time, cause otherwise I'd just be sitting on the train
10:58:58 <dcoutts> dons: it could be argued that hGetLine should be in Data.ByteString.Char8 not Data.ByteString
10:59:10 <dcoutts> dons: similarly for putStrLn etc
10:59:21 <ddarius> LoganCapaldo: I'm not saying don't do it.
10:59:32 <dcoutts> dons: and should we add hGetLine for .Lazy ?
10:59:43 <dcoutts> dons: it'd just wrap hGetLine for strict I guess
11:00:31 <ddarius> LoganCapaldo: Just don't expect too many parts where you think, "Oh, well this is just like that in Haskell."
11:00:42 <dcoutts> dons: and are we going to add a rechunk / defrag function for .Lazy ? and if so, what should it's interface be? should it take any tuning parameter or just be ByteString -> ByteString
11:00:50 <LoganCapaldo> ddarius ok
11:01:24 <ddarius> LoganCapaldo: There should be a few of those cases though.
11:02:17 <dons> hmm, the rebalancing we want to at least know how to do
11:02:43 <dons> not sure about moving things around just to break other people's code though -- though I see your point about newlines
11:06:48 <dcoutts> dons: so if we did move it, it'd affect putStrLn and getLine and the 'h' variants of both
11:07:10 <dcoutts> dons: perhaps we should ask on the libraries list for opinions
11:07:22 <dcoutts> dons: and we can perhaps add defrag later
11:07:39 <sjanssen> heh, defragmenting ByteStrings.  Reminds me of Windows '98 :)
11:08:00 <ddarius> Bloody youtube. *sigh*
11:08:02 <dons> right. i'd be inclined not to move the io functions -- since  that breaks a lot of things, and to look at refrags after the fusion patches go in
11:08:38 <tehgeekmeister> ?src foldl'
11:08:38 <lambdabot> foldl' f a []     = a
11:08:38 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:09:19 <dcoutts> dons: do you think it does break a lot? I'd have thought people using line based IO were using .Char8 anyway
11:09:44 <dcoutts> dons: or we could deprecate them in Data.ByteString and recommend getting them from .Char8
11:09:49 <dcoutts> dons: that'd be polite
11:09:51 <dons> well, that's possible. then there's also the issue that people won't find things
11:10:20 <pejo> dons/dcoutts, is there a timetable for the fusion patches?
11:10:20 <dcoutts> {-# DEPRECATED getLine "Use Data.ByteString.Char8.getLine" #-}
11:10:35 <dcoutts> pejo: a couple months I reckon
11:10:41 <dons> pejo: they just need some  testing, but really they should have gone in last year. oh well
11:11:03 <pejo> dcoutts, so 6.10 will have them, most likely?
11:11:22 <dcoutts> pejo: bytestring 1.0 will have it
11:11:34 <dcoutts> and the bytestring package can be upgraded independently of ghc
11:11:45 <dons> dcoutts: i'd be inclined to try to stabilise the api now, add fusion, and call that 1.0
11:11:55 <dcoutts> dons: me too
11:12:02 <pejo> dcoutts, ah, not talking about the stream fusion paper+code?
11:12:28 <dcoutts> pejo: yes, I'd like bytestring-1.0 to use the latest fusion code we describe in the papers
11:12:32 <tehgeekmeister> how do i avoid the stack overflow because of laziness problem in the case of infinite lists?  i've read what i can find of relevance on haskellwiki, and i don't see any obvious solutions to my problem.
11:12:34 <dons> no, that's exactly the stuff, we just need to tweak some definitions that got improved in the list fusion paper, and port them back to the bytestring repo
11:12:55 <dons> tehgeekmeister: infinite lists?
11:13:04 <dons> do you have an example loop that's causing you trouble?
11:13:12 <dcoutts> dons: yes, I was working on that, but as the 6.8 fork was approaching I moved to looking at api issues
11:13:23 <tehgeekmeister> dons: let triangulars = 1 : zipWith ((+) $!) [2..] triangulars in triangulars !! 100000000
11:13:32 <tehgeekmeister> that's the one i'm working on now.
11:13:36 <tehgeekmeister> errr
11:13:43 <tehgeekmeister> slightly wrong
11:13:45 <ddarius> tehgeekmeister: You need to use a stricter zipWith
11:13:59 <ddarius> @src zipWith
11:14:00 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:14:00 <lambdabot> zipWith _ _      _      = []
11:14:03 <dons> try compiling the code with -O2 though
11:14:13 <dons> and type [2..] as Integer (or Int), depending
11:14:14 <fax> why don't you just use n*(n+1)/2 ?
11:14:24 <dons> then hopefully the strictness analysis will spot it
11:14:37 <ddarius> zipWith' f (a:as) (b:bs) = (: zipWith f as bs) $! f a b
11:14:53 <tehgeekmeister> fax: i'm aware of that, it's a contrived exercise to improve my understanding of the language, i could just as easily use fibs.
11:15:00 <ddarius> Oops, zipWith' on the right hand side too.
11:15:39 <fax> I think you're better to try to program something real to understand a language
11:15:39 <dons> scary, i've so much ram now i'm not noticing a 700M space leak :)
11:16:05 <dons> that's a very leaky program, isn't it tehgeekmeister :)
11:16:21 <ddarius> The virtualbox thing makes me want to have >= 1GB of RAM.
11:16:48 <monochrom> I am uncomfortable with this usage of the word "leak".
11:17:19 <dcoutts> dons: ok, gotta go, so you don't think moving getLine etc is a good idea, even if we do it by leaving but deprecating getLine in Data.ByteString and recommending switching to the version from .Char8 ? in other words without breaking any existing code
11:17:45 <dons> yeah, I don't see it as critical, and it means the io stuff is spread around more
11:17:58 <oerjan> tehgeekmeister: what you could do is to leave the list as it is and access it with something that looks at each element in turn
11:18:06 <dons> but its easy to fix, tehgeekmeister
11:18:23 <dcoutts> dons: "yeah", which way? :-) yeah as in let's deprecate, or no lets not deprecate ?
11:18:24 <dons> so it'll run in constant space
11:18:39 <oerjan> foldl' (flip const) undefined . take n, say
11:18:43 <dons> 3452K 2108K onproc/1 -         0:06 27.34% a
11:18:50 <dons> 3452K 2108K onproc/1 -         0:06 27.34% a
11:18:58 <ddarius> That's another alternative (x:xs) !!! 0 = x; (x:xs) !!! n = x `seq` (xs !!! (n - 1))
11:19:01 <dons> triangulars = 1 : zipWith (+) [2..] triangulars
11:19:01 <dons>     where
11:19:01 <dons>         zipWith f (a:as) (b:bs) = z : zipWith f as bs where !z = f a b
11:19:02 <dons>         zipWith _ _      _      = []
11:19:37 * oerjan realizes he just found a reason for foldl' _not_ to be strict in the initial value
11:19:38 <dons> dcoutts: i'm not inclined to either move, nor deprecate
11:19:46 <dcoutts> dons: ok
11:20:05 <dons> that's a good case for ghc's strictness analyser
11:20:33 <dons> or at least an argument for a standard zipWith'
11:20:49 <dons> tehgeekmeister: got it working now, with strictness hints on the list results?
11:21:09 <tehgeekmeister> no, i've just rebooted, it was so leaky i had to.
11:21:14 <dcoutts> dons: the other problem we have is that the ghc testsuite uses the .Fusion module directly to test the fusion rules, however that requires the Fusion module be exposed. That's bad since we want to replace the fusion code without changing the public api.
11:21:15 <monochrom> haha
11:21:25 <dons> use
11:21:26 <dons> zipWith f (a:as) (b:bs) = z : zipWith f as bs where !z = f a b
11:21:26 <dons> zipWith _ _      _      = []
11:21:44 <dons> simple enough: just add a strictness hint on the result
11:21:54 <dons> dcoutts: right.
11:22:09 <dons> and isn't there a movement to put testsuite stuff in their own repos now?
11:22:14 <ddarius> The version dons provided uses an extension.
11:22:15 <tehgeekmeister> is that what ! is doing, then?
11:22:19 <ddarius> Unnecessarily.
11:22:28 <dons> yeah, that's -fbang-patterns, simple, easy, obvious.
11:22:31 <dcoutts> dons: not sure, ask Igloo
11:22:36 * dcoutts heads home and wishes he had net access at home.
11:22:48 <dcoutts> dons: so if you have any suggestions about that, email ma
11:22:55 <dons> ok. will do
11:23:00 <ddarius> tehgeekmeister: Did you see oerjan's response?
11:23:09 <tehgeekmeister> don't think so.
11:23:10 <Igloo> dons: The tests are moving, but they still need to be able to link against the compiled package
11:23:21 <dons> ah ok.
11:24:10 <oerjan> tehgeekmeister: ddarius's !!! is another way to do what i suggested
11:24:22 <ddarius> tehgeekmeister: There are three "general" solutions to this problem:  The solution I gave with zipWith' which is the code dons gave, oerjan's solution which is to use a version of !! that forces the elements of the list as it goes, and finally to use a head-strict list type.
11:24:28 <dons> Igloo: my amd patches just validated on linux/x86.
11:24:34 * dons runs validate for the first time. 
11:24:49 <tehgeekmeister> ddarius: what's a head strict list type?
11:25:21 <ddarius> The normal definition of lists (using different names for clarity) is data List a = Nil | Cons a (List a)
11:25:36 <fasta> runhaskell Setup.hs configure => Setup.hs: cannot satisfy dependency base-any
11:25:47 <fasta> This is with ghc-6.6.1
11:25:58 <ddarius> You could make a head-strict list type with data List a = Nil | Cons !a (List a) which would cause it's elements to be forced before they are put into the list.
11:26:00 <Igloo> dons: Cool, thanks!
11:26:38 <fasta> Igloo: Where can I get a source build for x86-64 that works?
11:27:09 <ddarius> Unfortunately, you'd have to make a head-strict lists library that essentially duplicated Data.List.
11:27:15 <oerjan> a third way would be to use something that strictifies the list but returns it
11:27:18 <oerjan> er, fourth
11:27:56 <oerjan> strictify l = foldr (\x y -> x `seq` (x:y)) [] l
11:27:58 <ddarius> oerjan: I consider that roughly equivalent to your approach.
11:28:03 <tehgeekmeister> okay, cool.  i'd imagine that using strictness can lead to some messiness, if not used carefully?
11:28:56 <sorear> strictness used thoughtlessly is the root of most Haskell evil
11:28:58 <oerjan> ddarius: the advantage is you can access the result with something other than !!
11:29:01 <ddarius> tehgeekmeister: No.  The choice of when to be strict and when not to be is something that needs to be considered.  You don't want everything to be strict and you don't want everything to be lazy.
11:29:36 <fasta> ddarius: you want everything to be lazy and the compiler should figure out where to insert strictness.
11:29:54 <fasta> ddarius: otherwise, why don't we just program in Scheme with lazy and force?
11:30:02 <tehgeekmeister> i like compilers making my life easier.
11:30:18 <fax> tehgeekmeister: You want to make life hard for yourself so the compiler can make it easy again ? :/
11:30:44 <ddarius> fasta: The compiler inherently -can't- do that and why doesn't Scheme figure out where I want laziness?
11:30:51 <monochrom> Cale has a good argument for letting laziness dominate
11:31:15 <tehgeekmeister> fax: no, my life's not hard, i don't want to make it hard, but if the compiler (or something else) can make it easier, i'm for that.
11:31:16 <fasta> ddarius: because Scheme doesn't have "laziness" in its advertisement
11:31:27 <ddarius> fasta: Haskell doesn't have "strictness" in it's.
11:31:33 <fax> tehgeekmeister: You said you are making up some contrived example, instead of using n*(n+1)/2
11:31:53 <fasta> ddarius: that's not the same
11:31:54 <ddarius> fasta: My point is which is default is just a preference.
11:31:58 <monochrom> I really hate call-by-value.
11:32:00 <ddarius> fasta:  Why not?
11:32:08 <monochrom> OK, perhaps just hate, not really hate.
11:32:19 <fasta> ddarius: because strictness in Scheme works ok, but laziness in Haskell not.
11:32:39 <fasta> (actually, I think that GHC most of the time seems to do quite nice)
11:32:50 <ddarius> fasta: Strictness in Scheme doesn't work okay not anymore often than laziness in Haskell.
11:32:51 <tehgeekmeister> fax: yep, i am.  because i'm not ready to make any of the applications i'm interested in yet, and this is a problem that'd been getting to me since i'd been studying haskell.  maybe once i actually understand io properly i'll get to non-contrived problems.
11:33:17 <fasta> But then again, I don't really know, since I don't know all the ways to do strictness analysis and what GHC currently does.
11:34:09 <fasta> ddarius: I don't see space leaks in Scheme, but this is otherwise a pointless discussion(like almost all discussions)
11:34:35 <monochrom> I like laziness to dominate. It means I don't have to use macros and (\() -> blah) all the time.
11:35:33 <ddarius> fasta: (define (append xs ys) (if (null? xs) ys (cons (car xs) (append (cdr xs) ys)))) compare to [] ++ ys = ys; (x:xs) ++ ys = x:(xs++ys)
11:35:39 <sorear> if you want sml, you know where to get it
11:37:00 <Philippa> SML doesn't really deserve the label of "the strict haskell", though. Really, only a strict-by-default haskell would
11:37:32 <EvilTerran> monochrom, i figure, if laziness wasn't default, there'd be some benefit from some uber-terse "delay this bit" syntax
11:37:55 <ddarius> EvilTerran: See Smalltalk blocks.
11:38:10 <Philippa> the verbose bit isn't so much delaying as forcing
11:38:37 <EvilTerran> (-> blah) or (\ blah), perhaps.
11:39:27 <monochrom> EvilTerran would be right IF people designed languages orthogonally and symmetrically. Unfortunately, people don't. They just don't.
11:39:27 <EvilTerran> forcing could be implicit, although i suspect that would be asking for trouble in a default-strict language
11:39:52 <fasta> ddarius: what's your point?
11:40:10 <fasta> ddarius: The Scheme solution and the Haskell solution don't do the same thing.
11:40:14 <EvilTerran> it's fairly straightforward to write a laziness system in perl, complete with implicit forcing, but it's a bit ugly to use.
11:40:29 <fasta> ddarius: In Scheme it's much easier to walk over the AST.
11:40:32 <conal> SamB: ("<SamB> conal: do you know of an Arrow library without that pesky pure method on the base class?").  no -- i don't know of one.  i just make error-ful arr/pure defs.  i'm glad there's growing awareness.
11:40:32 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:40:35 <ddarius> fasta: They're defined in exactly the same way.  The Scheme code breaks the Haskell code doesn't.
11:40:39 <EvilTerran> the delaying ends up horrifically ugly
11:41:06 <sorear> conal: uhm...
11:41:10 <sorear> conal: what's wrong with pute
11:41:19 <EvilTerran> tie my $foo, Delay::Scalar => sub { delayed expression here }
11:41:23 <ddarius> fasta: The point being that there are "space leaks" due to strictness that aren't there with laziness.  They are dual.
11:41:35 <fasta> ddarius: breaks? In what way? I assumed you didn't make a mistake.
11:41:48 <ddarius> fasta: It will stack overflow on a big enough list, the Haskell won't.
11:42:04 <EvilTerran> sorear, it might be rather difficult to define for your arrow
11:42:30 <sorear> EvilTerran: then it's not an arrow
11:42:41 <EvilTerran> although, as a last ditch, you could add an extra constructor (data FooArr a b = ... | PureFoo (a -> b), say)
11:42:47 <fasta> ddarius: that list must be the size of the complete memory in good Scheme implementations.
11:42:47 <sorear> EvilTerran: if you can't define pure, you're dealing with something rather different
11:43:11 <ddarius> fasta: So now you have a space leak where the Haskell code doesn't.
11:43:13 <fasta> ddarius: not every implementation has this "stack overflow" feature GHC has
11:43:29 <fasta> ddarius: I don't consider that a space-leak :)
11:43:48 <monochrom> This bickering is pointless.
11:43:50 <EvilTerran> i thought the point of arrows was to enable a kind of data/function duality
11:43:56 <ddarius> fasta: Then you shouldn't consider the dual case in Haskell a space leak either.
11:44:19 <conal> sorear: i think the issue is that we'd like to have a superclass of arrow w/o pure
11:44:37 <EvilTerran> in which case, if your Arrow instance is data-pretending-to-be-functions rather than vice-versa, defining pure might be awkward.
11:45:59 <pejo> Philippa, so what is required of a language to deserve the label "the strict haskell2?
11:45:59 <ddarius> What sorear said.
11:46:36 <monochrom> I find that I agree with many things sorear says.
11:46:39 <monochrom> sorear++
11:46:41 <sorear> conal: That, I'll go along with completely.  I've often wanted such a class myself...
11:46:43 <ddarius> Arrows are equivalent to Freyd categories which can readily be viewed as a kind of "adding impurity to a pure core" thing.
11:47:01 <ddarius> With 'pure' you'd have roughly something like just a category.
11:47:20 <monochrom> @quote glorified
11:47:20 <lambdabot> monochrom says: Oh I see. If you have been programming pointful all your life (basing yourself on function application), you will understand monads easier, since >>= is glorified function application.
11:47:20 <lambdabot>  If you have been programming pointfree all your life (basing yourself on function composition), you understand arrows easier, since >>> is glorified composition.
11:47:45 <monochrom> Perfect line-break :)
11:47:45 <ddarius> s/With/Without
11:48:18 <conal> sorear: one of the challenges is that arr is often used in defaults
11:54:07 <EvilTerran> is there some structure akin to the Writer monad, except consuming a stream of data rather than generating it?
11:54:25 <sorear> State :/
11:54:33 <EvilTerran> harumph.
11:54:52 <Mr_Awesome> EvilTerran: write one!
11:55:01 <ddarius> Stream comonad maybe...
11:55:01 <Heffalump> just hide the get/put operations and only offer a "get item from stream"
11:55:20 <EvilTerran> i guess it couldn't really be that akin to Writer, seeing as that uses Monoid to build the written data
12:05:48 <ddarius> The presenter of those CT/monad videos is awesome!
12:07:15 <crazy_coder> monad videos ?
12:08:11 <ddarius> http://youtube.com/watch?v=9fohXBj2UEI
12:08:15 <ddarius> Oops
12:08:20 <ddarius> Though that will work.
12:08:31 <ddarius> http://golem.ph.utexas.edu/category/2007/09/the_catsters_on_youtube.html
12:08:33 <lambdabot> Title: The Catsters on YouTube | The n-Category Caf&#xE9;, http://tinyurl.com/2an7kx
12:09:00 <crazy_coder> Downloadable videos please
12:09:09 <ddarius> crazy_coder: Don't blame me.
12:09:13 <ddarius> I'd prefer that too.
12:09:24 <fax> you can download the .flv
12:09:39 <crazy_coder> I am on Linux
12:09:46 <ddarius> I am on Linux too.
12:09:52 <fax> I mean you can download it without having flash
12:09:57 <balodja> crazy_coder: http://keepvid.com
12:09:58 <lambdabot> Title: KeepVid: Download videos from Google, Youtube, iFilm, Putfile, Metacafe, DailyMo ...
12:10:44 <balodja> and flv is playable by most players
12:10:52 <balodja> for example, mplayer and vlc
12:11:09 <benny> too bad they aren't seekable
12:11:50 <crazy_coder> Thanks
12:12:25 <balodja> vlc seeks successfully
12:14:22 <benny> balodja: I just tried... whoo, when did that happen ;-)
12:15:27 <tehgeekmeister> vlc seeks them successfully?  maybe i have an old vlc...
12:16:13 <tehgeekmeister> i do!
12:16:42 <Olathe> Bah. The audio is buzzy.
12:17:17 <sorear> I have no audio at all!
12:17:32 <dons> mine complains about no audio, too
12:17:56 <dons> maybe we can contact the catsters and get mpeg files or something
12:18:01 <Olathe> Do other YouTube videos give audio ?
12:19:32 <crazy_coder> It requires flash player to be installed for mozilla to be able to hear audio for youtube
12:19:54 <crazy_coder> I had this problem solved after I got the latest flash plugin for mozilla
12:20:33 <njbartlett> dons: Sorry, I missed your ping. How's things in Oregon?
12:20:39 <balodja> damn it
12:21:45 <sorear> I mean, I have no speakers and no sound drivers :)
12:22:19 <ddarius> sorear: Get some cardboard and some wire and a magnet will be helpful, but not critical.
12:22:48 <ddarius> The sound drivers are, of course, just a simple matter of programming.
12:22:49 <fasta> sorear: put your finger in the green hole long enough and your brains will adapt to it.
12:23:03 <sorear> ddarius: don't you also need motivation?
12:23:46 <Olathe> A functor turns a morphism in one category to a morphism in another ?
12:23:58 <ddarius> Olathe: And similarly for objects, yes.
12:24:07 <Olathe> Alright, thanks.
12:24:15 <ddarius> sorear: Building your own speakers from scratch isn't motivation enough?
12:24:43 <ddarius> Now where could I get some wire...
12:26:23 <ddarius> @seen shapr
12:26:23 <lambdabot> shapr is in #haskell-blah, ##logic, #scannedinavian and #haskell. I don't know when shapr last spoke.
12:26:32 <shapr> hiya ddarius
12:26:45 <ddarius> shapr: Hear about the CT/monad movies?
12:26:50 <shapr> nah, tell me
12:27:08 <dons> all the kids are into monads on youtube now
12:27:18 <dons> hey njbartlett. nice, really enjoying portland
12:27:28 <dons> shapr: http://golem.ph.utexas.edu/category/2007/09/the_catsters_on_youtube.html
12:27:30 <lambdabot> Title: The Catsters on YouTube | The n-Category Caf&#xE9;, http://tinyurl.com/2an7kx
12:28:55 <ddarius> http://golem.ph.utexas.edu/category/2007/09/the_catsters_on_youtube.html  CT + pleasant looking presenter + SPJ-like energy and enthusiasm = awesome!
12:28:55 <lambdabot> Title: The Catsters on YouTube | The n-Category Caf&#xE9;, http://tinyurl.com/2an7kx
12:28:55 <shapr> Sounds great!
12:28:55 <dons> http://magic.shef.ac.uk/puremaths/staff_info.php?id=35 -- behind the Catsters, and researcher on `Higher-dimensional category theory`
12:28:55 <lambdabot> Title: Staff
12:28:55 <EvilTerran> hm. module Control.Monad.Reader re-exports Control.Monad
12:28:55 <shapr> cute chick too
12:30:14 <EvilTerran> hm. Control.Monad.RWS re-exports Reader, Writer, and State
12:30:32 <dons> cute *and* writes papers on category theory!
12:30:32 <EvilTerran> but Control.Monad.RWS doesn't  re-export Control.Monad. weird.
12:30:32 <shapr> Is there a tutorial for the (-> r) monad somewhere?
12:30:32 <dons> `Higher-Dimensional Categories:
12:30:32 <dons> an illustrated guide book'
12:30:33 * EvilTerran is currently trying to grasp Reader, too
12:32:22 <sorear> @pl s a b c = a c (b c)
12:32:22 <lambdabot> s = ap
12:32:27 <sorear> @ty ap
12:32:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:33:40 <olsner> @ty (\s a b c -> a c (b c))
12:33:43 <lambdabot> forall t t1 t2 t3. t -> (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
12:34:01 <omniscientIdiot> for m = ((->) t1)
12:35:07 <olsner> yeah ;-) I'm actually starting to grok the (->) monad
12:35:52 <shapr> olsner: Quick, explain it to me!
12:36:12 <sjanssen> shapr: do you know the Reader monad?
12:36:22 <olsner> shapr: it's like a warm fuzzy thing, only it has functions
12:36:27 <shapr> sjanssen: Not sure.
12:36:33 <shapr> Sometimes I think I do.
12:36:47 <sjanssen> ((->) r) and Reader are actually the same thing
12:36:49 <sjanssen> @src Reader
12:36:49 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:37:06 <omniscientIdiot> join (f :: a -> a -> b) = \x -> f x x, fmap (f :: b -> c) (g :: (->) a b) = \x -> f (g x)
12:37:07 * LoganCapaldo wonders if saying Reader is just State without put is an oversimplification
12:37:07 <sjanssen> bah, it's something like newtype Reader r a = Reader (r -> a)
12:37:26 <ddarius> LoganCapaldo: It is.
12:37:27 <shteou> Veg-a-roma or Vegetarian Supreme pizza? :))
12:37:28 <dons> newtype Reader r a = Reader { runReader :: r -> a }
12:37:29 <omniscientIdiot> @unmtl State s a
12:37:29 <lambdabot> s -> (a, s)
12:37:33 <shteou> Someone make a decision for me plz
12:37:35 <omniscientIdiot> @unmtl Reader r a
12:37:35 <lambdabot> r -> a
12:37:40 <shteou> I'm incredibly indecisive atm
12:37:40 <shapr> shteou: I decide to not decide for you.
12:37:45 <ddarius> shteou: Supreme.
12:37:49 <omniscientIdiot> no r in the result
12:37:52 <shteou> You're decidedly dastardly, shapr!
12:37:55 <shteou> Ta ddarius
12:37:57 <sjanssen> LoganCapaldo: I think that's a pretty good definition
12:38:01 <olsner> shteou: when in doubt, choose left
12:38:03 <sjanssen> Reader also has 'local'
12:38:04 <conal> shteou: use the magic 8 ball
12:38:25 <ddarius> State r is "stricter" than Reader r.
12:38:47 * ddarius usually flips a coin.
12:40:28 <Olathe> @unpl (. map) ((.) . map)
12:40:28 <lambdabot> (\ j c d -> map (map j) (c d))
12:40:32 <Olathe> @unpl (. map) . (.) . map
12:40:32 <lambdabot> (\ g m d -> map g (map m d))
12:41:25 <olsner> @pl (\g m -> map (g.m))
12:41:25 <lambdabot> (map .) . (.)
12:41:39 <Olathe> So, . is left associative ?
12:41:58 <Heffalump> it's both ways associative
12:42:08 <Olathe> Ahh.
12:42:12 <Heffalump> left associative doesn't really mean anything
12:42:21 <Olathe> So (f) (g) isn't the same as f . g.
12:42:29 <Heffalump> you just say infixl and infixr to say "associate this to the left when you see multiple ones"
12:42:33 <Heffalump> (or the right)
12:44:29 <jatqceer> how do I get [a,d] out of [[a,b],[c,d]], or say, the diagonal elements, easily
12:45:35 <sorear> > zipWith id (iterate (.tail) head) [[1,2],[3,4]]
12:45:35 <LoganCapaldo> > zipWith (!!) [['a', 'b'],['c','d']] [0..]
12:45:43 <lambdabot> Terminated
12:45:44 <lambdabot>  "ad"
12:46:32 <Olathe> How does ((. map) . (.) . map) a b c get turned into map a (map b c) ?
12:46:41 <scandal> > let diag [a:b:[], c:d:[]] = [a,d] in diag [[1,2],[3,4]]
12:46:42 <lambdabot>  [1,4]
12:46:45 * LoganCapaldo makes no promises about the correctness of efficiency of his solution
12:46:49 <sorear> Olathe: β-reduction
12:46:53 <LoganCapaldo> s/of/or/
12:46:57 <jatqceer> thanks
12:47:15 <jatqceer> scandal: that doesn't work for arbitrary large [[]]'s
12:48:03 <sorear> ((. map) . (.) . map) a b c ==> (. map) ((.) (map a) b c)
12:48:29 <jatqceer> LoganCapaldo: i would prefer something faster...
12:48:32 <fax> > zipWith (!!) ["cat", "dog", "top"] [1..]
12:48:33 <sorear> well, something like that
12:48:33 <lambdabot>  Exception: Prelude.(!!): index too large
12:48:46 <sorear> jatqceer: it can't be done subquadratically
12:48:46 <Olathe> sorear: That's what I can't figure out.
12:48:53 <Olathe> @unpl (. map) ((.) (map a) b c)
12:48:53 <lambdabot> (\ j -> map a (b c) (map j))
12:49:00 <fax> > zipWith (!!) ["cat", "dog", "top"] [0..]
12:49:01 <lambdabot>  "cop"
12:49:03 <fax> grr
12:49:20 <Saizan> fax: ?
12:49:29 <fax> I write 1 first for some reason
12:49:54 <fax> jatqceer: that's how I'd do it anyway
12:50:50 <jatqceer> sorear: it could if I want to use array
12:50:52 <fax> ooo someone else said that :|
12:50:59 <monochrom> 1 is evil.
12:51:17 <jatqceer> fax: !! is too slow for large lists
12:51:29 <sorear> jatqceer: [] means you're using lists, not arrays
12:51:31 <fax> not really
12:51:37 <_dml> Can this be done with the regular unfoldr (or some other standard function)?
12:51:43 <monochrom> You have no better way to get the diagonal.
12:51:44 <_dml> unfoldr'      :: ([a] -> a) -> [a] -> [a]
12:51:44 <_dml> unfoldr' f xs = x' : unfoldr' f (x' : xs)
12:51:44 <_dml>     where x' = f xs
12:51:49 <Olathe> What is the first step in transforming "((. map) . (.) . map) a b c" to "map a (map b c)" ?
12:51:58 <jatqceer> sorear: right.  i'm trying to avoid array
12:52:00 <sorear> Olathe: 1. lose your sanity
12:52:03 <Olathe> Heheh
12:52:14 <sorear> jatqceer: it can't be done subquadratically with lists
12:52:21 <samreid> Olathe: (((. map) . (.) . map) a) b c
12:52:30 <Olathe> Bah.
12:52:37 <ddarius> Olathe: Apply the beta-rule in normal order.
12:52:38 <jatqceer> sorear: okay, that's fine
12:52:48 <SamB> hmm, interesting
12:53:02 <ddarius> So the first thing would be to expand the appropriate (.) into its definition.
12:53:08 <SamB> it seems that none of the functions in Lava's Patterns module have anything whatsoever to do with circuits ;-)
12:53:23 <ddarius> > let (.) = (,) in 'a' . 'b' . 'c'
12:53:25 <lambdabot>  (('a','b'),'c')
12:54:14 <fax> wow
12:54:15 <fax> let (.) = (,) in [].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[]
12:54:19 <EvilTerran> ...isn't the fixity decleration supposed to be attached to the value rather than the lexeme?
12:54:20 <fax> gives a very long error
12:54:22 <ddarius> So that would be the right one (\f g x -> f (g x)) ((. map) . (.)) map a b c, now apply the beta-rule.
12:54:53 <ddarius> ((. map) . (.)) (map a) b c
12:54:56 <sorear> EvilTerran: it does, but the default fixity is infixl 9
12:55:09 <ddarius> And repeat until you hit a weak head normal form.
12:55:13 <EvilTerran> ah yes. i was thinking it was just infix 9
12:55:19 <sorear> fax: you could probably get lonkger with something like
12:55:37 <sorear> @ty let x a=(a,a)in x.x.x.x.x.x
12:55:39 <lambdabot> forall a. -> ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a,
12:55:40 <lambdabot> a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))
12:55:43 <fax> :D
12:55:54 <omniscientIdiot> I've written an expansion in hpaste for laughs, should I submit?
12:55:57 <sorear> @ty let x a=(x a,x a)in x.x.x.x.x.x
12:55:59 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t1)
12:56:00 <lambdabot>       Expected type: t2 -> t
12:56:08 <jatqceer> _dml: so what would the f be?
12:56:23 <SamB> > let (.) = (,) in [].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[]
12:56:24 <lambdabot>          let nuu = let lfy = ... in take 2048 (show lfy) in nuu
12:56:24 <lambdabot>     In the de...
12:56:32 <fax> wtf :O
12:56:47 <SamB> indeed
12:56:58 <EvilTerran> @yhjulwwiefzojcbxybbruweejw
12:56:59 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
12:57:10 <sorear> @ty let x a=(a,a);a=a;b=x a;c=x b;d=x c;e=x d;f=x e in x f
12:57:12 <lambdabot> forall t. ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t),
12:57:12 <lambdabot> (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))
12:57:20 <hpaste>  omniscientIdiot pasted "(. map) . (.) . map" at http://hpaste.org/2768
12:57:25 <_dml> jatqceer: ([a] -> a)
12:57:37 <fax> @ty let (x) a=(a,a);a=a;b=x a;c=x b;d=x c;e=x d;f=x e in f x f x f x f x f
12:57:39 <lambdabot>     Couldn't match expected type `(t1 -> (t1, t1))
12:57:39 <lambdabot>                                   -> (((((t2, t2), (t2, t2)), ((t2, t2), (t2, t2))),
12:57:41 <dons> sorear: do you have to do that every day?
12:57:42 <_dml> some function which produced the next element in a list given a list
12:57:55 <EvilTerran> head?
12:58:04 <SamB> fax: and it's not even a legit error!
12:58:29 <fax> dons: sorry, I brought this up :/
12:58:48 <SamB> Top level:
12:58:48 <SamB>     Context reduction stack overflow; size = 20
12:58:48 <SamB>     Use -fcontext-stack=N to increase stack size to N
12:59:09 <jatqceer> _dml: so how do you get that _next_ element
12:59:15 <Olathe> sorear and omniscientIdiot: Thanks.
12:59:28 <EvilTerran> Undecidable instances strike again!
12:59:34 <omniscientIdiot> Olathe: do you understand each step?
13:00:21 <_dml> _jatqceer: the only function i've implemented looks at the head of the list past in and creates a value based on that, but I wanted unfoldr' to be more generic
13:00:37 <SamB> if you delete enough ".[]"s, it works fine
13:00:47 <_dml> passed in, not 'past', sorry
13:00:54 <fax> ooh
13:01:02 <fax> > []
13:01:04 <lambdabot>  []
13:01:10 <fax> I thought that was a type error before :S
13:01:26 <SamB> > let (.) = (,) in [].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[]
13:01:27 <lambdabot>          let bsm = let rgp = ... in take 2048 (show rgp) in bsm
13:01:27 <lambdabot>     In the de...
13:01:30 <SamB> > let (.) = (,) in [].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[]
13:01:32 <lambdabot>  ((((((((((((((((([],[]),[]),[]),[]),[]),[]),[]),[]),[]),[]),[]),[]),[]),[]),...
13:01:38 <fax> cool :D
13:01:58 <SamB> with lambdabot you need to get rid of an extra one before it works, apparantly ;-)
13:02:16 <jatqceer> so how about the reverse process, change [1,2] to [[1,0],[0,2]]
13:02:39 <SamB> anyway GHC is really being quite silly to give you an error
13:02:39 <dons> mm, so what do we need to do to get cabal builds to parallise?
13:02:43 <Olathe> omniscientIdiot: I think so.
13:02:46 <dons> dcoutts: were you thinking about that?
13:02:58 <Olathe> omniscientIdiot: flip was a bit weird at first.
13:03:43 <SamB> @quote ghc stack overflow
13:03:43 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
13:03:47 <SamB> @ghc stack overflow
13:03:47 <lambdabot> No quotes match. My pet ferret can type better than you!
13:04:00 <ddarius> @quote stack.overflow
13:04:01 <lambdabot> No quotes match. Wrong!  You cheating scum!
13:04:14 <_dml> jatqceer: not sure I follow you, sorry
13:04:39 <jatqceer> _dml: sorry, I was not asking you.
13:04:51 <SamB> fax: try "let (.) = (,) in [].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[].[]"
13:04:54 <_dml> ah, np
13:05:07 <fax> SamB: I had to delete one for it to work
13:05:24 <SamB> ah.
13:05:33 <SamB> that last one was supposed to be like that ;-)
13:06:07 * EvilTerran is thinking about scoped instances
13:06:20 <fax> > let o=repeat[];(.)=(,)in o.o.o.o.o.o
13:06:22 <lambdabot>  ((((([[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
13:07:01 <jatqceer> anyone has an idea how to change [[11,12],[21,22]] to [[11,0],[0,22]]?
13:07:14 <EvilTerran> i'm thinking of something similar to GHC's implicit parameters
13:07:41 <omniscientIdiot> jatqceer: I don't get the algorithm.  Is there another example?
13:07:56 <SamB> fax: GHC is a bit paranoid about the halting problem ;-)
13:07:56 <EvilTerran> f [[11,12],[21,22]] = [[11,0],[0,22]]
13:07:59 <Saizan> jatqceer: zerofill everything not on the diagona?
13:08:06 <fax> SamB: I don't blame it hehe
13:08:10 <jatqceer> Saizan: exactly
13:08:47 <jatqceer> EvilTerran: wonderful, mate
13:09:52 <samreid> > let f xs = zipWith (\x k -> replicate k 0 ++ x : replicate (length xs - k - 1) 0) xs [0..] in f [2,3,4]
13:09:54 <lambdabot>  [[2,0,0],[0,3,0],[0,0,4]]
13:10:04 <SamB> fax: but you'd think it ought to be able to give a discount for context reductions that actually reduce the size of the context...
13:11:40 <Saizan> > let foo _ [] = []; foo 0 (x:xs) = x : foo (-1) xs; foo n (x:xs) = 0 : foo (n-1) xs in zipWith foo [0..] $ [[11,12],[21,22]]
13:11:42 <lambdabot>  [[11,0],[0,22]]
13:12:23 <SyntaxNinja> does anyone know of a Haskell openid implementation
13:12:23 <lambdabot> SyntaxNinja: You have 1 new message. '/msg lambdabot @messages' to read it.
13:12:40 <Saizan> > let foo _ [] = []; foo 0 (x:xs) = x : map (const 0) xs; foo n (x:xs) = 0 : foo (n-1) xs in zipWith foo [0..] $ [[11,12],[21,22]]
13:12:42 <lambdabot>  [[11,0],[0,22]]
13:14:08 <jatqceer> Saizan, samreid: I'm not able to tell which one would be faster, can you give me a hint?
13:14:18 <samreid> jatqceer: Saizan's should be
13:14:31 <EvilTerran> ?type zipWith (zipWith ($)) (iterate (const 0:) (id:repeat (const 0)))
13:14:33 <lambdabot> forall a. (Num a) => [[a]] -> [[a]]
13:14:50 <EvilTerran> > zipWith (zipWith ($)) (iterate (const 0:) (id:repeat (const 0))) [[1,2],[3,4]]
13:14:50 <lambdabot> Terminated
13:14:52 <samreid> by a constant factor
13:14:52 <EvilTerran> huh.
13:14:55 <Saizan> uhm, but mine doesn't do the same thing
13:14:58 <EvilTerran> that one works on my computer.
13:15:21 <EvilTerran> lambdabot doesn't seem to like zipWith (zipWith ($))
13:15:23 <Heffalump> and on mine
13:15:29 <EvilTerran> or something
13:15:43 <Heffalump> that's really sneaky.
13:15:48 <EvilTerran> :D
13:15:59 <samreid> Saizan: sure, but mine . extracting the diagonal is slower
13:16:12 <EvilTerran> pointsfree for the win!
13:16:52 <Heffalump> EvilTerran++ # cunning zero-filling
13:17:00 <EvilTerran> hurrah!
13:17:07 <Saizan> yeah very nice, EvilTerran++
13:17:32 <jatqceer> awesome
13:18:38 * EvilTerran is really rather proud of that. i think lambdabot's jealous of my mad skills. :P
13:18:50 <EvilTerran> (or should that be "m4d 5k1lz"?)
13:18:52 <fax> I don't understand it
13:19:12 <EvilTerran> do you understand (iterate (const 0:) (id:repeat (const 0)))?
13:19:16 <fax> you make a list of functions
13:19:18 <Heffalump> you should suggest it as an exercise to Richard Bird
13:19:48 <Olathe> @src iterate
13:19:48 <lambdabot> iterate f x =  x : iterate f (f x)
13:19:50 <fax> oh
13:19:51 <omniscientIdiot> start with [id, const 0, const 0, const 0..], iterate (const 0 :) onto it's start, and zip-apply it to the list
13:19:59 <omniscientIdiot> ingenious
13:20:02 <EvilTerran> that's [id : repeat (const 0), const 0 : id : repeat (const 0), const 0 : const 0 : id : repeat (const 0), ...]
13:20:04 <fax> > (iterate (const 0:) (id:repeat (const 0))) 1 2
13:20:05 <lambdabot> Terminated
13:20:07 <Saizan> now write the other function without using length on the input list (this f [2,3,4] --> [[2,0,0],[0,3,0],[0,0,4]] )
13:21:09 <samreid> let's see if lambdabot likes this
13:21:17 <samreid> > zipWith (zipWith id) (iterate (const 0:) (id:repeat (const 0))) [[1,2],[3,4]]
13:21:18 <lambdabot> Terminated
13:21:21 <samreid> oh?  ok
13:21:26 <Olathe> Bad lambdabot !
13:21:43 <EvilTerran> \xs -> zipWith (zipWith ($)) (iterate (const 0:) (id:repeat (const 0))) . zipWith const (repeat xs) xs
13:21:55 <EvilTerran> ?pl \xs -> zipWith const (repeat xs) xs
13:21:55 <lambdabot> zipWith const =<< repeat
13:21:56 <ddarius> > zipWith
13:21:57 <lambdabot>  Add a type signature
13:22:13 <EvilTerran> ?unpl zipWith const `ap` repeat
13:22:14 <lambdabot> ((zipWith (\ a _ -> a)) >>= \ c -> repeat >>= \ b -> return (c b))
13:22:35 <EvilTerran> harumph. never mind. pointsful is easier there, methinks.
13:22:58 <EvilTerran> zipWith (zipWith ($)) (iterate (const 0:) (id:repeat (const 0))) . (\xs -> zipWith const (repeat xs) xs) -- better, seeing as xs isn't relevant 'til the second part
13:23:20 <EvilTerran> > (\xs -> zipWith const (repeat xs) xs) "abc"
13:23:25 <lambdabot>  ["abc","abc","abc"]
13:23:28 <EvilTerran> > (\xs -> zipWith const (repeat xs) xs) "abcd"
13:23:29 <lambdabot>  ["abcd","abcd","abcd","abcd"]
13:23:49 <omniscientIdiot> so it "squares" a list?
13:23:50 <EvilTerran> anyway. that good enough for you, Saizan?
13:24:14 <Saizan> > zipWith (zipWith ($)) (iterate (const 0:) (id:repeat (const 0))) . (\xs -> zipWith const (repeat xs) xs) $ [[1,2],[3,4]]
13:24:15 <lambdabot> Terminated
13:24:36 <EvilTerran> map (const xs) xs would work, too
13:24:58 <EvilTerran> that's probably clearer, actually. let's have that.
13:25:26 <EvilTerran> > id:repeat (const 0)
13:25:26 <lambdabot> Terminated
13:25:30 <EvilTerran> > repeat (const 0)
13:25:31 <lambdabot>  Add a type signature
13:25:34 <jatqceer> I can't follow you...
13:25:38 <EvilTerran> ^^ very peculiar
13:26:01 <EvilTerran> > (id::Num a => a -> a):repeat (const 0)
13:26:02 <lambdabot> Terminated
13:26:07 <jatqceer> what is probably clearer?
13:26:08 <EvilTerran> > (id::Int -> Int):repeat (const 0)
13:26:09 <lambdabot> Terminated
13:26:13 <twanvl> > snd . mapAccumR (\h x -> (0:h, x++h)) [] . snd . mapAccumL (\ h x -> (0:h, h++[x])) []   $   [2,3,4]
13:26:15 <lambdabot>  [[2,0,0],[0,3,0],[0,0,4]]
13:26:22 <omniscientIdiot> map (const xs) xs, replaces every element in xs, with xs itself.
13:26:26 <EvilTerran> jatqceer, "map (const xs) xs" over "zipWith const (repeat xs) xs"
13:26:58 <EvilTerran> they're exactly equivalent, AFAICT, although i leave the formal proof as an exercise to the reader
13:27:02 <EvilTerran> ;]
13:27:14 <twanvl> > (const >>= map) [1,2,3]
13:27:16 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
13:27:41 <Saizan> > (ap map const) [1..3]
13:27:42 <lambdabot>  Couldn't match expected type `[a]'
13:27:52 * EvilTerran wibbles
13:28:12 <EvilTerran> . o O ( it's *not* the list monad. it may involve lists, but it's *not*! )
13:28:43 <omniscientIdiot> oh, silly me!  const is a ((->) r) action.
13:29:05 <EvilTerran> > (return >>= fmap) [1,2,3] -- i'm feeling obscure!
13:29:06 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
13:29:21 <omniscientIdiot> lol
13:33:07 <EvilTerran> doesn't (return >>=) fit some kind of identity
13:33:07 <EvilTerran> ?
13:33:07 <Saizan> eheheh, const wasn't even used as the return of the r -> monad there
13:33:07 <ndm> return x >>= id == x
13:33:07 <Saizan> ?type (return >>=)
13:33:07 <ndm> return x >>= id == return x
13:33:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (m a -> a -> b) -> a -> b
13:33:07 <hpaste>  LoganCapaldo pasted "Now I think I see what ddarius meant by reader being 'stricter". Hooray for trying to reverse engine" at http://hpaste.org/2769
13:33:07 <LoganCapaldo> woah
13:33:07 <LoganCapaldo> that title is all wrong
13:33:07 <LoganCapaldo> s/Reader/State/
13:33:07 <LoganCapaldo> also hpaste has some kind of title length limit apparently
13:33:07 <olsner> ooh, "Featuring: Gratuitous alien nudity"
13:33:07 <dons> SyntaxNinja: yo, re. openid, if there isn't a binding, we should write one. it has been discussed here before -- i'll check the logs
13:33:17 <dolio> > (a <- (1+) ; b <- undefined ; return a) 2
13:33:17 <lambdabot>  Parse error
13:33:23 <dolio> > (do a <- (1+) ; b <- undefined ; return a) 2
13:33:25 <lambdabot>  3
13:33:50 <dons> SyntaxNinja: looks like we don't have a lib, the logs just point to people asking for one
13:33:52 <twanvl> > ((=<<)(<$>)return) [1..3]
13:33:53 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
13:33:54 <dolio> > runState (do a <- get ; b <- undefined ; return a) 2
13:33:56 <lambdabot>  Undefined
13:34:07 <fax> :o
13:34:09 <SyntaxNinja> dons: I"m thinking of an implementation rather than a binding, but could go etiehr way.
13:34:13 <SyntaxNinja> I guess a binding would be a good start.
13:34:13 <fax> ?unpl ((=<<)(<$>)return) [1..3]
13:34:14 <lambdabot> (return >>= (<$>)) [1 .. 3]
13:34:25 <fax> :t (<$>)
13:34:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:34:28 <twanvl> (<$>) == fmap
13:34:37 <omniscientIdiot> == liftM
13:34:38 <dons> SyntaxNinja: seems easy enough we could do it ourselves, doesn't it?
13:34:42 <dons> and do it well, even.
13:34:45 <SyntaxNinja> should be.
13:34:49 <omniscientIdiot> == (.) == map   :/
13:35:00 <SyntaxNinja> and since there's a 2.0 draft out, we could be one of the early implementations of that (maybe)
13:35:22 <dons> good idea
13:35:36 <dons> ah yes `OpenID Authentication 2.0 - Implementor's Draft 12 (txt)'
13:35:44 <SyntaxNinja> I thought starting with the client-side wouldn't be too bad.
13:36:02 <dons> i can see quite a few  uses for this
13:36:28 <twanvl> (.) /= map
13:37:06 <EvilTerran> twanvl, in a purist's haskell, fmap would be called (.)
13:37:07 <ddarius> (.) == fmap
13:37:22 <twanvl> There are two ways to generalize (.), to fmap or to (<<<)
13:37:24 <omniscientIdiot> true, I overextended the point
13:37:37 <ndm> dons: i read a bit of it, its only useful if it takes off
13:37:53 <oerjan> er, no common generalization of those two then?
13:38:00 <dons> hmm, trac uses a subversion backend?
13:38:11 <SyntaxNinja> hm.  I wonder if we have an implementation of  Diffie-Hellman Key Exchange (Rescorla, E., “Diffie-Hellman Key Agreement Method,” .) [RFC2631].
13:38:30 <SyntaxNinja> trac connects to subversion for browsing a code repository
13:38:36 <dons> ah
13:38:39 <SyntaxNinja> trac doesn't save wiki pages to subversion or anything. it uses sqlite
13:38:49 <dons> yeah
13:38:51 <SyntaxNinja> which is a pretty cool library, and some of the best-commented C code I've ever seen.
13:39:02 <SyntaxNinja> trac can also use darcs.
13:39:23 <dons> is trac mostly python?
13:39:45 <Nafai> dons: I think so
13:39:54 <SamB> dons: you mean it isn't all python?
13:40:03 * SamB hasn't looked at trac
13:40:15 <twanvl> oerjan: Let's see, (a c d -> a b c -> a b d)  `unify`  ((x -> y) -> f x -> f y)
13:40:18 <balodja> just a test: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
13:40:44 <balodja> hm, lambdabot doesn't recognize title of this page
13:40:53 * dons tries $ trac-admin /home/dons/life initenv
13:40:54 <dons> :)
13:40:59 <Saizan> ?bot
13:40:59 <lambdabot> :)
13:41:14 <balodja> oh, problem is in <title>
13:41:50 <SyntaxNinja> dons: good luck!
13:42:07 <dons> :D
13:42:29 <dons> Project environment for 'life' created.
13:42:36 <dons> shapr: you'd like this idea, i think.
13:42:51 <shapr> ?
13:42:59 <twanvl> The generalization of (<<<) and fmap would have a type:  a c d -> f c -> f d
13:43:00 <shapr> Which iead?
13:43:03 <shapr> idea*
13:43:07 <dons> put your life in trac.
13:43:28 <shapr> Really works?
13:43:43 <dons> don't know yet...
13:43:44 <SyntaxNinja> haha google "Getting things done with trac" and I'm the 4th hit.
13:43:48 <dons> hah
13:43:54 <SyntaxNinja> or maybe google is just sucking up to me.
13:44:02 <dons> we should start #haskell-productivity
13:44:04 <dons> :)
13:44:05 <SyntaxNinja> I keep meaning to write an actual blog entry about how to do it.
13:44:06 <shapr> yes!
13:44:13 <shapr> SyntaxNinja: Put it on your trac ;-)
13:44:35 <dons> 3rd hit on my google, SyntaxNinja, is you
13:44:52 <ddarius> dons: Didn't we already have a similar conversation: /topic #haskell-producivity -> "Step 1: Get off IRC"
13:44:58 <dons> hah
13:45:23 <balodja> It's too hard to write anything in haskell without on-line help :(
13:45:39 <dons> balodja: oh? access to library docs, you mean?
13:45:43 <dons> or some other kind of help?
13:46:07 <shapr> It's hard to write code without lambdabot.
13:46:18 <fax> I just discovered @hoogle is online :D
13:46:29 <SyntaxNinja> dons: oh, I was counting the sponsored link
13:46:32 <fax> outside of lambdabot that is
13:46:45 <SyntaxNinja> shapr: I have!
13:46:52 <shapr> SyntaxNinja: And you SURVIVED?
13:46:57 <balodja> I mean questions and answers :) and of course lambdabot, and lots of links to papers and presentations here
13:47:38 <yaxu> what's an easy way of having a local hoogle, that doesn't require being online?
13:47:50 <dons> install hoogle
13:47:54 <dons> it's just a command line app
13:48:03 <dons> lambdabot could be installed locally too, which provides a local hoogle
13:48:06 <yaxu> ah ok :)
13:49:23 <oerjan> twanvl: MPTC over a and f then
13:49:29 <ndm> i don't think the darcs hoogle command line client compiles at the moment...
13:49:44 <twanvl> That would likely ruin type inference
13:50:19 <twanvl> To me (.) means composition, map has nothing to do with comosing, so using (.) for that feels like a hack
13:50:32 <oerjan> possibly | f -> a  ?
13:50:47 <twanvl> Maybe
13:50:58 <twanvl> We already have enough names for map
13:51:21 <chessguy> twanvl, not as many as fmap :)
13:51:47 <Saizan> a c d -> a (f c) (f d)!
13:51:49 <oerjan> i suppose it depends on whether there is some interesting structure that uses such a generalization
13:51:50 <twanvl> Yes, I meant fmap
13:52:09 <conal> sometime fmap *is* composition, e.g., on lists.  if you think of a list as a function from naturals
13:52:23 <oerjan> Saizan: that does not include <<<
13:52:25 <yaxu> gah, i'm going to miss the london hug *again*
13:52:34 <Saizan> ?type <<<
13:52:37 <lambdabot> parse error on input `<<<'
13:52:41 <Saizan> ?type (<<<)
13:52:43 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
13:53:08 <Saizan> oerjan: right
13:53:15 <chessguy> @instances-importing Arrow
13:53:16 <lambdabot> (->), Kleisli m
13:53:39 <chessguy> there are only 2 instances of Arrow?
13:53:45 <oerjan> chessguy: instances-importing takes a list of modules to import
13:54:01 <oerjan> no way of getting absolutely everything if you don't know where it is
13:54:16 <chessguy> @help instances-importing
13:54:16 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
13:54:40 <twanvl> There are only two instances in base
13:54:52 <chessguy> well isn't (a, b) an Arrow?
13:55:04 <twanvl> No
13:55:15 <chessguy> ermm
13:55:21 <chessguy> @type first
13:55:27 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:55:28 <oerjan> chessguy: how would you define pure for that?
13:55:39 <oerjan> :t pure
13:55:40 <twanvl> pure should be removed from Arrow
13:55:42 <lambdabot>     Ambiguous occurrence `pure'
13:55:42 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
13:55:45 <twanvl> ?type arr
13:55:47 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
13:56:10 <twanvl> Then you could make functional references an instance of Arrow
13:56:11 <chessguy> > first (2, 'a')
13:56:11 <lambdabot>   add an instance declaration for (Arrow (,))
13:56:12 <lambdabot>     In the expression: first (2...
13:56:41 <oerjan> @djinn (b -> c) -> (b,c)
13:56:42 <lambdabot> -- f cannot be realized.
13:56:53 <oerjan> djinn thinks it is impossible
13:57:21 <Heffalump> that's because it is..
13:57:46 <omniscientIdiot> first would be (b,c) -> ((b,d), (c,d)).  I wouldn't know how that'd look.
13:58:53 <LoganCapaldo> @ty \f b -> (b, f b)
13:58:56 <lambdabot> forall t t1. (t -> t1) -> t -> (t, t1)
13:59:00 <chessguy> there was something that i did yesterday that i assumed worked because (,) was an Arrow, but now i can't remember what it was
13:59:13 <oerjan> twanvl: note that arr is used in the default declarations for second and &&&
13:59:31 <LoganCapaldo> mm'
14:00:01 <LoganCapaldo> yeah that does look pretty impastable
14:00:12 <chessguy> aha
14:00:16 <chessguy> @type second negate
14:00:18 <lambdabot> forall a d. (Num a) => (d, a) -> (d, a)
14:00:29 <twanvl> We could do with: ref :: Arrow a => (x -> y) -> (y -> x -> x) -> a x y
14:00:40 <chessguy> @type second
14:00:42 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
14:01:04 <omniscientIdiot> chessguy: first and second use pairs in the Arrow parameters, not the Arrow itself.
14:01:11 <twanvl> Or maybe: invertibleArr :: Arrow a => (x -> y) -> (y -> x) -> a x y
14:01:35 <chessguy> omniscientIdiot, huh?
14:01:40 <chessguy> @src Arrow
14:01:40 <lambdabot> class Arrow a where
14:01:40 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:01:40 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:01:40 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:01:40 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:01:42 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:01:44 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:01:58 <omniscientIdiot> a is what would have to be (,) for it to be an Arrow
14:02:37 <omniscientIdiot> second negate uses the (->) Arrow
14:02:46 <chessguy> so what is getting bound to a, b, and c in the case of second negate?
14:02:53 <chessguy> ohhh
14:02:56 <omniscientIdiot> a = (->)
14:03:01 <oerjan> twanvl: if you removed arr/pure you would have to define several more of the methods by hand
14:03:19 <conal> arrow-related types are more readable with infix
14:03:29 <chessguy> ugh, i never get it when (->) is introduced
14:03:30 <LoganCapaldo> [(a,b)] could be an arrow...couldn't it?
14:03:40 <twanvl> oerjan: I suggest replacing arr with arrInv
14:03:51 <omniscientIdiot> LoganCapaldo: Compose [] (,)?
14:04:02 <omniscientIdiot> Arrows have kind * -> * -> *
14:04:05 <ddarius> This is late, but streams are N -> a, lists aren't.
14:04:07 <twanvl> Then classes that support arr can be subclasses of Arrow (or whatever you want to call the super class)
14:04:07 <oerjan> LoganCapaldo: doubtful.  i take it as a given that x >>> arr id = x, or something
14:04:26 <oerjan> and you couldn't define arr to satisfy that.
14:04:48 <LoganCapaldo> mmm'
14:04:51 <LoganCapaldo> right
14:05:00 <conal> ddarius: partial N -> a
14:05:15 <conal> ?type elem
14:05:17 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:05:24 <dons> does anyone know of any statistics libraries for haskell?
14:05:24 <conal> ?type nth
14:05:26 <lambdabot> Not in scope: `nth'
14:05:30 <ddarius> :t (!!)
14:05:33 <lambdabot> forall a. [a] -> Int -> a
14:05:40 <LoganCapaldo> @type arr
14:05:41 <conal> thanks!  that's it.
14:05:43 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
14:05:55 <conal> i guess i never use (!!)
14:05:56 <LoganCapaldo> oh yeah
14:06:01 <ddarius> I never use (!!)
14:06:05 <LoganCapaldo> definitely could do that
14:06:09 <LoganCapaldo> *couldn't
14:06:16 <chessguy> dons, what about the one that ekidd and sigfpe blogged about a few months ago
14:06:38 <conal> i wonder what functors are *not* functions
14:06:47 <dons> yeah, that's one, chessguy.
14:07:11 <twanvl> conal: (,) a?
14:07:32 <oerjan> :t arrInv
14:07:32 <chessguy> dons, http://web.engr.oregonstate.edu/~erwig/pfp/
14:07:33 <lambdabot> Title: PFP - Probabilistic Functional Programming in Haskell
14:07:34 <lambdabot> Not in scope: `arrInv'
14:07:43 <conal> twanvl: yep.  i dont' know how to think of (,) a as a functoin.
14:07:48 <twanvl> arrInv :: (b -> c) -> (c -> b) -> a b c
14:07:56 <chessguy> dons, and ekidd's blog series about them starts at http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
14:07:57 <conal> or a function either
14:07:58 <lambdabot> Title: Refactoring probability distributions, part 1: PerhapsT, http://tinyurl.com/ythywo
14:08:01 <dons> cheers, chessguy
14:10:11 <oerjan> twanvl: that could work for arr swap swap but it looks strained for the &&& definition?
14:10:43 <oerjan> how would that work for a ref?
14:10:58 <oerjan> *arrInv swap swap
14:13:24 <oerjan> i suppose you would have to decide arbitrarily between fst or snd as what puts the value back
14:13:29 <user317> @src filter
14:13:29 <lambdabot> filter _ []     = []
14:13:30 <lambdabot> filter p (x:xs)
14:13:30 <lambdabot>     | p x       = x : filter p xs
14:13:30 <lambdabot>     | otherwise = filter p xs
14:14:07 <oerjan> which, when i think about it, seems like something you would have to do for ref (&&&) anyhow
14:14:28 <oerjan> *Ref (&&&)
14:14:29 <twanvl> Maybe there is a better way for references
14:15:36 <twanvl> p &&& q = Ref { get = \b        -> (get p b, get q b)
14:15:36 <twanvl>               , set = \(c,c') b -> set p c (set q c' b) }
14:16:46 <twanvl> But I don't know how that fits in the Arrow framework
14:16:53 <oerjan> explicit sequencing?
14:18:09 <oerjan> anyway anything like this would probably benefit from class aliases again
14:18:25 <oerjan> then you could just make a superclass of the current Arrow
14:19:03 <matthew-_> KatieHuber: so I switched to using index buffers which has reduced the data from 900MB to 250 with no more 70MB being loaded at any one time. Performance does seem to have been affected, but not by much. I guess prefecting and filling arrays is a lot easier for drawArrays than drawIndexArrays.
14:19:17 <twanvl> Maybe instead of / in addition to first you could have:  also :: a b c -> a b (b,c)
14:19:46 <KatieHuber> you may still be able to reorganize your triangles into better spatial locality to get some of the performance bak
14:19:52 <KatieHuber> (matthew-_ )
14:20:44 <matthew-_> KatieHuber: yeah, so the triangles are pretty much in row-major order.
14:24:04 <oerjan> twanvl: perhaps there should be a Morphism class above Arrow, which had >>> and id as methods
14:24:23 <oerjan> in fact it could overload the original id :)
14:24:34 <twanvl> And use (.) instead of >>>
14:24:37 <twanvl> (actually <<<)
14:26:38 <oerjan> although is Morphism really what it is? it still doesn't support arbitrary categories, since it must be defined for any pair of types
14:26:44 <monochrom> First they overloaded (.), and I didn't speak up because I wasn't Jewish. Then they overloaded (:), and I didn't speak up because I wasn't Catholic. Now they overload id, and I can't speak up because there is no one else left. :)
14:27:44 <oerjan> @remember monochrom First they overloaded (.), and I didn't speak up because I wasn't Jewish. Then they overloaded (:), and I didn't speak up because I wasn't Catholic. Now they overload id, and I can't speak up because there is no one else left. :)
14:27:44 <lambdabot> Done.
14:28:09 <monochrom> hehe
14:28:43 <EvilTerran> perhaps "and I can't speak up because I can't work out how to make the necessary haskell typecheck any more"?
14:28:50 <monochrom> hehe
14:29:15 * ddarius proposes overloading ::
14:29:45 <ddarius> Actually, it's already overloaded.
14:29:45 <oerjan> ddarius: let's start with making it a legal section, ok?
14:29:49 <EvilTerran> I prefer overloading ;
14:29:57 <oerjan> ,
14:30:01 <EvilTerran> (
14:30:03 <ddarius> What we really need is to overload whitespace.
14:30:06 <EvilTerran> and ), seperately
14:30:09 <nbb> =
14:30:16 <EvilTerran> e
14:30:22 <twanvl> Shouldn't that be (✡) and (†)?
14:30:25 <EvilTerran> none of the other letters, just e.
14:30:29 <oerjan> @go overload whitespace
14:30:32 <lambdabot> http://www.research.att.com/~bs/whitespace98.pdf
14:30:42 <pgavin> lol
14:30:43 * EvilTerran wonders how one would write a section of (
14:31:25 <ddarius> Prelude.(3(Prelude.)
14:31:50 * omniscientIdiot squints
14:32:22 <oerjan> O_O
14:34:37 <ddarius> @let e :: RealFrac a => a; e = exp 1
14:34:38 <lambdabot> <local>:6:26:     Could not deduce (Floating a) from the context (RealFrac a)...
14:34:43 <ddarius> > id
14:34:44 <lambdabot> Terminated
14:34:49 <ddarius> @undefined
14:34:50 <ddarius> > id
14:34:54 <lambdabot> Terminated
14:34:56 <lambdabot> Undefined.
14:34:59 <ddarius> > id
14:35:01 <lambdabot>  Add a type signature
14:35:19 <ddarius> @let e :: Floating a => a; e = exp 1
14:35:20 <lambdabot> Defined.
14:35:28 <EvilTerran> actually, i guess ( and ) are already overloaded
14:35:29 <twanvl> > concatMap ("Prelude."++) "(3)"
14:35:29 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
14:35:31 <monochrom> That's very freaky if you get id to loop. :)
14:35:37 <EvilTerran> for tuples and () and whatnot
14:35:39 <omniscientIdiot> > e :: Double
14:35:41 <lambdabot>  2.718281828459045
14:35:45 <twanvl> > concatMap (\x->"Prelude."++[x]) "(3)"
14:35:46 <lambdabot>  "Prelude.(Prelude.3Prelude.)"
14:36:32 <fax> > e :: Rational
14:36:33 <lambdabot>   add an instance declaration for (Floating Rational)
14:36:33 <lambdabot>     In the expression: ...
14:36:41 <oerjan> EvilTerran: ah, but to which typeclass do you add new instances?
14:36:43 <omniscientIdiot> @instances Floating
14:36:44 <lambdabot> Double, Float
14:37:07 <oerjan> > toRational e
14:37:09 <lambdabot>  6121026514868073%2251799813685248
14:37:15 <twanvl> ?let i = 0 :+ 1
14:37:18 <lambdabot> Defined.
14:37:39 <omniscientIdiot> > i * i
14:37:40 <lambdabot>  (-1.0) :+ 0.0
14:37:48 <twanvl> > e ** (pi * i)
14:37:49 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
14:38:32 <omniscientIdiot> IEEE--
14:38:51 <wli> > exp (negate pi / 2)
14:38:52 <lambdabot>  0.20787957635076193
14:38:55 <oerjan> omniscientIdiot: huh?
14:39:04 <monochrom> IEEE++
14:39:11 <monochrom> I think IEEE makes sense.
14:39:16 <wli> > i ** i
14:39:18 <lambdabot>  0.20787957635076193 :+ 0.0
14:39:20 <omniscientIdiot> just joking
14:39:23 <ddarius> reality--
14:39:31 <omniscientIdiot> @karma reality
14:39:31 <lambdabot> reality has a karma of -1
14:39:34 <monochrom> that one I agree
14:39:46 <goalieca> hehehe
14:39:56 <fax> > i
14:39:57 <lambdabot>  0.0 :+ 1.0
14:40:03 <fax> ah
14:40:09 <wli> For examples of why IEEE754 is needed look for JAVAhurt.pdf
14:41:05 <b_jonas> this braceless layout can be confusing :(
14:41:17 <dons> you can introduce braces if you like
14:41:20 <dons> have you seen that?
14:41:27 <dons> > let { x = 1; y = 2 } in x + y
14:41:28 <b_jonas> yes, I have
14:41:28 <lambdabot>  3
14:41:43 <b_jonas> but I still have to read braceless code
14:41:49 <b_jonas> why can you write this for example:
14:41:54 <b_jonas> let x = 1
14:41:58 <b_jonas>     y = 2 in
14:42:02 <b_jonas>  x + y
14:42:11 <b_jonas> I mean, how can you put the in there
14:42:25 <EvilTerran> for the same reason
14:42:28 <EvilTerran> class Foo a where
14:42:30 <EvilTerran>  blabla
14:42:30 <b_jonas> how does the compiler know that he has to introduce the closing brace between the in
14:42:31 <EvilTerran> works
14:42:31 <oerjan> b_jonas: that's the parse error rule
14:42:35 <dons> if you're not using `;' to terminate statements. then instead the indentation level of the first 'x' and 'y' are used
14:42:40 <wli> Try adaptive Gauss-Kronrod-Patterson quadrature or something. This stuff is so dull.
14:42:59 <oerjan> whenever the compiler hits an illegal token, it may try adding a }
14:43:18 <monochrom> The complete rules are complicated. Try not to ask "why", because an accurate answer is unreadable.
14:43:18 <b_jonas> oerjan: "may"?
14:43:24 <EvilTerran> as long as there's a corresponding {, anyway
14:43:30 <oerjan> ok, must
14:43:34 <b_jonas> ok, I see
14:43:35 <EvilTerran> must try to
14:43:37 <b_jonas> but that's just ugly
14:43:53 <oerjan> but very convenient
14:44:09 <monochrom> All ugly things start out as small conveniences.
14:44:11 <b_jonas> it seems to me that it defeats the purpose of layout
14:44:26 <EvilTerran> it's a big part of what makes layout work
14:44:27 <b_jonas> because you can't find the invisible end brace by finding the unindent anymore
14:44:32 <monochrom> In fact all complications start out as small conveniences too.
14:44:58 <EvilTerran> don't look for the unindent, look for where it moves to the left of the start of the block
14:45:13 <b_jonas> yeah, the unindent matching the indent
14:45:16 <EvilTerran> in the example you gave, look for the "let", not the "in", for instance
14:45:24 <b_jonas> what?
14:45:28 <EvilTerran> look for "if", not "then" or "else"
14:45:34 <b_jonas> sure
14:45:36 <sorear> runST (do foo
14:45:42 <sorear>           bar)
14:45:44 <EvilTerran> "in" doesn't introduce a block, iirc.
14:45:48 <sorear> that's why we have the rule
14:45:49 <EvilTerran> > let x = 1 in { x }
14:45:49 <lambdabot>  Parse error
14:45:55 <EvilTerran> voila
14:46:01 <b_jonas> but the block ends before the unindent
14:46:05 <wli> Why is layout complicated?
14:46:08 <b_jonas> that's my problem
14:46:17 <EvilTerran> b_jonas, in that case, it's terminated by an identifier - "in"
14:46:20 <b_jonas> wli: well, I just don't like layout in general
14:46:23 <monochrom> because it started out as convenience
14:46:24 <EvilTerran> *keyword
14:46:30 <b_jonas> but this seems more
14:46:42 <oerjan> b_jonas: haskell parsing _is_ ugly.  there are dark corners even ignoring layout.
14:46:49 <fasta> b_jonas: You can use {} and ;
14:46:55 <b_jonas> fasta: and I will
14:46:59 <oerjan> strangely, this nevertheless results in a beautiful language.
14:47:02 <b_jonas> but I still have to read code to learn haskell
14:47:14 <b_jonas> I mean, the "in" could be ending some inner block
14:47:28 <b_jonas> or just be there for some other reason
14:47:28 <wli> One could always throw natural language parsing algorithms at the task.
14:47:32 <ddarius> monochrom: So you are adding that all things that start out as conveniences become complicated?
14:47:42 <monochrom> Yes. Seriously.
14:47:55 <b_jonas> ok, nevee mind, I was just surprised on that code
14:48:03 <ddarius> oerjan: People tend to stay away from the dark corners.
14:48:05 <jcreigh> Stuff that people actually use is full of nasty corner cases. Pure, clean design rarely lasts long in the real world.
14:48:07 <monochrom> Look at some dark corners of C. Look at Perl. Look at the industry...
14:48:15 <fasta> Oh, another thing I agree on with monochrom
14:48:19 <b_jonas> monochrom: yeah, I know
14:48:30 <b_jonas> I've seen how ugly perl parsing is
14:48:34 <b_jonas> that's worse than everything
14:48:49 <b_jonas> I've never seen any other language that's so difficult to parse as perl (except perl6)
14:48:53 <wli> Well, the industry will go down in flames along with the rest of everything.
14:48:59 <b_jonas> even ruby is joy after it
14:49:14 <oerjan> joy is probably simple enough though :)
14:49:16 <Haru> how do i add 2 lists to make a bigger list?
14:49:20 <monochrom> In C, "i++" is there for convenience (plus a couple low-level reasons). It also leads to much complication in the big picture.
14:49:22 <b_jonas> lol
14:49:24 <sorear> isn't parsing Haskell harder?
14:49:29 <oerjan> Haru: ++
14:49:31 <jcreigh> > [1,2,3] ++ [4,5,6]
14:49:32 <Haru> [h:hs]:[h:hs] doesnt seem to work
14:49:36 <Haru> oerjan: ah ok
14:49:39 <Olathe> Bad lambdabot !
14:49:42 <lambdabot>  [1,2,3,4,5,6]
14:49:44 <Zao> ++ in C++ is there to let you overload more operators :)
14:49:55 <wli> GLR is a truly revolutionary thing on the parsing front; there the nondeterminisms etc. result in work proportional to the nondeterminism in the grammar and string to be parsed.
14:49:55 <twanvl> Parsing C++ is harder, but not because of the ++
14:49:57 <EvilTerran> BEGIN { *foo = rand < 0.5 ? sub () { "oh" } : sub { "dear" } }
14:50:14 <ddarius> :t (:)
14:50:16 <lambdabot> forall a. a -> [a] -> [a]
14:50:25 <sorear> EvilTerran: that doesn't look too hard
14:50:30 <b_jonas> ruby tries to use the same methods to make parsing difficult as perl (except for mixing compile time and runtime, but perl is bad even without that) but it's easier because there are fewer rules
14:50:40 <Olathe> Haru: That's because you're making [[a], a, a, ...]
14:50:42 <EvilTerran> foo / this; # /; # is not good
14:51:04 <EvilTerran> sorear, is that first slash in the expression i just typed division, or regex introduction?
14:51:29 <EvilTerran> answer: it depends on the return value of rand(), above. >:]
14:51:43 <twanvl> EvilTerran: Perl allows any character to be used for regexes
14:51:50 <sorear> EvilTerran: oh and dear do different things?
14:52:01 <twanvl> > "oh" == "dear"
14:52:02 <lambdabot>  False
14:52:10 <EvilTerran> you're both missing the point
14:52:20 <EvilTerran> the parse of the second line depends on how the first line runs
14:52:28 <jcreigh> EvilTerran: WTF?
14:53:01 <Haru> oerjan: then i found another way to interleave .. apart from concat.transpose :D interleave ((x:xs) : xss) = x : interleave (xss ++ [xs]	)
14:53:02 <sorear> EvilTerran: that's not very bad even by Lisp standards
14:53:09 <hpaste>  fxr pasted "replacing a node by contents read from stdin" at http://hpaste.org/2771
14:53:12 <EvilTerran> if rand returns <0.5, foo explicitly takes no parameters, so the / is taken to be division - it can't introduce a regex, 'cos that would be a parameter, and foo doesn't take any!
14:53:12 <Haru> my first sensible haskell program eayy
14:53:13 <b_jonas> but for haskell, I'm not saying it's difficult to parse for a machine, I'm just saying I don't like the rules from a human perspective
14:53:24 <EvilTerran> otherwise, it introduces a regex.
14:53:39 <sorear> EvilTerran: I don't recall the concrete syntax, but if one line might introduce a reader macro, than the second line must parse randomly
14:53:54 <jcreigh> so, that's what I don't like about perl.
14:53:58 <fxr> I coudn't replace a node with the provided input
14:54:02 <fasta> b_jonas: what editor do you use?
14:54:03 <b_jonas> ok, stop bashing perl now
14:54:03 <oerjan> Haru: that may be a bit inefficient though, ++ [xs] is O(n)
14:54:09 <fxr> any help ?
14:54:26 <b_jonas> fasta: I refuse to use syntax highlighting
14:54:38 <fasta> b_jonas: I ask what editor you use.
14:54:39 <b_jonas> though I use jump-to-other-parenthesis
14:54:41 <b_jonas> joe
14:54:50 <Paczesiowa> what happened to darcs.net? (btw check darcs.org :>)
14:54:50 <b_jonas> but I'm not completely satisfied with it
14:54:52 <EvilTerran> actually, prototypes (the () in sub () { "oh" }) have been deemed an error by larry wall and co, iirc.
14:54:56 <Haru> oerjan: ohh
14:55:08 <EvilTerran> specifically because they make the parsing even worse.
14:55:11 <fxr> any help will be highly appreciated
14:55:18 <EvilTerran> @paste , fxr?
14:55:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:55:19 <fasta> b_jonas: I haven't used joe, enough, but Emacs for example has semi-auto indentation.
14:55:28 <fxr> EvilTerran: already did
14:55:29 <sorear> Paczesiowa: the site has been randomly nonfunctional for as long as I can remember
14:55:36 <EvilTerran> ah, so you did
14:55:46 <fasta> b_jonas: moving a rectangle is possible for example too (and practical)
14:56:04 <b_jonas> I'll go back to reading the learning haskell now
14:56:14 <b_jonas> I don't want to discuss syntax anymore now, sorry
14:56:18 <b_jonas> nor editors
14:56:26 * sorear wonders what the priorities of the darcs team are
14:56:40 <b_jonas> gentle introduction to haskell thatis
14:57:38 <Paczesiowa> anyway, is it possible to force darcs to "work" per character and not per line?
14:57:54 <sorear> no
14:58:19 <Paczesiowa> is speed the only reason it's not implemented?
14:58:42 <monochrom> I think it's just convention. Every programmer thinks in terms of LOC.
14:58:50 <EvilTerran> sanity, too, i think
14:58:58 <Paczesiowa> LOC?
14:59:03 <allbery_b> lines of code
14:59:05 <twanvl> Talking of evil parsing; do you parse this in C++: f < 2 && 3 > (x + 1)
14:59:09 <monochrom> They even have an acronym for that!
14:59:11 <dons> i think in terms of cyclomatic complexity
14:59:17 <dons> that should be the natural hunk boundary :)
14:59:18 <sorear> (what) does the darcs team do nowadays?  is it still under development?
14:59:24 <EvilTerran> there's <128 characters you're likely to use, ambiguity is much more likely in terms of characters
14:59:25 <dons> yeah, under development
14:59:27 <conal> how much more compact would diffs/patches be if they were computed char-wise instead of line-wise?
14:59:29 <allbery_b> meanwhile, last I heard while there were block-diff (vs. .line-diff) algorithms, they were mostly very expensive and fairly poor
14:59:33 <dons> list is pretty active
14:59:44 <conal> I imagine char would help for comments especially
14:59:55 <Olathe> twanvl: Isn't it (f < 2) && (3 > (x + 1)) ?
15:00:09 <twanvl> Hint: templates
15:00:13 <EvilTerran> Olathe, or is it f <(2 && 3)> (x + 1)?
15:00:31 <conal> allbery_b: what's "block-diff"?
15:00:38 * EvilTerran really doesn't like C++'s template syntax
15:00:45 <Paczesiowa> would it be too hard for beginner haskell hacker (ok, to bo honestm more like noob) to add that per character patch type to darcs?
15:00:53 <allbery_b> oh, I wasn't thinking comments, I was thinking binary diffs
15:01:24 <sorear> there's plenty of talk, but is there any code?
15:01:38 <fasta> Paczesiowa: if you attack the problem systematically, it will be a challenge, otherwise probably not.
15:01:39 <Paczesiowa> because I think I have great (or at least not that stupid) idea for piece of software, but it needs that per characker work
15:02:47 <twanvl> Just intersperse "\n" :)
15:03:37 <fasta> Paczesiowa: you could just try it and see how far you get. The last time I wanted to add something darcs didn't build and so I lost interest. I only make working things better, not fix broken software of somebody else.
15:04:37 <Paczesiowa> any gentooers here perhaps? or anyone familiar with etc-update
15:06:05 * Naktibalda
15:06:24 <Naktibalda> 1 y q 1 y q :)
15:08:20 * EvilTerran boggles
15:08:20 <conal> seriously, i'd like to know why diff-like tools are line-oriented.
15:08:33 * EvilTerran fights the temptation to invent a new class of monads
15:08:45 <oerjan> ooh
15:08:53 <lscd> conal: because, once upon a time, it seemed like a good idea?
15:08:54 <infrared> Paczesiowa: you can always take the normal line-by-line diff output and then take compute per-character diffs from that
15:08:58 <conal> I've switched to longlines-mode in emacs, which i love.  diff is no longer my friend.
15:08:59 * oerjan tempts EvilTerran a bit more.
15:09:12 <infrared> Paczesiowa: practically building a layer on top of normal line-by-line diff program
15:09:24 <EvilTerran> MonadStream s m | m -> s where done :: m Bool; next :: m s; -- basically
15:09:33 <conal> lscd: maybe that's all.  i wonder if there's more.
15:09:34 <monochrom> conal: it made sense in imperative programming. a tradition since Fortran or before.
15:09:46 <lscd> monochrom: or rather, in line-oriented languages
15:09:48 <stepcut> conal: I (think) I have an diff algorithm in Haskell that is token oriented, so you could use it to diff on lines, words, characters, etc
15:09:49 <ddarius> monochrom: before
15:10:13 <monochrom> basically, one line of code expresses one step. when you change a program, you change a few steps, ==> a few lines.
15:10:15 <conal> stepcut: nifty.  what are the edit operations?
15:10:34 <monochrom> Clearly, functional programming is much different.
15:10:50 <EvilTerran> the obvious one is instance MonadState [a] m => MonadStream a m where done = liftM null get; next = do (x:xs) <- get; put xs; return x
15:10:51 <ddarius> change a few steps ==> fewer lines
15:11:04 <conal> monochrom: so short lines means line-oriented is tolerable
15:11:11 <ddarius> m (Maybe a)
15:11:29 <stepcut> conal: what do you mean ?
15:11:42 <EvilTerran> although, if i write it directly like that, i can't introduce any others without death by overlapping instances
15:11:44 <monochrom> Another factor is that we are used to lines in text (natural language) for centuries, too.
15:11:50 <EvilTerran> so it's gonna need to be a mess of newtypes =/
15:11:51 <wli> conal: One reason why I'm so religious about 24x80.
15:11:58 <conal> stepcut: e.g., insert string, delete string, swap strings.
15:12:18 <DRMacIver> Hm. I'm having a drain bead moment. I have an (Int, Int), say (m, n). I want to spiral outwards to cover the entire square within a distance k of (m, n), getting each point exactly once and moving only one square at a time.
15:12:20 <conal> stepcut: does your algorithm produce a way to transform one version into the other?
15:12:25 <DRMacIver> I can't for the life of me think how to implement this. :)
15:12:32 <monochrom> drain bead?
15:12:43 <DRMacIver> humorous misspelling of brain dead.
15:12:54 <stepcut> conal: no, you would have to write that part
15:12:57 <EvilTerran> ask spofessor prooner.
15:13:03 <conal> stepcut: what does your algorithm do?
15:13:09 <twanvl> EvilTerran: You could define instances for State, StateT, everyOtherT
15:13:13 <oerjan> DRMacIver: step 1: do it for (0,0). step 2: add (m,n)
15:13:22 <conal> oerjan: you beat me to it!
15:13:33 <DRMacIver> Well, yes.
15:14:00 <stepcut> conal: what I have is just a straight-forward implementation of diff+diff3. But, it does the diff on things of type [a], so your list can be a list of lines, characters, etc
15:14:06 <conal> DRMacIver: find the sequence of distances to travel
15:14:24 <monochrom> Two state variables. One is which direction you're going now. Another is the length you have to go for the current direction. The state transition function is left as an exercise.
15:14:39 <oerjan> DRMacIver: when you say distance k do you mean rectangular distance or euclidean? the latter might be worse.
15:14:49 <EvilTerran> twanvl, that looks like it could work, although i suspect it could get messy if i had more instances...
15:14:54 <oerjan> oh, you said square.
15:15:02 <conal> stepcut: and what's the output?
15:15:27 <ddarius> DRMacIver: Over 1, down 1, over 2, up 2, etc.
15:16:12 <DRMacIver> This isn't very helpful. I can see geometrically how this is supposed to work. I'm just for some reason having trouble converting it into actual code. :)
15:16:19 <DRMacIver> Never mind. I'll figure it out.
15:16:37 <DRMacIver> Thanks anyway.
15:16:42 <ddarius> DRMacIver: As monochrom suggested, you can view it as a state machine and it's very easy to translate state machines into Haskell.
15:16:44 <twanvl> EvilTerran: You mean other then [a]? Then add a class StreamLike f where doneS :: f a -> Bool; nextS :: f a -> (a, f a)
15:16:50 <EvilTerran> right 3, down 3, left 4, up 4, right 5, down 5, left 6, up 6
15:17:01 <EvilTerran> twanvl, and for other monads, equally. it doesn't have to be State.
15:17:03 <conal> DRMacIver: define a type for directions and a function move :: Dir -> Int -> Loc -> Loc
15:17:19 <EvilTerran> instance MonadStream Char IO, say
15:17:35 <stepcut> conal: In theory, you can out standard diff output or diff3 output, or you can get back a data structure
15:17:58 <twanvl> IO is also state in many ways
15:18:02 <EvilTerran> > [1..] >>= join replicate
15:18:03 <lambdabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9...
15:18:11 <EvilTerran> hm...
15:18:12 <oerjan> move (dx,dy) n (x,y) = (x,y):move (dx,dy) (n-1) (x+dx,y+dy)
15:18:25 <stepcut> conal: for diff, the data structure is: data DiffRes a = YPart !a | XPart !a | MatchPart !a
15:18:32 <oerjan> DRMacIver: ^^ one way of doing what conal said
15:18:35 <stepcut> well, a list of DiffRes
15:18:38 <DRMacIver> Thanks.
15:18:40 <conal> EvilTerran: cool one
15:18:47 <ddarius> > concatMap (replicate 2) [1..]
15:18:49 <EvilTerran> not sure if it's helpful
15:18:49 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
15:19:10 <monochrom> class StreamLike f where onoeS :: f a -> Bool; moreplS :: f a -> (a,  f a)
15:19:41 <stepcut> conal: for diff3 its, a list of, data Chunk a = Unstable (Span a) (Span a) (Span a) | Stable (Span a) (Span a) (Span a)
15:20:13 <ddarius> > [1..] >>= replicate 2 -- to gratuitously use (>>=)
15:20:15 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
15:20:29 <oerjan> DRMacIver: actually i think a Writer Monad might be helpful
15:20:33 <stepcut> Unstable ~ 3 files different, Stable ~ 3 files same
15:20:59 <conal> stepcut: and Span?
15:21:01 <oerjan> move (dx,dy) n (x,y) = do tell (x,y); move (n-1) (x+dx,y+dy)
15:21:12 <EvilTerran> > scanl (flip ($)) (0,0) (concat $ zipWith replicate (replicate 2 =<< [1..]) (cycle [first succ,second succ,first pred,second pred]))
15:21:13 <oerjan> er wait
15:21:15 <lambdabot>  [(0,0),(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1),(2,-1),(2,0),(2...
15:21:26 <ddarius> > iterate (\(b,n) -> (not b, if b then n + 1 else n)) (True,0)
15:21:28 <lambdabot>  [(True,0),(False,1),(True,1),(False,2),(True,2),(False,3),(True,3),(False,4)...
15:21:34 <EvilTerran> huzzah?
15:21:43 <ddarius> > iterate (\(b,n) -> (not b, if b then n + 1 else n)) (False,1)
15:21:45 <lambdabot>  [(False,1),(True,1),(False,2),(True,2),(False,3),(True,3),(False,4),(True,4)...
15:22:03 <oerjan> wow
15:22:43 <ddarius> We can use the parity of n to decide whether it's right/down or left/up
15:22:45 <EvilTerran> > sort $ take 25 $ scanl (flip ($)) (0,0) (concat $ zipWith replicate (replicate 2 =<< [1..]) (cycle [first succ,second succ,first pred,second pred]))
15:22:46 <lambdabot>  [(-2,-2),(-2,-1),(-2,0),(-2,1),(-2,2),(-1,-2),(-1,-1),(-1,0),(-1,1),(-1,2),(...
15:22:51 <DRMacIver> oerjan: I don't really understand writer monads yet. :)
15:23:12 <DRMacIver> Anyway, thanks all.
15:23:12 <EvilTerran> > sort $ take 25 $ scanl (flip ($)) (0,0) (concat $ zipWith replicate (replicate 2 =<< [1..]) (cycle [first succ,second succ,first pred,second pred])) == join (liftM2 (,)) [-2..2]
15:23:13 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
15:23:20 <Weremanatee> How do I turn a list into an infinite cycle?
15:23:21 <EvilTerran> > (sort $ take 25 $ scanl (flip ($)) (0,0) (concat $ zipWith replicate (replicate 2 =<< [1..]) (cycle [first succ,second succ,first pred,second pred]))) == join (liftM2 (,)) [-2..2]
15:23:22 <lambdabot>  True
15:23:23 <stepcut> conal: Span is a list consecutive tokens (aka, words, lines, etc)
15:23:25 <EvilTerran> :D
15:23:35 <EvilTerran> DRMacIver, do you see?
15:24:19 <Weremanatee> > cycle [1,2,3]
15:24:20 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
15:24:23 <Weremanatee> wo0t!
15:24:40 <monochrom> your first haskell program?
15:24:40 <conal> how about [first,second] <*> [succ,pred]
15:24:59 <EvilTerran> conal, i was just thinking of adding `ap` there
15:25:09 <conal> :)
15:25:10 <pjd> yay for <*>
15:25:22 <conal> ap is out <*> is in ;)
15:25:36 <oerjan> DRMacIver: never mind me today :)
15:25:53 <EvilTerran> anyway, i'm pretty sure that works
15:25:56 <oerjan> EvilTerran's was way cooler
15:26:04 <ddarius> > let (x,y) ? (b,n) | b && odd n = (x+n,y) | not b && odd n = (x,y+n) | b && even n = (x-n,y) | otherwise = (x,y-n) in scanl (?) (0,0) $ iterate (\(b,n) -> (not b, if b then n + 1 else n)) (False,1)
15:26:06 <lambdabot>  [(0,0),(0,1),(1,1),(1,-1),(-1,-1),(-1,2),(2,2),(2,-2),(-2,-2),(-2,3),(3,3),(...
15:26:37 <conal> i especially like the "first succ" etc part
15:26:47 <Paczesiowa> > "Hello World!"
15:26:48 <lambdabot>  "Hello World!"
15:26:52 <EvilTerran> that's not right, ddarius, it jumps straight from (1,1) to (1,-1)...
15:27:02 <ddarius> EvilTerran: It's easy to interpolate from their.
15:27:05 <ddarius> s/their/there
15:27:06 <DRMacIver> EvilTerran: I think I'm going to need to dijest that. :) But thanks.
15:27:30 <EvilTerran> conal, =]. i thought about using (+1) and (-1), but then the second one would be (+ -1) or (-1+) or (subtract 1) or something
15:27:46 <EvilTerran> so i thought i'd just abandon that plan and take advantage of the enum instance
15:28:04 <olsner> > 93 * (1.0225^1000)
15:28:06 <lambdabot>  4.283508449711061e11
15:28:12 <EvilTerran> DRMacIver, no probs. i enjoy my functions-as-data hackery immensely. ^^
15:28:25 <olsner> woot, Fry's balance is really what they say it is! :P
15:28:30 <olsner> (futurama)
15:28:39 <conal> EvilTerran: yeah -- that was too cool
15:29:19 <wli> Instant replay please? I was doing eyedrops.
15:29:26 <conal> has anyone seen 3D models (rotatable etc) in a pdf?  i only recently noticed the 3D section in acrobat reader preferences.
15:29:36 <ddarius> conal: No.
15:29:51 <Zao> conal: Isn't that more about using a 3D API to accelerate drawing of the document?
15:30:03 <EvilTerran> conal, i've seen that. it made me want to stab someone.
15:30:03 <conal> Zao: i don't know.
15:30:07 <ddarius> olsner: Yeah, but if you accounted for inflation, that would be nothing.
15:30:08 <EvilTerran> PDFS ARE FOR PRINTING >.<
15:30:20 <ddarius> EvilTerran: Actually...
15:30:25 * EvilTerran notes that [first,second] <*> [succ,pred] wouldn't work anyway
15:30:26 <conal> EvilTerran: tree killer
15:30:32 <conal> EvilTerran: no?
15:30:34 <EvilTerran> > [(1:), (2:)] <*> [[3], [4]]
15:30:35 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
15:30:36 <EvilTerran> wrong order
15:30:55 <allbery_b> EvilTerran: not a Mac fan, I take it?
15:31:10 <EvilTerran> it'd have to be [($succ),($pred)] <*> [first,second]
15:31:15 <EvilTerran> allbery_b, what makes you say that?
15:31:21 <conal> EvilTerran: oops.  good catch.
15:31:27 <allbery_b> OSX is based on Display PDF
15:31:42 <bas-fff> hello, i need to make an implementation of a function that works just link "maximum"
15:31:45 <EvilTerran> harumph. gotta move with the times, i suppose
15:32:03 <bas-fff> i'm using linux, where can i get the source code of this function to take as an example?
15:32:12 <omniscientIdiot> @src maximum
15:32:13 <oerjan> @src maximum
15:32:13 <lambdabot> maximum [] = undefined
15:32:13 <lambdabot> maximum xs = foldl1 max xs
15:32:14 <lambdabot> maximum [] = undefined
15:32:14 <lambdabot> maximum xs = foldl1 max xs
15:32:15 <monochrom> Postscript started out for printing, too. Note the common origin.
15:32:22 <allbery_b> @source Data.List
15:32:23 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
15:32:26 <EvilTerran> conal, that doesn't mean i actually print anything, just that, IMO, you shouldn't use PDFs for things you intend to only view on screen
15:32:29 <conal> i noticed that viewing 3D is fine but converting your model to the 3D pdf format requires a $1000 adobe program.
15:32:32 <EvilTerran> Display PDF, maybe. i don't know.
15:32:44 <conal> EvilTerran: why shouldn't one?
15:33:05 <conal> good quality and resolution independent.
15:33:13 <hpaste>  fxr annotated "replacing a node by contents read from stdin" with "solved" at http://hpaste.org/2771#a1
15:33:28 <bas-fff> thank you very much =D
15:33:37 <EvilTerran> @go chairs are for sitting PDF is for printing
15:33:38 <lambdabot> http://www.webpagesthatsuck.com/pdf.html
15:33:38 <conal> on the other hand, fixed page width & no adaptive paragraph reformatting
15:33:38 <lambdabot> Title: Chairs are for Sitting PDF is for Printing - Web Pages That Suck learn usability ...
15:34:13 <EvilTerran> conal, there you go. basically, "resolution independent" / "fixed page width & no adaptive paragraph reformatting" is the bulk of it
15:34:29 <EvilTerran> also, when online, anyway, "surprise! massive bloatware plugin/application!"
15:34:34 <monochrom> I thought chairs were for massaging and HDTV remote control, PDF for the multimedia experience on said HDTV. :)
15:34:46 <conal> EvilTerran: i like the resolution-independent part, but not the other
15:35:06 <olsner> ddarius: the inflation doesn't seem to be too bad in the futurama universe... bender's fine for shoplifting was only $80
15:35:23 <EvilTerran> conal, i may be misunderstanding what you mean by resolution independent
15:35:36 <EvilTerran> to me, it means basically the second thing of yours i quoted
15:36:14 <conal> EvilTerran: thanks.  i meant geometry & continuous coordinates.  renders into pixels dynamically, to suit output medium.
15:36:24 <oerjan> olsner: obviously there have been some digit strippings
15:36:33 <scodil> Can someone help me figure out what the type checker is doing here, and why my instance declarations aren't found unless I give full signatures to the values?
15:36:34 <conal> like outline fonts vs bitmap fonts
15:36:35 <hpaste>  scodil pasted "type inference with classes" at http://hpaste.org/2773
15:36:46 <conal> better quality with less data
15:37:01 <EvilTerran> i guess that has it's uses. the lack of paragraph flow's the killer, though.
15:37:09 <EvilTerran> *its
15:38:01 <fxr> I wonder if there is any solution with input validation for my paste http://hpaste.org/2771#a1
15:38:03 <conal> EvilTerran: yeah - it is.
15:38:20 <EvilTerran> > concat . transpose . replicate 2 $ [1..]
15:38:31 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
15:39:10 <oerjan> > [1..] <* [(),()]
15:39:12 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
15:39:19 <oerjan> i win! :D
15:39:47 <EvilTerran> actually, http://www.useit.com/alertbox/20030714.html is a better explanation of what's wrong with PDF on screen
15:39:49 <lambdabot> Title: PDF: Unfit for Human Consumption (Jakob Nielsen's Alertbox)
15:39:55 <EvilTerran> (altho linked from that WPTS article)
15:40:12 <EvilTerran> > map floor [1,1.5..]
15:40:13 * ddarius proposes as an energy saving measure use Simon Peyton-Jones to power the audio/visual equipment filming his talks.
15:40:13 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
15:41:14 <monochrom> I don't want to see lots of wires attached to him during his talks.
15:41:27 <Olathe> The wires could be hidden under his clothing.
15:41:31 <Mr_Awesome> is there a ghc package called "lang" ?
15:41:38 <SamB> ddarius: hahahaha
15:41:38 <monochrom> Not anymore.
15:42:10 <EvilTerran> ddarius, that's great. from seeing him talk, i know exactly what you mean
15:42:23 <oerjan> actually...
15:42:24 <Mr_Awesome> monochrom: talking to me?
15:42:26 <EvilTerran> @quote ddarius proposes as an energy saving measure use Simon Peyton-Jones to power the audio/visual equipment filming his talks.
15:42:27 <lambdabot> No quotes match. My pet ferret can type better than you!
15:42:33 <oerjan> > [1..]<*"ha"
15:42:34 <EvilTerran> @remember ddarius proposes as an energy saving measure use Simon Peyton-Jones to power the audio/visual equipment filming his talks.
15:42:34 <lambdabot> Done.
15:42:35 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
15:43:02 <monochrom> Yes Mr_Awesome
15:43:27 <goalieca> > length [1..]
15:43:31 <lambdabot> Terminated
15:43:34 <goalieca> ha!
15:43:35 <Mr_Awesome> monochrom: what happened to it? this library im trying to compile requires it
15:43:47 <EvilTerran> @help @run -- three second rule, goalieca
15:43:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:43:51 <EvilTerran> @help run
15:43:51 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
15:44:18 <Mr_Awesome> is it perhaps called something different now?
15:44:29 <monochrom> the libraries got reorganized. "lang" was a GHC 5.x thing. We're now at GHC 6.x. Some stuff goes into "base", there are other changes.
15:44:40 <goalieca> but it will never end or will it stop at overflow?
15:45:34 <oerjan> goalieca: i guess the length may wraparound as Int, so that will not overflow
15:45:42 <Mr_Awesome> monochrom: hmm... so would compiling something made for 5.x with 6.x even be feasible?
15:45:54 <oerjan> but the number inside is an Integer, so may grow arbitrary
15:46:07 <monochrom> You need to work. Hunt down things.
15:46:15 <oerjan> *numbers inside are
15:46:31 <Mr_Awesome> argh, i hate work
15:52:06 <b_jonas> bye
15:59:04 <scodil> hey can someone maybe take a look at this and tell me what I need to do to get the instance declarations to work right? http://hpaste.org/2773
16:00:13 <oerjan> scodil: i saw you had a forall type as instance, which is over my head somewhat, but that might also be the reason why it doesn't work i guess.
16:01:38 <scodil> oerjan: ah you're right, I don't need that. but taking it out doesn't make it work
16:01:58 <Saizan> knowing a b and u is not enough to decide v
16:02:03 <Saizan> from your fundeps
16:04:06 <scodil> Saizan: ah ok. I see
16:05:31 <tehgeekmeister> ?src foldM
16:05:31 <lambdabot> foldM _ a []     = return a
16:05:31 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:05:51 <scodil> Saizan: a b and u should be enough to decide v, but how do I encode that?
16:06:00 <fax> what don't fold me
16:06:13 <scodil> adding u -> v doesn't help, says coverage condition fails
16:06:16 <Saizan> scodil: u b -> v
16:06:24 <oerjan> scodil: in the vec1 case your problem may be the monomorphism restriction, which without declaration causes it to use Integer instead of Int
16:07:27 <oerjan> because of defaulting.
16:07:49 <scodil> Saizan: still complains about coverage condition
16:08:05 <scodil> oerjan: no I don't think that's it. when it complains about a lack of instance, it just says type is t, not Integer
16:08:32 <Mr_Awesome> what is the significance of a warning stating that an identifier is exported from two different modules?
16:08:33 <scodil> not sure though
16:08:41 <ricky_clarkson> DRMacIver: Excel fulfills those requirements.
16:08:58 <oerjan> scodil: i mean, that may bite you later.
16:09:06 <Saizan> scodil: well the coverage condition is a rough heuristic to be sure that type inference/checking terminates, you can remove it with -fallow-undecidable-instances
16:09:42 <monochrom> Mr_Awesome: If you import both modules, both have "f", then you use "f", which f is it? That's the question.
16:09:54 <Saizan> (rough = excessively restrictive, here)
16:09:58 <EvilTerran> monochrom, i thought the question was "will it blend?"
16:10:10 <monochrom> mebbe
16:10:19 <EvilTerran> actually, i guess, in haskell, "will it bind?" would be more appropriate ;)
16:10:34 <monochrom> haha
16:10:58 <monochrom> It's the same question in every programming language.
16:11:04 <Mr_Awesome> but if both are never imported at once then theres no problem?
16:11:11 <oerjan> Saizan: the context is smaller than the instance type to my eyes?
16:11:22 <monochrom> If you only import one of them, no problem.
16:11:56 <Mr_Awesome> ah damn. im getting an ambiguous reference to >>^ now
16:12:04 <Saizan> oerjan: so?
16:12:07 <Mr_Awesome> was ghc 5.x more lax on this stuff or what?
16:12:15 <scodil> Saizan: ok it allows the instance decl, but now I get the same "No instance for..." error when using vmap
16:12:49 <scodil> again, adding signatures makes it go away
16:12:57 <monochrom> No. But probably >>^ had only one definition, not two, a long time ago.
16:13:05 <oerjan> Saizan: so it obviously terminates from that, doesn't it? i thought whatever ghc uses must be more lenient than that...
16:13:47 <EvilTerran> what're the two defs?
16:14:04 <EvilTerran> one's composing an arrow and a pure fn, i know that
16:14:07 <monochrom> probably even zero definitions a long time ago.
16:14:46 <scodil> oh wait nm it works if I just give one signature.
16:14:58 <oerjan> @index (>>^)
16:14:59 <lambdabot> Control.Arrow
16:16:32 <oerjan> scodil: the last error message before it worked, it didn't happen to include Integer somewhere did it?
16:16:34 <Mr_Awesome> ah, so Arrow must have acquired >>^ since this lib was written
16:17:45 <oerjan> actually that couldn't be a problem i guess
16:18:08 <scodil> oerjan: no. you sure it defaults to Integer? I'm not using ghci. I thought integer literals had type (Integral a) => a
16:18:15 <oerjan> since with no declarations there would be nothing wanting an Int anyway.
16:18:42 <oerjan> scodil: default (Integer, Double) is the default default declaration in H98
16:19:07 <oerjan> so when something forces defaulting, that would be used unless you override it.
16:19:25 <EvilTerran> here's an idea - i'm going to take a leaf out of the implicit parameters syntax here...
16:19:39 <oerjan> and the monomorphism restriction would force defaulting of your vec1 and vec2.
16:19:43 <Saizan> does defaulting work when there are other classes involved?
16:19:56 <ddarius> Saizan: It only works for standard classes.
16:19:57 <EvilTerran> say "class ?Foo a" introduces a class with "scoped instances" (bear with me)
16:20:26 <SamB> which gets annoying if you are using Data.Bits...
16:20:27 <oerjan> right, so vec1 could be defaulted but vec2 wouldn't be able to.
16:20:37 <EvilTerran> then, if the type of a function had (?Foo a) => instead of (Foo a) =>, that would, likewise, indicate use of a scoped instance
16:20:54 <Saizan> ddarius: so if i have foo :: Integral a, Foo a => a, i don't get any defaulting, right?
16:21:04 <ddarius> Saizan: Correct.
16:21:06 <EvilTerran> instances could be scoped with "instance Foo a where ... in ...", where the second (...) is an expression, and the whole thing an expression
16:21:13 <hpaste>  scodil annotated "type inference with classes" with "1 sig still needed" at http://hpaste.org/2773#a1
16:21:40 <scodil> oerjan, Saizan: can you look at that and see if there's a way to get rid of the signatures?
16:21:42 <EvilTerran> we've still got the normal, global, instances, but this would allow for ones of limited scope, too
16:22:03 <ddarius> Why bother with the ?Foo nonsense?
16:22:37 <SamB> that should be scoped *classes*
16:22:40 <EvilTerran> i'm thinking maybe some kind of syntactic sugar for taking an existing instance off a newtype would be useful; say "instance ?Applicative [a] = ZipList a in..." or something
16:23:06 <EvilTerran> ddarius, because things would explode if every instance became this way scoped overnight.
16:23:24 <ddarius> EvilTerran: Nothing would change.
16:23:43 <sjanssen> you'd have major problems with type families
16:23:47 <SamB> news flash:
16:23:59 <SamB> the context already includes type classes!
16:24:07 <EvilTerran> this way, someone can specify "take this instance off the person calling the function, and use this instance as normal"
16:24:15 <EvilTerran> "(?Foo a, Bar a) => ..."
16:24:32 <ddarius> So you want "dynamic" scope for these things.
16:24:35 <SamB> EvilTerran: how's that different from what we have now?
16:24:35 <EvilTerran> sjanssen, i haven't thought about those, yet. this was just an idea i was tossing around.
16:25:03 <EvilTerran> SamB, (instance ?Monoid a = Sum     a in mconcat [1..5]) == 15
16:25:12 <EvilTerran> (instance ?Monoid a = Product a in mconcat [1..5]) == 120
16:25:42 <oerjan> scodil: you might _try_ -fno-monomorphism-restriction or whatever.
16:25:52 <oerjan> (iirc)
16:26:13 <EvilTerran> admittedly, those particular examples aren't any nicer under this idea, but i feel it'd be useful if you had many nested functions all relying on, say, an Applicative or Monoid instance.
16:26:13 * SamB wonders how the SID chip calculates the 12th root of 2
16:26:33 <scodil> oerjan: that's it. thanks
16:26:35 <ddarius> "SID chip"?
16:26:47 <EvilTerran> ddarius, kinda, yes, although i think it should be resolvable at compile time
16:26:50 <SamB> @google 6581
16:26:53 <lambdabot> http://en.wikipedia.org/wiki/6581
16:26:53 <lambdabot> Title: MOS Technology SID - Wikipedia, the free encyclopedia
16:27:36 <EvilTerran> the problem with trying to have lexically scoped instances being that it could become very muddy which instance was being used where
16:27:45 <ddarius> SamB: Would it need to?
16:27:54 <ddarius> EvilTerran: Indeed.
16:27:58 <EvilTerran> ddarius, it's a semitone, methinks
16:28:03 <ricky_clarkson> SamB: The 12th root of 2 isn't actually the ideal ratio.
16:28:26 <SamB> oh, wait, the documentation was talking about the equal-tempered scale
16:28:33 <SamB> not the chip's actual behaviour
16:28:43 <scodil> oerjan: what was going on there? can you try to explain it to me so I don't get bit by that again? the error messages seem to have nothing to do with the monomorphism restriction.
16:28:52 <ddarius> EvilTerran: I know that, why not just store a constant.
16:29:12 <EvilTerran> however, if every instance were "dynamically" scoped, one function could change behaviour unexpectedly inside an instance...in... clause you created to control the behaviour of another
16:29:23 <EvilTerran> ddarius, i dunno. ask SamB :P
16:29:44 <oerjan> scodil: the monomorphism restriction forces bindings like vec1 = ... and vec2 = ... to be monomorphic in all types involving type classes.
16:30:03 <SamB> ddarius: a constant?
16:30:04 <ddarius> ricky_clarkson: Are you going to say Pythagorean ratios are ideal?
16:30:13 <SamB> ddarius: the thing is an analog synth
16:30:39 <ricky_clarkson> No.  I can't remember the actual way the frequencies are worked out, but 12th root of 2 isn't it.  Something to do with harmonics getting in the way.
16:30:41 <oerjan> but if a type is in a non-standard typeclass, it cannot be defaulted.
16:30:44 <ddarius> SamB: You can get an analog signal that is roughly constant.
16:31:25 <scodil> oerjan: so the only reason I ran into that is because I was declaring those things, vec1 and vec2, at the top level. in functions I won't have to deal with that, right?
16:31:26 <oerjan> so then i guess ghc tries to find an instance that works _without_ fixing the type, before actually defaulting it. this is very vague in my mind.
16:31:34 <EvilTerran> ... but introducing a requirement that any scoped instances be stated in the types should prevent any such unexpected changes
16:31:52 <ddarius> SamB: Also calculating it shouldn't be that hard.  It's not hard to find an exponential in analog stuff.
16:32:10 <EvilTerran> anyone spotted any glaring problems?
16:32:14 <SamB> ricky_clarkson: anyway, if the 12th root isn't ideal, neither is the equal-tempered scale ;-)
16:32:29 <oerjan> scodil: in principle it can happen in functions, but more rarely because they types are usually fixed by the types of the function parameters
16:32:36 <ricky_clarkson> Don't say that in front of J.S.Bach.
16:32:41 <EvilTerran> actually, i might type this up neater and send it to -cafe; IRC's not the perfect setting for discussing long-winded proposals.
16:32:47 <ricky_clarkson> He'll start rubbing his music out.. decomposing.
16:33:08 <oerjan> and types fixed by function parameters are not affected by the MR.
16:33:35 <oerjan> *fixed in relation to the function parameters, i should say.
16:34:28 <oerjan> actually, thinking about it may not be possible, really
16:34:57 <ddarius> SamB: What it would probably do though is heterodyne two (or more) oscillators.
16:35:07 <glguy> ps axf
16:35:10 <jatqceer> I got "*** Exception: Error in array index".  How do I know which part of the code that produces this error?  some switchs that I have to turn on in ghc?
16:35:12 <glguy> hmm
16:35:14 <oerjan> because any type inside a function definition that doesn't affect the type of the function itself will give an ambiguity error instead.
16:35:32 <ricky_clarkson> Would you say that \x y -> x+y was equivalent to (lambda (x y) (+ x y))?
16:35:51 <ddarius> ricky_clarkson: It's how I would translate it, but it's not equivalent.
16:35:55 <fax> ricky_clarkson: No
16:36:00 <fax> more like
16:36:05 <fax> (lambda (x) (lambda (y) (+ x y))
16:36:10 <EvilTerran> (lambda (x) (lambda (y) (+ x y)))
16:36:12 <EvilTerran> snap!
16:36:15 <fax> :D
16:36:23 <ddarius> You lose fax, you missed a paren.
16:36:29 <ricky_clarkson> But then you can't call that with 5 6
16:36:41 <ricky_clarkson> ((that 5) 6)
16:36:44 <ddarius> ricky_clarkson: Indeed, but you can then pass around (f 5)
16:36:49 <EvilTerran> ricky_clarkson, i think behaviour is more important than syntax
16:36:53 <fax> ricky_clarkson: Function application in haskell is different
16:37:00 <fax> (f x y) is like ((f x) y)
16:37:13 <ddarius> It's not "like" that, it -is- that.
16:37:25 <EvilTerran> given that we're trying to compare a language with a very saccharine syntax to one with no syntax at all, let alone sugar
16:37:38 <ricky_clarkson> Yes, I know about currying, but if you are not using partial application then they appear equivalent.
16:37:53 <oerjan> jatqceer: ouch.  finding out where an exception is raised i think requires using profiling or (the very recent) debugger.
16:38:19 <ddarius> ricky_clarkson: As I said, I'd probably translate to the first form, but like it or not, they are not equivalent.
16:38:24 <fax> ddarius: Hey, I'm not used to typing close brackets!
16:38:37 <Mr_Awesome> if i have the file /foo/Foo.hi and i invoke ghci -i/foo and then > :m + Foo, will the Foo module be loaded?
16:38:48 <ddarius> It's not our fault that Lisps makes currying and application noisy.
16:38:49 * fax lets the computer do it
16:39:05 <ddarius> fax: Your IRC client doesn't have paren matching?!
16:39:07 <ricky_clarkson> In an article where currying is introduced later, I think it makes sense to translate it the way I suggested.
16:39:08 <jatqceer> oerjan: can you direct me to some manual or website?
16:39:20 <LoganCapaldo> Mr_Awesome: Didja try it? :)
16:39:20 <oerjan> @where ghc
16:39:21 <lambdabot> http://haskell.org/ghc
16:39:26 <fax> lol
16:39:27 <fax> nope
16:39:29 <ricky_clarkson> Ok, thanks.
16:39:41 <Mr_Awesome> LoganCapaldo: what i meant was, *should* it work? because id think it would, but it doesnt
16:39:48 <oerjan> jatqceer: the ghc manual?
16:40:08 <jatqceer> oerjan: i'll try to read that
16:40:10 <Mr_Awesome> it says it cant find the module
16:40:21 <oerjan> there's a profiling chapter.
16:40:43 <LoganCapaldo> Mr_Awesome: I don't really know tbh
16:40:47 <Saizan> jatqceer: you can get something like a stack trace compiling with -p -auto-all and running with +RTS -xc
16:40:58 <ddarius> ricky_clarkson: In an article where currying is going to be introduced, I would translate it properly from the get go (and talk about currying earlier), if it wasn't going to be introduced I would translate it your way.
16:41:22 <oerjan> jatqceer: mind you, i am as usual speaking a lot about things i haven't used myself
16:41:27 <jatqceer> Saizan: thanks.  I'll do
16:41:55 <jatqceer> oerjan: I like practice
16:42:56 <oerjan> and i am hideously impractical :/
16:44:39 <ricky_clarkson> ddarius: Do you think dibblego is just being picky here?  http://programming.reddit.com/info/2pv83/comments
16:44:40 <lambdabot> Title: Point-free programming in Java 7 (reddit.com)
16:45:47 <ricky_clarkson> (you may want to refresh, I just edited my last comment)
16:49:29 <balodja> Hm. C-pointers should have type of log(a) :) Difference then has type of log(1), and sum has type of log(a*a) :)
16:50:16 <olsner> what do you mean by log(a)?
16:51:34 <monochrom> ricky_clarkson: you have to define "same" before you can ask "is 'x and y not the same' just being picky"
16:51:51 <SamB> @google 1 pH in parts per million
16:51:53 <lambdabot> http://www.esrl.noaa.gov/gmd/ccgg/trends/
16:51:54 <lambdabot> Title: Trends in Carbon Dioxide
16:52:22 <ricky_clarkson> monochrom: I gave \x y -> x+y and {int x,int y => x+y} as examples of lambda expressions.
16:52:54 <ricky_clarkson> monochrom: (the latter is from the proposed Java 7).  Someone picked on it as the second not being the same as the first.
16:53:16 <monochrom> What is the type of {int x,int y => x+y} ?
16:53:32 <ricky_clarkson> java.lang.function.FunctionIII afaik
16:53:46 <monochrom> Is it legal to write {int x,int y => x+y}(5) ?
16:53:56 <ricky_clarkson> No, for two reasons.
16:54:10 <monochrom> Is it legal to write (\x y -> x+y) 5 ?
16:54:17 <ricky_clarkson> There is no automatic currying in the proposal at the moment (it is an 'open issue' though).
16:54:21 <shapr> SamB: pH is a measure of acidity.
16:54:39 <ricky_clarkson> Also, you need to explicitly invoke these - {int x,int y => x+y}.invoke(5,6)
16:55:18 <monochrom> So you see, you have to define "same" to overlook that difference. I see the difference. I don't see how to define "same" to overlook the difference. Perhaps you see how to.
16:55:43 <ddarius> ricky_clarkson: Currying isn't "automatic" or not.
16:56:03 <monochrom> Is there any way I pass 5 to {int x,int y => x+y} to get a function?
16:56:07 <allbery_b> <monochrom> Is it legal to write (\x y -> x+y) 5 ?
16:56:13 <allbery_b> sure, the result is a function
16:56:21 <ddarius> allbery_b: That's his point.
16:56:23 <ricky_clarkson> monochrom: Not currently.
16:56:36 <monochrom> OK, so you have to be aware of that.
16:56:46 <SamB> shapr: istr a logarithm being involved...
16:56:51 <monochrom> You can argue, "it doesn't matter", but you have to know it.
16:56:56 <ddarius> SamB: Indeed.
16:57:04 <ricky_clarkson> monochrom: In the context I was only giving examples of lambda expressions, not stating that "these following pieces of code are identical".
16:57:12 <olsner> an N-argument function should have an invoke implementation for [1..N-1] arguments that return the partial functions
16:57:20 <olsner> (Java7)
16:57:24 <ricky_clarkson> Perhaps the question I asked in the channel was badly formed.
16:57:38 <dancor> is it a better idea to use xslt 1.0 or 2.0 with happs?  since there is only one slow server-side xslt 2.0 and no client-side support, 2.0 seems bad.  thoughts?
16:57:51 <sorear> SamB: moles_H_per_litre = 10 ^ -pH
16:57:59 <monochrom> You asked, is he picky? I answer, not so picky.
16:58:06 <sorear> dancor: #happs maybe?
16:58:14 <ricky_clarkson> monochrom: Are you basing that on the context in the blog post?
16:58:28 <dancor> sorear: tx
16:58:31 <monochrom> No.
16:58:32 <ricky_clarkson> olsner: I agree completely.
16:58:42 <shapr> dancor: We've been using xslt2.0, I think.
16:59:47 <Haru> oerjan: any ideas how to write a determinant function?
17:00:06 <oerjan> Haru: i did, just the other day
17:00:18 <oerjan> it's on hpaste somewhere, i think
17:00:19 <olsner> but it seems the Java7 lambdas are just a little bit of salty sugar for the classical lambda-expressions-as-classes abomination
17:00:31 <oerjan> last someone asked :D
17:00:52 <ricky_clarkson> olsner: They are, but that's ok if it doesn't have any effects outside the implementation.
17:01:13 <Haru> oerjan: how do i search there :S
17:01:24 <oerjan> i was wondering that myself :)
17:01:26 <ricky_clarkson> olsner: return, this, break, continue, have the meaning from the containing code, as opposed to how things work for anonymous classes.  I don't think there's much leakage.
17:01:55 <ddarius> Upon reading the blog post, I want to emphasize again that Haskell doesn't "automatically" curry, it doesn't curry at all.
17:02:18 <olsner> my major gripe would be the invokation syntax.... having to do lambda.invoke(...) is ugly
17:02:23 <oerjan> not in google yet :(
17:03:01 <Haru> oerjan: could u hint me in the right direction.. i cannot figure an algo thats not memory based
17:03:02 <ricky_clarkson> olsner: Namespaces are the quoted problem with that.
17:03:12 <ddarius> Implement the geometric algebra, then, for a linear transformation lifted to an outermorphism, f, det f = i^-1 f(i)
17:03:15 <ricky_clarkson> olsner: It's not dissimilar to Common Lisp's funcall there.
17:03:27 <ddarius> ricky_clarkson: Which is ugly.
17:03:33 <ricky_clarkson> Yes.
17:04:18 <olsner> hey, they are already mucking in the grammar of the language - why can't they just add function call syntax for objects of the right class? like lambda(arg, arg)
17:04:31 <olsner> C++ has it ;-)
17:04:33 <ddarius> Why don't they just copy C#.
17:04:44 <oerjan> found it, http://hpaste.org/2516
17:04:48 <ricky_clarkson> ddarius: "In Haskell, all functions are considered curried" - is that significantly different to "In Haskell, all functions are automatically curried"?
17:05:03 <Haru> oerjan: thanks
17:05:25 <ricky_clarkson> olsner: I don't know what you mean.
17:05:35 <allbery_b> it's not automatic; haskell will let you write an uncurried function
17:05:36 <oerjan> essentially uses elementary row operations.
17:05:37 <ddarius> Yes.  Except, arguably the first isn't quite true.
17:05:47 <ricky_clarkson> ddarius: The first is from http://www.haskell.org/haskellwiki/Currying
17:05:49 <lambdabot> Title: Currying - HaskellWiki
17:06:10 <ddarius> ricky_clarkson: The (multiple parameter) functions -are- in curried form, but they are not being curried.
17:06:16 <Saizan> olsner: even python!
17:06:24 <monochrom> "\x y -> " is syntactic sugar for "\x -> \y -> ". Interpret this however you like.
17:06:27 <olsner> ricky_clarkson: that's me still not understanding why .invoke(...) is required
17:06:36 <Haru> oerjan: its a lil hard to understand tho
17:06:45 <ricky_clarkson> olsner: I don't understand your alternative.
17:06:49 <ddarius> ricky_clarkson: Currying is what the curry function does.
17:06:51 <ddarius> :t curry
17:06:54 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:07:15 <Haru> oerjan: plus it uses data.lists
17:07:58 <Mr_Awesome> can a *.hi file be loaded as a module?
17:08:00 <ricky_clarkson> Ok, I'll defer judgement on this stuff, and read some more.  Thanks.
17:08:31 <Saizan> ricky_clarkson: he's just asking for a syntactic sugar like obj(arg0,arg1) -> obj.invoke(arg0,arg1), which can be seen as a sort of C++ operator overloading
17:08:35 <monochrom> Mr_Awesome: First-order answer is no.
17:09:01 <ricky_clarkson> Saizan: Oh.  That's what Neal Gafter (spec lead) said causes difficulties with namespaces.
17:09:31 <ddarius> Mr_Awesome: A .hi file is like a C header file, there's nothing to load.
17:09:33 <ricky_clarkson> ..i.e., obj(arg0,arg1) is normally resolved to the nearest method, not a variable named obj.
17:09:36 <Saizan> ricky_clarkson: and why? one could just have an interface Callable
17:09:47 <Saizan> ah, right
17:09:52 <Mr_Awesome> as in, if you have import Foo and *.hi in the path, will that compile?
17:10:00 <Saizan> silly implicit this
17:10:03 <Mr_Awesome> s/*.hi/Foo.hi
17:10:22 <ricky_clarkson> Saizan: Implicit this is irrelevant.  The same issue exists for static methods.
17:10:30 <monochrom> That's gets us to the second-order answer, which I am not sure.
17:10:31 <ddarius> Mr_Awesome: It might compile to object code, it won't link.
17:10:41 <ddarius> (Not without the object code for Foo.)
17:10:49 <ricky_clarkson> Saizan: This is why Scheme programmers have to write variables called lst (instead of list) quite often. ;)
17:10:52 <monochrom> Yeah, if you have Foo.o too, maybe it will work.
17:11:15 <Mr_Awesome> but it wouldnt say "Couldn't find module "Foo"" ?
17:11:34 <Saizan> ricky_clarkson: well silly implicit qualifing then :)
17:12:10 <olsner> hmm... I guess that could result in old code changing behaviour when compiled with new java compilers, unless the compiler catches ambiguous shadowing
17:12:14 <ddarius> ricky_clarkson: They don't have to.  You can shadow list.
17:12:16 <oerjan> Haru: the span searches down the first column for the first row that starts with non-zero.  Then it subtracts multiples of that row from the remaining to make those start with zero.
17:12:27 <oerjan> *it = the function
17:13:05 <Mr_Awesome> ddarius: if i just had Foo.hi in the path, would it give me the error Couldnt find module "Foo" ?
17:13:27 <allbery_b> what path?
17:13:34 <Mr_Awesome> the search path
17:13:36 <oerjan> then it uses the usual formula to remove that row and column, and recurses on the minor.
17:13:40 <Mr_Awesome> like with -i/dir
17:13:42 <monochrom> I have just tried. It positively wants to see Foo.hs.
17:13:47 <ddarius> Mr_Awesome: I don't know.  Write two modules, have one import the other, compile, delete the .o files and the .hs file for the imported module and compile again and see what happens.
17:14:28 <SamB> monochrom: with or without --make?
17:14:28 <monochrom> If you put module Foo into a package, it will not require Foo.hs. Otherwise, it will.
17:14:33 <monochrom> with --make
17:14:59 <Mr_Awesome> monochrom: so in order for this to really work with ghc 6.x i should make it into a package?
17:15:19 <ricky_clarkson> ddarius: You can shadow list, but then you might find yourself forgetting you've shadowed it.
17:15:40 <ricky_clarkson> It's happened to me once in 2 months of playing with Scheme.
17:16:04 <monochrom> Interesting. Without --make, e.g., ghc h.hs Foo.o, it works.
17:16:22 <ricky_clarkson> Saizan: Haskell has similar qualifying to Java, afaik.
17:16:43 <monochrom> Note that Foo.hi is still implicitly read.
17:16:54 <ddarius> ricky_clarkson: Yes, that's the nature of the beast.  Usually you don't shadow, and usually you can do that without having to think up ridiculous names like lst.
17:17:08 <monochrom> Well, I like --make, it does a lot of things I wouldn't want to do by hand.
17:17:12 <oerjan> Haru: oh, and i just discovered the import Data.List is unnecessary - both span and zipWith are in the Prelude.
17:17:25 <ddarius> Also, usually you don't have such things scoped over large blocks of code.
17:17:35 <ddarius> @index span
17:17:35 <lambdabot> Data.List, Prelude
17:19:31 <hpaste>  oerjan annotated "determinant attempt" with "slight improvement" at http://hpaste.org/2516#a2
17:20:10 <Saizan> ricky_clarkson: but we don't have methods and vars in different namespaces
17:20:42 <Haru> oerjan: span is there only for efficiency?
17:21:09 <ricky_clarkson> Saizan: Does that ever cause difficulties?  I'm trying to think of a function with a name that you might want a variable to have.  Maybe elem.
17:21:34 <monochrom> phi
17:22:09 <ricky_clarkson> Saizan: Because Scheme has a function called list, and you often want to make lists and take them as arguments to procedures, conflict is quite common.  Haskell obviously has syntax for lists instead of a name..
17:23:06 <oerjan> Haru: well, it makes it easy to remove the found element from the list, and in this case also splits off the preceding rows, which we don't need to adjust and which we need the number of to calculate the sign in the formula
17:23:18 <Saizan> ricky_clarkson: having 2 namespaces is what causes problems with obj(arg0) no? you don't know if the programmer means the real method or the Callable, but with a single namespace you can have only one at a time
17:23:23 <ddarius> ricky_clarkson: In my experience, it is extremely rare for Haskellers to name variables or arguments "list" even though it also strongly supports lists.
17:23:36 <ricky_clarkson> Saizan: Yes.
17:23:38 <oerjan> it just fit the problem to well not to be used :)
17:24:00 <oerjan> *too
17:24:19 <ddarius> (Admittedly that's not really relevant to the discussion, but I find it odd that it's alledged that Schemers always want to.)
17:25:13 <ricky_clarkson> olsner: As it happens, I don't think it could break old code, because old code wouldn't use the features necessary to make a difference (function types).  It might cause a few surprises in new code though.
17:26:28 <Saizan> it's true that handling namespaces is harder in java because classes are more than modules
17:27:28 <ricky_clarkson> I think it's sad that Java even allows you to use classes as modules.
17:28:02 <ddarius> ricky_clarkson: I think it's sad tha Scheme even allows you to use lambdas as modules.
17:28:24 <ricky_clarkson> Ok, s/allows/encourages/ in my last line.
17:28:31 <Saizan> lambdas?
17:28:34 <ddarius> That's better.
17:28:50 <wli> I prefer for modules to be entities unto themselves.
17:28:52 <ricky_clarkson> I realised my error but hoped you might let me get away with it.
17:29:09 <ddarius> I'll go watch a movie, then everyone will be happier.
17:29:44 <ricky_clarkson> I'm trying to watch one but it keeps pausing.
17:41:27 <Saizan> can you make cabal call c2hs for you?
17:57:07 <alexj> dancor: server xsl2.0 is actually very fast.  the start up time for java is just very slow.  to use xslt2 someone just needs to write a wrapper around the java xslt2 code that keep it loaded and ready to receive commands.
17:58:20 * edwardk waves hello.
17:58:25 <sorear> 2hi!
17:58:50 <monochrom> the universe is quantized. your hello is particles.
17:59:05 * monochrom particles hello
17:59:06 <oerjan> also waves!
17:59:29 <allbery_b> mmm, wavicles
17:59:35 <alexj> oh, dancor, is no longer here.  anyone know how to send him a message?
17:59:50 <oerjan> @help tell
17:59:50 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
17:59:51 <allbery_b> @help tell
17:59:51 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
17:59:54 <allbery_b> heh
17:59:54 <monochrom> @tell alexj I love haskell
17:59:54 <lambdabot> Consider it noted.
18:00:08 <edwardk> =)
18:00:46 <monochrom> You don't have to use it in public.
18:01:04 <alexj> @tell dancor server xsl2.0 is actually very fast. the start up time for java is just very slow. to use xslt2 someone just needs to write a wrapper around the java xslt2 code that keep it loaded and ready to receive commands.
18:01:04 <lambdabot> Consider it noted.
18:01:50 <alexj> thanks.
18:01:50 <lambdabot> alexj: You have 1 new message. '/msg lambdabot @messages' to read it.
18:02:10 <oerjan> interesting - lambdabot did not consider a command to be a clue to tell about messages.
18:03:53 <allbery_b> nope, conbtext hooks and commands follow different paths
18:05:25 <ricky_clarkson> allbery_b: fwiw, I removed xsl (if I don't know what version that means version 1 I suppose) from my Java app and saw a marked speedup.
18:05:59 * allbery_b thinks you had a completion failure there
18:06:18 <ricky_clarkson> So do I, alexj.
18:06:29 <allbery_b> :)
18:09:08 <alexj> ricky_clarkson: not sure I follow.  you removed xsl from which app?
18:11:32 <ricky_clarkson> One I wrote.  I converted between old save formats using it.
18:15:17 <Haru> what is "in " in haskell
18:15:49 <conal> is there a standard type of rose trees with labels per item and a different label type for subtree list?
18:16:00 <conal> i.e., data LTree c a = TreeItem a | TreeChildren n [ LTree c a]
18:16:19 <conal> s/n/c
18:16:34 <mlh> Haru: scope
18:16:41 <mlh> > let n = 4 in n + 5
18:16:42 <lambdabot>  9
18:17:14 <Haru> mlh: ok
18:17:38 <mlh> > let n = x in n + 5
18:17:38 <lambdabot>   Not in scope: `x'
18:17:47 <mm_freak> > let x = 1 + 1 where 1 + 1 = 3 in x
18:17:48 <lambdabot>  3
18:18:23 <mlh> > let x = 4 in n + 5
18:18:24 <lambdabot>   Not in scope: `n'
18:18:46 <Haru> 3?
18:18:47 <mlh> mm_freak: heh, don't confure the poor chap
18:18:50 <mlh> cnofuse
18:18:50 <Haru> now i am confused
18:18:51 <Haru> :S
18:18:58 <mm_freak> confuse =)
18:19:06 <mm_freak> hehe
18:19:42 <mlh> mm_freak: has that been acknowledged as a bug to fixed?
18:20:13 <mm_freak> Haru: read "let X in Y" as: "Y, where X"
18:20:31 <mm_freak> > let x = 4 in x^2
18:20:33 <lambdabot>  16
18:20:35 <mlh> @source in
18:20:35 <lambdabot> in not available
18:20:40 <mm_freak> x^2, where x = 4
18:20:43 <Haru> ok
18:20:57 <Haru> so this is correct ? secsToWeeks secs = let perWeek   = 7 * 24 * 60 * 60 in secs * perWeek
18:20:58 <oerjan> mlh: what bug? he is just redefining the + operator completely legally :)
18:21:04 <mlh> oh
18:21:18 <mlh> thats .... sneaky
18:21:39 <mm_freak> Haru: it's correct (though somewhat ugly)
18:22:02 <Haru> higs gives me  Syntax error in input (unexpected `=')
18:22:06 <Haru> hugs*
18:22:15 <sorear> hugs is buggy
18:22:17 <alexj> ricky_claskson: so you used xsl2 instead of 1 or something else entirely?
18:22:35 <mlh> ghci gives the same error
18:22:38 <mm_freak> Haru: it works well in GHC
18:22:39 <mlh> Haru: ask lambdabot
18:22:53 <mm_freak> Prelude> let secsToWeeks secs = let perWeek   = 7 * 24 * 60 * 60 in secs * perWeek
18:22:53 <mlh> > secsToWeeks secs = let perWeek   = 7 * 24 * 60 * 60 in secs * perWeek
18:22:53 <lambdabot>  Parse error
18:22:56 <mm_freak> Prelude> secsToWeeks 14
18:22:58 <mm_freak> 8467200
18:23:24 <mlh> > let secsToWeeks secs = let perWeek   = 7 * 24 * 60 * 60 in secs * perWeek
18:23:24 <lambdabot>  Parse error
18:23:40 <oerjan> Haru: hugs doesn't allow you to define things interactively.
18:23:41 <mm_freak> > let secsToWeeks secs = let perWeek   = 7 * 24 * 60 * 60 in secs * perWeek in secsToWeeks 14
18:23:44 <lambdabot>  8467200
18:23:48 <Haru> oerjan: ah,
18:24:22 <oerjan> ghci has limits there, too, but it allows let ... = ...
18:25:35 <mm_freak> the only limitation is that previous definitions are lost upon defining something
18:25:45 <oerjan> both allow let ... in ..., but that doesn't save the definition for later.
18:26:03 <mm_freak> so you can't just write:
18:26:05 <mm_freak> Prelude> let 2 + 2 = 5
18:26:05 <mm_freak> Prelude> let 3 + 3 = 7
18:26:17 <mm_freak> the second defintion overwrites the first one
18:26:25 <oerjan> by limitations i mean no data type definitions, etc.
18:26:42 <sorear> mm_freak: that's not a case of old definitions being list
18:26:45 <Olathe> > let 2 + 2 = 2 + 2 in 2 + 2
18:26:47 <lambdabot>  Exception: <<loop>>
18:27:01 <sorear> mm_freak: that's a case of "two things named '+' are in scope, which do I use?"
18:27:41 <alexj> allberry_b: completion failure?
18:28:00 <mm_freak> sorear: then where is the first definition of (+) gone after writing the second one?
18:28:08 <mm_freak> i presume it's lost
18:28:19 <sorear> mm_freak: it's still there, but + refers to the second
18:28:28 <oerjan> mm_freak: it will still be used by any other things that used it in between.
18:28:39 <mm_freak> theoretically it's there, but you can't access it
18:28:53 <sorear> mm_freak: try 'let x = 2' 'let y = 3' 'x' in ghci
18:29:04 <sorear> mm_freak: x stays after y is defined
18:29:19 <mm_freak> oerjan: that's true
18:29:26 <sorear> mm_freak: this is basic lexical scoping, same as scheme, etc
18:29:28 <Olathe> > let 2 + 2 = 2 + 2 in 2 + 3
18:29:29 <lambdabot>   Non-exhaustive patterns in function +
18:29:33 <Olathe> Heh
18:30:06 <mm_freak> sorear: that's not what i mean…  if you redefine something, which was defined earlier in the same module, then the earlier definition is lost
18:30:40 <mm_freak> that wouldn't be the case for non-interactive source code, where the later definition extends the earlier instead of overwriting it
18:30:41 <sorear> mm_freak: losing something, and losing the name for something, are not the same
18:30:52 <mm_freak> true indeed
18:31:08 <mm_freak> but still not what i mean =)
18:31:11 <oerjan> mm_freak: actually extension only happens if the lines are consecutive
18:31:14 <sorear> mm_freak: you seem to be under the impression that if you define x, and then define y, the definition of x will be lost
18:31:27 <sorear> mm_freak: if this is not the case, tell me so I can stop correcting you :)
18:32:01 <mm_freak> sorear: no, i'm in the impression that "let x = …; let x = …" in interactive mode means something completely different than "x = …; x = …" in source code
18:32:15 <sorear> mm_freak: oh, that's correct
18:32:34 <mm_freak> <oerjan> mm_freak: actually extension only happens if the lines are consecutive ⇐ really?
18:33:00 <oerjan> i am pretty sure of that.
18:33:47 <Syzygy-> You can, though, do "let x a = ...; x b = ..." in interactive.
18:33:54 <Syzygy-> As long as you really do ; and not \n
18:33:55 <oerjan> > let f 'a' = 1; g = 2; f 'b' = 3 in "whatever"
18:33:56 <lambdabot>      Conflicting definitions for `f'
18:33:57 <lambdabot>     In the binding group for: f, g, f
18:34:11 <Syzygy-> Ooooh, never tried that.
18:34:23 <mm_freak> oerjan: you seem to be right
18:34:30 <mm_freak> foo 1 = 5
18:34:30 <mm_freak> bar 2 = 4
18:34:30 <mm_freak> foo 2 = 3
18:34:31 <Syzygy-> > let f 'a' = 1; f 'b' = 2 in "whatever"
18:34:32 <mm_freak> won't compile
18:34:33 <lambdabot>  "whatever"
18:35:21 <mm_freak>     Multiple declarations of `Main.foo'
18:35:58 <mm_freak> whatever, good night, friends =)
18:40:59 <Hrumph> is there a way to do restricted exectuion in haskell ?
18:41:19 <Hrumph> oh wait i already asked
18:41:21 <Hrumph> sorry
18:43:28 <wli> I never did finish writing CPO-STV. I think I got bogged down in Meek's method.
18:48:30 <Saizan> using ffi i get a Segmentation Fault, is there some way to know when is this happening?
18:49:53 <balodja> Are there any built-in functions in ghc, that do input/output(ie putStr, getLine etc) considering locale settings and doing character recodings?
18:51:08 <monochrom> Not yet. But do try the "encoding" package.
18:54:42 <|Paczesiowa|> infrared: neo mi sie resetnelo i stara sesja nie chce zgasnac i nie moge sie na konto zalogowac i uzywac priva
18:56:34 <chessguy> hm, italian?
18:56:43 <olsner> looks more slavic
18:57:10 <Adamant> I'm guessing Polish
18:57:38 <|Paczesiowa|> polish, sorry for that, it's just I lost connection, but old session looks alive to freenode so I can't login on my nickname and use priv
18:58:02 <olsner> a google search for "konto zalogowac i uzywac" returned .pl urls, and urls with poland in it ;-)
18:58:06 <Adamant> both because it looks Polish and the guy is from .pl, which is a strong clue. :)
18:58:45 <olsner> ooh, clever! just look at the whois ;-)
18:59:00 <|Paczesiowa|> could some op kick my old session/avatar/whatever it's called?
18:59:09 <shapr> use nickserv
18:59:27 <Pseudonym> Are you registered, Paczesiowa?
18:59:35 <allbery_b> he's an n= so I'd guess so
18:59:42 <Pseudonym> There you go.
18:59:50 <oerjan> i don't think n= has anything to do with that
19:00:08 <allbery_b> hm, I didn't become n= until I registered
19:00:18 <oerjan> oh?
19:00:20 <|Paczesiowa|> I can't register because I can't even change my nickna,e
19:00:30 <Haru> oerjan: how does span ((==0).head) m work?
19:00:43 <Olathe> |Paczesiowa|: Wait a bit and it will fix it.
19:00:47 <oerjan> i don't _think_ you need to register to ask nickserv to kick your old nick
19:00:53 <Pseudonym> An op won't help you, BTW.
19:01:01 <Pseudonym> We could kick the user off the channel, but they'd still be on freenode.
19:01:17 <SamB_XP> |Paczesiowa|: are you in a channel where you can't say anything?
19:01:22 <oerjan> @unpl (==0).head
19:01:23 <lambdabot> (\ d -> (head d) == 0)
19:01:23 <Pseudonym> Incidentally, this "n=" stuff...
19:01:24 <SamB_XP> if so, exit it before trying to change nick
19:01:37 <Pseudonym> There really should be a document of the form "so you've just got op privileges..."
19:01:39 <allbery_b> /msg niockserv ghost correctnick password
19:01:50 <Pseudonym> I've looked, but there's nothing like that.
19:01:53 <allbery_b> asuming you spell nickserv right, unlike my finfers :)
19:01:57 <Pseudonym> All these little things should be documented somewhere.
19:02:03 <infrared> |Paczesiowa|: no problem, i can wait :)
19:02:23 <SamB_XP> oh, that's what you meant ;-)
19:02:37 <Paczesiowa> allbery_b: tx:>
19:02:58 <allbery_b> you're welcome
19:05:38 <Haru> @unpl case
19:05:38 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
19:05:46 <Haru> @case
19:05:47 <lambdabot> Maybe you meant: ask paste
19:06:05 <oerjan> > span ((==0).head) [[0,1,2],[0,2,3],[3,0,1],[2,2,4]]
19:06:08 <lambdabot>  ([[0,1,2],[0,2,3]],[[3,0,1],[2,2,4]])
19:06:17 <oerjan> Haru: case is syntax
19:06:33 <oerjan> @src span
19:06:33 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:07:26 <oerjan> like a switch in C-like languages, if you know that
19:07:30 <Haru> yeah
19:07:41 <Haru> but then span made no changes to list
19:07:57 <oerjan> you're not looking closely :)
19:08:05 <oerjan> it's a tuple of two lists
19:08:06 <SamB_XP> there are no changes
19:08:11 <Haru> ohh yeah
19:08:25 <SamB_XP> there are only new lists!
19:08:29 <Olathe> It's so dirty, though.
19:08:56 <oerjan> Olathe: huh? :)
19:09:16 <Olathe> The ASCII porn.
19:09:42 <oerjan> the first part goes on as long as the head of the element lists are 0
19:09:55 <Olathe> I know ;)
19:10:13 <oerjan> so the second part, if empty, starts with the first row whose head is nonzero
19:10:25 <oerjan> Olathe: i'm talking to Haru :)
19:10:33 <Olathe> Oh.
19:10:47 <oerjan> but you're welcome to listen in
19:12:11 <Haru> effectively u make calculations only on rows with first element non zero
19:12:49 <oerjan> yep. well, there could be some with zeros in the second part too, after the first.
19:13:31 <Haru> span ((==0).head) [[0,1,2],[0,2,3],[3,0,1],[2,2,4],[0,1,3]]
19:13:46 <oerjan> you need "> "
19:13:47 <Haru> the bot wont do calculations for me T_T
19:13:50 <Haru> ohh
19:13:53 <Haru> >span ((==0).head) [[0,1,2],[0,2,3],[3,0,1],[2,2,4],[0,1,3]]
19:13:59 <oerjan> including the space
19:14:00 <TSC> With a space
19:14:00 <Haru> > span ((==0).head) [[0,1,2],[0,2,3],[3,0,1],[2,2,4],[0,1,3]]
19:14:06 <Haru>  > span ((==0).head) [[0,1,2],[0,2,3],[3,0,1],[2,2,4],[0,1,3]]
19:14:12 <lambdabot>  ([[0,1,2],[0,2,3]],[[3,0,1],[2,2,4],[0,1,3]])
19:14:16 <Haru> eayy
19:14:17 <Haru> finally
19:14:18 <oerjan> not at the very beginning though
19:14:32 <oerjan> i think lambdabot was just slightly slow there
19:14:34 <Haru> either the bot lagged or it was too slow :)
19:15:28 <oerjan> there is a function partition that would put _all_ the rows with zero in the first part if used that. but that would mess up the sign of the determinant.
19:15:36 <oerjan> *if i used
19:16:29 <Haru> oerjan: u can always ignore sign if u can figure out the flipping of the matrix
19:16:30 <TSC> So it would be to the detriment of the determinant?
19:17:31 <oerjan> yeah, but that would be more complicated
19:18:05 <oerjan> now all i need for the sign is the number of rows in the first part
19:28:13 <chessguy> are you guys talking about the matrix decomposition code that was sent to -cafe the other day?
19:28:52 <oerjan> no, just a determinant function i wrote
19:29:00 <chessguy> oh ok
19:29:21 <oerjan> http://hpaste.org/2516
19:45:27 <chessguy_> @pl \t -> w s i t
19:45:27 <lambdabot> w s i
19:49:54 <SyntaxNinja> isn't there a Haskell HTTP parser?
19:50:07 <SyntaxNinja> er I mean html
19:50:54 <SyntaxNinja> I guess I can use haxml
19:50:56 <allbery_b> hxt?
19:50:59 <chessguy> so here's a pattern i just learned to recognize recently: x <- f; g x === f >>= g
19:51:02 <allbery_b> or that
19:51:12 <chessguy> i'm wondering if there's a collection of idioms like this somewhere
19:51:34 <allbery_b> @undo do { x <- f ; g x }
19:51:34 <lambdabot> (f >>= \ x -> g x)
19:51:39 <mrd> @src Monad
19:51:39 <lambdabot> class  Monad m  where
19:51:39 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:51:39 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:51:39 <lambdabot>     return      :: a -> m a
19:51:39 <lambdabot>     fail        :: String -> m a
19:51:43 <lament> chessguy: that's not really an "idiom" as much as the definition of how the do notation works.
19:51:48 <allbery_b> @. pl undo do { x <- f ; g x }
19:51:48 <lambdabot> g =<< f
19:52:20 <chessguy> lament, well, technically, the difinition of how do notation works would be to say that it's equivalent to f >>= \x -> g x
19:52:41 <lament> chessguy: before 'do' notation was common, people used the second way of writing that more than the first.
19:52:45 <jcreigh> sure, but \x -> f x === f
19:53:01 <lament> chessguy: yes, and what jcreigh said :)
19:53:07 <chessguy> yes, i'm well aware of that
19:53:23 <chessguy> the point is, it's a pattern that you may or may not recognize, even if you know the theory of how it works
19:53:37 <lament> in fact, before the do notation was even invented, people certainly used the second way a lot :)
19:53:59 <jcreigh> yes, I've done that too: Have a kind of "ah-ha!" moment which is obvious in retrospect.
19:54:14 * allbery_b does that a lot
19:54:18 <chessguy> i mean, normally you certainly wouldn't particularly want to desugar it
19:54:36 <lament> jcreigh: i've had that when i added 2 and 2 on my fingers to get 4 :D
19:54:51 <chessguy> anyway, i just wonder if there's a collection of these patterns somewhere
19:55:02 <chessguy> or should be
19:55:30 <lament> i think every single description of do notation that i've seen had mentioned that sometimes not using the do notation is more convenient and that you should be aware of what >> and >>= do
19:55:34 <nburlett> gah.. why does the CalendarTime constructor take so many fscking arguments?
19:55:48 <chessguy> lament, you're mising the point
19:55:53 <lament> nburlett: second system effect? :)
19:55:55 <chessguy> and i'm missing an s
19:56:09 <nburlett> lament: possiblye
19:56:18 <lament> chessguy: not really, because your "pattern" is simply >>=, which is a Prelude function. Is there a list of prelude functions? Yes.
19:56:35 <nburlett> I think last time I ran into this I installed the date parser library
19:57:17 <chessguy> no, the pattern is what you said before, thinking about if/when we should do the desugaring ourselves
19:58:08 <nburlett> yeah, not using do is often more convienent
19:58:19 <nburlett> (not that I saw the rest of this converastion)
19:58:49 <chessguy> nburlett, and there are probably other similar patterns for making code shorter and more elegant
19:59:13 <nburlett> chessguy: almost certainly true
19:59:26 <Saizan> like do x <- m; return (f x) == m >>= return . f == liftM f m?
20:00:04 <chessguy> good one, Saizan
20:00:08 <shachaf> chessguy: I think this particular case is easy to see once you start to lose the distinction between do-notation and the desugared form.
20:00:11 <nburlett> gah.. I tried to parse that as a single hskell staement, and my brain exploded
20:00:33 <shachaf> chessguy: Since this would be quite easy to see, if it was desugared.
20:00:45 * shachaf prefers f <$> m.
20:01:06 <chessguy> shachaf, yes, i'm thinking more of the intermediate haskell programmer who hasn't quite gone the whole way down the rabbit whole yet
20:01:10 <Saizan> ?src liftM
20:01:11 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:01:19 <nburlett> hm... so does that mean that :    count 4 digit >>= return . read ==> liftM read $ count 4 digit ?
20:01:23 <mrd> @hoogle CalendarTime
20:01:24 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
20:01:24 <lambdabot> System.Time.CalendarTime :: data CalendarTime
20:01:24 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
20:01:40 <shachaf> nburlett: Or read <$> count 4 digit.
20:01:44 <Saizan> nburlett: yes
20:01:55 <mrd> hm I've only used Data.Time.*
20:01:55 <chessguy> nburlett, looks good to me
20:01:59 <nburlett> cool, I need to remember liftM more often
20:02:05 <chessguy> don't we all :)
20:02:14 <nburlett> @hoogle Data.Time
20:02:14 <allbery_b> aka fmap
20:02:14 <lambdabot> No matches, try a more general search
20:02:22 <jcreigh> I tend to view `liftM` as a monadic $
20:02:23 * allbery_b forgets that one a lot as well
20:02:42 <jcreigh> liftM = fmap, right?
20:02:45 <allbery_b> it's one of the things I'm trying to focus on currently
20:02:54 <allbery_b> should be but not always is
20:03:09 <chessguy> jcreigh, yes, but fmap is more general
20:03:11 <nburlett> mrd: does Data.Time handle dates?
20:03:13 <byorgey> shachaf: technically, <$> is only the same as liftM if the Monad is a Functor
20:03:21 <mrd> Data.Time.Calendar etc
20:03:22 <byorgey> which *should* always be the case...
20:03:53 <shachaf> byorgey: Yes.
20:03:55 * nburlett didn't know that Data.Time.Calendar even existed
20:03:57 <shachaf> byorgey: And yes.
20:04:06 <shachaf> What Monad isn't a Functor?
20:04:08 <Paczesiowa> :t (<$>)
20:04:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:04:23 <olsner> (... and if the respective instances have sensible implementations)
20:04:37 <mrd> ghc 6.6.1 has an even better date library now
20:04:46 <byorgey> shachaf: none that I know of, my point is that the Monad type class doesn't require it.
20:04:56 <Haru> oerjan: could u please rewrite the determinant w/o the check on 0s
20:04:59 <shachaf> Yes, but it should. :-)
20:05:05 <byorgey> shachaf: agreed. =)
20:05:15 <hpaste>  chessguy pasted "hmm, i think this code needs some undiselegantizing" at http://hpaste.org/2774
20:05:26 <jcreigh> at the end of the day, everything is just fancy function composition.
20:05:37 <chessguy> hpaste, paste?
20:05:42 <chessguy> hpaste, url?
20:05:42 <hpaste> Haskell paste bin: http://hpaste.org/
20:05:52 <chessguy> hpaste, url
20:05:52 <hpaste> Haskell paste bin: http://hpaste.org/
20:06:01 <chessguy> i think she's down
20:06:09 <byorgey> chessguy: ?
20:06:13 <chessguy> !paste
20:06:13 <hpaste> Haskell paste bin: http://hpaste.org/
20:06:24 <chessguy> glguy, ping
20:06:41 <chessguy> http://hpaste.org/2774
20:07:17 <chessguy> @bot
20:07:17 <lambdabot> :)
20:07:27 <Saizan> 05:04     hpaste :  chessguy pasted "hmm, i think this code needs some undiselegantizing" at http://hpaste.org/2774
20:07:37 <Saizan> chessguy: uh? ^^^
20:07:42 <nburlett> mrd: Data.Time doesn't seem to have a good way of taking "20070101" and turning it into Jan 1, 2007.... or am I missing something?
20:08:33 * chessguy sighs
20:08:44 <Giraph> you're missing slashes
20:08:46 <mrd> fromGregorian 2007 1 1
20:08:50 <pjd> byorgey: if you have a Monad that doesn't provide Functor, there is always WrappedMonad
20:08:52 <byorgey> chessguy: instead of the explicit recursion, wouldn't it be nicer to remove the interchangeRows (k-1) and just do a mapM over [k,(k-1)..0]?
20:09:16 <nburlett> mrd: ah, neat
20:09:19 <pjd> so there shouldn't ever be a problem, really
20:09:34 <mrd> ghc 6.6.1 has a ParseTime class or something, dual to FormatTime.  i haven't used it.
20:09:56 <pjd> (unless someone declares a Functor that does something completely different than the Monad, but that would just be insane)
20:10:13 <chessguy> ok, that was freaking wierd
20:10:33 <chessguy> apparently my comments were going through, but i wasn't seeing what anyone else was saying
20:11:00 <nburlett> chessguy: I can't see what you're saying either .... (^_^)
20:11:01 <shachaf> parseTime defaultTimeLocale "%Y%m%d" "20070710" :: Maybe Day -- Just 2007-07-10
20:11:16 <nburlett> shachaf: cool
20:11:47 <chessguy> nburlett, huh?
20:11:47 <shachaf> The Glorious Glasgow Haskell Compilation System, version 6.7.20070913
20:11:51 <byorgey> pjd: I'm not familiar with WrappedMonad, but I assume you mean something which simply implements fmap using >>= and return?
20:11:57 <nburlett> chessguy: nevermind.. was an atempt at humor
20:12:16 <byorgey> chessguy: hehe, I kind of figured that's what was happening
20:12:23 <pjd> byorgey: well, fmap specifically with liftM, but yeah
20:12:39 <hpaste>  ?botsnack pasted "Just a test" at http://hpaste.org/2775
20:12:39 <byorgey> pjd: oh, right, ok
20:12:46 <pjd> pure with return, <*> with ap, and so on
20:12:46 <nburlett> hm.. 6.6 doesn't have it, does it
20:12:49 <Pseudonym> Nope, didn't trigger lambdabot.
20:12:59 <shachaf> hpaste adds a space.
20:13:00 <nburlett> > parseTime defaultTimeLocale "%Y%m%d" "20070710" :: Maybe Day
20:13:01 <lambdabot>   Not in scope: type constructor or class `Day'
20:13:02 <Pseudonym> Yeah.
20:13:11 <nburlett> > parseTime defaultTimeLocale "%Y%m%d" "20070710"
20:13:12 <lambdabot>   Not in scope: `defaultTimeLocale'
20:13:16 <chessguy> and yes, byorgey the mapM thing is along the lines of what i was thinking, except i think i want mapM_, right?
20:13:23 <nburlett> > Data.Time.Format.parseTime defaultTimeLocale "%Y%m%d" "20070710"
20:13:23 <lambdabot>   Not in scope: `defaultTimeLocale'
20:13:25 <pjd> byorgey: it's in Control.Applicative
20:13:40 <glguy> chessguy: ?
20:13:45 <chessguy> glguy, sorry
20:13:47 <chessguy> never mind
20:13:54 <byorgey> chessguy: oh, right, mapM_, yeah
20:14:03 <Haru> oerjan: also the det evalutes to 0 all the time :S
20:14:05 <shachaf> defaultTimeLocale is in System.Locale.
20:14:36 <chessguy> byorgey, i'm more puzzled about the read/write lines. there's got to be a way to do that better, but i'm not sure
20:14:38 <shachaf> I don't think lambdabot has that.
20:14:51 <Haru> anyone here can help me with a determinant program in haskell?
20:15:01 <byorgey> chessguy: I don't know how to make the rest more elegant... the swapping makes it tough
20:15:10 * nburlett installs 6.6.1
20:15:43 <chessguy> if readArray weren't state-changing, it would be easy
20:16:02 <chessguy> but then there wouldn't be much point in making multiple calls to it :)
20:17:21 <oerjan> Haru: evaluates to 0? what did you test it with?
20:17:42 <chessguy> so essentially we have: readArray >>= \ajk -> readArray >>= \aik -> writeArray ajk >> writeArray aik
20:17:56 <oerjan> also, the algorithm _requires_ finding a row starting with non-zero element. i cannot remove the search for that.
20:18:25 <chessguy> @. unpl pl readArray >>= \ajk -> readArray >>= \aik -> writeArray ajk >> writeArray aik
20:18:25 <lambdabot> (\ e -> readArray >>= \ n -> ((readArray >>= writeArray) e) >> (writeArray n))
20:20:02 <oerjan> Haru: btw in case you didn't notice, the _first_ version of the function on hpaste is buggy.  use the third version which i just pasted.
20:23:20 <oerjan> and do remember that only square matrices have determinants
20:23:42 * lambdabot clubs baby korollaries
20:27:18 <chessguy_> wow, i'm butchering this program
20:27:29 <shachaf> lambdabot: Wrong channel.
20:28:07 <OceanSpray> chessguy, can I get the ribs?
20:28:34 <ChilliX> If you are in .au, check this out: http://haskell.org/haskellwiki/OzHaskell
20:28:35 <lambdabot> Title: OzHaskell - HaskellWiki
20:29:56 <hpaste>  oerjan annotated "determinant attempt" with "Added sanity check" at http://hpaste.org/2516#a3
20:30:22 * sorear wonders about Oz...
20:31:06 <sioraiocht> > read "4" :: CInt
20:31:08 <lambdabot>   Not in scope: type constructor or class `CInt'
20:31:20 <sioraiocht> > read "4" :: Foreign.C.CInt
20:31:21 <lambdabot>      Not in scope: type constructor or class `Foreign.C.CInt'
20:31:35 <sorear> sioraiocht: nothing under Foreign is imported
20:31:43 <sorear> sioraiocht: that's how afraid dons is
20:31:48 <sioraiocht> sorear: oh, damn, lol
20:31:51 <sorear> sioraiocht: (of Foreign.unsafePerformIO)
20:32:04 <sioraiocht> that's understandable, imo
20:32:43 <chessguy> @hoogle writeArray
20:32:43 <lambdabot> Data.Array.MArray.writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
20:34:15 <Haru> oerjan: det [[3,2],[3,9]]
20:35:10 <oerjan> gives 21 here (btw, new version which checks for square matrix)
20:35:46 <Haru> newversion?
20:35:51 <oerjan> http://hpaste.org/2516#a3
20:36:20 <oerjan> but it doesn't remove the check for 0, since that is necessary
20:37:10 <hpaste>  chessguy annotated "hmm, i think this code needs some undiselegantizing" with "not much improvement" at http://hpaste.org/2774#a1
20:37:44 <Haru> oerjan: det [[1,3],[9,11]]
20:37:44 <Haru> (-16) % 1
20:37:46 <Haru> :S
20:38:26 <oerjan> which is correct as far as i know
20:39:18 <Haru> why does it come as %1?
20:39:30 <oerjan> it does exact arithmetic with rationals
20:39:56 <nburlett> @hoogle liftM
20:40:00 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
20:40:00 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
20:40:00 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
20:40:05 <chessguy> @pl \ajj -> w (ajj == 0) $ e e'
20:40:05 <lambdabot> ($ e e') . w . (0 ==)
20:40:10 <oerjan> you could try removing the type annotation but it may be unstable with Doubles
20:40:49 <oerjan> the original question that made me write that function was about determinants of rationals.
20:41:05 <oerjan> *rational matrices
20:41:16 <Haru> why do you need to divide?
20:41:20 <Haru> xs' = map (/x) xs i.e.
20:42:00 <oerjan> i need to subtract multiples of that row from the others so they start with 0
20:42:09 <Haru> ohh u are doing gaussean
20:42:16 <Haru> i thought u were using cofactors
20:42:23 <Haru> and hence i was confused all this while :@
20:42:28 <oerjan> ah :D
20:42:40 <Haru> makes a lot more sense now
20:44:17 <oerjan> nah, there's just one cofactor at the end, after reduction
20:45:23 <Haru> i was trying for a normal n cofactor algo
20:45:32 <Haru> gaussean is good tho
20:45:39 <Haru> more efficient
20:45:55 <oerjan> yeah, that was the idea
20:46:26 <oerjan> cofactor would be exponential on large matrices
20:46:56 <oerjan> (not that exact rational arithmetic doesn't have size problems)
20:50:07 <hpaste>  haru pasted "(no title)" at http://hpaste.org/2776
20:50:18 <Haru> oerjan: whats wrong with http://hpaste.org/2776
20:50:30 <Haru> ehh.. hpaste spams :@
20:51:11 <oerjan> that's the idea
20:51:29 <oerjan> are you getting syntax errors?
20:51:34 <TSC> The indentation looks a bit messed up
20:51:48 <Haru> oerjan: yeah
20:51:53 <Haru> just taht :S
20:52:00 <glguy> hpaste spam?
20:52:12 <Haru> glguy: dint know hpaste would announce
20:52:22 <TSC> There's an "announce" button!  (:
20:52:58 <Haru> there is ?
20:53:01 <Haru> musta missed it
20:53:15 <Haru> now i see
20:53:28 <Haru> oerjan: that cos of indentation?
20:53:44 <hpaste>  oerjan annotated "(no title)" with "corrected indentation" at http://hpaste.org/2776#a1
20:54:00 <oerjan> try that
20:54:21 <Haru> eayy
20:54:23 <Haru> works
20:55:37 <oerjan> definitions within a let or where must be lined up
20:55:55 <oerjan> and everything within must be indented more
20:56:00 <oerjan> (also top level)
20:57:12 <oerjan> *everything within each definition
20:57:16 <Haru> apparantly haskell cannot be learnt just by looking at code
20:57:34 <shapr> Bah, I disagree!
20:57:55 <Haru> i fail :'(
20:58:05 <shapr> Just keep working at it!
20:58:11 <sjanssen> can you *really* learn any language just by looking at code?
20:58:30 <shapr> Hm, probably not. I think you have to write code of your own and that sort of stuff.
20:59:29 <pjd> sjanssen: people learn languages just by hearing them spoken
20:59:35 * pjd ducks
20:59:36 <oerjan> Haru: any way there are four keywords in haskell that start indentation blocks: let, where, do and of
20:59:55 <sjanssen> pjd: I'd think computer languages are a bit different, maybe not
21:00:08 <oerjan> after those you need to line up things
21:00:46 <_fang> hello! can i get just a quick explanation? What does the "Ord" means here? menor :: Ord a => [a] -> a
21:00:56 <_fang> sorry for the totally noob question =]
21:01:06 <sjanssen> _fang: short for "Ordered"
21:01:10 <oerjan> _fang: elements of the type a must be comparable
21:01:13 <pjd> _fang: informally, "a is an ordered/comparable type"
21:01:16 <oerjan> @src Ord
21:01:17 <lambdabot> class  (Eq a) => Ord a  where
21:01:17 <lambdabot>     compare      :: a -> a -> Ordering
21:01:17 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
21:01:17 <lambdabot>     max, min         :: a -> a -> a
21:01:23 <sorear> a TOTALLY ordered type
21:01:25 <Haru> sjanssen: u can learnt most languages if u know C just by reading and writing code of ur own
21:01:33 <Haru> or atleast go modifying them
21:01:49 <Haru> with haskell however C experience just fails :P
21:01:51 <_fang> okie dokie! thank you very much =D
21:02:24 <sorear> Haru: You can live with the redundancies in C programming?  Braces AND whitespace?
21:02:29 <oerjan> Haru: haskell slightly predates the total hegemony of C-like syntax
21:02:52 <Haru> lol
21:02:55 <sorear> Haskell was also designed to be pretty
21:03:05 <Haru> u mean mathmatical
21:03:09 <pjd> _fang: more formally, it reads "for any Ord instance a, menor has type [a] -> a"
21:03:34 <sorear> No, I mean pretty.
21:03:56 <Adamant> you mean mathematical
21:04:04 <pjd> sorear: some bits aren't so pretty
21:04:05 * Adamant ducks
21:04:47 <_fang> @src length
21:04:48 <lambdabot> Source not found. Take a stress pill and think things over.
21:06:09 <Haru> @length
21:06:09 <lambdabot> Unknown command, try @list
21:06:13 <Haru> @list
21:06:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:06:14 <oerjan> length            = foldl' (\n _ -> n + 1) 0
21:06:42 <_fang> thanks oerjan
21:06:49 <Haru> \n _ -> looks more like a smiley than code
21:07:18 <oerjan> it's a lambda expression
21:07:22 <oerjan> @quote korean
21:07:23 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
21:07:30 <Haru> lmao
21:07:47 <_fang> lol
21:08:01 <ricky_clarkson> Haru: I can't parse anything with spaces in as a smiley.
21:08:30 <Haru> upgrade?
21:09:13 <oerjan> > (\()_()->"ORLY?")()()()
21:09:15 <lambdabot>  "ORLY?"
21:09:30 <Haru> YARLY
21:10:14 <FMota> gnarly
21:16:36 <conal> i forget the command to compress executables.  strip + ??.  anyone know?
21:19:44 <hpaste>  oerjan annotated "hmm, i think this code needs some undiselegantizing" with "undiselegantized enough?" at http://hpaste.org/2774#a2
21:20:36 <conal> oh -- gzexe.  wow -- strip + gzexe reduces my ghc exe from 10MB to 1MB
21:22:55 <Mr_Awesome> is graphicsutils an old lib or somethign?
21:23:14 <wli> I wonder how intelligent it is wrt. dynamic linking.
21:26:32 <Weremanatee> So I have this list that represents the vertices of a polygon, but I want to traverse the polygon in left-to-right order rather than clockwise or counterclockwise. In something like C, I would just make an array of vertex pointers to index the original array. What's the best way to accomplish this in Haskell?
21:28:17 <sjanssen> Weremanatee: just run sort on the list?
21:28:40 <Weremanatee> But I also want to retain the original list for reference while I work on the sorted list.
21:29:02 <sjanssen> keep the original list around too?
21:29:07 <Weremanatee> if I pass both lists, I have to !! into the original list, which seems less than efficient.
21:29:24 <sjanssen> ah, you need to access the clockwise ordering at the same time
21:29:29 <Weremanatee> right-o
21:30:17 <oerjan> well for fast access you want to keep the original in an array
21:30:22 <liyang> Why do you need to !! into the original list?
21:30:30 <ChilliX> Weremanatee: Why not use arrays in Haskell, too?
21:30:36 <oerjan> so sort the indices by the coordinates
21:31:17 * liyang finds arrays very unidiomatic.
21:31:37 <Cale> nah, they're just finitemaps :)
21:31:54 <ChilliX> arrays are a data type, good for some algorithms, bad for others - I would call them (un)idiomatic.
21:31:55 <_fang> what would be the type for this function? "media = foldl (+) 0 / foldl (\n _ -> n + 1) 0"
21:32:18 <oerjan> :t foldl (+) 0 / foldl (\n _ -> n + 1) 0
21:32:18 <sjanssen> _fang: type error, probably
21:32:20 <lambdabot> forall a. (Num a, Fractional ([a] -> a)) => [a] -> a
21:32:21 <ChilliX> And standard Haskell array processing is well integrated with list processing.
21:32:33 <Cale> _fang: that's likely going to cause a type error
21:32:57 <ChilliX> Weremanatee: http://haskell.org/onlinereport/array.html
21:32:58 <lambdabot> Title: The Haskell 98 Library Report: Arrays
21:33:27 <oerjan> :t \l -> foldl (+) 0 l / foldl (\n _ -> n + 1) 0 l -- maybe you meant this?
21:33:29 <lambdabot> forall a. (Fractional a) => [a] -> a
21:33:42 <sjanssen> Weremanatee: I'd keep my clockwise-ordered list in an array
21:33:54 <Cale> You should be aware that sum and length exist as well
21:34:10 <Cale> though length has a stupid type signature.
21:34:15 <_fang> well. i'm trying to make a function that takes a list and calculate the mean value from it
21:34:15 <sjanssen> Weremanatee: then you can "sort . assocs" the array, which will give you a list of (clockwise ordered position, coordinates)
21:34:21 <Cale> So you'll probably want genericLength
21:34:28 <_fang> it was the closet i got
21:34:41 <Cale> > \xs -> sum xs / genericLength xs
21:34:43 <lambdabot>  <[Double] -> Double>
21:34:44 <Cale> :t \xs -> sum xs / genericLength xs
21:34:45 <lambdabot> forall a. (Fractional a) => [a] -> a
21:35:00 <Cale> > (\xs -> sum xs / genericLength xs) [5,1,6,2,76,3,1,7]
21:35:02 <lambdabot>  12.625
21:35:04 <oerjan> :t liftM2 (/) sum genericLength -- now the weird version
21:35:07 <lambdabot> forall a. (Fractional a) => [a] -> a
21:35:20 <_fang> Cale: i have to "make them by myself" since it was requested at the class
21:35:27 <Cale> _fang: ah
21:35:39 <sjanssen> Weremanatee: oh, you'll actually want to flip the result of assocs around before sorting
21:36:07 <_fang> Cale: and i completely suck in haskell x.x
21:36:27 <Cale> Well, you had a correct sum and length
21:36:39 <Cale> But you can't just divide functions like that
21:37:40 <Weremanatee> ok, thanks a lot
21:37:49 * Weremanatee reads
21:38:22 <_fang> Cale: hmm.. what should i do then?
21:46:20 <FMota> omg awesome
21:46:30 <FMota> reddit in pink tee :)
21:48:19 <FMota> I really want to get one now. :/
21:49:31 * liyang might write uncurry div . foldl (flip ((succ ***) . (+))) (1, 0)
21:49:47 <liyang> :t uncurry div . foldl (flip ((succ ***) . (+))) (1, 0)
21:49:49 <lambdabot> forall b. (Integral b) => [b] -> b
21:49:51 <FMota> :t \h->h h
21:49:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
21:49:52 <lambdabot>     Probable cause: `h' is applied to too many arguments
21:50:03 <FMota> :/
21:50:12 <oerjan> or not :D
21:50:18 <liyang> (or use foldr and get rid of the flip)
21:50:23 <sorear> FMota: types were invented to stop you from doing that
21:50:31 <FMota> meh
21:50:38 <FMota> I can't write my Y combinator.
21:50:41 <FMota> that's annoying.
21:50:45 <sorear> (only later did someone figure out they could also prevent crashes)
21:50:56 <sorear> yeah, that's the whole point
21:51:03 <fax> y f = f (y f)
21:51:16 <sorear> simply-typed lambda calculus CANNOT express any nonterminating function
21:51:16 <FMota> :t (\h -> h h) (\h f. f (h h f))
21:51:18 <lambdabot> parse error on input `.'
21:51:26 <FMota> oops
21:51:30 <sorear> you'll need an extension like let
21:51:38 <sorear> :t \f -> let x = f x in x
21:51:40 <lambdabot> forall t. (t -> t) -> t
21:51:44 <FMota> :t (\h -> h h) (\h f -> f (h h f))
21:51:46 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
21:51:46 <lambdabot>     Probable cause: `h' is applied to too many arguments
21:51:56 <stepcut> FMota: you can do infinite types in ocaml with the -rectypes flag, but it is still unsafe
21:52:17 <dolio> @type ((\h -> h h) :: (forall b. a -> b) -> b
21:52:19 <lambdabot> parse error (possibly incorrect indentation)
21:52:22 <dolio> @type ((\h -> h h) :: (forall b. a -> b) -> b)
21:52:24 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
21:52:24 <lambdabot>            against inferred type `a -> b1'
21:52:37 <FMota> :/
21:52:40 <sorear> stepcut: unsafe?  how'd you get that idea?
21:52:55 * dolio should test in a private chat first...
21:53:02 <FMota> :p
21:53:14 <dolio> @type ((\h -> h h) :: (forall a. a -> b) -> b)
21:53:16 <lambdabot> forall b. (forall a. a -> b) -> b
21:53:31 <dolio> Good luck with the other part. :)
21:53:39 <liyang> > (uncurry (/) . foldr ((Control.Arrow.*** succ) . (+)) (0, 1)) [1,2,3]
21:53:41 <lambdabot>  1.5
21:53:50 <liyang> (Wahey!)
21:54:56 <ricky_clarkson> liyang: All that for the mean of a list?
21:55:19 <sorear> FMota: When you succeed, you will have found a logical paradox valid (via model chains) in the current state of the art logical formalizations, and with a little luck will become as famous as Russel, Cantor, and Burali-Forti.  (if you're lucky)
21:55:22 <oerjan> > liftM2 (/) sum genericLength $ [1,2,3]
21:55:24 <lambdabot>  2.0
21:55:36 * ricky_clarkson checks his maths.
21:55:37 <oerjan> oh, and it was even wrong :D
21:55:38 <FMota> lol. Not likely to haqppen
21:55:40 <FMota> *happen
21:55:45 <FMota> oh, btw
21:55:48 <liyang> ricky_clarkson: only traverses the list once.
21:56:04 <FMota> I have the same birthday (except for year) as Cantor! Isn't that cool? :)
21:56:38 <liyang> > (uncurry (/) . foldr ((*** succ) . (+)) (0, 0)) [1,2,3] -- if you will. The 1 was only there to `prevent' division by zero.
21:56:40 <lambdabot>  2.0
21:57:26 <ricky_clarkson> liyang: I see.  Does that make a difference to performance, or does ghc optimise them to the same thing anyway?
21:57:38 <sorear> liyang: What's the average of []?
21:57:48 * sorear thinks ⊥
21:57:59 <dolio> Nullity, of course.
21:58:08 <sorear> @slap dolio
21:58:08 * lambdabot beats up dolio
21:58:13 <liyang> sorear: in the first instance, 0. The revised version would give 0/0... which as dolio says is nullity. :p
21:58:48 <liyang> ricky_clarkson: not a clue. I always get the feeling GHC's optimisations isn't as advanced as /that/.
21:58:49 <sorear> liyang: I think avg . map (+1) should be equal to (+1) . avg
21:59:40 <sorear> ricky_clarkson: liyang's first version is faster, and vastly more unreadable
21:59:50 <dolio> nullity + a = nullity, according to wikipedia.
22:00:12 <dolio> For all a, I assume.
22:00:14 <liyang> hey, I never claimed readability. Both versions are the same, it's just the `length' of [] that differs.
22:03:24 <FMota> I dont find much (any) use for nullity
22:03:32 <FMota> but I personally like (ln 0)
22:03:43 <oerjan> > ln 0
22:03:50 <lambdabot>   Not in scope: `ln'
22:03:55 <oerjan> > log 0
22:04:00 <lambdabot>  -Infinity
22:04:40 <FMota> A lot more useful than nullity. To begin with, you can make comparisons.
22:06:25 <FMota> Second... I was "inventing" a system of operators that involved logarithms to achieve the next level of operators (i.e. you use exponentiation and logarithms to go from addition to multiplication)
22:06:39 <FMota> it turns out that there was always one number
22:06:48 <FMota> I couldn't quite operate on.
22:07:31 <FMota> and it all stemmed from (log 0)
22:07:48 <FMota> ...as did the fixed points.
22:07:55 <FMota> And I'm officially rambling.
22:11:45 <ari> > (0/0) == (0/0)
22:11:57 <lambdabot>  False
22:11:59 <dolio> False.
22:12:01 <gvdm_other> wow
22:12:05 <gvdm_other> hmm
22:12:09 <gvdm_other> its undefined
22:12:14 <ari> > 0/0
22:12:15 <lambdabot>  NaN
22:12:23 <gvdm_other> is one undefined thing the same as any other undefined thing?
22:12:27 <FMota> > (log 0) == (log 0)
22:12:29 <lambdabot>  True
22:12:31 <FMota> :)
22:12:33 <ari> I was wondering if they're equal because...
22:12:39 <Chris> NaN is defined to be not equal to itself
22:12:40 <ari> > (1/0) == (2/0)
22:12:41 <lambdabot>  True
22:12:45 <FMota> > exp (log 0)
22:12:47 <lambdabot>  0.0
22:12:49 <sjanssen> gvdm_other: 0/0 is not the same as the usual Haskell 'undefined'
22:13:14 <FMota> log (exp 0)
22:13:21 <FMota> > log (exp 0)
22:13:22 <lambdabot>  0.0
22:13:31 <FMota> uhm
22:13:34 <ari> > isNaN (0/0)
22:13:35 <lambdabot>  True
22:13:49 <sjanssen> gvdm_other: 0/0 is actually defined in IEEE floating point
22:13:53 <FMota> Colloquy gives me a funny emoticon everytime lambdabot says that
22:13:55 <FMota> wha.
22:14:05 <gvdm_other> sjanssen: i know, there are actually a few kinds
22:14:07 <FMota> > 1
22:14:08 <lambdabot>  1
22:14:12 <FMota> > 0
22:14:13 <lambdabot>  0
22:14:19 <FMota> > 0.0
22:14:20 <lambdabot>  0.0
22:14:21 <FMota> :/
22:14:24 <dibblego> FMota, you mean 0[dot]0 ?
22:14:25 <gvdm_other> depending on how you set the exponent bits etc
22:14:27 <FMota> that's annoying
22:14:30 <FMota> yep
22:14:42 <FMota> okay
22:14:43 <FMota> ixed :)
22:14:46 <FMota> *fixed
22:14:51 <FMota> now everything looks like text.
22:16:49 <sorear> FMota: have you heard of tetration?
22:17:02 <FMota> sort of
22:17:06 <FMota> I know what it deals with
22:17:12 <FMota> I cant recall the actual definition atm though
22:18:07 <FMota> so, my
22:18:18 <FMota> "level 0" operation was +, obviously
22:18:46 <FMota> level 1 was  \a b -> (a + 1) * (b + 1) - 1
22:19:18 <FMota> not that it matters.
22:34:16 <glguy> ?seen shapr
22:34:17 <lambdabot> shapr is in #haskell-blah, ##logic, #scannedinavian and #haskell. I last heard shapr speak 1h 35m 38s ago.
22:35:39 <dibblego> ?check \x y - > x :: Float + y :: Float == y + x
22:35:40 <lambdabot>  Parse error
22:35:51 <dibblego> ?check \x y - > (x :: Float) + (y :: Float) == y + x
22:35:51 <lambdabot>  Parse error
22:35:59 <dibblego> ?check \x y -> (x :: Float) + (y :: Float) == y + x
22:36:01 <lambdabot>  OK, passed 500 tests.
22:43:51 <FMota> ?check \x y -> (x :: Float) * (y :: Float) + (c :: Float) == c + y * x
22:43:58 <lambdabot>   Not in scope: `c'
22:44:10 <FMota> ?check \x y c -> (x :: Float) * (y :: Float) + (c :: Float) == c + y * x
22:44:15 <lambdabot>  OK, passed 500 tests.
22:58:14 <FMotAFK> nighty night folks
22:59:49 <[TWiSTED]> ive got a function (call it func1) that inputs a list [a] and returns a list of tuples [(a,a)] such that it pairs up the adjacent elements in the list eg. func1 [1 .. 4] = [(1,2),(2,3),(3,4)]. i wanna create another function (call it func2) that uses func1 that inputs and outputs a list [a]. func2 is to remove the adjacent elements that are duplicates, so func2 [1,2,2,3,2,1,1,1,4] would result in [1,2,3,2,1,4]. ive tried using a list c
22:59:59 <[TWiSTED]> hope that all makes sense
23:00:34 <fax> > map (!!0) $ group [1,2,2,3,2,1,1,1,4]
23:00:36 <lambdabot>  [1,2,3,2,1,4]
23:01:14 <oerjan> you mean map head
23:01:49 <vincenz> @type group
23:01:51 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
23:01:55 <[TWiSTED]> what does group do
23:02:05 <vincenz> groups equal items
23:02:10 <Cale> > group [1,2,2,3,2,1,1,1,4]
23:02:11 <lambdabot>  [[1],[2,2],[3],[2],[1,1,1],[4]]
23:02:11 <vincenz> > group [1,1,1,3,3,3,2,2,2,]
23:02:12 <lambdabot>  Parse error
23:02:12 <vincenz> > group [1,1,1,3,3,3,2,2,2,4]
23:02:13 <lambdabot>  [[1,1,1],[3,3,3],[2,2,2],[4]]
23:02:21 <[TWiSTED]> ohh right
23:02:28 <vincenz> @stereo
23:02:28 <lambdabot> Unknown command, try @list
23:02:34 <[TWiSTED]> its a list of tuples tho
23:02:35 <vincenz> @quote stereo
23:02:36 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
23:02:40 <vincenz> equality is equality
23:02:52 <vincenz> > group [(1,1), (1,1), (2,1), (2,2), (2,2)]
23:02:54 <lambdabot>  [[(1,1),(1,1)],[(2,1)],[(2,2),(2,2)]]
23:03:03 <Syzygy-> :t (+++)
23:03:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
23:03:17 <Syzygy-> :t (***)
23:03:18 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:03:54 <Syzygy-> > (head *** length) . group $ [1,1,1,3,3,3,2,2,2,4]
23:03:55 <lambdabot>  Couldn't match expected type `([a], [a1])'
23:04:12 <Syzygy-> :t (&&&)
23:04:13 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
23:04:25 <Syzygy-> > (head &&& length) . group $ [1,1,1,3,3,3,2,2,2,4]
23:04:26 <lambdabot>  ([1,1,1],4)
23:04:32 <Syzygy-> There we are. ... No.
23:04:39 <oerjan> map fst . filter (uncurry (/=)) . zip . (id *** tail) $ [1,2,2,3,2,1,1,1,4]
23:04:41 <Syzygy-> > map (head &&& length) . group $ [1,1,1,3,3,3,2,2,2,4]
23:04:42 <lambdabot>  [(1,3),(3,3),(2,3),(4,1)]
23:04:46 <Syzygy-> There we are!
23:04:47 <oerjan> > map fst . filter (uncurry (/=)) . zip . (id *** tail) $ [1,2,2,3,2,1,1,1,4]
23:04:48 <lambdabot>  Couldn't match expected type `[a]'
23:05:03 <oerjan> > zip . (id *** tail) $ [1,2,2,3,2,1,1,1,4]
23:05:04 <lambdabot>  Couldn't match expected type `[a]'
23:05:11 <vincenz> zip takes two lists..
23:05:21 <oerjan> map fst . filter (uncurry (/=)) . uncurry zip . (id &&& tail) $ [1,2,2,3,2,1,1,1,4]
23:05:28 <oerjan> > map fst . filter (uncurry (/=)) . uncurry zip . (id &&& tail) $ [1,2,2,3,2,1,1,1,4]
23:05:29 <lambdabot>  [1,2,3,2,1]
23:05:35 <oerjan> whoops
23:05:50 <oerjan> > uncurry zip . (id &&& tail) $ [1,2,2,3,2,1,1,1,4]
23:05:50 <[TWiSTED]> can you do it using head and a list comprehension
23:05:52 <lambdabot>  [(1,2),(2,2),(2,3),(3,2),(2,1),(1,1),(1,1),(1,4)]
23:06:36 <[TWiSTED]> yeah thats what func1 does
23:06:44 <Syzygy-> :t funcl
23:06:46 <lambdabot> Not in scope: `funcl'
23:06:55 <[TWiSTED]> which is zip xs (tail xs)
23:08:13 <oerjan> but the other part dropped the final 4. hrm.
23:08:18 <[TWiSTED]> yeah
23:08:49 <[TWiSTED]> can you add like a dummy number at the end to catch the 4
23:09:10 <[TWiSTED]> so itll be [(1,2),(2,2),(2,3),(3,2),(2,1),(1,1),(1,1),(1,4),(4,0)] or 0 can be anything
23:09:39 <oerjan> no - you cannot add anything that can safely be compared with the 4
23:09:48 <[TWiSTED]> ohh yeh true
23:09:54 <oerjan> (without knowing that it is a 4)
23:10:01 <[TWiSTED]> yeh
23:11:07 <oerjan> > uncurry (:) . (fst . head &&& map snd) . filter (uncurry (/=)) . uncurry zip . (id &&& tail) $ [1,2,2,3,2,1,1,1,4]
23:11:09 <lambdabot>  [1,2,3,2,1,4]
23:11:38 <[TWiSTED]> hmm
23:11:46 <[TWiSTED]> is that pretty messy tho
23:11:48 <[TWiSTED]> hehe
23:11:52 <oerjan> that's going to fail on an empty list though
23:11:59 <[TWiSTED]> oh yeh
23:12:02 <oerjan> well, one element too
23:12:08 <dolio> > ap zip tail [1..10]
23:12:09 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
23:12:29 <oerjan> i knew there was a short way for that one
23:20:30 <vincenz> reader monad
23:20:57 <Mr_Awesome> im proud of myself. i just got a 3 year old library built for ghc 5.4 working with ghc 6.6 :)
23:21:01 <tuxplorer> how to get the list of all functions in a module that is currently loaded in ghci
23:21:07 <Mr_Awesome> it took all day though...
23:21:15 <oerjan> tuxplorer: :browse
23:21:26 <tuxplorer> oerjan: Thanks
23:21:33 <dolio> > let prependIf p e [] = [e] ; prependIf p e xs@(x:_) | p e x = e:xs | otherwise = xs in foldr (prependIf (/=)) [1,2,2,3,2,1,1,1,4]
23:21:41 <lambdabot>  <[Integer] -> [Integer]>
23:21:51 <dolio> > let prependIf p e [] = [e] ; prependIf p e xs@(x:_) | p e x = e:xs | otherwise = xs in foldr (prependIf (/=)) [] [1,2,2,3,2,1,1,1,4]
23:21:53 <lambdabot>  [1,2,3,2,1,4]
23:22:51 <[TWiSTED]> [head xs] ++ [y | (x, y) <- func1 xs, x /= y]
23:23:09 <[TWiSTED]> where func1 xs = zip xs (tail xs)
23:23:19 <oerjan> [head xs] ++ = head xs :
23:23:49 <[TWiSTED]> doesnt work for empty list
23:24:00 <oerjan> sure it does
23:24:15 <[TWiSTED]> o i tried it said pattern match failure
23:24:32 <[TWiSTED]> on head []
23:24:35 <oerjan> i mean, those two i wrote are equivalent
23:24:41 <vincenz> neither will work on an empty list
23:24:43 <vincenz> for good reasons
23:25:09 <dibblego> > head [] -- undefined
23:25:11 <lambdabot>  Exception: Prelude.head: empty list
23:25:24 <vincenz> though if it used fail instead of error...
23:25:26 <vincenz> at least yo could do
23:25:29 <vincenz> > [head []]
23:25:31 <lambdabot>  Exception: Prelude.head: empty list
23:25:31 <vincenz> and get an empty list
23:25:41 <oerjan> take 1 xs ++  then
23:25:50 <[TWiSTED]> o yeh
23:26:00 <dibblego> ?hoogle [a] -> a -> a
23:26:01 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
23:26:02 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
23:26:02 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
23:26:03 <conal> what's a simple way to search & replace a regex in a string?  I just want to remove [a-zA-Z]+\.
23:26:22 <[TWiSTED]> yea that works
23:26:27 <[TWiSTED]> thanks oerjan
23:26:27 <dibblego> @let headOr [] x = x; headOr (x:_) _ = x
23:26:29 <lambdabot> Defined.
23:26:34 <[TWiSTED]> and rest
23:26:44 <fax> :t takeWhile
23:26:46 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
23:27:01 <fax> :t member
23:27:03 <lambdabot> Not in scope: `member'
23:27:06 <fax> :/
23:29:04 <oerjan> :t elem
23:29:06 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:29:28 <fax> ah thanks
23:30:17 <fax> > takeWhile (\ch -> elem ch $ ['a'..'z'] ++ ['A'..'Z']) "abZacaBraz.end"
23:30:18 <lambdabot>  "abZacaBraz"
23:30:45 <tuxplorer> None of the functions help me convert the timestamp that is being printed to a string.. Why is let a <- getClockTime invalid?
23:30:57 <oerjan> i think conal's request was a bit more complicated.
23:31:15 <oerjan> @docs Text.RegEx
23:31:16 <lambdabot> Text.RegEx not available
23:31:41 <oerjan> @docs Text.Regex
23:31:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
23:32:16 <oerjan> tuxplorer: you don't use let with <-
23:34:30 <oerjan> use just: a <- getClockTime
23:34:32 <tuxplorer> oerjan: even without it throws error.. *Prelude Time> getClockTime     <outputs> Mon Sep 17 12:02:29 IST 2007*               *Prelude Time> a <- getClocktime    <outputs >    <interactive>:1:5: Not in scope: `getClocktime' *
23:35:12 <oerjan> miscapitalized
23:35:20 <tuxplorer> oops..
23:35:48 <tuxplorer> Ya. Now it works
23:35:52 <oerjan> :)
23:36:30 <[TWiSTED]> is there a function that removes duplicates in a list?
23:36:37 <oerjan> nub
23:36:38 <conal> nub
23:36:39 <TSC> nub
23:36:41 <[TWiSTED]> thanks
23:36:46 <conal> :)
23:36:51 <TSC> nub [nub,nub,nub] = [nub]
23:37:11 <oerjan> > nub [nub,nub,nub] -- actually, no
23:37:12 <lambdabot>   add an instance declaration for (Eq ([a] -> [a]))
23:37:12 <lambdabot>     In the expression: nu...
23:37:29 <TSC> I speak in metaphors (:
23:37:46 <[TWiSTED]> haha
23:38:36 <oerjan> i assume this time you mean nonconsecutive ones
23:38:54 <oerjan> since you already got plenty of the other kind
