00:00:09 <tuxplorer> let a = empty
00:00:09 <tuxplorer> insert "hi" "boo" a
00:00:09 <tuxplorer> when I check a again, its empty. How do I insert the values into a itself?
00:00:28 <tuxplorer> and a = insert "hi" "boo" a hangs
00:00:48 <oerjan> :t Data.Map.insert
00:00:50 <lambdabot> forall k a. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
00:01:07 <oerjan> it _returns_ the updated map.
00:01:20 <oerjan> the original is left as it is.
00:01:22 <Paczesiowa> insertion doesn't really insert (it can't mutate data) it returns new map with isnerted value
00:01:54 <Paczesiowa> let a = empty
00:02:02 <Paczesiowa> let b = inset "hi" "boo" a
00:02:12 <Paczesiowa> b ! "hi"
00:02:17 <tuxplorer> Paczesiowa: then how is it mutable?
00:02:24 <Paczesiowa> it's not mutable
00:02:49 <tuxplorer> is there a mutable version of Map?
00:03:02 <tuxplorer> a Map that uses IO Monad?
00:03:20 <oerjan> you are confusing two things here
00:03:46 <oerjan> changing state is not the purpose of Map.
00:04:26 <oerjan> it just gives you a new value to use with whatever other mechanism you use for state.
00:05:38 <oerjan> for the second, there are several options.
00:05:46 <Paczesiowa> but it can be slow when used with many values, inserting can result in copying log_2 of n keys
00:06:36 <tuxplorer> oerjan: I want to have something where I can insert records in memory, and finally at the end of session, commit it to a db
00:07:01 <oerjan> a State monad may be the most common method
00:07:05 <oerjan> :t modify
00:07:07 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
00:07:51 <tuxplorer> ok
00:08:19 <oerjan> > runState (do modify (Data.Map.insert "hi" "boo")) empty
00:08:20 <lambdabot> Terminated
00:08:30 <oerjan> now what?
00:08:56 <oerjan> :t runState (do modify (Data.Map.insert "hi" "boo")) empty -- must have done something wrong
00:08:58 <lambdabot>     Ambiguous occurrence `empty'
00:08:58 <lambdabot>     It could refer to either `empty', imported from Control.Applicative
00:09:22 <oerjan> :t runState (do modify (Data.Map.insert "hi" "boo")) Data.Map.empty -- must have done something wrong
00:09:24 <lambdabot> ((), Data.Map.Map [Char] [Char])
00:09:44 <oerjan> :t runState (do modify (Data.Map.insert "hi" "boo")) Data.Map.empty
00:09:46 <lambdabot> ((), Data.Map.Map [Char] [Char])
00:09:52 <oerjan> > runState (do modify (Data.Map.insert "hi" "boo")) Data.Map.empty
00:09:52 <lambdabot>   Not in scope: `Data.Map.empty'
00:10:04 <oerjan> what the?
00:10:25 <oerjan> > runState (do modify (M.insert "hi" "boo")) M.empty
00:10:27 <lambdabot>  ((),fromList [("hi","boo")])
00:11:06 <Syzygy-> Could you also do this?
00:11:43 <Syzygy-> > runState (do modify (M.insert "hi" "boo"); modify (M.insert "bye" "goo")) M.empty
00:11:45 <lambdabot>  ((),fromList [("bye","goo"),("hi","boo")])
00:11:48 <Syzygy-> Right.
00:15:30 <oerjan> > runState (do modify (M.insert "hi" "boo"); modify (M.insert "bye" "goo"); gets (! "hi")) M.empty
00:15:31 <lambdabot>  Couldn't match expected type `Array [Char] e'
00:15:41 <oerjan> > runState (do modify (M.insert "hi" "boo"); modify (M.insert "bye" "goo"); gets (M.! "hi")) M.empty
00:15:43 <lambdabot>  ("boo",fromList [("bye","goo"),("hi","boo")])
00:17:24 <Paczesiowa> > foldl (flip (uncurry Data.Map.insert)) Data.Map.empty [("hello","world"),("haskell",".org")]
00:17:25 <lambdabot>   Not in scope: `Data.Map.empty'
00:17:36 <oerjan> just M.
00:17:53 <Paczesiowa> > foldl (flip (uncurry M.insert)) M.empty [("hello","world"),("haskell",".org")]
00:17:55 <lambdabot>  fromList [("haskell",".org"),("hello","world")]
00:18:39 <oerjan> > M.union M.empty $ M.fromList [("hello","world"),("haskell",".org")] -- maybe more efficient for many values
00:18:41 <lambdabot>  fromList [("haskell",".org"),("hello","world")]
00:19:02 <Paczesiowa> > (foldl (flip (uncurry M.insert)) M.empty [("hi","boo"),("bye","goo")]) M.! "hi"
00:19:03 <lambdabot>  "boo"
00:29:23 <exDM69> a noob question: what's the difference between [Char] and String?
00:30:28 <Paczesiowa> none
00:30:29 <oerjan> nothing
00:30:43 <oerjan> @src String
00:30:43 <lambdabot> type String = [Char]
00:31:02 <Paczesiowa> @src curry
00:31:02 <lambdabot> curry f x y = f (x, y)
00:31:22 <oerjan> well, ghc tries to keep the String name around for better error messages.
00:31:40 <oerjan> but for the meaning of the program, nothing.
00:32:01 <Paczesiowa> but it sometimes fails and reports some error about type [Char] -> String
00:46:42 <exDM69> great, thanks!
00:47:00 <exDM69> btw. I have been reading YAHT, but I would like to buy a book on Haskell
00:47:45 <exDM69> any recommendations? I have no prior functional programming experience (apart from the "functional" c++ stuff)  but I have been programming for a while.
00:49:04 <exDM69> or would it be easier to start functional programming using scheme or common lisp or something?
00:50:25 <oerjan> i haven't read any printed books myself, and you seem to have come at a very quite time in the channel
00:50:32 <sjanssen> exDM69: I think Haskell is okay as a first functional language
00:51:08 <exDM69> sjanssen: but the fact that it's typed makes it a bit more complex, right
00:52:18 <sjanssen> sure, Haskell is more complex than Scheme for example
00:52:47 <oerjan> most things are more complex than Scheme.
00:53:05 <sjanssen> I don't think Haskell's type system will cause much difficulty for a C++ guy
00:53:37 <Paczesiowa> what's so complex about type system?
00:54:10 <oerjan> it keeps growing!
00:54:33 <sjanssen> exDM69: I think Haskell is better if you really want to learn FP
00:54:36 <oerjan> always at the edge of undecidability
00:54:51 <hpaste>  (anonymous) annotated "Operator-error?!" with "(no title)" at http://hpaste.org/2795#a1
00:55:11 <exDM69> sjanssen: great!
00:55:17 <sjanssen> Scheme, Lisp, the MLs all make "deals with the devil" when it comes to mutable state and imperative programming
00:55:37 <exDM69> I must look into I/O and monads, because I can't really write a real program in haskell yet
00:55:40 <exDM69> not even a simple one
00:56:06 <doserj> main = print "Hello World"
00:56:11 <doserj> how much simpler can it get?
00:56:24 <Paczesiowa> less whitespace?
00:56:54 <sjanssen> main = return ()
00:57:26 <Paczesiowa> pure program:>
00:57:30 <oerjan> main = fail ""
00:57:45 <exDM69> I have been writing the exercises in YAHT and been writing my own versions of the built in functions (like map, filter, reverse) to figure out how they work
00:58:17 <doserj> well done!
00:59:02 <doserj> did you compare your versions with the haskell report's versions?
01:00:11 <Paczesiowa> well if you understand fibs and this: "main = getLine >>= print" then you know quite a lot about haskell and fp, I think
01:00:44 <Paczesiowa> rest is just practice and thinking
01:01:18 <Paczesiowa> which is hard for someone as lazy and stupid like me:)
01:08:46 <exDM69> doserj: no I have not compared my solutions with the haskell report's ones
01:08:52 <exDM69> doserj: where can I find that stuff
01:18:16 <doserj> http://www.haskell.org/onlinereport/standard-prelude.html
01:18:17 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
01:21:04 <exDM69> as I suspected, the approach I took is a lot more simpler and brute force :)
01:21:47 <exDM69> my_reverse (x:xs) = reverse xs ++ x : []
01:22:13 <exDM69> prelude's reverse = foldl (flip (:)) []
01:22:42 <doserj> and do you see why your version is bad? :)
01:23:31 <DRMacIver> For bonus points, do you see why the prelude version is also bad? :)
01:24:40 <exDM69> no, not really :)
01:24:49 <exDM69> perhaps if I'll look into it more
01:28:58 <doserj> it should be noticable for lists with more than, say, a few 10 thousand elements...
01:30:03 <matthew-_> right. time to write a talk for the Î»ondon HUG tonight...
01:30:31 <DRMacIver> Don't worry. You've got loads of time. :)
01:30:42 <Paczesiowa> doserj: my_reverse uses O(n!) space and prelude's version uses O(n) right?
01:30:53 <matthew-_> DRMacIver: I've given lectures before with zero preparation. This should be easy ;)
01:31:28 <DRMacIver> matthew-_: You presumably didn't have to give demos in those lectures though. ;)
01:31:53 <therp> what's wrong with the prelude reverse?
01:32:05 <matthew-_> all the lectures I give consist of me doing live coding...
01:32:23 <doserj> Paczesiowa: i thinks it's only O(n^2), but otherwise, yes
01:32:49 <DRMacIver> therp: Strictness.
01:33:06 <DRMacIver> matthew-_: Fair enough. :)
01:33:33 <therp> drmaciver: is there a way reverse can't be strict?
01:33:55 <DRMacIver> therp: No, I mean it doesn't use the strict version of foldl.
01:34:29 <DRMacIver> @src reverse
01:34:29 <lambdabot> reverse = foldl (flip (:)) []
01:34:36 <therp> drmaciver: ah, ok. and as reverse has to be strict, there is no sense in using the non-strict version of foldl, that's your point?
01:35:39 <DRMacIver> therp: Well, there's almost never a reason to use the non-strict verison of foldl. :) The notable difference here is that the strict version will have the tail call optimised.
01:35:52 <doserj> unfortunately, foldl' isn't in the prelude...
01:37:39 <Paczesiowa> why reverse has to be strict?
01:37:40 <sjanssen> DRMacIver: normal foldl gets an optimized tail call too
01:38:13 <sjanssen> the real difference is that foldl' doesn't allocate a new thunk for the accumulator
01:38:26 <therp> paczesiowa: because to give the first element, you have to reach to the end of the given list, hence it must evalute all elements at least insofar as to determine whether they are Cons or Nil
01:38:29 <DRMacIver> sjanssen: Am I misunderstanding the issue then? Because I was under the impression the normal foldl would stack overflow in various cases where strict wouldn't.
01:39:05 <sjanssen> DRMacIver: yes, it can either overflow the stack or the heap
01:39:12 <DRMacIver> ok
01:39:24 <augustss> DRMacIver: it may cause stack overflow when all the thunks are forced
01:39:28 <mux> which always leaves one wondering why sum is implemented this way
01:39:28 <DRMacIver> Oh, right. I see what's going on. Sorry.
01:39:30 <mux> @src sum
01:39:30 <lambdabot> sum = foldl (+) 0
01:39:31 <Paczesiowa> therp: and strict functions are good (fast) right?
01:39:34 <sjanssen> DRMacIver: but the stack overflow won't happen until after foldl finishes, when you attempt to force the thunk chain
01:39:37 <DRMacIver> Yeah
01:39:45 <DRMacIver> I just realised that. Sorry. :)
01:39:48 <doserj> mux: (+) may be non-strict
01:39:59 <therp> paczesiowa: yes, because you save to allocate thunks on the heap
01:40:09 <mux> sure, I see the point, a Num instance might benefit from a lazy sum
01:40:15 <mux> it's just annoying in practice :-)
01:40:28 <sjanssen> mux: ghc -O usually eliminates the problem
01:40:38 <Paczesiowa> therp: tx
01:40:56 <doserj> sjanssen: but ghci doesn't, does it?
01:41:07 <sjanssen> IIRC, it has specific rules to rewrite sum :: [Int] -> Int to a strict unboxed version
01:41:08 <mux> sjanssen: is it thanks to the strictness analyzer?
01:41:31 <sjanssen> mux: the strictness analyzer and some RULES pragmas
01:41:39 <quicksilver> even without specific rules, the strictness analyzer would stop the overflow, I believe
01:41:45 <sjanssen> doserj: right, ghci expressions aren't optimized
01:41:49 <quicksilver> the rules just make it unboxed
01:46:40 <Olathe> Nothing = Just Kidding
01:55:46 <Rebooted> > 1 + 2
01:55:50 <lambdabot>  3
01:56:38 <Rebooted> @undo do highScoreList <- highScoreStore; highScores <- get highScoreList; ask $ mapM_ showScore (sort highScores)
01:56:39 <lambdabot> (highScoreStore >>= \ highScoreList -> get highScoreList >>= \ highScores -> ask $ mapM_ showScore (sort highScores))
02:01:05 <oerjan> get doesn't take a parameter
02:01:26 <oerjan> nor does ask
02:01:49 <oerjan> maybe you mean gets and asks?
02:01:57 <oerjan> er, he left
02:03:32 <oerjan> (even those seemed weird in that context)
02:05:55 <axm> isn't there some webinterface for lambdabot as is for hoogle so that you have to come here?
02:06:18 <oerjan> there is, but i don't think it is currently working
02:06:31 <oerjan> you can also run lambdabot locally
02:08:28 <oerjan> http://lambdabot.codersbase.com/
02:08:29 <lambdabot> Title: Lambdabot Web Interface
02:09:31 <oerjan> gives "No lambdabot process"
02:10:24 <Rebooted> > undo do linksH <- links; links <- get linksH; ask (empty)
02:10:24 <lambdabot>  Parse error
02:10:39 <Rebooted> > undo (do linksH <- links; links <- get linksH; ask (empty))
02:10:40 <lambdabot> Terminated
02:10:49 <oerjan> Rebooted: ask and get do not take parameters
02:11:27 <oerjan> also, it's @undo
02:11:43 <Rebooted> oh yeah
02:11:44 <Rebooted> thanks
02:11:51 <Rebooted> > @undo (do linksH <- links; links <- get linksH; ask (empty))
02:11:52 <lambdabot>  Parse error
02:12:01 <Rebooted> @undo (do linksH <- links; links <- get linksH; ask (empty))
02:12:01 <lambdabot> ((links >>= \ linksH -> get linksH >>= \ links -> ask (empty)))
02:12:18 <Rebooted> got it in the end :)
02:13:10 <oerjan> that's some weird code
02:13:20 <Rebooted> oerjan: it's WASH
02:13:32 <Rebooted> oerjan: being a pain in the arse at the moment
02:13:47 <oerjan> it uses a different get and ask function?
02:13:54 <Rebooted> yes
02:14:04 <Rebooted> in fact it reuses tonnes of names
02:14:10 <Rebooted> which is a bit annoying
02:14:22 <oerjan> oh
02:16:01 <oerjan> @pl links >>= \ linksH -> get linksH >>= \ links -> ask (empty)
02:16:01 <lambdabot> (get =<< links) >> ask empty
02:16:46 <oerjan> or links >>= get >> ask empty, even
02:17:02 <oerjan> i think
02:17:09 <oerjan> @pl links >>= get >> ask empty
02:17:09 <lambdabot> links >>= get >> ask empty
02:17:27 <oerjan> @pl (links >>= get) >> ask empty
02:17:27 <lambdabot> links >>= get >> ask empty
02:17:50 <oerjan> strange, it doesn't know >>= and =<< are flips of each other
02:19:43 <Rebooted> thanks, that looks better
02:20:01 <Rebooted> never really uses lambdabot before, its pretty impressive
02:20:07 <Rebooted> *used
02:20:42 <Japsu> Hmm
02:21:11 <Japsu> What if I have a deck of cards (say, [Card]), and I want to pick one at random and return the card and the deck without the card?
02:21:30 <Japsu> @djinn Int -> [a] -> (a, [a])
02:21:34 <lambdabot> -- f cannot be realized.
02:21:43 <oerjan> splitAt
02:21:59 <oerjan> to build it
02:22:05 <Japsu> hmm, yah
02:22:13 <Japsu> hmm
02:22:16 <Japsu> this is going to get hairy
02:22:49 <oerjan> :t extract n l = let (bef,x:aft) = splitAt n l in (x,bef++aft) -- had this question before
02:22:54 <lambdabot> parse error on input `='
02:23:27 <oerjan> :t let extract n l = let (bef,x:aft) = splitAt n l in (x,bef++aft) -- had this question before
02:23:28 <lambdabot> <command line>:
02:23:28 <lambdabot>     Could not find module `L':
02:23:28 <oerjan> huh?
02:23:28 <Japsu> !
02:23:42 <oerjan> :t let extract n l = let (bef,x:aft) = splitAt n l in (x,bef++aft) in extract -- had this question before
02:23:43 <lambdabot> forall a. Int -> [a] -> (a, [a])
02:23:47 <Japsu> hmm
02:23:48 <Japsu> thanks
02:23:51 <oerjan> (got confused by two lets)
02:25:10 <quicksilver> when nesting lets it one liners it can help to use explicit {}
02:25:19 <quicksilver> although with just one defn you don't need to
02:26:43 <axm> can you do class typing like "x :: Show" somehow?
02:27:16 <oerjan> x :: Show a => a
02:28:07 <oerjan> although that may not do what you want, depending
02:28:11 <axm> ghci complains when I try that about "    Could not deduce (Num a) from the context (Show a)" for x=Num
02:28:20 <axm> no, it does not
02:28:41 <oerjan> of, you mean x is a class?
02:28:46 <oerjan> *oh
02:29:08 <axm> no, say x is an Int, and I want to make clear it is showable in a function header
02:29:28 <axm> cause the compiler does not know at this point it is something showable
02:29:36 <oerjan> Int is
02:29:37 <axm> gotten by unsafeEval
02:29:48 <quicksilver> axm: Show a => a
02:29:49 <oerjan> oh
02:30:03 <axm> yeah, tried that
02:30:40 <axm> but maybe the wrong way, mom
02:30:40 <quicksilver> e.g.:  f :: (Show a) => a -> String
02:30:49 <oerjan> if you tell the compiler it's an Int, it will know it is showable
02:30:52 <quicksilver> or f :: (Show a) => b -> a -> String
02:31:21 <axm> but I do not want to be limited to int, just shows
02:31:33 <oerjan> you need an existential wrapper then
02:31:37 <axm> makeit = unsafeEval "5 :: Int" [] :: IO (Maybe a) --say a is an instance of show
02:31:59 <quicksilver> makeit :: Show a => IO (Maybe a)
02:32:02 <oerjan> cannot be done that way
02:32:11 <quicksilver> but that probably doesn't mean quite what you want
02:32:11 <axm> i tried makeit = unsafeEval "5 :: Int" [] :: (Show a) => IO (Maybe a)
02:32:29 <oerjan> the problem is that a pure Int value does not actually contain its Show instance
02:32:36 <quicksilver> axm: well you can't change the type of unsafeEval :)
02:32:52 <oerjan> so the necessary information is not communicated across the unsafEval bound
02:32:55 <oerjan> iiuc
02:32:57 <axm> no way?
02:33:01 <quicksilver> axm: unsafeEval doesn't give rise to a show constraint, and you can't ask for one
02:33:03 <axm> damn
02:33:08 <Japsu> hmm
02:33:20 <oerjan> you need to do the existential wrapping _inside_ the unsafeEval, i think
02:33:47 <Japsu> Is there some easy way to create an integer range type like Ada's "type My_Range is range 10..20"?
02:33:56 <oerjan> otoh, if Show is all you need, you may simply wrap it in show ( ) there
02:33:59 <quicksilver> axm: I don't know why you're using unsafeEval, though :) seems like a bad plan
02:35:06 <axm> cause I got a function I have not the type at compile time
02:35:13 <oerjan> say, unsafeEval "show(5 :: Int)" should work
02:35:19 <axm> that I planned on getting that way
02:35:26 <axm> yeah, it dows
02:35:28 <axm> *does
02:37:13 <quicksilver> axm: unsafeEval doesn't allow you to work with things whose type you don't know
02:37:14 <quicksilver> axm: it allows you to write programs which segfault if the type is wrong
02:37:14 <Rebooted> @pl links >>= \ linksH -> get linksH >>= \ links -> ask (empty)
02:37:14 <lambdabot> (get =<< links) >> ask empty
02:37:14 <quicksilver> not the same thing ;)
02:37:14 <axm> ok, must have misunderstood that
02:37:14 <Rebooted> @pl links >>= \ linksH -> get linksH >>= \ links -> ask (links)
02:37:14 <lambdabot> ask =<< get =<< links
02:37:14 <axm> ;)
02:37:14 <axm> I thought it would be a good start to see what is already possible
02:37:14 <quicksilver> Japsu: not per se, no.
02:37:14 <Japsu> Hmm
02:37:14 <quicksilver> axm: let me ask you this: if you don't know what type it is, how do you plan to use it?
02:37:19 <quicksilver> there is precious little you can do with a totally untyped value..
02:37:27 <quicksilver> since all interesting functions require types
02:37:30 <quicksilver> ;)
02:38:02 <axm> i do, but i do not want to have that information in the source, but as an external parameter to unsafeeval
02:38:10 <oerjan> and since the only thing you can do with a Show value is essentially turning it into a String, it is just as easy to do that inside the unsafeEval.
02:38:11 <axm> like "5 :: Int" above
02:41:36 <quicksilver> Japsu: sometimes Data.Ix is what you want, sometimes a simple list [10..20] is what you want.
02:41:36 <quicksilver> Japsu: sometimes a simple newtype wrapper over Int is what you want
02:41:36 <quicksilver> axm: yes but what are you actaully going to *do* with that value?
02:41:36 <quicksilver> axm: let us suppose you have an untyped "5 :: Int" floating around
02:41:36 <quicksilver> axm: how will you use it?
02:41:36 <Japsu> quicksilver: this time I'm trying to implement a deck of cards... I'd like to make Card instance of Enum and Bounded, which they intuitively are
02:41:36 <axm> will be a function that is evaluated, so I guess I will have to look at the other plugins stuff, not just eval
02:41:36 <Japsu> that would greatly simplify some things
02:41:36 <axm> about the 5::Int, i would be happy to show it for starters ;)
02:41:36 <oerjan> newtype Showable = forall x. Show x => Showable x
02:41:36 <oerjan> i think
02:41:36 <Japsu> hmm
02:41:36 <quicksilver> Japsu: I thnk the best solution to the card type is data Card = Two | Three | Four | ... | Jack | Queen | King | Ace deriving Enum,Show,Bounded
02:41:40 <Japsu> yeah
02:41:42 <oerjan> but you need to apply the Showable constructor inside the eval
02:41:42 <quicksilver> oerjan: data not newtype
02:41:57 <Japsu> quicksilver: ugly, but that's what I was about to do
02:42:09 <oerjan> oh right
02:42:15 <axm> quicksilver, but i see your point now, wont get me anywhere if cannot use that internal type
02:42:24 <oerjan> it's not the same representation as x itself
02:42:56 <quicksilver> oerjan: I'm not sure that will work, because the hs-plugins interface uses Typeable/Dynamic and is therefore restricted to monomorphic values
02:43:16 <oerjan> quicksilver: not unsafEval, i think
02:43:23 <oerjan> *unsafeEval
02:43:53 <oerjan> isn't a Showable essentially monomorphic? the type doesn't escape.
02:44:12 <quicksilver> maybe
02:44:21 <quicksilver> I don't quite understand the details
02:44:24 <axm> thats i went from eval to unsafeEval after I was not able to reproduce the one example that I think does I want to do, a polymorphic eval
02:45:00 <axm> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-4.html#node_sec_7
02:45:02 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules, http://tinyurl.com/2xwycf
02:45:50 <Rebooted> @undo do l' <- l; l'' <- get l'; ask (html (do head (title (text "title")); ol (mapM_ renderLink (sortBy (by points) links))))
02:45:50 <lambdabot> (l >>= \ l' -> get l' >>= \ l'' -> ask (html (head (title (text "title")) >> ol (mapM_ renderLink (sortBy (by points) links)))))
02:46:00 <quicksilver> axm: ok, interesting
02:46:13 <Rebooted> @pl (l >>= \ l' -> get l' >>= \ l'' -> ask (html (head (title (text "title")) >> ol (mapM_ renderLink (sortBy (by points) links)))))
02:46:14 <lambdabot> (get =<< l) >> ask (html (head (title (text "title")) >> ol (mapM_ renderLink (sortBy (by points) links))))
02:46:34 <quicksilver> axm: looks like you *can* do polymorphism with eval, but you need to write your own typeable instance
02:47:10 <axm> and the example seems to refer to plugins-0.9.10, which does not compile with ghc-6.6 anymore
02:47:49 <Rebooted> @undo do l' <- l; l'' <- get l'; ask (html (do head (title (text "title")); ol (mapM_ renderLink (sortBy (by points) l''))))
02:47:50 <lambdabot> (l >>= \ l' -> get l' >>= \ l'' -> ask (html (head (title (text "title")) >> ol (mapM_ renderLink (sortBy (by points) l'')))))
02:48:22 <oerjan> @. pl undo do l' <- l; l'' <- get l'; ask (html (do head (title (text "title")); ol (mapM_ renderLink (sortBy (by points) l''))))
02:48:23 <lambdabot> ask . html . (head (title (text "title")) >>) . ol . mapM_ renderLink . sortBy (by points) =<< get =<< l
02:48:28 <axm> there is a Test.QuickCheck.Poly that might go in that direction as well, but the description i found was rather short
02:48:41 <oerjan> Rebooted: btw, you can use lambdabot in private messages
02:49:13 <Rebooted> oerjan: thanks
02:50:16 <oerjan> you might have to be registered to send them, though
02:51:04 <oerjan> i hear lambdabot tries to allow messages, but doesn't always
02:51:22 <oerjan> *unregistered messages
02:51:53 <quicksilver> oerjan: now I think of it, existentials should be fine
02:51:59 <quicksilver> oerjan: but I bet deriving Typeable doesn't work
02:54:39 <oerjan> quicksilver: deriving Typable for existentials sounds to me like a case that may be made to work, but which may or may not have slipped by.
02:55:11 <quicksilver> http://www.haskell.org/pipermail/glasgow-haskell-users/2003-June/005312.html
02:55:12 <lambdabot> Title: Conditions on deriving Typeable, http://tinyurl.com/2acd8h
02:55:51 <oerjan> ah
03:01:29 <quicksilver> oerjan: yup, it works fine
03:01:42 <quicksilver>  typeOf [Showable 5,Showable "foo"]
03:01:47 <quicksilver> [Main.Showable]
03:01:56 <oerjan> good
03:02:05 <oerjan> now food
03:02:08 <quicksilver> axm: so, I think some flavour of existential wrapper is the answer to your problem
03:02:56 <quicksilver> axm: for example, if you have "x" of unknown type, and also a function "f" which operatores on x to return an Int
03:03:09 <axm> just trying to get it work, maybe I need a complete different approach for my final intention
03:03:24 <axm> hm, continue
03:03:27 <quicksilver> axm: then you can write the existential data MyBundle = forall a . MyBundle (a,a->Int)
03:03:48 <quicksilver> axm: then you will be able to use that iwht hsplugins, I belive
03:04:02 <quicksilver> of course the only useful thing you can do is pass the 'a' to the 'unction' bundled with it
03:04:07 <axm> jepp, i am working an how to apply that type at the moment
03:04:18 <quicksilver> this is a bit like object orientation
03:04:24 <axm> thats all i need
03:04:32 <quicksilver> object a of unknown structure, with a bunch of methods
03:04:52 <axm> yes. I was missing some basic oo features ;)
03:05:05 <quicksilver> you might also say it's like abstract data structures
03:05:10 <quicksilver> or that it's like first-class modules
03:05:10 <axm> one of the reasons i will take a step back and reconsider
03:05:20 <axm> things overlap
03:05:37 <axm> but since i come from java, it reminded me
03:08:55 <KatieHuber> people keep saying "hsplugin" but google is curiously recalcitrant... anyone got an explanatory link?
03:09:37 <axm> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-4.html
03:09:38 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
03:09:53 <KatieHuber> ta
03:15:15 <hpaste>  quicksilver pasted "existentials" at http://hpaste.org/2822
03:15:26 <quicksilver> axm: there is a simple example of the kind of thing
03:15:41 <quicksilver> axm: I don't have a hs-plugins installation here so I can't try it with that
03:15:54 <quicksilver> axm: but it should with with eval (not even unsafe) since MyBundle is typeable
03:16:30 <axm> thats what my impression was, but i could not get the example there running
03:17:02 <axm> i still have to look a lot at that stuff to understand it sufficiently, alas, have to go now
03:18:28 <axm> thanks a lot for helping me
03:18:46 <quicksilver> that's ok :)
03:18:48 <quicksilver> any time
03:32:56 <matthew_-> how do you do a min with a cyclical number system?
03:33:00 <matthew_-> if I have 1 and 2 then I want to choose 1. If I have 9 and 1 and values in range 1 -> 9 then I want to choose 9
03:33:03 <matthew_-> if I have 8 and 9 then I want 8
03:33:06 <matthew_-> it's just where it wraps
03:33:19 <matthew_-> (and sorry if I just asked this - my irc connection seems confused)
03:36:00 <matthew_-> ahh, it'll have to be done on relative distance
03:36:38 <doserj> does this have any useful properties?
03:42:57 <KatieHuber> sounds a bit like angular subtraction
03:43:09 <KatieHuber> I never did find an elegant solution to that :|
03:44:03 * gour just found out about new & cool ff extension (http://www.zotero.org/) suitable for research
03:44:04 <lambdabot> Title: Zotero - The Next-Generation Research Tool
03:45:10 <xerox> gour: that looks like flm.. !
03:45:28 <gour> xerox: flm?
03:45:35 <xerox> shapr's fermat last margin
03:45:56 <gour> :-)
03:50:24 <matthew_-> right, you have a fixed max range. You try both values and check to see whether the other value is smaller than the current value plus the range (with wrapping turned off)
03:52:20 <matthew_-> so with 0 -> 9 and a range of 3, comparing 9 and 1, well 9 + 3 == 12 and 1 < 12 so it's 9
03:52:34 <matthew_-> comparing 1 and 2, 2 < (1 + 3) so it's 1
03:54:26 <doserj> so this is neither commutative nor associative?
03:55:17 <matthew_-> well, it's not a binary op, because you really need to supply the range too
03:56:52 <matthew_-> with the same range, comparing 9 and 1 should be the same as comparing 1 and 9
03:59:38 <doserj> 2 < (1+3) and 1 < (2+3)
04:00:36 <matthew_-> ahh. ooopsy
04:00:40 <matthew_-> I suck at maths
04:01:02 <doserj> what are you actually trying to do?
04:01:24 <matthew_-> I have 3 longitudes
04:01:30 <matthew_-> I need the "smallest" one
04:01:35 <quicksilver> doserj: but abs (2-1) < abs (2-(1+3))
04:01:37 <matthew_-> but of course they wrap
04:01:52 <quicksilver> doserj: presumably you're supposed to look at the smallest different, or something
04:02:33 <quicksilver> matthew_-: I'd try to find a 180-degree arc which includes all three
04:02:41 <quicksilver> matthew_-: (hemisphere, if you like)
04:02:43 <doserj> matthew_-: do you simply mean the closest to some fixed one?
04:02:47 <matthew_-> ahh, I want the most "westerly" longitude
04:02:53 <quicksilver> matthew_-: and order them within that hemisphere
04:03:08 <quicksilver> matthew_-: if there is no 180-degree chunk which they all lie in
04:03:11 <quicksilver> then they're incomparable
04:03:18 <matthew_-> quicksilver: there is always a 180-degree are
04:03:19 <matthew_-> arc
04:03:26 <matthew_-> err, how to find that arc?
04:04:02 <quicksilver> sort them a,b,c, take the pairwise difference b-a, c-b, a-c
04:04:09 <quicksilver> whichever of those three difference is the largest number
04:04:12 <quicksilver> (with wraparound)
04:04:16 <quicksilver> is *outside*
04:04:22 <quicksilver> the othere two are the inside
04:05:14 <matthew_-> sorry, I don't follow
04:05:27 <quicksilver> Ok, suppose the numbers are 340, 350, 30
04:05:33 <matthew_-> yep
04:05:34 <quicksilver> sort them: 30, 340, 350
04:05:48 <matthew_-> yep
04:05:59 <quicksilver> pairwise diffs: 340-30 = 310. 350-340 = 10. 390 - 350 = 30.
04:06:06 <quicksilver> ((where 390 is 30+360))
04:06:17 <matthew_-> yep
04:06:25 <quicksilver> the 'largest' pairwise diff was 340-30, so that's 'outside'
04:06:39 <quicksilver> therefore the correct ordering is 340,350,30
04:06:40 <doserj> > 390-350
04:06:42 <lambdabot>  40
04:06:48 <matthew_-> heh
04:06:50 <quicksilver> doserj: thanks :) ortunately that doesn't matter :)
04:06:53 <DRMacIver> Ooh. I have shiny new book. (Which rather than the slim volume I expected is a massive great big tome. :) )
04:07:20 <matthew_-> quicksilver: ok, thanks
04:08:55 <wli> DRMacIver: Which is that?
04:15:36 <hpaste>  quicksilver pasted "circular order" at http://hpaste.org/2823
04:15:44 <quicksilver> matthew_-: there you are. That's my algorithm :)
04:19:17 <DRMacIver> wli: Foundations of multidimensional and spatial datastructures (possibly a bad choice for the subject, but it was cheaper than most of the alternatives. :) )
04:21:00 <wli> DRMacIver: A useful and sorely neglected topic.
04:22:04 <DRMacIver> wli: I've been working on various graph layout stuff (which is going quite badly at the minute :( ) for work, which got me interested in it.
04:22:34 <wli> Work's going badly here, too.
04:23:08 <DRMacIver> My Java quad tree implementation appears to be horrifically buggy.
04:23:14 <DRMacIver> (Unlike the Haskell one which worked out of the box)
04:23:21 <quicksilver> Java ... buggy ?
04:23:23 <quicksilver> surely not :P
04:23:31 <DRMacIver> quicksilver: I know. Sounds astonishing, doesn't it? ;)
04:23:54 <wli> B-K-D trees could be handy.
04:23:58 <DRMacIver> quicksilver: It's for work.
04:24:20 <DRMacIver> wli: Right now I'm more interested in getting the basics working. Alternative implementations are for much later. :)
04:24:57 <wli> B-K-D trees are mostly for higher-dimensions than 2 (where specialized things win out).
04:26:14 <DRMacIver> Ah. right now I'm mainly interested in the 2D case (which admittedly makes the choice of book seem strange). 3D is another 'much later' thing. :)
04:27:21 <DRMacIver> Let me rephrase.
04:27:25 <wli> Mostly higher than 3D, too, though the specialized wins are nowhere near as dramatic (and specialized structures less plentiful).
04:27:29 <DRMacIver> Right now I'm mainly interested in gettin gthis goddamn code working. :)
04:28:02 <wli> I had in mind Haskell libraries vs. your particular problem.
04:28:21 <DRMacIver> ok. :)
04:28:51 <vincenz> wli: ooh, an option for hac2
04:29:07 <DRMacIver> matthew_- said he had a heavily optimised octtree implementation. I have a heavily unoptimised quadtree one. I don't think there's much else out there.
04:29:11 <DRMacIver> vincenz: hac2?
04:29:24 <DRMacIver> (I agree it would be interesting though)
04:31:35 <wli> vincenz: Could be. It's very very useful to have around.
04:39:13 <matthew_-> quicksilver: perfect. Many thanks, you just saved me!
04:43:17 <hpaste>  TheMoose pasted "Randomizer" at http://hpaste.org/2824
04:44:59 <hpaste>  TheMoose annotated "Randomizer" with "(no title)" at http://hpaste.org/2824#a1
04:53:21 <Cale> TheMoose: which StdGen are you passing in?
04:54:31 <TheMoose> I'm new to this with Haskell, so I'm not sure. When I'm running the function in ghc, I call (mkStdGen 7) as StdGen
04:54:31 <quicksilver> matthew_-: :)
04:54:57 <Cale> TheMoose: If you pass in the same StdGen, you'll get the same pseudorandom number every time
04:55:10 <TheMoose> Yes, I know :)
04:55:14 <quicksilver> '7' is definitely one of my favourite StdGens
04:55:18 <quicksilver> it's very lucky
04:55:37 <TheMoose> But since the deck doesn't come back 'scrambled' it doesn't matter, right?
04:55:57 <TheMoose> The functions still is in-functional... ;)
04:56:20 <TheMoose> quicksilver ;)
04:56:49 <quicksilver> why do you pick a random value for 'i'
04:56:53 <Cale> I'm finding shuffle' a little strange. :)
04:56:55 <quicksilver> why not always use (size deck) ?
04:57:11 <quicksilver> TheMoose: surely it turns out that, with StdGen 7, a small random 'i' is chosen
04:57:16 <Cale> TheMoose: Is your Hand type set in stone?
04:57:24 <TheMoose> Cale, yes.
04:57:56 <Cale> okay, it's slightly silly, but likely just to force you to implement things which are in the Prelude :)
04:58:16 <TheMoose> quicksilver; That is from earlier - I never bothered to change. size deck is always 52 as well
04:58:55 <Cale> newtype Hand = H [Card] would be more convenient of course :)
04:59:55 <TheMoose> Cale, you're probably right - but as you said - we're forced.
05:00:29 <TheMoose> Our teacher is Koen Claessen, the guy who wrote QuickCheck.
05:00:40 <quicksilver> TheMoose: if you change it to shuffle' (size deck) 0 deck
05:00:44 <quicksilver> TheMoose: is that any better?
05:01:07 <quicksilver> but erm hang on
05:01:16 <quicksilver> your shuffle' doesn't actually do any shuffling?
05:01:26 <quicksilver> all it does it go through the deck and hand out the cards, top-first
05:01:40 <TheMoose> Yep.
05:01:51 <TheMoose> I know. ;)
05:02:04 <quicksilver> ok, so what is your question? :)
05:02:38 <quicksilver> oh I see,
05:02:43 <quicksilver> shuffle' is just "nth", really
05:02:53 <quicksilver> but, shuffle is trying to use it
05:02:59 <quicksilver> however, shuffle isn't recursive
05:03:09 <quicksilver> ...
05:03:13 <quicksilver> you only shuffle at most once
05:03:14 <TheMoose> I'm tring to pick out the n:th Card from the deck and put it on top.
05:03:26 * quicksilver nods
05:03:34 <quicksilver> ok, well shuffle' is well-laced to pick out the nth card
05:03:36 <TheMoose> And by doing this 52 times, the deck would be shuffled
05:03:40 <quicksilver> but it doesn't record the "rest of the deck"
05:03:42 <quicksilver> in any way
05:03:47 <quicksilver> all it does it pull out the nth
05:04:01 <quicksilver> you need to record the "rest of the deck" to put it on top of...
05:04:31 <TheMoose> That's why I'm using the two-tuple. You are so right.
05:05:02 <quicksilver> hmm. maybe I hve been confused by your code
05:05:17 <quicksilver> maybe shuffle' does work
05:05:21 <doserj> the else branch in shuffle' doesn't make sense...
05:05:38 <TheMoose> I'm sure you have. I'm very familiar with the oo-languages, but this kind of thinking just messes with my head
05:05:53 <doserj> you want (fst shuffle' ..., Add card (snd shuffle' ..))
05:06:18 <quicksilver> doserj: he doesn't want fst
05:06:35 <quicksilver> doserj: that part is right. at each stage the left component is just 'current card'
05:06:41 <quicksilver> doserj: it gets ignored recursively
05:06:49 <quicksilver> oh
05:06:52 <quicksilver> no, doserj is right
05:07:03 <quicksilver> TheMoose: I'm surprised that even compiles
05:07:08 <TheMoose> but the fst shuffle' is a Card?
05:07:12 <Cale> Don't use fst and snd, use pattern matching
05:07:15 <quicksilver> TheMoose: shouldn't it be snd $ shuffle', or snd ( shuffle'...)
05:08:01 <Cale> Is shuffle' intending to pick a specific card out of the deck and return the card along with the new deck?
05:08:05 <doserj> else let (c,h) = shuffle' ... in (c,Add card h)
05:08:22 <int-e> let (card', restDeck') = shuffle' i (counter+1) restDeck in ...
05:08:51 <TheMoose> The shuffle' should pick out the nth card and return every other card in the deck, including the ones that have been tossed away earlier in the recursion
05:08:53 <hpaste>  Cale annotated "Randomizer" with "pick" at http://hpaste.org/2824#a2
05:10:53 <Cale> You should usually try to avoid carrying around extra counters.
05:11:36 <matthew_-> right, target 1 has been achieved: we have software to demonstrate at tonight's Î»ondon hug
05:12:28 <DRMacIver> Good. :)
05:15:01 <TheMoose> Cale, thanks. I tried to get around it but never succeded. That looks good. But still, the deck is not scrambled. What to I have to add?
05:15:20 <Cale> To shuffle a deck of length n, you should pick a random element from it and Add that to the result of shuffling the rest of the deck.
05:15:30 <Cale> (which has length n-1)
05:15:47 <Cale> To shuffle the empty deck, you simply return the empty deck again.
05:16:20 <Cale> Note that when you get a random number from applying randomR to your StdGen, you'll get a new StdGen along with the result
05:16:38 <opqdonut> that's why using randomRIO or the Random monad is nice
05:16:43 <Cale> You must use that new StdGen, or else you'll just get the same number over and over.
05:17:26 <TheMoose> Yes, i' in my example. I've noticed. But how do I use i', since the shuffle is not recursive?
05:17:53 <Cale> shuffle *should* be recursive. :)
05:18:02 <TheMoose> Oh.
05:18:03 <TheMoose> :)
05:18:28 <opqdonut> but this is madness
05:18:32 <TheMoose> Ok. I'll try figure this out. Thanks everyone for your patience :)
05:18:37 <opqdonut> NO THIS IS PRIMARY RECURSIOOON!
05:18:50 * vincenz peers at opqdonut 
05:18:51 <Vq^> opqdonut?
05:19:08 <opqdonut> nevermind
05:19:09 <vincenz> Someone needs a lambda-cookie
05:19:10 <Japsu> ;D
05:19:12 <opqdonut> coffee etc
05:19:27 <Japsu> my 300 intertextuality a few days ago got a better response
05:19:28 <Cale> TheMoose: However, it might be worth having a helper function to keep track of the number of remaining cards, so you don't end up recomputing the size of the deck on each iteration.
05:19:33 <Japsu> someone even tried to @remember it
05:19:39 <Japsu> though there was no lambdabot at that time
05:19:45 <Vq^> opqdonut: get over here and i'll make you a cup :)
05:19:48 <oklopol> > 12345
05:19:49 <vincenz> "Have a lambda-cookie, by the time you finish it you will have forgotten all about recursion and slipped into a soft state of monads."
05:19:52 <lambdabot>  12345
05:19:53 <Cale> (you need the size of the deck so that you know the range for randomR)
05:21:09 <TheMoose> Cale, ok. Sounds good. One more question, how do I know when the recursion for shuffle should stop? I have to have a base case, right?
05:21:35 <Vq^> TheMoose: how about when some counter matches 0 ?
05:21:47 <Cale> TheMoose: there's only one way to shuffle an empty deck :)
05:22:32 <TheMoose> By just returning it.
05:22:37 <Cale> yeah
05:23:00 <vincenz> no there's not
05:23:05 <vincenz> you could return a new empty list
05:23:20 <vincenz> instead of returning it :)
05:23:22 <Cale> vincenz: that's equivalent
05:23:38 <vincenz> Cale: only if the ghc reuses the value :)
05:23:43 <vincenz> s/the //
05:23:54 <vincenz> shuffle [] = []  vs shuffle l@([]) = l
05:24:02 <Cale> It's semantically indestinguishable either way
05:24:10 <vincenz> for tuples that makes a difference in performance
05:24:15 <Cale> indistinguishable*
05:24:26 <vincenz> inextinguishable
05:24:57 <vincenz> meh
05:25:25 <Cale> TheMoose: so you get what the recursion is doing then?
05:25:47 <b_jonas> but the optimizer should find that.
05:25:50 <Vq^> doesn't he have to pass the length around as well?
05:26:03 <Cale> Vq^: he doesn't *have* to, but it's a good idea
05:26:09 <TheMoose> I think so...
05:26:09 <Cale> He might want to use a helper function: shuffle g xs = shuffle' g (size xs - 1) xs
05:26:16 <vincenz> Cale: why, it's indistinguishable from length ;)
05:26:56 <Cale> It actually probably doesn't matter in this case.
05:27:09 <Cale> The deck of cards is bounded.
05:27:24 <vincenz> and if it weren't, you might not want to get a random infinite number
05:27:39 <Cale> It does make the difference between a quadratic and a linear time algorithm though.
05:28:10 <Cale> vincenz: Of course it's always finite, but we also know that it has at most 52 cards
05:28:35 <Cale> which means that the asymptotic complexity of the shuffler "doesn't matter"
05:29:30 <b_jonas> have you never shuffled more than 52 cards? it's probably still bounded, you'd rarely use more than, say, 350 cards.
05:30:16 <Cale> (In his case though, the deck he needs to shuffle is only 52 cards long)
05:30:41 <vincenz> b_jonas: well that depends on the size of your hands, I wouldn't put in an arbitrary constant like that
05:31:31 <b_jonas> I see
05:32:16 <b_jonas> probably it's not only your hands, but also that the card games you play don't require more cards than that
05:32:53 <vincenz> and the thickness of the cards
05:34:00 <Vq^> yeah, the shuffle-function probably requires more energy when the cards are thicker
05:34:45 <vincenz> no, but the number of cards might vary
05:35:07 <vincenz> I doubt anyone would find it realistic to have 52 cards of 5cm thick
05:35:20 <b_jonas> yep, thickness and the physical quality of cards as well
05:35:31 <vincenz> you mean laminated vs non-laminated?
05:35:33 <b_jonas> but actually thicker cards can in some case be easier to shuffle
05:35:52 <b_jonas> no, not laminated
05:35:55 <vincenz> I think there's a curve to it
05:35:57 <b_jonas> but three things actually:
05:36:01 <vincenz> with some ideal thickness
05:36:03 <Cale> Online poker servers had lots of problems with heat ventilation in their server rooms until they learned to make their virtual cards thinner.
05:36:14 <vincenz> Yay for non-sequitur conversations
05:36:17 <b_jonas> the most important is that cards in removable plastic sleeves are easier to shuffle
05:36:23 <b_jonas> (though only if you know the technique)
05:36:33 <Vq^> Cale: :)
05:36:49 <vincenz> take_out sleeve >> shuffle >> put_in sleeve  ??
05:36:55 <b_jonas> because the sleeve is larger than the card so the sleeved card is thinner on the edges,
05:37:00 <int-e> Can we do better than O(n log(n)) for a perfect shuffle in Haskell, without resorting to ST or IO?
05:37:07 <b_jonas> so two stack of cards can be merged quite easily
05:37:29 <int-e> (O(n log n) can be achieved with lists. it's a fun exercise.)
05:37:33 <b_jonas> they just go together because of the zigzag shape on the size that's made by the thinner edges
05:37:40 <vincenz> ep
05:37:42 <vincenz> s/ep/yep
05:37:50 <vincenz> Of course, perfect shuffles are a bad idea
05:37:56 <b_jonas> the second thing is the size of the face of cards obviously
05:37:58 <vincenz> doing 8 of those results in no-randomness at all, you get your original deck
05:38:15 <int-e> uh I meant perfectly random.
05:38:17 * int-e wonders
05:38:39 <vincenz> int-e: with arrays it should be doablbe in O(n)
05:38:45 <b_jonas> and the third one is that the cards have to be of the same shape: if I cut cards from cardboard with scissors they're very imperfect which makes shuffling difficult
05:38:50 <int-e> (given a random number source, of course)
05:38:51 <vincenz> afaik, you run through your array and swap with a random other card
05:39:15 <b_jonas> vincenz: not exactly
05:39:25 <vincenz> b_jonas: I don't remember the details, but it was close to that
05:39:46 <b_jonas> it's running through the array from left to right and swapping with one of the cards to the right of it, including itself
05:39:57 <vincenz> ah :)
05:39:59 <vincenz> still O(n)
05:40:05 <b_jonas> yep
05:40:20 <b_jonas> the explanation is in both Knuth vol 3 and in Cormen
05:40:23 <int-e> vincenz: yes I knew why I disallowed arrays.
05:40:32 <Cale> It's also pretty common sense
05:40:56 <b_jonas> Cale: it's easy to prove it but not easy to invent
05:41:03 <b_jonas> at least I think so
05:41:22 <Cale> Oh, I think it's pretty easy to invent too -- just think about the problem of enumerating all the possible shuffles.
05:41:37 <int-e> vincenz: oh I guess DiffArrays are a way to cheat.
05:41:58 <Cale> You'd start off by picking your first element from the whole deck, then you'd pick the second from whatever cards remained, and so on.
05:42:26 <Cale> You can do that in all possible ways and get all permutations exactly once
05:42:43 <Cale> or you can do it in a random way, and get a random permutation with uniform probability
05:44:12 <Cale> The idea of storing the partially built permutation and the remaining cards in the same array is I suppose the clever bit
05:44:36 <wootles> a little OT here... does anyone know of a good resource for learning assembler on amd64 ?
05:45:19 <int-e> Cale: you can think of it as a selection sort, implemented in place, run in reverse.
05:45:24 <b_jonas> wootles: well, AMD itself releases programming information for the cpu (free to download, seven thick volumes)
05:45:31 <Cale> int-e: yeah, you could :)
05:45:59 <b_jonas> but I wouldn't want to work much with amd64 because it's SO UGLY because it tries to stay similar to x86
05:46:26 <wootles> b_jonas: it's worse than x86 ?
05:46:48 <b_jonas> wootles: yes
05:47:13 <b_jonas> at least if you want to write optimized code for it, but I assume you want that otherwise you wouldn't use assembly
05:47:55 <b_jonas> it might be better than x86 performance-wise though if you manage to optimize well
05:48:30 <wootles> best to learn x86 first then ?
05:50:17 <b_jonas> I don't know
05:50:24 <b_jonas> I don't actually want to learn it.
05:50:34 <b_jonas> I just want to know some things about what's available
05:52:43 <wootles> i was planning to write some bitboard-manipulation routines for an othello AI
05:53:22 <wootles> x86-64 seemed perfect because 8x8 board = two 64 bitfields, one for each player, and it seems to have so many registers
06:01:15 <b_jonas> I think you might be able to do it on x86 as well with these mmx and similar things
06:01:22 <b_jonas> which do have 64-bit extensions
06:02:22 <b_jonas> but if you only want it to run on amd64 (os, not only cpu) then it'll most probably be not slower with amd64 then in x86
06:03:32 <b_jonas> you might also want to learn about the gcc extensions that lets the compiler use vector instructions more
06:24:34 <hpaste>  TheMoose annotated "Randomizer" with "Not pretty!" at http://hpaste.org/2824#a3
06:30:31 <TheMoose> My solution is not pretty at all, and probably not very "scramable" - but the cards get scrambled. Can I do this is a prettier way? :)
06:30:47 <TheMoose> *in
06:34:08 <doserj> are you sure that your code does what you want it to do?
06:34:51 <TheMoose> Kind of. The output is a scrambled deck. But I know I'm at the wrong train, so to speak.
06:35:13 <doserj> can you say in words how your code is supposed to shuffle?
06:35:59 <TheMoose> Haha no. :e
06:36:12 <TheMoose> Well, let me try.
06:36:28 <doserj> in your second line for 'shuf', are you aware that there are two different i's?
06:37:10 <TheMoose> The pick-function picks a random card from the deck and places it on top of it. Then I do that 100 times. Not nice.
06:37:15 <TheMoose> Yes.
06:37:45 <TheMoose> I saw that after I posted on hpaste.
06:38:01 <doserj> which i is the i in "shuf g' (i-1) ..."?
06:38:05 <int-e> well, except that you don't do it 100 times.
06:38:30 <doserj> that was my point, yes :)
06:38:49 <TheMoose> The one from the randomR :e
06:38:58 <TheMoose> Damn. I really suck at this.
06:39:26 <doserj> ok. when you fixed this, think about for what you need the shuffle'
06:40:09 <TheMoose> Nothing, probably. I was thinking of it as well.
06:40:20 <int-e> You should change your algorithm. you will never get a perfectly random shuffle by picking a random card and putting it on top of the pile. The trick is to shuffle smaller and smaller piles, putting certain cards aside.
06:40:56 <int-e> At the same time that will also get rid of the awkward 100 constant.
06:41:04 <TheMoose> Hm. Ok... That's true.
06:43:36 <Saizan> int-e: you can perfect shuffle in O(n log n) with only lists?
06:43:48 <int-e> Saizan: yes
06:44:01 <int-e> Saizan: the idea is to run a merge sort in reverse.
06:45:00 <b_jonas> if you have a sort like that (that is, only lists in O(n log n)), you can always use it to shuffle with random unique keys
06:45:05 <int-e> Saizan: so the core procedure is a randomized merge, and the trick is to get the probabilities right.
06:45:59 <Saizan> int-e: i see
06:48:21 <Saizan> b_jonas: and how do you get N random unique keys?
06:49:15 <b_jonas> Saizan: cormen explaines that:
06:49:45 <b_jonas> iirc it's that you generate random integers up to N^3 and retry if they're not unique which is easy to see after the sort
06:50:25 <b_jonas> where N^3 (iirc) is enogh for theory but in practice you might want to use more, e.g. whatever rand gives
06:51:42 <vincenz> random unique keys can be getting by shuffling [1..n]
06:51:45 <vincenz> :)
06:51:54 <vincenz> hmm, a recursive problem specification
06:52:57 <doserj> just randomly choose one. if you have chosen that one before, try again.
06:53:13 <vincenz> that's O(inf)
06:53:52 <doserj> not quite, but also not O(nlogn)...
06:53:54 <int-e> but it has a reasonable expected runtime, so it's probably ;) ok.
06:54:11 <vincenz> there's an easier way, pick a random one
06:54:15 <vincenz> and remove it from the list :)
06:54:45 <vincenz> but then we've just implemented the original shuffle algo as proposed by cale
06:54:58 <doserj> yep.
06:54:59 <b_jonas> vincenz: it's still O(n log n) in average
06:55:19 <phobes> int-e:  So as you're merging two piles randomly, shouldn't you just pick from a pile with probability proportional to its (remaining) length?
06:55:25 <doserj> sure? it sounds more like O(n^2)
06:55:30 <int-e> phobes: yep
06:55:45 <sieni> what are you trying to accomplish?
06:56:29 <vincenz> sieni: golf on shuffle
06:57:31 <sieni> ok
06:58:44 <b_jonas> golf? hey, you never said that
06:58:51 <matthew_-> @seen njbartlet
06:58:52 <lambdabot> I haven't seen njbartlet.
06:58:59 <matthew_-> @seen njbartlett
06:59:00 <lambdabot> I saw njbartlett leaving #haskell-blah, #scala and #haskell 1h 11m 20s ago, and .
06:59:07 <matthew_-> DRMacIver: ping?
06:59:11 <DRMacIver> pong
06:59:20 <DRMacIver> What's up?
06:59:48 <matthew_-> ok, what time are we getting there?
06:59:58 <matthew_-> and are you getting there?
07:00:02 <matthew_-> and is neil getting there?
07:00:04 <DRMacIver> Good question. :)
07:00:04 <matthew_-> and where is there?
07:00:51 <DRMacIver> I've not been involved in the detailed planning and coordination. I'm really just an attendee who has leant a vague hand once or twice.
07:01:04 <DRMacIver> 'There' is City University, the place where we had the first one. It will be a different room, but signed to it. This may be contingent on Neil getting there first.
07:01:05 <matthew_-> no, you're the leader
07:01:15 <matthew_-> you must lead
07:01:19 <DRMacIver> The event starts at 6:30. Getting there at 6 is probably reasonable.
07:01:21 <matthew_-> on you, all our hopes rest
07:01:31 <matthew_-> okeydokie
07:02:06 <DRMacIver> I'm not sure when I'll be there. It depends which of "frustration at this stuff NOT FUCKING WORKING" and "Damn. I got in late. I can't leave now." wins out.
07:03:09 <DRMacIver> (I mean, it will definitely be on time. I'm not sure if it will be early)
07:03:32 <b_jonas> vincenz: the perl golf book has fair shuffling: http://terje2.frox25.no-ip.org/perlgolf_history_070109.pdf
07:04:00 <b_jonas> obviously it's probably not really relevant in haskell
07:17:33 <nominolo> @seen drcode
07:17:34 <lambdabot> I haven't seen drcode.
07:23:12 <matthew_-> why are mvars preferred to iorefs?
07:23:28 <quicksilver> matthew_-: they aren't
07:23:40 <quicksilver> matthew_-: IORefs are the right thing to use for single-threaded programs
07:23:57 <matthew_-> oh.
07:24:03 <quicksilver> matthew_-: MVars are the right thing to use if you want to access from multiple threads
07:24:55 <quicksilver> of course, in many of the occasions you might use an IORef it's probably preferred to simply not use one at all :)
07:29:27 <quicksilver> whereas MVars have a better raison-d'etre since a purely functional paradigm for communicating between threads is not so obvious
07:29:39 <vincenz> Did anyone grok cc-shan's haskell code?
07:36:34 <njbartlett> REMINDER: London HUG meeting tonight!
07:37:12 <njbartlett> Two great talks: Ross Paterson on fingertrees, and Matthew and Tristan on game design in Haskell
07:37:22 <vincenz> njbartlett: will there be movies?
07:37:26 <njbartlett> Be there or be... somewhere else
07:37:41 <vincenz> Maybe be there :)
07:37:47 <njbartlett> vincenz: There will be a video of the game design talk, but Dr Paterson declined to be videod
07:37:53 * vincenz nods
07:37:57 <vincenz> njbartlett: where will this be posted?
07:38:05 <njbartlett> http://www.londonhug.net/
07:38:06 <lambdabot> Title: Î»ondon HUG
07:38:14 <vincenz> gracias
07:38:24 <njbartlett> do itashimashite
07:44:42 <njbartlett> matthew_-: Are you there?
07:45:27 <njbartlett> ToRA: Or you?
07:46:17 <shapr> Greetings
07:47:23 <dcoutts> hia shapr
07:48:01 <shapr> hia dcoutts
07:49:22 <shapr> dcoutts: Hey, did you see that ATi's first batch of specs from AMD have been turned into a minimal driver already?
07:49:23 <quicksilver> dcoutts: does the macports gtk2hs "just work" ?
07:49:34 <dcoutts> quicksilver: I hear conflicting reports
07:49:37 <quicksilver> shapr: that driver was being worked on before the specs, AIUI
07:49:42 <quicksilver> shapr: (but under NDA)
07:49:51 <quicksilver> shapr: now the specs are public, the NDA expires and it could be published
07:49:57 <dcoutts> shapr: yes, great news, I might be able to upgrade my card some time
07:50:16 <shapr> Still beats the heck out of the nvidia drivers, I had to hack around a bug in those in the last few days.
07:50:25 <quicksilver> shapr: hell yes. It's excellent news.
07:50:27 <dcoutts> shapr: rather than stockpiling old ati radeon 9250's (the last with 3D drivers)
07:50:37 <quicksilver> dcoutts: I have two of those :)
07:50:42 <dcoutts> quicksilver: me too :-)
07:50:51 <quicksilver> dcoutts: unforuntately there is no free driver which does 3D + TV-out at the same time
07:50:52 <dcoutts> they're great, they "just work"tm
07:50:57 <shapr> Yes, I'm looking forward to decent 3D performance and an open source driver!
07:51:01 <dcoutts> ah, never tried tv out
07:51:04 <quicksilver> dcoutts: so I can't run 3D on my TV-box
07:51:13 <quicksilver> dcoutts: I want to write openGL games for my media centre :)
07:51:35 <dcoutts> I like the dual out, dvi + vga so I can run my flatscreen and an old crt
07:52:43 <shapr> I have dual dvi, two flatscreens. This motherboard can do SLI, so I may end up with four!
07:53:28 <shapr> But I'm not going to buy another nvidia graphics card if these drivers pan out.
07:53:52 * quicksilver nods
07:55:54 <phobes> Aren't ATI cards currently way behind nVidia?
07:55:59 <sioraiocht> > foldr ((+) . (\n -> 1)) [1..5]
07:56:01 <lambdabot>   add an instance declaration for (Num [t])
07:56:01 <lambdabot>     In the expression: 1
07:56:01 <lambdabot>     In a...
07:56:10 <phobes> (for high end 3D applications)
07:56:53 <sioraiocht> > foldr ((+) . (\n -> 1)) 0 [1..5]
07:56:55 <lambdabot>  5
07:57:09 <sioraiocht> @pl foldr ((+) . (\n -> 1)) 0 [1..5]
07:57:09 <lambdabot> foldr ((+) . const 1) 0 [1..5]
07:57:42 <sioraiocht> @pl foldr ((+) . (\n -> 1)) 0
07:57:42 <lambdabot> foldr ((+) . const 1) 0
07:57:46 <nominolo> :t const (+)
07:57:47 <sioraiocht> useless=p
07:57:48 <lambdabot> forall a b. (Num a) => b -> a -> a -> a
07:58:07 <sioraiocht> :t const
07:58:09 <lambdabot> forall a b. a -> b -> a
08:00:22 <olsner> hmm... foldr ((+) . const 1) 0 == sum . map (const 1) == length, right?
08:02:38 <nominolo> @pl fix (\f xs -> if null xs then 0 else 1 + f (tail xs) )
08:02:38 <lambdabot> fix (ap (flip if' 0 . null) . ((1 +) .) . (. tail))
08:02:57 <nominolo> > fix (\f xs -> if null xs then 0 else 1 + f (tail xs) ) [3..5]
08:02:59 <lambdabot>  3
08:03:12 <dcoutts> hia pgavin
08:03:17 <pgavin> hi
08:03:35 <pgavin> glad you're here :)
08:03:39 <dcoutts> @arr!
08:03:39 <lambdabot> I'll crush ye barnacles!
08:03:41 <dcoutts> :-)
08:03:44 <pgavin> lol
08:04:01 <nominolo> @check length x == fix (ap (flip if' 0 . null) . ((1 +) .) . (. tail)) (x :: [Int])
08:04:02 <lambdabot>   Not in scope: `x'
08:04:06 <shapr> phobes: Yeah, but an open source driver won't suck like the nvidia drivers.
08:04:10 <nominolo> @check \x -> length x == fix (ap (flip if' 0 . null) . ((1 +) .) . (. tail)) (x :: [Int])
08:04:11 <lambdabot>   Not in scope: `if''
08:04:16 <nominolo> heh
08:04:43 <pgavin> dcoutts: I was thinking about making the cabal package build the default setup executable along with the library
08:05:05 <dcoutts> pgavin: you mean cabal-setup
08:05:16 <dcoutts> cabal-setup is a separate prog at the moment
08:05:25 <pgavin> oh
08:05:26 <pgavin> ok
08:05:28 <sioraiocht> @src fix
08:05:29 <lambdabot> fix f = let x = f x in x
08:05:30 <pgavin> why is that?
08:05:36 <dcoutts> not entirely sure
08:05:41 <pgavin> ok
08:06:02 <pgavin> well, I'm working on building executables with the build system
08:06:23 <quicksilver> dcoutts: I will try macports gtk2hs and let you know
08:06:26 <quicksilver> dcoutts: not today though :)
08:06:29 <pgavin> and it seems to me it would be best to install the library in-place and build executables against the compiled lib
08:06:29 <dcoutts> quicksilver: ok
08:06:55 <dcoutts> pgavin: that's one of the problems with executables in the same packages as libs
08:07:06 <dcoutts> pgavin: that they have direct access to the source, not going via the lib
08:07:28 <dcoutts> which means it's good for test progs that can access hidden modules, but bad because we have to build the code twice
08:07:52 <pgavin> exes shouldn't be used for test progs though
08:07:52 <shapr> phobes: I first started using the nvidia linux drivers on an Athlon MP, and they didn't handle SMP well. This week I ran across a years old bug in the EDID handling that seems to have been partially, but never completely, fixed. I'd rather have slower 3D that works (and that I can fix) instead of 3D that works really quickly only if I'm using the most common hardware/software.
08:08:59 <nominolo> @pl let f x = f x in f
08:08:59 <lambdabot> fix id
08:09:09 <dcoutts> pgavin: maybe, lots of people do that though
08:09:37 <pgavin> dcoutts: maybe those kinds of progs should have a different entry in the cabal file
08:09:55 <dcoutts> pgavin: mm, yes maybe so
08:10:40 <pgavin> dcoutts: well, so I was thinking about building each executable in the subdir dist/build/<exename>
08:10:57 <sioraiocht> :t fix id
08:11:00 <dcoutts> pgavin: yes, that's roughly what we do at the moment
08:11:00 <lambdabot> forall a. a
08:11:05 <sioraiocht> fix id "a"
08:11:13 <sioraiocht> > fix id "a"
08:11:18 <lambdabot>  Exception: <<loop>>
08:11:23 <pgavin> then we can use ghc --hide-all-packages -package-conf inplace.conf -package <current-package-name>
08:11:41 <Shurique> @pl \ f n -> foldr (.) id (replicate n f)
08:11:41 <lambdabot> (foldr (.) id .) . flip replicate
08:24:16 <shapr> mmm, code
08:24:29 <shapr> Is there a tutorial on how to write interpreters in Haskell?
08:24:50 <pgavin> i think there's a scheme interpreter tutorial
08:24:59 <matthew_-> njbartlett: sorry, I have a rubbish irc connection here
08:25:01 <pgavin> write a scheme in 21 days or something
08:25:12 <matthew_-> njbartlett: err yeah, so what time should we get there?
08:25:21 <njbartlett> matthew_-: About 6, is that okay?
08:25:24 <matthew_-> fine
08:25:32 <matthew_-> you'll be there putting up signs and stuff?
08:25:37 <shapr> I'll check it out, I was wondering if something already existed that illustrated how to stack monads to write an interpreter, something like All About Monads Part III
08:25:50 <pgavin> yes, that's exactly what it does
08:26:18 <njbartlett> matthew_-: I'll be setting up my video stuff, and hopefully Ross will have the sign up and clear people through the front desk
08:26:34 <shapr> ah spiffy
08:26:37 <matthew_-> cool, ok.
08:26:50 <njbartlett> Room number is A205
08:27:06 <gattocarlo> I'm writing the bindings for xmms_remote_* API (to write an audacious client) and I'm having problems with GList: how can I insert elements - and how I correctly handles the type of data to be inserted?
08:27:15 <pgavin> shapr: hmm, actually maybe I was thinking about a different one
08:27:27 <pgavin> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/variables.html
08:27:29 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/2hujmc
08:27:37 <pgavin> that's the one I was talking about
08:27:55 <pgavin> that one uses IORefs though
08:28:51 <doserj> it is also on en.wikibooks.org
08:29:08 <pejo> shapr, there's a tutorial by some german guy (iirc) that stacks reader/writer and probably another one. But I can't remember the name of it.
08:29:29 <shapr> Got any more info on that?
08:29:49 <shapr> pgavin: Thanks, I'll check out scheme in 48 hours.
08:30:04 <pgavin> shapr: np :)
08:30:05 <pejo> @goog writert readert haskell monad site:.de
08:30:07 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.lhs
08:30:09 <shapr> aha!
08:30:09 <quicksilver> gattocarlo: I think that's a very intersting question
08:30:14 <shapr> pejo: Thanks!
08:30:20 <quicksilver> gattocarlo: I'm not familiar with the struct-marshalling stuff
08:30:25 <pejo> shapr, could be that one, you'll see if it's trying to construct some kind of interpreter.
08:30:31 <shapr> I'll check it out.
08:30:32 <pgavin> that's the one I was just googling for :)
08:30:38 <quicksilver> gattocarlo: I think there might be interesting questions about who's responsibility it is to free() the nodes you add
08:31:45 <gattocarlo> quicksilver: yes, indeed. I've seen gtk2hs code, but that doesn't make thing clearer very  much actually...
08:39:44 <dcoutts> who's going to the London HUG meeting tonight?
08:39:49 <shapr> me!
08:39:51 <shapr> ok, not really.
08:39:56 <shapr> I wish.
08:39:57 * vincenz wants to see movies
08:40:00 <dcoutts> http://www.londonhug.net/
08:40:02 <lambdabot> Title: Î»ondon HUG
08:40:03 <exDM69> too bad I'm not in london :(
08:40:03 * vincenz is a bit far to go
08:40:05 <quicksilver> gattocarlo: I think you should maybe ask dcoutts then ;)
08:40:07 * dcoutts heads out to catch a train
08:40:11 <vincenz> too bad I'm in the opposite side of europe
08:40:18 <quicksilver> gattocarlo: but not now, evidently
08:40:37 <shapr> Now that I don't need to save money to move to Sweden, I'm tempted to do an audreyt and fly around the world and hack.
08:40:59 <pejo> shapr, not coming back?
08:41:21 <shapr> pejo: Nah, she ended our relationship three days before my migrationsverket interview.
08:41:32 <pejo> shapr, ouch. Sorry to hear that.
08:41:37 <shapr> Yeah, me too.
08:42:15 <shapr> It's been a week, since she ended our three year relationship, I'm trying not to fall into a depressed puddle.
08:42:36 <shapr> Monad transformers never reject someone!
08:42:55 <pejo> shapr, true! It's usually the type checker that does the rejection!
08:42:58 <shapr> haha!
08:43:03 <sebell> Mine get jealous of the inner monad.
08:43:06 * shapr laughs
08:46:20 <gattocarlo> quicksilver: yes, I will. Thank you though. (I'm reading more carefully gtk2hs and ... who knows maybe I find my way...:)
08:46:21 <chessguy> @pl \x y -> 1 + y
08:46:21 <lambdabot> const (1 +)
08:46:35 <chessguy> @src succ
08:46:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:46:50 <chessguy> @hoogle succ
08:46:52 <lambdabot> Prelude.succ :: Enum a => a -> a
08:46:52 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
08:46:52 <lambdabot> System.Exit.ExitSuccess :: ExitCode
09:09:01 <vincenz> the issue is that not all Num's are enumerable
09:22:46 <quicksilver> I think too many Nums are enumerable
09:22:52 <quicksilver> I think the Num instance for Double is quite bogus :P
09:23:07 <vincenz> I'm numb thinking about that
09:23:19 <DRMacIver> quicksilver: I presume you mean the enumerable instance?
09:23:26 <quicksilver> DRMacIver: sorry, I did
09:23:39 <quicksilver> it exists so you can do [2.0,2.5..6.0]
09:23:52 <quicksilver> but I think that should be a different type class
09:30:46 <byorgey> > succ 3.1
09:30:49 <lambdabot>  4.1
09:45:03 <puusorsa> :t succ
09:45:06 <lambdabot> forall a. (Enum a) => a -> a
09:55:29 * kyevan frowns at Hugs
10:22:09 <wootles> say i have a function such as f k n = sum[ f (k-1) n | n<-[n,(n-k),..0] ]
10:22:26 <wootles> having base cases at k = 0
10:23:10 <glguy> wootles: no comma after n-k
10:23:24 <glguy> unless that isn't the problem you were about to ask :)
10:23:34 <wootles> i want to calculate f 200 200, but this will take about one year , because there is no memorisation
10:24:46 <wootles> what i would like to do, is calculate [f 0 n | n<-[1..200] ] , then use that to calculate [f 1 n | <-[1..200]], and so on... calculating 'forwards' from f 0 n to f 200 n, rather than 'backwards'
10:25:45 <wootles> that way i can get f n n in  O(n^3) rather than O(e^n)
10:26:56 <wootles> what is the best way to go about making haskell do this ?
10:28:14 <kpreid> wootles: use a list
10:28:33 <kpreid> oh, hm, two parameters
10:29:12 <sjanssen> wootles: use Okasaki's memoizing fixpoint
10:29:14 <wootles> i need an infinite list of infinite lists
10:29:20 <kpreid> should still work with nested lists...
10:29:55 <kpreid> classic fibonacci: fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
10:30:20 <kpreid> do the same sort of thing with your function, two levels of lists
10:30:32 <mauke> what is f 0 n?
10:30:39 <kyevan> Why does Hugs not like so many things? And GHCi uses the Windows console, which is just... ew :(
10:30:44 <wootles> a constant
10:30:56 <sjanssen> wootles: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
10:30:59 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/u45vz
10:33:03 <wootles> kyevan: can't you get something to replace the windows console ? it would just have to redirect stdin/stdout
10:34:22 <mauke> does 69005687856 look right for f 200 200 with constant = 42?
10:34:45 <mauke> oops, that's f 100 100
10:34:54 <mauke> f 200 200 is 1976553481328538
10:35:04 <kyevan> wootles: stdin and stdout? You've not used windows much, have you?
10:35:28 <kyevan> You handle the console by api calls, not writing to streams
10:36:19 <wootles> you can redirect stdin and stdout when spawning a process
10:37:22 <hpaste>  mauke pasted "f 200 200" at http://hpaste.org/2826
10:37:35 <mauke> keep in mind that I wrote this without using my brain
10:39:21 <wootles> if f 1 _ = 1,  then f n n = number of ways to express n as a sum of positive integers
10:40:39 <wootles> eg f 5 5 = 7  == length [ 5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1 ]
10:42:05 <wootles> kyevan: i think windows works just like unix wrt to stdin/stdout... you can provide a 'file descriptor' when you spawn a process to redirect them, I used it for an othello game (for IPC between frontend + AI engine)
10:43:07 <mauke> in that case, f 200 200 == 3972999029388
10:43:25 <wootles> kyevan: so if you were going to run ghci at the windows command line, you could redirect its stdin/stdout to a nicer interface than the ugly cmd.exe one
10:44:15 <dylan> or just install rxvt
10:48:11 <wootles> mauke: on my interpreter it is taking O(2^n) time ... f 4 4 takes 3 seconds, f 5 5 takes 6, etc  .. weird
10:48:34 <dino-> Can you do that? Install rxvt for Windows and then run bash from cygwin in it?
10:48:45 <mauke> wootles: compile with ghc -O2
10:51:43 <byorgey> wootles: the best way I know to compute that function is Euler's recurrence:
10:51:49 <byorgey> see equation (11) on http://mathworld.wolfram.com/PartitionFunctionP.html
10:51:50 <lambdabot> Title: Partition Function P -- from Wolfram MathWorld
10:51:57 <wootles> mauke: that fixed it, thanks
10:52:43 <nomeata> Hi. Iâm trying to model a graph in haskell with various contained types, and functions between them as edges. What are my choices, besides putting all the types in one algebraic type?
10:54:31 <dylan> dino-: rxvt is a cygwin package
10:55:40 <nomeata> Simple example: Given three functions "show", "read", "(*2)", I want to store the graph (a::String) ââ (b::Int) â (c::Int), whereas the first two edges are labeled show and print, and the third (*2).
10:58:13 <kpreid> nomeata: Data.Dynamic?
10:58:27 <kpreid> if your types are all simple like that, might work well
10:59:40 <nomeata> kpreid: thx for the tip
10:59:53 <quicksilver> Data.Dynamic is, essentially, an existential box
11:00:00 <quicksilver> using Typeable a=> as the constraint
11:00:01 <quicksilver> I think
11:00:06 <wootles> mauke: it works in the interpreter if i make the array etc 'global'
11:00:16 <quicksilver> you might find a different existential box suits you better. or not.
11:00:29 <mauke> ah
11:00:42 <mauke> lack of sharing
11:00:42 <kpreid> indeed, for example if you want all your nodes showable, you'll want a different box
11:00:49 <b_jonas> in haskell, what's the best way to have an infinite list of unequal values that can be used as a key to a map
11:01:03 <mauke> like [0 ..]?
11:01:04 <b_jonas> ?
11:01:07 <quicksilver> b_jonas: [1..] ?
11:01:11 <b_jonas> sort of, but possibly more efficent
11:01:18 <quicksilver> more efficient how?
11:01:20 <mauke> define "efficient"
11:01:37 <wootles> you want a hash ?
11:01:37 <b_jonas> more efficent by runtime speed and maybe memory usage
11:01:44 <b_jonas> no, not a hash
11:01:48 <kpreid> infinite structures of any sort can't be used as keys, unless your map type assumes that there are no misses
11:01:55 <quicksilver> [1..] takes up almost no space...
11:01:57 <b_jonas> but if those numbers get too large, I assume comparision can get too large
11:02:09 <b_jonas> comparision of two such integers
11:02:18 <quicksilver> well how many are you likely to store?
11:02:27 <quicksilver> if you've stored more than 4 billion unique items in your db...
11:02:30 <b_jonas> not much at once, but most of them can be discarded
11:02:34 <b_jonas> gced that  is
11:02:36 <quicksilver> the fact that your key size has gone up...
11:02:38 <kpreid> b_jonas: wait, do you want to use the *list* as a key, or the *members* of it as a key?
11:02:53 <b_jonas> in a non-pure language, you could just use a pointer comparision
11:02:54 <quicksilver> I interpreted it as a 'unique supply' list
11:02:58 <b_jonas> and the pointers would get gced
11:03:02 <b_jonas> kpreid: the numbers
11:03:06 <kpreid> check out Data.Unique
11:03:06 <b_jonas> the members that is
11:03:08 <wootles> why would you use a map, if your keys can be [1..] ? why not an array or list
11:03:17 <quicksilver> wootles: because it's going to be sparse
11:03:22 <b_jonas> yep
11:03:24 <quicksilver> wootles: he's going to throw most away
11:03:28 <b_jonas> I'd like something like symbols
11:03:29 <wootles> ahh
11:03:38 <quicksilver> b_jonas: I think [1..] will be just fine
11:03:41 <kpreid> b_jonas: Data.Unique sounds perfect if you can stand being in IO
11:03:57 <b_jonas> I'll look Data.Unique up
11:04:07 <b_jonas> thanks
11:04:09 <wootles> there is no sparse array ?
11:04:18 <kpreid> b_jonas: they grow as log(n) after all
11:04:20 <kpreid> b_jonas: but also, integers would not be very bad
11:04:46 <b_jonas> kpreid: yep, but I don't know how bignums are implemented, and they might be optimized for the <=2^30 case or something
11:04:55 <b_jonas> that is, they could get much worse after I reach 2^32 or something
11:05:16 <kpreid> b_jonas: so as a test case, start your unique supply at 2^32!
11:05:37 <quicksilver> they get a little worse
11:05:44 <quicksilver> but I don't think comparing bignums is slow
11:05:53 <quicksilver> they're still pretty compactly stored
11:05:57 <b_jonas> on the other hand, for all I know they could be implemented so that they get worse only after 2^64
11:06:11 <b_jonas> in which case they're good for this use
11:06:37 <wootles> mauke: to make it explicit that the array is to be shared, i have to make it 'global' ?
11:07:00 <wootles> i want a static local :D
11:07:05 <quicksilver> wootles: you'd just have to place it in a scope which both functions could reach
11:07:13 <mauke> it's just ghci being stupid
11:07:17 <quicksilver> wootles: which you can do by passing it as an argument
11:07:36 <kpreid> wootles: if you want a "static local", just don't export it from your module.
11:07:52 <mauke> kpreid: that's a "static global"
11:10:03 <b_jonas> Data.Unique looks fine according to the docs, thanks
11:10:33 <wootles> mauke: the one problem is that it evaluates the entire matrix to do even f 2 2
11:10:48 <nomeata> kpreid: well, I want to query the edges using a certain class, query the vertices using another class, and the edge class functions refer to the appropriate vertex types. (if thatâs clear)
11:11:24 <kpreid> no, not clear at all :)
11:11:49 <kpreid> you mean type classes of which all of your vertexes, say, are instances?
11:12:19 <psnively> Hey guys. What would the Haskell web app stack to compete with Rails be? WASH + HaskellDB? I keep hearing that HaskellDB is dead, though.
11:12:35 <mauke> wootles: are you sure? it's supposed to be lazy
11:12:50 <nomeata> kpreid: yes
11:13:14 <nomeata> kpreid: (sorry telephone)
11:13:16 <kpreid> nomeata: okay, you want to define your own existential box then.
11:13:49 <kpreid> hm...said box might actually be the same as your vertex type.
11:13:50 <psnively> Is an existential box a quantum box? :-)
11:14:24 <wootles> mauke: ideally, it would have an infinite 2d matrix
11:15:25 <mauke> hmm. can't use an array for that.
11:15:28 <mauke> and then I'd have to use my brain
11:17:58 <psnively> No comments on WASH and HaskellDB (or alternatives)?
11:18:28 <dons> I'd use HAppS
11:18:51 <dons> psnively: that's the main commercially supported haskell web framework. WASH is also used for these things too (see braintreehemp.com.au as an example site)
11:19:05 <dons> hpaste.org runs on happs, braintreehemp.com.au runs on WASH
11:19:06 <psnively> Gotcha, thanks, dons. :-)
11:19:29 <hagman> #ocaml
11:20:56 <dons> hagman: #haskell
11:21:35 <psnively> #ocaml and #haskell
11:22:31 <b_jonas> another related question: is there a module for weak maps, that is, maps (or hashes) that cannot be traversed?
11:23:01 <nominolo> @localtime dons
11:23:02 <lambdabot> Local time for dons is Thu Sep 20 11:20:31 2007
11:24:22 <CosmicRay> how does lambdabot do that?
11:24:45 <balodja> /ctcp <nick> time
11:25:30 <mauke> @localtime CosmicRay
11:25:32 <lambdabot> Local time for CosmicRay is Thu Sep 20 13:24:42
11:25:49 <CosmicRay> ah.
11:26:07 <twanvl> b_jonas: Why would you want that? If you don't want to traverse a map, then don't traverse it.
11:26:29 <nomeata> kpreid: ok, assume I have class Vertex a, and class Edge a b for an edge from a vertex of type a to a vertex of type b
11:26:37 <b_jonas> twanvl: so that the pairs with a gced key get gced
11:27:09 <glguy> b_jonas: there isn't a reason that a new instance of tha tkey couldn't be created later
11:27:11 <nomeata> kpreid: how do I pack that in a nice graph data structure?
11:27:26 <kpreid> nomeata: I don't know about graph libraries in Haskell
11:27:39 <nomeata> hmm, ok.
11:27:40 <b_jonas> glguy: hmm, that's true
11:27:41 <phobes> b_jonas:  That's a stronger condition than just a map that cannot be traversed, right?
11:27:43 <kpreid> but assuming a define-it-yourself-in-the-obvious-way:
11:27:51 <b_jonas> so pureness means you cannot do that?
11:27:51 <kpreid> something like:
11:28:11 <b_jonas> phobes: yep, if you have referential transparentness
11:28:22 <mauke> there was a paper about that
11:28:26 <quicksilver> @where hopengl
11:28:27 <lambdabot> http://haskell.org/HOpenGL/
11:28:52 <quicksilver> hmph
11:28:58 <quicksilver> that's sort-of out of date I think
11:29:20 <kpreid> nomeata: data Vertex' = forall a. Vertex' a [Edge'] [Edge']; data Edge' = forall a b. Edge' (a -> b) Vertex' Vertex'
11:29:23 <kpreid> nomeata: this graph rep doesn't represent cycles such that you can follow them
11:29:25 <glguy> b_jonas: its not pureness, its that there is no way for GHC to know you are done with the value
11:29:27 <kpreid> s/follow/detect
11:29:39 <kpreid> nomeata: but it does show you existentials
11:29:46 <glguy> b_jonas: if you don't tell it that you are, but still hold it in a collection
11:30:00 <b_jonas> glguy: yes, it's referential transparetness, but that's more or less implied by pureness
11:30:45 <glguy> no, its lack of magic
11:30:49 <mauke> b_jonas: possibly relevant: http://research.microsoft.com/Users/simonpj/Papers/weak.htm
11:30:50 <lambdabot> Title: Simon Peyton Jones: papers
11:30:58 <phobes> b_jonas:  what you're asking just doesn't make much sense I think... A map maps *values* onto values, not *objects* onto values
11:31:08 <nomeata> kpreid: but this way it is not ensured that the typ of the edges fit the the type of the vertices, right?
11:31:16 <phobes> so it's not like you can garbage collect part of the map when an *object* in its domain goes away
11:31:34 <phobes> Because the value will never "go away" (you could always recreate it)
11:31:37 <kpreid> nomeata: whoops, what I gave won't work at all
11:31:55 <kpreid> because you can't find out that the node and edge are the same
11:31:55 <kpreid> types
11:32:00 <psnively> Wow. HAppS looks pretty rockin'.
11:32:08 <b_jonas> phobes: yes, but in a language that's not referentially transparent, you can have gced types for which value equality is the same as obj equalty
11:32:11 <kpreid> you need to add Typeable to the context and use cast
11:32:24 <b_jonas> and you can use them as keys
11:32:35 <kpreid> hmm
11:32:41 <glguy> What is an example of this in another language?
11:32:55 <phobes> b_jonas:  I refuse to recognize those as "values" :)
11:32:57 <nomeata> kpreid: hmm, ok, but thatâs about as nice as an algebraic type, I think.
11:32:58 <b_jonas> glguy: lua, some schemes and lisps
11:32:59 <kpreid> nomeata: I think in order to enforce it you'd need a totally different structure...
11:33:04 <kpreid> let's see
11:33:07 <b_jonas> phobes: not haskell values, yes
11:33:17 <b_jonas> because haskell is referentially transparent
11:33:38 <phobes> b_jonas:  right, I mean referential transparency is tied to my understanding of "value"
11:33:41 <b_jonas> you can say "I refuse to recognzie impure functions as functions"
11:33:47 <phobes> sure :)
11:34:02 <phobes> I'm only joking when I say I refuse to recognize ...
11:34:14 <b_jonas> phobes: well, in that case I'd like a data structure that maps _objects_ to values
11:34:15 <psnively> I refuse to recognize "functions" that take and/or return more than one value as functions. ;-)
11:34:19 <b_jonas> and are weak
11:34:36 <phobes> b_jonas:  then you'll have to be in a monad I think
11:34:54 <psnively> In Haskell, you're in a monad anyway! ;-)
11:35:02 <kpreid> nomeata: data Graph = Graph [Vertex'] [Edges]; data Edges = forall a. (Typeable a, Vertex a, Typeable b, Vertex b) => Edges (a -> b) [(a,b)] -- might need another box in place of the (a,b) tuple, I'm not sure
11:35:12 <b_jonas> phobes: yes, looks like that
11:35:20 <kpreid> hrm, that's not quite right
11:35:32 <glguy> Monads aren't going to give you magic to know when a valu edoesn't exist any more
11:35:36 <dons> http://squing.blogspot.com/2007/09/haskelling-saco-1.html
11:35:37 <lambdabot> Title: The Most Fuun You Can Have: Haskelling the SACO 1
11:35:42 <kpreid> data Graph = Graph [Vertex'] [Edges]; data Edges = forall a. (Typeable a, Vertex a, Typeable b, Vertex b) => Edges [(a,a->b,b)]
11:35:43 <glguy> and there is no object equality
11:35:48 <kpreid> like that
11:36:05 <glguy> or "reference equality" or whatever
11:36:12 <kpreid> any given Edges object stores all the edges in a graph with the same in and out vertex types
11:36:23 <phobes> glguy:  True, you'd probably need to explicitly delete the objects
11:36:31 <bitwiseshiftleft> anyone here have experience with xml in haskell?
11:36:36 <b_jonas> glguy: just monads won't
11:36:45 <nomeata> kpreid: hmm. thanks for the help, but I think Iâll go with an algebraic type
11:36:47 <dons> bitwiseshiftleft: haxml or hxt seem to be widely used
11:36:56 <b_jonas> but you may still need monads to have pure semantics and that magic
11:37:04 <b_jonas> in fact I think you do
11:37:09 <quicksilver> @index withArray
11:37:09 <b_jonas> but I'm not sure how much of them
11:37:09 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
11:37:16 <b_jonas> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html looks promising
11:37:19 <lambdabot> http://tinyurl.com/3a7rbs
11:37:35 <bitwiseshiftleft> dons: i've been using haxml, but its parser is insanely slow... do you know if hxt's is any better?
11:37:51 <dons> hmm. you really want a bytestring xml parser. i'm not sure we have one yet.
11:38:01 <dons> there might be some other parsers on hackage though
11:38:06 <Lemmih> @seen mnislaih
11:38:06 <dons> and consult the mailing list
11:38:06 <lambdabot> I saw mnislaih leaving #haskell and #ghc 8d 56m 5s ago, and .
11:39:08 <bitwiseshiftleft> dons: ok, thanks.  ~1 second to parse a 100k xml file is kind of ridiculous
11:39:20 <phobes> glguy:  Actually, you could get garbage collection in a monad, but that monad would end up being an interpretter for a sub language :)
11:39:53 <b_jonas> phobes: yes, that's true
11:40:53 <quicksilver> dons: when using an idiom like 'withArray' which you feed a "list", often a list comprehension, is it feasible to completely eliminate all traces of actual list construction?
11:41:29 <dons> there's a lot of work with rules and the Array types to make that work, iirc
11:41:52 <quicksilver> dons: but it has to be special cased, basically?
11:41:55 <sjanssen> quicksilver: seems tricky, you have to know the length before-hand
11:41:56 <dons> bitwiseshiftleft: yeah, bytestring xml parser, or a binding to libxml or somehting would be super super nice. andyjgill worked on something like that, iirc
11:42:05 <quicksilver> dons: you can't hope for it as a free lunch of some fusion system?
11:42:27 <sjanssen> quicksilver: foldr/build can do that for free (streams can too)
11:42:35 <sjanssen> if you can get around the length problem
11:42:50 <quicksilver> but only if the "Array builder" is a foldr
11:42:56 <quicksilver> and typically it will be a mapM
11:42:58 <quicksilver> not a foldr
11:43:06 <quicksilver> cos it's doing effects to stuff the values into something
11:43:24 <sjanssen> wait, are we talking about the same thing?
11:43:28 <sjanssen> @hoogle withArray
11:43:32 <lambdabot> Foreign.Marshal.Array.withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
11:43:32 <lambdabot> Foreign.Marshal.Array.withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
11:43:32 <lambdabot> Foreign.Marshal.Array.withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
11:43:53 <sjanssen> we're talking about fusing the [a] away, right?
11:44:37 <quicksilver> yes
11:44:51 <quicksilver> and the [a] is used to build a Ptr thing in memory
11:44:56 <sjanssen> right
11:45:00 <quicksilver> which I presumse is something like mapM (poke...)
11:45:15 <sjanssen> it is pretty easy to write a fusible withArrayLen
11:45:40 <bitwiseshiftleft> aight, thanks for the recs on xml parsing
11:47:32 <sjanssen> withArrayLen len xs f = do p <- malloc len; foldr (\y ys i -> if i == len then return () else do pokeOffset p i y; ys (i+1)) (const $ return ()) xs 0; f p; free p
11:47:46 <sjanssen> quicksilver: ^^^ that will fuse with all good producers
11:47:52 <quicksilver> ah, nice
11:48:13 <quicksilver> without the length can't you do the standard imperative trick of a doubling-buffer?
11:48:21 <quicksilver> and a couple of IORefs?
11:48:22 <sjanssen> IIRC, sequence and friends are good consumers already
11:48:28 <sjanssen> quicksilver: yeah, you could do that
11:49:03 <quicksilver> cool. thanks
11:50:41 <sjanssen> you can write that even more directly with streams fusion, because it doesn't restrict you to foldr
11:51:17 <sjanssen> in fact, withArray is essentially the same as the core 'unstream' function for ByteStrings
11:55:31 <sjanssen> dons: I lost track, is streams fusion in ghc 6.8?
11:58:21 <dons> for lists, no.
11:59:53 <sjanssen> dons: ah, too bad.  I just realized that 'withArray' is essentially the same as ByteString's unstream -- so of course stream fusion would be great there ;)
12:03:51 * Cale can't wait for the day all memory is non-volatile. Power goes off for one second => Computer goes off completely => No alarm clock.
12:05:43 <Cale> Yay, more catsters videos!
12:06:28 <shapr> Cale: My nokia 770 was mostly reliable.
12:08:47 <lament> Cale: solution: don't use your computer as an alarm clock? :)
12:09:24 <flux> solution2: set the computer to start up on power recovery from the bios
12:09:28 <flux> solution3: ups ;)
12:09:33 <lament> there's beauty in low-tech solutions... in this case, low-tech could mean a digital alarm clock :)
12:09:35 <Cale> Yeah, that works. Still it would be rather nice if when your computer powered back on, it didn't lose any state.
12:10:40 <flux> there was this operating system that did that
12:10:56 <lament> Tunes? :)
12:10:56 <flux> well, it would lose some state, because it didn't require non-volatile memory
12:14:08 <b_jonas> so an underscore at the beginning of an identifier counts as a lowercase in haskell (like in ruby but unlike prolog)
12:16:22 <b_jonas> makes sense because a lone _ means sort of the similar thing
12:16:30 <b_jonas> (as in prolog I mean)
12:18:07 <swix_> alright, this is going to sound like a stupid question, but I'm working through haskell tutorials and everytime I get to a part where I define a function GHCI gives me a parse error, eg: > f = putStr "Hello"    ....  <interactive>:1:2: parse error on input `='    I have to clue what I'm doing wrong, since it's rather verbatim
12:18:24 <CosmicRay> put "let" before it
12:18:37 <phobes> Cale:  You need to get an alarm clock program that embeds itself (and your current settings) in the BIOS
12:18:48 <mauke> swix_: put it in a file
12:18:55 <CosmicRay> I think he just needs an alarm clock.
12:19:20 <phobes> I suppose recording the current settings to disk could also work... ;)
12:19:33 <swix_> mauke, still a parse error
12:19:33 <phobes> Then you've just got to get the computer to boot itself back up and reload the alarm clock program
12:19:55 <mauke> swix_: what exactly did you do, and what's the error?
12:20:21 <b_jonas> but most computers can boot at a given time using the CMOS
12:20:39 <b_jonas> most contemporary PCs that is
12:20:49 <phobes> b_jonas:  Cool, if Cale's computer is as noisy as mine, he can use _that_ as his alarm clock
12:21:25 <b_jonas> why, isn't it easier to just use speakers?
12:23:05 <swix_> mauke: in Test.hs; module test \n\t where \n f = 5 * 5 \n EOF then I go ghci Test.hs and get "Test.hs:1:7: parse error on input `test'"
12:23:42 <mauke> remove the "module test where"
12:24:18 <swix_> heh, that works, thanks
12:24:55 <kpreid> swix_: "module Test" would have worked
12:25:49 <b_jonas> that's not surprising though: wakeup from keyboard or ethernet is also a feature of some motherboards, but wakeup on time is very easy to implement because the cmos keeps track of (its version of) the real time anyway so it just has to compare it and send some singnal to the motherboard to wakeup
12:26:20 <shapr> Cale: What about an Arduino alarm clock?
12:26:50 <beelsebob> b_jonas: and how hard is a comparison to do without a CPU?
12:27:14 <b_jonas> beelsebob: as hard as incrementing the timer every second or something
12:27:28 <b_jonas> beelsebob: note that in theory it could be compared to a constant
12:27:34 <beelsebob> b_jonas: and as hard as comparing input from the USB bus, or the ethernet bus?
12:28:14 <b_jonas> beelsebob: no, easier because there you have to do a string compare on incrementally arriving data
12:28:17 <b_jonas> or something like that
12:28:28 <b_jonas> whereas in the clock you have all the data there
12:29:22 <beelsebob> I don't see the difference between comparing the MAC in a packet with a stored one, and comparing your time with a stored one
12:29:30 <b_jonas> in fact, the others aren't so difficult as well if you keep those devices (the ethernet card etc) under power
12:29:38 <jatqceer> what can i do with the segmentation fault?  I didn't use any unsafe* thing
12:29:41 <b_jonas> but you want to do this with low power consumption
12:30:00 <b_jonas> beelsebob: you have to recognize packets too
12:30:12 <beelsebob> true, but the network card will do that
12:30:22 <b_jonas> yep, but you have to make it not consume much power
12:30:32 <b_jonas> I'm not saying it's difficult with today's technology
12:30:36 <beelsebob> yeh, which is why PCI has a low power part of the standard
12:30:41 <b_jonas> but you could have wakeup on time in a 286
12:30:51 <beelsebob> true
12:30:51 <b_jonas> no wait not then
12:30:58 <b_jonas> because there were no ATX houses
12:31:12 <b_jonas> so the motherboard couldn't wake the power supply
12:31:29 <b_jonas> let's say 486 or something then
12:31:37 <b_jonas> maybe pentium, I don't know
12:33:01 <iguana_> hi
12:33:35 <jatqceer> can anybody help me with a segmentation fault?
12:33:44 <shapr> jatqceer: Can you hpaste the code?
12:33:50 <iguana_> i'm very new to haskell, but already love it, and i wonder if there's a project which could use my help
12:34:05 <mauke> huhu, you could write a monad tutorial
12:34:10 <jatqceer> shapr: that's probably too big...
12:34:12 <mauke> that's what everyone does
12:34:23 <iguana_> mauke: sure ^^
12:34:28 <shapr> iguana_: Lots of stuff, want to hack on lambdabot some?
12:34:41 <shapr> jatqceer: What does the code do?
12:34:53 <iguana_> shapr: well, what would be needed for lambdabot?
12:35:09 <pejo> shapr, was the tutorial what you were looking for? (Got disconnected last time, sorry).
12:35:12 <shapr> iguana_: You grab the source and look at the TODO file.
12:35:16 <shapr> pejo: Yes, I think so.
12:35:24 <iguana_> good idea ^^
12:36:47 <jatqceer> shapr: receiving data and do some statistical analysis
12:36:57 <shapr> Can you separate the pieces?
12:37:12 <shapr> receive data and save to a file, and separate do statistical analysis?
12:37:23 <shapr> At that point probably only one part or the other will segfault.
12:38:47 <jatqceer> are there some general procedure I could follow to debug this?
12:39:04 <shapr> I'd bet it's happening in the data receiving, but I'm not totally sure.
12:39:14 <shapr> It's unlikely to happen in the statistical analysis at least.
12:39:15 <Cale> jatqceer: are you doing much FFI?
12:39:23 <jatqceer> Cale: no
12:39:54 <Cale> jatqceer: Typically things don't segfault unless there's a compiler bug, or you're calling into some C code which segfaults.
12:40:29 <Cale> Though apparently by writing bad instances of Ix for unboxed arrays, you can cause a segfault (but that could be claimed to be a bug in GHC)
12:41:03 <jatqceer> Cale: i used unboxed array
12:41:06 <Cale> hmm
12:41:44 <jatqceer> I'll try to delete all these `U's first
12:42:21 <Cale> Mutable or immutable?
12:42:48 <jatqceer> STUArray
12:44:18 <jatqceer> still seg faults with STArray
12:47:58 <Cale> aha, are you using unsafeRead or unsafeWrite?
12:48:23 <Cale> Those don't do bounds checking.
12:48:59 <Cale> I can get a segfault to happen using either STArray or STUArray with unsafeRead
12:49:10 <jatqceer> no
12:49:15 <jatqceer> nothing unsafe
12:49:18 <Cale> okay
12:49:40 <Cale> hmm...
12:49:50 <jatqceer> I'm trying to run the code with runhaskell, it's very slow, but no seg fault, yet
12:49:54 <phobes> Did you hexedit the executable ghc produced before you ran it?
12:50:21 <jatqceer> phobes: I'm not as crazy as that
12:50:25 <Cale> hehe
12:53:04 <jatqceer> with runhaskell, the ghc is eating up 100MB of mem.  after 3 minutes, without showing anything, and no sign of seg fault, yet
12:53:38 <jatqceer> i'll go and get a coffee and see what will happen
12:54:18 <phobes> whoa whoa - you didn't say you were drinking coffee.   There's a known ghc bug about that
12:54:24 <shapr> phobes: oy!
12:54:31 * shapr laughs
12:54:42 <shapr> @remember phobes whoa whoa - you didn't say you were drinking coffee.   There's a known ghc bug about that
12:54:42 <lambdabot> Done.
12:56:31 <psnively> Ethiopian or Sumatran?
12:56:34 <psnively> I don't know that!
12:56:38 <psnively> Aieeeeeeeeeeeeeeeeeeeeeeeeee!
12:56:56 <Cale> jatqceer: you might try running it with gdb and seeing if the place where it segfaults is anything informative, but most likely it'll be something like s1Yj_info
12:57:12 <psnively> GHC doesn't have a "debug symbols" option?
12:57:25 * iguana_ looks at Text.Printf and is puzzled
12:57:28 <shapr> What about looking at the STG output?
12:57:38 <shapr> psnively: STG?
12:57:46 <byorgey> WHAT... is your favourite GHC extension?
12:57:49 <psnively> STG?
12:57:59 <shapr> psnively: What are you trying to do?
12:58:15 <psnively> byorgey: overlapping instances. No, wait! STM! Arrrrrrrrrrrrrrrrrrgh!
12:58:15 <shapr> byorgey: GADTs, no NDP, aieee!
12:58:30 <psnively> Heh
12:58:34 <byorgey> =)
12:58:56 <psnively> shapr: Sorry, I was trying to respond to Cale's observation about GDB and the segfault data.
12:59:03 <iguana_> do I see it correctly that the same function can output either to stdout *or* return a string?
12:59:24 <shapr> iguana_: Text.Printf has lots of magic :-)
12:59:39 <iguana_> now that's overloading
12:59:45 <Cale> psnively: Well, normally the symbols are there, it's just that most of them have useless names because they're names of intermediate results generated during compilation.
13:00:14 <psnively> Cale: Ah so.
13:01:15 <Cale> and the profiling tools don't seem to help much with segfaults either.
13:01:53 <Cale> Typically you only get a segfault if you're either doing something really unsafe, using the FFI stuff, or there's a compiler bug.
13:01:54 <phobes> Hmm, looks like it's spending 99% of its time in the 'unsafeSegFault' function
13:01:54 * jatqceer hates segfault
13:02:16 <jatqceer> runhaskell went fine without segfault
13:02:37 <Cale> okay, which Haskell interpreter is runhaskell pointing to?
13:02:42 <jatqceer> now, what should I do?  I can't live on runhaskell
13:02:47 <jatqceer> ghc, apparently
13:02:54 <Cale> How did you compile the program?
13:03:17 <Cale> (the one which segfaulted)
13:03:29 <byorgey> Man does not live on runhaskell alone, but on every word that proceedeth from the mouth of SPJ
13:05:01 <jatqceer> ghc-options:        -fexcess-precision -funbox-strict-fields -O3 -Wall -optl-Wl,-s -optc-O3 -optc-fomit-frame-pointer -optc-pipe -optc-mfpmath=sse -funfolding-use-threshold32
13:05:10 <Cale> Why O3?
13:05:30 <Cale> and what's with omitting the frame pointer?
13:05:36 <jatqceer> for imaginary speed
13:06:11 <jatqceer> I'll try to change the options
13:06:14 <Cale> Try turning those optc options off.
13:06:34 <twanvl> For imaginary speed, try -Oi
13:06:57 <Cale> O2 is the maximum level of optimisation in GHC
13:07:53 <psnively> byorgey: Or his wife. Isn't Mrs. Peyton-Jones a priest?
13:08:11 <byorgey> psnively: is she?  I have no idea.
13:08:18 <psnively> Hmmm
13:08:36 <psnively> Yes.
13:09:08 <psnively> "He is married to Dorothy, a priest in the Church of England, and they have three children."
13:10:15 <psykotic> there must be a lot of religion-based conflicts between them, seeing that he's a cardinal in the Church of Lambda Calculus
13:11:27 <jatqceer> ok, -fasm works
13:11:52 <psnively> psykotic: I doubt it--after all, one of the earliest texts on combinatorics was the Sefer Yeztirah. ;-)
13:11:57 <psnively> Yetzirah, even.
13:12:08 <jatqceer> although very slow
13:12:45 <psykotic> psnively, kabbalah?
13:13:16 <psnively> psykotic: Yes. There's a perfectly dandy description of the factorial in it.
13:14:42 <Cale> jatqceer: I'd stay away from passing too many options to the C compiler -- GHC really only uses GCC as a high level assembler, and it expects particular results from it.
13:15:14 <jatqceer> Cale: so do you think it's a bug in ghc, or gcc?
13:15:43 <psykotic> psnively: i remember borges wrote a very concise apologium for kabbalism, on the premise (which many believers in abrahamic religions seem to accept) that it's a book "infinitely perfect", leaving nothing to mere chance or coincidence. for, his argument goes, in that case obscure numerical relationships cannot be considered accidents but must have purpose, meaning. etc.
13:15:44 <Cale> jatqceer: Maybe it's a bug that GHC even lets you pass some of those options to the underlying GCC :)
13:16:11 <psykotic> psnively, you should check it out, if you like borges :)
13:16:19 <Cale> jatqceer: In any event compilation via C is being phased out.
13:16:43 <psnively> psykotic: I do have a complete Borges, interestingly. I guess that's not that surprising for someone of my interests.
13:17:03 * psykotic thinks all programmers are likely to like borges.
13:17:11 <psnively> Exactly.
13:17:17 <jatqceer> Cale: now, -O2 runs much faster, I'm trying to pin down which particular gcc flag is making trouble
13:17:41 <psnively> psykotic: Borges, Eco, Stephenson: the unholy trinity of geek literature.
13:18:03 <psykotic> it's funny, i read a lot of eco's work before i ever got to borges, and eco seems extremely derivative now.
13:18:30 <psnively> psykotic: What's funny is that Eco himself would almost certainly agree with you--that all the books have already been written.
13:18:30 <psykotic> i think eco's patterning of himself on borges was very conscious.
13:18:38 <psykotic> yes :)
13:19:01 <Cale> jatqceer: I somehow suspect it's -optc-fomit-frame-pointer
13:19:04 <psnively> psykotic: Have you read his essay on "The Name of the Rose?"
13:19:11 <psykotic> yes
13:19:22 <psykotic> i've probably read most of eco's stuff published in english, including essays
13:19:23 <psnively> In it, he basically discusses how he borrowed practically everything, including Borges.
13:19:29 <psnively> Of course.
13:19:55 <psnively> I confess that I failed to pick up on the "Adso" -> "Watson" connection upon first reading.
13:20:05 <psykotic> what eco lacks, and which borges has in profusion, is terseness
13:20:09 <psnively> But I laughed out loud at "Brother William of Baskerville."
13:20:22 <psnively> I don't mind Eco's pacing. In fact, I enjoy it.
13:20:25 <psykotic> anyway, i don't think this is #literature, sorry for the digression guys :)
13:20:39 <psnively> Awwww, but we're talking geek lit!
13:20:41 <psnively> OK, OK
13:23:27 <jatqceer> Cale: you are wrong.  it passes my test
13:23:34 <Cale> hmm
13:27:48 <Cale> ah, okay, apparently GHC might pass that one itself on some architectures. On others it passes -fno-omit-frame-pointer explicitly.
13:28:26 <Cale> Really, the C optimisation flags are not something I'd mess around with. Trust GHC to get them right :)
13:29:34 <iguana_> btw, how does ghc work on windows?
13:29:34 * jatqceer shall never use `-optc-mfpmath=sse' again!
13:30:28 <quicksilver> Cale: except -optc-magic-approved-by-dons
13:30:37 <quicksilver> Cale: that's permitted for shootout entries :)\
13:30:53 <jatqceer> quicksilver: what are these -optc-magic-approved-by-dons
13:31:17 <phobes> iguana_:  it targets MinGW
13:31:18 <Cale> jatqceer: it's a joke
13:31:18 <quicksilver> jatqceer: dons spent some time studying which options get you the best performance for the great compiler shootout problem
13:31:33 <Cale> If you actually know enough details about how the things are being compiled that you can ensure that the options are safe, then you can probably use them.
13:31:35 <quicksilver> jatqceer: you can see which ones he uses on the shootout pages
13:31:44 <quicksilver> @where shootout
13:31:44 <lambdabot> http://shootout.alioth.debian.org/
13:31:54 <jatqceer> quicksilver: thanks
13:31:56 <Cale> But there are things like the evil mangler which possibly make that somewhat tricky to analyse :)
13:32:16 <jatqceer> I can provide an -optc-magic-disapproved-by-jatqceer
13:32:16 <quicksilver> jatqceer: but he did that by inspecting the Core, and then inspecting the C, and then inspecting the asm
13:32:26 <quicksilver> jatqceer: and tracing it all back :)
13:32:31 <jatqceer> that is `-optc-mfpmath=sse'
13:33:27 <iguana_> isn't mingw a bit slow and clunky?
13:34:14 <twanvl> wingw is quite nice, it is cygwin you have to look out for
13:34:35 * quicksilver can't work out how to get the GL examples ina  sensible way and resorts to wget --recursive on darcs.haskell.org
13:34:43 <iguana_> i guess it would be hard to make ghc use the ms compiler?
13:35:20 <Cale> iguana_: There's little point. Targetting C is on its way out, as far as I've heard.
13:35:45 <twanvl> GHC has its own code generator, but it still relies on gcc for the runtime library and linker
13:35:50 <Cale> iguana_: GHC's native code generation is getting good enough that it doesn't have to compile via C anymore.
13:36:05 <quicksilver> the grand plan was always to compile via C-- wasn't it?
13:36:07 <phobes> GHC's code generation being C--?
13:36:14 <quicksilver> but currently that's just used for some parts of the runtime, I think
13:36:19 <augustss> Cale: I never understood targetting C in the first place. :)
13:36:42 <sorear> Haskell -> Core -> STG -> C-- -> C -> ASM -> mangled ASM -> object  (-fvia-C)
13:36:43 <dino-> I thought it was for bootstrapping a system that's never had GHC up to that point.
13:36:53 <sorear> Haskell -> Core -> STG -> C-- -> ASM -> object  (-fasm)
13:36:58 <quicksilver> sorear: does all code go via C--?
13:37:03 <sorear> quicksilver: yes
13:37:03 <dino-> I could be confused about what you guys are referring to, though.
13:37:09 <sorear> quicksilver: -ddump-cmm
13:37:13 <quicksilver> sorear: oh, interesting, I wasn't aware of that
13:37:15 <quicksilver> sorear: cool
13:37:18 <psnively> I wish C-- had more traction. All the cool kids are yakking about LLVM.
13:37:22 <augustss> dino-: You can bootstrap anyway, it's just a little harder.
13:37:45 * sorear has this feeling that lmlc is -fasm-equiv-only
13:37:59 <quicksilver> augustss: wasn't the reason for targetting C "C-- isn't here yet and we don't feel like writing code generators for every chip?"
13:38:05 <augustss> sorear: yes, we never went via C
13:38:11 <phobes> 'Core' is close to the language described in SPJ's paper on compiling lazy functional languges?
13:38:34 <quicksilver> phobes: Core is very much like haskell without syntactic sugar, and with explicit Type-level applications
13:38:45 <sorear> quicksilver: C as portable assembly predates C-- by decades
13:38:56 <quicksilver> sorear: that's what I meant
13:39:03 <sorear> quicksilver: in fact that state of affairs is what motivated the creation of C--
13:39:08 <augustss> quicksilver: the decision to use C predates C-- (for ghc).  But the reason was the one you stated.  I just don't think it was a good enough reason.
13:39:09 <quicksilver> sorear: ghc targets C because C-- wasn't existing at that point
13:39:12 <phobes> phobes:  typeclasses are included in that sugar, right?
13:39:19 <quicksilver> augustss: *nod*
13:39:30 <quicksilver> sorear: yes, I've been to one of SPJ's C-- motivational seminars
13:39:30 <phobes> quicksilver I meant!
13:39:39 <lament> what's wrong with C?
13:39:46 <phobes> There's a conversation starter...
13:39:48 <quicksilver> phobes: right. In core typeclasses exist explicitly as dictionaty passing
13:39:53 <sorear> quicksilver: it's hard to comment by name about the nonexistance of a language that hasn't been *invented*
13:39:55 <quicksilver> lament: as a "portable assembly"?
13:39:58 <jatqceer> actually, I still worry about the license.  would there be a day when every piece of code is adopted by some comercial company and no one wants to maintain an open sourced version any more?
13:39:59 <quicksilver> sorear: that's true :)
13:40:05 <quicksilver> lament: it can't do tail calls
13:40:11 <augustss> lament: there's too much low level stuff you can't express in C
13:40:17 <quicksilver> lament: and it doesn't make certain runtime hooks like GC easy to write
13:40:17 <mauke> it has no registers
13:40:29 <lament> does C-- have arrays? :)
13:40:32 <psnively> augustss: And, ironically, at the same time, C overspecifies some things.
13:40:35 <phobes> quicksilver:  So then what's the one sentence description of STG?
13:40:51 <dino-> Did you exit the unwanted screen first?
13:41:02 <quicksilver> phobes: "STG is described in the paper 'Spineless Tagless G-Machine' by SPJ" ?
13:41:03 <dino-> hehe, wrong widow
13:41:06 <dino-> window
13:41:16 <quicksilver> "wrong widow"
13:41:17 <quicksilver> I like that
13:41:25 <dino-> :D
13:41:26 <sorear> C requires a stack pointer
13:41:26 <sorear> Implementing Haskell efficiently requires lots of highly unorthodox stack munging
13:41:26 <sorear> although not so much as we did back in the heydey of the G-machine
13:41:30 <phobes> quicksilver:  ok I've read part of that paper... I just needed the acronym reminder, thanks!
13:41:50 <quicksilver> phobes: STG is more of an implementation technique
13:41:54 <quicksilver> phobes: Core is still a language
13:42:00 <quicksilver> phobes: albeit, a low level one
13:42:15 <quicksilver> phobes: (of course, Core is a language designed to fit the STG, or vice versa)
13:42:17 <augustss> It's not that low level
13:42:30 <sorear> Core refers to two different languages
13:42:35 <augustss> Just more explicit
13:42:40 <sorear> New Core is Haskell with much less sugar
13:42:45 <Cale> It still has pattern matching, even.
13:42:51 <quicksilver> augustss: that is one sense of "low level"
13:42:56 <quicksilver> augustss: although of course not the only sense
13:43:11 <sorear> Old Core is like New Core, but in A-normal form and with lots of binder annotations; it's called the STG language now
13:43:13 <phobes> Cale:  That surprises me... I wonder why not desugar pattern matching?
13:43:26 <augustss> quicksilver: it's low level as in closer to pure lambda calculus
13:43:33 <sorear> phobes: Only simple pattern matches, like Just x and Nothing
13:43:33 <quicksilver> augustss: agreed
13:43:35 <Cale> phobes: It's really the primitive on which evaluation of Haskell is built.
13:43:41 <phobes> sorear: ok
13:43:47 <quicksilver> phobes: pattern matching is nice for optimisation
13:43:59 <quicksilver> phobes: if you're inlining, you can prune chunks that way
13:44:01 <Cale> phobes: At some level, nothing is ever evaluated without a case expression.
13:44:14 <phobes> Cale:  hmm ok
13:44:30 <augustss> Cale: well... functional application evaluates the function
13:45:04 <sorear> Recognizing the fundamental role of case is what made STG STG
13:46:29 <Cale> well, okay :)
13:46:29 * sorear thinks UNWIND is genius
13:46:29 <augustss> sorear: but the fundamental role of case predates STG
13:46:29 <quicksilver> it's all just swinging pointers
13:46:29 <quicksilver> that's what is cute about it. Although by no means unique to it.
13:46:29 <quicksilver> stuff really doesn't need to move very often
13:46:29 <sorear> augustss: but nobody thought about it before
13:46:29 <quicksilver> C-like languages compile into copying all over the shop
13:47:01 <quicksilver> some really nice animations of the internals of an STG would be a great thing actually
13:47:03 <augustss> sorear: huh?  the G-machine had CASE very similar to STG.
13:47:19 <quicksilver> there are so many of these tricks that would look good animated
13:47:28 <quicksilver> we need combinators for animating box-and-arrow diagrams!
13:47:32 <augustss> Not in Thomas' description of the G-machine, but in the one we used.
13:47:46 <Cale> I'd really just like an animated graph reduction machine for Haskell.
13:47:56 <quicksilver> Cale: yes, that's the other thing I meant
13:47:57 <sorear> augustss: you had CASE, but you also had EVAL.  the insight of combining the two is what I meant
13:48:07 <quicksilver> Cale: but it would be nice to have the two side by side
13:48:14 <Cale> yeah
13:48:18 <quicksilver> Cale: to see (a) the graph picture and (b) how clever the STG is
13:48:20 <augustss> sorear: OK, I'll agree wit that :)
13:48:49 <augustss> But I don't think combining EVAL and CASE is a win
13:50:06 <augustss> The "clever" reasons (like multiple return points) for combining them are all gone from ghc now.
13:50:58 * quicksilver cargo-cults GL code shamelessly
13:51:23 <shapr> yay cargo cult!
13:51:59 <shapr> dons: Yay! It's released!
13:56:01 <bartw> cargo culted a bit at work from the original version, woops, copy/pasted a bit O(n^2) that could have been O(1) on the database
13:56:01 <quicksilver> ah well
13:56:01 <quicksilver> the different between n^2 and 1 is only n^1
13:56:01 <quicksilver> and who cares about O(n)?
13:56:01 <bartw> people seem all upity about code reuse, but everytime i try it, somethign like that happens
13:56:01 <bartw> it was 9000ms vs 200ms, so from a serious usability issue back to slow but useable
16:20:59 --- topic: '["The Haskell programming language: 100% safe to take, with NO side effects!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The language of ICFP winners 3 years running"]'
16:20:59 --- topic: set by dons on [Fri Sep 14 23:11:02 2007]
16:21:20 * kyevan hugs everyone in #haskell
16:21:34 * sieni doesn't
16:21:39 <kyevan> Even if you break my brain sometimes, at least you guys TRY to be helpful
16:21:55 * kyevan just had the pleasure of extracting an answer from #debian
16:23:51 <sieni> kyevan: is that possible?
16:23:59 <kyevan> Sorta
16:24:11 <kyevan> I eventually got one of them to use a bot macro that gave me the answer
16:24:28 <dons> Igloo: seems like we need to do some serious cabal package updating for ghc 6.9
16:24:31 <dons> 6.8.
16:24:35 <dons> is cabal up to the task?
16:24:42 <dons> since everything's going to break :)
16:25:11 <Igloo> dons: We don't want to do it before 6.8.1 though, or everything will be broken until the release
16:25:36 <sjanssen> why did Cabal 1.2.0 remove Distribution.Simple?
16:25:46 <cognominal__> @src length
16:25:47 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:26:15 <dons> Igloo: right. scary..
16:26:22 <TuringTest> Anyone else looking at the ITA Word Numbers problem? http://www.itasoftware.com/careers/puzzles07.html and http://conway.rutgers.edu/~ccshan/wiki/blog/ ?
16:26:22 <lambdabot> Title: ITA Software - Puzzle Archive
16:26:24 <dons> so 6.8 is a developer's snapshot preview?
16:26:35 <dons> Igloo: and we should send out to maintainers logs of their stuff failing
16:26:37 <Igloo> dons: 6.8 is a branch, not a release
16:26:54 <Igloo> 6.8.1 is what we will release RSN
16:27:04 <dons> but all of hackage will break
16:27:23 <kyevan> So, let me get this straight: In Haskell, it's impossible to write a program that doesn't give the same answer every times it's run, BUT
16:27:30 <Igloo> Yeah, but we'll fix it  :-)
16:27:37 <Igloo> It'll be easier in future now that we have configurations
16:27:38 <kyevan> that answer can be a more traditional, imperitive-like program?
16:27:43 <dons> oh, we're not doing 6.8.1 next week?
16:27:57 <dons> i'm inclined to have a guidelines page for updating to 6.8 in fact
16:28:09 <dons> since its going to be a big FAQ -- starting with all those new libs
16:28:18 <dons> and then things like bytestring (grumble) changing its module names
16:28:28 <TuringTest> kyevan: Something like that.... "main :: IO ()" is the action you specify
16:28:30 <wootles> sjannsen: i think i need to learn more haskell before i can use tries... do you know of a good 'plan' to learn the language step by step?
16:28:32 * dons feels like a corporate haskell programmer now -- stability before all else!
16:28:52 <dolio> Cabal has plenty of LANGUAGE constructors to add, too. :)
16:29:06 <phobes> You should just figure out that the 51 billionth letter is e.g. 'a' and submit an entry consisting of  print 'a'  -- see associated notes
16:29:18 <dons> dolio: right, language stuff changes (e.g. mtl breaks)
16:29:26 <dons> library dep changes (e.g. lambdabot needs 9 new libs)
16:29:34 <dons> things that use bytestring internals (e.g. binary) break
16:29:50 <dons> Igloo: should we have a upgrading advice page on the wiki?
16:29:51 <wxw> dons: is there a list of available LANGUAGE options for ghc? i had to guess that for arrow notation you write "Arrows"
16:29:51 <dolio> Yeah, I noticed that trying to build binary the other night. I had to add a bunch of stuff.
16:29:55 <dolio> And then it still didn't work. :)
16:30:00 <dons> right.
16:30:05 <kyevan> TuringTest: I'm trying to think about this without breaking down into tears again, so we'll run with that for now :)
16:30:16 <wxw> wxw: and the docs for arrow notation only mention the -farrows flag, not the "Arrows" LANGUAGE option
16:30:17 <dons> Igloo: we'll need a few weeks to get hackage into a good state :(
16:30:27 <dons> and there's a key set of non-core libs that have to work out of the box
16:30:33 <dons> like binary, for example.
16:30:45 <dons> Igloo: is anyone talking about the hackage story?
16:30:58 <dons> wxw: must be in the ghc user's guide
16:31:22 * TuringTest posts a mysterious number 676746575 and vanishes
16:31:45 <sorear> why are configurations good?  why can't we just have a base-2.0 compatibility packagee that re-exports all the relevant mdoules?
16:31:46 <wxw> dons: i did a thorough look through the ghc users guide, and only found mention of the -farrows compiler flag, nothing about "Arrows" LANGUAGE option
16:32:24 <dons> > 5 * 5 * 27069863
16:32:26 <lambdabot>  676746575
16:33:53 <Igloo> wxw: ghc --supported-languages will list them all, but not tell you any info in what they do
16:34:54 <dons> so yes, we need to coordinate cabal recommendations for handling dependency changes, ghc's release schedule, and contacting hackage maintainers to fix their stuff
16:35:32 <wxw> Igloo: hm... cool thanks. but doesn't seem to work with ghc 6.6
16:36:33 <Cale> Hey, wow, do the monad laws ever look natural when you write them as string diagrams :)
16:36:44 <wxw> Igloo: do you have the authority to get patches applied to the empty http://darcs.haskell.org/yampa/ ?
16:36:46 <lambdabot> Title: Index of /yampa
16:38:12 <kyevan> When the time comes, does anyone know a good explanation of monads that doesn't neglect part of it, or expect math beyond US high school geometry?
16:38:16 <earnest> I'd like to confess something about Haskell.
16:38:41 <wootles> where x,y are lists of equal length, i want to see if there exists a permutation of x such that x = y ... is there a standard library function for this? something like a multiset ?
16:38:57 <earnest> So far I have found pretty hard to go from my imperative ideas to Haskell.
16:39:22 <dons> shapr: what java did you end up going with?
16:39:23 <earnest> I haven't devoted enough time yet, but I am still very much totally in the dark.
16:39:25 <Cale> earnest: It takes a while before you're used to that
16:39:39 <earnest> Cale: I guess. :|
16:39:42 <Cale> earnest: Initially, it's best to really learn the list functions very well
16:39:51 <Cale> earnest: they take the place of your loops in many cases
16:40:14 <earnest> I see. I know how to use... head, tail, map, foldl, foldr (basically)
16:40:24 <Cale> filter is another one
16:40:37 <Cale> foldr is very important
16:40:48 <earnest> And I know how to write some very simple ones that only work with lists and nothing else.  I haven't worked with filter yet; but the problem I find is: it seems hard to do IO and everything I wanna do is IO-related.
16:41:04 <Cale> Ah, if you need a good intro to that...
16:41:20 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
16:41:21 <lambdabot> Title: Introduction to IO - HaskellWiki
16:41:35 <Cale> that should only take a couple minutes to read and just gives the basic idea
16:41:47 <earnest> Thanks. I will read it.
16:41:58 <Cale> after that, the important thing to do is to look at a few of the things in the Control.Monad library (I'll let you know which are most important)
16:42:15 <Cale> All your control structures, like foreach loops, are just library functions in Haskell :)
16:42:21 <Cale> You can even write your own :)
16:42:44 <wxw> it's even recommended that you do i believe
16:42:52 <Cale> yeah
16:42:54 <timthelion> ghci is in haskell?
16:43:00 <Cale> timthelion: yeah
16:43:12 <Cale> timthelion: basically all of GHC is in Haskell
16:43:14 <timthelion> where is the source?
16:43:18 <earnest> But let me complain one final thing: I haven't understood why I have to ``return ()'' when in other cases I can just say ``()'' as a return value or perhaps ``[]'' as a return value. The syntax being different, it even looks ugly, but I guess I haven't understood how things work, so I may not even be able to see the beauty.
16:43:23 <timthelion> to just ghci
16:43:33 <Cale> timthelion: it's mixed in with the GHC source
16:43:34 <luqui> in the ghc manual ss. 7.14, it says "Experimentally, GHC now makes pattern bindings monomorphic by default."   does anyone have an inkling why?
16:43:40 <Lemmih> timthelion: ghci == ghc --interactive.
16:43:56 <timthelion> I don't want to download gigs and gigs of code :(, I just want to know what it's generic showing algorithm is.
16:44:02 <wxw> timthelion: if you are interested in dynamic evaluation of haskell code, maybe you will like hs-plugins or GHC API
16:44:08 <earnest> Now, I have a real question: if IO is a side effect in one way or another, how can Haskell be purely functional if it must do IO? I suppose that purely function doesn't imply no side effects, does it?
16:44:12 <Cale> earnest: return x is the (IO) computation which does nothing and simply returns x when run
16:44:16 <dolio> Gigs?
16:44:42 <timthelion> well, I would asume so. it's a rather advanced compiler
16:44:43 <Cale> earnest: a Haskell function of type a -> IO b must only return the same *action* when given the same value of type a
16:45:18 <Cale> earnest: the actions don't actually run when evaluated -- you don't actually have the power to execute them yourself
16:45:21 <dolio> I guess my tree is 1.3 gigs, but that has a lot of extra stuff.
16:45:22 <timthelion> does it just call show i?
16:45:22 <monochrom> Some runtime system looks at those actions and produces side effects.
16:45:26 <earnest> Cale :Can we talk an example instead of in general?
16:45:32 <Cale> okay
16:45:42 <Cale> So let's look at putStrLn :: String -> IO ()
16:45:49 <earnest> Perfect. I know that one. :)
16:46:06 <Cale> It takes a String, and produces an action, which *when run*, will print that string.
16:46:08 <Lemmih> timthelion: This might be of help: http://darcs.haskell.org/ghc/compiler/ghci/InteractiveUI.hs
16:46:14 <earnest> Right.
16:46:15 <Cale> Given the same string, it always gives the same action.
16:46:27 <Cale> That is, it's referentially transparent, in a sense.
16:46:44 <Cale> But just *evaluating*  putStrLn "Hello", won't print "Hello" on the screen.
16:46:55 <Cale> It just makes an action.
16:47:00 <earnest> Hm. I see.
16:47:07 <Cale> In order to do the actual printing, you have to execute that action.
16:47:08 <earnest> It's called lazy?
16:47:16 <Cale> no, this isn't really laziness
16:47:29 <earnest> Then why not execute it when evaluating?
16:47:43 <Cale> You can think of (putStrLn "Hello") as giving you a data structure which represents the action of printing "Hello" on the screen
16:47:49 <Cale> A program script, if you want.
16:47:58 <earnest> Right. I'm imagining something like that.
16:48:00 <Cale> okay
16:48:09 <olsner> you can think of a program as something generating a list of IO things to do, then handing it over to some glue magic that actually does IO
16:48:12 <Cale> So in a compiled program, what happens is you define an action called main
16:48:16 <earnest> I see IO in Haskell as a way to sequence things.
16:48:17 <wxw> earnest: if you know c then you can think of putStrLn as a function that returns a pointer to a function that actually prints the string
16:48:30 <Cale> and the runtime system will *execute* the result of evaluating main
16:48:38 <kyevan> Haskell can't write programs that do anything other than always return the same thing
16:48:40 <earnest> wxw: gotcha; c is my background really.
16:49:01 <kyevan> But that same thing can be a different program that can :P
16:49:01 <Cale> So main evaluates to some big action which is the entire meaning of your program, and then the RTS executes it.
16:49:13 <kyevan> (At least, that's how I interpret it)
16:49:21 <Cale> In order to define main, you combine smaller IO actions, along with pure functions.
16:49:30 <Igloo> wxw: Oh, sorry, I thought you were talking about 6.8
16:49:31 <Cale> Does that make sense?
16:50:00 <Cale> Of course, if you don't know how to glue IO actions end to end, you can't do much.
16:50:04 <wxw> Igloo: should I be using ghc 6.8?
16:50:06 <Cale> You can write hello world though :)
16:50:14 <Cale> main = putStrLn "Hello, World!"
16:50:14 <Igloo> wxw: If it's not being used yet then it would be better to get a yampa project on community.haskell.org instead
16:50:19 <earnest> Cale: so the fact that Haskell is purely functional means that your program is purely functional; the RTS will actually do things just like a C program would. Does this make sense?
16:50:27 <Cale> earnest: right
16:50:39 <earnest> Cale: it does make sense; a lot of things are looking better.
16:50:40 <jmob> How do I create an IO () ?
16:50:50 <Cale> jmob: by using some IO primitives
16:50:59 <Cale> like putStrLn
16:51:03 <Cale> :t putStrLn
16:51:05 <lambdabot> String -> IO ()
16:51:15 <Cale> well, it's not necessarily primitive
16:51:16 <wootles> coming from an imperative background, something i find disconcerting is that my programs seem to be at the mercy of the haskell compiler; i feel like i have less control... often I will write something that should be O(log n), but before compiler optimisations it is O(n) , whereas in c/c++ the compiler optimisations tend to have a more linear effect
16:51:17 <Igloo> wxw: No, it's just that 6.8 introduced the --supported-languages flag
16:51:18 <Cale> :t putChar
16:51:20 <lambdabot> Char -> IO ()
16:51:34 <jmob> Cale: I have an if, who's else branch should be a no-op
16:51:44 <Cale> jmob: ah, you want  return ()
16:51:54 <Cale> That's a no-op that just returns ()
16:51:55 <wxw> Igloo: interesting. where can i read about community.haskell.org?
16:52:08 <Igloo> wxw: http://community.haskell.org/
16:52:09 <lambdabot> Title: Haskell Community Server
16:52:22 <jmob> Cale: hooray, on to my next compile error
16:52:24 <luqui> jmob, you might also want to consider Control.Monad.when
16:52:26 <sjanssen> wootles: optimizations generally don't change the time complexity of your code
16:52:27 <luqui> :t when
16:52:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:52:39 <sjanssen> wootles: can you give an example where they have?
16:52:39 <Cale> Note that return in Haskell doesn't have the control effects which it has in most imperative languages
16:52:43 <earnest> Now, Cale, can you help sort of picture ``IO a'' or ``IO ()'' in a C-point-of-view? I understand Int, Integer, and I can even deal fine with types ``a'' but ``IO a'' is what exactly? Is the difference between a and IO a just existent so that the compiler can do the right thing or is there a fundamental difference as there is between Char and Int?
16:52:49 <wxw> Igloo: thanks =]
16:53:09 <Cale> earnest: You can think of a value of type (IO a) as a C program which when run will produce a value of type a
16:53:32 <Cale> earnest: But Haskell evaluation doesn't cause said programs to run, it just builds them.
16:53:35 <wootles> sjanssen: with some earlier implementations of that array code , sometimes it would share the array, sometimes it would not , depending on whether optimisations were on or off
16:53:45 <earnest> Oh. Like a very small C program doing something for my big program?
16:53:49 <Cale> yeah
16:54:01 <Cale> or in the end, your main is a value of type IO a
16:54:03 <earnest> Cale: I see. So alright... IO-stuff are separated programs. :)
16:54:16 <luqui> earnest, which can, of course, reference each other by sequencing
16:54:19 <earnest> Gotcha. I didn't even know that my main was IO a.
16:54:28 <earnest> luqui: right.
16:54:42 <wootles> sjanssen: whereas in C, the sharing would be made explicit in the code itself, eg by a lookup
16:54:42 <earnest> You know... I'm feeling better.
16:54:45 <Cale> Because of this meta-programming view of the world, you can write your own control structures, once you have a few basic ways to glue such programs together.
16:54:54 <earnest> But I think it's because I'm looking at this as a C program now. :)
16:55:03 <earnest> Which makes me a lost cause? :P
16:55:18 <olsner> never too late to change
16:55:18 <luqui> wootles, yeah, I get the same feeling
16:55:19 <Cale> In some fuzzy sense, you're writing a Haskell program which writes a C program.
16:55:26 <earnest> Yeah. :)
16:55:34 <earnest> That's the truth. :P
16:55:45 <luqui> wootles, except... I like it.  I've never been an optimization monkey, so I kinda like being separated from that and just focusing on the logic.
16:56:01 <Cale> Of course, under the covers, that's not *really* what it's doing, but it ostensibly could be doing that.
16:56:18 <earnest> Cale, I get it. So Haskell does have some of Lisp powers of writing programs that write programs, right? Because you're saying that you write your own control structures.
16:56:31 <luqui> Cale, implementation question:  how _is_ the IO monad implemented?
16:56:44 <sjanssen> @src IO
16:56:44 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:56:45 <Cale> luqui: hideous cheating ;)
16:57:05 <luqui> can you give a slightly, but not too much so, more in depth explanation?
16:57:21 <dolio> luqui: Do you understand the State monad?
16:57:24 <sjanssen> luqui: read that as: 'IO a' is a function which takes the state of the world, and returns a new state of the world and an 'a'
16:57:26 <luqui> dogmaT, yeah
16:57:38 <Cale> luqui: A value of type RealWorld is passed around like a token to ensure that data dependencies make evaluation happen the right way, and you have effects directly caused by the Haskell evaluator.
16:57:38 <luqui> oops, dolio
16:58:06 <Cale> luqui: That's ugly, but it works.
16:58:11 <luqui> that's interesting...
16:58:15 <sjanssen> luqui: of course we can't actually represent the state of the world in RAM, State# RealWorld is actually an artificial value that the compiler uses to enforce sequencing
16:58:33 <Cale> A nicer way would be something like using a GADT to represent primitive actions and binds explicitly.
16:58:54 <Cale> (something like higher-order abstract syntax)
16:58:59 <wxw> Cale: what are the disadvantagers of this nicer way?
16:59:05 <wootles> luqui: i suppose you are right... my worry is that compiler optimisation changes the program so much (invokes a mechanism to keep track of previously calculated values, etc), but I suppose that is just part of using a higher-level language, and probably a good thing really
16:59:24 <Cale> wxw: It might be trickier to compile into efficient code. Also, GADT's are pretty new.
16:59:46 <wxw> Cale: i've read that GADT offers programmers new ways to take advantage of optimizations
17:00:05 <sjanssen> I don't think the GADT approach can explain threads either
17:00:25 <Cale> sjanssen: are you sure? You'd just represent ForkIO explicitly as a constructor.
17:01:00 <Cale> It would be up to the executor to actually carry out the actions described.
17:01:12 <phobes> Cale:  Do you have a reference to this GADTs for passing abstract syntax idea?
17:01:28 <Cale> No, I haven't really written it down anywhere
17:01:37 <phobes> Oh, it's your idea
17:01:45 <Cale> But there are lots of examples of GADT use for abstract syntax.
17:01:59 <luqui> how do I get the ghc darcs depot?
17:02:00 <sorear> phobes: I wrote it down once
17:02:05 <Cale> Just not for IO
17:02:08 <sorear> d.h.o/ghc
17:02:14 <luqui> ok
17:02:16 <sjanssen> Cale: I think you're right
17:02:19 <Cale> It's a sort of obvious idea, once you have the right mindset.
17:02:39 <sorear> http://www.haskell.org/pipermail/haskell-cafe/2007-April/024472.html
17:02:41 <lambdabot> Title: [Haskell-cafe] Do monads imply laziness?, http://tinyurl.com/2byoqu
17:03:54 <Cale> sorear: yeah, just like that :)
17:04:58 <Cale> Only a GADT would give you the ability to have bind along with nicer type constraints.
17:07:39 <phobes> Ok, so you're talking about building a little abstract machine for which the monad is the input, right?
17:12:02 <dons> Igloo: any idea how hard it is to do a local hackage install?
17:12:13 <dons> as a tool for managing in-house haskell libs :)
17:15:39 <Igloo> dons: I've got no experience with the hackage software, sorry
17:16:40 <dons> ok. i'd like to do a local install -- basically use the hackage system as a rcs for src bundles :)
17:16:58 <dons> within medium-sized haskell organisations, it seems useful (wish we'd done this at unsw)
17:17:21 <dons> and might just lead to some cabal/hackage work
17:21:17 <earnest> Cale: that article is by you. :)
17:21:23 <Cale> earnest: yep
17:21:30 <earnest> Cale: it's very nice.
17:21:36 <Cale> earnest: I wrote it because I kept saying the same thing over and over
17:22:32 <earnest> It was very useful. I had read another one previously which explained what a Monad is, so things connected very well there.
17:22:59 <elliottt> Lemmih: is your hackagedb repo on darcs.haskell.org the package that runs hackage.haskell.org?
17:23:19 <dons> nah, wiki page says that's the old version
17:24:18 <sorear> dons: ross
17:25:00 <Cale> earnest: I've written a couple of articles, monads as computations and monads as containers, which present a couple of views.
17:26:12 <earnest> I see it there; I'll read them too.
17:27:24 <dolio> @remember simonpj Actually, the universe does not disappear into your laptop when you run a Haskell program.
17:27:24 <lambdabot> Done.
17:27:30 <dolio> That took a while to find.
17:27:45 <earnest> hehe, i've heard that :)
17:27:56 <earnest> I watched some of his presentations.
17:27:57 <luqui> he said that at oscon, no?
17:28:02 <dolio> Yeah.
17:28:07 <luqui> I wish i were there
17:28:12 <luqui> would have liked to meet him
17:28:27 <stepcut> luqui: well, there is ICFP in a few weeks...
17:28:30 <P_D> > log (exp 1)
17:28:32 <lambdabot>  1.0
17:29:03 <dolio> Just ask him 'what are monads' and he'll have dinner with you. :)
17:29:17 <earnest> Hehe. :)
17:29:57 <luqui> i'm into comonads these days
17:30:07 <fax> hi everyone
17:30:10 <luqui> they are mind-boggling me about as much as monads did originally
17:30:16 <luqui> didn't have trouble with arrows, for some reason
17:30:44 <dolio> I can't say I have a handle on them, either. There are fewer examples of comonads out there.
17:31:17 <sorear> I know what comonads are, but I don't have a good mental model.
17:31:28 <dolio> Yeah.
17:31:31 <Saizan> yeah, if you have some interesting examples, luqui, give us the links :)
17:35:02 <olsner> if monads are containers that you can put anything into but not easily out of, comonads are containers that you can get things out of but not easily into
17:35:48 <Cale> yeah
17:36:15 <ddarius> You'd probably be better off pondering the difference between algebras and coalgebras.
17:36:34 <Saizan> yeah, but for example monads are useful to abstract repetitive patterns that pervade your code, but comonads?
17:36:40 <Cale> typical containers don't have a natural way to take an element out, since they hold a bunch of things without marking one of them as special
17:37:07 <luqui> zippers though...
17:37:41 <Cale> Whereas comonadic containers mark a special element which is given by extract
17:37:53 <luqui> samreid, are you the one I know?
17:37:57 <luqui> university of colorado?
17:38:26 <samreid> luqui: nope!  the one of RPI
17:38:41 <luqui> heh ok :-)
17:39:02 <samreid> wait... there's a sam reid?... hm reid is my middle name..
17:39:52 <olsner> I though 'reid' was only usable as a surname?
17:40:33 <samreid> You can give whatever middle names you want.  I think I had a great-grandfather with the surname.
17:41:43 <olsner> okay
17:41:53 <samreid> I suppose SamH is not a good name on this channel...
17:41:54 <luqui> samreid, no you cannot.  it is illegal to give certain middle names.  didn't you know that.  I'm calling the authorities.
17:42:11 <fax> uh oh.. busted
17:42:14 <P_D> What's the most basic class that will give me a division in the FPU?
17:42:36 <luqui> P_D, class?
17:42:42 <olsner> hmm.. the assembler code generation monad? :P
17:42:57 <newsham> hi
17:43:00 <samreid> Fractional?
17:43:18 <P_D> yes that's it
17:43:21 <P_D> supports real division, thanks
17:44:41 <P_D> :t floor 1.3
17:44:43 <lambdabot> forall b. (Integral b) => b
17:45:28 <luqui> what is the precedence of :: ?
17:45:41 <shapr> dons: java6
17:45:57 <shapr> dons: docs claimed java5 would work as well, but I already had 6 installed.
17:46:06 <kyevan> aw, the lambdabot web interface at http://lambdabot.codersbase.com/ is dead :(
17:46:07 <lambdabot> Title: Lambdabot Web Interface
17:46:36 <kyevan> (I'd set up a yubnub alias for it, too :()
17:46:49 <shapr> kyevan: Set up another one!
17:47:22 <dolio> luqui: Essentially, lower than everything else.
17:48:18 <kyevan> shapr: I don't have dedicated web hosting
17:48:24 <dons> you got it going , shapr?
17:48:33 <dons> sun's jre seems to work fine
17:48:35 <dons> with firefox 2
17:48:46 <dons> dons@xen-host02:~$ java -version
17:48:47 <dons> java version "1.6.0_02"
17:49:08 <shapr> dons: Yeah, I got it going.
17:49:35 <shapr> Using selenium-rc 0.9.2
17:49:37 <dons> sweet. we've a team of dedicated hackers here to help, so feedback is welcome :)
17:49:41 <dons> yeah, same
17:49:54 <dons> it kind of feels like we've a  bit of a haskell army here
17:49:55 <shapr> Means the README needs updating.
17:50:02 <dons> yeah
17:50:04 <dons> will do
17:50:04 <fax> D
17:50:07 <shapr> whoa, seven new patches today!
17:50:08 <luqui> > let x+1 = 43 in ()
17:50:10 <lambdabot>  ()
17:50:16 <luqui> > let x+1 = 42 in x
17:50:17 <lambdabot>   Not in scope: `x'
17:50:20 <luqui> that's... odd
17:50:32 <kyevan> > let x = x in x
17:50:33 <lambdabot>  Exception: <<loop>>
17:50:34 <fax> dons: Who can we battle?
17:50:47 <shapr> fax: It's more like we're building stuff.
17:50:53 <kyevan> Aw, we can't murder her that easily?
17:50:56 <shapr> We're the tool makers.
17:51:05 <dolio> > let (x+1) = 42 in x
17:51:05 <lambdabot>  Parse error in pattern
17:51:11 <fax> ahh :D
17:51:13 <fax> cool
17:51:19 <sjanssen> luqui: the "x+1" is parsed as the definitition of a (+) function, not an n+k binding
17:51:25 <luqui> aa soo
17:51:30 <fax> > let (x+1) = 42 in 42
17:51:30 <lambdabot>  Parse error in pattern
17:51:37 <sjanssen> fax:
17:51:41 <kyevan> > let let = let in let
17:51:41 <lambdabot>  Parse error
17:51:48 <kyevan> Aw :P
17:51:49 <fax> > let f (x+1) = 42 in f 42
17:51:49 <lambdabot>  Parse error in pattern
17:51:59 <sjanssen> fax: the pre-parser that @run uses doesn't understand n+k
17:52:08 * luqui dislikes n+k
17:52:12 <fax> ohh
17:52:15 <sorear> the pre-parser that @run uses is Language.Haskell
17:52:26 <fax> I liek n+1
17:52:31 <fax> not n+k though
17:52:44 <fax> not that I ever had an occasion to use it
17:53:51 <kyevan> me wishes 3x+2 = 0 was a valid way to assign a value to x :P
17:54:05 * Cale has lots of fun verifying the monad laws hold for the monad arising from an adjunction using string diagrams.
17:54:23 <Cale> It's so beautiful. I should really inkscape this up :)
17:54:40 <dataangel> Newb question, how can a pattern match 'fail'? I thought the whole point was that the compiler forced you to write code that exhausted all patterns. But I just read that inside a 'do' block you have to account for pattern matches failing.
17:55:11 <sarehu> > do { Just x <- Nothing ; return (x + 5) }
17:55:11 <Cale> dataangel: If you write something like  (x:xs) <- expr
17:55:12 <lambdabot>  Nothing
17:55:16 <thoughtpolice> dataangel: you mean like let? it's lazy pattern matching in that case.
17:55:24 <Cale> dataangel: and expr ends up giving you an empty list
17:55:30 <Cale> then the pattern match fails
17:55:51 <sarehu> er...
17:56:22 <sarehu> I meant  do { x <- Nothing.. but ok!
17:56:31 <Cale> > do { (x:xs) <- Just [] ; return (x + 5) }
17:56:32 <lambdabot>  Nothing
17:56:35 <sarehu> Or... Yes.
17:56:36 <dataangel> it's specifically talking about with 'let'
17:56:39 <Saizan> sarehu: yous is more an example of Nothing being mzero for Maybe
17:57:06 <dataangel> Cale: I thought I was forced to right code for when there is an empty list though? I thought that's what pattern matching was about.
17:57:10 <sarehu> > do { Just x <- return Nothing ; return (x + 5) }
17:57:11 <lambdabot>   add an instance declaration for (Show (t a))
17:57:19 <dolio> Haskell is not a total language.
17:57:38 <Cale> dataangel: You actually don't, but you can get the compiler to warn you.
17:57:53 <notsmack> Cale: how do you get the compiler to warn you?
17:58:06 <infrared> is there a haskell function in stdlib (or in lib that can be easily installed) that spells the integer in english, like (format nil "~r" NUMBER) in common lisp?
17:58:11 <kyevan> x = 1 : x
17:58:20 <sjanssen> infrared: no
17:58:24 <kyevan> that's valid in haskell, right?
17:58:24 <dataangel> Cale: Err, in that example wouldn't you gete  a type error? You can't add 5 to a list...
17:58:24 <Cale> -fwarn-incomplete-patterns
17:58:26 <sarehu> infrared: I have written it.
17:58:29 <sarehu> Do you want it?
17:58:36 <infrared> sarehu: yes :)
17:58:46 <Cale> dataangel: no, x would match just the head of the list
17:58:51 <sarehu> infrared: ok, let me find the forum I posted it on years ago :)
17:58:59 <infrared> sarehu: thanks :)
17:59:08 <Cale> > do { (x:xs) <- Just [1,2,3] ; return (x + 5) }
17:59:09 <lambdabot>  Just 6
17:59:18 <kyevan> > x = 1 : x
17:59:18 <lambdabot>  Parse error
17:59:20 <dataangel> Cale: Err, I'm not used to seeing just/nothing/maybe used inside a do block, so I guess I'm completely confused by what that does :P
17:59:26 <kyevan> hmm...
17:59:32 <Cale> dataangel: We're using Maybe as the monad
17:59:40 <notsmack> > let x = 1 : x in x
17:59:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:59:44 <Cale> Maybe is a monad with  return x = Just x
17:59:51 <kyevan> oh.
17:59:52 <Cale> Nothing >>= f = Nothing
17:59:56 <kyevan> ... That is really weird >_>
17:59:59 <Cale> Just x >>= f = f x
18:00:05 <fax> > fix (1:)
18:00:05 <dataangel> right..
18:00:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:00:31 <dataangel> Cale: I guess I didn't realize you could use that to bind x to refer to the head of the list for the whole do block
18:00:34 <Cale> So for example, it's rather good for chaining together a bunch of calls to 'lookup'
18:00:46 <Cale> where you want the whole computation to give Nothing if any of the lookups failed
18:00:50 <dataangel> right
18:01:05 <Cale> This is generally not a safe thing to do in most monads
18:01:22 <kyevan> I don't get how x = 1 : x can work. I mean, not evaling to the end is OK, but that doesn't seem to fit the definition of a list that I'm used to...
18:01:23 <Cale> There's a bit of a wart in the Haskell standard which puts a method called 'fail' into the Monad class
18:01:28 <Cale> where it really shouldn't belong
18:01:50 <Cale> kyevan: It's a cons whose head is 1 and whose tail is itself
18:02:00 <dataangel> In the case where you're defining a function that takes some union type though, you have to write patterns that exhaust the possible values, otherwise you get a compile error though
18:02:05 <dataangel> or in a case statement
18:02:10 <Cale> kyevan: A list is either the empty list, or it's the cons of an element and a list
18:02:16 <Cale> (any list)
18:02:22 <sjanssen> dataangel: you get a compiler *warning*, not an error
18:02:23 <notsmack> kyevan: 1 cons (1 cons ( 1 cons...
18:02:38 <dataangel> sjannsen: Really?! I kind of liked that it was an error :P:
18:02:41 <Cale> dataangel: You get a warning only.
18:02:45 <Cale> yeah
18:02:50 <dataangel> Why not have it always be an error?
18:02:56 <sjanssen> > case Nothing of Just () -> () -- totally valid
18:02:57 <Cale> -Wall -Werror will make it an error
18:02:58 <lambdabot>   Non-exhaustive patterns in case
18:03:03 <dataangel> That's what made Maybe so appealing over NULL pointers
18:03:09 <Cale> dataangel: Because sometimes you know that only some of the patterns will match
18:03:16 <sjanssen> you can't tell, but that was a runtime error, not compile time
18:03:26 <Cale> dataangel: and there's no way for the compiler to prove that you're right
18:04:02 <Cale> For instance, say you *know* that there's something in your finite map which corresponds to a given key, and you want to do that lookup
18:04:03 <edward1> cale: at present =)
18:04:15 <Cale> edward1: well, and to some extent forever
18:04:18 <edward1> cale: and yeah in the turing-complete general sense forever =)
18:04:25 <sjanssen> dataangel: the reason why Maybe is better than pointers-with-null is because 'Maybe a' and 'a' are two different types.  You've got to write something to get the 'a' out
18:04:37 <dataangel> Cale: I feel like you should be obligated to write it anyway. Or at least for it to be gaurunteed that if it fails the program will immediately exit rather than have undefined behavior.
18:04:50 <Cale> dataangel: Oh, it does immediately exit.
18:04:53 <dataangel> sjannsen: Yes, but that something is a pattern match isn't it?
18:05:00 <kyevan> maybe is confusing >_>
18:05:00 <dataangel> Cale: Ah that's still nicer then :)
18:05:22 <sjanssen> dataangel: correct, and the compiler can warn you when you've got an incomplete pattern match
18:05:23 <Cale> dataangel: pattern match failure causes an exception to be thrown, which if you're really careful, you can catch in IO, but typically your program will just die.
18:05:49 <Cale> With a little error message saying what line in what source file the pattern match failed on.
18:06:13 <kyevan> Haskell is confusing me, and I'm not even to monads again yet >_>
18:06:18 <dataangel> I'd think that at least for Maybe it should just be required
18:06:32 <Cale> kyevan: A value of type Maybe Integer is either the value called Nothing
18:06:46 <Cale> or it's a value of the form  Just n, where n is some Integer
18:06:54 <sjanssen> dataangel: Haskell *could* require that all cases be exhaustive, but then we'd end up with stupid code like: _ -> error "oops, br0ken"
18:07:28 <kyevan> Cale: but... WHY?
18:07:56 <Cale> kyevan: Well, you often have functions which might fail to return a result.
18:08:25 <Cale> For example, let's say you're writing a function which looks to see if an element is in a list, and gives its index if it is.
18:08:26 <sjanssen> dataangel: so instead of making the programmer write this boilerplate, the compiler inserts it automatically.  A good compiler will even insert better info in the error message, like the function name and line number
18:08:32 <dataangel> sjanssen: Is there anywhere to query GHC/Hugs, "Show me all instances where I don't exhaustively pattern match" specifically?
18:08:34 <Cale> What should it return if it isn't in the list?
18:09:07 <sjanssen> dataangel: -Wall will do it
18:09:08 <Cale> If it's just returning an Integer, we'd have to do something dumb like return (-1) when there's nothing found
18:09:18 <Cale> But sometimes even this isn't an option
18:09:44 <dataangel> sjannsen: True, but that's likely to print out lots of other BS that will cause programmers to not use it and then still write stupid code, just differently ;p
18:09:49 <Cale> Consider the case where you have a list of pairs, and you want to find the pair whose first element matches a value and return its second element.
18:09:49 <sjanssen> dataangel: this will warn you if you write an incomplete case, but it can't warn you if you're using a library function that has an incomplete case
18:10:00 <Cale> If there's no matching pair, what do you return?
18:10:03 <dataangel> sjanssen: Hrmm....
18:10:34 <Cale> [(a,b)] -> a -> b  is an unsatisfactory type for this, because we don't know if there's a value of type b we can use to fail with
18:10:56 <dataangel> sjannsen: I can think of instances where you have basically an enumeration, and you want it so that if you add items to the enumeration, you want all the places the code uses that enumeration have to be updated to compile. I guess a warning is enough...
18:10:58 <Cale> We could just throw an exception, but that's a pain in the ass, because it'll typically cause our program to die.
18:11:08 <Cale> So we want something nicer than that.
18:11:09 <fax> flip lookUp
18:11:15 <Cale> So instead we use the type
18:11:22 <Cale> [(a,b)] -> a -> Maybe b
18:11:55 <Cale> That is, it *might* find a value x of type b for you, in which case, it'll return Just x, or it won't in which case it will return Nothing
18:12:01 <Cale> Let's look at the code:
18:12:18 <Cale> myLookup [] x = Nothing
18:12:45 <Cale> myLookup (y:ys) x = if x == y then Just y else myLookup ys x
18:12:57 <infrared> i'm trying to use QuickCheck, but I got "QuickCheck.hs:156:41: Not in scope: `fromInt'" error
18:13:12 <infrared> i can't find fromInt in hoogle...
18:13:21 <fax> fromIntegral
18:13:22 <Cale> infrared: where'd you get that version of QuickCheck?
18:13:30 <Cale> infrared: It must be terribly old.
18:13:32 <infrared> http://www.cs.chalmers.se/~rjmh/QuickCheck/
18:13:33 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
18:13:43 <infrared> isn't that the homepage of QuickCheck?
18:13:44 <Cale> infrared: QuickCheck is bundled with GHC now.
18:13:53 <Cale> That page is somewhat outdated.
18:13:57 <sjanssen> @hackage QuickCheck
18:13:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck
18:14:13 <Cale> or yeah, you can get even newer ones from Hackage
18:14:14 <sjanssen> infrared: grab it from there ^^^
18:14:31 <sjanssen> Cale: quickcheck isn't always installed with GHC nowadays
18:14:32 <Cale> But you might be content with the one which is already in GHC and Hugs.
18:14:56 <Cale> Well, it's typically available as a separate package from the same provider that you got GHC from.
18:15:31 <Cale> libghc6-quickcheck-dev in Ubuntu
18:15:36 <infrared> i'm on kubuntu, and installed quickcheck library (i think)
18:15:39 <infrared> yeah, this one
18:15:57 <Cale> So it should be available as Test.QuickCheck
18:16:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
18:16:02 <lambdabot> http://tinyurl.com/y3vmep
18:16:03 <infrared> import QuickCheck doesn't work though..
18:16:08 <infrared> oh, Test.
18:17:14 <infrared> Cale: any idea where the quickcheck script is in ubuntu?
18:18:07 <Cale> hmm, I'm not sure
18:18:29 <Cale> I happen to have a copy in /usr/local/bin, but I probably got it elsewhere
18:18:37 <P_D> I need some heap advice: http://hpaste.org/2833 Monte carlo simulation.  When I run it a million times, it consumes a few hundred MB unnecessarily, as all the state is a 1024 element map.  What can I do to reduce heap usage (for bigger runs) with out going imperative?
18:19:12 <Cale> Maybe replace that foldl with a foldl'
18:19:21 <hpaste>  luqui pasted "Using type families correctly?  If so, where to get started debugging?" at http://hpaste.org/2834
18:20:09 <P_D> Replacing with foldl', no change
18:20:30 <Cale> oh, also insert -> insert'
18:20:52 <Cale> errr...
18:21:02 <Cale> nevermind that :)
18:21:26 <Cale> oh, you want insertWith' (+)
18:21:40 <fax> :t insertWith
18:21:42 <lambdabot> Not in scope: `insertWith'
18:21:49 <fax> :t insert
18:21:51 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
18:21:52 <fax> hmm :|
18:21:53 <Cale> :t Data.Map.insertWith
18:21:55 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
18:22:16 <fax> > insert 3 [1..10]
18:22:18 <lambdabot>  [1,2,3,3,4,5,6,7,8,9,10]
18:23:16 <P_D> That helped
18:23:24 <P_D> besides looking much nicer =)
18:23:32 <P_D> 90MB now
18:23:34 <P_D> down from 300MB
18:23:41 <P_D> Fewer thunks?
18:24:49 <Cale> P_D: yeah
18:26:09 <Cale> insertWith' will force the evaluation of the function so that you don't end up with long chains of 1 + (1 + (1 + ...)) in your map
18:26:16 <Cale> or in your case, 1 + (lookup...)
18:26:23 <P_D> Oh I used insertWith
18:26:27 <P_D> insertWith':  gorgeous, 3MB
18:26:37 <Cale> ah, hehe
18:26:40 <P_D> =) thanks
18:27:05 <Cale> No problem
18:27:59 <P_D> anything I could be doing more idiomatically?
18:31:53 <sjanssen> P_D: you can get rid of the foldl with fromListWith
18:32:28 <sorear> P_D: Can Ord a be strengthened to Ix a?
18:32:50 <sorear> P_D: eg. dense subsets of int
18:33:17 <P_D> yes, they're Ints [0,1024)
18:33:19 <sjanssen> cnt = Map.toList . Map.fromListWith (+) . map (\x -> (x, 1))
18:33:42 <sorear> P_D: this is the canonical use-case of accum
18:33:51 <sorear> @ty Data.Array.IArray.accum
18:33:56 <sjanssen> hmm, I bet that has a space leak
18:34:00 <lambdabot> forall e e' (a :: * -> * -> *) i. (Ix i, Data.Array.Base.IArray a e) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
18:34:14 <sjanssen> @type Data.Array.IArray.accumArray
18:34:14 <P_D> sjanssen: yes, 90MB
18:34:16 <lambdabot> forall e e' i (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
18:34:17 <sorear> @ty Data.Array.IArray.accumArray
18:34:18 <lambdabot> forall e e' i (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
18:34:54 <sorear> @ty Data.Array.IArray.accumArray (\a _ -> 1 + a) 0 (0,1023) ?lst
18:34:56 <lambdabot> forall e e' t (a :: * -> * -> *). (Num e, Num t, ?lst::[(t, e')], Ix t, Data.Array.Base.IArray a e) => a t e
18:35:10 <balodja> How to specify type in "let"?
18:35:15 <sorear> @ty Data.Array.IArray.assocs (Data.Array.IArray.accumArray (\a _ -> 1 + a) 0 (0,1023) ?lst :: Data.Array.Unboxed.UArray Int Int)
18:35:16 <lambdabot> (?lst::[(Int, e')]) => [(Int, Int)]
18:35:26 <sorear> that will use about 4k of memory
18:35:31 <balodja> > let f x = x :: Int -> Int in f 3
18:35:32 <lambdabot>   add an instance declaration for (Num (Int -> Int))
18:36:03 <sorear> balodja: let f :: Int -> Int ; f x = x in f 3
18:36:11 <sorear> balodja: *exactly* the same as at the top level
18:36:53 <sorear> balodja: in GHC you can also use ML-oid syntax, let f (x::Int) :: Int =
18:36:54 <sorear> x
18:38:14 <balodja> ok, thanks
18:39:31 <hpaste>  sarehu pasted "for infrared" at http://hpaste.org/2835
18:40:42 <infrared> sarehu: thanks!
18:42:31 <sarehu> infrared: it has a bug!
18:42:38 <sarehu> infrared: missing nonillion
18:43:16 <sarehu> er, I thought it was named novemtillion... so maybe you want to fix that.
18:43:52 <infrared> 10**30, i don't think i'll ever need a number that big :)
18:44:15 <hpaste>  (anonymous) annotated "for infrared" with "(no title)" at http://hpaste.org/2835#a1
18:44:30 <sarehu> Ok, that's just the fixed version.
18:44:44 <infrared> cool, thanks again
19:33:59 <Cale> http://cale.yi.org/autoshare/monadlaws.jpg -- the monad laws as string diagrams
19:34:14 <Cale> http://cale.yi.org/autoshare/adjunctionlaws.jpg -- the laws for an adjunction F -| G
19:34:36 <mrd> laws .. or commandments
19:34:44 <Cale> http://cale.yi.org/autoshare/rightunit.jpg -- the proof of the right unit law for the monad arising from F -| G
19:35:08 <Cale> http://cale.yi.org/autoshare/monadassociativity.jpg -- the proof of the associaivity for the same
19:35:25 <Cale> +t
19:35:35 <balodja> topology :)
19:36:16 <Pseudonym> Just a moment.
19:36:25 <Pseudonym> Monad associativity doesn't follow from naturality, IIRC.
19:38:12 <balodja> How to define an instance of MyShow for every instance of Show? instance (Show a) => MyShow a where myshow = show ?
19:38:21 <Pseudonym> And the proof is that it's trivial to implement a "monad" in Haskell which doesn't obey the associative laws.
19:38:21 <Igloo> Cale has reduced something I understand into something I don't understand. He must be a mathematician  :-)
19:38:34 <Pseudonym> Even though all of the operations are natural, by the free theorem.
19:38:54 <Cale> http://cale.yi.org/autoshare/leftunit.jpg -- and here's the left unit just for completeness
19:39:09 <Pseudonym> Perhaps I'm misunderstanding what you're proving here.
19:39:09 <Cale> Pseudonym: it's by naturality of the unit and counit
19:39:18 <Pseudonym> Oh, it's from the adjunction.
19:39:18 <Pseudonym> Right.
19:39:32 <Pseudonym> Oll korrect, do carry on.
19:39:39 <Cale> These are duals to 2-categorical diagrams
19:39:51 <Cale> So 2-cells are categories
19:39:56 <Cale> 1-cells (lines) are functors
19:39:58 * Pseudonym hasn't gotten this far in the videos, BTW
19:40:03 <Cale> and 0-cells are natural transformations
19:40:14 <Cale> I think this is the next couple of videos :)
19:40:47 <Pseudonym> You know, I kinda like the 10-minute-long maths lecture.
19:41:16 <Cale> heh, the buzzer is a nice touch
19:41:25 <Pseudonym> Category Theory for the Short Attention Span.
19:48:47 <sorear> balodja: that would work, but it's usally a bad idea
19:48:56 <sorear> balodja: care to explain your use-case?
19:49:06 <pjd> Abstract Nonsense:  YouTube Generation Edition
19:51:00 <Pseudonym> "Leave Saunders Mac Lane alone, you BASTARDS!"
19:53:08 <balodja> sorear: I want to redefine show for Int and to preserv instances for other types
19:54:06 <balodja> design bug? :)
19:54:18 <sorear> heh, probably :)
19:54:22 <sorear> balodja: that won't work well with your proposed solution
19:54:35 <balodja> I know, I know.
19:54:57 <sorear> balodja: both the 'a' instance and the 'Int' instance wil work; overlapping instances are very ill-defined in GHC
19:54:57 <Pseudonym> Why do you want to redefine Show specifically?
19:57:04 <balodja> Just as an exercise. But I see, that it's not good idea.
20:13:25 <notsmack> trying to configure yi from darcs:      Could not find module `Distribution.Setup':
20:13:25 <notsmack>       it is a member of package Cabal-1.1.6.2, which is hidden
20:17:05 * sorear wishes PR Stanley wouldn't prefix his answers with >
20:19:03 <oerjan> i guess his editor does that by accident and he just cannot see it.
20:22:07 * dolio kind of wishes he'd get a copy of his book without missing symbols all over the place. :)
20:32:43 <hpaste>  shapr pasted "Is this legal?" at http://hpaste.org/2836
20:33:00 <shapr> I get an error when compiling that, fixable by removing the \n
20:33:04 <shapr> Should it compile?
20:33:31 <Pseudonym> Ha, offside rule.
20:33:33 <Cale> shapr: what happens if you indent the line following the , by one space?
20:33:36 <Pseudonym> Put a space in before the second line.
20:33:44 <Pseudonym> Like Cale said.
20:34:00 <shapr> says duplicate type signature
20:34:28 <Cale> Well, that's odd
20:34:33 <shapr> removing the \n fixes it
20:34:43 <shapr> But this is Galois code, so I suspect they're actually using it.
20:35:08 <shapr> Oh, I see the problem.
20:35:21 <shapr> Right, now I get it.
20:35:49 <oerjan> :t let test, ; test2 :: Int ; test = 1; test2 = 2 in (test,test2)
20:35:54 <lambdabot> parse error on input `;'
20:36:16 <oerjan> should have been equivalent to that
20:38:23 <goalieca> no random spontaneous math lectures tonight?
20:38:30 <mrd> you just missed it
20:38:53 <goalieca> ah well. indoor soccer takes precidence
20:39:27 <mrd> when you complete a proof, do you shout: GOOOOOOOOOOOOOOOOOAAAAAAAAAALLLL!!!!!!?
20:39:40 <psnively> No, we shout: QED!
20:39:40 <fax> hahaha
20:39:48 <goalieca> actually.. i do my happy dance
20:39:55 <goalieca> i learned that from all the years of ice hockey
20:40:12 <goalieca> my happy dance whenever a i design a circuit that works
20:40:13 <goalieca> or whatever
20:40:47 * goalieca shouts "c'est le but! go habs go!"
20:40:58 <goalieca> il lance il compte
20:41:05 <goalieca> gooooaaal
20:44:24 <shapr> Jag har ingen aning vad du sager, men har ar kanin med pankakka pa huvudet.
20:45:22 <joed> Pankaka
20:45:30 <joed> It's not finnish.
20:46:13 <joed> Only word in Swedish with a double K I think is Kokkenmodding, being a waste site from the Iron era.
20:46:32 <P_D> Kokken as in coke?
20:46:39 <joed> Oh, and two n's Pannkaka
20:46:50 <shapr> joed: My confusion comes from living 3.5 years in Finland and THEN 3.5 years in Sweden.
20:47:08 <joed> shapr: :) I left sweden about 12 years ago
20:47:23 <shapr> Det Ã¤r sÃ¥ lÃ¤tt att blir forvÃ¥nade
20:47:29 <joed> bli
20:47:33 <shapr> right
20:47:34 <shapr> That too
20:47:36 <shapr> dang
20:47:40 <shapr> I only left a year ago.
20:47:50 <shapr> Kommer du frÃ¥n Sverige?
20:47:52 <joed> Swedish is one of the most complex languages you can learn I think.
20:48:02 <shapr> Um, I think Finnish has it beat by leagues.
20:48:17 <joed> Well - that is just noices :)
20:48:26 <shapr> I picked up enough Swedish to get by in a few months, but I never reached that level in Finnish.
20:48:45 <joed> You from what you wrote picked up an amazing amount.
20:49:09 <shapr> Jag hade en Svensk flickvÃ¤nn.
20:49:22 <joed> One n :) That helps.
20:49:27 <shapr> Hon slutade vÃ¥r relation just en vecka innan :-(
20:49:36 <joed> I'm sorry.
20:49:38 <shapr> Me too
20:49:54 <shapr> So how'd you end up in Chicago?
20:50:01 <shapr> And how'd you end up in #haskell?
20:50:08 <shapr> Most Swedes in #haskell get here via Chalmers.
20:50:40 <joed> Me, I'm in Philly, work for a Startup in Indy and got here as I at work write Java.
20:51:12 <shapr> How'd that lead you to #haskell?
20:51:56 <shapr> Anyway, I'm just being curious, you don't have to say if you don't want to :-)
20:52:02 <shapr> inga problem
20:52:09 <joed> Long story short, I like SICP, I assumed that if I could get some functional patterns I'd learn to better construct objects
20:52:15 <shapr> Ah, very true
20:52:30 <joed> I never went to MIT, I'm more one of those started hacking at 12
20:52:56 <psnively> You're better off avoiding objects.
20:53:02 * ddarius started hacking at 12,
20:53:03 <shapr> I never had any CS or math college courses, so I know what you mean.
20:53:10 <shapr> I started hacking at 11
20:53:10 <joed> I'm quite a bit older now and felt I missed out on something after having done Algol, Pascal, C, Java
20:53:22 <shapr> some 25 years ago
20:53:30 <joed> About some such yes :)
20:53:31 <pchiusano> hello
20:53:36 <shapr> hi pchiusano
20:53:37 <phobes> That's nothing - sorear IS 12 and knows more about everything than anyone
20:53:50 <shapr> Isn't he 13 by now?
20:54:04 * shapr grins
20:54:21 <ddarius> phobes: There are definitely holes in what sorear knows.
20:54:28 <psnively> Ah, Algol-60, the late, lamented.
20:54:33 <shapr> Much like there are holes in what ddarius knows...
20:54:39 <shapr> But don't ask me to find either of those!
20:54:40 <ddarius> Indeed.
20:54:50 <ddarius> (to your first comment)
20:55:09 <shapr> I'm not stupid. I just don't work very hard.
20:55:09 <joed> shapr: So anyways I started 'selling' code when I was 16, moved, worked and funnily enough have mostly worked as a consultant/integrations/custom code person
20:55:12 * shapr is joking
20:55:29 <phobes> ddarius:  My statement may have included some hyperbole for dramatic effect
20:55:31 <shapr> Oh, I thought up a new motto today in the shower: Live fast, die old, leave behind lots of beautiful code.
20:55:39 <pchiusano> are there other ways of dealing with side-effects besides monads?
20:55:49 * ddarius would rather leave behind lots of beautiful children.
20:55:57 <joed> I.e I guess I want to be a 'Hacker' in the true sense, Haskell seemed very hackish.
20:55:59 <shapr> pchiusano: Sure, look at Clean's uniqueness types, or linear types.
20:56:10 <P_D> children are code, code is children
20:56:11 <shapr> What's the other thing that's closely related to linear types?
20:56:26 <phobes> uniqueness types
20:56:29 <ddarius> shapr: There are a lot of things related to linear types.
20:56:38 <shapr> What're the two things edwardk is using in his substructural type system?
20:56:40 <mrd> you could pass worlds around explicitly
20:56:46 <shapr> Maybe it is both linear and uniqueness types.
20:57:01 <sorear> phobes: first, I'm 16.  second, it really really gets on my nerves when people accuse me of knowing everything.
20:57:10 <shapr> joed: I agree, Haskell is 'hackish'
20:57:20 <shapr> sorear: It's complementary teasing :-)
20:57:30 <shapr> er, complimentary*
20:57:30 <joed> shapr: I ment that in a very complementary way.
20:57:31 <shapr> sheez
20:57:34 <sorear> sure :)
20:57:38 <shapr> joed: Oh, I understand, and agree.
20:57:40 <P_D> Dual to a compliment?
20:57:45 <shapr> P_D: haha!
20:57:51 <pchiusano> hi
20:58:00 <shapr> pchiusano: Hey, haven't I seen you here before?
20:58:08 * shapr grins
20:58:21 <pchiusano> ah... ya I am in here occasionally
20:58:25 <sioraiocht> sorear: you're 16?
20:58:30 <pchiusano> I just got cut off
20:58:34 <joed> shapr: Ping me if you need swedish grammar. :)
20:58:37 <shapr> pchiusano: Did you see my response about linear and uniqueness types?
20:58:40 <shapr> joed: Heh, thanks
20:58:53 <phobes> sorear:  I actually knew you were 16, and figure there are a few things you don't know :)
20:58:54 <ddarius> sioraiocht: Yes, but there are (at least) two other younger youngins.
20:58:58 <shapr> joed: But since my gf dumped me three days before my migrationsverket interview, I don't think it's likely.
20:59:01 <pchiusano> did my question go through? I asked: are there other ways of dealing with effects besides monads
20:59:12 <pchiusano> shapr, no I missed that
20:59:16 <ddarius> pchiusano: Yes.
20:59:18 <joed> shapr: Oh, I do german as well :)
20:59:19 <sioraiocht> ddarius: ah, I had no idea
20:59:35 <shapr> It's sad, I wanted to marry that silly chick.
20:59:41 <sorear> sioraiocht: Yes.
20:59:49 <shapr> Anyway, code never rejects me.
20:59:51 <ddarius> sioraiocht: As far as the knowledge/age ratio, I think sorear is near the top though.
20:59:52 <psnively> shapr: I'm sorry.
20:59:52 * arcatan knows everything too
20:59:59 <shapr> psnively: It's life.
21:00:00 <ddarius> shapr: The typechecker does though.
21:00:01 <psnively> Your code never rejects you? Take more risks.
21:00:07 <sioraiocht> ddarius: I think his is above mine =p
21:00:12 <pchiusano> uniqueness types, ya, I have read a little bit about that
21:00:14 <P_D> Not at runtime, which is what counts
21:00:14 <shapr> psnively: You know what I mean :-P
21:00:20 <shapr> P_D: hah!
21:00:29 <psnively> shapr: Yes, I'm being a smartass. Sorry.
21:00:34 <sorear> Yes, dealing with people smarter than you is a lot less irritating when you know they are twice your age. :P
21:00:53 <psnively> Or closer to three times.
21:00:59 <phobes> sorear: Not when you're 40
21:01:01 <shapr> Really? I never find it hard to deal with people who are smarter than me.
21:01:11 <sioraiocht> sorear: I disagree completely, lol
21:01:13 <shapr> I find it VERY hard to deal with people who are significantly stupider than me though.
21:01:39 <sioraiocht> shapr: significantly stupider? I'd say the asme for moderately less intelligent
21:01:42 <pchiusano> shapr, can you um, repeat your answer :)
21:01:44 <sioraiocht> <---- very impatient
21:01:55 <phobes> I can imagine that I'd find it hard to interact with someone smarter than me ...  :P
21:01:55 <joed> I love dealing with people smarter than I....  That's why you want to work in a startup.
21:01:59 <shapr> pchiusano: uniqueness and linear types
21:02:04 <shapr> joed: Yeah, same for me.
21:02:12 <Pseudonym> The people I like working with are as smart as I am, but know different things than I do.
21:02:19 <shapr> phobes: Assholes come in every IQ bracket, but so do really nice people.
21:02:21 <sioraiocht> I love working with people smarter than me, it's the best wya to learn
21:02:23 <pchiusano> shapr: oh, was that it? :)
21:02:25 <Pseudonym> shapr: So true.
21:02:26 <joed> phobes: Smart is not going to equate to personal skills.
21:02:46 <sioraiocht> joed: I usually find that equation is an inverse relation, anyway =p
21:02:51 <joed> phobes: We have a 'no-asshole' metric
21:02:53 <Pseudonym> Hell, even Linus comes across as an arsehole to non-Finns.
21:03:10 <psnively> s/even Linus/especially Linus/
21:03:16 <joed> So yeah we hire seldom.
21:03:24 <Pseudonym> psnively: True.
21:03:31 <psnively> :-D
21:03:33 <Syzygy-> Saw a few minutes in the middle of a TerroristHackerActionMovie recently while dining.
21:03:38 <psnively> Could be worse. Could be Stallman.
21:03:41 <Syzygy-> The Main Bad Guy was named ... Axl Torvalds.
21:03:48 <P_D> tears
21:03:53 <psnively> LOL
21:03:55 <Pseudonym> Stallman isn't an arsehole, though.
21:04:00 <P_D> No, but he is nuts
21:04:01 <shapr> He isn't??
21:04:01 <psnively> I beg to differ.
21:04:03 <phobes> joed:  yikes,  am I the asshole?
21:04:04 <ddarius> Stallman is just completely buck nutty.
21:04:07 <Pseudonym> He's many things that I don't like, but I don't think he's that.
21:04:14 <shapr> Pseudonym: Have you met him?
21:04:18 <Pseudonym> Briefly.
21:04:25 <psnively> OK, it's possible that my definition of "asshole" is a bit more umbrellaesque than yours.
21:04:30 <Pseudonym> Perhaps.
21:04:34 * ddarius tries to be an asshole with moderate success.
21:04:35 <Pseudonym> Hard to get on with, yes.
21:04:42 <shapr> He came to Finland while I was there, and the stories I heard made him out to be a total asshole.
21:04:50 <joed> phobes: Nah just simply we have a 'soft' culture, I.e every tuesday we do a 'smack-down' all devs interview one on one all devs etc.
21:05:07 <Pseudonym> Admittedly, I haven't interacted with him personally much.  No more than a handshake, really.
21:05:22 <sioraiocht> Prelude> traceroute xxx.xxx.xxx.xxx
21:05:22 <sioraiocht> <interactive>:1:0: Not in scope: `traceroute'
21:05:25 <shapr> joed: sounds nice
21:05:25 <psnively> I don't have a problem with people challenging ideas strongly. I do have a problem with it being personal.
21:05:26 <sioraiocht> I do that way too often..
21:05:26 <joed> phobes: So we have said no to some seriously good people as they never would fit.
21:05:29 <shapr> joed: Hiring? :-)
21:05:34 <Pseudonym> The nicest guy in open source, I think, is Bruce Perens.
21:05:42 <joed> shapr: Interactions.net
21:05:45 <Pseudonym> He's the George Harrison.
21:05:54 <psnively> By all accounts, Bruce Perens is one of the nicest guys, period.
21:05:55 <P_D> if you have to say open source, the person has to be nuts
21:06:04 <joed> Nah.
21:06:07 <Pseudonym> P_D: Bruce isn't nuts.
21:06:14 <joed> Opensource is great.
21:06:21 <psnively> Guy Steele is really nice. Don Knuth is really nice.
21:06:24 <joed> if taken in moderate doses
21:06:30 <Pseudonym> They're not open sourcwe guys, though.
21:06:32 <P_D> isn't Steele a prof?
21:06:36 <P_D> And knuth obviously is
21:06:40 <Pseudonym> Yeah.
21:06:48 <Pseudonym> Well, Steele is at Sun now, IIRC.
21:06:53 <psnively> Steele is a huge fan of open source, as is Knuth.
21:07:07 <Pseudonym> Fan, yes, but they're not open source bosses.
21:07:16 <P_D> they're people for whom the work comes first
21:07:19 <Pseudonym> Self-styled or otherwise.
21:07:20 <P_D> not evangelists
21:07:30 <psnively> ESR is a nice guy.
21:07:33 <joed> pragmatism++
21:07:39 <P_D> ESR is definitely crazy though!
21:07:40 <psnively> Guido van Rossum is a nice guy.
21:07:42 <reffie> lol psnively
21:07:42 <Pseudonym> He actually is, I agree with that.
21:07:45 <phobes> joed:  Ahh ok ... I always find over the top not-serious boastfulness to be easier than sincerity
21:07:45 <shapr> psnively: Um, no.
21:07:47 <Pseudonym> He's nice, and crazy.
21:07:56 <sioraiocht> psnively: that's the python guy, right?
21:08:02 <psnively> shapr: No? He was  nice to me. :-)
21:08:03 <psnively> Yes.
21:08:04 <phobes> joed:  Because everyone has people that they DO consider themselves smarter than
21:08:14 <joed> phobes: True.
21:08:16 <Pseudonym> Guido has gone a bit funny since falling in with Microsoft.
21:08:16 <reffie> one day i'll be famous
21:08:24 <Pseudonym> reffie: I've heard of you!
21:08:25 <phobes> joed:  And if you're being sincere when talking about relative intelligence, then it just gets awkward
21:08:29 <psnively> Falling in with... Google, you mean?
21:08:33 <reffie> Pseudonym you have???
21:08:42 <Pseudonym> Yeah!
21:08:43 <Pseudonym> On IRC!
21:08:46 <reffie> lol
21:08:50 <joed> phobes: Let us call it accomplishment?
21:08:55 <psnively> Jean-Claude Wippler (MetaKit)... very nice guy.
21:09:05 <phobes> joed:  Accomplishment is much easier to discuss objectively
21:09:05 <reffie> i've seen guido once
21:09:10 <reffie> maybe more than once
21:09:15 <psnively> The sqlite guy whose name escapes me... nice guy.
21:09:22 <joed> phobes: Aye, sorry, I'm Swedish :)
21:09:48 <shapr> joed: Nothing about careers on that website.
21:09:58 <phobes> joed:  Yes, I realize that my sense of humour doesn't always translate to the wide audience on here
21:10:13 <psnively> Lack of tone and body language doesn't help, either.
21:10:30 <joed> shapr: Mainly (Only) handpicked.  shapr I'm sure you'd rock.
21:10:30 <ddarius> phobes: You made a jobe?
21:10:45 <P_D> Like phobes said..
21:10:47 <shapr> joed: Have you heard of me before?
21:10:49 <joed> phobes: :)
21:10:50 <sorear> Guido?  isn't he that evil lambda hater guy?
21:11:00 <joed> shapr: I've seen you here for a while.
21:11:03 <psnively> I think you could reasonably hire anyone on #haskell.
21:11:08 <P_D> speaking of python
21:11:10 * ddarius disagrees.
21:11:12 <fax> lambda hater!
21:11:13 <psnively> sorear: Regrettably, yes.
21:11:17 <sorear> joed: shapr *founded* #haskell
21:11:20 * fax learns a new insult :D
21:11:21 <shapr> psnively: I tried to hire lambdabot for the night...
21:11:22 <phobes> ddarius:  ... not a joke so much as a not-serious statement
21:11:28 <psnively> ddarius: Of course it's not quite literally true.
21:11:31 <psnively> shapr: LOL
21:11:37 <joed> As in being Swedish we master understatements.
21:11:38 <shapr> joed: Yes, I've been here for awhile :-)
21:11:41 <P_D> I have to use python at work because I can't stand anything other than pythoncard for making guis.  What's 'the way' to make haskell GUIs?
21:11:58 <P_D> need win32 and linux portability
21:12:07 <joed> shapr: You most likely would outwit us all.
21:12:10 <sorear> P_D: get functional users
21:12:12 <ddarius> P_D: There isn't "A One True Way".
21:12:17 <psnively> wxHaskell?
21:12:20 <shapr> joed: I dunno, large ego is not one of my job skills.
21:12:27 <ddarius> P_D: The two most pragmatic options are gtk2hs and wxHaskell.
21:12:27 <shapr> P_D: I like gtk2hs
21:12:47 <Pseudonym> ?users
21:12:47 <lambdabot> Maximum users seen in #haskell: 407, currently: 342 (84.0%), active: 18 (5.3%)
21:12:51 <psnively> Gtk2Hs
21:12:52 <P_D> ok let me define the way:  Maintained, reliable, retardedly easy to make hopefully with a GUI GUI builder
21:12:57 <Pseudonym> So that's at least 342 people you could hire.
21:12:58 <joed> shapr: What we do is pretty interesting, the CTO if you look at it is a very good profile. We like Java.
21:13:00 <Pseudonym> Minus a couple of bots.
21:13:06 <P_D> can you use glade with gtk2hs?
21:13:10 <KatieHuber> yup
21:13:12 <shapr> joed: I'll check out the website.
21:13:14 <ddarius> I'm sure lambdabot would make an excellent hacker.
21:13:27 <joed> shapr: And we have good financing.
21:13:45 * lambdabot iZ l33+ h4X0R d00D!!!!!1!!!
21:14:24 <psnively> @quote heat.death
21:14:24 <lambdabot> sorear says: Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer
21:14:24 <lambdabot> science problem. ;-)
21:15:44 <goalieca> lol
21:15:53 <psnively> :-)
21:15:57 <psnively> I'm immortal!
21:16:55 <sioraiocht> I think it's funny how we anthropomorphise lambdabot
21:16:59 <goalieca> was it asimov who wrote the last question
21:17:09 <ddarius> Random thing from earlier: Blech on circling natural transformations in string diagrams.
21:17:14 <P_D> Last question?
21:17:26 <ddarius> sioraiocht: In what way is it funny at all?
21:17:30 <P_D> Oh
21:17:38 <P_D> With the Worldvac and sof orth?
21:17:42 <P_D> Yes
21:17:44 <sioraiocht> ddarius: are you suggesting it's somethign else? pathetic perhaps? =p
21:17:53 <goalieca> heh :D well here's the paste anyways. http://www.multivax.com/last_question.html
21:17:55 <P_D> And the AC said... let there be light
21:18:01 <P_D> Oops
21:18:02 <P_D> sorry.
21:18:08 <phobes> ddarius is either the humour police or an AI trying to understand comedy
21:18:24 <P_D> Call the AI police to understand ddarius
21:18:45 * ddarius once again gets called non-human.  That's four times!
21:18:52 <ddarius> Twice today!
21:19:09 <P_D> not statistically significant yet.
21:19:16 <sioraiocht> ddarius: don't worry.  I'm sure it's a compliment
21:19:29 <ddarius> sioraiocht: The vast majority of people anthropomorphize computers and tools.
21:19:29 <P_D> 1 sigma level goes <1
21:19:54 <sioraiocht> ddarius: I know, it's maddening when one of my friends calls me and says "My computer seems mad at me"
21:19:59 <sioraiocht> or "maybe it just needs a break"
21:20:02 <jcreigh> Of course, you should never anthropomorphize computers. They *hate* that.
21:20:08 <Adamant> my computer loves to piss me off
21:20:14 <ddarius> P_D: Well you have to compare to the number of times I've been called "human."
21:20:30 <P_D> or a normal person gets called human
21:20:36 <P_D> Oops, sorry.
21:20:38 * ddarius thinks anthropomorphization is an efficient form of communication about such issues.
21:20:53 <thoughtpolice> i heard they smell your fear. :(
21:21:39 <Adamant> tastes like voltage
21:21:52 * ddarius has tasted current before, not voltage.
21:22:07 <P_D> currant?
21:22:29 * ddarius only likes good puns which are very very rare.
21:23:14 <P_D> As you've demonstrated.
21:23:25 <Adamant> rare good puns, or good puns are rare?
21:23:47 <Adamant> uncooked pun, yum
21:24:16 <sioraiocht> perhaps a pun tartare?
21:26:11 <timthelion> I think I have something truely revolutionary here: http://timtheli.freeshell.org/ipd
21:26:29 <timthelion> it's a little shell script which I wrote this afternoon.
21:26:59 <P_D> hsh?
21:27:25 <timthelion> hsh?
21:27:33 <P_D> Haskell Shell
21:27:38 <P_D> is this what you've invented?
21:27:54 <timthelion> not really, that's what I'm working towards.
21:28:03 <timthelion> but this is an actuall thing, that is usefull.
21:28:56 <timthelion> P_D: why do you ask?
21:29:32 <P_D> the question was unprompted
21:30:06 <timthelion> to my knowlege, no one has made any thing usefull in the area as of yet, is that correct?
21:30:13 <dibblego> @tell dibblego foo
21:30:14 <lambdabot> You can tell yourself!
21:30:20 <dibblego> @tell dibblegoo foo
21:30:20 <lambdabot> Consider it noted.
21:30:26 <dibblegoo> d
21:30:27 <lambdabot> dibblegoo: You have 1 new message. '/msg lambdabot @messages' to read it.
21:31:34 <Pseudonym> ?tell lambdabot foo
21:31:34 <lambdabot> Nice try ;)
21:31:51 <Pseudonym> ?tell hpaste foo
21:31:51 <lambdabot> Consider it noted.
21:31:58 <Pseudonym> Oh, now this will be fun.
21:32:17 <ddarius> !paste
21:32:17 <hpaste> Haskell paste bin: http://hpaste.org/
21:32:18 <lambdabot> hpaste: You have 1 new message. '/msg lambdabot @messages' to read it.
21:32:32 <Pseudonym> !paste
21:32:32 <hpaste> Haskell paste bin: http://hpaste.org/
21:32:36 <Pseudonym> Ah.
21:32:38 <ddarius> There exist at least two haskell "shells" and some Clean shell thing as well.
21:33:10 <timthelion> ddarius: what? where are they?
21:33:36 <phobes> @quote
21:33:37 <lambdabot> lennart says:  I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
21:33:37 <lambdabot> useful for functional code
21:33:40 <ddarius> There should be something called hash and I think the other is called hsh.
21:33:57 <ddarius> The Clean thing was described in a paper and the code should be somewhere.
21:34:02 <phobes> @remember @quote test
21:34:02 <lambdabot> Done.
21:34:06 <phobes> @quote @quote
21:34:06 <lambdabot>  @quote says: test
21:34:22 <sorear> nice try
21:34:22 <ddarius> @forget @quote test
21:34:22 <lambdabot> Done.
21:34:27 <sorear> @quote
21:34:27 <lambdabot> davidhasselh0f says: [on SPJ's "A Taste of Haskell" tutorial:] It's better than sex.
21:34:40 <Adamant> don't hassle the h0ff
21:34:49 <sorear> phobes: it won't cause a loop even if it works
21:35:09 <phobes> sorear:  just curious :)
21:35:09 <sorear> phobes: irc has a dumb misfeature that there is no remote echo
21:35:13 <phobes> ah
21:35:44 <jcreigh> sorear: I don't understand...what would a "remote echo" be?
21:35:47 <sorear> @remember ?quote says:
21:35:47 <lambdabot> Done.
21:35:47 <lambdabot2> Done.
21:36:02 <sorear> ?quote ?quote
21:36:02 <lambdabot2> ?quote says: says:
21:36:02 <lambdabot> ?quote says: says:
21:36:03 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
21:36:03 <lambdabot2> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
21:36:12 <sorear> lambdabot2: @part #haskell
21:36:27 <sorear> meh, too tired to get it working
21:36:36 <timthelion> ddarius: you may think that iperative steping is bad, but think of a 3 dimentional box, that can only hold so much, what if you allow things to slide through this box in a 4th dimention, time, it makes soo much more possible.
21:37:48 <Pseudonym> ?remember ?quote ?quote
21:37:48 <lambdabot> Done.
21:37:51 <Pseudonym> ?quote says: ?quote
21:37:52 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
21:37:59 <Pseudonym> ?remember says: ?quote
21:37:59 <lambdabot> Done.
21:38:02 <Pseudonym> ?quote says:
21:38:02 <lambdabot> says: says: ?quote
21:38:06 <Pseudonym> Hmm.
21:38:32 <sorear> it's been done with ?where
21:38:33 <jcreigh> sorear: oh! You mean that messages that I send are never echoed back to me?
21:38:35 <sorear> ?where ?where
21:38:36 <lambdabot> I know nothing about ?where.
21:38:38 <sorear> jcreigh: yep
21:38:43 <sorear> ?where loop
21:38:43 <lambdabot> I know nothing about loop.
21:38:47 <sorear> ?where pong
21:38:47 <lambdabot> I know nothing about pong.
21:38:49 <jcreigh> so LB would never see its own message. got it.
21:38:58 <Pseudonym> ?where+ loop ?where loop
21:38:58 <lambdabot> Done.
21:39:01 <Pseudonym> ?where loop
21:39:01 <lambdabot> ?where loop
21:39:06 <balodja> @type (,,,,)
21:39:06 <Pseudonym> Like that?
21:39:08 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
21:39:22 <phobes> So does everyone in IRC see a (potentially) different order of char arrival?
21:39:30 <jcreigh> phobes: pretty much
21:39:48 <balodja> Hm, is there any way to denote every (,,, ... ,)?
21:39:59 <P_D> the messages from the server will be ordered by TCP
21:40:04 <P_D> or some other layer
21:40:13 <phobes> balodja: what do you want to do?
21:40:15 <Pseudonym> ?where+ loop ?where loop
21:40:15 <Pseudonym> ?where loop
21:40:15 <lambdabot> Done.
21:40:15 <lambdabot> ?where loop
21:40:53 <balodja> phobes: To define (,, ... ,) as an instance of class :)
21:41:04 <balodja> @type (,,,,,,,,,,)
21:41:05 <lambdabot> forall a b c d e f g h i j k. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (a, b, c, d, e, f, g, h, i, j, k)
21:41:08 <timthelion> the thing about my script which makes it different than a shell, is that you end up with a reusable haskell program when you're done.
21:41:17 <balodja> It really seems not to have a limit
21:41:45 <phobes> , is (in theory maybe not in implementation) a binary operator
21:42:02 <balodja> That's really good
21:42:39 <phobes> so (a,b,c) is the same as (a,(b,c))
21:42:45 <phobes> assuming I guessed the associativity right
21:42:53 <phobes> probably didn't
21:42:56 <Heffalump> it has a different type, and different bottoms.
21:43:04 <phobes> ah k
21:43:05 <Heffalump> but it's quite close
21:43:23 <phobes> so (a,b,c) ((a,b),c) and (a, (b,c)) are all different types?
21:43:27 <Heffalump> yes
21:43:43 <balodja> @hoogle fst
21:43:44 <lambdabot> Prelude.fst :: (a, b) -> a
21:43:44 <lambdabot> Control.Parallel.Strategies.fstPairFstList :: NFData a => Strategy [(a, b)]
21:43:44 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
21:45:38 <balodja> There is no fst for higher tuples? Good, I'll assume it not to exist :)
21:45:50 <ddarius> timthelion: I'm not Lennart Augustsson
21:46:01 * timthelion googles
21:46:19 <shachaf> "forall a b c d e f g h i j k. -> b -> c -> "...?
21:46:40 <fax> :t (,,,,,,,)
21:46:42 <lambdabot> forall a b c d e f g h. a -> b -> c -> d -> e -> f -> g -> h -> (a, b, c, d, e, f, g, h)
21:46:50 <fax> :o
21:47:13 <shachaf> @type (,,,,,,,,,,)
21:47:13 <balodja> It was cut up to 80 chars may be.
21:47:15 <lambdabot> forall a b c d e f g h i j k. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (a, b, c, d, e, f, g, h, i, j, k)
21:47:51 <shachaf> Why was it cut in the middle, though?
21:48:01 <ddarius> timthelion: I didn't say anything about "imperative stepping" that was a quote of lennart said by lambdabot upon phobes prompting.
21:48:28 <timthelion> ah, I guess I got confused
21:50:04 <oerjan> it seems to me if haskell had had unlifted tuples (that the right term?), it would have been easy to make , associative and to make code that could work on any size of tuple
21:50:36 <oerjan> er, not associative
21:50:46 <phobes> I'm still not sure why you don't just restrict yourself to pairs
21:50:47 <oerjan> i mean, (a,b,c) = (a,(b,c))
21:50:50 <phobes> ya
21:51:38 <oerjan> because of the lifting, (a::A,undefined ::(B,C)) is not a triple
21:51:49 <ddarius> oerjan: What's the type of snd then?
21:51:54 <balodja> Ha. Look at ':t (,,,,,,,,)' in 'ghci'.
21:52:06 <balodja> It just takes another form of output
21:52:10 <oerjan> ddarius: hm, that may be a bit awkward
21:52:35 <balodja> Without 'a' :)
21:52:37 <phobes> ddarius:  It's the same as with lists, right?
21:52:47 <ddarius> phobes: No.
21:53:01 <oerjan> maybe it would have been better to have some cons intermediate
21:53:36 <oerjan> so (a,b) = a :. b :. ()
21:53:37 <phobes> [1,2,3] is sugar for 1:2:3:[]...   You have head and tail ... why wouldn't the same thing work for tuples
21:53:53 <wli> cons and nil
21:53:57 <balodja> oerjan: but types...
21:54:05 <wli> it doesn't work for tuples because it's ill-typed.
21:54:35 <oerjan> balodja: those _were_ the types
21:55:15 <oerjan> type (a,b) = a :. b :. ()
21:55:28 <Heffalump> wli: not if you make nested tuples, e.g. a :. b:. () = (a, (b, ())
21:55:36 <Heffalump> but those would be kind of annoying
21:55:51 <phobes> Heffalump: well, you'd have the same sugar as now
21:56:01 <phobes> err rather, what you have now would be sugar for that
21:56:09 <balodja> oerjan: we cannot have any finite number of universal constructors for the whole tuple.
21:56:36 <phobes> balodja:  You have one (polymorphic) constructor
21:56:45 <oerjan> balodja: huh? note that i am considering how haskell _could_ have been designed
21:57:57 <oerjan> and :. should be unboxed in its second argument
21:57:59 <balodja> imho, higher tuples are unnecessary here
21:58:31 <oerjan> unnecessary in haskell?
21:59:10 <phobes> oerjan:  if you're concerned about not admitting (a, _|_) as a 3-tuple.   Do you have an example of why that would be bad?
21:59:20 <balodja> yeah. i just can't imagin closures with them, for example
21:59:44 <ddarius> phobes: With (a,_|_) (a,(b,c)) is not isomorphic to (a,b,c)
22:00:02 <oerjan> phobes: it's just not how current haskell works
22:00:35 <phobes> ddarius:  ya I know - I was just asking if that was particularly bad
22:00:39 <phobes> oerjan: ok
22:01:08 <ddarius> phobes: It does mean that products in Haskell are not categorical products.
22:01:33 <ddarius> It also means you can't flatten a nested tuple.
22:02:25 <phobes> true
22:02:56 <balodja> And so, if in (a,b) b can be of any type, how to make in (c,d) then?
22:03:27 <balodja> Seems to be abmiguous.
22:03:39 <phobes> huh?
22:03:58 <balodja> s/make in/make it/
22:04:15 <phobes> a,b,c,d are just four arbitrary types?
22:04:32 <balodja> Of course, that's the meaning of tuple.
22:04:56 <phobes> "And so, if in (a,b) b can be of any type, how to make in (c,d) then?"
22:05:02 <phobes> Can you give an example of what you're asking?
22:05:21 <balodja> (a,b). Assume b = (c,d).
22:05:38 <phobes> oh ok
22:06:06 <balodja> If a and b could be of any type, why not assume b to that? And how to define such a tuple?
22:06:47 <phobes> (a, (c,d)) is a valid type... I'm not sure I follow what you're asking
22:07:16 <phobes> (1, ('a', 2)) :: (Int, (Char, Int)), for example
22:08:01 <phobes> sorry, I'm not sure what you're asking ... I'm off to sleep.   Good luck!
22:32:11 <cgranade> How do I use RealFloat with Printf?
22:33:44 <fax> > (printf :: String -> RealFloat -> String) "test %f" 5.68
22:33:46 <lambdabot>      Class `RealFloat' used as a type
22:33:46 <lambdabot>     In the type `RealFloat'
22:33:46 <lambdabot>     In the ...
22:33:52 <fax> I don't know :[
22:34:46 <shachaf> RealFloat is a class.
22:34:51 <shachaf> @instances RealFloat
22:34:52 <lambdabot> Double, Float
22:35:07 <shachaf> > printf "%f" (1.2 :: Double)
22:35:08 <lambdabot>  Add a type signature
22:35:24 <shachaf> > printf "%f" (1.2 :: Double) :: String
22:35:26 <lambdabot>  "1.2"
22:35:31 <fax> > (printf :: String -> Double -> String) "test %f" 5.68
22:35:32 <lambdabot>  "test 5.68"
22:35:34 <notsmack> :t printf
22:35:36 <lambdabot> forall r. (PrintfType r) => String -> r
22:35:49 <fax> @instances PrintfType
22:35:49 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
22:35:54 <fax> hm
22:36:01 <fax> PrintfType is an infinite set?
22:36:16 <sorear> it's a type class
22:37:29 <bos> @seen dons
22:37:29 <lambdabot> I saw dons leaving #xmonad and #haskell 4h 45m 57s ago, and .
22:37:37 <oerjan> @index PrintfType
22:37:37 <lambdabot> Text.Printf
22:37:55 <oerjan> @instances-importing Text.Printf PrintfType
22:37:57 <lambdabot> (a -> r), IO a, [c]
22:38:35 <calvins> "Exposed modules use unallocated top-level names"
22:38:44 <calvins> What does that hackage message mean?
22:39:17 <oerjan> @class PrintfType
22:39:17 <lambdabot> Unknown command, try @list
22:39:30 <oerjan> @src PrintfType
22:39:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:39:35 <oerjan> bah
22:39:47 <shachaf> @source Text.Printf
22:39:47 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
22:40:32 <oerjan> > printf (undefined :: Ordering) :: String
22:40:33 <lambdabot>  Couldn't match expected type `String'
22:40:42 <oerjan> bah
22:40:58 <shachaf> @ty printf
22:41:00 <lambdabot> forall r. (PrintfType r) => String -> r
22:41:08 <shachaf> oerjan: The first argument is always a String.
22:41:22 <oerjan> oh right
22:41:37 <oerjan> :t printf "" ?x
22:41:39 <lambdabot> forall t t1. (?x::t, PrintfType (t -> t1)) => t1
22:41:54 <oerjan> argh!
22:42:43 <oerjan> > printf "" (undefined :: Ordering) :: String
22:42:44 <lambdabot>   add an instance declaration for (PrintfArg Ordering)
22:42:45 <lambdabot>     In the expression:...
22:42:48 <oerjan> finally
22:43:22 <oerjan> @instances-importing Text.Printf PrintfArg
22:43:23 <lambdabot> Char, Double, Float, Int, Integer, [c]
22:58:56 <reffie> anyone happen to know how to plot a single point in gnuplot (without using an additional data file)
23:01:52 <Azmodan> I'm looking for a way to take a string and break it into a list of strings based on a delimiter character, what function should I use?
23:03:02 <fax> @hoogle a -> [a] -> [[a]]
23:03:02 <lambdabot> No matches, try a more general search
23:03:16 <sorear> Azmodan: There isn't one.
23:03:18 <P_D> @hoogle (a -> Bool) -> [a] -> [[a]]
23:03:19 <lambdabot> No matches, try a more general search
23:03:51 <sorear> Azmodan: People have been debating adding it for months if not years, but there is no consensus on the interface, and so no library function
23:04:10 <dibblego> sorear, what's the debate?
23:04:39 <Nafai> Azmodan: Something like Python's stringvar.split(",") ?
23:04:49 <Azmodan> Nafai: Yes
23:04:49 <sorear> dibblego: What to call the function.  Whether to strip empty sublists.  Whether to use a character or a string.  What to do about leading and trailing delimiters.  Etc.
23:05:09 <Azmodan> Nafai: Something like word but for arbitary characters instead of just whitespace.
23:06:03 <Vq^> the sepBy parser might be up for the challenge
23:18:59 <hpaste>  Wendy annotated "discount meridia" with "discount meridia" at http://hpaste.org/1504#a0
23:20:35 <brad__> if i have a value of type Integer, but i know it is within the bounds of Int (i.e. a small number), is there a way to convert this to Int? specifically, i want to do !! with a value that is an Integer
23:20:55 <TSC> :t genericIndex
23:20:57 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
23:21:14 <TSC> ... or you can use fromInteger to convert the Integer to an Int
23:21:25 <TSC> (or fromIntegral)
23:21:26 <brad__> thanks TSC!
23:21:35 <brad__> very helpful!
23:21:37 <TSC> You're welcome
23:23:22 <eck> how can I get the equivalent of C's argv in a Haskell program?
23:23:33 <oerjan> getArgs
23:23:40 <eck> thanks
23:34:04 <glguy> ?get-shapr
23:34:05 <lambdabot> shapr!!
23:42:02 <shapr> glguy: You called?
23:43:58 <glguy> shapr: what version of HAppS should I target if I wanted to bring hpaste up to date?
23:44:07 <shapr> 0.9.1
23:44:11 <glguy> is the new API stable enough to target?
23:44:16 <shapr> I think so.
