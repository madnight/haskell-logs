00:00:48 <ChilliX> sjanssen: by making all the data types Typeable..yeah
00:01:04 <ChilliX> but really, I think, I'll just add a new ghci command
00:01:19 <sjanssen> oh yes, that's definitely better
00:01:28 <ChilliX> if you really write ellaborate type level functions, its nice to be able to just eval them at the prompt
00:01:45 <ChilliX> it's easy enought to implement
00:02:03 <ChilliX> the type checker already got a function to take a type and return its normal form
00:02:22 <ChilliX> It's just a mattr of making it available in ghci
00:03:27 <ChilliX> but probably we want something a bit more clever
00:03:42 <ChilliX> where you can specify a local set of equalities under which to normalise
00:04:25 <ChilliX> somthing like:  :norm (F Int ~ Bool) => F [Int]
00:46:42 <unmarshal> newbie question.  i'm extending someone's code, they do type ProbRep = Float, this is too restricting since my numbers may be a Double.  How do I go about making ProbRep fractional?
00:49:27 <roconnor> unmarshal: I don't think there is a way to do that :(
00:49:36 <glguy> anyone know a good linux program for maintaining a set of ssh tunnels?
00:49:47 <unmarshal> here is what the guy's todo says
00:49:49 <roconnor> glguy: what do you mean maintain?
00:50:16 <unmarshal> -- TO DO: generalize Float to arbitrary Num type
00:50:19 <unmarshal> --
00:50:34 <unmarshal> so i was assuming i just need to make this probtype an instance of fractional ?
00:51:15 <glguy> roconnor: I've got a program in windows that keeps a list of my tunnels, and allows me to set them up and down
00:51:20 <glguy> and reconnects if they drop
00:51:22 <glguy> and so on
00:51:34 <opqdonut> unmarshal: why don't you just change all functions from "... -> ProbRep -> ..." to "(Num a) => ... -> a -> ..."
00:51:47 <unmarshal> trying that now.
00:51:56 <roconnor> unmarshal: I think you need to do what opqdonut suggests
00:52:05 <roconnor> when is a bit tedeous
00:52:09 <roconnor> which
00:52:18 <roconnor> that's probably why it was on the todo list.
00:52:21 <unmarshal> hehe
00:52:24 <unmarshal> thanks guys
00:52:30 <opqdonut> or wel you might actually get a "(RealFrac a) =>" constraint depending on the operations you use
00:53:06 <unmarshal> yeah i think that's going to be it
00:53:18 <unmarshal> needs to be able to handle doubles and floats
00:53:19 <roconnor> glguy: okay.  I as just going to note that you can add ``ServerAliveInterval=200'' to your ssh config
00:53:35 <roconnor> this do a ping every 200 seconds
00:53:37 <glguy> roconnor: so I'm able to do this manually
00:53:38 <roconnor> I think
00:53:53 <roconnor> which helped me keep my ssh sessions opened in the past.
00:53:56 <glguy> I was looking for a frontend to it
00:54:11 <roconnor> glguy: but it sounds like you want something more sophisticated.
00:54:31 <glguy> yeah, something to track common tunnels I use and to keep them alive
00:54:45 <glguy> ideally a client server model
00:54:50 <glguy> I don't want ot have to run it in screen
00:58:49 <sjanssen> glguy: I run some tunnels with xinetd
01:05:53 <earnest> glguy: what is this program that keeps your tunnel up or down on Windows?
01:06:02 <earnest> sjanssen: how do you run tunnels with xinetd?
01:06:17 <earnest> sjanssen: SSH tunnels somehow managed by xinetd?
01:06:39 <earnest> Oh sure; it just calls ssh with the proper parameters, huh?
01:06:56 <sjanssen> earnest: yeah, just a local port that pipes data through ssh
01:07:12 <earnest> Right; so it opens the connection up whenever needed, right?
01:07:41 <sjanssen> yeah
01:09:57 <earnest> I've been keeping a tunnel too, and my tunnel was also dying probably due to inactivity; it looks like that this can be configured on ssh config, but I'd like to see a command line option for ServerAliveInterval. I solved so far by keeping at least one client always open which keeps the tunnel alive; I have very limited control over the left-host-of-the-tunnel.
01:11:21 <earnest> I wasn't too sure why it was dying... SSH doesn't really report that; I was able to catch the exit status, and even googled for it, but I didn't find anything meaningful; SSH also reports its exit status to syslog, which I was able to read on the right-host-of-the-tunnel, because on the left side I can't read /var/log/messages, for instance.
01:12:21 <earnest> The xinetd idea seems very good, but I wouldn't be able to use it.
01:13:27 <pejo> earnest, for dying tunnels - do you have a firewall somewhere along the way? They sometimes prune inactive connections.
01:14:37 <earnest> Hm, it could be; but I wouldn't know if there are firewalls after the left-side-host. To find out, I'd have to infer its existence from programs like... nmap, for example.
01:14:42 <unmarshal> newtype Dist a = D {unD :: [(a, Float)]}
01:14:50 <unmarshal> is there any way to make dist use a float or double
01:16:04 <quicksilver> earnest: you can use ClientAliveInterval instead
01:16:13 <quicksilver> earnest: depending which config file is easier to modify
01:17:02 <earnest> Ideally I'd use a command line option; by the way, I don't see ClientAliveInterval in the man page for ssh(1). Maybe info files?
01:17:04 <quicksilver> unmarshal: type FloatOrDouble = F Float | D Double
01:17:24 <doserj> *data FloatOrDouble
01:17:37 <quicksilver> thanks doserj
01:17:41 <opqdonut> earnest: you can use the -o flag to set config file options on the commandline
01:17:45 <quicksilver> earnest: the manpages are ssh_config and sshd_config
01:17:53 <quicksilver> earnest: depending if you want client or server side
01:18:05 <earnest> Hm, perfect. :)
01:18:16 <quicksilver> earnest: the AliveInterval options only came in in a relatively recent ssh release though
01:18:30 * quicksilver can't think of a reason to prefer using -o to just having a .ssh config :P
01:18:56 <opqdonut> quicksilver: if you want to set the option for only some cases
01:19:06 <earnest> My reason is that I can't really change these files; or if I change, I might very easily lose my changes. I don't really own the user I'm using.
01:19:09 <opqdonut> for example i use it to set ProxyCommand on the occasions i ssh out of work
01:19:16 <opqdonut> but mostly i ssh inside work :)
01:19:20 <quicksilver> opqdonut: indeed, I was talking about this specific example
01:19:20 <pejo> opqdonut, you can set them on a host basis, and create an alias for the special time.
01:19:26 <opqdonut> quicksilver: i realize
01:19:36 <quicksilver> opqdonut: AliveInterval doesn't really have disadvanages
01:19:46 <earnest> quicksilver: yeah, my ssh doesn't seem to support this option: ClientInterval: %ssh -V
01:19:46 <earnest> OpenSSH_4.6p1 FreeBSD-openssh-portable-overwrite-base-4.6.p1,1, OpenSSL 0.9.7m 23 Feb 2007
01:19:54 <opqdonut> yeah in this case there is no  point in using the command line option :)
01:19:59 <quicksilver> 'ClientAliveInterval'
01:20:21 <earnest> The typo just went in the last message.
01:20:46 <quicksilver> I would point out that ClientAliveInterval is the server-side option
01:20:52 <quicksilver> and ServerAlive is the client-side one :)
01:20:57 <quicksilver> that tends to confuse me
01:21:09 <Sizur> quicksilver: you never sleep?
01:21:13 <Sizur> quicksilver++
01:21:15 <quicksilver> OpenSSH_4.5p1, OpenSSL 0.9.7l 28 Sep 2006
01:21:17 <earnest> Oh. :) Yeah, I have those now. That confused me too.
01:21:27 <quicksilver> Sizur: sleep is for the weak
01:21:37 <opqdonut> sleep is for the decaffeinated
01:22:02 <Sizur> opqdonut: you arent java coder, are you :P
01:22:15 <opqdonut> Sizur: hell no
01:22:43 <opqdonut> i had to do it at my univ for the basic courses
01:22:43 <Sizur> opqdonut: decaffeineted then ;)
01:22:59 <opqdonut> ahh
01:23:34 <opqdonut> http://en.wiktionary.org/wiki/decaffeinated wiktionary gives -nated as correct
01:23:41 <opqdonut> or are you making some sort of joke?
01:24:35 <Sizur> hmm.. java <=> coffee
01:24:50 <Sizur> so yeah, a joke
01:24:56 <opqdonut> ah yes i see
01:25:02 <opqdonut> what about decaf java?-)
01:25:16 <Sizur> you mean Groovy? :P
01:25:22 <opqdonut> or Jython :D
01:25:22 <scook0_> isn't java already pretty decaf?
01:25:38 <Sizur> Jruby
01:25:59 <earnest> I need a faster CPU.
01:26:17 <opqdonut> Jhaskell
01:28:52 <Sizur> i see no need for jhaskell really. why when you can already compile natively
01:29:36 <Sizur> to talk to all the java classes? beats the purpose of haskell
01:31:43 <opqdonut> but natively compiled is not as portable as java bytecode! :P
01:32:00 <Sizur> java portability is overrated
01:32:08 <opqdonut> (j/k)
01:32:11 <opqdonut> i agree
01:32:14 <Sizur> it's most supported platform is windows
01:34:03 <Sizur> JVM optimizations lag far behind on unix and osx
01:34:37 <Sizur> they are still having trouble implementing a x64 jvm for linux
01:35:42 <quicksilver> one reason for jhaskell would be to put haskell applets in a web page
01:35:43 <earthy> sizur doesn't believe in viral marketing then
01:35:52 <quicksilver> that's the reason I had for using MLj
01:36:06 <earthy> another reason for jhaskell would be to infect large java projects with haskell
01:36:20 <earthy> plus, it'd make cohatoe a shitload simpler and more portable. ;)
01:36:25 <mux> I've always thought it would be fun to have Haskell DOM bindings in firefox
01:36:59 <Sizur> quicksilver: arent applets pretty much dead?
01:37:20 <earthy> pretty much
01:37:24 * quicksilver shrugs
01:37:27 <earthy> servlets have won the day
01:37:29 <earthy> however
01:37:34 <quicksilver> they remain a useful way of embedding a program in a webpage
01:37:43 <quicksilver> a haskell-flash compiler might be more useful
01:37:51 <Sizur> yeah
01:37:57 <quicksilver> servlets appear to me totally irrelevant
01:38:01 <quicksilver> that's somethign quite different
01:39:03 <taruti> Is there something like setArgs to modify the output System.getArgs will produce??
01:39:54 <glguy> ?hoogle withArgs
01:39:54 <lambdabot> System.Environment.withArgs :: [String] -> IO a -> IO a
01:40:16 <taruti> thanks
01:42:21 <Sizur> cant you already compile SWGs using Cairo bindings?
01:42:53 <mux> you mean SVGs ?
01:43:28 <quicksilver> presumably an SWG is halfway between an SWF and an SVG
01:43:51 <quicksilver> it's a cunning way of compiling a flash applet into something that an SVG renderer can execute? ;P
01:44:06 <mux> eh
01:45:00 <Sizur> hehe +fully relational database
01:45:57 <Sizur> i meant swf
01:46:08 <Sizur> and i dont know the answer, was just a question
01:46:31 <quicksilver> no, you can't
01:46:41 <tvashtar> Hey, I have a newbie question, I was thinking about function composition as being a bit like this: f.g(x) == f(g(x)) so if I define an increment function: inc n = n+1 shouldn't inc.inc (1) be 3? Instead it gives an error in ghci?
01:46:53 <quicksilver> to run SWFs requires a flash VM, a bytecode interpreter, and compatible flash libraries
01:46:58 <quicksilver> cairo has none of the above :)
01:47:05 <vincenz> inc.inc $ 3
01:47:16 <quicksilver> tvashtar: you're aboslutely right
01:47:18 <mux> > (+1) . (+1) $ 2
01:47:23 <lambdabot>  4
01:47:26 <quicksilver> tvashtar: it's just the brackets that is the problem
01:47:28 <vincenz> inc . inc(1)  === inc . inc 1 == inc . (the function returned by inc 1)
01:47:33 <quicksilver> tvashtar: (inc.inc) 1
01:47:35 <mux> > let inc = (+1) in (inc . inc) 1
01:47:36 <lambdabot>  3
01:47:55 <Sizur> to run SWF yes, but to make one is a different story
01:48:01 <tvashtar> aha sure enough, thanks that's great, got in a mental rut with that ;-)
01:48:28 <quicksilver> Sizur: oh sorry
01:48:47 <quicksilver> Sizur: but that would presumably not lead to interactivity, if it is possible
01:48:56 <quicksilver> Sizur: and interactivity is the interesting part :)
01:49:12 <quicksilver> Sizur: otherwise you can just use a screen recorder and make a movie
01:50:24 <Sizur> yeah, you'd need to have haskell to actionscript rewriter
01:52:01 <quicksilver> otherwise known as a compiler :)
01:52:21 <quicksilver> although an actionscript producing DSL might be interesting
01:52:26 <quicksilver> a compiler would be cooler
01:57:31 <Randroid> Anyone here have an opinion on monadic subexpressions?
01:57:54 <Randroid> They seem like an obvious idea to me, but some have voiced opposition.
01:59:18 * Randroid can hear the crickets ...
01:59:20 <int-e> you mean the (<- foo) stuff? they have no obvious semantics.
01:59:29 <Randroid> Explain.
01:59:38 <int-e> let foo = (<- foo) in foo
02:00:17 <int-e> note that let is part of the expression syntax. so you should attach some meaning to this, or come up with a clear rule that forbids it.
02:00:22 <int-e> emphasis on clear.
02:00:33 <Randroid> I'm trying to digest the implications.
02:02:22 <quicksilver> Randroid: I dislike the fact that they break "common-sense" program rewriting
02:02:29 * earthy sighs
02:02:32 <earthy> no haskell for .net
02:02:33 <Randroid> The massive downside to *not* having it is that so much of Haskell seems to lack esthetic uniformity. For instance, liftM2, liftM3 etc. are useful, but *all* the parameters have to be non-monadic.
02:02:42 <Randroid> Er, monadic
02:02:43 <earthy> even though multiple groups have proven it possible
02:02:54 <quicksilver> Randroid: let x = (<- foo) in f x x
02:02:56 <earthy> only hugs98.net
02:03:08 <quicksilver> Randroid: is different from f (<- foo) (<- foo)
02:03:28 <quicksilver> Randroid: Yes, but you can just stick 'return's in front of the non-monadic ones
02:03:35 <int-e> Randroid: look at Control.Applicative for inspiration.
02:03:39 <quicksilver> Randroid: and, possibly, think of a shorter symbol for return
02:03:39 <Randroid> quicksilver: I realize that, but it's ... ugly
02:03:53 <int-e> (all monads can be made instances of Applicative)
02:04:02 <Sizur> earthy: microsoft-haskell research has lead to F# i heard
02:04:05 <Randroid> I'm a bit new to Haskell and haven't looked at Applicative
02:04:33 <int-e> @type ap
02:04:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:04:45 <int-e> @type (<*>)
02:04:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:05:11 <quicksilver> Randroid: doesn't seem that different from putting '<-' before some parameters
02:05:23 <Randroid> Yeah, you may be right.
02:05:28 <quicksilver> Randroid: putting return before some
02:05:43 <Randroid> True, it just seems more esthetically satisfying.
02:06:05 <quicksilver> maybe a shorter (symbolic?) synonym for return would help
02:06:06 <Randroid> I can't argue the semantics.
02:06:32 <Randroid> It's the esthetics of not having monadic subexpressions that I mildly dislike.
02:07:09 <int-e> I like the idea of monadic subexpressions but it seems nontrivial to implement.
02:07:59 <Randroid> I'm not expert enough in Haskell to have the vaguest clue.
02:08:33 <int-e> so it's likely not worth the effort.
02:09:07 * Randroid decides to kill himself over monadic subexpressions. But first, a beer.
02:09:23 <int-e> there's also http://www.haskell.org/haskellwiki/Idiom_brackets which is a related idea
02:09:24 <lambdabot> Title: Idiom brackets - HaskellWiki
02:09:32 <Randroid> reading ...
02:10:00 <int-e> (Idiom == Applicative. The name changed from the first paper about the idea and its introduction to the standard libraries)
02:10:55 <Sizur> what's more wasteful, to save the money for a beer or to buy a beer before suicide?
02:10:57 <earthy> <*>, <$> and friends.
02:11:28 <int-e> suicide seems excessively wasteful to me.
02:11:50 <Randroid> Sizur: Hm. I already have the beer. And now that I've had a few sips, monadic subexpressions don't seem worth dying over.
02:11:51 <earthy> killing off a few braincells however... :P
02:13:11 <Sizur> int-e: wholeheartedly agreed
02:20:32 <quicksilver> int-e: another painful wart is the way they'd be dependent on the "nearest do"
02:20:37 <quicksilver> int-e: that seems quite odd
02:21:24 <quicksilver> int-e: "do" effectively becomes a kind of "binding site" for all subexpressions, like a kind of lambda for '<-'
02:22:19 <int-e> so  a = do a  would fail? that's ugly.
02:22:43 <quicksilver> yes
02:22:47 <int-e> it'd be more like  mdo  then
02:23:08 <quicksilver> if a is (foo (<- bar))
02:23:21 <quicksilver> then that bar links to the enclosing monad
02:23:28 <quicksilver> but this one : do (foo (<- bar))
02:23:32 <quicksilver> links to that monad right there
02:23:41 <int-e> ah.
02:23:56 <quicksilver> given that the two 'dos' might be totally different monads
02:24:00 <quicksilver> that could be quite weird
02:24:14 <int-e> do foo (do (<- a)) vs. do foo (<- a)
02:24:21 <quicksilver> (imagine you're inside a "local" in a reader monad, for example)
02:24:43 <int-e> ( join f = do (<- f) )
02:25:04 <Shurique> @pl \ a b c -> a:b:c
02:25:04 <lambdabot> (. (:)) . (.) . (:)
02:33:48 <taruti> Is there a debian package for HaskellDB 0.10 available somewhere?
02:35:15 <quicksilver> taruti: libghc6-haskelldb-dev
02:35:21 <quicksilver> taruti: is visible in my packages list
02:36:27 <taruti> hmm, at least in the sid machine I am on haskelldb is at version 0.9
02:36:38 <taruti> what repository is that from?
02:37:55 <quicksilver> oh, sorry
02:38:11 <quicksilver> I didn't realise the emphasis in your sentence was on the 'version' part
02:38:14 <quicksilver> :(
02:38:20 <quicksilver> shouldn't be too hard to build, though
02:38:53 <taruti> true, but it depends on the other db-packages...
02:40:49 <Sizur> Cale: nice job on the TMR logo!
03:02:46 <hpaste>  tuxplorer pasted "Getting a No instance for (MonadReader ([Char] -> IO ()) IO) error" at http://hpaste.org/2694
03:05:17 <xwx> tuxplorer: you are using the IO monad
03:05:33 <tuxplorer> xwx: yes..
03:05:56 <tuxplorer> oh! I should have used the Conn monad there?
03:06:09 <tuxplorer> funcfoobar :: String -> Conn() right?
03:07:08 <xwx> maybe, i'm not an expert in monads myself
03:08:22 <tuxplorer> xwx: if i change it to Conn() monad I get an error like     Kind error: `Conn' is applied to too many type arguments
03:09:27 <xwx> i don't think that Conn is a monad
03:09:50 <quicksilver> tuxplorer: Conn isn't a monad
03:09:55 <xwx> try removing the type signature of funcfoobar and see what type ghci tells you it is
03:10:04 <quicksilver> tuxplorer: Conn is just a simple datatype you've created
03:10:11 <scook0_> tuxplorer: what are you trying to do with "ask"?
03:10:39 <quicksilver> scook0_: he's trying to ask the 'conn'
03:10:44 <quicksilver> scook0_: which is stored in his ReaderT
03:10:58 <tuxplorer> scook0_: yes. I was trying to get a connection
03:11:12 <scook0_> ah, I see
03:11:16 <quicksilver> tuxplorer: the type for funcfoobar is, IMO, String -> Db ()
03:11:30 <quicksilver> tuxplorer: your custom Db monad is IO wrapped up in a ReaderT for conn
03:12:22 <quicksilver> tuxplorer: this will lead to your next problem which is that you are trying to "call" dbconn as if it was a function
03:12:25 <quicksilver> but one thing at a time
03:13:03 <Saizan> ?type ask
03:13:06 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
03:13:48 <hpaste>  tuxplorer pasted "Modifying the type to use Db() throws" at http://hpaste.org/2695
03:14:03 <Saizan> ask just retrieves the value stored in your monad, it has nothing to do with sockets in general
03:14:42 <scook0_> tuxplorer: by the way, you can add content to an existing paste
03:14:44 <quicksilver> tuxplorer: now your problem is that acceptConections and talk are in the IO monad
03:14:53 <scook0_> with the "annotate" link -- makes it easier to follow
03:14:54 <quicksilver> tuxplorer: but funcfoobar is in the Db monad
03:15:10 <tuxplorer> scook0_: I didn't know that.. Thanks..
03:15:22 <quicksilver> tuxplorer: you can "run" funcfoobar in the IO monad by using runReaderT
03:15:31 <quicksilver> and supplying it with the connection it needs
03:15:34 <quicksilver> :t runReaderT
03:15:36 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
03:15:52 <quicksilver> (runReaderT funcfoobar conn)
03:15:57 <quicksilver> instead of just funcfoobar
03:15:58 <hpaste>  (anonymous) annotated "Getting a No instance for (MonadReader ([Char] -> IO ()) IO) error" with "Changing funcfoobar's type to String -> Db() throws" at http://hpaste.org/2694#a1
03:16:06 <quicksilver> in the defintion of talk
03:19:23 <hpaste>  tuxplorer annotated "Getting a No instance for (MonadReader ([Char] -> IO ()) IO) error" with "Changing to "talk conn@(h,_,_) = hGetLine h >>= (runReaderT funcfoobar conn) >> talk conn" throws" at http://hpaste.org/2694#a2
03:20:07 <quicksilver> tuxplorer: ah
03:20:23 <quicksilver> tuxplorer: ok it's because funcfoobar takes a parameter
03:20:26 <Saizan> that's because funcfoobar :: String -> Db () and not simply :: DB ()
03:20:43 <quicksilver> tuxplorer: I'd stop using the >> notation and switch to proper do notation now
03:21:11 <tuxplorer> oh! quicksilver, but then I would have to thread around the conn param to all functions that use the DB
03:21:13 <tuxplorer> isn't it>
03:23:28 <quicksilver> tuxplorer: no
03:23:34 <quicksilver> tuxplorer: that's the point of the reader monad
03:23:39 <quicksilver> if you get it right :)
03:24:33 <Saizan> you just have to remain inside the Db monad, then you can use ask, usually i do something like do conn <- connect params; runReaderT mainLoop conn; close conn; (adding exception handling)
03:25:04 <quicksilver> tuxplorer: talk should be something like this IMO " line <- hGetLine h ; runReaderT (funcfoobar line) conn ; talk conn
03:27:14 <quicksilver> tuxplorer: you can then make that even prettier by moving all of 'talk' into the reader monad as well
03:27:22 <quicksilver> tuxplorer: but, one thing at a time
03:28:52 <tuxplorer> quicksilver: ok.. will try now..
03:33:07 <cognominal__> is there a function that returns the array of its argument? Well technically, this is a many function. But does this exist?
03:33:49 <ndm> cognominal__: no, thinks don't work like that at all
03:34:01 <roconnor> cognominal__: generally functions in haskell require a fixed number of arguments.
03:34:26 <doserj> http://okmij.org/ftp/Haskell/vararg-fn.lhs
03:34:32 <ndm> cognominal__: can you explain what you are trying to do at a higher level - you can probably do it some other way
03:34:36 <cognominal__> that's why I say this is many functions
03:34:43 <mudge> hey kfish
03:34:55 <roconnor> @type newArray
03:34:55 <mudge> what is primitive recursion?
03:34:57 <lambdabot> Not in scope: `newArray'
03:35:02 * ndm thinks that giving newbies Oleg is like giving depressed people rope
03:35:02 <roconnor> @hoogle newArray
03:35:02 <mudge> as compared to general recursion?
03:35:03 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
03:35:03 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
03:35:03 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
03:35:09 <roconnor> hmm
03:35:10 <cognominal__> ndm: so I can use foldr.
03:35:12 <roconnor> @hoogle array
03:35:13 <lambdabot> Array.array :: Ix a => (a, a) -> [(a, b)] -> Array a b
03:35:14 <lambdabot> Data.Array.array :: Ix i => (i, i) -> [(i, e)] -> Array i e
03:35:14 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
03:35:14 <dcoutts> cognominal__: if you don't mind writing the function argument as: [a, b, c, d] then yes, you can have a function that returns an array of its arguments
03:35:21 <mudge> what is primitive recursion?
03:35:32 <ndm> mudge: check wikipedia, it has a good article on it
03:36:02 <ndm> cognominal__: that takes a list, for example:
03:36:12 <cognominal__> dcoutts: the whole point is that I don't know in advance the number of argument
03:36:15 <ndm> > foldr min 1 [12,24,53]
03:36:17 <lambdabot>  1
03:36:23 <ndm> > foldr min 1 [-54,12,24,53]
03:36:24 <lambdabot>  -54
03:36:33 <dcoutts> cognominal__: excellent, use a list then.
03:36:41 <cognominal__> heu, I meant list
03:37:12 <cognominal__> I am a Perler, so the syntax makes me say array even if I think list
03:37:16 <ndm> in Haskell, array's aren't very common - lists are the way we do everything
03:37:49 <mudge> ndm: I don't undestand wikipedia's entry on primitive recursion
03:38:07 <ndm> mudge: its a restricted form of recursion - do you understand recursion?
03:38:07 <dcoutts> cognominal__: so everywhere you might want a function that accepts a variable number of args (of the same type) you can use a list
03:38:20 <mudge> ndm: of course i understand recursion
03:38:21 <cognominal__> ndm: ya that's a thing I don't dig well cuz acccessing is O(n) insteand of O(1)
03:38:50 <ndm> cognominal__: in practice, if you write the algorithms inductively, it doesn't matter
03:39:18 <ndm> mudge: the definition is relatively simple - there are 3 basic primitive recursive functions, and 2 ways to combine them up
03:39:56 <cognominal__> yea, I start to understand that with laziness and deforestation optimization the list are often immaterial implementation wise.
03:40:00 <quicksilver> cognominal__: if you write your function like this:
03:40:03 <dcoutts> cognominal__: in perl you might access arrays linearly using an increasing index, like i = 0..N
03:40:05 <Sizur> cognominal__: you stop thinking in terms of accessing a specific element in a list
03:40:20 <quicksilver> cognominal__: f [a,b,c,d] = ...
03:40:23 <mudge> ndm: yea?  is there anything on the web that describes this in detail in english?
03:40:29 <quicksilver> cognominal__: then a b c and d are O(1) names for the parameters
03:40:31 <mudge> ndm: if you know
03:40:46 <quicksilver> cognominal__: there is admittedly a one-off hit to traverse the list
03:40:57 <quicksilver> cognominal__: but it's not a hit each time you use a b c d
03:41:09 <ndm> mudge: its mathematics, if you plow through the wikipedia one thats about as good as it gets - but i know nothing better
03:41:12 <mudge> i found this: http://planetmath.org/encyclopedia/PrimitiveRecursive.html
03:41:13 <lambdabot> Title: PlanetMath: primitive recursive
03:41:22 <mudge> ndm: thanks
03:42:23 <ndm> mudge: http://www-users.cs.york.ac.uk/~ndm/downloads/paper-qualifying_dissertation-30_jun_2005.pdf - section 2.4.1
03:42:25 <lambdabot> http://tinyurl.com/33zgmx
03:42:43 <ndm> mudge: may not be much more readable, but it has a little bit about ackermanns and some haskell stuff - certainly not a definitive reference
03:43:20 <ndm> mudge: the wikipedia page is much better than the planetmath one
03:43:49 <mudge> what wikipedia page are you talking about?
03:44:03 <ndm> mudge: http://en.wikipedia.org/wiki/Primitive_recursion
03:46:44 <cognominal__> @src concatMap
03:46:45 <lambdabot> concatMap f = foldr ((++) . f) []
03:47:10 <ndm> @src-better concatMap
03:47:10 <lambdabot> Unknown command, try @list
03:47:17 <ndm> concatMap f = concat . map f
03:48:01 <quicksilver> concat . map $ f
03:48:16 <quicksilver> or (concat . map) f
03:48:21 <ndm> surely that isn't the same thing?
03:48:24 <quicksilver> ah
03:48:25 <quicksilver> bah
03:48:30 <quicksilver> you were right, I was wrong
03:48:32 * quicksilver apologises
03:50:42 <idnar> @pl concatMap f = concat . map f
03:50:42 <lambdabot> concatMap = (=<<)
03:50:53 <idnar> oh heh, too clever
03:51:08 <idnar> @pl concatMap f = concat' . map f
03:51:08 <lambdabot> concatMap = (concat' .) . map
03:51:49 <cognominal__> @help pl
03:51:50 <lambdabot> pointless <expr>. Play with pointfree code.
03:52:28 <xerox> ?src concat
03:52:28 <lambdabot> concat = foldr (++) []
03:52:33 <xerox> Then it makes sense :)
03:53:21 <quicksilver> only if you also understand the foldr/map fusion rule
03:53:40 <quicksilver> and, of course, if you trust foldr/map fusion then the original definition is not needed
03:53:45 <quicksilver> since it will get fused anyway
03:54:53 <mudge> what is a "computable function"?
03:55:15 <quicksilver> a function which can be computed by a computer program
03:55:21 <quicksilver> or, if you like, methodical algorithm
03:56:24 <mudge> thanks quicksilver
03:56:58 <quicksilver> there is more than one way to express that precisely
03:57:03 <quicksilver> I don't remember which are correct, even
03:57:33 <quicksilver> I think it's "if I ask you the question 'does f(x) = y?' then you can decide in finite time the answer Yes or No"
03:58:00 <quicksilver> which is not obviously the same thing as actually calculating y from x
04:12:33 <xwx> what do you guys think about this? http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
04:12:36 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
04:16:14 <quicksilver> xwx: it's nice stuff, I've thought about that before
04:17:07 <xwx> quicksilver: so should i use Data.Derive to automate it?
04:17:32 <quicksilver> Ah, you're twanvl logging in through some evil java IRC interface?
04:17:36 <KatieHuber> shiny, this is just the kind of thing I've been dealing with in the last couple of days :|
04:17:38 <iguana_> where is the advantage to normal record syntax?
04:17:40 <quicksilver> I assumed you weren't him :)
04:17:41 <earthy> hm. this is schweet
04:17:55 <quicksilver> iguana_: composability and neater update syntax
04:17:58 <earthy> exactly what I was looking for
04:18:19 <earthy> still doesn't allow for extensible records though
04:18:24 <quicksilver> foo { bar = (bar foo) + 1 }
04:18:25 <earthy> or resolve the namespace clashes
04:18:26 <quicksilver> is not very pretty
04:18:51 <quicksilver> xwx: that would be an interesting project
04:18:55 <EvilTerran> (update bar (+1) foo) under this, right?
04:19:14 <iguana_> quicksilver: you're right
04:19:17 <quicksilver> yeah, update bar (+1) would have type Foo -> Foo
04:19:28 <quicksilver> so update bar (+1) foo to apply toa  particular foo
04:19:37 <quicksilver> but quite often I find it's the Foo -> Foo that I actually want
04:19:46 * earthy nods
04:19:54 <quicksilver> and I have to write (\foo -> foo { bar = (bar foo) + 1 } )
04:19:58 <quicksilver> which is even uglier :)
04:20:22 <quicksilver> xwx: it's also relevent to my monadic tunelling thoughts
04:20:35 <quicksilver> xwx: these reference comositions are exactly what you need to run one State monad inside another
04:22:05 <quicksilver> xwx: interesting the way you use a plain 'data' instead of an MPTC
04:22:19 <quicksilver> xwx: I'd have fallen straight into the MPTC trap there
04:22:32 <xwx> what is MPTC?
04:22:38 <quicksilver> multi-parameter type class
04:48:48 <hpaste>  Mitar pasted "(no title)" at http://hpaste.org/2696
04:48:59 <Mitar> i just pasted an error message i get
04:49:11 <Mitar> can anybody tell my why? is documentation for Parsec wrong?
04:51:19 <Lemmih> What does the documentation say the type of 'reserved' is?
04:51:37 <EvilTerran> and what type's "lexer"?
04:52:20 <Lemmih> EvilTerran: TokenParser (), would be my guess.
04:52:26 <scook0> hmm, the documentation seems to be inconsistent, at least
04:52:39 <EvilTerran> that would make sense
04:52:41 <scook0> " , reserved    :: String -> CharParser st ()"
04:52:46 <scook0> vs "reserved  :: String -> CharParser st String"
04:53:50 <Lemmih> reserved :: (String -> CharParser st ())   ->      http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Token.html
04:53:52 <lambdabot> http://tinyurl.com/3748y7
04:53:55 <Lemmih> Seems OK to me.
04:54:26 <Mitar> ok, so it is documentation here wrong:
04:54:26 <Mitar> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#reserved
04:55:00 <scook0> yeah, #reserved is wrong for some reason
04:55:36 <Lemmih> Perhaps because that documentation is 6 years old...
04:56:35 <scook0> if you actually need the string, it should be easy enough to just use \s -> reserved s >> (return s)
04:56:44 <Mitar> yes ..
04:56:55 <Mitar> i know, but it was just a little bit strange
04:56:59 <scook0> Lemmih: the point is more that the documentation is inconsistent with itself
04:57:06 <Mitar> i did not know who is wrong, me or compiler :-)
04:57:14 <Lemmih> scook0: Oh?
04:57:16 <quicksilver> runReaderT (reserved >> return) s ?
04:57:17 <quicksilver> ;)
04:57:39 <scook0> @pl \s -> reserved s >> return s
04:57:39 <lambdabot> liftM2 (>>) reserved return
04:57:44 <Lemmih> scook0: How so?
04:59:30 <scook0> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#ParsecToken
04:59:32 <lambdabot> http://tinyurl.com/2p5p89
04:59:54 <scook0> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#reserved
05:00:39 <scook0> two different types are given for reserved
05:00:42 <MyCatSchemes> Good afternoon #haskell.
05:00:59 <scook0> howdy
05:09:40 <mudge> how do you say woa
05:09:50 <mudge> how do you spell it right,  the slang spelling
05:09:57 <mudge> whoa?
05:13:13 <EvilTerran> I say "whoa". "woah" works, too
05:13:30 <Saizan> quicksilver: i've used the MPTC approach to combine State monads and it works quite well, |with :: (MonadState o m, MonadState i m', SubPart i o) => m' i -> m o|, even if it doesn't scale to more than one field of the same type
05:15:21 <roconnor> googling ``neo whoa'' returns 425,000 hits
05:15:22 <EvilTerran> would it be possible to class Functor r => Ref r? seeing as some want to make (.) = fmap, there might be a conflict there...
05:15:36 <roconnor> googling ``neo woah'' returns 124,000 hits
05:15:41 <quicksilver> Saizan: did you read twanvl's post?
05:15:51 <quicksilver> Saizan: seems potentially slightly simpler
05:16:14 <Saizan> quicksilver: yes, but you need to name the field
05:16:39 <quicksilver> EvilTerran: don't think so, Functors typically contain many 'rs' and Refs only contain one
05:16:50 <quicksilver> EvilTerran: you could do Ref r => Functor r, though
05:17:02 <Saizan> well, for one they have a different kind
05:17:09 <quicksilver> EvilTerran: (speaking loosely, you need to align the kinds)
05:17:11 <doserj> I think class Arrow a => Ref a would make sense
05:18:27 <EvilTerran> ?type fmap
05:18:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:18:54 <EvilTerran> hm... i was thinking "instance Functor FRef where fmap = compose" might work nicely with renaming fmap to (.), altho it would be a bit unintuitive conceptually
05:19:04 * EvilTerran is just thinking out loud
05:19:19 <roconnor> ugh, programming in haskell is just as hard as programming in other languages, but you end up with less code to show for all your hard work.
05:20:30 <allbery_b> measuring productivity by LoC is stupid
05:20:56 <allbery_b> I'd be tempted to measure it by lines of comments, except that's easily abused...
05:22:21 <Saizan> EvilTerran: that won't work because the first argument of fmap is a function instead of being parametric on the "functor" like in Ref
05:22:40 <uacingtyn> coi pupeno
05:22:57 <scook0> actually, LoC reminds me of score in NetHack
05:23:08 <scook0> if you haven't finished, it shows how far you've progressed
05:23:20 <scook0> if you *have* finished, it shows how bad you are ;)
05:24:11 <quicksilver> yes, that's a nice way of looking at it
05:24:24 <quicksilver> should we require that all programmers we hire have ascended at least once?
05:25:07 <ricky_clarkson> allbery_b: If you measure my code by lines of comments you'll sack me.
05:26:29 <nornagon> What's the list-fu for "permute this list"?
05:26:54 <nornagon> I'd like a list of all possible order permutations of the input list
05:27:00 <allbery_b> ricky_clarkson: I'd also sack myself, sadly.  :)
05:28:40 <scook0> googling found this:
05:28:47 <scook0> > perms [] = [[]]
05:28:47 <lambdabot>  Parse error
05:28:51 <scook0> perms [] = [[]]
05:28:53 <scook0> perms xs = [ x : ps | x <- xs , ps <- perms ( xs\\[x]) ]
05:29:02 <nornagon> aha :)
05:29:13 <ndm> > sequence "neil"
05:29:14 <lambdabot>  Couldn't match expected type `m a' against inferred type `Char'
05:29:19 <ndm> :t sequence
05:29:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:29:34 <nornagon> > sequence $ repeat "neil"
05:29:36 <lambdabot>  Exception: <<loop>>
05:29:56 <Saizan> > replicateM 4 "neil" -- not quite
05:29:57 <nornagon> > sequence $ replicate 4 "neil"
05:29:58 <lambdabot>  ["nnnn","nnne","nnni","nnnl","nnen","nnee","nnei","nnel","nnin","nnie","nnii...
05:29:59 <lambdabot>  ["nnnn","nnne","nnni","nnnl","nnen","nnee","nnei","nnel","nnin","nnie","nnii...
05:30:07 <nornagon> yeah, not quite what i'm after
05:30:29 <xerox> > let permutations [] = [[]]; permutations xs = [ x:ys | x <- xs, ys <- permutations (delete x xs)] in permutations [1,2,3]
05:30:30 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
05:31:32 <nornagon> yeah, i found that one too
05:31:59 <nornagon> i thought there was one using Control.Monad stuff, but i think replicateM is as close as it got
05:33:14 <ricky_clarkson> allbery_b: It's a poor measure.  Comments are a sign of bad code.
05:33:47 <allbery_b> tell me that when you've come back to your code after a 6-month break and say "what the f**k was I *thinking*?!"
05:34:02 <allbery_b> ...which happens to every programmer, even the experts :)
05:34:38 <nornagon> heh
05:34:48 <MyCatSchemes> allbery_b: I've heard it said that if you don't think that, though, you're in deep shit.
05:34:53 <nornagon> still, you're much better off writing code that's obvious in function
05:35:06 <MyCatSchemes> allbery_b: apparently, it's a *good* sign. Specifically, it shows that you're continuing to learn. =)
05:35:24 <allbery_b> nornagon: consider the ditinction between strategy and tactics
05:35:30 <nornagon> which is why functional languages are so nice; it's easier to write code in discrete, generalised chunks than in one huge blob
05:35:33 <allbery_b> clear code is tactics.  documentation should be for strategy
05:35:49 <nornagon> what's the difference between strategy and tactics?
05:36:07 <scook0> strategy is higher-level
05:36:09 <allbery_b> the difference between thhe forest and the trees
05:36:12 <MyCatSchemes> nornagon: strategy is high-level.
05:36:14 <allbery_b> overall intent vs. implementation
05:36:25 <nornagon> i see
05:36:28 <MyCatSchemes> nornagon: strategy: advance through Belgium to avoid having to battle through the Maginot Line.
05:36:42 <nornagon> i was under the impression that tactics could apply at various levels
05:36:54 <nornagon> you could have situational tactics and high-level tactics
05:36:54 <allbery_b> they can
05:36:56 <scook0> nornagon: it's relative to context
05:36:59 <MyCatSchemes> nornagon: tactics: sneak around the back of that tank, shoot the men standing next to it then jump on top and drop a grenade down the hatch.
05:37:05 <allbery_b> but there's still the intent vs. implemmentation distinction
05:37:20 <allbery_b> what to do vs. how to do it
05:37:38 <nornagon> mhm
05:37:46 <ricky_clarkson> allbery_b: I haven't come back to code and not understood it since I was 13.
05:37:59 <nornagon> i guess that's important for finding bugs, but then-- your tests should be your documentation :)
05:38:02 <ricky_clarkson> I have, however, wondered why I was using such retarded techniques.
05:38:09 <nornagon> ricky_clarkson: me too :)
05:38:19 <ricky_clarkson> nornagon: s/tests/types/ you're in #haskell. ;)
05:38:29 <nornagon> ricky_clarkson: quickcheck!
05:38:40 <nornagon> there are some things that are difficult to express in the type system
05:38:45 <nornagon> unless you are oleg
05:38:49 <allbery_b> you should not have to document how you are doing something.  you should clearly document the high level intent, not in terms of the implementation but in terms of the task
05:38:53 <quicksilver> nornagon: it's not *obvious* to me that better abstraction is in one-to-one correspondance with functional languages
05:38:57 <ricky_clarkson> Yes, which is just that the type system isn't perfect yet.
05:39:09 <ricky_clarkson> :t last
05:39:13 <scook0> allbery_b: though it can be useful to document *why* you chose that implementation
05:39:14 <quicksilver> nornagon: however, it is certainly true that, in practice, the functional languages we have, have better abstraction power, and haskell is one of the best
05:39:17 <lambdabot> forall a. [a] -> a
05:39:18 <allbery_b> true
05:39:21 <scook0> and why the more obvious one doesn't work, for example
05:39:22 <quicksilver> nornagon: and that is a powerful advantage to coding with it
05:39:22 <ricky_clarkson> :t first
05:39:24 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
05:39:42 <ricky_clarkson> Wow, I thought first would be [a] -> a
05:39:46 <nornagon> quicksilver: personally, i find it much easier to write segmented code in haskell than big-blob code
05:39:52 <nornagon> ricky_clarkson: haha
05:39:54 <quicksilver> nornagon: yes, I agree completely
05:40:05 <nornagon> @instances Arrow
05:40:06 <lambdabot> (->), Kleisli m
05:40:09 <scook0> :t fst
05:40:10 <lambdabot> forall a b. (a, b) -> a
05:40:22 <scook0> :t head
05:40:24 <lambdabot> forall a. [a] -> a
05:40:27 <ricky_clarkson> scook0: Ah. ;)
05:40:49 <ricky_clarkson> As long as :t head and :t last are the same the type system isn't good enough. ;)
05:41:07 <nornagon> > last []
05:41:12 <lambdabot>  Exception: Prelude.last: empty list
05:41:17 <scook0> I find myself needing (id &&& f) more than first/second
05:41:19 <ndm> ricky_clarkson: if the type system perfectly captures the behaviour of all functions, why have a value system?
05:41:41 <nornagon> functions with difficult types are useful
05:42:06 <quicksilver> scook0: morally that's "fmap"
05:42:07 <nornagon> let's just reduce this problem to GÃ¶del's incompleteness theorem and move on ;P
05:42:22 <quicksilver> scook0: it's just that we don't have a good way to encode that in our type system
05:43:27 <ricky_clarkson> ndm: Because types represent sets, not usually individual values.
05:43:42 <scook0> I guess it's also second f . dup, where dup = (id &&& id)
05:43:48 <ndm> ricky_clarkson: but you want to make the type system to the point where any value in the set is just fine?
05:44:05 <ricky_clarkson> I don't understand that sentence.
05:44:57 <quicksilver> :t (id &&& id)
05:44:58 <lambdabot> forall a. a -> (a, a)
05:45:03 <ToRA> :t (join (,))
05:45:05 <lambdabot> forall a. a -> (a, a)
05:45:15 <quicksilver> scook0: ah, sorry I was mixing up *** and &&& again
05:45:27 <scook0> actually, I wish it were possible to use "naked" Kleisli arrows
05:45:30 <quicksilver> scook0: actually (id &&& f) is also known as (,) `ap` f
05:46:26 <scook0> quicksilver: ((->)r) hurts my poor brain
05:46:26 <ndm> ricky_clarkson: i'm just asking what the value level specifies that the type level doesn't
05:46:27 <ndm> if the answer is nothing, then you can remove the value level
05:46:27 <quicksilver> I'm not sure why you would expect head and last to have different types
05:46:31 <quicksilver> I'm not sure what kind of type system that would be
05:46:43 <quicksilver> they both error out on empty lists and give a result on any non-empty list
05:46:47 <ndm> dependantly typed system
05:46:50 <ndm> i.e. Epigram
05:46:52 <ndm> Cayenne
05:47:00 <quicksilver> even in epigram they have the same type
05:47:07 <quicksilver> List (length at least 1) a -> a
05:47:42 <ndm> in Epigram they could have a more precise type
05:48:06 <nornagon> How do you get a more precise type?
05:48:59 <quicksilver> ndm: how? what type?
05:49:10 <ndm> quicksilver: who knows, but i'm sure you could
05:49:12 <quicksilver> ;)
05:49:18 <nornagon> heh
05:49:19 <ndm> perhaps by introducing ListWithEnd
05:49:25 <quicksilver> I don't think you can get a better type than that in any obvious way
05:49:37 <quicksilver> unless you have types like ListWhoseFirstItemIs
05:49:38 <nornagon> ndm: last produces a value on lists without ends
05:49:48 <nornagon> it just takes an infinite amount of time to do it
05:49:49 <nornagon> ;)
05:49:55 <quicksilver> and, correspondingly 'ItemWhichCanOnlyBe'
05:50:02 <quicksilver> oh, I wasn't thinking about infinite lists
05:50:07 <quicksilver> well infinite lists aren't an epigram data type :)
05:50:12 <quicksilver> epigram doesn't have codata
05:50:29 <ricky_clarkson> Suppose you stick an even number and an odd number into a list, and ask for the last of that list.  It is provably odd, but the type system can't tell you that.
05:50:50 <quicksilver> ricky_clarkson: but that's not the general type of last, is it?
05:51:02 <quicksilver> ricky_clarkson: you don't want last to have the type ListEndingWithOdd -> Odd
05:51:09 <quicksilver> ricky_clarkson: because you want to use last on all lists
05:51:23 <nornagon> i can't imagine such a system being useful or elegant
05:51:25 <doserj> well, if reverse has type [a] -> [a], then obviously head and last have the same type
05:51:47 <doserj> and i cannot think of another type for reverse :)
05:52:23 <nornagon> Reversable b => b -> b? >.>
05:52:52 <ibid> preserves type
05:53:13 <ibid> ListEndingWithOdd cannot be Reversable with that
05:53:39 <nornagon> unless it also begins with an odd number
05:53:43 <ibid> Mirror a b => a -> b might work :)
05:53:53 <ibid> nornagon: that would be ListStartingAndEndingWithOdd
05:54:05 <nornagon> i see
05:54:50 <ricky_clarkson> quicksilver: You want last to have the return type of the last element in the last.
05:54:54 <nornagon> ListWithSecondFourthFifthSeventhAndTwelfthItemsBeingDivisibleByAPowerOf72?
05:55:18 <quicksilver> ricky_clarkson: but all elements in a list have the same type
05:55:25 <quicksilver> ricky_clarkson: that's what list means, in haskell :)
05:55:39 <quicksilver> ricky_clarkson: if we're not talking about lists any more, well that's something else
05:56:00 <ricky_clarkson> Er, the last in the list, not the last in the last. ;)
05:57:00 <gip_> Hi! I have a value 0..15 and I'd like to convert it to a hex string ('0'..'F').
05:57:25 <quicksilver> :t showIntAtBase
05:57:27 <gip_> Hi! I have a value 0..15 and I'd like to convert it to a hex string ('0'..'F').
05:57:30 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
05:57:44 <ricky_clarkson> quicksilver: Suppose you had a list, and wanted to map (1/) across it.  A type system could tell you if any elements in it are zero, right?
05:57:53 <ricky_clarkson> ..i.e., a division by zero would occur.
05:58:06 <ricky_clarkson> s/are/are possibly/
05:58:11 <kpreid> quicksilver: but that requires you to supply the digit-to-char!
05:58:13 <quicksilver> > showIntAtBase 16 (chr.(+48)) 13
05:58:15 <lambdabot>  <[Char] -> [Char]>
05:58:19 <quicksilver> > showIntAtBase 16 (chr.(+48)) 13 ""
05:58:20 <lambdabot>  "="
05:59:12 <kpreid> I can't easily check the docs just now, but if there *isn't* one, ("0123456789ABCDEF" !!) would do
05:59:12 <ibid> gip_: the only way i know to do that (excluding existing library functions) is to look the digit up
05:59:14 <MyCatSchemes> ricky_clarkson: not really, unless you had a numerical type which was guaranteed to exclude zero.
05:59:15 <gip> Hi! I have a value 0..15 and I'd like to convert it to a hex string ('0'..'F').
05:59:34 <ibid> gag
05:59:35 * quicksilver shrugs
05:59:42 <kpreid> I wonder if his client was not displaying text.
05:59:58 <gip> Hi! I have a value 0..15 and I'd like to convert it to a hex string ('0'..'F').
06:00:06 <ibid> gip: please don't repeat yourself
06:00:07 <kpreid> gip: are you going to listen to the answers this time?
06:00:18 <gip> IRC dead?
06:00:25 <ibid> gip: works here
06:00:28 <Sizur> gip: no
06:00:28 <quicksilver> no, we can hear you fine
06:00:43 <scook0> @hoogle Char -> Int
06:00:44 <lambdabot> Char.digitToInt :: Char -> Int
06:00:44 <lambdabot> Char.ord :: Char -> Int
06:00:51 <quicksilver> there is showHex actually ;)
06:00:57 <scook0> oh, wrong way round
06:00:59 <quicksilver> > showHex 266
06:01:00 <lambdabot>  <[Char] -> [Char]>
06:01:04 <quicksilver> > showHex 266 ""
06:01:06 <lambdabot>  "10a"
06:01:14 <ibid> i'm sure that com
06:01:17 <ricky_clarkson> MyCatSchemes: Yes, but types don't have to be named specially, they can be inferred.
06:01:26 <ibid> copes with the requirement that the number is at most 15 :
06:01:28 <ibid> )
06:01:31 <scook0> :t Int -> Char
06:01:33 <lambdabot> <command line>:
06:01:33 <lambdabot>     Could not find module `L':
06:01:38 <scook0> @hoogle Int -> Char
06:01:39 <lambdabot> Char.chr :: Int -> Char
06:01:39 <lambdabot> Char.intToDigit :: Int -> Char
06:01:39 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
06:01:45 <ricky_clarkson> MyCatSchemes: map (\x -> 1/(x-2)) someList would require a list of values that aren't 2.
06:01:59 <scook0> > intToDigit 14
06:02:00 <lambdabot>  'e'
06:02:00 <quicksilver> ricky_clarkson: that suggest things no longer have a single type though
06:02:06 <MyCatSchemes> ricky_clarkson: your type checker won't do that.
06:02:12 <ricky_clarkson> MyCatSchemes: Why?
06:02:28 <quicksilver> ricky_clarkson: because it's equivalent to solving equations which is not possible in general :)
06:02:42 <quicksilver> ricky_clarkson: and even some cases which are possible are very hard (Slow)
06:02:44 <roconnor> > map toUpper (showHex 266)
06:02:45 <scook0> you could use an abstract newtype to "brand" values having desired properties
06:02:45 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `ShowS'
06:02:50 <roconnor> > map toUpper (showHex 266 [])
06:02:52 <lambdabot>  "10A"
06:02:53 <scook0> but you'd still have to prove the branding code correct
06:03:05 <MyCatSchemes> ricky_clarkson: because that's outside the domain of what you can do with simple types. That requires a clever static analysis program which knows about arithmetic.
06:03:22 <ricky_clarkson> MyCatSchemes: I don't see a problem with that.
06:03:41 <ricky_clarkson> Is Coq capable of things like this?
06:03:52 <ibid> ricky_clarkson: we usually like our typecheckers to pass judgment for all programs :)
06:04:59 <quicksilver> Coq is capable of anything which can be formalised in a formal language and proved with formal rules
06:05:13 <quicksilver> that doesn't necessarily make it a good place to write type checkers :)
06:05:16 <ibid> but only if it's a theorem, right :)
06:05:28 <ricky_clarkson> Coq can generate code.
06:05:37 <MyCatSchemes> ricky_clarkson: uh, well, it does give you an excuse to run screaming into open fields of lots and lots and LOTS of ridiculously difficult to write programs which aren't guaranteed to terminate.
06:06:07 <ricky_clarkson> MyCatSchemes: You could prove termination.
06:06:33 <ibid> ricky_clarkson: you can't, not if it is supposed to handle arithmetic
06:06:55 <MyCatSchemes> ricky_clarkson: ...firstly: before the Sun burns out or afterwards, and secondly, do *you* want to do it?
06:07:22 <quicksilver> ricky_clarkson: you can only prove termination for a rather small class of programs
06:07:44 <roconnor> small!?
06:07:52 <ibid> not very small, actually
06:07:54 <ricky_clarkson> quicksilver: Those without unbounded recursion.
06:07:58 <ibid> but there are useful programs outside that set
06:08:10 <MyCatSchemes> ricky_clarkson: because I sure as Hell don't. Proving absolutely anything nontrivial about arbitrary problems is extremely difficult at best, mathematically impossible at worst (paging doctor A. Turing...) and strong-AI-complete in many cases anyway.
06:08:20 <roconnor> ibid: the only useful program than I can think of is a coq interpreter.
06:08:21 <quicksilver> well the size of infinite sets is a bit fiddly
06:08:22 <ricky_clarkson> ibid: Why can't you prove termination of programs that include arithmetic?
06:09:06 <doserj> ricky_clarkson: you can sometimes, but not always
06:09:08 <ibid> ricky_clarkson: no, i meant you can't prove termination of a program that needs to prove statements about arithmetic (such as a typechecker that detects DBZ violations)
06:09:13 <MyCatSchemes> ricky_clarkson: halting problem?
06:09:33 <roconnor> @what DBZ
06:09:34 <lambdabot> I know nothing about dbz.
06:09:39 <quicksilver> divide by zero
06:09:40 <ibid> roconnor: divide by zero
06:09:56 <roconnor> there are type checkers that can detect DBZ?
06:09:57 <ricky_clarkson> MyCatSchemes: The halting problem applies to a Turing machine.  You can write programs that target something more restrictive than a Turing machine.
06:10:09 <ibid> roconnor: not decidable ones :)
06:10:33 * roconnor thinks a type checker ought to be decidable to be called a type checker.
06:10:49 <ibid> roconnor: the GHC and C++ folks seem to disagree :)
06:10:49 <ricky_clarkson> ibid: So if your type checker goes into an infinite loop (or appears to), kill it and write your code in a different way.
06:10:52 <Vq^> how can i parse something like "+2 + +3" ?
06:11:02 <quicksilver> roconnor: let us say "you can imagine a type system which detects DBZ, and then you can discuss if a type checker exists for that system"
06:11:16 * Vq^ writes a parsec parser for heidenhain
06:11:20 <roconnor> ibid: BTW, coq tactics can have unbounded recursion.
06:11:32 <ibid> ricky_clarkson: as i said earlier, we generally like our typecheckers to be able to pass judgment on all syntactically valid programs :)
06:11:52 <ibid> roconnor: i'm not surprised. what's your point?
06:12:01 <MyCatSchemes> Vq^: set your parser generator (please use a parser generator rather than writing one by hand, it's ever so much easier) to reduce "+ +" to "+"?
06:12:06 <roconnor> So you can write a DBZ type checker tactic that if halts, halts with a proof that your particular program is DBZ type safe.
06:12:25 <roconnor> similar to what an undecidable typechecker does
06:12:30 <ibid> roconnor: sure you can do that. you can do that without coq as well
06:12:36 <ibid> roconnor: but it doesn't make it decidable :)
06:12:40 <ibid> but i need to run :)
06:12:54 <ricky_clarkson> ibid: I don't think that's a serious problem.  If the type checker fails to terminate in a certain time limit, you can reject the code.
06:13:30 <Vq^> MyCatSchemes: thanks
06:13:38 <ricky_clarkson> Sometimes you'll reject valid code doing that, but then you'll just need to alter the type checker or the code.
06:14:28 <roconnor> quicksilver: do you mean coq can only prove a small set of programs terminates from the entire class of programs, or that coq can prove a small set of programs terminates from the class of programs that terminate?
06:14:29 <scook0> non-terminating typecheckers aren't really any worse than ones with exponential worst-cases
06:14:31 <MyCatSchemes> ricky_clarkson: that sounds like a major pain in the arse.
06:15:04 <quicksilver> roconnor: no, I meant that the class of 'provably terminating' programs is small compared to the class of 'all programs'
06:15:07 <ibid> ricky_clarkson: feel free to write one :)
06:15:11 <ibid> --> bbl
06:15:25 <ricky_clarkson> ibid: I'll investigate Coq properly first.
06:15:27 <quicksilver> roconnor: irrespective of the proof method usedd
06:15:37 <roconnor> quicksilver: ah, okay.  I suppose that isn't terribly unreasonable.
06:15:57 <roconnor> (modulo the fact the statement doesn't actually make sense ;)
06:16:30 <quicksilver> roconnor: of course, what I was actually thinking was probably "given a sensible inductive (syntactic) restricting on programs which makes them definitely provably total", the class of programs that restricts you too is rather small
06:16:55 <roconnor> quicksilver: too small for what purposes?
06:17:10 <quicksilver> roconnor: too small to include lots of nice programs we would like to analyse
06:17:12 <ricky_clarkson> quicksilver: A small infinity.
06:17:26 <quicksilver> roconnor: programs which we actually write in practice, for example
06:17:45 <roconnor> quicksilver: Coq is more than powerfull enough to write programs that we use in practice
06:17:46 <ricky_clarkson> What's the smallest program that cannot be written so that it is provably total?
06:17:48 <quicksilver> roconnor: including, for example, the program I'm supposedly writing to check termination, for one :)
06:18:02 <quicksilver> roconnor: yes, it certainly is
06:18:07 <roconnor> quicksilver: you're being difficult ;)
06:18:14 <quicksilver> roconnor: but those will not be provably terminating
06:18:31 <xerox> ricky_clarkson: maybe it is fix. Or fix something.
06:18:56 <roconnor> xerox: how about undefined
06:19:03 <xerox> Good one.
06:19:07 <encryptio> > let 2 + 2 = 5 in 2 + 2
06:19:08 <lambdabot>  5
06:19:15 <encryptio> cool =D
06:19:46 <roconnor> quicksilver: ah, you are saying you want to analyse programs that do not terminate.
06:20:02 <roconnor> quicksilver: presumably you are aware that Coq has coinductive types too.
06:20:32 <roconnor> and that general recursive programs can be embedded into coq via the partiality monad.
06:20:45 <roconnor> and hence you can reason about general recursion.
06:21:00 <roconnor> Coq ~= Math
06:21:54 <therp> I should definitely look at Coq
06:28:01 <quicksilver> roconnor: yes, I am
06:28:14 <quicksilver> roconnor: but there remain big classes of programs which you cannot prove terminating
06:28:37 <quicksilver> roconnor: even with the 'start from both ends' coinductive stuff
06:30:10 * matthew_- wonders if we're going to reach a "My infinite-sized set of programs is bigger than your infinite-sized set of programs..."
06:30:39 <Sizur> lol
06:33:58 <nornagon> surely the set of all terminating programs is of equal size to the set of all non-terminating programs
06:34:25 <nornagon> assuming you can insert some kind of nop into both
06:34:57 <EvilTerran> well, both sets are countable, i guess
06:35:08 <matthew_-> might take a while though...
06:35:30 <b_jonas> yes, but don't hope to have an explicitly computable bijection between the two kind of programs :)
06:35:37 <Sizur> we need to start counting now, later we'll have lower chances of finishing
06:35:37 <MyCatSchemes> nornagon: |N| in both cases. :)
06:35:52 <matthew_-> Sizur: I started last week
06:35:56 <EvilTerran> it wouldn't be computable, b_jonas, but we can make a nice non-constructive proof ;]
06:36:03 <matthew_-> Sizur: I'm nearly up to 10!
06:36:36 <nornagon> matthew_-: you're almost done!
06:37:13 <CosmicRay> This code snippet works under ghc but hugs tells me "inferred type is not general enough".  Could that be because the "t" is not available in the scope of the function definition, and if so, how would I fix it?
06:37:15 <CosmicRay> apffi :: forall t. Test.QuickCheck.Testable t => String -> (forall f i. (Eq i, Eq f, TestLL f i, LL.ListLike f i) => (f -> f -> i -> t)) -> Test
06:37:15 <CosmicRay> apffi msg x = TestLabel msg $ TestList $
06:37:15 <CosmicRay>     [t "[Int]" (x::[Int] -> [Int] -> Int -> t),
06:37:15 <CosmicRay>      t "MyList Int" (x::MyList Int -> MyList Int -> Int -> t),
06:37:20 <Sizur> 4 color theorem applies to 2 dimensions. i wonder what about 3
06:37:44 <nornagon> Sizur: i am pretty sure you need more
06:37:45 <EvilTerran> if you express your programs as inputs to a universal turing machine, it's possible to enumerate all programs, so the set of all programs is countable
06:37:55 <nornagon> wait, no i'm not
06:38:12 <EvilTerran> i think constructing an infinite set of halting programs and constructing an infinite set of non-halting programs are both fairly trivial
06:38:17 <Sizur> nornagon: i'm positive you'll need more than 4 colors for 3d, but how much more
06:38:39 <mrd> CosmicRay: i don't see a definition for 't' the term variable
06:39:02 <mrd> and if hugs doesn't have lexical type variable scope then you may be able to workaround that with creative use of "asTypeOf"
06:39:05 <EvilTerran> so you've got two infinities that both have to fit inside a countable infinity; thus both sets're countably infinite, and so a bijection exists ^^
06:39:14 <CosmicRay> what do you mean by "term variable"?  It's up at the top (forall t. Test.QuickCheck.Testable t =>)...
06:39:26 <mrd> CosmicRay: well you invoke t as a function
06:39:33 <mrd> where is that coming from?
06:39:35 <roconnor> EvilTerran: you mean doesn't not exist :)
06:39:41 <mrd> I guess this is just a snippet
06:39:48 <CosmicRay> it is the return value of a function that is being passed to apffi as an argument
06:40:05 <EvilTerran> roconnor, well, i guess. it exists, we just don't know what it is. as i said, nice non-constructive proof =]
06:40:08 <CosmicRay> the remaining lines are similar.  it is building up a list of test cases of the same function applied to different types.
06:40:15 <CosmicRay> the function is "x" in the code
06:40:30 <b_jonas> Sizur: no finite number is enough
06:40:35 <mrd> msg :: f -> f -> i -> t?
06:40:39 <b_jonas> in fact, you can embed any graph to 3 dimensions
06:40:42 <roconnor> exists in a philosphical sense maybe.
06:40:55 <b_jonas> I can draft you a proof if you don't want to think about it
06:41:08 <CosmicRay> no, msg is String... x is f -> f -> i -> t
06:41:26 * EvilTerran is perfectly happy with that sort of proof. don't blame me if you're a constructivist.
06:41:27 <mrd> wait, does hugs even have higher rank types?
06:41:32 <CosmicRay> yes.
06:41:48 <CosmicRay> if I just use Bool instead of (Testable t), this function works in hugs.
06:41:50 <roconnor> non constructive math is dumb.
06:42:14 <Sizur> b_jonas: why is 2d an exception
06:42:56 <b_jonas> Sizur: I think it's because the edges of the graphs are 1 dimensional
06:42:58 <EvilTerran> Sizur, 1d is different again, but it's not interesting.
06:43:15 <roconnor> you can colour all 1 d graphs with 2 colours?
06:43:23 <EvilTerran> i think so, yeah.
06:43:29 <b_jonas> and it's difficult for two edges to accidentally meet in a 3-space but easy in a 2-plane
06:43:30 * EvilTerran thinks... yep.
06:44:16 <quicksilver> are we colouring volumes in 3-space? or faces in 3-space?
06:44:37 <Sizur> quicksilver: i'm thinking about volumes.
06:44:43 <b_jonas> the vertices I think
06:44:49 <b_jonas> but you can use volumes as well
06:44:58 <EvilTerran> colouring the nodes of graphs with non-intersecting edges
06:45:03 <Sizur> faces can be colored with a generalization of the 4 color rule
06:45:19 <b_jonas> volumes in a way that they are disjoint and two count as neighbouring iff they have a shared face
06:45:25 <quicksilver> vertices are just the dual of volumes
06:45:30 <quicksilver> unless I"m being stupid
06:45:39 <quicksilver> so colouring vertices is colouring the volumes in the dual
06:45:41 <b_jonas> I think so, with  a proper definition
06:45:43 <quicksilver> i.e. same thing
06:45:48 <EvilTerran> there's a bijection between the two problems, yes
06:45:56 <EvilTerran> *problem sets
06:46:15 <b_jonas> but it's not the kind of dualty like in the plane
06:46:28 <Sizur> b_jonas: i think the number will be finite if you limit volumes to be convex structures
06:46:33 <b_jonas> because there you have a dualty pairing problems of the same kind
06:46:38 <EvilTerran> Sizur, i thought the 4-colour rule didn't work for surfaces of solids; toruses can need 5 colours, iirc.
06:46:41 <b_jonas> while here the two are clearly different
06:46:53 <b_jonas> sizur: convex? I have to think about that...
06:47:05 <b_jonas> tori need 7 colors
06:47:09 <Sizur> EvilTerran: well, it's a generalization of the 4 color rule to a curved surface
06:47:11 <EvilTerran> i bet sphere packing's going to appear soon
06:47:20 <EvilTerran> oh, 7. okay, it's even worse than i thought ;]
06:47:21 <b_jonas> I can show the lower limit for tori if you want, but I can't prove the upper limit
06:47:28 <nornagon> klein bottles only need 6!
06:47:42 <b_jonas> what about projective spaces?
06:48:01 <b_jonas> the funny thing is of course that the plane is the most difficult case, more difficult than any other surfaces
06:48:04 <EvilTerran> ...can the two sides of a bit of the klein bottle surface be different colours at any one location?
06:48:24 <b_jonas> no
06:48:34 <b_jonas> that's a different surface
06:48:46 <EvilTerran> okay
06:48:48 <b_jonas> I'm not sure what surface exactly, but it's a one-sided surface
06:50:02 <b_jonas> the convex thing reminds me to the famous cigar problem
06:50:56 <quicksilver> the surface of a klein bottle is two moebius strips connected in the obvious 1-1 way along their edge
06:51:01 <quicksilver> unless I misremember
06:56:36 <nornagon> quicksilver: take a mÃ¶bius strip and connect the edges
06:56:46 <nornagon> the not-already-connected edges, that is
06:57:03 * EvilTerran pokes his spatial awareness
06:57:21 <b_jonas> nornagon: that's what quicksilver's said, didn't he
06:57:35 <nornagon> er, i guess..?
06:57:36 * EvilTerran thinks quicksilver's version sounds righter
06:57:50 <nornagon> i've never done serious maths, so :)
06:58:22 <EvilTerran> i don't think you *can* join the edge of a mobius strip to itself all the way round, even if you are allowed to self-intersect
06:59:44 <quicksilver> you can't
06:59:47 <nornagon> exactly :)
06:59:50 <b_jonas> I think you can, but quicksilver said to join the edges of two different mobius strips, not join the edge of a single one
06:59:56 <quicksilver> you can't join S_1 (a.k.a the circle) to itself
07:00:07 <quicksilver> there is no continous way to do that
07:00:15 <quicksilver> you could 'squash it all down to a point'
07:00:19 <quicksilver> but that wouldn't be continuous :)
07:00:29 <quicksilver> but two strips = 2 circles
07:00:31 <quicksilver> that's no problem
07:00:37 <EvilTerran> "[The Klein bottle] can be cut in half along its length to make two MÃ¶bius strips (Dodson and Parker 1997, p. 88), but can also be cut into a single MÃ¶bius strip (Gardner 1984, pp. 14 and 17)."
07:00:47 <EvilTerran> http://mathworld.wolfram.com/KleinBottle.html
07:00:48 <lambdabot> Title: Klein Bottle -- from Wolfram MathWorld
07:01:08 <quicksilver> EvilTerran: hmm. That's interesting. Counter-intuitive.
07:01:55 <b_jonas> but of course you can, even with a single circle, you just equate the opposite points. that's one way to make a projective space from a disc (topologically speaking)
07:02:26 <quicksilver> ah, hmm
07:02:36 <quicksilver> damned 3d intuition getting in the way, I think :)
07:02:46 <quicksilver> of course b_jonas is quite right
07:03:31 * EvilTerran notes that those java applets have b0rkÃ©d his firefox
07:05:23 <b_jonas> you might be thinking of the Brouwer fixed point theorem
07:07:03 <b_jonas> anyway, I still wonder about this convex thing
07:12:58 <Sizur> is anybody inhere regularly producing literate haskell that can be compiled into pdf?
07:14:09 <kjdf> hello
07:14:17 <Sizur> kjdf: hi
07:14:40 <kjdf> is anyone here familiar with Control.Arrow.Transformer.Automaton from arrows package
07:14:46 <kjdf> Sizur: not me, sorry :)
07:15:09 <roconnor> Sizur: presumably the editors of the monad reader do that.
07:15:29 <kjdf> I don't know how to build a non trivial automaton without access to constructor, that is how to switch states
07:15:31 <Sizur> roconnor: yeah. guess it's not a common thread
07:15:33 <Sizur> yet
07:16:00 <kjdf> (I could build a switching combinator using automaton constructor, but it isn't exported)
07:18:49 <roconnor> mudge: I just read your post; I can see why you are confused :(
07:19:28 <roconnor> functions, total functions, partial functions.
07:19:32 <hkBst> is there a standard function for the complement of (!!), returning a list with one element removed?
07:19:44 <quicksilver> (\\)
07:19:48 <quicksilver> but you have to give it a list
07:19:53 <quicksilver> so \\ [x]
07:19:58 <quicksilver> > [1,2,3,4,5] \\ [4]
07:20:00 <lambdabot>  [1,2,3,5]
07:20:05 <Sizur> :t (\\)
07:20:07 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
07:20:28 <hkBst> quicksilver: I want to remove based on position
07:20:33 <Sizur> > "test" \\ "te"
07:20:34 <lambdabot>  "st"
07:20:53 <roconnor> mudge: the definition of partial function you cite is badly worded and I'd even argue it is wrong.
07:20:56 <quicksilver> hkBst: oh, sorry
07:21:04 <Sizur> > "test" \\ "st"
07:21:05 <lambdabot>  "et"
07:21:11 <roconnor> ``Partial Function: A function which is not defined for some of its domain. ''
07:21:13 <quicksilver> hkBst: no, just use take and drop
07:21:29 <roconnor> but of course a function is always defined on it's domain because that is the definition of domain.
07:21:35 <roconnor> its domain
07:21:59 <b_jonas> the indexing function in J has a special convention to do drops like that
07:22:02 <matthew_-> a function where the type of the input permits a larger set of values than the domain of the function ?
07:22:06 <quicksilver> > let l = "abcdef" in (take 3 l) ++ (drop 4 l)
07:22:08 <lambdabot>  "abcef"
07:22:09 <Sizur> > "test" \\ "tte"
07:22:10 <lambdabot>  "s"
07:22:32 <ToRA> @pl (\n -> (\(a,b) -> a ++ tail b) . splitAt n
07:22:32 <lambdabot> (line 1, column 43):
07:22:33 <lambdabot> unexpected end of input
07:22:33 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or ")"
07:22:36 <ToRA> @pl (\n -> (\(a,b) -> a ++ tail b) . splitAt n)
07:22:37 <lambdabot> (uncurry ((. tail) . (++)) .) . splitAt
07:22:41 <Sizur> > "test" \\ "ttte"
07:22:42 <lambdabot>  "s"
07:22:43 <quicksilver> Sizur: it has a weird-but-consitent interprettion of multiple occurences
07:23:03 <olsner> > "test" \\ "te"
07:23:04 <lambdabot>  "st"
07:23:04 <Sizur> quicksilver: works perfectly! :)
07:26:35 <hkBst> > let (~!!) lst n = let lst1 = take (n-1) lst ++ drop n lst in [1,2,3,4] ~!! 2
07:26:35 <lambdabot>  Parse error
07:26:59 <hkBst> 8-/
07:27:33 <hkBst> > let (~!!) lst n = take (n-1) lst ++ drop n lst in [1,2,3,4] ~!! 2
07:27:35 <lambdabot>  [1,3,4]
07:27:50 <Sizur> starts with 1?
07:27:54 <quicksilver> hkBst: you can define infix if you prefer
07:28:04 <quicksilver> hkBst: let lst ~!! n =
07:28:19 <mux> Haskell: You can.
07:31:01 <roconnor> > let (~!!) lst n = uncurry (++) spiltAt (n-1) lst in [1,2,3,4] ~!! 2
07:31:02 <lambdabot>   Not in scope: `spiltAt'
07:31:07 <roconnor> > let (~!!) lst n = uncurry (++) splitAt (n-1) lst in [1,2,3,4] ~!! 2
07:31:09 <lambdabot>  Couldn't match expected type `([a], [a])'
07:31:14 <ToRA> > let (~!!) = flip ((uncurry ((. tail) . (++)) .) . splitAt) in [1,2,3,4] ~!! 2
07:31:15 <lambdabot>  [1,2,4]
07:31:39 <roconnor> ToRA: ah, very clear
07:31:41 <Sizur> > let xs ~!! n = xs \\ (xs!!n:[]) in "test" ~!! 2
07:31:42 <lambdabot>  "tet"
07:32:00 <roconnor> > let xs ~!! n = xs \\ (xs!!n:[]) in "test" ~!! 3
07:32:02 <lambdabot>  "est"
07:32:14 <ToRA> roconnor: :)
07:32:18 <Sizur> lol
07:34:29 <roconnor> If I want to make a simple GUI for my simple program for personal use, is this phooey thing a reasonable choice?
07:35:04 <Sizur> @go phooey thing
07:35:06 <lambdabot> http://runesmith.blogspot.com/2007/08/phooey.html
07:35:06 <lambdabot> Title: Runesmith's Canadian Content: Phooey
07:35:13 <ToRA> why not gtk2hs + glade?
07:35:16 <roconnor> @wiki Phooey
07:35:17 <lambdabot> http://www.haskell.org/haskellwiki/Phooey
07:35:36 <Sizur> if it's for personal use, but gui?
07:35:41 <Sizur> why not but
07:35:42 <roconnor> ToRA: I was under the impression gtk2hs was low level and hence difficult to use.
07:35:57 <matthew_-> why not just a repl?
07:36:08 <matthew_-> is a gui really needed?
07:36:14 <roconnor> Sizur: yeah, I feel the same way about a GUI.  But typing at the ghci command line is getting annoying
07:36:22 <dcoutts> roconnor: it's not very difficult to use
07:36:34 <ToRA> roconnor: depends what you want.  glade is a visual designer for gtk programs, it outputs an xml file, and you can get gtk2hs to read that and present the gui
07:36:57 <matthew_-> roconnor: tab completion?
07:37:01 <ToRA> roconnor: you only then need to write code for the gtk hooks, which is fairly simple, if your gui is straightforwards
07:37:09 <dcoutts> roconnor: http://haskell.org/gtk2hs/docs/tutorial/glade/
07:37:10 <ToRA> *gtk hooks = mouse actions, etc.
07:37:10 <lambdabot> Title: Gtk2Hs » Documentation » Glade Tutorial
07:39:07 <roconnor> I don't know about this separate XML file from the rest of the code.  That doesn't seem type safe :)
07:39:28 <Sizur> Phooey looks easy
07:39:28 <hpaste>  hkBst pasted "calculate permutations" at http://hpaste.org/2699
07:39:43 <hkBst> can I write that better?
07:40:00 <roconnor> matthew_-: actually I have a specific problem with GHCi, maybe someone can help me here.
07:40:15 <matthew_-> maybe ;)
07:40:27 <roconnor> I have a function loadMarkets :: (Floating a) => IO [Market a]
07:40:42 <xerox> roconnor: check out demo/glade* in the gtk2hs source tree, it's quite nice.
07:40:43 <roconnor> and at the GHCi prompt I try do
07:40:49 <roconnor> > mk <- loadMarkets
07:40:50 <lambdabot>  Parse error
07:40:53 <roconnor> well
07:41:01 <matthew_-> heh
07:41:06 <roconnor> anyhow, mk always ends up with type IO [Market Double]
07:41:22 <roconnor> even when I do -fno-monomorphism-restriction
07:41:28 <matthew_-> ahh, right, is this the default stuff in ghc?
07:41:33 <dcoutts> roconnor: yes, it's not type safe statically, it checks when you load widgets from the xml file that they are of the right type.
07:41:40 <matthew_-> @type 2.3
07:41:44 <dcoutts> roconnor: so it's type safe dynamically.
07:41:49 <lambdabot> forall t. (Fractional t) => t
07:42:02 <roconnor> type safe dynamically is an oxymoron :P
07:42:02 <dcoutts> roconnor: same as you having to check formatting when loading data files etc
07:42:08 <dcoutts> no it's not.
07:42:18 <roconnor> well, it depends on what you mean by safe.
07:42:25 <ToRA> http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html#extended-default-rules
07:42:27 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2c2oeu
07:42:45 <Sizur> :t delete
07:42:47 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
07:43:47 <hkBst> @src delete
07:43:48 <lambdabot> delete = deleteBy (==)
07:43:55 <dcoutts> roconnor: the point is, at the point you load the glade xml file, if you're loading named elements of a particular type, and it turns out that the xml file does not contain that element or it has the wrong type then you get an exception
07:44:00 <Sizur> :t nub
07:44:00 <roconnor> Is it at all possible to run the loadMarkets command and get a Floating a => [Market a]?
07:44:02 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:44:22 <dcoutts> roconnor: same as if the file was not xml or it parsed wrong or anything like that, it's just a runtime exception
07:44:37 <roconnor> dcoutts: throws an execption; segfaults; almost the same thing.
07:44:49 <xerox> roconnor: if I do x <- readIO "12" and :t x, ghci says x :: Integer.
07:44:51 <dcoutts> it's quite a big difference
07:45:07 <Sizur> i also dislike runtime errors
07:45:17 <dcoutts> then you'd better avoid parsing :-)
07:45:41 <roconnor> dcoutts: parsers usually return Maybe Foo
07:45:47 <dcoutts> roconnor: same here
07:45:49 <roconnor> or m Foo for any monadZero
07:46:02 <dcoutts> `catch` return Nothing
07:46:20 <dcoutts> it's just that in IO, an IO exception is the normal and convenient mechanism
07:46:28 <roconnor> dcoutts: so it throws an exception in the error monad rather than an IOerror?
07:46:48 <Sizur> xhtml combinator is much easier and guaranteed to be valid as opposed to letting some editor comeup with valid xslt but invalid result
07:47:07 <dcoutts> roconnor: it throws an IO exception which you catch with the normal IO exception handling mechanism, or not at all if you don't care
07:47:34 <roconnor> dcoutts: well, you can only catch it in the IO monad ... but I guess if you are loading from a file, you are in IO already
07:47:43 <dcoutts> roconnor: oh, actually I'm forgetting :-)
07:47:44 <dcoutts> Just xml    <- xmlNew "hellogtk2hs.glade"
07:47:44 <roconnor> dcoutts: okay, I'm convinced.
07:47:55 <dcoutts> it does return IO (Maybe thing)
07:48:02 <roconnor> dcoutts: :)
07:48:12 <dcoutts> roconnor: I mean to change it to just throw an exception since that's the more convenient thing to do
07:48:28 <Sizur> he cannot continue his program if glide.xml is invalid anyway, even if he catches the exception
07:48:32 <dcoutts> I'll do that for the new gtk builder api, which is a replacement for glade
07:48:39 <roconnor> dcoutts: just return (m thing) for an MonadError m
07:48:49 <dcoutts> Sizur: exactly, so an exception is the right thing
07:48:55 <roconnor> dcoutts: then people can do join to get from IO (IO a) -> IO a
07:49:02 <dcoutts> roconnor: is IO not in MonadError ?
07:49:17 <dcoutts> IO is certainly an error monad
07:49:39 <trez> @src nub
07:49:40 <lambdabot> nub = nubBy (==)
07:49:51 <xerox> ?instances MonadError
07:49:52 <roconnor> @instances MonadError
07:49:52 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
07:49:54 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
07:49:56 <dcoutts> roconnor: we don't really want to parameterise the whole gtk2hs api by an arbitrary MonadIO and MonadError, just using IO is fine I think.
07:50:12 <roconnor> dcoutts: okay
07:50:51 <roconnor> dcoutts: I agree with that assessment
07:52:07 <roconnor> still... this phooey things sounds pretty interesting...
07:52:21 <dcoutts> yes, pitty it doesn't use gtk2hs at the moment
07:52:22 <quicksilver> I'd quite like all IO stuff to be MonadIO actually
07:52:22 <ndm> I personally prefer PropLang :)
07:52:27 <quicksilver> saves you a LOT of lifting
07:52:28 <dcoutts> so it's pretty hard to install
07:52:30 <roconnor> dcoutts: what does it use?
07:52:36 <dcoutts> roconnor: wx
07:52:37 <quicksilver> if you use a transformed monad
07:52:40 <roconnor> :(
07:52:45 <dcoutts> wx does not work for ghc 6.6.x
07:52:50 <quicksilver> on the other hand, it makes types and error messages unwieldy
07:52:52 <roconnor> :( :(
07:53:09 <dcoutts> unless you can find the patches floating around somewhere, the default released tarball certainly doesn't work
07:53:27 <quicksilver> standard problem
07:55:58 <roconnor> no phooey for GHC 6.6?
07:56:02 <roconnor> :'(
08:03:34 <Sizur> :t return
08:03:36 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:05:51 <ari> Would you consider it at all sane to load an untrusted plugin (with hs-plugins) and call it in a trusted monad that prevents general IO but has a sanitised set of useful computations lifted from IO? My goal is that the untrusted code might try to gobble up all the RAM or write enormous files in the directories it's allowed access to, but not actually do something like rm -rf without finding a bug in the GHC RTS or the trusted monad
08:06:30 <quicksilver> ari: that general idea, yes
08:06:31 <moonlite> i'd like to make a quickcheck property that states that my function "pow" and (^) is "equal" (in the lack for a better word. Ie they produce the same result from the same input)
08:06:45 <moonlite> is it hard?
08:06:47 <quicksilver> ari: some of the details you give don't really make sense :)
08:07:19 <quicksilver> moonlite: check \n m -> pow n m == n ^ m
08:07:25 <quicksilver> moonlite: is the basic structure
08:07:29 <ari> quicksilver: Well, I don't really know what I'm doing here, so...
08:07:35 <moonlite> quicksilver: ok neat.
08:07:48 <quicksilver> ari: I wouldn't say you "call it in a trusted monad" exactly
08:08:05 <quicksilver> ari: I'd say you "compile it against a restricted version of System.IO"
08:08:25 <quicksilver> ari: the simplest thing to do is to complete rule out System.IO, of course
08:08:41 <quicksilver> (and it's very important to rule out the unsafe functions)
08:08:55 <xwx> moonlite: how will you rule out unsafePerformIO?
08:09:14 <quicksilver> xwx: you'll have to compile it against a trusted library which doesn't contain unsafePerformIO
08:09:28 <quicksilver> (or, at least, which is known not to export it)
08:09:36 <moonlite> xwx: was that for me?
08:09:54 <xwx> yes
08:10:40 <ari> quicksilver++
08:11:21 <quicksilver> ari: it is interesting to examine what lambdabot does
08:11:40 <quicksilver> ari: (it completely forbids the import statement, of course, and then runs against a restricted library)
08:12:11 * ari nods - I've been reading lambdabot code, yes
08:12:14 <EvilTerran> > unsafePerformIO (putStrLn "blarg im ded")
08:12:15 <lambdabot>   Not in scope: `unsafePerformIO'
08:12:25 <EvilTerran> :t unsafePerformIO (putStrLn "blarg im ded")
08:12:27 <lambdabot> Not in scope: `unsafePerformIO'
08:12:35 <xwx> @hoogle unsafePerformIO
08:12:36 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
08:12:43 * ari reorders some thoughts in his head and goes off to hack!
08:12:50 <quicksilver> :t Foreign.unsafePerformIO (putStrLn "blarg im ded")
08:12:52 <lambdabot> ()
08:12:55 <quicksilver> tada
08:15:10 <axm> is there a simple way to make function types showable?
08:15:31 <axm> cannot derive show for example using type
08:15:36 <EvilTerran> ?instances Typeable
08:15:37 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
08:15:45 <EvilTerran> ?instances-importing Data.Typeable Typeable
08:15:47 <lambdabot> s a
08:15:50 <EvilTerran> ...
08:16:05 <axm> thx
08:16:25 <EvilTerran> axm, do you mean so show (\x -> x+1) = "\\x -> x+1"? 'cos that's impossible
08:16:55 <axm> no, i would like to get the types
08:17:14 <EvilTerran> Typeable merely makes it possible to introspect on the type of something, not it's contents...
08:17:19 <EvilTerran> oh right. just checkin'.
08:17:56 <phobes> Did I hear on here that Haskell typechecking doesn't always terminate?
08:18:42 <EvilTerran> it does unless you -fallow-undecidable-instances
08:18:44 <axm> i seem to remember a security problem came up sometime regarding that
08:19:01 <EvilTerran> and even then, there's a finite recursion depth
08:19:08 <phobes> EvilTerran: ok, that must have been what I was remembering ... thanks
08:20:05 <EvilTerran> (without -fallow-undecidable-instances, each iteration of the type inference makes the problem smaller. with it, it's possible for the problem to diverge)
08:20:37 <hpaste>  moonlite annotated "My (^)-function" with "(no title)" at http://hpaste.org/2701#a1
08:21:15 <EvilTerran> ...?
08:21:45 <moonlite> hm. Didn't mean to announce that yet. Adding some qc-props etc. The thing is it seems to be faster than what's in ghc. So im guessing i've missed somethign in my implementation?
08:21:51 <moonlite> please take a look
08:22:20 <EvilTerran> @source (^)
08:22:20 <lambdabot> (^) not available
08:22:22 <EvilTerran> @src (^)
08:22:22 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:22:24 <EvilTerran> hm.
08:23:19 <smashor> Hello. Has someone installed haskellmode for vim ?
08:23:35 <smashor> there is no :DocSettings
08:24:22 <byorgey> @type (^)
08:24:24 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:24:30 <byorgey> moonlite: it looks good.  I'm surprised that it's faster than the GHC version, though!
08:25:52 <EvilTerran> ?type (^)
08:25:54 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:26:10 <Flynsarmy> How do i fix the 'not in scope' error when i try to run isAlpha 'a' in a script?
08:26:17 <ibid> mudge: your blog comment script is buggy
08:26:31 <hpaste>  moonlite annotated "My (^)-function" with "my pow - tests" at http://hpaste.org/2701#a2
08:26:33 <ibid> mudge: IOError: [Errno 13] Permission denied: 'comments.py'
08:26:34 <byorgey> @index isAlpha
08:26:34 <lambdabot> Data.Char
08:26:42 <byorgey> Flynsarmy: probably need to add import Data.Char at the top.
08:26:59 <moonlite> byorgey: do you get the same results?
08:30:46 <byorgey> moonlite: yes, I do
08:31:50 <beelsebob> gyah
08:31:57 <byorgey> odd, I'm not sure what would make the GHC version so slow
08:32:06 <byorgey> but that's good to know!
08:32:08 <beelsebob> not doing garbage collection introduces a whole world of non-termination issues to an evaluator
08:32:48 <EvilTerran> byorgey, moonlite: might this warrant a bug report?
08:33:00 <byorgey> EvilTerran: it might
08:33:18 <byorgey> moonlite: want to file a GHC bug report?
08:33:57 <moonlite> byorgey: sure. Where though? ;)
08:34:12 <EvilTerran> @bugs ?
08:34:12 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
08:34:25 <moonlite> thx
08:34:49 <beelsebob> is the order in which arguments are evaluated defined in Haskell?
08:34:58 <EvilTerran> not exactly
08:35:05 <byorgey> beelsebob: it depends on what order they're needed in
08:35:18 <quicksilver> I'm not that surprised it is faster for sufficiently large y
08:35:18 <EvilTerran> but the bottom-semantics are defined, i believe.
08:35:21 <byorgey> beelsebob: sometimes arguments are not evaluated at all, if they are nnot needed.
08:35:27 <quicksilver> I'm pretty sure the ghc version doesn't do repeated-squaring
08:35:28 <beelsebob> byorgey: I know
08:35:37 <byorgey> quicksilver: why not?
08:35:40 <beelsebob> hmm, no, I was thinking slightly squint
08:35:46 <beelsebob> pattern matching works differently in Haskell
08:36:28 <moonlite> byorgey: did you test with 6.7?
08:36:29 <beelsebob> hmm
08:36:30 <quicksilver> the evaluation order is nearly-defined actually
08:36:35 <quicksilver> we know that haskell is non-strict
08:36:39 <beelsebob> my pattern matcher needs to return either a supstitution or a demand
08:36:40 <beelsebob> :/
08:36:41 <byorgey> moonlite: no, 6.6.1
08:36:44 <quicksilver> so we know that it's forbidden from evaluating too early
08:37:04 <quicksilver> if it's forbidden from evaluating too early, it can only evaluate when it has proved that it needs to
08:37:12 <beelsebob> quicksilver: ironically, the problem I'm having is my evaluator evaluating things "too late"
08:37:15 <byorgey> moonlite: yeah, good point, you should probably test with the latest version before filing a bug report =)
08:37:17 <quicksilver> which means that call-by-need is almost the only possibility
08:37:24 <beelsebob> i.e. after it's already discovered there will never be a demand for the evaluation
08:37:33 <quicksilver> it's only strictness analysis which enables you to do better than call-by-need
08:37:40 <quicksilver> and that's not particularly powerful, I don't think, in ghc
08:37:55 <moonlite> hm?
08:38:30 <moonlite> anyhow. Is there an easy way to check if the implementation has changed since 6.6
08:39:46 <byorgey> moonlite: I'm not sure
08:39:58 <moonlite> or, are there anyone here who could check if the same behavious is present in 6.7? (wouldn't want to post an already "fixed" "bug")
08:40:55 <quicksilver> the darcs soure for ghc is browsable
08:41:03 <quicksilver> but I don't know which file (^) is defined in
08:41:15 <quicksilver> moonlite: which instance were you comparing? presumably Integer?
08:41:48 <kjdf> is it possible to specify in instance declaration
08:41:49 <kjdf> a constraint that a parameter *is not* something?
08:41:58 <moonlite> quicksilver: i "learned" quickcheck a few minutes ago. so actually i'm not sure
08:42:00 <EvilTerran> kjdf, afraid not.
08:42:09 <moonlite> did you check my quickcheck proerty?
08:42:21 <quicksilver> :t 5
08:42:24 <lambdabot> forall t. (Num t) => t
08:42:28 <moonlite> prop x y = y >= 0 ==> x `pow` y == x^y
08:42:36 <EvilTerran> kjdf, the typesystem only covers intuitionistic logic, iirc
08:42:37 <quicksilver> moonlite: ghc defaults to Integer, so you probably were checking Integer
08:42:51 <moonlite> quicksilver: probably
08:42:51 <hpaste>  kjdf pasted "type class stupidity" at http://hpaste.org/2702
08:43:13 <quicksilver> moonlite: so probably what you're saying is taht your implementation is faster than gmp
08:43:19 <quicksilver> moonlite: that is certainly interesting though
08:43:30 <quicksilver> (I suspect ghc calls out to gmp for large (^) but I'm not sure)
08:43:59 <kjdf> any ideas how to make this work? the problem is that a tuple is both a general 'a' and '(a,b)'
08:44:09 <kjdf> (that is, first instance causes problems)
08:45:23 <Mitar> i am using Parsec to parse some language and it is throwing out of stack exception
08:45:30 <Mitar> probably I made some left recurssion ...
08:45:32 <quicksilver> kjdf: give up on a b -> c ?
08:45:40 <doserj> -fallow-overlapping-instances ?
08:45:41 <Mitar> how could I discover where does it loop?
08:46:04 <quicksilver> kjdf: surely "(a,b) c ((a,b),c)" and "(a,b) c (a,b,c)" are both quite sensible instances
08:46:25 <EvilTerran> kjdf, -fallow-overlapping-instances kinda works for that; you've got to be careful about what it means by "most specific instance", though
08:47:51 <doserj> maybe you even need -fallow-incoherent-instances
08:47:59 <kjdf> EvilTerran: can I hint the compiler about that?
08:48:11 <Flynsarmy> Sorry to be a pain but could some one please tell me where i went wrong with http://hpaste.org/2703
08:48:23 <matthew_-> if you need incoherent-instances it's quite possible you're in big trouble
08:48:30 <EvilTerran> doserj, if you need incoherent instances, you're doing it wrong
08:48:46 <matthew_-> EvilTerran: snap ;)
08:48:54 <matthew_-> @quote stereo
08:48:54 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
08:48:54 <hpaste>  sjanssen annotated "palindrome implementation" with "import was wrong" at http://hpaste.org/2703#a1
08:48:59 <EvilTerran> Flynsarmy, "isPalindrome s = s' == reverse s'", maybe?
08:49:07 <kjdf> doserj: I thought that actually was a joke ;)
08:49:58 <Flynsarmy> It will return true if s is equal to its reverse
08:50:09 <puusorsa> EvilTerran, no, if you want it to disregard whitespace and punctuation
08:50:21 <EvilTerran> wut?
08:50:39 <EvilTerran> if you want it to disregard whitespace, case, and punctuation, you want to use s'.
08:50:41 <puusorsa> oh sorry misunderstood what you meant
08:50:54 <puusorsa> yeah didn't get that ' in s'
08:51:00 <EvilTerran> if there's *any* of the above, (s == reverse s') will be false
08:51:03 <Mitar> how can i find out where Parsec is cycling?
08:51:37 <EvilTerran> put a GPS on its bike :D
08:52:02 <Mitar> :-)
08:56:58 <SimonRC> I recall reading somewhere that splitting random number generators is a bad idea.
08:57:00 <norpan> i hate using s and s' for variable names, so easy to get them mixed up
08:57:15 <SimonRC> Is that out-of-date info?
08:58:03 <SimonRC> gah!
08:58:12 <SimonRC> I ask a question, then 4 people join
08:58:55 <EvilTerran> @source Data.Random
08:58:55 <lambdabot> Data.Random not available
08:59:00 <SimonRC> I recall reading somewhere that splitting random number generators is a bad idea.  Is that out-of-date info?
08:59:11 <EvilTerran> @source System.Random
08:59:11 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
08:59:39 <oklopol> and after you repeat, no one answers :P
08:59:42 <oklopol> what a cruel world
08:59:55 <EvilTerran> "Object not found"?
09:00:45 <EvilTerran> SimonRC, given that there's 400 people in here at the moment (not counting the bot), i doubt 1% change is going to have that significant an effect on the likelihood of your question being answered...
09:00:50 <quicksilver> SimonRC: no, that's not out-of-date
09:01:00 <quicksilver> SimonRC: it's because the haskell RNG really isn't all that good
09:01:08 <Conal2> urg -- i've lost my nickserv password.  (gaim knows it, but my gaim is acting up.)  does anyone know how to retrieve a nickserv password?
09:01:12 <quicksilver> SimonRC: it has a few obvious artefacts and doesn't split all that well
09:01:21 <taruti> http://darcs.haskell.org/packages/random/System/Random.hs
09:01:21 <quicksilver> Conal2: there is a link on freenode's website
09:01:57 <Conal2> quicksilver: hm.  i've searched the faq.
09:02:09 <taruti> For cryptographically strong random numbers something else than System.Random should be used.
09:03:36 <quicksilver> taruti: it's not just that
09:03:46 <quicksilver> taruti: it's jsut a bit easy to get into short cycles and stuff
09:03:55 <quicksilver> taruti: we could do better without going to crypto-strength
09:04:08 <quicksilver> It has been suggested that someone should write a mersenne twister for haskell
09:04:12 <taruti> true
09:04:19 <quicksilver> that's a well understood algorithm and loads better than what we have
09:04:27 <quicksilver> our current RNG only has about 64 bits of state, IIRC?
09:04:34 <quicksilver> or even less, perhaps?
09:05:15 <quicksilver> actually I think StdGen might only be 30 bits
09:05:17 <quicksilver> or 32
09:05:48 <quicksilver> ah well, it's Int Int
09:05:58 <quicksilver> so it migth be rather better on 64 bit machines than it is on 32
09:08:03 <hpaste>  kjdf annotated "type class stupidity" with "(no title)" at http://hpaste.org/2702#a1
09:08:21 <oklopol> > 3*2
09:08:23 <lambdabot>  6
09:08:36 <kjdf> quicksilver: I removed "a b -> c" - now I get an error
09:08:53 <kjdf> why and how do I fix it?
09:08:53 <quicksilver> kjdf: right
09:09:05 <quicksilver> kjdf: because as far as it knows, there might be many possible cs
09:09:10 <quicksilver> kjdf: so it doesn't know which to use
09:09:16 <quicksilver> kjdf: add a type signature
09:09:28 <quicksilver> kjdf: (in real programs, often not needed as context + type inference can find it)
09:10:02 <kjdf> it works with Char with signature
09:10:13 <kjdf> but doesnt't work with Ints
09:10:44 <quicksilver> what is the error with Ints?
09:10:53 <EvilTerran> kjdf, i'd suggest replacing "instance Stretchable a b (a,b)" with "newtype Single a = Single a; instance Stretchable (Single a) b (a,b)", say.
09:11:05 <kjdf> that is " 1 ==> 1 :: (Int,Int)" spits out  "No instance for (Stretchable t t1 (Int, Int))"
09:11:16 <EvilTerran> it'd be a little clunkier to use, but it'd eliminate the overlapping instance
09:11:31 <xwx> will random numbers be fixed in ghc 6.7?
09:12:20 <quicksilver> xwx: not unless someone steps forward to fix them
09:12:29 <quicksilver> kjdf: that's defaulting
09:12:41 <quicksilver> kjdf: 1 has type 'Num' not Int'
09:12:43 <moonlite> http://hackage.haskell.org/trac/ghc/ticket/1687#preview
09:12:44 <lambdabot> Title: #1687 (A faster (^)-function.) - GHC - Trac
09:12:45 <quicksilver> kjdf: so that doesn't match
09:12:54 <kjdf> quicksilver: ok, I got it
09:13:01 <quicksilver> kjdf: try (1 :: Int) ==> 1 :: (Int,Int)
09:13:01 <quicksilver> ;
09:13:02 <EvilTerran> quicksilver, type Num a => a, shurely?
09:13:03 <kjdf> thanks
09:13:08 <quicksilver> EvilTerran: yeye :P
09:13:12 <kjdf> EvilTerran: thanks too :)
09:13:16 <Igloo> What about random numbers do you want fixed?
09:13:18 * EvilTerran is a pedant ;]
09:13:26 <quicksilver> EvilTerran: when I'm typing in several irc windows and once and doing real work, forgive me my shorthand
09:13:33 <EvilTerran> k
09:13:33 <quicksilver> Igloo: the fact that our generator isn't very good
09:13:41 <quicksilver> Igloo: and doesn't split well (in particular)
09:14:00 <Igloo> OK, yeah, that would certainly need someone to step up
09:14:11 <quicksilver> Igloo: it has been mooted that a mersenne twister with a nice big state (512 bits?) would be an improvement, but someone needs to write it :)
09:14:25 <Igloo> Right
09:15:18 <Igloo> Note that you can actually make a separate random-mersenne-twister package, though, it doesn't hav to be fixed in any particular GHC release
09:15:42 <Igloo> xwx: You have to nominate people who actually want a better random number library  :-)
09:16:18 <vincenz> @spell categorize
09:16:20 <vincenz> @spell cathegorize
09:16:32 <vincenz> lambdabot: ping
09:16:34 <vincenz> @bobt
09:16:34 <lambdabot> Unknown command, try @list
09:16:54 <quicksilver> Igloo: but, if someone did write a nice one, it would certainly be a good candidate for a new StdGen
09:17:12 <Flynsarmy> Not in scope: 'getArgs' when loading a script in the interpreter?
09:17:18 <Igloo> quicksilver: Is that used outside of the random library?
09:17:44 <Igloo> (but yes, we presumably would switch, if a better replacement was written)
09:18:19 <ndm> byorgey: who were you playing prime numbers with?
09:18:22 <sjanssen> Igloo: in theory, isn't System.Random free of the GHC release cycle now?
09:18:37 <byorgey> ndm: ?
09:19:02 <Igloo> sjanssen: No, it's in H98, so it has to come with the compiler
09:19:02 <ndm> byorgey: i meant power functions (^) - who is the original reporter? they gave an email but not an IRC
09:19:17 <byorgey> oh, it was moonlite
09:19:19 <EvilTerran> that was moonlite
09:19:38 <moonlite> :)
09:19:48 <EvilTerran> (beep beep)
09:20:08 <sjanssen> Igloo: it's in a separate package now though, so can't you install an upgraded version along with the one that came with ghc?
09:20:11 <conal> any gaim users here?  i've gotten gaim into a weird state where it interprets any lowercase B i type as toggle logging.
09:20:13 <sjanssen> you being the user
09:20:18 <sm> morning all
09:20:27 <mrd> conal: perhaps you have a stuck modifier
09:20:45 <EvilTerran> conal, try tapping all your modifier keys
09:20:49 <EvilTerran> er, what mrd said
09:20:51 <Igloo> sjanssen: Yes, although personally I would recommend sticking to only having a single versino of each package installed
09:20:53 <ndm> moonlite: in the odd branch, the next time round you know y - 1 is not odd, but you still test it
09:21:08 <ndm> moonlite: its possible (depending on how expensive odd is) that you could save a bit more time
09:21:20 <sm> after some weeks away from haskell, just now I decided to use it as a more concise interactive calculator (instead of python). I tried to sum a list of integers at the hugs or ghci prompt, but failed. Help.
09:21:33 <conal> mrd: tried that.  oddly, it's only gaim, and only B
09:21:45 <conal> and my options menu does list B as toggle logging
09:22:03 <moonlite> ndm: yes that seems possible.
09:22:10 <EvilTerran> > sum [1,2,3,7,10]
09:22:12 <lambdabot>  23
09:22:34 <sm> ack.. commas still required in lists.. thanks!
09:22:45 <EvilTerran> conal, might you have somehow edited gaim's set of keyboard shortcuts somehow?
09:23:02 <EvilTerran> (delete one "somehow" ;P )
09:24:19 <Conal2> EvilTerran: probably something like that.  so far i haven't found how to tweak the shortcuts.
09:25:14 <EvilTerran> have you asked in #pidgin?
09:25:18 <olsner> gtkrc-2 hacking, I guess... that's the way to configure Ctrl-Enter vs Enter, now that they *removed that option* from the settings dialog
09:25:22 <Conal2> Btw, i'm trying out erc (emacs irc client) is very cool.  i think i'll stick with it if i can get my password recovered.  gaim knows it and i don't.
09:25:24 <sm> if I wanted to write: sum n1 n2 n3 ..., with no punctuation and a variable number of ns, what would be a good approach ?
09:25:39 <ari> sm: Deep typeclass hackery
09:25:48 <EvilTerran> i've done that, actually
09:25:48 <sm> aiee
09:26:01 <ari> sm: http://okmij.org/ftp/Haskell/types.html#polyvar-fn
09:26:02 <lambdabot> Title: Haskell Programming: Types
09:26:18 <quicksilver> sm: once you start thinking in the haskell type system
09:26:28 <quicksilver> sm: you start to feel like that is not really a very pleasant idea anyway
09:26:43 <ndm> moonlite: are you going to look into that, or shall i add a comment to the bug, in case anyone follows it further
09:26:44 <quicksilver> > printf "%d:%d:%d" 4 5 6 :: String
09:26:46 <lambdabot>  "4:5:6"
09:26:56 <quicksilver> sm: although it is certainly possible, as printf shows
09:27:03 <quicksilver> I'm not fond of printf's hackery, though
09:27:12 <quicksilver> and for an even more painful example, see regex :)
09:27:13 <EvilTerran> class Num a => SumResult a b where sum :: b -> a; instance Num a => SumResult a a where sum = id; instance SumResult a s => SumResult a (a -> s) where {- i dunno what goes here -}
09:27:30 <EvilTerran> or something. don't quote me on that.
09:27:37 <moonlite> ndm: i'm gonna look into it tonight i think. Otherwise i'll report on IRC. I really should be studying instead :)
09:27:50 <sm> ari, quicksilver: thanks, good info
09:28:12 <moonlite> but add the note by all means. it can't hurt
09:28:17 <EvilTerran> @paste
09:28:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:28:40 <hpaste>  EvilTerran pasted "sm, here's something similar i did recently for kicks" at http://hpaste.org/2705
09:29:02 <sm> (+ EvilTerran)
09:29:07 <quicksilver> moonlite: one final question
09:29:15 <quicksilver> moonlite: did you compile with -O2 ?
09:29:20 <conal> EvilTerran: #pidgin?
09:29:21 <moonlite> yes
09:29:28 * quicksilver nods
09:29:29 <EvilTerran> there's probably a better way of doing it, but that was a killing-time-while-insomniaic thing
09:29:32 <ndm> i'm also curious what GHC's current algorithm is, as the one you've coded is the "standard" one
09:29:45 <moonlite> neat
09:29:45 <quicksilver> ndm: I guess it defers to gmp
09:29:58 <quicksilver> ndm: (at least for sufficiently large numbers)
09:30:07 <ndm> quicksilver: who should at the very least be using the standard one, if not some crazy table-driven uber-algorithm
09:30:09 <EvilTerran> conal, pidgin's what gaim's called now (copyright involving "aim" in the context of instant messaging, i guess). i figured they might be able to help
09:30:16 <quicksilver> ndm: yes, so you'd thing
09:30:20 <ndm> you do not beat GMP in 4 lines of Haskell!
09:30:26 <quicksilver> ndm: but I've heard people call GMP slow
09:30:37 <quicksilver> ndm: (but I didn't thinkt hey were talking about integer exponent)
09:31:21 <sm> EvilTerran: what does your paste do ?
09:31:56 <EvilTerran> sm, it lets you write "build a b c d e ..." and get [a,b,c,d...]
09:32:03 <sm> but ghci tells me build :: Int -> Int -> Int -> Int -> Int -> [Int]
09:32:09 <EvilTerran> using typesystem funk
09:32:29 <sm> and complains with arguments <> 5
09:32:51 <xwx> Conal2: you can use a packet dumping tool to discover your password. it's transmitted in cleartext
09:33:11 <EvilTerran> sm, hm... ah, i see; i had -fno-monomorphism-restriction, i think
09:33:16 <sm> (I have ghc 6.6)
09:33:35 <mrd> which is LANGUAGE NoMonomorphismRestriction also
09:34:04 <EvilTerran> sm, or add the line "build :: (ListBuilder a lb) => lb
09:34:04 <EvilTerran> " above the "build = buildList []" line
09:34:38 <EvilTerran> what mrd said works, too; i've changed the pragma in my local copy to {-# LANGUAGE MultiParamTypeClasses, NoMonomorphismRestriction #-}
09:34:38 <EvilTerran>  now
09:34:45 <EvilTerran> bah for newlines!
09:35:32 <sm> I've tried those changes, it's not happy at all
09:35:57 <hpaste>  sjanssen annotated "My (^)-function" with "found in GHC.Real" at http://hpaste.org/2701#a4
09:37:00 <sm> so if you have a version tested for ghc 6.6 I'd love to see it, otherwise thanks for the info
09:37:03 <EvilTerran> what error are you getting?
09:37:05 <EvilTerran> i'm on 6.6.1
09:38:00 <sm> No instance for (ListBuilder a (t -> t1)) arising from use of `build' at <interactive>:1:0-6
09:38:36 <tizoc[w]> anyone knows why Cabal uses 'cp' instead of 'install' when installing files?
09:39:20 <EvilTerran> sm, what're you typing that gives that error?
09:39:58 <hpaste>  sm annotated "sm, here's something similar i did recently for kicks" with "my version + example" at http://hpaste.org/2705#a1
09:40:04 <sm> build (anything)
09:40:28 <swiert> sm: you need to give a type signature probably.
09:41:00 <EvilTerran> sm, yeah, it needs a type to work properly
09:41:07 <EvilTerran>  that's why the xs example is :: [Int]
09:41:32 <sm> ah I see.. thanks
09:41:32 <EvilTerran> otherwise, it wouldn't know whether xs should be ::[Int], ::Int->[Int], Int->Int->[Int], or whatever
09:42:55 <sm> hmm hmm.. now if I force it to int I'll have my handier-than-python interactive adder
09:43:53 <EvilTerran> any way of forcing it to a Num type would be sufficient, an explicit type might not be strictly necessary.
09:44:13 <EvilTerran> (sum$build 1 2 3 4 5 6) should work, for instance
09:44:26 <sm> I mean, in the function definition/types.. so I don't need to type it interactively
09:44:28 <sm> aha
09:45:25 <sjanssen> hmm, I wonder if you could use a function type as a sentinel?
09:45:42 <sjanssen> to make something like "build 1 2 3 4 5 sum" work
09:46:38 <EvilTerran> sjanssen, sounds like you want postscript ;]
09:46:58 <EvilTerran> (in which "mark 1 2 3 4 5 sum" could work)
09:46:59 <xerox> sjanssen: yeah, I think that works.
09:47:13 <xerox> And it's also a nice idea :)
09:47:26 <sjanssen> of course it's not so nice if you want to make lists of functions
09:47:48 <xerox> If you go that far you can as well use HList :)
09:48:01 <EvilTerran> that'd involve overlapping instances, wouldn't it?
09:48:22 <sjanssen> if you wanted to be really evil, you can overload Num giving "1 2 3 4 5 sum" :)
09:48:29 <EvilTerran> i was quite pleased that mine managed to avoid doing so
09:48:32 <sjanssen> EvilTerran: most likely
09:58:41 <bvd> Hello, are there any GATDs and Type Family experts around?
09:59:39 <EvilTerran> i know a little...
10:00:00 <Flynsarmy> What are the functions to convert to and from ascii?
10:00:04 <bvd> I'm playing a bit with GATD's and Type Families and I have the following problem:
10:00:06 <hpaste>  Bas van Dijk pasted "GATDs and Type Families" at http://hpaste.org/2707
10:00:36 <EvilTerran> btw, the acronym you're looking for is "GADTs".
10:00:37 <bvd> I would like to define concat' and fromList but I can't get them to work
10:00:51 <EvilTerran> ?type ord
10:00:54 <hpaste>  sm annotated "sm, here's something similar i did recently for kicks" with "trying to force [Integer]" at http://hpaste.org/2705#a2
10:00:54 <lambdabot> Char -> Int
10:00:56 <bvd> EvilTerran: ofcourse.. typo
10:01:01 <EvilTerran> ?index ord
10:01:02 <lambdabot> Data.Char
10:01:08 <EvilTerran> > ord 'A'
10:01:10 <lambdabot>  65
10:01:32 <ricky_clarkson> I was thinking that 'then' would be a good name for flip (.), except that it's a keyword.
10:01:57 <SimonRC> how about |>
10:02:02 <ricky_clarkson> > let thenn=flip (.) in map ((*2) `thenn` (+10)) [3,4,5,6]
10:02:03 <SimonRC> that's that name in f#
10:02:04 <lambdabot>  [16,18,20,22]
10:02:09 <EvilTerran> sm, the type annotation in my definition of xs wasn't so it knew what type the elements of the lists were
10:02:24 <SimonRC> the unix name is of course |
10:02:25 <twanvl> > map (*2) >>> map (+10) $ [3,4,5,6]
10:02:26 <lambdabot>  [16,18,20,22]
10:02:30 <EvilTerran> sm, it was so it knew that xs was a list, not a function a->[a] or a->a->[a], or whatever.
10:02:35 <ricky_clarkson> SimonRC: aye.
10:02:43 <sm> I see
10:03:11 <ricky_clarkson> I can get Haskell to accept \|, but not |
10:03:35 <ricky_clarkson> :t (>>>)
10:03:37 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
10:03:40 <twanvl> ?src (->) (>>>)
10:03:40 <lambdabot> f >>> g = g . f
10:03:41 <SimonRC> | is syntax for guards
10:03:45 <EvilTerran> because all the system knows is that its type is an instance of ListBuilder, and that includes both lists and functions returning lists
10:03:53 <SimonRC> ricky_clarkson: just use |>
10:04:03 <ricky_clarkson> || is ok
10:04:10 <EvilTerran> || is or...
10:04:15 <SimonRC> ricky_clarkson: it is quite mneumonic, and many will know it from F#
10:04:18 <ricky_clarkson> Not if you use let. ;)
10:04:50 <ricky_clarkson> I'm struggling to see |> as mnemonic, can you explain why it is?
10:05:23 <EvilTerran> bvd, that doesn't seem to involve a GADT...
10:05:42 <EvilTerran> oh, wait, further down. never mind.
10:05:59 <bvd> EvilTerran: Does it involve type families then?
10:06:10 <EvilTerran> sorry, i missed the GADT definition
10:06:57 <ricky_clarkson> Does Haskell make any guarantees about equality of performance?
10:07:15 <ricky_clarkson> E.g., is (*2) always the same as \x -> x*2 in output code?
10:07:21 <bvd> EvilTerran: I'm also wondering if it's possible to define a function like fromList at al. Because statically you don't know the length of the list so you can't give a type of the resulting ListN.
10:07:24 <EvilTerran> the problem is that foldr's first parameter is (a -> b -> b), and you want to return something of a different type to its second parameter
10:07:31 <EvilTerran> indeed, you can't
10:07:53 <twanvl> ricky_clarkson: Haskell doesn't say *anything* about performance (aside from termination)
10:07:58 <ricky_clarkson> Ok.
10:08:05 <EvilTerran> these static guarantees are all well-and-good in theory, but only if you're actually only dealing with lists whose lengths you know at compiletime.
10:08:08 <ricky_clarkson> How about space?
10:08:45 <phobes> You can still deal generically with ListNs though through the N class, right?
10:09:03 <ricky_clarkson> What languages other than Haskell have automatic currying?
10:09:25 <dons> Curry probably does
10:09:28 <EvilTerran> the MLs do
10:09:46 <EvilTerran> i suspect Coq, altho i haven't actually looked at it
10:10:22 <bvd> phobes: What do you mean with 'generically'?
10:10:32 <ricky_clarkson> Is there a reason it wouldn't work in a dynamically-typed language?
10:10:39 <ricky_clarkson> (I know about the vararg problem)
10:11:18 <bvd> I mean, is it possible to define concat' in terms of foldr using the N class?
10:11:54 * phobes thinks
10:12:48 <EvilTerran> bvd, i think it's awkward as foldr's first parameter needs to be something weird like (forall b c. a -> b -> c)
10:13:11 <EvilTerran> as it needs to be able to return something of a different type to what its receiving
10:13:39 <conal> any erc (emacs irc client) users here?
10:14:25 <bvd> EvilTerran: Mmm yes, the wiki about GADTs also describes using existential types for this problem. Lets see if I can work something out. Thanks
10:21:57 <phobes> bvd:  I don't think existential types will provide the solution you want
10:22:25 <phobes> bvd: (because you won't be able to get the type out when you're done)
10:22:40 <phobes> bvd:  I think you need to use the type family trick again and define Foldr at the type level
10:22:45 <dons> Igloo: around?
10:23:25 <Igloo> dons: Yup
10:24:07 <phobes> bvd:  but actually you probably can't do that, so I dunno...
10:25:23 <phobes> bvd:  or maybe you can... ok lemme try
10:26:33 <phobes> bvd:  ok I see what's confusing me... I think you need to define it both at the type level and then at the value level
10:26:42 <EvilTerran> it might be possible if you make foldr a method of something
10:26:59 <phobes> bvd:  You need foldr, and it's type will be something like FoldrType, which will be a type family
10:28:11 <bvd> phobes: thanks I will look into it (I was away for a minute)
10:32:21 <sclv> what are the decent haskell implementations of a cache?
10:32:30 <sclv> I found the Haskell Transactional Cache -- are there any others?
10:37:07 <sclv> nobody
10:37:09 <sclv> ?
10:37:12 <phobes> bvd:  Actually you could also have an abstract induction type (t n) in your definition of foldr...
10:37:17 <phobes> foldr :: forall t :: * -> *. (forall n. N n => a -> t n -> t (S n)) -> t Z -> List a m -> t m
10:38:07 <Cale> sclv: Haskell implementations of a cache?
10:38:42 <Cale> sclv: What sort of cache?
10:38:46 <sclv> yep -- for database queries, etc.
10:39:17 <sclv> a generic autopopulating cache interface that gives control over timeouts and such
10:39:57 <sclv> so you can control when items expire from the cache and need to be updated
10:40:57 <Cale> Such a thing would have an interface in IO, but it's doable. I haven't heard anything about it being done.
10:41:17 <Cale> Memo tables, on the other hand, are quite easy.
10:41:20 <sclv> i'm thinking of playing around with creating a toy one to teach myself more about type-level-hackery
10:41:35 <sclv> so i wanted to get a sense of what exists already
10:42:08 <Cale> I don't think it would involve too much type-level hackery...
10:43:13 <Cale> You'd probably maintain a Data.Map from queries to results, paired with the time at which they were accessed.
10:43:59 <sclv> pretty much, except you'd want a generic way to define queries such that they could, on a "miss" be passed to a function to execute them
10:44:46 <sclv> and then to look at efficient implementation issues for storage -- i.e., hashtables maybe, or etc.
10:46:00 <sclv> i might have been overthinking it with types tho -- the HTM uses a simple record query model
10:46:10 <sclv> s/HTM/HTC/
10:47:24 <glen_quagmire> is there a way to make windows version ghci to ahve tab completion?
10:48:11 <sclv> i was thinking of keying on a hlist of types implementing "Hashable" with custom hash functions but that might be overkill
10:50:07 <conal> anyone use ContT?  i don't see a difference between ContT m a and Cont (m a).
10:50:46 <dons> ?unmtl Cont (m a)
10:50:53 <lambdabot> Cont (m a)
10:51:00 <dons> ?unmtl ContT m a
10:51:00 <lambdabot> err: Unknown MTL(1)
10:51:02 <dons> grr
10:51:50 <monochrom> ?unmtl ContT (IO a)
10:51:50 <lambdabot> ContT (IO a)
10:52:06 <conal> ?help unmtl
10:52:06 <lambdabot> unroll mtl monads
10:52:09 <monochrom> ?unmtl ContT r IO a
10:52:09 <lambdabot> (a -> IO r) -> IO r
10:52:44 <conal> ?unmtl Cont (IO r) a
10:52:44 <lambdabot> (a -> IO r) -> IO r
10:52:55 <conal> the methods all look the same to me also
10:53:14 <Flynsarmy> If i try to filter with filter's first argument being a function that takes 2 arguments, how do get it working properly? eg (currentLine needs to be the html line filter is currently working on):
10:53:15 <conal> and i doubt the Monad constraints are necessary
10:53:15 <Flynsarmy> filter (lnLen currentLine 5 > 25) htmlLines
10:53:20 <monochrom> Cont (IO r) a misses out MonadIO.
10:53:55 <conal> oh.
10:54:39 <Lemmih> Flynsarmy: filter (\lnLen -> lnLen < currentLine) htmlLines ?
10:54:44 <monochrom> It also misses out MonadTrans, so you can't even say "lift (putStrLn "hello")"
10:55:01 <conal> ah
10:55:25 <conal> thanks
10:56:17 <alexmKay> hey guys, need some help from a spanish speaking guy! :D msg plz
10:56:52 <Lemmih> alexmKay: Haskell help from a spanish speaking guy?
10:57:28 <dons> alexmKay: you might ask on #haskell.es
10:57:39 <alexmKay> okay thanks
10:59:04 <lambdabot> No hablo espaÃ±ol, desafortunadamente.
10:59:32 <lambdabot> Why do you need help in Spanish?
10:59:43 * araujo looks at dons joining and leaving
10:59:52 <Flynsarmy> Lemmih: How do i input both arguments using that method?
11:00:02 <araujo> alexmKay, #haskell.es !
11:00:42 <Lemmih> Flynsarmy: I don't understand the question.
11:01:25 <glen_quagmire> :i getArgs
11:01:34 <glen_quagmire> @index getArgs
11:01:34 <lambdabot> System.Environment
11:02:06 <Flynsarmy> Lemmih: lnLen takes 2 arguments. the line, and an integer value. By typing \lnLen -> lnLen < currentLine as the first argument of filter is that inputting the current list item into lnLen? It's not sticking in lnLen's second argument
11:02:25 * araujo boings and throws a lambda cookie at shapr direction
11:03:02 <kpreid> Flynsarmy: you want (\line -> lnLen line 5 > 25)
11:03:03 <Lemmih> Flynsarmy: filter (\ln -> lnLen ln currentLine) htmlLines ?
11:04:12 <shapr> hiya araujo
11:04:12 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
11:04:34 <araujo> hola shapr
11:04:36 <shapr> conal: Yes, I use erc, and M-x customize-group erc should get you to all the nice settings.
11:04:54 <conal> shapr: including nick notify?
11:05:02 <shapr> yup, it's in there somewhere.
11:05:14 <conal> shapr: oky doke.  thanks.
11:22:16 <roconnor> sigh, wxHaskell doesn't even come close to building for me
11:23:17 <conal> roconnor: what kind of problems?
11:24:10 <hpaste>  roconnor pasted "errors making wxHaskell" at http://hpaste.org/2708
11:25:22 <conal> yeeps :(
11:25:45 <roconnor> like I said, not even close
11:25:52 <roconnor> I'm probably misconfigured somehow :(
11:25:56 <conal> roconnor: have you confirmed that wxWidgets is working?  running demos?
11:26:02 <conal> roconnor: yeah, probably
11:26:19 <roconnor> conal: nope, done nothing with checking wxWidgets
11:26:27 <roconnor> other than update-alternatives
11:26:51 <conal> roconnor: better confirm wxWidgets first.  do you know how?
11:27:03 <conal> there was something in the wxHaskell build directions
11:27:06 <roconnor> nope
11:27:45 <conal> roconnor: see http://wxhaskell.sourceforge.net/building.html, under building wxWidgets
11:27:46 <lambdabot> Title: wxHaskell - Building
11:28:30 <axm> @hoogle a -> (a -> b) -> Maybe b
11:28:31 <lambdabot> Data.Generics.Twins.gzip :: (a -> b -> Maybe b) -> a -> b -> Maybe b
11:28:34 * conal is insanely delighted to be irc'ing in emacs.
11:28:55 <axm> @hoogle (a -> b) -> a -> Maybe b
11:28:56 <lambdabot> Data.Generics.Twins.gzip :: (a -> b -> Maybe b) -> a -> b -> Maybe b
11:29:04 <roconnor> I installed wxWidgets from Ubuntu
11:29:13 * ricky_clarkson is insanely insane to be ircing in firefox.
11:29:15 <EvilTerran> axm, what behaviour do you want?
11:29:22 <EvilTerran> @djinn (a -> b) -> a -> Maybe b
11:29:23 <lambdabot> f a b = Just (a b)
11:29:30 <axm> don't know yet, just fooling around
11:29:32 <conal> roconnor: oh, sure.  how about trying samples/controls, as in the wxHaskell build directions?
11:29:48 <EvilTerran> i agree with djinn; there doesn't seem to me to be any other implementation of that type.
11:30:21 <conal> ricky_clarkson: irc in firefox -- how?
11:30:29 <ricky_clarkson> chatzilla.
11:30:30 <roconnor> samples/controls isn't in the wxHaskell directories I believe
11:30:50 <conal> roconnor: right.  in wxWidgets
11:31:01 <roconnor> I don't have the sources for wxWidgets
11:31:46 <conal> roconnor: oh -- drag
11:31:59 <roconnor> I have somthing called wxvlc
11:32:12 <roconnor> it seems to play movies fine for whatever that's worth
11:32:26 <roconnor> wx-config --version works fine
11:32:46 <axm> EvilTerran, declaring a function that passes function application through monads just felt as if it would be already defined
11:32:52 <roconnor> oh, wxvlc is just a link to vlc
11:33:07 <EvilTerran> axm, er, (return .)?
11:33:13 <axm> hm
11:33:13 <EvilTerran> ?type (return .)
11:33:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
11:33:30 <conal> roconnor: wish i knew what to suggest. how about a plea to wxhaskell-users@lists.sourceforge.net
11:33:32 <EvilTerran> ?type (Just .)
11:33:33 <lambdabot> forall b a. (a -> b) -> a -> Maybe b
11:33:42 <EvilTerran> @src Maybe return
11:33:42 <lambdabot> return              = Just
11:33:54 <axm> still unsused to that stuff, thx
11:34:48 <roconnor> maybe I should indeed just use gtk2hs
11:34:59 <roconnor> ... I was looking forward to trying phooey though.
11:35:03 <EvilTerran> wxhaskell's dead in the water, AFAICT
11:35:36 <conal> roconnor: i'm having the same temptation. too bad, as wxhaskell is pretty elegant.  i really like daan's designs.
11:35:39 <EvilTerran> (that's not to say that the most recent build shouldn't work, but it's not a particularly /recent/ recent build)
11:36:13 <conal> i'd love to get help porting phooey over to gtk2hs. maybe i'll switch altogether.
11:36:30 <EvilTerran> conal, roconnor, one/other/both of you could try to get involved in keeping wxHaskell maintained...
11:37:01 <conal> EvilTerran: yep.
11:37:37 <roconnor> EvilTerran: would that involve me knowing something about wxWidgets?
11:37:42 * EvilTerran would, too, but is mostly a 'doze user, and there's all sorts of fun and games(*) involved in getting these things working on windows
11:37:49 <EvilTerran> (*) neither fun, nor games
11:38:04 <roconnor> EvilTerran: isn't the whole point of wx to be cross-platform?
11:38:29 <roconnor> Windows users would have even more incentive as presumably gtk won't work for windows.
11:38:42 <conal> roconnor: it won't?!
11:38:53 <roconnor> well, I don't know anything about gtk
11:39:08 <roconnor> I assumed it was some sort of cross between gnome and kde
11:39:08 <EvilTerran> roconnor, yes, but i at least have had a lot of trouble getting haskell bindings -- for libraries that work in windows -- working in windows
11:39:22 <EvilTerran> ghc works, the library works, but they refuse to talk to each other.
11:39:37 <roconnor> EvilTerran: what do you use for GUI development?
11:40:16 <EvilTerran> i alternate between prodding random things in vain attempts to get them working, and wallowing in despair.
11:40:43 <EvilTerran> when i get fed up with those options, i do something in Perl/Tk in a vain attempt to restore my sanity.
11:41:00 * EvilTerran twitches
11:41:01 <roconnor> EvilTerran: where does haskell fit in?
11:41:11 <EvilTerran> in the prodding random things bit, mostly
11:41:20 <roconnor> hmm
11:41:29 <conal> i have troubles, too, with haskell & windows, but i do get it mostly working, including wxHaskell.
11:41:38 <roconnor> I think I have a new theory as to why large applications aren't written in haskell.
11:41:52 <roconnor> conal: you have wxHaskell working?
11:42:00 <monochrom> what is the new theory?
11:42:09 <roconnor> monochrom: no way to program a GUI.
11:42:19 <roconnor> in windows
11:42:25 <roconnor> :)
11:42:32 <EvilTerran> my current theory is "the process of getting a new library working is either very difficult, poorly documented, or the documentation is very easy to overlook"
11:42:55 <EvilTerran> on windows, that is
11:43:17 <EvilTerran> the cabal installer barfs, and when you ask why, the answer is "you need to run autoconf first"
11:43:34 <roconnor> ``The UNIQ210f20f733c155aa-hask25ac64f17dbc3cd000000007 type is a (data-driven) source of time-varying values. By using Source Int instead of Int for the type of a and b above, we do not have to rebuild the GUI every time an input value changes.
11:43:36 <ricky_clarkson> roconnor: Perhaps Haskell discourages large programs, and encourages composition of programs instead.  Or not.
11:43:37 <roconnor> WTF?
11:44:10 <roconnor> ricky_clarkson: presumably we should eventually be able to compose small programs into large ones.
11:44:53 <ricky_clarkson> roconnor: You could argue that a hello world program is such a beast, based on all the layers below it.
11:45:02 <conal> roconnor: was the last question (wtf?) directed to me?
11:45:21 <roconnor> my WTF? was directed at The UNIQ210f20f733c155aa-hask25ac64f17dbc3cd000000007 type
11:45:40 <EvilTerran> wait, that's not even a valid type name! hyphens aren't valid!
11:46:00 <monochrom> It says you need an IQ of 210f20f733c155aa to understand it.
11:46:08 <conal> i had the same question when i saw it.  gee -- it's really in the text.  i'll fix it.  no idea how that got there.
11:46:24 <monochrom> You also need 25ac64f17dbc3cd000000007 Olegs, that's what the second part means.
11:46:29 <roconnor> I would fix it except I have no idea what it is supposed to be
11:46:45 <roconnor> copying error from the old wiki?
11:47:25 <conal> roconnor: i guess it was a markup error. fixed now
11:47:27 <monochrom> Indeed, "UNIQ..." = "U Need IQ ..." XD
11:48:56 <roconnor> conal: this data driven stuff reminds me of STM a bit.
11:49:12 <conal> roconnor: yeah?
11:49:29 <roconnor> atomic blocks are only rerun when the data the read from changes.
11:50:06 <roconnor> of course it isn't the same
11:51:03 <oerjan> > (0x210f20f733c155aa,0x25ac64f17dbc3cd000000007)
11:51:05 <lambdabot>  (2382158973999601066,11659357295737275903803129863)
11:51:34 <conal> roconnor: i hadn't made that connection.  thanks.
11:51:37 <oerjan> > (0x210f20f733c155aa,0x25ac64f17dbc3cd000000007)::(Double,Double)
11:51:39 <lambdabot>  (2.382158973999601e18,1.1659357295737275e28)
11:52:03 <yetAnotherOne> is it possible to use UDP?
11:55:57 <monochrom> It's likely that Network.Socket with socket type Datagram is UDP.
11:56:44 <yetAnotherOne> aha, searched a bit for udp, but never looked really through network.socket?
11:56:47 <yetAnotherOne> *.
11:56:59 <yetAnotherOne> thanks
11:59:42 <oerjan> @users
11:59:43 <lambdabot> Maximum users seen in #haskell: 407, currently: 395 (97.1%), active: 9 (2.3%)
12:02:12 <EvilTerran> we were over 400 again earlier today
12:12:21 <roconnor> wow O(n*ack^(-1)(n)) is even better than O(n*log n)
12:12:34 <mrd> one would hope
12:12:46 <mrd> looking at union find?
12:13:41 <roconnor> common ancestor finding in graphs
12:13:51 <roconnor> maybe that is the same thing
12:13:52 <mrd> sounds like union find
12:13:58 <quicksilver> roconnor: but that's of largely academic interest since log n is in practice negligible :)
12:14:04 <olsner> inverse ackerman?
12:14:09 <mrd> yep
12:14:26 <roconnor> quicksilver: and I thought log(n) was practically constant
12:14:33 <quicksilver> roconnor: that's what I mean
12:14:44 <quicksilver> roconnor: i.e. negligible as a multiplicative term
12:14:52 <roconnor> ack^(-1)(n) makes log(n) look like an exponential function.
12:14:57 <olsner> so, really it's like O(n) for problems that fit in our universe?
12:15:32 <quicksilver> olsner: O(n * log n) is basically bounded above by O(32*n)
12:15:36 <quicksilver> olsner: for practical programs
12:15:43 <oerjan> problems that fit in our universe may be O(1) anyway :)
12:15:58 <quicksilver> olsner: so it's really O(n) and only the constant factors differentiate O(n) and O(n log n) algorithms
12:16:11 <roconnor> O(64*n)
12:16:15 <quicksilver> i.e. a good O(n log n) algorithm may easily be much faster than O(n)
12:16:18 * mrd wants a 'rm' which deletes data by sending it down a black hole
12:16:38 <roconnor> mrd: black holes don't destroy information.
12:16:44 <glen_quagmire> :t liftM
12:16:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:16:52 <mrd> roconnor: i'm ok if it appears 3 trillion years later
12:16:56 <gnomnain> :t blackHole
12:16:58 <lambdabot> Not in scope: `blackHole'
12:17:10 <olsner> for a fixed upper bound on problem size, every algorithm is O(1), I guess
12:17:15 <roconnor> Perfect! A monad is like a black hole.
12:17:22 <glen_quagmire> :i liftM
12:17:27 <mrd> also, it's still speculation about what happens to information in a black hole anyhow
12:17:31 <glen_quagmire> :info liftM
12:17:48 <oerjan> glen_quagmire: :info is not in lambdabot, only ghci
12:17:50 <roconnor> mrd: true, but I think it is only resonable that information is preserved.
12:17:54 <oerjan> @src liftM
12:17:55 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:18:11 <roconnor> mrd: of course I used to think it is only reasonable that water, etc is infinitely divisable
12:18:18 <mrd> in the 18th century it was reasonable to expect the speed of light to vary depending on your motion
12:18:18 <roconnor> ... stupid atoms
12:18:24 <quicksilver> I think if there is one thing black hole's aren't, it's "Reasonable"
12:18:27 <glen_quagmire> oerjan: how can I find where liftM is defined? @index?
12:18:35 <glen_quagmire> @index liftM
12:18:35 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:18:46 <quicksilver> even neutron stars are unreasonable. And black holes are smaller than that.
12:19:06 <glen_quagmire> oh nice lambda bot now takes pm
12:19:28 <olsner> hasn't it always?
12:19:30 <dons> glen_quagmire: always has :)
12:19:30 <mrd> yes
12:19:32 <roconnor> glen_quagmire: I think lambdabot pm's with any registered user
12:19:53 <quicksilver> lambdabot always used to have registered user protection turned off
12:19:54 <dons> yeah, you must be identified on freenode for it to work, and lambdabot too
12:20:00 <glen_quagmire> oh maybe i wasn't identified when i tried last time
12:20:00 <quicksilver> didn't it?
12:20:04 <mrd> oh perhaps thats why it ignores me sometimes
12:20:11 <dons> we tried, sometimes freenode plays funny games
12:20:13 <mrd> i just figure she's moody
12:20:14 * quicksilver nods
12:20:23 <quicksilver> I have registered user protection turned off, myself
12:20:31 <olsner> I've never seen any kind of uncooperation from lambdabot
12:20:49 <oerjan> olsner: you haven't tried @src much, have you? :D
12:21:15 <olsner> not a lot, no... @type is often much more interesting
12:21:19 <olsner> and @pl
12:21:20 <monochrom> @src of inspiration
12:21:21 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:21:32 <roconnor> @vixen do you like glen_quagmire?
12:21:32 <lambdabot> yah, i like
12:21:34 <oerjan>  @pl isn't always optimal either
12:21:36 <mrd> @. djinn type id
12:21:38 <lambdabot> f a = a
12:21:39 <roconnor> glen_quagmire: she likes you
12:21:51 <glen_quagmire> lambdabot: asl
12:22:01 <roconnor> @vixen asl
12:22:01 <lambdabot> 19/f/California
12:22:04 <oerjan> @. type seq
12:22:05 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "seq"
12:22:12 <oerjan> @. djinn type seq
12:22:14 <lambdabot> f _ a = a
12:22:38 <quicksilver> who needs src when you have @. djinn type ?
12:22:57 <mrd> @. djinn type foldr
12:22:59 <lambdabot> f _ a _ = a
12:23:53 <mrd> sometimes the least is not enough
12:24:58 <gnomnain> @. djinn type uncurry
12:25:00 <lambdabot> f a (b, c) = a b c
12:26:12 <EvilTerran> @. pl . djinn type uncurry
12:26:14 <lambdabot> f = (`ap` snd) . (. fst)
12:26:37 <EvilTerran> @. pl . djinn type seq
12:26:39 <lambdabot> f = const id
12:31:22 <gpi5> > readFloat "-13"
12:31:23 <lambdabot>  []
12:31:28 <gpi5> > readFloat "13"
12:31:30 <lambdabot>  [(13.0,"")]
12:33:08 <oerjan> right, it doesn't do signs :(
12:34:38 <oerjan> > lex "-13"
12:34:39 <gpi5> :)
12:34:40 <lambdabot>  [("-","13")]
12:37:05 <oerjan> > let rsF s = (do ("-",r) <- lex s; liftM (first negate) (readFloat r)) ++ readFloat s in map rfS ["-13","13"]
12:37:06 <lambdabot>   Not in scope: `rfS'
12:37:17 <oerjan> > let rsF s = (do ("-",r) <- lex s; liftM (first negate) (readFloat r)) ++ readFloat s in map rsF ["-13","13"]
12:37:19 <lambdabot>  [[(-13.0,"")],[(13.0,"")]]
12:37:44 <oerjan> > readFloat " 13"
12:37:46 <lambdabot>  [(13.0,"")]
12:37:55 <oerjan> > lex " 13"
12:37:56 <lambdabot>  [("13","")]
12:40:36 <oerjan> > let rsF = runStateT ((do "-" <- StateT . lex; liftM negate . StateT . readFloat) `mplus` StateT . readFloat) in map rsF ["-13","13"]
12:40:37 <lambdabot>      precedence parsing error
12:40:38 <lambdabot>         cannot mix `mplus' [infixl 9] and `(.)'...
12:40:52 <oerjan> > let rsF = runStateT ((do "-" <- StateT . lex; liftM negate . StateT . readFloat) `mplus` (StateT . readFloat)) in map rsF ["-13","13"]
12:40:53 <lambdabot>  Couldn't match expected type `s -> m (a, s)'
12:48:56 <oerjan> > let rsF = runStateT ((do "-" <- StateT lex; negate `liftM` StateT readFloat) `mplus` StateT readFloat) in map rsF ["-13","13"]
12:48:58 <lambdabot>  [[(-13.0,"")],[(13.0,"")]]
12:50:04 <glen_quagmire> :t (\_ ->)
12:50:06 <lambdabot> parse error on input `)'
12:50:15 <glen_quagmire> is that an incomplete lambda?
12:50:26 <oerjan> you need an expression to the right of ->
12:50:50 <EvilTerran> you can't section (->) (yet...)
12:50:55 <glen_quagmire> it says every expr2 in do block is translated into expr2 >>= \_ ->
12:51:23 <roconnor> that doesn't sound quite right
12:51:31 <roconnor> oh wait
12:51:32 <oerjan> yes, but the remainder of the do block is put after the ->
12:51:36 <roconnor> that is right
12:51:56 <oerjan> and it does not include the last one
12:52:14 <EvilTerran> do { foo; bar } = (foo >>= \_ -> bar)
12:52:14 <oerjan> also, it should really be expr2 >>
12:52:22 <EvilTerran> = foo >> bar
12:52:25 <oerjan> (according to the report)
12:52:35 <roconnor> oerjan: oooh
12:53:21 <oerjan> which are equivalent for a real monad, but not guaranteed by the class definition of course
12:54:04 <EvilTerran> can you define (>>) seperately?
12:54:09 <EvilTerran> @src Monad
12:54:09 <lambdabot> class  Monad m  where
12:54:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:54:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:54:10 <lambdabot>     return      :: a -> m a
12:54:10 <lambdabot>     fail        :: String -> m a
12:54:13 <oerjan> because although >> has a default, it is a method that can be overridden
12:54:15 <EvilTerran> hm. apparently.
12:54:27 <roconnor> oerjan: of course they may still have different operational properties... although haskell doesn't have operational semantics.
12:54:45 <roconnor> er, that last msg was for the whole channel
13:26:39 <phobes> Does GHC not count as an operational semantics?  :)
13:29:37 <monochrom> not standardized by a committee
13:29:57 <mrd> phobes: do you want to do proofs with it?
13:31:28 <monochrom> My colleague is compiling his proof search engine by GHC, to perform multi-threaded, multi-core proof search.
13:31:39 <monochrom> IOW he is doing proofs "with" it. :)
13:33:39 <mrd> I should have stated proofs about meta-theorems
13:33:44 <mrd> stated:
13:33:54 <mrd> anyhow! that's really cool
13:34:42 <mrd> it's possible also to be less than confident in your proof-search program if you have confidence in your proof verifier
13:34:49 <phobes> mrd:  Is an operational semantics not allowed to be unweildy?
13:35:31 <mrd> phobes: it would be somewhat useless if no one wanted to use it for proofs because it was too unwieldy
13:36:40 <mrd> ideally, of course, the proof that of normalisation, say, for your language happens to correspond to the program for an interpreter (via C-H)
13:40:37 <Qerub> I'm doing an assignment in a uni. course in Haskell and have a question about one on the first tasks: Is there any way to make http://hpaste.org/2709 more elegant/Haskellish?
13:40:56 <Qerub> s/on the first/of the first/
13:41:55 <mrd> pattern match instead of head/tail
13:42:44 <mrd> use  the Maybe monad
13:42:48 <Qerub> So pattern => (p:ps)?
13:42:51 <mrd> yea
13:43:15 <Qerub> What should I name p and ps to make sense then?
13:43:21 <mrd> that works
13:43:51 <monochrom> the_first_guy_in_the_list : the_other_girls_in_the_list
13:43:57 <mrd> I see you are checking "isJust" of a result before using it.  the Maybe monad will capture that "pattern" for you.
13:46:21 <mrd> what is mmap?
13:46:26 <EvilTerran> @index mmpa
13:46:26 <lambdabot> bzzt
13:46:28 <EvilTerran> @index mmap
13:46:29 <lambdabot> bzzt
13:46:47 <twanvl> I would guess 'maybe map', aka. fmap for Maybe
13:46:53 <EvilTerran> hm. seems likely.
13:46:55 <mrd> yea
13:47:05 <EvilTerran> i thought i'd seen a function by that name somewhere else...
13:47:11 <Qerub> I use isJust there because I thought the code would read nice with the matches function.
13:47:14 <oerjan> :t mapM
13:47:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:47:22 <shachaf> @ty mapMaybe
13:47:24 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
13:47:32 * EvilTerran was probably getting confused between the names of mplus, fmap, and mapM
13:47:34 <monochrom> http://www.opengroup.org/onlinepubs/000095399/functions/mmap.html
13:47:35 <lambdabot> Title: mmap
13:47:37 <Qerub> Here's mmap: http://hpaste.org/2710
13:47:55 <EvilTerran> and so invented some frankenstein's monster of a function name ;]
13:48:03 <mrd> Qerub: it is potentially doing work twice though
13:48:04 <shachaf> That's called mapMaybe (or fmap).
13:48:04 <EvilTerran> @src Maybe fmap
13:48:05 <lambdabot> fmap _ Nothing       = Nothing
13:48:05 <lambdabot> fmap f (Just a)      = Just (f a)
13:48:15 <mrd> yes that's fmap, Qerub
13:48:21 <oerjan> no, mapMaybe is different
13:48:38 <shachaf> Wait.
13:48:42 <shachaf> Never mind, sorry.
13:48:56 <oerjan> @src mapMaybe
13:48:57 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:49:14 <Qerub> mrd: Oh, it is? I was hoping it would only eval that part once per branch :-)
13:49:48 <mrd> Qerub: only if you let-bind it
13:50:05 <EvilTerran> Qerub, common subexpression elimination is shakey at best, in current implementations
13:50:10 <oerjan> :t catMaybes
13:50:12 <lambdabot> forall a. [Maybe a] -> [a]
13:50:15 <Qerub> mrd, EvilTerran: I see. Thanks.
13:50:21 <mrd> and arguably undesirable in some instances
13:50:26 <oerjan> mapMaybe f = catMaybes . map f
13:50:38 <EvilTerran> but, as mrd says, binding an expression to a name almost certainly ensures it'll only be run once
13:51:23 <Qerub> This mmap function was actually included with the source code skeleton :)
13:51:58 <Qerub> The page anchors on Hoogle seem brokenâ¦ :(
13:53:25 <mrd> just let-bind recursiveMatch (p:ps) and recursiveMatch ps, and then use those names, and I think you'll be fine
13:53:46 <mrd> assuming the code is correct, which i haven't really looked into
13:54:12 <Qerub> mrd: I'm pretty sure it's correct. It runs through my > 15 HUnit test assertions.
13:55:03 <moonlite> quicksilver: here?
13:55:22 <shapr> Does cabal have a field for darcs repositories?
13:58:52 <Mitar> i have a feeling that this can be written nicer:  (foldl (\x f -> f x) i fs)
13:59:14 <sjanssen> Mitar: foldl (flip ($))?
13:59:37 <Mitar> hmm, yes :-)
13:59:40 <olsner> :t flip ($)
13:59:45 <olsner> :t flip id
13:59:49 <lambdabot> forall a b. a -> (a -> b) -> b
13:59:50 <lambdabot> forall b c. b -> (b -> c) -> c
14:00:05 <Mitar> foldr ($) i fs?
14:00:18 <oerjan> just perhaps you would want flip ($!) and foldl'
14:01:20 <oerjan> or foldr ($) i . reverse, i think
14:01:51 <oerjan> according to how lazily you want to evaluate
14:02:13 <balodja> http://www.haskell.org/haskellwiki/Stack_overflow
14:02:14 <lambdabot> Title: Stack overflow - HaskellWiki
14:02:16 <balodja> main = print (length (concat [[x] | x <- [1..1000000]]))
14:02:24 <balodja> Why do this example is ok?
14:02:25 <Qerub> mrd: If you have time, I would be very happy if you could spend a few seconds looking if the logic of the function could be simpler.
14:02:38 <Mitar> thanks
14:02:56 <mrd> Qerub: ah, well i just wrote up what I think your function does, correct me if i'm wrong
14:03:12 <mrd> match '*' "ab*d" "abcd" ==> Just "c" -- correct?
14:03:13 <oerjan> balodja: length is tail recursive and the list is consumed lazily
14:03:21 <Qerub> mrd: Correct.
14:03:40 <balodja> thnks
14:04:02 <Qerub> mrd: Just for the record, the assignment is given here http://www.cs.lth.se/EDA120/assignment1/ .
14:04:03 <hpaste>  mrd annotated "match :: Eq a => a -> [a] -> [a] -> Maybe [a]" with "a shorter version" at http://hpaste.org/2709#a1
14:04:05 <lambdabot> Title: Functional Chatterbots
14:04:24 <mrd> oh except varying lengths won't work
14:04:25 <mrd> hmm
14:04:27 <Qerub> mrd: Impressive!
14:04:37 <mrd> that's because of zip
14:04:43 <EvilTerran> (concat `fmap`) ?!
14:05:34 <oerjan> :t (concat `fmap`)
14:05:37 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
14:06:04 <twanvl> why not zipWithM?
14:06:09 <mrd> :t zipWithM
14:06:11 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:06:21 <mrd> heh, because I never used it before
14:07:17 <mrd> also, i like having the function last
14:07:27 <oerjan> is zipWithM an Applicative transformer, i wonder
14:07:46 <oerjan> sort of
14:08:06 <Qerub> I don't get the "guard (p == x) >> return [] " part ATM, but I'll look it up tommorrow.
14:08:21 <EvilTerran> Qerub, note that we've run far ahead of what whoever set the question wants
14:08:55 <Qerub> Yeah, I guess - but it just got more interesting.
14:09:06 <hpaste>  twanvl annotated "match :: Eq a => a -> [a] -> [a] -> Maybe [a]" with "using zipWithM" at http://hpaste.org/2709#a2
14:09:07 <EvilTerran> Qerub, and that, if this is assessed, you should be sure to give them the answer they want, even if we've given you a better one
14:09:14 <EvilTerran> aint edumacation great!
14:09:16 <oerjan> asking #haskell to simplify code generally ends up with one line of nearly unreadably point-free code :)
14:09:39 <KatieHuber> which is educational, if not necessary exactly what was desired ;)
14:09:54 <opqdonut> yeah there is a balance to be struck :)
14:09:55 <Qerub> oerjan: And a small headache if you're unused, perhaps?
14:10:02 <oerjan> certainly :)
14:10:44 <mrd> Qerub: here i've expanded it
14:11:21 * Qerub laughs at <$>
14:11:31 <hpaste>  mrd annotated "match :: Eq a => a -> [a] -> [a] -> Maybe [a]" with "deal with varying lengths" at http://hpaste.org/2709#a3
14:11:36 <EvilTerran> perl -e 'map{s/\*/(.*?)/g;print+(shift~=/^$_\z/)[0]}shift'
14:11:57 <Qerub> It looks like the mightiest operator ever!
14:12:05 <EvilTerran> ?type ($)
14:12:07 <EvilTerran> ?type (<$>)
14:12:07 <lambdabot> forall a b. (a -> b) -> a -> b
14:12:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:12:11 <EvilTerran> *ahem*
14:12:13 <mrd> it's just fmap
14:12:16 <EvilTerran> ?type fmap
14:12:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:12:18 <EvilTerran> ?type liftM
14:12:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:12:25 <EvilTerran> take your pick
14:13:00 <mrd> Qerub: the 'guard' function tests a condition and if it fails returns 'mzero' which i now use explicitly
14:15:45 <KatieHuber> so, speaking of operators with wacky symbols, how does one go about choosing such things?
14:15:47 <hpaste>  twanvl annotated "match :: Eq a => a -> [a] -> [a] -> Maybe [a]" with "Using explicit recursion; gives a simpler solution" at http://hpaste.org/2709#a4
14:16:10 <KatieHuber> I have a couple of functions which behave a lot like and and or, so I'd like an operator for each which has an & and a | in it...
14:16:18 <twanvl> You pick what is still available, and usually they are grouped.
14:16:30 <KatieHuber> how do I know what is still available?
14:17:15 <twanvl> Look at the docs; what do your operators do?
14:17:39 <Vulpyne> It'll probably depend on what libraries you import. There aren't that many wacky operators in the prelude.
14:17:57 <KatieHuber> rComb f r0 r1 p h = f (r0 p h) (r1 p h)
14:17:58 <KatieHuber> rAnd = rComb (&&)
14:17:58 <KatieHuber> rOr = rComb (||)
14:18:07 <KatieHuber> currently I'm using `rAnd` which is kinda OK
14:19:06 <KatieHuber> the r is for "rule", which is a generic word for a specific concept ;)
14:19:19 <twanvl> You could use something like <&&> or maybe &&& (used by Control.Arrow, but you probably don't use that)
14:19:20 <KatieHuber> but the idea is that I can specify rules modularly, and combine them with these operators
14:19:36 <twanvl> Your rules look like a monad
14:19:55 <KatieHuber> uhoh, here we go again ^_^
14:19:59 <twanvl> The environment/reader monad to be precise
14:20:31 <mrd> monads in #haskell, whowudda thunk it
14:20:51 <KatieHuber> the answer to *everything* in #haskell is "hey, that's a monad!"
14:20:56 <twanvl> rComb ~= liftM2, only for two arguments instead of one
14:21:12 <oerjan> actually, isn't that just an Applicative? >:)
14:21:12 <KatieHuber> which is cool and all, I just don't understand monads yet ;)
14:21:38 <sjanssen> oerjan: Monad implies Applicative
14:21:42 <mrd> KatieHuber: sometimes its "that's an Arrow"
14:21:49 <KatieHuber> heh
14:21:56 <oerjan> sjanssen: your point being?
14:23:20 <Qerub> Thanks for the help everybody!
14:23:25 <oerjan> > liftM2 (liftM2 (&&)) (<=) (>=) 0 0
14:23:27 <lambdabot>  True
14:23:33 <oerjan> > liftM2 (liftM2 (&&)) (<=) (>=) 0 1
14:23:34 <lambdabot>  False
14:24:32 <oerjan> > liftA2 (liftA2 (&&)) (<=) (>=) 0 1
14:24:33 <lambdabot>  False
14:24:42 <sjanssen> oerjan: just that "looks like a monad" is a stronger statement than "looks like an applicative"
14:25:03 <oerjan> sjanssen: which happens to be what i meant
14:25:21 <oerjan> er, wait
14:25:33 <mrd> Qerub: note that you can turn twanvl's last example quite easily into one using mmap o.O
14:25:35 <oerjan> i meant, that function used just the Applicative structure
14:27:03 <Qerub> mrd: Yeah, I saw that :-)
14:27:27 <oerjan> @pl liftM ($)
14:27:27 <lambdabot> id
14:27:37 <oerjan> @pl liftM2 ($)
14:27:37 <lambdabot> ap
14:28:04 <thetallguy> Is everyone else getting blank pages from l-t-u?
14:28:18 <oerjan> i read it fine earlier
14:28:23 <iamabarnacle> hi all
14:28:24 <thetallguy> Hmm.
14:28:51 <iamabarnacle> has anyone here tried to do lab 3 of the caltech cs 11 exercises posted on the wiki?
14:29:08 <oerjan> seems fine now too (although no new posts)
14:29:25 <thetallguy> oerjan: thanks, must be my browser
14:30:42 <iamabarnacle> i wanted to ask something about the abstractinteger part of the exercise
14:33:49 <iamabarnacle> it says that all operations on abstractintegers must result in all succs or all preds or zero only
14:34:51 <iamabarnacle> question is: does this also mean that we may assume all abstractinteger input to be the same?
14:35:45 <oerjan> provided you don't export the actual constructors
14:35:58 <oerjan> so users cannot make ill-formed ones
14:36:16 <twanvl> iamabarnacle: (not heaving read or even heared of the assignment) I think it means you must not return a combination of both preds and succs
14:36:43 <TSC> Yes, you'd just provide "fromInteger" and not let your users use your constructors
14:37:24 <oerjan> however, of course different numbers may use preds and succs, if that's what you mean
14:37:31 <iamabarnacle> oerjan, TSC: hm...  there is no such restriction in the statement of the exercise...
14:38:05 <oerjan> well, that's just what you would do if you made it a safely usable module
14:38:58 <oerjan> it's simpler and more efficient than having to check everything
14:39:17 <iamabarnacle> twanvl: yes, i think so, too but i'm trying to see if the exercise allows me to make the assumption (to make things easier) that input consists of only preds and succs
14:39:31 <oerjan> (not that efficiency is a big deal with succ/pred based integers anyhow :) )
14:40:00 <TSC> It does say that the property is an invariant, so I think it's a safe assumption
14:40:49 <twanvl> sorry, I read "assume all abstractinteger input to be the same" as "assume all input to be the same single value", which would be kind of stupid :)
14:40:59 <iamabarnacle> oerjan: yeah, it does say something about horrible perf with factorials :)
14:41:14 <iamabarnacle> twanvl: :P
14:41:45 <iamabarnacle> sorry, if i wasn't clear :)  i was trying to be concise :P
14:42:21 <oerjan> iamabarnacle: anyway, now i've browsed the assignment, i think you can assume numbers entered are well-formed
14:42:34 <iamabarnacle> tsc: ah, is that what the exercise meant by invariant?
14:42:53 <Trixsey> Can you do character comparisons without taking case into consideration in Haskell?
14:43:04 <oerjan> you might make a valid function that checks it, like Data.Map and others do
14:43:27 <TSC> I'd read that "invariant" as you can assume it's true of input, and must ensure it's true for output
14:43:44 <oerjan> Trixsey: you can apply toUpper or toLower
14:43:57 <iamabarnacle> ok, thanks so much tsc, oerjan and twanvl :D
14:44:00 <oerjan> (from Data.Char)
14:44:00 <twanvl> ?type liftM2 (==) toLower toLower
14:44:03 <lambdabot> Char -> Bool
14:44:08 <twanvl> Nope
14:44:20 <TSC> iamabarnacle: You're welcome
14:44:23 <iamabarnacle> i was having a hard time implementing compare because i was trying to handle cases when succs and preds were mixed
14:44:32 <oerjan> twanvl: huh?
14:44:37 <Trixsey> oerjan, oh ok.. I'm doing a program to replace some chars in a string and it has to ignore case... maybe I should just define all illegal chars as both upper and lower-case in my list of forbidden chars?
14:44:40 <TSC> iamabarnacle: You could try to write a normalise function
14:44:40 <iamabarnacle> -_-;
14:44:43 <Trixsey> I'm looking for the prettiest solution kinda
14:44:56 <sorear> .
14:45:04 <iamabarnacle> tsc: yeah, i think i may have to write one later anyway
14:45:41 <twanvl> oerjan: not thinking straight
14:48:02 <RegexGuy> Hi, I'm new to Haskell... tried to evaluate something I thought was easy: mod (ceiling sqrt (10)) 3
14:48:07 <RegexGuy> spits back a host of errors
14:48:11 <Trixsey> Wrapping recursive functions to get rid of static parameters like having to add "0" as a param all the time, is that considered ugly? Is there any other way?
14:48:24 <EvilTerran> > ceiling (sqrt 10) `mod` 2
14:48:26 <DukeDave> > mod (ceiling sqrt (10)) 3
14:48:26 <lambdabot>  0
14:48:27 <lambdabot>        add an instance declaration for
14:48:27 <lambdabot>       (RealFrac (a -> a), Integral (t ...
14:48:27 <lambdabot> DukeDave: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:48:48 <oerjan> Trixsey: nah, i've seen it several places
14:48:59 <oerjan> @src foldl
14:49:00 <EvilTerran> RegexGuy, "ceiling sqrt (10)" parses as "(ceiling sqrt) (10)", not "ceiling (sqrt (10))"
14:49:00 <lambdabot> foldl f z xs = lgo z xs
14:49:00 <lambdabot>     where lgo z []     =  z
14:49:00 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:49:26 <EvilTerran> also, you don't need the brackets around the 10
14:49:27 <DukeDave> RegexGuy: We say that 'function application binds tightest'
14:49:38 <EvilTerran> DukeDave, and to the left
14:50:04 <DukeDave> That too :)
14:50:32 <RegexGuy> thanks guys!
14:51:09 <opqdonut> and is left-associative
14:55:20 <EvilTerran> ...
14:55:53 <olsner> also, it binds to the left
14:56:17 <oerjan> not to forget that it associates leftward
14:56:55 <opqdonut> ah
14:57:27 <opqdonut> btyb the department of redundant extraneous redundancy department of redundant information
14:57:56 <oerjan> in foursome quadruplicate
14:58:20 <RegexGuy> ok, so I'm still a bit lost. Why does this one fail? It's got all the parens. If I leave out the guard it runs. But I want the guard.
14:58:20 <RegexGuy> import Monad
14:58:20 <RegexGuy> flist num =
14:58:20 <RegexGuy>     do
14:58:20 <RegexGuy>         i <- [2..ceiling(sqrt(num))]
14:58:21 <RegexGuy>         guard(num `mod` i == 0)
14:58:23 <RegexGuy>         return i
14:58:28 <beelsebob> does anyone know what wiki engine Haskell.org uses?
14:58:39 <oerjan> beelsebob: Mediawiki
14:58:44 <beelsebob> ah, cool
14:59:15 <olsner> > 1 `mod` 3 == 0
14:59:16 <lambdabot>  False
14:59:53 <RegexGuy> It's not that it gives the wrong answer -- it does not compile..
14:59:53 <RegexGuy> flist 10
14:59:53 <RegexGuy> in hugs produces "Ambiguous type variable" errors
15:00:11 <EvilTerran> > [i | i <- [2..ceiling(sqrt(num))], 100 `mod` i == 0]
15:00:12 <lambdabot>   Not in scope: `num'
15:00:14 <olsner> > (\num -> [i | i <- [2 .. ceiling (sqrt num)], num `mod` i == 0]) 7
15:00:14 <lambdabot>  Add a type signature
15:00:19 <opqdonut> yep
15:00:22 <oerjan> :t ceiling
15:00:24 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:00:28 <EvilTerran> > (\num -> [i | i <- [2..ceiling(sqrt(num))], num `mod` i == 0]) 100
15:00:29 <lambdabot>  Add a type signature
15:00:35 <EvilTerran> > (\num -> [i | i <- [2..ceiling(sqrt(num))], num `mod` i == 0]) (100::Int)
15:00:36 <lambdabot>   add an instance declaration for (Floating Int)
15:00:43 <opqdonut> :)))
15:00:43 <EvilTerran> > (\num -> [i | i <- [2..ceiling(sqrt(num))], num `mod` i == 0]) (100::Float)
15:00:44 <lambdabot>   add an instance declaration for (Integral Float)
15:00:46 <oerjan> ah, right
15:00:47 <EvilTerran> oh, sod it
15:00:53 <opqdonut> :t ceiling
15:00:55 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:00:57 <opqdonut> :t sqrt
15:01:00 <lambdabot> forall a. (Floating a) => a -> a
15:01:02 <EvilTerran> yeah
15:01:15 <opqdonut> :t ceiling . sqrt
15:01:15 <oerjan> you are using num both as an integer (in mod) and as a float (in sqrt)
15:01:17 <lambdabot> forall b a. (RealFrac a, Integral b, Floating a) => a -> b
15:01:18 <EvilTerran> RegexGuy, the problem is, you can't take the sqrt of something of an integral type
15:01:21 <iamabarnacle> gtg, thanks again guys!  :)
15:01:29 <EvilTerran> and you can't take the modulus of something of a fractional type
15:01:31 <monochrom> @quote fromIntegral
15:01:31 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
15:01:42 <Trixsey> oerjan, how would you do if you had a set of characters you wanted to highlight, regardless of case? Would you add both upper- and lowercase characters to a char list/string and then look through the string where you want matches highlight?
15:01:49 <Trixsey> highlighted
15:01:59 <Trixsey> I have a working solution but it's ugly
15:02:09 <Trixsey> I'm storing all upper AND lowercase chars in a string
15:02:19 <Trixsey> feels like a waste to store AaBbCc etc.. you know what I mean
15:02:50 <EvilTerran> > (\num -> filter (\i -> num `mod` i == 0) $ takeWhile (\i -> i^2 <= num) [2..]) (100::Float)
15:02:51 <lambdabot>   add an instance declaration for (Integral Float)
15:02:55 <EvilTerran> > (\num -> filter (\i -> num `mod` i == 0) $ takeWhile (\i -> i^2 <= num) [2..]) 100
15:02:58 <lambdabot>  [2,4,5,10]
15:03:04 <opqdonut> [toUpper, id] `ap` "abcde"
15:03:10 <opqdonut> > [toUpper, id] `ap` "abcde"
15:03:12 <lambdabot>  "ABCDEabcde"
15:03:18 <opqdonut> ^ Trixsey you want that
15:03:20 <opqdonut> probably
15:03:21 <Trixsey> ohhh
15:03:22 <Trixsey> great
15:03:37 <opqdonut> or less idiomatically:
15:03:37 <Trixsey> whats the ap function?
15:03:51 <opqdonut> > (\l -> l ++ map toUpper l) "abcde"
15:03:53 <lambdabot>  "abcdeABCDE"
15:04:01 <EvilTerran> RegexGuy, i'd suggest (takeWhile (\i -> i^2 <= num) [2..]) over [2...ceiling (sqrt num)]
15:04:06 <olsner> or [toUpper, toLower] if the input string can be mix-case
15:04:13 <opqdonut> olsner: good point!
15:04:36 <EvilTerran> RegexGuy, it gets 'round the issue of converting between integral and fractional types
15:04:55 <Trixsey> [toUpper, toLower] `ap` "AbC"
15:04:59 <Trixsey> oh oops
15:05:04 <Trixsey> > [toUpper, toLower] `ap` "AbC"
15:05:06 <lambdabot>  "ABCabc"
15:05:10 <Trixsey> perfect
15:05:11 <hpaste>  delroth pasted "test" at http://hpaste.org/2711
15:05:13 <EvilTerran> RegexGuy, not to mention using fractional types to solve integer-only problems is asking for rounding issues
15:05:48 <olsner> huh, delroth isn't even in here
15:06:05 <EvilTerran> o/` spam spam spam spam spam LOVELY SPAM WONDERFUL SPAM o/`
15:06:06 <opqdonut> huh indeed
15:06:22 <DukeDave> While we're in the Fractional ball park: Do we not have a standard function for rounding to a certain number of decimal places?
15:06:58 <oerjan> DukeDave: i vaguely recall the answer being no
15:07:12 <opqdonut> isn't that in the realm of formatted output mostly?
15:07:25 <opqdonut> one rarely wants to do that otherwise
15:07:32 <oerjan> for output you can use printf
15:07:49 <opqdonut> yep
15:07:56 <DukeDave> Erm,
15:08:05 * DukeDave hoogles printf
15:08:05 <oerjan> > printf "%.4f" pi :: String
15:08:07 <lambdabot>  "3.1416"
15:08:11 <EvilTerran> DukeDave, show[EFG]Float, if you want to convert to a string
15:08:24 <DukeDave> Wow, we have a printf :)
15:08:33 <EvilTerran> otherwise you have to do it with multiplication,truncate,and division
15:08:38 <mrd> it's also an sprintf
15:08:44 <opqdonut> EvilTerran: well of course it's doable :)
15:08:46 <olsner> :t printf
15:08:47 <lambdabot> forall r. (PrintfType r) => String -> r
15:08:56 <oerjan> :t showEFloat
15:08:58 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
15:09:12 <EvilTerran> > showFFloat pi (Just 3)
15:09:13 <lambdabot>        add an instance declaration for (Floating (Maybe Int))
15:09:17 <mrd> > showEFloat (Just 2) (1/3) ""
15:09:18 <lambdabot>  "3.33e-1"
15:09:20 <olsner> 'tis cool, the n-argument trick...
15:09:24 <mrd> > showFFloat (Just 2) (1/3) ""
15:09:25 <lambdabot>  "0.33"
15:09:29 <EvilTerran> > showFFloat (Just 3) pi ""
15:09:30 <lambdabot>  "3.142"
15:09:37 <opqdonut> > approxRational 0.1 pi
15:09:38 <lambdabot>  0%1
15:09:42 <opqdonut> > approxRational 0.001 pi
15:09:44 <lambdabot>  0%1
15:09:46 <mrd> other way
15:09:49 <opqdonut> ah
15:09:52 <opqdonut> > approxRational pi 0.001
15:09:54 <lambdabot>  201%64
15:09:58 <opqdonut> that is useful also
15:10:14 <EvilTerran> showEFloat is exponential notation, showFFloat is standard decimal notation, and showGFloat picks, depending on the magnatude
15:10:35 <DukeDave> These are useful tools, cheers :)
15:10:45 <EvilTerran> 't's like printf "%[efg]" in that respect
15:10:52 <oerjan> @index showEFloat
15:10:53 <lambdabot> Numeric
15:10:55 <mrd> see Numeric and Text.Printf
15:11:00 <ddarius> DukeDave: Incidentally, printf is also sprintf.
15:11:30 <ddarius> And this is all type safe even with runtime generated format specifiers.
15:12:03 <mrd> > printf "%d" "a" :: String
15:12:04 <lambdabot>  Exception: Printf.printf: bad argument
15:13:52 <mrd> though it has puzzled me why there isn't a generic %spec which just works on anything Show-able
15:13:52 <EvilTerran> ddarius, it's typesafe, but surely it can still fail at runtime?
15:14:22 <EvilTerran> mrd, printf "...%s..." ... (show foo)... not good enough for ya?
15:14:30 <mrd> yea it's annoying
15:14:36 <EvilTerran> meh
15:14:41 <oerjan> mrd: you cannot dispatch on a typeclass that way, i think
15:14:47 <DukeDave> :t printf
15:14:49 <lambdabot> forall r. (PrintfType r) => String -> r
15:14:58 <mrd> probably could with incoherant instances=)
15:15:01 <DukeDave> That type, isn't it a little, odd?
15:15:10 <mrd> just a little =)
15:15:29 <DukeDave> @src PrintfType
15:15:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:15:29 <mrd> the type is constructed "recursively"
15:15:41 <oerjan> you would need an instance Show a => WhateverPrintf'sClassIs a
15:16:09 <DukeDave> oerjan: Ah, magic, got it ;)
15:16:28 <oerjan> DukeDave: er, that wasn't actually for you :)
15:16:38 <monochrom> The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
15:17:07 <EvilTerran> oerjan, that would be overlapping instances everywhere...
15:17:30 <mrd> DukeDave: interesting things happen when you enable -fmagic!
15:17:40 <oerjan> @remember monochrom The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
15:17:41 <lambdabot> Done.
15:17:58 <opqdonut> @remember mrd interesting things happen when you enable -fmagic!
15:17:58 <lambdabot> Done.
15:18:00 <mrd> the zeroth law: Must protect programmer-kind?
15:18:02 <opqdonut> @quote -f
15:18:03 <lambdabot> cjeris says: i have a little perl script that aliases gcc -freduced-suckage to ghc
15:18:07 <opqdonut> @quote -f
15:18:08 <lambdabot> ghc says: accepting non-standard pattern guards (-fglasgow-exts to suppress this message)
15:18:16 <opqdonut> @quote -f
15:18:17 <lambdabot> cjeris says: i have a little perl script that aliases gcc -freduced-suckage to ghc
15:18:33 <sorear> @quote -f
15:18:33 <lambdabot> ghc says: Use -fglasgow-exts to allow multi-parameter classes
15:19:15 <monochrom> Haskell: Referentially Transparent, Monadic, and Three-Law Safe.
15:19:39 <opqdonut> @quote law
15:19:40 <lambdabot> Adamant says: Godwin's Law of Programming Debates - Hitler = ASM
15:19:42 <opqdonut> @quote law
15:19:43 <lambdabot> Adamant says: Godwin's Law of Programming Debates - Hitler = ASM
15:19:47 <opqdonut> duh
15:19:52 <opqdonut> @quote [lL]aw
15:19:52 <ddarius> No rampaging compilers here.
15:19:53 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
15:19:57 * mrd thought the three laws of types were: determinacy, progress, and preservation
15:20:02 <opqdonut> @quote [lL]aw
15:20:02 <lambdabot> Adamant says: Godwin's Law of Programming Debates - Hitler = ASM
15:20:10 <opqdonut> ok i'll cut it off now
15:20:41 <pgavin> @seen dcoutts
15:20:42 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 5h 35m 48s ago.
15:21:30 <sorear> determinacy?  is that like uniqueness-of-types?
15:21:40 <oerjan> maybe @quote should order quotes by last time presented...
15:21:43 <RegexGuy> ok, thx
15:21:45 <sorear> @quote
15:21:45 <RegexGuy> bye
15:21:46 <lambdabot> edwardk says: notes that in haskell, it seems that you asymptotically approach writing no code over time as you learn your way around whats already there
15:21:49 <sorear> @quote
15:21:50 <lambdabot> syntaxfree says: "You can't catch me / I'm syntax free / I'm preconceived / preternaturally"
15:21:53 <sorear> @quote
15:21:53 <lambdabot> vincenz says: then you call 1-800-GET_DONS
15:21:54 <mrd> yea i was just thinking that doesn't really belong there
15:21:56 <sorear> @quote
15:21:57 <lambdabot> xDie says: sampabolla
15:23:09 <oerjan> sorear: i was thinking of the axiom of determinacy, which _really_ doesn't belong there
15:32:41 <Trixsey> else a: []
15:32:49 <Trixsey> Why would someone add ": []"?
15:32:53 <Trixsey> In case a is empty?
15:32:59 <Trixsey> So it's not null?
15:33:24 <olsner> a:[] is the same as [a]
15:33:45 <EvilTerran> a ++ [] would be a O(n) no-op, but that's not that
15:33:46 <Trixsey> olsner, oh, an Ord-type list?
15:33:54 <EvilTerran> o.Ã³
15:34:38 <olsner> Ord-type?
15:34:40 <LoganCapaldo> Ord isn't a type. Ord is a type class. and a:[] is the same as [a] for all lists
15:34:53 <Saizan> Trixsey: a : [] is contructing a list of the single element a
15:35:11 <Saizan> > 1 : []
15:35:13 <lambdabot>  [1]
15:35:19 <Saizan> > 0 : 1 : []
15:35:20 <lambdabot>  [0,1]
15:35:20 <Trixsey> Saizan, oh ok
15:35:32 <LoganCapaldo> even for (GobbleMonkey a) => [a] a : [] == [a]
15:35:53 <Saizan> ?src []
15:35:53 <lambdabot> data [] a = [] | a : [a]
15:35:56 <Trixsey> forvandla x = x: 'o' :x: []
15:35:58 <Trixsey> So in this case
15:36:05 <Trixsey> it's used to signify it's a string?
15:37:23 <Saizan> it's not to "signify" [] is the value that represent an empty list, and since lists are defined inductively every finite list has a [] at the end
15:37:38 <Frederick> folks congrats for the new docs they are MUCH better thab the last time I checked it an year ago
15:37:48 <ddarius> Trixsey: This may or may not help, but that is equivalent to forvandla x = [x,'o',x]
15:38:33 <DukeDave> Am I correct in thinking all constructors for a type have to be given at one time?
15:38:44 <ddarius> "given"?
15:38:53 <LoganCapaldo> I think he means in a single declaration
15:38:57 <opqdonut> yeah
15:39:14 <LoganCapaldo> ie not data [] = [] ; data [] = a : [a]
15:39:21 <LoganCapaldo> err
15:39:30 <DukeDave> LoganCapaldo: Yeah something like that :)
15:39:33 <LoganCapaldo> why did I pick sucha  sugary example
15:39:44 <opqdonut> :P
15:39:58 <ddarius> DukeDave: Yes, they do... though exceptions are growing (in the extensions)
15:40:20 <DukeDave> I'm trying to create a system where I provide some 'base' constructors, but a user may add their own at a later date.
15:41:00 <EvilTerran> @go data types a la carte
15:41:02 <lambdabot> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
15:41:04 <opqdonut> sounds like a job for type classes
15:41:13 <EvilTerran> have a shufty at that
15:41:15 <ddarius> DukeDave: Unless this is embedded in Haskell, that should be no problem.  If it is, there are ways to handle this.
15:41:24 <ddarius> E.g. what EvilTerran referenced.
15:41:39 <DukeDave> Chees EvilTerran I'll investigate
15:41:51 <EvilTerran> mmm... cheese...
15:41:51 <DukeDave> *Cheers
15:41:53 <EvilTerran> :D
15:43:05 <DukeDave> Wow really thank you; exactly the article I was looking for!
15:43:22 <DukeDave> If I could just remember the karma command :)
15:43:26 <EvilTerran> it gets a bit hairy with the typeclasses in places, but it is rather cool
15:43:31 <DukeDave> @karma EvilTerran++
15:43:32 <lambdabot> EvilTerran++ has a karma of 0
15:43:41 <DukeDave> @karma EvilTerran
15:43:41 <lambdabot> EvilTerran has a karma of 2
15:43:45 <DukeDave> @karma EvilTerran ++
15:43:45 <lambdabot> EvilTerran has a karma of 2
15:43:58 <oerjan> DukeDave: a simple workaround might be to make the user's additions a type which is passed as a parameter of the original type
15:44:00 <EvilTerran> i think just name++ works
15:44:04 <ddarius> @karma name
15:44:04 <lambdabot> name has a karma of 1
15:44:14 <DukeDave> EvilTerran++
15:44:18 <DukeDave> @karma EvilTerran
15:44:18 <lambdabot> EvilTerran has a karma of 3
15:44:22 <DukeDave> So it does
15:44:24 <EvilTerran> awesome
15:44:56 <EvilTerran> anyway; one thing to note is that, with that system, altho adding constructors to the type afterwards is easy, adding *functions* to it is more difficult
15:44:58 <LoganCapaldo> Do you just replace every occurence of your type with a type class>
15:45:02 <LoganCapaldo> ?
15:45:31 <EvilTerran> you can't just define a new function that takes any instances of your class and does some new funk that can't be expressed in terms of the class methods
15:45:43 <LoganCapaldo> EvilTerran, Is that the "expression problem"?
15:46:19 <ddarius> EvilTerran: To add functions you'd add (sub)classes.
15:46:28 <EvilTerran> but i think having a catamorphism and an anamorphism as methods might be enough to make anything expressible
15:46:31 <oerjan> LoganCapaldo: sounds like it
15:46:41 <EvilTerran> i do not know what the expression problem is
15:46:55 <LoganCapaldo> I'm not entirely clear myself, which is why I asked :)
15:47:09 <ddarius> EvilTerran: It points at a duality in OO and FP.
15:47:20 <oerjan> it's the problem of having a datatype with functions such that you can add _both_ new values and new functions to it
15:47:24 <ddarius> @google Wadler "expression problem"
15:47:26 <lambdabot> http://www.daimi.au.dk/~madst/tool/papers/expression.txt
15:48:03 <EvilTerran> ah
15:48:36 <oerjan> and still have everything safely typed
15:48:41 <EvilTerran> i guess you've got to deal with the cartesian product of functions and values somehow
15:49:12 <EvilTerran> which means, if one person adds a function, and another person adds a value, you end up with a gap at the intersection of the two
15:49:14 <ddarius> :t uncurry ($)
15:49:16 <lambdabot> forall a b. (a -> b, a) -> b
15:49:20 <oerjan> problem is, the old functions need to be updated to work on the new values, and vice versa
15:49:26 <EvilTerran> bring on the SYB!
15:50:25 <Trixsey> ddarius, oh, it did.. I get it now.. thx =)
15:50:42 <Trixsey> ddarius, so the [] in the end is just to clarify it's an array of chars (a string) like I said?
15:50:57 <oerjan> lists are not arrays!
15:51:27 <EvilTerran> argh
15:51:28 <ddarius> Trixsey: No. [a,b,c] is syntactic sugar (expands at parse-time) to a:b:c:[].
15:51:28 <Trixsey> sorry =(
15:51:33 <EvilTerran> it's not "just to clarify"
15:51:47 <EvilTerran> x : [] is NOT x
15:51:51 <EvilTerran> ?type (\x -> x)
15:51:53 <lambdabot> forall t. t -> t
15:51:55 <EvilTerran> ?type (\x -> x : [])
15:51:57 <lambdabot> forall a. a -> [a]
15:51:58 <Trixsey> x : [] is not [x]? :(
15:52:01 <EvilTerran> ?type (\x -> [x])
15:52:02 <lambdabot> forall t. t -> [t]
15:52:19 <oerjan> Trixsey: read more carefully
15:52:23 <EvilTerran> x : [] is [x], it doesn't *clarify* the type, it *changes* the type
15:52:39 <Trixsey> EvilTerran, from char to string?
15:52:56 <Trixsey> for instance
15:52:57 <EvilTerran> yes. or, in general, from a to [a]
15:52:58 <oerjan> from whatever to list of whatever
15:53:12 <ddarius> :t (:)
15:53:14 <lambdabot> forall a. a -> [a] -> [a]
15:53:26 <sorear> maybe Trixsey has Haskell confused with ML?
15:53:35 <ddarius> Trixsey: [] is just a value.
15:53:37 <ddarius> :t []
15:53:39 <lambdabot> forall a. [a]
15:53:53 <EvilTerran> (:) takes a value on the left, a list of same-typed values on the right, and produces a new list starting with the thing on the left and followed by those on the right
15:54:01 <EvilTerran> 1 : [2,3] = [1,2,3]
15:54:02 <Trixsey> This is my first day with Haskell, be easy on me! :P
15:54:11 <Trixsey> Welcome me! :P
15:54:12 <EvilTerran> [] is the empty list
15:54:24 <EvilTerran> so 1 : [] is the list starting with 1 and followedby nothing, ie [1]
15:54:36 <EvilTerran> 1:2:[] = 1:(2:[]) = 1:[2] = [1,2]
15:54:37 <EvilTerran> etcetc
15:54:45 * EvilTerran disappears suddenly
15:55:01 <LoganCapaldo> In a poof of logic?
15:55:05 * Trixsey awaits the "Welcome to Haskell! We adore your nubness"-message
15:55:18 * ddarius eyes a large bar of Lindt dark chocolate.
15:55:26 <johnnowak> eat it all!
15:55:29 <Trixsey> ddarius, for me? :D
15:55:38 * oerjan dances the traditional haskell welcome dance
15:55:46 <Trixsey> welcoming gifts and all, I would never have thought Haskell-people were this nice :D
15:55:55 <sorear> Trixsey: We're pleased you had the courage to come here right away ;)
15:55:57 * LindtDarkChocola looks nervously at ddarius
15:56:15 <ddarius> Chocola!  That sounds like a great idea!
15:56:48 <LoganCapaldo> chocolate soda?
15:56:59 <LoganCapaldo> I'm pretty sure they have that
15:57:01 <oerjan> (the lamb(a)da, of course)
16:00:30 <ddarius> I'm pretty sure it's been done too.
16:00:54 * oerjan notes that chocola is apparently dutch for chocolate
16:03:51 <Trixsey> In haskell, is it "or", or "||"?
16:03:58 <LoganCapaldo> yes :)
16:04:01 <LoganCapaldo> @type or
16:04:06 <Trixsey> @type or
16:04:06 <lambdabot> [Bool] -> Bool
16:04:08 <lambdabot> [Bool] -> Bool
16:04:09 <LoganCapaldo> @type (||_
16:04:09 <oerjan> no :)
16:04:11 <lambdabot> parse error (possibly incorrect indentation)
16:04:12 <LoganCapaldo> @type (||)
16:04:14 <lambdabot> Bool -> Bool -> Bool
16:04:16 <oerjan> it's both
16:04:18 <TSC> || is the binary operator; "or" takes a list
16:04:19 <Trixsey> oh
16:05:01 <LoganCapaldo> @check (\a b -> or [a, b] == a || b) :: Bool -> Bool
16:05:02 <lambdabot>      The lambda expression `\ a b -> ...' has two arguments,     but its type...
16:05:09 <LoganCapaldo> @check (\a b -> or [a, b] == a || b) :: Bool -> Bool -> Bool
16:05:11 <lambdabot>  OK, passed 500 tests.
16:05:18 <LoganCapaldo> @scheck (\a b -> or [a, b] == a || b) :: Bool -> Bool -> Bool
16:05:19 <lambdabot>   Completed 4 test(s) without failure.
16:05:59 <sjanssen> @scheck (\xs -> or xs == foldr (||) False xs)
16:06:00 <lambdabot>   Completed 127 test(s) without failure.
16:06:25 <LoganCapaldo> 127 doesn't seem like enough tests...
16:06:58 <dons> for Bool?
16:07:13 <oerjan> @check \p l -> (or . map p) l == any p (l::[Int])
16:07:14 <lambdabot>  OK, passed 500 tests.
16:07:22 <LoganCapaldo> for [Bool]
16:08:01 <oerjan> scheck has a size limit
16:08:08 <oerjan> s is for small
16:08:17 <oerjan> but exhaustive
16:08:17 <LoganCapaldo> heh
16:08:32 <LoganCapaldo> @scheck (\a b -> or [a, b] == a || b) -- 4 is enough here
16:08:34 <lambdabot>   Completed 4 test(s) without failure.
16:08:40 <ari> @scheck \xs -> length (xs :: [Char]) < 7
16:08:41 <lambdabot>   Completed 1957 test(s) without failure.
16:08:54 <ari> Yay, all lists are at most six elements long!
16:09:00 <LoganCapaldo> LOL
16:09:12 <KatieHuber> o_O
16:09:16 <ddarius> Exhaustive up to the size limit.
16:09:34 <mornfall> obviously, exhaustive without limit would, well, fail to terminate
16:09:42 <oerjan> > logBase 6 1957
16:09:44 <lambdabot>  4.230014183020567
16:09:52 <oerjan> > logBase 7 1957
16:09:53 <LoganCapaldo> woah
16:09:54 <lambdabot>  3.894921854986756
16:10:09 <LoganCapaldo> that's some mighty fine mathematics
16:10:31 <ari> ... I don't get it :(
16:10:44 <oerjan> it doesn't bring me any closer to why there were 1957 cases though
16:10:50 <mornfall> oerjan: there are different numbers of lists of different lengths
16:10:55 <DukeDave> ari: Likewise, I was about to say :(
16:11:00 <mornfall> oerjan: question is, lists of -what- are exhausted
16:11:35 <oerjan> @scheck \c -> (c::Char) == c
16:11:37 <lambdabot>   Completed 7 test(s) without failure.
16:11:43 <oerjan> aha :)
16:11:48 <mornfall> lists of (), there are 7, lists of Bool, there are 128 or so
16:11:50 <ddarius> > 1957 ** (1/6)
16:11:51 <lambdabot>  3.536702023872291
16:11:54 <ddarius> > 1957 ** (1/7)
16:11:56 <lambdabot>  2.9527539612548606
16:12:09 <oerjan> > 1957/49
16:12:10 <lambdabot>  39.93877551020408
16:12:22 <oerjan> oh, wait
16:12:43 <mornfall> > 3 ^ 7
16:12:45 <lambdabot>  2187
16:12:49 <mornfall> hm, too many
16:12:59 <ddarius>  3^6
16:13:03 <ddarius> > 3^6
16:13:04 <mornfall> too few
16:13:04 <lambdabot>  729
16:13:05 <mornfall> :)
16:13:14 <mornfall> but that was the logBase experiment anyway
16:13:15 <oerjan> > [(m,sum[7^n|n <- [0..m])|m<-[0..7]]
16:13:15 <lambdabot>  Parse error
16:13:27 <oerjan> > [(m,sum[7^n|n <- [0..m]])|m<-[0..7]]
16:13:29 <lambdabot>  [(0,1),(1,8),(2,57),(3,400),(4,2801),(5,19608),(6,137257),(7,960800)]
16:14:00 <mornfall> so it's not really exhaustive i suppose
16:14:06 <ddarius> Extra Dark Chocolate!
16:14:13 <mornfall>  @scheck \xs -> length (xs :: [Char]) < 7
16:14:31 <oerjan> space
16:14:34 <mornfall> agh
16:14:37 <mornfall> @scheck \xs -> length (xs :: [Char]) < 7
16:14:39 <lambdabot>   Completed 1957 test(s) without failure.
16:14:42 <mornfall> deterministc
16:14:45 <mornfall> interesting :)
16:14:51 <mornfall> @src scheck
16:14:52 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
16:14:56 <mornfall> :\
16:15:04 <oerjan> @scheck \xs -> length (xs :: [()]) < 7
16:15:06 <lambdabot>   Completed 7 test(s) without failure.
16:15:16 <oerjan> @scheck \xs -> length (xs :: [Bool]) < 7
16:15:17 <lambdabot>   Completed 127 test(s) without failure.
16:15:22 <oerjan> @scheck \xs -> length (xs :: [Ordering]) < 7
16:15:23 <lambdabot>  add an instance declaration for (Serial Ordering)
16:15:24 <lambdabot>     In the expression: let...
16:15:36 <oerjan> @scheck \xs -> length (xs :: [Maybe Bool]) < 7
16:15:38 <lambdabot>   Completed 607 test(s) without failure.
16:15:41 <mornfall> good,  the 7 and 127 tests are understandable
16:15:55 <mornfall> now, Maybe Bool is a problem :]
16:16:15 <oerjan> > sum[3^n|n<-[0..6]]
16:16:17 <lambdabot>  1093
16:16:25 <oerjan> > sum[2^n|n<-[0..6]]
16:16:26 <lambdabot>  127
16:16:45 <oerjan> @scheck \c -> (c::Maybe Bool) == c
16:16:46 <lambdabot>   Completed 3 test(s) without failure.
16:17:08 <mornfall> wonders :)
16:17:24 <oerjan> perhaps the size involves the parts somehow
16:18:27 <oerjan> @scheck \xs -> length (xs :: [Char]) < 6
16:18:29 <lambdabot>   Failed test no. 7. Test values follow.: "aaaaaa"
16:18:50 <mornfall> @scheck \xs -> True `elem` (xs::[Bool])
16:18:52 <lambdabot>   Failed test no. 1. Test values follow.: []
16:19:00 <mornfall> oh
16:19:03 <mornfall> lame :)
16:19:45 <mornfall> @scheck \xs -> if length xs > 0 then False `elem` (xs::[Bool]) else True
16:19:46 <lambdabot>   Failed test no. 2. Test values follow.: [True]
16:19:54 <oerjan> @scheck \xs -> (xs :: [Char]) `elem` [[]]
16:19:55 <lambdabot>   Failed test no. 2. Test values follow.: "a"
16:20:08 <mornfall> @scheck \xs -> if length xs > 0 then True `elem` (xs::[Bool]) else True
16:20:10 <lambdabot>   Failed test no. 3. Test values follow.: [False]
16:20:24 <oerjan> @scheck \xs -> (xs :: [Char]) `elem` tails "aaaaaaa"
16:20:26 <lambdabot>   Failed test no. 4. Test values follow.: "b"
16:21:28 <oerjan> @scheck \xs -> all (`elem` "abcdefg") (xs :: [Char])
16:21:30 <lambdabot>   Completed 1957 test(s) without failure.
16:22:02 <mornfall>  @scheck \xs -> all (`elem` "abcdef") xs
16:22:05 <mornfall> grrr
16:22:08 <mornfall> @scheck \xs -> all (`elem` "abcdef") xs
16:22:10 <lambdabot>   Completed 1957 test(s) without failure.
16:22:18 <mornfall> @scheck \xs -> all (`elem` "abcde") xs
16:22:20 <lambdabot>   Failed test no. 1632. Test values follow.: "f"
16:22:27 <oerjan> !
16:22:27 <mornfall> interesting...
16:22:59 <oerjan> @scheck \x -> x `elem` "abcdef"
16:23:01 <lambdabot>   Failed test no. 7. Test values follow.: 'g'
16:23:04 <oerjan> @scheck \x -> x `elem` "abcdefg"
16:23:06 <lambdabot>   Completed 7 test(s) without failure.
16:23:30 <mornfall> it appears to cut at some point it deems "reasonable"
16:23:31 <mornfall> :-)
16:23:33 <oerjan> hm... it drops the size down on recursion, perhaps?
16:23:58 <oerjan> since it uses 'g' for Char only, but not [Char]
16:24:39 <mornfall> right, and it starts to use f at test 1632
16:24:45 <oerjan> > [(m,sum[6^n|n <- [0..m]])|m<-[0..7]]
16:24:47 <lambdabot>  [(0,1),(1,7),(2,43),(3,259),(4,1555),(5,9331),(6,55987),(7,335923)]
16:25:25 <oerjan> > 1632/1957
16:25:27 <lambdabot>  0.8339294839039346
16:25:34 <oerjan> > 1632%1957
16:25:36 <lambdabot>  1632%1957
16:25:46 <oerjan> > 1633%1957
16:25:48 <lambdabot>  1633%1957
16:25:51 <mornfall> > 1632 `mod` 1957
16:25:52 <lambdabot>  1632
16:25:55 <mornfall> err
16:26:06 <mornfall> that's sort of obvious ;-)
16:26:27 <mornfall> nm
16:26:33 <oerjan> > approxRational (1632/1957) 0.01
16:26:35 <lambdabot>  5%6
16:27:18 <ddarius> Just factor the thing.
16:28:24 <oerjan> > find (\n -> 1957 `mod` n == 0) [3..1956]
16:28:26 <lambdabot>  Just 19
16:28:36 <oerjan> > 1957/19
16:28:38 <lambdabot>  103.0
16:29:05 <oerjan> not tremendously enlightening
16:29:19 <ddarius> No... not really.
16:30:41 <oerjan> > sum[(7-m)^m|m<-[0..6]]
16:30:43 <lambdabot>  210
16:31:22 <oerjan> > sum[(8-m)^m|m<-[0..7]]
16:31:23 <lambdabot>  733
16:31:53 <oklopol> > "oko - fol"
16:31:55 <lambdabot>  "oko - fol"
16:32:05 <BMeph> @pl  (\ys -> ((not.null) ys)
16:32:06 <lambdabot> (line 1, column 24):
16:32:06 <mornfall> how do you get a list of all permutations?
16:32:06 <lambdabot> unexpected end of input
16:32:06 <lambdabot> expecting variable, "(", operator or ")"
16:32:07 <BMeph>                         && (((x==).head) ys)
16:32:08 <BMeph>                         && (((startsWith xs).tail) ys))
16:32:13 <oklopol> > map(\x -> x+3)"oko - fol"
16:32:14 <lambdabot>   add an instance declaration for (Num Char)
16:32:14 <lambdabot>     In the expression: x + 3
16:32:14 <lambdabot>    ...
16:32:22 <oklopol> :<
16:32:33 <ddarius> @google permutations haskell
16:32:35 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg19025.html
16:32:35 <lambdabot> Title: [Haskell] String permutation
16:32:38 <oerjan> BMeph: lambdabot only takes single lines
16:33:21 <oerjan> mornfall: it was discussed recently
16:33:27 <BMeph> Okay, thanks, oerjan.
16:33:31 * ddarius hasn't seen Tomasz Zielonka in a while...
16:33:47 <oklopol> > map(\x -> x)"oko - fol"
16:33:48 <lambdabot>  "oko - fol"
16:34:07 <oklopol> > map(\x -> [x]++"moko")"oko - fol"
16:34:08 <lambdabot>  ["omoko","kmoko","omoko"," moko","-moko"," moko","fmoko","omoko","lmoko"]
16:34:15 <oklopol> i'm so leet at this..
16:34:21 <mornfall> @yow
16:34:22 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
16:34:38 <mornfall> lambdabot doesn't love me today
16:34:47 <oerjan> not again?
16:34:52 <oklopol> can you do "o" -> num so you can make like caesar encryption
16:35:07 <ari> :t toEnum
16:35:09 <lambdabot> forall a. (Enum a) => Int -> a
16:35:19 <ari> Hmm, wrong way
16:35:23 <oklopol> > toEnum "o"
16:35:23 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
16:35:25 <oklopol> > toEnum 65
16:35:27 <lambdabot>  65
16:35:30 <oklopol> hmm...
16:35:33 <ari> > fromEnum 'o'
16:35:35 <lambdabot>  111
16:35:40 <oklopol> oh cool
16:35:43 <BMeph> :t fromEnum
16:35:45 <lambdabot> forall a. (Enum a) => a -> Int
16:36:01 <BMeph> Nice, ari. :)
16:36:10 <BMeph> @pl (\ys -> ((not.null) ys) && (((x==).head) ys) && (((startsWith xs).tail) ys))
16:36:10 <lambdabot> ap ((&&) . not . null) (ap ((&&) . (x ==) . head) (startsWith xs . tail))
16:36:44 <Boney> > map (toEnum $ 1 + fromEnum) "abc"
16:36:45 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> Int'
16:36:46 <mornfall> > map ((toEnum::Int->Char).(+3).fromEnum) "oko - fol"
16:36:48 <lambdabot>  "rnr#0#iro"
16:36:53 <oerjan> BMeph: try using and
16:37:00 <Boney> *shrug*
16:37:18 <Boney> > map (\x -> toEnum $ 1 + fromEnum x) "abc"
16:37:19 <lambdabot>  [98,99,100]
16:37:24 <oklopol> hmm... how did list comprehensions work again?
16:37:25 <oklopol> :P'
16:37:27 <Boney> > map (\x -> toEnum $ 1 + fromEnum x) "abc" :: String
16:37:28 <lambdabot>  "bcd"
16:37:28 <oerjan> and . map [(not.null) etc.
16:37:35 <ari> > fromEnum 'a'
16:37:36 <lambdabot>  97
16:37:55 <BMeph> oerjan: Okay, checking it out - thanks again. :)
16:38:10 <oerjan> er, that's a bit wrong
16:38:54 <BMeph> Just toss a ...(replicate 3) on the end, and it should work.
16:38:55 <EvilTerran> all (not.null) etc?
16:38:59 <mornfall> > map ((toEnum::Int->Char).(+97).(`mod`122).(+3).(-97).fromEnum) "oko - fol"
16:39:00 <lambdabot>   add an instance declaration for (Num (Int -> Int))
16:39:03 <oerjan> and . ap [(not.null) ...
16:39:03 <mornfall> blah
16:39:40 <oerjan> ... . return
16:39:58 <mornfall> :t ap
16:40:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:40:26 <mornfall> wee
16:40:27 <Saizan> > map ((toEnum::Int->Char).(+97).(`mod`122).(+3).(subtract 97).fromEnum) "oko - fol"
16:40:28 <lambdabot>  "rnr\157\170\157iro"
16:40:33 <oklopol> let inc x = x + 1 in (\a -> [toEnum $ inc $ fromEnum x | x <- a]) "oko-fok"
16:40:49 <mornfall> Saizan: ah right, the - fiasco :\
16:40:50 <oklopol> > let inc x = x + 1 in (\a -> [toEnum $ inc $ fromEnum x | x <- a]) "oko-fok"
16:40:51 <lambdabot>  [112,108,112,46,103,112,108]
16:40:54 <mornfall> unary -
16:40:55 <oklopol> hmm...
16:41:18 <oklopol> > toEnum 97
16:41:19 <lambdabot>  97
16:41:26 <oklopol> i don't get that...
16:41:29 <EvilTerran> toEnum::Int->Char = chr, btw.
16:41:34 <EvilTerran> ?index chr
16:41:34 <lambdabot> Data.Char
16:41:36 <Saizan> ?type toEnum
16:41:38 <lambdabot> forall a. (Enum a) => Int -> a
16:41:47 <oklopol> oh
16:41:49 <EvilTerran> > chr 97
16:41:50 <lambdabot>  'a'
16:41:53 <EvilTerran> @src chr
16:41:53 <lambdabot> Plugin `source' failed with: IRCRaised getRandItem: empty list
16:41:59 <EvilTerran> ...
16:42:04 <oklopol> > let inc x = x + 1 in (\a -> [chr $ inc $ fromEnum x | x <- a]) "oko-fok" -- ?
16:42:05 <lambdabot>  "plp.gpl"
16:42:08 <oklopol> wow
16:42:15 <oklopol> coool
16:43:05 <oklopol> > 'a'
16:43:06 <BMeph> Likewise, `ord` is fromEnum for Char.
16:43:07 <lambdabot>  'a'
16:43:10 <oklopol> > "a"
16:43:12 <lambdabot>  "a"
16:43:15 <BMeph> Go-go, BASIC skillz, lol.
16:43:17 <oerjan> oklopol: toEnum defaults to Integer if you don't tell it you want Char
16:43:29 <oklopol> i see
16:44:09 <mornfall> > "Good night world!"
16:44:10 <lambdabot>  "Good night world!"
16:44:36 <oklopol> how do you check whether a value is in a list?
16:44:44 <mornfall> `elem`
16:44:54 <oklopol> elem 2 [1..8]
16:44:55 <mornfall> :t elem
16:44:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:44:57 <oklopol> > elem 2 [1..8]
16:44:58 <lambdabot>  True
16:45:02 <oklopol> cool.
16:45:16 <mornfall> > 2 `elem` [1..8]
16:45:18 <lambdabot>  True
16:45:22 <mornfall> nicer, imho
16:45:49 <EvilTerran> > map succ "oko-fok"
16:45:50 <lambdabot>  "plp.gpl"
16:45:59 <EvilTerran> > map pred "plp.gpl"
16:46:01 <lambdabot>  "oko-fok"
16:46:24 <TSC> It's a shame lambdabot won't accept "let â = elem in 2 â [1..10]"
16:46:28 <oerjan> > map (join(.)pred) "oko-fok"
16:46:28 <BMeph> 't' `elem` "you Loved it, lambdabot!"
16:46:30 <lambdabot>  "mim+dmi"
16:46:50 <Quiet> hi
16:46:52 <oerjan> it doesn't?
16:47:03 <BMeph> Bah, you ruined my ploy, oerjan. ;p
16:47:04 <oerjan> > let (?) = elem in 2 ? [1..10]
16:47:06 <lambdabot>  True
16:47:08 <Quiet> can i ask, how can i convert an Int to a Float or a Double?
16:47:10 <BMeph> 't' `elem` "you Loved it, lambdabot!"
16:47:33 <TSC> Quiet: fromIntegral
16:47:34 <ddarius> @quote fromIntegral
16:47:34 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
16:47:38 <ddarius> Bugger.
16:47:42 <Quiet> ok, thank you
16:47:45 <TSC> > fromIntegral 3 :: Double
16:47:47 <lambdabot>  3.0
16:48:02 <ddarius> > 3 :: Double -- just to sow confusion
16:48:03 <lambdabot>  3.0
16:48:05 <oerjan> TSC: @run is H98 so it doesn't have implicit parameters, i think
16:48:08 <EvilTerran> what's with lambdabot today? she's not her usual helpful self
16:48:09 <mornfall> >  (foldr1 (.) $ take 10 $ repeat succ) 'a'
16:48:10 <lambdabot>  'k'
16:48:16 <mornfall> how do you write that nicer?
16:48:17 <oerjan> > let ?x = 1 in ?x
16:48:18 <lambdabot>  Parse error
16:48:58 <EvilTerran> > iterate succ 'a' !! 10
16:48:59 <lambdabot>  'k'
16:49:00 <dons> ?quit its that weird bug
16:49:14 <dons> ?quote fromIntegral
16:49:21 <EvilTerran> > iterate (1:) 2
16:49:21 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:49:27 <lambdabot>   add an instance declaration for (Num [t])
16:49:30 <EvilTerran> > iterate (1:) []
16:49:37 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
16:49:43 <augustss> ?dons spekas in questions
16:49:49 <lambdabot> spekas in questions not available
16:50:07 <oerjan> @quote Law
16:50:09 <mrd> ?quote quote?
16:50:11 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
16:50:13 <lambdabot> psykotic says: monochrom, i'm reminded me of that alan kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
16:50:17 <oerjan> @quote Law
16:50:17 <lambdabot> Adamant says: Godwin's Law of Programming Debates - Hitler = ASM
16:50:18 <dons> augustss is a reddit celebrity, did you see?
16:50:21 <oerjan> @quote Law
16:50:22 <lambdabot> Adamant says: Godwin's Law of Programming Debates - Hitler = ASM
16:50:26 <oerjan> @quote Law
16:50:27 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
16:50:30 <augustss> dons: no?
16:50:39 <oerjan> seems it lost the quote
16:50:45 <oklopol> > let charz = ['a'..'z']++['A'..'Z']; n=3 in map (\x -> if x `elem` charz then chr ((fromEnum x + n) `mod` length charz) else x) "testing this crapzor"
16:50:47 <lambdabot>  "\SI\NUL\SO\SI\EOT\t\STX \SI\ETX\EOT\SO 2\r0\v\NAK\n\r"
16:50:49 <oklopol> ...
16:50:50 <oklopol> :)
16:50:53 <mornfall> > map ((!!13) . iterate succ) "mornfall"
16:50:55 <lambdabot>  "z|\DEL{snyy"
16:50:57 * Pseudonym wonders what "ASM" refers to in that quote
16:50:58 <dons> augustss: hehe, http://gnuvince.wordpress.com/2007/09/12/celebs-on-reddit/
16:51:00 <lambdabot> Title: Celebs of Reddit « Occasionally sane
16:51:01 <mornfall> almost there :)
16:51:14 <dons> slava too, though he's not in here
16:51:19 <oklopol> > let charz = ['a'..'z']++['A'..'Z']; n=3 in map (\x -> if x `elem` charz then charz !! ((fromEnum x + n) `mod` length charz) else x) "testing this crapzor"
16:51:20 <lambdabot>  "paopejc pdeo YnWlvkn"
16:51:23 <oklopol> wow
16:51:29 <Pseudonym> alt.syntax.formal.tactical
16:51:30 <oklopol> i love this language :=)
16:51:43 <Pseudonym> We've snared another one!
16:51:44 <oklopol> hmm...
16:51:49 <Pseudonym> Hair shirts for everyone!@
16:51:49 <oklopol> that might be wrong though...
16:51:56 <augustss> dons: and so are you!
16:52:18 <dons> mega celebs
16:52:40 <dons> ?seen gnuvince
16:52:41 <lambdabot> Last time I saw gnuvince was when I left ##logic, #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #oasis, #parrot, #perl6, #scala, #
16:52:41 <lambdabot> scannedinavian, #unicycling and #xmonad 27d 18h 55m ago, and .
16:53:18 * ddarius starts counting how many of those people hang out in #haskell.
16:53:31 <Pseudonym> ?seen
16:53:31 <Choko> no many
16:53:35 <augustss> dons: are you coming to ICFP?
16:53:39 <dons> sure!
16:53:45 <Pseudonym> ?msg lambdabot ?stats
16:53:50 <dons> we've the fusion paper to present, the xmonad talk, and the hackathon to run
16:53:50 <Pseudonym> Bleah.
16:53:52 <oklopol> umm...
16:53:54 <augustss> excellent!
16:53:59 <oklopol> how do you do the inverse of !!?
16:54:01 <oklopol> "!!"
16:54:10 <Pseudonym> oklopol: There is no inverse of !!.
16:54:13 <Pseudonym> What do you mean?
16:54:13 <ari> oklopol: Do you mean flip (!!)?
16:54:14 <oklopol> hmm
16:54:29 <oklopol> i mean, `elem` tells me the thing is in the list, does something tell the inverse?
16:54:29 <Pseudonym> !!, by definition, can't have an inverse.
16:54:31 <oklopol> ...
16:54:33 <ari> :t (!!)
16:54:33 <oklopol> not inverse
16:54:35 <oklopol> index
16:54:35 <lambdabot> forall a. [a] -> Int -> a
16:54:36 <ari> :t flip (!!)
16:54:38 <lambdabot> forall a. Int -> [a] -> a
16:54:39 <Pseudonym> You mean if it's NOT in the inverse?
16:54:42 <Pseudonym> Oh!
16:54:46 <Pseudonym> Right, the position it's at.
16:54:48 <ddarius> :t notElem
16:54:50 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
16:54:52 <oklopol> well yes.
16:54:55 <Pseudonym> Well you can do that.
16:55:00 <dons> augustss: yeah, should be fun. i've not been to Germany before
16:55:03 <oerjan> :t lookup
16:55:06 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:55:11 <oerjan> er, not quite
16:55:16 <oklopol> > 8 `lookup` [1..10]
16:55:16 <lemmih> ?type findIndex
16:55:16 <lambdabot>   add an instance declaration for (Num (t, b))
16:55:16 <lambdabot>     In the expression: 10
16:55:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
16:55:22 <oklopol> > 8 `lookup` [1..10]
16:55:23 <lambdabot>   add an instance declaration for (Num (t, b))
16:55:23 <lambdabot>     In the expression: 10
16:55:24 <augustss> dons: I've not been to Freiburg before :)
16:55:26 <oklopol> kay...
16:55:26 * Boney would love to go to ICFP.
16:55:29 <ari> @hoogle Eq a => a -> [a] -> Maybe int
16:55:30 <lambdabot> Did you mean: Eq a => a -> [a] -> Maybe Int
16:55:36 <lemmih> ?type findIndices
16:55:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
16:55:40 <EvilTerran> ?type lookup
16:55:42 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:55:43 <Boney> and to Germany, but for different resons.
16:55:55 <oerjan> :t elemIndex -- found it
16:55:55 <Pseudonym> "lookup" is useful soemtimes.
16:55:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
16:56:00 <ddarius> A lowercase 'l' today.
16:56:02 <Boney> I guess there's another reason to become a Phd Student.
16:56:02 <oklopol> > 8 `elemIndex` [1..10]
16:56:03 <augustss> :t (!!)
16:56:03 <ari> @hoogle a -> [a] -> Maybe Int
16:56:03 <lambdabot>  Just 7
16:56:04 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
16:56:04 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
16:56:05 <lambdabot> forall a. [a] -> Int -> a
16:56:13 <Pseudonym> > lookup 'e' (zip "hello world" [0..])
16:56:14 <lambdabot>  Just 1
16:56:14 <oklopol> > return (8 `lookup` [1..10])
16:56:15 <lambdabot>   add an instance declaration for (Show (m (Maybe b)))
16:56:18 <oklopol> hmm
16:56:24 <oklopol> what takes it off the Just?
16:56:28 <oerjan> also, elemIndices
16:56:36 <Pseudonym> :t fromJust
16:56:37 <lambdabot> forall a. Maybe a -> a
16:56:40 <Pseudonym> That.
16:56:42 <sioraiocht> @src fromJust
16:56:42 <lucca> Maybe. :p
16:56:43 <lambdabot> fromJust Nothing  = undefined
16:56:43 <lambdabot> fromJust (Just x) = x
16:56:49 <conal> :t fromMaybe
16:56:50 <oerjan> or pattern matching
16:56:51 <lambdabot> forall a. a -> Maybe a -> a
16:56:54 <conal> safer
16:56:59 * Pseudonym nods
16:57:00 <ari> oklopol: Either work en the Maybe monad, use fromMaybe, or pattern match
16:57:02 <sioraiocht> oklopol: you're better off using pattern matching, so you can prepare for the "Nothing" case
16:57:05 <ari> *en=in
16:57:10 <sioraiocht> @src fromMaybe
16:57:11 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
16:57:11 <BMeph> @src catA
16:57:12 <lambdabot> Source not found. Do you think like you type?
16:57:13 <oklopol> > let charz = ['a'..'z']++['A'..'Z']; n=3 in map (\x -> if x `elem` charz then charz !! ((fromJust (x `elemIndex` charz) + n) `mod` length charz) else x) "testing this crapzor"
16:57:14 <Pseudonym> Use fromJust only if you KNOW it's there.
16:57:15 <lambdabot>  "whvwlqj wklv fudsCru"
16:57:29 <oerjan> oklopol: in Haskell, there is more than one way to do it.  Just like perl.
16:57:45 <dons> but there's only one type for it.
16:57:45 <sioraiocht> oerjan: I'm pretty sure that's where the parallels stop
16:57:48 <Pseudonym> oklopol: By using the Maybe, you avoid the call to elem.
16:58:02 <oklopol> i realized that
16:58:12 <oerjan> sioraiocht: haskell can be just as unreadable as perl, too :)
16:58:20 <Trixsey> Any swedes in here?
16:58:22 <oklopol> unreadability is nice <3
16:58:32 <oklopol> in small doses at least
16:58:41 <Pseudonym> oklopol: You'll love point-free programming, then.
16:58:42 <sioraiocht> oerjan: I disagree.  Haskell can be unreadable.  In perl though, you don't have to try =p
16:58:55 <oklopol> Pseudonym: i've done unlambda
16:58:56 <dons> Trixsey: should be dozens
16:59:00 <Pseudonym> There you go!
16:59:02 <BMeph>  (foldl (<+>) none (map (hasText.startsWith) fH))
16:59:16 <Trixsey> I'm looking for swedes! :p
16:59:17 <dons> Trixsey: see also #haskell.se
16:59:20 <Trixsey> ohhh
16:59:23 <Pseudonym> ?pl (\x -> if x `elem` charz then charz !! ((fromJust (x `elemIndex` charz) + n) `mod` length charz) else x
16:59:23 <lambdabot> (line 1, column 104):
16:59:23 <lambdabot> unexpected end of input
16:59:23 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
16:59:25 <Pseudonym> ?pl (\x -> if x `elem` charz then charz !! ((fromJust (x `elemIndex` charz) + n) `mod` length charz) else x)
16:59:25 <lambdabot> join (liftM2 if' (`elem` charz) ((charz !!) . (`mod` length charz) . (n +) . fromJust . (`elemIndex` charz)))
16:59:28 <Pseudonym> Woo!
16:59:30 <ddarius> At least in unlambda the combinators always mean the same thing.
16:59:43 <mornfall> very obscure... :]
16:59:45 <mornfall> > let (==>) pred fun = (\x -> if pred x then fun x else id x) in map (((>'z')
16:59:45 <lambdabot>  Unbalanced parenthesis
16:59:46 <mornfall>  ==> ((!!26) . iterate pred)) . (!!13) . iterate succ) "mornfall"
16:59:48 <mornfall> grr
16:59:48 <dons> so no one responded to the `prime monads' mail?
17:00:01 <mornfall> > let (==>) pred fun = (\x -> if pred x then fun x else id x) in map (((>'z')  ==> ((!!26) . iterate pred)) . (!!13) . iterate succ) "mornfall"
17:00:03 <lambdabot>  "zbeasnyy"
17:00:05 <mornfall> ha
17:00:21 <ddarius> dons: I have it remarked it as unread, but I'm not sure what to say about it.
17:00:22 <oklopol> that goes over my head
17:00:33 <Pseudonym> dons: Some of us only got up not long ago, you know.
17:00:37 <Qerub> mornfall: Nice to see you (here).
17:00:45 * Pseudonym murmurs about bloody people in other bloody hemispheres
17:00:45 <mornfall> Qerub: hey! :)
17:00:45 <monochrom> hi
17:00:47 <sioraiocht> hrm, #haskell.es actually has people in it, maybe i'll learn some academic spanish
17:00:49 <mornfall> it's 2 am though :\
17:01:00 <Qerub> mornfall: Yeah... That part sucks, I agree.
17:01:02 <ddarius> Pseudonym: We should just do away with those other hemispheres altogether.
17:01:06 <dons> Pseudonym: oh no. it has begun!
17:01:07 <mornfall> and i get up 6:30
17:01:10 <KatieHuber> can anyone see anything obviously wrong with
17:01:11 <mornfall> gah
17:01:11 <KatieHuber> type Rule = Pile -> Hand -> Bool
17:01:14 <Qerub> mornfall: Me too :-)
17:01:14 <lucca> swap (>'z') for Data.Char.isLetter
17:01:20 <KatieHuber> I get ERROR "./Rule.hs":22 - Illegal type "Pile -> [FacingCard] -> Bool" in constructor application
17:01:25 <Qerub> mornfall: Care to give me a wake-up call? :-)
17:01:29 <mornfall> lucca: ?
17:01:32 <dons> KatieHuber: oh, you're using hugs?
17:01:35 <mornfall> Qerub :P
17:01:36 <KatieHuber> yeah
17:01:41 <KatieHuber> can't get GHC to work here
17:01:49 <sioraiocht> KatieHuber: what is "here'?
17:01:50 <lucca> mornfall: then you can handle upper and lower case in one go
17:01:58 <KatieHuber> sioraiocht: Mac OS X Leopard beta
17:02:02 <lucca> mornfall: and potentially other alphabets way out there unicodeland
17:02:08 <sioraiocht> KatieHuber: you couldn't compile it?
17:02:12 <sioraiocht> that surprises me
17:02:14 <lucca> though 26 may not be appropriate for them
17:02:15 <mornfall> lucca: rot13 doesn't really work with other alphabets :)
17:02:29 <mornfall> uppercase would be nice
17:02:41 <mornfall> but  this is an exercise in futility anyway :)
17:02:44 <KatieHuber> MacPorts works on Tiger, but I get a compilation error having hacked the Portfile to even attempt building on Leopard
17:02:53 <mornfall> i like the ==> though
17:03:30 <mornfall> although there's something wrong with it nevertheless
17:03:34 <KatieHuber> is hugs the problem in this situation that it's brought up?
17:03:47 <oerjan> KatieHuber: your type looks fine, the error must be somewhere else.
17:03:53 <KatieHuber> lovely :)
17:04:00 <BMeph> Could someone point out where I'm going wrong:
17:04:03 <oerjan> what is at line 22?
17:04:04 <KatieHuber> Pile is data Pile = Pile { ... }
17:04:17 <KatieHuber> Hand is type Hand = [ FacingCard ]
17:04:20 <greenrd> I am using StateT (Maybe ...) to propagate type bindings around an AST - works well, but I want to now support scoping
17:04:31 <KatieHuber> both of which seem to work OK
17:04:34 <EvilTerran> > let rot n c | isUpper c = fromJust $ c `lookup` zip ['A'..'Z'] (drop n $ cycle ['A'..'Z']) | isLower c = fromJust $ c `lookup` zip ['a'..'z'] (drop n $ cycle ['a'..'z']) | otherwise = c in map (rot 13) "Hello, world!"
17:04:34 <oerjan> KatieHuber: i am more interesting in _where_ the error message is given
17:04:36 <lambdabot>  "Uryyb, jbeyq!"
17:04:41 <BMeph> I'm trying to use fusion on a line:  (foldl (<+>) none (map (hasText.startsWith) fH)) works, but
17:04:42 <greenrd> Looks like I should stick a continuation monad in my monad transformer stack
17:04:46 <oerjan> it does include a line number
17:04:53 <BMeph> (foldl ((<+>).(hasText.startsWith)) none fH) bombs out.
17:04:54 <KatieHuber> for the line I quoted
17:05:02 <KatieHuber> type Rule = Pile -> Hand -> Bool
17:05:02 <greenrd> My questions are: (1) where should I put the continuation monad transformer in my monad transformer stack?
17:05:08 <KatieHuber> previous line is "import Pile"
17:05:12 <mornfall> EvilTerran: nice :)
17:05:16 <KatieHuber> following is a boring function definition
17:05:54 <greenrd> and (2) do I even need to use ConT, or can I use instance MonadCont ReaderT?
17:06:16 <oerjan> KatieHuber: please paste
17:06:21 <oerjan> @paste
17:06:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:06:40 <mornfall> one-line programming in haskell... :)
17:06:47 <EvilTerran> > let rot n c | isAlpha c = fromJust $ c `lookup` zip letters (drop n $ cycle letters) | otherwise = c where letters = if isUpper c then ['A'..'Z'] else ['a'..'z'] in map (rot 13) "Hello, world!"
17:06:48 <lambdabot>  "Uryyb, jbeyq!"
17:07:04 <Qerub> mornfall: Good night!
17:07:09 <mornfall> Qerub: night
17:07:12 <mornfall> hm
17:08:03 <oklopol> > let k=(\a b->a) in k 1 2
17:08:04 <lambdabot>  1
17:08:07 <oerjan> greenrd: ReaderT is not a MonadCont unless it is stacked above a Cont or ContT
17:08:15 <KatieHuber> never mind, I found the problem... thanks for making me read my code ;)
17:08:19 <EvilTerran> oklopol, k = const
17:08:20 <KatieHuber> Pile is a parameterized type
17:08:26 <oerjan> oh :)
17:08:32 * dons $ home time
17:08:41 <mornfall> > let rot n c | isAlpha c = fromJust $ c `lookup` zip letters (drop n $ cycle letters) | otherwise = c where letters = if isUpper c then ['A'..'Z'] else ['a'..'z'] in map (rot 26) "Good night, world! (really, this time)"
17:08:43 <lambdabot>  "Good night, world! (really, this time)"
17:08:47 <oklopol> > let k=(\a b->a);s=(\a b c->(a c) (a b)) in s $ k $ k $ 5
17:08:48 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
17:08:48 <lambdabot>     Probab...
17:08:50 <oklopol> hmm
17:09:16 <greenrd> oerjan: ah, silly me, should have noticed that
17:09:18 <oklopol> EvilTerran: i do know, would've been kind of a weird coincidence if i'd've just randomly called that k
17:09:44 <oerjan> oklopol: $ is right associative
17:09:48 <greenrd> oerjan: does that suggest that I *should* stack ReaderT above a Cont for my particular problem, or is that a red herring?
17:09:55 <oklopol> > let k=(\a b->a);s=(\a b c->(a c) (a b)) in ((s k) k) 4
17:09:56 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
17:09:56 <lambdabot>     Probab...
17:10:00 <EvilTerran> well, it'd make sense to call it k, seeing as it *is* the k combinator
17:10:20 <oerjan> oklopol: and just spaces are left
17:10:38 <oklopol> > let k=(\a b->a);s=(\a b c->(a c) (b c)) in ((s k) k) 4
17:10:39 <lambdabot>  4
17:10:41 <oklopol> but...
17:10:45 <oerjan> oklopol: you are hitting the Dreaded Monomorphism Restriction
17:10:59 <EvilTerran> but we tend to go for more descriptive names than the combinatorial logicians
17:11:09 <oerjan> write it as k a b = a; similarly for s
17:11:14 <oklopol> > let k=(\a b->a);s=(\a b c->a c (b c)) in s k k 4
17:11:15 <lambdabot>  4
17:11:23 * EvilTerran was utterly horrified, when learning physics, with the ridiculous variable names they use
17:11:50 <sorear> EvilTerran: I find the lack of rigor worse
17:11:57 <oklopol> EvilTerran: i'm just jamming around, so it'll be k
17:11:58 <sorear> oklopol: no he's not
17:12:05 <sorear> oerjan: no he's not
17:12:07 <oerjan> oklopol: oh, you had a typo.
17:12:15 <sorear> oerjan: DMR only applies to constained variables
17:12:18 <EvilTerran> "yeah, this term's insignificant **cross out**"
17:12:23 <oerjan> he would have, if he had tried something more complicated :)
17:12:29 <oerjan> oh right.
17:12:30 <oerjan> bah
17:12:35 <EvilTerran> the MR only affects top-level bindings, doesn't it?
17:12:37 <sorear> > let x = undefined in (x,x) == ('x', True)
17:12:39 <lambdabot>  Undefined
17:12:44 <oerjan> EvilTerran: i don't think so
17:12:45 <sorear> > let x :: Show a => a; x = undefined in (x,x) == ('x', True)
17:12:47 <lambdabot>  Undefined
17:13:00 <sorear> > let x = (undefined :: Show a => a) in (x,x) == ('x', True)
17:13:02 <lambdabot>  Couldn't match expected type `Char' against inferred type `Bool'
17:13:07 <sorear> EvilTerran: No.
17:13:11 <EvilTerran> > let x = 1 in (x :: Int, x :: Float)
17:13:11 <lambdabot>  Couldn't match expected type `Float' against inferred type `Int'
17:13:12 <oerjan> but other bindings are rarely used polymorphically
17:13:19 <EvilTerran> > let x :: Num a => a; x = 1 in (x :: Int, x :: Float)
17:13:20 <lambdabot>  (1,1.0)
17:13:22 <greenrd> everyone knows e=mc^2, right? wrong - there are actually (an infinite number of?) extra terms
17:13:23 <EvilTerran> yes, quite
17:13:41 <oerjan> greenrd: mc^2 is the rest term
17:14:06 <oerjan> (particle at rest, that is)
17:14:35 * Boney thinks of splitting beer atoms.
17:14:42 <zeeeee> @seen lemmih
17:14:43 <lambdabot> lemmih is in #xmonad and #haskell. I last heard lemmih speak 19m 6s ago.
17:14:46 <Boney> .. and french women.
17:14:52 <Olathe> @seen lambdabot
17:14:53 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #ghc and #darcs
17:14:57 <Olathe> O-o
17:15:16 <hpaste>  BMeph pasted "Fusion failure" at http://hpaste.org/2712
17:15:17 <lemmih> zeeeee: Yo.
17:15:30 <hpaste>  (anonymous) annotated "Fusion failure" with "(no title)" at http://hpaste.org/2712#a1
17:15:41 <oklopol> so... what's DMR?
17:15:43 <sorear> greenrd: but... E *does* equal m c^2, becuase the same terms contribute to m.  Also, in my universe, E = m.
17:15:55 <EvilTerran> oklopol, the Dreaded Monomorphism Restriction
17:16:01 <oklopol> well yeah
17:16:04 <oklopol> but what's that?
17:16:10 <Pseudonym> sorear works in Planck coordinates.
17:16:19 <oerjan> @where DMR
17:16:20 <lambdabot> I know nothing about dmr.
17:16:24 <EvilTerran> basically, it means that if you bind an expression to a name with no parameters, it's not polymorphic unless you explicitly type it as such
17:16:29 <EvilTerran> ?type 1
17:16:31 <lambdabot> forall t. (Num t) => t
17:16:34 <EvilTerran> ?type let x = 1 in x
17:16:35 <lambdabot> forall t. (Num t) => t
17:16:39 <EvilTerran> wha...
17:16:39 <greenrd> sorear: I stand corrected
17:16:49 <EvilTerran> > let x :: Num a => a; x = 1 in (x :: Int, x :: Float)
17:16:49 <lambdabot>  (1,1.0)
17:16:55 <sorear> wait, so I'm automatically right because I'm sorear?
17:16:56 <EvilTerran> > (1 :: Int, 1 :: Float)
17:16:57 <lambdabot>  (1,1.0)
17:17:00 <ari> oerjan: Best to just call it MR, I think, DMR reminds me of Dennis M. Ritchie
17:17:08 <EvilTerran> > let {- look ma, no type signature -} x = 1 in (x :: Int, x :: Float)
17:17:09 <lambdabot>  Couldn't match expected type `Float' against inferred type `Int'
17:17:43 * sorear installs the RC
17:18:03 <augustss> DMR = Da Monomorphism Restriction?
17:18:11 <oerjan> Dreaded
17:18:24 <oerjan> or similar
17:18:44 <oklopol> not sure if it'd be too impolite to tell i didn't understand EvilTerran's explanation
17:18:45 <greenrd> sorear: just to clarify - you mean, it depends on whether you are talking about the rest mass or the "actual mass"?
17:19:02 <EvilTerran> oklopol, no, go ahead, i suck at explanations
17:19:11 <oklopol> heh, polymorphism?
17:19:13 <oerjan> oklopol: well do you understand polymorphism?  otherwise it might be a bit early to explain to you the exceptions
17:19:15 <EvilTerran> look at those last three things i did there
17:19:18 <sorear> greenrd: yeah
17:19:18 <hpaste>  BMeph annotated "Fusion failure" with "Commenting the comment" at http://hpaste.org/2712#a2
17:19:22 <greenrd> ok
17:19:28 <EvilTerran> > (1::Int, 1::Float) -- works
17:19:30 <lambdabot>  (1,1.0)
17:19:31 <oklopol> oerjan: i guess i don't.
17:19:47 <EvilTerran> > let x = 1 in (x::Int, x::Float) -- doesn't, 'cos the MR means that x can only have one type
17:19:48 <lambdabot>  Couldn't match expected type `Float' against inferred type `Int'
17:19:55 <augustss> oerjan: I liked mine better
17:19:57 <oklopol> they teach us java @ school, i thought i knew polymorphism, but...
17:20:02 <oerjan> greenrd: the rest mass is the actual mass, the other one is not really used
17:20:06 <hpaste>  zeeeee pasted "small patch for Lemmih's STM.HashTable" at http://hpaste.org/2713
17:20:42 <augustss> oklopol: you've probably not seen proper polymorphism.  it's a term abused in the OO community
17:20:43 <zeeeee> lemmih: you should submit your module for inclusion into STM, it's handy
17:20:52 <Pseudonym> Not really.
17:21:03 <oklopol> augustss: exactly what i suspected
17:21:11 <Pseudonym> Inheritance-based subtype polymorphism is perfectly legitimate.
17:21:15 <sorear> OO gives you linear subtype polymorphism
17:21:22 <Pseudonym> So is C++-style overloading, for that matter.
17:21:28 <lemmih> zeeeee: What module?
17:21:35 <oklopol> i guess i'll do some googling
17:21:36 <Pseudonym> It's not an abuse of the term.
17:21:38 <augustss> Pseudonym: I'd call it oligomorphism
17:21:46 <lemmih> zeeeee: Oh, the pasted one.
17:21:47 <zeeeee> lemmih: the STM.HashTable module, i just pasted a patch for it
17:21:48 <johnnowak> augustss:  how is it "abused"?
17:21:54 <Pseudonym> cacistomorphism
17:22:14 <LoganCapaldo> cactusmorphism?
17:22:39 <greenrd> Is the Maybe monad merely a special case of the List monad?
17:22:40 <ari> polymorphism with spikes?
17:22:46 <Pseudonym> kleptomorphism
17:22:50 <lemmih> zeeeee: Where's the repo? I seem to have forgotten it.
17:23:01 <zeeeee> haha
17:23:11 <greenrd> It seems that ap does exactly the same thing - if we consider Just to be equivalent to (:[])
17:23:14 <zeeeee> http://darcs.haskell.org/~lemmih/stm-base/
17:23:16 <lambdabot> Title: Index of /~lemmih/stm-base
17:23:18 <greenrd> and Nothing to be equivalent to []
17:23:30 <lemmih> Oh, stm-base. I remember now.
17:23:33 <Pseudonym> @let robotNinjaMonkey = (:[])
17:23:36 <lambdabot> Defined.
17:23:36 <oerjan> greenrd: i suppose if you only use zero or one-element lists
17:23:44 <Pseudonym> There, now everyone's happy.
17:23:45 <greenrd> oerjan: that's my point
17:23:52 <oerjan> however, it breaks down when you add MonadPlus methods
17:24:07 <greenrd> ok, but what if you don't?
17:24:45 <EvilTerran> oerjan, well, you can use the MonadPlus methods, if you only ever actually look at the first item in the result list
17:25:11 <ari> > Just 1 `mplus` Just 2
17:25:12 <lambdabot>  Just 1
17:25:21 <ari> > [1] `mplus` [2]
17:25:22 <lambdabot>  [1,2]
17:25:28 <greenrd> so for conversion functions you could use:
17:25:30 <greenrd> maybe [] (:[])
17:25:49 <Pseudonym> :t maybe [] (:[])
17:25:51 <lambdabot> forall a. Maybe a -> [a]
17:26:06 <greenrd> and \x -> case x of [] -> Nothing; (h:t) -> Just h
17:26:06 <greenrd> ?
17:26:07 <EvilTerran> do { } :: Maybe a = listToMaybe (do {...})
17:26:15 <Pseudonym> ?djinn Maybe a -> [a]
17:26:16 <lambdabot> -- f cannot be realized.
17:26:34 <oerjan> EvilTerran: not really, because you can backtrack past success in the list monad but not in the maybe monad, i think
17:26:48 <EvilTerran> hm... kinda.
17:26:57 <EvilTerran> i was assuming one-item-per-list throughout
17:27:11 <oklopol> hmm... i'm pretty sure i understand polymorphism
17:27:22 <oerjan> but that is the same as not using mplus
17:27:37 <EvilTerran> the intended implication was that the same do{} would typecheck as :: [Foo] and :: Maybe Foo
17:27:48 <greenrd> yeah, I mean Maybe conceptualised as "lists restricted to length 0 or 1"
17:27:58 <oklopol> but i don't know what "binding a name with no parameters" is
17:28:03 <EvilTerran> i think giving it the Maybe type and using listToMaybe should produce the same end result
17:28:19 <augustss> oklopol: make sure you understand parametric polymorphism, because that's the cool one. :)
17:28:45 <oerjan> oklopol: functions can defined as f x = ... or as f = \x -> ...
17:28:58 <EvilTerran> > let x = (\y -> y+1) in (x (1::Int), x (1::Float)) -- x has no parameters, so the MR means it has only one type
17:28:58 <lambdabot>  Couldn't match expected type `Int' against inferred type `Float'
17:29:12 <oerjan> the latter is binding without parameters, which applies also to other values than functions
17:29:17 <EvilTerran> > let x y = y+1 in (x (1::Int), x (1::Float)) -- x has a parameter, so is polymorphic
17:29:18 <lambdabot>  (2,2.0)
17:29:37 <oklopol> oh
17:29:38 <oklopol> i see
17:30:12 <oklopol> hmm... "it's not polymorphic unless you explicitly type it as such"
17:30:41 <oklopol> guess i don't actually know what it means for it to be polymorphic...
17:30:54 <_dolio> > let x :: Num n => n -> n ; x = (\y -> y + 1) in (x (1 :: Int), x (1 :: Float))
17:30:56 <lambdabot>  (2,2.0)
17:31:35 <oerjan> oklopol: in haskell every expression has a type, right?
17:31:40 <oerjan> :t map
17:31:42 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:31:56 <oklopol> oerjan: yeah
17:32:10 <oerjan> for some values, such as map, the type contains variables.  this is polymorphism.
17:32:31 <oklopol> i see.
17:32:32 <oklopol> so...
17:32:40 <oerjan> you can use map with different actual types
17:32:46 <dolio> There's a GHC 6.8.1 release candidate? Did I miss 6.8?
17:32:52 <oklopol> the type of the function would be... what? if you don't explicitly type it as polymorphic?
17:33:10 <oklopol> :t (\a b->a)
17:33:12 <lambdabot> forall t t1. t -> t1 -> t
17:33:34 <oklopol> :t k where k = (\a b->a)
17:33:36 <lambdabot> parse error on input `where'
17:33:42 <oklopol> hmm :\
17:33:56 <oerjan> :t let k = (\a b->a) in k
17:33:58 <lambdabot> forall t t1. t -> t1 -> t
17:34:21 <oklopol> so... that isn't polymorphic why?
17:34:24 <ddarius> How is a functor more flexible than a function?
17:34:34 <shachaf> oklopol: Are you thinking of type classes, maybe?
17:34:42 <oerjan> well that one is a little deceptive
17:35:07 <shachaf> > let x = 1 in (x :: Int, x :: Float)
17:35:07 <lambdabot>  Couldn't match expected type `Float' against inferred type `Int'
17:35:09 <shachaf> > let x :: Num a => a; x = 1 in (x :: Int, x :: Float)
17:35:10 <lambdabot>  (1,1.0)
17:35:34 <dolio> :t let k = \a b -> a ; x = k 1 2 in k
17:35:36 <lambdabot> forall t t1. t -> t1 -> t
17:35:58 <oklopol> shachaf: i don't think so
17:36:19 <oerjan> in shachaf's example, x is not polymorphic (because of the MR in this case)
17:36:32 <oerjan> so it is not allowed to use both as Int and as Float
17:37:25 <atp> hey folks.  i'm trying to compile some code for the first time (up until now i've done most everything in ghci) and i'm getting (.text+0x22): undefined reference to `__stginit_ZCMain'
17:37:36 <atp> and also (.text+0x43): undefined reference to `ZCMain_main_closure'
17:37:38 <oklopol> okay... and how does this all make s and k not work?
17:37:38 <oerjan> another example of variables that are not polymorphic are those in lambdas
17:37:51 <lemmih> atp: Using --make?
17:37:54 <oerjan> oklopol: that was a mistake on my part
17:37:59 <oklopol> oh
17:38:01 <oerjan> they actually do
17:38:05 <atp> lemmih: no, just ghc -o code code.hs
17:38:16 <oklopol> so mine was a straightforward way to compile sk -> haskell?
17:38:27 <oerjan> at least until you try to write the y combinator, then you get problems
17:38:40 <oklopol> yeah
17:38:46 <oklopol> i actually know that.
17:38:56 <oklopol> (tried making it once)
17:39:01 <lemmih> atp: Does code.hs contain a function named 'main'?
17:39:07 <atp> lemmih: yep
17:39:17 <oerjan> but it can be defined in other ways
17:39:20 <atp> lemmih: of type IO ()
17:39:21 <oerjan> @src fix
17:39:22 <lambdabot> fix f = let x = f x in x
17:39:40 <lemmih> atp: Does code.hs contain a module named 'Main'?
17:40:03 <atp> lemmih: no, should it?
17:40:12 <oklopol> i should get some sleep i guess
17:40:16 <oklopol> ->
17:40:32 <oerjan> good night
17:40:33 <greenrd> atp: if you don't put a module Foo where ... statement, the default module name is Main
17:40:38 <lemmih> atp: You either have to name it 'Main' or pass '-main-is Code.main' to ghc.
17:40:57 <atp> greenrd: yeah, i always do module Etc where ...
17:41:08 <atp> lemmih: ok, great, thanks, i'll go try that
17:42:07 <atp> lemmih: great, that worked.  thanks for your help.
17:42:13 <atp> you too, greenrd
17:43:46 <greenrd> dolio: no - 6.8 has been branched but not released - probably it's a typo
17:44:08 <greenrd> but bizarrely, ghc HEAD still calls itself ghc 6.7.$DATE
17:44:59 <sorear> dolio, greenrd: it's not a typo
17:45:29 <greenrd> there will be no 6.8.0 then?
17:45:37 <sorear> correct.
17:45:55 <greenrd> I see
17:46:08 <greenrd> makes it easier for linux packagers I guess
17:46:20 <greenrd> the HEAD version must be a mistake though
17:46:33 <greenrd> it should be 6.9.$DATE or whatever
17:46:50 <sorear> 7.-1.$DATE :D
17:46:59 <greenrd> heh
17:47:02 <dolio> Well, in the past they've done, say, 6.6 --> 6.6.1, which is even weirder.
17:47:16 <dolio> No .0 at the end of the first.
17:47:39 <greenrd> ok, I take that back - none of this makes it easier for linux packagers ;)
18:04:24 * stepcut boings for 6.8.1
18:05:21 * monochrom boings too!
18:06:33 <ari> ... why aren't people boinging for 6.8?
18:06:50 * monochrom boings for 6.8 too
18:08:00 <sioraiocht> wait, is there even a 6.7 release?
18:08:05 * sioraiocht boggles, as usual.
18:09:02 <ddarius> There will never be a 6.7 release.
18:09:08 <ddarius> sioraiocht: Look for 6.5
18:09:35 <dolio> .odd is development, like the Linux kernel.
18:09:40 <sioraiocht> ohhhh
18:10:03 <sioraiocht> once again, i ahve to stay away from bleeding edge compilers
18:10:10 <sioraiocht> I can never assume I'm right and it's wrong
18:12:32 <sioraiocht> only super smart people can do that, imo
18:20:42 <mrd> 6.8.1 will be the next release
18:21:20 <ari> That's... interesting, I guess
18:28:27 <stepcut> @src partition
18:28:27 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
18:28:27 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
18:28:27 <lambdabot>                               | otherwise = (ts, x:fs)
18:32:55 <zeeeee> are par/strategies not usable for IO concurrency?
18:33:14 <zeeeee> *are strategies
18:34:54 <sjanssen> zeeeee: no, they're for pure code only
18:39:55 <KatieHuber> naming question, are these names appropriate?
18:39:56 <KatieHuber> liftRank f (Card r _) = f r
18:39:56 <KatieHuber> liftSuit f (Card _ s) = f s
18:40:10 <KatieHuber> (that is, is that what "lift" usually means?)
18:40:16 <Pseudonym> No, it's not.
18:40:18 <Pseudonym> However.
18:40:25 <Pseudonym> You have "rank" and "suit"?
18:40:41 <Pseudonym> f . rank and f . suit, respectively, do the job, and are even shorter.
18:40:48 <KatieHuber> oh, right
18:41:21 <Pseudonym> "lift" has several meanings in category theory/Haskell, and this isn't one of them. :-)
18:41:26 <KatieHuber> hehe
18:41:37 <Pseudonym> I won't explain what it does mean.  It'll come up naturally eventually.
18:42:33 <KatieHuber> OK, but I'm going to want names for these (I have an even longer one)
18:42:41 <LoganCapaldo>  let by = (.) in f `by` suit
18:42:44 <KatieHuber> any suggestions for what to call it?
18:43:18 <LoganCapaldo> mapRank ?
18:43:32 <LoganCapaldo> onRank ?
18:43:36 <Pseudonym> What's your longer one?
18:43:53 <KatieHuber> f . rank . abstractCard, using your notation
18:43:59 <KatieHuber> (and same for suit)
18:44:12 <KatieHuber> I'm going to be using this a lot :|
18:44:13 <Pseudonym> Then why not:
18:44:19 <Pseudonym> abstractRank = rank . abstractCard
18:44:22 <Pseudonym> Or something/
18:44:34 <Pseudonym> Then use: f . abstractRank
18:45:02 <Pseudonym> That's not too bad if you use an editor with name completion.
18:45:20 <KatieHuber> since I have a couple of different objects which have a rank, maybe I should make a typeclass
18:45:26 <KatieHuber> then I can use "rank" for all of them
18:45:27 <Pseudonym> Oh, good idea!
18:45:29 <dibblego> ?hoogle (Ord a) => Set a -> Set a -> Set a
18:45:33 <lambdabot> Data.Set.(\\) :: Ord a => Set a -> Set a -> Set a
18:45:33 <lambdabot> Data.Set.difference :: Ord a => Set a -> Set a -> Set a
18:45:33 <lambdabot> Data.Set.intersect :: Ord a => Set a -> Set a -> Set a
18:45:44 <Pseudonym> Yes, excellent.
18:46:05 <LoganCapaldo> what's the type of abstractCard ooc?
18:46:30 <KatieHuber> ooc?
18:46:36 <KatieHuber> data Card = Card Rank Suit deriving (Eq)
18:46:40 <KatieHuber> data FacingCard = FacingCard {
18:46:40 <KatieHuber>     abstractCard :: Card,
18:46:40 <KatieHuber>     facing :: Face
18:46:40 <KatieHuber> } deriving (Eq)
18:47:05 <LoganCapaldo> out of curiosity
18:47:10 <LoganCapaldo> or out of character
18:47:16 <LoganCapaldo> depending on context :)
18:47:48 <dolio> If you're playing on the Haskell MUD?
18:47:54 <Pseudonym> I did a similar thing once with group actions.
18:48:22 <Pseudonym> You had basic actions which could be applied to a state, but it also made sense to apply a list of actions, one after the other.
18:48:32 <Pseudonym> A simple type class did the trick.
18:49:15 * dolio backstabs the lambda wizard.
18:49:30 <LoganCapaldo> Is Face like A | B | C?
18:49:40 <LoganCapaldo> or more complexified?
18:49:46 <KatieHuber> yeah, FaceUp | FaceDown to be precise
18:50:09 <LoganCapaldo> data FacingCard = FaceUp Card | FaceDown Card ?
18:50:30 <KatieHuber> ooh, that'd be nicer
18:50:30 <LoganCapaldo> Why the "extra" type?
18:50:38 <KatieHuber> 'cos I didn't think of that ;p
18:51:29 <LoganCapaldo> heh
18:53:40 <LoganCapaldo> you can even still do data FacingCard = FaceUp { abstractCard :: Card } | FaceDown { abstractCard :: Card }
18:54:29 <KatieHuber> nice :)
18:54:31 <KatieHuber> much tidier
18:54:51 <LoganCapaldo> I'd want to call abstractCard card
18:55:03 <LoganCapaldo> but I'm guessing you have something else named card
18:55:04 <KatieHuber> me too :)
18:55:11 <KatieHuber> I think I need card elsewhere
18:59:08 <LoganCapaldo> This is why I kind of wish record syntax was a variation on something like facingCard.card or facingCard#card or whatever
18:59:22 <KatieHuber> yeah
18:59:27 <KatieHuber> does haskell use ` for anything?
18:59:31 <LoganCapaldo> yes
18:59:36 <KatieHuber> I got quite used to ` in PVS and liked it
18:59:44 <Nucleo_> :t map
18:59:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:59:48 <LoganCapaldo> > 5 `mod` 2
18:59:49 <lambdabot>  1
19:00:03 <LoganCapaldo> > mod 5 2
19:00:04 <lambdabot>  1
19:00:08 <KatieHuber> oh right, in pairs in that situation... I wonder whether the two'd be ambiguous
19:00:23 <LoganCapaldo> it would be as ambigous as using ' or "
19:00:53 <LoganCapaldo> actually
19:00:53 <LoganCapaldo> no
19:01:02 <LoganCapaldo> since you can't have `foo bar`
19:01:09 <LoganCapaldo> but that would be icky
19:02:20 <ari> Obviously we need to define a baskell (bourne again haskell) where you can use arbitrary functions as infix operators with $()
19:02:41 <LoganCapaldo> heh
19:03:26 <LoganCapaldo> isn't $() taken by template haskell?
19:03:39 <Olathe> Bah.
19:03:58 <Olathe> That's what I say to Bourne again haskell.
19:04:08 <dolio> People have shown how you can make -: :- operators for that.
19:04:15 <LoganCapaldo> Yeah!
19:04:20 <LoganCapaldo> I love those :)
19:04:26 <dolio> [1..10] -: zipWith (+) :- [11..20]
19:04:37 <Olathe> Neat :)
19:04:58 <LoganCapaldo> at least one defn. was on hpaste once upon a time
19:05:13 <Flynsarmy> How would i pick an integer out of an argument, such as -w20? I currently have:
19:05:14 <Flynsarmy> wOpt = head (filter ("-w" `isPrefixOf`) args) but it's not quite there yet
19:05:46 <LoganCapaldo> is args String or [String] ?
19:05:52 <Flynsarmy> [String]
19:06:04 <LoganCapaldo> I shoulda been able to figure that out :)
19:06:13 <LoganCapaldo> head (filter ...
19:08:26 <LoganCapaldo> \args -> do { x <- find ("-w" `isPrefixOf` args) ;  listToMaybe $ map fst $ reads (drop 2 x) }
19:08:30 <dons> dcoutts: is the bytestring stuff ready to go for ghc 6.8? is Igloo planning on uploading his forked bytestring?
19:08:44 <LoganCapaldo> :: [String] -> Maybe Integer
19:09:18 <LoganCapaldo> > (\args -> do { x <- find ("-w" `isPrefixOf` args) ;  listToMaybe $ map fst $ reads (drop 2 x) }) ["-w21"] :: Maybe Integer
19:09:18 <lambdabot>  Couldn't match expected type `a -> Bool'
19:09:28 <Igloo> dons: GHC is using d.h.o/bytestring now
19:09:40 <sorear> Igloo: see #ghc...
19:09:47 <LoganCapaldo> @type (\args -> do { x <- find ("-w" `isPrefixOf` args) ;  listToMaybe $ map fst $ reads (drop 2 x) })
19:09:49 <lambdabot>     Couldn't match expected type `a -> Bool'
19:09:49 <lambdabot>            against inferred type `Bool'
19:09:54 <LoganCapaldo> doh
19:10:02 <LoganCapaldo> @type (\args -> do { x <- find ("-w" `isPrefixOf`) args ;  listToMaybe $ map fst $ reads (drop 2 x) })
19:10:04 <lambdabot> forall a. (Read a) => [[Char]] -> Maybe a
19:10:15 <LoganCapaldo> @type (\args -> do { x <- find ("-w" `isPrefixOf`) args ;  listToMaybe $ map fst $ reads (drop 2 x) }) ["-w21"] :: Maybe Integer
19:10:16 <lambdabot> Maybe Integer :: Maybe Integer
19:10:23 <LoganCapaldo> > (\args -> do { x <- find ("-w" `isPrefixOf`) args ;  listToMaybe $ map fst $ reads (drop 2 x) }) ["-w21"] :: Maybe Integer
19:10:23 <KatieHuber> if I have red :: AbstractCard a => a -> Bool, then saying black = not . red gives an error -- this is DMR?
19:10:28 <lambdabot>  Just 21
19:10:52 <LoganCapaldo> > (\args -> do { x <- find ("-w" `isPrefixOf`) args ;  listToMaybe $ map fst $ reads (drop 2 x) }) ["-w"] :: Maybe Integer
19:10:53 <lambdabot>  Nothing
19:11:13 <LoganCapaldo> > (\args -> do { x <- find ("-w" `isPrefixOf`) args ;  listToMaybe $ map fst $ reads (drop 2 x) }) ["-a", "-w32", "-b", "--ok"] :: Maybe Integer
19:11:14 <lambdabot>  Just 32
19:13:15 <Pseudonym> :t red x = show x == "" in not . red
19:13:16 <LoganCapaldo> > (\args -> do { x <- find ("-w" `isPrefixOf`) args ;  listToMaybe . map fst . reads . drop 2  $ x }) ["-w"] :: Maybe Integer
19:13:16 <lambdabot> parse error on input `='
19:13:18 <lambdabot>  Nothing
19:13:23 <LoganCapaldo> > (\args -> do { x <- find ("-w" `isPrefixOf`) args ;  listToMaybe . map fst . reads . drop 2  $ x }) ["-w99"] :: Maybe Integer
19:13:23 <Pseudonym> :t let red x = show x == "" in not . red
19:13:24 <lambdabot>  Just 99
19:13:26 <lambdabot> forall a. (Show a) => a -> Bool
19:13:42 <Pseudonym> KatieHuber: What's the error?
19:13:45 <dons> Igloo: but for the ghc release, we'll need packages on hackage, won't we?
19:14:08 <KatieHuber> I forgot already after I fixed the code then edited it beyond recognition ;)
19:14:15 <Igloo> dons: Yup, for all the bootlibs
19:14:22 <dons> but not, say, bytestring?
19:14:27 <Pseudonym> Did it mention the monomorphism restriction, by any chance?
19:14:29 <Igloo> bytestring is a bootlib
19:14:31 <dons> ah ok
19:14:32 <KatieHuber> nope
19:14:45 <KatieHuber> but it felt like the kind of thing that the monomorphism restriction does
19:14:49 <Pseudonym> Right.
19:14:50 <LoganCapaldo> KatieHuber, revision control is your friend :)
19:14:57 <dons> Igloo: so you'll do a release of d.h.o/bytestring and other libs as required?
19:15:00 <KatieHuber> it said something about unresolved bindings in context or something
19:15:12 <Igloo> dons: Yup
19:15:14 <KatieHuber> I have version control, I just don't commit to it every ten seconds ;)
19:15:20 <Pseudonym> Ah.  Adding a type signature (which you SHOULD BE DOING) often makes error messages more helpful.
19:15:28 <LoganCapaldo> committing every 10 seconds is definitely your friend
19:15:40 <LoganCapaldo> no such thing as committing too often IMO
19:15:43 <Pseudonym> So you might want to do that.
19:16:33 <KatieHuber> if I write type signatures I have twice as much code >:(
19:16:49 <TSC> And half as many errors (:
19:16:50 <KatieHuber> which is incidentally then approximately twice as much code as I'd have in Ruby
19:16:54 <LoganCapaldo> you don't have to write them
19:17:00 <LoganCapaldo> you just have to clean them up
19:17:08 <Igloo> But your code will be 10 times easier to understand
19:17:16 <KatieHuber> what's the point of having type inference when everyone wants you to write type signatures anyway :p
19:17:38 <Pseudonym> KatieHuber: The point of type inference is so that you don't have to declare types for everything.
19:17:42 <LoganCapaldo> load up your code in ghci, find out the type signatures, and then put them in, with nicer type variables than t1 t2 etc.
19:17:43 <Pseudonym> So in:
19:17:47 <Pseudonym> f :: Int -> Int -> Bool
19:17:49 <Pseudonym> f x y = ...
19:17:54 <Pseudonym> You don't have to declare types for x and y.
19:17:55 <dolio> Writing top-level signatures is still less arduous than having to explicitly type every variable.
19:18:05 <Pseudonym> Yeah, like dolio says.
19:18:14 <dibblego> explicit type signatures are what other programmers call 'unit testing'
19:18:17 <Pseudonym> But top-level type signatures make your type error messages 20x more helpful.
19:18:24 <dibblego> so to compare to Ruby, you also have to compare to what they call 'unit tests'
19:18:28 <dibblego> Haskell clearly wins
19:18:41 <liyang> The whole sales pitch about type inference being able to work everything out so you won't have to write any is a bit of a sham, IMO.
19:18:43 <ricky_clarkson> dibblego: Contradicted by the existence of QuickCheck.
19:18:51 <dibblego> ricky_clarkson, not at all
19:18:56 <LoganCapaldo> dibblego, I hope you don't really believe that
19:18:58 <drtomc> Type signatures are also really useful on exported symbols.
19:18:59 <ricky_clarkson> Not all bugs can currently be caught by the compiler.
19:19:05 <dibblego> LoganCapaldo, no, I am exaggerating :)
19:19:18 <Pseudonym> The other thing is, each type signature that you write is a comment that you don't have to write.
19:19:27 <ricky_clarkson> dibblego: Port QuickCheck to Coq, and see how much traction it gets there.
19:19:34 <ari> ricky_clarkson: "currently"? I think your cup is more than just half full ;)
19:19:37 <drtomc> A statically checked comment, if you will
19:19:41 <Pseudonym> Indeed.
19:19:44 <dibblego> ricky_clarkson, that's quite a silly thing to do
19:19:48 <ricky_clarkson> dibblego: Rather.
19:19:52 <Pseudonym> And Haddock understands them, too.
19:19:54 <liyang> A *specification*.
19:19:56 <liyang> *cough*
19:20:15 <ricky_clarkson> ari: Yes'm.
19:20:46 <dibblego> "not all bugs can be caught by the compiler" is a well known issue
19:21:06 <liyang> (A partial one, at least in Haskell. But it's better than nothing, or worse, duck-typing.)
19:21:07 <dolio> "... therefore we should abandon static typing entirely." :)
19:21:23 <drtomc> Gosh - this is bringing back into my mind stuff from my Prolog past about success sets, intended interpretation, and formal models. :-)
19:21:27 <dibblego> dolio, you won't believe how many people say that and believe it :)
19:21:43 <dolio> dibblego: I've seen it plenty. :)
19:21:59 <dibblego> dolio, good, *feel* my frustration :)
19:22:29 <KatieHuber> OK, I have class Colored o where color :: o -> Color, and class AbstractCard c where suit :: c -> Suit and instance Colored Suit, how do I make a default instance of Colored for all instances of AbstractCard ?
19:22:37 <drtomc> My current shop is mostly Python, and there is quite strong anti-static typechecking sentiment. Personally, I figure if the compiler will find bugs for me, so much the better.
19:22:43 * jjore happens to like duck typing quite a bit, usually when replacing an object with something unanticipated by the original authors, usually some form of debugging or proxy object.
19:22:54 <Pseudonym> KatieHuber:
19:23:06 <Pseudonym> instance (AbstractCard c) => Colored c where { ... }
19:23:20 <dibblego> jjore, the newest version of Scala released a couple of days ago has structural typing; I find no rational reason to "like duck typing" in light of structural typing, can you?
19:23:35 <ari> You need undecidable instances for that, though, AFAICS
19:23:43 <KatieHuber> syntax error in declaration (unexpected keyword "instance")
19:24:34 <ari> KatieHuber: Instance declarations live in the top level
19:24:46 <KatieHuber> which is where it is
19:25:03 <jjore> I don't think I know what you mean by structural typing. Sorry.
19:25:06 <Pseudonym> So the bug may be with whatever is right behind the instance declaration.
19:25:25 <LoganCapaldo> jjore, compiler checked duck-typing :)
19:25:34 <jjore> Ah. Well I've no problem with that.
19:25:43 <jjore> As long as runtime can pull fast ones.
19:25:49 <hpaste>  Katie pasted "buh?" at http://hpaste.org/2714
19:26:04 <Pseudonym> I don't like duck typing.  If it looks like duck and quacks like a duck, it could still be full of Greek soldiers.
19:26:12 <KatieHuber> lol
19:26:19 <dibblego> jjore, structural typing == type-safe duck typing
19:26:22 <jjore> Yay! Full of greek soldiers!
19:26:30 <Olathe> Pseudonym: That's badger typing.
19:26:38 <drtomc> KatieHuber: remove the second instance of instance. :-)
19:26:48 <liyang> If you're into Greek soldiers, fair enough. Not my sort of thing. :-/
19:26:51 <dibblego> there is a paper that I have read, that discusses the tension between proving a halting program and the ability to express programs in a universal language (iirc?); can anyone give me some keywords?
19:27:08 <monochrom> I think that is precisely why people like duck typing. To betray.
19:27:20 <Pseudonym> And if it weighs the same as a duck, it could just be a witch.
19:27:32 <LoganCapaldo> Why do we feel the need to betray our programs?
19:27:43 <monochrom> No. Betray other people.
19:27:57 * glguy needs a dishwashing machine that returns the dishes to the cabinets
19:28:01 <liyang> In Soviet Russia, programs betray *you*.
19:28:06 * jjore writes many libraries that pretend very hard to be other things so that unmodified code can behave in new and fantastic ways (that blow up in your face if you look too hard).
19:28:07 <monochrom> Betray other people who work on the same program.
19:28:24 <shachaf> liyang: That doesn't sound very reversed. :-)
19:28:31 * LoganCapaldo needs a drying rack that returns the dishes to the "cabinet" 
19:28:36 <jjore> http://search.cpan.org/~jjore/ fwiw.
19:28:37 <lambdabot> Title: Joshua ben Jore - search.cpan.org
19:28:50 <liyang> shachaf: just goes to show how similar our world is to Soviet Russia. :(
19:29:46 <jjore> most of that is really about adding introspection and macros.
19:29:54 <Spark> i've taken to playing the russian national anthem on loop while writing GPL software
19:30:18 <liyang> Spark: face.
19:30:41 <liyang> (PS: get to bed. It's half three in the morning.)
19:30:58 <glguy> It's one thing to *use* GPL software... but to write it is quite another
19:31:24 <Spark> noone uses GPL software without also writing it though
19:31:27 <phobes> Duck typing is often better than typing typing
19:31:43 <liyang> It's bad. But of the commercial software whose sources I have seen, they're much, much worse.
19:31:49 <Spark> duck typing is just anonymous nominal typing, get over it
19:31:55 <monochrom> jjore: I highly recomment Phil Wadler's "monads for functional programming" for changing behaviour of existing code by changing an underneath layer.
19:32:13 <Pseudonym> STL concepts are very duck-like, of course.
19:32:50 <Spark> all macro-like things will be
19:33:07 <jjore> thanks monochrom
19:33:35 <phobes> Spark:  Duck typing is equivalent to anonymous nominal typing?
19:33:45 <dibblego> if it looks like a duck, then it is a macro
19:33:59 <Spark> nah, if it's a macro, it looks like a duck
19:34:14 <Spark> to another duck
19:34:33 <Pseudonym> template <class Duck> struct DuckConcept { void constraints() { function_requires< AnimalConcept<Duck> >(); d.appearance() == DUCK; d.quack(); } Duck d; };
19:34:41 <Spark> macros are really the ultimate in polymorphism -- it's not one piece of code on different data, it's one piece of code that gets copied and the various copies get specialised
19:34:42 <monochrom> @quote obey
19:34:42 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
19:34:44 <Spark> also known as cheating
19:34:44 <liyang> You will all burn in hell. Good night!
19:35:05 <Spark> hell has a large carbon footprint
19:35:16 <Pseudonym> Spark: It's all sequestered.
19:35:22 <LoganCapaldo> is there a zeroth law of typotics?
19:35:39 <Spark> (0) Must get papers published
19:35:42 <Pseudonym> Besides, it's balanced by sulphur emission.
19:35:46 <monochrom> Someone proposed "must protect programmer-kind".
19:35:58 <mrd> @djinn quack -> quack  -- duck typing
19:35:59 <lambdabot> Cannot parse command
19:36:12 <mrd> foiled!
19:36:25 <monochrom> @djinn f : quack -> quack
19:36:25 <lambdabot> Cannot parse command
19:36:31 <Pseudonym> If you could manufacture a duck out of pure thought, you'd be a deity.
19:36:33 <monochrom> @djinn f :: quack -> quack
19:36:33 <lambdabot> Cannot parse command
19:36:45 <monochrom> extremely hmm!
19:36:50 <mrd> remove the ::
19:36:57 <mrd> @djinn quack -> quack
19:36:58 <lambdabot> f a = a
19:37:15 <monochrom> Oh! It did not like "-- duck typing"!
19:37:51 <Spark> null.quack()
19:37:54 * Spark claims deity status
19:37:58 <LoganCapaldo> @djinn a -> a -- pretty sure it doesn't like comments period
19:37:58 <lambdabot> Cannot parse command
19:38:17 <Pseudonym> Mind you, in Haskell, undefined is always a Duck.
19:38:30 <mrd> > undefined :: quack
19:38:32 <lambdabot>  Undefined
19:39:11 <phobes> So how does this story with the type system go?  As the type system becomes sufficiently advanced it decides the only way it can really protect the programmer is by subverting his wishes and removing his crappy OS?
19:39:32 <shachaf> @djinn Void -> a
19:39:32 <lambdabot> f = void
19:39:41 <Pseudonym> Somewhere there's a Schroedinger joke about undefined :: Cat being contingent on the boxed Cat being alive or dead.
19:39:49 <mrd> because, of course, the type system is an intelligent being
19:39:50 <shachaf> "void" is like undefined?
19:40:29 <mrd> Pseudonym: it depends on whether you observe it!
19:41:02 <monochrom> void is not like undefined
19:41:15 <shachaf> What is void?
19:41:22 <liyang> I'm guessing Void is "data Zero". Whose only inhabitant is undefined. (This makes sense? I haet Haskell.)
19:41:24 <shachaf> @djinn-env
19:41:24 <lambdabot> data () = ()
19:41:25 <lambdabot> data Either a b = Left a | Right b
19:41:25 <lambdabot> data Maybe a = Nothing | Just a
19:41:25 <lambdabot> data Bool = False | True
19:41:25 <lambdabot> data Void
19:41:26 <lambdabot> type Not x = x -> Void
19:41:28 <lambdabot> class Eq a where (==) :: a -> a -> Bool
19:41:49 <shachaf> What is void, with a lowercase v?
19:41:50 <mrd> it's a lifted empty type
19:41:54 <monochrom> In Haskell the only inhabitant is undefined.
19:42:10 <monochrom> In djinn there is no undefined. void has no inhabitant.
19:42:24 <liyang> Then what is void? (lower-case)
19:42:31 <monochrom> I mean Void.
19:42:44 <shachaf> Yes, but what is "void"?
19:42:51 * shachaf has been careful about case.
19:42:57 <liyang> void == computer says `no'.
19:44:12 <Spark> does haskell have "void"?
19:44:13 <monochrom> For every codomain a, there is a unique function from the empty set to a. You can understand the function void as that.
19:44:31 <Pseudonym> You can also think of it in terms of Not.
19:44:45 <phobes> so  void :: Void -> a?
19:45:15 <Spark> void usually the type that no value fits
19:45:27 <liyang> Think of it in terms of types as proofs. By @djinn Void -> a, you're asking it to prove the proposition ``False implies anything.''
19:45:27 <Pseudonym> "False" is the proposition such that for all propositions P, False -> P is a theorem.
19:45:50 <liyang> s/proofs/propositions/ I should go to bed.
19:45:55 <Pseudonym> i.e. the function f :: forall a. False -> a exists
19:46:03 <phobes> Under CH, False = Void, right?
19:46:12 <Pseudonym> Yup.
19:46:21 <Pseudonym> And this function f is called "void".
19:46:47 <phobes> so what I said is right?  'void :: Void -> a'?
19:46:54 <Pseudonym> Should be, yes.
19:47:11 <Pseudonym> ?djinn False -> a
19:47:12 <phobes> k thx
19:47:14 <lambdabot> -- f cannot be realized.
19:47:19 <Pseudonym> ?djinn Not () -> a
19:47:19 <lambdabot> f a = void (a ())
19:47:22 <Pseudonym> There you go.
19:47:29 <mrd> False isnt a type
19:47:35 <Pseudonym> Yeah, but Not () works.
19:47:38 <Pseudonym> Since () is true.
19:47:50 <liyang> @djinn (a -> b, b -> c) -> a -> c
19:47:51 <lambdabot> f (a, b) c = b (a c)
19:48:02 <phobes> :t Not
19:48:07 <lambdabot> Not in scope: data constructor `Not'
19:48:16 <phobes> is that a djinn thing?
19:48:26 <liyang> djinn is something else. :t is Haskell.
19:48:26 <mrd> yes and  its not a term anyhow
19:48:58 <phobes> :k Not
19:49:00 <phobes> :P
19:49:00 <lambdabot> Not in scope: type constructor or class `Not'
19:49:28 <Spark> @djinn badger face rape
19:49:28 <lambdabot> -- f cannot be realized.
19:50:00 <liyang> Spark: lovely image.
19:52:01 <hpaste>  liyang annotated "buh?" with "fixed." at http://hpaste.org/2714#a1
19:52:50 <shachaf> liyang: Fixed the spelling too? :-)
19:53:33 <liyang> What? We're British. We drink tea don't you know.
19:54:09 <sioraiocht> how does one interpret (a,b) c = b (a c) anyway?
19:54:26 <Adamant> liyang, not iced tea, I presume
19:54:32 <Spark> with a perl executable
19:54:49 <Spark> that's not tea, it's a herbal infusion
19:54:55 <liyang> sioraiocht: the proof for (a implies b) and (b implies c) implies (a implies c)
19:55:11 <sioraiocht> no, i got that, but what does that proofe MEAN
19:57:43 <liyang> sioraiocht: if you give me a proof[program] for (A implies B)[or A -> B], as well as a proof for (B implies C), and you give me a proof for A, I can then prove B from the first proof (A -> B), which you can then feed into the second proof (B -> C) to get C out. Hence proving A -> C.
19:59:18 <monochrom> I drink tea.
19:59:42 <monochrom> I disbelieve in herbal stuff.
20:00:06 <ricky_clarkson> I believe in herbal stuff, because I've seen it, but I prefer tea.
20:00:07 <liyang> Or (read : as `is a proof for') -- we have x : A -> B and y : B -> C. Given z : A, y (x z) : C.
20:00:47 <liyang> Pairing (,) is just logical conjunction.
20:01:16 * liyang actually drinks espresso. Which is why he's still awake. GAH.
20:01:27 <monochrom> Function application is modus ponens. Here is how. Suppose x::a, f :: a->b, then f x is like "from a and a->b, get b".
20:01:44 <sioraiocht> liyang: yeah, it's like 4am there =p
20:01:48 <Pseudonym> And a lambda abstraction is a hypothetical.
20:02:03 <Pseudonym> If x :: A and e :: B, then \x -> e :: A -> B
20:02:14 <Pseudonym> That means if you supply a proof of A, I can get a proof of B.
20:02:20 <Pseudonym> And e is the proof.
20:02:28 <monochrom> So if you see "f (a,b) c = b (a c)", it is using modus ponens twice, once at (a c), another at b (...).
20:02:41 <liyang> CH AT WORK WTFLOLBBQ!!!!!
20:02:51 <monochrom> I wonder why BBQ.
20:03:00 <liyang> Because.
20:03:24 <monochrom> Is that supposed to be the empty reason? :)
20:03:36 <liyang> Just because.
20:03:55 <monochrom> Just because :: Maybe Proof ?
20:04:53 <phobes> Just Nothing :: Maybe Maybe Not
20:05:19 <phobes> (ok it doesn't quite work... I'm going to bed)
20:05:30 <Pseudonym> ?remember phobes Just Nothing :: Maybe Maybe Not
20:05:30 <lambdabot> Done.
20:05:35 <Pseudonym> I like it, though.
20:05:43 <monochrom> Hahaha
20:05:53 <monochrom> Very nice.
20:05:53 <liyang> Haskell is a crap proof checker. That is all.
20:06:02 <liyang> Night night. Really.
20:06:07 <Pseudonym> No, it's a checker for only crap proofs.
20:06:09 <Pseudonym> And night!
20:06:17 <pjd> that can also be written f (a,b) = b . a
20:06:20 <monochrom> Haskell permits unsound recursion e.g. x = not x
20:06:42 <pjd> where (.) is hypothetical syllogism (apparently)
20:08:29 <monochrom> (x -> y) -> (t -> x) -> (t -> y).  some kind of transitivity of ->. some kind of cut.
20:10:58 <KatieHuber> drtomc: (to go back 40 mins) - thanks, but now I get "overlapping instances for class "Colored" :|
20:12:14 <monochrom> I think he predicted it.
20:14:15 <monochrom> You will have to enable overlapping instances. Or you have to re-design. I think the idea of class AbstractSuit is misguided.
20:14:48 <KatieHuber> what does "overlapping instance" even mean?
20:15:15 <Pseudonym> It means that there are two instances for the same type.
20:15:18 <Pseudonym> More or less.
20:15:24 <monochrom> advanced type class subject. I can't explain it.
20:15:42 <Pseudonym> Actually, it means there _could_ be, and the compiler can't prove there isn't.
20:16:53 <KatieHuber> so it thinks I might write instance AbstractCard Suit, even though I won't... I see.
20:17:24 <KatieHuber> so is this generic implementation of a class ever useful?
20:17:33 <KatieHuber> I can't see a situation where this wouldn't come up...
20:17:49 <Pseudonym> Could you paste your current code again?
20:18:40 <hpaste>  Katie annotated "buh?" with "code again" at http://hpaste.org/2714#a2
20:19:37 <KatieHuber> (there is another instance of AbstractCard, and hence Colored, later)
20:19:46 <Pseudonym> Ah, that's important.
20:20:01 <Pseudonym> And it's overlapping instances for AbstractCard, or Colored?
20:20:23 <hpaste>  Katie annotated "buh?" with "the error" at http://hpaste.org/2714#a3
20:20:36 <KatieHuber> line 55 is instance (AbstractCard c) => Colored c where
20:22:10 <liyang> Drop AbstractCard and just write data Card = Card { rank :: Rank, suit :: Suit } deriving Eq ; Not quite seeing why you need AbstractCard.
20:23:06 <Pseudonym> Yeah, I tend to agree.
20:23:13 <Pseudonym> Well...
20:23:20 <Pseudonym> Oh, it's for the FaceUp/FaceDown thing.
20:23:46 <hpaste>  Katie annotated "buh?" with "More code for more context" at http://hpaste.org/2714#a4
20:23:53 <KatieHuber> that's the other instance
20:23:55 <Pseudonym> OK, do you ever need to directly take the Color of a suit?
20:24:05 <KatieHuber> no, I don't think so
20:24:09 <Pseudonym> Right.
20:24:26 <Pseudonym> So actually, a better thing would be to remove the Colored class and just do this instead:
20:24:34 <Pseudonym> colorOfSuit :: Suit -> Color
20:24:43 <Pseudonym> color :: (AbstractCard c) => c -> Color
20:24:57 <Pseudonym> color = colorOfSuit . suit
20:24:58 <Pseudonym> Or something.
20:25:13 <Pseudonym> Keep the short name for the commonly-used operation.
20:25:41 <KatieHuber> yeah, that works
20:25:43 <KatieHuber> thanks
20:26:50 <KatieHuber> stupid DMR :)
20:26:57 <KatieHuber> making me write type signatures :p
20:28:49 <ddarius> You could eta expand...
20:29:23 <KatieHuber> if that means adding an argument and replacing (.) with a normal call then yeah, I did that
20:29:36 <drtomc> > True
20:29:37 <lambdabot>  True
20:29:52 <drtomc> > maxBound::Char
20:29:53 <lambdabot>  '\1114111'
20:30:24 <drtomc>  Why 1114111?
20:30:46 <dolio> > showHex 1114111 ""
20:30:48 <lambdabot>  "10ffff"
20:31:45 <Pseudonym> In Haskell, \1114111 isn't in octal.
20:31:56 <Pseudonym> Not sure if that was the confusion; just saying.
20:32:23 <ddarius> KatieHuber: Most Haskellers would probably add a type signature over adding an argument.
20:32:27 <drtomc> Okay, so why 0x10ffff?
20:32:42 <ddarius> And yes, that's what eta expand means (for function types)
20:32:44 <drtomc> Pseudonum [sic]: it takes more than that to confuse me. ;-)
20:32:53 <Pseudonym> Figured. :-)
20:33:04 <Pseudonym> I realise not everyone is as tired as I am. :-)
20:33:06 <ddarius> (or more to the point, E ~> \x -> E x)
20:33:22 <drtomc> Too much Pirates?
20:33:23 <KatieHuber> drtomc: I suspect you need to ask the unicode consortium that question
20:33:31 <Pseudonym> Yup.
20:33:44 <Pseudonym> Basically, this is UCS-4.
20:34:03 <Pseudonym> 2^20 + 2^16 possible code points.
20:34:28 <Pseudonym> Well, UTF-32.
20:34:29 <Pseudonym> I guess.
20:34:47 <liyang> s/possible/defined as of Unicode 3.something/
20:35:06 <drtomc> Except that there is no such thing as UTF-32, and that's official!
20:36:19 <Pseudonym> http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G7404
20:36:36 <liyang> oh god.
20:36:46 <liyang> WILL THE MADNESS NEVER END?
20:38:01 <sjanssen> it isn't quite right to call [Char] UCS-4, or UTF-8, or any other encoding
20:38:21 <sjanssen> Char is an abstract entity representing a Unicode code point, String is just a list of them
20:38:29 <Pseudonym> Indeed.
20:38:31 <sjanssen> s/UTF-8/UTF-32
20:38:47 <drtomc> Exactly. [Char] is just that. It's not encoded per se.
20:39:16 <monochrom> Right.
20:39:21 <Pseudonym> What do you mean?!  All you need is to store a Unicode scalar value in a Char, and you have Unicode support!
20:39:23 <Pseudonym> Right?  Right>
20:39:28 <monochrom> Too much folklore misconception around Unicode.
20:39:44 <Pseudonym> I'm shocked, I tell you!
20:40:00 <drtomc> Yep. It's the conversion from sequences of bytes that's the tricky bit - where you have to pay attention to the encoding.
20:40:08 <KatieHuber> if I have two elements of an instance of Enum, how do I safely tell whether the one is the successor of the other?
20:40:15 <KatieHuber> obviously a == succ b has problems
20:40:35 <drtomc> Only if it derives Eq as well.
20:40:36 <ddarius> a == succ b || succ a == b ?
20:40:43 <KatieHuber> yeah, it derives Eq
20:40:56 <KatieHuber> problem is that just using succ on a random element will blow up when it's the maxBound
20:41:09 <drtomc> fromEnum perhaps?
20:41:17 <Pseudonym> I did let everyone know at the dress rehearsal last night that Talk Like a Pirate Day is next week.
20:41:19 <ddarius> Indeed null [a..b]
20:41:22 <drtomc> > fromEnum 'a'
20:41:30 <Pseudonym> Bad timing that it's this weekend.
20:41:34 <lambdabot>  97
20:41:36 <Pseudonym> The show, that is.
20:42:39 <monochrom> How do you talk like a Pirate Day, or talk like a Labour Day, or talk like a Christmas Day? ...
20:43:00 <liyang> abs (fromEnum a - fromEnum b) == 1
20:43:04 <liyang> (you can puke now.)
20:43:37 <liyang> (or -- please irradiate your hands)
20:43:58 <ddarius> isJust $ listToMaybe (do [_] <- [a..b]; return ())
20:44:15 <Boney> monochrom: you need #lojban.
20:44:29 <liyang> ddarius: won't work if a > b :-/
20:44:30 <monochrom> I think I do. :)
20:45:01 <ddarius> liyang: I was only going for succ a == b
20:45:27 <ddarius> isJust $ listToMaybe (do [_] <- [a..b]++[b..a]; return ())
20:45:42 * ddarius hugs unary.
20:46:53 <ddarius> :t (fromEnum,enumFrom)
20:46:56 <lambdabot> forall a a1. (Enum a, Enum a1) => (a -> Int, a1 -> [a1])
20:46:57 <liyang> Why not just length ([a..b] ++ [b..a]) == 1 ?
20:47:17 <ddarius> liyang: That would be inefficient.
20:47:19 <liyang> I mean, there's clever uses of the Maybe monad and then there's pointless uses...
20:47:34 <liyang> :-/
20:48:15 <liyang> Suppose you don't need to build up a big list if they're far apart. Still needlessly hard to read though.
20:48:38 <liyang> This is pointless micro-optimisation.
20:49:29 <ddarius> How could doing Enum arithmetic by going through lists be hard to read?!
20:49:40 <ddarius> Optimization?
20:49:52 * liyang doesn't care enough to continue. Apologies. :)
20:51:03 <ddarius> I need to work on making a girl my girlfriend and I need to sleep.  So that works for me.
20:51:47 <liyang> Have fun lol. I'm sure you will.
20:52:05 <dolio> @check \l -> isJust (listToMaybe l) == not (null (l :: [I]))
20:52:06 <lambdabot>  OK, passed 500 tests.
20:52:40 <dolio> @scheck \l -> isJust (listToMaybe l) == not (null (l :: [()]))
20:52:42 <lambdabot>   Completed 7 test(s) without failure.
20:56:39 <Trixsey> If I do "drop 2 myList" I loose the two first elements?
20:56:45 <Trixsey> three first?
20:56:55 <dolio> > drop 2 [1..10]
20:56:57 <lambdabot>  [3,4,5,6,7,8,9,10]
20:57:29 <Trixsey> >drop 2 ['A', 'B', 'C', 'D', 'E']
20:57:40 <Trixsey> > drop 2 ['A', 'B', 'C', 'D', 'E']
20:57:41 <lambdabot>  "CDE"
20:58:13 <Olathe> @src drop
20:58:14 <lambdabot> drop n xs     | n <= 0 =  xs
20:58:14 <lambdabot> drop _ []              =  []
20:58:14 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
21:01:21 <Trixsey> dolio, anywhere I can try my haskell stuff without having to install hugs or glasgow compiler etc? :p
21:01:26 <Trixsey> like, small programs
21:01:34 <dons> > "right " ++ "here?"
21:01:36 <lambdabot>  "right here?"
21:01:46 <Trixsey> It'd spam the channel, they are a few hundred lines
21:01:49 <dons> installing hugs should be easy though, its tiny
21:01:54 <dolio> You can open a private chat with lambdabot.
21:02:29 <dolio> Although, you have to write everything as one-liners.
21:02:32 <Trixsey> [06:01:45]  <Trixsey> > fib::Int -> Int
21:02:32 <Trixsey> [06:01:46]  <lambdabot>   Not in scope: `fib'
21:02:33 <dolio> Unless you use @let a bunch.
21:02:35 <Trixsey> yeah I noticed :p
21:02:41 <Olathe> @let f 0 = 1; f 1 = 1; f n = (f (n - 1)) + (f (n - 2))
21:02:45 <lambdabot> Defined.
21:02:48 <Olathe> > f 5
21:02:49 <lambdabot>  8
21:11:24 <Trixsey> I want to do a little project of my own in Haskell, but I can't think of anything
21:11:27 <Trixsey> What do you guys do in Haskell?
21:11:29 <Trixsey> Inspire me! :)
21:11:40 <Olathe> Trixsey: Do you like math or programming contests ?
21:12:41 <Trixsey> Olathe, my math skills sure suck so I could work on those I guess.. I <3 programming =)
21:16:42 <Olathe> Trixsey: You could find a programming contest site and do the work in Haskell instead.
21:17:10 <Olathe> If you want a math site that doesn't care what language you use: http://projecteuler.net/
21:17:11 <lambdabot> Title: Project Euler
21:17:21 <Olathe> But some of the problems are a bit advanced.
21:17:27 <JohnMeacham> got 'Foldable' 'Functor' and 'Traversable' deriving in DrIFT now.
21:18:37 <Trixsey> Olathe, I wrote my first set of functions in haskell this week, want to have a look? Maybe tell me how it looks? I could be writing crappy code for all I know :P
21:19:22 <Olathe> I'm not too good at Haskell yet ;)
21:19:41 <Trixsey> oh ok :p
21:19:42 <Olathe> That's what I'm doing to help learn it, though (try problems from contests).
21:20:18 <Trixsey> The contest is to get as far as possible?
21:20:22 <Trixsey> Or to be quick too?
21:20:29 <Trixsey> Because I'm usually not quick when I do things
21:20:32 <Trixsey> I like doing it at my own pace lol
21:28:42 <drtomc> Trixsey: A little while back, I posted to haskell-cafe about using a zipper to do terrain generation (e.g. for a game, or similar). That might be an interesting project for you.
21:36:26 <shachaf> cabal-install doesn't accept "moo"? :-(
21:38:18 <Olathe> Trixsey: On Project Euler, take as long as you need to program it, but the program has to solve the problem in less than a minute.
21:38:28 <sorear> shachaf: Neither does sid's apt-get:(
21:38:31 <Olathe> Trixsey: On other contests, it might be different.
21:38:43 <shachaf> sorear: They took it out?
21:38:53 <sorear> apparently :(
21:38:55 <shachaf> sorear: At least aptitude has it?
21:38:59 <shachaf> moo++
21:39:07 <shachaf> (-v and all?)
21:39:10 <glguy> Archlinux has "gmoo"
21:39:14 <glguy> the mud client
21:39:15 <sorear> stefan@stefans:~$ aptitude moo
21:39:15 <sorear> There are no Easter Eggs in this program.
21:39:28 <glguy> ?
21:39:30 <shachaf> sorear: That seems right. :-)
21:39:45 <shachaf> aptitude++
21:39:54 <glguy> aptitude -v moo
21:40:13 <glguy> keep adding -v for more fun, apparently
21:40:40 <shachaf> It's easier to put the -v after the moo.
21:40:52 <glguy> so you can just do: -vvv
21:43:15 <Trixsey> What do you guys recommend for MacOSX, a Haskell compiler I mean
21:43:19 <Trixsey> is it the glasgow one?
21:43:27 <Trixsey> or does hugs work here too? since it's bsd-based I mean
21:43:31 <Trixsey> unix
21:43:31 <Trixsey> :p
21:43:42 <dibblego> Trixsey, my Mac colleagues use GHC
21:43:43 <sioraiocht> Trixsey: GHC
21:43:44 <Cale> Trixsey: I used GHC mostly
21:43:55 <Pseudonym> Hugs also works, but most prefer GHC.
21:44:12 <sioraiocht> Trixsey: you can download binaries, but it also compiles pretty quickly
21:44:28 <Cale> GHC compiles pretty quickly?
21:44:36 <Trixsey> binaries, where? :o
21:44:36 <Cale> Maybe if you have a 16 core machine ;)
21:44:47 <sioraiocht> Cale: for a compiler, yes
21:45:07 <sioraiocht> I want a 16 core machine
21:45:16 <sioraiocht> I'd settle for quad or octal, though =p
21:45:41 <goalieca> i want 16 cores per node with each node have dual core full cpu, with the rest being specialized dsp or something
21:46:01 <drtomc> Trixsey: I'm using ghc on a mac mini.
21:46:03 <Trixsey> I'd like 1000 linked PS3's
21:46:30 <Trixsey> Where can I get binaries for intel macs? :o
21:46:41 <drtomc> So have you seen "Little Big Planet" - I'd buy a PS3 just for that once it's out.
21:46:50 <shachaf> The usual place?
21:47:02 <shachaf> It's not there?
21:47:02 <drtomc> I think there's a ports version.
21:47:18 <shachaf> http://haskell.org/ghc/download_ghc_661.html#macosxintel
21:47:19 <lambdabot> Title: GHC: Download version 6.6.1
21:47:31 <Trixsey> This is a standard unix-style binary package with GHCi and profiling libraries. You will also need a GMP framework  and a readline framework. See this message  for more details.
21:47:33 <Trixsey> it seems bothersome
21:47:36 <goalieca> gch takes a fscking long time to compile
21:48:10 <sioraiocht> it took a lot less time than gcc =p
21:48:50 <goalieca> gcc doesn't take that long actually
21:48:59 <goalieca> i used to use gentoo back in the day
21:49:00 <goalieca> ...
21:49:16 <bos> gcc builds in about 2 minutes on a decent machine
21:50:39 <Trixsey> So I can just use this binary?
21:51:13 <Trixsey> because last I downloaded it, it wanted me to ./configure, make, make install.. and complained about me not having a C compiler :S
21:51:27 <bos> you need a C compiler
21:51:38 <bos> and yes, you need to run that configure and make combo
21:51:41 <Trixsey> I thought this was pre-compiled?
21:51:50 <bos> it won't build anything, it's just rewiring some scripts
21:51:58 <bos> the mac binary is just awful :-(
22:15:35 <Trixsey> http://pastebin.com/d18abb360 <- Unexpected ";" on line 26, any idea what's up? :x
22:16:46 <Trixsey> nvm
22:17:03 <sjanssen> Trixsey: line 23
22:17:13 <sorear> !paste
22:17:13 <hpaste> Haskell paste bin: http://hpaste.org/
22:17:16 <ari> > [toUpper, toLower] `ap` "bcdfghjklmnpqrstvwxz"
22:17:18 <lambdabot>  "BCDFGHJKLMNPQRSTVWXZbcdfghjklmnpqrstvwxz"
22:17:35 <ari> ap++
22:17:35 <sorear> > ['b'..'z'] -- ari
22:17:37 <lambdabot>  "bcdefghijklmnopqrstuvwxyz"
22:17:56 <Trixsey> yes
22:17:59 <Trixsey> sjanssen, I fixed that
22:18:21 <Trixsey> I have another error now, on line 52
22:18:27 <Trixsey> Unexpected "p"
22:18:45 <Trixsey> So I think something is up with my merge function, some misplaced else if / then?
22:19:13 <ari> Trixsey: Line 48 needs to be indented
22:19:37 <Trixsey> haha ohh
22:19:42 <Trixsey> I didn't know it was that picky
22:20:22 <Trixsey> Error remains :(
22:20:23 <sjanssen> Trixsey: you should probably change those ifs into guards
22:20:40 <Trixsey> Guards? You mean "|"?
22:20:45 <sjanssen> right
22:21:51 <sjanssen> also, length xs == 0 is better written as null xs
22:22:39 <Trixsey> sjanssen, how do I write two ifs in each other with guards
22:22:40 <Trixsey> like
22:22:53 <Trixsey> if xy then if x...
22:24:34 <sjanssen> that code for merge has some logic errors, by the way
22:24:56 <Trixsey> =(
22:25:01 <glguy> if x then (if y then a else b) else c :   | not x = c  | y = a  | otherwise = b
22:25:33 <sjanssen> Trixsey: you're matching (x:xs) and (y:ys), then checking whether xs or ys are empty
22:25:44 <sjanssen> ie. you're checking for lists with a single element
22:25:59 <sjanssen> what you really want to do is check for lists with zero elements
22:26:38 <Trixsey> So you want me to check if x:xs or y:ys are null?
22:27:04 <sjanssen> well, we know that (x:xs) is not null, it has at least one element 'x'
22:27:16 <Trixsey> how do we know that?
22:27:17 <sjanssen> you should be matching the first parameter with []
22:27:35 <Trixsey> oh yeah
22:27:40 <sjanssen> Trixsey: (x:xs) means construct a new list with 'x' as the first elem, and 'xs' as the rest
22:27:53 <sjanssen> it follows that the list has at least one element :)
22:27:58 <Trixsey> sjanssen, yeah but x could be [] no?
22:28:04 <sjanssen> no
22:28:14 <glguy> well...
22:28:15 <sjanssen> @type (:)
22:28:17 <Trixsey> so if you pass an empty list it'll give an error?
22:28:23 <lambdabot> forall a. a -> [a] -> [a]
22:28:28 <glguy> []:[] is ok too :)
22:28:28 <sjanssen> Trixsey: yeah, in your current code it does
22:28:39 <ari> > []:[]
22:28:43 <lambdabot>  [[]]
22:28:45 <Trixsey> merge [] (y:ys) = y:ys
22:28:59 <Trixsey> merge (x:xs) [] = x:xs
22:29:03 <Trixsey> I should do that?
22:29:22 <sjanssen> what about the case where both are empty?
22:29:23 <Pseudonym> Trixsey: Well, it works.
22:29:35 <Pseudonym> merge [] ys = ys
22:29:40 <Pseudonym> merge xs [] = xs
22:29:46 <Pseudonym> That also works, and covers the both-empty case.
22:30:22 <Trixsey> oh ok
22:34:32 <Trixsey> http://pastebin.com/m15f3e4eb
22:34:33 <Trixsey> how about now?
22:34:41 <Trixsey> Is something wrong with my indentation? :(
22:35:06 <sjanssen> Trixsey: extra = on 6
22:35:24 <Trixsey> oh its not supposed to be there?
22:35:24 <sjanssen> Trixsey: btw, which compiler are you using?
22:35:42 <Trixsey> I didnt bother getting one for MacOSX
22:35:47 <Trixsey> I got WinHugs for my other comp
22:35:54 <sjanssen> ah
22:36:00 <sjanssen> ghc might give you better error messages
22:36:03 <Trixsey> In school we use solaris, and we have hugs98 pre-installed
22:36:05 <Trixsey> oh ok
22:40:20 <bos> how do i undo a "darcs setpref test"? set it to the empty string?
22:42:31 * bos shakes his fist at darcs. again.
22:43:47 <Trixsey> It says `ap` is an undefined variable on line 13 :S
22:44:18 <Trixsey> > [toUpper, toLower] `ap` ["hello"]
22:44:19 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
22:44:28 <Pseudonym> ?index ap
22:44:29 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
22:44:29 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
22:44:41 <Pseudonym> Control.Monad is the likeliest.
22:44:45 <Trixsey> > [toUpper, toLower] `ap` "hello"
22:44:46 <lambdabot>  "HELLOhello"
22:45:01 * ulfdoz throws a subversion binary at bos. Try to get happy with that. ;)
22:45:02 <Trixsey> > ps = [toUpper, toLower] `ap` "hello"
22:45:02 <lambdabot>  Parse error
22:45:07 <Trixsey> I can't store it?
22:45:23 <Japsu> ulfdoz: heresy!!!
22:45:33 <Trixsey> =(
22:45:33 <Japsu> ;)
22:46:12 <Pseudonym> Trixsey: Sorry, what do you mean by "can't store it"?
22:47:03 <ulfdoz> Japsu: I just migrated away from svn. Currently mercurial, because ghc doesn't compile in 128MB of RAM.
22:47:47 <bos> mercurial++
22:47:50 <bos> :-)
22:48:02 <Trixsey> Pseudonym, I'd like to store the output in a variable :)
22:48:10 <Trixsey> i.e
22:48:13 <Trixsey> > ps = [toUpper, toLower] `ap` "hello"
22:48:13 <lambdabot>  Parse error
22:48:15 <Trixsey> oops
22:48:18 <Trixsey> > ps = [toUpper, toLower] `ap` "hello"
22:48:18 <lambdabot>  Parse error
22:48:21 <Trixsey> wtf :S
22:48:21 <Pseudonym> On the GHC command line?
22:48:22 <drtomc> Do you mean bind a name to a value?
22:48:27 <Trixsey> yes
22:48:34 <Trixsey> Pseudonym, in a .hs file
22:48:35 <Pseudonym> There is no "store in a variable" in Haskell.
22:48:37 <Pseudonym> Ah.
22:48:50 <Trixsey> Well a reference to it or whatever :P
22:48:50 <Pseudonym> OK, well, that should work.
22:48:55 <Trixsey> its not working :S
22:49:07 <Trixsey> it says it doesnt recognize the VARIABLE `ap`
22:49:10 <Trixsey> its a FUNCTION ;_;
22:49:11 <Pseudonym> Ah.
22:49:22 <Pseudonym> Oh, well, we'll get to that misconception in a moment.
22:49:24 <Pseudonym> However.
22:49:25 <drtomc> There's no real distinction in haskell
22:49:29 <Pseudonym> You need to import Control.Monad.
22:49:33 <Pseudonym> Up the top of the .hs file.
22:49:41 <Trixsey> import Control.Monad
22:49:42 <Trixsey> like that?
22:49:43 <Pseudonym> Right.
22:49:54 <Pseudonym> Now the misconception:
22:50:08 <Pseudonym> What you call a "function" is actually a variable that just happens to have a function type.
22:50:36 <Pseudonym> :t undefined :: Int
22:50:38 <lambdabot> Int :: Int
22:50:42 <Pseudonym> :t undefined :: Int -> Int
22:50:44 <lambdabot> Int -> Int :: Int -> Int
22:50:58 <Pseudonym> See, the same thing can have either a function type or a non-function type.
22:51:17 <Pseudonym> So it's sometimes not even useful to make a distinction.
22:53:09 <drtomc> I would go further, and say that by eliminating a distinction, you emphasize that haskell deals exclusively with values
22:53:26 <Trixsey> Pseudonym, ok
22:54:33 <liyang> (Functions are values? Just don't bring up the monomorphism restriction!)
22:54:37 <ari> Trixsey: You could imagine, say, a value with type Int -> Int -> Int as a function of two arguments; Int -> Int as a function of one argument; and Int as a function of zero arguments :)
22:55:12 <sjanssen> of course you could also say that Int -> Int -> Int is a function of one argument :)
22:55:59 <drtomc> I'm trying to emphasize value vs reference and the consequent referential transparency
22:56:00 <glguy> SPJ said it himself, Haskell is value-oriented programming
22:56:16 <Trixsey> ok I think I get that part
22:56:27 <Trixsey> I could pretty much define anything as a reference to a value
22:56:36 <drtomc> reference => state/effects
22:57:00 <dibblego> what is the name of the DPA where you find the minimum number of coins that adds to some sum?
22:57:01 <Trixsey> the function `ap` was defined in monad?
22:57:12 <Pseudonym> :t ap
22:57:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:57:18 <Pseudonym> Yes, and that's why.
22:57:22 <Trixsey> oh ok
22:57:28 <drtomc> Well, what I'm getting at is that the usual notion of "storing" something in a variable involves reference
22:57:36 <Trixsey> :t toLower
22:57:38 <lambdabot> Char -> Char
22:57:40 <Trixsey> :p
22:57:51 <Trixsey> it says undefined variable toLower / toUpper
22:58:06 <ari> @index toLower
22:58:06 <lambdabot> Data.Char
22:58:14 <ari> > concatMap ($ "hello") [map toUpper, map toLower]
22:58:15 <lambdabot>  "HELLOhello"
22:59:41 <Trixsey> I need to use that syntax?
22:59:46 <drtomc> So in this context, "variable" means the name for a value, not a named slot with something stored in it.
23:00:29 <Trixsey> yeah but it worked in the terminal just now
23:00:47 <Trixsey> > [toUpper, toLower] `ap`"hello"
23:00:49 <lambdabot>  "HELLOhello"
23:00:52 <Trixsey> see?
23:01:02 <Trixsey> I can't just refer to that?
23:01:46 <ari> Trixsey: You can use either, it's just that you probably have a better chance of actually understanding my version than that at the moment :)
23:03:13 <Trixsey> what's the dollar sign?
23:03:39 <quicksilver> apply function to arguments
23:03:49 <drtomc> :t ($)
23:03:51 <lambdabot> forall a b. (a -> b) -> a -> b
23:03:54 <quicksilver> f $ x is just a strange way of writing f x
23:04:03 <quicksilver> however, it becomes very useful in sections
23:04:22 <quicksilver> ($ "hello") is "the function which, given a parameter, applies that parameter to hello"
23:04:48 <Trixsey> ari, they both give the same error though
23:04:55 <quicksilver> Trixsey: you need import Data.Char
23:05:01 <Trixsey> oh :S
23:05:03 <quicksilver> Trixsey: that's where toLower and toUpper liver
23:05:06 <drtomc> :t ($ "hello")
23:05:07 <lambdabot> forall b. ([Char] -> b) -> b
23:12:03 <Trixsey> http://pastebin.com/m503b5d3a <- On line 24 I get "unexpected type Char -> [Char]
23:12:11 <Trixsey> While both are strings (should be [Char]) grr
23:13:52 <ibid> Trixsey: you probably mean ++ and not :
23:14:07 <Trixsey> : is not merge? I guess concat shoud work too :p
23:14:11 <drtomc> ibid: beat me too it. :-)
23:14:21 <ibid> Trixsey: : is cons
23:14:21 <drtomc> :t (++)
23:14:23 <lambdabot> forall a. [a] -> [a] -> [a]
23:14:27 <ibid> Trixsey: (in lisp terminology)
23:14:32 <jbauman> > map ($ "hello") [toUpper, toLower]
23:14:32 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
23:14:35 <jbauman> oops
23:15:00 <ibid> Trixsey: : prepends a single new element to a list
23:17:58 <Trixsey> One last error, then I'm done.. (I know it since I uncommented it and it worked) :P
23:18:07 <Trixsey> in my merge function header
23:18:07 <Trixsey> I do
23:18:22 <Trixsey> merge::[a] -> [a] -> [a]
23:18:24 <Trixsey> but it says its wrong
23:18:33 <Trixsey> I want it to take two sorted lists and return one merged sorted list
23:18:42 <Trixsey> only the header is wrong, but its annoying
23:18:44 <ibid> Trixsey: you probably want to say that a is ordered :)
23:18:59 <ibid> Trixsey: i assume your merge does comparisons
23:19:03 <Trixsey> yeah
23:19:16 <ibid> Trixsey: so constrain a properly :)
23:19:22 <Trixsey> but I take two params of the type [a] and return [a] :S
23:20:01 <ari> Trixsey: merge :: Ord a => [a] -> [a] -> [a]
23:20:07 <ibid> Trixsey: yes, but your type says that any type is allowed as a, even if it doesn't support comparisons
23:20:21 <ibid> what ari said, i just tried to avoid giving the full answer :)
23:20:31 <Trixsey> oh ok
23:20:47 <Trixsey> so I have to explicitly state that its the a inherited from Ord
23:20:48 <Trixsey> meh
23:21:07 <ibid> Trixsey: yes. otherwise you allow also unordered types
23:21:46 <ibid> Trixsey: you are (usually) allowed to leave the type signature out, but if you do give it, it has to be correct :)
23:27:24 <Trixsey> Finally, I'm done correcting all small mistakes in the code :)
23:27:28 <Trixsey> It's working flawlessly!
23:28:45 <drtomc> Now the trick will be to refactor it over and over till it fits on a single line, uses monads, arrows, bananas, lenses, &c, &c
23:29:33 <drtomc> :-)
23:31:09 <Pseudonym> So... tht prime monads question...
23:31:13 <Pseudonym> Does anyone actually understand it?
23:31:36 <dolio> Nope. No one.
23:31:45 <Pseudonym> Where's Moggi when you need him?
23:31:53 <Pseudonym> He could come up with an equally impenetrable answer.
23:32:29 <drtomc> You mean it wasn't rhetorical? ;-)
23:32:59 <Trixsey> A question though, I'm running fibonaccis algorithm
23:33:06 <Trixsey> At very high numbers it becomes negative, how come?
23:33:10 <Trixsey> It's a series of additions
23:33:12 <Trixsey> :S
23:33:17 <Trixsey> Its out of Int's scope?
23:33:20 <Trixsey> and bugs?
23:33:25 <Trixsey> I should use Integer?
23:33:38 <ari> Trixsey: yes
23:38:11 <Trixsey> ari, ahh, did the trick :D
23:53:45 <kfish> tertium datur
23:57:52 <drtomc> bye all
