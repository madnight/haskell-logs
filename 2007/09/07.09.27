00:00:12 <jmob> Since there's no way to get a stack trace or implement a traditional debugger
00:00:28 <dmwit> Sometimes you can use hat, though I've never gotten it to work.
00:00:30 <sjanssen> jmob: there's a debugger coming with GHC 6.8.1
00:00:42 <Tac-Tics> If you can run it, you can debug it
00:00:53 <Tac-Tics> theoretically at least....
00:00:54 <dmwit> There's also Debug.Trace, which is kind of gross from a theory standpoint, but fairly convenient from a practicality standpoint.
00:01:18 <sjanssen> as convenient as printf-style debugging, at least
00:01:35 <dmwit> Well... yeah.
00:01:39 <jmob> What does hat do?
00:01:47 <Tac-Tics> I'd say Haskell is easier to debug than PHP in a lot of cases
00:01:50 <dmwit> I must say the debugging process is not my favorite part of Haskell.
00:01:59 <Tac-Tics> but then again, that's just my hatred for my job speaking
00:02:05 <dmwit> But I find myself needing a lot less debugging.
00:02:14 <dmwit> I know that sounds kind of... like... advocacy.
00:02:27 <sjanssen> good Haskell is split into smaller pieces that you can hopefully test/debug independently
00:02:36 <Tac-Tics> I wish ghc had a feature to help you track down type errors better
00:02:57 <Tac-Tics> like, a type evaluator that worked on programs which compile up to the typechecking phase
00:11:47 <Tac-Tics> It looks as if my work here is done
00:12:05 <Tac-Tics> Good night my monadic friends
00:13:54 <dmwit> So, his work is done when nobody talks for a while?
00:13:54 <Vq^> good morning arrow friends
00:13:58 <dmwit> tricky
00:14:01 <dmwit> Hi Vq^!
00:14:05 <dmwit> Your name is hard to type.
00:14:07 <Vq^> hi dmwit!
00:14:15 <reffie> :q!
00:14:17 <Vq^> just type Vq then :)
00:14:31 <dmwit> reffie: Wrong window. ;-)
00:16:00 <Vq^> welcome mr Grigoriev
00:16:23 <sjanssen> even Vq<tab> is a bit weird to type
00:16:40 <dmwit> Luckily, V<tab> is enough here.
00:16:59 <dmwit> Now, if I could just get a <tab> with no prefix to just enter my thoughts...
00:17:14 <dmwit> ?users
00:17:14 <lambdabot> Maximum users seen in #haskell: 420, currently: 362 (86.2%), active: 10 (2.8%)
00:17:15 <OceanSpray> We're workin' on that...
00:17:27 <sjanssen> yes, then we'll write all our programs by repeatedly pressing tab
00:17:41 <dmwit> heh
00:17:51 <OceanSpray> except our thoughts aren't 'perfect'
00:18:01 <Vq^> my thoughts wouldn't be very reliable, it better just write the right words
00:18:15 <OceanSpray> the only thing this program would accomplish is save our hands from having to type.
00:18:21 <OceanSpray> The output would still be the same.
00:18:25 <Boney> programs would be like:  code boobies, code code code boobies, code code.
00:18:26 <dmwit> Actually, I'd probably be fairly embarassed if all my thoughts went to this channel.
00:18:44 <Boney> also beer.
00:19:03 <sjanssen> OceanSpray: sure.  All we have to do to debug our programs is press tab some more
00:19:16 <OceanSpray> that would indeed save a lot of time.
00:38:48 <sizur> i can hear crickets
00:39:09 * omniscientIdiot shoots crickets
00:39:14 <omniscientIdiot> darned things
00:56:05 <omniscientIdiot> @. elite keal
00:56:05 <lambdabot> neED 1 +O Do A Whi|e 0 DoEz0rz !A. n33D 1 +0 D0 a WHIle 0 doez !a
00:58:12 <ivanm> what's the correct layout rule for an if...then... else? I'm trying to line up the if, then and else keywords underneath each other but ghci keeps complaining about parse errors :s
00:58:32 <glguy> ivanm: then and else need to be indented in a do block
00:58:32 <Botje> ivanm: then and else need to be indented one step more than if
00:58:40 <glguy> in a do block
00:58:52 <ivanm> *nod* why though?
00:59:01 <ivanm> (and yes, it's in a do block)
00:59:19 <glguy> because any line that starts on the left side of a do block is a new statement
00:59:26 <ivanm> ahhh, yes...
00:59:29 <ivanm> forgot about that :s
01:00:06 <doserj> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
01:00:10 <lambdabot> Title: DoAndIfThenElse - Haskell Prime - Trac, http://tinyurl.com/2khhmj
01:02:39 <ivanm> thanks for that, doserj... though I've been putting the "then" on a newline as well :p
01:02:58 * ivanm still hasn't worked out exactly what looks better for him for "if...then...else" expressions
01:03:40 <dmwit> I also find if/then/else mildly awkward.
01:03:50 <doserj> ivanm: that's the same issue
01:04:05 <ivanm> yeah, I know
01:04:11 <doserj> the proposal would allow it
01:04:17 <ivanm> *nod*
01:04:58 * ivanm wonders if maybe it would be better just to manually define the if' function that lambdabot is so fond of using, so that if statements are then like in lisp...
01:05:07 <doserj> i personally like if then else to be lined up
01:05:23 * dmwit really likes if'
01:05:36 <doserj> (trying to conserve precious horizontal space)
01:05:50 <ivanm> yeah, exactly
01:05:55 <glguy> I tend towards: if condition\n then this \n else that
01:06:02 <glguy> so it makes more sense for the then and else to both be indented
01:06:05 <glguy> (in my case)
01:06:12 <ivanm> the 80 column rule still holds :p (or 77 for Fortran77, IIRC)
01:06:24 <ivanm> glguy: *nod*
01:06:50 <doserj> I rather use horizontal space for longer identifiers than for "unnecessary" indentation
01:08:05 <doserj> dmwit: and yes, if then else really should be syntactic sugar for if' :)
01:10:14 <ivanm> well, I just tried using if' ... but when I had a do statement for a then expression, it complains of a parse input... might have to bracket it :s
01:12:16 <ivanm> doserj: well, the ticket associated with that issue hasn't been touched for 2 years by the looks of things :s
01:13:50 <doserj> according to http://hackage.haskell.org/trac/haskell-prime/wiki/Status%27, it is "definitely in" Haskell'
01:13:52 <lambdabot> Title: Status' - Haskell Prime - Trac
01:14:21 <quicksilver> I prefer guards to if then else in many cases
01:14:40 <quicksilver> and there's 'when' for a one-branch one, which is fairly common in a do block IMO
01:15:12 <quicksilver> but when I have a true two-branch I don't mind using if/then
01:15:17 <quicksilver> I try to avoid nesting them
01:16:06 <omniscientIdiot> if you have many cases you could use 'case () of _ | cond1 -> expr1; | cond2 -> expr2; ...'
01:16:17 <doserj> Does anyone know if there are any plans to push Haskell' forward, or discuss certain issues, next week in Freiburg?
01:16:34 <dmwit> ivanm: Did you try using ($) between if' and do?
01:17:02 <ivanm> ummm... no... :s
01:17:04 <quicksilver> doserj: I would also like ot know the answer to that
01:17:31 <ivanm> dmwit: but as it stands, if' doesn't have font highlighting so if...then...else looks better in my editor :p
01:17:37 <dmwit> heh
01:17:47 <quicksilver> doserj: speaking as an outsider it seems that someone with a bit of emotional energy should push haskell' forward a bit
01:18:24 <quicksilver> doserj: I'd rather have an imperfect haskell' (which was still better than haskell98) and see people start talking about haskell'', than we stick forever waiting for perfection
01:18:58 * ivanm can just imagine eventually having a haskell'''''''''''''' ;-)
01:19:22 <quicksilver> omniscientIdiot: it's often quite natural, in my opinion, to "name" the switch, make it a function and then you don't need the slightly ugly case () hack
01:20:31 <quicksilver> omniscientIdiot: but it would also be nice to have a "case |" syntax IMO
01:21:44 <dmwit> haskell^(vii) -- the seventh revision
01:25:15 <scodil> does anyone know of any code making use of type-level lists? Like "data Cons a b = Cons a b; data Nil; type ThreeList a = Cons a (Cons a (Cons a Nil))"? Perhaps in conjunction with type-level numbers?
01:26:29 <matthew-_> scodil: hlist
01:26:45 <matthew-_> (well, it does it differently, but it's kinda similar)
01:27:06 <dmwit> I think the real question here is, does anybody know of a type-level FizzBuzz implementation?
01:27:36 <matthew-_> scodil: plus I've written something sorta similar and in use at http://www.wellquite.org/non-blog/sessions-browseable/Control/Concurrent/Session/List.hs
01:27:38 <lambdabot> http://tinyurl.com/3e4e2y
01:29:30 <scodil> matthew-_: ah cool. yeah that's kind of what i was looking for.
01:30:52 <matthew-_> scodil: be careful - some of that sessions stuff only works with ghc 6.7 - I'm not sure which individual modules work with 6.6. The list stuff is fairly unexciting though so that probably does work with 6.6
01:32:04 <scodil> when writing code like that, is there anyway to get arround the accumulation of superclasses for each instance declaration? Like Append class to implement, say, a Sort class, then when I use Sort in again another function, I have to declare the operands to be instances of both Append and Sort, rather than just sort. In normal code this isn't that burdensome, but I'm getting up to like 10-15 instance declarations
01:32:47 <scodil> and they all have like 3 or 5 type parameters, and there's functional dependencies. its a mess.
01:33:53 <matthew-_> yeah - try looking at some of the other module there - 20 lines of type sigs to 3 lines of code!
01:33:58 <matthew-_> it's a problem ;)
01:34:43 <sjanssen> associated types might help, though the implementation is still a bit rough
01:53:07 <b_jonas> If haskell monads enable you to embed special languages in haskell code, including stateful ones with strict evaluation, then wouldn't it be better to use one of these more common impure and strict languages instead and embed lazyness or whatever you need with that language's equivalent of monads?
01:54:39 <opqdonut> no, because that doesn't work
01:55:03 <opqdonut> an impure system isn't restrictive enough, you couldn't enforce things nearly as well as with monads
01:55:37 <opqdonut> also, the mindset behind all this is essentially functional which means a functional language is nice
01:56:15 <opqdonut> and once we have pretty encapsulation with monads we have no need to make our language strict or impure (decicions which are usually forced on languages because of io and performance concerns)
01:56:35 <dmwit> b_jonas: Actually, monads don't enforce strictness.
01:56:47 <dmwit> Even with monads, you have to do strictness annotations if that's what you want.
01:57:06 <dmwit> That's one of the really cool things about monads: we can enforce *sequencing* without enforcing strictness.
01:57:21 <dmwit> The cool thing about that is you can still build infinite monads without exploding your computer.
01:57:40 <opqdonut> yes, good point
01:58:02 <dmwit> Even more important (because it is more common), you can build up enormously complicated monadic actions, and only the bits that need to be evaluated are.
02:00:23 <b_jonas> dmwit: sure they don't
02:00:34 <b_jonas> you can just use them to implement anything, including strictness
02:00:46 <dmwit> Mmmm... I don't think so.
02:01:14 <dmwit> You need the compiler built-in "seq" and !-annotations to get real strictness.
02:01:20 <dmwit> Or, what did you mean by strictness?
02:01:48 <b_jonas> well, you could build a language of all strict primitives
02:02:00 <b_jonas> with seq or something equivalent
02:02:27 <b_jonas> actually strictness isn't really important
02:02:37 <b_jonas> it's state and io instead
02:02:55 <b_jonas> what IO and stuff can do
02:04:16 <b_jonas> as an unrelated note,
02:04:24 <b_jonas> you know what I find strange in haskell?
02:04:29 <b_jonas> it's the semantics of case
02:04:52 <b_jonas> case forces to evaluate the expression you case on
02:05:00 <b_jonas> that seems illogical a bit
02:05:06 <dmwit> No it doesn't!
02:05:30 <b_jonas> > case undefined of _ -> 1
02:05:33 <lambdabot>  1
02:05:39 <b_jonas> hmm, it indeed doesn't
02:05:51 <b_jonas> good
02:05:54 <dmwit> > case (repeat 1) of { [] -> "one thing"; (x:xs) -> show x; _ -> "what happened here?" }
02:05:55 <lambdabot>      Warning: Pattern match(es) are overlapped
02:05:55 <lambdabot>              In a case alterna...
02:06:04 <dmwit> > case (repeat 1) of { [] -> "one thing"; (x:xs) -> show x }
02:06:06 <lambdabot>  "1"
02:06:15 <b_jonas> but then what is this they say about case and let?
02:06:29 <b_jonas> how is case with one arm different from let?
02:06:44 <b_jonas> is it that the let pattern is lazy by default?
02:06:55 <dmwit> Who said what now?
02:07:06 <b_jonas> > let Just x = Nothing in 1
02:07:07 <lambdabot>  1
02:07:21 <b_jonas> > case Nothing of Just x -> 1
02:07:22 <lambdabot>   Non-exhaustive patterns in case
02:07:27 <doserj> b_jonas: pattern matching (as in case x of (Just y)) is strict
02:07:41 <doserj> b_jonas: pattern "bindings" in let are lazy
02:08:04 <b_jonas> so is that let thing equivalent to 'case Nothing of ~(Just x) -> 1' ?
02:08:28 <doserj> let Just x = ... may give a runtime error
02:09:20 <doserj> if the ... evaluates to Nothing and you use the x somewhere
02:10:23 <doserj> b_jonas: yes
02:12:19 <b_jonas> and matching undefined to _ or matching undefined to a variable both succeed only that variable becomes undefined, right?
02:12:55 <sizur> is there any Continuous Integration product available for Haskell?
02:13:26 <doserj> @src undefined
02:13:26 <lambdabot> undefined =  error "Prelude.undefined"
02:13:58 <doserj> matching a variable to undefined binds "error ..." to that variable
02:15:03 <b_jonas> I see
02:15:11 <b_jonas> that's logical
02:15:14 <doserj> "undefined" is a perfectly defined value :)
02:16:42 <b_jonas> another unrelated question. is it a good thing to instance a type to Eq even if the equalty-comparision of that type is VERY slow?
02:19:23 <greenrd> b_jonas: if you're only going to use it for debugging or other things where speed doesn't matter so much, it might make sense, for example
02:19:58 <greenrd> It seems to me that the Writer and State monads offer similar functionality, only the Writer monad is tailored to an appending situation
02:20:23 <greenrd> Any particular advantage that Writer has over State, or vice-versa? (likewise for WriterT and StateT)
02:21:35 <b_jonas> I don't understand why the basic facilties of the IO monad and the file operations are in the same module (file:///usr/share/doc/ghc6-doc/html/libraries/base/System-IO.html)
02:22:26 <Cale> b_jonas: Which stuff is basic and which isn't?
02:22:47 <b_jonas> basic is the definitions of IO I mean
02:23:33 <b_jonas> actually you could say that module only has file io
02:23:46 <Cale> If you only have the definition of the IO monad, you can't do anything with it.
02:23:57 <Cale> Because it doesn't export its constructor.
02:24:19 <b_jonas> you can return
02:24:29 <b_jonas> but it's true that you can't do anything with it
02:24:38 <b_jonas> maybe my problem is why that module is called "IO"
02:24:47 <b_jonas> when the IO monad is called "IO" as well
02:26:00 <b_jonas> alternately, you could have just some debugging print operators but no file open in that module
02:26:19 <b_jonas> file io is partitioned between modules in that way in ruby and python and lua for example:
02:26:45 <dmwit> IO.liftIO :: IO.MonadIO m => IO.IO a -> m a -- Just for fun, how many IO's can you get in one type signature?
02:27:06 <b_jonas> (actually, not in ruby)
02:28:59 <Cale> :t let f = join . join; g = f . f; h = g . g in h
02:29:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m (m (m (m (m (m (m a)))))))) -> m a
02:29:14 <b_jonas> ST is like an IO that is restricted so that it cannot affect the Outside World but for that you get that you can run ST computations as a pure calculation, right?
02:29:21 <Cale> :t let f = join . join; g = f . f; h = g . g; k = h . h; l = k . k in l
02:29:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m (m a)))))))))))))))))))))))))))))))) -> m a
02:29:30 <Cale> Now specialise to the IO monad :)
02:29:35 <dmwit> =P
02:30:23 <dmwit> I find it mildly surprising that the process gives you 2^n+1 nested monads.  The (+1) bit throws me off.
02:30:25 <osfameron> I have an interesting (but annoying) book http://www.amazon.co.uk/Programming-Language-Design-Concepts-David/dp/0470853204 which criticises the "Can't get out of the IO monad" thing, suggesting it makes haskell only good for those programs which can be naturally split into Pure and Action parts
02:30:28 <lambdabot> http://tinyurl.com/3dymk6
02:30:45 <osfameron> of course the book also talks a whole lot of nonsense about Perl and others, but it's an interesting survey...
02:31:28 <dmwit> If it talks nonsense about other languages, what makes you think it's making sense about Haskell?
02:31:37 <b_jonas> perl has a different kind of nonsense than haskell
02:32:03 <osfameron> dmwit: oh, I didn't say I thought it was right.
02:32:10 <dmwit> aha
02:32:36 <osfameron> dmwit: but he seemed to know a bit more about haskell than Perl (which he didn't cover, dismissing it as "old fashioned" unlike Python), and that statement caught my mind as "interesting"
02:32:49 <dmwit> Yeah.
02:33:08 <dmwit> I wonder if he mentioned any areas he thought were particularly bad for splitting that way.
02:33:20 <kfish> osfameron, it sounds more like an extended blog article than a book
02:33:22 <osfameron> no.  That would have been more interesting
02:33:47 <dmwit> (As a side note, I am composing a program which has almost no "pure" -- non-monadic -- code at all, and I don't find it terribly cumbersome or bad.)
02:34:07 <osfameron> kfish: well, a second hand quote on irc from an ignoramus like me probably doesn't render it very well... it's a survey of different types of programing languages, roughly following (apparently) his course at Glasgow University
02:35:25 <Taejo> :t ("foo" ++) . show
02:35:27 <lambdabot> forall a. (Show a) => a -> [Char]
02:35:27 <araujo> osfameron, what kind of programs can't be split into those two models? :-P
02:35:36 <Taejo> let f = ("foo" ++) . show
02:35:45 <Taejo> @let f = ("foo" ++) . show
02:35:46 <lambdabot> <local>:3:17:     Ambiguous type variable `a' in the constraint:       `Show ...
02:36:02 <Taejo> what does that mean?
02:36:35 <b_jonas> araujo: the problem is, as I see it, that while most programs can be naturally split to an io and a computation part, the computation part does some io as well
02:36:55 <EvilTerran> monomorphism restriction?
02:37:14 <EvilTerran> @let f :: a -> [Char]; f = ("foo" ++) . show
02:37:15 <lambdabot> <local>:3:35:     No instance for (Show a)       arising from use of `show' a...
02:37:26 <greenrd> Hmm, I guess the difference between State and Writer is that with Writer, you can only get the logged data by having a reference to the computation that contains it
02:37:28 <EvilTerran> @let f :: Show a => a -> [Char]; f = ("foo" ++) . show
02:37:29 <lambdabot> Defined.
02:37:45 <araujo> b_jonas, that still falls into the action model
02:37:51 <greenrd> Whereas with State, you can get the logged data with get, at any time
02:37:52 <araujo> what's wrong with that?
02:38:16 <araujo> Plus, you pretty much can isolate actions using monads
02:38:25 <araujo> From the rest of the pure code
02:38:52 <araujo> I mean .. that's the point of the IO monad
02:39:50 <b_jonas> probably depends on the kind of programs you write
02:39:58 <b_jonas> and my inexperience in haskell
02:40:06 <araujo> b_jonas, that's why i asked what kind of programs wouldn't fit well here
02:40:09 <b_jonas> (because of that, I probably can't see how to split well)
02:40:10 <dmwit> Taejo: Did you follow what EvilTerran did there?
02:40:16 <araujo> i really can't think of any kind
02:40:19 <b_jonas> well, I've been writing some irc bots
02:40:26 <b_jonas> with threading
02:40:32 <b_jonas> and debugging output all over them
02:40:33 <dmwit> b_jonas: Have you heard of lambdabot? ;-)
02:40:37 <b_jonas> sure I have
02:40:42 <Taejo> dawit, I don't understand why my way doesn't work, but I understand what his means
02:41:03 <b_jonas> dmwit: but lambdabot executes haskell expressions
02:41:19 <dmwit> Taejo: There is a much debated rule called the "monomorphism restriction", which says that top-level functions must not have type variables.
02:41:31 <EvilTerran> top-levels with no parameters!
02:41:48 <doserj> simple pattern bindings
02:41:52 <osfameron> araujo: yeah, I wondered.  I couldn't think of any cases, but I'd have preferred that statement to have given examples rather than just asserting it like that
02:41:58 <Taejo> dawit, is this only in the interpreter?
02:42:12 <doserj> no
02:42:22 <b_jonas> otoh, some parts of my irc bot count ugly even in ruby
02:42:34 <dmwit> Taejo: Even in compiled code.  The result is that if you don't explicitly declare the type variables, it will be specialized to a certain "default".
02:42:36 <b_jonas> it does some very illegal and sometimes unsafe things with threading
02:42:41 <araujo> One thing we have to be aware of , is that a function of type , f :: a -> IO a , is indeed a pure function
02:42:46 <osfameron> goddam, I wish some of our legacy code has separation between side effects and pure code
02:42:55 <b_jonas> it would be possible to rewrite some of it a bit cleaner
02:42:58 <dmwit> Taejo: Probably the things I am saying are subtly wrong.  You can read more about it online now that you know the name.
02:43:06 <araujo> It just contains a computation with side-effects which is encapsulated inside such a monad.
02:43:14 <araujo> That's a slight detail sometimes is confusing.
02:43:20 <Taejo> dawit, I see... I hadn't noticed that since when I'm writing actual programs I usually declare types
02:43:38 <araujo> osfameron, me too by far
02:43:49 <araujo> i really would like to see examples
02:48:47 <b_jonas> ok, I'll now try to write some real program
02:49:20 <b_jonas> s/real/toy but working/
02:49:30 <araujo> b_jonas, learning Haskell?
02:49:57 <b_jonas> yes
02:50:02 <araujo> nice
02:50:03 <EvilTerran> Taejo, you can also get around it with -fno-monomorphism-restriction
02:50:06 <araujo> learning Haskell is fun
02:50:18 <Taejo> EvilTerran, thx
02:50:23 <b_jonas> for starter, I'm writing a program that has mostly pure parts
02:50:25 <araujo> b_jonas, do you have any book?
02:50:26 <EvilTerran> or {-# LANGUAGE NoMonomorphismRestriction #-} in your file
02:50:33 <b_jonas> no, not about haskell
02:50:34 <araujo> b_jonas, yes, that's a good way to start
02:50:47 <araujo> b_jonas, ok, there are very good tutorials on haskell.org
02:50:53 <b_jonas> yep, I've read some of them
02:51:46 <b_jonas> namely, http://www.haskell.org/tutorial/, and parts of some others
02:51:47 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
02:52:27 <b_jonas> plus map (parts of) [the report, the ghc user manual, the ghc library docs]
02:52:31 <araujo> YAHT is also a good one
02:53:12 <b_jonas> I'm going to write functions that can compare symbolic expressions containing square roots
02:53:20 <b_jonas> I have the algorithm in my head
02:53:26 <b_jonas> (I hope it works)
02:53:33 <b_jonas> it's very inefficent
02:53:50 <b_jonas> and involves two mutually recursive data types
02:53:56 <araujo> Taking an algorithm from your head to haskell is usually easier than using other language
02:54:31 <b_jonas> and repeatedly squaring two sides of an inequation while doing the minimal set of other operations required
02:54:35 <araujo> That's why i usually prototype on Haskell for programming on other languages.
02:54:44 <b_jonas> I thought to write this in haskell because this oen desparately needs _strong typedness_
02:55:14 <b_jonas> that wouldn't exclude other strong typed languages of course
02:55:29 <dmwit> b_jonas: Today radicals, tomorrow Mathematica. ;-)
02:55:33 <araujo> Haskell has this nice thing called: 'lazy evaluation' too
02:55:38 <b_jonas> but funnily lazyness will actually lower the memory requirements of this one
02:55:41 <b_jonas> yep
02:55:45 <araujo> that might help you there
02:55:50 <b_jonas> dmwit: well no, I cannot handle radicals
02:55:53 <b_jonas> only square roots
02:56:04 <b_jonas> radicals need some more complicated things I belive
02:56:11 <dmwit> ...
02:56:18 <b_jonas> (like converting to rootofs and Sturm-chains or something)
02:56:25 * dmwit thought radicals were just the name for the symbol used to denote square roots
02:56:30 <dmwit> sorry
02:56:58 <b_jonas> it is, (though the typographical symbol is also called "surd"), but it's also the one for nth roots
02:57:08 <b_jonas> for n :: Integer
02:57:15 <dmwit> Oh, right.
02:58:09 <b_jonas> on the other hand, if you add some optimizations and simplifications to this, you might get something as useful as mathomatic
02:58:29 <b_jonas> but I've no idea how to write an equation solver like the one in mathomatic
02:58:40 <b_jonas> (I'm not handling symbolic variables, just integers)
03:03:47 <b_jonas> ok, actually it's four types circularly recursive, but only two of them will have operations
03:08:04 <dmwit> Really, four circularly recursive types?
03:08:34 <dmwit> Not a type with four self-recursive constructors?
03:08:55 <b_jonas> no, it's four types each of which depend on the cyclically next one
03:09:01 <dmwit> (I don't doubt you, I'm just surprised because I haven't seen it before.)
03:09:04 <b_jonas> but two of them are insignificant
03:09:13 <b_jonas> and could be eliminated
03:09:19 <b_jonas> to just newtypes or something
03:09:45 <b_jonas> and those two mostly don't have any functions that act on them (apart from equalty)
03:10:02 <b_jonas> I need them for the expressive name of their constructors
03:10:48 <b_jonas> so that instead of just a list of stuff, I have a Product of list of stuff so I never accidentally use that list in any other way than a product
03:11:32 <dmwit> Yes, that is a very nice way to use the type system.
03:12:15 <b_jonas> and I need strict typeing to easily ensure that I only put those types into such a list that I want to
03:12:49 <b_jonas> I use lists because the library has lots of convenient list functions
03:22:50 <b_jonas> when you program haskell, do you bind some the digraphs -> <- to the 102th key or something? how can those be typed?
03:23:28 <wolverian> I don't think anyone actually uses those, outside of papers.
03:23:38 <ivanm> b_jonas: first by entering a hyphen and then a greater than sign for the first one... :p
03:23:55 <wolverian> or do you mean a shortcut for typing '->'. wow, you're lazy. :)
03:23:59 <b_jonas> I mean the two-character sequences
03:24:18 <b_jonas> it requires some tricky finger movement
03:26:10 <hpaste>  ivanm pasted "Infinite STM loop" at http://hpaste.org/2961
03:27:51 <b_jonas> or maybe you just let local names to functions instead of using \ ->
03:28:33 <quicksilver> I've nev er found -> hard to type
03:30:37 <Vq^> b_jonas: what keyboard do you have?
03:30:47 <EvilTerran> i have "multimedia keys", nominally for back and forward, by my arrow keys. i guess i could rebind those to produce "<-" and "->", but i haven't felt the need to
03:30:58 <b_jonas> us-english keyboard with 104 keys
03:31:03 <b_jonas> us-english layout mostly
03:31:15 <b_jonas> with caps-lock rebound as an extra modifier
03:33:47 <Vq^> i guess it's easier with a swedish 105keys keyboard
03:34:12 <b_jonas> actually, I value the left shift more than a 102th key
03:34:35 <b_jonas> that's why bought a us-english variant instead of a (102 key) hu variant which are available more here
03:34:55 <b_jonas> the 102 key one have the bottom row shifted differently and the left shift less reachable
03:35:20 <b_jonas> (where 102 key means 105 key really because of these windows buttons)
03:35:20 <ivanm> anyone got any idea what I'm doing wrong with that code I've hpasted above?
03:35:42 <ivanm> b_jonas: not necessarily... I think you can still get keyboards without the windows keys...
03:35:51 <ivanm> admittedly, you might have to look pretty hard for them :p
03:36:04 <b_jonas> ivanm: sure, you can
03:36:36 <b_jonas> but that's not so important as getting a good quality keyboard and one without the 102th key
03:36:41 <Vq^> the right and left win-keys might be good for -> and <- :)
03:36:50 <b_jonas> (and a black one so it matches the room and the computer)
03:37:32 * ivanm uses the windows key as his keyboard layout switcher
03:37:42 <b_jonas> ivanm: yes, that's reasonable
03:37:49 <ivanm> b_jonas: happy hacking keyboard maybe?
03:37:54 <b_jonas> I don't switch layouts because I don't want to learn two
03:37:58 <ivanm> heh
03:38:04 <ivanm> two languages = two layouts :p
03:38:12 <b_jonas> no, it's one layout for me
03:38:21 <b_jonas> with the hungarian characters with capslock
03:38:37 <b_jonas> but I don't want to have the symbols at a different place for the two languages
03:38:51 <b_jonas> and the hungarian layout sucks anyway (more than the generic qwerty I mean)
03:39:22 <osfameron> Italian layout is terrible:  no ~ or `  - awful for unix/perl
03:39:28 <b_jonas> it's derived from old typewriters
03:39:44 <b_jonas> ok, not _that_ old typewriters that only had half of the hungarian letters
03:40:12 <ivanm> I hate the default polyphonic Ukrainian layout... maybe cos its written for Europeans or Americans, which have different phonetic pronounciations :s
03:40:58 <EvilTerran> http://www.artlebedev.com/everything/optimus/ !
03:41:06 <lambdabot> Title: Optimus Maximus keyboard
03:41:43 <ivanm> EvilTerran: yes... if you can afford it :p
03:41:59 <b_jonas> as for the all-black one, that's a valid option, my friend's made one by painting a normal one
03:42:03 <EvilTerran> http://www.daskeyboard.com/ ?
03:42:04 <ivanm> I mean, > US$1.5k for a keyboard is a _little_ much, don't you think?
03:42:05 <lambdabot> Title: Das Keyboard - The Blank Keyboard for Demanding Users.
03:42:12 <b_jonas> (though I think his is all-white)
03:42:43 <EvilTerran> i have a battered model M, and a can of black spraypaint...
03:43:13 <EvilTerran> i'd want to make sure i could get it working on USB first, tho - it's only got a PS2 plug
03:43:47 * therp recommends kinesis keyboards
03:43:49 <b_jonas> EvilTerran: oh yeah
03:44:17 <quicksilver> don't think I'd like the clickiness of daskeyboard
03:44:35 <b_jonas> I had a good old compaq keyboard with an at plug and an at->ps2 converter that didn't completely work on new mainboards
03:44:50 <b_jonas> even though I plugged it to the ps2 port, not the usb port
03:45:02 <b_jonas> why can't they comprehensively test a mainboard with all sorts of hardware? :)
03:45:10 <EvilTerran> i like the clickiness of the model M, actually. i'm annoyed i can't plug it in.
03:45:23 <b_jonas> I still used to use it despite the small problems
03:45:31 <ivanm> @hoogle debug
03:45:32 <lambdabot> Network.Socket.Debug :: SocketOption
03:45:32 <lambdabot> Text.Html.debugHtml :: HTML a => a -> Html
03:45:32 <lambdabot> Test.QuickCheck.Batch.debug_tests :: TestOptions -> Bool
03:45:37 <b_jonas> until it worn off too much
03:46:03 <EvilTerran> i think you can get adapters for PS2->USB, but i'm not sure if they work with the power requirement of an M
03:46:35 <therp> http://www.kinesis-ergo.com/contoured.htm <- no more RSI issues for me.
03:46:37 <lambdabot> Title: Kinesis US Model Contoured Keyboards
03:46:43 <b_jonas> you could plug the M in an older pc and use some software solution to redirect it
03:47:27 <EvilTerran> i do have the PS/1 it came with sitting on the desk next to me
03:47:28 <b_jonas> I like the original ibm 101 key layout, I wonder why they don't make keyboards with exactly that layout anymore
03:47:40 <b_jonas> why do they have to innovate with the layout?
03:47:53 <EvilTerran> unfortunately, it doesn't have any two-way ports in common with my laptop, AFAICT.
03:47:59 <b_jonas> it's difficult to get a classic layout 10{1,2,4,5} key one nowdays
03:48:24 <EvilTerran> i'd have to get a serial/usb adapter or something
03:48:32 <b_jonas> my compaq had the calssical 101 key layout and the right clicky feeling when you pressed the keys
03:50:11 <b_jonas> my current ones has a messed-up layout as well
03:50:22 <b_jonas> s/ones/one/
03:54:11 <iguana_> what is the easiest way to convert a color spec ala "#abcdef" or "#abc" to a (r, g, b) tuple?
03:58:50 <EvilTerran> > map (read.("0x"++)) . (\('#':r:r':g:g':b:b':[])->[[r,r'],[g,g'],[b,b']]) $ "#C0FFEE"
03:58:52 <lambdabot>  [192,255,238]
03:59:53 * EvilTerran notes that ['#',r,r'...] also works. also that there must be a better way of doing it.
04:01:09 <sek> if i'm using Parsec's buildExpressionParser, how can i implement an unary operation?
04:01:24 <EvilTerran> @hoogle base
04:01:24 <lambdabot> Text.Html.base :: String -> HtmlAttr
04:01:24 <lambdabot> Test.HUnit.Base :: module
04:01:24 <lambdabot> Text.Html.basefont :: Html
04:01:24 <ivanm> therp: I've got the M$ ergonomic 4000 keyboard... couldn't find the kinesys one :s
04:01:30 <EvilTerran> @hoogle+
04:01:30 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
04:01:31 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
04:01:31 <lambdabot> Text.Html.codebase :: String -> HtmlAttr
04:01:34 <EvilTerran> @hoogle+
04:01:34 <lambdabot> Text.Html.thebase :: Html
04:01:34 <lambdabot> Language.Haskell.TH.nameBase :: Name -> String
04:01:41 <EvilTerran> bah. no readIntAtBase?
04:01:52 * ivanm just has to find a mouse that won't hurt his wrist now :s
04:01:59 <iguana_> no, doesn't look like :(
04:02:07 <EvilTerran> iguana_, my approach would be to implement a scanf library and then use that :P
04:02:15 <iguana_> you'd think it's a quite primitive operation
04:03:00 <Sizur> guys, does Haskell have any sort of Continuous Integration system? or can any CI system be used with Haskell?
04:03:02 <scook0_> I have a hard time believing there's *nothing* in the libs ...
04:03:06 <doserj> :t readInt
04:03:08 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
04:03:31 <doserj> that is readIntAtBase
04:03:36 <EvilTerran> huh.
04:03:40 <EvilTerran> yay consistency!
04:04:05 <EvilTerran> > digitToInt 'f'
04:04:06 <iguana_> ah, there's readHex
04:04:07 <lambdabot>  15
04:04:14 <iguana_> :t readHex
04:04:15 <EvilTerran> @src readHex
04:04:15 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:04:16 <lambdabot> forall a. (Num a) => String -> [(a, String)]
04:04:25 <EvilTerran> :t isHexDigit
04:04:27 <lambdabot> Char -> Bool
04:04:27 <sieni> > digitToInt 'z'
04:04:29 <lambdabot>  Exception: Char.digitToInt: not a digit 'z'
04:05:16 <EvilTerran> @check liftM2 (==) (readInt isHexDigit digitToInt) readHex
04:05:16 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Int'
04:05:30 <EvilTerran> @check liftM2 (==) (readInt 0 isHexDigit digitToInt) readHex
04:05:31 <lambdabot>  OK, passed 500 tests.
04:05:45 <EvilTerran> wait, what's that first parameter to readInt? it's the base, isn't it
04:05:51 <Sizur> does anybody here thing that Continuous Integration is important?
04:05:58 <Sizur> think*
04:06:02 * EvilTerran notes that that shouldn't've passed. hm.
04:06:03 <iguana_> readInt 0 isHexDigit digitToInt "ff"
04:06:06 <iguana_> > readInt 0 isHexDigit digitToInt "ff"
04:06:07 <lambdabot>  [(15,"")]
04:06:21 <iguana_> huh?
04:06:23 <EvilTerran> :t showHex
04:06:25 <lambdabot> forall a. (Integral a) => a -> String -> String
04:06:28 <iguana_> ah well
04:06:39 <iguana_> > readInt 16 isHexDigit digitToInt "ff"
04:06:40 <lambdabot>  [(255,"")]
04:06:44 <EvilTerran> @check liftM2 (==) (readInt 16 isHexDigit digitToInt) readHex . (showHex :: Int -> String)
04:06:45 <lambdabot>  Couldn't match expected type `String' against inferred type `ShowS'
04:06:57 <iguana_> @src readInt
04:06:57 <lambdabot> Source not found. Wrong!  You cheating scum!
04:07:01 <EvilTerran> @check liftM2 (==) (readInt 16 isHexDigit digitToInt) readHex . (($"") . showHex :: Int -> String)
04:07:02 <lambdabot>  Exception: Numeric.showIntAtBase: applied to negative number -3
04:07:38 <EvilTerran> @check \i -> (i > (0 :: Int)) ==> liftM2 (==) (readInt 16 isHexDigit digitToInt) readHex . ($"") . showHex)
04:07:38 <lambdabot>  Unbalanced parenthesis
04:07:52 <EvilTerran> @check \i -> (i > (0 :: Int)) ==> (liftM2 (==) (readInt 16 isHexDigit digitToInt) readHex . ($"") . showHex $ i)
04:07:53 <lambdabot>  OK, passed 500 tests.
04:07:56 <EvilTerran> there we go!
04:08:02 <doserj> readDec, readOct, readHex :: (Integral a) => ReadS a
04:08:03 <doserj> readDec = readInt 10 isDigit    digitToInt
04:08:03 <doserj> readOct = readInt  8 isOctDigit digitToInt
04:08:03 <doserj> readHex = readInt 16 isHexDigit digitToInt
04:08:14 <doserj> is in the report :)
04:08:19 <EvilTerran> okay, looking at the source would work better, yes
04:08:24 <EvilTerran> why aren't those in @src?
04:15:11 <therp> ivanm: I switch from an old MS ergonomic model to kinesis. feels much better.
04:15:44 <ivanm> well, australia is the technological backwater of the western world :p
04:16:12 <ivanm> and the M$ one was the only one I could find here (kinesys might be available down south, not sure)
04:17:48 <therp> ivanm: I imported the kinesis keyboard from the US ;).. it's not much different here
04:18:03 <ivanm> heh.... I wanted to try before I bought
04:25:30 <SamB_XP> ivanm: is that account of australia being in the east?
04:25:35 <SamB_XP> *on
04:32:58 <ivanm> SamB_XP: no, just that its apparently so far away from europe, US, etc
04:36:38 <matthew_-> I tried a kinesis for half an hour which isn't really fair on it. I didn't get on with it though.
04:36:52 <matthew_-> I'm currently on a Das Keyboard II which has a very nice action...
04:37:09 <cognominal_> how successfull is pl as a tool to detect function equivalence?
04:39:53 <hpaste>  ivanm annotated "Infinite STM loop" with "Updated with debugging support" at http://hpaste.org/2961#a1
04:40:10 <ivanm> any ideas why this won't work?
04:40:14 <sclv-away> cognomial: have you looked at dr. haskell?
04:40:51 <sclv-away> (i couldn't get a decent build with the head of yht though last i tried, needs some cleaning up)
04:41:07 <cognominal_> sclv-away? no. what is is? url?
04:42:06 <sclv> @go "dr. haskell"
04:42:08 <lambdabot> http://www.nrlc.org/abortion/pba/pbafact10.html
04:42:08 <lambdabot> Title: For what reasons are partial-birth abortions usually performed?
04:42:14 <sclv> oops
04:43:00 <cognominal_> that sounds weird indeed :)
04:43:32 <sclv> ah. here we are: http://www-users.cs.york.ac.uk/~ndm/drhaskell/
04:43:33 <lambdabot> Title: Neil Mitchell - Dr Haskell
04:45:01 <sclv> it uses yhc internal representation to match code against code "patterns" -- finding, e.g., functions that are explicit versions of foldr or foldl' etc. You can add your own patterns too
04:45:26 <doserj> ivanm: "else retry" looks suspicous. How do make progress with that?
04:46:12 <ivanm> doserj: the point is, its meant to wait until the next time loop... but I get what you mean :s
04:46:26 <ivanm> just thought that was what retry was meant to be for, didn't think
04:47:08 <doserj> retry aborts and waits for something to happen before it tries again.
04:47:34 <ivanm> *nod*
05:27:09 <ivanm> OK, with forkIO + STM ... could the problem with my code be that I'm trying to do the looping inside the STM monad do-block, rather than inside the IO Monad do block?
05:28:25 <EvilTerran> if you're trying to do that, you'd probably get a type error
05:29:13 <Lemmih> ivanm: URL?
05:29:40 <Choko_> zzqqq
05:31:22 <Olathe> Choko_: Is that snoring ?
05:33:18 <alexeevg> @yarr
05:33:18 <lambdabot> Well Ahoy! thar.
05:33:55 <Choko_> no i'm fully operational now
05:34:01 <Olathe> Heheh, OK.
05:36:50 <hpaste>  ivanm annotated "Infinite STM loop" with "Looping via STM" at http://hpaste.org/2961#a2
05:36:58 <ivanm> Lemmih: ^^
05:37:13 <ivanm> sorry for the delay... have been having problems lately with my laptop, keeps freezing for no reason :s
05:38:38 <masak> dons: do you think you could re-invite lambdabot to #bioclipse? we miss it...
05:38:47 <Lemmih> ivanm: Transaction only become visible when they finish.
05:39:10 <ivanm> Lemmih: that's what I was afraid of :(
05:40:01 <ivanm> *sigh* I thought I could get the looping happening nicely via the STM monad (well, originally I was erroneously using retry, which didn't help)
05:42:13 <EvilTerran> it's kinda the point of transactions...
05:51:51 <crazy_coder> hello everone
05:52:08 <crazy_coder> I am implementing a min-max algorithm for AI in tictactoe game
05:52:40 <crazy_coder> I read about the algo. but I have problems assigning values to nodes in a recursive way
05:53:27 <crazy_coder> can anyone help me out ? I hope it is easy to read my code :p
05:54:11 <hpaste>  crazy_coder pasted "min-max algo" at http://hpaste.org/2963
05:55:28 <crazy_coder> the game works fine for 2 players
05:55:38 <crazy_coder> I haven't tested for AI
05:56:23 <crazy_coder> It wont work due to incomplete program. But can anyone guide me about what I should return from the functions minMove and maxMove ?
05:56:57 <doserj> you shouldn't use return at all
05:57:03 <scook0> what exactly are they supposed to be doing?
05:57:12 <scook0> (type signatures tend to help, by the way)
05:57:37 <crazy_coder> http://ai-depot.com/articles/minimax-explained/2/
05:57:38 <lambdabot> Title: Minimax Explained - AI Depot
05:58:02 <crazy_coder> I looked at the first pseudo code given on this link and tried to adopt it to my Haskell program
05:58:49 <crazy_coder> do i need to keep track of the moves list I took throughout the game?
05:58:52 <EvilTerran> ?type (digitToInt, intToDigit)
05:58:58 <lambdabot> (Char -> Int, Int -> Char)
05:59:03 <crazy_coder> oh ok
05:59:10 <crazy_coder> Sorry didnt know abt it
06:00:05 <scook0> hmm, is that pseudocode even well-typed?
06:00:15 <scook0> it's hard to tell
06:00:29 <scook0> (that might be the source of your problems)
06:00:34 <crazy_coder> min and max are not integers. That is one of the foolish things I did but didnt remove while pasting it.
06:01:16 <scook0> what's the return type of MinMove/MaxMove supposed to be?
06:01:22 <crazy_coder> The main problem is that I have to return something, so that my program can compute the best node to take
06:01:26 <axm> min :: Integer ?
06:01:28 <crazy_coder> I dunno
06:01:36 <crazy_coder> axm: Thats wrong
06:01:36 <axm> sry, misread
06:01:49 <crazy_coder> I removed it now
06:02:50 <crazy_coder> (evalGameState b a p Max) is another problem
06:04:23 <scook0> I'm really not impressed with that article actually
06:05:25 <scook0> the returns in MaxMove seem to have inconsistent types
06:05:58 <doserj> most of the "return"s are unnecessary, i think
06:06:01 <crazy_coder> hmm. They have not clearly defined what the return types are
06:06:18 <scook0> (I'm not even looking at the paste; I'm trying to figure out the original pseudocode)
06:08:21 <crazy_coder> This was the best article I could find on mixmax
06:08:36 <crazy_coder> Rest of the articles even dont have a  pseudocode
06:10:33 <doserj> updateAvailable should be unnecessary
06:10:47 <crazy_coder> where?
06:10:47 <doserj> loop m = filter (/= m)
06:10:58 <doserj> printPlayer = show
06:11:20 <doserj> getPlayer = (:[])
06:11:30 <crazy_coder> doserj: Thanks
06:11:41 <doserj> vert = transpose
06:12:50 <doserj> convInt and lookup were already suggested :)
06:13:48 <crazy_coder> what is the getPlayer code ?
06:13:52 <crazy_coder> what does it do ?
06:13:56 <crazy_coder> ^^
06:14:14 <doserj> [x] is syntactic sugar for x:[]
06:14:29 <quicksilver> > 1:[]
06:14:32 <lambdabot>  [1]
06:14:36 <quicksilver> > (:[]) 1
06:14:36 <doserj> (:[]) is sugar for \x -> x:[]
06:14:37 <lambdabot>  [1]
06:14:41 <Olathe> What is the long form of [1,3,..] ?
06:14:43 <EvilTerran> @pl \x -> [x]
06:14:43 <lambdabot> return
06:14:46 <Olathe> [1,3..]
06:14:57 <scook0> @hoogle enumFrom
06:14:58 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
06:14:58 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
06:14:58 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
06:14:59 <EvilTerran> @pl \x y->[x,y..]
06:14:59 <lambdabot> enumFromThen
06:15:03 <tcr> So I had this big state monad where the state was an environment (bunch of stuff that conceptually belongs together to a particular stage), now I factored out a counter from that environment and made it its own monad because I need to preserve the counter state through various other stages.
06:15:16 <Olathe> > enumFrom 25 27
06:15:17 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[t2]'
06:15:24 <Olathe> > enumFromThen 25 27
06:15:25 <lambdabot>  [25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,...
06:15:28 <Olathe> Ahh.
06:15:30 <Olathe> Thanks.
06:15:35 <EvilTerran> @docs Enum
06:15:35 <lambdabot> Enum not available
06:15:39 <EvilTerran> @docs Data.Enum
06:15:39 <lambdabot> Data.Enum not available
06:15:45 <Olathe> > enumFromThenTo 25 27 60
06:15:46 <lambdabot>  [25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59]
06:16:14 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AEnum
06:16:15 <tcr> Now I'm a bit puzzled what I should make a transformer, the original big state monad, or the factored out counter monad?
06:16:16 <lambdabot> http://tinyurl.com/ovjef
06:16:21 <Olathe> @src enumFromThenTo
06:16:22 <lambdabot> Source not found. Where did you learn to type?
06:16:28 <Olathe> It never has these sources :|
06:16:50 <EvilTerran> enumFrom* is instance-dependent
06:17:27 <quicksilver> tcr: you can do either, in fact
06:17:42 <doserj> enumFromThenTo x y z =  map toEnum [fromEnum x, fromEnum y .. fromEnum z] -- by default
06:17:45 <quicksilver> tcr: it may be more natural to make the big monad a tranformer over the counter
06:17:59 <EvilTerran> iirc, transforming one state with another or vice-versa gives the same end result
06:18:00 <ivanm> is there kind of null operator for use with an if statement inside a do block, if you don't have a specific else statement to do?
06:18:12 <EvilTerran> and is the same as tupling the states
06:18:18 <EvilTerran> (lifts etc notwithstanding)
06:18:21 <EvilTerran> ivanm, return ()
06:18:23 <tcr> quicksilver: Well, but then I've got to integrate the counter into other stages (which possibly become also monads), so that'd rather speak for making the counter a transformer, doesn't it?
06:18:36 <allbery_b> @src when
06:18:36 <lambdabot> when p s = if p then s else return ()
06:18:46 <ivanm> EvilTerran: no, I meant for when you have something like do... if/then/else ... return foo
06:19:01 <EvilTerran> ivanm, or return {something else that doesn't do anything but returns something of the riht type}
06:19:30 <EvilTerran> hm? i'm not sure i follow
06:19:50 <EvilTerran> do ...; if foo then bar else {do nothing}; ...?
06:19:50 <crazy_coder> I need to rewrite a lot of it to make it work. Lets hope for the best. Thanks
06:20:14 <ivanm> EvilTerran: yes..
06:20:18 <ivanm> wait, forget that anyway
06:20:19 <Olathe> > let ef = iterate (+1) in ef 1.5
06:20:21 <ivanm> I wasn't thinking right
06:20:21 <lambdabot>  [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5,17.5...
06:20:41 <EvilTerran> well, return {whatever}'s defined to not do anything according to the monad axioms, so it should be what you want
06:20:46 <Olathe> doserj: Ahh.
06:21:23 <doserj> Olathe: what it does for integers should be clear :)
06:31:02 <tcr> Let `EnvM a' be `State Env a', and a counter state monad `State Int foo', how can I integrate the latter into the former? I thought about changing `EnvM a' to be `StateT Env (State Int <what's supposed to come here?>) a'
06:37:17 <phobes> The a goes there
06:38:00 <ToRA> tcr: nothing goes there, the a stays outside the brackets
06:38:01 <phobes> err no
06:38:03 <phobes> ya, nothing
06:38:19 <tcr> Yeah just found that out by kind analysis. :)
06:38:23 <phobes> That parameter is the inner monad... it has a free variable
06:38:24 <phobes> sorry :)
06:38:26 <ToRA> @kind StateT
06:38:28 <lambdabot> * -> (* -> *) -> * -> *
06:38:40 <ToRA> @kind (State Int)
06:38:41 <ToRA> yeah
06:38:42 <lambdabot> * -> *
06:43:17 <phobes> free parameter *
06:48:21 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2965
06:50:10 <pizza_> i am just learning haskell and using ghci, why would it not accept any "data" commands, such as: data Bool = False | True
06:50:38 <idnar> you can't type in declarations like that at the ghci prompt, unfortunately; you need to put that sort of thing in a file, and then :load it
06:50:53 <pizza_> ok
06:51:17 <pizza_> so types cannot be created "on-the-fly"?
06:53:10 <profmakx> well you can open an editor and a terminal with ghci
06:53:15 <profmakx> and just :reload
06:53:24 <profmakx> works quite nicely
06:53:46 <profmakx> either way you will become accustomed to thinking about your solutions beforehand :)
06:54:00 <pizza_> is the reason that types need to be defined in a file a consequence of the ghci implementation or the haskell language?
06:55:05 <Taejo> pizza_, the haskell language makes it difficult for ghci to do something sensible
06:55:21 <Taejo> though I've been thinking about the problem myself
06:55:49 <pizza_> Taejo: how so?
06:56:33 <Taejo> because of dealing with circular definitions, lack of statefulness in normal (non-interpreter-entered) Haskell programs, etc
06:56:45 <Taejo> I'm not an expert (only been coding in haskell about a week)
07:00:41 <pizza_> hmm ok, thanks for the input
07:07:34 <crazy_coder> if I have a list of tuples (x,score) I want to compare all scores in the list and return the x which has the highest score
07:07:41 <crazy_coder> how to do that ?
07:07:43 <mrd> maximumBy
07:07:55 <crazy_coder> @src maximumBy
07:07:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:08:02 <mrd> @hoogle maximumBy
07:08:02 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
07:08:03 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
07:08:19 <mrd> er
07:08:22 <mrd> yea
07:08:29 <crazy_coder> I said a list of tuples
07:08:31 <mrd> right
07:08:36 <mrd> 'a' can be that
07:08:52 <crazy_coder> can I use maximum then ?
07:09:11 <mrd> default maximum will compare first elem then second elem of tuple
07:09:18 <crazy_coder> by the way, how will it know what to compare, like compare the fst or snd is not known right ?
07:09:51 <crazy_coder> compare the fst first or snd first is not know
07:09:54 <crazy_coder> *known
07:09:57 <mrd> > maximumBy (\ (x1,s1) (x2,s2) -> if s1 >= s2 then (x1,s1) else (x2,s2)) [('a',1),('b',2)]
07:09:58 <lambdabot>  Couldn't match expected type `Ordering'
07:10:15 <mrd> > maximumBy (\ (x1,s1) (x2,s2) -> s1 `compare` s2) [('a',1),('b',2)]
07:10:17 <lambdabot>  ('b',2)
07:10:27 <mrd> blah, wonder why hoogle has the out of date entry
07:10:37 <kjdf> is it safe to write to a single Control.Concurrent.Chan from multiple threads?
07:10:43 <mrd> kjdf: yes
07:11:07 <doserj> > maximumBy (comparing snd) [('a',1),('b',2)]
07:11:08 <lambdabot>  ('b',2)
07:11:22 <Saizan> crazy_coder: if you just use maximum you the fst is compared first because that's how the Ord instance is defined, with maximumBy you can provide your comparing function so you can specify whatever order you wish
07:11:25 <crazy_coder> what modules do I need to import to use it
07:11:32 <doserj> import Data.List
07:11:37 <crazy_coder> thanks
07:11:50 <mrd> comparing isn't in ghc 6.6 though
07:12:20 <doserj> true :(
07:12:48 <doserj> it should be (compare `on` snd) anyways :)
07:13:06 <mrd> crazy_coder: alternatively you can create a new datatype for your tuples instead of just using tuples.  then define Ord on the scores.
07:13:13 <mrd> this is arguably the "correct way"
07:16:42 <araujo> @find strip
07:16:44 <lambdabot> Not in scope: type variable `strip'
07:28:01 <crazy_coder> Is there a std function to know the position of maximum element in a list
07:28:23 <crazy_coder> say if list is [1,2,3,4,5,2,9] answer is 7
07:28:33 <ivanm> don't think so... but you could do something like this:
07:28:53 <Olathe> @hoogle [a] -> Int
07:28:53 <lambdabot> Prelude.length :: [a] -> Int
07:29:01 <Olathe> Nope.
07:29:07 <ivanm> > fst . maximumBy snd . zip [1..] $ [1,2,3,4,5,2,9]
07:29:08 <lambdabot>      Occurs check: cannot construct the infinite type:
07:29:08 <lambdabot>       b = (a, b) -> Or...
07:29:12 <ivanm> heh
07:29:19 <ivanm> :t maximumBy
07:29:21 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
07:29:24 <Saizan> @hoogle Ord a => [a] -> Int
07:29:24 <lambdabot> Prelude.length :: [a] -> Int
07:29:28 <ivanm> :t compare
07:29:30 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
07:29:32 <ari> :t maximumBy (comparing snd)
07:29:34 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
07:29:46 <ivanm> > fst . maximumBy (comparing snd) . zip [1..] $ [1,2,3,4,5,2,9]
07:29:48 <lambdabot>  7
07:29:53 <idnar> !hoogle [a] -> [(Int, a)]
07:29:54 <ivanm> :D
07:29:57 <idnar> @hoogle [a] -> [(Int, a)]
07:29:57 <lambdabot> No matches, try a more general search
07:30:00 <idnar> heh
07:30:09 <ari> :t let on f p x y = f (p x) (p y) in maximumBy (compare `on` snd)
07:30:11 <crazy_coder> > maximumBy (compare `on` snd) (zipWith [1..] [1,2,3,4,5,6,9])
07:30:11 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
07:30:11 <lambdabot>   Not in scope: `on'
07:30:18 <doserj> > fromJust $ elemIndex =<< maximum $ [1,2,5,3,2]
07:30:20 <lambdabot>  2
07:30:46 <crazy_coder> > maximumBy (\ (x1,s1) (x2,s2) -> s1 `compare` s2) (zipWith [1..] [1,2,3,4,5,6,9])
07:30:47 <lambdabot>  Couldn't match expected type `a -> b -> c'
07:30:50 <ivanm> > fromJust $ elemIndex =<< maximum $ [1,2,5,3,2,9]
07:30:51 <lambdabot>  5
07:31:02 <Saizan> ?tyoe elemIndex
07:31:04 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
07:31:42 <crazy_coder>  > maximumBy (comparing snd) (zipWith [1..] [1,2,3,4,5,6,9])
07:31:47 <ivanm> crazy_coder: I think you're trying to get what I had just before...
07:31:58 <ivanm> > fst . maximumBy (comparing snd) . zip [1..] $ [1,2,3,4,5,2,9]
07:31:59 <crazy_coder> where ?
07:31:59 <lambdabot>  7
07:32:08 <crazy_coder> ok ok
07:32:08 <ivanm> ^^ there :p
07:32:12 <crazy_coder> is comparing std
07:32:16 <ivanm> though I must say, I like doserj's
07:32:21 <ivanm> I believe so...
07:32:26 <ivanm> @where comparing
07:32:26 <lambdabot> I know nothing about comparing.
07:32:32 <ivanm> @hoogle comparing
07:32:33 <lambdabot> No matches found
07:32:37 <idnar> @index comparing
07:32:37 <lambdabot> bzzt
07:32:38 <ivanm> @src comparing
07:32:38 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:32:41 <idnar> heh
07:32:43 <ivanm> hmmm...
07:32:49 <kpreid> so when do lambdabot's dbs get updated to ghc 6.6?
07:33:08 <doserj> comparing is new in 6.8, i think
07:33:09 <mrd> comparing isn't 6.6
07:33:38 <shachaf> I thought it was.
07:33:50 <shachaf> I've used comparing in 6.6, I think.
07:34:08 <ivanm> probably define it yourself...
07:34:14 <ivanm> @type on
07:34:17 <lambdabot> Not in scope: `on'
07:34:37 <shachaf> But on is new in base-2.1.
07:34:49 <ivanm> *shrug*
07:35:01 <doserj> ah, it is in 6.6
07:35:07 <doserj> (in Data.Ord)
07:35:17 <b_jonas> is there a function for '(all id) . zipWith' ?
07:35:36 <b_jonas> one that can tell whether all zipped pairs of two lists satisfy some relation
07:36:22 <twanvl> all id == and
07:36:43 <crazy_coder>  > fromJust $ elemIndex =<< maximum $ [10,1,2,5,3,2,9]
07:36:43 <crazy_coder> > fromJust $ elemIndex =<< maximum $ [10,1,2,5,3,2,9]
07:36:44 <lambdabot>  0
07:37:05 <b_jonas> twanvl: I see. so it's and . zipWith
07:37:10 <idnar> that scans the list twice, though ;)
07:37:38 <b_jonas> does it? this is a lazy language
07:38:08 <doserj> maximum is necessarily strict
07:38:16 <idnar> well, it might not evaluate the list twice
07:38:33 <idnar> but I would think it would have to traverse it twice
07:38:36 <mrd> that won't work on multisets
07:38:41 <mrd> er
07:38:47 <mrd> well it might not be the one you want
07:39:01 <idnar> @index maximumBy
07:39:01 <lambdabot> Data.List
07:39:08 <mrd> i guess it doesn't matter then
07:39:30 <doserj> > fromJust $ elemIndices =<< maximum $ [10,1,2,5,3,2,9,10]
07:39:31 <lambdabot>  Couldn't match expected type `Maybe a'
07:39:34 <b_jonas> sorry, I thought you meant that for my problem
07:39:38 <doserj> > elemIndices =<< maximum $ [10,1,2,5,3,2,9,10]
07:39:39 <lambdabot>  [0,7]
07:40:20 <mrd> mm reader monad so handy
07:41:01 <idnar> heh, I read something about "moaned" and was very confused
07:43:22 <crazy_coder> can I write something like this - if (condition)  then p<-func1  else p<- func2  where both func1 and func2 return the same type
07:43:43 <crazy_coder> 'where' is not part of the syntax above
07:43:49 <Saizan> no
07:43:54 <crazy_coder> why ?
07:43:55 <ari> p <- if condition then func1 else func2
07:44:05 <crazy_coder> oh Thanks
07:44:16 <ari> Um, actually... I'm not sure at all if that works
07:44:18 <Taejo> because there are no assignments in haskell
07:44:33 <mrd> so long as func1 and func2 are both monadic..
07:45:37 <ari> ... but it should
07:46:05 <crazy_coder> can I use 'let' instead of ->  in my code I wrote in the beginning
07:46:21 <Taejo> yes
07:46:28 <mrd> instead of ->?
07:46:36 <crazy_coder>  if (condition)  then (let p= func1)  else (let p= func2 )
07:46:39 <Taejo> oh wait
07:46:41 <mrd> no
07:46:41 <Saizan> no
07:46:51 <Saizan> you still need the let outside
07:47:01 <Taejo> instead of <0
07:47:01 <Taejo> oops <-
07:47:02 <mrd> if you are pulling a value out of a monad, then you need <-
07:47:07 <doserj> let p = if ... then func1 else func2 -- if func1, func2 are not monadic
07:47:24 <crazy_coder> if they are monadic
07:47:45 <doserj> p <- if ... then func1 else func2 -- if they are monadic
07:47:55 <dons> ?users
07:47:55 <lambdabot> Maximum users seen in #haskell: 420, currently: 383 (91.2%), active: 20 (5.2%)
07:48:07 <mrd> early riser!
07:49:07 <Saizan> crazy_coder: do you know how do-notation is desgared to Monad's methods and lambdas?
07:49:27 <shapr> good morning #haskell!
07:50:02 <mrd> the sun never sets on #haskell
07:50:54 <crazy_coder> then what can I do ?
07:50:55 <crazy_coder> I have func1 as getChar
07:50:55 <crazy_coder> whereas func2 is an algorithm that gives computers decision
07:50:55 <crazy_coder> do both func1 and func2 necessarily have to be of the same type
07:50:55 <crazy_coder> if one is IO() and the other is say IO (Char) is it ok ?
07:51:01 <mrd> no
07:51:11 <crazy_coder> what the f***
07:51:11 <EvilTerran> what type would p be in that case?
07:51:24 <crazy_coder> how am i supposed to do then ?
07:51:29 <mrd> disjoint union perhaps
07:51:33 <mrd> Either () Char
07:51:39 <crazy_coder> should I pastebin it ?
07:51:40 <EvilTerran> what does p even represent?
07:51:48 <crazy_coder> p represents a character
07:51:49 <mrd> yea maybe you can just rewrite
07:51:54 <doserj> p <- if ... then func1 else return $ func2
07:51:56 <crazy_coder> but i want to input it from user
07:52:01 <mrd> crazy_coder: or a Maybe Char?
07:52:04 <crazy_coder> so I use getChar
07:52:15 <EvilTerran> okay, then what does it represent if the condition is false?
07:52:18 <crazy_coder> return type of getChar is IO()
07:52:24 <mrd> ?
07:52:26 <EvilTerran> ?type getChar
07:52:33 <axm> looking at the plugins eval/unsafeEval accepting any risks and wanting to be able to do a lot of typing at runtime, it comes down to reading my own data type (by giving that modules type to eval and wrapping the evaluated text with the constructor) or to do anything i want to do with it inside an unsafeEval, am I right?
07:52:34 <lambdabot> IO Char
07:52:38 <crazy_coder> if it is false, I wrote an function
07:52:47 <crazy_coder> which returns a Char
07:52:48 <sieni> getChar isn't even a function
07:52:55 <BoudewijnE> hi
07:53:02 <crazy_coder> oh ok
07:53:05 <BoudewijnE> i was here a few days ago asking for some parsing help
07:53:12 <crazy_coder> EvilTerran: So it should work, right ?
07:53:13 <Saizan> crazy_coder: getChar is of type IO Char
07:53:16 <BoudewijnE> still stuck, and want to get it running
07:53:27 <Saizan> crazy_coder: how would you get a Char from IO () if not?
07:53:29 <crazy_coder> right, i saw
07:53:35 <EvilTerran> p <- if (...) then getChar else (...)
07:53:37 <EvilTerran> should work
07:53:44 <BoudewijnE> I've copied some functions from the "prorgramming in haskell" book from hutton
07:54:10 <crazy_coder> EvilTerran: I am curently getting a parse error at then
07:54:20 <mrd> hpaste: url
07:54:20 <hpaste> Haskell paste bin: http://hpaste.org/
07:54:26 <BoudewijnE> http://pastebin.com/d46713707
07:54:26 <crazy_coder> Oh Ok
07:54:31 <BoudewijnE> I've got this error
07:54:38 <BoudewijnE> can someone help me?
07:54:39 <crazy_coder> Sorry it was it another place
07:54:53 <BoudewijnE> line 34 ist the 2nd 'return'
07:55:08 <twanvl> BoudewijnE: You need to indent 'return' so it lines up with 'many'
07:55:29 <BoudewijnE> ah okay
07:55:42 <BoudewijnE> 1 indenture isn't enough I see
07:55:43 <BoudewijnE> ok
07:55:45 <BoudewijnE> thanks
07:55:49 <axm> or is it possible to add a dynamic type signature to an "unsafeEval "5::Int" []" _without_ adding the Int signature static? it only worked for me for strings as type
07:56:02 <mrd> BoudewijnE: you need to line up code with the first column of "real code" in a do-block
07:56:15 <BoudewijnE> well , I did indenture it
07:56:20 <BoudewijnE> but when using 2 tabs, it works
07:56:24 <BoudewijnE> instead of 1
07:56:26 <mrd> it's not about indents
07:56:30 <mrd> it's about lining up code
07:56:36 <mrd> also -- do NOT use tab characters
07:56:59 <BoudewijnE> o
07:57:00 <BoudewijnE> k
07:57:04 <mrd> use spaces only
07:57:23 <sieni> why not tabs?
07:57:33 <axm> the emacs plugin would be one example that takes care about that for you
07:57:38 <BoudewijnE> I've been using tabs at universirty, it worked fine
07:58:00 <EvilTerran> tabs are okay only if your editor interprets them the same way the layout rule does
07:58:01 <axm> tabs are displayed differently in different editors, looks ugly somewhere else
07:58:03 <Saizan> you can probably set your editor to transparently use spaces instead of tabs
07:58:04 <mrd> sieni: because tabs can be set to different expansions
07:58:05 <EvilTerran> ie as eight characters
07:58:17 <mrd> and haskell compilers expect them to be 4 spaces
07:58:26 <sieni> 4?
07:58:30 <sieni> I thought 8
07:58:30 <mrd> and if you mix spaces and tabs, all bets are off
07:59:02 <twanvl> Tab(stop)s are 8 spaces
07:59:11 <sieni> stops indeed
08:02:27 <dino-> Please don't use tabs.
08:03:33 <axm> so, we are from explaining to begging now? ;)
08:04:34 <Taejo> axm, if ANSI had set down a standard for the width of a tab when they standardised the first character set, tabs would be awesome
08:04:43 <Taejo> they didn't, so they aren't
08:05:21 <Taejo> actually, by then it was probably too late if the teletype companies didn't all agree then
08:06:49 <axm> i thought that it was the point to jump with it to some point defined by whitespace in the previous line, so defining a fixed width might have been counterproductive for layout uses (if that is even what it might to be used for)
08:07:28 <BoudewijnE> another question, can someone help me writing a parser which splits a string with 4 natural numbers into a list of ints?
08:07:36 <BoudewijnE> I've read this one too: http://www-etud.iro.umontreal.ca/~laurieti/parser.html
08:07:37 <lambdabot> Title: Interesting parsers in Haskell
08:08:00 <BoudewijnE> and the nomadic parsers document too
08:08:10 <EvilTerran> > map read . words . take 4 $ "12 34 56 78" :: [Int]
08:08:15 <lambdabot>  [12,3]
08:08:17 <EvilTerran> ups
08:08:22 <EvilTerran> > map read . take 4 . words $ "12 34 56 78" :: [Int]
08:08:24 <lambdabot>  [12,34,56,78]
08:08:38 <BoudewijnE> nice :)
08:08:55 <BoudewijnE> thanks :)
08:09:08 <EvilTerran> np
08:09:18 * BoudewijnE is such a newbie
08:12:19 <Saizan> with a monadic parser it'll look be more like replicateM 4 (nat >> space)
08:12:26 <Saizan> s/be//
08:13:03 <BoudewijnE> yes indeed
08:14:02 <EvilTerran> well, replicateM 4 (nat <* space), i think
08:14:07 <EvilTerran> ?type (<*)
08:14:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:14:24 <hpaste>  crazy_coder pasted "error at line 155 and 161 " at http://hpaste.org/2966
08:14:27 <Saizan> right
08:14:38 <EvilTerran> otherwise you'd lose all your numbers
08:15:06 <crazy_coder> I finally finished implementing minmax algo. I hope it is correct
08:15:16 <crazy_coder> But I am getting syntax errors
08:15:21 <phobes> > map read . words $ "12 34 56 78"
08:15:22 <lambdabot>  [12,34,56,78]
08:15:30 <crazy_coder> Can anyone help me, paste ^^^
08:16:21 <ToRA> crazy_coder, which are those lines, and what is the error?
08:16:36 <crazy_coder> i have pasted the error below
08:16:56 <crazy_coder> maxMove b a p d = if ((fullBoard a) || (depthLimitReached d) || (checkForWin b p)) then (evalGameStateMax b a p d)
08:17:12 <EvilTerran> you need an else
08:17:16 <EvilTerran> surely?
08:17:36 <crazy_coder>  sorry
08:17:38 <crazy_coder>  return(minMove (updateBoard b p (lookups choice)) (updateAvailable (lookups choice) a) (changePlayer p) (d+1) )
08:17:41 <crazy_coder> and
08:17:56 <crazy_coder> maxMove b a p d = if ((fullBoard a) || (depthLimitReached d) || (checkForWin b p)) then (evalGameStateMax b a p d)
08:18:01 <crazy_coder> are the two lines
08:18:10 <crazy_coder> EvilTerran: where ?
08:18:26 <EvilTerran> maxMove b a p d = if ((fullBoard a) || (depthLimitReached d) || (checkForWin b p)) then (evalGameStateMax b a p d) HERE
08:18:35 <idnar> yeesh
08:18:52 <EvilTerran> if/then always-but-always has an else in haskell
08:19:08 <crazy_coder> why, there can be a if without else
08:19:16 <crazy_coder> oh
08:19:19 <EvilTerran> not in haskell there can't
08:19:36 <ttfh> what value would be returned then?
08:19:42 <EvilTerran> every expression has to always have a value
08:19:44 <ttfh> without an else
08:19:50 <EvilTerran> what value would "if False then 1" have?
08:19:57 <dylan> undefined?
08:19:59 <mrd> _|_
08:20:06 <kpreid> that'd be rather useless
08:20:07 <ttfh> `42
08:20:17 <mrd> @hoogle when
08:20:17 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
08:20:17 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
08:20:18 <EvilTerran> that'd be pretty useless from a monadic point of view
08:20:29 <crazy_coder> btw, I have an else over there
08:20:45 <crazy_coder> I have an else {do block}
08:20:50 <axm> asked more precisely, this is not to be made possible by existentials "magic" that ensures that the (+5) may be applied to 4 ? > ((flip unsafeEval []) "(+5)::Int->Int") >>= (return.(\(Just x) ->x)) >>= (return.4)
08:21:17 <phobes> EvilTerran:  Yes, clearly the implicit else should be "return ()"
08:21:31 <EvilTerran> but what about if you're not in a monad?
08:21:36 <phobes> get an error?
08:21:54 <EvilTerran> anyway, that's "when" you're asking for
08:22:21 <EvilTerran> @src when
08:22:21 <lambdabot> when p s = if p then s else return ()
08:22:23 <phobes> ya, if / else should just be removed from the language
08:22:25 <phobes> or so I hear :)
08:22:33 <sioraiocht> phobes: Hear hear!
08:22:41 <sioraiocht> i'm okay with if :: Bool -> a -> a
08:22:43 <crazy_coder> EvilTerran: did you see my code? I have an else over there
08:22:55 <sioraiocht> rather
08:22:59 <EvilTerran> i saw what you pasted into the channel
08:23:03 <sioraiocht> if :: Bool -> a -> a -> a
08:23:08 <paolino> how do I work in the list monad with one state  ?
08:23:16 <crazy_coder>  http://hpaste.org/2966
08:23:19 <doserj> if :: (Boolean a ) => a -> b -> b -> b
08:23:32 <idnar> :t if'
08:23:38 <lambdabot> Not in scope: `if''
08:24:40 <EvilTerran> what lines are 155 and 161? those ones you pasted into the channel?
08:24:41 <b_jonas> what's the haskell equivalent of the perl join function
08:24:51 <EvilTerran> concat?
08:24:54 <crazy_coder> yes
08:25:00 <paolino> I tried StateT s  [] with no success
08:25:03 <b_jonas> no, I want to add a certain string in between them
08:25:13 <b_jonas> concat concatenates strings with nothing between
08:25:36 <EvilTerran> > ((conat.) . intersperse) "||" ["foo","bar","baz"]
08:25:37 <lambdabot>   Not in scope: `conat'
08:25:41 <EvilTerran> > ((concat.) . intersperse) "||" ["foo","bar","baz"]
08:25:41 <b_jonas> I want an f so that (f "foo" ["bar", "qux", "baz"]) == "barfooquxfoobaz"
08:25:45 <lambdabot>  "foo||bar||baz"
08:25:55 <EvilTerran> @src intersperse
08:25:55 <lambdabot> intersperse _   []     = []
08:25:55 <lambdabot> intersperse _   [x]    = [x]
08:25:55 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
08:26:24 <b_jonas> hmm
08:26:43 <b_jonas> why do you need two dots in that?
08:27:06 <paolino> :t (:)
08:27:08 <lambdabot> forall a. a -> [a] -> [a]
08:27:34 <osfameron> eeek (concat.)
08:27:39 <osfameron> :t (concat.)
08:27:41 <lambdabot> forall a a1. (a1 -> [[a]]) -> a1 -> [a]
08:27:57 <crazy_coder> EvilTerran: find anything missing in the code?
08:28:05 <crazy_coder> EvilTerran: It looks correct to me
08:28:12 <EvilTerran> with the two dots, intersperse gets two parameters and then the result gets passed to concat
08:28:36 <b_jonas> ah, I see
08:28:37 <EvilTerran> crazy_coder, i don't see anything. try adding explicit curlies instead of relying on layout?
08:28:47 <crazy_coder> did that
08:28:52 <b_jonas> so that's an idiom for two-arg right function
08:28:54 <crazy_coder> no use
08:28:58 <b_jonas> thanks
08:29:12 <EvilTerran> ((f.) . g) x y = (f.) (g x) y = (f . (g x)) y = f (g x y)
08:29:25 <osfameron> > concat (intersperse "," ["a", "b", "c"])
08:29:27 <lambdabot>  "a,b,c"
08:29:32 <osfameron> that seems less scary to me
08:29:44 <b_jonas> that's the kind of wierd thing you get in curried languages
08:30:27 <paolino> :t (do x <- [1..2]; lift modify (x:)) :: ListT (State [Int]) ()
08:30:29 <lambdabot>     Couldn't match expected type `ListT (State [Int]) t'
08:30:29 <lambdabot>            against inferred type `[a]'
08:30:41 <paolino> how do I fix that ?
08:31:23 <EvilTerran> crazy_coder, i don't get a parse error
08:31:24 <b_jonas> :pf \x y -> f (g x y)
08:31:41 <b_jonas> @pf \x y -> f (g x y)
08:31:41 <lambdabot> Maybe you meant: bf pl
08:31:46 <EvilTerran> well, except where the paste is truncated
08:31:47 <b_jonas> @pl \x y -> f (g x y)
08:31:47 <crazy_coder> EvilTerran: I got it initially. Now i am getting type errors
08:31:47 <lambdabot> (f .) . g
08:32:00 <b_jonas> ah huh, that's the canonical one according to lambdabot as well
08:32:15 <EvilTerran> often people call it .: for sanity's sake
08:32:25 <EvilTerran> don't trust @pl to produce sensible output ;)
08:32:28 <sieni> @pl \x y z -> f (g x y z)
08:32:28 <lambdabot> ((f .) .) . g
08:32:32 <sieni> aha!
08:32:38 <sieni> I see a pattern here
08:32:46 <crazy_coder> hey, is there a text size limit for pasting one's code in pastebin
08:32:48 <osfameron> I see line noise
08:33:11 <conal> > let result = (.)
08:33:11 <lambdabot>  Parse error
08:33:19 <conal> @let result = (.)
08:33:23 <lambdabot> Defined.
08:33:42 <conal> i like that name, since it does for functions what first & second do for pairs
08:33:56 <sieni> @pl \x y -> f (g (h x y))
08:33:57 <lambdabot> ((f . g) .) . h
08:34:01 <EvilTerran> @pl \n -> fix (\f (i,t) -> if i==n then t else f(i+1,i+t))
08:34:02 <lambdabot> fix . flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ((. ap ((.) . (,) . (1 +)) (+)) . (.))) . ap . ((ap . if') .) . (==)
08:34:07 <sieni> @pl \x y z -> f (g (h x y z))
08:34:07 <lambdabot> (((f . g) .) .) . h
08:34:09 <b_jonas> J is in between curried and non-curried languages and in it, the @ composition operator "just works" for both one and two argument right function (even though that's only because it's defined that way)
08:34:25 <EvilTerran> (as i said, don't trust @pl to produce sane output)
08:34:56 <wli> EvilTerran: I've seen @pl bungle typeclass constraints.
08:35:17 <paolino> anyone can help me understand StateT s [] and ListT (State s) ?
08:35:31 <b_jonas> :t if'
08:35:33 <lambdabot> Not in scope: `if''
08:36:09 <EvilTerran> if' p x y = if p then x else y
08:36:12 <b_jonas> :pl \x y -> f (g x y) -- why is it sometimes @ and other times :
08:36:41 <EvilTerran> b_jonas, only a few things work with :. everything else is @ or ? (those two're interchangable)
08:36:49 <EvilTerran>  ?type = @type = :t
08:37:45 <greenrd> Would it be possible to create a monad transformer for DList?
08:37:56 <greenrd> http://www.cse.unsw.edu.au/~dons/dlist.html
08:37:56 <lambdabot> Title: DList : Difference Lists
08:38:32 <b_jonas> perhaps : is for compatibility with ghci commands
08:38:38 <b_jonas> ghci has a :t and :i
08:38:43 <b_jonas> (meaning :type and :info)
08:38:56 <EvilTerran> :k StateT
08:38:58 <lambdabot> * -> (* -> *) -> * -> *
08:39:11 <b_jonas> I'm not criticizing, for my bot has a stupidly wierd invocation syntax as well
08:39:38 <b_jonas> so it answers four characters: > : @ ?
08:40:02 <b_jonas> that's why vincenz is angry about haskell bot clones producing so much junk
08:41:34 <axm> anyone here that i can interest in my monologic dynamic evaluation discussion?
08:42:39 <phobes> What is a monologic?
08:43:05 <axm> me only one talking :/
08:43:42 <phobes> oh heh, I thought it was a technical term :)
08:43:49 <malim> soliloquy?
08:44:03 <axm> yeah, that would probably the better word
08:44:08 <axm> *be
08:45:04 <malim> what is there to discuss in dynamic evaluation
08:45:53 <axm> i am to build a small framework for dynamic function evaluation, and at the moment i see 2 possibilities
08:46:53 <dons> ?yow
08:46:53 <lambdabot> I need to discuss BUY-BACK PROVISIONS with at least six studio SLEAZEBALLS!!
08:47:05 <axm> using hs-plugins, i could use the eval to read a data type with a couple of constraints for what i need to do with it
08:47:43 * ptolomy wonders why he never hears about John Skaller's Felix language from anybody but him.
08:48:01 <axm> downside, as far as i know, the module has to be fed to the eval, and putting in the absolute path is rather ugly
08:48:46 <dons> more interesting agda  posts, http://programming.reddit.com/info/2u3nx/details
08:48:47 <lambdabot> Title: Sized Mergesort in Agda (reddit.com)
08:49:05 <axm> the other possibility would be to go for unsafeEval, but i do not even know it is possible to put some constraints on data there
08:49:53 <cizra> What's the difference between quot and div?
08:49:57 <axm> (unsafeEval  "(+5)::Int->Int" []) >>= (return.(\(Just x) ->x)) >>= (return.4)
08:50:11 <Olathe> > quot 5 4
08:50:12 <lambdabot>  1
08:50:22 <Olathe> > quot (-5) 4
08:50:23 <lambdabot>  -1
08:50:27 <dons> ?check \x y -> div x y == quot x y
08:50:28 <lambdabot>  Add a type signature
08:50:32 <cizra> > div (-5) 4
08:50:33 <dons> ?check \x y -> div x y == quot x (y :: Int)
08:50:33 <lambdabot>  -2
08:50:34 <lambdabot>  Exception: divide by zero
08:50:44 <dons> ?check \x y -> y > 0 ==> div x y == quot x (y :: Int)
08:50:46 <lambdabot>  Falsifiable, after 2 tests: -1, 2
08:50:51 <dons> ?scheck \x y -> y > 0 ==> div x y == quot x (y :: Int)
08:50:52 <lambdabot>   Failed test no. 10. Test values follow.: -1, 2
08:51:02 <dons> so they differ wrt. negative
08:51:24 <cizra> Hmm.. OK
08:51:28 <cizra> Thank you.
08:52:17 <mux> ?scheck \x y -> x > 0 && y > 0 ==> div x y == quot x (y :: Int)
08:52:19 <lambdabot>   Completed 169 test(s) without failure.  But 133 did not meet ==> condition.
08:52:26 <chessguy> ?scheck \x y -> y \= 0 ==> div x y == quot x (y :: Int)
08:52:27 <mux> Bad 133!
08:52:27 <lambdabot>  Not in scope: `\='
08:52:36 <chessguy> @src Eq
08:52:36 <lambdabot> class  Eq a  where
08:52:36 <lambdabot>     (==), (/=)   :: a -> a -> Bool
08:52:41 <chessguy> i always forget that noe
08:52:46 <chessguy> ?scheck \x y -> y /= 0 ==> div x y == quot x (y :: Int)
08:52:47 <lambdabot>   Failed test no. 10. Test values follow.: -1, 2
08:54:21 <phobes> ptolomy:  Have you ever used Felix?
08:59:09 <Tac-Tics> ?scheck
08:59:09 <lambdabot> smallcheck: <stdin>: hGetLine: end of file
08:59:16 <Tac-Tics> what is scheck do?
08:59:32 <ToRA> like quickcheck, but instead of random inputs
08:59:49 <ToRA> it walks the space of inputs in a structured manner, starting small and getting bigger
09:00:00 <Tac-Tics> ah
09:00:46 <Tac-Tics> ?scheck (>1) || (<=1)
09:00:47 <lambdabot>     The section `(> 1)' takes one argument,
09:00:47 <lambdabot>     but its type `Bool' has none
09:00:54 <Tac-Tics> oops
09:01:10 <Tac-Tics> ?scheck \x -> 1 < x || 1 > x
09:01:11 <lambdabot> Add a type signature
09:01:22 <ToRA> @scheck (\x -> length x < 3 ) :: [Int] -> Bool
09:01:23 <lambdabot>   Failed test no. 4. Test values follow.: [-2,-1,0]
09:01:29 <ToRA> @check (\x -> length x < 3 ) :: [Int] -> Bool
09:01:31 <lambdabot>  Falsifiable, after 4 tests: [4,0,-1,-4]
09:01:32 <Tac-Tics> ?scheck (\x -> 1 < x || 1 > x) :: Int -> Bool
09:01:33 <lambdabot>   Failed test no. 3. Test values follow.: 1
09:01:34 <ToRA> @check (\x -> length x < 3 ) :: [Int] -> Bool
09:01:35 <lambdabot>  Falsifiable, after 6 tests: [-2,1,-4]
09:01:53 <ToRA> so the scheck will always fail after 4, but check will fail at some random point
09:01:55 <Tac-Tics> ?scheck (\x -> 1 < x || x >= x) :: Int -> Bool
09:01:56 <lambdabot>   Completed 13 test(s) without failure.
09:02:15 <EvilTerran> x >= x = True
09:03:21 <malim> Wiki says Felix = ML family language with C++-like syntax... doesn't sound particularly enticing
09:04:07 <dons> C++ syntax -- not something you see emulated very often
09:04:29 <malim> unless you're reaching for heights of ugliness
09:05:27 <phobes> The reason for choosing a C++ syntax seem pretty obvious... people know C++
09:05:39 <phobes> seems*
09:05:46 <dons> they know the syntax? and that's enough to fool anyone, eh?
09:05:51 <Tac-Tics> @let perfect n = sum [x | x <- [1..n], n `mod` x == 0] == 2 * n
09:05:52 <mux> I'll create a new language that will have the syntax of perl, the safeness of C, and the speed of Java
09:05:54 <lambdabot> Defined.
09:05:58 <mux> s/Java/Ruby/
09:06:02 <dons> suck 'em in with the syntax, then bam! functor them up real good!
09:06:20 <Tac-Tics> ?scheck perfect :: Int -> Bool
09:06:22 <lambdabot>   Failed test no. 1. Test values follow.: -1
09:06:25 <Tac-Tics> doh
09:06:58 <phobes> dons:  familiar syntax isn't enough to win people over, but unfamiliar syntax will scare alot of people off
09:07:01 <Tac-Tics> ?scheck (\x -> perfect x && x `mod` 2 == 0) :: Int -> Bool
09:07:03 <lambdabot>   Failed test no. 1. Test values follow.: -1
09:07:41 <dons> phobes: oh, i don't disagree. its a bit sad though. why be stuck with legacy, inefficient notation.
09:07:53 <Tac-Tics> ?scheck (\x -> perfect x == (x `mod` 2 == 0)) :: Int -> Bool
09:07:54 <lambdabot>   Failed test no. 1. Test values follow.: -2
09:08:28 <dcoutts> @yarr!
09:08:28 <lambdabot> Get out o' me way, yeh landlubber
09:08:46 <dcoutts> 10% of hackage packages break with Cabal-1.2, that's not too bad I reckon
09:08:47 <phobes> dons:  I generally agree, though I think you can have a generally nice powerful language that looks closer to C++ in many ways
09:08:55 <dons> dcoutts: oh, ok! that's better than i thought
09:08:56 <dcoutts> they've all got complex Setup.hs scripts
09:09:05 <idnar> honestly, I don't think syntactical similarity between things that are drastically different is a good idea
09:09:05 <dons> dcoutts: you just grab the lot, and checked it against 6.6.1?
09:09:09 <Tac-Tics> ?scheck (\x -> if perfect x then even x else False) :: Int -> Bool
09:09:09 <dcoutts> yes
09:09:10 <lambdabot>   Failed test no. 1. Test values follow.: -1
09:09:14 <dcoutts> I've sent a survey to the libraries list
09:09:23 <dons> dcoutts: ok, any ideas how many things break with 6.8 ... :)
09:09:29 <dcoutts> dons: all of them? :-)
09:09:36 <idnar> it makes it more likely that you'll get someone thinking they know what's happening, but actually being horribly mistaken
09:09:42 <Tac-Tics> ?scheck (\x > if perfect x then even x else True) :: Int -> Bool
09:09:42 <lambdabot>  Parse error
09:09:43 <dcoutts> dons: see the email, it's good material for a conversion Wiki
09:09:53 <Tac-Tics> ?scheck (\x -> if perfect x then even x else True) :: Int -> Bool
09:09:53 <lambdabot>   Completed 13 test(s) without failure.
09:09:56 <Tac-Tics> there we go
09:09:57 <Tac-Tics> hehe
09:10:02 <dons> dcoutts: http://haskell.org/haskellwiki/Upgrading_packages
09:10:03 <lambdabot> Title: Upgrading packages - HaskellWiki
09:10:25 <phobes> dons:  though the closer you try to stick to C-like notation, the more quirky sugar you are going to need
09:10:52 <dcoutts> dons: we need a system for applying minor build patches to hackage packages without bothering the maintainers / authors
09:10:57 <dons> yeah
09:12:06 <dcoutts> dons: we could fix almost all the packages in an afternoon with a simple patching system
09:12:14 <dons> right. i agree
09:12:21 <dons> both for cabal and for 6.8
09:12:25 <dcoutts> dons: even if it was as simple as whole file replacement
09:12:36 <dcoutts> since we'd only be replacing Setup.hs and $pkg.cabal
09:12:42 <dons> so hmm. we do have access to the entire hackage tree
09:12:46 <dcoutts> yes
09:12:54 <dons> but they need to become new releases
09:12:57 <dcoutts> but it's rude to change the .tar.gz files md5sums
09:13:06 <dons> oh, that's definitely not possible
09:13:10 <dons> since it breaks all the distros
09:13:15 <dcoutts> in gentoo and debian etc we have the build system apply patches at compile time
09:13:26 <dcoutts> we unpack the sources, apply patches and build
09:13:29 <dons> in openbsd, somehting like:  package-foo-1.0.tgz --> pacakge-foo-1.0p0.tgz
09:13:42 <dons> yeah, that's the distro approach in *bsd too
09:13:48 <dcoutts> making the patches easily available is nice too
09:13:58 <dcoutts> both for downstream packagers and upstream maintainers
09:14:35 <dons> yeah, we're suggesting turning hackage into a bit of a package system
09:14:41 <dons> with downstream patches
09:14:53 <Japsu> mmm... hackage install Data.Binary <3
09:15:04 <Japsu> that'd be cool
09:15:05 <dons> cabal-install binary :)
09:15:09 <Japsu> bah ;)
09:15:10 <dons> grab cabal-install today!
09:15:15 <DRMacIver> Ooh, does that exist now?
09:15:18 <dcoutts> yes
09:15:19 <dons> yeah
09:15:21 <DRMacIver> Excellent
09:15:28 <DRMacIver> How long has it been around for?
09:15:41 <Japsu> perl has CPAN, TeX has CTAN, R has CRAN... we should have CHAN :)
09:15:42 <dons> dcoutts: we could just create new minor version releases local to hackage for stuff we fix
09:15:45 <Baughn> It works now? No more "it only works with the newest version of cabal, which doesn't work with any cabalized packages"?
09:15:56 <dons> using a script to automate the process
09:16:08 <dcoutts> dons: well, we can't really mess with upstream author's version scheme
09:16:09 <dons> unpack, fix, pack, upload foo.X.Y.p0
09:16:27 <dcoutts> dons: in gentoo we have a special -rx component in version names for our own revisions
09:16:38 <dons> right. that seems a plausible process
09:16:43 <Baughn> dons: By the way, lambdabot appears to crash whenever I change the command prefix in the slightest (even if I remove all state)
09:16:43 <dcoutts> but Cabal packages do not support that kind of versioning atm
09:17:07 <krishn_bhakt> Anything like  R statistical package in haskell?
09:17:12 <dcoutts> DRMacIver: cabal-install-0.3.0 for Cabal-1.1.6 works, for latest Cabal it's only partially working
09:17:19 <dons> it's a bit concerning that there's no clear plan on how hackage is supposed to work with 6.8 this close to release
09:17:31 <dcoutts> DRMacIver: we'll be making a proper release of cabal-install after ghc 6.8.1 is out
09:17:36 <dons> i suspect it means people will be uploading new versions of everything
09:17:47 <dcoutts> dons: yes, probably so
09:18:01 <dcoutts> dons: that is the plan really
09:18:16 <dcoutts> dons: in the absence of any patching mechanism
09:18:19 <dons> right, so for a lot of packages, we may just be able to step in and do that ourselves
09:18:30 <dons> mtl 1.0.1
09:18:42 <dcoutts> we've already got mtl-1.0.1 :-)
09:18:54 <dcoutts> though that makes me nervous, since we don't really control upstream version scheme
09:19:17 <dons> so there's a bunch of `inner circle' libs we own
09:19:21 <dcoutts> yes
09:19:23 <dons> including anything with libraries@ as maintainer
09:19:41 <esquinque> hey, is there a way in haskell to overload a function based on what type parameter is passed to it?  I thought I read something about being able to do that but am failing to find docs on the idea
09:19:45 <dcoutts> I like the patching idea, and make cabal-install apply the patches
09:19:55 <DRMacIver> dcoutts: ok. I'll wait around then. :)
09:19:58 <dcoutts> and make the patches available for other packagers
09:20:02 <Baughn> esquinque: Type classes, or just a union data type
09:20:10 <dons> dcoutts: yeah, that seems a reasonable approach
09:20:12 <esquinque> Baughn: I suspected type classes might be it
09:20:20 <dons> though breaks the simple .tgz unpack and build model
09:20:39 <dcoutts> dons: yes, or we can provide a new combined .tar.gz with a new URL
09:20:41 <Baughn> esquinque: The data statement would get the same effect, non-extendable, but does it by creating a new type
09:20:52 <esquinque> hmm
09:21:13 <dcoutts> dons: but it'd have to have the same version number, so only patches to build system, not functionality changes
09:21:48 <dons> oh hmm, that's interesting
09:22:08 <dons> changes to the .cabal or Setup.hs considered outside the version system?
09:22:14 <pgavin> dcoutts: I put up a bug report on trac with the dep patch
09:22:20 <dcoutts> pgavin: great
09:22:31 <dcoutts> dons: that's what all distros do
09:22:42 <dons> we could put patches Setup.hs and .cabal files under package/6.8/*
09:22:46 <dcoutts> dons: they even sometimes patch minor bugs and call it the same version
09:23:20 <dcoutts> dons: conditional patching is a bit evil, build system patches should enable things to continue to work
09:23:29 <dcoutts> with older ghc etc
09:23:36 <dcoutts> though not necessarily older Cabal I guess
09:23:55 <pgavin> dcoutts: has the cabal repo been branched yet?
09:24:00 <dcoutts> pgavin: yes
09:24:06 <dcoutts> a month ago or so
09:24:13 <pgavin> oh, ok
09:24:21 <esquinque> Baughn: I kept poking around for docs on type classes, but all I turn up are examples showing operator overloading.  Oh well, at least I know which trees to be barking up now!
09:25:12 <pgavin> dcoutts: ok, so is there anything I should do to help get the patch in?
09:25:13 <xerox> ?source Data.List
09:25:14 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
09:25:57 <dcoutts> pgavin: no, I'll put it in some time soon, perhaps at the hackathon when we start to work on it
09:25:58 <xerox> Anybody knows off-hand where's Show defined for [a] ?
09:26:13 <pgavin> dcoutts: cool, sounds good
09:27:26 <byorgey> xerox: GHC.Show
09:27:36 <xerox> ah, just found it in Text.Show
09:27:41 <xerox> thanks anyway
09:29:13 <iguana_> if I have a list of tokens of type data Token = Token TokenType LineNumber with data TokenType = TString String | TNumber Int | ... how do I best parse these with parsec?
09:29:49 <pgavin> dcoutts: there's also a gstreamer patch I put up on the gtk2hs list that never got merged
09:34:04 <EvilTerran> try (liftM TNumber readInt) <?> ...
09:34:19 <EvilTerran> parseInt, rather
09:34:55 <iguana_> well, I already have those tokens
09:35:01 <iguana_> and I want to construct something like an AST now
09:35:24 <elliottt> Eelis: you around?
09:35:25 <iguana_> but I don't see how I can write a parser combinator that parses only, say, a TString token
09:35:31 <Eelis> elliottt: yes
09:35:39 <Eelis> elliottt: you Trevor?
09:35:50 <EvilTerran> sorry, you've got a [Token] that you want to do something to with Parsec?
09:35:59 <iguana_> yes
09:36:09 <iguana_> sorry for being vague
09:36:50 <elliottt> Eelis: yep :)
09:37:01 <elliottt> just got your message about the irc package suggestions
09:37:17 <Eelis> i see
09:37:30 <Philippa> iguana_: you have to write some basic 'token parsers' using token, tokenPrim, tokenPrimEx et al
09:37:31 <elliottt> i can integrate the changes tonight, and go for a 0.2 release, if you like
09:37:32 <EvilTerran> acceptString t@(TString _) = return t; acceptString _ = fail "acceptString: not a string" --?
09:37:35 <Philippa> then you just carry on as normal
09:37:42 <iguana_> Philippa: yep, and this is where I fail
09:37:46 <Eelis> elliottt: that would be great, obviously :)
09:37:52 <elliottt> :)
09:38:11 <elliottt> i was going to put up the darcs repository somewhere public too, just hadn't gotten around to it yet
09:38:17 <Philippa> @paste
09:38:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:38:30 <Eelis> elliottt: ah, i see
09:38:53 <elliottt> Eelis: how soon do you need a fixed version?
09:39:05 <EvilTerran> !
09:39:06 <hpaste>  Philippa pasted "Token parser example" at http://hpaste.org/2967
09:39:11 <EvilTerran> GenParser isn't Applicative
09:39:24 <EvilTerran> @docs Control.Applicative
09:39:25 <lambdabot> Control.Applicative not available
09:39:30 <Philippa> Parsec predates Control.Applicative somewhat
09:39:44 <Eelis> elliottt: there's no hurry at all. geordi currently uses a very primitive string-manipulation based message "parser", and it works fine. changing it to something more civilized has been a low-priority thing on the todo list for months
09:39:59 <EvilTerran> ah, gotta use WrappedMonad for the Applicative instance. never mind that.
09:40:06 <iguana_> okay
09:40:12 * EvilTerran was thinking there would be an instance Monad m => Applicative m
09:40:34 <EvilTerran> but apparently it's instance Monad m => Applicative (WrappedMonad m)
09:40:38 <Philippa> iguana_: let me know if that's enough?
09:40:39 <iguana_> but I guess it's impossible to do tokenType x that only parses tokens of type x?
09:40:50 <dons> augustss: i've a theory that Data.Number should have been Numerics.*
09:40:59 <iguana_> (because it'
09:41:00 <Philippa> depends what you mean by "type x", but more or less
09:41:11 <elliottt> Eelis: well, i'll try to make the changes tonight then :)
09:41:12 <iguana_> let me try to paste that
09:41:16 <Philippa> you'd be looking to make x some kind of matcher
09:41:17 <EvilTerran> iguana_, what do you mean by "parses"? accepts?
09:41:21 <Philippa> which can't be just the constructor
09:41:22 <Eelis> elliottt: i've only reviewed the irc package's source. i haven't written any code that uses it or anything
09:41:30 <Philippa> at which point you need all the info token asks for anyway
09:41:34 <Eelis> elliottt: ok, great :)
09:42:54 <EvilTerran> seeing as you've already got it all tokened up, "parsing a <blah token>" seems to be an odd thing to want
09:42:57 <sioraiocht> @src unlines
09:42:58 <lambdabot> unlines = concatMap (++ "\n")
09:43:08 <elliottt> Eelis: let me know if you have any other suggestions for it.  i'd been thinking of writing a simple monadic interface around it, to provide basic protocol actions that would hide the handle with each call.  not sure how useful that sort of thing will be, though :)
09:43:11 <EvilTerran> @src unwords
09:43:11 <lambdabot> unwords [] = ""
09:43:11 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
09:43:19 <Philippa> EvilTerran: no, it's as in "parsing a terminal symbol" - atomic parsers that'll match a single token
09:43:48 <Philippa> you can't parse more complex things without them
09:43:53 <EvilTerran> so, return a foo if given that foo, otherwise fail?
09:44:03 <EvilTerran> (given anything that isn't a foo)
09:44:06 <Philippa> that sort of thing, yes
09:44:16 <iguana_> EvilTerran: how would you transform a token list into an AST?
09:44:52 <EvilTerran> it seems an odd use of the word "parse", is all, if it's just a pass/fail kinda thing. i guess i'm not used to the terminology.
09:45:04 <Philippa> presumably you're not /that/ used to parsec either
09:45:11 <EvilTerran> i'll get back to you when i've done languages and compilers next year ;)
09:45:17 <Eelis> elliottt: i kinda like how it currently really only just does message parsing/printing. trying to encapsulate more might be nice, but is not something i would personally be interested in. i'll let you know if i have more suggestions
09:45:19 <Philippa> most people'd call char 'a' a parser in the context of parsec
09:45:41 <EvilTerran> okay then.
09:45:42 <elliottt> Eelis: thanks :)
09:45:47 <Philippa> and parsers're built from smaller ones
09:46:48 <EvilTerran> as i said, i'm not used to the terminology. i haven't talked about parsec that much, mostly just used it from the documentation.
09:48:18 <Philippa> I'm pretty sure the docs (the stuff on Daan's site, not so much the haddock) uses that terminology too
09:48:23 <Philippa> -s
09:49:42 <EvilTerran> i guess so. i didn't make the connection, though, is all. my brain sees characters and already-parsed tokens as disparate.
09:50:14 <Philippa> they're not already-parsed
09:50:22 <Philippa> they're /lexed/, not the same thing
09:50:59 * EvilTerran does the funky "i'm not familiar with the terminology and have already said so twice" dance
09:51:07 * EvilTerran goes to have dinner
09:51:59 <Philippa> yeah, the phase distinction's relevant though. In this case, the tokens're exactly equivalent to the characters in a single-pass setting
09:53:44 <cognominal_> @hoogle  (b -> c ->d ) -> ( a-> (b,c)) -> a -> d
09:53:45 <lambdabot> No matches, try a more general search
09:55:16 <dons> dcoutts: another nice thing is to just edit .cabal files filling out missing synopsis, and categorising them properly
09:57:31 <dcoutts> dons: yes, the .cabal files in the hackage index need not be the same as those inside the .tar.gz file
09:57:50 <dcoutts> they can contain all of hackage's extra meta data and corrections
09:58:27 <dcoutts> eg: x-hackage-build-fails-with: GHC ==6.8.1
09:58:51 <dcoutts> "x-" fields are extensions and Cabal ignores them
10:02:05 <iguana_> @type mapM
10:02:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:04:58 <dons> dcoutts: ah!
10:05:52 <cognominal_> I thought it was possible to define new operators in haskells but
10:05:56 <cognominal_> (..) ::  (b -> c ->d ) -> ( a-> (b,c)) -> a -> d
10:05:56 <cognominal_> (..) g f x =   g ( fst f x) (snd f x)
10:06:04 <dcoutts> cognominal_: .. is a reserved operator
10:06:05 <cognominal_> is not accepted
10:06:14 <dcoutts> using . or ... would be ok
10:06:24 <cognominal_> so what operators are accepted?
10:06:26 <dcoutts> though . is already a defines on
10:06:40 <cognominal_> ho, for ranges
10:06:47 <dcoutts> cognominal_: all possible combinations of symbol chars, except the reserved ones
10:07:17 <dcoutts> just like all normal chars are ok for variable names, except reserved words
10:07:19 <cognominal_> the error message is pretty cryptic
10:07:31 <cognominal_>  parse error on input `..'
10:07:54 <cognominal_> I suppose that the price to pay for fast parsing
10:07:55 <Pastorn_> @src concat
10:07:55 <lambdabot> concat = foldr (++) []
10:08:07 <sek> if i create an instance of data T = {a :: Int; b :: Int; c :: Int}, say x = T{a=3}, then b and c will match to undefined, correct?
10:08:12 <Pastorn_> @src elemIndex
10:08:13 <lambdabot> elemIndex x     = findIndex (x==)
10:08:49 <allbery_b> sek: yes
10:08:57 <allbery_b> ghc will also warn if you have the right options
10:09:53 <allbery_b> be aware that undefined is not something you can actually *match*
10:11:23 <cognominal_> and that's (...) g f x =   g ( fst $ f  x) (snd  $ f  x)
10:11:46 <cognominal_> I  now uderstand the benefit of explicit typing
10:14:49 <cognominal_> @src liftM
10:14:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:15:23 <cognominal_> @src liftM2
10:15:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:15:36 <sek> allbery_b, but if i matched against (T _ b _), then b == undefined would be True right?
10:17:09 <allbery_b> b == undefined would be _|_, I think
10:17:24 <allbery_b> undefined is not a value.  it is an exception
10:18:11 <allbery_b> > let b = 5 in b == undefined
10:18:13 <lambdabot>  Undefined
10:18:21 <allbery_b> lambdabot converts it
10:18:27 <sek> > let a=2 in a/=undefined
10:18:28 <lambdabot>  Undefined
10:18:29 <allbery_b> ghci will print "Exception: undefined"
10:18:41 <sek> crap
10:19:15 <allbery_b> > let a=2 in catch (return (a==undefined)) (\_ -> return True)
10:19:16 <lambdabot>  <IO Bool>
10:19:19 <allbery_b> heh
10:19:57 <sek> allbery_b, i basically have a list of T's (as in the example above), some of which have a a value defined and the other 2 not, others the b value defined and the others not and the same for c
10:20:07 <sek> and i'm trying to collect the defined a,b,c and put them into one T
10:20:14 <allbery_b> "you're doing it wrong"
10:20:16 <allbery_b> consider using Maybe
10:20:20 <sek> ok
10:20:27 <sek> damnit:p
10:21:12 <byorgey> @pl \ g f x =   g ( fst $ f  x) (snd  $ f  x)
10:21:12 <lambdabot> (line 1, column 9):
10:21:12 <lambdabot> unexpected "="
10:21:12 <lambdabot> expecting pattern or "->"
10:21:18 <byorgey> @pl \ g f x ->   g ( fst $ f  x) (snd  $ f  x)
10:21:18 <lambdabot> (`ap` (snd .)) . (ap .) . (. (fst .)) . (.)
10:21:37 <byorgey> hmm... isn't that just uncurry g . f?
10:22:18 <sek> it's quite a bit more complex though. I am parsing a structure "\command1{...} \command2{} .." where i have written a parser for each command and there is an overall data type which is consisted of values that will be returned from the parsers. The commands are unfortunately not in order so what i thought my safest choice was, was to use many1 choice parserlist, and have each parser return my entire data type, with only some values filled in
10:22:32 <byorgey> @pl \g f -> uncurry g . f
10:22:33 <lambdabot> (.) . uncurry
10:22:50 <allbery_b> when I did that kind of thing I passed a defaulted T as state and returned modified versions of it
10:23:12 <EvilTerran> ?type \ g f x ->   g ( fst $ f  x) (snd  $ f  x)
10:23:14 <lambdabot> forall t a b t1. (a -> b -> t1) -> (t -> (a, b)) -> t -> t1
10:23:17 <sek> but now i am stuck with a list of semi-fille data types, when i want to collect all the non-undefined info from each one and pack it all in one
10:23:18 <EvilTerran> ?type \g f -> uncurry g . f
10:23:20 <lambdabot> forall a b c a1. (a -> b -> c) -> (a1 -> (a, b)) -> a1 -> c
10:24:01 <sek> it's just that many1 choice was too convienient
10:24:06 <EvilTerran> sek, might you want a Text.ParserCombinators.Parsec.Perm?
10:24:11 <b_jonas> @pl f x x
10:24:11 <lambdabot> f x x
10:24:18 <b_jonas> @pl \x -> f x x
10:24:18 <lambdabot> join f
10:24:26 <sek> i havent actually read up on how Perm works
10:24:57 <EvilTerran> it sounds like you want permutations, anyway
10:26:39 <sek> quoted from the manual: "A permutation phrase is sequence of elements of possibly different types in which each element occurs at most once and the order is irrelevant"
10:26:57 <sek> my commands are unordered, but each one can happen more than once
10:27:10 <EvilTerran> oh.
10:27:23 <sek> maybe i can generalise the idea though, let me read more thouroughly
10:27:42 <Olathe> A multiset ?
10:27:53 <Olathe> Oh, a set.
10:27:56 <EvilTerran> if something appears more than once, do you want all the instances of it, or only the first/last?
10:28:07 <sek> all
10:28:14 <b_jonas> can you help me formatting a long haskell statement?
10:28:16 <b_jonas> I'll paste it
10:28:19 <sek> in a list of the type that type the parser will return
10:28:28 <sek> s/the type//
10:29:25 <allbery_b> this is from one of my first Haskell programs so probably sucks in many ways, but:
10:29:40 <allbery_b> http://www.ece.cmu.edu/~allbery/FingerConf.hs
10:29:54 <EvilTerran> sounds like you might want to keep with your implementation with many, and then foldl/r the results together
10:30:02 <hpaste>  b_jonas pasted "format the defn of wideFormat" at http://hpaste.org/2968
10:30:24 <allbery_b> the entire configuration thing, plus several of its components, are built up the way you're talking about
10:30:28 <sek> EvilTerran, but how can i *scan* through the semi-filled data types and extract the juice?
10:30:36 <sek> allbery_b, checking
10:30:47 <b_jonas> you may rewrite it a bit if that helps, not only reformat with whitespaces and stuff
10:31:13 <allbery_b> (like as not someone else here will look at it and hpaste something better...)
10:31:16 <b_jonas> I'm asking only the defn of wideFormat, the others are there for context only
10:31:18 <allbery_b> @quote fluxbox
10:31:18 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
10:31:18 <lambdabot> for your entire program.")
10:32:39 <EvilTerran> sek, scan? if you've got a load of semi-filled structures and want to get a complete structure out of 'em, that sounds like folding to me
10:32:45 <b_jonas> "hyper-monas" lol
10:32:51 <EvilTerran> scanning, you'd be left with a list of structures at the end
10:33:09 <sek> i meant *going-through* them:p
10:34:34 <b_jonas> (I'll also have make that function handle negative m-s better...)
10:34:37 <sek> ok so if i had data T = {a::Int, b::Int, c::Int} and [t1,t2,t3] where t1=T{a=1}, t2=T{b=1}, t3=T{c=1}, how could i make up the entire T using a fold?
10:36:10 <hpaste>  EvilTerran annotated "format the defn of wideFormat" with "my version" at http://hpaste.org/2968#a1
10:36:43 <EvilTerran> well, you can't do that, 'cos you've got bottoms everywhere that'll explode if you look at them
10:37:20 <sek> ok
10:38:06 <sieni> bottoms everywhere <3
10:38:19 <crazy_coder> whats the difference between foldl and foldr
10:38:26 <lament> sieni: ...that'll explode if you look at them
10:38:27 <EvilTerran> but if you had data T = T { a :: Maybe Int, b :: Maybe Int, c :: Maybe Int } and instance Monoid T where mempty = T { a = Nothing, b = Nothing, c = Nothing }; mappend (T a1 b1 c1) (T a2 b2 c2) = T (mappend a1 a2) (mappend b1 b2) (mappend c1 c2)
10:38:36 <EvilTerran> say
10:38:37 <b_jonas> foldr reverses its list argument first
10:38:57 <b_jonas> but passes the arguments to the function reversed another time
10:39:05 <sek> EvilTerran, i am unfortunately not allowed to alter the data type=/
10:39:10 <EvilTerran> then mconcat would do what you want
10:39:19 <crazy_coder> i am getting this error :  Occurs check: cannot construct the infinite type:
10:39:20 <crazy_coder>       a
10:39:20 <crazy_coder>       =
10:39:20 <crazy_coder>       [[[Player] -> [[[Player] -> a]] -> [[Player] -> a]]]
10:39:20 <crazy_coder>       -> [[Player] -> [[[Player] -> a]] -> [[Player] -> a]]
10:39:20 <crazy_coder>     Probable cause: `foldr' is applied to too few arguments
10:39:21 <iguana_> say I have foo x = do { xres <- bar x; return Just xres }
10:39:21 <crazy_coder>     In the first argument of `return', namely `(foldr (+) moves)'
10:39:23 <crazy_coder>     In the expression: return (foldr (+) moves)
10:39:35 <iguana_> I bet that can be written more concise
10:39:43 <sek> and unfortunately Parsec's Perm does up to one instance of each parser, i could use many, but i cant guarantee that the commands will be clustered together
10:39:45 <EvilTerran> sek, right... if there's multiple things with a value for a, say, what do you want to do with the duplicated values?
10:40:02 <lament> :t foldr
10:40:03 <iguana_> oops, it should be foo x = do { xres <- bar x; return $ Just xres }
10:40:04 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:40:10 <sek> EvilTerran, well there will supposedly not be, so i can ignore anything after the first
10:40:15 <twanvl> foo x = liftM Just (bar x)
10:40:19 <lament> crazy_coder: what's the type of foldr, and what are you giving it?
10:40:26 <twanvl> or foo x = Just <$> bar x
10:40:30 <sek> EvilTerran, and in some cases the data type contains a list, so i'll cluster them together
10:40:32 <b_jonas> EvilTerran: thanks
10:40:36 <EvilTerran> if there won't be duplicates, perms should be fine, surely?
10:40:42 <crazy_coder> lament: ?
10:40:45 <iguana_> ah, liftM to the rescue :)
10:40:53 <lament> crazy_coder: what's the type of foldr?
10:41:11 <EvilTerran> if you're not expecting duplicates, it should be safe to use perms. to do more is to break YAGNI
10:41:13 <crazy_coder> (a -> b -> b) -> b -> [a] -> b
10:41:22 <EvilTerran> np, b_jonas
10:41:24 <sek> EvilTerran, in the list case there are duplicates though
10:41:39 <lament> crazy_coder: notice any discrepancies between that and (foldr (+) moves) ?
10:41:58 <crazy_coder> how to add all elements in a list
10:42:04 <crazy_coder> a list of integers ?
10:42:05 <sek> crazy_coder, sum ?
10:42:11 <crazy_coder> yes
10:42:11 <sek> > sum [1,2,3]
10:42:12 <lambdabot>  6
10:42:16 <mauke> :t sum
10:42:18 <lambdabot> forall a. (Num a) => [a] -> a
10:42:34 <doserj> @src sum
10:42:35 <lambdabot> sum = foldl (+) 0
10:42:36 <lament> crazy_coder: foldr requires one extra argument, the "base case"
10:42:43 <lament> crazy_coder: which in this case would be 0
10:42:47 <crazy_coder> Oh I forgot yeah
10:42:49 <crazy_coder> thanks
10:42:53 <lament> crazy_coder: because the list "moves" could be empty, and what should foldr return then?
10:42:58 <EvilTerran> hm.
10:42:58 <lament> > sum []
10:42:59 <lambdabot>  0
10:43:16 <EvilTerran> sek, the problem is, with that data type, you can't tell if a value's already been filled or not
10:43:28 <EvilTerran> so you're going to need to use another datatype somewhere
10:43:44 <sek> yes=/
10:44:14 <EvilTerran> can we have a paste of your actual datatype? it might give me some ideas
10:44:17 <sek> i think i will stick with Perm for now and force users to cluster commands together
10:44:22 <sek> ok, just a min
10:45:01 <crazy_coder> lament: I am still getting the error - Occurs check: cannot construct the infinite type:
10:45:01 <crazy_coder>       a = [Player] -> [Player] -> a
10:45:08 <hpaste>  sek pasted "data type" at http://hpaste.org/2969
10:45:35 <lament> crazy_coder: what's the line that causes that?
10:46:08 <sek> EvilTerran, apart from the ones that are clearly lists, modelTransitions is also a list
10:46:19 <crazy_coder> actually now I am using return (sum moves)
10:46:34 <b_jonas> EvilTerran: I can't really see why 'where' is better than 'let' here
10:46:57 <sek> and i'm parsing something like \model{ \transition{..} \transition{..} \header{..} \initial{..}} The problem is i cant guarantee the transitions will be clustered together
10:47:03 <b_jonas> matching (WideSum []) I like
10:47:40 <b_jonas> at least the where for wideFormat
10:47:47 <crazy_coder> lament: thats where I am getting the error
10:47:49 <EvilTerran> b_jonas, it's less noisy, imo. only one word instead of two
10:47:54 <b_jonas> I can see that the where smallFormat makes sense
10:48:06 <b_jonas> because it's used in both bar brances
10:48:08 <EvilTerran> you don't need as many discrete levels of indentation for it
10:48:17 <b_jonas> I don't think so
10:48:39 <b_jonas> the defns in where are indented by 2 as the defns in let { would be
10:48:53 <EvilTerran> eh, ignore that one, then
10:49:16 <EvilTerran> it keeps the "thing being defined = this expression" nice and close together
10:49:54 <b_jonas> yeah, maybe I'm not used to that from other languages
10:50:09 <b_jonas> a postfix where or similar is rarely used in the languages I used
10:50:10 <EvilTerran> it's more like stepwise refinement, i guess
10:50:20 <mux> > appEndo (Endo (+1) `mappend` Endo (+3)) 2
10:50:20 <b_jonas> barring the occasional ((lambda
10:50:32 <lambdabot>  6
10:50:41 <EvilTerran> you can see "oh, foo = bar baz eek" and stop worrying, or you can think "hm, i wonder what that 'baz' is... <have a look>"
10:50:44 <lament> crazy_coder: seems unlikely
10:50:58 <EvilTerran> rather than "foo = let... oh, where's the in?"
10:51:33 <b_jonas> the in is at the end of indentation
10:51:37 <b_jonas> let
10:51:43 <b_jonas>     blah
10:51:45 <b_jonas>      blah
10:51:48 <b_jonas>      blah
10:51:50 <b_jonas> in
10:52:25 <b_jonas> it might be good if the emphasis is on whatever is after the in
10:52:37 <EvilTerran> let blah
10:52:39 <b_jonas> and the defns in the let block are just helpers
10:52:39 <EvilTerran>     blah
10:52:43 <EvilTerran>     blah in
10:52:45 <EvilTerran>     blah
10:52:47 <EvilTerran> :PO
10:53:06 <b_jonas> but here I think it's not more important than the helper functions
10:53:10 <crazy_coder> lament:  I will show you my source code. wait
10:53:14 <b_jonas> well yes, that's ugly
10:53:17 <b_jonas> I don't do that
10:53:25 <b_jonas> I sometimes do things like this:
10:53:33 <b_jonas> blah blah = let
10:53:36 <b_jonas>     blah
10:53:39 <b_jonas>     blah
10:53:39 <hpaste>  twanvl annotated "format the defn of wideFormat" with "Type classes to the rescue" at http://hpaste.org/2968#a2
10:53:40 <b_jonas> in
10:53:43 <b_jonas>     blah
10:53:47 <b_jonas> especially with ifs
10:54:30 <b_jonas> and even when I do what you've shown, I'd put the in at the beginning of the next line
10:54:31 <b_jonas> like
10:54:34 <b_jonas> let blah
10:54:37 <b_jonas>     blah
10:54:42 <b_jonas>     in blah
10:54:46 <b_jonas> never at the end of that line
10:55:00 <b_jonas> though I do this:
10:55:03 <b_jonas> blah and
10:55:06 <b_jonas>     balh
10:55:09 <b_jonas> often in perl
10:55:13 <b_jonas> maybe too often
10:55:17 <hpaste>  crazy_coder pasted "(no title)" at http://hpaste.org/2970
10:55:35 <b_jonas> my perl and ruby coding styles are wierdly inconsistent
10:56:39 <coffeemug> is perl worth learning these days?
10:56:52 <coffeemug> it has always been on my list of languages to learn
10:56:56 <b_jonas> may be, because it has lots of good libraries pre-written
10:56:57 <kscaldef> coffeemug: depends....
10:57:03 <b_jonas> not if you want a nice languages
10:57:05 <lament> sure it is... for the golf!
10:57:12 <b_jonas> perl has too much historical remnants in it
10:57:16 <coffeemug> I already have Lisp and Haskell
10:57:22 <coffeemug> enough nice languages :)
10:57:22 <kscaldef> it's pretty mature, there's still lots of companies using it
10:57:48 <kscaldef> perl is pretty far the other extreme... practicality over "niceness"
10:57:56 <mauke> if you know lisp, perl should be easy
10:58:03 <crazy_coder> lament: paste ^^
10:58:15 <coffeemug> writing scripts in common lisp is impossible
10:58:34 <mauke> if you want to learn perl and have any questions, ask me :-)
10:58:36 <Cin> writing scripts in mzscheme is quite nice
10:58:39 <EvilTerran> hey, where'd sek go?
10:58:40 <cytzol> people seem to like writing scripts in it, at least. probably because it's installed nearly everywhere.
10:58:45 <b_jonas> I think I'll give global names to '\x y -> concat (intersperse x y)' and maybe also to '\x -> "(" ++ x ++ ")"'
10:58:48 <coffeemug> CL completely lacks good libraries for shell scripting type of work
10:58:57 <b_jonas> that would make this defn simpler
10:59:00 <kscaldef> although, I found erlang kind of appealing coming from a perl background... like "here's a functional language that gets out of your way, like perl"
10:59:15 <EvilTerran> =/
10:59:28 <coffeemug> basically I have enough "nice" languages
10:59:30 <kscaldef> so, if you like erlang, you might like perl.  and if you don't like erlang, you might not like perl
10:59:34 <cytzol> it's so tricky to write scripts in CL because of the way lisp works
10:59:41 <coffeemug> I just want a concise language that will let me get dirty jobs done fast
10:59:47 <Cin> cytzol, have you tried Scheme?
10:59:48 <coffeemug> and it seems Perl is better for that than Ruby
10:59:52 <cytzol> you can't just execute a file, you have to load the environment, tell that to run, then quit.
10:59:53 <kscaldef> coffeemug: that's pretty much the defiintion of perl
11:00:03 <b_jonas> coffeemug: you may want to try ruby instead of perl if you don't need lots of existing libraries (though ruby also has lots of them, juts not as much as perl)
11:00:14 <cytzol> Cin: no, but I indent to
11:00:19 <b_jonas> ruby and perl are mostly similar but have somewhat different backsides
11:00:20 <cytzol> Cin: I also inTenD to
11:00:22 <Cin> cytzol, hehe
11:00:25 <Cin> cool
11:00:33 <b_jonas> in fact, ruby's stolen some good things from perl and changed some bad things
11:00:40 <coffeemug> from what I understand ruby isn't as consice
11:00:44 <kscaldef> perl is much more mature than ruby, for better or worse
11:00:51 <b_jonas> I don't think so
11:01:04 <b_jonas> I don't think it's less concise
11:01:16 <kscaldef> perl is a good 10x faster than ruby in most case, has many times more libraries, has unicode support
11:01:18 <lament> crazy_coder: why do you have do and return all over the place? You don't seem to need them.
11:01:22 <b_jonas> no, not 10x faster
11:01:31 <coffeemug> hmm
11:01:40 <b_jonas> that's what I thought as well, because that's what they say and that's what you'd think after reading some sources
11:01:41 <coffeemug> I should also learn to use unix tools better
11:01:46 <b_jonas> but in fact it's just 2x slower
11:01:59 <coffeemug> my knowledge of grep, find, sed, etc. are very minimal
11:02:07 <kscaldef> hmm... that's not what I recall from the shootouts...
11:02:14 <EvilTerran> i find some aspects of ruby frustratingly inconsistent
11:02:22 <b_jonas> EvilTerran: yes, that's true
11:02:26 <Cin> i thought ruby was lisp but with things taken away
11:02:27 <lament> EvilTerran: yeah but we're comparing it with Perl here
11:02:33 <b_jonas> but it's true to perl as well, just for different things
11:02:42 <kscaldef> and perl's implementation has a lot of serious crazy hacks to make it fast
11:02:43 <b_jonas> Cin: not exactly
11:02:47 <b_jonas> ruby is OO
11:02:50 <Cin> that's essentially what the other said
11:02:54 <cytzol> Perl scripts have a lot of serious crazy hacks too
11:02:55 <Cin> b_jonas, and Common Lisp isn't?
11:02:58 <EvilTerran> i prefer perl's inconsistency
11:03:01 <b_jonas> Cin: not as much
11:03:02 <Cin> s/other/author
11:03:05 <kscaldef> cytzol: that's a function of the programmer
11:03:16 <b_jonas> in ruby, most builtin functions are actually methods
11:03:25 <EvilTerran> less in the standard functions, more in the syntax
11:03:29 <Cin> even the author said the object orientation isn't as advanced as CLOS
11:03:42 <kscaldef> but, making a regexp engine as fast as perl's requires lots of black magic
11:03:47 <EvilTerran> oh, nothing's as advanced as Common Lisp, ever!
11:03:49 <b_jonas> I don't know common lisp though
11:03:54 <Cin> kscaldef, perl's is slow..
11:04:01 <EvilTerran> haven't you been told that a hundred times over by smug lisp weenies?
11:04:04 <kscaldef> Cin: compared to what?
11:04:10 <b_jonas> I'm not saying OO is advanced, only that the libraries are implemented in an OO way
11:04:13 <coffeemug> CLOS is amazing
11:04:17 <cytzol> EvilTerran: but it's true!
11:04:21 <b_jonas> you can learn OO not to stand in your way and just not write classes
11:04:27 <Cin> EvilTerran, no, i read it in something the inventor of Ruby said in a newsgroup post.
11:04:33 <b_jonas> so yes, it's not really OO
11:04:41 <coffeemug> CLOS is very very powerful
11:04:45 <EvilTerran> perl's regex system is easy to make run slowly
11:04:51 <coffeemug> you can customize essentially every aspect of its behavior
11:05:02 <b_jonas> EvilTerran: less so these days
11:05:05 <Cin> kscaldef, well, i would say cl-ppcre. but there are different types of regexes and perl's is of the slow kind
11:05:09 <dcnstrct> are we having a Ruby vs Perl conversation ?  Perl has a crappy "hacked on" object system.. Ruby was designed to be an OO language form day one and it shows.
11:05:17 <b_jonas> of course you can make it run slowly if that's your purpose because it's backtracking
11:05:25 <EvilTerran> there are ways of implementing regexes that are more immune to such malarky by design, rather than by patchwork.
11:05:28 <kscaldef> Cin: if you know a regexp implementation that is overall faster than perl's, they would be happy to use it in place of the existing system
11:05:33 <b_jonas> but it performs well on regexen you typocally use
11:05:40 <b_jonas> EvilTerran: sure, dfas
11:05:51 <dcnstrct> coffeemug is right imho.. CLOS FTW!
11:05:54 <Cin> kscaldef, i'm sure they would
11:05:56 <cytzol> cl-ppcre!
11:06:03 <EvilTerran> dcnstrct, i actually quite like perl's OO system.
11:06:05 <b_jonas> but for practical purposes, perl's regexen are quite good
11:06:13 <kscaldef> actually, though, currently the perl regex engine is somewhat slower in "normal" cases to avoid pathelogical cases that require more than the age of the universe
11:06:15 <coffeemug> every other OO system I've seen is a poor imitation of CLOS
11:06:20 <coffeemug> including Smalltalk and Dylan
11:06:38 <Cin> ha
11:06:39 <EvilTerran> it doesn't get in my way as much as other OO systems i've used. although i've noticed people tend to abuse it (much like any other bit of perl)
11:07:15 <b_jonas> kscaldef: that's true
11:07:28 <b_jonas> but it's not that much slow for things you use in the real world really
11:07:33 <kscaldef> right
11:07:54 <b_jonas> and if you want really lots of speed, well, then don't write everything in perl
11:08:03 <EvilTerran> true.
11:08:06 <kscaldef> they chose to take a 10% or so hit for common cases to make some edge cases exponentially faster
11:08:08 <b_jonas> for example, you can use an xml-parser module that's written in c
11:08:16 <dcnstrct> EvilTerran, in my opinion OO in Perl 5 has too many unsatisfactory way to do it and a too verbose syntax.
11:08:43 <lokik> is there a function to get multiple lines taking ending sequence as argument?
11:08:46 <EvilTerran> meh. that's a matter of opinion.
11:08:52 <b_jonas> and, as I'm saying, the perl re is even these days being actively improved
11:08:54 <tcr> coffeemug: What Dylan missing? MOP?
11:08:58 <b_jonas> so it will be better in perl 5.10
11:09:11 <coffeemug> tcr: yeah
11:09:26 <kscaldef> b_jonas: exactly... that's why I said earlier that if anyone knows a faster engine, the perl guys would happily use it
11:09:27 <cytzol> lokik: You want to filter strings based on what they end with?
11:09:35 <coffeemug> tcr: also CLOS is more general, even without MOP
11:10:00 <coffeemug> for example in CLOS you can find your method by checking arguments left to right or right to left
11:10:03 <coffeemug> you can't do that in Dylan
11:10:11 <coffeemug> that's just a simple example
11:10:25 <tcr> coffeemug: I haven't really looked at Dylan so far, but it's object hierarchy seemed to be nicer (standardized extensible sequences and streams)
11:10:32 <cytzol> coffeemug: left-to-right?
11:10:33 <lokik> cytzol: its okay i wrote my own
11:10:44 <kscaldef> speaking of regexen.... for anyone who was following my HXT performance sorrows yesterday (Cale, you around?), it appears that HXT's regex implementation is to blame
11:10:57 <omniscientIdiot> lokik: like f 'x' "abcxdefxghxi" = ["abc","def","gh","i"]?
11:10:59 <Cale> ah
11:11:05 <coffeemug> tcr: well CLOS isn't as pretty, but it *is* more general
11:11:32 <b_jonas> hmm
11:11:33 <Cin> coffeemug, as seem most things lispy
11:11:35 <Cale> kscaldef: It might be possible to fix that -- there are decent regex libraries in GHC now, as I understand it.
11:11:44 <coffeemug> heh
11:11:45 <coffeemug> yeah
11:11:46 <kscaldef> in my example of a 2.5KB document that took 4min to validate, it does almost a _billion_ entries to some of the regex functions
11:11:49 <bos> kscaldef: HXT uses regexps?
11:12:00 <kscaldef> bos: yes, for content validation
11:12:01 <b_jonas> I just realized it's stupid to parenthisize the product in smallFormat
11:12:09 <bos> how weird is that.
11:12:15 <b_jonas> that makes the funciton much nicer
11:12:36 <bos> there's are two sort of decent haskell regexp libraries, neither bundled with GHC.
11:12:55 <bos> the PCRE bindings provide perl-compatible regexps, and are faster than the POSIX regexps bundled with GHC.
11:13:28 <bos> the regex-tdfa package is POSIX-like, and very fast if you don't do grouping, but performance goes to hell if you want to capture a subgroup.
11:13:33 <kscaldef> bos: HXT seems in part to have been written with making some point about regexs in mind.  "His idea  of validating XML by using derivatives of regular expressions was implemented in the validation functions of this software."
11:13:49 <b_jonas> foo (bar baz)
11:13:53 <b_jonas> foo $ bar baz
11:14:03 <b_jonas> equal width
11:14:16 <bos> kscaldef: yes, HXT was written as a masters thesis project, not as a usable piece of software :-)
11:14:18 <kscaldef> I can't imagine, though, that it's really necessary to use regexen to validate XML, though
11:14:23 <bos> of course not.
11:14:34 <kscaldef> bos: how is that different from most other Haskell libraries?
11:14:34 <twanvl> b_jonas: did you look at my annotation of your paste?
11:14:36 <idnar> I would imagine it is not even desireable :P
11:14:37 <kscaldef> ;-)
11:14:45 <b_jonas> twanvl: no, I've missed it
11:15:08 <bos> kscaldef: hey, at least a few haskell libraries aspire to be used :-)
11:15:18 <kscaldef> bos: any of the XML libraries
11:15:19 <kscaldef> ?
11:15:38 <bos> HaXml, allegedly, though the documentation is thin and the API is huge.
11:15:46 <b_jonas> formatList -- tricky
11:16:01 <kscaldef> I tried HaXML before HXT and the validation seemed very, very broken
11:16:19 <dons> hmm, a good xml library for bytestrings would be really useful
11:16:27 <kscaldef> it claimed that every single element and attribute in my document was invalid
11:16:46 <idnar> did you have a DTD?
11:16:53 <kscaldef> so I asked if anyone could help me, and everyone said use HXT instead
11:17:05 <kscaldef> idnar: yes, the document specifies a DTD
11:17:12 <idnar> ok
11:20:17 <bos> dons++
11:20:30 <bos> dons: a good xml library for bytestrings is also many months of work :-)
11:21:16 <bos> see oleg's circa-2001 rants about how awful most xml libraries are
11:21:41 <EvilTerran> s/most//; s/libraries are/is/; IMO :P
11:21:56 <EvilTerran> although that would be my rant rather than his
11:22:09 <dons> bos yeah. we'll see how much i need for work...
11:22:40 <dons> we're going to need parsers and pretty printers, in bytestrings, for a fair few common web formats.
11:22:57 <bos> yeah
11:23:08 <shapr> Will you be using ParsecT for bytestring parsing?
11:23:12 <dons> (also, s/we/my job needs/ )
11:23:18 <shapr> My job too.
11:23:29 <shapr> Sounds like a worthwhile project.
11:23:29 <bos> btw, you'll need charset encoding support, then. bytestring isn't good enough to handle XML.
11:23:41 <dons> right, hence utf8-*
11:23:53 <dcoutts> bos: I've got a bytestring iconv binding, that's one step
11:24:16 * bos has UTF-32 bytestring-alike sitting around without enough time to clean it up
11:24:36 <bos> and codecs for many charsets.
11:25:06 <dcoutts> yes we also need a standard PackedString that presents itself as a sequence of unicode code points
11:25:16 <dons> shapr, if you see here, http://galois.com/xdomain_projects.php (the RSS project i'm working on), we're going to need proper bytestring-based libs for xml, rss, atom, ...
11:25:17 <lambdabot> Title: Cross Domain Technology Services
11:25:32 <dons> so might be a good chance to get some serious libraries paid to be written :)
11:25:38 <kscaldef> dons: XML / the web is more than utf8
11:25:40 <bos> ooh, yummy nummy
11:25:50 <dcoutts> kscaldef: iconv helps there
11:25:54 * Igloo thinks we have (or will have) too many string types. But I don't know how to fix it.
11:25:57 <dons> kscaldef: i was pointing at the utf8-* lib that was written as a start on this issue
11:25:59 <dcoutts> dons: so time is ripe for PackedString then
11:26:15 <dons> Igloo: same issue in other langs too
11:26:36 <dcoutts> Igloo: which is why the type of PackedString should not be parameterised by the encoding
11:26:47 <bos> we really need only two, bytestring and unicode string
11:26:51 <Igloo> dons: Well, in other languages you typically wouldn't have String, LazyByteString, LazyUTF8ByteString
11:26:52 <sjanssen> dcoutts: I concur
11:26:54 <dcoutts> bos: yes.
11:27:08 <dons> Igloo: yeah, i like the model that encodings are done via encode/decode
11:27:11 <Igloo> dcoutts: I don't follow
11:27:29 <dcoutts> Igloo: no, they'd call it a FileStream or something, for the infinite data stream thing
11:27:30 <sjanssen> in memory encoding is an implementation detail.  You don't expose implementation details to users
11:27:51 <kscaldef> sjanssen++
11:27:56 <dcoutts> Igloo: there's a suggestion to parameterise a string type by the encoding, CompactString UTF8 /= CompactString UTF16
11:28:19 <Igloo> Well, a FileStream interface would be a StringLike typecalss in Haskell, but people are avoiding that for performance reasons
11:28:21 <dcoutts> Igloo: it tracks encoding but there should be only one encoding for internal string
11:28:41 <dcoutts> Igloo: for performance and because it's not clear what it should be
11:29:04 <bos> there's little drawback to just using UTF-32
11:29:17 <dcoutts> bos: UTF16 is typically faster apparently
11:29:19 <bos> UTF-16 and UTF-8 are just painful to deal with
11:29:30 <bos> dcoutts: it's faster, but you need 8x as much code
11:29:41 <idnar> why is UTF-8 painful to deal with?
11:29:51 <idnar> I'd say it's less painful than UTF-32, no byte order issues
11:29:52 <dcoutts> UTF16 is mostly fixed width with occasional surrogate pairs
11:30:05 <Igloo> idnar: Think of writing length, !! etc for UTF8
11:30:10 <sjanssen> idnar: lots of fiddly if one byte then ... else if two bytes ..., etc.
11:30:11 <bos> both UTF-8 and UTF-16 require linear scans to find characters
11:30:13 <kscaldef> dcoutts: UTF16 is more compact then UTF-32, not "faster"
11:30:23 <dcoutts> kscaldef: memory throughput
11:30:25 <bos> kscaldef: more compact == faster
11:30:34 <idnar> Igloo: you can just track the length if you need it
11:30:43 <dcoutts> bos: but that doesn't matter, nobody needs to index strings
11:30:53 <idnar> Igloo: and if you want efficient !!, then do something fancier than a linear array of bytes for storage
11:30:55 <kscaldef> bos, dcoutts : if all other things were equal
11:30:56 <Igloo> idnar: You still need a function to find the length to store
11:31:04 <bos> dcoutts: that's not true
11:31:17 <idnar> Igloo: you can calculate the length as you parse the string, initially
11:31:18 <dcoutts> bos: it's pretty rare is it not?
11:31:20 <Igloo> idnar: I'm not talking about performance, I'm talking about why it is painful to deal with
11:31:21 <bos> i often find myself needing to skip a known number of characters
11:31:39 <dcoutts> bos: ok, but not 1000's
11:31:53 <idnar> Igloo: well, if you don't care about performance, !! and length are trivial
11:31:58 <idnar> Igloo: just walk the string
11:32:07 <dcoutts> bos: we're used to [a] where we can't index
11:32:12 <kscaldef> dcoutts: maybe he needs to skip small numbers of characters thousands of times
11:32:27 <Igloo> idnar: Fairly trivial, yes, but large
11:32:51 <bos> dcoutts: we put up with [a], but that's because we have to
11:33:14 <dcoutts> bos: you can always use an array. We use [a] because there are advantages to doing that.
11:33:22 <idnar> Igloo: anyhow, you only have to implement it once, whereas UTF-32 is painful every time you use it
11:33:35 <bos> idnar: no it isn't
11:33:38 <Igloo> idnar: By "painful" do you mean "slower"?
11:33:42 <kscaldef> idnar: who is "you"?
11:33:48 <sjanssen> there is a way to get O(1) indexing with a UTF-16 representation most of the time (depending on your distribution of characters)
11:33:55 <idnar> kscaldef: me, I guess :P
11:33:57 <dcoutts> anyway, I reckon with a Stream based impl, you could get all three UTF encodings without too much work
11:34:06 <idnar> Igloo: no, I mean in terms of ease of use
11:34:18 <kscaldef> sjanssen: if you don't mind being wrong part of the time... UTF-16 is not fixed width
11:34:20 <Igloo> idnar: How is it painful?
11:34:27 <dcoutts> just define stream :: PackedString -> Stream Char  and unstream
11:34:35 <sjanssen> data Utf16String = U16 { fp :: ForeignPtr Word16, offset, bytes, chars :: Int }
11:34:56 <idnar> Igloo: mainly the byte order thing, I guess
11:35:02 <monochrom> I'm wondering why not 32-bit, since Char is already that.
11:35:16 <sjanssen> kscaldef: nah, you just use O(1) code when bytes == chars and do a linear scan when bytes /= chars
11:35:17 <bos> monochrom: exactly
11:35:38 <Igloo> idnar: You only have to worry about that in the couple of functions that read data in and write it out
11:35:39 <idnar> Igloo: if you're using it solely as an internal in-memory storage format, then it probably doesn't make a difference
11:35:42 <Mr_Awesome> can you use functions from the class Random with the State monad?
11:35:51 <bos> idnar: that's what we've been talking about all along
11:36:02 <bos> external encodings are a whole different kettle of fish
11:36:06 <idnar> oh, sorry
11:36:15 <idnar> I guess that'll teach me to jump into conversations too quickly
11:36:16 <kscaldef> sjanssen: I see... so basically you examine all strings when input
11:36:26 <sjanssen> kscaldef: yes, you'd have to
11:36:45 <sjanssen> kscaldef: we need to do that anyway, IMO
11:37:03 <sjanssen> push encoding errors to construction/IO time
11:37:05 <idnar> in some cases you might care about the memory usage, I guess;
11:37:06 <dcoutts> sjanssen: while you can do that, my guess is that the optimisation for indexing is not worth it.
11:37:33 <sjanssen> dcoutts: perhaps
11:37:34 <bos> dcoutts: it's not even the optimisation for indexing that counts. it's the simplicity of not having to deal with combining characters.
11:37:58 <sjanssen> bos: surrogate pairs, not combining characters
11:38:14 <sjanssen> bos: UTF-32 and UTF-16 are pretty much the same wrt. combining characters
11:38:15 <dcoutts> bos: its a trade off between memory use and branch mis-predictions
11:38:38 <Igloo> Right, in UTF32 you can still get   <umlaut> <a> rather than <a umlaut>   AIUI
11:38:38 <dcoutts> UTF16 has more checks than UTF32, for the surrotage pair check
11:39:11 <dcoutts> but UTF16 has half the memory bandwidth
11:39:14 <b_jonas> UTF32 will have those once we have UCS64 :)
11:39:14 <monochrom> I assume that in the next 20 years the third-world countries (e.g., China) and their languages will be very important. Unicode characters outside the 16-bit BMP will be the norm, not the exception. If you use UTF16 as your internal representation, you are just setting up yourself for a Y2K problem to explode in 20 years time.
11:39:50 <omniscientIdiot> Mr_Awesome, I don't see why not, what exactly do you mean?
11:39:52 <sjanssen> monochrom: it's not like the code will crash
11:39:55 <Igloo> Well, nothing will explode, it'll just be less efficient
11:40:03 <dcoutts> bos: according to the ICU folk, since the surrogate pair branches are so rair, they can be predicted never to be taken and the fast path works well. It is certainly more complex code though.
11:40:06 <b_jonas> monochrom: I can't see why because UTF16 can represent those chars
11:40:11 <monochrom> It is still very short-sighted.
11:40:13 * Igloo think UTF32 is the way to go, unless it's substantially slower
11:40:31 <b_jonas> and we have enough developpers and machine speed to use UTF16
11:40:38 <dcoutts> I think we should benchmark all 3 UTF encodings :-)
11:40:44 <monochrom> I mean, if you adopted UTF16 ten years ago, like Java did, I would say that made sense, that was ten years ago.
11:40:51 <Igloo> Hard to know what to benchmark them on, though
11:40:53 <Mr_Awesome> omniscientIdiot: i dont exactly see how id do it. the random functions return g -> (a, g), but you need to return a State g a to use with the state monad
11:40:53 <oerjan> > runState (do n1 <- State randomR (0,10) ; n2 <- State $ randomR (10,20) ; return (n1,n2)) $ makeStdGen 1 -- Mr_Awesome
11:40:54 <lambdabot>   Not in scope: `makeStdGen'
11:41:00 <bos> dcoutts: right. ICU has an army of IBM employees working full time on it.
11:41:00 <oerjan> er...
11:41:01 <allbery_b> 32bit is generally avoided for space reasons, but given haskel's default [Char] that isn't a valid argument :)
11:41:02 <Igloo> UTF32 will do better on random access programs, for example
11:41:19 <omniscientIdiot> @type State
11:41:20 <lambdabot> forall s a. (s -> (a, s)) -> State s a
11:41:29 <oerjan> > runState (do n1 <- State randomR (0,10) ; n2 <- State $ randomR (10,20) ; return (n1,n2)) $ mkStdGen 1 -- Mr_Awesome
11:41:30 <lambdabot>  Couldn't match expected type `(a, (a1, a1))'
11:41:32 <omniscientIdiot> @type State (randomR (0, 10))
11:41:34 <lambdabot> forall t s. (Num t, Random t, RandomGen s) => State s t
11:41:38 <b_jonas> I myself still use iso-8859-2 (though there's no general agreement between that and utf8 in the population yet)
11:41:38 <Igloo> Is UTF8 or UTF16 faster?
11:41:40 <oerjan> oh wait
11:41:51 <b_jonas> because I'm fucked up about all the character set changes
11:41:59 <sjanssen> Igloo: most sources claim UTF16, but I haven't seen much in the way of evidence
11:42:13 <oerjan> > runState (do n1 <- State randomR (0,10) ; n2 <- State $ randomR (10,20) ; return (n1 :: Int, n2 :: Int)) $ mkStdGen 1
11:42:14 <lambdabot>  Couldn't match expected type `(a, (a1, a1))'
11:42:16 <Igloo> Hmm, that's a pity
11:42:21 <oerjan> argh
11:42:31 <oerjan> > runState (do n1 <- State $ randomR (0,10) ; n2 <- State $ randomR (10,20) ; return (n1 :: Int, n2 :: Int)) $ mkStdGen 1
11:42:33 <lambdabot>  ((3,13),1054756829 1655838864)
11:42:36 <omniscientIdiot> oerjan: State (...), use parens or ($)
11:42:51 <b_jonas> it was CWI first, then 852, then 8859-2/1250 then utf8 and utf16 and utf32
11:42:53 <Mr_Awesome> ah, i get it. thanks
11:42:54 <oerjan> i know, i forgot to add it to the first
11:43:00 <Igloo> If UTF8 was faster then we could just go with UTF32, and then do something on top of bytestrings for people who really cared about performance
11:43:21 <Mr_Awesome> itd be nice though if randomR and friends just returned an actual State, or had couterparts that did
11:43:27 <b_jonas> I'd rather wait a few more years to see which one gets the best choice of the utf* ones
11:43:43 <b_jonas> and until that, I just keep using 8859-2
11:43:53 <dcoutts> Igloo: see  http://icu-project.org/userguide/icufaq.html "What is the performance difference between UTF-8 and UTF-16?"
11:43:54 <lambdabot> Title: ICU Userguide
11:44:12 <oerjan> Mr_Awesome: it's a bit strange that there is no Control.Monad.Random in the common distributions
11:44:14 <Igloo> b_jonas: I think you're confusing two things, but if I try and tell you which I'd get the names wrong...
11:44:33 <b_jonas> character sets and encodings?
11:44:41 <b_jonas> well, I should have said encoding all along
11:45:07 <b_jonas> (ucs32 is THE character set, and 8859-2, utf8 etc are character encodings)
11:45:40 <omniscientIdiot> aren't Unicode code points topped off at 0x10FFFF?
11:45:49 <dcoutts> yes, something like that
11:46:08 <Igloo> b_jonas: 8859-2 isn't an encoding of (all of) ucs32, though
11:46:08 <b_jonas> omniscientIdiot: not really. they're not using more than something like that, but they define it to be topped at 2^31 only
11:46:17 <b_jonas> Igloo: yes, that's true
11:46:30 <b_jonas> but it's a one byte per character encoding, which is an advantage
11:46:43 <monochrom> 8-bit die die die
11:46:58 <omniscientIdiot> > showHex (fromEnum (maxBound::Char)) ""
11:46:59 <lambdabot>  "10ffff"
11:47:25 <b_jonas> there was just no point for more than 8 bits while I was still using text console a lot
11:47:34 <b_jonas> because you can't get more than 9 bits from a vga card
11:47:51 <monochrom> Ha!
11:48:14 <b_jonas> now computers are fast enough so I (practically) always use X
11:48:55 <shapr> dons: Yay, paid Haskell libs!
11:49:07 <shapr> dons: I surely like this selenium binding.
11:49:07 <b_jonas> I couldn't use console with current videocards even if I wanted to, though
11:49:15 <b_jonas> but there was a time when I could use both
11:49:30 <shapr> dons: You think it's possible we could collaborate on libs before they're released?
11:49:39 <b_jonas> it's just inconvenient to mix because it takes some seconds to resync when you change video mode
11:49:48 <b_jonas> and there's no way you can avoid that
11:50:05 <b_jonas> (have you ever seen a monitor advertised with "fast video mode change")
11:50:26 <b_jonas> (I think there's none)
11:50:47 <dons> shapr: very likely
11:50:49 <phobes> Why would you want to use text mode anymore?
11:50:58 <dons> shapr: we're holding off on the official selenium release till you send us some feedback...
11:50:59 <shapr> dons: That would be especially spiffy.
11:51:08 <shapr> dons: Should have feedback soon.
11:51:19 <dons> we're using it internally a fair bit now
11:51:39 <dons> atomb is the main guy now though, i'm working on other things
11:51:49 <psnively> Hi guys (and ladies).
11:51:51 <dons> so if you want QC integration, you might need to work on that youself
11:52:04 <dons> i'd like to use QC to test form input handling, for example
11:52:19 <dons> or to generate arbitrary paths through the website (different each run)
11:52:29 <dons> anyway, patches welcome
11:52:44 <b_jonas> phobes: I wouldn't
11:52:46 <b_jonas> that's what I've said
11:52:51 <b_jonas> xterm is fast enough now
11:52:53 <psnively> dons, refresh my memory: for HAppS or WASH?
11:53:05 <phobes> b_jonas:  sorry, wasn't reading carefully enough
11:53:28 <b_jonas> there was a time when I used both because I was used to text mode and it takes time to adjust
11:53:44 <mauke> here's a fun little problem: http://www.spoj.pl/problems/SCYPHER/
11:53:48 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem SCYPHER
11:53:56 <dons> psnively: oh, i was talking about the selenium bindings for testing web stuff
11:54:11 <b_jonas> luckily, computers got fast enough for xterm starting from pentium2
11:54:18 <psnively> Ah, right. We like Selenium.
11:54:38 <b_jonas> and video cards became unsupported by svgatextmode starting from pentium4 times
11:54:45 <b_jonas> so luckily there was a time to change
11:55:06 <shapr> dons: Fair enough
11:55:08 <b_jonas> (though they say rxvt is faster exactly because it's not unicode)
11:55:12 <shapr> y0 psnively
11:55:38 <psnively> shapr: Hey yo!
11:55:50 <shapr> psnively: How's code?
11:55:58 <shapr> psnively: I've enjoyed reading your LtU posts for years :-)
11:56:35 <psnively> Thanks! Code is baking. Posting to LtU much less frequent of late, partially because I'm in startup hell, partially because, well, I'm beginning to feel like it's all been daid.
11:56:37 <psnively> Er, said.
11:56:46 <psnively> (Freudian slip of the month.)
11:56:49 <shapr> haha
11:56:53 <phobes> psnively: startup hell?  What are you working on?
11:57:01 <psnively> http://www.virgincharter.com
11:57:02 <lambdabot> Title: Virgin Charter
11:57:05 <phobes> oh ya
11:57:10 <shapr> I think there's lots more to be said, but I'm not sure there's more that the new batch of LtU users is willing to hear.
11:57:14 <psnively> Not in Haskell, dammit.
11:57:17 <psnively> Or even OCaml.
11:57:20 <shapr> Achilleas seriously burned me out.
11:57:39 <pastorn> @pl (\(x,y) -> (y,x))
11:57:39 <lambdabot> uncurry (flip (,))
11:57:39 <psnively> Oy veh is mir with Achilleas, the heel.
11:58:15 <psnively> Ignorance, I don't mind. Stupidity, I don't mind. Willful ignorance, I mind.
11:58:29 <omniscientIdiot> pastorn: the @pl'd version is cute, but you can't beat the lambda's clarity.
11:58:58 <pastorn> true... just looking for if there was a predefined
11:59:10 <shapr> psnively: I have sometimes wondered whether Achilleas is willfully ignorant. Most of the time I don't think he's doing it on purpose, I think he's just having a serious case of cognitive dissonance.
11:59:19 <psnively> shapr: Oleg's finally pushed me over the edge: I feel the need to become fluent in Haskell.
11:59:31 <EvilTerran> swap :: (a,b) -> (b,a) -- would be nice to have such a thing in Data.Tuple
11:59:31 <dons> can't hurt .. much :)
11:59:37 <shapr> Cool! I don't think you'll regret becoming fluent in Haskell.
11:59:39 <EvilTerran> along with the (->) instance of first, second, etc
11:59:59 <byorgey> mauke: that is a nifty problem =)
12:00:03 <shapr> Whether or not you end up using Haskell for work/play, you'll learn some stuff faster because of research papers and libraries that use Haskell.
12:00:03 <psnively> shapr: I used to agree, but he keeps asking how to do MVC functionally, and refuses to hear "MVC is barely appropriate for objects, and flat isn't for functional programming." Weeks/months later, it's "How do you do MVC functionally?" again.
12:00:21 <shapr> psnively: Yeah, that was the thread that burned me out.
12:00:23 <psnively> I'm sure I won't regret it. I just wish I could write real stuff in it now.
12:00:24 <byorgey> extract a partial order and see if it determines a total order...
12:00:47 <shapr> Me telling Achilleas that MVC can be done with just a few functions, or with arrows, or several other ways, but still doesn't really fit into the FP viewpoint.
12:01:06 <psnively> shapr: Yeah. Besides, lately I'm trying to concentrate more on doing, less on writing about doing.
12:01:11 <shapr> psnively: Smart :-)
12:01:17 <psnively> :-D
12:01:20 <shapr> @eurohaskell
12:01:21 <lambdabot> Unknown command, try @list
12:01:22 <shapr> aww
12:01:31 <shapr> The EuroHaskell motto was "less talks, more code!"
12:01:37 <dolio> Writing about doign is so much easier, though. :)
12:01:55 <psnively> I have an agreement in principle with... er... psykotic, whose real name just fled my head, to do Coq proofs for TAPL.
12:02:21 <shapr> Per Vognensen(sp?)
12:02:26 <shapr> Vognsen?
12:02:28 <shapr> Bah
12:02:30 <psnively> Exactly.
12:02:38 <monochrom> MVC barely appriopriate for objects? What is more appropriate? Please point me in a direction, I'll look further, thanks.
12:02:46 <shapr> psykotic - Per Vognsen
12:03:04 <psnively> monochrom: Arguably, FRP even wins for objects.
12:03:05 <profmakx> wingoto 21
12:03:13 <monochrom> thanks
12:03:16 <shapr> profmakx: You have joined ##c++ !
12:03:23 <psnively> But the implemented alternative would seem to be Morphic, in Squeak.
12:03:36 <profmakx> i surely hope that i didnt shapr ;)
12:03:40 <dolio> conal's work on tangible values looks interesting, too.
12:04:27 <psnively> If you look at the landscape, Swing in Java ends up conflating model and controller like most MVC-in-the-wild implementations do. There have been numerous critiques of it. Morphic came from Self and was adopted by Squeak.
12:06:01 <shapr> dolio: Yeah, tangible values is *very* cool.
12:06:36 <hpaste>  (anonymous) annotated "gief_lulz!" with "(no title)" at http://hpaste.org/2971#a1
12:06:37 <psnively> Bottom line seems to be that doing things in a genuinely event-driven way is hard.
12:06:38 <shapr> I wish I could get Frag to build on 64-bit, I'd like to try to hack Conal's tangible values into a 3D interface.
12:07:23 <psnively> shapr: My pet project for years now has been an Unreal tech editor.
12:07:32 <psnively> First in C++, then OCaml, now likely in Haskell. :-D
12:07:35 <shapr> Have you tried tremulous?
12:07:36 <phobes> Tech?
12:07:36 <psnively> I should look at Frag.
12:07:52 <shapr> Tremulous is my favorite Q3 total conversion.
12:07:55 <psnively> phobes: I mean "UnrealEd clone" with plugins for different games.
12:08:09 <phobes> psnively:  Have you worked with UE3?
12:08:15 <psnively> phobes: No. :-(
12:09:04 <quicksilver> shapr: I keep wanting tangible values to experiment with various different setting in my opengl code
12:09:14 <shapr> quicksilver: ooh
12:09:17 <shapr> That would be cool!
12:09:21 <quicksilver> shapr: but haven't quite got around to figure out how to do it :)
12:09:33 <psnively> Time to learn HOpenGL.
12:09:47 <shapr> Part of the reason I got into Haskell was that I wanted to make a spoken programming language that I could use to 'cast spells' in a 3D interface.
12:09:58 <psnively> Cool!
12:10:00 <shapr> I'd like to speak the code and have it show up in a graphical format.
12:10:12 <mauke> just use LSD
12:10:16 <shapr> heh
12:10:20 <quicksilver> they told me haskell would seem like black magic, but I didn't realise that's what they meant...
12:10:40 <psnively> I think it's white magic.
12:11:01 <psnively> "The power of the Curry-Howard Isomorphism compels you!"
12:11:11 <phobes> I'm still not sold on Curry Howard
12:11:31 <psnively> What's to sell? It's actually a pretty basic observation.
12:11:31 <phobes> I mean it's really quite beautiful, but I'm not sure I see the value as a programming language tool
12:11:50 <phobes> psnively:  I mean I'm not sure I see that you should base your type system on it
12:11:54 <psnively> Ah, I see what you mean. Yeah, you're either into Coq or Epigram or whatever, or you aren't, I think.
12:12:27 <psnively> I frame it as "Your type system is based on it whether you know it or not." The only question is what you do about it.
12:12:48 <phobes> psnively:  I'm not sure that's true
12:13:02 <psnively> Um... OK.
12:13:10 <phobes> I haven't looked deeply at Ontic - would you say the type system there is based on it?
12:13:20 <phobes> (the language sweeney mentions)
12:13:38 <psnively> Probably more than any other!
12:13:46 <phobes> hmm
12:14:06 <psnively> I think the notion of "based on it" is misleading you: if it's an isomorphism, it holds any/everywhere.
12:14:53 <phobes> psnively:   ... I'm not aware of a general isomorphism between an as-of-yet unspecified type system and some logic?
12:15:00 <quicksilver> phobes: yes, there is
12:15:05 <psnively> The only questions are: what logic is at the "proof" and "term" end of the isomorphism, and what programming language is at the "type" and "function" end?
12:15:09 <quicksilver> phobes: any type system corresponds to a logic
12:15:13 <quicksilver> phobes: they are the same thing
12:15:21 <quicksilver> it might not seem like a useful logic....
12:15:28 <psnively> ==quicksilver
12:15:30 <quicksilver> (maybe it doesn't seem like a useful type system)
12:15:49 <psnively> Exactly. C's "logic" and "type system" are just lame. :-D
12:15:57 <quicksilver> curry-howard doesn't just mean "hmm, this tuples and functions stuff is like intuitionistic logic"
12:16:07 <quicksilver> it means "hmm, any type system gives rise to a logic"
12:16:20 <psnively> Or vice-versa.
12:16:27 <quicksilver> right
12:16:35 <phobes> Some logic
12:16:54 <psnively> Yes, some logic (that may or may not be all that useful).
12:17:12 <phobes> What are the requirements on the type system?
12:17:51 <psnively> Good question. I don't think there are any.
12:18:05 <psnively> I'm probably wrong about that, though.
12:18:33 <monochrom> That comes down to "what is a type system" :)
12:19:00 <phobes> right.... if your definitions of type system and logic are isomorphic then you can just take your type system and say "This IS a logic!"
12:19:21 <doserj> well, if your type system is bad, the corresponding logic may just be inconsistent
12:19:29 <phobes> bad = unsound
12:19:36 <doserj> yep
12:19:45 <psnively> Yeah, I was just going to suggest that soundness must play a role.
12:19:54 <psnively> My category-theory-fu isn't sufficient to be more precise.
12:19:57 <monochrom> A type system is a logic of invariants. The invariants are upheld during program execution.
12:20:38 <psnively> Right.
12:20:56 <iguana_> @type maybe
12:20:59 <psnively> Wikipedia on Curry-Howard seems pretty good.
12:20:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:21:22 <psnively> In any case, I'd love to run Ontic, but it seems to be buried in a morass of crufty, non-portable, dated implementation.
12:21:34 <psnively> But playing with Coq has been a real eye-opener.
12:22:06 <omniscientIdiot> > map (maybe 32 fromEnum) [Just 'a', Nothing, Just 'c']
12:22:08 <lambdabot>  [97,32,99]
12:22:14 <quicksilver> Is the Storable instance for Bool bit-packed?
12:22:40 <phobes> psnively:  What's the version of CH for ontic?
12:22:41 <quicksilver> I'm thinking not, because sizeOf is measured in bytes
12:23:07 <psnively> phobes: Not sure. Whatever goes with ZFC, I would guess.
12:23:14 * monochrom goes write "on the unreasonable effectiveness of logic in in type systems" :)
12:23:18 <phobes> psnively:  no
12:23:33 <phobes> This is my point
12:23:36 <psnively> Then I guess I don't understand the question.
12:23:57 <phobes> Ontic works by effectively introducing a logic for the type system
12:23:58 <b_jonas> ok, multiplication seems to work
12:24:06 <b_jonas> not I have a choice
12:24:17 <phobes> If you then try to apply CH I think you're going to get a hideous beast as the result
12:24:24 <psnively> ?
12:24:31 <b_jonas> either I implement division first (which is simple) or comparision (which is complicated)
12:24:34 <dolio> quicksilver: "peekElemOff p i   = liftM (/= (0::HTYPE_INT)) $ peekElemOff (castPtr p) i"
12:24:37 <b_jonas> the two are independedt of each other
12:24:38 <dolio> Looks like no.
12:24:45 <phobes> psnively:  maybe I'm talking nonsense, lemme think this through
12:25:06 <psnively> phobes: I think you're still not understanding: Curry-Howard applies to ALL statically-typed languages. There's no need to "apply" it; it does, without any effort on my part, your part, anyone's part.
12:25:09 <quicksilver> dolio: *nod*
12:25:29 <quicksilver> dolio: trying to build one-bit bitmaps
12:25:34 <psnively> That's the meaning of "isomorphism," oversimplified.
12:25:44 <quicksilver> dolio: think I'm going to have to bit-twiddle somewhat
12:25:59 <psnively> So the question really is: how much does your language support taking advantage of CH?
12:26:03 <phobes> psnively:  An isomorphism is a function and functions can be applied :)
12:26:06 <dolio> quicksilver: UArray Bool is bit-packed.
12:26:44 <psnively> phobes: Sure. The point is that this particular isomorphism is applied (consciously or not) every time someone designs a statically-typed language.
12:26:56 <quicksilver> dolio: I thought that was the case, but it doesn't seem to be formally specified as such
12:27:12 <psnively> When it's done consciously, you tend to get things like Coq, Twelf, Epigram, etc.
12:27:15 <Ben`> how can I print a line sleep for 5 secconds, then print another?
12:27:25 <dolio> Ah, well, I think it is in GHC, at least.
12:27:27 <quicksilver> dolio: it seems a bit ugly to coerce that to a Ptr..
12:27:29 <quicksilver> dolio: *nod*
12:27:43 <psnively> Wen it's done unconsciously, you tend to get things like OCaml, Haskell, Standard ML...
12:27:54 <b_jonas> hmm: head, tail, last, init
12:27:59 <psnively> When it's done without even knowing that the CH exists, you tend to get Java, C++...
12:28:27 <b_jonas> some call them first, rest, last, most
12:28:30 <phobes> psnively:  I'm not sure there's any point in arguing that functions apply themselves when noone is looking - I was using the phrase "applied CH to a type system" to describe the logic that is under the correspondence with a given type system
12:28:52 <b_jonas> " I'm not sure there's any point in arguing that functions apply themselves when noone is looking" lol
12:29:29 <b_jonas> ok, I've decided: fractions first
12:29:36 <psnively> phobes: It depends upon the domain and range of the function, doesn't it? If you put something in one end and get something out of the other, it's hard to argue that that "something" isn't a function, isn't it?
12:30:05 <omniscientIdiot> @hoogle Int -> IO ()
12:30:09 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
12:30:09 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
12:30:09 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
12:30:09 <psnively> It's not at all obvious that "applying a function" necessarily requires an act of will.
12:30:13 <omniscientIdiot> Ben`, ^^
12:30:24 <psnively> And I would expect someone conversant in Category Theory to agree with that. :-D
12:30:35 <omniscientIdiot> @docs Control.Concurrent
12:30:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
12:31:39 * quicksilver cargocults huge chunks mercilessly from sven's examples
12:32:20 <phobes> psnively:  My original statement was " If you then try to apply CH I think you're going to get a hideous beast as the result" .    The act of applying is irrelevant to my point... My statement could be rephrased as "for the type system in question, the CH-corresponding logic is a hideous beast"
12:32:59 <psnively> phobes: I appreciate the clarification, but I think you'd find that Ontic's logic would likely fit on a single 8.5" x 11" page.
12:33:21 <Ben`> omniscientIdiot: thanks
12:33:27 <phobes> psnively:  Possibly, but would anyone have any intuition about it I wonder?
12:33:30 <psnively> (In particular, I think you'd find that the logic as as simple as, or simpler than, the Calculus of Constructions.)
12:33:54 <psnively> phobes: Who cares? You said something about a "hideous beast." I'm making a counterclaim to that.
12:34:04 <omniscientIdiot> @go 1 second in microseconds
12:34:04 <lambdabot> 1 second = 1,000,000 microseconds
12:34:19 <psnively> phobes: If the point is that not enough people are familiar with Pure Type Systems or the Calculus of Constructions, well, then we agree. :-D
12:34:20 <phobes> psnively:  By hideous beast I mean something you wouldn't want to reason through
12:34:40 <phobes> psnively:  My point is that I expect it would look nothing like the CoC
12:34:45 <monochrom> Intuition about Chess is learned by training, as are intuitions about all logics.
12:34:53 <psnively> phobes: That's why we have computers to help us (I don't spend much time reasoning through the Calculus of Inductive Constructions; I use Coq to help me).
12:35:22 <waern_> what's so different about Ontic compared to e.g Coq and the modern stuff?
12:35:39 <phobes> psnively:  But with CoC, if you want to write an assertion like "This operation is commutative" you can encode that in the type system, because the CH correspondence is sane
12:35:45 <MyCatSchemes> :t let y f = f (y f) in y
12:35:48 <lambdabot> forall t. (t -> t) -> t
12:35:59 <psnively> waern_: Ontic has a radically unified type-and-term language. Coq et al tend to make a distinction between types and terms, even if they do have, e.g. infinite type hierarchies.
12:36:21 <waern_> psnively, ah. so it is more like cayenne then
12:36:36 <phobes> cayenne is much closer to CoC
12:36:42 <psnively> waern_: Hard to say. In all of these cases, we're talking about dependent type systems (of course).
12:36:43 <phobes> or other dependently typed languages
12:36:43 <Philippa> psnively: how radically-unified? More so than, say, PTSes?
12:36:56 <phobes> What's a PTS?
12:37:02 <psnively> Philippa: A good question--I've not used any of the Pure Type Systems.
12:37:21 <Philippa> psnively: yes you have, they're a generalisation of the lambda cube :-)
12:37:29 <waern_> psnively;phobes: ok
12:37:50 <psnively> Philippa: That I know. What I meant was that I haven't used any provers or proof-assistants that are self-consciously based on PTSes. :-)
12:38:40 <psnively> But what I've seen of Maude, etc. still looks like it makes a type/term-language distinction that Ontic does not.
12:38:51 <psnively> (Superficially, to my uneducated eyes, anyway.)
12:39:24 <Philippa> PTSes don't have a distinction per se, they just have parts of the syntax that indicate two things are in a relationship akin to term:type (or type:kind, or...)
12:39:34 <b_jonas> ok, and now the difficult part: comparisions
12:40:14 <phobes> Anyway, if you look at how languages like coq or cayenne make use of the CH correspondence, they do it by letting you encode propositions in your type system
12:40:16 <psnively> Philippa, hmmm, good point.
12:40:39 <phobes> and I'm just not sure you'll get that if you try to use CH with a language like ontic
12:41:18 <psnively> phobes: You lost me again: expressing propositions in Ontic is dirt simple.
12:41:43 <phobes> psnively:  But it's not done under CH
12:41:56 <psnively> ?
12:42:26 <Ben`> @src (.)
12:42:26 <lambdabot> (.) f g x = f (g x)
12:42:38 <phobes> ok let me work out an example... maybe I'll realize this is nonsense
12:43:11 <psnively> Someone with considerably greater background in Category Theory than I have is going to have to address that. I think quicksilver has, thus far, expressed it best.
12:43:49 <Philippa> psnively: I think what's being said is that the propositions in Ontic aren't directly equivalent to the propositions in Ontic-the-logic
12:43:56 <psnively> CH doesn't say that you CAN related a type system and a logic; it says that a type system and a logic ARE related.
12:43:59 <b_jonas> is there a convention for what a function that compares a number to zero should return?
12:44:14 <b_jonas> because a function that compares two numbers gives an Ordering
12:44:15 <EvilTerran> @src ORD
12:44:15 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:44:20 <EvilTerran> whups
12:44:27 <EvilTerran> Ordering would be normal, yes
12:44:27 <allbery_b> @src Ord
12:44:27 <lambdabot> class  (Eq a) => Ord a  where
12:44:27 <lambdabot>     compare      :: a -> a -> Ordering
12:44:27 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:44:27 <lambdabot>     max, min         :: a -> a -> a
12:44:33 <EvilTerran> @src Ordering
12:44:33 <lambdabot> data Ordering = LT | EQ | GT
12:44:34 <Philippa> that is, there's a mapping but the logic's screwy and doesn't correspond to how you'd reason with Ontic-the-language
12:44:37 <EvilTerran> that's the one i was after
12:44:42 <b_jonas> EvilTerran: and in which way? LT should mean negative or positive?
12:44:48 <psnively> Philippa: OK, I'll accept that that's what's being said. I still can't get any semantics out of it. :-)
12:44:52 <EvilTerran> negative, i say
12:45:09 <EvilTerran> LT => (<0), EQ => (==0), GT => (>0)
12:45:20 <phobes> psnively: can't get semantics out of what?
12:45:24 <psnively> Philippa: Assuming that that's a faithful rendition of the claim, I claim that it is false.
12:45:34 <b_jonas> so sign x = compare (x - 0)
12:45:48 <phobes> Philippa does seem to be espousing my viewpoint, yes
12:45:48 <psnively> phobes: Philippa's rendition of your observation, to the extent that it is faithful.
12:45:51 <psnively> I see.
12:45:52 <b_jonas> I'm just asking in case there's an existing haskell convention
12:46:00 <EvilTerran> or make your own data Sign = Negative | Zero | Positive
12:46:16 <b_jonas> EvilTerran: yes, that's why I'm asking
12:46:18 <EvilTerran> probably deriving (Read, Show, Eq, Ord, Enum, anything else you might want)
12:46:32 <b_jonas> I probably don't want any of them, all I'll be using this for is in a case
12:46:38 <EvilTerran> the other way is to use signum
12:46:41 <EvilTerran> @src signum
12:46:42 <lambdabot> Source not found. Are you on drugs?
12:46:54 <b_jonas> because I don't want to do two comparisions where one can do
12:46:55 <dolio> @src Int signum
12:46:55 <lambdabot> Source not found. It can only be attributed to human error.
12:47:18 <Philippa> psnively: I can get semantics - if I introduced a term-level "proposition" construct to Haskell, for example, it wouldn't map to the CH propositions (because those map to types)
12:47:18 <EvilTerran> > map signum [-5..5]
12:47:18 <lambdabot>  [-1,-1,-1,-1,-1,0,1,1,1,1,1]
12:47:34 <b_jonas> so then compare x y = sign (y - x)
12:47:43 <phobes> Philippa:  I was thinking about giving that example
12:47:56 <b_jonas> I guess I'll make my own type then
12:48:00 <psnively> Philippa: I think I see... and it also, I think, helps define the "radical unification of types and terms" in Ontic.
12:48:07 <psnively> But I could, of course, be mistaken.
12:48:11 <b_jonas> so that I don't mess it up
12:48:19 <EvilTerran> your own type would be clearer, yes
12:48:40 <phobes> If you wanted to encode that (f x == 1) -> (g x == 1) in a haskell like language, you'd do it by interpretting implies (the -> there) as the -> operator between some types
12:48:41 <EvilTerran> and you don't exactly miss out on masses of functionality like you would if you made something isomorphic-to-a-list-but-not-a-list
12:48:52 <omniscientIdiot> > signum [(-1):+0, (-1):+(-1), 1:+1, 1:+0]
12:48:53 <lambdabot>   add an instance declaration for (Num [Complex a])
12:48:53 <lambdabot>     In the expression:
12:48:53 <lambdabot>   ...
12:49:09 <omniscientIdiot> > map signum [(-1):+0, (-1):+(-1), 1:+1, 1:+0]
12:49:09 <lambdabot>  [(-1.0) :+ 0.0,(-0.7071067811865475) :+ (-0.7071067811865475),0.707106781186...
12:49:12 <phobes> In a language where the correspondence to intuitionist logic isn't so clear, I'm just not sure how you'd proceed under CH
12:49:38 <b_jonas> yes, signum is better for complex numbers
12:49:42 <b_jonas> but this one is for reals
12:49:56 <b_jonas> I want to three-way-case on it
12:50:16 <phobes> In Ontic you don't have to go through CH, because the type system itself is basically strong enough to encode the requirement itself
12:50:16 <psnively> I'll certainly agree that if you can't even identify the logic, it will be hard to take advantage of. :-D
12:50:34 <EvilTerran> um... is complex signum the parallel unit vector?
12:50:36 <phobes> hehe
12:50:52 <dolio> Yes.
12:50:59 <EvilTerran> makes sense
12:51:07 <omniscientIdiot> the requirement is that abs x * signum x = x
12:51:14 <phobes> Anyway, my whole point in all of this is that my current view is that designing a strong type system that doesn't need CH to encode propositions is the way to go
12:51:27 <omniscientIdiot> abs (x :: Complex a) is the euclidean distance from 0.
12:51:28 <psnively> Phobes: That's what I meant when I said Ontic probably is "more based on" CH than anything else is.
12:51:35 <dolio> > signum (0 :+ 0) -- except here
12:51:38 <lambdabot>  0.0 :+ 0.0
12:52:02 <psnively> Phobes: I think we are in vehement agreement. :-)
12:52:11 <phobes> psnively:  cool!  :)
12:52:15 <psnively> Heh
12:52:46 <dmwit> God, zero is constantly making a nuisance of itself.
12:52:51 <psnively> So let's all program in Ontic!
12:53:10 <b_jonas> why, abs x * signum x == x there as well
12:53:20 * waern_ is re-reading the Ontic paper
12:53:53 <phobes> waern_: heh, I hope not because of us :)
12:53:55 <psnively> waern_: Good stuff.
12:54:01 <omniscientIdiot> since abs x = 0 :+ 0, signum x could be anything
12:54:14 <dmwit> b_jonas: True, but signum x is not a unit vector.
12:54:22 <b_jonas> oh yes, that one
12:54:30 <psnively> Tim Sweeney's interest was enough to get me into it.
12:54:52 <waern_> phobes: I re-read tim sweeneys original LtU post about it and it persuaded me to look at the paper again
12:55:19 <phobes> I think don't Ontic is the ideal foundation for a language, but I do think the basic idea of starting out in a strong logic is ideal
12:55:32 <psnively> Tim was hyperventilating a lot at the time. Since then, I think he's modulated his stance. :-)
12:55:45 <phobes> hehe
12:56:08 <psnively> Yeah. I think the more pragmatic launching-off point today is "A Very Modal Model of a Modern, Major, General Type-System."
12:56:22 <phobes> Is that a paper?
12:56:26 <psnively> Yes.
12:56:40 <phobes> crap, I've got to read that
12:56:49 <psnively> http://www.cs.princeton.edu/~appel/papers/modalmodel.pdf
12:56:55 <phobes> already grabbed it :)
12:56:59 <psnively> But of course!
12:57:40 <phobes> o.O  This paper looks like it's out there
12:57:52 <psnively> Yessir.
12:58:25 <dolio> That's a title that'll give Wadler a run for his money.
12:58:59 <psnively> I love the first LtU comment on it: "I'm disappointed the abstract isn't in iambic octameter."
12:59:13 <phobes> When did this get posted to LtU?
12:59:23 <psnively> http://lambda-the-ultimate.org/node/1760
12:59:24 <lambdabot> Title: A Very Modal Model of a Modern, Major, General Type System | Lambda the Ultimate
12:59:37 <psnively> 2006-10-08
12:59:50 <phobes> ya,not sure how I missed it
13:00:09 <psnively> I seem to recall a spike in LtU activity around then.
13:00:32 <phobes> ya, there was one period that had a spike in LtU activity during a period of increased work for me... might have been then
13:00:37 <psnively> I also remember trying to read the paper and going "OW!"
13:02:05 <psnively> "It is also simple, and reduces mainly to defining a Kripke semantics of the G  odel-L  ob logic of provability."
13:02:10 <psnively> Bwahahahahahahahahahahaha.
13:02:16 <phobes> hehe
13:02:52 * EvilTerran runs far away
13:02:54 <dolio> Well, it's obvious just from that sentence.
13:03:02 <dolio> No need to read the paper.
13:03:20 <olsner> nice quote
13:03:30 <phobes> How do you pronounce Kripke anyway?
13:03:43 <phobes> cripk?  cripkey?
13:03:56 <phobes> long i?
13:03:57 <psnively> "Dear, kindly Sargeant Kripke?"
13:04:05 <olsner> creep-kay?
13:04:20 <psnively> I hear it in my head as "Cripkey." But I'm a Merkin.
13:04:35 <EvilTerran> my logic&proof lecturer (canuck) pronounces it "cripkey"
13:04:40 <oerjan> psnively: so, apparently, is kripke himself
13:04:49 <phobes> EvilTerran: thanks
13:04:57 <EvilTerran> (crip as in crippled, key as in key)
13:05:03 <psnively> oerjan: Yeah, but that's rather obviously not an Anglo-Saxon name.
13:05:38 <oerjan> no, but it at least keeps me from beating you up when doing an anglo-saxon mispronunciation of it :D
13:05:47 <psnively> When I say that "Snively" has a long "i," it really is because it follows the morphology of the English language, being an English name.
13:05:55 <psnively> Heh!
13:06:22 <phobes> I always assumed snively had a long i
13:06:34 <psnively> phobes: Then you are among God's chosen few. :-D
13:06:52 <b_jonas> english has rules?
13:07:02 <dmwit> No, English has exceptions.
13:07:07 <psnively> b_jonas: Tons of them.
13:07:09 <psnively> ==dmwit
13:07:18 <b_jonas> yeah, that's the problem
13:07:26 <b_jonas> too many rules = no rules
13:07:44 <psnively> ==b_jonas
13:07:56 <psnively> English is the Lisp of human  languages, apart from popularity.
13:08:06 <EvilTerran> throw new VowelOrderException
13:08:08 <EvilTerran> ;)
13:08:33 <johnnowak> psnively: i would think most english speakers would assume a long 'i'
13:08:53 <psnively> Wait... is that a "new vowel" order exception, a "new vowel order" exception, a "new" vowel order exception...?
13:09:02 <johnnowak> it's snively, not snivly
13:09:19 <psnively> johnnowak: You'd think so.
13:09:19 <psnively> Exactly.
13:09:19 * psnively shrugs after 42 years of this crap.
13:09:19 <olsner> so, it's pronounced sneevely or something?
13:09:29 <psnively> No: Sny-vlee.
13:09:52 <johnnowak> 'i' as in "eye"
13:09:55 <dmwit> I would assume long 'i'.  The odd thing is that if there were two 'l's, I would assume a short 'i'.
13:10:00 <psnively> But I hear "Snih-vlee" constantly, and I mean, constantly.
13:10:01 <omniscientIdiot> 'VCe' is like one of the first pronunciation rules taught in grade school!
13:10:01 <olsner> oh, long 'i' on the *end*?
13:10:31 <psnively> No, in the middle. "Sneye-vlee."
13:10:36 <johnnowak> psnively: I've given up on my name as well. People see "Nowak" and say "No-wack"... but it isn't.
13:10:37 <psnively> Everyone gets "vlee" right. :-D
13:10:53 <psnively> johnnowak: Er... Slavic?
13:11:03 <dylan> johnnowak: no-uk?
13:11:12 <johnnowak> nowak is a common polish name. more like no-vack.
13:11:32 <johnnowak> and the a is more of an o.
13:11:33 <psnively> So much so that it's usually been transliterated in America as "Novak."
13:11:34 <dylan> ah, I've heard that name before. :)
13:11:39 <johnnowak> psnively: aye
13:11:56 <b_jonas> I care more about spelling my name (because people get that wrong often and that can cause problems)
13:12:03 <psnively> Look up "Novak" in the Chicago phone book. :-D
13:12:30 <b_jonas> but that's because my name (and most hungarian names) are more difficult to spell from hearing than to read out
13:12:47 <psnively> b_jonas: You people do funny things with z's. Cut it out. ;-)
13:13:12 <b_jonas> there are lots of names with an old and new spelling variant, both worn by people
13:13:37 <b_jonas> (the worst ones even have two)
13:13:42 <b_jonas> (more than two I mean)
13:13:42 <Olathe> Besides atomicity, what are some other common constraints in parallel programming ?
13:13:59 <psnively> Yes. Honestly, "Snively" is itself an Anglicization of "Schnabel," as are "Shively" and "Snavely."
13:14:13 <b_jonas> Olathe: shutting down a thread the right way if the condition to shut down is initiated from another thread
13:14:13 <EvilTerran> b_jonas, is "jonas" pronounced "yanesh", perchance?
13:14:29 <b_jonas> EvilTerran: that's my nick, it has no official pronounciation
13:14:33 <Olathe> I mean more execution ordering constraints.
13:15:02 <b_jonas> because I use it mostly online and when not then mostly in hungarian
13:15:07 <Olathe> Like you might want to sequence two operations in different threads.
13:15:12 <psnively> Well, the name of the game is ACI, right? "Atomicity, Consistency, Isolation." Just like ACID in databases, just without "Durability," necessarily.
13:15:13 <b_jonas> so I've no idea how it's pronounced in English
13:15:18 <EvilTerran> oh, okay. if it were hungarian, would that be a plausible pronunciation?
13:15:34 <b_jonas> that's difficult as well,
13:15:38 <puusorsa> acid..
13:15:49 <b_jonas> because jonah the prophet is spelt Jns in hungarian
13:15:57 <b_jonas> but I've got the name not from him
13:16:11 <b_jonas> but from the hero of The Giver
13:16:28 <psnively> "MySQL on ACID." Now there's an article title for ya.
13:16:33 <Olathe> ACID seems to just be what I meant by atomicity.
13:16:36 <puusorsa> http://openacs.org/philosophy/why-not-mysql.html
13:16:37 <b_jonas> who was presumable named from the prophet
13:16:38 <lambdabot> Title: Why Not MySQL?
13:16:45 <Olathe> I mean more general than just transactions.
13:16:48 <puusorsa> old, but i'd still rather use postgres
13:16:52 <b_jonas> but whose name is translated to Jonas to hungarian by a good translator
13:17:20 <psnively> Yeah, MySQL 5 with InnoDB in strict mode ain't that bad.
13:17:29 <psnively> Olathe: Atomicity is just the "A" in ACID.
13:17:32 <b_jonas> nevertheless, I think it's translated the same as the prophet in hungarian
13:17:41 <puusorsa> what's the 25 in acid?
13:17:44 <Olathe> psnively: Right, using their definitions.
13:17:51 <Olathe> psnively: By atomicity, I mean all of that.
13:18:05 <b_jonas> which is like yonaash
13:18:07 <psnively> Olathe: Then you're the one abusing the terminology, not them. :-)
13:18:13 <Olathe> OK.
13:18:15 <b_jonas> but with a long o sound
13:18:22 <b_jonas> (as in more)
13:18:30 <psnively> Still, point taken. So what are some concurrency patterns?
13:18:38 <psnively> You know, the Oz people are all over this.
13:18:48 <phobes> How is Oz coming?
13:18:54 <b_jonas> and a long a as in calm
13:18:54 <phobes> Gaining momentum at all?
13:19:00 <b_jonas> and a consonant y
13:19:13 <psnively> phobes: Not AFAICT, and honestly, with as brilliant as the CTM is, I'm shocked.
13:19:31 <b_jonas> though the a is actually a hungarian  which is more open than the english long a
13:19:47 <b_jonas> but I'll ask the translator if I even get to sign my copy of the book
13:20:02 <b_jonas> and I don't really care how you pronounce it until that time
13:20:53 <EvilTerran> b_jonas, i see. intriguing.
13:21:13 <tuomov> Ummm... What happens to errors on liftIO?
13:21:15 <Olathe> psnively: Ahh, concurrency pattern is a nice search term.
13:21:17 <psnively> phobes: I partially blame the pressure on academic CS to get less academic: instead of switching from SICP to CTM, they switch from SICP to Java training.
13:21:18 <Olathe> Thanks.
13:21:26 <psnively> Olathe: Certainly!
13:21:45 <b_jonas> I pronounce it like that because if you try to read out "Jonas" by the hungarian rules then it doesn't sound well, so I assume his intention was not to transscribe it from the English
13:21:56 <puusorsa> java ;(
13:21:57 <b_jonas> that makes sense because he didn't transscribe most of the other names either
13:22:09 <tuomov> It's not possible to have an allocaBytes type of thing in a StateT IO?
13:22:11 <puusorsa> most courses in university of helsinki are in java now
13:22:16 <b_jonas> though he did translate some from Harry Potter
13:22:17 <psnively> puusorsa: Java's OK. Java in "CS" education...
13:22:25 <puusorsa> psnively, exactly
13:22:33 <psnively> Yeah.
13:22:36 <puusorsa> cs should be more theoretical
13:22:39 <byorgey> @type allocaBytes
13:22:41 <lambdabot> Not in scope: `allocaBytes'
13:22:53 <tuomov> it's in IO, not MonadIO
13:23:03 <phobes> well, honestly much of CS you can do in whatever language you have
13:23:04 <tuomov> re-implementing it with mallocBytes runs in the problem of catching errors
13:23:24 <eyeris> Could someone give me a url that explains the f' notation? Google isn't very good at finding ' :)
13:23:27 <phobes> If you think you're going to have to get a job using Java when you're done, it's not so terrible to learn it
13:23:29 <psnively> Sure, you can, but it's good for it not to be obfuscated.
13:23:36 <monochrom> For better or worse, many take CS for an applied field.
13:23:38 <psnively> No, you should learn Java.
13:23:39 <b_jonas> (the author of the book is Lois Lowry and the translator is Tth Tams Boldizsr for the record)
13:23:41 <psnively> ==monochrom
13:24:09 <dmwit> psnively: What is the == idiom you are using?
13:24:14 <phobes> "agrees with"
13:24:18 <dmwit> 'k
13:24:19 <psnively> Sorry: == "Agree with"
13:25:08 <psnively> If I had an enthusiastic, bright teenager, really fired up about CS and asking questions about underlying stuff (wittingly or otherwise), I'd work them through CTM.
13:25:45 <puusorsa> phobes, yeah but doing web apps in java is not my idea of good cs education
13:25:59 <phobes> web-apps, obviously not
13:26:05 <byorgey> eyeris: in what context?
13:26:19 <phobes> but there's something to be said for learning to program in imperative closer to the machine languages
13:26:35 <psnively> I'd teach bare-metal stuff in C, sure.
13:26:53 <hpaste>  eyeris pasted "byorgey: line 59" at http://hpaste.org/2972
13:26:59 <puusorsa> yeah, c, not java
13:27:05 <puusorsa> though i'm biased
13:27:11 <puusorsa> i have an intense dislike for java
13:27:22 <phobes> I actually strongly dislike Java too
13:27:35 <tuomov> I'm beginning to think Haskell isn't much better..
13:27:36 <psnively> I like Scala. :-D
13:27:43 <olsner> getting your feet wet in everything from interconnected gates to haskell (including Java) is probably only good
13:27:44 <oerjan> eyeris: fp' is just a name
13:27:52 <byorgey> eyeris: it's not a special Haskell construct.
13:27:58 <oerjan> ' is a legal identifier character
13:28:02 <eyeris> oh
13:28:05 <eyeris> I see it often.
13:28:13 <eyeris> Is there a convention?
13:28:15 <puusorsa> tuomov, which programming language doesn't suck then?
13:28:15 <monochrom> If you do web apps in Java but you use full-blown formal methods to specify, derive, verify, assert lots of safety and liveness properties, you're doing good cs.
13:28:27 <byorgey> often if you have something named foo, you might name something closely related foo'
13:28:29 <Cale> If x is a variable, x' is usually something related in some way to x
13:28:32 <oerjan> it's commonly used when you want something a little similar to the variable without it
13:28:33 <tuomov> all of them suck, but Haskell isn't what it's touted to be
13:28:34 <EvilTerran> eyeris, usually foo and foo' are somehow related
13:28:38 <tuomov> running into a zillion absurd limitations here
13:28:47 <b_jonas> do you read it out as "prime"?
13:28:50 <puusorsa> tuomov, ok let me rephrase the question: which sucks the least?
13:28:51 <tuomov> and in the end I'd have written this in C already, even with the memory management hell
13:28:52 <Cale> b_jonas: yes
13:28:58 <tuomov> (that I still need to do a bit in Haskell too)
13:29:02 <eyeris> oh, ok
13:29:05 <puusorsa> written what?
13:29:12 <EvilTerran> some people use it instead of separating_words_with_underscores or excessiveUseOfCamelCase
13:29:16 <tuomov> whatever I'm working on
13:29:22 <EvilTerran> you'can'use'it'in'the'middle'of'identifiers'too
13:29:33 <monochrom> Oleg writes like zip'term
13:29:37 <eyeris> yuck.
13:29:39 <b_jonas> prime is a useful thing, though in maths formulas (esp handwritten) I prefer to use superscript star instead
13:29:42 <Cale> tuomov: I take it you haven't been in the best mood lately.
13:29:49 <tuomov> Haskell sort of works as you stick to standard Prelude, and Haskell'98
13:30:04 <tuomov> but anything beyond that is too flaky, experimental, etc. to be actually usable
13:30:09 <byorgey> > let hawai'i = 5 in hawai'i
13:30:11 <lambdabot>  5
13:30:23 <tcr> psnively: In my experience it takes you 1 to 2 years until you grok a topic moderately well; a semester lasts no 6months. So... :)
13:30:23 <puusorsa> true
13:30:33 <b_jonas> but in the middle of identifiers, if you don't want camel case, isn't underscore better?
13:30:39 <puusorsa> haskell will probably be great in a few years or so
13:30:50 <dylan> haskell is great now for most of what I need to do.
13:30:59 <tuomov> fundeps in particular seem too general, because undecidable cases are included
13:31:00 <monochrom> I have found 2nd-rank polymorphism and existential types very robust and usable.
13:31:05 <b_jonas> though two levels of separators can help sometimes
13:31:08 <byorgey> b_jonas: in my opinion, yes, but I'm not sure how you could argue that there is an absolutely "right" answer in that case
13:31:09 <EvilTerran> let don't _ = return () in don't do { ... }
13:31:10 <tuomov> perhaps type families or whatever are a better choice..
13:31:10 <eyeris> btw, is the haskell compiler written in haskell?
13:31:12 <puusorsa> which is nice as i'm jsut le<arning, will prbaly be nice when i canactually do something
13:31:16 <shapr> tuomov: Have you looked at Associated Types?
13:31:22 <byorgey> eyeris: yes! =)
13:31:25 <shapr> tuomov: From what I've heard, ATs will subsume fundeps.
13:31:28 <tuomov> what are those? type families?
13:31:31 <byorgey> eyeris: at least, ghc is
13:31:40 <eyeris> byorgey yeah, that's what I meant
13:31:47 <eyeris> Does anyone actually use hugs, etc?
13:32:02 <b_jonas> EvilTerran: yes, don't is a perl joke: http://search.cpan.org/~dconway/Acme-Don-t-1.00/t.pm
13:32:03 <psnively> Hugs is pretty popular as a faster alternative to GHCi.
13:32:03 <lambdabot> Title: Acme::Don't - The opposite of do - search.cpan.org
13:32:09 <eyeris> it didn't seem to offer anything over ghc to me, but I'm super new
13:32:22 <psnively> "Faster alternative to GHCi." :-)
13:32:28 <puusorsa> b_jonas, threaded intercal for teh win!
13:32:34 <puusorsa> please ... come from
13:32:37 <puusorsa> (as goto is evil)
13:32:39 <psnively> But I hear current GHCi is pretty zippy once it starts up.
13:32:46 <b_jonas> puusorsa: yep
13:32:48 <byorgey> I've heard it claimed that Hugs has nicer error messages for newbies.
13:32:48 <b_jonas> and trintercal
13:32:53 <Philippa> yeah, but hugs actually starts up in a sane length of time on my zaurus
13:33:00 <Philippa> (but it really doesn't matter on the desktop)
13:33:26 <eyeris> oooo, I would like nicer error messages. I'm starting to get the ghci errors though
13:33:28 <Cale> byorgey: I've experienced the opposite
13:33:41 <b_jonas> byorgey: I can belive that as ghc has just reported a type agreement error to me instead of calling a non-function
13:33:44 <Cale> (at least, back when I was a beginner)
13:33:59 <tuomov> anyway, the latest problem is that monad transformers seem to be crap
13:34:06 <byorgey> good error messages are Really Hard
13:34:07 <b_jonas> how could it even not match the type of a calling a non-function expressoin
13:34:08 <tuomov> no way to actually catch IO errors
13:34:17 <b_jonas> byorgey: yes, that's true
13:34:20 <eyeris> So does anyone here actually work on Haskell as a language or on a compiler? My guess is that Cale does :)
13:34:24 <tuomov> and thus do 'withSomething' type of stuff
13:34:27 <EvilTerran> tuomov, can you write in a way so as to not have them thrown in the first place?
13:34:45 <Cale> eyeris: I don't actually, though perhaps it could be claimed that I should.
13:34:45 <monochrom> Fun! call/cc is at the same time goto and come-from! (also other control operators)
13:34:55 <dylan> huh? I'm pretty sure I've caught IOErrors in ReaderT before. :P
13:34:57 <tuomov> sounds like an ugly hack... something that does a raw 'malloc' should catch things..
13:35:09 <byorgey> eyeris: ndm has done work on a Haskell compiler (yhc)
13:35:21 <psnively> I thought it was proven that call/cc == Landin's J == everything?
13:35:31 <bos> you can catch errors if you're in a monad transformer on top of IO, you might just need to lift the exception handler into your stack
13:35:33 <byorgey> I'm sure there are others but I don't know off the top of my head.
13:35:33 <tuomov> I'd rather avoid the overhead of ForeignPtr..
13:35:49 <tuomov> and there's still the issue that other errors might be best caught
13:35:49 <byorgey> I don't know of any ghc developers that hang out in here (?).
13:36:07 <psnively> What, SPJ has better uses for his time? ;-)
13:36:08 <bos> byorgey: several do: igloo, jaffacake, and others
13:36:10 <tuomov> bos: but I can't catch errors in a non-IO function
13:36:31 <tuomov> s/function/monad action/
13:36:31 <bos> tuomov: i thought you said you were in StateT IO?
13:36:35 <monochrom> IIRC yes, call/cc == J. If you have state, you also get delimited continuations.
13:36:55 <eyeris> I started learning Haskell after I read some stuff by Simon Peyton Jones. I can't tell yet if I like it or if I just like being challenged again :)
13:37:09 <byorgey> ah yes, forgot about Igloo.  I don't think I've met jaffacake, maybe we are on different schedules. =)
13:37:11 <tuomov> yes, and I want to do something like: with_foo :: MonadIO m => (Ptr b -> m c) -> m c
13:37:25 <psnively> monochrom: right.
13:37:49 <tuomov> now what if an IO error is thrown in the handler?
13:37:52 <byorgey> eyeris: well, whichever it is, I hope you enjoy =)
13:37:56 <tuomov> I can't catch it!
13:37:58 <tuomov> or so it seems to me
13:38:13 <EvilTerran> liftIO (whatever your catch thing is) doesn't work?
13:38:49 <tuomov> what does liftIO do to errors? And how would it help when my handler isn't in IO?
13:39:03 <bos> tuomov: you ought to be able to lift your handler into IO using it
13:39:11 <tuomov> I expect that running into an error in liftIO just returns you outside your transformed monad
13:39:59 <tuomov> http://www.haskell.org/pipermail/libraries/2003-February/000774.html
13:40:01 <lambdabot> Title: FW: MonadIO needs catch?, http://tinyurl.com/2nymyg
13:40:01 <tuomov> that seems relevant
13:40:09 <monochrom> Yes.
13:41:15 <dolio> What about catchError?
13:41:29 <monochrom> Some MonadIO instances may be unable to support catch, even if you try. Therefore, perhaps we should keep MonadIO for just liftIO, and create a subclass MonadIOExc for catch support.
13:42:10 <tuomov> It seems to me that errors in general need a major overhaul...
13:42:26 <b_jonas> tuomov: isn't it catching errors only?
13:42:32 <b_jonas> just dieing from errors don't
13:42:32 <EvilTerran> tuomov, feel free to invent something better
13:42:47 <b_jonas> and dieing covers most of the cases
13:42:48 <tuomov> b_jonas: eh?
13:42:59 <tuomov> dolio: I don't see how it even is relevant?
13:43:09 <oerjan> you could write a variant of liftIO that catched errors and turned them into throwErrors of the enclosing monad...
13:43:18 <oerjan> *caught
13:43:24 <oerjan> i think
13:43:39 <tuomov> maybe you can somehow write a variant of liftIO that transforms IO errors into other errors?
13:43:39 <b_jonas> s/dieing/dying/
13:43:49 <oerjan> that's what i meant
13:43:58 <tuomov> yeah, my eyelids are closing..
13:44:09 <dolio> @type catchError :: StateT s IO a -> (IOError -> StateT s IO a) -> StateT s IO a
13:44:11 <lambdabot> StateT s IO a -> (IOError -> StateT s IO a) -> StateT s IO a :: forall s a. StateT s IO a -> (IOError -> StateT s IO a) -> StateT s IO a
13:44:12 <tuomov> and this is getting complicated..
13:45:01 <oerjan> but it couldn't be used with just StateT s IO - you would need an ErrorT in there.
13:45:07 <tuomov> ErrorT StateT IO or whatever.. yugh
13:45:14 <monochrom> @src help
13:45:15 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:45:25 <tuomov> it gets totally unwieldy
13:45:33 <monochrom> @src catchError IO
13:45:33 <lambdabot> Source not found. It can only be attributed to human error.
13:45:47 <oerjan> tuomov: so define a type synonym for your monad
13:45:58 <dolio> @src IO catchError
13:45:58 <lambdabot> catchError = catch
13:46:13 <tuomov> and write a liftM in front of every statement?
13:46:36 <oerjan> huh?
13:46:38 <monochrom> Thanks. I'm convinced catchError for StateT s IO a works.
13:47:18 <oerjan> monochrom: it will lose the state, won't it?
13:47:31 <monochrom> Err, I'm missing an ErrorT there, too.
13:47:41 <oerjan> oh right, IO _is_ a MonadError instance
13:47:42 <monochrom> Oh! No need for ErrorT.
13:48:13 <monochrom> ErrorT would only introduce another type of exceptions unrelated to IO's. :)
13:48:15 <tuomov> hmm.. maybe it could work
13:48:31 * monochrom is happy now :)
13:49:04 <tuomov> but some kind of hacked liftIO is still needed?
13:49:26 <shapr> @seen dnm
13:49:27 <lambdabot> I saw dnm leaving #haskell 1d 3h 13m 51s ago, and .
13:49:38 <monochrom> catchError for StateT s m a  carefully preserves: (a) the state, (b) the error semantics of m.  Now let m = IO...
13:50:17 <Philippa> tuomov: essentially, yep. Or a catch wrapper. This shouldn't really be much of a surprise given the current exception model
13:50:35 <oerjan> monochrom: the state from the point of throwing, or from the point of initializing the handler?
13:51:21 <oerjan> i think the former.
13:51:33 <oerjan> it forgets all changes in between if an error occurs.
13:51:57 <drigz> how do i get the source of an class instantiation?
13:52:05 <drigz> e.g. instance Num Ratio
13:52:15 <dons> we use a little wrapper in xmonad for intercepting exceptions from lower down
13:52:17 <dons> catchIO :: IO () -> X ()
13:52:17 <dons> catchIO f = liftIO (f `catch` \e -> do hPutStrLn stderr (show e); hFlush stderr)
13:52:22 <dons> if that's helpful
13:52:33 <dons> hmm, that should be an hPrint.
13:52:39 <dons> someone mustn't have known about that function
13:52:52 <tuomov> doesn't seem relevant to me: the catch is in IO
13:53:06 <dons> right. you want to an error handling transformer?
13:53:09 <dons> catchError et al?
13:53:25 <tuomov> yep, if it actually works with liftIO etc.
13:53:29 <dons> you've looked at MonadError?
13:53:31 <tuomov> which it might, from the types
13:53:35 <tuomov> they seem to match
13:53:42 <monochrom> @src StateT catchErrot
13:53:42 <lambdabot> Source not found. Wrong!  You cheating scum!
13:53:45 <monochrom> @src StateT catchError
13:53:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:53:45 <dons> :t Control.Monad.Error.catchError
13:53:50 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
13:54:03 <tuomov> MonadError IOError IO ; MonadError e m => MonadError e (StateT s m)
13:54:05 <tuomov> looks good
13:54:13 <dons> i've used throwError/catchError for similar things in lambdabot
13:54:21 <dons> StateT (ReaderT ..) iirc
13:54:26 <dons> ah, here we go:
13:54:27 <dons>   m `catchError` h = lbIO $ \conv -> (conv m
13:54:27 <dons>               `catchDyn` \(SignalException e) -> conv $ h $ SignalCaught e)
13:54:27 <dons>               `catch` \e -> conv $ h $ IRCRaised e
13:54:53 <dons> newtype ModuleT s m a = ModuleT { moduleT :: ReaderT (MVar s, String) m a } deriving (Functor, Monad, MonadTrans, MonadIO, MonadError IRCError, MonadState t)
13:55:16 <dons> i wonder if you can just use newtype deriving, tuomov, to inherit a MonadError implementation?
13:55:24 <dons> (you probably want to customise it though)
13:56:01 <tuomov> I think I might not have to do anything other than catch errors with catchError... but it will take long before I can test that out
13:56:14 <monochrom> oerjan: m `catchError` h = StateT $ \s -> runStateT m s `catchError` \e -> runStateT (h e) s
13:56:43 <monochrom> So it says, if h is run, it starts from the state before m starts.
13:57:01 <oerjan> right, i was reading that too
13:57:38 <oerjan> whether that is enough obviously depends on the application
13:58:16 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2973
13:58:35 <tuomov> maybe like that.. haven't tested it through the compiler
13:58:49 <b_jonas> lazyness allows fold to terminate early, which makes you need somewhat less library functions on lists
13:59:37 <puusorsa> http://www.intternetti.net/~jiri/motivation/programming.jpg
14:00:41 <b_jonas> @hoogle (a -> Maybe b) -> [a] -> (Maybe b)
14:00:41 <lambdabot> No matches, try a more general search
14:00:44 <b_jonas> @hoogle (a -> Maybe b) -> [a] -> Maybe b
14:00:45 <lambdabot> No matches, try a more general search
14:00:54 <BoudewijnE> hi everybody
14:01:05 <BoudewijnE> I've got a small problem again
14:01:17 <BoudewijnE> I'm using an IO function, and having some problem with it's return type
14:01:19 <b_jonas> I want a findWith
14:01:26 <dolio> @type \f -> msum . map f
14:01:28 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
14:01:44 <hpaste>  BoudewijnE pasted "IO" at http://hpaste.org/2974
14:01:52 <Cale> BoudewijnE: okay
14:01:59 <BoudewijnE> would someone be so kind to help me?
14:02:17 <BoudewijnE> the function should work, afaik but I'm still messing around using the IO type
14:02:20 <Cale> BoudewijnE: you have something of type Guess as a line in a do-block
14:02:29 <BoudewijnE> yes
14:02:29 <omniscientIdiot> @type readInt
14:02:30 <Cale> The lines of a do-block should be actions
14:02:31 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
14:02:43 <BoudewijnE> type Row = [Int]
14:02:44 <BoudewijnE> type Guess = Row
14:02:44 <Cale> But a Guess is not an IO action -- what do you want to do with the Guess?
14:02:48 <BoudewijnE> this is my guess type
14:02:53 <BoudewijnE> well, I want to return it
14:02:55 <b_jonas> is there a find function typed (a -> Maybe b) -> [a] -> Maybe b that finds the first element of a list for which the function gives a just and returns that just if found?
14:02:57 <BoudewijnE> it's just a [Int]
14:03:08 <oerjan> BoudewijnE: so use return :)
14:03:09 <Cale> return (map readInt (words l))
14:03:26 <Cale> return turns a value into an IO action which does nothing but return that value
14:03:27 <EvilTerran> b_jonas, find.isJust
14:03:31 <EvilTerran> ?type find.isJust
14:03:32 <BoudewijnE> why do I have to use it in a IO-based function, and not in normal functions?
14:03:34 <omniscientIdiot> b_jonas: dolio @type'd it above
14:03:34 <lambdabot>     Couldn't match expected type `a -> Bool'
14:03:34 <lambdabot>            against inferred type `Bool'
14:03:37 <EvilTerran> hm.
14:03:39 <BoudewijnE> aahhh okay
14:03:41 <EvilTerran> ?type find.(isJust.)
14:03:41 <BoudewijnE> I see
14:03:42 <BoudewijnE> thanks
14:03:42 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> Maybe a1
14:03:45 <Cale> BoudewijnE: Because it turns them into IO actions :)
14:03:56 <Cale> BoudewijnE: It's important to notice that it's not a keyword
14:03:57 <EvilTerran> hm. that's not quite right.
14:04:07 <BoudewijnE> @Cale, why not?
14:04:07 <lambdabot> Unknown command, try @list
14:04:11 <BoudewijnE> Cale, why not?
14:04:16 <b_jonas> @info msum
14:04:16 <lambdabot> (msum)
14:04:16 <Cale> BoudewijnE: Just a function which makes IO actions out of values.
14:04:16 <EvilTerran> ?type catMaybes
14:04:18 <lambdabot> forall a. [Maybe a] -> [a]
14:04:26 <EvilTerran> ?src msum
14:04:26 <lambdabot> msum =  foldr mplus mzero
14:04:29 <dmwit> ?info Monad
14:04:29 <lambdabot> (Monad)
14:04:34 <dmwit> ?src Monad
14:04:34 <lambdabot> class  Monad m  where
14:04:34 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:04:34 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:04:34 <lambdabot>     return      :: a -> m a
14:04:34 <lambdabot>     fail        :: String -> m a
14:04:35 <omniscientIdiot> @src Maybe mplus
14:04:36 <lambdabot> Nothing `mplus` ys  = ys
14:04:38 <EvilTerran> > msum [Nothing, Just 1, Nothing, Just 2]
14:04:38 <lambdabot> xs      `mplus` _ys = xs
14:04:41 <lambdabot>  Just 1
14:04:43 <Trixsey> How do I add a single element to a list?
14:04:45 <Cale> BoudewijnE: As such, it doesn't have its usual meaning with respect to control in imperative languages: return x in the middle of a do-block is a no-op.
14:04:53 <dmwit> Trixsey: Use (:), as in
14:04:53 <Cale> Trixsey: x : xs ?
14:04:58 <dmwit> > 1:[2,3,4]
14:04:59 <lambdabot>  [1,2,3,4]
14:05:01 <Trixsey> ohh yeah.. ok :D
14:05:03 <BoudewijnE> okay I see, thanks :)
14:05:09 <dpiponi> Anyone know why I get this building X11 (for xmonad): Setup.hs: got error code while preprocessing: Graphics.X11.Types
14:05:10 <Trixsey> forgot :/
14:05:11 <Trixsey> :)
14:05:24 <dpiponi> On a suse Linux box
14:05:40 <dmwit> dpiponi: You'll get more help in #xmonad, but did you autoreconf?
14:05:45 <nomeata> dpiponi: are you building X11 or X11-extras?
14:05:54 <b_jonas> in which module is that msum?
14:05:55 <dpiponi> There's a #xmonad?!?
14:06:00 <shapr> sure!
14:06:03 <shapr> @listchans
14:06:03 <lambdabot> ##logic #darcs #friendly-coders #gentoo-haskell #ghc #haskell #haskell-blah #haskell-hac07 #haskell-overflow #haskell-soc #haskell.it #jtiger #parrot #perl6 #scala #scannedinavian #unicycling #
14:06:03 <lambdabot> xmonad
14:06:07 <mauke> @index msum
14:06:07 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:06:12 <dmwit> heh, #unicycling
14:06:45 <monochrom> In these days of multicore, haskellers should contemplate multicycling.
14:07:06 <b_jonas> @where msum
14:07:07 <lambdabot> I know nothing about msum.
14:07:09 <dmwit> Well, I'm no technophile, but I bicycle regularly.
14:07:13 <pizza_> multicycling?
14:07:15 <dcnstrct> oh thats sooooooo bad
14:07:21 <dcnstrct> why can't I stop laughing ?
14:07:25 <oerjan> @hoogle msum
14:07:26 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
14:07:26 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
14:08:07 <lament> I multicycle!
14:08:09 <b_jonas> I see
14:08:10 <b_jonas> thanks
14:08:15 <lament> i own two bicycles since yesterday
14:08:17 <shapr> cool
14:08:57 <b_jonas> I asked because the docs index says there's one in Control.Monad and one in Data.Foldable
14:09:19 <b_jonas> apparently the second is a generalization of the first one
14:11:13 <b_jonas> ah, I've found another solution:
14:11:35 <b_jonas> @t \f l -> first (mapMaybe f l)
14:11:36 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
14:11:40 <b_jonas> @type \f l -> first (mapMaybe f l)
14:11:42 <lambdabot>     Couldn't match expected type `a b' against inferred type `[]'
14:11:43 <lambdabot>       Expected type: a b c
14:11:58 <dmwit> ?help thx
14:11:58 <lambdabot> Plugin `help' failed with: IRCRaised Plugin/Dummy.hs:(23,19)-(46,62): Non-exhaustive patterns in case
14:12:02 <dmwit> ?thx
14:12:02 <lambdabot> you are welcome
14:12:15 <oerjan> b_jonas: head instead of first?
14:12:21 <b_jonas> yeah, head
14:12:26 <b_jonas> @type \f l -> head (mapMaybe f l)
14:12:28 <lambdabot> forall a a1. (a -> Maybe a1) -> [a] -> a1
14:12:41 <oerjan> or perhaps listToMaybe
14:12:59 <oerjan> if you want to keep the Just
14:13:01 <dmwit> :t mapMaybe
14:13:02 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
14:13:03 <b_jonas> that works only if I know there's a match
14:13:09 <b_jonas> yes, right
14:13:15 <b_jonas> it's good to know both
14:13:19 <b_jonas> but here I know there's a match
14:13:23 <dmwit> You could use msum.
14:13:52 <dmwit> :t msum . map
14:13:53 <lambdabot>     Couldn't match expected type `[m a]'
14:13:53 <b_jonas> I could, yes, but I don't know MonadPlus yet
14:13:53 <lambdabot>            against inferred type `[a1] -> [b]'
14:14:07 <b_jonas> :t (msum .) . map
14:14:07 <dmwit> :t (msum .) . map
14:14:09 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
14:14:10 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
14:14:26 <omniscientIdiot> b_jonas: MonadPlus, at least for Maybe, is easy!
14:14:35 <omniscientIdiot> @src Maybe mzero
14:14:35 <lambdabot> mzero = Nothing
14:14:38 <omniscientIdiot> @src Maybe mplus
14:14:38 <lambdabot> Nothing `mplus` ys  = ys
14:14:39 <lambdabot> xs      `mplus` _ys = xs
14:15:53 <dmwit> > (msum [Nothing, Just 1, Just 2], msum [Nothing, Nothing, Nothing])
14:15:57 <lambdabot>  (Just 1,Nothing)
14:16:15 <puusorsa> Maybe Just Nothing
14:17:13 <dolio> @pl maybe Nothing Just
14:17:13 <lambdabot> maybe Nothing Just
14:17:26 <omniscientIdiot> = id -- :)
14:18:21 <omniscientIdiot> @list pl
14:18:21 <lambdabot> pl provides: pointless pl-resume pl
14:22:29 <omniscientIdiot> @scheck liftM2 (==) (maybe Nothing Just) id :: Maybe Int -> Bool
14:22:30 <lambdabot>   Completed 12 test(s) without failure.
14:22:48 <mdmkolbe> @help scheck
14:22:48 <lambdabot> scheck <expr>
14:22:48 <lambdabot> You have SmallCheck and 3 seconds. Test something.
14:23:03 <ukl> hey....is there any usable audio player written in haskell? (I can't get minstrel to work...would use another one, too)
14:23:06 <omniscientIdiot>  @check said no Arbitrary (Maybe a) :(
14:23:20 <omniscientIdiot> @where hmp3
14:23:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
14:23:47 <omniscientIdiot> never used it, but it's the first to come to mind
14:23:56 <ukl> oh, i forgot, "gstreamer-based" is another issue....
14:24:09 <ukl> (hmp3 needs mpg321)
14:24:33 <puusorsa> quodlibet ftw
14:27:42 <b_jonas> another annoying list question: is there a better way to say 'length (filter cnd lst)'
14:28:07 <puusorsa> no
14:28:08 <mdmkolbe> @pl length . fileter cnd lst
14:28:08 <lambdabot> length . fileter cnd lst
14:28:09 <puusorsa> lol!
14:28:23 <b_jonas> mdmkolbe: that's wrong though
14:28:28 <mauke> sum . map (fromEnum . cnd)
14:28:35 <b_jonas> @pl length $ filter cnd lst
14:28:35 <lambdabot> length (filter cnd lst)
14:28:51 <b_jonas> mauke: yes, that would work
14:28:53 <oerjan> (length . filter cnd) lst
14:28:54 <b_jonas> is that better?
14:29:00 <mauke> b_jonas: no :-)
14:29:03 <b_jonas> I mean, it needs an intermediate list too
14:29:13 <omniscientIdiot> b_jonas: length filter is pretty clear
14:29:24 <mauke> isn't length/filter smart enough to eliminate the intermediate list?
14:29:31 <b_jonas> omniscientIdiot: sure, but it builds a temp list which may not be optimized away
14:29:36 <b_jonas> I've no idea
14:29:44 <monochrom> You can hand-calculate the fusion of length and filter, both being definable as foldr's.
14:29:55 <b_jonas> because of lazyness the list doesn't cost memory only time I think
14:30:16 <monochrom> err, maybe filter is not definable as foldr, but anyway, you can hand-calculate anything.
14:30:21 <sjanssen> monochrom: it is
14:30:32 <monochrom> really? nice!
14:30:40 <Botje> @src filter
14:30:40 <lambdabot> filter _ []     = []
14:30:40 <lambdabot> filter p (x:xs)
14:30:40 <lambdabot>     | p x       = x : filter p xs
14:30:40 <lambdabot>     | otherwise = filter p xs
14:30:47 <Botje> what, no list comprehension?
14:30:48 <sjanssen> filter p = foldr (\x xs -> if p x then x:xs else xs) []
14:31:21 <newsham> http://speaklolcat.com/?from=filter+p+%28x%3Axs%29%0D%0A+++++%7C+p+x+++++++%3D+x+%3A+filter+p+xs%0D%0A++++%7C+otherwise+%3D+filter+p+xs%0D%0A
14:31:23 <lambdabot> Title: speak lolcat - lolcat translator, http://tinyurl.com/2vpf6z
14:31:35 <sorear> filter p xs = [ x <- xs, p x ]
14:31:36 <oerjan> Botje: i think possibly list comprehensions are defined in terms of filter etc.
14:31:54 <b_jonas> yeah, foldr could work
14:31:55 <sorear> oerjan: iirc, they are defined in terms of concatMap
14:32:05 <xerox> [ x | x <- xs, p x ]
14:32:10 <oerjan> sorear: not the guard part surely?
14:32:17 <omniscientIdiot> oerjan: list comps are hard-wired syntax
14:32:21 <sorear> oerjan: if p then [x] else []
14:32:22 <Botje> aren't they just syntactic sugar for do{} blocks? :)
14:32:27 <sorear> oerjan: BITD they were defined using return, mzero, and >>=
14:33:04 <oerjan> D?
14:33:08 <dmwit> day
14:33:15 <sjanssen> @seen dcoutts
14:33:15 <lambdabot> dcoutts is in #haskell-hac07, #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 2h 47m 25s ago.
14:33:20 <omniscientIdiot> @vera bitd
14:33:22 <lambdabot> No match for "bitd".
14:33:25 <oerjan> the Golden Age, i presume :)
14:33:26 <dmwit> Back in the day.
14:33:32 <omniscientIdiot> back in the day
14:33:39 <monochrom> length . filter cnd = foldl' (\n x -> if cnd x then n+1 else n) 0
14:34:50 <omniscientIdiot> how does manual fusion work?  foldr f x . foldr g y = ?
14:34:59 <oerjan> omniscientIdiot: the Haskell 98 report defines much "hard-wired" syntax as sugar for something else
14:35:29 <monochrom> @free foldr
14:35:31 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
14:36:10 <b_jonas> monochrom: yes, that looks good. thanks.
14:36:30 <sjanssen> @ask dcoutts is it possible to use the new pkg-config stuff for conditional dependencies?  For example, I want to compile some code only if the xinerama package is available
14:36:30 <lambdabot> Consider it noted.
14:37:02 <monochrom> Unfortunately it only fuses foldr and map.
14:37:11 <omniscientIdiot> oerjan: I checked the report, you're right.  I guess I remembered seeing filter and map and stuff defined in terms of list comps in some Prelude (I think Hugs') and got confused.
14:38:05 <omniscientIdiot> "List comprehensions satisfy these identities, which may be used as a translation into the kernel", note the 'may', so it could or could not, depending on implementation.
14:38:45 <oerjan> omniscientIdiot: although i was also wrong, since filter was not mentioned
14:39:48 <monochrom> Oh! That free theorem is the fusion law for foldr. To use it to fuse two foldr's, let g be the other foldr, and keep working.
14:40:40 <omniscientIdiot> what's $map?
14:40:57 <mauke> a predefined map
14:42:03 <omniscientIdiot> so, it's like saying *specifically* Prelude.map instead of whichever map is in scope?
14:42:06 <monochrom> Pretend it's fmap.
14:42:13 <dolio> @free map
14:42:15 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
14:42:22 <monochrom> hehehehe
14:42:31 <dolio> It's so you can keep that straight.
14:42:46 <mauke> omniscientIdiot: if it was map, it would be a variable (and implicitly forall'd)
14:42:57 <monochrom> There are many ways to see it. I take it that $map is the mathematical function and map is the program code function.
14:42:57 <dolio> @free map :: ([a] -> [b]) -> [[a]] -> [[b]]
14:42:57 <lambdabot> $map g . h = k . $map f => $map ($map g) . map h = map k . $map ($map f)
14:43:24 <dolio> If it just called it 'map' that wouldn't make sense.
14:43:53 <dolio> Because you can give the name 'map' an arbitrary type via your input.
14:44:15 <monochrom> I need to practice my Bird-fu.
14:46:21 <psnively> A little Bird told me that was pointless. :-D
14:46:33 <beelsebob> monochrom: not your bird-flu?
14:46:43 <psnively> Heh
14:46:47 <monochrom> hahaha
14:53:08 <ChWr> Hi! Does anyone mind if I ask a newbie question?
14:53:18 <dons> please ask!
14:53:25 <ChWr> Thanks!
14:53:26 <dons> we encourage and welcome all newbies :)
14:53:27 <mdmkolbe> ChWr: #haskell is very friendly
14:53:41 <ChWr> I'd heard that, but this is my first firsthand experience. ;)
14:53:43 <dolio> Everybody asks to ask. :)
14:53:50 <mdmkolbe> ChWr: but in general don't ask to ask
14:53:59 <Botje> or we'll axe you!
14:54:27 <ChWr> I won't next time; I preferred to err on the side of verbosely polite at first.
14:54:31 <ChWr> heh @ Botje
14:54:40 <psnively> I'm a newbie too, and it's true: the room loves questions. The room hates meta-questions. :-D
14:54:40 <ChWr> So, the actual question:
14:55:20 <psnively> (So I've started writing my meta-questions in Template Haskell...)
14:55:21 <ChWr> I'm reading through "The Craft of Functional Programming", and everything was going swimmingly until I hit this definition:
14:55:27 <b_jonas> I've made a recursive function that calls itself back either zero or two or three times
14:55:43 <ChWr> curry :: ((a,b) -> c) -> (a -> b -> c)
14:55:48 <ChWr> curry g x y = g (x,y)
14:56:04 <ChWr> I understand what this is supposed to do and why on an intuitive level, but not why it is valid syntax
14:56:15 <mauke_> which part is invalid?
14:56:25 <monochrom> the type says it takes a function and returns another function
14:56:45 <omniscientIdiot> f x = y   is the same as   f = (\x -> y)
14:56:46 <beelsebob> the bracketing of the type signature is slightly confusing
14:56:57 <omniscientIdiot> (modulo MMR, :/)
14:56:58 <monochrom> so it's ok to have lots of ->'s nested in deep levels
14:57:00 <beelsebob> remember that -> is right associative
14:57:01 <sorear> nah, the bracketing is ENLIGHTENING!
14:57:02 <sorear> :)
14:57:08 <Botje> ChWr: g is of type ((a,b) -> c)
14:57:14 <beelsebob> so it's actually curry :: ((a,b) -> c) -> a -> b -> c
14:57:19 <mauke_> you think that's enlightening? try flip id!
14:57:27 <b_jonas> I agree with sorear
14:57:45 <Cale> curry :: ((a,b) -> c) -> (a -> (b -> c))
14:57:56 <beelsebob> sorear: the bracketing is enlightening to someone trying to understand what it does, but confusing to someone who is trying to understand the syntax
14:58:01 * mdmkolbe has seen sterio answers in #haskell before, but I think we just got surround sound answers
14:58:08 <beelsebob> lol
14:58:09 <sorear> syntax /= static semantics
14:58:19 <beelsebob> sorear: agree
14:58:25 <monochrom> "That's just semantics"
14:58:40 <b_jonas> beelsebob: hmm. I agree with that too
15:00:34 <dmwit> :t flip id -- time to check my hand-calculated type
15:00:37 <lambdabot> forall b c. b -> (b -> c) -> c
15:01:09 <oerjan> :t uncurry (flip id)
15:01:12 <lambdabot> forall a c. (a, a -> c) -> c
15:01:17 <xerox> :t app
15:01:19 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
15:01:20 <b_jonas> for flip id, you just have to know that id is equivalent to $
15:03:11 <monochrom> I hope you accept UTF-8.  ->  is valid type syntax provided  and  both are. So just let  be (a,b)->c,  be a->(b->c).
15:03:50 <ChWr> omniscientIdiot, beelsebob, monochrom: That was incredibly helpful; I now understand the syntax in two different ways. Thanks!
15:03:58 <beelsebob> ChWr: no probs :)
15:04:13 <Taejo> monochrom, I am the  and the 
15:04:29 <beelsebob> does ghc accept UTF-8 yet?
15:04:38 <xerox> beelsebob: yup
15:04:44 <b_jonas> are the List and Maybe modules made to import unqualified?
15:04:49 <beelsebob> so I can define types with greek letters?
15:04:54 <monochrom> That's blasphemy, Taejo!
15:05:09 <xerox> I'm not sure about types beelsebob but it worked for identifiers while ago when I tried.
15:05:15 <mdmkolbe> xerox: for strings or for veriable names as well?
15:05:16 <monochrom> No, I'm using Greek letters as placeholders, as meta-variables you might say.
15:05:20 <beelsebob> xerox: win :)
15:05:27 <Taejo> monochrom, your typesystem is blasphemous
15:05:33 <beelsebob> monochrom: I know you are... but I want to define types with greek letters
15:05:42 <b_jonas> xerox: actually the manual said it accepts only 8859-1
15:06:20 <b_jonas> which implies it will accept some utf8 but not most
15:06:35 <xerox> I think the SNOWMAN operator worked.
15:06:44 <b_jonas> and a quite hactic subset of utf8
15:07:00 <monochrom> I want to write foldr ()  (x:xs) = x  foldr ()  xs  too
15:07:01 <xerox> ...or were them the HEART ones.
15:07:23 <b_jonas> lol
15:07:56 <xerox> monochrom: it works.
15:08:04 <b_jonas> could you answer my module question though?
15:08:07 * monochrom is happy
15:08:12 * xerox too (:
15:08:16 <oerjan> b_jonas: List certainly is meant to be unqualified.
15:08:58 <monochrom> () x y = x
15:09:05 <oerjan> my impression is most of those that are qualified are so because they collide with List...
15:09:13 <b_jonas> Maybe seems like that too
15:09:31 <b_jonas> it has only few functions and all have "maybe", "just", or "nothing" in their lowercased names
15:10:02 <oerjan> List is original from H98
15:11:41 <b_jonas> what? there's no xor for booleans?
15:11:41 <oerjan> i don't think there were any collisions in that
15:11:50 <xerox> b_jonas: /=
15:11:52 <monochrom> > True /= False
15:11:57 <b_jonas> oh, I see
15:11:58 <mauke> b_jonas: it's called /=
15:12:00 <lambdabot>  True
15:12:24 <b_jonas> and imp is called <= then, I guess
15:12:33 <monochrom> Yes.
15:12:55 <xerox> > liftM2 (/=) [False ..] [False ..]
15:12:57 <lambdabot>  [False,True,True,False]
15:13:09 <xerox> > liftM2 (<=) [False ..] [False ..]
15:13:10 <oerjan> @instances-importing Data.Bits Bits
15:13:10 <lambdabot>  [True,True,False,True]
15:13:10 <mdmkolbe> :t min
15:13:12 <lambdabot> Int, Integer
15:13:12 <lambdabot> forall a. (Ord a) => a -> a -> a
15:13:22 <mdmkolbe> :t min True False
15:13:24 <lambdabot> Bool
15:13:27 <mdmkolbe> > min True False
15:13:28 <lambdabot>  False
15:13:51 <mauke> wait, min = (&&)?
15:13:55 <monochrom> Yes.
15:14:02 <monochrom> Lattice theory!
15:14:06 <ukl> good night.
15:14:22 <oerjan> > join (liftM2 (&&)) [False ..]
15:14:23 <lambdabot>  [False,False,False,True]
15:14:34 <b_jonas> that's the trick J uses as well so it only has to define 4 (or even just 2) binary operators for booleans to actually have 14
15:14:43 <xerox> > ap ((==) . join (liftM2 min)) (join (liftM2 (&&)) [False ..]
15:14:44 <lambdabot>  Unbalanced parenthesis
15:14:50 <xerox> doh :)
15:14:51 <ddarius> @check \x y -> max (x :: Bool) y == (x || y)
15:14:52 <lambdabot>  OK, passed 500 tests.
15:15:14 <mauke> 500? that's overkill
15:15:19 <ddarius> @scheck \x y -> max (x :: Bool) y == (x || y)
15:15:20 <lambdabot>   Completed 4 test(s) without failure.
15:15:23 <xerox> that's clearer :)
15:15:54 <b_jonas> @info /\
15:15:54 <lambdabot> (/\)
15:16:02 <b_jonas> @type /\
15:16:04 <lambdabot> parse error on input `/\'
15:16:11 <b_jonas> @type (/\)
15:16:13 <lambdabot> Not in scope: `/\'
15:16:22 <beelsebob> @hoogle (/\)
15:16:23 <lambdabot> Did you mean: (/\)
15:16:23 <lambdabot> Prelude.undefined :: a
15:16:23 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:16:42 <oerjan> :t (&&)
15:16:43 <lambdabot> Bool -> Bool -> Bool
15:17:04 <xerox> ?scheck \x y -> (min x (max x y) == x) && (max x (min x y) == (x :: Bool))
15:17:06 <b_jonas> I don't like /\ and \/ because some use it to mean a vedge/vee, and some as a foreach/exists
15:17:06 <lambdabot>   Completed 4 test(s) without failure.
15:18:04 <ddarius> It's extremely rare (in my experience) for those to be used as universal/existential quantifiers.
15:18:30 <b_jonas> ddarius: it's probably done by those that use a big vedge in non-ascii context for that
15:18:43 <b_jonas> the way you use other big operators like the big union
15:19:05 <b_jonas> I should've said big cup
15:19:20 <b_jonas> so yes, it's rare
15:19:28 <b_jonas> I still don't like the ascii symbol much
15:19:46 <monochrom> I like /\ i.e.  precisely because finitary conjunction and infinitary forall are related.
15:19:48 <lament> \/ /\ \/ /\ \/ /\ \/ /\ \/ /\ \/ /\ \/ /\
15:20:14 <lament> monochrom: that's rather far-fetched
15:20:15 <b_jonas> though when some informatician handed me in maths homework with two vertical bars instead of or at one place accidentally, I was a bit shocked
15:20:26 <b_jonas> lament: it isn't actually
15:20:44 <b_jonas> lattice theorists consider lattices with infinite vee and vedge operations
15:21:19 <monochrom> Only a few laws for finitary conjunction breaks for infinitary forall. Most laws carry over fine, including de Morgan.
15:21:41 <xerox> ?scheck \x y -> (max x y == False) && (min x y == True) ==> not x == y
15:21:43 <lambdabot>   Completed 4 test(s) without failure.  But 4 did not meet ==> condition.
15:21:46 <Taejo> you know what I love about Haskell? UML doesn't apply
15:22:07 <lament> Taejo: you'll like BASIC too!
15:22:36 <Taejo> lament, ok, that isn't the real reason I love Haskell, but it is one reason I don't like CS 2
15:23:08 <lament> Taejo: if your curriculum is anything like mine, there's plenty of reasons to not like CS 2.
15:23:09 <sorear> UML is considered CS now?
15:23:19 <FMota> :/ unfortunately
15:23:25 <lament> sorear: the first two CS courses at my uni were all UML.
15:23:27 <FMota> I'm starting to 'get' Ada
15:23:29 <monochrom> "CS" is a large umbrella.
15:23:32 * sorear gasps in horror, curls up, and plays dead
15:23:34 <Taejo> sorear, I don't think there's a single thing in my undergrad CS course that I would call CS
15:23:40 <FMota> but our teacher is pushing for us to learn more UML
15:24:02 <sorear> meh, UML should be relegated to vocational schools
15:24:12 <monochrom> Pretend that CS expands to Computer Software.
15:24:13 <yaarg> UML is SE.
15:24:30 <Taejo> I have a project due monday, where 40% of the mark is for the code, and 60% is for the schedule, for the minutes of the meetings we had with our supervisor, for the UML
15:24:30 <sorear> save uni for stuff like curry-howard and church-turing
15:24:43 <FMota> oh, today I invented a diagram notation for functional programming.
15:24:48 <Taejo> of course, I'm going to Freiburg, and I want a weekend, so I have to do it now
15:24:48 <FMota> ...so watch out!
15:24:48 <lament> we have this discussion every day or so, and yet the university curriculum doesn't change at all :)
15:24:50 <FMota> :o
15:24:55 <Taejo> lol
15:25:14 <sjanssen> I think it's reasonable for a CS program to have some software engineering curriculum
15:25:14 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
15:25:16 <b_jonas> my problem with using vedge and vee for 'and' and 'or' that mathematicians use it both as a low precedence 'and' and 'or' and a high precedence operation on other lattices
15:25:17 <monochrom> By 2050, only a few PhDs know boolean algebra.
15:25:21 <Taejo> FMota, Haskell is a very good notation for functional programming
15:25:26 <sjanssen> "all UML" really frightens me, though
15:25:38 <b_jonas> but this kind of precedence confusion is common in other parts of maths notation as well
15:25:52 <FMota> Taejo: I'm not talking about notation. I'm talking about graphs. :/
15:26:02 <ddarius> @google FAD functional design
15:26:02 <FMota>  / diagrams
15:26:04 <lambdabot> http://www.cs.kent.ac.uk/pubs/2001/1152/
15:26:04 <lambdabot> Title: Computer Science: Publication: FAD: A Functional Analysis and Design Methodology
15:26:21 <sorear> b_jonas: mathematicians in general are very sloppy with notation...
15:26:26 <b_jonas> yeah
15:26:28 <b_jonas> very true
15:26:28 <yaarg> thankfully i only encountered uml in a few projects and managed to outsource the laboursome task.
15:26:36 <ddarius> @where+ fad http://www.cs.kent.ac.uk/pubs/2001/1152/
15:26:36 <lambdabot> Done.
15:26:40 <b_jonas> and they use bad notation inherited from history as well
15:26:41 <yaarg> group projects, i mean.
15:26:44 <Cale> sorear: sloppy compared to what?
15:26:51 <ddarius> Cale: Us!
15:26:52 <Cale> sorear: Machine readable notations?
15:26:57 <b_jonas> the second implies part of the first
15:27:24 <sorear> yes (although "readable" is a bit vague)
15:27:46 <Taejo> yaarg, unfortunately the other member of my group is... the identity: he does nothing
15:27:50 <monochrom> Cale: Sloppy compared to the notation my supervisor has designed! http://www.enformatika.org/ijms/v1/v1-1-2.pdf
15:28:02 <beelsebob> 404ed!
15:28:09 <Taejo> actually not, but too much group theory on my mind
15:28:14 <monochrom> err excuse, I'll find a better url
15:28:30 <Cale> I don't actually think most mathematicians are very sloppy with notation at all.
15:28:39 <monochrom> http://www.cs.toronto.edu/~hehner/BAUA.pdf is an alternative that works.
15:28:47 <Cale> It's just that they're not writing for stupid machines
15:29:06 <lament> that's the beauty of not doing programming
15:29:06 <monochrom> They're writing for stupid humans. :)
15:29:34 * ddarius agrees with Cale, but doesn't say anything.
15:30:04 * ddarius still has an SPJ talk to see and there might be new Catsters talks!
15:30:09 <Cale> Which would often by comparison require much more verbose notation -- notation which wouldn't serve to clarify things further for a reasonable human.
15:30:12 <yaarg> or they were trying to formulate some nice notation only to be thwarted by latex...
15:31:10 <Cale> yaarg: It's actually pretty surprising what some people get away with in LaTeX.
15:31:26 * ddarius still wonders how to put a variable over a congruence symbol.
15:31:35 <yaarg> I do all my math notation in ASciiMath these days.
15:31:38 <yaarg> Cale: sure
15:32:48 <yaarg> which is rather nice, moanings about javascript aside.
15:32:59 <yaarg> looks good printed.
15:33:04 <Tac-Tics> I only realized recently that Javascript is a nice langauge
15:33:19 <Tac-Tics> and it was only pathetic ass browser implementation that makes it suck
15:33:44 <yaarg> one might conjecture you went insane recently
15:33:50 <Tac-Tics> hehe
15:33:58 <yaarg> :-)
15:34:02 <Tac-Tics> It's better than PHP =-P
15:34:14 * yaarg yawns
15:34:18 <yaarg> yes, agreed.
15:34:42 <lament> Tac-Tics: javascript is getting a lot nicer thanks to all the ajax buzz
15:34:51 <lament> better libraries, etc
15:34:56 <Tac-Tics> yes, I've been doing a lot of ajax lately in my job
15:35:15 <Tac-Tics> I taught my C++ friend about closures
15:35:24 <Tac-Tics> and I wrote our Ajax library to use them
15:35:30 <Tac-Tics> re*wrote
15:35:51 <Tac-Tics> It was exciting X-D
15:35:57 <Tac-Tics> moreso than I make it sound
15:36:34 <b_jonas> ddarius: try \stackrel{relation sign}{math over it}
15:37:40 <b_jonas> I hate how bad typography (with latex) many maths articles and books manage to have
15:37:43 <Cale> ddarius: \stackrel{a}{\equiv}
15:37:53 <Cale> oh, heh
15:37:56 <Cale> too late :)
15:38:12 <b_jonas> they're flipped though
15:38:13 <tcr> I feel so stupid not to understand how flip id works... I mean flip takes a function which takes two args itself, but id is a function that only takes one arg... I must be missing something obvious.
15:38:16 <b_jonas> so only one of us are right
15:38:32 <mauke> tcr: every function takes exactly one argument
15:38:34 <ddarius> javascript seems like a beautiful place from afffaaaarrr / until one day, I saw how miserable things really arrrreeee
15:38:36 <Cale> b_jonas: It's typically better than the typography of those articles and books which don't use LaTeX.
15:38:45 <b_jonas> and indeed, Cale is right in the order
15:38:56 <b_jonas> Cale: only for new ones
15:39:00 <Cale> Like Microsoft Word math.
15:39:10 <Botje> tcr: write out the types, then remove the parens
15:39:11 <b_jonas> the old books that were typed by hand are much better
15:39:19 <Tac-Tics> @type flip id
15:39:22 <lambdabot> forall b c. b -> (b -> c) -> c
15:39:23 <monochrom> tcr: think of id :: (a->b) -> (a->b), a special case of the usual x->x
15:39:35 <Cale> b_jonas: Typeset by hand, you mean?
15:39:37 <Tac-Tics> @src flip
15:39:37 <lambdabot> flip f x y = f y x
15:39:50 <Tac-Tics> > flip id 1 (+1)
15:39:51 <lambdabot>  2
15:39:54 <Cale> b_jonas: Because I have seen books which were typed on a typewriter by hand, and it's hideous :)
15:39:55 <b_jonas> yes, or at least typeset with a machine not a computer
15:40:07 <sorear> b_jonas: i've seen some of those books... 500 pages of typewriter output is not fun unless it's REALLY interesting
15:40:08 <b_jonas> oh yeah, the typewriter ones aren't really good either
15:40:12 <tcr> monochrom: Ah, of course! Thanks.
15:40:12 <Tac-Tics> flip id puts the function call 2nd and the argument first... kinda
15:40:16 <oerjan> > id id id (+) 2 2
15:40:17 <lambdabot>  4
15:40:23 <Tac-Tics> > flip id [1,2,3,4,5] reverse
15:40:24 <lambdabot>  [5,4,3,2,1]
15:40:35 <b_jonas> actually, the typewriter ones depend on whether it's made by mathematicians or engineers
15:40:42 <monochrom> @free id
15:40:44 <lambdabot> f . id = id . f
15:40:45 <sorear> Tac-Tics: ... all computers are machines
15:40:51 <b_jonas> the engineers tend to write formulas by hand and can write them well
15:40:55 <mauke> @pl \x -> ($ x)
15:40:56 <lambdabot> flip id
15:41:12 <b_jonas> while the ones typewritered by mathematicians are much worse
15:41:23 <Cale> sorear: Tell that to Stephen Wolfram.
15:41:25 <Tac-Tics> sorear: are they?
15:41:26 <b_jonas> sorear: true, but sometimes it's the best thing you've got
15:41:46 <monochrom> Engineers went through a "drawing" class in which they were trained to handwrite and handdraw with mechanical consistency.
15:41:52 <b_jonas> monochrom: yep
15:41:56 <lament> i've a book that has a diagram of a tree drawn in ASCII
15:41:56 <b_jonas> it's not surprising
15:41:58 <lament> with / and \
15:42:17 <sorear> dead tree? :o
15:42:18 <lament> and the ends of / in consecutive lines don't really match up
15:42:26 <lament> (the font isn't even fixed-width)
15:42:32 <lament> the book is written by a linguist...
15:42:56 <b_jonas> lament: oh yeah, that's one reasone why 8x16 character cells pwn 8x14 ones btw
15:43:20 <Cale> Now there's the subject for a flamewar
15:43:37 <b_jonas> that's not the best reason of course
15:43:48 <b_jonas> the more important reason is line spacing
15:43:54 <Tac-Tics> Your 2 cent titanium task goes too far!
15:44:04 <b_jonas> anyway, good night now
15:44:08 <Tac-Tics> Your 2 cent titanium tax* doesn't go too far enough
15:46:07 <Cale> Heh, this combinatorics book is awesome: Show that the number of {0,1} matrices with column sum 2, m nonempty rows, l of which are distinct, and n columns, k of which are distinct, is: (sum over t = 0 to k of (k;t) t^n (-1)^(k-t)) m! (-1)^l sum over i,j >= 0 of ((i;2);k-j) (j;l+j-m) (-1)^(i+j) 2^-j / (i! j! (m-i-2j)!)
15:46:44 <Bokoros> http://tubeimage.com/viewer.php?file=x7o3ydsiwmvc6pnvqyd3.jpg
15:46:45 <lambdabot> Title: Tube Image .com | Free Image Hosting | Photo Sharing | Upload | Picture Gallery
15:46:55 <JohnnyL> what i mean to say is: Can I make an HTTP/HTTPS client that can make macros for online payments (say to frys.com)?
15:47:05 <Saizan> Cale: for which definition of awesome?:)
15:47:08 <xerox> Cale: that's a big formula :)
15:47:26 <Botje> JohnnyL: you probably can!
15:47:32 <phobes> Cale:  Which book is that?
15:47:36 * sorear is suspicious of people who show up out of numbers and immediatly post links
15:47:44 <oerjan> @faq Can I make an HTTP/HTTPS client that can make macros for online payments (say to frys.com)?
15:47:44 <lambdabot> The answer is: Yes! Haskell can do that.
15:47:49 <Cale> "Combinatorial Enumeration" by Jackson and Goulden
15:47:53 <JohnnyL> oerjan, i don't even know if that link works.
15:48:41 <phobes> At least it's not "{0,1} matrices with column sum 2" by Jackson and Goulden
15:48:58 <phobes> problem #89
15:49:17 <oerjan> @users
15:49:17 <lambdabot> Maximum users seen in #haskell: 420, currently: 384 (91.4%), active: 26 (6.8%)
15:49:23 <Cale> phobes: It's actually a great book
15:49:35 <Saizan> do we have an HTTPS library?
15:49:37 * ddarius needs to us $$ more.
15:49:42 <Botje> we have curl
15:50:24 <oerjan> :t ($$)
15:50:26 <lambdabot> Doc -> Doc -> Doc
15:50:42 <Cale> phobes: Also, the problem is probably not as hard as it looks
15:51:05 <phobes> Cale:  Ya, I can imagine it just being a problem of "apply these 4 concepts at once"
15:51:11 <Cale> yeah
15:51:48 <lament> Show that 1 added to 2 added to 3 is 1+2+3.
15:51:53 <Cale> and by that point you already have some rather nice bijective decompositions for binary matrices of various types
15:55:35 <Bokoros> http://tubeimage.com/index.php?do_random=true
15:55:36 <lambdabot> Title: Tube Image .com | Free Image Hosting | Photo Sharing | Upload | Picture Gallery
15:55:58 <Cale> Bokoros: what's up?
15:56:05 <sorear> Cale: what's with Bokoros?
15:56:06 <sorear> oh
15:56:11 <Cale> Bokoros: You realise this is #haskell?
15:56:20 --- mode: ChanServ set +o Cale
15:56:32 <Bokoros> funny picture wont kill
15:56:48 <lament> unless it's really funny
15:57:04 <sorear> We just think you smell like a good-for-nothing spammer, that's all
15:57:18 <thoughtpolice> 6.8 is the STABLE now?
15:57:31 <Bokoros> http://tubeimage.com/viewer.php?file=x7o3ydsiwmvc6pnvqyd3.jpg
15:57:31 <Bokoros> this is funny
15:57:32 <lambdabot> Title: Tube Image .com | Free Image Hosting | Photo Sharing | Upload | Picture Gallery
15:57:34 <Cale> If you were talking about Haskell, then it might be acceptable.
15:57:51 <lament> let me guess, bokoros is the owner of tubeimage.com.
15:58:02 <Igloo> Cale: Please ban him to save me the effort  :-)
15:58:03 <Botje> Bokoros: hilarious. now stop spamming it.
15:58:23 --- mode: Cale set +b *!*@*.dyn.optonline.net
15:58:26 <Botje> well, repeating
15:58:27 <phobes> Bokoros:  What's haskell?
15:58:31 <Cale> hmm, might be a little general there :)
15:58:42 --- mode: Cale set -b *!*@*.dyn.optonline.net
15:58:45 <lament> yeah, who needs optonline!
15:58:50 --- mode: Cale set +b *!*@ool-45761a5c.dyn.optonline.net
15:59:03 <Cale> That'll do.
15:59:15 --- mode: Cale set -o Cale
15:59:38 <JohnnyL> why did you want to ban me?
16:00:04 <Cale> JohnnyL: hehe, I didn't -- I set the wrong ban type
16:00:26 <TSC> cs
16:00:30 <TSC> oops
16:00:45 <sorear> same principle as a few months ago when it was unilaterally decided that all Turks were spammers?
16:01:22 <lament> whenever i want to connect to a russian or an israeli IRC server, i usually can't.
16:01:30 <lament> They have all of canada banned due to clonebots.
16:01:46 <sorear> what are clonebots?
16:01:47 <Cale> I have some rather large ip ranges in my hosts.deny now.
16:02:27 <phobes> How many people have ops on this channel?
16:02:34 <Cale> phobes: lots
16:02:35 <JohnnyL> oh ok.
16:02:35 <JohnnyL> hehe
16:02:56 <lament> sorear: hundreds of bots joining the channel and flooding it.
16:03:13 <sorear> phobes: /msg chanserv access #haskell list
16:03:40 <sorear> people would do something like that?
16:03:41 <sorear> :P
16:03:53 <lament> no, never.
16:03:54 <lament> hence "bots"
16:04:30 <lament> remember, guns don't kill people, impacting bullets rupturing internal organs kill people :)
16:04:43 <sorear> I'm assuming the bots are wielded by deranged men
16:04:59 <koala_man> lament: what if they're pistol whipped really hard?
16:05:56 <sorear> or if you get shot in the foot and centrifuged?
16:06:17 <lament> oh god
16:06:25 <lament> that can't be pleasant.
16:07:07 <idnar> lament: and probably when a person in Russia or Israel wants to connect to a server in the US or wherever, they're banned due to clonebots :P
16:07:19 <idnar> it's a rather sad state of affairs
16:07:33 <lament> plenty of russians and israelis on freenode
16:07:44 <idnar> yeah, I was thinking of other networks
16:07:51 <lament> although freenode is just too cool in general
16:14:31 <ddarius> Thanks, by the way, Cale and b_jonas.
16:19:18 <tehgeekmeister> ?src fix
16:19:19 <lambdabot> fix f = let x = f x in x
16:20:53 <Taejo> @pf fix f = let x = f x in x
16:20:54 <lambdabot> Maybe you meant: bf pl
16:21:00 <Taejo> @pl fix f = let x = f x in x
16:21:00 <lambdabot> fix = fix id
16:21:46 <idnar> heh
16:22:12 <kpreid> @type fix id
16:22:14 <lambdabot> forall a. a
16:22:41 <idnar> @type fix
16:22:43 <lambdabot> forall a. (a -> a) -> a
16:22:56 * idnar scratches his head
16:23:25 <idnar> @pl foo f = let x = f x in x
16:23:25 <lambdabot> foo = fix
16:23:59 <kpreid> idnar: any questions?
16:24:21 <Cale> > fix (1:)
16:24:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:24:24 <Taejo> isn't the fixed point of id, id ?
16:24:28 <idnar> I'm trying to figure out how it gets "fix = fix id"
16:24:37 <mauke> any value is a fixed point of id
16:24:57 <Cale> But id has least fixed point _|_, because id _|_ = _|_
16:25:22 <JohnnyL> what does haskell have that java already doesn't?
16:25:30 <Taejo> so fix = fix id means fix = _|_ ?
16:25:31 <beelsebob> readable code
16:25:34 <Cale> JohnnyL: A decent type system
16:25:42 <liyang2> STM
16:25:45 <beelsebob> JohnMeacham_: consiceness
16:25:57 <mauke> JohnnyL: sum types
16:26:01 <allbery_b> idnar: I think the problem there is that fix is a builtin for @pl and it doesn't realize that you're already using the name
16:26:04 <Cale> Nonstrict-semantics
16:26:11 <Taejo> allbery_b, indeed
16:26:20 <liyang> the support of MS Research.
16:26:25 <Cale> Referential transparency
16:26:30 <Taejo> let fix = id
16:26:34 <kpreid> JohnnyL: type inference
16:26:36 <mauke> type classes
16:26:38 <Taejo> @pl foo f = let x = f x in x
16:26:38 <lambdabot> foo = fix
16:26:43 <omniscientIdiot> which allows equational reasoning
16:26:44 <allbery_b> a useful, helpful IRC channel :)
16:26:46 <Taejo> @let fix = id
16:26:50 <lambdabot> Defined.
16:26:50 <allbery_b> lambdabot :)
16:26:52 <Taejo> @pl foo f = let x = f x in x
16:26:52 <lambdabot> foo = fix
16:27:09 <liyang> A Turing-complete type system.
16:27:16 <Taejo> damn you, lambdabot, and your lack of pythonic silliness
16:27:17 <Cale> Pure parallelism annotations
16:27:20 <kpreid> JohnnyL: type inference, type classes, purity, and more broadly useful syntax
16:27:30 <Cale> Oh, yeah, typeclasses are another good one
16:27:46 <Cale> and inference -- Java really badly needs that
16:27:59 <liyang> Did lambda expressions make it into 1.6?
16:28:07 <Cale> If you want to see what Java would look like if designed properly, look at Scala :)
16:28:12 <liyang> Or am I thinking of C# 3.0?
16:28:31 <Pseudonym> Modula-3, I suspect.
16:28:38 * SimonRC goes to bed
16:28:56 <liyang> or for a less convoluted verversion, try http://nice.sf.net/ (disclaimer: never used it.)
16:28:58 <Pseudonym> Modula-3 is Java as it would have been designed in the early 90s had it been designed properly then.
16:29:24 <liyang> What does Java have that Haskell doesn't?
16:29:34 <JohnnyL> why can't you make haskell on top of the JVM?
16:29:35 <platypus> Sideffects.
16:29:36 <idnar> lots of users
16:29:37 <Pseudonym> Beauty.
16:29:43 <Pseudonym> Erm.
16:29:47 <Pseudonym> No, ugliness.
16:29:54 <liyang> (Broad runtime library.)
16:29:55 <Pseudonym> Sorry, caffeine hasn't kicked in yet.
16:30:04 <Pseudonym> Buzzword compliance.
16:30:18 <Pseudonym> Portable, secure bytecode.
16:30:26 <dbueno> Is there a way to probe the infixity of a function in ghci?  :<magic> (.) => ...?
16:30:35 <Cale> Shelves and shelves of poorly written books about it?
16:30:52 <omniscientIdiot> dbueno:  :info (.)
16:30:52 <Saizan> dbueno: :i
16:30:53 <liyang> Cale: oh yes. The horrors.
16:31:01 <liyang> Dominance of mainstream bookshops.
16:31:07 <liyang> s/mainstream//
16:31:36 <dbueno> Saizan, omniscientIdiot: Thanks.
16:32:14 <sorear> Portable, secure bytecode is a red herring
16:32:16 <Pseudonym> I think the portable secure bytecode thing is still Java's main selling point.  Even C# isn't quite there yet.
16:32:20 <liyang> Web browser plugin.
16:32:30 <Pseudonym> sorear: Actually, I disagree with that.  That was Java's main selling point.
16:32:36 <Pseudonym> As I previously noted.
16:32:38 <sorear> Haskell has source code, when is just as inscrutible to the vast majority of computer users
16:32:45 <Pseudonym> People don't use it for that, admittedly.
16:32:50 <Heffalump> compilation is a real pain
16:33:06 <Heffalump> and many people don't want to give away their source
16:33:14 <tehgeekmeister> ?src flip
16:33:14 <lambdabot> flip f x y = f y x
16:35:18 <FMota> ?src ap
16:35:18 <lambdabot> ap = liftM2 id
16:35:23 <FMota> :o
16:35:45 <omniscientIdiot> equivalently, liftM2 ($)
16:36:21 <dbueno> Can one not use `infixl' in ghci?  Prelude> infixl 9 # ---> parse error on input `infixl'
16:36:30 <sorear> dbueno: right
16:36:33 <liyang> JohnnyL: Haskell can't run efficiently on top of the JVM, because the JVM is very much tuned towards the Java execution model.
16:36:49 <omniscientIdiot> dbueno: use 'let' to introduce definitions.
16:37:04 <dbueno> omniscientIdiot: Ooh, thanks.
16:37:08 <Cale> dbueno: You can stick it inside the let where you define #, but I'm not sure if it works properly or not.
16:37:12 <sorear> JohnnyL: In particular, it's neigh-impossible to implement tail calls using the JVM machinery
16:37:23 <dbueno> For some reason I used let to define # but not for the infixity.
16:37:29 <sorear> even though it's trivial on all real hardware
16:37:56 <liyang> JohnnyL: On an unrelated note, people have done Haskell to Javascript compilers though. (IIRC.)
16:38:02 <omniscientIdiot> dbueno: make sure you put the def and infix decl on the same ghci line, seperated by ';'
16:38:29 <nxt> @pl (\x y z -> x + y + z)
16:38:29 <lambdabot> ((+) .) . (+)
16:38:33 <dbueno> omniscientIdiot: Oh, thanks. I'll do that.  Can I import in ghci?
16:38:38 <JohnnyL> liyang, yes , the turing machine.. a beautiful thing.
16:38:59 <omniscientIdiot> dbueno:  there's :m +Module
16:39:20 <dbueno> Ah.
16:39:22 <Cale> Yeah, it appears that it simply ignores infix decls.
16:39:25 <Cale> (ghci does)
16:39:26 <liyang> JohnnyL: no, dear god not the Turing machine. It's as powerful as a Turing machine. :)
16:39:44 <Cale> Basically, just put the damn things in a file :)
16:39:51 <omniscientIdiot> Cale: oh, how unfortunate.
16:40:10 <dibblego> what are some good beginner exercises to highlight the use of partial application?
16:40:15 <Pseudonym> Ugh, disagree.  TMs are uiglier than lambda calculus.
16:40:54 <sorear> MRM!
16:41:03 <Pseudonym> Von Neumann automata!
16:41:07 <LoganCapaldo> Pseudonym: they're both ugly-complete
16:41:09 * liyang could not think of a worse model of computation than a TM. I mean, what *was* he thinking? It's served its purpose. Stop teaching it in CS classes.
16:41:29 <liyang> (Well okay I'm exaggerating. I could easily think of a worse model of computation than a TM.)
16:41:33 <Pseudonym> liyang: Quite.
16:41:40 <dbueno> Cale: Yeah, I was just trying a few things out, but I'll do it from emacs in the future. =]
16:41:42 <newsham> liyang: prefer RAM's?
16:41:42 <sorear> liyang: it's what you get when you have a professional cyclist design your mathematical models
16:41:43 <Taejo> liyang, brainf***
16:41:47 <Pseudonym> But it's an obvious generalisation of DFAs and PDAs.
16:41:53 <Taejo> newsham, I prefer RAMs
16:42:01 <Pseudonym> It has much value in that respect.
16:42:05 <newsham> RAMs easy to relate to, but much more proof cases
16:42:23 <Pseudonym> TMs are the 3SAT of automata.
16:42:27 * sorear likes 2-stack automata better than TMs.  TMs are just too physical
16:42:32 <liyang> (Yes thank you everyone for the suggestions.)
16:42:51 <Pseudonym> sorear: Yeah, 2-stack automata I like, because they have a regular expression syntax.
16:42:54 <newsham> when your TM runs out, flip the tape
16:43:06 <xerox> Isn't sed a 2-state automata?
16:43:28 <JohnnyL> liyang:http://www.superdeluxe.com/sd/contentDetail.do?id=D81F2344BF5AC7BBB4886672AF480441672BD00C61EE8BC9
16:43:29 <Cale> TM's have one advantage -- they're like fancy versions of DFAs/PDAs
16:43:31 <lambdabot> Title: Super Deluxe - Ken Swizzle's Time Machine, http://tinyurl.com/349zyv
16:43:32 <Pseudonym> sed supports regular expressions, so there's at least finite automata in there.
16:43:36 <allbery_b> only if you don't use its more complex tricks
16:43:48 <Pseudonym> Cale: But like sorear said, 2-stack automata are less fancy/
16:44:02 <Pseudonym> And they're Turing-complete.
16:44:05 <lament> sed supports regexes and loops, which is already enough for TC, plus it's TC in more obviouss ways as well.
16:44:42 <reffie> TC?
16:44:49 <reffie> oh
16:44:55 <reffie> wait, sed is turing complete?!
16:44:56 <LoganCapaldo> Tender Care
16:45:06 <xerox> reffie: yeah it is
16:45:18 <reffie> please show me addition in sed
16:45:20 <Pseudonym> The thing I was most impressed with, though, was sendmail.
16:45:24 <LoganCapaldo> wasn't there a forth written a sed?
16:45:26 <newsham> xerox: do you mean while : sed < in > .out && mv .out out; done  is TC?
16:45:37 <newsham> while : ; do
16:45:39 <LoganCapaldo> s/a/in/
16:45:42 <Pseudonym> That's really diabolical programming.
16:45:50 <lament> reffie: http://aurelio.net/sed/sokoban/
16:45:51 <lambdabot> Title: Index of /sed/sokoban
16:45:56 <reffie> thanks
16:46:17 <lament> that's not addition as such, but i'm sure there's addition there somewhere.
16:46:21 <reffie> that is fucking crazy
16:46:25 <kscaldef> reffie: s/(.*) (.*)/$1$2/
16:46:33 <kscaldef> for some definition of "addition"
16:46:52 <Taejo> kscaldef, two-symbol TMs do addition the same way
16:46:58 <kscaldef> indeed
16:47:18 <liyang> JohnnyL: maybe I'm spoilt by British television but that was pretty awful. :(
16:47:31 <JohnnyL> the tm stands for time mahine.
16:47:39 <liyang> Still, I wouldn't want to change anything.
16:47:46 <Igloo> echo "SSSZ SSSSZ" | sed ":l; s/S\([^ ]*\) /\1 S/; t l; s/Z //"    is add in sed, in a non-cheaty way
16:47:52 <liyang> TMs served a useful purpose.
16:48:00 <sorear> seriously, sed has loops
16:48:12 <idnar> perhaps the most scary part of that is that the code is actually relatively legible
16:48:20 * JohnnyL lovesss it
16:48:38 <dbueno> Does Haskell have any operator that does reverse application?  e.g. x $> f = f x
16:48:44 * JohnnyL has that sick 12 year old type humour.
16:48:49 <dbueno> I noticed it has reverse composition (Control.Arrow.(>>>))
16:48:51 <liyang> Here's a whole collection of games in sed: http://sed.sourceforge.net/#gamez
16:48:52 <lambdabot> Title: sed.sf.net - The SED $HOME
16:49:20 <kscaldef> @hoogle a -> (a -> b) -> b
16:49:24 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
16:49:24 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
16:49:24 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
16:49:37 <omniscientIdiot> @hoogle+
16:49:37 <lambdabot> Control.Parallel.Strategies.($||) :: (a -> b) -> Strategy a -> a -> b
16:49:37 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
16:49:37 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
16:49:51 <kscaldef> hmm... none of those seem right
16:49:52 <lament> reffie: not really.
16:50:01 <reffie> no?
16:50:01 <idnar> @pl flip ($)
16:50:01 <lambdabot> flip id
16:50:03 <lament> reffie: many systems much less complex than sed are turing complete.
16:50:06 <xerox> aha, I was remembering right, it's a two-state machine.
16:50:16 <dbueno> kscaldef: Yeah, I did that too....
16:50:21 <dbueno> idnar: Oh, right. Duh.  Thanks.
16:50:28 <omniscientIdiot> I don't think there's a name for it in the libs
16:50:33 <ddarius> Pseudonym: What is the programming model of sendmail?
16:50:41 <LoganCapaldo> SOA
16:50:43 <LoganCapaldo> :-p
16:50:52 <newsham> ddarius: rewrite rules
16:51:08 <idnar> so yeah, I guess define your own
16:51:09 <dbueno> Reverse composition seems more readable to me since I read english, but it's a little awkward without reverse composition.
16:51:15 <Pseudonym> ddarius: Yeah.
16:51:20 <idnar> just need to give it the right precedence
16:51:22 <ddarius> :t (>>>)
16:51:22 <Pseudonym> http://pfaff.newton.cam.ac.uk/jhnc/hanoi-cf.html
16:51:28 <lambdabot> Title: Towers of Hanoi in sendmail.cf
16:51:28 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
16:51:33 <newsham> http://okmij.org/ftp/Computation/sendmail-as-turing-machine.txt
16:52:06 <liyang> :t (>>>) :: (b -> c) -> (c -> d) -> (b -> d)
16:52:08 <xerox> look whose url is it :)
16:52:08 <lambdabot> (b -> c) -> (c -> d) -> (b -> d) :: forall b c d. (b -> c) -> (c -> d) -> b -> d
16:52:25 <ddarius> Pseudonym: What's so diabolical about it?
16:52:32 <dbueno> idnar: Same precedence as $, no?
16:52:41 <idnar> dbueno: I would expect so
16:52:44 <idnar> @info ($)
16:52:44 <lambdabot> (($))
16:53:01 <idnar> infixr 0 $> or somesuch
16:53:13 <omniscientIdiot>  @info --(spellcheck)--> @undo
16:53:48 <idnar> @type flip ($)
16:53:50 <lambdabot> forall a b. a -> (a -> b) -> b
16:54:03 <Pseudonym> ddarius: Try writing something serious.
16:54:13 <Pseudonym> It's not as bad as TECO, admittedly.
16:55:35 <dbueno> idnar: It works out. Neat.
16:55:43 <idnar> dbueno: :)
16:58:45 <liyang> This isn't ideal, but is it good enough?
16:58:48 <liyang> > ($ 1) $ (+2) >>> (*3)
16:58:50 <lambdabot>  9
16:59:21 <liyang> (right <--- left.)
17:00:37 <newsham> http://www.thenewsh.com/%7Enewsham/x/postfix.hs
17:02:00 <liyang> > ($ 1) $ ($ 2) $ (+)
17:02:02 <lambdabot>  3
17:02:08 <liyang> Almost looks like Perl.
17:02:17 <liyang> (but not as terse.)
17:02:57 <liyang> Oh bugger. Nevermind. Above example is wrong.
17:03:57 <drtomc> Pseudonym: but saying something isn't as bad as TECO is like saying that  something isn't as bad as having your arm sawn off with a bread and butter knife.
17:04:06 <liyang> > ($ 4) >>> ($ 2) $ div -- this works
17:04:08 <lambdabot>  2
17:04:39 <Pseudonym> Well, true.
17:09:26 <JohnnyL> is: tail             :: [a] -> [a]
17:09:26 <JohnnyL> >	tail (_:xs)       = xs         ....magical or does haskell have to search from begining to end to get tail?
17:09:51 <bos> @seen dons
17:09:51 <lambdabot> dons is in #haskell-hac07, #xmonad and #haskell. I last heard dons speak 1m 53s ago.
17:10:12 <liyang> JohnnyL: maybe you're thinking of last. :)
17:10:18 <mauke> JohnnyL: no magic, no searching
17:10:39 <liyang> tail gives the second element onwards.
17:11:02 <hpaste>  bos pasted "strict line count thingy" at http://hpaste.org/2975
17:11:21 <liyang> And yes, last would have to traverse the whole list to get the last element.
17:11:26 <bos> dons: remember the lazy bytestring code i blogged? above is a chunked strict bytestring version
17:11:30 <liyang> (There are better data structures for that sort of thing.)
17:11:51 <JohnnyL> liyang. ok, maybe last? is last 'magic'?
17:12:00 <JohnnyL> oh ok
17:12:02 <JohnnyL> gotcha
17:12:09 <JohnnyL> just as in lisp
17:12:12 <liyang> Nope. It really walks over (almost) the entire list.
17:12:27 <mauke> tail is cdr
17:12:29 <liyang> (Er, strike that (almost).)
17:12:33 <idnar> :t ($ 4) >>> ($ 2)
17:12:41 <lambdabot> forall a a1 b. (Num a, Num a1) => (a -> a1 -> b) -> b
17:12:57 <idnar> :t ($ 4)
17:12:58 <lambdabot> forall a b. (Num a) => (a -> b) -> b
17:13:04 <drtomc> If you want an efficient "last" operation, have a look at Data.Sequence
17:13:08 <tehgeekmeister> anyone have a simple example of a function (aside from id) which fix does something aside from overflowing the stack with?
17:13:20 <bos> dons: it seems to have a space leak somewhere, but damn if i can find it
17:13:25 <liyang> idnar: I hope this isn't going into any sort of production code. :-/
17:13:27 <tehgeekmeister> (actually, it does that with id, too, doesn't it?)
17:13:35 <bos> tehgeekmeister: yeah, people write loops with fix all the time
17:13:59 <tehgeekmeister> bos: so that's what the flip fix 0 $ \findOffsets offset -> ... bit is doing?
17:14:05 <tehgeekmeister> in your post?
17:14:06 <bos> tehgeekmeister: right
17:14:14 <idnar> liyang: I'm so far from having any production Haskell code at all, that it's not even in my light cone ;)
17:14:18 <tehgeekmeister> thot so, just trying to make sure.
17:14:30 <idnar> liyang: just trying to wrap my head around the mechanics of that code
17:14:36 <liyang> idnar: okay. My conscience is clear for the time being then.
17:14:44 <idnar> for academic reasons, as it were, not practical ones
17:14:55 <liyang> :)
17:15:16 * yaarg waves at liyang and heads to bed :-)
17:15:25 <idnar> > fix (1:)
17:15:26 <lambdabot> Terminated
17:15:41 <Pseudonym> ? fix (\fac x -> if x == 0 then 1 else x * fac (x-1))
17:15:46 <Pseudonym> > fix (\fac x -> if x == 0 then 1 else x * fac (x-1))
17:15:47 <lambdabot> Terminated
17:15:50 <Pseudonym> > fix (\fac x -> if x == 0 then 1 else x * fac (x-1)) 3
17:15:50 <lambdabot> Terminated
17:15:54 <Pseudonym> Hmm.
17:15:59 <idnar> > fix ((1:) . scanl (+) 1)
17:16:00 <lambdabot> Terminated
17:16:10 <idnar> doh
17:16:19 <xerox> ?undef
17:16:20 <Pseudonym> > 3
17:16:23 <idnar> oh
17:16:23 <lambdabot> Undefined.
17:16:24 <lambdabot>  3
17:16:25 <drtomc> I can do it too:
17:16:29 <drtomc> Terminated
17:16:35 <liyang> yaarg: wassup. (Why am I bothering seeing as you've already disappeared? :-/)
17:16:35 <idnar> someone messed with fix earlier
17:16:44 <xerox> Somebody was tampering fix
17:16:45 <lambdabot> From now on, I shall answer everyone with just "Terminated".
17:16:54 <idnar> > fix ((1:) . scanl (+) 1)
17:16:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:17:00 <lambdabot> Terminated
17:17:01 <idnar> there we go :)
17:17:04 <lambdabot> Terminated
17:17:14 <mauke> @vixen terminated?
17:17:14 <lambdabot> isn't it obvious?
17:17:16 <lambdabot> Terminated
17:17:22 <Pseudonym> > fix (\fac x -> if x == 0 then 1 else x * fac (x-1)) 3
17:17:24 <lambdabot>  6
17:17:26 <idnar> lambdabot: I bet you think you're a really funny guy
17:17:29 <dbueno> idnar ... that is cool.
17:17:35 <xerox> > fix (\_ x -> x) 0
17:17:37 <lambdabot>  0
17:17:43 <kawfee> xerox hi
17:17:46 <lambdabot> Someone thinks I'm a guy.
17:17:56 <lambdabot> Oh, and... Terminated
17:18:11 <idnar> lambdabot: I meant it in the gender-neutral sense, of course
17:18:13 <xerox> hello kawfee
17:18:21 <kawfee> lambdabot I thought you were a bot.
17:18:25 <lambdabot> idnar: Terminated
17:18:35 <idnar> kawfee: more like a sock puppet, I guess ;)
17:18:37 <lambdabot> All right, I'll stop now.
17:18:52 <lament> @kill Bush
17:18:52 <lambdabot> Maybe you meant: keal kind tell
17:19:01 <Pseudonym> @keal Bush
17:19:02 <lambdabot> what are epsilons?
17:19:02 <kawfee> lambdabot are you real?
17:19:12 <lament> @keal
17:19:13 <lambdabot> ghc need to have plugin that allow copy paste in xp
17:19:16 <xerox> kawfee: do we know each other?
17:19:18 <lambdabot> Now that's a strange question.
17:19:24 <kawfee> I'll vote for Bush again if given the chance.
17:19:27 <kawfee> xerox dunno
17:19:35 <kawfee> xerox I have some of your products
17:19:40 <lambdabot> I'm an IRC bot, not a philosopher.
17:20:03 <kawfee> lambdabot What do you think about Kant?
17:20:08 <liyang> idnar: hey! You're that Dosage guy!
17:20:17 <lambdabot> A real pissant who was very rarely stable.
17:20:40 <bos> hmm, perhaps not a space leak, perhaps it's just miserably inefficient for unknown and magical reasons
17:20:43 <idnar> liyang: oh wow, I'm famous ;)
17:20:56 <kawfee> I guess lambdabot is posessed?
17:20:58 * liyang used to use Dosage when he had time to read webcomics. :(
17:21:17 <lament> kawfee: don't vote Bush, vote Putin
17:21:23 <kawfee> I love Bush!
17:21:32 <idnar> liyang: heh, I know the feeling
17:21:39 * liyang hopes that Good Bush as opposed to Bad Bush.
17:21:45 <liyang> *that's
17:21:54 <lament> Bush is like cholesterol?
17:21:59 <kawfee> Well, I don't like bush between her legs but that is another subject.
17:22:03 <Pseudonym> In Australia, "bush" is a synonym for "wilderness".
17:23:13 <lament> australian is a very odd language
17:23:20 <Pseudonym> It's a bonza lingo.
17:23:47 <lament> it's rapidly losing mutual intelligibility with english
17:27:46 <dbueno> Is there a ghci setting to limit the length of printed lists by using an ellipsis? (the way lambdabot does if it tries to print an infinite list.)
17:28:39 <sorear> dbueno: lambdabot doesn't
17:28:52 <sorear> > 2^1024
17:28:56 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:29:01 <sorear> > [1..]
17:29:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:29:08 <sorear> > fix show
17:29:10 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:29:27 <sorear> notice that they are the same length *in characters*
17:29:31 <liyang> dbueno: I'd just use take. :-/
17:29:36 <sorear> the truncation is independant of listiness
17:29:41 <dbueno> I see ellipses.
17:29:47 <dbueno> Oh, I see what you mean.
17:30:16 <dbueno> liyang: Yeah, that's what I do.  Hmm.
17:30:51 <liyang> Well, showsPrec has an extra useless parameter (in many instances) which you could (ab)use.
17:31:31 <liyang> (If you're into that sort of perversion.)
17:31:57 <LoganCapaldo> just build yerself alocal lambdabot
17:32:08 <LoganCapaldo> if you really want it
17:32:16 <LoganCapaldo> plus then you get even more cool features
17:32:41 <dbueno> Like backtalk?
17:32:58 <LoganCapaldo> _configurable_ backtalk
17:33:19 <dbueno> I think it's great that it makes fun of you for crashing it.
17:35:09 <Sgeo> Bye all
17:35:53 <dbueno> What other ways can you piss lambdabot off?
17:44:32 <LoganCapaldo> @src foo
17:44:33 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:54:34 <JohnnyL> isn't stack allocation much more resrouce intensive than looping against a hardset value based limit?
17:55:56 <liyang> What on earth is a harset value-based limit? @.@
17:56:47 <liyang> (And stack allocation? What stack allocation?)
17:57:04 <JohnnyL> LOOP: if c < 1 then goto LOOP:
17:57:24 <JohnnyL> stack allocation as in selectEven :: [Int] -> [Int]
17:57:24 <JohnnyL> >	selectEven xs = [ x | x<-xs , isEven x ]
17:57:49 <JohnnyL> bad example
17:58:06 <JohnnyL> how about: >	concat (x:xs) = x ++ concat xs
17:58:31 <mauke> where does that touch the stack?
17:58:35 <JohnnyL> the LOOP example is hardset value.
17:59:06 <JohnnyL> mauke at the moment concat calls itself and bumps the memory reference on the stack.
17:59:14 <sjanssen> JohnnyL: GHC allocates very little on the stack
17:59:16 <mauke> er, no
17:59:37 <sjanssen> pretty much just function call records and arguments to functions
17:59:50 <sjanssen> pointers to arguments, that is
17:59:59 <mauke> concat doesn't call itself
18:00:50 <JohnnyL> oh?
18:01:02 <liyang> JohnnyL: regarding the earlier comment on why Haskell would run badly on the JVM -- it's a fundamentally different execution model from a stack machine, on which the JVM is designed.
18:01:05 <JohnnyL> how does recursion under haskell 98 go?
18:01:38 <JohnnyL> liyang, oh that clears up a few things.
18:01:51 <mauke> I don't think h98 specifies implementation details
18:01:57 <sorear> it doesn't
18:02:08 <sjanssen> JohnnyL: concat (x:xs) creates a thunk for "concat xs", we'll call it 't'.  It then calls "x ++ t"
18:02:15 <sjanssen> in GHC's execution model
18:02:34 <cameron> JohnnyL: so that at any given time, you'll only have one thunk hanging around, the one for the "next" call to concat
18:02:39 <sjanssen> the thunk is allocated on the heap
18:03:03 <sorear> JohnnyL: concat(ARG1) = Eval ARG1; Case ARG1 of { [] -> Return [] ; (x:xs) -> Allocate V1 as (concat/1 xs); Tail call ++/2 x V1 }
18:03:13 <sorear> in pseudo-STG
18:03:55 <sorear> so concat only calls itself if its argument is [[], ..]
18:04:08 <sorear> even then, it's a stackless tail call
18:04:25 <JohnnyL> oh ok
18:04:26 <JohnnyL> cool
18:06:03 <JohnnyL> thanks for clearing that up.
18:06:23 <JohnnyL> As I go over haskell code.. i'm really only noticing syntactic sugar. however nice it is.
18:14:43 <Syzygy-> By the way.
18:14:54 <Syzygy-> This crowd might be interested in knowing about this:
18:15:21 <Syzygy-> http://www.ams.org/amsmtgs/2109_program_ss39.html#title
18:15:22 <lambdabot> Title: Joint Mathematics Meetings, Program by Special Session
18:15:33 <Syzygy-> (scroll down to the second to last talk)
18:18:29 <liyang> (Someone should send a message to Taiwan and the rest of the Orient that names like William (somewhat less so) but especially Ernest are no longer in fashion.)
18:19:16 <Syzygy-> Wilieam not in fashion?
18:19:18 <liyang> (A student of a friend from when I was teaching in China last semester called himself Adolf. No, really. It's not even funny.)
18:19:23 <Syzygy-> Heh
18:19:28 <Syzygy-> I find Ernest really neat.
18:21:01 <liyang> A building in my old school was named after an Ernest. (Walton.) Maybe it's just me but that name is so 1900s.
18:21:31 <sjanssen> people today are probably more likely to name their child Earnest
18:21:43 <Syzygy-> sjanssen: Deliberate spelling?
18:21:48 <sjanssen> Syzygy-: yes
18:21:53 <Syzygy-> :)
18:22:00 * sjanssen is not a fan of words-for-names
18:22:01 * liyang gets it. And he feels depressed for it.
18:22:04 <Syzygy-> Well... What I really wanted to point to was my own talk on that workshop.
18:22:18 <liyang> Sorry.
18:22:33 <Syzygy-> Which does have some relevance for this channel...
18:23:46 <liyang> I *am* reading the abstract, if that'll restore my karma. :-/
18:24:00 <Syzygy-> liyang++
18:24:03 <Syzygy-> Have a karma boost.
18:24:03 <lament> I'm not sure why taiwanese naming fashion should be the same as the western one.
18:24:08 <lament> fashion is a local thing.
18:24:49 <liyang> Well this is the thing. That's not their real names. They make up English names because it's the `fashionable' thing to do.
18:27:05 * liyang better hide from the channel lest he'll still be here when the sun rises.
18:44:12 <pastorn> anyone i talked haskell memory with the other day alive?
18:45:02 <pastorn> or anyone who knows something about haskell memory management
18:48:06 <sjanssen> pastorn: what about Haskell memory management?
18:48:21 <pastorn> let's say you do this:
18:48:43 <pastorn> l <- getLine; let r = reverse l
18:48:59 <pastorn> and maybe putStrLn r ++ l
18:49:26 <sjanssen> putStrLn (r ++ l) -- I'm sure
18:49:32 <pastorn> each list element is a value and a pointer to the next, right?
18:49:52 <pastorn> no, parentenses are T3H S1LLAYz
18:49:54 <sjanssen> a cons cell is represented as a pointer to the head and a pointer to the tail
18:50:13 <pastorn> whoa... both ways?
18:50:21 <pastorn> why would that be needed?
18:50:30 <sjanssen> plus a tag at the beginning declaring whether it's a [] or (:)
18:50:57 <sjanssen> pastorn: because the size of the head isn't statically known
18:51:10 <dino-> > putStrLn "foo" ++ "bar"
18:51:11 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO ()'
18:51:17 <dino-> > putStrLn $ "foo" ++ "bar"
18:51:19 <lambdabot>  <IO ()>
18:51:19 <sjanssen> pastorn: also, because the head might be a thunk
18:51:24 <pastorn> wait.. so in actuallity a list is
18:51:49 <pastorn> : (head) (tail)
18:52:35 <sjanssen> roughly, data [a] = [] | (:) a [a]
18:52:57 <pastorn> where : contains size of the head and the positions of head and tail
18:53:03 <sjanssen> no
18:53:20 <sjanssen> head and tail are both pointers, which have a fixed size
18:53:27 <tehgeekmeister> i've been trying for a few hours now to figure out this (flip fix 0 $ \findOffsets offset -> do ...) bit from bos' recent post, and while i get that it's looping somehow, i'm not really sure why this works at all.
18:53:44 <LoganCapaldo> struct list { void* head; struct list* tail; }; :p
18:54:13 <omniscientIdiot> flip fix x (\f y -> ...) = fix (\f y -> ...) x, to start with
18:54:14 <sjanssen> struct list { int tag; void* head; struct list* tail; };
18:54:21 <pastorn> sjanssen: ok, so just pointers to the values then?
18:54:28 <LoganCapaldo> sjanssen: you don't need a tag
18:54:31 <sjanssen> pastorn: right
18:54:35 <LoganCapaldo> [] can be NULL
18:54:51 <sjanssen> LoganCapaldo: in C, yes.  GHC doesn't do it this way ;)
18:54:52 * pastorn forgot about recursion for like twenty seconds there
18:54:55 <omniscientIdiot> @src fix
18:54:55 <lambdabot> fix f = let x = f x in x
18:55:03 <pastorn> *recursive types*
18:55:14 <sjanssen> exactly
18:55:16 <LoganCapaldo> sjanssen: sure. I was just trying a different language to see if maybe he could get it like that :)
18:55:53 <tehgeekmeister> omniscientIdiot: yep, i've tried substituting in the source, and i just don't see how any arguments ever make it into that lambda.
18:56:16 <sjanssen> @type flip fix
18:56:18 <lambdabot> forall b c. b -> ((b -> c) -> b -> c) -> c
18:56:43 <pastorn> WAAAH!!! my head explodes by looking at fix
18:57:00 <tehgeekmeister> pastorn: yours too?  i'm glad i'm not alone.
18:57:01 <LoganCapaldo> tehgeekmeister: fix (\f y -> ...) x is like (\f y -> ...) (\f y -> ...) x so y is x in the body of the first function
18:57:04 <pastorn> ok, so it's 4 am and i need to get up in four hours, but still
18:57:38 <pastorn> tehgeekmeister: wanna do a paste-learning-thread?
18:57:41 <pastorn> .paste
18:58:03 <tehgeekmeister> pastorn: if i knew what that meant, i'd be better suited to decide.
18:58:03 <pastorn> lambdabot: FINE, i'll do it myself!!
18:58:18 <LoganCapaldo> !paste
18:58:18 <hpaste> Haskell paste bin: http://hpaste.org/
18:58:25 <dibblego> ?kind []
18:58:27 <lambdabot> * -> *
18:58:27 <LoganCapaldo> don't blame lambdabot
18:58:36 <LoganCapaldo> it''s not her job
18:58:41 <LoganCapaldo> @paste
18:58:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:58:46 <LoganCapaldo> but she does it anyway
18:59:11 <dolio> "I don't know any langauge, aside from XSLT, that supports XML at the syntax level like VB intends to." I do. :)
18:59:12 <LoganCapaldo> She works hard for the money, so hard for it honey, she works hard for the money so you'd better treat her right
18:59:13 <jbauman> i doubt that this will work but...
18:59:18 <jbauman> @djinn b -> ((b -> c) -> b -> c) -> c
18:59:19 <lambdabot> -- f cannot be realized.
18:59:20 <dino-> Is there a difference in the symbols I see people use to communicate with lambdabot? I mean the @ > ? !
18:59:21 <tehgeekmeister> LoganCapaldo: this confuses me a lot, from the definition of fix, i'd expect it to recurse endlessly
18:59:33 <pastorn> http://hpaste.org/2976
18:59:35 <LoganCapaldo> tehgeekmeister: Haskell is lazy
18:59:39 <jbauman> the beauty of lazy evaluation
18:59:55 <LoganCapaldo> s/lazy/non-strict/
18:59:55 <pastorn> tehgeekmeister: just annote with comments and we'll get there eventually
18:59:59 <dolio>  @ and ? work the same. It's a matter of preference.
19:00:07 <dolio>  ! talks to hpaste, I think?
19:00:11 <dolio> !paste
19:00:11 <hpaste> Haskell paste bin: http://hpaste.org/
19:00:14 <LoganCapaldo> so if you don't "look at" f, it never gets evaluated
19:00:14 <omniscientIdiot>  > = @run
19:00:19 <omniscientIdiot> @run 1 + 1
19:00:24 <lambdabot>  2
19:00:35 <LoganCapaldo> so in the base case, y == 42 or whateer, you don't evaluate f
19:00:35 <dino-> I suppose it will tell me all this if I ask for help.
19:00:38 <LoganCapaldo> and you don't recurse
19:00:45 <monochrom> "fix f" is an infinite loop for some f, but works fine for others.
19:01:03 <LoganCapaldo> make sense?
19:01:07 <monochrom> E.g., "fix (\xs -> 1 : xs)" works like a charm.
19:01:33 <tehgeekmeister> yes!
19:01:37 <tehgeekmeister> so essentially
19:01:42 <monochrom> Note: if you define "os = fix (\xs -> 1 : xs)", that is the same as "os = 1 : os".  Clearly it has to work.
19:02:11 <pastorn> @type fix
19:02:13 <lambdabot> forall a. (a -> a) -> a
19:02:18 <tehgeekmeister> fix f ... applies a loop of applications of f to ..., until f short circuits?
19:02:22 <monochrom> OTOH "loop = 1 + loop" is going to be bad, and therefore "loop = fix (1 +)" is, too.
19:03:14 <omniscientIdiot> fix kinda "passes a function into itself"
19:03:22 <ddarius> infinity = fix (1 +) :: Nat
19:03:24 <monochrom> All questions about fix can be answered by knowing recursion.  Are all recursive definitions infinite loops? No.
19:03:51 <tehgeekmeister> monochrom: yes, but ones like that look infinite when you're not used to thinking in terms of laziness.
19:04:21 <mauke> you can define fix in strict languages
19:04:38 <LoganCapaldo> you just can't use the same definition
19:04:38 <ddarius> A slightly less general fix
19:04:42 <mauke> sub fix { my $f = shift; sub { $f->(fix($f), @_) } }
19:04:49 <mauke> yeah, it only works for functions
19:05:03 <hpaste>  pastorn annotated "(no title)" with "AMIRITE?" at http://hpaste.org/2976#a2
19:05:05 <monochrom> I agree. My point is that "fix" is no harder than recursion to understand.
19:05:46 * omniscientIdiot once worked through the Y combinator in javascript.  Hurts the head, but it was educational. :)
19:05:54 <monochrom> "os = 1 : os" is also a no-no in SML.
19:06:10 <mauke> it works in OCaml
19:06:42 <monochrom> Yes, OCaml adds a special rule that essentially says "switch to lazy under this condition..."
19:06:47 <ddarius> mauke: What about fibs = 1:1:zipWith (+) fibs (tail fibs) ?
19:06:55 <mauke> let rec a = 0 :: b and b = 1 :: a in ...
19:07:08 <mauke> ddarius: no, that's an infinite list :-)
19:07:14 <omniscientIdiot> > fix (\fibs -> 1:1:zipWith (+) fibs (tail fibs))
19:07:16 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:07:20 <pastorn> tehgeekmeister: how does that look?
19:07:51 * dons found vegemite in usa. vegemite pig out crazy time!
19:08:06 <tehgeekmeister> pastorn: updated.
19:08:39 <pastorn> tehgeekmeister: you missed a spot
19:08:47 <pastorn> or rather; lots of them :p
19:09:04 <tehgeekmeister> pastorn: i did?
19:09:07 <pastorn> @src (.)
19:09:07 <lambdabot> (.) f g x = f (g x)
19:09:17 <LoganCapaldo> > fix (0 *) -- numbers should be less strict <g>
19:09:18 <lambdabot>  Exception: <<loop>>
19:09:35 <pastorn> tehgeekmeister: (1+) . (1+) . (1+) . (1+)...
19:09:44 <LoganCapaldo> pastorn: no
19:10:02 <monochrom> Which one should be less strict, fix (0 *) or fix (* 0) ?
19:10:03 <tehgeekmeister> > (+1) (+1) (+1)
19:10:04 <lambdabot>   add an instance declaration for (Num (a -> a))
19:10:11 <tehgeekmeister> bah!
19:10:15 <bos> dons: did you see my blatherings in scrollback?
19:10:15 <ddarius> monochrom: Clearly we should support por
19:10:24 <tehgeekmeister> pastorn: you're probably right.  you still get it, tho.
19:10:27 <monochrom> heh
19:10:40 <pastorn> tehgeekmeister: don't fool yourself
19:10:44 <tehgeekmeister> > (+1) (+1) (+1) 0
19:10:45 <lambdabot>   add an instance declaration for (Num (a -> a))
19:10:48 <hpaste>  omniscientIdiot annotated "(no title)" with "substitute" at http://hpaste.org/2976#a4
19:11:00 <pastorn> i just saw that we had f(f(f(f....
19:11:12 <pastorn> and that is the same as f . f . f . f...
19:11:47 <ddarius> It's (+1) ((+1) ((+1) ...
19:11:49 <dons> bos, looking
19:11:51 <tehgeekmeister> right, that's what i was getting at.  that's what fix does, until one of the calls returns a definite value.  so monochrom is right, it's basic recursion.
19:11:53 <pastorn> > (+1) . (+1) . (+1) $ 0
19:11:55 <lambdabot>  3
19:12:06 <pastorn> @src $
19:12:06 <lambdabot> f $ x = f x
19:12:18 <Boney> @src fix
19:12:19 <lambdabot> fix f = let x = f x in x
19:12:20 <bos> dons: trying the chunked strict bytestring trick didn't work out so well; it's half the speed of plain lazy
19:12:21 <tehgeekmeister> monochrom: not that i doubted, i just had to figure out how.
19:12:35 <dons> bos, sounds suspicious
19:12:43 <monochrom> alright, no problem. :)
19:12:50 <bos> dons: yeah, but i can't find the problem, assuming there is one
19:13:11 <dons> oh, those appends seem a bit bad
19:13:26 <dons> they'll copy on strict ones, but be a cons on lazy ones
19:14:22 <bos> yes
19:14:23 <dons> bos, i'm leaving in the morning for ICFP, btw. Haskell Workshop on Sunday, then ICFP, CUFP and the hackathon. i'll blog as we go
19:14:36 <bos> woot!
19:15:01 <Nafai> Awesome!
19:15:02 * tehgeekmeister gets back to reading bos' post again now that he understands fix
19:15:13 <bos> dons: some kind of appending seems necessary though
19:15:15 <dons> oh, i should take my camera too
19:15:31 * bos puts kids to bed - back soon
19:15:38 <pastorn> dons: how many are attending the hackathon?
19:17:51 <Boney> dons: What's the URL of your blog,
19:18:06 * Boney will vocarasly live through others that attend ICFP.
19:18:06 <mudge> hey is there an easy way to read a single character from user input without echoing it  with GHCI?
19:18:21 <mudge> getChar  without echoing it
19:18:21 <dons> pastorn: 30 or so for the hackathon
19:18:27 <dons> double the january one
19:18:41 <dons> getChar >> return ()
19:18:47 <hpaste>  banbh pasted "FFI idioms" at http://hpaste.org/2977
19:18:48 <dons> or turn of echoing
19:19:31 <banbh> i have an FFI question.  Is there a more idiomatic way of doing the above "FFI idioms" post (on hpaste)?
19:19:33 <mudge> thanks dons
19:20:39 <Boney> > @google dons blog
19:20:39 <lambdabot>  Parse error
19:20:43 <Boney> ?.
19:20:43 <lambdabot> Not enough arguments to @.
19:20:54 <Boney> @url dons
19:20:54 <lambdabot> http://www.cse.unsw.edu.au/~dons
19:21:22 <ddarius> @help url
19:21:22 <lambdabot> url <key>. Return element associated with key
19:21:27 <ddarius> Interesting.
19:21:32 <ddarius> @url fad
19:21:32 <lambdabot> http://www.cs.kent.ac.uk/pubs/2001/1152/
19:21:39 <ddarius>  @where by another name
19:28:30 <tehgeekmeister> ?src ($)
19:28:30 <lambdabot> f $ x = f x
19:28:41 * tehgeekmeister thot so.
19:30:43 <mudge> @mudge
19:30:44 <lambdabot> Unknown command, try @list
19:30:56 <mudge> i want my name to be a command
19:31:00 <mudge> @url mudge
19:31:00 <lambdabot> I know nothing about mudge.
19:31:11 <mauke> @quote
19:31:11 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
19:31:11 <mudge> lambdabot how could you
19:31:11 <dons> dcoutts: how's the talk coming along?
19:31:49 <LoganCapaldo> @seen mudge
19:31:49 <lambdabot> mudge is in #haskell. I last heard mudge speak 38s ago.
19:31:54 <lambdabot> oh mudge baby! don't worry, we can still be friends
19:32:15 <LoganCapaldo> @tell mudge see she still pays attention
19:32:15 <lambdabot> Consider it noted.
19:32:36 <omniscientIdiot> @where+ mudge http://nickmudge.info/
19:32:36 <lambdabot> Done.
19:32:45 <dons> lots of fun stuff at the HW on sunday, http://www.cse.unsw.edu.au/~keller/haskellws/ProgramDraft.html
19:32:46 <lambdabot> Title: Haskell Workshop 2007 - List of Accepted Papers
19:32:46 <omniscientIdiot> there you go :)
19:34:15 <dolio> mudge: If you say enough dumb stuff you might get a command. :)
19:34:22 <dolio> mudge: Or write some top-40 hits.
19:34:37 <ddarius> And then kickbanned from #haskell
19:35:15 <LoganCapaldo> or if we need a way to summon you
19:35:18 <LoganCapaldo> @shapr
19:35:18 <lambdabot> why on earth would I slap
19:35:23 <LoganCapaldo> wait
19:35:30 <omniscientIdiot> it's @get-shapr
19:35:30 <ddarius> @get-shapr
19:35:30 <lambdabot> shapr!!
19:35:50 <omniscientIdiot> @seen shapr
19:35:50 <lambdabot> shapr is in #haskell-blah, ##logic, #scannedinavian and #haskell. I last heard shapr speak 4h 10m 55s ago.
19:36:18 <dolio> @b52s
19:36:18 <lambdabot> His ear lobe fell in the deep. Someone reached in and grabbed it. It was a rock lobster!
19:36:38 <LoganCapaldo> @b52s
19:36:38 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
19:36:43 <omniscientIdiot> @. elite . elite keal
19:36:43 <lambdabot> Wha+ +|-|3 H31| D0ES pre|uDe > /\/\E4n?
19:36:47 <LoganCapaldo> No love shack?
19:37:06 <LoganCapaldo> @fix elite keal
19:37:06 <lambdabot> Maybe you meant: faq ft id thx
19:37:20 <LoganCapaldo> @keal
19:37:20 <lambdabot> T seems to be haskell, except with a decent interface at this point
19:37:28 <LoganCapaldo> Augh
19:37:28 <omniscientIdiot> @faq Can you write web apps in Haskell?
19:37:29 <lambdabot> The answer is: Yes! Haskell can do that.
19:37:43 <LoganCapaldo> I really wish I had seen that
19:37:47 <LoganCapaldo> been ther efor it
19:37:57 <LoganCapaldo> however you want to phrase it
19:38:02 <dons> @faq Can Haskell help solve global warming?
19:38:02 <lambdabot> The answer is: Yes! Haskell can do that.
19:38:17 <dons> the bot never lies
19:38:22 <omniscientIdiot> @faq Will Haskell do my homework?
19:38:22 <lambdabot> The answer is: Yes! Haskell can do that.
19:38:26 <dons> ?vixen you wouldn't like, would you?
19:38:26 <lambdabot> yeah, i like
19:38:27 <ddarius> @faq Is Haskell the cause of global warming?
19:38:27 <lambdabot> The answer is: Yes! Haskell can do that.
19:38:33 <LoganCapaldo> I'm jealous of the old timers, not because of their vasty haskell knowledge but because they got to see keal perform live
19:38:40 <dons> hah
19:38:41 * ddarius never saw keal.
19:38:48 <omniscientIdiot>  /agree LoganCapaldo
19:38:50 <Syzygy-> @faq Can Haskell trigger the apocalypse?
19:38:51 <lambdabot> The answer is: Yes! Haskell can do that.
19:39:00 <dons> well, that's reasonable
19:39:01 <ddarius> Sweet!
19:39:08 <LoganCapaldo> @faq Can Haskell prevent the apocalypse?
19:39:08 <lambdabot> The answer is: Yes! Haskell can do that.
19:39:13 <omniscientIdiot> :O
19:39:24 <Syzygy-> dons: Now that I'm in Sydney, is there something you believe I should do? Or people I should make sure I meet?
19:39:42 <ddarius> Syzygy-: Make sure to meet the woman of your dreams.
19:39:55 <Syzygy-> ddarius: In Sydney?
19:39:55 <dons> hang out in newtown? eat lots of yummy thai and italian? hit the beach!
19:40:04 <dons> go see some 20-20 cricket
19:40:10 <LoganCapaldo> @faq Can Haskell find the woman of Syzygy-'s dreams in Sydney?
19:40:10 <lambdabot> The answer is: Yes! Haskell can do that.
19:40:13 <Syzygy-> ddarius: We decided a long time ago that she couldn't afford coming along.
19:40:17 <shapr> ddarius: You called?
19:40:19 <dons> have lunch at a pub. drink lots of coopers
19:40:29 <Syzygy-> dons: Check. Check. Check.
19:40:31 <ddarius> shapr: Not really.  I don't have your number.
19:40:34 <Syzygy-> Not yet. And Coopers?
19:40:45 <dons> great beer.
19:40:51 <LoganCapaldo> shapr we've just been using your name in vain
19:40:53 <shapr> ddarius: You want my number?
19:40:56 <dons> you'll get it at select pubs round the inner west
19:40:59 * Syzygy- is headed for Bondi tomorrow with a borrowed boogie board and someone hwo knows how to use them.
19:41:07 <Syzygy-> dons: Ah. Is it light?
19:41:13 <LoganCapaldo> ooooo, ddarius is gonna get some digits ;)
19:41:19 <dons> Syzygy-: you're at usyd right? you could head down to the Rose pub, in redfern, for pizza and beer.
19:41:19 <ddarius> shapr: Not at this juncture.
19:41:20 * Syzygy- almost only drinks ales and stouts...
19:41:22 <dons> nice pub.
19:41:23 <shapr> ddarius: Ah too bad
19:41:24 <Syzygy-> dons: Yup.
19:41:30 <Syzygy-> Sititng there right now.
19:41:31 <LoganCapaldo> Ok I've had enough, I'm going to bed
19:41:35 <LoganCapaldo> later
19:41:39 <ddarius> shapr: I did accidentally put Birmingham instead of Montgomery on my 29B.
19:41:42 <dons> yeah, all beer is light /draught in syd. too hot for stout
19:42:02 <dons> ?temp Syzygy-
19:42:03 <Syzygy-> dons: Not all. I have in fact found a whole bunch of ales and stouts here.
19:42:03 <lambdabot>   now 27.6, min 16.5, max 28.6, rain 0.0mm, wind 39km/h NNW
19:42:06 * ddarius could go for some (non-alchoholic) liquid right now.
19:42:17 <dons> Syzygy-: yeah, but there not had by the locals :)
19:42:24 <Syzygy-> What does the ?temp use?
19:42:30 <shapr> ddarius: 29B?
19:42:31 <dons> your body temp
19:42:35 <Syzygy-> oO
19:42:51 <omniscientIdiot> @help temp
19:42:51 <lambdabot> Local temperature
19:43:01 <Syzygy-> And how does it determine local?
19:43:21 <dons> let local = "Sydney"
19:43:22 * Syzygy- points out that he's chatting from a computer in Stockholm, accessing it over ssh...
19:43:32 <Syzygy-> ?temp dons
19:43:33 <lambdabot>   now 27.6, min 16.5, max 28.6, rain 0.0mm, wind 39km/h NNW
19:43:40 <Syzygy-> ?temp Somewhere else
19:43:40 <lambdabot>   now 27.6, min 16.5, max 28.6, rain 0.0mm, wind 39km/h NNW
19:43:42 <Syzygy-> Ah.
19:43:43 <omniscientIdiot> @temp Mars
19:43:44 <lambdabot>   now 27.6, min 16.5, max 28.6, rain 0.0mm, wind 39km/h NNW
19:43:44 <dons> referentially transparent!
19:44:12 <omniscientIdiot> Mars seems pleasant this time of year
19:44:42 <omniscientIdiot> @go 27.6 C in F
19:44:43 <lambdabot> 27.6 degrees Celsius = 81.68 degrees Fahrenheit
19:45:14 <omniscientIdiot> A little hotter than I'd like :)
19:45:29 <Syzygy-> omniscientIdiot: A lot hotter than I like.
19:45:39 <Syzygy-> Over 25 C I lose the will to work.
19:45:44 <tehgeekmeister> re this chunk again: flip fix 0 $ \findOffsets offset ->..., it seems, now, to me, that this will end up trying to apply 0 to the lambda on the right hand side, which obviously doesn't work.  what am i misreading?
19:45:44 <Syzygy-> Over 30 I shut down mentally.
19:46:11 <omniscientIdiot> tehgeekmeister: it applies 0 to the fixed lambda
19:46:24 <dons> Syzygy-: wait till it reaches 40 :)
19:46:33 <tehgeekmeister> omniscientIdiot: you can apply numbers?
19:46:38 <dons> @go 40 C in F
19:46:39 <lambdabot> 40 degrees Celsius = 104 degrees Fahrenheit
19:46:40 <tehgeekmeister> omniscientIdiot: that doesn't seem sensible.
19:46:40 <Syzygy-> dons: I'm fleeing end of october.
19:46:46 <omniscientIdiot> tehgeekmeister: it's passed in as offset
19:46:49 <dons> ah, you'll miss the best of it then
19:47:43 <omniscientIdiot> remember (fix (\findOffsets offset -> ... findOffsets ...)) is like findOffsets offset = ... findOffsets ...
19:47:45 <Syzygy-> The ... best?
19:47:50 <tehgeekmeister> @type 0 $ \x -> x + 1
19:47:52 <lambdabot> forall b. (Num ((Integer -> Integer) -> b)) => b
19:48:05 <sjanssen> @go 30 C in F
19:48:07 <lambdabot> 30 degrees Celsius = 86 degrees Fahrenheit
19:48:12 <sjanssen> that isn't bad at all
19:48:19 <tehgeekmeister> >0 $ \x -> x + 1
19:48:35 <tehgeekmeister> > 0 $ \x -> x + 1
19:48:35 <lambdabot>   add an instance declaration for (Num ((a -> a) -> b))
19:48:44 <tehgeekmeister> bah, typing woes.
19:49:04 <omniscientIdiot> > flip fix 4 $ (\f x -> if x > 0 then 2 * (f (x-1)) else x)
19:49:06 <lambdabot>  0
19:49:32 <omniscientIdiot> hehe, 2 * 2 * 2 * ... 0 = 0
19:50:52 <omniscientIdiot> the fix ties (\f -> ... f ...) together so that f is a recursive function
19:51:31 <mudge> how do you include other haskell files in your haskell files?
19:51:32 <lambdabot> mudge: You have 1 new message. '/msg lambdabot @messages' to read it.
19:51:34 <omniscientIdiot> so we get 'fix untiedFunction arg = tiedFunction arg'
19:51:34 <tehgeekmeister> wait, the way i read it
19:51:46 <mudge> @messages
19:51:46 <lambdabot> LoganCapaldo said 19m 31s ago: see she still pays attention
19:52:00 <omniscientIdiot> heh
19:52:15 <omniscientIdiot> mudge: use import to import other modules
19:52:20 <tehgeekmeister> flip fix 4 $ is the same as fix $ 4
19:52:34 <tehgeekmeister> so i was thinking it'd be fix $ 4 (\f...
19:52:41 <omniscientIdiot> tehgeekmeister: you're forgetting the function at the end
19:52:46 <mudge> ominisceintidiot:  I tried to,  my other files name is: haskell.lhs   so I tried    import haskell.lhs
19:52:58 <omniscientIdiot> (flip fix 4 $ \f -> ...) = fix (\f -> ...) 4
19:52:59 <mudge> @mail LoganCapaldo thanks
19:52:59 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:53:13 <omniscientIdiot> mudge: @tell
19:53:27 <mudge> @tell LoganCapaldo thanks
19:53:27 <lambdabot> Consider it noted.
19:53:39 <mudge> @tell lambdabot thanks
19:53:39 <lambdabot> Nice try ;)
19:54:10 <omniscientIdiot> mudge: You use the module name specified at the top of the file: "module Blah where ..." then in the other file "import Blah"
19:54:14 <lament> @thanks
19:54:15 <lambdabot> you are welcome
19:54:50 <tehgeekmeister> omniscientIdiot: what black magic causes that to happen?
19:55:03 <omniscientIdiot> mudge: http://www.haskell.org/onlinereport/modules.html#sect5
19:55:04 <lambdabot> Title: The Haskell 98 Report: Modules
19:55:18 <omniscientIdiot> tehgeekmeister: the def of flip
19:55:20 <omniscientIdiot> @src flip
19:55:21 <lambdabot> flip f x y = f y x
19:55:30 <Trixsey> (zipWith.zipWith)
19:55:32 <omniscientIdiot> flip fix 4 (...) = fix (...) 4
19:55:33 <Trixsey> could someone explain this to me?
19:55:38 <Trixsey> zipWith combines lists?
19:55:48 <mudge> omniscientIdiot: thanks dude, I'm checking it out
19:56:08 <omniscientIdiot> > zipWith (+) [1,6,1] [87,2,9]
19:56:19 <lambdabot>  [88,8,10]
19:56:33 <tehgeekmeister> so flip f x y = f y x, and flip fix x y = fix y x, and so flip fix 4 $ = fix $ 4, no?
19:56:40 <Trixsey> ahh
19:56:44 <omniscientIdiot> or zipWith (\x y -> x + y) ...
19:57:04 <omniscientIdiot> tehgeekmeister: substitute ($) first
19:57:19 <omniscientIdiot> flip fix 4 $ ... = flip fix 4 (...) = fix (...) 4
19:57:19 <tehgeekmeister> omniscientIdiot: i thot it had lower precedence than function application!
19:57:58 <omniscientIdiot> tehgeekmeister: yes, but technically flip doesn't have enough args yet to fully expand it
19:58:08 <omniscientIdiot> (flip fix 4) $ (\f -> ...)
19:58:35 <omniscientIdiot> $ isn't an arg to flip, (flip fix 4) is an arg to ($)
19:58:47 <mudge> omniscientIdiot: does the module name have to be the same name as its file name?
19:58:47 <Trixsey> what does \x mean? not x? :/
19:59:06 <omniscientIdiot> mudge: I'm not sure it *has* to be, but you probably should
19:59:12 <omniscientIdiot> Trixsey: lambda
19:59:26 <mauke> Trixsey: \ <parameter> -> <body>
19:59:28 <Trixsey> and lambda in this context means?
19:59:32 <mauke> function
19:59:32 <omniscientIdiot> (\x -> x + 1) is a function that adds one to its argument
19:59:40 <omniscientIdiot> > (\x -> x + 1) 4
19:59:42 <lambdabot>  5
19:59:53 <tehgeekmeister> omniscientIdiot: how do i go about learning how things bind, better, then?  that'd solve a lot of problems for me, i think.
20:00:34 <Trixsey> >map help
20:00:39 <Trixsey> :o
20:00:43 <omniscientIdiot> (add a space after >)
20:01:01 <Trixsey> didn't work anyway :S
20:01:05 <Trixsey> tried in pm
20:01:13 <Trixsey> Not in scope: `help'
20:01:18 <lament> what's map help supposed to do/
20:01:18 <omniscientIdiot> tehgeekmeister: Not sure...
20:01:19 <lament> ?
20:01:19 <MU9214> How long does it usually take to compile and install ghc using macports on a PPC g4 mac mini? It's been at Building ghc with target all about about 1.5 hours.
20:01:29 <Trixsey> lament: tell me more about map!! :D
20:01:29 <Trixsey> lol
20:01:39 <omniscientIdiot> @index map
20:01:40 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
20:01:43 <omniscientIdiot> @docs Prelude
20:01:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
20:02:01 <MU9214> is my install frozen or normal?
20:02:02 <lament> Trixsey: assuming 'help' were defined, 'map help' would just pass 'help' as a parameter to map
20:02:07 <omniscientIdiot> use @index <name> to find the module a name is in, then @docs <module> to look up the docs
20:02:24 <sjanssen> MU9214: quite a long time, probably
20:02:47 <MU9214> sjanssen: time estimate?
20:02:52 <omniscientIdiot> tehgeekmeister: are you working through a tutorial?
20:03:13 <lament> i saw zipWith on the board in one of my CS classes
20:03:16 <sjanssen> MU9214: 2-3 hours?
20:03:21 <tehgeekmeister> omniscientIdiot: yes, but that's not currently what i'm working on.
20:03:22 <lament> and i don't think there's a haskell course in the uni...
20:03:24 <MU9214> sjanssen: thanks.
20:03:27 <sjanssen> it takes 45 min. ony Core Duo
20:03:35 <sjanssen> if that gives you any idea
20:03:42 <MU9214> i only have a g4. want to get a macbook eventually.
20:03:56 <MU9214> how big is it, after it's installed? Is it gonna slow down my mini a lot?
20:04:17 <sjanssen> MU9214: btw, you might be better off sticking with a binary build of ghc
20:04:43 <MU9214> sjanssen: i need the version that works with Perl6/Pugscode... the newest version
20:04:57 <MU9214> i dont think they have a binary for that, do they?
20:05:09 <Trixsey> Is Evol a pre-defined class?
20:05:09 <MU9214> this is what the pugscode site said to install, so i'm just doing what it said.
20:05:19 <sjanssen> MU9214: it's about 175MB on my machine
20:05:19 * tehgeekmeister finishes a gentle introduction to haskell real quick
20:05:22 <MU9214> but is it gonna make my mini a lot slower even after the install?
20:05:28 <MU9214> sjanssen: k. not that bad
20:05:37 <MU9214> whys it take so long to install though?
20:05:51 <lament> it won't slow your computer down unless you run it.
20:06:01 <monochrom> not long to install. long to build. you're building.
20:06:15 <MU9214> k
20:06:21 <omniscientIdiot> tehgeekmeister: Haskell's precedence rules are pretty small, but without an intuition I can see why code could look like a meaningless sea of symbols.  I wonder if there's a list of example lexes that show the grouping of code with parens?
20:07:52 <Trixsey> Is Evol a standard class? :o)
20:08:05 <tehgeekmeister> omniscientIdiot: that would be useful, i'll have to look around for such a thing, but it's certainly not in the tutorials/books i've read so far.
20:08:55 <mauke> Trixsey: no
20:09:06 <omniscientIdiot> a b c $ d = ((a b) c) $ d, since, as you said, application is so tight.  When you see an operator, remember that it's looser than its args on the sides
20:09:51 <omniscientIdiot> if, however, the operator is in parens, it behaves like an ordinary name:  a b c ($) d = ((((a b) c) ($)) e)
20:10:50 <tehgeekmeister> okay, that's useful.
20:11:38 <omniscientIdiot> so (flip fix 4 $ ...) = ((flip fix 4) $ (...)) = (fix (...) 4)
20:11:49 <omniscientIdiot> er, I think I skipped a step
20:12:14 <omniscientIdiot> so (flip fix 4 $ ...) = ((flip fix 4) $ (...)) = (flip fix 4 (...)) = (fix (...) 4)
20:12:51 <omniscientIdiot> the use of the ($) is bos's code is so he didn't have to surround the giant right-hand lambda in parens.
20:13:40 <tehgeekmeister> right, sensible.
20:14:04 <tehgeekmeister> unfortunate that it took me a few hours to get to this conclusion, but sensible!
20:15:26 <omniscientIdiot> :D  parsing haskell expressions is rather extremely different than many other languages, but once you get the intuition, I think you'll appreciate its simplicity.  Just keep asking questions!
20:17:20 <tehgeekmeister> yes, it is quite different.  i must say, i really do like haskell, tho.  i certainly wouldn't be putting this much effort into a language that wasn't this powerful.
20:18:07 <Trixsey> If I want to implement a typeclass Evol and let MolSeq and Profile become instances of Evol, I could do something like this right?
20:18:07 <Trixsey> instance Evol Profile,MolSeq where
20:20:19 <Trixsey> or can't I use both of them there? "Profile,MolSeq" is the part I'm not sure about
20:21:30 <omniscientIdiot> other languages require parens and commas for function application, but Haskell functions take one argument, so it's just (function arg), which might result in a function you can pass another arg to: ((function arg) arg2) = (function arg arg2), and infix operators complicate this somewhat
20:22:32 <omniscientIdiot> application is tightest, so (f x y `op` g a b) = ((f x y) `op` (g a b))
20:23:23 <omniscientIdiot> the fixity and associativity affect how operators bind with respect to each other.
20:23:33 <allbery_b> Trixsey: you havre to do each one separately
20:25:04 <omniscientIdiot> a b ! c d ? e f = ((a b) ! ((c d) ? (e f))), if (?) has tighter fixity
20:28:28 <Trixsey> allbery_b, is there a simpler way to do it? Like make one Evol instance compatible with two different types (Lists and lists of lists (matrices)) for instance?
20:29:25 <allbery_b> if the same methods work for all the instances you're going to define, put the instances as default methods in the class declaration.
20:29:31 <allbery_b> then it's just
20:29:49 <allbery_b> instance Evol Profile where -- nothing
20:29:58 <allbery_b> instance Evol MolSeq where -- nothing
20:30:09 <allbery_b> and the defaults from the class will be used for both
20:31:50 <Trixsey> http://pastebin.com/m5073c6fd
20:31:52 <Trixsey> something like this would work?
20:31:54 <omniscientIdiot> tehgeekmeister: you also said you thought flip should be substituted first because it has tighter fixity.  Fixity deals only with grouping.  Actual order of operation doesn't matter because of Haskell's lazyness.
20:32:02 <Trixsey> or would it get nested or something?
20:32:23 <Trixsey> this would only work for MolSeq I guess?
20:32:29 <omniscientIdiot> or its non-strictness I should say
20:32:54 <adamjones> is there an easy way to resolve an ambiguity in defining a + operator for my vector data type?
20:33:50 <omniscientIdiot> adamjones: what kind of ambiguity?
20:33:54 <omniscientIdiot> @paste
20:33:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:35:05 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2978
20:35:26 <adamjones> that was it...forgot to leave my name.
20:35:46 <Trixsey> http://pastebin.com/m48a0c126 <- is there a prettier solution to this?
20:35:50 <omniscientIdiot> you could import Prelude hiding ((+))
20:36:22 <Trixsey> I know allbery_b suggested putting it in the class definition, but it feels scary, I want it within the where :(
20:36:28 <omniscientIdiot> or choose a different name for your vector addition
20:36:36 <omniscientIdiot> (.+) perhaps?
20:37:36 <adamjones> omniscientIdiot: thanks, renaming it is probably a good idea anyways since multiplication/division don't work as expected
20:38:17 <omniscientIdiot> if it satisfies the Num laws, you could instance Num Vec
20:38:38 * omniscientIdiot doesn't know enough abstract algebra for sure
20:38:55 <adamjones> It doesn't, division doesn't quite make sense.
20:39:16 <omniscientIdiot> Num doesn't have division, does it?
20:39:20 <omniscientIdiot> @src Num
20:39:20 <lambdabot> class  (Eq a, Show a) => Num a  where
20:39:21 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:39:21 <lambdabot>     negate, abs, signum     :: a -> a
20:39:21 <lambdabot>     fromInteger             :: Integer -> a
20:39:40 <adamjones> guess that would work then.
20:44:33 * omniscientIdiot looks through the report and Prelude for a list of the Num laws, finds only 'abs x * signum x == x'
20:45:24 <OceanSpray> does anybody even use Liskell?
20:55:02 <johnnowak> i just wish they'd balance the parens on liskell.org
20:55:28 <johnnowak> they were wrong. then they fixed them. and they're STILL wrong. not a big deal, just utterly odd.
20:57:50 <adamjones> johnnowak: The example on the front page looks right, which ones are you talking about?
20:58:07 <adamjones> oh, wait, the parens for the haskell side are wrong.
20:58:27 <adamjones> evidently they really enjoy adding more parens to haskell. ;)
20:58:41 <johnnowak> adamjones: aye. the scheme version has 7 closing parens before.
20:58:45 <johnnowak> they're paren-crazy!
20:59:50 <adamjones> johnnowak: You did know that John McCarthy has put out a ten dollar bounty on broken paren keys, right?
21:00:05 <johnnowak> hehe
21:00:08 <adamjones> it's a language adoption helping effort.
21:00:18 <adamjones> He pays twenty for right parens.
21:02:22 * shapr boings cheerfully
21:04:10 <dibblego> ?type splitAt
21:04:13 <lambdabot> forall a. Int -> [a] -> ([a], [a])
21:14:21 <omniscientIdiot> @yow!
21:14:21 <lambdabot> I feel partially hydrogenated!
21:14:37 <omniscientIdiot> how awful
21:20:27 <adamjones> @yow!
21:20:27 <lambdabot> If a person is FAMOUS in this country, they have to go on the ROAD for
21:20:28 <lambdabot> MONTHS at a time and have their name misspelled on the SIDE of a
21:20:28 <lambdabot> GREYHOUND SCENICRUISER!!
21:20:52 <adamjones> mine wasn't as bad.
21:22:09 <malim> `scenicruiser'... what a wonderful word (*puke*)
21:33:01 <slava> does ghc use darcs to manage sources?
21:33:17 <Heffalump> yes
21:33:29 <slava> are there any performance issues?
21:33:40 <slava> have they ever been forced to re-create the repos from scratch?
21:35:16 <sjanssen> slava: I know that they're very disciplined about not letting conflict patches into the repo
21:35:37 <slava> are conflict patches the cause of darcs slowness?
21:35:48 <slava> have they considered switching to another dvcs?
21:36:50 <malim> What's a `monad'?
21:37:34 <Pseudonym> It's a warm fuzzy thing that you should not be the least bit frightened of!
21:37:37 <omniscientIdiot> a Monad is a type that supports the return and bind functions such that the monad laws hold.
21:37:39 <ddarius> malim: An endofunctor and two natural transformations that satisfy some laws.
21:38:01 <Pseudonym> I liked my explanation better.
21:38:16 <ddarius> Pseudonym: Who says they're in conflict?
21:38:21 <Pseudonym> Indeed!
21:38:34 <slava> ddarius: endofunctor? really?
21:38:42 <ddarius> slava: Yes.
21:39:00 <slava> if F is the free group functor, and U is the forgetful functor from groups to sets, then U*F is a monad right?
21:39:05 <ddarius> slava: Well you can generalize to an endo-1-cell.
21:39:15 <ddarius> Yep, Set -> Set
21:39:26 <slava> and an endofunctor = "onto" functor?
21:39:27 <Heffalump> slava: yes, and yes.
21:39:33 <slava> not every set is in the image of that functor...
21:39:38 <slava> hmm
21:39:42 <Pseudonym> malim: Google "monad tutorial haskell" and take your pick.
21:39:43 <ddarius> slava: No, just a functor from a category to that category.
21:39:44 <malim> Ok. I see now. yes, yes... What's a `functor'?
21:39:44 <slava> i'm wrong
21:39:50 <Pseudonym> And if you have any questions, ask here.
21:39:55 <slava> ddarius: i mixed up 'epi' and 'endo'
21:39:56 <ddarius> malim: A functor is a category homomorphism.
21:40:24 <omniscientIdiot> ...not that there's anything wrong with that
21:40:26 <ddarius> slava: One usually does not say "epifunctor".
21:40:32 * omniscientIdiot buh-dum pssh!
21:40:35 <malim> Pseudonym: I can't use Google. The Internet is not set up.
21:40:51 <slava> yet you're on IRC?
21:41:04 <malim> slava: Internet, not IRC...
21:41:04 <ddarius> They still haven't finished setting it up, sheesh!
21:41:41 <omniscientIdiot> uh, you mean you don't have a suitable web browser or something?
21:41:54 <malim> They connected *some* of the tubes to my house. Not *all* the tubes yet. (and didn't interconnect all the tubes connected to my house)
21:42:33 <Pseudonym> I'm confused.  Web traffic goes over a different tube?
21:42:47 <malim> So the Google tube is still hanging somewhere...
21:42:58 <Pseudonym> Google Tube.  Good name for a product.
21:42:58 <omniscientIdiot> @google monad tutorial
21:43:01 <lambdabot> http://patryshev.com/monad/m-intro.html
21:43:01 <lambdabot> Title: Crash Monad Tutorial
21:44:15 <malim> Ooo... looks like a good link...
21:44:41 <omniscientIdiot> maybe a little too "crashy" if you don't know what a functor is.
21:44:55 <OceanSpray> I herd dat monads are superior to 'normal' sequential coding.
21:45:09 <OceanSpray> what's with that?
21:45:16 <ddarius> OceanSpray: Nonsense.
21:45:40 <OceanSpray> ?
21:45:42 <monochrom> monads are about tubes too :)
21:45:49 <ddarius> Perhaps you mean the monadic style of programming.
21:45:59 <OceanSpray> yeah, maybe.
21:46:10 <omniscientIdiot> @go monads as computation
21:46:13 <lambdabot> http://blogs.msdn.com/dsyme/archive/2007/09/22/some-details-on-f-computation-expressions-aka-monadic-or-workflow-syntax.aspx
21:46:13 <lambdabot> Title: Don Syme's WebLog on F# and Other Research Projects : Some Details on F# Computa ...
21:46:16 <omniscientIdiot> ???
21:46:24 <OceanSpray> lol msdn
21:46:33 <ddarius> OceanSpray: It's largely dependent on what you consider "normal" imperative programming.
21:46:48 <omniscientIdiot> Cale!!!!
21:46:58 <Cale> yeah?
21:46:58 <OceanSpray> a.k.a. the type used in 99% of mainstream languages.
21:47:22 <omniscientIdiot> malim wants to know what a moand is
21:47:23 <ddarius> OceanSpray: In that case, yes, but primarily because 99% of mainstream languages suck all around.
21:47:39 <OceanSpray> wow, that's a strong statement.
21:47:49 <OceanSpray> There's something I still don't get.
21:48:14 <Pseudonym> I think it's also incorrect.
21:48:22 <Pseudonym> 100% of programming languages suck in some respect.
21:48:37 <ddarius> Pseudonym: I didn't say "in some respect"
21:48:38 <monochrom> Somehow, "mainstream" by definition and "the lower 50%" by definition imply the strong statement.
21:48:39 <pgavin> I would have to agree with that as well :)
21:48:44 <Pseudonym> And to be honest, I'm not convined that there are 100 "mainstream languages".
21:48:45 <OceanSpray> See, if these 'uncommon' languages are so much more powerful and expressive,
21:48:56 <Pseudonym> Which is a precondition for there being a stray 1%.
21:49:03 <omniscientIdiot> here we are: http://www.haskell.org/haskellwiki/Monads_as_computation
21:49:04 <lambdabot> Title: Monads as computation - HaskellWiki
21:49:05 <OceanSpray> why do 90% of the coders not use them?
21:49:16 <monochrom> The lower 90%, too.
21:49:27 <Pseudonym> monochrom: Sturgeon's Revelation is correct, ehre.
21:49:28 <Pseudonym> here
21:49:29 <ddarius> OceanSpray: Why did betamax lose to VHS?
21:49:35 <OceanSpray> I have no idea.
21:49:36 <pgavin> legacy code, abstraction is difficult to understand, etc.
21:49:40 <omniscientIdiot> porn
21:49:46 <pgavin> yes, and porn
21:49:51 <pgavin> lets not forget that one
21:49:55 <monochrom> What is Sturgeon's revelation again?
21:49:57 <Apocalis1> looks like I got here just in time
21:50:04 <Pseudonym> ?go sturgeon's revelation
21:50:06 <lambdabot> http://en.wikipedia.org/wiki/Sturgeon's_law
21:50:06 <lambdabot> Title: Sturgeon's Law - Wikipedia, the free encyclopedia
21:50:12 <pgavin> isnt that the 80/20 rule?
21:50:12 <monochrom> thanks
21:50:26 <pgavin> or is that amdahl's law
21:50:32 <pgavin> thats a fish
21:50:36 <Apocalis1> almost everything is crap, right?
21:50:41 <Pseudonym> Right.
21:50:44 <Pseudonym> 90% of everything is crap.
21:50:49 <Apocalis1> right on
21:50:54 <Pseudonym> He stated it "crud".
21:51:05 <Pseudonym> By extension, BTW, 81% of everything is complete crap.
21:51:12 <Pseudonym> And 9% of everything is mostly crap.
21:51:19 <Pseudonym> Or partly crap.
21:51:20 <monochrom> hehe
21:51:20 <OceanSpray> because we don't want our precious little snowflakes to hear them baaad words, rite?
21:51:56 <OceanSpray> It just doesn't make sense.
21:52:13 <OceanSpray> It's the same in music, too
21:52:18 <Pseudonym> OceanSpray: Sturgeon actually was answering a question that was posed with the term "crud".
21:52:18 <omniscientIdiot> what doesn't make sense?
21:52:20 <monochrom> Anyway, "if XXX is so great, why don't 99% of people rush to use it" is a flawed question or flawed rhetorical question.
21:52:32 <Pseudonym> OceanSpray: There's one exception.  Old stuff often isn't crud.
21:52:39 <Pseudonym> And the reason is natural selection.
21:52:47 <Pseudonym> Old crud gets forgotten or destroyed.
21:52:59 <ddarius> It gets replaced with new crud
21:53:08 <OceanSpray> It wasn't meant to be a rhetorical question.
21:53:10 <Apocalis1> there's more and more crud as well
21:53:15 <Pseudonym> An example is music.
21:53:26 <Apocalis1> It's easier and easier to make crud music.
21:53:28 <Pseudonym> We remember Mozart, Bach, Beethoven...
21:53:36 <Pseudonym> We forget the 90% of music from that era that was crud.
21:53:40 <OceanSpray> I really meant "This shit rocks, but why are people too stupid to see why it's so great?"
21:53:42 <monochrom> We even forget CPE Bach.
21:54:02 <ddarius> OceanSpray: You've answered your own question: people are stupid.
21:54:03 <Apocalis1> no, we don't
21:54:15 <monochrom> OK, that question is a tautology, can't be further explained except "it's an axiom" :)
21:54:22 <OceanSpray> ddarius, I'm not that cynical.
21:54:27 <Pseudonym> OceanSpray: There are some more sensible reasons, too.
21:54:36 <Pseudonym> One is a chicken and egg problem.
21:54:42 <Apocalis1> That isn't a problem.
21:54:47 <ddarius> That's not cynicism at all.
21:54:53 <Pseudonym> Another is that there's no guarantee that _new_ cool technology will still be around in five years.
21:55:00 <Pseudonym> Especially if it's still in a state of flux.
21:55:07 <Apocalis1> or if it's crap
21:55:15 <OceanSpray> what, believing that 90% of people are too stupid to understand abstraction?
21:55:34 <monochrom> More likely 90% are not educated properly.
21:55:38 <fax> Hello
21:55:44 <sclv> @src read
21:55:44 <lambdabot> read s = either error id (readEither s)
21:55:49 <OceanSpray> orz
21:55:50 <monochrom> For example kindergarten doesn't teach basic logic, but it should.
21:55:56 <ddarius> OceanSpray: I didn't say that, and yes, that is not cynicism.  Cynicism is being suspicious of people's motives.
21:55:57 <omniscientIdiot> @src readEither
21:55:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:56:01 <Pseudonym> Personally, I have a real problem with the fact that some of the most useful bits of Haskell aren't part of any standard.
21:56:10 <OceanSpray> I just kept on using that word.
21:56:18 <Pseudonym> I can imagine how that might make someone nervous.
21:56:23 <Apocalis1> ddarius: cynicism is disbelief in the possibility of "good"
21:56:30 <OceanSpray> It doesn't mean what I thought it meant.
21:56:44 <ddarius> Let's ask lambdabot, she'll decide it.
21:57:04 <ddarius> (Not that there is a necessary a conflict between what I said and what Apocalis1 said)
21:57:08 <ddarius> @wn cynicism
21:57:12 <lambdabot> *** "cynicism" wn "WordNet (r) 2.0"
21:57:12 <lambdabot> cynicism
21:57:12 <lambdabot>      n : a cynical feeling of distrust
21:57:18 <lambdabot> Cynicism is a philosophical system characterised by the belief that self-interest is the human's primary motive.
21:57:27 <OceanSpray> oy, there's a revelation
21:57:39 <OceanSpray> and I thought it meant being generally negative.
21:57:46 <ddarius> That would be pessimism
21:57:50 <Apocalis1> That's a crap definition, Wordnet.
21:57:52 <ddarius> @wn pessimism
21:57:55 <lambdabot> Example: A cynic would think that you were just too lazy to look it up on Wikipedia.
21:57:58 <lambdabot> *** "pessimism" wn "WordNet (r) 2.0"
21:57:58 <lambdabot> pessimism
21:57:58 <lambdabot>      n 1: the feeling that things will turn out badly [ant: {optimism}]
21:57:58 <lambdabot>      2: a general disposition to look on the dark side and to expect
21:57:58 <lambdabot>         the worst in all things [ant: {optimism}]
21:58:10 <OceanSpray> well, not exactly
21:58:21 <OceanSpray> believing that most people are stupid would be more like...
21:58:27 <OceanSpray> lack of faith.
21:58:27 <ddarius> realism
21:58:30 <OceanSpray> no, wait
21:58:32 <monochrom> Robotism. :)
21:58:37 <OceanSpray> can't think of a word.
21:58:47 <malim> misanthropy?
21:59:07 <fax> teenager ?
21:59:09 <Cale> malim / omniscientIdiot: sorry, I'm on the phone at the moment
21:59:19 <Cale> I'll be back in a sec :)
21:59:35 <malim> O.K. Cale! All Correct!!
21:59:42 <OceanSpray> Orl Korrekt
21:59:43 <Apocalis1> Pessimism is a psychological response such that you reward yourself today for guessing that things will go badly. You might end up in the shit, but hey, at least you get to feel good about it.
21:59:47 <Pseudonym> "It has been said that man is a rational animal. All my life I have been searching for evidence which could support this." -- Bertrand Russell
22:00:10 <lament> believing most people are stupid would be a behaviorial bias that says that since you're not aware of others' thinking, you assume they don't think as much as you do. The bias has a name which I don't remember.
22:00:10 <monochrom> hehehe
22:00:13 <malim> ehh
22:00:15 <sclv> > read "foo" :: String
22:00:17 <lambdabot>  Exception: Prelude.read: no parse
22:00:28 <sclv> is there any easy way to prevent this from failing?
22:00:35 <omniscientIdiot> > read "Just 12" :: Maybe Int
22:00:36 <lambdabot>  Just 12
22:00:44 <omniscientIdiot> > read "\"foo\"" :: String
22:00:45 <lambdabot>  "foo"
22:00:55 <Cale> okay
22:00:57 <malim> 0_o
22:01:02 <Cale> malim wanted to know what a monad is?
22:01:08 <omniscientIdiot> http://www.haskell.org/haskellwiki/Monads_as_computation
22:01:09 <lambdabot> Title: Monads as computation - HaskellWiki
22:01:09 <sclv> thx
22:01:21 <fax> > let readString eee = read ("\""++eee++"\"") :: String in readString "foo"
22:01:23 <lambdabot>  "foo"
22:01:32 <Cale> Yeah, that gives a fairly good overview if I do say so myself :)
22:01:34 <fax> > let readString = id in readString "foo"
22:01:36 <lambdabot>  "foo"
22:01:39 <omniscientIdiot> let readString = id = readString "foo"
22:01:47 <malim> Cale: yes, thank you. I'll read it (as soon as I'm awake _and_ not drunk)
22:01:47 <omniscientIdiot> oh, darn, beaten to the punch :)
22:01:49 <Cale> malim: What's your background in programming like?
22:02:01 <Pseudonym> > reads "foo" :: [(String,String)]
22:02:02 <lambdabot>  []
22:02:07 <Pseudonym> > reads "foo\" :: [(String,String)]
22:02:07 <lambdabot>  Improperly terminated string
22:02:12 <Pseudonym> > reads "\"foo\"" :: [(String,String)]
22:02:13 <lambdabot>  [("foo","")]
22:02:19 <Pseudonym> Is that what you had in mind?
22:02:26 <Cale> Have you much experience with domain specific languages or combinator libraries?
22:02:50 <sclv> Pseudonym: not exactly. i'm thinking of how to do this without rewriting "foo"
22:03:07 <Pseudonym> sclv: Did you see the first example?
22:03:09 <Pseudonym> > reads "foo" :: [(String,String)]
22:03:10 <OceanSpray> btw, what's a combinator?
22:03:10 <lambdabot>  []
22:03:21 <Pseudonym> That doesn't parse as a string, so it returns [].
22:03:29 <ddarius> OceanSpray: A buzzword in most uses.
22:03:35 <omniscientIdiot> OceanSpray: a fancy name that, as far as I can tell, usually just means "higher-order function"
22:03:43 <sclv> Pseudonym: But I want it to parse as a string. :-(
22:03:43 <Pseudonym> No, it's got a specific meaning.
22:03:52 <OceanSpray> huh?
22:03:53 <malim> Cale: background in programming? I've been at it for two years or so. Began with reading a beginner's book on C++, then took programming in college. In my second year now. (of course, they don't teach us any functional programming)
22:03:54 <Pseudonym> It's a lambda expression with no free variables.
22:03:54 <ddarius> Pseudonym: Indeed, but it's not usually used to mean that.
22:04:10 <Cale> OceanSpray: There are a couple of senses. One is that it's a function that just produces some application of its parameters to one another.
22:04:12 <Pseudonym> If all subexpressions are also combinators, then it's a supercombinator.
22:04:24 <omniscientIdiot> Pseudonym: like the SKI combinators?
22:04:30 <Pseudonym> Yes, they're supercombinators.
22:04:35 <malim> The "dreaded" application-order Y-combinator?!?!!
22:05:02 <Pseudonym> Y-combinator, expressed as a lambda expression, is _not_ a supercombinator.
22:05:05 <Pseudonym> But it is a combinator.
22:05:05 <platypus> Pseudonym: I always have called lambda expressiosn with no free variables "Thunks".
22:05:17 <OceanSpray> what's a 'free' variable?
22:05:31 <Pseudonym> OceanSpray: "Free", in this sense, refers to a specific location.
22:05:35 <Pseudonym> Take this, for example:
22:05:41 <Pseudonym> \f g x -> f x (g x)
22:05:44 <malim> a free variable is a variable that is bound by the environment, as opposed to function arguments
22:05:45 <monochrom> thunk and closure would be manifestations in computer
22:05:45 <Pseudonym> The S combinator.
22:05:45 <ddarius> I thought combinator already included having its subexpressions contain no free variables, e.g. the one basis "combinator" X is usually referred to as a "pseudo-combinator"
22:05:55 <Pseudonym> No lambda expressions have free variables.
22:06:08 <Pseudonym> In the sense that no variables from the _outside_ appear inside.
22:06:10 <OceanSpray> Ah.
22:06:11 <Pseudonym> Now consider:
22:06:20 <Pseudonym> \f -> (\x -> f (x x)) (\x -> f (x x))
22:06:31 <Pseudonym> This is not a supercombinator because (\x -> f (x x)) isn't a combinator.
22:06:37 <Pseudonym> There's a free variable there: f.
22:06:57 <OceanSpray> Oh, I kind of see what you mean now
22:07:01 <Pseudonym> I wish the old wiki was online.
22:07:10 <Pseudonym> It explained things fairly well.
22:07:29 <OceanSpray> the f comes from the outside environment, and was not created within the function that uses it, hence making that function not a combinator, aye?
22:07:32 <Cale> malim: Okay, so as functional programmers have largely discovered, a good way to solve problems generally is to construct libraries which are like small programming languages in which coding a solution to your problem is easy.
22:07:39 <Pseudonym> Right.
22:07:49 <OceanSpray> got it.
22:07:57 * ddarius needs to reinvigorate the "Bring HaWiki Back" movement.
22:08:02 <Pseudonym> Yeah.
22:08:16 <Cale> That is, libraries with a rich enough API that it's like you're programming in a language embedded in the one you're using.
22:08:21 <Pseudonym> ?foldoc lambda lifting
22:08:22 <malim> Cale: yeah, I've watched the SICP lectures.
22:08:23 <lambdabot> *** "lambda" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
22:08:23 <lambdabot> LAMBDA
22:08:23 <lambdabot>  
22:08:23 <lambdabot>         A version of {typed lambda-calculus}, used to describe
22:08:23 <lambdabot>         semantic {domain}s.
22:08:25 <lambdabot> [5 @more lines]
22:08:28 <Cale> malim: ah, great :)
22:08:28 <Pseudonym> ?foldoc "lambda lifting"
22:08:30 <lambdabot> *** "lambda lifting" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
22:08:30 <lambdabot> lambda lifting
22:08:31 <lambdabot>  
22:08:31 <OceanSpray> we talking about lisp?
22:08:33 <lambdabot>         A program transformation to remove free variables.  An
22:08:35 <lambdabot>         expression containing a free variable is replaced by a
22:08:37 <lambdabot> [21 @more lines]
22:08:40 <ddarius> That's exactly 4 years old.
22:08:40 <OceanSpray> Cale is Paul Graham in disguise?
22:08:40 <Pseudonym> ?more
22:08:41 <lambdabot>         function applied to that variable.  E.g.
22:08:41 <lambdabot>  
22:08:43 <lambdabot>         	f x = g 3  where g y = y + x
22:08:44 <lament> OceanSpray: hint: what channel are we in :)
22:08:45 <lambdabot>  
22:08:47 <lambdabot>         x is a free variable of g so it is added as an extra argument:
22:08:47 <Pseudonym> Anyway, read that.
22:08:48 <Cale> malim: So monads are one particular kind of domain specific language.
22:08:49 <lambdabot> [16 @more lines]
22:08:53 <Cale> gah!
22:08:57 <Pseudonym> Lambda lifting turns combinators into supercombinators.
22:09:00 <Cale> So much scrolling!
22:09:02 <malim> lambdabot: don't you know: flooding is frowned upon!
22:09:04 <Cale> I'm getting dizzy!
22:09:06 <adu> ooo i like DSLs
22:09:20 <Apocalis1> @slap lambdabot
22:09:20 * lambdabot beats up lambdabot
22:09:26 <omniscientIdiot> lol
22:09:27 <malim> Cale: I've watched the SICP lectures, I'm reading the book now.
22:09:32 <OceanSpray> get rid of the extra whitespace
22:09:35 <ddarius> Fight Club flashbacks.
22:09:37 <Cale> A monad is a domain specific language which supports a particular form of means of combination.
22:09:56 <Apocalis1> What's the first rule of #haskell?
22:09:56 <malim> really? that sounds pretty vast
22:10:07 * lambdabot wonders if Apocalis1 realises that bots are incapable of feeling pain
22:10:09 <ddarius> Oh god, monads are domain specific languages now?
22:10:17 <malim> I thought a monad would be like a single block of sequential code
22:10:24 <Cale> ddarius: yes, that's what they always were :)
22:10:29 <ddarius> Apocalis1: We don't talk about Haskell.
22:10:37 <OceanSpray> Cale, I thought monads were just functions
22:10:50 <omniscientIdiot> To be precise, a monad is a *type*
22:10:50 <ddarius> Cripes!
22:10:56 <ddarius> omniscientIdiot: No.
22:10:59 <malim> Not talking about Haskell is for #haskell-blah
22:11:08 <OceanSpray> and the do-notation was syntactic sugar for easier handling
22:11:15 <ddarius> malim: You'd think...
22:11:18 <OceanSpray> where does the embedded language part come in?
22:11:18 <omniscientIdiot> ddarius: type + eta + mu, right?
22:11:23 <ddarius> omniscientIdiot: No.
22:11:35 * omniscientIdiot frowns
22:11:38 <Cale> OceanSpray: well, the values of your monadic type are computations
22:11:43 <malim> What I *do* know up to know, is that monads are some kind of solution for integrating side-effect code in a purely functional language
22:11:56 <Cale> malim: Well, that's one thing they do
22:12:08 <ddarius> omniscientIdiot: It's a type constructor (that further is a Functor) and then plus join and return (or more Haskell-specific (>>=) and return and drop Functor)
22:12:11 <Apocalis1> A monad is a thing.
22:12:15 <Cale> heh
22:12:22 <ddarius> Apocalis1: True.
22:12:28 <Cale> Okay, so let's get a little more formal
22:12:34 <Apocalis1> Seriously, they could just as well be called wossnames.
22:12:35 <malim> *"up to now"
22:12:54 <OceanSpray> Does this channel go even ONE day without someone bringing up monads?
22:13:10 <shachaf> OceanSpray: Why would it?
22:13:10 <omniscientIdiot> ddarius: that's what I said!  Just because Maybe and [] aren't *-kinded doesn't mean they aren't types!
22:13:11 <Apocalis1> Impossible!
22:13:23 <Cale> A monad is a type constructor M, and we think of values of type (M t) as being computations (in our DSL) which when run, will produce a value of type t
22:13:48 <ddarius> omniscientIdiot: Yes it does.
22:13:55 <Cale> Further, there are two basic combining operations which every monad must support.
22:14:27 <Cale> First, there's return :: t -> M t. It simply takes a value, and gives the computation which "does nothing" and produces that value as a result.
22:14:31 <ddarius> omniscientIdiot: What you are saying is like saying just because id doesn't have type Int doesn't mean it's not a number.
22:15:02 <Cale> The second one is complicated the first time you see it, so I'll talk about one of its corollaries first
22:15:39 <Cale> There's an operation (>>), so that if x and y are computations, then x >> y is a computation which performs x, then performs y.
22:16:02 <Cale> (and the result of the combined computation is the result of y)
22:16:31 <Cale> However, we usually don't just want to throw the result of the computation x away.
22:16:41 <lament> Cale: you're getting better at this
22:17:31 <Cale> Much of the time, we want to capture the result of x and use it to shape the rest of the computation
22:17:59 <omniscientIdiot> ddarius: did you get my privmsg?
22:18:05 <ddarius> I responded to it.
22:18:17 <Cale> So in order to support that, there's an operation called bind, and written (>>=). On the left, it still takes a computation, but on the right, it takes a function from results of that computation to further computations to be done.
22:18:24 <ddarius> You might not have gotten the response though.
22:18:24 <omniscientIdiot> lemme check if I'm auth'd
22:18:30 <Cale> That's kind of a mouthful, so it helps to see an example or two.
22:18:30 <ddarius> I'm not identified.
22:19:09 <omniscientIdiot> ah, well, we'll just do in-channel
22:19:15 <Cale> In Haskell, there's an IO monad, for describing computations that might do I/O when they're run
22:19:16 <omniscientIdiot> ddarius: I think we're just disagreeing on terms.  I'm probably incorrect.  I thought, term-wise, type constructors subset types, even though I know there are no values for (*->*)-kinded type constructors.  In any case, I think I understand what we both mean.
22:19:27 <Cale> and in this monad, we have:
22:19:31 <ddarius> * is the kind of types by definition.  Something is a type exactly when it has kind *.
22:19:33 <Cale> getLine :: IO String
22:19:37 <shachaf> Maybe we should implement @cale, to give a random explanation of monads.
22:19:40 <sclv> hmm.. malim.. do you know webwork/struts2 or any other similar web frameworks?
22:19:41 <shachaf> It's be handy.
22:19:46 <Cale> as well as  putStrLn :: String -> IO ()
22:19:57 <malim> sclv: shhh! I'm listening to Cale
22:20:12 <sclv> :-)
22:20:19 <shachaf> s/s/d/
22:20:19 <omniscientIdiot> ddarius: I understand there are no values of kind (*->*) or higher, I just thought the word 'type' could be used to refer to them, too.
22:20:39 <ddarius> omniscientIdiot: In some languages, * is written as Type.
22:20:44 <Cale> note that putStrLn is a (pure) function which takes a String, and produces an IO action which when run produces an empty tuple. The empty tuple just indicates that the result of running it is uninteresting -- we're interested in the effect, which is to print the given string.
22:21:08 <malim> right
22:21:19 <omniscientIdiot> ddarius: using your argument, I argue that saying (*->*) is not a type is like saying (a->b) is not a term.
22:21:20 <Cale> Just evaluating putStrLn "Hello" though, doesn't cause that string to be printed
22:21:42 <ddarius> a->b -is- not a term, it's a type.
22:21:57 <omniscientIdiot> er, right
22:22:02 <Cale> It just builds the I/O computation. To actually run an I/O computation, you'll either have to type its name at the GHCi prompt, or end up defining it as the main computation of your program.
22:22:14 <shachaf> ddarius: "something of kind (*->*)", "something of type (a->b)"
22:22:29 <ddarius> Using my argument (and this is exactly what I said earlier, it's like saying that Int -> Int is not an Int.
22:22:45 <Cale> So a value of type (IO String) is a value which describes a bunch of I/O actions to be carried out, producing a String.
22:22:57 * ddarius has to decide to consistently use parentheses or subclauses.
22:23:08 <Cale> So, bind :)
22:23:17 <Cale> putStrLn "Hello" >> putStrLn "World"
22:23:26 <omniscientIdiot> ah, well, I've no formal learning in these matters, and this isn't a very useful discussion anyway.
22:23:31 <Cale> that's the action which prints Hello and World on separate lines
22:23:47 <Cale> getLine >> putStrLn "Hello"
22:24:03 <Cale> That gets a line of text from the user, throws it away, and prints "Hello"
22:24:14 <ddarius> omniscientIdiot: I've no formal "learning" either, and it's a crucial distinction and using correct terminology is crucially important (but that does not imply that this is a useful discussion)
22:24:25 <Cale> Now, if we want to use the line of text, we need the full version of bind:
22:24:39 <malim> >>=
22:24:48 <Cale> getLine >>= \name -> putStrLn ("Hello, " ++ name)
22:25:10 <Cale> It takes the result of getLine, which is a String, and passes it to the function on its right
22:25:17 <malim> mmhm
22:25:28 <dolio> @djinn Not a -> a -> b
22:25:28 <lambdabot> f a b = void (a b)
22:25:33 <Cale> that function produces an action which is the rest of the stuff to be done
22:25:57 <Apocalis1> I just realized that I invented bind once.
22:26:05 <Apocalis1> at least one
22:26:05 <Cale> There was that one other primitive, return, which I mentioned at the beginning.
22:26:07 <Apocalis1> once
22:26:32 <Cale> It's handy at the end of a chain of actions, for deciding on a specific result to return, rather than leaving it up to the last action in the chain.
22:27:17 <Cale> Remember it doesn't have the control properties of return in most imperative languages though: it just produces the no-op computation which returns the given value every time.
22:27:52 <Cale> (So it doesn't cause you to jump out of the middle of blocks of code -- return in the middle of a block does nothing)
22:28:30 <Tac-Tics2> > map map [map map map]
22:28:32 <lambdabot>  Couldn't match expected type `[a -> b]'
22:28:46 <Cale> As you might imagine, most programs which use monads end up with long chains of >>= and >>
22:28:52 <fax> :t (map map map)
22:28:54 <lambdabot>     Couldn't match expected type `[a -> b]'
22:28:54 <lambdabot>            against inferred type `(a1 -> b1) -> [a1] -> [b1]'
22:28:58 <OceanSpray> > bork bork [bork bork bork]
22:28:59 <lambdabot>   Not in scope: `bork'
22:29:02 <ari> :t (map . map . map)
22:29:04 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
22:29:10 <Cale> In order to make that a little prettier, there's some syntax, which is directly converted into appropriate >>='s and >>'s
22:29:26 <Tac-Tics2> > this expression contains mostly [undefined variables]
22:29:27 <lambdabot>   Not in scope: `variables'
22:29:30 * FMota has found a delightful functional syntax
22:29:39 <fax> > (map . map . map) (*2) [[[1],[1,2]],[[5]]]
22:29:39 <Cale> @undo  do { name <- getLine; putStrLn ("Hello, " ++ name) }
22:29:39 <lambdabot> (getLine >>= \ name -> putStrLn ("Hello, " ++ name))
22:29:41 <lambdabot>  [[[2],[2,4]],[[10]]]
22:29:56 <Cale> and the undo plugin in lambdabot will happily convert it for you :)
22:30:13 <malim> "@undo"... hehhh
22:30:18 <Tac-Tics2> litterally, it un-do-es a do expression
22:30:46 <Cale> IO isn't by any means the only monad though
22:30:56 <dolio> @type map map [map map]
22:30:58 <lambdabot> forall a b. [[[a -> b]] -> [[[a] -> [b]]]]
22:31:19 <Pseudonym> ?type map map [map map [map map]]
22:31:21 <lambdabot>     Couldn't match expected type `a -> b'
22:31:21 <lambdabot>            against inferred type `[[[a1 -> b1]] -> [[[a1] -> [b1]]]]'
22:31:25 <malim> Do programmers prefer >> & >>=, or <- & ; ?
22:31:32 <Pseudonym> malim: Depends.
22:31:35 <ddarius> malim: Yes.
22:31:45 <Pseudonym> ddarius: Actually, the answer is "no".
22:32:04 <monochrom> I like them all.
22:32:04 <Cale> There are monads for Prolog-like nondeterminism, for maintaining small bits of state (while still not doing IO), for passing "environment" parameters implicitly down to computations, for managing continuations, and all sorts of other things
22:32:19 <Cale> malim: In fact, you can mix them
22:32:19 <ddarius> For passing state backwards.
22:32:30 <omniscientIdiot> usually I use (>>=) and return for short definitions
22:32:32 <malim> the question was: do they prefer X or Y?  I'm not sure what `yes' and `no' mean...
22:32:41 <Cale> malim: the flipped version of >>=, which is =<< mixes rather well with do notation
22:32:53 <ddarius> malim: Both are used by most programmers.  They don't prefer one or the other.
22:32:54 <notsmack> malim: some prefer one, some prefer another, some prefer both
22:32:57 <monochrom> Collect them all!
22:33:02 <omniscientIdiot> f >>= k = k =<< f
22:33:11 <malim> 0_o
22:33:28 <Cale> k >>= f = f =<< k, rather
22:33:46 <Cale> and vice versa :)
22:33:49 <omniscientIdiot> Cale: that's the same module alpha
22:33:54 <Pseudonym>   f
22:33:58 <ddarius> @src (=<<)
22:33:58 <Pseudonym>  | |
22:33:58 <lambdabot> f =<< x = x >>= f
22:33:59 <omniscientIdiot> s/module/modulo/
22:34:02 <Cale> omniscientIdiot: yeah, but the names are suggestive
22:34:04 <Pseudonym>  /\
22:34:05 <Pseudonym>  /\
22:34:08 <Pseudonym>   m
22:34:21 <Pseudonym> Just in case you're not happy with those directions.
22:34:21 <Cale> Pseudonym: haha
22:34:29 <Pseudonym> f
22:34:31 <Pseudonym> \\
22:34:35 <Pseudonym>  |\
22:34:37 <Pseudonym>   |\
22:34:41 <Pseudonym>    m
22:34:53 <Pseudonym> And at that point, the bar closed.
22:34:55 <omniscientIdiot> Cale: but I put (>>=) on the left of the equals, I used k for 'Kleisli'
22:35:04 <fax> haha
22:35:05 <omniscientIdiot> f was probably a bad choice for the action
22:35:33 <Cale> malim: anyway, there's actually some laws which >>= and return are required to satisfy, but they're actually kind of obvious things which you'll probably end up assuming based on my descriptions of what >>= and return do. Read my article if you want to know what they are :)
22:35:59 <Cale> They essentially mean that certain kinds of code refactorings are always valid.
22:36:05 <ddarius> Your trial license for Cale has expired.  You must buy the full version now.
22:36:07 <Cale> Regardless of the monad you're working with.
22:36:09 <omniscientIdiot> do { x <- a ; return x } = do { a }
22:36:26 <Pseudonym> fmap id = id
22:36:30 <notsmack> Cale: there's no enforcement of those laws, right?
22:36:30 <Cale> okay, okay, we'll list them :)
22:36:31 <Pseudonym> fmap (f . g) = fmap f . fmap g
22:36:36 <Pseudonym> And the associative law.
22:36:41 <Pseudonym> That's the three.
22:36:53 <Pseudonym> "But hang on," I hear you say, "that doesn't sound right."
22:36:59 <Korollary> I'm waiting for the open source community to implement a drm-free, nag-free Cale.
22:37:08 <Cale> notsmack: No, except that if you write an instance of Monad which breaks the laws, the Category Theory Police will be knocking at your door the next morning.
22:37:12 <Pseudonym> Actually, they follow from the two fmap laws, the associative law, and the free theorems for return and bind.
22:37:20 <malim> Cale: article?
22:37:25 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
22:37:25 <ddarius> Korollary: An open source Cale would be very interesting.
22:37:27 <lambdabot> Title: Monads as computation - HaskellWiki
22:37:39 <omniscientIdiot> notsmack: that'd be like inforcing that, for some instance of Num, that (a + 0 = a).  You'd want it to be true, but it's not done statically.
22:37:43 <malim> Oh, I didn't know it was *your* article
22:37:45 <Cale> do { w <- return v; f w } == do { f v } -- the first unit law
22:37:46 <omniscientIdiot> *enforcing
22:37:47 <ddarius> God certainly doesn't believe in the FSF's vision.
22:37:54 <Cale> do { v <- x; return v } == do { x } -- second unit law
22:37:55 <Korollary> ddarius, yes. You don't like his opinion on subject X? Fork him.
22:37:59 <notsmack> Cale: i wonder any time i read about the laws...  is it possible there's an interesting definition that violates them?
22:38:03 <Cale> 3. do w <- do v <- x
22:38:03 <Cale>               f v
22:38:03 <Cale>       g w
22:38:03 <Cale>  
22:38:03 <Cale> == do v <- x
22:38:03 <Cale>       w <- f v
22:38:05 <Cale>       g w
22:38:14 <Cale> and that's called associativity
22:38:15 <ddarius> notsmack: Yes.
22:38:43 <Pseudonym> ?free return :: a -> M a
22:38:43 <lambdabot> $map_M f . return = return . f
22:38:45 <omniscientIdiot> notsmack: if it violates the laws, it's technically not a monad, but it could be something else useful.
22:38:49 <notsmack> ddarius: then are they less laws and more suggestions?  only laws if you want to be true to category theory?
22:38:50 <Cale> notsmack: yeah, there are lots actually, but they can be kind of confusing to use, when you're used to monads.
22:39:02 <Pseudonym> ?free bind :: M a -> (a -> M b) -> M b
22:39:02 <lambdabot> $map_M g . h = k . f => $map_M g (bind x h) = bind ($map_M f x) k
22:39:06 <ddarius> notsmack: It's a bad idea to break the laws.
22:39:19 <Cale> notsmack: They're important to make the general monad functions behave sanely.
22:39:38 <Cale> notsmack: And not drive your users insane when they try to refactor their code and it breaks :)
22:39:45 <omniscientIdiot> notsmack: it'd be like having a number type where (a + 0) didn't equal a, it's incorrect.
22:39:54 <ddarius> Not enforcing the monad laws (and such things) is Haskell's unchecked array indexing.
22:40:13 <notsmack> Cale: sure
22:40:27 <Cale> ddarius: Not enforcing the Ix laws is Haskell's unchecked array indexing.
22:40:36 <wnoise> I thought unchecked Ix instances were Haskell's unchecked array indexing.  Scooped.
22:41:10 <notsmack> probably trivial to whip up QuickChecks for the monad laws on a given monad?
22:41:14 <Pseudonym> Anyway, the point is that if you have a sane fmap instance, it's actually impossible to break the other monad laws apart from the associative law.
22:41:22 <Pseudonym> (In the absence of bottom.)
22:41:24 <Apocalis1> liftM2 zip ptsOf (ap ((++) . tail . ptsOf) (return . head . ptsOf))
22:41:30 <Apocalis1> Do people really write code like this?
22:41:45 <Cale> anyway, if you read that associativity law, it basically says that if you have some sub-do-block of code, you're allowed to factor it out into its own definition without changing the meaning of the program
22:41:47 <Pseudonym> Apocalis1: Sadly, some do.
22:42:08 * Apocalis1 is boggled
22:42:11 <malim> Cale: well, I certainly appreciate all the effort you put in teaching a confessed drunk. I will tell you it wasn't it vain.
22:42:19 <wnoise> @where ord
22:42:19 <lambdabot> I know nothing about ord.
22:42:26 <Pseudonym> Now, here's the cool bit.
22:42:28 <Pseudonym> ?free return :: a -> M a
22:42:28 <lambdabot> $map_M f . return = return . f
22:42:34 <Pseudonym> That's the free theorem for "return".
22:42:37 <Cale> malim: hehe, if you've forgotten anything later or have more questions, feel free to ask
22:42:40 <Pseudonym> For "$map_M", read "fmap".
22:42:45 <Pseudonym> ?free bind :: M a -> (a -> M b) -> M b
22:42:45 <lambdabot> $map_M g . h = k . f => $map_M g (bind x h) = bind ($map_M f x) k
22:42:50 <Pseudonym> That's the free theorem for "bind".
22:43:07 <Pseudonym> Take the free theorem for return, and match it up with the LHS of the implication in the free theorem for bind.
22:43:12 <Pseudonym> You have:
22:43:17 <Cale> malim: The concept of monads in general is not so hard, but there are lots of examples to learn about.
22:43:19 <malim> Cale: you're a born teacher then. Are you one by profession?
22:43:25 <Cale> Not yet.
22:43:32 <malim> Cale: `yet'?
22:43:34 <Cale> I'd like to be a professor someday.
22:43:39 <Pseudonym> fmap f . return = return . f => fmap f (bind x return) = bind (fmap f x) return
22:43:48 <malim> Cale: what are you now?
22:43:50 <Cale> First I'm going to need to get my act together and go to grad school.
22:43:52 <Pseudonym> The LHS is the free theorem for return.
22:43:53 <Pseudonym> So you have:
22:44:04 <Pseudonym> fmap f (x >>= return) = (fmap f x) >>= return.
22:44:14 <notsmack> Cale: you haven't done any grad school?
22:44:27 <Cale> I'm doing random small jobs, and studying in my spare time.
22:44:32 <Cale> notsmack: nope
22:44:34 <glguy> how many times is too many times to listen to the same song in a row?
22:44:37 <Pseudonym> Erm.
22:44:37 <malim> Cale: sounds like me lol
22:44:41 <Pseudonym> hang on, forgot this.
22:44:46 <Pseudonym> Never mind, I'll work it out later.
22:44:50 <omniscientIdiot> glguy: 298,347
22:44:58 <omniscientIdiot> give-or-take
22:45:06 <notsmack> Cale: i'm absolutely ashamed of my own undergrad knowledge, then
22:45:34 <Cale> notsmack: Well, I went to Waterloo for pure mathematics, and I've studied a lot of stuff on my own.
22:45:46 <olsner> is "Grad school" what you read after a bachelors to get a masters, or is it masters->doctor?
22:45:50 <omniscientIdiot> how about an example monad?
22:45:55 <omniscientIdiot> Maybe for instance?
22:45:55 <Cale> olsner: both
22:46:03 <olsner> oh
22:46:04 <hpaste>  FMota pasted "Delightful Functional Syntax" at http://hpaste.org/2979
22:46:05 <malim> come on guys, don't base one's knowledge on academic grades
22:46:13 <notsmack> (that's ontario, and not belgium?)
22:46:24 <Cale> notsmack: yeah, I'm in Ontario
22:46:29 <notsmack> olsner: everything after bachelors
22:46:34 <glguy> a lot of people skip the masters step
22:46:38 <FMota> Check out the syntax. Opinions?
22:46:39 <glguy> and go straight to doctorate
22:46:57 <Cale> notsmack: Waterloo is a pretty good place to do a mathematics undergrad. It has a faculty of mathematics.
22:47:06 <malim> What's Sei?
22:47:16 <FMota> My FPL
22:47:32 <FMota> Which I'm using to learn more about FP.
22:47:33 * Apocalis1 heads down to Waterloo station
22:47:34 <notsmack> Cale: i've actually got an abstract algebra book en route from amazon, inspired by your #haskell lectures
22:47:38 <FMota> And waste all of my time.
22:48:00 <Cale> With a school of CS which is part of that, along with departments of pure mathematics, combinatorics and optimisation, applied mathematics, statistics, and actuarial science (and maybe I forgot one)
22:48:19 <Cale> notsmack: cool :)
22:48:26 <fax> humm
22:48:32 <malim> FMota: `your' fpl?
22:48:39 <fax> Kind of wish I could use the Parsec stuff I wrote to create a show instance
22:48:46 <fax> backwards :S
22:48:52 <Cale> malim: Yeah, he's been designing it for a while.
22:48:58 <FMota> malim: Yes. The one I'm thinking a lot about but implementing very little.
22:49:22 <Apocalis1> FMota: I can empathize.
22:49:29 <Cale> fax: That would be pretty neat :)
22:49:31 <FMota> :)
22:49:34 <ddarius> Implementing is a good way to keep a check on reality.
22:49:34 <tehgeekmeister> omniscientIdiot: re the issue i had understanding precedence earlier -- if $ were being passed as an argument to another function, wouldn't it be made into a section?  or does it not have to be?
22:49:40 <malim> FMota: what language are you using for the implementation?
22:49:52 <FMota> Ironically, I'm using python.
22:49:53 <Apocalis1> Actually, no. I think about empathizing, but I get very little done of it.
22:49:54 <omniscientIdiot> tehgeekmeister: pretty much
22:49:59 <omniscientIdiot> ($), the un-applied section
22:50:00 <FMota> I'm treating it as a prototype, though.
22:50:06 <Cale> fax: There have been things like simultaneous pickler/depickler combinator libraries
22:50:33 <FMota> (The implementation, and the language, I think).
22:51:21 <Cale> malim: Oh, right, and I just reminded myself that I haven't really told you the whole point of abstracting over monads yet. It's the reason you abstract over anything -- so that you can write code which works in any monad.
22:51:40 <FMota> I wish my emacs used the same syntax highlighting as hpaste. :/
22:51:49 <Cale> malim: Things which work in any monad tend to look a whole lot like control structures.
22:51:50 <omniscientIdiot> @src liftM
22:51:50 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:51:57 <Cale> :t sequence
22:51:58 <omniscientIdiot> @src sequence_
22:51:59 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
22:52:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:52:12 <FMota> I'm not really annoyed enough to figure out how to change it, though.
22:52:28 <Cale> sequence [] = return [];  sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
22:52:32 <fax> moof :[
22:52:40 <fax> What's the thingy for escaping strings?
22:52:50 <Cale> fax: show?
22:52:59 <fax> Ohhhhh yeah
22:53:02 <fax> thank you :D
22:53:05 <Cale> > show "hello"
22:53:07 <lambdabot>  "\"hello\""
22:53:10 * wli does not have the expertise to do a "new language" as he conceives of it, but it wouldn't be very interesting in either of the cases of interest.
22:53:21 <omniscientIdiot> > fix show
22:53:22 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:53:50 <dmwit> ?pl \f m -> m >> f m
22:53:50 <lambdabot> ap (>>)
22:53:55 <wnoise> Are the indices returned from ByteString.findSubstrings guaranteed to be in ascending order?
22:53:55 <wli> case 1 would be Haskell + higher-order module system + compiler intrinsics rolled back to Haskell 1.4
22:54:11 <dons> wnoise: yeah
22:54:37 <wli> case 2 would be heavy modifications of C for numerous forms of hygiene plus a higher-order module system.
22:54:38 <wnoise> dons: Excellent.
22:55:07 <wli> Both would be carried out by modifying existing compilers.
22:55:31 <fax> > insert ", " ["a", "b", "c"]
22:55:33 <lambdabot>  [", ","a","b","c"]
22:55:51 <Syzygy-> >show $ fix show
22:56:12 <omniscientIdiot> > intersperse ", " ["a","b","c"]
22:56:13 <lambdabot>  ["a",", ","b",", ","c"]
22:56:23 <shachaf> Syzygy-: show (fix show) === fix show
22:56:26 <fax> > concat $ intersperse ", " ["a","b","c"]
22:56:28 <lambdabot>  "a, b, c"
22:56:30 <fax> :D
22:56:35 <fax> thank you
22:56:36 <olsner> @quote kripke
22:56:37 <lambdabot> No quotes match. My pet ferret can type better than you!
22:56:55 <Syzygy-> shachaf: I know. Wanted to see it. :)
22:56:57 <fax> @where intersperse
22:56:57 <lambdabot> I know nothing about intersperse.
22:57:06 <shachaf> > show (fix show)
22:57:08 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:57:09 <omniscientIdiot> @index intersperse
22:57:09 <lambdabot> Data.List
22:57:49 <Syzygy-> So why didn't my attempt work?
22:58:13 <shachaf> ">show $ fix show"
22:58:21 <Syzygy-> Again.
22:58:22 <shachaf> If you can see that.
22:58:30 <Syzygy-> Why shouldn't that work?
22:58:34 <Sgeo> Bye all!
22:58:39 <shachaf> Extra character between '>' and ' '.
22:58:50 <Syzygy-> Hmmm.
22:58:56 <Syzygy-> I don't see that extra character...
22:59:00 <Syzygy-> But that would explain it.
22:59:11 <malim> So monads are like opaque portions of code that always return a certain type of value?
22:59:14 <OceanSpray> lol exmude
22:59:20 <OceanSpray> is the dude who wrote it in here?
23:00:17 <dmwit> This is stupid.  I have to import four modules just to write a six-line program.
23:00:37 <fax> dmwit: At least you don't have to write 4 modules just to write a 6 line program :D
23:00:42 <malim> well, you're using a lot of modules =P
23:00:44 <dmwit> True, true. =)
23:00:52 <omniscientIdiot> mailim: a monadic value can be a block of code, or it can be something different entirely, depending on which monad type you use.
23:01:04 <olsner> "I have to import four modules just to write a six-line program that uses four modules"
23:01:21 <fax> It's really a 2 line program then
23:01:24 <dmwit> Yeah, but I import those four modules into every program I write.
23:01:33 <ttfh> dwit: what modules?
23:01:39 <dmwit> fax: Well, start from calling it a ten-line program, then.
23:01:41 <wli> Expressions are monads.
23:01:49 <dmwit> ttfh: Control.Monad, Control.Arrow, Data.Map, Data.Char
23:01:57 <malim> wli: any expression?
23:02:02 <dmwit> I guess Data.Char is reasonable, that's slightly less common.
23:02:02 <wli> malim: No.
23:02:05 <fax> dmwit: >:|
23:02:19 <wli> malim: Expressions with variables whose values are a type parameter of the expression type.
23:03:15 <malim> does the type of a monad need to be explicit then?
23:03:27 <Cale> Yeah, though it can be a parameter
23:03:34 <Cale> :t sequence
23:03:34 <omniscientIdiot> it can be inferred from context
23:03:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:03:47 <Cale> Oh, and yeah, type inference still works :)
23:04:15 <wli> malim: data Expr t = Var t | Apply (Expr t) (Expr t) | ...
23:04:29 <omniscientIdiot> @src Maybe
23:04:29 <lambdabot> data Maybe a = Nothing | Just a
23:04:35 <malim> lol
23:04:38 <omniscientIdiot> @src Maybe (>>=)
23:04:39 <lambdabot> (Just x) >>= k      = k x
23:04:39 <lambdabot> Nothing  >>= _      = Nothing
23:04:40 <wli> malim: Expr (Expr t) maps to Expr t in an obvious way
23:04:44 <omniscientIdiot> @src Maybe return
23:04:45 <lambdabot> return              = Just
23:04:48 <wli> malim: so there is join
23:05:00 <wli> malim: fmap is obvious too
23:05:05 <wli> malim: as is return
23:05:42 <wli> malim: Given those 3 you can write (>>=) and you get a monad
23:06:06 <ddarius> Expr is a free monad.
23:06:08 <omniscientIdiot> x >>= k = join (fmap k x)
23:06:10 <wli> malim: Interestingly you basically get substitution as whatever
23:06:24 <omniscientIdiot> ddarius: what does that mean?
23:09:09 <malim> Cale: are you in the UK?
23:09:10 <ddarius> omniscientIdiot: It's a free model of a signature, every other model would be a homomorphism from it.
23:09:16 <ddarius> Canadia
23:09:28 <brad> i had an unanswered question from cafe still lingering - does anyone know what the goal and status of the haskellnet project were?
23:09:31 <malim> ?
23:09:46 <malim> oh right, Ontario
23:10:21 <malim> What the hell... what are you doing so late at night Cale =o
23:11:22 <Cale> malim: Uh, watching the daily show? :)
23:11:31 <malim> brad: is it so mysterious?
23:11:31 <omniscientIdiot> @localtime malim
23:11:32 <lambdabot> Local time for malim is Fri Sep 28 03:09:41 2007
23:11:57 <brad> malim - well i can figure it out but all there is left is a darcs repo, no docs or anyting
23:12:28 <brad> i would like to play with the IMAP lib, but some code samples would be nice
23:12:47 <brad> i swear, people just dropping off code with no docs, no examples...whats the point?
23:13:09 <brad> harmuph
23:13:22 <malim> brad: sorry, I concentrated on `goal', not `status'
23:13:52 <brad> i think the general silence is my answer - whats there is a darcs repo, thats it
23:14:32 <brad> it would be nice to kill off my last perl script with a haskell equivalent - a poller for IMAP over SSL
23:14:35 <brad> err, TLS
23:15:28 <brad> okay next topic
23:16:00 <brad> does anyone know how the underguts of System.Posix.Signals works? as in, on freebsd does it use kqueue/kevent?
23:16:22 <brad> wondering if this library uses native real-time posix signals bindings
23:23:24 <FMota> night folks
23:23:34 <fax> gn FMota
23:23:43 <FMota> :) ciao
23:25:32 <blarz> ?users
23:25:32 <lambdabot> Maximum users seen in #haskell: 420, currently: 352 (83.8%), active: 18 (5.1%)
23:47:46 <Lycurgus_> blarz: lolcats
23:48:10 <Pseudonym> o noes, i hatez lolcats
23:48:11 <blarz> Lycurgus_: sorry?
23:48:26 <Lycurgus_> 02:24 < blarz> ?users
23:48:36 <Lycurgus_> 02:24 < lambdabot> Maximum users seen in #haskell: 420, currently: 352 (83.8%), active: 18 (5.1%)
23:49:13 <Lycurgus_> a sorry I dound that funny because I thought the current #(users) was 420
23:49:25 <Lycurgus_> not the set limit which isn't so funny
23:49:53 <Lycurgus_> dound <- found
23:50:42 <blarz> I see ;)
23:53:52 * Lycurgus_ shouldn't sleeptype.
23:54:42 <bens> hello, has anybody made some kind of checklist for releasing a haskell library?
23:56:11 <fishkandy> bens, http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
23:56:12 <lambdabot> Title: How to write a Haskell program - HaskellWiki
23:56:24 <tibbe> good morning #haskell
23:56:29 <bens> fishkandy: cool, thanks
23:56:39 <coffeemug> hmm
23:56:47 <coffeemug> good UI design is hard :)
23:59:10 <Lycurgus_> am I right that there's still no Haskell equivalent of ant, asdf, and the like, the Cabal UG seemed to answer that negatively.
