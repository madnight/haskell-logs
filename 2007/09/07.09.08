00:02:23 <Tac-Tics2> why is it so quiet in this room tonight?
00:02:29 <Tac-Tics2> everyone must be getting drunk =-(
00:02:34 <Tac-Tics2> drunk but not programming
00:03:44 <scook0> oh, it fluctuates
00:04:27 <Tac-Tics2> is there a LambdaBot command that makes people want to talk?
00:04:29 <Tac-Tics2> @talk
00:04:29 <lambdabot> Maybe you meant: ask tell
00:04:38 <scook0> @yow
00:04:39 <lambdabot> You mean now I can SHOOT YOU in the back and further BLUR th'
00:04:39 <lambdabot> distinction between FANTASY and REALITY?
00:05:46 <Tac-Tics2> I have an idea
00:06:04 <Tac-Tics2> Naive Set Theory is the best way to think about Mathematics because it's easier than using types!
00:06:40 <Tac-Tics2> that's odd.... it's not working
00:19:24 <Cale> Tac-Tics2: What's not working?
00:19:52 <Cale> Tac-Tics2: I'm a ZFC person myself, like 99% of all mathematicians :)
00:20:24 <Cale> Types are just propositions. Mathematics has those.
00:21:53 <Tac-Tics2> heh
00:22:10 <Tac-Tics2> Cale, you must be the one person in this channel who won't get into a heated argument with me over such a statement I made
00:22:12 <goalieca> cale is incomplete? or is he just inconsisten
00:24:13 <Tac-Tics2> Cale, can you learn us something new about Haskell?
00:28:38 <Tac-Tics2> also, ZFC is not Naive set theory. It's just the closest working thing there is to it
00:30:54 <DRMacIver> Cale: So mathematics has subtyping? :)
00:31:35 <Tac-Tics2> > cycle ()
00:31:37 <lambdabot>  Couldn't match expected type `[a]' against inferred type `()'
00:31:42 <Tac-Tics2> > repeat ()
00:31:44 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
00:31:46 <Tac-Tics2> hehe
00:32:43 <goalieca> > reverse repeat ()
00:32:44 <lambdabot>  Couldn't match expected type `[a]'
00:32:52 <goalieca> > reverse $ repeat ()
00:32:56 <lambdabot> Terminated
00:33:07 <goalieca> heh. not lazy.
00:40:02 <tuomov> can't you have stuff like: class Foo a b where bar :: Baz c b => a -> (c -> d) -> d ?
00:40:15 <tuomov> it seems to take the second 'b' for a new one, 'b1'
00:40:42 <tuomov> and the forall. trick doesn't seem to be supported in classes
00:41:28 <olliej> tuomov: try -fglasgow-exts ?
00:42:16 <tuomov> already on
00:42:30 <sjanssen> there's a flag for scoped type vars IIRC
00:43:09 <tuomov> or maybe I put it in the wrong place
00:43:15 <tuomov> still doesn't seem to work
00:43:44 <sjanssen> tuomov: you don't mention b directly in the type signature of bar
00:43:50 <sjanssen> tuomov: does Baz have a fundep on it?
00:43:56 <tuomov> yes
00:44:05 <tuomov> class Baz c b | c -> b
00:44:19 <jbauman> @pl (\x -> Char.chr $ floor $ 81 + 7.3 * (sin $ 0.25 - fromIntegral x))
00:44:19 <lambdabot> Char . chr . floor . (81 +) . (7 . 3 *) . sin . (-) (0 . 25) . fromIntegral
00:44:36 <jbauman> hmm
00:45:32 <sjanssen> tuomov: but no fundep on Foo?
00:46:33 <tuomov> actually, the dep was missing from the signature..
00:46:48 <tuomov> and the forall needed to be  over c in the signature of bar
00:52:39 <hpaste>  sjanssen pasted "tuomov's program with type families" at http://hpaste.org/2623
00:56:30 <tuomov> actually that's not quite complete: BazT and FooT need to be in a specific type class
00:57:04 <sjanssen> need to instances of a specific type class?
00:57:17 <Cale> DRMacIver: Yes, certainly.
00:57:18 <sjanssen> s/need to/need to be/
00:57:26 <tuomov> yes
00:57:33 <Cale> Tac-Tics2: hmm
00:57:52 <Tac-Tics2> hmm?
00:57:52 <tuomov> it's a poor man's dependent-typing hack (once again)
00:58:04 <Cale> something new about Haskell, eh?
00:58:09 <DRMacIver> Cale: Hm. I suppose mathematics has dependent types, so subtyping comes for free. :)
00:58:11 <Tac-Tics2> yessir
00:58:14 <tuomov> with the last parameter of both Foo and Baz encoding such dependencies
01:15:47 <Cheery> I'd need a 16 symbols which are simple to draw with a pen and none of the symbols could be flipped to another
01:16:22 <Cheery> just wondering how would I reach something like that?
01:21:00 <luqui> Cheery, explain a bit more
01:21:34 <luqui> oh, I understand, you're trying to construct such a set
01:21:53 <Cheery> yes
01:22:07 <luqui> well, the pentominos give you twelve
01:22:54 <luqui> pick 16 heptominos...
01:23:12 <luqui> though they might not meet your definition of "simple"
01:23:50 <luqui> or you could do oriented 4-bit numbers... that is to say
01:23:55 <luqui> draw a line with a curve on one end
01:24:30 <luqui> and then represent 0 as (----
01:24:34 <luqui> 1 as (---|
01:24:37 <luqui> 2 as (--|-
01:24:38 <luqui> etc.
01:25:24 <luqui> where the | represent crosses in the line
01:25:49 <Cheery> hmm, need to try that
01:26:35 <Cheery> but how would you represent the amount of '0's at the line?
01:26:50 <luqui> spacing?
01:27:03 <luqui> or maybe you could use vertical and diagonal lines for 1 and 0 respectively
01:27:20 <luqui> *lines -> crosses
01:27:50 <luqui> hmm, or a slightly prettier version
01:28:01 <sjanssen> > [1 .. 16] -- how about this?
01:28:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
01:28:07 <luqui> hahaha
01:28:18 <sjanssen> with an underline to indicate the "bottom"
01:28:29 <luqui> good call
01:28:30 <luqui> :-)
01:30:16 <Cheery> luqui: well, bend the 'line' to C-curve and it seems to do well
01:32:58 <Cheery> thus it has the exact function I wanted. :)
01:33:40 <roconnor> @bab en nl cancel
01:33:42 <lambdabot>   annuleer
01:33:50 <roconnor> @bab en nl canceled
01:33:51 <lambdabot>   geannuleerd
01:33:56 <roconnor> oh right
01:34:03 <roconnor> duh
01:35:43 <roconnor> @bab nl en Betaalvoorkeur wijzigen
01:35:44 <lambdabot>   Betaalvoorkeur modify
01:35:54 <roconnor> oooh modify
01:36:02 <Cheery> except the final symbols are relatively complex
01:38:58 <Cheery> and at the end they are also ambiguous
02:05:28 <Tac-Tics2> what is a coproduct type?
02:09:51 <Cheery> 'don't kill the messenger' has gotten really hard-to-obey rule after MSN
02:10:39 <Tac-Tics2> A coproduct is probably something like type T = T1 A | T2 B | ... | Tn Z isn't it?
02:11:32 <Cheery> since you wouldn't just like to kill that impostor scumbag, you'd like to cut it into bits and send every bit to different direction in void space
02:27:36 <Tac-Tics2> There are no good explanations of the Hindley Milner algorithm anywhere on the interwub
02:27:45 <Tac-Tics2> grr
02:29:38 <cinimod> Tac-Tics2: there's typing haskell in haskell and there's a tutorial by Simon PJ - I'll look up the reference but it'll take me a few mins
02:35:03 <gpi5> What's the difference between Num and Integral ?
02:35:24 <cinimod> http://research.microsoft.com/~simonpj/papers/higher-rank/
02:35:25 <lambdabot> Title: Simon Peyton Jones: papers
02:36:26 <cinimod> Tac-Tics2: I think that's the best - you get the type theory as well as the implementation although THIH is also very good
02:37:06 <scook0> gpi5: arbitrary Nums don't need to be convertible to Integer
02:37:14 <scook0> but Integrals do
02:37:34 <scook0> (e.g. Double is a Num, but not an Integral)
02:37:55 <cinimod> gpi5: :i Num and :i Integral at the ghci command line will tell you
02:38:02 <cinimod> > :i Num
02:38:03 <lambdabot>   parse error on input `:'
02:38:15 <cinimod> >:i Num
02:38:33 <cinimod> Not sure how to get lambdabot to do this though :-(
02:39:41 <gpi5> Ok, thanks. Btw, the output of :i commands is chinese to me..
02:40:34 <scook0> looks pretty straightforward to me, assuming you're familiar with typeclasses
02:41:15 <quicksilver> the classes are reasonably wel documented in http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
02:41:17 <lambdabot> http://tinyurl.com/ovjef
02:41:20 <cinimod> gpi5: I think Integral is mean to be integral domain - I once made polynomials into an instance and then you get gcd for polynomials for free
02:42:52 <gpi5> Is there a 'if' function in haskell (should be Bool -> a -> a -> a)?
02:43:01 <quicksilver> also in http://www.haskell.org/onlinereport/basic.html
02:43:02 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
02:43:08 <quicksilver> gpi5: no
02:43:18 <quicksilver> gpi5: if is a keyword
02:43:54 <scook0> but you can easily define your own if', of course
02:44:00 <ricky_clarkson> @djinn Bool -> a -> a -> a
02:44:01 <lambdabot> f a b c =
02:44:01 <lambdabot>     case a of
02:44:01 <lambdabot>     False -> c
02:44:01 <lambdabot>     True -> b
02:44:15 <quicksilver> :t let if' c t e = if c then t else e in if'
02:44:17 <lambdabot> forall t. Bool -> t -> t -> t
02:44:30 <gpi5> What's the preferred way ?
02:44:48 <gpi5> There is no predefined function to do that?
02:45:09 <quicksilver> normally you just use if :)
02:45:13 <ricky_clarkson> You already asked that.
02:45:17 <quicksilver> or, quite often, guards instead of ifs
02:47:28 <shiversc> please help me http://www.pennergame.de/ref.php?refid=9290332
02:47:30 <lambdabot> Title: Pennergame
03:01:45 <Saul__> Maybe a stupid question, but is Either a monad?
03:02:10 <xerox> ?instances Monad
03:02:11 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:03:21 <Saul__> ok thanks
03:03:34 <xerox> :)
03:03:51 <Saul__> But isn't it supposed to be Either a b instead of Either e?
03:04:12 <xerox> Monads must have kind * -> *
03:04:35 <xerox> Either has kind * -> * -> *, so it works only if you fix one parameter.
03:05:12 <xerox> The left one comes first.
03:05:39 <Saul__> I'm not sure I understand that completely, but thanks
03:06:43 <xerox> The kind is the type of a type. In the declaration of monad there is an explicit kind annotation, class Monad (m :: * -> *) where ...
03:07:21 <xerox> That is, m is a type constructor of one parameter, a type, *, that returns a type, *.
03:07:54 <Saul__> ok
03:08:24 <xerox> Either is a type constructor that takes a type, and returns a type constructor that takes a type, and returns a type.
03:09:03 <xerox> Just like partial application at value level, Either a, for any fixed a, is of kind * -> *, the right one for a Monad.
03:09:34 <iguana_> what's the "((->) r)" doing in the list?
03:09:47 <xerox> ?unmtl Reader r a
03:09:47 <lambdabot> r -> a
03:10:01 <iguana_> ?help unmtl
03:10:01 <lambdabot> unroll mtl monads
03:10:09 <xerox> It is the real name of the Reader monad.
03:10:13 <iguana_> ah
03:10:16 <xerox> Well, the real shape.
03:10:22 <Saul__> ok I think I sort of get it on an abstract level, but is there any difference in how you use it compared to Maybe, List or State monads?
03:10:46 <iguana_> as I understand it it is very similar to the Maybe monad
03:10:47 <xerox> Saul__: it has its own bind and return, so no, the interface is the same.
03:10:58 <iguana_> except that failure can be assigned a value
03:11:16 <xerox> Right, and it also comes with its own flavoured-monad typeclass.
03:11:21 <xerox> E.g. State comes with this one:
03:11:24 <xerox> ?src MonadState
03:11:24 <lambdabot> Source not found. My mind is going. I can feel it.
03:11:43 <xerox> Aw. Well, the one that gives you 'get', 'put', and 'modify'.
03:11:51 <xerox> ?src MonadError
03:11:51 <lambdabot> class (Monad m) => MonadError e m | m -> e where
03:11:51 <lambdabot>     throwError :: e -> m a
03:11:51 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
03:12:02 <xerox> The Either one gives you instances of this one instead.
03:12:47 <oerjan> could have defined an instance MonadError () Maybe ...
03:13:03 <Saul__> these are just synonyms for fail and bind?
03:13:14 <oerjan> but i don't think it has been made
03:13:28 <xerox> Nope. They are features around the error monad, much like get and set are for the State one.
03:14:12 <iguana_> but what does throwError that fail doesn't do?
03:14:39 <quicksilver> have a parameter of type e
03:14:42 <quicksilver> rather than string
03:14:47 <quicksilver> that's the only different
03:14:51 <quicksilver> s/t/ce/
03:15:04 <quicksilver> morally, throwError *is* fail
03:15:10 <iguana_> okay
03:15:13 <quicksilver> but then again, morally, fail shouldn't exist :)
03:15:23 <quicksilver> fail is a hack, throwError is a bit elegant
03:15:26 <wli> quicksilver: I was about to say.
03:15:33 <quicksilver> however, throwError can't be haskell98
03:15:41 <quicksilver> because if the multi-parameter typeclass there
03:15:54 <oerjan> i wonder if throwError and catchError are sort of return and bind for a "dual" view of the monad, i recall something similar on haskell-cafe
03:16:13 <oerjan> like if you switched Left and Right
03:16:19 <quicksilver> that's certainly true for the either instance, yes
03:16:49 <quicksilver> whether it's true for all imaginable MonadErrors, I couldn't say :)
03:17:00 <iguana_> are there other predefined MonadErrors?
03:17:18 <quicksilver> @instances MonadError
03:17:20 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
03:17:39 <quicksilver> IO is the only real one
03:17:43 <quicksilver> (real other instance)
03:17:56 <quicksilver> the others are just showing how to lift MonadError through monad transformers
03:18:08 <iguana_> @src RWST
03:18:09 <lambdabot> Source not found. That's something I cannot allow to happen.
03:18:13 <Saul__> Where is Either defined as a Monad?
03:18:50 <Saul__> No instance for (Monad (Either a))
03:18:51 <Saul__>       arising from use of `>>=' at <interactive>:1:0-8
03:18:51 <Saul__>     Possible fix: add an instance declaration for (Monad (Either a))
03:18:51 <quicksilver> Control.Monad.Error I believe
03:18:58 <wli> Not Either, but Error e => Either e
03:27:21 <LeCamarade> Okay, is deriving (Read, Show) good enough for me to use in a persistence model?
03:28:32 <LeCamarade> I mean performance-wise.
03:32:48 <Heffalump> I suspect not, Read isn't very efficient
03:34:08 <quicksilver> well that would depend entirely how much you use it :)
03:34:18 <quicksilver> but no, it's not desperately fast
03:39:22 <LeCamarade> Hmm ... okay.
03:40:29 <EvilTerran> it also wouldn't be particularly awesome wrt space usage on disk
03:40:52 <EvilTerran> you could likely build something better on top of SYB
03:41:25 <Heffalump> also, you need to be sure that all contained types either also use deriving (Read, Show), or definitely satisfy read . show = id
03:42:25 <EvilTerran> might be good to work in [Word8] rather than [Char], too, for portability
03:43:48 <poh> I am currently working on project euler in haskell and just got a solution for the collatz problem.  my issue is that I want to store all values that I previously computed, so I don't need to recalculate it each time.
03:44:06 <poh> is there a way to tell the compiler to do that, or would I need to code a lookup explicitly
03:44:08 <poh> ?
03:45:06 <oerjan> i think you need some lookup
03:45:21 <Heffalump> a "solution"?
03:45:27 <Heffalump> oh, in the sense of computing it?
03:46:08 <EvilTerran> Heffalump, one of the PE problems is "Find the longest sequence using a starting number under one million."
03:46:20 <Heffalump> ah.
03:48:42 <glguy> poh, stick with a lazily evalutated array to do thet memoization for you
03:49:28 <Heffalump> glguy: what do you do if you don't know the upper bound of the array?
03:49:46 <oerjan> Heffalump: tries
03:49:51 <glguy> Heffalump, in this case, you just decide how much to memoize
03:50:08 <glguy> This problem has been done a few times in channel before
03:51:03 <Heffalump> glguy: memoizing an arbitrary subset sounds a bit rubbish
03:51:17 <glguy> Umm... ok
03:51:23 <Heffalump> well, IMO
03:51:42 <Heffalump> oerjan: would that be starting with the least significant figure?
03:51:49 <glguy> So the point of the problem is to solve exactly what the problem says in less than 1 minute, which is what that solution accomplishes
03:51:50 <poh> Heffalump, you would memoize a subset that you know is computed frequently
03:52:07 <Heffalump> glguy/poh: fair enough, I guess.
03:52:18 <Heffalump> As a general solution to memoization it seems a bit ugly.
03:53:27 <wli> Where does it say 1 minute, anyway?
03:53:31 <oerjan> Heffalump: i suppose that would be most efficient if you used divMod to compute the key.
03:54:01 <glguy> wli, its a general standard for the site, "Euler" states that tha tis the expectation somewhere
03:55:24 <oerjan> otoh if you can look at the binary representation directly, either direction should be equally good.
03:55:41 <oerjan> (but in Haskell you cannot easily)
03:56:38 <glguy> I've written my program but should it take days to get to the answer?
03:56:38 <glguy>     Absolutely not! Each problem has been designed according to a "one-minute rule", which means that although it may take several hours to design a successful algorithm with more difficult problems, an efficient implementation will allow a solution to be obtained on a modestly powered computer in less than one minute.
04:06:08 <EvilTerran> @src maximum
04:06:08 <lambdabot> maximum [] = undefined
04:06:08 <lambdabot> maximum xs = foldl1 max xs
04:06:26 <EvilTerran> @src maximum'
04:06:26 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:06:28 <EvilTerran> >:[
04:12:35 <LeCamarade> ?uptime
04:12:35 <lambdabot> uptime: 18h 48m 58s, longest uptime: 1m 10d 23h 44m 29s
04:12:47 <oerjan> @users
04:12:48 <lambdabot> Maximum users seen in #haskell: 402, currently: 371 (92.3%), active: 11 (3.0%)
04:13:29 <cizra> lambdabot: add me
04:13:30 <cizra> @users
04:13:31 <lambdabot> Maximum users seen in #haskell: 402, currently: 371 (92.3%), active: 12 (3.2%)
04:13:33 <cizra> \o/
04:13:44 <Botje> oh noes, we're getting too popular :)
04:14:00 <opqdonut> noes indeed
04:14:51 <opqdonut> why is that first case of maximum even defined that way?
04:15:04 <oerjan> better error message
04:15:09 <opqdonut> as foldl1 would throw an exception anyways
04:15:26 <opqdonut> foldl1's error is better than undefined imo :)
04:15:28 <oerjan> but then you would only know that foldl1 failed, not maximum
04:15:51 <oerjan> isn't undefined special?
04:15:53 <oerjan> maybe not
04:16:31 <oerjan> > let f x = undefined in f ()
04:16:33 <lambdabot>  Undefined
04:16:48 <oerjan> lambdabot is not particularly helpful there
04:18:02 <cizra> > goto hell
04:18:02 <lambdabot>   Not in scope: `hell'
04:18:24 <cizra> > hell: in goto hell
04:18:24 <lambdabot>  Parse error
04:18:25 * luqui tries to picture a "goto" in haskell
04:18:27 <cizra> hmm..
04:20:25 <scook0> what about a tail call?
04:20:38 <cizra> @src goto
04:20:39 <lambdabot> Source not found. My pet ferret can type better than you!
04:20:41 * EvilTerran blinks
04:21:42 <EvilTerran> that's bizarre. one of the PE problems i hadn't done yet was so straightforward, even \bot can solve it naively
04:25:01 <Cheery> cizra: goto imperative; imperative: goto hell
04:25:31 <oerjan> > raise
04:25:33 <lambdabot>   Not in scope: `raise'
04:25:48 <cizra> Hey, Cheery
04:25:51 <oerjan> apparently you cannot raise hell either
04:26:03 <cizra> > freeze hell
04:26:03 <lambdabot>   Not in scope: `hell'
04:26:04 <mr_tenor> my code's getting shorter and shorter due to list combinators but this makes annoying special cases and end cases stand out like sore thumbs :(
04:26:08 <cizra> > freeze
04:26:09 <lambdabot>   Not in scope: `freeze'
04:27:03 <mr_tenor> i guess that's good, but triplling a function's line count for trivial bits and bobs sux
04:27:45 <cizra> Boobs are never trivial
04:27:55 <Cheery> what is the good european role model for 'dad' or 'mother'?
04:28:31 * oerjan thinks this channel is getting more bizarre than usual
04:28:38 <mr_tenor> cizra: some are, and trivial ones can be nice :P
04:29:12 <mr_tenor> oerjan: more bizarre than category theory?
04:29:34 <oerjan> hm, good point
04:30:01 <oerjan> well then, what is the _categorical_ model for 'dad' or 'mother'?
04:31:29 <ricky_clarkson> I don't think we have role models.  We have roles, and models, but the two don't coincide.
04:31:45 <Cheery> it depends about the culture and the culture is affected by region and religion and state where one lives in
04:32:09 <mr_tenor> should this be in #haskell-blah?
04:32:17 <Cheery> probably, lets continue there
04:33:53 <Cheery> thought that's a thing I came to wonder when I read the term
04:39:44 <mr_tenor> is it acceptable to change code examples and their explanatory paragraphs between a paper being accepted and a final submission?
04:41:42 <wli> If you can't change that, what can you change?
04:42:08 <mr_tenor> idunno. clarify wordings, insert experimental data...
04:43:11 <mr_tenor> here i've got "this 20 line example is imho much more enlightening than the one i'mrattling on about currently", but switching one example for another means redoing maybe half a page or so of text :/
04:45:12 <roconnor> mr_tenor: is the paper refereed?
04:48:59 <mr_tenor> roconnor: DEST category E1 conference
04:49:43 <roconnor> does that mean it is refereed?
04:49:49 <mr_tenor> yeah http://www.jcu.edu.au/office/research_office/biblio/pubcat1.html
04:49:49 <lambdabot> Title: Research Publication Data Collection: Publication Categories
04:50:34 <mr_tenor> i've never seen written down what you're allowed to change between initial and final submission :/
04:50:48 <roconnor> mr_tenor: I wouldn't make such signifigant changes without being rerefered, and pressumably there isn't time for it. :(
04:51:55 <mr_tenor> sounds like good advice. i could put the better example in my slides, but i'll have the mediocre one published with my name on it :(
04:51:59 <roconnor> mr_tenor: I would try to make a judgement based on preserving the integrity of referee process.
04:52:11 <mr_tenor> yeah, that's why i'm worried in the first place ;)
04:52:25 <scook0> how about inserting the url of a page containing the new example?
04:53:06 <scook0> (that way the refered paper gets published, but anyone reading it could use the new explanation instead)
04:53:36 <scook0> though there might be practical difficulties ...
04:53:42 <mr_tenor> i'd rather it be self contained
04:53:48 <mr_tenor> yeah, urlscome and go
04:53:53 <roconnor> similar to scook0's idea, I would pubished the review paper, and put the new paper on the web
04:54:00 <roconnor> everyone reads the web versions anyways ;)
04:54:09 <mr_tenor> heh
04:54:20 <mr_tenor> but IEEE ownzors submitted papers
04:54:44 <roconnor> mr_tenor: I strongly recommend never assigning copyright to publishers.
04:54:53 <roconnor> Or rather.
04:55:10 <roconnor> I always publish my own works under a CC licence
04:55:20 <roconnor> and then I transfer the copyrigh to the publisher
04:55:26 <mr_tenor> yeah, well, if i had the option i would
04:55:29 <pejo> djb recommends boycotting IEEE for exactly that very reason.
04:55:30 <roconnor> but because there is a version with a CC licence
04:55:38 <roconnor> I can copy my own work
04:55:40 <scook0> oh, that's a clever hack
04:56:02 <roconnor> I also write a notice that the work was previously pubished under a CC licence in my copyright transfer form
04:56:04 <scook0> though if the publisher demands the work be previously unpublished ...
04:56:13 <roconnor> just to let them know what's up
04:56:18 <pejo> http://cr.yp.to/writing/ieee.html
04:56:29 <mr_tenor> if you're no longer the copyright holder, then aren't you powerless to dictate licencing?
04:56:49 <roconnor> mr_tenor: I was the copyright owner at the time I wrote the CC licenced document.
04:58:01 <roconnor> scook0: at TPHOLs, I noticed the coference required that the papers not be previous published.  I asked if what I was doing was okay (because the previous publication wasn't peer reviewed).  The editor was fine with accepting, and said the issues with the publisher would be between me and the publisher.
04:58:08 <mr_tenor> but by default the _current_copyright holder has exclusive rightsto copy the thing, and any other copying is an exception dictated by them, isn't it?
04:58:51 <roconnor> mr_tenor: true.  So in my copyright noticed I said I would transfer my copyright to them to the extent possible given that an existing copy has already been distributed under a CC licence.
04:59:08 <roconnor> mr_tenor: it involved a moderate ammount of crossing out and writting stuff it.
04:59:17 <mr_tenor> IANAL, so i give up at this point ;)
04:59:22 <roconnor> mr_tenor: not that they read these forms ;)
04:59:32 <scook0> ah, the seedy underbelly of academic publishing
04:59:46 <mr_tenor> i really hate IEEE and ACM restricting access to papers
04:59:59 <mr_tenor> i mean, what's the point of being a scientist and publishing :P
05:00:18 <EvilTerran> going back to the original problem of coming up with a better example, could you perhaps add it as an appendix?
05:00:20 <roconnor> mr_tenor: well, I don't know if my trick will work.  But I figured it is useful to lay some groundwork for my defence.
05:00:35 <mr_tenor> hrm... what if the work is in public domain
05:00:51 <mr_tenor> but then could it be "previously unpublished"? hmm
05:01:16 <mr_tenor> roconnor: good luck with that ;) it seems like some authors just put up their papers on their websites regardless
05:01:19 <roconnor> mr_tenor: I usually put another copy of my work in the public domain; however some people suggest putting things in the public domain is impossible; hence the use of a CC lienced copy as well.
05:01:22 <pejo> mr_tenor, read the stuff at the link, it's exactly stuff about IEEE and them refusing to publish stuff in the public domain.
05:01:25 <mr_tenor> EvilTerran: strict page limit
05:01:35 <EvilTerran> "blah blah blah <insert bad example here> <sup>1</sup> blah blah blah" "1. see Appendix A for a better example"
05:01:38 <EvilTerran> oh. bah.
05:01:45 <roconnor> mr_tenor: It's not so hard to cross out and modify these copyright transfer forms.
05:01:59 <mr_tenor> roconnor: it is if they're webpage forms :D
05:03:20 <roconnor> mr_tenor: are you serious?
05:03:41 <scook0> doesn't the inability of one party to negotiate terms cause legal problems with contracts?
05:04:11 <roconnor> I've always been asked to print out transfer forms and mail/fax them in.
05:04:18 <scook0> (assuming the act is a contract, of course)
05:04:22 <wli> scook0: That's the de facto case in most contracts anyway (whichever lacks the "upper hand," so to speak).
05:04:22 <roconnor> but I've never sumbitted to the IEEE.
05:04:29 <mr_tenor> http://www.ieeeconfpublishing.org/cpir/AuthorKit.asp?Community=CPS&Facility=CPS_Dec&ERoom=DICTA+2007
05:04:36 <scook0> wli: true
05:04:56 <cizra> OK, so I got a programming assignment about generating Fibonacci numbers. I guess I've done MUCH more than required (remember, memoization, stuff, learning Haskell in the first place). However, the task requires writing an iterative Fibonacci as well, Y'know, [0, 1, 0+1, 1+1, 2+1, ...]. How could I do that?
05:05:05 <mr_tenor> ah, maybe they gie you a pdf to print and fax back in
05:05:08 <cizra> I know it's possible somehow to hack that iteration into recursion, but how?
05:05:32 <mr_tenor> tail recurse?
05:05:42 <EvilTerran> state monad?
05:05:49 <EvilTerran> :D
05:05:50 <cizra> monads give me the creeps.
05:05:56 <luqui> cizra, "iterate"
05:05:58 <luqui> :t iterate
05:05:58 <cizra> All unfamiliar is scary.
05:06:00 <wli> Then you're in the interesting situation of assuming they honor your modifications of the boilerplate.
05:06:00 <lambdabot> forall a. (a -> a) -> a -> [a]
05:06:01 <roconnor> mr_tenor: I'm lookin'
05:06:39 <EvilTerran> :t until
05:06:40 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
05:06:50 <scook0> I think "iterate" is insufficient for fib, unless you use tupling
05:06:59 <luqui> of course you have to use tupling
05:07:06 <mr_tenor> does fodling or accumulating count as iteration?
05:07:13 <cizra> dunno
05:07:42 <scook0> if the task is specced without regard for Haskell/functional, "iterative" is unlikely to be well-defined
05:07:43 <luqui> cizra, I think it would.  as long as you have the computation (a, b) -> (b, a + b) in there somewhere
05:07:46 <EvilTerran> > (\n -> until (\(i,p,pp)->i == n) (\(i,p,pp)->(i+1,pp,p+pp)) (0,0,1)) 10
05:07:48 <lambdabot>  (10,55,89)
05:07:52 <luqui> it ought to be considered an iterative method
05:08:13 <cizra> Actually, I bet my pants that my teacher hasn't thought of the possibility of someone choosing Haskell to do the task.
05:08:21 <cizra> Hafta try Lisp next (=
05:08:34 <luqui> cizra, after haskell, lisp will be cake
05:08:43 <mr_tenor> yeah,les syntax ;)
05:08:44 <cizra> Oh? I thought it's supposed to be the other way around.
05:08:48 <scook0> doing the iterative version in lisp would be better from a CYA perspective
05:08:49 <EvilTerran> either
05:08:59 <EvilTerran> anything FP is easier once you've got your head round it
05:09:02 <roconnor> mr_tenor: wow, it is all online!
05:09:08 <luqui> > iterate (\(a,b) -> (b,a+b)) (0,1)
05:09:09 <lambdabot>  [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89),...
05:09:15 <cizra> scook0: CYA?
05:09:19 <roconnor> mr_tenor: maybe there is some sort of alternative process.
05:09:20 <scook0> cover your ass
05:09:36 <scook0> > map snd $ iterate (\(a,b) -> (b,a+b)) (0,1)
05:09:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:09:39 <EvilTerran> but i suspect i'd rapidly get fed up with the lack of typesystem and enforced purity in lisp ;]
05:09:49 <mr_tenor> roconnor: :D
05:09:58 <luqui> it's nice when we solve your assignments for you out of curiosity, isn't it cizra  :-)
05:10:10 <cizra> oh, very much.
05:10:13 <cizra> I still learn, though.
05:10:17 <scook0> cizra: i.e. ensuring your assessor will actually be convinced you've done the assignment properly
05:10:50 <cizra> scook0: Understood. However, the memoizing O(log n) algo should be enough to cover me for another 2 assignments (=
05:10:55 <mr_tenor> i always asked my students "why did you do it this way?"
05:11:04 <mr_tenor> so many could not answer at all
05:11:24 <luqui> mr_tenor, uh, there's another way?
05:11:25 <roconnor> mr_tenor: Well, my ``method'' may still work in this case.  You just lack the ability to notify them that a prior licence agreement on the work exists, so others maybe have the right to copy the work without permission by the IEEE.
05:11:49 <cizra> > take 10 (iterate (2*) 1)
05:11:50 <araujo> morning
05:11:51 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
05:11:52 <mr_tenor> the best ones of course would start rattling on about their clever (or misguided) optimisations, of course ;)
05:12:02 <cizra> hmm.. take 10 gets the head of the list, right?
05:12:12 <cizra> iterate (2*) 1
05:12:15 <cizra> > iterate (2*) 1
05:12:17 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
05:12:44 <scook0> take is usually unnecessary when dealing with \bot
05:12:57 <scook0> but it helps a lot in ghci
05:13:00 <cizra> It's an example from http://www.zvon.org/other/haskell/Outputprelude/iterate_f.html
05:13:01 <lambdabot> Title: Haskell : iterate
05:13:04 <pejo> roconnor, in return IEEE will threaten to not publish the work though. Or atleast that was what happened to the student djb spoke to.
05:13:41 <cizra> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
05:13:46 <cizra> This IS basically the iterating algorithm
05:13:57 <cizra> using recursion for implementation, however.
05:14:08 <cizra> > fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
05:14:08 <lambdabot>  Parse error
05:14:08 <roconnor> pejo: well, then I guess you have a choice: assign your copyright to IEEE, or don't publish.
05:14:13 <cizra> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
05:14:13 <lambdabot>  Parse error
05:14:13 <roconnor> I would chose the latter
05:14:21 * cizra grumbles
05:14:28 <EvilTerran> or publish under someone else
05:14:33 <EvilTerran> @let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
05:14:38 <roconnor> pejo: who is djb?
05:14:40 <lambdabot> Defined.
05:14:46 <EvilTerran> > drop 1000 fibs
05:14:50 <cizra> > fibs !! 114
05:14:51 <lambdabot>  [703303677114228158218352548771835497701812698363587327426049050871545371181...
05:14:53 <lambdabot>  483162952612010163284885
05:15:09 <mr_tenor> cizra: mapAccum maybe?
05:15:19 <cizra> mr_tenor: ??
05:15:24 <EvilTerran> see if you can convince whoever set the assignment that that zipWith version is iterative
05:15:33 <mr_tenor> cizra: http://cvs.haskell.org/Hugs/pages/libraries/base/Data-List.html
05:15:55 <mr_tenor> gah, that's notthe ghc page
05:15:56 <pejo> roconnor, dj bernstein. qmail/djdns/... author. Professor in math too.
05:16:03 <cizra> EvilTerran: The spirit is the same algo.
05:16:08 <EvilTerran> the path taken by the data is actually rather like one in an imperative language
05:16:24 * roconnor thinks `iterate' should appear in an iterative implementation.
05:16:30 <mr_tenor> heh
05:16:30 <EvilTerran> when working out each cell, it's got the previous two cells right there and no other information
05:16:52 <EvilTerran> heh, roconnor. i find (until) lends itself well to iterative-style algorithms, too
05:17:21 <mr_tenor> yeah,zipWith is pretty much all there is to the solution description i reckon
05:17:29 <EvilTerran> especially with a record type with all your variables in it
05:18:33 <roconnor> pejo: okay.  springer has never threated not to publish my works, but it certianly is a reasonable response to modifying the terms of agreement.
05:18:49 <wli> Is it?
05:18:51 <roconnor> I would be fine with them not publishing it.
05:19:07 <roconnor> Presumably I would still go to the conference.
05:19:21 <roconnor> my work just wouldn't appear in the proceedings.
05:19:22 <wli> They don't need to be reasonable; they have the upper hand by a very long longshot.
05:19:29 <roconnor> I would put my work on the web
05:19:48 <roconnor> and I would end up with more references than if I had agreed to their terms and their publication.
05:19:49 <EvilTerran> \n -> until (\s-> index s == n) (\s-> s{prevprev = prev s, prev = prevprev s + prev s, index = index s + 1}) (S{prevprev = 0, prev = 1, index = 0})
05:20:13 * EvilTerran *thinks* that works, anyway.
05:20:22 <pejo> roconnor, but would it count for your case about tenure?
05:20:55 <EvilTerran> isn't there someone else you can publish under?
05:20:55 <wli> There is an oligopoly on these sorts of things.
05:21:09 <roconnor> pejo: nope
05:21:09 <wli> You'll not get anything published that way, apart from on the web.
05:21:31 <roconnor> wli: I already have 2 publications.
05:21:59 <wli> roconnor: With whom were you able to negotiate such non-boilerplate copyright affairs?
05:22:27 <roconnor> wli: springer, and elsiver(?).  I just modified their forms and sent it in.
05:22:32 <pejo> wli, well, lots of places have better deals than IEEE. JFP for example.
05:22:36 <roconnor> not not elsiver
05:22:46 <roconnor> cambridge something something
05:22:53 <EvilTerran> university press?
05:23:00 <roconnor> anyhow, given that they published the works, I assume they accepted my modifications.
05:23:25 * roconnor checks his webpage
05:23:35 <Pastorn_> @type intersperse
05:23:39 * EvilTerran is looking at the AMS's setup: http://www.ams.org/authors/ctp.html
05:23:43 <wli> roconnor: Accept or ignore? Hmm.
05:23:43 <lambdabot> Title: Consent to Publish and Copyright Agreement
05:23:45 <lambdabot> forall a. a -> [a] -> [a]
05:23:48 <cizra> How can I append an element into the beginning of a list? Or is this impossible with Haskell's "every variable is a constant" philosophy?
05:23:48 <roconnor> wli:  I
05:23:57 <roconnor> wli: I'm sure that didn't read my form.
05:24:01 <EvilTerran> "an author is also encouraged to transfer copyright of the work to the AMS. In doing so, the author retains the right to use the work for his or her own purposes but simplifies the permissions process by enabling the AMS to administer it."
05:24:04 <roconnor> wli: sounds like their problem.
05:24:08 <Pastorn_> > intersperse ',' "duehiduaued euhtod te hdtaduhten"
05:24:08 <mr_tenor> cizra: like 1:[2,3,4] ?
05:24:10 <EvilTerran> "encouraged", not "required"
05:24:13 <lambdabot>  "d,u,e,h,i,d,u,a,u,e,d, ,e,u,h,t,o,d, ,t,e, ,h,d,t,a,d,u,h,t,e,n"
05:24:15 <cizra> mr_tenor: yes
05:24:37 <mr_tenor> a list is defined as an element consed onto a list of elements ;)
05:24:39 <cizra> mr_tenor: however, I have the list fibs = [1, 1, 2, 3, 5, ...] and I want it to become [0, 1, 1, ...]
05:24:53 <roconnor> Yep, Cambridge University Press
05:24:57 <mr_tenor> foobar = 0:fibs ?
05:24:58 <cizra> Pastorn_: Dvorak \o/
05:25:08 <cizra> mr_tenor: Yeah, but I can't do fibs = 0:fibs
05:25:09 <pejo> wli/roconnor/others: http://www.sherpa.ac.uk/romeo.php
05:25:09 <EvilTerran> and they've got a "copyright bit is void for gov't employees" at the bottom of the contract
05:25:11 <lambdabot> Title: SHERPA/RoMEO - Publisher copyright policies & self-archiving
05:25:24 <EvilTerran> > let fibs = 0:fibs in fibs -- probably not what you want
05:25:24 <Pastorn_> cizra: fuck that's sharp
05:25:25 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:25:29 <igel> > let fibs = 0 : 1 : (zipWith (+) fibs (drop 1 fibs)) in fibs
05:25:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:25:39 <igel> cizra: ^^
05:25:41 <mr_tenor> igel: heh
05:26:03 <cizra> Pastorn_: What's so sharp about it?
05:26:04 <EvilTerran> drop 1 = tail except for the [] case...
05:26:28 <Pastorn_> well, that you, from my random keyboard bashing, can note that i use dvorak
05:26:40 <cizra> igel: Coolie cool. This is slower, though. I'll just ignore the problem.
05:27:01 <roconnor> EvilTerran, wli: I do assign my copyright to them, but notify them of existing CC licences, so that they know that effictively being the copyright holder isn't terribly useful.
05:27:06 <cizra> Pastorn_: Hey, it's absolutely shiny clear. No cleverness needed.
05:27:28 <EvilTerran> roconnor, i imagine universities will tend to be more reasonable about these things
05:27:31 <mr_tenor> 0 isn't really part of the fibonacci numbers, though, is it?
05:27:32 <Pastorn_> > (\xs -> '[' : xs ++ "]") . intersperse ',' "duehiduaued euhtod te hdtaduhten"
05:27:33 <lambdabot>  Couldn't match expected type `a -> [Char]'
05:27:40 <roconnor> My works becoms dual licenced.  One full copyright from the publisher, one CC on the web.
05:27:43 <mr_tenor> so calling that list "fibs" isn't quite right ;)
05:27:47 <Pastorn_> > (\xs -> "[" ++ xs ++ "]") . intersperse ',' "duehiduaued euhtod te hdtaduhten"
05:27:48 <lambdabot>  Couldn't match expected type `a -> [Char]'
05:28:05 <roconnor> mr_tenor: 0 is the 0th fib number.
05:28:14 <Pastorn_> @type (\xs -> "[" ++ xs ++ "]")
05:28:16 <lambdabot> [Char] -> [Char]
05:28:27 <EvilTerran> mr_tenor, i think 0 is as much a part of the fibonacci numbers as it is part of the natural numbers ;]
05:28:33 <EvilTerran> > (\xs -> '[' : xs ++ "]") . intersperse ',' $ "duehiduaued euhtod te hdtaduhten"
05:28:34 <mr_tenor> really? i recall seeing it being defined as 1,1,2,... all the time
05:28:34 <lambdabot>  "[d,u,e,h,i,d,u,a,u,e,d, ,e,u,h,t,o,d, ,t,e, ,h,d,t,a,d,u,h,t,e,n]"
05:28:55 <Pastorn_> EvilTerran: thanks :D
05:29:16 <cizra> @src Maybe
05:29:17 <lambdabot> data Maybe a = Nothing | Just a
05:29:19 <EvilTerran> function application binds tigher than *everything*. this is useful to remember when you get annoying type errors.
05:29:25 <mr_tenor> oh hey, so it is
05:29:28 <cizra> I like the keyword Maybe (=
05:29:32 <roconnor> 1 is the -1th fib number
05:29:42 <roconnor> -1 is the -2nd fib number
05:30:08 <roconnor> 2 is the -3rd fib number
05:30:15 <ricky_clarkson> cizra: It isn't a keyword.
05:30:23 <cizra> ricky_clarkson: What then? Function?
05:30:27 <cizra> Still nice.
05:30:35 <EvilTerran> > let antifibs = 1 : 1 : zipWith subtract antifibs (tail antifibs) in antifibs
05:30:36 <mr_tenor> so just let fibs = 0 : 1 : zipWith (+) fibs (tail fibs
05:30:38 <lambdabot>  [1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0...
05:30:46 <ricky_clarkson> Type, I think.
05:31:01 <mr_tenor> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
05:31:02 <lambdabot>  Parse error
05:31:17 <roconnor> ... in fibs
05:31:26 <EvilTerran> > let antifibs = 1 : 1 : zipWith subtract (tail antifibs) antifibs in antifibs -- or is this the right one?
05:31:30 <lambdabot>  [1,1,0,1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,418...
05:32:44 <cizra> mr_tenor: Doh! Of course!
05:33:03 <mr_tenor> parse error?
05:33:11 * mr_tenor tired
05:33:28 <oerjan> mr_tenor: missing "in ..." part
05:33:55 <roconnor> pejo: springer and CUP are both on the green list :D
05:34:14 <cizra> fib = fibs !!
05:34:15 <oerjan>  > takes an expression, not a declaration
05:34:22 <cizra> I thought currying would allow this
05:34:26 <roconnor> fib = (fibs !!)
05:34:31 <mr_tenor> oerjan: ah :D
05:34:37 <cizra> > fib = (fibs !!)
05:34:37 <lambdabot>  Parse error
05:34:42 <cizra> > let fib = (fibs !!) in fib 3
05:34:44 <lambdabot>  3
05:34:47 <cizra> > let fib = (fibs !!) in fib 10
05:34:48 <lambdabot>  89
05:34:50 <cizra> aha
05:34:52 <cizra> thanks, lambdabot
05:34:59 <mr_tenor> i never bothered to look into what lambdabot was doing... assmed it was just passing it to ghci directly
05:35:24 <zx]treads>  
05:35:30 <cizra> @src lambdabot
05:35:30 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:35:42 <mr_tenor> llamabot ;)
05:36:01 <oerjan> @where lambdabot
05:36:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:36:01 <roconnor> > fibs !! 0
05:36:03 <lambdabot>  1
05:36:06 <roconnor> bah
05:36:10 <roconnor> wrong!
05:36:12 <mr_tenor> ah, not a typo of cizra's... just crappy font rendering :(
05:36:46 <oerjan> @undefine
05:36:51 <lambdabot> Undefined.
05:36:52 <EvilTerran> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
05:36:53 <lambdabot> Defined.
05:36:57 <roconnor> > fibs !! 0
05:36:59 <lambdabot>  0
05:37:03 <roconnor> better
05:37:07 <EvilTerran> @let fib = (fibs !!)
05:37:08 <lambdabot> Defined.
05:37:16 <roconnor> > fib 0
05:37:18 <lambdabot>  0
05:37:21 <cizra> > fib 999999
05:37:25 <lambdabot> Terminated
05:37:29 <cizra> blah
05:37:32 <roconnor> > fix fib
05:37:33 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
05:37:36 <cizra> I hoped it'd cause a DOS
05:37:42 <roconnor> :/
05:37:44 <oerjan> @help run
05:37:45 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
05:38:01 <mr_tenor> couldn't take _that_ long to add up a few numbers... you don't even need any stack frames
05:38:15 <mr_tenor> 3 seconds... maybe not :/
05:38:22 <cizra> hmmm..
05:38:40 <norpan> Integers are fast, but not that fast
05:38:54 <roconnor> haskell is slow! :P
05:38:56 <norpan> Ints should be faster
05:38:57 <oerjan> mr_tenor: they grow exponentially
05:39:21 <norpan> although i doubt that fib 999999 fits in an Int
05:39:22 <mr_tenor> oerjan: with 999999 you'd overflow pretty quickly, though, so no worries ;)
05:39:51 <EvilTerran> ?type genericIndex
05:39:53 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
05:40:02 <EvilTerran> @let genericFib = genericIndex fibs
05:40:04 <lambdabot> Defined.
05:40:08 <roconnor> :D
05:40:10 <EvilTerran> > fix genericFib
05:40:12 <lambdabot>  Exception: <<loop>>
05:40:37 <cizra> Hey, can I somehow give lambdabot complex expressions incorporating whitespace/indentation?
05:40:57 <oerjan> cizra: not indentation
05:41:05 <TSC> I don't think so; you have to use semi-colons
05:41:07 <cizra> oerjan: What about guards then?
05:41:15 <oerjan> guards are fine
05:41:33 <EvilTerran> cizra, do you know about the desugaring of layout?
05:41:43 <cizra> no
05:42:12 <EvilTerran> @where layout
05:42:13 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
05:42:23 <Philippa> cizra: lambdabot already does the layout rule, it just doesn't do multi-line input
05:42:45 <EvilTerran> basically, if a line is indented more than the one before, it gets a "{" before it; less, it gets a "}"; otherwise, it gets a ";"
05:43:00 <EvilTerran> to be very VERY approximate
05:43:35 <EvilTerran> you can put these characters in yourself, and, if you do, you don't need the newlines.
05:43:45 <oerjan> and { are inserted only after do, where, let, of
05:43:50 <EvilTerran> > let { x = 1; y = 2 } in x + y
05:43:52 <lambdabot>  3
05:43:55 <cizra> @let luc = ((map luc' [0 ..]) !!) where luc' 0 = 2; luc' n; | odd n = (5*fib(n-1) + luc(n-1)) `div` 2; | otherwise = fib(n `div` 2) * luc(n `div` 2)
05:43:55 <lambdabot>  Parse error
05:43:58 <cizra> blah
05:44:15 <EvilTerran> @let luc = ((map luc' [0 ..]) !!) where luc' 0 = 2; luc' n | odd n = (5*fib(n-1) + luc(n-1)) `div` 2 | otherwise = fib(n `div` 2) * luc(n `div` 2)
05:44:17 <lambdabot> Defined.
05:44:22 <oerjan> no semicolons before guards
05:44:34 <EvilTerran> not all newlines. as i said, very very approximate
05:44:38 <cizra> @let luc = ((map luc' [0 ..]) !!) where luc' 0 = 2; luc' n | odd n = (5*fib(n-1) + luc(n-1)) `div` 2 | otherwise = fib(n `div` 2) * luc(n `div` 2)
05:44:38 <lambdabot> <local>:5:0:     Multiple declarations of `L.luc'     Declared at: <local>:4:...
05:44:56 <cizra> Someone reboot lambdabot (=
05:45:00 <cizra> > reboot
05:45:01 <mr_tenor> maybe i could get my next paper into CUFP orsomething, if they're okay :P
05:45:01 <lambdabot>   Not in scope: `reboot'
05:45:08 <cizra> > killall -HUP lambdabot
05:45:09 <lambdabot>   Not in scope: `lambdabot'
05:45:15 <EvilTerran> as oerjan said, the rule i just described only applies in do{}, where{}, let{}, and case of{} blocks
05:45:16 <oerjan> @undefine
05:45:17 <lambdabot> Undefined.
05:45:27 <oerjan> cizra: try again
05:45:30 <cizra> @let luc = ((map luc' [0 ..]) !!) where luc' 0 = 2; luc' n | odd n = (5*fib(n-1) + luc(n-1)) `div` 2 | otherwise = fib(n `div` 2) * luc(n `div` 2)
05:45:31 <lambdabot> <local>:1:67: Not in scope: `fib'  <local>:1:110: Not in scope: `fib'
05:46:01 <oerjan> er right. @undefine wipes out _all_ temporary definitions, unfortunately.
05:46:18 <EvilTerran> outside of lambdabot, it also applies anywhere else there's a where{}; class ... where, instance, module, etc
05:46:37 <EvilTerran> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
05:46:39 <cizra> @let fib = ((map fib' [0 ..]) !!) where fib' 0 = 0; fib' n | odd n = (fib(n-1) + luc(n-1)) `div` 2 | | otherwise = fib(n `div` 2) * luc(n `div` 2)
05:46:39 <lambdabot> Defined.
05:46:39 <lambdabot>  Parse error
05:46:47 <mr_tenor> cizra: are you trying to haxxor dons computer?
05:46:48 <EvilTerran> @let fib = genericIndex fibs
05:46:50 <lambdabot> Defined.
05:46:52 <cizra> mr_tenor: no, of course
05:47:05 <cizra> EvilTerran: Hey, hey, I'm trying to do some optimizations here
05:47:08 <cizra> @let luc = ((map luc' [0 ..]) !!) where luc' 0 = 2; luc' n | odd n = (5*fib(n-1) + luc(n-1)) `div` 2 | otherwise = fib(n `div` 2) * luc(n `div` 2)
05:47:10 <EvilTerran> :P
05:47:11 <lambdabot> Defined.
05:47:14 <cizra> @let fib = ((map fib' [0 ..]) !!) where fib' 0 = 0; fib' n | odd n = (fib(n-1) + luc(n-1)) `div` 2 | | otherwise = fib(n `div` 2) * luc(n `div` 2)
05:47:14 <lambdabot>  Parse error
05:47:20 <cizra> @let fib = ((map fib' [0 ..]) !!) where fib' 0 = 0; fib' n | odd n = (fib(n-1) + luc(n-1)) `div` 2 | otherwise = fib(n `div` 2) * luc(n `div` 2)
05:47:20 <EvilTerran> sorry
05:47:20 <lambdabot> <local>:4:0:     Multiple declarations of `L.fib'     Declared at: <local>:2:...
05:47:24 <cizra> @undefine
05:47:25 <lambdabot> Undefined.
05:47:32 <cizra> But you gave a good idea
05:47:50 <EvilTerran> may i suggest doing this in private, and @paste'ing your results?
05:47:51 <cizra> hmmmm.. no
05:48:00 <cizra> Nope, I want to make lambdabot smart (
05:48:01 <cizra> (=
05:48:07 <EvilTerran> you won't have to keep typing everything in again after you make one mistake
05:48:26 <cizra> *nod* But please tell me, how can I define two inter-dependent functions to lambdabot?
05:48:46 <oerjan> cizra: let takes a _block_ of definitions
05:49:04 <EvilTerran> @let even 0 = True; even x = not (odd (x-1)); odd x = not (even (x-1))
05:49:04 <lambdabot> <local>:1:29:     Ambiguous occurrence `odd'     It could refer to either `od...
05:49:13 <cizra> Aha! So I just separate them with ;
05:49:15 <EvilTerran> @let even' 0 = True; even' x = not (odd' (x-1)); odd' x = not' (even (x-1))
05:49:15 <lambdabot> <local>:1:53: Not in scope: `not''
05:49:21 <EvilTerran> @let even' 0 = True; even' x = not (odd' (x-1)); odd' x = not (even' (x-1))
05:49:22 <lambdabot> Defined.
05:49:27 <EvilTerran> > even' 13
05:49:33 <lambdabot> Terminated
05:49:39 <EvilTerran> er.
05:49:49 <mr_tenor> @let {a=1;b=2} in a+b
05:49:49 <lambdabot>  Parse error
05:49:57 <mornfall> @src words
05:49:57 <lambdabot> words s = case dropWhile isSpace s of
05:49:58 <lambdabot>     "" -> []
05:49:58 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
05:50:04 <EvilTerran> @let doesn't have an "in".
05:50:04 <lambdabot>  Parse error
05:50:07 <mr_tenor> > let {a=1;b=2} in a+b
05:50:08 <lambdabot>  3
05:50:09 <mr_tenor> rather
05:50:43 <EvilTerran> > even' 0
05:50:44 <lambdabot>   Not in scope: `even''
05:50:53 <EvilTerran> er? did someone @undef?
05:51:37 <EvilTerran> @let even' 0 = True; odd' 0 = False; even' x = not (odd' (x-1)); odd' x = not (even' (x-1))
05:51:38 <lambdabot> <local>:1:32:     Multiple declarations of `L.even''     Declared at: <local>...
05:51:59 <EvilTerran> i give up.
05:52:02 * EvilTerran -> lunch
05:52:42 <oerjan> > even' 0
05:52:43 <lambdabot>   Not in scope: `even''
05:53:14 <oerjan> > let even' = even in even' 0
05:53:16 <lambdabot>  True
05:53:36 <oerjan> > odd' 0
05:53:49 <lambdabot>   Not in scope: `odd''
05:53:53 <cizra> OK, I tested it.
05:53:55 <EvilTerran> i had all the nots in the wrong places, anyway.
05:53:55 <cizra> May I undefine now?
05:54:01 <EvilTerran> go on then
05:54:27 <oerjan> @undefine
05:54:29 <lambdabot> Undefined.
05:54:52 <EvilTerran> @let even' 0 = True; odd' 0 = False; even' x = odd' (x-1); odd' x = even' (x-1)
05:54:53 <lambdabot> <local>:1:32:     Multiple declarations of `L.even''     Declared at: <local>...
05:55:01 <EvilTerran> O.o o.O
05:55:06 <cizra> @let fib = ((map fib' [0 ..]) !!) where fib' 0 = 0 ; fib' n | odd n = (fib(n-1) + luc(n-1)) `div` 2 | otherwise = fib(n `div` 2) * luc(n `div` 2) ; luc = ((map luc' [0 ..]) !!) where luc' 0 = 2 ; luc' n | odd n = (5*fib(n-1) + luc(n-1)) `div` 2 | otherwise = (5*fib(n `div` 2)^2 + luc(n `div` 2)^2) `div` 2
05:55:10 <lambdabot> Defined.
05:55:12 <EvilTerran> @let even' 0 = True; even' x = odd' (x-1); odd' 0 = False; odd' x = even' (x-1)
05:55:17 <lambdabot> Defined.
05:55:23 <EvilTerran> > even' 13
05:55:25 <lambdabot>  False
05:55:26 <oerjan> oh, right
05:55:27 <EvilTerran> finally.
05:55:36 <cizra> OK, now it should be able to calculate fib 2500000 in 3 seconds.
05:55:45 <cizra> It'll generate a lot of spam, I'm afraid...
05:55:52 <oerjan> not at all
05:56:05 * EvilTerran wasn't aware that multiple bits of a function had to all be defined together
05:56:11 <oerjan> > fib 2500000
05:56:16 <lambdabot> Terminated
05:56:23 <cizra> > fib 1000000
05:56:25 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
05:56:30 <cizra> > fib 2000000
05:56:34 <lambdabot> Terminated
05:56:38 <cizra> blah )=
05:56:47 <cizra> Oh, this is ghci? This explains stuff.
05:56:50 <oerjan> it did better than i expected :)
05:56:53 <cizra> Yes
05:57:00 <cizra> > fib 1500000
05:57:03 <lambdabot>  1290892168118739516127853177669473612015044170384009622099938119509407370340...
05:57:23 <EvilTerran> anyway. lunch.
05:57:36 <cizra> Note: this algo calculates (with -O2 optimization) 2000000th number in 1.7 seconds, taking around 200M of ram.
05:58:00 <ari> cizra: It's ghc -O2 -fasm, but I think it gets like only 1 second of running time, on a rather old server
05:58:32 <oerjan> cizra: the next step would be to use matrix multiplication i guess
05:58:39 <cizra> oerjan: Nope, it's slower
05:58:47 <oerjan> oh?
05:58:52 <ari> (I woke up recently and I didn't check the validity of this information anywhere, so take it with a grain of salt)
05:58:54 <cizra> At least I believe it to be.
05:59:13 <oerjan> i mean something with binary division
05:59:24 <oerjan> @src (^)
05:59:24 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:59:27 <oerjan> @src ^
05:59:28 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:01:42 <EvilTerran> whups
06:05:04 <mr_tenor> nite ppl :) happy APEC.
06:05:37 <oerjan> @let a `mm` b = [[sum (zipWith (*) a' b')| b' <- transpose b]|a' <- a]
06:05:50 <lambdabot> Defined.
06:09:17 <cizra> Why does Haskell use backticks so much?
06:09:31 <cizra> I use those as screen control character, which tends to mess up everything.
06:09:44 <int-e> you don't have to use them
06:10:22 <cizra> Oh? Why do I use them then?
06:10:44 <int-e> I mean they're only used to make infix operators out of identifiers - you can write all these in prefix notation.
06:10:59 <int-e> a `f` b becomes f a b
06:11:22 <cizra> Ahh!
06:11:29 <int-e> that being said, it's often more natural to use them, and makes code easier to read.
06:11:45 <cizra> Why "div", not /?
06:11:53 <cizra> To keep it functional?
06:11:59 <int-e> because / has a different type
06:12:00 <cizra> > quot 2 3
06:12:02 <lambdabot>  0
06:12:03 <cizra> > div 2 3
06:12:03 <int-e> @type (/)
06:12:05 <lambdabot>  0
06:12:06 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:12:12 <Twan> > 2/3
06:12:13 <lambdabot>  0.6666666666666666
06:12:23 <cizra> > quot 2.0 3.0
06:12:24 <lambdabot>  Add a type signature
06:12:31 <cizra> > div 2.0 3.0
06:12:32 <lambdabot>  Add a type signature
06:12:40 <Twan> (/) doesn't round the result
06:12:49 <cizra> OK, so quot and div work for ints.
06:12:53 <cizra> > div 5 3
06:12:55 <lambdabot>  1
06:12:57 <cizra> > quot 5 3
06:12:59 <lambdabot>  1
06:13:02 <cizra> hmmm...
06:14:02 <foo-nix> does haskell has some perl like || operator, i.e.       n || -1 ==-1 if n==0   and    n||-1 == n if n>0   ?
06:14:34 <oerjan> @let a `mpow` 1 = a; a `mpow` n | odd n = a `mm` a2 | otherwise = a2 where a2 = (a `mm` a) `mpow` (n `div` 2)
06:14:40 <lambdabot> Defined.
06:15:06 <oerjan> :t (||)
06:15:08 <lambdabot> Bool -> Bool -> Bool
06:15:25 <norpan> foo-nix: that sounds like a very strange operator
06:15:28 <foo-nix> oerjan: Are you european?
06:15:38 <oerjan> norwegian
06:16:02 <foo-nix> norpan: not if you define boolean as an integer, where it is false for smaller then or equal 0 and true for positive.
06:16:10 <LeCamarade> noerjan.
06:16:11 <norpan> but we don't
06:16:12 <foo-nix> oerjan: Ah, I'm dutch.
06:16:16 <norpan> because booleans are not integers
06:16:31 <foo-nix> norpan: from a digital logic level they mostly are.
06:16:58 <Twan> You would need to know what 'empty' or 'zero' is for all types. If you want you could make a type class.
06:18:21 <oerjan> @let fib'' n = head . head $ [[1,1],[1,0]] `mpow` (n-1)
06:18:26 <lambdabot> Defined.
06:19:17 <oerjan> > fib'' 1000000
06:19:20 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
06:19:25 <oerjan> > fib'' 2500000
06:19:30 <lambdabot> Terminated
06:19:34 <oerjan> bah
06:19:40 <Twan> > let fib=fst.f;f 0=(1,1);f 1=(1,2);f n=let (a,b)=f$n`div`2-1;c=(a+b)^2 in if odd n then(c-a*a,b*b+c)else(a*a+b*b,c-a*a) in fib 2500000
06:19:42 <oerjan> > fib'' 2000000
06:19:44 <lambdabot>  9122788048145465328356022860646067352153585110474811308501391659278800517140...
06:19:47 <lambdabot>  8531294917507641543051660654503825161955433610024013070059635858838398006887...
06:21:29 <norpan> foo-nix: but haskell is not a digital logic level language, and in mathematics, integers and booleans are certainly not the same
06:22:49 <int-e> > (Just 1 `mplus` Just 2, Nothing `mplus` Just 3)
06:22:51 <lambdabot>  (Just 1,Just 3)
06:23:00 <int-e> the maybe type is closer to that idea
06:23:03 <oerjan> i think it has been used to _design_ digital logic, though :)
06:23:50 <oerjan> right, mplus is probably haskell's version of that idea
06:24:01 <oerjan> suitably generalized
06:24:40 <twanvl> I think mOrElse is more like it (not a standard haskell function)
06:25:19 <twanvl> > "xyz" `mplus` "in-case-of-empty-string" -- not what you want for your `orElse` operator
06:25:20 <lambdabot>  "xyzin-case-of-empty-string"
06:25:32 <foo-nix> oerjan: I am talking about memory adressing, and the unability to allocate one bit in most memories, so one can better use all 32bits for an integer instead of a bit of them.
06:26:08 <foo-nix> twanvl: Thanxs
06:26:13 <oerjan> @docs Data.Bits
06:26:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
06:26:26 <oerjan> take a look there
06:27:15 <roconnor> foo-nix: 64bits per integer?
06:28:01 <oerjan> not sure that has a || function, though
06:28:26 <roconnor> > 1 .|. 2
06:28:27 <lambdabot>  Add a type signature
06:28:34 <roconnor> > 1 .|. 2 :: Word32
06:28:35 <lambdabot>  3
06:29:49 <foo-nix> roconnor: well, in modern architectures
06:35:00 <roconnor> I think catchError is kinda like ||
06:42:14 <alexeevg> @yow
06:42:14 <lambdabot> I'd like MY data-base JULIENNED and stir-fried!
06:46:03 <gpi5> Hi! How do I replace the n-th element of a list?
06:46:29 <beelsebob_> gpi5: probably you're thinking about your problem wrong if you're trying to do that
06:46:53 <gpi5> Argh :)
06:46:59 <beelsebob_> what is the problem?
06:48:03 <beelsebob_> replace [] _ _ = []
06:48:03 <beelsebob_> replace (x:xs) 0 y = y:xs
06:48:03 <beelsebob_> replace (x:xs) n y = x:(replace xs (n-1) y)
06:48:08 <beelsebob_> if you do acutally need to
06:48:13 <beelsebob_> but what's the problem?
06:48:30 <gpi5> Consider an integer i...
06:48:51 <beelsebob_> uhhuh
06:48:55 <cizra> Oh, did it turn out that matrix multiplication is even faster?
06:49:14 <luqui> gpi5,  replace n x xs = take n xs ++ [x] ++ drop (n+1) xs
06:49:19 <gpi5> I'm trying to find the list representing a binary number whose value is the integer.
06:49:31 <gpi5> Am I clear?
06:49:46 <luqui> where the list is a list of 0s and 1s?
06:49:56 <beelsebob_> gpi5: so you're using a list representation like [1,1,0,1,0,0,1] for binary numbers?
06:50:05 <EvilTerran> you shouldn't need changing items in lists to do that
06:50:09 <gpi5> Yes
06:50:10 <beelsebob_> no
06:50:12 <beelsebob_> you shouldn't
06:50:14 <beelsebob_> two secs
06:51:01 <int-e> > map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) $ 421
06:51:03 <lambdabot>  [1,0,1,0,0,1,0,1,1]
06:51:07 <beelsebob_> hehe
06:51:14 <beelsebob_> int-e: beat me to the punch
06:51:23 <luqui> lsb first
06:51:40 <int-e> add a reverse for good measure of you want the msb first.
06:52:05 <luqui> but what if it's an infinite integer? :-)
06:52:17 <int-e> a what?
06:52:20 <gpi5> Thanks :) But my problem is a bit more complex as the number may be signed with a fractional part...
06:52:34 <int-e> you didn't say that though
06:52:54 <beelsebob_> gpi5: so you want to convert a float to binary?
06:53:03 <gpi5> Well, I started with the easy example..
06:53:19 <gpi5> beelsebob_ : No I defined my own data types
06:53:23 <beelsebob_> sign is easy enough to deal with anyway
06:53:45 <EvilTerran> unsafeCoerce# :: Float# -> Word#
06:53:53 <int-e> how do you want to represent the result if there's a fractional part?
06:54:04 <int-e> EvilTerran: good job at assuming a 32 bit architecture.
06:54:20 <EvilTerran> it was a joke.
06:54:26 <EvilTerran> i thought that would be obvious.
06:54:56 <gpi5> int-e: I specify the number of bits for the fractional part
06:54:57 <EvilTerran> anyway, i'm not assuming that... or are one or other of those garunteed to be the word length and the other 32 bits?
06:55:16 <EvilTerran> gpi5, multiply by 2^bitsOfFractionalPart first, then?
06:55:29 <int-e> gpi5: ok, so multiply by 2^k (k being the number of bits) first and round. then deal with the resulting integer.
06:55:30 <luqui> and take floor, then do int-e's solution :-)
06:55:46 <int-e> @quote stereo
06:55:46 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
06:55:53 <int-e> sniff.
06:55:58 <roconnor> > encodeFloat pi
06:55:59 <lambdabot>   add an instance declaration for (Floating Integer)
06:56:05 <roconnor> > decodeFloat pi
06:56:07 <lambdabot>  (7074237752028440,-51)
06:56:21 <int-e> EvilTerran: I've coded too much assembler to take that as a joke I guess.
06:56:33 <EvilTerran> hehe, okay.
06:56:37 * luqui hoogles encodeFloat
06:56:55 <Manyfold> what was the joke?
06:56:58 <EvilTerran> it would be rather similar to the way i'd do it in C/++
06:57:25 <gpi5> What does '$'mean in int-e solution?
06:57:33 <luqui> gah, I didn't expect such a low level function to be in the prelude...
06:57:35 <roconnor> @src ($)
06:57:36 <lambdabot> f $ x = f x
06:57:54 <luqui> I guess it's not that low level, it's just weird
06:57:55 <EvilTerran> int unsafeCoerce (float fl) { enum { float f, int i } e; e.f = fl; return e.i; } kinda thing
06:58:02 <roconnor> f $ foo bar baz = f (foo bar baz)
06:58:09 <EvilTerran> ?src ($)
06:58:09 <lambdabot> f $ x = f x
06:58:12 <EvilTerran> ?info ($)
06:58:12 <lambdabot> (($))
06:58:27 <int-e> EvilTerran: you mean union
06:58:30 <roconnor> $ prevents our code from looking like scheme.
06:58:35 <luqui> yeah, I had to stare at that for a little while
06:58:36 <EvilTerran> yes. yes, i do mean union.
06:58:41 <EvilTerran> i haven't done C for a while...
06:58:46 <gpi5> $ is like a separator then
06:58:49 <EvilTerran> especially not anything so hackish.
06:58:59 <luqui> I wrote about my ugliest looking haskell ever today, and it looked a little like scheme
06:59:11 <luqui> pre,(((_,bs),p'):posts)) -> classify' (pre ++ ((a,((a,b),p):bs),p+p'):posts) xs
06:59:42 <roconnor> sounds like you could use more types :)
06:59:53 <luqui> yeah probably
07:00:55 <EvilTerran> or more helper functions
07:01:31 <luqui> one will probably follow from the other
07:01:56 <luqui> I'm refactoring some new types right now, hoping it will show me an opportunity to clean up
07:02:09 <ndm> luqui: you have redundant brackets on the left, and on the right
07:02:54 <ndm> pre,((_,bs),p'):posts) -> classify' (pre ++ ((a,(a,b),p):bs,p+p'):posts) xs
07:03:05 <ndm> still needs a good refactoring though!
07:03:28 <int-e> ndm: I think you misparsed that.
07:03:41 <int-e> ((a,b),p):bs
07:04:00 <int-e> is a subterm of the original
07:04:17 <ndm> int-e: entirely possible, much harder, but i'm sure there are redundant brackets
07:05:00 <int-e> there aren't, they all belong to constructed pairs, except for the outermost ones
07:05:22 <int-e> but this is an indication that better types would help :)
07:06:16 <int-e> (I only looked at the RHS)
07:07:16 <twanvl> nested tuples are *always* an indication that you need to refactor
07:08:55 <luqui> caddar
07:08:57 <luqui> :-)
07:09:23 <roconnor> execpt when you are writing a stack calculator.
07:09:29 <alexeevg> oleg et. al's latest article on tagless typed interpreters seems to be a counter-example
07:09:58 <alexeevg> they represent environments as nested tuples
07:10:23 <roconnor> alexeevg: do the functions operate on more than one level of pairs at a time?
07:10:54 <alexeevg> roconnor: I guess no
07:11:07 <roconnor> then it's all good :)
07:13:24 <luqui> anyone here edit haskell with vim?
07:13:44 <luqui> if so, do you know how to make it so that it counts \( as a left parenthesis?
07:14:05 <luqui> I'm tired of writing lambdas with a space in them: \ (Foo bar baz) -> ...
07:14:25 <EvilTerran> you can leave those parentheses out...
07:14:39 <luqui> note the capital on Foo
07:14:44 <EvilTerran> yes..
07:14:47 <luqui> really?
07:14:52 <EvilTerran> i think so. i may be wrong.
07:15:00 <EvilTerran> > (\Just x -> x)
07:15:01 <lambdabot>      Constructor `Just' should have 1 argument, but has been given 0
07:15:02 <lambdabot>     In t...
07:15:09 <EvilTerran> okay, maybe not. =/
07:15:19 <EvilTerran> there'll be something in the haskell syntax file
07:15:29 <luqui> I think it inherits the behavior...
07:15:43 <luqui> eh, ok, I was just looking for a way not to have to work at it :-)
07:15:54 <EvilTerran> which one're you using? i'll have a look if you like
07:15:54 <chessguy> you could always switch to a real editor, like emacs
07:15:56 * chessguy ducks
07:16:06 <EvilTerran> -.-
07:16:07 <Ben`> luqui: what version of Vim are you using?
07:16:11 <EvilTerran> emacs is a lisp interpreter.
07:16:18 <luqui> Ben`, 6.4
07:16:30 <sebell> EvilTerran: But it comes with an editor too!
07:16:30 <EvilTerran> a particularly shoddy flavour of lisp, at that.
07:16:51 <EvilTerran> it happens to come with an editor as an example script, yes ;]
07:17:22 <Ben`> luqui: well it works fine for me in Vim 7
07:17:31 <cizra> fib=fst.f;f 0=(1,1);f 1=(1,2);f n=let (a,b)=f$n`div`2-1;c=(a+b)^2 in if odd n then(c-a*a,b*b+c)else(a*a+b*b,c-a*a)
07:17:37 <cizra> Could someone please explain this thing to me?
07:17:38 <luqui> Ben`, ok thanks, I'll upgrade
07:17:39 <cizra> What is fst?
07:17:49 <chessguy> @type fst
07:17:51 <lambdabot> forall a b. (a, b) -> a
07:17:52 <luqui> > fst (1,2)
07:17:53 <lambdabot>  1
07:18:07 <cizra> What is .?
07:18:16 <EvilTerran> ?src (.)
07:18:17 <lambdabot> (.) f g x = f (g x)
07:18:21 <cizra> So fst takes the first element of a tuple/pair/howyoucallit.
07:18:24 <EvilTerran> functional composition operator
07:18:33 <chessguy> a tuple,yes
07:18:34 <EvilTerran> have you read any haskell tutorials?
07:18:42 <cizra> yea
07:18:54 <EvilTerran> they should've explained (.), if not fst as well.
07:19:10 <cizra> did not. Will have to find a better one.
07:19:15 <chessguy> @where yaht
07:19:15 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
07:19:29 <cizra> The meta-tutorial lists a lot of those.
07:19:31 <chessguy> cizra, this is a pretty good one ^^
07:19:38 <cizra> Thank you.
07:21:11 <ricky_clarkson> EvilTerran: I think it's sufficient to make the reader understand :t (.)
07:21:30 <EvilTerran> hmm
07:21:52 <chessguy> ricky_clarkson, i think it's preferable to any single example
07:22:11 <luqui> hmm, that's cleaner, if a bit confusing: fmap (map (fmap shuffleRightPair)) $ f (map (fmap shuffleLeftPair) sts))
07:22:16 <chessguy> no single example shows the polymorphism
07:22:18 <luqui> (not the same as previous ugly example)
07:22:48 <chessguy> @pl f (m (f sh)) $ f (m (f sh) s))
07:22:49 <lambdabot> (line 1, column 30):
07:22:49 <lambdabot> unexpected ")"
07:22:49 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
07:23:11 <luqui> it is already pointfree
07:23:24 <chessguy> oh, what's sts?
07:23:30 <chessguy> @pl f (m (f sh)) $ f (m (f sh) s)
07:23:30 <lambdabot> f (m (f sh)) (f (m (f sh) s))
07:23:38 <luqui> oh right... that is a parameter
07:23:53 <chessguy> @pl \s -> f (m (f sh)) $ f (m (f sh) s)
07:23:53 <lambdabot> f (m (f sh)) . f . m (f sh)
07:23:59 <chessguy> there we go
07:24:20 <luqui> it's just the multiple different meanings of fmap that I think make it confusing...
07:24:46 <EvilTerran> you could replace "map" with "fmap" as well, for kicks...
07:24:51 <luqui> haha
07:24:55 <EvilTerran> and (.)
07:25:10 <ricky_clarkson> :t fmap
07:25:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:25:47 <chessguy> @type (.)
07:25:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:26:27 <luqui> inside Functor (a ->) then?
07:26:40 <ricky_clarkson> :t id
07:26:42 <lambdabot> forall a. a -> a
07:26:42 <EvilTerran> fmap (fmap (fmap shuffleRightPair)) (fmap f (fmap (fmap shuffleLeftPair))  >:]
07:26:50 <luqui> lol
07:26:57 <Botje> OI. what's all this then!
07:27:02 <ricky_clarkson> Why does it bother with the forall a part?
07:27:22 <luqui> just being explicit, I suppose
07:28:36 <EvilTerran> ?type fmap (fmap (fmap (fmap shuffleRightPair))) (fmap f (fmap (fmap shuffleLeftPair)))
07:28:38 <lambdabot> Not in scope: `shuffleRightPair'
07:28:38 <lambdabot>  
07:28:38 <lambdabot> <interactive>:1:49: Not in scope: `f'
07:28:45 <EvilTerran> ?type fmap (fmap (fmap (fmap ?shuffleRightPair))) (fmap f (fmap (fmap ?shuffleLeftPair)))
07:28:47 <lambdabot> Not in scope: `f'
07:28:51 <EvilTerran> ?type fmap (fmap (fmap (fmap ?shuffleRightPair))) (fmap ?f (fmap (fmap ?shuffleLeftPair)))
07:28:53 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a1 b1 (f3 :: * -> *) (f4 :: * -> *). (?shuffleRightPair::a -> b, Functor f, Functor f1, Functor f2, ?f::f4 (f3 b1) -> f2 (f1 (f a)), ?shuffleLeft
07:28:53 <lambdabot> Pair::a1 -> b1, Functor f3, Functor f4) => f4 (f3 a1) -> f2 (f1 (f b))
07:29:06 <EvilTerran> okay, never mind
07:29:38 <EvilTerran> ?type fmap (map (fmap ?shuffleRightPair)) . ?f  . map (fmap ?shuffleLeftPair) sts
07:29:40 <lambdabot> Not in scope: `sts'
07:29:44 <EvilTerran> ?type fmap (map (fmap ?shuffleRightPair)) . ?f  . map (fmap ?shuffleLeftPair)
07:29:46 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) a1 b1 (f2 :: * -> *). (?shuffleRightPair::a -> b, Functor f, Functor f1, ?f::[f2 b1] -> f1 [f a], ?shuffleLeftPair::a1 -> b1, Functor f2) => [f2 a1] -> f1 [f
07:29:46 <lambdabot> b]
07:30:05 <EvilTerran> okay, the types correspond. i think that one works.
07:30:27 <EvilTerran> luqui, yes, this is using the (a ->) functor
07:30:32 <EvilTerran> @src (->) fmap
07:30:33 <lambdabot> fmap = (.)
07:30:52 <ricky_clarkson> > map (flip (,) 5) [1,2,3,4]
07:30:54 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
07:31:00 <ricky_clarkson> Is there a better way of writing that?
07:31:41 <gpi5> ?t denominator
07:31:42 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:31:43 <EvilTerran> unfortunately, we can't write (,5), so i think so
07:31:52 <int-e> (\x -> (x,5)) seems clearer
07:31:53 <EvilTerran> *i think not
07:32:06 <EvilTerran> i prefer the flip-based one, TBH.
07:32:45 <gpi5> How can I use the denominator function on Rational ? (I include
07:32:52 <gpi5> I import Data.Ratio
07:33:44 <int-e> > let x = 42 % 15 in (numerator x, denominator x)
07:33:46 <lambdabot>  (14,5)
07:34:21 <EvilTerran> ?index numerator
07:34:22 <lambdabot> Data.Ratio
07:36:11 <EvilTerran> > zip [1,2,3,4] (repeat 5) -- ricky_clarkson, this better?
07:36:12 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
07:36:45 <EvilTerran> > [(x,5) | x <- [1,2,3,4]] -- i prefer this one to an explicit lambda, too
07:36:46 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
07:37:04 <opqdonut> > zipWith (%) [1..] $ repeat 5
07:37:06 <lambdabot>  [1%5,2%5,3%5,4%5,1%1,6%5,7%5,8%5,9%5,2%1,11%5,12%5,13%5,14%5,3%1,16%5,17%5,1...
07:37:32 <opqdonut> > zipWith (%) [1..] [2..]
07:37:33 <lambdabot>  [1%2,2%3,3%4,4%5,5%6,6%7,7%8,8%9,9%10,10%11,11%12,12%13,13%14,14%15,15%16,16...
07:37:53 <EvilTerran> > last (zipWith (%) [1..] [2..])
07:37:58 <lambdabot> Terminated
07:38:04 <EvilTerran> aww, i wanted it to say 1%1 :P
07:38:07 <ricky_clarkson> EvilTerran: I like the zip one.
07:38:23 <chessguy> @paste
07:38:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:38:50 <opqdonut> EvilTerran: :D
07:38:52 <hpaste>  chessguy pasted "Any suggestions for simplifying this?" at http://hpaste.org/2626
07:38:54 <EvilTerran> > map (`(,)` 5) [1,2,3,4]
07:38:54 <lambdabot>  Parse error
07:38:56 <EvilTerran> aww
07:39:05 <Ben`> how can I turn the list [1..9] into the number 123456789?
07:39:16 <ricky_clarkson> > [1..]==[1..]
07:39:21 <lambdabot> Terminated
07:39:40 <kpreid> Ben: read . concatMap show
07:39:57 <scook0> ooh, clever
07:40:23 <Ben`> kpreid: thanks
07:40:29 <EvilTerran> or there's a fold, if you don't want to go via characters for tidiness reasons
07:40:43 <chessguy> @instances-importing Eq
07:40:44 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
07:40:50 <EvilTerran> > foldl ((+).(10*)) 0 [1..9]
07:40:52 <lambdabot>  123456789
07:41:07 <cizra> Prelude> makelist !! 999999999999
07:41:07 <cizra> *** Exception: Prelude.(!!): negative index
07:41:18 <scook0> cizra: Int overflow
07:41:20 <ricky_clarkson> EvilTerran: I see you're a pointless programer.
07:41:28 <cizra> scook0: Yeah. I see.
07:41:33 <kpreid> EvilTerran: yours and mine do different things if an element >= 10
07:41:42 <EvilTerran> cizra, try genericIndex instead of (!!)
07:41:52 <cizra> scook0: Add 2 '9's and it'll work again
07:41:57 <cizra> EvilTerran: /me looks it up
07:42:10 <scook0> cizra: for some value of "work" that doesn't require a correct answer
07:42:17 <EvilTerran> kpreid, that's breaking the precondition, so doesn't affect correctness
07:42:20 <EvilTerran> :D
07:42:29 <chessguy> ...
07:42:39 <cizra> scook0: That list is composed of an infinite number of ones.
07:42:41 <EvilTerran> ricky_clarkson, yeah, in the cases where it doesn't really break legibility
07:42:47 <kpreid> bah, preconditions should be explicitly checked :)
07:42:47 <scook0> though I'm inclined to think that if you're applying (!!) with such a large index, you're probably doing something wrong
07:42:55 <cizra> scook0: so the code happens incidentally to be correct.
07:43:05 <ricky_clarkson> EvilTerran: I expect that is a function of how much you use pointless.
07:43:15 <EvilTerran> yes, i imagine so
07:43:15 <scook0> cizra: isn't that the most exciting kind of correct?
07:43:25 <cizra> Of course. And why is !! bad?
07:43:39 <ari> cizra: It's O(n) on the index
07:43:41 <chessguy> @type (!!)
07:43:42 <EvilTerran> ricky_clarkson, i tend to draw the line at sections of (.), say. i have been known to use ($ ...), tho.
07:43:43 <lambdabot> forall a. [a] -> Int -> a
07:43:54 <cizra> Oh, interesting.
07:43:55 <chessguy> it's not polymorphic in the index
07:43:57 <ricky_clarkson> :t $
07:43:59 <lambdabot> parse error on input `$'
07:44:04 <scook0> if you genuinely need (!!), you should probably be using arrays
07:44:06 <ricky_clarkson> :t ($)
07:44:08 <lambdabot> forall a b. (a -> b) -> a -> b
07:44:28 <twanvl> not if you need element 999999999999
07:44:40 <EvilTerran> > map ($ 2) [(+1),(*3),const 23,(^4),(4^)]
07:44:41 <lambdabot>  [3,6,23,16,16]
07:45:17 <ricky_clarkson> Haha.
07:45:33 <twanvl> > sequence [(+1),(*3),const 23,(^4),(4^)] 2
07:45:34 <lambdabot>  [3,6,23,16,16]
07:45:55 <EvilTerran> o.ó
07:45:59 <twanvl> (Although I would write the map version)
07:46:18 <ricky_clarkson> :t sequence
07:46:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:46:23 <scook0> hooray for the ((->) a) monad
07:46:48 <chessguy> i thought it was usually called ((->) r)
07:47:07 <scook0> chessguy: I'm correct up to alpha-conversion ... good enough
07:47:35 <scook0> and if you're being informal, you can probably get away with calling it the (->) monad
07:47:46 <ari> :k (->)
07:47:48 <EvilTerran> or reader, right?
07:47:48 <lambdabot> ?? -> ? -> *
07:47:55 <ari> scook0: No, you can't
07:48:05 <scook0> ari: "if you're being informal"
07:48:11 <ddarius> ((->) quetzalcoatl)
07:48:15 <kpreid> :k State
07:48:17 <lambdabot> * -> * -> *
07:48:17 <twanvl> I prefer to write (e->), ((->)e) puts the variable on the wrong side of the arrow
07:48:26 <EvilTerran> ((->) (<-))
07:48:36 <EvilTerran> wait, that's a parse error
07:48:37 <twanvl> But type level sections are not allowed
07:48:45 <kpreid> EvilTerran: aaaaaa
07:48:47 <EvilTerran> ((->) (~>))
07:48:51 <EvilTerran> that'll do
07:48:52 * mrd wants (-> e)
07:48:58 <kpreid> ((->) (—>))
07:49:04 <EvilTerran> O.o
07:49:21 <ricky_clarkson> Why does pointfree 'feel' more elegant than lambdas?
07:49:32 <chessguy> because it often is
07:49:33 <EvilTerran> ((>-)->), if type sections were allowed
07:49:36 <ricky_clarkson> Is it because you're not introducing a new scope level?
07:49:40 <scook0> lambdas require too many extra parens, for one
07:49:49 <EvilTerran> (and you're not using -farrows)
07:50:02 <chessguy> ricky_clarkson, it makes explicit the sort of 'pipeline
07:50:09 <chessguy> ricky_clarkson, it makes explicit the sort of 'pipeline' effect that haskell encoruages
07:50:10 <ricky_clarkson> chessguy: que?
07:50:11 <twanvl> That is kind of evil evil, terran
07:50:14 <ricky_clarkson> Ah.
07:50:20 <EvilTerran> often, to do a lambda, you need (\->) and at least two instances of the variable name
07:50:23 <chessguy> @spell encoruages
07:50:27 <|Jedai|> \x is ugly, with a real lambda it would be better ... silly reason number one for me
07:50:43 <EvilTerran> while with pointsfree, you might just need . and maybe ()s
07:50:44 <chessguy> ?spell encoruages
07:51:00 <EvilTerran> "encourages"
07:51:04 <scook0> |Jedai|: it's better than any other ascii notation I've seen
07:51:20 <chessguy> EvilTerran, i know how to spell it, thanks :)
07:51:27 <|Jedai|> scook0: But it's still not good enough
07:51:27 <EvilTerran> thank eris we're not programming in lisp...
07:51:28 <chessguy> @spell foo
07:51:37 <EvilTerran> (lambda x (...))
07:51:52 <EvilTerran> @bot
07:51:52 <lambdabot> :)
07:52:02 <|Jedai|> EvilTerran: I meant with a unicode lambda of course
07:52:17 <chessguy> EvilTerran, that's not as bat as (function(x){...}) in javascript :)
07:52:26 <scook0> I've always thought (non-seriously) that the entire history of lisp macros is based on the fact that (lambda ...) is too cumbersome to write ;)
07:52:35 <ricky_clarkson> EvilTerran: Lisps that I know don't have automatic currying, so point-free isn't so convenient either.
07:52:46 <EvilTerran> |Jedai|, i know. i'm just saying, lisp manages to be hideously clunky in its anonymous functions, given that it's meant to be a functional language
07:52:47 <ddarius> delegate (int x) { return ...; }
07:53:00 <ndm> its not as bad as <xsl:function name="foo"><xsl:arguments><xsl:argument name="x" /></xsl:arguments><xsl:body>...</xsl:body></xsl:function>
07:53:07 <EvilTerran> i mean, seriously. you've got "lambda" and "define" as two constructs you need a lot.
07:53:23 <ndm> and XSL is a purely functional language!
07:53:31 <jedai> EvilTerran: On that you're indeed completely right ! At least when you need a lambda in Haskell it's still pretty easy to use
07:53:32 * ddarius doesn't mind define at all.
07:53:33 <EvilTerran> perl calls these "sub" and "my" respectively, and that's not even meant to be a functional language.
07:53:56 <scook0> well, Larry is a big fan of "Huffmanization"
07:53:58 <EvilTerran> haskell calls them "\ ->" and "" :D
07:54:06 <EvilTerran> well, "=", i guess
07:54:12 <jedai> ndm: Don't speak about XSL as if it was a real language !! ;-)
07:54:26 <EvilTerran> ndm, AAAAAAHHHHHHH </rabbid>
07:54:40 <ndm> jedai: its horrible, but it is one of the two turing complete languages which will run natively in browsers
07:54:41 <ricky_clarkson> The long syntax for lambdas in lisp doesn't affect how much people use lambdas, I think.
07:54:50 <jedai> EvilTerran: Or let, or where, if you're not on the module level
07:54:52 <ricky_clarkson> Common Lisp's funcall and sharpquote affect things more imo.
07:55:13 <EvilTerran> ricky_clarkson, are those identifiers?
07:55:14 <chessguy> ndm, only two?
07:55:31 <mrd> ocaml functions are hideously obnoxious to write
07:55:34 <ndm> chessguy: that i can think of, ecmascript and xsl - what others?
07:55:43 <mrd> and they really do claim to be functional
07:55:55 <ricky_clarkson> EvilTerran: CL has a separate namespace for functions than variables, so if you want to call a function that's referred to by a variable, you get: (funcall the-var the-args).
07:56:10 <ricky_clarkson> EvilTerran: And if you want to get a function as a value, you get #'the-function
07:56:32 <ricky_clarkson> Scheme lacks that retardation.
07:56:36 <mrd> dude
07:56:40 <mrd> there's a very good reason for it
07:56:41 <chessguy> hmm. you're probably right, I can't think of any others. that's just surprising
07:56:47 <mrd> and scheme lacks that cause
07:56:51 <mrd> macros
07:57:03 <jedai> EvilTerran: Perl as a functional language is quite good in fact (well, it's not really one, but you have a good subset)
07:57:20 <ricky_clarkson> Scheme supports macros, albeit hygienic - and most implementations support unhygienic macros anyway.
07:57:21 <ddarius> mrd: Most schemes have macros.
07:57:25 <mrd> not like CL macros
07:57:29 <EvilTerran> ricky_clarkson, wrt CL there... eeeeew
07:57:36 <ddarius> Most Schemes have CL macros.
07:57:39 <scook0> Lisp-1 vs. Lisp-2 is one of the classic flamewars
07:57:41 <mrd> the reason why Scheme absolutely HAS to have hygenic macros is because it has a single namespace
07:57:43 <EvilTerran> jedai, yeah, i agree.
07:57:59 <ddarius> mrd: Most Schemes have unhygenic macros.
07:58:11 <mrd> CL can get away with unhygenic macros because it doesn't affect normal practice -- because it is a Lisp-2
07:58:13 <ricky_clarkson> ddarius: Keep saying it. ;)
07:58:21 <mrd> and here's the very easy example of why:
07:58:36 <ddarius> mrd: Your statements are flying in the face of reality.
07:58:38 <jedai> EvilTerran: I think of Haskell as Perl on Acid, it's got the same philosophy but with strong typing, monads and referential transparency (might be because Perl and Haskell are my two favorite languages) :P
07:58:43 <mrd> (let ((list ...)) ... (macro-that-uses-list ...))
07:58:55 <mrd> ddarius: dude, I've hashed this out way more than you
07:59:05 <mrd> I've programmed CL for many years and do it professionally now
07:59:39 <mrd> in a Lisp-1, the macro in the above code will break
07:59:43 <EvilTerran> jedai, hooray! they're my two favourites, too! :D
07:59:46 <mrd> in a Lisp-2, it will not
07:59:50 <mrd> it's a total hack, but it works
08:00:05 <ddarius> mrd: That doesn't make your statements not patently false.   Scheme doesn't "absolutely HAVE to have hygenic macros" clearly if it also has unhygenic macros".
08:00:18 <mrd> it does, but they are much more risky to use
08:00:30 <mrd> also schemers tend to use obfuscated variable names like 'lst'
08:00:34 <ricky_clarkson> mrd: You could replace a variable and call a macro and get the same results.
08:01:08 <mrd> ricky_clarkson: except that proper macros always use freshly bound names.  Yes you can fuck yourself over if you don't do this, but... it's CL.
08:01:32 <ricky_clarkson> mrd: I'm not talking about gensym, just a macro whose expansion uses a global.
08:01:51 <mrd> there are no global variables in CL.  just special ones.
08:02:04 <mrd> and by special they mean "dynamically scoped"
08:02:09 <ricky_clarkson> PCL happily calls them globals.
08:03:42 <mrd> Portable Common LOOPS?
08:04:00 <ricky_clarkson> I think the other reason macros are popular is that you cannot denote that a CL function's arguments should be lazily evaluated.
08:04:10 <mrd> certainly
08:04:20 <mrd> it's not the only use, but it is about 80% of them
08:04:37 <ricky_clarkson> Practical Common Lisp, by Peter Seibel, who is idling here as it happens.
08:05:02 <mrd> yes, I know him ;) I was just kidding. before that book came out, PCL was commonly used to reference the portable CLOS implementation
08:06:50 <mrd> refering to Lisp-1 vs Lisp-2 as "just a flamewar" shows a complete misunderstanding of the issue.  There are very good solid reasons for Scheme to be a Lisp-1, and very good solid reasons for CL to be a Lisp-2.  They are completely different languages with different goals.
08:07:23 <ricky_clarkson> My only point on the matter was that I expect funcall and sharpquote to discourage FP somewhat.
08:07:31 <mrd> yes, and CL is not a functional language.
08:08:26 <scook0> mrd: well, I didn't intend to suggest it was "just" a flamewar, merely that flamewars can be the result of it
08:09:50 <mrd> the fact that CL is not a functional language is a good part of the reason why I'm here
08:10:21 <cizra> How is it not? What determines if a language is "functional"?
08:10:35 <mrd> the way it is used
08:10:49 <ddarius> functional assembly ho!
08:11:31 <ddarius> mrd: If it was just the way it used, you could just use CL as a functional language (modulo the 3rd party stuff)
08:12:04 <mrd> programming functionally in CL causes detriment.  the language doesn't support you.  the compilers don't support you.  the libraries don't support you.  Haskell is completely the opposite in that regard.
08:12:23 <ddarius> mrd: So it's language/compiler/library support, not just the way you use it.
08:12:32 <mrd> that is the way you use it
08:12:58 <mrd> use as in "practical usage"
08:13:25 <DRMacIver> ddarius: Perhaps "The way it is idiomatically used", which is very dependent on all those factors?
08:13:58 <DRMacIver> ddarius: There are a lot of idioms which feel very unnatural in a given language. You 'can' write Java functionally, but it's sure as hell not a functional language. :)
08:14:26 <ddarius> DRMacIver: They don't feel unnatural in Java just because people don't use it that way.
08:14:40 <DRMacIver> ddarius: No, but people don't use it that way because it feels unnatural. :)
08:15:15 <DRMacIver> (And because most Java programmers' heads explode when they see a lambda)
08:15:43 <DRMacIver> ddarius: I'm suggesting that what matters is not how you *can* use a language, but the way it feels natural to use it.
08:15:44 <ddarius> If there is a reason people don't use Java in a functional way, then that reason should be why Java isn't a functional language, not the fact that people don't use it that way.
08:15:58 <lemmih_> ndm: Hiya, is your "Faster Haskell" paper out?
08:16:07 <pgavin> I tried programming Java functionally
08:16:16 <pgavin> it failed miserably at that
08:16:29 <DRMacIver> pgavin: Yes, so have I. It's nasty. :) But you can do it if you perservere.
08:16:34 <DRMacIver> err. persevere
08:16:52 <ddarius> perversevere
08:16:56 <pgavin> DRMacIver: I'd rather just program in haskell :)
08:17:10 <DRMacIver> Yes, so would I. I'm not saying it's a good idea. :)
08:17:15 <EvilTerran> it's incredibly verbose, ugly, and is slower than programming imperatively in java.
08:17:16 <DRMacIver> I'm saying quite the opposite in fact.
08:17:27 <ndm> lemmih_: its written, but contains no additional results over my blog posts - although quite a bit more of the method and details
08:17:31 <EvilTerran> (slower to write and/or to execute; pick your favourite)
08:17:46 <ndm> i can upload a temporary copy, i'll put it on my website next week
08:18:29 <ndm> it would have been up sooner, but i'm having quota issues...
08:19:29 <ndm> i'm also disappointed with the results and the method, i have something much better in the works...
08:21:21 <ricky_clarkson> I program Java functionally, and yes, it's annoying, but it's ok, especially since Java 5.
08:22:24 <ndm> lemmih_: http://www-users.cs.york.ac.uk/~ndm/temp/draft-supero.pdf
08:22:36 <ndm> will be gone by Monday, and moved to the proper place on my website
08:22:53 <ricky_clarkson> DRMacIver: I don't think most Java programmers' heads explode when they see a lambda, especially if you present it as a Runnable or a Comparator.
08:22:58 <DRMacIver> ricky_clarkson: Sorry, but I've seen your code. It's not ok. ;)
08:23:15 <ricky_clarkson> What you saw dates from my first attempt. ;)
08:23:56 <DRMacIver> ricky_clarkson: Most *good* Java programmers can handle a lambda if you give it a silly name. :)
08:24:08 <ricky_clarkson> It's an enterprise anonymous class?
08:24:10 <DRMacIver> That's not really the same thing as most java programmers.
08:24:36 <DRMacIver> I meant 'runnable' or 'comparator' :)
08:24:50 <ricky_clarkson> DRMacIver: Lambdas are understandable to people who have never programmed before.
08:25:08 <DRMacIver> Yes.
08:25:18 <DRMacIver> People who have programmed before seem to have a harder time. :)
08:26:34 <araujo> it's because lambda calculus follow mathematical principles we all have taught since we are child
08:26:46 <araujo> been*
08:27:46 <araujo> then imperative programming screws our brains with those side-effects :-)
08:28:17 <ricky_clarkson> And crap static typing does us in further with 1/2==0
08:28:52 <int-e> > let (/) = div in 1/2 == 0 -- *ducks*
08:28:58 <lambdabot>  True
08:29:28 <DRMacIver> ricky_clarkson: I don't agree that that has anything to do with static typing. It has to do with poor choices of operator names. :)
08:30:04 <int-e> when all you have is / everything looks like division.
08:30:33 <int-e> ascii and single character operator names are so limiting.
08:30:34 <ricky_clarkson> > let (=)=(==) in 1=2
08:30:34 <lambdabot>  Parse error
08:30:39 <ricky_clarkson> Grr.
08:30:53 <EvilTerran> the problem is ad hoc polymorphism without rigidly defined semantics for the instances to follow
08:31:14 <DRMacIver> The problem is too many people trying to assign blame.
08:31:40 <ibid> ah, darcs-monitor was just accepted from NEW
08:31:44 <ibid> nice
08:32:06 <EvilTerran> okay, *a* problem
08:32:36 <EvilTerran> imagine if you programmed in haskell by having a fresh typeclass for every function
08:32:56 <DRMacIver> I've often thought that sounded like a good idea, personally. :)
08:33:00 * ricky_clarkson goes to line the pockets of $tarbucks.
08:33:30 <EvilTerran> instance SlashOp Float where (/) = ...; instance SlashOp Int...; instance SlashOp String... >:]
08:33:32 <ibid> and i notice it fails to build on many architectures as they don't support runghc
08:34:16 * DRMacIver shrugs
08:34:29 <DRMacIver> EvilTerran: Without a turing complete type checker, there's no way to prevent programmers from doing stupid things. :)
08:34:43 <matthew-_> DRMacIver: shotgun
08:34:46 <int-e> the type checker is already turing complete :)
08:34:58 <EvilTerran> class NotAStupidIdea ....
08:35:25 <DRMacIver> int-e: In the 'turing test' rather than computational power sense. :)
08:35:26 <DRMacIver> matthew-_: Hm?
08:35:32 <matthew-_> int-e: only with certain flags. And even then it has limited recursion (unless I'm forgetting something)
08:35:46 <matthew-_> DRMacIver: point a shotgun at the programmers. If they do something stupid they die.
08:35:54 <DRMacIver> matthew-_: Ok, no automated way.
08:36:01 <matthew-_> DRMacIver
08:36:11 <int-e> matthew-_: you can write an S-K-calculus interpreter in the type system
08:36:11 <matthew-_> DRMacIver: it needs the human touch!
08:36:25 <DRMacIver> matthew-_: That's what I'm *saying*. :)
08:36:37 <matthew-_> int-e: without exploding the stack?
08:36:44 <DRMacIver> matthew-_: The language can't prevent programmer stupidity unless your typechecker is an AI. :)
08:37:47 <luqui> matthew-_, right, type checker is decidable without -fallow-undecidable-instances
08:38:08 <EvilTerran> and then it has a limited recursion depth
08:38:17 <luqui> well so does haskell
08:38:34 <luqui> but that's just a technicality
08:38:51 <luqui> the type checker is just running on a significantly less powerful computer, you might say
08:39:03 <int-e> matthew-_: hmm, yes. The equivalent of (S I I) (S I I) just eats memory slowly.
08:40:51 <int-e> matthew-_: I'm not sure. You may be right, I didn't really stress-test that.
08:41:32 <araujo> DRMacIver, I think that a 'language' can really prevent serious errors. A language is just a way of express your thoughts and at the same time, the language influences those thoughts. So, a crappy language can really make you code wrongly.
08:42:47 <DRMacIver> araujo: Well, a language can certainly prevent *errors*, but that's not the same as stupidity. Similarly a language can encourage a good style while discouraging a bad one.
08:43:32 <DRMacIver> I'm specifically saying that you can't have a (sufficiently expressive) language in which it's actually impossible to say/do stupid things.
08:43:59 <matthew-_> DRMacIver: have you looked at Perfect Developer?
08:44:32 <DRMacIver> Never heard of it. What is it?
08:44:39 <matthew-_> not really sure
08:44:55 <matthew-_> but I think it does stuff
08:45:02 <araujo> DRMacIver, There is no need for that. You only need a language with a good and simple logical or in this case mathematical foundation. The rest is up to the programmers.
08:45:10 <DRMacIver> araujo: I agree.
08:45:20 <DRMacIver> Did I suggest otherwise?
08:45:36 <DRMacIver> If so, sorry. :)
08:45:47 <DRMacIver> matthew-_: 'does stuff' is nice and specific. :)
08:45:57 <ddarius> "guaranteed to behave according to precise specifications and meet user requirements"
08:46:06 <matthew-_> aka "stuff"
08:46:26 <araujo> DRMacIver, i just commented ... about the part of preventing 'stupidity' , a language can really help to avoid common mistakes or so called stupid coding
08:46:33 <ddarius> So can I get my money back if the code doesn't meet user requirements?
08:47:05 <ddarius> araujo: Which is something he said, in that sentence he was talking about possibility.
08:47:35 <DRMacIver> I'm having trouble with simultaneously holding the concepts of 'precise specifications' and 'user requirements' in my mind. :)
08:47:47 <araujo> ok, i see :-)
08:47:50 <araujo> good then
08:48:48 <int-e> matthew-_: the worst I've done is calculate 3^5 on the type level (using church numerals encoded in the S-K-I-calculus). ghc seemed to be happy to do it, it just took some time.
08:49:12 <matthew-_> mmm. interesting.
08:49:35 <matthew-_> just with allow-inconsistent and/or allow-overlapping?
08:49:57 <int-e> without overlapping. with multi parameter type classes and a functional dependency.
08:50:52 <mornfall> PD sounds like a marketing bluff
08:51:02 <matthew-_> mmm. In which case I must be confused about what types of computation ghc does and doesn't allow in types
08:51:23 <int-e> I can paste the code if you're interested
08:52:05 <DRMacIver> matthew-_: It only allows morally upright ones.
08:52:09 <ddarius> matthew-_: It quite easy.  With -fallow-undecidable-instances, all computations are allowed.
08:52:11 <EvilTerran> the important one'd be allow-undecitable
08:52:15 <EvilTerran> *d
08:52:41 <EvilTerran> sometimes -overlapping's helpful, but that's generally only if you need a "default" case or somesuch
08:52:43 <kep> lambdabot: :help
08:52:47 <cizra> Why does snd fst (1, 2) not work?
08:52:52 <kep> lambdabot: /help
08:52:57 <EvilTerran> @help
08:52:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:52:59 <ddarius> :t snd fst
08:53:01 <lambdabot>     Couldn't match expected type `(a, b)'
08:53:01 <lambdabot>            against inferred type `(a1, b1) -> a1'
08:53:05 <roconnor> > (snd &&& fst) (1,2)
08:53:07 <lambdabot>  (2,1)
08:53:21 <ddarius> cizra: You are applying snd to fst and (1,2)
08:53:35 <chessguy> @type gets
08:53:37 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
08:53:40 <cizra> And so? It should curry.
08:53:41 <EvilTerran> kep, you *do* realise you're saying "lambdabot: :help" to #haskell, not messaging lambdabot privately, right?
08:53:50 <mornfall> cizra: it should what?
08:53:53 <cizra> @let foo = snd fst
08:53:54 <lambdabot> Couldn't match expected type `(a, b)'
08:53:58 <cizra> hmmm
08:54:03 <cizra> Hm, not curry
08:54:05 <EvilTerran> cizra, that's got nothing to do with curry
08:54:06 <cizra> What's the term?
08:54:14 <mornfall> cizra: dunno, but snd wants a tuple
08:54:19 <mornfall> cizra: and fst is not a tuple
08:54:23 <cizra> *nod*
08:54:26 <EvilTerran> cizra, what do you want the result to be?
08:54:27 <cizra> This explains.
08:54:28 <roconnor> @type snd . fst
08:54:30 <lambdabot> forall a b b1. ((a, b), b1) -> b
08:54:38 <cizra> Do functions bind more tightly to left then?
08:54:44 <EvilTerran> yes
08:54:50 <kep> EvilTerran thanks
08:54:55 <cizra> So it becomes (snd fst) (1, 2)
08:54:58 <ddarius> Yes
08:55:00 <cizra> *nod* Now I see.
08:55:03 <mornfall> that too, but even snd $ fst (1, 2) won't do what you want
08:55:06 <mornfall> well
08:55:08 <mornfall> whatever you want :][
08:55:08 <gpi5> Why is concat of type [[a]]->[a] and not [a]->[a]->[a] ? Strange...
08:55:18 <cizra> > snd $ fst (1, 2)
08:55:19 <lambdabot>   add an instance declaration for (Num (a, b))
08:55:19 <lambdabot>     In the expression: 1
08:55:22 <int-e> gpi5: (++) is append
08:55:26 <roconnor> @type  (++)
08:55:26 <EvilTerran> this being why "map f e xs" isn't "map (f (e xs))" , cizra
08:55:29 <lambdabot> forall a. [a] -> [a] -> [a]
08:55:41 <cizra> > snd ( fst (1, 2) )
08:55:42 <lambdabot>   add an instance declaration for (Num (a, b))
08:55:42 <lambdabot>     In the expression: 1
08:55:54 <cizra> > snd ( fst ((1, 3), 2) )
08:55:56 <chessguy> @type map ?f ?e ? xs
08:55:56 <lambdabot>  3
08:55:56 <kep> @list
08:55:58 <lambdabot> Not in scope: `?'
08:55:58 <lambdabot>  
08:55:58 <lambdabot> <interactive>:1:12: Not in scope: `xs'
08:55:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:56:01 <cizra> > snd $ fst ((1, 3), 2)
08:56:02 <lambdabot>  3
08:56:02 <chessguy> @type map ?f ?e ?xs
08:56:04 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `[b]'
08:56:12 <mornfall> cizra: bingo.
08:56:13 <cizra> OK, now I understand.
08:56:34 <cizra> And $ means "bind less tightly here, will you?" between functions.
08:56:48 <mornfall> :t ($)
08:56:48 <EvilTerran> kinda
08:56:50 <lambdabot> forall a b. (a -> b) -> a -> b
08:57:07 <gpi5> int-e: so concat [a,b] === a++b ?
08:57:11 <cizra> > odd $ 2 + 1
08:57:12 <EvilTerran> $ is just an operator with a really low precedence that applies the thing on the left to the thing on the right
08:57:12 <lambdabot>  True
08:57:13 <int-e> gpi5: yes
08:57:17 <cizra> > odd 2 + 1
08:57:18 <lambdabot>   add an instance declaration for (Num Bool)
08:57:18 <lambdabot>     In the expression: (odd 2) +...
08:57:27 <gpi5> int-e: thanks
08:57:41 <chessguy> > odd $ 2+1
08:57:42 <lambdabot>  True
08:58:04 <mornfall> ...
08:58:19 <mornfall> yes, haskell is deterministic :)
09:00:48 <cizra> I exploited ghci to do some dumb work for me (formula calculations) recently. It felt so nice.. And only after that it hit me that just about any language know would do it equally fast, equally easily and equally well. Doh.
09:01:21 <mornfall> *shrug*
09:01:46 <chessguy> but not as safely or elegantly
09:07:00 <gpi5> > \a -> \b -> concat [a,b] = (++)
09:07:01 <lambdabot>  Parse error
09:07:10 <gpi5> > \a -> \b -> concat [a,b] == (++)
09:07:11 <lambdabot>  Couldn't match expected type `[a]'
09:07:13 <Cale> cizra: that's not true of all calculations though. I find it's really nice to use the list monad for doing brute force (or even slightly clever) searches for solutions to things
09:08:18 <cizra> Cale: Gimme a gentle example?
09:09:18 <Cale> Well, here's an example which is easy with just list comprehensions:
09:09:40 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
09:09:45 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
09:10:19 <Cale> The list monad gives you lots of other combinatorial stuff to play with though.
09:10:27 <cizra> Hmmmm.. Generate a list of (x, y, z) such that x is in [1..20], ..., and so on
09:10:39 <cizra> I can get the meaning, although most of the operators are unfamiliar.
09:10:59 <Cale> > filterM (const [False,True]) [1..5]
09:11:01 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
09:11:08 <Cale> > filterM (const [False,True]) [1..3]
09:11:09 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
09:11:30 <Cale> > filterM (const [True,False]) [1..3]
09:11:31 <xerox> > filterM (const [True,False]) [1..3]
09:11:33 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:11:34 <xerox> hehe
09:11:34 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:11:39 <cizra> Please point me to a place where I could look up stuff like filterM easily.
09:11:39 <xerox> I was wondering... :)
09:11:50 <Cale> It's in Control.Monad
09:11:53 <Cale> :t filterM
09:11:55 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:12:10 <Cale> But here's how you think about that...
09:12:30 <Cale> In the list monad, you "run" a list by trying each of its elements in turn.
09:12:51 <Cale> > do { x <- [1,2,3]; y <- [True, False]; return (x,y) }
09:12:53 <lambdabot>  [(1,True),(1,False),(2,True),(2,False),(3,True),(3,False)]
09:13:13 <cizra> *sigh*
09:13:47 <Cale> What filterM does is like filter, except that instead of just applying the element of the list to a function which returns a plain boolean
09:14:03 <Cale> the function returns an action which when run gives a boolean
09:14:16 <Cale> in this case, a list of bools
09:14:25 <Cale> [True, False]
09:14:50 <Cale> Which means that it will try all possibilities of keeping each element or throwing it away
09:15:06 <Cale> @src filterM
09:15:07 <lambdabot> Source not found. That's something I cannot allow to happen.
09:15:12 <Cale> oh, come on
09:15:33 <Cale> filterM p [] = []
09:15:48 <cizra> OK
09:16:01 <Cale> filterM p (x:xs) = do { b <- p x; ys <- filterM p xs; return (if b then (x:ys) else ys) }
09:16:28 <Cale> So here, remember that p was (const [True, False])
09:16:43 <cizra> What is <-? What is const?
09:16:50 <cizra> You're rushing way ahead of my level.
09:16:54 <Cale> Ah, okay
09:17:21 <Cale> Well, in this context
09:17:34 <Cale> x <- xs means to pick x from the list xs in all possible ways
09:17:49 <cizra> OK
09:18:01 <cizra> > 2 [1, 2, 3]
09:18:03 <Cale> > do { x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z) }
09:18:03 <lambdabot>   add an instance declaration for (Num ([t] -> a))
09:18:04 <lambdabot>     In the expression: 2 [...
09:18:04 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
09:18:06 <cizra> > 2 <- [1, 2, 3]
09:18:07 <lambdabot>  Parse error
09:18:15 <Cale> It needs to be inside a do-block
09:18:25 <cizra> > do {2 <- [1, 2, 3]}
09:18:25 <lambdabot>  Parse error
09:18:37 <Cale> and the last line in a do-block can't be one of those
09:18:42 <Cale> it has to be a list
09:18:43 <cizra> > do { x <- [1, 2, 3]; return x }
09:18:44 <lambdabot>  [1,2,3]
09:18:56 <ndm> @seen Heffalump
09:18:57 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 5h 26m 38s ago.
09:19:00 <Cale> and it'll build you a list which makes those choices
09:19:32 <Cale> > do { x <- [1,2,3]; y <- replicate x x; return y }
09:19:33 <lambdabot>  [1,2,2,3,3,3]
09:19:53 <Cale> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) }
09:19:55 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
09:19:56 <cizra> \o/ procreation
09:20:36 <Cale> there's all possible pairs of elements from [1,2,3] and [4,5] -- a Cartesian product.
09:20:43 <luqui> oooh list monad
09:20:43 <cizra> OK, it seems I got the <- stuff.
09:20:49 <luqui> quite possibly my favorite monad
09:21:01 <Cale> Okay, and const is easy
09:21:05 <Cale> const k x = k
09:21:23 <cizra> Where does x disappear? Just ignored?
09:21:25 <Cale> (const k) is the function which ignores its parameter and gives k
09:21:37 <Cale> That is, the constant function giving k
09:21:46 <cizra> What for?
09:22:21 <Cale> Well, in our case, we want to ignore what the actual element of the list is, and give [True, False] as a decision of sorts for whether to keep it.
09:22:31 <cizra> OK
09:22:44 <Cale> Of course, that's kind of a funny decision -- more of an indecision really :)
09:22:51 <cizra> > filterM (const [True,False]) [1..3] -- for easy reference
09:22:53 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:23:39 <Cale> So, the first time it goes and takes True each time, then it backtracks and tries picking false for the 3rd element, then some more, and picks false for the second, true for the 3rd
09:23:42 <Cale> and so on
09:24:00 <cizra> *nod*
09:24:21 <Cale> Once you're used to it, it's a very powerful idiom.
09:24:44 <cizra> What? const or filterM?
09:25:00 <Cale> The list monad, which is what we're using with filterM here
09:25:11 <cizra> OK
09:25:36 <cizra> This stuff is strange and uncomfortable. Kinda like the underwear of the opposite sex.
09:25:44 <cizra> But it can be fun as well. Kinda like the underwear of the opposite sex.
09:25:48 <Cale> heh
09:26:08 * shapr laughs
09:26:23 <shapr> cizra: What languages are you already comfortable with?
09:26:30 <Cale> So, back to that list comprehension example...
09:26:33 <cizra> C, C++, Ruby, Java
09:26:39 <cizra> A bit of Python
09:26:48 <gpi5> In my code, r is a Rational but can safely be converted to Integer (denominator is 1). What's equivallent of assert(denominator r == 1) in Haskell?
09:27:05 <shapr> Ah, Python and Ruby are bit closer to Haskell than C/Java.
09:27:09 <cizra> yes
09:27:36 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2] -- this is rather like the list monad -- it tries all possibilities of choosing x,y, and z, and tests whether x^2 + y^2 == z^2 before returning the result.
09:27:37 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
09:27:53 <Cale> (and when it fails, the choice doesn't get returned)
09:27:54 <xerox> ?type \r -> Control.Exception.assert (denominator r == 1) -- gpi5
09:27:56 <lambdabot> forall a a1. (Integral a) => Ratio a -> a1 -> a1
09:27:56 <xerox> ;-)
09:28:21 <Cale> > do { x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z) }
09:28:21 <cizra> Yes, this one seems pretty easy
09:28:22 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
09:28:29 <Cale> There it is in do-notation
09:28:33 <gpi5> xerox - thx
09:28:46 <cizra> (in the light of the do {stuff} block)
09:29:02 <Cale> guard b = if b then return () else []
09:29:20 <shapr> cizra: Anyone who learns Haskell to do a fib assignment in a language their teacher won't expect fits right into #haskell :-)
09:29:32 <cizra> shapr: Guess what my name means.
09:29:45 <Cale> or perhaps this would be slightly less confusing...
09:29:49 <Cale> guard b = if b then [()] else []
09:30:05 <shapr> cizra: It means 'being strange'
09:30:13 <cizra> Guard? Is it sorta like exceptions?
09:30:16 <Cale> imagine that the guard (x^2 + y^2 == z^2) is having an element chosen from it too, it's just not being used
09:30:17 <shapr> xu do tavla mi bau la lojban
09:30:19 <chessguy> @pl update ref f s = set ref (f (get ref s)) s
09:30:19 <lambdabot> update = flip flip id . (ap .) . ap ((.) . (.) . set) (flip (.) . get)
09:30:23 <cizra> ka'e go'i
09:30:23 <chessguy> wheee
09:30:27 <shapr> je'e
09:30:43 <Adamant> ok, Lojban is just crazy
09:30:49 <shapr> mi djica lenu mi gunka
09:31:10 <cizra> bai ma na gunka
09:31:29 <roconnor> take it to the lojban haskell channel.
09:31:36 <Cale> heh
09:31:39 <Adamant> why not learn a language that more people speak. like Basque.
09:31:48 <shapr> There's nobody on #haskell.jbo !
09:31:51 <cizra> 'cuz Lojban fits Haskell better.
09:31:56 <Adamant> true
09:33:15 <Cale> cizra: anyway, with a little more work, you can use this sort of thing to solve puzzles.
09:33:23 <Adamant> I wonder sometimes if illogical natural languages are more powerful than logical ones.
09:33:41 <chessguy> i'm sure they're both turing complete
09:33:56 <cizra> Cale: sounds more amazing than "amazing" usually conveys.
09:36:47 <chessguy> @pl g s = c (g' s) (f s)
09:36:47 <lambdabot> g = liftM2 c g' f
09:37:03 <chessguy> eh?
09:37:51 <chessguy> @pl g s = c $ (g' s) (f s)
09:37:51 <lambdabot> g = c . ap g' f
09:37:56 <chessguy> ...
09:37:58 <chessguy> wtf
09:38:14 <chessguy> has @pl gone bonkers?
09:38:57 <Cale> chessguy: no
09:39:05 <Vq^> chessguy: i believe not
09:39:14 <Cale> chessguy: that works quite well
09:39:38 <Cale> ap g' f s = g' s (f s)
09:39:40 <chessguy> ok, first of all, why did it interpret those 2 things differently?
09:39:52 <Cale> because they are quite different
09:40:05 <Cale> In the first, c is applied to two parameters
09:40:12 <Cale> in the second, it's applied to one
09:40:18 <chessguy> err
09:40:18 <byorgey> chessguy: remember, function application associates to the left
09:40:39 <chessguy> oh
09:40:43 <chessguy> duh
09:40:46 <byorgey> a b c == (a b) c;  a $ b c == a (b c)
09:40:52 <monochrom> I'm sure illogical languages are more powerful than logical languages, viz, an inconsistent theory proves more theorems than a consistent theory.
09:40:55 <chessguy> the first is what i actually meant
09:41:07 <chessguy> but i don't see what it has to do with liftM2
09:41:09 <chessguy> what's the monad?
09:41:25 <byorgey> It's the (env ->) monad
09:41:27 <monochrom> IOW, illogical languages are so utterly powerful that they are utterly useless.
09:41:40 <chessguy> oh
09:41:41 <chessguy> figures
09:42:44 <cizra> monochrom: Surely! Just as programming asm is more powerful and general than Haskell.
09:43:55 <dons> ?users
09:43:55 <lambdabot> Maximum users seen in #haskell: 402, currently: 386 (96.0%), active: 17 (4.4%)
09:43:55 <jcreigh> "programming in asm" is the "just like Hitler" of programming language debates. :)
09:44:26 <monochrom> Nazis wrote in asm.
09:44:38 <roconnor> @quote law
09:44:38 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
09:44:54 <roconnor> @quote discussion
09:44:54 <lambdabot> No quotes match. My mind is going. I can feel it.
09:45:01 <monochrom> That one is illustrating a lazy sequence of laws. :)
09:45:29 <monochrom> Indeed (2) is a thunk for the rest of the laws.
09:45:33 <cizra> jcreigh: Since every program gets reduced to asm eventually, they can only reduce the possibilities offered by asm. Not that anyone wants to write asm...
09:45:40 <monochrom> You should now say "lawl". :)
09:46:14 <Adamant> Godwin's Law of Programming Debates - Hitler = ASM
09:46:40 <dons> ndm: hehe. just read your reply. seems we think on the same wave length
09:46:58 <ndm> dons: indeed, i just couldn't leave any paragraph untouched
09:47:17 <ndm> dons: but i have not the slightest idea about database in Haskell, i'm waiting for your book before i learn :)
09:48:37 <hpaste>  Japsu pasted "Omigod, practical use for the list monad!!!" at http://hpaste.org/2627
09:49:47 <dons> ndm, people use hdbc, takusan, and bos just wrote another mysql binding
09:49:48 <sjanssen> dons++ ndm++ way to beatdown the FUD :)
09:49:57 <byorgey> Japsu: heh, nice
09:50:00 <Japsu> ;)
09:50:09 <dons> sjanssen: the pity is: those were trivial things. i would have liked to see some really `impossible' problems :)
09:50:24 <ndm> dons: i'm the only professional web developer who always just uses a flat file, since databases are too much hassle
09:50:33 <dons> heh.
09:50:55 <dons> i should have demoed compress . encode for serialising and gzipping. hmm
09:51:43 <gpi5> I know takeWhile. Is there something like takeFirst ?
09:51:49 <Japsu> @remember Adamant Godwin's Law of Programming Debates - Hitler = ASM
09:51:49 <lambdabot> Done.
09:52:13 <dons> > head [1..] -- ?
09:52:14 <lambdabot>  1
09:52:15 <ndm> gpi5: you want the first thing that matches a predicate?
09:52:21 <xerox> gpi5: find
09:52:25 <gpi5> ndm : yes
09:52:26 <dons> :t find
09:52:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:52:45 <ndm> i had never heard of find...
09:53:16 <gpi5> find is not in scope here??
09:53:22 <xerox> ?index find
09:53:22 <lambdabot> Data.List
09:53:26 <dons> sjanssen: btw, xmonad seems to be running rather nicely on core 2 duo/openbsd
09:53:37 <cizra> ♡xmonad♥
09:53:40 <byorgey> gpi5: just add 'import Data.List' to the top of your file
09:53:52 <gpi5> ok, thanks.
09:53:53 <dons> > find isSpace "haskell is fun"
09:53:55 <lambdabot>  Just ' '
09:54:03 <dons> > findIndex isSpace "haskell is fun"
09:54:04 <lambdabot>  Just 7
09:54:07 <xerox> > findIndices isSpace "haskell is fun"
09:54:08 <lambdabot>  [7,10]
09:54:17 <cizra> > find mySpace "I'm fun as well"
09:54:17 <lambdabot>   Not in scope: `mySpace'
09:54:31 <xerox> haha.
09:54:52 <roconnor> @go 4 oz in g
09:54:55 <lambdabot> 4 ounces = 113.398093 grams
09:55:02 <FMotAFK> :/
09:55:16 <FMotAFK> imperial system = bad
09:55:32 <cizra> FMotAFK: Not necessarily, just outdated.
09:55:56 <Cale> It's bad compared to SI
09:55:56 <roconnor> @go 2 lb in g
09:55:58 <lambdabot> 2 pounds = 907.18474 grams
09:56:01 <FMotAFK> if you assume that outdated = bad, then imperial system = bad
09:56:18 <FMotAFK> and yes, the imperial system is bad anyway :/
09:56:22 <gpi5> find is not found even though I import Data.List ??
09:56:30 <Cale> @index find
09:56:30 <lambdabot> Data.List
09:56:33 <Cale> hmm
09:56:37 <Cale> :t find
09:56:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:56:57 <Cale> > find even [3,5,1,6,1,8]
09:56:58 <lambdabot>  Just 6
09:57:10 <Japsu> @t findAll
09:57:10 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:57:13 <byorgey> gpi5: can't find find, eh?
09:57:15 <Japsu> :t findAll
09:57:17 <lambdabot> Not in scope: `findAll'
09:57:19 <Japsu> bah
09:57:20 <Cale> Japsu: filter
09:57:23 <Japsu> o
09:57:24 <Japsu> *oh
09:57:25 <Japsu> right ;)
09:57:30 <Cale> > filter even [3,5,1,6,1,8]
09:57:31 <lambdabot>  [6,8]
09:57:42 <Japsu> yeah
09:57:50 <gpi5> byorgey: yes:) I've ghc
09:57:56 <byorgey> gpi5: hmm... what version?
09:58:04 <Adamant> we will all be incorrect until we use Kelvins for daily temperature readings
09:58:12 <gpi5> Lastest 6.6.1 I think
09:58:22 <byorgey> @go 81 F in Kelvin
09:58:23 <lambdabot> 81 degrees Fahrenheit = 300.372222 kelvin
09:58:39 <byorgey> sweet!  it's 300 Kelvin here =)
09:58:44 <cizra> Adamant: http://en.wikipedia.org/wiki/Rankine_scale
09:58:45 <Cale> Heh, 300 K means more to me than 81 F
09:58:46 <lambdabot> Title: Rankine scale - Wikipedia, the free encyclopedia
09:59:10 <byorgey> @go 81 F in Celsius
09:59:11 <lambdabot> 81 degrees Fahrenheit = 27.2222222 degrees Celsius
09:59:21 <FMotAFK> Adamant: not necessarily.
09:59:37 <byorgey> gpi5: maybe hpaste your code?
10:00:01 <Cale> It's easy to go between C and K, you just add/subtract 273.15
10:00:13 <FMotAFK> yup
10:00:18 <byorgey> ah, right
10:00:24 <gpi5> Ok, Data.List.find exists but I cannot use 'find'. Weird!
10:00:29 * byorgey wishes the US used SI units =(
10:00:58 <luqui> what is the lambek-lawvere correspondence?
10:01:13 <byorgey> gpi5: are you in ghci, or compiling?
10:01:22 <sorear> cartesion closed categories and lambda calculus, IIRC
10:01:29 <luqui> and what is the former?
10:01:37 <gpi5> byorgey: ghci
10:01:38 <Cale> byorgey: Maybe you'd crash fewer space missions. ;)
10:01:51 <byorgey> Cale: =P
10:01:57 <Adamant> Cale, we wouldn't crash if you would just adopt customary. :)
10:02:33 * sorear points NASA at the Haskell dimensional-numbers library
10:03:14 <FMota> Adamant: I find it hard to take anything you say about change seriously with a username like "adamant"
10:03:18 <Cale> NASA should just fire anyone who mentions imperial units.
10:03:39 * roconnor thinks our temperature scale is upside down
10:03:45 <Adamant> anyway. the problem is that the government has already tried to get us on SI. Nobody budged, so in the end the government had to give up.
10:03:48 <FMota> upside down?
10:03:53 <roconnor> cold should be high numbers, and hot should be low numbers
10:03:54 <byorgey> gpi5: you might have to load the module in ghci by typing :m +Data.List
10:03:56 <Cale> A pound is a British unit of currency.
10:03:59 <roconnor> with absolute zero at infinity.
10:04:12 <sorear> Cale: stray op bit
10:04:16 <jcreigh> roconnor: it couldn't be a linear scale, then.
10:04:18 --- mode: Cale set -o Cale
10:04:19 <FMota> I think it should be left up to the states. So that states can move on.
10:04:26 <Adamant> Imperial != Customary anyway (nitpick)
10:04:29 <roconnor> jcreigh: what do you mean linear?
10:04:30 <FMota> Then there'd me massive disarray within the US
10:04:32 <sorear> jcreigh: Linear wrt what?
10:04:41 <FMota> and I think the US would converge on SI units, eventually.
10:04:48 <Adamant> nah, not happening.
10:05:04 <byorgey> FMota: I kind of doubt it.  which state would switch first?
10:05:06 <FMota> one can hope, though, can't one?
10:05:06 <cizra> FMota: Right after M$ going OSS.
10:05:12 <sorear> the US is going to explode anyways...
10:05:14 <roconnor> with our current kelvin scale we get weird things like super hot objects having a negative temperature.
10:05:38 <Adamant> how so?
10:05:39 <roconnor> because the temperature goes past infinity and wraps around.
10:05:46 <cizra> Yeah, overflow
10:05:55 <cizra> > 0x7fffffff + 1
10:05:56 <roconnor> just illustrates we need to use the inverse scale
10:05:56 <chessguy> @type gets
10:06:03 <dons> roconnor: btw, do you have a tshirt size? if so, send it to the hackathon mailing list
10:06:04 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
10:06:06 <dons> ndm , you too :)
10:06:07 <lambdabot>  2147483648
10:06:07 <cizra> lambdabot: wake up
10:06:09 <cizra> > 0x7fffffff + 1
10:06:10 <lambdabot>  2147483648
10:06:10 <roconnor> then as things get hotter they would get closer and closer to zero
10:06:23 <roconnor> and supper hot things would be below zero
10:06:26 <roconnor> super
10:06:26 <FMota> roconnor: I think that would be very complicated.
10:06:39 <roconnor> FMota: not it would me more natural.
10:06:42 <FMota> what would you set freezing water at?
10:06:50 <FMota> 100?
10:07:03 <byorgey> supper hot things?  so, -1 would be the temperature of, say, a nice pot of beef stew?
10:07:10 <cizra> FMota: And what would you set freezing humans at?
10:07:11 <jcreigh> roconnor: but there's no upper limit on heat, whereas there is a lower limit. so the Kelvin scale makes perfect sense.
10:07:12 <roconnor> FMota: that depends on how you want to calibrate the scale.
10:07:34 <mornfall> @yow
10:07:35 <lambdabot> YOW!!  What should the entire human race DO??  Consume a fifth of
10:07:35 <lambdabot> CHIVAS REGAL, ski NUDE down MT. EVEREST, and have a wild SEX WEEKEND!
10:07:39 <roconnor> jcreigh: how does it make sense to have super hot objects with negative temperatures?
10:07:42 <FMota> roconnor: yes, but I want to know how YOU think it shoulde be calibrated
10:07:56 <jcreigh> roconnor: super hot objects don't have negative temperatures.
10:08:03 <roconnor> FMota: I don't care so much about the calibration, just the orientation.
10:08:08 <FMota> :/
10:08:09 <sorear> jcreigh: there is an upper limit - in the Kelvin-Helholtz (?) distribution, you can equate terperatures with fractions of an ensemble of atoms that are in excited states
10:08:11 <roconnor> jcreigh: yes the do.
10:08:35 <jcreigh> roconnor: what do you mean?
10:08:36 <cizra> sorear: Helmholtz
10:08:39 <sorear> jcreigh: 0.5 corresponds to infinity on the Kelvin scale, 1.0 is trivially the true maximum
10:08:49 <byorgey> gpi5: did you get it to work?
10:09:00 <FMota> hmmm
10:09:06 <sorear> cizra: I think I used the wrong pair of names, so the spelling is relatively immeterial :)
10:09:31 <FMota> 100R = 0C, 50R = 100C, 25R = 200C... and so on. :p
10:10:06 <cizra> FMota: Difficult to calculate with
10:10:13 <FMota> yep
10:10:23 <cizra> As you see, Americans tend to have difficulty with something as simple as Celsius scale
10:10:26 <cizra> and you're proposing this!
10:10:35 <FMota> not really proposing
10:10:38 <FMota> thinking about.
10:10:51 <gpi5> byorgey: yes, but that's the only function that requires that -- I'm using other functions in different modules and they work fine?? Thanks anyway.
10:10:51 <FMota> can't see much merit to it currently
10:11:27 <byorgey> gpi5: well, some functions in other modules are re-exported through the Prelude, so you may be able to use them without loading their respective modules
10:11:34 <mornfall> why not just use arbitrary precision arith? :)
10:11:38 <roconnor> jcreigh: http://en.wikipedia.org/wiki/Negative_temperature
10:11:39 <lambdabot> Title: Negative temperature - Wikipedia, the free encyclopedia
10:11:57 <roconnor> In physics, certain systems can achieve negative temperatures; that is, their thermodynamic temperature can be of a negative quantity.
10:12:10 <roconnor> a system with a negative temperature is hotter than the same system with an infinite temperature.
10:12:32 <roconnor> temperature is more generally defined by statistical mechanics than just kinetic energy (see below).
10:13:08 <jcreigh> roconnor: oh, interesting. I (obviously) didn't know that. Thanks for the link, I'll have to do some reading.
10:13:11 <sorear> I think I was looking for Fermi-Dirac
10:13:25 <roconnor> only certain degrees of freedom of a particle can have negative temperature.
10:13:34 <roconnor> usually you have spin temperatures
10:13:44 <roconnor> and I've seen something for magnetic temperature.
10:14:16 <roconnor> Temperature isn't a measure of kenetic energy, but is a measure of how much energy it takes to gain or lose a certain amount of entropy.
10:14:37 <roconnor> So if we worked in units of per Kevin
10:14:48 <roconnor> on a ``cryoture scale'' measureing coldness
10:14:58 <roconnor> then the math would work about better
10:15:11 <chessguy> @type get
10:15:12 <roconnor> absoultue zero would become infinity, and is unachivable
10:15:19 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
10:15:28 <roconnor> while infinitely hot would beocme 0, and achivable temperature in some domains.
10:16:57 <monochrom> Interesting.
10:18:23 <Adamant> this is all well and good, but it tells me nothing about whether I should go with red sativa habareno or the new mutated Scotch Bonnets for maximum natural heat impact
10:18:43 <Adamant> for that, I turn to the only scale that really matters, Scoville
10:18:54 <shapr> habanero, you mean?
10:19:24 <Adamant> yeah, I'm dysnumeric, but with letters instead of numbers
10:19:32 <shapr> Haven't tried the Scotch Bonnets, but habaneros are quite good.
10:19:42 <Adamant> tried red sativa? they are great
10:20:06 <Adamant> the mutated 900,000 Scoville Scotch Bonnets are new and hard to find
10:20:32 <byorgey> ! what would you do with such a monstrosity?
10:20:37 <Adamant> eat it?
10:21:06 <byorgey> don't tell me you would actually just chomp down on it by itself!?
10:21:19 <Adamant> uh, yeah. or put it into a sauce.
10:21:23 <monochrom> dysalphabetic? :)
10:21:39 <chessguy> @hoogle concatMapM
10:21:40 <lambdabot> No matches found
10:21:41 * monochrom is dysartistic
10:21:57 <Adamant> The Onion: "I'm like a chocoholic, but for booze!"
10:21:59 * byorgey likes spicy things but fails to see the point of such masochism.
10:22:15 <Adamant> I barely even feel jalapeno
10:22:23 <Adamant> that's probably why
10:23:17 <monochrom> pleasure and pain are two sides of the same coin.
10:23:48 <Adamant> a good sweat is the third side of the coin
10:23:49 <ddarius> no comment
10:23:54 <sfultong> aww, I can't derive (Show, Read) for functions :(
10:24:07 <chessguy> @src mapM
10:24:08 <lambdabot> mapM f as = sequence (map f as)
10:24:10 <FMota>  comfortable temperatures are around 80 to 85
10:24:16 <ddarius> You can't derive Show or Read for any type already defined.
10:24:24 <FMota> (R, that is)
10:24:28 <byorgey> sfultong: nope.  what do you think Show or Read should do for functions?
10:24:44 <chessguy> @type \f as -> sequence (concatMap f as)
10:24:46 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> [m a1]) -> [a] -> m [a1]
10:24:55 <monochrom> what? 80 to 85 is the right temperature for brewing most green teas.
10:25:08 <chessguy> err
10:25:12 <sfultong> byorgey: I dunno... wrap the raw haskell code in something that says "this is a function" ?:-P
10:25:33 <FMota> monochrom: it's a long conversation.
10:25:37 <ddarius> Reaumurs or the other one
10:25:43 <byorgey> sfultong: the problem is, that breaks referential transparency
10:25:48 <FMota> about an exponential temperature scale
10:25:49 <chessguy> @djinn (a -> m [b]) -> [a] -> m [b]
10:25:49 <lambdabot> -- f cannot be realized.
10:26:07 <ddarius> djinn doesn't do recursive types
10:26:09 <chessguy> @hoogle (a -> m [b]) -> [a] -> m [b]
10:26:10 <lambdabot> No matches, try a more general search
10:26:18 <chessguy> that's not a recursive type
10:26:20 <gpi5> I have something like pow2 i = find ((<=) i) [2^x | x<-[1..]]. But I'd like to return the matching x (this function returns the matching 2^x). How do I do that elegently?
10:26:26 <ddarius> A list is a recursive type
10:26:31 <chessguy> oh
10:26:31 <Japsu> @type sequence
10:26:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:26:39 <byorgey> sfultong: it's a valid question, but turns out not to work so well =)
10:26:52 <sfultong> yeah, I guess not
10:27:06 <FMota> I can think of an answer to chessguy: @hoogle (a -> m [b]) -> [a] -> m [b]
10:27:14 <FMota> how about   id
10:27:18 <FMota> ;)
10:27:24 <chessguy> wow, you're hilarious
10:27:42 <chessguy> you really should take your show on the road
10:27:44 <FMota> glad to be of service
10:28:10 <byorgey> > let pow2 i = last [ x | x <- [1..], 2^x <= i ] in pow2 29 -- gpi5 ?
10:28:13 <lambdabot> Terminated
10:28:24 <byorgey> oh, never mind
10:28:38 * byorgey thinks some more
10:29:07 <byorgey> gpi5: that's basically log2, right?
10:29:10 <sfultong> aww, I can't do Show for IO () either :(
10:29:18 <gpi5> byorgey: yes, kind of
10:29:23 <chessguy> so how would concatMapM be defined?
10:29:29 <sjanssen> > getLine
10:29:31 <lambdabot>  <IO [Char]>
10:29:52 <byorgey> > let log2 = length . takeWhile (> 0) . iterate (`div` 2) in log2 29
10:29:54 <lambdabot>  5
10:29:57 <sorear> @type \x y -> fmap concat $ mapM x y
10:29:59 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
10:30:06 <sorear> @type \x y -> liftM concat $ mapM x y
10:30:08 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
10:30:11 <byorgey> > let log2 = length . tail . takeWhile (> 0) . iterate (`div` 2) in log2 29
10:30:12 <lambdabot>  4
10:30:21 <byorgey> > let log2 = length . tail . takeWhile (> 0) . iterate (`div` 2) in log2 32
10:30:22 <lambdabot>  5
10:30:23 <sorear> chessguy: ?
10:30:29 <byorgey> gpi5: that should work
10:30:49 <Saizan>  > let pow2 i = listToMaybe [ x | x <- [1..], i <= 2^x ] in pow2 29
10:30:51 <Saizan> > let pow2 i = listToMaybe [ x | x <- [1..], i <= 2^x ] in pow2 29
10:30:52 <lambdabot>  Just 5
10:31:05 <gpi5> byorgey: thanks -- let me some time to understand :)
10:31:22 <byorgey> @type listToMaybe
10:31:24 <lambdabot> forall a. [a] -> Maybe a
10:31:47 <byorgey> @src listToMaybe
10:31:47 <lambdabot> listToMaybe []        =  Nothing
10:31:47 <lambdabot> listToMaybe (a:_)     =  Just a
10:32:05 <chessguy> @pl \x y -> liftM concat $ mapM x y
10:32:06 <lambdabot> (fmap join .) . mapM
10:33:16 <byorgey> chessguy: heh, for lists, liftM == fmap  and join == concat
10:33:42 <byorgey> actually, liftM == fmap for any Monad which is also a Functor
10:33:51 <byorgey> (which should be all of them...)
10:35:35 <chessguy> sorear, that works, thanks
10:35:46 <sorear> @uesers
10:35:47 <lambdabot> Maximum users seen in #haskell: 402, currently: 393 (97.8%), active: 23 (5.9%)
10:37:37 <chessguy> @undo do { ps <- fP; liftM concat $ mapM g ps }
10:37:37 <lambdabot> (fP >>= \ ps -> liftM concat $ mapM g ps)
10:38:50 <byorgey> ... which is the same as fP >>= liftM concat . mapM g, I think
10:39:25 <chessguy> @pl \ps -> liftM concat $ mapM g ps
10:39:25 <lambdabot> fmap join . mapM g
10:39:33 <byorgey> yup
10:39:45 <chessguy> yeah, i knew there was a simplification in there, i just couldn't find it
10:39:50 <gpi5> I have a Maybe Integer. How do I convert to the Interger itself in an expression?
10:40:10 <ddarius> gpi5: What if it's Nothing?
10:40:20 <elliottt> mInt >>= \i -> ...
10:40:20 <chessguy> so fP >>= concatMapM g
10:40:37 <byorgey> chessguy: yeah, whenever you see \x -> ..... x, you can remove the x by eta-reduction
10:40:47 <byorgey> at least, I think that's called eta-reduction
10:40:50 <ddarius> if x is not free in .....
10:40:58 <ddarius> That is eta-reduction.
10:41:09 <byorgey> gpi5: if you know it can never be Nothing, you can use fromJust
10:41:09 <gpi5> ddaruis: it won't be Nothing, I'm sure of that
10:41:15 <byorgey> > fromJust (Just 5)
10:41:27 <lambdabot>  5
10:41:35 <elliottt> gpi5: you could use fromMaybe
10:41:49 <byorgey> gpi5: you could also use a pattern-match, of course
10:41:56 <ddarius> > fromJust Nothing
10:41:58 <lambdabot>  Exception: Maybe.fromJust: Nothing
10:42:03 <byorgey> > let f (Just x) = x + 2 in f (Just 5)
10:42:04 <lambdabot>  7
10:42:13 <chessguy> yeah, i really suck at doing @pl myself
10:42:16 <gpi5> Great, thks
10:42:21 <byorgey> @type fromMaybe
10:42:23 <lambdabot> forall a. a -> Maybe a -> a
10:42:34 <sjanssen> @remember b7j0c the haskell community should take out life insurance on dons
10:42:35 <lambdabot> Done.
10:42:40 <byorgey> > fromMaybe 0 (Just 2)
10:42:41 <ddarius> fromMaybe = flip maybe id
10:42:41 <lambdabot>  2
10:42:49 <byorgey> > fromMaybe 0 (Nothing)
10:42:50 <lambdabot>  0
10:43:42 <gpi5> @index fromJust
10:43:42 <lambdabot> Data.Maybe
10:43:55 <byorgey> chessguy: well, for some reason I really enjoy doing @pl myself =)
10:44:01 <ddarius> @hoogle Maybe a -> a
10:44:02 <lambdabot> Maybe.fromJust :: Maybe a -> a
10:44:02 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
10:44:02 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
10:48:04 <chessguy> @pl m s = m' (b s)
10:48:05 <lambdabot> m = m' . b
10:51:01 <chessguy> @bot
10:51:01 <lambdabot> :)
10:51:46 <sfultong> @bot @bot @bot @bot
10:51:46 <lambdabot> :)
10:52:36 <sfultong> @quote
10:52:37 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
10:52:46 <chessguy> @b x y = return (x, y)
10:52:46 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . v
10:52:52 <chessguy> @pl b x y = return (x, y)
10:52:53 <lambdabot> b = (return .) . (,)
10:53:04 <sfultong> @botsnack
10:53:04 <lambdabot> :)
10:56:00 <mornfall> i  suppose i cannot use derived (==) in an implementation of my own for a given type?
10:56:32 <luqui> mornfall, elaborate?
10:56:41 <Saizan> for the same type?
10:57:50 <mornfall> ex: a == b = if a `uuidEq` b then (if a `derivedEq` b then True else <error>) else False
10:58:24 <mornfall> for the same type, yes
10:58:56 <mornfall> i'd like to assert "uuid matches" `implies` "everything matches"
10:59:35 <byorgey> mornfall: no, but you could derive an Eq instance for the type, and then create a newtype on top of that and implement (==) in the way you'd like
11:00:21 <mornfall> a little icky :\
11:00:26 <dons> ?users
11:00:27 <lambdabot> Maximum users seen in #haskell: 402, currently: 394 (98.0%), active: 16 (4.1%)
11:01:52 <mornfall> i suppose i'll have  to enforce consistency elsewhere
11:03:31 <mornfall> ok, a different question
11:03:59 <mornfall> or not
11:04:02 <mornfall> figured
11:05:31 <mornfall> hm
11:05:34 <mornfall> if i have
11:05:47 <mornfall> instance Eq A where (==) = volEq
11:05:52 <mornfall> instance Eq B where (==) = volEq
11:05:57 <mornfall> ...
11:06:02 <mornfall> is there a way to streamline that?
11:09:47 <mornfall> nevermind, i don't need it anymore :-) (yeh, i change my mind quickly...)
11:13:05 <chessguy_> @paste
11:13:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:14:06 <hpaste>  chessguy pasted "i understand the problem, but not the solution..." at http://hpaste.org/2628
11:14:43 <chessguy_> so, in genPieceMoves, targets p doesn't work
11:15:01 <chessguy_> err, well i can't use targets p there, i should say
11:15:34 <chessguy_> is there something better than falling into do notation and doing ts <- targets p before the whole case expression?
11:16:42 <chessguy_> oh!
11:16:56 <chessguy_> targets p >>= mapSource (location p) works
11:17:08 <mornfall> aight
11:18:13 <mgsloan> sections with subtraction seem rather ambiguous
11:18:32 <mgsloan> map (-1) xs
11:18:34 <mgsloan> that kind of thing
11:19:00 <chessguy> @pl \p -> targets p >>= mapSource (location p)
11:19:00 <lambdabot> liftM2 (>>=) targets (mapSource . location)
11:19:39 <EvirDrevo> mgsloan: Does that even work for you?
11:19:43 <mgsloan> no
11:19:54 <twanvl> :t subtract
11:19:57 <lambdabot> forall a. (Num a) => a -> a -> a
11:19:57 <mgsloan> ah
11:23:01 <luqui> > subtract 3 4
11:23:03 <lambdabot>  1
11:23:08 <luqui> and the argument order is correct!
11:23:17 <mgsloan> yeah, more curryable
11:23:29 <ddarius> subtract was made specifically to handle "(- x)
11:23:31 <ddarius> "
11:23:49 <mornfall> > (-5) 10
11:23:50 <lambdabot>   add an instance declaration for (Num (t -> a))
11:23:51 <lambdabot>     In the expression: (- 5)...
11:23:55 <mornfall> ah
11:23:55 <hpaste>  chessguy annotated "i understand the problem, but not the solution..." with "figured it out" at http://hpaste.org/2628#a1
11:24:00 <mornfall> daesn't figure :)
11:24:10 <mornfall> > (- 5) 10
11:24:11 <lambdabot>   add an instance declaration for (Num (t -> a))
11:24:11 <lambdabot>     In the expression: (- 5)...
11:24:13 <luqui> the more i use haskell and put my other language patterns aside, the more I want mod's arguments to be flipped
11:24:17 <mornfall> doesn't love me
11:24:32 <mornfall> luqui: flip mod ;-)
11:24:58 <jcreigh> luqui: hmm...why?
11:25:09 <mornfall> partial application
11:25:10 <mornfall> i assume
11:25:22 <ddarius> (`mod` 3)
11:25:23 <Tac-Tics2> > ((-) 1) 2
11:25:25 <lambdabot>  -1
11:25:44 <ddarius> > (+ (-1)) 2
11:25:44 <opqdonut> > 4 `mod` 3
11:25:45 <lambdabot>  1
11:25:46 <lambdabot>  1
11:25:50 <luqui> jcreigh, yeah, it's much more common for me to, eg. take a list of numbers mod n, than take n mod a list of numbers
11:25:52 <opqdonut> seems correct to me :)
11:26:04 <mornfall> hm, (`mod` n) is pretty good
11:26:08 <jcreigh> > map (`mod 4) [1..20]
11:26:08 <lambdabot>  Parse error
11:26:11 <jcreigh> > map (`mod` 4) [1..20]
11:26:12 <Tac-Tics2> How does one determine the rank of a type?
11:26:12 <lambdabot>  [1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0]
11:27:04 <pastorn_> Tac-Tics2: what?
11:27:11 <pastorn_> what do you want to do?
11:27:52 <ddarius> You could pull out all the universal quantifications (changing some to existential ones) and then the rank would be how often it alternates roughly
11:27:57 <Tac-Tics2> I want to.... determine the rank of a type?
11:28:18 <Tac-Tics2> that explanation is too confusing for me ^^;
11:29:44 <ddarius> Roughly it's how deeply the foralls nest.
11:30:18 <luqui> Tac-Tics2, or do you mean kind?
11:31:13 <Tac-Tics2> I'm reading through Practical Type 	inference for arbitrary rank types by SPJ and it is talking about ranks. It gives three examples, but the last example gives a result I didn't expect
11:31:54 <Tac-Tics2> Int -> (Aa. a->a) is rank 1, but (Aa.a->a) -> Int is rank 2
11:33:01 <ndm> @seen dons
11:33:02 <lambdabot> I saw dons leaving #xmonad and #haskell 8m 34s ago, and .
11:34:04 <Tac-Tics2> The definition given for rank is "The rank of a type describes the depth at which universal quantifiers appear contra-
11:34:05 <Tac-Tics2> variantly", but I don't understand what they mean by "contravariantly" in this context
11:36:02 <arjanb> you can read it as to the left of an arrow
11:36:09 <ddarius> Tac-Tics2: - -> +, the - is contravariant and + covariant and it "multiplies" so you get (+ -> -) -> +
11:36:38 <ddarius> Incidentally, Int -> (forall a. a -> a) is equivalent to forall a. Int -> a -> a
11:37:20 <Tac-Tics2> I'm wondering if there is any introductory type theory stuff that would help me with this
11:37:56 <ndm> Tac-Tics2: benjamin pierce, "types and programming languages" is the standard one
11:38:14 <ddarius> Tac-Tics2: Some introductory logic stuff would be about as good
11:39:07 <Tac-Tics2> bah, good books aren't so expensive
11:42:08 * ddarius needs to make a module that sets up Parsec the way he likes it.
11:42:24 <Tac-Tics2> what don't you like about how it's set up?
11:42:57 <ddarius> It isn't set up.  You have go through and import and rebind a bunch of stuff to have something sane.
11:54:26 <gpi5> Who could explain the difference between (`div` 2) and (div 2) plz?? Looks like I've lost one hour because of it!
11:55:09 <_roconnor> (`div` 2) x means (x `div` 2)
11:55:18 <_roconnor> (`div` 2) x means (x `div` 2) means (div x 2)
11:55:34 <_roconnor> (div 2) x means (div 2 x)
11:55:35 <sieni> gpi5: well, (`div` 2) is the same as \x -> (div x 2) and (div 2) is the same as \x -> (div 2 x)
11:56:00 <Botje> with a bit more practice we can get the majestic stereo into dolby surround sound.
11:56:21 <sieni> gpi5: so (div 2) is the same as (2 `div`)
11:56:43 <gpi5> sieni: ok, I see. Scary haskell :)
11:56:45 <_roconnor> `div` is infix
11:56:48 <_roconnor> div is prefix
11:57:52 <Botje> @pl \x -> (x `div` 2)
11:57:53 <lambdabot> (`div` 2)
11:57:57 <Botje> @pl \x -> (2 `div` x)
11:57:57 <lambdabot> (2 `div`)
11:58:10 <_roconnor> for infix operators (#), Haskell has this strange things  called sections, so you can write (x #) and (# x)
11:58:22 <_roconnor> for partially applied infix functions
11:58:38 * Botje has thought up the crazy notion of wanting to hack ternary operators into haskell
11:58:54 <Botje> (ie: x isBetween 5 and 9
12:00:40 <_roconnor> Botje: what's wrong with making isBetween :: a -> (a,a) -> Bool, and having and:: a -> a -> (a,a) ?
12:00:50 <astrolabe> If Ord a => Eq a, why do I need both in my type signatures?  Is there any way to simplify it?
12:02:20 <roconnor> Do you need both in your type signatures?
12:02:58 <Botje> roconnor: mostly because and is already defined, and I want to hack ghc up a bit
12:03:03 <Botje> i'll think about it some more :)
12:04:11 <oerjan> astrolabe: Ord a should be enough
12:04:33 <astrolabe> oerjan, roconnor: thanks, I'll have to play with it.
12:04:33 <oerjan> (unless this is related to some discussion before i entered)
12:04:38 <axm> roconnor, ifThenElse :: a -> b -> c would be ugly, why not extend
12:05:47 <roconnor> ifThenElse :: Bool -> (a,a) -> a
12:06:08 <roconnor> of course ifThenElse isn't a ternary notation
12:06:18 <roconnor> ternary notations usually have 2 symbols.
12:06:28 <roconnor> if then else has 3
12:06:45 <axm> the point is extending control structures to get more readability
12:07:35 <axm> reminds me a bit to lisps makros
12:12:39 <axm> hm, your (a,a) contains the then/else, returning a new a (of some code type)? still new here.
12:15:09 <DRMacIver> >  let {if' v w x y z = if v then x else z; then' = undefined; else' = undefined;} in if' True then' "foo" else' "bar"
12:15:11 <lambdabot>  "foo"
12:15:34 <DRMacIver> Or is that not what you wanted? :)
12:15:50 <roconnor> > let {x ? (a,b) = if x then a else b; (!) = (,)} in True ? "foo" ! "bar"
12:15:51 <lambdabot>  Couldn't match expected type `(t, t)'
12:15:52 <oerjan> (([snd,fst]!!).fromEnum) True ('y','n')
12:15:55 <oerjan> > (([snd,fst]!!).fromEnum) True ('y','n')
12:15:57 <lambdabot>  'y'
12:16:15 <roconnor> > let {x ? (a,b) = if x then a else b; (!) = (,)} in True ? ("foo" ! "bar")
12:16:16 <lambdabot>  "foo"
12:16:34 <roconnor> I have some precidence issue I cannot resolve right here.  I need an actual module.
12:16:37 <Japsu> > lookup [(True, 'y'), (False, 'n')] True
12:16:38 <lambdabot>  Couldn't match expected type `[([(Bool, Char)], b)]'
12:16:43 <ddarius> roconnor: You can add fixity declarations.
12:16:44 <Japsu> oops
12:16:51 <Japsu> > lookup True [(True, 'y'), (False, 'n')]
12:16:52 <lambdabot>  Just 'y'
12:16:58 <Japsu> ...
12:17:02 <Japsu> > fromJust $ lookup True [(True, 'y'), (False, 'n')]
12:17:03 <phobes> DRMacIver: Why not make Then and Else data constructors and then have if pattern match on them
12:17:04 <lambdabot>  'y'
12:17:04 <roconnor> can I and fixity delcaration to lambdabot?
12:17:10 <roconnor> ugh
12:17:16 <Saizan> > let x ? a = if x then const a else id;  in True ? "foo" $ "bar"
12:17:17 <lambdabot>  "foo"
12:17:18 <DRMacIver> phobes: Why would you?
12:17:18 <roconnor> can I add fixity declarations to lambdabot
12:17:27 <sjanssen> roconnor: you can do fixity declarations in 'let'
12:17:29 <ddarius> roconnor: You can have local fixity declarations.
12:17:34 <roconnor> Saizan: :D
12:17:43 <oerjan> roconnor: i tried with @let the other day and couldn't do it, but > may still work
12:17:55 <roconnor> Saizan: that is a thing of beauty
12:18:13 <phobes> DRMacIver: Because then you could get the compiler to warn if the result is undefined (or am I wrong about this?)
12:18:35 <phobes> Actually, you want them to be new types
12:18:52 <DRMacIver> phobes: The undefined bits get ignored by the if' definition. They're just silly parameters which don't affect the result of the function.
12:19:13 <phobes> If :: Bool -> ThenType -> a -> ElseType -> b
12:19:17 <ddarius> DRMacIver: He wants to disallow, if True else bar then baz
12:19:18 <phobes> If :: Bool -> ThenType -> a -> ElseType -> a -> a
12:19:44 <DRMacIver> ddarius: Oh, right.
12:19:59 <phobes> ddarius:  I want to disallow:   If True 5 False 'charlie' True
12:20:18 <DRMacIver> Well, sure, you could do that. But what I was suggesting was sufficiently silly that doing it 'properly' seems unneccessary. :)
12:20:32 <phobes> No way man, I think you're on to something
12:20:37 <phobes> This could fix haskell
12:20:44 <ddarius> The correct thing to do is define 'bool'
12:21:26 <DRMacIver> ddarius: ?
12:21:42 <ddarius> The fold for Bool, similar to maybe.
12:21:47 <DRMacIver> Ah, right.
12:22:21 <oerjan> er... if you make Then and Else ordinary identifiers rather than operators then you cannot use them to avoid parentheses
12:22:38 <ddarius> oerjan: They are just parameters.
12:22:53 <ddarius> But I guess you'd have issues yes.
12:23:02 <DRMacIver> Don't fear the parentheses.
12:23:07 <DRMacIver> The parentheses are your friends.
12:23:12 <oerjan> i mean, you would need parentheses for _other_ arguments
12:23:15 <ddarius> We should just strike if-then-else from the language altogether.
12:23:25 * DRMacIver agrees. :)
12:23:31 <Japsu> heh
12:23:45 <DRMacIver> Either that or add 'for' and 'while' keywords in. ;)
12:25:17 <phobes> Of course really to make the operators easy to use, you should introduce C's ? : syntax
12:26:38 <ddarius> -or- we could just get rid of if-then-els.
12:27:04 * ddarius doesn't want if-then-else to be easier to use.
12:27:18 <DRMacIver> I think we should add goto. :)
12:27:31 <Vq^> why not throw in INTERCALs PLEASE keyword to make it really interesting? :)
12:27:32 <phobes> Probably wouldn't be too hard to make a Monad with goto support
12:27:33 <kpreid> cizra: re looking up filterM, use hoogle
12:27:36 <kpreid> @where hoogle
12:27:36 <lambdabot> http://haskell.org/hoogle
12:27:46 <phobes> LineNumberMonad
12:27:47 <ddarius> phobes: Not only is it not hard, it's already done.
12:27:57 <phobes> ddarius:  Not surprising
12:28:05 <DRMacIver> ddarius: Link?
12:28:25 <ddarius> Just use Cont(T)
12:28:35 <phobes> Heh, I was afraid you were going to link to Cont
12:28:36 <ddarius> It's particularly useful with mdo
12:28:50 <DRMacIver> Heh. Fair enough. :)
12:28:52 <phobes> That's not the same... You really need line numbers
12:29:01 <cizra> Now this is useful! Thank you!
12:29:05 <DRMacIver> phobes: Or labels.
12:29:13 <ddarius> You have labels!
12:29:17 <phobes> DRMacIver:  With labels you're getting too close to Cont :)
12:29:29 <DRMacIver> ddarius: I know. :)
12:29:44 <ddarius> With a crazy enough instance of Num you may be able to pull it off.
12:29:46 <DRMacIver> phobes: Well continuations are practically functional gotos aren't they? :)
12:29:57 <oerjan> ddarius: wait - i thought i read continuation monads don't have MonadFix instances?
12:30:13 <ddarius> @instances MonadFix Cont
12:30:15 <lambdabot> Couldn't find class `MonadFix Cont'. Try @instances-importing
12:30:18 <ddarius> @instances MonadFix
12:30:19 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:31:36 <iguana_> what is a MonadFix?
12:31:38 <greenrd> Has anyone else done some ad-hoc "partial evaluation" using Template Haskell? I'm planning to
12:31:48 <oerjan> @src MonadFix
12:31:49 <lambdabot> class (Monad m) => MonadFix m where
12:31:49 <lambdabot>     mfix :: (a -> m a) -> m a
12:31:53 <ddarius> oerjan: It's certainly doable to have mfix for some continuation monads.
12:32:16 <kpreid> iguana_: MonadFix has mfix. mfix is to fix as mapM is to map, etc.
12:32:27 <greenrd> i.e. I'm planning to just parse in some data, and pre-filter it, in a Template Haskell splice, to avoid having to do that in every run of a program
12:32:32 <iguana_> shouldn't it be called fixM then? ;)
12:32:45 <kpreid> > execWriter $ mfix (tell "foo")
12:32:46 <lambdabot>  Couldn't match expected type `m a' against inferred type `()'
12:32:48 <kpreid> er
12:33:08 <kpreid> > execWriter $ mfix (\x -> tell show x; return (1:x))
12:33:09 <lambdabot>  Parse error
12:33:13 <kpreid> > execWriter $ mfix (\x -> do tell show x; return (1:x))
12:33:14 <lambdabot>  Couldn't match expected type `m t' against inferred type `()'
12:33:17 <greenrd> but how am I going to convert the data into a meta-level representation of itself?
12:33:18 <kpreid> > execWriter $ mfix (\x -> do tell (show x); return (1:x))
12:33:20 <lambdabot>  "[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:33:48 <greenrd> I will need to write something like show but for meta-level representations of data, instead of strings (ok, that isn't really much like show)
12:33:48 <Saizan> greenrd: you can just use the constructors
12:34:10 <iguana_> hm, I don't really have to understand MonadFix, do I?
12:34:26 <ddarius> iguana_: No, you don't.
12:34:30 <iguana_> ok :D
12:35:12 <iguana_> I was just trying "fix (\x -> x^2)" and it gives a stack overflow
12:35:16 <greenrd> Saizan: I don't think so... you mean parse the data in my head, and type out the constructors by hand?
12:35:44 <oerjan> > fix (\x -> x^2)
12:35:46 <lambdabot>  Exception: <<loop>>
12:36:09 <oerjan> that's not stack overflow, that's a value depending circularly on itself
12:36:35 <greenrd> ah - maybe what I need to do is to write Lift instances for each of my datatypes
12:36:38 <oerjan> oh, in Hugs that gives a stack overflow
12:36:55 <kpreid> iguana_: that can be made to work given an appropriate Num type.
12:37:03 <oerjan> since it doesn't check for circularity
12:37:06 <Saizan> greenrd: no, but you can use the standard haskell representation in your macros for the input, and then output a Q Exp which correspond to the constructors for your data
12:37:39 <iguana_> kpreid: which Num type would that be?
12:37:52 <kpreid> One you write, probably.
12:37:55 <iguana_> :D
12:38:15 <kpreid> The thing to remember is that fix is the *least* fixed point.
12:38:20 <greenrd> Saizan: sorry, not following you - what do you mean by "in your macros for the input"?
12:38:23 <kpreid> Least defined, that is.
12:38:49 <oerjan> iguana_: a type of algebraic expressions might work
12:38:51 <iguana_> @src fix
12:38:51 <lambdabot> fix f = let x = f x in x
12:39:12 <iguana_> hmmm
12:39:32 <Saizan> greenrd: "as input to your macro", like if you have to filter things of type A you have a macro :: A -> Q Exp
12:40:03 <iguana_> that isn't really obvious to me
12:40:13 <kpreid> > fix ((0:) . map (+1))
12:40:14 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:40:15 <greenrd> yeah, but my question was how do I create the Q Exps
12:40:30 <greenrd> and I think the standard way would be to create Lift instances
12:40:33 <kpreid> this works because the 0: gives it somewhere to start.
12:40:35 <greenrd> that's what Lift seems to be for
12:40:54 <oerjan> iguana_: an important thing about fix is that fix f only works if f doesn't look at its argument before producing part of the result
12:41:56 <iguana_> ok
12:42:13 <iguana_> this is really a thing only a lazy language can do
12:42:15 <kpreid> or rather: for any part of the result, it must not look at that part of the input!
12:42:21 <oerjan> indeed :)
12:43:08 <phobes> is that sufficient?
12:43:12 <phobes> or true?
12:43:36 <Saizan> there are fixpoint combinators that work with eager evaluation, iirc
12:43:43 <oerjan> *of the input in order to calculate that part of the result
12:44:06 <oerjan> or otherwise that part will be undefined
12:44:31 <oerjan> Saizan: that's because they essentially fix lambdas first, i think
12:44:55 <oerjan> and eager languages are usually not eager under lambdas
12:45:38 <monochrom> fix for eager languages add a couple more lambdas.
12:45:39 <kpreid> it's also possible in eager non-strict languages.
12:45:41 <iguana_> hm, is there any obvious useful thing you can do with fix?
12:46:07 <monochrom> xmonad uses fix for all its loops
12:46:08 * kpreid works with an eager, impure, selectively non-strict language...
12:47:08 <oerjan> iguana_: well any time you have recursion you might replace it with a fix
12:47:31 <oerjan> in point-free style that may sometimes be an improvement
12:47:44 <monochrom> in pointful style even more so.
12:48:00 <oerjan> oh?
12:48:11 <monochrom> If you appreciate anonymous functions, you will appreciate anonymous recursions.
12:48:19 <ricky_clarkson> iguana_: fix is useful for anonymous recursion.
12:48:28 <ricky_clarkson> iguana_: Languages that force you to name things are bad!
12:48:30 <oerjan> right
12:48:47 <monochrom> xmonad is full of code like fix (\self -> do { .... ; self; ...} )
12:48:52 <iguana_> uh ok
12:48:56 <ricky_clarkson> I started writing point-free style in Java just before.
12:49:03 * iguana_ can find only one use of "fix" in xmonad
12:49:13 <wli> Isn't there a monadic fix?
12:49:26 <oerjan> wli: we discussed mfix a moment ago
12:50:07 <ricky_clarkson> curry(flip(startsWithRef()),"visibleComponents ")) (where curry should really be called partiallyApply.
12:50:29 <iguana_> ricky_clarkson: beautiful :)
12:51:08 <ricky_clarkson> It's Java's punishment for not giving me proper lambdas.
12:51:33 <Saizan> so you've a Function class?
12:51:58 <ricky_clarkson> In this case a Predicate (well, Predicate2, meaning (a, b) -> Bool).
12:53:26 <Saizan> i think i'd feel even more frustrated by emulating first class functions like that while writing java
12:53:37 <monochrom> Scheme's (let self ((x 0) (y 1)) (if (= x 10) y (self (+ x 1) (+ y 2)))) is Haskell's fix (\self x y -> if x==10 then y else self (x+1) (y+2)) 0 1
12:55:12 <ddarius> You don't name every for or while loop
12:55:26 <ddarius> That said, fix is rarely used.
12:56:46 <monochrom> I think it's under-used.
12:57:00 <hpaste>  FMota pasted "Interesting functional syntaxes?" at http://hpaste.org/2629
12:57:23 <FMota> check it out. I want opinions. :)
12:57:33 <monochrom> Using fix or Scheme's let, I still have to give a name to the loop --- the "self" there. But it's a local name, I can use it for every loop, that's the beauty of it.
12:58:01 <ricky_clarkson> monochrom: You'd be better defining fix in Scheme and avoiding the name.
12:58:33 <ricky_clarkson> monochrom: (lambda (f x) (f f x)) is quite useful.
12:58:59 <monochrom> If there is a nice point-free form of what I do, I surely skip the name too.
12:59:13 <ricky_clarkson> @check \x y -> x+y-x==y
12:59:14 <lambdabot>  Add a type signature
12:59:21 <ricky_clarkson> Where can I add a type signature to that?
12:59:27 <ddarius> monochrom: If you name it, you're no better off than just using a let.
12:59:42 <oerjan> @check \x y -> x+y-x==(y::Double)
12:59:44 <lambdabot>  Falsifiable, after 11 tests: 3.2, 2.6
12:59:51 <FMota> nobody commenting on my syntaxes? psh...
12:59:57 <monochrom> No one is reading what I wrote.
13:00:11 <monochrom> "But it's a local name, I can use it for every loop, that's the beauty of it."
13:00:33 <earnest> FMota: it looks like you're writing python in functional style; my newbiness allows me to only say that; python, though im not a python programmer, does allow some functional style, doesnt it?
13:00:40 <monochrom> do { let loop_number_1 = ...; loop_number_1; let loop_number_2 = ...; loop_number_2 } ?
13:00:48 <ricky_clarkson> monochrom: It's still a name.  That's like when CL users are pleased they can use macrolet to use the name 'def' for lots of macros.
13:00:55 <FMota> earnest: it isn't really python, though
13:00:58 <monochrom> vs do { fix (\self -> ...); fix (\self -> ...) }
13:01:06 <earnest> FMota: what is it?
13:01:10 <FMota> and anyway, I'm more interested in opinions on the second style
13:01:20 <FMota> earnest: it's a functional-style pythn
13:01:24 <FMota> *python
13:01:31 <earnest> it's how you wish python would be?
13:01:32 <ddarius> FMota: What kind of response do you want?
13:01:52 <FMota> earnest: no, python is fine as it is. I'm just throwing syntax around.
13:02:08 <FMota> ddarius: any :)
13:02:43 <Esteth> are there any gentler intoductions to haskell than "A Gentle Introduction to Haskell" ? Most of the code it lists (or what appears to be code) doesn't work in GHCi
13:02:47 <monochrom> I think it makes a big difference that I don't have to watch out for name clashes.
13:03:03 <ddarius> monochrom: I don't think it's a big difference in practice.
13:03:03 <monochrom> I.e., it is not just program length.
13:03:17 <ddarius> Er, or are you talking about macrolet?
13:03:21 <oerjan> Esteth: you often need to put things in a file rather than directly in ghci
13:03:34 <sioraiocht> Esteth: what code in particular?
13:03:40 <monochrom> I'm talking about do { let loop_number_1 = ...; loop_number_1; let loop_number_2 = ...; loop_number_2 } vs do { fix (\self -> ...); fix (\self -> ...) }
13:03:57 <Esteth> sioraiocht: as an example: [f x | x <- xs]
13:04:35 <ddarius> monochrom: I don't think it is common to want that too many unnamed loops in a binding group.
13:04:35 <Esteth> sioraiocht: or "tail (x:xs) = xs" (quotes for clarity)
13:04:37 <oerjan> monochrom: but you don't need to give the loops different names in that case
13:04:56 <ricky_clarkson> monochrom: let in Haskell and Lisp has its own scope.
13:05:09 <oerjan> just use in loop instead of semicolon
13:05:39 <monochrom> ddarius: that is a do block, not a binding group.
13:06:03 <oerjan> monochrom: you can use let ... in as a do action
13:06:05 <ddarius> monochrom: Just do as oerjan said and you're set.
13:06:32 <ricky_clarkson> > [let x=5 in x*x,let x=6 in x*10]
13:06:34 <lambdabot>  [25,60]
13:06:36 <astrolabe> Esteth: the gentle introduction isn't that gentle I don't think
13:06:46 <oerjan> i won't actually claim that it's an improvement over using fix though :)
13:06:50 <monochrom> except that "let ... in ..." inside a do-block is a pain to indent.
13:06:50 <astrolabe> Esteth: try yaht
13:06:57 <astrolabe> @where yaht
13:06:58 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
13:07:18 <ricky_clarkson> gigamonkey_: Can you write a book for these people please?
13:07:23 <ddarius> monochrom: ?
13:07:34 <ddarius> No more than 'return 3'
13:08:10 <hpaste>  sjanssen pasted "the fix loop idiom in xmonad" at http://hpaste.org/2630
13:08:19 <sjanssen> "when more again" is very cute IMO
13:08:29 <Esteth> astrolabe: Thanks :)
13:08:30 <monochrom> show me how to indent do { let l = <three lines of code here> in l; return 5 }
13:08:33 <sioraiocht> Esteth: tail is a self-contained function, but the other is not
13:08:44 <sioraiocht> > [f x | x <- xs]
13:08:45 <lambdabot>   Not in scope: `xs'
13:09:07 <sioraiocht> > let tail (x:xs) = xs
13:09:07 <lambdabot>  Parse error
13:09:13 <ddarius> in ...
13:09:20 <sioraiocht> > let tail (x:xs) = xs in [1..5]
13:09:22 <lambdabot>  [1,2,3,4,5]
13:09:28 <sioraiocht> > let tail (x:xs) = xs in tail [1..5]
13:09:33 <lambdabot>  [2,3,4,5]
13:09:52 <monochrom> "in" aligned with "let"? Wouldn't that be an error inside a do-block?
13:10:51 <oerjan> monochrom: yeah, same problem as if-then-else
13:11:48 <chessguy_> why in the world is semantic whitespace a good thing anyway?
13:12:16 <ddarius> Because the {}'s and ;'s are redundant.
13:12:27 <ricky_clarkson> chessguy: ihavenoidea
13:12:33 <chessguy> redundant?
13:12:35 <monochrom> The best position for "in" is embarassing. It has to be to the right enough so the computer doesn't misread. It has to be to the left enough so another human can see it. And the two are in conflict.
13:12:48 <monochrom> s/see/notice/
13:12:56 * ddarius just uses two spaces in those cases
13:13:10 <ddarius> chessguy: Obviously it's redundant or else we wouldn't be able to get rid of them.
13:13:16 <hpaste>  iguana pasted "counting monad" at http://hpaste.org/2631
13:13:26 <ricky_clarkson> monochrom: Despite hating it at first, I like lisp's let syntax.
13:13:35 <iguana_> can someone look at that paste? I'm having problems with the errors it gives
13:13:36 <monochrom> On top of that, most editors' auto-indent won't give you the best position for that "in". Not even as one of many choices.
13:13:38 <ricky_clarkson> (let ((x 10)) (* x 10))
13:14:21 <chessguy> ddarius, hmm. i'm not following, sorry
13:14:46 <oerjan> iguana_: you are missing the return value of the monad
13:14:52 <ddarius> chessguy: The indentation already reveals the structure of the code.  We don't further need symbols.
13:14:59 <oerjan> the type needs another argument for it
13:15:09 <ricky_clarkson> ddarius: During code editing, indentation can be wrong.
13:15:27 <iguana_> ok
13:15:33 <ddarius> ricky_clarkson: And so can the usage of ; and {} what's your point?
13:15:36 <hpaste>  Ron pasted "Modified RotatingCubes example" at http://hpaste.org/2632
13:15:37 <ricky_clarkson> E.g., if you are in the process of wrapping some code in an if.
13:15:37 <Saizan> iguana_: you've forgotten the Counted constructor in the last branch of the case
13:15:46 <chessguy> ah. well sure, but i would replace the indentation with ;'s and {}'s, in which case they wouldn't be redundant
13:15:59 <ricky_clarkson> ddarius: The point is that with {} you can more easily see the mistake.
13:16:08 <ddarius> chessguy: They still would because the vast majority of programmers indent their code anyways.
13:16:19 <iguana_> Saizan: right, but it's still complaining
13:16:29 <hpaste>  FMota annotated "Interesting functional syntaxes?" with "Haskell-ish dependent-typed syntax." at http://hpaste.org/2629#a1
13:16:39 <ricky_clarkson> ddarius: If editors were tree editors instead of text editors then perhaps this wouldn't be an issue and whitespace would rule.
13:16:42 <ddarius> ricky_clarkson: It shouldn't be an issue.  You should be (re)indenting your code anyway.
13:16:42 <chessguy> ddarius, they do, but not necessarily with the semantics that haskell assigns to their indentation
13:16:59 <FMota> anyway, that part is far more interesting.
13:17:32 <ddarius> chessguy: The vast majority of programmers indent their code with a meaning that is consistent with most of the layout rule.
13:17:40 <Saizan> iguana_: because you can't use the Num context inside the implementation of >>=, restricted monads are not supported by the current layout of the monad class
13:17:55 <iguana_> oh, so this isn't possible at all?
13:17:58 <ddarius> Since Haskell doesn't require significant whitespace, if you don't like it you can not use it.
13:18:07 <ddarius> (to a large extent)
13:18:18 <chessguy> that's hardly the point
13:19:15 <oerjan> iguana_: you can have a count, but you also need to have return values that can be any type
13:19:24 <ddarius> chessguy: You've never had missing braces or semicolons in a C-style syntax?
13:19:37 <chessguy> ddarius, of course i have. don't be silly
13:20:44 <iguana_> so I can't add the return values up
13:21:05 <ddarius> chessguy: So far as I can tell, you've not stated a point.
13:21:14 <oerjan> indeed not, that would be a violation of the monad laws
13:21:44 <iguana_> ok
13:21:55 <chessguy> ddarius, i'm probably being pointless again :)
13:21:59 <Saizan> oerjan: which one?
13:22:04 <gigamonkey_> ricky_clarkson: isn't bos working on a Haskell book for O'Reilly?
13:22:12 <chessguy> @where rwh
13:22:12 <lambdabot> is http://www.realworldhaskell.org/blog/
13:22:16 <chessguy> gigamonkey_, ^^
13:22:20 <iguana_> are arrows the solution? ;)
13:22:30 <oerjan> Saizan: the return values cannot be modified
13:22:34 <gigamonkey_> That's the one.
13:22:36 <ddarius> gigamonkey_: Along with CosmicRay (John Goerzen) and dons (Don Stewart)
13:22:40 <oerjan> in that way
13:23:08 <gigamonkey_> How's it going?
13:23:15 <oerjan> iguana_: writer monads do something like this
13:23:27 <ddarius> @seen bos
13:23:27 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 16h 6m 1s ago.
13:23:30 <ddarius> @seen dons
13:23:30 <lambdabot> I saw dons leaving #xmonad and #haskell 1h 59m 3s ago, and .
13:24:07 <FMota> Anyone know how to install haskell-mode in Aquamacs? :/
13:24:19 <sioraiocht> FMota: yes, i have it
13:24:38 <FMota> can you help me? :)
13:24:38 <ddarius> gigamonkey_: dons just moved to America, so he's probably not working on it too hard right at the second.  bos and CosmicRay are no doubt hacking away.
13:24:51 <sioraiocht>  copy the haskell mode to sme directory, and have a .emacs file, here's mine
13:24:58 <sioraiocht> (load "/Users/rtharper/lib/emacs/haskell-mode/haskell-site-file")
13:25:07 <FMota> ok
13:25:08 <FMota> ty
13:25:20 <oerjan> @instances Monoid
13:25:28 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
13:25:49 <ddarius> gigamonkey_: I believe they were saying they'd start putting up content around this time (these months).
13:25:59 <gpi5> > div 1 2
13:26:04 <lambdabot>  0
13:26:09 <gigamonkey_> Yeah, I was wondering when that would happen.
13:26:10 <gpi5> > div (-1) 2
13:26:12 <lambdabot>  -1
13:26:13 <Esteth> hmm. I'm working through yaht, but i can't find a way to complete a task. It says to use a combination of fst and snd to get the snd element of the fst element. but "snd fst ((1, 'a'), "Foo")" gives an error
13:26:32 <gpi5> Why div (-1) 2 amounts to -1 ??
13:26:44 <Liskni_si> @index Monoid
13:26:44 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
13:26:45 <ari> :t snd fst
13:26:46 <ari> :t snd . fst
13:26:48 <lambdabot>     Couldn't match expected type `(a, b)'
13:26:48 <lambdabot>            against inferred type `(a1, b1) -> a1'
13:26:49 <lambdabot> forall a b b1. ((a, b), b1) -> b
13:26:59 <oerjan> > runWriter $ do tell (Sum 1); tell (Sum 2); return "hi"
13:27:00 <lambdabot>  ("hi",Sum {getSum = 3})
13:27:16 <oerjan> iguana_: ^^
13:27:36 <oerjan> as you see the count and return values are kept separate
13:27:39 <ddarius> @ask bos ETA on some Real World Haskell content?
13:27:39 <lambdabot> Consider it noted.
13:28:22 <twanvl> Esteth: "snd fst tuple" is the same as "(snd fst) tuple", while you want "snd (fst tuple)"
13:28:28 <ari> Esteth: In "snd fst foo" you're calling snd with two arguments, fst and foo
13:29:00 <Esteth> ari/ twanvl: Ahh, thanks
13:30:19 <sioraiocht> (+,Z) is a monoid, right?
13:30:35 <oerjan> sioraiocht: that's Sum Integer
13:30:51 <sioraiocht> oerjan: ah, so that's a yes =)  thanks
13:31:13 <oerjan> Product Integer would be (*, Z)
13:31:27 <sioraiocht> isn't (*,Z) also a group?
13:32:24 <sioraiocht> oh wait, no
13:32:28 <sioraiocht> there's no inverse
13:32:40 <oerjan> (+, Z) is though
13:32:45 <sioraiocht> right
13:35:02 <sioraiocht> what does the Sum type do?
13:35:05 <sioraiocht> @src Sum
13:35:05 <lambdabot> Source not found. It can only be attributed to human error.
13:35:13 <sioraiocht> guess that doesn't work, lol
13:35:33 <roconnor> sioraiocht: I think it converts a Num to a Monoid over plus
13:36:05 <roconnor> @src Data.Monoid.Sum
13:36:06 <lambdabot> Source not found. Do you think like you type?
13:36:26 <sioraiocht> mconcat [1..5]
13:36:33 <sioraiocht> > mconcat [1..5]
13:36:41 <lambdabot>  Add a type signature
13:36:44 <sioraiocht> > mconcat [1..5] :: Integer
13:36:45 <lambdabot>   add an instance declaration for (Monoid Integer)
13:36:45 <lambdabot>     In the expression: mco...
13:36:54 <roconnor> wow, apparently destructible updates are essential for program modularity
13:37:03 <roconnor> > mconcat [1..5] :: Sum Integer
13:37:04 <lambdabot>   add an instance declaration for (Num (Sum Integer))
13:37:04 <lambdabot>     In the expression: 5
13:37:17 <roconnor> > mconcat (map fromInteger [1..5]) :: Sum Integer
13:37:18 <lambdabot>   add an instance declaration for (Num (Sum Integer))
13:37:23 <roconnor> hmm
13:37:39 <twanvl> > mconcat (map Sum [1..5])
13:37:44 <lambdabot>  Sum {getSum = 15}
13:37:48 <sioraiocht> ah
13:37:52 <iguana_> oerjan: nice
13:38:00 <roconnor> > mconcat (map Product [1..5])
13:38:02 <lambdabot>  Product {getProduct = 120}
13:38:24 <sioraiocht> so by using Sum and Monoid you gain an abstraction about certain operations
13:38:27 <sioraiocht> ?
13:38:38 <roconnor> sioraiocht: and lose efficency :P
13:38:49 <sioraiocht> roconnor: then what's the point?
13:39:00 <roconnor> sioraiocht: abstraction is good
13:39:10 <sioraiocht> roconnor: I've never seen code utilise these type classes, that's why i'm curious
13:39:35 <roconnor> sioraiocht: It is used in the FingerTree API.
13:39:54 <roconnor> each finger tree is measured by an aribrary monoid.
13:40:15 <sebell>  /qut
13:40:46 <sioraiocht> > mempty
13:40:47 <lambdabot>  Add a type signature
13:40:53 <sioraiocht> > mempty (Sum 12)
13:40:54 <lambdabot>  Add a type signature
13:41:17 <sioraiocht> > mempty (Sum (12 :: Integer))
13:41:18 <lambdabot>  Add a type signature
13:41:48 <sioraiocht> what do you WANT from me, lambdabot?
13:42:10 <allbery_b> :t mempty
13:42:12 <lambdabot> forall a. (Monoid a) => a
13:42:30 <allbery_b> > mempty :: Sum Int
13:42:31 <lambdabot>  Sum {getSum = 0}
13:42:32 <roconnor> > mempty :: (Sum Integer)
13:42:33 <lambdabot>  Sum {getSum = 0}
13:42:34 <sioraiocht> oh
13:42:38 <sioraiocht> <--- retard
13:42:54 <sioraiocht> > mempty :: Product Int
13:42:55 <lambdabot>  Product {getProduct = 1}
13:45:34 <oerjan> sioraiocht: also as i showed above, Writer monads use Monoid
13:45:40 <oerjan> :t tell
13:45:43 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
13:48:17 <sioraiocht> I feel like with haskell, because it exposes you to so many issues of logic and mathematics, there's always more to learn and I'll never master it, lol
13:48:21 <oerjan> :t Writer
13:48:23 <lambdabot> forall a w. (a, w) -> Writer w a
13:48:41 <iguana_> sioraiocht: I know that feeling :)
13:48:44 <oerjan> it just hides the Monoid well :D
13:49:08 <phobes> I have the opposite feeling... I know exactly what I'm doing, but I still have so much to teach Haskell
13:49:22 <sioraiocht> phobes: lol
13:49:24 <iguana_> but that's also what makes it so fascinating
13:49:43 <sioraiocht> it just makes me feel like I'm a freshman undergrad again who knows nothing, lol
13:50:00 <iguana_> in contrast to other functional languages which have a "common" feel to them
13:51:28 <elliottt> i think that's what i like the most about haskell :)
13:51:39 <sioraiocht> elliottt: how stupid it makes you feel? lol
13:51:41 <elliottt> always something new
13:51:43 <elliottt> haha
13:52:00 <elliottt> sioraiocht: more like always being surprised
13:52:39 <sioraiocht> I actually currently have no work in haskell; I did a ton last year and learned a ton, but now I have other work I hang arond in hopes of absorbing more concepts, beacuse I just learn more about theory of computation along the way..maybe when I finish my PhD i'll be wise and learned about such issues
13:53:00 <matthew-_> sioraiocht: what are you doing your PhD in/on?
13:53:38 <sioraiocht> matthew-_: Computer Science.  I have to complete a Master's dissertation first, though; it'll be on some PL research, I'm just not sure what, yet
13:53:51 <elliottt> sounds like fun :)
13:54:19 <sioraiocht> yes
13:54:36 <matthew-_> sioraiocht: sounds familiar. Be sure to have either a supervisior with a sufficiently large boot or sufficiently large motivation to get through it
13:55:02 <sioraiocht> matthew-_: that
13:55:11 <sioraiocht> is probably the most distilled version of all the advice I ahve been given, lol
13:55:46 <matthew-_> sioraiocht: it seems to me the first year of a PhD is about learning as much as you want to and then realising how big the field is and how unlikely it is that you can change the world. I'm about to start my 2nd year and have massively scaled my plans down
13:56:11 <matthew-_> basically I dislike the whole thing now and so my motivation is about doing enough work and getting enough results to be able to get out in 2 years from now
13:56:47 <roconnor> is it just me or does this Peter Van Roy comment make very little sense.
13:56:55 <sioraiocht> my university tries to get their PhD students in three yeras (four years if you complete a MSc first)
13:57:07 <matthew-_> sioraiocht: which uni?
13:57:14 <sioraiocht> matthew-_: Oxford
13:57:30 <matthew-_> ahh, yes, sounds very much like the same setup as here at Imperial
13:57:39 <matthew-_> you with Peter Gibbons?
13:57:52 <sioraiocht> I almost applied to Imperial :) Their international student rates made me cry, though
13:58:11 <matthew-_> sioraiocht: most PhD students at Imperial do get funding though
13:58:30 <pejo> matthew, how do the ones without funding survive?
13:58:44 <sioraiocht> I actually havent' been told my advisor's name yet; term doesn't start for another 4 weeks and I don't leave the States for another two
13:58:55 <sioraiocht> matthew-_: are you british?
13:59:25 <matthew-_> sioraiocht: yep
13:59:39 <sioraiocht> it's a lot more painful to get funding if you're a non EU citizen
13:59:52 <matthew-_> sioraiocht: ahh yes, I've heard that
13:59:56 <ddarius> roconnor: Peter Van Roy usually knows what he is talking about.
14:00:11 <matthew-_> pejo: um, no idea.
14:00:25 <matthew-_> pejo: I don't think I know of any without funding tbh
14:00:48 <matthew-_> sioraiocht: which uni / degree have you been at in .us?
14:01:03 <sioraiocht> matthew-_: I got my BSc from Syracuse University in Computer Science
14:01:07 <roconnor> ddarius: but ``the number of times an operation is called'' only makes sense with respect to an implemenation of haskell.
14:01:25 <roconnor> haskell only has denotational semantics.
14:02:08 <matthew-_> sioraiocht: Syracuse in Sicily?
14:02:36 <matthew-_> sioraiocht: ahh, in NY
14:02:44 <phobes> ddarius: I think he incorrectly blames threaded state rather than blaming the way that it's often typed
14:02:44 <sioraiocht> matthew-_: No, new york state lacks originality in it's city names =)  There's a Syracuse, NY, Rome, NY, Mexico, NY, Lima, NY, Waterloo, NY...
14:03:19 <phobes> ddarius: but then I use 'incorrectly' loosely, because it's likely that what he intended was correct
14:03:24 <matthew-_> sioraiocht: sorry, my eu geography is vastly better than my .us geography ;)
14:03:43 <Esteth> join #python
14:03:51 <Esteth> sorry, forgot the /
14:04:09 <sioraiocht> matthew-_: same here, actually ;)  I grew up on the West coast, the states are so big we don't understand the little details of the rest of the US
14:04:32 <roconnor> Esteth: traitor :P
14:05:04 <monochrom> yeah, traitor of #python, working for #haskell undercover
14:06:16 <Esteth> roconnor: hehe. I don't know either language very much. I've been writing some ruby, but i'm getting somewhat irritated at how flexible it is (everyone's code looks different) and the lack of libraries/speed/portability. Python solves libraries and is somewhat less flexible, and very portable. Haskell should teach me something new, is fast, and should be good for math-y stuff :)
14:07:39 <monochrom> Haskell is fast???!!!!
14:07:53 <monochrom> (hehehehe I'm just teasing you)
14:07:55 <sorear> monochrom: sadly. :/
14:08:16 <Esteth> Faster than ruby, certainly. The fact that it compiles helps.
14:08:20 <sioraiocht> monochrom: have you used python or ruby? =p
14:08:21 <chessguy> @type when
14:08:23 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:08:56 <chessguy> @hoogle m Bool -> m () -> m ()
14:08:56 <lambdabot> No matches, try a more general search
14:09:01 <Esteth> monochrom: psychotic python is probably catching up to haskell, but i don't have figures
14:09:20 <chessguy> @type liftM when
14:09:22 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m () -> m ())
14:09:33 <Cale> Esteth: Haskell is also very flexible, but in such a way that you should always be able to figure out what's going on because of the types.
14:09:35 <chessguy> er, whoops
14:09:56 <sioraiocht> the static, strong typing of haskell is my favourite thing about it
14:09:58 <elliottt> Cale: that's what bothered me about ruby.  very flexible, but difficult to figure out what you were working with
14:10:03 <sioraiocht> it makes reasoning out someone elses code so much easier
14:10:46 <matthew-_> sorear: do I detect that you don't care for the attention Haskell gets for its speed or optimisation opportunities?
14:10:47 <phobes> Am I correct that Typeclasses are the only aspect of Haskell's type system that increase expressivity?
14:11:05 <phobes> (and other features to the extent that they interoperate with typeclasses)
14:11:06 <sorear> matthew-_: yes
14:11:08 <chessguy> @pl \d -> i d || f d
14:11:09 <lambdabot> liftM2 (||) i f
14:11:18 <sorear> matthew-_: it attracts people like Bulat and Ron
14:11:23 <Esteth> Cale: ok :)
14:11:33 <ddarius> > let (-@) = undefined in (-@)
14:11:35 <lambdabot>  Undefined
14:11:39 <ddarius> Sweet.
14:12:03 <monochrom> It's like you're some middle-class person, working long hours, your income just enough to pay off your mortgage, your tax, your kids' expenses. You always think there are people richer to you. Then one day, suddenly some peasant from a thousand years ago got teleported to you, and he says, "you live like a King!"
14:12:12 <ddarius> phobes: Define expressivity?
14:12:38 <EvilTerran> phobes, well, tuples and algebraic data types in general save me a lot of boilerplate
14:13:02 <ddarius> dons: ETA for Real World Haskell content?
14:13:07 <EvilTerran> no more typedef struct { foo first; bar second } FooBarPair; etc.
14:13:51 <ddarius> EvilTerran: Haskell record syntax is no better than that (except by perhaps a "constant factor")
14:14:17 <EvilTerran> ddarius, but C and its derivatives have no anonymous tupling
14:14:22 <wli> monochrom: Not true of the 5/6 of humanity that's literally starving.
14:14:30 <dons> ddarius: sometime in the next few weeks, I think. bos is hard at work getting the auto-publishing stuff going
14:14:30 <EvilTerran> and working around that costs me a big whack of typing
14:14:31 <ddarius> It's no trouble defining them in say C++ or C#
14:14:34 <phobes> ddarius: I mean expressive power in ability to solve a problem, and I explicitly want to exclude mistake catching ability
14:14:49 <ddarius> dons: Thanks, that's about what I told gigamonkey.
14:14:56 <EvilTerran> (typing as in clacky clacky, not, er, inducty inducty.)
14:15:08 <phobes> EvilTerran:  I guess data types and pattern matching have to be included as well, but that could be done in an untyped way I think
14:15:19 <EvilTerran> pattern matching!
14:15:22 <dons> ddarius: i'm just getting up to speed here in portland, but given a week or two, we should be into full production mode :)
14:15:23 <ddarius> phobes: You still aren't being specific enough.
14:15:31 <EvilTerran> yes, that's what i was thinking of when i said "algebraic types"
14:15:36 <hpaste>  chessguy pasted "Am i missing a simplifcation here?" at http://hpaste.org/2633
14:15:42 <ddarius> dons: Yeah, I told him that you're probably not doing to much on it of late due to the move.
14:15:58 <dons> yep. though i hope to get into it this week
14:16:15 <dons> btw, people in the portland area, i'm giving a talk about xmonad, QuickCheck , Catch and HPC on Tuesday at galois
14:16:25 <dons> i think there's some PSU announce page about it.
14:16:31 <dons> @seen Binkley
14:16:31 <lambdabot> I saw Binkley leaving #haskell 3d 6h 18m 49s ago, and .
14:16:31 <EvilTerran> 'cos you can fake algebraic types in C with struct { enum { Foo, Bar, Baz } constructor; union { struct Foo; struct Bar; struct Baz } params } AlgebraicType
14:16:36 <dons> @seen wli
14:16:36 <lambdabot> wli is in #haskell. I last heard wli speak 2m 14s ago.
14:16:43 <dons> i'll at least put up some slides
14:16:50 <EvilTerran> but it's still a bugger to use, 'cos of the lack of pattern matching
14:17:34 <EvilTerran> chessguy, is that there a Chess monad?
14:17:46 <chessguy> EvilTerran, yes, a very simple one
14:17:53 <EvilTerran> hm
14:18:05 <chessguy> type Chess = State GameState
14:19:07 <ddarius> "Oh no! My code is more than two lines!  There must be a better way!"
14:19:26 <kpreid> chessguy: ListT perhaps?
14:19:33 <chessguy> ddarius, that wasn't my point
14:19:37 <kpreid> er, no, that's not quite right
14:19:50 <oerjan> @remember ddarius "Oh no! My code is more than two lines!  There must be a better way!"
14:19:50 <lambdabot> Done.
14:19:57 <mr_tenor> so true ;)
14:20:08 <chessguy> @quote melted
14:20:08 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
14:20:24 <sorear> @quote hypermonad
14:20:24 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
14:20:28 <sorear> @quote hyper-monad
14:20:28 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
14:20:28 <lambdabot> for your entire program.")
14:20:38 <monochrom> Yeah, 2 lines, one of which is type signature. :)
14:20:41 <kpreid> chessguy: how about a ChessT [Pos]?
14:20:56 <chessguy> kpreid, hm?
14:20:57 <kpreid> chessguy: then you could use 'guard' for the validity checks
14:21:26 <kpreid> hmm...
14:21:40 <chessguy> kpreid, which validity checks?
14:21:42 <kpreid> maybe ListT Chess is better
14:21:48 <kpreid> chessguy: the condition in the if'
14:21:57 <hpaste>  EvilTerran annotated "Am i missing a simplifcation here?" with "how about this, chessguy?" at http://hpaste.org/2633#a1
14:22:10 <oerjan> @pl \b x -> b >>= flip when x
14:22:11 <lambdabot> (. flip when) . (>>=)
14:22:13 <kpreid> ListT Chess would let you operate over several futures, if that's interesting
14:22:19 <EvilTerran> it's a bit of a hack, but now i look at it, it's not actually shorter
14:22:27 <EvilTerran> whoa, unicode characters?
14:22:40 <EvilTerran> i'll keep thinking
14:22:41 <ddarius> I doubt you want to use ListT for this.
14:22:47 <chessguy> heh. cute
14:22:59 <chessguy> kpreid, several futures?
14:23:10 <kpreid> chessguy: never mind.
14:23:39 <xerox> kpreid: your graph life is really neat.
14:23:55 <kpreid> how about: return [dest | valid dest, not f]
14:24:05 <chessguy> EvilTerran, hmm. that idea may come in handy for a similar function
14:24:08 <kpreid> xerox: thanks.
14:24:31 <EvilTerran> or what kpreid just wrote. that's cooler, imo.
14:24:42 <chessguy> that is nice
14:24:47 <kpreid> xerox: want to write the infinite field setup function?
14:24:49 <EvilTerran> > [ 1 | True ]
14:24:51 <lambdabot>  [1]
14:24:54 <EvilTerran> > [ 1 | False ]
14:24:55 <lambdabot>  []
14:25:01 <EvilTerran> mmm. cunning.#
14:25:18 <EvilTerran> .oO( unboxed cunning? )
14:25:19 <chessguy> i was mostly wondering about whether i have to explicitly pull friendly dest out of the monad
14:25:23 <ddarius> Now we just need to have ; replace (||)
14:25:36 <kpreid> chessguy: pretty much, yes
14:25:36 <xerox> kpreid: maybe. I also find very cute the use of GL, can you point me in the right direction to learn how to use it efficiently?
14:25:59 <chessguy> ok
14:25:59 <EvilTerran> chessguy, does it matter if we flip the arguments to (||)?
14:26:07 <chessguy> EvilTerran, no
14:26:08 <kpreid> xerox: well, I started with the nehe tutorials, wrote a bunch of screen savers
14:26:34 <kpreid> xerox: for this I took a small Haskell GL example and then chopped out everything unnecessary
14:26:42 <chessguy> @go nehe tutorials
14:26:45 <lambdabot> http://nehe.gamedev.net/
14:26:46 <lambdabot> Title: NeHe Productions: Main Page
14:26:48 <xerox> kpreid: ah, I thought you used that quartz composer application for the screensavers. Alright.
14:27:02 <kpreid> xerox: nope, never used QC for anything released
14:27:22 <ddarius> > let (=>) = undefined in (=>)
14:27:22 <lambdabot>  Parse error
14:27:35 <oerjan> => is a keyword
14:27:50 <oerjan> (class contexts)
14:28:01 <ddarius> I can't think of a case where it applies at the value level, so it shouldn't conflict.
14:28:14 <chessguy> kpreid, i guess that's because friendly is monadic and valid isn't?
14:28:31 <kpreid> chessguy: roughly so
14:28:34 <xerox> kpreid: the function you miss is the one that initializes just the border of the torus? I guess this is not what you were talking about with "infinite filed" though.
14:28:42 <kpreid> xerox: no
14:28:54 <kpreid> xerox: one which makes a genuinely infinite field
14:29:08 <kpreid> lazily computed, of course, with some function specifying the initial values
14:29:29 <xerox> Right.
14:29:32 <EvilTerran> chessguy, you could use return.valid
14:30:01 <kpreid> of course every successive generation must then take more time (because it evaluates a one-cell-larger-in-every-dimension area)
14:30:09 <EvilTerran> but i doubt it'd make anything any nicer
14:30:27 <chessguy> EvilTerran, hm?
14:30:56 <kpreid> chessguy: maybe it'd work better to pass in the state rather than making it monadic?
14:30:56 <EvilTerran> stick the result of valid in the monad, do something horrible with liftM... never mind, it's not worth pursuing
14:31:08 <kpreid> i.e Pos -> Pos -> GameState -> [Pos]
14:31:10 <ddarius> Yay unsafeCoerce
14:31:19 <chessguy> kpreid, i've thought of that
14:31:40 <EvilTerran> mfilter :: MonadZero m => (a -> m Bool) -> m a -> m a -- would be nice here
14:31:44 <chessguy> kpreid, i keep going back and forth between wanting to do that and wanting to do it with State
14:31:45 <ddarius> @index unsafeCoerce
14:31:45 <lambdabot> bzzt
14:31:52 <ddarius> @hoogle unsafeCoerce
14:31:53 <lambdabot> No matches found
14:32:04 <EvilTerran> @let mfilter = liftM2 (>>) guard return
14:32:08 <kpreid> chessguy: I'd leave at as it is (with the [ dest | change) for now, I think
14:32:08 <lambdabot> <local>:6:22:     Ambiguous type variable `m' in the constraint:       `Monad...
14:32:09 <oerjan> @index unsafeCoerce#
14:32:10 <lambdabot> bzzt
14:32:22 <EvilTerran> @let mfilter :: MonadZero m => (a -> m Bool) -> m a -> m a; mfilter = liftM2 (>>) guard return
14:32:23 <lambdabot> <local>:6:11: Not in scope: type constructor or class `MonadZero'
14:32:24 <chessguy> kpreid, mostly because i don't have enough experience to know which is better
14:32:29 <EvilTerran> @let mfilter :: MonadPlus m => (a -> m Bool) -> m a -> m a; mfilter = liftM2 (>>) guard return
14:32:30 <lambdabot> Couldn't match expected type `a -> m Bool'
14:32:32 <EvilTerran> gah
14:32:38 <kpreid> chessguy: well, you can interconvert at any time
14:32:50 <chessguy> kpreid, yeah, but it's a pain in the butt
14:33:02 <kpreid> so write functions!
14:33:10 <chessguy> functions?
14:33:19 <kpreid> to wrap up the conversion
14:33:33 <chessguy> you lost me
14:33:47 <xerox> State and runState? (-:
14:34:08 <kpreid> and fmap f get
14:34:25 <kpreid> i.e. do ...; value <- fmap functionTakingAState get; ...
14:34:58 <kpreid> fmap f a == do x <- a; return (f x)
14:35:05 <oerjan> @let mfilter :: MonadPlus m => (a -> m Bool) -> m a -> m a; mfilter = (>>= liftM2 (>>) guard return)
14:35:06 <lambdabot> Couldn't match expected type `m a'
14:35:10 <chessguy> so i would write all my functions to accept the state explicitly?
14:35:19 <dons> Igloo: do you have the url of that debian package popularity site?
14:35:22 <kpreid> only the ones cleaner that way!
14:35:31 <dons> i'm wondering what the x11 et al. packages have been doing since xmonad 0.1
14:35:56 <chessguy> and then a function to convert a function in that form to a function which handles the state monadically
14:35:58 <kpreid> chessguy: but wrt monad usage in general -- learn to use fmap / liftM*
14:36:13 <chessguy> kpreid, i'm learning to use liftM
14:36:19 <chessguy> i generally stay away from fmap
14:36:28 <xerox> They are the same function.
14:36:28 <Igloo> dons: http://people.debian.org/~igloo/popcon-graphs/index.php?packages=libghc6-x11-dev%2Clibghc6-mtl-dev&show_installed=on&want_legend=on&want_ticks=on&from_date=&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
14:36:30 <lambdabot> Title: popcon graph, http://tinyurl.com/3dwq22
14:36:31 <kpreid> chessguy: fmap/liftM *is* that function, if the state isn't modified
14:36:48 <chessguy> well some functions will modify the state
14:37:00 <kpreid> > runState (fmap (+1) get) 1
14:37:02 <lambdabot>  (2,1)
14:37:11 <kpreid> > runState (liftM (+1) get) 1
14:37:13 <lambdabot>  (2,1)
14:37:21 <chessguy> xerox, i know that, but i mean i don't usually need to explicitly use the more general version
14:37:22 <dons> Igloo: cheers
14:38:18 <EvilTerran> @let mfilter p x = x >>= p >>= guard >> x
14:38:26 <lambdabot> Defined.
14:38:51 <EvilTerran> mfilter (return.(>0)) (Just 0)
14:38:54 <EvilTerran> > mfilter (return.(>0)) (Just 0)
14:38:55 <lambdabot>  Nothing
14:38:59 <dons> Igloo: do you have a list of haskell packages somewhere?
14:38:59 <EvilTerran> > mfilter (return.(>0)) (Just 1)
14:39:00 <lambdabot>  Just 1
14:39:15 <oerjan> EvilTerran: that may run x twice
14:39:17 <EvilTerran> ?type L.mfilter
14:39:19 <lambdabot> Couldn't find qualified module.
14:39:24 <EvilTerran> hm. i guess.
14:39:43 <EvilTerran> @undef
14:39:45 <lambdabot> Undefined.
14:40:07 <EvilTerran> @let mfilter p m = do x <- m; px <- p x; if px then x else mzero
14:40:08 <lambdabot> Defined.
14:40:29 <EvilTerran> wait, that's not right.
14:40:33 <EvilTerran> @undef , never mind
14:40:36 <lambdabot> Undefined.
14:41:00 <hpaste>  Igloo pasted "dons: Debian Haskell libraries" at http://hpaste.org/2634
14:41:18 <dons> Igloo++
14:41:47 <TSC> There are hugs library packages too
14:42:15 <dons> so no xmonad or x11-extras
14:42:51 <sorear> TSC: xmonad is not compatible with hugs :/
14:43:05 <dons> :)
14:43:11 <dons> oh, i mean, :|
14:43:16 <dons> no, actually, :)
14:43:18 <Igloo> Yup, those are just the libghc6-.*-dev packages
14:43:24 <dons> ok.
14:43:42 <sorear> since we all know dons is out to destroy all C programs :P
14:44:01 <dons> that's true enough.
14:44:10 <dons> all unix console tools, anyway
14:44:16 <dons> and system utilities
14:44:18 <dons> and kernel modules
14:44:20 <dons> and drivers
14:44:22 <dons> and browsers
14:44:24 <dons> and servers
14:45:00 <sorear> but not haskell runtime systems? :P
14:45:15 <dons> oh, that too. ultimately.
14:45:30 * chessguy thought for a minute that sorear said that xmonad is not compatible with bugs
14:45:35 <dons> mm, this new laptop is noticeably faster than the old one.
14:45:42 <dons> amazing how hardware improves in 4 years :)
14:45:50 <dons> xmonad actually feels fast now
14:46:03 <dons> instead of just quick
14:46:09 <ddarius> xmonad felt slow?  What did the other wms feel like?
14:46:16 <dons> glacial?
14:46:16 <TSC> A subtle distinction, obviously
14:46:33 <oerjan> @let mfilter p m = m >>= \x -> p x >>= guard >> return x
14:46:36 <lambdabot> Defined.
14:46:51 <oerjan> @pl mfilter p m = m >>= \x -> p x >>= guard >> return x
14:46:51 <lambdabot> mfilter = (=<<) . (`ap` return) . ((>>) .) . flip flip guard . ((>>=) .)
14:46:52 <dons> well, i notice i have to be pretty quick to lift off the keys, when flipping through clients, since they're rendering so fast
14:47:00 <oerjan> *cough*
14:47:10 <dons> cute
14:50:20 <oerjan> :t \p m -> m >>= liftM2 (>>) (>>=guard).p) return
14:50:23 <lambdabot> parse error on input `)'
14:50:33 <oerjan> :t \p m -> m >>= liftM2 (>>) ((>>=guard).p) return
14:50:36 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> m Bool) -> m a -> m a
14:50:48 <oerjan> @pl \p m -> m >>= liftM2 (>>) ((>>=guard).p) return
14:50:49 <lambdabot> (=<<) . flip (liftM2 (>>) . ((guard =<<) .)) return
14:51:12 <oerjan> ah, better
14:53:02 <EvilTerran> still not very nice
14:53:35 <oerjan> @pl \m p -> m >>= liftM2 (>>) ((>>=guard).p) return
14:53:36 <lambdabot> (. flip (liftM2 (>>) . ((guard =<<) .)) return) . (>>=)
14:53:40 <EvilTerran> ew
14:53:52 <EvilTerran> bonus: two monads at once
14:54:02 * EvilTerran is reminded of his fmap monstrosity from earlier
14:54:35 <ddarius> Now you're making me want to write a piece of code that uses a countable infinity of monads.
14:55:17 <EvilTerran> surely that'd require an infinite type?
14:56:16 <ddarius> I was thinking of something using polymorphic recursion.
14:57:26 <chessguy> kpreid, ok, i'm trying to take your advice, and not getting it
14:57:57 <joelr1> good evening
14:58:56 <hpaste>  chessguy annotated "Am i missing a simplifcation here?" with "for kpreid" at http://hpaste.org/2633#a2
14:59:23 <chessguy> kpreid, it appears to me that friendly could be more easily written to take the state explicitly, but won't that screw up step?
14:59:54 <kpreid> chessguy: well, if you were to do that you'd write step to take the state explicitly too.
15:00:01 <kpreid> I'm not sure it's a good idea though.
15:00:12 <kpreid> I'd stick with the ... <- friendly ... for now.
15:00:18 <chessguy> yeah, that sounds bad to me
15:00:33 <sysfault> howdy AtnNn
15:00:48 <hpaste>  EvilTerran annotated "Am i missing a simplifcation here?" with "another attempt" at http://hpaste.org/2633#a3
15:01:06 <AtnNn> hello there
15:02:02 <EvilTerran> TBH, i think the version with do{} and the list comprehension is the clearest
15:02:12 <chessguy> EvilTerran, there's also a valid function :)
15:02:31 <EvilTerran> you don't need the $ before the comprehension, BTW
15:02:46 <chessguy> oh yeah, that's a holdover from before
15:02:49 <chessguy> no big deal though
15:02:55 <EvilTerran> i figured, but i'd either need to invert the result of "friendly" or of the disjunction
15:03:02 <EvilTerran> ...unless you've got "unfriendly", too?
15:03:08 <chessguy> no
15:04:11 <joelr1> i wonder what needs to be done to make ghc generate shared libraries
15:04:11 <kpreid> I'd be tempted to write an unfriendly (= not . friendly) just to take out the not
15:04:17 <joelr1> anyone?
15:04:57 <chessguy> joelr1, maybe a question for #ghc?
15:05:10 <joelr1> chessguy: aye!
15:05:37 <chessguy> err
15:05:41 <thoughtpolice> joelr1: there was a summer of code project to do it, it gives a short outline of what you'd need
15:05:59 <thoughtpolice> http://code.google.com/soc/2007/haskell/appinfo.html?csaid=D0137F8B637176F1
15:06:01 <lambdabot> Title: Google Code - Summer of Code - Application Information, http://tinyurl.com/3afhje
15:06:02 <chessguy> kpreid, surely that wouldn't work
15:06:12 <joelr1> thoughtpolice: thanks!
15:06:24 <kpreid> chessguy: err, right. fmap not friendly
15:06:33 <kpreid> not `fmap` friendly
15:06:38 <kpreid> not `liftM` friendly
15:06:51 <chessguy> i prefer liftM unless the generality is needed for some reason
15:07:13 <joelr1> thoughtpolice: how do i tell if anything was done with this project?
15:07:22 <glguy> fmap is nice because you don't have to import to use it
15:08:01 <thoughtpolice> joelr1: not sure, you might have to get in touch with simon mar. or clemens to get info.
15:08:42 <joelr1> ok
15:14:47 <beelsebob> what's hugs written in
15:14:50 <beelsebob> Haskell?
15:14:56 <sieni> perl, of course
15:15:04 <beelsebob> o.O
15:15:05 <beelsebob> really?
15:15:18 <sorear> C
15:15:22 <sieni> just kidding
15:15:24 * oerjan almost soaked his keyboard now
15:15:24 <beelsebob> win!
15:15:36 <beelsebob> I have a porting project to do now :)
15:15:45 <mlesniak> but perl6 is written in haskell ;)
15:15:46 <beelsebob> porting hugs -> iPhone
15:15:51 <sorear> beelsebob: it's written in huge amounts of C
15:16:03 <beelsebob> mlesniak: well, pugs is, and pugs is a reference implementation rather than a useful one
15:16:11 <sorear> 50k lines
15:16:22 <chessguy> @type guard
15:16:24 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:16:26 <beelsebob> that should easily be doable
15:16:35 <beelsebob> make it terminal runable in the first place
15:16:39 <beelsebob> and then add a nice interface
15:16:41 <sorear> the iPhone can run C usefully?
15:16:50 <beelsebob> there's a C cross compiler for it, yes
15:17:01 <chessguy> @hoogle (Monad m) => m Bool -> a -> a -> a
15:17:02 <beelsebob> it's a hack to make anything run -- but who cares
15:17:02 <lambdabot> No matches, try a more general search
15:17:08 <beelsebob> there's a package manager even now
15:17:16 <sorear> I would have thought it would require signed binaries, with a key better guarded than the Coke formula
15:17:28 <chessguy> we need an ifM
15:17:44 <sorear> beelsebob: you might have better luck with yhi :)
15:18:01 <stepcut> and a, bool :: a -> a -> Bool -> a
15:18:25 <chessguy> stepcut, that's just a re-arranted if'
15:18:35 <chessguy> s/ted/ged/
15:18:40 <beelsebob> sorear: maybe, maybe not -- yhc has a lot of Haskell in it -- this would imply being able to cross compile the Haskell
15:18:43 <stepcut> chessguy: yes, but you can partially apply it
15:18:45 <beelsebob> which may be a lot of hard work
15:19:17 <sorear> beelsebob: why would you need to cross compile haskell?
15:19:27 <sorear> beelsebob: york bytecode is platform independant
15:19:35 <chessguy> so write bool t f b = if' b t f
15:19:51 <chessguy> @pl bool t f b = if' b t f
15:19:51 <lambdabot> bool = flip . flip if'
15:19:54 <beelsebob> ohhh
15:19:58 <beelsebob> so use yhc to compile yhi
15:20:06 <beelsebob> use the C cross compiler to port the runtime
15:20:07 <chessguy> heh. that's cute
15:20:12 <sorear> beelsebob: so run yhc on your PC, and transport the .hbc files to the iPhone
15:20:14 <beelsebob> and then dump it on
15:20:18 <sorear> beelsebob: yhc can't compile yhi
15:20:19 <stepcut> chessguy: I have -- many times, that is the problem ;)
15:20:22 <sorear> beelsebob: yhi is pure C
15:20:31 <sorear> beelsebob: yhc only compiles Haksell
15:20:32 <stepcut> chessguy: it should be in Data.Bool
15:20:51 <beelsebob> sorear: oh, hang on, naming convention wrongness
15:21:00 <beelsebob> are you saying to port the runtime
15:21:04 <beelsebob> but not the interpretter
15:21:20 <sorear> yhi is the runtime and the interpreter
15:21:30 <beelsebob> no, yhe is the interpretter
15:21:34 <beelsebob> york haskell evaluator
15:21:44 <beelsebob> it happens to be written in Haskell though
15:21:49 <beelsebob> so it could be compiled with yhc
15:21:51 <chessguy> er
15:21:51 <sorear> yhi is an intepreter too
15:22:02 <beelsebob> wait
15:22:03 <beelsebob> doom
15:22:13 * beelsebob needs to poke yhc again -- long time since I've played with it
15:22:20 <fuxxx> @pl \(f,a,b) = f a b
15:22:21 <lambdabot> (line 1, column 6):
15:22:21 <lambdabot> unexpected ","
15:22:21 <lambdabot> expecting letter or digit, operator or ")"
15:22:21 <lambdabot> ambiguous use of a non associative operator
15:22:26 <sorear> I thought you were on the devteam?
15:22:46 <EvilTerran> @pl \(f,a,b) -> f a b
15:22:46 <lambdabot> (line 1, column 6):
15:22:46 <lambdabot> unexpected ","
15:22:46 <lambdabot> expecting letter or digit, operator or ")"
15:22:46 <lambdabot> ambiguous use of a non associative operator
15:22:46 <oerjan> fuxxx: @pl doesn't do more than pairs
15:22:50 <beelsebob> sorear: long time since I could do that unfortunately
15:22:56 <fuxxx> oh, ok.
15:23:08 <EvilTerran> wait, of course that wouldn't work. there's no combinators for triples.
15:23:32 <oerjan> indeed
15:23:52 <oerjan> thought that doesn't stop @pl from doing if-then-else
15:23:53 <beelsebob> sorear: according to the wiki, yhe is still the interpretter
15:23:58 <oerjan> *though
15:24:04 <beelsebob> and yhi is still the runtime and bytecode interpretter
15:25:55 <beelsebob> right
15:25:56 <beelsebob> well
15:25:59 <beelsebob> yhe would be easy
15:26:05 <beelsebob> but I think it'd be nicer to get hugs running
15:26:12 <beelsebob> would save having to run it in a VM
15:26:19 <beelsebob> which is fairly important on a 700Mhz ARM
15:27:30 <elliottt> @hoogle [a] -> Bool
15:27:34 <lambdabot> Prelude.null :: [a] -> Bool
15:27:35 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
15:27:35 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
15:28:09 <thoughtpolice> beelsebob: it might also be worth seeing if you could get jhc to output some C that would run, too
15:28:22 <chessguy> let me try again, this time in english
15:28:26 <oerjan> @hoogle+
15:28:27 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
15:28:27 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
15:28:27 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
15:28:33 <thoughtpolice> I believe shapr had some luck with using jhc's generated C on his phone
15:28:38 <chessguy> is there a class for monads for which there is a function extract :: m a -> a
15:28:50 <oerjan> chessguy: nope
15:29:04 <oerjan> although it is often called runXXX
15:29:12 <oerjan> where XXX is the monad name
15:29:25 <thoughtpolice> isn't a function of that form more for comonads?
15:29:31 <oerjan> also, it can take extra arguments as appropriate
15:29:46 <oerjan> :t runStateT
15:29:46 <beelsebob> of course... now I need an iPhone
15:29:51 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:30:05 <beelsebob> but that shouldn't be too long away
15:30:29 <chessguy> hm. wierd that there's not a typeclass for it
15:31:08 <oerjan> monads differ too much in what you need to provide to run them, and what they give as result
15:31:17 <kpreid> chessguy: there are very few interesting monads for which that's a useful function
15:31:29 <kpreid> Writer is the only one that comes to mind, and then you're ignoring the result
15:31:37 <kpreid> the output, I should say
15:31:41 <EvilTerran> well, there's Maybe and []...
15:32:05 <EvilTerran> if you know/assume there's at least one result
15:32:25 <kpreid> bah, partial functions :)
15:32:44 <EvilTerran> bah, reality!
15:33:03 <sorear> beelsebob: ehem...
15:33:11 <sorear> beelsebob: yhi is too an interpreter
15:33:22 <sorear> beelsebob: it doesn't accept raw haskell
15:33:26 <beelsebob> sorear: exactly
15:33:32 <sorear> beelsebob: but it *will* suffice for running haskell programs
15:33:32 <beelsebob> it's a byte code interpretter
15:33:39 <beelsebob> yeh... but I don't want to run haskell programs
15:33:47 <beelsebob> I want to interpret arbitary bits of Haskell
15:33:51 <sorear> beelsebob: ah.
15:34:04 <beelsebob> for which I need yhe, or hugs
15:34:08 <sorear> beelsebob: well, hugs is much slower than yhi/yhe
15:34:13 <beelsebob> because porting ghci doesn't appeal
15:34:20 <beelsebob> sorear: really?
15:34:23 <beelsebob> fair enough
15:34:33 <sorear> beelsebob: both ways you use a VM
15:34:34 <beelsebob> I'll try both
15:34:52 <sorear> beelsebob: one is a tree-walking VM, the other is a bytecode VM
15:35:03 <beelsebob> fair enough
15:36:40 <kscaldef> hi.... it looks to me like Network.HTTP calls "error" on a connection timeout, which seems a particularly unfortunate design decision.  Am I missing some way of preventing this?  Is there an HTTP library that doesn't behave this way?
15:37:35 <sorear> kscaldef: why is it unfortunate?
15:37:50 <sorear> kscaldef: don't forget about Control.Exception.catch
15:38:13 <gpi5> Quick question: for a function f, is there a way to express that f a b c = f b c a = f c a b = ... (the number of patterns to write would be much smaller). Thanks
15:39:07 <sysfault> permutational function?
15:39:15 <EvilTerran> what type are the parameters?
15:39:26 <sorear> gpi5: 'f is a symmetric function'
15:39:37 <kscaldef> sorear: thanks for reminding me where that was... I was starting to think I imagined it (it's been a couple months since I last worked on this project)
15:39:38 <EvilTerran> sorear, i think he means in haskell
15:39:51 <oerjan> gpi5: you might sort them first?
15:39:52 <Botje> gpi5: write a function that takes a list [a,b,c] and calls f a b c
15:39:59 <gpi5> EvilTerran: yes, in haskell
15:40:04 <Botje> then just call that function with a permutation of the list
15:40:30 <EvilTerran> that's what i was going to suggest
15:41:22 <gpi5> Problem is, I have to write stuff like f 'x' _ _ = 'x' , f _ 'x' _ = 'x' , f _ _ 'x' = 'x' ... very very boring.
15:41:34 <kscaldef> sorear: it's unfortunate because a) it's undocumented and b) the library also uses Either to return errors.  So, it seems that for a call to simpleHTTP, I have to both catch exceptions and unpack the Either.  Ugly.
15:42:34 <EvilTerran> devise some ordering of the parameter type, then write f' a' b' c' = f a b c where [a,b,c] = sort [a',b',c']?
15:43:50 <Botje> gpi5: f a b c | 'x' `elem` [a,b,c] = ... ?
15:44:03 <monochrom> It may reflect a design flaw.
15:44:08 <EvilTerran> that too
15:45:21 <gpi5> Consider data T = A | B | X. f T->T->T->T. To define the function, how many patterns do I have to write if this function is symmetric. Don't tell me 9?
15:46:20 <allbery_b> depending on what you're doing, might convert args to a list and map (or mapAccumL, etc.) over it
15:46:34 <allbery_b> or fold, etc. depending on what you actually want
15:47:16 <oerjan> data T = A | B | X deriving (Eq, Ord), then EvilTerran's suggestion
15:47:17 <allbery_b> guess not mapAccum*
15:48:33 <oerjan> or Botje's suggestion if it works
15:49:08 <EvilTerran> ... i'm not sure if you need 9. if it were asymmetric, you could need up to 27, surely?
15:49:51 <EvilTerran> AAA,AAB,AAX,ABB,ABX,AXX,BBB,BBX,BXX,XXX. so... ten, i'm afraid.
15:50:10 <gpi5> Ok, I was hoping haskell would provide some magic :)
15:50:14 <gpi5> Thanks.
15:50:22 <EvilTerran> well, that's less than 27!
15:50:57 <EvilTerran> and you may be able to get it lower if you can use the wildcard pattern in places.
15:52:26 <gpi5> I think I'll convert the type to a new type where there are some symmetric operators (like +). Thanks.
15:53:37 <EvilTerran> another idea that occurs to me is that you could use an array indexed by triples as a lookup table, and it might be possible to define that in some elegant way
15:53:49 <EvilTerran> depending on what your function actually does
15:55:07 <oerjan> you could combine that with the sort suggestion, naturally
15:57:04 <norgul> hi
15:57:34 <shapr> thoughtpolice: On my Nokia 770
15:57:53 <norgul> just wondered what editor you guys use when you code haskell?
15:58:04 <sjanssen> norgul: vim
15:58:23 <kscaldef> norgul: emacs
15:58:24 <sorear> vim
15:58:41 <earnest> ed
15:58:42 <norgul> haskell-mode seems to be fucked up in emacs :S
15:58:49 <earnest> :)
15:58:58 <sorear> not fucked up, just well documented
15:59:04 <kscaldef> define "fucked up"?
15:59:06 <norgul> the idention is weird
15:59:26 <kscaldef> define "weird"
15:59:29 <earnest> :)
15:59:32 <newsham> ?remember sorear [emacs haskell mode] not fucked up, just well documented
15:59:32 <lambdabot> Done.
15:59:45 <monochrom> emacs and eclipse
15:59:50 <norgul> uhm
15:59:55 <kscaldef> you realize that repeated TABs will cycle through possible indentations of a line
15:59:55 <sorear> norgul: i'm pretty sure it says very clearly in the documentation that because of indentation sensitivity, there are multiple valid intentations, and you have to tell it which one by multiple TAB presses
16:00:04 <norgul> im thinking about switching
16:00:16 <monochrom> haskell indentation is undecidable.
16:00:33 <norgul> i know that
16:00:38 <norgul> but when i press enter
16:00:50 <norgul> the TAB is set about to 30 spaces or so
16:00:51 <monochrom> you want it to stick out a probe
16:01:06 <monochrom> and the probe penetrates your brain
16:01:12 <monochrom> and it reads what you want
16:01:16 <kscaldef> norgul: frequently, that's a reasonable choice
16:01:42 <norgul> well
16:02:00 <monochrom> And after coding Haskell using this probe for a month
16:02:07 <monochrom> your head will have more holes
16:02:18 <monochrom> then the arm of the most addicted drug addict.
16:02:46 <newsham> most drug addicts dont shoot up
16:02:48 <monochrom> Alternatively, you can press tab a few more times than you like. Or press space.
16:04:31 <ddarius> Or turn the thing off.
16:04:53 <norgul> i will start using YI instead
16:05:09 * FMota is thinking about functional assembly.
16:05:33 <earnest> wild thinking :)
16:05:38 <FMota> ;)
16:05:41 <newsham> speaking of drugs
16:07:11 <earnest> so FMota, I didn't finish my explanation last time as to why I speak Portuguese for real
16:07:23 <FMota> hmm?
16:07:40 <earnest> somebody asked my where I was from, and I said I was from America, and eventually I got distracted into some other subject
16:07:52 <earnest> I said I spoke Portuguese muy bien
16:08:02 <earnest> remember? and I do :)
16:08:11 <FMota> I remember
16:08:13 <earnest> and although I really am from America, I think I mislead people
16:08:26 <earnest> I'm from the America in the south
16:08:33 <FMota> ah
16:08:34 <nuncanada_> Mucho bueno en portugues?
16:08:37 <FMota> makes more sense.
16:08:42 <earnest> and I speak Portuguese because your country colonized by country :)
16:08:47 <newsham> thats not the real america
16:08:54 <FMota> newsham: you suck :)
16:09:03 <newsham> i'm american.  i rock.
16:09:07 <earnest> hehe, newsham: you suck :)
16:09:10 <earnest> hehe
16:09:12 <nuncanada_> newsham, actually the America name is from the continent
16:09:25 <FMota> so, Brasil
16:09:32 <earnest> that's me :)
16:09:32 <FMota> (or Brazil)
16:09:34 <nuncanada_> USA propositelly wants this to get messed up
16:09:46 <newsham> when god blessed america I think he was talking about the one with the pyramid on the back of their money
16:09:56 <FMota> Brazil is nice.
16:10:01 <earnest> Brazil is.
16:10:12 <FMota> nicer than Portugal, I'd venture to say.
16:10:13 <earnest> Did you know that Brazil used be spelled Brazil?
16:10:20 <earnest> Why would it be nicer than Portugal?
16:10:22 <nuncanada_> Entoces, su hablas portunhol?
16:10:23 <FMota> really? :o
16:10:35 <earnest> FMota: yup; I read Brazil in the first constitution
16:10:44 <FMota> heh, interesting
16:10:52 <FMota> I wonder how that changed
16:11:00 <newsham> #haskell-blah ?
16:11:16 <FMota> newsham: we're talking about unusual changes in state
16:11:16 <earnest> somehow that got changed to Brasil, and now Brazilians like to call people sort-of-stupid and they spell it with z
16:11:18 <nuncanada_> definetelly
16:11:34 <earnest> FMota: I wonder the same; but how can one find this out?
16:11:41 <earnest> these questions are not easy to answer
16:11:49 <FMota> yeah :/
16:12:01 <FMota> maybe they misspelled it in the Constituotion! lol
16:12:05 <earnest> :)
16:12:06 <FMota> (jk)
16:12:09 <earnest> that would be funny :)
16:12:40 <FMota> now, to learn howto spell Constitution...
16:12:51 <FMota> *how to
16:12:53 <earnest> hehe that's harder, right? :P
16:13:03 <FMota> Ironic,
16:13:13 <purejadekid> What's the easiest way to get GHC 6.6 for FreeBSD 6.2?  I'm new to FreeBSD and I think I need the newest ports, FeeBSD-current
16:13:26 <earnest> but why would you say Brazil is nicer than Portugal?
16:13:31 <purejadekid> I only see ghc5 in /usr/ports/lang
16:13:40 <earnest> purejadekid: easiest is to pkg_add it
16:13:53 <earnest> purejadekid: ghc6 won't work (it seems) on fbsd 4.x
16:13:58 <newsham> the latest ports has 6.6.1.
16:13:58 <earnest> dont know about 5.x or 6.x
16:14:05 <newsham> in /usr/ports/lang/ghc
16:14:34 <newsham> what version ghc is in the ports tree that ships with 6.2?
16:14:48 <purejadekid> lemme check
16:15:07 <earnest> here's my suggestion: wget ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6.2-release/lang/ghc-6.4.2_1.tbz and then pkg_add it
16:15:21 <purejadekid> ghc5 soemthing
16:15:29 <newsham> wow, really?
16:16:09 <purejadekid> earnest: just wget it to any location and pkg_add it form there?
16:16:13 <newsham> 6.2-RELEASE has ghc-6.4 in its ports tree I thoght
16:16:16 <earnest> yup
16:16:25 <stepcut> pair.com finally upgraded from FreeBSD 4.7 to 6.2 -- and they even include ghc 6.6 and darcs by default now ;)
16:16:28 <newsham> just pkg-add -r ghc   and you should have 6.4.2
16:16:34 <newsham> from there you can build 6.6 from srcs if you want
16:16:47 <purejadekid> I must have some old ports collection
16:16:47 <newsham> or if you prefer, update your ports tree and then install ghc from that
16:16:57 <purejadekid> newsham: I was hoping to do that
16:17:02 <stepcut> earnest: for the record, I have built GHC 6.6.1 for FreeBSD 4.7...
16:17:07 <newsham> updating ports tree is fairly easy
16:17:12 <earnest> stepcut: do you? how did you make it?
16:17:19 <purejadekid> cvsup supfile, but what's the supfile I need?
16:17:44 <earnest> purejadekid: do u really want to wait the build? :)
16:17:48 <newsham> its in /usr/share somewhere... 1 sec
16:17:55 <earnest> [wait for]
16:18:00 <newsham> /usr/share/examples/cvsup/ports-supfile
16:18:10 <stepcut> earnest: I built it from source. I may have installed the ghc5 and used that to build ghc6
16:18:16 <newsham> you'll just have to edit one line to set the *default host=....
16:18:21 <purejadekid> well I'd prefer a package if possible but I'm using ghc6.6 on my Mac and trying to get 6.6 to match that on FreeBSD
16:18:23 <newsham> (or specify it on the cmd line each time)
16:18:40 <earnest> newsham: build it from the source is probably too much work on 4
16:18:51 <purejadekid> ok I thought supfile stuff must have been easier than the man page made it look
16:18:52 <earnest> i mean: stepcut
16:19:10 <newsham> is there a bin pkg for 6.6 that you can pkg-add?
16:19:12 <earnest> if i ``make'' and it breaks... i'm totally not willing to fix it
16:19:36 <stepcut> newsham: a bin pkg for 6.6 for FreeBSD 4.x ?
16:19:48 <earnest> build systems that don't work are very frustrating
16:19:54 <newsham> [13:11] < purejadekid> What's the easiest way to get GHC 6.6 for FreeBSD 6.2?
16:20:00 <newsham> he said freebsd 6.2, not 4.x
16:20:32 <stepcut> newsham: right, but earnest said, <earnest> purejadekid: ghc6 won't work (it seems) on fbsd 4.x
16:20:42 <stepcut> newsham: so I am not clear on what we actually care about
16:20:43 <newsham> so is that relevant?
16:20:58 <purejadekid> yes I think I may be able to get somewhere with this
16:20:59 <stepcut> newsham: I dunno, that is my question
16:21:36 * stepcut rereads the conversation more carefully this time
16:21:52 <newsham> purej: did you try "pkg_add -r ghc" yet to see which one it might try to install?
16:22:02 <allbery_b> um, been years since ports included ghc5, I think
16:23:01 <stepcut> allbery_b: yeah, but I think might be a ghc5 binary tarball for FreeBSD 4.x on haskell.org somewhere
16:23:10 <allbery_b> possibly
16:23:18 <earnest> ghc5 installed with no problem on freebsd 4.7; made me happy
16:23:31 <earnest> but i could not pkg_add -r ghc5
16:23:34 <newsham> someday ghc will run properly on freebsd/amd64 :\
16:23:37 <earnest> but that might just be configuration on my system
16:23:37 <allbery_b> packages aren't being updated for 4.x, and ports is dubious these days because 4.x is EOLed
16:23:50 <earnest> since it seems to try to download from the wrong place
16:24:03 <earnest> yeah, fbsd 4.x is left to the flies
16:24:06 <earnest> a real pity :|
16:24:13 <newsham> so do we have one person asking for fbsd4.x and one person asking about fbsd6.2?
16:24:19 <allbery_b> looks like 6.6.1 is current (but IGNORE on amd64, of course)
16:24:32 <earnest> newsham: i think we're just talking about freebsd
16:24:47 <earnest> newsham: but purejadekid is really interested on 6.2, i think
16:24:57 <allbery_b> <purejadekid> What's the easiest way to get GHC 6.6 for FreeBSD 6.2?  I'm new to FreeBSD and I think I need the newest ports, FeeBSD-current
16:25:09 <purejadekid> yes I am asking about ghc 6.6 on freebsd6.2
16:25:11 <allbery_b> er, so are you running 6.2 or -CURRENT?
16:25:28 <purejadekid> I think my ports are old and I'd like to remedy that with -CURRENT
16:25:35 <purejadekid> working on that
16:25:39 <allbery_b> ports is independent of freebsd version
16:25:51 <earnest> which is why it breaks so much? :)
16:26:21 <allbery_b> it's certaibnly been known to happen
16:26:34 <allbery_b> ports isversion independent but there are versions they stop supporting after a while
16:26:40 <earnest> when i met freebsd, i was very happy with the ports; but freebsd doesnt seem to look back when it moves on, and that made the slow people very sad, 'cause the slow people are always behind in the so-called progress
16:27:25 <earnest> so then i decided to meet new friends, and i met deb and ian
16:27:27 <newsham> you remember how to untar and make right? :)
16:27:54 <earnest> who? earnest?
16:27:57 <allbery_b> for example only the final release of anything older than 6.0 has any support at all, and support is "if the maintainer feels like it" for < 5-last
16:28:20 <allbery_b> (5.5 I think?  I lost track of 5.x)
16:28:22 <earnest> yeah; that makes the ports sort of unfeasible for many
16:28:39 <earnest> at least they still leave the tgz's on the ftp
16:28:45 <earnest> but i only discovered that last week
16:28:49 <newsham> i think software developers are relying more on ports maintainers and pkg maintainers
16:28:57 <earnest> so i struggled for a long time for nothing
16:28:59 <newsham> and as a result software is getting less portable again
16:29:12 <earnest> non-portable stuff sucks :|
16:29:51 <earnest> but there's no one to blame, tho
16:30:29 <Lycurgus> leave
16:30:35 <shapr> no!
16:30:44 <newsham> hey shapr
16:30:51 <shapr> hiya newsham
16:36:52 <pgavin> @hoogle directory
16:36:52 <lambdabot> Directory :: module
16:36:53 <lambdabot> Distribution.Compat.Directory :: module
16:36:53 <lambdabot> System.Directory :: module
16:36:58 <pgavin> @hoogle chdir
16:36:58 <lambdabot> No matches found
16:37:04 <pgavin> @hoogle change
16:37:05 <lambdabot> Distribution.Compat.FilePath.changeFileExt :: FilePath -> String -> FilePath
16:37:05 <lambdabot> System.Win32.File.c_FindCloseChangeNotification :: HANDLE -> IO Bool
16:37:05 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
16:37:15 <pgavin> @hoogle dir
16:37:16 <lambdabot> Directory :: module
16:37:16 <lambdabot> Distribution.Compat.Directory :: module
16:37:16 <lambdabot> System.Directory :: module
16:37:23 <purejadekid> ok I tried sudo cvsup ports-supfile and I get a weird error "Cannot get IP address of my own host -- is its hostname correct?"
16:37:24 <pgavin> @list
16:37:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:38:09 <pgavin> @hoogle current
16:38:10 <lambdabot> Language.Haskell.TH.currentModule :: Q String
16:38:10 <lambdabot> Control.Concurrent :: module
16:38:10 <lambdabot> Foreign.Concurrent :: module
16:39:57 <elliottt> @hoogle ((a, b), c) -> (a,b,c)
16:39:58 <lambdabot> No matches, try a more general search
16:40:57 <purejadekid> newsham: any ideas why cvsup hates me?
16:41:28 <purejadekid> I changed the *default host=ftp7.us.freebsd.org
16:41:43 <newsham> I use *default host=ftp4.us.FreeBSD.org
16:41:49 <newsham> and have had success in the past
16:48:04 <earnest> i want to get the second argument on the cmd line: argv[1]; so I need getArgs and I need head to extract the first element of the list returned by getArgs; but I'm IO-confused; I want to isolate the work in a function getDir; so getDir = do list <- getArgs; how do I make getDir return head list now?
16:48:34 <ddarius> With return
16:48:40 <ddarius> Also you can just use pattern matching.
16:48:46 <newsham> do { as <- getArgs; return (head as) }
16:49:09 <newsham> do { (a:as) <- getArgs; return a }
16:49:12 <earnest> hm; so any function that does IO must be totally enclosed by a do-block?
16:49:27 <newsham> liftM head getArgs
16:49:31 <EvilTerran> getDir = liftM head getArgs, also, i think
16:49:33 <ddarius> Damn you newsham.
16:49:36 <conal> fmap head getArgs
16:49:43 <conal> ;)
16:49:47 <earnest> wow :) lots of solutions
16:49:50 <newsham> earn: more or less.  doesnt have to be "do" per-se, but morally you're on the right track
16:49:54 <EvilTerran> gah! newsham wins.
16:50:06 <earnest> i see
16:50:22 <ddarius> @undo do as <- getArgs; return (head as)
16:50:22 <lambdabot> (getArgs >>= \ as -> return (head as))
16:50:27 <EvilTerran> newsham++ , that's just the sort of answer i'd be after ;]
16:50:39 <EvilTerran> er, :], even
16:50:49 <monochrom> bot smile? :)
16:50:57 <newsham> ?bot
16:50:58 <lambdabot> :)
16:51:12 <monochrom> I should use :] more often.
16:51:15 * monochrom is a computer.
16:51:18 <earnest> how do i know when i have to use parentesis and when i dont? for instance, i would have tried return head as instead of return (head as)
16:51:36 <newsham> earn: to know for sure you need an understanding of the precedence rules
16:51:41 <EvilTerran> [] are handier keys than 90, and don't need modifiers to type []s
16:51:48 <ddarius> earnest: How do you know when you use parentheses and when you don't in arithmetic?
16:51:50 <monochrom> "return x y" is read as "(return x) y".
16:51:58 <newsham> return head as  ==  (return head) as
16:52:01 <EvilTerran> > return 1 2
16:52:03 <lambdabot>  1
16:52:03 <earnest> ddarius: experience, i guess
16:52:09 <EvilTerran> >:D
16:52:23 <newsham> bot smile:   :[]
16:52:28 <ddarius> earnest: I doubt that.
16:52:33 <newsham> > (:[]) 5
16:52:34 <lambdabot>  [5]
16:52:34 <earnest> ddarius: why?
16:52:58 <monochrom> I love experience. Everyone comes down to experience.
16:52:59 <ddarius> earnest: I'm sure the teacher who taught you arithmetic expressions also taught you order of precedence.
16:52:59 <EvilTerran> "brackets over division, multiplication, addition, subtraction"
16:53:16 <earnest> ddarius: hehe, i really wouldn't be sure of that
16:53:35 <earnest> but i get your point
16:53:41 <monochrom> How many people have completely forgotten childhood?
16:53:43 <EvilTerran> you must've learnt that a*b+c is (a*b)+c, and not a*(b+c)
16:54:05 <ddarius> EvilTerran: Even Smalltalk thinks that
16:54:29 <EvilTerran> ...that's precedence; and that a-b-c is (a-b)-c, not a-(b-c) - that's direction of associativity
16:54:33 <chessguy> childhood? what's that?
16:54:49 <purejadekid> newsham: "Cannot get IP address of my own host -- is its hostname correct?" ... had to fix my /etc/hosts file and give my host name a proper ip address. so now I can go back to getting FreeBSD-current. thx btw
16:55:05 <newsham> purej: awesome.
16:55:40 <purejadekid> I'm slow because I can't copy paste since I'm using FreeBSD on Parallels. Manual copy-paste char by char = no fun
16:56:26 <newsham> why no copy&paste?  not enough buttons?
16:56:28 <ddarius> I'm slow because I got dropped on my head often as a child.
16:56:56 <EvilTerran> anyway, earnest, the gist of it is, in haskell, a b c = (a b) c, function application is higher precedence than any infix operator, and :: is lower than any infix operator
16:57:31 <EvilTerran> so a b <op> c d = (a b) <op> (c d), and not, say, a (b <op> c) d or something
16:57:41 <earnest> EvilTerran: hm, that's useful knowledge; for some reason i thought that functional languages would always be: a b c = a (b c)
16:57:59 <EvilTerran> earnest, it's necessary to make curried functions non-painful to use
16:58:05 <EvilTerran> ?type map
16:58:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:58:09 <EvilTerran> ?type map (+1)
16:58:11 <lambdabot> forall a. (Num a) => [a] -> [a]
16:58:15 <EvilTerran> ?type map (+1) [1..10]
16:58:16 <newsham> tastey curried functions
16:58:17 <earnest> i haven't learned what curried functions are
16:58:17 <lambdabot> forall a. (Num a, Enum a) => [a]
16:58:28 <EvilTerran> map (+1) [1..10] = (map (+1)) [1..10]
16:58:46 <EvilTerran> "map", given its first parameter (a function), returns a new function that expects a list
16:59:15 <newsham> > let f = map (+1) in f [1,2,3]
16:59:17 <lambdabot>  [2,3,4]
16:59:37 <newsham> map only got one argument in "f = map (+1)"
16:59:39 <EvilTerran> this would be a PITA if (a b c) was (a (b c))
17:00:12 <earnest> EvilTerran: why? a PITA example to show?
17:00:12 <newsham> (just like  (+) only got one argument in  (+1))
17:00:47 <newsham> map (+1) [1..10]  ->     map ((+1) [1..10]) ?
17:00:52 <newsham> > (+1) [1..10]
17:00:53 <lambdabot>   add an instance declaration for (Num [t])
17:00:53 <lambdabot>     In the expression: (+ 1) ([1 ...
17:00:58 <EvilTerran> earnest, well, there's be brackets everywhere
17:01:11 <ddarius> All that really needs to be said is that we'd rather write 'f a b c' to apply a function to three arguments as opposed to '((f a) b) c'
17:01:35 <EvilTerran> a lot of functions in haskell take multiple parameters that way
17:01:38 <earnest> hm
17:01:43 <earnest> i didnt know this would happen
17:02:10 <purejadekid> newsham: no c&p because I'm using IRC and Safari on OS X and I guess Parallels didn't implement a shared clipboard for non-Windows OSes like FreeBSD
17:02:21 <newsham> ahh, gotcha.
17:02:30 <newsham> you could always build irc for fbsd :)
17:02:30 <EvilTerran> anyway, a couple more points of syntax: the body of a lambda, a let/in, and suchlike other things extends as far to the right as it can. that's a useful one to remember.
17:02:33 <purejadekid> I mean I could implement one using a web server which I can do when I get ghc6.6 working
17:03:04 <purejadekid> newsham: true
17:03:10 <ddarius> Network clipboard!
17:03:27 <purejadekid> ddarius: tell me more
17:03:40 <ddarius> I'm not suggesting something.
17:04:46 <EvilTerran> hpaste the thing you want to copypaste?
17:05:42 <purejadekid> hpaste just might do it
17:05:48 <purejadekid> gracias
17:11:27 <mr_tenor> where can i find a formal definition of what a general combinator is?
17:12:01 <earnest> EvilTerran: that's right; that one i have in mind
17:12:23 <earnest> but i actually always match the in with the column of the let
17:12:25 <ddarius> mr_tenor: The term "combinator" is usually abused to mean practically anything and totally unrestricted by its actual meaning.
17:12:47 <EvilTerran> that works
17:13:37 <ddarius> mr_tenor: There is a brief but complete definition at the beginning of http://en.wikipedia.org/wiki/Combinatory_logic
17:13:37 <monochrom> Any function is a combinator.
17:13:37 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
17:16:48 <mr_tenor> ddarius: that's been my impression, but there's always the risk that one just doesn't "get it" and there are abstract underpinnings ;)
17:17:37 <mr_tenor> so it's like a buzzword for PL geeks I guess ;)
17:18:33 <ddarius> mr_tenor: People usually have connotations attached to the word "combinator" when used in a loose sense that do go back to the actual meaning of combinators.
17:18:38 <ddarius> Yes.
17:19:31 <purejadekid> I thought combinators implied a certain amount of points-free-ness, as a connotation
17:19:46 <purejadekid> as opposed to a general function
17:20:05 <purejadekid> you don't see people writing combinatorial style Java programs, right?
17:20:21 <mr_tenor> the stuff i've seen referred to as combinators seem to have easier composability and more high orderness, roughly speaking
17:21:09 <purejadekid> mr_tenor: agreed
17:23:26 <phobes> I thought combinator just implied no free variables
17:24:44 <purejadekid> is (+1) a combinator? it doesn't take functions args so I wouldn't elevate it to that status
17:25:09 <thoughtpolice> phobes: i was thinking the same
17:25:23 <phobes> If it's the successor function on ordinals with the curch encoding, then I would think it a combinator
17:25:49 <phobes> ordinals = naturals :)
17:25:51 <ddarius> Combinators must be built from other combinators.
17:26:22 <phobes> which is any lambda expression with no free variables (if you start from SKI), right?
17:26:44 <ddarius> You can't use lambda ("except" for the primitive combinators)
17:27:10 <phobes> right, but with @pl and @unpl, you can go back and forth
17:27:14 <ddarius> Xf = f(\x.S) is not a combinator
17:27:22 <phobes> hmm
17:27:43 <phobes> Are those x's meant to be the same?
17:27:48 <ddarius> no
17:28:03 <ddarius> Not that it would matter or make sense.
17:28:17 <phobes> So that's just \f. f (const S)?
17:28:42 <ddarius> phobes: Yes.  That would be a combinator.
17:28:56 <ddarius> Something being a combinator or not is an intensional property.
17:29:12 <phobes> ddarius:  ok I get your meaning
17:29:21 <monochrom> You know how people say "xerox" for photocopying, "develop" for programming, "rip" for copying CDs and DVDs. Language is a funny thing. If there are two different words "xerox" and "photocopy", surely there must be a difference and you're missing something? But no, language is not supposed to be that logical.
17:29:46 <ddarius> monochrom: wtf?
17:30:03 <monochrom> I'm speaking in analogy.
17:32:35 <mr_tenor> according to http://en.wikipedia.org/wiki/Combinatory_logic, isn't the set of combinators equivalent to the set of higher order pure functions?
17:32:36 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
17:33:48 <ddarius> mr_tenor: It depends on what primitive combinators you assume.
17:34:45 <sioraiocht> @src [] pure
17:34:45 <lambdabot> pure = return
17:35:39 <sioraiocht> @src [] (<*>)
17:35:39 <lambdabot> (<|>) = (++)
17:36:06 <sioraiocht> that's...not what i asked for..thanks though lambdabot =p
17:36:09 <sioraiocht> @src [] ap
17:36:09 <lambdabot> Source not found. You type like i drive.
17:36:42 <monochrom> hahaha, that one is bizzare
17:36:43 <mr_tenor> ddarius: ah, that's what i'm missing. so i guess it's like logic. "here our axioms and let's see where they get us"
17:37:02 <ddarius> mr_tenor: It -is- logic.  Combinatory logic.
17:37:49 <sioraiocht> @src ap
17:37:49 <lambdabot> ap = liftM2 id
17:37:56 <mr_tenor> sorry... i'm abbreviating. i mean "the practice of building a combinator library looks like the process of defining a logic system"
17:38:20 <mr_tenor> which is pretty much what you're doing, right?
17:39:22 <ddarius> mr_tenor: You can view it that way, yes.
17:40:07 <mr_tenor> stepsFromEnlightenment--;
17:41:06 <sioraiocht> > ap (map (+) [1..5]) [6..10]
17:41:07 <ddarius> @karma stepsFromEnlightenment
17:41:07 <lambdabot> stepsFromEnlightenment has a karma of 0
17:41:08 <lambdabot>  [7,8,9,10,11,8,9,10,11,12,9,10,11,12,13,10,11,12,13,14,11,12,13,14,15]
17:41:24 <sorear> > nubBy(((>1).).gcd)[2..]
17:41:26 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:41:38 <sioraiocht> lol
17:46:36 <sioraiocht> > map head (iterate (\ (p:xs) -> [x | x <- xs, x `mod` p /= 0]) [2..n])
17:46:37 <lambdabot>   Not in scope: `n'
17:46:40 <sioraiocht> > map head (iterate (\ (p:xs) -> [x | x <- xs, x `mod` p /= 0]) [2..])
17:46:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:12:16 <sioraiocht> is there a good website of monad transformers
18:13:41 <sioraiocht> nevermind, found the wikibook
18:14:00 <byorgey> @go monad transformers step-by-step
18:14:02 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
18:14:02 <lambdabot> Title: Monad Transformers Step by Step
18:14:06 <thoughtpolice> sioraiocht: for an intro I really liked this page, http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
18:14:06 <pjd> cgibbard has a bit on them: http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
18:14:08 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
18:14:08 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
18:14:15 <thoughtpolice> and the paper byorgey gave is pretty good too. :)
18:15:09 <Cale> My bit is mostly targetted at people who already know the basics of monad transformers -- it's really a bunch of style issues.
18:15:42 <sioraiocht> well thanks
18:15:54 <pjd> http://www.cs.chalmers.se/~augustss/AFP/monads.html -- John Hughes & Magnus Carlsson
18:15:57 <lambdabot> Title: Systematic Design of Monads
18:17:29 <monochrom> Hrm, do they use English extensively in a Swedish university?
18:18:41 <thoughtpolice> Cale: I liked yours a lot. shows a good way to use transformers for creating a small DSL, basically. :)
18:19:29 <augustss> monochrom: yes
18:20:29 <sioraiocht> monochrom: there are a fair number of european schools that use english as the medium of instruction
18:21:11 <monochrom> Interesting.
18:21:12 <augustss> there's a lot of foreign students in swedish universities
18:21:24 <monochrom> Nice.
18:21:38 <sioraiocht> I imagine that's because the education is so inexpensive
18:21:52 <augustss> as in free, yes :)
18:25:44 <sioraiocht> augustss: even for international students?
18:25:55 <augustss> yes
18:26:03 <sioraiocht> harrumph, screw the UK, i should have gone to sweden
18:26:22 <augustss> of course, it's only free if you are accepted.  swedish or not swedish
18:26:47 <sioraiocht> augustss: right, I should have applied to swedish schools, lol
18:26:48 <augustss> if you're not accepted you get nothing
18:27:19 <sioraiocht> as an international student from a non EU country, oxford SCREWWWWWED me
18:27:22 <monochrom> Hey, rejection is free too. :)
18:27:34 <sorear> augustss: don't you still have to pay taxes?
18:27:36 <sioraiocht> monochrom: unless there's an application fee
18:27:53 <monochrom> Hrm! There lies the catch...
18:28:08 <augustss> sioraiocht: swedish rules could have changed in the last few years, but it used to be free regardless of country
18:28:25 <monochrom> Very profittable business: "our school charges no tuition fee! but application fee is us$10000" :)
18:28:33 <sioraiocht> haha
18:28:42 <augustss> sorear: the students generally don't make enough money to pay any taxes to speak of
18:28:45 <sioraiocht> speaking of USD, I hate exchange rates these days
18:29:13 <monochrom> OK, make it 10000 GB Pounds XD
18:29:34 <sorear> augustss: hmm, I got the impression from shapr that immegrants had to make N dollars taxible income, or face deportation
18:29:39 <sioraiocht> I've saved up a decent amount of money for my first term, and it gets halved in 14 days ><
18:29:52 * sorear actually knows very little about this, in case anyone couldn't tell
18:29:58 <sioraiocht> sorear: I would guess student visas are exempt from that
18:30:03 <augustss> sorear: students are in sweden on a student visa, different rules
18:30:12 <wli> sorear: Students and housewives, anyone?
18:30:40 <sioraiocht> sorear: but you're right, a lot of countries, especially welfare states, will deport any free-riding immmigrants
18:30:57 <sioraiocht> I believe Switzerland is notorious for getting rid of any immigrant pressure on the economy
18:31:20 <monochrom> Somehow Canada doesn't. :)
18:31:44 <sorear> so what do they do with free-riding natives? :)
18:31:57 <monochrom> But of course, Canada gives you much hassle just for applying for immigration.
18:31:58 <sioraiocht> sorear: well, as a welfare state that's a little redundant =p
18:32:24 <wli> Oh brilliant. The right wing has come to #haskell.
18:32:40 <scook0> quick, everybody foldl!
18:32:47 <sioraiocht> hahah I'm not conservative at all!
18:32:54 <monochrom> Basically you have to be extremely useful to Canada to get accepted. Or else, family re-union.
18:33:12 <sioraiocht> I didn't mean that offensively, more that welfare states take care of their own..regardless
18:33:28 <monochrom> But once you're accepted, all your misfortunes are taken care of.
18:33:39 <sioraiocht> monochrom: I think that's true of most countries.  Except the US, where you have a lottery 
18:35:33 <sorear> How is it *mathematically* possible for every country to be having a problem with immigrants??
18:36:27 <sioraiocht> sorear: LOL well, turkey, for one, doesn't =p
18:36:54 <sioraiocht> as the influx of turkish workers to germany is one major reason they protest their admission into the EU
18:37:18 <sorear> you're from turkey? (curiousity)
18:37:34 <sioraiocht> sorear: no, had to right a paper on the topic in a class during undergrad
18:37:42 <sioraiocht> (I was an international relations major for a semester)
18:39:28 <augustss> sorear: it's easy for every country to have immigrant problems.  at least if you view any immigrants as a problem
18:40:29 <monochrom> I can make up a fictional scenerio of a universe with just two countries and both have immigrant problems.
18:41:39 <sioraiocht> @seen dcouts
18:41:39 <lambdabot> I haven't seen dcouts.
18:41:41 <sioraiocht> @seen dcoutts
18:41:41 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 6h 3m 18s ago.
18:43:09 <sioraiocht> monochrom: it's get complicated by the fact that in the EU for example, the borders among member countries are completely open
18:43:25 <sioraiocht> making them even LESS inclined to accept immigrants from elsewhere
18:51:05 <sioraiocht> :t when
18:51:07 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:51:37 <sioraiocht> why can't it be m a instead of m ()?
18:52:49 <monochrom> return undefined? :)
18:53:03 <sioraiocht> oh
18:53:23 <Saizan> ?src when
18:53:23 <lambdabot> when p s = if p then s else return ()
18:53:59 <sioraiocht> riiiight, nevermind
18:55:26 <monochrom> sometimes "if p then liftM Just s else return Nothing" may be more useful.
18:55:41 <sioraiocht> aha! I kinda like that, heheh
18:56:37 <byorgey> whenMaybe?
18:56:53 <nominolo> > printf "%4.1d" 1024
18:56:54 <lambdabot>  Add a type signature
18:57:03 <nominolo> > printf "%4.1d" (1024::Double)
18:57:04 <lambdabot>  Add a type signature
18:57:08 <sioraiocht> :t printf
18:57:10 <lambdabot> forall r. (PrintfType r) => String -> r
18:57:30 <byorgey> > printf "%4.1d" 1024 :: String
18:57:32 <lambdabot>  "1024"
18:57:46 <sioraiocht> > printf "%4.1d" 1024 :: IO ()
18:57:47 <lambdabot>  <IO ()>
18:57:52 <sioraiocht> > printf "%4.1d" 1024 :: IO String
18:57:53 <lambdabot>  <IO [Char]>
18:57:56 <sioraiocht> lol
18:57:58 <sioraiocht> well then
18:58:07 <nominolo> > printf "%4.1d" 1024 :: String
18:58:08 <lambdabot>  "1024"
18:58:13 <byorgey> hey, that's neat!
18:58:13 <nominolo> > printf "%4.1d" 1.4 :: String
18:58:15 <lambdabot>  Exception: Printf.printf: bad argument
18:58:20 <nominolo> > printf "%4.1f" 1.4 :: String
18:58:21 <lambdabot>  " 1.4"
18:58:28 <nominolo> > printf "%4.1f" 1024 :: String
18:58:30 <lambdabot>  Exception: Printf.printf: bad argument
18:58:34 <nominolo> > printf "%4.1f" 1024.0 :: String
18:58:36 <lambdabot>  "1024.0"
18:58:40 <byorgey> I didn't realize printf could act like both printf and sprintf =)
18:58:46 <sioraiocht> lol
18:59:02 <sorear> And fprintf!
18:59:07 <sorear> (use hPrintf)
18:59:31 <nominolo> still doesn't do what i want it to do
18:59:37 <byorgey> @info PrintfType
18:59:38 <lambdabot> (PrintfType)
18:59:43 <nominolo> > printf "%4.f" 1024.0 :: String
18:59:44 <lambdabot>  "1024"
18:59:47 <sjanssen> I'm surprised printf isn't overloaded st. you can give it a Handle directly
18:59:50 <byorgey> @src PrintfType
18:59:51 <lambdabot> Source not found. I feel much better now.
18:59:52 <nominolo> > printf "%4.f" 1.0240 :: String
18:59:54 <lambdabot>  "   1"
18:59:57 <byorgey> @source PrintfType
18:59:58 <lambdabot> PrintfType not available
19:00:11 <byorgey> @source printf
19:00:11 <lambdabot> printf not available
19:00:13 <byorgey> grr
19:00:30 <sioraiocht> it looks like IO () and String work
19:00:43 <sioraiocht> @instances PrintfType
19:00:44 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
19:00:55 <sioraiocht> @instances-importing PrintfType
19:00:56 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
19:01:18 <byorgey> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
19:01:20 <lambdabot> http://tinyurl.com/34sj2z
19:01:20 <sorear> @instances-importing PrintfType Text.Printf
19:01:21 <lambdabot> Couldn't find class `Text.Printf'. Try @instances-importing
19:01:27 <sorear> @instances-importing Text.Printf PrintfType
19:01:29 <lambdabot> (a -> r), IO a, [c]
19:01:36 <sorear> use the correct syntax and it works!
19:01:41 <sioraiocht> lol
19:01:45 <nominolo> > show 10.34
19:01:46 <lambdabot>  "10.34"
19:01:59 <nominolo> > take 4 $ show 109.34
19:02:00 <lambdabot>  "109."
19:02:01 <sioraiocht> Prelude Text.Printf> printf "%4.1f" 1.4 :: IO String
19:02:02 <sioraiocht>  1.4"*** Exception: Prelude.undefined
19:03:13 <nominolo> > 234123/(1024*1024)
19:03:15 <lambdabot>  0.22327709197998047
19:03:22 <byorgey> sioraiocht: try explicitly annotating 1.4 as Double?
19:03:22 <nominolo> :t 234123/(1024*1024)
19:03:24 <lambdabot> forall t. (Fractional t) => t
19:03:33 <nominolo> @instances Fractional
19:03:34 <lambdabot> Double, Float
19:03:52 <sioraiocht> nope, neither float nor double works
19:04:01 <byorgey> hm, strange
19:04:30 <thoughtpolice> sioraiocht: type it as simply 'String,' not IO String
19:04:44 <sioraiocht> thoughtpolice: but I should be able to type it as IO String
19:05:36 <idnar> > return $ printf "%4.1f" 1.4 :: IO String
19:05:38 <lambdabot>  <IO [Char]>
19:05:46 <sioraiocht> yeah, in ghci that doesn't play nice
19:06:00 <byorgey> sioraiocht: does it work if you compile it?
19:06:05 <sioraiocht> hrm, let's see
19:06:07 <idnar> what doesn't play nice?
19:06:11 <thoughtpolice> i've had the same experiance
19:06:29 <idnar> I get the same result in ghci
19:06:30 <thoughtpolice> compiling it results in nothing out of the ordinary
19:06:41 <thoughtpolice> don't know why it throws an exception in ghci
19:09:05 <sioraiocht> ueaj
19:09:07 <sioraiocht> yeah
19:09:13 <sioraiocht> no problem in compilation
19:19:09 <ricky_clarkson> gigamonkey_: No idea (about bos, a Haskell book and O'Reilly).
19:30:31 <dcoutts> sioraiocht: I'm not here!
19:30:44 <sioraiocht> hahah hi dcoutts
19:30:47 <sioraiocht> you're not?
19:30:54 <dcoutts> sioraiocht: did you have a really quick question?
19:31:16 <sioraiocht> actually cladhaire had a question, but it wasn't really quick, i'll find you later
19:31:28 <dcoutts> sioraiocht: OK
19:31:30 * dcoutts should be in bed
19:31:34 <sioraiocht> lol yes
19:31:40 <sioraiocht> isn't it 3:30 there?
19:31:44 <dcoutts> @Arr!
19:31:44 <lambdabot> Aye
19:31:48 <dcoutts> @localtime dcoutts
19:31:48 <lambdabot> Local time for dcoutts is Sun Sep  9 03:33:21
19:32:22 <ricky_clarkson> dcoutts: UK?  Which city?
19:32:47 <dcoutts> .ox.ac.uk
19:33:21 <ricky_clarkson> .salford.ac.uk for me - Where Lambda Is a Foreign Word
19:35:17 <mudge> hey dons
19:35:55 <mudge> dons: you there?
19:36:04 <ddarius> ricky_clarkson: Lambda -is- a foreign word there.
19:36:16 <mudge> hey ddarius
19:36:33 <ricky_clarkson> ddarius: And humour is there, I expect.
19:37:15 <mudge> hey, i just wrote an article on high level programming: http://nickmudge.info/?post=50
19:37:17 <lambdabot> Title: High-Level Programming is About Expression
19:37:22 <mudge> i'm curious what anyone might think of it
19:38:14 <ricky_clarkson> mudge: automaticities?
19:38:56 <dons> mudge: yo
19:39:43 <mudge> hey dons: i just finished writing an article/blog post about programming: http://nickmudge.info/?post=50
19:39:44 <lambdabot> Title: High-Level Programming is About Expression
19:39:51 <mudge> will you read it and tell me what you think?
19:40:03 <dons> ok.
19:40:18 <mudge> ricky_clarkson: yea,    automaticities,  things that are automatic
19:40:25 <dons> mudge: you want feedback via mail or irc?
19:40:36 <mudge> either :)
19:40:54 <mudge> which ever feels best for you
19:40:56 <mudge> i like email
19:41:02 <dons> ok. i'll have some dinner and give it a read. i think i've your email.
19:41:13 <mudge> mudgen@gmail.com
19:41:14 <mudge> cool
19:41:17 <mudge> thanks dons
19:43:31 <ricky_clarkson> mudge: It looks verbose.  I'd quote sicp about programs being only incidentally for machines to execute, and say that modularising code makes it easier to understand as a whole, and hence maintain.  Also that studying existing systems is a good idea.
19:45:25 <mudge> ricky_clarkson: thanks,   yea, it does look verbose.  I didn't know SICP said that :)
19:45:53 <ricky_clarkson> First chapter.
19:46:38 <mudge> rad
19:47:34 <mudge> i did try to keep it kind of simple,  because I also wrote in mind a little for people that don't know programming totally, like maybe managers,   and so also explain a bit of stuff
19:51:19 <ricky_clarkson> Is there a reason to expect managers to read it?
19:51:21 * ddarius wonders why "people" have issues with the fact that adding mutable state to a language is an expressiveness boost.
19:51:45 <ricky_clarkson> ..like have you pointed your own managers at it?
19:52:08 <FMota> I dont understand uniqueness typing systems.
19:52:20 <ddarius> FMota: What's not to understand?
19:52:34 <FMota> how can they be functional?
19:52:46 <ddarius> How can they not be functional?
19:52:46 <mudge> well my boss who is a manager reads my blog
19:53:19 <mudge> ricky,  good point,   it probably should just be for programmers
19:53:24 <FMota> wouldn't the fact that you can only have one of something at one time essentially ammount to having state?
19:53:26 <FMota> *amount
19:53:41 <ddarius> FMota: No.
19:53:44 <FMota> ok
19:53:58 <FMota> there's obviously something I'm not getting. Wanna help? :)
19:54:09 <ddarius> I have to know what it is you're not getting.
19:54:25 <ddarius> If you erase the uniqueness types from a Clean program, say, you get a "normal" program.
19:54:42 <FMota> how do they work? how can you use them?
19:55:04 <ddarius> FMota: All they do is ensure you use a variable exactly once.
19:55:18 <scook0> ddarius: "issues" as in they don't like it, or as in they don't accept it as true?
19:55:23 <FMota> so essentially they restrict you
19:55:32 <pjd> ddarius: as in linear typing? (are they the same thing?)
19:55:37 <ddarius> FMota: That was exactly what I was about to say.
19:55:42 <FMota> oh ok
19:56:25 <ddarius> pjd: Yes and maybe no.  I think Clean made it's uniqueness typing system before linear logic was as well understood as it is now, but yes, linear logic would do the job.
19:56:29 <FMota> so you can use them for IO, because you can only a character off a stream once.
19:56:37 <ddarius> scook0: As in they don't accept it as true.
19:56:53 <idnar> what exactly is CDuce?
19:57:06 <ddarius> idnar: Not Haskell.
19:57:34 <idnar> hmm, ok
19:57:38 <pjd> idnar: the act of getting people to use low-level programming languages?
19:57:46 <idnar> pjd: bwahaha
19:57:59 * idnar should read more closely before following links
19:59:11 <scook0> the CTMCP book makes it pretty clear that state adds expressiveness (and weakens other properties), I think
19:59:54 <ddarius> Most people just use CTM for that.
20:00:16 <wli> What's CTM?
20:00:20 <scook0> I usually do too
20:00:27 <ddarius> Concepts, Techniques, and Models of Computer Programming
20:02:03 <scook0> I was assuming that "CTMCP" would make it easier for someone unfamiliar to find out what it is
20:02:30 <scook0> but I don't think it actually helped
20:02:47 <ddarius> "Concepts, Techniques and Models of Computer Programming" would be what you want in that case, or less helpfully, "Peter Van Roy's book"
20:03:39 <scook0> sure, but those are more than 2 extra characters, and I was lazy :)
20:03:48 <scook0> and I assumed *you* would know what I was talking about either way
20:04:24 <wli> There needs to be a bibliographical database IRC client plugin.
20:05:02 <Philippa> * ddarius wonders why "people" have issues with the fact that adding mutable state to a language is an expressiveness boost. <- Because it's often done in a way that makes a language merely differently expressive rather than clearly more expressive?
20:07:00 <scook0> @what ctm
20:07:00 <lambdabot> I know nothing about ctm.
20:07:05 <scook0> @what+ ctm http://www.info.ucl.ac.be/~pvr/book.html
20:07:05 <lambdabot> I know nothing about ctm.
20:07:21 <scook0> @where+ ctm http://www.info.ucl.ac.be/~pvr/book.html
20:07:21 <lambdabot> Done.
20:07:28 <scook0> @what ctm
20:07:28 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
20:07:36 <ricky_clarkson> @wtf ctm
20:07:37 <lambdabot> Maybe you meant: bf ft wn
20:07:59 <ricky_clarkson> @bf ft wn
20:07:59 <lambdabot>  fd:20: hClose: resource vanished (Broken pipe)
20:08:00 <FMota> what's paradoxic about Van Roy's paradox?
20:08:04 <ddarius> Philippa: Starting from a given "pure" language and adding state in the way it exists in practically all languages is definitively an expressiveness boost.
20:08:07 <pjd> Philippa: that kind of statement can only end up in a heated debate about what exactly expressiviness means
20:08:11 <FMota> (besides the fact that it may or may not be paradoxic)
20:08:32 <ddarius> pjd: There is a specific definition of "expressiveness" that I have in mind and I don't think it's particularly contentious.
20:08:40 <pjd> ddarius: you could consider the loss of referentially transparency a loss of expressiveness
20:08:47 <scook0> I suppose theres the all-too-common assumtion that expressiveness is necessarily a good thing
20:09:02 <scook0> in the sense that restricted expressiveness makes reasoning easier
20:09:15 <ddarius> pjd: I didn't say the one I had in mind was the only one or necessarily the best one, but a reasonable one.
20:09:35 <ricky_clarkson> Restricted expressiveness makes reasoning harder to express.
20:09:44 <FMota> XD
20:09:47 <pjd> one of several reasonable ones, which is the problem with that kind of statement :)
20:10:03 <scook0> e.g. simply-typed \calc is "less expressive" than untyped, but you can solve the halting problem in it
20:10:04 <Philippa> exactly. It's equally clearly not just a strict increase in expressiveness
20:10:29 <segher_> first, define "expressiveness"
20:10:29 <ddarius> pjd: I usually specify which "expressiveness" I mean, and with that one it is a strict increase in expressiveness.
20:10:32 <scook0> Philippa: i.e. if you already have features equivalent to state?
20:10:55 <ddarius> http://citeseer.ist.psu.edu/felleisen90expressive.html
20:10:57 <lambdabot> Title: On the Expressive Power of Programming Languages - Felleisen (ResearchIndex)
20:10:58 <Philippa> scook0: or a way to build them
20:11:22 <scook0> Philippa: which is implied by "equivalent" ;)
20:12:08 <Olathe> @check 1 == 1
20:12:09 <lambdabot>  OK, passed 500 tests.
20:12:12 <Olathe> Yay, it works !
20:12:17 <ddarius> Olathe: Whew.
20:12:41 <Olathe> We can't be totally sure, though. There might be some value of 1 that wasn't checked.
20:12:47 <monochrom> hahahha
20:12:52 <ddarius> True, but I'm comforted.
20:13:10 <scook0> @check (0/0) == (0/0)
20:13:11 <lambdabot>  Falsifiable, after 0 tests:
20:13:22 <monochrom> Gives a new spin to "1 = 2 for large enough values of 1" or something.
20:13:44 <pjd> does @check not suppress duplicate tests?
20:14:05 <ddarius> @remember Olathe We can't be totally sure, though. There might be some value of 1 that wasn't checked.
20:14:05 <lambdabot> Done.
20:14:31 <ddarius> That said, there are values of 1 where that test may fail.
20:14:39 <mr_tenor> is there a listing ofallthe quotes people have fed lambdabot somewhere?
20:14:46 <pjd> ddarius: depends on the Num instance?
20:14:51 <ddarius> mr_tenor: In the lambdabot database.
20:14:56 <mr_tenor> :P
20:15:14 <ddarius> pjd: More the Eq instance, as fromInteger 1 damn well better equal fromInteger 1.
20:15:28 <ddarius> mr_tenor: I'm serious.
20:15:54 <pjd> ddarius: well, as in the Num instance would have to return the funny Eq instance
20:15:54 <ddarius> @version
20:15:54 <scook0> I think the implied question was "is there a way for me to view this database?"
20:15:54 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
20:15:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:16:08 <allbery_b> dunno if it's still true but at one point you could geta  snapshot by pulling the darcs version of lambdabot
20:16:13 <ddarius> http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
20:16:24 * mr_tenor reads
20:16:32 <ddarius> It's, for some insane reason, a gzipped text file.
20:17:34 <scook0> is the requirement that Eq et al. behave sanely actually officially documented? it doesn't seem to be in the report
20:17:53 <ddarius> scook0: I'm not sure that it is, or is very strongly.
20:18:12 <mr_tenor> lambdabot stores state in dons' public_html directory? learn something new every day
20:18:26 <mr_tenor> ddarius, scook0: cheers
20:18:42 <wli> Why would Eq make a difference to the language?
20:19:06 <ddarius> There is also the old QuotesPage, another thing in the lost tracts of HaWiki.
20:19:34 <wli> Well, there are compiler intrinsics there.
20:19:40 <scook0> wli: Eq itself is in the report
20:20:22 <scook0> and a sanity requirement could potentially allow an optimizing compiler to short-circuit (==) with a pointer comparison
20:20:41 <pjd> scook0: the situation is similar to many other type classes too
20:20:45 <scook0> which you can't do if the compiler is obliged to respect faulty Eq
20:21:39 <pjd> Functor, Monad, anything intended to capture behavior not directly reflected in the type system
20:21:40 <scook0> at least Ord has the decency to mention "The Ord class is used for totally ordered datatypes", which implies sanity
20:21:51 <ecksit> hello, i am just beginning to try to learn haskell and am having trouble with passing arguments as lists
20:22:22 <scook0> ecksit: what do you have so far?
20:22:37 <ecksit> i have two functions, one that adds a list, which i got off the internet
20:23:00 <ecksit> the other divides the product of that list by the length of the list
20:23:26 <beelsebob> ecksit: okay, well your first task is probably to understand how the sum function you have works
20:23:29 <pjd> ecksit: a list of numbers?
20:23:29 <wli> Eq may compare normal forms and do a number of machinations under the hood.
20:23:48 <ecksit> so if the function is addList which takes a list as argument and returns its sum
20:23:53 <ecksit> yeah, its integers
20:24:17 <scook0> > sum [1, 3, 5]
20:24:29 <lambdabot>  9
20:24:30 <ecksit> i figure the other function is "mean x = addList x / length x"
20:24:43 <pjd> ecksit: you can perhaps paste what you have at http://hpaste.org/new
20:24:47 <beelsebob> ecksit: yep, sounds good
20:24:52 <beelsebob> ecksit: what's the problem?
20:24:59 <Cale> ecksit: one problem with that
20:25:08 <beelsebob> oh yeh
20:25:11 <Cale> ecksit: length returns an Int, which is unsuitable for using /
20:25:12 <beelsebob> function app binds tightest
20:25:13 <scook0> ah, I think I see the problem
20:25:23 <ecksit> i get a type error in application
20:25:29 <wli> genericLength
20:25:37 <Cale> So you either want genericLength or fromIntegral (length x)
20:25:53 <beelsebob> ecksit: the problem is that function application is always the tightest binding thing -- so it's trying to give the function add list 4 arguments
20:26:00 <Cale> beelsebob: no
20:26:01 <monochrom> @type genericLength
20:26:03 <lambdabot> forall b i. (Num i) => [b] -> i
20:26:03 <allbery_b> still get a tpe error though, won't you?
20:26:07 <scook0> mean xs = fromIntegral (sum xs) / fromIntegral (length xs)
20:26:11 <beelsebob> the first one is x, the second one is /, the third is lingth
20:26:11 <monochrom> Oh, nice, it's Num.
20:26:16 <Cale> beelsebob: no, / is infix
20:26:17 <allbery_b> right
20:26:32 <Cale> beelsebob: to pass / as a parameter, you'd have to put it in parens
20:26:42 <beelsebob> Cale: I thought infix opps had lower precidence than f-app?
20:26:48 <Cale> Yes, lower.
20:26:55 <ddarius> beelsebob: By your logic, 1 + 2 would be (1 (+)) 2
20:27:06 <Cale> Which means that it's  (addList x) / (length x)
20:27:24 <ecksit> so what does fromIntegral function do?
20:27:26 <beelsebob> ddarius: no, that just makes + left ascosiative
20:27:28 <Cale>  / isn't a syntactically valid term
20:27:34 <monochrom> numeric conversion
20:27:42 <beelsebob> Cale: ah, fair enough indeed
20:27:44 <allbery_b> :t fromIntegral
20:27:46 <lambdabot> forall a b. (Num b, Integral a) => a -> b
20:27:48 <Cale> ecksit: Converts any integer-like numeric type to any numeric type at all.
20:28:00 <ddarius> beelsebob: Associativity can only come up with more than one operator.
20:28:07 <Cale> In this case, probably Int to Double
20:28:22 <beelsebob> ddarius: my point though wrong, had nothing to do with associativity though
20:28:25 <monochrom> You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
20:28:29 <beelsebob> merely operator precidence
20:28:32 <ddarius> beelsebob: Neither did my point.
20:28:43 <ddarius> beelsebob: You brought up associativity, not me.
20:28:44 <wli> mean xs = sum xs / genericLength xs ; stdErr = let { n = genericLength xs ; mu = sum xs / n } in sqrt $ (sum $ map (^2) $ [x - mu | x <- xs]) / (n - 1)
20:28:49 <monochrom> (With apology to Ghostbusters :) )
20:28:55 <beelsebob> ddarius: as there's only one operator in 1 + 2, operator precidence can't possibly have any effect at all
20:29:00 <pjd> ecksit: that fromIntegral type signature essentially says "from some integer type to some other numeric type"
20:29:18 <ddarius> beelsebob: There is only one operator in addList x / length x
20:29:27 <pjd> @remember monochrom You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
20:29:27 <lambdabot> Done.
20:29:33 <monochrom> haha
20:29:42 <beelsebob> ddarius: yes, but there's also function application -- which has a higher precidence than any operator
20:30:02 <beelsebob> there's 3 apps there, not 1
20:30:08 <Cale> mean xs = sum xs / genericLength xs ; stdErr xs = let { n = genericLength xs ; mu = sum xs / n } in sqrt $ (sum [(x - mu)^2 | x <- xs]) / (n - 1)
20:30:40 <ddarius> beelsebob: Suffice to say you had (have?) a serious issue understanding how Haskell is parsed.
20:30:57 <beelsebob> ddarius: no, I merely got the precidence the wrong way round
20:31:09 <scook0> if the list contents aren't Fractional, you need to convert (sum xs) to do the division
20:31:13 <Cale> mean xs = sum xs / genericLength xs; stdErr xs = sqrt $ sum [(x - mu)^2 | x <- xs] / (n - 1) where n = genericLength xs ; mu = sum xs / n
20:31:23 <beelsebob> the point is -- in 1+2 there's only one application -- precidence cannot possibly come into it
20:31:29 <ecksit> i get an error "Instance of Fractional Integer required for definition of mean"
20:31:47 <ecksit> maybe i should change the return to floating point notation?
20:31:48 <ddarius> beelsebob: No you didn't.  If you had the precedence wrong you would be saying that that parsed as addList (x / length) x
20:31:48 <beelsebob> the only thing that changes whether it's (1+)2 or 1(+2) is associativity
20:31:53 <Cale> ecksit: That means that you're trying to apply (/) to things which are Integers
20:32:05 <ddarius> beelsebob: That is not associativity.
20:32:07 <beelsebob> ddarius: no, I said it would be parsed as addList x (/) length x
20:32:17 <beelsebob> I admit I was wrong
20:32:20 <Cale> ecksit: To do (truncating) integer division, you can use div
20:32:21 <scook0> ecksit: mean xs = fromIntegral (sum xs) / fromIntegral (length xs)
20:32:24 <beelsebob> you just haven't got how I was wrong
20:32:33 <ecksit> right, thats what i did
20:32:45 <monochrom> What's in xs?
20:32:51 <ddarius> beelsebob: I didn't say that you said what I said above, I said that you didn't but what it is what you should have said if you understood precedence and just mixed them up.
20:33:04 <ecksit> actually i have it as x, not xs, ill try that
20:33:18 <ecksit> i dont think it matters
20:33:25 <scook0> ecksit: you're right, that won't make a difference
20:33:26 <mr_tenor> @quote OlegFacts
20:33:27 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
20:33:30 <beelsebob> ddarius: all I did was take "function application binds tightest" one step too far -- I bound the / to addList as another argument
20:33:31 <ddarius> beelsebob: You have a serious misunderstanding of either the terminology or what is actually going on.
20:33:34 <scook0> (xs is just a Haskell style thing)
20:33:48 <beelsebob> ddarius: no, you have a serious misunderstanding of what went wrong in my head
20:33:50 <ecksit> hmm, same error
20:33:58 <ddarius> beelsebob: Define associativity.
20:34:07 <scook0> ecksit: what's your current definition?
20:34:12 <monochrom> > fromIntegral (sum [1,2,3]) / fromIntegral (length [1,2,3])
20:34:12 <ddarius> Or rather, state in symbols what it means for an operator to be associative.
20:34:17 <lambdabot>  2.0
20:34:21 <monochrom> seems to work
20:34:21 <ecksit> mean :: [Integer] -> Integer
20:34:26 <beelsebob> ddarius: associativity is the order in which operations of the same precidence are bound
20:34:30 <Cale> ecksit: There's your problem :)
20:34:43 <Cale> ecksit: That's not an appropriate type for the code we've been providing
20:34:45 <beelsebob> an operator is left associative if x opp y opp z == (x opp y) opp z
20:34:47 <monochrom> [Integer] -> Double
20:34:53 <beelsebob> and right associative if the brackets appear on the other side
20:35:23 <ddarius> beelsebob: Okay, then 1+2 can't be a case of associativity because there is only one operator.
20:35:34 <scook0> or, if you want to be fancy, (Fractional a) => [Integer] -> a, though Double is likely sufficient for your purposes
20:35:41 <Cale> :t let mean xs = fromIntegral (sum xs) / fromIntegral (length xs) in mean
20:35:42 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> b
20:35:49 <beelsebob> ddarius: no, but that's the closest possible description of what you seemed to be trying to do -- as parsing 1+2 as (1+)2
20:36:01 <beelsebob> (which is a bloody odd thing to do)
20:36:16 <ecksit> ok, i think that worked, thanx alot
20:36:20 <allbery_b> > let f = (1+) in f 2
20:36:21 <lambdabot>  3
20:36:29 <scook0> beelsebob: no, it was (1 $ (+)) 2
20:36:40 <ddarius> beelsebob: I was following exactly your example, parsing 1+2 as 1 applied to (+) and that applied to 2 which is exactly what (1 (+)) 2 parses as.
20:36:47 <ecksit> i just started using haskell today and its weird but cool
20:36:53 <allbery_b> ...what's so odd about it? :)
20:36:58 <beelsebob> scook0: check your logs -- no dollars there
20:37:08 <monochrom> It does many things right. That is why it's weird and cool.
20:37:11 <Cale> allbery_b: hehe
20:37:17 <beelsebob> ddarius: but that makes no sense at all -- 1 is not an identifier
20:37:19 <beelsebob> and couldn't be
20:37:27 <beelsebob> because identifiers can't start with numerals
20:37:32 <scook0> beelsebob: the $ was to clarify the intent, it wasn't in the original
20:37:44 <ddarius> beelsebob: You can quite definitely legitimately have write (1 (+)) 2 in code and have it parse and execute.
20:38:05 <beelsebob> ddarius: yes -- but it most deffinately won't execute as "1 applied to (+)"
20:38:11 <scook0> you just need a sufficiently crazy instance of Num
20:38:12 <ddarius> beelsebob: Sure it could.
20:38:18 <beelsebob> it'll execute as (+) applied first to 1, then to 2
20:38:27 <ddarius> beelsebob: No it won't.
20:38:29 <beelsebob> 1 cannot be applied
20:38:29 <ecksit> its most similar to python, nothing like java or c
20:38:31 <beelsebob> it's not a function
20:38:35 <ddarius> 1 can so be applied.
20:38:36 <allbery_b> you might want to look at my example again and think about currying and partial application
20:38:42 <ddarius> 1 can be a function.
20:38:50 <beelsebob> ddarius: 1 can't even be an identifier
20:38:57 <beelsebob> identifier start with letters
20:39:04 <ddarius> \x -> x is not an identifier either, but I can apply it too.
20:39:08 <allbery_b> let 1 = 3 in 1 + 1
20:39:12 <allbery_b> > let 1 = 3 in 1 + 1
20:39:14 <lambdabot>  2
20:39:17 <allbery_b> oh well
20:39:26 <Cale> beelsebob: remember that 1 really means (fromInteger 1), and you can write an instance of Num for a function type
20:39:32 <scook0> allbery_b: o_O
20:39:33 <beelsebob> ddarius: yes -- and functions are one of... (a) named functions (identifiers) or (b) lambda expressions
20:39:57 <Cale> beelsebob: Given the way that integer literals are overloaded, 1 can be of any type at all.
20:40:01 <ddarius> beelsebob: No.  It could also be an application, or a case analysis, or a let expression, or in fact any expression that evaluates to a function.
20:40:02 <allbery_b> scook0: let binding can do interesting things
20:40:03 <beelsebob> Cale: haha, now *that* would be impressively confusing
20:40:05 <Cale> beelsebob: It just has to be an instance of Num.
20:40:37 <scook0> beelsebob: (flip id) is a function, but it's neither (a) nor (b)
20:40:39 <beelsebob> hmm, *goes away and writes instance Num (a -> a)*
20:40:50 <ddarius> allbery_b: Unfortunately for you, that was just a failed but irrefutable pattern match of 1 against 3.
20:40:54 <allbery_b> yep
20:41:01 <Cale> beelsebob: unfortunately, you'll have to provide some crappy instances for Eq and Show
20:41:16 <beelsebob> Cale: true, but if all my functions a->a are id, then that's pretty easy
20:41:23 <pjd> @type (/) <$> fromIntegral . sum <*> fromIntegral . length
20:41:25 <lambdabot> forall b a. (Integral a, Fractional b) => [a] -> b
20:41:27 <Cale> heh, okay
20:41:31 <allbery_b> Church numerals?
20:41:41 <ddarius> Actually the typical Church encoding is a -> (a -> a) -> a
20:41:50 <ddarius> With some foralls sprinkled about.
20:41:54 <Cale> You can write a more meaningful instance for (Num b) => a -> b
20:42:09 <beelsebob> Cale: of note... 1+2 would *still* not be parsed as 1 applied to +, because of defaulting
20:42:15 <beelsebob> even if that instance did exist
20:42:27 <ddarius> It wouldn't parse as that period because of the syntax of Haskell.
20:42:32 <Cale> no, it wouldn't be parsed that way because of the way that infix functions are parsed
20:42:39 <Cale> It(+) 1 2
20:42:46 <Cale> It's desugared to (+) 1 2
20:42:51 <monochrom> But now (1 (+)) is valid.
20:43:00 <beelsebob> true
20:43:05 <beelsebob> which would be entertaining
20:43:27 * beelsebob notes that down for Haskell obfuscation techniques
20:43:41 * ddarius often finds himself wanting a Num b => Num (a -> b) instance.
20:43:55 <beelsebob> o.O
20:43:59 * beelsebob finds that scary
20:44:08 <beelsebob> actually no
20:44:18 <beelsebob> that just gives you a nice way to define an ordering on functions
20:44:41 <beelsebob> although... why not just do Ord (a -> b)
20:45:14 <ddarius> It's not that at all.  It won't make making an Ord instance any more possible.  It's just pointwise addition, subtraction, etc.
20:45:45 <ddarius> It would be necessary to give dummy instances for Eq and Show and Ord.
20:46:14 <beelsebob> I'm missing what you're gaining
20:46:18 <monochrom> functional analysis and differential equation do that all the time. E.g., "d/dx + 5" means "\y -> dy/dx + 5*y". Quantum mechanics books to that all the time.
20:46:25 <beelsebob> can you show me something you can do with that that you can't otherwise?
20:47:00 <beelsebob> hmm, fair enough
20:47:14 <monochrom> So 5 is not only used as a function, in fact it is a higher order function.
20:47:17 <beelsebob> that's quite neat actually
20:47:38 <beelsebob> although fairly nasty if you're trying to read the code
20:47:56 <Cale> monochrom: Not \y -> dy/dx + 5 ?
20:48:03 <monochrom> No. I'm sure.
20:48:09 <Cale> er, oh, right
20:48:10 <ddarius> Readability is why you'd do it.
20:48:37 <ddarius> Though you'd probably only want to do it in a domain where that is very natural or standard.
20:48:54 * SamB_XP_ thinks what Cale said would be valid but odd
20:48:54 <Cale> I'm more used to the derivative operator being called D when used like that though. :)
20:49:43 <Cale> yeah, I kind of misread what he wrote
20:50:08 <ddarius> SamB_XP_: Cale's is more natural. Usually in QM the application is read as a multiplication.
20:50:11 <wli> It's done often with generating functions as well.
20:50:14 <Cale> dy/dx + 5 would mean \k -> (dy/dx)|_k + 5
20:50:27 <wli> z (d/dz) for instance is even written d/d(log(z))
20:50:37 <Cale> (Leibniz notation is awkward, and I tend not to use it)
20:51:12 <SamB_XP_> I wonder if I could get away with using lambdas in any of my courses...
20:51:13 <Cale> f' + 5 would mean \x -> f'(x) + 5
20:51:14 <monochrom> One reason it is done is because higher-order functions like (\y -> Dy + 5*y) belong to a nice class (called "operators") with nice properties. If you focus on operators themselves (rather than always applying them), i.e., if you go pointfree, you get important insights.
20:51:33 <Cale> Right, D is a linear operator
20:51:37 <ddarius> Agreed.
20:51:47 <SamB_XP_> I have used D as a linear operator. briefly.
20:51:52 <Cale> and in that context, a number n is treated as n times the identity map
20:52:14 <Cale> Just like how you use 1 for the identity matrix.
20:52:24 <Cale> (though some people don't like that overloading and use I)
20:52:32 <monochrom> IIUC you get into Hilbert space something. It tells you a lot about quantum mechanics. The same results are not easily available pointful.
20:52:38 <SamB_XP_> that was probably for one section of one chapter in Differential Equations, though
20:53:32 <ddarius> SamB_XP_: You can almost treat D as a number and use normal number tricks, the difference is the algebra formed is non-commutative.
20:53:44 <SamB_XP_> istr that
20:53:45 <Cale> SamB: yeah, it's important notation for solving certain classes of differential equations where you can view the equation as some polynomial in D applied to your function being equal to some constant.
20:54:16 <ddarius> It's really cute.
20:54:18 <SamB_XP_> it'll probably make more sense once I've had linear algebra ;-)
20:54:20 <Cale> p(D) f = g
20:55:48 <monochrom> Quantum people are the people who can testify that pointfree is not just aesthetics, it's actually bread and butter.
20:56:46 <Cale> Certain algebraic topologists are also quite fond of it.
20:56:56 <ddarius> They would be.
20:57:00 <sorear> Quantum people also have a habit of asserting without proof that any set of reals can be indexed by naturals.
20:57:03 <Cale> Differential geometers just go nuts.
20:57:16 <sorear> Physicist math makes me *sick*.
20:57:18 <ddarius> Cale: It's reasonable there.
20:57:24 <monochrom> hehehe
20:57:35 <ddarius> sorear: Look at better physicists.
20:57:35 <Cale> The overloading that happens in differential geometry confuses the hell out of me half the time.
20:57:51 <ddarius> Cale: Agreed.
20:58:00 <Cale> Yeah, most physicists have awful notation, but there are some who actually know what they're doing :)
20:58:21 <Cale> It's really the lack of rigour which annoys me in physics.
20:58:43 <ddarius> Cale: With differential geometry, my main issue is the inconsistency in the use of the notation.
20:58:46 <edwardk> cale: just coz they like to cut off taylor series after a term or two as good enough... =)
20:59:06 <TSC> Can someone explain this strange GHC warning?  "Warning: Imported from `Data.Dynamic' but not used: `toDyn'" -- but I do use toDyn in the module!
20:59:11 <ddarius> edwardk: QM is linear!  It's amazing!
20:59:18 <Cale> ddarius: heh, yeah, differential geometry has been referred to as the study of invariants under change of notation
20:59:21 <edwardk> ddarius: =)
20:59:54 <monochrom> I knew every geometry is supposed to be the invariance of something rather.
21:00:33 <FMota> well, for normal intents and purposes, the real numbers /can/ be indexed by the natural numbers.
21:00:49 <FMota> you simply restrict yourself to rationals
21:00:56 <FMota> and that tends to be good enough
21:01:07 <monochrom> IEEE 754 FTW
21:01:15 <ddarius> Let's just sweep pi, e, and the Euler-Mascheroni constant under the rug.
21:01:26 <Cale> Not to mention sqrt(2)
21:01:33 <FMota> ddarius: you can use approximations
21:01:36 <monochrom> just use rational trig.
21:01:42 <FMota> physicists use approximations all the time ;)
21:02:21 <FMota> heh. CS people should know that too.
21:02:47 <edwardk> yeah, we call the usual approximation a 'float' =)
21:02:51 <sorear> Cale: haha, I love it
21:03:02 <ddarius> Field extensions should be no problem.
21:03:24 <Cale> Yeah, you can work with the algebraic numbers, though it's computationally a little involved.
21:03:51 <scook0> well, IEEE754 tends to approximate insanity more than it does the reals
21:03:51 <FMota> ;)
21:03:58 <earnest> here's what i get when i run xmonad from my .xinitrc:
21:03:58 <earnest> Xlib:  extension "XINERAMA" missing on display ":0.0".
21:04:05 <SamB_XP_> Cale: I didn't know sqrt was a syscall!
21:04:23 * scook0 groans
21:04:25 <Cale> SamB_XP_: hm?
21:04:33 <FMota> heh
21:04:35 <ddarius> man
21:04:37 <sorear> Lots of other stuff, too.  Like in the derivation of the Fermi-Dirac equation, a book I'm looking at goes "Okay, now this square root is too hard, so square both sides (later on, we'll revise our physics to make the spurious solutions seem real)"
21:04:37 <SamB_XP_> Cale: you said something about sqrt(2)
21:04:47 <ddarius> Took me a second too.
21:04:48 <FMota> I dislike floats :/
21:04:48 <Cale> SamB_XP_: yeah? I mentioned that it's not rational.
21:04:56 <ddarius> which(1)
21:05:02 <SamB_XP_> Cale: stupid pun, yes, I know...
21:05:04 <Cale> oh
21:05:12 <Cale> I see
21:05:18 <ddarius> FMota: Use doubles.
21:05:39 <FMota> ddarius: I dislike those too, as you probably can guess.
21:05:40 <edwardk> ieee754 is the bane of my existence, i can't comply with its notion of equality and have a notion of observational equality between floats since it says that 0 = -0, but that they have different behaviors.
21:06:00 <beelsebob> o.O
21:06:01 <ddarius> FMota: Use affine arithmetic.
21:06:04 <scook0> > map (1/) [0, -0]
21:06:09 <lambdabot>  [Infinity,-Infinity]
21:06:12 <beelsebob> haha
21:06:14 <beelsebob> fun
21:06:26 <edwardk> > 0 == -0
21:06:27 <lambdabot>  True
21:06:30 <Boney> > Infinity == (-Invinity)
21:06:31 <lambdabot>   Not in scope: data constructor `Invinity'
21:06:37 <Cale> > (1/0) == (1/(-0))
21:06:39 <lambdabot>  False
21:06:39 <beelsebob> but then Infinity and -Infinity don't exist
21:06:40 <Boney> > Infinity == (-Invfinity)
21:06:40 <lambdabot>   Not in scope: data constructor `Invfinity'
21:06:47 <scook0> > (\x -> x == x) (0/0) -- this one's fun too
21:06:47 * SamB_XP_ continues to add books to his bookshelf on facebook...
21:06:48 <lambdabot>  False
21:06:49 <Boney> nm,
21:06:53 <edwardk> beelsebob: tell that to ieee754 =)
21:06:57 <beelsebob> so it seems reasonable that in their equal non-existance they should be equal
21:07:03 <beelsebob> edwardk: :P
21:07:18 <segher_> you think floats are bad?  "computer integers" aren't integers, either
21:07:30 <beelsebob> edwardk: only way to rectify it is to say "well, numbers meet up round the back somewhere"
21:07:36 <edwardk> oh, and i can't even have an observational disequality because two NaN's with the same physical representation have to be inequal =)
21:07:38 <beelsebob> so Infinity == -Infinity
21:07:47 <sjanssen> earnest: I think you can ignore that warning
21:07:52 <wli> They're at least Z/2^nZ for some n.
21:07:54 <scook0> segher_: "unlimited"-precision integers are decent, though
21:07:57 <ddarius> segher_: Integers are a reasonable approximation, and Ints form a relatively nice mathematical structure.
21:08:16 <segher_> scook0: no they're not -- the division operator isn't there
21:08:29 <FMota> segher_: yes, however, it's trivial to extend ints, to be able to handle arbitrarily large numbers.
21:08:30 * beelsebob hands everyone a nice shiny church numeral and considers bed
21:08:31 <segher_> not with the correct semantics, that is
21:08:36 <FMota> except for one simple fact
21:09:00 <FMota> computers aren't computers. ;)
21:09:16 <monochrom> There is some wisdom in that.
21:09:18 <ddarius> They're not Turing machines, that's for sure.
21:09:22 <FMota> ;)
21:09:23 <scook0> segher_: what about arbitrary-precision rationals?
21:09:27 <monochrom> Another one is: humans aren't intelligent.
21:09:27 <segher_> yeah, no actual computer is equivalent to a turing machine, heh
21:09:36 <FMota> they're just approximations
21:09:38 <beelsebob> rubbish!
21:09:45 <beelsebob> my computer has an infinite tape coming out of it
21:09:50 <segher_> scook0: sure, but those aren't "computer integers"
21:09:52 <FMota> but in reality, they're just huge finite state machines
21:10:20 <FMota> ...aren't we all?
21:10:29 <ddarius> Isn't the whole universe?
21:10:30 <beelsebob> FMota: which is scary -- because the implication is that all these "Context free grammars" we're programming them with are just giant regexps
21:10:33 <scook0> segher_: sure ... my point is that it's easier to paper over the deficiencies of machine integers than machine floats
21:10:35 <monochrom> I keep plugging in USB fingers to extend its memory.
21:10:46 <segher_> huge finite state machines?  humans have just two states, "on" and "off" ;-)
21:10:50 <FMota> lopl
21:10:52 <FMota> *lol
21:11:05 * allbery_b 's state is uually irrational
21:11:05 <FMota> and since NDFA = DFA
21:11:08 <segher_> scook0: true enough
21:11:12 <FMota> ...we're all deterministic
21:11:27 <beelsebob> FMota: I'd come to terms with that ages ago
21:11:34 <segher_> fmota: yeah, we all switch to "off" state soon enough
21:11:52 <FMota> :) yep. And I'm perfectly fine with it.
21:12:10 <scook0> doesn't that mean you've solved the halting problem for human beings? ;)
21:12:10 <ddarius> On a long enough timeline, the local state of everyone transitions to zero.
21:12:19 <beelsebob> o -> (o)   <-- the human :)
21:12:23 <scook0> what if somebody diverges?
21:12:35 <FMota> not gonna happen
21:12:43 <beelsebob> scook0: yes -- human beings halt -- there, solved
21:12:44 <FMota> (IMO)
21:12:47 <FMota> heh
21:12:48 <segher_> fmota: people look really strange at you if you want to test if the DFA in a new human works correctly
21:12:54 <FMota> I can solve the halting problem
21:12:55 <monochrom> divergence is called insanity. those people get sent to asylums.
21:13:08 <beelsebob> FMota: in general?
21:13:10 <FMota> yes
21:13:16 <FMota> well
21:13:16 <beelsebob> you can solve it for dogs too?
21:13:23 <ddarius> Didn't I solve that last week.
21:13:28 <FMota> for anything that actually exists
21:13:30 <monochrom> hhahaha
21:13:44 <beelsebob> FMota: even a jack russel?
21:13:48 <FMota> halt f = true
21:13:48 <FMota> ;)
21:13:57 <SamB_XP_> ddarius: whether the universe is a finite state machine or not may depend on it's expansion/contraction...
21:13:59 <beelsebob> I'm pretty sure some jack russels will carry on chasing their tails forever
21:14:31 <segher_> samb_xp: if it is an fsm, it cannot contract nor expand ;-)
21:14:38 <ddarius> SamB_XP_: Maybe, I'm actually betting that it doesn't.
21:15:04 <FMota> segher_: but it can appear to do so
21:15:04 <segher_> otoh, the universe _is_ created _by_ an FSM.  and that's a fact :-)
21:15:12 <FMota> lol
21:15:19 <scook0> praise his noodly appendage!
21:15:25 <FMota> omg, that makes so much sense.
21:15:30 <beelsebob> ohh, another pastafarian
21:15:36 <SamB_XP_> I'm thinking that if it expands fast enough, the relevant-to-me universe might be an FSM
21:15:42 <FMota> er, *omfsm
21:16:04 <SamB_XP_> probably an NFA...
21:16:24 <segher_> beelsebob: hey, if i have to pick a religion, i pick the one with beer volcanos every day of the week
21:16:26 <FMota> NFA = DFA, so FSM suffices really
21:16:36 <beelsebob> segher_: and pirates!
21:16:44 <SamB_XP_> FMota: it makes a difference at the reality level
21:16:58 <SamB_XP_> I do not feel like a quantum superposition...
21:17:00 <segher_> beelsebob: yeah, but that only on fridays
21:17:05 <FMota> :) good point
21:17:28 <beelsebob> I don't know -- there might be an un-me somewhere
21:17:37 <SamB_XP_> ... 'twould be a very confused sort of feeling, if I did ;-)
21:17:43 <beelsebob> but only if you actually observed me
21:17:48 <beelsebob> best not turn my camera on
21:17:52 <sorear> you mean the universe isn't a giant 64-dimensional membrane sitting in the tensor bundle of a 4-sphere?
21:18:11 <segher_> sorear: yeah, it has only six dimensions
21:18:13 <scook0> sorear: actually, it's turtles all the way down
21:18:18 <beelsebob> sorear: well, it is, but the surface is covered in a giant diagram of a state machine :P
21:18:37 <FMota> I thought it was a cube?! SHUT UP!
21:18:45 <FMota> :o
21:19:10 <SamB_XP_> if we could get the philosphers to buy that NFA = DFA argument, it would save them a lot of trouble ;-)
21:19:17 <beelsebob> haha
21:19:36 <FMota> :)
21:20:01 <beelsebob> so in one night, we have successfully solved P=NP, the halting problem, and the deepest mysteries of the universe?
21:20:02 <beelsebob> WIN!
21:20:14 <segher_> if we could get the philosophers to buy _any_ argument, it would save _us_ a lot of trouble
21:20:18 <ddarius> Computer science: Destroying jobs since 1946
21:20:28 <beelsebob> 46?
21:20:33 <scook0> beelsebob: tomorrow, we'll solve emacs vs. vi!
21:20:38 <tessier_> ddarius: Destroying jobs?
21:20:40 <FMota> beelsebob: I haven't laughed so hard in a couple of weeks. :)
21:20:43 <beelsebob> scook0: SubEthaEdit :P
21:20:53 <FMota> or...  no, wait, actually, I laughed a lot last week
21:21:16 <segher_> emacs vs. vi will be solved pretty soon -- emacs will die an entropy death
21:21:27 <FMota> something about a Haskell being used by Native American tribes as a mind-altering substance.
21:21:30 <ddarius> Or implode into a blackhole!
21:21:33 <beelsebob> either that or vi will be replaced with vii
21:21:33 <SamB_XP_> segher_: I don't see why that prevents me from using it
21:22:04 <segher_> samb_xp_: sure, but you'll be gone with it
21:22:08 * beelsebob is determined to always pronounce vi "six"
21:22:31 * SamB_XP_ hopes his parents won't be too mad that he has forgotten to do the dishes ... er, yes, that does mean I'm going to bed now...
21:22:42 <beelsebob> nn SamB
21:22:59 <SamB_XP_> nn = nighty night?
21:23:03 <beelsebob> yep
21:23:15 * beelsebob actually did the dishes tonight
21:23:18 <FMota> gn!
21:23:22 <beelsebob> just as well, the place was rapidly becoming a shit tip
21:23:33 * FMota had a pizza slice out. :/
21:23:44 <SamB_XP_> nn to you too!
21:24:20 * beelsebob notes that he really should not get addicted to sitting in here again when he has writing up to do :(
21:25:00 <FMota> work is overrated
21:25:06 <beelsebob> well
21:25:11 <beelsebob> when you have 3 months money remaining
21:25:24 <FMota> :/
21:25:33 <beelsebob> it's probably fairly necessary
21:27:59 * earnest bows to the authors of xmonad
21:28:28 <earnest> i haven't seen a useful software after the gnu emacs in a long time
21:28:59 <sorear> interesting
21:29:02 * earnest very satisfied
21:29:03 <monochrom> nice
21:29:19 <sorear> the level of xmonad talk on #haskell is almost back to the level it was when I created #xmonad
21:29:38 <earnest> i didnt know there was #xmonad
21:29:51 <FMota> If I had linux, I'd try it out
21:29:53 <sorear> but we are pleased you're pleased :)
21:30:02 * beelsebob has never seen the point of tiling window managers
21:30:02 <hpaste>  s pasted "(no title)" at http://hpaste.org/2637
21:30:04 <FMota> as it stands, I have very little reason to install it...
21:30:12 <beelsebob> overlapping stuff I find so much more useful
21:30:19 <FMota> but I'd like to try it. so, yeah
21:30:24 <beelsebob> let things be the shapes they need to be
21:30:26 <earnest> Fmota: what system do you use?
21:30:30 <FMota> Mac
21:30:32 <sorear> sfultong: means what it says
21:30:43 <earnest> i used to do with my mouse with xmonad now does by itself
21:30:51 <sorear> sfultong: you have a misnamed module
21:30:55 <beelsebob> if the document is A4, why should the window be wider than the A4 page
21:31:08 * monochrom wants an editor that takes the shape of the Mendolbrot set or something.
21:31:10 <earnest> i used to do with my mouse *what* xmonad now does by itself
21:31:36 <monochrom> It would completely justify procrastination - even better than "compiling". :)
21:31:37 <earnest> beelsebob: you got a point, but most of the time i really want to tile the winodws
21:31:46 <beelsebob> earnest: I used to do with my mouse what the F9 key does by its self
21:31:49 <sfultong> sorear: yes, but... a similarly named module works fine... a module called Client.Display in file Client/Display.hs works fine...
21:32:01 <beelsebob> now windows just go everywhere
21:32:08 <beelsebob> and it doesn't matter
21:32:24 <earnest> i still prefer xmonad than those fancies window managers
21:32:35 <earnest> there's also that; there's some kind of beauty in simplicity
21:32:54 <mr_tenor> like programming languages, you don't want the freedom to stuff things up
21:32:56 <earnest> now i just wish alt would function as my meta key under xterm
21:32:58 <conal> sorear: thanks for the poiner for library submissions and the alternative suggestion for Cont as a monoid.
21:33:19 <sorear> sfultong: Exactly - in file Client/Display.hs
21:33:30 <earnest> prefer xmonad [over] those fancies window managers
21:33:38 <sorear> sfultong: You need Client/ClientState.hs, not ClientState.hs
21:33:49 <sorear> earnest: quite easy
21:33:50 <sfultong> sorear: yup, that's what I have
21:33:53 <beelsebob> earnest: http://www.apple.com/macosx/features/expose/ <-- solves the same problem, but allows windows to be freeform
21:33:54 <lambdabot> Title: Apple - Mac OS X - Expos&#233;
21:33:59 <hpaste>  conal pasted "Monoid choices for Cont" at http://hpaste.org/2638
21:34:45 <sorear> sfultong: grep -r 'import *ClientState' .
21:34:50 <earnest> sorear: do you know how to get my alt in shape?
21:35:01 <sorear> earnest: yeah, change modKey to mod4Mask
21:35:13 <earnest> in my xorg.conf?
21:35:14 <sorear> earnest: I have no clue why the default is what it is...
21:35:22 <sorear> earnest: in your Config.hs
21:35:28 <earnest> oh, is that in xmonad?
21:35:35 <earnest> but it was this way even before xmonad
21:35:41 <sorear> earnest: oh.
21:35:46 <sorear> earnest: what terminal?
21:35:49 <earnest> xterm
21:36:56 <sorear> urxvt works for me
21:37:01 <sfultong> sorear: huh, interesting... I didn't realize that how I imported a module would affect how ghc thought it should be named
21:37:09 <sfultong> sorear: thanks, too :)
21:37:16 <earnest> i guess i should leave xterm in the past then
21:37:27 <earnest> i hear that urxvt has good support of unicode?
21:37:34 <sorear> sfultong: you're probably under the impression module names are hierarchal
21:37:41 <sorear> sfultong: they aren't
21:37:53 <sorear> sfultong: Data.Map, Data, and Control.Monad are equally unrelated
21:38:21 <sorear> sfultong: when you import ClientState, ghc looks for ClientState.hs in the path (. and ..), finding it in .
21:38:33 <sfultong> sorear: I thought directory structure was important for module names
21:38:35 <sorear> sfultong: and expects it to be module ClientState
21:39:09 <sorear> sfultong: Only true insofar as module names contain  slashes.
21:39:31 <sorear> sfultong: when you import Client.ClientState, GHC looks for Client/ClientState.hs in the path (. and ..), finding it in .. - but expects module Client.ClientState
21:39:51 <sorear> sfultong: the *only* significance of . is that it expands to the platform filename separator
21:40:14 <sorear> sfultong: there is no scoping, no concept of a current directory, no fanciness of any kind
21:40:21 <sorear> sfultong: just s/./\//g
21:40:37 <sorear> sfultong: clears this up?
21:41:10 <sfultong> yes, thanks
21:50:12 <falconair> >  replicate 6 (recip 6)
21:50:14 <lambdabot>  [0.16666666666666666,0.16666666666666666,0.16666666666666666,0.1666666666666...
21:50:16 <falconair> > let dist buckets = replicate buckets (recip buckets) in dist 6
21:50:17 <lambdabot>   add an instance declaration for (Fractional Int)
21:50:28 <falconair> what's going on here?  why does one work and not the other?
21:51:01 <sjanssen> @type replicate
21:51:03 <lambdabot> forall a. Int -> a -> [a]
21:51:08 <ddarius> falconair: Because in the first, the 6's don't have to be the same type.
21:51:15 <ddarius> But buckets has to be the same type as buckets.
21:51:57 <falconair> oh....but I want a function like 'dist' ... how else can i do it?
21:52:13 <ddarius> What type should dist be?
21:52:43 <falconair> the first result is the correct one, it should be a list of some sort of decimals (float, double, whatever)
21:52:47 <monochrom> @quote fromIntegral
21:52:48 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
21:53:30 <scook0> > let dist buckets = replicate buckets (recip $ fromIntegral buckets) in dist 6
21:53:31 <lambdabot>  [0.16666666666666666,0.16666666666666666,0.16666666666666666,0.1666666666666...
21:54:22 <falconair> cool, thanks!  I was trying to put in explicit type annotations...this one works (and frankly solve many other problems similar bugs :) )
21:57:12 <sorear> conal: I put Partial throught the correct deletion procedure
21:58:22 <conal> sorear: thanks.  what's the procedure?
21:58:35 <sorear> conal: {{Please delete me}}
21:58:47 <conal> sorear: and how does that work?
21:58:53 <conal> i mean, what happens?
21:59:16 <sorear> conal: sets up a category so that the administrators will find it, eventually
21:59:30 <conal> oh, great.  thanks. :)
22:08:21 <dons> night all.
22:08:44 <conal> night dons
22:08:48 <sorear> 'night
23:19:42 <prb> Anyone built the fastcgi libraries with the multi-threaded bindings enabled?
23:28:58 <prb> nm -- darcs tip appears to include it and builds OK.
