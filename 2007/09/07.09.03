00:00:08 <earnest> hum
00:00:12 <olsner> earnest: I worked on a place like that this summer.. people there had been waiting for their internet access to be approved for months... I used the neighbor's open wlan instead when the work required internet access
00:00:15 <earnest> you guys barbeque a lot?
00:00:19 <Adamant> I'm having ribs tomorrow night
00:00:22 <Adamant> yum
00:00:35 <glguy> "waiting to get their internet access to be approved"?
00:00:56 <glguy> where are you? China?
00:00:57 <earnest> olsner: people at my work bring their laptops and they hook them up onto the wireless network there and they have internet...
00:01:17 <earnest> you can always leave your cubicle and go to an internet terminal
00:01:30 <glguy> olsner, I see you are in Sweden :-)
00:01:51 <glguy> what are the qualifications?
00:01:55 <earnest> i don't even mind not having the web too much, or perhaps irc
00:02:07 <olsner> MAC-locked switch ports combined with Xen's virtual network cards means you'd need someone to MAC-unlock your port
00:02:11 <earnest> but i like to have my personal email and certainly the USENET
00:02:21 <earnest> but i like the web too because i often want to download tools
00:02:22 <olsner> and any request to do that has never actually been taken care of
00:02:37 <earnest> but that's fine because i can always download it at an internet terminal that they have there
00:02:43 <glguy> OH
00:02:48 <glguy> you guys are talking about *at work*
00:02:58 <olsner> glguy: yes
00:03:44 <earnest> one of the terminals there is a gnu system, so i actually run a ssh tunnel from that terminal to a freebsd at my past company :) which from there i check my email and use irc or whatever i want
00:03:54 <earnest> but that system doesn't run X, so i can't run firefox or something like that
00:04:05 <earnest> so i'm left with irc/usenet/email which is all through my gnu emacs
00:04:30 <earnest> my previous company saves the day
00:04:38 <earnest> because i don't have another computer to log on to
00:04:51 <olsner> earnest: oh, that doesn't sound entirely kosher... I've found that netadmins can be quite paranoid about long-lasting ssh tunnels
00:04:56 <glguy> heh, if you search for sendmail on archlinux, it returns postfix
00:05:14 <earnest> and from this computer where i run the ssh tunnel i don't have an account on it; i use the account that it's there... so my only chance is to run a ssh tunnel from there to somewhere
00:05:21 <earnest> olsner: they would not really identify that as a ssh tunnel, man
00:05:30 <earnest> unless they are sniffing the network and all
00:05:46 <glguy> and there's no *way* that a netadmin would do *that* ;)
00:05:53 <earnest> :)
00:06:22 <earnest> i dont think they do it, tho
00:06:39 <olsner> (esp. if the tunnel has a lot of traffic and coincides with the spreading of a worm in the network)
00:07:08 <earnest> i also hide the process with a program i wrote just for that actually, which is an old idea on how to fool the UNIX ps
00:07:28 <earnest> my tunnel wouldnt have a lot of traffic
00:07:32 <Adamant> there are a few tricks
00:07:37 <glguy> heh, if you are going to try to look guilty
00:07:38 <glguy> go all out
00:07:44 <Adamant> there are SSL-based VPN's you can use
00:07:55 <glguy> don't stop at simply violating the corporate computer user policies
00:08:01 <glguy> cover up the evidence too
00:08:02 <earnest> i'm limited to the tools installed on this gnu system
00:08:18 <earnest> i'm not exactly violating anything
00:08:35 <earnest> i can send packets to this terminal
00:08:37 <glguy> sure, you can't get out to the internet otherwise because they forgot to set up up all the way
00:08:43 <earnest> and this terminal is allowed to send packets everywhere
00:08:51 <earnest> i'm just automating things :)
00:08:57 <olsner> do you really have legitimate access to your prior employers network?
00:09:02 <earnest> yes
00:09:36 <olsner> oh, okay...
00:10:03 <matt__r> sorry to bug you guys with this question, but there is no-one in the darcs channel - what are the differences between running a script by itself and with `tests script` in darcs prefs?
00:10:17 <earnest> yeah, i wouldn't log in there without their permission
00:10:40 <earnest> i wouldn't even have an account there if that'd be the case
00:10:51 <earnest> but i pretty much still work for them, actually
00:12:12 <earnest> last pepsi glass, then im gonna go fry ribs
00:12:27 <joelr1> good morning
00:12:31 <joelr1> dons: ping
00:12:48 <ddarius> "fry" and "ribs" doesn't seem to go together
00:13:06 <astrolabe> joelr1: You weren't at anglo-haskell were you?
00:13:31 <joelr1> astrolabe: no, people keep asking that. here's my picture: http://wagerlabs.com :-)
00:13:32 <lambdabot> Title: Tenerife Skunkworks
00:13:59 <earnest> so, my task for haskell will be: i have a large INBOX file generated by VM under the gnu emacs; eventually i will want to read that file, change a few headers in each message and send that to some SMTP. I would have no problems in AWK, but AWK is not functional; how does this problem look from functional perspective?
00:14:37 <astrolabe> joelr: Thanks, I thought not.  There was a guy there that used to have a poker server that I am trying to track down.  I don't suppose you have a clue who he might be.
00:15:04 <joelr1> astrolabe: no clue :-) why do you want a haskell poker server?
00:15:11 <ddarius> earnest: About the same way it looks from AWK.
00:15:36 <astrolabe> joelr: heh. no.  He wanted some advice on automatic opponent modelling for poker.
00:16:26 <kosmikus> mrd: you had a question about lhs2tex? was it answered?
00:16:34 <earnest> ddarius: so i would say interact doitAll, then doitAll would get all lines, one at a time, correct?, and then would I sort of compose the message into string to pass it to an external-smtp-sender-program?
00:17:12 <ddarius> earnest: Not exactly, but close enough.
00:18:29 <joelr1> astrolabe: i think uni. of alberta would be your best bet. search for irc poker database and go from there
00:19:05 <joelr1> astrolabe: here you go: http://www.cs.ualberta.ca/~games/poker/
00:19:06 <lambdabot> Title: U of A Computer Poker Research Group
00:19:59 <astrolabe> joelr: thanks, I'll take a look.
00:20:44 <glguy> slubman> Hi
00:20:44 <glguy> <slubman> Does anyone know why ffmpeg segfault ?
00:20:44 <glguy> <glguy> it tried to access memory that it should not have
00:20:44 <glguy> <slubman> any workaround ?
00:21:59 <matthew-_> permit it to access any memory?
00:22:25 <ddarius> glguy: It's not really that unreasonable a question depending on who it's coming from.
00:23:34 <glguy> ddarius: nope, its just characteristic of the channel
00:23:46 <olsner> which channel was that from?
00:24:13 <glguy> #archlinux
00:24:35 <glguy> I don't know who thought it was a good idea to bring Linux to the masses
00:24:40 <matthew-_> strange. I'd have expected it more from #ubuntu
00:25:31 <matthew-_> glguy: there was an article on LWN which was making a similar point about security - most security issues are social engineering, so with linux getting "easier", the overall clue level decreases
00:26:28 <matthew-_> it's a shame elitism is considered a bad thing eh? otoh, this is #haskell ;)
00:26:37 <glguy> it's considered a bad thing?
00:26:41 <Pseudonym> matthew: We're not elitists here.
00:27:03 <Pseudonym> True elitists don't want everyone else to be an elitist too.
00:27:14 <matthew-_> Pseudonym: good point.
00:27:32 <matthew-_> glguy: well yeah, I thought we were mean to be all inclusive these days - anyone can do anything etc etc
00:28:37 <Pseudonym> We're not elitists so much as Kool Aid evangelists.
00:28:54 * ddarius is not a big fan of Kool Aid.
00:29:01 <matthew-_> Right, but I certainly don't believe that everyone can be "saved"
00:29:03 <Pseudonym> I've never had it.
00:29:13 <matthew-_> Vodka evangelists?
00:29:15 <ddarius> Pseudonym: You haven't missed anything.
00:30:00 <astrolabe> elitism is really the belief in rule by the elite rather than the belief that people have a range of abilities.
00:30:08 <Pseudonym> Right./
00:30:14 <Pseudonym> Meritocracy, I tell you.
00:30:18 <ddarius> I believe that for reasonable values of "everyone" everyone can be "saved" (for some apropriate notion of "saved").  This is a much more cynical viewpoint.
00:30:22 <Pseudonym> Or felistocracy, with goldfish having the nukes.
00:30:47 <olsner> "Kool Aid evangelist"? wouldn't that be that Jonestown guy?
00:30:49 <matthew-_> ddarius: hah! "Either learn Haskell or STEP AWAY FROM THE COMPUTER!"
00:30:57 <shapr> I agree with ddarius, but I think that's because I don't think we're doing anything difficult here on #haskell.
00:31:17 <ddarius> "saved" doesn't necessarily mean "use Haskell"
00:31:25 <Pseudonym> That's true.
00:31:40 <ddarius> But yes, I don't think the issues are particularly hard to surmount.
00:31:41 <Pseudonym> Everyone can learn Haskell.  Not everyone has to subsequently use it.
00:31:46 <shapr> I'm thinking stuff like 'critical thinking' and 'measure and then improve' and stuff like that.
00:32:00 <glguy> but they all want to *blog* about it
00:32:02 <shapr> "if you can't measure it, it's opinion"
00:32:06 <matthew-_> Pseudonym: I do not think everyone can learn Haskell
00:32:21 <int-e> glguy: so what, you don't have to read any of it.
00:32:22 <Pseudonym> matthew: I think if you can learn C, you can learn Haskell.
00:32:36 <glguy> int-e: no, but others do
00:32:40 <ddarius> matthew-_: I believe anyone that can learn -some- programming language can learn Haskell.
00:32:43 <shapr> matthew-_: I suspect that the only people who cannot learn Haskell are the people who cannot learn a difficult native language (say, finnish).
00:33:08 <Pseudonym> English is a pretty difficult language.
00:33:22 <matthew-_> Yeah, I was born here and I have the odd battle with it
00:33:30 <osfameron> english doesn't twist your head though.  It's just the subtleties that trip you up
00:33:32 <ddarius> Only because English isn't just English.  Well, primarily nowadays.
00:33:51 <Pseudonym> Does Finnish twist the head of the typical Finn?
00:34:03 <matthew-_> American twists the head of the typical Englishman
00:34:16 * earthy mutters 'cockney rhyming slang'
00:34:23 <osfameron> don't suppose it does.  It twists mine because I learnt baby Finnish and continued to speak that until late teens, and then gave up.
00:34:24 <ddarius> matthew-_: Don't worry.  They twist back.
00:35:07 <glguy> "baby finnish"?
00:35:09 <Pseudonym> (And by "The Typical Finn", I am, of course, not referring to any members of Split Enz.)
00:36:11 <osfameron> glguy: well, what finnish babies talk :-)
00:36:22 <matthew-_> ok ok. But, back to the point, if Haskell was the only language available, the vast interest in Computing would not be so vast and we wouldn't have as much software available today
00:36:38 <matthew-_> otoh, many problems with much of that software also wouldn't exist
00:37:10 <Pseudonym> We wouldn't have as big a line count, that's for sure.
00:37:25 <ddarius> matthew-_: Interest in software comes from users not from programmers (except insofar as they are users too).
00:37:32 <int-e> and computers with more memory.
00:37:46 <ddarius> Users don't care what language you implement your code in.  They just want their use cases handled.
00:37:59 <Pseudonym> Anyway, must away.
00:38:00 <Pseudonym> Nytol!
00:38:12 <matthew-_> ddarius: right, but they do care about software that's buggy and constantly crashing
00:38:42 <glguy> but they prefer buggy software to no software
00:38:52 <glguy> see the current state of the electronic voting machine industry ;)
00:39:16 <ddarius> matthew-_: They're less interested in software that's not buggy and constantly crashing?
00:39:25 <MyCatVerbs> glguy: except that the users quite vocally *don't* want those. >>
00:39:50 <matthew-_> Yes. I would like to believe that we're protected by the Pond. But if our Civil Service ever decided to do electronic elections, it would be /just/ as big a mess
00:40:04 <glguy> MyCatVerbs: the tiny minority that knows enough about them to know not to want them but isn't making a fortune off of them
00:40:10 <matthew-_> ddarius: they're less irate about it?
00:40:11 <glguy> quite vocally doesn't want them
00:40:22 <kReepicheep> ddarius: they're interested in software that runs... they don't necessarily care about quality.
00:40:37 <MyCatVerbs> glguy: ie "everybody with two brain cells to rub together who has also heard of them".
00:40:55 <ddarius> matthew-_: The point you are going back to is eluding me.
00:40:57 <MyCatVerbs> (Which admittedly is a pretty miniscule minority.)
00:40:57 <glguy> I wish that that was the case
00:41:08 <matthew-_> ddarius: yes, I suspect I need breakfast.
00:41:25 <mudge> glguy: do you have a website?
00:41:30 <glguy> no
00:41:38 <ddarius> @time ddarius
00:41:41 <glguy> hpsate.org? :)
00:41:47 <glguy> spelled correctly
00:41:50 <lambdabot> Local time for ddarius is Mon Sep  3 02:40:31
00:42:14 <matthew-_> you'll need brekie too soon then!
00:42:42 <ddarius> Yes. Like now.
00:43:17 <mudge> ddarius: do you have a website or blog?
00:48:12 <therp> any comment about "Programming in Haskell" by Graham? A friend (that recently got into Erlang) is asking me whether I can recommend it
00:48:31 <kosmikus> depends on what you're looking for.
00:48:35 <earnest> which Graham?
00:48:44 <earnest> that wouldn't be Paul Graham, would it?
00:48:45 <kosmikus> therp: have you read dcoutts' detailed review in TMR?
00:48:50 <earnest> I wonder what Graham thinks of Haskell
00:49:00 <earnest> I believe he would like it more than Lisp
00:49:00 <kosmikus> earnest: no, Graham Hutton
00:49:10 <therp> not Paul Graham
00:49:19 <earnest> I'm gonna ask Paul Graham what he thinks of Haskell
00:49:29 <therp> kosmikus: no, thanks will have a look
00:49:48 <therp> the next monad reader deadline is 4.Oct, right?
00:49:49 <olsner> linux's scheduler sucks!
00:49:52 <olsner> argh
00:50:03 <earnest> olsner: what's wrong with it?
00:50:12 <olsner> audacious reading some ID3 tags brings the entire system to a halt for half a minute
00:50:37 <earnest> is this the scheduler's fault?
00:50:49 <olsner> regardless, I blame it!
00:50:53 <earnest> :)
00:51:13 <earnest> should you nice it to something high?
00:52:30 <olsner> I guess it could be an I/O problem too, but I expect other applications to be just a responsive albeit with other CPU-intensive tasks running at half the speed
00:53:14 <earnest> it's funny that reading a file should bring your system to a halt
00:53:15 <kReepicheep> olsner: have you tried the other schedulers?
00:53:33 <olsner> kReepicheep: can I do that at runtime, or must I do that at boot time?
00:53:47 <earnest> the gnu file systems are usually pretty fast
00:53:56 <therp> kosmikus: this a really in-detail review, great. forwarded it to my friend
00:53:57 <earnest> compared to, say, ntfs
00:53:57 <kReepicheep> olsner: not too sure. I remember always seeing the option on kernel compiles though
00:54:01 <earnest> ntfs is really slow
00:54:37 <olsner> I think this system might actually be doing something crazy like PIO
00:55:02 <earnest> what's PIO?
00:55:30 <olsner> no, it's using DMA according to dmesg (phew)
00:56:00 <earnest> man, i'm frustrated that i can't install a gnu system right now
00:56:03 <kReepicheep> you can also check with hdparm IIRC
00:56:06 <earnest> for lack of blank cds
00:57:50 <pejo> earnest, Fedora Core 7 has boot-media that is suitable for putting on an USB stick and install from the net, iirc.
01:00:54 <olsner> my super-cool high-speed Raptor drive is slower than the newer slower cheapest-price-per-GB disk, by almost 8 MB/s
01:01:12 <olsner> "slower"
01:01:23 <DRMacIver> shapr: Hm?
01:01:40 <mudge> therp: I'm reading the book Programming Haskell,   I think it is pretty good
01:01:46 <gour> earnest: you can eg. do ftp install of Arch linux by dl-ng floppy image only
01:02:22 <mudge> earnest: you going to ask Paul Graham what he thinks about haskell?
01:03:53 <mudge> kosmikus: you there?
01:05:05 <earnest> pejo: i don't have a usb stick :( i could've bought one tho
01:05:22 <earnest> gour: i have no floopies; i could've bought some tho
01:05:30 <earnest> i totally didn't think of these things
01:05:37 <earnest> i thought my cdrom was a dvdrom
01:05:47 <kosmikus> mudge: yes, for 5 minutes
01:05:48 * earnest is silly
01:05:49 <gour> earnest: huh, it's good time to start thinking about them
01:05:56 <earnest> mudge: i will ask him
01:06:10 <gour> earnest: so you can burn cd
01:06:39 <earnest> yeah, i will buy some tomorrow
01:07:39 <gour> good luck tomorrow...what will you put on your box?
01:08:07 <earnest> a debian system, i guess
01:08:36 <earnest> i'm a big fan of the organization of the freebsd people
01:08:40 <gour> i was thinking about it (after moving from gentoo) and went with Arch
01:08:47 <earnest> but i like the gnu project more
01:08:53 <earnest> what's Arch?
01:09:26 <gour> http://archlinux.org/about/
01:09:27 <lambdabot> Title: Arch Linux
01:10:09 <earnest> hm, interesting
01:10:21 <earnest> i like that
01:10:37 <earnest> is debian full of these ``let's set it up'' configuration tools?
01:10:47 <gour> no idea
01:11:16 <earnest> i never used it
01:11:18 <gour> http://wiki.archlinux.org/index.php/Arch_vs_Others
01:11:19 <lambdabot> Title: ArchWiki :: Arch Compared To Other Distros - ArchWiki
01:11:20 <kReepicheep> earnest: yes and no. it has a configuration system that's related to the packaging system (apt).
01:11:35 <earnest> i haven't learned how to use apt yet
01:11:40 <kReepicheep> earnest: after initial install it generally stays outa your way
01:11:42 <earnest> i dont know how they all work together, in fact
01:11:44 <kosmikus> mudge: now away for ~30 minutes, then back ...
01:11:46 <earnest> apt, apt-get, aptitude...
01:11:51 <kReepicheep> earnest: I'm sorry dpkg not apt
01:12:08 <earnest> yeah, i hear only good things about debian
01:12:14 <kReepicheep> where it gets involved are when you have several alternative packages installed like nvi and vim for example
01:12:25 <earnest> plus the fact that debian seems to be the most gnu one...
01:12:30 <gour> earnest: this is 'manifesto' http://wiki.archlinux.org/index.php/The_Arch_Way
01:12:31 <lambdabot> Title: ArchWiki :: The Arch Way - ArchWiki
01:12:54 <gour> earnest: i was the most smooth install i ever had wit hany distro
01:12:55 <kReepicheep> earnest: it's one of the few I use that I like
01:13:03 <gour> s/i/it
01:13:49 <quicksilver> there are two kinds of package management: (1) dpkg (2) broken attempts to reinvent dpkg
01:13:55 <quicksilver> personaly I'd recommend (1). YMMV.
01:14:39 <kReepicheep> rpm done right is ok IMHO. Unfortunately, you usually have to buy a license to experience that.
01:15:22 <stepcut> quicksilver: and nix  ;)
01:15:52 <earnest> one thing i like about distros is that they set up my hardware is pain-free as possible; but i suppose that's more of a kernel task, no?
01:16:20 <earnest> if the kernel supports your hardware, it detects and initializes at boot time / module-load-time, right? so i guess the distro has nothing to do with it, or almost nothing
01:16:27 <gour> quicksilver: arch's pkg is just a simple tarball
01:16:29 <stepcut> earnest: if only that were true
01:16:42 <quicksilver> earnest: what the distro has to do is supply the right version of the kernel with the right patches and the right modules
01:16:47 <earnest> stepcut: what's the truth then? :)
01:16:48 <stepcut> nix's package manager is purely functional :p
01:17:02 <earnest> quicksilver: true
01:17:10 <quicksilver> earnest: and supply user-land software which talks directly to harware (mostly X, alsa etc) correctly configured
01:17:19 <stepcut> earnest: the crap never works right and you have to have lots of scripts that try to probe things, black list things, pass in special options, and other insanity
01:17:22 <earnest> yeah... that's a bit harder now
01:17:34 <earnest> yeah, this complexity really sucks
01:17:46 <earnest> we need to be very careful with the UNIX philosophy
01:17:55 <earnest> having programs talking to one another can get really tricky
01:17:59 <earnest> and *complex*
01:18:09 <earnest> the system at my work is this way... :)
01:18:12 <stepcut> earnest: in theory Xorg 7.3 is supposed to completely do away with the /etc/X11/xorg.conf, but I will believe it when I see it ;)
01:18:26 <earnest> that thing is so complicated... jesus christ
01:18:35 <gour> xorg?
01:18:40 <earnest> i understand nothing about X and its families
01:18:51 <gour> earnest: what card you have?
01:18:57 <earnest> it's a part of UNIX that i feel pretty clueless
01:19:07 <earnest> i have an NVIDIA gforce something
01:19:38 <gour> earnest: on arch, running nvidia-config did everything for me. even dual-monitor setup with TV-out
01:19:58 <stepcut> earnest: the only interesting one these days is X.org, which was forked from XFree86
01:20:21 <sjanssen> stepcut: have you tried autoconfiguration in the current release?  It works pretty well in my experience
01:20:22 <earnest> wow
01:20:36 <earnest> what's X.org's license?
01:20:48 <Japsu> the MIT/X11 license
01:20:56 <sjanssen> I'd be running without an xorg.conf if it was smart enough to use my touchpad over the generic USB mouse
01:21:08 <earnest> same xfree's license, then
01:21:09 <Japsu> somewhat like BSD without adv. clause, just simpler
01:21:13 <Japsu> nope
01:21:24 <earnest> xfree's is MIT license, no?
01:21:26 <Japsu> XFree has a "new version" of the license
01:21:34 <earnest> which is its own?
01:21:35 <Japsu> which adds significant complexity and restrictions
01:21:40 <earnest> like what?
01:22:11 <Japsu> hrmh can't remember anymore, go read it at xfree86.org... it's what sparked the xfree/xorg fork, thoug
01:22:16 <stepcut> earnest: XFree86 upgrade to BSD4 (i think) which had some wacky advertising clauses, and was the final straw that caused the fork
01:22:28 <earnest> i see
01:22:38 <earnest> fork as in freedom
01:22:41 <stepcut> earnest: but, there was also a lot of fighting prior to that, that was just the excuse
01:22:41 <earnest> :)
01:22:57 <earnest> as you said: the last straw
01:23:05 <earnest> or final :)
01:23:09 <gour> stepcut: any url that new xorg will do without xorg.conf ?
01:23:24 <earnest> so one day i came up with approximated quotes, with a friend
01:23:32 <earnest> we decided on this notation:
01:23:34 <stepcut> earnest: many people felt the core XFree86 developers moved too slow, and were too resistant to accepting new developers, changes, etc
01:23:42 <earnest> stepcut said ~``the last straw''~
01:24:10 <earnest> the truth is that people dont need reasons to fork
01:24:18 <earnest> but i think the community should lay some rules on forking
01:24:26 <earnest> such as do not keep the name
01:24:28 <earnest> not even close
01:24:34 <earnest> X.org should be called Y or something
01:24:42 <matthew-_> earnest: there is Y-windows
01:24:51 <earnest> then it should be called K :)
01:24:53 <evir> But that is not a fork.
01:25:09 <earnest> a fork should not take the name with it
01:25:15 <matthew-_> evir: it's not anything!
01:25:25 <matthew-_> earnest: that's part of the GPL I think
01:25:32 <stepcut> gour: this one has a great title, but not much information: http://people.freedesktop.org/~ajax/ddc2006.pdf
01:25:42 <earnest> well, the gpl doesnt say you can keep a similar name
01:25:50 <earnest>                              cannot
01:26:01 <earnest> it says you cant keep the same name, right?
01:26:08 <matthew-_> that's what I thought
01:26:19 <earnest> now, knuth did the Right Thing with TeX
01:26:26 <earnest> except that... now it's public domain, right?
01:26:30 <earnest> that's so weird
01:26:51 <earnest> if you fork TeX you have to call it something entirely different
01:26:51 <earthy> no it's not public domain.
01:26:53 <MyCatVerbs> ?check (\z->(if odd z then (=='9') else (/='9')) $ last $ show $ 9^x) :: Integer -> Bool
01:26:54 <lambdabot>   Not in scope: `x'
01:26:57 <earnest> it's not? good.
01:26:59 <MyCatVerbs> ?check (\z->(if odd z then (=='9') else (/='9')) $ last $ show $ 9^z) :: Integer -> Bool
01:27:01 <lambdabot>  Exception: Prelude.^: negative exponent
01:27:18 <MyCatVerbs> ?check (\z->(if odd z then (=='9') else (/='9')) $ last $ show $ 9^(abs z)) :: Integer -> Bool
01:27:19 <lambdabot>  OK, passed 500 tests.
01:27:22 <earthy> but you can do what you want with it as long as you do not call the new thing TeX
01:27:25 <earnest> so earthy, i suppose it's this knuth-mini-license that i'm talking about then
01:27:32 <earnest> yeah, there we go... that's it
01:27:55 <Auris-> well, they didn't call it xfree86.org.
01:28:08 <gour> stepcut: thanks. not certain it will be 7.3 ?
01:28:32 <stepcut> gour: I think it is. Mostly it just means that they will have hotplug monitor support
01:28:37 <matthew-_> Auris-: quite. texlive and tetex are as different from TeX as xorg is from xfree86
01:28:46 <stepcut> gour: xorg.conf will still be supported, but if you don't have one, something sane will happen
01:28:47 <earnest> that's nice... except that i do have little thing against companies taking control of stuff from the community without giving anything back; every software company out there these days are using The People's Stuff, and probably very few are giving it back
01:29:11 <gour> stepcut: in 7.3?
01:29:21 <Auris-> matthew-_, dunno. I've always been confused about tetex. :-)
01:29:27 <stepcut> gour: the cooler part is, if you plug in an project or second monitor, etc, it is supposed to autodetect that and ask if you want to extend your desktop onto the new display
01:29:31 <earnest> tetex is not a fork of TeX
01:29:33 <gour> stepcut: we'll see in a few days
01:29:34 <sjanssen> stepcut, gour: the current release already supports this to some extent
01:29:36 <stepcut> gour: I believe the patches were commited months ago
01:29:38 <earnest> tetex is just a distribution of TeX
01:29:45 <earnest> like MikTeX
01:30:06 <earnest> i guess
01:30:06 <stepcut> sjanssen: does the current release support monitor hotplug ?
01:30:23 <sjanssen> stepcut: yes, for some drivers
01:30:33 <gour> sjanssen: right. i powered TV on my card and could configure it as 2nd (separate) screen using nvidia's config
01:30:46 <stepcut> sjanssen: nifty
01:31:01 * stepcut really should know these things
01:31:39 <sjanssen> gour: nvidia is a bit of a different story, AFAIK
01:32:08 <gour> sjanssen: why?
01:32:50 <sjanssen> gour: you had to use special nvidia tools to hotplug your 2nd monitor?
01:35:07 <gour> sjanssen: yes, nvidia-setting pkg
01:35:15 <therp> earnest: I think there are no rules on naming in the GPL
01:36:07 <sjanssen> gour: and this is the difference ;).  The new hotplugging stuff in Xorg uses the same interface (randr 1.2) for all drivers, rather than some proprietary thing
01:37:19 <earnest> therp: i just searched for ``fork'' or ``deriv'' and found nothing
01:37:27 <gour> sjanssen: well, not much difference for me and taking into consideration that there are not so many different drivers in use ...
01:38:01 <therp> earnest: other licenses include rules on how to deal with forks, but I think forks where less common (no internet) when the GPL was written..
01:38:27 <therp> err s/no internet/no wide public access to the net/
01:38:30 <therp> that's what I meant
01:38:37 <earnest> :)
01:38:45 <earnest> i got it
01:38:52 <earnest> i dont like to put rules on things
01:39:07 <earnest> but i think that we should keep the images of people intact
01:39:45 <earnest> taking your software x and call it x-me and making a horrible mess isn't very nice; it eventually makes x look bad too, i think; all due to people's cluelessness
01:40:03 <earnest> but perhaps the Right Thing is to have us all paying the price
01:40:12 <earnest> we're a society after all; if we suck, we suck, period.
01:40:58 <earnest> i give a lot of thought to these things
01:41:00 <earnest> for instance:
01:41:13 <earnest> this channel might have a rule or another
01:41:22 <earnest> but suppose that a lot of haskellers come here tomorrow
01:41:32 <earnest> and they start making a huge mess here; the channel now sucks
01:41:36 <earnest> what should we do?
01:41:43 <earnest> i mean: what's the right thing to do?
01:41:52 <therp> kick them.
01:41:56 <earnest> why?
01:42:01 <therp> because otherwise we get #lisp
01:42:09 <earnest> what? :)
01:42:25 <therp> #lisp is horrible place to hang out. I really love the rules and social conventions that are intact here
01:42:45 <earnest> i don't know #lisp
01:42:51 <earnest> i like it here because of the people
01:42:57 <therp> a rule set that does not have any rules that protect them from change is evolutionary unstable
01:43:22 <sjanssen> @users
01:43:23 <lambdabot> Maximum users seen in #haskell: 394, currently: 363 (92.1%), active: 14 (3.9%)
01:43:26 <earnest> hm, ``protect them from change''
01:43:39 <earnest> i'm not sure that's a very good thing
01:44:00 <therp> earnest: me too :) but I found the social norms to be quite ok in here.
01:44:01 <earnest> systems do need to be changed as we find bugs in them or if we want improvements
01:44:16 <sjanssen> well, a very specific definition of 'change'
01:44:44 <therp> earnest: in your example you gave a subtle negative taste to 'change' when you phrase 'they make a huge mess'
01:45:03 <therp> earnest: so I presumed it would be a negative change wrt the overall utility this channel provides for the community
01:45:22 <earnest> i dont even know what's the social norm in here, but the people here have a very nice co-existance and there seems to be true intelligence here which seems to be a very rare thing in IRC nowadays; the programming channels are full of assholes; for instance, hang in ##c, and you might get disgusted, like I do.
01:46:19 <therp> earnest: my synonym for ##c is #lisp :)
01:46:19 <earnest> therp: true, but my point was that the mess'ers might be half the community; suppose that, for instance; or suppose that compose 57% of the community
01:46:19 <johnnowak> earnest: shove off
01:47:03 <earnest> what does ``shove off'' mean?
01:47:25 <int-e> earnest: that's still no good reason to give up a friendly channel; they can create their own one if they are so inclined.
01:47:35 * sjanssen starts #haskell-jerks
01:47:41 <puusorsa> try #coders on ircnet for real intelligent discussion :p
01:47:49 <johnnowak> the most innocuous bit of rudeness i could think of so as to provide a humorous and unexpected remark
01:50:00 <earnest> i was putting forth a sort of philosophical problem; they might claim --- and this can be done well enough --- that they're friendly enough and their ways dont differ too much from the ``norm'' here; but in one way or another, they destroy the good atmosphere
01:51:23 <araujo> morning
01:51:25 <therp> earnest: I would rather advise for an aggressive strategy to keep this local optimum (and really like it!) and kick them.
01:51:55 <therp> earnest: but that's a pure theoretic answer. I have rarely seen kicks to misbehaving people in here.
01:51:57 <earnest> but to kick people from a community place seems wrong, therp
01:52:18 <therp> earnest: definitely not. I would remove a lot of people from their roles in communities.
01:52:33 <earnest> where can i read the rules of this channel?
01:52:51 <araujo> earnest, hi there
01:52:52 <earnest> therp: can someone remove your role of removing roles? :)
01:52:54 <therp> earnest: there are no written rules :)
01:52:56 <earnest> hi araujo
01:52:59 <MyCatVerbs> I submit to the (heretical) notion that this channel doesn't *need* written rules.
01:53:03 <araujo> earnest, i'd say the only rule for this channel is being polite
01:53:06 <earnest> therp: that's a Good Thing :)
01:53:09 <therp> earnest: I don't have this role, so I guess someone did already :)
01:53:15 <sjanssen> earnest: 1) Be nice.  2) Talk about Haskell most of the time.
01:53:19 <earnest> hehe, that's another Good Thing :)
01:53:26 <MyCatVerbs> "Don't be a total jerk," isn't complicated enough to require writing out longhand.
01:53:29 <earnest> i've been breaking (2) badly, sjanssen
01:53:49 <MyCatVerbs> earnest: yet you haven't been flooding the channel with it, so no one cares.
01:54:24 <earnest> that's nice then; but listen: why doesn't this channel need written rules? i would think that no one does; what does this channel have in special?
01:54:25 <therp> earnest: breaking (2) is ok, as long as it's interesting :) -- Haskell discussions will take over anyway if it's not interesting for the majority. a kind of natural revert to on-topic discussions :)
01:54:34 <earnest> i mean, in your opinion
01:54:34 <sjanssen> 2 is greatly relaxed as long as you're not overwhelming on topic discussion
01:55:07 <MyCatVerbs> earnest: because it's overwhelmingly stuffed with freakishly nice people.
01:55:33 <earnest> hehe, ``freakishly nice people'' :) i guess that's what i like here
01:55:44 <MyCatVerbs> earnest: seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychich MegaHelpfulness.
01:55:50 <earnest> and, conversely, what i dont like everywhere else
01:55:50 <MyCatVerbs> *Psychic
01:56:00 <stepcut> there is also #haskell-blah offtopic conversations
01:57:55 <earnest> MyCatVerbs: yeah, this channel distinguishes itself
01:58:08 <araujo> earnest, Haskell programmers prefer theorems instead of rules.
01:58:22 <earnest> knowing it has about 400 users, it becomes very unusual
01:58:24 <xerox> ?remember MyCatVerbs [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
01:58:24 <lambdabot> Done.
01:58:26 <MyCatVerbs> araujo: and lemmas in place of guidelines? ;)
01:58:31 <earnest> araujo: good point :)
01:58:49 <xerox> ?users
01:58:49 <lambdabot> Maximum users seen in #haskell: 394, currently: 363 (92.1%), active: 13 (3.6%)
01:59:08 <xerox> Only a small percentage is usually "active" at a given time.
01:59:15 <kReepicheep> It pales in comparison to OpenBSD's channel friendliness.
01:59:30 <earnest> how's openbsd's?
01:59:33 <araujo> The rest of the people is just spying our world domination plans
01:59:38 <MyCatVerbs> kReepicheep: er...
01:59:47 <Naktibalda> who said "world domination"?
02:00:14 <masm> I want to world dominate also.
02:00:19 <masm> ?users
02:00:19 <lambdabot> Maximum users seen in #haskell: 394, currently: 363 (92.1%), active: 16 (4.4%)
02:00:20 <earnest> :)
02:00:23 <MyCatVerbs> kReepicheep: having idled in both for a few months, I wouldn't say that. OpenBSD's channel's reasonably civilised, but not quite as exceptional as this.
02:01:02 <kReepicheep> kReepicheep: We're talking about the people who used to bitch about /away messages because they didn't have good enough clients to filter them, right?
02:01:06 <xerox> Naktibalda: want to join?
02:01:16 <kReepicheep> s/kReepicheep/MyCatVerbs
02:02:39 <kReepicheep> MyCatVerbs: This used to be in their channel page for a while http://sackheads.org/~bnaylor/spew/away_msgs.html
02:02:40 <norpan> @quote
02:02:41 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
02:02:41 <lambdabot> Title: People who use /away constantly suck ass
02:02:57 <norpan> should it do that?
02:03:23 <xerox> Seems dons took the Entropy with him to the US and lambdabot hasn't got any left.
02:03:32 <MyCatVerbs> kReepicheep: and who get stuffy if your nick ever changes in channel, as this obstructs the plentiful (uhhh) discussion with single annoying messages once every few dozen hours or so. Never mind that this pales in comparison with the overhead simply from channel joins/parts and peoples' dodgy internet connections...
02:05:05 <araujo> Seriously, i have been around this channel for a while now ... and it is the nicer channel for a PL community , Haskell seems to attract very smart and nice people. I always hope new users keep our community like that too.
02:05:12 <earnest> these types of complaints are very unintelligible since a /ignore would just work for that person
02:05:14 <MyCatVerbs> kReepicheep: but, Hell, I'm not claiming that they aren't right either. ;)
02:05:31 <kReepicheep> MyCatVerbs: They do good work ;)
02:05:43 <kReepicheep> MyCatVerbs: but they're jerks about it :D
02:05:58 <ivant> yay, look what I've got: http://i2.tinypic.com/6gvnqr8.png
02:06:11 <earnest> yeah; you see, you can be extremely competent and be socially awful
02:06:31 <earnest> ivant: what's that?
02:07:14 <ivant> it is the solutions of a nonlinear ODE system. I'm trying to stabilize the solutions, and it looks like I've succeeded
02:07:36 <earnest> what's ``to stabilize'' a solution?
02:07:40 <ivant> I mashed up a small haskell program yesterday which solves the ODE and plots the graphics
02:07:52 <earnest> wow, cool
02:08:02 <evir> The plot is also very nice ... antialiased.
02:08:09 <araujo> Haskell makes people happy
02:08:11 <araujo> :-D
02:08:22 <ivant> earnest, suppose you have some real object, say, inverted pendulum
02:08:41 <ulfdoz> kReepicheep: Btw. is your client good enough to post away messages only in those channels, where it is not considered annoying?
02:08:47 <hpaste>  judahj pasted "Attempted doc install fix" at http://hpaste.org/2556
02:08:57 <ivant> earnest, it will fall down, because it is ‘unstable’ in the top position
02:08:59 <earnest> araujo: :) there may be some truth in that; people working low level tend to be very unfriendly, but that may just be coincidence in my experience
02:09:16 <earnest> ivant: i follow you so far; go ahead
02:09:26 <araujo> earnest, it'd be interested to research this phenomenon
02:09:48 <ivant> earnest, now, suppose you can move the pivot point. By moving it you can ‘stabilize’ the pendulum in the top position
02:10:06 <earnest> what's the pivot point?
02:10:07 <ivant> (imagine balancing a pencil on your finger)
02:10:22 * earnest imagines
02:10:25 <DRMacIver> Hm. Semi-OT question: If I have a setup with 'normal' threads and continuations and want to try to build a lightweight threading model on top of this, where would be a good place to start my reading?
02:10:58 <ivant> earnest, umm, I may be wrong with terminology
02:11:16 <earnest> just put in words your feelings of a pivot point is
02:11:26 <earnest>                                 of what a (...)
02:12:11 <ivant> ·------O — this is a pendulum (rotated by -π/2)
02:12:20 <earnest> okay
02:12:29 <ivant> the weight is at the right, the pivot point is at the left
02:12:56 <earnest> oh, so the pivot point, as far as we care, is where my finger touches the pencil?
02:13:04 <ivant> yep
02:13:36 <earnest> the stable point would be the one in which the pencil is balanced and doesnt fall?
02:13:38 <ivant> now, we can mathematicaly describe our system of finger and pencil (or, whatever) with a system of differential equations
02:15:10 <kReepicheep> ulfdoz: with a script yes
02:15:18 <ivant> earnest, not quite. wait a sec, I'll try to put it in words
02:15:43 <kReepicheep> ulfdoz: however, it can disable viewing away messages on a per channel basis
02:17:04 <ulfdoz> kReepicheep: Yes, several 100 people are able to remove you on a per channel basis. You failed to follow the ettiquette, you got kicked. Daily business, simple and the kicked person is usually the only one, not agreeing.
02:17:55 <ivant> M is a stable _movement_ (of some system) if any movement N which you get by slightly disturbing movement M tends to get closer to M when time → ∞
02:18:10 <ivant> for some definition of slightly
02:18:14 <earnest> i have a hard time with this example --- not related to the stable-point-definition perhaps ---, which is: i can't think of a way to describe such pendulum system; i don't think i ever solved a pendulum equation, so i dont think ever saw a diff eq of this kind; would a population-model have its stable point?
02:19:11 <ivant> earnest, it may have, or it may have not. I guess, it does (population=0)
02:19:18 <earnest> i could relate better to a populational model; and what comes to mind as a stable point would be where the population equals the carrying capacity; does that make sense to you?
02:19:55 <ivant> earnest, yes probably
02:20:05 <ivant> earnest, ok, lets switch to the population model
02:20:12 <earnest> hm, population = 0 is out of the domain of the model :)
02:20:17 <kReepicheep> ulfdoz: I don't like the tone of that second person there. I've pretty much never been kicked from any channel including the one we're discussing. I'm just saying it's a very elitist attitude to take for people who know how, and very well could filter away notifications, nick changes, and joins.
02:20:28 <ivant> earnest, is it? can't population die? :-)
02:20:44 <earnest> they can; but not in their models
02:21:10 <earnest> i mean, i can't really think of a model that would account for that
02:21:26 <ivant> earnest, all right, I don't remember the population model: what kind of varying entities we have there (other than the population)?
02:21:44 <earnest> just population variance
02:21:47 <ivant> e.g. resources?
02:21:53 <earnest> that would complicate things more
02:21:58 <earnest> let's leave the resources aside :)
02:22:17 <earnest> the resources are always there.. but implicitly
02:22:21 <ulfdoz> kReepicheep: There are n+1 different away messages, weekly coming up new ones from m+1 different people. Why should all adjust their ignore because of one person not following the rules?
02:22:28 <earnest> we can add the carrying capacitity to the system
02:22:34 <earnest> shall i give you one nice example?
02:22:40 <ivant> ok, so, we have a system like ẏ = f(y, t). where y is population, right?
02:23:01 <xerox> Oh, that dotted y is so nice :)
02:23:04 <earnest> right; i dont see the symbol on the left, tho
02:23:53 <ivant> earnest, sorry, y'=f(y,t)
02:24:39 <osfameron> (nice characters)-- # and I'm sure putty+screen+irssi should all be speaking utf8...
02:24:41 <earnest> no problem
02:25:09 <ivant> now, suppose we have some solution y=F(t,t0,y0)
02:25:21 * earnest supposes
02:26:03 <xerox> Hey, don't you see the sign? You can't stand there and suppose at this hour of the day.
02:26:05 <kReepicheep> ulfdoz: because it's taking a very quarrelsome stance on situations that could be simply avoided. It's the same reason I prefer /ignore to +b's for offtopic conversation. <hypocrisy alert ;)>
02:26:28 <ivant> we'll call it unstable if for however small the change we'd make to the population at t0, the following dynamics of the population would diverge from F(t,t0,y0)
02:27:05 <earnest> such as adding *too many* members?
02:27:20 <ivant> earnest, no, even adding one person
02:27:21 <earnest> or changing their sexual habits?
02:27:41 <earnest> right; anything that would cause a divergence from the solution
02:27:42 <ivant> earnest, we have only one variable for now :-)
02:27:57 <earnest> right right; i'm just trying to imagine a reason for that to happen to a population
02:28:50 <earnest> because what change to the *population* we'd make at t0 that would generate a different solution? perhaps i don't get what ``diverge from F()'' means
02:28:54 <ivant> earnest, now imagine that we can somehow control the dynamics (e.g., increase/decrease the birth rate using some methods at our own will)
02:29:08 * earnest imagines
02:29:32 * ivant wonders if we should move to #haskell-blah
02:29:43 <earnest> let's do it
02:29:46 <earnest> i'm already there
02:30:07 <ivant> sorry guys
02:30:25 <xerox> ivant: no problem.
02:31:39 <joelr1> dons: sent you the tarball
02:32:00 <dcoutts> @vixen who stole all your pirate quotes lambdabot?
02:32:00 <lambdabot> Plugin `vixen' failed with: IRCRaised getRandItem: empty list
02:32:03 <dcoutts> noo!
02:32:12 <dcoutts> they got to vixen too
02:32:22 <xerox> Arr!
02:52:42 <dcoutts> @seen liyang
02:52:42 <lambdabot> liyang is in #haskell. I don't know when liyang last spoke.
02:52:49 <dcoutts> liyang: ping
03:00:00 <quicksilver> @users
03:00:00 <lambdabot> Maximum users seen in #haskell: 394, currently: 365 (92.6%), active: 12 (3.3%)
03:12:28 <iguana_> i'm searching since a while for a good explanation what "bottom" is and how it affects haskell evaluation
03:12:34 <iguana_> can anyone give me a pointer?
03:12:50 <LeCamarade> Comrades, Brethren. Haskellers. From all over _Le Monde Grand_, From Down Under and Up Yonder. Tell ye me, what, in but one sentence well-crafted, are open function types?
03:13:04 <LeCamarade> iguana_: It is an error, in short.
03:13:04 <quicksilver> iguana_: "bottom" represents results which fail to converge
03:13:13 <quicksilver> iguana_: for example, a function which doesn't terminate
03:13:19 <quicksilver> iguana_: or an exception is thrown
03:13:53 <iguana_> but is it an actual value that's passed around?
03:14:36 <LeCamarade> iguana, yes, you can pass it around. But once it is evaluated, BOOM.
03:14:45 <iguana_> hm, ok
03:14:50 <LeCamarade> > length [undefined, undefined]
03:14:51 <lambdabot>  2
03:15:03 <LeCamarade> > head [undefined, undefined]
03:15:04 <lambdabot>  Undefined
03:15:07 <iguana_> so "undefined" is one way to get a bottom value?
03:15:17 <LeCamarade> > undefined -- This is Bottom (TM)
03:15:19 <lambdabot>  Undefined
03:15:37 <LeCamarade> iguana_: Bottom is the compiler-known bottom. :o)
03:16:12 <iguana_> when do you have to care about bottom?
03:16:22 <kfish> > ⊥ -- Accept no substitute, this is the Real Bottom
03:16:23 <lambdabot>  Illegal character ''\138''
03:16:39 <quicksilver> it's simplifying to say you can pass "it" around
03:16:50 <quicksilver> suggests there is only one way to represent a bottom value
03:16:57 <LeCamarade> iguana_: I hate it, for one, but what should you do if the spec says the result is `undefined'?
03:16:58 <earnest> haskellers, enjoy the day
03:17:00 <quicksilver> > let x = x in x
03:17:02 <lambdabot>  Exception: <<loop>>
03:17:02 <LeCamarade> Like factorial of 0?
03:17:18 <quicksilver> iguana_: very rarely do you have to care about it
03:17:28 <LeCamarade> let (_'_) = undefined in (_'_) -- Bottom (TM)
03:17:32 <quicksilver> iguana_: but anyone who writes computer programs has to recognise that not all programs terminate
03:17:34 <LeCamarade> >let (_'_) = undefined in (_'_) -- Bottom (TM)
03:17:55 <iguana_> yes
03:18:05 <quicksilver> it's not observable
03:18:13 <LeCamarade> > let (_'_) = undefined in (_'_) -- Bottom (TM)
03:18:14 <lambdabot>  Undefined
03:18:16 <quicksilver> so you can't do much about it anyway :)
03:20:30 <quicksilver> LeCamarade: I've never heard of open function types, I'm afraid
03:21:18 <dhpeterson> ?seen dons
03:21:19 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 50m 32s ago.
03:21:39 <dhpeterson> ?seen Pseudonym
03:21:39 <lambdabot> I saw Pseudonym leaving #haskell-blah and #haskell 2h 43m 37s ago, and .
03:25:07 <LeCamarade> quicksilver: Seen MT Chak's latest blog post?
03:29:03 <quicksilver> LeCamarade: ah. Open Type Functions.
03:29:14 <quicksilver> LeCamarade: that's a bit different from Open Function Types :)
03:29:25 <quicksilver> LeCamarade: that's from his web page though, not his blog. Where is his blog?
03:32:54 <LeCamarade> Ma bad. :o)
03:33:10 <LeCamarade> His blog? Lemme check my feeds ...
03:33:31 <LeCamarade> Or you can just run to planet.haskell.org
03:34:30 <quicksilver> LeCamarade: ah, got it
03:59:01 <joelr1> g'day
04:14:04 <joelr1> wow, it's eerily quiet here
04:14:26 <joelr1> must be my irc client that's misbehaving
04:15:12 <dcoutts> @arr!
04:15:12 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
04:15:15 <dcoutts> doh
04:15:28 <dcoutts> joelr1: no it's just quiet
04:16:00 <dcoutts> joed: everyone's just coming to terms with the fact it's Monday morning
04:16:02 <njbartlett> Lunchtime in Europe, and too early for North America
04:16:05 <joelr1> haha
04:16:16 <joelr1> i'm coming to terms with it for sure
04:16:17 <njbartlett> And bedtime (at last) for dons
04:16:26 <quicksilver> it was a quiet morning even before it was lunchtime
04:16:31 <quicksilver> not many lambdas today
04:16:40 <quicksilver> maybe the weekend had too many side-effects
04:17:24 <joelr1> i wonder, is it possible to write cons-free code in haskell?
04:17:29 <joelr1> with ghc of course
04:18:16 <oerjan> joelr1: i thought that was the point of ghc's deforestation optimizations
04:18:33 <joelr1> oerjan:  i mean completely cons-free
04:18:47 <joelr1> that would mean strictly strict code
04:18:49 <oerjan> as in not even in the source?
04:18:55 <joelr1> no laziness or ghc would create thunks
04:19:01 <joelr1> to be evaluated later
04:19:05 <joelr1> thus no laziness
04:20:04 <oerjan> well you can use the unboxed types
04:20:27 <joelr1> right
04:21:43 <oerjan> and case statements on them are strict i think
04:23:29 <LeCamarade> I'm updating my Haskell Hacker's Kit: GHC System, Hugs System, Darcs, IRC Client, PS&||PDF tools* (way too many papers). *New!
04:23:45 <LeCamarade> Those are what one needs, I think. :o)
04:23:47 <LeCamarade> To do Hs.
04:24:20 <earthy> Haddock?
04:24:31 <earthy> web browser?
04:25:26 <LeCamarade> :-o But you can survive without Haddock ... Um ... IRC + PDFs > Web browser ... ;o)
04:25:51 <Boney> GHC > Hugs
04:25:53 <Boney> :-)
04:27:12 <LeCamarade> Many examples and newbie problems require a Hugs environment.
04:27:24 <earthy> GHCi?
04:27:44 <LeCamarade> Part of the GHC system?
04:28:48 <ibid> yes
04:36:27 <takamura> hey
04:37:02 <matthew_-> @seen Heffalump
04:37:02 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 6h 48m 6s ago.
04:39:22 <Igloo> He is unlikely to be around for 6 hours or so
04:43:17 <matthew_-> ja, they're not allowed IRC in the banks are they?
04:43:22 <wolverian> is the type functions paper based on the recent GHC associated types work?
04:43:28 <wolverian> that is, do they describe the same thing?
04:46:27 <matthew_-> is the lightweight concurrency primitives paper the direction that the haskell runtime is going to be taking?
04:46:59 <matthew_-> s/haskell/ghc/
04:47:33 <schemelab> hilarous - http://paste.lisp.org/display/47151
04:47:49 <takamura> does somebody know a haskell library for creating pdfs?
04:48:24 <Boney> matthew_-: do you have a link for that paper?
04:49:19 <scook0> takamura: there's http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HPDF-0.3 on hackage, though I've never used it
04:49:21 <lambdabot> http://tinyurl.com/3yavt4
04:49:27 <Boney> @google lightweight concurrency primitives
04:49:28 <lambdabot> https://research.microsoft.com/users/simonpj/papers/lw-conc/index.htm
04:49:43 <takamura> thanks, scook0
04:50:00 <matthew_-> Boney: yep, that's the one
04:50:08 <matthew_-> it's at HW@ICFP07
04:50:25 <quicksilver> takamura: no. but there is one at http://hackage.haskell.org/packages/archive/pkg-list.html
04:50:47 <quicksilver> takamura: I'd personaly tend to generate LaTeX and then run pdflatex, but it depends what kind of document you're hoping to produce
04:51:00 <Boney> matthew_-: cheers.
04:51:36 <osfameron> what are the format rules for if..then..else ?
04:51:45 <osfameron> I always end up sticking them on one line, which is fugly
04:51:57 <matthew_-> you can put them on different lines
04:52:12 <matthew_-> I tend to put the "then" and "else" directly below the if
04:52:24 <matthew_-> but that can cause problems in do notation without { and ; and }
04:52:31 <takamura> quicksilver, its a document with a format almost fixed, but that can change sometimes, namely certificates, invoices, etc. Almost all the text is fix, but some part changes (person names, numbers, etc.)
04:53:25 <osfameron> matthew_-: ah ok, I had a *different* error this time.  I'll fix that, then try formatted as you suggested
04:53:39 <wolverian> takamura, perl's pdf stuff is great (PDF::API2 IIRC) if you could use that.
04:53:46 <takamura> the easiest would be Latex, but I dont want that my client worried about problems with Latex installation
04:54:15 <quicksilver> takamura: I'd definitely try for a latex solution for stuff like invoices and certificates
04:54:31 <takamura> wolverian, i prefer to use haskell. The rest of the program is in haskell, and i konow nothing about perl :S
04:54:53 <takamura> mmm, probably will use latex
04:55:10 <hpaste>  osfameron pasted "getting lost in do expression (random numbers)" at http://hpaste.org/2558
04:55:26 <osfameron> I'm having trouble with above code...
04:55:51 <osfameron> I want to concatenate an a with a list of IO [a] ...
04:55:54 <Philippa> takamura: LaTeX's got packages for most linux distros. I don't know how easy it is to totally automate a miktex install though
04:56:13 <Philippa> (miktex being the usual distro under windows)
04:56:26 <Boney> takamura: a friend found it easy-enough to write his invoice formatting stuff in postscript.  so the invoice data would be a pre-able attached to invoice formatting code..  all in postscript.  Then printed or whatever.  Leaving the actual formatting to execute in the printer or print-server.
04:56:32 <takamura> the program is for windows
04:56:46 <takamura> i used miktex long time ago, and it is easy to install
04:57:03 <scook0> osfameron: (x:) `liftM` (pickN2' (n-1) (l-1) xs) maybe?
04:57:24 <oerjan> osfameron: return x: has precedence problems, try return $ x: or what scook0 said
04:57:26 <osfameron> scook0: good God, that's horrible! ;-)
04:57:30 <takamura> my main concern is if maybe 2-3 ayers later, miktex installation brokens, for any reason, and it must be reinstalled
04:57:46 <Philippa> takamura: right - like I said, whether you can automate it sufficiently
04:57:53 <osfameron> oerjan: yeah, I think I originally had return $ ...
04:57:54 <Philippa> if you can make it nearasdammit one click, all's cool
04:57:56 <scook0> well, you can format it different ways if you want
04:58:04 <takamura> the better solution would be a solution i can pack with my program and control entirely
04:58:07 <osfameron> but that didn't deal with the (non monad):[monad] problem
04:58:10 <oerjan> osfameron: oh, that won't work because pickN2' is monadic
04:58:28 <osfameron> scook0: that "lifts" the sectioned (:) to work monadically on the LHS ?
04:58:35 <oerjan> in fact you cannot do it in a let
04:58:39 <takamura> Boney, the invoice format should be configurable by the user
04:58:40 <swiert> takamura: what about html?
04:58:46 <scook0> one of these days I must write a "how to mash these two terms together" oracle
04:58:53 <scook0> :t liftM
04:58:55 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:58:57 <DRMacIver> I suppose just doing do { xs <- myMonad; return $ x:xs; } is out of the question? :)
04:58:57 <takamura> html would looks odd for certificates
04:59:02 <takamura> i think
04:59:11 <Boney> takamura: you should be able to extend the idea.  Obviously the user shouldn't control everything but they may control some things.
04:59:19 <scook0> osfameron: aye
04:59:25 <DRMacIver> (Which I guess is just liftM (x:) )
04:59:47 <scook0> DRMacIver: I decided to keep it a one-liner
04:59:54 <takamura> Boney, for example, in the certificates, there are text that come from laws
04:59:58 <takamura> that laws can change
05:00:02 <osfameron> DRMacIver: that said I think your solution makes more sense
05:00:08 <takamura> and the certificates must be modified accordingly
05:00:17 <hpaste>  oerjan annotated "getting lost in do expression (random numbers)" with "one way" at http://hpaste.org/2558#a1
05:00:51 <Boney> takamura: mabye I don't quite understand exactly what your doing.  But I beleive most things you should be able to submit as data to a post script program which places them on the page.
05:01:00 <takamura> but yes, i should restrict users freedom to change the document
05:01:17 <osfameron> oerjan: but where's the return?
05:01:53 <DRMacIver> scook0: All programs are one-liners, for sufficiently long lines. ;)
05:02:05 <hpaste>  scook0 annotated "getting lost in do expression (random numbers)" with "a few stylistic variations" at http://hpaste.org/2558#a2
05:02:29 <scook0> DRMacIver: my heuristic is that it would've been a one-liner in an impure language :)
05:02:36 <oerjan> osfameron: return is not needed
05:02:56 <osfameron> oerjan: oh.
05:02:59 * osfameron cries
05:03:29 <alexeevg> can I have multi-line formatted string in 'Description' of cabal-package?
05:03:36 <osfameron> still.  I didn't set myself the task of actually understanding Monads, just *using* them, so I suppose I'll just cargo-cult that for now
05:03:44 <osfameron> oerjan, scook0, DRMacIver: thanks :-)
05:03:46 <takamura> i will look at hpdf
05:03:59 <swiert> alexeevg: Sure. What's causing you trouble?
05:04:43 <alexeevg> swiert: I can't see formatting in preview on Hackage upload page
05:04:51 <scook0> osfameron: oh, if I'd known that, I would've just given the do-version ;)
05:05:03 <DRMacIver> osfameron: return is very non-magical. :)
05:05:15 <alexeevg> swiert: All lines are catenated
05:05:24 <swiert> alexeevg: I've done something along those lines for IOSpec.
05:05:33 <oerjan> osfameron: generally, do ret <- whatever; return ret is equivalent to just do whatever
05:05:35 <osfameron> scook0: :-)
05:06:05 <DRMacIver> Where "generally" means "it's one of the monad laws", right?
05:06:06 <oerjan> that's the second monad law in disguise
05:06:07 <swiert> alexeevg: Are you indenting the newlines?
05:06:17 <DRMacIver> ok. :)
05:06:28 <alexeevg> swiert: yes
05:06:46 <swiert> alexeevg: Do you have any empty lines?
05:06:47 <oerjan> f >>= return = f
05:06:47 <quicksilver> osfameron: 'return' if you need to put something into a monad which wasn't already
05:06:55 <quicksilver> osfameron: but no return, if the thing was alread in the monad
05:07:05 <alexeevg> swiert: No, should I
05:07:07 <alexeevg> ?
05:07:10 <oerjan> er, f not necessarily a function actually
05:07:16 <swiert> alexeevg: No. Empty lines cause problems.
05:07:39 <DRMacIver> oerjan: Dont' you mean f >>= return x = f x ?
05:07:53 <quicksilver> no
05:08:12 <quicksilver> f is a monadic action which he binds to return
05:08:12 <xerox> return x >>= f = f x
05:08:13 <swiert> alexeevg: It might be a Hackage-preview-problem...
05:08:18 <DRMacIver> Oops, sorry, yes.
05:08:19 <oerjan> DRMacIver: no, actually x >>= return = x
05:08:20 <alexeevg> swiert: I've found IOSpec on hackage, I'll use your *.cabal as example. Thanks for your help!
05:08:23 <swiert> alexeevg: I've used multiline description fields.
05:08:25 <DRMacIver> Right.
05:08:27 * DRMacIver sucks
05:08:31 <osfameron> quicksilver: ah, ok.  I'm still confused as to how do and return "know" which monad they're supposed to be in.  (I guess that desugaring the whole expression would make that clearer)
05:08:37 <swiert> alexeevg: Np. Glad to help.
05:08:58 <DRMacIver> osfameron: Just by the overall type of the expression. It's the usual type inference magic that Haskell does.
05:09:00 <oerjan> i started writing it as f before i realized it was not the function part
05:09:28 <quicksilver> osfameron: sometimes, they don't
05:09:35 <quicksilver> :t return 1
05:09:38 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
05:09:46 <DRMacIver> osfameron: In the same way that with 1 :: Int and 1 :: Rational, 1 knows which type of number it's supposed to be.
05:09:47 <quicksilver> osfameron: ^^ doesn't know which monad it's on
05:10:05 <DRMacIver> osfameron: The only difference is that often the type is inferred rather than explicitly annotated.
05:10:38 <DRMacIver> > return 1 !! 0 -- knows it's a list because of the type of !!
05:10:40 <lambdabot>  1
05:11:05 <idnar> hah
05:11:18 <osfameron> :t (^^)
05:11:21 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
05:11:25 <idnar> I confused myself into thinking that shouldn't work
05:11:48 <oerjan> osfameron: i think he meant ^^ as "look above", not as the ^^ operator
05:12:02 <idnar> > maybe 5 (return 6)
05:12:03 <lambdabot>  Add a type signature
05:12:21 <idnar> oh whoops
05:12:25 <idnar> > maybe 5 id (return 6)
05:12:28 <lambdabot>  6
05:12:40 <xerox> > maybe 5 (return 6) (return 10)
05:12:40 <DRMacIver> :t maybe
05:12:42 <lambdabot>  6
05:12:42 <osfameron> ah ok
05:12:43 <xerox> ;-)
05:12:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:13:46 <hpaste>  oerjan annotated "getting lost in do expression (random numbers)" with "with just do" at http://hpaste.org/2558#a4
05:14:45 <quicksilver> osfameron: yes, ^^ was "look above" :)
05:15:02 <quicksilver> osfameron: and whilst (x:) `liftM` is very cute, and probably what I'd use myself
05:15:18 <quicksilver> osfameron: I think the 'do' version which oerjan has pasted is probably more clear for 'beginners'
05:15:23 <oerjan> osfameron: i just pasted how you could do it without fancy liftM's
05:15:28 <quicksilver> agreed
05:15:38 <osfameron> oerjan: cool, just saw it
05:15:59 <quicksilver> althoug the ret <- ; return ret part can go
05:16:01 <osfameron> oerjan: so there you have a return, because ret is de-monadified, and you have to re-monadify it?
05:16:15 <osfameron> ah, ok
05:17:26 <oerjan> osfameron: as quicksilver says, the ret <- and return are unnecessary
05:17:38 <oerjan> i just tried to modify your original version minimally
05:17:46 <osfameron> cool, ta
05:21:59 <osfameron> does liftM2 work equally for m a `op` a as per a `op` m a ?
05:22:21 <oerjan> um...
05:22:30 <oerjan> liftM2 takes 3 arguments
05:22:42 <oerjan> so it's not quite as suited as infix
05:23:09 <osfameron> right, but where the op would have been infix I mean (I think...)
05:23:37 <oerjan> liftM2 f x y where x and y are both monadic, f a pure function
05:23:39 <quicksilver> only with an intervening let
05:23:44 <quicksilver> unfortunately
05:23:51 <quicksilver> becaise you can't put expressions in ``
05:23:59 <quicksilver> you can't say x `liftM2 (+)` y
05:24:10 <quicksilver> but you can say let (+++) = liftM2 (+) in x +++ y
05:24:12 <oerjan> you _can_ write it as (f `liftM2` x) y
05:24:28 <vincenz> lo
05:24:32 <oerjan> but it seems slightly pointless
05:24:51 <oerjan> a better way is f `liftM` x `ap` y
05:25:19 <osfameron> ah ok
05:25:29 <idnar> @src ap
05:25:29 <quicksilver> oerjan: he wanted to preserve the infixness of f, I think
05:25:29 <lambdabot> ap = liftM2 id
05:25:32 <oerjan> or if your monad is also Applicative, f <$> x <*> y
05:25:44 <quicksilver> oerjan: as in x `f` y
05:26:03 <osfameron> oh, but now I'm confused, because am I not concatenating a pure value (x) with a monadic value [m xs] ?
05:26:16 <quicksilver> that's why it was only liftM
05:26:18 <quicksilver> and not liftM2
05:26:25 <quicksilver> (essentially)
05:26:26 <oerjan> oh right, i may have been confused, indeed that seems impossible
05:26:46 <osfameron> ah, sorry.  my brane added the "2" because I've seen it elsewhere...
05:26:50 <quicksilver> osfameron: note you weren't lifting (:) (a two-arg function)
05:27:02 <quicksilver> osfameron: you were lifting (x:) , which is a section, and hence has only one arg left
05:27:18 <quicksilver> osfameron: in a sense, you were lifting (:) on the right but not the left
05:27:26 <osfameron> ok. I think my initial reaction ("Good God that's horrible") was correct.
05:27:34 <quicksilver> exactly as you said "a pure value (x) with a monadic value [m xs]"
05:28:02 <alexeevg> Do I need some serious justification to get a Hackage account? I have a tiny improvement to a tiny package (initial version was kindly uploaded for me by Spenser Janssen)
05:29:35 <alexeevg> @yarr
05:29:35 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:29:47 <oerjan> what?
05:29:53 <oerjan> @arr
05:29:54 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:30:08 <osfameron> db failure probably?
05:30:40 <oerjan> something like that
05:30:43 <dons> hmm, interesting.
05:30:43 <oerjan> @yow
05:30:44 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:30:48 <dons> yeah, i'll look at it in the morning.
05:30:51 <oerjan> @quote
05:30:51 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
05:30:55 <oerjan> all of them
05:31:18 <oerjan> @users
05:31:18 <lambdabot> Maximum users seen in #haskell: 394, currently: 375 (95.2%), active: 19 (5.1%)
05:31:21 <dons> ?where ghc
05:31:21 <lambdabot> http://haskell.org/ghc
05:31:41 <dons> ?quit
05:32:00 <dons> ?quote
05:32:06 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
05:32:22 <dons> ?users
05:32:28 <lambdabot> Maximum users seen in #haskell: 394, currently: 375 (95.2%), active: 1 (0.3%)
05:32:33 <matthew_-> dons: are you the only person that can issue quit?
05:32:56 <dons> there's a few people with privs. typically, just operators in channels lambdabot lives in, or developers of lambdabot
05:33:24 <dons> usual suspects
05:33:24 <dcoutts> dons: thanks for restoring lambdabot :-)
05:33:26 <dcoutts> @yarr!
05:33:26 <lambdabot> Arrr!
05:33:39 <int-e> @quote
05:33:40 <lambdabot> dons says: the lambda revolution isn't going to happen without YOUR CODE!
05:33:42 <dons> i think that's the infamous 'empty list of randoms' bug, that i've not seen in a long long time
05:34:02 <dons> apparently i didn't actually work out what the problem was, or it got reintroduced some how
05:34:49 <dons> ok, 5.30 am. my jet lag is kicking in. better try to get some sleep. night all!
05:35:10 <matthew_-> time for brekkie, surely?
05:35:25 <LeCamarade> Wait!
05:35:29 <LeCamarade> dons, wait!
05:35:40 <Sizur> hi guys, new blood here for haskell. Very much excited about the language!
05:36:07 <LeCamarade> 5:30am is evil, by the way. You're an organic REPL of sorts here ... nobody knows what damage you could cause ...
05:36:16 <LeCamarade> Sizur: Welcome. :o)
05:36:32 <DRMacIver> Sizur: Excellent. Haskell can always use new blood sacrifices.
05:36:39 <DRMacIver> Oh, that wasn't what you meant. Never mind...
05:36:45 * DRMacIver looks innocent. :)
05:36:53 * matthew_- rolls his eyes
05:36:53 <LeCamarade> DRMacIver: A rather hard god to please, no? A monad every freakin' day?
05:36:59 * vincenz hmms
05:37:00 <vincenz> ok
05:37:03 <vincenz> jetlag is starting to kill me
05:37:06 * vincenz waves
05:37:12 * DRMacIver gives matthew_- a cookie.
05:37:20 * LeCamarade doesn't know what to do.
05:37:27 * matthew_- gobbles and spills cookie crumbs all over the place
05:37:57 * matthew_- notices the similarites between the floor and the Writer monad
05:38:21 * LeCamarade wonders how long this will go on ... 'tis fun.
05:40:33 <DRMacIver> matthew_-: ?
05:40:52 <matthew_-> well, stuff goes into it, but you never know quite where it'll end up!
05:41:38 <mux> that's the /dev/null monad! ;-)
05:42:50 <matthew_-> no, the floor of my office isn't quite like /dev/null
05:43:02 <EvilTerran> data Null a = Null; instance Monad Null where return = Null; _ >>= _ = Null
05:43:19 <matthew_-> nor is the desk - no matter how much I ignore the hundreds of papers strewn across it, I am concious they are actually still there
05:43:42 <EvilTerran> return _ = Null, rather
05:43:49 <mux> mine is a bit like /dev/null in that I often lose objects when they fall on the floor
05:43:52 <mux> like, lighters
05:44:04 <matthew_-> well that's because the monad knows you shouldn't smoke
05:44:16 <matthew_-> or set fire to stuff
05:44:28 <EvilTerran> but i *like* setting fire to stuff!
05:44:45 <mux> that's the moralist monad
05:45:14 * oerjan notes that haskell must distinguish between strict and lazy null monads
05:45:16 <matthew_-> no, it's just easily influenced by government propoganda
05:46:27 * EvilTerran is still vaguely amused that there're Eq and Ord instances for ()
05:46:33 <oerjan> (strict ones having x >>= _ = x)
05:47:03 <EvilTerran> ...does that pass associativity?
05:47:04 <quicksilver> EvilTerran: they're important for the generic instances like Eq a, Eq b => Eq (a,b)
05:47:31 <EvilTerran> quicksilver, i know they're useful, for completeness if nothing else, but it's still kinda amusing imo
05:47:48 <matthew_-> I find it a little scary that Ordering has an instance of Ord
05:48:21 <EvilTerran> > EQ `compare` LT
05:48:23 <lambdabot>  GT
05:48:36 <matthew_-> > LT < EQ && EQ < GT
05:48:38 <lambdabot>  True
05:49:04 <matthew_-> someone should also define GT < LT and see what breaks!
05:49:14 <matthew_-> actually, can Ord have cycles?
05:49:55 <ari> > EQ `mappend` LT
05:49:56 <lambdabot>  LT
05:50:07 <oerjan> @check (l1 `compare` (l2 :: [Int])) == (zipWith compare l1 l2 `compare` repeat EQ)
05:50:08 <lambdabot>   Not in scope: `l2'
05:50:10 <EvilTerran> in practice, yes, but i think one of the "requirements for Ord instances" is that you don't
05:50:19 <oerjan> @check \l1 l2 -> (l1 `compare` (l2 :: [Int])) == (zipWith compare l1 l2 `compare` repeat EQ)
05:50:21 <lambdabot>  Falsifiable, after 0 tests: [1], []
05:50:33 <oerjan> bah
05:51:20 <oerjan> @check \l1 l2 -> (if length l1 == length l2 then l1 `compare` (l2 :: [Int])) == (zipWith compare l1 l2 `compare` repeat EQ)
05:51:20 <lambdabot>  Parse error
05:51:50 <oerjan> @check \l1 l2 -> if length l1 == length l2 then (l1 `compare` (l2 :: [Int])) == (zipWith compare l1 l2 `compare` repeat EQ)
05:51:50 <lambdabot>  Parse error
05:52:50 <oerjan> :t \l1 l2 -> if length l1 == length l2 then (l1 `compare` (l2 :: [Int])) == (zipWith compare l1 l2 `compare` repeat EQ)
05:52:52 <lambdabot> parse error (possibly incorrect indentation)
05:53:11 <oerjan> ah
05:53:32 <oerjan> @check \l1 l2 -> if length l1 == length l2 then (l1 `compare` (l2 :: [Int])) == (zipWith compare l1 l2 `compare` repeat EQ) else True
05:53:34 <lambdabot>  Falsifiable, after 2 tests: [], []
05:54:10 <EvilTerran> > fix (compare EQ)
05:54:11 <lambdabot>  Exception: <<loop>>
05:54:45 <EvilTerran> > map fromEnum [minBound :: Ordering ..]
05:54:46 <lambdabot>  [0,1,2]
05:55:54 <oerjan> @check \l1 l2 -> if length l1 == length l2 then (l1 `compare` (l2 :: [Int])) == (zipWith compare l1 l2 `compare` replicate (length l1) EQ) else True
05:55:56 <lambdabot>  OK, passed 500 tests.
06:11:56 <iguana_> @src liftM
06:11:56 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:21:49 <gimbo> @seen dons
06:21:49 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 47m ago.
06:22:10 <oerjan> gimbo: he said he was going to bed
06:22:58 <gimbo> heh - ta :)
06:23:16 * gimbo should get on freenode in the middle of the night (GMT)
06:23:28 <gimbo> np, no biggie
06:45:02 <nomeata> @seen dcoutts
06:45:02 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 16m 43s ago.
06:45:08 <dcoutts> hia nomeata
06:45:13 <nomeata> dcoutts: hi
06:45:28 <nomeata> dcoutts: I’m currently working on 0.9.12 for debian
06:45:31 <dcoutts> cool
06:45:35 <nomeata> but I have a problem building gtk2hs
06:45:50 <nomeata> lots of these: gtk/Graphics/UI/Gtk/Types.chs:4665:25:
06:45:50 <nomeata>     Not in scope: type constructor or class `CUInt
06:45:54 <dcoutts> nomeata: with GType being an CUInt vs CULong
06:46:01 <dcoutts> recent change in glib headers
06:46:08 <dcoutts> I have a small patch...
06:46:09 <nomeata> ah, ok. What’s the fix? :-)
06:46:12 <nomeata> nice
06:46:31 <dcoutts> at least I think it fixes, it, fedora 8 had the same problem, as did I when I updated glib
06:47:09 <nomeata> and while I’m at it: is http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=427796#10 still needed with 0.9.12?
06:47:11 <lambdabot> Title: #427796 - gtk2hs: Subsequent build process fails - Debian Bug report logs
06:47:49 <dcoutts> nomeata:
06:47:51 <dcoutts>     hunk ./tools/hierarchyGen/Hierarchy.chs.template 33
06:47:51 <dcoutts>     -import Foreign.C.Types    (CULong)
06:47:51 <dcoutts>     +import Foreign.C.Types    (CULong, CUInt)
06:48:50 <dcoutts> nomeata: yes, I added that just after 0.9.12
06:49:45 <iguana_> I'm currently trying to compile the "plugins" package from hackage, and get a very strange error
06:49:57 <iguana_> configure: error: C compiler cannot create executables
06:50:15 <iguana_> and in config.log
06:50:22 <iguana_> | #define TOP "/home/myself/plugins-1.0
06:50:22 <iguana_> | [?1034h"
06:52:59 <iguana_> ah, that define is generated by configure with the following command
06:53:11 <iguana_> echo "Directory.getCurrentDirectory >>= putStrLn.init.tail.show " | ghc --interactive -ignore-dot-ghci -v0
06:53:24 <iguana_> and if I run that in a shell, I get the strange "[1034h" too
06:54:01 <iguana_> (GHC 6.6.1)
06:54:10 <__nasa__> Question -- How do I initialize a data with random values (with e.g. data User = Guy Integer Float)?
06:54:35 <__nasa__> :t return getStdRandom (random)
06:54:37 <lambdabot>     Ambiguous type variable `g' in the constraint:
06:54:37 <lambdabot>       `RandomGen g' arising from use of `random' at <interactive>:1:21-26
06:55:02 <oerjan> :t getStdRandom
06:55:04 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
06:55:18 <nomeata> dcoutts: you also redefine GTK_CHECK_VERSION in gtk2hs-config.h.in, which is, for gtk and glib, also defined there. this causes only ugly warnings, thought...
06:55:21 <takamura> :t StdGen
06:55:23 <lambdabot> Not in scope: data constructor `StdGen'
06:55:24 <oerjan> @index getStdRandom
06:55:25 <lambdabot> System.Random
06:55:25 <scook0> it may help to use a random monad
06:55:26 <__nasa__> so it is already IO
06:55:36 <dcoutts> nomeata: sigh, yes.
06:55:46 <__nasa__> scook0 -- that is what they are
06:55:51 <__nasa__> :t random
06:55:53 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
06:56:03 <dcoutts> nomeata: that's tricky, since we need to define them for .hs code, but that also gets included into .hsc files
06:56:47 <nomeata> dcoutts: ah, so I can’t just remove it from there. I assumed you added it before gtk had it.
06:57:12 <dcoutts> nomeata: no, sorry, we use it to conditionally compile .chs code
06:57:19 <scook0> something along the lines of http://haskell.org/haskellwiki/New_monads/MonadRandom
06:57:20 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
06:57:20 <nomeata> dcoutts: but then you could just rename it as GTK2HS_GTK_CHECK_VERSION, to get rid of the warnings.
06:57:21 <dcoutts> nomeata: the warnings are harmless though
06:57:27 <dcoutts> nomeata: true
06:57:45 <nomeata> dcoutts: harmless but ugly :-) but that’s ok :-)
06:57:57 <dcoutts> right
06:58:30 <__nasa__> ahh, scook0, I was missing the evalRand.
06:58:42 <swiert> __nasa__: Why do you need a random data type?
06:59:05 <__nasa__> I want to initialize the fields randomly
06:59:06 <iguana_> nobody got an idea?
06:59:14 <__nasa__> for testing and such
06:59:30 <swiert> __nasa__: if it's for testing, your much better off using QuickCheck.
07:00:02 <swiert> @where QuickCheck
07:00:02 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
07:04:12 <__nasa__> swiert, I think that should work for part of the code.
07:08:33 <iguana_> waaah
07:08:37 <iguana_> it seems to be a terminal issue
07:08:44 <iguana_> with rxvt, it works fine
07:08:58 <iguana_> wth
07:09:27 <iguana_> with konsole, it doesn't
07:09:55 <nomeata> dcoutts: what would be the easiest way to build the ghci libraries at build time, instead of when running ghc-pkg register?
07:11:14 <dcoutts> nomeata: it builds ghci libs by default, you just have to not delete them from the install image when you build your .deb
07:11:42 <nomeata> dcoutts: ah, ok, now that’s easy :-)
07:11:57 <dcoutts> right :-)
07:11:59 <nomeata> dcoutts: what’s the advantage of having them build by ghc-pkg?
07:12:15 <dcoutts> nomeata: smaller .deb I suppose
07:12:22 <__nasa__> swiert, what should I do if I want to randomly role dice and sum the values?
07:12:27 <dcoutts> nomeata: I never had anything to do with that decision
07:12:53 <__nasa__> (and no, I will not be using this to get a random number ;-))
07:13:00 <dcoutts> nomeata: or perhaps I did actually, we changed to building ghci libs by default a few versions ago.
07:13:37 <dcoutts> nomeata: previously at the request of the rpm maintainer we didn't build the ghci libs and relies on ghc-pkg to do it. but we noticed that's very slow and not worth the space saving.
07:14:03 <nomeata> dcoutts: yes, I got the same complaints for the debian package
07:14:08 <dcoutts> nomeata: I had thought that the .deb caught up in version 0.9.11
07:14:44 <nomeata> dcoutts: no, although someone submitted a fix. he did it in a very bad way, so I just now discovered how he actually did it.
07:15:08 <dcoutts> nomeata: ok :-)
07:15:34 <nomeata> @seen liyang
07:15:34 <lambdabot> liyang is in #haskell. I don't know when liyang last spoke.
07:16:20 <oerjan> > runState (liftM sum . replicateM 10 . State . randomR $ (1,6)) . mkStdGen 1
07:16:22 <lambdabot>  Couldn't match expected type `a -> s'
07:17:08 <oerjan> :t randomR
07:17:10 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
07:17:41 <oerjan> > runState (liftM sum . replicateM 10 . State . flip randomR $ (1,6)) . mkStdGen 1
07:17:42 <lambdabot>  Couldn't match expected type `a -> (a1, a1)'
07:18:23 * nomeata thinks gtk2hs takes too long to compile :-]
07:18:36 <oerjan> > runState (liftM sum . replicateM 10 . State $ flip randomR (1,6)) $ mkStdGen 1
07:18:37 <lambdabot>  Couldn't match expected type `(a, a)'
07:18:49 <oerjan> > runState (liftM sum . replicateM 10 . State $ randomR (1,6)) $ mkStdGen 1
07:18:52 <lambdabot>  (41,1244126523 1336516156)
07:19:01 <EvilTerran> nomeata, i'm sure duncan'd be delighted to hear from you if you manage to make it build faster
07:19:08 <nomeata> :-) I know
07:19:16 <dcoutts> nomeata: yeah, it does. If you're doing test builds you can disable -O for a big time saving
07:19:26 <nomeata> make gtk upstream switch to haskell by default
07:19:33 <dcoutts> hah
07:19:56 <dcoutts> nomeata: when cabal does parallel builds and we're using an external c2hs it'll fly :-)
07:19:57 <nomeata> I don’t even run the tests.
07:20:32 <__nasa__> oerjan -- the sum of those 6 dice rolls is 41?
07:20:41 <oerjan> 10 rolls
07:20:44 <__nasa__> yeah
07:20:53 <__nasa__> ok, I think that makes sense.
07:21:11 <nomeata> the problem with package maintenance is that you usually re-build the whole package, because changes apply to the build in total − in contrast to actually hacking, when you hoefully only re-compile the changed file.
07:21:22 <oerjan> the State is used to thread the generator monadically
07:22:02 <oerjan> you could use RandomRIO instead and drop most of it, but lambdabot does not allow IO
07:23:07 <__nasa__> ok, that makes sense.
07:23:13 <__nasa__> :t RandomRIO
07:23:15 <lambdabot> Not in scope: data constructor `RandomRIO'
07:23:19 <nomeata> dcoutts: a mail of mine to gtk2hs-devel is caught in the filter because I sent it from my debian address, and not from my subscribed personal address − sorry for the hassle
07:23:27 <__nasa__> @hoogle RandomRIO
07:23:28 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
07:23:28 <oerjan> :t System.Random.RandomRIO
07:23:31 <lambdabot>     Not in scope: data constructor `System.Random.RandomRIO'
07:23:39 <oerjan> er, randomRIO
07:24:06 <__nasa__> @hoogle randomRIO
07:24:07 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
07:24:14 <__nasa__> hmmm
07:24:23 <oerjan> @dice 10d6
07:24:24 <lambdabot> 10d6 => 40
07:24:28 <dcoutts> nomeata: no probs
07:24:41 <dcoutts> nomeata: especially as I'm not moderator ;-)
07:24:52 <nomeata> oh, ok :-)
07:24:59 <__nasa__> nice! I doubt it works in my GHC :-(
07:25:21 <oerjan> @where ghci-on-acid
07:25:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
07:25:30 <__nasa__> yeah, I know...
07:26:03 <SamB> @where goa
07:26:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
07:26:35 <oerjan> @where ghc.*acid
07:26:35 <lambdabot> I know nothing about ghc.*acid.
07:27:12 <SamB> hehe
07:27:16 <SamB> regexes!
07:27:56 <SamB> dons: news flash: that WAS the morning
07:28:00 <oerjan> @quote r.*x
07:28:01 <lambdabot> monochrom says: These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
07:29:25 <SamB> @quote r[^ ]*x
07:29:25 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
07:29:41 <SamB> @quote r[^\x20]*x
07:29:41 <lambdabot> JulianMorrison says: Small startup companies are the expendable sensory and feeding apparatus of the mainstream.
07:30:37 <oerjan> didn't work
07:30:50 <SamB> yeah, I can see that
07:31:04 <SamB> I meant to express my frustration but I guess I forgot :-(
07:31:14 <oerjan> > map ord [33,127]
07:31:22 <lambdabot>   add an instance declaration for (Num Char)
07:31:22 <lambdabot>     In the expression: 127
07:31:30 <oerjan> > map chr [33,127]
07:31:31 <lambdabot>  "!\DEL"
07:32:11 <oerjan> @quote r[!-\?]*x
07:32:11 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
07:32:59 <xerox> o_O
07:33:08 <oerjan> saw that trick the other day, not sure if i remember the \? correctly
07:33:39 <nomeata> dcoutts: another bug that’s still valid: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=395200
07:33:41 <lambdabot> Title: #395200 - gtk2hs-doc: Broken links to Graphics-UI-Gtk-Types.html in html doc - D ...
07:34:08 <dcoutts> nomeata: yeah, there's lots of those. It's a big job clearing them all up.
07:34:36 <dcoutts> nomeata: there's lots of links that should be links but are not too.
07:34:53 <dcoutts> nomeata: that one is really a haddock bug. It's linking to a hidden module.
07:34:54 <Shurique> @pl \ (a, b) (as, bs) -> (a:as, b:bs)
07:34:55 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (:)) . flip . (((.) . (,)) .) . (:))
07:35:14 <nomeata> dcoutts: ok, I’ll quote you in that bugreport if you don’t mind
07:35:20 <dcoutts> ok
07:36:34 <oerjan> Shurique: i am sure i saw someone do that with arrow operations the other day
07:37:01 <oerjan> or something very similar
07:37:21 <Botje> @pl \(a,b) -> (a:,b:)
07:37:21 <lambdabot> (line 1, column 14):
07:37:21 <lambdabot> unexpected ","
07:37:21 <lambdabot> expecting white space or simple term
07:37:30 <Botje> boo
07:37:37 <Botje> @pl \(a,b) -> ((:) a, (:) b)
07:37:37 <lambdabot> (:) *** (:)
07:37:45 <oerjan> that part isn't the problem
07:37:50 <Botje> :t (:) *** (:)
07:37:52 <lambdabot> forall a a1. (a, a1) -> ([a] -> [a], [a1] -> [a1])
07:38:04 <Botje> oh, but then you have to apply it somehow
07:38:05 <Botje> brr :(
07:38:27 <EvilTerran> > uncurry (***) ((:) *** (:)) ('a','b') ("foo","bar")
07:38:27 <lambdabot>  Couldn't match expected type `(b, c)'
07:38:47 <oerjan> @instances-importing Control.Applicative Applicative
07:38:48 <EvilTerran> > (uncurry (***) . ((:) *** (:))) ('a','b') ("foo","bar")
07:38:50 <lambdabot>  ("afoo","bbar")
07:38:50 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
07:39:06 <EvilTerran> there we go.
07:39:22 <Shurique> interesting
07:40:22 <oerjan> :t uncurry (***)
07:40:24 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
07:43:11 <EvilTerran> > (uncurry (***) . join (***) (:)) ('a','b') ("foo","bar")
07:43:12 <lambdabot>  ("afoo","bbar")
07:43:54 <LoganCapaldo> @pl \a b as bs -> (a:as, b:bs)
07:43:55 <lambdabot> (. (:)) . flip . (((.) . (,)) .) . (:)
07:44:01 <LoganCapaldo> yow
07:44:09 <EvilTerran> my way is nicer
07:44:14 <LoganCapaldo> indeed
07:44:21 <LoganCapaldo> I was just curious
07:44:24 <EvilTerran> just writing it pointfully's nicer ,too
07:44:36 <int-e> ((.) . (,)) <-- is @pl trying to wink?
07:46:05 <int-e> join (***) (:) is just (:) *** (:) though, isn't that cuter?
07:46:15 <DRMacIver> :t ((.) . (,))
07:46:17 <lambdabot> forall b a a1. a1 -> (a -> b) -> a -> (a1, b)
07:46:44 <oerjan> @let ((+) `on` f) x y = f x + f y
07:46:51 <lambdabot> Defined.
07:47:13 <int-e> @pl \(a,b) (as,bs) -> (a:as, b:bs)
07:47:14 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (:)) . flip . (((.) . (,)) .) . (:))
07:47:41 <LoganCapaldo> @ty on
07:47:43 <lambdabot> Not in scope: `on'
07:47:47 <LoganCapaldo> @ty L.on
07:47:49 <lambdabot> Couldn't find qualified module.
07:47:54 <oerjan> > uncurry ((***) `on` (:)) ('a','b') ("foo","bar")
07:47:56 <lambdabot>  ("afoo","bbar")
07:48:15 <Botje> nice!
07:49:44 <int-e> @djinn (a -> b -> c) -> (d -> e -> f) -> (a, d) -> (b, e) -> (c, f)
07:49:45 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
07:50:12 <int-e> @pl f a b (c, d) (e, f) = (a c e, b d f)
07:50:15 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
07:50:27 <EvilTerran> hm. (on) is the (->) instance of (join)?
07:50:39 <oerjan> is it?
07:50:48 <int-e> @type Data.Function.on
07:50:50 <lambdabot> Couldn't find qualified module.
07:51:04 <oerjan> i don't think so
07:51:07 <EvilTerran> "Data.Function"? wouldn't "Control.Function" make more sense?
07:51:41 <int-e> on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:51:44 * shapr yawns
07:51:45 <LoganCapaldo> "Data.List"? wouldn't "Control.List" make more sense?
07:51:53 <LoganCapaldo> it works everywhich way!!
07:51:56 <LoganCapaldo> bwahahahahahahhahaa
07:52:00 <EvilTerran> . . .
07:52:24 <rhz> how does one uninstall ghc 6.6 on Mac os x so as to install ghc 6.6.1 in its place?
07:52:45 <puusorsa> port install ghc ?
07:52:46 <sysfault> haskell is interesting, although its syntactical structure frightens and perplexes the unfamiliar eye.
07:53:08 <puusorsa> or was it port install ghc-dev or something
07:53:25 <rhz> well I wanted to install the binary distribution
07:53:48 <oerjan> sysfault: don't be frightened by our obfuscated one-liners, they're not exactly production code!
07:53:52 <rhz> so I didn't have to wait hours and hours for it to build
07:54:07 <puusorsa> doesn't take hours on 1ghz g4
07:54:28 <rhz> really? how long does it take then?
07:54:47 <sysfault> oerjan: heh
07:54:50 <puusorsa> about one hour i think or a bit less
07:55:41 <rhz> hmm. but that still leaves the problem of wanting to remove the ghc i have installed in /usr/local right now.
07:55:42 <puusorsa> if isntalling the binaries requires thinking and effort and so on, port install could very possibly be faster and at least easier
07:55:58 <puusorsa> it's not like YOU have to compile it, the computer does it for you :)
07:56:28 <__nasa__> puusorsa: how much RAM? I spent 8 hours compiling on my 512MB RAM 800 Mhz powerbook, and 1.5+ hours compiling on my 2GB 2Ghz Macbook.
07:56:53 <puusorsa> 512
07:56:55 <xerox> 14mins on my macbook pro :)
07:56:58 <geezusfreeek> *eight* hours???
07:57:01 <int-e> puusorsa: also keep in mind that you need a working ghc to compile ghc
07:57:03 * EvilTerran envisages someone sitting on the floor of his office surrounded by flowcharts and tables, writing down hex codes on a bit of paper
07:57:07 <__nasa__> yeah, it was a long time.
07:57:40 <__nasa__> Oh, and I had to do it twice -- I didn't realize MacPorts isn't happy when you compile outside of it's system :-(
07:57:42 <puusorsa> hm actually i lied. just remembered i'm using distcc and x86 gentoo on 2.66ghz p4 to crosscompile
07:57:52 <geezusfreeek> even my 1.33 GHz powerbook only took a couple hours
07:57:54 <__nasa__> :-) that's more like it.
07:57:59 <geezusfreeek> 768MB ram
07:58:26 <oerjan> EvilTerran: wouldn't that be what they did in the 50's or so?
07:58:26 <__nasa__> Maybe that included the MacPorts dependencies.
07:58:50 <puusorsa> anyway it still shouldnt be hours, just one or two
07:58:56 <rhz> Yeah. I suppose Macports might be a good alternative
07:58:57 <EvilTerran> oerjan, perhaps. i was thinking of "<puusorsa> it's not like YOU have to compile it, the computer does it for you :)", tho...
07:59:05 <rhz> i'll have to remove the old version by hand i suppose
07:59:08 <oerjan> i got that :)
07:59:14 <__nasa__> I was running Rosetta@home in the background...
07:59:23 <puusorsa> rhz, or just make sure the new one is first in path
07:59:26 <__nasa__> That is the real culprit, now that I remember it.
07:59:57 <puusorsa> btw, this is really useful: http://biolpc22.york.ac.uk/pub/linux-mac-cross/
07:59:59 <lambdabot> Title: Index of /pub/linux-mac-cross
08:00:50 <puusorsa> had to search for a few hours until i found that and got compiling on x86 linux for ppc osx working. (sorry for the offtopic i'll just stop here)
08:01:28 * geezusfreeek wonders what the popularity would be of a content in which players race to compile a particular chunk of code... by hand
08:01:35 <geezusfreeek> *contest
08:01:50 <Philippa> hard to organise
08:02:02 <LoganCapaldo> wow
08:02:08 <puusorsa> geezusfreeek, on punch cards
08:02:08 <LoganCapaldo> that sounds bizzarely like fun
08:02:12 <Philippa> you pretty much have to get a bunch of people together physically to prevent cheating of various sorts
08:02:15 <__nasa__> What optimize flag? -OCarpalTunnel?
08:02:22 <geezusfreeek> points would go to the fastest to completion and to the fastest execution
08:02:30 <earthy> uhuh.
08:02:31 <geezusfreeek> yeah
08:02:36 <__nasa__> yeah, that would be cool.
08:02:46 <earthy> sounds like something that might actually be useful in the context of a compiler construction class
08:02:57 <Philippa> yeah
08:03:10 <Philippa> or even somewhat earlier in an assembly/machine architecture one, with much simpler tasks
08:03:16 * earthy nods
08:03:23 <earthy> 'build a while loop'
08:03:37 <Philippa> you'd have to have well-defined correctness criteria though
08:03:42 <__nasa__> and the world championships -- compile Mozilla!
08:03:47 <earthy> now, why does this all sound very familiar. oh yeah... we did that, more or less. :)
08:03:48 <geezusfreeek> LOL
08:03:58 <geezusfreeek> the linux kernel
08:04:10 <earthy> nah. not interesting.
08:04:13 <__nasa__> no, that has problems
08:04:13 <geezusfreeek> i actually didn't mean to do that in all caps
08:04:33 <geezusfreeek> i guess so
08:04:35 <__nasa__> yeah, how to talk to hardware it annoying, Mozilla is just software (mostly)
08:04:40 <earthy> compiling a compiler for the language you're compiling, that'd be fun
08:04:57 <earthy> (and instructional)
08:05:01 <Philippa> mmm, or an interpreter. FORTH?
08:05:03 <geezusfreeek> so compile gcc?
08:05:05 * earthy nods
08:05:15 <puusorsa> btw, punchcard reader/writer with usb connection would be Real Cool (and useful!)
08:05:19 <geezusfreeek> forth would be seriously good
08:05:27 <geezusfreeek> woah yes
08:05:28 <__nasa__> I wrote a (limited, very much so) dialect of forth a few days/weeks ago.
08:05:31 <earthy> somehow I think geezusfreeek has never compiled much code by hand
08:06:02 <geezusfreeek> earthy, very little, only small bits for various classes... but i don't know if you're detecting my sarcasm, either
08:06:07 <__nasa__> 206 lines of C as of now. That is doable...
08:06:17 <earthy> what sarcasm? :)
08:07:14 <geezusfreeek> i've written a very small bit of machine code and only few thousand lines of assembly code
08:07:43 <__nasa__> what architecture would we compile for? I am much more comfortable with MIPS, PIC, AVR small RISC than SISC or this DEC Alpha "RISC".
08:07:49 <Philippa> the one that'd be fun but cruel for a contest like that is hand-compiling 10-20 lines of interesting haskell
08:08:00 <__nasa__> s/SISC/CISC
08:08:05 <geezusfreeek> Philippa, only if it exploits laziness in some way :)
08:08:20 <geezusfreeek> MIPS or ARM would be pretty nice
08:08:32 <Philippa> geezusfreeek: not true - noticing that it didn't would be a big deal for fast execution
08:08:37 <__nasa__> Philippa: would it have to be standards compliant?
08:09:22 <Philippa> __nasa__: interesting question. It should be clear what the operational behaviour is, at least - and tell people at the start that it typechecks
08:09:32 <Philippa> probably only fair to not do anything too horrible with type classes
08:09:41 <Philippa> (but polymorphic recursion and GADTs can be enough fun)
08:09:50 <__nasa__> that could work.
08:12:41 <EvilTerran> > [n^2 + n + 41 | n <- [0..]]
08:12:42 <lambdabot>  [41,43,47,53,61,71,83,97,113,131,151,173,197,223,251,281,313,347,383,421,461...
08:13:05 <shapr> @yow !
08:13:05 <lambdabot> Like I always say -- nothing can beat the BRATWURST here in DUSSELDORF!!
08:15:52 <EvilTerran> > [pfs $ n^2 + n + 41 | n <- [0..]]
08:15:54 <lambdabot>  [[41],[43],[47],[53],[61],[71],[83],[97],[113],[131],[151],[173],[197],[223]...
08:16:24 <EvilTerran> > pfs $ 2^3*3^2
08:16:25 <lambdabot>  [2,2,2,3,3]
08:16:34 <oerjan> :t pfs
08:16:36 <lambdabot> Not in scope: `pfs'
08:16:57 <EvilTerran> pfs = pfsIn [2..] where pfsIn _ 1 = []; pfsIn (i:is) n | n `mod` i == 0 = i : pfsIn (i:is) (n `div` i) | otherwise = pfsIn is n
08:17:21 <oerjan> > print () >> return pfs
08:17:23 <lambdabot>  <IO (Integer -> [Integer])>
08:17:43 <roconnor> @go 30 oz in grams
08:17:44 <lambdabot> 30 ounces = 850.485694 grams
08:18:02 <__nasa__> > filter (\x -> length x > 1) [pfs $ n^2 + n + 41 | n <- [0..]]
08:18:06 <lambdabot> Terminated
08:19:28 <oerjan> > take 3 $ filter (\x -> length x > 1) [pfs $ n^2 + n + 41 | n <- [0..]]
08:19:30 <lambdabot>  [[41,41],[41,43],[43,47]]
08:19:38 <__nasa__> yeah
08:19:57 <__nasa__> > take 3 $ filter (\x -> length x > 2) [pfs $ n^2 + n + 41 | n <- [0..]]
08:20:01 <lambdabot> Terminated
08:20:12 <__nasa__> hmm, all semiprimes...
08:20:25 <oerjan> > take 1 $ filter (\x -> length x > 2) [pfs $ n^2 + n + 41 | n <- [0..]]
08:20:29 <lambdabot>  [[47,53,71]]
08:20:34 <__nasa__> or not...
08:20:50 <__nasa__> > take 2 $ filter (\x -> length x > 2) [pfs $ n^2 + n + 41 | n <- [0..]]
08:20:55 <lambdabot> Terminated
08:21:16 <earthy> lambdabot *does* work in messages...
08:33:17 <nomeata> brr, I hate it. re-building the thing that just worked (now in a clean environment) gives me:
08:33:19 <nomeata> /usr/bin/ghc +RTS -RTS -split-objs -c glib/System/Glib/GList.hs -o glib/System/Glib/GList.o -O -fffi -iglib -package-conf package.conf.inplace -hide-all-packages -ignore-package glib -package base -package-name glib-0.9.12 '-#include<glib-object.h>' -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include
08:33:20 <nomeata> glib/System/Glib/GList_split/.o::GList(void):(.data+0x0): multiple definition of `glibzm0zi9zi12_SystemziGlibziGList_polyzumakeList_closure'
08:33:20 <nomeata> glib/System/Glib/GList_split/GList__1.o:(.data+0x0): first defined here
08:33:44 <nomeata> and a bunch of similar errors.
08:33:52 <nomeata> dcoutts, help :-)
08:34:19 <dcoutts> nomeata: using gcc-4.2 ?
08:34:36 <mux> hmmm, gcc 4.2
08:35:27 <nomeata> dcoutts: ah, yes, the changeroot contains gcc-4.2.
08:35:38 <nomeata> dcoutts: is that a problem? :-)
08:35:57 <dcoutts> nomeata: http://hackage.haskell.org/trac/ghc/ticket/1427
08:36:16 <dcoutts> nomeata: workaround for both ghc and gtk2hs is to not use split-objs, or to patch ghc
08:36:37 <nomeata> is not using split-objs a bad idea?
08:36:48 <mux> you'll just have bigger executables
08:36:51 <dcoutts> it makes binaries huge if you don't use it
08:37:20 <mux> dcoutts: hya, how are you doing?
08:37:22 <dcoutts> so the right fix is to patch ghc to pass -fno-toplevel-reorder rather than -fno-unit-at-a-time to gcc
08:37:28 <dcoutts> mux: ok thanks :-)
08:37:51 <dcoutts> mux: lots of last minute cabal & bytestring work before ghc-6.8 fork :-)
08:37:53 <mux> nomeata: I hope you have at least gcc 4.2.1; 4.2.0 had some annoying bugs
08:37:59 <mux> dcoutts: yay, sounds good :-)
08:38:05 <earthy> 6.8 sounds great ;)
08:38:07 <nomeata> gcc (GCC) 4.2.1 (Debian 4.2.1-3)
08:38:17 <dcoutts> nomeata: the temporary workaround is to configure gtk2hs with --disable-split-objs
08:38:39 <__nasa__> Can I make custom "deriving" clauses?
08:38:57 <nomeata> dcoutts: can’t I patch the makefile to use -fno-toplevel-reorder? I could not find  -fno-unit-at-a-time anywhere, though.
08:39:26 <dcoutts> nomeata: you can't patch gtk2hs to do that, because we're not passing -fno-unit-at-a-time, that's ghc that's doing that
08:39:37 <dcoutts> and adding -fno-unit-at-a-time in addition to -fno-unit-at-a-time does not work
08:39:41 <dcoutts> erm
08:39:49 <dcoutts> using -fno-unit-at-a-time and -fno-toplevel-reorder
08:39:51 <nomeata> dcoutts: oh, ok. so the problem will go away as soon as ghc in debian knows about this
08:39:55 <dcoutts> nomeata: yes
08:40:04 <nomeata> so I guess best is to force gcc-4.1 for now
08:40:06 <dcoutts> nomeata: but I've not heard of anyone backporting the fix
08:44:23 <dolio> @remember JonHarrop The critical difference is, of course, that F# is designed to run under Windows and OCaml is designed to run under Unix.
08:44:23 <lambdabot> Done.
08:47:48 <Saul_> @src concat
08:47:49 <lambdabot> concat = foldr (++) []
08:48:16 <Saul_> @src sequence
08:48:17 <lambdabot> sequence ms = foldr k (return []) ms
08:48:17 <lambdabot>     where
08:48:17 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:48:59 <oerjan> @src liftM2
08:48:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:50:02 <__nasa__> is there a non-goa equivalent to @src?
08:50:25 <oerjan> in hugs there's :f
08:50:47 <__nasa__> ok
08:50:50 <__nasa__> thakes
08:51:22 <oerjan> also :i gives some information in both ghc and hugs, i think
08:51:35 <oerjan> (but not the entire source)
08:52:09 <__nasa__> :i sequence
08:52:31 <__nasa__> it works on my GHC, but not much more than :t
08:52:49 <__nasa__> it does say "defined in Control.Monad", which is nice.
08:53:33 <oerjan> classes and types may give more
08:53:33 <mux> :i has some nice pretty-printing features :)
08:54:05 <roconnor> > (log 24)/(log 55)
08:54:07 <lambdabot>  0.793059544452025
08:54:15 <roconnor> > (logBase 2 24)/(logBase 2 55)
08:54:16 <lambdabot>  0.7930595444520251
08:54:22 <roconnor> > (logBase 33 24)/(logBase 33 55)
08:54:24 <lambdabot>  0.793059544452025
08:54:38 <oerjan> i think ghc may not actually _have_ the source for most modules
08:55:08 <oerjan> hugs is essentially an interpreter, so it does
08:56:28 <__nasa__> yeah, it gives all the methods and instances for classes
08:56:43 <__nasa__> and the definition and instances for types.
08:56:47 <oerjan> logBase m n = logBase k n / logBase k m, which explains the rest
08:57:20 <oerjan> > logBase 55 24
08:57:22 <lambdabot>  0.793059544452025
08:57:27 <__nasa__> but no source...
08:57:53 <oerjan> @docs
08:57:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:58:16 <oerjan> if you look there, you can find a link to each module's source at the top of its page
08:58:47 <Choko> I have a infinite list of primes, is there a way to make them to a list of tuples (n1,n2),(n2,n3),(n3,n4),....
08:58:59 <__nasa__> thanks!
08:59:01 <Choko> easy way i should mention!
08:59:42 <oerjan> nothing builtin that's really easier than a straight recursion
09:00:06 <oerjan> f (p1:p2:ps) = (p1,p2):f ps
09:00:31 <Choko> jearh
09:00:35 <nomeata> how can I make the ghc2hs reliably use a given version of gcc?
09:00:41 <Choko> p2:ps i will call it on!
09:00:47 <Choko> thanks
09:01:06 <oerjan> oh, you want _all_ neigboring pairs?
09:01:49 <ddarius> > let xs = [1..] in zip xs (tail xs)
09:01:49 <Choko> jearh
09:01:51 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
09:01:57 <nomeata> it seems that setting CC when running configure && make does not help
09:02:20 <Choko> great
09:03:00 <ddarius> @pl \xs -> zip xs (tail xs)
09:03:00 <lambdabot> ap zip tail
09:03:28 <quicksilver> I prefer to call that: zip`ap`tail
09:03:46 <quicksilver> it's the name of an inca god
09:04:00 <quicksilver> zip`ap`tail, god of the fibonacci sequence
09:04:23 <quicksilver> > zip`ap`tail$ [1..]
09:04:25 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
09:05:20 <ddarius> > let f = (0:) . (1:) . uncurry (+) . ap zip tail in fix f
09:05:20 <lambdabot>  Couldn't match expected type `(a, a)'
09:05:44 <nomeata> dcoutts: does the gtk2hs build use the gcc defined in CC?
09:06:27 <dcoutts> nomeata: hmm, we don't invoke gcc much, we go via ghc
09:06:32 <oerjan> i think you mean zipWith(+)`ap`tail, his elder son
09:06:49 <ddarius> :t (0:) . (1:) . uncurry (+) . ap zip tail
09:06:51 <lambdabot>     Couldn't match expected type `(a, a)'
09:06:51 <lambdabot>            against inferred type `[(a1, b)]'
09:07:10 <ddarius> > let f = (0:) . (1:) . map (uncurry (+)) . ap zip tail in fix f
09:07:11 <dcoutts> nomeata: we use ghc to compile .o files from .c files
09:07:11 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:07:28 <nomeata> dcoutts: and can ghc be told to use gcc-4.2?
09:07:34 <nomeata> eh, gcc-4.1
09:07:55 <dcoutts> nomeata: -pgm-c=gcc-4.1 or something like that, check the ghc user guide
09:07:59 <nomeata> ah, -pgmc gcc-4.1 I guess
09:08:04 <olsner> :t (0:) . (1:) . map (uncurry (+)) . ap zip tail
09:08:06 <lambdabot> forall b. (Num b) => [b] -> [b]
09:09:38 <nomeata> dcoutts: does this sound sane, passing to configure: --with-hcflags "-O -pgmc gcc-4.1"
09:09:38 <oerjan> > fix$(0:).(1:).(zipWith(+)`ap`tail)
09:09:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:09:50 <dcoutts> nomeata: yep
09:18:59 <idnar> @src fix
09:19:00 <lambdabot> fix f = let x = f x in x
09:21:51 <conal> i'm building ghc from sources (on windows, from darcs repo), which i haven't done in ages.   it's dying when compiling rts/Linker.c.  The problem seems to be that the C compiler isn't searching in my c:/cygwin/usr/include .  does anyone know how to point it there?
09:23:13 <shapr> hiya jewel, how's code?
09:23:32 <shapr> conal: Can you specify -L paths somewhere?
09:23:43 <shapr> Or is it -I that does include?
09:24:05 <conal> shapr: seems to be -I.  and i don't know in what config file to specify it.
09:24:20 <pippijn> hi all
09:24:20 <conal> nor in what variable
09:24:27 <conal> hi pippijn
09:24:45 <shapr> hoi pippijn, hoe gaat het?
09:24:58 <shapr> conal: What about fgrep -I **/*.mk ?
09:25:06 <pippijn> shapr: gaat wel, ik ben wat moe ;-)
09:25:14 <shapr> er "fgrep '-I' **/*.mk
09:25:18 <pippijn> shapr: en met jou?
09:25:22 <shapr> goed
09:25:29 <shapr> pippijn: Are you learning Haskell?
09:25:36 <pippijn> does anyone know of a document explaining Maybe and maybeM?
09:25:43 <conal> shapr: i'll give it a try.
09:25:46 <pippijn> I have a Maybe String that I want to print
09:25:59 <shapr> I can explain Maybe, it's just an explicit equivalent of a null pointer.
09:26:10 <pejo> shapr, isn't ** zsh specific?
09:26:19 <shapr> That is, Maybe String means that you can represent not having anything with Nothing.
09:26:26 <shapr> pejo: Yeah, it is, but it's the thought that counts!
09:26:27 <pippijn> shapr: I got that far
09:26:37 <pippijn> but how can I print the string if there is one
09:26:40 <conal> shapr: does "**" mean something in a file pattern, or did you stutter?
09:26:46 <pippijn> I had "maybeM (conffile) $ \np -> putStrLn np" but it was wrong
09:26:56 <shapr> conal: It means "find all files in this directory or below that end in .mk"
09:26:59 <shapr> That's **/*.mk
09:27:16 <shapr> pippijn: What about using fromMaybe?
09:27:20 <conal> shapr: that's very cool.  i wonder if bash has it.
09:27:34 <shapr> > fromMaybe "no conf file" (Just "conffile")
09:27:35 <lambdabot>  "conffile"
09:27:37 <pippijn> shapr: conffile = Settings . fromMaybe "config"
09:27:38 <shapr> > fromMaybe "no conf file" Nothing
09:27:39 <lambdabot>  "no conf file"
09:27:44 <oerjan> :t maybe
09:27:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:27:48 <pippijn> hmm
09:27:53 <oerjan> :t fromMaybe
09:27:55 <lambdabot> forall a. a -> Maybe a -> a
09:27:57 <shapr> conal: I don't think so. But if you try zsh, you may never go back.
09:28:14 <conal> shapr: now i'm intrigued!
09:28:40 <shapr> pippijn: fromMaybe takes a default value, a value that might exist, and returns either the value if it exists, or the default.
09:29:36 <oerjan> :t maybe (return ()) print
09:29:38 <lambdabot> forall a. (Show a) => Maybe a -> IO ()
09:29:43 <shapr> pippijn: What's maybeM?
09:29:49 <shapr> Is that a monadic maybe?
09:30:00 <shapr> conal: Want a copy of my zshrc?
09:30:10 <shapr> It's got some scary bits...
09:30:31 <conal> shapr: yeah -- please email it to me.
09:30:44 <shapr> name @ name . net, right?
09:31:20 <conal> i think i found the solution.  set the CPPFLAGS environment var, including "-I...".
09:31:32 <MyCatVerbs> fromMaybe x Nothing = x; fromMaybe _ (Just y) = y ?
09:32:10 <shapr> pippijn: Any other questions? Are you doing Haskell for business or pleasure?
09:32:25 <pippijn> shapr: pleasure
09:32:32 <shapr> Spiffy, how'd you find Haskell?
09:32:37 <ddarius> @. djinn type fromMaybe
09:32:40 <lambdabot> f a b =
09:32:40 <lambdabot>     case b of
09:32:40 <lambdabot>     Nothing -> a
09:32:40 <lambdabot>     Just c -> c
09:33:47 <shapr> conal: I never asked you that before, how'd you find Haskell? You've been doing Haskell way longer than me, right?
09:34:13 <hkBst> @src print
09:34:13 <lambdabot> print x = putStrLn (show x)
09:34:48 <quicksilver> @. djinn type maybe
09:34:50 <lambdabot> f a b c =
09:34:50 <lambdabot>     case c of
09:34:50 <lambdabot>     Nothing -> a
09:34:50 <lambdabot>     Just d -> b d
09:34:56 <quicksilver> very cute
09:34:58 <conal> shapr: pretty long time.  since 95 probably.  i've been into functional programming for a lot longer, though.  mainly ML and scheme before haskell.
09:35:04 <quicksilver> I'd not thought of using @. like that before
09:35:42 <shapr> conal: Wow, cool. I wish I'd found Haskell and FP earlier, but I'm glad I didn't find it any later.
09:35:42 <conal> i played with laziness in grad school & loved it.  and then i read john hughes' "why fp" paper and was totally sold.
09:35:57 <conal> shapr: how & when did you find it?
09:36:35 <shapr> I started writing Python with one single result call, and no side effects, and my friend Darius Bacon told me to look into Haskell. It was instant love!
09:36:45 <shapr> That was ... 2001 I think.
09:37:19 <shapr> I got onto #haskell about two weeks later, so the start date of #haskell is a good way to figure out when I started.
09:37:50 <ddarius> quicksilver: Of course, @src would work in most of these cases, but I like to drive home the fact that the type practically says it all. And sometimes @src doesn't work.
09:37:51 <chessguy> Hughes' "why fp" paper is great. i just recently ported his pseud-haskell to reall haskell
09:37:52 <conal> shapr: was the python functional programming style your own personal inclination?
09:38:11 <quicksilver> ddarius: yes, it's much cooler than @src :)
09:38:13 <chessguy> and then i learned to type...
09:38:19 <shapr> conal: Yeah, I picked up some of that from my minimal exposure to elisp, but most of it was just that I liked code better when done that way.
09:38:47 <quicksilver> most of the elisp I've seen is not remotely functional
09:38:49 <shapr> I had no idea that was called referential transparency, but I was so thrilled that someone else had been doing it first, and written lots about it!
09:39:07 <shapr> quicksilver: Yeah, but the 'result' is the last eval in the code.
09:39:18 <shapr> And I realized I wanted everything to be that way.
09:39:20 <quicksilver> shapr: *nods*
09:39:22 <ddarius> chessguy: Isn't it's "pseudo-Haskell" Miranda?
09:39:47 <conal> shapr: yeah -- there's an elegance to math & fp that resonates deeply in some of us.
09:39:55 <chessguy> ddarius, i wouldn't know
09:40:11 <shapr> conal: Yeah, it fits the way I think.
09:40:58 <chessguy> @bot
09:40:58 <lambdabot> :)
09:41:17 <|Jedai|> @. djinn type unfoldr
09:41:19 <lambdabot> -- f cannot be realized.
09:41:30 <conal> shapr: when language & thinking are in harmony, it's flow!  otherwise, stumble & stutter.  (as with non-judgment & nvc or judgment & our cultural language)
09:41:34 <jedai> @. djinn type foldl
09:41:36 <lambdabot> f _ a _ = a
09:42:29 <conal> shapr: that's why i think it sounds so awkward when people try to talk nvc while still thinking judgmentally.
09:42:32 <jedai> @. djinn type sum
09:42:59 <ddarius> djinn doesn't do recursive types, i.e. lists (at this point)
09:43:19 <ddarius> And it barely does type classes.
09:43:32 <jedai> ddarius: Ok, it looks interesting still ^^
09:43:45 <ari> @. djinn type fromJust
09:43:46 <ddarius> jedai: It's a small theorem prover.
09:43:47 <lambdabot> -- f cannot be realized.
09:43:51 <ari> ):
09:43:57 <ddarius> Damn right it can't be realized!
09:44:12 <shapr> conal: Yeah, I agree.
09:44:36 <conal> shapr: :)
09:44:55 <shapr> conal: But that sort of sounds like "You can talk to others about the thing if they already understand it."
09:45:00 <shapr> I'm not sure if that's true or not.
09:45:44 <oerjan> ari: it assumes there are no undefined values
09:46:19 <oerjan> otherwise the Curry-Howard logic correspondence it uses does not work
09:46:20 <ddarius> shapr: I would think that that is true, I think you mean it's contrapositive(?) isn't necessarily (?)
09:46:40 <ddarius> oerjan: Sure it works.
09:46:53 <conal> shapr: i like how Eckhart Toelle says all words & belief systems are pointers only.  if we are able to follow the pointer, then we get value from the words.  otherwise, just words.
09:47:21 <oerjan> well, it could always return undefined as the answer
09:50:34 <shapr> conal: Hah, that's cute.
09:50:42 <pippijn>     Couldn't match expected type `Maybe [Char]'
09:50:43 <pippijn> 	   against inferred type `Maybe String -> Flag'
09:51:11 <pippijn> this Maybe String is inside a Flag structure..
09:51:14 <shapr> ddarius: er, maybe it's contrapositive.
09:51:21 <oerjan> pippijn: you may be missing a function argument
09:51:30 <pippijn> cfg <- readTypedFile (fromMaybe "config" (conffile))
09:52:19 <sorear> .
09:52:26 <oerjan> what is the type of conffile?
09:52:51 <pippijn> it's part of flags which is [OptDescr Flag]
09:53:13 <pippijn> and Flag is a udt where the corresponding type is FilePath
09:53:20 <conal> shapr: also the saying "the tao that can be spoken is not the tao".  still, it's a pointer.  like haskell is not the tao of (functional) programming, but it sure points some of us there.
09:54:04 <pippijn> (I think what I'm saying is correct, but I am unsure)
09:54:16 <ari> "The second reason was that the development group had only made the transition from assembly language to Prolog within the past year or so, and the prospect of pulling the group through another paradigm shift made all the managers turn pale." -- Bill Wood on haskell-cafe
09:54:20 <pippijn> I started haskell an hour ago
09:54:44 <SamB> ari: that's a pretty strange transition!
09:54:54 <conal> pippijn:  have a blast!
09:55:03 <pippijn> conal: huh?
09:55:15 <shapr> conal: Yeah, I agree.
09:55:18 <conal> pippijn: have fun with haskell :)
09:55:20 <SamB> pippijn: with Haskell
09:55:27 <oerjan> pippijn: sounds like you are using System.Console.GetOpt
09:55:33 <pippijn> oerjan: indeed
09:55:36 <shapr> pippijn: Are you working on some source that we can see?
09:55:39 <shapr> hoi fasta!
09:55:43 <shapr> Hoe gaat het?
09:55:43 <pippijn> yes, sec
09:55:50 <shapr> @paste
09:55:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:56:01 <pippijn> http://pip.one09.net/files/up/Bot.hs
09:56:12 <fasta> shapr: with me fine, but my machine is a bit broken.
09:56:18 <fasta> shapr: or maybe it was.
09:56:22 <shapr> What happened?
09:56:23 <pippijn> (this is not my code, I'm just hacking on it, trying to change something I would like improved)
09:56:34 <ddarius> > fix$(0:).(1:).(zipWith(+)`ap`tail) -- have a fixpoint since dons is not here (this is the fixpoint for the day)
09:56:36 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:56:38 <fasta> shapr: it randomly shut down.
09:56:44 <SamB> pippijn: are you doing the "roll your own IRC bot" tutorial?
09:56:51 <fasta> shapr: it seems temperature related.
09:57:01 <pippijn> SamB: no, I'm modifying an existing bot
09:57:02 <shapr> fasta: Are you using lmsensors to keep track of it?
09:57:10 <fasta> shapr: yes, I installed that.
09:57:17 <shapr> pippijn: What are you trying to change?
09:57:18 <SamB> pippijn: that someone else wrote doing it?
09:57:27 <shapr> fasta: Does it help any?
09:57:28 <pippijn> SamB: I don't know :-)
09:57:30 <fasta> shapr:  but "keeping track" of it, no
09:57:50 <fasta> shapr: AFAIK, it's not a program that continually tracks it and produces graphs etc.
09:57:51 <SamB> I heard it was a popular tutorial
09:58:02 <fasta> shapr: nor do I know such a program.
09:58:05 <pippijn> shapr: I am trying to change the way command line arguments are passed and I am trying to make the config file a command line option
09:58:20 <fasta> shapr: it also switches the temperature of motherboard and CPU AFAIK
09:58:29 <SamB> fasta: gkrellm?
09:58:38 <pippijn> shapr: so I have this options structure out of which I get everything, but now I need to get the string out of conffile
09:58:38 <fasta> SamB: that uses mbmon
09:58:44 <fasta> SamB: which I also installed.
09:58:52 <fasta> SamB: but sometimes it fails
09:59:08 <SamB> fails?
09:59:20 <fasta> SamB: yes, something like "no sensors found"
09:59:25 <SamB> wierd
09:59:33 <fasta> SamB: while after a run of 5 it has found the sensor.
09:59:38 * SamB wonders if this motherboard has sensors
09:59:50 <fasta> Rather odd. One would expect that when hardware is broken it doesn't repair itself
10:00:02 <fasta> Well, I would expect that to happen in 60 years, though.
10:00:06 <fasta> But not today
10:00:22 <fasta> The NASA has repairable hardware today. :)
10:00:27 <pippijn> if anybody is looking at it, the line that I don't know how to get to work is line 126
10:00:30 <fasta> It only doesn't work that good ;)
10:01:05 <ddarius> NASA has plenty of self-repairing hardware, how well they work is questionable.
10:01:27 <fasta> Anyone using Shim here?
10:01:35 <fasta> http://shim.haskellco.de/trac/ <- 500 error
10:02:03 <Cale> pippijn: cfg <- readTypedFile (fromMaybe "config" (conffile))
10:02:06 <Cale> that one?
10:02:26 <pippijn> Cale: yes
10:02:46 <Cale> hmm, what is fromMaybe?
10:03:05 <pippijn> > fromMaybe "no conf file" (Just "conffile")
10:03:06 <lambdabot>  "conffile"
10:03:07 <pippijn> > fromMaybe "no conf file" Nothing
10:03:08 <ddarius> :t fromMaybe -- Cale?
10:03:09 <lambdabot>  "no conf file"
10:03:09 <sorear> @src fromMaybe
10:03:10 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
10:03:10 <lambdabot> forall a. a -> Maybe a -> a
10:03:11 <Cale> oh
10:03:14 <Cale> right
10:03:39 <fasta> shapr: do you know software that monitors hardware continuously?
10:03:45 <Cale> conffile :: Maybe String -> Flag
10:03:54 <oerjan> i think you need to pattern match for Settings somehow
10:04:26 <Cale> So it's not the right type for the second parameter of fromMaybe, which is supposed to be Maybe a for some type a
10:04:39 <oerjan> conffile is used only for building the option list, it's not useful for inspecting it
10:05:05 <pippijn> oerjan: how can I inspect it then?
10:05:10 <oerjan> it only makes a Flag with a Settings constructor
10:05:23 <oerjan> :t find
10:05:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:05:37 <Cale> oh, I see what it is that you're doing here
10:05:45 <Cale> Yeah, you want to look through the list of options
10:06:45 <oerjan> which seems to be in opts
10:06:47 <shapr> fasta: collectd?
10:07:07 <Cale> right
10:07:26 <balodja> Do functions like snd, fst, either, maybe etc evaluate thunks? Or they just become another thunk-layer?
10:08:06 <pippijn> I haven't found anything on that yet, I'll look further
10:08:44 <Cale> balodja: They become another layer until evaluated.
10:09:46 <fasta> shapr: seems fine, I will install it later. Thanks
10:09:59 <oerjan> listToMaybe . map (\o -> do Settings p <- Just o; return p) $ opts
10:11:01 <Cale> But fst x, for example, when evaluated, will evaluate x up to finding the pair constructor, and then return the first element of the pair (which will then be evaluated itself -- at least up to the top level constructor
10:11:03 <Cale> )
10:11:04 <oerjan> put that instead of conffile on that line
10:11:30 <oerjan> um wait
10:11:31 <ddarius> The question isn't well phrased.
10:12:09 <chessguy> terminology question. if you have data Tree a = Leaf a | Branch a (Tree a) (Tree a), what's the proper name for something like t :: Tree Int; t = Leaf 3
10:12:21 <chessguy> i want to call it an instance, but that's  my OO background talking
10:12:22 <oerjan> listToMaybe [p| Settings p <- opts]
10:12:39 <ddarius> chessguy: Most people here would call it a tree.
10:12:39 <fasta> chessguy: tree value?
10:12:45 <jedai> chessguy: a value of type Tree Int ?
10:12:45 <chessguy> well
10:12:48 <oerjan> much simpler
10:12:52 <ddarius> chessguy: The generic term would be value as fasta said.
10:12:52 <chessguy> sorry
10:12:53 <sorear> @seen ChilliX
10:12:53 <lambdabot> I saw ChilliX leaving #ghc and #haskell 5h 47m 22s ago, and .
10:13:03 <balodja> Cale: is there any way to tell compiler to partially evaluate lazy expressions? not totally, like ($!) and seq
10:13:10 <chessguy> i meant in general, if you have an 'instance' of an algebraic data type
10:13:25 <fasta> chessguy: value
10:13:27 <oerjan> pippijn: try listToMaybe [p | Settings p <- opts]
10:13:29 <jedai> chessguy: it's just a value
10:13:29 <Cale> balodja: only once the expression itself is being evaluated
10:13:33 <chessguy> ok
10:13:41 <pippijn> oerjan: what does that return?
10:13:49 <balodja> ok, great thanks
10:13:53 <jedai> chessguy: instance is for the algebraic type that instance a type class
10:13:54 <sorear> @tell ChilliX Minor notational discontinuity on page 3; you define data Z; data S a; but then use Succ and Zero
10:13:55 <lambdabot> Consider it noted.
10:13:57 <oerjan> it should return a Maybe String
10:14:11 <pippijn> okay
10:14:20 <pippijn> oerjan: yeah, it seems to work
10:14:22 <Cale> balodja: You can use seq to ensure that things are evaluated early, as you mentioned
10:14:32 <chessguy> oh, i know what a type class instance is
10:14:32 <ddarius> balodja: How do you "partially evaluate" an expression and how is seq not "partially evaluating" it?
10:15:05 <fasta> Cale: what's the part of seq that "throws away the result"?
10:15:19 <Cale> balodja: seq will cause evaluation to occur only up to the top-level constructor, which is almost the least amount of evaluation which you could conceive of wanting.
10:15:32 <pippijn> oerjan: thanks
10:15:56 <oerjan> you're welcome :)
10:15:56 <pippijn> okay, it doesn't work exactly the way I wanted it yet, but I'll look at it later
10:16:06 <balodja> ddarius: Something, that will be identical to pattern matching
10:16:16 <Cale> balodja: that's seq
10:16:21 <nomeata> dcoutts: I install /usr/lib/haskell-packages/ghc6/lib/gtk-0.9.12/HSgtk.o now, but I get:
10:16:23 <nomeata> Reading package info from "/usr/lib/haskell-packages/ghc6/lib/gtk-0.9.12/gtk.package.conf" ... done.
10:16:23 <nomeata> warning: can't find GHCi lib HSgtk.o
10:16:25 <balodja> Hm-m-m
10:16:47 <balodja> Good.
10:17:12 <fasta> nomeata: do you get actual problems resulting from this?
10:17:19 <Cale> balodja: seq is (in most cases) equivalent to a single pattern match, for example, on lists,  seq x y  is rather like  case x of [] -> y; _ -> y
10:17:31 <dcoutts> nomeata: odd, what does the gtk.package.conf say?
10:17:46 <Cale> (in fact, it's exactly equivalent to that)
10:17:49 <nomeata> fasta: yes, ghci does not seem to work
10:18:04 <balodja> > seq [undefined] "good"
10:18:09 <lambdabot>  "good"
10:18:14 <balodja> Cale: GOOD! :)
10:18:19 <Cale> The only thing which you can do with seq and can't do with a pattern match is to evaluate functions.
10:18:35 <ddarius> Cale: And other abstract data types.
10:18:53 <hpaste>  nomeata pasted "package.conf" at http://hpaste.org/2559
10:18:55 <Cale> Yeah, types where you have no access to the constructors.
10:19:38 <nomeata> strange. the deb contains the file, but after installation it is gone − maybe ghc-pkg register removes it for some reason?
10:20:10 <balodja> So, 'c = snd (a, b); seq c id;' will get expression 'c' evaluated to 'b'? That's fantastic.
10:21:00 <oerjan> and also b evaluated
10:21:01 <nomeata> nevermind, my bad
10:21:11 <nomeata> I delete the file in prerm, leftover from before.
10:21:19 <nomeata> (And another build to be triggered...)
10:21:59 <nomeata> hmm. why does it not clean gconf/System/Gnome/GConf/GConfClient_stub.o: properly... /me investigates
10:22:53 <balodja> Cale: And, as I see, 'seq (seq a) b' is not really equal to 'seq a b'. That's true?
10:23:16 <ddarius> balodja: No, it is not.
10:23:20 <ddarius> (not true that is)
10:23:25 <balodja> :(
10:23:28 <Cale> They're not the same at all
10:23:53 <oerjan> well, seq a is not applied enough there...
10:23:55 <ddarius> Er, I think balodja meant seq a to be applied to two things.
10:24:05 <Cale> seq (seq a) b will evaluate (seq a) before resulting in b, which, since it's clearly not undefined, will simply result in b without touching a
10:24:34 <ddarius> Probably (id $! a) was the intent
10:26:34 <balodja> Oh, I meant 'seq (seq a a) b'
10:26:46 <Cale> seq x x = x
10:27:17 <ddarius> Cale, balodja: As I said, id $! a is probably what is meant.
10:27:20 <Cale> (for any x)
10:27:33 <ddarius> @src ($!)
10:27:33 <lambdabot> Source not found. You type like i drive.
10:27:35 <oerjan> seq is actually associative...
10:28:26 <oerjan> id $! a = a `seq` id a = a
10:29:29 <Cale> It's important to note that  (seq x y)  is an expression which *when evaluated* will ensure that x is evaluated to its top-level constructor before resulting in y.
10:29:39 <ddarius> oerjan: Yes. hence me saying that seq (seq a) b not really being equal to seq a b is false.
10:29:47 <Cale> It doesn't magically cause evaluation to occur any earlier than that.
10:30:10 <Cale> ddarius: hm?
10:30:26 <Cale> ddarius: you mean seq (seq a a) b ?
10:30:49 <ddarius> Cale: I was quoting the original statement, but using the interpreted meaning.
10:31:10 <Cale> > seq (seq undefined) "Hello"
10:31:12 <lambdabot>  "Hello"
10:31:17 <Cale> > seq undefined "Hello"
10:31:19 <lambdabot>  Undefined
10:31:19 <ddarius> seq (seq a) b does not equal seq a b of course
10:31:24 <Cale> right
10:31:38 <ddarius> Cale: As I said, I was using the meaning I believed was intended.
10:32:21 <Cale> Of course, it's just that the actual meaning gives the opposite answer :)
10:33:03 <alexeevg> @seen sjanssen
10:33:04 <lambdabot> I saw sjanssen leaving #happs, #gentoo-haskell, #haskell-overflow, #xmonad and #haskell 8h 23m 23s ago, and .
10:33:12 <nomeata> dcoutts: there was a small typo in your clean patch: in the definition of gconf_MOSTLYCLEANFILES you added the file twice as _stub.h, instead of once as _stub.h and once as _stub.o files
10:33:54 <dcoutts> nomeata: oh, oops
10:34:21 <nomeata> dcoutts: (just in case you have applied the same patch in your tree as well...)
10:34:30 <dcoutts> nomeata: I did
10:35:02 <sorear> @tell ChilliX Page 13; your composition rule is printed twice, sym has the wrong rule, REFL and COMP are not listed, and TRANS appears to be backward
10:35:02 <lambdabot> Consider it noted.
10:35:05 <phobes> Is there a StateMonad (or MonadState) class?
10:35:21 <chessguy> @hoogle MonadState
10:35:22 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
10:35:35 <phobes> thanks
10:35:44 <fasta> So "submitValue" is evil. ;)
10:35:59 <fasta> collectd coding guide lines.
10:36:05 <chessguy> so, i'd like to write an algebraic type such that there is a value of the type which represents a standard alpha-beta algorithm. suggestions?
10:36:34 <dcoutts> nomeata: thanks. fixed in my tree(s) now
10:36:50 <ddarius> data Search = AlphaBeta
10:37:05 <ddarius> chessguy: What do you mean by "represents"?
10:38:10 <fasta> He wants to reify the steps you take in an alpha-beta algorithm
10:38:11 <chessguy> ddarius, so the ADT would serve as a sort of language in which you could write similar search algorithms but with variations
10:38:27 <phobes> Should (ListT m) really be an instance of MonadState?
10:38:56 <fasta> phobes: easy question: why shouldn't it?
10:39:20 <phobes> It seems like you'd want MonadState to have an invariant that a put followed by a get returns the value just put
10:39:38 <GyroL> Is there a function from [m a] to m [a] ?
10:39:48 <chessguy> @type sequence
10:39:50 <ddarius> @hoogle [m a] -> m [a]
10:39:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:39:54 <lambdabot> Prelude.head :: [a] -> a
10:39:54 <lambdabot> Prelude.last :: [a] -> a
10:39:54 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
10:40:03 <ddarius> @hoogle Monad m => [m a] -> m [a]
10:40:04 <lambdabot> Prelude.head :: [a] -> a
10:40:04 <lambdabot> Prelude.last :: [a] -> a
10:40:09 * ddarius smacks hoogle.
10:40:31 <LoganCapaldo> GyroL, yes, it's named sequence :)
10:40:57 <chessguy> @src sequence
10:40:57 <lambdabot> sequence ms = foldr k (return []) ms
10:40:57 <lambdabot>     where
10:40:57 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
10:41:09 <GyroL> LoganCapaldo, chessguy: ok thanx.
10:41:46 <chessguy> so anyway, i think fasta has it right, if i understand reification correctly
10:42:10 <chessguy> is it even possible?
10:42:16 <fasta> chessguy: it's just a fancy word for putting the stuff you want the user todo to put in a data structure.
10:42:24 <fasta> to do, even
10:42:46 <phobes> What's the command to show the instance for MonadState s (ListT m)?
10:42:59 <fasta> phobes: you mean the source?
10:43:01 <phobes> ya
10:43:02 * nomeata hopes that this is really going to be the last build run for the debian package upload.
10:43:07 <fasta> phobes: in ghci?
10:43:08 <fasta> phobes: none
10:43:09 <phobes> ya
10:43:11 <phobes> grr
10:43:12 <fasta> phobes: here, no idea
10:43:21 <fasta> phobes: just download ghc and use find
10:43:24 <phobes> ok
10:43:56 <sjanssen> phobes: :info can tell you where instances are defined
10:43:56 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
10:43:57 <fasta> I think Linux search tools are pretty bad, though.
10:44:13 <fasta> They either are way too active or too inactive.
10:45:15 <hkBst> @pl divides dividend divisor = dividend `mod` divisor == 0
10:45:16 <lambdabot> divides = flip flip 0 . ((==) .) . mod
10:46:05 <oerjan> eek
10:46:14 <oerjan> @slap @pl
10:46:14 * lambdabot beats up @pl
10:46:29 <ivant> @pl \a b -> f (g a b)
10:46:30 <lambdabot> (f .) . g
10:46:40 <ari> We should have a contest on who can produce the greatest @pl code blowup ratio
10:46:42 <ddarius> chessguy: Uh, represent the "source code" for a "language" that you will interpret to perform the alpha-beta search.
10:46:48 <ivant> hkBst, divides = ((==0) .)  . mod
10:47:01 <ddarius> ari: No we shouldn't and there are already plenty of readily available candidates.
10:47:19 <ari> ):
10:47:30 <hkBst> ivant: ah, that's what the fuss is about :)
10:48:12 <ivant> > let divides = ((==0) .)  . mod in 12 `divides` 5
10:48:14 <lambdabot>  False
10:48:19 <ivant> > let divides = ((==0) .)  . mod in 12 `divides` 4
10:48:21 <lambdabot>  True
10:48:54 <oerjan> hm, the mathematical usage is the other way around
10:50:02 <oerjan> (divisor means "something which divides")
10:50:06 <jbauman> > let divides = flip $ ((==0) .)  . mod in 4 `divides` 12
10:50:07 <lambdabot>  True
10:50:19 <sorear> @tell kfish No need to use a class for rot, twist, and flip (and if you do, no need for a where-clause)
10:50:20 <lambdabot> Consider it noted.
10:51:10 <jbauman> > let divides = ((==0) .)  . flip mod in 4 `divides` 12 -- better
10:51:11 <lambdabot>  True
10:55:11 <conal> otoh, "divides 4" is a little misleading.  i think infix & prefix push for different arg order.
10:56:02 <EvilTerran> indeed
10:56:20 * EvilTerran writes (x `mod`) rather than (mod x), for that reason
10:56:35 <ddarius> > let (|) = ((==0) .) . flip mod in 4 | 12 -- if only
10:56:35 <lambdabot>  Parse error
10:56:54 <EvilTerran> | is a special token, i think
10:57:05 <EvilTerran> reserved token, rather
10:57:06 <ddarius> EvilTerran: Of course.
10:57:48 <ddarius> If we tried to define a (|) function infix it would be clear that it's not sensible x | y = ...
10:57:51 <EvilTerran> what about (/?)?
10:58:10 <ddarius> EvilTerran: Not bad.
10:58:26 <EvilTerran> although then i do start wondering about the argument order again
10:58:48 <EvilTerran> seeing as "x /? y" looks like "does x/y work?"
10:58:53 <ddarius> True.
10:59:09 <ddarius> Perhaps that argument order should be the intended one for that operator.
11:00:17 <conal> my ghc build is dying due to this line in a .h file, which the c compiler thinks has an unterminated char constant:       #error Don't know what sort of Windows system this is
11:00:41 <conal> does anyone know how to tell the c compiler not to fret about the apostrophe?
11:00:55 <olsner> remove the apostrophe ;-)
11:01:05 <sorear> > let x ∣ y = x `mod` y == 0 in 4 ∣ 12
11:01:05 <lambdabot>  Illegal character ''\136''
11:01:08 <sorear> @type let x ∣ y = x `mod` y == 0 in 4 ∣ 12
11:01:10 <lambdabot> lexical error at character '\136'
11:01:14 <conal> olsner: yeah -- i thought of that. it'll bite me again, though.
11:01:31 <conal> thanks, though ;)
11:01:41 <olsner> I don't know precisely what the standard says about this, but that code relies on the compiler not to tokenize ifdef:ed parts of the source.. and that's definitely ugly
11:01:47 <ddarius> sorear: That's not right.
11:07:04 <__nasa__> Is there a non-blocking Graphics.HGL.getKey?
11:08:10 <hpaste>  hkBst pasted "No instance for (Fractional Integer)??" at http://hpaste.org/2560
11:08:25 <conal> __nasa__: what's HGL.getKey ?
11:09:15 <__nasa__> It lets one get key presses in a window.
11:09:23 <conal> hkBst: it's the num/divisor
11:09:28 <oerjan> hkBst: use `div` instead of /
11:09:48 <__nasa__> namely, getKey w returns a Key object once a key has been pressed and released.
11:10:24 <hkBst> oerjan: div does integral division?
11:10:35 <oerjan> yes
11:10:38 <conal> __nasa__: oh, thanks.  you probably want an event-callback sort of thing instead.
11:10:44 <__nasa__> yeah, exactly.
11:11:02 <conal> __nasa__: are you using a GUI package?
11:11:03 <__nasa__> I just didn't see them in the HGL docs
11:11:10 <__nasa__> yeah, HGL.
11:11:19 <__nasa__> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL.html
11:11:21 <lambdabot> http://tinyurl.com/34ulos
11:11:53 <oerjan> "getKey is defined using getWindowEvent, which waits for a range of user interface events."
11:12:33 <oerjan> __nasa__: maybeGetWindowEvent
11:12:57 <conal> oerjan: where's that?
11:13:11 <__nasa__> @hoogle maybeGetWindowEvent
11:13:12 <lambdabot> No matches found
11:13:15 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL-Window.html#v%3AgetWindowEvent
11:13:17 <lambdabot> http://tinyurl.com/282tzj
11:13:27 <oerjan> just below
11:13:37 <conal> oerjan: thanks.
11:13:39 <__nasa__> yup. Thanks oerjak!
11:13:53 <__nasa__> s/oerjak/oerjan :-(
11:16:18 <conal> __nasa__: it looks like HGL has some very simple GUI stuff.  if it's not enough, there are alternatives, such as gtk2hs & wxHaskell.  i'm working on some related, higher-level libraries also.  see http://haskell.org/haskellwiki/User:Conal .
11:16:22 <lambdabot> Title: User:Conal - HaskellWiki
11:16:39 <chessguy> ddarius, i have a feeling this is going to turn into a full turing-complete "language"
11:16:56 <ddarius> chessguy: It depends on what kinds of variations you want to support.
11:18:16 <__nasa__> I have looked at gtk2hs, conal. This program is not really a GUI (I am just using the keypress to close the window), so I don't really need gtk2hs or wxHaskell.
11:18:31 <hkBst> could someone look at the ``primes'' definition in my paste http://hpaste.org/2560 . It overflows the stack if I do  ``take 2 primes''
11:18:40 <conal> __nasa__: oh, great.  nice & simple.
11:20:42 <oerjan> hkBst: your sieve function never returns
11:20:51 <ddarius> What oerjan said.
11:21:27 <MyCatVerbs> Why is Data.Graph considered evil, anyway?
11:21:39 * chessguy comes to the same conclusion but decides not to say so since it would be horribly redundant and repetitive to say it again since it's already been said
11:24:02 <oerjan> more precisely, you nead head l : or similar
11:24:50 <oerjan> (and it would be nicer to use a pattern match instead of head and tail)
11:25:10 <oerjan> *need
11:28:07 <hkBst> right, thanks for your comments oerjan :)
11:34:33 <asl> hey there, I have a question about using the State monad.  Well, maybe not a question, but a situation
11:34:41 <asl> http://hpaste.org/2549
11:35:08 <oerjan> !paste
11:35:09 <hpaste> Haskell paste bin: http://hpaste.org/
11:35:13 <asl> I'm trying to use a recursive state dataype, and then write a function in a state monad which can recurse down it
11:36:42 * beelsebob is trying to figure out if a problem is reasonably tractable
11:36:56 <asl> maybe it isn't
11:37:11 <beelsebob> anyone care to help me try and figure out a reasonably fast algorithm?
11:37:14 <oerjan> asl: just one thing, gets f = f `liftM` get
11:37:39 <fasta> asl: your type is isomorphic to a list btw.
11:37:46 <Saizan> ?type withState
11:37:48 <lambdabot> forall s a. (s -> s) -> State s a -> State s a
11:38:01 <asl> fasta:  yeah, I know.  that's a simplification of the type I'm really using
11:38:32 <monochrom> Fairly strange use of State.
11:39:01 <asl> fasat:  now that I think more, just having a list as the state would solve all of my problems
11:39:25 <Saizan> ?type let withState' f m = do x <- get; put (f x); r <- m; put x; return r in withState'
11:39:26 <lambdabot> forall s (t :: * -> *) t1. (MonadState s t) => (s -> s) -> t t1 -> t t1
11:39:38 <chessguy> is it just me or is there something very wrong with this?
11:39:38 <chessguy> do (best, payoff) <- do return (getBestMove depth O b2)
11:39:59 <fasta> chessguy: use let?
11:40:14 <chessguy> wouldn't that be do let (best, payoff) = getBestMove depth O b2
11:40:21 <Saizan> asl: you can use withState' (const state') (find key) and it will be more polymorphic
11:40:26 <fasta> chessguy: y
11:40:36 <chessguy> ok, that's what i thought
11:40:58 <oerjan> chessguy: your friendly neighborhood first monad law there :)
11:41:09 <asl> Saizan: thanks.  I'll try to digest a bit of that
11:41:28 <chessguy> @undo do return (getBestMove depth O b2)
11:41:28 <lambdabot> (return (getBestMove depth O b2))
11:41:47 <chessguy> oerjan, indeed
11:42:25 <Saizan> asl: it's based on using only the interface of MonadState, you take the current state, put a different one, eval the action, and then put the old state back
11:42:48 <asl> Saizan: which is exactly what I want to do
11:43:57 <oerjan> asl: except that your code doesn't really need a monad at all as written
11:44:59 <Saizan> yeah, find can be written with the equivalent of foldr on your datatype
11:45:35 <oerjan> and if it is a list, you can use lookup
11:45:38 <fasta> oerjan: he said it was simplified.
11:46:05 <oerjan> that doesn't mean it cannot be a list
11:46:28 <monochrom> it is still a pompous use of State.
11:46:32 <asl> oerjan, fasta: yeah, I think both of your intuitions that I should be using a list is correct
11:46:55 <asl> no sense reinventing induction
11:46:58 <fasta> I wonder how a list is implemented under the hood.
11:47:12 <monochrom> lots of cons cells.
11:47:16 <fasta> I.e. whether it has a ByteString like implementation...
11:47:21 <monochrom> No.
11:47:26 <Saizan> nah, pointers
11:47:26 <taruti> just cons-cells.
11:47:34 <fasta> Isn't that like.... slow?
11:47:39 <monochrom> Yes!
11:47:42 <taruti> fasta: not really for short lists.
11:47:48 <oerjan> if it had then they wouldn't have needed to invent the actual ByteString
11:47:49 <taruti> for long ones, yes.
11:47:56 <fasta> taruti: most people tend to have long lists, I guess.
11:48:00 <dcoutts> fasta: bytestring has different semantics, so you cannot transparently replace list by bytestring
11:48:16 <fasta> dcoutts: "*-like" <- I said that.
11:48:19 <taruti> fasta: rather they use lists for wrong purposes.
11:48:43 <dcoutts> fasta: but anything like bytestring would also have wrong semantics
11:48:46 <Saizan> lists are fast when you can fuse/deforest
11:48:56 <dcoutts> right, when used as control structure
11:48:59 <taruti> a list is very nice if one e.g. needs to consume lots of values once and not keep them all in memory at once.
11:49:12 <MyCatVerbs> Saizan: anything is fast if you have a compiler smart enough to optimize it away. ;)
11:49:18 <fasta> But to accumulate results and process them later is a nightmare?
11:49:45 <monochrom> I guess "____ is slow" and its negation are naive statements.
11:49:49 <taruti> fasta: just producing them lazily will help
11:50:01 <ddarius> fasta: Lists are singly linked list as the "naive" implementation of algebraic data types and particularl datat [] a = [] | a : [a] would suggest.
11:50:16 <ddarius> You use them where you'd use singly linked lists.
11:50:31 <monochrom> Is list slow? Is recursion slow? Is generator slow? Is array slow? Is BST slow? Is hashing slow?
11:50:53 <fasta> monochrom: an implementation can be slow.
11:50:56 <asl> monochrom: maybe!
11:51:10 <sorear> What does slow mean?
11:51:13 <monochrom> Even "an implementation is slow" is a naive statement.
11:51:20 <sorear> Does slow mean?
11:51:35 <fasta> Slow means slower than one would reasonably expect.
11:51:38 <LoganCapaldo> wouldn't having lists impelemented as "ByteString"s also ruin the (expected) laziness
11:51:41 <LoganCapaldo> ?
11:51:47 <__nasa__> conal: Does Vertigo only work on Windows, or can I get it working on OS X and/or Linux (I was actually planning on using it for the demo I was working on above, but I didn't realize you wrote it!)
11:51:52 <ddarius> LoganCapaldo: Yes as dcoutts said.
11:52:34 <monochrom> Nothing is absolutely, context-freely, unquestionably slow, OK? You have to say, "given this feature, given this implementation, I'm using it for the purpose", now you can ask is it slow, is there a faster way.
11:52:35 <fasta> The list could also be implemented as a list of tuples than can contain c items, where c >1
11:52:41 <fasta> that*
11:52:57 <conal> __nasa__: it's only worked on windows so far.  i'd be interested in collaborating on a cross-platform version.
11:53:13 <fasta> It could be true that for some c > 1 is better than c = 1.
11:53:31 <dcoutts> fasta: that could be slow :-) as in slower than expected, since if it's often =1 then you've added overhead without saving anything
11:53:40 <__nasa__> That is possible, conal. I want to write a demo for windows first, but then I  will consider it.
11:53:44 <monochrom> When did people begin to talk about performance devoid of application?
11:53:46 <MyCatVerbs> ~
11:53:50 <MyCatVerbs> Whoops, sorry.
11:53:57 <conal> __nasa__: great.  just let me know if & when you're interested.
11:54:02 <MyCatVerbs> monochrom: bubblesort.
11:54:02 <dcoutts> monochrom: 1981? :-)
11:54:04 <fasta> monochrom: what makes you think there's no application?
11:54:21 <monochrom> Perhaps I mean s/devoid/indepedent/
11:54:23 <ddarius> MyCatVerbs: bubblesort can be "fast"
11:54:25 <pippijn> can anyone tell me how to do a case switching of getOpt?
11:54:49 <pippijn> or show me a document that tells how to do it
11:54:51 <MyCatVerbs> monochrom: and, if you can find an edge case bizarre enough to make bubblesort optimal (though I will admit they do exist, true enough)... bogosort.
11:55:20 <ddarius> minimum = head . bubblesort
11:56:02 <monochrom> "list is slow" is a statement independent of application. It is an undecidable statement.
11:56:37 <phobes> People talk in generalizations because it allows progress
11:56:43 <MyCatVerbs> monochrom: depending on how much time you spend indexing into the middle of the list, and how much time you spend consing and cdring and removing elements from the middle of the list?
11:56:53 <monochrom> Yes, things like that.
11:56:56 <phobes> "lists are slow" is a pretty fair statement alot of the time
11:57:11 <ddarius> phobes: Not really.
11:57:19 <fasta> I never cons anything to the middle of a list unless I know the list has bounded length.
11:57:30 <monochrom> I think it is not a generalization, it is a prejudice.
11:57:36 <roconnor> for loops are slow
11:57:48 <monochrom> computer is slow.
11:57:55 <phobes> Short lists are terrible compared to short arrays
11:57:58 <ddarius> universe is slow
11:58:10 <monochrom> #haskell is slow
11:58:11 <ddarius> phobes: I agree with "lists are slow arrays"
11:58:20 <MyCatVerbs> ddarius: I can think of a way to make that O(N), but it involves defining bubbleSort *using* minumum. :/
11:58:27 <LoganCapaldo> arrays are slow lists
11:58:35 <monochrom> YES!
11:58:42 <MyCatVerbs> ddarius: and I have no clue how to write it in Haskell.
11:58:45 <phobes> ddarius:  lists are slow lists unless you're inserting into the middle of them
11:59:03 <roconnor> lists are pretty fast when they are deforested.
11:59:11 <fasta> Ok, I meant the list interface implemented by the [] type in GHC.
11:59:29 <monochrom> It still depends on what you use it for.
11:59:30 <phobes> roconnor:  I'm talking about the singly linked list at implementation level
11:59:37 <ddarius> fasta: They are singly linked lists.  You use them when you'd use singly linked lists.
11:59:52 <ddarius> If you wouldn't use singly linked lists, don't use [].
11:59:53 <fasta> For something that doesn't use the laziness associated with them.
12:00:06 <fasta> ddarius: I can use any sequence type
12:00:11 <phobes> ddarius:  But it's so much easier most of the time
12:00:17 <fasta> ddarius: but Data.Sequence is about 14 times slower.
12:00:29 <MyCatVerbs> roconnor: unless I'm misunderstanding something here, deforestation when the compiler optimizes the data structure away, right? So that's just a case of the principle that *anything* is fast if you optimize it away?
12:00:59 <roconnor> MyCatVerbs: yeah, but it is moderately common to use lists in a manner that has it deforested.
12:01:02 <phobes> MyCatVerbs: Yes ... though maybe GHC is specially tuned to do deforestation on lists?
12:01:12 <ddarius> phobes: It is.
12:01:22 <ddarius> For some values of "specially tuned"
12:01:26 <dons> ?yow
12:01:26 <lambdabot> I appoint you ambassador to Fantasy Island!!!
12:01:31 <dons> ?users
12:01:31 <lambdabot> Maximum users seen in #haskell: 394, currently: 387 (98.2%), active: 22 (5.7%)
12:01:32 <ddarius> (Really the libraries are, not the compiler)
12:01:34 <fasta> Ok, I think I am saying that a list like implementation that doesn't specify laziness properties could be faster than the [] type.
12:01:52 <fasta> (and certainly more appropriate to what I need)
12:02:02 <ddarius> fasta: Faster at what?  And then it's something else altogether.
12:02:03 <MyCatVerbs> roconnor: ah. Any explainations of how to go about writing Haskell programs to make such oppourtunities evident to the compiler? Or does it not take much work at all?
12:02:17 <MyCatVerbs> phobes: that would seem the logical thing to do, given their prevalence in functional programming.
12:02:29 <ddarius> MyCatVerbs: Use list combinators rather than rolling your own.
12:02:30 <fasta> ddarius: at adding elements, and then getting the results back from the structure again.
12:02:34 <monochrom> fasta is working for a company and under an NDA he can't tell you what he uses a sequence for.
12:02:37 <roconnor> MyCatVerbs: I just assume the compiler is doing deforestation. ... I worry it probably isn't most of the time.
12:02:47 <sorear> Why can't people just accept that haskell has more important goals than performance?
12:02:50 <phobes> This is the main thing I miss from OO - data abstraction for free
12:02:59 <MyCatVerbs> ddarius: mapM_, foldl', sequence, concat, map, etc?
12:03:13 <ddarius> MyCatVerbs: And list comprehensions, yes.
12:03:30 <Heffalump> sorear: at some level, performance always matters
12:03:35 <MyCatVerbs> ddarius: they don't always compile down to exactly the same code as you'd get by writing their standard prelude sources out by hand?
12:03:39 <ddarius> sorear: That's not the issue.  Why can't people just accept that different data structures do different things with different trade offs.
12:03:42 <monochrom> sorear: My gripe instead is when people talk about performance why can't they do it properly.
12:03:42 <roconnor> MyCatVerbs: ah, ddarius is right.  Try to avoid writing you own recursive functions.
12:03:54 <sorear> Heffalump: Even when you're writing papers?
12:04:26 <monochrom> Many GHC papers are on performance.
12:04:29 <MyCatVerbs> sorear: because we want our programs to terminate *before* the Sun burns out, rather than after. Excepting for all those crazy people writing about corecursion. Goodness knows what _they_ want. ;)
12:04:34 <Heffalump> have you ever read PLDI proceedings? :-)
12:04:34 <sorear> MyCatVerbs: There is no GHC-specific
12:04:56 <ddarius> MyCatVerbs: There are RULES that turn things like map f . map g into map (f . g) and they work at that level.  So if you write out map they won't see it.
12:05:00 <MyCatVerbs> sorear: was that meant for monochrom?
12:05:06 <roconnor> MyCatVerbs: corecursion plays exteremely well with structural recursion.
12:05:14 <MyCatVerbs> ddarius: ah, right, they cheat. Good to know. :)
12:05:24 <monochrom> The ByteString papers include performance.
12:05:24 <sorear> MyCatVerbs: Terminate?  Time?  We don't run programs, we just gaze at their timeless beauty like Dijkstra intended!
12:05:29 <MyCatVerbs> roconnor: (I was just being silly ;)
12:05:35 <roconnor> oh okay
12:05:41 <ddarius> MyCatVerbs: They're almost not cheats.
12:05:44 <MyCatVerbs> roconnor: (sort of, anyway)
12:05:59 <MyCatVerbs> ddarius: eh, I strongly approve of cheating.
12:06:04 <taruti> dons: could Data.Binary.Get export some more API to make it possible to define an external transformer version of the monad?
12:06:18 <ddarius> MyCatVerbs: Nevertheless, they are almost not cheats.  Just expressions of truths.
12:06:19 <monochrom> Dijkstra did not dismiss performance. He wants you to get things correct first.
12:06:22 <MyCatVerbs> ddarius: it's what engineering is all about, after all. That and selecting appropriate tradeoffs.
12:06:27 <hpaste>  taruti pasted "Data.Binary.Get-api-patch" at http://hpaste.org/2561
12:06:30 * roconnor thinks that corecursion is just a memozied function on the natural numbers (more or less).
12:06:55 <MyCatVerbs> roconnor: I like that expression.
12:07:09 * sorear thought corecursion has nothing to do with naturals?
12:07:31 <monochrom> Every program is a function from the natural numbers to machine state.
12:07:50 <ddarius> mu G -> X ~ nu F
12:07:51 <roconnor> sorear: my naturals I mean anything isomorphic to the naturals.
12:08:09 <monochrom> My naturals include 0.
12:08:23 <ddarius> My naturals include 3.
12:08:34 <roconnor> my naturals go down to -1.
12:08:40 <MyCatVerbs> sorear: (\n -> l !! n) where l = iterate somefunction startingpoint
12:08:43 <dons> taruti: oh, we have a transformer version, don't we?
12:08:47 <dons> or haven't i applied that patch/
12:08:54 <phobes> My naturals include 'fix succ'
12:09:03 <phobes> but I don't want them to :)
12:09:10 <MyCatVerbs> My naturals include n if and only if n is equal to zero or if (pred n) is already included by a previous clause.
12:09:31 <taruti> dons: not at least in the darcs.haskell.org/binary repository
12:09:53 <sorear> Oh, I see.
12:09:55 <MyCatVerbs> :t fix
12:10:01 <lambdabot> forall a. (a -> a) -> a
12:10:02 <sorear> ITC, Why stop at the naturals?
12:10:18 <sorear> What's so special about the first infinite ordinal?
12:10:18 <monochrom> My real numbers can be well-ordered.
12:10:26 <MyCatVerbs> Where's fix defined? *can't find it in the prelude*
12:10:33 <chessguy> in Hughes' classic "Why FP" paper, he develops a function evaluate :: Board -> Int, which generates the game tree from a given board position, maps a static evaluation function over it, then uses alpha beta to get the actual evaluation
12:10:35 <dons> sorear: btw, wrt. performance -- it was one of ghc's original goals
12:10:37 <monochrom> Hell, my functional spaces are well-ordered.
12:10:53 <monochrom> fix is in Control.Monad.Fix
12:10:56 <MyCatVerbs> dons: yeah, but definately not the primary goal.
12:10:57 <chessguy> is there a good way to extend this to collect the "principal variation"...i.e., the best sequence of moves from the current postion
12:11:08 <dons> its probably not the primary goal -- while that might be the case for say, ocaml
12:11:12 <dons> or clean.
12:11:14 <chessguy> (besides turning each node into something like a (Board, [Move])
12:11:14 <MyCatVerbs> dons: number two at most, after correct semantics ;)
12:11:25 <dons> yeah, maybe #2 or #3
12:11:31 <dons> so higher ranked than for python or ruby ;0
12:11:44 <monochrom> chessguy: I think one can do it, but I haven't tried.
12:11:45 <phobes> well, those are languages
12:11:50 <sorear> python and ruby are also programming languages
12:12:01 <phobes> The goal for Haskell should be a clean nice language... the primary goal for GHC should be performance
12:12:01 <chessguy> monochrom, how would you go about it if you were to try?
12:12:02 <phobes>  :)
12:12:13 <sorear> ghc is just an implementation, so it has less goals; a fortiori most of them have higher ranks
12:12:15 <roconnor> phobes: down with MR!
12:12:25 <sorear> phobes: primary goal for GHC is to implement Haskell
12:12:32 <dons> well...
12:12:43 <MyCatVerbs> dons: number three most likely. I get the impression performance is #2 for both OCaML and Clean too - their communities also seem to revolve around the point that a wrong answer is useless no matter how quick you get it. ;)
12:12:44 <dons> to be a research vehicle perhaps for new language ideas
12:12:47 <phobes> sorear:  Correctly implementing of Haskell is a given...
12:13:00 <monochrom> I would read the algorithm. (I haven't.) There seems to be some general techniques of extending "find minimum" to "find how to get minimum".
12:13:20 <MyCatVerbs> phobes: no, it isn't.
12:13:25 <MyCatVerbs> phobes: see, for example, csh.
12:13:41 <Philippa> phobes: Hah. It's rather questionable whether Haskell 98 as standardised can be correctly parsed at all
12:13:48 <MyCatVerbs> phobes: if "correctness" isn't actually right at the bloody top of your goals list, you tend to produce broken ad-hoc shite.
12:14:05 <MyCatVerbs> Philippa: really? Why?
12:14:10 <chessguy> monochrom, maybe there is, but if so, i'm missing it
12:14:31 <fasta> Haskell 98 is not defined and probably never will be.
12:14:34 <monochrom> I just want to offer you spiritual support. :)
12:14:41 <MyCatVerbs> Philippa: (that isn't particularly daunting since I've heard the same about C++ programs' semantics being undecidable because templates are Turing-complete).
12:14:45 <chessguy> lol, gee thanks :)
12:15:03 <fasta> Sun with it's Java test suite seems a better idea for specification.
12:15:07 <MyCatVerbs> fasta: but you can download the spec, like, right over the internet and stuff. And you can wallpaper your room with it!
12:15:13 <fasta> A formal spec is of course better.
12:15:14 <phobes> MyCatVerbs:  I agree correctness is obviously the primary goal
12:15:23 <fasta> MyCatVerbs: there is no spec.
12:15:26 <kilimanjaro> MyCatVerbs, are they turing complete? I thought there was a rule about recursion depth
12:15:28 <monochrom> Is it one of those days in the month when fasta goes on a complaining spree?
12:15:42 <fasta> monochrom: ok, you can talk.
12:15:43 <phobes> kilimanjaro:  Yes, the machine will run out of memory :)
12:16:02 <kilimanjaro> No, I thought it would termintate at some fixed depth. I could be wrong though
12:16:09 <MyCatVerbs> kilimanjaro: most implementations have limits on recursion depth, but there's AFAIK no standard about it, and you can tell the compiler to raise (or maybe even lift) those.
12:16:13 <kilimanjaro> ahh
12:16:20 <phobes> That's not in the language... certain compilers might have that limitation though
12:16:28 <MyCatVerbs> kilimanjaro: g++ by default gives up after 500 reductions, for example.
12:16:45 <phobes> lambdabot gives up too
12:16:59 <MyCatVerbs> But you can give -ftemplate-depth 5000000, which'll vastly exceed the amount of RAM+swap you probably have in your machine anyway.
12:17:27 <MyCatVerbs> (For any given value of "you" which doesn't include "you over there in the corner with the fourty-terrabyte supercomputer attached to the petabyte SAN")
12:17:35 <pejo> MyCatVerbs, I don't follow your argument. Since the compiler might not terminate, the semantics are not well defined?
12:17:37 <MyCatVerbs> *terabyte, yikes.
12:17:56 <MyCatVerbs> pejo: it's formally undecidable whether any given program can be compiled.
12:18:06 <phobes> Anyway, I maintain the fact that the simple [] notation is tied to a particular (poor in many cases) singly linked list implementation is a bad thing for haskell
12:18:50 <MyCatVerbs> pejo: "I don't know whether I can actually ever compile this in a finite quantity of time or not" could be counted as semantic ambiguity, if you're prepared to give me the benefit of the doubt. ;)
12:18:54 <Japsu> Hmm
12:19:07 <MyCatVerbs> phobes: that's not a fact, that's an opinion. :P
12:19:14 <Japsu> It would be cool if one could do something like "let a = [1,2,3] :: Array Int"
12:19:36 <phobes> MyCatVerbs: You parenthesized incorrectly :)
12:20:14 <phobes> MyCatVerbs:  The simple [] notation is in fact currently tied to a particular implementation if I understand correctly
12:20:16 <chessguy> > let a = fromList [1,2,3] in a
12:20:21 <lambdabot>   Not in scope: `fromList'
12:20:24 <monochrom> How do you maintain facts? :)
12:20:47 <Philippa> MyCatVerbs: undecidable just means "might not terminate" though
12:20:48 <MyCatVerbs> phobes: mebbe, but that being a bad thing or not is the matter of opinion.
12:21:13 <Philippa> anyway, there's a hiccup with the layout rule and operator fixity declarations
12:21:15 <monochrom> English needs scoping punctuations badly.
12:21:16 <phobes> MyCatVerbs:  Agreed, but I never intended to mean that was a fact
12:21:18 <chessguy> > let a = array (1,3) [1,2,3] in a
12:21:18 <lambdabot>   add an instance declaration for (Num (t, e))
12:21:19 <lambdabot>     In the expression: 1
12:21:22 <MyCatVerbs> Philippa: so, what's the problem with parsing Haskell, anyhoo?
12:21:33 <MyCatVerbs> phobes: ah, right, sorry. I read that sentence wrong, then.
12:21:52 <Philippa> the layout rule defines the scope of a declaration (obvious reasons) but may be affected by a declaration later on in the source
12:22:23 <MyCatVerbs> Philippa: that sounds awkward, but resolvable with something like a unifier.
12:23:22 <chessguy> let fromList list = array (1,3) $ zip [1..] list in fromList [1,2,3]
12:23:28 <chessguy> > let fromList list = array (1,3) $ zip [1..] list in fromList [1,2,3]
12:23:29 <lambdabot>  array (1,3) [(1,1),(2,2),(3,3)]
12:24:17 <chessguy> @pl fL l = a (1,3) $ z foo l
12:24:17 <lambdabot> fL = a (1, 3) . z foo
12:28:50 <ddarius> monochrom: Are there any natural written languages that use scoping punctuation?
12:29:30 <Japsu> hmm
12:29:53 <monochrom> I haven't run into one. But I have little exposure.
12:30:18 <monochrom> All natural languages badly need scoping.
12:30:26 <ddarius> There you go.
12:30:32 <EvilTerran> lojban?
12:30:40 <ddarius> Is not a natural language.
12:30:44 <EvilTerran> bah!
12:30:50 <trippo_> hello
12:31:13 <monochrom> We need to teach school kids to talk in Haskell in daily life.
12:31:36 <ddarius> I don't even know how to talk in Haskell.
12:31:36 <EvilTerran> hm... if i ever write a compiler, its flag to disable optimisations will be -Ono, and for extra optimisations will be -Orly ;]
12:31:39 <Philippa> MyCatVerbs: no, because there's not a "most general unifier" of "brace goes here" and "brace goes there"
12:31:55 <monochrom> hahaha
12:32:13 <ddarius> Philippa: Given the entire source file, is the parse ambiguous?
12:32:21 <EvilTerran> and for the particularly expensive optimisations, -Odear ;]
12:32:28 <b_jonas> lol
12:32:42 <b_jonas> but I like the current ones seriously
12:32:45 <MyCatVerbs> monochrom: I disagree. Teach 'em LOGO and don't let on that it's a Lisp dialect.
12:32:49 <trippo_> I have a question about type system extensions in GHC
12:32:59 <monochrom> LOGO is good enough.
12:33:16 <EvilTerran> trippo_, shoot
12:33:19 <ddarius> Just don't teach them javascript.
12:33:24 <MyCatVerbs> monochrom: that's enough to teach FP with, if not anything interesting that can be done with type systems.
12:33:29 <trippo_> does GHC with extensions include the full System F
12:33:30 <trippo_> ?
12:33:41 <b_jonas> -O0 = I wanna rebug, -O1 = I want fast compilation, -O2 = I want good code, -O3 = I want slightly better code than that, I have lots of time
12:33:53 <b_jonas> and -Os for size
12:34:29 <monochrom> I like Orly. I don't like magic numbers.
12:34:52 <b_jonas> so what would you call -O2 and -O1?
12:34:56 <ddarius> monochrom: Would 17, 8, and 32 be less magical?
12:35:40 <monochrom> At least, 17 is a mersenne prime, 8 and 32 are powers of 2.
12:35:52 <EvilTerran> is -O1 the default?
12:36:11 <monochrom> GHC defaults to -O0
12:36:16 <EvilTerran> "rebug"?
12:36:27 <monochrom> yeah, I'm wondering about rebug too.
12:36:36 <EvilTerran> debug?
12:36:41 <ddarius> "I would like the compiler to insert all the bugs I just fixed"
12:36:55 <monochrom> That should be the job of darcs.
12:38:33 <pjd> @remember EvilTerran hm... if i ever write a compiler, its flag to disable optimisations will be -Ono, and for extra optimisations will be -Orly ;]
12:38:34 <lambdabot> Done.
12:38:47 <EvilTerran> =]
12:39:15 <chessguy> shouldn't it be -0noes
12:39:20 <chessguy> err
12:39:22 <chessguy> -Onoes
12:39:25 <EvilTerran> actually, yes it should.
12:39:33 <EvilTerran> doh!
12:40:07 <EvilTerran> .oO( Bad poetry,
12:40:12 <EvilTerran>      oh noetry! )
12:40:24 <idnar> bwahaha
12:43:41 <pjd> phobes: Alternative/MonadPlus!
12:43:51 <pjd> (for [] notation)
12:45:00 <EvilTerran> (http://www.toothpastefordinner.com/022005/bad-poetry.gif)
12:49:40 <chessguy> err, http://haskell.org/haskellwiki/HaWiki_migration needs a link to the old wiki
12:49:41 <b_jonas> well, there's still no topping to gcc -Larry -Wall
12:49:41 <lambdabot> Title: HaWiki migration - HaskellWiki
12:50:27 <roconnor> old wiki?
12:51:11 <chessguy> yeah, the one we're migrating from
12:51:29 <roconnor> @where old-wiki
12:51:30 <lambdabot> I know nothing about old-wiki.
12:51:57 <chessguy> @go haskell wiki
12:51:59 <lambdabot> http://en.wikipedia.org/wiki/Haskell_(programming_language)
12:52:22 <chessguy> not quite what i had in mind
12:52:44 <Japsu> "what, does wiki mean something else than wikipedia too" ...
12:53:19 <chessguy> dons?
12:54:40 <chessguy> ohhh, the old wiki is down now, my bad
12:55:05 <ddarius> @oldwiki
12:55:05 <lambdabot> http://www.haskell.org/hawiki/
12:55:43 <chessguy> The requested URL /hawiki/ was not found on this server.
12:56:25 <ddarius> Yep.
12:57:09 <chessguy> i never realized how much stuff was on the old wiki, or i would've ported the stuff myself
12:57:27 <dons> i suspect we can convince igloo to host the pages somewhere
12:57:35 <chessguy> (at least the stuff that the authors had agreed to have ported)
12:57:38 * ddarius is upset.
12:57:50 * ddarius just barely can't fit all the Hamming and SICP lectures onto one DVD.
12:58:23 <roconnor> ddarius: get rid of hamming00.mov
12:59:00 <xerox> Barely? How big are all of the SICP lectures?
12:59:10 <ddarius> roconnor: Just barely is by more than that.  I've already dropped that, hamming14.mov, all the PDFs and even hamming31.mov.
12:59:32 <ddarius> xerox: The ones I got sum to about 2.8 gig.
12:59:41 <Heffalump> dons: why Igloo in particular?
12:59:43 <EvilTerran> can't you re-encode the quality down a little?
12:59:45 <Heffalump> does he have them?
13:00:02 * EvilTerran isn't sure how DVD video works exactly
13:00:03 <ddarius> EvilTerran: No.  They are both at pretty low quality any way.
13:00:04 <__nasa__> EvilTerran, that would take longer than burning 2 CDs :-)
13:00:04 <xerox> ddarius: so I guess you need some double-layer dvd.
13:00:28 <__nasa__> s/2 CDs/a DVD and CD
13:01:00 <dons> Haskell oh, I thought he took down the wiki originally
13:01:07 <dons> Heffalump:
13:01:12 * __nasa__ is having problems compiling code with HGL.
13:01:14 <Heffalump> oh, right.
13:01:29 * Heffalump has no idea who did it. Most annoying, though.
13:01:49 <xerox> Isn't it shapr who has got hawiki? I think he's the one who was maintaing it at least.
13:02:06 <chessguy> @get-slap
13:02:07 <lambdabot> shapr!!
13:04:13 <chessguy> hmm
13:04:15 <chessguy> data FRef s a = FRef
13:04:16 <chessguy>       { get :: s -> a
13:04:16 <chessguy>       , set :: a -> s -> s
13:04:16 <chessguy>       }
13:04:37 <chessguy> is there some reason other than needing extensions for MPTCs to not use them here?
13:05:05 <roconnor> fun deps?
13:05:05 <ddarius> Huh?
13:05:41 <chessguy> or am i totally mis-understanding MPTCs
13:05:53 <EvilTerran> that's not a typeclass
13:06:01 <EvilTerran> let alone a multi-parameter one ;]
13:06:14 <chessguy> it seems to me like this is equivalent to class FRef s a where get :: s -> a; set :: a -> s -> s
13:06:36 <chessguy> or am i way off?
13:06:43 <SamB> chessguy: except there's no, uh, coverage condition or whatever...
13:06:53 <SamB> er.
13:07:07 <SamB> hmm. maybe that only applies when fundeps are involved.
13:07:25 <SamB> anyway, more to the point, you can have as many implementations as you like
13:07:29 <EvilTerran> you can have multiple values :: FRef s a; you'd only get one instance FRef s a for any particular s and a
13:07:56 <nomeata> help: ghc-pkg register seems to remove the ghci library file that I have pre-compiled!
13:08:08 <trippo_> oh my gosh, can someone explain me the "let 2 + 2 = 5 in 2 + 2" ?
13:08:33 <nomeata> ah, nevermind
13:08:35 <mauke> trippo_: it rebinds +
13:08:40 <nomeata> I really should read the code I’m using... ARG.
13:08:42 <chessguy> huh? wouldn't any given instance FRef s a correspond to an expression you could form using the data declaration?
13:08:47 <xerox> trippo_: you're welcome on #haskell.it :-)
13:08:56 <conal> > let 2 + 2 = 5 in 2 + 3
13:08:58 <lambdabot>   Non-exhaustive patterns in function +
13:09:26 <trippo_> mauke, oh now i get it ;-)
13:09:26 <conal> did someone come up with "let 2 + 2 = ..." to scare newbies?
13:09:32 <SamB> conal: no
13:09:40 <SamB> we just use it to tease eachother
13:09:52 <jedai> chessguy: You seem to be confused ? FRef isn't a typeclass
13:09:55 <conal> ah.  i like it. :)
13:10:08 <chessguy> jedai, i'm not saying it is. i'm saying it's equivalent to one
13:10:16 <EvilTerran> foo = FRef { get :: fst, set :: \x (_,y) -> (x,y) } :: FRef (a,a) a
13:10:24 <chessguy> (though i may still be confused)
13:10:25 <EvilTerran> bar = FRef { get :: fst, set :: \y (x,_) -> (x,y) } :: FRef (a,a) a
13:10:37 <EvilTerran> good luck having both of those as instances
13:10:52 <jedai> chessguy: In what sense is it ? I think you're confused, please don't use instance except for instance of typeclass
13:11:12 <chessguy> ok, hang on, i suspect an hpaste will clarify
13:11:12 <glguy> chessguy: it is equivalent to the dictinoary in one of the dictionary passing implementations of typeclasses
13:11:15 <chessguy> @hpaste
13:11:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:12:44 <hpaste>  chessguy pasted "what can you do with a value of type FRef that you can't do with an instance of Fref' (or vice versa" at http://hpaste.org/2562
13:13:17 <thoughtpolice> hm. :( I guess for this api wrapper I'm not going to be able to bind to runStmt; seems there's no way to get at the values of expressions after they're entered. I mean, there's it since runstmt binds it, but no way to get its value it seems. :(
13:13:32 <chessguy> glguy, i'm not following that
13:13:47 <iguana_> in the definition of Complex a, "data Complex a = !a :+ !a", what do the "!" mean?
13:14:05 <chessguy> iguana_, they're strict fields
13:14:11 <swiert> On the topic of the old wiki, what's the easiest way to port material?
13:14:12 <jedai> iguana_: It's a strictness annotation, meaning you can't put thunk in there
13:14:33 <swiert> I have permission from most of the old TMR authors to move stuff - who is responsible for the hawiki?
13:14:44 <glguy> chessguy: with the datatype, you have to pass the dictionary around manually, and you have to select the correct dictionary manually
13:14:46 <jedai> iguana_: And they'll be unboxed if you use -funbox-strict-fields in GHC
13:14:53 <glguy> chessguy: with the typeclass you don't do either
13:15:09 <iguana_> jedai: I don't know what "put thunk there" means
13:15:12 <chessguy> so...the typeclass is better?
13:15:20 <glguy> chessguy: so they are unrelated
13:15:27 <chessguy> oy
13:15:44 <jedai> iguana_: Meaning you can't put a lazy value in one of those fields, she will be evaluated immediately
13:15:48 <glguy> one can be used to emulate the other with a bunch of other machinery
13:16:03 <iguana_> ah, ok
13:16:22 <iguana_> and why is that necessary there?
13:16:34 <hpaste>  EvilTerran annotated "what can you do with a value of type FRef that you can't do with an instance of Fref' (or vice versa" with "what about this?" at http://hpaste.org/2562#a1
13:16:36 <ddarius> swiert: Porting is by hand.  You should just be able to copy and paste the "source" and fix it up.
13:16:48 <ddarius> Of course, that would require hawiki to be up.
13:17:01 <jedai> iguana_: It never is necessary, though for performance reason, you don't want your Complex type to have boxed fields
13:17:24 <iguana_> so that means that the compiler will be able to generate lower level code which is then faster?
13:17:33 <jedai> iguana_: And it avoid some "accident" where you get a stack overflow
13:17:42 <chessguy> oh, hmm
13:18:00 <jedai> iguana_: much faster, and the value will take less space (as the fields will be unboxed)
13:18:39 <chessguy> EvilTerran, so with the typeclass you couldn't have multiple FRef instances with the same type
13:18:49 <chessguy> err, FRef'
13:18:50 <glguy> chessguy: some_f :: FRef a => b -> c , becomes: some_f :: FRef a -> b -> c
13:18:51 <EvilTerran> exactly
13:18:52 <iguana_> ok
13:19:03 <jedai> iguana_: You most often want strictness for numeric value, and lazyness for algebraic datatype (like list or tree)
13:19:06 <glguy> chessguy: and you have to manually thread the FRef through
13:19:16 <glguy> chessguy: instead of letting the compiler pick the right one
13:19:20 <glguy> and do it for you
13:19:32 <chessguy> ok
13:19:38 <glguy> and then manually extract the methods:
13:19:45 <glguy> get dictionary first_param
13:19:52 <glguy> set dictionary first_param second_param
13:22:02 <jedai> iguana_: Do you understand why you want strictness for numeric value and lazyness for algebraic datatype ? It's because numeric value aren't useful at all when they aren't totally evaluated, where algebraic datatype can be explored partially without evaluating all parts of it
13:22:45 <swiert> ddarius: Ok - thanks for the tip. Do hawiki and MediaWiki use the same markup?
13:22:45 <ddarius> jedai: Conceptually...
13:23:05 <chessguy> interesting stuff. http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
13:23:08 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
13:23:08 <jedai> ddarius: Don't speak about Peano integer, please...
13:23:38 <ddarius> swiert: I'm pretty sure that's a no though there shouldn't be tons of stuff to change on any one page.
13:23:43 <ddarius> I think they are similarish.
13:23:59 <swiert> Fair enough.
13:24:07 * EvilTerran has used an instance Integral a => Num [a] that was lazy for good reason...
13:24:12 <swiert> I'll give it a wirl once hawiki is up again...
13:24:18 <jedai> swiert: Not exactly, there was {{{ for <haskell> for example
13:25:02 <ddarius> Some search and replace would probably do a well enough job for most of it and leave not an unreasonable amount behind.
13:27:10 <ddarius> jedai: Actually that was not the direction I was thinking.
13:27:46 <klein> i've got a types question...
13:28:09 <shapr> xerox: Yes, I was the HaWiki maintainer, and I think I have a backup copy somewhere.
13:28:11 <klein> say i've got a graph data structure like "data Node a = Node a [Node a]"
13:28:12 <chessguy> klein, fire away
13:28:14 <jedai> ddarius: You were thinking about algebraic datatype where you want strictness ? Well I was speaking in very general term there... ^^
13:28:27 <klein> where it's got some data and a list of neighbors
13:28:40 <ddarius> No, I was thinking about complex numbers that you might not want fully evaluated.
13:28:42 <xerox> shapr: cool. People seem to want to volunteer for porting stuff to haskellwiki :)
13:28:44 <klein> any way i can fool with the type system to ensure statically that it's got no cycles?
13:29:10 <EvilTerran> klein, there is, but it's not pretty
13:29:13 <klein> i've been trying to read up on dependent types, looking at Peano arithmetic examples
13:29:39 <klein> EvilTerran: yeah?  can you point me in the right direction?
13:29:42 <jedai> ddarius: Yes, you're right in this particular case (because it is an algebraic datatype in fact) but I guess it was for efficiency reason ?
13:30:10 <ddarius> klein: You could make a strict list type then any cycles would lead to infinite loops at runtime.
13:30:42 <ddarius> jedai: That and as I said, conceptually we tend to like to think of completely evaluated numbers.
13:30:45 <klein> ddarius: that's exactly what i'm trying to avoid :)
13:31:19 <EvilTerran> http://okmij.org/ftp/Haskell/number-parameterized-types.html
13:31:20 <lambdabot> Title: Haskell Programming: Types that depend on numbers
13:31:22 <jedai> ddarius: Yes, that too I suppose :-/
13:32:15 <EvilTerran> klein, that thar by Oleg's the closest thing that i know of to what you want
13:32:22 <ddarius> klein: -Making- cycles is fine, mucking about with them is fine, it's just when you try to traverse the whole structure that they become not fine.
13:32:56 <klein> EvilTerran: hmm.  i think this might work.  if i parameterize the nodes of the graph on their height
13:33:19 <ddarius> klein: That would work.
13:33:35 <EvilTerran> indeed it would
13:33:51 <klein> ddarius: yep.  ultimately i'm wanting to print out these graphs (really, trees), so infinite recursion is a bit of a downer :)
13:34:14 <ddarius> klein: If you did want to handle cycles there are some interesting ways.
13:34:23 <ddarius> As well as some brute force ways.
13:34:24 <jedai> klein: Why not just make a smart constructor ? Or do you want to do it with types to try it out ?
13:34:42 <EvilTerran> klein, doing this sort of thing does rather restrict you. it'd probably be nicer to do this sort of thing at runtime
13:34:42 <klein> jedai: it's for the fun of figuring out the types
13:34:46 <ddarius> jedai: The constructor can't figure it out.
13:35:30 <ddarius> klein: How about considering a nested data type solution?
13:35:31 <klein> EvilTerran: yep.  the idea is just to see if i can do it
13:35:31 <jedai> ddarius: If there is height in his graph, the constructor can indeed figure it out (modulo some modification on the data definition)
13:36:16 <ddarius> jedai: I guess that would work, but the type would have to be abstract then.
13:36:17 <klein> as i see it, what i'll be getting with this is guarantees of no-cycles. from there, my next type adventure is enforcing tree-ness
13:36:33 <klein> i.e. 1 parent per node
13:37:09 <hpaste>  conal pasted "generalizing catMaybes" at http://hpaste.org/2563
13:37:24 <klein> ddarius: can you give me an example of what you mean by a nested data type solution?
13:37:44 <ddarius> @google AVL trees nested data type site:haskell.org inurl:pipermail
13:37:46 <lambdabot> http://www.haskell.org/pipermail/haskell/2003-April/011693.html
13:37:46 <lambdabot> Title: Polymorphic stanamically balanced binary trees
13:38:15 <jedai> klein: Have you read the 2-3 FingerTree paper ? it's quite interesting on this field
13:38:16 <ddarius> klein: That isn't the solution to your problem obviously (well actually it's not that far off I don't think)
13:38:50 <jedai> klein: There's nested data type in it.
13:38:56 <ddarius> klein: Without labelling the nodes there's no way currently to differentiate a DAG from a tree.  It would always print as a tree currently.
13:39:10 <conal> i'd like to hear ideas for improving the generalized catMaybes at the hpaste link above.
13:39:11 <klein> jedai: i'll give that a look
13:39:14 <ddarius> (that is the sharing that may exist in not observable)
13:39:44 <klein> ddarius: oh right, i guess what i was thinking was that if you were to recursively print the structure, you'd never see the same node twice
13:39:48 <ddarius> conal: Can't you readily use NotJustMaybe?
13:40:03 <conal> ddarius: what's that?
13:40:04 <ddarius> klein: Yep, but there is no notion of "same"
13:40:23 <ddarius> Replace Maybe a with Monad(Zero) m => m a
13:40:40 <klein> ddarius: i guess i have to get out of a pointer mindset :)
13:41:04 <jedai> Nested data type would in fact insure there is no cycle as well as treeness, wouldn't they ?
13:42:26 <ddarius> conal: I guess that would be generalization in a different direction (assuming it even made sense in this case)
13:42:54 <conal> ddarius: yeah, thanks.  i wasn't even considering generalizing from Maybe.
13:43:37 <conal> the inelegant thing about my filterG is that it uses mempty but not mappend.
13:43:50 <klein> well, you've all given me something to chew on -- got to run now.  thanks!
13:48:37 <ddarius> conal: Incidentally m >>= f = join . fmap f $ m
13:48:50 <ddarius> :t join . fmap ?f
13:48:52 <lambdabot> forall a a1 (f :: * -> *). (Monad f, ?f::a1 -> f a, Functor f) => f a1 -> f a
13:49:44 <ddarius> In fact, the generalization you may be looking for may well just be join
13:49:57 <pjd> filterG = (>>= maybe mempty return)
13:50:39 <conal> ddarius, pjd: oh, thanks!
13:51:15 <EvilTerran> what about (>>= maybe mzero return)?
13:51:19 <conal> ddarius: join's type is too specific.
13:51:23 <ddarius> conal: Yep.
13:51:35 <conal> ?ty (>>= maybe mzero return)
13:51:37 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m (Maybe a) -> m a
13:51:39 <EvilTerran> or even (>>= maybe fail return), if you don't mind annoying the purists
13:51:47 <ddarius> Something like liftM f for f :: m a -> n a
13:51:50 <pjd> conal: MonadPlus = Monad + Monoid
13:52:05 <ddarius> EvilTerran: (fail "foo")
13:52:13 <pjd> mzero and mempty are essentially the same concept
13:52:19 <pjd> just from different classes
13:52:22 <EvilTerran> ddarius, i don't think that's possible, seeing as it'd involve escaping the (m) monad
13:52:28 <EvilTerran> ddarius, ah, yes, of course
13:52:43 <ddarius> EvilTerran: Clearly you couldn't have it in general
13:53:03 <ddarius> :t maybeToList
13:53:05 <lambdabot> forall a. Maybe a -> [a]
13:53:07 <conal> so they're incomparable, generality-wise
13:53:21 <conal> (ie mempty vs mzero versions)
13:53:22 <EvilTerran> hm... class Monad m => MonadRun m where runMonad :: m a -> a, anyone?
13:53:42 <ddarius> > liftM maybeToList [Just 3, Nothing, Just 2]
13:53:47 <lambdabot>  [[3],[],[2]]
13:54:02 <EvilTerran> > maybeToList =<< [Just 3, Nothing, Just 2]
13:54:03 <lambdabot>  [3,2]
13:54:03 <ddarius> > maybeToList =<< [Just 3, Nothing, Just 2]
13:54:05 <lambdabot>  [3,2]
13:54:07 <EvilTerran> heh
13:54:27 <jedai> > mzero :: Maybe Int
13:54:29 <lambdabot>  Nothing
13:54:49 <chessguy> @src maybeToList
13:54:49 <lambdabot> maybeToList  Nothing   = []
13:54:49 <lambdabot> maybeToList  (Just x)  = [x]
13:55:37 <conal> on second though, I guess the Monoid (m a) version is more general, in that it's implied by MonadPlus m, in that there's either a defined or easy-to-define Monoid instance
13:55:40 <chessguy> ah, concatmap, right
13:55:53 <pjd> a similar take:  filterG p = (>>= \x -> if p x then return x else mzero)
13:56:20 <conal> pjd: yes.  as a specialization
13:56:23 <conal> Maybe ()
13:56:52 <pjd> well, not quite
13:57:01 <EvilTerran> @src filterM
13:57:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:57:08 <EvilTerran> @type filterM
13:57:11 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:57:33 <conal> oh yes
13:58:25 <chessguy> @where BOB
13:58:26 <lambdabot> I know nothing about bob.
13:58:31 <chessguy> likely story
13:58:59 <chessguy> @src filterM
13:59:00 <lambdabot> Source not found. Take a stress pill and think things over.
13:59:23 <conal> i'm restarting writing on "applicative data-driven computation", and this filterG function describes event filtering with nice generality.
14:00:32 <EvilTerran> filterM p [] = []; filterM p (m:ms) = b <- p m; return $ if b then (m:) else id $ filterM p ms
14:01:12 <EvilTerran> sorry,
14:01:29 <EvilTerran> filterM p (m:ms) = do b <- p m; liftM (if b then (m:) else id) (filterM p ms)
14:01:52 <conal> why I don't like filterM is that it combines mapping and filtering.  so not an atomic idea.
14:02:05 <EvilTerran> it does?
14:02:41 <jedai> Doesn't it only filter ?
14:03:07 <conal> it applies a function to each list element
14:03:13 <conal> and it decides what to keep
14:03:13 * EvilTerran sees [a] -> m [a], and blinks
14:03:35 <Heffalump> so your complaint is that the function is not pure?
14:03:48 <conal> not pure?
14:03:58 <ddarius> @where HSU
14:03:58 <lambdabot> I know nothing about hsu.
14:04:02 <jedai> conal: But the elements at the end are the same as the element at the beginning (except those that were filtered out)
14:04:37 <jedai> conal: though the list if now in the monad you used in the predicate
14:04:44 <ddarius> :t filterM
14:04:46 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:04:47 <jedai> s/if/is/
14:05:13 <chessguy> conal, there are lots of non-atomic ideas in haskell, or any language. what's wrong with that?
14:05:34 <dons> axioms only please! :)
14:05:48 <chessguy> as long as the atomic ideas its made of are also available, i don't see why this is a problem
14:05:54 <jedai> It don't do any mapping
14:05:59 <chessguy> e.g., concatMap
14:06:07 <chessguy> @src concatMap
14:06:08 <lambdabot> concatMap f = foldr ((++) . f) []
14:06:14 <DRMacIver> chessguy: Thanks for the link.
14:06:15 <conal> chessguy: i guess it sounded like i was criticizing filter/filterM.  I'm really not.  Just wondering how I want to explain event filtering.
14:06:18 <dons> hey jedai :)
14:06:33 <dons> i'm not sure I've seen you on irc before?
14:06:34 <chessguy> DRMacIver, the functional references?
14:06:40 <DRMacIver> chessguy: No, on my blog. :)
14:06:45 <DRMacIver> (The API talk)
14:06:47 <chessguy> oh!
14:06:51 <chessguy> no problem
14:07:13 <jedai> dons: You surely have, here for example (maybe in other places too)
14:07:15 <sieni> conal: I think it's a good idea to have commonly used idioms as standardized functions even though they are not strictly necessary
14:07:45 <dons> ah yes, since July or so.
14:07:59 <jedai> conal: filterM isn't event filtering, it's filtering by event...
14:08:14 <sieni> conal: like saying something like [1..17] in scheme is a bitch (well at least in r5rs, I'm not that familiar with r6rs)
14:08:30 <jedai> dons: Yep, I'm a newly converted to Haskell ;-)
14:08:43 <dons> welcome!
14:08:51 <dons> i've enjoyed your hacking on the mailing list, btw.
14:08:54 <conal> sieni: i agree.  and i'm sorting out what the primitives are in my Events library & paper.
14:08:59 <jedai> dons: Thanks :-)
14:09:16 <mudge> dons: cool, making pdfs with haskell
14:09:45 <conal> jedai: yep -- different operation
14:10:05 <dons> mudge: yeah, now I just need a good use for this.
14:10:16 <dons> hmm, i could programmatically produce the haskell weekly news pdf editoin, i guess
14:10:54 <jedai> dons: You could add a pdf output to haddock (if it doesn't already exist ?)
14:11:10 <dons> oh, that's an interesting idea.
14:11:26 <conal> dons: what kind of operations does your library have?  is there a doc pointer?
14:12:12 <dons> conal: oh, not my lib.
14:12:12 <olliej> dons: doesn't haddock already support latex out?
14:12:23 <dons> conal: http://www.alpheccar.org/en/posts/show/80
14:12:24 <lambdabot> Title: Haskell PDF 1.0
14:12:35 <conal> dons:  thanks.  i forgot where i'd seen it.
14:13:05 <conal> i had that page in a tab but lost it in the sea of tabs
14:19:28 <chessguy> @pl s b = s' b (g b)
14:19:28 <lambdabot> s = ap s' g
14:19:54 <chessguy> @hoogle ap
14:19:58 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
14:19:58 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
14:19:58 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
14:20:06 <Nucleo_> what's null for a single Char?
14:20:25 <roderyk> if function expects IO String and c is a Char, why is 'return [c]' legal, but 'return c : []' is not?
14:20:27 <xerox> > '\0'
14:20:29 <lambdabot>  '\NUL'
14:20:34 <Nucleo_> ahh, thank you.
14:20:38 <xerox> You're welcome.
14:21:00 <liyang> roderyk: (return c) : []
14:21:03 <nomeata> finally uploaded the new gtk2hs. took the better of the day − I hope someone with a faster machine will set up and maintian the package
14:21:07 <mauke> roderyk: needs more parens
14:21:12 <mauke> return is not a keyword
14:21:18 <Saizan> roderyk: because return c : [] is parsed as (return c) : [], instrad you want return (c : [])
14:21:19 <liyang> um. Hello there.
14:21:33 <dcoutts> nomeata: thanks muchly!
14:21:54 <dcoutts> nomeata: sorry about the trouble
14:22:02 <liyang> (I'm buried under too much stuff at the minute. :-/)
14:22:04 * liyang runs and hides
14:22:27 <roderyk> ah, thanks!
14:22:37 <nomeata> dcoutts: welcome. I also uglyly patched the Makefile.in to remove a haddock file that was created, but not installed, as it comes from a hidden source file.
14:22:58 <dcoutts> ok
14:23:10 <ddarius> DRMacIver: Good API == small API (?0
14:23:11 <nomeata> liyang: ah, you are still there? I haven’t heared from you for a while :-) I tried to fix some of the open bugs.
14:23:36 <liyang> I am, but only in body and not quite in mind. :-/
14:24:19 <laz0r> why does Haskell2Xml/DrIFT work fine as long as i play around with it, and then stops working when i actually try to use it? and, more importantly, does anyone in here have an idea how i can solve that 'irrefutable pattern failed' error?
14:24:32 <shapr> Igloo: thanks!
14:25:43 <dons> laz0r: i'd imagine it depends on the input text?
14:25:51 <dons> is it some invalid pragma or syntax?
14:26:20 <laz0r> dons: im trying to output haskell data as xml
14:26:27 <xerox> More tea or not more tea?
14:26:36 <laz0r> that worked fine for some little examples
14:26:50 <Igloo> shapr: ?
14:26:50 <DRMacIver> ddarius: Hm. I don't agree. Smallness helps a lot, but I don't think it's neccessary or sufficient
14:26:57 <olliej> xerox: more tea, duh :D
14:26:58 <laz0r> but when i use on something a little more complex, it stops working
14:27:04 <xerox> Sold.
14:27:05 <Igloo> shapr: Oh, I remember
14:27:20 <laz0r> i think it has problems with lists of tupels, for some reason
14:27:27 <DRMacIver> ddarius: To take the two examples I provided, Joda time is actually very large. It's a lot larger than the core calendar/date classes for example, but infinitely better.
14:28:02 <laz0r> the problem is, i had to generate an instance of haskell2xml for my data with drift
14:28:37 <laz0r> and i cant really figure out what that code exactly does
14:28:41 <chessguy> > sortBy (comparing fst) $ zip [9,8..1] "abcdefghi"
14:28:46 <lambdabot>  [(1,'i'),(2,'h'),(3,'g'),(4,'f'),(5,'e'),(6,'d'),(7,'c'),(8,'b'),(9,'a')]
14:32:35 <augustss> yo
14:32:51 <conal> augustss: ho
14:33:24 <matthew-_> conal: ho
14:33:28 * matthew-_ fetches the rum
14:33:40 <chessguy> @arr
14:33:40 <lambdabot> Yo ho ho, and a bottle of rum!
14:33:47 <matthew-_> l33t!
14:33:57 <ddarius> DRMacIver: I agree that it is not sufficient.  However, I'm willing to bet that it's often a good indicator.
14:34:06 <chessguy> @index comparing
14:34:06 <lambdabot> bzzt
14:34:12 <chessguy> @hoogle comparing
14:34:12 <lambdabot> No matches found
14:34:22 <conal> augustss: what do you think about real-time code generation with fairly good optimization?
14:34:25 <chessguy> wtf
14:34:29 <chessguy> @type comparing
14:34:31 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:34:35 <mnu> Is someFunc :: (Floating a) => a -> a the same as someFunc :: Float -> Float?
14:34:48 <Philippa> conal: do you actually mean real-time, or just interactive?
14:34:51 <chessguy> mnu, no
14:34:55 <augustss> conal: depends on what you mean by real time
14:34:57 <chessguy> @instances-importing Floating
14:34:58 <lambdabot> Double, Float
14:35:10 <conal> augustss: i guess i mean interactive.  is harpy a good starting point?  what else?
14:35:17 <DRMacIver> ddarius: Sure. A small API is much more likely to be a good API than a large one.
14:35:18 <augustss> conal: btw, if you liked let 2+2=..., how about let (+)(+)(-)=(-)(+)(+) in 10+logBase
14:35:20 <conal> "on the fly"
14:35:35 <DRMacIver> ddarius: But a large API isn't neccessarily bad and a small API isn't neccessarily good.
14:35:35 <mnu> chessguy: I guess what I'm asking is the purpose of '=>
14:35:38 <mnu> '
14:35:45 <conal> augustss: yurk!
14:35:59 <augustss> conal: Oh, interactive.  No problem.  Harpy does fine with that
14:36:22 <Philippa> mnu: it separates out a "context" from the rest of the type. The context puts constraints on type variables
14:36:22 <dons> tiobe is getting more interesting, http://www.tiobe.com/tpci.htm
14:36:24 <lambdabot> Title: TPCI - TIOBE Programming Community Index
14:36:24 <conal> augustss: and how about producing fast code?
14:36:37 <Philippa> they're not the same because Floating can have instances other than Float (Double, for example)
14:36:46 <mauke> mnu: separates class constraints from the "real" type
14:36:52 <dons> a couple of months ago haskell cracked 0.1%, now its at #35. up from #49 this time last year, and way ahead of ocaml, ml. erlang finally has appeared in the top 50
14:37:13 <mnu> Philippa, mauke: That's what I thought. Thanks!
14:37:16 <augustss> conal: with some effort you can do that.  My Mickey Mouse code generator beats ghc for fib with on-the-fly generation with Harpy.
14:37:29 <dons> (n.b. these `rankings' are based on google hits for the term 'haskell programming' -- so the more that is used, the higher the rank)
14:37:43 <ddarius> dons: Wait until you guys release your book.
14:37:52 <conal> augustss: neat.
14:37:56 <dons> ddarius: yeah.
14:38:02 <dons> also, i note 'functional languages' are up 0.5%
14:38:22 <dons> so while lisp/scheme continue to fall, erlang/haskell are rising fast enough to balance it
14:38:36 <augustss> conal: I meant to do do&blog some more about that
14:38:50 <dons> 2 down arrows for lisp/scheme (-0.02%), while haskell is up about 0.4%
14:38:58 <dons> 0.04% i mean
14:39:03 <ddarius> Schemers are moving to Haskell!
14:39:08 <conal> augustss: i hope you do.  i'm interested in getting back into code gen for graphics and wondering about tools
14:39:42 <augustss> conal: but you want code generation for GPUs?
14:39:45 <ddarius> augustss: Add a register allocator over a simple infinite register machine and I'll be happy.
14:39:57 <conal> augustss: that also.  different project
14:39:59 <dons> ddarius: maybe some of them.
14:40:15 <Heffalump> ddarius: as in start with an infinite register machine and allocate to x86?
14:40:29 <ddarius> Heffalump: Yes.  So I don't have to.
14:40:35 * ddarius doesn't feel like writing a register allocator.
14:40:39 <augustss> ddarius: no need to get that fancy to beat ghc ;)
14:40:44 <dons> so i think everyone should embed the text "haskell programming" in their blogs :)
14:40:59 <ddarius> dons, I'll be sure to do that to mine.
14:41:05 <Heffalump> how should it manage spilling?
14:41:19 <augustss> ddarius: register allocation is easy.  spilling is tricky
14:41:44 <ddarius> Choosing what to spill is tricky.
14:41:52 * LoganCapaldo doesn't feel like writing a register spiller
14:41:54 <augustss> yes, and when
14:42:07 <dons> isn't benl writing a new register allocator right now for ghc?
14:42:07 <Heffalump> and how, if you have no notion of a stack frame
14:42:13 <Heffalump> yes, he is
14:42:16 <ddarius> Yay
14:42:19 <LoganCapaldo> at dawn, tommorow
14:42:23 <LoganCapaldo> spill it then
14:42:32 <LoganCapaldo> and let the rivers run with register contents
14:42:32 <augustss> the guts?
14:43:42 <ddarius> All I want is to be able to write almost-assembly-level code with the illusion of an infinite number of registers and have that become something sane.
14:43:51 <chessguy> woot!
14:44:15 * chessguy finally finishes porting some crappy tic-tac-toe code to use WhyFP-style alphabeta
14:44:31 <pjd> ddarius: that would be like writing assembly that only addresses virtual memory?
14:45:38 <ddarius> pjd: Kind of, though I want to be able to say what things I'd like to have in registers and which things should definitely be memory.
14:46:25 <olliej> ddarius: define "sane"
14:46:31 <pjd> ddarius: sounds almost like stack languaging
14:46:36 <olliej> ddarius: are you wanting to do register allocation?
14:47:00 <Heffalump> no, he wants someone else to do it for him
14:47:11 <olliej> ddarius: eg. reduce the "infinite set" down to a finite set and overflow
14:47:21 <Heffalump> I still think you need to at least explain to the allocator how it should spill.
14:47:24 <pjd> ddarius: with stack addressing
14:47:41 <olliej> ddarius: if that's the case look up register allocation in google, either with graphi colouring or linear scan are the best
14:47:45 <pjd> with the top of the stack what should be in registers
14:47:47 <Heffalump> pjd: no, he just wants x86 assembler with infinite registers.
14:48:04 <Heffalump> which is much less verbose than stack machines
14:48:11 <pjd> x86 stack dialect!
14:48:30 <olliej> pjd: a standard compiler technique is to generate code on the assumption of infinite regsiters
14:48:33 <Heffalump> stack machines are ugly and waste code
14:48:35 <ramza3> observations.  with the the blip.tv with simon peyton, the camera man sucks
14:48:49 <olliej> then allocate the infinite registers into the finite set in the mahine
14:48:57 <ddarius> olliej: I've read tons and tons on register allocation.
14:49:05 <ddarius> But I don't feel like writing the code.
14:49:09 <olliej> ddarius: ah
14:49:16 <olliej> ddarius: sucks to be you then :D
14:49:27 * olliej wrote a crappy reg allocator in C ages ago
14:49:28 <ddarius> olliej: Not if someone else writes the code.
14:49:36 <olliej> ddarius: hah :p
14:49:39 <ddarius> In fact, someone did but they didn't make it available!
14:50:43 <augustss> ddarius: Why not write the code.  It's only a page or two of Haskell.
14:51:09 <wli> Integrated instruction selection and register allocation is the way to go anyway and that's orders of magnitude more involved.
14:51:32 <augustss> wli: true
14:52:41 <ddarius> http://www.piumarta.com/papers/vm04-vpu.pdf
14:53:24 <Caelum> what can I read to understand partial application better?
14:53:55 <augustss> Caelum: there is very little to understand
14:54:45 <TSC> You could try writing your types as "a -> (b -> (c -> d))" instead of "a -> b -> c -> d"
14:55:42 <conal> Caelum: if you've used OO languages, then think of an object constructor as a partial application and a method call as an additional application.
14:55:49 <ddarius> That paper describes what I want.
14:56:27 <Caelum> conal: I see, thank you
14:56:40 <conal> :)
14:58:23 <conal> there's a sort of syntactic progression from conventional OO style to java-style anonymous inner classes to partial application.  in the end, the notation is so unintrusive that it's a delight to use.
14:58:36 <pjd> Caelum: provide some parameters, to get a function of the remaining parameters
14:59:43 <liyang> I wrote a concurrent STM sudoku solver but it's slow: http://haskell.org/haskellwiki/Sudoku#Concurrent_STM_Solver . Haelp.
14:59:47 <lambdabot> Title: Sudoku - HaskellWiki
15:01:41 <ddarius> "applicative functor porn"?
15:01:46 <LoganCapaldo> mmm
15:01:56 <conal> drool
15:01:58 <LoganCapaldo> pure functional pornography
15:02:37 <LoganCapaldo> With underwear so translucent you could call it referentially transparent
15:02:44 <LoganCapaldo> or something
15:02:59 <liyang> Right. But it runs slow. And that makes me a sad panda.
15:03:03 <Philippa> "want to act in my IO monad?"
15:03:23 <liyang> as long as there's on unsafe IO performing.
15:03:30 <liyang> s/on/no
15:03:46 <wli> hmm, every 100th element of a list
15:03:47 <Philippa> as soon as you can poke, all IO is unsafe...
15:03:59 <mrd> no peeking under the covers, of functions
15:04:36 <LoganCapaldo> lemme unsafeCoerce so I can see what your existential looks like
15:04:39 <conal> liyang: for more AF porn, define Region = Triple `O` Triple
15:04:48 <DRMacIver> I don't think my brain can cope with Haskell innuendo.
15:05:12 <conal> liyang: and Cube = Grid `O` Cell.  you get the idea.
15:05:30 <LoganCapaldo> I feel like I keep getting to the territory of good innuendo but my execution is poor :(
15:05:46 <liyang> conal: . . .
15:07:00 * ddarius just regrets having said anything.
15:07:19 <conal> liyang: i like your code.
15:07:52 <Cale> heh, launchMissiles
15:08:17 <Philippa> more examples should include launchMissiles
15:09:58 <glguy> k_dub must have been running KDE
15:10:02 * wli goes about applying the geodesy code he's been brewing up for therp to ICBM targeting.
15:10:19 <liyang> conal: Thank you. :) Please make it faster. I'm not familiar with all (read: any) of the -ffunky-transformation flags GHC has. :-/
15:17:24 <Cale> liyang: are you compiling with -O2 ?
15:18:08 <liyang> -O3 , but the nefarious one at the bottom of the Sudoku page never* finishes. :-/
15:18:15 <liyang> Makefile's at the bottom.
15:18:44 <LoganCapaldo> I thought -O3 was bad
15:18:59 <mauke> it is
15:19:13 <Cale> At best, it's the same as -O2
15:19:16 <liyang> ah. I expected it to be better than -O2. :-/ Tried both, in fact. Couldn't remember much difference...
15:19:47 <thoughtpolice> there's an -O3?
15:19:58 <EvilTerran> thoughtpolice, it's my -Odear from earlier ;]
15:20:39 <thoughtpolice> i suggest an -O42, for those optimizations you need an entire planet to help determine.
15:21:02 <liyang> <grin>
15:21:17 <EvilTerran> that doesn't sound very optimising...
15:21:23 <Cale> http://darcs.haskell.org/ghc/compiler/main/DynFlags.hs -- at least in the darcs version, it clamps the number to 0..2
15:21:32 <Cale> but I think that code has changed
15:21:49 <EvilTerran> -OMG, for code that requires omnipotence to optimise effectively :D
15:21:50 <dolio> thoughtpolice: That's just called jhc. :)
15:22:04 <thoughtpolice> :)
15:22:51 <thoughtpolice> what's the flag for black ninja optimisation magic?
15:23:04 <liyang> I propose -OMGWTFBBQ
15:23:24 <matthew-_> I propose -Opwned
15:23:32 <thoughtpolice> what about -Oshit?
15:23:34 <EvilTerran> -O.o
15:23:38 <thoughtpolice> i mean, that's a lot of optimization
15:25:13 <liyang> thoughtpolice: it lets you divide by zero?
15:25:39 <thoughtpolice> we're dealing with *ninja* magic here.
15:34:28 <EvilTerran> hm... i'm thinking it'd be nice to have an operator with the same fixity as <*> that takes a vanilla second parameter
15:36:07 <EvilTerran> (<#>) :: Applicative f => f (a -> b) -> a -> f b
15:36:52 <conal> EvilTerran: so save  "pure", just as <$> saves one
15:36:56 <EvilTerran> f <#> x = f <*> pure x
15:37:07 <EvilTerran> yeah
15:38:09 <liyang> Perhaps. But having said that I'm perfectly happy to use pure f <*> ...
15:38:10 <EvilTerran> it seems it'd be useful for the Monad Applicatives, anyway, for when you've got a function with some monadic and some vanilla parameters
15:42:49 <chessguy> EvilTerran, why vanilla and not chocolate?
15:43:48 <chessguy> @bot
15:45:09 <ddarius> chessguy: If you mix chocolate with vanilla you get chocolate.  If you mix vanilla with chocolate you get chocolate.
15:45:39 <chessguy> ddarius, that's profound
15:46:34 <ddarius> It actually matches the situation even more than I intended.
15:46:35 <liyang> Essentially you're saying that ice cream is a monoid and vanilla == mempty?
15:47:33 <Boney> mixing is multiplcation and vanilla is 1
15:47:46 <ddarius> To a rough approximation, yes.
15:47:54 <Boney> eating is (0*)
15:48:01 <Boney> :-)
15:48:12 <liyang> This is too much for my fragile mind.
15:50:17 <wli> I foresee a paper on gastronomical combinators and/or DSL's in Haskell.
15:50:42 <xerox> And I guess cones are functors in the category of icecream flavours.
15:51:12 <glguy> ?quote xerox And I guess cones are functors in the category of icecream flavours.
15:51:20 <glguy> ?remember xerox And I guess cones are functors in the category of icecream flavours.
15:51:27 <glguy> ?bot
15:51:28 <ddarius> There aren't functors in the category of icecream flavours unles you are saying icecream flavours form a subcategory of Cat.
15:51:37 <Boney> @hello
15:51:38 <ddarius> Perhaps you meant functors on.
15:51:39 <Boney> @ping
15:51:52 <xerox> ddarius: yeah, just like monads on types :=)
15:51:54 <glguy> xerox: you win this time ;)
15:52:00 * xerox giggles
15:52:02 <chessguy> dons, ?
15:52:17 <glguy> dons is busy with HWN, leave him alone !
15:52:18 <glguy> :)
15:52:23 <Boney> I had a good one the other day "Im in ur monads, changing ur state"
15:52:35 <ddarius> glguy: Is he?
15:54:26 <earnest> so paul graham said what he thinks about haskell: ``don't know enough to say, but it has strong typing, which is a lose''
15:54:42 <chessguy> earnest, link?
15:55:03 <ddarius> earnest: And people care what Paul Graham says... why?
15:55:20 <earnest> chessguy: that's in my mailbox
15:55:24 <MyCatVerbs> ddarius: he did implement a few really really big pieces of software from time to time.
15:55:42 <ddarius> MyCatVerbs: As have most programmers.
15:55:49 <earnest> ddarius: i actually care what everyone says if they say it honestly
15:56:12 <ddarius> I don't care what the vast majority of humanity says whether or not they say it honestly.
15:56:15 <earnest> i tend to link strong typing; i wonder why he doesn't like it
15:56:16 <chessguy> earnest, that's ok, just give me your email password :)
15:56:28 <earnest> chessguy: it's dance@r0x
15:57:07 <chessguy> @bot
15:57:12 <MyCatVerbs> Since you still can't do destructive updates inside the IO monad, that makes it act rather more like Scheme (restricted to parameter-passing style) than like C, right?
15:57:12 <lambdabot> :)
15:57:39 <chessguy> yay!
15:57:44 * chessguy hugs lambdabot
15:58:02 <Boney> @remember Boney "Im in ur monads, changing ur state"
15:58:02 <lambdabot> Done.
15:58:20 <monochrom> I can't do destructive updates inside the IO monad?
15:58:23 <ddarius> @help forget
15:58:23 <lambdabot> forget nick quote.  Delete a quote
15:58:38 <dons> :t Data.IORef.writeIORef
15:58:40 <lambdabot> forall a. GHC.IOBase.IORef a -> a -> IO ()
15:58:45 <chessguy> @remember xerox And I guess cones are functors in the category of icecream flavours
15:58:45 <lambdabot> Done.
15:58:49 <dons> IO () -- looks destructive to me
15:59:07 <ddarius> Also, now that I think about it, CT already has cones.
15:59:09 <monochrom> haha ice-cream category
15:59:16 <ddarius> :t return ()
15:59:17 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
15:59:29 <mauke> @flush
15:59:29 <lambdabot> Not enough privileges
15:59:39 <dons> @flush
16:00:05 <sjanssen> MyCatVerbs: you can certainly do destructive updates in IO, see IORef, Ptr, etc.
16:00:28 <MyCatVerbs> sjanssen: ahhhh.
16:00:43 <dons> you can also do them in a more careful monad, like ST.
16:00:49 <monochrom> I am aware of a sense in which destructive update is impossible. But that sense is not restricted to Haskell and IO; it extends to the whole universe.
16:01:09 <MyCatVerbs> sjanssen: so, using IORef vs. not using IORef is equivalent to not-sticking-to-parameter-passing-style versus sticking-to-parameter-passing-style?
16:01:32 <dons> IORefs give you true mutable boxes for values
16:01:58 <MyCatVerbs> (I mean, obviously you can do destructive things in either language anyway - there's the damn filesystem right under you, for Pete's* sake, but aside from that...)
16:01:58 <dons> with all the thread-unsafety that implies :)
16:02:12 <MyCatVerbs> (* note to self: find out who Pete is.)
16:02:27 <ddarius> MyCatVerbs: You mean f :: IORef a -> IO b and f :: a -> IO b ?
16:02:27 <MyCatVerbs> dons: STM doesn't play nicely with IORefs?
16:02:43 <ddarius> STM doesn't play with IORefs
16:02:44 <monochrom> STM disallows IORef.
16:02:59 <dons> you'd use STM-specific safe mutable variables, like TVars
16:03:01 <monochrom> But you only need IO to thread.
16:03:01 <MyCatVerbs> Oh, right, yeah, because it stops you ever touching the IO monad, sorry.
16:03:16 <dons> IORefs are just like pointers to addresses in legacy languages, so just as unsafe.. almost
16:03:22 <dons> (there is atomicModifyIORef)
16:03:59 <MyCatVerbs> dons: safer how? You're not allowed to do arithmetic on them and you aren't responsible for manually malloc()ing and free()ing the buggers?
16:04:06 <LoganCapaldo> dons, I love how you call them "legacy languages" :)
16:04:16 <dons> they're safe with respect to threads, TVars.
16:04:27 <dons> unlikes the immediate races you get with IORefs
16:04:39 <dons> LoganCapaldo: :)
16:04:49 <MyCatVerbs> dons: I mean, how're IORefs safer than pointers?
16:04:50 * monochrom confuses the pot by adding MVar
16:05:08 <MyCatVerbs> LoganCapaldo: I for one do *not* object to the assertion. :)
16:05:09 <dons> MyCatVerbs: no no, IORefs are pretty much just raw pointers, but there is an atomicModify operation on them
16:05:22 <dons> however, you're right: they're garbage collected, and you can't do math on them
16:05:27 <dons> so already they're safer than C.
16:05:36 <glguy> IORefs don't support pointer arithmetic, and can't be set to null
16:05:57 <dons> from a Haskellish view though, anything that's not naturally thread safe is *unsafe*
16:06:00 <MyCatVerbs> dons: so they're about on a par with Java's references for safety, except that they have no concept of null?
16:06:02 <LoganCapaldo> you also can't construct an arbitrary IORef ((void*)12345)
16:06:03 <monochrom> IORef is only as safe as Java.
16:06:05 <dons> which is not the usual story in programming languages.
16:06:25 <MyCatVerbs> dons: ahhh, I see.
16:06:32 <dons> yeah, like Java references, but the type tells you if null is allowed (IORef (Maybe a))
16:07:00 <MyCatVerbs> Say, does this mean in another ten years' time #haskell and #erlang are going to be pointing and laughing at all the mutable-state language programmers whose programs keep deadlocking?
16:07:03 <dons> Ptr a is your raw pointer, in IO if you want it.
16:07:10 <dons> you can do arithmetic on them
16:07:20 <sjanssen> MyCatVerbs: ten years?  How 'bout now? :P
16:07:23 <dons> MyCatVerbs: i think we're already laughing at them :)
16:07:24 <MyCatVerbs> dons: mmmmm, screaming weasels.
16:07:41 * dons throws some TVars around
16:07:53 <MyCatVerbs> sjanssen, dons: yes, but we're laughing *here*. We aren't actually going out and attending their funerals for the sake of pissing on their graves.
16:08:02 <dons> oh, we should organise some of those events
16:08:08 <dons> that sounds super!
16:08:16 <dons> flash mob #haskell
16:08:17 <LoganCapaldo> you guys are mean :)
16:08:26 <dons> turn up at a C++ workplace to point and laugh :)
16:08:28 <monochrom> hahahahaha flash mob
16:08:29 <dons> then run off
16:10:30 <MyCatVerbs> (Re: screaming weasels: funniest error message I ever wrote. Made a mistake with some half-working C code that had incorrect pointer arithmetic to index into a const char[]. The bug caused it to printf() out of a completely different part of the text segment... one full of generic invariant messages, used in statements along the lines of "if (!invariant) { fprintf(stderr,"The weasels are closing in!\n"); abort(); }. Hence my half-working program su
16:11:04 <SamB> "Hence my half-working program su"???
16:11:04 <EvilTerran> "Hence my half-working program s"?
16:11:08 <liyang> (Not even a workplace. Some sort of exhibition or something would do.)
16:11:23 <MyCatVerbs> suddenly started screaming about weasels when it was *meant* to be printing variable names.)
16:11:38 <liyang> MyCatVerbs: that can be creepy.
16:11:39 <EvilTerran> ahh.
16:12:31 <monochrom> It is still a wonder that any program contains any text so obsessed with weasels.
16:13:02 <liyang> WRT the whole null thing, remember we still have undefined / _|_. So don't get too cocky now. ;)
16:13:15 <mudge> hey what is the difference between "data" and "newtype"?
16:13:25 <chessguy> liyang, that's not nearly as bad
16:13:33 <MyCatVerbs> (+ a b c (* p q)) became something like (+ MY GOD IT'S FULL OF WEASELS\n OD IT'S FULL OF WEASELS\n T'S FULL OF WEASELS\n (* THE WEASELS ARE CLOSING IN\n WEASELS ARE CLOSING IN\n)\n
16:13:42 <mauke> mudge: newtype is limited to a single constructor
16:13:43 <LoganCapaldo> mudge, newtype is "free"
16:13:46 <EvilTerran> is there a page on the wiki about data vs newtype?
16:14:03 <ddarius> There was a page on the old wiki about strict data v. newtype.
16:14:09 <EvilTerran> aha. http://haskell.org/haskellwiki/Newtype
16:14:10 <lambdabot> Title: Newtype - HaskellWiki
16:14:16 <EvilTerran> (surprisingly)
16:14:18 <ddarius> And probably a FAQ question too.
16:14:34 <MyCatVerbs> monochrom: if (impossibleerrorcondition) { fprintf("MY GOD, IT'S FULL OF WEASELS!\n"); exit(1); }
16:14:59 <LoganCapaldo> MyCatVerbs, that's not a very informative error message...
16:14:59 * EvilTerran is reminded of the linux kernel's unexpected comments about penguins
16:15:03 <monochrom> Whoever wrote that is very disturbed.
16:15:11 <MyCatVerbs> monochrom: I think it was for, uh, 'responding to' incorrectly-setup data structures.
16:15:13 <liyang> Essentially, newtype keeps the same machine representation as the underlying type. As far as I'm (un)aware it's there for performance reasons.
16:15:15 <EvilTerran> or indeed "LP1 on fire"
16:15:17 <MyCatVerbs> monochrom: oh hey, I wrote that. Thanks.
16:15:39 <Olathe> "ERROR: Computer is off."
16:15:40 <MyCatVerbs> LoganCapaldo: well, it would never come up unless I fucked up truly egreriously in how I was handlin' them data structures.
16:15:51 <monochrom> IMHO anyway. I also find Simpsons disturbed.
16:15:57 <EvilTerran> isComputerOn(); isComputerOnFire();
16:16:17 <LoganCapaldo> well wouldn't "I fucked up truly egreiously in how I was handlin these data structures" be a btter error message then? :)
16:16:40 <MyCatVerbs> EvilTerran: imagine all the accidental unneccessary shutdowns and deaths by flaming silicon that could result from people typo-ing one for the other!
16:17:20 <MyCatVerbs> LoganCapaldo: no, because it wouldn't be as much fun to write. If that weren't important to me, I wouldn't be anywhere near #haskell right now.
16:17:51 <LoganCapaldo> I think we disagree in what's fun :)
16:17:59 <LoganCapaldo> I think that would be a fun error message
16:18:27 <EvilTerran> MyCatVerbs, at least they're not setComputerOn() and setComputerOnFire()
16:18:37 <MyCatVerbs> EvilTerran: bwahahahahhaahaha, nice.
16:19:31 <MyCatVerbs> ...every time I code something that works, any time I come back to it more than three weeks later I wonder what the fucking Hell was wrong with me back then?
16:19:42 <monochrom> Internal error messages that are secret messages meaningful only to the author himself/herself are ok, I don't mind that. In fact, how else could you peek into the true mental state of the author in question, other than looking at those?
16:19:53 <liyang> (Too much out-right absurdity and not enough subtlety. But that's just me. :)
16:20:23 <monochrom> For example, if you have lots of messages about "mother" and "f*ck", then, well, although Freud isn't always right, in this case he's right on!
16:20:28 <MyCatVerbs> monochrom: precisely! LoganCapaldo: error messages in that program are sensible in direct proportion to how liable they were to occur due to any reason other than my own stupidity.
16:20:35 * EvilTerran is reminded of people who were reading too much into Reiser's documentation on the life cycle of inodes
16:20:40 <MyCatVerbs> monochrom: what about loads of HST references? :)
16:20:48 <Philippa> liyang: there're other situations warranting newtype - for example, you can instance newtype but not type
16:21:29 <MyCatVerbs> LoganCapaldo: like, looking for something in the hash table that just ain't there? "Symbol searched for but not found: %s\n"
16:22:04 <wli> I almost never use newtype.
16:22:08 <wli> I just use data.
16:22:11 <mudge> my understanding of newtype is that it is a lot like "type" synonyms, but with newtypes you can declare instances of classes,  so the different operators like + etc. can work differently
16:22:37 <mauke> I use newtype instead of data so I get magic deriving
16:22:42 <mudge> and newtypes can be more efficient than "data"
16:22:42 <liyang> Philippa: huh? Think there's shome mishcommunication. That wasn't my point. It's there for performance reasons over data, to spell it out. And the whole levels of undefinedness explanation is just a naturall fallout of that.
16:22:43 <MyCatVerbs> LoganCapaldo: somebody gives incorrect input? Things like, "More ('s than )'s" (and vice versa), "Doesn't make sense to have two symbols in a row" and so on.
16:23:01 <wli> I almost never use type, either.
16:23:05 <mudge> mauke: magic deriving?
16:23:23 <liyang> The magic deriving is also a nice result.
16:23:23 <mudge> wli:  if you don't use "data" or "newtype"  what do you use?
16:23:33 <mauke> instance Foo a = Foo [a] deriving (Monad)
16:23:39 <mauke> er
16:23:44 <mauke> newtype Foo a = Foo [a] deriving (Monad)
16:23:48 <wli> mudge: I use data and almost never use type or newtype.
16:23:53 <dons> i use newtype quite a lot
16:24:01 <mudge> wli: oh okay
16:24:02 <dons> its perfect for introducing more structured type information
16:24:03 * ddarius uses them all.
16:24:11 <liyang> wli: in an ideal world that'd be my stance too.
16:24:13 <dons> type I use only for naming long types
16:24:35 <MyCatVerbs> LoganCapaldo: null pointer in a place where null pointers absoposifuckintively must not ever happen, because otherwise they'll cause my program to segfault about ten minutes later in an unrelated place from where it'll take hours to track down - plus, dammit, this function is only meant to be called with *instantiated* variables - "Mein gott, vhat vere zhey zhkinkink?\n" and "The old marthter wouldn't let thith happen."
16:24:36 <liyang> type is used when I don't want to type too muchy.
16:24:37 <mudge> dons:   why do you use newtype instead of data?
16:24:45 <monochrom> When I play with infinite function types I use newtype. This happens often in monad hacking.
16:24:53 <wli> type Z = Integer is my most common use for type.
16:24:58 <MyCatVerbs> LoganCapaldo: (I'd just finished (re)reading Carpe Jugulum at the time I wrote that bit of code, BTW. XD
16:25:24 <liyang> wli: that's just laziness. ;)
16:25:30 <dons> mudge: to wrap existing types cheaply, for new instances, and for newtype deriving
16:25:41 <liyang> *pure laziness. I mean.
16:25:43 <dons> in xmonad for example, we use newtype deriving Num for specific, constrained numeric types
16:25:44 <ddarius> monochrom: Really?
16:25:49 <MyCatVerbs> mudge: if there's only one possible constructor, newtype lets the compiler whisk that constructor away.
16:25:58 <dons> so that we can ensure statically we don't index structures with the wrong keys
16:26:18 <MyCatVerbs> (How come ghc doesn't optimize single-constructor data declarations into newtypes, anyway? Would seem like a cheap benefit.)
16:26:43 <ddarius> newtype communicates different things v. data
16:26:46 <mauke> Foo _|_ vs. _|_
16:26:46 * liyang would -- in an ideal world -- data Natural = Zero | Succ Natural all the way down...
16:27:10 <ddarius> MyCatVerbs: There is a subtle distinction.
16:27:18 <monochrom> ddarius: Yeah! I have this ReaderT over Cont, and the "environment" I want to store in the ReaderT is the same ReaderT over Cont again.
16:27:21 <mudge> dons: thanks
16:27:22 <wli> An arbitrary-precision unsigned integer type is desperately needed.
16:27:27 <mudge> MyCatVers: thanks
16:27:33 <dons> wli, want to get famous?
16:27:43 <dons> upload Data.Natural to hackage :)
16:27:45 <wli> dons: How's that?
16:27:45 <xerox> monochrom: impressive.
16:27:51 <MyCatVerbs> mudge: pas de probleme.
16:28:06 <mudge> MyCatVerbs: I don't speak latin
16:28:06 <wli> dons: The obstacle isn't implementing it but rather the numeric hierarchy and compiler intrinsics.
16:28:08 <dons> hey mnislaih
16:28:08 <ddarius> monochrom: This happens often?
16:28:20 <MyCatVerbs> Davemon: when's there everr a difference in runtime behavoir?
16:28:30 <MyCatVerbs> mudge: s'okay, neither do I. That was French. ;)
16:28:36 <mnislaih> hi dons, what's up
16:28:40 <xerox> monochrom: you should blog about this ;-)
16:28:50 <mudge> MyCatVerbs: oh, haha
16:28:53 <liyang> (Or better than Natural: define Fin n. ;)
16:28:59 <Pseudonym> Yeah, there aren't enough blogs complaining about what's wrong with things.
16:29:01 <dons> mnislaih: just moved to the US. settling in here. btw, you're coming to the hackathon?
16:29:06 <phobes> Is there anyway to build a Natural type in Haskell that doesn't include Nat _|_?
16:29:12 <Pseudonym> dons: Good $DEITY, you're on early today.
16:29:18 <monochrom> This is what I use it for: You know how Cont can emulate exception throwing and catching. Well, the emulation requires passing around a "throw command" as parameter. Then I come up with this natural idea: why not use ReaderT to pass it around implicitly?
16:29:19 <dons> :)
16:29:22 <wli> dons: Is there a hackathon coming to pdx?
16:29:23 <dons> ?time Pseudonym
16:29:23 <mnislaih> dons, congrats on your new job! yep
16:29:23 <lambdabot> Local time for Pseudonym is Tue Sep  4 09:28:14 2007
16:29:28 <dons> ?time dons
16:29:31 <lambdabot> Local time for dons is Mon Sep  3 16:27:32 2007
16:29:41 <glguy> whoa, your time is correct now!
16:29:43 <glguy> ;)
16:29:47 <xerox> monochrom: nice idea!
16:29:48 <dons> oh noes! i'm losing my future
16:29:49 <glguy> it used to be *hours* off
16:29:55 <mnislaih> dons I'll be there, looking forward to it
16:30:01 <Pseudonym> dons: Not many people get an extra day.
16:30:06 <dons> wli, I reckon we should organise an FP user group
16:30:08 <Pseudonym> I had a boss once who lost his birthday.
16:30:11 <MyCatVerbs> Er, ddarius: when's there ever a difference in runtime behavoir between newtype and a single-constructor data declaration?
16:30:12 <Pseudonym> Crossing the date line.
16:30:16 <dons> heh
16:30:41 <xerox> monochrom ...and then 'local' is catch, and something upon ask is throw!
16:30:48 <dons> heya bos
16:30:48 <monochrom> Yes.
16:30:53 <ddarius> @wiki Newtype
16:30:54 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
16:30:57 <mudge> dons: but "data" does deriving,   is "data" derving different than newtypes?
16:30:57 <wli> dons: Sounds good to me.
16:30:59 <bos> hi dons
16:31:16 <ClaudiusMaximus> threading with -no-hs-main question: does hs_init() check the GHCRTS environment variable? is it safe to forkIO if GHCRTS="-N8"? will my "main" thread always be the thread that called hs_init()?
16:31:18 <EvilTerran> mudge, GHC can derive any typeclass for newtypes
16:31:38 <wli> There's something mysterious going on with MArrays.
16:31:41 <dons> mudge: yeah, with newtypes you can automatically derive non-derivable classes
16:31:48 <monochrom> http://www.vex.net/~trebla/study-notes/ContMonad.lhs has my code!
16:31:49 <dons> assuming the type your wrap in the newtype supports the class
16:31:59 <mudge> EvilTerran: ah, and "data" can't do that?
16:32:07 <EvilTerran> mudge, indeed not.
16:32:09 <xerox> monochrom: cool, thanks.
16:32:15 <ddarius> Indeed, you look at the dynamic scope for exception handlers.
16:32:16 <mudge> cool, thanks
16:32:31 <ddarius> Most people just use an error monad.
16:32:37 <ddarius> (transformer)
16:32:46 <EvilTerran> given newtype Foo a = Foo a deriving Bar, ghc does instance Bar a => Bar (Foo a) where {- pass everything through -}, iirc
16:32:49 <monochrom> It is for education (of Cont) more than real use.
16:32:54 <wli> Shouldn't there be a way to pick apart types based on products, coproducts, functions, et al to implement deriving on types?
16:33:06 <dons> use generics :)
16:33:12 <ddarius> data -could- do that for simple cases, but they chose not to because of the differing intent of newtype v. data
16:33:20 <wli> I guess those would be generics, yes.
16:33:22 <dons> (which is how we do deriving for class Binary)
16:33:39 <ddarius> wli: They partially implemented it a while ago but no one ever used it and they never finished implementing it.
16:33:53 <dons> derive :: (Typeable a, Data a) => a -> String
16:34:12 <wli> ah, that's what emits the instance
16:34:22 <wli> But it's not supported in the compiler.
16:34:25 <dons> :t Data.Generics.dataTypeOf
16:34:28 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> Data.Generics.Basics.DataType
16:34:41 <dons> yeah, its library-based
16:35:28 <EvilTerran> @docs Data.Generics
16:35:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
16:35:45 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
16:35:47 <lambdabot> Title: 7.13. Generic classes, http://tinyurl.com/33xvg5
16:35:56 <Saizan> there's still TH
16:36:33 <EvilTerran> which is also incomplete
16:39:36 --- mode: ChanServ set +o dons
16:39:42 --- topic: set to '["A Taste of Haskell: http://tinyurl.com/3bgybs ","The Haskell programming language: functional dependencies are now obsolete!","Home: http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ ","The language of ICFP winners 3 years running"]' by dons
16:39:46 --- mode: ChanServ set -o dons
16:40:32 <wli> Have the ICFP programming contest results been decided?
16:40:38 <EvilTerran> ...what changed?
16:41:00 <dons> +functional dependencies are now obsolete! and some url consing
16:41:12 <vincenz> hmm
16:41:46 <EvilTerran> ah, i see
16:42:21 <vincenz> dons: I'm gonna see if I can't get funding to come to that week in freiburg
16:42:33 <liyang> fundeps are obsolete? How?
16:42:43 <dons> liyang: oh, you've not read the new paper :)
16:42:48 <dons> that's from the abstract. sounded fun.
16:43:02 <dons> http://www.cse.unsw.edu.au/~chak/papers/SSPC07.html
16:43:02 <lambdabot> Title: Research Papers of Manuel Chakravarty
16:43:04 <liyang> ah, no, been kind of buried.
16:43:11 <liyang> *looks*
16:43:12 <dons> "Moreover, functional dependencies are now obsolete: we show how they can be encoded as type functions."
16:44:01 <liyang> dons: hahahahaha type functions. I like the sound already and I haven't even clicked the URL yet.
16:44:23 * vincenz has wished for type functions for a while
16:45:03 <liyang> (Doesn't mean I'm going to stop playing with Agda though. ;p)
16:45:21 <dons> well, now you've got a richer type language to extract from Agda :)
16:45:23 <liyang> (um, er, I mean, Epigram.)
16:46:31 <vincenz> dons: in the us?
16:47:34 <dons> yeah
16:47:53 <liyang> I'm not going to read it now. It's almost 1AM here. But I can go to sleep with the fuzzier feeling that my struggles with Haskell are going to get easier because of this.
16:48:09 <vincenz> dons: Does that mean you're still going to Freiburg?
16:49:02 <dons> yep
16:49:15 <dons> got to present a paper or two and there's the hackathon also
16:49:23 <chessguy> dons, heh. the intro says that making fundeps obsolete isn't even the main contribution of the paper :)
16:49:33 * vincenz nods
16:50:16 * EvilTerran looks at that paper
16:50:22 <EvilTerran> that's awesome :D
16:50:42 <dons> it changs things quite a bit
16:50:53 * vincenz hasn't had a time to look at it yet
16:51:01 <vincenz> Came back from .co yesterday
16:51:53 <liyang> dons: when did that paper come online? Wondering why no one here (notts) told me about it now.
16:51:58 <EvilTerran> hm. the "datakind" keyword mentioned in passing looks very interesting
16:52:28 <liyang> (other than the fact that everyone's on holiday...)
16:52:47 <ddarius> Tim Harris is one scrawny guy.
16:52:48 <EvilTerran> although, with all this, we're dangerously close to the RHS of a :: just being an expression ;]
16:52:48 <dons> liyang: last night I think
16:52:53 <dons> its less than 12 hours old
16:53:04 <liyang> ah hah. :)
16:53:29 <DRMacIver> EvilTerran: Sounds good to me. :)
16:53:37 <liyang> EvilTerran: shush! That's a good thing.
16:54:05 <EvilTerran> i agree. it'd be absolutely awesome.
16:54:15 <DRMacIver> EvilTerran: Clearly :: being an operator definable in the language is a target to aim for. :)
16:54:27 <EvilTerran> i'veidly meditated on the plausibility of it occasionally
16:54:51 <DRMacIver> (Or even a primitive operator)
16:55:39 <EvilTerran> type functions bring it a lot closer to reality
16:56:35 <EvilTerran> without them, sure, (Vector 3 a) would be possible, but vappend :: Vector n a -> Vector n' a -> Vector (n+n') a wouldn't be
16:57:23 <xerox> Actually, it is.
16:57:28 <xerox> ?go number-indexed types
16:57:30 <lambdabot> http://download.oracle.com/docs/cd/B19306_01/appdev.102/b14258/d_sessio.htm
16:57:30 <lambdabot> Title: 96 DBMS_SESSION
16:57:36 * EvilTerran has considered writing something to the effect of instance Num Type, so $(3) would work
16:57:39 <xerox> ?go Oleg number-indexed types
16:57:43 <lambdabot> http://www.dailyseoblog.com/feed/
16:57:44 <EvilTerran> but then, type-splices don't work =/
16:57:46 <xerox> Oh well.
16:58:05 <xerox> ?go Oleg number indexed types
16:58:06 <lambdabot> http://okmij.org/ftp/Haskell/number-parameterized-types.html
16:58:06 <lambdabot> Title: Haskell Programming: Types that depend on numbers
16:58:07 <EvilTerran> i know of those. i think i've even got a PDF sitting around waiting to be read somewhere
16:58:27 <EvilTerran> or is that just the one involving encoding numbers as types?
16:58:57 <EvilTerran> 'cos, in that one, (a+b) as a type didn't work, iirc. it was more a case of Add a b c => c...
17:00:37 <liyang> (oh my oh my. Type-level functions *and* an Apple event on the same day! I'll never get to sleep with all this excitement.)
17:00:46 <liyang> (*cough*)
17:03:20 <dons> liyang: i just saw your sudoku.hs ....
17:03:22 * wli attempts to ramify primes in Z[i]
17:04:01 <dons> whoa, is this a lego mindstorm haskell interface? http://www.forzanka.si/files/NXT.tgz
17:04:05 <liyang> dons: please accept my apologies. :3
17:04:16 <dons> liyang: i'm scared. i think you're dangerous now. :)
17:04:30 <wli> Where's liyang's Sudoku.hs?
17:04:42 <liyang> http://haskell.org/haskellwiki/Liyang/sudoku.hs
17:04:43 <lambdabot> Title: Liyang/sudoku.hs - HaskellWiki
17:05:07 <sioraiocht> @src fold
17:05:07 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:05:09 <sioraiocht> @src foldl
17:05:10 <lambdabot> foldl f z xs = lgo z xs
17:05:10 <lambdabot>     where lgo z []     =  z
17:05:10 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:05:15 <sioraiocht> @src fold1
17:05:15 <lambdabot> Source not found. stty: unknown mode: doofus
17:05:18 <sioraiocht> @src foldl1
17:05:18 <lambdabot> foldl1 f (x:xs) = foldl f x xs
17:05:19 <lambdabot> foldl1 _ []     = undefined
17:05:26 <dons> ok, this lego binding looks nice.
17:05:34 <dons> anyone got some good lego we can program?
17:05:57 <SamB> my sisters haven't returned my lego :-(
17:06:30 <ndm> SamB, kill them!
17:06:36 <liyang> (ooh, funky. There are people interested in Mindstorms here at Notts...)
17:06:41 <wli> That is something else.
17:06:53 <ndm> there are about 3 groups trying to port Yhc to mindstorms
17:07:05 <ndm> i think one guy is now pretty close
17:07:13 <SamB> ndm: I don't think my mom would like that
17:07:31 <SamB> ndm: what's the problem?
17:08:54 <ndm> SamB, in porting?
17:09:30 <SamB> yeah
17:09:35 <ndm> i've never done it, but basic problem is lack of memory on the machine
17:09:46 <ndm> you'd need a .hbc linker really, and i never got round to writing one
17:09:47 <SamB> so what if it only has 32k of RAM
17:10:01 <ndm> Prelude ~ 200Kb
17:10:15 <SamB> ah.
17:10:21 <SamB> you're porting the wrong compiler ;-P
17:10:36 <ndm> nope, thats the right compiler
17:10:45 <liyang> On a semi-related note, what's the status of GHC on ARM? Anyone played with it?
17:10:58 <ndm> what you need is whole program linking, which eliminates most of the libraries
17:11:01 <liyang> (or for that matter, /any/ Haskell compiler?)
17:11:17 <ndm> we have whole program linking at the core level, but not the bytecode level (yet) - it was always the plan
17:11:22 <ndm> liyang: i think someone ported Hugs
17:11:31 <chessguy> hmm. so how come Oleg's number-parameterized types haven't made it into libraries like Data.Array?
17:11:36 <liyang> ndm: with or without FFI?
17:12:07 * liyang wants to play with one of these shiny things: http://gumstix.com/
17:12:08 <lambdabot> Title: gumstix - way small computing
17:12:24 <mudge> the code example on the newtypes page doesn't make sense: http://haskell.org/haskellwiki/Newtype
17:12:25 <lambdabot> Title: Newtype - HaskellWiki
17:12:40 <dpiponi> liyang: I've run hugs on an nslug (an ARM device)
17:12:42 <ndm> liyang: no idea
17:12:50 <mudge> I get everything except for what the y1, y2, y3  examples are for
17:12:55 <SamB> liyang: what's the cdecl convention on ARM?
17:12:59 <ndm> chessguy: because his code is GHC only and pops brains
17:13:27 <chessguy> err
17:13:31 <chessguy> he says it's H98
17:13:39 <liyang> SamB: can't remember. Don't think it's anything too strange.
17:13:48 <Igloo> liyang: GHC works on Arm
17:13:55 <SamB> liyang: does it involve registers?
17:13:59 <liyang> dpiponi: coolness. :)
17:14:03 <Igloo> (unregisterised)
17:14:38 <SamB> liyang: if not, hugs' FFI shouldn't be hard to port
17:14:43 <ndm> chessguy: maybe then - its still bound to be brain poppingly complex...
17:14:45 <SamB> if it isn't already ported
17:14:46 <liyang> SamB: er... I haven't looked at it in years, and probably have it confused with a bunch of other architectures. ^^;
17:14:58 <ndm> SamB, easy to port because its written in assembly and very crufty?
17:15:06 <liyang> Igloo: this is looking better than hugs. :)
17:15:07 <chessguy> ndm, so? just look at the API, not the code
17:15:19 <SamB> ndm: that's the only way TO write it, you know!
17:15:44 <Philippa> liyang: you don't get GHCi though
17:15:54 <liyang> That's fine, I think.
17:16:11 <liyang> My coffee machine isn't l33t enough. I'm planning to make it l33t.
17:16:42 <Philippa> add b33r?
17:16:51 <chessguy> @remember liyang My coffee machine isn't l33t enough. I'm planning to make it l33t.
17:16:51 <lambdabot> Done.
17:16:54 <__nasa__> liyang: I have a 400xm (400 Mhz, 16 MB RAM) and a CF slot. I could try to get ghc running.
17:17:07 <syntaxfree> general fear-mongering completely unrelated to personal woes to happen in #haskell-blah in two minutes.
17:17:12 <__nasa__> (more likely, it would be a smaller variety, but w/e
17:17:13 <__nasa__> )
17:17:14 <SamB> ndm: in the infinite wisdom of the FFI commitee, you can't use the closure-conversion technique -- you have to generate C-compatible stubs dynamically
17:17:25 <Philippa> __nasa__: ouch, I wouldn't expect to compile much in that little RAM
17:17:35 <liyang> __nasa__: You're making the whole madcap scheme sound even more feasible... :D
17:17:38 <__nasa__> Yeah, I meant 16 MB Flash. 64MB RAM.
17:17:54 <Philippa> ah. Even then you want swap for most apps
17:17:58 <wli> Primes ramified.
17:18:06 <liyang> __nasa__: I wasn't thinking of actually running GHC on the poor things...
17:18:19 <liyang> as long as GHC can target them I'm happy.
17:18:22 <__nasa__> yeah, well, I was...
17:18:25 <Philippa> heh, I've done it on my zaurus
17:18:43 <__nasa__> nhc really, since apparently it is smaller.
17:18:48 <SamB> I'd use qemu or something ;-)
17:19:53 <__nasa__> ghc-6.6.1    0.1%  0:00.61   3    33    59  26.4M  11.4M  34.8M  64.6M -- Philippa, not much swapping (though this is a small app)
17:20:01 <liyang> or qemu because past experiences of cross-compilation resulted in massive brain hemorrhage.
17:20:04 <liyang> Good idea.
17:20:27 <Philippa> __nasa__: yeah, I just had to kill everything I didn't need for the link step on my interpreter
17:20:39 <Philippa> yeah, qemu works
17:20:49 <__nasa__> cool!
17:20:51 <SamB> liyang: yes, my understanding is that cross compiling isn't so much supported as possible in cases of extreme need ;-)
17:21:24 <SamB> Philippa: link step on your interpreter?
17:22:12 <syntaxfree> this Storm Network stuff is damn scary.
17:23:15 <__nasa__> How big is GHC? I only have a 1GB CF card...
17:23:24 <__nasa__> and a 128MB with me now.
17:23:48 <SamB> __nasa__: you can probably fit it on a 1GB card
17:24:02 <Philippa> SamB: as in, when ghc --make started linking it. "My interpreter" being the app I was building
17:24:09 <SamB> Philippa: ah.
17:24:23 <SamB> Philippa: I think that could be remedied by using a different ld(1)
17:24:46 <Philippa> it was pushing it on some of the modules too, and they weren't that big - I'd hate to think what would've happened if I'd had -O2 on
17:25:01 <liyang> __nasa__: my PPC binaries are 13MB compressed and 72MB otherwise. You could probably fit the whole lot on the 128MB card...
17:25:04 <__nasa__> 266MB it seems
17:25:17 <liyang> :-/
17:25:19 <__nasa__> liyang -- is that all the libraries?
17:26:04 <liyang> This is Fink's GHC 6.4.1 .deb, and that doesn't seem to depend on other GHC packages.
17:26:11 <__nasa__> of course, I could get rid of a lot (HGL, HOpenGL, X11, ...)
17:26:19 <liyang> Yes. :)
17:26:46 <__nasa__> but that is just 8.6MB...
17:27:59 <liyang> I can't imagine a threefold increase in binary size... no matter how different the ISA...
17:28:56 <ddarius> VLIW!
17:29:06 <__nasa__> Mine is from darwinPorts
17:29:47 <__nasa__> I ran:
17:29:48 <__nasa__> du -h /opt/local/lib/ghc-6.6.1/
17:29:54 <liyang> Oh wait. I'm using darwinPorts too.
17:30:14 <__nasa__> is that what you did?
17:30:31 <liyang> no, I kind of instinctively went for apt-cache show ghc...
17:30:42 <__nasa__> ah
17:31:18 <__nasa__> perl as a dependency!? That hurts...
17:31:19 <liyang> Yah. Mine's worse at 328MB. (GHC 6.6)
17:32:57 <ddarius> Perl and Haskell have had a long and interesting relationship.
17:33:54 <Lemmih> Is perl used in other places than in the evil mangler?
17:34:07 <dons> don't think so (maybe some odd corner of the build scripts?)
17:34:11 <ddarius> I don't believe so.  Not in a critical capacity.
17:35:24 <LoganCapaldo> well
17:35:51 <EvilTerran> and then there's the matter of the perl6-in-haskell thingy
17:35:51 <liyang> __nasa__: it's only so bad because of all the profiling libraries.
17:35:51 <LoganCapaldo> once pugs is ready we can use it to do the evil mangler thing and remove the perl dependency ;)
17:36:14 <liyang> What's the evil mangler?
17:36:46 <dons> hehe, hugh perkins is troll^h^h engaging with the erlang community too :) http://www.trapexit.org/forum/viewtopic.php?p=30946#30946
17:38:56 <phobes> I heard something about it earlier... has there been work on getting GHC to target GPUs?
17:39:07 <phobes> (or getting haskell in general to target GPUs)
17:39:11 <dons> yeah, that's an active project joined to the NDP/data parallel haskell project
17:39:21 <phobes> cool
17:39:40 <dons> haskell maps nicely to gpus: compiled speed, ffi calls to cuda. types for data parallelism
17:39:45 <ddarius> @google Haskerl
17:39:49 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
17:39:49 <lambdabot> Title: The Haskerl index
17:40:25 <dons> someone should drop that by reddit :)
17:40:32 * wli mutters something about linear algebra.
17:40:55 * syntaxfree murmurs in a sinister voice "Storm network ... storm network ... storm network..
17:41:05 * ddarius mutters something about geometric algebra.
17:41:49 * EvilTerran grumbles about skynet
17:42:17 <wli> Pray tell, what's geometric algebra?
17:42:37 <syntaxfree> ask dr. know. there's nothing he doesn't
17:42:39 <phobes> So um... haskerl is a joke... right... ?
17:42:42 <syntaxfree> @google geometric algebra
17:42:44 <lambdabot> http://www.mrao.cam.ac.uk/~clifford/
17:42:45 <lambdabot> Title: Cambridge University GA Research Group
17:44:52 <liyang> Wow: http://www.tilera.com/products/processors.php ::drool::
17:44:53 <lambdabot> Title: Tilera Corporation
17:45:03 <phobes> It's kind of a cross between algebraic algebra and geometric geometry
17:45:30 <ddarius> And nothing at all like algebraic geometry.
17:45:31 <wli> That's somewhat less fundamental than linear algebra.
17:47:20 <liyang> (Not as nifty as Alphamos^WBroadcom's VideoCore, but still droolworthy.)
17:52:30 <SamB> phobes: it's more of a joke than pugs...
17:54:21 <phobes> dons:  What was the haskell front-end project that you suggested to me the other day?
17:55:50 <phobes> Anyone know of a project that aims to put a prettier imperative face on haskell?
17:57:05 <dons> some people write preprocessors for IORef code, or define domain specific languages for the task
17:57:13 * liyang finishes reading Haskerl and is scared.
17:57:32 <liyang> Isn't the monadic syntax essentially what we have now?
17:58:14 <phobes> Haskell's monadic syntax is a very light sugar
17:58:17 <vincenz> @seen psykotic
17:58:17 <lambdabot> psykotic is in #haskell-blah and #haskell. I don't know when psykotic last spoke.
17:58:20 <ddarius> phobes: See augustss blog
17:58:49 <ddarius> Though how you get "prettier imperative face on haskell" I have no idea.
17:59:01 <phobes> ddarius: I do :)
17:59:13 <phobes> at least I think I do
17:59:32 <vincenz> Les gouts et les couleurs, cela ne se discute pas
17:59:58 <dibblego> is there a formal definition for function equivalence somewhere?
18:00:06 <dibblego> @foldoc function equivalence
18:00:09 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
18:00:09 <lambdabot> function
18:00:09 <lambdabot>  
18:00:09 <lambdabot>         1. <mathematics> (Or "map", "mapping") If D and C are sets
18:00:09 <lambdabot>         (the domain and codomain) then a function f from D to C,
18:00:11 <lambdabot> [26 @more lines]
18:00:25 <liyang> (And actually, I do want if :: IO Bool -> a -> a; or more generally, case :: Monad m => m Bool -> (... -> alpha) -> ... -> (... -> alpha) -> alpha )
18:00:57 <liyang> s/m Bool/m beta/
18:01:01 <wli> There's a lot more where you need linear algebra to get anything done.
18:01:08 <ddarius> f = g if forall x. f x = g x
18:01:39 <dibblego> ddarius, I just wrote that in English, but wondered if there might be a better definition
18:01:42 <ari> instance (Enum a, Bounded a, Eq b) => Eq (a -> b) where f == g = map f [minBound..maxBound] == map g [minBound..maxBound]
18:02:07 <reffie> when you program, do you actually see the whole code structure before you write it?
18:02:17 <ddarius> dibblego: That's the definition of extensional equality of functions.
18:02:39 <ddarius> reffie: In broad strokes, and then I thoroughly depart from it.
18:04:53 <reffie> ddarius why do you depart from it?
18:05:03 <ddarius> reffie: Reality.
18:05:14 <ddarius> I usually think of some better way as I actually work on the code.
18:05:34 <reffie> is that true also in non-haskell languages for you?
18:05:42 <ddarius> Yes.
18:07:14 <dons> http://rubyforge.org/projects/ruskell/ !
18:07:16 <lambdabot> Title: RubyForge: Ruskell: Project Info
18:07:50 <ddarius> Clearly that should have been called raskel
18:08:02 <dons> i can't work out if its a bridge/library/ffi or a new language?
18:09:00 <ddarius> It sounds like some kind of FFI.
18:10:48 <vincenz> dons: Nowadays, all those things are rather intermingled.
18:12:39 <ddarius> Shite, I really need to do something about disk space.
18:14:32 <vincenz> ddarius: go store >> buy disk >>= insert computer
18:14:47 <ddarius> laptop
18:15:02 <ddarius> My real solution is burn SICP lectures to DVD, delete
18:15:09 <ddarius> Burn hamming lectures, delete
18:15:10 <stepcut> ddarius: amazon S3 ;)
18:15:12 <vincenz> go store >> buy disk >>= insert laptop >> buy external case >> transfer data
18:15:20 <ddarius> I have space, just not on this partition.
18:15:36 <vincenz> I guess this is what agile programming feels like :)
18:15:39 <vincenz> constantly shifting specs
18:15:50 <ddarius> I need to poke at the NTFS settings so I can write to it.
18:16:06 <vincenz> ddarius: or do it the other way, boot to iwndos and get the ext2fs driver
18:26:07 <ddarius> 3gig available, yay
18:36:57 <Tac-Tics> Everyone's asleep for labor day it seems
18:37:09 <Pseudonym> Sorry, what day?
18:37:25 <Tac-Tics> http://en.wikipedia.org/wiki/Labor_Day_%28United_States%29
18:37:27 <lambdabot> Title: Labor Day (United States) - Wikipedia, the free encyclopedia
18:37:44 <Pseudonym> Not everyone is in the USA, you insensitive clod.
18:37:53 <earnest> :)
18:37:59 <earnest> i'm trying to install my debian system
18:38:02 <Tac-Tics> Everyone knows that the USA is a superset of the Universe
18:38:02 <SamB> dons: sleep you?
18:38:03 <earnest> since yesterday
18:38:06 <ddarius> All Americans are insensitive clods.
18:38:11 <Tac-Tics> =-P or at least all Americans know it
18:38:22 <ddarius> Tac-Tics: Which is everyone, right?
18:39:52 <Tac-Tics> technically, I don't actually know
18:40:37 <Tac-Tics> but I'm sure a slight modification of my above statement would make an interesting version of Russel's paradox
18:44:11 <glguy> Pseudonym: we know that everyone isn't *in* the US, but we at least expect that if you are going to consume our Internet and media, you'll acknowledge our holidays ;-)
18:44:31 <Pseudonym> I acknowledge that you guys have a holiday.
18:44:39 <Pseudonym> Happy now?
18:44:46 <SamB> Pseudonym: fine!
18:44:53 <Pseudonym> Now if you're going to use GHC, you should acknowledge British holidays.
18:45:41 <Tac-Tics> pseudonym: I will celebrate any holiday my boss lets me take. Please let her know of your those Brittish holidays, because I could use more time to myself to learn Haskell.
18:45:45 <glguy> what is "british"?
18:45:54 <SamB> Pseudonym: if ghc celebrated them we might!
18:46:20 <Pseudonym> Oh, good idea!
18:46:36 <Pseudonym> Sorry, I can't compile your program today, being Queen's Birthday.
18:46:38 <SamB> of course, I don't want GHC to try and take off for holidays
18:46:44 <SamB> that would be supremely annoying
18:47:06 <SamB> just when you got a lovely free day to do some Haskell hacking, GHC refuses to compile...
18:47:15 <LoganCapaldo> it's a truism
18:48:23 <Pseudonym> "I'm in a huff, because I didn't get a knighthood this year."
18:48:35 <Tac-Tics> SamB, maybe Lisp and ML have such trouble with their compilers, but luckily for us, GHC is side-effect free and knows nothing of holidays
18:48:47 <lambdabot> Say, maybe I could be Dame Lambdabot.
18:49:16 <LoganCapaldo> Oooo my compiler
18:49:21 <ddarius> I can't work, my compiler is on holiday.
18:49:22 <LoganCapaldo> is taking a vacation
18:49:26 <SamB> Tac-Tics: latter may be true
18:49:28 <SamB> but former is not
18:49:42 <Tac-Tics> oh?
18:49:51 <SamB> it has all manner of side effects!
18:49:57 <Pseudonym> Sadly, it reduces the "compiling" excuse.  See also the recent xkcd.
18:50:04 <Tac-Tics> hehe
18:50:16 <LoganCapaldo> I use that excuse all the time now
18:50:26 <LoganCapaldo> Which reminds me, I need to buy some swords...
18:50:38 <SamB> "Yes I murdered my coworker and slept with his wife, but it's okay, I'm compiling"?
18:50:41 <ddarius> GHC celebrates British holidays, I'm American.  No trouble here.
18:50:42 <Tac-Tics> Using side effects in Computer Science is like breaking the 4th wall in Theater.
18:51:08 <SamB> Tac-Tics: very funny when you do it right?
18:51:40 <ddarius> But usually done wrong?
18:51:51 <SamB> heh
18:51:54 <Tac-Tics> well, funny in the sense of "haha, when I get fired, the guy who replaces me will never figure out this code"
18:52:34 <SamB> Tac-Tics: that sounds like one of those sprite comics where the author never did learn to use whole-number scales for the sprites
18:53:29 <Tac-Tics> I've never heard of such a comic, link?
18:53:46 <SamB> I'm not sure I've seen an actual one, but I've seen parodies...
18:53:53 <Pseudonym> ?where xkcd
18:53:53 <lambdabot> I know nothing about xkcd.
18:53:59 <SamB> @go xkcd
18:54:01 <lambdabot> http://xkcd.com/
18:54:01 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
18:54:02 <Tac-Tics> ah xkcd
18:54:04 <Pseudonym> Ah, right.
18:54:11 <SamB> Tac-Tics: that's not even a spritecomic
18:54:29 <Tac-Tics> My favorite is this one http://xkcd.com/224/
18:54:30 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
18:54:37 <LoganCapaldo> but it certainly is a spritely one
18:58:55 <SamB> man I wish I could do text search of webcomics...
18:59:14 <ddarius> ORC
18:59:16 <ddarius> er OCR
18:59:28 <SamB> I want to see if I can find "bad sprite comic" or "bad spritecomic" in anyone's lines
18:59:30 <LoganCapaldo> SamB, you can if the webcomic is dillegent enough
18:59:40 <LoganCapaldo> *webcomic creator
18:59:40 <Tac-Tics> SamB: that might be a cool web app, a web comic search engine
18:59:47 <LoganCapaldo> also makes for better adsense :)
19:00:53 <ddarius> nautilus' CD burner thing can't hack it
19:03:44 <SamB> Tac-Tics: well, if you go through the entire archives of Bob and George you might find a parody... then again you might find the genuine article on the forums ;-)
19:05:32 <Tac-Tics> Random question: who was it that wrote in their blog that a programming language was part tool and part religion? I'm thinking it was Paul Graham, but I can't find the article
19:06:10 <Pseudonym> Phil Wadler, probably.
19:06:19 <Pseudonym> He talked about this in his address at Google.
19:07:10 <monochrom> It is true.
19:07:47 <ddarius> Where can I get the Programming in the Age of Concurrency STM video without beating my head against the freakin' streaming multimedia?
19:08:17 <aFlag> hm, this is really stupid but how do an exhaustive case of where I'm matching Chars?
19:08:29 <ddarius> Have a catchall case.
19:09:25 <aFlag> yeah, but what would that clause be in the case of Char? I tried _ but it didn't work, maybe I'm doing something wrong
19:09:42 <aFlag> oh, nevermind
19:09:47 <aFlag> it was an indentation problem
19:10:36 <Pseudonym> Matching Chars, though, is one situation where you really want dense switches.
19:10:45 <Pseudonym> Which GHC doesn't support yet.
19:11:04 <ddarius> Pseudonym: ?
19:11:18 <dons> ddarius: do you have mplayer? you could write the stream to disk.
19:11:29 <Pseudonym> ddarius: The case switch would be better implemented with an array lookup.
19:12:36 <conal> hey -- i have an tool project idea i'd like to float and see who's interested
19:13:14 <Pseudonym> I'd be interested in a floating tool.
19:13:20 <ddarius> Elaborate.  The difference with the vectored dispatch?
19:13:36 <conal> the tool would convert a set of haskell source modules into a Tiddlywiki.  One tiddler per top level def.  all source is syntax colored and hyper-linked.
19:13:40 <conal> @go tiddlywiki
19:13:41 <lambdabot> http://www.tiddlywiki.com/
19:13:46 <Pseudonym> ddarius: I need to check.  I got this complaint second-hand.
19:14:27 <conal> the cool thing about tiddlywikis is that when you click on a link, the (micro)content gets added to the page, rather than replacing it.
19:14:45 <monochrom> Nice.
19:14:53 <conal> so one could start with a single def and fill in more by clicking on identifiers.
19:15:16 <conal> you can move tiddlers (defs) around on the page.  close or fold them.
19:15:23 <conal> all very self-organizing.
19:15:43 <conal> documentation and types would get folded in also.
19:16:24 <monochrom> It is consistent with my "Can programming be liberated from the Plain ASCII File?"
19:16:52 <Tac-Tics> monochrom: yes, w/ plaintext unicode files ^^
19:17:06 <conal> yep
19:17:20 <monochrom> We already talk of generic zipper, an inversion of control applied to data and fold functions.
19:17:46 <monochrom> Now we also ought to apply an inversion of control to the presentation of program code.
19:17:52 <conal> include pictures etc in the tiddlers as part of the documentation.  maybe interactive demos
19:18:11 <conal> monochrom: so that it's editable?
19:19:44 <monochrom> Perhaps a web page should be read-only. But out-of-order editing in an IDE is no problem, even desirable. Anyway, zipper is not just about editing; you can use it read-only, and it is still a better traversal than traditional traversals.
19:20:17 <conal> has anyone here played with tiddlywiki?  it's great fun.
19:20:41 <ddarius> conal: I tiny bit (not as an author)
19:20:55 <ddarius> The first one I went to had me lost for a minute.
19:21:08 <ddarius> Once I saw what it was doing I was entertained.
19:23:35 <conal> i wonder what tools would help to get an implementation going.  there's a lot in common with haddock and some with hscolour.
19:23:43 <monochrom> Yeah, it has this zipper-like inversion of control, i.e., "hole and context", "delimited continuation". You click on a hyperlink and it is a shift command.
19:24:00 <dons> oh hmm, that's interesting, monochrom
19:24:05 <dons> yes, since you just visit neighbours
19:24:27 <conal> monochrom: i like that
19:24:56 <dons> you could use type algebra to derive the data structure for the web :)
19:26:24 <monochrom> I spent a whole week a week ago to explore delimited continuation. Now I see it everywhere, even where it is not there.
19:26:55 <ddarius> monochrom: If you try hard enough, you should be able to get delimited continuations just about anywhere.
19:27:03 <monochrom> But don't worry, when I spent a whole week many years ago to learn monads, it was the same, I saw monads everywhere, even where it was not there.
19:31:28 <sioraiocht> dcoutts: ping
19:32:11 <stepcut> delimited continuations are on the top of my ToLearn list
19:32:16 <stepcut> well, near the top
19:32:58 <dons> do you think these topics are discussed in any other language community?
19:33:05 <sioraiocht> dons: no
19:33:08 <ddarius> dons: Some, definitely.
19:33:30 <ddarius> But then we rarely get into the intricacies of hygenic macro expansion, so...
19:33:39 <dons> or are we going to be playing with delimited continuations for the next 10 years, while the everyone else says they're too hard
19:33:59 <sioraiocht> dons: I would say that at the very least, what we consider normal is considered extremely esoteric elsewhere
19:34:03 <dons> ddarius: though foundational control mechanisms are a bit more generally applicable concepts
19:34:12 <dons> its like finding a new data structure, that only we get to use
19:34:18 <dons> you know, like finger trees :)
19:34:30 <dons> or stream fusion. i love having all the toys!
19:34:32 <stepcut> dons: are you in the US now ?
19:34:37 <dons> stepcut: yep
19:34:50 <stepcut> dons: fun!
19:34:51 <ddarius> Schemers have been playing with delimited continuations for a while now and presumably some MLers.
19:34:57 <dons> yeah, its been a lovely couple of days.
19:34:59 <ddarius> Or are you counting them?
19:35:13 <dons> ddarius: i suppose i should :)
19:35:59 <dons> sioraiocht: the thing though is that concepts like monads or delimited continuations are foundational computer science. its a bit scary that pretty much only this community understand them
19:36:10 <ddarius> I don't know.  The mainstream has been doing better recently at recognizing useful theoretical work than it has for essentially it's entire history.
19:36:19 <sioraiocht> dons: ...have you USED any software recently? ;)
19:36:39 <dons> sure, things with monads in them
19:36:57 <ddarius> xmonad ho!
19:37:03 <dons> ddarius: yeah, there's only so many dead ends you can walk down before you get to where the action is at ;)
19:37:04 <sioraiocht> ddarius: I would say that formal methods and structured programming are definitely being recognised as more and more important
19:39:10 <monochrom> http://www.vex.net/~trebla/humour/book_for_sale.html  on structured programming
19:39:12 <lambdabot> Title: Book For Sale
19:39:19 <wli> I'm pessimistic.
19:39:43 <wli> I doubt the mainstream will ever get with it.
19:40:18 <ddarius> wli: No one said get with it.  Just better.
19:40:41 <EvilTerran> hehe... If somebody posts the question, "What is the maximum number of IPv4 ports I can create in my application? I start running into trouble after around 60,000," your response is probably going to be "What the heck are you doing that needs 60,000 ports?" -Raymond Chen
19:40:56 <monochrom> hahaha
19:43:01 <EvilTerran> (http://blogs.msdn.com/oldnewthing/archive/2007/03/01/1775759.aspx)
19:43:02 <lambdabot> Title: The Old New Thing : If you have to ask, you're probably doing something wrong
19:43:25 <wli> ddarius: I expect the mainstream to get worse, actually.
19:44:20 <liyang> monochrom: maybe it's the /b/-tard in me but you should have posted your version up next to the original. (Wherever you saw it.)
19:44:23 <ddarius> wli: Any rational reasons or sheer pessimism?
19:44:25 <wli> ddarius: Rampant anti-intellectualism, total rejection of anything that smells remotely mathematical, ad hoc BS pulled out of people's arses like perl taking over everywhere, etc.
19:44:59 <liyang> monochrom: then took photographs. And posted it to some anonymous discussion board.
19:45:03 <glguy> the biggest issue is that the demand for programming will increase, and that demand will be filled by people less capable than those already doing it
19:45:34 <sioraiocht> glguy: perhaps, but there is a critical point at which software will become so large it will not function without a more rigourous approach
19:45:40 <sioraiocht> I think we're getting close to that point
19:45:43 <wli> ddarius: Not to mention R&D getting killed en masse during the huge offshoring, merger, & acquisition fest.
19:46:20 <monochrom> liyang: The original was in a local newsgroup. I posted first to that same newsgroup. The web page is for archive and perpetuation purpose. I think it was kind of hard to take a meaningful photograph of a newsgroup 10 years ago.
19:46:23 <ddarius> wli: We'll see. I think many of these aspects look worse than they actually are.
19:46:25 <sioraiocht> glguy: IMO, there will also be less issues the farther away we get from the C++ era =p
19:46:36 <ddarius> At least in some aspects.
19:46:56 <liyang> monochrom: Good good. :)
19:47:06 <ddarius> glguy: If the foundations are better, we can still come out ahead.
19:47:12 <wli> Well, for futuristic affairs, the window has essentially already closed for numerous reasons.
19:47:27 <ddarius> A complete doofus in C# is not as much a liability as a complete doofus in C.
19:48:16 <wli> If you want to see windows of opportunity closing for all time, observe x86-64.
19:49:11 <wli> The 64-bit transition for the mass market was the only opportunity ever for a remotely decent architecture to be commodity/massmarket/etc.
19:49:15 <dons> one hope is that C# will have monads deep enough you'll be forced to be competent in modern CS to get a job in it
19:49:49 <ddarius> My hope is that being less competent becomes less and less of an issue.
19:50:04 <wli> It's gone. The mass market is locked into x86-64 for all eternity, or at least the remainder of the lifetime of the field of computing.
19:50:16 <vincenz> I sincerely doubt that
19:50:24 <vincenz> We'll see another paradigm shift soon as we go towards multicore
19:50:36 <dons> the market is already getting kinda weird
19:50:36 <vincenz> (and when I say multicore, I mean more than 4-8)
19:50:37 <ddarius> I'm certain that that is false, unless we manage to kill our selves in the not at all distant future.
19:50:43 <vincenz> You want to go back to simpler processors that fail easily
19:50:47 <dons> with bizarre new architecutres being churned out monthly , it seems
19:51:05 <wli> dons: What bizarre new architectures?
19:51:14 <monochrom> I like "the remainder of the lifetime of the field of computing" :)
19:51:19 <dons> tiny 128 parallel streaming cpus and so forth
19:51:22 <ddarius> Most people here have more of their life remaining than the entire history of computing.
19:51:55 <ddarius> Amorphous computing, ubiquitous computing.  Tiny, "weak", commodity chips everywhere.
19:52:06 <ddarius> Heck, embedded people don't care about x86-64
19:52:07 <vincenz> dons: hah
19:52:09 <vincenz> dons: there's worse
19:52:15 <vincenz> dons: like 4096 1-bit processors
19:52:32 <vincenz> ddarius: of course we don't, they suck power like ...
19:52:43 <monochrom> monads
19:52:59 <liyang> lulz
19:53:09 <liyang> Good timing. Heh.
19:53:15 <monochrom> hehehehe
19:53:25 <dons> the sudden emergence of lots of new designs is great though
19:53:29 <vincenz> Though I do think that x86 will simplify, there's a merge going on between mainstream and embedded, which explains Intel's presence at embedded conferences. I really think they'll go to simpler architectures.  Since soon failure will be a fact of life, having 4 things that are really complex doesn't really help much
19:53:38 <dons> even things like 'transactional memory on a chip' make things interesting
19:53:49 <vincenz> dons: oh I saw a presentation on that
19:53:53 <vincenz> dons: it was a bit dissapointing tho
19:53:54 <ddarius> vincenz: Exactly.
19:54:03 <ddarius> vincenz: Have you checked out amorphous computing?
19:54:05 <wli> The relevance of embedded to CPU's people interact with in deep ways is questionable.
19:54:15 <vincenz> ddarius: you mean asynch?
19:54:29 <wli> That said, embedded dwarfs PC/desktop/etc. numerically.
19:54:32 <ddarius> wli: The relevance of the "personal computer" in the future is far far more questionable.
19:54:34 <vincenz> Since soon we'll have NoCs, asynch computing might be something that'll happen.
19:54:44 <ddarius> @google "amorphous computing"
19:54:44 <vincenz> Islands of synchonous processors in a sea of asynch connect
19:54:46 <lambdabot> http://www-swiss.ai.mit.edu/projects/amorphous/
19:54:46 <lambdabot> Title: Amorphous Computing Home Page
19:55:05 <monochrom> amorphous computing means using sand silicon rather than crystalline silicon?  <duck!>
19:55:20 <vincenz> ddarius: Oh no, though I've helped on a paper working on something similar
19:55:26 <sioraiocht> ddarius: I don't envision a world where they don't exist, but a personal internet device would replace a good portion of PCs in use right now without a lose of use
19:55:47 <monochrom> (I am sorry I paid attention to chemistry classes. XD)
19:55:49 <wli> ddarius: There will still be workstations a la PC's.
19:55:51 <johnnowak> how is a laptop not a personal internet device?
19:56:03 <sioraiocht> johnnowak: It is, but it's more
19:56:13 <sioraiocht> johnnowak: I'm thinking more giant iPhones =p
19:56:18 <wli> ddarius: Their prevalence will decline.
19:56:20 <ddarius> sioraiocht: I can easily imagine a world where there are no apparent "computers" at all.
19:56:28 <ddarius> +wli:
19:56:45 <sioraiocht> ddarius: In such a case, what sort of device would, say, programmers use?
19:56:49 <wli> ddarius: They will not be eliminated. Their prevalence will decline.
19:57:35 <ddarius> wli: I agree in some regards.  There will still be some someplaces, but they will essentially be non-existant.  Certainly, they won't exist in the mind of the populace.
19:57:44 <Caelum> if I want to make a signature like Ord a => [a] -> [a] but I want the function to work on empty lists too, what do I make it?
19:58:14 <int-e> @type []
19:58:16 <lambdabot> forall a. [a]
19:58:17 <ddarius> sioraiocht: The same thing everyone else used.  Computing won't go away.  Computers won't.  Boxes that sit on desks, or even little boxes we carry around will.
19:58:38 <int-e> Caelum: it'll work on empty lists with that signature.
19:58:44 <int-e> @type sort []
19:58:47 <lambdabot> forall a. (Ord a) => [a]
19:58:53 <sioraiocht> ddarius: you thinking like, completely distributed computing?
19:58:56 <LoganCapaldo> Caelum, the emptyness of a list is not encoded in the type
19:59:24 <LoganCapaldo> [] has the same type as [1] has the same type as [7,3,0]
19:59:26 <ddarius> sioraiocht: Yes.  Everything would be ridiculously distributed.  And there would be way way way more computers (albeit often much simpler ones).
19:59:31 <int-e> Caelum: you may have to fix the type of the empty list.
19:59:51 <ddarius> You'll have computers in your clothing, in you building materials, in your bloodstream.
19:59:53 <vincenz> the real problem is
20:00:01 <Caelum> thank you
20:00:02 <vincenz> Programming languages still assume turing machines
20:00:12 <vincenz> Turing machines do not encapsulate the cost of memory
20:00:12 <ddarius> vincenz: Hence amorphous computing.
20:00:26 <vincenz> Memory/data is the main bottleneck of modern devices, not computation
20:01:02 <ddarius> A large part of that is that memory is getting "farther" away from the computer.
20:01:09 <vincenz> Indeed, and spread out
20:01:15 <Tac-Tics2> How far away is the Internet from my computer?
20:01:23 <vincenz> Memory is not a flat hierarchy, never has bene, though the embedded community has been aware of that longer
20:01:40 <vincenz> Or at least, focussed on it longer
20:02:02 <glguy> any freebsd users?
20:02:43 <glguy> more specifically, anyone know what the livefs cd is for?
20:03:11 <phobes> I think that's to raise awareness for the environment
20:04:25 <wli> I'm not convinced the futuristic scenarios are going to happen.
20:04:31 <monochrom> sometimes "live cd" refers to a bootable cd for experimenting with an OS (the one on the cd) without writing to the hard disk. perhaps "livefs cd" means the same.
20:04:53 <glguy> monochrom: yeah, I know about livecds, i just didn't know what a livefs iso is
20:05:35 <johnnowak> glguy: you might ask in #freebsd if you'd like someone to yell at you
20:05:45 <glguy> johnnowak: they don't seem to know
20:05:51 <monochrom> Hrm! Perhaps livefs is yet another filesystem, and "livefs cd" means this cd uses that filesystem, not very compatible with certain common assumptions.
20:05:53 <ddarius> wli: I'm sure aspects of them will plus many things that I would never think of.  And many things will stay the same too.
20:05:56 <glguy> they are too busy bitching about #c++ and which -j flag ot use
20:06:03 <johnnowak> sounsd about right
20:06:41 <ddarius> Pencils have been around for a long long time and they are not going anywhere for a long long time.
20:06:55 <monochrom> Here is another guess. "livefs" refers to a new filesystem designed for live cds.
20:06:59 <Tac-Tics2> pencils?
20:07:04 <Tac-Tics2> I haven't used one of those in a long time =-P
20:07:22 <sioraiocht> Tac-Tics2: that means you haven't been doing math by hand, I hate you
20:07:25 <wli> Well, things depend on a number of factors.
20:07:26 <Tac-Tics2> hehe
20:07:32 <Tac-Tics2> No no, pencils are great
20:07:42 <Tac-Tics2> but still, mechanical pencils are fairly recent in the overall history of pencils
20:07:54 <ddarius> I hate mechanical pencils.
20:07:57 <wli> I'm almost unable to write with pens or pencils at all due to RSI.
20:08:00 <monochrom> A possible feature of this filesystem is: during runtime, you can write, and if you write, it's stored in RAM.
20:08:09 <Tac-Tics2> ddarius: why so?
20:08:14 <vincenz> all we need is persistant ram that's as fast as dram
20:08:21 <ddarius> Actually, pencils are fairly recent, but still writing implements have not fundamentally changed in thousands of years.
20:08:25 <vincenz> (for a given size)
20:08:49 <ddarius> Tac-Tics2: I bear down pretty hard and I don't like the way they feel or the lead feels on the page.
20:09:02 <Tac-Tics2> I see I see
20:09:03 <Pseudonym> Pencil technology is quite amazing, actually.
20:09:12 <Pseudonym> I'm particularly impressed with Col-Erase.
20:09:23 <Pseudonym> I've been doing a bit of drawing with those lately.
20:09:26 <Tac-Tics2> I don't like how regular pencils vary in their width after a little use
20:09:28 <FMota> :o. I'm sorry, I skimmed over this page and say the words 'pencil' and 'size'... and I guess I misread the first the first time... so, yeah...
20:09:33 <Tac-Tics2> I tend to press pretty hard too
20:09:39 <FMota> *window, not page
20:09:55 <Pseudonym> FMota: I once did a google search to find out the airspeed of an unladen swallow using the terms "speed" and "swallow".
20:09:57 <sorear> .
20:10:09 <ddarius> Pseudonym: Yes, but if I gave someone a thousand years ago a pen that can write upside-down in space* they'd have no trouble using it.
20:10:10 <vincenz> the problem with regular pencils is their non-constant point.  Either you have a very sharp point which gives unsatisfactory marks, or a really thick one that makes it impossible to write small.
20:10:18 <ddarius> * yes there is no "upside-down" in space
20:10:21 <vincenz> 0.7 mechanical pencils ftw
20:10:35 <Pseudonym> vincenz: That's why artists often carry sandpaper.
20:10:44 <FMota> Pseudonym: Sorry to hear that. :o
20:10:48 <Pseudonym> There's no easier way to maintain your point quickly.
20:11:02 * ddarius should get some sand paper.
20:11:07 <sorear> @seen ChilliX
20:11:07 <lambdabot> ChilliX is in #ghc and #haskell. I don't know when ChilliX last spoke.
20:11:11 <ddarius> 0.7, blech too dull.
20:11:12 <Tac-Tics2> Chalk is kinda cool how you can erase it
20:11:19 <monochrom> I use a fountain pen. Problem solved.
20:11:21 <vincenz> Tac-Tics2: sure, dusty as hell
20:11:21 <ddarius> I want to try out pastels.
20:11:22 <Tac-Tics2> Pencil + paper leads to a lot of waste
20:11:40 <Pseudonym> Tac-Tics2: No!
20:11:41 <ddarius> Tac-Tics2: I usually use graphite.  It erases well enough.
20:11:45 <Pseudonym> The secret is you mark up the paper first.
20:11:52 <Tac-Tics2> not that I care so much about pollution type stuff, but finding a clean notebook in my house is hard
20:11:53 <Pseudonym> Rub it with graphite, then erase to make it white.
20:12:02 <sorear> Quick!  Somebody advocate typewriters!
20:12:03 <Pseudonym> No waste that way.
20:12:16 <Tac-Tics2> dvorak typewriters?
20:12:21 <ddarius> Graphite powder!
20:12:29 <johnnowak> Tac-Tics2: far better than drawing 250 watts via your computer
20:12:53 <wli> About all I can do is type. I can't write legibly anymore.
20:13:18 <Tac-Tics2> wli: indeed
20:13:28 <Tac-Tics2> writing legibly is a challenge
20:13:36 <wli> It's not disuse. It's RSI.
20:13:36 <Tac-Tics2> only my mathscript comes out nicely any more
20:13:45 <Weremanatee> @hoogle [(a, b)] -> a -> b
20:13:46 <lambdabot> No matches, try a more general search
20:13:51 <Pseudonym> http://www.artsupplies.co.uk/item.php?item_id=4502
20:13:53 <lambdabot> Title: Ken Bromley Art Supplies - Sandpaper Block
20:13:56 <vincenz> Weremanatee: lookup
20:14:04 <vincenz> @hoogle [(a,b)] -> a -> Maybe b
20:14:04 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
20:14:05 <Pseudonym> In case anyone is curious.
20:14:09 <wli> Carpal tunnel, tendonitis, whatever you want to call it.
20:14:19 <monochrom> I had a friend who really wanted to save paper. (He was poor.) To practice for those dreadful Hong Kong math exams, we needed lots of drills (on calculus, say), and so lots of paper. He would take a blank paper, and use a light pencil and do math on it. Then he would use a blue pen to do math superimposed on that. Then he would use a bright red pen to do math superimposed yet on that. Then he feels ok to discard that piece of
20:14:19 <monochrom>  paper.
20:14:20 <vincenz> geekity
20:14:50 <ddarius> Pseudonym: Curious?
20:14:52 <Cale> I just influence things subtly and pervasively such that my message will be encoded in national and global statistics.
20:14:55 <Pseudonym> Woo, the Student Palimpsest.
20:15:03 <Pseudonym> ddarius: The link I gave.
20:15:17 <Tac-Tics2> does anyone remember that research project a while back which stored data on paper instead of a magnetic disk?
20:15:28 <Adamant> it was called punch cards
20:15:32 <glguy> and barcodes
20:15:32 <Tac-Tics2> humans are rather inefficient at storing data on paper by hand
20:15:34 <ddarius> monochrom: He can't find a patch of dirt?
20:15:41 <Cale> Tac-Tics2: yeah, the one with BS claims of storage density?
20:15:48 <Tac-Tics2> something like that
20:16:13 <Tac-Tics2> Why do you call BS on it?
20:16:18 <vincenz> Not finding many books in Atlanta airport, I bought "Anthem" by Ayn Rand, and "The Naked Sun" by Asimov.  (Haven't read asimov yet, and read "objectivist epistemology" of rand a long time ago) Anyone know if they're good?
20:16:21 <ddarius> Pseudonym: Yes, I got that.  Curious about what?
20:16:35 <Cale> Because it has several orders of magnitude too high a storage density.
20:16:58 <Tac-Tics2> it's still an interesting idea in concept
20:17:01 <ddarius> I've only read a short story by Asimov ("The Dead Past" which is amazingly good) and "Atlas Shrugged" by Ayn Rand.
20:17:07 <Cale> Like, even assuming some pretty incredible things about what could be done with ordinary paper.
20:17:15 <vincenz> And, anyone know the title/author of the book where they inhabit these other planets and then terraform them with some energy grid, and some people start to have the ability to influence it directly by mind?
20:17:21 <Weremanatee> vincenz: Yes, they are good.
20:17:38 <vincenz> I saw another rand book in bogota, it seemed good, but books in colombia in english are REAELLY expensive
20:17:49 <Pseudonym> ddarius: About artist's sandpaper.
20:17:51 <wli> vincenz: I'd recommend "NATO's Secret Armies" by Daniele Ganser over anything Rand wrote.
20:17:52 <Weremanatee> I read Anthem in a single night. It's short and sweet.
20:17:54 <vincenz> (like 15-30 dollars)
20:17:55 <monochrom> The Naked Sun is wicked. This means cool.
20:18:01 <Pseudonym> BTW, nothing by Ayn Rand is good fiction.
20:18:13 <Pseudonym> That's also mostly true of Asimov, to be honest.
20:18:36 <vincenz> And I couldn't resist and bought the third splinter cell by clancy
20:18:44 <wli> vincenz: Anything by William Blum is also good.
20:18:44 <Pseudonym> Mind you, they wrote better fiction than I do.
20:18:47 <vincenz> (read that one in one go on the plane, though it was a bit too much action based)
20:19:04 <vincenz> wli: thanks
20:19:10 <monochrom> Action on paper. Now that's hard.
20:19:11 <Weremanatee> Pseudonym: You're full of it.
20:19:17 <Tac-Tics2> wtf, why did I leave the room?
20:19:20 <Cale> http://www.youtube.com/watch?v=RdM6z1gU5yk
20:19:40 <Pseudonym> Weremanatee: Perhaps, but not for this reason.
20:19:47 <wli> vincenz: Also anything by Chalmers Johnson
20:19:59 <wli> vincenz: Or John Perkins
20:19:59 <Weremanatee> Pseudonym: With the garbage that fills the shelves these days, most of Rand and Asimov constitute great fiction by comparison.
20:20:26 <Adamant> I'd recommend Neal Stephenson. leave politics to the politicos.
20:20:28 <vincenz> wli: what style are they?
20:20:34 <Pseudonym> Weremanatee: Sturgeon's Revelation applies.
20:20:43 <Weremanatee> These are conceptual authors. They have a point. This is rare.
20:20:54 <Pseudonym> That's true, but it's still not good fiction.
20:20:59 <wli> vincenz: Nonfiction about the US espionage campaigns.
20:21:10 <vincenz> any good scifi books?
20:21:21 <Pseudonym> I'm not knocking them.  (I'll do that on other grounds, if I want to.)
20:21:31 <wli> vincenz: I don't read much fiction, never mind science fiction.
20:21:33 <vincenz> I've mostly read fantasy in the past (r.a. salvatore)
20:21:36 <Weremanatee> I haven't heard your definition of good fiction, so I cannot say for sure.
20:22:03 <Adamant> vincenz, Neal Stephenson is solid sci-fi and decent "near future" fiction
20:22:08 <vincenz> Oh yes, for worst book of the year (which I actually BARBEQUED on my bbq)...
20:22:11 <vincenz> Adamant: cool
20:22:13 <ddarius> You know what I could go for?  Type level applicative functors.
20:22:18 <monochrom> Asimov's "The God Themselves" is one of those few books worthy of the category-sake "science fiction". It really makes up a fictitious law of physics and base a story on it. You see, most other stories just throw in a lot of gadgets, there is no science in it.
20:22:35 <Pseudonym> Worst science fiction book I've ever read, BTW, is by Brian Herbert.  Frank's son.
20:22:40 <vincenz> The new one by Coupland
20:22:42 <Pseudonym> Just Say No.
20:22:48 <vincenz> It was so bad I felt an urge to burn it, and did, on my bbq
20:22:56 <klein> check out James Hogan's "The Genesis Machine"
20:23:05 <wli> vincenz: There should be a good biography of Klaus Barbie floating around with numerous shockers in it.
20:23:07 <ddarius> vincenz: Burning books is fun.
20:23:19 <klein> that's another one about a realistic bit of science
20:23:29 <Tac-Tics2> Books are dangerous. Readers will be punished to the full extent of the law.
20:23:32 <wli> vincenz: These things are almost alternate history except they're real.
20:23:39 <Adamant> ha. like anyone reads books.
20:23:58 <klein> it looks cheezy but it's really quite good... asimov and minsky gave it good reviews
20:24:01 <Tac-Tics2> Blogs are dangerous. Readers will be punished to the full extent of the law.
20:24:03 <ddarius> Books are another thing that have yet to be improved fundamentally.
20:24:04 <Tac-Tics2> .... (in China)
20:24:06 <mrd> The Naked Sun is part of a larger series
20:24:56 <Pseudonym> Well, the best thing that ever happened to books was the photostat.
20:25:15 <Adamant> or the e-book
20:25:17 <Pseudonym> It allowed for cheap publishing of paperbacks.
20:25:35 <Adamant> ah, I thought you meant photocopier
20:25:41 <Adamant> samizdat and all that
20:25:57 * vincenz is a bookaholic
20:25:58 <Pseudonym> No, I meant reproduction from camera copy. :-)
20:26:06 <geezusfreeek> ebooks are still not where they should be. something about them just can't compare to dead trees
20:26:14 <vincenz> <3 dead trees
20:26:17 <Adamant> yeah, I agree.
20:26:19 <wli> Samizdat is insignificant these days due to issues of distribution and reach.
20:26:23 <vincenz> I wish they'd get e-paper out
20:26:32 <Pseudonym> I need to eat.
20:26:33 <Pseudonym> BBS
20:26:34 <vincenz> with equal feel to a book, not too heavy, big storge, and long long long battery
20:26:40 <geezusfreeek> what kind of dpi is epaper supposed to have again?
20:26:49 <mrd> and doesn't hurt your eyes
20:26:53 <monochrom> Another thing in "The God Themselves" that attracts me is this. It says: you know how our universe has four forces, and there are other universes. Perhaps actually there are infinitely many forces, but ours parameters are such that four are domininant, the others negligible? And it doesn't stop there. It goes on: You know there is "infinite" as in natural numbers, and then there is "infinite" as in real numbers?  Gosh, see, h
20:26:53 <monochrom> ow many writers out there at all know about cardinals?
20:26:53 <vincenz> dunno, though you don't need that much on paper
20:27:08 <vincenz> monochrom: ooh there's this great presentation on that on the net, about the 10 dimensions
20:27:17 <mrd> monochrom: well Asimov did have a PhD in chemistry
20:27:22 <mrd> fwiw
20:27:27 <monochrom> Nice.
20:27:38 <Tac-Tics2> if you have an infinite number of forces, how does the universe update its state in a finite length of time?
20:27:41 <sorear> chemistry is alarmingly close to physicsd
20:27:47 <mrd> it also took him 10 years to graduate. WWII kinda interfered.
20:27:50 <wli> I need to get made up to leave the house and meet someone for dinner.
20:28:01 <Tac-Tics2> (and is the answer to my above question a kind of monad?)
20:28:02 <geezusfreeek> Tac-Tics2, it can do it because it has infinite awesomeness
20:28:07 <mrd> Asimov wrote WAY more non-fiction than fiction.
20:28:20 * sorear is reading a QM book that apparently asserts (without proof, of course) "the reals are denumerable"
20:28:21 <vincenz> http://www.tenthdimension.com/flash2.php
20:28:24 <lambdabot> Title: Imagining the Tenth Dimension - A Book by Rob Bryanton
20:28:40 <mrd> he had something approaching 400 books to his name and less than a hundred fiction.
20:28:55 <Weremanatee> sorear: *bull..cough...*
20:29:11 <Adamant> he even had Biblical criticism written at one point, and he was an atheist, IIRC
20:29:16 <vincenz> http://www.tenthdimension.com/medialinks.php
20:29:17 <vincenz> check that :)
20:29:20 <lambdabot> Title: Imagining the Tenth Dimension - A Book by Rob Bryanton
20:29:36 <Tac-Tics2> I always find it humorous when someone I know says "there are only three dimensions" and another friend in the room will rattle off "no, you doofus, TIME is the 4th dimension" as it they understand something totally profound about the universe the first friend does not yet comprehend
20:30:00 <geezusfreeek> Adamant, he actually wrote two large books on the old testament and the new testament. he analyzed it in the most historically accurate way he could, not really from a spiritual standpoint
20:30:16 <sorear> time, length, mass, ...
20:30:23 <Weremanatee> yellowness
20:30:27 <ddarius> Adamant: Not a good idea to criticize the Bible if you're a Christian...
20:30:28 <ChilliX> sorear: Were you looking for me?
20:30:28 <geezusfreeek> lol
20:30:36 <geezusfreeek> ddarius, why not?
20:30:41 <Weremanatee> ...similarity to a carrot
20:31:03 <ddarius> Weremanatee: Those aren't orthogonal
20:31:44 <vincenz> anyone check that link/movie?
20:31:45 <vincenz> it's really good
20:31:47 <ddarius> geezusfreeek: You might upset God and be sent to Hell.
20:31:49 <Adamant> ddarius, I should have been clearer, Biblical research criticism
20:31:55 <vincenz> (and great presentation from a technical point of view,w gotta love the sounds and images)
20:32:04 <geezusfreeek> ddarius, meh... God didn'
20:32:07 <monochrom> There are 5 dimensions. left-right, up-down, front-back, past-future, and how much money you make.
20:32:07 <vincenz> bit hard to really grok at times
20:32:08 <sorear> ChilliX: Yeah.  I was pondering the properties of type functions, and I had an odd problem with the parser when I tried to test somethign
20:32:12 <geezusfreeek> *didn't write the Bible, necessarily
20:32:18 <geezusfreeek> even as a christian, i don't believe that
20:32:26 <Tac-Tics2> When I was a kid, I imagined that mathematics was created by God to keep humans from possessing omnipotence
20:32:37 <sorear> ChilliX: forall a. Foo () ~ () => Int  doesn't parse
20:32:38 <Tac-Tics2> Then when I grew up, I realized the world worked just fine with or without a god
20:32:45 <mrd> Tac-Tics2: darn paradoxes get in the way
20:32:58 <Adamant> I saw it before. I don't think it's accurate from a physics standpoint, but it's a great presentation and helps to open your mind up
20:33:01 <sorear> ChilliX: For that matter, how do you officially get forall to parse these days?
20:33:08 <ddarius> geezusfreeek: He doesn't have to have written it to be upset with you critizing it.  Plenty of people get upset when you do that and they didn't write it either.
20:33:12 <mrd> ExistentialTypes ext?
20:33:37 <geezusfreeek> plenty of people are stubborn and too lazy to do their own research
20:33:44 <dolio> sorear: I think there are several flags that'll do it.
20:33:52 <Tac-Tics2> I was too young to understand things like Godel's Incompleteness theorem or Russel's paradox
20:33:53 <dolio> sorear: RankNTypes is one, I think.
20:34:24 <Tac-Tics2> If there's anything the existence of God would allow for, it's the Axiom of Choice
20:34:42 <dolio> sorear: Or TypeOperators.
20:34:44 <vincenz> I don't get the 3rd dimension one
20:34:52 <vincenz> "Jumps from one spot to the next in lower dimension"
20:35:02 <dolio> Oh, wait, maybe not.
20:35:10 <ChilliX> sorear: re the option, I guess -X RankNTypes should do the job
20:35:12 <geezusfreeek> mathematics is manmade... it's just a model for putting things on paper
20:35:41 <sioraiocht> geezusfreeek: I disagree, mathematics is discovered, not made
20:36:14 <ChilliX> Does (forall a. (() ~ ()) => Int) parse?
20:36:17 <sfultong> mathematics is an abstract modeling of the world that has no real counterpart...
20:36:30 <sfultong> mathematics is as unreal as you can get
20:36:35 <sorear> *Main> :k (forall a. (() ~ ()) => Int)
20:36:35 <sorear> (forall a. (() ~ ()) => Int) :: *
20:36:37 <mrd> monads were first discovered deep in the jungle
20:36:39 <sioraiocht> sfultong: physics?
20:36:47 <geezusfreeek> sioraiocht, that depends on if your way of defining math is based on assumptions or on deductive processes
20:36:58 <Tac-Tics2> mathematics tells us how things should be, physics tells us how things are
20:37:05 <sorear> physics and math shouldn't be mentioned on the same page
20:37:20 <mrd> and engineers tell us "it'll cost another 50 million"
20:37:25 <sioraiocht> sorear: they owe their existence to each other...
20:37:32 <geezusfreeek> sioraiocht, if there is anything we discover, it's that everything we know about physics is always wrong
20:37:47 <geezusfreeek> math can't be wrong, therefore, physics is not math
20:37:51 <geezusfreeek> :)
20:38:03 <Tac-Tics2> math can be wrong
20:38:06 <ddarius> math is wrong all the time
20:38:09 <Tac-Tics2> it's just unlikely from what we see
20:38:12 <Adamant> bad proofs
20:38:13 <monochrom> Is math invented or inflicted?
20:38:35 <ChilliX> *Main> :k forall a. F () ~ () => Int
20:38:36 <vincenz> induced
20:38:36 <ChilliX> forall a. F () ~ () => Int :: *
20:38:37 <Tac-Tics2> There was a post on slashdot or something today on math being taught at religious schools
20:38:41 <geezusfreeek> valid math can't be wrong
20:38:46 <vincenz> hah
20:38:51 * FMota is thinking.
20:39:01 <vincenz> the interesting part is you can keep adding axioms
20:39:05 <ChilliX> sorear: that was with -fglasgow-exts, but XRankNTypes should be fine, too
20:39:07 <vincenz> and thereby make a choice about what 'math' is
20:39:08 <FMota> Invalid math can be wrong but will often look right.
20:39:23 <Tac-Tics2> geezusfreeek: you can't prove math is logically consistent using math
20:39:25 <vincenz> infinity is a point in the 7th dimension
20:39:35 <ddarius> You can define something wrongly despite the fact that it is a definition.
20:39:35 <geezusfreeek> vincenz, no, i was just pointing out that it's not math if it's invalid
20:39:43 <FMota> Invalid computer programs will not work if they are not right.
20:39:43 <sfultong> vincenz: ??
20:39:51 <vincenz> sfultong: check the link
20:40:04 <dolio> -XExistentialQuantification and -XScopedTypeVariables also enable 'forall ...'
20:40:06 <geezusfreeek> FMota, unless the hardware is wrong :)
20:40:24 <FMota> Ah, but that's the problem, isn't it?
20:40:40 * ddarius recommends Lakatos' Proofs and Refutations
20:40:46 <geezusfreeek> but hardware is not math. it's physics :)
20:40:54 <vincenz> anyone that can explain to me the folding in 3rd dimension? If you move in 3 dimensions, your 2dimensional projection is still continuous, is it not?
20:41:01 <Tac-Tics2> it is math too, geezusfreeek
20:41:32 <geezusfreeek> Tac-Tics2, we use math to model it, but ultimately it comes down to physics that we don't understand
20:41:33 <FMota> if we had a theoretical machine that could run any program correctly, we could say a lot more things about math and computing. But we don't have such a computer.
20:41:39 * Weremanatee looks on the floor at the shattered pieces of context.
20:41:54 <sioraiocht> LOL @ Weremanatee
20:41:59 <Tac-Tics2> geezusfreeek: I'd say we understand classic electricity pretty well ;-)
20:42:08 <ddarius> vincenz: The fold takes place in time.
20:42:08 <monochrom> vincenz: yes, still continuous. but continuity is a very weak property.
20:42:18 <FMota> Such a computer would be based in maths too -- which can be wrong. So we can't even be sure that a theoretical computer works right.
20:42:48 <geezusfreeek> in physics, we see the high-level effects of doing certain things, but we never see the base principles that define them. in math, it's the exact opposite: we understand the base principles pretty well (we define them ourselves), but we will never really understand all the high-level properties that come out of them
20:43:01 <vincenz> ddarius: no
20:43:06 <vincenz> ddarius: the 4th dimension is a line again
20:43:06 <Tac-Tics2> interesting observation
20:43:09 <vincenz> ddarius: check the link
20:43:19 <FMota> geezusfreeek: Agree.
20:43:32 <sfultong> Weremanatee: hehe
20:43:34 <Tac-Tics2> but the "understanding" in the sense of physics is different
20:43:36 <vincenz> http://www.tenthdimension.com/medialinks.php
20:43:37 <lambdabot> Title: Imagining the Tenth Dimension - A Book by Rob Bryanton
20:43:57 <FMota> maths evolves through construction
20:44:04 <FMota> physics evolves through observation
20:44:23 <FMota> :)
20:44:28 <sorear> maths evolves through deduction
20:44:35 <sorear> physics evolves through induction
20:44:44 <sfultong> @haskell-blah
20:44:45 <lambdabot> Unknown command, try @list
20:44:53 <sioraiocht> I like sorear's answer better, imo
20:44:56 <Tac-Tics2> Math evolves through creativity, physics evolves through very, very expensive machines
20:45:07 <FMota> lol Tac-Tics2
20:45:13 <SamB> Tac-Tics2: some creativity too
20:45:15 <FMota> so true.
20:45:25 <sorear> yes, creative abuse of maths
20:45:30 <SamB> exactly!
20:45:39 <SamB> except why does it have to be abuse?
20:45:49 <Tac-Tics2> because abuse is more entertaining than standard use
20:45:59 <SamB> oh, okay, that sense of abuse
20:46:11 <Tac-Tics2> and math needs to milk the entertainment card, because dry math is no fun
20:46:11 <SamB> same principle as the demoscene
20:46:14 <wli> Physics is empirical.
20:46:18 <Tac-Tics2> like the Hairy Ball Theorem
20:46:30 <wli> Mathematics is not.
20:46:35 <geezusfreeek> math models physics, but it doesn't explain physics
20:46:35 <FMota> :o The Harry Ball Theorem ?!
20:46:37 <Tac-Tics2> Mathematics often evolves through empiricism
20:46:38 <idnar> are there any Haskell image manipulation libraries?
20:46:44 <wli> The only way to get mathematics to apply is abuse.
20:46:48 <idnar> actually, I guess manipulation is the wrong word; I basically just want to write out some pixels
20:46:48 <Tac-Tics2> http://en.wikipedia.org/wiki/Hairy_ball_theorem
20:46:48 <lambdabot> Title: Hairy ball theorem - Wikipedia, the free encyclopedia
20:46:58 <sorear> idnar: man 4 ppm
20:47:01 <FMota> ER, *Hairy
20:47:03 <FMota> *er
20:47:15 <Tac-Tics2> as in, you can't comb a hairy ball
20:47:17 * ddarius again -highly- recommends Lakatos' Proofs and Refutations to everyone.
20:47:25 <SamB> empirical observations can lead to attempted theorems, true
20:47:51 <monochrom> They don't seem to like to read books. :)
20:47:56 <idnar> sorear: mmm
20:47:56 <Tac-Tics2> hmm
20:47:59 <idnar> sorear: I guess that could do, for now
20:48:13 <sorear> idnar: It's better than any library IMO.
20:48:14 <SamB> idnar: what?
20:48:27 <SamB> you basically want a library that outputs that, eh?
20:48:43 <sfultong> all this chat is distracting, and doesn't aid haskell learning
20:48:45 <ddarius> monochrom: It's almost a pamphlet.  It's tiny.
20:48:51 <idnar> well, I want the final result as a PNG or a JPEG
20:48:59 <SamB> idnar: idnar uh
20:49:04 <idnar> but I can convert a PPM easily enough
20:49:04 <geezusfreeek> idnar, the gtk bindings have some image import/export functions
20:49:09 <sorear> idnar: man 1 pnmtopnt
20:49:11 <sorear> idnar: man 1 pnmtopng
20:49:20 <SamB> idnar: exactly!
20:49:23 <sorear> geezusfreeek: eek!
20:49:26 <SamB> that's the point of a ppm
20:49:26 <geezusfreeek> :P
20:49:34 <idnar> SamB: yeah, it's just that ppm files are rather... gigantic
20:49:41 <ddarius> Uh, cute... "Everything done. Thank you for downloading a media file containing proprietary and patented technology. Core dumped ;)"
20:49:44 <SamB> idnar: |
20:49:46 <sorear> idnar: the ppm files don't exist
20:49:51 <sorear> idnar: UNIX is lazy
20:49:53 <mrd> now i remember what came before The Naked Sun: The Caves of Steel.  I think.
20:50:09 <idnar> oh, you're suggesting sending it straight into the conversion tool
20:50:20 <idnar> heh
20:50:37 <idnar> fair enough
20:50:42 <geezusfreeek> UNIX is bloated, badly implemented Haskell!
20:50:58 <ddarius> UNIX is also badly implemented muffins.
20:51:06 <idnar> plan 9 woo
20:51:07 <geezusfreeek> exactly
20:51:09 <SamB> yes. UNIX does not taste very good.
20:51:15 <Tac-Tics2> Muffins are badly implemented pastries
20:51:21 <SamB> Tac-Tics2: eh?
20:51:31 <SamB> pastries are badly-implemented muffins!
20:51:36 <Tac-Tics2> hehe
20:51:40 <Tac-Tics2> muffins are a pastry
20:51:46 <Tac-Tics2> so muffins are badly implemented muffins
20:52:01 <SamB> muffins are more of a bread
20:52:13 <geezusfreeek> Tac-Tics2 is a badly-implemented deduction engine
20:52:29 <Tac-Tics2> I deduce that statement to be false =-P
20:52:36 * mrd falls off the channel
20:52:39 <geezusfreeek> see?
20:53:32 <vincenz> science is the art of saying "I'm not completely sure"
20:54:01 <wli> UNIX isn't as virile as Multics.
20:55:25 <Tac-Tics2> Does anyone know if there's a project for a UNIX shell written in haskell?
20:55:39 <Tac-Tics2> I think that would be cool
20:55:52 <mrd> it is far more viral though
20:55:53 <Tac-Tics2> if you could just type haskell expressions into your command line and get the result
20:56:08 <Tac-Tics2> and then have haskell be the scripting language for your shell
20:56:08 <FMota> would the haskell shell be caleld hash?
20:56:12 <FMota> *called
20:56:19 <mrd> there's something or other along those lines
20:56:21 <Tac-Tics2> either that or Hashell
20:56:26 <FMota> I think that would be funny. :)
20:56:57 <SamB> there's probably things called both of those already
20:57:12 <SamB> maybe with different capitalization
20:57:13 <mrd> naming needs to become more creative
20:57:14 <wli> There have been several shells written in Haskell.
20:57:22 <FMota> :o
20:57:41 <FMota> I always pick small names from foreign languages. :)
20:58:22 <FMota> i.e., the PL I'm designing is called "sei". It was called "ae" before.
20:58:29 <monochrom> I heard "h4sh"
20:58:50 <Tac-Tics2> FMota what language is 'sei' from?
20:58:56 <FMota> Portuguese.
20:59:08 <FMota> and, um, 'ae' isn't actually foreign :/
20:59:16 <earnest> FMota speaks Portuguese?
20:59:26 <FMota> FMota is Portuguese.
20:59:40 <earnest> So I guess you do :)
20:59:43 <FMota> :)
20:59:56 <earnest> I speak Portuguese too
21:00:11 <earnest> Eu sei falar português tambien
21:00:13 <Tac-Tics2> Is portuguese implies speaks Portuguese, but the converse is not true
21:00:14 <FMota> Hmm? How did you pick that up?
21:00:16 <earnest> Eu sei falar muy bien!
21:00:29 <FMota> Mais ou menos.
21:00:44 <earnest> Don't put my Portuguese down!
21:00:46 <earnest> :)
21:00:53 <FMota> Hey, I can help fix it!
21:01:00 <earnest> I'm just kidding with you :)
21:01:06 <earnest> I speak Portuguese for real.
21:01:13 <FMota> we don't end anything in "-ien", we use "-em"
21:01:42 <earnest> Yeah, well, I need to adjust it sometimes, you know? We live in a very globalized world these days... I get confused, man.
21:01:42 <FMota> and "muy" is actually "muito"
21:01:46 <earnest> :)
21:01:50 <FMota> yep.
21:01:54 <SamB> FMota: I think he's just mixing some spanish in...
21:02:10 <FMota> SamB: well, they're very similar.
21:02:10 <earnest> My tricks don't work anymore. :)
21:02:15 <monochrom> throw in some Latin too. no one will know.
21:02:23 <earnest> Even SamB has caught up to them. :|
21:02:38 <SamB> I don't know much spanish, but I can recognize "muy bien"
21:02:46 <FMota> :)
21:02:54 <earnest> But you guys are not believing me...
21:03:08 <Tac-Tics2> earnest, where are you from?
21:03:13 <earnest> I do speak Portuguese like there was no tomorrow
21:03:16 <monochrom> what is muy?
21:03:19 <sorear> I don't know portugese, but I'm pretty familiar with intensional type theory
21:03:37 <earnest> monochrom: muy is ``very''
21:03:54 <earnest> Tac-Tics2: I'm from America
21:04:00 <FMota> sorear: Funny... I'm sure they're related, actually.
21:04:07 <Tac-Tics2> Oh, so you are celebrating Labor Day today?
21:04:14 <earnest> Aren't we all? :)
21:04:22 <jql> I know I am...
21:04:30 <Tac-Tics2> According to the channel a few hours ago.... no
21:04:31 <Tac-Tics2> =-P
21:04:32 <earnest> I thought we had concluded that the world celebrates that today
21:04:37 <jql> although I kinda wish my office had been open today, if just for the air conditioning
21:04:45 <earnest> Tac-Tics2: don't go with the rebels
21:04:56 <ddarius> I thought we concluded that the world is contained in America.
21:05:08 <earnest> See? I'm not craz
21:05:10 <earnest>                  y
21:05:37 <ddarius> Oh no! earnest has entered the second dimension!  Beat him down before it's too late!
21:05:44 <Tac-Tics2> Isn't there an axiom in ZFC that says that no set is infinitely recursive?
21:05:54 <Tac-Tics2> or something like that
21:06:12 <ddarius> Axiom of Well-Foundedness.  I don't know if it's typically part of ZFC.
21:06:15 <FMota> no set can contain itself
21:06:36 <Tac-Tics2> So the set of all sets except the set of all sets is a set?
21:06:43 <FMota> hence, there is no infinite sequence of sets such that s1 contains s2 contains s3 ....
21:06:59 <Tac-Tics2> or does "contain" meant recursively? as in some iterated subset contains the set itself?
21:07:07 <Tac-Tics2> ah
21:07:08 <FMota> Tac-Tics2: but that contains itself.
21:07:14 <ddarius> FMota: Axiom of Non-Wellfoundedness...
21:07:32 <earnest> Those weird sets would be called classes
21:07:39 <FMota> :o Well, I don't really know this too well, so take it with a grain of salt.
21:07:44 <earnest> Which are divided in normal classes and non-normal classes
21:07:48 <earnest> Isn't that true?
21:08:11 <sorear> Classes don't really exist, they are a meta-logical construct
21:08:14 <wli> I suppose I could design a programming language, but I've no idea what I'd do that would make it useful.
21:08:18 <SamB> hmm. Haskell doesn't allow that...
21:08:21 <sorear> a Class is just a predicate on sets, IIRC
21:08:32 <ddarius> wli: So don't design a programming language.
21:08:35 <wli> Proper classes are not ses.
21:08:44 <Tac-Tics2> I never liked the whol Godel whatever set theory. I can never tell on Wikipedia whether "class" means a ZFC set or an actual class
21:08:59 <wli> ddarius: It was a response to something I'd long-since forgotten.
21:08:59 <Tac-Tics2> the nomenclature is kinda ambiguous
21:09:23 <sorear> Tac-Tics2: I hate non-rigorous math too
21:09:52 <FMota> wli: Usefulness is only good for some things. I'm designing sei to better grasp functional programming.
21:10:01 <Tac-Tics2> Rigor is a double edged sword
21:10:15 <wli> That's who it was.
21:10:17 <Tac-Tics2> you need to be precise in what you mean, but you should try not to obfuscate
21:10:34 * SamB_XP_ feels the urge to say something about the sharp end of a split infinitive
21:10:54 <wli> FMota: Probably the only ideas on that front I think are worth pursuing are for improving C, but I don't really know enough about module systems to do it.
21:12:46 <FMota> wli: You could try to design a module system for some C-like language, to learn more about them. Honestly, the best way to learn is by having to do it.
21:13:08 <FMota> by which I mean, having to grok it.
21:13:42 <wli> FMota: I'll not be able to reinvent the theory by slapping together things in ignorance of it.
21:13:48 <ddarius> Oif.  Computer Scientists, the worst formalists ever.
21:14:02 <Tac-Tics2> omg ddarius, yeah
21:14:25 <Tac-Tics2> "length = O(n)"
21:14:30 <FMota> wli: No, I don't expect you to, but you will run into walls by trying, and when you run into walls you tend to look for ways out. That's learning.
21:14:37 <Tac-Tics2> I wanted to strangle someone when I saw that in my theory of comp book
21:14:55 <SamB_XP_> wli: maybe you could do it like this: slap together, look for the next piece of theory you need, implement, rinse, repeat
21:15:04 <Tac-Tics2> if subtract = O(1) and add = O(1), then subtract = add
21:15:42 <vincenz> Tac-Tics2: depends on the definition of =
21:16:19 <Tac-Tics2> why would you want to overload the = operator for a single (and quite important) chapter in your damn textbook?
21:16:22 <FMota> XD . Reminds me of the equation: CompSci - Math = BigMac - SecretSauce
21:16:52 <ddarius> BigMac + Math = CompSci + SecretSauce
21:16:58 <FMota> yep
21:17:15 <FMota> Which is.. odd
21:17:17 <Tac-Tics2> Thankfully, our professor for the class also disliked the notation and insisted on O(n) = {f | f is BigO n }
21:17:18 <Weremanatee> Hold the math.
21:17:54 <SamB_XP_> Weremanatee: this is #haskell, doofus!
21:18:01 <wli> Follow Brassard and use the element sign.
21:18:06 <SamB_XP_> we hold the math adn we aren't afraid to use it
21:18:44 <Tac-Tics2> no other language besides haskell is so unafraid of the subject
21:18:46 <Weremanatee> Can I substitute my math for onions?
21:18:59 <Tac-Tics2> Weremanatee: only if math = onions
21:19:02 <Weremanatee> % /s/for/with
21:19:11 <drbean> Math - CompSci = SecretSauce - BigMac
21:19:36 <SamB_XP_> Weremanatee: depends on the recipe
21:19:40 <FMota> drbeam: Compsci = Math + BigMac - SecretSauce
21:19:49 <drbean> HaHa
21:19:51 <FMota> sounds like there's something to gain, ;)
21:20:46 <vincenz> CompSci = Factory Geek
21:21:14 <brad_> ?
21:21:14 <lambdabot> brad_: You have 1 new message. '/msg lambdabot @messages' to read it.
21:21:35 <Tac-Tics2> ComputerScienceMajor(p) => Geek(p)
21:21:36 <ddarius> vincenz: Is multiplication commutative?
21:21:43 <vincenz> it's not multiplication
21:21:47 <vincenz> It's Factory of Geek
21:21:50 <Tac-Tics2> hehe
21:21:56 <Tac-Tics2> function application ftw
21:23:56 <FMota> lol Tigge
21:24:01 <FMota> *Tac-Tics2
21:24:38 <FMota> That equation looks like Sei... you'd say: CompSciMajor => Geek
21:24:46 <monochrom> SecretSauce is a good example of encapsulation and information hiding.
21:24:55 <Tac-Tics2> lol monochrom
21:25:11 <Tac-Tics2> SecretSauce is an example of an oracle sauce
21:25:21 <FMota> haha
21:25:22 <ddarius> monochrom: I've often had SecretSauce leak it's innards all over me.
21:25:33 <vincenz> instance (CompSci a) => Geek a where
21:25:34 <ddarius> Well maybe not often.  I hate McDonalds.
21:26:17 <monochrom> Tomorrow I should get a Big Mac.
21:26:17 <FMota> fast-food is bad
21:26:32 <vincenz> I disagree, some salads are great
21:26:47 <Tac-Tics2> Tomorrow is my own personal Ramen Day
21:27:08 <ddarius> Tomorrow is government subsidized food day.
21:27:48 <Tac-Tics2> there was a 40 minute wait on ramen today at the Japanese marketplace near my house. It was quite traumatizing.
21:28:47 <FMota> Today was "go out for lunch and get full before the main dish is served" day.
21:28:52 <FMota> (for me)
21:31:02 <vincenz> The worst thing about airtravel: all the waiting before and after.
21:31:10 <vincenz> "Oh 1 hour flight only!" and then you get like 5 hours of extra crap
21:31:22 <Tac-Tics2> What was the earliest programming language to have a 'foreach'-type loop?
21:31:42 <vincenz> semantically or syntactically?
21:32:10 <Tac-Tics2> well semantically, almost all for loops do the same thing
21:32:16 <vincenz> heh
21:32:21 <vincenz> all languages then :)
21:32:28 <Tac-Tics2> I mean, which was the first language to have a for loop which takes an interable and a binding name?
21:32:42 <Tac-Tics2> instead of the integer index bullplop
21:33:02 <ddarius> Quite probably Fortran or Lisp.
21:33:29 <Tac-Tics2> foreach isn't really a lispy thing to do
21:33:44 <vincenz> Tac-Tics2: so syntactically :)
21:33:50 <Tac-Tics2> yeah...
21:33:53 <ohub> well, dolist is a pretty nice thing anyway
21:33:56 * vincenz grins wickedly
21:34:19 <Tac-Tics2> I sort of assumed it was understood I could figure out the the trivial solution for myself =-P
21:34:37 <vincenz> I was kidding
21:35:00 <monochrom> Lisp is much more imperative than you think. It contains lots of list functions for side effects.
21:35:32 <Tac-Tics2> monochrom: the most I learn about Haskell, the more I realize that truth
21:35:37 <monochrom> Scheme has foreach, too. But Lisp is even older.
21:35:57 <Tac-Tics2> Lisp is just an imperative language with functional wheels
21:36:11 <vincenz> Yeah, lisp is a garbage-collected language, it collects all the syntactical garbage of all other languages
21:36:14 * vincenz coughs
21:36:17 <Tac-Tics2> loL
21:36:19 <monochrom> hahaha
21:36:47 <Tac-Tics2> vincenz, I think CL in particular
21:37:05 <Tac-Tics2> as elegant as the core of the language is, CL makes me want to throw up just a little in my mouth
21:37:50 <Tac-Tics2> not that it's a bad language
21:37:54 <Tac-Tics2> but it's just not a pretty language
21:38:01 <Tac-Tics2> it's like the functional perl, imo
21:38:19 <Pseudonym> CL is elegant for the late 50s.
21:38:34 <Tac-Tics2> that's probably true
21:38:40 <ddarius> CL wasn't made until the 80's.
21:38:47 <Pseudonym> True.
21:38:57 <Pseudonym> OK, Lisp is elegant for the late 50s.
21:39:38 <Tac-Tics2> hmm
21:39:47 <Tac-Tics2> That's one thing about research I never understood
21:39:49 <monochrom> CL does suffer from a bit of committee design.
21:40:01 <Tac-Tics2> how would I go about figuring out the earliest language with a syntactic iterator-based foreach loop?
21:40:02 <Pseudonym> Well CL is 2.5 Lisp implementations.
21:40:11 <Pseudonym> Anything which didn't actually conflict just went in.
21:40:35 * ddarius knew SPJ would not be able to stay sitting the entire video.
21:40:43 <monochrom> You have to do an exhaustive search over published languages.
21:41:01 <Pseudonym> Probably FLOW-MATIC.
21:41:06 <Pseudonym> IOf I had to guess.
21:41:10 <Tac-Tics2> but why would anyone do that for a silly question like mine?
21:41:11 <monochrom> You may apply some heuristics to prune the search, e.g., ask your supervisor.
21:41:16 <Tac-Tics2> lol
21:42:11 <Tac-Tics2> what if you don't have one to ask?
21:42:18 <Tac-Tics2> Do you just do your best, and then assume you're right?
21:42:25 <monochrom> You can ask newsgroups and channels.
21:42:31 <Pseudonym> Actually, by the look of it, FLOW-MATIC doesn't have syntactic loops.
21:42:35 <Pseudonym> http://www.cbi.umn.edu/graphics/iter-flowmatic.jpg
21:43:12 <monochrom> Yes, it comes down to that. You give best effort search, then you report. Then if anyone cares, they may tell you a counterexample. It may still not be the earliest.
21:43:35 <Tac-Tics2> yeah
21:43:58 <Tac-Tics2> Someday I want to go to graduate school CS or Math
21:44:02 <Tac-Tics2> but for now, I'm stuck working
21:44:04 <monochrom> You will only be able to say "the earliest known" "the earliest we can find".
21:44:14 <Pseudonym> Looks like the answer might be FORTRAN.
21:44:39 <Tac-Tics2> forshizzle?
21:44:45 <bparkis> a general CS question:  how can I best get involved in research as a senior undergrad CS and math student?
21:44:57 <ddarius> Pseudoynm: As I said, that seems very likely.
21:44:58 <Tac-Tics2> heh
21:45:07 <bparkis> one way that I guess I'll do without further guidance is just email a bunch of professors to see if they could find use for an undergrad
21:45:11 <Pseudonym> bparkis: Make friends with an academic who's working on a cool proejct that you like.
21:45:25 <Tac-Tics2> I took an undergraduate research in mathematics class my last year in school, and I totally hated the professor for how he taught the class
21:45:30 <monochrom> OTOH, normally there is no reason to find "the earliest whatever" other than giving credit where it's due. It's not mission critical.
21:45:49 <Pseudonym> Yeah, the first FORTRAN compiler was in 1957.  The first COBOL compiler wasn't until 1960ish.
21:45:49 <bparkis> I don't really have any "schmooze" skill
21:46:05 <Pseudonym> Lisp was the first self-hosting compiler, though.
21:47:01 <bparkis> I've been reading up on professors who might be doing something interesting to me, but it is intimidating how advanced much of the research is
21:47:20 <bparkis> I feel like I need more courses to contribute anything but I'm already a senior
21:47:21 <Pseudonym> bparkis: Many universities have summer studentships or the equivalent.
21:47:29 <bparkis> too late for summer, I'm an entering senior
21:49:28 <Pseudonym> "Consistently separating words by spaces became a general custom about the tenth century A.D., and lasted until about 1957, when FORTRAN abandoned the practice."
21:49:50 <bparkis> I mean, am I likely to be able to help a machine vision professor, when I have general math background but haven't specifically taken the machine vision course?
21:50:07 <SamB_XP_> bparkis: you think the professors are doing experiments on you?
21:50:24 <Pseudonym> bparkis: There's only one way to find out.
21:50:28 <Pseudonym> You're a senior, right?
21:50:32 <Pseudonym> That means final year, I assume.
21:50:35 <bparkis> yes it does
21:50:46 <Pseudonym> OK.  Go see someone in the field at your university.
21:51:04 <Pseudonym> Say you're thinking of doing postgrad (or whatever the hell you call it) work, and were curious what they're working on.
21:51:07 <monochrom> Professors are constantly looking for students to code up their ideas. Don't be afraid.
21:51:08 <SamB_XP_> Pseudonym: the ultimate frisby field?
21:51:28 <Pseudonym> You don't even need a pretext.
21:52:20 <FMota> hmm
21:52:28 <FMota> im so nt looking forward to tomorrow :/
21:52:30 <bparkis> also, there are a bunch of professors who might be interested in this, so one option might be to mail each of them--but would that be considered impolite?
21:52:45 <Pseudonym> Not at all.
21:52:50 <Pseudonym> But you've got time.  See one at a time.
21:53:05 <Pseudonym> It really is a seller's market out there.
21:53:06 * FMota is going to bed with "The Art of UNIX Programming"
21:53:14 <Tac-Tics2> heh
21:53:14 <Pseudonym> FMota: Woah, TMI.
21:53:21 <FMota> lol
21:53:23 <Tac-Tics2> Younicks
21:53:27 <Pseudonym> Eunuchs
21:53:34 <bparkis> I don't have that much time, I do have a senior project I need to do by the end of the year, so I have to get involved at least by the end of fall semester
21:53:35 <johnnowak> going to bet with the art of unix programming is going to bed with ESR
21:53:40 <SamB_XP_> Pseudonym: um. not that kind of going to bed
21:53:43 <Pseudonym> bparkis: Then start now.
21:54:06 <Pseudonym> Thanks a lot.  I've met ESR, and now I have flashbacks.
21:54:18 <Pseudonym> (He wasn't carrying, for the record.)
21:54:26 <FMota> I don't know ESR personally, how is he like?
21:54:40 <SamB_XP_> FMota: are you into guns?
21:54:53 <FMota> No.
21:55:38 <Pseudonym> FWIW, I have a friend who isn't into guns, but ESR hit on her anyway.
21:55:58 <Pseudonym> FMota: Well, he's short, nerdy and has a mild physical disability.
21:56:01 <bparkis> one thing I'm looking for is if professors list undergrads that they are supervising, but most professors only list grad students
21:56:02 <Pseudonym> But he's bloody smart.
21:56:14 <FMota> Ugh. Not interested.
21:56:22 <Pseudonym> And that's more important, surely.
21:56:30 <SamB_XP_> Pseudonym: is he bloody becauses he shot himself in the foot?
21:56:50 <Pseudonym> No, he follows all the correct safety procedures.
21:56:56 <FMota> XD. Yes, being smart is more important. But being 50 years old is... offputting.
21:57:02 <SamB_XP_> ... in Python?
21:57:06 <Tac-Tics2> heh, if programming languages were like guns, you'd need a special government license to write code in C or C++
21:57:22 <FMota> lol, SamB_XP_
21:57:26 <Pseudonym> Hey, some of the best Unix pioneers are 50+.
21:57:45 <FMota> Pseudonym: Right, but I wouldn't go to bed with any of them.
21:57:48 <Pseudonym> Not that ESR is a Unix pioneer, exactly.
21:57:50 <Pseudonym> Well, no.
21:58:00 <stepcut> Tac-Tics2: you'd probably need a different license for each state too
21:58:06 <Pseudonym> Being already taken sort of rules that one out for me anyway.
21:58:40 <Tac-Tics2> Texans would be able to write in C++ without the 3 day waiting period
21:58:46 * FMota wonders how many people think FMota is female.
21:59:09 * Pseudonym doesn't pry, FMota
21:59:13 <ddarius> FMota: I haven't even considered it until now.
21:59:13 <Nafai> Tac-Tics2: Being Texan, I wouldn't argue with that one :)
21:59:18 <Pseudonym> But ESR is broad minded.
21:59:24 <Tac-Tics2> Python would be like a pocket knife, requiring no sort of special training or experience necessary
21:59:27 <Tac-Tics2> hehe
21:59:45 <FMota> LOL Pseudonym
21:59:59 <FMota> And with that, ciao. Talk to y'all tomorrow.
22:00:10 <Pseudonym> Night.
22:00:54 <sorear> FMota: I've never heard of a female named Francisco.  Have you?
22:01:27 <FMota> No, but not many people know my first name. Until a minute ago, that is.
22:01:40 * Pseudonym just did a whois to check
22:01:44 <Heffalump> it's in your whois..
22:01:50 <FMota> :)
22:01:55 <monochrom> not many people look that up
22:02:15 <sorear> it's also on the esolang wiki
22:02:53 <FMota> Yep. Oh, I'm 16 and 1/2 years old today. :)
22:03:06 <Pseudonym> Oh, happy whatever.
22:03:21 <SamB_XP_> "half birthday"
22:03:29 <FMota> mmhmm. Ciao!
22:03:33 <monochrom> semianniversary
22:03:38 <johnnowak> closer to death every minute...
22:03:50 <SamB_XP_> monochrom: that would be if she'd been married that long...
22:06:00 <sorear> FMota: Wow, you're younger than me!
22:06:15 <FMota> sorear: ORLY? :)
22:06:19 <ddarius> sorear feels like an old man
22:06:30 <Tac-Tics2> how old is everyone here?
22:06:36 * Tac-Tics2 22
22:06:59 <Pseudonym> Old.
22:07:07 * sorear 16 5/6
22:07:24 <SamB_XP_> 21
22:07:28 <ddarius> Going on 23 this month.
22:07:37 <Tac-Tics2> wow
22:07:38 <Pseudonym> 34 as of a month ago.
22:07:39 <FMota> 16 1/2, ofc
22:07:47 <Tac-Tics2> For some reason, I thought everyone here was older than they really are
22:07:47 <SamB_XP_> as of the 26th of last month
22:07:49 <monochrom> I do somewhat assume people on IRC are males. But that is to the same extent that I assume an ordinal is a set of lesser ordinals, or a real number is a cut or a sequence of rationals, or a computation is a sequence of state or graph changes, ... IOW I form a mental model, but I only use the properties that matter, so you can't easily tell what mental model I have internally.
22:08:06 <Tac-Tics2> I expected more 26ish or older
22:08:17 <Pseudonym> monochrom: That's okay, we do reason by stereotyping.
22:08:33 <Pseudonym> If I tell you "I saw a car crash", you form a picture of the car, its colour, its make, where it was...
22:08:40 <Pseudonym> And you repair it as necessary.
22:08:43 <Tac-Tics2> Stereotyping is not proof, but it is a damn good survival trait
22:08:49 <SamB_XP_> Tac-Tics2: is it because we act so mature :-P?
22:08:57 <Pseudonym> It's a reasonable assumption, for example, that everyone you meet is straight until proven otherwise.
22:09:08 <Pseudonym> Or, at least, until you have reason to believe otherwise.
22:09:27 <SamB_XP_> if it weren't so, we probably wouldn't use the term "straight"
22:09:28 <monochrom> Models are easier to use than dry axioms.
22:09:43 <FMota> Pseudonym: ;) Yes, that's a reasonable assumption. But it's b*tch, isn't it?
22:09:56 <Tac-Tics2> it's because you all know so much about monad stm axiom of formal turing computation theory
22:10:20 <SamB_XP_> Tac-Tics2: are you just lining words up at random again?
22:10:21 <Pseudonym> The thing is, of course, there's usually no reason to need to know, unless you're planning to hit on them and want to avoid embarrassment.
22:10:24 <allbery_b> not all of us do, no.
22:10:28 <SamB_XP_> (or was that someone else last time?)
22:10:33 <monochrom> Excuse. Models take less training to use than dry axioms.
22:10:34 <allbery_b> (and, ftr, 43)
22:10:56 <Tac-Tics2> SamB_XP_ what if I am?
22:11:09 * f-d <-- 25
22:11:15 <SamB_XP_> Tac-Tics2: 'twould explain why that made no sense ;-)
22:11:32 <Tac-Tics2> well, now you know how I feel hanging in this channel sometimes ^^
22:11:43 <Tac-Tics2> granted its often quite interesting, and I wish I knew more
22:12:02 <f-d> hahah
22:12:09 <SamB_XP_> sometimes I feel like that when Cale gets into one of those maths-heavy conversations...
22:12:13 <Pseudonym> BTW, has anyone tried the adjunctive flutzpah extension?
22:12:16 <Tac-Tics2> but you can only churn through cool things you hear about on this channel so fast
22:12:18 <f-d> Someone should write a KnowItAll IRC script sometime :)
22:12:30 <f-d> Like the pomo generator.
22:12:41 <Pseudonym> f-d: The guy who wrote that came to my wedding.
22:12:43 <Tac-Tics2> pomo? or porno?
22:12:49 * Pseudonym has serious nerd cred now
22:12:50 <FMota> Pseudonym: Agree. But I still wish one could just identify whether someone is straight or fay without having to ask them. Would save me a lot of trouble.
22:12:53 <FMota> *gay
22:12:53 <monochrom> Anyway, it is shocking to find out that sorear is now only the second youngest. :)
22:12:55 <ddarius> Yeah heavy math!  Now with 200% more neutrons!
22:12:55 <Tac-Tics2> (they look very similar from this distance from my monitor)
22:13:04 <f-d> Pseudonym, wow
22:13:12 <Pseudonym> I know acb quite well.
22:13:27 <Pseudonym> And he really is like that IRL.
22:13:30 <f-d> Tac-Tics2, I think a porno generator would ruin the porn industry.
22:13:40 <ddarius> FMota: Ask the people who know them.
22:13:45 <sorear> Pseudonym: acb?  or ajb?
22:13:51 <Pseudonym> acb
22:13:52 <monochrom> hahahaha ddarius
22:13:58 <Pseudonym> I'm ajb.
22:14:00 <ddarius> monochrom: timthelion is younger than FMota, I believe.
22:14:01 <Pseudonym> He's acb.
22:14:17 <monochrom> My mental model is collapsing!
22:14:18 <FMota> I'm not the youngest? Oh bugger!
22:14:30 <Pseudonym> Also known as Lee Harvey Oswald Smith.
22:14:33 <f-d> To think--there are new people being born all the time.
22:14:40 <ddarius> timthelion is not currently on, so you may be good
22:14:45 <f-d> Sorry...I'm new here.  Hi everyone :)
22:15:04 <FMota> Hi f-d
22:15:21 <sorear> Hi f-d
22:15:27 <f-d> Hi.
22:15:31 <f-d> I'm f-d.
22:15:34 <Pseudonym> Hi f-d!
22:15:40 * sorear IS the youngest person on the top-10 list.
22:15:46 <Pseudonym> And how long is it since you last used an imperative language?
22:15:58 <Tac-Tics2> hehe
22:16:07 <monochrom> Damn, I just learned Scheme last night.
22:16:11 <brad_> is there anything like perl's chop for haskell, like a single function that is the equivalent of (reverse . tail . reverse) ??
22:16:21 <Tac-Tics2> Let's go on a witchhunt for imperative programmers!
22:16:42 <f-d> Well, I'm learning python :)
22:16:46 <f-d> whoops
22:16:46 <Tac-Tics2> init?
22:16:53 <Tac-Tics2> > init [1,2,3,4]
22:17:04 <lambdabot>  [1,2,3]
22:17:08 <brad_> thanks Tac-Tics2!!
22:17:16 * monochrom almost tried to beat lambdabot.
22:17:18 <Tac-Tics2> Holy crap, I answered a Haskell question for once ^^
22:17:21 <vincenz> @src init
22:17:21 <lambdabot> init [x]    = []
22:17:21 <lambdabot> init (x:xs) = x : init xs
22:17:21 <lambdabot> init []     = undefined
22:17:25 <sorear> Tac-Tics2++
22:17:29 <brad_> and i really did RTFM on Data.List, not sure how i missed it
22:17:30 <Tac-Tics2> brad_: also see, last
22:17:36 <f-d> Oh cool a code bot
22:17:44 <sorear> Yup!
22:17:50 * sorear pets lambdabot
22:17:50 <Tac-Tics2> it might be in the Prelude, I think
22:17:57 <sorear> @index init
22:17:57 <lambdabot> Data.List, Prelude
22:18:22 <sorear> @version
22:18:22 <lambdabot> lambdabot 4p548, GHC 6.6 (Linux i686 2.66GHz)
22:18:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:19:00 * lambdabot purrs
22:19:18 <Tac-Tics2> f-d: python is a slick language
22:19:27 <Tac-Tics2> If you are going to use any imperative language, it's that or Ruby
22:19:44 <FMota> omg, I wish oerjan was here to tell him how amazing his V interpreter is.
22:19:48 * Pseudonym has a soft spot for Modula-3
22:19:59 <FMota> It's so amazing I don't understand half of it. :o
22:20:00 <Pseudonym> As imperative languages go.
22:20:07 <Tac-Tics2> python is just so clean and simple
22:20:19 <brad_> anyone here "get" factor? as in the factor language?
22:20:24 <Tac-Tics2> it's like a toy programming language with a laser or something taped onto it
22:20:30 <SamB_XP_> Tac-Tics2: it's actually dirty and complicated
22:20:36 <f-d> Now, I don't know a whole lot about Haskell.  I've dabbled with it in the past, but I'm wondering: how good is it for metaprogramming?
22:20:45 <monochrom> Modula-3 was the best imperative language at its time. Good types. Good modules. Good exposure and hiding of low-level stuff.
22:20:48 <SamB_XP_> but I'll admit code can be clean and simple
22:20:59 * monochrom is a secret fan of Greg Nelson
22:21:00 <Tac-Tics2> SamB_XP_ I mean from a visual stand point =-P
22:21:02 <sorear> brad_: maybe not *now*, but slava is a regular here
22:21:02 <SamB_XP_> it just has a lot of dark corners, full of cobwebs and cat poop
22:21:10 <Tac-Tics2> yeah
22:21:23 <Tac-Tics2> Python's object model isn't quite perfect, in particular
22:21:26 <brad_> factor is the one language i look at where i just don't get even the simple code samples
22:21:28 <Tac-Tics2> but I don't think any language gets that right
22:21:35 <SamB_XP_> Tac-Tics2: that's an understatement
22:21:36 <brad_> as in, i don't get what you are "buying"
22:21:55 <sorear> brad_: Seen J or K?
22:22:05 <brad_> no sorear
22:22:16 <FMota> Anyway, i'm really leaving now. Ciao.
22:22:17 <Tac-Tics2> but for getting stuff done, python with its huge and most importantly EASY-TO-USE standard library
22:22:22 <brad_> i think for alternative languages, haskell is where i will keep my focus
22:22:36 <brad_> just finished rewriting most of my perl stuff in it
22:22:45 <Tac-Tics2> it's just the superior choice for a good number of problem domains
22:23:08 <Pseudonym> monochrom: Yeah, I'm not claiming that Modula-3 is great by modern standards.
22:23:14 <Pseudonym> But it's certainly a high point for me.
22:23:33 <Pseudonym> It's like Ada, only not unwieldy.
22:23:39 <FMotAFK> btw, I love Python. More than Haskell. Yes, you may lynch me now. :)
22:23:46 <Tac-Tics2> hah
22:23:48 <Pseudonym> Modula-3 : Ada :: Pascal : Algol
22:23:57 <johnnowak> brad_: i "get" factor
22:24:02 <Pseudonym> FMotAFK: You're just lucky that you're AFK.
22:24:13 <FMotAFK> I guess I am. :)
22:24:20 <Tac-Tics2> Python is just great because it is optimized for learning the language
22:24:30 <johnnowak> brad_: factor is actually very simple. simpler than than most any mainstream language.
22:24:36 * Pseudonym watches Rob Pike's Google tech talk
22:24:38 <Tac-Tics2> Haskell is probably the most intimidating language ever
22:24:49 <brad_> johnnowak: cool, maybe i will take another look at it someday
22:25:00 <Pseudonym> Tac-Tics2: Guess you've never tried programming anything in Sendmail.
22:25:17 <dhpeterson> gotta love m4 ;)
22:25:41 <Tac-Tics2> Learning Haskell is O(2^n)
22:25:41 <olsner> and the m4 code isn't even the actual config file ;-)
22:25:47 <brad_> i would like Makefile syntax as probably the worst in my opinion, although i have never tried sendmail
22:25:48 <Tac-Tics2> learning python is O(1)
22:25:59 <Tac-Tics2> maybe not O(1)
22:26:03 <Tac-Tics2> like O(ln n)
22:26:15 <SamB_XP_> Tac-Tics2: it's called O(log n)
22:26:20 <SamB_XP_> because that's easier to say
22:26:27 <SamB_XP_> and because it's equivalent
22:26:36 <brad_> python is a pretty good swiss-army-knife language...i still cling to perl
22:26:38 <Pseudonym> LOL!
22:26:50 <Pseudonym> Rob Pike's email address is r.  It's at google.com, but it's just r.
22:26:57 <Pseudonym> How did he manage that?
22:27:01 <johnnowak> Tac-Tics2: python has a lot of dark corners. O(log n) is generous
22:27:01 <SamB_XP_> r@google.com?
22:27:02 <Tac-Tics2> Screw that SamB, I'm gonna start calling it O(pi * log(n) + e)
22:27:08 <dhpeterson> Pseudonym: easy, he wrote unix ;)
22:27:11 <Pseudonym> SamB: I was hoping to avoid him some spam.
22:27:12 <SamB_XP_> Pseudonym: nobody else who worked there had taken it?
22:27:17 <Pseudonym> This channel is logged, you know.
22:27:22 <SamB_XP_> oops
22:27:33 <SamB_XP_> maybe the spambots won't notice that
22:27:42 <SamB_XP_> or maybe if I say honeynet or something it will scare them away
22:27:51 <olsner> it might be nice to introduce haskell as the new sendmail config-file-generating language
22:27:56 <brad_> having a short, cool email address is a straight line to spam hell. i know, i had "brad@yahoo.com"
22:28:03 <dhpeterson> heh - at least gmail's spam filter will get well trained!
22:28:16 <monochrom> O(2^n) is faster than Haskell's type inference algorithm.
22:28:25 <Pseudonym> brad: That's a real name.
22:28:31 <SamB_XP_> monochrom: seriously?
22:28:35 <Pseudonym> Which is faster, since it's vulnerable to a dictionary attack.
22:28:50 <SamB_XP_> Pseudonym: maybe the dictionary has "r" in too
22:28:51 <Pseudonym> I would guess that r might actually get _less_ spam.
22:29:01 <ddarius> SamB_XP_: Yes.
22:29:03 <Pseudonym> No spam checker would think it's real.
22:29:20 <SamB_XP_> ddarius: depends on the dictionary
22:29:21 <Pseudonym> My 5-year-old daughter gets spam even though she doesn't have email.
22:29:29 <SamB_XP_> spammers don't necessarily take the wordlist from dict.org
22:29:40 <SamB_XP_> Pseudonym: how?
22:29:42 <ddarius> SamB_XP_: I was referring to your question to monochrom.
22:29:43 <Pseudonym> Because she has a name that's in some dictionary of first names.
22:29:55 <Pseudonym> I only know because I created the account.
22:29:59 <ddarius> olsner: There is some mail thing in Haskell.
22:30:00 <Pseudonym> And being root, I get bounce messages.
22:30:08 <vincenz> How can you get spam without an email account?
22:30:09 <brad_> definitely without a doubt all spam lists include all combos of letters of length four or less, they know these are sought after addresses
22:30:20 <SamB_XP_> vincenz: well, it's addressed to her unix account
22:30:26 <Pseudonym> Right.
22:30:31 <SamB_XP_> vincenz: but that account doesn't have mail delivered to it
22:30:36 <vincenz> Your 5-year old uses unix?
22:30:38 * vincenz is impressed
22:30:39 <olsner> actually, thinking about that, it would probably be nicer to write the whole SMTP server in haskell than ever involving sendmail
22:30:47 <SamB_XP_> vincenz: probably for games!
22:30:48 <Pseudonym> vincenz: Actually, no.
22:30:52 <ddarius> vincenz: People constantly get snail mail spam.
22:30:55 <Pseudonym> But she did learn how to suspend a process at age 2.
22:31:02 <vincenz> ddarius: yeah, I feel sorry for all the trees.
22:31:09 <dhpeterson> heh does she use screen?
22:31:10 <dhpeterson> :)
22:31:20 <vincenz> Pseudonym: accidentally typed ctrl+z?
22:31:21 <Tac-Tics2> Monad a => SpamMonad a where
22:31:21 <Tac-Tics2>     spam person :: String -> IO a
22:31:22 <SamB_XP_> but they don't use dictionary attacks for snail-mail spam
22:31:27 <SamB_XP_> phonebook maybe
22:31:30 <SamB_XP_> but not dictionary
22:31:57 <vincenz> I think it's by referral, like when they ask you your address for your grocery-store card, or just spam everyone in one neighbourhood
22:32:16 <SamB_XP_> yeah
22:32:21 <vincenz> In belgium we have a special sticker for that which you can place on your mailbox "Don't leave unaddressed stuff"
22:32:28 <vincenz> Though some bastards start spamming with seemingly serious letters :|
22:32:48 <brad_> were it not for snail mail spam the USPS would be out of business
22:32:53 <brad_> they secretly love it
22:33:03 <Pseudonym> That and eBay.
22:33:11 * vincenz has never used ebay :)
22:33:21 <Pseudonym> But the postal service loves it.
22:33:21 <SamB_XP_> the thing about snail mail spam is that it's legal because they pay the cost of it's transportation, not you
22:33:22 <brad_> ebay is not bad if you are careful
22:33:24 <ddarius> I've used it once or twice.
22:33:41 <vincenz> And I send my amazon stuff to work, cause you have to sign off on deliveries
22:33:55 <brad_> for some items it is essential - i like to buy straight razors...for that and other collectibles, the secondary market is the only market
22:34:21 <Pseudonym> Yeah, I have a small collection of slide rules.
22:34:24 <vincenz> You use second-hand razors?
22:34:25 <vincenz> Eww
22:34:30 <brad_> yes vincenz
22:34:37 <brad_> they have been sterilized
22:34:50 <vincenz> aren't they really dull-edged?
22:34:55 <brad_> i shaved recently with one which was US civil war issue
22:35:07 <brad_> no vincenz, the sellers often hone them prior to sale
22:35:25 <brad_> they are beyond sharp
22:35:30 * vincenz hmms
22:35:34 <brad_> only surgical tools are close
22:35:39 <monochrom> interesting
22:35:46 <ddarius> They are only half an atom wide at the edge!
22:35:48 <brad_> people "finish" the edges on newsprint
22:36:17 <vincenz> surgical tools are scary, I once threw a surgical knife into a shelf of very hard plastic, it just stuck straight into it
22:36:22 <brad_> a good one can a century
22:36:39 <vincenz> brad_: you mean those things that you flip open?
22:36:39 <Pseudonym> Yeah, I shave with a liston knife.
22:36:54 <brad_> yes vincenz
22:37:03 <monochrom> scary tools you have
22:37:16 <vincenz> Alright, I'm off
22:37:26 <SamB_XP_> fancy shaving with a scalpal?
22:37:26 <monochrom> shaving with unsafePerformIO essentially
22:37:27 * Pseudonym can imagine that taking your shaving kit on a plane would be problematic
22:37:40 <Pseudonym> SamB: That's what I'm saying.  Liston knife.
22:37:42 <brad_> hey i figure shaving with a straight blade is a lot like programming in haskell
22:37:50 <sebell> brad_: I do both!
22:37:54 <brad_> harder to learn, more rewarding, a bit of testosterone involved
22:38:21 <SamB_XP_> confusing error messages?
22:38:27 <monochrom> hahahaha
22:38:49 <brad_> sebell - are you on straightrazoreplace forums?
22:38:49 <monochrom> people think you're weird
22:39:00 <brad_> i think there is a sebell there too
22:39:07 <monochrom> .... they have a forum? ...
22:39:14 <sebell> brad_: That's me :)
22:39:16 <Tac-Tics2> instance Monad Shaving .....
22:39:22 <SamB_XP_> monochrom: where are they supposed to exude their testosterone?
22:39:37 <LeCamarade> This kind of thing is why I am more-rewarded reading #haskell
22:39:44 * monochrom 's mental model collapses the second time
22:39:44 <LeCamarade> :o)
22:39:46 <brad_> yes monochrome, its a small but vibrant community, a little bit red-state but thats okay
22:40:53 <brad_> anyway this is all dreadfully offtopic
22:40:55 <Pseudonym> I remember when "red state" referred to the Communist bloc.
22:41:02 <bparkis> ok so I'm composing a letter offering to assist a professor in research, and I basically just say, I want to assist in research, here are the technical courses I've taken and the computer languages I have experience in
22:41:16 <Pseudonym> bparkis: Perfect.
22:41:28 <Pseudonym> Also say what you've read about but HAVEN'T formally studied.
22:41:33 <Pseudonym> What you're interested in is often more important.
22:42:47 <Tac-Tics2> Sigh, I really want to do graduate school some day
22:43:16 <bparkis> well I mention machine learning but I don't go into great detail
22:43:16 <ddarius> Tac-Tics2: Then do it.
22:43:18 <Tac-Tics2> But I got bad grades in school and I really didn't click with any of the professors in my department
22:43:25 <brad_> Tac: biggest mistake of my life was grad school
22:43:30 <brad_> waste of time
22:43:40 <Tac-Tics2> what did you study brad_?
22:43:53 <brad_> compsci, focusing on computational geometry
22:44:05 <Tac-Tics2> why do you feel it was wasted?
22:44:39 <brad_> well naybe i had misconceptions of what it would be
22:44:44 <brad_> there is still coursework
22:44:46 <Tac-Tics2> heh
22:44:54 <Tac-Tics2> that's why my grades always sucked in school
22:44:55 <brad_> its not all topic exploration
22:45:15 <Tac-Tics2> in high school, I thought to myself "This is going to be when I learn about the cool things there are in life"
22:45:16 <Tac-Tics2> wrong
22:45:17 <brad_> i found it to be just more school
22:45:31 <Tac-Tics2> in college "this is where people respect you and you learn about your future trade"
22:45:32 <Tac-Tics2> wrong
22:45:49 <brad_> maybe if i had gone out to work after undergrad then i might have appreciated it more. instead i followed four years of school with more school
22:45:53 <brad_> and more "poverty"
22:46:08 <brad_> thats another thing
22:46:27 <brad_> i hated living like a poor student at that point
22:47:07 <Tac-Tics2> what do you do now?
22:47:17 <bparkis> I kind of wish I could take an unlimited number of courses
22:47:26 <brad_> engineer at yahoo for 12 years now, totally unrelated to my grad work
22:47:37 <Tac-Tics2> heh
22:47:43 <Tac-Tics2> do you like your job?
22:47:48 <bparkis> I mean there are subject areas I haven't touched that I want to learn about
22:48:06 <Tac-Tics2> bparkis: same here
22:48:16 <brad_> its had its fun parts, some boring parts, i've been there so long now i don't even think i could figure out how to work somehwere else
22:48:35 <brad_> did get to create some neat stuff
22:48:36 <Tac-Tics2> I'm fresh out of college with a crappy paying job in PHP
22:48:42 <Tac-Tics2> Programming in PHP makes me want to cut myself
22:48:51 <Tac-Tics2> (but not really)
22:49:14 <brad_> php is an in-demand skill but the market is flooded with php coders
22:49:24 <brad_> i think you want something more on your resume over time
22:49:31 <Tac-Tics2> yeah
22:49:45 <Tac-Tics2> PHP is just such a garbage language
22:49:48 <Tac-Tics2> it's not fun to program in
22:49:54 <bparkis> I never learned php... I heard that it is poorly designed
22:49:57 <brad_> at yahoo at least, the php-only crowd face an informal salary cap
22:49:58 <Tac-Tics2> and the software I design is such crap
22:50:09 <Tac-Tics2> bparkis: it's really quite terrible
22:50:22 <bparkis> I know python instead
22:50:33 <Tac-Tics2> I wouldn't mind doing python
22:51:01 <Tac-Tics2> Python at least has first class functions and runtime type checking
22:51:18 <Tac-Tics2> PHP will let you add strings and fruit punch together
22:51:31 <Tac-Tics2> and it will barely make a wimper that you did something questionable
22:51:58 <SamB_XP_> Tac-Tics2: PHP *has* fruit punch?
22:52:07 <bparkis> type safety is nice
22:52:13 <Tac-Tics2> lol samB
22:52:15 * SamB_XP_ heads to bed
22:52:19 <Tac-Tics2> night
22:52:23 <f-d> Is there a market for python coders?
22:52:28 <brad_> absolutely f-d
22:52:43 <brad_> but i think you never want to be a one-tool coder
22:52:46 <bparkis> better if it's static, that's why I'm abandoning common lisp
22:52:51 <bparkis> in favor of haskell
22:53:35 <Tac-Tics2> Dynamic Typing is nice for throwing stuff together sometimes
22:53:50 <f-d> Well...it would be nice to get a real job programming.
22:54:02 <f-d> But I don't think I meet the prerequisites.
22:54:22 <sieni> static type checking is nice, run-time type-checking is close to worthless
22:54:29 <brad_> well f-d, at yahoo if you are hotshit enough, the only thing that will keep you out is a criminal record
22:54:37 <johnnowak> sieni: worthless compared to what?
22:54:45 <Adamant> yeah, that's the crack talking
22:55:05 <Adamant> run-time type checking stops a whole lot of problems
22:55:13 <Tac-Tics2> brad_: hotshit enough? explain pls
22:55:24 <sieni> johnnowak: who cares if a program segfaults or aborts with "Error: Expected a value of type <cadarable value>, got 7"
22:55:47 <Adamant> sieni, that can be the difference between a program crash and being pwned
22:55:50 <Tac-Tics2> sieni: knowing what line crashed your program is kinda nice
22:55:58 <Tac-Tics2> something segfaults don't give you
22:55:58 <brad_> well Tac if you are a very good coder and it is obvious from interviews, past experiene etc, i don't think even college is a strict requirement (it might be in 2007, but a few years back when i interviewed a lot, it wasn't)
22:56:00 <johnnowak> sieni: there's a big difference between catching an error, giving a reason, and providing a trace... and possibly continuing on with undefined behavior
22:56:53 <brad_> we had one guy who aced all interviews, and i mean ACED. it was clear he was superior to us...he had no high school but he had a criminal record
22:56:56 <dons> ?users
22:56:56 <lambdabot> Maximum users seen in #haskell: 394, currently: 360 (91.4%), active: 16 (4.4%)
22:57:23 <brad_> since we handle user data, money, etc we couldn't hire him
22:57:24 <johnnowak> and certainly all sorts of systems wouldn't be possible if they had no checking instead of dynamic checking... imagine a live image smalltalk that segfaulted for every "error"
22:59:37 <brad_> signing off, sorry to everyone for so much off-topic banter, i know it devalues the group when too much smalltalk goes on
23:01:05 <sorear> dons: what's going to happen to PLS, in particular their free hosting?
23:04:47 <timchen1`> I'm new to haskell, is there any different between type String and [char] ?
23:05:10 <sieni> they are the same type
23:05:12 <f-d> not as I recall
23:05:35 <timchen1`> cause :t "hey" give me [Char] and :t "hey" :: String give me String
23:06:30 <allbery_b> @src String
23:06:30 <lambdabot> type String = [Char]
23:06:33 <dons> YOW! I should file a PETITION for an ALIEN FIANCEE
23:06:48 * dons gets to play Zippy in the real world. fun fun
23:07:03 <sieni> johnnowak: yeah, like if dynamic type safety is 1 meter ahead of just segfaulting, then static type safety is something like 3 kilometers ahead
23:08:17 <johnnowak> that statement is so obviously bogus i'm not going to bother
23:08:30 <Pseudonym> Oh, I wonder if the admin sock puppet feature works with dons.
23:08:49 * Pseudonym probably isn't a dons admin
23:09:21 <dons> heh
23:10:11 <dons> Pseudonym's up to something..
23:10:22 <Pseudonym> Just seeing if lambdabot is a dons admin.
23:10:27 <dons> yeah. weird
23:12:50 <dibblego> can you have lazy function arguments in Ruby?
23:14:00 <Eelis> dibblego: you got the wrong door, #ruby is three doors down the hall
23:14:08 <allbery_b> standard arguments aren't lazy but you can pass a block which is only evaluated when the function demands it
23:14:18 <dons> Eelis: but they don't know what laziness is ;)
23:14:30 <dibblego> Eelis, #haskell knows more about Ruby than #ruby
23:14:41 <dons> dibblego: and you should be able to move it under a lambda, as in other strict languages
23:14:49 <dons> i guess the code block is the same thing, allbery_b ?
23:14:51 <dibblego> dons, ok thanks, what I thought
23:15:06 <allbery_b> well, you can only pass a single code block
23:15:26 <sieni> johnnowak: well, perhaps I'm exaggerating a bit, but my gripe with dynamic type checking is that you have to actually hit the code path that causes the type error to notice it, with type inference or more traditional static typing you will check everything at once and before the program executes
23:15:28 <allbery_b> and it's only as lazy as the called function's use of "yield" is
23:15:45 <glguy> you can pass a single code "block" but you can pass any number of procs
23:15:52 <allbery_b> that's true
23:16:00 <johnnowak> sieni: sure, I don't disagree with that.
23:16:10 <allbery_b> painful though, compared to the block
23:16:14 <dons> so blocks aren't first class values, somehow?
23:16:29 <sieni> johnnowak: I occasionally just express myself a bit colourfully, so to speak.
23:16:43 <allbery_b> they are, it';s the function syntax that is odd
23:16:55 <dons> ah
23:17:11 <allbery_b> any function call can optionally include a single block after the other arguments, which is wrapped up in a proc object nd passed in as &block
23:17:21 <johnnowak> i don't suppose anyone can explain to me why ruby needs both blocks and procs
23:17:37 <allbery_b> it's a syntactic convenience
23:17:48 <glguy> the list of subtle differences is quite long
23:17:49 <allbery_b> the block syntax lets you write methods that look like control syntax
23:18:03 <allbery_b> hm, thought the subtle differences were going away
23:18:06 <johnnowak> but they are two different types, aren't they
23:18:09 <dons> ok, the syntax (and apply semantics!) are optimised this way for what purpose?
23:18:19 <allbery_b> I know it was pretty bad in 1.6 but I thought when they started turning blocks into procs in 1.8 it got better
23:18:28 <johnnowak> it's a mess
23:18:41 <dons> we're really spoilt in here.
23:19:10 <dons> language design is hard, let's go shopping!
23:20:35 <allbery_b> (but what do you expect from a language that's basically the bastard offspring of perl and smalltalk?)
23:20:46 <Lycurgus> must be ruby
23:20:51 <LeCamarade> Proc is a block, and is like the C block, in that all controls are local. The lambda is different.
23:21:14 <LeCamarade> A return in a proc exits the lexical function.
23:21:14 <johnnowak> can you also pass methods?
23:21:22 <LeCamarade> s/local/lexical/
23:21:29 <LeCamarade> johnnowak: Yeah.
23:21:40 <johnnowak> right. so methods, blocks, and procs.
23:22:23 * dons hands around some more functions. thanks be to the lambda gods!
23:23:01 <takamura> hi
23:23:01 <LeCamarade> Keep your lambda for the _|_ days and check again - it will have turned into a golden ring.
23:23:40 <kfish> takamura, ohayou
23:24:10 <LeCamarade> I find that, in strict langauges, laziness is explicit. All this noise about how laziness makes space complexity uncertain is silly. I worry more about code complexity, which is responsible for the Software Crisis.
23:24:23 <bparkis> so students are not expected to come to prof's with a research idea in hand?
23:24:29 <johnnowak> I can only assume that most people judge the "cleanness" of a language by how good the web design is.
23:24:33 <bparkis> at least at the undergrad level
23:24:37 <LeCamarade> So to laziness, for better or for worse! :o)
23:25:08 <takamura> ohayou, kfish
23:25:09 <sjanssen> LeCamarade: "uncertain" might not be right, but it is certainly difficult to understand on occasion
23:25:17 <LeCamarade> s/laziness/implicit, default laziness/gi
23:25:22 <johnnowak> LeCamarade: don't forgetting debugging difficulties.
23:26:32 <LeCamarade> Me, I prefer to just use take 5 [1 ..] rather than wrapping that in a clever series of ifs. There are better problems to solve than if-balancing. Frankly, I wish I had never known an alternative to Haskell-esque laziness.
23:26:57 <dons> LeCamarade: yeah :) i hate computing exits from loops. how boring!
23:27:11 <johnnowak> LeCamarade: you can do that in many "strict" languages.
23:27:55 <jewel> newsqueak has nothing to do with squeak smalltalk?
23:28:35 <LeCamarade> johnnowak: Not really. If the args are going to be evaluated, I've hit _|_. The Py guys here, I told them the standard ternary in Py (x and y or z) is simple lazy eval. And they realised the power they'd been hidden from.
23:28:45 <LeCamarade> jewel: No, nothing.
23:29:07 <LeCamarade> jewel: It descends from a language called Squeak, which is different from Squeak Smalltalk.
23:29:12 <f-d> * the power that has been hidden from them.
23:29:15 <jewel> and this predates erlang?
23:29:22 <f-d> Sorry :)
23:29:23 <LeCamarade> > "Squeak" == "Squeak Smalltalk" -- :o)
23:29:23 <lambdabot>  Unbalanced parenthesis
23:29:32 <johnnowak> LeCamarade: there's nothing stopping you from having a lazy list data structure in a strict language.
23:29:37 <Pseudonym> Bug in lambdabot.
23:29:47 <dons> in Language.Haskell, in fact
23:29:52 <Pseudonym> Yes.
23:30:06 <LeCamarade> johnnowak: Yeah, and it takes the series of ifs I am running away from.
23:30:11 <dibblego> just a brief look at Ruby, it seems like Perl dressed up a bit; what's the compelling bit?
23:30:37 <allbery_b> an actual object model, lifted from smalltalk, for one
23:30:45 <f-d> Lot of talk on the web about ruby and metaprogramming.
23:30:55 <dons> dibblego: object model, yeah. that's what people like, and the web framework thing they have
23:30:56 <johnnowak> LeCamarade: are you talking about implementing the list or using it?
23:31:03 <LeCamarade> dibblego: That is a really hard question. Just think you will no longer have to write loops. And even the /regex/ constructor is an object. That and a million other things. :o)
23:31:06 <dons> what's that called? ruby webforms or something?
23:31:09 <jjore> It's got ubiquitous autoboxing (or rather - stuff is already objects). Perl would be nicer if it had that.
23:31:16 <allbery_b> rails
23:31:17 <dons> ;)
23:31:21 <dibblego> LeCamarade, I already don't have to write loops and yet every tutorial teaches me I need them
23:31:22 <LeCamarade> johnnowak: About using laziness.
23:31:24 <dons> allbery_b: i knew someone would have to bite :)
23:31:38 * LeCamarade never used Rails in all these years of Ruby. Not even a single web page.
23:31:44 <allbery_b> (as in,run out of town on?)
23:31:50 <dons> "ruby webforms" would be so much cooler
23:32:05 <dibblego> what's so great about the object model?
23:32:23 <allbery_b> mostly that it exists, unlikeinperl
23:32:42 <allbery_b> (perl's "object model" is a complete and utter hack based on the ancient package model)
23:32:42 <LeCamarade> It's funny when you read a Ruby tutorial by an imperativist and one by a functionalist. They are different. We recurse, they loop. We use 3.time {|x| puts x}, they loop.
23:33:06 <dibblego> LeCamarade, why .time and not .each?
23:33:28 <dibblego> oh wait, because of 3 and not 0...3
23:33:29 <LeCamarade> s/\.time/.times/gi   # :o)
23:33:46 <dibblego> ?rubytype time
23:33:46 <lambdabot> Unknown command, try @list
23:33:51 <dibblego> damn lambdabot!
23:33:59 <johnnowak> LeCamarade: I can do something like '1 to(inf) select(< 5)' in Io, which is a strict language, and nothing horrible happens.
23:34:20 <kfish> dons: you had an example using phantom types buried in your web pages at cse somewhere, do you have the url?
23:34:25 <sjanssen> "3.time" seems ridiculous to me
23:34:37 <johnnowak> LeCamarade: And certainly some strict languages have ways of inducing laziness when appropriate, but without the constant overhead, space issues, etc.
23:34:53 <LeCamarade> johnnowak: That is a lazy evaluation. Io has lazy eval, no? Show Java, now. ;o)
23:35:25 <kfish> dons: btw. welcome to not(.au)
23:35:44 <johnnowak> LeCamarade: Of course it's lazy eval, or at least an emulated form of it. I'm just saying you don't need "a series of ifs" in "strict" languages to do many of the same things.
23:36:09 <LeCamarade> johnnowak: Laziness is necessary for any non-trivial computation (more that two movs and pops). But if you have to wrap ifs in every thing, that is crappy laziness, and it sad how few people realise they are writing the equivalent of implicit lazy eval.
23:36:58 <LeCamarade> johnnowak: DRMacIver was writing a lazy lib for Java. In using it, you don't type the ifs. He does. That's the problem. He probably stopped, after the ifs won the war. That _is_ the problem.
23:37:04 <johnnowak> I'll admit I have no idea what you're getting it. It seems to be some complaint about java.
23:37:38 <LeCamarade> Not Java. All implicit strictness in all languages that require to do the compiler's work as regards strictness.
23:38:13 <LeCamarade> In short, just say no to having to take care of `don't evaluate more that I use' in your visible code.
23:38:17 <johnnowak> Is your argument that lazy eval can be useful, or that all languages should be lazy by default?
23:38:24 <LeCamarade> s/more that/more than/
23:39:30 <LeCamarade> That languages that aren't lazy by default are not advanced enough. They keep you solving the laziness problem (because you will _have to_ solve it), instead of going on with new problems.
23:40:05 <dibblego> LeCamarade, I think DRMacIver will disagree with statement
23:40:06 <LeCamarade> It's like being required to dance the stack dance before you can have local vars. C took that away, hence it was advanced in that.
23:40:08 <johnnowak> LeCamarade: What about a language that is strict by default but allows me to use laziness whenever I'd like to?
23:40:27 <dons> yeah, i think you need to switch easily, comfortably between the two
23:40:29 <dibblego> (or maybe he has learned some things since he first disagreed with my assertion of same)
23:40:58 <LeCamarade> johnnowak: It's closer to the victory, but it also lets you worry about laziness a little bit. Better than the strict-forever, but worse than the lazy-first.
23:41:02 <dons> it should be possible to use lazy lists as control, and define your own control structures with simple enough syntax that people actually do it
23:41:04 <johnnowak> I personally thing that being strict by default but pure enough that you can use laziness when desired is a reasonable approach.
23:41:09 <dibblego> johnnowak, Scala?
23:41:20 <dons> but also you sometimes know how you want to evaluate something, hence it needs to be possible to be strict when required
23:41:31 <dons> haskell's getting there for a good mixed strict/lazy language, actually
23:41:31 <johnnowak> LeCamarade: You have to worry about strictness in Haskell.
23:41:38 <johnnowak> There's no perfect solution.
23:41:55 <dons> since you get all the nice pure, lazy control structures and so on, but a good set of strict types (like bytestrings), and bang patterns for working around strictness analysis
23:42:27 <sjanssen> johnnowak: adding strictness to Haskell is sometimes regarded as a black art, don't you think that adding laziness annotations in a strict language will become the same way?
23:42:29 <dons> strictness wasn't first class before we had bang patterns :)
23:42:41 <LeCamarade> And let's not - I repeat, let's _NOT_ - blame the laziness paradigm when the compilers are the culprits. With a ... `Sufficiently-Smart Compiler (TM), one should get the equivalent of explicit laziness from implicit laziness.
23:42:47 <dibblego> sjanssen, it's harder, if that language also has uncontrolled side-effects
23:43:01 <dibblego> sjanssen, (from experience with such a language, and Haskell)
23:43:02 <johnnowak> sjanssen: It's easier to add laziness to a pure, strict language than it is to add strictness to a pure, lazy language.
23:43:07 <dons> yeah, like unsafeinterleaveIO every day.
23:43:23 <sjanssen> interestingly, forgetting to add strictness to your lazy program makes it use slightly more time/space
23:43:23 <dons> so you're screwed if you're not pure -- you can hardly exploit laziness in the first place
23:43:40 <sjanssen> forgetting laziness in a strict language can mean divergence!
23:44:00 <dons> sjanssen: yeah, there's nice papers about this from the 80s
23:44:26 <sjanssen> johnnowak: I don't really agree there, "seq" is sufficient and pretty simple
23:44:53 <dons> f !x is even better. and dead simple
23:45:01 <LeCamarade> dons: I've found myself sleeping on papers from the 80s of late. I mean, if this stuff is so old, _why isn't Blurb using them?_
23:45:12 <dons> hence you see more strictness in haskell (as a proportion of code), than you see lazy control or lists introduced in strict languages
23:45:18 <johnnowak> sjanssen: Why do you say it is a black art then?
23:45:42 <dons> but none of the strict languages are pure, so they don't try very hard with support for laziness
23:45:49 <dibblego> now that I have stirred the nest, I must depart, bye
23:45:50 <dons> typically just a few primops like if-then-else wired in
23:46:34 <LeCamarade> johnnowak: It's not a black art. Haskell is, above all else, for learning from. Someone is going to put strictness analysis and a better syntax for this in another language, and the `black art' thing will vanish into the compiler and syntax, _where it belongs_.
23:46:34 <sjanssen> johnnowak: oh, I thought you were referring to the complexity of the language specification, rather than the usage of the language
23:46:50 <johnnowak> sjanssen: Yes, sorry.
23:47:26 <sjanssen> johnnowak: as far as using locating opportunities for strictness/laziness, it seems about the same to me
23:47:32 <dons> night all. sweet lambda dreams.
23:47:53 <dons> and try out the xmonad release candidate, if you're a xmonad abuser.
23:47:58 <johnnowak> sjanssen: I mean only that adding something like delay/force is relatively straightforward from an implementation perspective.
23:48:03 <dons> we'll put out a new release tomorrow, so a bit of candidate testing would be good :)
23:49:41 <sjanssen> johnnowak: well, non-strictness is really easy -- just use delay/force everywhere
23:49:42 <LeCamarade> I use OCaml's lazy a lot, but it seems to stand in my way, and is a kind of anti-pattern. But you work with what you have. :o)
23:50:10 <johnnowak> sjanssen: Aye
23:50:20 <sjanssen> it's a bit more difficult to get laziness, I suppose
23:51:17 <sjanssen> I'm sure it's the same case when adding it to a default-strict language too
23:52:05 <sjanssen> in any of the default-strict languages, will "force x + force x" share the results of computing x?
23:52:38 <johnnowak> sjanssen: yes, that's how it works in scheme
23:53:05 <LeCamarade> And OCaml, I think.
23:53:38 <scook0> I suppose if you aren't doing that, you have no business calling your implementation "lazy"
23:53:49 <sjanssen> exactly
23:54:33 <sjanssen> johnnowak: at that point, how is the code for a delay/force library any different than the little bit of thunk handling in a Haskell system?
23:54:45 <johnnowak> I'll admit I'd like to see a strict language with an effect system to enable "safe" use of laziness, futures, etc.
23:55:30 <johnnowak> sjanssen: It's no different.
