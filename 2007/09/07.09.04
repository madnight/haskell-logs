00:01:15 <LeCamarade> Haskell with bang patterns.
01:03:03 <DRMacIver> LeCamarade: Actually the sticking point was the type system.
01:03:20 <DRMacIver> LeCamarade: The laziness aspect wasn't too bad. (although not a lot of fun either)
01:05:08 <LeCamarade> :o)
01:05:44 <DRMacIver> And theoretically the lazy strings project is still ongoing. It's just not very lazy any more except for in a few key places. :)
01:06:28 <DRMacIver> (And I'm thinking strongly of switching to Scala out of frustration)
01:12:54 <LeCamarade> DRMacIver: Scala is good outside Java, and useless outside Java. The Java APIs will not help you use the functional aspects, unfortunately.
01:13:20 <DRMacIver> I know. :)
01:13:42 <DRMacIver> More, they actively hinder you using them.
01:13:44 * DRMacIver had to abandon using Scala on a project for exactly that reason.
01:13:45 <LeCamarade> I ended up leaving F# for C# on .NET for the very same reasons.
01:14:08 <DRMacIver> But here what I really need is functional aspects for the internals.
01:14:31 <LeCamarade> It's a bit of a quiz, this. There would be absolutely no problem if functional programming didn't make alternatives painful.
01:14:45 <LeCamarade> Yet nobody warns you of this aspect when they sing the Haskell praises.
01:14:46 <DRMacIver> The actual API exposed doesn't need to use them nearly as much (although it will certainly expose hook points and methods like map, filter, etc.)
01:14:54 <LeCamarade> And I am serious about this ... :o)
01:14:58 <DRMacIver> Yes. A nuisance, isn't it? :)
01:15:22 <DRMacIver> Of course, I was hooked from day 1.
01:15:27 * DRMacIver learned ML as his starter language.
01:15:42 <LeCamarade> I mean, GOTO is not harmful if GOTO is what is going to be used. GOTO proficiency is good in a GOTO world.
01:15:59 <DRMacIver> GOTO isn't particularly harmful really. :)
01:16:05 <DRMacIver> Spaghetti code is harmful.
01:16:06 * LeCamarade left SML (NJ) for OCaml in the ML days, to avoid the image-centricism.
01:16:21 <kosmikus> there's no "instance Arbitrary Char" in Test.QuickCheck? is there one somewhere else?
01:16:32 <LeCamarade> Yeah. You can have GOTO-ism without a single GOTO in code.
01:16:43 <opqdonut> kosmikus: there's probably a (Enum a) => Arbitary a
01:16:47 <opqdonut> or something
01:17:04 <TSC> Or you could use the instance for Int and toEnum
01:17:05 <DRMacIver> LeCamarade: And you can have nice code involving gotos too, without drinking the "write structured goto!" coolaid.
01:17:54 <oerjan> opqdonut: that would require overlapping instances
01:18:02 <LeCamarade> The Web is one big GOTO-land, the way I see it. :o)
01:18:10 <kosmikus> opqdonut: thanks, it's not so much that I can't define it. I wanted to demonstrate QuickCheck to absolute beginners. Having to define an instance myself is counterproductive ...
01:19:08 <kosmikus> is there a good reason *why* there isn't such an instance?
01:19:12 <opqdonut> oerjan: ah, good point
01:19:24 <oerjan> kosmikus: maybe it's not very useful since most uses of Char require some restricted format
01:20:14 <kosmikus> then it could still be provided in another module; that's why I was asking if there is one
01:29:27 <sjanssen> kosmikus: Data.Binary's tests define an Arbitrary instance
01:29:50 <sjanssen> "instance Arbitrary Char where arbitrary = choose (maxBound, minBound)"
01:30:18 <oerjan> the other way around, surely?
01:31:47 <sjanssen> oerjan: that's the way it is defined
01:32:11 <oerjan> that must be a bug?
01:32:15 <sjanssen> hmm, will we uncover some bugs here?
01:37:41 <alexeevg> @src choose
01:37:41 <lambdabot> Source not found. You speak an infinite deal of nothing
01:37:59 <alexeevg> @src Test.QuickCheck.choose
01:37:59 <lambdabot> Source not found. Wrong!  You cheating scum!
01:49:20 <sjanssen> it uses System.Random, which swaps (lo, hi) if lo > hi
02:09:25 <Svrog> is it safe to use unsafePerformIO when marshaling a struct from haskell to c and then returning the modified struct back to haskell?
02:09:51 <Svrog> assuming the c function has no side effects other than updating said struct
02:11:38 <quicksilver> I don't quite know what you mean but "modified" and "unsafePerform"  in the same sentence sounds ugly :)
02:12:15 <sjanssen> Svrog: yeah, sounds fine
02:12:56 <puusorsa> http://www.fbi.gov/wanted/fugitives/cac/reisch_ec.htm
02:12:58 <lambdabot> Title: Federal Bureau of Investigation - Wanted By the FBI - Fugitive - Edward Claire R ...
02:14:21 <hpaste>  Svrog pasted "unsafePerformIO and marshaling of structs to and from C" at http://hpaste.org/2566
02:14:26 <Svrog> thats what i mean
02:15:16 <Svrog> is there a better or safer or more efficient way of doing something like that?
02:17:59 <araujo> morning
02:32:07 <LeCamarade> Why didn't anyone tell me about Kinetic? http://www.ninj4.net/kinetic/
02:32:09 <lambdabot> Title: Kinetic Operating System
02:32:34 <LeCamarade> Or am I just out the loop.
02:32:43 <osfameron> oh!  I thought there was just House
02:33:43 <matthew-_> aol
02:33:49 <matthew-_> that looks quite impressive
02:34:01 <LeCamarade> I'm thinking, how would a type-based microkernel rock? Maybe like Singularity, where the separation is type-system-enforced.
02:34:12 <matthew-_> if he'd just got emacs, mutt, ghc and and an irc client working then it'd be usable
02:34:35 <LeCamarade> None of the classic L4 problems, all the classic L4 benefits. Statically.
02:34:52 <LeCamarade> matthew-_: :o)
02:35:09 <dcoutts> sioraiocht: pong
02:35:09 <osfameron> L4?
02:35:31 <osfameron> ah, microkernel
02:35:59 <LeCamarade> Yeah.
02:39:04 <olsner> but kinetic doesn't support running binaries, right? so it's more of a haskell-on-bare-metal library for haskell software, it seems
02:41:25 <LeCamarade> Seems so, yes. But a gallant stride. Lemme manufacture some traffic for him/
02:43:34 <tomppa> I would need some (possibly mutable) global state but I'm a bit lost about how to achieve that
02:43:56 <tomppa> actually something like lisp's dynamic variables would be fine
02:44:27 <olsner> you can't have global mutable state! (although in e.g. the IO monad, you can)
02:45:15 <tomppa> I have a bunch of loadFoo :: string -> IO Thingy functions that need to use a list of paths to find the resources
02:45:32 <quicksilver> tomppa: traditional approaches are state monads or environment monads
02:47:08 <tomppa> I just wrestled with IORefs but it doesn't look like I could use them (alone?) to achieve what I want, any pointers
02:47:20 <pejo> LeCamarade, are you aware of Osker?
02:47:39 <LeCamarade> perjo: Yes.
02:48:01 <LeCamarade> perjo: Brings my count to three, now. Osker -> House, Kinetic.
02:48:11 <Svrog> tomppa: like quicksilver said have a look at the state monad
02:48:28 <pejo> LeCamarade, ok, just thought I'd point it out since you mentioned L4.
02:48:36 <tomppa> ok, thanks.
02:50:31 <Liskni_si> i saw a note somewhere that unsafePerformIO . newIORef works like a global variable declaration
02:51:15 <dcoutts> Liskni_si: except that it's evil :-)
02:51:29 <xerox> ?quote sorear unsafePerformIO
02:51:29 <doserj> http://www.haskell.org/haskellwiki/Top_level_mutable_state
02:51:29 <lambdabot> sorear says: unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
02:51:30 <lambdabot> Title: Top level mutable state - HaskellWiki
02:51:39 <LeCamarade> pejo: I'm an L4 fan, but also realistic about its short-comings. I think most things should move to the type system, and we are set to rival the monolithics.
02:52:00 <LeCamarade> :o)
02:52:26 <Svrog> speaking of unsafePerformIO could anyone tell me if there's a better way of doing this: http://hpaste.org/2566
02:53:25 <Svrog> i cant think of any other way to return multiple values from c back to haskell
02:54:08 <Svrog> as in from a c function that is effectively without side effects
02:55:50 <int-e> hmm. Why is there no variant of Data.List.delete with a type signature like filter?
02:56:07 <olsner> filter . not?
02:56:14 <xerox> ?type (filter .) . not
02:56:15 <lambdabot>     Couldn't match expected type `a1 -> a -> Bool'
02:56:16 <lambdabot>            against inferred type `Bool'
02:56:16 <mux> int-e: deleteBy ?
02:56:23 <int-e> @type deleteBy
02:56:25 <quicksilver> Svrog: did you read http://www.haskell.org/haskellwiki/FFICookBook ?
02:56:26 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
02:56:28 <lambdabot> Title: FFI cook book - HaskellWiki
02:56:47 <int-e> xerox: delete stops after the first element found
02:57:00 <xerox> int-e: right
02:57:05 <xerox> ?type filter . (not .)
02:57:05 <Svrog> nope, haven't seen that before
02:57:07 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:57:12 <Svrog> thanks for the link
02:57:29 <mux> :t deleteFirstBy
02:57:31 <lambdabot> Not in scope: `deleteFirstBy'
02:57:37 <mux> :t deleteFirstsBy
02:57:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
02:58:24 <xerox> ?type deleteBy
02:58:26 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
02:58:50 <mux> looks like deleteBy is only slightly more generic than what you need
02:58:59 <int-e> mux: I expected deleteBy to have that signature, too.
02:59:41 <int-e> ok, I could cheat with  deleteBy (const f) undefined
02:59:48 <int-e> (yuck)
03:00:01 <doserj> which is not any better than filter (not f)
03:00:23 <mux> filter would remove all the elements, he only wants to remove the first
03:00:27 <doserj> ah
03:00:56 <ivant> is there haskell library which can generate PostScript files?
03:00:57 <quicksilver> I would use takeWhile and tail, I think
03:01:33 <int-e> s/tail/drop 1/
03:01:53 <doserj> http://cryp.to/funcmp/
03:01:55 <lambdabot> Title: Functional MetaPost
03:01:59 <int-e> anyway I know how to write it, I'm just surprised that it doesn't exist :)
03:02:01 <Svrog> quicksilver: hmm.. stuff on that page seems pretty basic and doesn't really help me :(
03:02:07 <mux> it's probably easier to write it self with explicit recursion
03:02:18 <ivant> doserj, thanks
03:02:21 <int-e> mux: yeah that's what I did actually.
03:02:51 <quicksilver> Svrog: there is an example of multiple I/O parameters, though
03:02:54 <quicksilver> Svrog: using pointers
03:03:02 <quicksilver> (which is one way to return multiple things)
03:04:32 <Svrog> it's doing pretty much the same thing that i'm doing though
03:05:50 <Svrog> the main question i had was if you have a function written in c that has no side-effects - for example a function like int f(int x) { return x + 3; } in haskell it's safe to represent that as CInt -> CInt instead of CInt -> IO CInt (or am i wrong about this?)
03:06:35 <quicksilver> no, you're right about that
03:07:05 <Svrog> but when you're marshaling a struct and use something like the with function to get a Ptr to that struct, the result is wrapped in the IO monad
03:07:18 <quicksilver> yes, I see what you mean
03:09:22 <quicksilver> yes, that does seem like a reasonable use of unsafePerformIO
03:12:07 <ivant> wow, funcmp is really cool
03:13:28 <ivant> I wonder if it makes sense to replace the .tex files with haskell programs which produce all the mp/tex source dynamically
03:18:43 <tomppa> umm, results of mixing IO and State monads seem a bit clumsy
03:19:38 <tomppa> I'm using http://haskell.org/haskellwiki/Simple_StateT_use as an example
03:19:39 <lambdabot> Title: Simple StateT use - HaskellWiki
03:19:45 <Svrog> you dont mix IO and state monads, state monad is used for state - it is used where you dont need all the functionality provided by the IO monad
03:19:46 <tomppa> yep, that
03:20:02 <Svrog> use IO monad only when you have no other choice
03:20:18 <Svrog> try to separate pure code to code that needs the IO monad
03:20:23 <Svrog> to=from
03:21:06 <tomppa> sure, but I'm not sure if my design is screwed up but it would look like it would get a bit unwieldy
03:21:08 <Svrog> and yeah you can use monad transformers like StateT when you have to mix monads
03:21:14 <Svrog> ah
03:22:33 <quicksilver> I think it's quite often sensible to mix IO and state monads
03:22:36 <quicksilver> or IO and reader monads
03:22:46 <quicksilver> typically you might use the reader monad to hold the IORef
03:22:51 <tomppa> scenario is like follows: I use some init function to set up state and init foreign libs, and it seems like that initFun would call my actual main function(s)
03:22:53 <quicksilver> which points to the underlying mutable state
03:23:04 <Svrog> yeah i suppose it depends on what you're doing
03:23:10 <tomppa> and my main function would need to do a lot of IO
03:23:23 <tomppa> at least some parts of it would
03:24:57 <tomppa> I guess I'll just try to refactor the whole State out of the equation, only reason I would need that is because there is just one list of pathnames I would like to transparently hand to one function
03:25:01 <tomppa> seems like an overkill
03:25:40 <Svrog> well what you just described sounds alright
03:26:16 <Svrog> what problem are you having with the state monad?
03:26:44 <quicksilver> tomppa: what you want to do actualy sounds like the reader monad
03:26:46 <Svrog> im guessing the setting up state part is for the foreign libs
03:26:57 <quicksilver> tomppa: and the reader monad is really just a way of passing an argument to every function
03:27:00 <quicksilver> (and hiding the plumbing)
03:27:09 <tomppa> quicksilver: sound like what I would need
03:27:31 <Svrog> but is that state for the foreign code? or for the haskell code?
03:27:40 <tomppa> haskell code
03:27:47 <Svrog> ah
03:27:53 <Svrog> in that case yeah use the reader monad
03:31:00 <tomppa> how are things like this usually handled, say, if I were to implement a haskell library with shared state that calls user code
03:31:15 <tomppa> wouldn't users of that library need to know that they are operating inside state monad?
03:32:31 <quicksilver> yes
03:32:41 <quicksilver> I wrote a long and complicated post about this
03:32:52 <quicksilver> which may make it seem worse, rather than better
03:32:52 <tomppa> url, please?
03:33:31 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
03:33:33 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
03:34:41 <tomppa> that looks like just what I have been looking for :)
03:35:51 <tomppa> using just one monad like IO feels quite elegant to me but I have been a bit puzzled about what happens when you throw more of them into the mix
03:36:51 <quicksilver> that post didn't really stimulate the discussion I had hoped for, though
03:47:07 <osfameron> monads!  in tunnels!  they're coming out of the fucking walls!
03:48:12 <opqdonut> omg
04:03:47 <LeCamarade> Is SHA512 automatically better than SHA(<512)?
04:05:02 <pjd> LeCamarade: define better
04:05:09 <pjd> it's certainly more expensive
04:06:20 <LeCamarade> Harder to cause collision?
04:06:23 <pjd> LeCamarade: many people happily use SHA256
04:06:32 <quicksilver> accidental collisions are obviously less likely
04:06:37 <LeCamarade> In an OS you want the _best_.
04:06:43 <quicksilver> engineered collissions, well, no one knows
04:06:46 <pjd> s/less likely/practically impossible/
04:06:52 <LeCamarade> But it also takes a higher minimum.
04:06:56 <quicksilver> if you do know, then you could become a rich man
04:07:00 <pjd> you have to work pretty hard to collide SHA1
04:07:16 <pjd> an accidental collision is still unheard of, i think
04:07:41 <pjd> in any case, it's between SHA512 and SHA256
04:08:05 <pjd> -384 and -224 are just truncated versions of those
04:11:39 <pjd> LeCamarade: in an OS, efficiency is probably also a concern
04:12:32 <LeCamarade> pjd: Yeah. A BIG concern. But it is implemented at a Forth level. And it removes many other concerns (like chasing down file names) in the long run.
04:14:48 <sieni> LeCamarade: what purpose are do you want to use the hash for?
04:25:56 <LeCamarade> sieni: To identify and validate files.
04:26:35 <LeCamarade> So that if a file matches the hash, it is all we need, not the path thereof (so it can change paths and break nothing).
04:26:45 <sieni> LeCamarade: so why do you need a cryptographically strong hash function for this purpose?
04:27:39 <LeCamarade> It also helps in chaching in the large. So, if you apply it to all files that have gone through this server, you want _absolutely_ no collisions, lest a request for EWD3444.html becomes goatse.jpg or something.
04:28:12 <Botje> ITYM "hello.jpg" :)
04:28:31 <LeCamarade> Because names and location just shouldn't matter, the content should. But matching gigs is worse that working with SHA512, penaly considered.
04:28:51 <LeCamarade> Botje: Well, whatevs. :o)
04:31:53 <ivant> EWD3444 â€” sounds like Dijkstra's writings
04:32:12 <LeCamarade> ivant: Yes. :o)
04:32:26 <LeCamarade> His preachings. :o)
04:33:01 <ivant> Dijkstra wrote unbelievably cool things. It's sad that not many people actually read them
04:34:02 <LeCamarade> ivant: I like them, for one. Nice way to spend a Saturday morning. Even though I disagree every once in a while,
04:34:19 <matt__r> hi peeps, anybody got opinions on eclipsefp?
04:34:46 <ivant> LeCamarade, it's okay to disagree, the main thing is that they make you think and decide for yourself
04:35:28 <LeCamarade> ivant: Indeed.
04:35:42 <ivant> I very much like his ideas about reforming the mathematical writing style (e.g. in formulaes), but it is hard to switch to it
04:36:31 <LeCamarade> What EWD is that?
04:36:45 <LeCamarade> Haven't read it.
04:38:28 <ivant> 1300, 950, 950a, 815, 782, 650 (and probably 619)
04:38:51 <ivant> that's just based on what I have downloaded on my laptop
04:39:09 <ivant> probably there are even more, but 1300/950 should be the most complete
04:39:18 * LeCamarade goes to download ...
04:39:55 <roconnor> ivant: for more like that see: http://www.funmath.be/
04:39:57 <lambdabot> Title: Funmath Home Page
04:40:23 <roconnor> in particular the funmath language rationale and reference leaflet: http://www.funmath.be/LRRL.pdf
04:40:28 <ivant> roconnor, wow, looks interesting
04:42:34 <LeCamarade> :-o
04:42:40 <roconnor> ivant: what in intresting is that e /= e' /= e'' means they are all distinct according to his notation.
04:43:20 <roconnor> and more technically the function {0 -> e, 1 -> e', 2 -> e''} is an injection.
04:44:18 * alexeevg recalls "Notation as a Tool of Thought" by Ken Iverson
04:44:56 <alexeevg> though /me cannot accept APL as tool of choice
04:44:59 <ivant> Sapir-Whorf, anyone? :-)
04:45:59 <roconnor> the idea is that this notation can do for logic, what algebra has done for number theory.
04:46:20 <roconnor> screw deductions.
04:46:56 <quicksilver> I absolutely believe that good notation is paramount, and poor notation holds us back
04:47:14 <quicksilver> however, it's hard to overcome all the (mental) investment in old, bad notation
04:54:10 <quicksilver> also it's hard to think of the good notaiton :)
04:55:30 <osfameron> what does the funmath homepage mean about 'quantifiers like " and $' ?
04:56:54 <roconnor> osfameron: hmm
04:56:57 <quicksilver> osfameron: I presume that's a screwed up charset
04:57:02 <roconnor> seems like an encoding issue.
04:57:22 <osfameron> oh :-)
04:57:23 <quicksilver> I presume it's supposed to be \forall and \exists
04:57:28 <osfameron> lambdabot: unicode--
04:58:33 <olsner> @karma unicode
04:58:33 <lambdabot> unicode has a karma of 0
04:58:57 <roconnor>  <font face="symbol">"</font>
04:59:03 <roconnor> is what is in the source :(
05:00:05 <roconnor> ``R. c. L. 2 p. di m. 11 L
05:00:27 <osfameron> meh
05:03:51 <roconnor> > 15*17
05:03:54 <lambdabot>  255
05:04:15 <roconnor> @hoogle digit
05:04:16 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
05:04:16 <lambdabot> Char.digitToInt :: Char -> Int
05:04:16 <lambdabot> Char.intToDigit :: Int -> Char
05:05:03 <roconnor> > iterate (sum . (map digitToInt) . (read)) (15*17)
05:05:04 <lambdabot>  Couldn't match expected type `String' against inferred type `Int'
05:06:56 <roconnor> > iterate (sum . (map digitToInt) . show) (15*17)
05:06:58 <lambdabot>  [255,12,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
05:07:37 <xerox> (You can avoid the parens areound map digitToInt.)
05:08:20 <roconnor> > (find ((==1) . length)) . (iterate (sum . map digitToInt . show)) $ (15*17)
05:08:21 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
05:09:20 <roconnor> > (find ((==1) . length . show)) . (iterate (sum . map digitToInt . show)) $ (15*17)
05:09:22 <lambdabot>  Just 3
05:10:19 <xerox> > find (<10) . iterate (sum . map digitToInt . show) $ (15*17)
05:10:20 <lambdabot>  Just 3
05:10:27 <roconnor> ah
05:10:58 <roconnor> > (mod 9) $ (15*17) -- :)
05:10:59 <lambdabot>  Unbalanced parenthesis
05:11:06 <roconnor> > (mod 9) $ (15*17) -- :(
05:11:07 <lambdabot>  Unbalanced parenthesis
05:11:11 <roconnor> > (mod 9) $ (15*17)
05:11:13 <lambdabot>  9
05:11:19 <roconnor> > (`mod` 9) $ (15*17)
05:11:21 <lambdabot>  3
05:12:51 <xerox> ?check \n -> n > 0 ==> (fromJust . find (<10) . iterate (sum . map digitToInt . show) $ n) == (n `mod` 9)
05:12:54 <lambdabot>  Falsifiable, after 34 tests: 9
05:16:58 <roconnor> 9 `mod` 9
05:17:04 <roconnor> > 9 `mod` 9
05:17:14 <quicksilver> 0
05:17:15 <lambdabot>  0
05:17:19 <quicksilver> I win
05:17:24 <roconnor> :)
05:17:32 <roconnor> @quicksilver-snack
05:17:32 <lambdabot> Unknown command, try @list
05:18:20 <xerox> ?check \n -> (n > 0 && mod n 9 /= 0) ==> (fromJust . find (<10) . iterate (sum . map digitToInt . show) $ n) == (n `mod` 9)
05:18:21 <lambdabot>  OK, passed 500 tests.
05:18:35 <xerox> Now I see what that means :)
05:19:34 <quicksilver> but can you prove it? :)
05:21:02 <roconnor> that's for my students to do.
05:22:45 <xerox> roconnor: are your students around here in the channel?
05:23:08 <roconnor> @losers
05:23:09 <lambdabot> Maximum users seen in #haskell: 394, currently: 369 (93.7%), active: 6 (1.6%)
05:23:13 <roconnor> maybe
05:23:20 <roconnor> probably not thought :)
05:23:23 <roconnor> though
05:24:04 <xerox> I'll prove that in #haskell-overflow :)
05:24:33 <quicksilver> (100a + 10b + c) - (a+b+c) = 99a + 9b
05:24:45 <quicksilver> that's as much as you need to intuit the rpoof :)
05:25:37 <roconnor> xerox: they will never find you there ;)
05:25:43 <xerox> OK :)
05:25:48 <xerox> Every number can be written in the form c_o + 10 c_1 + ... + 10^n c_n, where 0 <= c_i <= 9 forall i.
05:26:22 <xerox> In Z_9 it holds that [10^k] = [10]^k = [1]^k = [1^k] = 1
05:27:41 <xerox> Hence, if a > 9 then [a] = [c_0 + 10 c_1 + ... + 10^n c_n] = [c_0] + [10][c_1] + ... + [10^n][c_n] = [c_0 + c_1 + ... + c_n] = [a_1] with 0 <= a_1 < a.
05:32:32 <waern> dcoutts: thanks for the c2hs release btw
05:35:33 <dcoutts> waern: no probs :-)
05:54:07 <roconnor> @check \a e -> 0 < a && a < 1 && 0 < e ==> 0 <= (a + e*a - e - a*a::Double)
05:54:12 <lambdabot>  Falsifiable, after 0 tests: 0.3333333333333333, 2.0
05:54:48 <roconnor> that would make it more difficult to prove.
05:57:26 <roconnor> @check \a e -> 0 < a && a < 1 && 0 < e ==> 0 <= (a/e - 1) <= 1/e - 1/a
05:57:28 <lambdabot>      precedence parsing error         cannot mix `(<=)' [infix 4] and `(<=)' ...
05:57:35 <roconnor> @check \a e -> 0 < a && a < 1 && 0 < e ==> (a/e - 1) <= 1/e - 1/a
05:57:36 <lambdabot>  Add a type signature
05:57:44 <roconnor> @check \a e -> 0 < a && a < 1 && 0 < e ==> (a/e - 1) <= (1/e - 1/a::Double)
05:57:46 <lambdabot>  Falsifiable, after 0 tests: 0.75, 1.0
05:58:31 <cizra> How do I get data out of lists?
05:58:44 <cizra> (Haskell newbie)
05:58:55 <opqdonut> > head [1,2,3]
05:58:58 <lambdabot>  1
05:58:59 <opqdonut> > tail [1,2,3]
05:59:00 <lambdabot>  [2,3]
05:59:02 <geezusfreeek> cizra, in short, pattern matching
05:59:03 <opqdonut> > [1,2,3] !! 2
05:59:05 <lambdabot>  3
05:59:05 <geezusfreeek> or head and tail, yes
05:59:13 <opqdonut> !! is for indexing
05:59:28 <cizra> Oh, thanks
05:59:33 <geezusfreeek> !! is not usually preferred, if it can be helped
05:59:54 <roconnor> cizra: if the list is empty there is no data to get.
05:59:55 <geezusfreeek> but if you really really only want something at a particular index, it works nicely
05:59:56 <cizra> Eh. I want to read n'th Fibonacci number from a list.
06:00:09 <geezusfreeek> i'd say that's a good application for it
06:00:25 <mux> > fix ((1:) . scanl (+) 1) !! 10
06:00:27 <lambdabot>  89
06:00:38 <quicksilver> !! is best used on infinite lists
06:00:41 <quicksilver> then you know it's ok :)
06:00:51 <cizra> *sigh* How do I output it?
06:00:52 <quicksilver> on short lists it's often saner to pattern match
06:00:56 <cizra>         putStr [1, 2, 3] !! 1
06:00:58 <cizra> doesn't work
06:01:04 <mauke> cizra: needs more parens
06:01:04 <quicksilver> try 'print'
06:01:08 <quicksilver> putStr is for strings
06:01:16 <quicksilver> and you do also need more parens
06:01:19 <mux> > print ([1,2,3] !! 1)
06:01:20 <lambdabot>  <IO ()>
06:01:21 <quicksilver> print ([1,2,3] !! 1)
06:01:25 <cizra> Hooray!
06:01:38 <mauke> @src print
06:01:38 <lambdabot> print x = putStrLn (show x)
06:01:40 <quicksilver> if you're just messing around, don't use print at all
06:01:46 <quicksilver> just type [1,2,3] !! 1
06:01:49 <quicksilver> straight into ghci
06:01:53 <quicksilver> and see the result :)
06:02:00 * geezusfreeek gets the feeling he isn't using ghci :)
06:02:08 <quicksilver> repls are great for experimenting with a new language
06:02:14 <quicksilver> (and an old one too)
06:02:15 <cizra> nono, I'm trying to prove that Haskell can handle recursive calculation of Fibonacci numbers
06:02:28 <cizra> (it's HUGELY redundant and doing lots of work multiple times)
06:02:32 <mux> doesn't everyone take this as granted? :)
06:02:57 <cizra> But lazy evaluation should make this redundancy a moot point, making the recursive algo as efficient as the linear one.
06:03:02 <geezusfreeek> cizra, yes it does, but the fib sequence in particular has all kinds of one-liners with memoization and stuff
06:03:09 <cizra> meh?
06:03:19 <cizra> I want something simple, please.
06:03:59 <mauke> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
06:04:10 <geezusfreeek> http://en.literateprograms.org/Fibonacci_numbers_(Haskell)
06:04:12 <lambdabot> Title: Fibonacci numbers (Haskell - LiteratePrograms
06:04:35 <geezusfreeek> oops
06:04:36 <mux> yay for sharing
06:04:41 <geezusfreeek> doesn't have what i though it would
06:05:01 <cizra> mauke: Yes, that's what I'm using now, just for comparison. Having figured out how to get the data out of it, I can do a comparison with the recursive version.
06:05:10 <geezusfreeek> well, it's still there in some form i guess
06:05:15 <mauke> http://haskell.org/haskellwiki/The_Fibonacci_sequence
06:05:17 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
06:06:18 <geezusfreeek> cizra, laziness doesn't always serve as cheap memoization
06:06:38 <geezusfreeek> particularly when you are making completely separate calls to a function (with different "instances" of its arguments)
06:07:07 <cizra> I suspect this thing is advanced/unneccessary in my case..?
06:07:20 <idnar_> cizra: in what way is that not a recursive version?
06:07:46 <geezusfreeek> well, what kind of production code would you use the fibonacci sequence? :)
06:07:48 <mux> it would actually be pretty hard to code the fibonacci sequence without recursion in haskell
06:10:02 <quicksilver> it's hard to distinguish between iteration and recursion in haskell
06:10:17 <cizra> OK, proven to be incorrect -- the naive recursive implementation is slow as hell.
06:10:34 <geezusfreeek> quicksilver, haskell can do iteration? :o
06:10:37 <quicksilver> since recursion is primitive and all implementations of iteration use some kind of recursion
06:10:57 <Botje> mux: you could abuse the 1 +- sqrt(5) trick
06:11:05 <quicksilver> geezusfreeek: well it rather depends what you think iteration means, precisely
06:11:08 <Botje> for fibs without recursion
06:11:42 <geezusfreeek> quicksilver, i meant on a primitive level, and i was half joking
06:11:45 <MyCatSchemes> 1 +- sqrt(5)?
06:11:57 <mux> Botje: yeah, but isn't that only an approximation?
06:11:59 <MyCatSchemes> Botje: nearest integer to GR^n?
06:12:51 <Botje> mux: that's waht you have round() for :)
06:13:09 <Botje> MyCatSchemes: what's GR? :)
06:13:23 <mauke> > let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round (fromIntegral (fib (n - 1)) * t) in fib 11
06:13:28 <lambdabot>  144
06:13:36 <MyCatSchemes> Botje: golden ratio.
06:13:53 <mauke> > let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round (fromIntegral (fib (n - 1)) * t) in map fib [1 ..]
06:13:55 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
06:14:01 <Botje> oh.
06:17:08 <idnar> > 1 : 1 : zipWith (+) fibs (tail fibs)
06:17:10 <lambdabot>   Not in scope: `fibs'
06:17:22 <idnar> > lit fibs = 1 : 1 : zipWith (+) fibs (tail fibs); fibs
06:17:23 <lambdabot>  Parse error
06:17:26 <idnar> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs); fibs
06:17:26 <lambdabot>  Parse error
06:17:38 <mauke> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:17:40 <allbery_b> s/;/ in /
06:17:40 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:17:52 <idnar> oh, yes
06:18:34 <mux> @check \n -> let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fix ((1:) . scanl (+) 1) !! n == fibs !! n
06:18:35 <lambdabot>  Exception: Prelude.(!!): negative index
06:18:50 <mux> @check \n -> n >= 0 ==> let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fix ((1:) . scanl (+) 1) !! n == fibs !! n
06:18:51 <lambdabot>  OK, passed 500 tests.
06:20:04 <mux> @check \n -> n >= 0 ==> let let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round  (fromIntegral (fib (n - 1)) * t) inin fix ((1:) . scanl (+) 1) !! n == fibs n
06:20:05 <lambdabot>  Parse error
06:20:38 <mux> @check \n -> n >= 0 ==> let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round (fromIntegral (fib (n - 1)) * t) in fix ((1:) . scanl (+) 1) !! n == fib n
06:20:39 <lambdabot>  Falsifiable, after 174 tests: 81
06:20:45 <mux> heh heh.
06:20:46 <idnar> heh
06:21:16 <mux> > let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round  (fromIntegral (fib (n - 1)) * t) in fib
06:21:18 <lambdabot>  <Integer -> Integer>
06:21:21 <mux> > let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round  (fromIntegral (fib (n - 1)) * t) in fib 81
06:21:22 <lambdabot>  61305790721611600
06:21:33 <mux> > fix ((1:)  . scanl (+) 1) !!
06:21:33 <lambdabot>   parse error on input `}'
06:21:36 <mux> damn
06:21:38 <mux> > fix ((1:)  . scanl (+) 1) !! 81
06:21:39 <lambdabot>  61305790721611591
06:21:47 <mux> off by 9
06:21:53 * mux hearts quickcheck
06:22:56 <mux> @check \n -> n >= 0 ==> let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round (fromIntegral (fib (n - 1)) * t) in fix ((1:) . scanl (+) 1) !! n == fib n
06:22:57 <lambdabot>  Falsifiable, after 223 tests: 84
06:23:21 <mux> > let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round fromIntegral (fib (n - 1)) * t) in fib 84
06:23:21 <lambdabot>  Unbalanced parenthesis
06:23:32 <mux> > let t = 0.5 + sqrt 1.25; fib n | n < 2 = 1 | otherwise = round (fromIntegral (fib (n - 1)) * t) in fib 84
06:23:34 <lambdabot>  259695496911122656
06:23:40 <mux> > fix ((1:)  . scanl (+) 1) !! 84
06:23:42 <lambdabot>  259695496911122585
06:58:28 <conal> nominolo: i think waern mentioned that you were working on a cabal patch to get cabal & haddock 2.0 (haddock.ghc) working together.  is that so?
06:59:06 <nominolo> conal, yes but we have a ghc release upcoming and there are some more important issues, atm
07:00:18 <conal> nominolo: oh, okay.  any idea when to expect cabal & haddock 2.0 to work together?
07:01:01 <conal> i have several libraries i'd like to release, and they use language extensions
07:04:23 <nominolo> conal, i know.
07:06:02 <nominolo> conal, i can send you a cabal version where the patch is applied, and you try to duplicate those changes into the latest cabal, send me a patch and i'll review it
07:06:12 <nominolo> conal, but i can't work on it myself today
07:09:35 <conal> nominolo: thanks for the offer.   i don't mind waiting a few days or a week, if that's what it would be.  i'm hoping to get some sense of whether to wait or set up my makefiles to run haddock manually.
07:10:33 <nominolo> conal, i'd suggest makefiles
07:10:57 <nominolo> i'm not sure how long we'll need with the current cleanups / fixes
07:11:36 <conal> nominolo: thanks much.  that's exactly what i was looking to find out. i'll probably go with the makefile tweaks.
07:11:57 <conal> and best wishes with the release etc!
07:12:34 <nominolo> thanks
07:12:53 <conal> @localtime nominolo
07:12:54 <lambdabot> Local time for nominolo is Tue Sep  4 16:12:07
07:13:13 <conal> germany?
07:13:57 <nominolo> sweden
07:14:20 <nominolo> but i am german, yes
07:14:57 <conal> ah.  i see you'll be at Hac.  I'm looking forward to it.
07:16:30 <hpaste>  idnar pasted "PPBM generation" at http://hpaste.org/2567
07:17:19 <idnar> ^^^ is there a more efficient way of doing that? my implementation seems to be horribly slow, at least when dealing with 2048x2048 images and the like
07:21:46 * alexeevg 's brain is going to explode. Data.SuffixTree.fold is too abstract for him :(
07:27:54 <alexeevg> idnar: you may want to use ShowS or similar trick
07:29:30 <alexeevg> idnar: look at the 'DList' type at http://www.cse.unsw.edu.au/~dons/code/hmp3/Lexers.hs
07:30:29 <idnar> alexeevg: I'll take a look, thanks
07:31:47 <alexeevg> idnar: lots of concatenations are faster this way. the question remains if it's reasonable to represent image as [[Bool]]
07:34:54 <xerox> ?where dlist
07:34:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
07:35:57 <idnar> alexeevg: what would you suggest in place of [[Bool]]?
07:36:09 <alexeevg> idnar: array?
07:36:27 <alexeevg> unboxed array perhaps
07:36:52 <idnar> mmm. I guess I'm not really generating it lazily anyway
07:37:19 <alexeevg> xerox: thanks
07:37:37 <pjd> bytestring or something?
07:37:39 <alexeevg> xerox: the link i posted was first in google
07:42:42 <xerox> alexeevg: you're welcome :)
07:56:07 <alexeevg> @yarr
07:56:07 <lambdabot> I heard andersca is a pirate
07:56:15 <alexeevg> @yaww
07:56:15 <lambdabot> Maybe you meant: yarr yow
07:56:20 <alexeevg> @yow
07:56:20 <lambdabot> Do you think the "Monkees" should get gas on odd or even days?
07:57:57 <cizra> lambdabot: All my days are odd.
08:13:54 <dmead> @yow
08:13:54 <lambdabot> ONE:    I will donate my entire "BABY HUEY" comic book collection to
08:13:54 <lambdabot> 	the downtown PLASMA CENTER ...
08:13:54 <lambdabot> TWO:	I won't START a BAND called "KHADAFY & THE HIT SQUAD" ...
08:13:54 <lambdabot> THREE:	I won't ever TUMBLE DRY my FOX TERRIER again!!
08:14:18 <dolio> That was a long one.
08:14:38 <dolio> @quote JonHarrop
08:14:39 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
08:15:01 <shapr> I get the impression he's not a fan of Haskell.
08:15:11 <dmead> @quote sorear
08:15:11 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
08:15:11 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
08:15:14 <shapr> I've also gotten the impression that he's a fan of OCaml.
08:15:25 <dolio> Yeah, I'd say so.
08:15:46 <dolio> I get the feeling he's slightly crazy, though.
08:15:50 <MyCatSchemes> sorear was full of shit.
08:16:08 <MyCatSchemes> There's no way in *hell* anyone could've done all that in C within a week. ;)
08:16:10 <dolio> He recently posted a F# vs. OCaml vs. C++ benchmark on c.l.functional.
08:16:15 <dmead> :P
08:16:33 <mrd> net.kook perhaps
08:16:34 <dolio> And he ran F# on Windows, and the other two on 64-bit Linux or something.
08:16:43 <osfameron> how di dthey compare?
08:16:51 <dolio> F# was fastest, actually.
08:17:19 <osfameron> interesting. apart from being unfair comparison due to architectures
08:17:31 <dolio> But people were complaining that you couldn't draw any meaningful conclusions, because he ran them on totally different operating systems and such.
08:17:42 <dolio> But, he doesn't seem to think that's a valid criticism.
08:18:01 <osfameron> can you run F# on mono?
08:18:04 <LPhas> using gtk2hs there's a way to say that an image has not to be bigger than a (size,size)?
08:18:12 <mrd> that's silly. why not just run ocaml and c++ on windows too.
08:18:36 <dolio> You can, but his argument is that mono is inferior to the MS implementation.
08:18:38 <dcoutts> LPhas: do you mean an image widget or a pixbuf ?
08:18:45 <dolio> But I don't see why you can't run OCaml and g++ on windows.
08:18:52 <osfameron> well, it probably is inferior, yeah
08:18:54 <LPhas> dcoutts: an image widget
08:19:01 <dolio> His argument is that they're "native" to Linux or something.
08:19:12 <mrd> F# should do better than ocaml on windows.
08:19:14 <dcoutts> LPhas: you can set the packing so it does not take any more space than it requests
08:19:32 <mrd> I also think it should do better than g++, but I'm a fan of high level languages.
08:20:06 <LPhas> dcoutts: ok. while using a pixbuf? i see that i can build an image using a pixbuf, so if i can resize the pixbuf i can build a "limited image" this way?
08:20:15 <mrd> his efforts are somewhat quixotic though.  we're not here because we're performance junkies.
08:20:29 <LPhas> suppouse that this let me spare some memory
08:21:05 <dcoutts> LPhas: the memory is only the size of the pixbuf, the image widget doesn't take more memory to display the blank edges :-)
08:21:39 <LPhas> dcoutts: yeah but if i resize the pixbuf, i free some memory, right?
08:21:51 <dolio> mrd: He does make a much bigger deal about performance than I think most people who use the languages care about.
08:22:11 <dcoutts> LPhas: if you delete a pixbuf and create a smaller one, yes.
08:22:11 <osfameron> it's good for *some people* in any community to be raving mad about performance
08:22:40 <LPhas> dcoutts: i see that resizing a pixbuf, copies it, so i think that old one should be garbage collected
08:22:52 <dolio> Although, when he attacks Lisp, his argument seems to include the fact that his solutions are more concise, as well as faster.
08:22:57 <dolio> So, that's a double whammy, I guess.
08:23:19 <mrd> yea but does Harrop actually contribute to the compiler?
08:24:17 <osfameron> mah.  I'd even guess that it's good for *some people* in the community to whine a bit :-)
08:24:34 <wli> If you want the compiler to do something different (e.g. generate faster code, use different or rebindable intrinsics, etc.), there are better things to do than whine.
08:24:38 <wli> Use the source, Luke.
08:25:03 * mrd suspects that the GHC source code leads to the dark side, however.
08:25:21 <wli> mrd: The dark side meaning?
08:25:31 <mrd> anger, hatred, fear and loathing
08:26:05 <osfameron> wli: if you are a high level programmer, and your high level language doesn't work to expectation, then it's not reasonable to expect you to become a low-level programmer to fix it.
08:26:08 <wli> Well, I've got 3 things I want that I'll eventually start pestering people about internals for.
08:26:10 <Japsu> oh, so the "pain and suffering" part with the ghc source is just an indirect consequence
08:26:18 <Japsu> (hatred leads to suffering etc)
08:26:39 <wli> (1) intrinsics gunk for H1.4 prelude support
08:26:39 * mrd whiffed with the star wars reference, a rarity
08:27:05 <wli> (2) type, class, and instance decls at the ghci prompt
08:27:23 <pjd> yay
08:27:29 <wli> (3) there was a third but I forgot it
08:27:53 <mrd> (3) profit!
08:28:06 <wli> That's step 4 of a 4-step program.
08:28:25 <matthew-_> can't be long to go before 6.8-beta snapshots start appearing can it?
08:28:36 <mrd> it's almost been a year since 6.6
08:29:05 * byorgey does the beta dance
08:29:19 <mrd> you can checkout GHC head anytime ;)
08:29:27 <wli> I don't remember (3) at all.
08:29:35 <doserj> but you cannot always compile it...
08:29:40 * byorgey has enough time to apply to grad schools, or compile GHC from HEAD, but not both
08:29:46 <mrd> eh, just poke at it a little
08:29:55 <byorgey> hehe =)
08:30:02 <mrd> unpull the bad patch
08:30:22 <MyCatSchemes> byorgey: what do you mean? Just apply to grad school while the computer's busy compiling.
08:30:27 <wli> Compilation is, um, compilation. It's not real programming.
08:30:33 * mrd is puzzled by byorgey's statement too
08:31:24 <mrd> I hope I still have time for apps,  as I already committed time to compiling GHC!
08:32:03 * byorgey makes a mental note not to make jokes in a place full of geeks without checking them for factual accuracy first =)
08:33:23 <wli> I think (3) may have been something intrinsics-related about numeric hierarchy fixups.
08:35:17 <dolio> Maybe he has to watch the text scroll by to feel productive. Does he run gentoo? :)
08:35:55 <osfameron> of course while ghc compiles your laptop gets very hot and peaks in cpu usage
08:36:07 <osfameron> probably not nice if you're trying to also write letters/forms on it at the same time
08:37:10 <wli> I think (3) may literally be changing integer literals' type so as to accommodate an arbitrary-precision natural number type.
08:37:59 <dolio> You mean, like "-1 :: Nat" would be a compile time error? I'd go for that.
08:38:00 <MyCatSchemes> byorgey: s/geeks/bloody pedantic geeks/ ;)
08:38:06 <wli> Without such you're forced to deal with everything in terms of some partial coercion function.
08:38:31 <xerox> LPhas: if you use glade, you can set properties like size request and packing properties from a GUI.
08:38:50 <wli> dolio: Yes, though it's not quite that because "-1" ends up parsing as "negate (GHC.Num.fromInteger 1)" anyway.
08:38:52 <LPhas> xerox: thx but i'm not using glade
08:39:18 <wli> dolio: "negate (GHC.Num.fromInteger (1 :: Integer))" even.
08:39:54 <dolio> Yeah. I suppose you'd need a richer numeric class hierarchy to make that work.
08:40:17 <dolio> I actually hacked up a template haskell thing to do stuff like that, but it's predictably ugly/verbose.
08:40:26 <wli> dolio: The richer hierarchy is stopped cold by the intrinsics that make it all parse that way; GHC.Num is hardwired in.
08:41:21 <dolio> But I could write '$(check 42) :: Prime' and get a compile-time error. :)
08:41:41 <MyCatSchemes> Is there a Nat class?
08:42:19 <wli> dolio: More useful would be type-level numeral support with someclass constraining numbers to be prime.
08:43:00 <osfameron> like a type guard?
08:43:07 <wli> dolio: Then you could define GF(p^n) as a type.
08:44:39 <dolio> Type-level numerals should be #4 on your list, yes. :)
08:45:18 <wli> dolio: Well, there are plenty of implementations around. Intrinsics and/or syntactic support for them OTOH would be nice.
08:45:34 <wli> dolio: It's too far afield and/or deep for me to deal with, though.
08:45:38 <dolio> So we can do cool stuff without having to write 'B O (B O (B O Z))' or something like that instead of 14.
08:46:29 <wli> dolio: I really have to settle for merely plugging preexisting components together. I lack the depth of knowledge to do anything so involved.
08:46:58 <dolio> Yeah.
08:47:51 <wli> dolio: The parsing/etc. bits for type, class, and instance decls at the ghci prompt are all there merely waiting to be invoked.
08:48:43 <wli> dolio: The H1.4 monad comprehension, do notation, etc. intrinsics are largely search and replace.
08:48:45 <dolio> I suppose. That might require a non-trivial change in how ghci works.
08:48:54 <quicksilver> @where mappend
08:48:54 <lambdabot> I know nothing about mappend.
08:49:04 <quicksilver> gah, what was that command
08:49:05 <mauke> @index mappend
08:49:06 <dolio> Although maybe they could be : commands.
08:49:06 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
08:49:11 <quicksilver> thank you
08:49:36 <wli> dolio: I don't honestly know if that's the case but I've been told it is not.
08:50:03 <dolio> I don't actually know how ghci works, though, I suppose.
08:50:22 <dolio> The interface is that you're essentially running in a 'do' block.
08:50:53 <dolio> So the way you'd get to declarations is 'let ...', but type/class declarations aren't allowed there.
08:51:03 <dolio> But maybe it doesn't really work that way.
08:53:11 <quicksilver> @check \l -> foldr mplus mzero . map return l == (l :: [Int])
08:53:18 <lambdabot>  Couldn't match expected type `a -> [m a1]'
08:53:31 <quicksilver> @check \l -> (foldr mplus mzero . map return $ l) == (l :: [Int])
08:53:33 <lambdabot>  OK, passed 500 tests.
08:53:48 <quicksilver> that, presumably, would be the desugaring for generalised list notation
08:53:54 <quicksilver> I'm not sure I see the compelling case for it, though
08:59:30 <dmead> is there a wrapper for standard C library calls?
09:00:17 <ndm> dmead: its pretty easy to do with the FFI, although most have an equivalent in Haskell
09:00:28 <ndm> dmead: any particular call in mind?
09:00:31 <dmead> yes
09:00:36 <dmead> i need rint
09:00:38 <dmead> round int
09:00:40 <dmead> from cmath
09:00:45 <mauke> rint is not a standard C function
09:00:46 <ndm> @hoogle floor
09:00:47 <dmead> i'm doing a prototype
09:00:50 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
09:01:00 <ndm> dmead: what does rint do? i'm not familiar with it
09:01:01 <mauke> oops, it's in C99
09:01:13 <dmead> actually i need rintf
09:01:19 <ndm> @hoogle round
09:01:20 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
09:01:20 <lambdabot> Text.Html.background :: String -> HtmlAttr
09:01:20 <lambdabot> System.Win32.Info.cOLOR_BACKGROUND :: SystemColor
09:01:31 <dmead> ahh
09:02:00 <dmead> i use rintf to round a float to the nearest 1/10th
09:02:01 <ndm> its much much easier to use the built in haskell stuff, and whatever is in C is probably in Haskell as well
09:02:08 <dmead> ya
09:02:35 <ndm> > let x = 3.142 in round (x * 10)
09:02:42 <lambdabot>  31
09:02:45 <norpan> otoh it's easy to import these kinds of pure c functions into haskell if you really want them
09:02:59 <ndm> then you just need to divide by 10 after
09:03:02 <mauke> > printf "%.1f" 3.142 :: String
09:03:04 <lambdabot>  "3.1"
09:03:47 <oerjan> > printf "%.1f" 3.161 :: String
09:03:49 <lambdabot>  "3.2"
09:03:55 <quicksilver> You may consider using fixed point types too
09:04:06 <dmead> ahh i don't need fancy typing
09:04:11 <dmead> just an approximation of whats in C
09:04:31 <dmead> i'm getting into the habit of doing a rapid prototype in haskell
09:04:37 <mauke> > read . printf "%.1f" $ 3.142 :: Double
09:04:39 <dmead> so C takes less effort
09:04:39 <lambdabot>  3.1
09:04:43 <mauke> perl style!
09:04:43 <quicksilver> > 1.5 * 1.5 :: Micro
09:04:45 <lambdabot>  2.250000
09:05:00 <dmead> bbl
09:05:30 <norpan> @info Mircor
09:05:30 <lambdabot> (Mircor)
09:05:40 <norpan> @where Micro
09:05:40 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Fixed.html
09:05:41 <lambdabot> I know nothing about micro.
09:05:43 <lambdabot> http://tinyurl.com/yqdcrb
09:05:43 <quicksilver> norpan: ^^
09:05:47 <mauke> @info do { x; y }
09:05:48 <lambdabot> (x >> y)
09:05:58 <quicksilver> @index Micro
09:05:59 <lambdabot> bzzt
09:07:28 <norpan> Micro is just Integer interpreted differently?
09:08:10 <matthew-_> yes
09:08:35 <matthew-_> just div 1e6
09:08:46 <quicksilver> norpan: correct
09:08:59 <quicksilver> norpan: integer interpreted as millionths
09:09:02 <norpan> ok
09:09:05 <norpan> good to know
09:09:13 <quicksilver> norpan: the the (+) (*) etc operations doing the behind-the-scenes multiplications
09:09:19 <quicksilver> to keep it all sane
09:09:27 <norpan> of course i used fixed point numbers in assembler 20 years ago :)
09:09:28 <quicksilver> well obviously (+) doesn't have any work to do, but you get the idea
09:10:47 <quicksilver> it's not limited to base 10 FP, it just happens that the built in instances are for 10^6 and 10^12
09:10:56 <quicksilver> although some of the utility functions are base 10-centric
09:11:14 <norpan> sure
09:11:34 <quicksilver> it's quite a nice case study of a simple use of phantom types
09:11:44 <quicksilver> and classes-for-typelevel-functions
09:11:50 <quicksilver> code's only just over a page long
09:12:48 <norpan> i suppose the show function is the most tricky one :)
09:13:58 <quicksilver> yes
09:17:21 <norpan> it could use some binary instances too
09:22:47 <quicksilver> norpan: not very hard to write :)
09:23:26 <quicksilver> norpan: although, the constructor isn't exported so the cleanest solution would need to be inside the file
09:23:35 <quicksilver> this is a typical encapsulation problem :(
09:23:58 <hpaste>  bct pasted "(broken) simple CGI file server" at http://hpaste.org/2568
09:26:40 <Lemmih> Who's bct?
09:26:50 <dons> huh, http://intoverflow.wordpress.com/kinetic/
09:26:52 <lambdabot> Title: Kinetic « Integer Overflow
09:28:14 <matthew-_> dons: yeah, that's making the rounds today
09:28:40 <matthew-_> it looks interesting, but the code doesn't seem to be available (I may be being blind)
09:28:52 <ndm> its amazing that Guillium emails everyone once a month about a Haskell OS, and this guy just goes and writes one
09:29:06 <matthew-_> and there doesn't seem to be much info about the structure of the thing
09:29:26 <Liskni_si> @src fix
09:29:26 <lambdabot> fix f = let x = f x in x
09:29:26 <matthew-_> I got the impression somehow that it's microkernel, but I'm not sure...
09:29:31 <Liskni_si> mornfall: ^^
09:30:30 <shapr> I thought that guy gave up on Kinetic for now?
09:31:07 <matthew-_> he has a blog posting on it from yesterday
09:31:20 <luqui> aww, the haskell garbage collector does not solve the halting problem!
09:31:21 <matthew-_> though it's a posting about thoughts about kinetic...
09:31:35 <luqui> [0..] ++ [foo] does not clean up foo
09:32:19 <olsner> @unpl return . (. (f .))
09:32:20 <lambdabot> (\ e -> return (\ i -> e (\ l -> f (i l))))
09:33:18 <wli> Haskell would not be my first choice to write a kernel in.
09:33:36 <shapr> But maybe it'd be your second? :-)
09:33:48 <matthew-_> well, I'd be prepared to do it, but I would rewrite the runtime
09:34:20 <matthew-_> without rewriting the runtime, I'm not quite sure how memory allocation would ever work
09:34:26 <wli> The operational semantics are too complex.
09:34:35 <dons> so that's #3 or #4 in the list of haskell kernels?
09:34:39 <mornfall> Liskni_si: hm, works
09:34:54 <mornfall> haskell pwns
09:34:55 <shapr> dons: hOp, L4, Kinetic.. what else?
09:35:08 <matthew-_> L4 isn't in Haskell. It's C and C++ iirc.
09:35:17 <dons> yeah, hop/house, sel4, kinetic
09:35:19 <mornfall> L4 is spec, first of all
09:35:26 <mornfall> L4Ka::Pistachio is a C++ implementation
09:35:35 <matthew-_> sorry, correct. Yes, I was thinking of L4ka
09:35:54 <dons> sel4 is the haskell one (from the `running the manual` paper)
09:36:01 <dons> http://programming.reddit.com/info/2lovz/comments
09:36:02 <lambdabot> Title: seL4: a microkernel in Haskell (reddit.com)
09:36:37 <dons> ndm: i think if you know what you're doing, writing a microkernel is like writing a small compiler, complexity-wise
09:37:10 <dons> they churn them out all the time in the OS group at unsw, so an experienced kernel hacker could whip up a haskell one in little time, if they're fluent in the language
09:37:30 <ndm> dons: true, we are turning out compilers all the time in our group - the first one is the hardest
09:37:39 <dons> yeah
09:37:51 <ndm> dons: still, a kernel scares me, but a compiler doesn't
09:38:20 <matthew-_> programming a dma controller or a pci bridge scares me. memory allocation, scheduling etc doesn't.
09:38:31 <SamB> kernels don't scare me too much anymore
09:38:55 <ndm> computers scare me...
09:39:07 <matthew-_> especially those that are turned on!
09:39:36 <dons> and just to round the set out, http://programming.reddit.com/info/2loz1/comments
09:39:37 <lambdabot> Title: A Principled Approach to Operating System Construction in Haskell (reddit.com)
09:39:42 <ddarius> Why is programming a DMA controller scary?
09:39:50 <matthew-_> it's bit banging
09:40:03 * ddarius downloaded both of those papers at the beginning of this year and still hasn't read either.
09:40:11 <quicksilver> programming a DMA controller typically involves hardware timings
09:40:24 <quicksilver> that is scary because interrupts can mess up your timings
09:40:31 <olsner> I'm thinking, a FP kernel would have beautiful pure descriptions of state machines and hardware devices, with some magic to whip up IRQ handler routines and asynchronous code from that description
09:40:38 <quicksilver> or even preemptive scheduling if you're doing userspace drivers
09:41:00 <dons> why doesn't rebekah leslie hang out here?
09:41:04 <quicksilver> I think those things are scary because they're very hard to test
09:41:21 <quicksilver> you can have bugs which only appear in the presence of particular hardware timing occurences
09:41:28 <quicksilver> which may never happen on your particular setup
09:41:57 <xerox> Just have a QuickCheck Testable Computer instance ;-)
09:42:17 <ddarius> dons: Maybe you should email her?
09:42:28 <matthew-_> yes, clearly Haskell is too good for such hardware. We should start by designing some proper hardware.
09:42:40 <ddarius> Lava, that other one.
09:42:45 <ddarius> matthew-_: No problem.
09:43:03 <matthew-_> ddarius: and then manufacture it.
09:43:32 <matthew-_> "The Haskell Community Computer". I suspect Babbage would be proud!
09:43:33 <olsner> like, this computer networks course I'm reading now... I'm just wondering how much simpler it would be in a language with message passing concurrency rather than ugly C hacks
09:44:05 <ddarius> olsner: Implement a message passing language in C.
09:44:17 <matthew-_> Haskell doesn't really have good message passing
09:44:32 <ddarius> matthew-_: It has good message passing it doesn't have good messages.
09:44:49 <matthew-_> ddarius: explain!
09:45:04 <Apocalis1> matthew-_: Perhaps asynchronous processors will be more Haskell-friendly.
09:45:07 <quicksilver> MVars and Chans are nice message passing IMO
09:45:11 <olsner> ... that sinking feeling you get when you find the stack switching assembly code in a kernel-space wannabe user-space program that also can be compiled to a bootable kernel for Alpha systems
09:45:12 <quicksilver> some people don't like that they're typed
09:45:18 <Apocalis1> asynchronous circuits even
09:45:18 <quicksilver> pesonally I like typed messages
09:45:20 <dons> ddarius: yeah, good idea.
09:45:22 <matthew-_> MVars are better than Chans as a Chan is homogeneous
09:45:37 <ddarius> matthew-_: ?
09:45:42 <glguy> they are "better"?
09:46:02 <ddarius> Apparently TChans are the way to go nowadays.
09:46:05 <matthew-_> Chans are homogeneous shared lists (sorta)
09:46:06 <dons> Chans are just 2 MVar [a]'s
09:46:09 <matthew-_> quite
09:46:21 <dons> data Chan a
09:46:21 <dons>  = Chan (MVar (Stream a))
09:46:21 <dons>         (MVar (Stream a))
09:46:25 <matthew-_> indeed
09:46:32 <matthew-_> so you really want message passing of heterogeneous types
09:46:33 <quicksilver> TChans are cool if a TChan is what you want, yes :)
09:46:37 <matthew-_> which you can do with MVars
09:46:51 <matthew-_> but you get fairly large type sigs!
09:46:55 <ddarius> matthew-_: ?  By having multiple MVars.  You can readily have multiple Chans.
09:47:01 <Apocalis1> dons: You can't use (') that way. It's poorly typed.
09:47:05 <matthew-_> yeah, but then it's not properly ordered
09:47:29 <quicksilver> you can have a Chan of Dynamics
09:47:32 <quicksilver> if htat's what you really want
09:47:33 <ddarius> matthew-_: How is it properly ordered with MVars?
09:47:40 <quicksilver> but that sounds nasty to me
09:48:01 <matthew-_> well it's a fifo chain
09:48:03 <ddarius> quicksilver: That's what I did with my pi calculus embedding if I remember correctly.
09:48:08 <matthew-_> and there's one chain
09:48:22 <matthew-_> if you just have a set of chans, how do you know which one you're meant to be reading next?
09:49:08 <matthew-_> data Cell :: * -> * where Cell :: t -> MVar (Cell ct) -> Cell (SessT t ct)
09:49:34 <matthew-_> this is how all my session type stuff works. You have a chain of MVars, but you allow the types to vary
09:49:39 <matthew-_> without using Dynamic
09:49:53 <ddarius> matthew-_: I didn't think you were going for that at first.
09:50:29 <matthew-_> ddarius: ?
09:51:35 <dons> ndm, do you have a link to where gadgets lives now?
09:52:04 <ndm> dons: does it live anymore? i think i managed to break the www.cs.york.ac.uk/fp stuff, which maybe where it last lived
09:52:40 <dons> it lives in House, as the window system
09:52:52 <dons> which i thought would be nice to look at , after the 'why isn't X in Lisp' post
09:53:07 <ndm> ok, no, i've no idea where it might be - i am pretty sure its no longer anything to do with York
09:54:21 <ddarius> matthew-_: Now you may understand roughly why I seemed so confused.
09:55:23 <matthew-_> ddarius: um, not sure. Anyway, so long as neither of us are confused now!
09:56:11 <dons> ?users
09:56:11 <lambdabot> Maximum users seen in #haskell: 394, currently: 385 (97.7%), active: 16 (4.2%)
10:17:29 <llewyenoh> given an int (say, 10000) representing seconds, what's the best way to convert that to a string in the format HH:MM:SS?
10:19:01 <Saizan> seconds in a day?
10:19:19 <ibid> what's 0 in HH:MM:SS?
10:19:19 <mauke> let x = 10000; (x', s) = x `quotRem` 60; (h, m) = x' `quotRem` 60 in printf "%02d:%02d:%02d" h m s :: String
10:19:19 <mauke> > let x = 10000; (x', s) = x `quotRem` 60; (h, m) = x' `quotRem` 60 in printf "%02d:%02d:%02d" h m s :: String
10:19:22 <lambdabot>  "02:46:40"
10:20:30 <Lemmih> > reverse $ unfoldr (\n -> case n `divMod` 60 of (0,0) -> Nothing; (a,b) -> Just (b,a)) 10000
10:20:32 <lambdabot>  [2,46,40]
10:21:48 <idnar> :t quoteRem
10:21:50 <lambdabot> Not in scope: `quoteRem'
10:21:54 <oerjan> > mapAccumR (flip divMod) 10000 [60,60]
10:21:56 <lambdabot>  Exception: divide by zero
10:22:17 <oerjan> > mapAccumR divMod 10000 [60,60]
10:22:19 <lambdabot>  (2,[46,40])
10:22:45 <Cale> cute
10:23:37 <Saizan> > mapAccumL divMod 10000 [60,60]
10:23:38 <lambdabot>  (2,[40,46])
10:23:52 <olsner> @where ctk
10:23:53 <lambdabot> http://www.cse.unsw.edu.auc/~chak/haskell/ctk/index.html
10:25:03 <oerjan> > concat . intersperse ":" . map (printf "%02d") . uncurry (:) . flip (mapAccumR divMod [60,60]) $ 10000
10:25:04 <lambdabot>  Couldn't match expected type `a -> c'
10:25:32 <llewyenoh> what do i need to import for printf, since i never seem to be able to get that?
10:25:41 <oerjan> @index printf
10:25:42 <lambdabot> Text.Printf
10:25:49 <llewyenoh> there we go, thanks
10:25:57 <Cale> printf seems like overkill there
10:26:03 <llewyenoh> yeah, i think so too
10:26:06 <oerjan> > concat . intersperse ":" . map (printf "%02d") . uncurry (:) . flip (mapAccumR divMod) [60,60] $ 10000
10:26:08 <lambdabot>  "02:46:40"
10:26:10 <llewyenoh> which of those looks like the best one?
10:26:20 <oerjan> it's just to get that 0 padding
10:27:00 <twanvl> > let x = -10000; (x', s) = x `divMod` 60; (h, m) = x' `divMod` 60 in printf "%02d:%02d:%02d" h m s :: String
10:27:02 <lambdabot>  "-3:13:20"
10:27:33 <twanvl> vs.
10:27:38 <twanvl> > let x = 10000; (x', s) = x `quotRem` 60; (h, m) = x' `quotRem` 60 in printf "%02d:%02d:%02d" h m s :: String
10:27:39 <lambdabot>  "02:46:40"
10:27:43 <twanvl> > let x = -10000; (x', s) = x `quotRem` 60; (h, m) = x' `quotRem` 60 in printf "%02d:%02d:%02d" h m s :: String
10:27:44 <lambdabot>  "-2:-46:-40"
10:34:01 <alexeevg> how do I install profiling libraries for some custom cabal package?
10:34:21 <Saizan> configure with -p, iirc
10:34:32 <alexeevg> Saizan: thanks
10:44:31 <oerjan> @bot
10:44:32 <lambdabot> :)
10:45:21 <pjd> @botsmack
10:45:21 <lambdabot> :)
10:45:45 <oerjan> i had resisted that temptation
10:46:10 <psnively> Resisting temptation is overrated.
10:46:42 <psnively> Hmmm. I keep parsing "roconnor" as "Rock-onner!"
10:46:57 <roconnor> :)
10:47:23 <psnively> But, given Rory O'Connor's elegant Coq proofs, perhaps that's not a bad parse after all. :-D
10:48:34 <roconnor> Rory?
10:48:49 <psnively> Sorry, misremembering your name now. LOL
10:48:52 <psnively> After all that...
10:49:03 <roconnor> :D
10:49:17 <psnively> Russell, then. :-)
10:49:45 <roconnor> that will do
10:49:47 <roconnor> :)
10:49:51 <psnively> Too darned many smart O'Connors. Make fewer.
10:50:22 <roconnor> elegant?
10:50:44 <roconnor> let me tell you, there is nothing remotely elegant about my coq proofs.
10:51:22 <psnively> OK, how about "concise?"
10:51:30 <roconnor> nope
10:51:43 <roconnor> I'll give you ``correct''
10:52:06 <psnively> I dunno... I saw what you did with Per Vognsen's automation of the first proof in TAPL.
10:52:37 <roconnor> that doesn't sound like something I would have done.
10:53:24 <roconnor> oh
10:53:25 <roconnor> hmm
10:54:21 <psnively> Heh. OK, so was it Rory or your evil twin? ;-)
10:54:32 <roconnor> psnively: psykotic?
10:54:40 <psnively> Exactly.
10:54:44 <dons> things you don't see every day: "I am using it in my AI robot research project where I am using Lego
10:54:47 <dons> Mindstorms NXT unit and communicating with it over Bluetooth. And the
10:54:49 <dons> AI is made in Haskell."
10:54:58 <psnively> Darn straight, dons.
10:55:31 <psnively> I'm not yet a Haskell programmer, but Oleg's paper on delimited continuations and operating systems is pushing me over the edge.
10:57:58 <psnively> Which reminds me: for Mac OS X, what sort of "IDE" (I use the term extremely loosely) do people do Haskell development with?
10:58:07 <roconnor> @what deliminted_continuation
10:58:08 <lambdabot> I know nothing about deliminted_continuation.
10:58:09 <bos> vi?
10:58:09 <psnively> "Haskell mode for EMACS" is a perfectly acceptable answer.
10:58:15 <olsner> psnively: I use textwrangler and xterm
10:58:23 <psnively> Interesting.
10:58:59 <olsner> although that requires me to indent manually, I don't have to use emacs
10:59:12 <psnively> "Have to use EMACS" is not a barrier for me. :-)
10:59:23 <olsner> port install emacs then :P
10:59:36 * bos uses aquamacs on OS X, but you have to install haskell-mode by hand
11:00:11 <psnively> Installing EMACS modes by hand also doesn't scare me. Try harder. ;-)
11:00:25 <Philippa> psnively: I imagine everyone just uses their favourite text editor - it's what happens on other OSes
11:00:30 <bos> installing ghc on OS X is a bit of a pain, though.
11:00:40 <MyCatVerbs> psnively: jEdit + some or other plugin whose name escapes me works well enough and is more or less cross platform.
11:00:45 <psnively> bos: Really? I just downloaded the .dmg. :-)
11:00:56 <bos> if you're using darwinports or whatever it's called this week, that's easy enough
11:00:59 <bos> psnively: which dmg?
11:01:09 <MyCatVerbs> psnively: personally, I just use VIM and no IDE whatsoever, though. Yi might be popular? :)
11:01:10 <psnively> Philippa: hi! Yes, so I gather.
11:01:40 <psnively> bos: I think I'm exaggerating, i.e. I installed an old GHC from dmg, then build 6.6.1 from source with it.
11:01:42 <psnively> IIRC.
11:01:48 <bos> ah
11:01:59 <bos> there's also an xcode plugin for haskell
11:02:14 <bos> @where xcode
11:02:14 <lambdabot> I know nothing about xcode.
11:02:18 <psnively> XCode... blech.
11:02:20 <psnively> Thanks, though.
11:02:23 <bos> @where+ xcode http://www.hoovy.org/HaskellXcodePlugin/
11:02:24 <lambdabot> Done.
11:02:54 <psnively> Ah. There are non-DMG distros of 6.6.1 for both PowerPC and Intel.
11:03:01 <psnively> That's semi-nice, anyway.
11:03:35 <bos> yeah, but they're a pain to install. you need to install several frameworks and run a bunch of scripts by hand. ugh.
11:03:45 * MyCatVerbs wonders why it's called XCode, anyway?
11:04:09 <psnively> Yeah, hence "semi-nice." ;-)
11:04:25 <MyCatVerbs> It's not like it uses X11 or anything - the most common reason among unix weenies for jamming an 'x' onto the front of one's program's name.
11:04:40 <bos> because it lets you write code for OS X?
11:04:41 <psnively> I think it means "Mac OS X code."
11:04:48 <bct> can somebody tell me what i'm doing wrong here? http://hpaste.org/2568
11:04:56 <bct> i think it's pretty simple, i just don't quite grok the type system
11:05:17 <mauke> openFile is a function in IO
11:05:20 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint-0.1 !
11:05:21 <mauke> you're trying to use it in CGI
11:05:23 <lambdabot> http://tinyurl.com/2wblpj
11:05:29 <dons> "an Interpreter monad, inside which modules can be loaded, and strings with
11:05:29 <dons> Haskell expressions can be evaluated, coerced into values, or type-checked. The library is
11:05:32 <dons> thread-safe and all operations (even the coertion of expressions to values) are type-safe. It is,
11:05:35 <dons> esentially, a huge subset of the GHC API wrapped in a simpler API."
11:06:18 <mauke> bct: to answer your other question, hGetContents closes the handle for you, sort of
11:06:40 <bct> mauke, so is using the result of an IO action in CGI just plain impossible?
11:06:42 <bct> ah, ok
11:06:43 <Lemmih> bct: Lift the IO.
11:06:53 <mauke> I don't know Network.CGI but it probably has a function to lift IO actions into CGI
11:07:10 <bos> just normal lift will do it.
11:07:15 <bos> bct is using CGIT IO
11:07:38 <mauke> bct: handle <- lift (openFile "/etc/fstab" ReadMode)
11:08:45 <oerjan> um, usually lifting IO is done with liftIO
11:08:46 <Lemmih> bct: readFile is openFile+hGetContents, btw.
11:09:21 <mauke> contents <- liftIO $ readFile "/etc/fstab"
11:09:35 <bct> hmm
11:09:55 <bct> can you point me to some documentation about lifting?
11:10:19 <mauke> :t lift
11:10:21 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
11:10:26 <mauke> it's horrible magic
11:10:31 <oerjan> @index liftIO
11:10:32 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:10:47 <oerjan> not really.
11:11:08 <mauke> in this case, it turns IO a into CGIT IO a
11:11:16 <oerjan> lift goes one nesting level of monad transformers down
11:11:16 <mauke> and CGI = CGIT IO, apparently
11:11:27 <oerjan> liftIO goes all the way down to IO
11:11:42 <bct> how do i get access to these mystical functions? ghci just gives me "out of scope"
11:12:01 <mauke> import Control.Monad.Trans
11:12:23 <bct> aah, so this is monad transformer stuff?
11:12:31 <bos> bct: it is indeedy
11:12:38 <llewyenoh> @index intersperse
11:12:39 <lambdabot> Data.List
11:12:41 <oerjan> @src MonadTrans
11:12:42 <lambdabot> Source not found. Where did you learn to type?
11:12:46 <bct> well, i guess i have some more stuff to read about.
11:12:47 <bct> thanks :)
11:13:06 <oerjan> class MonadTrans a where lift :: Monad b => b c -> a b c
11:13:17 <llewyenoh> @index mapAccumR
11:13:17 <lambdabot> Data.List
11:14:03 <oerjan> class Monad a => MonadIO a where liftIO :: IO b -> a b
11:23:05 <hpaste>  ptolomy pasted "newsqueak primes channel example in haskell" at http://hpaste.org/2569
11:27:27 <hpaste>  llewyenoh annotated "Change battery information" with "Parsing error in charging state" at http://hpaste.org/2552#a1
11:28:25 <llewyenoh> the problem is in the comment at the top of http://hpaste.org/2552#a1. anyone see why that isn't working?
11:32:06 <Lemmih> llewyenoh: What's in 'charge' then?
11:33:04 <llewyenoh> Lemmih: i think it can't parse it at all
11:33:57 <llewyenoh> Lemmih: it returns the "Recalculating..." string because i'm guessing it fails parsing
11:36:33 <Lemmih> llewyenoh: splitColon "charging state:          charged"    ==>    ("charging state","          charged")
11:37:41 <Lemmih> llewyenoh: And calling 'reads' on "     charged" doesn't make much sense.
11:38:18 <Lemmih> llewyenoh: use: charge <- lookup "charging state" state
11:38:51 <llewyenoh> Lemmih: ah, i see what you mean
11:39:09 <llewyenoh> Lemmih: thanks
12:01:57 <igel> @users
12:01:57 <lambdabot> Maximum users seen in #haskell: 397, currently: 397 (100.0%), active: 3 (0.8%)
12:02:07 <igel> one more :)
12:04:06 <igel> @users
12:04:07 <lambdabot> Maximum users seen in #haskell: 398, currently: 398 (100.0%), active: 3 (0.8%)
12:04:17 <igel> \o/
12:04:31 <Naktibalda> 400, 400!
12:05:04 <pippijn> not much are active
12:05:06 <pippijn> many*
12:06:21 <igel> nnnooooooo
12:06:46 <igel> @users
12:06:47 <lambdabot> Maximum users seen in #haskell: 398, currently: 385 (96.7%), active: 6 (1.6%)
12:06:51 <oerjan> O_o
12:06:52 <jh> hihi
12:07:15 <oerjan> it didn't register jh in time
12:07:31 <igel> i just mobilized him^^ ;)
12:08:19 <igel> they're returning
12:08:46 <oerjan> @users
12:08:47 <lambdabot> Maximum users seen in #haskell: 398, currently: 390 (98.0%), active: 7 (1.8%)
12:09:23 <dolio> Maybe we should un-ban palomer.
12:09:29 <dolio> And have him bring some of his bitches in here.
12:09:49 <igel> who's that?
12:10:25 <dolio> @palomer
12:10:25 <lambdabot> That's a lie
12:10:45 <igel> @help palomer
12:10:45 <lambdabot> palomer. Sound a bit like palomer on a good day.
12:11:45 <dolio> He was a guy whose main motivation for hanging out here seemed to be to annoy people.
12:12:13 <olsner> @palomer
12:12:14 <lambdabot> I think vim is good for the rubbish bin
12:12:32 <olsner> is that a set of actual palomer quotes, or some generator thingy?
12:12:37 <sjanssen> heh, "on a good day"
12:12:42 <sjanssen> olsner: set of quotes
12:13:12 <sjanssen> @quote palomer
12:13:12 <lambdabot> No quotes match. You speak an infinite deal of nothing
12:13:19 <olsner> @palomer
12:13:19 <lambdabot> Scalliwags!
12:13:24 <olsner> @yow
12:13:24 <lambdabot> Now I'm being INVOLUNTARILY shuffled closer to the CLAM DIP with the
12:13:24 <lambdabot> BROKEN PLASTIC FORKS in it!!
12:13:43 <igel> @help yow
12:13:43 <lambdabot> yow. The zippy man.
12:14:11 <dolio> @keal
12:14:12 <lambdabot> with KealDigit quantum crackproof encryption possible
12:14:49 <dolio> keal and protontorpedo were actual people, too.
12:15:00 <olsner> @help keal
12:15:00 <lambdabot> keal. Talk like Keal
12:15:05 <olsner> @help protontorpedo
12:15:05 <lambdabot> protontorpedo is silly
12:15:12 <olsner> @protontorpedo
12:15:13 <lambdabot> can haskell do data transfer from box to box over sockets?
12:15:15 <dolio> yow, as I understand it, is shapr indulging his insane side, or something like that.
12:15:16 <mauke> protontorpedo is a troll but keal is actually insane
12:15:28 <olsner> @keal
12:15:28 <lambdabot> are there full body recognition files for sorting art?
12:16:08 <olsner> "actually insane"? as in "nick known to correspond to a clinically insane real person"?
12:16:31 <igel> this seems to have a long history :D
12:16:49 <mauke> well, maybe not 100% known
12:17:20 <mauke> but someone in another channel recognized keal from a message board or something
12:17:40 <mauke> and he said those quotes were relatively normal compared to some of his other stuff
12:17:41 <sjanssen> @keal
12:17:41 <lambdabot> last day i was in my lab i had a diagram which might have removed pi
12:17:47 <sjanssen> @keal
12:17:47 <lambdabot> my proof show math is broken right now
12:17:49 <sjanssen> @keal
12:17:50 <lambdabot> i changed my user od
12:17:52 <sjanssen> @keal
12:17:53 <lambdabot> proofs are no longer sound
12:17:55 <sjanssen> @keal
12:17:55 <lambdabot> tomorrow i share next mathematical secrety
12:18:04 <roconnor> @kool
12:18:05 <lambdabot> tomorrow i share next mathematical secrety
12:18:39 <dolio> keal sounds like he'd hang out in sci.math.
12:18:53 <Olathe> Heheh
12:20:03 <oerjan> @users
12:20:04 <lambdabot> Maximum users seen in #haskell: 398, currently: 396 (99.5%), active: 12 (3.0%)
12:20:07 <olsner> the voynich mailing list has a few insane people too - mostly good-hearted but sometimes really crazy.. and then a day or so later comes a mail with an apology - apparently someone had just forgot to take his drugs that day
12:21:16 <roconnor> http://bestdocumentaries.blogspot.com/2007/09/dangerous-knowledge-full-documentary.html
12:21:18 <dons> @users
12:21:18 <lambdabot> Maximum users seen in #haskell: 398, currently: 397 (99.7%), active: 12 (3.0%)
12:21:18 <lambdabot> Title: Best Free Documentaries: Dangerous Knowledge - Full Documentary, http://tinyurl.com/326eba
12:21:45 <wli> roconnor: What's the one-line summary?
12:21:56 <olsner> math genius => insanity
12:21:58 <roconnor> In this one-off documentary, David Malone looks at four brilliant mathematicians - Georg Cantor, Ludwig Boltzmann, Kurt GÃ¶del and Alan ... all Â» Turing - whose genius has profoundly affected us, but which tragically drove them insane and eventually led to them all committing suicide.
12:22:19 <roconnor> I haven't seen it
12:22:24 <roconnor> it just seemed topical
12:23:50 <dolio> In other words, the guy on sci.math whose main idea is that mathematicians can't prove axioms because they're "too lazy" is actually a genius? :)
12:24:02 <roconnor> dolio: *l*
12:24:12 <Olathe> Not really.
12:24:22 <olsner> a `implies` b /= b `implies` a
12:24:31 <dolio> Yes, I suppose that's affirming the consequent.
12:24:53 <olsner> was that you saying I'm insane?
12:24:54 <roconnor> @check \a b -> (a <= b) == (b <= a)
12:24:55 <lambdabot>  Add a type signature
12:25:01 <roconnor> @check \a b -> (a <= b) == (b <= (a::Bool))
12:25:03 <lambdabot>  Falsifiable, after 2 tests: False, True
12:25:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/2570
12:25:44 <dolio> @check \a b -> (a <= b) == (b <= (a :: ()))
12:25:45 <lambdabot>  OK, passed 500 tests.
12:25:49 <dolio> Woo!
12:25:55 <roconnor> dolio: <= means implies
12:26:14 <roconnor> @check \a b -> (a <= b) == (not a or (b::Bool))
12:26:15 <lambdabot>  Couldn't match expected type `([Bool] -> Bool) -> Bool -> Bool'
12:26:17 <dons> @scheck \a b -> (a <= b) == (b <= (a :: ()))
12:26:18 <lambdabot>   Completed 1 test(s) without failure.
12:26:20 <oerjan> and it is true in trivial logic!
12:26:27 <roconnor> @check \a b -> (a <= b) == ((not a) or (b::Bool))
12:26:28 <dons> scheck is smart
12:26:28 <lambdabot>  Couldn't match expected type `t -> t1 -> Bool'
12:26:32 <roconnor> @check \a b -> (a <= b) == ((not a) || (b::Bool))
12:26:34 <lambdabot>  OK, passed 500 tests.
12:26:39 <roconnor> @scheck \a b -> (a <= b) == ((not a) || (b::Bool))
12:26:40 <lambdabot>   Completed 4 test(s) without failure.
12:26:50 <dolio> roconnor: Huh, I hadn't thought about it that way, but that's true.
12:27:00 <dolio> Cute.
12:27:08 <roconnor> it's kinda pointing the wrong way :(
12:27:45 <hpaste>  tphyahoo annotated "(no title)" with "(no title)" at http://hpaste.org/2570#a1
12:29:14 <luqui> yeah, if you switched the sort order of True and False it would be right :-)
12:30:07 <hpaste>  llewyenoh annotated "Change battery information" with "Parse error in pattern on case" at http://hpaste.org/2552#a2
12:30:43 <roconnor> luqui: there is somethting about the swiching of order between propositions and models
12:31:02 <tphyahoo> having some trouble building 6.6l.1, anyone seen this?
12:31:05 <tphyahoo> http://hpaste.org/2570#a1
12:31:28 <tphyahoo> is my process being killed by some resource manager? this is on a user mode linux virtualized server
12:31:39 <llewyenoh> i don't know what i'm doing wrong in http://hpaste.org/2552#a2, probably something with the case line
12:31:51 <luqui> llewyenoh:  are those supposed to be pattern guards?
12:32:11 <llewyenoh> luqui: i think so, i'm not sure if i'm doing things correctly
12:32:40 <roconnor> if A => B then the models of A are a subset of the models of B.
12:32:50 <luqui> llewyenoh: oh, it looks like you're treating <- as assignment
12:32:51 <olsner> tphyahoo: sounds like you're out of memory
12:33:12 <luqui> llewyenoh: you probably want something like:
12:33:16 <tphyahoo> olsner: shouldn't 289M be enough?
12:33:43 <luqui> sign <- "charging state" state of ...
12:33:45 <luqui> er
12:33:51 <luqui> sign <- case "charging state" state of
12:33:53 <luqui> er
12:33:56 <luqui> you know what I mean
12:33:58 <luqui> :-)
12:34:03 <llewyenoh> oh, i see
12:34:21 <llewyenoh> but if it's "charging," i want it to return "100%"
12:34:28 <llewyenoh> so how would i account for that?
12:34:39 <llewyenoh> i don't want to assign that to sign
12:34:44 <llewyenoh> i want to actually return there
12:34:49 <luqui> give me a sec, I'm not actually understanding your code, I was scanning for syntax
12:35:34 <tphyahoo> I guess I'll complain to the admins
12:37:23 <luqui> llewyenoh: ok, something like case lookup "charging state" state of "charged" -> return "100%"; st -> do sign <- case st of ...
12:37:33 <luqui> wouldn't be that clean
12:37:47 <luqui> but basically you can't "return instantly" and then continue to bind afterward
12:37:54 <sorear> Igloo: What's the advantage of -Wwarn over -Wno-error, as a name?
12:37:57 <luqui> (not without ContT at least :-)
12:38:22 <luqui> but I would probably split it out into a supporting function
12:38:28 <llewyenoh> luqui: ah, i was afraid of that
12:38:32 <llewyenoh> luqui: how so?
12:38:50 <luqui> where reportState "charged" = "100%"
12:38:59 <luqui>       reportState st = ...
12:40:07 <llewyenoh> and take out case entirely?
12:40:25 <luqui> perhaps, or perhaps have one in the reportState st = clause
12:40:34 <luqui> but I generally consider cases a good indication to refactor :-)
12:40:41 <llewyenoh> hahahhaha ok
12:41:17 <luqui> i'm not sure how far you've rewired your brain yet
12:41:22 <luqui> so I may be preaching to the choir
12:41:31 <luqui> but you should think of everything in haskell as a "definition"
12:41:39 <luqui> so how is "sign" *defined*
12:41:39 <llewyenoh> i'm still trying to rewire mine
12:42:01 <luqui> not "assign to sign under these conditions"
12:42:23 <llewyenoh> yeah, i still don't get that concept very clearly
12:42:53 <luqui> and, and with complex program logic like this it can be tough to get it right
12:43:06 <luqui> usually requires a big rethink of the problem or acceptance of ugly code :-)
12:43:36 <llewyenoh> ah, i'm trying to get there slowly
12:43:44 <llewyenoh> in the meantime, i have to live with the ugly code
12:44:00 <luqui> sure.  I always tell the story that when I started to learn haskell, I was taking about 6 hours to learn a new language
12:44:04 <luqui> and haskell took me a year
12:44:18 <luqui> ;-)
12:44:23 <llewyenoh> long road ahead, then
12:44:25 <luqui> (and I'm still no guru)
12:44:53 <luqui> it was worth it though
12:44:59 <luqui> haskell absolutely undisputably rocks
12:46:58 <hpaste>  llewyenoh annotated "Change battery information" with "Empty do construct" at http://hpaste.org/2552#a3
12:47:08 <llewyenoh> luqui: what did i forget to add this time?
12:47:22 <luqui> what line is it complaining about?
12:47:32 <llewyenoh> 23
12:47:33 <luqui> case lookup "chargine state" of ?
12:47:42 <llewyenoh> oh, that may be important
12:48:02 <luqui> hmm... looks like an indentation issue perhaps
12:48:48 <llewyenoh>                  case lookup "charging state" state of
12:48:48 <llewyenoh>                    where reportState "charged" = "100%"
12:48:48 <llewyenoh>                          reportState st = do sign <- case st of
12:48:48 <llewyenoh>                            "charging" -> sign <- "[+]"
12:48:48 <luqui> i'm actually not sure
12:48:49 <llewyenoh>                            "discharging" -> sign <- "[-]"
12:49:01 <llewyenoh> says issue on where
12:49:08 <mauke> wtf
12:49:13 <mauke> why is there a 'where' in there?
12:49:18 <luqui> where goes at the end of the definition
12:49:19 <sorear> !paste
12:49:19 <hpaste> Haskell paste bin: http://hpaste.org/
12:49:35 <llewyenoh> yeah, i didn't want to annotate again
12:49:42 <mauke> reportState is also unused
12:50:07 <luqui> battery = stuff where stuff
12:50:30 <luqui> it's a function definition that is in scope only for the right side of that =
12:51:06 <luqui> I wish I had subetha or something...
12:51:11 <luqui> very hard to explain
12:52:09 <llewyenoh> yeah, i'm completely lost
12:52:15 <luqui> yeah, it looks like it
12:52:19 <luqui> ok, here's what I recommend
12:52:26 <luqui> forget where and case and fancy stuff
12:52:38 <luqui> and rewrite (or heavily refactor) your program
12:52:44 <luqui> until it's a bunch of function definitions
12:52:50 <luqui> each one or two lines
12:52:59 <luqui> do it bottom up
12:53:08 <luqui> you need a function to take seconds and return H:M:S
12:53:16 <luqui> so write secToHMS :: Int -> String
12:53:21 <llewyenoh> right, i have that already
12:53:29 <luqui> and use ghci to make sure it works correctly
12:53:49 <llewyenoh> yeah, that HMS one works, it's been checked
12:53:52 <luqui> cool
12:54:14 <volothamp> hi everybody.. just lurking
12:54:17 <Lemmih> llewyenoh: What's the problem?
12:54:28 <sebell> volothamp: Not anymore.
12:54:31 <roconnor> @users
12:54:32 <lambdabot> Maximum users seen in #haskell: 399, currently: 399 (100.0%), active: 14 (3.5%)
12:54:41 <volothamp> heheh right :)
12:55:13 <llewyenoh> Lemmih: http://hpaste.org/2552#a2 - basically the case block
12:55:19 <luqui> llewyenoh: then, uh, I'm having trouble coming up with the next step
12:55:24 <Lemmih> Sigh, lambdabot got the memory of Alberto Gonzales.
12:55:26 <holst> why are so many interested in haskell>
12:55:37 <luqui> llewyenoh: can you describe what battery does in words?
12:55:41 <llewyenoh> Lemmih: i'm thinking of it in an imperative sense, i'm guessing
12:56:11 <llewyenoh> battery returns a string, but that string varies depending on whether the charging state is "charging," "charged," or "discharging."
12:56:12 <byorgey> holst: because it's totally sweet.
12:56:13 <Cale> holst: because it's an awesome language :)
12:56:31 <luqui> llewyenoh: okay, I wouldn't be able to implement battery based on that description
12:56:37 <luqui> so you need to break it down a bit :-)
12:56:48 <Lemmih> llewyenoh: What should sign be when it's charged?
12:56:50 <luqui> and as you do, you'll probably find the functions you need to write first
12:56:51 <holst> yes, but it has no commercial or webbased applications? =D
12:57:15 <Lemmih> llewyenoh: You really wanna keep 'charge <- lookup "charging state" state'.
12:57:20 <llewyenoh> Lemmih: i was trying to just ignore sign, and return "100%" (thereby not running any of the rest)
12:57:25 <Cale> holst: It has commercial and web-based applications
12:57:45 <byorgey> holst: that's actually untrue, but even if it were, that's no reason for people not to be interested in it =)
12:57:46 <luqui> yeah, "return" is kinda confusing
12:57:50 <Cale> holst: Not too many so far, but a few nonetheless, and there are even some companies using it almost exclusively.
12:57:53 <luqui> because it does very little like what "return" does in other languages
12:58:06 <llewyenoh> luqui: oh, that may be why i'm misusing it
12:58:20 <Lemmih> llewyenoh: let sign = case dropWhile isSpace charge of "charged" -> ""; "charging" -> "[+]"; "discharging" -> "[-]"
12:58:55 <Cale> llewyenoh: (return x) is a computation which has no side effects, and returns x. It doesn't have any of the control-flow effects that "return" has in languages like C.
12:59:11 <llewyenoh> Cale: ok, that's why i'm not using it correctly
12:59:17 <RemiTurk> hi to all
12:59:20 <mauke> "return" is a virtual constructor
12:59:29 <byorgey> hi there RemiTurk
12:59:37 <mauke> > return 42 :: [Int]
12:59:38 <llewyenoh> Lemmih: that's what i though, and correct me if i'm wrong, but if it's "charged" i don't want to return all the rest of the stuff, like percent and minutes later on
12:59:39 <lambdabot>  [42]
12:59:41 <mauke> > return 42 :: Maybe Int
12:59:43 <lambdabot>  Just 42
12:59:46 <llewyenoh> Lemmih: just "100%"
13:01:19 <byorgey> @users
13:01:19 <lambdabot> Maximum users seen in #haskell: 400, currently: 400 (100.0%), active: 16 (4.0%)
13:01:30 <roconnor> \o/
13:01:38 <Lemmih> llewyenoh: case chargeStatus charge of Charged -> return "100%"; Active sign -> return (percent ++ ...
13:01:46 <sorear> @users
13:01:46 <lambdabot> Maximum users seen in #haskell: 401, currently: 401 (100.0%), active: 16 (4.0%)
13:01:50 <sorear> woah
13:01:55 <sorear> they  fixed it!
13:02:22 * sorear expected lambdabot> Maximum users seen in #haskell: 400, currently: 401 (102.5%), active: 16 (4.0%)
13:02:32 * sorear has seen that before
13:02:35 <|Jedai|> Lemmih: return $ case chargeStatus charge of Charged -> "100%"; Charging ...
13:02:35 <holst> return 42 :: [Int]. found in the code appendix of the famous paper:
13:02:36 <holst> "A implementation of a generic all purpose multiscale algebraic solver with preconditioned krylov subspace iteration solver with O(1) complexity in Haskell"
13:02:38 <Lemmih> llewyenoh: chargeStatus charge = case dropWhile isSpace charge of "charged" -> Charged; "charging" -> Active "[+]"; "discharging" -> Active "[-]"
13:03:12 <Lemmih> |Jedai|: Well, matter of taste and strictness, I guess.
13:03:20 <holst> everything boils down to 42 in different linear combinations
13:03:53 <llewyenoh> Lemmih: thanks, let me try to digest all that
13:04:03 <|Jedai|> Lemmih: There's no difference in strictness, I just noted that you could put the return in front of the pure case instead of putting it in each alternative
13:05:53 <Lemmih> jedai: Indeed, and that changes the strictness, I believe.
13:06:20 <luqui> Lemmih: this is interesting.  explain.
13:06:22 <Lemmih> (do x <- Just undefined; case x of () -> return ()) `seq` ()    vs.   (do x <- Just undefined; return $ case x of () -> ()) `seq` ()
13:06:23 <jedai> Lemmih: Where ? There is absolutely no differrence
13:06:29 <luqui> strictness is something I am completely lost on
13:06:56 <Lemmih> jedai: Same difference between 'x `seq` return x' and 'evaluate x'.
13:07:12 <jedai> Lemmih: Not in this example anyway
13:08:05 <luqui> Lemmih: did you mean case x of _ ?
13:08:07 <llewyenoh> Lemmih: do i need something for Active?
13:08:07 <luqui> or
13:08:16 <luqui> llewyenoh: yeah, it's a "data" declaration
13:08:23 <Lemmih> jedai: Because it doesn't change the strictness or because there aren't any bottoms?
13:08:43 <llewyenoh> luqui: can you clarify that/
13:08:45 <llewyenoh> *?
13:08:46 <Lemmih> llewyenoh: data ChargeStatus = Charged | Active String
13:08:58 <llewyenoh> ah, ok, thanks
13:09:02 <luqui> llewyenoh: I was hoping someone who knew where to look would point you to some appropriate docs
13:10:06 <luqui> llewyenoh: this might be good: http://en.wikibooks.org/wiki/Haskell/Type_declarations
13:11:37 <llewyenoh> luqui: ah, ok
13:11:46 <llewyenoh> @index isSpace
13:11:47 <lambdabot> Data.Char
13:14:29 <hpaste>  llewyenoh annotated "Change battery information" with "Any suggestions / improvement?" at http://hpaste.org/2552#a4
13:14:53 <llewyenoh> luqui, Lemmih: thanks for all the help, mind checking it over to see if i did everything correctly?
13:15:41 <luqui> reading
13:15:48 <Lemmih> llewyenoh: Hoisting out the 'return' as jedai suggested is probably a good idea.
13:17:10 <llewyenoh> Lemmih: in lines 38 and 39?
13:17:44 <Lemmih> llewyenoh: Yes.
13:17:49 <luqui> llewyenoh: looks pretty good to me.  I would have defined fcap, rcap, and rate in slightly different places
13:17:53 <luqui> but shouldn't matter too much
13:18:01 <llewyenoh> luqui: thanks
13:18:15 <llewyenoh> Lemmih: doesn't compile if i simply take out the return's
13:18:26 <llewyenoh> Lemmih: oh wait
13:18:27 <luqui> llewyenoh: take out the returns, and add one before case:
13:18:34 <luqui> return $ case chargeStatus charge of ...
13:18:36 <jedai> Lemmih: Well you were right about the strictness, putting the case outside force the evaluation of it if you ask for the value of the function, (you often see $! after a return to avoid that). In his case it shouldn't make a difference except stylistic (I prefer to avoid repeating things needlessly)
13:18:44 <llewyenoh> luqui: right, i completely missed jedai's line up above
13:20:10 <ptolomy> Is there a haskell ORM (well, FRM?) library? I'm curious about the best way to deal with the standard "business objects in a database, server needs to access them, cache them, and now and then update them" problem.
13:20:13 <llewyenoh> wow, thanks for all the advice.
13:20:40 <luqui> llewyenoh: if you're interested in a good exercise, you might want to try pulling most of battery out of the IO monad
13:21:14 <luqui> so battery :: IO String becomes batteryDescription :: [(String,String)] -> [(String,String)] -> String
13:21:16 <dons> ptolomy: a custom monad I'd expect?
13:21:28 <dons> there's some db bindings along this line, on the haskell.org wiki
13:21:33 <luqui> where the arguments are state and info
13:21:40 * ptolomy rechecks the wiki.
13:21:58 <llewyenoh> luqui: yeah, i'll try that out
13:22:34 <llewyenoh> out of curiosity, isn't it somewhat efficient for me to use all those grabs when i don't need it if it's charged?
13:22:39 <llewyenoh> *inefficient
13:23:13 <luqui> llewyenoh: uh, a little bit... not going to be a huge issue unless info and state are really big lists though
13:23:25 <luqui> but that's what I was talking about when I said I would define fcap and rcap elsewhere
13:23:43 <llewyenoh> luqui: right, so how would you define it?
13:23:49 <luqui> essentially I'd put the case back up where you had it in the original...
13:23:54 <luqui> umm, I'll annotate
13:25:10 <ptolomy> dons: Are you aware of any projects that use haskelll for distributed systems stuff? (I couldn't find any)
13:25:51 <hpaste>  luqui annotated "Change battery information" with "(no title)" at http://hpaste.org/2552#a5
13:26:24 <luqui> llewyenoh: however, if you pulled battery out of IO, then it wouldn't matter, because Haskell wouldn't evaluate what it didn't need anyway :-)
13:26:36 <Lemmih> dons: HAppS uses Haskell for distributed stuff.
13:26:45 <dons> ptolomy: yeah, there's some. Chilli has used haskell for distributed cluster work.
13:26:48 <Lemmih> Tsk, I meant ptolomy.
13:26:50 <dons> using the `ports' lib in hackage
13:26:56 <luqui> (actually, it still might not, depending on how deeply the laziness goes, that's a big ot haskell that I don't understand that well yet)
13:27:01 <dons> lots of little haskell nodes running over mpi or tcp
13:27:08 * ptolomy checks it out.
13:27:10 <dons> ptolomy: there's the hmpi binding too
13:27:22 <dons> you should be able to find quite a few experts in this area on the lists
13:28:03 <ptolomy> dons: Thanks!
13:28:05 <luqui> llewyenoh: whoops
13:28:16 <luqui> llewyenoh: the final return in my battery is indented one level too many
13:28:25 <llewyenoh> luqui: yeah, i caught that
13:28:26 <augustss_> hello dons!
13:28:56 <jedai> luqui: If you means the grabs, in your version they won't be executed if you're not in the Active state
13:29:15 <luqui> jedai: right, I know that bit
13:29:20 <llewyenoh> luqui: thanks for all your help, that's really helpful
13:29:23 <luqui> I was wondering if in his version they wouldn't be executed anyway
13:29:28 <luqui> or rather the "lookup"s
13:29:35 <luqui> if he's not in Active
13:29:36 <dons> hey augustss
13:29:41 * dons waves from the west coast :)
13:29:56 <augustss> the US west coast?
13:30:11 <dons> yeah. i'm in portland now
13:30:16 <dons> start work tomorrow
13:30:23 <augustss> wow
13:30:37 <augustss> so your thesis is done?
13:30:41 * byorgey waves to dons from the east coast
13:30:49 <dons> mostly. still some writing to go. i'm enrolled till january
13:30:52 * sebell waves to dons from the north coast
13:30:56 <dons> :)
13:30:56 <jedai> luqui: They would (except if the lookup state fail early on), because he needs to know if they're Nothing to short circuit to nothing, it's how the Maybe Monad is implemented (I believe at least)
13:31:15 * wli waves to dons from Tanasbourne.
13:31:35 <cizra> How could I convince Haskell to do _integer_ division by 2? Or a right shift?
13:31:37 <dons> wli, that's over on the west side?
13:31:43 * augustss waves from London
13:31:46 <jedai> cizra: div
13:31:47 <dons> > 5 `div` 2
13:31:47 <luqui> cizra: `div`
13:31:52 <jedai> cizra: or quot
13:31:52 <lambdabot>  2
13:31:57 <Igloo> Or `shiftL` 1
13:32:04 <Igloo> Err, shiftR even
13:32:05 <augustss> cizra: quot
13:32:06 <dons> augustss: oh, i forgot, you're not in NYC anymore
13:32:09 <luqui> timtowtdi :-)
13:32:15 <wli> dons: Out by Hillsboro, Rock Creek, Aloha, and Beaverton.
13:32:21 <cizra> thanks!
13:32:25 <augustss> cizra: > 4 `quot` 2
13:32:35 <wli> dons: I'm maybe 2-3 blocks from the OGI campus.
13:32:46 <augustss> If you want to be sure it turns into a shift you need quot
13:32:59 <dons> wli, ah i see. i'm right in the centre of town
13:33:04 <dons> hey dpiponi
13:33:05 <augustss> or is it div?  I can never remember :)
13:33:14 <luqui> > (-4) `div` 3
13:33:16 <lambdabot>  -2
13:33:20 <luqui> > (-4) `quot` 3
13:33:21 <lambdabot>  -1
13:33:22 <dpiponi> hey dons!
13:33:23 <jedai> augustss: I think quot is the primitive one
13:33:28 <dons> ?check \x y -> x `div` y == x `quot` (y :: Int)
13:33:30 <lambdabot>  Exception: divide by zero
13:33:30 <byorgey> dons: it's spelled "center" now =)
13:33:31 <luqui> er wait, I tested the wrong thing
13:33:39 <dons> ?check \x y -> y /= 0 ==> x `div` y == x `quot` (y :: Int)
13:33:39 <augustss> quot is the typical machine instruction
13:33:40 <lambdabot>  Falsifiable, after 11 tests: -1, 3
13:33:45 <luqui> > (-3) `div` 2
13:33:47 <lambdabot>  -2
13:33:48 <dons> ?scheck \x y -> y /= 0 ==> x `div` y == x `quot` (y :: Int)
13:33:49 <lambdabot>   Failed test no. 10. Test values follow.: -1, 2
13:33:51 <dpiponi> When did "expr -> x" become legal? (As in http://calculist.blogspot.com/2007/07/cute-idiom-from-haskell.html)
13:33:54 <luqui> > (-3) `quot` 2
13:33:56 <lambdabot>  -1
13:33:58 <lambdabot> Title: The Little Calculist: Cute idiom from Haskell, http://tinyurl.com/24h9gu
13:33:58 <dons> dpiponi: its illegal again
13:34:01 <jedai> augustss: but div is implemented by quot so you would get a shift in both case (it's optimised on low-level by GHC)
13:34:06 <dons> dpiponi: it was a strange bug in the parser
13:34:17 <dpiponi> dons: You're replying too fast. You must be a bot.
13:34:18 <dons> byorgey: heh
13:34:28 <augustss> jedai: but there will be tests and jumps to implement div
13:34:29 <luqui> augustss: 1111100 >> 1 == 1111110   (-1)
13:34:31 <dons> dpiponi: i just know, because I wrote the bug report and watched it get closed :)
13:34:39 <luqui> augustss, looks like it's quot
13:34:53 <dpiponi> Pity, I quite liked that notation.
13:35:13 <jedai> augustss: Yep, that's why you better use quot if you don't need the semantic of div (for example working only on positive int)
13:35:16 <dons> yeah, it's an interesting idea.
13:35:23 <mauke> huhu
13:35:23 <dons> E |- e -> v is cute
13:35:43 <mauke> perl developers would just call it an "accidental feature" and keep it :-)
13:35:43 <augustss> yeah, that was cute
13:35:59 <dpiponi> And of course it's closer to the desugaring
13:36:11 <dons> mauke: heh
13:36:24 <augustss> btw, hello, dpiponi :)
13:36:39 <dpiponi> hello augustss. Did you make sense of my blog?
13:37:09 <shapr> I got a google recruiting email. They found me! Aah!
13:37:17 <dons> hehe shapr
13:37:19 <augustss> dpiponi: I've not had time to read it properly yet.  it's not something you can speed read
13:37:20 <ivant> :-)
13:37:21 <jfredett> shapr: hide! quick!
13:37:29 <ivant> no, convert google to haskell!
13:37:31 <ivant> :-)
13:37:40 * luqui is a perl developer, and sees no reason not to keep it.  good prediction :-)
13:37:57 <Cale> -> came into being along with the arrow notation, I think.
13:38:09 <dpiponi> Does 'notfancy' on reddit hang out here?
13:38:16 <luqui> can you also do >- ?
13:38:43 <olsner> "Q: Can haskell be used to write real-world software? A: Yes - Haskell is currently operating the most popular search engine in the world."
13:38:47 <cizra> http://pastie.caboo.se/93930
13:38:49 <dons> dpiponi: hmm, I don't think so. maybe on LtU though.
13:38:49 <lambdabot> Title: #93930 - Pastie
13:38:52 <cizra> Why does it give a syntax error?
13:39:04 <cizra> fibo_2n_1.hs:8:0: parse error (possibly incorrect indentation)
13:39:58 <luqui> cizra: otherwise =
13:40:01 <augustss> missing = after otherwise
13:40:12 <cizra> Thanks!
13:40:28 <mauke> cizra: line 5 better written as | odd n = ...
13:40:56 <mauke> (10) is the same as 10
13:41:02 <Cale> Yeah, not-equals is written /= in Haskell, not !=
13:41:43 <luqui> mauke: some people still prefer the foo(x) syntax, especially while they're getting used to it
13:41:45 <Cale> Also, you usually want div and not quot for integer division.
13:41:52 <mauke> luqui: there is no foo(x) syntax
13:41:53 <cizra> By the way, it gives incorrect answers.
13:42:00 <dons> shapr: have you seen this monthly growth chart for the channel? http://ircbrowse.com/cdates.html?channel=haskell
13:42:00 <mauke> you can prefer it, but it doesn't work
13:42:02 <luqui> mauke: well, the harmless extra parentheses
13:42:05 <lambdabot> Title: Meme Channel haskell by Dates
13:42:10 <mauke> (see also: sizeof in C)
13:42:15 <dons> they need more shades of 'hot red' though
13:42:25 <luqui> mauke: as long as there's only one argument, there's no problem with it
13:42:43 <dons> ?users
13:42:43 <lambdabot> Maximum users seen in #haskell: 402, currently: 398 (99.0%), active: 24 (6.0%)
13:42:47 <augustss> Cale: but if you're after speed for `quot` 2 is your friend
13:42:54 <mauke> luqui: let me find a counterexample
13:42:59 <dpiponi> Who's going to the 1st bayfp meeting? http://bayfp.org/
13:43:00 <lambdabot> Title: Bay Area Functional Programmers
13:43:02 <shapr> dons: Yeah, too bad it's all just red.
13:43:50 <luqui> mauke:
13:43:53 <luqui> mauke: I've got one
13:43:53 <wli> No spline curves etc.?
13:44:02 <wli> Or user activity rankings?
13:44:16 <luqui> mauke: map add(1) [1,2,3]
13:44:16 <wli> I think efnet-math.org has some things along those lines.
13:44:25 <luqui> mauke: for add = (+)
13:44:30 <Cale> cizra: maybe you need the second base case for fib
13:44:46 <luqui> so I stand corrected :-)
13:44:47 <mauke> oh, you could write that as map(add(1))([1,2,3]) :-)
13:44:54 <luqui> true
13:45:01 <mauke> who needs spaces anyway
13:45:28 <luqui> so as long as you're consistent, there's probably no issue
13:45:37 <luqui> no mixing though!
13:46:31 <Cale> (map(add(1)))([1,2,3])
13:46:37 <Cale> more parens!
13:47:53 <byorgey> (map(add(1)))([(1),(2),(3)]) -- be careful with those other numeric constants!
13:47:59 <hpaste>  mauke pasted "fun with parens" at http://hpaste.org/2572
13:48:10 <Cale> let add x y = x + y in (((map)((add)(1)))([(1),(2),(3)]))
13:48:12 <dons> @seen glguy
13:48:12 <lambdabot> glguy is in #haskell. I last heard glguy speak 4h 2m 35s ago.
13:48:12 <Cale> > let add x y = x + y in (((map)((add)(1)))([(1),(2),(3)]))
13:48:14 <lambdabot>  [2,3,4]
13:48:15 <mauke> luqui: ^
13:48:30 <dons> heh
13:48:40 <dons> ?wiki Obfuscation
13:48:40 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
13:48:44 <dons> has a similar idea
13:49:30 <luqui> mauke: nice one
13:49:44 <mauke> record update to the rescue
13:50:03 <cizra> Cale: no
13:50:41 <xerox> > let (add) = ((+)) in (((map)((add)(1)))((:)(1)((:)(2)((:)(3)([])))))
13:50:42 <lambdabot>  [2,3,4]
13:50:55 <Cale> cizra: adding fib 1 = 1 caused the program to give valid results for me
13:55:24 <dons> ?users
13:55:24 <lambdabot> Maximum users seen in #haskell: 402, currently: 396 (98.5%), active: 25 (6.3%)
13:58:44 <cizra> Cale: fib 0 = 0, by definition
13:58:55 <cizra> By the way, I figured it out. Or at least I'm in the process of it.
13:58:56 <Cale> cizra: yeah
13:59:08 <luqui> cizra: actually fib 0 = 1
13:59:18 <Cale> cizra: I added a second line, giving the case fib 1 = 1 as well.
13:59:46 <luqui> map fib [0,1,2,3,4] = [1,1,2,3,5]
13:59:59 <luqui> at least in the definition I'm familiar with
14:00:26 <volothamp> I've got a question about the fibonacci numbers!
14:00:27 <shapr> Man, I have to get that hard drive holding the IOHCC data...
14:00:30 <byorgey> luqui: map fib [0..4] = [0,1,1,2,3,5] is pretty common
14:00:39 <byorgey> erm, [0,1,1,2,3]
14:01:01 <byorgey> luqui: for example, Graham, Knuth & Patashnik use that in "Concrete Mathematics"
14:01:15 <cizra> http://en.wikipedia.org/wiki/Fibonacci_sequence
14:01:16 <lambdabot> Title: Fibonacci number - Wikipedia, the free encyclopedia
14:01:16 <luqui> @check length (map f xs) == length xs
14:01:17 <lambdabot>   Not in scope: `xs'
14:01:18 <cizra> this lists fib 0 as 0
14:01:24 <luqui> hmm, how does one use @check
14:02:28 <luqui> cizra: that works too
14:02:33 <dons> it takes an expression in the Property class, iirc
14:02:39 <dons> :t Test.QuickCheck.quickCheck
14:02:41 <lambdabot> forall a. (Test.QuickCheck.Testable a) => a -> IO ()
14:02:45 <dons> Testable, sorry
14:02:56 <dons> which means Bool, and some other things.
14:03:14 <byorgey> @check \f xs -> length (map f xs) == length xs
14:03:15 <lambdabot>  Add a type signature
14:03:26 <byorgey> @check \f xs -> length (map f (xs::[Int])) == length xs
14:03:27 <lambdabot>  Add a type signature
14:03:28 <lucca> hm, need a new class Detestable
14:03:35 <byorgey> @check \f xs -> length (map (f::Int->Int) (xs::[Int])) == length xs
14:03:36 <lambdabot>  OK, passed 500 tests.
14:03:47 <luqui> kcool
14:04:25 <luqui> @check \(f::a->a) xs -> length (map f xs) = length xs
14:04:25 <lambdabot>  Parse error in pattern
14:04:36 <luqui> @check \(f::Int->Int) xs -> length (map f xs) = length xs
14:04:36 <lambdabot>  Parse error in pattern
14:04:38 <luqui> oh
14:04:41 <luqui> can't do that?
14:05:37 <luqui> @check \f xs -> let _ = f :: Int -> Int in length (map f xs) = length xs
14:05:37 <lambdabot>  Parse error
14:05:46 <luqui> @check \f xs -> let _ = (f :: Int -> Int) in length (map f xs) = length xs
14:05:47 <lambdabot>  Parse error
14:05:50 <mauke> ==, not =
14:05:56 <luqui> @check \f xs -> let _ = (f :: Int -> Int) in length (map f xs) == length xs
14:05:58 <luqui> oh
14:05:59 <lambdabot>  OK, passed 500 tests.
14:06:00 <luqui> :-)
14:06:57 <fasta> Why is planet.haskell.org filled with non-Haskell content?
14:07:21 <dons> its not restricted to only haskell content
14:07:34 <bos> fasta: that's usually what happens with planets
14:07:47 <augustss> @seen dpiponi
14:07:47 <Japsu> Perhaps the bloggers haven't discovered the joy of using a "Planet Haskell" category to filter what to send to a Planet
14:07:47 <lambdabot> dpiponi is in #haskell. I last heard dpiponi speak 24m 48s ago.
14:07:55 <dons> though, some people were signed up early that aren't really part of the community. while that's interesting, I doubt ibid would prune them.
14:08:05 <augustss> dpiponi: Your blog makes perfect sense :)
14:08:08 <dpiponi> augustss: looking for me?
14:08:43 <augustss> I'm looing forward to the next installment
14:09:10 <cizra> By the way, ghc doesn't know about `shiftR`.
14:09:14 <dpiponi> augustss: the next installment will just be a recap of some papers. But the one after will be cool (though not exactly useful...)
14:09:16 <mauke> @index shiftR
14:09:17 <lambdabot> Data.Bits, Foreign
14:09:19 <luqui> oh that explains the activity my blog has been seeing lately... Overloading functional references links to it :-
14:09:21 <mauke> import Data.Bits
14:09:38 <luqui> sweeet
14:10:03 <fasta> Those "functional references" can they implement the STRef interface?
14:10:08 <cizra> Thanks.
14:10:46 <fasta> If they can't it's terminology abuse, imho.
14:11:25 <luqui> that doesn't really make sense...
14:11:33 <luqui> so it could be
14:11:37 <luqui> I called them "state accessors" :-)
14:12:07 <fasta> What doesn't make sense?
14:12:16 <luqui> using functional references with STRef
14:12:19 <mauke> she's a -- twentieth century fox!
14:12:23 <luqui> you can't really make a "new" one
14:12:24 <mauke> oops, ww
14:12:29 <augustss> dpiponi: and I agree with Conor, I think Agda would be a good choice if you want to check out the dependent type route
14:12:32 <fasta> luqui: that's because you misunderstand.
14:12:46 <luqui> oh...kay
14:13:02 <sjanssen> fasta: these functional references have nothing to do with ST
14:13:17 <dpiponi> augustss: I tried to look at agda but couldn't make head or tail of the documentation :-(
14:13:39 <luqui> fasta: elaborate
14:13:40 <augustss> dpiponi: that's sad
14:13:50 <fasta> sjanssen: that's just a detail.
14:14:03 <augustss> dpiponi: sad about Agda, I mean.  Not you. :)
14:14:10 <fasta> The point of references is that they are mutable.
14:14:28 <luqui> well you can't really call them "functional" if they're mutable though
14:14:39 <luqui> :-)
14:14:47 <fasta> Needing these "functional references" seems a very theoretical issue.
14:14:49 <dpiponi> augustss: Just looked again and found UlfNorell's PhD thesis. Looks like that might be the thing to read. (Or at least skim.)
14:15:20 <augustss> dpiponi: Probably a good idea.  I've not read it
14:15:57 <augustss> dpiponi: you can also look at my Cayenne paper.  Old Agda had almost the same syntax, and similar semantics (they stole it all :) ).
14:16:40 <luqui> fasta: yeah, I don't know about this whole standardizing thing, though I admit it would be convenient.  I just think there a neat design pattern.
14:16:48 <fasta> Actually, you can implement functional references and they would provide the same features as STRefs
14:16:48 <luqui> but "functional reference" isn't a bad name imho
14:17:10 <fasta> These are not "functional references" im my book.
14:17:19 <fasta> in*
14:17:35 <dpiponi> Your paper on Cayenne looks much shorter than that thesis. I might just have to follow the path of least resistance.
14:17:39 <shapr> I realized yesterday that register allocation fits perfectly onto stack-based concatenative languages...
14:17:50 <luqui> fasta: are you talking about eg. a mutable reference outside a monad, say as in ML
14:17:58 <shapr> Obvious, I know.. but still a new connection for me.
14:20:33 <fasta> luqui: I have little interest in explaining it, but I have little trouble with the name "Haskell State Accessors", although this is of course also a rather general name and it could still mean a million things, but those are the facts of life, I guess.
14:29:59 <cizra> In short, I wrote a prog for calculating Fibonacci numbers with logarithmic complexity (approximately). finding 500 000th number took 112 seconds with the list-based one and only 34 seconds with the logarithmic.
14:30:25 <luqui> cizra, it's actually probably linear complexity
14:30:39 <cizra> Why do you think so?
14:30:42 <luqui> 500000th at logarithmic should be measured in milliseconds
14:30:52 <luqui> it's only logarithmic if you memoize the results
14:31:01 <cizra> How could I do that?
14:31:11 <luqui> because you're cutting the size of the numbers in half, but you're branching twice per call
14:31:16 <sorear> luqui: it's still not logarithmic
14:31:25 <luqui> sorear: it's not?
14:31:42 <sorear> luqui: the Nth fibonacci number has O(N) digits... multiplying big numbers takes a while
14:31:49 <Olathe> You can do it with O(n) multiplications.
14:31:59 <luqui> sorear: good point
14:32:07 <Vulpyne> http://www.kimbly.com/blog/000263.html
14:32:44 <Olathe> http://gmplib.org/manual/Fibonacci-Numbers-Algorithm.html
14:32:46 <lambdabot> Title: Fibonacci Numbers Algorithm - GNU MP 4.2.1
14:33:11 <Vulpyne> lambdabot doesn't love me. :(
14:33:52 <luqui> cizra: but memoizing will probably help you.  the answer to your question is: pure funtionally, with much difficulty; inside a monad, not too bad.
14:34:07 <luqui> use the State or ST monad to do it
14:34:18 <luqui> together with a Data.Map
14:34:37 <luqui> I just pulled ST out of my ass, btw, I've never used it :-)
14:34:41 <luqui> so that could be totally wrong
14:34:51 <Vulpyne> The link I pasted was a memoizing fibonacci algorithm, BTW.
14:35:05 <luqui> Vulpyne: with linear complexity though
14:35:11 <Vulpyne> Ah, yeah.
14:35:54 <cizra> luqui: bleh. I'm an absolute newbie.
14:36:11 <luqui> cizra: ahh, probably not the best thing to tackle right off the bat then
14:36:30 <luqui> but it's a relatively low-complexity thing to do, so once you've worked a little more with monads you might want to come back
14:37:05 <cizra> Could I hack this code here  http://www.kimbly.com/blog/000263.html to work with my log(n) functions?
14:37:25 <luqui> cizra: well, sortof
14:37:46 <luqui> problem with that is that it takes O(N) time just to look up the Nth number in the memo table!
14:38:09 <luqui> when you're working with numbers like 500000 that's a problem
14:38:38 <cizra> hrm
14:38:52 <augustss> luqui: an O(N) memo table sounds bad
14:39:32 <luqui> ya, best to use a Map...
14:41:13 <twanvl> or a trie
14:41:23 <luqui> hm, what is a trie?
14:41:57 <twanvl> ?wiki trie
14:41:58 <lambdabot> http://www.haskell.org/haskellwiki/trie
14:41:59 <mauke> best data structure ever
14:42:03 <twanvl> wrong wiki
14:42:04 <mauke> at least if you're writing in C
14:42:04 <twanvl> http://en.wikipedia.org/wiki/Trie
14:42:06 <lambdabot> Title: Trie - Wikipedia, the free encyclopedia
14:42:10 <glguy> bah! finger tree is the best evar!
14:42:26 <mauke> finger tree requires thinking
14:42:29 <twanvl> Compromise: a finger trie?
14:42:45 <luqui> oh, it's kinda like a dynamic DFA for string lookups
14:42:46 <luqui> neat
14:43:24 <twanvl> The real cool thing is that you can use tries for (almost) anything, not just strings
14:43:43 <luqui> the binary digits of a number, for example?
14:43:52 <cizra> WTF
14:43:55 <cizra> WTF^2
14:44:00 <jbalint> windows task force
14:44:07 <mrd> anything that can be sorted into buckets
14:44:07 <jbalint> thats what it means at my company :X
14:44:15 <luqui> cizra: WTWTF?
14:44:21 <glguy> jbalint: what's the difference?
14:44:22 * cizra is glad to lie down, lest I'd fall down from from my chair.
14:44:26 <Vulpyne> Did he just call the windows task force a bunch of squares?
14:44:28 <mauke> luqui: yes. or you could group the bits into groups of 4
14:44:35 <jbalint> glguy: hehe :D
14:44:39 <dons> is anyone using xmonad from a linux distro package?
14:44:40 <mauke> I did that for pointers once
14:44:46 <luqui> yummy
14:44:47 <bos> @hoogle userError
14:44:47 <lambdabot> Prelude.userError :: String -> IOError
14:44:47 <lambdabot> Control.Exception.userErrors :: Exception -> Maybe String
14:44:47 <lambdabot> System.IO.Error.userErrorType :: IOErrorType
14:44:59 <glguy> :t pebkac
14:45:01 <lambdabot> Not in scope: `pebkac'
14:45:07 <cizra> http://pastie.caboo.se/93962 -- milliseconds you were talking of.
14:45:08 <lambdabot> Title: #93962 - Pastie
14:45:38 <luqui> cizra: really, it worked?  cool
14:45:58 <luqui> how's your memory usage?
14:47:10 <cizra> I dunno how to measure it.
14:47:27 <olsner> wow, the 500000th fibonacci number was about 1000 times bigger than I imagined it!
14:47:33 <olsner> no wonder it took so long
14:47:47 <ddarius> Three orders of magnitude is not that big a difference.
14:47:52 <luqui> haha
14:48:00 <twanvl> > let {fib = fst . f ; f 0 = (1,1) ; f 1 = (1,2) ; f n = let (a,b) = f (n `div` 2 - 1) ; c = a + b in if even n then (a*a + b*b, c*c - a*a) else (c*c - a*a, b*b + c*c) } in fib 500000
14:48:02 <luqui> 10^1000 times bigger perhaps?
14:48:06 <lambdabot>  4782198814417580011745635839357386389629038165160320124272945142121783193064...
14:48:15 <twanvl> > length . show $ let {fib = fst . f ; f 0 = (1,1) ; f 1 = (1,2) ; f n = let (a,b) = f (n `div` 2 - 1) ; c = a + b in if even n then (a*a + b*b, c*c - a*a) else (c*c - a*a, b*b + c*c) } in fib 500000
14:48:18 <lambdabot>  104494
14:48:21 <cizra> OK, now  I need someone  to  explain that memoization in plain dumb language so  that I could brag about it in my algorithms class (=
14:48:28 <mrd> I went on a walk that turned out to be 1000 times longer than I imagined.
14:48:38 <luqui> cizra: memoization is basically storing the results of an expensive function in a table
14:48:40 <cizra> I understand the problem of computing stuff multiple times
14:48:52 <cizra> Isn't it a side effect?
14:48:59 <luqui> cizra: yeah
14:49:07 <ddarius> mrd: I went on a walk one day and came back a month and a half later.
14:49:08 <mrd> lazy evaluation does memoization under the hood, so you can take advantage of it
14:49:11 <twanvl> It is not an *observable* side effect
14:49:12 <luqui> you can only do it on functions _without_ side effects
14:49:29 <luqui> but it creates a side effect of making the function faster :-)   (heh, joke kinda)
14:49:38 <b_jonas> month and a half?
14:50:04 <cizra> Well,
14:50:04 <mrd> why last week I went on a walk and travelled 400 miles
14:50:04 <b_jonas> I mean, just 1000 times longer doesn't mean anything, you might just wanted a 10 meter long walk originally
14:50:10 <cizra> why doesn't Haskell do that lazy evaluated memoization for me?
14:50:18 <luqui> cizra: it does on a local scale
14:50:28 <DRMacIver> cizra: Because space usage is hard enough to predict without that...
14:50:29 <luqui> and in fact it's doing that in your new version from kim's blog
14:50:41 <glguy> cizra: because in general you don't want it to
14:50:48 <cizra> OK
14:51:24 <luqui> it is too bad that it's so hard to tell a function to do it when you _do_ want it to though
14:51:49 <nuncanada> memoization dont substitute good understanding of the problem! For example the typical dynamic programming example matrix index multiplication order can be solved in O(n*log n)... dynamic programming does it in n^3
14:51:49 <cizra> Oh my! top reported that this thing consumes around 43% of my memory (512 megs).
14:51:59 <mrd> > let l = [1+1] in (l !! 0, l !! 0)  -- memoization
14:52:01 <lambdabot>  (2,2)
14:52:34 <Cale> > let l = 1+1 in (l,l)
14:52:35 <lambdabot>  (2,2)
14:52:51 <mrd> > let l = [1+1, (l!!0)+1] in (l !! 0, l !! 0)  -- memoization
14:52:53 <lambdabot>  (2,2)
14:53:12 <DRMacIver> luqui: The trick int-e showed me recently involving generalised tries is rather nice.
14:53:22 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
14:53:23 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:53:39 <luqui> let l = trace "Evaluate" (1+1) in (l,l)
14:53:44 <luqui> > let l = trace "Evaluate" (1+1) in (l,l)
14:53:45 <lambdabot>   Not in scope: `trace'
14:54:14 <luqui> > let l = Debug.Trace.trace "Evaluate" (1+1) in (l,l)
14:54:14 <ddarius> mrd: 300 miles to, 300 miles back.
14:54:15 <lambdabot>   Not in scope: `Debug.Trace.trace'
14:54:16 <cizra> Okie, good night. It was fun and I'm really starting to like Haskell.
14:54:17 <luqui> aww
14:54:26 <cizra> I can't imagine doing anything useful with it yet, though.
14:54:26 <luqui> cizra: it only gets better :-)
14:54:52 <cizra> Like.. real-world stuff like a database-driven GUIfied application (Ruby + Qt4 was my bet).
14:54:54 <luqui> it's the opposite of perl.  hard to get going, good when you do.
14:55:10 <cizra> What about Haskell's suitability for this kind of stuff?
14:55:18 <luqui> cizra: it _can_ do it
14:55:21 <luqui> but it's not great at it
14:55:30 <luqui> what it is good at is the algorithms backing your application
14:55:42 <luqui> if your application is a gui around some very simple logic, then haskell probably won't be a good idea
14:55:56 <cizra> yes, it is
14:56:09 <mrd> I dunno, I found gtk2hs to be pretty easy to  use
14:56:11 <cizra> OK. But can I somehow bind to haskell from Ruby or C++ or something?
14:56:14 <luqui> but if it's a gui around some amazing algorithmic magic, then you'd probably use haskell to make the algorithmic magic writing easier in exchange for the slight pain of gui/db app writing
14:56:28 <luqui> cizra: haskell has an amazingly good FFI (foreign function) interface
14:56:33 <EvirDrevo> I find Gtk2Hs with glade relatively easy to use.
14:56:35 <mrd> I think you are being overly negative
14:56:36 <luqui> so you can bridge to C nicely
14:56:38 <EvirDrevo> There's not much about the GUI.
14:56:40 <cizra> nah, you misunderstood -- I want it the other way around
14:56:53 <cizra> Like one can write Ruby and "outsource" the difficult bits to C
14:56:53 <EvirDrevo> Just click the GUI together in Glade and load it with GtkHs ...
14:57:05 <ddarius> luqui:  Haskell could have a better story for GUI and DB, but it doesn't have a bad one if the libraries work with your DB.
14:57:30 <luqui> yeah, I probably shouldn't be talking to this measure
14:57:40 <luqui> since I've mostly done algorithms with haskell with minimal UI
14:57:45 <EvirDrevo> It definitively easier to use Gtk2Hs than using GTK from C.
14:57:58 <luqui> I'm not really comparing to C
14:58:02 <bos> @where sha
14:58:02 <lambdabot> I know nothing about sha.
14:58:06 <luqui> because just about everything is better than C
14:58:09 <luqui> unless you're talking about speed
14:58:14 <luqui> comparing more to, eg. ruby
14:58:15 <ClaudiusMaximus> cizra: it's possible to have a C program that calls Haskell bits (see ghc flag -no-hs-main or similar)
14:58:23 <cizra> OK, thanks
14:58:25 <bos> @where sha1
14:58:25 <lambdabot> I know nothing about sha1.
14:58:36 <cizra> fib = ((map fib' [0 ..]) !!)
14:58:40 <glguy> bos: there's a crypto library laying around somewhere
14:58:40 <cizra> -- what does this map do?
14:58:47 <ddarius> Any implementation of a language that can talk to C (and it'd better be able to!) can talk to Haskell.
14:58:55 <luqui> it just says build the list:  [fib' 0, fib' 1, fib' 2, ...]
14:59:06 <bos> glguy: yeah, igloo wrote a SHA-1 library ages back
14:59:08 <luqui> but it's lazy, so it won't evaluate an element of the list until it needs to
14:59:11 <glguy> cizra: it applies the fib' function to each element of the list of natural numbers
14:59:19 <bos> but i want SHA-1 on ByteStrings, alack
14:59:26 <cizra> [0 ..] is an infinite list of natural numbers?
14:59:30 <luqui> cizra: yes
14:59:42 <ddarius> Assuming 0 :: Integer
14:59:48 <mrd> > maximum [0..] :: Integer
14:59:52 <luqui> haha
14:59:52 <lambdabot> Terminated
14:59:53 <cizra> (map fib' [0 ..]) is an infinite list of fib' functions with the argument [number]?
15:00:03 <dons> bos, didn't i roll a sha1 on bytestrings (using openssl) the other week?
15:00:03 * bos has an FFI-free haskell mysql binding working, but it can't authenticate to a server yet
15:00:03 <cizra> fib' function values, maybe?
15:00:09 <bos> dons: did you?
15:00:15 <dons> yeah, i did. let me see...
15:00:18 <bos> oh, sure, it's easy to wrap openssl
15:00:19 <olsner> bos: I remember someone working on that... I think it was posted on haskell-cafe a month back or two
15:00:20 <dons> damn fast too, i might say :)
15:00:21 <luqui> cizra: yes, it is essentially the list of the range of fib'
15:00:30 <dons> bos, right. that's the easy approach
15:00:31 <cizra> Which one? functions or values?
15:00:38 <luqui> cizra: values
15:00:40 <bos> but i'd rather not have an openssl requirement
15:00:52 <cizra> OK
15:00:57 <bos> cabal yak shaving: write a package so you can write a package
15:00:59 <luqui> cizra: [fib'(0), fib'(1), fib'(2), ...]  :-)
15:01:08 <cizra> Yes, I see
15:01:16 <luqui> gut
15:01:47 <cizra> What does !! do there? Is it applied to the argument of fib, so that really the function becomes this:
15:01:57 <luqui> > [6,4,8,3,1] !! 3
15:02:00 <lambdabot>  3
15:02:02 <luqui> > [6,4,8,3,1] !! 2
15:02:04 <lambdabot>  8
15:02:07 <cizra> fib n = [fib'(0), fib ..] !! n?
15:02:12 <luqui> yes
15:02:13 <cizra> I find it VERY strange.
15:02:22 <mauke> it's called a section
15:02:31 <bos> not being able to pattern-match on the likes of bytestrings makes them very cumbersome compared to plain old strings :-(
15:02:34 <mauke> > map (+ 1) [0 .. 3]
15:02:35 <cizra> It seems dangling freely and erraneously there.
15:02:36 <lambdabot>  [1,2,3,4]
15:02:51 <bos> view patterns FTW!
15:02:55 <mauke> > map (!! 1) ["foo", "bar", "baz"]
15:02:56 <lambdabot>  "oaa"
15:03:02 <luqui> cizra: just how you can leave out an argument to a function, you can leave out an argument to an operator
15:03:22 <luqui> and it creates a curried function which takes the missing argument and applies it
15:03:23 <cizra> Oh? So map applies a function to each of the elements of the array, returning an array of results.
15:03:29 <luqui> right
15:03:35 <glguy> I think it can be confusing at first that: ((!!) n) and (!! n) mean "opposite" things :)
15:03:50 <cizra> "curried function", "monad", "coroutine", you're scaring me
15:04:01 <luqui> cizra: who said "coroutine" ?
15:04:03 <luqui> :-)
15:04:05 <mauke> ignore coroutines
15:04:08 <mauke> monads are trivial
15:04:13 <cizra> no one (= I just remember it from somewhere.
15:04:15 <mauke> (so you can ignore them too)
15:04:20 <cizra> Ah, yes, "memoization" ain't friendly either.
15:04:32 <mauke> memoization = caching the results of a function
15:04:35 <FMotAFK> memoization rocks.
15:04:45 <cizra> Yes, that's the easiest concept.
15:04:48 <FMota> 'sup guys (/gals) ?
15:05:05 <glguy> ?vixen what's up
15:05:05 <lambdabot> not much, what's up with you?
15:05:08 <Cale> Haskell doesn't really have memoisation, it just makes it easy to implement by way of sharing.
15:05:22 <glguy> @vixen do you like to share?
15:05:22 <lambdabot> yah, i like
15:05:28 <ddarius> currying is trivial too so you can ignore that too
15:05:29 <luqui> cizra: currying is this
15:05:45 <FMota> So, we can ignore everything?
15:05:45 <luqui> > let add x y = x + y in (add 4) 6
15:05:47 <lambdabot>  10
15:06:00 <ddarius> FMota: Yep.  Haskell is so trivial you already know all of it.
15:06:01 <cizra> Yeah? This is easy.
15:06:02 <luqui> add 4 is a function from ints to ints
15:06:09 <mauke> f = \(x, y) -> z  -- not curried
15:06:12 <FMota> ddarius: I wish :/
15:06:16 <Cale> Currying is the process of turning a function of multiple parameters into a function which takes a single parameter and returns a function which takes the rest.
15:06:17 <mauke> f = \x -> (\y -> z)  -- curried
15:06:27 <glguy> yum
15:06:41 * glguy had 10a today, curry with peanut sause
15:06:44 <cizra> oh, wait, damn
15:06:44 <glguy> sauce
15:06:51 <glguy> mild, chicken
15:06:53 <luqui> what was that interesting term I used
15:06:59 <Cale> Curried functions are easy to partially apply -- that is, apply them to just some of the parameters, getting a function of the rest (which is what luqui did)
15:07:04 <ddarius> Currying is (one way of) the natural isomorphism between (a,b) -> c and a -> (b -> c)
15:07:05 <luqui> oh yeah, salted hash
15:07:24 <glguy> dons: if you were just going to chat all day, you could have just come in to work ;)
15:07:27 <luqui> ddarius: yeah, isomorphism is also a friendly word
15:07:28 <cizra> Cale: Now it clicked in the place!
15:08:02 <Cale> > map (subtract 1) [1..10]
15:08:04 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
15:08:05 <dons> glguy: trying to get xmonad 0.3 released. almost done!
15:08:10 <Cale> > subtract 1 5
15:08:11 <lambdabot>  4
15:08:11 <luqui> the nice thing about asking questions on #haskell is that you get 45 answers
15:08:12 <cizra> Of course, if you supply one argument to a mathematical 2-arg function, then it becomes an 1-arg function.
15:08:15 <ddarius> isomorphism is very friendly.  f is an isomorphism if there exists a g such that f . g = id and g . f = id.
15:08:16 <luqui> and you can usually make sense of one of them
15:08:32 <dons> glguy: though we've a few organisational things i needed to do today :)
15:08:32 <luqui> cizra: exactly
15:08:37 <ddarius> dons: What's new in xmonad?
15:08:47 <glguy> dons: you are in the US now, that's "organizational"
15:09:05 <Cale> cizra: right -- in mathematics, the distinction is hardly mentioned
15:09:06 <luqui> though folks in math usually don't curry, unless they're lambda calculoids:    they'd say  +:  Z x Z -> Z
15:09:13 <dons> ddarius: floating layer, better xinerama support, more state preservation, hmm, huge library of extensions, including an ion-alike layout
15:09:30 <dons> glguy: heh. never! i'll rot in gaol before I spell 's' with an 'z'
15:10:08 <ddarius> luqui: A lot of currying in the theory of monoid/group actions and such.
15:10:23 <ddarius> And modules and rings.
15:10:42 <luqui> ddarius: ok I believe you
15:10:48 <luqui> ddarius: I spend most of my math in set theory
15:10:52 <Cale> It's one of those things which just gets applied implicitly whenever it's really convenient.
15:11:14 <Cale> Like the "associativity" of the Cartesian product.
15:11:52 <luqui> well that comes from the set-theoretic definition of the tuple <a,b,c>
15:11:52 <ddarius> Cale: Yeah, the isomorphism is often used implicitly in those cases though they definitely are cognizant of what's going on.
15:11:54 <luqui> oh wait
15:11:56 <luqui> no it doesn't
15:11:59 <Cale> ddarius: of course
15:12:27 <luqui> it's just sloppiness which happens to work out
15:12:39 <ddarius> luqui: The definition of math.
15:12:46 <luqui> haha
15:12:54 <DRMacIver> luqui: I think it comes up reasonably often under different names.
15:12:55 <luqui> yeah, totally
15:13:04 <luqui> I can handwave to mathematicians way better than I can handwave to computers
15:13:07 <DRMacIver> (currying I mean)
15:13:29 <Cale> Whenever it's convenient, we regard S x (S x S), (S x S) x S and S^3 = S^{0,1,2} as the same thing.
15:13:40 <ddarius> DRMacIver: I'm curious what other names you are thinking of in particular.
15:13:41 <Cale> (using the familiar isomorphisms)
15:13:48 <luqui> right
15:13:49 <Cale> But they're not *really* the same thing.
15:13:59 <luqui> they could be
15:14:17 <luqui> at some point my brain discards the fact that SxS is a set
15:14:24 <luqui> i'm not sure when that is
15:14:28 <cizra> OK, good night and thanks for all the help! Haskell seems amazing.
15:14:31 <ddarius> SxS is a set?
15:14:36 <Cale> cizra: glad you like it :)
15:14:38 <cizra> Brain-twisting.
15:14:44 <DRMacIver> ddarius: I'm failing to come up with any good examples now that I've said that. :) I'm not sure if it's actually often named. But when you're dealing with function spaces in analysis you tend to do a lot of operations which look suspiciously like currying.
15:14:48 <luqui> but if I could formalize it, I'm pretty sure I could formalize it so that S x (S x S) = (S x S) x S
15:14:54 <Cale> ddarius: In this context, yeah :)
15:14:57 <dpiponi> Cale: One time I was teaching a problem class in basic linear algebra.  I simply couldn't convince one guy that zero in the reals wasn't the same as zero in a vector space. "Zero is zero is zero" the guy kept saying.
15:15:18 <ddarius> DRMacIver: Yep.  E.g. the various persectives on homotopy (not quite analysis)
15:15:36 <Cale> dpiponi: I think that has a deeper cause still.
15:15:47 <DRMacIver> dpiponi: I had something akin to the opposite argument when being taught basic linear algebra. :)
15:16:00 <DRMacIver> (Trying to convince my supervisor that a 1*1 matrix was not the same thing as a scalar)
15:16:11 <Cale> dpiponi: In particular, lots of problems in thinking seem to arise from the notion that mathematical truth is somehow "absolute".
15:16:18 <luqui> heh, I was a programmer before a mathematician
15:16:19 <EvirDrevo> dpiponi: Umm. I've seen a girl claiming "0 divided by anthying is always 0! So the limes is 0!" (when the limes was "0/0" and you'd use L'Hospital)
15:16:24 <luqui> and I had a hell of a time with math's equality
15:16:33 <luqui> "which equality do you mean" I kept thinking
15:16:38 <luqui> value, referential?
15:16:39 <ddarius> 0 divided by anything is 1?
15:16:56 <EvirDrevo> ddarius: Exclamation, not factorial. ;-)
15:17:03 <Cale> luqui: Well, you need the quantifiers to know.
15:17:04 <ddarius> Long live Plato!
15:17:07 <DRMacIver> ddarius: Yes, that too. Algebraic topology was never my strongest point though. :)
15:17:30 <dpiponi> DRMacIver: Maybe some mathematicians could use a dose of type theory :-)
15:17:42 <luqui> agg gtg
15:17:46 <luqui> I like this discussion
15:17:51 <ddarius> dpiponi: Many mathematicians could use a dose of the lambda calculus.
15:17:56 <Cale> dpiponi: Differential geometry in particular seems to need some type theory. :)
15:17:57 <luqui> no kidding
15:18:07 <DRMacIver> ddarius: Oh, it also comes up in multidimensional calculus. :)
15:18:09 <ari> DRMacIver: May I suggest starting with asking him if he is convinced that zero is a meaningful number? That could get him on the road of enlightenment :)
15:18:36 <DRMacIver> ari: Given that this was 6 years ago and I no longer even remember his name, I'm not sure it's a useful suggestion. :)
15:19:06 <Cale> However, keeping the types of things straight isn't really so important so long as everyone is fully conscious of what's going on -- which isomorphisms are being applied.
15:19:12 <dpiponi> Cale: I think many mathematicians would enjoy lambda calculus. For some reason, mathematicians study computing in a most unmathematical way.
15:19:12 <ari> DRMacIver: I see :/
15:20:11 <b_jonas> dpiponi: yeah. I always find some way "the" mathematicians do things
15:20:17 <Cale> dpiponi: Mathematicians study computing? :)
15:20:35 <dpiponi> Cale: Many mathematicians take courses in numerical methods etc.
15:20:40 <Cale> I suppose so
15:20:50 <dpiponi> Cale: But the computing aspect is so boringly imperative.
15:20:55 <DRMacIver> I had a course on "Logic, Computation and Set Theory" as part of my maths degree.
15:21:30 <ddarius> aka "How To Tell The Computer To Tell You You are Wrong"
15:21:48 <dpiponi> Cale: Additionally, many subjects (including things like group theory and representation theory) have algorithms in them.
15:21:48 <DRMacIver> The computation part was moderately interesting. We learned to write an interpreter for recursive functions on a register machine. 'though they didn't call it that. :)
15:21:55 <Lamperi_> Â§Â§
15:22:58 <dpiponi> Cale: The really dumb thing is that these algorithms are presented in imperative form because the people writing these courses assume that the much simpler recursive algorithm, which is closer to the original mathematics, isn't suitable for real computers.
15:23:12 <Cale> dpiponi: hmm, I suppose. Most of the things which could be treated as algorithms were just handled in plain English when I took those subjects.
15:23:51 <dpiponi> Cale: It's usually a pidgin imperative pseudo-code.
15:23:53 <Cale> Though the focus of the courses was pretty far away from computing anything.
15:25:12 <ddarius> Computational Category Theory was cute
15:28:04 <Cale> In my rings course, there was a blurb about the Miller-Rabin primality test, but I don't think there was even pseudocode for that.
15:29:29 <Cale> Heh, in real analysis 1, there was some proof that involved an infinite flowchart. (But it was a bit silly, the proof didn't really require anything like that.)
15:32:45 <MyCatVerbs> Cale: I should bloody well hope not.
15:33:37 <Cale> MyCatVerbs: hm?
15:33:45 <MyCatVerbs> Cale: you'd all be guaranteed to run out of ink on your exam papers, excepting that one guy way over in the corner who hasn't actually studied, never turned up for lectures and is, in fact, quietly huffing glue. Nobody knows why the _Hell_ he enrolled, him least of all, but such is life.
15:34:01 <shapr> @arr
15:34:01 <lambdabot> I want me grog!
15:34:33 <MyCatVerbs> Because he isn't even *attempting* the question. The naked green faeries flying around his head would slap him with mallets if he dared touch his biro.
15:34:43 <Cale> ah -- you could still *describe* the infinite flowchart in finite space. In fact, I think if you allowed for mutable cells, you could do it with just a finite flowchart.
15:35:48 <MyCatVerbs> Cale: no you couldn't.
15:36:02 <Cale> MyCatVerbs: hm?
15:36:07 <MyCatVerbs> Cale: not if the bastard who wrote the exam paper used those three satanic words...
15:36:15 <MyCatVerbs> "Show your working."
15:36:48 <MyCatVerbs> And the other two which're absolutely guaranteed to have the class swearing under their breath? "In full."
15:36:50 <Cale> I know you're kidding, but that still doesn't really make sense ;)
15:38:19 <Cale> (It really would be acceptable to do that on the exam, and of course you do actually have to show your work.)
15:39:03 <Cale> These exams usually didn't tend to have many questions where showing your work could even conceivably be optional, since the answer was usually a proof.
15:39:44 <Cale> heh, though if you were required to show your work in *constructing* the proof, now that would be interesting ;)
15:40:01 <nuncanada> I thought the guy that never studied and never showed up would score an A...
15:40:10 <nuncanada> :)
15:41:09 <MyCatVerbs> nuncanada: yes, but only because he has photographs of the prof in the dean's wife's bedroom...
15:41:39 <nuncanada> hehehe...
15:44:33 <MyCatVerbs> (They're playing Boggle together. Completely innocent except for the fact that the Dean *hates* wordgames and would commit genocide if he caught either at it.)
15:45:24 <Saizan> i feel weasels are going to enter this discussion very soon
15:46:01 <LoganCapaldo> Saizan, that's a self-fufilling prophecy right there
15:46:14 <LoganCapaldo> The very sentence makes itself true
15:46:22 <LoganCapaldo> it's like the opposite of paradox
15:46:28 <LoganCapaldo> Does that have a name?
15:46:43 <Lycurgus> performative utterance
15:47:02 <LoganCapaldo> Really? Or did you make that up?
15:47:10 <Olathe> A tautology ?
15:47:13 <Lycurgus> liek Lux Fiat
15:47:19 <LoganCapaldo> Olathe, that sounds right
15:47:25 <LoganCapaldo> maybe
15:48:15 <sjanssen> @keal
15:48:15 <lambdabot> perhaps i just genius and never tested
15:48:34 <olsner> perfect exam answer right there!
15:48:46 <desp> it has come to my attention that JavaScripts sucks.
15:48:46 <LoganCapaldo> does @keal support searching like quote?
15:48:50 <LoganCapaldo> @keal weasel
15:48:51 <lambdabot> proofs are no longer sound
15:49:04 <olsner> @keal
15:49:05 <lambdabot> intuitive != imperative
15:49:15 <olsner> @protontorpedo
15:49:15 <lambdabot> does huge or ghc have more stuff?
15:49:28 <LoganCapaldo> I would guess huge
15:49:30 <olsner> "huge" definitely should have more stuff
15:49:48 <LoganCapaldo> I love this channel :)
15:49:58 <atp> hey guys.  i'm trying to implement field extension types in haskell.  is there some way to create a derived type based on a particular *value* of a particular type, rather than on the whole of the type?
15:50:12 <olsner> LoganCapaldo: don't we all :)
15:50:24 <atp> for the moment, i'm only worrying about quadratic field extensions
15:50:38 <atp> (ie, constructible numbers)
15:51:10 <atp> basically, I want to be able to have F[sqrt(2)] and F[sqrt(3)] be different types
15:51:29 <sorear> atp: basically, you want a type to depend on a value
15:51:33 <atp> sorear: yes
15:51:39 <atp> can haskell do that?
15:51:41 <atp> if so, how?
15:51:44 <sorear> atp: no
15:51:47 <atp> darn
15:51:49 <olsner> (C++ has that ;-)
15:51:52 <sorear> atp: this is called dependant types :)
15:52:00 <mauke> @where oleg
15:52:00 <lambdabot> http://okmij.org/ftp/
15:52:12 <LoganCapaldo> import Oleg
15:52:13 <sorear> Even Oleg can't do it.
15:52:14 <atp> sorear: hm, any plans to include it in haskell prime?
15:52:20 <sorear> (He can fake it though)
15:52:21 <Saizan> sorear: can't you get something close like in the functional pearl about implicit configurations?
15:52:35 <LoganCapaldo> There are other languages out there...
15:52:37 <sorear> Saizan: close but not it
15:52:43 <LoganCapaldo> some even already have dependant types
15:52:46 * LoganCapaldo ducks
15:52:53 * atp likes haskell.
15:52:57 <olsner> It is so impossible, even Oleg can't do it!
15:53:08 <atp> it would be a rather useful feature for doing algebra
15:53:09 <liyang> atp: er, not a chance. Though http://www.cse.unsw.edu.au/~chak/papers/SSPC07.html is the first step towards that direction.
15:53:09 <lambdabot> Title: Research Papers of Manuel Chakravarty
15:53:27 <liyang> Agda 2 *compiles* these days, I hear.
15:53:30 <atp> liyang hm, ok.
15:54:13 <liyang> (actually Agda 2 works okay I hear. I'm just being sarky.)
15:54:25 <atp> what's agda 2?
15:54:58 <liyang> This is Agda: http://unit.aist.go.jp/cvs/Agda/
15:54:59 <lambdabot> Title: Agda Official Web Site
15:55:03 <Saizan> atp: http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf <-- this is the paper i was talking about
15:55:07 <ddarius> dependent
15:56:00 <LoganCapaldo> potato, potatoe
15:56:06 <LoganCapaldo> let's call the whole thing off
15:56:10 <atp> Saizan: thanks
15:57:11 <ddarius> @seen DRMacIver
15:57:11 <lambdabot> DRMacIver is in #haskell-blah, #scala and #haskell. I last heard DRMacIver speak 35m 24s ago.
15:59:57 <DRMacIver> ddarius: ?
16:03:00 <ddarius> Blog post.  TCO is unrelated to CPS.
16:03:19 <dpiponi> atp: Check out http://www.haskell.org/pipermail/haskell-cafe/2007-August/030729.html
16:03:21 <lambdabot> Title: [Haskell-cafe] How do I simulate dependent types using phantom types?, http://tinyurl.com/2hsrem
16:03:32 <ddarius> And TCO is really easy to do for a (to assembly) compiler.
16:04:39 <sorear> DRMacIver: Just replace CALL foo ; RET with JMP foo  (in a x86 compiler without arguments or return values; the general case is only slightly more complicated)
16:04:59 <DRMacIver> ddarius: I was under the impression that scheme implementations often sidestepped the tail call optimisation issue by converting everything into continuation passing style and then the tail call optimisation popped out for free. But maybe I'm confusing issues.
16:05:15 <DRMacIver> But I guess I've just grabbed the wrong end of the stick. Thanks for the clarification.
16:05:18 * DRMacIver will add a note.
16:05:28 <ddarius> DRMacIver: Continuation passing style -makes- everything a tail call, so you -need- TCO to (reasonably) do CPS
16:05:48 <DRMacIver> Oh, right. Fair point. :)
16:05:50 * DRMacIver sucks.
16:06:34 <ddarius> Getting TCO and performance when compiling to a high-level language that doesn't support TCO is hard.
16:07:19 <ddarius> Ironically, CPS can be used to work with that.
16:08:10 <DRMacIver> Because implementations can make it work via trampolining, right?
16:08:46 <ddarius> That's one possibility.  Basically, you're either going to have to return and so you must also return what remains or you roll your own control stack.
16:09:00 <DRMacIver> ok.
16:10:14 <DRMacIver> Thanks for the clarification. I've posted an update to this effect.
16:10:27 <DRMacIver> (The actual empirical tests still hold. :) )
16:16:52 <pjd> ddarius: CPS without TCO isn't necessarily that hard;  you can use a trampoline
16:17:24 <pjd> this is the standard approach in Common Lisp and such, IIRC
16:17:54 <pjd> ah, as DRMacIver said
16:17:56 <roderyk> having trouble with basic type conversions... how can I round a sqrt (..) expression back to an Int?
16:18:34 <pjd> @type round
16:18:37 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:18:40 <Saizan> ?type floor -- etc
16:18:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:19:15 <pjd> @type ceiling
16:19:17 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:19:31 <atp> i'm sort of confused... why is the forall necessary?
16:19:38 <mauke> atp: it isn't
16:19:40 <shachaf> It's not.
16:19:48 <atp> ah.  so what's the point of it then?
16:19:57 <mauke> too many spare cycles
16:20:01 <shachaf> To be there when it is necessary. :-)
16:20:09 <Saizan> atp: since -fglasgow-exts is on ghci prints unnecessary foralls
16:20:17 <atp> ok, let me rephrase the question: when would forall be necessary?
16:20:23 <TSC> The forall is implicit most of the time
16:20:28 <shachaf> When it's not on the outside.
16:20:35 <atp> for example?
16:20:40 <Saizan> ?type gfoldl
16:20:42 <lambdabot> Not in scope: `gfoldl'
16:20:49 <shachaf> @ty Control.Monad.ST.runST
16:20:51 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
16:21:00 <shachaf> @ty Data.Generics.gmapT
16:21:02 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall b. (Data.Generics.Basics.Data b) => b -> b) -> a -> a
16:21:12 <TSC> atp: Also, search for "existential types"
16:21:19 <atp> existential types
16:21:20 <atp> ok
16:21:21 <atp> thanks
16:22:05 <Saizan> yeah, higher rank
16:33:43 <miraage> Does ghci understand multi-line function definitions: "let fac 0 = 1 \n let fac n | n > 0 = n * fac (n-1)" doesn't seem to work.
16:33:58 <dibblego> miraage, use ;
16:34:10 <mauke> also, too many lets
16:34:22 <dibblego> > let fac 0 = 1; fac n | n > 0 = n * fac (n-1) in fac 5
16:34:23 <lambdabot>  120
16:34:43 <kpreid> miraage: like this: let fac 0 ... ; fac n ...
16:34:48 <TSC> > let f 0 = 1 ; f n = n * f (n-1) in f 10
16:34:50 <lambdabot>  3628800
16:35:09 <mauke> > let f n = product [1 .. n] in f 100
16:35:11 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
16:35:38 <miraage> So in ghci, every function definition has to be a one-liner?
16:38:34 <b_jonas> miraage: yep
16:39:54 <geezusfreeek> miraage, every program is a one-liner, in a sense
16:40:03 <geezusfreeek> one expression, anyway
16:40:03 <kpreid> hmm. I'd think it wouldn't be too hard to allow multiline ghci input with explicit {s
16:40:21 <sorear> kpreid: hbi worked liek that
16:40:51 <geezusfreeek> oh, i didn't catch that you meant ghci specificallly
16:41:49 <miraage> Most examples of haskell code I saw online had nice readable multi line definitions. I guesss that works in non-interactive environments?
16:41:51 <geezusfreeek> i interpreted that as a more newbie question about expressions or something :\
16:42:07 <geezusfreeek> miraage, yes
16:42:52 <geezusfreeek> haskell even has significant indentation
16:43:24 <geezusfreeek> in the same sense as python, i mean
16:43:45 <DRMacIver> Although is slightly less religious about it. :)
16:43:46 <LoganCapaldo> except in Haskell it's sugar
16:43:52 <LoganCapaldo> Mmmm tasty sugar
16:45:24 <geezusfreeek> haskell is like cream and sugar and icing and a cherry on top
16:46:04 <geezusfreeek> but on a nice piece of steak... and the whole thing tastes better than it sounds
16:46:13 <LoganCapaldo> mmm steak and eggs
16:46:22 <LoganCapaldo> clearly no better meal imo
16:46:32 <geezusfreeek> steak and potatoes
16:47:04 <LoganCapaldo> well potatoes are the side (along with bacon) w/ my steak and eggs
16:47:14 * LoganCapaldo is gonna die of a coronary
16:48:12 <mauke> is that like a corollary
16:48:23 <LoganCapaldo> I hope so
16:49:19 <ddarius> Dying of a corollary would be depressing.
16:50:01 <LoganCapaldo> Or at the least, anti-climatic
16:50:19 <LoganCapaldo> "What not even a theorum killed me? Just a corollary??"
16:54:54 <sorear> what about a Korollary?
16:55:28 <LoganCapaldo> that would be...personal
16:55:39 <dibblego> just get a corollary bypass
16:55:55 <LoganCapaldo> no murder in #haskell please
16:56:00 <dons> heh
16:56:01 <mauke> you should see an ontologist
16:58:25 <LoganCapaldo> I had to google to get that joke
16:58:32 <LoganCapaldo> Or at least to be sure I got it anyway
17:12:12 <shapr> Has anyone hacked on Frag at all?
17:13:07 <shapr> I'm trying to figure out why it crashes on 64-bit systems.
17:13:25 <Lemmih> Does it segfault?
17:14:38 <shapr> *** glibc detected *** ./main: malloc(): memory corruption: 0x0000000001230270 ***
17:14:58 <shapr> First thing I did was grep for 'unsafe' but only turned up unsafe matrix calls.
17:15:33 <shapr> Now I'm adding debugging statements.
17:17:58 <shapr> I remembered what I wanted to do with hs-plugins... I wanted to try something like OpenCroquet for Haskell.
17:19:46 <shapr> This is probably a bizarre question, but is there some way to run an X server inside an OpenGL program?
17:20:40 <dons> hmm.
17:20:52 <dons> non trivial
17:21:04 <dons> you'd have to reimplement one of the X-in-a-window tools
17:21:08 <shapr> hmm
17:21:14 <dons> like Xnest
17:21:30 <shapr> Too bad, otherwise that'd be the easy way to recreate IRC in 3D :-)
17:31:30 <puusorsa> why is there no good functional bindings/wrapper/whatever for cocoa?
17:32:47 <puusorsa> i'll do it myself if i have to but me being haskell beginner it'll be useless piece of shit so it would be Real Nice if someone who actually knows what he's doing did it
17:33:09 <Cale> http://hoc.sourceforge.net/
17:33:10 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
17:33:25 <Cale> I don't know if that's still being maintained or not.
17:33:28 <puusorsa> doesnt work and it's not "functional"
17:33:33 <puusorsa> it is, kind of
17:33:45 <chessguy> ermm, i thought i heard of such a binding.
17:33:48 <chessguy> @go haskell cocoal
17:33:50 <chessguy> @go haskell cocoa
17:33:51 <lambdabot> http://del.icio.us/ade/cocoa
17:33:51 <lambdabot> Title: ade's bookmarks tagged with "cocoa" on del.icio.us
17:33:53 <lambdabot> http://hoc.sourceforge.net/
17:33:53 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
17:33:54 <dons> mocha/hoc is the main binding.
17:34:01 <dons> talk to ozone about it, puusorsa.
17:34:16 <dons> there's been little enough interest in further cocoa bindings - but perhaps you could restart that effort?
17:39:55 <puusorsa> little interest?
17:40:15 <puusorsa> fuck, maybe i should learn ruby instead, at least it has lots of mac support
17:40:33 <dons> well, HOC is a pretty complete binding, and had a thesis written about it.
17:40:42 <dons> perhaps you could take that up and just use it?
17:40:54 <dons> if its not satisfactory, contact the authors with improvements.
17:41:15 <dons> note that binding to an OO language in a functional manner is a research topic.
17:41:21 <dons> there's a basic parity mismatch in the type systems
17:41:28 <puusorsa> "please make even the examples work"
17:41:43 <dons> did you try it?
17:41:58 <dons> last time I used it, a couple of years ago, it worked for simple gui things
17:42:25 <puusorsa> of course not, i just say the examples work for fun and profit
17:42:34 <puusorsa> dont work
17:43:02 <puusorsa> (yes, i did try it. some examples work, some don't)
17:43:18 <dons> ok. so then perhaps ask the authors, (ozone is one of them), what the state is.
17:43:35 <dons> it could be a trivial issue, or it could be that the cocoa api has changed a lot since it was last updated in hoc
17:43:53 <ddarius> "Our amateur historian may thus become easily confused, despair, and switch to a less depressing hobby such as stamp collection."
17:44:19 <LoganCapaldo> ddarius, what is that from???
17:44:25 <LoganCapaldo> It sounds so familar...
17:44:57 <puusorsa> thanks, i will.. otoh, it makes the effort of being typesafe etc, i thought i'd just make some io binding or something to call the function thats used for sending messages to cocoa objects and use a ForeignPtr or something for the objects
17:45:43 <dons> you can always just make FFI calls, yep. gtk2hs might give some hints on that directoin
17:45:58 <dons> HOC tries to match up the type systems -- so more safety, more maintainence by the hoc devs
17:46:36 <ddarius> LoganCapaldo: The link Dan Piponi referenced on folk theorems.
17:47:57 <ChilliX> puusorsa: The problem is overloading.  If you don't track types on the Haskell side, you won't be able to resolve overloading automatically => name mangling to disambiguate overloaded functions by name, which is pretty ugly (but workable).
17:48:05 <ddarius> "the fact that due to its rather technical style it is apparently more often cited than read" (slight bit of context removed for comedic value)
17:51:02 <shapr> dons: Frag has some serious magic numbers in the biquadratic patch loading code.
17:51:23 <dons> yeah. seriously magic. :(
17:51:35 <dons> jdh hit that recently, I think, trying to get it ported to 64 bit
17:51:55 <shapr> That's exactly what I'm looking at.. who's jdh? John Hughes?
17:51:57 <dons> we've got a couple of guys hacking on frag in ~pls. maybe they know what's going on --- and could commit docs
17:52:03 <dons> jon harrop
17:52:06 <dons> he gave up
17:52:06 <shapr> ah
17:52:08 <shapr> heh
17:52:12 <dons> but he didn't try very hard.
17:52:22 <puusorsa> can't say i know exatcly how to do it but i've given it some though and i think it was your hs-plugins that had some
17:53:13 <puusorsa> damn i think i broke my mac, at least it keeps freezin every 5 minutes or so
17:53:59 <dibblego> DRMacIver, reading your latest blog entry, it seems you're missing a { ?
17:54:06 <puusorsa> anyway now beofre it does it again: 034528  dons> HOC tries to match up the type systems -- so more safety, more maintainence by the hoc devs
17:54:30 <puusorsa> exactly. screw that and just some simple ffi call to send message to objc
17:54:42 <shapr> dons: "ptr <- mallocBytes (((tesselation+1)*(tesselation+1))*28)" fails sometimes on a 64-bit system, but not always.
17:55:05 <dibblego> I hate seeing ; in Scala code :)
17:55:17 <sorear> shapr: twenty-eight, eh?
17:55:31 * sorear smells a sizeof() constant
17:55:50 <dons> yeah
17:55:54 <puusorsa> then maybe even some evil cpp trickery to automagicaly match the cocoa objects to their haskell cousins
17:56:00 <dons> what's the type of the pointer, shapr ?
17:56:01 <ddarius> dibblego: I don't think so.
17:56:11 <dibblego> ddarius, you don't think there is a missing { ?
17:56:36 <dibblego> oh wait, I see what's happening now
17:56:41 <dons> shapr: you'll just need to look at the C struct that's reading, and try to work out what the size should be, in terms of portable values
17:56:41 <ddarius> There you go.
17:56:44 <shapr> dons: Ptr Float
17:56:55 <sorear> eek!
17:56:59 <puusorsa> is that a) stupidest idea ever, or b) something that could work, even though it's less beautiful than hoc ?
17:57:03 <dibblego> it's indirect tail call optimisation (which the IBM JVM won't do either)
17:57:05 <sorear> er, maybe not eek
17:57:41 <ddarius> dibblego: Scala could do it regardless of whether the JVM supported it or not.
17:57:42 <dons> an array of these guys?
17:57:43 <sorear> dons: there is no way to portably calculate the size of a C struct
17:57:44 <shapr> sorear: If you're following along at home, it's the second line of createPatch in Curves.hs
17:57:53 <sorear> shapr: I'm not. :(
17:58:01 <ddarius> dibblego: But that would cost in efficiency and ease of talking to POJOs.
17:58:01 <dibblego> ddarius, I know; I just mean how difficult it is (the IBM JVM at least tries as well)
17:58:22 <dibblego> i.e. Scala is at least as clever as the most clever JVM
17:58:40 <dibblego> to make that an optimised tail call is breaking new ground on the JVM
17:58:54 <puusorsa> or c) dam you fool just ask ozone like we already told you we're not the lest bit interested stop bugging us already! :-p
17:59:05 <ddarius> dibblego: Only if you use Java methods for your methods/functions.
17:59:17 <ddarius> I'd be amazed if SISC doesn't support TCO.
17:59:37 <dibblego> ddarius, I'm referring specifically to *indirect* tail calls
17:59:59 <ddarius> dibblego: And I'm referring specifically to -all- tail calls.
18:00:21 <dibblego> ddarius, there are many examples of direct TCO on the JVM (IBM, Scala, SISC, etc.)
18:00:29 <dibblego> for loops :)
18:00:59 <dibblego> not even the Sun JVM will inline a direct tail call though
18:01:15 <ddarius> SISC supports indirect tail calls
18:01:17 <puusorsa> i'd like something like phooey (http://haskell.org/haskellwiki/Phooey) but production quality and for cocoa not wxhaskell, please
18:01:20 <lambdabot> Title: Phooey - HaskellWiki
18:01:25 <dibblego> ddarius, I didn't know that
18:01:53 <ddarius> It claims to support all of R5RS Scheme no exceptions, so it must support TCO.
18:04:18 <ddarius> puusorsa: I believe conal split the library apart so that it should be easier to retarget to Cocoa.
18:04:49 <puusorsa> whee, thanks!
18:05:16 <bitwize> howdy
18:05:23 <ddarius> howdy howdy howdy
18:05:38 <bitwize> did Haskell gain support for value semantics in my absence? :)
18:05:40 <puusorsa> 9 Plans
18:05:42 <puusorsa> Use Javascript and HTML in place wxHaskell, and hook it up with Yhc/Javascript.
18:06:02 <puusorsa> oh please no
18:07:08 <bitwize> it's really important :)
18:07:42 <mauke> what's a value semantics?
18:08:22 <bitwize> as opposed to reference semantics.
18:08:42 <phobes> Haskell is now completely OO by-reference
18:09:11 <mauke> bitwize: is there a difference if there are no mutables?
18:09:20 <bitwize> of course.
18:10:28 <bitwize> If a variable has value semantics it is allocated on the stack. That typically saves you one pointer indirection per access.
18:10:36 <mauke> haha
18:10:36 <bitwize> Which means fewer CPU cycles lost as heat :D
18:10:50 <mauke> you're completely missing the point of ... anything
18:11:07 <bitwize> That's why it's important though!
18:11:16 <shapr> sorear: Yeah, it appears to be a sizeof constant.
18:11:38 <phobes> You can probably do what you want with Template Haskell, which IIRC introduces C++ templates to Haskell
18:11:39 <puusorsa> myeah haskell should be made faster than c!
18:11:52 <mauke> phobes: no.
18:12:13 <mauke> is it trolling hour?
18:12:16 <shapr> I wish I could figure out the source of that magic 28.
18:12:27 <phobes> mauke: I'm just playing along
18:16:02 <ddarius> For Whom The Nick Trolls
18:17:39 <bitwize> when I go on about value semantics, I'm not really trolling, only kidding.
18:17:50 * ddarius understands.
18:19:18 <dons> bitwize: heh
18:19:45 <dons> i think bitwize /must/ be qwe1234 then. always with the value semantics
18:20:17 <ddarius> Can you have aliases with value semantics?
18:20:51 <bitwize> No, that's another good thing about it.
18:21:44 <ddarius> So bitwize can't be qwe1234 or IRC lacks value semantics and bitwize can't be qwe1234.
18:21:45 <bitwize> dons: qwe1234 helped me understand the IO monad.
18:22:16 <bitwize> oh, I thought that he meant pointer aliases :)
18:23:17 <puusorsa> @type (f .) . g
18:23:26 <lambdabot> Not in scope: `f'
18:23:26 <lambdabot>  
18:23:26 <lambdabot> <interactive>:1:8: Not in scope: `g'
18:23:32 <ddarius> @unpl (f .) . g
18:23:32 <lambdabot> (\ d i -> f (g d i))
18:23:38 <puusorsa> thanks
18:23:59 <bitwize> While snarking at him I said something to the effect of that you need const-correctness in order to optimize. And he said that was true, of course. But it's pretty ridiculous on its face, because you could do just the opposite: tag all side-effectful operations with a "this causes side effects, don't do these optimizations" marker in your program analysis.
18:24:45 <puusorsa> so that's like f . g but for functions takinf two arguments?
18:24:48 <bitwize> Start with certain primitives (like in Scheme, set!, set-car!, set-cdr! vector-set!, etc. and all IO) and recursively falgg as effectful any routine which calles these.
18:25:46 <bitwize> Of course if you have a typeful language you may as well flag effectful operations with a special type -- hence the IO type (and the monad which also eases composition of effectful operation sequences).
18:26:15 <bitwize> To quote Picard, "I think I owe Q(we1234) a debt of gratitude."
18:28:29 <bitwize> oh and by typeful I meant statically typed.
18:28:34 <bitwize> heheh, thinking outloud.
18:32:38 <bitwize> sry 'bout that
18:38:38 <pgavin> @pl f x y z = f y z x
18:38:38 <lambdabot> f = fix (flip . (flip .))
18:39:16 <sorear> Or, simpler yet, \_ _ _ -> fix id
18:39:20 <pgavin> @pl \f x y z -> f y z x
18:39:20 <lambdabot> flip . (flip .)
18:39:28 <pgavin> thats actually what I meant to do :)
18:39:44 <ddarius> Or simpler yes \_ _ _ -> undefined
18:40:06 <dhpeterson> guys what does @pl do?
18:40:14 <dhpeterson> it's a lambdabot command right?
18:40:18 <sorear> Abstraction elimination
18:40:25 <pgavin> pl = pointless
18:40:31 <pgavin> or, points-free
18:40:46 <dhpeterson> ok
18:41:24 <dhpeterson> so you're trying to compose a function that will give you a certain behaviour?
18:41:26 <bitwize> @pl \f x y -> (f x) && (f y)
18:41:26 <lambdabot> flip =<< (((.) . (&&)) .)
18:42:08 <dhpeterson> that's still a bit whacky for me i think - just learning:)
18:42:39 <ddarius> It compiles to combinators, a technique with a long history in lazy fp
18:42:47 <dhpeterson> ok
18:42:57 <dhpeterson> i have read about combinators, specifically parser combinators
18:43:16 <dhpeterson> :t flip
18:43:19 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:43:51 <shapr> I wonder if I could just replace all of these Int type signatures with Word32 and fix this problem?
18:43:52 <ddarius> The real meaning of combinators
18:44:01 <ddarius> @google "combinatory algebra"
18:44:05 <lambdabot> http://www.santafe.edu/~walter/AlChemy/Statement/combalgebra.html
18:44:05 <lambdabot> Title:
18:44:49 <ddarius> That page is not particularly useful, but not off.
18:44:58 <dhpeterson> thanks
18:45:04 <dhpeterson> just reading this now: http://haskell.org/haskellwiki/Pointfree
18:45:05 <lambdabot> Title: Pointfree - HaskellWiki
18:45:05 <dhpeterson> useful
18:45:12 <dhpeterson> it explains @pl
18:45:44 <ddarius> @google "Haskell Curry" "combinatory logic"
18:45:46 <lambdabot> http://en.wikipedia.org/wiki/Haskell_Curry
18:45:46 <lambdabot> Title: Haskell Curry - Wikipedia, the free encyclopedia
18:46:01 <dhpeterson> @unpl flip . (flip .)
18:46:01 <lambdabot> (\ j b c f -> j c f b)
18:48:43 <bitwize> @pl \f g x -> (f x) && (g x)
18:48:43 <lambdabot> liftM2 (&&)
18:53:09 <dhpeterson> heh this is whacky stuff - just reading now :)
18:53:29 <dhpeterson> tell me, does haskell provide these "I", "S" and "K" combinators, and if so what are they called (in the language)
18:53:43 <dhpeterson> (i hope that's not a stupid question btw)
18:53:59 <jder> I've got a question about haskell performance in this example: http://tinyurl.com/2gwuvv
18:54:01 <lambdabot> Title: Re: functional languages ill-suited for large programs?
18:54:03 <jder> Can anyone explain how "sure" I can be that the second version of 'fib' on this page is faster?  - That is, how long is the memoized list going to hang around? Forever?
18:54:32 <ddarius> dhpeterson: id ap const
18:54:43 <dhpeterson> ddarius: thanks :)
18:54:55 <ddarius> @pl \a b -> a
18:54:55 <lambdabot> const
18:54:57 <dhpeterson> and "Y" ?
18:55:02 <ddarius> @pl \f g x -> f x (g x)
18:55:03 <lambdabot> ap
18:55:05 <ddarius> y = fix
18:55:10 <ddarius> @pl \x -> x
18:55:10 <lambdabot> id
18:55:20 <pjd> @unpl ap
18:55:20 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
18:55:25 <pjd> :D
18:55:33 <FMota> so S = ap, K = const, and I = id
18:55:37 <dhpeterson> yep
18:55:43 <dhpeterson> and Y = fix
18:55:49 <dhpeterson> ok
18:55:55 <ddarius> :t ap const const
18:55:57 <lambdabot> forall a. a -> a
18:56:03 <sioraiocht> @src Either fmap
18:56:03 <lambdabot> fmap _ (Left x) = Left x
18:56:03 <FMota> :)
18:56:03 <lambdabot> fmap f (Right y) = Right (f y)
18:56:15 <ddarius> @. djinn type ap const const
18:56:17 <lambdabot> f a = a
18:56:38 <ddarius> @. . pl djinn type ap const const
18:56:41 <lambdabot> f a = a
18:56:59 <dhpeterson> @unpl id
18:56:59 <lambdabot> (\ a -> a)
18:57:11 <dhpeterson> @unpl fix
18:57:11 <jbauman> > ap const const 1
18:57:12 <lambdabot> fix
18:57:13 <lambdabot>  1
18:57:19 <shapr> jder: As long as you have a handle to it.
18:58:36 <bitwize> @type (+2)
18:58:37 <lambdabot> forall a. (Num a) => a -> a
18:58:39 <jder> shapr: But fib could, say, be defined in a module. That means it's never garbage collected?
18:59:13 <shapr> No, if you never call fib, nothing gets allocated, nothing gets executed.
18:59:23 <shapr> for example:
18:59:35 <shapr> > let ones = 1 : ones in take 5 ones
18:59:37 <lambdabot>  [1,1,1,1,1]
18:59:45 <ddarius> jder: What you want to look at is how GC in GHC deals with CAFs.
18:59:50 <bitwize> ap (+) (+2) 3
19:00:26 <shapr> jder: An infinite list could use a lot of memory, but the amount used depends on how much you request.
19:00:33 <shapr> jder: http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_need
19:00:51 <jder> right, but once it's requested, it's stuck in memory for ever? No re-thunking?
19:01:00 <shapr> Actually, no.
19:01:20 <jder> ddarius: thanks, I'll search for that.
19:01:21 <shapr> That could be how Haskell does it, but in fact it does the opposite for performance reasons.
19:01:53 <shapr> That's why you have to memoize functions explicitly if you want them to be memoized.
19:02:53 <shapr> jder: Also, even if Haskell did automatically memoize everything, once that value was no longer reachable, it'd still get GC'd.
19:03:04 <shapr> I don't think I said that clearly....
19:03:27 <LoganCapaldo> I can has memoization?
19:03:36 <shapr> DO NOT WANT!
19:04:05 <jder> So, basically, making it a list "encourages" haskell to keep it around?
19:05:02 <shapr> I think having the definition in a let or where encourages Haskell to keep it around.
19:06:21 <jder> Ok, thanks. I'll poke around with some of these keywords. :)
19:06:39 <shapr> Are you new to Haskell?
19:07:36 <jder> yes; I've gone through a couple tutorials and am now tackling some mathy problems to feel my way around.
19:08:23 <shapr> Are you joining the McMaster Haskellers?
19:08:50 <shapr> Anyway, welcome to the community! Feel free to ask any questions!
19:09:26 <shapr> jder: You could put those two definitions into a module, and run them with profiling on, that would give you an excellent view of memory use.
19:10:09 <jder> Good point! I just like having some idea of what's supposed to be going on behind the scenes.
19:10:09 <shapr> hiya coffeemug, how's code?
19:10:38 <jder> Well, thanks for the help! I should be off for now.
19:10:44 <shapr> Feel free to drop by anytime.
19:11:00 <sioraiocht> @src (->) fmap
19:11:01 <lambdabot> fmap = (.)
19:11:21 <sioraiocht> @instances (->)
19:11:23 <lambdabot> Couldn't find class `(->)'. Try @instances-importing
19:11:29 <sioraiocht> @instance (->)
19:11:29 <lambdabot> Maybe you meant: instances instances-importing
19:12:29 <coffeemug> hey, shapr
19:12:34 <coffeemug> code's well
19:12:35 <coffeemug> :)
19:13:05 <coffeemug> hmm
19:13:17 <coffeemug> all haskell jobs in NYC area are related to financial industry
19:13:34 <coffeemug> these stocks and bonds keep haunting me :)
19:13:36 <shapr> What about HAppS?
19:13:43 <LoganCapaldo> hmm all jobs in NYC are related to financial industry
19:13:53 <LoganCapaldo> I kid
19:13:59 <LoganCapaldo> but it sure seems that way
19:14:29 <coffeemug> yeah, HAppS is an option
19:15:06 <coffeemug> HAppS has the benefit of being an open source project
19:15:14 <shapr> yeah, BSD3
19:15:19 <coffeemug> so to get a job all one really needs to do is to submit some thoughtful patches
19:15:40 <LoganCapaldo> people get paid to work on happs now?
19:15:44 <LoganCapaldo> hot
19:16:02 <bitwize> LoganCapaldo: that means quants out the wazoo.
19:16:18 <bitwize> best sharpen your OCaml and APL skillz :)
19:16:38 <LoganCapaldo> bitwize, when I interviewed it was K
19:16:39 <LoganCapaldo> ;)
19:17:12 <bitwize> oooo.
19:17:35 <geezusfreeek> dude, i want to work on happs...
19:18:12 <dons> yeah, i want to meet the haskell guys working at abn amro and barclays bank.
19:18:15 <geezusfreeek> too bad it's out of the question right now due to... everything else... and my relative newbness
19:18:21 <dons> they're the new banks in the haskell game, it seems
19:18:48 <dons> i wonder if the finance guys are in a bit of an arms race to skill up in FP :)
19:19:04 <dons> seems like a mini-boom in haskell jobs, almost from nowhere, thanks to credit suisse
19:19:20 <coffeemug> I met credit suisse guys
19:19:24 <coffeemug> they do some interesting stuff
19:19:31 <dons> yep, definitely.
19:20:01 <coffeemug> it's just a bit hard to be passionate about building a product in financial industry unless you're a trader yourself
19:20:03 <bitwize> I landed my current position due to FP experience, though I don't actually use it :)
19:20:18 <SamB> bitwize: how can you avoid using it?
19:20:25 <coffeemug> I'm fishing for FP jobs now and there are surprisingly few
19:20:38 <dons> i'm starting a new haskell job tomorrow :)
19:20:40 <SamB> bitwize: you can't just forget the stuff
19:20:45 <coffeemug> I could count the companies I've found on fingers and toes
19:20:53 <coffeemug> dons: you're already in the US?
19:20:57 <dons> coffeemug: yup
19:21:01 <coffeemug> cool
19:21:01 <bitwize> No, but you can be constrained in how it is implemented.
19:21:05 <coffeemug> what will you be doing?
19:21:10 <coffeemug> MS Research?
19:21:12 <dons> but yeah, there's what, a dozen or so places that'd employ haskellers
19:21:23 <dons> coffeemug: nope, galois.com
19:21:25 <bitwize> dons: Apparently Qinetiq is looking for some.
19:21:30 <dons> bitwize: oh!
19:21:32 <dons> url?
19:21:40 <geezusfreeek> oh crap, i missed a smalltalk lecture at my university this evening
19:21:42 <bitwize> Don't have it now.
19:21:47 <dons> another one to chalk up though, very interesting
19:21:51 <coffeemug> well, if you add up Haskell, OCaml, Common Lisp, and Scheme you'll probably get a few dozen places
19:21:55 <bitwize> But I was contacted about a position with them in Cali involving java and haskell
19:22:03 <Nafai> It would be nice to find a job that would let you learn Haskell on the job like I learn Java on the job
19:22:09 <dons> bitwize: cool.
19:22:18 <ddarius> You should be able to find more than that with just Common Lisp alone.
19:22:25 <dons> Nafai: if you had ocaml or say, scheme, a haskell place might let you pick it up as you go
19:22:28 <bitwize> anyway, putting FP experience into practice is a smidge difficult when you are using Python 2.1
19:22:40 <bitwize> though admittedly much less so than if using say, C or Java
19:22:49 <geezusfreeek> python is better for it than most procedural/OO languages
19:23:20 <haskell_noob> dumb q: what's an easy way for me to figure out what the $ operator does? Its hard to google $ ....its used in the wikibook exercise solution without introduction
19:23:28 <ddarius> @src ($)
19:23:29 <lambdabot> f $ x = f x
19:23:31 <coffeemug> ddarius: you'd have to significantly broaden the search then
19:23:33 <Nafai> dons: I have Common Lisp experience, but not recently and that's about it :/
19:23:37 <geezusfreeek> @type ($)
19:23:39 <lambdabot> forall a b. (a -> b) -> a -> b
19:23:46 <LoganCapaldo> it does nothing!
19:23:50 <ddarius> @. djinn type ($)
19:23:52 <lambdabot> f a = a
19:23:54 <coffeemug> many CL jobs are for government/military contractors
19:23:56 <coffeemug> I don't want to do that
19:23:58 <LoganCapaldo> it's space with different precedence
19:24:03 <LoganCapaldo> :)
19:24:06 <coffeemug> many require PhDs
19:24:09 <coffeemug> I don't have that (yet)
19:24:13 <coffeemug> etc. etc.
19:24:18 <Randroid> haskell_noob: It's a convenience used to dispense with parentheses in some situations. x (a + b) could be x $ a + b
19:24:27 <dons> so yeah, it helps if you want to do high assurance stuff, or finance stuff, and have a phd
19:24:28 <bitwize> there's always ITA
19:24:33 <Nafai> coffeemug: Already doing that, but Java at a contractor
19:24:39 <bitwize> THEY'RE STILL HIRING :) :)
19:24:39 <dons> but you get paid well, that's the upside :)
19:24:39 <haskell_noob> thank you!
19:24:42 <Randroid> haskell_noob: np
19:25:11 <ddarius> @pl ($)
19:25:12 <lambdabot> id
19:25:13 <coffeemug> yeah, I was considering ITA
19:25:15 <Randroid> haskell_noob: Be careful with $, though. It isn't syntactic sugar. It's an actual operator, with precedence.
19:25:19 <coffeemug> but they seem to be more into C++ than Lisp
19:25:27 <coffeemug> looks like they're transitioning away from Lisp
19:25:59 <Randroid> haskell_noob: The last time I used $ incorrectly, my girlfriend left me and then my dog died. Use with caution.
19:26:02 <haskell_noob> are the @src @type etc above irc commands or something else? i'm using ghci at the moment and know " :t "
19:26:13 <LoganCapaldo> @botsnack
19:26:14 <lambdabot> :)
19:26:22 <LoganCapaldo> @where lambdabot
19:26:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:26:35 <LoganCapaldo> something else in other words
19:26:36 <haskell_noob> my gf and dog are getting on my nerves anyway but i appreciate the warning
19:26:43 <Randroid> :)
19:26:52 <LoganCapaldo> it's everybodies favorite irc bot, lambdabot
19:27:00 <haskell_noob> @src($)
19:27:00 <lambdabot> Unknown command, try @list
19:27:05 <LoganCapaldo> space
19:27:11 <haskell_noob> @ src ($)
19:27:16 <LoganCapaldo> not there :)
19:27:22 <LoganCapaldo> @src ($)
19:27:24 <lambdabot> f $ x = f x
19:27:37 <haskell_noob> thanks
19:27:42 <LoganCapaldo> the parens belong to the $, not the command
19:27:49 <geezusfreeek> haskell_noob, just in case you didn't catch it, the $ is in parens because it's an operator
19:27:54 <haskell_noob> oh i get it, indicating operator
19:28:03 <haskell_noob> thanks
19:28:22 <haskell_noob> is there a ghci equivalent to @src
19:28:38 <geezusfreeek> haskell_noob, there is a lambdabot plugin for ghci :)
19:29:19 <haskell_noob> thanks geezus i'll look for that
19:29:25 <haskell_noob> ty everyone
19:30:33 <Randroid> @src (.)
19:30:33 <lambdabot> (.) f g x = f (g x)
19:31:04 <Randroid> $ always makes me think of .
19:31:20 <Randroid> Just like Britney always makes me think of Kevin.
19:31:28 <FMota> :o
19:31:38 <FMota> I think . and $ are counter intuitive.
19:31:42 <FMota> *counter-intuitive
19:32:07 <Randroid> Britney and Kevin are counter-intuitive as well. Seriously, though, in what way are they counter-intuitive?
19:32:15 <Randroid> . and $
19:32:26 <FMota> . for composition is kinda sketchy. Should be a non-filled circle.
19:32:32 <FMota> and $... wtf?
19:32:46 <bitwize> http://bitwize.deviantart.com/art/Daria-What-s-in-a-Name-52426655
19:32:47 <lambdabot> Title: Daria: What's in a Name by ~bitwize on deviantART
19:32:48 <Randroid> You mean that the symbols themselves are counter-intuitive, not their  functionality?
19:32:52 <dons> well, in ascii. . is close to the right thing
19:33:01 <dons> though now we've unicode, you can go nuts with good symbols
19:33:02 <Randroid> The problem is typography.
19:33:07 <FMota> the symbols are counter intuitive, yes
19:33:11 <chessguy> it becomes a lot more intuitive once you've seen it a few times
19:33:20 <FMota> in Sei, I'm using . as concatenation. I prefer that.
19:33:26 <Randroid> Sei?
19:33:28 <Caelum> we just need unicode keyboards :)
19:33:34 <Lemmih> FMota: We're working on it: http://darcs.haskell.org/~lemmih/HideUnicodeOk.png (:
19:33:34 <chessguy> @go sei
19:33:36 <lambdabot> http://www.sei.cmu.edu/
19:33:37 <lambdabot> Title: Software Engineering Institute | Carnegie Mellon
19:33:44 <Randroid> Ah.
19:33:45 <sorear> @go FMota Sei
19:33:47 <lambdabot> http://programming.reddit.com/user/fmota/
19:33:47 <lambdabot> Title: overview by fmota (on programming.reddit.com)
19:33:50 <SamB_XP_> Caelum: what about that ISO that sorear is always talking of...
19:33:52 <FMota> :o lol.
19:34:08 <FMota> havent made a post about that in a while.
19:34:57 <FMota>  @go does google? nice.
19:35:34 <ddarius> @google does google
19:35:35 <lambdabot> http://www.google.com/newsletter/librarian/librarian_2005_12/article1.html
19:35:35 <lambdabot> Title: Google Librarian Central - Article 12/2005 - 1
19:35:54 <Olathe> > (\f -> f 3) (\x -> x + 2)
19:35:59 <lambdabot>  5
19:36:07 <chessguy> i can't make heads or tails of how to test this code http://www.haskell.org/haskellwiki/Principal_variation_search
19:36:08 <lambdabot> Title: Principal variation search - HaskellWiki
19:36:15 <chessguy> anybody have any suggestions?
19:40:01 <chessguy> i've added type annotations to everything to try to sort it out
19:40:30 <chessguy> maybe i need to order everything by types
19:41:24 <chessguy> @pl b x = Node x []
19:41:24 <lambdabot> b = flip Node []
19:41:46 <geezusfreeek> is my understanding of -fallow-undecidable-instances correct that if ghc is able to compile the program then there is no safety lost by using it?
19:42:08 <sorear> right,
19:42:10 <sorear> .
19:42:23 <geezusfreeek> okay good, thanks
19:43:00 <SamB_XP_> just don't complain if GHC takes forever to compile your program
19:43:02 <SamB_XP_> literally
19:43:10 <geezusfreeek> right :)
19:44:21 <SamB_XP_> (say, because you implemented a turing machine in the type system using fundeps along with it ;-)
19:47:33 <monochrom> I think it aborts at a finite point.
19:47:35 <ddarius> -fallow-undecidable-instances doesn't effect the soundness of the type system.
19:48:08 <chessguy> a finite point?
19:48:18 <chessguy> as opposed to an infinite point?
19:48:39 <monochrom> right, as opposed to an infinite point
19:48:46 <chessguy> naturally...
19:49:05 <monochrom> You can try asking what you really mean to ask.
19:49:44 <ddarius> What if he can't try, monochrom?  Did you ever think about that?  Gosh, some people are so insensitive.
19:49:46 <chessguy> i wasn't really paying attention to the conversation, the phrase just struck me as odd. what's a finite point?
19:50:03 <chessguy> @slap ddarius
19:50:03 * lambdabot slaps ddarius
19:50:11 <chessguy> insensitive clod
19:50:19 <ddarius> I am American.
19:50:24 <monochrom> I am Sorry.
19:51:05 <chessguy> monochrom, reading the scrollback, did you mean "after a finite number of steps"?
19:51:11 <monochrom> Yes.
19:51:18 <chessguy> ah, that makes more sense
19:51:49 <chessguy> sorry, my brain is a bit melted at the moment
19:51:58 <monochrom> mine too
19:52:10 <ddarius> Oo, melted brains over brocolli sounds good.
19:52:20 <chessguy> worked 14 hours today, plus in the middle of sorting out some ugly PVS code
19:52:41 <monochrom> how could PVS code be ugly, hmm...
19:52:56 <chessguy> oh, this is nasty stuff.
19:53:03 <chessguy> http://www.haskell.org/haskellwiki/Principal_variation_search
19:53:05 <lambdabot> Title: Principal variation search - HaskellWiki
19:53:28 <monochrom> I only know that proof trees automatically produced by PVS are ugly. Someone is pulling a prank on "formal proofs".
19:53:53 <chessguy> i haven't even really looked at the actual searching code yet. i'm still trying to figure out what the author was doing with the multitude of tests
19:54:00 <monochrom> OH! Not the theorem prover.
19:54:17 <chessguy> ah, conflicting acronyms?
19:54:22 <monochrom> Yes.
19:54:32 <chessguy> what does your PVS stand for?
19:54:39 <monochrom> A theorem prover.
19:55:11 <chessguy> strange acronym. i would have expected ATP
19:55:33 <ddarius> That's taken by adenosine triphosphate or whatever.
19:55:48 <monochrom> Yeah, I've got ATP in my muscle. :)
19:55:50 <chessguy> LOL
19:56:01 <chessguy> that was way funnier than it should have been. i need sleep :)
19:56:25 <monochrom> Wait till you meet ADP = automatic design program
19:56:49 <chessguy> are they like ADFs in genetic programming?
20:00:58 <chessguy> geez, even this negamax code is nasty
20:01:24 <ddarius> @google Haskell negamax
20:01:27 <lambdabot> http://ircarchive.info/haskell/2007/3/27/8.html
20:01:27 <lambdabot> Title: haskell But for English, it's really nice. seems to do OK with spanish too Proba ...
20:01:38 <chessguy> nice title
20:04:11 <dons> xmonad 0.3 is out!
20:04:29 <dons> http://www.haskell.org/pipermail/xmonad/2007-September/001999.html
20:04:31 <lambdabot> Title: [Xmonad] ANNOUNCE: xmonad 0.3, http://tinyurl.com/2fae7u
20:04:44 <dons> huh, 2k messages .
20:05:16 <ddarius> From that we deduce that there are an even number of messages.
20:07:29 <geezusfreeek> ooh
20:07:58 * geezusfreeek checks to see if he is using the xmonad ebuild or the xmonad-darcs ebuild
20:08:38 <geezusfreeek> yay, xmonad-darcs!
20:08:51 <dons> cool. so you don't have to wait for the tarball to be ported
20:09:05 <fxr> xmonad rocks
20:09:32 <dons> I reckon so :)
20:11:18 <dons> xmonad is such nice software, inside and out. it makes me feel good about coding :)
20:11:37 <ddarius> dons is getting xmonad warm fuzzies
20:12:17 <dons> yeah. sometimes i hate it. when people send ugly patches. but then when all those QuickChecks run, i feel good again about it
20:12:25 <dons> the strange emotional life of code
20:12:27 <fxr> Thank you dons, I'll talk about xmonad on inet-tr'07 conference. I think It's a very nice and solid example for haskell programming.
20:12:43 <dons> fxr: oh, cool. let me know if you need slides or anything like that.
20:12:53 <dons> i'm doing a demo of xmonad as a talk for the haskell workshop in october
20:13:00 <dons> so there'll be some slides available
20:13:17 <dons> there's plenty of material on the website too, of course
20:13:28 <ddarius> Slide after slide of big empty boxes.
20:13:43 <dons> heh
20:14:04 <dons> tiled without gaps or overlap
20:14:13 <fxr> dons: great, if possible, we'll give a haskell programming introductory course in the conference.
20:14:48 <dons> ah, that's really cool. you should lean on the community to help put together the best course you can.
20:15:00 <dons> you might be able to reuse spj's oscon tutorial notes
20:15:15 <dons> heh, someone already updated the wikipedia page.
20:15:25 <fxr> yeah I watched the talk
20:15:39 <fxr> spj is fast talkable man :)
20:16:03 <dons> he's great to watch
20:16:35 <ddarius> Indeed.
20:17:13 <ddarius> The STM talk with Tim Harris is hilarious to watch.  He's so eager and with Tim there as a near perfect foil.
20:18:41 <dons> oh, that's a nice idea. a straight man for spj to bounce off.
20:18:43 <dons> yeah, that's cool.
20:21:22 <dons> http://programming.reddit.com/info/2lv7v/comments
20:21:23 <lambdabot> Title: More details on Kinetic: the new Haskell kernel (reddit.com)
20:22:14 <fxr> uh, I got 404 object not found
20:22:51 <LoganCapaldo> you would
20:22:52 <dons> works for me.
20:23:08 <dons> forwards to http://intoverflow.wordpress.com/2007/09/04/kinetic-greetings-redditors/
20:23:11 <lambdabot> Title: Kinetic: Greetings, Redditors « Integer Overflow, http://tinyurl.com/24bhby
20:25:52 <fxr> got it
20:30:30 <Tac-Tics2> What does the | mean in the statement?
20:30:30 <Tac-Tics2> class (Monoid w, Monad m) => MonadWriter w m | m -> w where
20:30:36 <dons> http://programming.reddit.com/info/2lvaq/comments :)
20:30:37 <lambdabot> Title: xmonad 0.3: a tiling window manager in Haskell: now with floating layers and imp ...
20:31:22 <mauke> Tac-Tics2: http://haskell.org/haskellwiki/Functional_dependencies
20:31:23 <lambdabot> Title: Functional dependencies - HaskellWiki
20:31:27 <ddarius> Tac-Tics2: It means everything to its right is functional dependency stuff.
20:32:00 <thoughtpolice> dons: doubleplusgood
20:32:09 <Tac-Tics2> thanks
20:32:10 <sorear> dons++ xmonad 0.3
20:32:28 <thoughtpolice> dons: also I seemed to be having some sort of issue with xmonad 0.2 on my linux box although it seemed to work fine previously... openbox is puttering along fine though.
20:32:41 <dons> ok. i'd try upgrading to 0.3
20:32:53 <dons> a reasonable number of instabilities in X were rectified.
20:33:07 <thoughtpolice> cool.
20:33:35 <dons> 0.3 should be quite a stable branch, I suspect.
20:34:10 <sorear> Just FTR, it's Simon Peyton-Jones, not Simon Peyton Jones.  (His middle initial is L)
20:35:03 <fxr> Tac-Tics2: by the way http://www.cse.unsw.edu.au/~chak/papers/SSPC07.html is giving examples of functional dependencies If I remember correctly
20:35:04 <lambdabot> Title: Research Papers of Manuel Chakravarty
20:36:15 <dons> sorear: yes, that's right. though some of his papers leave off the -
20:36:21 <dons> i did get that wrong though, I think
20:37:31 <ddarius> Simon Lester Peyton Jones
20:38:47 <sorear> ty
20:57:05 <chessguy> wow. it's interesting going back through all of my old pastes on hpaste
20:57:39 <chessguy> i've come a long way, even if i've done so very slowly :)
20:57:52 <chessguy> and kicking and screaming, sometimes
20:59:05 <chessguy> on that note...
21:10:51 * allbery_b is waiting for someone to add -fmzero to ghc :)
21:11:00 <glguy> Hi NiTM
21:11:12 <wli> allbery_b: What's that supposed to do?
21:11:23 <allbery_b> make Cale happy :)
21:11:44 <Cale> heh
21:11:45 <wli> allbery_b: That's rather vague.
21:12:15 <allbery_b> (do notation requires MonadZero; fmap = map; list syntax becomes more generic MonadPlus syntax, including monad comprehensions)
21:12:27 <Cale> Presumably it changes the translation for do-notation such that it uses mzero to handle the failing case of failable patterns.
21:12:48 <wli> Haskell 1.4
21:12:54 <Cale> Exactly :)
21:12:59 <allbery_b> maybe make separate -fmzero and -fmplus or something
21:13:28 <sorear> how about just -fcale-happy?
21:13:34 <allbery_b> akaHaskell before the committee became afraid of polymorphism
21:13:52 <wli> What happened between 1.3 and 1.4?
21:15:46 <dons> haskell when we still thought we were scheme, and not C++ ;)
21:16:46 <allbery_b> -fno-training-wheels-dammit
21:17:15 <Cale> I totally think that if the list syntax is generalised, we need another defaulting mechanism for it though.
21:17:40 <allbery_b> I'd think the existing mechanism could be extended
21:17:43 <wli> Well, I ask about 1.3 vs. 1.4 since if we're going back in time to undo past mistakes we might as well go back all the way.
21:18:24 <allbery_b> perhaps not every change to the language was a mistake
21:18:37 <allbery_b> if we're going to assert that. just bring back Gofer :)
21:18:40 <Cale> I didn't notice mistakes between 1.3 and 1.4. I have seen Preludes which included permutations and combinations functions though, and I think those should at least be in Data.List
21:18:58 <wli> I'm not saying anything of that sort.
21:19:13 <wli> And most of this is essentially base libraries and compiler intrinsics.
21:21:46 <chadz> how do you get text.xhtml to generate closing '>'s that are on the same line?
21:22:58 <glguy> There are three methods that return a String, did you find them?
21:23:05 <glguy> prettyHtml, showHtml , renderHtml
21:23:07 <glguy> or something like that
21:23:17 <glguy> one of them should do what you want
21:23:58 <dons> yeah, pretty is the prettiest
21:24:02 <dons> render is minimal space, iirc
21:24:38 <chadz> dons: correct.
21:24:42 <chadz> just tried all three
21:25:02 <chadz> render is a oneliner, pretty is normal, and show is just messed up
21:35:02 <elliottt> anyone have time for an api design question?
21:35:43 <dons> elliottt: just shoot.
21:35:48 <Lemon> yes.
21:35:52 <dons> if someone's alert, they might feel up to it :)
21:36:06 <elliottt> ok.  so i'm working on a monadic irc client library
21:36:09 <dibblego> ?djinn (a, b, c) -> (a, b)
21:36:09 <lambdabot> f (a, b, _) = (a, b)
21:36:28 <elliottt> and i wanted to compose StateT with my IRC monad, to yield a Bot monad
21:36:50 <dons> yep.
21:36:52 <elliottt> the problem that i'm having now is that i can't use any IRC actions within the Bot monad
21:37:01 <elliottt> (i was using the fancy newtype deriving for the Bot)
21:37:07 <dons> so you want to define lift for your IRC monad?
21:37:13 <dons> i guess its a wrapped IO type?
21:37:16 <elliottt> yes
21:37:22 <sorear> elliottt: just use 'lift'
21:37:24 <wli> A bot doesn't really sound like the right thing to base a monad around...
21:37:36 <dons> you might need to write MonadTrans or something
21:37:39 <elliottt> wli: yeah?
21:37:42 <dons> wli, sure it is.
21:37:48 <dons> you store you network details in state
21:37:55 <dons> and limit IO to approved irc ops
21:37:56 <elliottt> dons: i was trying to derive MonadTrans, but that was giving me sassy errors :)
21:38:10 <allbery_b> @paste it
21:38:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:38:18 <dons> elliottt: you've got the irc bot tutorial at hand, i guess?
21:38:24 <elliottt> i do :)
21:38:24 <wli> Well, I can see various sorts of actions but not necessarily a bot per se.
21:38:29 <elliottt> i started from a bit of a different angle
21:38:35 <elliottt> mostly just wanting to write an irc parser
21:38:37 <dons> yeah, so that's a nice step actually, define your own IRC monad, restrict actions, then layer
21:38:56 <elliottt> but it seemed like it made more sense to write a general irc monad on top of the parser that i had written, once i started working with it
21:38:59 <dons> so that means you need MonadTrans for IRC. :) (or derive it with newtype deriving)
21:39:05 <elliottt> ah, ok
21:39:10 <elliottt> that's the problem then
21:39:14 <dons> sorear: see http://programming.reddit.com/info/2lvpm/comments ?
21:39:14 <lambdabot> Title: hint: embed a Haskell interpreter in your program (reddit.com)
21:39:30 <elliottt> i'd changed Bot to being: type Bot s a = StateT s IRC a
21:39:32 <elliottt> and that worked
21:39:37 <elliottt> but it gives really gross errors
21:39:45 <dons> yeah, you might want to newtype that
21:39:50 <elliottt> yeah
21:40:04 <mudge> newtypes
21:40:04 <elliottt> i'll add the MonadTrans derivation to IRC, and see what that does
21:40:05 <elliottt> thanks :)
21:40:06 <dons> we have
21:40:07 <dons> newtype X a = X (ReaderT XConf (StateT XState IO) a)
21:40:07 <dons>     deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf)
21:40:15 <dons> in xmonad. which is more than you need, but gives you the flavour
21:40:26 <dons> so the MonadIO gives us liftIO
21:40:46 <dons> which might be enough for you
21:40:52 <elliottt> yes, i've currently got Monad, MonadIO and MonadReader for the IRC monad
21:40:59 <dons> tyype jigsaw puzzles
21:41:06 <elliottt> hehe :)
21:41:11 <dons> ok. so then you can liftIO IRC actoins
21:41:17 * glguy kicks dons to bed
21:41:18 <elliottt> yeah
21:41:21 <elliottt> hehe
21:41:25 <dons> ah, i was going to bed. thanks glguy :)
21:41:33 <elliottt> well, i'll bother you another time then :)
21:41:40 <elliottt> thanks for the help!
21:41:48 <dons> night :)
21:47:02 <chadz> anyone have any little cgi/xhtml snippets they'd like to share? :)
21:48:21 <Heffalump> I have several, but they're not very interesting..
21:54:36 <chadz> Heffalump: well, i'm just interested in general style. i've never read or coded much web application jazz.
21:55:19 <chadz> like right now, i'm curious if you could pass command line opts to a cgi file
21:55:41 <chadz> like, index.cgi?hello
21:56:02 <Binkley> chadz: sure, the CGI program "sees" them as environment variables
21:56:06 <Binkley> that's what CGI is about
22:03:21 <takamura> hi
22:05:42 <Heffalump> chadz: it's more normal to do that as name/value pairs, e.g. index.cgi?mode=hello
22:05:49 <Heffalump> are you using any particular library?
22:07:39 <chadz> Heffalump: Text.XHtm, Network.CGI
22:07:43 <chadz> i've almost got it :)
22:08:12 <elliottt> is it even possible to derive MonadTrans?
22:09:02 <Heffalump> there's some fairly clear examples with Network.CGI
22:09:11 <Heffalump> you just use getInput to get hold of parameters
22:09:56 <chadz> i'm using getVar, i'm just doing something incorrectly
22:10:30 <FMota> hmm
22:10:45 <FMota> any haskell ddities tutorial?
22:10:48 <FMota> *oddities
22:11:10 <mudge> thanks I was going ask what a ddities was
22:11:48 <allbery_b> Haskell ditties?>  not sure I want to know :)
22:12:08 <FMota> lol.
22:12:20 <dons> there once was a man with a lambda
22:12:23 <FMota> so, any Haskell oddities tutorial?
22:12:25 <dons> doh, that's hard to rhyme with
22:12:44 <FMota> "he had a lamb, duh"
22:13:02 <dons> there once was a man with a monad
22:13:12 <dolio> No good can come from that.
22:13:13 <dons> oh, that's not going to end well
22:13:26 <FMota> oh no it wont
22:13:36 <FMota> I can only think of one thing to rhyme with monad :/
22:14:31 <FMota> there once was a man named Haskell
22:14:37 <FMota> ...that's not easy either
22:14:41 <chadz> hmm, with the url "../index.cgi?page=index", getVar "page", always returns Nothing
22:14:57 <dons> who was a bit of a rascal
22:15:17 <Tac-Tics2> There once was a man named H. Currey
22:15:17 <Tac-Tics2> Whose language was ..... something something... fury?:
22:17:15 <FMota> There once was a man named Curry
22:17:26 <FMota> He liked to eat curry.
22:17:34 <FMota> His curry was of lamb, duh
22:17:42 <FMota> so he used some lambda(s)
22:17:45 <glguy> Haskell Curry died before they named Haskell the programming language
22:17:45 <FMota> and ...
22:17:54 <FMota> orly? :)
22:18:17 <glguy> yarly
22:18:22 <Tac-Tics2> No they didn't. Curry still lives. Inside the Haskell 98 Report
22:18:24 <Lemon> nowai!
22:19:08 <wli> What goes on at FPL user group meetings anyway?
22:19:22 <FMota> so... we have to make a functional limerick now.
22:19:31 <Lemon> recursive limerick.
22:19:35 <Lemon> hmm
22:19:40 <FMota> xd
22:19:48 <FMota> I suppose it could be an actual function
22:19:52 <FMota> but that's be difficult
22:20:23 <wli> FMota: Write a Haskell program to search for them?
22:21:01 <FMota> not proficient enough in Haskell to do that.
22:22:51 <elliottt> how does the ? kind differ from * ?
22:23:11 <dolio> ? includes unboxed somethings.
22:23:32 <dolio> I forget which is which, though.
22:23:32 <elliottt> ah, thank you :)
22:23:38 <Lemon> ? is a operator/keyword/reserved something?
22:23:56 <elliottt> i was just confused by the result of :k (->)
22:24:02 <dolio> # is unboxed types, * is boxed types, and (#) is unboxed tuples.
22:24:04 <chadz> is there a methodology for parsing QUERY_STRING with network.cgi?
22:24:22 <dolio> Either ? or ?? is the union of * and #, and the other is the union of ? and (#)
22:24:33 <dolio> Or something like that.
22:24:37 <chadz> it mentions getInput is more useful, i'll try that...
22:24:39 <elliottt> that makes sense
22:24:42 <elliottt> thanks :)
22:24:49 <dolio> And then there's !, but I don't know where that fits, or what it is. :)
22:25:05 <elliottt> huh.  what sort of thing produces a !?
22:25:12 <elliottt> these questions are getting hard to ask :)
22:25:17 <dolio> @kind MutableByteArray#
22:25:19 <lambdabot>     Not in scope: type constructor or class `MutableByteArray#'
22:25:29 <chadz> ah, getInput does read from QueryString
22:26:05 <dolio> @kind GHC.Prim.MutableByteArray#
22:26:07 <lambdabot> * -> !
22:34:50 <mudge> is the do notation just sytactic sugar for >>=   ?
22:35:00 <dolio> Yes.
22:35:18 <mudge> cool, thanks
22:35:38 <dolio> More or less. If you do pattern matching, the sugar inserts calls to 'fail', too.
22:36:02 <glguy> and if uses >> if you don't use the result
22:37:20 <FMota> Haskell's cryptic form
22:37:20 <FMota> is natural to some folks,
22:37:20 <FMota> and so is Haiku's.
22:37:44 <glguy> Haiku needs to deal with a season
22:37:50 <glguy> otherwise it has some other name
22:37:53 <FMota> coding season?
22:37:54 <mudge> what is the name of the >> operator?
22:38:17 <mudge> ooh coding season, i like that
22:38:20 <mudge> when't coding season?
22:38:40 <FMota> everyday that isn't non-coding season
22:38:41 <glguy> mudge: "sequence" ? "then" ?
22:38:45 <elliottt> mudge: still bind.  anonymous bind?
22:39:02 <elliottt> sequence does make more sense
22:39:06 <mudge> glgug:  i thought >>= was the sequence operator
22:39:22 <mudge> what's the difference between >>= and >>
22:39:26 <Tac-Tics2> @info Writer
22:39:27 <lambdabot> (Writer)
22:39:29 <Tac-Tics2> ugg
22:39:39 <elliottt> >> is >>= throwing away its argument
22:39:40 <Tac-Tics2> Why can't GHC find Control.Monad.Writer for me?
22:39:49 <shachaf> That gets corrected to @undo, I think.
22:39:53 <shachaf> Tac-Tics2: Install mtl?
22:40:00 <shachaf> @where mtl
22:40:01 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
22:40:01 <Tac-Tics2> mtl?
22:40:14 <shachaf> Not that.
22:40:24 <glguy> Tac-Tics2: what linux distro do you use?
22:40:29 <Tac-Tics2> Ubuntu
22:40:37 <shachaf> sudo apt-get install libghc6-mtl-dev
22:40:58 <mudge> @remember I like big butts and I can not lie
22:40:58 <lambdabot> Done.
22:41:08 <dolio> @quote I
22:41:08 <lambdabot> I says: like big butts and I can not lie
22:41:20 <FMota> :o
22:41:32 <mudge> @quote I
22:41:32 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
22:41:38 <mudge> @quote
22:41:38 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
22:41:53 <dolio> Well, that's bad.
22:41:59 <mudge> @remember I
22:41:59 <lambdabot> Incorrect arguments to quote
22:42:12 <FMota> @remember FMota Haskell's cryptic form \n is natural to some folks \n and so is Haiku's
22:42:12 <lambdabot> Done.
22:42:13 <mudge> @remember mudge I like big butts and can not lie
22:42:13 <lambdabot> Done.
22:42:16 <FMota> ;)
22:42:27 <mudge> @quote mudge
22:42:27 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
22:42:40 <mudge> well it was a strong quote
22:42:46 <allbery_b> fwiw, the convention when single-lining such things is to use / as the separator
22:42:49 <FMota> you broke it :/
22:42:58 <FMota> hmm
22:42:58 <allbery_b> I think quotes were broken anyway
22:43:00 <Binkley> ?quote
22:43:00 <lambdabot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
22:43:04 <Binkley> :-(
22:43:34 <allbery_b> if I understood backscroll from a few days back correctly, sorear managed to reproduce the @quote / @forget breakage I reported to him some time back
22:43:59 <allbery_b> and it's still affecting the bot (as it did me, something wrong with the serialized version of the quote db I think)
22:44:33 <allbery_b> the quotes are there and will be updated correctly but can't be retrieved for ome reason
22:45:08 <sorear> allbery_b: It broke immediately after @forget, so serialization is not involved.
22:45:37 <dons> oh, that weirdo rand item bug!
22:45:45 <dons> sorear: remember that from many moons ago?
22:45:53 <sorear> nope.
22:45:57 <dons> i think i even wrote down a solution for it, or an explanation, once upon a time
22:46:08 <allbery_b> whatever it is gets serialized in such a way that it stays broken on quit/reload, whatever
22:46:31 <mudge> i think it was my strong sentence
22:46:34 <mudge> powerful
22:46:45 <wli> Some kind of lockfile left hanging around?
22:47:30 <allbery_b> (and yes, I've been spweing bot bugs at both of you since bringing up a lambdabot over in cognet:#lopsa :)
22:48:20 <mudge> lambdabot has a stomachache
22:49:20 * OceanSpray gives lambdabot a belly rub
22:49:32 <dolio> @vixen
22:49:32 <lambdabot> Plugin `vixen' failed with: IRCRaised getRandItem: empty list
22:49:49 <dolio> Didn't work. :)
22:49:56 <dons> ?quit
22:50:22 <dons> ?quote
22:50:24 <mudge> @remember mudge
22:50:29 <lambdabot> ChrisKuklewicz says: Are there little known Haskell idioms for doing math? Is there an undocumented -funleash-fortran parameter?
22:50:35 <lambdabot> Incorrect arguments to quote
22:50:37 <mudge> @quote mudge
22:50:45 <lambdabot> mudge says: I like big butts and can not lie
22:50:50 <mudge> yep
22:50:56 <dons> sorear: you got time to poke around the random util module, to see if there's some comment in there on this thing?
22:51:01 <dons> running out of randoms is a bit spookey lukey
22:51:26 <dons> night all.
22:51:28 * dons departs
22:51:32 <mudge> @quote
22:51:32 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexidecimal.
22:51:37 <mudge> @quote dons
22:51:38 <lambdabot> dons says: but let is more lazy ;)
22:51:46 <dolio> @quote JonHarrop
22:51:46 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
22:51:47 <mudge> later dons
22:51:54 <sorear> dons: no, I think it's perfectly obvious
22:52:06 <sorear> dons: you can't pick a random item from an empty list
22:52:16 <sorear> dons: the problem is in its caller
22:52:17 <allbery_b> I didn't see such a comment when I was poking around in there a few days ago (looking for a generic random number wrapper) and don't see one now
22:52:19 <mudge> @quote sorear
22:52:19 <lambdabot> sorear says: -f flags are so 2006
22:52:25 <allbery_b> in Lib/Util.hs
22:52:30 <tehgeekmeister> do all the terms of a list defined in terms of itself (for example, the fibonacci sequence) remain in memory, or do the unused ones get garbage collected?
22:52:33 <dons> sorear: yeah, that's it. losing the state somewhere/somehow.
22:52:51 <tehgeekmeister> when grabbing the nth item, that is
22:53:13 <FMota> tehgeekmeister: only the ones that are needded are actualyl calculated (as far as I can tell)
22:53:14 <sorear> dons: allbery_b suggested that the problem may be the existance of an undocumented invarient [] `notElem` keys map
22:53:19 <sorear> s/keys/values/
22:53:25 <FMota> and the rest is disposed of eventually
22:53:42 <FMota> (i.e., the ones that were needed temporarily)
22:53:52 <tehgeekmeister> FMota: all are needed, the issue is how quickly they're disposed off
22:54:10 <FMota> all? surely not.
22:54:16 <dolio> It sort of depends on whether there's a pointer to the beginning of the list (or, whatever) still in scope.
22:54:21 <tehgeekmeister> all less than n, i mean.
22:54:26 <FMota> ;)
22:54:33 <FMota> ask others.
22:54:38 <allbery_b> yeh when I triggered it it left an empty user in the state, and when I deleted that manualy it started working again
22:54:54 <allbery_b> (butthen it broke later without that case, IIRC, so I retracted it)
22:55:25 <tehgeekmeister> dolio: so if the list is defined in the current scope, all values, once computed, will be stored?
22:55:26 <wli> tehgeekmeister: It can often be deforested down to just 2 numbers.
22:55:42 <tehgeekmeister> wli: w00t!  that's exciting.
22:55:57 <allbery_b> what does "the list is defined" mean?
22:56:02 <dolio> In, say, '(fibs !! 1000000) + (fibs !! 1)', it will, probably, build a 1000000 element list that stays around until 'fibs !! 1' is evaluated, at which point it can garbage collect.
22:56:12 <allbery_b> keep in mind that a list can be "defined" without its elements being "defined"
22:56:27 <allbery_b> yeh
22:56:47 <cizra> \o/ â™¡Fibonacciâ™¥
22:56:59 <dolio> Although, further, if 'fibs' is a top-level name, it probably won't ever be collected.
22:57:12 <Binkley> > fix (:â™¥)
22:57:13 <lambdabot>  Illegal character ''\153''
22:57:13 <monochrom> â™¡lazyâ™¥
22:57:31 <tehgeekmeister> well, a simple example of the type of lists i'm thinking of is: triangulars = 1 : zipWith (+) triangulars [2..]
22:57:32 <cizra> Binkley: What does fix do?
22:57:44 <Binkley> cizra: finds the fixed point of a function :-)
22:57:51 <Binkley> > fix (:"lol")
22:57:52 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
22:57:54 <cizra> eh..? What's that?
22:58:05 <Binkley> > fix (:'z')
22:58:05 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
22:58:10 <Binkley> this isn't my night
22:58:11 <Binkley> ah
22:58:15 <monochrom> 'z' :
22:58:15 <Binkley> > fix ('z':)
22:58:16 <lambdabot>  "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
22:58:21 <tehgeekmeister> oh, so the issue is where the list is defined?  not the form of the list itself?
22:58:24 <psykotic> > let x = 'z' : x in x
22:58:25 <lambdabot>  "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
22:58:28 <monochrom> fix ( ++ "lol" )
22:58:36 <monochrom> err, "lol" ++
22:58:51 <wli> dolio: I think top-level bits get collected all-or-nothing; the whole list has to be dead at which time the whole thing is collected.
22:58:53 <Binkley> cizra: if you have a function f, a fixed point x is a value such that f x = x
22:58:59 <cizra> Aha
22:59:09 <chadz> :t fix
22:59:11 <lambdabot> forall a. (a -> a) -> a
22:59:17 <monochrom> fix ('z' :)  means the same as  let x = 'z':x in x.  It generalizes well to arbitrary fix f.
22:59:34 <cizra> OK
22:59:46 <cizra> Sounds pretty pointless..
22:59:52 <monochrom> All recursions can be written as fix, and vice versa.
23:00:27 <Tac-Tics2> Gah, it is very frustrating that 99% of Haskell is experimental
23:00:31 <shachaf> cizra: Indeed, that's one of its uses. :-)
23:00:44 <monochrom> I do this all the time.  do { x <- blah; fix (\self -> do { putStrLn stuff; self }); whatever }
23:00:48 <glguy> Tac-Tics2: like many people, you are having trouble with statistics ;)
23:01:01 <cizra> shachaf: Being pointless?
23:01:07 <shachaf> How about "forever self"?
23:01:22 <shachaf> "forever (putStrLn stuff)", I mean?
23:01:28 <shachaf> cizra: Yes.
23:01:40 <FMota> gah
23:01:43 <shachaf> @pl f x = x + f x
23:01:43 <Tac-Tics2> glguy: that doesn't really ease the frustration much
23:01:43 <lambdabot> f = fix (ap (+))
23:01:47 <FMota> I have an Ada quiz tomorrow
23:01:51 <FMota> this is not a high point.
23:02:01 <Tac-Tics2> is there any standard documentation on Writer and Reader?
23:02:03 <dolio> wli: Well, top-level (monomorphic) CAFs are typically memoized over the whole program in GHC. That's why you can use them for memoizing dynamic programming, for instance.
23:02:16 <Tac-Tics2> the haskell.org documentation on those modules are.... like blank
23:02:18 <FMota> g'night guys (/ gals)
23:02:35 <monochrom> How about fix (\self -> if x==0 then return () else (fix \me -> if x==1 then me else self))
23:02:38 <dolio> wli: Maybe it collects them sometimes, though. I don't really know.
23:02:57 <monochrom> You can't easily express that with forever.
23:02:58 * FMota is going to bed with "Programming and Problem Solving with ADA 95" tonight.
23:03:05 <FMota> in fact, right now
23:03:47 <glguy> Tac-Tics2: what are you trying to figure out about those two?
23:03:57 <glguy> Tac-Tics2: (I don't know a good tutorial off hand)
23:04:29 <monochrom> xmonad contains lots of uses of fix in the similar fashion as I have described, i.e., to express arbitrary imperative loops.
23:05:27 <Tac-Tics2> I'm getting lose in all the abstraction. There's Writer. There's MonadWriter. I'm trying to understand what the instances of MonadWriter are doing. I got caught up in functional depenencies earlier.
23:05:49 <Tac-Tics2> ^^^ lost* not lose
23:06:09 <monochrom> If you use functions, you will eventually find anonymous functions useful. If you use recursions, you will eventually find anonymous recursions useful. I can't see how that's pointless. You have to say functions and recursions are pointless to justify lambda and fix pointless.
23:06:27 <monochrom> Or you have to be immature.
23:06:40 <shachaf> You should understand Writer before looking at MonadWriter.
23:06:44 <allbery_b> Reader is read-only state with local bindings
23:06:47 <glguy> Tac-Tics2: MonadWriter is a class that has functions that make a writer
23:06:58 <glguy> Writer is basic implementation of that functionality
23:07:02 <shachaf> Just pretend there was no type class at first.
23:07:28 <shachaf> Then reimplement Writer, and try to generalize it into a type class.
23:07:28 <quicksilver> david benbennick?
23:07:54 <quicksilver> "for example you can define filter :: (MonadPlus m) => (a -> Bool) -> m a -> m a"
23:07:57 <quicksilver> I don't see how
23:08:57 <quicksilver> I see how you could define that *if* you had your monadic value l defined explicitly as x1 `mplus` x2 `mplus` x3 `mplus` ...
23:09:07 <quicksilver> but MonadPlus doesn't give you that
23:09:14 <quicksilver> you can't "deconstruct" an msum
23:09:18 <quicksilver> (can you?)
23:09:22 <wli> mplus used to be ++
23:09:36 <shachaf> Not mappend?
23:09:45 <wli> Not mappend.
23:10:05 <shachaf> Wouldn't mappend make more sense as (++)?
23:10:05 <quicksilver> indeed, I see the analogy with ++
23:10:15 <quicksilver> shachaf: well lists happen to also be a monad
23:10:28 <quicksilver> mplus is like mappend if you're a monad as well as a monoid
23:10:32 <quicksilver> basiaclly
23:10:38 <glguy> ?type let filter f xs = xs >>= \ x -> if f x then return x else mzero in filter
23:10:44 <shachaf> So why depend on being a monad?
23:10:47 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
23:11:01 <quicksilver> glguy: Oh, clever.
23:11:04 <quicksilver> glguy: Thanks.
23:11:07 <monochrom> > (\p m -> do { x <- m; guard (p x); return x }) (even) [3,1,4,1,5,9,2,6,5,3]
23:11:09 <lambdabot>  [4,2,6]
23:11:17 <quicksilver> shachaf: so you can do what glguy just did :)
23:11:24 <monochrom> Apparently, you only need MonadZero.
23:11:35 <quicksilver> so you can use >>= to access the "elements" of your monad
23:11:41 <shachaf> monochrom: Yes, that's just a list comprehension.
23:11:44 <shachaf> s/list/monad/
23:11:48 <monochrom> Here is what happens. >>= deconstructs the list.
23:11:56 * quicksilver nods
23:11:59 <quicksilver> I understand now
23:12:01 <quicksilver> nice
23:12:19 <monochrom> >>= also reconstructs the answers into a list.
23:12:27 <wli> (>>=) = flip concatMap
23:12:44 <shachaf> (>>=) = flip joinFmap -- :-)
23:12:50 <monochrom> Afterall, the "map" part deconstructs, and the "concat" part reconstructs. It's very beautiful.
23:12:57 <glguy> ?type \ f xs -> join ( liftM ( \ x -> if f x then return x else mzero ) xs
23:12:59 <lambdabot> parse error (possibly incorrect indentation)
23:13:10 <glguy> ?type \ f xs -> join ( liftM ( \ x -> if f x then return x else mzero ) xs )
23:13:12 <lambdabot> forall a1 (m :: * -> *). (MonadPlus m) => (a1 -> Bool) -> m a1 -> m a1
23:13:34 <glguy> (I know that those are equivalent, but I'm just playing around ;) )
23:14:10 <wli> join = concat, liftM = map
23:14:12 <shachaf> glguy: Of course they're equivalent. They have the same type. :-)
23:20:26 <quicksilver> but, are there any other interesting MonadPlus'es?
23:20:39 <Naktibalda> labas rytas
23:20:41 <quicksilver> besides Maybe which is just lists-of-length-at-most-one
23:20:46 <Naktibalda> err.., good morning :)
23:21:04 <dolio> There's LogicT.
23:21:16 <dolio> And probably Sequence...
23:21:38 <allbery_b> @instances MonadPlus
23:21:42 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
23:22:20 <dolio> Oh yeah, and anything wrapped around lists, of course. :)
23:22:24 <dolio> Parsers.
23:22:53 <quicksilver> @src IO mplus
23:22:54 <lambdabot> m `mplus` n = m `catch` \_ -> n
23:23:03 <quicksilver> hmm
23:23:41 <dolio> Sets and bags and such, if we ever get the right machinery.
23:23:46 <quicksilver> so filter on IO a would keep going through your "catch" possibilities until it found one which satisfied the predicate
23:24:28 <dolio> @src IO mzero
23:24:29 <lambdabot> mzero       = ioError (userError "mzero")
23:24:40 <dolio> That's the relevant entry.
23:24:42 <glguy> filter on IO wouldn't do lists
23:25:04 <glguy> it would return an IO action that returns a value that fulfills a predicate
23:25:10 <glguy> or an IOException
23:25:19 <glguy> (or am I not reading enough of the backlog)
23:27:00 <dibblego> why doesn't ?src ever work?
23:27:06 <dibblego> ?src ($!)
23:27:06 <lambdabot> Source not found. Take a stress pill and think things over.
23:27:08 <dibblego> ?src seq
23:27:09 <lambdabot> Source not found. stty: unknown mode: doofus
23:27:17 <glguy> right... ?src seq
23:27:20 <glguy> seq is primative
23:27:37 <oerjan> ?src $!
23:27:37 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:27:40 <dibblego> right, so what about $!?
23:27:45 <dibblego> ?src ($)
23:27:45 <lambdabot> f $ x = f x
23:27:52 <glguy> dibblego: dons manually adds them
23:28:00 <dibblego> ok
23:28:06 <oerjan> f $ x = x `seq` f x
23:28:10 <glguy> since the version in the source isn't always useful for teaching
23:28:14 <oerjan> er, f $! x = x `seq` f x
23:28:33 <dibblego> ?type seq
23:28:35 <lambdabot> forall a t. a -> t -> t
23:28:36 <dolio> 'seq _ y = y' is the definition in the base library.
23:28:40 <FMotAFK>   hey oerjan
23:28:40 <Tac-Tics2> Would it be erronous to define MonadPlus as
23:28:40 <Tac-Tics2> instance (Monad m, Monoid m) => MonadPlus where
23:28:40 <Tac-Tics2>     mzero = mempty
23:28:40 <Tac-Tics2>     mplus = mappend
23:28:47 <FMotAFK> your V interpreter is amazing!
23:28:48 <dolio> The magic is in the compiler.
23:28:48 <oerjan> hi FMotAFK
23:28:53 <oerjan> thanks :)
23:29:06 <FMotAFK> I have no idea how it works, but the amazingness seeps through the code :)
23:29:55 <dolio> Tac-Tics2: You'd need something more like: '(Monad m, Monoid (m a)) =>'
23:30:30 <fax> Hiya
23:31:06 <quicksilver> glguy: yes, I was wrong
23:31:13 <quicksilver> dolio: plus a naturality condition
23:31:14 <cizra> Of course, if a GHC compiled program runs slower than the same program compiled with NHC or Hugs, then it's definitely a bug. -- haha
23:31:21 <quicksilver> dolio: that the monad is compatible with the monoid
23:31:38 <quicksilver> glguy: filter is really just guard
23:31:57 <Tac-Tics2> dolio: is that because "List" isn't a monoid, but "List of a" is?
23:32:10 <dolio> Tac-Tics2: Right.
23:32:23 <Tac-Tics2> would that be legal Haskell code then?
23:32:47 <Tac-Tics2> or would ghc wine about some weird type restraint I don't understand =-P
23:33:25 <glguy> quicksilver: guard + return
23:33:34 <dolio> It'd probably whine about overlapping instances.
23:33:48 <Tac-Tics2> well yeah that
23:33:50 <Tac-Tics2> coolness
23:34:45 <fax> Is there some kind of haskell self-test around, so one can check if they actually know what's going on (or how much)?
23:34:51 <dolio> As quicksilver says, there's no guarantee that the Monoid instance will satisfy all the laws MonadPlus operations are supposed to.
23:35:20 <allbery_b> fax: not per se although I understand some people test it by solving Project Euler problems in Haskell
23:36:56 <Tac-Tics2> fax: I don't know, but that would be cool to see
23:37:56 <fax> I was thinking of a little command line program which generates questions about the language and then gives you a score
23:38:10 <Tac-Tics2> What laws does MonadPlus require that Monoid does not?
23:38:11 <oerjan> FMotAFK: well the main trick is to represent the infinite V tree in such a way that all the operations become local changes of the data structure.
23:38:24 <Tac-Tics2> oh
23:38:24 <Tac-Tics2> hmm
23:38:36 <quicksilver> glguy: interestingly, the list instances is "more than" a bare MonadPlus
23:38:41 <FMotAFK> hm
23:38:53 <FMotAFK> I dont really get the UpTree and DownTree thing.
23:38:59 <quicksilver> glguy: we have (filter p m) `mplus` (filter p l) == filter p (m `mplus` l)
23:39:12 <FMotAFK> I'm sure that, with more time, and with some of your time, I can grok it.
23:39:18 <FMotAFK> but ... not now :|
23:39:21 <quicksilver> glguy: which is, kind of, the defining characteristic of what I think filter means
23:39:21 <oerjan> FMotAFK: it's really a sort of zipper, if you have heard about those
23:39:30 <FMotAFK> it's way too late :)
23:39:33 <FMotAFK> nope
23:39:38 <FMotAFK> anyway, nightie night
23:39:39 <quicksilver> glguy: but the other MoandPlus instances (IO) don't satisfy that
23:39:45 <Tac-Tics2> MonadPlus has two operators to deal with? mplus and >>= which it treats like addition and multiplication....
23:39:47 <FMotAFK> and thank you for implementing the silly language :)
23:39:48 <Tac-Tics2> hmm
23:40:05 <quicksilver> Tac-Tics2: >>= is something like "iteration"
23:40:13 <dolio> Tac-Tics2: mplus and mzero are supposed to behave a certain way in combination with (>>=) and return.
23:40:13 <quicksilver> Tac-Tics2: (if you use the list analogy)
23:40:15 <oerjan> you're welcome :)
23:40:58 <dolio> It's probalby possible to come up with monoids that don't satisfy them.
23:41:10 <quicksilver> the key law which specifies how they related is that mzero is not only a zero for your monoid but also for your monad
23:41:14 <dolio> I think there are even instances where existing MonadPluses don't, though.
23:41:29 <quicksilver> dolio: sure, just pick a stupid monoid structure :)
23:41:45 <quicksilver> dolio: there are an infinity of daft monoids on [a] along with the sensible one
23:42:16 <dolio> Yeah.
23:42:21 <quicksilver> for example, symmettric difference is a monoid, IIRC
23:42:24 <allbery_b> "daft monoid" sounds like the name of an alternative rock band
23:42:26 <quicksilver> with identity []
23:42:32 <FMotAFK> metric rocks.... and ciao
23:42:44 <dolio> In fact, one example is the fair choice from LogicT.
23:42:49 <quicksilver> allbery_b: Good idea. I'm in. I'll play the drums.
23:43:09 * allbery_b hasn't played any instrument in years
23:43:10 <dolio> That's why Oleg made it a separate operator (presumably) instead of just making mplus use it.
23:43:27 <dolio> At least, that's the only reason I can come up with.
23:43:30 <quicksilver> I wasn't aware that ability to play was any barrier to forming an alternative rock band.
23:43:37 <allbery_b> could probably re-pick up trumpet and trombone pretty quickly :)
23:43:54 <allbery_b> I also can't sing like that, I have a real singing voice and prefer to keep it that way :>
23:44:06 <vincenz> Hello peeps
23:44:37 * allbery_b keeps wanting to pick up a sax and re-learn it but suspects neighbors would lynch him
23:45:06 <Kahdloc> lynching is fun for the whole family! i'm sure it'd turn out fine.
23:45:23 <Kahdloc> <.< that was a joke.
23:45:24 <oerjan> @users
23:45:24 <lambdabot> Maximum users seen in #haskell: 402, currently: 361 (89.8%), active: 12 (3.3%)
23:45:31 <oerjan> yoohoo
23:45:55 <cizra> lambdabot: count me too
23:45:56 <cizra> @users
23:45:57 <lambdabot> Maximum users seen in #haskell: 402, currently: 362 (90.0%), active: 12 (3.3%)
