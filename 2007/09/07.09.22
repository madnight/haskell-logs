00:29:17 <scodil> anyone here use claus reinke's vim mode for haskell?
00:52:28 <glguy> ?seen dons
00:52:28 <lambdabot> I saw dons leaving #xmonad and #haskell 56m 37s ago, and .
00:57:52 <arcatan> what's that and .
02:21:25 <adaptable> !seen notsmack
02:21:59 <ari> @bot
02:21:59 <lambdabot> :)
02:22:36 <adaptable> @seen notsmack
02:22:37 <lambdabot> I saw notsmack leaving #haskell 2h 27m 38s ago, and .
02:25:10 <augustss> @botsnack
02:25:10 <lambdabot> :)
02:49:28 <ndm> does anyone know any real projects using SYB?
02:49:32 <ndm> other than perhaps Happs
02:49:54 <Soliah> @help
02:49:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:50:04 <Soliah> @help list
02:50:04 <lambdabot> list [module|command]
02:50:04 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:52:44 <KatieHuber> hmm, is it generally known that one shouldn't use Apple's "Shark" profiler to profile GHC-compiled apps?
02:52:58 <KatieHuber> it appears to die horribly after using a few GB of RAM
02:53:10 <ndm> KatieHuber: GHC has lots of provided profiling stuff, i very much doubt the general ones will do as well
02:53:47 <KatieHuber> I wasn't sure if I'd get anything useful out of shark, but it's zero-impact, which is great
02:53:54 <Cale> Shark is pretty cool for really low-level code though.
02:54:08 <KatieHuber> stuff like gprof for C is useless because it affects the performance of the profiled code so much
02:54:19 <ndm> the GHC profiler is pretty good
02:54:31 <ndm> and in some cases it even speeds up the execution :)
02:54:40 <Cale> ndm: really?
02:54:48 <KatieHuber> well that's scarcely desirable :p
02:54:57 <ndm> Cale: really, Catch goes ~25% faster with profiling turned on
02:54:57 <Cale> I've never seen that :)
02:55:06 <ndm> although that is totally not meant to happen
02:55:15 <Cale> Have you found out why?
02:55:19 <ndm> nope
02:55:31 <ndm> the program is too big, and i didn't have the time
02:55:45 <ndm> the paper I submitted to ICFP had "programs compiled with -O2 and profiling turned on"
02:56:49 <dolio> Does it only go faster when profiling is enabled, or is it just compiling with profiling that does it?
02:56:54 <ndm> i'm pretty sure -O2 was doing some optimisation that was a big loss, but that profiling inbhibited it
02:56:59 <KatieHuber> ooh, shark may finish... progress bar's at the end and it's only up to 2.6GB...
02:57:03 <ndm> dolio: compiling with profiling
02:57:45 <KatieHuber> hmr, still rising :/
02:59:59 <ndm> why not just use GHC's profiler?
03:02:16 <KatieHuber> just intrigued to see what it'll give
03:02:56 <KatieHuber> lots of tiny functions that look like they should've been inlined using approximately equal percentages of the runtime :|
03:06:42 <KatieHuber> apparently the most expensive function in my program (according to GHC profiling) is
03:06:43 <KatieHuber> hands = map reverse . inits
03:07:20 <KatieHuber> the lists it's run on are never long (max 18 elements)
03:07:51 <pjd> that looks like a lot of copying
03:08:04 <KatieHuber> I then filter that list a couple of times
03:08:08 <pjd> how about tails . reverse ?
03:08:20 <pjd> or something along those lines
03:08:37 <dolio> @check \l -> (reverse . tails . reverse) (l :: [I]) == (map reverse . inits) l
03:08:42 <lambdabot>  OK, passed 500 tests.
03:09:11 <KatieHuber> where is tails ?
03:09:16 <dolio> Same place as inits.
03:09:35 <Saizan> how do i tell cabal to not pass -O to ghc? Ghc-options: -O0 doesn't seem to work
03:10:07 <dolio> @src inits
03:10:07 <lambdabot> inits []     =  [[]]
03:10:07 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
03:10:39 <ndm> @hoogle tails
03:10:39 <lambdabot> List.tails :: [a] -> [[a]]
03:10:40 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
03:10:59 <KatieHuber> wow, that's like 10x faster :o
03:11:12 <dolio> Yeah.
03:11:38 <dolio> tails shares lots of stuff in the generated list (all the tails).
03:11:41 <KatieHuber> I don't understand why, but thanks ;)
03:11:50 <KatieHuber> ah, right
03:11:58 <dolio> Whereas inits has to build unique lists.
03:12:09 <dolio> And then you're reversing all of them, which builds them again. :)
03:12:13 <ndm> and reverse is quite expensive
03:12:25 <KatieHuber> I definitely understand that :)
03:12:37 <ndm> its tail strict - probably not an issue for n=18, but as that goes up, reverse gets really bad
03:14:21 <dolio> So, 'reverse . tails . reverse' is O(n) (is that right?) whereas 'map reverse . inits' is O(n^2) in both operations?
03:15:25 <KatieHuber> This is now taking near 50% of the run-time according to the profiler: http://hpaste.org/2847
03:16:24 <ndm> yes, on the first half
03:16:37 <ndm> not sure if inits is O(n^2)
03:16:42 <KatieHuber> dfs on a graph, with a list of visited nodes to avoid infinite recursion
03:17:37 <KatieHuber> the profiler doesn't seem to say if library functions are the expensive bit of it?
03:17:40 <ndm> ((flip Set.notMember) seen) === (`Set.notMember` seen)
03:17:52 <ndm> (Eq a, Ord a) === Ord a (I think)
03:18:21 <scook0> n^2 for inits sounds right, since you need to replicate the spine for each endpoint
03:18:30 <scook0> whereas tails can just cdr down the list
03:18:35 <ndm> i suspect that might just be an expensive operation
03:18:50 <ndm> unless you can find a faster dfs algorithm
03:19:01 <augustss> inits must be O(n^2), since it produces unique lists with O(n^2) elements
03:19:45 <KatieHuber> maybe if I didn't filter the kids, but checked them if they came off the fringe...
03:20:25 <ndm> KatieHuber: why are you using a sequence rather than a list for the kids?
03:20:41 <KatieHuber> not sure any more ^_^
03:21:18 <KatieHuber> I'm using it as a stack, so I shouldn't have a problem
03:21:35 <augustss> A list is more efficient.  Much
03:21:37 <KatieHuber> the intent was to try out breadth-first search too, where a list might be problematic, but I didn't go there
03:21:46 <ndm> yeah, if you used a list it would be less overhead, simpler and you could do direct pattern matching, so shorter as well
03:23:14 <ndm> breadth-first search is usually much more expensive, certainly in memory terms
03:23:18 <augustss> KatieHuber: and as you say, checking when you pop things off could be a win
03:24:03 <ndm> won't that be roughly the same, just changing the time of the test
03:24:18 <augustss> sure, but one less traversal
03:24:19 <ndm> and possibly not even changing the time of the test, with laziness
03:24:33 <ndm> true
03:24:51 <augustss> but perhaps ghc can fuse the filter and the (++) anyway
03:24:51 <ndm> i always tend to do the test after popping off, but thats more because it makes the code shorter
03:25:13 <ndm> is filter fusable?
03:25:23 <KatieHuber> well, just switching to a list made dfs go away by the looks...
03:25:34 <KatieHuber> ... actually maybe I broke the code :p
03:25:38 <augustss> I could certainly fuse the filter and (++) by hand
03:25:51 <ndm> oh, it can
03:25:57 <ndm> it is both a producer and a consumer
03:27:25 <cognominal_> @src map
03:27:26 <lambdabot> map _ []     = []
03:27:26 <lambdabot> map f (x:xs) = f x : map f xs
03:30:02 <KatieHuber> huh, my code was actually a breadth-first search by the looks :|
03:30:03 <KatieHuber> doh
03:31:24 <KatieHuber> and in that case, list is way less efficient than sequence by the looks
03:31:52 <ndm> sure? you only seemed to be adding to the front and popping from the front
03:32:21 <ndm> i guess it depends on the cost of the adding to the front, if sequence can go faster than ++ and the kids are largish
03:32:23 <KatieHuber> isn't e <| es a push to the front and the viewr a pop from the back?
03:32:54 <ndm> no idea, not used Data.Sequence
03:33:25 <KatieHuber> certainly when I made the depth-first version with lists it doesn't behave anything like the original code
03:33:40 <KatieHuber> and when I made the breadth-first version, it behaves like the original code, only like a million times slower
03:34:27 <augustss> KatieHuber: if you want bfs you can use more efficient queues that Data.Squence
03:34:42 <KatieHuber> Data.Queue said to use Data.Sequence...
03:36:14 <augustss> OK, I was just guessthing.  But the queues implemented with two lists are very hard to beat.  But maybe Data.Sequence does
03:36:19 <iguana_> hi, does anybody have a pointer how to parse an indentation-aware language like python with parsec?
03:36:45 <ndm> Data.Queue is depreciated (if not entirely removed)
03:37:01 <Heffalump> I thought Data.Sequence was about 10-12 times slower than lists
03:37:15 <Heffalump> or perhaps a bit better since it's specialised - but Ross said that finger trees are about 10-12 times slower than lists
03:38:09 <augustss> The double list implementation of queues costs 2 cons operations per enqueue
03:38:29 <augustss> well, a little more, but 2 cons is the allocation cost
03:46:15 <KatieHuber> what are the con2tag_*# functions?
03:47:00 <ndm> KatieHuber: constructor to tag, they are internal functions - they should be cheap, look at the caller of them
03:47:33 <KatieHuber> they are very cheap, just being executed a few hundred million times
03:47:37 <KatieHuber> which adds up :)
03:47:51 <KatieHuber> not nearly as expensive as that search function
03:48:19 <ndm> look at the caller of them
03:48:22 <KatieHuber> I made the double-list Queue thing and it seems slower than the Data.Sequence implementation
03:48:35 <KatieHuber> they've been inlined so I don't know who the caller is
03:52:32 <KatieHuber> ... and the unoptimized version doesn't dump profiling info if it's ctrl-c'd
03:53:32 <ndm> really?
03:53:41 <KatieHuber> really :)
03:53:42 <ndm> i think it should, and i think it does on windows
03:53:50 <ndm> you have to hit Ctrl+C then wait
03:53:51 <KatieHuber> I'm on Mac OS X
03:53:58 <ndm> if you hit Ctrl+C twice it aborts straight away
03:54:04 <KatieHuber> only hit it once
03:57:03 <KatieHuber> oh, doh, me being stupid
03:57:40 <augustss> My simple queue test show that Data.Sequence is 4 times slower than the double list.
03:58:44 <KatieHuber> huh, even without -O it looks like those con2tag_*# things are in something that's been inlined :|
04:02:11 <KatieHuber> OK that's wacky... my two-list Queue bfs is much more expensive at -O2 than without optimization :|
04:02:12 <augustss> So Data.Sequence is faster than the double list if the queue is very short (1 element).  it slows down with more elements.  The double list remains about constant.
04:06:24 <KatieHuber> this is my current implementation: http://hpaste.org/2847#a2
04:08:50 <augustss> you can make a better enqueueMany by using (++)
04:09:12 <augustss> save constructing a lot of Queues
04:32:25 <EvilTerran> what about using section composition on the (++)s as well? ;)
04:34:09 * EvilTerran hasn't read all the scrollback, but isn't it SOP to use something akin to the first version thre (ie with Sequences) for queues?
04:40:26 <KatieHuber> SOP?
04:41:22 <EvilTerran> "standard operating procedure"
04:42:59 <KatieHuber> ah
04:43:30 <KatieHuber> if they are (as augustss appears to have proven to himself) slower than sequences, why would it be :P
04:46:16 <infrared> hello, i have problem installing X11 binding from hackage
04:46:26 <infrared> i do "runghc Setup.lhs configure" and it says:
04:46:32 <infrared> "<no location info>: can't find file: Setup.lhs"
04:47:14 <infrared> any idea how can i find/generate this Setup.lhs?
04:47:51 <mrd> try Setup.hs
04:48:21 <infrared> oh shit
04:48:29 <infrared> sorry :)
04:49:02 <infrared> xmonad has Setup.lhs so I just pasted the same command when building X11
04:50:46 <kyevan> Mmm, I wonder if I could teach haskell to work in base 25...
04:51:04 <kyevan> (Yes, I am playing Riven right now. What of it?)
04:51:27 <infrared> btw, what's the difference between .hs and .lhs?
04:52:57 <Heffalump> .lhs is a "literate" haskell file
04:53:08 <Heffalump> the code is on lines starting with "> " and everything else is a comment
04:53:27 <Heffalump> the ">" are known as Bird tracks (I guess cos Richard Bird invented them)
04:54:03 <augustss> KatieHuber: What I have proven (to myself) is that sequences are slower that the double list queues, no the other way around.
04:54:26 <KatieHuber> er, yes, that's what I meant to say :)
04:55:06 <infrared> Heffalump: good for making documentation with examples
04:55:22 <EvilTerran> @hoogle showIntAtBase
04:55:23 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
04:55:25 <Heffalump> and writing papers and articles and things
04:55:28 <EvilTerran> kyevan, ^^
04:55:39 <Heffalump> I'm not generally that keen on them though
04:56:11 <KatieHuber> I keep needing this function: \f g t a -> t (f a) (g a)
04:56:24 <KatieHuber> it looks like the kind of thing that should be in Control.Arrow but I don't see it there
04:56:39 <augustss> It's almost S'
04:56:39 <Heffalump> @pl \f g t a -> t (f a) (g a)
04:56:39 <lambdabot> flip . (ap .) . flip (.)
04:56:45 <Heffalump> @pl \t f g a -> t (f a) (g a)
04:56:45 <lambdabot> liftM2
04:57:03 <KatieHuber> ooh
04:57:24 <Heffalump> hmm. Well, it's right, but I think using the (a ->) Monad instance gratuitously is a little obfuscated.
04:57:35 <EvilTerran> > showIntAtBase 25 ((['0'..'9']++['A'..'Z'])!!) 12345 ""
04:57:36 <lambdabot>  "JIK"
04:57:55 <ari> Heffalump: What? That would imply that @pl isn't perfect :(
04:58:25 <Heffalump> it's not intended to produce code that's good style, which is anyway a matter of debate
04:58:32 <augustss> actually, @pl has a lot of bugs, but that's not one of them
04:59:12 <ari> @pl "("
04:59:13 <lambdabot> "("
05:00:09 <Heffalump> @pl \x -> "foo" ++ x
05:00:09 <lambdabot> ("foo" ++)
05:00:20 <Heffalump> @pl \x -> 'f':'o':x
05:00:20 <lambdabot> ("fo" ++)
05:02:59 <kyevan> Woosles > Heffalumps
05:03:37 <augustss> > "Woosles" > "Heffalumps"
05:03:39 <lambdabot>  True
05:04:04 <EvilTerran> > "pirates" > "ninjas"
05:04:05 <lambdabot>  True
05:05:08 <kyevan> > "pirates" > "TWO ninjas"
05:05:10 <lambdabot>  True
05:05:30 <kyevan> I think lambdabot is broken >_>
05:05:37 <EvilTerran> > 'p' > 'T'
05:05:38 <lambdabot>  True
05:05:40 <EvilTerran> > 'p' > 't'
05:05:41 <lambdabot>  False
05:06:00 <kyevan> > "Pirates" > "TWO Ninjas"
05:06:02 <lambdabot>  False
05:06:10 <kyevan> There we go, I fixed her :P
06:36:26 <Ben`> how can I convert a number from base 10 to base 2?
06:37:02 <Botje> you could do it manually with div and mod
06:37:28 <Ben`> ok
06:37:43 <Botje> or you could check the code in ... I think Data.Char
06:38:25 <xerox> Numeric.showIntAtBase
06:38:37 <Ben`> thanks
06:38:40 <Botje> oh, that
06:38:40 <Botje> :p
06:39:19 <Botje> *sigh*
06:41:44 <Baughn> :t showIntAtBase
06:41:49 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
06:42:32 * Baughn would have expected Integral -> Integral -> String
06:44:04 <xerox> > showIntAtBase 2 intToDigit 1023
06:44:05 <SamB> Baughn: but that wouldn't work for base64, now would it?
06:44:07 <lambdabot>  <[Char] -> [Char]>
06:44:16 <xerox> hehe, add "" :)
06:44:33 <Baughn> SamB: Neither does showIntAtBase. What, exactly, is the /point/ of that function?
06:44:37 <xerox> SamB: yup it would
06:44:38 <SamB> @type showString
06:44:40 <lambdabot> String -> String -> String
06:44:43 <SamB> Baughn: doesn't it?
06:44:47 <igel> > showIntAtBase 2 intToDigit 1023 "test"
06:44:49 <lambdabot>  "1111111111test"
06:44:51 <xerox> Ah, misunderstood.
06:44:53 <Baughn> SamB: I don't see how it could
06:44:57 <xerox> showIntAtBase would.
06:45:10 <Baughn> SamB: Base64 requires that a single int becomes /multiple/ chars
06:45:15 <SamB> Baughn: oh.
06:45:22 <SamB> how come?
06:45:39 <Baughn> Mapping 8-bit ints to 6-bit chars?
06:46:13 <Baughn> That's true for pretty much all mappings, granted, base64 is just a bit unusual. Even so..
06:46:18 <SamB> what, it doesn't map the whole file to an arbitrary-precision integer first?
06:46:34 * Baughn sweatdrops
06:46:55 <Baughn> You'd need a lazy int type. Unary list, maybe.
06:47:09 <Baughn> ...though that's not lazy in the right way
06:47:20 <SamB> How about a little-endian lazy bytestring based representation?
06:47:57 <Baughn> That could work
06:48:26 <SamB> or I could just say "how about base 64 instead"
06:48:54 <Baughn> Anyway.. how /is/ showIntAtBase supposed to work?
06:48:55 <ari> :t showIntAtBase
06:48:57 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
06:49:10 <olsner> I thought base64 did something like take three bytes as a 24-bit integer, then write that number in base 64
06:49:31 <Baughn> olsner: Base64 doesn't do that. Base64 implementations might do that.
06:49:33 <SamB> you pass it: the base, a function that converts the digit's value to the digit itself, and the number
06:49:38 <int-e> > showIntAtBase 15 intToDigit 202871 ""
06:49:39 <SamB> it returns a ShowS
06:49:40 <lambdabot>  "4019b"
06:50:03 <Baughn> SamB: I see. Still doesn't work with base64, though since the "digits" need to span three bytes.
06:50:09 <Baughn> s/three/four/
06:50:14 <SamB> eh?
06:50:24 <SamB> whatever
06:50:55 <Baughn> Wouldn't it be nice to have an 8-bit clean URL syntax?
06:51:18 <SamB> clean in what sense?
06:51:29 <Baughn> In the sense that no conversion would be needed
06:51:46 <Baughn> Instead of escaping things, just prepend the length of the url
06:51:59 <Baughn> ..url fragment, rathr
06:52:14 <mauke> 2-byte big endian length?
06:52:17 <SamB> how do you type those in?
06:52:21 <Baughn> I suppose that wouldn't be human-readable, though. Not that /sdfhj?34689=%23&asd=asd is particularily readable.
06:52:32 <Baughn> SamB: "type"?
06:52:41 <SamB> at least the way it works now SOME urls are human readable and even manually enterable
06:52:57 <Baughn> Only properly DRMed applications should be able to enter URLs
06:53:02 <SamB> hah
06:53:25 <Janni> Hello. I hope, someone is here (and active) who has some knowledge about YHC(-Core) internals. I'm working on a YHC-core backend but at a point I am stuck. Running a simple test application (main = putChar 'C') fails, but as far as I see the error is in the YHC-Core libraries, at least I don't understand how it is supposed to work. I hand-executed the simple program and put what I got on hpaste.org.
06:54:31 <Janni> When you have a look at it, you notice that there is a "top-level evaluation" with one argument missing, and since it's a "top-level evaluation" it doesn't make sense to curry.
06:54:32 <araujo> > let f 0 = [] ; f n = (mod n 2) : f (div n 2) in f 15
06:54:34 <lambdabot>  [1,1,1,1]
06:54:52 <Janni> At least, that's what I think, or there is some kind of crazy currying I don't know about...
06:55:00 <araujo> though it won't take Fractional
06:55:36 <araujo> @pl let f 0 = [] ; f n = (mod n 2) : f (div n 2)
06:55:36 <lambdabot> (line 1, column 45):
06:55:36 <lambdabot> unexpected end of input
06:55:36 <lambdabot> expecting ";" or "in"
06:55:46 <Janni> err, it's the one, posted as (anonymous).
06:55:49 <araujo> @pl f 0 = [] ; f n = (mod n 2) : f (div n 2)
06:55:49 <lambdabot> (line 1, column 10):
06:55:49 <lambdabot> unexpected ";"
06:55:49 <lambdabot> expecting variable, "(", operator or end of input
06:56:33 <ndm> Janni: i wrote Yhc.Core
06:56:40 <mauke> > let f n = (if n `div` 2 > 0 then f (n `div` 2) else []) ++ [n `mod` 2] in f 10
06:56:42 <lambdabot>  [1,0,1,0]
06:56:48 <Janni> ndm: Ah, nice to have you there then :)
06:57:20 <Janni> So, do you understand, what's my problem?
06:57:36 <ndm> Janni: not really, have you managed to create a .ycr file?
06:57:42 <ndm> (or .yca perhaps)
06:57:50 <ndm> talk me through what you've got so far
06:57:54 <Janni> Yes, yes, I'm far beyond that poitn...
06:58:08 <ndm> are you using the latest darcs of Yhc
06:58:11 <Janni> Yes.
06:58:23 <ndm> and have you run "scons libraries", if you started on a release more than a month ago
06:58:36 <Janni> Let's say, I have the .ycr files of the libraries and I have Main.ycr (with "main = putChar 'C')
06:59:04 <ndm> yep
06:59:08 <Janni> So, let's see what we get, when we execute this Main;main by hand... (done on hpaste.org -> (anonymous))
06:59:53 <ndm> oh, are you worried that ioBind requires 3 arguments, but only has two?
06:59:54 <Janni> If you look at line 6 (I suppose I evaluated the previous lines correctly) you notice that Prelude;1791_ioBind is supplied with 2 arguments, though it needs 3.
07:00:02 <ndm> yeah, thats correct
07:00:07 <ndm> main :: IO ()
07:00:11 <Janni> Yep, being evaluated on "top-level"
07:00:24 <ndm> but IO () is actually something like "RealWorld -> _E ()"
07:00:27 * Janni is thinking...
07:00:34 <Janni> Ah, yes, I see....
07:00:36 <ndm> so the way evaluation of main works is by passing a value in at the start
07:00:57 <ndm> I'm not entire sure what the actual value should be - give me a second and I'll look up our IO Monad
07:01:22 <Janni> Ah, yes, I see.... (again)
07:02:08 <Janni> So, that's the only point s.th. (kind of unexpected) like this happens, a missing (implicit) argument?
07:02:28 <ndm> http://darcs.haskell.org/yhc/src/packages/yhc-base-1.0/YHC/Internal.hs
07:02:30 <lambdabot> http://tinyurl.com/ysqvpf
07:02:39 <ndm> no, its not implicit, its just not in the code
07:02:57 <ndm> evaluation of a Haskell program doesn't start with "main", it starts with "main realWorld"
07:03:09 <ndm> data World = World
07:03:11 <ndm> newtype IO a = IO (World -> _E a)
07:03:15 <ndm> thats the definition of IO in Yhc
07:03:19 <Janni> OK. Yes, thats what I meant...
07:03:27 <ndm> so if you just have as your initial expression "main World" it should be fine
07:03:42 <Janni> A yes, thanks, you're very helping...
07:03:52 <ndm> you need the world, otherwise the compiler can optimise out things that don't hold with the IO Monad
07:03:56 <ndm> no problem :)
07:04:01 <ndm> what backend are you writing?
07:04:21 <Janni> Hmm. Let's say, another byte-code language...
07:04:35 <ndm> and if you have further issues and i'm not online then you can always ask on yhc -AT- haskell.org
07:04:44 <ndm> you don't have to say, was just curious :)
07:04:51 <Janni> *noted*
07:05:10 <ndm> i take it you've seen the Yhc.Core Monad Reader article?
07:05:36 <Janni> Or let's rather say, I'm working on the Ultimate Haskell Operating System!!!!!11
07:05:46 <ndm> thats cool ;)
07:05:54 <Janni> No, I didn't, but I'll do it now...
07:06:11 <ndm> and there is also the Uniplate paper, which explains the stuff in Yhc.Core.Uniplate, which may be of benefit if you are doing lots of traversals over Yhc.Core
07:06:18 <ndm> depends on exactly how you are compiling it, really
07:06:39 <ndm> http://www-users.cs.york.ac.uk/~ndm/yhc/ - Yhc.Core - from Haskell to Core
07:06:41 <lambdabot> Title: Neil Mitchell - Yhc
07:06:53 <ndm> http://www-users.cs.york.ac.uk/~ndm/uniplate/ - Uniform Boilerplate and List Processing
07:06:54 <lambdabot> Title: Neil Mitchell - Uniplate
07:07:27 <ndm> the first is very likely to be helpful, since there is an evaluator in the paper. The second might help if you want to do much work with Yhc.Core, or might be one to save for a bit later
07:08:04 <ndm> I think the first also explains the Overlay system, which you are very likely to want as well
07:08:09 <Janni> OK. Thanks. I don't neet the Uniplate stuff, but the first one seems useful....
07:09:38 <Janni> Ah well, no, I guess I'm quite beyond this point...
07:10:02 <ndm> there is a little on the Overlay mechanism in that paper, which might come in handy
07:15:10 <Janni> You did a great work, btw., on YHC(-Core), I guess. But it isn't very well documented. Maybe sometime I will help and improve that situation...
07:16:23 <ndm> what type of documentation do you think is lacking?
07:16:59 <ndm> have you seen http://haskell.org/haskellwiki/Yhc/API/Core
07:17:01 <lambdabot> Title: Yhc/API/Core - HaskellWiki
07:17:39 <ndm> feel free to edit the wiki, or submit patches with haddock documentation - or if anything seems particularly unclear tell me what
07:19:37 <Janni> I will... Maybe the situation has already somewhat improved since the last time I checked, but for example, I was only able to learn the YHC-Core format, by looking at th YHC source code (which is OK for me).
07:20:18 <ndm> the paper is designed to present a basic intro to it
07:21:53 <Janni> OK. Thanks again, so far. I guess it will take some time, until the next problem/question occurs..
07:22:30 <ndm> cool :)
07:22:46 <ndm> am off to Germany on Wednesday for a week and a half, so if you ask in that period you might be in for a bit of a wait
07:26:06 <ddarius> Damn straight most mathematicians prefer blackboards.
07:26:10 <Janni> Ah, where in Germany?
07:26:28 <ddarius> Janni's going to come knocking on your door!
07:26:43 <Janni> If it's not too far, maybe :-)
07:27:32 <ndm> Frieburg
07:27:40 <ndm> where loads of Haskeller's will be
07:27:42 <EvilTerran> what's the thing to run as/in a callback when you want a Graphics.UI.GLUT program to exit?
07:27:58 <EvilTerran> System.Exit.exitWith?
07:28:32 <ndm> Haskell Workshop next Sunday :)
07:28:44 <Janni> That's really near... Maybe I should attend the first Haskell Workshop (or any other event)?
07:28:50 <Janni> (for me)
07:29:11 <ndm> you have to register, and it costs money
07:29:14 <ndm> its an academic thing
07:29:19 <ndm> @google haskell workshop 2007
07:29:20 <lambdabot> http://www.cse.unsw.edu.au/~keller/haskellws/HaskellWorkshop.html
07:29:20 <lambdabot> Title: Haskell Workshop 2007
07:30:33 <igel> damn exams, i wish i had the time to go to freiburg :(
07:57:52 <Ben`> @src ($)
07:57:53 <lambdabot> f $ x = f x
08:00:48 <Ben`> @users
08:00:48 <lambdabot> Maximum users seen in #haskell: 407, currently: 340 (83.5%), active: 4 (1.2%)
08:16:01 <EvilTerran> ... does vanilla GLUT have no way of binding a callback to the closing of a window?
08:17:53 <matthew-_> does it not call resize?
08:31:28 <EvilTerran> hm
08:34:36 <EvilTerran> nope
08:35:25 <EvilTerran> nor does it call visibility
08:35:45 <EvilTerran> there is a "closeCallback :: SettableStateVar (Maybe CloseCallback)", but i get an error saying i need freeGLUT when i try to use it
08:35:59 <EvilTerran> (even though it doesn't say that's the case in the docs)
08:37:56 <EvilTerran> and i'm having trouble finding a FreeGLUT DLL
08:41:48 <mauke> > let f=f in f
08:41:50 <lambdabot>  Exception: <<loop>>
08:41:56 <matthew-_> EvilTerran: oh ok. freeglut is fairly easy to compile I think
08:42:13 <EvilTerran> even on windows?
08:42:35 <matthew-_> oh no idea about that.
08:43:10 <EvilTerran> in my experience, *nothing* is easy to compile on windows
08:43:15 <EvilTerran> and most things are impossible
08:43:18 <matthew-_> and you're using it because?
08:43:27 * EvilTerran sighs
08:43:33 <EvilTerran> because i happen to quite like it
08:43:37 <EvilTerran> because it came with my computer
08:44:00 <zeeeee> i wrote a simple program in haskell and c++, but the c++ runs much faster (program counts # overlapping events, given their start/stop times sorted by start time). how do i make my haskell version (http://hpaste.org/2853) as fast as the c++ version (http://rafb.net/p/CPBgGw78.html)?
08:44:07 <EvilTerran> because i like to be able to play mainstream computer games reliably, without a massive fight with dubious virtualisation or whatever
08:44:11 <EvilTerran> et cetera.
08:44:31 <zeeeee> i tried adding some things like strictness, but that didn't seem to do much. i compile with -O2 in ghc and no optimizations in c++
08:44:40 <EvilTerran> i'm not going to switch over because some things don't work, because just as many things don't work on linux.
08:46:04 <puusorsa> EvilTerran, buy ps3 or whatever for games
08:46:12 <puusorsa> even easier than windows
08:46:23 <zeeeee> there's an algorithmic difference in the overlap detection (taking off a priority queue vs. list partitioning), but the number of overlapping events is small enough that this shouldn't make too much of a difference, yet what i see is a 10x difference
08:46:36 <ndm> zeeeee: strictness only makes things faster in the right place, in the wrong place it makes things slower
08:47:17 <zeeeee> ndm: in one of the places i put it, it seems necessary (for foldl' to not stack-overflow), but i'm not sure where else it would help (in terms of perf)
08:47:18 <augustss> zeeeee: I'd suspect simple things like parsing
08:47:24 <EvilTerran> puusorsa, i'll let you know when i get a knock on the head and decide that a gamepad is a sensible input device for FPSes or RTSes.
08:47:34 <zeeeee> augustss: you mean read?
08:47:42 <ndm> zeeeee: i find the C version much more readable, so its quite possible the Haskell one could look a lot prettier
08:47:48 <augustss> words&read
08:47:59 <ndm> reading an Int in Haskell is quite slow
08:48:06 <ndm> and words is a very badly written function
08:48:17 <EvilTerran> and that 625 lines @ 50 hz is a satisfactory display setup
08:48:20 <zeeeee> words is from bytestring though
08:48:31 <ndm> oh, that one is probably very optimised
08:48:39 <ddarius> EvilTerran: It should be possible to hook some kind of keyboard up.
08:48:53 <zeeeee> (so is read)
08:48:53 <olsner> hmm, is f >>> g === g . f?
08:49:02 <EvilTerran> ddarius, and a mouse?
08:49:05 <augustss> I hate >>>
08:49:07 <ddarius> olsner: Yes and no.
08:49:13 <ndm> i really can't read that arrow code...
08:49:20 <ddarius> EvilTerran: Probably.  I wouldn't really know, but I'd be surprised if it wasn't.
08:49:26 <EvilTerran> and why bother, when I **already have a computer**, thankyouverymuch?
08:49:41 <zeeeee> yeah, here i just use it for composition: f>>>g === g.f
08:49:42 <augustss> zeeeee: read for Double is very slow
08:49:53 <ndm> zeeeee: try profiling, and see what percentage of time is spent in parse
08:50:00 * ddarius owns no gaming systems and probably never will again.
08:50:00 <zeeeee> i like reading (and writing) left to right :)
08:50:11 <ndm> augustss: read for _everything_ is ridiculously slow
08:50:16 <zeeeee> ndm: i was about to do that but now i'm lost on whicih rts option to pass
08:50:20 <augustss> zeeeee: I know read for double is very slow, because I wrote it :)
08:50:28 <zeeeee> augustss: really! :)
08:50:34 <puusorsa> o rly?
08:50:39 <mauke> ya srsly
08:50:41 <zeeeee> no wai
08:50:44 <augustss> but it is correct
08:50:59 <ddarius> @google fast floating point printing
08:51:01 <EvilTerran> anyway, that's completely tangential to the original point, which is that i want to be able to use GLUT on windows, in haskell
08:51:01 <lambdabot> http://citeseer.ist.psu.edu/28233.html
08:51:01 <lambdabot> Title: Printing Floating-Point Numbers Quickly and Accurately - Burger, Dybvig (Researc ...
08:51:05 <ndm> zeeeee: ghc --make Main.hs -prof -auto-all, then main.exe +RTS -p
08:51:09 <augustss> if you don't care about correctness you can make it fast
08:51:12 <mauke> > read "inf" :: Double
08:51:14 <zeeeee> well, i'm not exactly about to embark on a double-parsing adventure...
08:51:20 <matthew-_> EvilTerran: right, and I want to be able to print reliably in Linux ;)
08:51:24 <lambdabot>  Exception: Prelude.read: no parse
08:51:33 * Lycurgus thought correctness was a given in hs
08:51:53 <ddarius> Lycurgus: Highschool?
08:52:07 <Lycurgus> hs <- hassel
08:52:23 <ddarius> What the heck is hassel?
08:52:30 <EvilTerran> it's all rather frustrating, seeing as I've GOT haskell, GLUT, *and* the bindings, and yet it seems to not be working
08:52:32 <ndm> Lycurgus: not at all, there is always a tension between correct and fast
08:52:33 <augustss> > read "Infinity" :: Double
08:52:35 <lambdabot>  Infinity
08:52:35 <Lycurgus> a given though not automatic;especially with quickcheck?
08:52:38 <zeeeee> hah
08:53:29 <ndm> but do profile before assigning blame :)
08:53:29 <ddarius> Lycurgus: To any extent that it's a given, it's due to the nature of the community, not to a tool.
08:53:39 <ddarius> Do blame assigning profiling!
08:54:17 <SamB> ndm: or possibly between general and fast
08:54:21 <Lycurgus> tension, meaning optimization tends in general to corrupt otherwise correct codings?
08:54:26 <olsner> is that "blame-assigning profiling"?
08:54:39 <augustss> ddarius: btw, the Haskell FP printer is Based on the atricle above.  And the reader on the article next to it by Will Clinger.
08:55:13 <zeeeee> why does hpaste.org never remember who i am
08:55:21 <EvilTerran> zeeeee, i get that, too
08:55:36 <ddarius> zeeeee: You have a forgettable face?
08:55:37 <zeeeee> so here are the profiling results: http://hpaste.org/2853#a1
08:55:42 <ddarius> augustss: Not surprising at all.
08:56:23 <zeeeee> indeeed, all the time seems to be going into that parse function
08:56:35 <augustss> The FP reader is slow partly because it's totally generic.
08:57:00 <augustss> A special version for Double could be much faster
08:57:55 <ndm> zeeeee: i think ByteString has a readInt function, which you can use for two of those, and should give a speedup
08:58:27 <zeeeee> i'm not prepared to learn the ieee layout for double :)
08:58:54 <matthew-_> err, it's a fairly simple variant of the layout for float ;)
08:58:54 <geezusfreeek> zeeeee, it's not that hard
08:58:56 <ddarius> zeeeee: They're both pretty simple.
08:59:06 <ddarius> Tedious when you try to cover everything though.
08:59:10 <zeeeee> i'm not even sure how to do such low-level bit manip in haskell
08:59:15 <ddarius> Data.Bits
08:59:22 * ndm remembers duncan saying similar things about the Cabal source code
08:59:24 <geezusfreeek> it's just exponent, mantissa, and sign bit, regardless of whether it's float or double
09:00:08 <ddarius> geezusfreeek: But then you get denormalized encodings and various non-numeric encodings.
09:00:09 <augustss> Use the FFI to call the C version
09:00:32 <ddarius> Is the C version correct?
09:00:38 <zeeeee> geezusfreeek: i thought there was much more to it.... positive zeros, negative zeros, inf, nan, etc.
09:00:43 <augustss> ddarius: dunno
09:00:55 <geezusfreeek> i thought denomalized encoding was against IEEE... and yes, there are special values involved
09:01:01 <zeeeee> at least that's what i've always heard hardware people complain about
09:01:03 <geezusfreeek> *denormalized
09:01:15 <augustss> geezusfreeek: denormalized numbers are ok in IEEE
09:01:16 <zeeeee> "please! prof kahan! stop!"
09:01:18 <SamB> geezusfreeek: denormalized numbers are very important
09:01:30 <SamB> geezusfreeek: otherwise there'd be a huge gap around zero
09:01:45 <augustss> There's a huge gap anyway :)
09:01:53 <matthew-_> SamB: I know parts of Double where there're bigger gaps ;)
09:02:05 <geezusfreeek> i don't even see how you would represent a denormalized number....
09:02:19 <augustss> geezusfreeek: It has a special exponent
09:02:26 <SamB> augustss: at least the gap is the size of the smallest difference between representable numbers this way
09:02:43 <EvilTerran> all bits in the exponent are zero => denormalized
09:02:43 <geezusfreeek> hmm
09:03:00 <geezusfreeek> oh okay, that does make sense i suppose
09:03:24 <EvilTerran> can you tell ghc to dynamic link to a library file with a different name from the default, that does the same thing?
09:04:09 <SamB> zero can't be represented normalized anyway ;-P
09:05:18 <augustss> WOW!  read fo Double is even worse than I thought for GHC.  It goes via Rational
09:05:34 <mauke> > 1e9999
09:05:36 <olsner> augustss: didn't you say that you wrote it?
09:05:39 <lambdabot>  ghc: failed with error code 9
09:05:44 <augustss> And fromRational for double is very, very slow.  I know.  I wrote it.
09:05:46 <mauke> > 1e999
09:05:50 <lambdabot>  Infinity
09:06:22 <augustss> olsner: ghc has switched to readP, which makes the code path somewhat different than my original hbc code
09:06:37 <olsner> ah, okay
09:08:06 <augustss> amazing.  Someone should fix the code for reading Float and Double :)
09:09:12 <augustss> Getting it fast and correct is non-trivial, though.
09:09:22 <ndm> someone should fix words and isSpace as well
09:09:33 <ndm> but when I sent in the fix I got asked for loads of proofs...
09:09:49 <augustss> The trick part is when you get close the smallest and largest numbers
09:10:12 <augustss> ndm: your fixes looked good, i thought
09:10:20 <zeeeee> can look for inspiration in libstdc++
09:10:49 <ndm> augustss: i might file them as a bug against GHC, then hopefully they'll get in
09:13:03 <augustss> ndm: yes, those functions are in base, after all
09:14:00 <augustss> Does C++ have a function that does the same thing as show for Double in Haskell?
09:15:00 <augustss> I.e., prints the number that is the shortest closest decimal number the the rational that the FP number represents.
09:15:34 <mauke> operator<< I guess
09:15:43 <olsner> or snprintf
09:16:06 <olsner> (with the proper set of format flags)
09:16:13 <augustss> mauke: But do those functions make guarantee the conversion I want?
09:16:29 <mauke> no idea
09:17:01 <mauke> snprintf wasn't in C++ last time I looked
09:19:11 <olsner> seems snprintf has quite fuzzy definitions of what is actually printed by the floating-point formats
09:20:43 <augustss> So strtod on MacOS is broken for string-to-double conversion.  It has the same bug as Joe Fasel's Haskell code from 1990.
09:21:21 <mauke> what's that?
09:21:50 <augustss> wait, my test is broken...
09:23:17 <augustss> No, strtod seems to work
09:23:30 <augustss> It should, it's from NetBSD. :)
09:26:17 <augustss> Is there a fast conversion from ByteString to CString?
09:28:42 <augustss> Oh, the MacOS strtod is not from NetBSD.  I wonder why not...
09:30:11 <olsner> I always forget which BSD dialect they used to make OS X
09:31:06 <augustss> olsner: FreeBSD for kernel stuff, NetBSD for most of userland
09:31:15 <olsner> oh, ok
09:31:35 <Saizan> augustss: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html#v%3AuseAsCString
09:31:38 <lambdabot> http://tinyurl.com/y58jn8
09:31:56 <augustss> The C code to convert a string to double is over 2500 lines
09:32:49 <augustss> and contains a bignum implementation
09:32:55 <ddarius> wtf?!
09:33:00 <mauke> haha, oh wow
09:34:10 <augustss> actually, the file I was lookig at seems to do conversion both ways
09:34:24 <augustss> Doing it fast and correct is difficult.
09:37:24 <augustss> Oh, the code is pretty clever.  Using FP instead of bignum when you only want low precision conversion to strings.
09:39:35 * EvilTerran boggles
09:39:52 * EvilTerran fails to see how this could be better than the naive approach
09:39:54 <pejo> augustss, any idea why they mixed BSD's in osx?
09:40:05 <augustss> pejo: nope
09:40:17 <SamB> hmm. this looks wierd...
09:40:20 <olsner> pejo: instead of doing it themselves, I guess
09:40:26 <SamB> data S s a where
09:40:26 <SamB>   Bool :: forall s. Bool -> S s Bool
09:40:43 <SamB> I wonder what the forall is there for :-(
09:40:43 <EvilTerran> (using floating-point arithmetic, with minimal fiddling to avoid loss of precision)
09:41:02 <pejo> olsner, it was the mixing I was curious about, seems odd to use FreeBSD for kernel stuff and then go for NetBSD for userland.
09:41:07 <ddarius> SamB: Either it's a mistake, or they mean what they said.
09:41:15 <SamB> that's GHCi output
09:41:19 <SamB> I never said no forall
09:41:28 <olsner> pejo: oh, yeah, that surprised me too
09:41:42 <augustss> SamB: what's surprising about the forall?
09:41:47 <SamB> hmm.
09:41:50 <SamB> oh, right
09:41:53 <SamB> I get it ;-)
09:42:07 <ddarius> The s and a are irrelevant and presumably GHC just ignores them
09:42:13 <augustss> yep
09:42:21 <augustss> it does
09:42:25 <mauke> data S :: * -> * -> * where { Bool :: Bool -> S s Bool }
09:42:42 <SamB> I'm just forgetful ;-)
09:42:58 <SamB> forgot that GADT heads don't bind type variables
09:43:17 <SamB> unlike typeclass heads
09:43:36 <augustss> EvilTerran: I don't think you can do any reasonable minimum fiddling and make the conversion guarantees that you want
09:43:56 <EvilTerran> bah
09:44:01 <SamB> if they did, I guess we'd need equality constraints ;-)
09:44:05 <Saizan> it would be clearer if didn't accept tyvars at all
09:44:15 <Saizan> +ghc
09:44:35 <EvilTerran> heck, converting to/from decimal strings doesn't even have to be that accurate, does it?
09:44:44 <SamB> EvilTerran: um
09:44:53 <SamB> EvilTerran: yes!
09:45:02 <augustss> EvilTerran: you want to (read . show) to be the identity function
09:45:57 <augustss> And you want the output of show to look nice (i.e., no trailing 0 or 9 unless necessary)
09:46:05 <mauke> > ((read . show) `asTypeOf` id) 1.23456789012345678
09:46:07 <lambdabot>  1.2345678901234567
09:46:14 * SamB wonders about the implementation of:
09:46:16 <SamB>   Var :: forall s a. (Typeable a) => String -> S s a
09:46:53 * EvilTerran thinks... i guess it's possible to write any IEEE float as a finite decimal
09:47:03 <EvilTerran> but it wouldn't be pretty
09:47:46 <augustss> EvilTerran: right, so the one you want is the one with the shortest string representation that when read gives back the same number
09:47:50 <EvilTerran> i'm not convinced read.show has to be the identity. that encourages people to use it inappropriately for serialisation.
09:48:08 <augustss> It would be terrible if it wasn't the identity
09:48:15 <augustss> it would wrong
09:48:25 <EvilTerran> that's a matter of opinion, imo
09:49:15 <ddarius> fix (read . show)
09:49:15 <augustss> No, because that's the expectation that people have.
09:49:20 <EvilTerran> i expect show to produce good human-readable output. expecting it to read in identically as well is asking too much of one function.
09:49:26 <EvilTerran> imo.
09:49:42 <SamB> EvilTerran: that's a lot to expect from something that works on String!
09:49:45 <augustss> EvilTerran: So you wouldn't mind if converting say a list skipped a few elements now and then
09:49:50 <sorear> @check \x -> read (show x) == (x :: Double)
09:49:51 <SamB> the human-readable bit, I mean
09:49:53 <lambdabot>  OK, passed 500 tests.
09:50:09 <ddarius> @scheck \x -> read (show x) == (x :: Double)
09:50:11 <lambdabot>   Completed 79 test(s) without failure.
09:50:40 <augustss> If (read . show) isn't the identity, then what good are they?
09:50:58 <mauke> debugging
09:51:06 <SamB> @check (not . isNaN :: Float -> Bool)
09:51:06 <sorear> mauke: really?
09:51:07 <lambdabot>  OK, passed 500 tests.
09:51:38 <EvilTerran> sorear, for communicating with humans.
09:51:48 <sorear> mauke: if printing a number gives me a slightly wrong answer, is it a bug in my code, or a idiocy in show?
09:51:49 <ddarius> @scheck (not . isNaN :: Double -> Bool)
09:51:50 <lambdabot>   Completed 79 test(s) without failure.
09:51:51 <therp> evilterran: Show is not meant for pretty printing, but to produce Haskell parsable statements
09:52:18 <therp> evilterran: clearly Haskell lacks such a pretty printing facility (in its standard classes)
09:52:37 <mauke> sorear: I don't know (because I don't understand floating point math)
09:53:12 <EvilTerran> therp, is that defined anywhere, or merely the de facto standard?
09:53:21 <sorear> EvilTerran: the Report, iirc
09:53:31 <xerox> there are also comments in Show.hs sources
09:53:41 <Liskni_si> @type asTypeOf
09:53:43 <EvilTerran> http://haskell.org/onlinereport/basic.html#sect6.3.3 <- i don't see it here
09:53:43 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
09:53:43 <lambdabot> forall a. a -> a -> a
09:53:56 <wli> Floating point math is kind of screwy. It's set up around avoiding or working around obscure pathologies.
09:53:59 <sorear> mauke: suppose foo should be 1.0.  I type foo; ghc calls show (which is badly implemented and inexact) and prints 1.0000000000000001.  I go on a wild-goose chase to find the nonexistant bug in my code.
09:54:20 <mauke> sorear: I'd just say "good enough"
09:54:44 <EvilTerran> i say, if you want precision, you shouldn't be using floats in the first place
09:55:13 <therp> evilterran: showsPrec talks about operator precedence, that's only important for generating parseable statements -- namely when to add parenthesis.
09:55:26 <augustss> EvilTerran: but now that you are, why make it even wose by incorrect string conversions?
09:56:15 <EvilTerran> augustss, it makes a hell of a lot more sense than using incorrect string conversions for lists, as you suggested above by way of a strawman.
09:56:19 <augustss> EvilTerran: if you want a sloppy language, you've picked the wrong one. :)
09:56:59 <sorear> why does everyone here seem to think floating point math is inexact?
09:57:17 <EvilTerran> sorear, because, if you use them naively, it is
09:57:19 <augustss> EvilTerran: so where do you draw the line?  Is it ok to leave out non-printable characters when you show a string?  surely you'r not interested in reading those back in.
09:57:58 <augustss> sorear: it's not inexact, just very different from real numbers
09:58:18 <xerox> the #perl6 bot does a cute thing to say '\n', showing an unicode char with an N in the upper left and and L in the lower right :)
09:58:23 <EvilTerran> augustss, if you start murdering performance to preserve the minutae of a type that's already an approximation, i think that's misguided
09:58:24 <sorear> augustss: I know.  I'm complainign about how alone I feel in knowing
09:58:49 <augustss> sorear: don't worry, you're not alone :)
09:58:52 <EvilTerran> sorear, it's an inexact approximation of the real numbers. people use them, mostly, to represent the real numbers.
09:59:02 <EvilTerran> so, as most people use them, they're inexact
09:59:50 <EvilTerran> augustss, character escaping is a fairly inexpensive process, and strings are already a precise type, so it's worth the extra expense to ensure nothing is lost.
10:00:28 <augustss> EvilTerran: what do you care about string conversion performance?  I thought they were only supposed to be used for debugging
10:00:36 <EvilTerran> did i say that?
10:00:40 <EvilTerran> i don't think i said that!
10:00:47 <augustss> No, mauke said that
10:00:59 <augustss> but when would you use conversion to strng, then?
10:01:09 <augustss> and why wouldn't you want those uses to be correct?
10:01:11 <EvilTerran> 1748 <EvilTerran> sorear, for communicating with humans.
10:01:26 <xerox> nearly every time you press RET in ghci
10:01:39 <sorear> that's called debugging
10:01:43 <EvilTerran> i don't want them to be perfect because they don't need to be perfect
10:02:03 <sorear> EvilTerran: If you want a standard pretty-printing class, fine.  But don't take out your frustation on Show
10:02:08 <EvilTerran> and algorithmic simplicity trumps perfection when perfection is unnecessary, imo
10:02:35 <EvilTerran> what's Show for, then? producing valid haskell expressions, and nothing else?
10:02:41 <augustss> EvilTerran: but you don't know how show is going to be used by everyone around the world.
10:02:41 <EvilTerran> that's pretty narrow requirements.
10:03:10 <augustss> EvilTerran: show sucks at communicating with humans.  I always define a pretty printing class for that
10:03:22 <EvilTerran> it also sucks for serialisation
10:03:29 <EvilTerran> (ie communicating with non-humans)
10:03:32 <xerox> TheCatsters are producing a lot of videos :)
10:03:33 <sorear> yes, it's a narrow requirement
10:04:24 <EvilTerran> okay, let me take a different tack: i think the Show class is misguided in scope, if that's its intended scope.
10:04:32 <ddarius> xerox: And garnishing quite a bit of popularity (relatively speaking)
10:04:36 <augustss> When Haskell start sacrificing correctness for speed then it's time to move to another language
10:05:10 <ddarius> augustss: Then that time was a long long time ago...
10:05:31 <ddarius> Still, Haskell seems to be one of the better languages in that regard.
10:05:38 <augustss> ddarius: yeah, I know :)
10:05:38 <sorear> > S.take 3 (S.pack ("abcdef" ++ undefined))
10:05:43 <lambdabot>  Couldn't match expected type `Word8' against inferred type `Char'
10:05:53 <sorear> > S.take 3 (S.pack ([1..100] ++ undefined))
10:05:54 <lambdabot>  Undefined
10:06:00 <sorear> ...wow
10:06:02 <EvilTerran> there's nothing wrong with having a class for turning values into a source-code representation thereof, but converting to/from human-readable forms and serialisation are far more common goals
10:06:19 <sorear> EvilTerran: Fine.
10:06:36 <sorear> EvilTerran: Go make your own class.  Give it a good name.  Put it on Hackage.
10:06:41 <EvilTerran> so people expect Show/Read to do one or t'other (or both).
10:06:48 <sorear> people are wrong
10:06:50 <EvilTerran> sorear, and patch GHC so it can derive it?
10:06:55 <SamB> all three!
10:07:09 <augustss> EvilTerran: it does all three, some of them badly
10:07:19 <EvilTerran> write my own library standard that does what i want?
10:07:19 <sorear> EvilTerran: you shouldn't expect GHC to be able to generate human readable anything
10:07:27 <SamB> I suggest a Pretty class
10:07:41 <DRMacIver> I suggest a Classy class.
10:07:55 <ronwe> or a classy printer
10:07:59 <EvilTerran> augustss, it's not designed for serialisation nor pretty-printing, though
10:08:06 <augustss> EvilTerran: so you think strtod&co in C are wrong too then?  They go to great length to get the last bit right.
10:08:09 <sorear> EvilTerran: deriving for Pretty would be pointless, unless you can invent an aesthetic optimization algoritm
10:08:32 <sorear> EvilTerran: and if you can, stop wasting your time programming, go get a nobel prize
10:09:15 <augustss> Haskell 1.0 actually had a serialization class, but it was dropped
10:12:16 <EvilTerran> what do people really use Read and Show for, then?
10:14:42 <phobes> EvilTerran:  Producing a string from which the original binary encoding can be recovered is a requirement for the default floating show/read!!
10:14:58 <EvilTerran> why?
10:15:27 <EvilTerran> ah, let me re-phrase.
10:15:47 <EvilTerran> if the defined point of Read/Show is to parse/produce valid Haskell, yes, that's a perfectly valid requirement to have.
10:17:20 <phobes> is that not the point of Read/Show?
10:17:27 <EvilTerran> i'm not saying it isn't
10:17:29 <phobes> (one point)
10:17:50 <phobes> You're saying you want a PrettyPrint class with no associated reader
10:17:52 <phobes> ?
10:18:19 <ndm> i am saying that
10:18:25 <phobes> Even C supports %3.5d etc
10:18:29 <ndm> i want a Pretty class which is for human consumption
10:18:29 <phobes> err, %3.5f
10:18:30 <EvilTerran> but it gets in the way if you want to slurp in a million human-readable values, mung them about, and spit them out again, and you aren't concerned with small inaccuracies
10:18:47 <ndm> you shouldn't do read/show, you should serialise
10:19:00 <SamB> ndm: should it use an overloaded pretty-printing mechanism?
10:19:22 <ndm> SamB, yes
10:19:41 <EvilTerran> and, in the case of using floats as an approximation of the reals, you don't care about small inaccuracies.
10:19:46 <EvilTerran> and that's a common use case.
10:20:28 <SamB> EvilTerran: you care about unneccessary inaccuracies...
10:20:49 <EvilTerran> SamB, it may not be unnecessary if it reduces your running time a hundredfold.
10:21:24 <phobes> EvilTerran:  You think there is a hundred fold performance gain to be had by allowing small inaccuracies?
10:21:24 <SamB> if you're that hard up for cycles, you can use another mechanism...
10:21:43 <phobes> EvilTerran:  If that's the case, I suspect it's because of a poor implementation
10:21:46 <EvilTerran> phobes, depending on the scenario, and what inaccuracies you're dealing with, yes
10:22:15 <SamB> anyway I'm positive you can do fairly well just by using a Double-specific implementation or something...
10:22:43 <vagif> Hello, trying to comlile HaskellNet. get this error: Module Data.Time.LocalTime does not export formatTime
10:23:00 <EvilTerran> i may be being a bit superlative there, i agree. i haven't done the research to know exact values.
10:23:48 <phobes> EvilTerran:  I would expect it to be less than 2x...  getting the right number of digits should just be about attention to detail I think
10:24:25 <phobes> EvilTerran:  (Though if you're willing to lose significant precision you can obviously save some time)
10:25:35 <phobes> EvilTerran:  Honestly, I'd think it reasonable to see a correct implementation be something like 10% slower
10:25:55 <yetAnotherOne> > 2.2 - (floor 2.2)
10:25:57 <lambdabot>  Add a type signature
10:25:57 <EvilTerran> what *i* want is a class/classes to deal with getting values to/from human-readable (not necessarily "pretty") formats, and a class/classes for serialization. it seems to me that, in comparison to those two applications, the official purpose of Show/Read is tiny
10:26:11 <yetAnotherOne> > 2.2 - (floor 2.2) :: Float
10:26:12 <lambdabot>   add an instance declaration for (Integral Float)
10:26:28 <ddarius> :t floor
10:26:30 <EvilTerran> i may be the only one who feels that way, but that's how i see it.
10:26:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:26:40 <yetAnotherOne> how do i convert an integer to a float?
10:26:44 <dcoutts> sorear: what do you mean exactly by "a cabal faq list"?
10:26:52 <phobes> yetAnotherOne:   add a .0 to the end of it
10:27:00 <mauke> yetAnotherOne: fromIntegral
10:27:07 <yetAnotherOne> thanks
10:27:37 <yetAnotherOne> > 2.2 - (fromIntegral $ floor 2.2)
10:27:38 <lambdabot>  0.20000000000000018
10:27:54 <sorear> dcoutts: read one line up
10:27:56 <mauke> > properFraction 2.2
10:27:58 <lambdabot>  (2,0.20000000000000018)
10:28:16 <sorear> dcoutts: far too many poeple are bothering #haskell about build-depends woes
10:28:28 <sorear> dcoutts: they think hidden packages are a ghc-pkg issue
10:28:49 <sorear> EvilTerran: You're not alone.
10:29:00 <sorear> EvilTerran: Write it, and become famous.
10:29:13 <dcoutts> sorear: right, because ghc reports them as such
10:29:14 <sorear> EvilTerran: We already have Binary for format-agnostic serialization
10:29:32 <EvilTerran> the problem comes, imo, when people expect Read/Show to be perfect for serialization, or to produce output fit for human consumption, or (god forbid) both
10:30:00 <sorear> people are stupid
10:30:02 <dcoutts> sorear: perhaps we can fix the ghc error message, after all it ought to know that they've been *explicitly* hidden by passing a particular flag on the command line
10:30:07 <sorear> no reason to dumb down the language
10:30:29 <sorear> maybe dumb down isn't quite the right choice
10:30:39 <int-e> > read ('"':repeat ' ') :: Int
10:30:39 <EvilTerran> and, in the human consumption case, i think sacrivicing perfect accuracy for algorithmic elegance in the cases where only one is possible is the way to go
10:30:43 <lambdabot> Terminated
10:30:44 <phobes> I don't understand why you wouldn't want human readable text from which the original value can be recovered exactly...
10:30:51 <int-e> try to explain that to a haskell newbie :P
10:30:55 <SamB> EvilTerran: wait up
10:31:13 <SamB> what does any of this have to do with elegance>
10:31:19 <SamB> s/>/?/
10:31:47 <EvilTerran> elegance, performance, etcetra
10:32:25 <EvilTerran> sorear, i know what you mean - i think it'd benefit from clarifying, not from dumbing down
10:33:07 <phobes> EvilTerran:  Why do you think precision accurate stringification of floating point numbers should be so much slower?  (I'm not saying you're wrong... t just seems counterintuitive to me)
10:33:41 <EvilTerran> where Show is documented: "warning: this is not meant to be human readable, nor is it meant to be good for serialization. it's for converting values into haskell expressions and vice-versa."
10:34:05 <EvilTerran> phobes, from earlier discussion, i was under the impression that that was the case
10:34:33 <phobes> EvilTerran:  Did you infer from the fact that it takes significantly more lines of code that it would be significantly slower?
10:34:52 <EvilTerran> not a hundredfold (as i said, that was me being excessively superlative in the heat of the moment), but still slower
10:35:06 <phobes> EvilTerran:  I would expect it to take significantly more code (since you have to handle the cases carefully), but be not much slower
10:35:11 <kyevan> > let x = 1 : fst x + 1 : x
10:35:12 <lambdabot>  Parse error
10:35:15 <EvilTerran> well, that's why i fell back to my wishy-washy arguments about elegance ;)
10:35:16 <kyevan> > let x = 1 : fst x + 1 : x in x
10:35:17 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a, b)'
10:35:22 <kyevan> Hmm...
10:35:36 <EvilTerran> > let x = 1 : head x + 1 : x
10:35:36 <lambdabot>  Parse error
10:35:39 <EvilTerran> > let x = 1 : head x + 1 : x in x
10:35:40 <kyevan> I'm sure that's not correct code, I just can't think of what would be right >_>
10:35:40 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
10:35:45 <kyevan> Oh, right
10:35:49 <EvilTerran> @src head
10:35:49 <lambdabot> head (x:_) = x
10:35:49 <lambdabot> head []    = undefined
10:35:51 <EvilTerran> @src fst
10:35:51 <lambdabot> fst (x,_) =  x
10:36:13 <kyevan> head, not fst. I've used PLT's Scheme varient too much (where car/head is called first)
10:36:33 <ddarius> @src (->) first
10:36:33 <lambdabot> first f = f *** id
10:36:43 <EvilTerran> phobes, anyway, i have to go have dinner. i'll think about where i was going with this while i'm eating, and if i come up with anything else worth saying, i'll get back to you ;)
10:36:48 <phobes> EvilTerran: If we grant the assumption that it is much slower, then I think your case becomes much stronger.   If they are about the same speed, even if doing it right is more complex, then I'd say the property of recovering the binary value exactly is a nice to have
10:37:14 <phobes> EvilTerran:  Enjoy your meal :)
10:37:26 <EvilTerran> indeed. but still, make sure people know not to abuse it for serialization.
10:37:29 <EvilTerran> thanks!
10:37:42 <EvilTerran> (it's a documentation thing, in a way)
10:38:57 <augustss> phobes: doing it right doesn't have to be much slower (in the typical case).  But doing it right and fast is complex.
10:39:17 <kyevan> Does Haskell support weird radixes (radi?)?
10:39:19 <phobes> augustss: That's as I would expect
10:39:24 <kyevan> (Say, 25.)
10:39:36 <augustss> phobes: just look at the C code :)
10:40:07 <augustss> kyevan: not in any systematic way
10:41:47 <augustss> phobes: at the time I wrote all the conversion functions I was more interested in correctness and generality.  that's why they are slow
10:42:15 <augustss> I thought they would get rewritten eventually, but not yet, it seems
10:42:48 <augustss> kyevan: there's showIntAtBase
10:43:11 <phobes> augustss: Did you paste a link?  I see you talking about it in the history, but didn't see a link
10:43:22 <byorgey> @type showIntAtBase
10:43:27 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
10:43:33 <phobes> augustss: (to the C code)
10:43:39 <augustss> I've not pasted any links
10:43:51 <phobes> oh, what C code were you referencing?
10:43:55 <augustss> phobes: I just looked at the NetBSD source
10:43:59 <phobes> oh ok
10:44:18 <phobes> What's the file name?
10:44:24 <augustss> strtod.c
10:44:28 <phobes> ok thank
10:44:39 <byorgey> > showIntAtBase 16 ("0123456789abcdef"!!) 253 "wha?"
10:44:44 <lambdabot>  "fdwha?"
10:45:09 <byorgey> weird, what's the extra String arguemnt for?
10:45:17 <int-e> > map intToDigit [0..15]
10:45:18 <lambdabot>  "0123456789abcdef"
10:45:43 <int-e> byorgey: the string gets appended to the result. this idea allows for efficient string concatenation.
10:45:47 <int-e> @type shows
10:45:49 <lambdabot> forall a. (Show a) => a -> String -> String
10:45:58 <byorgey> int-e: oh, ok, I get it
10:46:04 <int-e> it can also be found in the Show class. (in shows, and showsPrec)
10:46:27 <ddarius> phobes: ? He means the code in the libraries
10:47:14 <phobes> ddarius: eh?
10:47:40 <byorgey> > showIntAtBase 16 intToDigit 551 . shows "foo" $ "bar"
10:47:42 <lambdabot>  "227\"foo\"bar"
10:50:43 <phobes> intToDigit 10
10:50:46 <phobes> > intToDigit 10
10:50:48 <lambdabot>  'a'
10:50:59 <phobes> > intToDigit 36
10:51:00 <lambdabot>  Exception: Char.intToDigit: not a digit 36
10:53:06 <gnech> hello
10:55:09 <sorear> gnech: Hello
11:00:26 <dcoutts> hia pgavin
11:00:36 <koeien> 3
11:00:45 <dcoutts> pgavin: so we're going to want to work on dep analysis at the Haskell Hackathon
11:00:59 <dcoutts> pgavin: so we should get your code into Cabal HEAD before then
11:04:17 <bos> my god, the book's comment system is succeeding perhaps a little too well.
11:04:46 <augustss> heh
11:04:49 <bos> 800 comments on 4 chapters is going to take a bit of digesting, and that's just 36 hours of feedback.
11:04:53 <Nafai> Heh
11:05:04 <Nafai> bos: I'm only through 2 of the chapters myself so far...
11:05:06 <augustss> bos, have you fixed the bugs
11:05:20 <bos> augustss: which ones?
11:05:20 <augustss> comment system bugs, i mean
11:05:31 <bos> most of them.
11:05:42 <augustss> comments in the wrong place.  no comments after green boxes
11:05:50 <bos> yes, those are fixed.
11:05:58 <kolmodin> 4 chapters are out?!
11:06:19 <bos> kolmodin: not in full public view yet
11:06:43 <kolmodin> I'm not public. how do I get access? :)
11:07:00 <augustss> bos: it looks quite good
11:07:04 <bos> join the mailing list, then look in the archive for login and password
11:07:11 <kolmodin> ok, thanks
11:07:13 <bos> augustss: thanks. obviously there's plenty of editing to do.
11:07:47 * EvilTerran returneth
11:07:51 <pgavin> dcoutts: sorry, was afk
11:07:54 <augustss> bos: are you going to have it edited by a profession copy editor as well?
11:07:56 <EvilTerran> (run for the hills, here comes the troll! ;] )
11:08:03 <pgavin> dcoutts: I can send you a patch
11:08:07 <chessguy> import Defs hiding (public); public = not . (== me)
11:08:08 <bos> augustss: we have a content editor and a copy editor both
11:08:24 <bos> but the copy editor doesn't get a run at it for quite a while
11:08:25 <augustss> bos: good
11:08:25 <dcoutts> pgavin: yes, to me and/or to the cabal-devel list
11:08:43 <sorear> bos: I thought I subscribed?
11:08:52 <dcoutts> pgavin: actually, to the list is probably best, my email is a bit dodgy atm
11:09:08 <pgavin> dcoutts: ok
11:09:19 <ddarius> augustss: Presumably O'Reilly would want that for their own reputation.
11:09:34 <augustss> ddarius: true
11:09:35 <pgavin> dcoutts: or I can stick it somewhere and post a link
11:09:47 <dcoutts> pgavin: whichever
11:09:51 <bos> sorear: did you?  i can check. you should have been getting mail.
11:09:57 <dcoutts> pgavin: if the patch is very big that might be better
11:12:32 <pgavin> dcoutts: ehh, only 12k bzipped
11:14:41 <dcoutts> pgavin: ok, good good. right I've got to head home, bye.
11:15:02 <bos> augustss: by the way, thank you for taking the time to read and comment so far
11:19:09 <puusorsa> http://frostfirezoo.com/uk-police-using-hovering-camera-for-surveillance
11:19:11 <lambdabot> Title: UK police using hovering camera for surveillance | Frostfirezoo.com, http://tinyurl.com/3c88r4
11:19:33 <EvilTerran> is it programmed in haskell?
11:20:19 <kolmodin> hah, the chapter "Installing GHC" could be as short as the book of Italian War Victories "emerge ghc". hohohhhohohoh :)
11:20:33 <kolmodin> joking, of course
11:20:44 <ddarius> Yes, you meant French
11:21:04 <newsham> french rifle for sale, never fired, only dropped once.
11:21:08 <kolmodin> it applies to the french too, yes :)
11:21:18 <kolmodin> hah
11:21:25 <pgavin> @list
11:21:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:21:28 <jcreigh> hey, let's not poke fun at the world's #4 nuclear power. :)
11:21:31 <EvilTerran> nah, "french civil war" is a word longer than "emerge ghc"
11:21:54 <EvilTerran> and they won that, almost by definition
11:22:00 <newsham> who can bad mouth the country that gave us freedom fries?
11:22:06 <jcreigh> actually, it might be #3
11:22:11 <ddarius> newsham: I can.
11:22:13 <newsham> (wait, those are made in grease)
11:22:19 <pgavin> @tell dcoutts ok, I've posted the patch to the list
11:22:20 <lambdabot> Consider it noted.
11:22:21 <puusorsa> http://frostfirezoo.com/uk-police-using-hovering-camera-for-surveillance
11:22:23 <lambdabot> Title: UK police using hovering camera for surveillance | Frostfirezoo.com, http://tinyurl.com/3c88r4
11:22:38 <newsham> puu: yah, we saw it the first time.
11:22:46 <ddarius> we still don't care
11:22:49 <puusorsa> oh sorry
11:23:00 <puusorsa> i'm blind AND stupid
11:23:11 <jcreigh> puusorsa: there's always #haskell-blah for OT stuff.
11:30:27 <fnord123> OT = off topic or on topic
11:30:29 <kaol> they seem to be talking about haskell right now. both channels are off topic, then.
11:30:53 <lament> another failure of concurrency :)
11:31:40 <olsner> when #haskell gets into logic or abstract algebra or something, #haskell-blah sometimes takes over the haskell discussions :P
11:32:12 <ddarius> Speaking of which, the State monad arises from a very common adjunction.
11:32:38 <pgavin> has anything been decided RE the location of AmeroHaskell?
11:33:29 <coffeemug> ?src repeat
11:33:29 <lambdabot> repeat x = xs where xs = x : xs
11:33:50 <pgavin> ?src cycle
11:33:50 <lambdabot> cycle [] = undefined
11:33:50 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:34:07 <coffeemug> heh
11:34:15 <kaol> shouldn't join be part of the Monad class? join and >>= could be given default implementations in terms of each other.
11:34:16 <coffeemug> I thought cycle is implemented slightly differently
11:34:27 <pgavin> shouldn't there be some kind of lift that does that?
11:34:32 <Botje> but join is defined as >>= id
11:34:33 <ddarius> kaol: That would require Monad being a subclass of Functor.
11:34:43 <SamB> what about
11:34:53 <SamB> cycle xs = fix (xs ++)
11:35:05 <sorear> no, cycle = fix . (++) :P
11:35:06 <kaol> oh. and I guess there are reasons for not doing that.
11:35:12 <sorear> repeat = fix . (:)
11:35:31 <sorear> forever = fix . (>>)
11:35:32 <kaol> I was just reading http://en.wikibooks.org/wiki/Haskell/Category_theory and saw that thing about join and >>=
11:35:41 <SamB> sorear: I was going for clarity rather than conciseness
11:36:02 <coffeemug> cycle xs = xs ++ cycle xs
11:36:16 <coffeemug> which is pretty much the same thing
11:36:17 <xerox> now = fix . const -- :-)
11:36:22 <SamB> eh?
11:36:52 <ddarius> kaol: No, no good reasons.
11:37:02 <pgavin> @pl (fix . const)
11:37:02 <lambdabot> id
11:37:15 <ddarius> coffeemug: That definition of cycle would have bad properties in most implementations.
11:37:35 <coffeemug> ddarius: right
11:37:55 <coffeemug> it would calculate each boundary from the start
11:38:01 <coffeemug> for one
11:38:40 <EvilTerran> the @src version uses a finite number of list cells
11:39:29 <EvilTerran> iirc. which is good for keeping the GCs down.
11:41:43 <ddarius> We must repress those rebellious GCs.
11:42:22 <jcreigh> they're trying to elimiate free cells!
11:42:32 <jcreigh> *eliminate
11:43:08 <EvilTerran> i am not a pointer, i am a free cell!
11:49:47 <arcatan> all False []
11:49:51 <arcatan> > all False []
11:49:52 <lambdabot>  Couldn't match expected type `a -> Bool'
11:50:02 <arcatan> > all (const False) []
11:50:04 <lambdabot>  True
11:50:06 <arcatan> hmm.
11:50:17 <newsham> > all id []
11:50:19 <lambdabot>  True
11:50:26 <newsham> > all id [True, True, True]
11:50:28 <lambdabot>  True
11:50:33 <newsham> > all id [True, False, True]
11:50:34 <lambdabot>  False
11:50:50 <ddarius> @check \p -> all p []
11:50:51 <lambdabot>  Add a type signature
11:50:58 <sorear> all id == and
11:51:03 <ddarius> @check \p -> all (p :: Int -> Bool) []
11:51:04 <dons> ?users
11:51:04 <lambdabot>  OK, passed 500 tests.
11:51:04 <lambdabot> Maximum users seen in #haskell: 407, currently: 357 (87.7%), active: 17 (4.8%)
11:51:44 <EvilTerran> @src and
11:51:45 <lambdabot> and   =  foldr (&&) True
11:51:47 <EvilTerran> @src all
11:51:47 <lambdabot> all p =  and . map p
11:51:51 <EvilTerran> @src any
11:51:51 <lambdabot> any p =  or . map p
11:52:39 <puusorsa> :type all
11:53:48 <coffeemug> hmm
11:54:07 <coffeemug> I wish there was some means to get a GHC mentor
11:54:26 <coffeemug> who'd cook up projects/tasks
11:54:27 <coffeemug> for people
11:54:36 <coffeemug> it's kind of hard to just jump in :)
11:54:42 <ddarius> TRAC?
11:55:22 <coffeemug> yeah, trac is a good start
11:59:29 <therp> coffeemug: try to find out why ghc-6.8 does not compile with ghc-6.8 :) -- or verify that you don't see http://hpaste.org/2852
12:01:57 <coffeemug> hehe, you gotta love "the impossible happened" messages
12:02:34 <gnech> How would I truncate 7.5 to 7?
12:03:00 <gnech> i just want to convert from a fractional to an integer
12:03:04 <omniscientIdiot> > truncate 7.5
12:03:09 <lambdabot>  7
12:03:50 <omniscientIdiot> @src RealFrac
12:03:50 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
12:03:50 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
12:03:50 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
12:04:12 <gnech> wow really
12:04:25 <gnech> neat
12:04:47 <gnech> thanks omniscientIdiot
12:04:57 <omniscientIdiot> sure thing
12:05:27 <gnech> i'm sort of impressed with haskell.. i'm learning it for a CS class but it turned out better than expected
12:07:06 <dons> gnech: yeah, its good to realise its not a toy, but a serious tool :)
12:07:51 <DRMacIver> Which isn't to say that you shouldn't play with it. :)
12:09:06 <augustss> gnech: sure you want truncate and not floor?
12:10:22 <omniscientIdiot> > (floor (-2.3), truncate (-2.3))
12:10:34 <lambdabot>  (-3,-2)
12:12:14 <coffeemug> gnech: which university?
12:14:47 <iguana_> hi, does anybody have a pointer how to parse an indentation-aware language like python with parsec?
12:15:06 <sorear> "like python"? :D
12:16:08 <iguana_> well, it's not python but something that uses indentation to group
12:16:31 <iguana_> i'm not writing a python interpreter in haskell :)
12:18:38 <rey_> http://www.secnetix.de/~olli/Python/block_indentation.hawk
12:18:40 <lambdabot> Title: Python: Myths about Indentation
12:18:46 <rey_> the last question on that page explains it
12:20:02 <iguana_> rey_: I know, but I'd have hoped for a more specific example with parsec :)
12:22:33 <omniscientIdiot> iguana_: look at get, set, and updateState.  You might have a stack of indentation levels in the parser state.
12:25:36 <dons> iguana_: it really depends on the input language i think
12:25:56 <dons> you can do haskell by implementing the layout rules in the lexer, but python probably has its own spec
12:28:38 <iguana_> in general, does one do lexing and parsing as separate steps with parsec? many examples seem to do both at once
12:29:24 <dons> for small systems. you're trying to parse python I take it?
12:29:37 <dons> does it have a grammar specification?
12:29:40 <omniscientIdiot> YAML?
12:30:09 <omniscientIdiot> dons: 15:16 <iguana_> i'm not writing a python interpreter in haskell :)
12:30:14 <iguana_> it's similar to yaml
12:30:28 <dons> still, i'd do the lexing and parsing separately
12:30:40 <dons> get a stream of significant tokens, then parse that
12:30:43 <dons> makes your life easier
12:30:53 <sjanssen> @hackage numbers
12:30:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
12:30:56 <sjanssen> neat ^^^
12:31:18 <sjanssen> augustss blog posts rolled into Cabal form :)
12:31:37 <dons> mmm. tasty
12:31:59 <dons> hackage really needs a reclassificatoin tool
12:32:05 <dons> and a fixed set of categories
12:32:13 <iguana_> and a total count of packages
12:33:16 <SamB> @hoogle Random
12:33:20 <lambdabot> Random :: module
12:33:21 <lambdabot> System.Random :: module
12:33:21 <lambdabot> System.Random.Random :: class Random a
12:34:00 <dons> the search interface might provide some clues
12:34:06 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/search
12:34:11 <dons> we should get a lambdabot plugin for that..
12:35:40 <sjanssen> hmm, depends on and required by seem to be reversed on the advanced search
12:36:17 <dons> hmm. we could use this to start doing statistics and pretty graphs
12:36:33 <iguana_> @hoogle comparing
12:36:34 <lambdabot> No matches found
12:36:39 <iguana_> odd
12:36:45 <dons> yeah, it is reversed, sjanssen
12:37:08 <dons> 7 projects depend on `binary'
12:37:53 <dons> a GET-based interface would be nice.
12:38:05 <dons> 112 packages use the mtl
12:38:33 <dons> only 23 use the unix package. interesting
12:38:44 <omniscientIdiot> iguana_: comparing f x y = compare (f x) (f y)
12:39:15 <iguana_> omniscientIdiot: well, I would have expected hoogle to find it
12:40:18 <omniscientIdiot> it's in Data.Ord, but I think it's newish.
12:40:52 <sjanssen> dons: 112 is almost half of all packages
12:41:15 <dons> mtl is a core language feature
12:41:18 <dons> ;)
12:41:39 <gnech> hmm
12:41:42 <omniscientIdiot> MONADS, FSCK YEAH!
12:42:33 <dons> glguy: should we tell iavor half of all hackage projects are using mtl-based monad stacks? :)
12:42:55 <gnech> http://pastehere.com/?ubanym
12:43:03 <gnech> can anyone explain this error?
12:43:27 <dons> ?paste <- is a good place for future pastes, since it announces in here.
12:43:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:43:59 <dons> yes, the bug is in the type of (/)
12:44:03 <dons> :t length
12:44:05 <lambdabot> forall a. [a] -> Int
12:44:07 <dons> ;t (/)
12:44:19 <dons> :t (/)
12:44:21 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:44:26 <omniscientIdiot> @type div
12:44:27 <cognominal_> ?  ( (1+) + (1-) ) (0 ::Int)
12:44:28 <dons> ?instances Fractional
12:44:28 <lambdabot> forall a. (Integral a) => a -> a -> a
12:44:29 <lambdabot> Double, Float
12:44:42 <omniscientIdiot> you want div
12:44:48 <dons> so note that (/) works on fractional types. but Int, the result of length, isn't one of those types
12:44:51 <dons> (/) is for floating point
12:44:56 <dons> `div` is for integer division
12:45:09 <gnech> really
12:45:10 <dons> so you can either convert the result of length to floating point, or use `div`
12:45:12 <gnech> interesting
12:45:16 <dons> > 3 `div` 2
12:45:17 <lambdabot>  1
12:45:19 <dons> > 3 / 2
12:45:20 <lambdabot>  1.5
12:45:22 <cognominal_> What do I need to import to be able to add function?
12:45:27 <dons> > length "haskell" `div` 2
12:45:29 <lambdabot>  3
12:45:31 <gnech> thanks dons
12:45:37 <dons> > fromIntegral (length "haskell") / 2
12:45:39 <lambdabot>  3.5
12:45:46 <omniscientIdiot> cognominal_: to add functions?
12:45:49 <dons> > genericLength "haskell" / 2
12:45:49 <ddarius> > genericLength "haskell" / 2
12:45:51 <lambdabot>  3.5
12:46:05 <lambdabot>  3.5
12:46:05 <cognominal_> I am asked :  Possible fix: add an instance declaration for (Num (Int -> Int))
12:46:21 <dons> :t (1+)
12:46:22 <cognominal_> ?  ( (1+) + (1-) ) (0 ::Int)    -- Here I add two function and I apply them
12:46:23 <lambdabot> forall t. (Num t) => t -> t
12:46:25 <dons> is a function
12:46:36 <sjanssen> cognominal_: are you inteding to add functions, or are you making a mistake?
12:46:37 <omniscientIdiot> cognominal_: are you sure you don't just want to give it another argument?
12:46:42 <dons> you want to compose them?
12:46:52 <dons> > ((1+) . (1-)) 0
12:46:53 <lambdabot>  2
12:46:58 <dons> > ((1+) &&& (1-)) 0
12:46:59 <lambdabot>  (1,1)
12:47:07 <dons> > ((1+) ||| (1-)) 0
12:47:07 <lambdabot>   add an instance declaration for (Num (Either t t))
12:47:07 <cognominal_> no, I want to add them
12:47:18 <dons> what does it mean to add a function?
12:47:28 <iguana_> perhaps something like (f +++ g) x  = f x + g x
12:47:39 <dons> if you have a semantics for it, you can then write a Num instance for that behaviour
12:47:45 <dons> ah
12:47:45 <sjanssen> cognominal_: just use the ((->) a) Monad
12:47:58 <omniscientIdiot> @type liftM2 (+)
12:48:00 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
12:48:03 <dons> > liftM (+) (1+) (1-) $ 0
12:48:03 <cognominal_> sjanssen, how so?
12:48:03 <lambdabot>   add an instance declaration for (Num (t -> t))
12:48:10 <sjanssen> > liftM2 (+) (1+) (1-) 0
12:48:12 <lambdabot>  2
12:48:19 <sjanssen> cognominal_: ^^^
12:48:24 <dons> and in applicative functors..
12:48:53 <cognominal_> thx
12:48:58 <dons> ?pl liftM2 (+) (1+) (1-) 0
12:48:58 <lambdabot> 2
12:49:02 <dons> ?pl liftM2 (+) (1+) (1-)
12:49:02 <lambdabot> liftM2 (+) (1 +) ((-) 1)
12:49:11 <cognominal_> :t liftM
12:49:12 <nominolo> > (+) <$> [2,3] <*> [4,5]
12:49:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:49:14 <lambdabot>  [6,7,7,8]
12:49:21 <dons> oh, lists. heh
12:49:28 <omniscientIdiot> > (+) <$> (1+) <*> (1-) $ 0
12:49:29 <lambdabot>  2
12:49:39 <omniscientIdiot> :)
12:49:52 <iguana_> uh oh
12:49:53 <dons> and now in arrows..
12:50:48 <kaol> gnn... turning perl code into haskell code is harder than what it would be the other way around.
12:50:48 <cognominal_> I don't know that syntax :  <*>
12:51:01 <dons> > uncurry (+) $ ((1+) &&& (1-)) $ 0
12:51:03 <lambdabot>  2
12:51:13 <omniscientIdiot> cognominal: it's a method of the Applicative class.
12:51:39 <EvilTerran> > liftM2 (+) (1+) (1-) 0
12:51:40 <lambdabot>  2
12:51:45 <nominolo> >  ((1+) &&& (1-))  0
12:51:46 <omniscientIdiot> cognominal: which is like a "not quite a Monad".
12:51:46 <lambdabot>  (1,1)
12:52:23 <cognominal_> omniscientIdiot, can you point me to some doc?
12:52:25 <nominolo> oh, heh.  i confused (1-) with (\x->x-1)
12:52:34 <omniscientIdiot> @docs Control.Applicative
12:52:34 <lambdabot> Control.Applicative not available
12:52:40 <omniscientIdiot> @docs Data.Applicative
12:52:40 <lambdabot> Data.Applicative not available
12:52:43 <omniscientIdiot> hm
12:52:56 <nominolo> it's Control.Applicative
12:52:58 <omniscientIdiot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
12:53:01 <lambdabot> http://tinyurl.com/yyo64c
12:53:04 <cognominal_> so  lexcially <$> is a plain operator?
12:53:14 <omniscientIdiot> (<$>) = fmap
12:53:25 <omniscientIdiot> @src (<$>)
12:53:25 <lambdabot> f <$> a = fmap f a
12:53:30 <nominolo> f <$> x = pure f <*> x
12:53:32 <omniscientIdiot> quite literally, too :)
12:54:04 <EvilTerran> cognominal_, there are very few things in haskell that aren't lexiacally a plain operator
12:54:09 <dons> cognominal_: everything is just a library function, at a first approximiation
12:54:09 <cognominal_> now I understand why two language that are polar opposite are liked by the same people : TMOWTDI!!
12:54:50 <omniscientIdiot> too many names for the same thing in the Functor heirarchy, hysterical raisons.
12:54:54 <dons> none of this stuff is wired in (they're coming from Control.Monad or Control.Arrow or Control.Applicative)
12:55:01 <dons> different models of computation as a library
12:55:08 <EvilTerran> to quote the report, "reservedop 	 -> 	 .. | : | :: | = | \ | | | <- | -> | @ | ~ | =>"
12:55:40 <dons> > let x +*#++!!+ y = x - y in 1 +*#++!!+ 3
12:55:42 <lambdabot>  -2
12:55:48 <EvilTerran> and "special 	 -> 	 ( | ) | , | ; | [ | ] | `| { | }"
12:56:00 <dons> and your next step would be to look at haskell.org/haskellwiki/Obfuscation :)
12:56:10 <omniscientIdiot> I was just thinking of that :)
12:56:13 <EvilTerran> beyond those, basically any lexeme comprising only punctuation is a vanilla operator
12:56:35 <omniscientIdiot> evil, evil, dons
12:56:44 <int-e> let (!|) = 1; (|!) = 2 in (!|) + (|!)
12:57:08 <nominolo> > (-) 1
12:57:10 <lambdabot>  <Integer -> Integer>
12:57:18 <omniscientIdiot> > let (^_^) = (+) in 1 ^_^ 2
12:57:18 <lambdabot>  Parse error
12:57:20 <dons> and you can also use lambda calculus to remove all your keywords as well
12:57:22 <EvilTerran> > let ((-)+2)+((+)+2) = (-)+(+)
12:57:22 <lambdabot>  Parse error in pattern
12:57:28 <omniscientIdiot> oops, underscore
12:57:38 <int-e> use .
12:57:44 <omniscientIdiot> > let (^.^) = (+) in 1 ^.^ 2
12:57:44 <EvilTerran> ^.^ would work, or ^-^
12:57:45 <lambdabot>  3
12:57:54 <dons> > (let f x = x + 2 in f 3 ,  (\x -> x + 2) 3)
12:57:56 <cognominal_> dons, I am a shameless obfuscator in Perl : http://paris.mongueurs.net/aplusplus.html
12:57:56 <lambdabot>  (5,5)
12:57:57 <lambdabot> Title: $A++
12:58:10 <dons> so then you can quickly strip all mental hooks from your program
12:58:21 <dons> turning it into parens, lambdas and symbols only
12:58:26 <dons> and no whitespace too, of course
13:01:04 * nominolo votes for using "O_O" instead of "undefined" 
13:01:51 <ddarius> That would be a constructor.
13:01:56 <nominolo> oh, right
13:01:57 <int-e> data O = O; instance Num O where _ - _ = undefined;
13:01:59 <EvilTerran> o_O
13:02:01 <int-e> hmm
13:02:02 <nominolo> then o_O
13:02:28 * omniscientIdiot votes for it
13:02:52 <SamB> @hoogle Id
13:02:53 <lambdabot> Prelude.id :: a -> a
13:02:53 <lambdabot> Control.Monad.Identity :: module
13:02:53 <lambdabot> Text.Read.Ident :: String -> Lexeme
13:04:12 <thn> I'm new to haskell and having some Ratio troubles
13:04:14 <EvilTerran> ?type let ((-)+1)+((+)+2) = (,)(-)(+) in 3+4
13:04:15 <lambdabot> forall t t1. (Integral t, Integral t1) => (t, t1)
13:04:52 <omniscientIdiot> thn: ask away!
13:05:16 <thn> I'm trying to convert a list of ratios into a list of integers
13:05:26 <thn> With the same ratios
13:06:09 <thn> lcm' = foldr1 lcm
13:06:10 <thn> gcd' = foldr1 gcd
13:06:10 <thn> denoms = map denominator
13:06:10 <thn> numers = map numerator
13:06:10 <thn> intify x = numers (map ((*) lowest) x)
13:06:10 <thn>     where
13:06:13 <thn>     lowest = lcm' (denoms x)
13:06:15 <thn> intify x = numers (map ((*) lowest) x)
13:06:16 <thn> intify x = numers (map ((*) lowest) x)
13:06:19 <thn> lcm' = foldr1 lcm
13:06:20 <thn> gcd' = foldr1 gcd
13:06:22 <thn> denoms = map denominator
13:06:24 <thn> numers = map numerator
13:06:26 <thn> intify x = numers (map ((*) lowest) x)
13:06:27 <nominolo> uh
13:06:30 <thn>     where
13:06:32 <thn>     lowest = lcm' (denoms x)
13:06:34 <thn> numers = map numerator
13:06:36 <thn> sorry, I pasted twice
13:06:40 <nominolo> thn please use hpaste,erg next time
13:06:51 <nominolo> hpaste.org
13:06:54 <EvilTerran> \o/
13:07:57 <nominolo> :t 3/4
13:07:59 <lambdabot> forall t. (Fractional t) => t
13:08:09 <nominolo> > 3/4 :: Ratio
13:08:11 <lambdabot>      `Ratio' is not applied to enough type arguments
13:08:11 <lambdabot>     Expected kind `?', b...
13:08:28 <omniscientIdiot> > 3/4 :: Ratio Int
13:08:33 <lambdabot>  3%4
13:09:32 <omniscientIdiot> I tried the code and got an infinite type
13:09:44 <thn> http://hpaste.org/2857
13:09:48 <thn> like this?
13:09:59 <thn> yes, I get an infinite type
13:10:32 <thn> But I don't understand why
13:10:44 <thn> my goal is to take the lcm of a list of ratios
13:10:50 <thn> then multiply them all by that lcm
13:10:57 <thn> and take all the numerators
13:11:06 <EvilTerran> intify x = map ((*) lowest) (numers x)
13:11:35 <ddarius> thn: In general, when you are having issues with types, it helps to add type signatures to (at least) the top-level declarations.
13:12:00 <thn> EvilTerran, that worked!
13:12:05 <thn> But why?
13:12:24 <EvilTerran> you want to take the numerators of everything in x - that's "numers x"
13:12:25 <Saizan> lowest there is not a Ratio, because you're taking the lcm of the denominators
13:12:37 <EvilTerran> then multiply each by "lowest"
13:12:51 <EvilTerran> that's map (lowest *)
13:13:00 <thn> But usually it seems ok to multiply Ratios with Integers:
13:13:01 <EvilTerran> or map ((*) lowest)
13:13:21 <omniscientIdiot> > (3%4) * (2::Int)
13:13:22 <lambdabot>  Couldn't match expected type `Ratio t' against inferred type `Int'
13:13:35 <thn> > (3%4) * 2
13:13:37 <lambdabot>  3%2
13:13:43 <thn> ?
13:13:49 <omniscientIdiot> 2 is inferred as Ratio Int
13:14:07 <Olathe> > (3%4) * 2.0
13:14:08 <lambdabot>  3%2
13:14:09 <Saizan> numeric literals are polymorphic
13:14:13 <Saizan> ?type 2
13:14:14 <lambdabot> forall t. (Num t) => t
13:14:18 <thn> Ah
13:14:18 <EvilTerran> > 2 :: Rational
13:14:19 <lambdabot>  2%1
13:14:26 <EvilTerran> inference magic
13:14:32 <Olathe> > (3%4) * 2.2
13:14:33 <lambdabot>  33%20
13:14:38 <thn> Now I see,
13:14:56 <thn> Thanks everyone
13:15:04 <Olathe> > 1.15 * (1%1)
13:15:05 <lambdabot>  23%20
13:15:24 <thn> Haskell's typing is pretty magical
13:15:50 <Olathe> I know. It's like...how does it type things without a keyboard ?
13:19:16 <Saizan> http://en.wikipedia.org/wiki/Type_inference#Hindley.E2.80.93Milner_type_inference_algorithm <-- here is the basic algorithm, it's not magic :)
13:19:18 <lambdabot> http://tinyurl.com/72ovj
13:19:53 <gnech> what would be a good way of seeing if string a is a substring of string b?
13:19:59 <gnech> without doing recursion
13:20:10 <Saizan> ?src isInfixOf
13:20:10 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
13:20:33 <sjanssen> gnech: what's wrong with recursion?
13:21:05 <gnech> nothing really, i just feel like i'm using recursion too much and should make use of other functions
13:21:09 <Olathe> gnech: http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
13:21:11 <lambdabot> Title: Knuth-Morris-Pratt in Haskell - 21 thoughts, http://tinyurl.com/23rvcf
13:22:32 <omniscientIdiot> gnech: well, recursion is the (I believe) sole way to repeat things in Haskell.  Luckily almost all of the useful recursive patterns are already encapsulated in library functions.
13:23:22 <gnech> the only reason I ask is because I'm wondering if there is a simpler way
13:23:50 <omniscientIdiot> dig in the libs!  Did you see the code for isInfixOf above?
13:24:11 * Lycurgus wonders what happened to LOLITA
13:24:17 <dons> omniscientIdiot: hmm? to repeat things?
13:24:59 <omniscientIdiot> dons: uh, I guess the way other languages would use a loop, but don't quote me on it :)
13:25:01 <dons> most of the list and monad functions are specialised control forms for repeating/foldig/looping
13:25:22 <dons> right, in haskell you'd use a fold or a map or a list comprehension or recursion if nothing else fits
13:25:24 <omniscientIdiot> yeah
13:25:52 <dons> > [ toUpper x | x <- "haskell" ]
13:26:03 <lambdabot>  "HASKELL"
13:26:08 <ddarius> > map toUpper "haskell"
13:26:09 <lambdabot>  "HASKELL"
13:26:23 <dons> ?let for = flip map
13:26:25 <lambdabot> Defined.
13:26:36 <dons> > for "haskell" $ \n -> toUpper n
13:26:37 <lambdabot>  "HASKELL"
13:27:15 <omniscientIdiot> > map toLower "OKAY I GET IT"
13:27:17 <lambdabot>  "okay i get it"
13:27:24 <dons> so you'd use recursion as a beginner, to understand the fundamentals
13:27:36 <dons> and you pick up the specific combinator forms for each kind of recursion as you go
13:27:44 <omniscientIdiot> exactly as I did
13:34:12 <olivier_> hi guys, anyone getting "Not in scope" on MachCodeGen.hs when compiling ghc? I'm on a x86_64-pc-linux-gnu
13:34:52 <olivier_> (from darcs and from 6.6.1 sources)
13:35:10 <sorear> olivier_: ghc doesn't always compile, especially on less common platforms, use a binary
13:35:44 <dons> hmm. darcs head should work on that arch. but there are binaries available as well
13:36:00 <ddarius> sorear: Clearly if there is a binary you can compile it too.
13:36:11 <dons> right, but maybe not the current darcs stable branch (!)
13:36:19 <dons> or some other issue might be involved
13:36:37 <dons> olivier_: try a src snapshot for the stable branch, or one of the release candidates
13:36:46 <sorear> ddarius: the binaries were prepared by humans who understand the GHC build system.  emerge is neither.
13:36:47 <olivier_> dons: ok
13:37:06 <ddarius> sorear: I didn't say emerge could compile it.
13:37:38 <Ultra5pam> We meet on th’ copper  threshing-floor:
13:37:39 <Ultra5pam> And we alone know where it is;
13:37:41 <Ultra5pam> In March we ride on weaving-beams,
13:37:42 <Ultra5pam> Together hold our secret councils,
13:37:44 --- mode: ChanServ set +o dons
13:37:44 <Ultra5pam> Decide on whom to work our ill.
13:37:45 <Ultra5pam> Many a different form we take,
13:37:46 --- mode: dons set +b *!*=chatzill@*.client.mchsi.com
13:37:46 --- kick: Ultra5pam was kicked by dons (dons)
13:37:49 --- mode: ChanServ set -o dons
13:37:58 <EvilTerran> alrighty then.
13:37:59 <mrd> 5 seconds <click>
13:38:16 * dons blows smoke from his 6 shooter
13:38:21 <EvilTerran> have we annoyed anyone recently?
13:38:54 <EvilTerran> * [Ultra5pam] (n=chatzill@12-214-39-49.client.mchsi.com): New Now Know How
13:39:03 <Botje> known spammer
13:39:06 <Botje> different username
13:39:09 <Botje> ignore :)
13:39:34 <EvilTerran> okay. someone with a grudge, or was that meant to be advertising something?
13:39:55 <sorear> EvilTerran: Pseudonym uses that ircname
13:40:01 <Botje> probably a bored spammer
13:40:07 <ddarius> EvilTerran: You're trying to understand the mind of a spammer.  Think about this.
13:40:21 <EvilTerran> ddarius has a point
13:40:59 <EvilTerran> sorear, i think "New Now Know How" is the chatzilla default, if we're thinking of the same thing
13:41:34 <gnech> omniscientIdiot: do i need to import any libraries for isInfixOf to work
13:41:42 <mrd> Data.List
13:41:56 <gnech> ok cool
13:42:41 <dons> welcome cameron
13:43:54 <SamB> I don't suppose anyone knows where this comes from:
13:44:01 <SamB>     Couldn't match kind `?' against `* -> *'
13:44:01 <SamB>     When matching the kinds of `t :: ?' and `t1 :: * -> *'
13:44:19 <dons> :k (->)
13:44:21 <lambdabot> ?? -> ? -> *
13:44:41 <dons> you've got the type variables over or underapplied, i suspect
13:45:03 <SamB> I think the typechecker is making those up though!
13:45:23 <sorear> SamB: Kind errors can only occur in explicit tpe delcs
13:45:28 <dons> its inferred two types, t and t1, and tried to unify them. but the kind check failed
13:45:44 <sorear> dons: inferred types are always kind-correct
13:46:01 <SamB> sorear: you'd think!
13:46:30 <Lycurgus> GF I guess it is, but LOLITA shore looked nice.
13:46:45 <SamB> http://hpaste.org/2858
13:46:48 <dons> sorear: hmm. i've not looked at the kind checking code. is that really the case?
13:47:05 <Botje> @pl \a b -> b+1
13:47:05 <lambdabot> const (1 +)
13:47:09 <Botje> ah.
13:47:12 <Saizan> have you ever had to change a lot of type signatures in a non-trivial way? what did you use?
13:47:19 <dons> SamB, more context please...
13:47:29 <dons> but Bool b is a good hint. an over-applied type
13:47:31 <sorear> dons: I think I've seen a proof somewhere
13:47:33 <SamB> well. it might be related to this GADT
13:47:34 <EvilTerran> > undefined :: Bool Int
13:47:36 <lambdabot>      Kind error: `Bool' is applied to too many type arguments
13:47:36 <lambdabot>     In the type...
13:47:43 <sorear> Saizan: sed
13:47:45 <dons> sorear: for Fc or something else?
13:47:51 <sorear> dons: for HM
13:48:08 <xerox> Saizan: Emacs macros are also very nice.
13:48:16 <dons> oh, that may well be true. it rings a bell. but for GHC right now... :)
13:48:27 <dons> SamB: Bool b pattern?
13:49:45 <dons> sorear: so are you back at school now?
13:49:49 <sorear> dons: it's a sufficiently important meta-result that if it turned out to be broken by GHC extensions I'd file a bug
13:49:52 <sorear> yes
13:50:19 <dons> oh, maybe we're talking about different things.
13:50:58 <dons> ah, maybe not. is the only way to introduce a kind error to write a kind-incorrect type, then. hmm.
13:51:02 <olivier_> could my ghc compile problem due to a switch of Architecture between my installed version (i386) and my compile target (x86_64) ?
13:51:08 <dons> oh!
13:51:11 <SamB> sorear: that doesn't mean it isn't making kind errors in it's attempt to infer the types
13:51:16 <dons> yes, quite possible. you can't cross compile ghc
13:51:48 <olivier_> dons: thanks, I'll compile to i386 then. ty v much!
13:52:04 <dons> olivier_: if you're on amd64 et al, you can get a 64 bit binary snapshot though
13:52:16 <olivier_> dons: nope, intel :/
13:52:34 <sorear> olivier_: intel makes amd64 processors
13:52:42 <sorear> olivier_: they call them em64t
13:52:58 <dons> olivier_: there's x86_64 ghc binaries on haskell.org/ghc
13:53:02 <olivier_> em64t is a standard that amd64 and intel 64bit processor comply to, no?
13:53:03 <sorear> because, of course, the name amd is taboo
13:53:04 <dons> which you can use to bootstrap your own compile
13:53:13 <olivier_> cool thanks
13:53:27 <dons> sorear: except in openbsd, since they had an amd64 port very early on. the result is a lot of broken configure.ac checks :(
14:11:16 <Lycurgus> Randroid: how's that FIOS?
14:11:29 <Lycurgus> oh, gone.
14:20:11 <thn_> Is there a Fractional Integral type?
14:20:12 <phobes> If you have overlapping instances, there's no way to specify that you want it to pick one instance when in one section of code and another instance in another section, right?
14:22:41 <sorear> thn_: i think you have types and type classes confused
14:24:38 <EvilTerran> phobes, if you want different instances for the same type and class in different places, the normal approach is to make a newtype of the type for one of the instances
14:25:08 <thn_> Is there a Fractional Integral class?
14:25:18 <phobes> EvilTerran: makes sense
14:25:18 <EvilTerran> > mappend (Sum 1) (Sum 2)
14:25:19 <lambdabot>  Sum {getSum = 3}
14:25:26 <EvilTerran> > mappend (Product 1) (Product 2)
14:25:28 <lambdabot>  Product {getProduct = 2}
14:25:38 <EvilTerran> ?type Sum
14:25:40 <lambdabot> forall a. a -> Sum a
14:25:47 <EvilTerran> ?type mappend
14:25:49 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:26:25 <sorear> thn_: you don't need one, because you can constrain a variable with multiple classes
14:26:33 <sorear> Fractional a, Integral a => a
14:26:43 <sorear> of course, there is no such type
14:33:24 <olivier_> dons: wb - the cross compile (i386 - x86_64) was the pb, I'm now on stage 2 everything going great. Thanks v much!
14:33:39 <dons> sweet.
14:33:48 <dons> for x86 or x86_64?
14:34:29 <olivier_> ended up doing the x86 version, I don't care too much about performance at this point
14:36:11 <dons> cool
14:44:17 <rafaelkbraw> hi, how to accessing an data type property such as Dt.Dt2.b in somthing like that data Dt= Dt1 Dt2   data Dt1 = {a :: Int, b :: String}      data Dt2 = {a :: Int, b :: String} ?
14:45:47 <int-e> ?
14:45:50 <sjanssen> first, those data declarations aren't syntactically correct
14:46:02 <sjanssen> data Dt1 = Dt1 {a :: Int, b :: String}
14:46:10 <sjanssen> data Dt2 = Dt2 {a :: Int, b :: String}
14:46:22 <phobes> data Dt = Dt Dt1 Dt2 -- and this
14:46:40 <rafaelkbraw> yes... sorry
14:46:53 <sjanssen> secondly, the field names for Dt1 and Dt2 will clash
14:46:59 <dibblego> what module is sortBy in?
14:47:07 <sjanssen> dibblego: hoogle
14:47:11 <dibblego> ?hoogle sortBy
14:47:12 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
14:47:14 <int-e> Dt1 and Dt2 can't be declared like this in the same module.
14:47:16 <dibblego> ah thanks
14:47:23 <int-e> as sjanssen said
14:47:35 <rafaelkbraw> why ?
14:47:51 <int-e> because the accessors (a and b) are really functions.
14:47:54 <sjanssen> that's just how it works
14:47:56 <int-e> named a and b.
14:48:28 <rafaelkbraw> ok....
14:48:39 <sjanssen> it's similar to introducing two functions with different types in the same scope
14:48:48 <phobes> You could do:   data Dt = Dt1 {a :: Int, b :: String} | Dt2 { a::Int, b:: String} though
14:48:58 <rafaelkbraw> but if Dt2 = Dt2 {c :: Int, d :: String}
14:49:08 <rafaelkbraw> it's ok , no ?
14:49:15 <sjanssen> for example, you can't write "foo :: Int; foo = 2; foo :: Double; foo = 1.0"
14:49:20 <sjanssen> rafaelkbraw: yep, that'd fix it too
14:49:43 <phobes> The problem with what you have is that Dt1 and Dt2 are different types, so the type of 'a' or 'b' wouldn't be able to extract from both of them
14:49:50 <int-e> data Dt1 = Dt1 {a :: Int, b :: String} is roughly equivalent to  data Dt1 = Dt1 Int String; a :: Dt1 -> Int; a (Dt1 x _) = x; b :: Dt1 -> String; b (Dt1 _ y) = y;, ignoring the record update syntax (foo { a = bar })
14:50:32 <sjanssen> wo, we've got: data Dt1 = Dt1 {a :: Int, b :: String}; data Dt2 = Dt2 {c :: Int, d :: String}
14:50:37 <sjanssen> s/wo/so
14:51:07 <sjanssen> next: data Dt = Dt {one :: Dt1, two :: Dt2}
14:51:38 <sjanssen> we want to extract the 'a' field from the 'one' field in a Dt
14:51:51 <sjanssen> a . one -- that's all there is to it :)
14:52:46 <dibblego> ?uses
14:52:46 <lambdabot> Maximum users seen in #haskell: 407, currently: 359 (88.2%), active: 10 (2.8%)
14:52:52 <sjanssen> a (one myDt) -- if you find the pointfree form confusing
14:52:53 <dibblego> oh thanks for the typo fix :)
14:53:42 <rafaelkbraw> ok tks
14:56:31 <rafaelkbraw> and... anyone know about traverse recusive data types ?
14:57:06 <sjanssen> that is a vague question :P
14:57:36 <sjanssen> you probably want to use pattern matching and recursion?
14:58:11 <rafaelkbraw> ok... i would travese HsModule from Language.Haskell.Syntax
14:58:19 <sjanssen> ah
14:58:36 <rafaelkbraw> i 'm confused about an way do that
14:58:54 <sjanssen> you probably want to use generic traversal for such a large and complicated type
14:59:32 <rafaelkbraw> generc traversal ?
14:59:36 <sjanssen> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Undo.hs has an example
15:05:22 <cognominal_> @src until
15:05:23 <lambdabot> until p f x | p x       = x
15:05:23 <lambdabot>             | otherwise = until p f (f x)
15:06:23 <cognominal_> @t until
15:06:24 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
15:06:49 <cognominal_> @type until
15:06:51 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
15:07:59 <cognominal_> is there a way to summon lambdabot to join another channel to avoid bothering evyone with my interaction with the bot
15:08:13 <cognominal_> ??
15:08:19 <cognominal_> @thanks
15:08:19 <lambdabot> you are welcome
15:10:27 <sjanssen> cognominal_: lambdabot responds to /msg
15:11:12 <cognominal_> nice
15:20:24 <Daveman> welcome back, chessguy :)
15:22:14 <exDM69> where can I find the documentation of standard haskell functions?
15:22:52 <chessguy> danke
15:24:30 <chessguy> who ever heard of polymorphic literals, anyway
15:24:43 <chessguy> @doc prelude
15:24:43 <lambdabot> prelude not available
15:25:26 <chessguy> exDM69, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
15:25:28 <lambdabot> http://tinyurl.com/y4wexy
15:29:55 <wli> :t 0
15:29:57 <lambdabot> forall t. (Num t) => t
15:41:11 <wli> cognominal: Try /msg
15:44:21 <sorear> why would a bot NOT respond to /msg?
15:44:38 <sorear> @where report
15:44:38 <lambdabot> http://www.haskell.org/onlinereport/
15:44:45 <sorear> exDM69: that too ^^^
15:45:41 <monochrom> @quote monochrom
15:45:41 <lambdabot> monochrom says:  (<3) is the Haskell love operator :)
15:45:47 <monochrom> hehe
15:46:18 <FMota> lol
15:46:20 <monochrom> perhaps your msg never reached it.
15:48:40 <EvilTerran> you have to be registered with services for it to hear you, iirc
15:49:08 <kaol> > foldM (\xs y -> do (x:xr) <- xs; guard (x == y); return xr) "hello" "helloabc"
15:49:09 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
15:49:09 <lambdabot>       Expected...
15:49:31 <sorear> kaol: xs is a value, not an action
15:50:08 <sorear> kaol: so <- return xs, or use foldl
15:51:09 <kyevan> Hmm, I dare someone to sign their trainer card in Pokemond Diamond/Pearl with a haskell program. It's probably the only way to beat my nearly-legible D'ni transcription in oddness.
15:51:15 <kaol> > (foldM (\xs y -> do (x:xr) <- return xs; guard (x == y); return xr) "hello" "helloabc")::(Maybe String)
15:51:17 <lambdabot>  Nothing
15:51:23 <kaol> > (foldM (\xs y -> do (x:xr) <- return xs; guard (x == y); return xr) "helloabc" "hello")::(Maybe String)
15:51:24 <lambdabot>  Just "abc"
15:51:57 <kaol> that's what I wanted. thanks.
15:53:07 <kyevan> ?type Just Nothing
15:53:09 <lambdabot> forall a. Maybe (Maybe a)
15:56:47 <cognominal_> @src uncurry
15:56:48 <lambdabot> uncurry f p = f (fst p) (snd p)
15:57:03 <EvilTerran> uncurry f ~(x,y) = f x y
15:57:12 <EvilTerran> if you prefer
15:57:35 <P_D> ~ ?
15:57:58 <EvilTerran> > (\True -> 1) undefined
15:58:00 <lambdabot>  Undefined
15:58:01 <EvilTerran> > (\~True -> 1) undefined
15:58:01 <lambdabot>  Parse error
15:58:06 <EvilTerran> hm.
15:58:17 <Cale> P_D: it means that it'll only bother to do the pattern matching if the variables matched are used
15:58:18 <EvilTerran> > let f ~True = 1 in f undefined
15:58:19 <lambdabot>  1
15:58:22 <EvilTerran> > let f True = 1 in f undefined
15:58:24 <lambdabot>  Undefined
15:58:30 <EvilTerran> there's the difference
15:58:54 <Cale> > let f ~[] = 5 in f [1,2,3]
15:58:56 <lambdabot>  5
15:59:07 <Botje> so is it ever useful to have a lazy pattern match if there's more than one case?
15:59:19 <Cale> Even if the pattern doesn't match, you don't get an error unless something matched is actually needed.
15:59:26 <EvilTerran> as the last case, perhaps
15:59:45 <P_D> I don't see what this does other than enforce a type
15:59:54 <EvilTerran> > uncurry (const (const 1)) undefined
15:59:55 <lambdabot>  1
15:59:57 <kyevan> Hmm...
16:00:03 <Botje> but the damage is done, it's already evaluated by then?
16:00:03 <EvilTerran> > (\f (x,y)->f x y) (const (const 1)) undefined
16:00:05 <lambdabot>  Undefined
16:00:10 <wli> You can occasionally use the variables defined in the pattern match.
16:01:11 <EvilTerran> as in the case of uncurry f ~(x,y) = f x y; the definition of uncurry uses x and y, but, if f doesn't, it's still okay
16:01:16 <koeien> > let f p ~[x] = if p then Nothing else Just x in f True []
16:01:18 <lambdabot>  Nothing
16:01:24 <kyevan> Enumerated types can be a pain, when you have lots of things you need to give names too
16:01:25 <koeien> > let f p ~[x] = if p then Nothing else Just x in f False []
16:01:27 <lambdabot>   Irrefutable pattern failed for pattern [x]
16:01:51 <Botje> ah.
16:01:53 <kyevan> Like for alphabets that aren't in Unicode for one reason or another...
16:02:05 <Botje> koeien++ #that makes sense
16:02:23 <koeien> i didn't know the feature either... could be useful sometime
16:02:26 <kyevan> (As often as not, because they're owned by someone/some company. Cirth, D'ni script, etc...)
16:06:59 <kyevan> Can type constructors be single letters?
16:07:24 <EvilTerran> yes
16:07:26 <koeien> sure
16:07:34 <EvilTerran> as long as they haven't been used somewhere else
16:08:37 <kyevan> so data DniChar = V | B | T | S | Sh | J... is theoreticly valid?
16:08:45 <EvilTerran> yup
16:08:49 <koeien> yes
16:09:03 <kyevan> (I have reasons other than D'ni characters, but it makes a fun example, no?)
16:09:28 <wli> What's D'ni?
16:09:30 <idnar> D'ni as in Myst?
16:09:38 <kyevan> idnar: Yep.
16:09:40 <wli> Oh good it's not Gorean.
16:09:40 <idnar> awesome
16:10:23 <kyevan> I should write that whole thing out sometime, for the heck of it :P
16:10:59 * wli replaces fst and snd with quick and dirty typeclasses and augments them with thd, frth, and ffth.
16:11:55 <EvilTerran> if you're following the pattern of the standard libraries, you should probably go up to sxth and svnth
16:12:06 <kyevan> why not sxth, snth, eth, nth, wli?
16:12:10 * EvilTerran still isn't sure why they go up to seven, but still...
16:12:32 <wli> It's an easy enough cut & waste job. svth it is.
16:12:56 <EvilTerran> do you have a type for the 1-tuple?
16:13:07 <idnar> why are they abbreviated so clumsily? :P
16:13:16 <kyevan> ?type (1)
16:13:24 <lambdabot> forall t. (Num t) => t
16:13:46 <kyevan> Hmm, I don't think 1-tuples exist >_>
16:14:09 <koeien> ?type (1,)
16:14:11 <lambdabot> parse error on input `)'
16:14:59 <EvilTerran> you'd have to make a newtype Single a = Single a or something, if you wanted to write instances for it
16:15:43 <wli> Done.
16:16:00 <EvilTerran> it'd be purely for completeness, so Single could be the first instance of Fst instead of (,) being so
16:16:17 <wli> I can't be arsed.
16:16:40 <EvilTerran> fairy nuff
16:16:41 <wli> first and second already got co-opted by Arrow
16:17:10 <wli> >> svth ('a', 'b', 'c', 'd', 'e', 'f', 'g')
16:17:10 <wli> 'g'
16:18:23 <kyevan> EvilTerran: I thought you said... something else, for a moment there
16:19:20 <EvilTerran> kyevan, don't worry, that was the sensible interpretation of what i said. calling it a "1-tuple"'s a bit silly
16:19:55 <ddarius> You can have 1-tuples they're just isomorphic to the "object" they "contain".
16:20:25 <idnar> what about 0-tuples? ;)
16:20:52 <ddarius> Yep.
16:20:54 <ddarius> :t ()
16:20:56 <lambdabot> ()
16:22:06 <idnar> I guess you wouldn't have any instances for those, though
16:23:04 <EvilTerran> if you had class Tuple a t | t -> a where length :: t -> Int, you could, say
16:23:39 <EvilTerran> then class Tuple a t => Fst a t where fst :: t -> a; etc
16:24:15 <idnar> well, it's not like fst () makes any sense
16:25:44 <SamB> EvilTerran: I have a languishing family of classes a bit like that...
16:25:54 <EvilTerran> you'd still instance Tuple a () where length = 0
16:26:15 <EvilTerran> length _ = 0, rather
16:26:18 <SamB> except mine doesn't have a Tuple analogue...
16:27:22 <EvilTerran> that was just an excuse to have an instance of something for (), really. i can't imagine it'd be that useful.
16:30:13 <augustss> Haskell should have a one-tuple.  It's annoying that it doesn't
16:30:36 <ddarius> augustss: Haskell doesn't have any tuples.
16:30:41 <jcreigh> augustss: really? What would the use of such a thing be?
16:30:41 <kyevan> EvilTerran: No, you said 'fairy nuff' and my mind made that... not appropreate.
16:30:51 <EvilTerran> ahh
16:31:13 <augustss> ddarius: Haskell doesn't have any tuples?
16:31:37 <ddarius> Well, not categorical products.
16:31:53 <ddarius> It does have a "tensor" product though.
16:32:11 <sysfault__> lt
16:32:15 <ddarius> (at least, it doesn't naively()
16:32:17 <augustss> jcreigh: I've missed the one-tuple on several occasion, but the examples to show it are a bit involved.  But they have been about extracting data from a relation
16:32:44 <augustss> ddarius: I wasn't talking about categorical products.  I don't care about those :)
16:32:45 <ddarius> It would help avoid overlapping.
16:32:54 <ddarius> augustss: I do somewhat.
16:33:29 <ddarius> But a symmetric monoidally closed category is pretty nice itself still.
16:34:02 <ddarius> Haskell doesn't (or shouldn't) require weakening down to a pre-monoidal category.
16:36:01 <augustss> ddarius: Haskell has non-termination.  It messes up everything anyway.
16:37:08 <augustss> I can live with the lifted product in Haskell, what I dislike is the lifted function space (which Haskell did have originally)
16:37:17 <augustss> s/did/didn't/
16:38:40 <dolio> That's due to seq?
16:38:44 <augustss> yes
16:40:32 <augustss> tuples in Haskell behave like the Church encoding of tuples lambda calculus, so I'm pretty happy with that
16:41:30 <sorear> augustss: didn't?  how long ago?
16:41:42 <augustss> Before seq
16:41:49 <dolio> Back when the Eval class existed, presumably?
16:41:55 <sorear> nope
16:42:06 <sorear> I read the 1.3 report, Eval (a -> b) existed
16:42:07 <augustss> Yes.  And before Eval existed.  No seq at all
16:42:14 <dolio> Ah.
16:42:34 <augustss> sorear: yes, Eval (a->b) was a mistake, IMO
16:42:57 <augustss> But at least it could be removed easily in those days
16:42:59 * dolio would have thought that (a -> b) not being a member would be one of the advantages of the Eval class.
16:43:02 <wli> I'll settle for monad comprehensions, killing fail from Monad, mzero desugaring for pattern match failures in do blocks, and so on.
16:43:24 <augustss> wli: like the good old days! :)
16:43:57 <wli> I've found where to put monad comprehensions but I'm too clueless/incompetent to carry it out.
16:44:14 <edward1> looking through ghc, wli?
16:44:20 <wli> edward1: Yes.
16:44:37 <augustss> I can't believe they took the code out
16:44:40 <edward1> yeah, i found the spot too, but was worried about the impact of it on the existing optimizations there.
16:44:44 <augustss> I would have added a flag
16:44:56 <wli> #ghc people say to add a flag, yes.
16:45:07 <edward1> at last year's icfp marlow said he'd accept a patch that added a -fmonad-comprehensions
16:45:20 <augustss> in fact, that's what I did for hbc when monad comprehensions went out of style
16:45:22 <swix> I've been looking everywhere, but how do you convert between numeric types? eg. make (5 / 2) in to an Int?
16:45:30 <EvilTerran> ?type floor
16:45:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:45:38 <EvilTerran> ?type fromIntegral
16:45:40 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:45:45 <edward1> > floor (5 / 2)
16:45:47 <lambdabot>  2
16:45:52 <augustss> swix: floor, ceiling, truncate, round
16:46:02 <swix> I tried floor, but take requires me to give it an Int
16:46:11 <swix> unless there some automatic conversion that's failing
16:46:14 <augustss> floor gives you an Int
16:46:20 <wli> The fact is I'm very unlikely to ever make forward progress on any of this so whoever else can do this probably should.
16:46:34 <edward1> floor will take any RealFrac type and return any Integral type
16:47:04 <augustss> > floor (5%2) :: Word8
16:47:07 <lambdabot>  2
16:47:45 <ddarius> @src RealFrac
16:47:45 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
16:47:45 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
16:47:45 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
16:48:08 <augustss> > properFraction (5/2)
16:48:10 <lambdabot>  (2,0.5)
16:51:20 <swix> oh, my problem is actually, "length  [1,2,3] / 2" and I get type errors
16:51:44 <ddarius> :t (/)
16:51:46 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:52:01 <EvilTerran> :t (`div`)
16:52:02 <lambdabot> parse error on input `)'
16:52:06 <EvilTerran> :t div
16:52:08 <lambdabot> forall a. (Integral a) => a -> a -> a
16:52:45 <swix> :t length
16:52:47 <lambdabot> forall a. [a] -> Int
16:52:59 <swix> yeah, you can't go Int / Integral ?
16:53:31 <EvilTerran> Integral is not a type, it's a typeclass
16:53:37 <EvilTerran> ?instances Integral
16:53:38 <lambdabot> Int, Integer
16:54:21 <augustss> swix: you want div
16:54:35 <swix> k
17:06:44 <augustss> @quote
17:06:45 <lambdabot> emonk says: Quien desmorruga?
17:07:29 <augustss> @quote
17:07:30 <lambdabot> numerodix says: tbh people who do haskell on their own initiative kinda creep me out :)
17:07:43 <Botje> @quote fur
17:07:43 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
17:07:43 <lambdabot>  what you just said?"
17:13:33 <augustss> @quote
17:13:33 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
17:13:44 <newsham> best curry-howard intro I've seen:  https://cgi.cse.unsw.edu.au/~cs4181/07s2/cgi-bin/moin.cgi/Schedule?action=AttachFile&do=get&target=proofs-rl.pdf
17:13:45 <lambdabot> http://tinyurl.com/yugtpp
17:14:06 <newsham> who's roman leshchinskiy?  does he irc?
17:14:23 <sorear> a ghc hacker, and no
17:14:36 <sorear> he's mostly responsible for NDP
17:14:51 <newsham> whats that?
17:17:03 <augustss> Looks like a good C-H intro, yes
17:18:13 <newsham> also he goes into NOT, thats beyond c-h, right?
17:18:40 <augustss> no
17:18:47 <augustss> not really
17:19:25 <newsham> i thought curry-howard was about logic without negation
17:19:25 <augustss> but he doesn't go into the really cool parts of C-H, which is quantifiers
17:20:25 <augustss> there's nothing wrong with negation, it's just implication of the absurdity
17:21:03 <augustss> so once you have the absurd proposition you can have negation
17:21:35 <newsham> slide 10 has p /\ ~p -> false, and slide 13 has absurd :: (p -> q) -> (p -> NOT q) -> NOT p
17:22:35 <augustss> what I call the absurd proposition he calls FALSE.  It has many names
17:23:13 <augustss> The empty type
17:24:27 <augustss> @djinn (p->q) -> (p -> Not q) -> Not p
17:24:27 <lambdabot> f a b c = b c (a c)
17:25:07 <newsham> intuitionistic vs classical.
17:26:08 <sorear> CH relates computable languages to intuitionistic logics - consider the classical tautology forall x : TuringMachine, Halts x \/ ~Halts x
17:26:20 <newsham> so this roman guy is a guest lecturer and not a student doing a report?
17:26:55 <augustss> He's a PhD student
17:27:04 <augustss> I think
17:30:46 <asl> has anyone messing witht he new type families run into the ever helpful error: "Couldn't match expect type Elem t against inferred type Elem t"?
17:31:06 <asl> (in the case of generic collections)
17:31:54 <newsham> ok, when he starts getting into the gadt stuff my head is hurting
17:32:08 <Mr_Awesome> if i have a data type with multiple constructors, are any predicates defined to determine which constructor an object is, or must i use pattern matching?
17:32:36 <asl> Mr_Awesome:  you can write the predicates using pattern matching pretty quick
17:32:41 <SamB> Mr_Awesome: you basically have to write your own predicates
17:32:42 <asl> but I don't think any come for free
17:32:51 <SamB> you could use drift or derive though
17:33:43 <Mr_Awesome> drift or derive?
17:34:06 <asl> drift: http://repetae.net/john/computer/haskell/DrIFT/
17:34:07 <lambdabot> Title: DrIFT Homepage
17:34:58 <augustss> Mr_Awesome: it's rare that you need to test what constructor something is like that.  So if you do, you need to define the function yourself
17:35:38 <augustss> but most often there's a better way of writing it
17:35:40 <asl> yeah, when you define your functions on your type using pattern matching it's pretty clear which case you're dealing as your input
17:37:06 <Mr_Awesome> right, i see what youre saying
17:37:27 <asl> anyway, here's the hpaste for my question re. type families, if anyone wants to take a look.  It's a conversion of one of the classes used in the collections package to use indexed types: http://hpaste.org/2860#a0
17:38:04 <asl> it feels like a mostly mechanical conversion except for the weird type-check error I get.
17:38:24 <augustss> asl: I suspect that type families still have a lot of bugs
17:38:47 <asl> augustss: at the least, I'd consider an error this useless to be a bug in itself :-)
17:39:10 <augustss> asl: absolutely.  report it
17:43:10 <Qerub> Do I need to do anything special to export constructors from a module?
17:43:34 <ddarius> No.
17:43:40 <asl> Qerub: if you
17:43:55 <augustss> Qerub: yes, you need to export T(..)
17:44:02 <augustss> if T is your type
17:44:05 <asl> Querub: if you're using an export list, you need to export the type like so:  Type(...)
17:44:07 <ddarius> Yes, if you are explicitly exporting things, no if you aren't.
17:44:22 <ddarius> Or Type(Constructor1, Constructor2)
17:44:58 <Qerub> T(…) worked perfectly.
17:45:00 <Qerub> Thank you!
17:45:14 <Qerub> (Sorry, it's late here over here…)
18:02:55 <Qerub> What's the prettiest way to do [a,b,c] -> [a,b,c,a,b,c]?
18:03:24 <dons> \x -> x ++ x
18:03:26 <dons> ?
18:03:30 <dons> ?pl \x -> x ++ x
18:03:31 <lambdabot> join (++)
18:04:17 <dons> > join (++) ['a','b','c']
18:04:19 <lambdabot>  "abcabc"
18:04:38 <idnar> hmm
18:04:41 <kpreid> > (concat . replicate 2) ['a','b','c']
18:04:42 <lambdabot>  "abcabc"
18:05:07 <idnar> oh, (->) monad
18:05:13 <idnar> man, that always confuses me
18:05:42 <dons> yeah, \x becomes the `state' acted upon
18:06:10 <Qerub> I like kpreid's!
18:06:13 <Qerub> Thanks a lot.
18:06:19 <idnar> (-> r) monad even
18:09:03 <lament> i like join (++) because i have no idea what it does.
18:09:48 <idnar> *chuckle*
18:10:01 <idnar> :t join (++)
18:10:03 <lambdabot> forall a. [a] -> [a]
18:10:14 <idnar> meh
18:10:22 <idnar> join (++) :: (Monad ((->) [a])) => [a] -> [a]
18:10:48 <kpreid> > join (,) 5
18:10:48 <lament> @src join
18:10:48 <lambdabot> join x =  x >>= id
18:10:49 <lambdabot>  (5,5)
18:10:56 <kpreid> > join (++) "5"
18:10:58 <lambdabot>  "55"
18:11:18 <kpreid> > join (+) 5
18:11:18 <P_D> > join (+) 5
18:11:20 <lambdabot>  10
18:11:21 <lambdabot>  10
18:11:54 <kpreid> > join replicate 7
18:11:55 <idnar> ?unpl join f
18:11:55 <lambdabot> (f >>= \ a -> a)
18:11:55 <lambdabot>  [7,7,7,7,7,7,7]
18:12:35 <P_D> ?pl \x -> f x x
18:12:36 <lambdabot> join f
18:13:30 <kpreid> > join id ((1:) . fix)
18:13:31 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
18:13:32 <lambdabot>     Probab...
18:13:32 <P_D> > (++ >>= id) "x"
18:13:33 <lambdabot>  Parse error
18:13:36 <dons> join replicate 7 is cute
18:14:03 <kpreid> > join id (\f x -> 1 : f x)
18:14:05 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
18:14:05 <idnar> heh
18:14:05 <lambdabot>     Probab...
18:14:26 <P_D> :t \ a -> a
18:14:28 <lambdabot> forall t. t -> t
18:14:31 <kpreid> > join id (\f x -> 1 : f id x)
18:14:32 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
18:14:33 <lambdabot>     Probab...
18:14:53 * kpreid switches to ghci
18:15:16 <kpreid> ah, I see, join id is itself sufficient to lose
18:16:28 <kpreid> > join enumFromBy 5
18:16:30 <lambdabot>   Not in scope: `enumFromBy'
18:19:02 <kpreid> @pl join const
18:19:03 <lambdabot> join const
18:19:10 <ihope_> > ((1:) . fix) ((1:) . fix)
18:19:11 <idnar> heh
18:19:11 <lambdabot>  Couldn't match expected type `[t]' against inferred type `a -> a'
18:20:37 <chessguy> @type const join
18:20:38 <shachaf> > join enumFromThen 5
18:20:42 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
18:20:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => b -> m (m a) -> m a
18:21:43 <kpreid> > let enumFromBy f b = enumFromThen f (f + b) in join enumFromBy 5
18:21:45 <lambdabot>  [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120...
18:23:58 <shachaf> @pl \f b -> enumFromThen f (f + b)
18:23:58 <lambdabot> liftM2 (.) enumFromThen (+)
18:24:48 <lament> oh god.
18:25:52 <dons> :t liftM2 (.) enumFromThen (+)
18:25:54 <lambdabot> forall a. (Enum a, Num a) => a -> a -> [a]
18:26:03 <dons> :t (.) <$> enumFromThen <*> (+)
18:26:06 <lambdabot> forall a. (Enum a, Num a) => a -> a -> [a]
18:26:20 <dons> that's got to be something else
18:26:29 <kpreid> :t liftM2 (.)
18:26:31 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
18:26:39 <dons> :t ap
18:26:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:27:23 <shachaf> dons: Is the Applicative version really more readable for you than the liftM2 version?
18:28:00 <dons> i don't think so, no.
18:28:03 <kpreid> it's just `ap` :)
18:28:03 <lament> haskell: the self-obfuscating programming language
18:28:14 <dons> just practicing with applicatives. :)
18:28:22 <dons> they're good in instances of Binary though
18:28:26 <kpreid> lament: we're just having fun
18:28:28 <lament> haskell programmers are like perl programmers in that they think a program is better when it's unreadable
18:28:33 <lament> :)
18:28:43 <dons> do not take code fragments in #haskell as guaranteed examples of good style :)
18:29:04 <dons> well, we like clarity of ideas
18:29:15 <dons> so getting at the essence of some algorithm, and abstracting away glue and clutter
18:29:40 <phobes> and letters
18:29:49 <kpreid> no, no, haskell programmers are like OO programmers in that programs are considered better when built on a mountain of layered abstractions :)
18:30:09 <dons> no mountains though. thin sheets of ice perhaps
18:30:13 <dons> ?src <$>
18:30:13 <lambdabot> f <$> a = fmap f a
18:30:21 <kpreid> (the difference being, of course, entirely in the nature and reusability of your abstractions)
18:30:24 <dons> *thin abstraction, but foundational*
18:30:49 * kpreid thinks Haskell could use fewer names for map/fmap/./<$>/liftM
18:31:05 <Qerub> Good night people.
18:31:21 <sioraiocht> :t liftM
18:31:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:31:46 <sioraiocht> kpreid: overhaul the type class sytem, then =p
18:31:54 <chessguy> huh? (.) is not fmap
18:32:06 <chessguy> nor is map
18:32:06 <sioraiocht> @src (->) fmap
18:32:07 <lambdabot> fmap = (.)
18:32:20 <sioraiocht> @src [] fmap
18:32:20 <lambdabot> fmap = map
18:32:21 <sioraiocht> =
18:32:21 <kpreid> @src [] fmap
18:32:22 <sioraiocht> =p
18:32:22 <lambdabot> fmap = map
18:32:22 <chessguy> well, in one particular monad maybe
18:32:54 <kpreid> well, per Cale it *should* be fmap :)
18:33:25 <Cale> hehe
18:33:27 <chessguy> well i certainly won't question the wisdom of the great Cale
18:33:34 <Cale> hah
18:34:03 <Cale> I'm not 100% sure whether it would be best to make (.) general functor application, but it seems like a nice idea.
18:34:39 <Cale> Function composition and functor application are two of the most important operations in functional programming -- it's rather nice that they can be unified.
18:41:55 * kpreid wonders if <something> f => (f a -> f b) -> a -> b has any interesting applications
18:42:06 <Mr_Awesome> if i import IdentityList and have a file called identityList.hs that defines that module in the include path, shouldnt hmake find it?
18:42:23 <olsner> what is a functor exactly? in my (C++) mind, a functor is just a function object or an abstraction of a function
18:42:31 <kpreid> olsner: unrelated thing
18:42:45 <kpreid> olsner: a functor is a parameterizable container of some sort
18:43:09 <kpreid> @src Functor
18:43:10 <lambdabot> class  Functor f  where
18:43:10 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:43:12 <twanvl_> Mr_Awesome: The file should be IdentityList.hs (with a capital i)
18:43:21 <kpreid> olsner: that's the entirety of the definition
18:43:24 <olsner> kpreid: as in, you can apply a function to the contained value but not explicitly insert any value into the functor?
18:43:32 <Mr_Awesome> twanvl_: i see. thanks
18:43:52 <kpreid> olsner: right, if you don't know anything else.
18:44:08 <kpreid> olsner: of course, you can replace everything with one value: "fmap (const 42)"
18:44:37 <asl> olsner: a functor is some sort of parameterized type where there's a way to lift functions "up to" the type
18:44:41 <kpreid> > fmap (const 42) "abc"
18:44:43 <lambdabot>  [42,42,42]
18:44:43 <kpreid> > fmap (const 42) ""
18:44:45 <lambdabot>  []
18:45:20 <asl> olsner: They aren't always a container, for example as people were having fun with earlier in here, the function type is a functor
18:45:34 <olsner> oh, that's a nice way to insert arbitrary values.. but still, you'd need some function that "lifts" some original value "into the functor"
18:45:49 <asl> yep.  the lifting function defines the functor
18:45:52 <kpreid> olsner: that's *not part of what a functor is*
18:46:09 <twanvl_> Then you are halfway to an Applicative functor or Monad
18:46:12 <phobes> I thought usual terminology was that the lifting function _was_ the functor?
18:46:44 <asl> phobes:  usually I think it's the type that's referred to as a "functor"
18:47:02 <idnar> I don't think that operation is usually called "lifting", is it?
18:47:26 <phobes> idnar:  all kinds of things are called lifting, afaict
18:47:29 <kpreid> olsner: if you have an "put in one value" operation, then that's ...hmm, I don't know of a name for it. it's like Monad's "return", but we haven't got a >>= or join so the thing isn't a monad yet.
18:47:33 <idnar> ok
18:47:54 <twanvl_> There is liftM which is (should be) the same as fmap
18:48:12 <asl> twanvi_:  yeah, that's where I was coming from with "lifting"
18:48:16 <olsner> hmm, but... given (fmap f :: f a -> f b), unless you also have some function (exists a. a -> f a), the functor is pretty much useless?
18:48:45 <idnar> olsner: well, I think usually you'd create it using specific means
18:49:03 <olsner> yeah, but that specific means is also, in some meaning, part of the functor
18:49:15 <idnar> right, but not the Functor type class
18:49:16 <asl> olsner: we could have some library defined that gives us values already in the functor, for whatever reason, and hides the direct way to construct them
18:49:19 <phobes> olsner: No
18:49:51 <idnar> > fmap (+1) [1, 2, 3]
18:49:53 <lambdabot>  [2,3,4]
18:49:58 <kpreid> olsner: not useless
18:50:08 <kpreid> olsner: for example ... oops, doesn't work. never mind
18:50:15 <olsner> unless the functor has some means of producing values "in the functor" (i.e. of type f a), the functor can't do anything, right?
18:50:48 <kpreid> olsner: take data Pair a = Pair a a
18:51:04 <kpreid> olsner: that has an obvious functor instance, but there's no obvious general a -> f a
18:51:11 <idnar> well, obviously any data type is useless if you have no way of constructing or otherwise obtaining a value
18:51:47 <asl> > fmap succ succ $ 1
18:51:48 <lambdabot>  3
18:51:50 <olsner> hmm... I guess I might be stating the obvious or making otherwise meaningless statements, yes
18:52:45 <olsner> actually, I think the class definition for Functor told me most of what I was originally asking for..
18:52:57 <idnar> :)
18:52:58 <kpreid> olsner: nah, it was a decent question
18:53:33 <kpreid> but yes, the class def tells you everything fundamental about Functor. what it doesn't tell you is what it's good for
18:53:43 <olsner> well, Monad has return, but Functor is interesting because the class lacks an "insertIntoThingy" function
18:54:10 <kpreid> olsner: for more brain twisting, take a look at Comonad!
18:54:32 <olsner> I did... it only has "takeOutOf" :P
18:54:38 <olsner> and that's just twisted
18:54:57 <olsner> I'd need an actual Comonad instance to make car or cdr out of that one :P
18:55:07 <phobes> olsner:  But Monads are equally useless if you just have return and <<=, because you don't have any way to take things out of the monad
18:55:43 <phobes> olsner:  The point is that there's a richer structure present, and the Monad or Functor just isolate a substructure
18:56:39 <olsner> phobes: yeah, kind of what interfaces does for objects (methinks me groks)
18:56:44 <olsner> *do
18:57:01 <phobes> ya
19:21:09 <pjd> kpreid: if the obvious Pair functor instance is fmapping across both values, the obvious a -> f a would be to duplicate a
19:25:49 <Saizan> ?djinn a -> (a,a)
19:25:50 <lambdabot> f a = (a, a)
19:25:57 <sorear> pjd: consider data Void
19:26:05 <sorear> pjd: rather data Void a
19:26:27 <sorear> pjd: instance Functor Void where fmap fn x = case x of {  } -- yep, exhaustive!
19:26:46 <sorear> pjd: what should your forall f a. Functor f => a -> f a   do?
19:28:12 <pjd> it wouldn't
19:28:47 <pjd> does that relate to data Pair a = Pair a a ?
19:28:54 <idnar> how does that work?
19:30:11 <idnar> I don't understand how you could ever invoke that fmap
19:30:11 <ddarius> (.) should no more be fmap anymore than second should
19:30:55 <ddarius> pjd: pairs are defined by an adjunction that (as do all adjunctions) form a monad.
19:31:33 <ddarius> s/form/give rise to/
19:32:04 <ddarius> The unit of that adjunction (and the corresponding monad) is exactly dup :: a -> (a,a)
19:33:10 <pjd> awesome
19:34:39 <ddarius> The counit of the adjunction is the pair of fst and snd
19:37:10 <Saizan> ddarius: counit :: w a -> a? isn't it fst (or snd)?
19:38:00 <pjd> hmm
19:38:51 <Saizan> ah no, because you compose the functors in the other way, right?
19:40:16 <Cale> ddarius: But second is fmap :)
19:41:02 <ddarius> Cale: second is an instance of fmap, it isn't fmap itself which is my point.  Would you find writing second (+1) [1,2,3] ~> [2,3,4] sensible?
19:41:40 <Cale> ddarius: Well, not particularly. But (+1) . [1,2,3] = [2,3,4] doesn't really bother me
19:42:02 <ddarius> Saizan: The counit (of this particular adjunction) operates in the product category; so in this case (meta-)pairs of types and pairs of functions.
19:43:18 <ddarius> Cale: It's exactly analogous.  (.) is just a special case of fmap.  Admittedly, somewhat more important than many others, but all the others aren't (readily at least) instances of it.
19:43:27 <Cale> Having (.) as a general notation for functor application doesn't seem to hurt though.
19:43:52 <idnar> well, I think it's more a case of renaming fmap to (.)
19:43:53 <Cale> Naming general functor application "second" seems silly, of course.
19:44:08 <Cale> But naming it (.) doesn't seem so silly.
19:44:13 <ddarius> Cale: Why not?
19:44:41 <Cale> Because (.) isn't a word.
19:44:52 <ddarius> It still has connotations.
19:45:10 <Cale> Connotations which are mostly pretty consistent with general functor application.
19:45:12 <ddarius> And denotations for that matter.
19:45:56 <ddarius> Cale: How? How any more so than second?
19:47:25 <pjd> second begs first
19:48:05 <kyevan> > (9 * 25) + 13
19:48:07 <lambdabot>  238
19:48:11 <kyevan> > 9 * 25 + 13
19:48:13 <lambdabot>  238
19:48:57 <Cale> One way to think of values in the type (f a), for some functor f is as functions from positions in an appropriate structure to a.
19:49:13 <ddarius> pjd: first is also an instance of a functor action.  Haskell just doesn't support instantiating Functor for it.
19:49:51 <Cale> Applying the functor to a function from a -> b then is composition of this function with that labelling function.
19:50:00 <pjd> ddarius: i mean as a spelling of functor application, instead of (.)
19:50:00 <ddarius> Cale: Indeed, Pair a becomes Bool -> a, but fmap (+1) (Pair 2 3) doesn't compose with that.
19:50:25 <ddarius> pjd: I can find plenty of examples that don't have that problem.
19:50:34 <Cale> It doesn't?
19:50:37 <pjd> like (.) :)
19:50:45 <ddarius> (+1) doesn't have type X -> Bool.
19:50:45 <Cale> Sure it does.
19:50:59 <ddarius> Sorry, wrong example.
19:51:02 <Cale> (+1) has type X -> Y for appropriate X and Y
19:51:02 <ihope_> > tan (atan 100)
19:51:03 <lambdabot>  100.0
19:51:13 <ihope_> Wow, accuracy.
19:51:42 <Cale> You have a function Bool -> a, and a function a -> b, then you can get a function Bool -> b
19:51:46 <Cale> which is exactly what you need
19:54:09 <Saizan> ?type let (.) f = fmap f in (words .) . lines . readFile "foo" -- i don't know if it's pretty or obfuscating
19:54:11 <lambdabot> IO [[String]]
19:54:34 <idnar> ?unpl (words .) . lines
19:54:35 <lambdabot> (\ d g -> words (lines d g))
19:54:37 <Cale> This probably follows in some way from Yoneda's lemma. :)
19:54:51 <idnar> eek
19:54:53 <ddarius> Indeed
19:55:06 <ddarius> That hence the "readily at least".
19:55:15 <Saizan> idnar: (words .) = map words, there
19:55:20 <lokik> hey i put up a LOGJbang tokenizer written in haskell http://tcana.info/valsi.hs  if you're interested also mild description in blog post: http://lokamaf.blogspot.com/2007/09/logjbang-tokenizer.html
19:55:28 <platypus> Cale: What is Yoneda's lemma?
19:55:33 <ddarius> You can view many Haskell data types and perhaps all that are functors in such a way, but not readily.
19:55:38 <ddarius> (in all instances)
19:55:41 <idnar> Saizan: yeah
19:56:04 <idnar> Saizan: I realised that afterwards
19:56:27 <Saizan> idnar: a bit obfuscated then :)
19:56:40 <idnar> Saizan: well, I sort of glossed over the let for some reason
19:57:19 <lokik> less than 220 lines of code
19:57:22 <lokik> :)
19:57:23 <Cale> ddarius: Well, it's not *that* hard -- for any Haskell data type (T a), what fmap will do is apply the given function of type (a -> b) to every element of type a in T.
19:57:28 <ddarius> platypus: In Haskell lingo, every functor is equivalent to a polymorphic function space.
19:57:45 <ddarius> Cale: Yes, that's not the issue.
19:58:27 <Cale> So it is sort of like composition in that sense -- you're composing the given function with the structure map.
19:58:55 <ddarius> Yes, but viewing the data type as a function is not something that is readily doable for all functors in Haskell.
19:59:00 <Cale> Oh?
19:59:38 <ddarius> Cale: Quickly describe Haskell lists as a function space.
19:59:49 <dons> ?seen mudge
19:59:50 <lambdabot> Last time I saw mudge was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #scala, #scannedinavian, #unicycling
19:59:50 <lambdabot> and #xmonad 10d 3h 10m 33s ago, and .
20:00:10 <dons> re. http://nickmudge.info?post=56
20:00:19 <dons> nick likes:
20:00:19 <dons>   twoChar = do v1 - item
20:00:19 <dons>                v2 - item
20:00:20 <dons>                return (v1:v2:[])
20:00:27 <dons> but that's massively golfable in interesting ways
20:00:34 <Cale> Well, [a] is essentially the set of functions from initial segments of the naturals to values of type a
20:00:38 <dons> into , say,   twoChar = do v1 - item v2 - item return (v1:v2:[])
20:00:46 <dons> gr..
20:00:47 <dons> twoChar = liftM2 (\x y -> [x,y]) item item
20:00:53 <ddarius> Cale: Describe "initial segments of the naturals" as a Haskell data type.
20:01:03 <dons> but then, do we have some nice tricks for doubling the input function, and currying [x,y] ?
20:01:23 <dons> twoChar should return a pair anyway though -- its in the name, it should be in the ytpe
20:01:25 <ddarius> Also, you need to add all the naturals unless "initial segments" included that.
20:01:42 <Cale> yeah, I'm including that
20:02:41 <Cale> That is, it's the set of functions: union over S: A^S, where S ranges over initial segments of N, including all of N.
20:03:08 <dons> ?t let ?twoChar = item &&& ?item in twoChar
20:03:08 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:03:11 <ddarius> Wait, I wanted one function not a set of them.
20:03:15 <dons> :t let twoChar = item &&& ?item in twoChar
20:03:21 <Cale> One function?
20:03:23 <lambdabot> Not in scope: `item'
20:03:34 <ddarius> You compose functions with functions not with sets of functions.
20:03:38 <Cale> The type [a] doesn't just have one element in it.
20:03:45 <Saizan> twoChar = join (liftM2 (,)) item ?
20:03:59 <ddarius> [21:58] <ddarius> Cale: Quickly describe Haskell lists as a function space.
20:04:00 <sjanssen> dons: replicateM 2 iterm?
20:04:15 <sjanssen> item, rather
20:04:18 <Cale> ddarius: as a function space
20:04:23 <Cale> that's what I've done :)
20:04:42 <Cale> It's the union of the function spaces A^S
20:04:48 <ddarius> Describe it as something implementable in Haskell.
20:04:55 <Cale> Why?
20:04:59 <ddarius> As a function type.
20:05:09 <ddarius> We're working with Haskell!
20:05:27 <dons> f &&& f comes up so often, it should have some syntax
20:05:31 <ddarius> If we're composing functions, I want a function to compose.
20:05:37 <dons> and it feels like the (-> f) monad should have a role
20:05:53 <Saizan> that's join (&&&)
20:05:56 <dons> Saizan: ah. yes.
20:06:11 <dons> i looked up, saw join (liftM2 (,)), and jumped to join (&&&) in my head
20:06:21 <dons> :t join (&&&)
20:06:21 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
20:06:29 <dons> > join (&&&) getChar
20:06:30 <lambdabot>  Couldn't match expected type `IO' against inferred type `a b'
20:06:35 <dons> :t join (&&&) getChar
20:06:36 <lambdabot>     Couldn't match expected type `IO' against inferred type `a b'
20:06:37 <lambdabot>       Expected type: IO Char -> t
20:07:19 <dons> :t getChar &&& getChar
20:07:21 <lambdabot>     Couldn't match expected type `a b' against inferred type `IO'
20:07:21 <lambdabot>       Expected type: a b c
20:07:23 <dons> oh.
20:07:26 <sjanssen> doesn't the problem specification require returning a list rather than a pair?
20:07:33 <Saizan> IO is not an instance of Arrow
20:07:37 <ddarius> dup . f
20:07:55 <ddarius> Kleisli IO is.
20:08:43 <Saizan> :t Kleisli
20:08:45 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
20:09:42 <Saizan> ?pl (\x y -> (x:y:[]))
20:09:42 <lambdabot> (. return) . (:)
20:16:47 <sjanssen> @type replicateM 2 ?item
20:16:49 <lambdabot> forall (m :: * -> *) a. (?item::m a, Monad m) => m [a]
20:17:21 <omniscientIdiot> @src replicateM
20:17:21 <lambdabot> replicateM n x = sequence (replicate n x)
20:18:44 <chessguy> @type replicate 2 (State 3)
20:18:46 <lambdabot> forall s a. (Num (s -> (a, s))) => [State s a]
20:19:04 <chessguy> eh?
20:19:24 <omniscientIdiot> sequence them together for a State s [a]
20:19:31 <ddarius> chessguy: What were you expecting?
20:19:42 <Saizan> ?type State
20:19:44 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:20:09 <chessguy> i was expecting the [State s a] but not the first part
20:20:21 <kpreid> along with instance Functor Void in scrollback, we also can have: data None a = None; instance Functor None where fmap = id
20:20:40 <Saizan> @type replicate 2 (return 3 :: State () Int)
20:20:40 <chessguy> why is it saying s -> (a,s) should be an instance of Num?
20:20:41 <lambdabot> [State () Int]
20:20:50 <omniscientIdiot> chessguy: 3 isn't a (s -> (a, s)), which is what the State constructor expects.
20:20:53 <ddarius> kpreid: That wouldn't quite work.
20:21:09 <ddarius> Though what you are going for would.
20:21:28 <omniscientIdiot> (well, it could be, if you wrote a Num (s -> (a,s)))  :)
20:21:30 <kpreid> Oh?
20:21:38 <kpreid> Oh.
20:21:41 <kpreid> fmap _ = id
20:21:47 <kpreid> er...
20:21:51 <chessguy> oh, i'm an idiot, never mind
20:21:56 <kpreid> yes, that's right
20:21:59 <Saizan> kpreid: wrong types
20:22:12 <kpreid> ...sigh
20:22:12 <omniscientIdiot> @type replicate 2 (State (\_ -> (3,3)))
20:22:15 <lambdabot> forall s t. (Num t, Num s) => [State s t]
20:22:18 <kpreid> fmap _ _ = None
20:22:27 <kpreid> I should have thought of that
20:22:43 <kpreid> I *thought* of writing it as = None, but I missed why it *has* to be that
20:22:53 <ddarius> Also None is different from Void.
20:23:05 <chessguy> @type None
20:23:07 <lambdabot> Not in scope: data constructor `None'
20:23:12 <chessguy> @hoogle None
20:23:12 <lambdabot> Text.ParserCombinators.Parsec.Char.noneOf :: [Char] -> CharParser st Char
20:23:12 <lambdabot> Language.Haskell.Syntax.HsAssocNone :: HsAssoc
20:23:12 <lambdabot> System.Win32.File.fILE_SHARE_NONE :: ShareMode
20:23:28 <omniscientIdiot> chessguy: see kpreid's comment in scrollback.
20:23:45 <chessguy> oh, i missed that
20:25:28 <kpreid> ddarius: yes, it is. that's why I mentioned it.
20:30:14 <chessguy> @bot
20:30:14 <lambdabot> :)
20:32:47 <chessguy> so what's really the difference, architecturally, between f :: Int -> State Foo Bar and f' :: Int -> Foo -> Bar?
20:33:19 <sorear> chessguy: f can return a new foo, f' can't
20:33:47 <chessguy> oh, good point
20:33:48 <dons> ?unmtl Int -> State Foo Bar
20:33:48 <lambdabot> err: No applications
20:33:53 <dons> ?unmtl State Foo Bar
20:33:54 <lambdabot> Foo -> (Bar, Foo)
20:34:03 <dons> so its, Int -> Foo -> (Bar, Foo)
20:34:16 <sorear> heh, O
20:34:21 <sorear> I'd forgotten ?unmtl
20:34:45 <chessguy> @help unmtl
20:34:45 <lambdabot> unroll mtl monads
20:35:41 <sjanssen> @unmtl ReaderT XConf (StateT XState IO) a
20:35:41 <lambdabot> XConf -> XState -> IO (a, XState)
20:35:42 <Cale> okay...
20:35:48 <Cale> !paste
20:35:48 <hpaste> Haskell paste bin: http://hpaste.org/
20:36:11 <dons> it should unroll all monads :)
20:36:12 <kpreid> @unmtl ErrorT Ex (StateT Con IO) Foo
20:36:12 <lambdabot> Con -> IO (Either Ex Foo, Con)
20:36:19 <dons> ?src IO
20:36:19 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
20:36:27 <omniscientIdiot> :O
20:36:28 <kpreid> unmtl seems disturbingly specialized.
20:36:31 <ddarius> This should be interesting.
20:36:40 <kpreid> how about an unnewtype?
20:36:45 <dons> mm.
20:36:52 <dons> indeed
20:37:00 <dons> kpreid++ good thinking, 99.
20:37:06 * kpreid . o O ( @oldtype )
20:37:10 <dons> heh
20:37:46 <dons> kpreid: do you want to have a go at it?
20:37:49 <kpreid> of course, dropping newtypes can change semantics
20:38:02 <dons> so that you could unroll IO, Arrow types, and so on?
20:38:09 <Cale> ddarius: http://hpaste.org/2863 -- there, I think that works
20:38:13 <kpreid> cf Monoid instances, especially Dual
20:38:18 <dons> it would be nice to @add-newtype newtype X = Y { ... )
20:38:38 <dons> then just reduce definitions
20:38:49 <kpreid> dons: I was thinking more like extract it from the std lib, like @src
20:38:53 <Cale> It's somewhat awkward to describe an infinite disjoint union as a Haskell type directly.
20:39:03 <dons> yep, that'd be ok too
20:39:41 <kpreid> no, I'm not very up for it
20:40:03 <Cale> Every list of type [a] is isomorphic to a function from INat n (for some type n) to a
20:41:35 <ddarius> So to make a list of such "lists" I would need existentials or something?
20:41:39 <Cale> If you want, we can wrap it in an existential.
20:42:24 <Cale> To just forget which n it was.
20:42:29 <ddarius> Now we go back to two key words that I used: "readily" and "Quickly"
20:42:58 <Cale> Well, so what if Haskell's type language makes it difficult to express the function space concerned.
20:43:25 <ddarius> Cale: Describe in words the type for trees quickly.
20:43:47 <Cale> Which type for trees?
20:43:58 <ddarius> I.e. the type T such that T -> a is isomorphic for Tree a, and for binary leaf trees say.
20:45:07 <Cale> Well, it would be the type of trees labelled with integers from 1 up to the number of labels, such that each integer occurs exactly once.
20:45:28 <Cale> Er, not quite :)
20:46:34 <Cale> I think one problem is that my inital conception of what the functions involved were is not quite this one.
20:46:58 <ddarius> I agree.
20:48:43 <monochrom> where is xerox's latest additions to Parsec?
20:49:37 <Cale> If T is some Haskell data type functor, you can always represent a value of type (T a) by a pair of some structure T Nat (where you really only use some initial segment of the naturals, and each natural occurs at most once), together with a function from that initial segment of the naturals to a.
20:50:13 <ddarius> dons, kpreid: Why stop there?  Let's add beta reductions at both the type and term level to @src, since @src already roughly does the simplest case of unmtl.
20:50:17 <Cale> So it would be that function which you're composing.
20:51:17 <Cale> Of course, there's the issue of having more than one representation of every value of type T a, but it's easy to define an equivalence.
20:51:32 <ddarius> Cale: So (a,a) is T1? T2? T??
20:51:41 <ddarius> T being type T a = (a,a)
20:52:00 <Cale> (1,2), together with a function {1,2} -> a
20:52:51 <ddarius> Cale: You have looked at Containers, yes?
20:53:08 <Cale> Or, say we have some tree:  Branch (Leaf "one") (Branch (Leaf "two") (Leaf "three"))
20:53:56 <Cale> that can be represented by the tree  Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3)), together with the function {1,2,3} -> String, which sends 1 to "one", 2 to "two", 3 to "three"
20:54:13 <Cale> ddarius: "Containers"?
20:54:26 <ddarius> @google "Thorsten Altenkirch" Containers
20:54:30 <lambdabot> http://portal.acm.org/citation.cfm?id=1195941
20:54:30 <lambdabot> Title: Containers
20:54:34 <Cale> no
20:54:41 <ddarius> @google "Thorsten Altenkirch"
20:54:46 <lambdabot> http://www.cs.nott.ac.uk/~txa/
20:54:46 <lambdabot> Title: Thorsten Altenkirch
20:55:33 <dibblego> ?where stm
20:55:33 <lambdabot> http://haskell.org/haskellwiki/Software_transactional_memory
20:55:38 <ddarius> See his publications page.  At least some of the relevant papers will be titled obviously.
20:55:46 <dibblego> ?where video
20:55:46 <lambdabot> http://haskell.org/haskellwiki/Video_presentations
20:56:09 <ddarius> Some of it is cute, they use Kan extensions (though not really for much more than essentially a dependent sum)
20:57:24 <ed1t> is there any rdbms engine written in haskell?
20:58:11 <dons> i believe so. check hackage.haskell.org
20:59:01 <dons> try 'rdbm' in http://hackage.haskell.org/packages/search.html
20:59:03 <lambdabot> Title: HackageDB: search
20:59:46 <ed1t> thx
21:00:09 <Cale> ddarius: anyway, my original point I suppose is just that everything could be viewed as some indexed structure together with a function from indices to values
21:00:20 <dons> ed1t: in general, http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Database
21:00:21 <lambdabot> http://tinyurl.com/yqov7f
21:00:26 <ddarius> Cale: Yes, that is what containers are.
21:00:33 <Cale> ddarius: it's that particular function from indices to values that you're composing with when you use functor application.
21:00:49 <Cale> Hence it's not so strange to use (.) for fmap :)
21:00:51 <ddarius> My point is that this is not immediately intuitive.
21:01:09 <Cale> I don't know, 5 minutes of use and it's reasonably so.
21:03:57 <Cale> You might have to think a little with things like Cont, but then, everything to do with Cont requires a bit of thought :)
21:05:05 <monochrom> What? I thought Cont was intuitive. Every day I see something in daily life and recognize "oh it's Cont!" or even "oh it's delimited Cont!"
21:05:32 <P_D> ?pl \h l -> f h $ f h l
21:05:32 <lambdabot> liftM2 (.) f f
21:05:38 <ddarius> Like when someone gives you a number and time to call back!
21:06:41 <dons> join (&&&) f :)
21:06:49 <idnar> heehee
21:06:49 <dons> P_D: this came up just a few minutes ago
21:06:58 <ddarius>  @pl doesn't touch unbound variables.
21:07:06 <P_D> Oh thanks
21:07:14 <idnar> uhm, that's not quite the same, is it?
21:07:17 <monochrom> For example the other day I was contemplating "IDEs like Eclipse has incremental, undo-able parsing and that is why it can do code completion and all sorts of lookups, but it's specific to Java, how do you do it generally?" and in a minute I saw "oh! It's delimited cont!"
21:07:22 <dons> :t join (&&&) toUpper
21:07:24 <lambdabot> Char -> (Char, Char)
21:07:31 <dons> oh, liftM2
21:07:34 <idnar> :t \h l -> f h $ f h l
21:07:36 <lambdabot> Not in scope: `f'
21:07:36 <lambdabot>  
21:07:36 <lambdabot> <interactive>:1:14: Not in scope: `f'
21:07:38 <dons> idnar: good point.
21:07:49 <ddarius> monochrom: I eagerly await your generic IDE, or I would if I liked IDEs.
21:07:57 <idnar> :t \f h l -> f h $ f h l
21:07:59 <lambdabot> forall t b. (t -> b -> b) -> t -> b -> b
21:08:19 <P_D> liftM2 doesn't seem to work for me either actually
21:08:23 <idnar> actually, that seems like a very strange thing to be doing
21:08:36 <P_D> No instance for (Monad ((->) Double))
21:08:45 <monochrom> Of course, in another minute, I found out that Oleg already wrote about that idea months before me. :)
21:08:58 <monochrom> I'm just glad it's just months, not years. XD
21:09:11 <idnar> P_D: I think you need to import Control.Monad.Instances to get that instance
21:09:32 <idnar> hmm, not so strange, I guess; but interesting :)
21:10:20 <P_D> Yep that did it, thanks.  Although it's rather more confusing than just g h l = f h $ f h l =)
21:10:27 <idnar> ?pl \f h l -> f h $ f h l
21:10:27 <lambdabot> ap =<< ((.) .)
21:10:34 <idnar> oh man
21:10:41 * idnar picks up the pieces of his brain
21:20:31 * FMota thinks outside the box.
21:20:43 <chessguy> @quote explode
21:20:43 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
21:20:55 <FMota> lol.
21:21:59 <chessguy> @pl i like how you conveniently gloss over the part where your head explodes
21:21:59 <lambdabot> i like how you conveniently gloss over the part where your head explodes
21:22:08 <FMota> okay, so. I don't want to stir up a religious or political debate, so I came to #haskell
21:23:23 <FMota> in a cellular automata, is there any way to prove outside interference?
21:24:03 <chessguy> interference?
21:24:21 <FMota> As in, I create a cellular automata with an initial state. Then I run it. Then I modify some of its cells.
21:24:27 <FMota> (while it runs)
21:24:57 <ddarius> FMota: Sometimes, yes.
21:25:11 <FMota> I can only think of "Garden of Eden"s
21:25:49 <FMota> or if you knew some previous state and how much has elapsed since then.
21:26:09 <ddarius> You can prove some states are not possible from an initial state in some cases.
21:26:25 * FMota wonders.
21:26:28 <chessguy> FMota, it's easy to construct simple examples where you could make such a proof, so the anwer to your question is yes. but since that's probably not very useful, you're probably asking the wrong question :)
21:26:29 <kawfee> unf
21:26:33 <P_D> you can search the inverse operator
21:26:38 <kawfee> I forgot all my haskell skills
21:26:40 <kawfee> =[
21:26:41 <FMota> There are some structures that just wouldn't be possible naturally, right?
21:27:38 <FMota> I mean, parts of the grid that couldn't have come about without somebody putting them there.
21:28:44 <FMota> This is essentially the Intelligent Design folks' argument
21:28:46 <ddarius> FMota: It depends on the automata, but there are things that can't arise from the rules and even more things that can't arise given an initial state.
21:29:11 <FMota> mmhmm
21:29:28 * FMota doesn't know what to make of it.
21:29:34 <ddarius> What to make of what?
21:29:35 <FMota> Besides an amusing mental detour.
21:29:53 <P_D> do they not teach statistical mechanics at bible school?
21:30:16 <FMota> this mini-"Garden of Eden" = anti-darwinists argument
21:31:00 <FMota> P_D: wouldn't know. :)
21:31:29 <ddarius> FMota: To begin with, we don't know all the rules and don't know the initial state, so there's no way to argue that as a certainty and further it does look like we could come about from the rules we do know.
21:31:48 <FMota> yes, ddarius, I agree.
21:32:00 <FMota> But they obviously don't.
21:32:29 <ddarius> I don't think most of them think of it that way, but then I don't know what most of them think at all.
21:32:51 <glguy> > 1440 / 305
21:32:53 <lambdabot>  4.721311475409836
21:32:55 <ddarius> P_D: Actually a superficial reading of statistical mechanics seems to suggest that life and such is unlikely.
21:33:09 <glguy> > 1440 / 12
21:33:10 <lambdabot>  120.0
21:33:25 <ddarius> (Mostly due to an emphasis on equilibrium states, for not unreasonable reasons)
21:33:32 <P_D> physics as we know it indicates that the ergodicity hypothesis is correct
21:33:41 <wli> Well, the fundies are joining the military en masse and pushing exclusionary policies there, so they'll soon be in positions to enforce their beliefs at gunpoint.
21:33:43 <FMota> yeah. Probably not worth thinking too much about it.
21:34:00 <P_D> i.e. there are no exceptional states
21:34:03 <wli> Physics to me suggests life will be transient.
21:34:28 <P_D> actually
21:34:50 <P_D> how is this an argument at all?
21:35:02 * FMota doesn't know.
21:35:32 <ddarius> wli: Well, physics suggests that existence in general is transient...
21:35:59 <wli> No, it's vastly more specific.
21:36:49 <wli> Life forms survive essentially by externalizing entropy.
21:37:16 <wli> Physics suggests they will be overwhelmed by entropy in a heat death -like process.
21:38:02 <FMota> well
21:38:12 <FMota> I know that your life is transient.
21:38:14 <FMota> As is mine.
21:38:48 <wli> By "life" I meant the existence of life forms / living things / etc.
21:39:00 <FMota> ok
21:39:13 <idnar> I guess that really depends on how you define life
21:39:24 <FMota> yes, I was about to say
21:39:27 <ddarius> wli: I think a good part of the universe's life would be over by the time all life extinguished due to that process.
21:40:44 <wli> I suspect not. I suspect space travel will never be meaningful in part because there's nowhere to go but also for other reasons. At that point you can easily bound life's lifetime with conditions on the earth.
21:42:05 <P_D> we've got a few billion years to go, more than enough to send people across the galaxy
21:42:35 <P_D> and back
21:43:12 <wli> P_D: And I say there's nowhere to go within our light cone.
21:43:56 <wli> P_D: If we make it across the galaxy and back all we'll find are gas giants, asteroids, and other similarly barren affairs.
21:44:03 <P_D> any star and any supernova rock is good enough
21:44:37 <wli> P_D: I'm far from convinced.
21:45:04 <wli> P_D: Why is any star and any supernova rock good enough?
21:45:22 <P_D> If you've got the chemistry, all you need is a hot star, a cold sky, and heavy elements to build new people
21:46:05 <P_D> do you think we can live profitably on other planets in our solar system?
21:46:13 <wli> P_D: I say that's an overly-optimistic view of terraforming. If it were so easy to do that then we could control our own atmosphere.
21:46:19 <wli> P_D: No.
21:46:26 <P_D> Who cares about terraforming, all we need is a bubble.
21:46:53 <P_D> Really we'll have to go underground, since all the starlight will be consumed by heat engines or solar panels
21:47:28 <Adamant> I think predicting what humanity will be capable of even a million years from now (assuming we survive) is sheer craziness.
21:47:34 <wli> P_D: Such schemes will prove inadequate extraterrestrially as they do terrestrially.
21:47:41 <P_D> Adamant:  Be pessimistic
21:47:58 <Adamant> we can't even do 5 year plans
21:48:21 <P_D> How did you lose your faith in the social sciences!
21:48:27 <P_D> What did they ever get wrong
21:48:52 <wli> Adamant: If we can't do 5-year plans how can we marshal the resources of the entire planet into migrating to a new one and setting up extraterrestrial colonies?
21:49:03 <goalieca> 3 year plan is almost long term for most companies
21:49:43 <Adamant> why do we need the resources of the entire planet?
21:49:49 <P_D> It just seems really expensive right now because we're so deep in gravity
21:50:17 <wli> Adamant: Never mind excursions and construction projects so vast they would require generations, if not centuries, to execute?
21:50:53 <Adamant> who says they will take centuries? or at least what would be perceived to us as centuries?
21:51:22 <P_D> not sur what you mean by centuries
21:51:32 <P_D> Ideally a colony would take forever; it would never stop growing
21:55:19 <wli> Its lifetime would be bounded by the duration of hospitable conditions (e.g. the star going nova would terminate it).
21:57:55 <Adamant> the whole problem with prediction is that, compared to whatever humanity will be like a million years from now, we are at best, in all likelyhood, about as knowledgable as cavemen are compared to us.
21:58:49 <Adamant> I mean, how long have we even been forming civilizations? not very long.
21:59:13 <P_D> yes yes, but that's not interesting, just assume we're like we are today, but we had a lot of time to build stuff with today's technology
22:00:23 <ddarius> Adamant: Probably much much much much less knowledgeable relatively.
22:00:55 <Adamant> right, I'm being "optimistic" and assuming our descendants are slow learners.
22:01:05 <Adamant> so we don't look as bad in comparison
22:01:24 <ddarius> Adamant: Everything suggests the pace will only increase as it has since our inception.
22:01:38 <ddarius> Also, cavemen were pretty damn bright.
22:01:59 <Adamant> I agree, although we can't be sure there won't be a limit to it, like there is to Moore's Law
22:02:15 <Adamant> they were bright for their environment
22:02:51 <ddarius> Adamant: They were pretty bloody bright period.
22:03:00 <wli> We're not going to get any smarter; all indications are actually that we're getting dumber with rather clear reasons why.
22:03:21 <wli> Namely, the stupid outbreed the bright by a long longshot.
22:03:31 <ddarius> wli: We don't actually need to be smarter individually to still be getting more knowledgeable as a whole.
22:03:48 <Adamant> and we may be able to enhance our brains
22:04:09 <Adamant> I'm also not sure the stupid outbreed the bright in the long run
22:04:10 <ddarius> We -do- enhance our brains.
22:04:20 <Adamant> I mean physical modification. :)
22:04:51 <P_D> what's your evidence for stupid people outbreeding bright people.  or even your criteria for stupidity
22:05:35 <P_D> Most of the smart people I know seem to be reproducing just fine
22:05:38 <wli> 5/6 of the world is living in squalor and literally starving; technological fantasies of enhancing our brains are preposterous.
22:06:00 <ddarius> wli: Is there a reason to think that this is a new phenomenon?
22:06:19 <P_D> It used to be 6/6 of the world living in squalor.  So far 1/6 has made it out...
22:07:07 <wli> ddarius: It's new by proportions. It was not so large a proportion prior to various conquests etc.
22:07:27 <Olathe> How do I get the Cartesian product of three lists ?
22:07:39 <wli> Olathe: zip3?
22:07:52 <ddarius> wli: So you agree that the stupid people have been outbreeding bright people for a long long time?
22:08:25 <wli> ddarius: I don't believe there is enough information to determine how long it's been happening.
22:08:37 <Olathe> Zipping isn't quite what I want.
22:08:50 <Olathe> > zip3 [1..] [1..] [1..]
22:08:52 <lambdabot>  [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(6,6,6),(7,7,7),(8,8,8),(9,9,9),(10...
22:09:04 <wli> Olathe: [(x, y, z) | x <- xs, y <- ys, z <- zs] ?
22:09:07 <Olathe> Should also include things like (3,1,2)
22:09:23 <ddarius> liftM3
22:09:23 <P_D> you want to convolve them?
22:09:57 <Olathe> > [(x, y, z) | x <- [1..], y <- [1..], z <- [1..]]
22:09:59 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1,...
22:10:07 <Olathe> I don't know what a convolution is.
22:10:15 <Olathe> I want something like diagonalization.
22:10:24 <Olathe> Like to iterate the rational numbers or something.
22:10:27 <idnar> > liftM3 (,,) [1..5] [1..5] [1..5]
22:10:28 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,2,1),(1,2,2),(1,2,3),(1,2,4),(1,...
22:10:46 <Olathe> > liftM3 (,,) [1..] [1..] [1..]
22:10:47 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1,...
22:10:51 <ddarius> Olathe: Miranda had diagnolizing list comprehensions.  You have to write your own function nowadays.
22:11:23 <ddarius> (This only -really- matters if you deal with infinite lists.)
22:12:07 <Olathe> Alright, thanks.
22:12:16 <wli> Olathe: Hang on.
22:12:39 <wli> Olathe: http://holomorphy.com/~wli/Tuple.hs
22:12:40 <omniscientIdiot> @google site:hpaste.org diagonal
22:12:44 <lambdabot> http://hpaste.org/2225
22:12:44 <lambdabot> Title: diagonal transposition - hpaste
22:14:52 <Olathe> wli: Thanks :)
22:18:00 <wli> Olathe: To do it do flatten [[[(x, y, z) | z <- zs] | y <- ys] | x <- xs]
22:18:59 <wli> Olathe: Though I think it expects all lists to be infinite.
22:28:00 * omniscientIdiot reads Type Level Instant Insanity in the latest Monad.Reader
22:29:00 <omniscientIdiot> And I grok it so far!  I am pleased.
22:30:39 <idnar> go you :)
22:30:48 <OceanSpray> hey, anybody remember me?
22:31:15 <idnar> heh, this reminds me of C++ template metaprogramming
22:31:16 <Cale> Hello
22:31:31 <OceanSpray> Y halo thar, Cale
22:31:35 <Cale> hi
22:32:27 <OceanSpray> well, I had stopped working on that interpreter for a few months
22:32:35 <OceanSpray> and now, when I return to it, I am completely lost.
22:32:44 <OceanSpray> ah well.
22:32:55 <merus> ghc runs on OS X now, doesn't it?
22:33:06 <glguy> has for some time
22:33:07 <OceanSpray> I was just wondering...
22:33:28 <OceanSpray> how efficient is Haskell's handling of IO actions?
22:33:38 <OceanSpray> you know, since it uses Monads and whatnot
22:33:41 <Cale> It's not so bad.
22:34:12 <sorear> OceanSpray: Has it really been that long?
22:34:16 <joed> merus: works well with xcode as an editor
22:34:17 <Cale> It's compiled down to fairly good code in most cases. The biggest issue is probably the string representation.
22:34:21 <OceanSpray> now, I was thinking of just taking the parser and data definition parts of what I've written so far,
22:34:34 <merus> Hrm. I wonder what I was hallucinating as not working about it.
22:34:41 <Cale> If you use Haskell's ordinary String type, that's linked lists of 32-bit wide characters.
22:34:56 <sorear> OceanSpray: Aug 19.  You've only been gone for one month. :)
22:34:57 <Cale> Which can be slow. There's Data.ByteString now though.
22:35:02 <OceanSpray> and just use C for the evaluator
22:35:26 <merus> I've hit a bottleneck trying to get my debian box working again and would rather just code :)
22:35:31 <sorear> OceanSpray: why not write the parser in lisp?
22:35:31 <OceanSpray> it felt like a long time.
22:36:07 <OceanSpray> sorear, why?
22:36:16 <OceanSpray> is parsec not good enough?
22:41:01 <Cale> Use C for the evaluator?
22:42:22 <Cale> Oh, I remember you had a language with lots of mutability everywhere.
22:42:45 <Cale> Still, I'm not sure that handling that in C will really be much easier.
22:47:25 <merus> Wooo! It works.
22:48:18 * merus explodes his old linux box.
22:54:31 <sorear> sml frw
22:54:34 <sorear> *ftw
22:58:36 <joed> merus: Heh :)
