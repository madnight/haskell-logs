00:00:15 <goltrpoat> if you want to pursue the latter group, you end up with the same requirements that produced java to begin with.
00:00:50 <Vq^> Cheery: python has it's good sides where (in my eyes) Haskell shines less
00:01:21 <Cheery> yes, but there are so little of them..
00:01:23 <Philippa> goltrpoat: not quite, if only because we're a decade on
00:01:57 <Vq^> Cheery: yeah, they are mostly document/web domains
00:02:42 <Cheery> if you work for request, not for hours, I think haskell is the way to go. If you work for hours.. well it goes well with what majority uses today
00:02:51 <Svrog> Vq^: that's mostly due to the available libraries - not the language itself
00:02:59 <goltrpoat> philippa:  there will always be language tiers, where the first tier has a low barrier to entry.  that tier has been steadily improving, but you can't expect it to suddenly get populated with interesting languages.
00:03:04 <Vq^> Svrog: not entirely
00:03:16 <Philippa> goltrpoat: sure. And I don't think we're arguing here
00:03:20 <sieni> Cheery: if you are paid by the hours, then assembler is the way to go ;-)
00:03:20 <gour> another stupid post - http://t-a-w.blogspot.com/2007/05/syntactic-tradeoffs-in-functional.html
00:03:23 <lambdabot> Title: taw's blog: Syntactic tradeoffs in functional languages, http://tinyurl.com/26jy3t
00:03:24 <Vq^> Svrog: the dynamic nature of python makes frameworks like zope very practical
00:03:46 <Cheery> sieni: the problem in assembler is that your boss is not fooled with it
00:03:56 <Cheery> you need something more coinvincing, like java!
00:04:02 <goltrpoat> philippa:  then i don't understand your "not quite comment" :)
00:04:10 <goltrpoat> er.  "not quite" comment, rather.
00:04:27 <Vq^> twisted is a very useful python-library which alone could justify the use of python, they really needed a monad for handling deferreds thought :)
00:04:37 <Philippa> the requirements for such a language now aren't the same as those for one ten years ago
00:04:48 <Cheery> where's the kittens in that links?!
00:05:13 <sieni> Cheery: C then, or FORTRAN IV
00:05:17 <Philippa> because there're corresponding shifts in what the average coder's been exposed to
00:05:52 <Cheery> ow, gour that writer misses the point entirely!
00:05:56 <goltrpoat> philippa:  10 years ago, we had java, python and ruby.
00:06:02 <goltrpoat> today, we have java, python, and ruby.
00:06:11 <goltrpoat> i'm not fully sure what you're getting at.
00:06:22 <gour> Cheery: right. people do not have idea what fp is about
00:06:42 <Philippa> ten years ago, Java wasn't what Java is today - it was still "that weird web language"
00:06:55 <Philippa> python and ruby were largely unheard of, the buzz was about perl
00:07:13 <Philippa> and we had C, C++ and/or VB in the place Java holds today
00:07:22 <Cheery> gour: it's funny that guy thinks it's the syntax different :)
00:07:23 <gour> Cheery: it's right post for Cale  to comment ;)
00:07:28 <goltrpoat> ok.  in my world, the buzz was about c++ and, to a lesser extent, lua.
00:07:33 <ivanm> gour: do you go out of your way to find stupid posts or something? :p
00:08:00 <goltrpoat> (yes, c++ -- we're seriously behind the times)
00:08:06 <gour> ivanm: no, just checking reddit feed
00:08:11 <ivanm> *nod*
00:08:11 <Philippa> point - it's easy to forget that C++ hadn't actually been standardised at the time
00:08:21 <Cheery> thought, first thing I liked in haskell was it's syntax
00:08:35 <gour> exactly
00:08:41 <Philippa> but now there isn't buzz around Java, it's just plain saturated
00:08:42 <Cheery> ..after I realised how well it fits with lambda calculus
00:08:49 <gour> it's hard to go 'down' afterwards
00:09:06 <ivanm> Cheery: so you went out of your way to find a good lambda-calculus based language?
00:09:48 <Cheery> ivanm: partly, yes, I were interested about it because it felt promising
00:09:51 <Philippa> so if you're looking to be what Java was ten years ago, you'd better not be Java. Hell, even C#'s doing its damnedest to be not just Java and forcing improvements to Java in the process
00:10:06 <Cheery> damn I were in right, it was promising :)
00:10:22 <goltrpoat> hmm.  going off on a tangent here, but i think c# is actually moving in a decent direction.
00:10:29 <ivanm> Cheery: *nod*... Haskell was recommended to me by one of my lecturers after I said I liked the introductory scheme subject I did
00:10:37 <Philippa> today, if you're designing a language for that market you don't need to actively avoid having HOFs in the language the way it was explicitly decided to with Java
00:10:46 <goltrpoat> ah right.
00:10:55 <ivanm> and then I remembered after a while doing a dodgy, cut down haskell interpreter in scheme for one of my assignments
00:11:09 <Philippa> inner classes were voodoo to most of the target market at the time :-)
00:11:16 <goltrpoat> although, python is taking a bit of a backslide there, due to guido's odd preferences.  from what i've read, anyway.
00:11:50 <Philippa> yep. Some of which amount to "wah, I can't figure out how to write the parser any more!"
00:11:56 <goltrpoat> haha
00:12:03 <Svrog> c# is way too much like java
00:12:13 <goltrpoat> which just scares the living fuck out of me, considering how high profile that guy is
00:12:55 <Cheery> I wonder what will be  after haskell..
00:12:59 <Philippa> in fairness, it was a fair complaint if your parsing tech's limited
00:13:00 <jbauman> Philippa: like for what
00:13:14 <jbauman> what couldn't he figure out how to parse?
00:13:36 <Philippa> I'm exaggerating a bit - he could figure out how to do it in principle and actively didn't want to do it in practice
00:13:42 <gour> Cheery: flood
00:13:50 <Philippa> lambdas containing statements rather than expressions, IIRC
00:14:08 <Cheery> gour: ?
00:14:20 <jbauman> no, he didn't want to do that because he couldn't think of syntax that he actually liked
00:14:24 <gour> Cheery: there is nothing after haskell
00:14:25 <jbauman> afaik
00:15:12 <Cheery> gour: it sure looks like that right now
00:15:21 <gour> yep
00:15:23 <Svrog> after haskell - epigram perhaps
00:15:35 <Svrog> or something like that
00:15:40 <Philippa> jbauman: one piece of syntax was turned down because of the parsing complexity
00:16:13 <gour> Cheery: i'd say haskell didn't even arrive yet considering prospect of improving speed, concurrency...
00:16:47 <Cheery> Svrog: I don't know whether epigram counts as non-haskell, it's almost like a brother for it
00:17:30 <Cheery> it's not such steep jump like java -> haskell, for example
00:19:12 <Cheery> gour: haskell is so big compared to java, when you look at where it goes well
00:20:05 <tcr> The future might be that a automatic theorem prover is part of the language compiler.
00:20:21 <Shimei> Hmm. Is it just me or does it not make sense to say that scheme's syntax is non-traditional.... considering that it predates almost every popular language?
00:20:31 <Cheery> tcr: is ATP what we now call a type system?
00:20:48 <Shimei> (referring back to that syntax article)
00:20:55 <jbauman> Shimei, depends on what culture you're in
00:21:05 <jbauman> cannibalism is non-traditional in my culture
00:21:43 <skew> There are a few more incremental things Haskell could pick up - proper extensible records and variants would be nice
00:21:51 <tcr> Cheery: They're completely orthogonal.
00:22:31 <jbauman> curry-howard?
00:22:44 <Cheery> I've not heard about variants
00:22:44 <skew> tcr: automation is closely coupled, but a logics and type systems are quire close
00:23:16 <tcr> skew: Only to some extent, as I'm told.
00:23:44 <skew> tcr: e.g, the Coq type system is approximately equivalent to ZF
00:24:02 <Shimei> jbauman: Good point, but then syntax complaints don't seem too useful when crossing cultures.
00:24:25 <Cheery> I think theorem proving and type checking would be also very useful more lower you go
00:24:37 <Philippa> Scheme's syntax is weird unless your tradition is lisp or perhaps concatenative languages
00:24:50 <jbauman> Shimei, probably not, but it can make stepping out into that new culture seem strange
00:25:11 <tcr> skew: What's ZF?
00:25:12 <gour> Philippa: why some consider Haskell's syntax weird?
00:25:21 <shapr> Zermel Franko?
00:25:21 <Cheery> ie. I can think of it having use to be capable check that your assembly program is correct :)
00:25:28 <jbauman> gour, not enough braces
00:25:31 <skew> tcr: zermelo-frankel set theory
00:25:38 <gour> jbalint: lol
00:25:41 <shapr> whoops, I spoonerised
00:25:55 <gour> jbalint: oops
00:25:59 <gour> jbauman: lol
00:26:05 <jbauman> i think you need a "u" there
00:26:10 <Philippa> gour: layout rule, function application by juxtaposition rather than using parens, patterns
00:26:52 <gour> Philippa: really strange...i was (unfortunately) exposed to (too) many imperative langs, and consider haskell's syntax relieving
00:27:14 <gh_> has anyone managed to make STPP work ? http://www.cs.utah.edu/~hal/STPP/
00:27:16 <lambdabot> Title: The Haskell Array Preprocessor
00:27:16 <skew> Cheery: Types like Either are variants
00:27:24 <skew> Cheery: but then you make them extensible
00:27:32 <gh_> the given example programs don't even work with it
00:28:06 <skew> e.g. f x = case `Int i -> i | `Char c -> ord c gets a type like <`Int Int | `Char Char> -> Int
00:28:07 <tcr> skew: Ah well, I'm pretty new to all that stuff (working as a student assistant on Isabelle) :)
00:28:26 <jbalint> gour: hey
00:28:28 <jbalint> oops!
00:28:30 <jbalint> hahaa
00:29:01 <skew> then if you define g x = case x of `Float v -> round v | _ -> f x it gets a type like <`Int Int | `Char Char | `Float Float> -> Int
00:29:43 <skew> tcr: type systems are more like an unautomated theorem prover.
00:30:55 <skew> tcr: either way, you want automation in your type system
00:31:12 <tcr> skew: what's automation for you?
00:31:14 <Svrog> i think haskell has a bit too much syntax and a bit too much syntactic sugar
00:31:34 <Svrog> even though i like the syntax
00:31:36 <gour> Svrog: eg. ?
00:31:51 <Svrog> well for example list comprehensions
00:31:57 <Svrog> or operator precedence
00:32:19 <Svrog> or the n+k patterns (granted everyone hates those)
00:32:23 <skew> tcr: Oh, I just generally mean anything from type inference up to quite powerful things like decision procedures for arithmetic
00:32:40 <Svrog> or the do notation - or the arrow notation
00:33:04 <skew> tcr: more like being able to automate any sort of type juggling / proof search
00:33:04 <Svrog> code does look uglier without the do notation but i always wonder if it could have been done better without special syntax
00:33:13 <Philippa> no, no it couldn't
00:33:27 <Philippa> the best thing you can do is look at generalising let and variants into do and mdo
00:33:49 <skew> maybe you could make an infix ; with a really funny type
00:33:50 <Philippa> but that would've required a redesign for the entire language! Monads didn't take off until after the first version
00:34:07 <Philippa> no, because it'd have to take a pattern - you'd still need the lambdas
00:34:16 <skew> yeah, but \ is pretty light
00:34:23 <LeCamarade> skew: I see you are thinking OCaml... :o)
00:34:39 <skew> you'd need more trickery to allow chosing whether to bind something
00:34:45 <skew> I wouldn't put it past Oleg
00:35:42 <skew> about binding more generally, I think it might be nice if you didn't need the parens around a lambda
00:35:46 <Philippa> skew: you just reinvented >>= and >>
00:35:50 <Philippa> you don't need them
00:35:52 <Svrog> Philippa: what i wonder is if the syntax could have been made simpler from the start - as in whether it could have been designed so that it still looks nice but doesn't require special cases
00:36:14 <Philippa> Svrog: it could have if you knew you had monads in the language from day 1
00:36:14 <skew> Philippa: right, but perhaps you can merge them with some fancy typeclasses, and spell them ;
00:36:14 <Philippa> they didn't
00:36:26 <Svrog> yes
00:37:32 <Philippa> also, you'd really need a number more realisations that're pretty new
00:37:41 <Philippa> you could do it right in 2007 with some thought, it wasn't doable in 1982
00:37:44 <Philippa> er, 1987
00:37:49 <skew> now that I think about it, layout isn't completely incompatible with treating ; as a normal function in the middle of expressions
00:38:07 <skew> not that it sounds like a good idea
00:38:08 <Philippa> except that that breaks case and let
00:38:25 <skew> nah, you can just have the case / let syntax expect you to write ; without reserving it elsewhere
00:38:48 <skew> there are a handful of keywords like that
00:38:53 <skew> qualified can be used as an ordinary name
00:39:24 <skew> Sounds more like something to keep in mind for a successor to INTERCAL, but still
00:40:06 <Philippa> it doesn't work because if ; is an operator then it'll always be read as part of an expression rather than as a separator
00:40:29 <skew> that totally depends on how you write your grammar
00:41:18 <Philippa> sure. It'd look radically different to the existing one
00:42:08 <skew> maybe not even that bad, just take the current infix operator production, and add another with the semicolon token
00:42:38 <skew> not that I really want to do that for semicolon, but I think it might be nice for a few other words
00:43:31 <skew> like "type" or "data" which can only appear in top level definitions, but sometimes would be nice for variables
00:44:07 <skew> now that would be trickier, because you don't want to duplicate every last production mentioning identifiers
00:44:29 <skew> and happy at least doen't let you write rules talking about subsets of tokens
00:46:26 <ketil> Good morning!
00:47:17 <ketil> @botsnack
00:47:18 <lambdabot> :)
00:47:32 <Cheery> http://dev.codeflow.org/trac/cheery/browser/self.images/current.png?format=raw
00:47:35 <lambdabot> http://tinyurl.com/2ecdxj
00:47:47 <ketil> @hoogle [[String]]->[String]
00:47:48 <lambdabot> No matches, try a more general search
00:47:58 <Cheery> going to put that on my pages
00:48:08 <goltrpoat> @hoogle [[a] -> [a]
00:48:08 <ketil> Anybody know a funciton to align columns of text?
00:48:09 <lambdabot> No matches, try a more general search
00:48:11 <goltrpoat> er.
00:48:13 <goltrpoat> @hoogle [[a]] -> [a]
00:48:14 <lambdabot> Prelude.concat :: [[a]] -> [a]
00:48:33 <Cheery> ketil: explain
00:48:38 <ketil> Well, that would do it, but perhaps not quite as pretty as I'd like...
00:49:06 <DRMacIver> Morning
00:49:23 <ketil> I have some data, each line as a list of words (column entries).
00:49:35 <Cheery> a,b,c,d,e -> a|d,b|e,c ?
00:49:41 <ketil> I'd like to print it all, but with the columns aligned.  I.e. calculate the max length for each col and pad with spaces.
00:49:58 <ketil> I can do it of course, but it sounds like a fairly standard thing.
00:52:05 <Cheery> @hoogle lines
00:52:06 <lambdabot> Prelude.lines :: String -> [String]
00:52:06 <lambdabot> Data.PackedString.linesPS :: PackedString -> [PackedString]
00:52:06 <lambdabot> Text.Html.linesToHtml :: [String] -> Html
00:52:14 <Cheery> @hoogle unlines
00:52:15 <lambdabot> Prelude.unlines :: [String] -> String
00:52:16 <lambdabot> Data.PackedString.unlinesPS :: [PackedString] -> PackedString
01:18:17 <TSC> Is there some method equivalent to "mod" for Doubles ?
01:18:42 <profmakx> it`s called division
01:18:49 <profmakx> so
01:18:53 <profmakx> mod = 0
01:20:10 <TSC> I mean so that, for example, 6.0 `floatMod` 2.5 == 1.0
01:21:16 <flux> @hoogle Float -> Float -> (Float, Float)
01:21:17 <lambdabot> No matches, try a more general search
01:21:21 <flux> @hoogle Float -> Float -> Float
01:21:21 <lambdabot> No matches, try a more general search
01:21:29 <ski> > let n `mod` d = n - fromIntegral (floor (n / d)) * d in 6 `mod` 2.5
01:21:31 <lambdabot>  1.0
01:21:46 <ski> TSC : i think there's no predefined
01:22:22 <TSC> > let n `m` d = n - fromIntegral (floor (n / d)) * d in (-6) `m` 2.5
01:22:24 <lambdabot>  1.5
01:22:38 <TSC> Hmm, that looks good to me
01:22:49 <TSC> Thanks, ski
01:23:11 <ski> > let n `mod` d = n - fromIntegral (floor (n / d)) * d in liftM2 mod [6,-6] [2.5,-2.5]
01:23:13 <lambdabot>  [1.0,-1.5,1.5,-1.0]
01:23:32 <ski> > liftM2 mod [6,-6] [2,-2]
01:23:34 <lambdabot>  [0,0,0,0]
01:23:34 <ketil> hmm.  I have an option in my program to do some stuff (run gnuplot) via forkIO, and it seems a bit unreliable.
01:23:44 <ski> > liftM2 mod [6,-6] [4,-4]
01:23:46 <lambdabot>  [2,-2,2,-2]
01:23:55 <ski> > liftM2 rem [6,-6] [4,-4]
01:23:57 <lambdabot>  [2,2,-2,-2]
01:23:58 <ketil> Do I need the main program to wait around for them to finish perhaps?
01:25:07 <ski> ok, so it seems the above 'mod' variant (maybe name 'modRealFrac' ??) is consistent with usual 'mod' wrt sign
01:27:28 <DRMacIver> Yes, but the sign of the usual 'mod' is wrong. ;)
01:28:36 <cinimod> @hoogle Int -> [Int]
01:28:37 <lambdabot> No matches, try a more general search
01:29:24 <cinimod> @hoogle Integral a => a -> [Int]
01:29:25 <lambdabot> List.elemIndices :: Eq a => a -> [a] -> [Int]
01:29:54 <cinimod> @hoogle Integral a => a -> [Bool]
01:29:55 <lambdabot> No matches, try a more general search
01:30:04 <cinimod> @hoogle Integral a => a -> [b]
01:30:05 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
01:30:05 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
01:30:05 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
01:31:03 <cinimod> @hoogle Int -> Int -> [a]
01:31:04 <lambdabot> No matches, try a more general search
01:31:11 <ddarius> ketil: Unless they've changed it, if the main thread terminates the whole program terminates.
01:31:35 <cinimod> @hoogle (Integral a, Integral b) => a -> b -> [a]
01:31:36 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
01:31:36 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
01:32:36 <cinimod> Is there a library function somewhere that takes an Int and returns a fixed width binary representation?
01:34:42 <ddarius> cinimod: I'm pretty sure not.
01:35:17 <TSC> cinimod: showIntAtBase might be close
01:35:35 <Cale> What do you mean by "fixed width binary representation"?
01:35:44 <Cale> Perhaps fromIntegral with the Int32 type?
01:36:24 <cinimod> I mean I want to encode e.g. 1..5 into 3 bits
01:36:40 <Cale> ah, okay
01:36:41 <cinimod> or 1..17 into 5 bits
01:36:52 <cinimod> so 1 would be 00001
01:37:08 <Cale> So you want the actual bits, not just that it's internally stored using a particular size.
01:37:18 <cinimod> exactly
01:37:33 <Cale> I think probably unfoldr or equivalent is your best bet.
01:37:40 <cinimod> I can code it myself but if it's in a library somewhere I'd rather use that
01:38:13 <ddarius> It might be in some older Binary library, but I doubt it does exactly what you want.  It certainly isn't just sitting around the standard library.
01:38:19 <cinimod> yes I have an unfoldr version that produces variable length encoding so I just need to pad it
01:38:26 <Cale> There's showIntAtBase, but it doesn't ensure a particular length.
01:38:31 <cinimod> Ok thanks worth a try
01:40:12 <cinimod> @help
01:40:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:41:01 <ddarius> You could just .&. against 2^n for n = 0 to whatever.
01:41:36 <cinimod> that sounds better than unfold and pad
01:42:17 <ddarius> :t .&.
01:42:23 <lambdabot> parse error on input `.&.'
01:42:33 <ddarius> :t (.&.)
01:42:35 <lambdabot> forall a. (Bits a) => a -> a -> a
01:42:41 <ddarius> @src Bits
01:42:42 <lambdabot> Source not found. Do you think like you type?
01:42:49 <ddarius> @instances Bits
01:42:50 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
01:45:04 <Cale> YouTube seems to actively stifle intelligent discussion in the comments by its very construction.
01:46:20 <cinimod> but now I need integer log 2
01:46:27 <Cale> If you want to write a comment longer than 500 characters, it seems the only way to do it is to break your message into chunks less than 500 characters and reply to yourself recursively.
01:46:55 <cinimod> is there a library function giving the minimum number of bits into which a number would encode?
01:46:57 <ketil> ddarius: thanks (sorry, was busy coding :-)
01:47:29 <Cale> cinimod: probably the best thing would be to work out how much padding you'll need as you go along.
01:47:33 <ddarius> cinimod: It is easy to work that into the routine.
01:47:39 <cinimod> yes ok
01:48:28 <Cale> In fact, you can even start with the maximum padding and carry the tail along each time you get a new bit.
01:48:53 <ketil> Cale: Heh - same for the newspapers here.  They complain about the quality and level of reasoning in their forums, but limit the reader submissions to SMS sizes.
01:49:57 <cinimod> ddarius: while you are on why does the coincidence of inductive types and coinductive types cause consistency problems?
01:50:16 <ddarius> cinimod: It let's you implement the fixpoint operator.
01:50:23 <cinimod> there's a perfectly good semantics for this wCPOs
01:50:44 <ddarius> cinimod: Which corresponds to an inconsistent logic.
01:51:38 <cinimod> ddarius: fair enough
01:52:39 <Cale> Formulating an argument more coherent than "LOL ZOMG ROFLOL!!!111" in less than 500 characters can be pretty challenging.
01:53:54 <ketil> But for some reason, you can fit quite a bit of profanity and vulgar prejudices into 500 chars.
01:54:23 <ketil> Does that mean the information content is higher in vulgarities than in reasoned argument?
01:54:26 <ketil> :-)
01:54:34 <Cale> heh
01:54:48 <ketil> @hoogle [ThreadId] -> IO ()
01:54:52 <lambdabot> No matches, try a more general search
01:54:53 <ddarius> Quite seriously, I'm almost certain it is.
01:55:06 <cinimod> @type unfoldr
01:55:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:55:15 <ketil> (i.e. I want the equivalent of 'wait')
01:55:25 <ketil> @hoogle ThreadId
01:55:26 <lambdabot> Control.Concurrent.ThreadId :: data ThreadId
01:55:26 <lambdabot> GHC.Conc.ThreadId :: ThreadId# -> ThreadId
01:55:26 <lambdabot> Control.Concurrent.myThreadId :: IO ThreadId
01:56:06 <ddarius> ketil: Wait for all threads to terminate?
01:56:12 <ketil> xsactly.
01:56:46 <ddarius> I don't know if they've made a convenience function around the current hackish type solution of having each thread take an MVar and having the main thread wait on them.
01:57:20 <ddarius> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#11
01:57:22 <lambdabot> http://tinyurl.com/y2q5k2
02:00:58 <ketil> Hmm..right.
02:01:00 <ketil> Thanks.
02:04:27 <DRMacIver> Hm
02:04:38 <DRMacIver> Alice ML and GHC appear to depend on incompatible versions of libgmp3.
02:04:41 <DRMacIver> How... annoying.
02:04:55 <Cale> It's a conspiracy!
02:06:42 <DRMacIver> Might just be an artifact of the debian package. I'll try building Alice from source.
02:09:59 <yango> why do fold* need a () around the function/operator?
02:10:12 <quicksilver> yango: they don't
02:10:27 <quicksilver> yango: but operators always need a () around them if you want to stop them being infix
02:10:53 <yango> oh, right... it's (+) but not (sqrt)
02:10:57 * quicksilver nods
02:11:08 <quicksilver> (sqrt) is fine, of course. But the () are not necessary in that case.
02:11:58 <yango> yeah, it's just I was using a defined by me function, which of course at first didn't work, so I blamed it on the () not on my utter newbieness :)
02:13:23 <quicksilver> :)
02:14:00 * DRMacIver mutters darkly
02:14:09 <DRMacIver> Well, Alice ML doesn't build from source on my machine for entirely different reasons.
02:14:16 <DRMacIver> I really need to downgrade back to 32bit.
02:15:25 <DRMacIver> (Although they claim it supports AMD64, so maybe it's not that)
02:31:25 <ejt> I'm using lazy IO from a socket in an application; I was wondering if people think this is a good idea, or should make this code more strict ?
02:35:54 <Cheery> ejt: laziness in communication == good iff failure relilient
02:36:45 <goltrpoat> drm:  i have both ghc 6.6 and alice 1.4 running on a debian machine, didn't build either one from source
02:37:27 <ejt> Cheery: not sure I understand you ?
02:37:55 <Cheery> ejt: if you can make sure it can't botch up without a reason, it's great
02:38:03 <ejt> k, thx
02:38:35 <ejt> I'm having trouble with the program, it's a chess client fro FICS, sometimes it works, sometimes it hangs on input
02:39:43 <Cheery> and you think it'd be in reading IO from socket lazily?
02:40:20 <ejt> I can't think what else
02:40:43 <ejt> I think I'm going to fake up a server so I'm know the input isn't changing
02:40:56 <ejt> just reading SMs high performance webserver paperr ATM
02:48:48 <Cheery> I wonder whether I should make my hsdl window -allocation more functional-style
02:49:22 <Cheery> how haskell handles values runtime?
02:50:24 <Cheery> would it be simple to make the window context destroy when it has left the graph?
02:51:01 <Cheery> similar to just an another value. :)
02:52:30 <Cheery> ie. when the window context is lost, the window shuts down itself.
03:30:59 <hpaste>  yango pasted "hugs complains..." at http://hpaste.org/1810
03:37:06 <ejt> you're doing io inside fib
03:37:14 <ejt> so it needs to be inside the IO monad
03:37:45 <ejt> yango: start by adding type signatures to all your functions
03:38:57 <yango> ejt: ok, so I'm trying to step way ahead of the current chapter of the tutorial :)
03:39:10 <ejt> y, I guessed it was something like that
03:39:48 <ejt> because Haskell is lazy you can't use imperative features (like outputting a string) everywhere
03:40:23 <ejt> have you covered type signatures ?
03:40:24 <yango> yeah, I've read about it... but forget it, of course. What's the idiom to complain about n < 1 in fib then?
03:40:31 <Saizan> also for error messages there's error :: String -> a that throws an exception
03:40:52 <ejt> 'error' is fine for what you want
03:41:09 <ejt> but isn't nice for real programs
03:41:56 <yango> can't be "catched"?
03:42:26 <Saizan> it can, but only from IO
03:42:40 <Saizan> ?type catch
03:42:45 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
03:43:22 <Saizan> however don't bother with this at this point :)
03:43:58 <yango> yes, will get back to exercises
03:43:59 <yango> :)
03:44:00 <yango> thanks
03:44:06 <hpaste>  ejt annotated "hugs complains..." with "use error" at http://hpaste.org/1810#a1
03:44:54 <ejt> yango: which book are you using ?
03:45:17 <yango> YAHT
03:58:37 <ejt> has anyone written a rewrite program that removes explicit recursion ?
03:59:37 <Saizan> fix?:)
04:00:45 <DRMacIver> Well @pl will do that.
04:00:49 <ejt> I was more thinking of something like @pl, which I use when I suspect that my pointful code could be improved
04:01:01 <DRMacIver> It just has a few other effects along with it. :)
04:01:29 <ejt> oh, I'll try
04:01:49 <dmhouse> ejt: I think there's a program called #haskell that does that. You type your code into an 'IRC client' or something like that and about a dozen people start playing around with your code.
04:01:57 <DRMacIver> Well, what I mean is that pointfree code automatically has no explicit recursion in it.
04:02:10 <ejt> DRMacIver: y, you're right
04:02:52 <DRMacIver> I agree that it would be nice to have something which didn't go quite so far and just removed explicit recursion.
04:03:03 <hpaste>  ejt pasted "simplification question" at http://hpaste.org/1811
04:04:18 <yango> what's wrong with explicit recursion?
04:04:29 <ejt> yango: you should use it ;)
04:04:39 <ejt> yango: then when you are good at it, never use it
04:04:59 <dmhouse> I disagree.
04:05:22 * edwinb too ;)
04:05:26 <dmhouse> Often explicit recursion is the only way of expressing something, there simply aren't enough HOFs.
04:05:47 <edwinb> I'm not writing a load of HOFs for everything I might want to do with every complex data structure
04:05:52 <yango> just like those painters, who first learn how to paint the most detailed and realistic scenarios, and then go on to paint a black canvas with a white line on it
04:05:56 <dmhouse> Most _simple_ paradigms of recursion can be captured with maps, folds, scans, zips and so on, but once you get a bit more complicated, recursion's a great tool you should take advantage of.
04:05:57 <edwinb> abstraction is good, but sometimes I want to see what's going on easily...
04:05:58 <DRMacIver> Nothing is wrong with explicit recursion. But when you can find a higher order way of expressing the definition it often makes the code nicer.
04:06:24 <DRMacIver> ejt: I think you can do something nice with tails and filtering here
04:06:52 <edwinb> yes, I'd rather use maps, folds, etc on lists. But not on more complex things like syntax trees, unless there turns out to be some common pattern
04:06:53 <dmhouse> DRMacIver: then how would you capture the prefix?
04:07:03 <edwinb> which there often does
04:07:24 <DRMacIver> dmhouse: Haven't decided yet. I'm speculating. :)
04:07:33 <dmhouse> I'd generate the list of splits, i.e. map (\i -> splitAt i xs) [1..]
04:07:37 <yango> HOF = Haskell's own function?
04:07:44 <dmhouse> yango: higher-order function.
04:07:53 <DRMacIver> Also "Huge Orange Fish"
04:09:35 <ejt> dmhouse: trying splits approach ...
04:11:20 <hpaste>  dmhouse annotated "simplification question" with "findSubstring" at http://hpaste.org/1811#a1
04:11:29 <dmhouse> ejt: try ^^
04:11:52 <ejt> (not looking until I've finished the one I'm working on)
04:12:01 <dmhouse> (It uses a Maybe result type in case the substring isn't found in the list, this differs from your behaviour but I think it's better.)
04:12:03 <dmhouse> Okay.
04:12:46 <ejt> agree with the Maybe, will change
04:16:56 <ejt> dmhouse: ok, I've got a splits one working, will now post and compare with yours
04:17:16 <Saizan> mapping splitAt seems a waste.. it has to restart from the head of the list every time
04:17:34 <hpaste>  ejt annotated "simplification question" with "using splits" at http://hpaste.org/1811#a2
04:18:06 <hpaste>  dmhouse annotated "simplification question" with "Slightly different version" at http://hpaste.org/1811#a3
04:18:42 <ejt> better, you're first had an idexing error ?
04:18:43 <dmhouse> ejt: you've got the basic idea, just missed out on using the find function.
04:18:54 <ejt> y, I don't habitually use that one
04:19:00 <ejt> thanks for the help
04:19:03 <dmhouse> Yeah, if the prefix was at the start of the list it wouldn't have worked, my second fixes that.
04:19:08 <dmhouse> Saizan: true, hmm...
04:19:58 <ejt> so maybe we needs a splits function that uses an accumulator ?
04:21:10 * dmhouse wonders whether splits is necessarily O(n^2)
04:21:32 <dmhouse> ?src splitAt
04:21:33 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
04:22:07 <ejt> I don't think so, we could write it in a similar way to find' in my original
04:22:22 <dmhouse> Well, okay, that uses O(n) space and O(n) time.
04:22:55 <dmhouse> Or is it...
04:23:26 <dmhouse> If you had to reverse every split, that'd make it O(n^2) again.
04:23:42 <ejt> I only reverse in the final case
04:23:49 <ejt> ah,
04:23:57 <ejt> see what you mean
04:24:29 <dmhouse> Hrm.
04:24:54 <dmhouse> I think getting the splits is always O(n^2), BUT if we only reversed the matching split, that'd make it O(n) again.
04:25:01 <ejt> splits the first element reversed, and leave it to the caller to reverse the one he wants
04:25:18 <ejt> y
04:27:31 <hpaste>  dmhouse annotated "simplification question" with "O(n) version (I think)" at http://hpaste.org/1811#a4
04:27:46 <dmhouse> ejt: ^^ check that one out.
04:27:53 <ejt> one minute :)
04:29:08 <hpaste>  dmhouse annotated "simplification question" with "Bugfix from previous" at http://hpaste.org/1811#a5
04:29:20 <dmhouse> ejt: and the bugfix ^^ :)
04:30:30 <hpaste>  dmhouse annotated "simplification question" with "Another bugfix from previous :)" at http://hpaste.org/1811#a6
04:30:40 <dmhouse> ejt: and another bugfix :)
04:30:43 * dmhouse is done now
04:31:28 <hpaste>  ejt annotated "simplification question" with "using splits" at http://hpaste.org/1811#a7
04:31:44 <ejt> me too, now to see how much shorter yours is ;)
04:32:21 <ejt> mmm, fmap on a Maybe
04:32:29 <dmhouse> ejt: first is a function in Control.Arrow defined thusly:
04:32:35 <dmhouse> first f (x, y) = (f x, y)
04:32:48 <dmhouse> (Well, that's how it is for the (->) arrow.)
04:32:51 <dmhouse> ?src (->) first
04:32:51 <lambdabot> first f = f *** id
04:33:01 <ejt> y, have been reading up on arrows
04:33:02 <dmhouse> ?src (->) (***)
04:33:03 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
04:33:21 <dmhouse> It's just a nice combinator.
04:33:54 <ejt> interesting difference in our splits' definitions
04:38:44 * dmhouse sets about bugfixing his hpaste.el
04:39:31 <ejt> I should write one of those for TextMate
04:39:49 <dmhouse> ejt: no, you should use Emacs :)
04:40:03 <ejt> have done for 20 years
04:40:21 <ejt> switched to TextMate on my OS X laptop, it's that good
04:40:42 <ejt> still use emacs for day job though
04:41:29 <joelr1> good day
04:42:02 * ejt bows
04:43:33 * Saizan notices that findSubString is basically using a Zipper
04:43:40 <dmhouse> Saizan: it is indeed.
04:44:00 <dmhouse> You could generalise it to any datastructure! :)
04:45:39 <Saizan> we need a Zipper class! the problem is that every datastructure can have many different directions
04:46:39 <dmhouse> Anyone else find that one of the first things they do on a new system is installing an appreciable percentage of Hackage?
04:46:49 * dmhouse is installing his... 5th? or 6th? dependency for hpaste
04:46:50 <ejt> yep
04:47:22 <ejt> is there a way to get cabal to do the downloading and installing ?
04:47:31 <dmhouse> ejt: work is underway with cabal-install.
04:47:37 <ejt> I get bored of tying runhaskell setup etc.
04:47:41 <dmhouse> Albeit not very quickly, I gather.
04:48:23 <ejt> doesn't sound hard
04:48:44 <dmhouse> ejt: why not hack on it yourself? :)
04:49:00 <dmhouse> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
04:49:03 <lambdabot> Title: CabalInstall - Hackage - Trac
04:49:06 <ejt> because I have trouble writing a findSubString function ?
04:50:02 * dmhouse yawns whilst waiting for the monolithic HAppS to compile
04:50:26 <ejt> dmhouse: you wrote hpaste ?
04:50:37 <dmhouse> ejt: nope, it was glguy. I wrote the Emacs integration.
04:50:59 <dmhouse> I'm currently installing a local copy of hpaste so I can reproduce the bug I'm getting in said Emacs library and fix it.
04:51:14 <ejt> ah, I read the hpaste code through the other day, very helpful, looks like it stole a lot from the 'roll you own irc bot' tutorial
04:51:14 <dmhouse> (Without spamming hpaste.org.)
04:54:24 <ejt> I've not come across Zippers before, neat idea
04:54:52 <dmhouse> ejt: have you seen http://en.wikibooks.org/wiki/Haskell/Zippers ?
04:54:52 <ejt> I have a program where I'm using Control.Arrow.Tree to manipulate tree structures.  I wonder if a zipper would be easier
04:55:19 <ejt> dmhouse: no, that looks good, thx
04:57:33 * dmhouse waits for the monolithic darcs version of HAppS to compile after hpaste failed to compile on the release version
05:02:02 <beelsebob> dons poke
05:03:29 <hpaste>  drigz pasted "why is this code slow?" at http://hpaste.org/1812
05:03:38 <drigz> that seems like it should be quite fast to me?
05:04:18 <ejt> why do you think it's slow ?
05:04:44 <drigz> it's taking up 40% of the runtime of my program
05:04:49 <DRMacIver> Well, I've finally given into the trend and written my own introduction to monads. :)
05:05:00 <dmhouse> DRMacIver: yay, where is it? :)
05:05:20 <beelsebob> anyone have experience of compiling lambdabot recently?
05:05:35 <drigz> ah, it's a lot faster if you don't unpack the last 4 elements
05:05:40 <DRMacIver> dmhouse: http://unenterprise.blogspot.com/2007/05/whats-monad.html
05:05:42 <lambdabot> Title: Desperately UnEnterprise: What's a monad?
05:05:44 <drigz> i guess it's all the breaking up and reforming lists
05:06:08 <ejt> drigz: you sure you're not forcing some deferred calculation that really is slow ?
05:06:32 <drigz> ejt: why would that force calculations? it doesn't look at the contents
05:06:49 <dmhouse> DRMacIver: ah, I know no Java, shame. :(
05:06:57 <ejt> it looks at the length
05:07:00 <dmhouse> glguy: ping
05:07:04 <DRMacIver> dmhouse: It doesn't really involve much Java.
05:07:17 <DRMacIver> dmhouse: After the first line of Java it descends into Scala, which you probably know even less of. ;)
05:07:46 <DRMacIver> I kinda hoped that the code I wrote would be readable even if you didn't know the language though.
05:07:52 <beelsebob> hmm
05:08:06 <beelsebob> apparently another monad introduction that teaches by example
05:08:12 <beelsebob> but can't explain a general pattern
05:08:21 <drigz> it's called as map triples . permutations $ [1..9], maybe it's forcing the forming of lists from permutations
05:09:04 <ejt> I think the best intro to monads is Hughes' arrows paper, made things click for me anyway
05:09:34 <DRMacIver> beelsebob: The point is more to demystify than to cause the reader to walk away enlightened.
05:09:37 <dmhouse> DRMacIver: most likely.
05:09:52 <ejt> drigz: can you replace triples with something you know is trivial, such as length ?
05:09:59 <beelsebob> DRMacIver: the point I was trying to make is that I'm yet to be convinced that monads actually capture a common behaviour and hence *can* be explained in a general sence
05:10:30 <beelsebob> or rather, a common behaviour that's more interesting than the monad laws
05:10:50 <DRMacIver> beelsebob: Ah, right. I suspect they do capture a general pattern, but you need a buttload of category theory to understand it. ;) I'm just not trying to focus on that.
05:11:07 <beelsebob> DRMacIver: I have gone a lot into the category theory
05:11:20 <beelsebob> in a vain attempt to find the common behaviour
05:11:35 <DRMacIver> The idea with my post is simply to motivate why the monad operations are a sensible thing to come up with and how they relate to do notation
05:11:35 <beelsebob> unfortunately, coming out empty handed, (although I admit I need to study it more still)
05:11:52 <beelsebob> DRMacIver: sure, sorry, I didn't mean it as a criticism against you in any wa
05:11:57 <beelsebob> or against your write up
05:12:12 <beelsebob> it was mostly meant as a criticism of monads
05:12:12 <dmhouse> beelsebob: what about the fact that they model different types of computation?
05:12:14 <DRMacIver> Yeah, I realised that now. :) Sorry if I snapped in response.
05:12:41 <DRMacIver> I don't understand the category theory very well either. My category theory is rather rusty and my Haskell is weak, so I've not really managed to mesh the two
05:12:50 <beelsebob> dmhouse: *different* types of computation -- the point of an abstraction is to model the *same* type of computation
05:13:04 <beelsebob> otherwise it's not useful to understanding what's going on
05:13:09 <dmhouse> DRMacIver: seen http://en.wikibooks.org/wiki/Haskell/Category_theory? It's probably the best article on the Wikibook
05:14:03 <dmhouse> beelsebob: the point is that certain control structures are common to all types of computation.
05:14:11 <dmhouse> (Success, failure and sequencing come to mind.)
05:14:25 <dmhouse> (I.e. return, fail and (>>=).)
05:14:40 <DRMacIver> dmhouse: I'll read through it later, thanks. For now I'm going to stop staring at the computer and go outside. :)
05:14:49 <dmhouse> DRMacIver: but it's raining!
05:15:01 <beelsebob> dmhouse: okay, that gets me pretty much to what my main bugbear with monads is
05:15:10 <beelsebob> they appear to be a *great* abstraction for sequencing
05:15:18 <beelsebob> if you have a sequential computation -- go for them!
05:15:30 <DRMacIver> dmhouse: Not here. :)
05:15:38 <beelsebob> however, lots of people here think they're a great solution to pretty much every problem
05:15:42 <Syzygy-> DRMacIver: That's just what YOU think.
05:15:45 <beelsebob> whether it's inhearently sequential or not
05:16:04 <DRMacIver> beelsebob: By the way, it should be noted that I very often explain things like this. The fact that I'm doing it for monads is just a special case. :)
05:16:07 <drigz> ejt: i replaced it with const [([], [], [1])], but i'm not sure what the results should tell be
05:16:17 <beelsebob> DRMacIver: :)
05:16:33 <DRMacIver> Syzygy-: err, which bit? :)
05:16:38 <Syzygy-> The rain
05:16:46 <Syzygy-> Or, most of ti, relaly
05:17:00 <DRMacIver> Oh, well yes. It will probably start raining as soon as I go outside.
05:17:04 <DRMacIver> It's been off and on all day.
05:17:39 <dmhouse> beelsebob: 'sequencing' is actually a very general term, though. Any time you want to sequence computations in any way other than passing a value into a function, then another function, monads are useful. E.g. monads are often used to hide state threading, where you have to be careful with the sequencing as you have to update the state along the way.
05:17:49 <ejt> drigz: const wont force the first 9 elements of the list
05:18:15 <beelsebob> dmhouse: my point really is that it's actually very rare I want to do any more than push something from a function to a function
05:18:30 <beelsebob> if I can't describe it neatly without sequence I probably haven't thought about it enough
05:18:48 <beelsebob> doing things without sequence is pretty much what functional programming is about to me
05:19:05 <dmhouse> To some extent.
05:19:11 <dmhouse> I wouldn't say monads are over-used, though.
05:19:28 <beelsebob> well, okay then, an example
05:19:42 <beelsebob> I have a debugger
05:19:47 <beelsebob> bernie pope has a debugger
05:20:19 <beelsebob> Bernie's involves unsafe updates to lists and IO Refs to catch what's going on
05:20:28 <drigz> ejt: ok, i tried triples l = [([], [], [length l])] and triples doesn't use much time up
05:20:35 <drigz> 12.5% compared to about 40% before
05:20:43 <beelsebob> mine involves only one top level monadic function that does the interaction
05:20:58 <beelsebob> and it turns out that the rest of the debugger is actually beautifully mathematical
05:20:59 <ejt> drigz: ok, I'm wrong then :)
05:21:04 <beelsebob> it just took some thinking about to come up with
05:21:13 <drigz> ejt: in fact, my bad
05:21:29 <dmhouse> beelsebob: I see.
05:21:43 <drigz> it takes 12.5% compared to 13% with my new code
05:21:57 <ejt> ah
05:21:58 <dmhouse> beelsebob: yes, I suppose there may be an argument that the unsafe aspects of Haskell are sometimes used as a crutch for when you don't want to get out of your imperative mindset.
05:22:08 <dmhouse> beelsebob: but I'm not sure that extends to a general criticism of monads.
05:22:09 <drigz> the 13% is of a number about twice as large
05:22:19 <beelsebob> dmhouse: no, not really
05:22:26 <beelsebob> it extends to a criticism of their use
05:22:52 <dmhouse> Even still, I'd stop short of saying that all monads are overused.
05:22:54 <beelsebob> it is partly monads fault
05:23:15 <beelsebob> in that they are more general than just sequencing
05:23:29 <beelsebob> but no one can really pin down what that generalness is
05:23:59 <dmhouse> Well, they generalise sequencing in that you can define exactly what the term 'sequencing' means by defining your own (>>=).
05:24:14 <beelsebob> exactly
05:24:34 <beelsebob> and I can define 'sequence' to mean throw jam at one of the inputs and ham at the other
05:24:41 <beelsebob> assuming that that works with the monad laws
05:24:50 <dmhouse> Sure.
05:24:59 <dmhouse> But that's not monads' fault, that's your fault.
05:25:11 <beelsebob> what I'm saying is that the definition of sequence can become something stupid
05:25:18 <ejt> beelsebob: you're just saying that sometimes people write bad code
05:25:35 <beelsebob> in other words the abstraction includes a lot of things that are not traditionally thought of as "sequencing"
05:25:52 <dmhouse> beelsebob: so your point is that monads give you enough rope to hang yourself by?
05:26:09 <beelsebob> dmhouse: yes -- which is something that I've got used to Functional Programming languages not doing
05:26:21 <beelsebob> in general they tell you exactly what length of rope they're giving you
05:26:22 <dmhouse> I.e. they're so general that people can use them to get stupid results, and therefore they should be less general?
05:26:42 <beelsebob> take for example the tree abstraction
05:27:06 <beelsebob> with the tree abstraction I get a nice little label hanging round the code saying "this thing organises things in a nice logarithmic structure"
05:27:08 <dmhouse> beelsebob: I don't really see how that relates to your above example of someone overusing the impure features of Haskell, though.
05:27:29 <beelsebob> and it's pretty damn hard to break out of the box of putting things in a tree
05:27:46 <beelsebob> monads give me a label saying "this has something to do with sequencing computations"
05:28:49 <dmhouse> Hrm.
05:28:49 <beelsebob> but often there are two problems with that (a) thinking about the computation as a sequence often actually makes it harder to understand (b) the definition of sequence may be so loose that it's useless
05:29:07 <dmhouse> Well, all the monads in, say, mtl have sensible sequencing semantics.
05:29:09 <beelsebob> (a) is a problem with the programmer
05:29:14 <beelsebob> (b) is a problem with monads
05:29:32 <dmhouse> beelsebob: have you got any specific monads in mind for which (b) is true?
05:29:49 <beelsebob> I'd suggest that it's pretty tenuous for the list monad
05:30:19 <dmhouse> Then I'd suggest you don't fully understand the list monad.
05:30:30 <takamura> hi
05:30:38 <beelsebob> tell me what your understanding of the sequence behaviour of the list monad is then?
05:31:00 <ejt> if Monad was too general to be useful then there wouldn't be mtl
05:31:36 <ejt> it is useful precisely because you can use general purpose combinators
05:31:40 <dmhouse> beelsebob: copmutations in [] can have any number of valid answers (for example, parsing ambiguous grammars). Sequencing two of these computations together involves calling the second on every possible value of the first, then 'flattening' the results down into one list of possible answers.
05:32:36 <beelsebob> ah, so what you're saying is that the result I want is all the combined solutions in a big list
05:32:46 <beelsebob> oh look -- I can easily describe that without it being a sequence
05:32:49 <dmhouse> ejt: I don't think he's arguing that monads aren't useful, but instead that they're so general they've become the hammer in every Haskell programmers' toolbox, and we see every problem as a nail, regardless of whether it'd be better modelled as a screw or not.
05:33:02 <dmhouse> beelsebob: functional programming doesn't remove sequencing.
05:33:08 <dmhouse> f (g x) -- Call g on x, then f.
05:33:16 <dmhouse> *Call g on x, then f on the result of that.
05:33:19 <ejt> dmhouse: well that's an education problem surely
05:33:20 <Syzygy-> Oh, if only you bash hard enough, the screw becomes a nail!
05:34:03 <beelsebob> dmhouse: certainly but I can more clearly read f (g x) than I can the monadic version
05:34:17 <dmhouse> beelsebob: because in this case the monad is so trivial it's not worth bothering with.
05:34:27 <beelsebob> dmhouse: okay
05:34:34 <beelsebob> yet the list monad is used by a lot of people
05:34:42 <beelsebob> because they think "wow, monad, got to use that"
05:34:44 <dmhouse> No, not [].
05:35:10 <beelsebob> I've seen a lot of people use the list monad just because they can
05:35:13 <dmhouse> beelsebob: once you start dealing with functions will multiple possible outputs, or functions that can fail, or functions that rely on state, sequencing becomes complex enough such that it's useful to hide the details.
05:35:36 <beelsebob> certainly -- computations that involve state -- monads win
05:35:44 <beelsebob> computations that involve IO -- monads win
05:35:51 <dmhouse> Otherwise refactoring a program that uses the list monad to get rid of the monadic bits will involve _lots_ of concats and maps all over the place.
05:35:56 <beelsebob> but again this is a source of over use
05:36:19 <beelsebob> if you have a program that involves IO most people in this channel seem to write the entire program in the IO monad
05:36:30 <dmhouse> Really?
05:36:38 <dmhouse> That's most definitely bad Haskell style.
05:36:46 <beelsebob> rather than just wrapping the nice "core" of their program in a simple 1 or two IO-action wrapper
05:36:49 <beelsebob> yep
05:37:02 <dmhouse> Can't say I've experienced that coming from people in this channel.
05:37:30 <beelsebob> tbh, it may be a bit of a biased view
05:37:45 <beelsebob> based on the fact that 99% of the time I come in here the code being talked about is entirely monadic
05:38:07 <beelsebob> and yet I've so far not found a single time where I had to write a significant of monadic code to solve a problem
05:38:11 <ohmega> I had this functon a while ago, it went like
05:38:18 <ohmega> findLabel :: LabelName -> MethodS Instructions
05:38:20 <ohmega> +findLabel :: LabelName -> Instructions -> Instructions
05:38:20 <ohmega>  findLabel lname =
05:38:20 <ohmega>    do m <- ask
05:38:30 <beelsebob> s/had to/it would have been nice to/
05:38:57 <ohmega> Or well, without that line with the +. Then I switched from the MethodS Instructions to use Instructions -> Instructions, but the ask was still there
05:39:09 <dmhouse> I think we're just speaking from different experiences. If I saw the list mnad being used in places where it were just as clear to do it without monads, or an entire program being written in IO when all you really needed was a 1- or 2-function interaction layer, with the rest being pure, then I'd probably agree with you.
05:39:10 <ohmega> I forgot to remove it. I was very confused when my code still worked ;)
05:39:28 <ohmega> Then I found out that -> was actually an instance of Reader :)
05:39:33 <beelsebob> dmhouse: :) violent agreement we come to :D
05:39:47 <dmhouse> ohmega: crazy, isn't it? :)
05:39:51 * beelsebob is good at having violent agreements with people
05:39:57 <dmhouse> ohmega: well, (->) is an instance of MonadReader.
05:39:58 <ohmega> dmhouse: yeah :)
05:40:06 <dmhouse> ohmega: interestingly, (->) and Reader are basically the same thing.
05:40:21 <dmhouse> newtype Reader r a = Reader {runReader :: r -> a}
05:40:32 <dmhouse> I.e. newtype Reader r a = Reader (r -> a)
05:40:43 <dmhouse> So a 'Reader r a' is just a wrapped-up version of an 'r -> a'.
05:40:55 <dmhouse> So Reader is, up to wrapping, the same as (->).
05:41:01 <ohmega> Oh ok :)
05:41:21 <dmhouse> (Similarly Writer w a is isomorphic to (w, a).)
05:42:29 <ToRA__> > (do { x <- ask ; return (x 3) }) (+1)
05:42:32 <lambdabot>  4
05:44:18 <Saizan> is there a script to automatically insert typesignatures in a file?
05:45:21 <dmhouse> Saizan: If you use Emacs's haskell-mode, then C-u C-c C-t will insert the type signature of the function at point in the line above.
05:46:05 <Saizan> dmhouse: it doesn't work for me
05:46:14 <ohmega> Does it use ghc for that?
05:46:21 <dmhouse> ohmega: yeah.
05:46:29 <dmhouse> Saizan: are you using inf-haskell?
05:46:38 <dmhouse> If not, you should be.
05:46:48 <Saizan> Symbol function definition is void: remove-if in the minibuffer
05:46:53 <Saizan> yes, i'm using it
05:46:59 <dmhouse> Which version of haskell-mode?
05:47:12 <Saizan> svn
05:47:52 <dmhouse> You might need to do C-c C-l beforehand.
05:48:11 <Saizan> i have done it ..
05:48:17 <Saizan> C-c C-t works
05:48:30 <dmhouse> remove-if is an autoloaded Lisp function in `cl-seq'.
05:48:43 <dmhouse> That's from my C-h f remove-if RET
05:49:32 <Saizan> uhm C-u C-c C-t works only for operators ..
05:49:40 <dmhouse> It works for functions for me.
05:49:57 <dmhouse> Saizan: do C-h f remove-if RET
05:50:02 <Saizan> no match
05:50:10 <dmhouse> Try (load "cl-seq")
05:50:34 <dmhouse> That is, M-: (load "cl-seq") RET
05:52:40 <dmhouse> Saizan: then try C-h f remove-it RET again, and see if it works.
05:52:42 <Saizan> i've had to (load "cl") forst but now it works, thanks!
05:52:47 <dmhouse> Cool. :)
05:53:14 <Saizan> i can put this 2 loads in .emacs right?
05:53:19 <dmhouse> I think inf-haskell.el is missing a (require 'cl).
05:53:29 <dmhouse> Should be able to.
05:53:40 <dmhouse> Use (require 'cl) rather than (load "cl").
05:54:09 <Saizan> ok
05:54:27 <dmhouse> Hrm, cl gets loaded with haskell-mode for me.
05:55:02 * Saizan now understands why this module dosn't have any typesign, they are 9 lines tall!
05:55:24 <dmhouse> Eep. Someone needs to learn about type synonyms! :)
05:58:21 <Saizan> or use superclasses
06:11:29 <dcoutts> falconair: it's deserialisation that is an applicative functor, serialisation is a monoid
06:12:31 <dcoutts> falconair: at a minimum anyway
06:23:22 <Nicu_> @pl isSubstringOf3 as bs = any done $ scanl next (makeTable as) bs
06:23:23 <lambdabot> isSubstringOf3 = (any done .) . scanl next . makeTable
06:29:44 <ehird`> is @pl as pointless (;)) as it seems?
06:30:43 <ejt> I find it very useful, but sometimes it does return unreadable code
06:30:55 <ehird`> why is it useful?
06:31:10 <Botje> ehird`: "map"
06:31:22 <ejt> because often I have a pointful function that I want to make pointless
06:31:32 <ehird`> Botje: map = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . liftM2 flip (((.) . (:)) .))
06:31:52 <Botje> ehird`: yes, there are limits.
06:32:14 <Botje> but for simple statements, a pointfree statement is more clear than a pointful one
06:33:06 <Botje> just as map (+5) is more clear than map (\x -> x + 5)
06:33:29 <yango> ?src map
06:33:30 <lambdabot> map _ []     = []
06:33:30 <lambdabot> map f (x:xs) = f x : map f xs
06:34:08 <ehird`> hm:
06:34:09 <ehird`> sequence = foldr (liftM2 (:)) (return [])
06:34:19 <ehird`> that's rather prettier than the @src one. heh
06:34:38 <yango> is there any practical difference saying map x [] = [] instead of map _ [] = [] ?
06:34:42 <erider> good morning
06:35:09 <ehird`> yango: well, the former might use more memory or something?
06:35:16 <ehird`> because it creates a binding instead of just dropping it?
06:35:18 * DRMacIver returns
06:35:19 <ehird`> for huge lists
06:35:29 <ehird`> er, s/huge lists/huge functions
06:36:03 <ejt> ehird`: no difference, except the human reader would expect x to be used
06:36:21 * ehird` doesn't see why
06:36:42 <ejt> if your function was longer, it wouldn't be so clear that it wasn't
06:37:12 <yango> foo _ _ _ _ _ = -1
06:38:57 <ehird`> foldM = fix (\ aw f i -> (\ w -> ((\ ao cp ai aj am -> (ao cp aj) >>= (ai am)) >>= \ aa -> (\ cv ar as -> aw cv as ar) >>= \ z -> return (\ ag -> aa ag z)) f i (head w)) >>= \ be -> tail >>= \ bd -> return (be bd))
06:39:01 <ehird`> har
06:39:06 <yango> hangman _ _ _ _ _ _ _ = do putStrLn "Guess the word!";
06:39:15 <yango> 8o)
06:39:24 <ehird`> @unpl > @pl :P
06:39:25 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
06:40:52 <ehird`> surely this is illegal: foldM = fix (flip flip ((tail >>=) . (return .)) . ((flip . ((>>=) .)) .) . flip flip head . ((flip . ((.) .)) .) . (((flip . (((.) . (>>=)) .)) .) >>=) . (. ((return .) . flip)) . (>>=) . (flip .))
06:40:55 <ehird`> :P
06:41:25 <ejt> which bit do you think is wrong ;)
06:41:36 <ehird`> i meant illegal as in law :)
06:41:41 <qwr> @pl \a b c d -> a (b c d)
06:41:41 <lambdabot> (.) . (.)
06:42:42 <yango> ehird`: where are you getting that code from?
06:42:48 <ehird`> yango: lambdabot
06:42:56 <ehird`> @src -> @pl -> @unpl -> any number of times
06:42:56 <lambdabot> Source not found. It can only be attributed to human error.
06:43:12 <ehird`> yay x y z g b c = y z (\ d j -> d (x j)) g (b c) <-- it has spit out this. i am trying to find a use for it as we speak.
06:44:01 <Saizan> ?type \x y z g b c = y z (\ d j -> d (x j)) g (b c)
06:44:03 <lambdabot> parse error on input `='
06:44:10 <Saizan> ?type \x y z g b c -> y z (\ d j -> d (x j)) g (b c)
06:44:12 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. (t3 -> t4) -> (t -> ((t4 -> t5) -> t3 -> t5) -> t1 -> t6 -> t7) -> t -> t1 -> (t2 -> t6) -> t2 -> t7
06:44:19 <ehird`> ... hmmmmmmmmmmm :P
06:45:23 <ehird`> yay (\t -> t) (\a b c d -> d c b a) 3 (\x -> x 2) (\t -> \x -> t + x)  5
06:45:27 <ehird`> damn. i thought that would work
06:45:40 <ehird`> > let yay x y z g b c = y z (\ d j -> d (x j)) g (b c) in yay (\t -> t) (\a b c d -> d c b a) 3 (\x -> x 2) (\t -> \x -> t + x)  5
06:45:41 <lambdabot>        add an instance declaration for
06:45:41 <lambdabot>       (Num (((t -> t1) -> t -> t1) -> ...
06:47:01 <ehird`> lambdabot sez my expr is (5 + ($ 2)) id 3
06:49:10 <Pseudonym> Bleah.
06:49:20 <Pseudonym> It's really hard to get parts for slide rules these days.
06:49:39 <DRMacIver> Yeah, and I can never find a water trough for my horse in central London. :(
06:49:58 <Pseudonym> I have a 60s era K+E.
06:50:17 <Pseudonym> Apparently these things have a known problem where after a few decades, the cursor runners disintegrate.
06:51:05 <Pseudonym> Tough on the water trough thing, though.
06:51:22 <Pseudonym> I bet there's no mooring space on canary wharf any more, too.
06:52:44 <hpaste>  yango pasted "dumb newbie mistake, please share your insights! :)" at http://hpaste.org/1814
06:54:28 <DRMacIver> Your 'do let list = num : list' block is wrong.
06:54:59 <DRMacIver> let foo = bar doesn't assign to foo. It introduces a local definition.
06:55:54 <yango> then how can I store state?
06:56:13 <DRMacIver> Well, you use the state monad if you have to, but generally you shouldn't :)
06:56:29 <ehird`> "how can I store state?" in #haskell :)
06:56:33 <DRMacIver> if statements in Haskell are more like the ternary operator than they are like if blocks.
06:56:39 <DRMacIver> (if blocks in Java that is)
06:57:29 <DRMacIver> So rather than let list = foo; if bar list = baz else list = bif; you do let list = if bar baz else bif.
06:57:44 <TomMD> yes - it took me too long to realize that.  If blocks are math expressions, not program flow.
06:58:36 <ejt> is there a combinator like this in the standard library: ifZero m1 m2 = if m1 == mzero then m2 else m1
06:58:37 <ejt> ?
06:58:55 <DRMacIver> yango: Also you probably mean /= rather than /==
06:58:55 <ejt> where m1, m2 are members of MonadZero ?
06:59:50 <TomMD> yango - it is worth noting that the actual compiler complaint is that the then statement has no actions, just a let.  You give it an variable and ask for nothing to be done.
07:01:06 * yango is still trying to absorb this
07:02:48 <SamB_XP_> ejt: is there an ifZero?
07:02:57 <TomMD> yango: Thats fine, it took me quite a while.  I am guessing you don't have any background with ML or lisp?
07:03:14 <yango> i did some Scheme 10 years ago or so
07:03:15 <SamB_XP_> ejt: you might try mplus, though
07:03:21 <yango> and never liked it very much, to be honest
07:03:21 <yango> :D
07:03:23 <SamB_XP_> it doesn't exactly do that
07:03:23 <ejt> mplus isn't quite it
07:03:36 <ejt> I want just m1 if it's not zero
07:03:53 <DRMacIver> ejt: Hm. I swear I saw something like that the other day, but I can't find it now.
07:03:55 <kpreid> I wouldn't call that an 'if', it's more of an 'or'
07:04:00 <Laney> @src transpose
07:04:00 <lambdabot> transpose []             = []
07:04:00 <lambdabot> transpose ([]   : xss)   = transpose xss
07:04:00 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
07:04:10 <ejt> kpreid: good point
07:04:15 <SamB_XP_> the Maybe monad acts rather like that
07:05:37 <kpreid> ejt: why do you want to do this to MonadPlus?
07:05:48 <SamB_XP_> @index MonadZero
07:05:49 <lambdabot> bzzt
07:06:04 <SamB_XP_> @index MonadPlus
07:06:04 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:06:22 * SamB_XP_ forgot that there is no MonadZero class right now ;-)
07:06:33 <SamB_XP_> @doc Control.Monad
07:06:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
07:06:39 <kpreid> (mainly I'm wondering if it shouldn't perhaps be Monoid instead)
07:07:06 <SamB_XP_> kpreid: Monoid doesn't do that either, really
07:07:15 <kpreid> no, it doesn't
07:07:26 <kpreid> but Monoid is more general (though not defined for Maybe)
07:08:08 <CyberShadow> sorry for the lame question, but is this haskell code? if not, anyone knows what it is?
07:08:08 <CyberShadow> foldM = fix (\ aw f i -> (\ w -> ((\ ao cp ai aj am -> (ao cp aj) >>= (ai am)) >>= \ aa -> (\ cv ar as -> aw cv as ar) >>= \ z -> return (\ ag -> aa ag z)) f i (head w)) >>= \ be -> tail >>= \ bd -> return (be bd))
07:08:26 <yango> ?src num
07:08:27 <lambdabot> Source not found. I feel much better now.
07:08:34 <kpreid> CyberShadow: it is automatically mangled Haskell code
07:08:37 <ehird`> CyberShadow: hah!
07:08:42 <ehird`> yes it is ;)
07:08:45 <kpreid> specifically, run through pl and unpl, at least
07:09:02 * kpreid eyes ehird`
07:09:08 <CyberShadow> is it safe to run?
07:09:13 <kpreid> Sure.
07:09:17 <ehird`> haha wtf
07:09:45 <kpreid> @type fix (\ aw f i -> (\ w -> ((\ ao cp ai aj am -> (ao cp aj) >>= (ai am)) >>= \ aa -> (\ cv ar as -> aw cv as ar) >>= \ z -> return (\ ag -> aa ag z)) f i (head w)) >>= \ be -> tail >>= \ bd -> return (be bd))
07:09:51 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a -> a1 -> m a) -> a -> [a1] -> m b
07:10:07 <kpreid> CyberShadow: you can tell because its type does not refer to the IO monad and its source does not refer to unsafePerformIO.
07:10:09 <yango> this is insane
07:10:20 <TomMD> No, just different from what most people are used to
07:10:31 <yango> that's the definition of insanity
07:10:32 <yango> :)
07:10:56 <ehird`> CyberShadow: did you seriously go hunting around to solve the mystery of what language it was?
07:11:19 <CyberShadow> well I thought it looked like haskell at first
07:11:19 <yango> "I'm not insane, just different" he used to say while the guards cuffed him and locked him up in the sanitarium
07:11:38 <Cheery> @pl foldM = fix (\ aw f i -> (\ w -> ((\ ao cp ai aj am -> (ao cp aj) >>= (ai am)) >>= \ aa -> (\ cv ar as -> aw cv as ar) >>= \ z -> return (\ ag -> aa ag z)) f i (head w)) >>= \ be -> tail >>= \ bd -> return (be bd))
07:11:39 <SamB_XP_> @index Monoid
07:11:40 <lambdabot> foldM = fix (flip flip ((tail >>=) . (return .)) . ((flip . ((>>=) .)) .) . flip flip head . ((flip . ((.) .)) .) . (((flip . (((.) . (>>=)) .)) .) >>=) . (. ((return .) . flip)) . (>>=) . (flip .))
07:11:41 <CyberShadow> asked some friends but no one knew Haskell well enough, so I came here ;)
07:11:41 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
07:11:45 <ehird`> @src foldM
07:11:46 <lambdabot> foldM _ a []     = return a
07:11:46 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
07:11:48 <SamB_XP_> @doc Data.Monoid
07:11:48 <ehird`> CyberShadow: it's that warped.
07:11:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
07:12:11 <yango> @src >>=
07:12:12 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:12:16 <Cheery> @unpl foldM = fix (\ aw f i -> (\ w -> ((\ ao cp ai aj am -> (ao cp aj) >>= (ai am)) >>= \ aa -> (\ cv ar as -> aw cv as ar) >>= \ z -> return (\ ag -> aa ag z)) f i (head w)) >>= \ be -> tail >>= \ bd -> return (be bd))
07:12:16 <lambdabot> foldM = fix (\ aw f i -> (\ w -> ((\ ao cp ai aj am -> (ao cp aj) >>= (ai am)) >>= \ aa -> (\ cv ar as -> aw cv as ar) >>= \ z -> return (\ ag -> aa ag z)) f i (head w)) >>= \ be -> tail >>= \ bd ->
07:12:17 <lambdabot> return (be bd))
07:12:37 <ehird`> it went, iirc, @undo->@unpl->@pl->@unpl
07:12:37 <Cheery> @unpl foldM = fix (flip flip ((tail >>=) . (return .)) . ((flip . ((>>=) .)) .) . flip flip head . ((flip . ((.) .)) .) . (((flip . (((.) . (>>=)) .)) .) >>=) . (. ((return .) . flip)) . (>>=) . (flip .))
07:12:38 <lambdabot> foldM = fix (\ aw f k -> (\ y -> ((\ ai cy ac ad ag -> (ai cy ad) >>= (ac ag)) >>= \ de -> (\ dk ar as -> aw dk as ar) >>= \ dh -> return (\ an -> de an dh)) f k (head y)) >>= \ az -> tail >>= \ cj -
07:12:38 <lambdabot> > return (az cj))
07:12:59 <Cheery> ehird`: I've excepted something like it. :)
07:13:17 <yango> @pl map f (x:xs) = f x : xs
07:13:18 <lambdabot> map = (`ap` tail) . (. head) . ((:) .)
07:13:28 <yango> @unpl map = (`ap` tail) . (. head) . ((:) .)
07:13:29 <lambdabot> map f = (\ l -> ((:)) (f (head l))) >>= \ q -> tail >>= \ p -> return (q p)
07:13:37 <yango> @pl  map f = (\ l -> ((:)) (f (head l))) >>= \ q -> tail >>= \ p -> return (q p)
07:13:38 <lambdabot> map = ((tail >>=) . (return .) =<<) . ((:) .) . (. head)
07:13:39 <ehird`> if you want to make it more insane, you'll have to write a haskell compiler supporting inline asm ;)
07:14:04 <TomMD> ehird: Never say that again.
07:14:13 <ehird`> oh but i'm tempted
07:14:14 <ehird`> so very tempted
07:14:24 <Cheery> I'd love to make something insane like turn asm into something similar to haskell
07:14:27 <ehird`> then we might have a haskell implementation on the bare hardware :)
07:14:39 <Cheery> ie. readable and nice to manipulate
07:14:40 <TomMD> You will destroy all that is well and good in the world.
07:14:57 <ehird`> ASM monad? ;)
07:15:06 <TomMD> ehird: There are several Haskell on bare metal projects out there already.
07:15:06 <yango> is num a reserved word?
07:15:09 <ehird`> FudgeUpDirectMemoryMonad
07:15:21 <TomMD> "Num" is a class for "Numbers"
07:15:34 <yango> but num with lcfirst?
07:15:34 <TomMD> I don't know about 'num'
07:16:28 <TomMD> I am able to use 'num', such as:
07:16:28 <TomMD> > let num = head [4+3,5/0]
07:16:29 <lambdabot>  Parse error
07:16:37 <ehird`> o rly :p
07:16:38 <TomMD> err - I can use it anyway.
07:16:42 <ejt> kpreid: because I find I want to say do this or that a lot in do expressions.  eg, 'find in left branch of tree' or 'find in right branch of tree'
07:16:49 <Cheery> programming languages are like sex, each kind of them has their own place
07:16:58 <ejt> kpreid: where M is Maybe
07:17:09 <ehird`> Cheery: <cue java = anal sex joke>
07:17:18 <kpreid> ejt: so why not use mplus?
07:17:22 <kpreid> oh
07:17:28 <kpreid> hm
07:17:42 <kpreid> no, I still don't see why not to use mplus
07:17:46 <ejt> mplus is 'and'
07:17:51 <kpreid> no it isn't
07:18:00 <kpreid> what it is depends on the monad
07:18:00 <yango> got my mistake... what's the opposite of read (ie get back a string from an int)
07:18:07 <TomMD> mplus and mzero are mevil
07:18:08 <kpreid> for Maybe, you'll get only one result, necessarily
07:18:19 <ejt> @src mplus
07:18:20 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:18:22 <kpreid> >>= is "and"
07:18:25 <kpreid> @src Maybe mplus
07:18:26 <pejo> yango, show
07:18:26 <lambdabot> Nothing `mplus` ys  = ys
07:18:26 <lambdabot> xs      `mplus` _ys = xs
07:18:40 <DRMacIver> Isn't inline assembler in Haskell exactly what was being discussed yesterday? :) Harpy practically does that.
07:18:46 <ejt> ah, it appears what I want is mplus ;)
07:18:48 <ejt> thx
07:18:55 <Cheery> ehird`: yeah, and .net is like gay sex
07:21:08 * ehird` saw an x86 assembler in scheme
07:21:11 <ehird`> sexpr-asm...scary
07:22:13 <LoganCapaldo> scary?
07:22:20 <LoganCapaldo> I think you mean brilliant!
07:22:27 <DRMacIver> Scary brilliant?
07:22:39 <LoganCapaldo> why if asm was written in scheme, you could have asm macros!
07:22:47 <DRMacIver> Heh
07:22:51 <LoganCapaldo> this has opened up whole new possibilties
07:23:24 <Cheery> @unpl (flip . ($)) . (+2)
07:23:25 <lambdabot> (\ i b c -> (i + 2) c b)
07:23:50 <Baughn_> That.. does not look right
07:24:16 <DRMacIver> I forget which one it was, but there was some console game a while back that basically did that - it was written in a lisp dialect that had inline assembly for the console.
07:24:33 <LoganCapaldo> Jak and Daxter
07:24:39 <LoganCapaldo> PS2
07:24:43 <LoganCapaldo> GOAL
07:24:59 <Cheery> Baughn: yes, it'd say that Num (->) not defined
07:25:02 <LoganCapaldo> Game Oriented A(ssembly?) Lisp
07:25:07 <Baughn> PS1, wasn't it? Porting the toolkit to PS2 turned out to be too much of a problem, so they stopped using it
07:25:15 <LoganCapaldo> right right
07:25:20 <Baughn> Cheery: Well, you could always define it
07:25:39 <Cheery> > (\i b c -> (i + 2) c b)
07:25:41 <DRMacIver> LoganCapaldo: That's the one. :)
07:25:41 <lambdabot>        add an instance declaration for
07:25:41 <lambdabot>       (Typeable1 ((->) t),
07:25:41 <lambdabot>        Type...
07:26:36 <yango>  No instance for (Show (a -> a)) arising from use of `show' at threeeight.hs:11:37-40 In the result of a 'do' expression: putStrLn ("The product is " ++ (show rprod))
07:27:11 <DRMacIver> yango: That says "rprod is a function. I don't know how to show functions."
07:27:57 <yango> but I have let rprod = map (*) result
07:28:05 <ehird`> that's a function
07:28:11 <yango> holy cow
07:28:26 <ehird`> Hasmkell, anyone?
07:28:36 <yango> and how would I assign the result of that call to rprod?
07:28:46 <DRMacIver> Sorry, rprod is a list of functions even.
07:29:16 <DRMacIver> The error message is what it is because showing a list is defined in terms of showing the type of things it's a list of.
07:29:33 <DRMacIver> yango: what are you trying to do there, take the product of the list?
07:29:38 <ejt> yango: import Text.Show.Function
07:29:40 <DRMacIver> map doesn't do what you want in which case.
07:29:51 <LoganCapaldo> > product [2,3,5]
07:29:53 <lambdabot>  30
07:30:01 <LoganCapaldo> > map (*) [2,3,5]
07:30:03 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
07:30:16 <LoganCapaldo> > foldr (*) 1 [2,3,5]
07:30:17 <lambdabot>  30
07:30:22 <yango> foldr
07:30:23 <yango> yea
07:30:24 <yango> crap
07:30:25 <Baughn> Why isn't lambdabot's code there part of ghci already?
07:30:28 <psnl>  /win 22
07:30:32 <DRMacIver> @src product
07:30:33 <lambdabot> product = foldl (*) 1
07:30:51 <DRMacIver> Why is that foldl rather than foldl' ?
07:31:01 <yango> @src foldfl'
07:31:02 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:31:03 <yango> @src foldl'
07:31:04 <lambdabot> foldl' f a []     = a
07:31:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:31:07 <Baughn> foldl usually uses less memory, yes?
07:31:34 <takamura> hi
07:31:36 <DRMacIver> Huh?
07:31:36 <yango> lambdabot is that harsh to compensate for all the patient and nice guys here?
07:31:40 <DRMacIver> Hi takamura
07:32:04 <ejt> Baughn: depends on the strctness of 'f'
07:32:10 <Baughn> DRMacIver: foldl is tail-recursive, foldr is not.. or that's how it is in strict languages
07:32:22 <DRMacIver> Baughn: No, I asked why it used foldl rather than foldl'
07:32:29 <DRMacIver> Baughn: The latter is strict in its arguments.
07:32:58 <LoganCapaldo> DRMacIver: maybe you really do only want to evaluate the spine?
07:33:12 <ejt> it should be foldl' as far as I understand
07:33:14 <DRMacIver> LoganCapaldo: hm. I woudln't have thought so with *.
07:33:29 <LoganCapaldo> Maybe each element is a large computation? I dunno?
07:33:37 <DRMacIver> * is strict anyway though
07:33:59 <LoganCapaldo> it is?
07:34:03 <LoganCapaldo> I didn't know that
07:34:20 <DRMacIver> It pretty much has to be. :)
07:34:22 <kpreid> depends on your Num instance
07:34:24 <DRMacIver> True
07:34:56 <LoganCapaldo> Well you'll have to forgive me, I haven't gotten to that part in IFP yet :)
07:35:13 * DRMacIver will never forgive you!
07:35:18 * DRMacIver sears a blood vendetta against LoganCapaldo 
07:35:24 <DRMacIver> swears
07:35:29 <LoganCapaldo> I gtg
07:35:37 <LoganCapaldo> so you'll have to take your vengeance later
07:35:40 <LoganCapaldo> :)
07:35:42 <DRMacIver> ok. Take care. :)
07:35:58 <Baughn> DRMacIver: For a sufficiently long list, wouldn't foldl' have O(n) memory usage where foldl is O(1)?
07:36:16 <DRMacIver> The opposite I'd have thought.
07:36:16 <yango> can you put a non strict function in a map?
07:36:22 <DRMacIver> yango: Sure
07:36:41 <DRMacIver> yango: Except for the manner in which things are evaluated, the language makes no distinction between strict and non strict functions.
07:37:06 <DRMacIver> Baughn: Note that both foldl' and foldl are tail recursive.
07:39:05 * mux achieved mentioning memoization on arch@FreeBSD.org
07:39:07 * mux grins
07:41:02 <DRMacIver> hm?
07:41:48 <yango> I feel I'm close
07:42:16 <ehird`> since haskell is purely functional, shouldn't it be possible to memoize >every< function automatically?
07:43:02 <mux> any pure function
07:43:05 <DRMacIver> It should be possible. if you're not concerned with trivial things like insane space leaks.
07:43:11 <mux> DRMacIver: was that hm? directed to me? :)
07:43:15 <ehird`> DRMacIver: true :)
07:43:25 <DRMacIver> mux: Yes
07:43:27 <ehird`> mux: well, monad's solve the non-pure-function problem there don't they?
07:43:39 <DRMacIver> ehird`: In general the compiler does not memoize anything for you.
07:43:48 <ehird`> I was just asking if it would be possible/feasabl
07:43:49 <ehird`> e
07:43:49 <DRMacIver> The common claim that it can do so is a lie.
07:43:54 <yango> con you so something "perlish" like referring to the item of the list being processed in a map? (also declaring the function in the argument)? something like map (a $_ = $_ + 1) [1,2,3]
07:43:59 <mux> ehird`: that still doesn't mean you can memoize an action in the IO monad since it may not return the same thing each time
07:44:21 <DRMacIver> yango: You can use an anonymous function.
07:44:25 <mux> DRMacIver: why hm? then?
07:44:33 <DRMacIver> I was just curious as to what you meant. :)
07:44:39 <mux> ah
07:44:39 <ehird`> mux: i thought the IO monad returned is always the same, but only applies to that function call?
07:44:46 <DRMacIver> yango: So e.g. map (\x -> x + 1) [1, 2, 3]
07:44:50 <mux> well, there was someone wondering what was __attribute__((pure)) for in GCC
07:45:15 <mux> so I explained to him and mentioned that with purely functional languages you can get that for free
07:45:22 <DRMacIver> Ah.
07:45:22 <mux> for the sake of proselytism
07:45:30 <mux> I didn't mention haskell though
07:45:38 <DRMacIver> I wish you wouldn't do that. :)
07:45:46 <DRMacIver> Purely functional languages almost never memoize things for free.
07:45:52 <DRMacIver> It's just not a good idea.
07:45:56 <DRMacIver> As nice as it would be
07:46:05 <mux> but you can trick the compiler into doing it?
07:46:15 <DRMacIver> I'm not aware of a way to do so in Haskell.
07:46:15 <yango> DRMacIver: map (do putStrLn "value => "++show x) [1,2] ?
07:46:22 <ehird`> DRMacIver: I'm sure heuristics could make it work :)
07:46:33 <mux> I've heard of implementation for things in haskell that were qualified as using memoization
07:46:36 <ehird`> maybe memoize functions that don't have any monad?
07:46:47 <DRMacIver> ehird`: Monads are irrelevant here.
07:46:56 <DRMacIver> ehird`: The problem is that you need to maintain the memo table.
07:47:13 <DRMacIver> This is a huge space leak. Lazy evaluation makes space useage unpredictable enough as it is.
07:47:27 <ehird`> True.
07:47:34 <ehird`> Maybe based on usage?
07:47:38 <mux> you certainly can't keep track of everything you have to select what to memoize
07:47:53 <mux> some kind of LRU algorithm with heuristics
07:48:17 <DRMacIver> yango: I think you're confused. :)
07:48:38 <DRMacIver> mux: It's certainly possible. But it's not a trivial thing either, and I think there are bigger priorities at the moment.
07:48:57 <mux> well sure, that was meant to make some people interested in the functional area
07:49:08 <mux> yango: you want forM_
07:49:24 <yango> DRMacIver: sure I am
07:49:27 <ehird`> if somebody implemented it, haskell could get a lot faster :)
07:49:27 <mux> yango: which is just a reversed mapM_ (flip mapM_)
07:49:34 <DRMacIver> Yes, but "here's this really cool thing you can do with functional programming" is a bad way of motivating FP if no one does this really cool thing. :)
07:49:37 <yango> DRMacIver: I've been playing with this for a couple of hours
07:49:39 <yango> :P
07:49:46 <DRMacIver> yango: What are you trying to do here?
07:49:50 <mux> ehird`: the guys dealing with GHC really know where's it's best to work on :-)
07:49:52 <yango> iterate over a list
07:50:17 <Saizan> ?type map (\x -> putStrLn ("value => "++show x)) [1,2]
07:50:19 <lambdabot> [IO ()]
07:50:30 <mux> @type forM_ [1..3] $ \x -> putStrLn ("value => " ++ show x)
07:50:32 <lambdabot> IO ()
07:50:44 <yango> anyhow just finished it!
07:50:57 <yango> will paste it for you to laugh at and suggest improvements if you wish
07:51:14 <DRMacIver> Most people in here are nice enough not to laugh at you. :)
07:51:20 <DRMacIver> (I'm not though)
07:52:03 <Saizan> yango: putStrLn "value => " ++ show x is parsed as (putStrLn "value => ")++(show x) which is wrong, fyi
07:52:38 <Saizan> because function application has the highest precedence
07:52:45 <hpaste>  yango pasted "here it is" at http://hpaste.org/1815
07:54:36 <DRMacIver> yango: The thing to bear in mind here is that putStrLn is not a function which 'has the side effect of printing'. It's a function which returns an IO (). It's essentially something which returns a recipe which describes how you might print a line if you felt like it. In order to get the line to be printed you need to realise this IO () as part of main.
07:55:05 <ehird`> hmm, how do i get a function, instead of applying it?
07:55:15 <ehird`> map func list doesn't call func but passes it, so it has to be possible.
07:55:15 <DRMacIver> ehird`: How do you mean?
07:55:22 * ehird` is newbie :)
07:55:35 <DRMacIver> ehird`: You can just refer to the function by its name.
07:55:49 <ehird`> if i just have the function name by itself, it calls it
07:56:01 <DRMacIver> No it doesn't.
07:56:07 <ehird`> hm.
07:56:23 <DRMacIver> The juxtaposition foo bar calls foo on bar.
07:56:26 <ehird`> i think i'm being confused by variables/functions having the same syntax :)
07:56:35 <kpreid> they don't!
07:56:45 <yango> DRMacIver: I don't get the "IO() as part of main" thing
07:56:45 <kpreid> in C, you write f(x), but you can also write f
07:56:58 <ehird`> x = y evals y right then, but x <...> = y evals y later, right?
07:57:02 <ehird`> ignoring lazy-eval stuff
07:57:04 <DRMacIver> yango: Basically you can build up IO values in terms of other IOs.
07:57:07 <kpreid> the same goes for Haskell, but without the parentheses
07:57:24 <kpreid> ehird`: it's not possible to speak of time of evaluation ignoring laziness
07:57:30 <ehird`> however, i seem to be wrong, because
07:57:34 <ehird`> a = putStrLn "hello"
07:57:34 <ehird`> a
07:57:34 <yango> DRMacIver: I think I'm missing a chapter... what is "an IO" a monad?
07:57:36 <DRMacIver> yango: 'main' is the IO that is being evaluated by the runtime. The rules for evaluating it may cause the runtime to evaluate other IO objects and act accordingly based on their result.
07:57:37 <ehird`> seems to "call" a
07:57:37 <hpaste>  Saizan annotated "here it is" with "using more of Prelude" at http://hpaste.org/1815#a1
07:57:56 <kpreid> ehird`: nor is it *meaningful* to speak of time of evaluation wrt call vs. mention
07:58:09 <kpreid> ehird`: the only question is whether you are applying a function or not
07:58:12 <ehird`> so how would i get the "value" of a then? or is lazy evaluation picking up the monad when i get the value of the var a, deluding me into thinking it's a function?
07:58:19 <ehird`> basically:
07:58:21 <kpreid> a is an IO action, not a function
07:58:25 <ehird`> let a = putStrLn "hello" in a
07:58:26 <DRMacIver> yango: "IO a" is a type. It happens to be a monad, but you can think of it as the type of an input/output operation which returns an a
07:58:33 <ehird`> is a the IO monad, or a function returning an IO monad
07:58:40 <kpreid> ehird`: that's precisely equivalent to just 'putStrLn Hello'
07:58:42 <kpreid> er
07:58:46 <kpreid> putStrLn "hello"
07:58:54 <ehird`> ^
07:58:56 <kpreid> @type let a = putStrLn "hello" in a
07:59:01 <DRMacIver> yango: So if we had main = putStrln "Hello world" then when main is evaluated the runtime will see that it needs to write the line "hello world"
07:59:02 <lambdabot> IO ()
07:59:03 <kpreid> @type putStrLn "hello"
07:59:05 <lambdabot> IO ()
07:59:13 <ehird`> OK. So a is a binding, not a function
07:59:16 <kpreid> they are both IO actions; values in the IO monad
07:59:30 <kpreid> er, those are incomparable things
07:59:33 <ehird`> It's just because the monad isn't "noticed" until I use a - because of lazy evaluation - that it seems like a function
07:59:34 <ehird`> Right?
07:59:40 <kpreid> no
07:59:45 <kpreid> lazy evaluation is not involved here
08:00:12 <ehird`>  a = putStrLn "hello" <-- Is a immediately assigned the IO action, or does lazy evaluation delay it?
08:00:12 <Saizan> ehird`: your a is of type IO (), you can pass it around as any other value, like a list or a tuple, only when it is connected to your main it's executed
08:00:12 <ehird`> That's my question.
08:00:28 <kpreid> ehird`: doesn't matter!
08:00:41 <DRMacIver> yango: The idea is that what happens is that the runtime evaluates the main IO value and performs actions based on what it finds.
08:00:44 <kpreid> ehird`: *evaluation* has nothing to do with the timing of execution of actions
08:00:53 <ehird`> doesn't matter, yes, but i'm curious :)
08:01:15 <DRMacIver> yango: And because of the lazy evaluation strategy it only evaluates the parts of the IO it needs to perform these actions.
08:01:47 <DRMacIver> I have a suspicion that Haskell IO makes a lot more sense if you try to write it without do notation for a while.
08:02:07 <kpreid> ehird`: well, putStrLn "hello" is usually evaluated immediately before it is executed
08:02:12 <Saizan> and you know something about monads :)
08:02:14 <kpreid> because that's when exactly which IO action it is matters; before then, it's just a thunk
08:02:16 <DRMacIver> I've not tried this though. :)
08:02:30 <kpreid> but that is all implementation details.
08:02:49 <andygill> The way I think of IO is you are building a datastructure, called IO, purely functionally, and the runtime system interprets IO
08:02:57 <Botje> > getContents >>= liftM lines
08:02:58 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
08:03:07 <Baughn> @src foldl'
08:03:08 <lambdabot> foldl' f a []     = a
08:03:08 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:03:37 <yango> Saizan: why mapM_ instead of map?
08:03:52 <ehird`> andygill: I can use that to prove that haskell is not pure - ghc is mostly written in haskell, ghc has a runtime system to interpret the IOs, therefore if haskell can do that it is not pure :)
08:03:56 <ehird`> shaky logic, sure, but :D
08:04:20 <kpreid> ehird`: ghc's runtime system could be written using IO!
08:04:30 <Baughn> DRMacIver: Oh, that's not the same strictness I was looking for. I see - then is there any point in having foldl as well as foldl'?
08:04:36 * kpreid ignores the infinite regression
08:04:37 <ehird`> kpreid: TOO MUCH RECURSION - stack overflow
08:04:47 <ehird`> Fix: Stop being functional, ya hippy
08:04:52 <andygill> Not true. The IO 'datastructure" (only a conceptual model) is the functional result.
08:05:24 <Saizan> yango: because map :: (a -> b) -> [a] -> [b], so because your function is of type (Integer -> IO ()) you get a [IO ()] with map, but you need something of type IO a
08:05:29 <Saizan> ?type mapM_
08:05:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:05:41 <hpaste>  koeien pasted "can somebody explain this?" at http://hpaste.org/1816
08:06:05 <Saizan> yango: you could have used map and than pass that list to sequence
08:06:11 <ehird`> i have to look at ghc internals sometime
08:06:11 <Saizan> ?type Prelude.sequence
08:06:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:06:16 <kpreid> data IO a = PutStr s (() -> a) | GetLine (String -> a) | ...
08:06:16 <ehird`> i have a feeling i'll be horrified
08:06:22 <yango> okay, will read the monad chapter before asking further questions :D
08:06:39 <kpreid> IO is essentially that
08:06:45 <kpreid> plus the runtime system interpreting it
08:06:48 <andygill> Thats the idea, kpreid
08:07:07 <kpreid> er
08:07:13 <kpreid> data IO a = PutStr s (() -> IO a) | GetLine (String -> IO a) | ...
08:07:25 <ehird`> yes, but here is my logic:
08:07:34 <ehird`> - GHC, for all intents and purposes, is 99% Haskell
08:07:48 <ehird`> - GHC's runtime system - which is needed to make IO "do it" - is also written in Haskell
08:07:54 <andygill> There is also a paper in last years ICFP about skeletons for monads
08:08:00 <ehird`> - GHC can do a non-pure IO operation, therefore, when applying IO monads
08:08:06 <ehird`> - So, Haskell is not 100% pure
08:08:11 <Saizan> koeien: when you define a value without parameters like your "f" ghci infer a monomorphic type defaulting to Int
08:08:16 <Baughn> ehird`: - The IO primitives are /not/ written in haskell
08:08:26 <ehird`> Baughn: Oh. I thought they were
08:08:29 <yango> ehird`: a 100% pure functional language would be useless
08:08:31 <koeien> okay, so if I would say "f x  = ..." then it would work?
08:08:41 <ehird`> yango: no - I'm wrong, Haskell IS 100% functional
08:08:51 <Baughn> ehird`: Well, some of them might be written in haskell using the FFI, but there are quite a few .c files in there
08:08:52 <Botje> that or give the type of f explicitly
08:08:53 <Saizan> koeien: yes
08:08:54 <ehird`> the runtime system just isn't :) i just thought it was written in Haskell but it's not
08:08:58 <koeien> ah, yes, that works
08:08:59 <koeien> thanks!
08:09:29 <Baughn> ehird`: A lot of the runtime system is written in IO. More may (I haven't checked) be written in a non-haskell language suspiciously similar to haskell.
08:09:30 <Saizan> koeien: this is called monomorphic restriction, btw
08:09:59 <ehird`> Baughn: OK. So basically there's a C core doing the base evil application of IO
08:10:04 <ehird`> and then the rest of the runtime system piggybacks that
08:10:32 <koeien> i'm going to look it up on the internet now
08:10:39 <Baughn> ehird`: Yes. It's also possible to take the approach of using compiler primitives, but given that GHC is easily portable, I don't think it does that.
08:10:54 <Baughn> ehird`: This isn't so much "how to implement haskell" as "how to implement high-level languages", though
08:11:09 <ehird`> Baughn: Most highlevel languages aren't monadic ;P
08:11:24 <Baughn> ehird`: Sure, but the monads are a simple concept
08:11:35 <DRMacIver> yango: Here's what I think is an illustrative example of how IO works: main = getArgs >>= sequence_ . (map putStrLn)
08:11:42 <ehird`> i've always liked languages implemented in themselves
08:11:47 <Baughn> ehird`: It would be easy enough to compile Haskell to Scheme, for example
08:12:14 <ehird`> once I pondered trying language spec-->write compiler in itself-->write compiler in C, use to compile self-written compiler->fix the inevitable millions of errors
08:12:21 <ehird`> the last bit was the stopper
08:12:40 <DRMacIver> yango: Try and unpick that and I think you'll be a lot closer to figuring out how things are put together. :)
08:13:14 <DRMacIver> ehird`: I believe Lisp was originally written in an even more hardcore manner - language spec --> write compiler in itself --> hand compile said compiler to assembly --> win
08:13:28 <ehird`> DRMacIver: Well, Lisp wasn't intended to be implemented
08:13:39 <pitecus> Any idea why length, Map.size, Set.size etc return an Int instead of a (Num a)???
08:13:45 <Baughn> DRMacIver: Also, that spec was /simple/
08:13:47 <pitecus> Its really annoying
08:13:54 <ehird`> It was just a lambda-calculus style theoretical "hey look, with a few basic definitions, we can write an 'eval' function for this, and it's turing complete, isn't that cool"
08:13:56 <Botje> pitecus: there's genericLength
08:14:01 <DRMacIver> Baughn: True. :) But it's not the only language which has been done this way.
08:14:04 <TomMD> pitecus: Int is faster than a general Integral.
08:14:06 <ehird`> then a smartass thought "HAY LETZ REWRITE EVAL IN ASM"
08:14:30 <DRMacIver> Back in the days when the computer was new and assembly roamed wild upon the plains, this was normal.
08:14:46 <TomMD> pitecus: but genericLength exists for your enjoyment.  I agree with you though that the core functions should make different types smoother to use.
08:14:49 <Baughn> DRMacIver: Common at the time, true. C was done that way too..
08:14:50 <DRMacIver> Or at least not unheard of
08:14:53 <TomMD> @type genericLength
08:15:02 <lambdabot> forall b i. (Num i) => [b] -> i
08:15:10 <pitecus> TomMD, doesnt sound like a good justification. If i want fast I won't be able to use Haskell anyway probably...
08:15:32 <Cheery> I made my window handling code act a bit more functional
08:15:42 <ehird`> Cheery: eh?
08:15:59 * ehird` wonders what haskell compiler was used to compile ghc
08:16:04 <MyCatVerbs> ehird`: I thought the actual story was more like, McCarthy writes paper on eval function for use as a part of some other programming language, a colleague looks over his shoulder and goes, "Hey yuoes that's a full programming language already, lets implement it."?
08:16:13 <ehird`> MyCatVerbs: Nope.
08:16:24 <Baughn> ehird`: Actually, it can be bootstrapped /without/ a haskell compiler
08:16:26 <Baughn> Or so I hear
08:16:33 <Cheery> ehird`: just a minor modification to what I had already
08:16:39 <ehird`> Cheery: what what?
08:17:12 <Cheery> I put it to release the window context when it has gotten out of reach
08:17:13 <yango> DRMacIver: where's getArgs?
08:17:18 <Botje> ehird`: probably miranda?
08:17:22 <ehird`> A one act play: MCCARTHY: "HAY LOOK, I DEFINED A TURING COMPLETE THEORETICAL STUFFS WITH SOMETHING THAT HAS ITSELF IN ITSELF. ISN'T THAT INTERESTING." SMARTASS: "HAY LOOK. I TRANSLATED IT TO ASM. NOW YUO AER INVENTOR OF PROGRAM LANGUAGE! HA HA HA!" MCCARTHY: "O NO-"
08:17:27 <ehird`> Cheery: what what what what?
08:17:32 <ehird`> Cheery: which window what what?
08:17:39 <ehird`> Cheery: what which window what which which what what what?
08:17:43 <yango> ehird`: you better stick to programming
08:17:57 <DRMacIver> yango: Sorry, it's in System
08:18:02 <Cheery> thus modified stuff related to that window -stuff so that you need the window context before you can use window-related IO
08:18:09 <ehird`> [16:17] ehird`: @pl what which window what which which what what what
08:18:10 <ehird`> [16:17] lambdabot: what which window what which which what what what
08:18:15 <ehird`> Cheery: WINDOW WHAT?>
08:19:03 <Cheery> @unpl what which window what which which what what
08:19:04 <lambdabot> what which window what which which what what
08:19:06 <DRMacIver> Baughn, ehird`: I think there's a core very simple Haskell compiler written in C that's bundled with GHC for bootstrapping.
08:19:29 <ehird`> @pl (\what which window -> what which window what which which what what)
08:19:30 <lambdabot> flip =<< (flip .) . (flip =<< (flip .) . join . (flip .) . join . (flip .) . (flip =<< (flip .)))
08:19:34 <ehird`> hah!
08:19:47 <Baughn> DRMacIver: Interpreter, perhaps?
08:19:47 <ehird`> @unpl flip =<< (flip .) . (flip =<< (flip .) . join . (flip .) . join . (flip .) . (flip =<< (flip .)))
08:19:48 <lambdabot> (\ af -> ((\ g bf e f -> g bf f e) >>= \ a b c -> a c b) (((\ n bl l m -> n bl m l) >>= \ h i j -> h j i) ((\ bo p q -> ((\ br t u -> ((\ ac bx aa ab -> ac bx ab aa) >>= \ w x y -> w y x) af br u t)
08:19:48 <lambdabot> >>= \ av -> av) bo q p) >>= \ am -> am)))
08:19:51 <psnl> DRMacIver: you compile ghc to c on another box to bootstrap
08:19:55 <Cheery> :DD
08:19:59 <DRMacIver> psnl: Ah
08:20:21 <ehird`> @pl (\what which window -> what (which window) (what which) (which what what))
08:20:22 <lambdabot> ap (ap . (flip .) . (ap =<< (flip .) . (.))) (flip =<< flip id)
08:20:22 <Cheery> there gone the only clarity we had
08:20:30 <Cheery> so now, the window does not disapper before the next garbage collection
08:20:36 <psnl> DRMacIver: however, initially ghc was bootstrapped with a perl script, I think
08:20:46 <DRMacIver> ...
08:20:46 <ehird`> psnl: Hah!
08:20:54 <ehird`> Cheery: WHAT WINDOW?
08:20:58 <ehird`> WHAT ARE YOU TALKING ABOUT
08:21:02 <ehird`> :P
08:21:10 <quicksilver> presumably ghc was bootstrapped in gofer
08:21:13 <quicksilver> and/or miranda
08:21:29 <Cheery> ABOUT MY COOL GAME INITIALISATION CODE
08:21:52 <Cheery> is today all-caps -day nobody obeys or something?
08:22:02 <DRMacIver> Miranda actually seems to have a lot less to do with Haskell than I'd previously thought.
08:22:10 <Apocalisp> @arr
08:22:11 <lambdabot> Keelhaul the swabs!
08:22:17 <Cheery> @garr
08:22:17 <lambdabot> Maybe you meant: arr yarr
08:22:22 <Cheery> @yarr
08:22:23 <lambdabot> Shiver me timbers!
08:22:25 <DRMacIver> What I think of as the really big features of Haskell (monads and type classes) aren't from Miranda at all.
08:22:48 <Pseudonym> The big features from Miranda are laziness with a ML-like type system.
08:22:52 <DRMacIver> Yeah
08:22:56 <Pseudonym> Nobody did that before.
08:23:04 <augustss> nonsense
08:23:21 <Pseudonym> Hmm?
08:23:27 <DRMacIver> There were a bunch of lazy pure languages about at the time. That was the whole idea behind Haskell.
08:23:30 <augustss> LML had laziness with an ML type system in about 1983
08:23:36 <DRMacIver> I don't know how many of them had ML like type sytsems.
08:24:33 <DRMacIver> (As I understand it Haskell was basically designed as a solution to the problem of there being a huge number of lazy pure functional languages with no one being able to agree on what to use)
08:24:54 <Pseudonym> Now that I think about it, KRC might have had a ML-like type system.
08:24:56 <augustss> that's right
08:24:56 <yango> and has it changed?
08:24:58 <Pseudonym> Before my time.
08:24:59 <Cheery> so haskell is a sort of unification of past?
08:25:21 <Pseudonym> Everyone wrote their own Miranda-alike because Miranda was not only not open, but copyrighted.
08:25:24 <DRMacIver> The type classes are a Haskell invention, and I think it was the first language to use monads for structuring IO and side effects.
08:25:35 <Pseudonym> Haskell was a consolidation of those Miranda-alikes.
08:25:38 <DRMacIver> (Although that arose independently)
08:25:42 <augustss> yes, on both of those
08:25:53 <MyCatVerbs> Pseudonym: and, it seems, a superset of all of them?
08:25:58 <augustss> but monds were not in the original haskell design
08:26:03 <Pseudonym> MyCatVerbs: Not quite.
08:26:27 <Pseudonym> Some of them had some very odd features which are better removed.
08:26:37 <Pseudonym> I remember an oddity from Orwell.
08:26:56 <Botje> monads are all part of an elaborate scheme to support SPJ in his quest for world domination
08:26:56 <Pseudonym> Take a definition like:
08:26:58 <Pseudonym> merge [] ys = ys
08:27:01 <Pseudonym> merge xs [] = xs
08:27:07 <Pseudonym> merge (x:xs) (y:ys) = ...
08:27:22 <Pseudonym> Orwell wouldn't accept that becxause the first two patterns overlapped.
08:27:30 <DRMacIver> Ew
08:27:33 <Pseudonym> You had to write:
08:27:36 <Pseudonym> merge [] ys = ys
08:27:37 <Pseudonym> %else
08:27:43 <Pseudonym> merge xs [] = xs
08:27:45 <Pseudonym> merge (x:xs) (y:ys) = ...
08:27:52 <Pseudonym> I may have some of the syntax wrong.
08:27:57 <Pseudonym> But that's the general idea.
08:28:01 <augustss> Yes, one of Phil Wadler's pet peeves :)
08:28:01 <dmhouse> The patterns don't overlap though...
08:28:53 <DRMacIver> dmhouse: Sure they do. Both match [] []
08:29:05 <Pseudonym> You mean it wasn't Wadler who designed that oddity?
08:29:06 <dmhouse> Oh, right.
08:29:39 <augustss> Pseudonym: no, I mean that Phil doesn't like overlapping patterns
08:29:43 <Pseudonym> Ah, right.
08:29:54 <Pseudonym> Gofer did post-date the first Haskell report.
08:30:02 <Pseudonym> So it doesn't count as one of the Miranda-alikes.
08:30:35 <Pseudonym> But it was the forerunner of the modern "Haskell is a testbed for advanced type hackery" philosophy.
08:31:00 <davidL> is there a better way to concatenate a whole list together than foldl1' (++) ?
08:31:02 <hpaste>  ejt annotated "here it is" with "tidied a bit" at http://hpaste.org/1815#a2
08:31:11 <ejt> yango: ^^
08:31:15 <DRMacIver> dmhouse: concat ?
08:31:15 <dmhouse> davidL: use concat?
08:31:19 <DRMacIver> ops
08:31:24 <dmhouse> DRMacIver: suggestion through proxy?
08:31:26 <DRMacIver> Heh
08:31:31 <Pseudonym> davidL: foldl1' (++) isn't a good way.
08:31:31 <davidL> @type concat
08:31:31 <DRMacIver> No, I just fail at tab complete.
08:31:34 <lambdabot> forall a. [[a]] -> [a]
08:31:38 <DRMacIver> @src concat
08:31:38 <lambdabot> concat = foldr (++) []
08:31:56 <davidL> so it is the same =\
08:32:08 <DRMacIver> davidL: No, because foldr is lazy.
08:32:14 <augustss> no, it's better
08:32:15 <Pseudonym> RIght.
08:32:16 <davidL> foldl is not?
08:32:38 <DRMacIver> Well, it is lazy. But it messes up the evaluation strategy here.
08:32:49 <DRMacIver> Because you need to evaluate the whole thing in order to get at the head of the list.
08:32:51 <Pseudonym> foldr does the right thing on infinite lists, too.
08:33:00 <dmhouse> > foldl' (++) [] (repeat [1])
08:33:02 <Pseudonym> > foldr (++) [] (map return [1..])
08:33:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:33:08 <lambdabot> Terminated
08:33:12 <dmhouse> > foldlr (++) [] (repeat [1])
08:33:13 <lambdabot>   Not in scope: `foldlr'
08:33:17 <Pseudonym> > foldr (++) [] (map return [1..])
08:33:17 <dmhouse> > foldr (++) [] (repeat [1])
08:33:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:33:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:33:25 <Pseudonym> > foldl (++) [] (map return [1..])
08:33:32 <lambdabot> Terminated
08:33:34 <Pseudonym> Right.
08:33:48 <Pseudonym> And even if you don't have an infinite list, it still uses more transient storage.
08:33:50 <davidL> thanks, hadn't known that
08:33:51 <Pseudonym> In general.
08:34:05 <Pseudonym> To be a problem, it doesn't have to be infinite, merely big enough,.
08:34:52 <Saizan> also (++) is more efficient with left sections rather than right ones
08:35:13 <ejt> davidL: http://www.haskell.org/haskellwiki/Stack_overflow
08:35:14 <lambdabot> Title: Stack overflow - HaskellWiki
08:37:01 <MyCatVerbs> > foldr (++) [] (cycle "b0rk! ")
08:37:02 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
08:37:28 <MyCatVerbs> :t foldr
08:37:30 <DRMacIver> Do you mean repeat?
08:37:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:37:37 <dmhouse> > foldr (++) [] (repeat "b0rk!" )
08:37:39 <lambdabot>  "b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!b0rk!...
08:37:52 <MyCatVerbs> DRMacIver: ah, danke.
08:38:00 <MyCatVerbs> > foldr (++) [] (cycle ["b0rk! "])
08:38:01 <lambdabot>  "b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0r...
08:38:06 <DRMacIver> Or that. :)
08:38:20 <Saizan> ?tyep cycle
08:38:20 <MyCatVerbs> lambdasweden! ^_^
08:38:20 <lambdabot> Maybe you meant: temp type
08:38:22 <DRMacIver> Or:
08:38:30 <Saizan> ?type cycle
08:38:33 <DRMacIver> > foldr (:) [] (cycle "b0rk! ")
08:38:33 <lambdabot> forall a. [a] -> [a]
08:38:34 <lambdabot>  "b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0r...
08:38:35 <dmhouse> cycle xs = foldr (++) [] (repeat xs)
08:38:50 <MyCatVerbs> DRMacIver: yes, that's more like it.
08:38:56 <dmhouse> Or cycle xs = xs ++ cycle xs, the more normal definition.
08:39:37 <Saizan> foldr (:) [] == id :: [a] -> [a]  :D
08:39:59 <DRMacIver> Oh, hold on. That's a highly silly think to do. :)
08:40:01 <dmhouse> Catamorphisms!
08:40:06 <DRMacIver> > cycle "b0rk! "
08:40:08 <lambdabot>  "b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0rk! b0r...
08:40:22 <ejt> cycle = concat . repeat
08:40:27 <DRMacIver> foldr (:) [] being equal to id on list...
08:41:26 <DRMacIver> @unpl foldr (:) []
08:41:27 <lambdabot> foldr (:) []
08:41:32 <DRMacIver> How disappointing.
08:41:42 <dmhouse> ?unpl \x -> foldr (:) []
08:41:43 <lambdabot> \ x -> foldr (:) []
08:41:52 <dmhouse> ?unpl \x -> foldr (:) [] x -- :)
08:41:52 <lambdabot> \ x -> foldr (:) [] x
08:41:58 <dmhouse> Oh, oops.
08:42:02 <dmhouse> ?pl \x -> foldr (:) [] x -- :)
08:42:03 <lambdabot> foldr (:) []
08:42:06 <MyCatVerbs> Hrmn. Lisp <-> Haskell terminology mappings...
08:42:17 <DRMacIver> I guess @unpl only removes . ?
08:42:31 <DRMacIver> @unpl fix (1:)
08:42:32 <lambdabot> fix (\ a -> 1 : a)
08:42:36 <MyCatVerbs> car/cdr = head/tail, map is the same either way, folds are reduces and vice versa.
08:42:42 <DRMacIver> And sections apparently.
08:42:42 <MyCatVerbs> What the heck is mapcar, though?
08:42:50 <dmhouse> MyCatVerbs: map.
08:43:00 <MyCatVerbs> dmhouse: huh? That all?
08:43:08 <dmhouse> Depends which Lisp you're using.
08:43:25 <dmhouse> In Emacs Lisp (which I've written the most of), mapcar = map, mapc = mapM_.
08:43:36 <dmhouse> Lisp lists are different from Haskell lists, though.
08:43:52 <MyCatVerbs> Not by much.
08:43:56 <dmhouse> (1 2 3) in Lisp is basically the same as (1, (2, (3, []))) in Haskell.
08:44:11 <ejt> ?!
08:44:12 <lambdabot> Maybe you meant: . v
08:44:16 <DRMacIver> MyCatVerbs: Sure they are. Lisp lists are heterogenous.
08:44:36 <MyCatVerbs> DRMacIver: oh, aye.
08:44:52 <MyCatVerbs> So anyway. Scheme's map is the same as Haskell's, I take it?
08:44:55 <dmhouse> Hrm, discount what I said, it's true, but not interesting.
08:45:22 <dmhouse> (As (,) -- the constructor -- is isomorphic to (:) apart from types, so types are the interesting bit, as DRMacIver already pointed out.)
08:45:42 <DRMacIver> dmhouse: Well, you could make it interesting by basically upgrading LispList to a type class with constructors which are types in their own right. :)
08:46:15 <dmhouse> MyCatVerbs: sounds right. Scheme always had sensible names.
08:47:09 <kpreid> DRMacIver: unpl removes sections and a specific set of combinators: http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/Pointful.hs
08:47:25 <kpreid> (look at the definition of 'combinatorModule')
08:47:51 <DRMacIver> kpreid: Thanks
08:48:12 <kpreid> DRMacIver: I made that set mostly by looking at what combinators @pl uses
08:48:22 <kpreid> and taking out the ones that aren't correct in the presence of type inference
08:48:28 <kpreid> (reader monad, etc)
08:48:29 <MyCatVerbs> dmhouse: as far as I can tell "sensible names" is one third of Scheme's raison d'etre. The other two thirds being sane block scoping and getting rid of CL's occasional distinction between lambdas and data.
08:48:44 <dmhouse> MyCatVerbs: and to be really simple.
08:49:02 <MyCatVerbs> dmhouse: well yes, but that's a happy side effect, kinda.
08:49:25 <dmhouse> I _love_ the idea of Scheme. Really. I want to use it a lot more. But there are 20 different competing Scheme compilers, and it's impossible to write any kind of practical Scheme whatsoever without resorting to compiler-specific extensions.
08:49:42 <dmhouse> I.e. nearly all Scheme code is non-portable.
08:49:55 <Saizan> write you own compiler!
08:50:04 <matthew-_> in scheme!
08:50:06 <dmhouse> SRFIs are attempting to fix that, and doing a good job. But guess what? There's no compiler-independant way to say "Use SRFI number n". :|
08:50:28 <DRMacIver> I keep meaning to play with Scheme more than I currently do, but I don't have the mental energy to keep up with learning both Scheme and Haskell. :)
08:50:41 <DRMacIver> (And Haskell maps better onto my way of thinking)
08:50:47 <dmhouse> DRMacIver: ah, once you have Haskell nailed Scheme will be no problem at all.
08:50:48 <Saizan> in haskell, but running it on an interpreter written in scheme that compiles to .NET
08:51:01 <dmhouse> DRMacIver: it'll feel like Haskell with side effects and less expressive.
08:51:02 <ehird`> > let { fold f s [] = s; fold f s (x:xs) = fold f (f x) xs } in fold (+) 0 [1..3]
08:51:03 <lambdabot>   add an instance declaration for (Num (t -> t))
08:51:14 <DRMacIver> dmhouse: well, I've no conceptual problem with scheme.
08:51:25 <DRMacIver> dmhouse: What I need is time spent writing it. :)
08:51:34 <dmhouse> Same here, to be honest.
08:52:08 <augustss> scheme has call/cc which takes some practice to use
08:52:17 <DRMacIver> I don't know how to use Scheme macros or CPS, but otherwise I could probably write things in Scheme given a bit of head scratching. It's not like it's got a complicated syntax. ;)
08:52:18 <ehird`> call/cc = warped goto
08:52:36 <Saizan> ehird`: fold f s (x:xs) = fold f (f s x) xs
08:52:39 <dmhouse> CPS is fun to try to get your head around.
08:52:47 <DRMacIver> augustss: Yeah, continuations are high on my list of things I need to get my head around in general.
08:52:52 * dmhouse wrote the Wikibook chapter on continuations. It's not very good.
08:52:55 <ehird`> Saizan: ahhhh duh
08:53:00 <dmhouse> Actually, continuations are pretty easy. Cont isn't.
08:53:42 <ehird`> ok, now somebody tell me why
08:53:43 <ehird`> fold f s [] = s
08:53:43 <ehird`> fold f s (x:xs) = fold f (f s x) xs
08:53:43 <ehird`> isn't in prelude, because it's tail recursive and doesn't look horrific (unlike foldl')
08:53:54 <Saizan> is there a scheme with an haskellish syntax?
08:54:04 <ehird`> Saizan: that would defeat the point
08:54:05 <dmhouse> ?google liskell
08:54:06 <DRMacIver> Saizan: No, but there's a Haskell with schemeish syntax. ;)
08:54:08 <lambdabot> http://clemens.endorphin.org/liskell
08:54:08 <lambdabot> Title: Liskell - clemens.endorphin.org
08:54:10 <Saizan> ehird`: that's foldl
08:54:16 <ehird`> Saizan: it is?
08:54:22 <Saizan> ?src foldl
08:54:23 <dmhouse> ehird`: not foldl', but foldl.
08:54:23 <lambdabot> foldl f z xs = lgo z xs
08:54:23 <lambdabot>     where lgo z []     =  z
08:54:23 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
08:54:24 <ehird`> oh shi-, it's stack-overflowing
08:54:34 <DRMacIver> Saizan: dylan is probably the closest, but it's fairly deceased.
08:54:34 * ehird` wonders why - it's tail recursive
08:54:52 <dmhouse> ehird`: use foldl' and it won't.
08:54:58 <dmhouse> ehird`: foldl' is the strict version.
08:54:59 <ehird`> I was just wondering
08:55:10 <matthew-_> ehird`: it's foldl because you're applying the function to the head of the list immediately - hence all the brackets are on the left, thus foldl
08:55:11 <dmhouse> (I.e., the one that can take advantage of it being tail-recursive.)
08:55:26 <Saizan> ehird`: because you are constructing a huge thunk: ((..(0 + 1) + 2) + 3) + ....
08:55:36 <ehird`> Saizan: true
08:55:44 <dmhouse> > foldl (+) 0 [1.100000]
08:55:46 <lambdabot>  1.1
08:55:58 <dmhouse> > foldl (+) 0 [1..100000] -- that was confusing for a moment!
08:56:00 <lambdabot>  5000050000
08:56:00 <ehird`> > foldl (+) 0 [1..1000000]
08:56:03 <lambdabot>  500000500000
08:56:05 <ehird`> wtf
08:56:07 <ehird`> > foldl (+) 0 [1..1000000000000]
08:56:13 <lambdabot> Terminated
09:01:49 <davidL> let (a:as) $+ (b:bs) = (a+b) : (as $+ bs); as $+ [] = as; [] $+ bs = bs; nextPascal xs = xs $+ (0:xs); pascalTriangle = iterate nextPascal [1] in take 10 pascalTriangle
09:01:53 <davidL> > let (a:as) $+ (b:bs) = (a+b) : (as $+ bs); as $+ [] = as; [] $+ bs = bs; nextPascal xs = xs $+ (0:xs); pascalTriangle = iterate nextPascal [1] in take 10 pascalTriangle
09:01:55 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
09:02:35 <davidL> > let (a:as) $+ (b:bs) = (a+b) : (as $+ bs); as $+ [] = as; [] $+ bs = bs; nextPascal xs = xs $+ (0:xs); pascalTriangle = iterate nextPascal [1] in pascalTriangle !! 1000
09:02:37 <lambdabot>  [1,1000,499500,166167000,41417124750,8250291250200,1368173298991500,19428060...
09:02:48 <DRMacIver> Hm. Bored now, and the weather's too crap to go outside. :)
09:03:20 <Saizan> ?type ($+)
09:03:22 <lambdabot> Not in scope: `$+'
09:04:03 <DRMacIver> augustss: So, what should I frantically be trying to brush up on to impress you with on monday? ;)
09:04:08 <DRMacIver> (kidding, kidding)
09:25:13 <TomMD> DRMaclver: you are interviewing?
09:25:53 <DRMacIver> I will be being interviewed.
09:26:46 <TomMD> Good luck - you have to come back to IRC and let us know how it goes.
09:26:58 <DRMacIver> Heh.
09:27:04 <DRMacIver> Given the context I suspect that would be dangerous. ;)
09:39:30 <Uz> 18:24 < DRMacIver> Heh.
09:39:31 <beelsebob> @dice 3d6 + 1d10
09:39:31 <lambdabot> 3d6 + 1d10 => 21
09:39:51 <DRMacIver> Uz: ?
09:40:04 <Uz> Sorry, randomly clicked around with my mouse
09:40:19 <Uz> and apparently cn'ped something
09:40:38 <DRMacIver> ok :)
09:44:46 <sorear> hello.
09:44:47 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
09:44:56 <sorear> @messages
09:44:57 <lambdabot> kc5tja said 9h 59m 47s ago: Awesome. I'll need to check it out. Was watching more Internet videos (Penn&Teller's Bullshit! show -- awesome show)
09:45:23 <DRMacIver> Hi sorear
09:46:51 <chatcopitecus> lambdabot
09:53:56 <beelsebob> @dice 3d6 + 1000d23908469938245
09:53:56 <lambdabot> 3d6 + 1000d23908469938245 => 11488317118159424
10:02:05 <DRMacIver> Hm
10:02:42 <DRMacIver> Why does GHC not pass "main = randomIO :: IO Int >>= print" but does when I add a type signature of (Int -> IO ()) to print?
10:02:45 <beelsebob> dons: you about?
10:04:19 <sorear> DRMacIver: both expressions should be illegal, :: can only appear as the rightmost "operator" in a paren'd group
10:05:55 <DRMacIver> Oops, yes. I omitted the parenthesis that are actually in my code.
10:06:13 <DRMacIver> Hm
10:06:31 <DRMacIver> Never mind, I'm being an idiot. I must have added parentheses to the first at the same time as I added a type signature to print.
10:06:39 <DRMacIver> As removing the type signature it now works.
10:08:00 <DRMacIver> Is it just my imagination or is the random source used for randomIO really bad? Running the above program twice in quick succession tends very strongly to produce the same results. It's like it's using a fresh random seed based only on the time in seconds granularity or something.
10:08:32 <sorear> DRMacIver: The time in seconds is the standard random seed.  Everyone uses it.
10:09:05 <DRMacIver> Hm, really? I thought something based on milliseconds was more normal.
10:09:28 <sorear> srand(time(NULL));  is what I've seen most often...
10:09:47 <DRMacIver> Huh. Odd.
10:10:19 <DRMacIver> (The Java standard libraries for example actually use the time in nanoseconds as the default seed)
10:10:59 <DRMacIver> (Well, something a bit more complicated than that actually)
10:11:12 <DRMacIver> Anyway, that doesn't refute my point. The fact that everyone uses it doesn't mean that it's not really bad. :)
10:11:15 <Cale> Using the time to get a random seed on unix seems stupid.
10:11:31 <Cale> Pull a single integer from /dev/random
10:11:44 <Cale> Someone should fix that :)
10:11:53 <sorear> it's in trac
10:39:30 <Kensome> 2 laptops 400 ea. 1 xbox 360 for 300, 1 ps3 with 3 games, extra controller 500, 1 nintendo ds with game 100$  livraiison/shiiping  incl msn: mberrelley@telusmail.net
10:45:23 --- mode: ChanServ set +o shapr
10:45:28 --- kick: Kensome was kicked by shapr (Kicked by shapr)
10:48:55 <ddarius> Interesting.
10:49:48 <shapr> irc spam, yay
10:50:06 <arcatan> eevryone here in the future loves spam
11:00:29 <DRMacIver> Hm. Doing non-trivial IO without do notation makes my brain hurt.
11:01:22 <monochrom> >>= \x ->  notation is ok if you align things nicely.
11:02:14 <ddarius> DRMacIver: The benefit of do-notation is very small.
11:02:17 <Apocalisp> (nerd "Actually, the brain has no pain receptors, so it's impossible for it to hut.")
11:02:26 <Apocalisp> hurt!
11:03:19 <ddarius> Point?
11:03:29 <monochrom> Point!
11:03:36 <DRMacIver> ddarius: Theoretically I know this, yes. :)
11:03:52 <DRMacIver> ddarius: But I seem to be having trouble structuring my thinking that way for IO.
11:04:53 <ddarius> do a <- m; b <- f a; return (g b) <-> m >>= \a -> f a >>= \b -> return (g b)
11:05:06 <drigz> @source Binary
11:05:07 <lambdabot> Binary not available
11:05:14 <ddarius> DRMacIver: It is structured exactly the same as do-notation.
11:05:23 <drigz> @hoogle getbits
11:05:24 <lambdabot> No matches found
11:05:42 <DRMacIver> Yes yes, I understand the translation. And if I write it in exactly the form that I would have written it in if I were using do notation then yes, it's not conceptually harder.
11:06:08 <DRMacIver> But that's hardly the point, is it?
11:06:20 <ddarius> Actually, when you do stuff like do Just x <- m; return x then the translation gets ugly.
11:06:56 <drigz> where is getBits meant to be declared? I don't seem to have it on Gentoo
11:06:58 <ddarius> DRMacIver: You want to write it more "point-free" or something?
11:07:02 <ddarius> @index getBits
11:07:03 <lambdabot> bzzt
11:07:07 <ddarius> @hoogle getBits
11:07:08 <lambdabot> No matches found
11:07:31 <drigz> it seems to be maybe a module called Binary (not Data.Binary), but I don't seem to have it
11:07:43 <ddarius> @hackage Binary
11:07:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Binary
11:07:50 <Saizan> drigz package NewBinary
11:08:05 <Saizan> it's on hackage
11:08:06 <ddarius> @hackage NewBinary
11:08:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/NewBinary
11:08:13 <DRMacIver> ddarius: Basically, yes.
11:08:16 <drigz> Saizan: thanks!
11:08:38 <DRMacIver> ddarius: Although in the end I gave up and just wrote it with do notation. :)
11:09:15 <Saizan> fmap g (m >>= f)
11:09:45 <ddarius> DRMacIver: Two things: If it's hard to figure out, just use do-notation, and/or alternatively just look for easy cases (in do-notation) where you pass some variable around in a trivial manner.
11:10:01 <ddarius> Also, liftM and co. really help and make the code look nice.
11:10:58 <ddarius> Saizan demonstrated exactly how I'd write my above example which is easy to see from my do-notation and/or desugared code.
11:11:56 <ddarius> I.e. in the desugared code you immediately see you can write m >>= f and ... >>= \b -> return (g b) as >>= return . g which is a common pattern caught by liftM (aka fmap) giving liftM g (m >>= f)
11:12:18 <DRMacIver> ddarius: Well, I was trying to figure it out as much as a mental exercise as anything else. :)
11:12:36 <fasta> Can one implement binary search as a fold?
11:12:37 * DRMacIver may rewrite it once the rest is finished
11:13:28 <DRMacIver> Hm
11:13:40 <DRMacIver> @pl \ n f -> foldr (.) id $ flip replicate n f
11:13:40 <lambdabot> (foldr (.) id .) . flip replicate
11:13:47 <DRMacIver> Ah, there we go.
11:13:48 <ddarius> fasta: A binary search over a list? (What's the point?)
11:13:53 <monochrom> binary search over a cons list? I have never seen that.
11:14:12 <monochrom> binary search over a binary tree is probably a fold.
11:14:24 <fasta> One can generalize folds for different structures.
11:14:38 <ddarius> fasta: Indeed, which structure are you referring to.
11:14:50 <ddarius> You can have a fold over an array.
11:14:54 <fasta> ddarius: the vanilla binary tree
11:14:56 <monochrom> one can formulate a complete question.
11:15:29 <ddarius> fasta: Yes, it is a fold albeit you need lazy evaluation for it not to check the whole tree.
11:15:32 <fasta> data Tree = Bin Tree Int Tree | Leaf
11:16:12 <fasta> ddarius: right, that's what I supposed.
11:17:31 <ddarius> \x -> foldTree False (\l i r -> case compare x i of LT -> l; EQ -> True; GT -> r)
11:18:16 <fasta> ddarius: I wish my application was that easy
11:18:41 <ddarius> @quote two.lines
11:18:41 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
11:18:49 * shapr folds fasta up into a very small lambda expression.
11:18:54 <ddarius> @quote two.lines
11:18:55 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
11:19:02 <ddarius> Hmm.
11:19:31 <ddarius> @quote melt
11:19:32 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
11:19:42 <ddarius> Ah '2'
11:19:47 * shapr folds himself up into an origami combinator.
11:20:01 <DRMacIver> Hm. Hurrah. My trivial list shuffler works. :)
11:20:12 <Cheery> How can I force garbage collection after each line request in ghci?
11:20:47 <shapr> @index performGC
11:20:48 <lambdabot> System.Mem
11:21:02 <LoganCapaldo> @type System.Mem.performGC
11:21:05 <lambdabot> IO ()
11:21:12 * LoganCapaldo applauds
11:21:25 <LoganCapaldo> for a second there I was truly afeared it would be ()
11:22:33 <Cheery> shapr: does not seem to help
11:22:58 <haskellnew> hello , ghci gives " Could not find module `Parsec' "   when using  "import Parsec"
11:23:20 <LoganCapaldo> Text.ParserCombinators.Parsec
11:23:24 <LoganCapaldo> IIRC
11:23:33 <SamB_XP_> Parsec is the old name
11:23:35 <LoganCapaldo> @index Parsec
11:23:36 <lambdabot> bzzt
11:23:46 <SamB_XP_> @index Parser
11:23:47 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
11:24:15 <ddarius> Cheery: performGC is only a "hint"
11:24:39 <DRMacIver> Hm. This code is embarassingly strongly tied to its IO. I should fix that.
11:24:45 <monochrom> You can force garbage collection by exhausting memory.
11:25:05 <ddarius> Maybe I'm wrong though.
11:25:18 <haskellnew> ok thanks , it works now
11:26:11 <Philippa> LoganCapaldo: the appropriate type of a 'pure' performGC would be the one that suggests it's denotationally equivalent to id
11:26:12 <Cheery> ok
11:26:44 <ddarius> It is denotationally equivalent to id modulo finalizers I guess.
11:26:45 <LoganCapaldo> Philippa: In "FP for dummies" talk?
11:26:55 <ddarius> and weak pointers too I guess.
11:27:04 <chatcopitecus> I have a problem with ghci
11:27:33 <chatcopitecus> if I write something like primeList :: Int -> [Int]
11:27:48 <chatcopitecus> I get <interactive>:1:0: Not in scope: `primeList'
11:27:55 <chatcopitecus> what's the matter?
11:28:05 <LoganCapaldo> ghci is not the same as a file
11:28:18 <chatcopitecus> I don't understand
11:28:27 <LoganCapaldo> that's ok neither do I :)
11:28:33 <chatcopitecus> I'm using the interactive front-end
11:28:40 <LoganCapaldo> yes
11:28:49 <LoganCapaldo> ghci doesn't work the same as code sitting in a file
11:28:58 <chatcopitecus> I figured that out
11:29:03 <LoganCapaldo> stick your pimeList :: stuff in a file and load it
11:29:05 <DRMacIver> chatcopitecus: You should think of GHCI as being closer to a do block than anything else.
11:29:07 <Philippa> LoganCapaldo: "you could redefine it to id and modulo memory usage there'd be no change in what result you get"
11:29:16 <ariep> usually you don't need to specify types; they are inferred by the compiler
11:29:23 <LoganCapaldo> Philippa: ok
11:29:27 <DRMacIver> chatcopitecus: Haskell's syntax doesn't allow for very good interpreters unfortunately. :)
11:29:32 <Philippa> operationally, it does things that id doesn't - but you can't tell the difference from within pure code
11:29:32 <DRMacIver> ERr,
11:29:36 <DRMacIver> Well, I don't mean interpreters.
11:29:43 <DRMacIver> I mean top level interactive prompts.
11:29:49 <chatcopitecus> ariep: OK, I don't need to specify types
11:29:53 <DRMacIver> (Or whatever the hell they're called :) )
11:29:55 <fasta> DRMacIver: ?
11:29:58 <ddarius> DRMacIver: Sure it does.
11:29:59 <Philippa> it doesn't have to be as bad as you might think
11:29:59 <fasta> DRMacIver: why wouldn't it?
11:30:00 <chatcopitecus> but I'm puzzled by this difference
11:30:13 <Philippa> you might end up with a library of IO operations that can only be carried out from inside a REPL...
11:30:13 <Cheery> @index Memoize
11:30:14 <lambdabot> bzzt
11:30:20 <Cheery> @index Memoization
11:30:20 <lambdabot> bzzt
11:30:28 <chatcopitecus> between the interactive and compiled
11:30:28 <ddarius> chatcopitecus: GHCi only evaluates Haskell expressions, you cannot make new declarations (e.g. function definitions, type declarations).
11:30:28 <Philippa> I'm considering taking that approach for an interpreter for another language I'm working on
11:30:46 <fasta> chatcopitecus: reading a user-manual also doesn't hurt
11:30:54 <chatcopitecus> ddarius: if I have a function
11:31:03 <DRMacIver> fasta: Because the parsing isn't single pass, so the interpreter runs into trouble with e.g. mutually recursive function definitions.
11:31:04 <fasta> chatcopitecus: it's not as if that misfeature isn't documented.
11:31:17 <ariep> chatcopitecus: in fact you can declare a function/variable in ghci, by using 'let'
11:31:21 <chatcopitecus> how do I define it with an argument interactively?
11:31:24 <ddarius> chatcopitecus: There isn't a difference between interactive and compiled, GHCi just accepts only a subset of Haskell.
11:31:34 <Philippa> DRMacIver: you just have to write them in one line
11:31:35 <fasta> DRMacIver: It's still a computable function => I don't see the problem.
11:31:39 <chatcopitecus> can I declare functions with let too?
11:31:42 <ariep> yes
11:31:47 <chatcopitecus> OK
11:31:48 <DRMacIver> fasta: I'm not talking about interpreting Haskell.
11:31:49 <chatcopitecus> thanks
11:31:52 <ariep> "let f x = x + 1"
11:31:52 <DRMacIver> fasta: I'm talking about a decent REPL.
11:32:04 <fasta> DRMacIver: You make arbitrary assumptions over a potential implementation of a REPL.
11:32:09 <ddarius> Philippa, DRMacIver: The interpreter can easily have a multiline mode.
11:32:16 <chatcopitecus> I'm just beginning to learn, sorry for the stupid questions
11:32:27 <ddarius> You can't of course make forward references interactively, but that's far from unreasonable.
11:32:32 <monochrom> Why are people arguing?
11:32:58 <Philippa> ddarius: yeah, but you can do it on one line /now/
11:32:58 <Cheery> I wonder what would be the nicest and funniest way of doing a scene graph for vector renderer
11:33:01 <ddarius> By "interactively" I mean write some code referring to something later, evaluate it, and then define the later thing.
11:33:04 <ddarius> Philippa: True.
11:33:39 <DRMacIver> Ok. Fine. I don't care enough to defend my point. Nonetheless, none of the current interactive modes for Haskell that I'm aware of approach what I'd consider a reasonable standard.
11:34:00 <ddarius> DRMacIver: hbi is/was supposed to be good.
11:34:03 <DRMacIver> Whether it's possible / easy is a different question.
11:34:11 <Cheery> ie, how to do a such scene graph which is fun to use and create while being very neat implementation too?
11:34:15 <DRMacIver> ddarius: Hm. Not seen that one.
11:34:16 <chatcopitecus> about defining things later, Mathematica can do it
11:34:45 <chatcopitecus> so I think it should be possible to do better
11:34:47 <ddarius> chatcopitecus: It's dynamically typed (1) and is impure (2).
11:34:47 <Cowmoo> hi
11:34:59 <Cowmoo> can someone tell me what benefits lazy evaluation gives you?
11:35:10 <Cheery> Cowmoo: myriads
11:35:11 <fasta> chatcopitecus: changing the REPL in that way creates a new language
11:35:15 <Philippa> Cowmoo: damn, you just forced everyone to think about it
11:35:15 <Cowmoo> it lets you have infinite structures which is nice
11:35:22 <Cowmoo> anything else?
11:35:26 <chatcopitecus> ddarius: right, but I don't think that those things help
11:35:29 <Saizan> we need something like the python repl, where some keywords and indentation trigger multiline mode, and treat multiline blocks as atomic wrt type checking
11:35:32 <ddarius> However, you -could- make it work, but I see little reason to.  Also note we are only talking about an interactive shell, in a file you can refer to whatever wherever.
11:35:33 <Philippa> yeah, it also lets you stop thinking entirely about order of evaluation, it lets you use HOFs where a strict language'd need macros...
11:35:34 <monochrom> lazy evaluation allows you to implement an REPL that supports forward references.
11:35:46 <ariep> Cowmoo: it allows better composition
11:35:51 <fasta> monochrom: :)
11:36:10 * fasta likes monochrom's unifying answer
11:36:13 <Cowmoo> ariep: ok I can see that
11:36:16 <ddarius> monochrom: You going to use lazy IO?
11:36:17 <ariep> by seperating the definition of some data from its use
11:36:23 <Philippa> fasta: you can create the new language in such a way that it's "REPL commands + Haskell" though
11:36:37 <monochrom> lazy parsing and typechecking and linking, ddarius
11:36:44 <Cowmoo> monochrom: mind elaborating?
11:36:53 <Cowmoo> what do you mean forward references?
11:37:25 <ddarius> monochrom: If I define a function with a forward reference and start using it, it's going to hit bottom until I enter the code it uses.
11:37:28 <fasta> Philippa: yes, but I think that's the reason why it hasn't been done before. I don't say I would have chosen to do things in that way, but that's the way it currently is.
11:38:09 <Cowmoo> Philippa: right, that too (re: functions instead of macros)
11:38:20 <ddarius> Cowmoo: Just a few minutes ago I wrote some code that only works (helpfully) in a lazy language that has nothing to do with infinite data structures, albeit it would work on an infinite data structure.
11:38:44 <monochrom> Suppose the very first fragment the user enters is "f :: FooFoo -> FunFun". You want to typecheck that, right? But FooFoo and FunFun are not seen yet.  Well, using lazy evaluation, you thunk up the typechecking for now.  Most likely the necessary information will come later.  When, finally, the user says "evaluate f foo1", that's when you force the typechecking thunk.
11:39:02 <Cowmoo> ohh I see
11:39:29 <Philippa> Cowmoo: the functions vs macros bit has some surprising ramifications. You can't really use >> the way you'd expect in a strict language, for example
11:40:01 <Cowmoo> Philippa and everyone: just a disclaimer, I don't know any Haskell - only currently reading SICP chapter 4
11:40:05 <monochrom> ddarius: Yes, if the necessary information is still missing when the user forces it, nothing will help. We accept that fate.
11:40:09 <Cowmoo> where they talk about laziness
11:40:26 <Cowmoo> so I don't know what >> is
11:40:41 <Philippa> it's a common monadic operation
11:40:43 <DRMacIver> Hm, SICP. I finally picked up a copy a few weeks ago. I don't think I've opened it yet.
11:41:07 <Philippa> I've skimmed some of it - I don't think it'd be anywhere near as fun for me as it would've been five years ago though
11:41:39 <Cowmoo> ddarius: what did your code do that you couldn't do non-lazily?
11:41:41 <DRMacIver> I suspect I'm still at the point where I can learn a fair bit from it.
11:42:01 <DRMacIver> But I've got about 4 or 5 other books I'm part way through reading which I can learn just as much from. :)
11:42:36 <Cowmoo> to be honest the bits about delaying evaluation are probably the most memorable for me so far
11:42:38 <Cowmoo> in SICP
11:42:41 <monochrom> Anyway, YES! I'm great at giving one single answer to two questions. Moreover sometimes the answer appears before the second question.
11:42:51 <Cheery> nehe tutorials are really pushing me to implement scene graph next..
11:43:02 <ray> @hoogle a -> [a]
11:43:03 <sorear> .
11:43:04 <lambdabot> Prelude.repeat :: a -> [a]
11:43:04 <lambdabot> List.intersperse :: a -> [a] -> [a]
11:43:04 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
11:43:11 <DRMacIver> monochrom: Is your answer not to this question?
11:43:32 <pkd> urk. my connection keeps failing. i hope nobody answered yet :s
11:43:32 <monochrom> haha
11:43:45 <Cheery> lol
11:44:01 <ddarius> Cowmoo: The code used a fold over a Tree to implement binary search which if Haskell was strict would have been pointless because in an eager language the whole tree would be searched instead of just what was needed.
11:44:20 <SamB_XP_> pkd: maybe you should just read the logs ;-)
11:44:21 <Cowmoo> ahh I see
11:44:44 <pkd> SamB_XP_: yeah. are they updated frequently? :)
11:44:55 <sorear> pkd: Real time.
11:45:00 <davidL> calculating 2 million factorial took 33.8 real seconds, does this sound reasonable?
11:45:02 <pkd> nice
11:45:05 <sorear> pkd: <1 second latency
11:45:06 <Cowmoo> ddarius: wait, no I don't, can you explain? since binary search never searches the whole tree anyway
11:45:13 <SamB_XP_> you *do* have to hit "refresh"...
11:45:43 <Cheery> in my mind, lazy evaluation somehowly entangles wickedly with knuth coroutines
11:45:44 <sorear> davidL: Maybe.  remember product[1..n]  is asymptotically slow
11:45:57 <ddarius> Cowmoo: The way it was implemented (using a fold) it would in an eager language but not in a strict language.  You'd have to write it out by hand rather than reusing a common function in an eager language.
11:46:15 <ddarius> Cheery: That's because they are related.
11:46:16 <davidL> sorear: hmm product[1..n] didnt even work for one hundred thousand for me =\
11:46:32 <Cowmoo> oh ok
11:47:01 <fasta> ddarius: if I also use values from the two sub-trees below the current one in the fold it still works, right? I.e. it still takes O(depth) time.
11:47:30 <fasta> ddarius: i.e. values that can be computed from the items stored in a Bin
11:47:36 <sorear> > let { kfac d m n | m >= d = n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac 5 1 1
11:47:38 <lambdabot>  40320
11:47:48 <sorear> > let { kfac d m n | m >= d = n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac (2000) 1 1
11:47:50 <lambdabot>  1672691931910011705169952468793676234018507002356736559822305290870074970011...
11:47:52 <Saizan> Cowmoo: a bit like && and || magically shortcuts in eager languages, with laziness every fucntion can shortcut
11:47:54 <sorear> > let { kfac d m n | m >= d = n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac (2000000) 1 1
11:48:00 <lambdabot> Terminated
11:48:02 <Cowmoo> Saizan: sure
11:48:03 <sorear> > let { kfac d m n | m >= d = n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac (200000) 1 1
11:48:07 <Cheery> ddarius: I don't think they are just related
11:48:09 <ddarius> fasta: It depends on what you mean, in my implementation all that is returned is a Bool, you don't have access to the subtrees at all.  However, you could return a pair with the information you needed and it should still work.
11:48:09 <lambdabot> Terminated
11:48:14 <Cheery> they entangle more strongly
11:48:27 <Cheery> it's like they'd be almost and exactly the same thing!
11:48:30 <fasta> ddarius: yes, I am using higher-order folds for the problem
11:48:42 <sorear> > let { kfac :: Int -> Int -> Int -> Integer ; kfac d m n | n `seq` m >= d = n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac (100000) 1 1
11:48:44 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
11:48:56 <sorear> > let { kfac :: Int -> Int -> Int -> Integer ; kfac d m n | n `seq` m >= d = toInteger n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac (100000) 1 1
11:48:59 <lambdabot>  2358150556532892503967638667879458845112306047411385362728917951127672546251...
11:49:02 <sorear> > let { kfac :: Int -> Int -> Int -> Integer ; kfac d m n | n `seq` m >= d = toInteger n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac (200000) 1 1
11:49:08 <lambdabot> Terminated
11:49:23 <davidL> impressive
11:49:30 <ddarius> Cheery: They are strongly related, but they are not exactly the same.
11:50:00 <pkd> Is there an accepted operator synonym of 'mappend'? I used to use <*>, but that is now claimed by Control.Applicative...
11:50:01 <Cheery> ddarius: like a perspective from same banana?
11:50:05 <sorear> davidL: Were you using binary splitting?
11:50:14 <Cowmoo> ok thanks guys, some good answers
11:50:24 <pkd> will i be shot at night if i just use ++ ?
11:50:31 <sorear> pkd: yes, ++.  unfortunately the h98 fools decided to make it list-specific
11:50:37 <sorear> pkd: it was polymorphic before
11:50:53 <davidL> sorear: yes
11:51:02 <pkd> alright
11:51:19 <Cheery> I think I'll approach this scene-graph thing from bottom and forget the HOpenGL for momnet
11:51:23 <Cheery> *moment
11:53:22 <pkd> irc noob question: can i kick my other self to reclaim my first nickname?
11:53:43 <Cheery> yes
11:53:46 <Saizan> only if you have registered it
11:53:48 <Cheery> if you are registered
11:53:49 <ddarius> If you've identified yourself you can.
11:53:51 <Cheery> nickserv help
11:54:21 <Philippa> pkd: no. You want to /kill/ your other self
11:54:23 <LoganCapaldo> /msg nickserv ghost nick pass IIRC
11:54:34 <Philippa> (but that's what LoganCapaldo's shown you how to do)
11:54:57 <sorear> hello jyp
11:55:52 <DRMacIver> Philippa: Sounds awfully psychological to me. :)
11:56:17 <LoganCapaldo> I think hes already dead
11:56:27 <LoganCapaldo> you want to exorcise your other self
11:56:39 <pkd> exactly
11:57:24 <pkd> i don't feel too registered today
11:58:31 <jyp> hey sorear
12:06:35 <davidL> sorear: kfac doesn't return the correct answer for 2 hundred thousand factorial
12:08:37 <davidL> > 1306594 - 973352 --it's about this many digits too long
12:08:43 <lambdabot>  333242
12:09:23 <sorear> > let { kfac :: Int -> Int -> Int -> Integer ; kfac d m n | n `seq` m >= d = n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac 3 1 1
12:09:24 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
12:09:50 <sorear> > let { kfac :: Int -> Int -> Int -> Integer ; kfac d m n | n `seq` m >= d = toInteger n | otherwise = kfac d (m*2) n * kfac d (m*2) (n+m) } in kfac 3 1 1
12:09:52 <lambdabot>  24
12:10:29 <davidL> > 3*2*1 ==24
12:10:31 <sorear> hmm.
12:10:31 <lambdabot>  False
12:10:38 <sorear> odd.  oh well
12:10:49 <ddarius> > 4*3*2*1
12:10:50 <lambdabot>  24
12:10:53 <davidL> it still runs really fast though ;)
12:11:01 <merus> lol
12:13:04 <davidL> only 1.1 seconds slower than a percision math library for C
12:13:15 <chatcopitecus> probably this gets asked a lot, but here it is: I wrote a Haskell program for computing the list of first n prime numbers
12:13:30 * ddarius waits for it.
12:13:35 <chatcopitecus> primeList :: Int -> [Int]
12:13:35 <chatcopitecus> primeList n = foldl (\x y -> filter (\z -> z `mod` y /= 0) x) [1..n] [2..floor $ sqrt n]
12:13:41 <sorear> chatcopitecus: why stop at the first N?
12:13:52 <chatcopitecus> ?
12:13:56 <sorear> > nubBy(((>1).).gcd)[2..]  -- have ALL of them!
12:13:58 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:14:03 <chatcopitecus> OK
12:14:06 <chatcopitecus> got you
12:14:06 <davidL> sorear you're my hero
12:14:22 <sorear> davidL: what did I do this time?
12:14:42 <chatcopitecus> but I would like to understan why it doesn't work
12:14:55 <moglum> @type nubBy
12:14:57 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
12:15:04 <chatcopitecus> I mean, I think there's something wrong with floor $ sqrt n
12:15:36 <chatcopitecus> because if I put the numbers by hand it works
12:15:39 <davidL> > [2..floor $ sqrt 64]
12:15:39 <ddarius> chatcopitecus: You mean it doesn't type check.
12:15:41 <lambdabot>  [2,3,4,5,6,7,8]
12:15:49 <chatcopitecus> something like that
12:16:09 <davidL> :t [2..floor $ sqrt 64]
12:16:11 <lambdabot> forall b. (Integral b) => [b]
12:16:15 <chatcopitecus> the error message is to cryptic for me
12:16:24 <ddarius> chatcopitecus: When you write 4, say, as a literal it's interpreted as 'fromIntegral 4'.
12:16:38 <davidL> :t [2..truncate $ sqrt 64]
12:16:41 <lambdabot> forall b. (Integral b) => [b]
12:16:49 <ddarius> :t sqrt
12:16:51 <lambdabot> forall a. (Floating a) => a -> a
12:17:23 <ddarius> You are probably getting an error like: No instance of Floating Int
12:17:54 <chatcopitecus> it's longer than that
12:18:00 <chatcopitecus> but it's a type problem
12:18:14 <ddarius> Yes, I know, but it says something along those lines somewhere in it.
12:18:16 <ddarius> ?
12:18:18 <chatcopitecus> if I type floor $ sqrt 10 it works
12:18:36 <chatcopitecus> <interactive>:1:0:
12:18:36 <chatcopitecus>     Ambiguous type variable `t' in the constraints:
12:18:36 <chatcopitecus>       `Floating t'
12:18:36 <chatcopitecus>         arising from use of `primeList' at <interactive>:1:0-10
12:18:36 <chatcopitecus>       `RealFrac t'
12:18:37 <ariep> that's because '10' is overloaded
12:18:37 <chatcopitecus>         arising from use of `primeList' at <interactive>:1:0-10
12:18:39 <chatcopitecus>       `Integral t'
12:18:41 <chatcopitecus>         arising from use of `primeList' at <interactive>:1:0-10
12:18:43 <chatcopitecus>     Probable fix: add a type signature that fixes these type variable(s)
12:18:56 <ariep> > floor $ sqrt (10 :: Int)
12:18:57 <lambdabot>   add an instance declaration for (Floating Int)
12:19:33 <ddarius> All you need is to add a fromIntegral before n in the sqrt expression
12:19:42 <chatcopitecus> OK
12:19:51 <davidL> > floor $ sqrt ( fromIntegral n)
12:19:52 <lambdabot>   Not in scope: `n'
12:20:34 <davidL> works
12:20:41 <chatcopitecus> thanks
12:21:11 <ddarius> Note, something called defaulting is used there.
12:21:49 <davidL> :set +s
12:22:50 <davidL> does lambdabot use GHC or GHCi to run haskell code?
12:22:56 <sorear> davidL: GHC
12:23:12 <sorear> davidL: ghc -O2 -fextended-default-rules
12:23:20 <davidL> I see
12:23:30 <sorear> that's why it's so much faster than ghci :)
12:23:45 <davidL> it would be nice if it ran time also
12:24:21 <sorear>  @ask dons
12:24:24 <cdsmith> sorear: ghc -O2 is faster than interpreting an expression in GHCi?
12:24:42 <Baughn> cdsmith: Depends on the expression
12:24:52 <sorear> cdsmith: By several orders of magnitude, for long running expressions
12:25:07 <Baughn> By several gigabytes, for some other expressions
12:25:11 <wilx> :)
12:25:12 <sorear> cdsmith: and the ~0.5s needed to optimize expressions is lost in IRC lag
12:25:13 <cdsmith> GHC -Oanything is very slow on my machine...
12:25:47 <Baughn> @src foldl
12:25:47 <lambdabot> foldl f z xs = lgo z xs
12:25:48 <lambdabot>     where lgo z []     =  z
12:25:48 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
12:25:52 <Baughn> @src foldl'
12:25:53 <lambdabot> foldl' f a []     = a
12:25:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:26:52 <davidL> do people often create their own Prelude library that's more efficient?
12:27:03 <cdsmith> That;s just weird.  It just took about 10 seconds to compile a hello world with -O2.  About 0.5 seconds without -O2.  Is that just me?
12:27:15 <Baughn> davidL: No, never. What are you concerned about?
12:27:41 <Baughn> cdsmith: lambdabot does run on a sixteen-core machine or something like that
12:27:54 <sorear> cdsmith: You notice that most of the time is spent in the Linking... stage
12:27:56 <davidL> I'm not really concerned about anything, just curious.
12:28:13 <davidL> dons has a 16 core machine?
12:28:16 <cdsmith> sorear: yes.  Doesn't lambdabot need to link?
12:28:18 <sorear> cdsmith: lambdabot uses a special loader that can load the .o files directly, so linking is skipped.
12:28:22 <Baughn> Oh, and - are there any advantages to using foldl over foldl'? When?
12:28:26 <cdsmith> oh!
12:28:42 <Baughn> davidL: Maybe not that, but it's something preposterously powerful. I bet that helps.
12:28:48 <ehird`> sorear: so its an OS? :)
12:29:03 <sorear> Baughn: dons has a 16 code machine, but it's a benchmarking clean room and can't be used for lambdabot.  I suspect it doesn't even have cron running ;)
12:29:14 <sorear> 16 core 2ghz amd64
12:29:32 <sorear> lambdabot's actual machine is an ordinary 2ghz p4
12:29:32 <Baughn> sorear: I see. What does it run on, then?
12:29:36 <sorear> @version
12:29:36 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
12:29:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:29:38 <Baughn> Ah.. gah?
12:31:08 <Baughn> > [1..] seq []
12:31:15 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
12:31:27 <sorear> Baughn: huh?
12:31:31 <Baughn> :t seq
12:31:33 <sorear> Baughn: [1..] isn't a function!
12:31:34 <lambdabot> forall a t. a -> t -> t
12:31:38 <Korollary> he forgot the `
12:31:39 <roconnor> > [1..] `seq` []
12:31:41 <ddarius> @oldwiki StackOverflow  Baughn
12:31:41 <lambdabot>  []
12:31:41 <lambdabot> http://www.haskell.org/hawiki/StackOverflow  Baughn
12:31:49 <sorear> Baughn: you're applying [1..] to two arguments - seq and []
12:31:52 <ddarius> But, essentially, you shouldn't use foldl ever.
12:32:01 <Baughn> sorear: Yes, I forgot the ``
12:32:27 <Baughn> Trying to figure out exactly how strict seq is.. I was hoping that up there would give me a timeout. :/
12:33:06 <Baughn> > fix (\f x -> f x) `seq` 42
12:33:08 <lambdabot>  42
12:33:12 <Philippa> seq != deepseq, if that's what you mean - it doesn't evaluate a constructor's values
12:33:31 <Baughn> Ah.
12:33:57 <sorear> ehird`: No, lambdabot isn't an OS. GHC however is.
12:34:06 <Baughn> @doc seq
12:34:07 <lambdabot> seq not available
12:34:11 <sorear> ehird`: it's amazing all the stuff you find in the GHC-RTS
12:35:06 <Baughn> So, seq basically evaluates /one/ thunk?
12:35:08 <sorear> ehird`: a SMP scheduler, a block memory manager, a suballocator, a work pool system, a bytecode interpreter, etc.
12:35:23 <sorear> Baughn: Yes, and everything that the thunk calls.
12:36:01 <Baughn> sorear: Right, but it doesn't choke on infinities because it stops after one level
12:36:14 <sorear> ehird`: GHC has been ported to raw x86 - see House
12:36:18 <sorear> Baughn: yes.
12:36:36 <ddarius> Baughn: seq evaluates to whnf not nf.
12:36:41 <Baughn> Also, does @doc ever work?
12:36:46 <Baughn> ddarius: ?
12:36:48 <ddarius> @doc Data.List
12:36:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
12:37:03 <ddarius> whnf == weak head normal form nf = normal form
12:37:22 <ddarius> > fix id `seq` 42
12:37:24 <lambdabot>  Exception: <<loop>>
12:39:04 <Baughn> ddarius: Why does that happen?
12:39:14 <ddarius> Baughn: Why does what happen?
12:39:26 <Baughn> @src id
12:39:27 <lambdabot> id x = x
12:39:53 <ddarius> :t fix ($)
12:39:55 <ddarius> :t fix id
12:39:55 <lambdabot> forall a b. a -> b
12:39:57 <lambdabot> forall a. a
12:42:43 <Baughn> So, <<loop>> counts as a form of bottom?
12:42:49 <sorear> Yes.
12:44:49 <ddarius> All exceptions are a form of bottom.
12:45:06 <SamB> and some things that just don't return anything, ever
12:45:26 <SamB> > last (cycle 1)
12:45:27 <lambdabot>   add an instance declaration for (Num [a])
12:45:34 <SamB> hmm.
12:45:39 <SamB> @type cycle
12:45:40 <Wild_Cat> Is there a Haskell library equivalent to Python's BeautifulSoup (i.e. a parser for the kind of absolute crap HTML that unfortunately makes up 95% of the web)?
12:45:41 <lambdabot> forall a. [a] -> [a]
12:45:45 <SamB> oh, right.
12:45:52 <ddarius> TagSoup
12:45:53 <SamB> > last (repeat 1)
12:45:59 <lambdabot> Terminated
12:46:15 <ddarius> @hackage TagSoup  ?
12:46:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TagSoup  ?
12:46:31 <Saizan> @hackage not a very smart command
12:46:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/not a very smart command
12:46:33 * SamB was wondering if GHC was able to CSE that somehow...
12:46:36 <Wild_Cat> 404 :p
12:46:38 <ddarius> http://www-users.cs.york.ac.uk/~ndm/tagsoup/
12:46:41 <lambdabot> Title: Neil Mitchell - Tag Soup
12:46:47 <ddarius> Saizan: I realize.
12:46:52 <Wild_Cat> cheers.
12:47:51 <ddarius> SamB: And what?
12:48:25 <SamB> ddarius: figure out it was a loop
12:48:58 <ddarius> @src last
12:48:59 <lambdabot> last [x]    = x
12:48:59 <lambdabot> last (_:xs) = last xs
12:48:59 <lambdabot> last []     = undefined
12:49:13 <ddarius> @src repeat
12:49:14 <lambdabot> repeat x = xs where xs = x : xs
12:50:37 <ddarius> SamB: Even deforested what you get is last xs = last xs.
12:51:42 <SamB> ddarius: well, if it noticed that the recursive call to last was on the self-same value...
12:58:11 <ddarius> > let f x = f x in f 'a'
12:58:17 <lambdabot> Terminated
13:03:25 <falconair> if i want to incrementally calculate the average of a list of numbers, I can use the following simple expression:
13:03:27 <falconair> >take 11 (scanl (\x y-> (fst x +  y, snd x+1)) (0,0) [1..])
13:04:13 <falconair> however, if i want to calculate the average over some window (say, 3 consecutive numbers over the whole list...a running avg) ... is there a simple way of doing that?
13:06:08 <ClaudiusMaximus> > (\l -> zipWith3 (\a b c -> a + b + c) l (tail l) (tail (tail l)) ) [1..10]
13:06:13 <lambdabot>  [6,9,12,15,18,21,24,27]
13:07:19 <mauke> @pl \a b c -> a + b + c
13:07:20 <lambdabot> ((+) .) . (+)
13:07:48 <mauke> @pl \ (+) a b c -> a + b + c
13:07:48 <lambdabot> (line 1, column 4):
13:07:49 <lambdabot> unexpected "+"
13:07:49 <lambdabot> expecting pattern
13:07:52 <falconair> ClaudiusMaximus: is this a solution to my problem?  could you give a one line english translation please :)
13:08:03 <mauke> @pl \f a b c -> a `f` b `f` c
13:08:04 <lambdabot> (.) =<< (.)
13:08:48 <drigz> @pl \f a b c -> f a (f b c)
13:08:48 <lambdabot> flip =<< (((.) . (.)) .)
13:08:56 <ClaudiusMaximus> falconair: it adds the list to two shifted copies, thereby finding the sum of each three consecutive elements
13:08:59 <drigz> @pl \f a b c -> f (f a b) c
13:09:00 <lambdabot> (.) =<< (.)
13:09:36 <mauke> :t (.) >>= (.)
13:09:38 <lambdabot> forall b a. (b -> a -> b) -> b -> a -> a -> b
13:10:54 <falconair> ClaudiusMaximus: ok, can it abstract over the number of consecutive items...in other words, can i use the same function to do sums of 3 consecutive numbers or 10 consecutive numbers?
13:11:58 <ClaudiusMaximus> falconair: not easily
13:12:51 <drigz> :t scanl
13:12:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:14:18 <falconair> ClaudiusMaximus: i could probably work around that, secondly, is it effecient?  in other words, if i run your logic to calculate number over a _huge_ list (potentially infinite) ... will there by any space/time explosions?
13:14:20 <mauke> > (\n -> transpose . take n . iterate tail) 4 [1..]
13:14:21 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10],[8,9...
13:14:23 <drigz> > let sums n l = let pairs = zip l (drop n l) in scanl (\s (o,i) -> s-o+i) (sum (take n l)) pairs in sums 3 [1..10]
13:14:25 <lambdabot>  [6,9,12,15,18,21,24,27]
13:14:46 <mauke> > map sum . (\n -> transpose . take n . iterate tail) 4 $ [1..]
13:14:47 <lambdabot>  [10,14,18,22,26,30,34,38,42,46,50,54,58,62,66,70,74,78,82,86,90,94,98,102,10...
13:15:03 <drigz> mauke: that's o(nm) i think
13:15:45 <drigz> falconair: translation of mine: pairs in a list of tuples representing the change to the sum at each step
13:15:53 <drigz> the scanl then applies those changes
13:16:10 <mauke> what's n and m?
13:16:21 <drigz> mauke: length of the list, length of the sums
13:16:40 <falconair> drigz: i had no idea you were solving my problem!  could you paste your function again please
13:16:49 <ClaudiusMaximus> > map sum . map (take 4) . takeWhile (not . null) . iterate (drop 1) $ [1..10]
13:16:51 <lambdabot>  [10,14,18,22,26,30,34,27,19,10]
13:16:55 <falconair> (obviously i'm a newbie ... :) )
13:16:58 <drigz> > let sums n l = let pairs = zip l (drop n l) in scanl (\s (o,i) -> s-o+i) (sum (take n l)) pairs in sums 4 [1..10]
13:16:59 <lambdabot>  [10,14,18,22,26,30,34]
13:17:46 <DRMacIver> Hm
13:18:08 <jbauman> that last one seems nice
13:18:24 <DRMacIver> I can't decide whether the fact that I find that amazingly unreadable is a sign a) that I don't know enough Haskell yet b) of sanity or c) both.
13:18:42 <falconair> is "transpose" in the prelude?  I get a not in scope error for "map sum . (\n -> transpose . take n . iterate tail) 4 $ [1..]"
13:18:42 <DRMacIver> But I'm leaning towards a. :)
13:18:48 <drigz> i copied the idea from sorear the other night
13:19:07 <drigz> DRMacIver: part is d) it's been compressed into one line
13:19:22 <DRMacIver> True
13:19:43 <drigz> @hoogle transpose
13:19:44 <lambdabot> List.transpose :: [[a]] -> [[a]]
13:19:44 <lambdabot> Data.Graph.transposeG :: Graph -> Graph
13:19:46 <ddarius> > map (sum . take 4) $ tails [1..]
13:19:48 <lambdabot>  [10,14,18,22,26,30,34,38,42,46,50,54,58,62,66,70,74,78,82,86,90,94,98,102,10...
13:20:51 <falconair> ok, i need to spend the rest of the day understand these two or three one liners :)  thanks folks!
13:20:53 <drigz> > map (sum . take 4) $ tails [1..6]
13:20:55 <lambdabot>  [10,14,18,15,11,6,0]
13:23:39 <Baughn> @src sum
13:23:39 <lambdabot> sum = foldl (+) 0
13:24:01 <falconair> so is the "maximum segment sum problem" basically the same thing as what was solved here?
13:24:52 <falconair> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/calculating.ps.gz
13:24:55 <lambdabot> http://tinyurl.com/27uhdn
13:25:04 <falconair> "Calculating Functional Programs" by Jeremy Gibbons
13:26:12 <falconair> btw, is there a "@src" command in ghci?
13:26:33 <dmwit> :i is the closest you get.
13:26:38 <shapr> No, but you could add one!
13:27:02 <shapr> I figured out how to add some of the useful lambdabot commands, though I can't remember how I did it right now.
13:27:08 <Baughn> falconair: You could run lambdabot locally. It /mostly/ duplicates the functionality of ghci
13:27:20 <shapr> What about GoA?
13:27:23 <shapr> @where goa
13:27:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
13:27:26 <falconair> cool, i'll try that
13:30:08 <shapr> falconair: http://www.cse.unsw.edu.au/~dons/lambdabot.html talkes about GHCi On Acid, which gives you the full power of lambdabot from inside GHCi.
13:30:09 <lambdabot> Title: lambdabot
13:32:31 <falconair> cool, i'm checking out the gui ... i wish this stuff was integrated in a GUI environment ... with syntax helpers, haskell would go from being fairly difficult to almost trivial!
13:32:42 <falconair> i mean "i'm checking out the wiki"
13:33:17 <DRMacIver> I'm not sure I buy that.
13:33:47 * DRMacIver doesn't find Haskell's syntax to be one that would be very amenable to the usual helper tools.
13:33:49 <Baughn> falconair: Such as emacs, you mean?
13:33:54 <DRMacIver> Inline error reporting would be fantastic though. :)
13:34:08 * DRMacIver should give the emacs mode a try
13:34:13 <DRMacIver> I've never got along with emacs though
13:34:17 <dmwit> vim has pretty good Haskell support.
13:34:25 <Baughn> It's a good editor-construction toolkit
13:34:26 <falconair> Baughn, i haven't used emacs, let me get you an example of an interesting environment ...
13:34:30 <TomMD> DRMaclver: You interview will be all about emacs...
13:34:35 <TomMD> :-)
13:34:54 <DRMacIver> I doubt it...
13:34:56 <TomMD> @quote lambdabot
13:34:57 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
13:34:57 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
13:35:16 <shapr> @quote ghci
13:35:17 <lambdabot> ghci.debugger says: http://haskell.org/haskellwiki/Ghci/Debugger
13:35:26 <DRMacIver> dmwit: Really? What does it have other than the syntax highlighting?
13:35:46 <dmwit> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/vim.html
13:35:49 <lambdabot> Title: Vim as a Haskell IDE, first steps, http://tinyurl.com/yvxl52
13:36:16 <DRMacIver> Cool, thanks
13:36:20 <dmwit> _T to add type annotations is kind of neat.
13:36:27 <falconair> cool (research) gui video: http://www.cs.cmu.edu/~NatProg/movies/CitrusMPEG4.mov
13:36:29 <dmwit> [I to list all places a keyword appears
13:36:50 <dmwit> And C-X C-O for omni-completion.  That one is _very_ nice.
13:37:08 <shapr> There's also http://shim.haskellco.de/trac/
13:37:10 <lambdabot> Title: shim - Trac
13:48:23 <njbartlett> The Haskell plugin for Eclipse isn't bad. Worth considering if you're already an Eclipse user for other reasons (eg you have to use Java for your day job)
13:49:46 <falconair> njbartlett: does the eclipse plugin show types of expressions if mouse hover over them?  f# visual studio does that, and it is very useful
13:49:51 <shapr> Is anyone here currently using shim?
13:50:22 <njbartlett> falconair: No, it doesn't do that
13:50:23 <sorear> I used to use shim.
13:50:26 <dmwit> falconair: That video breaks at 1:09 for me... =(
13:50:32 <fuzan> alright, i have no iddea hwo to derive an instance of Show for a non-haskell-98 constructor
13:50:40 <DRMacIver> njbartlett: I've never found a non Java eclipse plugin I liked. :)
13:50:42 <shapr> sorear: What did you think?
13:50:43 <sorear> it doesn't help more than C-c C-l did, and is much slower to boot
13:50:48 <falconair> dmwit: yeah me too, don't know what happened, i saw it a few months ago, it was fine
13:51:21 <sorear> shapr: jfyi, your +o flag is still set
13:51:23 <fuzan> data Packet = forall b. BattleNet b => Packet b deriving (Show)   -- ghc refuses to try
13:51:35 <fuzan> and I can't seem to mangle together a manual instance
13:51:56 <sorear> fuzan: It can't be done.  How do you show a value if you don't know the type?
13:52:21 <njbartlett> DRMacIver: Yeah. Developing a decently featured IDE for a language is a really big job, even with a framework like Eclipse to build on
13:53:21 <ariep> fuzan: unless you make Show a superclass of Battlenet
13:53:38 <fuzan> ariep: i was just dabbling into tha tidea
13:54:00 <ariep> but that seriously changes the type
13:54:05 <DRMacIver> njbartlett: Yeah, I know. But they've never really managed to get past the point where I considered them superior to vim + syntax highlighting. :)
13:54:08 <Saizan> or  forall b. (BattleNet b,Show b) => Packet b
13:54:10 <ariep> it depends on your use if it is viable
13:54:17 <DRMacIver> njbartlett: It doesn't help that I'm not a big Eclipse fan to start with.
13:54:40 <shapr> sorear: oh
13:54:41 --- mode: shapr set -o shapr
13:55:04 <pgavin> is anyone here familiar with the Haskell FFI?
13:55:15 <Lemmih> pgavin: Yes!
13:55:22 <Baughn> pgavin: Just ask the question
13:55:26 * shapr hugs Lemmih 
13:55:27 <pgavin> cool... ok :)
13:55:34 <DRMacIver> In ##java that would have got you an ~anyone :-p
13:56:12 <pgavin> I'm trying to figure out if     alloca -> (\ptr doSomethingWithPtr ptr)     is equvalient to
13:56:15 <njbartlett> DRMacIver: Fair enough. Eclipse has its warts, it's true. It's a great platform though.... my other big interest besides Haskell is the OSGi runtime at the core of Eclipse.
13:56:29 <pgavin> do { ptr <- alloca return ;  doSomethingWithPtr ptr }
13:56:33 <njbartlett> Anyway, I'll be sent off to #haskell-blah if I talk any more about that!
13:56:43 <sorear> don't you mean   alloca (\ptr -> doSomethingWithPtr ptr)   ?
13:56:45 <sorear> pgavin: No!
13:56:52 <pgavin> sorear:  yeah :)
13:56:55 <pgavin> ok
13:56:58 <pgavin> I thought not
13:56:59 <sorear> pgavin: Alloca frees the memory as soon as it returns.
13:57:02 <pgavin> right
13:57:04 <pgavin> ok :)
13:57:10 <sorear> pgavin: so in your second exampl, ptr is a dangling pointer
13:57:11 <DRMacIver> njbartlett: Yeah, I know. I read your blog. :)
13:57:21 <pgavin> so, I need to use malloc for that
13:57:31 <sorear> isn't it cool that we can provide alloca-like functionality as a plain HOF?
13:57:32 <sorear> :)
13:57:46 <sorear> pgavin: yes, but remember to call free when you're done
13:58:10 * Lemmih gives shapr a wet, just-out-of-a-shower hug.
13:58:13 <pgavin> sorear:  isn't there a garbage collected version of malloc?  like mallocFreeForeignPtr or something?
13:58:35 <sorear> pgavin: mallocForeignPtrBytes
13:59:23 <pgavin> unless I'm using a Storable :)
13:59:37 <pgavin> then there's mallocForeignPtr
14:00:42 <pgavin> is there any downside to using the GC'd version? versus explicit freeing?
14:00:46 <falconair> lambdabot's website says that it is available through a web interface, but the address isn't listed...where can i access lambdabot on the web?
14:00:50 <fuzan> just wrote my first Haskell program that compiles but magically terminates ;)
14:01:01 <mauke> http://www.google.de/search?q=web%20lambdabot
14:01:02 <lambdabot> Title: web lambdabot - Google-Suche
14:01:22 <falconair> got it :)
14:02:26 <shapr> DRMacIver: Whats' ~anyone do?
14:02:31 <shapr> Lemmih: haha!
14:02:36 <sorear> pgavin: You need to keep the ForeignPtr around
14:02:45 <sorear> shapr: I suspect set complement?
14:03:24 <sorear> pgavin: so you can't pass a gc'd ptr into a C function which stores it  - you have to hold it on the Haskell side
14:03:29 <DRMacIver> shapr: ~ triggers a factoid. The relevant factoid in this case is:<javabot> Instead of asking whether anyone works with something you need help with, please save time by asking your actual question.  If someone knows  and wants/has time to help, perhaps he/she will.
14:04:03 <pgavin> sorear: gotcha, thanks
14:05:20 <DRMacIver> Hi Wild_Cat. Do you know anything about Enterprise Haskell Monads?
14:05:47 * Wild_Cat kills DRMacIver with eXtreme Prejudice.
14:05:58 <DRMacIver> :)
14:06:05 <dmwit> ?fact+ ask It saves time for both of us if you just ask the question.
14:06:06 <lambdabot> I know nothing about ask
14:06:18 <dmwit> ?list
14:06:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:06:50 <DRMacIver> Ooh. lambdabot has an unlambda interpreter?
14:06:56 <dmwit> ?fact-set ask It saves time for everyone if you just ask the question.
14:06:57 <lambdabot> Fact recorded.
14:07:00 <Wild_Cat> DRMacIver: did you get that Haskell job you were talking about the other day?
14:07:25 <DRMacIver> Haven't had the interview yet. :)
14:07:45 <int-e> @unlambda `r`.o`.l`.l`.e`.Hi
14:07:45 <lambdabot>  fd:20: hClose: resource vanished (Broken pipe)
14:08:39 <DRMacIver> Shame
14:08:43 <dmwit> ?b52s
14:08:44 <lambdabot> She drove a Plymouth Satellite faster than the speed of light!
14:14:43 <Syrin> Hey, I believe that I'm asking in the wrong channel, but I've spent the better part of my day trying to figure this out, and you are all computer people, so: how do I access a .MYD MySQL database file? I just want to open it, maybe look at what's in it, maybe change one or two things, then I'm done.
14:15:36 <Wild_Cat> I'm no expert, but MySQL comes to mind.
14:15:59 <Syrin> Yyyes. So how do I get that?
14:16:15 <Syrin> The MySQL website has a bunch of downloads, like a 'community server' and some tools for connecting to servers and various, various things
14:16:18 <falconair> Syrin: looks like #mysql channel has a large number of people, they could probably tell you exactly what you want
14:16:47 <Syrin> Alright, I'll head over there. This was just the first thing that came to mind when I wanted intelligent help, because it's the only IRC channel I've ever been in.
14:16:55 <Wild_Cat> Syrin: the MySQL database server is probably what you're looking for.
14:17:38 <Wild_Cat> (which you can install in a couple clicks from just about any Linux distro's package manager)
14:17:53 <Syrin> Kthx, I'm running Windows, not Linux, so..
14:18:11 <Syrin> But, yeah, I'm gonna go get help from the MySQL channel. Thanks anyway.
14:18:22 * DRMacIver boggles
14:18:39 <DRMacIver> How does one possibly join #haskell purely to ask a MySQL question?
14:18:50 <drigz> at least he seemed open to advice on the correct way to get help
14:19:06 <drigz> i remember a while ago some guy came in here asking about using some cracking software
14:19:11 <njbartlett> Anybody got one of those "No I will not fix your computer" t-shirts? ;-)
14:19:32 <mahogny_> and mysql. if you want a db, get the real thing :P
14:19:39 <njbartlett> DRMacIver: You've applied for a Haskell job? Cool... good luck
14:19:48 <DRMacIver> Thanks.
14:20:33 <njbartlett> Wouldn't be the one with Credit Suisse that augustss advertised a while back, would it?
14:20:37 <Wild_Cat> drigz: well, perhaps the program was written in Haskell?
14:21:21 <mahogny_> the reason is obvious! #haskell is the channel if you are looking for the clever guys! :)
14:21:21 <DRMacIver> njbartlett: It is, yes.
14:21:37 <drigz> software tagline: "You'll Pwn Great, I Guarantee It!"
14:21:55 <njbartlett> Nice, I was under the impression that the location was NY...?
14:21:55 <Shimei> drigz: We get people asking about cracking in #nethack and #nethack-offtopic a lot.
14:22:03 <Shimei> More understandable than in #haskell though.
14:22:09 <falconair> DRMaclver: Credit Suisse ... were you at the NYC functional programmers meet?
14:22:23 <DRMacIver> falconair: London branch of CS.
14:22:51 * DRMacIver will be at london-hug though. :)
14:22:55 <Wild_Cat> of course, why someone would join Freenode, of all networks, to talk about cracking software, boggles the mind.
14:23:08 <kpreid> drigz: we have a little fun with this sort of encounter occasionally in #swhack
14:23:11 <njbartlett> Great, see you there...
14:23:11 <drigz> Shimei: :D that's pretty much what i thought when i first heard the name
14:23:16 <Wild_Cat> I mean, we're pretty much the *only* IRC network that's not about trading filez of some sort -.-
14:23:23 <falconair> oh, the NYC branch is looking as well, haskell is slowly picking up
14:23:27 <drigz> i thought it was some game where you hacked in a dungeon :p
14:23:48 <njbartlett> As it happens I'm unemployed at the moment. Though about applying to Credit Suisse, but I'm hopelessly underqualified in Haskell at the moment
14:23:49 <drigz> kpreid: everyone is so polite about it here, it's amazing
14:24:08 <falconair> DRMaclver, do you know what department you will be doing into?
14:24:16 <drigz> it's like 'am i really using the internet now? people are acting like they do when face to face!'
14:24:24 <njbartlett> In many ways Haskell is like the game of Go. The rules are simple and easy to learn, but mastering the strategy takes a lifetime!
14:24:40 <DRMacIver> falconair: Don't count my chickens before they're hatched please! :)
14:25:23 <falconair> :) ok, hope you get the job, if you aren't familiar with the financial industry, i might be able to answer some questions
14:25:37 <Wild_Cat> njbartlett: that applies to most programming languages. Heck, to programming in general, if not to just about any art form out there ;)
14:25:50 <DRMacIver> falconair: But the job is in the global modelling and analytics group.
14:26:25 <DRMacIver> falconair: I might take you up on that. :)
14:26:48 <DRMacIver> Thanks
14:26:55 <njbartlett> Wild_Cat: I don't really agree. I mean, look at C++. Horrendously complicated rulebook... once you've mastered the rules (which nobody ever does) there isn't much more to learn.
14:27:00 <falconair> DRMaclver: sure, shahbazc@gmail
14:28:02 <DRMacIver> njbartlett: I don't think I agree that there isn't much more to learn.
14:28:24 <Wild_Cat> njbartlett: oh, there is. Algorithm design and implementation... Even though I agree C++ feels inelegant, to say the least. But that's in the eye of the beholder. There are people out there who like drum machines. ;)
14:29:13 <Wild_Cat> the thing is, most of us come to Haskell (or FP in general) after years of procedural (or OO) programming, which by that point feels natural to us.
14:29:30 <njbartlett> Well okay. But the point is probably moot. C++ takes up too much brainspace, there's nothing left for algorithm design ;-)
14:29:55 <Wild_Cat> njbartlett: agreed.
14:30:32 <DRMacIver> Nah. C++ is no more complicated than e.g. english. :)
14:30:51 <DRMacIver> (English when you're talking to a collossal pedant maybe)
14:31:11 <njbartlett> Yeah exactly. And how many English people (or Americans) can speak anything other than English? ;-)
14:32:11 <DRMacIver> But that's not what you were complaining about. To stretch the analogy, we're talking about their proficiency in english itself, which... err.
14:32:14 <DRMacIver> I see your point.
14:32:35 <njbartlett> :-)
14:33:01 <ddarius> To stretch the analogy, a decent chunk can speak languages other than English, certainly not most, but most have no reason to.
14:33:28 <Wild_Cat> bah, a little bit of random C++ bashing is always healthy anyway.
14:34:34 <DRMacIver> I always feel that I'm missing somethign due to the lack of low level languages in my repertoire. I dont' have more than a little bit of C really. (I'm broadly speaking aware of what C++ is like, but not to the point where I can actually write the stuff)
14:34:37 <njbartlett> Yeah, but C++ is not the only bad guy. I mean, HOW MANY reserved keywords does C# need?
14:35:04 <Wild_Cat> DRMacIver: IMO, C++ isn't low-level enough to be interesting.
14:35:25 <fuzan> if I have an existential type such as: data Foo = Foo2 a => Foo a, how can I access a? I've tried record syntax and simple pattern matching functions, yet I can't seem to outsmart the type system. On further thought, I'd have to specify the exact type?
14:35:50 <Wild_Cat> C is what I consider to be the low-level language of choice. It's spartan, but at least it's not bloated.
14:36:17 <DRMacIver> Wild_Cat: Well I'd rather work on my C knowledge than my C++. But C++ at least gives you access to the low level.
14:36:21 <DRMacIver> njbartlett: I like C#. :)
14:36:27 <njbartlett> Yeah. Who was it that called C "portable assembler"?
14:36:35 <fuzan> Wild_Cat: it's a beautiful core language. Imagine using Haskell without any Libraries. I'd be almost as annoyed :)
14:36:47 <Wild_Cat> fuzan: true.
14:36:56 <falconair> what does this mean: "No instance for (Fractional Int) arising from use of '/' at ..."
14:36:57 <falconair> take 5 (map (\x->(sum x) / (length x))  (List.tails [1..]))
14:37:19 <fuzan> :t div
14:37:21 <lambdabot> forall a. (Integral a) => a -> a -> a
14:37:31 <DRMacIver> falconair: / isn't the operator for integer division.
14:37:33 <Wild_Cat> C++, in hindsight, looks like a half-assed, lower-level Java.
14:37:40 <falconair> oh...'div' ?
14:38:01 <DRMacIver> falconair: Or you could convert your integers to rationals.
14:38:14 <fuzan> I don't have any complaints with C++. The syntax is a little dirty, but it accomplishes its goal
14:38:16 <DRMacIver> Depending on what you want the answer to be.
14:38:58 <falconair> DRMaclver, how do i convert integers to rationals?
14:39:42 <Wild_Cat> fuzan: if said goal is "an OO-ish superset of C", I'd say you're right. But I think it lacks too many things for it to be a proper OO language.
14:40:03 <ddarius> falconair: The same way you convert integers to anything else.
14:40:32 <DRMacIver> falconair: toRational
14:40:39 <falconair> thanks
14:40:41 <fuzan> Wild_Cat: What does it lack?
14:40:47 <ddarius> It's about as OO as most "mainstream" "OO" languages.
14:40:47 <mauke> > take 5 (map (\x-> sum x / fromIntegral (length x)) (List.tails [1..]))
14:40:54 <lambdabot> Terminated
14:40:54 <ddarius> fromIntegral
14:41:00 <DRMacIver> falconair: You should probably just have hoogled for Int -> Rational though. :)
14:41:16 <mauke> > take 5 (map (\x-> sum x / fromIntegral (length x)) (List.tails [1..100]))
14:41:17 <fuzan> falconair: fromIntegral, toInteger, fromRational, fromInteger    . hoogle is yoru friend :)
14:41:18 <lambdabot>  [50.5,51.0,51.5,52.0,52.5]
14:41:39 <njbartlett> Or even n % 1  ;-)
14:41:42 <Wild_Cat> fuzan: introspection facilities, mostly. Automatic memory management, too (although I understand you can graft a GC on top of it, though the specifics are unknown to me).
14:41:44 <drigz> why is there no numConvert (Num a, Num b) => a -> b?
14:42:10 <DRMacIver> That would be problematic at best.
14:42:22 <Wild_Cat> and the use of include files instead of a proper module system bothers me.
14:42:27 <mauke> drigz: how do you convert pi :+ 2 to Rational?
14:42:27 <DRMacIver> It would make defining new instances of Num a very unpleasant process.
14:42:31 <ddarius> It does have some introspection facilities, but neither GC nor introspection are aspects that I'd consider to be part of OO.
14:42:38 <fuzan> Wild_Cat: I havn't read that soustraps? guy's book yet, but I don't think that was the goal of C++ :)
14:43:12 <Wild_Cat> Stroustrup. I have that book. Still haven't gotten around to reading it.
14:43:30 <drigz> mauke: good point, thanks
14:43:30 <fuzan> I think it was ment only to be a superset of C. Not a _complete_ OO language.
14:44:06 <njbartlett> I read Stroustrup a long time ago. Before the STL existing. Most of the book was about how to implement a standard library for C++...
14:44:12 <fuzan> and it's stil C, which is what I think the goal was.
14:44:18 <njbartlett> Before the STL existed, even
14:45:27 <fuzan> Wild_Cat: Bohem's works well with C++, anyways ;)
14:45:32 <Wild_Cat> true story: about 10 years ago, after a few years spent on Casio graphing calculators (that being my *only* programming experience), I decided I needed to learn to program on my computer. Off to the library I went... And bought Stroustrup's "The C++ Programming Language".
14:45:55 <earthy> which version? :)
14:46:18 <Wild_Cat> second edition, French translation.
14:46:27 * earthy owns the third
14:46:31 <earthy> big difference. ;)
14:47:00 <earthy> never read it though :)
14:47:08 <earthy> (not completely, at least)
14:47:20 <Wild_Cat> I went back to my calculators.
14:48:05 <Wild_Cat> to this day, I still haven't been able to finish reading it.
14:48:28 <dcoutts> how on earth am I supposed to diagnose linker problems on OSX when I don't have access or any experience with OSX?
14:48:31 <dcoutts> grr
14:49:03 <mauke> crystal ball/meth
14:50:07 <Wild_Cat> ssh into the box?
14:50:30 <DRMacIver> Hm. I always feel vaguely out of my depth when people say what they were programming 10 years ago.
14:50:54 * edwinb thinks
14:51:06 <edwinb> Modula 2 and gofer, disturbingly
14:51:06 * ddarius is coming up on programming 10 years ago.  A few more months I think.
14:51:16 <Wild_Cat> I was programming *Casio calculators* 10 years ago.
14:51:19 <DRMacIver> Heh
14:51:30 * ddarius was programming QBASIC.
14:51:35 <DRMacIver> Hm
14:51:36 <dcoutts> Wild_Cat: heh, I don't think the people sending me bug reports would also include an ssh account on their box :-)
14:51:36 <Wild_Cat> the little machines were very fun to use, but I can't believe I could put up with their language.
14:51:39 <njbartlett> Oh god, when did the Spectrum 48k come out? That's when I started programming!
14:51:54 <DRMacIver> Actually I guess I started learning ML about 5 years ago, so I guess I'm pushing a non-trivial amount of programming history.
14:52:07 <DRMacIver> But I didn't really do anything serious until about a year and a half ago. :-0
14:52:08 <DRMacIver> )
14:52:15 <olsner> there was someone here last week who was coming up to 23-25 years of programming
14:52:22 <Wild_Cat> I mean, on the FX7900 I started with, the only control structures available were a one-line if-then and the goto statement.
14:52:59 <sorear> I've been programming for about 8 years.
14:53:00 <Wild_Cat> that's right folks, no for or while loops, goto was the only way to branch. With only 10 possible destinations in your program.
14:53:02 * sorear is 16
14:53:03 <edwinb> I wouldn't be surprised if several here had been programming one way or another for 23 years...
14:53:15 * ddarius started programming Haskell about five years ago.
14:53:31 <sorear> Discovered haskell about a year ago.
14:53:43 <fuzan> i'm at about half a year :)
14:53:46 <Philippa> were you doing much coding before you did?
14:53:50 <sorear> been a member of the haskell community since ~Oct
14:53:55 * ddarius hasn't been programming for 23 years.
14:53:57 <ddarius> That's for sure..
14:54:04 <Philippa> I was mostly toying with gamedev in C at 16
14:54:08 * fuzan hasn't been alive that long.
14:54:15 <Wild_Cat> and of course, there was no concept of functions/procedures. Subprograms yes, but all variables (26 of them) were cross-program global (OS-global, in fact)
14:54:23 <shapr> edwinb: 24 years
14:54:31 <edwinb> there you go ;)
14:54:33 <ddarius> At 16 I had been programming in C++ for like a year or two.
14:54:34 <Philippa> I've been alive that long, but I think it would've broken records if I'd been coding at the time
14:54:40 <fuzan> shapr: old nerds exist too, it appears.
14:54:49 <shapr> fuzan: Yeah, and we get the young chicks ;-)
14:54:58 <fuzan> ;)
14:55:13 <edwinb> young chicks can't resist all these old Haskell geeks
14:55:15 <Philippa> that's just because they're all straight. Lucky bastard :-)
14:55:15 <sorear> allbery_b is really old... I forget exactly how much
14:55:34 <edwinb> I'm fighting them off all the time
14:55:37 <Wild_Cat> "wanna get higher-order with me, baby?"
14:57:03 <njbartlett> Remember to do everything inside the "safe sex" monad
14:57:38 * Philippa suspects njbartlett missed the unsafeHead discussion
14:57:47 <fuzan> those two are a little bit too nerdy to never use that monad.
14:57:48 <njbartlett> Evidently!
14:58:08 <Wild_Cat> "unsafeHead"? Now there's a mental image I didn't really need.
14:58:33 <wolverian> oh, wow, the vim toolbox looks a lot better than what I saw last time I googled for 'haskell vim'
14:58:34 <wchogg> Wild_Cat:It involves juggling chainsaws at the same time.
14:58:41 <sorear> Huh.  I wonder where *that* memory came from.
14:58:58 <sorear> grepping the logs I get 43 ... not what I'd call "really old"
15:00:00 <nominolo> Do haskell girls like bytestrings?
15:00:48 <Philippa> I've never actually used the lib myself. I should do sometimes
15:00:56 <Philippa> Any punning answers belong in #haskell-blah though...
15:00:56 <Wild_Cat> you're missing the critical issue there: do they like lazy boys?
15:01:24 <Philippa> I have one ex who only evaluated to boy when sufficiently forced...
15:01:26 <nominolo> it sounds somewhat edible
15:02:11 <Philippa> somehow I suspect that's not what Wild_Cat has in mind though
15:02:47 <nominolo> Wild_Cat: no, it's demand-driven behaviour
15:02:48 <Wild_Cat> an ex-girlfriend who evaluates to boy? Not really.
15:03:26 <Baughn> It's okay if you stay lazy
15:03:28 <mahogny_> sounds like an unsafe cast :o
15:03:31 <sorear> 6.11.15 btw
15:05:15 <fuzan> tell's supposed to print stuff out, right?
15:05:37 <nominolo> @tell foo
15:05:38 <lambdabot> Consider it noted.
15:05:43 <Baughn> fuzan: All commands are acknowledged
15:06:24 <fuzan>  > tell "haha"
15:06:36 <fuzan> well, while in a WriterT String
15:06:46 <ddarius> fuzan: No.
15:07:08 <nominolo> @msg #haskell Hoho
15:07:09 <lambdabot> Not enough privileges
15:07:13 <fuzan> ddarius: where does the result of tell disspear to?
15:07:24 <nominolo> what privileges do you need?
15:07:31 <ddarius> :t runWriter
15:07:34 <lambdabot> forall w a. Writer w a -> (a, w)
15:07:39 <sorear> @msg nominolo Hi.
15:07:40 <Baughn> nominolo: There are only two privilege levels
15:07:51 <sorear> Baughn: there are three now.
15:07:58 <sorear> @ignore + Baughn
15:08:13 <Baughn> > um..
15:08:27 <sorear> @ignore - Baughn
15:08:49 <Baughn> Can you be admin /and/ ignore?
15:08:55 <fuzan> haha
15:08:57 <fuzan> interesting case :)
15:09:01 <fuzan> bound to crash lambdabot.
15:09:08 <Baughn> If so, I hold that ignore is not an actual privilege level. ;)
15:09:54 <Baughn> sorear: Won't you try it?
15:09:55 <sorear> Baughn: No, they are mutually exclusive
15:10:00 <sorear> @ignore + sorear
15:10:03 <sorear> > 2 + 2
15:10:05 <lambdabot>  4
15:10:14 <sorear> @ignore - sorear
15:10:23 <Baughn> That lagged. For a moment I hoped it had ignored you.
15:10:23 <nominolo> bah.
15:10:32 <nominolo> sorear you're using ERC, right?
15:10:45 <sorear> nominolo: No, I switched to irssi yesterday.
15:11:08 <nominolo> hehe, i switched the other way round ..
15:11:26 <ddarius> Bodes well for both of you.
15:11:46 <fuzan> the balance has been reserved.
15:11:56 <sioraiocht> sooo, what's a .hi file from GHC contain?
15:12:01 <nominolo> anyways, do you happen to know why ERC disconnects me when i close the frame but still have another frame open?
15:12:02 <fuzan> conserved ? i'm pooped.
15:12:05 <ddarius> Open it.
15:12:44 <sorear> sioraiocht: ghc --show-iface filename
15:12:48 <Baughn> sioraiocht: Stuff that really should be in the .o but isn't.
15:13:05 <sioraiocht> so more object code?
15:13:26 <sorear> sioraiocht: Types, mostly.
15:13:27 <Baughn> Meta-data for the object code, mostly. Also code for inlinable functions, that sort of thing.
15:13:44 <sorear> Instances
15:13:59 <Baughn> It could perfectly well be in the .o; I'm sure there's a very good reason it isn't, but probably it's along the lines of "some linker somewhere chokes on it"
15:14:02 <ddarius> It's essentially the same thing as a header file fro C/C++.
15:14:28 <sorear> Baughn: More like there's no standard way to put extra information in .o files.
15:15:10 <Baughn> sorear: If it's ELF, it should be possible to invent one
15:15:17 <sorear> Baughn: As usual, every maintained flavor of UNIX has standardized on ELF, but Windows does something completely different
15:15:26 <sorear> anyone know where OSX stands?
15:15:38 <isaacd> Mach-O
15:16:07 <sorear> isaacd: IIRC that's the name of the kernel, we're talking about object file formats
15:16:16 * sorear suspects he is about to be wrong
15:16:20 <Baughn> sorear: The file format is called mach-o
15:16:29 <isaacd> Darwin is the kernel, which uses Mach-O object format even in the free versions
15:16:29 <sorear> Oh.  OK.
15:16:40 <Baughn> And it's a /mess/
15:16:42 <isaacd> er, QNX
15:16:44 <isaacd> ?
15:16:47 <isaacd> whatever
15:16:54 <isaacd> oops
15:17:12 <Baughn> Though I wonder if GHC couldn't use ELF format for the .os and libraries regardless of what the OS otherwise uses. Is it commonly linked with other software like that?
15:18:27 <sorear> Baughn: Yes, for FFI exports.  I suppose we could make a link-library subcomment for GHC that would produce native-format objects?
15:18:53 <sorear> there are issues re. when to strip and dynamic finding
15:19:17 <sorear> but it's similar enough to the situation of names in dso's that I'm sure it's soluble
15:19:17 <allbery_b> <sorear> allbery_b is really old... I forget exactly how much
15:19:19 <allbery_b> 42
15:19:23 <Baughn> It's very tempting, but part of why I like GHC is that it's fairly interoperable with other-languaged code
15:19:35 <sorear> 14:58 < sorear> grepping the logs I get 43 ... not what I'd call "really old"
15:19:37 <Baughn> Having .hi is a small price to pay for that
15:19:37 <allbery_b> ...and about the mean on #lopsa
15:19:46 <allbery_b> almost 43, yeh
15:19:49 <DRMacIver> 42? That's practically prehistoric!
15:19:58 <DRMacIver> *cough*
15:20:02 * DRMacIver looks innocent
15:20:11 <Baughn> sorear: And strip.. why would you /ever/ strip?
15:20:49 <sorear> Baughn: Because it takes a long time to slurp bits from ftp.us.debian.org
15:21:10 <sorear> Baughn: even with my (TV cable) pipe
15:21:20 <Baughn> sorear: Most of which isn't executable code
15:21:38 <sorear> Right, it's gzipped executable code. :)
15:21:51 <Baughn> It's gzipped data and small amounts of executable code. ;)
15:22:01 <sorear> size of gzipped data `isRoughlyProportionalTo` size of data
15:22:25 <Baughn> Of course
15:22:29 <sorear> besides, Data Is Code.  Code Is Data.
15:22:38 <sorear> i
15:22:45 <Baughn> The point is, executable code is a small percentage of an installed system. Stripping the code wouldn't shave much off that.
15:22:46 <Philippa> Baughn: I get 8 meg binaries when I build small apps on my Zaurus. My Zaurus only has 64 meg of RAM...
15:23:15 <Baughn> Philippa: Get a.. modern... that's not a computer, is it?
15:23:30 <Philippa> it is modern. It's also PDA sized :-)
15:23:31 <mux> it's some kind of neat ARM PDA.
15:23:38 <Baughn> Does GHC work on that?
15:23:41 <Philippa> yes
15:23:51 <Philippa> though there's only an unregisterised build available atm
15:23:53 <Baughn> Hmm. Okay, you're allowed to strip.
15:24:08 <Baughn> Those of us who use x86 are not. -_-
15:24:36 <mux> it's quite convenient to strip binaries even on x86, the size difference is large
15:24:46 <mux> even for very small applications
15:24:53 <Baughn> Even if it's 100%, that isn't worth it
15:25:02 <sorear> Baughn: I have a 4mhz z80 computer somewhere with <1M of ROM, does that count as x86?
15:25:05 <mux> I don't see why not
15:25:07 <Baughn> /usr/bin is 211M. /usr is 4G.
15:25:24 <mux> my /usr/bin is 26MB :-).
15:25:25 <sorear> Baughn: remember to count /usr/lib and /usr/lib64
15:25:39 <sorear> (if you have it)
15:25:55 <DRMacIver> Hm. /usr clocks in at about 4G for me as well. I'm surprised it's so low.
15:26:31 <mux> Baughn: the problem isn't really disp space anyways
15:26:38 <mux> disk, rather
15:26:39 <Baughn> Righto, 1.2G code, then. (But /usr is actually 8G)
15:27:11 <pchiusano> hi
15:27:15 <sorear> hello
15:27:22 <pchiusano> hey sorear
15:27:37 <Baughn> mux: Exactly my point. Surely the debugging symbols aren't actually loaded into memory?
15:28:11 <mux> Baughn: I can't be 100% positive on this, but it's possible there is still some overhead on loading time, but nowadays even that isn't really a problem I guess
15:28:22 <mux> it is more annoying when you think about binary packages
15:28:32 <mux> where a few megabytes difference is significant
15:28:42 <sorear> 15:20 < sorear> Baughn: Because it takes a long time to slurp bits from ftp.us.debian.org
15:29:11 * mux nods at sorear - I wasn't here when you said that
15:30:42 <pchiusano> in Haskell, can you do the equivalent of (cons a b) when b is not a list of a's?
15:31:01 <sorear> (,)
15:31:02 <Baughn> pchiusano: No, but you can create a type c that contains b /and/ a
15:31:06 <sorear> > (,) 1 2
15:31:08 <lambdabot>  (1,2)
15:31:38 <Baughn> Or use a tuple if you know how many there are, sure
15:32:06 <pchiusano> internally, is x:y:[] the same as (x, (y, []))
15:32:08 <pchiusano> ?
15:32:14 <Baughn> pchiusano: It is not.
15:32:28 <pchiusano> so each cons cell is not a tuple...
15:32:53 <kpreid> the difference is in the typing
15:33:45 <kpreid> data [a] = [] | a : [a] -- not actually legal syntax, but that's what the list type is
15:33:46 <pchiusano> ok
15:33:53 <Baughn> pchiusano: Haskell doesn't /have/ cons cells as such, though the implementation may. Creating a list via tuples runs into the problem that the type would vary depending on the length of the list.
15:34:01 <pchiusano> right
15:34:18 <kpreid> whereas tuples don't have the recursion in the data type
15:34:33 <Philippa> you can think of data constructors as being specific types for n-value cons cells
15:34:42 <Philippa> although that doesn't gain you much
15:35:07 <pchiusano> Baughn, can you explain 'Creating a list via tuples runs into...'
15:35:51 <Baughn> pchiusano: Think of how you'd do it. For a list of ints, for example..
15:36:08 <Baughn> pchiusano: The empty list is (). But what's the type of a cons cell containing one int plus the empty list?
15:36:28 <sorear> It's perfectly possible.
15:36:30 <pchiusano> (int, ()) ?
15:36:31 <DRMacIver> Hm
15:36:34 <kpreid> newtype List x = Either () (x, List x) -- here's a tuple-y list
15:36:42 <sorear> Oleg has a library of generic list functions for tuple chains.
15:36:46 <sorear> @where hlist
15:36:47 <lambdabot> http://homepages.cwi.nl/~ralf/HList
15:36:51 <Philippa> sorear: now is a bad time to introduce HList and relatives
15:37:24 <sorear> OK.
15:37:26 <Philippa> stick to H98 for the purposes of this discussion, it'll make everyone's life easier
15:37:28 <sorear> *backtrack*
15:37:35 <sorear> pchiusano: What do you want to do?
15:37:51 <Philippa> AFAICT, pchiusano is a lisper looking to understand haskell's basic datatypes...
15:38:08 <Philippa> and probably running into some dynamic vs static typing issues
15:38:24 <pchiusano> hehe
15:38:33 <Baughn> pchiusano: Does it help if I say that "List of x" is a basic, irreducible type constructor?
15:38:45 <Baughn> Even if kpreid just pointed out how you /could/ reduce it..
15:38:45 <Philippa> pchiusano: the type you give for 1:[] would be fine in lisp, but you can't use it in haskell for the reason Baughn just gave
15:39:04 <kpreid> It's not a type constructor.
15:39:06 <Philippa> (though as sorear mentioned, this is a white lie - there're ways given GHC's extensions to encode all kinds of complicated types)
15:39:32 <Baughn> kpreid: [] does not have kind * -> *?
15:39:34 <kbrooks> hey
15:39:35 <Philippa> kpreid: no, but List (or rather []) is and it's an understandable abuse of syntax
15:39:43 <sorear> One way to look at it is using a maybe chain.
15:39:45 <Philippa> Baughn: you applied it to x, "List of x"
15:39:48 <kpreid> Baughn: [x] does not have kind * -> *
15:40:00 <kbrooks> <ams> Who here understands haskell?
15:40:00 <kbrooks> <ams> import List(elemIndex)
15:40:00 <kbrooks> <ams> cipherText = "LUXDZNUAMNDODJUDTUZDGYQDLUXDGOJDCKDTKKJDOZ"
15:40:00 <kbrooks> <ams>
15:40:00 <kbrooks> <ams> shift i x = (cycle ['A'..'Z'])!!(maybe (error "Bad character " ++
15:40:01 <kbrooks> <ams> (show x)) (+i) (elemIndex x ['A'..'Z']))
15:40:03 <kbrooks> <ams> main = sequence_ (map (\i -> putStrLn $ map (shift i) cipherText)
15:40:05 <kbrooks> <ams> [0..25])
15:40:07 <pchiusano> it makes sense that the list type is basically primitive
15:40:14 <kbrooks> in #natter
15:40:14 <Baughn> kpreid: How should I have said it? "List of " sounds bad
15:40:19 <sorear> kbrooks: don't paste anything longer than 4 lines
15:40:26 <kbrooks> sorear, sorry
15:40:34 <sorear> use hpaste for hosting instead
15:40:36 <sorear> @paster
15:40:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:40:39 <Philippa> Baughn: "List", and then demonstrate its use in a type "List x"
15:40:39 * arjanoosting enjoyed reading about gnome-power-manager as well. It is indeed very ironic. Do we have an ITP for powertop yet?
15:40:42 <kbrooks> sorear, SORRY
15:40:57 <arjanoosting> argh. wrong channel again
15:41:03 <Baughn> Philippa: Sadly, that sounds like List is a type, not a type constructor. :'(
15:41:15 <Baughn> "\x -> List of x"?
15:41:16 <kbrooks> sorear, fine
15:41:43 <sorear> kbrooks: It's important to learn quickly - but don't feel bad, every second newbie makes that mistake
15:42:01 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1817
15:42:02 <Philippa> Baughn: "List is a fundamental type constructor, so you can't give a more precise type than 'List x' for 'List of values of type x'"
15:42:31 <sorear> So in Standard ML, we can treat list of a  as   Maybe (a, Maybe (a, Maybe (a, Maybe (....))))
15:42:33 <kbrooks> http://hpaste.org/1817 # could you explain this code for a person in #natter
15:42:38 <kpreid> pchiusano: the provided list type constructor is primitive, but you can define an exactly equivalent one yourself.
15:42:40 <Philippa> pchiusano: an important convention here - This is a constructor, that is a variable
15:42:51 <sorear> Haskell doesn't have infinite types, so we fake it using a constructor.
15:42:55 <kpreid> pchiusano: the only thing special about it is the syntax and the standardization.
15:43:00 <pchiusano> right
15:43:08 <Philippa> so List x is "list of some type, any type, which we'll call x", whereas List X would be a list of some specific type X
15:43:15 <pchiusano> the point is, the actual cons cells are not really exposed
15:43:28 <Philippa> what "actual cons cells"?
15:43:29 <mauke> what makes you think there are actual cons cells?
15:43:30 <kpreid> pchiusano: sure they are, but as *values*, never as *types*
15:43:37 <Philippa> if it's built with :, it's as close to a cons cell as you'll find
15:43:40 <pchiusano> er, they are, but they have a specific type
15:43:46 <Philippa> enough so that we actually pronounce cons ':'
15:43:55 <Philippa> er, pronounce : "cons" even
15:43:59 <kbrooks> ping
15:44:00 <mauke> haha
15:44:07 <Baughn> pchiusano: It might use cdr coding internally, for all you know
15:44:08 <kbrooks> http://hpaste.org/1817 # could you explain this code for a person in #natter please
15:44:14 <sorear> kbrooks: That looks like it would crack a Caesar cipher.
15:44:25 <Philippa> pchiusano: yes, it's a strongly statically typed language so you don't get to frig with the implementation
15:44:40 <kbrooks> sorear, what does the shift func do?
15:44:51 <sorear> kbrooks: 'shift' is a generalized rot function, shift 13 "FOO" -> "SBB"
15:45:26 <mauke> doesn't it take a char?
15:45:31 <sorear> the right hand side uses a list as a lookup table, with some complication for error nicification, to turn E into 4 etc.
15:45:41 <pchiusano> Philippa - I think I understand - even if the implementation of lists internally used whatever, the typing of the (:) ctor prevents you from using it like a pair
15:45:42 <sorear> mauke: yes.
15:45:46 <drigz> there's a function that does elemIndex c ['A'..'Z'] for you, isn't there?
15:46:10 <mauke> @hoogle Char -> Int
15:46:10 <Philippa> pchiusano: right. The second parm is always of List type
15:46:10 <sorear> drigz: i'm afraid the best we have is fromEnum
15:46:11 <lambdabot> Char.digitToInt :: Char -> Int
15:46:11 <lambdabot> Char.ord :: Char -> Int
15:46:12 <kbrooks> drigz, i didnt write  it
15:46:18 <sorear> > fromEnum 'a'
15:46:18 <kbrooks> ams didn't either
15:46:20 <lambdabot>  97
15:46:21 <Philippa> so it's always [] or another cons
15:46:21 <mauke> > digitToInt 'A'
15:46:23 <lambdabot>  10
15:46:23 <drigz> kbrooks: i was just wondering
15:46:29 <drigz> > ord 'a'
15:46:31 <lambdabot>  97
15:46:41 <jbauman> > ord 'a' - 97
15:46:41 <drigz> i was thinking of digitToInt
15:46:42 <sorear> ord is just a crippled version of fromEnum
15:46:42 <lambdabot>  0
15:46:54 <drigz> @src ord
15:46:55 <lambdabot> Source not found. Are you on drugs?
15:47:08 <Philippa> if it helps any, you can implement a lisp ala McCarthy's original paper with an eval implementation and this datatype:
15:47:12 <sorear> ord = fromEnum :: Char -> Int
15:47:20 <Philippa> data SExp = Atom String | Cons SExp SExp
15:47:32 <Philippa> (feel free to swap String for another representation if you prefer - Integer, say)
15:47:51 * kpreid would use Unique
15:48:38 <pchiusano> hmm, what is Unique?
15:48:43 <Philippa> kpreid: as the parm for Atom? That gives you some excess hassle, as you need nil, lambda etc defined for the eval implementation
15:49:09 <kpreid> @docs Data.Unique
15:49:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Unique.html
15:49:41 <kpreid> Philippa: hm, yes
15:50:25 <Philippa> pchiusano: does seeing that SExp type help clarify anything? You can extend it further and turn it into the base of a more interesting lisp too - I think there're a few scheme-in-haskell implementations knocking about
15:50:29 <drigz> @source Data.Unique
15:50:30 <lambdabot> http://darcs.haskell.org/packages/base/Data/Unique.hs
15:50:42 <Rasmus1> is there a predefined way to get [1,2,3,4,5,6,7,8] => [[1,2],[3,4],[5,6],[7,8]] (like a reverse concat: ) ?
15:50:56 <sorear> No.
15:51:04 <Rasmus1> ok thank you
15:51:15 <pchiusano> Philippa, how do you represent Nil?
15:51:23 <pchiusano> or is that just a special symbol?
15:51:24 <sorear> Atom "nil"
15:51:29 <sorear> just like lisp does it :)
15:51:32 <pchiusano> ok
15:51:42 <sorear> scheme has nil as a separate type - lisp doesn't
15:51:57 <kpreid> hmmm?
15:52:18 <kpreid> assuming you mean Common Lisp (Scheme is a Lisp), *anything* has its own type
15:52:25 <kpreid> there's even a predefined type for nil: null
15:52:37 <kbrooks> ams says:
15:52:41 <kbrooks> <ams> I suppose it is some kind of if stamenet.
15:52:41 <kbrooks> <ams> From A to Z, and if if i is not in that, error.
15:52:41 <kbrooks> <ams> Else return the index in a to z of x.
15:52:47 <kbrooks> is he right? ;-)
15:52:50 <sorear> I mean McCarthy lisp, the only one I have a book on :)
15:52:58 <sorear> kbrooks: yeah
15:53:23 <Philippa> sorear: it'd be unwise to make statements about lisp in general (or to put it another way, lisp without any qualifier) on that basis
15:53:44 <kbrooks> sorear, thanks for the help
15:53:49 <Philippa> as almost always it'll be read as either a statement about all lisps or a statement about Common Lisp
15:54:09 <sorear> ah ok.
15:54:14 * sorear isn't an active lisper
15:54:18 <nominolo> > map (take 2) $ tails [1..8]
15:54:24 <Philippa> I'm not, but I know that much! :-)
15:54:26 <lambdabot>  [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8],[]]
15:54:32 <kbrooks> what is $ ?
15:54:41 <DRMacIver> Function application
15:54:43 <nominolo> kbrooks: same as ( ... )
15:54:46 <int-e> @src ($)
15:54:46 <DRMacIver> But with a low precedence.
15:54:46 <lambdabot> f $ x = f x
15:54:57 <kbrooks> ah
15:54:59 <sorear> kbrooks: one of the few things in haskell you can call a cute hack
15:55:03 <nominolo> kbrooks: you use it to avoid ( .. ( .. ))
15:55:13 <drigz> > takeWhile (not.null) $ iterate (take 2) [1..8]
15:55:14 <lambdabot>  [[1,2,3,4,5,6,7,8],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,...
15:55:23 <int-e> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1..8]
15:55:24 <lambdabot>  [[1,2],[3,4],[5,6],[7,8]]
15:55:28 <drigz> god, that went wrong :p
15:55:31 <sorear> kbrooks: a b $ c d parses as ($) (a b) (c d)  is equivalent to  a b (c d)
15:55:46 <sorear> kbrooks: so it's like parens, but prettier and more error prone
15:55:54 <Tchakkazulu> ($) = id ;)
15:56:04 <Baughn> > map ($ 4)  [+2, +3, *2]
15:56:04 <lambdabot>  Parse error
15:56:12 <Baughn> > map ($ 4)  [(+2), (+3), (*2)]
15:56:14 <lambdabot>  [6,7,8]
15:56:17 <DRMacIver> I'm still unconvinced that $ is more readable than appropriate use of parentheses
15:56:29 <kbrooks> sequence_ (map (\i -> ... [0..25]) # what does sequence_ do, and the first map?
15:56:47 <kbrooks> oh
15:56:49 <kbrooks> doh
15:56:54 <kbrooks> i missed the 0..25
15:56:56 <DRMacIver> (Sometimes it is, but generally only in cases where the parentheses aren't especially hard to read either)
15:57:00 <int-e> kbrooks: should be mapM_ though
15:57:14 <Baughn> DRMacIver: Sure, but how do you do my last map without ($)?
15:57:23 <kbrooks> ok, so i got the first map. and sequence_ ?
15:57:36 <kpreid> kbrooks: http://haskell.org/hoogle/ can find you links to documentation
15:57:37 <lambdabot> Title: Hoogle
15:57:40 <DRMacIver> Baughn: Oh, absolutely. $ is a very useful operator to have. I just don't think its use as a bracket avoidance tool improves readability.
15:57:42 <kpreid> just put in any of those function names
15:57:56 <Tchakkazulu> (\f -> f 4), but yeah, that's ugly :P
15:58:04 <int-e> kbrooks: sequence_ takes a list of actions (in a monad) and executes them - well - in sequence.
15:58:04 <nominolo> > (flip id 4) (+5)
15:58:06 <lambdabot>  9
15:58:14 <Baughn> DRMacIver: I use it for pipes. There, it's just as readable as | usually is.
15:58:27 <DRMacIver> Fair enough.
15:58:44 <int-e> kbrooks: so sequence_ [a,b,c] is a >> b >> c >> return ()
15:58:45 <Tchakkazulu> I find that $ works well with wxHaskell's layout combinators.
15:58:54 <DRMacIver> I guess I should qualify my previous statement with "in most of the cases in which it is used"
15:59:00 <DRMacIver> I'm sure there are cases where it's more readable. :)
15:59:24 <drigz> DRMacIver: it's nice at the end of big function pipelines, it looks very unixy
15:59:39 <int-e> Baughn: flip id ;)
15:59:40 <DRMacIver> Mm. Maybe. :)
16:00:13 <DRMacIver> Hm
16:00:29 <kbrooks> int-e, OK.
16:00:30 <int-e> DRMacIver: $ is nice if you have a last argument that spans several lines.  return $ \x -> ... reads nicer than return (\x -> ...) if the ) is somewhere else completely
16:00:46 <DRMacIver> Ok, yeah. That does seem a good use.
16:01:15 <mauke> .oO( runST :( )
16:01:22 <DRMacIver> Even if I do like a nigh lispy level of bracketing. ;)
16:02:08 <int-e> mauke: oh yes. if only it worked.
16:02:42 <DRMacIver> What's wrong with runST?
16:02:55 <int-e> it has a rank 2 type.
16:03:04 <int-e> which doesn't work well with $
16:03:08 <DRMacIver> Ah
16:03:35 <int-e> @type Control.Monad.ST.runST
16:03:37 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
16:03:45 <int-e> @type (Control.Monad.ST.runST $)
16:03:47 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
16:03:53 <int-e> @version
16:03:53 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
16:03:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:03:54 * DRMacIver still doesn't understand what a rank 2 type is. :)
16:04:09 <mauke> DRMacIver: embedded forall
16:05:03 <sorear> mauke: what does .oO() stand for?
16:05:07 <DRMacIver> That doesn't really tell me a lot though. :)
16:05:11 <DRMacIver> sorear: It's a thought bubble
16:05:22 <int-e> @type Control.Monad.ST.runST $ Data.STRef.newSTRef 0 >> return ()
16:05:24 <lambdabot>     Couldn't match expected type `forall s. GHC.ST.ST s a'
16:05:24 <lambdabot>            against inferred type `GHC.ST.ST s ()'
16:05:35 <int-e> anyway. this doesn't type check; with () instead of $ it does.
16:06:33 <sorear> int-e: I saw your patch a week or so ago to lambdabot's online.rc, adding #ai
16:06:55 <sorear> int-e: it can't work - lambdabot is limited to 10 channels, and is maxed out
16:07:22 <DRMacIver> Why is lambdabot limited to 10 channels?
16:07:54 <sorear> DRMacIver: Fixed size buffers in hyperion, I guess
16:08:08 <Tchakkazulu> In lambdabot's /whois, I count 11 channels.
16:08:16 <sorear> hyperion being the true name of freenode.net's ircd
16:08:17 <DRMacIver> hyperion?
16:08:20 <DRMacIver> Ah
16:08:33 <int-e> sorear: Oh, dons did apply that?  I had almost forgotten about this. It wasn't me who wanted lambdabot on #ai, hmm. who did, dmhouse?
16:08:34 <DRMacIver> So it's a freenode rather than lambdabot limitation?
16:08:36 <Tchakkazulu> But yeah, still an upper limit, I guess.
16:08:38 <EvilTerran> is the monadic (no pattern match => fail) a feature of the desugaring of do{}, or something else?
16:08:49 <sorear> EvilTerran: do{}
16:08:56 * sorear incites Cale
16:08:58 <EvilTerran> i thought so. thanks.
16:09:30 <int-e> sorear: the real point of the patch was the 'friendly' ignore feature.
16:10:28 <kpreid> er, freenode's limit is 20 channels
16:10:43 <jcreigh> what? There's a limit?
16:11:05 <Cale> heh
16:11:08 <EvilTerran> ... is there a trick to making a nice unfoldr function with the maybe monad?
16:11:22 <Cale> EvilTerran: yeah, I think that the translation of do in that respect is a wart
16:11:28 <EvilTerran> > unfoldr (\xs -> do x:y:rest <- return xs; return ((x,y), rest)) $ [1..20]
16:11:29 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20)]
16:11:39 <EvilTerran> being an example of what i've currently got
16:12:22 <EvilTerran> the "\xs -> do x:y:rest <- return xs" bit strikes me as unduly verbose
16:12:50 <yaxu> gah, i was really pleased with the simplicity of this haskell function, but have been spending the last half hour trying to remove a few more characters
16:13:13 <jcreigh> so if I say foo >>= (\(1, x) -> return (2, x)), that's different than (1, x) <- foo; return (2, x)? (ie, the former will using monadic "fail" on pattern match failure, whereas the latter will throw an exception?)
16:13:29 <DRMacIver> yaxu: Bad idea :)
16:13:38 <Cale> jcreigh: yes
16:13:40 * EvilTerran is thinking it'd be nice if you could just say unfoldr (\x:y:rest -> return ((x,y), rest) and then it could DWIM
16:13:40 <jcreigh> err, swap former and latter.
16:13:57 <int-e> jcreigh: right
16:14:18 <Philippa> yaxu: congratulations, you've become addicted to pointless refactoring!
16:14:26 <Cale> It would be nice if do-notation desugared to use mzero instead of fail with refutable patterns.
16:14:33 <ddarius> Indeed.
16:14:35 <EvilTerran> jcreigh, the latter's actually foo >>= (\arg -> case arg of (1,x) -> return (2,x); _ -> fail)
16:14:51 <Cale> It would also be nice if MonadZero was separated out of MonadPlus again
16:14:51 <EvilTerran> if i understand right
16:15:21 <kpreid> Cale: I'd rather see fail moved to MonadZero. Messages are nice.
16:15:32 <DRMacIver> Cale: Why were they combined?
16:15:56 <ddarius> kpreid: Then you use MonadError.
16:16:12 <int-e> I like being able to write  [x] <- getArgs in IO ;)
16:16:15 <kpreid> Okay, scratch the "move" part then
16:16:29 <Cale> They decided to remove monad comprehensions because the error messages were confusing to beginners. Then they reasoned that since they didn't have monad comprehensions, they could specialise a whole bunch of other stuff back to lists.
16:16:56 <Cale> Then they noticed that every existing instance of MonadZero was a MonadPlus in the standard libraries, so they joined them.
16:17:04 <DRMacIver> Hm.
16:17:08 <Cale> These were all mistakes as far as I'm concerned.
16:17:29 <EvilTerran> monad comprehensions? as in, make [ foo bar | bar <- baz ] equivalent to do { bar <- baz; return (foo bar) } ?
16:17:38 <ddarius> Yes.
16:17:50 <Cale> Oh right, and then since MonadZero had been joined into MonadPlus, they noticed that the translation of the do-syntax no longer worked.
16:18:00 <EvilTerran> i was thinking about that just a few days ago; that it sounded like an interesting idea...
16:18:00 <Cale> So they added fail.
16:18:22 <EvilTerran> Cale, this all seems rather backsliding
16:18:26 <int-e> and all was well until someone decided to make Either e a Monad :-P
16:18:34 <ddarius> Is there a Haskell' ticket about getting rid of faiL
16:18:36 <DRMacIver> I'm indifferent to comprehensions. I agree that the rest sound like mistakes. :)
16:18:46 <Cale> ddarius: I don't know, but there really ought to be.
16:18:49 <int-e> (this is so far the only point I've seen where it actually hurts me)
16:19:40 <jcreigh> The "confusing error message" rationale seems to ring hallow now, but as I understand it, H98 was when people thought Haskell was going to be mostly an academic/teaching language.
16:20:15 <Cale> Another mistake that is now almost impossible to fix is that ($) and ($!) would be better off with the opposite associativity. (To match the associativity of function application)
16:20:16 <ddarius> jcreigh: The very first paragraph of the Report says that it is NOT intended to be purely an academic/teaching language.
16:20:23 <jcreigh> ddarius: oh
16:20:27 <jcreigh> well, never mind then.
16:20:29 <sorear> "ring hallow"?
16:20:46 <mauke> hollow?
16:20:47 <Cale> jcreigh: You're right that's where the sentiment came from though.
16:20:51 <jcreigh> sorear: you know what I mean. :)
16:20:52 <DRMacIver> I'm mainly skeptical as to whether the language needs yet another way of writing monads. :)
16:21:00 <Cale> Writing monadic computations
16:21:10 <DRMacIver> True.
16:21:12 <sorear> @remember Philippa congratulations, you've become addicted to pointless refactoring!
16:21:12 <lambdabot> Done.
16:21:18 <Cale> It would be nice because it emphasises the container analogy.
16:21:26 <Cale> (when you want that emphasis)
16:21:33 <DRMacIver> I suppose so, yes.
16:22:47 <ddarius> List comprehensions have a few perks that do-notation lacks.
16:23:10 <EvilTerran> the conditional aspect is nice
16:23:36 <EvilTerran> altho that would require MonadZero if fail were to be removed from Monad again
16:24:00 <EvilTerran> actually, would monad comprehensions always be MonadPlus?
16:24:03 <tom___> Does anyone have any idea why my haskell program might be suddenly exiting with "runhaskell: waitForProcess: interrupted (Interrupted system call)"?
16:24:20 <ddarius> EvilTerran: They're merely MonadZeroes.
16:24:36 * EvilTerran thinks... yes, i see.
16:24:53 <tom___> Sorry, that's very vague. The program is a multithreaded tcp server using STM and that happens sometimes when a client disconnects
16:25:56 <DRMacIver> Is Haskell' ever going to move out of vapourware? :)
16:25:57 <tom___> It just seems to leave no trace of why it might have crashes, is there some way to get a ghc compiled program to spit out some debug info when it dies?
16:26:32 <sorear> DRMacIver: It's only vaporware if they haven't set a deadline yet.
16:26:46 <mauke> tom___: you could strace it
16:27:31 <sorear> And haskell' does have a deadline - November 2006  :)
16:27:47 <jcreigh> DRMacIver: GHC! :)
16:27:54 <sorear> you would expect that at the very least they would have pushed it back.
16:28:36 <DRMacIver> sorear: Oh, have they set a deadline? :)
16:29:10 <tom___> mauke: Thanks, I'll go read the man page on strace
16:29:57 <mauke> looks like you're receiving a signal
16:30:20 <DRMacIver> jcreigh: GHC isn't so much Haskell' as Haskell + fiddly bits. ;)
16:30:39 <tom___> write(4, "\0", 1)                       = -1 EPIPE (Broken pipe)
16:30:41 <tom___> --- SIGPIPE (Broken pipe) @ 0 (0) ---
16:30:41 <DRMacIver> (Rather interesting fiddly bits admittedly)
16:30:43 <tom___> +++ killed by SIGPIPE +++
16:31:05 <EvilTerran> it looks like the thing i was thinking of wrt making unfoldr nicer is http://hackage.haskell.org/trac/haskell-prime/ticket/114
16:31:06 <lambdabot> Title: #114 (introduce lambda-match (explicit match failure and fall-through)) - Haskel ...
16:31:08 <mauke> ah, SIGPIPE
16:31:29 <mauke> you should probably just ignore it
16:31:44 <tom___> How is it that that is killing the whole process though? I've got everything wrapped in `finally`s
16:31:54 <mauke> it's a signal, not an exception
16:32:19 <tom___> Ah, is this to do with the way I've opened the sockets then?
16:32:30 <mauke> no, this is just sockets/pipes
16:32:32 <tom___> How would I ignore it?
16:32:53 <sorear> @docs System.Posix.Signals
16:32:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Posix-Signals.html
16:33:46 <tom___> Do I really have to use Posix stuff to make a tcp server work? That can't be very portable...
16:33:57 <int-e> sorear: hyperion has a user mode (+u) that allows joining up to 100 (by default) channels. I assume freenode staffers can set that somehow but I don't know how it works in detail.
16:34:56 <mauke> why did they call SIGPIPE openEndedPipe?
16:35:25 <sorear> mauke: it's called a bad analogy
16:35:40 <mauke> anyway, installHandler openEndedPipe Ignore
16:35:46 <sorear> mauke: there is nobody reading the pipe, so the data can't go anywhere
16:36:06 <sorear> mauke: contrary to the signal name, it doesn't spray all over some innocent process :)
16:36:32 <olsner> it only sprays all over your own process
16:36:42 <olsner> killing it with very sharp bits
16:38:23 <tom___> Thanks for the help, it's working now (put in "installHandler sigPIPE Ignore Nothing" as suggested)
16:38:54 <drigz> this feels like an abuse of the function pipelining style:
16:39:04 <drigz> print . (subtract 1) . (*2) . length . ...
16:40:09 <kpreid> drigz: I disagree
16:40:15 <ddarius> What is the purpose of the code?
16:40:34 <drigz> kpreid: really? it seems like an application for the infix arithmetic style that is so popular
16:41:15 <kpreid> hm....maybe
16:41:40 <kpreid> print . (\xs -> length xs - 2 * 1) . ...
16:41:45 * ddarius doesn't really like the syntax for lambdas.
16:41:54 <kpreid> I'm not sure whether that's serious...
16:42:40 <wolverian> I think it's easy to be too scared of syntax. this isn't scheme.
16:42:41 <int-e> print . lengthTimes2Minus1 . ... where lengthTimes2Minus1 xs = length xs * 2 - 1 ;-)
16:42:55 <olsner> print . (\x -> 2*x-1) . length
16:42:58 <mux> > filter isAlpha . map chr $ [1..255]
16:43:03 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
16:43:25 <mauke> print . pred . sum . (>> [2])
16:43:35 <mux> looks like a bug in isAlpha to me
16:43:47 <ddarius> @src isAlpha
16:43:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:44:01 <mux> > ord 'z'
16:44:02 <lambdabot>  122
16:44:10 <olsner> > [1,2,3,4] >> [2]
16:44:11 <mux> > map chr [122..255]
16:44:13 <lambdabot>  [2,2,2,2]
16:44:13 <lambdabot>  "z{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\1...
16:44:21 <int-e> > generalCategory '\170'
16:44:22 <lambdabot>  LowercaseLetter
16:44:25 <mux> > isAlpha '{'
16:44:25 <mauke> mux: apparently it thinks ordinal indicators are letters
16:44:27 <lambdabot>  False
16:44:49 <mux> mauke: ordinal indicators?
16:45:01 <mauke> U+00AA (0xc2 0xaa): FEMININE ORDINAL INDICATOR []
16:45:17 <mux> hmm, doesn't seem right
16:45:22 <int-e> probably uses latin1 (the 128 ... 255 range of unicode)
16:45:26 <mauke> why? it looks like an a
16:45:29 <drigz> @source Data.Char
16:45:29 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
16:45:39 <mauke> the masculine indicator looks like an o
16:45:40 <mux> well in any case, isAlpha should be locale sensitive
16:45:43 <kpreid> int-e: uses Unicode, not Latin-1
16:45:45 <mauke> and the others are accented letters
16:45:48 <int-e> generalCategory c = toEnum $ fromIntegral $ wgencat $ fromIntegral $ ord c
16:46:11 <int-e> and wgencat is in C land (WCsubst.h)
16:46:14 <int-e> (u_gencat)
16:46:40 <mux> I'll need to check the standard just to be sure
16:46:44 <int-e> kpreid: that's what I meant. it matches latin 1 though, for all I know.
16:48:17 <edwardk> @where harpy
16:48:18 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
16:49:43 <fax> helo
16:49:48 <fax> I mean hello
16:50:00 <sorear> hello
16:50:02 <sorear> ehlo
16:50:14 <fax> :p
16:50:30 <fax> I was wondering about monads, right
16:50:49 <fax> hm well in particular, if it would be applicable to a specific problem
16:51:08 <fax> If you had a LOGO interpreter in haskell,
16:51:12 <kpreid> int-e: yes, latin-1 is a subset of unicode (considering the numeric values)
16:51:19 <fax> theres commands like FD 10, which moves it forward 10
16:51:38 <fax> right now the whole program is evaluated in one step
16:52:27 <fax> itd be pretty straightforward in scheme with call/cc to change eval into a new function which returns a closure which would evaluate as much code as required to move the turtle 3 px each time for example
16:52:39 <fax> but would you be able to do this in haskell by writing a custom monad?
16:52:51 <sorear> Nah, just use callCC
16:52:58 <fax> aw :(
16:52:59 <sorear> @type Control.Monad.Cont.callCC
16:53:02 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:53:10 <fax> oh so callcc IS a monad?: D
16:53:11 <sorear> you can write it yourself if you want ;)
16:53:16 <sorear> Cont!
16:53:22 <fax> @src Control.Monad.Cont.callCC
16:53:23 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:53:33 <sorear> @src callCC
16:53:34 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:53:39 <fax> ;(
16:53:40 <fax> hehe
16:53:42 <sorear> @source Control.Monad.Cont
16:53:42 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
16:54:02 <fax> ok well thank you I will try to do it then, but I feel like im just writing scheme in haskell
16:54:16 <sorear> the code is a bit more complicated than it needs to be, because of ContT
16:54:34 <sorear> fax: if you want to write a scheme in haskell, look into CPS
16:54:50 <fax> no, I really dont want to!
16:55:00 <fax> id love to write haskell in haskell, but I dont really know what haskell is yet
16:55:10 <sorear> oh. :)
16:55:18 <fax> ill learn, someday though
16:55:27 <shapr> Monads are pretty easy, would you like a short intro?
16:55:32 <mauke> yeah, starting with Cont is a good idea
16:55:35 <mauke> not
16:55:43 <fax> shapr: certainly
16:55:43 <sorear> it's certainly possible to have a Gen monad
16:55:56 <sorear> newtype Gen t a = Gen (Cont [t] a)
16:56:01 <sorear> + deriving Monad
16:56:02 <fax> I already know that monads aer like nuclear waste in a spacesuit & a bucket of apples in the ocean
16:56:03 <fax> though
16:56:05 <shapr> Oh wait, you're specifically interested in monads as they apply to modular interpreters?
16:56:08 <shapr> fax: haha
16:56:08 <fax> Gen monad?
16:56:11 <sorear> yield :: t -> Gen t ()
16:56:19 <sorear> yield t = Cont (t:)
16:56:26 <sorear> yield t = Gen (Cont (t:))
16:56:35 <sorear> runGen :: Gen t a -> [t]
16:56:36 <mauke> http://sigfpe.blogspot.com/2007/04/trivial-monad.html
16:56:38 <lambdabot> Title: A Neighborhood of Infinity: The Trivial Monad
16:56:41 <kpreid> fax: why do you think implementing Logo needs continuations? do you want to 'interrupt' it at each drawing operation?
16:56:44 <sorear> runGen (Gen (Cont f)) = f []
16:56:53 <shapr> fax: This is specifically on that topic if that's what you want - http://citeseer.ist.psu.edu/steele94building.html
16:56:54 <Sgeo> What's a Continuation?
16:56:55 <lambdabot> Title: Building Interpreters by Composing Monads - Steele (ResearchIndex)
16:57:02 <fax> kpreid: I want my turtle to move at a set speed, instead of being able to draw the entire picture in 1 frame
16:57:18 <ddarius> @google Modular Interpreters Monad Transformers
16:57:20 <lambdabot> http://citeseer.ist.psu.edu/liang95monad.html
16:57:20 <lambdabot> Title: Monad Transformers and Modular Interpreters - Liang, Hudak, Jones (ResearchIndex ...
16:57:24 <kpreid> fax: well...
16:57:24 <mauke> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
16:57:27 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
16:57:28 <fax> Sgeo: its somthing like you can pause a computation and resume it, via making a closure of that
16:57:39 <shapr> Yeah, that "You could have invented monads" is a really good thing to read first!
16:57:41 <ddarius> Sgeo: You want a Resumption Monad.
16:57:43 <fax> kpreid: I could mess up my eval() lots, but I think callcc is more elegant
16:57:51 <shapr> Unlike my Presumption monad...
16:57:54 <fax> kpreid: thing is I dont know how a real haskell programmer would do this
16:58:04 <kpreid> fax: you could have your interpreter generate a result list of drawing commands, then process the list
16:58:18 <kpreid> fax: might even be able to make it lazy
16:58:24 <fax> ooh nice idea
16:58:34 <ddarius> I would use a Resumption monad which is implementable with continuations, but those are overkill in this case in my opinion.
16:58:45 <kpreid> hmm
16:59:17 * sorear likes kpreid's idea far better than his own
17:01:20 <kpreid> sadly, the Writer monad is not sufficiently lazy for that to be efficient
17:01:23 <sorear> kpreid: why use writer at all?
17:01:39 <kpreid> well, whatever fits
17:01:41 <sorear> interpreter :: LogoProgram -> [DrawCommand]
17:01:43 <fax> ooh yeah thats a good point
17:01:48 <fax> I really want to make my thing lazy
17:01:51 <kpreid> I would expect evaluating Logo to fit a monad
17:01:57 <fax> if you did an infinite loop it would be nice
17:02:08 <kpreid> yes
17:02:41 <fax> you know what I will learn haskell a bit and rewrite from scratch because my code is terrible
17:02:46 <fax> I think thats a good idea?
17:02:52 <sorear> sure
17:03:56 <shapr> fax: Sounds like a fun idea to me.
17:04:42 <fax> oh yeah also what is some really well written haskell code that I could read?
17:05:01 <fax> I just see stuff like makeHuffmanTree in books, not so inspiring
17:05:38 <ddarius> data Resume a = Done a | Continue (Resume a)  instance Monad Resume where return = Done; Done a >>= f = f a; Continue m >>= f = Continue (m >>= f)
17:06:01 <ddarius> Now let's see if that is right...
17:07:17 <pchiusano> hey
17:07:36 <wchogg> fax:There's a lot of blogs on planet.haskell that have good example code (not mine though).  I think any of dons' posts with real code are useful to look at.
17:07:39 <pchiusano> I have a Parsec question:
17:08:10 <pchiusano> I have a grammar in which expr expr is function application (ala Haskell) and is left assoc
17:08:59 <fax> wchogg: cheers ill check it out once I read this monads tutorials
17:09:55 <ddarius> pause :: Resume a -> Resume a; pause (Done a) = Continue (Done a); pause m = m , or I guess just pause = Continue might work.
17:10:21 <pchiusano> but it just seems to loop forever if I code it as: application = do head <- expr; tail <- expr; return (some expr involving head/tail)
17:11:14 <ddarius> Of course, a monad transformer version would be rather more useful.
17:11:45 <Philippa> pchiusano: a paste from some of my own code (ignore the missing closing paren)
17:11:46 <Philippa> expression = (letBlock <|>
17:11:46 <Philippa>               lambdaAbstraction <|>
17:11:46 <Philippa>               (do es <- (many1 expression_)
17:11:46 <Philippa>                   return (foldl1 App es)
17:11:46 <Philippa>               )
17:12:30 <pchiusano> Philippa, hmm
17:12:31 <Philippa> expression_ is either a variable or an expression in parens
17:13:00 <beelsebob> dons: you anywhere about?
17:13:01 <pchiusano> I was thinking I needed to use chainl somehow
17:13:23 <Philippa> different kind of situation there
17:13:31 <Philippa> so you need to break the loop a different way
17:13:34 <olsner> I think you have to refactor the grammar to eliminate left-recursion
17:13:34 <pchiusano> basically, you're getting a list of all expressions (w/ many1 expression_), then doing a left fold
17:13:37 <beelsebob> anyone happen to know how to solve this... http://hpaste.org/1806
17:13:51 <Philippa> yeah, but the important bit is that it's expression_ rather than expression
17:14:03 <Philippa> you can't go from expression to expression without expecting to munch a paren on the way
17:14:24 <Philippa> (or the bulk of a let block, or a lambda)
17:14:42 <Philippa> to put it another way, the grammar isn't left-recursive, it doesn't do this:
17:14:50 <Philippa> e ::= ... | e ... | ...
17:15:10 <Philippa> otherwise it keeps going "to parse an e, I look for an e, which I do by looking for an e..."
17:15:15 <pchiusano> right
17:15:42 <pchiusano> okay, let me try that
17:15:46 <pchiusano> be back in a few min
17:15:52 <pchiusano> thx
17:16:35 <fax> is there a page like http://merd.sourceforge.net/pixel/language-study/syntax-across-languages-per-language/Haskell.html but better?
17:16:37 <lambdabot> Title: syntax in Haskell, http://tinyurl.com/ytwlbu
17:22:18 <fax> lift f * lift g   is equiv to   lift (f * lift g)   ?
17:23:17 <LoganCapaldo> fax: no if you are asking about operator precendence
17:23:18 <sorear> hehe.
17:23:28 <fax> :(
17:23:32 <LoganCapaldo> maybe yes if you are asking about the semantics of lift and * isn't multiplication
17:23:33 <fax> what does * mean in this context?
17:23:34 <sorear> I google for information on signed binary division
17:23:51 <sorear> very first relevant hit
17:23:53 <sorear>    The Haskell implementation of this algorithm is as follows:
17:23:55 <fax> its from http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
17:23:57 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
17:26:56 <fax> oh!  f * g = bind f . g
17:27:03 <fax> sorry, I didnt notice it before
17:28:44 <LoganCapaldo> fax: sorry I'm not done trying to skim thru
17:28:57 <LoganCapaldo> did you answr you question yourself?
17:29:08 <fax> I just noticed that * is used as shorthand for bind f . g
17:29:20 <fax> but before I didnt know what * was, and the syntax chart only says * is multiply
17:29:26 <fax> so yes, I found the answer
17:29:32 <LoganCapaldo> cool :)
17:31:27 <kpreid> Oh, I was wrong. The Writer monad *is* lazy enough.
17:31:46 <fax> what does the writer monad Do?
17:31:47 <kpreid> Just as long as you don't look at the return value too early.
17:32:07 <kpreid> > take 10 $ snd $ runWriter (sequence_ $ repeat (tell ["fd 10"]))
17:32:09 <lambdabot>  ["fd 10","fd 10","fd 10","fd 10","fd 10","fd 10","fd 10","fd 10","fd 10","fd...
17:32:16 <araujo> hello
17:32:27 <kpreid> it accumulates a result
17:32:37 <kpreid> in this case, you'd use it for graphics commands
17:34:07 <kpreid> or one might use, say, RWS for turtle/variable state and graphics output
17:35:04 <Korollary> turtles all the way
17:35:15 <LoganCapaldo> Logkell
17:35:34 <LoganCapaldo> Haskurtle?
17:38:39 <fax> f * unit = unit * f = f and lift f * lift g = lift (f.g)
17:38:47 <pchiusano> Philippa, that worked great
17:38:52 <fax> this is true for all monads and if so why?
17:38:57 <fax> I mean why must it be
17:39:26 <pchiusano> (doing a foldl to make application left associative
17:39:28 <pchiusano> )
17:39:46 <kpreid> fax: Because using a proper monad which obeys those rules lets you use generic code which assumes those rules.
17:40:33 <fax> aye that makes sense
17:40:56 <fax> I think I am starting to see the basic point about monads now :D
17:41:23 <Botje> monads are a way of storing extra information about a computation
17:41:28 <ddarius> It's true for all monads by definition.
17:41:30 <Botje> that's pretty much all they are.
17:41:47 <fax> but you can also change the way a computation occurs right?
17:42:06 <fax> or is that not true, its just an implication of the use of e.g. do notation?
17:42:27 <Botje> "how the computation happens" falls under "extra information", for me :)
17:44:52 <lokam_> how do I set a sleep timer? like to get the program to wait for say 2 min
17:45:08 <mauke> @hoogle delay
17:45:12 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
17:45:12 <lambdabot> Network.Socket.NoDelay :: SocketOption
17:45:12 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
17:45:35 <Botje> *blink*
17:45:39 <Botje> delay until reboot?
17:45:44 <Botje> that's pretty horrifying.
17:45:46 <Botje> @hoogle sleep
17:45:47 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
17:46:04 <lokam_> ki'e  thanks
17:46:06 <sorear> Botje: yeah, have you ever used that "OS"
17:46:07 <sorear> ?
17:46:29 <Korollary> the lowercase m is a nice touch
17:46:43 <sorear> Botje: basically since the system is too dumb to support moving open files, it has a queue of moves that need to be executed right before the next boot
17:46:49 <Botje> oh.
17:46:50 <sorear> as in, before most of the kernel
17:46:52 <Botje> that's horrible!
17:47:32 <sorear> this is part of the reason why windows installers demand so many reboots :)
17:47:43 <Korollary> they dont demand more than one
17:47:48 <Botje> sorear: thanks a lot, now I won't be able to sleep :)
17:48:16 <sorear> keep in mind I haven't used windows in like 3.5 yrs
17:48:41 <sorear> i've heard rumors that around vista the kernel team sobered up
17:48:53 <kbrooks> sober up?
17:49:42 <sorear> insert colorful exaggerative phrase reflecting previous ineptitude
17:50:15 <phoniq> "went back on their meds"
17:50:30 <sjanssen> @keal
17:50:30 <lambdabot> pork steaks taste like dick
17:50:35 <sjanssen> @keal
17:50:36 <lambdabot> know you know this 24 periods Keal SecretTM
17:54:35 <Adamant> @(elite . keal)
17:54:35 <lambdabot> . x3AL)
17:54:40 <Adamant> @elite . keal
17:54:40 <lambdabot> . K3a1
17:54:44 <sorear> @. elite keal
17:54:44 <lambdabot> I |AcK iN verbA| 4nd sO(iA1 exPRe55i0N
17:55:15 <Adamant> @. elite keal
17:55:15 <lambdabot> b0T DEph3(7IvE
17:58:37 <fax> @. elite :(){ :|:& };:
17:58:38 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ":(){"
17:58:43 <fax> :/
17:59:42 <bd_> @unpl fix ((>> (return ())) . forkIO)
17:59:43 <lambdabot> fix (\ d -> (forkIO d) >> (return ()))
18:01:07 <ddarius> @elite :(){ :|:& };:
18:01:08 <lambdabot> :(){ :|:& };:
18:01:44 <LoganCapaldo> ddarius: that's not a very nice shell script
18:01:57 <shapr> Keal still amazes me thoroughly.
18:02:06 <Botje> @protontorpedo
18:02:07 <lambdabot> are objects kina just subroutines
18:02:40 <shapr> I actually did explain objects that way once.
18:02:58 <ddarius> lambda based objects!
18:03:24 <Botje> closure-ects!
18:03:24 <shapr> I had a boss who last did programming with COBOL and FORTRAN were hot. He asked me what objects really were, and I explained them as subroutines that just get looping, where you could change the values of their variables while they were looping.
18:03:28 <fax> objects are watered down closures!
18:03:28 <fax> no closures are watered down object!
18:03:42 <sorear> I've seen the converse.  "Closures are a crippled form of objects.  Use a real (OO) language"
18:03:46 <sorear> scary.
18:03:54 <fax> sorear: both statements are true really
18:03:56 <shapr> I think they're both true.
18:03:59 <Botje> but in most OO languages, an object can't replace itself.
18:04:02 <fax> sussman put it well, let me see if I can fnd it
18:04:03 <shapr> fax: hah
18:04:03 <Botje> with closures, you can!
18:04:16 <shapr> Botje: good point.
18:04:40 <Botje> this is still *THE* coolest abuse of continuations, for me.
18:04:46 <olsner> in what way can a closure replace itself?
18:05:06 <Botje> you can send a message to a closure
18:05:16 <Botje> and the entire closure can replace itself permanently with something else.
18:05:32 <fax> its still the same closure..
18:05:38 <Botje> no it's not :)
18:05:39 <fax> just its internal state has changed
18:05:45 <Botje> it really is gone.
18:05:51 <fax> this is how I view it, do you know some example which conflicts with my view?
18:06:01 <Botje> i'll whip something up now, sec
18:06:07 <SamB> @hoogle CInt
18:06:08 <lambdabot> Foreign.C.Types.CInt :: data CInt
18:07:37 <Botje> http://sial.org/pbot/24850
18:07:39 <lambdabot> Title: Paste #24850 from "Botje" at 213.118.68.151
18:07:44 <Botje> there's a trivial example.
18:08:18 <Botje> if you call (my-eval '(+ 4 2)) you get back a lambda
18:08:28 <Botje> once you call that lambda, that closure is gone.
18:10:48 <Botje> so, let's see any self-respecting "oo language" do that
18:15:52 <int-e> It seems that "Any problem in computer science can be solved with another layer of indirection." applies to that.
18:15:57 <ddarius> Does read-eval exp produce thunks?
18:15:59 <SamB> Botje: don't you at least have to wait for the next GC flip?
18:16:16 <fax> I dont really get the example :|
18:17:21 <SamB> layers of indirection must be easier to add in CS than in programming
18:18:28 <int-e> What's hard about creating a wrapper object that contains a pointer to the 'real' object (which can then be replaced)?
18:20:10 <SamB> I wrote one in Slate...
18:20:24 <SamB> I was trying to port Parsec ;-)
18:20:48 <SamB> it seemed difficult to do much without it, for some reason.
18:21:39 <fax> im sorry I cant find the thnig about closures/OO
18:24:32 <sioraiocht> are there trig functions in haskell thta will return Rationals?
18:25:20 <SamB> sioraiocht: ... how are they supposed to do that?
18:25:36 <SamB> the closest we could do would be some kind of power series...
18:25:39 <sioraiocht> SamB: I don't know, my TI-89 will do it =p
18:26:25 <beelsebob> wow
18:26:27 <beelsebob> now there's an idea
18:26:38 <sioraiocht> eh?
18:26:40 <beelsebob> a Haskell compiler for TI calculators
18:26:45 <sioraiocht> *drools*
18:26:50 <sioraiocht> that would be neeeeeeeaaaat
18:26:59 <beelsebob> would be neat beyond belief
18:27:39 <sioraiocht> probably not very memory friendly, though
18:28:35 <sorear> sioraiocht: I don't have the book with me atm, but I have a proof that f(x) is irrational for all non-zero rational x and f from the 12 basic trig functions
18:28:36 <fax> "a lot" of the results of trig functions will be irrational values..
18:28:43 <jcreigh> But TI-BASIC (or whatever they call it) sucks so much...it would be cool to have a real language on a TI calc.
18:29:06 <fax> sioraiocht: oh wow
18:29:11 <ddarius> It's called Z80 assembly
18:29:11 <fax> damn id love to read that
18:29:18 <fax> do you know what book its from?
18:29:21 <Olathe> You could make a compiler for PCs to generate the proper programs for a TI calculator, probably.
18:29:28 <sorear> too bad they don't have forth
18:29:38 <ddarius> Make it.
18:29:40 <sorear> i tried implementing forth in ti-basic ...
18:29:42 <Olathe> They have C compilers for them, so you could compile to C.
18:29:48 <SamB> Yhc, I think they call it.
18:29:57 <sorear> no indirect jumps made NEXT impossibly daunting :/
18:29:57 <ddarius> Trying to implement -anything- in TI-BASIC ends in tears.
18:30:09 <SamB> unfortunately it don't work too well :-(
18:30:31 <beelsebob> yeh... yhc probably would fit
18:30:33 <sorear> ddarius: So does Z80 asm, if you don't have a link cable :)
18:30:35 <SamB> it is based on nhc98, which was pre-monad and pre-typeclass, apparantly...
18:30:45 <int-e> ddarius: how is that? "I tried to implement Hello, world, but all I managed was PRINT "CRY, BABY, CRY"?
18:30:53 <beelsebob> SamB: it has typeclasses
18:31:03 <beelsebob> it has monads, just not where you expect them
18:31:06 <ddarius> sorear: Indeed.  But you can make one for like five bucks, if you already have the tools.
18:31:14 <SamB> sorear: buy a soldering iron, a db-9, and a couple of componentes
18:31:42 <ddarius> int-e: No, you do the crying and the calculator still doesn't print out hello world.
18:31:43 <SamB> assuming you have a TI-to-TI cable
18:59:05 <sorear> @botsnack
18:59:06 <lambdabot> :)
18:59:20 <emu> @botbeer
18:59:20 <lambdabot> Unknown command, try @list
19:01:49 <sorear> Yay.  My super mysterious formatter bug has been traced to ... 4 - 2 = 1
19:02:19 <mauke> > let 4 - 2 = 1 in 4 - 2
19:02:21 <lambdabot>  1
19:02:56 <fax> > let x/0 = "explode" in 1/0
19:02:58 <lambdabot>  "explode"
19:03:03 <fax> wow
19:03:37 <mauke> that kind of code is great for confusing newbies :-)
19:03:39 <sorear> when you implement subtraction wrong, stuff *breaks*
19:04:42 <dmwit> > let x/0 = "explode" in 3/4 -- RAAAH
19:04:44 <lambdabot>   Non-exhaustive patterns in function /
19:05:28 <sorear> hello.
19:06:37 <chessguy> hi all
19:09:33 <int-e> > let (!)!(?)=[1..5]!(?) in (>>)!"?!"
19:09:35 <lambdabot>  "?!?!?!?!?!"
19:10:06 <fax> EH?
19:10:12 <fax> ahah wow :d
19:10:22 <ariks_> any ideas why xmonad fails to build for me? http://hpaste.org/1818
19:11:17 <sorear> and now / isn't working.  figures
19:11:35 <sorear> ariks_: yeah, your x11-extras is obsolete
19:12:07 <sorear> complaints about the level of churn should be directed to #xmonad
19:13:28 <nornagon> int-e: cute :)
19:13:44 <ariks_> ah, thanks
19:13:55 <ddarius> Console output may work better if I write to stdout rather than stdin.
19:14:37 <nornagon> heh
19:14:58 <ddarius> And indeed it does.
19:18:36 <ariks_> if i find a package on hackage.haskell.org is there some easy way to find a link to an official site or darcs repository or something?
19:19:19 <stepcut> ariks_: the packages sometimes list that in the .cabal file
19:19:54 <stepcut> ariks_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HaXml-1.13.2
19:19:56 <lambdabot> http://tinyurl.com/yqedu8
19:20:09 <stepcut> Home page: http://www.cs.york.ac.uk/fp/HaXml/
19:20:11 <lambdabot> Title: HaXml: Haskell and XML
19:21:13 <stepcut> ariks_: but, there is currently no requirement that the package list that, since some packages may not even have a homepage or repository
19:21:56 <ariks_> ah, the ones i clicked on at must have just happened not to have one listed
19:34:55 * Sgeo writes a quick haskell program to help him understand http://qntm.org/message
19:34:56 <lambdabot> Title: The Message @ Things Of Interest
19:35:20 <hpaste>  lala pasted "config.hs" at http://hpaste.org/1819
19:37:13 <hpaste>  lalalal pasted "conf2" at http://hpaste.org/1820
19:39:32 <ariks_> hmm. that hpaste announce feature can be annoying when the user is in another channel.
19:40:26 <sorear> ariks_: Fortunately, it's optional.
19:44:21 <hpaste>  int-e pasted "type checking oddity" at http://hpaste.org/1821
19:45:49 <davidL> fax you leet hacker help me debug this http://rafb.net/p/bz2KLc87.html
19:45:50 <lambdabot> Title: Nopaste - Need Help Debugging This (GMP)
19:45:53 <dmwit> > 0xdead
19:45:55 <lambdabot>  57005
19:46:36 <dmwit> > complement 0xdead
19:46:37 <lambdabot>  Add a type signature
19:46:56 <dmwit> > complement 0xdead :: Word16
19:46:58 <lambdabot>  8530
19:46:59 <kpreid> > complement (0xdead :: Integer)
19:47:01 <lambdabot>  -57006
19:47:30 <int-e> davidL: you want mpz_ui_pow_ui I think
19:47:44 <fax> davidL: lol ty :)
19:47:46 <kpreid> two's complement works just fine in an unbounded integer!
19:48:05 <davidL> int-e: have you done p156 on projecteuler?
19:48:23 <fax> oh jesus you are doing euler in C?
19:48:38 <fax> wow, I cant tell if thats sillier than using brainfuck
19:49:14 <davidL> I know it sucks
19:49:45 <int-e> davidL: no. it only goes up to 154 ;)
19:50:09 <int-e> and I'm 'only' up to 152
19:50:10 <davidL> int-e: and yes, I do need mpz_ui_pow_ui, thanks for pointing that out (I meant 154 :) )
19:51:57 <int-e> davidL: and the other warnings can be fixed by using gmp's comparison functions. and the whole code would actually be readable in some language with multiple precision integers. (heck, I guess even C++ with gmpxx would work ok)
19:53:05 <davidL> int-e: but I don't think that fixing the warnings will help me with the segfault (or will it?)
19:53:10 <int-e> did anyone look at my paste? I'm really curious why ghc doesn't manage to do that (although I suspect that variable type constructors throw it off)
19:53:57 <int-e> davidL: well, using mpz_ui_pow_ui probably fixes a segfault, and fixes a warning. using pointers as integers is generally a very bad idea :-P
19:58:47 <davidL> int-e: my idiocy aside, which language natively supports multiple percision integers?
19:59:12 <int-e> Haskell :-P
20:00:11 <davidL> I want to do iteration though ;)
20:00:57 <ed1t> hail haskell!
20:01:14 <merus> hail haskell, full of grace, the lord is with you...
20:01:22 <ed1t> lol
20:02:02 <dmwit> :t guard
20:02:05 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:02:10 <fax> davidL: common lisp and scheme
20:02:45 <dmwit> ?hoogle Bool -> m () -> m ()
20:02:46 <lambdabot> No matches, try a more general search
20:02:56 <dmwit> ?hoogle (Monad m) => Bool -> m () -> m ()
20:02:57 <lambdabot> No matches, try a more general search
20:03:31 <dmwit> :t when -- hoogle loses
20:03:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:04:05 <dmwit> davidL: while p body = p >>= flip when body
20:04:19 <dmwit> ;-)
20:04:40 * davidL is tempted
20:04:42 <ddarius> I think you want some recursion there.
20:05:25 <dmwit> You're right.
20:05:33 <davidL> this would be my fourth time rewriting that program :(
20:05:55 <dmwit> doWhile p body = body >> p >>= flip when (doWhile p body)
20:06:37 <dmwit> while p body = p >>= flip when (body >> while p body) -- here we go, I think this might be it.
20:06:41 <davidL> actually I can do this rather quickly in haskell with guards and recursion
20:07:50 <davidL> I'm just affraid it won't handle the big numbers quickly
20:08:10 <ed1t> poop
20:08:14 <davidL> lol
20:08:28 <kbrooks> ttyl bed
20:08:32 <ed1t> this is fun
20:08:42 <dmwit> davidL: GHC uses gmp for its big numbers, so... =P
20:08:46 <ed1t> kbrooks got scared already
20:09:26 <davidL> dmwit: really? is there haskell source for gmp?
20:09:43 <dmwit> I think it calls into C.
20:09:50 <dmwit> http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes/TheCurrentGMPImplementation
20:09:57 <lambdabot> Title: ReplacingGMPNotes/TheCurrentGMPImplementation - GHC - Trac, http://tinyurl.com/2hfxl5
20:10:17 <davidL> and this is native to Prelude?
20:10:27 <dmwit> yep
20:10:30 <int-e> it calls into C and it changes the memory management. It's sometimes faster than C actually, because free is a nop.
20:10:33 <dmwit> > 2^100
20:10:38 <lambdabot>  1267650600228229401496703205376
20:11:06 <davidL> how can I do the other functions gmp has like primes and factorial?
20:12:05 <dmwit> Oooo, those might be trickier. =P
20:12:20 <Cale> davidL: For that you'd need to write a more complete binding.
20:12:26 <kbrooks> byeeeeeeeeeeeeeeeeee going off now
20:12:35 <int-e> you can't really. (you'll have to mimic ghc's tricks, simple FFI won't work)
20:12:55 * merus sets his slow comp computing some random large number
20:13:09 * int-e has a start for a  gmp FFI binding somewhere that he gave up on for those reasons.
20:14:05 <dmwit> You can do factorial quickly by doing a binary fold.
20:14:15 <dmwit> (But yeah, you have to write it yourself.)
20:15:09 --- mode: irc.freenode.net set +o ChanServ
20:15:21 <dmwit> fax, davidL: It is semantically equivalent to foldl/r, if your operator is commutative.
20:15:21 <fax> oh right
20:15:21 <dmwit> Let's see if I can code it up real quick here...
20:15:21 <davidL> ?bot
20:16:27 <davidL> ?bot
20:16:28 <ed1t> is there any IDE for haskell?
20:16:35 <tessier> ed1t: emacs
20:16:38 <dmwit> > let foldb _ [] = []; foldb _ [x] = x; foldb op (x:y:rest) = foldb (x `op` y : foldb op rest) in foldb (+) [1..10]
20:16:44 <tessier> is there any IDE for *? Yes, emacs.
20:16:45 <lambdabot> :)
20:16:46 <lambdabot>  Couldn't match expected type `[a]'
20:16:55 <davidL> > foldl' (*) [1..10000]
20:16:56 <lambdabot>   add an instance declaration for (Num [t])
20:17:04 <davidL> > foldl' (*) 1 [1..10000]
20:17:06 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
20:17:12 <ed1t> i dont like emacs
20:17:17 <fax> ed1t: lol
20:17:27 <fax> you most likley dont know emacs
20:17:28 <dmwit> Oh, right.
20:17:28 <tessier> ed1t: I don't like MS Visual Studio. We're both fucked. :(
20:17:29 <kilimanjaro> ed1t, it's useful
20:17:32 <fax> I used to "not like emacs"
20:17:35 <davidL> there are IDEs check the wiki
20:17:46 <fax> I just didnt know what emacs was
20:17:49 <davidL> @whereis editors
20:17:50 <lambdabot> Maybe you meant: where where+
20:17:52 <tessier> fax: ditto
20:17:56 <davidL> @where editors
20:17:56 <lambdabot> I know nothing about editors.
20:17:59 <davidL> @where edittors
20:18:00 <lambdabot> I know nothing about edittors.
20:18:07 <davidL> lol
20:18:12 <Cale> @go editors
20:18:15 <ed1t> emacs blows....im better off with ghc
20:18:15 <lambdabot> http://www.editorsofficial.com/
20:18:15 <lambdabot> Title: Editors - Official website - Homepage
20:18:16 <shapr> jiihaa!
20:18:17 <Cale> heh
20:18:30 <davidL> ghc is a good editor
20:18:56 <Cale> @type appendFile
20:18:58 <lambdabot> FilePath -> String -> IO ()
20:19:17 <davidL> > length $ foldl' (*) 1 [1..200000]
20:19:18 <lambdabot>   add an instance declaration for (Num [a])
20:19:19 <lambdabot>     In the expression: 200000
20:19:31 <davidL> > length . show $ foldl' (*) 1 [1..200000]
20:19:37 <lambdabot> Terminated
20:19:41 <davidL> damn it
20:19:42 <dmwit> Hmmm...
20:19:50 <LordBrain> hmm, i wrote a little utility which only read two bytes in but used readFile, that's probably a leak huh?
20:20:09 <davidL> is lambdabot set to terminate after a specific time?
20:20:14 <fax> yeah
20:20:14 <dmwit> 3 seconds
20:20:31 <fax> > reverse [1..]
20:20:37 <lambdabot> Terminated
20:20:42 <davidL> with 16 cores, dons should give us a few more seconds :(
20:21:01 <ddarius> lambdabot is not on that machine.
20:21:11 <davidL> ?version
20:21:12 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
20:21:12 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:21:21 <dmwit> > let foldb _ ident [] = ident; foldb _ _ [x] = x; foldb op ident (x:y:rest) = foldb op ident (x `op` y : foldb op ident rest) in foldb (+) 0 [1..10]
20:21:22 <davidL> oh
20:21:22 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
20:21:23 <lambdabot>       Expected...
20:21:35 <davidL> can we bring our own lambdabots in here?
20:22:02 <fax> lambda-krew :d
20:22:02 <ed1t> yea and then let all lambdabot play with each other?
20:22:24 <fax> how can you make lambdabot print: > stuff
20:22:31 <fax> I dont think thats posibel?
20:22:41 <davidL> she cant do IO
20:22:47 <tessier> IO is a side effect
20:22:54 <tessier> ie. monad territory
20:22:55 <davidL> > putStrLn "mommy"
20:22:57 <lambdabot>  <IO ()>
20:22:59 <tessier> ie. Don't do it with haskell. :)
20:23:00 <fax> > let x ">" in x
20:23:01 <lambdabot>  Parse error
20:23:05 <fax> > let x = ">" in x
20:23:07 <lambdabot>  ">"
20:23:28 <davidL> heh
20:23:41 <ed1t> anybody got a problem for me to solve? im bored
20:23:56 <merus> Man, I'm bored too.
20:23:59 <davidL> problem154 on projecteuler.net
20:24:05 <fax> ed1t: the software crisis :)
20:24:13 <merus> I was watching ghci calculate 7^(10^10)
20:24:22 <hpaste>  Cale pasted "using ghci as a text editor" at http://hpaste.org/1824
20:24:23 <davidL> > 10^10
20:24:24 <lambdabot>  10000000000
20:24:43 <davidL> > 7 ^ (10^10)
20:24:49 <lambdabot> Terminated
20:25:01 <merus> it takes more than 3 seconds, silly :P
20:25:07 <davidL> ?admin
20:25:07 <lambdabot> Not enough privileges
20:25:19 <ed1t> ?blah
20:25:19 * lambdabot smacks  about with a large trout
20:25:29 <davidL> ?nazi
20:25:30 <lambdabot> Maybe you meant: nazi-off nazi-on arr ask fact faq map part wiki yarr
20:25:31 <merus> Cale, lol
20:25:40 <ed1t> ?nazi
20:25:41 <lambdabot> Maybe you meant: nazi-off nazi-on arr ask fact faq map part wiki yarr
20:25:45 <fax> ?nazi-on
20:25:46 <lambdabot> Not enough privileges
20:25:48 <fax> :(
20:25:55 <davidL> ?fact
20:25:55 <ed1t> ?abuse
20:25:56 <lambdabot> I can not handle empty facts.
20:25:56 <lambdabot> Unknown command, try @list
20:26:07 <davidL> ?map
20:26:07 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:26:08 <ed1t> lambdabot [1,2,3,4]
20:26:13 <dmwit> > let foldb' op (x:y:rest) = op x y : foldb' rest; foldb' _ e = e; foldb _ i [] = i; foldb op i xs = foldb op i $ foldb' op xs in foldb (+) 0 [1..10]
20:26:14 <ed1t> ? [1,2,3,4]
20:26:15 <lambdabot>  Couldn't match expected type `[t]'
20:26:20 <ed1t> ?[1,2,3,4]
20:26:20 <lambdabot> Unknown command, try @list
20:26:24 <ed1t> @list
20:26:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:26:39 <davidL> dmwit: how much faster is that than a normal fold?
20:26:47 <ed1t> ?karma
20:26:47 <lambdabot> You have a karma of 0
20:26:53 <dmwit> davidL: For big numbers, it can make a big difference.
20:26:54 <ed1t> ?karma-all
20:26:54 <lambdabot>  "audreyt"             642
20:26:55 <lambdabot>  "fglock"              224
20:26:55 <lambdabot>  "dons"                147
20:26:55 <lambdabot>  "agentz"              131
20:26:55 <lambdabot>  "larry"               106
20:26:56 <lambdabot> [1080 @more lines]
20:27:02 <ed1t> how do i get karma?
20:27:10 <dmwit> Doing operations on similarly-sized Integers is significantly faster than, say, 1 + 10^30.
20:27:31 <nornagon> 642?!
20:27:43 <Cale> The perl6 guys have a bot which gives them karma on every commit.
20:27:44 <ed1t> hes cheating!
20:27:49 <Cale> Which is sort of unfair :)
20:27:51 <davidL> lol!
20:27:53 <dmwit> Or, rather, 10^30 + 10^30 is roughly as fast as 10^30 + 1, but 10^30+1 is way slower than 1+2.
20:27:56 <nornagon> cheaters :(
20:28:09 <davidL> dmwit: I see
20:28:18 <nornagon> guess if it encourages them to commit more, it's all good :)
20:28:45 <davidL> why can't we do perl on our lamdabot :(
20:28:59 <davidL> @seen lambdabot
20:28:59 <lambdabot> Yes, I'm here. I'm in #xmonad, #unicycling, #perl6, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #darcs and #scannedinavian
20:29:05 <nornagon> quote shell out
20:29:15 <nornagon> @quote perl
20:29:16 <lambdabot> cjeris says: i have a little perl script that aliases gcc -freduced-suckage to ghc
20:29:31 <nornagon> @quote shell out
20:29:31 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
20:29:38 <davidL> @quote XSLT
20:29:39 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
20:29:52 <fax> and APL coders say its a on char'r
20:30:16 <fax> nah probably 3 to be realistic
20:30:58 <nornagon> @quote pozorvlak
20:30:58 <lambdabot> pozorvlak says: You could always shell out to perl :-)
20:31:03 <nornagon> ^- the quote I was looking for.
20:31:30 <davidL> @quote lambdabot
20:31:30 <lambdabot> lambdabot says: Nobody brings small problems into a laundromat.
20:32:03 <davidL> @quote fantasma
20:32:04 <lambdabot> fantasma says: i'll change my nick and everything once I learn haskell
20:32:09 <fax> @quote headache
20:32:09 <lambdabot> fax-- says: I wake up with a headache because of you, haskell
20:32:12 <fax> :D
20:32:39 <ed1t> @quote ed1t
20:32:40 <lambdabot> No quotes match. You type like i drive.
20:32:44 <ed1t> @quote fax
20:32:45 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
20:32:52 <fax> my nick was fax--
20:33:02 <ed1t> @quote lambda
20:33:02 <lambdabot> dons says: i wish you success and may your lambdas always beta reduce.
20:33:42 <davidL> @quote java
20:33:43 <lambdabot> lispy says: it's like java, it gets cross on any platform :)
20:33:52 <fax> haha
20:33:53 <ed1t> @quote C#
20:33:53 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
20:34:10 <ed1t> @quote fun
20:34:10 <lambdabot> monochrom says: If you come across "monads are fun!" it's probably Wadler.  If you come across "continuations are fun!" it's probably Appel.
20:34:40 <davidL> @quote thunk
20:34:40 <lambdabot> ghc says: eval_thunk_selector: strange selectee
20:34:44 <davidL> @quote thunk
20:34:45 <lambdabot> ghc says: eval_thunk_selector: strange selectee
20:35:25 <davidL> @quote nature
20:35:26 <lambdabot> Cale says: Does X have the monad-nature?
20:35:46 <dmwit> > let foldb' op (x:y:rest) = op x y : foldb' op rest; foldb' _ e = e; foldb _ b [] = b; foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs) in foldb (*) 1 [1..1000] -- here we go
20:35:55 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
20:36:12 * dmwit is done spamming
20:36:28 <davidL> > let foldb' op (x:y:rest) = op x y : foldb' op rest; foldb' _ e = e; foldb _ b [] = b; foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs) in foldb (*) 1 [1..20000]
20:36:29 <lambdabot>  1819206320230345134827641756866458766071609901478752648918062218634569461038...
20:36:33 <davidL> wow
20:36:53 <davidL> > let foldb' op (x:y:rest) = op x y : foldb' op rest; foldb' _ e = e; foldb _ b [] = b; foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs) in foldb (*) 1 [1..200000] --please don't terminate, it would make my day
20:36:59 <lambdabot>  1420225345470314404966946333682305976089965356746401622696224744629226778516...
20:37:03 <davidL> AH
20:37:39 <MyCatVerbs> davidL: your day, it is make. I hope.
20:37:53 <MyCatVerbs> What the Hell is that, anyway? It lookks vaguely like...
20:37:57 <davidL> yes, it is
20:38:05 * MyCatVerbs squints. "Square root of two?"
20:38:11 <davidL> its a factorial function
20:38:13 <int-e> 973351 digits. hmm
20:38:26 <MyCatVerbs> No, something else.
20:38:28 <dmwit> foldb does a binary fold.
20:38:30 <dmwit> So,
20:38:40 <merus> It is verily the taste of power.
20:38:49 <davidL> that should be built in
20:38:52 <dmwit> It treats the values in the list as leaves of a binary tree listed in depth-first search order, and condenses upwards.
20:38:56 <MyCatVerbs> davidL: I was staring at the output, not the function. I can't decipher that. x_x
20:39:16 <davidL> ah ok, in that case it kinda does look like root 2 ;)
20:39:48 <davidL> ? hoogle DFS
20:39:58 <davidL> ?hoogle DFS
20:39:59 <lambdabot> Data.Graph.Inductive.Query.DFS :: module
20:39:59 <lambdabot> Data.Graph.dfs :: Graph -> [Vertex] -> Forest Vertex
20:39:59 <lambdabot> Data.Graph.Inductive.Query.DFS.dfs :: Graph gr => [Node] -> gr a b -> [Node]
20:40:03 <Sgeo> > take 5 $ iterate (2^) 1
20:40:05 <lambdabot>  [1,2,4,16,65536]
20:40:13 <Sgeo> > take 6 $ iterate (2^) 1
20:40:15 <lambdabot>  [1,2,4,16,65536,200352993040684646497907235156025575044782547556975141926501...
20:40:59 <davidL> dmwit: if I had used Data.IntSet.fold would that have done the same thing?
20:41:09 <dmwit> Int /= Integer
20:41:12 <fax> > prime numbers
20:41:13 <lambdabot>   Not in scope: `numbers'
20:41:25 <fax> @quote prime
20:41:26 <lambdabot> dons says: -fglasgow-exts ~= -fhaskell-prime
20:41:33 <dmwit> > foldl' (*) 1 [1..200000] -- does this one terminate?
20:41:39 <int-e> > take 6 $ iterate (2^) 1 :: Int
20:41:40 <lambdabot> Terminated
20:41:40 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
20:41:47 <int-e> > take 6 $ iterate (2^) (1 :: Int)
20:41:48 <lambdabot>  [1,2,4,16,65536,0]
20:42:01 <int-e> dmwit: eventually ;)
20:42:05 <dmwit> Yes.
20:42:08 <davidL> dmwit: would it go as fast?
20:42:08 <dmwit> =)
20:42:27 <dmwit> davidL: I don't know how IntSet is done.
20:42:38 <Sgeo> let twothingy n = (iterate (2^) 1) !! n in (twothingy (twothingy 2))
20:42:43 <Sgeo> > let twothingy n = (iterate (2^) 1) !! n in (twothingy (twothingy 2))
20:42:44 <lambdabot>  65536
20:42:51 <Sgeo> ..oh duh
20:43:06 <Sgeo> > let twothingy n = (iterate (2^) 1) !! n in (twothingy (twothingy 3))
20:43:11 <lambdabot> Terminated
20:43:16 <davidL> > Data.IntSet.fold (*) 1 Data.IntSet.fromList ([1..20000])
20:43:16 <lambdabot>  Couldn't match expected type `Data.IntSet.IntSet'
20:43:22 <davidL> ;(
20:43:42 <Sgeo> What's the IntSet for?
20:43:45 <dmwit> > Data.IntSet.fold (*) 1 (Data.IntSet.fromList [1..20000])
20:43:47 <lambdabot>  0
20:43:55 <dmwit> !
20:44:00 <ddarius> Int
20:44:10 <dmwit> > 2^16*2^16 :: Int
20:44:12 <lambdabot>  0
20:44:15 <int-e> @type Data.IntSet.fold
20:44:17 <lambdabot> forall b. (Int -> b -> b) -> b -> Data.IntSet.IntSet -> b
20:44:35 <davidL> > Data.IntSet.fold (*) 1 (Data.IntSet.fromList [1..20])
20:44:37 <lambdabot>  -2102132736
20:44:37 <int-e> dmwit: the type tells you that it has to do this sequentially.
20:44:45 <Sgeo> > let facs = scanl (*) [1..] in take 5 facs
20:44:45 <davidL> fail
20:44:45 <lambdabot>  Couldn't match expected type `[a]'
20:44:55 <dmwit> int-e: Ah, good point.
20:44:58 <Sgeo> > let facs = scanl1 (*) [1..] in take 5 facs
20:45:00 <lambdabot>  [1,2,6,24,120]
20:45:18 <dmwit> foldb :: (a -> a -> a) -> ...
20:45:30 <davidL> @remember dmwit > let foldb' op (x:y:rest) = op x y : foldb' op rest; foldb' _ e = e; foldb _ b [] = b; foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs) in foldb (*) 1 [1..1000] -- here we go
20:45:31 <lambdabot> Done.
20:45:55 <sch> :t foldb'
20:45:57 <lambdabot> Not in scope: `foldb''
20:46:08 <dmwit> foldb' :: (a -> a -> a) -> [a] -> [a]
20:46:17 <ddarius>  @let works now
20:46:43 <dmwit> ?help let
20:46:43 <lambdabot> let <x> = <e>. Add a binding
20:46:55 <davidL> @let (+) x y = x*y
20:46:56 <lambdabot> <local>:4:9:     Ambiguous occurrence `+'     It could refer to either `+', d...
20:47:00 <fax> @let x/0 = "explode!"
20:47:02 <lambdabot> Defined.
20:47:06 <dmwit> > 3 / 4
20:47:08 <lambdabot> Terminated
20:47:10 <davidL> > 20/0
20:47:10 <dmwit> =(
20:47:11 <lambdabot> Terminated
20:47:17 <Sgeo> > let facs = scanl1 (*) [1..] in take 5 (map (facs !!) facs)
20:47:19 <lambdabot>  [2,6,5040,2076180480,0]
20:47:20 <dmwit> ?list
20:47:20 <fax> D:
20:47:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:47:33 <Sgeo> > let facs = scanl1 (*) [1..] in take 6 (map (facs !!) facs)
20:47:34 <dmwit> ?undefine x/0
20:47:35 <lambdabot>  [2,6,5040,2076180480,0,0]
20:47:35 <lambdabot> Undefined.
20:47:39 <dmwit> > 3 / 4
20:47:41 <lambdabot>  0.75
20:47:42 <dmwit> phew
20:47:51 <davidL> that's awesome
20:48:02 <davidL> @let let x = x^2
20:48:03 <lambdabot>  Parse error
20:48:07 <Sgeo> > 1 / 0
20:48:08 <lambdabot>  Infinity
20:48:17 <dmwit> ?let x/0 = x
20:48:19 <lambdabot> Defined.
20:48:19 <dmwit> > 3/4
20:48:21 <lambdabot> Terminated
20:48:22 <fax> wtf
20:48:26 <dmwit> ?undefine x/0
20:48:26 <fax> 1/0 isnt infinity
20:48:27 <lambdabot> Undefined.
20:48:38 <Sgeo> @let facs = 1 : (scanl1 (*) [1..])
20:48:39 <davidL> ?let x/0 = Nothing
20:48:39 <lambdabot> Defined.
20:48:40 <lambdabot> Defined.
20:48:48 <davidL> > 3/4
20:48:49 <lambdabot> Terminated
20:49:05 <Sgeo> davidL, that makes x / 0 be of type Maybe a
20:49:10 <davidL> ?undefine x/0
20:49:11 <lambdabot> Undefined.
20:49:11 <Sgeo> ?undefine x/0
20:49:12 <lambdabot> Undefined.
20:49:18 <davidL> :t null
20:49:19 <dmwit> Clearly, changing the built-in operators is a bad idea...
20:49:21 <lambdabot> forall a. [a] -> Bool
20:49:35 <Sgeo> ?let x/0 = error "Don't try to explode the universe!"
20:49:36 <lambdabot> Defined.
20:49:41 <Sgeo> > 1 / 0
20:49:42 <lambdabot> Terminated
20:49:43 <davidL> > 10/2
20:49:44 <lambdabot> Terminated
20:49:47 <Sgeo> oO
20:49:54 <dmwit> ?undefine x/0
20:49:55 <lambdabot> Undefined.
20:50:05 <Cale> ?let x/0 = error "Don't try to explode the universe!"
20:50:05 <lambdabot> Defined.
20:50:11 * davidL guesses that @let wont be here for long
20:50:12 <Sgeo> :t x/0
20:50:14 <lambdabot> Not in scope: `x'
20:50:15 <Cale> > 1 L./ 0
20:50:16 <lambdabot>  Exception: Don't try to explode the universe!
20:50:22 <Sgeo> > 1/0
20:50:22 <lambdabot> Terminated
20:50:28 <Sgeo> @t 1/0
20:50:29 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:50:32 <Sgeo> @ty 1/0
20:50:34 <lambdabot> forall t. (Fractional t) => t
20:50:44 <Sgeo> > 3/4
20:50:44 <lambdabot> Terminated
20:50:47 <Cale> > 1 Prelude./ 0
20:50:49 <lambdabot>  Infinity
20:50:57 <Sgeo> ?undefine x/0
20:50:58 <lambdabot> Undefined.
20:51:01 <Sgeo> hm
20:51:02 <Cale> > 1 L./ 0
20:51:03 <lambdabot>   Not in scope: `L./'
20:51:12 <dmwit> ?let x/0 = error "hi there!"; x/y = x Prelude./ y
20:51:13 <lambdabot> Defined.
20:51:14 <Sgeo> Why does it seem like it's using x/0 as a base case?
20:51:18 <dmwit> > x/0
20:51:19 <lambdabot> Terminated
20:51:23 <dmwit> > xL./0
20:51:24 <lambdabot>   Not in scope: `./'
20:51:24 <Sgeo> > 1 / 2
20:51:25 <lambdabot> Terminated
20:51:26 <Sgeo> > 1/2
20:51:26 <dmwit> > x L./0
20:51:27 <lambdabot> Terminated
20:51:27 <lambdabot>   Not in scope: `x'
20:51:31 <Sgeo> @undefine x/0
20:51:32 <lambdabot> Undefined.
20:51:33 <dmwit> > 3 L./0
20:51:34 <Sgeo> @undefine x/y
20:51:35 <lambdabot>   Not in scope: `L./'
20:51:35 <lambdabot> Undefined.
20:51:36 <Cale> Sgeo: the Terminated message is because it can't resolve which version to use
20:51:48 <Cale> @undefine (/)
20:51:49 <ed1t> let fib c (x:y) = if (x + y) <= 1000 then fib c+1 (y:x+y) else c
20:51:49 <lambdabot> Undefined.
20:51:57 <ed1t> wats wrong with this
20:52:05 <davidL> lol
20:52:08 <dmwit> y would be a list in there
20:52:09 <Cale> x and y are different types
20:52:14 <Cale> and you're adding them
20:52:17 <davidL> @let (a:as) $+ (b:bs) = (a+b) : (as $+ bs)
20:52:18 <lambdabot> Defined.
20:52:20 <ed1t> y is the tail
20:52:33 <dmwit> davidL: ($+) = zipWith (+)
20:52:35 <davidL> @let as $+ [] = as
20:52:36 <lambdabot> Defined.
20:52:38 <Cale> ed1t: which is a list
20:52:49 <Cale> ed1t: whereas x is the first element, which probably isn't
20:52:49 <ed1t> so i gotta do head y
20:52:54 <Sgeo> @let twos = iterate (2^) 0
20:52:55 <lambdabot> Defined.
20:52:55 <Cale> no, you can pattern match
20:52:59 <Cale> perhaps like:
20:53:00 <Sgeo> > take 10 twos
20:53:01 <lambdabot>  [0,1,2,4,16,65536,2003529930406846464979072351560255750447825475569751419265...
20:53:06 <Cale> let fib c [x,y] = ...
20:53:11 <davidL> @let [] $+ bs = bs
20:53:11 <lambdabot> <local>:4:3:     Multiple declarations of `L.$+'     Declared at: <local>:1:7...
20:53:13 <ddarius> No matter what x is not the same type as xs in (x:xs)
20:53:19 <Cale> or  let fib c (x:y:_) = ...
20:54:12 <araujo> Anyone knows, or might guess what 'hairly' means?
20:54:22 <dmwit> Done in a way similar to hair!
20:54:22 <ed1t> [x,y] wouldnt work in pattern matchin?
20:54:29 <Cale> araujo: pertaining to hair?
20:54:30 <dmwit> ed1t: Sure it would.
20:54:45 <Cale> araujo: I don't think it's a word.
20:54:46 <Sgeo> > map (facs > twos)
20:54:47 <lambdabot>   Not in scope: `facs'
20:54:47 <QtPlatypus> araujo: With regards to spheres?
20:54:48 <dmwit> araujo: More likely, it means something like ugly.
20:54:54 <araujo> Cale, yeah , i know it has something to do with it ..... but i am not sure
20:54:56 <davidL> @let nextPascal xs = xs $+ (0:xs)
20:54:58 <lambdabot> Defined.
20:55:03 <Sgeo> Who undefined facs?
20:55:07 <araujo> dmwit, ugly hair =
20:55:11 <araujo> ?
20:55:17 <ed1t> let c [x,y] = if x + y <= 1000 then fib c+1 [y, x+y] ?
20:55:22 <Sgeo> @let facs = 1 : (scanl1 (*) [1..]
20:55:22 <lambdabot>  Parse error
20:55:22 <araujo> Cale, i can't find it either
20:55:25 <davidL> @let pascalTriangle = iterate nextPascal [1]
20:55:27 <lambdabot> Defined.
20:55:28 <dmwit> araujo: What's the context?
20:55:29 <Sgeo> @let facs = 1 : (scanl1 (*) [1..])
20:55:31 <lambdabot> Defined.
20:55:32 <Cale> oh, it seems like google does have instances of it
20:55:35 <Sgeo> > take 5 facs
20:55:37 <lambdabot>  [1,1,2,6,24]
20:55:37 <davidL> > take 10 pascalTriangle
20:55:39 <lambdabot>  Exception: <local>:(1,0)-(2,12): Non-exhaustive patterns in function $+
20:55:44 <araujo> dmwit, describing a person
20:55:56 <dmwit> araujo: Ah, probably a typo for "hairy" then.
20:55:57 <Cale> araujo: maybe "hairy"?
20:56:04 <araujo> aah
20:56:05 <araujo> ok
20:56:10 <Sgeo> > facs !! 3
20:56:11 <lambdabot>  6
20:56:37 <araujo> Thanks guys
20:56:41 <Sgeo> @ty scanl
20:56:43 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
20:57:37 <Sgeo> > take 5 [f < t | f <- facs, t <- twos]
20:57:39 <lambdabot>  [False,False,True,True,True]
20:58:29 <dmwit> > let nextPascal xs = zipWith (+) xs (0:xs) in nextPascal [1]
20:58:31 <lambdabot>  [1]
20:58:42 <dmwit> > let nextPascal xs = zipWith (+) (xs++[0]) (0:xs) in nextPascal [1]
20:58:44 <lambdabot>  [1,1]
20:58:53 <dmwit> > let nextPascal xs = zipWith (+) (xs++[0]) (0:xs) in iterate nextPascal [1]
20:58:55 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
20:59:16 <davidL> ?undefine $+
20:59:18 <lambdabot> Undefined.
20:59:34 <davidL> @let nextPascal xs = zipWith (+) (xs++[0])
20:59:35 <lambdabot> Defined.
20:59:49 <dmwit> ?undefine nextPascal
20:59:50 <lambdabot> Undefined.
20:59:59 <dmwit> ?let nextPascal xs = zipWith (+) (xs++[0]) (0:xs)
21:00:00 <lambdabot> Defined.
21:00:18 <davidL> oops
21:00:20 <davidL> ;)
21:00:23 <dmwit> =)
21:00:25 <Sgeo> ?let pascals = iterate nextPascal [1]
21:00:25 <lambdabot> Defined.
21:00:30 <Sgeo> > take 5 pascals
21:00:31 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
21:00:38 <fax> ?define N = [1..]
21:00:39 <lambdabot> Undefined.
21:00:42 <davidL> > zip facs pascals
21:00:43 <lambdabot>   Not in scope: `pascals'
21:00:48 <fax> @let N = [1..]
21:00:49 <lambdabot> <local>:1:0: Not in scope: data constructor `N'
21:01:10 <Sgeo> fax, it would need to be lowercase
21:01:22 <Sgeo> caps is for constructors, types, classes, etc.
21:01:29 <dmwit> > take 5 facs
21:01:30 <lambdabot>   Not in scope: `facs'
21:01:34 <davidL> ???
21:01:41 <davidL> > take 10 pascals
21:01:41 <fax> Sgeo: :(
21:01:42 <lambdabot>   Not in scope: `pascals'
21:01:51 <Sgeo> ?let hi = "h"
21:01:52 <lambdabot> Defined.
21:01:53 <Sgeo> > hi
21:01:55 <lambdabot>  "h"
21:02:00 <Sgeo> ?define t = 5
21:02:01 <lambdabot> Undefined.
21:02:03 <Sgeo> > hi
21:02:04 <lambdabot>   Not in scope: `hi'
21:02:06 <dmwit> ?help undefine
21:02:07 <lambdabot> undefine. Reset evaluator local bindings
21:02:10 <nornagon> > L.hi
21:02:11 <lambdabot>   Not in scope: `L.hi'
21:02:13 <dmwit> That's why right there.
21:02:20 <Sgeo> the bad @define broke everything
21:02:22 <Cale> > iterate (ap (zipWith (+)) tail . (0:) . (++[0])) [1]
21:02:22 <ddarius> Good old spellchecking.
21:02:23 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
21:02:33 <davidL> > davidL
21:02:34 <Sgeo> @let facs = 1 : (scanl1 (*) [1..])
21:02:35 <lambdabot>  "davidL is the greatest in the world"
21:02:36 <lambdabot> Defined.
21:02:44 <Sgeo> ?let pascals = iterate nextPascal [1]
21:02:44 <lambdabot> <local>:3:18: Not in scope: `nextPascal'
21:02:53 <Sgeo> @let twos = iterate (2^) 0
21:02:54 <lambdabot> Defined.
21:03:05 <Sgeo> ?let nextPascal xs = zipWith (+) (xs++[0]) (0:xs)
21:03:06 <lambdabot> Defined.
21:03:11 <Sgeo> ?let pascals = iterate nextPascal [1]
21:03:12 <lambdabot> Defined.
21:03:38 <fax> @let  lambda
21:03:38 <lambdabot>  Illegal character ''\187''
21:03:43 <fax> FUCK
21:04:00 <dmwit> > '\187'
21:04:01 <lambdabot>  '\187'
21:04:07 <davidL> > div 10 2
21:04:08 <lambdabot> Terminated
21:04:13 <fax> > ''
21:04:13 <lambdabot>  Improperly terminated character constant
21:04:15 <Sgeo> > print ['\187']
21:04:16 <lambdabot>  <IO ()>
21:04:22 <fax> > ""
21:04:22 <Sgeo> > show ['\187']
21:04:24 <lambdabot>  "\955"
21:04:24 <lambdabot>  "\"\\187\""
21:04:30 <Sgeo> > ['\187']
21:04:31 <fax> Ggrr
21:04:32 <lambdabot>  "\187"
21:04:43 <Sgeo> > ['\32']
21:04:45 <lambdabot>  " "
21:05:01 <Sgeo> > ['\955']
21:05:02 <lambdabot>  "\955"
21:05:23 <davidL> > void 1
21:05:25 <dmwit> > (187 == 955, '\187' == '\955', doTheyLookAlike)
21:05:25 <lambdabot>  Exception: I smell bad
21:05:27 <lambdabot>  (False,False,True)
21:05:29 <fax> lol
21:05:41 <Sgeo> @ty doTheyLookAlike
21:05:43 <lambdabot> Not in scope: `doTheyLookAlike'
21:06:01 <Sgeo> > doTheyLookAlike
21:06:02 <lambdabot>  True
21:06:11 <Sgeo> @src doTheyLookALike
21:06:12 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:06:17 <Sgeo> @source doTheyLookALike
21:06:18 <lambdabot> doTheyLookALike not available
21:06:19 <dmwit> doTheyLookAlike = True
21:06:27 <dmwit> (What other definition could it have?)
21:06:48 <Sgeo> Why can't I seem to find where it was defined?
21:06:58 <dmwit> Because I defined it in a ?let.
21:07:19 <davidL> do the definitions get cleared after a few minutes?
21:07:30 <dmwit> I don't think so.
21:07:41 <davidL> > take 10 pascals
21:07:43 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
21:07:58 <davidL> > take 10 facs
21:08:00 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880]
21:08:15 <dmwit>  > sleep (60 * 60 * 10) >> return (take 10 pascals) -- ;-)
21:08:31 <davidL> ?src sleep
21:08:32 <lambdabot> Source not found. Do you think like you type?
21:08:37 <davidL> ?src void
21:08:38 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:08:45 <Sgeo> ?ty sleep
21:08:47 <lambdabot> Not in scope: `sleep'
21:08:47 <Sgeo> ?ty void
21:08:49 <dmwit> ?index void
21:08:49 <lambdabot> Not in scope: `void'
21:08:49 <lambdabot> Foreign.Marshal.Error, Foreign.Marshal, Foreign
21:08:59 <fax> > map (\x -> (x!, 2^x)) [1..]
21:09:00 <lambdabot>  Parse error
21:09:05 <MyCatVerbs> ?src i_enjoy_being_insulted_please_bitch_at_me_lambdabot_pretty_pretty_please
21:09:05 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:09:09 <MyCatVerbs> \o/
21:09:14 <davidL> lol
21:09:24 <LordBrain> is there a switch to tell ghc to set the bit when linking a win32 program so it is gui only and doesn't have an associated console?
21:09:38 <dmwit> ?remember MyCatVerbs ?src i_enjoy_being_insulted_please_bitch_at_me_lambdabot_pretty_pretty_please
21:09:38 <lambdabot> Done.
21:09:49 <LordBrain> i vaguely recall something like this but now i can't find it online
21:09:51 <fax> > map (\x -> (factorial x, 2^x)) [1..]
21:09:52 <lambdabot>   Not in scope: `factorial'
21:09:56 * Sgeo would prefer to think of Haskell as a scripting language..
21:09:59 <davidL> @quote here you go
21:09:59 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
21:10:05 <Sgeo> @quote Goldilocks
21:10:05 <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
21:10:12 <davidL> @quote dmwit
21:10:13 <lambdabot> dmwit says: > let foldb' op (x:y:rest) = op x y : foldb' op rest; foldb' _ e = e; foldb _ b [] = b; foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs) in foldb (*) 1 [1..1000] --
21:10:13 <lambdabot> here we go
21:10:20 <dmwit> > map (\x -> (facs !! x, 2^x)) [1..]
21:10:22 <lambdabot>  [(1,2),(2,4),(6,8),(24,16),(120,32),(720,64),(5040,128),(40320,256),(362880,...
21:10:43 <davidL> ?let foldb' op (x:y:rest) = op x y : foldb' op rest
21:10:45 <lambdabot> Defined.
21:10:50 <Sgeo> > map (\x -> (facs !! x, (twos !!))) [1..]
21:10:52 <lambdabot>  [(1,<Int -> Integer>),(2,<Int -> Integer>),(6,<Int -> Integer>),(24,<Int -> ...
21:11:03 <davidL> ?let foldb' _ e = e; foldb _ b [] = b
21:11:04 <lambdabot> Defined.
21:11:09 <Sgeo> > map (\x -> (facs !! x, (twos !! x))) [1..]
21:11:11 <lambdabot>  [(1,1),(2,2),(6,4),(24,16),(120,65536),(720,20035299304068464649790723515602...
21:11:15 <davidL> ?let foldb op b [x] = op b x
21:11:17 <lambdabot> Defined.
21:11:18 <dmwit> > foldb' (+) [3,4]
21:11:20 <lambdabot>  [7]
21:11:27 <dmwit> Oh, hey, it didn't kill it!
21:11:35 <davidL> ?let foldb op b xs = foldb op b (foldb' op xs)
21:11:36 <lambdabot> Defined.
21:11:45 <davidL> > foldb (*) 1 [1..1000]
21:11:47 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
21:12:06 <davidL> > foldb (*) 1 [1..10000000000000]
21:12:11 <dmwit> haha
21:12:12 <lambdabot> Terminated
21:12:15 <davidL> heh
21:12:48 <davidL> > foldb (^) [1..100]
21:12:49 <lambdabot>   add an instance declaration for (Integral [t])
21:12:52 <Sgeo> > zipWith (*) [1..] [1..]
21:12:53 <davidL> > foldb (^) 1 [1..100]
21:12:54 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
21:12:57 <Sgeo> > zipWith (*) [1..] [1..]
21:12:59 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
21:13:00 <lambdabot> Terminated
21:13:12 <davidL> > foldb (^) 1 [1..14]
21:13:18 <lambdabot> Terminated
21:13:20 <lokam> @hoogle cmd
21:13:21 <lambdabot> System.Cmd :: module
21:13:21 <lambdabot> Distribution.Setup.BuildCmd :: Action
21:13:21 <lambdabot> Distribution.Setup.CleanCmd :: Action
21:13:22 <Sgeo> > zipWith (*) [0..] [0..]
21:13:24 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
21:13:24 <dmwit> > 2^3^4^5
21:13:30 <lambdabot> Terminated
21:13:42 <davidL> > 2^3^4
21:13:44 <lambdabot>  2417851639229258349412352
21:13:56 <Sgeo> > facs !! 18
21:13:57 <lambdabot>  6402373705728000
21:14:04 <davidL> ?let 1 = 2
21:14:06 <int-e> > foldr1 (^) [2..5]
21:14:06 <lambdabot> Defined.
21:14:09 <dmwit> > (2^12,2^81)
21:14:11 <lambdabot>  (4096,2417851639229258349412352)
21:14:12 <Sgeo> > facs !! 18
21:14:12 <davidL> > 1 + 1
21:14:13 <lambdabot> Terminated
21:14:14 <lambdabot>  6402373705728000
21:14:15 <lambdabot>  2
21:14:21 <Sgeo> > 1
21:14:22 <lambdabot>  1
21:14:23 <dmwit> > foldb (^) 1 [1..4]
21:14:24 <lambdabot>  1
21:14:36 <dmwit> > foldb (^) 2 [3,4]
21:14:38 <lambdabot>  2417851639229258349412352
21:15:02 <LordBrain> what was that bit or byte or header called?
21:15:10 <dmwit> (^) isn't commutative, so foldb might give odd answers.
21:15:16 <dmwit> Data.Bits
21:15:20 <davidL> > length . show $ foldb (*) 1 [1..200000]
21:15:21 <fax> > foldb (^) [,2] [3,4]
21:15:22 <lambdabot>  Parse error
21:15:26 <fax> > foldb (^) [1,2] [3,4]
21:15:27 <lambdabot> Terminated
21:15:27 <lambdabot>   add an instance declaration for (Integral [t])
21:15:31 <davidL> > length . show $ foldb (*) 1 [1..20000]
21:15:33 <lambdabot>  77338
21:15:40 <davidL> lambdabot++
21:15:55 <davidL> @karma-add dmwit
21:15:56 <lambdabot>  "audreyt"             642
21:15:56 <lambdabot>  "fglock"              224
21:15:56 <lambdabot>  "dons"                147
21:15:56 <lambdabot>  "agentz"              134
21:15:56 <lambdabot>  "larry"               106
21:15:58 <lambdabot> [1080 @more lines]
21:16:01 <davidL> ...
21:16:03 <Sgeo> @ let fac = facs !!
21:16:06 <davidL> dmwit++
21:16:07 <Sgeo> @let fac = facs !!
21:16:07 <lambdabot>  Parse error
21:16:16 <dmwit> That corrects to karma-all instead of karma+. =)
21:16:18 <dmwit> ?karma
21:16:18 <lambdabot> You have a karma of 6
21:16:22 <dmwit> Yay!
21:16:23 <Sgeo> @karma+ dmwit
21:16:23 <int-e> @karma
21:16:23 <lambdabot> dmwit's karma raised to 7.
21:16:24 <lambdabot> You have a karma of 30
21:16:30 <Sgeo> @karma
21:16:30 <lambdabot> You have a karma of 0
21:16:31 <davidL> @karma+ dmwit
21:16:32 <lambdabot> dmwit's karma raised to 8.
21:16:37 <dmwit> Whoa.
21:16:40 <dmwit> dmwit--
21:16:43 <dmwit> ?karma dmwit
21:16:44 <lambdabot> You have a karma of 8
21:16:48 <davidL> davidL--
21:16:51 <int-e> dmwit--
21:16:52 <int-e> ;)
21:16:55 <dmwit> Thanks.
21:17:12 <Sgeo> @karma+ lambdabot
21:17:12 <lambdabot> lambdabot's karma raised to 49.
21:17:27 <Sgeo> @botsnack
21:17:27 <lambdabot> :)
21:17:39 <Sgeo> @let fac = (facs !!)
21:17:40 <lambdabot> Defined.
21:17:59 <Sgeo> > map fac facs
21:18:00 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
21:18:01 <davidL> > karmaplus
21:18:03 <lambdabot>  ["davidL++","davidL++","davidL++","davidL++","davidL++","davidL++","davidL++...
21:18:06 <sorear> wait, @let works now?!
21:18:13 <dmwit> ?karma davidL
21:18:14 <lambdabot> davidL has a karma of 1
21:18:20 <Sgeo> > length karmaplus
21:18:25 <lambdabot> Terminated
21:18:35 <Sgeo> @ty fac
21:18:36 <lambdabot> Not in scope: `fac'
21:18:48 <Sgeo> Why didn't map fac facs work?
21:18:57 <dmwit> > unwords . repeat $ "harmless++" -- hack?
21:18:58 <lambdabot>  "harmless++ harmless++ harmless++ harmless++ harmless++ harmless++ harmless+...
21:19:01 <dmwit> ?karma harmless
21:19:01 <lambdabot> harmless has a karma of 0
21:19:03 <Sgeo> > map fac facs::[Int]
21:19:04 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
21:19:10 <Sgeo> > map fac (facs::[Int])
21:19:11 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
21:19:34 <Sgeo> @let fac = facs `genericIndex`
21:19:34 <lambdabot>  Parse error
21:19:41 <Sgeo> @let fac = (facs `genericIndex`)
21:19:42 <lambdabot> <local>:16:0:     Multiple declarations of `L.fac'     Declared at: <local>:1...
21:19:47 <Sgeo> @undefine fac
21:19:48 <lambdabot> Undefined.
21:19:50 <Sgeo> @let fac = (facs `genericIndex`)
21:19:51 <lambdabot> <local>:1:7: Not in scope: `facs'
21:19:56 <dmwit> heh
21:19:56 <Sgeo> oshi-
21:19:59 <dmwit> back to square one
21:20:05 <davidL> it would be nice if you could do ?source on things that have been defined
21:20:17 <Sgeo> Why can't I undefine a single function?
21:20:57 <int-e> Sgeo: you did, I think. facs isn't defined?
21:20:59 <int-e> @type facs
21:21:01 <lambdabot> Not in scope: `facs'
21:21:04 <Sgeo> I did define facs
21:21:10 <dmwit> int-e: No, he undefined *everything*. =(
21:21:23 * Sgeo only wanted to undefine fac
21:21:24 <dmwit> > take 5 pascals
21:21:25 <lambdabot>   Not in scope: `pascals'
21:21:29 <davidL> seee
21:21:35 <davidL> they do get deleted
21:21:44 * Sgeo is sorry
21:21:46 <dmwit> davidL: Yes, but not by time; by Sgeo!
21:21:47 <dmwit> =P
21:21:48 <Sgeo> =( =( =(
21:21:50 <davidL> oh
21:21:51 <davidL> lol!
21:21:54 <davidL> haha
21:22:27 <Sgeo> Well, as time increases, the chances of some idiot doing @define or @undefine approach 1
21:22:33 <davidL> > foldb (*) [1..1000]
21:22:34 <lambdabot>   Not in scope: `foldb'
21:22:42 <davidL> how did you delete them?
21:22:45 <ddarius> @listmodules
21:22:45 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact figlet free fresh ft haddock help hoogle instances irc karma localtime log maya more offlinerc pl pointful poll pretty
21:22:46 <lambdabot> quote search seen slap small source spell state system tell todo topic type undo unlambda unmtl url version vixen where
21:23:00 <davidL> if you leave @let empty it deletes them?
21:23:01 <dmwit> davidL: ?undefine resets all the ?let's
21:23:09 <davidL> ouch
21:23:20 <Sgeo> And by spellchecking, ?define does the same thing
21:23:26 <ddarius> @list eval
21:23:27 <lambdabot> eval provides: run let undefine
21:23:31 <Sgeo> and ?undefine does NOT just delete a single function
21:23:33 <dmwit> > foldb (*) 1 [1..100]
21:23:34 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
21:23:35 <Sgeo> =(
21:23:45 <int-e> oh well, nobody should rely on lambdabot to remember anything :-P
21:24:06 <davidL> we need another bot that constantly provides definitions to lamdabot
21:24:06 <araujo> int-e, we all are lambdabot addicts
21:24:18 <int-e> yes, I know.
21:24:20 <int-e> @botsnack
21:24:21 <lambdabot> :)
21:24:32 <int-e> @arr
21:24:32 <lambdabot> Avast!
21:24:38 <araujo> @yarr!
21:24:39 <lambdabot> Where d' all t' pirates come from?
21:24:39 <lambdabot> Great Yarrmouth!
21:24:40 <int-e> and I can't say that I'm not :)
21:24:57 <davidL> > botsnack
21:24:59 <lambdabot>  "(:"
21:25:17 <int-e> back to 100% on project euler ... hmm. what now?
21:25:23 <davidL> WHAT
21:25:25 <davidL> so fast??
21:25:39 <davidL> how'd you do 154, just give me hint
21:25:39 <fax> :O
21:25:43 <fax> wow!
21:25:47 <dmwit> Well, he doesn't waste time here yapping. ;-)
21:25:49 * fax very impressed
21:26:04 <int-e> simplistic number crunching I'm afraid. The program took 5 minutes.
21:26:10 <davidL> oh
21:26:18 <Sgeo> What's this?
21:26:20 <davidL> you should have fixed mine ;)
21:26:20 <int-e> no arbitrary precision math involved though
21:26:51 <int-e> davidL: I doubt it, it will never run fast enough (I'm quite sure.)
21:26:51 <davidL> did you attempt to greate the entire pyramid?
21:27:02 <davidL> s/g/c
21:27:05 <Sgeo> @let facs = 1 : (scanl1 (*) [1..])
21:27:10 <lambdabot> Defined.
21:27:28 <Sgeo> @let fac = (facs `genericIndex`)
21:27:32 <lambdabot> Defined.
21:27:35 <Sgeo> > fac 3
21:27:44 <lambdabot>  6
21:27:44 <Sgeo> oO
21:27:48 <Sgeo> > "hi"
21:27:55 <int-e> davidL: ok, a hint. think about prime factors. actually looking at recent haskell-cafe archives may help if you know what you're looking for ;)
21:27:55 <lambdabot>  "hi"
21:28:06 <Sgeo> int-e, what are you talking about?
21:28:15 <davidL> projecteuler.net
21:28:16 <Sgeo> > zipWith (*) facs facs
21:28:22 <lambdabot>   Not in scope: `facs'
21:28:24 <Sgeo> ty
21:28:26 <dmwit> > let choose a b = (facs !! a) `div` (facs !! b) `div` (facs !! (a - b)) in map (choose 80) [0..80]
21:28:34 <lambdabot>   Not in scope: `facs'
21:28:40 <int-e> http://projecteuler.net/index.php?section=view&id=154
21:28:42 <lambdabot> Title: Project Euler
21:28:47 <Sgeo> > fac 3
21:28:51 <davidL> @where haskell-cafe
21:28:51 <lambdabot>   Not in scope: `fac'
21:28:52 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
21:29:02 <Sgeo> wtf
21:29:09 <monochrom> > scanl 1 (*) [1..]
21:29:16 <lambdabot>        add an instance declaration for
21:29:16 <lambdabot>       (Num ((a -> a -> a) -> b -> a ->...
21:29:22 <int-e> ignore the blurb, just look at the last line ;)
21:29:23 <monochrom> > scanl (*) 1 [1..]
21:29:31 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
21:30:15 <monochrom> scanl (*) 1 [1..] is therefore a simplification of 1 : scanl1 (*) [1..].  (Why do people still resist to start from 0?)
21:30:39 <dmwit> > let fac n = foldb (*) 1 [1..n]; choose a b = fac a `div` fac b `div` fac (a - b); pascal n = map (choose n) [0..n] in pascal [80]
21:30:45 <lambdabot>   Not in scope: `foldb'
21:30:54 <dmwit> > let fac n = product [1..n]; choose a b = fac a `div` fac b `div` fac (a - b); pascal n = map (choose n) [0..n] in pascal [80]
21:31:00 <davidL> int-e: so your approach had nothing to do with the pyramid?
21:31:01 <lambdabot>   add an instance declaration for (Integral [t])
21:31:02 <lambdabot>     In the expression:
21:31:02 <lambdabot>      ...
21:31:48 <dmwit> > let fac n = product [1..n]; choose a b = fac a `div` fac b `div` fac (a - b); pascal n = map (choose n) [0..n] in pascal 80
21:31:58 <monochrom> The ancient Greeks resisted to start from 1.  They thought of numbers as starting from 2, with 0 and 1 needing distinguished treatments because 0 and 1 were not numbers.  They would write: 1 : 1 : scanl1 (*) [2..].  You see it's arbitrarily obfuscated.
21:32:04 <lambdabot>  [1,80,3160,82160,1581580,24040016,300500200,3176716400,28987537150,231900297...
21:32:47 <Sgeo> > fac 0
21:32:47 <int-e> davidL: I can't say that. but the values can be expressed in a way similar to binomial coefficients.
21:32:48 <Sgeo> > fac 1
21:32:52 <lambdabot>  1
21:32:59 <lambdabot>  1
21:33:06 <Sgeo> > fac (-1)
21:33:10 <Sgeo> > fac (- 1)
21:33:13 <Sgeo> > fac (-1)
21:33:16 <Sgeo> argh
21:33:17 <lambdabot>  Exception: List.genericIndex: negative argument.
21:33:19 <lambdabot>  Exception: List.genericIndex: negative argument.
21:33:21 <lambdabot>  Exception: List.genericIndex: negative argument.
21:33:23 <Sgeo> ..wait
21:33:38 <Sgeo> > facs
21:33:46 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
21:33:54 * Sgeo headplodes
21:34:02 <Sgeo> > zipWith (*) facs facs
21:34:10 <lambdabot>  [1,1,4,36,576,14400,518400,25401600,1625702400,131681894400,13168189440000,1...
21:34:17 <Sgeo> > zipWith (^) facs facs
21:34:25 <lambdabot>  [1,1,4,46656,1333735776850284124449081472843776,3175042373780336892901667920...
21:34:54 <int-e> Evaluating all the layers will probably take too long. (that's roughly 20000^3/6 values)
21:35:54 <Sgeo> @hoogle Bool->Bool->Bool
21:35:54 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
21:35:55 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
21:37:20 <QtPlatypus> @hoogle Bool->Bool->Bool->Bool
21:37:21 <lambdabot> No matches, try a more general search
21:37:41 <QtPlatypus> Interesting the tri-op isn't in prelude.
21:37:42 <monochrom> Why do you headplode? scanl and scanl1 are not that hard to understand.
21:38:09 <dmwit> QtPlatypus: That wouldn't be the type of the tri-op anyway.
21:38:17 <dmwit> ?hoogle Bool -> a -> a -> a
21:38:18 <lambdabot> No matches, try a more general search
21:38:50 <dmwit> Someone earlier was doing
21:39:04 <dmwit> data Pair a = a ::: a
21:39:20 <dmwit> p ? (a ::: b) = if p then a else b
21:39:39 <monochrom> That would be me and some others :)
21:40:08 <dmwit> :t (:.) -- is this already used?
21:40:12 <lambdabot> Not in scope: data constructor `:.'
21:40:46 <fax> when you do "p ? (a ::: b) = if p then a else b"
21:40:56 <fax> how does haskell decompose the LHS expression?
21:41:04 <dmwit> (?) p (a ::: b)
21:41:38 <monochrom> (?) is a function taking two parameters. In the second parameter, we use pattern matching.
21:41:47 <dmwit> i.e. if the only characters in the second word are infixables, it knows what to do.
21:41:48 <Sgeo> LHS?
21:41:56 <fax> left hand side
21:43:04 <fuzan> hmm, if I have a list of heterogeneous items, how can I revert a single item from that list back to a single item?
21:43:30 <Sgeo> .. a list of heterogeneous items?
21:43:50 <davidL> > isPrime 394823
21:43:53 <fuzan> when bringing it back down to a variable I can never use it with a function that doesn't allow for any type
21:44:00 <lambdabot>  False
21:44:20 <int-e> 11*11*13*251
21:44:27 <Sgeo> I wasn't aware that such lists were allowed..
21:44:28 <fuzan> data Foo = forall b. Foo2 b => Foo b
21:44:43 <davidL> > factors 394823
21:44:45 <fuzan> i have a packetbuffer that allows for different types of packets belonging to the battlenet class
21:44:58 <lambdabot>  [11,11,13,251]
21:45:06 <int-e> @index isPrime
21:45:06 <lambdabot> bzzt
21:45:23 <dmwit> ?index factors
21:45:24 <lambdabot> bzzt
21:45:28 <int-e> ... @let in privmsg?
21:45:29 <fuzan> however, if I ever need to specify the type of one to do some work on it, the type system ninjas me.
21:45:33 <dmwit> seems so
21:45:39 <davidL> > factors 200000
21:45:46 <Sgeo> @hoogle factors
21:45:46 <lambdabot> No matches found
21:45:54 <lambdabot>  [2,2,2,2,2,2,5,5,5,5,5]
21:46:21 <davidL> > factors 3490237843487207423
21:46:31 <lambdabot>  [13,13,14891,36713,37776749]
21:47:24 <fax> > let foldl (*) factors x = x
21:47:24 <lambdabot>  Parse error
21:47:26 <fax> ?!
21:47:27 <lambdabot> Maybe you meant: . v
21:47:29 <fax> can you do this?
21:47:43 <fax> > let foldl (*) $ factors x = x
21:47:44 <lambdabot>  Parse error in pattern
21:48:09 <dmead> > let fold (*) factors x = x
21:48:09 <lambdabot>  Parse error
21:48:12 <dmead> > let fold (*) factors x = x in x
21:48:19 <lambdabot>   Not in scope: `x'
21:48:30 <dmead> your yer gonna use a let it has to be follwed by in
21:48:44 <dmead> unless you want to add an instance
21:48:49 <davidL> > let f x = fold (*) factors x in f 10
21:48:53 <lambdabot>   Not in scope: `fold'
21:49:01 <davidL> > let f x = foldr (*) factors x in f 10
21:49:05 <dmead> > let foldr (*) factors x = x in f 10
21:49:09 <lambdabot>   add an instance declaration for (Num [a -> [a]])
21:49:12 <lambdabot>   Not in scope: `f'
21:49:29 <dmead> > let f = foldr (*) in f 10
21:49:37 <davidL> > foldb [1..1000]
21:49:41 <lambdabot>  <[Integer] -> Integer>
21:49:44 <lambdabot>   Not in scope: `foldb'
21:49:49 <davidL> what
21:49:52 <dmead> o0
21:49:54 <davidL> I miss foldb
21:49:56 <dmead> > let f = foldr (*) in f 10
21:50:02 <dmead> whats foldb?
21:50:05 <lambdabot>  <[Integer] -> Integer>
21:50:15 <davidL> @quote foldb
21:50:16 <lambdabot> dmwit says: > let foldb' op (x:y:rest) = op x y : foldb' op rest; foldb' _ e = e; foldb _ b [] = b; foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs) in foldb (*) 1 [1..1000] --
21:50:16 <lambdabot> here we go
21:51:08 <davidL> @let foldb' op (x:y:rest) = op x y : foldb' op rest
21:51:18 <dmwit> davidL: You can do it all in one ?let
21:51:18 <lambdabot> Defined.
21:51:23 <davidL> oh
21:51:45 <davidL> @let foldb' op (x:y:rest) = op x y : foldb' op rest; foldb' _ e = e; foldb _ b [] = b; foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs)
21:51:48 <lambdabot> <local>:8:0:     Warning: Pattern match(es) are overlapped              In th...
21:52:06 <davidL> lambdabot--
21:53:34 <davidL> > foldb (*) 1 [1..1000] -- x_x
21:53:39 <lambdabot>   Not in scope: `foldb'
21:53:45 <davidL> heh
21:54:18 <davidL> wait
21:54:38 <fuzan> How can one test the type of an internal type? for some type like: data Foo = forall a. Foo a
21:54:41 <davidL> so attempting to undefine one thing will erase everything else?
21:54:51 <dmwit> > foldb (*) 1 [1..1000] -- =)
21:54:57 <ddarius> fuzan: You can't.
21:55:03 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
21:55:38 <ddarius> @help undefine
21:55:39 <lambdabot> undefine. Reset evaluator local bindings
21:55:41 <davidL> dmwit: how did you undefine the one I defined ?
21:55:50 <dmwit> davidL: I didn't.
21:55:53 <davidL> oh
21:55:56 <fuzan> ddarius: so one would need to add information toe the datastructure for identifying type?
21:55:57 <dmwit> I just defined the rest of the cases.
21:56:03 <davidL> no one undefine anything!!!
21:56:16 <monochrom> > undefined
21:56:19 <davidL> > factors $ foldb (*) 1 [1..1000]
21:56:24 <ddarius> fuzan: Yes.  The easiest thing to do would be to require a to be an instance of Typeable.
21:56:28 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
21:56:32 <lambdabot>  thread killed
21:56:32 <davidL> hahaha
21:56:47 <fuzan> ddarius: hmm, i need to read more about generics / typeable.
21:56:49 <monochrom> Bad...
21:56:57 <davidL> > factors $ foldb (*) 1 [1..10]
21:57:09 <lambdabot>  [2,2,2,2,2,2,2,2,3,3,3,3,5,5,7]
21:57:25 <davidL> > group . factors $ foldb (*) 1 [1..100]
21:57:35 <lambdabot>  [[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
21:57:45 <monochrom> map head
21:57:53 <ddarius> Why not have factors return a list of pairs of ints?
21:57:53 <davidL> no there's another one
21:58:00 <davidL> wait
21:58:06 <monochrom> Because the author was too lazy.
21:58:27 <davidL> :(
21:58:38 <davidL> its better this way
21:59:13 <monochrom> map (head &&& length)
21:59:21 <dmwit> > map (head &&& length) . factors $ [330]
21:59:21 <davidL> yeah that's it
21:59:29 <lambdabot>   add an instance declaration for (Integral [a])
21:59:32 <monochrom> you're missing group
21:59:34 <dmwit> > map (head &&& length) . factors $ 330
21:59:42 <lambdabot>   add an instance declaration for (Integral [a])
21:59:52 <davidL> > map (head &&& length) . group . factors $ foldb (*) 1 [1..100]
22:00:04 <lambdabot>  [(2,97),(3,48),(5,24),(7,16),(11,9),(13,7),(17,5),(19,5),(23,4),(29,3),(31,3...
22:00:57 <monochrom> What is foldb?  Is it scanl?
22:01:06 <dmwit> It's foldr for commutative operators.
22:01:14 <dmwit> Well, semantically, that is.
22:01:21 <davidL> @tell dons lamdabots undefine needs to be fixed
22:01:22 <lambdabot> Consider it noted.
22:01:33 <ddarius> It's foldTree . listToTree
22:01:52 <dmwit> :t foldTree
22:01:55 <lambdabot> Not in scope: `foldTree'
22:02:00 <davidL> > foldTree . listToTree [1..10]
22:02:07 <lambdabot>   Not in scope: `listToTree'
22:02:09 <ddarius> That's pseudocode.
22:02:11 <dmwit> yeah
22:02:15 <davidL> oh
22:02:59 <davidL> I think we can run xmonad off lamdabot now that there is @let
22:03:18 <monochrom> That is surreal
22:03:32 <davidL> yes.
22:04:19 <fax> xmonad?
22:04:21 <fax> hm
22:04:29 <davidL> what is that?
22:05:31 <davidL> > please be my friend
22:05:33 <lambdabot>   Not in scope: `friend'
22:05:36 <fax> aww
22:05:38 <davidL> :(
22:05:40 <fax> :(
22:10:53 <fuzan> heh
22:11:01 <fuzan> ghc allows for record syntax with existentials
22:11:03 <fuzan> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
22:11:06 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/8bwuf
22:12:50 <dmwit> > second negate (3, 4)
22:12:55 <lambdabot>  (3,-4)
22:13:20 <dmwit> ?index second
22:13:21 <lambdabot> Control.Arrow
22:27:25 <dmead> ][[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\
22:27:36 <sorear> dmead: try again
22:29:22 <dmwit> Quick poll: should "divides (3%5) 3" be True or False?
22:32:10 <dmwit> dmead: Cat-like typing detected!
22:32:42 <jbauman> true
22:32:43 <MyCatVerbs> True! 3%5 evaluates to three.
22:32:43 <sorear> dons!!
22:32:58 <dmwit> > 3%5 -- Not 3!
22:33:10 <fax> > 3%5
22:33:14 <lambdabot>  3%5
22:33:15 <fax> do it
22:33:21 <lambdabot>  3%5
22:33:42 <LordBrain> @typen 3 % 5
22:33:45 <dmwit> > 6%10 -- it's a ratio
22:33:46 <LordBrain> @type 3 % 5
22:33:49 <sorear> stop it
22:33:56 <sorear> lambdabot is screwed up now
22:33:57 <lambdabot> forall t. (Integral t) => Ratio t
22:34:00 <lambdabot>  3%5
22:34:01 <lambdabot> thread killed
22:34:12 <dmwit> sorear: Okay, sorry.
22:34:16 <sorear> all you're doing is maxing out dons' cpu
22:34:39 <sorear> it's got this weird mode where ghc processess stay alive and go into infinite loops
22:34:42 <int-e> dmwit: divides shouldn't be defined for rational numbers ;)
22:34:51 <sorear> nobody has a clue what causes it
22:35:06 <sorear> but thread killed after > is a dead givaway
22:35:19 <sorear> load average should be like 20 and rising
22:35:22 <sorear> @uptime
22:35:23 <lambdabot> uptime: 6d 4h 14m 9s, longest uptime: 13d 18h 36m 21s
22:35:31 <sorear> not what i meant...
22:35:35 <sorear> @version
22:35:35 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
22:35:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:35:49 <sorear> huh.  i thought there was a load avg in the @version output
22:36:26 <dmead> 766666666
22:36:26 <int-e> dmwit: but if you have to define it I guess 'the result is an integer' is the most useful definition.
22:36:39 <dmwit> sorear: But you yelled at us before "thread killed" even appeared?
22:36:49 <fax> he didnt yell :/
22:36:54 <dmwit> int-e: I agree, that's what I ended up doing.
22:37:02 <fax> just because someone tells you to do somting doesnt mean they are yelling
22:37:10 <sorear> dmwit: It appeared, just not in #haskell
22:37:13 <dmwit> o
22:37:29 <sorear> lambdabot failing in #xmonad usually means it won't work here ;)
22:39:30 <fuzan> hmm. i'm not seeing how Typeable helps me get to an existential type.
22:41:05 <dmwit> davidL: Do you know the binomial theorem?
22:41:20 <davidL> dmwit: yeah
22:41:34 <davidL> did he just derive it from that?
22:41:36 <dmwit> davidL: You can use that to derive a theorem for (x+y+z)^n pretty easily.
22:41:41 <davidL> ohh ok
22:41:49 <davidL> I thought he derived it from scratch or something
22:41:51 <dmwit> Note that (x+y+z)^n = (x+(y+z))^n and go from there.
22:42:54 <sorear> You want to know how I derived the trinomial thm?
22:44:25 <fuzan> :t cast
22:44:34 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
22:47:58 <int-e> fuzan: what do you want to do?
22:50:18 <cinimod> @help
22:50:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:51:16 <fuzan> int-e: i'm using heterogeneous lists and I'm trying to pull down elements to their real type
22:54:44 <fuzan> int-e: so, I perform a function "takeBuffer" with type "forall a. Foo a => MBot Packet a" , and now I'm trying to utilize the result in an action that doesn't support the existential type
22:54:45 <int-e> fuzan: you can pattern match on the Box (I think you called it Foo) and then use the value; obviously you can only use the class dictionary that you packed with it. - note, there was a recent change in ghc which is related, it's possible that you need the darcs head ghc to make this work properly. I don't know.
22:56:19 <fuzan> int-e: you mean something as simple as, (Packet p) <- takeBuffer 0x50 ? how would it know the type of p?
22:56:42 <fuzan> oh, i think I see wha tyou're saying.
22:56:47 <int-e> fuzan: it doesn't. But it knows that it comes with a Foo2 dictionary
22:56:59 <int-e> (going by data Foo = forall b. Foo2 b => Foo b)
22:58:15 <fuzan> int-e: is there no method for coercing the type?
22:58:53 <int-e> fuzan: if you know the type, Data.Typeable is a way to convince the compiler of that.
22:59:12 <fuzan> int-e: i've been reading various documentation trying to figure out how to use Typeable :)
22:59:17 <fuzan> the best I was able to find was "cast"
22:59:59 <fuzan> the main papers off the page seem to be broken (linkwise)
23:00:58 <int-e> say you have data Box = forall b . Typeable b => Box b;  now you have a certain Box that you know contains an Int. Then, you can do  f (Box foo) = let Just x = cast foo :: Maybe Int in <use x as an Int>
23:01:33 <int-e> (note that if the type wasn't Int then you'll get a pattern match failure at runtime)
23:01:47 <int-e> because cast will return Nothing then
23:02:12 <fuzan> int-e: heh, that's almost what I've got written now. I've been messing with other errors :)
23:02:20 <fuzan> int-e: alright, thanks a ton. i'll keep hacking away at this ;)
23:05:14 <fuzan> int-e: sadly as a beginner I get so excited when my Haskell code compiles. It's roughly similar to experiencing C code not segfault.
23:05:44 <int-e> fuzan: well normally the code won't segfault then :)
23:06:04 <ddarius> Normally...
23:06:39 * int-e has been playing with unsafeCoerce# which resulted in a few segfaults ;)
23:10:04 <ClaudiusMaximus> @quote segfault
23:10:04 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
23:23:32 <fuzan> for some odd reason, would typeable and cast require Data.Binary.put ?
23:24:49 <int-e> @type Data.Typeable.cast
23:24:51 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
23:24:56 <int-e> no.
23:25:19 <fuzan> Bnet.hs:291:0: No instance nor default method for class operation Data.Binary.put
23:26:01 <fuzan> and I'm not accidentally invoking anything that may try to put on a type that doesn't provide it
23:26:13 <int-e> that's a warning.
23:26:21 <fuzan> no, it's a runtime error ?
23:26:49 <int-e> oh hmm.
23:27:10 <fuzan> that's why I'm stumped.
23:27:41 <fuzan> if I change from patternmatching to a fromJust on the cast, it errors differently.
23:28:10 <fuzan> ah, I think I know the problem.
23:28:35 <int-e> fuzan: right, the warning and the exception have identival messages. (which makes sense)
23:47:36 <DRMacIver> Morning
