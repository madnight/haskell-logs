00:10:32 <quicksilver> HairyDude: nothing wrong with read's speed on a simple job like int parsing
00:11:13 <quicksilver> HairyDude: you wouldn't do much better than it unless your input format wasn't Streing at all (but, e.g. ByteString)
00:18:07 <jim_>  I have an annoying problem...... i used  a deb package to install ghc, but i installed gtk2hs via source, and the ghc is apparently not configured to read packages from /usr/local ....  So it doesn't see my gtk2hs
00:19:08 <jim_> the config file is apparently a huge haskell type that ghc just reads in using read.
00:19:27 <dons> hmm. did you regitser gtk2hs?
00:19:32 <dons> I think there's a 'make register' target.
00:19:52 <jim_> does that come after install?
00:19:56 <dons> anyway, you can check if the package is registered with ghc-pkg list
00:20:08 <dons> also, are you using --make or -package gtk2hs ?
00:20:26 <jim_> ./configure; make; make install; make register ?
00:20:37 <jim_> i tried either
00:20:53 <jim_> I'd like to set it up to just do --make tho
00:21:01 <dons> I think gtk2hs has a 'make register' target, which calls ghc-pkg to register the library with ghc
00:21:04 <dons> check the docs.
00:21:12 <dons> once gtk2hs is registerd, --make will work
00:22:33 <HairyDude> I think it's probably blowing stack simply because the representation of the data is so large (doing arithmetic with peano numbers)
00:22:48 <Heffalump> HairyDude: what is?
00:23:24 <HairyDude> my memoized Fibonacci function
00:23:31 <Heffalump> ah
00:24:12 <jim_>  the docs make it sound like it registers automatically unless you tell it not to
00:25:31 <HairyDude> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in sum (take 36 fibs)
00:25:34 <lambdabot>  24157816
00:25:53 <dons> jim_: hmm. is it listed by: ghc-pkg list ?
00:26:11 <HairyDude> so if it takes 1 byte per object, it takes 24 megs to calculate the 35th Fibonacci number
00:27:18 <jim_> ghc-pkg doesn't send to stdout, that's annoying
00:27:26 <Heffalump> 1 byte per object sounds optimistic
00:27:30 <HairyDude> yes
00:27:38 <HairyDude> more likely 4
00:27:51 <HairyDude> or 8 on a 64 bit machine
00:27:55 <dons> jim_: hmm. sure it does.
00:28:01 <dons> $ ghc-pkg list > x
00:28:01 <dons> $ cat x
00:28:01 <dons> /home/dons/lib/ghc-6.6/package.conf:
00:28:02 <dons>     BinaryByteString-0.1, Cabal-1.1.6, Cabal-1.1.7,...
00:28:34 <jim_> hmmm i guess its my terminal doing something funky to me
00:28:48 <jim_> anyway its not in there
00:29:47 <dons> ok. so it didn't register.
00:29:56 <dons> check if there's a 'make register' target for gtk2hs.
00:30:03 <dons> and then talk to dcoutts, when he wakes up.
00:30:16 <jim_> well, this is an old install
00:31:02 <osfameron> hi: I just asked on #haskell, but I think it's maybe on topic here too
00:31:06 <Heffalump> I think dcoutts is in Cambridge (for Fun in the Afternoon); dunno if he'll be online this morning.
00:31:12 <Heffalump> osfameron: this is #haskell..
00:31:17 <osfameron> what markup system do you guys use to prepare a blog post on haskell before posting
00:31:21 <osfameron> er
00:31:23 <dons> hehe.
00:31:24 <osfameron> s/haskell/haskell-blah
00:31:26 <osfameron> good catch
00:31:33 <dons> HsColour is good for syntax hl
00:31:41 <osfameron> I could have meant #haskell for perlers... but sadly I didn't
00:31:51 <dons> I tend to use html + hscolour. that's all.
00:32:00 <osfameron> how do you hscolourify those bits?
00:32:01 <osfameron> manually?
00:32:15 <dons> nah, i've a script.
00:32:16 <dons> $ cat bin/colour
00:32:16 <dons> #!/bin/sh
00:32:16 <dons> tmpf=`mktemp`
00:32:16 <dons> cat > $tmpf
00:32:18 <dons> HsColour -css $tmpf | sed '1,8d;$d;s/<\/body>//'
00:32:21 <dons> rm $tmpf
00:32:30 <dons> so from vim, I colourise with !colour
00:32:41 <osfameron> ah!  I see
00:32:55 <osfameron> but once it's colourised you can't easily go back and edit the source of the haskell ?
00:33:01 <dons> right.
00:33:12 <dons> Tom Moertel wrote a script for his blog that dynamically coloursies on the way out
00:33:28 <osfameron> I was looking at something like POD formatting:  if para is indented, mark up as code, otherwise html
00:33:29 <dons> check his blog, here, http://blog.moertel.com/
00:33:37 <lambdabot> Title: Tom Moertel's Weblog
00:33:40 <osfameron> ta
00:33:54 <dons> yeah, so you could write your own little post-processor to take <haskell> </haskell> blocks, and pipe them into HsColour -css $tmpf | sed '1,8d;$d;s/<\/body>//'
00:34:05 <dons> depends on the blog software you use.
00:34:18 <osfameron> well, I'm using Vox, so not really hackable
00:34:27 <osfameron> but I can preprocess on lappy before I post
00:34:41 <dons> yeah, just a script that generates the final version offline would be enough.
00:35:06 <dons> here's Tom's article on colour, http://blog.moertel.com/articles/2006/11/01/adding-haskell-syntax-highlighting-to-the-typo-blogging-system
00:35:08 <lambdabot> Title: Adding Haskell syntax highlighting to the Typo blogging system, http://tinyurl.com/2b4ovk
00:35:52 <osfameron> cool, thanks
00:39:58 <osfameron> what is the sed invocation for ?
00:40:39 <osfameron> ah.  chop the first last lines.  get rid of the closing body tag
00:41:08 <osfameron> really would be better for HsColour to have a "just gimme this as a snippet" option, which I could patch in (possibly, for my haskell is feeble)
00:57:14 <BSP> hi, i was wondering if there was such a library function that let you express "foldl with early return", i.e. something like "(a -> b -> Either a a) -> a -> [b] -> a", where returning Left stops foldl continuing down the list?
00:59:52 <dons> unfoldr ?
01:00:07 <dons> :t unfoldr
01:00:09 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:00:23 <dons> certainly lets you short circuit.
01:01:20 <BSP> hmm, i'm trying to see how that would work..?
01:01:58 <BSP> it looks like Control.Monad foldM would do what I want, if Either had a monad instance and Left was failure
01:02:20 <dons> which it is, yes.
01:02:28 <dons> import Control.Monad.Error for the Either monad instance
01:02:38 <BSP> ah, cool.. i couldnt find it on hoogle
01:02:41 <dons> :t until
01:02:44 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
01:03:03 <dons> is related as well, apply a function repeatedly, till predicate is false
01:03:47 <dons> Prelude Control.Monad.Error> foldM (\x y -> if x == y then Nothing else Just (x+y)) 10 [1..10]
01:03:50 <dons> Just 65
01:03:50 <BSP> with unfoldR you mean something like taking the last element of "unfoldr (\x:xs -> ...) myList"?
01:04:29 <kaol> > unfoldr (\x -> do guard (x>1); return (x/2, x/2)) 42
01:04:30 <lambdabot>  [21.0,10.5,5.25,2.625,1.3125,0.65625]
01:04:46 <dons> nice kaol
01:04:55 * araujo wonders what would be the reason for the interactiveCommand function to not return a proper output value at the first run but in the second
01:05:06 <BSP> mm, nice
01:05:12 <BSP> until.. ok, thanks dons!
01:05:22 <dons> uses the Maybe monad instance. bit under-exploited with unfoldr.
01:05:25 <araujo> dons, idea? ^^
01:05:32 <dons> its a cute corner you found there, kaol
01:05:38 <dons> araujo: don't know.
01:05:53 <araujo> ok
01:06:04 <araujo> i remember i found a bug report about this behaviour somewhere ... mm...
01:17:08 <quicksilver> BSP: I doubt that foldM with the Either instance is what you want
01:17:16 <quicksilver> BSP: it's going to abort when it sees the first Left
01:17:24 <quicksilver> BSP: but it's going to end up returning that Left value
01:17:28 <quicksilver> BSP: you'll lose your computation
01:17:44 <dons> hmm. Left acc / Right acc ? :-)
01:17:49 <dons> its a bit sneaky
01:17:52 <quicksilver> ah, true
01:17:56 <dons> oh, though the Monad instance is for String though, isn't it?
01:17:57 <quicksilver> you could embed the computation in the left bit too
01:18:04 <quicksilver> well it's for Error e
01:18:04 <dons> ?src fail Either
01:18:05 <lambdabot> Source not found. I feel much better now.
01:18:09 <dons> yeah.
01:18:13 <quicksilver> but you could fake that out :)
01:18:19 <dons> urgh :}
01:18:29 <quicksilver> the 'String' equivalence is only needed if you actually need to use "fail"
01:18:37 <quicksilver> as long as you don't use "fail" it isn't needed
01:18:40 <dons> ah yes.
01:18:45 <BSP> mm, i've just run into this problem...
01:18:52 <BSP> i need my own Either instance i guess..
01:19:06 <quicksilver> BSP: as dons says, you can keep the data in the 'Left' too
01:19:19 <dons> i'd just write a loop, I suppose. though its a little old we don't have a short-circuiting foldl/r, like unfoldr
01:19:22 <dons> oh, scanl/scanr.
01:19:51 <dons> yeah, maybe scanr would be enough.
01:19:57 <quicksilver> :t scanr
01:19:59 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
01:20:05 <dons> return all results, filter out those you don't want
01:20:14 <quicksilver> last . takeWhile (something) . scanr
01:20:15 <quicksilver> you mean?
01:20:19 <dons> yeah
01:20:22 * quicksilver nods
01:20:25 <quicksilver> yes, I've used that style
01:20:56 <quicksilver> well actually, I've used it with scanl
01:21:06 <quicksilver> doesn't scanr have to 'go and find the end of the list' before it starts?
01:21:20 <dons> yeah, a bit too hard :)
01:21:53 <quicksilver> > scanr (++) [] ["apple","pear","plum"]
01:21:54 <lambdabot>  ["applepearplum","pearplum","plum",""]
01:22:04 <quicksilver> yup, that's not what you want :)
01:22:06 <quicksilver> scanl it is
01:23:04 <jyp> dons: I've prepared this release for Yi...
01:23:06 <jyp> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Editor
01:23:09 <lambdabot> http://tinyurl.com/yqov7f
01:23:14 <jyp> tell me what you think :)
01:23:19 <dons> woo!
01:23:21 <BSP> going back to foldM, i was always going to put the data in Left, but probably for some silly reason this dosent work
01:23:22 <BSP> > foldM (\a b -> if (a > 100) then (Left a) else Right (a + b)) [1..100]
01:23:23 <lambdabot>   add an instance declaration for (Num [t])
01:23:29 <dons> jyp, you should solicit some more testers in here.
01:23:35 <BSP> uh, yeah, that is silly
01:23:36 <jyp> sure
01:23:43 <BSP> > foldM (\a b -> if (a > 100) then (Left a) else Right (a + b)) 0 [1..100]
01:23:44 <lambdabot>  Add a type signature
01:23:47 <jyp> that's what I'm doing :)
01:23:54 <dons> :)
01:24:10 <jyp> Folks, please test http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Editor before I announce :)
01:24:11 <lambdabot> http://tinyurl.com/yqov7f
01:24:23 <Korollary> ah
01:24:28 <Korollary> So this is where Yi lives now
01:24:41 <jyp> Just tentatively
01:24:53 <jyp> Well I think it should reside on hackage
01:24:59 <Korollary> Do I need both Yi and yi-vty?
01:25:05 <jyp> yes
01:25:16 <jyp> or yi-gtk if you prefer that type of stuff
01:25:20 <Korollary> Ah, it even says so there
01:26:08 <Korollary> Isn't it possible to merge all three into one and either have cabal hooks or autoconf to control the build?
01:26:37 <jyp> Korollary: You are very welcome to send patches :)
01:26:52 <dons> jyp, yeah, it should be uploaded to hackage once its tagged and tarballed
01:27:17 <quicksilver> BSP: this is the error you should get:
01:27:18 <jyp> but seriously, I can't seem to find a way to group the packages in one thing.
01:27:19 <quicksilver> > foldM (\a b -> if (a > 100) then (Left a) else Right (a + b)) 0 [1..100] :: Either Int Int
01:27:20 <lambdabot>   add an instance declaration for (Error Int)
01:27:20 <lambdabot>     In the expression:
01:27:20 <lambdabot>         ...
01:27:37 <quicksilver> BSP: but fortunately it's not hard to write an instance for Error Int
01:27:53 <Korollary> If I can manage to build it, I'll think about it.
01:29:17 <Korollary> Is it me or are these tar.gz's somewhat empty?
01:30:55 <jyp> Korollary: indeed
01:31:31 <jyp> I don't quite get what went astray
01:31:46 * jyp is back to work
01:35:33 <jyp> Something is quite wrong with cabal sdist
01:36:49 <Lemmih> jyp: Did it try to invade Estonia again?
01:37:37 <jyp> Lemmih: I'm not sure what you refer to... but I think not :)
01:38:00 <dons> hehe "medical workers and computer techniciansthe professional troubleshooters of the worldkeep our bodies and mainframes running by being paragons of pessimism.
01:38:03 <dons> "
01:38:14 <dons> hehe, code sucks, we suck. it is all bugs
01:38:23 <dons> please please give me a type system.
01:39:05 <Lemmih> jyp: Phew, that's good. It unfortunately takes our creed of world domination quite serious.
01:39:25 <dons> hehe
01:39:52 <dons> Lemmih: I think that's the funniest thing you've ever said :-)
01:42:48 <jyp> Ok, despite the high ambitions of our tool, it seems completely unable to handle the kind of thing I wants it to do.
01:43:02 <jyp> Namely, refer to source files in parent directories
01:43:45 <jyp> This is very unfortunate, because if you combine that with the fact that you can have only one cabal file per directory
01:43:53 <jyp> and only one library per cabal file
01:44:24 <jyp> is makes rather impossible to distribute the same source file in 2 packages.
01:45:52 <Heffalump> why can't you just refer to them with ..?
01:46:07 <Heffalump> Visual Haskell crashes if you do that, but apart from that it worked fine when I did it.
01:46:49 <jyp> Heffalump: everything is ok with that, except the sdist does not manage to put the files in the tarball
01:47:09 <Heffalump> ah, right. I never used it that far.
01:47:26 * Heffalump finds cabal very restrictive, in part for the reasons you describe.
01:47:46 <Heffalump> it's nice that it provides a standard way to install people's stuff, but it's a pain to use for your own projects
01:48:35 <osfameron> oooo!  Haskell workshop in Freiburg!
01:48:37 <osfameron> I liek Freiburg
01:51:48 <BSP> quicksilver: ok, so i >do< have to write my own error instance :( shame this is not in the stdlib.. thank anyway
01:52:31 <quicksilver> BSP: it's a bit illogical, to be honest
01:52:39 <quicksilver> BSP: the only reason for the error instance is to make 'fail' work
01:52:46 <quicksilver> BSP: you can just do a dummy instance
01:54:54 <BSP> right, so now i have two instances of Monad Either in scope.. one from Control.Monad.. can I tell it not to import that somehow?
01:55:19 <quicksilver> I actually wasn't suggesting a new instance of Monad
01:55:25 <quicksilver> just an instance of Error int
01:55:34 <quicksilver> tbh, I'd make my own data type 'like Either'
01:55:49 <quicksilver> data Shortcut a = Stop a | Continue a
01:55:50 <quicksilver> ?
01:56:05 <BSP> hmm, nice idea
01:56:09 <BSP> thats easier to read as well
01:56:11 <quicksilver> and then a monad instance... return = Continue; bind = case of Stop ...  etc
01:56:33 <quicksilver> not sure if shortcut is the right name
02:06:49 <MarcWeber> Did I miss a point or is cabal only capable of registering with the user/ system package database by now?
02:09:03 <david48> is it normal that building yi fails with *** Exception: failed to extract ghc path from command line: use --with-ghc=<GHC_PATH>
02:09:32 <Heffalump> is ghc on your path?
02:09:35 <david48> yes !
02:09:39 <Heffalump> what OS?
02:09:46 <david48> Linux
02:09:50 <Heffalump> (I dunno about yi, but it's not normal for Cabalised things)
02:09:53 <david48> Kubuntu feisty actualy.
02:10:00 <david48> I can provide the configure output
02:10:11 <david48> it's not that long.
02:10:38 <MarcWeber> david48: hpaste.org or something similar ;)
02:10:50 <david48> ok, I'll hpaste it :)
02:11:30 <hpaste>  david48 pasted "building yi fails" at http://hpaste.org/1871
02:13:38 <MarcWeber> david48: That's a stupid advice, but maybe export PATH works?
02:14:02 <MarcWeber> It will need some time till I have downloaded all the patches to try it
02:14:59 <david48> you mean typing export PATH then runghc Setup.hs configure ?
02:15:17 <david48> I'm not sure what it would change, but tried it and same output and result
02:15:26 <quicksilver> PATH is exported by default
02:15:38 <quicksilver> you don't need to export things which are already exported, IYSWIM
02:15:39 <MarcWeber> @quicksilver Didn't know that.
02:15:39 <lambdabot> Unknown command, try @list
02:15:46 <MarcWeber> quicksilver Didn't know that.
02:16:24 <david48> I could of course get it to build by giving the --with-ghc=<GHC_PATH> option, but I think it's not normal it doesn't configure without the option since ghc in is the patch and it's even detected by configure
02:16:53 <david48> <- path
02:17:03 <david48> not patch. typo... my bad.
02:20:42 <jyp> david48: I don't know how to use the autodetected ghc path; for now the --with-ghc is mandatory
02:20:54 <jyp> but don't bother; because the archive is otherwise empty
02:21:16 <jyp> I'll give updates whenever I got a fix.
02:21:23 <david48> :) how do I test it then ?
02:21:47 <david48> I thought you wanted people to test it :)
02:22:01 <jyp> Just wait a moment... thanks for helping :)
02:22:14 <david48> No worries !
02:29:49 <mdmkolbe|wor1> is there a foldr or foldl that also returns the intermediate results?
02:30:59 <MarcWeber> jyp: The simple way is using the functions to get ghc path it's using itself (lookupProgram / findExecutable) .. There might be better ways but it should work ;)
02:31:36 <quicksilver> mdmkolbe|work: yes, scanl/r
02:31:51 <quicksilver> > scanl (*) 1 [1..]
02:31:55 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
02:32:00 <jyp> MarcWeber: do you think you could provide a patch?
02:32:35 <MarcWeber> Wait some minutes
02:32:50 <mdmkolbe|work> quicksilver: perfect, thx
02:32:51 <jyp> MarcWeber: many many thanks!
02:32:56 <mdmkolbe|work> @index scanl
02:32:56 <lambdabot> Data.List, Prelude
02:34:27 <BSP> is the nomaware monad tutorial at "http://www.nomaware.com/monads/" down for anyone else..? its a shame if it is, it was excellent..
02:34:32 <desp> hmm.
02:34:41 <desp> does Haskell have automatic memoization of function results?
02:34:56 <yakov> hi
02:35:06 <jyp> desp: no
02:35:17 <MarcWeber> jyp Wait. It's much more easy
02:35:31 <MarcWeber> jyp: Do you have Cabal sources ?
02:35:37 <jyp> yes
02:35:40 <Ogedei> A while ago I saw some program that processes source files and automatically adds type declarations, but now I can't find it anymore. Anyone know what it was called?
02:35:45 <yakov> cool. it's a official place of functional discussions on irc?
02:36:34 <quicksilver> yakov: well haskell dicussions techincally
02:36:44 <quicksilver> yakov: but general functional topics get discess from time to time
02:36:59 <quicksilver> desp: that's a *very* hard problem to get right automatically
02:37:07 <MarcWeber> jyp: If you have a look at Distribution/Simple/Configure.hs (line 242) There the Compiler flavor is printed. f' is defined some lines above. The whole configure function returns a LocalBuildInfo containing a field compiler holding the path to the compiler
02:37:08 <quicksilver> desp: haskell makes it pretty easy to memoize yourself, though
02:37:21 <desp> quicksilver: with the appropriate monad?
02:37:26 <MarcWeber> jyp: And the LocalBuildInfo is accesible from setup.hs
02:37:30 <quicksilver> desp: that's not how I'd do it, no
02:37:35 <quicksilver> desp: although somebody did write something like that
02:37:55 <desp> quicksilver: how'd you do it, then? do you have something you could point me to?
02:37:59 <quicksilver> desp: the simplest way is just to access the function via an array
02:38:23 <quicksilver> since array's values are calculated lazily, the function isn't called until needed
02:38:29 <jyp> MarcWeber: thanks very much for the analysis :) Would you patching?
02:38:33 <quicksilver> but then once it's called, the value is there in the array for next time
02:38:37 <jyp> would you care patching?
02:38:45 <desp> quicksilver: ah, I see.
02:38:50 <MarcWeber>  jyp Still reading cabal source ;)
02:39:00 <jyp> MarcWeber: aye! ;)
02:40:01 <quicksilver> desp: that impies you have some idea about the range which will be called before hand
02:45:00 <quicksilver> desp: http://haskell.org/hawiki/MemoisingCafs
02:45:01 <lambdabot> Title: MemoisingCafs - The Haskell Wiki
02:45:37 <desp> thanks
02:45:43 <desp> reading also a few other pages
03:00:49 <joelr1> good morning
03:03:24 <_case> hello, is it possibly to use the map function and specify two arguments? one is a list of string, the other a string which is always the same
03:03:34 <_case> s
03:03:59 <DRMacIver> How do you mean?
03:04:17 <_case> i wan't to call a function, N-times the length of the string list
03:04:36 <_case> and with a second argument, the "constant" string
03:04:51 <_case> i have aantalGoed :: [String] -> String -> Int
03:05:00 <_case> which has to be called
03:05:14 <mdmkolbe|work> _case: do you mean like "map (flip aantalGoed "str") list"?
03:05:35 <_case> hmm depends what flip does :)
03:05:42 <mdmkolbe|work> @src flip
03:05:42 <lambdabot> flip f x y = f y x
03:06:04 <_case> hmm that could be right
03:06:18 <_case> let me try
03:10:23 <_case> mdmkolbe|work: i think you were right, just have to put the things together, tnx :)
03:12:23 <mdmkolbe|work> _case: depending on how much you want to assume from your readers "map (\x -> aantalGoed x "str") list" also works.  One way might be clearer to some than the other (for me it depends on my mood and the context of the code).
03:13:27 <DRMacIver> But point free solutions are inherently cooler. ;)
03:14:34 <int-e> unless they involve too many dots
03:14:52 <_case> mdmkolbe|work: i agree
03:15:51 <int-e> @pl \a b c d -> d (b a) c
03:15:51 <lambdabot> ((flip . flip id) .) . flip id
03:17:01 <quicksilver> I don't much like flip
03:17:13 <quicksilver> I find the explicit lambda expression perfectly clear
03:17:18 <quicksilver> and only a couple of chars longer
03:17:35 <quicksilver> 3 chars longer, it looks like
03:17:51 <quicksilver> but in more complex cases the flip gets progressively uglier
03:18:23 <Heffalump> <aol>
03:19:25 <quicksilver> and the lambda solution scales well
03:22:38 <int-e> how about  aantalGoed `flip` "str"
03:24:37 <quicksilver> int-e: that's rather cute for the 2-arg case
03:24:48 <quicksilver> int-e: but I maintain that lambda scales better :)
03:25:06 <int-e> quicksilver: yes, I agree.
03:26:19 <hpaste>  Marc Weber pasted "yi find ghc ugly patch @ jyp" at http://hpaste.org/1872
03:27:59 <MarcWeber> jyp: I think you have to test it. I could compile those 4 module but when starting yi I'm getting Failed to load interface for `Yi': Use -v to see a list of the files searched for.
03:28:27 * earthy still likes flip though
03:29:56 <quicksilver> earthy: I think it's fine in, e.g. foldr (flip (:))
03:30:06 <MarcWeber> @tell jyp http://hpaste.org/1872
03:30:06 <lambdabot> Consider it noted.
03:30:10 <quicksilver> earthy: but I don't realaly like it as a tool for out-of-order partial applications
03:30:18 <earthy> that's exactly where it is useful
03:45:12 <jyp> MarcWeber: thanks! I'm off to lunch now.
03:45:12 <lambdabot> jyp: You have 1 new message. '/msg lambdabot @messages' to read it.
03:50:43 <ivanm> hey everyone, just got a quick questions:
03:51:01 <quicksilver> let's hope we have a quick answers!
03:51:09 <ivanm> when profiling, should I use the different flags like -O2, or just use the default options?
03:51:12 <ivanm> quicksilver: heh
03:51:28 <quicksilver> I think it's safe to us -O2
03:51:35 <quicksilver> optimisation can confuse profiling, of course
03:51:40 <quicksilver> but it tries to be clever enough
03:51:43 <ivanm> *nod* yeah, that's why I was asking
03:51:52 <quicksilver> if you don't *need* -O2 to run sensibly you could leave it off
03:51:57 <ivanm> whether its a more realistic scenario to use it with or without compilation options
03:51:59 <quicksilver> but some code needs -O2 or it's horrible...
03:52:11 <ivanm> yeah, without -O2 its too slow
03:52:20 <quicksilver> the profiling is supposed to be clever enough to give results even with O2 on
03:52:25 <Cheery> Why Mathama Gandhi has been so correct about winning?
03:52:36 <Cheery> why that sentence seems to keep it's guts?
03:53:03 <quicksilver> why main verbs are not in right place being used?
03:53:56 <Pastorn> someone mentioned my name but x-chat has scrolled that away, does lambdabot keep track of when someone mentions someone else?
03:54:06 <quicksilver> nope
03:54:19 <Pastorn> @where log
03:54:19 <lambdabot> I know nothing about log.
03:54:20 <DRMacIver> But the channel is publically logged, so...
03:54:22 <quicksilver> you could search through the logs though
03:54:22 <Cheery> *mahatma
03:54:23 <Pastorn> @where logs
03:54:23 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
03:54:46 <Cheery> quicksilver: because I suck in english
04:01:44 <quicksilver> Cheery: sorry, I didn't mean to be harsh :)
04:02:05 <quicksilver> Cheery: it was the poetry of the way the two sentences lined up that caught my eye
04:04:49 <Cheery> I didn't notice any kind of harshness ;) But anyways, I'm wondering how did he know that stuff keeps it's guts
04:05:18 <Cheery> I wonder what makes it keep it's guts often
04:14:14 <liber> Just a question: why is recursion so much slower than iteration? (I used C to compare them)
04:14:30 <mauke> liber: because your C compiler sucks
04:15:00 <quicksilver> because the traditional C way to compile recursion involves building up massively deeply nested stack frams
04:15:03 <mauke> get a better C compiler
04:15:03 <liber> what I really meant was: I used c++ with gcc
04:15:09 <quicksilver> it doesn't really work like that in haskell though
04:15:14 <mauke> did you use -O2?
04:15:16 <liber> oh
04:15:21 <liber> mauke: no
04:15:24 <mauke> hahaha
04:16:09 <liber> mauke: My c++-skills are... dreadful... So i havn't had a reason to learn g++ :)
04:16:22 <mauke> then why are you writing benchmarks in C++? :-)
04:16:24 <Cheery> liber: each time you recurse, you generate a call -instruction
04:16:30 <Lemmih> liber: There are no theoretical reasons recursion should be slower than iteration.
04:16:41 <Cheery> it adds the address to stack, which is later extracted by ret
04:16:50 <liber> So this "problem" does not exist in haskell?
04:17:04 <Cheery> oh, thus values too, if I remember well the C's calling conventions :)
04:17:08 <mauke> liber: yes, haskell has no loops
04:17:15 <liber> :)
04:17:29 <liber> How about stack overflows?
04:17:41 <mauke> yeah, you can get that
04:17:41 <ttt-> whats g++?
04:17:44 <quicksilver> haskell has stack overflows, under some circumstances
04:17:47 <quicksilver> ttt-: a C++ compiler
04:17:48 <mauke> ttt-: gnu c++ compiler
04:17:52 <ttt-> oh
04:17:54 <Cheery> liber: haskell turns most of recursion into loops
04:17:58 <ttt-> i thought some new language
04:18:01 <Cheery> implicitly
04:18:19 <liber> That was the answer I wanted :) Thx...
04:18:23 <quicksilver> Cheery: but even if it didn't
04:18:31 <quicksilver> Cheery: lazy evaluation still doesn't work like that
04:21:35 <Cheery> quicksilver: oh yeah, I get the idea. :)
04:23:20 <Cheery> because lambda is evaluated before it's value is required, the stack shouldn't fill as fast even if it'd do nothing
04:23:36 <Cheery> or at all
04:25:25 <Cheery> while in imperative code, instruction is evaluated when an another instruction has branched on it
04:26:17 <quicksilver> in haskell you get space leaks with unevaluated thunks
04:26:23 <quicksilver> but not from recursion itself, per se
04:26:34 <quicksilver> because what in C would be the stack, is in fact the heap
04:26:41 <quicksilver> and it's garbage collected as you go along
04:26:44 <quicksilver> (basically)
04:27:42 <Cheery> and that's why you need seq if you ever need it
04:31:07 <ivanm> @hpaste
04:31:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:31:59 <dons> mm, new code, http://turing.une.edu.au/~bsinclai/code/libmpd-haskell.html
04:31:59 <lambdabot> Title: libmpd-haskell
04:32:16 <hpaste>  ivanm pasted "Errors when compiling for profiling" at http://hpaste.org/1873
04:32:48 <yakov> guys, is it possible to call out haskell code *from* obj-c one?
04:32:57 <quicksilver> yakov: yup
04:33:07 <yakov> I want to prepare my parser using Haskell's parser combinators...
04:33:08 <quicksilver> yakov: well, via C-calling conventions
04:33:13 <yakov> OK
04:33:15 <quicksilver> yakov: the FFI goes both ways
04:33:38 <yakov> I've already checked out HOC project though..
04:33:56 <dons> yeah, talk to ozone or wolfgangt about how best to do this.
04:34:38 <nominolo`> @seen dcoutts dcoutts_
04:34:38 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts last spoke.
04:36:02 <Cheery> does somebody of you have a directory full of .png:s?
04:36:32 <Cheery> rather varying as possible
04:36:56 <Cheery> (varying sources, varying encoders which generated the pictures, and so on..)
04:38:42 <Hardradi> hi all
04:41:55 <amil>  I am trying to build X11-1.2 on netbsd with no luck
04:42:16 <amil> i am getting ld: cannot find -lX11, googling suggests
04:42:41 <amil> that upgrading cabal could fix this, but i have ghc-6.6.1 with
04:42:56 <amil> cabal-1.1.6.2. Any ideas?
04:44:09 <Hardradi> anyone knows good tutorial for HAppS lib?
04:44:38 <MarcWeber> Hardradi: There is one on their homepage
04:45:04 <MarcWeber> amil: You can have more than one cabal installed at the same time
04:45:28 <MarcWeber> amil: Just get the sources compile and install and use ghc-pkg hide (cabal-<old version>)
04:46:21 <amil> MarcWeber: hm, i only see  Cabal-1.1.6.2 when doing  ghc-pkg -list
04:47:03 <MarcWeber> Cheery: Have you tried using a search engine (web ? google pictures/ altavista ... ?)
04:47:08 <jyp> Ok,  a new version of the Yi packages is there to test.
04:47:23 <jyp> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Editor
04:47:27 <lambdabot> http://tinyurl.com/yqov7f
04:47:56 <MarcWeber> amil Read my second message again. I told you to get the source and compile /install it as you would doing with any other package ;)
04:48:07 <orbitz> i want to create some pictures (jpegs or png's etc), is ther ea good library for writing out to them fo rhaskell/
04:48:07 <Cheery> MarcWeber: nop, maybe I should
04:48:36 <mux> dons: are there known problems with LB at the moment?  I had to hack one file changing a Monad.Writer to Control.Monad.Writer to get the eval plugin working again, and the @let one is still broken for me
04:48:38 <amil> MarcWeber: sorry... will do that.
04:48:40 <Cheery> orbitz: nop, but I'm planning about doing such
04:48:55 <orbitz> drats
04:48:56 <Cheery> there's some graphics libraries which do that and also other as well
04:49:00 <orbitz> the rie snothign liek imagemagick wraper sor gd?
04:49:05 <orbitz> there must be gd wrapers?
04:49:20 <Cheery> ?where hackage
04:49:20 <lambdabot> http://hackage.haskell.org/trac/hackage
04:49:37 <Hardradi> MarcWeber: i know, but that that tutorial is not too good
04:49:41 <Cheery> http://hackage.haskell.org/packages/hackage.html
04:49:42 <lambdabot> Title: HackageDB: introduction
04:49:42 <Hardradi> -that
04:49:43 <Hardradi> :P
04:49:48 <dons> mux, you need to update the regex lib for @let
04:49:49 <MarcWeber> amil: This happens to me, too ;) Don't worry.
04:49:53 <dons> the mtl issue is known, I think.
04:50:22 <dons> mm, lemons markets, i wonder if this explains haskell's lack of widespread adoption... http://www.schneier.com/crypto-gram-0705.html#1
04:50:24 <lambdabot> Title: Crypto-Gram: May 15, 2007
04:50:34 <MarcWeber> Hardradi Then you may ask on their mailinglist? Contribute and make it better? Don't know any further sources
04:50:41 <dons> "With so many mediocre security products on the market, and the difficulty of coming up with a strong quality signal, vendors don't have strong incentives to invest in developing good products."
04:50:59 <MarcWeber> jyp: Can you tell me the way to compile yi? (Using make/ ./Setup ? .. )
04:51:46 <jyp> MarcWeber: from the tarballs?
04:51:51 <jyp> Normal cabal method
04:51:53 <MarcWeber> jyp: I'm missing vty
04:52:05 <jyp> ah
04:52:07 <jyp> ok
04:52:13 <jyp> I need to package the README ;)
04:52:15 <MarcWeber> jyp: What about adding this to the cabal file as well?
04:52:28 <MarcWeber> jyp: It's there. But that starts with make vim/ make emacs
04:52:45 <mux> dons: what is the regex version I should have in order for it to work?
04:53:07 <jyp> MarcWeber: what do you suggest to add to the cabal file?
04:53:07 <mux> dons: I have 0.71
04:53:29 <MarcWeber> jyp: Dependency on vty
04:53:42 <mux> dons: also, shouldn't this be added to the .cabal as a requirement?
04:53:59 <jyp> MarcWeber: well it's in the yi-vty cabal file.
04:54:51 <MarcWeber> jyp: Sorry. Have have to read the README and the other stuff first
04:55:24 <jyp> MarcWeber: no problem.
04:56:17 <jyp> Btw i'll have to go now. Hopefully I'll be back somewhere in the afternoon.
04:56:27 <jyp> Bug reports always welcome :)
04:57:50 <dons> mux, regex-compat-0.90, regex-posix-0.71, regex-posix-0.92
04:58:01 <dons> so 0.9*
04:58:15 <mux> dons: ok, thank you
04:58:29 <mux> so, regex-base too I guess
04:58:34 <mux> 0.91 everything
05:05:56 <araujo> morning
05:19:58 <helmut> Can I somehow create a selfcontained value like I have a tree which contains itself as a leaf?
05:20:58 <mux> dons: cheers, @let works now :)
05:21:11 <Syzygy-> > let xs=[1,xs] in  take 5 $ show xs
05:21:12 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
05:21:12 <lambdabot>       Expected...
05:21:49 <Syzygy-> > let xs=Right [Left 1,xs] in  take 5 $ show xs
05:21:50 <lambdabot>      Occurs check: cannot construct the infinite type: b = [Either t b]
05:21:50 <lambdabot>      ...
05:22:38 <Saizan> Syzygy-: a list can never be a member of itself, you'd need to both be a and [Ã¦]
05:22:46 <Saizan> [a]
05:22:47 <helmut> Hum. Something like this gives an infinite loop for me ..
05:23:12 <helmut> I'm propably evaluating my stuff recursiveley.
05:24:15 <Saizan> well when you have a tree as a leaf of itself you have formed a cycle, so it's quite easy to end up in a infinite recursion
05:27:24 <helmut> uhm. I fixed it for one case, but it still fails in another.
05:28:07 <helmut> let me think about it again.
05:37:03 <hpaste>  mnislaih pasted "Ennals example" at http://hpaste.org/1874
05:39:20 <amil> MarcWeber: build of X11-1.2 still fails with cabal from darcs, new error message though :)
05:48:08 <cdsmith> So it is definitely 100% true that if a module doesn't import another module, then it doesn't (directly) use any functions from that other module?
05:48:46 <int-e> you can reexport functions from modules in other modules
05:49:16 <int-e> so what do you mean by 'directly'? they're still the same function.
05:49:43 <cdsmith> okay, that is fine, though, I think.  As long as the function being used is exported by the a module in the import list.
05:50:09 <timbod> Anyone seen anything related to "tuple spaces" and haskell?
05:50:11 <cdsmith> e.g., in Java you can always use stuff by fully qualified name, even if it's not imported.  Nothing like this in Haskell?
05:50:27 <int-e> nope, nothing like that
05:50:55 <cdsmith> int-e: okay.  the #ghc folks don't like the whole safety analysis concept, so I'm looking for simpler alternayives now.
05:51:01 <quicksilver> cdsmith: no; there is an extension in ghci which lambdabot also uses
05:51:11 <quicksilver> cdsmith: but in 'standard' haskell
05:52:23 <dons> cdsmith: right. nothing is exported not in the export list, other than instances.
05:52:46 <dons> and nothing is imported, other than explicit imports, and instances, and modules reexported by modules you import.
05:52:54 <Hardradi> bb
05:52:56 <dons> so you can use the module system to enforce abstraction
05:53:29 <igli> um can i ask a favour with regards to hpaste? i'd like to recommend it to users of our channel #friendly-coders as it rocks :)
05:53:41 <cdsmith> dons: I'm more concerned about enforcing security than abstraction... instances may be used without importing the modules?
05:53:48 <dons> nope.
05:54:01 <dons> you can import M () -- which brings in just its instances
05:54:03 <cdsmith> dons: oh, good.
05:54:48 <dons> and you can import qualified, to ensure functions are used only with explicit module qualifiers.
05:54:58 <dons> we do this in lambdabot, to provide a trusted module base
05:55:07 <igli> obviously i don't want to step on any toes, or place undue strain (we only have max 30 usrs tho, and little paste)
05:55:08 <dons> > unsafePerformIO is not available -- for example
05:55:10 <lambdabot>   Not in scope: `available'
05:55:27 <dons> igli: well, I think its ok, but you'll need to check they don't use the 'announce' feature
05:55:32 <dons> which sends the pastes here.
05:55:37 <igli> sure for your channel?
05:55:39 <igli> ok
05:55:54 <igli> i won't put it in topic for now; it's in !haskell factoid
05:56:05 <dons> ok. should be fine then.
05:56:08 <igli> [13:48] <friendlyToaster> A beautiful language, check out http://haskell.org/ and http://tunes.org/~nef/logs/haskell/ to learn more or #haskell to see some lovely code -  we put the funk in funktion :) http://hpaste.org/ is the best pastebin i've ever seen.
05:56:23 <igli> is there anything you'd like to add dons?
05:56:41 <dons> hehe. that's enough I suppose.
05:56:46 <igli> cool :)
05:56:47 <dons> let me know if you want a lambdabot in there :-)
05:57:23 <igli> well if you join with that's fine :)
05:57:23 <igli> as i don't know how to control it
05:57:27 <dons> the channel is #friendly-coders ?
05:57:38 <igli> indeed sir
05:57:38 <dons> ?join #friendly-coders
05:58:08 <dons> how's that?
05:58:08 <igli> cool
05:58:08 <dons> let me know if you ever want it removed.
05:58:19 <igli> um would you mind /joining for a sec so we can see how it works?
06:00:33 <cdsmith> dons: sounds good.  I'd prefer to have the safety analysis stuff that dcoutts and sjanssen and SamB and I worked out; but it's looking a little like I'd have to fork GHC to do it. :(
06:00:33 <SamB_XP> hmm?
06:01:36 <cdsmith> SamB: I wrote a summary of what we talked about; asked folks in #ghc as sorear suggested, and did not get an initial positive response.
06:01:36 <SamB_XP> you got a response?
06:01:36 <dons> cdsmith: well, a trusted module set , plus type constraints, should give you very strong results, no?
06:01:36 <dons> but it might be better to pose the problem on haskell-cafe@
06:01:45 <cdsmith> SamB: yes.  They said to just list packages that are safe.
06:02:10 <cdsmith> dons: I'd like people to be able to write new modules and install new libraries, which complicates things a bit.
06:02:11 <SamB_XP> "just list packages that are safe".
06:02:23 <SamB_XP> um, that explains the idea very well. NOT.
06:03:00 <cdsmith> SamB: well, there wasn't really a conversation.  It was about three hours ago, and I was asleep.
06:03:00 <igli> dons: is it possible to stop lambdabot doing the url thing? we have a lot of urls in factoids
06:03:20 <SamB_XP> cdsmith: yeah. I'm just thinking they may not have been thinking straight ;-)
06:03:33 * igli is dead excited about lambdabot joining :D
06:04:02 <cdsmith> SamB: sorry, I meant modules.  That should be a little more sensible.
06:05:06 <SamB_XP> except that you need to have someone you trust make that list of modules ;-)
06:05:54 <cdsmith> SamB_XP: yeah, which is fine for trusted packages.  The problem is that there can be untrusted modules that are nevertheless known to be fine.
06:07:46 <SamB_XP> yeah
06:11:33 <timbod> It probably says in the doco somehere, but does instance Binary Int write in a platform dependent or independent fashion?
06:12:00 <SamB_XP> timbod: in the pure Binary?
06:12:25 <timbod> this one: http://darcs.haskell.org/binary/
06:12:26 <lambdabot> Title: Index of /binary
06:12:48 <quicksilver> timbod: independent I believe
06:12:52 <SamB_XP> iirc, it is portable
06:12:57 <SamB_XP> let me check
06:13:14 <quicksilver> timbod: although the primitives are there to dependent if you choose. Apparently the speedup you gain really isn't that interesting.
06:13:21 <timbod> So I can write on a big endian platform, and read on little endian?
06:13:24 <mauke> types, and is
06:13:25 <mauke> -- suitable for serialising Haskell values to disk, over the network.
06:13:54 <timbod> cool - thanks
06:15:01 <mauke> how do I understand Cont and shift/reset?
06:15:27 <Saizan> they are saved as Word64 big endian
06:19:22 <chessguy> @type Data.Map.fromList
06:19:24 <lambdabot> forall k a. (Ord k) => [(k, a)] -> Data.Map.Map k a
06:21:39 <roconnor> @where lambdabot
06:21:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
06:22:59 <stmartin> @paste
06:22:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:25:02 <igli> thanks roconnor :)
06:31:11 <MarcWeber> amil: Can't help if you don't give us more info ..
06:33:00 <roconnor> @define reified
06:33:02 <lambdabot> Undefined.
06:33:13 <roconnor> @dict reified
06:33:13 <lambdabot> Supported dictionary-lookup commands:
06:33:13 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
06:33:13 <lambdabot> Use "dict-help [cmd...]" for more.
06:33:41 <roconnor> @all-dicts reified
06:33:43 <lambdabot> *** "reified" wn "WordNet (r) 2.0"
06:33:43 <lambdabot> reify
06:33:43 <lambdabot>      v : consider an abstract concept to be real
06:33:43 <lambdabot>      [also: {reified}]
06:33:43 <lambdabot>  
06:33:45 <lambdabot> [3 @more lines]
06:39:28 <dons> hey roconnor
06:39:47 <roconnor> dons: guess what I'm reading ;)
06:39:56 <dons> hah
06:40:36 <dons> there was a great comment on reddit, that connected what we're doing in 'index' to the amazing one-hole context stuff by Conor, http://programming.reddit.com/info/1rczs/comments/c1retq
06:40:37 <lambdabot> Title: Roll your own window manager: implementing a Zipper in Haskell (reddit.com)
06:40:45 <dons> now I finally understand what Conor's paper was all about :}
06:40:53 <matthew_-> how do you write the code so that other people can say "deriving (Foo)" on a data decl and Foo is your class?
06:41:10 <dons> hmm. you can't derive non-builtin classes
06:41:15 <dons> without using an external tool
06:41:23 <matthew_-> suxors
06:41:42 <dons> how would it work?
06:41:50 <Saizan> you can write a derivation for them with ndm's derive and then use $(derive makeFoo ''Type)
06:41:52 <hpaste>  stmartin pasted "Matching Either" at http://hpaste.org/1875
06:41:54 <dons> i guess some classes have obvious derivable implementations.
06:42:05 <matthew_-> Saizan: yeah, TH is all that I've come up with either
06:42:07 <stmartin> I have a problem with my first use of case to match an Either
06:42:08 <dons> yeah, or use DrIFT, or SYB techniques (we do this for deriving  Binary)
06:42:15 <dons> stmartin: oh?
06:42:19 <osfameron> dons: the zipper idea looks interesting - is that something you'd use in representing a text editor too for example?
06:42:21 <roconnor> dons: I'm looking forward to using a zipper to solve a problem some day
06:42:22 <dons> > case Left 1 of Left x -> x ; Right y -> y
06:42:24 <lambdabot>  1
06:42:39 <dons> osfameron: yes! I think so!
06:42:45 <dons> osfameron: a zipper on Data.Sequence, for exapmle
06:43:00 <stmartin> That's basically what I've done. Would you care to take a look at the latest pastbot?
06:43:10 <dons> looking...
06:43:23 <roconnor> dons: Conor's student had some nice work on reflecting algebraic data types as a data type
06:43:28 <osfameron> dons: I have a (long dormant) project to make a text editor in Perl using something like an enfilade structure (basically a Piecetable indexed by a relative rather than absolutely positioned binary tree)
06:43:34 <stmartin> The odd thing is, :t ParseError says it doesn't know about it.
06:43:36 * shapr boings
06:43:44 <osfameron> but I keep on getting stumped by not being clever enough to implement it ;-)
06:43:48 <roconnor> Epigram 2 will probably automatically generate zippers of data structures for you.
06:43:52 <stmartin> but csv_read_file works okay.
06:43:56 <dons> hehe. you should do it in haskell, then you can write papers about it, osfameron
06:44:00 <Saizan> stmartin: you have ParserError and putStrLn wants a String, you can try to use show on it
06:44:10 <dons> roconnor: oh, that's an interesting idea.
06:44:18 <osfameron> dons: well, I suppose I could write a paper about it for perl too... though I'd more likely to write a blog post...
06:44:21 <dons> shapr: yow!
06:44:22 <stmartin> Saizan: thanks, trying...
06:44:28 <osfameron> but yeah, I think the algorithms would be easier in Haskell
06:44:35 <dons> and the data types.
06:45:33 <kpreid> osfameron, dons: it occurs to me that a gap buffer, while mutable, is sort of like a zipper
06:45:41 <matthew_-> roconnor: that student's work - reflecting adts as data types - is that in haskell?
06:46:09 <roconnor> matthew_-: Nope, it is in Epigram
06:46:18 <matthew_-> roconnor: oh well.
06:46:32 <osfameron> kpreid: yeah, I looked at gap buffer but, er, I didn't understand it.  And the piecetable structure is beautiful (and enfilade even more so)
06:46:32 <roconnor> haskell has no functions from objects to types :(
06:46:36 <hpaste>  stmartin annotated "Matching Either" with "'show'ing e" at http://hpaste.org/1875#a1
06:46:39 <matthew_-> roconnor: tell me about it!
06:46:49 <stmartin> still fails however.
06:46:54 <dons> roconnor: I wonder if there's a way to have a typeclass fake a zipper type for a given real type.
06:47:02 <dons> so we could derive Zipper
06:47:08 <dons> and get a zipper api onto a type.
06:47:56 <matthew_-> roconnor: I need to convert data Foo = A | B | C such that I can use A B and C at the type level and still have them as "members" of Foo. My current plan is Foo derives Bounded and Enum, I make a list, and then that becomes the indexes into an hlist of data A, data B etc. Disgusting, but I think I could make it work - would involve TH...
06:48:08 <roconnor> dons: I would say that's impossible, so I guess Oleg will have to do it.
06:48:26 <dons> heh. yes, it seems rather hard.
06:48:36 <edwinb> The best way to find out if you can do some dependently typed thing in Haskell is to tell Oleg it's impossible
06:48:42 * edwinb runs
06:48:50 <quicksilver> edwinb: *nod*
06:49:09 <dons> hey edwinb. btw, why are zippers so attractive to the depenent type crowd?
06:49:10 <quicksilver> edwinb: well, that's an extension of the old usenet law
06:49:18 <dons> because of the type calculations used to derive them?
06:49:23 <edwinb> dons: I'm not sure. They are lovely though...
06:49:28 <quicksilver> because Conor wrote about them? *duck*
06:49:29 <dons> they certainly are.
06:49:31 <Saizan> stmartin: odd error, however it means that it parsed your code as (putStrLn "Error" >> putStrLn) $ (show e) because of $
06:49:32 <dons> heh
06:49:33 <DRMacIver> I'm still not clear on what a zipper is.
06:49:48 <stmartin> Saizan: thanks
06:49:49 <quicksilver> DRMacIver: your trousers must fall down a lot. *badabom* *crash*
06:49:54 <dons> DRMacIver: well, basically, the type of one-hole contexts for a type :-)
06:49:55 <Saizan> stmartin: so i'd write putStrLn (show e) in the second line
06:50:11 <DRMacIver> dons: Oh, is that all? Huh. I thought it would be something harder.
06:50:14 <dons> DRMacIver: check the zipper page on the haskell wiki, its truly a gem.
06:50:17 <quicksilver> edwinb: i.e. that in a forum of grumpy hackers, asking doesn't get you an answer. But being wrong, loudly, gets you several good and details answers.
06:50:23 <Saizan> stmartin: are you using hugs?
06:50:27 <edwinb> quicksilver: heh, yes
06:50:46 <stmartin> Saizan: yes, I am.
06:50:49 <DRMacIver> dons: ok, will do.
06:50:59 <edwinb> I suppose part of what makes zippers attractive to the dependent types crowd is that they're handy for writing theorem provers...
06:51:33 <dons> ah yes. of course.
06:51:40 <stmartin> Saizan: Ah, that makes it work. Thanks
06:51:41 <dons> that's Huet's original motivation too
06:51:44 <edwinb> yes
06:52:20 <dons> then, those guys get to thinking about deriving the zippers from the AST for their language, and then you get papers :-)
06:52:28 <roconnor> I didn't understand zippers.  I think it was the haskell wikibook that explained them to me
06:52:30 * shapr hugs dons
06:52:43 <shapr> roconnor: Zippers are Rubik's Cube datastructures.
06:52:52 <edwinb> I'd like a magic way of generating zippers from an ADT, and all the associated navigation functions.
06:52:53 <dons> roconnor: i spent about 3 days on a beach thinking about them last week, and now they're *so obvious*
06:53:00 <edwinb> I expect it's a Simple Matter Of Programming ;0
06:53:02 <shapr> edwinb: I think I've seen a paper about that.
06:53:03 <stmartin> Saizan++
06:53:09 <dons> they should be a fundamental technique, taught along with binary trees
06:53:11 <DRMacIver> Hm
06:53:17 <edwinb> I've seen papers on how to derive a zipper, certainly
06:53:20 * DRMacIver stares vacantly at the haskellwiki
06:53:29 <DRMacIver> I think I'll save this for a day where my brain isn't turning to mush. :)
06:53:32 <Saizan> stmartin: thanks :D
06:53:41 <matthew_-> dons: I tried to convince my supervisor that we should teach category theory. It didn't go down well...
06:53:53 <amil> MarcWeber: Shared object "libX11.so.6" not found
06:54:08 <desp> quicksilver: http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf
06:54:12 <dons> heh. they'd fit well into a Adv. Fun Prog course, along with all the other cool data structures we've come up with in the last 10 years
06:54:19 <dons> Data.Sequence et al.
06:54:46 <stmartin> I don't understand what's so difficult about zippers. It's a fairly simple interface: open close, and don't go to fast of else you'll suffer from ... side effects ;^)
06:54:58 <desp> ouch
06:55:09 <dons> and yeah, walk down your structure, reversing pointersso you have a path back out.
06:55:13 <dons> they are simple.
06:55:13 <Cheery> zippers..
06:55:20 <quicksilver> desp: hmm look snice
06:55:22 <Cheery> ?where zippers
06:55:22 <lambdabot> I know nothing about zippers.
06:55:26 <Cheery> @go zippers
06:55:31 <lambdabot> http://www.zippersperformance.com/
06:55:31 <lambdabot> Title: Home
06:55:35 <matthew_-> yep. I'm sure there are garbage collectors that do pointer reversing the same way as zippers work
06:55:42 <Saizan> and they may also be comonads!
06:55:49 <dons> matthew_-: oh, that's an interesting idea.
06:56:48 <matthew_-> dons: I'm pretty sure it's been done. Just not sure if anyone's seen that they might be zippers
06:56:48 <matthew_-> or that it's exciting! ;-)
06:56:48 <dons> Saizan: I would truly love to see how xmonad let me use both zippers and comonads in the one program.
06:56:48 <roconnor> I was talking to Conor on the bus about logrithms of algebraic data types.
06:56:48 <dons> matthew_-: right! derivable GC :-)
06:56:49 <dons> the type of GC is the type of one-hole contexts on the heap!
06:57:00 <edwinb> oh my
06:57:10 <SamB_XP> what?
06:57:24 <dons> i think zippers might be everywhere.
06:57:31 <SamB_XP> dons: aren't zippers already comonads
06:57:38 * osfameron faints
06:57:47 <roconnor> I'm trying to remember what they were.  I think they were paths in data structures.
06:57:56 <dons> SamB_XP: do you have a reference for that?
06:58:03 <desp> osfameron: yeah
06:58:20 <quicksilver> I've been to Conor's 'derivative of a type is the type of its one hole contexts' talk
06:58:28 <quicksilver> he mentions logarithms at the end
06:58:48 <dons> yeah, its amazing stuff.
07:00:53 <shapr> quicksilver: Have you read the "derivatives of regular expressions" paper?
07:01:11 <shapr> Conor's paper got me interested in the general idea of "derivatives of datastructures."
07:01:25 <quicksilver> shapr: no
07:01:40 <quicksilver> shapr: regular expressions make me ill. Are their derivatives even worse?
07:02:29 <osfameron> oooo!  what's a "derivative" in that context ?
07:02:30 <DRMacIver> Their derivatives are just more regexps.
07:02:35 * SamB_XP looks for a permalink
07:02:43 <DRMacIver> sigfpe has a blog post about it a while ago.
07:02:56 <SamB_XP> yeah
07:03:05 <DRMacIver> http://sigfpe.blogspot.com/2005/05/derivatives-of-regular-expressions.html
07:03:07 <lambdabot> Title: A Neighborhood of Infinity: Derivatives of Regular Expressions, http://tinyurl.com/2a3cxy
07:03:14 <chessguy> x = 2;
07:03:14 <chessguy> main = print x
07:03:15 <chessguy> haha
07:03:27 <DRMacIver> chessguy: Hm?
07:03:39 <chessguy> DRMacIver: on haskell-cafe
07:03:54 <chessguy> sorear's response to how to do global variables in haskell :)
07:04:39 <DRMacIver> Ah
07:04:54 <igli> DRMacIver: thanks! v interesting :)
07:05:36 <Botje> @quote monkey
07:05:36 <lambdabot> bfulgham says: I now have trained-monkey-level skills in Haskell.  I can write really bad shootout code (that the real people rewrite correctly), and build stuff like darcs.
07:06:07 <MarcWeber> amil: Do you have this lib somwhere ? You can tell ghc to be more verbose by adding ghc-options: -v at the cabal file or perhaps using ./setup build -v5 . You can also try exporting LDPATH  and set it to the dirctory containing the lib
07:06:22 <igli> lol codeMonkeys ftw ;)
07:06:32 <chessguy> @quote darcs
07:06:32 <lambdabot> Korollary says: darcs is free of chemical toxins of big pharma. It's made using all natural herbs and other woo. It's good for you. Cheers.
07:06:39 <igli> er ninjaCodeMonkeys ftw sorry ;)
07:09:09 <tibbe> why is ghc so hard to install under os x :(
07:09:28 <osfameron> on 10.2 ?
07:09:39 <osfameron> I had a hell of a time trying to install it on dad's ibook
07:09:56 <LeCamarade> tibbe: Adventure, my friend. Adventure. :oD
07:10:02 <osfameron> perhaps you should switch to something more usable like Ubuntu ? ;-)
07:11:10 <amil> MarcWeber: the library is there alright /usr/X11R6/lib/libX11.so.6 and this is the directory that Setup.hs configure has found libraries in. Will test your suggestions.
07:12:11 <quicksilver> funny, I've never had the slightest trouble installing ghc
07:12:16 <migraine> yeah me either
07:12:20 <quicksilver> I've installed from dmgs, and I've installed from source
07:12:22 <quicksilver> (on OSX)
07:12:25 <quicksilver> without a whimper
07:12:32 <DRMacIver> Hm. So basically a zipper is a data structure which you can 'update' from any location without recreating a large part of the sourrounding data structure?
07:12:33 <migraine> I used the dmg... smooth sailing
07:12:34 <quicksilver> it's a bit slow to compile on this iBook, but that's all
07:13:08 <quicksilver> DRMacIver: certainly one of it's applications (in an FP world) is the ability to 'share context' transparently
07:13:18 <quicksilver> DRMacIver: generalising the way list tails are shared
07:13:26 <DRMacIver> ok.
07:13:32 <quicksilver> that's not all it's for, though
07:13:35 <whaleofconfusion> are there any languages with _compile-time_ logic programming?
07:13:39 <quicksilver> it also makes algorithms elegant
07:13:41 <dons> quicksilver: yes, thanks for that nice reply to the mailing list.
07:13:43 <quicksilver> whaleofconfusion: yes, haskell :P
07:13:52 <quicksilver> dons: about globals?
07:13:53 <whaleofconfusion> I mean more than just type inference
07:13:55 <dons> we should have a standard set of pages for this stuff...
07:13:57 <whaleofconfusion> arbitrary, like Prolog
07:14:04 <DRMacIver> So in other words the above holds in the same way that 'monads are a way of sequencing things'? ;) (i.e. not really but it works as an introductory motivation)
07:14:11 <dons> quicksilver: yeah. maybe you should stick it on a haskellwiki/Global_variables page
07:14:15 <whaleofconfusion> so that you specify logical rules about the objects in your program and it generates imperative code
07:14:17 <dons> and people can add other techniques
07:14:27 <quicksilver> whaleofconfusion: yes, haskell. Your brain needs to be twisted to pervert it that way, though :)
07:14:39 <whaleofconfusion> how does Haskell do it?
07:14:40 <quicksilver> whaleofconfusion: but you can program in the FD/typeclass system at compile time
07:14:47 <joelr1> fols, what's the cause of this warning? Warning: orphan instances:
07:14:47 <joelr1>   instance uulib-0.9.3:UU.PPrint.Pretty [morpher-0.1:Morpher.Easy.AST.Call] = $f9
07:14:51 <dons> quicksilver: do you mind if I use your mail as the basis for a wiki page on this?
07:14:57 <quicksilver> dons: absolutely not :)
07:14:57 <dons> so I can quote that page in future?
07:15:01 <quicksilver> dons: please do
07:15:03 <dons> ok. good. :-)
07:15:18 <whaleofconfusion> quicksilver: I understand though that the Haskell type system is not a universal system of computation
07:15:30 <quicksilver> dons: I almost cancelled it, I have a pathological fear of saying stupid thiings on mailing lists and looking like a fool
07:15:46 <quicksilver> whaleofconfusion: I don't think it's turing complete, but it's quite powerful. I'm not an expert.
07:15:53 <quicksilver> whaleofconfusion: It wasn't a very serious suggestion :)
07:16:04 <quicksilver> whaleofconfusion: A more serious suggestion would be: you could do something like that with TH, I'm sure.
07:16:05 <DRMacIver> GHC's type system is turing complete.
07:16:09 <DRMacIver> Haskell 98's isn't.
07:16:24 <quicksilver> dons: which I do with great regularlity :)
07:17:09 <tibbe> quicksilver: where did you find those dmgs? it's not that getting it on there is difficult, I want to be able to get it in and out in a clean manner
07:17:24 <tibbe> quicksilver: i.e. not unix spray the filesystem install
07:17:49 <quicksilver> tibbe: I downloaded them from haskell.org
07:18:01 <quicksilver> tibbe: although my current version is a compiled-from-source one, I think
07:18:11 <quicksilver> tibbe: Once it's all working it's quite easy to forget exactly what you did :(
07:18:30 <chessguy> quicksilver++ that is indeed a very nice paste, though i wouldn't have known who the author was :)
07:18:41 <chessguy> err, s/paste/post/
07:19:03 <quicksilver> chessguy: I keep my real identity a closely guarded secret
07:19:13 <joelr1> dons: when does it make sense to use QC2 over QC1 ?
07:19:18 <quicksilver> chessguy: only those who have mastered the deep voodoo of '/whois' can work it out.
07:19:34 <whaleofconfusion> DRMacIver: is that really true?  you should tell this guy: http://www.lambdassociates.org/advtypes.htm
07:19:35 <lambdabot> Title: Advanced Types in Qi
07:19:39 <quicksilver> (even my mother is only permitted to refer to me as quicksilver: )
07:20:13 <DRMacIver> whaleofconfusion: Turing complete type systems are nothing new.
07:20:17 <DRMacIver> whaleofconfusion: Even C++ has one. :)
07:20:23 <DRMacIver> (More or less)
07:20:46 <dons> joelr1: i think only if you need 'shrinking'
07:20:53 <dons> otherwise you can use QC1, and steal some of the newtypes.
07:21:15 <joelr1> dons: isn't shrinking good enough to kill and so qc2 should be used always?
07:21:34 <dons> yes, but QC2 is missing some drivers, and isn't released.
07:21:37 <quicksilver> DRMacIver: you've seen the compile-time raytracer, I presume?
07:21:39 <dons> it can't hurt to start moving to it though.
07:22:10 <DRMacIver> quicksilver: I've seen one in D. Is there a C++ one?
07:22:16 <joelr1> dons: yeah, i think i'll try that. i have no idea of drivers anyway. i'm still using your example one for 0-arity tests :)
07:22:25 <dons> heh
07:22:49 <joelr1> dons: i decided to bite the bullet and test my parser by generating arbitrary asts, pretty-printing them and re-parsing
07:23:03 <dons> sounds good.
07:23:16 <dons> did I point you to that Clean paper on QuickCheck for parser combinators?
07:23:33 <DRMacIver> quicksilver: I don't really do C++. I'm just amused by programming perversions, so I've got a vague general awareness of it.
07:23:33 <dons> and yes, I think that's a great system, if you can pull it off.
07:23:39 <quicksilver> DRMacIver: oh, I thought it was C++ but I can't find it now so I'm guessing my memory is faulty and it was the D one
07:23:54 <joelr1> dons: clean... clean... don't remember
07:24:10 <joelr1> dons: would it be directly applicable?
07:24:22 <dons> i think it gives some hints on generating complex ASTS
07:24:30 <dons> and testing higher-order  parser functions
07:24:35 <dons> let me find it.
07:26:09 <joelr1> dons: i was just going to created sized generators for each member of the AST
07:26:33 <joelr1> dons: wouldn't that work?
07:27:07 <joelr1> dons: i still have trouble wrapping my head around QC-ing of HOFs
07:28:23 <quicksilver> joelr1: it's actually dangerous to try to do that
07:28:28 <quicksilver> joelr1: your head could easily explode
07:28:58 <SamB_XP> joelr1: you want to SmallCheck it?
07:29:34 <joelr1> SamB_XP: i don't know!
07:30:18 <joelr1> SamB_XP: the complication is that a statement can be something that has another statement, for example. like a compound statement. i don't understand what it would mean to exhaustively check that with SC.
07:30:26 <dons> joelr1: here's the paper,
07:30:27 <dons>  Automatic Testing of Higher Order Functions
07:30:28 <dons> Pieter Koopman and Rinus Plasmeijer
07:30:41 <SamB_XP> joelr1: SC has size bounds...
07:30:58 <quicksilver> in particular, SC has depth bounds, doesn't it?
07:31:01 <joelr1> my head is ready to explode already
07:31:05 <joelr1> dons: thanks
07:31:14 <dons> SC is a breadth first, rather than random walk, test generator
07:31:19 <joelr1> SamB_XP: would you suggest that i SC it instead of QC it?
07:31:24 <timbod> Help: If I've constructed an instance of Binary for a datatype of my own, how would I read it from a Handle corresponding to a network socket?
07:31:24 <dons> ?scheck \x -> not x
07:31:25 <lambdabot>   Failed test no. 1. Test values follow.: True
07:31:29 <dons> ?check \x -> not x
07:31:30 <lambdabot>  Falsifiable, after 1 tests: True
07:31:38 <dons> ?check \x -> not x || x
07:31:39 <lambdabot>  OK, passed 500 tests.
07:31:41 <dons> ?scheck \x -> not x || x
07:31:42 <lambdabot>   Completed 2 test(s) without failure.
07:31:55 <SamB_XP> joelr1: it has a lot of nice features
07:31:57 <dons> timbod: hGetContents on the handle
07:32:08 <dons> timbod: then run 'get' or what have you, on that lazy bytestring
07:32:32 <joelr1> dons, SamB_XP: so why isn't everyone using SC then? it takes longer to hit an error?
07:33:02 <timbod> Dons: OK... so I've got to convert all the input for the rest of the life of the handle into a lazy bytestring?
07:33:12 <SamB_XP> hmm. well, quickcheck has been around longer and is perhaps more polished
07:33:17 <dons> no, you read it from the handle directly as a bytestring :-)
07:33:28 <dons> :t Data.ByteString.Lazy.hGetContents
07:33:30 <lambdabot> GHC.IOBase.Handle -> IO Data.ByteString.Lazy.ByteString
07:33:32 <SamB_XP> and I guess smallcheck's exhaustive searches can take a while
07:33:53 <dons> yeah, QC has more instances, and QC2 has test case shrinking, and much better support for generating complex ASTs
07:34:00 <dons> it has a richeer combinator set
07:34:06 <SamB_XP> (note, they are exhaustive searches of a very small part of the space QC searches)
07:34:15 <timbod> Dons: yep, I was attempting to say that once you've done that, you can't use the handle via any other calls.... ?
07:34:17 <dons> but, imo, QC2 should support breadth first generators too
07:34:27 <dons> timbod: probably not a good idea. would be possible though
07:34:37 <timbod> dons: that
07:34:39 <dons> strict read from the handle, then convert to a lazy bytestring , then parse
07:34:45 <timbod> s fine works for me here.
07:34:48 <quicksilver> timbod: if you don't like that method, you can read ah what dons just said
07:34:54 <dons> strict read via Data.ByteString.hGet*
07:34:56 <joelr1> so it sounds to me like i should probably go with QC2 and wait for SC to be integrated into it, right?
07:35:02 <amil> MarcWeber: No luck, and no more info could be got by adding -v as an option to ghc since it is running dist/build/Graphics/X11/Types_hsc_make that fails
07:35:03 <quicksilver> :t Data.ByteString.Lazy.pack
07:35:04 <lambdabot> [Word8] -> Data.ByteString.Lazy.ByteString
07:35:06 <dons> joelr1: yep. that'd be fine
07:35:15 <quicksilver> (convert Word8s read elswhere into LBs)
07:35:18 <timbod> dons: only if I know how much to read strictly
07:35:19 <SamB_XP> it would be nice if had a unified framework for equational testing
07:35:38 <SamB_XP> that is, for specifying the equations
07:35:57 <amil> MarcWeber: I find all this strange, since I have built X11-1.2 on OpenBSD and NetBSD is usually similar enough.
07:36:05 <joelr1> how do you test something like "sized $ \n -> resize 3 arbitrary" with lambdabot?
07:36:33 <joelr1> i'm trying to restrict my lists to be no longer than N elements
07:39:05 <whaleofconfusion> why does Haskell not allow references to variables that are not in scope?
07:39:24 <SamB_XP> whaleofconfusion: um, because they aren't in scope?
07:39:28 <whaleofconfusion> there is an alternative, what Mathematica does-> x := y + z; y := 3 / w; z := 1; w := 9; x (which returns 4/3)
07:40:13 <SamB_XP> > let x = y + z; y = 3 / w; z = 1; w = 9 in x
07:40:15 <lambdabot>  1.3333333333333333
07:40:21 * dons ponders the google ad:   'GHC: Read more about products related to GHC on ebay.com.au'
07:40:25 <SamB_XP> > let x = y + z; y = 3 / w; z = 1; w = 9 in x :: Rational
07:40:26 <lambdabot>  4%3
07:40:27 <dons> people selling their second hand packages?
07:40:29 <allbery_b> heh
07:40:34 <SamB_XP> whaleofconfusion: good enough for you?
07:40:39 <whaleofconfusion> maybe
07:40:50 <allbery_b> "what are you really trying to do?"
07:41:01 <whaleofconfusion> but does that depend on them all being in the same expression?
07:41:03 <quicksilver> whaleofconfusion: haskell does allow mutually recursive variables
07:41:20 <quicksilver> whaleofconfusion: it relies on them all being in scope (what else would you expect?)
07:41:28 <whaleofconfusion> could you define a global variable x that was defined as the sum of w and z, and wherever any variables named w and z are defined, x has the corresponding value?
07:41:37 <SamB_XP> whaleofconfusion: well, if you want your variables to be mutually recursive, they need to be defined in the same module, let, or where block
07:41:48 <quicksilver> whaleofconfusion: but haskell is not a general equation system solver, unlike mathematic
07:42:01 <joelr1> dons: is sized superfluous here? "sized $ \n -> resize 3"
07:42:05 <whaleofconfusion> it doesn't really take an equation solver, it just takes substitution
07:42:08 <quicksilver> whaleofconfusion: anything which requires a complex algorithm to reach a fixed point will diverge in haskell
07:42:12 <timbod> dons, quicksilver: thanks guys, you got me thinking, and I've changed the protocol so that blobs are preceded by a length, so that I can read strictly.
07:42:15 <whaleofconfusion> you can do it in Lisp using define-symbol-macro
07:42:20 <SamB_XP> and, as a programming language, Haskell has to be stricter about scope than a math program
07:42:22 <quicksilver> whaleofconfusion: right. substitution works in haskell
07:42:32 <allbery_b> hm, maybe he wants Reader?
07:42:35 <quicksilver> whaleofconfusion: those equations which can be solved merely by substituion work ;)
07:43:19 <whaleofconfusion> (progn (define-symbol-macro x (+ y z)) (define-symbol-macro y (/ 3 w)) (define-symbol-macro z 1) (define-symbol-macro w 9) x)
07:43:23 <SamB_XP> whaleofconfusion: you *could* look into those funny dynamic-like variables
07:43:27 <quicksilver> whaleofconfusion: what I don't understand is why you don't think your mathematica example works in haskell, when in fact it does
07:43:36 <SamB_XP> @type ?x
07:43:38 <lambdabot> forall t. (?x::t) => t
07:43:41 <quicksilver> just don't do it
07:43:43 <quicksilver> don't even go there
07:43:49 <quicksilver> (and I don't think they help, anyhow)
07:43:50 <SamB_XP> heh
07:43:57 <whaleofconfusion> in mathematica if there is an expression with unbound variables, they show up as themselves
07:44:03 <SamB_XP> ... or you could just use functions that take parameters
07:44:06 <allbery_b> what's with those suddenly coming back, anyway?  I thought they were slated for removal
07:44:12 <whaleofconfusion> you can say z + 9 even if you have no z, and it will evaluate to the expression z + 9
07:44:14 <allbery_b> (implicit vars, that os_
07:44:19 <allbery_b> "is)"
07:44:26 <joelr1> ?where qc2
07:44:26 <lambdabot> darcs get http://www.cs.chalmers.se/~bringert/darcs/QuickCheck/
07:44:26 <SamB_XP> allbery_b: slated for removal, or removed?
07:44:48 <allbery_b> well, they're still in 6.6 (and 6.6.1)?
07:45:45 <allbery_b> whaleofconfusion: haskell doesn't do that automatically.  you could write code (pesumably involving the Reader monad) to implement it, fairly easily I think, but the haskell "REPL" doesn't do such things
07:45:48 <allbery_b> haskell isn't lisp
07:46:11 <allbery_b> if you want lisp, use lisp.
07:46:25 <SamB_XP> anyway, in lisp, isn't the top-level scope extensible?
07:46:37 <cdsmith> > ?z + 9
07:46:38 <lambdabot>  Parse error
07:47:07 * allbery_b keeps around multiple tools (including programming languages) because every one has its strengths, and tries to use the right tool for the job
07:47:07 <whaleofconfusion> extensible like how?
07:48:07 <whaleofconfusion> you mean that you can declare new top-level variables in some lower level of nesting?
07:48:09 <cdsmith> @type ?z + 9
07:48:11 <lambdabot> forall a. (?z::a, Num a) => a
07:48:22 <cdsmith> I knew that worked somehow.
07:48:28 <qwr> whaleofconfusion: definitions are added to lisp toplevel when they are reached by interpretator
07:48:39 <whaleofconfusion> Lisp isn't interpreted
07:48:45 <whaleofconfusion> usually
07:49:04 <qwr> whaleofconfusion: the semantics shouldn't change by optimisations
07:49:26 <whaleofconfusion> yes
07:50:38 <gleb> \me
07:51:07 <allbery_b> \me -> ?
07:51:14 <opqdonut> \me -> _|_
07:51:24 <gleb> sorry guys, new to IRC
07:51:29 <quicksilver> partially evaluated functions (like whaleofconfusion is describing) are not that useful in a general purpose programming language
07:51:41 <gleb> is there some sandbox to try IRC commands?
07:51:43 <quicksilver> if we have to admit that Int doesn't only contain _|_ and all Ints
07:51:58 <quicksilver> but also all expressions not yet evaluated due to free variables
07:52:06 <quicksilver> I don't think that's useful in a general purpose setup :)
07:52:15 <quicksilver> of course, it's extremely useful in some specific cases
07:52:28 <allbery_b> join a nonexistent channel and play?
07:52:39 <allbery_b> (channels are created dynamically)
07:53:02 <gleb> allbery_b: oh thanks, didn't know that
07:53:50 <SamB_XP> there is actually a channel called #sandbox...
07:57:26 <joelr1> dons: i just noticed that QC2 does not seem to have coarbitrary. how do you test HOFs with QC2 then?
07:58:57 <twanvl> coarbitrary is in a separate module
07:59:43 <joelr1> twanvl: thanks
08:02:15 <MarcWeber> @tell jyp: It's very uncommon that make vim tries to install it ! That's why there is make and make install.
08:02:15 <lambdabot> Consider it noted.
08:03:57 <jyp> MarcWeber: the thing is, yi won't run unless it is installed.
08:04:44 <MarcWeber> jyp I don't mind. But it's strange to get a permission denied error when using make vim ... That's all.
08:05:19 <whaleofconfusion> quicksilver partially evaluated functions are the equivalent of currying
08:05:56 <whaleofconfusion> only a more general kind of currying where more than the last argument may be curried
08:05:57 <quicksilver> whaleofconfusion: yes and no
08:06:05 <quicksilver> whaleofconfusion: you're confusing the types, though
08:06:22 <quicksilver> whaleofconfusion: a partially applied function of that nature has type Int -> Int
08:06:31 <quicksilver> whaleofconfusion: i.e. it is clear in its type that it has been partially applied
08:06:39 <quicksilver> whaleofconfusion: haskell supports this kind of thing clearly enough
08:06:59 <quicksilver> but what you can't do is say 'z+3' has either type Int or type Int -> Int, depending if z has already been defined
08:07:16 <whaleofconfusion> why can't you say that?  it can be determined by static analysis
08:07:25 <whaleofconfusion> if all scoping is static
08:07:29 <quicksilver> well, you could say it, in fact
08:07:45 <quicksilver> you could define z+3 to be just a funny way to write \z -> z + 3
08:08:00 <whaleofconfusion> ah but a bit more than that
08:08:12 <quicksilver> but I don't think that would be useful as part of haskell
08:08:12 <whaleofconfusion> because if you have x = z + 3 and then later on you define z, you want x to reflect the value of z
08:08:17 <quicksilver> right
08:08:21 <quicksilver> well x can't change type like that
08:08:46 <whaleofconfusion> more properly it doesn't currently, but would this be a conservative extension to haskell?
08:09:04 <whaleofconfusion> I don't think it would make any currently correct programs behave differently or fail
08:09:06 <quicksilver> to me it doesn't sound like a useful one
08:09:23 <whaleofconfusion> it's dataflow programming
08:09:27 <quicksilver> in part, because it would change programs which currently failed with a nice 'foo is not defined' error
08:09:38 <quicksilver> into programs with nasty type errors
08:09:48 <quicksilver> however, feel free to suggest it on the -cafe
08:09:51 <quicksilver> and get better answers ;)
08:10:01 <whaleofconfusion> maybe later, no time now
08:14:15 <whaleofconfusion> actually, it would break some currently working programs if it works the way I am thinking
08:15:28 <whaleofconfusion> in a Lisp syntax you would want something like (let* ((z 9) (x (+ 3 z)) (z 2)) x) to equal 5
08:15:40 <whaleofconfusion> updating the value of x when z is bound again
08:16:12 <quicksilver> well there you break referential integrity
08:16:15 <quicksilver> and thus, the entire point of haskell
08:16:21 <quicksilver> so I think that would be bad :)
08:16:32 <quicksilver> erm, referential transparency
08:17:59 <whaleofconfusion> I'm not sure, but if you assume that any new variable binding implicitly rebinds any of the variables that depend on it, I don't think it would break transparency
08:18:24 <whaleofconfusion> so it would become the equivalent of (let* ((z 9) (x 12) (z 2) (x 5)) x)
08:18:59 <Baughn> whaleofconfusion: Your point may be valid, but that's not how let* works. (let* ((z 9) (x 12) (z 2) (x 5)) x) is equivalent to (let ((z 9)) (let (x 12)) (let ((z 2)) ...
08:19:39 <whaleofconfusion> yes, and I'm saying that the (let ((z 2)) ... ) would need to expand to (let ((z 2) (x 5)) ... )
08:19:43 <whaleofconfusion> er
08:19:51 <whaleofconfusion> to (let ((z 2)) (let ((x 5)) ... ))
08:23:26 <migraine> I am blinded forever... thanks alot
08:30:59 <chessguy> hmm, full of (
08:31:12 <chessguy> like lisp?
08:32:01 <nominolo`> i guess it was supposed to be funny
08:39:14 <osfameron> dammit!  yi needs ghc>=6.6
08:39:27 <osfameron> curse my puny ubuntu 6.4.2
08:40:14 <SamB_XP> I think maybe the message got truncated ;-)
08:41:11 <TomMD> osfameron: I use Ubuntu and I have 6.6 - it isn't a big deal grabbing a non-apt package :)
08:41:34 <osfameron> TomMD: no, but I have to think
08:41:45 <osfameron> sudo apt-get install whatever I can do in seconds
08:41:58 <osfameron> (or, more realistically open synaptic, but still, maybe 30 seconds)
08:42:19 <osfameron> now I have to look for it and possibly go through hate compiling it
08:42:54 <quicksilver> osfameron: ghc-6.6 is in debian unstable
08:43:10 <quicksilver> osfameron: if it's not in ubuntu's equivalent, then upgrade to a real OS :P
08:43:26 <quicksilver> or try your luck at the debian packages on the ubuntu machine
08:43:41 <osfameron> meh.  debian doesn't like my hardware.  I guess I could try the debian package
08:43:47 <osfameron> can I just add the debian repo ?
08:44:13 <osfameron> meh.  sorry, don't answer that, I won't waste your time any more now
08:44:29 <osfameron> I'll look at it later on more tuits
08:44:42 <quicksilver> I think you can
08:44:45 <quicksilver> but I don't use ubuntu
08:44:47 <quicksilver> so no promised :)
08:44:55 <osfameron> fair enough
08:48:16 * osfameron downloads source for 6.6.1 on the basis that compiling it might be "fun"
08:48:22 <osfameron> gah, I hate computers
08:49:37 <TomMD> osfameron: ghc-6.6.1 src compiled fine for me the other day (except for the extras).
08:50:52 <jyp> osfameron: the newest ubuntu has a suitable ghc
08:51:56 <bluestorm> dons: as i saw the length of your last blog post, i thought that a "printable version" link would be helpful
08:52:34 <dons> hmm. yes. i wonder how i can generate those.
08:52:43 <Botje> appropriate css?
08:52:44 <dons> yes, i think that would be pretty easy
08:52:54 <dons> though its almost printable as is..
08:52:57 <osfameron> jyp: oh, that's good.  But I've read bad things about latest upgrade (broken bash, PHP - not that I care, drivers, etc) thought I'd wait a couple of weeks
08:52:58 <bluestorm> actually i could extract the post and print it myself
08:53:07 <osfameron> TomMD: cool, I'll try tonight
08:53:08 <bluestorm> but you may want to add some copyright information for example
08:53:19 <dons> not really :-)
08:53:24 <dons> they're just words.
08:53:29 <jyp> osfameron: no problems to report here.
08:54:08 <osfameron> jyp: yeah, but negative datapoints are always so much more compelling ;-)
08:54:42 <bluestorm> dons: even if you don't care about the copyright, i think it's always a good idea to make it clear
08:54:53 <bluestorm> hm
08:55:50 <dons> bluestorm: yeah. i've been thinking about that.
08:55:58 <dons> there should be some creative commons or some such on blog posts
08:56:03 <dons> like for wiki articles
09:03:54 <atp> hey guys, does anyone know off-hand if ghci has an rc file or something?  i'm getting  tired of typing :set editor at every outset, but a quick look at the manpage on my debian system doesn't mention anything
09:04:49 <kpreid> ~/.ghci
09:05:07 <atp> kpreid: do i need the colons?
09:05:20 <kpreid> contents are ghci commands
09:05:22 <kpreid> $ cat .ghci
09:05:22 <kpreid> :def lr \f -> return (":load " ++ f ++ "\nmain")
09:05:25 <kpreid> yes
09:05:30 <atp> kpreid: great, thanks a bunch :)
09:06:24 <shapr> @yow !
09:06:24 <lambdabot> I know things about TROY DONAHUE that can't even be PRINTED!!
09:07:17 <shapr> Excitement!
09:11:05 <TomMD> @src read
09:11:05 <lambdabot> read s = either error id (readEither s)
09:11:15 <TomMD> @src readEither
09:11:15 <lambdabot> Source not found. That's something I cannot allow to happen.
09:11:29 <Saizan> ?type readEither
09:11:37 <lambdabot> Not in scope: `readEither'
09:12:32 * osfameron starts compiling ghc... I guess that'll take some time?
09:12:43 <mauke> oh yeah
09:12:43 <quicksilver> osfameron: 15 minutes on don's sick-machine
09:12:52 <osfameron> that's nae too bad
09:13:07 <mauke> a few hours here
09:13:08 <quicksilver> you won't see that unless you have 64 cores too, though :)
09:13:33 <osfameron> ah, "sick" means something different than I expected it to
09:13:37 <twanvl> What will happen to lambdabot if I do "?pointful (\x -> x x x) (\x -> x x x)"?
09:13:55 * osfameron wonders if he'll be able to sleep his machine and have it resume safely while compiling...
09:14:02 <quicksilver> osfameron: sure
09:14:12 <kpreid> twanvl: why don't you try it?
09:14:26 <mauke> ?pointful (\x -> x x x) (\x -> x x x)
09:14:27 <lambdabot> (\ x -> x x x) (\ x -> x x x)
09:14:34 <twanvl> Because I am affraid it will kill it
09:14:40 <quicksilver> it has CPU limits
09:14:43 <quicksilver> it's pretty safe
09:14:48 <kpreid> er
09:14:52 <quicksilver> > last [1..]
09:14:58 <lambdabot> Terminated
09:15:15 <quicksilver> ?pl (\x -> x x x)(\x -> x x x)
09:15:18 <lambdabot> ap (ap id id) id (ap (ap id id) id)
09:15:18 <lambdabot> optimization suspended, use @pl-resume to continue.
09:15:19 <twanvl> It has limits for things like eval, but pointful is called directly from a plugin
09:15:20 <kpreid> pl has limits, and eval has limits, but pointful doesn't
09:15:25 <desp> does anyone have a haskell implementation of a heap handy?
09:15:45 <mauke> > minBound `div` (negate (1::Int))
09:15:46 <lambdabot> Terminated
09:15:52 <sjanssen> @where edison
09:15:52 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
09:15:52 <kpreid> however, I doubt there's a way to make pointful go boom
09:15:56 <SamB_XP> desp: you mean what knuth calls a heap?
09:16:23 <sjanssen> desp: Edison has several
09:16:42 <desp> sjanssen: thank you, I was actually about to translate Okasaki's SML code :)
09:16:50 <kpreid> twanvl: unpl didn't do anything to your code because it had no named combinators and your lambdas all mentioned their bound name more than once
09:17:30 <sjanssen> desp: Okasaki is the original author of Edison
09:17:32 <desp> SamB_XP: I'm not sure what exactly does Knuth call a heap, so I'll settle for a structure that offers logarithmic-time insertions/deletions and constant time minimum lookup
09:17:37 <desp> sjanssen: yeah, I see that :)
09:18:00 <SamB_XP> desp: okay, so not the thing on which you do dynamic allocation ;-)
09:18:12 <kpreid> twanvl: any questions?
09:18:24 <quicksilver> desp: 'a tree with a left-most pointer' satisfies that, doesn't it?
09:18:26 <twanvl> No, it seems it is safe
09:18:33 <quicksilver> desp: well as long as it's balanced
09:19:38 <desp> quicksilver: I'm not sure if balanced trees are much simpler than vanilla heaps
09:20:17 <shapr> I want code! Quick, someone feed me some code!
09:20:19 <atp> hey guys, why would i get a kind mismatch for an instance declaration of the Monad class?  ghci seems to think that instances of Monad have to have type * -> *, but there are lots of Monads that don't have this type... i'm a little bit confused
09:20:24 * shapr has a kernel panic!
09:20:26 <quicksilver> desp: that's a good point
09:20:36 <quicksilver> atp: name a monad which does not have kind * -> * ?
09:20:49 <atp> quicksilver: Maybe ?
09:20:53 <shapr> @kind Maybe
09:20:55 <lambdabot> * -> *
09:20:59 <atp> hm
09:21:02 <mauke> @kind []
09:21:04 <lambdabot> * -> *
09:21:12 <mauke> @kind ((->) e)
09:21:13 <lambdabot> Not in scope: type variable `e'
09:21:15 <shapr> @kind vicious
09:21:17 <lambdabot> Not in scope: type variable `vicious'
09:21:24 <shapr> @unkind shapr
09:21:25 <quicksilver> atp: Maybe has that kind, because Maybe takes 1 type parameter, as in 'Maybe Int'
09:21:26 <lambdabot> Not in scope: type variable `shapr'
09:21:27 <shapr> True !
09:21:45 <atp> quicksilver: oh, i see!  ok, i know what I'm doing wrong
09:21:50 <quicksilver> atp:  :)
09:21:50 <atp> quicksilver: stupid me
09:22:06 * atp didn't really understand kinds until just now, apparently...
09:22:31 <quicksilver> :)
09:22:36 <quicksilver> then today is a good day
09:22:41 <atp> indeed
09:22:41 <quicksilver> because you learnt abuot kindness!
09:22:53 <atp> although, you know, the great thing about haskell is that i learn something new every day
09:22:59 <atp> generally many new things
09:24:49 <chessguy> @quote kind
09:24:49 <lambdabot> ghc says: Can't represent explicit kind signatures yet
09:25:25 <TomMD> Why does the Network.Socket library use an IO inet_addr and the like?  These could be purely computational (and I would argue, should be).
09:25:41 <mauke> TomMD: because Network.Socket is broken
09:25:50 <TomMD> No doubt.
09:26:14 <chessguy> isn't that part of one of the SoC projects?
09:26:29 * chessguy looks
09:26:30 <chessguy> ?where soc
09:26:30 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
09:28:24 <chessguy> oh, i was thinking of the http project, but i guess that won't include this
09:31:08 <atp> hey, can anyone give me an example of a monad which is not an instance of functor?
09:31:18 <atp> is that even possible?
09:31:24 <mauke> no, fmap = liftM
09:31:31 <int-e> you can make all monads an instance of functor
09:31:35 <atp> right, that's what i thought
09:32:43 <int-e> I'm not sure if there is any monad that doesn't come with a functor instance, but there is no good reason for not defining one.
09:32:44 <atp> because looking at the prelude documentation, it says "instances of both monad and functor should additionally satisfy the law fmap f xs >>= return . f" as though you needed to prove something else, but it seems as though the generic monad laws have this as a relatively trivial corollary
09:32:58 <int-e> sure
09:33:14 <atp> i just wanted to make sure i wasn't having a brain fart
09:33:20 <atp> it is early in the morning, after all :)
09:33:21 <int-e> you can make conflicting functor and monad instances which are consistent in themselves
09:33:33 <atp> hm
09:34:02 <atp> i suppose that's true
09:34:50 <pitecus> Could someone explain why this: foo =  do { i<- get ; put (i+1::Int);  return i } doesnt compile?
09:34:59 <atp> rather in the way that there may be a "natural" homomorphism between groups but also several "unnatural" but nonetheless valid ones
09:35:09 <pitecus> But it does once i add the type signature foo :: State Int Int ???
09:35:22 <mauke> :t do { i<- get ; put (i+1::Int);  return i }
09:35:24 <lambdabot> forall (t :: * -> *). (MonadState Int t) => t Int
09:35:38 <mauke> pitecus: monomorphism restriction
09:36:53 <pitecus> mauke, how exactly does it kick in here?
09:37:38 <mauke> (MonadState Int t) => t Int
09:37:41 <mauke> that's polymorphic
09:39:10 <atp> what is the impetus for the monomorphism restriction anyway?  i never really grokked that
09:39:16 <pitecus> i guess i still dont understand that restriction. it doesnt prohibit all polymorphic functions, doesn it?
09:39:38 <mauke> I think it disallows implicitly polymorphic constants
09:39:43 <mauke> because they're not really constant
09:41:46 <mauke> e.g. foo = sqrt 2 looks like it computes sqrt 2 once, then binds it to foo
09:42:11 <mauke> but that's not what happens because the behavior of 2 and sqrt depend on the typeclass used
09:42:22 <quicksilver> pitecus: it's "supposed" to eliminate a source of confusion
09:42:40 <quicksilver> pitecus: that your foo looked like a constant (cos it has no parameters) but in fact it isn't a constant (it's polymorphic)
09:42:55 <quicksilver> pitecus: IMO it just generates a different kind of confusion, though :)
09:43:00 <atp> you can turn it off apparently in ghc with -fno-monomorphism-restriction
09:43:33 <pitecus> quicksilver, exactly
09:43:54 <pitecus> atp, the problem is that in this case GHC doesnt tell you to turn it off
09:43:59 <pitecus> normally it does
09:44:26 <atp> yeah.
09:44:48 <monochrom> Interesting. Beginner confusion cannot be eliminated, only moved around.
09:45:02 * atp laughs at monochrom.
09:45:17 <pitecus> in haskell you're alwyas a beginner
09:45:18 <DRMacIver> The law of conservation of confusion?
09:45:30 <int-e> @quote+ monochrom Interesting. Beginner confusion cannot be eliminated, only  moved around.
09:45:30 <lambdabot> No quotes match. Are you on drugs?
09:45:43 <monochrom> No, this is serious! It has consequences on how to go about education.
09:45:44 <osfameron> heh, good law
09:45:55 <atp> we should call it "monochrom's conservation of confusion law"
09:46:06 <monochrom> Now I'm really famous.
09:46:13 <DRMacIver> And not the "Conservation of monochrom's confusion" law, which is somethign entirely different
09:46:14 <atp> :)
09:46:26 <int-e> ah, @remember was it.
09:46:36 <Si> this may sound a daft question, but is there any way of representing an existentially quantified type such that you can tell whether two values are quantified over the same type (although you don't know what it is)
09:46:43 <int-e> @quote confusion
09:46:43 <lambdabot> Bulat says: we can also rename Pascal to Blez to avoid confusion
09:46:52 <int-e> @quote confusion
09:46:52 <lambdabot> monochrom says: Interesting. Beginner confusion cannot be eliminated, only  moved around.
09:48:13 <Codex_> Can I move my confusion to your cat?
09:48:28 <mauke>  A number of languages give lip service to the idea of minimalism, but merely sweep the complexity of the problem under the carpet of the programmer.
09:48:45 <osfameron> that's a Larry Wall quote isn't it?
09:49:15 <osfameron> wooot!  ghc compile is bringing my laptop to its knees
09:49:16 <desp> hmm
09:49:17 <desp> http://www.eecs.usma.edu/webs/people/okasaki/jfp96/index.html
09:49:19 <lambdabot> Title: Optimal Purely Functional Priority Queues
09:49:24 <desp> has anyone done that in Haskell?
09:50:25 <desp> I don't think Edison has this
09:51:16 <monochrom> Si: Yes. Design a two-parameter class that says "class SameType a b where sametype :: a -> b -> Bool". Define instances for all pairs of types that you will use in your existential type.
09:52:25 <Si> monochrom: ok, so on the whole if I'm going to do it I might as well use Typeable.
09:53:09 <int-e> typeable pretty much forces the compiler to do run-time checks though
09:53:50 <monochrom> I think it's ok.
09:55:07 <monochrom> All equality checks must be run-time checks, including value equality and type equality. :)
09:55:39 <Si> the problem is I'm trying to take maximum advantage of Haskell's type-system in a plugin system. Basically what seems to be the case is I can't write generic functions which process existentials because I can't do binary functions very easily.
09:55:55 <Si> So it's better to do the whole thing on a case by case basis and cast the output at the end
09:57:04 <int-e> hmm, it's a trade-off, as usual. Typeable has the desired effect with O(n) instances, while the other classe amounts to packing a known constant function taking two arguments and returning bool into the existential when it's created, which is cheaper to test. (and with some type fiddling you can actually pack the bool constant into the existential)
09:57:38 <int-e> oh, and typeable also comes with the cast that you'll probably want to do sooner or later.
10:08:12 <chessguy> ?src negate
10:08:12 <lambdabot> negate x = 0 - x
10:08:31 <chessguy> @type (+ -5 )
10:08:33 <lambdabot>     The operator `+' [infixl 6] of a section
10:08:33 <lambdabot>         must have lower precedence than the operand prefix `-' [infixl 6]
10:08:48 <chessguy> @type (+ (-)5)
10:08:49 <lambdabot> forall t. (Num t, Num (t -> t)) => (t -> t) -> t -> t
10:19:59 <int-e> @type (-5+)
10:20:07 <lambdabot> forall a. (Num a) => a -> a
10:25:41 <ed1t> @type (+5)
10:25:43 <lambdabot> forall a. (Num a) => a -> a
10:25:53 <ed1t> @type [1,2,3]
10:25:54 <lambdabot> forall t. (Num t) => [t]
10:26:09 <ed1t> @type [1,2,[3]]
10:26:11 <lambdabot> forall t. (Num [t], Num t) => [[t]]
10:30:16 <hstenstrom> What is this "lambdabot"?
10:31:06 <decaf_cakirkeyf> hstenstrom: it's a bot
10:31:43 <Botje> > scanl (+) 1 [1..]
10:31:44 <lambdabot>  [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,2...
10:33:33 <desp> > let fix f = let x = f x in x in fix show
10:33:35 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
10:35:02 <mauke> @v
10:35:02 <lambdabot> "\""
10:49:08 <hstenstrom> What does lambdabot do, and how is it used?
10:49:34 <SamB_XP> @quote
10:49:34 <lambdabot> Cheery says: Monads should be called Paradises
10:49:46 <SamB_XP> it does a lot of things :-)
10:50:02 <Cheery> @quote
10:50:02 <lambdabot> Pseudonym says: I think principal types are overrated
10:50:06 <Cheery> @quote
10:50:06 <lambdabot> Kaji says:  * Kaji beats Gates over the head with a lambda.
10:50:20 <Cheery> too bad it does not share fortunes
10:50:28 <SamB_XP> hmm?
10:50:43 <Cheery> that was very lucky hit
10:50:48 <SamB_XP> you mean you want to download the quotes in fortune cookie format?
10:56:53 <shapr> SHAZAM!
10:56:59 <shapr> bos: You work on SL?
10:59:35 <bos> i do now :-)
10:59:39 <bos> today's my first day
11:01:12 <Nafai> bos: Work for Linden Labs?
11:02:56 <bos> Nafai: yep
11:03:01 <Nafai> Cool
11:03:05 <Nafai> I have a friend that works there
11:06:19 <bos> nice!
11:11:55 <pitecus> is there an instance of arbitray for Data.Tree around?
11:21:43 <hstenstrom> @quote
11:21:44 <lambdabot> skew says: Swapping is just a constant factor
11:21:56 <hstenstrom> @help
11:21:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:22:11 <hstenstrom> list
11:23:26 <hstenstrom> @list
11:23:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:24:27 <hstenstrom> @version
11:24:27 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
11:24:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:24:53 <hstenstrom> @help  babel
11:24:53 <lambdabot> babel <lang1> <lang2> <phrase>.
11:24:54 <lambdabot> Translate a phrase in lang1 to lang2.
11:24:54 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
11:25:53 <hstenstrom> @help src
11:25:53 <lambdabot> src <id>. Display the implementation of a standard function
11:25:54 <norpan> @babel en de i have saurkraut in my lederhosen
11:25:56 <lambdabot>   ich habe saurkraut in meinem lederhosen
11:26:18 <norpan> wow!
11:27:32 <Apocalisp> @babel en de I have pickled cabbage in my leather pants.
11:27:33 <lambdabot>   Ich habe Kohl in meinen ledernen Hosen in Essig eingelegt.
11:28:22 <Apocalisp> @babel en de There is much asshattery in this channel.
11:28:22 <lambdabot>   Es gibt viel asshattery in dieser Führung.
11:28:58 <Apocalisp> teehee
11:34:02 <Apocalisp> @pl regularPolygon numSides sideLength = (let angle = (2*pi) / numSides in take numSides (iterate (rotateVertex angle) (0,(cos(angle) * sideLength))) )
11:34:02 <lambdabot> regularPolygon = ap (flip . (. (liftM2 iterate rotateVertex . ((,) 0 .) . (. cos) . (*))) . (.) . take) ((2 * pi) /)
11:47:03 <shapr> bos: Does that mean we'll see you on Gale too?
11:48:22 <bos> Gale?
11:55:10 <shapr> Yeah, I know some developers at linden use the Gale chat network.
12:03:48 <shapr> bos: Have you seen the Ginsu chat client? Written in Haskell even!
12:04:58 <MyCatVerbs> shapr: I thought Ginsu was the name of an anime series?
12:05:12 * araujo thinking we already have a Haskell: shell, window manager, irc client, editor ......
12:05:15 <MyCatVerbs> Oooh, kitchen knives. Rather more exciting.
12:05:17 <shapr> MyCatVerbs: Could be, I don't know.
12:05:32 <MyCatVerbs> shapr: google says throatcutting devices.
12:05:47 <MyCatVerbs> araujo: we have a Haskell shell? Editor? IRC client?
12:05:49 <vegai> Irc client? Do we?
12:05:55 <araujo> MyCatVerbs, yes
12:06:08 <vegai> Does anyone use that irc client? Or that editor? :)
12:06:14 <MyCatVerbs> araujo: names so I can google, please?
12:06:17 <araujo> hash, hashell, Yi, Ginsu
12:06:22 <araujo> xmonad
12:06:27 <shapr> hircules is juhp's irc client
12:06:46 <vegai> except ginsu isn't irc, is it?
12:07:05 <MyCatVerbs> araujo: errrrr
12:07:38 <MyCatVerbs> araujo: "We have a Haskell shell" <-- on the hash project's front page, "No code has yet been written."
12:07:47 <araujo> It'd be nice to combine all these stuff with House :-)
12:07:59 <araujo> MyCatVerbs, oh, there are many many shells
12:08:09 <araujo> @where hsh
12:08:09 <lambdabot> I know nothing about hsh.
12:08:12 <araujo> mm...
12:08:14 <MyCatVerbs> Well, at least hashell actually exists.
12:08:23 <araujo> hah, that's mine
12:08:29 <araujo> but dons has another one
12:08:41 <MyCatVerbs> That sounds silly.
12:08:48 <araujo> what?
12:08:54 <araujo> @where shell
12:08:55 <lambdabot> I know nothing about shell.
12:08:59 <araujo> @where h4sh
12:08:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
12:09:04 <araujo> there it is :-)
12:09:09 <MyCatVerbs> Wouldn't you be better off throwing one of yours away and both working on the same one? Or merge the codebases for features, whatever.
12:09:30 <araujo> MyCatVerbs, these are all about shell researching
12:09:40 <atp> MyCatVerbs: and fun, which often means re-inventing the wheel
12:09:43 <araujo> on a purely functional language
12:09:48 <atp> it's not all about efficient development :)
12:09:56 <MyCatVerbs> Ahhh, righto.
12:10:07 <MyCatVerbs> Solution-space exploration. Fair enough.
12:10:23 <araujo> i also think CosmicRay is working on one
12:10:35 <araujo> And probably two or three more people here :-)
12:10:49 <atp> writing a shell is a fun semi-advanced learning project in any language
12:11:01 <araujo> indeed
12:11:35 <araujo> you could also consider pugs a shell too :-P
12:11:47 <atp> pugs is pretty neat
12:12:04 <MyCatVerbs> The 'obvious' way to do it would seem to be to hack a REPL with a few extra features for redirection.
12:12:23 <atp> perhaps you should write one, MyCatVerbs
12:12:27 <atp> and join the club :)
12:12:29 <MyCatVerbs> atp: heh. =)
12:12:32 <araujo> yeah, join the party
12:13:13 <MyCatVerbs> araujo: but then I'd have to neglect writing an IRC bot. ;)
12:13:27 <atp> another time-honoured tradition, that
12:13:34 <araujo> well, we have lambdabot
12:13:35 <arcatan> you have to write a IRC bot in every language you learn
12:13:45 * atp wonders how many IRC bots in how many different languages he's written or started writing over the years...
12:13:49 <arcatan> including French
12:14:06 <MyCatVerbs> arcatan: really?
12:14:11 <procyon112> I thought the time honored tradition of Haskell was writing interpreters... I guess I'm behind the times ;)
12:14:44 <MyCatVerbs> arcatan: okay, but does it count if I just write it in Scheme or something, use a weird name-decoration for all my variables and then throw it through a sed script to change all the varaible names into French?
12:14:56 <atp> MyCatVerbs: non
12:15:04 <MyCatVerbs> atp: merde.
12:15:11 <atp> MyCatVerbs: il faut que tu l'ecrit tout en francais, haha
12:15:57 <MyCatVerbs> atp: ...qu'est-ce que la mot pour "cdr" en français? :D
12:16:05 <atp> i do think some of the classic projects are harder to do elegantly with haskell (assuming you're a beginner) because many of the classic projects are very IO driven
12:16:13 <MyCatVerbs> Er, s'il vous plait?
12:16:31 <atp> which is probably why interpreters are an attractive haskell project
12:16:48 <MyCatVerbs> atp: nahhhh. I think the IRC bot thing is trivial, for example, because Haskell is freakishly good for writing parsers for incoming messages.
12:17:02 <arcatan> I tried to write a Brainfuck interpreter but figured out that that would be easier in C :P
12:17:12 <MyCatVerbs> atp: beyond that, you just use a simple event loop and take advantage of Unix's blocking reads on a network socket. ^^
12:17:20 <procyon112> Je parl ampul francais.  I don't speak enough to even say how much I suck ;)
12:17:41 <MyCatVerbs> procyon112: j'ai la meme probleme.
12:17:45 <atp> (je parle un peu francais?  je suck beaucoup?)
12:17:55 <procyon112> heh
12:17:55 * atp grins.
12:18:30 <atp> i went to a french school until i was 10, but my spelling is atrocious ...
12:18:38 <MyCatVerbs> atp: je parle un petit peu de français. Je vais retrouver mon dictionairre. x_x
12:18:41 <procyon112> oui!  Je sui beaucoup suckage.
12:19:12 <procyon112> My spelling is worse than my grammar
12:19:58 <arcatan> je comprends le francais mais je ne le parle pas :|
12:20:11 <shapr> pourquoi pas?
12:20:35 <MyCatVerbs> shapr: parceque la français est malodoreuse.
12:20:37 <atp> j'ai l'impression que tu parles assez bien, arcatan... est-ce que tu a des difficultes de prononciation?
12:20:47 <shapr> MyCatVerbs: nej, det är inte skit!
12:21:08 <MyCatVerbs> shapr: okay, that sure as heck weren't French. What *is* that, Dutch?
12:21:09 <tibbe> @src foldr
12:21:09 <lambdabot> foldr k z xs = go xs
12:21:09 <lambdabot>     where go []     = z
12:21:09 <lambdabot>           go (y:ys) = y `k` go ys
12:21:27 <tibbe> @src foldl
12:21:28 <lambdabot> foldl f z xs = lgo z xs
12:21:28 <lambdabot>     where lgo z []     =  z
12:21:28 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
12:21:29 <atp> something nordic i'd guess?
12:21:46 <arcatan> swedish!
12:21:46 <atp> danish?
12:21:59 <atp> i can never tell those norse languages apart :)
12:21:59 <MyCatVerbs> atp: it *looks* like Dutch, to me, anyway.
12:22:09 <atp> i mean if i hear them i can have a go at it
12:22:18 <atp> because danish sounds like crack and norwegians are so sing-songy
12:22:34 * MyCatVerbs tries to look up which country shapr's in. Just in case it's something totally curveball, like Afrikaans.
12:22:36 <atp> dutch i know very little about, unfortunately...
12:22:51 <atp> afrikaans is just pidgin dutch anyway
12:22:52 <arcatan> atp: my French vocabularly has gaping holes, so it's difficult to produce text
12:22:59 <shapr> MyCatVerbs: I'm in Alabama. We speak Swedish, French, and some Dutch and German here.
12:23:02 <atp> arcatan: ah.  i see.
12:23:03 <MyCatVerbs> atp: yeah, that's why I checked. =)
12:23:10 <shapr> Ik begrijp het niet!
12:23:14 <MyCatVerbs> shapr: whoa. Contact with the Amish or something?
12:23:15 <dylan> atp: afrikaans is considered a seperate language now, iirc.
12:23:17 <atp> shapr: that's dutch
12:23:22 <shapr> atp: That's right
12:23:36 <atp> dylan: yeah, it is.  my stepdad is south african.
12:23:38 <shapr> MyCatVerbs: Nah, I live in Birmingham, doesn't everyone here speak those languages?
12:23:44 <atp> dylan: but in practice, the two languages are still very similar
12:24:00 <MyCatVerbs> shapr: please stop hurting my head. ._.
12:24:01 <dylan> atp: sort of like the difference between english and scots.
12:24:18 <atp> dylan: yeah.  and lord knows some scottish people speak dialects i can't make heads or tails out of
12:24:58 <dylan> atp: of course, then you have scots gaelic..
12:25:09 <atp> so shapr, which language was the first?
12:25:18 <atp> dylan: different beast entirely, that...
12:25:25 <dylan> atp: if you're a purist, then scots isn't really a seperate language from english... and in that case, Friisian (sp?) is the closest living relative.
12:25:33 <shapr> atp: I'm from the Southeast USA originally, so I learned Southern drawl first!
12:25:45 <dylan> atp: of course, it's a Q-celtic language. Not a horrible west-germanic one.
12:25:59 <atp> shapr: no i mean, which was the first non-english language you spoke in the channel
12:26:19 <atp> dylan: nothing wrong with germanic languages, i speak two, they're quite expressive
12:26:41 <atp> dylan: and all indo-european languages are so similar anyway
12:26:44 <dylan> atp: horrible in a sarcastic way.
12:28:14 <atp> shapr: anyway it's nice to meet another polyglot american... euros always assume we can only speak one language, the fools
12:30:23 <dylan> I'm american and speak two. No enough practice in the second to consider a third. :(
12:31:04 <atp> i speak 4 fluently, and am reasonably conversant in a third... but then i'm a first generation immigrant, and lived abroad for most of my younger years, so maybe that's cheating
12:31:12 <atp> err not third, fifth :)
12:32:32 <thorkilnaur> atp, "nej, det Ã¤r inte skit!" is Swedish
12:32:54 <dylan> my girlfriend speaks french, and I speak spanish, and sometimes we eschew english for an entire day.
12:32:57 <atp> thorkilnaur: what does it mean?
12:33:47 <atp> dylan: spanish is quickly becoming a necessary language where i live (california) ... that's mostly why i'm conversant in it (it's the 5th)
12:34:21 <thorkilnaur> atp, something like "No, it's not bad", but unfortunately, it was a response to something French that I am not sure I understand completely
12:34:21 <dylan> atp: same here -- I live in Florida.
12:34:23 <atp> dylan: lots of americans are complaining about that, but i don't think that mandatory bilingual education would be a bad thing at all
12:34:51 <dylan> atp: heaven forbid there be spanish speakers in *California*, or *Texas*, or *Florida*...
12:35:05 <atp> if suddenly all public schools were taught in both english and spanish, and all the anglos had to (in principle) learn spanish and the latin americans (in principle) learn english, i think we'd all be better off
12:35:09 <atp> being bilingual is great
12:35:24 <dylan> or Nevada, Colorado...
12:35:26 <kolmodin> atp, shapr: do you get to study other languages in school too in the US? I mean from a low age
12:35:28 <arcatan> I need to practice my French
12:35:43 <arcatan> being fluent in something other than English would be useful
12:35:47 <kolmodin> in Sweden you learn English from 3rd grade (age 9)
12:36:23 <atp> kolmodin: the elementary school across the street has a spanish immersion program... these are becoming more and more common but are sadly not the norm... here in CA, you start foreign language education at age 12
12:36:24 <migraine> darn haskell... can't code in C anymore without thinking how much better it could be in haskell
12:37:12 <tibbe> @src Control.Maybe.mplus
12:37:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:37:15 <atp> kolmodin: and there's not much emphasis on fluency, really.  i took 5 years of japanese, for example, but i could never have held a very complex conversation with a native speaker.
12:37:53 <arcatan> specify complex
12:38:12 <atp> arcatan: more than, gee it's cold today, or, hi, how are you, have you eaten yet?
12:38:16 <dylan> I have three college semesters in spanish and I'm still scared about even speaking to native speakers.
12:38:23 <atp> dylan: don't be
12:38:44 <dylan> I can say "Where is the toilet?" in quite a few language.
12:38:48 <dylan> *languages.
12:38:54 <phoniq> hit 'em with the speedy gonzales they love it
12:39:00 <kolmodin> atp: yeah, it's hard if you don't pracise with the native speakers
12:39:09 <arcatan> native speakers are probably just happy when you're able to speak their language
12:39:16 <arcatan> even if you suck
12:39:17 <dylan> I also know "he na cackie an th' cludgie waws"
12:39:32 <atp> kolmodin: also, to be fair, i think the level of english fluency in sweden has a lot to do with your tv shows not being dubbed
12:39:38 <atp> kolmodin: and less to do with education
12:39:49 <atp> kolmodin: most of the rest of europe isn't that great at english
12:39:56 <kolmodin> atp: very true
12:40:05 <arcatan> my English skills are because the Internets are in English :|
12:40:15 <atp> arcatan: what's your native language?
12:40:19 <arcatan> Finnish
12:40:28 <atp> finland is cool
12:40:33 <kolmodin> atp: we're not as good at french or german as we are at english
12:40:33 <dylan> the average highschool graduate in the US doesn't have that great a grasp of English anyway.
12:40:51 <kolmodin> finnish is cool, except it's completely different from all other languages I know
12:41:05 <atp> kolmodin: yeah, it's a bit like estonian, only maybe less complex, a little
12:41:05 <kolmodin> so I really really don't understand anything :)
12:41:22 <dylan> isn't finish a language isolate?
12:41:27 <atp> dylan: no
12:41:30 <atp> dylan: it's finno-ugric
12:41:36 <dylan> no? What family is--ah.
12:41:38 <atp> dylan: related to estonian, hungarian, and saami
12:41:53 <arcatan> and lots of very small languages in Russia
12:41:53 <atp> dylan: and a host of siberian languages that don't bear much superficial resemblence
12:42:00 <arcatan> yeah
12:42:04 <thorkilnaur> kolmodin, Not even "yksi, kaksi, kolme" (spelled wrong, perhaps, sorry)?
12:42:17 <atp> the only word i can remember in finnish is perkele :)
12:42:20 <kolmodin> thorkilnaur: that I do understand :D
12:42:40 <kolmodin> thorkilnaur: I even find the danish language to be easier than finnish :D
12:42:50 <ari> atp: That's the only word that counts :)
12:43:01 <atp> finnish has a wacky front/back vowel distinction that i find rather hard to manage
12:43:16 <atp> also, both consonants and vowels have a length contrast iirrc
12:43:19 <atp> iirc even :)
12:43:39 <atp> on the plus side, no genders, and stress is very regular
12:43:45 <kolmodin> atp: you seem to know more about languages than most
12:43:57 <atp> i'm a language geek
12:44:07 <atp> comes from speaking a lot of them i suppose...
12:44:08 <kolmodin> :D
12:44:18 <kolmodin> me too, but not natural languages...
12:44:33 <atp> oh yeah?  you like conlangs?
12:44:34 <dylan> I used to be able to write some poetry in lojban.
12:44:43 <atp> lojban is pretty neat
12:44:47 <shapr> coi rodo .i ma nuzba
12:44:54 * DRMacIver spent about two days trying to learn lojban and then got bored
12:44:55 <shapr> mi djice lenu mi gunka
12:45:00 <shapr> djica*
12:45:07 <shapr> atp: puhutko suomea?
12:45:17 <atp> shapr: no
12:45:19 <atp> puhun
12:45:20 <atp> ?
12:45:32 <atp> wait, does puhu take the partitive?
12:45:39 * atp can't remember...
12:45:39 <dylan> I remember coi and .i, and that's it.
12:45:53 <atp> suomea is partitive, or elative?  arcatan?
12:45:54 <Vulpyne> Ever look at Ithkuil?
12:46:19 <shapr> atp: puhutko is the question form
12:46:21 <kolmodin> atp: computer languanges, yes :)
12:46:25 <atp> kolmodin: hehe
12:46:32 <shapr> minä en puhu suomea
12:46:36 <kolmodin> atp: although I don't know that many. haskell would be the most "extreme"
12:47:23 <atp> shapr: en puhun suomea means i don't speak finnish, right?
12:47:51 * atp sighs... so many languages, so little time
12:47:52 <kolmodin> jag talar svenska :)
12:48:03 <kolmodin> och shapr
12:48:05 <shapr> Jag också!
12:48:08 <kolmodin> :D
12:48:10 <shapr> ja ja!
12:48:14 * shapr studsar och hoppar
12:48:15 <kolmodin> bra bra :)
12:48:15 <atp> hey kolmodin, what does "slut" mean in swedish?  stop, or something?
12:48:21 <shapr> atp: Yes, 'stop'
12:48:22 <kolmodin> atp: end
12:48:38 <atp> hm
12:48:58 <atp> i don't really know enough about the nordic languages... my dad speaks danish, he went to uni there
12:48:58 <thorkilnaur> kolmodin, shapr SÃ¥ forstÃ¥r I sikkert ogsÃ¥ lidt dansk, sÃ¥dan til husbehov
12:48:59 <kolmodin> end of the tunnle = slutet pÃ¥ tunneln
12:49:13 <ari> atp: Ay, "suomea" is partitive, and "I don't speak Finnish" is "en puhu suomea" (auxiliary verb of negation ftw(
12:49:26 <kolmodin> thorkilnaur: yeah, but only written danish, not when you guys speak it :D
12:49:41 <atp> ari: oh right, "puhun suomea" means i do speak finnish, and "en puhu ..." means i don't, right?
12:49:42 <shapr> Finnish is awesome, too bad I didn't learn it well enough to use it.
12:49:44 <kolmodin> I had to speak english to you and Lemmih at the hackathon :D
12:49:45 <thorkilnaur> atp, Which uni was that, and when?
12:49:56 <shapr> Jag talar inte dansk.
12:50:03 <ari> atp: aye
12:50:06 <kolmodin> *danska
12:50:16 <atp> thorkilnaur: the international people's school in helsingor, i guess it would have been in the late 60s
12:50:16 <shapr> atp: I spent 3.5 years in Finland and 3.5 years in Sweden.
12:50:30 <shapr> atp: I suspect you're older than I am.
12:50:32 <kolmodin> shapr: which did you prefer...? o_O?
12:50:36 <atp> shapr: i'm 27 ?
12:50:53 <shapr> kolmodin: Sort of like saying which of Epigram or Haskell do you prefer.. they're both cool in different ways.
12:51:07 <thorkilnaur> atp, ok
12:51:11 <atp> so what's up with the finns always losing to the swedes in hokey, anyway.  i don't get it.  it always looks like they're going to win, and then BAM
12:51:12 <kolmodin> shapr: yeah, it was a trick question
12:51:12 <shapr> atp: Ok, maybe not.
12:51:23 <atp> hockey even
12:51:31 <atp> shapr: how old are you?
12:51:41 <shapr> atp: trettio fem
12:52:05 <atp> shapr: ah, a smidgen older than me then :)
12:52:07 <shapr> heh
12:52:12 <Apocalisp> sagde nogen dansk?
12:52:21 <shapr> kanske!
12:52:29 <shapr> Is there a #haskell.dk ?
12:52:38 <Apocalisp> join #haskell.dk
12:52:46 <atp> i read somewhere that danish kids learn to speak a full year later than the european average
12:52:54 <shapr> I stay in #haskell.se where I can understand stuff!
12:52:55 <atp> because their language is so hard to pronounce :)
12:53:05 <thorkilnaur> Apocalisp, Joh, vi er da et par stykker
12:53:16 <kolmodin> j'ai vingt trois ans
12:53:19 <shapr> Danish sounds almost exactly like Swedish from my USA perspective. Same for Norsk.
12:53:30 <Apocalisp> Sounds?
12:53:43 <Apocalisp> No way.
12:53:44 <atp> swedish people enunciate better it seems, but i don't speak the language
12:53:53 <shapr> I can understand Danish and Norwegian just fine if they speak slowly and clearly.
12:53:58 <atp> when i try to repeat danish words danes laugh at me
12:54:04 <kolmodin> atp: it's true! they are close to impossible to understand
12:54:07 <atp> swedes seem to understand what i'm trying to say
12:54:21 <kolmodin> Norwegian is so much easier
12:54:32 <Apocalisp> fnys, fnys, fnys, og endnu engang fnys.
12:54:34 <thorkilnaur> shapr, Danes generally understand Norwegian easier than Swedish
12:54:36 <atp> you sure you don't need to be a singer to speak norwegian?
12:54:42 <atp> they always sound like they're yodeling
12:54:53 <atp> norwegian girls are hot though so it's all good
12:55:15 <shapr> I'm biased towards Swedish girls.
12:55:37 <shapr> Especially the one I'm dating now.
12:55:53 <atp> hehe
12:56:00 <Apocalisp> Eru hér einhverjir háfrónskir harðsoðnir haskellingar?
12:56:13 <shapr> Hey, you have to use utf-8 on this channel.
12:56:42 <shapr> salut the_dormant, ca va?
12:57:04 <mnislaih> Swedish speak sounds like the Heidi soundtrack compared to finnish,
12:57:12 <atp> si tu commences a parler avec tlm en francais ou alors suedois tu vas leur faire peur, shapr
12:57:40 <the_dormant> shapr:
12:57:40 <atp> swedish speaking finns speak funny swedish, too
12:57:42 <the_dormant> shapr: trÃ¨s bien et toi :) ?
12:58:03 <shapr> atp: Like Linus
12:58:12 <shapr> bien!
12:58:22 <atp> shapr: i've never actually heard him speak swedish
12:58:26 <shapr> atp: Bah, I'm not that scary.
12:58:34 <atp> (not that it would matter as i don't speak swedish myself)
12:58:45 <ari> http://www.kernel.org/pub/linux/kernel/SillySounds/swedish.au
12:59:17 <kolmodin> ari: nice :D
12:59:47 <kolmodin> ari: you can clearly hear the finnish-swedish accent
12:59:51 <shapr> yup
12:59:52 <shapr> clearly
13:00:03 <atp> can linus speak finnish?
13:00:08 <kolmodin> expecially on Torvalds
13:00:11 <atp> i mean, and not sound retarded?
13:00:21 <kolmodin> and "uttalar"
13:00:37 <shapr> Most swedish speaking Finns do speak Finnish, but not all. I don't know about Linus specifically.
13:00:53 <kolmodin> I guess he does
13:01:00 <TomMD> Is there a standard function that I am duplicating when I make my safeTail function in which safeTail [] = []?
13:01:05 <atp> shapr: all the ones i met were conversant, could order food and have simple conversations, but not all of them were fluent
13:01:05 <ari> I exchanged a couple of words with him at a book signing a couple of years ago in Finnish
13:01:07 <shapr> You should this crazy half Finnish half Swedish mix they have in the far north. Mienkele or something.
13:01:24 <ari> ... and of course heard him speak a bunch more before that
13:01:44 <atp> ari: and so he speaks it properly?
13:01:51 <roconnor> do I use HaXml to generate XML?  I want to make an atom feed
13:01:55 <ari> Didn't sound all that bad to me, although he did have problems remembering words
13:02:07 <ari> shapr: MeÃ¤nkieli, I think
13:02:17 <atp> ari: is his wife finnish finnish or finnish swedish?
13:02:30 <shapr> ari: Thanks
13:02:47 <shapr> roconnor: I think there are one or two Atom modules already. Do you want to write your own?
13:03:05 <roconnor> Oh, well, I'll use an existing one hen
13:03:06 <roconnor> then
13:03:11 <roconnor> @where Atom
13:03:11 <lambdabot> I know nothing about atom.
13:03:14 <roconnor> :)
13:03:19 <ari> atp: Finnish Swedish, I think, Tove isn't a Finnish name
13:03:22 <shapr> @go filetype:hs atom xml
13:03:24 <lambdabot> http://darcs.haskell.org/SoC/haskellnet/test/AtomTest.hs
13:04:08 <roconnor> hmm, at first glance, that seems to be parsing Atom rather than generating it
13:04:13 <shapr> hmm
13:04:40 <Baughn> ari: There are plenty of finns named "Tove". That said, it is originally a swedish-norwegian name
13:07:29 <ari> Baughn: Well, it is a Swedish/Norwegian name in my books, because it sounds... *wrong* to me if I pronounce it in Finnish
13:07:44 <TomMD> @src words
13:07:44 <lambdabot> words s = case dropWhile isSpace s of
13:07:45 <lambdabot>     "" -> []
13:07:45 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
13:08:37 <mauke> TomMD: drop 1
13:09:06 <TomMD> Of coarse - thanks.  I knew there was something I was missing.
13:15:24 <thruspa> Hi.
13:16:44 <sjanssen> TomMD: safeTail = drop 1
13:16:58 <sjanssen> greetings, thruspa
13:17:28 <sjanssen> bah, mauke beat me
13:19:51 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1876
13:20:14 <thruspa> I have a begginer's doubt. If I don't interrupt anyone, could I ask about it?
13:20:16 <TomMD> sjanssen: Having two people covering my stupidity is fine.  I always like to have things beat into me.
13:20:33 <njbartlett> Just got back from Fun in the Afternoon..
13:20:38 <sjanssen> thruspa: feel free
13:20:45 <thruspa> Thank you.
13:21:32 <thruspa> I have to pass a very big data structure in a state monad.
13:22:00 <thruspa> When I want to update a field in that structure, I have to write some hellish pattern-matches.
13:22:17 <thruspa> Is there an easy way to update a structure with many fields?
13:22:22 <sjanssen> thruspa: perhaps you should use record syntax?
13:22:41 <sjanssen> data Foo = Foo {bar :: Int, baz :: Char}
13:23:07 <sjanssen> say you want to set bar to 2: modify (\s -> s {bar = 2})
13:23:35 <sjanssen> to read the value of baz: do myBaz <- gets baz; stuff_with_baz
13:23:41 <thruspa> I didn't know about that kind of modification.
13:23:48 <thruspa> I think it's what I need.
13:24:03 <thruspa> Great! Thank you!
13:24:31 <atp> thruspa: check out Yet Another Haskell Tutorial, section 7.7.1 for an in-depth but approachable treatment
13:26:08 <thruspa> Aha. There it is. I had overlooked it.
13:26:11 <thruspa> Thanks again.
13:35:18 <chitin> how can I change the type/bounds of an array from (Int,Int) to ((Int,Int),(Int,Int)) ?
13:35:35 <bos> @where log
13:35:35 <lambdabot> I know nothing about log.
13:35:37 <bos> @where logs
13:35:38 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
13:36:08 <sjanssen> @hoogle ixmap
13:36:08 <lambdabot> Array.ixmap :: (Ix a, Ix b) => (a, a) -> (a -> b) -> Array b c -> Array a c
13:36:08 <lambdabot> Data.Array.ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
13:36:08 <lambdabot> Data.Array.IArray.ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
13:37:47 <chitin> @docs ixmap
13:37:47 <lambdabot> ixmap not available
13:38:00 <sjanssen> @docs Data.Array
13:38:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
13:38:33 <chitin> sjanssen: I don't really want to change one. I want it to be that way when it is created.
13:39:17 <sjanssen> chitin: then you should just create it differently? :)
13:39:24 <yakov> hi
13:39:59 <chitin> sjanssen: It's not being created. It's a parameter
13:40:05 <chitin> sjanssen: Array Int Double -> Int -> Int -> Double
13:40:49 <chitin> sjanssen: and when I attempt to do (_,(_,n)) = bounds dist
13:41:02 <chitin> I get a type error: *** Type           : (Int,Int)
13:41:02 <chitin> *** Does not match : (a,(b,c))
13:41:18 <sjanssen> chitin: you should probably change the type of the argument, then
13:41:37 <sjanssen> Array (Int, Int) Double -- if you want to access the bounds as a tuple
13:42:29 <chitin> sjanssen: thanks, I will try that
13:58:10 <atp> hey, does anybody feel like helping me understand why my code isn't doing what i think it ought to?  it's a relatively simple, small monad that catches errors, you can find it at http://csbd.org/~atp/errormonad.hs
13:58:33 <fasta> I have these patterns in my code, but other than making the combine function receive monadic arguments(or building a compiler), I don't immediately see how to eliminate the intermediate names
13:58:35 <fasta>  
13:58:35 <fasta> somefunction_someargument <- somefunction someargument
13:58:35 <fasta> anotherfunction_anotherargument <- anotherfunction another_argument
13:58:35 <fasta> combine somefunction_someargument anotherfunction_anotherargument
13:58:35 <fasta>  
13:58:36 <fasta> VS
13:58:38 <fasta>  
13:58:40 <fasta> combine (somefunction someargument) (anotherfunction another_argument)
13:58:49 <atp> basically, as written, test_func 1 0 will throw a "complex result" error instead of a divide by zero error, and i don't understand why
14:00:50 <Saizan> fasta: yeah i had the same problem yesterday, no easy way around that with standard combinators
14:00:52 <sjanssen> atp: maybe you mean <= 0?
14:01:11 <atp> sjanssen: haha, actually i mean == 0... stupid me
14:01:52 <fasta> Saizan: It makes me think Haskell is unsuited for computations that are not purely functional.
14:01:59 <Saizan> fasta: you can eleminate one: sf sa >>= \x -> anf ana >>= combine x
14:02:19 <sjanssen> fasta: liftM2?
14:02:22 <atp> sjanssen: now it works, thanks ... that was a stupid bug.  otherwise, do you have any pointers on the code?  style, anything like that?  i'm still a beginner
14:02:22 <Saizan> fasta: or you can define a >>=>>=
14:02:53 <Saizan> ?type \m1 m2 f -> join (liftM2 f m1 m2)
14:02:53 <fasta> sjanssen: Hmm, I keep forgetting about that.
14:02:55 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => m a1 -> m a2 -> (a1 -> a2 -> m a) -> m a
14:03:08 <Saizan> uh right, with join
14:03:43 <sjanssen> @type ap
14:03:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:03:49 <sjanssen> nah, that won't work
14:04:08 <sjanssen> yeah, join . liftM2 $
14:05:05 <Saizan> ?type ((join .) .) . liftM2 $ -- :)
14:05:07 <sjanssen> @pl x >>= \xx -> y >>= \yy -> f xx yy
14:05:07 <lambdabot> parse error (possibly incorrect indentation)
14:05:07 <lambdabot> (y >>=) . f =<< x
14:05:15 <Saizan> ?type ((join .) .) . liftM2
14:05:16 <fasta> I don't think liftM2 applies in this case.
14:05:17 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:05:41 <Saizan> fasta: why not? the types match if you join at the end
14:06:42 <fasta> The exact problem I have now is:
14:06:43 <fasta> foo_bar <- foo bar
14:06:43 <fasta> a_b <- a b
14:06:43 <fasta> case compareMaybe foo_bar a_b of
14:06:43 <fasta>   ....
14:06:57 <Saizan> oh
14:07:00 <sjanssen> there's no helping the case statement
14:07:56 <Saizan> you need a monadic case there :)
14:08:16 <fasta> I end up programming in Scheme in Haskell.
14:08:42 <fasta> I already have the when operator, the whenL, forever, and I don't know what else :)
14:09:11 <Saizan> you need the monad inside that case?
14:09:31 <fasta> Saizan: ?
14:10:36 <Saizan> can write it as a pure function and liftM here?
14:11:37 <fasta> Saizan: I am sorry you write somewhat too much compressed.
14:12:11 <Saizan> can you write the case ... of ... as a standalone function? then it's easier to combine
14:13:25 <fasta> Saizan: the various cases go in recursion and all return a monadic value
14:13:33 <fasta> Saizan: I am still not sure what you mean, though.
14:16:47 <Saizan> i mean that you can have |where foobar x y = case compareMaybe x y of ...|  and |join (liftM2 foobar (foo bar) (a b))| here
14:16:51 <chessguy> @type quickCheck
14:16:59 <lambdabot> forall a. (Testable a) => a -> IO ()
14:17:30 <chessguy> is there a version of this function that returns a bool or something programmatically useful?
14:17:41 <Saizan> unless you need some other bindings from the current do-block inside foobar
14:18:28 <fasta> Saizan: Ok, I see your point, but in theory one could also create a function taking all bindings from the do-block.
14:18:58 <fasta> Saizan: no, it takes one argument from the do-block.
14:19:07 <fasta> Saizan: a closure holding about 4 arguments.
14:20:53 <Saizan> fasta: last try :D -> liftM2 compareMaybe (foo bar) (a b) >>= \x -> case x of ..
14:23:27 <fasta> Another thing I find weird about Haskell is that it even has a let keyword.
14:23:42 <fasta> Since it has indentation, that should be redundant.
14:25:05 <Wild_Cat> fasta: How would you do away with let?
14:25:21 <emu> where!
14:25:24 * Wild_Cat doesn't like let anyway. where ftw.
14:26:45 <Baughn> fasta: The indentation is optional
14:26:51 <fasta> toplevel a b =
14:26:53 <fasta>                f a = zork
14:26:53 <fasta>                g a = bar
14:26:53 <fasta>                f (g 1) (g 2)
14:27:37 <fasta> Baughn: yes, but when you are in the optional "indentation mode" my point still holds
14:28:11 <fasta> Baughn: AFAIK the indentation is optional is only a service to make it easier to compile to Haskell.
14:33:34 * Saizan wonders how much work would be to add caseM and ifM
14:33:56 <fasta> Saizan: not much, probably.
14:34:14 <sjanssen> Saizan: maybe it's better to add lambda case?
14:34:39 <Saizan> GHC desugars at the "last minute" i've read
14:34:45 <Saizan> sjanssen: lambda case?
14:35:16 <sjanssen> such that (\case of alts) desugars to: (\uniqueVar -> case uniqueVar of alts)
14:35:37 <sjanssen> then caseM m {alts} becomes:
14:35:45 <sjanssen> m >>= \case of {alts}
14:36:38 <fasta> The problem with all these "improvements" is that they make the language into a beast the size of Japan.
14:36:58 <sjanssen> lambda-case is a pretty small change (and it's flexible!)
14:37:16 <Saizan> yeah, very nice
14:38:33 <Saizan> you'd still have to use >>= inside do-notation in this case, though
14:38:49 <sjanssen> right
14:39:08 <sjanssen> it doesn't really solve the ifM problem -- but 'if' has problems already
14:41:10 <sjanssen> ifM could be a function, as long as you don't fear parens
14:41:35 <sjanssen> ifM cond (a b c) (x y z)
14:41:58 <atp> it seems the further we move away from lisp, the more we find ourselves coming back to it...
14:43:22 <Saizan> i tend to use HOFs like maybe or either,anyway
14:44:03 <sjanssen> http://hackage.haskell.org/trac/haskell-prime/ticket/41
14:44:05 <lambdabot> Title: #41 (add LambdaCase) - Haskell Prime - Trac
14:44:15 <sjanssen> http://hackage.haskell.org/trac/haskell-prime/ticket/114 is an interesting related proposal
14:44:15 <lambdabot> Title: #114 (introduce lambda-match (explicit match failure and fall-through)) - Haskel ...
14:47:45 <cdsmith> sjanssen: update on the safety stuff.  Igloo feels it would be better to do it on a per-module basis.
14:48:14 <sjanssen> cdsmith: there's a good argument for that
14:48:50 <cdsmith> Yep.  It's simpler, anyway.  Rule: a module is safe if we declare it so, or if it depends only on safe modules and doesn't use -fffi, -fth, etc.
14:48:51 <fasta> What kinds of safety?
14:49:25 <sjanssen> cdsmith: ah, so the entire module becomes tainted?
14:49:35 <cdsmith> fasta: more info than you could possibly want is at http://www.pphsg.org/safeghc
14:49:37 <lambdabot> Title: Safe Mode for GHC - Ideas
14:49:41 <sjanssen> @hoogle unsafePerformIO
14:49:42 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
14:49:52 <sjanssen> @hoogle unsafeIOToST
14:49:52 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
14:49:53 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
14:50:11 <sjanssen> cdsmith: that means moving things like unsafeIOToST around
14:50:28 <xDie> @join #ubuntu-br
14:50:28 <lambdabot> Not enough privileges
14:50:34 <cdsmith> sjanssen: yes, a module at a time is tainted.  And yes, the need to reorganize base was discussed.
14:51:04 <cdsmith> There was even a mention of doing is on a per-package basis, and creating a new package base-unsafe.
14:51:26 <ibid> lambdabot has evidently joined the bot liberation movement
14:51:34 <fasta> The "promise" is already implemented in PLT Scheme, AFAIK.
14:51:58 <fasta> Or at least something very similar to it.
14:52:11 <cdsmith> fasta: and even Java, but not Haskell
14:52:40 <fasta> cdsmith: right, but AFAIK, they did it somewhat more elegant in PLT Scheme (surprise! ;))
14:52:58 <sjanssen> fasta: do you have a link handy? (or some good search terms)
14:53:23 <fasta> sjanssen: custodians, AFAIR
14:54:53 <cdsmith> sjanssen: Igloo also mentioned doing the whole thing with Cabal.  I don't know enough to know if that's feasible.
14:55:23 <sjanssen> cdsmith: it could be done if everything is at the package level
14:55:50 <sjanssen> Cabal isn't smart enough to do taintedness at the module level
14:55:57 <cdsmith> sjanssen: So that presumes splitting base, then.
14:56:42 <sjanssen> cdsmith: yeah
14:56:57 <sjanssen> cdsmith: and every package that has an intentionally unsafe function
14:57:06 <sjanssen> package level probably isn't feasible
14:57:07 <cdsmith> Doesn't Cabal just generate Haskell code to run with the runhaskell command?
14:58:33 <sjanssen> cdsmith: Cabal is just a library that reads a .cabal file and tells GHC to do some things
14:59:09 <cdsmith> But it has something to with the Setup.[l]hs files in packages, right?
14:59:24 <sjanssen> it's fairly naive in some respects -- it knows nothing about module dependencies, for example, it lets GHC handle that
14:59:46 <sjanssen> cdsmith: the Setup.lhs are little boilerplate programs that call into the Cabal library
14:59:58 <cdsmith> Well, if it would be limited to packages and packages aren't feasible (which I agree with), then we could skip me understanding Cabal. :)
15:00:36 <sjanssen> import Distribution.Simple; main = defaultMain -- this is the canonical Setup.hs
15:02:41 <sjanssen> cdsmith: anyway, the module approach is simpler
15:02:41 <cdsmith> Okay, that makes sense.  In any case, it looks like modules are the way to go.
15:03:06 <sjanssen> the compiler just needs to know a handful of modules are fundamentally unsafe
15:03:45 <cdsmith> The outstanding question, for me, is whether we still let the code declare its own safety ({-# SAFE #-} in a module) and separate trust from safety; or just combine the concepts and have a list of inherently safe modules somewhere.
15:04:32 <sjanssen> I think there ought to be a difference between modules that intend to be unsafe and modules that use unsafe features but intend to be safe
15:04:53 <sjanssen> you probably don't want to make "-trust System.IO.Unsafe" possible
15:05:13 <cdsmith> sjanssen: so that argues for continuing to separate trust from safety?
15:05:23 <sjanssen> cdsmith: yes, I suppose so
15:06:05 <cdsmith> So then we'd still specify trust on a package-by-package basis, and ignore safe declarations in untrusted packages (not modules).  Seem right?
15:06:27 <sjanssen> cdsmith: yeah, seems right
15:06:32 <cdsmith> (but safe declarations now apply to entire modules)
15:07:18 <sjanssen> because you want to distinguish between Data.ByteString (notorious safe user of unsafePerformIO), and some random module that happens to use Data.ByteString
15:07:40 <cdsmith> ???
15:07:50 <cdsmith> Did you mean "happens to use unsafePerformIO"?
15:08:06 <sjanssen> no, I mean unsafePerformIO
15:08:21 <sjanssen> bah, I suck
15:08:27 <sjanssen> I mean what I said initially
15:08:44 <cdsmith> Okay: what's the distinguishing feature?
15:09:01 <sjanssen> let's say module Foo imports ByteString
15:09:17 <sjanssen> Foo just uses the innocent functions from ByteString (head, tail, etc.)
15:09:46 <sjanssen> and a client program uses Foo only
15:10:03 <cdsmith> So if ByteString's package is trusted, then Foo is considered safe as well, right?
15:10:33 <sjanssen> in trusted mode, ghc will refuse to compile saying something like "Add -trust ByteString or Foo to compile this package"
15:11:04 <sjanssen> if we add a SAFE pragma to ByteString, we know to suggest giving trust to ByteString, not Foo
15:11:27 <cdsmith> sjanssen: Well, -trust Foo should only work if the module in package Foo has a SAFE declaration.
15:11:30 <sorear> hello.
15:11:30 <lambdabot> sorear: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:11:50 <cdsmith> Wait, is Foo a package or a module?
15:11:54 <shapr> @yow !
15:11:55 <lambdabot> Hello.  Just walk along and try NOT to think about your INTESTINES
15:11:55 <lambdabot> being almost FORTY YARDS LONG!!
15:11:56 <sjanssen> cdsmith: right.  I was imagining a world without SAFE, and trying to justify it
15:12:06 <sjanssen> cdsmith: module
15:12:07 <cdsmith> sjanssen: Ah, okay.
15:12:40 <cdsmith> So you'd need to add -trust foopackage, not -trust Foo; are we agreed on that?
15:12:58 <sjanssen> I thought trust was on a per-module basis?
15:13:03 <cdsmith> sorear: hello
15:13:17 <cdsmith> sjanssen: I thought safety was per-module, but trust was still per-package
15:13:40 <sjanssen> cdsmith: that's an option too
15:13:49 <sjanssen> I don't have an opinion there
15:14:09 <cdsmith> sjanssen: if we separate trust/safety, then I don't see a scenario where I'd trust one module in a package, but not another.
15:15:42 <cdsmith> I guess my motivation is to avoid having to specify a hundred lines of -trust options to GHC.  Not a noble cause, exactly, but I think worthwhile.
15:16:56 <fasta> Wouldn't the correct solution be to write a proof that it really is safe?
15:16:56 <fasta> Instead of the "practical" solution to tag things as being safe or not?
15:17:23 <cdsmith> fasta: Rice's theorem precludes that in general.
15:17:38 <cdsmith> Or do you mean have the programmer write a proof?
15:17:39 <fasta> cdsmith: That would be highly unlikely.
15:17:40 <sorear> @messages
15:17:40 <lambdabot> kc5tja said 6h 23m 43s ago: No such file exists in the repo. However, I now have an integer parser in about 12 lines of code. I had to introduce some more variables because it's not possible to
15:17:40 <lambdabot> resort to an all-stack implementation without resorting to PICK and ROLL, which I'm religiously against for maintenance reasons.
15:17:40 <lambdabot> kc5tja said 6h 8m 19s ago: Oops -- discovered your address based on output from darcs send. No email file, but it was stored also in the patch context too.
15:17:57 <fasta> cdsmith: yes, the programmer.
15:18:21 <sjanssen> cdsmith: yes -trust on a per package basis seems better
15:18:26 <fasta> I don't think there's anything wrong with writing a proof as a programmer.
15:18:48 <cdsmith> fasta: hmm... I'm afraid that starts to reintroduce the level of complexity that Igloo didn't like, though.  The information needed to verify the proof is probably on a per-expression basis.
15:19:06 <fasta> It just depends on how smart the language is in which you have to write it.
15:19:15 <sjanssen> proofs are too complicated
15:19:42 <fasta> It's just that today there's little technology like that for free.
15:19:52 <fasta> Some commercial implementations seem nice, though.
15:20:07 <monochrom> Every time you write "newtype X = X Y", it is already a proof that "X is isomorphic to Y".
15:20:16 <cdsmith> fasta: that does sound cool -- don't get me wrong -- but probably not the ideal  short-term answer.
15:20:22 <sjanssen> I could imagine a scenario where one could add a {-# SAFETY_PROOF blah blah blah #-} pragma someday -- it would let the compiler automatically -trust the module if the proof is valid
15:20:39 <cdsmith> sjanssen: yes!  I was thinking the same thing.
15:20:41 <fasta> cdsmith: yes, problem would be that probably everybody thinks that way :)
15:20:47 <sjanssen> ie. optionally and in the future
15:20:51 <fasta> cdsmith: i.e. in 30 years the same problem exists.
15:21:22 <cdsmith> fasta: I tell you what.  I'll strongly consider doing that for a doctoral thesis one of these days.
15:21:35 <monochrom> However, don't make handwritten proofs mandatory in all cases. If you don't prove, it's still ok for most trivial cases. If you prove, more things get an ok.
15:21:47 * sjanssen leaves
15:21:55 <fasta> cdsmith: there's little chance one person could pull that off.
15:22:23 <fasta> cdsmith: maybe it could think of the right interface, but an actual implementation probably takes longer.
15:22:44 * kolmodin will go and sleep. good night!
15:23:02 <cdsmith> fasta: Well, the nice thing about that was I get to put it off.  I won't even be applying to graduate schools until this fall.
15:23:05 <monochrom> 30 years is still too short for a cultural change. Programmers' willingness to prove is entirely cultural.
15:23:30 <fasta> monochrom: it depends on who you define to be programmers.
15:24:17 <pejo> sjanssen, isn't that similar thoughts to the programmatica project?
15:24:32 <cdsmith> pejo: I think he left.
15:24:34 <pejo> For the "how much can you trust source code?"-thing.
15:26:13 <atp> hey, quick question, does anyone know if a solution to the comonad problem was ever found?
15:27:01 <atp> http://haskell.org/pipermail/haskell-cafe/2003-January/003794.html
15:27:03 <lambdabot> Title: comonads, io, http://tinyurl.com/yoy8a4
15:29:42 <ddarius> atp: Yeah, don't use comonads.
15:30:21 <atp> ddarius: so the verdict is, comonads are unsafe, they do break referential transparency?
15:30:36 <ddarius> atp: No, using the for IO is.
15:30:37 <procyon112> fasta: Programs are proofs.  Types are lemmas.  typechecking is testing that the proof satisfies the lemma.  If the problem implies that the programmer must supply a proof of the correctness of the program, that's just a deficiency of the type system (possibly intractable).
15:31:32 <atp> ddarius: so "don't use comonads" should really be "don't use comonads for IO" ?
15:31:52 <ddarius> atp: Yes.  The link is about the OI comonad yes?
15:31:53 <fasta> procyon112: with lots of extensions you can already proof about everything in GHC -- that doesn't mean it's a nice interface to write proofs.
15:31:59 <atp> ddarius: yeah.
15:32:07 <cdsmith> procyon112: Right.  All of the analysis from the proof could be incorporated into the type system.  In this case, it isn't because there's a desire to simplify it more than that.
15:32:29 <atp> ddarius: could you point me to a place where using a comonad *is* appropriate?
15:32:31 <ddarius> procyon112: There are reasons to have a separate proof language, separate from the type system.
15:32:36 <sorear> Comonads are perfectly safe.  And I can prove it.
15:32:44 <ddarius> atp: Any of the other uses.
15:33:01 <atp> ddarius: i'm a beginner, bear with me... what's the "canonical" example?
15:33:05 <ddarius> There was no reason to think there should be a comonad equivalent to IO just because a monadic version exists.
15:33:16 <fasta> It would also be nice to have a proof of the complexity of some function.
15:33:18 <procyon112> atp: There is an interesting example of cellular automata being comanadic
15:33:32 <ddarius> atp: What's the canonical example of monads?  That said, there is a "state in context" comonad.
15:33:42 <fasta> (checked by the machine)
15:33:45 <ddarius> atp: Read the papers.
15:33:48 <sorear> let cobind ((a,e),f) = (f(a,e),e) ;; let coreturn (a,e) = a ;;
15:33:49 <atp> ddarius: ah, right, i saw that, (s, (s -> a))
15:33:59 <procyon112> atp: http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
15:34:00 <fasta> Programming something like that would be highly non-trivial in practice.
15:34:01 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
15:34:06 <sorear> there, a simple comonad implemented in a language that has been proved typesafe!
15:34:36 <ddarius> sorear th issue was referential transparency not type safety
15:35:02 <atp> ddarius: ok, i'll read the papers.  thanks for your help.
15:35:07 <atp> procyon112: thanks, i'll check it out
15:35:10 <meester> \\\\\\\\\\\
15:35:25 <meester> oops, sorry, i was taking keys of my keyboard
15:35:30 <meester> out of my*
15:37:35 <procyon112> TAPL question: section 15.7 "In  a call-by-name variant of the simply typed lambda calculus with subtyping and intersections... a term is typeable iff it's evaluation terminates"
15:38:00 <procyon112> How is this not a solution to the halting problem?? (proven unsolvable)
15:38:32 <monochrom> perhaps "typeable" begs the question too?
15:38:39 <procyon112> and that's iff (not if) on purpose.
15:38:41 <twanvl> The problem with comonads in haskell is that while you can not put multiple things into a return value, but you can take multiple things out of an argument
15:38:56 <sorear> I don't think normal order reduction without primitives is turing complete.
15:39:20 <cdsmith> procyon112: the next sentence
15:39:21 <fasta> sorear: primitives like?
15:39:38 <sorear> Delta rules
15:39:48 <sorear> But that was just a gut feeling
15:39:55 <monochrom> Does it have Y?
15:39:59 <procyon112> cdsmith: Oh.. duh :)
15:40:04 <procyon112> cdsmith++
15:40:16 <sorear> monochrom: Yeah, this is untyped LC in the second half
15:40:31 <procyon112> For those without the book handy, the next sentance is: "
15:40:50 <monochrom> empty?
15:40:52 <sorear> monochrom: I read it as \/expr:untypedLC . terminates expr <=> typeable expr
15:41:01 <procyon112> "This immediately implies that the type reconstruction problem for calculi with intersections is udecideable"
15:41:29 <procyon112> I think I was so stunned by the first sentance, I was glossing over the second ;)
15:41:36 <monochrom> Hey, I said that first about typeable begging the quesiton!
15:41:47 <sorear> Has anyone actually managed to prove the Church-Turing thesis yet?
15:42:00 <procyon112> monochrom++
15:42:02 <monochrom> Skynet will.
15:42:04 <procyon112> there :)
15:42:11 <monochrom> kthxz
15:42:16 <cdsmith> sorear: What statement of it do you have that's formal enough to be proven?
15:44:00 <sorear> cdsmith: notExists e suchThat (forall p, halts(e,p) iff not (forall q, halts(p,q)))
15:45:12 <Heffalump> 'lo
15:45:22 * dcoutts__ reads dons new post on xmonad and the zipper
15:45:26 <dcoutts__> hia Heffalump
15:46:17 <cdsmith> sorear: So there exists no program to determine if another program computes a total function?  That's easily provable by diagonalization; there's a proof in Cutland.  But that's not the Church-Turing thesis.
15:46:59 <monochrom> "such that" has no semantics, just punctuation.  Consider: "for all x, x>=2" and "for some x, x>=2".  No "such that".
15:48:14 <monochrom> Formalization does not mean giving every English word a symbol.
15:49:38 <cdsmith> sorear: no, I misinterpreted you...  I guess your formula was there exists no program that halts iff its input is a program that computes a total function.  That's also provable impossible.
15:50:31 <sorear> oh right, yeah.
15:50:34 <sorear> thanks
15:52:07 <procyon112> or, more formally, F ~= /\ W in {Eng} Exists S in {Symb} :D
15:59:44 * ptolomy shakes his fist at C++ templates, the leaky abstraction that laughs at his misery.
16:01:00 <procyon112> hehe.  The haskell wikibook (type declarations) has the type constructor for Wedding taking "His Name" and "Her Name", verifying that Haskell is part of the right wing conspiracy to make gay marriage not only illegal, but not type safe!
16:02:29 <cdsmith> @remember procyon112 Haskell is part of the right wing conspiracy to make gay marriage not only illegal, but not type safe!
16:02:29 <lambdabot> Done.
16:02:35 <MyCatVerbs> procyon112: it's a wiki. Change it so it's polymorphic.
16:02:38 <Apocalisp> drat, beat me to it
16:04:52 <Saizan> slides that use simultaneusly :<, :> and :=| as contructors... what were they thinking!?
16:05:27 <psnl> subliminal messages!
16:05:33 <procyon112> MyCatVerbs: I'm not sure what to change it too.. spouseA/spouseB, Husband/Wife, Giver/Reciever... I'm not sure of a good English gender neutral pairing.
16:05:48 <Binkley> fixed it
16:06:01 <Binkley> "first partner's name" and "second partner's name" seems fine to me
16:06:02 <sorear> [Human]
16:06:12 <Binkley> but you can improve it if you have something better
16:06:13 <procyon112> hehe
16:06:17 <sorear> Binkley: you just offended a whole bunch of polyamorists
16:06:22 <cdsmith> sorear: What's your problem with bestiality?
16:06:24 <procyon112> nice...
16:06:35 <sorear> oooh...
16:06:38 <Binkley> sorear: I offended myself? :-)
16:06:40 <procyon112> maybe it should be [participants] :)
16:06:44 <opqdonut> :D
16:06:52 <savanni> or [Partner]
16:06:59 <opqdonut> Maybe [Partner]
16:07:04 <opqdonut> ^_^
16:07:12 <savanni> The wedding could happen without any Partner s?
16:07:16 <opqdonut> of course
16:07:20 <procyon112> ahh... the ever excluded masturbatory marriage...
16:07:22 <Saizan> there's [] for that
16:07:26 <Binkley> that would be one partner
16:07:54 <opqdonut> Saizan: Just [] means no people are getting married while None means there is nobody getting married ;)
16:09:21 <ddarius> You guys are missing a simple alternative solution
16:09:48 <Saizan> change the example?
16:09:58 <davidL> what am I doing wrong here: readFile "matrix.txt" >>= lines ?
16:10:18 <Saizan> lines is not in a monad
16:10:21 <cdsmith> davidL: lines doesn't have a monad type
16:10:29 <ddarius> Saizan: Within the context of the example, though being serious, that would probably be best.
16:10:30 <cdsmith> (or it is, but not the same monad as readFile)
16:10:36 <Saizan> so lines `liftM` readFile "matrix.txt"
16:10:37 <davidL> oh
16:11:02 <savanni> Huh... is that superior to readFile "blah" >>= return $ lines ?
16:11:16 <davidL> oh I could do return?
16:11:23 <Saizan> savanni: your dosn't typecheck :)
16:11:42 <Saizan> readFile "blah" >>= return . lines   is ok
16:11:42 <ddarius> s/$/.
16:11:48 <cdsmith> :t readFile "blah" >>= return . lines
16:11:48 <savanni> Oops.....
16:11:53 <lambdabot> IO [String]
16:12:18 <davidL> I thought >>= was used to bind monadic and nonmonadic functions
16:12:27 <Botje> :t (>>=)
16:12:28 <Saizan> ?type (>>=)
16:12:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:12:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:12:45 <davidL> oops
16:12:50 <Botje> your function takes in an a and returns an m b
16:12:51 <davidL> ?ty liftM
16:12:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:13:02 <Botje> thereby ensuring values in a monad do not "leave the monad"
16:13:14 <ddarius> :t fmap
16:13:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:13:34 <cdsmith> @src liftM
16:13:34 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:14:03 <davidL> is the only way to leave the IO monad to use unsafePerformIO?
16:14:06 <savanni> Does <- extract a value from the monad?
16:14:16 <opqdonut> basically es
16:14:18 <opqdonut> *yes
16:14:28 <Botje> davidL: or getting executed by main (which has type IO ())
16:14:40 <emu> getting a value out of the IO monad means breaking referential transparency
16:14:59 <Botje> davidL: and you shouldn't use unsafePerformIO, generally
16:15:00 <opqdonut> ?undo do { x <- m1; return (x+1) }
16:15:00 <lambdabot> m1 >>= \ x -> return (x + 1)
16:15:01 <emu> only main can do that! (or else your program would be pointless)
16:15:06 <Saizan> savanni: syntactically yes, but you can't end a do-block without a monadic expression
16:15:14 <Botje> emu: main often IS pointless^Wpointfree ;)
16:15:21 <opqdonut> ^_^
16:15:24 <savanni> Saizan: that part I knew, I just wanted to make sure <- was doing what I thought.
16:15:30 <emu> also, my programs tend to be pointless, but still!
16:15:56 <opqdonut> point-free versus pointless
16:16:01 <opqdonut> the great paradigm war is coming
16:16:32 * ddarius considers whipping people to use (more) precise speech with respect to monads.
16:16:58 <Botje> call them monkeys.
16:17:16 <cdsmith> @quote monkeys
16:17:16 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
16:17:23 <davidL> so ideally 'main' should just be one line which executes a monad?
16:17:24 <cdsmith> hmmm...
16:17:37 <opqdonut> davidL: yes
16:17:43 <Botje> @quote monkey
16:17:43 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
16:18:04 <opqdonut> @quote monkey
16:18:04 <lambdabot> Botje says: replacing "monad" with "monkey" makes haskell much more easy to understand
16:18:07 <opqdonut> @quote monkey
16:18:07 <lambdabot> quicksilver says: I normally define my types using giantkillermonkey and enormouspeacefulshrew as type variables
16:18:13 <Saizan> it doesn't seem too happy to me
16:18:13 <opqdonut> @quote monkey
16:18:14 <lambdabot> Botje says: replacing "monad" with "monkey" makes haskell much more easy to understand
16:18:19 <Binkley> @quote robot
16:18:19 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
16:18:20 <cdsmith> That's the one!
16:18:23 <Binkley> @quote ninja
16:18:23 <lambdabot> SyntaxNinja says: * SyntaxNinja does the type-checking dance ;)
16:18:27 <opqdonut> :D
16:18:33 <opqdonut> type-checking dance
16:18:34 <Binkley> @quote pirate
16:18:34 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
16:18:42 <opqdonut> arrrrr
16:18:59 <Apocalisp> @yarr
16:18:59 <lambdabot> Get out o' me way, yeh landlubber
16:19:17 <ddarius> @argh
16:19:17 <lambdabot> Yo ho ho, and a bottle of rum!
16:19:28 <opqdonut> @. elite yarr
16:19:28 <lambdabot> aRRR!
16:19:30 <opqdonut> @. elite yarr
16:19:30 <lambdabot> PrEPAR3 7O b3 boArdED!
16:19:37 <opqdonut> ^_^
16:19:40 <Apocalisp> ooh!
16:19:41 <cdsmith> ha!
16:19:45 <savanni> lol
16:20:11 <opqdonut> @. elite type (^^)
16:20:13 <lambdabot> ph0ral1 A b. (iNTE9ral B, FR4cTioNA1 4) => 4 -> B -> 4
16:20:17 <chessguy> ?src Num
16:20:18 <opqdonut> ^_^
16:20:18 <lambdabot> class  (Eq a, Show a) => Num a  where
16:20:18 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:20:18 <lambdabot>     negate, abs, signum     :: a -> a
16:20:18 <lambdabot>     fromInteger             :: Integer -> a
16:20:28 <opqdonut> @. elite src Nul
16:20:28 <lambdabot> Say again?
16:20:29 <opqdonut> @. elite src Num
16:20:30 <lambdabot> Say again?
16:20:33 <Apocalisp> @. elite quote lambda
16:20:33 <lambdabot> Dons S4Ys: I \/\/I$H u 5u(c3$S aNd m4Y y0UR l4mbdAs 41\/\/aYs bET4 REDUCe.
16:20:34 <opqdonut> :/
16:21:43 <Apocalisp> @. unpl yarr
16:21:43 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
16:21:55 <Apocalisp> ;-o
16:22:00 <davidL> @. elite ['a'..'z']
16:22:00 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "['a'..'z']"
16:22:07 <davidL> @. elite > ['a'..'z']
16:22:08 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ">"
16:22:29 <Apocalisp> @. elite pl ['a'..'z']
16:22:29 <lambdabot> ['a'..'Z']
16:22:42 <ddarius> @. elite run ['a'..'z']
16:22:43 <davidL> @. elite show ['a'..'z']
16:22:44 <lambdabot> "A8cdEfGhIJx|MNOpqR$TUV\/\/xys"
16:22:44 <lambdabot> "['A'..'s']"
16:22:48 <cdsmith> @. elite eval ['a'..'z']
16:22:48 <lambdabot> Say again?
16:22:49 <davidL> ah run
16:22:54 <Apocalisp> run it is
16:24:29 <chessguy> ?hoogle run
16:24:29 <lambdabot> Test.QuickCheck.Batch.run :: Testable a => a -> TestOptions -> IO TestResult
16:24:29 <lambdabot> Data.Graph.Inductive.NodeMap.run :: (DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> (r, (NodeMap a, g a b))
16:24:29 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
16:24:34 <cdsmith> Hmm... locally: Prelude> :. elite run ['a'..'z']
16:24:34 <cdsmith>  f4ILED to LOad InteRfa(E FOr `/\/\ON4D.WRI7er': uS3 -V to $33 4 lizt of +h3 fILES 5EarCh3d fOR.
16:24:39 <Apocalisp> @. elite elite elite elite elite yarr
16:24:39 <lambdabot> e|I73 3lITe elI7E YaRr
16:25:18 <Apocalisp> @. elite . elite . elite . elite yarr
16:25:18 <lambdabot> 94nG\/\/4Y!
16:25:29 <MyCatVerbs> Apocalisp: what
16:25:34 <MyCatVerbs> Apocalisp: the HELL?
16:25:55 <Apocalisp> limmelone, I'm spacing out
16:26:01 <davidL> cdsmith: how did that happen locally..?
16:26:09 <cdsmith> @where goa
16:26:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
16:26:19 <davidL> oh
16:26:52 <sorear> @remember lambdabot f4ILED to LOad InteRfa(E FOr `/\/\ON4D.WRI7er': uS3 -V to $33 4 lizt of +h3 fILES 5EarCh3d fOR.
16:26:52 <lambdabot> Done.
16:27:38 <MyCatVerbs> > "This transformation thing isn't permanent, right?"
16:27:40 <lambdabot>  "This transformation thing isn't permanent, right?"
16:27:45 * ddarius can't wait for the day when someone says to their manager, "Well, GHCi on Acid is an important development support tool."
16:27:47 <MyCatVerbs> Phew. Okay.
16:28:06 <ddarius> @help elite
16:28:06 <lambdabot> elite <phrase>. Translate English to elitespeak
16:28:20 <MyCatVerbs> ddarius: we can squish bugs more easily if they're too busy laughing to fight back.
16:28:31 <ddarius> @. elite help elite
16:28:31 <lambdabot> e1I+e <pHRaSE>. +Ranz|a7e 3Ng|izh To 3|Ite$P3ax
16:28:46 <MyCatVerbs> ddarius: then hope like Hell that your manager doesn't notice your anthromorphisation of bugs.
16:30:12 <ddarius> We're allowed to turn logical errors into multicellular organisms but not into organisms with vocal tracts sophisticated enough to produce laughter?
16:30:12 <MyCatVerbs> darcs is awesome. ^^
16:30:18 <ddarius> True.
16:30:43 * ddarius doesn't think he rinsed this glass out well enough when he cleaned it.
16:30:59 <ptolomy> Am I wrong in my assumption that top-level mutable state can be pretty reasonably simulated with a new monad around IO, some liftIOing here and there, an initialization function, and a wrapper for forkIO?
16:31:16 <ddarius> ptolomy: Yes and no.
16:31:26 <ptolomy> Heh.
16:31:34 <ptolomy> I was hoping that was the answer.
16:31:56 * ddarius finds logic much easier when A /\ not A holds.
16:32:21 * cdsmith wonders if ddarius meant \/
16:32:26 <ddarius> Nope.
16:32:35 <Binkley> logic is very easy when A /\ not A holds
16:32:37 <Binkley> everything is true
16:32:55 <dibblego> no, everything is false
16:33:03 <cdsmith> that too!
16:33:13 <Binkley> indeed
16:34:22 <MyCatVerbs> Whoaaaa
16:34:26 <MyCatVerbs> Evil, horrible thought.
16:34:51 <MyCatVerbs> Imagine if, when netnews was hacked together, instead of uucp, they'd used darcs.
16:35:16 <MyCatVerbs> Surreal. ^^
16:35:20 <cdsmith> Then there would be time travel.  Yes, the implications are amazing! :)
16:36:35 <Apocalisp> Aristotle is turning in his grave, ddarius.
16:37:06 <QtPlatypus> MyCatVerbs: There is nothing stopping you from using darcs as the news transport layer.
16:37:44 <cdsmith> Well, except perhaps wanting to peer with any existing server.
16:37:52 <QtPlatypus> Well yeah that.
16:38:57 <MyCatVerbs> QtPlatypus: "Copying patch 5102 of 645590..."
16:39:34 * kc5tja just got back from a meeting.
16:39:41 <sorear> hello!
16:39:54 <kc5tja> What's funny, is not a month ago, I pondered using Darcs as a collaborative messaging back-end with a friend of mine.
16:39:54 * cdsmith hopes there were doughnuts.
16:39:58 <sorear> kc5tja: Is r> drop really that common? *look of terror*
16:40:01 <kc5tja> cdsmith: No.
16:40:32 <sorear> kc5tja: it sure isn't ANS, and I don't look forward to implementing a hack for it in the optimizer ...
16:40:34 <kc5tja> sorear: Only if you tweak the return stack like I do.  :)  I normally use a dedicated word "rdrop" for the same purpose, but I didn't check to see if you had it defined (and therefore, assumed the worst
16:42:12 <ddarius> sorear: You've read Thinking Forth?
16:42:20 <kc5tja> While it isn't 100% ANSI compliant, it's not forbidden from the standard either.
16:43:14 <sorear> ddarius: Yes.  TF has a great deal of other 83isms, though (compiling with , etc)
16:43:31 <sorear> kc5tja: Does RAFTS dtrt with rdrop?
16:43:39 <kc5tja> dtrt?
16:43:44 <sorear> do the right thing
16:44:06 <kc5tja> RAFTS treats all Forth primitives as macros for SSA representation.  Then, the code optimizer and code emitter works with SSA.
16:44:24 <sorear> Can it inline user-defined words?
16:44:28 <ddarius> sorear is young, and all the youngens tlt.
16:45:17 <kc5tja> sorear: It is capable of doing that, provided a heuristic brings the compiler to that conclusion.
16:45:45 <sorear> kc5tja: And this doesn't break in the presence of rdrop, why>
16:45:47 * kc5tja has often noticed that most words in Forth are used between 1 and 4 times maximum, which makes them excellent candidates for inlining.
16:46:08 <sorear> And they are short.
16:46:11 <kc5tja> sorear: Lost context -- what doesn't break in the presence of rdrop?
16:46:52 <sorear> kc5tja: RAFTS inlines user defined words - but if you inline functions, that changes the format of the return stack, causing manual return stack munging to fail badly.
16:47:16 <ddarius> sorear: There isn't a problem.  It's fairly obvious is something doesn't munge the return stack too bad, when it's not obvious don't inline.
16:47:28 <kc5tja> One of the heuristics could be, if you tweak the return stack at all, it's ineligible for inlining.
16:47:59 <ddarius> sorear: For something as simple as R> DROP, it's only an issue if your word directly calls a word that does that.
16:48:01 <kc5tja> Same basic optimization that GHC does on functions -- if a function tail-calls itself, it's best not to inline it.  :D
16:49:40 <ddarius> Most words aren't "higher-order" and thus the compiler can easily find if any munging is done within the word or the words it calls.
16:54:04 <kc5tja> sorear: I'm thinking of taking your code and merging it with my code to produce a hybrid environment that actually works, and still resembles what I'd originally conceived for the Kestrel's firmware.
16:54:37 <kc5tja> But a rewrite of the base-level firmware is definitely in order, since it's too complicated.  I need to go back to basics and keep it simple.
16:55:07 <sorear> base level?
16:55:28 <kc5tja> Yeah, the firmware that my Forth implementation sits on top of.
16:55:34 <sorear> I've been operating on KISS as much as I could.  What did I mess?
16:55:51 <ddarius> Forget the firmware, reimplement the hardware!
16:56:02 <kc5tja> ddarius: I can't change the processor.
16:56:09 <sorear> Oh right.  You have the the pure-asm kernel, mine is in forth.
16:56:17 <sorear> + a few code words
16:56:37 <kc5tja> Right.
16:57:05 <kc5tja> I'd like to build on what you've done, and flesh it out a bit.
16:57:53 * kc5tja really wishes he could replicate the Commodore screen editor without too much complexity -- it is very simple, but alas, it just doesn't fit the Forth I/O model at all.
16:58:27 <sorear> kc5tja: What is the advantage of a full screen editor over a readline style interface?
16:58:53 * procyon112 wishes he had the time to reimplement Commodore basic as a bios flash Core 2 Duo, just for kicks.
16:59:11 <chessguy> haha
16:59:16 <chessguy> Dartmouth Basic ftw!
16:59:18 <kc5tja> procyon112: DUDE, that's awesome!  That'd be slashdotted *SO* fast... :D
16:59:45 <kc5tja> SmartBASIC is the latest Dartmouth-class BASIC.  I'd probably try to go with that dialect if at all possible.
16:59:56 <procyon112> I think there's an open source BIOS project, so it's wouldn't be too difficult.
17:00:00 <kc5tja> But, still, Commodore's BASIC has that really high nostalgia quotient.
17:00:36 <procyon112> I'd love to turn on my machine and get the White-On-Blue with a Ready prompt and a blinkie cursor.
17:01:32 <procyon112> Maybe even hack Grub to do it, and boot your OS by doing a: LOAD "WINDOWSXP",8,1
17:01:32 <sorear> kc5tja: Aside from nostalgia, is there any reason to prefer a Commodore's full screen editor over Readline?
17:02:25 <kc5tja> procyon112: Actually, blue on white if you want that VIC-20 feel.  But with a later generation of BASIC, you can go with Commodore's tribute to their own past -- C128's green on grey -- hooray for PET!  :D
17:03:19 <kc5tja> OK, I just had a case of massive lag, and had to reconnect.  Sorry -- I must have missed something.
17:03:22 <kc5tja> 16:57 < procyon112> I'd love to turn on my machine and get the White-On-Blue with a Ready prompt and a blinkie cursor.
17:03:26 <kc5tja> 16:58 < kc5tja> procyon112: Actually, blue on white if you want that VIC-20 feel.  But with a later generation of BASIC, you can go with Commodore's tribute to their own past -- C128's green on grey -- hooray for PET!  :D
17:03:30 <kc5tja> That's where I left off.
17:04:18 <procyon112> hehe.  I never had a PET, or a 128.  I saved up for a 128, but my grandpa interviened and asked what I was getting it for. When I showed him my coding, being a Silicon Valley banker and seeing the trend, he objected and bought me an IBM XT instead.
17:04:59 <kc5tja> Ahh.
17:05:41 <procyon112> I did have a Commodore Plus 4 though... I forget how I got it.  That was quite the frankenmachine.
17:06:07 <sorear> kc5tja: Why a full screen editor?  (I want to know the motivations, that's all)
17:06:30 <kc5tja> The Plus/4 was a nice machine, actually.  It's a pity that it didn't catch on.  Although it lacked hardware sprites, it made up for it nearly every which way else.
17:06:38 <kc5tja> sorear: It's just convenient.
17:06:44 <kc5tja> sorear: You could write something like:
17:06:53 <kc5tja> ." : foo bar bah ;" cr
17:06:58 <kc5tja> have it print that to the screen.
17:07:04 <kc5tja> Then cursor up to the : foo line, and hit ENTER.
17:07:07 <kc5tja> Foo would be defined.
17:07:36 <sorear> That actually seems rather bad for forth.
17:07:40 <sorear> 2 2 + .  4 ok
17:07:40 <kc5tja> Which means, using this imaginatively, you could LIST a block to the screen, and each line is prefixed with " 0 r ...text here..."
17:07:46 <sorear> UP
17:07:53 <sorear> 2 2 + .  4 ok  ? ok
17:08:00 <kc5tja> Think outside the box.
17:08:06 <kc5tja> Forth doesn't require everything to be on one line.  :)
17:08:14 <kc5tja> 2 2 + .
17:08:15 <kc5tja> 4
17:08:18 <kc5tja> OK.
17:08:20 <kc5tja> _
17:08:33 <kc5tja> But imagine if you type in something like:
17:08:35 <kc5tja> 5 LIST
17:08:41 <kc5tja>  0 r ( This is a comment )
17:08:42 <kc5tja>  1 r
17:08:47 <kc5tja> 2 r : foo bar baz ;
17:08:50 <kc5tja>  3 r ...etc..
17:08:55 <kc5tja> And you need to make a change to line 2.
17:09:00 <kc5tja> Make the change, and just hit ENTER.
17:09:26 <kc5tja> Because the line starts with "2 r", that's valid Forth code to _r_eplace that line with what follows.
17:09:40 <kc5tja> (thus, extending old-school Forth line-editors into the screen-editor environment)
17:10:41 <sorear> Seems like it would make other operations unnecessarily difficult.
17:10:55 <sorear> What if I want to extend line 5 to the point of wrapping?
17:11:12 <kc5tja> It'll only take the first 64 characters obviously.
17:11:30 <kc5tja> The Commodore machine-language monitors used this to its great advantage.
17:11:38 <sorear> I mean, 5 48 SPLIT-LINE is a lot of typing.
17:11:40 <kc5tja> You used the "m" command to display a block of memory, which produced a line like:
17:11:47 <sorear> "machine language monitors" ?
17:11:54 <kc5tja> Dude, you're making me look old here.
17:12:04 <kc5tja> Probably the first "operating systems" ever.
17:12:27 <kc5tja> A program that let you manually set memory contents (with hexadecimal values), retrieve the memory in a hex dump, and then you could "G"o to an address.
17:12:48 <kc5tja> So you could use m 0300 to display memory starting at $0300, and you'd get a line like:
17:13:12 <kc5tja> ., 0300 00 44 45 41 44 00 00 00 .DEAD...
17:13:14 <kc5tja> ..etc..
17:13:39 <kc5tja> But because the ',' is the "command" in the line, with Commodore's MLMs, you could just cursor up to the line, make changes to the hex codes, and hit ENTER.  Done -- memory modified.
17:13:48 <kc5tja> It's like an interactive watch window in modern IDEs.
17:14:59 <kc5tja> But, you're right, although the editor interface is simple to use from the user's point of view, it does add some complexity and is incompatible with Forth's strict I/O model.
17:15:06 <kc5tja> So, that's why I'm discarding it.
17:15:29 <kc5tja> Chalk it up to experience -- I tried a good idea, but the idea didn't work out for me.  I'm moving on.
17:15:56 <sorear> Oh, cool.
17:23:58 <Binkley> @yow
17:23:58 <lambdabot> RELATIVES!!
17:25:25 <kc5tja> Speaking of which, I need to catch up on my regular dose of Zippy...
17:27:28 <Binkley> @quote
17:27:28 <lambdabot> mbishop says: mbishop nibbles on chessguy
17:27:49 * chessguy recoils in horror
17:28:05 <sorear> @quote cheeseguy
17:28:05 <lambdabot> cheeseguy says: what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
17:28:19 <Binkley> unrequited nibbling is so sad
17:29:14 <ddarius> Binkley: Indeed.
17:29:52 <ddarius> Perhaps @remember should remember the date and time as well
17:32:01 <jcreigh> chessguy: I don't know what it is, but I read your nick as "cheeseguy" for the longest time. It just doesn't tokenize well, for some reason.
17:32:49 <sorear> kc5tja: Something troubles me about your approach to number conversion...  I know it shouldn't, but this mind is not giving reasons
17:33:00 <dibblego> ?src Ord
17:33:00 <lambdabot> class  (Eq a) => Ord a  where
17:33:00 <lambdabot>     compare      :: a -> a -> Ordering
17:33:00 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
17:33:00 <lambdabot>     max, min         :: a -> a -> a
17:33:37 <sorear> (Or maybe all approaches to number conversion are troubling)
17:38:25 <minimal-criminal> Hi
17:38:35 <minimal-criminal> which board games are good?
17:38:53 <jcreigh> Warlambda 40000
17:39:01 <minimal-criminal> :D
17:39:02 <sorear> minimal-criminal: That is *very* OT
17:39:08 <Binkley> try #haskell-blah
17:39:27 <minimal-criminal> oh, sorry if its a problem sorear
17:39:35 <sorear> minimal-criminal: Why'd you try #haskell ?
17:39:43 <kc5tja> sorear: I'd be happy to address them at a later time of course.  I need to head home and partake in some obligatory chores.
17:39:55 <minimal-criminal> I guesses haskell'ers would have ecclectic taste in board games
17:39:55 <wchogg> jcreigh:I prefer the original lisp-based Warlambda to the newfangled 40k edition.
17:40:05 <Pseudonym> minimal-criminal: #haskell-blah
17:40:16 <sorear> minimal-criminal: OK, that's reasonable.  But #haskell-blah
17:40:20 <kc5tja> sorear: Feel free to ask in ##forth or in /msg in the mean time.
18:10:43 <mcnster> hello.  i am having a ffi problem...
18:13:11 <mcnster> i have a module A with foreign import ccall unsafe "foo.h & ext" extPtr :: Ptr (Ptr Word8)
18:13:48 <mcnster> and another module B that imports a fn from A that makes reference to extPtr
18:14:17 <mcnster> but when ghc --make is made, i get an undeclared error in module B
18:14:36 <mcnster> can anyone advise?
18:15:07 <kpreid> I don't know about FFI, but does module A export extPtr?
18:15:51 <mcnster> kpreid, no.  it exports a fn that contains extPtr in its definition
18:16:25 <sorear> mcnster: you need to pass -#include foo.h to GHC
18:16:37 <sorear> mcnster: this is a C-level undefined error, right?
18:17:07 <mcnster> sorear, yes it is c-level.
18:17:30 <mcnster> sorear, i have tried {-# INCLUDE "foo.h" #-} in module B but that doesn't seem to help
18:20:24 <sorear> Are you using -fvia-C ?
18:20:27 <sorear> -O ?
18:21:16 <mcnster> sorear, yep
18:22:00 <sorear> mcnster: Is the undefined error on "ext" ?
18:22:49 <mcnster> sorear, yes
18:22:52 <sorear> mcnster: I give up.  Hpaste
18:22:54 <sorear> @paste
18:22:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:28:45 <mcnster> sorear, success!  i tried using -#include on the cmdline and it works.  i don't know why the pragma didn't tho
18:28:53 <mcnster> thanks for your help :)
18:30:12 <mcnster> @hoogle mkSet
18:30:12 <lambdabot> Data.Set.mkSet :: Ord a => [a] -> Set a
18:30:14 <dons> ?users
18:30:14 <lambdabot> Maximum users seen in #haskell: 340, currently: 296 (87.1%), active: 43 (14.5%)
18:31:11 <mcnster> @hoogle setToList
18:31:12 <lambdabot> Data.Set.setToList :: Set a -> [a]
18:38:04 <Binkley> @yow
18:38:04 <lambdabot> I'm young ... I'm HEALTHY ... I can HIKE THRU CAPT GROGAN'S LUMBAR REGIONS!
18:50:46 <igli> @botsnack
18:50:46 <lambdabot> :)
18:50:56 <igli> thanks lambdabot :D
18:52:58 <dons> are we there yet?
18:53:13 <ari> @yow
18:53:13 <lambdabot> If I pull this SWITCH I'll be RITA HAYWORTH!!  Or a SCIENTOLOGIST!
18:53:20 <Binkley> when you get there, there's no there there
18:53:39 <sorear> dons: Error: Cannot satisfy (?there :: a) in context #haskell
18:53:44 <dons> true! oh no.
18:53:54 <dons> hmm, how can we solve this dillema. I know. a zipper!
18:53:59 <dons> we can track where we are automatically
18:53:59 <sorear> dynamic scoping is so creul.
18:54:01 <Botje> @pl \(a, b) -> (a,tail b)
18:54:01 <lambdabot> second tail
18:54:07 <procyon112> there is my base case.  Once I hit there, I hav to unwind my stack.
18:54:07 <Botje> heh
18:54:07 <Botje> neat
18:54:39 <chessguy> @type second
18:54:45 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
18:55:09 <chessguy> ermmmmm, ok
18:55:39 <chessguy> ?src second
18:55:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:56:10 <chessguy> ?hoogle second
18:56:10 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
18:56:44 <procyon112> Where does the d come from?
18:56:55 <procyon112> Arrows still scare me.
18:57:25 <dons> :t second tail
18:57:27 <lambdabot> forall a d. (d, [a]) -> (d, [a])
18:57:37 <dons> > (second tail) (1, "foo")
18:57:38 <lambdabot>  (1,"oo")
18:57:55 <dons> a DSL for hacking tuples, that's all arrows are ;-)
18:58:23 <chessguy> > (second (*2)) (2,3)
18:58:24 <lambdabot>  (2,6)
18:59:05 <dons> > (toUpper *** toLower) ('x', 'X')
18:59:06 <lambdabot>  ('X','x')
18:59:22 <minimal-criminal> haha
18:59:34 <minimal-criminal> what is ***?
18:59:48 <chessguy> @type (***)
18:59:48 <minimal-criminal> > (toUpper *** toLower) (,) "xX"
18:59:49 <lambdabot>  Couldn't match expected type `t1 -> t'
18:59:50 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:00:20 <dons> you need a function to get your from (,) "xX"
19:00:22 <procyon112> I used (&&&) the other day, thinking I was cool and all... only to realize that I could do it in half the code with a pattern match... Which made me realize that even having a vague concept of how they work, i have no concept of them in a practical sense.
19:00:25 <dons> :t (,)
19:00:26 <dons> :t "xX"
19:00:27 <lambdabot> forall a b. a -> b -> (a, b)
19:00:29 <lambdabot> [Char]
19:00:50 <dons> > splitAt 1 "xX"
19:00:52 <lambdabot>  ("x","X")
19:00:56 <minimal-criminal> ooh
19:01:13 <minimal-criminal> > (toUpper *** toLower) splitAt 1 "Oo"
19:01:14 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
19:01:18 <dons> > (head *** head) . splitAt 1 $ "xX"
19:01:19 <minimal-criminal> > (toUpper *** toLower) $ splitAt 1 "Oo"
19:01:20 <lambdabot>  ('x','X')
19:01:20 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
19:01:28 <dons> > (toUpper *** toLower) . (head *** head) . splitAt 1 $ "xX"
19:01:29 <lambdabot>  ('X','x')
19:01:33 <dons> :-)
19:01:55 <dons> :t splitAt 1 "xX"
19:01:57 <lambdabot> ([Char], [Char])
19:02:01 <dons> wrong type, for toUpper.
19:02:03 <dons> :t toUpper
19:02:05 <lambdabot> Char -> Char
19:02:06 <dons> make sense, minimal-criminal ?
19:02:19 <minimal-criminal> Yeah
19:02:21 <minimal-criminal> thanks :D
19:02:35 <chessguy> ?hoogle [a] -> ([a],[a])
19:02:36 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
19:02:36 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
19:02:36 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
19:02:38 <dons> you know arrows now :-)
19:02:42 <minimal-criminal> no I dont!
19:02:56 <monochrom> There is also map toUpper *** map toLower
19:02:58 <chessguy> ?hoogle [a] -> (a,[a])
19:02:59 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
19:02:59 <dons> well, just generalise these tuple splittings to arbitrary streams of data
19:02:59 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
19:02:59 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:03:03 <dons> and add some extra operations
19:03:12 <dons> and you have a model for mulitple streams of control
19:03:18 <minimal-criminal> dons: It will be a while before I can do that :S
19:03:22 <minimal-criminal> sounds very cool though
19:03:49 <dons> for example, you might model a circuit that has one intput and two outputs this way
19:03:53 <dons> a -> (a,a)
19:04:00 <dons> then apply some function to just the second output
19:04:05 <monochrom> You can add state.
19:04:11 <dons> second f . split
19:04:25 <dons> and yeah, add loops in the circuit. and other fun tricks
19:04:39 <minimal-criminal> wild
19:05:05 <dons> so you build up a set of operations that model circuits in the real world (i.e. graphs of computations)
19:05:20 <dons> whereas good ole monads just model sequences of computations, usually.
19:05:22 <dons> a >> b >> c
19:05:31 <minimal-criminal> So that is arrows
19:05:37 <dons> basically, yeah.
19:05:42 <SamB> we are talking Lava now?
19:05:49 <dons> its related.
19:05:52 <SamB> do we have it ported to modern GHC?
19:05:53 <monochrom> Not necessarily Lava.
19:06:44 <SamB> also, has everyone learned that it is downloadable again?
19:07:26 <chessguy> ?where lava
19:07:26 <lambdabot> I know nothing about lava.
19:08:19 <chessguy> SamB: is this the main page?
19:08:20 <chessguy> http://raintown.org/lava/
19:08:21 <lambdabot> Title: The Lava Hardware Description Language
19:08:54 <minimal-criminal> Can you make a Pong emulator with Arrows?
19:09:09 <sorear> It's basically been done.
19:09:09 <SamB> http://www.cs.chalmers.se/~koen/Lava/download.html
19:09:12 <lambdabot> Title: The Lava Homepage: Download
19:09:25 <chessguy> ?where+ lava http://www.cs.chalmers.se/~koen/Lava/download.html
19:09:25 <lambdabot> Done.
19:09:26 <sorear> One of the arrow GUI libs has a basically pong game as a demo.
19:09:41 <minimal-criminal> A pong game is nothing though
19:09:49 <chessguy> ugh, no darcs repo?
19:09:50 <minimal-criminal> but a pong emulator I would be amazed
19:10:13 <minimal-criminal> I mean emulation of the circuits
19:10:17 <SamB> chessguy: apparantly
19:10:23 <sorear> minimal-criminal: Every pong game emulates pong.
19:10:25 <SamB> we should steal it and make one
19:10:41 <sorear> minimal-criminal: Are you looking for an emulator for the computer that ran the original pong?
19:10:58 <minimal-criminal> sorear: Like the kit you can solder together yourself
19:11:06 <SamB> oh, so you want *pong*
19:11:28 <SamB> oh, no, you want a simulation of it
19:13:42 <ari> Any HaskellDB people around? #haskelldb was empty...
19:14:17 <stmartin> :t print
19:14:20 <lambdabot> forall a. (Show a) => a -> IO ()
19:14:28 <SamB> wow that is a big board
19:15:18 <stmartin> What is the Haskell equivalent of printf? I need to do some formatted output.
19:15:30 <SamB> you could use printf ;-)
19:15:36 <Binkley> :t printf
19:15:38 <lambdabot> forall r. (PrintfType r) => String -> r
19:15:43 <SamB> or you could use show
19:15:55 <monochrom> > printf "%08x" (0x80000000 :: Int) :: String
19:15:56 <lambdabot>  "17ffffffe"
19:16:05 <stmartin> Oh, I didn't see printf mentioned in the Report. Is it in the Prelude?
19:16:09 <monochrom> You can replace String by IO a.
19:16:19 <kpreid> or perhaps you're looking for a pretty-printer library
19:16:27 <monochrom> It is not in the report.  It is in Text.Printf
19:16:34 <stmartin> Ah, thanks.
19:17:20 <thoughtpolice> dons: thanks for your little explanation on arrows, gave some quick examples. question, do functions explicitly need to be defined as arrows via arr, or are pure functions arrows implicitly (for example in something like (head &&& tail) "hello world!")
19:17:25 <sorear> It is not part of the langauge.  It is a part of the defacto standard library bundle.
19:17:42 <kpreid> thoughtpolice: pure functions are a *kind* of arrow
19:17:45 <dons> ?instance-importing Control.Arrow Arrow
19:17:46 <lambdabot> (->), Kleisli m
19:17:59 <dons> thoughtpolice: so normal -> functions are in Arrow already
19:17:59 <SamB> so was pong really before the oscilascope games?
19:18:05 <kpreid> thoughtpolice: you need to use arr/pure if you want to turn a pure function into some other arrow
19:18:08 <dons> but that's like the Reader moand for ->
19:18:14 <procyon112> Dons: So, concievably, I can do pi-calculus as arrows, and with lazy evaluation, processes will send and recieve messages only when needed to perform the computation?  Or am I totally missing the point?
19:18:22 <monochrom> > (head &&& tail) "hello world!"
19:18:23 <lambdabot>  ('h',"ello world!")
19:18:31 <stmartin> One other newbie question. How would I get to the documentation for Text.Printf. Would it be on my local machine?
19:18:34 <dons> procyon112: hmm, I think that might make sense. though i'm not aware of using arrows to model processes.
19:18:44 <dons> they are used to model circuits, and reactive programming
19:18:53 <thoughtpolice> kpreid: (this is just a guess,) such as kleisli arrows?
19:18:53 <dons> it would make a nice paper..
19:19:10 <kpreid> thoughtpolice: *any* other arrow
19:19:21 <thoughtpolice> simple enough, I suppose.
19:19:34 <procyon112> Seems they would be great for processes then also.  Speaking from intuition and much naievity only.
19:19:42 <kpreid> including the function arrow itself (in which case arr == id)
19:21:12 <SamB> hmm, I don't like this definition of video game as a game played on a RASTER display...
19:21:13 <Binkley> stmartin: see below...
19:21:16 <Binkley> @doc Text.Printf
19:21:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
19:21:17 <thoughtpolice> kpreid: so arr/pure are just functions defined by your Arrow instance to lift your pure functions into arrow's themselves?
19:21:25 <Binkley> if you munge the URL appropriately, you can find your local copy, if you have the docs installed
19:21:27 <kpreid> thoughtpolice: yes
19:22:24 <thoughtpolice> kpreid: thanks :)
19:22:47 <stmartin> Binkley: thanks. So is there anything local like perldoc?
19:23:58 <monochrom> file:///usr/local/share/ghc-6.6/html/libraries/base/Text-Printf.html  is available on my computer.
19:24:22 <stmartin> Thanks
19:28:05 <dons> ?docs Text.Printf
19:28:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
19:33:21 <monochrom> I love the way dons says "import global var support" for importing Control.Monad.State. :)
19:38:30 <SamB> whoa neat
19:38:38 <SamB> I've scored spacewar sources!
19:38:43 <SamB> http://spacewar.oversigma.com/sources/sources.zip
19:39:10 <minimal-criminal> java :[
19:39:19 <minimal-criminal> I thought you mean original sources or somthing
19:39:26 <SamB> minimal-criminal: I'm assuming it has the pdp-1 sources in there too
19:39:26 <procyon112> @pl f x y = [(x,y)]
19:39:26 <lambdabot> f = flip flip [] . ((:) .) . (,)
19:39:39 <minimal-criminal> ooh
19:39:40 <SamB> see
19:39:53 <SamB> http://spacewar.oversigma.com/readme.html
19:39:54 <lambdabot> Title: Spacewar Readme
19:40:08 <monochrom> (:)^P
19:40:28 <minimal-criminal> ohhh
19:40:29 <minimal-criminal> Nice !
19:47:08 <SamB> now, apparantly these are slightly modded sources...
19:54:34 <shapr> mbishop: Nice to see you in another virtual environment!
19:55:17 <mbishop> :P
19:55:28 <mbishop> humies were doing so good up until SD :(
19:56:00 <shapr> Yeah, that's how it always goes.
19:56:15 <shapr> You gotta wipe out the aliens at S2 with grenades and painsaws.
20:00:47 <minimal-criminal> SamB: do you know how to compile it?: )
20:00:54 <abbystew> I compiled a wxHaskell program with ghc 6.4 and when I run it, I see a console.  Is there a way to get rid of that console?
20:02:39 <sorear> Other than 'don't use windows', no.
20:02:43 <sorear> it's a reported bug
20:02:50 <sorear> let me find the ticket
20:02:50 <abbystew> sorear, thanks!
20:02:57 <minimal-criminal> SamB: oh just deleting the imports worked
20:04:07 * SamB wonders how to load this into simh
20:04:10 <stmartin> How can I include a module that is defined in a non-standard directory (the same directory as the source)?   (I'm thinking like #include "foo.h"  in C)
20:04:37 <minimal-criminal> seems like it needs spacewar.bin
20:04:42 <SamB> yes. I've built that.
20:04:46 <minimal-criminal> how?
20:04:53 <SamB> erm.
20:05:07 <SamB> perl macro.pl spacewar.mac > spacewar.lst
20:05:22 <SamB> perl pass12.pl spacewar.lst | perl tape.pl
20:05:41 <minimal-criminal> ah cool thanks
20:07:19 <ed1t> anybody want haskell-lang.org? i got it like a week ago but im not gonna use it anymore ill sell it for regular price $8 with godaddy
20:07:41 <dons> ed1t: hmm. maybe ask on haskell-cafe@ ? someone might pick it up.
20:07:54 <minimal-criminal> :[
20:08:14 <ed1t> thx
20:12:27 <sorear> abbystew: Huh.  I was wrong
20:12:33 <sorear> abbystew: -optl-mwindows
20:13:01 <abbystew> very nice!  I'll give that a shot.  Thank you!
20:24:50 <dons> today's paper, http://programming.reddit.com/info/1rmap/comments
20:24:51 <lambdabot> Title: More Zippers: Using partial differentiation on a data structure to derive its zi ...
20:26:25 <kc5tja> And in this stage, we take dH/dS, which is the derivative of the hashtable in terms of memory space consumed, and . . .
20:26:41 * kc5tja has always liked the idea of measuring performances in decibels instead of O-notation.
20:26:45 <dons> heh
20:26:55 <kc5tja> This implementation is 64dB faster and 4dB smaller than XYZ...
20:27:02 <dons> that's a cool idea
20:28:14 <kc5tja> It probably only makes sense when comparing two implementations of some code given the same input though.
20:29:24 <dons> well, it might be a useful notation for comparing different constant factors on a log scale, with the same O complexity
20:29:37 * kc5tja nods
20:29:38 <dons> both O(n), but one has a constant 64dB louder.
20:29:47 <kc5tja> Hahah
20:30:00 <kc5tja> That'd be useful too.
20:30:23 <dons> actually, dB would make a scale for publicity.
20:30:31 <dons> how many votes up or down, or how many references to a blog article
20:30:42 <dons> so not hot/cold, but a 0 .. 120 dB scale
20:31:02 <dons> which has the nice result that over exposure is deafening.
20:31:12 <dons> say, like paris hilton (a first reference for this channel!)
20:31:40 <dons> oh no, not the first.
20:31:41 <dons> 04.02.11:11:47:11 <earthy> Paris Hilton vs Paris Hilton? :)
20:31:42 <dons> 04.12.10:21:22:58 <Gahhh> at least, it's a tribute to this channel that it didnt mention Paris Hilton, et al.
20:31:47 <dons> earthy: wins the prize.
20:32:00 <dons> ?quote paris
20:32:00 <lambdabot> No quotes match. I've seen penguins that can type better than that.
20:32:07 <dons> ?quote Paris
20:32:07 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
20:32:09 <dons> oh.
20:32:16 <zarvok> does the "prize" involve STDs?
20:32:26 <dons> ?remembe palomer Category theory is the Paris Hilton of mathematics
20:32:26 <lambdabot> Done.
20:32:50 <jcreigh> dons: that was the first refence in my logs as well. :)
20:32:58 <monochrom> What does that mean? (I did not follow Paris Hilton.)
20:33:44 <dons> she wrote some nice papers in the late 80s on generational garbage collection, I think.
20:33:52 <dons> there was one with Wadler, iirc.
20:34:01 <dons> on removing intermediate lists.
20:34:22 <dons> unless i'm thinking of the wrong paris hilton.
20:34:50 <zarvok> there is a Paris Hilton in type theory?
20:35:20 * monochrom goes into an infinite loop
20:36:42 <JohnMeacham_> dare me to write a c-- compiler.
20:37:02 <zarvok> http://www.cs.cmu.edu/~avrim/ML07/soln3.pdf
20:37:07 <zarvok> umm, oops
20:37:09 <dons> JohnMeacham_: I dare you to .... oh wait...
20:37:10 <zarvok> accidental paste
20:37:11 <zarvok> sorry
20:37:22 <dons> hehe. /me gets cmu degree on the cheap
20:37:34 <zarvok> heh
20:38:39 <sorear> JohnMeacham_: It might make me write my C-- Ã¼ber-optimizer faster :)
20:40:55 <shapr> Did nomaware die?
20:42:38 <shapr> dons: Are you serious?
20:43:17 <dons> shapr: heh no. zarvok i think dropped a cmu tutorial soln into the chan accidentally
20:43:40 <zarvok> indeed
20:44:11 <mbishop> @where monads
20:44:11 <lambdabot> http://www.nomaware.com/monads/html/index.html
20:44:25 <mbishop> who changed it back? heh
20:44:29 <mbishop> @where monad
20:44:29 <lambdabot> I know nothing about monad.
20:44:30 <sorear> w/wg 3
20:44:50 <mbishop> http://mbishop.esoteriq.org/stuff/allaboutmonads.pdf
20:45:05 <shapr> dons: I had to quote that as my first blog entry in a year.
20:45:25 <shapr> Oh, only first in several months.
20:45:27 <shapr> Whatever...
20:45:38 <dons> quote what?
20:45:52 <shapr> http://www.scannedinavian.com/hope/entry/113
20:46:27 <dons> heh
20:46:45 <shapr> mbishop: Thanks!
20:48:23 <shapr> mbishop: Do you have the source archive of allaboutmonads as well?
20:48:27 <bos> @seen CosmicRay
20:48:27 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 6h 38m 51s ago, and .
20:53:33 <shapr> Does anyone have a zip or tgz of the allaboutmonads sources?
20:54:52 <Korollary> http://www.haskell.org/all_about_monads/html/examples.html
20:54:53 <lambdabot> Title: Haskell code examples
20:54:58 <mbishop> shapr: nope
20:55:14 <mbishop> ahh, looks like haskell.org does :P
20:55:52 <shapr> yay!
20:55:55 <shapr> Korollary: Thanks!
20:56:48 <shapr> Oh hey, now that I know what filename to look for, I have my own backup copy.
21:54:52 <hpaste>  stmartin pasted "Matching Either (again)" at http://hpaste.org/1878
21:55:14 <stmartin> I'm having trouble matching the result of Parsec's parse function
21:55:29 <stmartin> Can someone please have a look at the previous paste?
21:55:57 <bos> stmartin: your call to error doesn't have a type.
21:56:18 <stmartin> Can you give an example please?
22:00:04 <bos> stmartin: actually, your error is more basic than that. you're not passing enough arguments to parse.
22:00:26 * stmartin raises eyebrows
22:00:39 <bos> you need to give it a SourceName. you're using the parse defined in the Prim module, right?
22:01:05 <bos> it takes three arguments; you're passing two.
22:01:23 <stmartin> Ah, I see. Thanks.
22:13:00 <sorear> @botsnack
22:13:01 <lambdabot> :)
22:23:42 <atp> hey, suppose I have a partial ordering (P, <=).  then apparenly there exists a morphism between objects A and B \in P iff A <= B.  this is the standard example of a non-concrete morphism.  i don't understand, though, how the associativity axiom for such a morphism works... what's the composition operation?  i would have guessed <=, but obviously (a <= b) <= c is a type mismatch.  so much of the literature on category theory fo
22:23:42 <atp> cuses on concrete categories, so this is a bit difficult to wrap my head around
22:25:13 <atp> the thing is, the associativity law for morphisms means essentially nothing in the concrete case, because function composition is associative in general
22:25:46 <atp> so clearly the point of the associativity law is to ensure that non-concrete morphisms preserve some characteristics of functional mappings
22:26:45 <dmead> :P
22:29:14 <cinimod> if a <= b and b <= c then a <= c so composition
22:31:36 <cinimod> if a <= b and b <= c and c <=d then it doesn't matter which way round you do the comparisons
22:31:43 <cinimod> Hence associativity
22:32:13 <atp> cinimod: so in this particular nonconcrete example, "composition" is better thought of as transitivity... i think i'm beginning to see why some mathematicians prefer the term arrow to morphism
22:32:57 <cinimod> actually if you use arrows then <- looks like <=
22:33:37 <atp> i don't quite follow ... ?
22:33:52 <cinimod> well you could just replace one by the other
22:34:01 <cinimod> sorry I have to go to work now
22:34:14 <Korollary> Actually it's you who decides what the composition operation does. The way you choose (i.e. morphisms via <=), associativity is immediately satisfied.
22:35:31 <atp> Korollary: right, i think i understand that now.  it's just that the way i've been seeing associativity written in papers is generally as (f * g) * h = f * (g * h)
22:35:48 <Korollary> That is still true
22:36:22 <atp> which carries over well in the concrete case, but if * is <= then (f <= g) <= h = f <= (g <= h) is kind of wacky syntax
22:36:36 <Korollary> * is not <=
22:36:44 <atp> what is *, then?
22:37:05 <atp> how does one "compose" morphisms in this nonconcrete case?
22:37:23 <atp> cinimod: thanks for your help, btw
22:38:24 <Korollary> You defined composition like: if (f <= g) is a morphism and (g <= h) is a morphism, then the morphism (f <= h) is their composition.
22:39:04 <atp> oh right!  i see, because (f <= g) is the morphism, not f or g!
22:39:07 * atp slaps his head.
22:39:30 <atp> f or g are objects, not morphism
22:39:31 <atp> s
22:39:35 <atp> in this case
22:40:00 <Korollary> I usually pick A, B, C, etc. for objects and f, g, h for morphisms to keep my sanity
22:40:08 <atp> right, right, i see how i confused myself
22:40:39 <atp> for A, B \in (P, <=) there exists a morphism f : A -> B iff (A <= B), right?
22:41:07 <Korollary> yes
22:41:55 <Korollary> iirc, there can also be a g : A -> B. I don't think the morphism has to be unique.
22:42:32 <atp> so if we have morphisms h : A -> B, g : B -> C, f : C -> D, then f * (g * h) : A -> D, right?
22:42:50 <atp> Korollary: yeah, uniqueness isn't a requirement
22:43:16 <Korollary> yes
22:43:20 * atp scratches his head.
22:43:31 <sorear> 12
22:43:44 <atp> well clearly, A -> D is a morphism by transitivity of ordering
22:48:12 <atp> i guess that in this case, the parenthesis in (f * g) * h = f * (g * h) just affect the intermediate morphism we use to determine the end result (A <= D)... either f * g : B -> D or g * h : A -> C
22:48:19 <atp> right?
22:50:03 <monochrom> partial order as category has unique morphisms.
22:50:23 <atp> yeah... i'm reading that unique morphisms imply composition
22:51:12 <atp> any reflexive and transitive relation on a set satisfies the category laws
22:54:34 <monochrom> reflexive+unique = the id law.  transitive+unique = composition.  unique+associativity of conjunction = associativity of composition, i.e., (a<=b /\ b<=c) /\ c<=d  =  a<=b /\ (b<=c /\ c<=d)
22:55:37 <atp> so you're using logical and as composition then?
22:56:01 <monochrom> Did I forget to say transitive+unique = composition ?
22:56:06 <atp> nope
22:56:26 <monochrom> Then that says what I use for composition.
22:56:52 <monochrom> OOps. I guess there is no conflict.  Transitivity contains /\.
22:57:18 <atp> i guess i don't entirely understand what you mean by transitive + unique = composition
22:57:29 <atp> i do appreciate your taking the time to explain it to me, though.
22:57:33 <monochrom> I forgot that transitivity contains /\
23:05:26 <UUStudent> anyone experienced with state monads?
23:05:37 <monochrom> yes
23:07:32 <UUStudent> i'm trying to use state monads to add/modify things within a data structure, but i don't know how to get started even initializing it or anything. the haskell tutorial didn't give an example for that section
23:07:49 <skew> That sounds like ST
23:08:37 <UUStudent> hmm, the professor said it could also be done without the state transformer monad
23:08:54 <monochrom> What data structure? Or do you mind I choose a data structure?
23:09:13 <UUStudent> i have one called Company
23:09:36 <monochrom> ST stands for State Thread.  Control.Monad.ST.  May or may not be relevant.
23:10:03 <UUStudent> data Company = C [Dept]       Dept = D Name Manager          SubUnit = PU Employee | DU Dept         Employee = E Person Salary
23:10:22 <UUStudent> Person = P Name Address        Salary = S Float      type Manager = Employee        type Name = String        type Address = String
23:11:23 <UUStudent> oops, omitted "data" before Dept, SubUnit, Employee, Person, and Salary. anyway, all that is wrapped in an Ret (Error) monad and i have functions to search/add
23:12:10 <UUStudent> so i have data SM a = SM (Company -> (a,Company))    and defined readSM, updateSM, and runSM based on that, and no idea how to test those functions
23:12:47 <monochrom> May I have the type signatures of them?
23:13:24 <UUStudent> readSM :: SM Company          updateSM :: (Company -> Company) -> SM ()              runSM :: Company -> SM a -> (a, Company)
23:15:31 <monochrom> runSM (PU (E (P "mono" "earth") (S 0.2))) (updateSM (const (PU (E (P "mono" "earth") (S 0.1)))))
23:15:54 <monochrom> Eh! That's wrong.
23:18:37 <monochrom> runSM (C []) (updateSM (\ C s -> D "love" (E (P "mono" "earth") (S 0.1)) : s))
23:18:51 <monochrom> The initial state is a company with no department.
23:19:12 <monochrom> Then I modify the state. I add a department to the company.
23:19:30 <monochrom> That's still wrong
23:19:42 <monochrom> runSM (C []) (updateSM (\ C s -> C (D "love" (E (P "mono" "earth") (S 0.1)) : s)))
23:19:47 <monochrom> Now it's better.
23:21:53 <monochrom> You can experiment with other initial states. Replace C [] by C [something-else]. You will see that I just add a deparment; all departments in the initial state are preserved.
23:22:24 <UUStudent> that's the initial state i've been trying with, probably the best bet. sweet
23:22:36 <UUStudent> parse error..assuming that means i typed something in wrong
23:23:12 <monochrom> Due to the blindingly convoluted data structure, it is nearly impossible to experiment with this and learn anything.
23:23:49 <monochrom> You spend forever crafting a valid company rather than learning about SM.
23:23:50 <UUStudent> yeah.. i spent a while just trying to figure out the structure, but oh well
23:24:31 <UUStudent> plus the prof. was gone so had a grad student teach the SM part of class :)
23:24:34 <monochrom> It would be most educational to use something transparent like Bool or Char or Int or String.
23:26:58 <UUStudent> plus the prof. was gone so had a grad student teach the SM part of class :)
23:27:29 <UUStudent> still trying to type-check. what's the s you're consing the company onto?
23:27:30 <monochrom> Teaching is hard.
23:27:32 <encryptio> :t liftM
23:27:41 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:27:48 <UUStudent> couldn't match company against t -> t1 in first argument of updatesm
23:28:01 <Cheery> Teaching is hard - that's why you teach to learn
23:28:17 <monochrom> It's supposed to be: updateSM (\ C s -> C ((new department here) : s))
23:28:19 <encryptio> @hoogle Monad m => (a -> m b) -> m a -> m b
23:28:20 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
23:28:20 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
23:28:20 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
23:28:35 <encryptio> :t (>>=)
23:28:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:28:40 <encryptio> doh.
23:29:25 <igli> dons: ping
23:30:40 <igli> @tell dons Where do i start with the source code to add a per-channel Secondary attr (default to 0) ?
23:30:40 <lambdabot> Consider it noted.
23:31:57 <UUStudent> is s an input department?
23:32:29 <monochrom> input list of departments.
23:34:03 <hpaste>  stmartin pasted "Type checking prob with IO" at http://hpaste.org/1879
23:34:36 <stmartin> So many errors, can someone help with this one. I think I'm starting to get my head around Haskell error messages/typing...
23:35:02 <UUStudent> still typechecking. now wondering if my functions are even corect :) http://jdurhous.googlepages.com/proj4.lhs
23:36:30 <monochrom> Oh, I missed subunits.
23:37:09 <monochrom> Or equivalently, you missed subunits too.
23:38:17 <UUStudent> somehow i guess i did
23:38:20 <hpaste>  stmartin annotated "Type checking prob with IO" with "added type defs" at http://hpaste.org/1879#a1
23:38:21 <monochrom> D "love" (E (P "mono" "earth") (S 0.1)) []    use this as the new department
23:41:29 <UUStudent> so something like.... runSM (C []) (updateSM (\C s -> (C [newdept]) : s)) ?
23:43:27 <monochrom> runSM (C []) (updateSM (\C s -> C (newdept : s)))
23:43:28 <UUStudent> strange..it's still saying updateSM expects a company instead of a function... but it's defined as updateSM f = SM (\s -> ((), f s))
23:44:28 <monochrom> updateSM f = SM (\s -> ((), f s))  is correct.
23:47:21 <UUStudent> well that's good. i'm not sure why it keeps telling me "Expected type: Company" as the first argument of updateSM though
23:47:54 <Korollary> stmartin: parse_command doesn't have an IO type. Just say return (parse_command line). The Nothing branch also needs a return.
23:48:39 <stmartin> Oh, is there something special about return? I thought it was just for early exits.
23:49:05 <monochrom> return does not early exit.
23:49:09 <Korollary> return places the value in the IO monad.
23:49:15 <Korollary> @type return
23:49:18 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:49:25 <stmartin> Ahhhh, I must try to remember that....
23:49:33 <monochrom> do { return (); putStrLn "Hello world" }   -- try this.
23:49:42 * stmartin scribbles it on his forehead.
23:50:52 <monochrom> Throw in a layer of ContT and you will have early exits.  This is an evil advice.
23:52:51 <stmartin> Korollary++
23:56:16 <UUStudent> haskell keeps telling me updateSM takes a Company instead of a function...strange
23:57:18 <monochrom> @type \f -> Just (\s -> ((), f s))
23:57:21 <lambdabot> forall t t1. (t -> t1) -> Maybe (t -> ((), t1))
