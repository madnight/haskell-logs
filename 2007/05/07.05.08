00:00:17 <dons> cpu.
00:01:00 <dons> note, on amd64, -fasm is pretty good.
00:01:02 <dons> :-)
00:01:49 <andygill> So you've got a Haskell program to generate this table, as well?
00:02:11 <dons> yeah. http://www.cse.unsw.edu.au/~dons/code/nobench/bin/gen-report.hs
00:02:24 <dons> and the stats are collected by http://www.cse.unsw.edu.au/~dons/code/nobench/bin/bench.hs
00:02:32 <dons> (there's a darcs url on the nobench page)
00:03:10 <andygill> Simon was always into geometric means .. glad to see you've done the same
00:03:27 <dons> yeah, he bugged me until I added it.
00:03:29 <dons> :)
00:03:55 <Korollary> why?
00:04:35 <dons> normalising results is good
00:05:13 <Korollary> but why geometric
00:05:33 <dons> its a standard way to present this kind of data, I think.
00:05:34 <andygill> geometric means are good because one (good or bad) result does not dominate the total.
00:05:38 <dons> yeah
00:06:02 <dons> whereas previously, one erroneous program would cause much distortion
00:09:56 <monn> what language is used in http://frmb.org/images/lambda.gif ?
00:10:12 <dons> that's lambda calculus
00:13:39 <monn> what software enable us to do see the reduction like that?
00:14:36 <Korollary> any lambda calculus interpreter. There are some even in javascript. Just google.
00:14:48 <kfish> monn: http://frmb.org/lambda.html
00:14:49 <lambdabot> Title: into the wibble [lambda-calculus]
00:15:26 <monn> lol, I should check the page first :)
00:16:40 <MarcWeber> Did I miss the function to set a single char using ByteStrings ? There is the index and unsafeIndex (which still contains an assert statement?) to get an arbitrary byte.
00:18:04 <dons> MarcWeber: singleton 'x' ?
00:18:16 <dons> you want to unsafely mutate ??
00:18:39 <dons> MarcWeber: btw, the assert is compiled out with -O
00:19:29 <dons> kfish: hey. got xmonad? :-)
00:19:36 <kfish> heya dons :-)
00:19:56 <kfish> currently using beryl, is xmonad similar? ;-)
00:20:01 <dons> xmonad: greatest window manager ever written at unsw mwhahaha evil evil
00:20:08 <dons> kfish: :P
00:20:16 <kfish> hahahaha
00:20:38 * dons `ap` bus
00:21:02 <ozone> dons: you'll be changing your tune when e18 is rewritten in haskell
00:21:05 <ozone> :}
00:21:38 <kfish> ozone, heh, first we gotta resurrect hevas :-)
00:22:36 <ozone> i reckon dons should steathily integrate pastured functionality into xmonad
00:22:50 <ozone> two days later after the user's installed it... mooooooooo
00:30:26 * joelr1 sulks due to not understanding of co-arbitrary
00:30:43 <joelr1> can someone explain, once again?
00:30:45 <MarcWeber> dons: I did need something like bytestring[10]='x' .. (I should have used a binary library ;) ..
00:34:11 <MarcWeber> I finally ended implementing this function in C ;( pokeByteOff didn't write a single byte but 4 bytes the last three beeing 0.. The docs say that you might have to pay attention to alignment. Just wonder wether there could have been another option.
00:45:45 <hpaste>  osfameron pasted "Sample answer to exercise Chapter 3 SOE" at http://hpaste.org/1752
00:45:54 <osfameron> morning
00:46:05 <osfameron> this is the code for the snowflake exercise in chapter 3 SOE
00:46:16 <osfameron> it hangs for me when run in ghci - any suggestions ?
00:46:53 <osfameron> also... I have no idea how to compile it... ghc doesn't like it at all
00:49:51 * osfameron panics and hurriedly checks that the code he pasted still works (phew!)
00:54:07 <MarcWeber> osfameron: Don't know, don't have the Graphics.SOE module. But it might help if you paste the error messages from ghc when running ghc --make yourfile.hs as well.
00:57:40 <osfameron> ah!
00:57:46 * osfameron blushes
00:57:55 <osfameron> I wasn't using "--make"
00:58:24 <osfameron> but that hasn't created an executable
00:59:12 <osfameron> I was trying ghc -package HGL -package X11 3.hs
01:01:04 <osfameron> it says "Compiling SimpleGraphics ( 3_.hs 3_.o )" compiles those, and then stops
01:01:23 <osfameron> is there a nice tutorial on the ghc compiler?  "man ghc" is very informative but a bit terse
01:03:43 <MarcWeber> osfameron: haskell.org/ghc -> manual
01:09:03 <osfameron> MarcWeber: ah, thanks
01:09:09 <MarcWeber> osfameron: Didn't see the line bofere the last one. You can check wether ghc thinks it has finishes succesfully by checking the return value (in bash using echo $?) This might help you getting to know wether you've missed adding an option.
01:09:17 <MarcWeber> Did you succeed now?
01:09:41 <osfameron> not yet, I'm trying to, er, "interleave" this with my day job :-)
01:10:01 <osfameron> if I add && echo "DONE" it does indeed echo DONE
01:10:05 <osfameron> so bash thinks it finished OK
01:10:14 <osfameron> it creates the .o file, just not the executable
01:10:37 <MarcWeber> osfameron: Sorry. Change the module name to module Main..
01:10:54 <MarcWeber> or you can add another option to tell ghc this (I've forgotten which one)
01:11:12 <MarcWeber> Then you'll get your executable.
01:11:20 <osfameron> ah!  ok, that makes sense
01:12:35 <osfameron> yay, that works, thanks
01:12:38 <osfameron> it still hangs though
01:12:50 <osfameron> like it's waiting for an input event at random points
01:13:01 <osfameron> if I move the mouse over the window then it wakes up again.
01:14:26 <MarcWeber> Don't know the lib this app is using. All I know is that 'space' should close the window ;)
01:14:36 <osfameron> yup :-)
01:14:58 <osfameron> if I press space early in the rendering, the window is closed once it finishes rendering
01:15:23 <osfameron> which suggests that I'm not doing something stupid like running getKey on every iteration
01:15:27 <osfameron> so I don't know why it would hang
01:16:24 <MarcWeber> osfameron: I would suggest having a look at different examples and compare with one which doesn't hang.
01:16:55 <osfameron> good plan.  I'll google in my next break, I guess someone else will have posted a sample answer
01:17:03 <osfameron> thanks for the help :-)
01:21:30 <marscher> > map (filter (any isAlpha) ) $ (filter (/= ' ' )) ["cc", "555", "BB", "666", "AA"]
01:21:31 <lambdabot>  Couldn't match expected type `[[Char]]'
01:22:09 <joelr1> @pl iff x y = Iff x y Skip
01:22:10 <lambdabot> iff = flip flip Skip . Iff
01:40:47 <marscher> > foldl (-) [1..3]
01:40:48 <lambdabot>   add an instance declaration for (Num [t])
01:41:08 <marscher> how do i substract each element from its next neighbour?
01:41:19 <quicksilver> fold1 (-) [1..3]
01:41:22 <quicksilver> > fold1 (-) [1..3]
01:41:23 <lambdabot>   Not in scope: `fold1'
01:41:27 <quicksilver> > foldl1 (-) [1..3]
01:41:29 <lambdabot>  -4
01:41:40 <marscher> foldl1 ah ;) thx
01:41:40 <quicksilver> that's 1-2-3
01:41:50 <quicksilver> not clear to me what you really wanted though..
01:42:19 <quicksilver> > foldr1 (-) [1..3]
01:42:20 <lambdabot>  2
01:42:25 <quicksilver> that's 1-(2-3)
01:42:34 <quicksilver> which, obviously, is quite different :)
01:42:59 <marscher> from left to right ;)
01:43:18 <marscher> thats why i used foldl initially
01:43:36 <dmwit> > zipWith (-) [1..3] (tail [1..3]) -- another interpretation of "subtract each element from its next neighbour"
01:43:38 <lambdabot>  [-1,-1]
01:56:45 <marscher> how do i calculate bases to negative exponents? prelude doesn't like it
01:57:04 <marscher> at least with the prelude infix ^ operator
01:57:38 <ClaudiusMaximus> > (2^^(-3), 2 ^(-3))
01:57:39 <lambdabot>  Exception: Prelude.^: negative exponent
01:57:44 <ClaudiusMaximus> > (2^^(-3))
01:57:46 <lambdabot>  0.125
01:58:08 <quicksilver> marscher: there are three exponentiation operators
01:58:15 <marscher> > 2^(-3)
01:58:17 <lambdabot>  Exception: Prelude.^: negative exponent
01:58:17 <quicksilver> marscher: depending on how 'hard' the maths involved is
01:58:23 <marscher> > 2^^(-3)
01:58:25 <lambdabot>  0.125
01:58:26 <quicksilver> ^,^^,**
01:58:35 <marscher> how hard? :D
01:58:47 <ClaudiusMaximus> :t ((^),(^^),(**))
01:58:49 <lambdabot> forall a b a1 b1 a2. (Integral b, Num a, Integral b1, Fractional a1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
01:59:04 <quicksilver> yes; there are more efficient, faster ways of calculating positive integer exponents
01:59:08 <quicksilver> than general floating ones
01:59:09 <quicksilver> etc
01:59:16 <quicksilver> > 2**3
01:59:17 <marscher> ah of cource ;)
01:59:17 <lambdabot>  8.0
01:59:23 <quicksilver> > 2^3
01:59:25 <lambdabot>  8
01:59:32 <quicksilver> same value but you might expect 2^3 to be faster
01:59:40 <quicksilver> also 2^3 'knows it's an integer'
01:59:49 <quicksilver> whilst 2**3 thinks it is fractional
01:59:57 <marscher> in which dimension?
02:01:06 <marscher> (^) = o(^^)
02:01:14 <ClaudiusMaximus> > 2^100 -- might be slower for large integers? but more accurate)?
02:01:21 <lambdabot>  1267650600228229401496703205376
02:01:29 <marscher> > 2 ^^100
02:01:34 <lambdabot>  1.2676506002282295e30
02:01:42 <marscher> slower
02:01:47 <monn> > 2 ^^ 512
02:01:55 <lambdabot>  1.3407807929942598e154
02:02:05 <monn> 2 ^ 512
02:02:11 <monn> > 2 ^ 512
02:02:13 <marscher> dont annoy the poor lambdabot ;P
02:02:14 <lambdabot>  1340780792994259709957402499820584612747936582059239337772356144372176403007...
02:02:45 <quicksilver> marscher: Are you familiar with how fractional exponents are calculated?
02:02:53 <monn> @source ^
02:02:53 <lambdabot> ^ not available
02:03:00 <quicksilver> marscher: basically (**) will inevitably use logarithms to do its work
02:03:15 <quicksilver> marscher: so it's stuck with approximate, floating point work
02:03:27 <quicksilver> marscher: (^) can use exact, arbitary precision integers if needed
02:04:11 <quicksilver> In maths, X^Y for general (real) X and Y is defined as exp(Y ln X)
02:04:16 <monn> quciksilver: does ^ use fast exponentiation?
02:04:27 <quicksilver> monn: I'm not sure if it's fast but it is at least exact
02:04:30 <quicksilver> monn: I imagine it's fast
02:05:05 <quicksilver> also you can't give ** a negative base
02:05:12 <quicksilver> > (-3)**(3)
02:05:14 <lambdabot>  -27.0
02:05:18 * quicksilver blinks
02:05:21 <quicksilver> or, apparently you can
02:05:26 <quicksilver> > (-3)**(3.5)
02:05:28 <lambdabot>  NaN
02:05:31 * quicksilver grins
02:05:36 <quicksilver> > (-3)**(3.0)
02:05:38 <lambdabot>  -27.0
02:05:44 <quicksilver> that's a bit odd
02:05:52 <quicksilver> > (-3.)**(3.0)
02:05:53 <lambdabot>      The operator `.' [infixr 9] of a section
02:05:54 <lambdabot>         must have lower precede...
02:05:56 <quicksilver> > (-3.0)**(3.0)
02:05:58 <lambdabot>  -27.0
02:06:05 <quicksilver> you shouldn't give ** a negative base, I'd say :) I'm surprised it works.
02:07:46 <marscher> well, thx for the explanations, i think im gonna read something about this topic
02:09:03 <anne> who have a game with GUI?
02:09:13 <profmakx> o.o
02:09:26 <monn> anne: i have solitaire in this unlicensed winxp
02:09:27 <hpaste>  marscher pasted "little typerror..." at http://hpaste.org/1753
02:09:37 <marscher> what's wrong? ;)
02:10:03 <anne> just solitaire?
02:10:42 <monn> anne: and about tens more :)
02:11:40 <anne> :)
02:12:03 <anne> i need the code of a game with gui
02:12:22 <dmwit> anne: Frag?
02:12:27 <monn> haskell game?
02:12:34 <anne> ya
02:12:38 <anne> frag?
02:12:54 <monn> @where frag
02:12:55 <lambdabot> http://www.haskell.org/haskellwiki/Frag
02:14:23 <anne> thx...but i want an easy game
02:15:59 <dmwit> anne: What are you trying to do?
02:16:06 <dmwit> Do you just want some examples of GUIs, or what?
02:16:45 <dmwit> If so, look around the gtk2hs page, there's a few good examples there.
02:18:33 <anne> no example of guis...just a game with graphical interface...like rummy,backgammon.sodoku
02:19:16 <marscher> expo (x:xs) = (trace "bi: " ++ show (bi) ) (bi x ^^ expo xs)
02:19:26 <marscher> bi is function
02:19:32 <marscher> bi :: [Integer] -> Integer
02:22:33 <quicksilver> you cant' show a function
02:24:08 <marscher> i got it too... i'am to stupid this morning :D
02:25:01 <pitecus> Would it be very complicated to interface haskell with a C++ library? If I only need a few functions?
02:25:10 <marscher> now i got a typing problem... bi always returns Integer, expo returns Float or Double..
02:25:22 <marscher> how can i mix this?
02:25:44 <quicksilver> pitecus: no it's quite simple
02:25:56 <quicksilver> :t (^^)
02:26:02 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
02:26:11 <pitecus> quicksilver, are there any examples around?
02:26:35 <quicksilver> pitecus: http://haskell.org/haskellwiki/GHC/Using_the_FFI
02:26:37 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
02:26:50 <joelr1> how can you write something like this in haskell? case x of Foo _ | Bar _ -> ... Baz _ -> ...
02:27:12 <quicksilver> joelr1: you can't, directly
02:27:19 <hpaste>  (anonymous) annotated "little typerror..." with "(no title)" at http://hpaste.org/1753#a1
02:27:23 <joelr1> quicksilver: i thought so :-(
02:27:49 <pitecus> quicksilver, this seems to be about windows DLL libraries. Is it similar on Unix?
02:27:54 <quicksilver> marscher: well it seems to me that expo really does return fractional numbers
02:28:12 <marscher> yeah it does
02:28:26 <quicksilver> pitecus: well try those links at the top of that page
02:28:43 <pitecus> ok thanks
02:28:47 <quicksilver> marscher: you can 'upgrade' bi x to a fractional
02:29:00 <quicksilver> marscher: (fromIntegral $ bi x)
02:29:15 <quicksilver> marscher: but I think you need (**)
02:29:22 <quicksilver> marscher: since yhou are raising to the power expo xs
02:29:32 <quicksilver> marscher: and expo xs is fractional
02:37:09 <marscher> but Fractional is a class and not a type...
02:37:15 <marscher> what do i misunderstand?
02:37:36 <quicksilver> I'm not sure :)
02:37:47 <quicksilver> fromIntegral allows you to 'upgrade' to any Num type
02:37:54 <quicksilver> from any Integral type
02:38:04 <quicksilver> haskell will figure out which one to use based on other constraints
02:38:08 * osfameron googles and fails to find other sample answers for HSOE :-(
02:38:12 <quicksilver> since you use it as the left argument to ^^
02:38:21 <quicksilver> it will work out it needs Fractional
02:38:28 <quicksilver> you may need to coerce it to Double
02:38:32 <quicksilver> or defaulting may figure that out
02:38:58 <osfameron> anyone else got a sample answer for 3.2 snowflake fractal?  that I can compare to http://hpaste.org/1752
02:39:35 <marscher> quicksilver, thx a lot ;)
02:40:08 <quicksilver> osfameron: instead of fromInteger . toInteger you can just use fromIntegral
02:40:18 <marscher> now the only thing left is, that testexpo call fails with "empty argument!" exception
02:40:44 <marscher> but i assign it my testdata
02:40:45 <quicksilver> osfameron: instead of concat . repeat you can use 'cycle'
02:40:49 * marscher is confused
02:41:17 <osfameron> quicksilver: cool.  notedl.
02:41:21 <osfameron> I'm looking for other answers, as MarcWeber suggested, to see if they hang while rendering like mind does...
02:41:48 <quicksilver> osfameron: sequence_ . map is also known as mapM
02:42:09 <quicksilver> erm, mapM_
02:42:22 <quicksilver> :t sequence_ . map
02:42:25 <lambdabot>     Couldn't match expected type `[m a]'
02:42:25 <lambdabot>            against inferred type `[a1] -> [b]'
02:42:27 <osfameron> what's the significance of the trailing _ in both those cases ?
02:42:35 <quicksilver> osfameron: throw away the result
02:43:03 <osfameron> ah, so basically "this is a side effect" ?
02:43:13 <quicksilver> yes
02:43:21 <marscher> i want to trace the expo function (the calculation) like i my paste - whats wrong with the trace statement?
02:43:21 <quicksilver> or "I'm ignoring everything except side effects"
03:03:45 <drigz> would it be possible/easy to put compiled haskell into a c/c++ program?
03:04:30 <Baughn> drigz: Yes/yes
03:04:31 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
03:04:33 <drigz> (i want to try submitting a haskell program to the topcoder system grader
03:04:37 <drigz> )
03:04:39 <Baughn> drigz: ...no.
03:04:44 <drigz> why not?
03:04:54 <Baughn> drigz: It requires a fairly enormous runtime system to work
03:05:10 <drigz> oh yeah, all the libraries
03:05:12 <Baughn> Usually that just manifests as a library dependency, but..
03:05:17 <drigz> i forgot about those
03:05:20 <drigz> ok, thanks
03:05:23 <Baughn> And the GC, and such
03:11:54 <mux> heh
03:11:56 <mux> So, we're finally at a 'valid' Monad instance for Set, and it only took us
03:11:59 <mux> multi-parameter type classes, undecidable instances, and GADTs. :)
03:12:27 <Baughn> drigz: Also, while GHC is perfectly capable of /interfacing/ with C code, and it certainly compiles via C, it doesn't really compile /to/ C.
03:13:44 <flux> wasn't jhc supposed to generate ANSI C code
03:13:52 <flux> I wonder how it's going these days..
03:14:11 <Baughn> I dare say that the C code, while possibly ANSI, would be totally unreadable
03:14:19 <Baughn> That does not make a good topcoder submission.
03:15:18 <drigz> i wasn't planning on using it in competitions
03:15:32 <drigz> just in the practise bit
03:15:45 <drigz> jhc might be good, though
03:17:32 <dmwit> I don't know about you, but I read -fvia-c code over a light breakfast repast.
03:18:09 <dmwit> Mmmm, yes dear, I do think the toast is particularly delightful today, and, oh my!  Look at those beautiful closures.  I've never seen such a well-crafted thunk in my whole life!
03:19:50 * mux has a whole different take on Djinn now that he watched the video of the google tech conference talking about the Girard-Reynold isomorphism and F2 / P2 descriptions
03:20:28 <dons> mm great mux! :)
03:21:25 <drigz> can djinn actually do useful things? (useful to the level of @pl, say)
03:21:54 <dons> hmm. not really. its useful for games in here, but i've never used it to write code
03:21:56 <mux> no, but it's spiffy!
03:22:03 <dons>  @pl i actually do use everyday
03:22:09 <dons> we should have put more effort into it :}
03:22:28 <mux> @djinn a -> b -> a
03:22:29 <lambdabot> f a _ = a
03:22:31 <drigz> @pl is the best
03:22:32 <lambdabot> is the best
03:22:39 <drigz> oops
03:22:57 <mux> plz someone hand 'const' over to djinn :-)
03:23:02 <dons> @djinn (Eq a) => a -> a -> a
03:23:02 <lambdabot> f a b =
03:23:02 <lambdabot>     case a == a of
03:23:02 <lambdabot>     False -> b
03:23:02 <lambdabot>     True -> a
03:23:54 <mux> @djinn foo ? (a -> b) -> a -> b
03:23:55 <lambdabot> Cannot parse command
03:24:02 <mux> @djinn foo :: (a -> b) -> a -> b
03:24:03 <lambdabot> Cannot parse command
03:24:17 <dons> @djinn (a -> b) -> a -> b
03:24:17 <lambdabot> f a = a
03:24:22 <mux> hmm, in the talk he is handing djinn the name of the function he shuld be defining
03:24:33 <mux> oh well, not that it matters much.
03:24:56 <dons> mux, yeah, works for the cmdline version
03:25:04 <dons> oh, wadler was using djinn?
03:25:06 <mux> anyways, that isomorphism between type signatures and code is truly stunning
03:25:13 <mux> it wasn't wadler in this talk
03:25:14 <dons> that's cool. i heard he tried out @pl a bit too.
03:25:16 <dons> ah ok.
03:25:23 <mux> not sure who it was
03:25:47 <drigz> i always thought that djinn was just taking that 'if it type checks, it's the right code' to extremes
03:26:01 <mux> http://video.google.com/videoplay?docid=-4851250372422374791
03:26:02 <lambdabot> Title: Advanced Topics in Programming Languages Series: Parametric Polymorphism - Googl ...
03:27:01 <dons> drigz: nah, types as proofs, find a witness to the proof, found the code for the type.
03:27:11 <mux> it's quite impressive to be able to tell with 100% certitude that some type cannot be inhabited
03:27:20 <mux> @djinn a -> b
03:27:21 <lambdabot> -- f cannot be realized.
03:27:38 <dons> why do you think we go nuts about strong static typing :) its theorem proving for programmers.
03:27:48 <mdmkolbe|work> mux: only if you excluse bottom of course
03:27:52 <mux> sure
03:28:11 <mux> by definition of bottom
03:28:38 <dons> ?free foldr
03:28:40 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
03:28:42 <dons> ?free id
03:28:44 <lambdabot> f . id = id . f
03:28:48 <dons> theorems for free!
03:28:51 <dons> types for all!
03:29:11 <dons> ?free (==)
03:29:12 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:29:16 <dons> ah, no classes
03:29:18 <dons> ?free map
03:29:20 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
03:29:36 <dons> ?free const
03:29:39 <lambdabot> f . const x = const (f x) . g
03:29:55 <dons> right.
03:30:18 <mux> I need to send mail to wadler asking him where he got that 'lambda superman' t-shirt
03:30:28 <mux> it's an absolute must-have
03:30:42 <dons> hehe
03:30:55 <mux> This is a job for... lambda calculus!
03:31:13 <mdmkolbe|work> The Wiki [1] claims there are closure types for CONSTR_INTLIKE and CONSTR_CHARLIKE, but the header [2] doesn't seem to have those defines.  What gives?.  [1] http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#DataConstructors [2] http://darcs.haskell.org/ghc/includes/ClosureTypes.h
03:31:17 <lambdabot> Title: Commentary/Rts/Storage/HeapObjects - GHC - Trac, http://tinyurl.com/2y6qst
03:31:44 <dons> and with his mighty beta reduction, lambda man redduced his enemies to normal form!
03:31:54 <mux> hahaha
03:32:25 <mux> who said nerd? :)
03:32:41 * dons can't wait for his xmonad tshirt to arrive
03:32:49 <dons> all the power of newtype deriving, in a tshirt!
03:34:40 <mux> in a mere millisecond, lambdaman transforms itself into second-order lambda calculus and blasts his enemies using type-abstraction!
03:35:28 <LeCamarade> dons: Who designed the logo?
03:36:22 <dons> my girlfriend and I, one sunday afternoon.
03:36:32 * LeCamarade thinks the `We are not afraid of a little unsafePerfomIO' t-shirt is the snazziest thing among the FP keepsakes. It's even sexy - something he can't blame most FPers for being.
03:36:45 <mux> heh
03:36:49 * LeCamarade ... now it may be the xmonad logo.
03:36:59 <szabi_> LeCamarade: how are you progressing with the torque stuff?
03:37:02 <mux> what about 'we are not afraid of unsafeInterleaveIO?'
03:37:11 <LeCamarade> szabi_: :oO
03:37:15 <szabi_> LeCamarade: :)
03:37:48 * LeCamarade did it for a while, then JavaBoss floated by, then he forgot about the whole thing ... 
03:37:55 <szabi_> how do you usually implement 'default parameters' in haskell?
03:37:57 <LeCamarade> szabi_: Did you do it?
03:38:13 <mux> szabi_: often with Maybe types
03:38:35 <mux> gtk2s has lots of functions with optional parameters this way
03:38:36 <LeCamarade> szabi_: With the Either type?
03:38:47 <dons> szabi_: optional? or default?
03:38:51 <mux> Either is probably too much if it's an optional parameter
03:38:53 <szabi_> LeCamarade: It's equal in functionality to the python code
03:39:12 <szabi_> dons: actually, I'm interested in both :)
03:39:15 <mux> dons: ain't this the same? if you have a default, it means you are not forced to supply one
03:39:22 <mux> so it's optional
03:39:31 <LeCamarade> szabi_: Bon. By the time I stopped, I had stripped it of much sexiness, so maybe you'd have hated it.
03:40:15 <dons> mux, ah I see.
03:40:19 <dons> yes, Maybe a.
03:40:29 <LeCamarade> szabi_: I find that I don't usually need optional params and stuff in Haskell. Maybe I'm wrong, but there are some very good solutions for which I have no good problems. :oD
03:40:31 <dons> Nothing for the case you fall back to a wired in default
03:40:39 <mux> yeah
03:40:49 <mux> of course if you can do without the default parameter it's good :-)
03:42:38 <quicksilver> szabi_: If I'm trying to implement an attractive high-level interface with multiple possible calling paradigms
03:42:52 <quicksilver> szabi_: then I give different names to the functions that take different kinds of parameters, but....
03:43:04 <quicksilver> szabi_: I consider implementing a typeclass to abstract between them if I think it's worth it
03:44:04 <szabi_> here is what I want to do: a function on images which get's an optional parameter for downsampling
03:44:09 <joelr1> :t fold
03:44:11 <lambdabot> Not in scope: `fold'
03:44:13 <szabi_> foo img downsample = ....
03:44:16 <joelr1> ah!
03:44:33 <szabi_> if downsample is not given it defaults to 1
03:45:01 <dons> szabi_: data Sample = None | Sample Int
03:45:07 <dons> f :: Sample -> ... -> Image
03:45:09 <szabi_> yes, I could downsample myself explicitly, but I would like it better this way
03:45:14 <dons> f None = f (Sample 1)
03:45:18 <dons> f xs = ...
03:46:34 <mdmkolbe|work> where do I file a bug report for lambda bot
03:46:36 <szabi_> dons: so the only way is to actually give None as a parameter? Isn't it possible to omit it somehow?
03:46:38 <mdmkolbe|work> @help hackage
03:46:39 <lambdabot> Plugin `help' failed with: IRCRaised Plugin/Dummy.hs:(23,19)-(46,62): Non-exhaustive patterns in case
03:46:52 <dons> nice, functional pearl page "This page has been accessed 5,000 times" :)
03:47:01 <dons> szabi_: what's the type of 'f' then?
03:47:01 <szabi_> like: f (img,ds) =...
03:47:08 <szabi_> f (img) = ...
03:47:08 <szabi_> ?
03:47:37 <dons> data Arg = Pair Image Rate | Only Image
03:47:44 <dons> f (P img ds) ==
03:47:48 <dons> f (Only img) = ...
03:47:56 <dons> f :: Arg -> ..
03:48:39 <szabi_> but then I have to use it like: f Only currimg ?
03:48:51 <dons> yea, you could do that.
03:48:55 <dons> f' = f . Only
03:49:08 <dons> f' :: Image -> ..
03:49:35 <szabi_> but then it's a different name...
03:49:50 <szabi_> ok I get it. I can't do what I want
03:49:52 <szabi_> no problme
03:49:59 <dons> right. I'd think the most idioimatic way was a data type for the argument forms you handle
03:50:26 <dons> data A = O Image | P Image Int
03:50:30 <dons> f (O img) =
03:50:36 <dons> f (P img n) =
03:50:48 <dons> that's the standard way to do the variant args you want
03:51:04 <dons> since you somehow have to type this function, and that means using a runtime tag to indicate which branch to take
03:51:19 <dons> the above form would be obvious to any haskeller, so that's probably the best way.
03:54:39 <szabi_> dons: ok, thanks
03:55:21 <szabi_> what about messing around with xml? HaXml? Is it the best I can have?
03:55:38 <dons> haxml or hxt seem to be the most common libs used.
03:55:52 <dons> there's some fun deep embeddings of xml in the type system, if you're generating xml.
03:56:03 <dons> but they're more experimental
04:05:01 <quicksilver> szabi_: you can do what you want
04:05:06 <quicksilver> szabi_: by using typeclasses
04:05:25 <quicksilver> szabi_: check out the HSH stuff for a practical example
04:05:34 <quicksilver> I'm not *necessarily* recommending it though
04:06:25 <dons> ah yes, you could do it that way
04:06:32 <dons> good point, quicksilver
04:06:48 <quicksilver> like I say, I tend to use functions with different names
04:06:52 <quicksilver> which gives one level of abstract
04:07:03 <quicksilver> then I *consider* the use of typeclasses as an additional abstractiong
04:07:09 <dons> yeah, actually overloading on type, to do say, varargs, is a bit rare.
04:07:10 <quicksilver> if you want a really high-level interface
04:08:40 <quicksilver> one approach which you must *never* use is [Dynamic] though
04:08:44 <quicksilver> that's just horrible :)
04:09:11 <quicksilver> I almost wish Dynamic and Typeable hadn't been invented, since their abuses appear to so far outnumber theit uses...
04:09:42 <dons> that's true.
04:10:09 <dons> we actually used Typeable + existentials + typeclasses to implement open data types in xmonad the other day.
04:10:18 <quicksilver> I saw you say that
04:10:24 <dons> since users need to be able to extend the events the window manager handles, on the fly.
04:10:27 <quicksilver> but I didn't have the spare brain bandwidth to question you on it :)
04:10:31 <dons> and combine events from multiple modules.
04:10:50 <dons> it uses the same idea as SimonM's extensible exceptions paper.
04:10:53 * quicksilver nods
04:11:36 <dons> basically, start with Typeable, then constraint  with an existential-with-typeclass-dictionary. then use:  instance Message T   to extend the inhabitants of the type
04:11:57 <dons> so, as usual, leaning on the open instance system, to do openness in other dimensions
04:13:01 <dons> hey ndm, ever thought of doing a 'Safe' Data.List using the NonEmpty/Empty List GADT?
04:13:19 <ndm> dons: yes, but it makes much more sense using a phantom type
04:13:31 <dons> you know the GADT? seems really nice.
04:13:43 <dons> i tried it out in xmonad, with some success.
04:13:49 <ndm> i've seen one of them, requires existentials to get the information out
04:13:57 <ndm> whereas a phantom type is a lot neater
04:14:05 <ndm> and H98, and simpler, and better type errors
04:14:05 <dons> data Empty
04:14:05 <dons> data NonEmpty
04:14:05 <dons> data List x y where
04:14:05 <dons>      Nil  :: List Empty x
04:14:06 <dons>      Cons :: x -> List y x  -> List NonEmpty x
04:14:09 <dons> that guy.
04:14:15 <ndm> oh, ok
04:14:24 <dons> head :: List NonEmpty a -> a
04:14:24 <dons> head (Cons x _) = x
04:14:24 <ndm> that is just hte phantom type representation in a GADT
04:14:32 <dons> *Main> safehead Nil
04:14:32 <dons>       Expected type: List NonEmpty a
04:14:33 <dons>       Inferred type: List Empty x
04:14:34 <dons> yeah
04:14:36 <dons> it is.
04:14:46 <ndm> you can do it identially without phantom types, apart from the pattern matching
04:14:54 <ndm> which i guess is an issue
04:15:42 <dons> ndm, I want to do some static checking on xmonad. should I use catch?
04:15:49 <ndm> dons: yes
04:16:00 <ndm> dons: do you want to prove the absence of pattern match errors?
04:16:05 <dons> I do.
04:16:10 <ndm> then catch is perfect
04:16:15 <dons> of the core StackSet structure.
04:16:25 <dons> let me find it.
04:16:26 <ndm> dons: have you seen my ICFP paper?
04:16:37 <dcoutts_> dons: what is the state of QC? are we awaiting QC2 or should we be patching & extending the current QC?
04:16:37 <dons> not yet. is it online?
04:16:45 <ndm> it has to be Yhc compilable, and if you treat it as a library, its easy enough to do
04:16:52 <dcoutts_> dons: eg things like making it an instance of applicative, adding other obvious instances etc
04:16:52 <ndm> no - i'll just put a copy up
04:16:58 <dons> dcoutts_: i think maybe a QC1.5?
04:17:02 <dons> dcoutts_: we need to ping bringert.
04:17:15 <dons> ndm, i might review for icfp though. so better not :}
04:17:33 <ndm> :(
04:17:38 <dcoutts_> dons: you might review what?
04:17:40 <dons> though if i get a paper about 'catch' i'll probably know who it is.
04:17:56 <ndm> dons: you don't have to not know who it is, merely not try and find out - so you are fine to review catch
04:18:01 <dons> dcoutts_: ndm's paper. i've got a stack here to go through. but i don't know who the authors are.
04:18:18 <dcoutts_> @tell bringert we're wondering if we should be patching/extending current QC or waiting for your QC2
04:18:18 <lambdabot> Consider it noted.
04:18:32 <dons> ndm, ok. well, stick it up, since i want to look at check for xmonad.
04:18:32 <ndm> dons: the reason i was more "concerned" is that it would be unfair for me to talk you through the paper (and its implementation), as its no longer a fair review
04:18:40 <dons> right.
04:18:48 <dcoutts_> @tell bringert we're also interested in making SmallCheck and StrictCheck as consistent as possible with QC/QC2
04:18:49 <lambdabot> Consider it noted.
04:18:59 <dons> i should probably check if i'm to review the check paper :/
04:19:01 <ndm> http://www-users.cs.york.ac.uk/~ndm/private/catch-icfp2007.pdf
04:19:23 <ndm> and the darcs repo is:
04:19:32 <dons> ah no. look fine. no static checking papers.
04:19:33 <ndm> http://www.cs.york.ac.uk/fp/darcs/catch
04:19:35 <lambdabot> Title: Index of /fp/darcs/catch
04:19:42 <ndm> dons: so you are definately not reviewing Catch?
04:19:43 <Japsu> ndm: "Author I, Affiliation I, Contact Details I"? :P
04:19:55 <ndm> Japsu: anonomous reviewing, they don't get my details
04:20:07 <dons> ndm, hang on...
04:20:12 <Japsu> ndm: oh, k
04:20:14 <ndm> dons: in that case i can talk you through the details
04:20:21 <dons> right. i am definitely not reviewiing it.
04:20:37 <ndm> ok, that makes it easier
04:20:38 <dons> so now we can talk about it :)
04:20:46 <dons> silly conferences.
04:20:50 <ndm> yeah...
04:20:59 <ndm> flip to the section about Data.FiniteMap
04:21:07 <dons> is that a darcs repo above?
04:21:09 <ndm> that shows how you basically go through and check a library
04:21:11 <ndm> no, in the paper
04:21:18 <ndm> the paper is in the darcs repo
04:21:47 <dons> s6.3?
04:22:13 <ndm> sounds about right
04:22:20 <ndm> you may also want to check out hte user manual: http://www.cs.york.ac.uk/fp/darcs/catch/catch.htm
04:22:21 <dons> dcoutts_: oh, andygill wants to integrate QC and hpc
04:22:21 <lambdabot> Title: Catch: A User Manual
04:22:25 <dons> so QC would print coverage info.
04:22:36 <dcoutts_> dons: ah yes, that'd be fun.
04:22:37 <dons> dcoutts_: and then we'd get stats on coverage for hackage libs.
04:22:44 <dons> and hand out "100% covered" badges
04:22:48 <dcoutts_> :-)
04:23:00 <ndm> the user manual says how to check something, the FiniteMap and FilePath examples in the paper show how to check a library, and the code is in the darcs
04:23:21 <dons> ndm, so i start by identifing the non-exhaustive patterns?
04:23:32 <ndm> dons: no, it does all the stuff for you :)
04:24:09 <ndm> dons: you start by checking the code compiles with Yhc, then annotating which functions are in the interface (if checking as though the code was a library), then fire and forget
04:24:40 <dons> ok.
04:24:43 <dons> that seems doable
04:24:52 <dons> i don't think StackSet uses anything non-h98
04:25:32 <dons> ndm, this is the module, the core logic of the wm, http://darcs.haskell.org/~sjanssen/xmonad/StackSet.hs
04:26:03 <ndm> {-# OPTIONS -fglasgow-exts #-} ?
04:26:17 <dons> ah yes, pattern guards
04:26:23 <dons> for the interesting 'swap' function.
04:26:28 <dons> see down the bottom
04:26:40 <dons> (we can decompile the pattern guard for check purposes)
04:27:09 <ndm> :( - i love pattern guards, they should definately be in Yhc!
04:27:12 <dons> there's a fromJust or two in there.
04:27:26 <dons> swap a b xs | a == b  = xs    -- do nothing
04:27:26 <dons>             | Just ai <- L.elemIndex a xs
04:27:27 <dons>             , Just bi <- L.elemIndex b xs = insertAt bi a (insertAt ai b xs)
04:27:29 <dons> is very nice.
04:27:35 <ndm> yeah
04:27:45 <ndm> could you convert it to a list comp?
04:28:02 <dons> case / case perhaps
04:28:07 <DRMacIver> Isn't fromJust basically "how to get a nullpointer exception in Haskell"? :)
04:28:32 <dons> DRMacIver: sort of. though you can't get it on any value, only things in Maybe :)
04:28:39 <ndm> head [computation | a == b, Just ai <- [L.elemIndex a xs], Just bi ...] ++ [original_value]
04:28:53 <ndm> with $ after head
04:28:54 <dons> cute.
04:28:59 <DRMacIver> dons: Well, yes. I'm just saying, that's exactly the sort of thing Maybe is supposed to help you avoid. :)
04:29:23 <dons> yes. fromJust is evil, since it needs a side condition.
04:29:34 <dons> 'check' helps us verify those side-conditions (as does QC)
04:29:42 <ndm> catch proves that fromJust is safe
04:29:45 <dons> right.
04:29:50 <ndm>     StackSet(..),           -- abstract
04:29:57 * ndm senses a lie (..) -- abstract
04:30:01 <dons> s/abstract/non-abstract/ :)
04:30:10 <dons> it was abstract, users wanted to extend things in weird ways
04:30:15 <dons> damn users and their config files
04:30:34 <ndm> lol
04:30:47 <ndm> ok, well it looks fairly safe, but always needs a proof
04:30:57 <dons> some of the fromJusts might be nice to check
04:31:04 <ndm> i'm off to lunch now, but will check it myself, since i've got the proof tools set up
04:31:12 <dons> index k w = uncurry (++) $ fromJust $ M.lookup k (stacks w)
04:31:16 <ndm> then talk you through how to do it, checking there isn't anything that needs extending
04:31:19 <dons> is a good case.
04:31:43 <ndm> that just plain old _is_ unsafe
04:31:49 <dons> yeah, 'k' must be in bounds.
04:32:10 <ndm> well catch will complain at that
04:32:22 <dons> nice.
04:32:29 <LeCamarade> > let x == y = null . dropWhile $ id $ zipWith (==) x y in "this" == "this"
04:32:31 <lambdabot>  Couldn't match expected type `[a]'
04:32:35 <dons> i'd be happy to get complaints too, not just 'ok' :)
04:32:43 <ndm> you would need to either require a Maybe wrapper, or pass in a default
04:32:57 <ndm> or of course, catch can generate preconditions for functions
04:33:06 <ndm> although in that particular case the precondition is False
04:35:32 <LeCamarade> > let x === y = null . dropWhile id $ zipWith (==) x y in "this" === "this"
04:35:34 <lambdabot>  True
04:36:07 <LeCamarade> Is == implemented (for lists, at least) in the compiler? Or does it do something like the above?
04:36:28 <LeCamarade> Are there pointers*? Does it perform well?
04:38:02 <therp> ok, this is a kinda tricky question. assuming I have a type a, with its respective transformer a -> a. Assume I have a set of transformers [t1, t2, t3] that have this type and they are chained in a way like t0 = (t1 (t2 (t3 obj))). In fact, t1, t2, t3 are partially applied functions to arbitrary other types b. (so t1 t2 t3, are b1 -> a -> a, b2 -> a -> a, b3 -> a -> a, and so on..). any tricks on how to exchange any of these trans
04:38:02 <therp> formers t1,t2.. with some other version partially applied to their b1, b2,.. types without knowning these types, perferably only by holding an object similar to t0.
04:38:26 <dons> ?src Eq []
04:38:27 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:38:29 <dons> ?src [] Eq
04:38:29 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:38:33 <dons> ?src [a] Eq
04:38:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:38:36 <dons> bah
04:38:47 <dons> LeCamarade: == on [a] is the obvious impl.
04:39:57 <LeCamarade> Hm.
04:40:56 <szabi_> quicksilver: could you point me directly to the place where typeclasses are used to help default parameters in HSH? I can't find what you were referring to...
04:41:34 <quicksilver> therp: that depends what you mean by 'exchange'
04:42:35 <quicksilver> szabi_: http://software.complete.org/hsh/static/doc/HSH-Command.html
04:42:39 <therp> quicksilver: so that t0 is formed by (t1 (new_t2 (t3 obj))
04:42:59 <quicksilver> szabi_: I refer to the way he uses the typeclass 'ShellCommand'
04:43:14 <quicksilver> szabi_: this is isomoprhic to the idea of having 'multiple different signatures'
04:43:23 <quicksilver> i.e. 'multiple different argument types'
04:43:31 <quicksilver> which is the general case of optional arguments
04:44:01 <LeCamarade> @qont Levenshien -> quote?
04:44:02 <quicksilver> RunResult is the opposite trick: it's for multiple return types
04:44:02 <lambdabot> Not enough privileges
04:44:26 <LeCamarade> @qont hex
04:44:26 <lambdabot> Not enough privileges
04:44:31 <quicksilver> therp: well if you really want it to be a value t0 (t1 (t2 (t3 x)))
04:44:35 <quicksilver> therp: that's not possible
04:44:45 <quicksilver> therp: because the value, once formed, can't be deconstructed in haskell\
04:44:45 <LeCamarade> @quite hex
04:44:46 <lambdabot> Maybe you meant: quit quote
04:44:53 <quicksilver> (you could deconstruct it in TH, of course)
04:44:57 <therp> quicksilver: no, doesn't have to be.. could be a list that foldr's t0.
04:45:01 * quicksilver nods
04:45:09 <quicksilver> well if it's a list, that's obviously more tractable
04:45:11 <SamB_XP_> @fact hex
04:45:12 <lambdabot> hex: 09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0
04:45:17 <quicksilver> but then you have to decide the issue of how to decide equality
04:45:23 <quicksilver> how will you know which element 'is' t2?
04:45:24 <SamB_XP_> @fax hex
04:45:24 <lambdabot> The answer is: Yes! Haskell can do that.
04:45:32 <LeCamarade> @quote hex
04:45:32 <lambdabot> hex says: 09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0
04:45:44 <LeCamarade> @quote tm
04:45:45 <lambdabot> tm says: Miranda (tm) is a trademark of Research Software
04:46:38 <SamB_XP_> @quote .* miranda
04:46:39 <lambdabot> No quotes for this person. Where did you learn to type?
04:47:30 <quicksilver> therp: depending on your application, I'd suggest either you identify by position (replace 3rd transformer from the left with t_new)
04:47:40 <quicksilver> therp: or you tag the values with 'names' in some sense
04:47:55 <quicksilver> therp: and you replace by name
04:49:17 <therp> quicksilver: my problem is the transformation process itself and the types.. I want a clean functional program
04:49:32 <therp> That's the first time I feel restricted by typing
05:01:20 <kfish> http://tapas.affenbande.org/wordpress/?page_id=71
05:01:22 <lambdabot> Title: ugha! » LaTeX-Preview
05:01:32 * kfish wants LaTeX-ghci
05:26:34 <ndm> dons: so can i send xmonad patches to make that file H98?
05:26:41 <ndm> dons: and if so, where
05:29:18 <BRS_Runaro> @quote XML
05:29:19 <lambdabot> mwc says: XML is like violence. If it doesn't work, use more.
05:29:39 <therp> lol :)
05:29:45 <BRS_Runaro> @quote XML
05:29:45 <lambdabot> mwc says: XML is like violence. If it doesn't work, use more.
05:29:54 <BRS_Runaro> aww
05:38:30 <dons> ndm, maybe. and xmonad@haskell.org
05:38:38 <dons> ndm, subscribe via xmonad.org, the site
05:38:45 <ndm> dons: subscribed and sent already
05:39:21 <quicksilver> ndm: pattern guards are a conservative and useful extension to H98
05:39:29 <dons> ndm, .gz patch?
05:39:35 <ndm> quicksilver: agreed, i love them, and they don't work with Yhc
05:39:41 <dons> ndm, is it possible to darcs send plain text?
05:39:53 <ndm> dons: yeah, otherwise windows can inadvertantly change the line enedings, this is safer
05:40:02 <dons> urgh. scary. ok. thanks!
05:40:05 <quicksilver> ndm: in principle they are easy to implement. In practice I have no idea what yhc is like inside :)
05:40:15 <ndm> dons: no, darcs send is 100% broken with windows - esa has a patch but they've never accepted it from him :(
05:40:28 <ndm> quicksilver: malcolm tried, malcolm failed, thats enough to make me know i'd fail
05:40:30 <dons> maybe you should make some more noise.
05:40:41 <dons> ndm, if you reply to your xmonad@ patch, david r will read it.
05:40:43 <quicksilver> ndm: they can't accept the patch, because the line endings were garbled :)
05:40:44 <ndm> dons: i use gmail, its never going to work with that, so i gave up
05:42:02 <malcolmw> pattern guards are cool - but I didn't actually try to implement them yet
05:42:35 <dons> ndm, was that the only non-h98 in StackSet?
05:42:58 <Knuckles> hello
05:43:00 <ndm> dons: yep, plus yhc is choking on a Num context with bad defaulting rules
05:43:09 <dons> ah ok. otherwise. good.
05:43:10 <ndm> dons: i will try and fix that, but malcolmw may know more
05:43:18 <Knuckles> can someone explain me the accumulators, on an example... i want to transforme this function with the use of an accumulator
05:43:28 <Knuckles> sommeLignes :: [[Integer]]->[Integer]
05:43:29 <Knuckles> sommeLignes [] = []
05:43:29 <Knuckles> sommeLignes (x:l) = (sum x) : (sommeLignes l)
05:43:32 <Knuckles> i tried that
05:43:47 <Knuckles> sommeLignes2 :: [[Integer]]->[Integer]->[Integer]
05:43:47 <Knuckles> sommeLignes2 [] acc = acc
05:43:47 <Knuckles> sommeLignes2 (x:l) acc = sommeLignes2 l (acc+x)
05:43:52 <malcolmw> ndm: dons: what failing  example are you talking about?
05:43:55 <Knuckles> but that doesn't work
05:44:09 <Knuckles> i think i haven't totally understood the accumulators
05:44:13 <Knuckles> can someone explain to me?
05:44:22 <ndm> @hpaste
05:44:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:44:52 <hpaste>  ndm pasted "XMonad Num error" at http://hpaste.org/1755
05:45:04 <ndm> malcolmw: ^^^, i've ||| around the bit the error refers to
05:45:14 <dons> ok. this is just freaky. http://worrydream.com/AlligatorEggs/
05:45:15 <lambdabot> Title: Alligator Eggs!
05:45:19 <dons> lambda calculus as alligators.
05:46:16 <Knuckles> does someone use accumulators here?
05:46:49 <malcolmw> ndm: oh, that's simple to fix.  let (a,b) = foo    becomes   let { ab = foo; a = fst ab; b = snd ab }
05:47:09 <ehird`> dons: hahahaha
05:47:14 <dons> Knuckles: hmm. what's the problem? ah I see. your type for sommeLignes2 is wrong.
05:47:22 * ndm notes thats also slightly more efficient in this particular case
05:47:33 <dons> Knuckles: you're returning acc in the base case.
05:47:46 <dons> meaning the return type can't be [Integer], since you use (acc+x) ?
05:48:00 <dons> maybe you meant (sum x : acc) ?
05:48:31 <ndm> dons: will you accept a patch entitled "Yhc sucks at defaulting" ?
05:48:52 <ndm> which makes the code 2 lines longer, for Yhc's benefit?
05:48:53 <Knuckles> I didn't understand the type for an acc
05:49:02 <Knuckles> because in my lessons, we used simple list
05:49:03 <dons> ndm. hmm. why? its not like the rest of xmonad will run in Yhc.
05:49:07 <Knuckles> and i use list of lists
05:49:11 <dons> ndm, the problem of Xlib and all.
05:49:13 <ndm> dons: that makes it run in Catch
05:49:21 <dons> but for the purposes of Catch, i'll maintain a small branch :-)
05:49:27 <dons> so please send the patches, I'll use them.
05:49:32 <ndm> dons: plus it is also required for nhc, which may feasibly work
05:49:35 <dons> if it turns out to be really useful, I'll merge them in.
05:49:50 <ndm> ok, i'll accumulate catch patches and send them in one batch
05:49:57 <dons> yeah, that's best.
05:49:58 <ndm> i'll let you do branch management stuff :)
05:50:18 <dons> right.
05:50:34 <Knuckles> sommeLignes2 :: [[Integer]]->[Integer]->[Integer]
05:50:34 <Knuckles> sommeLignes2 [] acc = acc
05:50:34 <Knuckles> sommeLignes2 (x:l) acc = sommeLignes2 l (sum x:acc)
05:50:35 <szabi_> how can I convert a string to int? ("1" -> 1)
05:50:43 <Knuckles> sommeLignes2 :: [[Integer]]->[Integer]->[Integer]
05:50:43 <Knuckles> sommeLignes2 [] acc = acc
05:50:43 <Knuckles> sommeLignes2 (x:l) acc = sommeLignes2 l (sum x:acc)
05:50:51 <Knuckles> sommeLignes2 :: [[Integer]]->[Integer]->[Integer]
05:50:51 <Knuckles> sommeLignes2 [] acc = acc
05:50:51 <Knuckles> sommeLignes2 (x:l) acc = sommeLignes2 l (sum x:acc)
05:50:53 <Knuckles> oh
05:50:54 <Knuckles> sorry
05:50:57 <dons> > read "1" :: Int
05:50:58 <lambdabot>  1
05:51:07 <szabi_> thanks
05:51:20 <Knuckles> <interactive>:1:0:
05:51:21 <Knuckles>     No instance for (Show ([Integer] -> [Integer]))
05:51:21 <Knuckles>       arising from use of `print' at <interactive>:1:0-13
05:51:21 <Knuckles>     Possible fix:
05:51:21 <Knuckles>       add an instance declaration for (Show ([Integer] -> [Integer]))
05:51:21 <Knuckles>     In the expression: print it
05:51:23 <Knuckles>     In a 'do' expression: print it
05:51:25 <Knuckles> *Main>
05:51:27 <dons> Knuckles: use hpaste :)
05:51:27 <Knuckles> i have this error
05:51:35 <Knuckles> oki
05:51:55 <dons> ?paste <--
05:51:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:52:11 <Knuckles> i don't understand the error
05:54:28 <Cheery> I'm getting the feeling I'd like to make programming languages make use from the width of current displays
05:55:58 <Knuckles> dons,  do you have an idea for my problem?
05:56:05 <bluecell> Imagine buying cheeses :) (yep, cheeses). Now, every cheese has its own weight. We need a specific sum of weight.
05:56:05 <bluecell> SearchCheeses :: Int -> [Int] -> [[Int]]
05:56:05 <bluecell> SearchCheeses (sumofweigth weightofcheeses) needs to give all possible combinations. How would you do this?
05:59:09 <LoganCapaldo> I presume you can't use a given cheese more than once?
05:59:48 <quicksilver> beelsebob: you'd just map (sumofweight weightofcheeses) over the cheese
05:59:48 <LoganCapaldo> (In a given combo that is0
05:59:52 <bluecell> indeed
06:00:03 <quicksilver> beelsebob: well it depends what 'all possible combinations means'
06:00:08 <timlarson_> Cheery, how do you mean? 2D instead of linear?
06:00:30 <quicksilver> > [ (a,b) | a <- [1,2,3] ; b <- [90,91,92] ]
06:00:31 <lambdabot>  Parse error
06:00:36 <quicksilver> > [ (a,b) | a <- [1,2,3] , b <- [90,91,92] ]
06:00:40 <Cheery> no, like code would automatically span lines, structure by itself into the best possible form
06:00:42 <lambdabot>  [(1,90),(1,91),(1,92),(2,90),(2,91),(2,92),(3,90),(3,91),(3,92)]
06:00:57 <quicksilver> bluecell: that is one meaning of 'all possible combinations'
06:01:03 <timlarson_> an advanced form of the "indent" program?
06:01:08 <Cheery> yes
06:01:10 <Cheery> sort of
06:01:30 <LoganCapaldo> I imagine its supposed to look like f 3 [1,3,2] --> [[1,2], [3]]
06:01:33 <Cheery> and use double column view for do -blocks when appropriate
06:01:40 <Cheery> or triple column, or quad column
06:01:54 <beelsebob> quicksilver: o.O
06:01:58 <beelsebob> pardon?
06:02:00 <bluecell> uhm...
06:02:09 <bluecell> let me construct a sample output
06:02:55 <timlarson_> makes sense, code that flows to naturally fit the page the most pleasing/logical way.
06:03:43 <Cheery> I think it should be done so that it's backwards compatible with the most common 80-line -sheet
06:04:05 <bluecell> SearchCheeses 5 [1,2,3,4,5] ---> [[1,4],[2,3],[3,2],[4,1],[5]]
06:05:56 <quicksilver> > let l = [1,2,3,4,5] in [[a,b] | a <- l, b <- l, a+b == 5]
06:05:58 <lambdabot>  [[1,4],[2,3],[3,2],[4,1]]
06:07:02 <tibbe> bluecell, an inefficient way to do it would be to create all combinations and then do a filter
06:07:05 <quicksilver> not quite what you want because it's only lists of length 2
06:07:20 <quicksilver> and it will actually include repeated entries like [2,2]
06:07:23 <quicksilver> which you apparently don't want?
06:07:30 <quicksilver> (it's just 5 is an odd number so you don't see any)
06:08:11 <beelsebob> what's the challenge here?
06:08:24 <quicksilver> beelsebob: I don't know, yes :)
06:08:33 <beelsebob> ????
06:08:34 <beelsebob> wtf!
06:08:37 <quicksilver> beelsebob: I think it might be 'all subsets of a list which satisfy a predicate'
06:08:44 <beelsebob> quicksilver: okay
06:09:06 <beelsebob> > filter p (perms l)
06:09:07 <lambdabot>   Not in scope: `l'
06:09:16 <beelsebob> silly lambdabot I was being rhetorical!
06:09:40 <quicksilver> > let power [] = []; power (x:xs) = power xs ++ (map (x:) power xs) in [ m <- power [1,2,3,4,5] | sum m == 5 ]
06:09:41 <lambdabot>  Parse error
06:09:54 <quicksilver> > let {power [] = []; power (x:xs) = power xs ++ (map (x:) power xs)} in [ m <- power [1,2,3,4,5] | sum m == 5 ]
06:09:54 <lambdabot>  Parse error
06:10:01 <beelsebob> yeh, I meant power, not perms
06:10:26 <LoganCapaldo> @index power
06:10:27 <lambdabot> bzzt
06:10:41 <beelsebob> > let power [] = []; power (x:xs) = power xs ++ (map (x:) power xs)}in [ m <- power [1,2,3,4,5] | sum m == 5 ]
06:10:43 <beelsebob>  fail
06:10:44 <LoganCapaldo> > power [1,2,3,4]
06:10:45 <lambdabot>   Not in scope: `power'
06:10:50 <LoganCapaldo> oh ok
06:11:07 <ndm> beelsebob: know whats happening yet with papers and thesises?
06:11:16 <beelsebob> > let power [] = []; power (x:xs) = power xs ++ (map (x:) power xs) in filter ((==5) . sum) (power [1,2,3,4,5]
06:11:16 <lambdabot>  Parse error
06:11:26 <beelsebob> ndm: nope, waiting on Bernie publishing
06:11:44 <beelsebob> > let power [] = []; power (x:xs) = power xs ++ (map (x:) power xs) in filter ((==5) . sum) (power [1,2,3,4,5])
06:11:46 <lambdabot>  Couldn't match expected type `[[t]]'
06:11:48 <quicksilver> > let {power [] = [[]]; power (x:xs) = power xs ++ (map (x:) (power xs))} in [ m | m <- power [1,2,3,4,5] , sum m == 5]
06:11:50 <lambdabot>  [[5],[2,3],[1,4]]
06:11:53 <beelsebob> ah yes
06:11:53 <quicksilver> I win!
06:12:01 <quicksilver> although it's order-independent this time :)
06:12:05 <beelsebob> > let power [] = [[]]; power (x:xs) = power xs ++ (map (x:) power xs) in filter ((==5) . sum) (power [1,2,3,4,5])
06:12:06 <lambdabot>  Couldn't match expected type `[[t]]'
06:12:09 <beelsebob> bah
06:12:24 <quicksilver> of course, bluecell has quite anyway
06:12:31 <quicksilver> but I've learnt something, so it's not wasted :)
06:12:35 <beelsebob> hehe
06:13:18 <tibbe> bah, missing a map?
06:13:30 <tibbe> beelsebob, ^
06:13:43 <beelsebob> tibbe: where?
06:13:43 <quicksilver> @pl \x -> x ++ (map (1:) x)
06:13:44 <lambdabot> ap (++) (map (1 :))
06:13:58 <tibbe> beelsebob, you're trying to sum sublists right?
06:14:01 <bluecell> back... damn... I had some internet troubles
06:14:10 <beelsebob> tibbe: uhhuh?
06:14:10 <tibbe> beelsebob, nevermind xD
06:14:20 <quicksilver> > let {power [] = [[]]; power (x:xs) = ap (++) (map (x:)) (power xs)} in [ m | m <- power [1,2,3,4,5] , sum m == 5]
06:14:20 <beelsebob> k
06:14:22 <lambdabot>  [[5],[2,3],[1,4]]
06:14:24 * beelsebob is confused today
06:14:27 <quicksilver> now with extra obfuscation!
06:14:42 <LoganCapaldo> can never have too much obfuscation
06:15:06 <beelsebob> > let {power [] = [[]]; power (x:xs) = power xs ++ (map (x:) (power xs))} in filter ((==5) . sum) (power [1,2,3,4,5])
06:15:10 <lambdabot>  [[5],[2,3],[1,4]]
06:15:17 <quicksilver> of course that does in some sense 'try every possibility'
06:15:26 <quicksilver> although it's not wasteful enough to construct them all in memory at once
06:15:31 <quicksilver> but it's still running through them
06:15:42 <quicksilver> so it's exponential in the size of the list
06:15:54 <beelsebob> *considers*
06:15:55 <quicksilver> to do better you need to adapt the algorithm to the precise problem at hand, though
06:16:07 <beelsebob> I think that this problem is exponential by definition
06:16:11 <quicksilver> (that is, you 'prune' the branches as soon as you see that sum > 5)
06:16:14 <tibbe> subset sum?
06:16:22 <quicksilver> beelsebob: not with branch pruning it isn't
06:16:30 <LoganCapaldo> > map (5 -) [1,2,3,4,5]
06:16:32 <lambdabot>  [4,3,2,1,0]
06:16:35 <beelsebob> quicksilver: why not?
06:16:44 <beelsebob> surely it's still exponential, just not badly
06:16:50 * quicksilver shakes his head
06:16:59 <quicksilver> consider [1..99]
06:17:01 * beelsebob tries to think of why
06:17:07 <quicksilver> 94 of the subforests are cut off at the first step
06:17:08 <bluecell> what about making it a "binary search algo"??
06:17:08 <tibbe> it's NP right?
06:17:13 <beelsebob> yep
06:17:14 <quicksilver> so you get no exponential explosion
06:17:19 <quicksilver> (if sum is fixed at 5)
06:17:25 <beelsebob> but you still need to do the exponential search in the first 5
06:17:32 <quicksilver> that's exp(5), though
06:17:34 <quicksilver> not exp(n)
06:17:35 <LoganCapaldo> quicksilver: but doens't thaqt only apply if your list is sorted?
06:17:40 <quicksilver> so the problem isn't exponential :)
06:17:48 <quicksilver> exp(5) is a constant
06:17:52 <quicksilver> the problem becomes linear
06:17:59 <beelsebob> quicksilver: consider [1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,4,3,2,1,2,3,4,5,3]
06:17:59 <tibbe> if the universe is finite all algorithms run in O(k) for some constant k
06:18:09 <quicksilver> beelsebob: for that kind of list it would be exponential, yes
06:18:09 <beelsebob> it's sill exponential in the size of that list
06:18:15 <beelsebob> remember, we're talking worst case
06:18:15 <quicksilver> beelsebob: it depends on the kind of list
06:18:18 <beelsebob> not best case
06:18:25 <quicksilver> beelsebob: no, we're talking about specific cases
06:18:33 <quicksilver> beelsebob: if I tell you that list never occurs, then I'm right
06:18:44 <beelsebob> well, in terms of the complexity of the algorithm it's traditional to consider the worst case
06:18:46 <quicksilver> I never promised I was writing a function over all of [Int[
06:18:53 <quicksilver> beelsebob: but not to consider a case which never occurs
06:18:56 <beelsebob> it's O(x^n) o(x^5)
06:19:01 <osfameron> tibbe: so it suffices to find an algorithm that doesn't run O(k) for some k to prove that the universe is infinite!
06:19:10 <tibbe> osfameron, !!!
06:19:10 <quicksilver> suppose a constraint is that no item occurs twice, for example
06:19:13 <quicksilver> and all items are >0
06:19:31 <beelsebob> makes enough sense -- I hadn't seen any evidence that the case I illustrated would never occur
06:19:35 <tibbe> cheeeese 5 [[5]]
06:19:40 <tibbe> constant time
06:20:14 * LoganCapaldo thinks its entirely possible to have two different cheeses weight the same
06:20:54 <osfameron> what's the half life of cheese?
06:21:01 <quicksilver> beelsebob: acutally, it's still not exponential
06:21:05 <quicksilver> beelsebob: in your example
06:21:09 <beelsebob> quicksilver: why not?
06:21:16 <bluecell> how would this example look like if we were to use a binary search backtracking algorythm?
06:21:17 <quicksilver> beelsebob: assuming the total weight constant
06:21:26 <beelsebob> oh yeh
06:21:33 <quicksilver> beelsebob: then there is some 'average number' of cheese which reaches that weight
06:21:34 <beelsebob> you get to a maximum of <weight> additions
06:21:41 <beelsebob> so it's quadratic in the maximum weight
06:21:42 <quicksilver> so it's probably roughly a fixed poly
06:21:56 <lypanov> vital is very cool
06:22:01 <tibbe> what happens if we melt all the cheese? couldn't we use a greedy algorithm then?
06:22:01 <quicksilver> still, it's very slow :)
06:22:07 <beelsebob> tibbe: :P
06:22:19 <bluecell> :P
06:22:24 <beelsebob> quicksilver: I don't think it's possible to have a very fast algorithm here :P
06:22:52 <Cheery> does haskell have character escape of some sort?
06:22:53 <quicksilver> beelsebob: indeed :)
06:23:22 <tibbe> Cheery, what do you mean?
06:23:40 <Cheery> like, allowing whitespaces in name: blah\ guux
06:23:53 <Cheery> just to consider whether I need to care about it. ;)
06:24:14 <tibbe> Cheery, not that I know of, check the Haskell 98 report ;)
06:24:21 <Cheery> excellent
06:24:22 <Cheery> :)
06:24:29 <quicksilver> I believe it does not
06:24:41 <Cheery> that fucks up the variable names, etc.
06:24:46 <quicksilver> however with unicode source files, the rules about what is allowed in identifiers are more coplex
06:24:54 <quicksilver> I don't think that's H98 though
06:29:42 <hpaste>  szabi_ pasted "xml sample" at http://hpaste.org/1756
06:30:00 <szabi_> anyone care to help me extract some info from this xml?
06:30:23 <szabi_> I have looked into HaXml, but I have no idea how the hell could I use it :)
06:30:56 <szabi_> I'm mainly interested in the X, Y and Descriptor values
06:31:13 <malcolmw> szabi_: what do you want to do with the values once you get them?
06:31:16 <szabi_> or do you have any sample code?
06:31:30 <therp> szabi: well, I have my code to read google geocoding
06:31:35 <therp> szabi: but it should give you an idea
06:32:07 <szabi_> malcolmw: umm. these values are extracted from images. I want to find the transformation between them, etc...
06:32:36 <szabi_> malcolmw: so I have to do a lot of calculations. I don't want to transfrom the xml. Just get the values
06:32:41 <malcolmw> xtract "//Arr/KeypointN/X"
06:32:56 <szabi_> thedatabase: that would be a lot of help
06:33:14 <szabi_> therp: that would be lot of help
06:34:24 <hpaste>  clemens annotated "xml sample" with "geocode xml reader" at http://hpaste.org/1756#a1
06:35:03 <therp> oh what a clever hack of mine to read 3 doubles at once.
06:35:41 <dcoutts_> therp: mm?
06:35:58 <therp> read ("(" ++ show (content c) ++ ")") :: (Double, Double, Double)
06:36:04 <therp> (content c) =  3,4,1
06:36:18 * dcoutts_ is currently writing code for binary serialisation of float & double
06:40:31 <ndm> dons: StackSet has quite a lot of holes in it - you often use head/tail, which is relying that hte user won't screw with a StackSet object
06:42:17 <BRS_Runaro> @unpl pl
06:42:18 <lambdabot> pl
06:43:19 <chessguy> @. unpl pl \x y -> x + y
06:43:19 <lambdabot> (+)
06:43:34 <chessguy> @unpl (+)
06:43:34 <lambdabot> (+)
06:43:56 <assl0r> hi
06:44:06 <assl0r> http://hpaste.org/1753#a2 whats wrong in here?
06:45:27 <dons> ndm, great! feel free  to send a summary to xmonad@
06:45:31 <BRS_Runaro> @pl \a b c d -> a b (c d)
06:45:32 <lambdabot> ((.) .)
06:45:36 <ndm> dons: just doing so
06:45:51 <dons> ndm, i'm off on vacation for a week, so if you just talk to sjanssen about it, he would be the best point to get code changed.
06:45:55 <assl0r> i pass a 2 dimensional list, but getting an "empty argument" exception...
06:46:07 <ndm> dons: cool, have fun relaxing
06:46:13 <dons> ndm, i'll have a look at any suggestions you send in the next 12 hrs, though.
06:46:19 <dons> give me something to ponder on the beach
06:46:26 <dons> that, and rewriting xmonad to use a zipper instead
06:46:42 <ndm> dons: cool, should be at your inbox within half an hour
06:47:09 <dons> ndm++ thanks.
06:47:36 <dons> ndm, also, feel free to drop by #xmonad if you want to talk about the code during the week
06:47:43 <ndm> dons: cool
06:47:46 <dons> sjanssen and jcreigh and davidr are usually there.
06:49:18 <kpreid> assl0r: assuming the third code block expo recurses over its list and dies on the base case
06:49:28 <kpreid> s/block expo/block, expo/
06:49:58 <assl0r> but it never touches the third block
06:50:17 <assl0r> dies on the base condition directly
06:50:26 <assl0r> but why?!
06:50:54 <kpreid> perhaps it's evaluating the right side of the ^ before the left
06:51:01 <kpreid> then your trace never happens
06:51:51 <assl0r> doesn't the haskell interpreter goes from left to right, doesn't it?
06:52:44 <dcoutts_> assl0r: evaluation order is data dependent, not left to right or anything that simple
06:53:21 <kpreid> that ^ will be strict but I don't think there's anything that requires an ordering
06:53:45 <kpreid> just put the trace around the whole expression
06:53:52 <hpaste>  malcolmw annotated "xml sample" with "another way of doing it" at http://hpaste.org/1756#a2
06:54:00 <kpreid> right now it's around only 'fromIntegral'
06:59:03 <assl0r> ah i got it
06:59:09 <assl0r> the base condition was wrong
07:01:40 <shapr> Yay! Alligators!
07:02:01 <dylan> mmm, alligator jerky.
07:02:56 <syntaxfree> ?get-shap
07:02:57 <lambdabot> shapr!!
07:03:44 <lypanov> SHAPRRRRR
07:03:46 <lypanov> etc
07:04:18 <tapi> hi
07:05:03 <ndm> dons: sent off to the list
07:05:08 <tapi> could someone tell me why the following doesn't work ? i really can't figure it out by myself... -> http://www.syskall.net/~tapi/test.hs
07:06:01 <tapi> it seems incredibly simple, but it doesn't output anything :|
07:06:33 <Igloo> Because you haven't actually read the file before you close it, due to lazy IO
07:07:01 <Igloo> evaluate (length file) before hClose h should fix it
07:07:21 <tapi> ouch... ok thx a lot :)
07:08:14 <tapi> swaping the last two lines should make it work too, i suppose
07:08:30 <tapi> yes.
07:10:25 <tapi> Igloo: does hPutStr happen to be lazy IO too ? do i have a risk of corrupted data when writing something to a file ? that would be weird...
07:11:12 <Igloo> No
07:11:20 <Igloo> Well, apart from buffering
07:11:35 <tapi> ok, thanks a lot
07:15:58 <shapr> hiya lypanov!
07:18:24 <Nafai> Hi shapr!
07:18:38 <joelr1> @pl f x = Z (f1 x)
07:18:39 <lambdabot> f = Z . f1
07:19:38 <joelr1> hiya shapr
07:21:13 <joelr1> @pl iff x y = If x (Compound y) Skip
07:21:14 <lambdabot> iff = flip flip Skip . (. Compound) . If
07:21:17 <joelr1> hmm
07:25:32 <assl0r> is it forbidden to use if statements in a let ... in expression?
07:25:48 <assl0r> let foo = bar in if foo then ..
07:25:56 <kolmodin> dcoutts_: will double/float be ieee compatible?
07:26:34 <Igloo> assl0r: Yes
07:26:47 <joelr1> @pl mc x = MethCall (Obj (var x))
07:26:47 <lambdabot> mc = MethCall . Obj . var
07:29:30 <dcoutts_> kolmodin: yes.
07:29:30 <dcoutts_> kolmodin: though quite how we do that on non-ieee platforms... :-)
07:32:54 <BRS_Runaro> @pl f a b c d = a b (c d)
07:32:54 <lambdabot> f = ((.) .)
07:33:36 <BRS_Runaro> @pl f a b c d = a (b c) d
07:33:37 <lambdabot> f = (.)
07:35:05 <BRS_Runaro> @pl (.) a b c d
07:35:06 <lambdabot> a (b c) d
07:37:21 <BRS_Runaro> @unpl (.)
07:37:22 <lambdabot> (\ a b c -> a (b c))
07:38:00 <kpreid> okay, I think it's time to take "unpl" off my notification list
07:38:18 <BRS_Runaro> Sorry about ath.
07:38:19 <BRS_Runaro> that
07:38:43 <kpreid> nothing your fault
07:38:52 <BRS_Runaro> Lambdabot rocks.
07:40:16 <osfameron> how do @pl and @unpl work?  Do they interface with a haskell parser?  Or reparse it and manipulate themselves?
07:40:45 <chessguy> @help pl
07:40:46 <lambdabot> pointless <expr>. Play with pointfree code.
07:40:49 <shapr> hi Nafai
07:40:52 <shapr> hi joelr1
07:40:52 <chessguy> so descriptive
07:40:54 * shapr boings
07:41:00 <chessguy> @get-slap
07:41:00 <lambdabot> shapr!!
07:41:45 <twanvl> I think pl uses a custom parser, and unpl uses Language.Haskell
07:41:45 <kolmodin> dcoutts_: well yeah... non-ieee platforms are silly anyway
07:41:50 <kpreid> osfameron: unpl works on Language.Haskell.Syntax trees
07:42:14 <dcoutts_> kolmodin: tell that to the embedded devs, don't you want Haskell on your phone? :-)
07:42:39 <kolmodin> dcoutts_: hm... :)
07:42:42 <kolmodin> yes I do :D
07:42:42 <chessguy> now that would be cool
07:43:03 <chessguy> unsafePerformRingtone
07:43:05 <osfameron> ah, there's a standard library, nice
07:43:07 <kolmodin> dcoutts_: well they simply have to be careful about double/float on those devices though
07:43:17 <osfameron> why does pl use a custom one?  just hysterical raisins?
07:43:22 <dcoutts_> you can already run ghc on a nokia 770/800
07:43:32 <kolmodin> dcoutts_: will you simply leave out those instances for non-ieee platforms?
07:43:45 <kolmodin> dcoutts_: ghc, or was it yhc?
07:43:55 <dcoutts_> kolmodin: ghc I think. It builds on arm.
07:44:01 <kolmodin> ok
07:44:01 <dcoutts_> kolmodin: we'll try make it a build error until someone fixes it.
07:44:05 * joelr1 wonders how long it takes to build ghc on the nokia 770/800
07:44:10 <osfameron> dcoutts_: ooo!  how?
07:44:21 <Igloo> Why are people making phones with non-IEEE floats?
07:44:32 <kolmodin> dcoutts_: ok. but they will miss out on functionality then. other stuff will still work :/
07:44:32 <dcoutts_> osfameron: debian have arm packages for ghc I believe.
07:44:34 <osfameron> I thought you needed ghc to build ghc ?
07:44:42 <osfameron> oh!  cute
07:44:47 <dcoutts_> Igloo: cheaper
07:44:51 <dcoutts_> lower power
07:44:57 <LeCamarade> joelr1: Did you just say you have a port of Haskell for a Nokia.
07:45:00 <LeCamarade> ?
07:45:07 <Igloo> dcoutts_: Do you mean no floats, or different floats?
07:45:11 <LeCamarade> s/\./?/
07:45:27 <joelr1> LeCamarade: i did not but dcoutts did
07:45:27 <dcoutts_> Igloo: I think quite a few arm have no hardware floating point and the software impl uses a simpler format than ieee
07:45:49 <Igloo> hmm, OK
07:45:57 <LeCamarade> dcoutts: Haskell _on the Nokia_? Is this some perverse dream I am having?
07:46:09 <joelr1> i want a leg processor architecture, to be coupled with the arm
07:46:27 <BRS_Runaro> crikey, it's got me arm!
07:46:29 <LeCamarade> joelr1: :oD
07:46:44 <dcoutts_> LeCamarade: the nokia 770/800 is a linux mobile pc
07:46:55 <dcoutts_> hia bringert
07:47:04 <bringert> hi dcoutts_
07:47:04 <lambdabot> bringert: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:47:26 <dcoutts_> LeCamarade: it's not a tiny mobile phone, so you can build most ordinary stuff for it
07:48:09 <bringert> dcoutts, re QC/QC2: I don't know what answer to give
07:48:37 <dcoutts_> bringert: normal problem of not enough dev time I presume
07:48:46 <bringert> yep
07:49:24 <dcoutts_> bringert: the QC2 code is available somewhere I presume so if we had a volunteer... ?
07:49:24 <LeCamarade> dcoutts_: Seen it. Phew. I thought I was going to start losing sleep again. And coding on the bus is just not healthy.
07:51:27 <kolmodin> dcoutts_, bringert: wrt?
07:51:52 <dcoutts_> kolmodin: I was wondering if we should be improving QC1 or waiting for QC2
07:51:59 <kolmodin> right
07:52:07 <dcoutts_> kolmodin: since every time I've ever used QC1 I've had to add missing bits
07:52:16 <kolmodin> I thought QC2 was already finished but not proprely distributed/used
07:52:24 <dcoutts_> which is why I asked
07:52:30 <kolmodin> right
07:52:50 <dcoutts_> if QC2 is going to be out soon then there's no point improving QC1
07:52:55 <kolmodin> aye
07:53:37 <bringert> dcoutts, QC2 repo is here for now http://www.cs.chalmers.se/~bringert/darcs/QuickCheck/
07:53:40 <lambdabot> Title: Index of /~bringert/darcs/QuickCheck
07:54:00 <bringert> dcoutts, I think it just needs a bit of cleaning up, documenting etc
07:54:31 <bringert> dcoutts: I'll go see if koen is here
07:54:37 <bringert> bbiab
07:55:30 <bringert> he was busy
07:55:57 <bringert> dcoutts: anyway, I think working on QC2 would be better
07:56:04 <dcoutts_> bringert: right.
07:56:47 <shapr> oh, what's the discussion?
07:56:56 <bringert> dcoutts, feel free to contribute improvements
07:57:13 <dcoutts_> bringert: I'd like to make Gen an instance of Applicative
07:57:33 <dcoutts_> bringert: instances look very neat that way: Constructor <$> arbitrary <*> arbitrary
07:57:46 <dcoutts_> rather than: liftM2 Constructor arbitrary arbitrary
07:57:49 <bringert> dcoutts: nice
07:58:06 <bringert> dcoutts, I'll talk to koen and see if he'd be ok with putting QC2 on darcs.haskell.org. that should speed up development.
07:58:13 <dcoutts_> indeed
07:58:27 <dcoutts_> and have the web page that the .cabal file refers to exist :-)
07:58:41 <bringert> hmm
07:58:54 <dcoutts_> perhaps it should just refer to a wiki page if nobody has time to do any other kind of website
07:59:03 <bringert> I wrote that cabal file I think
07:59:15 <dcoutts_> Homepage: http://www.haskell.org/QuickCheck/
07:59:21 <bringert> yeah
07:59:26 <bringert> dunno where that comes from
07:59:48 <dcoutts_> probably wishful thinking :-)
08:00:19 <bringert> Fri Nov 17 16:22:30 CET 2006  bringert@cs.chalmers.se
08:00:20 <bringert>   * Added Cabal build system.
08:00:36 <bringert> maybe that page has existed at some point?
08:00:43 <hpaste>  assl0r pasted "(no title)" at http://hpaste.org/1757
08:01:13 <assl0r> how do i handle missing elements in the x:y:...:xs syntax?
08:01:54 <dcoutts_> bringert: a colleague today suggested that it would have been helpful if the Gen monad's fail method did something useful. He was trying to generate ASTs and sometimes found he had to abandon the generation of test cases. He hacked it so it was an error monad and failed test cases were ignored.
08:02:02 <emu> lambdabot is trying to hack me
08:02:14 <ari> assl0r: An empty list would be [], a list with one element x:[], two elements x:y:[], etc.
08:02:31 <assl0r> ari: yeah i know that already
08:02:48 <ari> ... good point, I didn't notice the context *goes to read the paste*
08:02:57 <assl0r> the algorithms works, if all lists have the same length
08:03:05 <bringert> dcoutts: sounds reasonable
08:03:07 <assl0r> -s
08:04:56 <assl0r> if elements are missing, i want to simply skip them
08:06:20 <ari> @src zipWith
08:06:20 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
08:06:20 <lambdabot> zipWith _ _      _      = []
08:06:28 <dcoutts_> bringert: want me to put that current code on darcs.haskell.org/QuickCheck/ ?
08:07:56 <bringert> dcoutts: is that based on QC2?
08:08:02 <nominolo> what is the idiom to convert string literals to ByteStrings?
08:08:21 <nominolo>  pack (map toOrd "foo") ?
08:08:27 <bringert> there is already the repo http://darcs.haskell.org/packages/QuickCheck/, wouldn't darcs.haskell.org/QuickCheck/ be confusing?
08:08:28 <lambdabot> Title: Index of /packages/QuickCheck
08:08:45 <chessguy> so what haskell libraries are there for web programming? i know of Text.Html, Text.Xhtml, hApps, the Network packages,...am i missing any?
08:08:56 <bringert> nominolo, use Data.ByteString.Char8.pack?
08:09:03 <dcoutts_> bringert: packages is just what gets included in ghc distributions, there are many things at the top level which are inlcuded in ghc too, eg cabal
08:09:26 <chessguy> @pl \s -> pack (map toOrd s)
08:09:26 <lambdabot> pack . map toOrd
08:09:38 <nominolo> bringert: oh, overlooked that package. thanks
08:09:45 <bringert> dcoutts_: right, I just mean that there would be two repos named QuickCheck with quite different versions
08:09:47 <dcoutts_> bringert: if/when ghc distributions include QC2 then we just symlink it like with Cabal
08:09:48 <assl0r> thx ari, i will try it ;)
08:10:10 <bringert> dcoutts_: maybe darcs.haskell.org/QuickCheck2 would be better for clarity?
08:10:23 <bringert> the package would still be called QuickCheck I guess
08:10:26 <dcoutts_> bringert: we have /cabal which is HEAD, and /cabal-branches/ with other versions
08:10:27 <bringert> hmm
08:11:42 <dcoutts_> bringert: /packages/Cabal symlinks to /cabal, /ghc-6.6/packages/Cabal symlinks to /cabal-branches/cabal-1.1.6
08:12:17 <bringert> ok, makes sense
08:12:48 <bringert> dcoutts, let me just see if I can get some input from koen first. I haven't talked to him about quickcheck in a while
08:12:52 <dcoutts_> ok
08:13:47 <assl0r> > \x -> show x
08:13:56 <lambdabot>  <Integer -> [Char]>
08:14:29 <quicksilver> that's a weird bit of defaulting
08:14:58 <hpaste>  ari annotated "(no title)" with "Inspired by zipWith, is this what you want?" at http://hpaste.org/1757#a1
08:15:08 <hpaste>  bringert pasted "lhs2tex question mark weirdness" at http://hpaste.org/1758
08:15:24 <assl0r> but this default mechanism doesnt seem to work in my case
08:15:27 <assl0r> test :: a -> IO()
08:15:27 <assl0r> test f = print $ show f
08:16:00 <hpaste>  bringert annotated "lhs2tex question mark weirdness" with "(no title)" at http://hpaste.org/1758#a1
08:16:38 <bringert> kosmikus: any idea about this lhs2TeX issue: http://hpaste.org/1758 ?
08:17:02 <assl0r> No instance for (Show a)
08:17:57 <emu> @tell ndm nice installer
08:17:57 <lambdabot> Consider it noted.
08:18:00 <glguy> assl0r: test :: Show a => a -> IO ()
08:18:06 <quicksilver> assl0r: your type is incorrect, that's all
08:18:09 <assl0r> ari: whats diffrent (beside the default pattern)?
08:18:15 <assl0r> glguy, quicksilver thx :)
08:18:16 <glguy> assl0r: and also: print x = putStrLn (show x)
08:18:29 <ndm> emu: thanks :)
08:18:32 <glguy> assl0r: so the show in your definition isn't really needed
08:18:33 <ndm> @clear-messages
08:18:33 <lambdabot> Messages cleared.
08:18:44 <emu> hehe
08:18:47 <emu> did you use installshield?
08:18:50 <glguy> *baleted*
08:21:15 <assl0r> ari: ah now i understand :)
08:21:34 <hpaste>  Sgeo annotated "little typerror..." with "typeerror stuff" at http://hpaste.org/1753#a3
08:22:52 <Jesus> hello
08:23:00 <assl0r> ari: this solution drops all futher processing... that's not what i want ;)
08:24:50 <matthew-_> Jesus: could you deal with the bug as reported today on xkcd. I think it should be a priority.
08:25:10 <ari> assl0r: What was different was that that function was closer to my idea of what you might have wanted based on what you said about handling missing elements...
08:25:24 <Jesus> The bug, is not an issue matthew, for the sin of the creator of the big will release a fix in a few days.
08:25:32 <Jesus> bug rather.
08:26:07 <LeCamarade> Jesus: The sin? Aren't you supposed to die and save ... oh, sorry.
08:26:32 <matthew-_> Jesus: divergence is being eliminated?
08:26:34 <Jesus> for I have died and went to the father, but I am actually not on irc, you are seeing this because your faith is great.
08:26:42 <matthew-_> lol
08:26:50 <matthew-_> now I /know/ this isn't actually Jesus!
08:26:51 <quicksilver> assl0r: it sounds to me like you want a list of [Maybe foo]
08:26:53 <Jesus> I tell you the truth, for when a man dies, he is alive in spirit, and his awareness continues after death.
08:27:06 <quicksilver> assl0r: then you can use Nothing to represent missingness
08:27:13 <ari> Jesus: Until they're garbage collected?
08:27:15 <kaol> that sounds like a fate worse than death
08:27:17 * LeCamarade saw `creator' and `sin' in the same line and thought it was the real ... Oh! Behold, I have seen the Lord, and yet I live! Or, do I live?
08:27:36 <quicksilver> > zipWith (liftM2 (+)) [Just 1, Nothing, Just 3] [Just 4, Just 5, Just 6]
08:27:45 <lambdabot>  [Just 5,Nothing,Just 9]
08:27:51 <Jesus> People do you not know that you are like angels after death, and each of you will be given a planet, full of human life, that you will be a king over, where you can come and go, and do as you please.
08:28:07 <kaol> bah. I was hoping for virgins
08:28:14 <glguy> and now we are onto mormonism
08:28:20 <Jesus> glguy, good one
08:28:22 <matthew-_> I was hoping for termination
08:28:24 <Jesus> im surprised you caught that
08:28:24 <Jesus> heh
08:28:31 <Jesus> mormons believe they are given their own planet
08:28:33 <glguy> I've always wanted to do this
08:28:34 <Cale> That's kind of like becoming a Goa'uld, eh?
08:28:35 --- mode: ChanServ set +o glguy
08:28:39 --- kick: Jesus was kicked by glguy (glguy)
08:28:41 <glguy> WOOT
08:28:46 --- mode: glguy set -o glguy
08:29:00 <quicksilver> You have to give a witty kick message though
08:29:06 <glguy> :*(
08:29:06 <Jesus> glguy, guess what, you were to slow for the bankick,...........mother fucking owned IMO. hahahah, I win, you lose. gg
08:29:07 <Jesus> glguy, guess what, you were to slow for the bankick,...........mother fucking owned IMO. hahahah, I win, you lose. gg
08:29:13 <glguy> lol
08:29:16 <glguy> I didn't ban you
08:29:20 <glguy> I didn't even try
08:29:20 <matthew-_> err, it's "too", not "to" you wally
08:29:22 <quicksilver> Unable to match expected type HaskellProgrammer with inferred type Troll ?
08:29:24 <glguy> I jus twanted to "kick Jesus"
08:29:42 <glguy> if I wanted to bankick, I'd ban *first*
08:29:53 <quicksilver> or just use a client which does that automatically :)
08:29:53 <kaol> I think "what would Jesus code?" just got an answer
08:29:59 <osfameron> I thought /kickban did that?
08:30:08 * glguy only typed /kick
08:30:15 <quicksilver> osfameron: that's a client-side macro but, yes, that's what it does
08:30:22 <glguy> We had some crazy mormons at my highschool
08:30:32 <matthew-_> as opposed to the non crazy ones?
08:30:44 <glguy> that's true, they might have  been normal...
08:30:55 <glguy> for mormons, I don't know
08:33:43 <hpaste>  assl0r annotated "(no title)" with "that would have been to easy?" at http://hpaste.org/1757#a2
08:34:15 <glguy> assl0r: wtf are you trying to do?
08:34:18 <glguy> a4 doesn't tell me
08:34:20 <glguy> :)
08:35:02 <assl0r> crazy list appending :-D
08:35:38 <assl0r> wait...
08:38:44 <quicksilver> assl0r: the order you want is definitely a h x y g b ?
08:38:49 <quicksilver> assl0r: cos that's quite odd :)
08:39:25 <assl0r> http://picload.org/image/35ef1670d9eff9325c77852cf7d7a386/clipboard01.gif
08:39:29 <lambdabot> http://tinyurl.com/2ebza5
08:39:54 <BRS_Runaro> What do you think of "Clean"?
08:40:12 <quicksilver> assl0r: pretty :)
08:40:15 <assl0r> quicksilver, the order is according to the image
08:40:22 <assl0r> yeah.. makes me headages :)
08:40:34 <assl0r> but only with the missing elements
08:40:46 <assl0r> how does this Maybe stuff work?
08:41:30 <quicksilver> assl0r: well what do you want to do if elements are missing?
08:41:47 <assl0r> leave em out :)
08:41:59 <assl0r> ignore em
08:42:01 <glguy> You want to leave out the elements that don't exist?
08:42:09 <quicksilver> then you use Maybe, yes
08:42:13 <quicksilver> and then you catMaybe at the end
08:42:20 <assl0r> mhm
08:42:21 <quicksilver> catMaybes, even
08:42:36 <quicksilver> catMaybe [Just 1, Just 2, Nothing, Just 4, Just 5, Nothing, Just 8]
08:42:41 <quicksilver> > catMaybes [Just 1, Just 2, Nothing, Just 4, Just 5, Nothing, Just 8]
08:42:43 <lambdabot>  [1,2,4,5,8]
08:42:45 <ari> I'm assuming you want the type [Maybe a] -> [Maybe a] -> [Maybe a] -> [a], then
08:42:51 <assl0r> [ [1..3], [9,10], [23..26] ]
08:43:11 <quicksilver> assl0r: ah you mean the elements can only be missing at the end?
08:43:19 <quicksilver> (you really must be more precise about what you mean! :)
08:43:34 <assl0r> will be: 1, 10, 23, 24, 9, 2, 3, (missing) 25, 26...
08:43:56 <assl0r> quicksilver, yeah.. :)
08:44:02 <assl0r> i will try in future
08:44:09 <quicksilver> one approach, which will make for fairly clean code, is to pad them all to the same length with 'Nothings'
08:44:16 <quicksilver> and then catMaybes the result
08:44:29 <quicksilver> and you can use your first attempt at a4
08:44:46 <assl0r> i've never worked with monads before..
08:44:47 <quicksilver> except you will no longer need to check they are the same length, since they will be :)
08:44:56 <quicksilver> it's not a monad, for your purposes
08:45:04 <quicksilver> we're not using any monadic operations
08:45:13 <quicksilver> Maybe is just a way to note that a value might be present or absent
08:45:35 <assl0r> sounds great
08:45:50 <assl0r> can you tell me why my trivial approach doesnt work?
08:45:57 <quicksilver> a value is either present (Just <val>) or absent (Nothing)
08:46:03 <assl0r> (a:b:as) _ ...
08:46:10 <helmut> Can you give me some hints on passing errors? (I'm writing a compiler.) error doesn't seem to be a good solution ..
08:46:16 <quicksilver> assl0r: it looks plausible but you missed some cases
08:46:31 <assl0r> a lot of stupid :)
08:46:34 <quicksilver> assl0r: you missed the cases that there is only 1 element left at the end
08:46:36 <assl0r> i won't miss that
08:46:44 <quicksilver> assl0r: i.e. odd-number of elements
08:46:56 <quicksilver> assl0r: that approach works fine but you have a lot of cases to list
08:47:09 <assl0r> so i will give a try to that maybe/nothing stuff..
08:47:18 <quicksilver> 'only 1 element in second list', 'only one in 1st and 2nd but still somethin n 3rd'
08:47:23 <quicksilver> and so on
08:47:40 <chessguy> helmut: i'm not sure if this is what you want, but it might be of interest to you: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
08:47:42 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
08:47:58 <assl0r> > :t lookup
08:47:59 <lambdabot>  Parse error
08:48:10 <_frederik_> can someone explain this error message?
08:48:11 <_frederik_>     A pattern type signature cannot bind scoped type variables `xv', `e', `yv', `r'
08:48:14 <_frederik_>       unless the pattern has a rigid type context
08:48:42 <quicksilver> > let { padToLength n [] = replicate n Nothing; padToLength n (x:xs) = Just x : padToLength (n-1) xs} in padToLength 6 [1,2,3]
08:48:43 <lambdabot>  [Just 1,Just 2,Just 3,Nothing,Nothing,Nothing]
08:48:50 <helmut> chessguy: looks good! thanks.
08:48:58 <quicksilver> assl0r: that's an example of how you might pad out a list
08:49:16 <assl0r> > lookup 9 [(1,10),(2,20)]
08:49:18 <lambdabot>  Nothing
08:49:19 <quicksilver> assl0r: now you want to pad all three to the 'the first even number which is bigger than all three lengths', if I'm not wrong
08:50:16 <assl0r> > lookup 2 [(1,10),(2,20)]
08:50:17 <lambdabot>  Just 20
08:50:50 <quicksilver> > let maxlength l m n = foldr max . map length $ [l,m,n] in maxlength [[1..3],[9,10],[23..26]]
08:50:52 <lambdabot>  <[[Integer]] -> [[Integer]] -> [[Int]] -> [Int]>
08:51:02 <quicksilver> > let maxlength l m n = foldr max . map length $ [l,m,n] in maxlength [1..3] [9,10] [23..26]
08:51:04 <lambdabot>  <[[Int]] -> [Int]>
08:51:14 <quicksilver> > let maxlength l m n = foldr1 max . map length $ [l,m,n] in maxlength [1..3] [9,10] [23..26]
08:51:16 <lambdabot>  4
08:51:17 <quicksilver> bah, sorry for noise
08:51:29 <quicksilver> assl0r: and that's a way to get the max length
08:51:40 <assl0r> :)
08:51:43 <assl0r> thx a lot
08:57:47 <Saizan> ?djinn a -> b -> Either (Not a) b
08:57:48 <lambdabot> f _ a = Right a
08:58:09 <chessguy> ?hoogle Not
08:58:09 <lambdabot> Prelude.not :: Bool -> Bool
08:58:10 <lambdabot> Prelude.Nothing :: Maybe a
08:58:10 <lambdabot> Network.Socket.NotConnected :: SocketStatus
08:58:20 <_frederik_> never mind
08:58:25 <Saizan> ?djinn-env
08:58:25 <lambdabot> data () = ()
08:58:26 <lambdabot> data Either a b = Left a | Right b
08:58:26 <lambdabot> data Maybe a = Nothing | Just a
08:58:26 <lambdabot> data Bool = False | True
08:58:26 <lambdabot> data Void
08:58:27 <lambdabot> type Not x = x -> Void
08:58:29 <lambdabot> class Eq a where (==) :: a -> a -> Bool
08:58:31 <lambdabot> data Ordering = LT | EQ | GT
08:58:34 <lambdabot> class Ord a where compare :: a -> a -> Ordering
08:58:36 <lambdabot> class Monoid a where mempty :: a; mappend :: a -> a -> a; mconcat :: [a] -> a
09:06:39 * mdmkolbe|work learned a new Haskell trick
09:06:56 <mdmkolbe|work> > "Hello \                            \ World"
09:07:01 <lambdabot>  "Hello  World"
09:07:05 <quicksilver> hates it
09:07:12 <quicksilver> nasty hateful trick
09:07:30 <dylan> > "\   \"
09:07:32 <lambdabot>  ""
09:07:39 <dylan> fascinating
09:07:57 <mdmkolbe|work> I think they added it to allow multi-line strings
09:08:03 <phoniq> it burns us!
09:08:16 <bringert> dcoutts, koen is fine with moving the repo to d.h.o, but he had some reasons why fail in Gen isn't that useful
09:08:30 <dcoutts_> bringert: right 'o
09:08:32 <mdmkolbe|work> They couldn't do it the C way ("x" "y" --> "xy") b/c of types, so they had to come up with something
09:09:08 <bringert> dcoutts, we agreed to set up a quickcheck@haskell.org list, for quickcheck users and developers
09:09:19 <dcoutts_> great
09:09:21 <bringert> dcoutts, do you know who I should talk to about that
09:09:47 <dcoutts_> bringert: it should say on the mailing lists page, or ask JaffaCake
09:10:22 <bringert> dcoutts, so, do you think it should be darcs.haskell.org/QuickCheck then?
09:10:27 <dcoutts_> bringert: do you think it's worth a new mailing list? perhaps keeping it on the libraries list would give a wider audience
09:10:41 <dcoutts_> bringert: yes, that seems a good place for the repo
09:11:15 <ndm> bringert: i'd recommend not doing that, i set up hoogle@haskell.org, and in retrospect it was a bad idea
09:11:32 <dcoutts_> ndm: not enough interest for a whole mainling list ?
09:11:35 <quicksilver> mdmkolbe|work: In practice, I use concat ["x", \n "y", \n "z"] for small examples
09:11:44 <quicksilver> mdmkolbe|work: and for larger examples, I'd outsource the string to a file :)
09:12:06 <ndm> dcoutts_ indeed, and the spam problem is annoying, and harder for each small list
09:12:18 <dcoutts_> ndm: I'd say cabal & c2hs are only just big enough to justify their own lists
09:12:36 <ndm> dcoutts_ cabal is, you have a steady stream of bug reports that warrant a list :)
09:12:40 <dcoutts_> splitting the pool of potential reviews isn't such a good idea
09:12:46 <dcoutts_> ndm: right :-)
09:12:48 <ndm> hoogle isn't because everyone prods me on IRC
09:15:43 <assl0r> may i mix let .. in and do statements?
09:15:51 <quicksilver> assl0r: yes
09:15:59 <bringert> dcoutts, repo now at http://darcs.haskell.org/QuickCheck/
09:16:01 <quicksilver> assl0r: although it may confuse you if you don't quite know what you're doing :)
09:16:02 <lambdabot> Title: Index of /QuickCheck
09:16:12 <dcoutts_> bringert: great
09:16:42 <quicksilver> assl0r: but in principle you can mix them either way around, with any arbitrary nesting
09:16:55 <quicksilver> assl0r: there is also a special kind of let that actually works inside a 'do' block
09:17:01 <quicksilver> assl0r: this special let doesn't have an 'in'
09:17:17 <bringert> dcoutts, the Gen fail issue was that it breaks promote, and makes it hard to generate infinite trees
09:17:44 <dcoutts_> ah yes ok, it needs to be lazy and allowing failure makes that harder
09:18:19 <dcoutts_> bringert: where do you want 'darcs send' to send patches ?
09:18:41 <dcoutts_> bringert: the libraries list ? you'll want to set _darcs/prefs/email on the server
09:20:27 <assl0r> quicksilver, padToLength :: Int -> [a] -> [Maybe a] -- is that the right signature?
09:20:37 <bringert> dcoutts, thanks, done
09:21:06 <quicksilver> assl0r: yes
09:21:13 <quicksilver> assl0r: that's the signature of the code I wrote, at least
09:21:48 <quicksilver> assl0r: there is a non-recursive version too, which you might find more attractive
09:22:02 <assl0r> i like recursions :)
09:22:24 <quicksilver> > let padToLength n l = map Just l ++ (replicate (n - length l) Nothing)
09:22:24 <lambdabot>  Parse error
09:22:32 <quicksilver> > let padToLength n l = map Just l ++ (replicate (n - length l) Nothing) in padToLength 6 [1..3]
09:22:41 <lambdabot>  [Just 1,Just 2,Just 3,Nothing,Nothing,Nothing]
09:22:49 <assl0r> you mean in my case i should fixate it to the number of lists?
09:22:57 <quicksilver> I have something of a prejudice against 'length' and subtractiong
09:23:04 <quicksilver> which is why I gave the recursive version
09:23:15 <quicksilver> however really that's a bit daft :) there's not much wrong with that one
09:23:32 <mnislaih> there is something wrong with the hackage packages file for cabal-install. Has anyone else noticed ?
09:23:41 <mnislaih> dcoutts ?
09:23:46 <dcoutts_> mnislaih: what's wrong?
09:23:57 <mnislaih> it seems it's not a valid tar
09:24:06 <dcoutts_> hmm
09:24:35 <mnislaih> tar fails to open it, I tested both in my Mac Os and in a Debian
09:24:40 <Igloo> Where is it?
09:24:43 <dcoutts_> mnislaih: there is no cabal-install package on hackage
09:25:02 <mnislaih> I mean, the 00-index.tar.gz file with the list of packages
09:25:06 <dcoutts_> mnislaih: ah ok
09:25:33 <mnislaih> http://hackage.haskell.org/packages/00-index.tar.gz igli
09:25:39 <mnislaih> oops, Igloo
09:25:52 <mnislaih> arg, that's not the right url sorry
09:26:12 <Igloo> It's double-gzipped
09:26:14 <mnislaih> http://hackage.haskell.org/packages/archive/00-index.tar.gz
09:26:17 <assl0r> quicksilver, my result will be [Maybe a]
09:26:19 <assl0r> of a4
09:26:30 <quicksilver> assl0r: yes
09:26:33 <quicksilver> assl0r: then you catMaybes it
09:26:40 <dcoutts_> mnislaih: it's been gziped twice
09:26:43 <quicksilver> assl0r: which strips off the 'Justs' and removes the nothings
09:26:56 <mnislaih> ok, there must be something wrong in the hackage scripts then
09:26:59 <Igloo> dcoutts_: Like I said  :-)
09:27:02 <dcoutts_> mnislaih: gunzip it once, rename it from .tar to .tar.gz again and you'll see what I mean
09:27:04 <quicksilver> > catMaybes [Just 1, Nothing]
09:27:07 <lambdabot>  [1]
09:27:11 <dcoutts_> Igloo: oh you beat me to it :-)
09:27:12 * Igloo suspects it uses tar -zcf and then gzips it anyway
09:27:23 <mnislaih> who maintains those ?
09:27:29 <Igloo> Ross, I assume?
09:27:38 <dcoutts_> mnislaih: Ross. this is a recent issue. It worked the other day.
09:27:44 <LoganCapaldo> let tacMaybes = [] :)
09:27:50 <mnislaih> dcoutts_: yes, it's some recent change
09:27:54 <LoganCapaldo> I mean const []
09:28:02 <dcoutts_> mnislaih: email him and cc cabal-devel
09:28:06 <mnislaih> ok
09:28:27 <assl0r> recursive calls in do statements doesn't work?
09:28:36 <dcoutts_> mnislaih: do we know where the hackage code lives? we could send him the patch
09:28:49 <bringert> hackage-scripts repo
09:29:00 <dcoutts_> bringert: ah ok
09:29:02 <mauke> assl0r: works for me
09:29:03 <bringert> http://darcs.haskell.org/hackage-scripts/
09:29:04 <lambdabot> Title: Index of /hackage-scripts
09:29:14 <Knuckles> how can i simplify this function :
09:29:15 <Knuckles> addition :: [Integer]->[Integer]->[Integer]
09:29:15 <Knuckles> addition [] [] = []
09:29:15 <Knuckles> addition [] l  = l
09:29:15 <Knuckles> addition l []  = l
09:29:15 <Knuckles> addition (x:l1) (y:l2) = x+y : (addition l1 l2)
09:29:17 <Knuckles> sommeColonnes :: [[Integer]]->[Integer]
09:29:19 <Knuckles> sommeColonnes [] = []
09:29:21 <Knuckles> sommeColonnes (x:l) = addition x (sommeColonnes l)
09:29:25 <mauke> aiirrr
09:29:26 <Knuckles> the goal is to calculate the sum of the columns
09:29:31 <bringert> # Regenerate the index $archive/00-index.tar.gz
09:29:32 <bringert> find . -name '*.cabal' | tar -cz -T - -f - | gzip -9 >00-index.tar.gz
09:29:32 <Knuckles> of a list of lists
09:29:38 <bringert> from http://darcs.haskell.org/hackage-scripts/post-upload-hook
09:29:48 <slowriot> anyone know where I can get windows binaries for darcs?
09:29:53 <mauke> Knuckles: sommeColonnes = sum . concat
09:29:59 <dcoutts_> Knuckles: in future, for longish pastes, use hpaste. thanks :-)
09:30:01 <dcoutts_> @paste
09:30:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:30:06 <bringert> slowriot, #darcs may be a better place to ask
09:30:14 <BRS_Runaro> @arr
09:30:15 <lambdabot> Arrr!
09:30:24 <mauke> Knuckles: hmm, no
09:30:29 <slowriot> bringert: thanks
09:30:33 <mauke> addition = zipWith (+)
09:30:42 <quicksilver> assl0r: what are you using a 'do' statement for, btw?
09:30:53 <Knuckles> mauke, yep, isn't good
09:31:11 <assl0r> quicksilver, if i call a4 with [a]'s and fill it up with Nothings in there, i can't call it recursivley (cause a4 expects [a] not [Maybe a])
09:31:26 <assl0r> there had to be an elegant solution... :(
09:31:28 <quicksilver> assl0r: you want to split up your problem into three pieces
09:31:33 <mauke> Knuckles: map sum . transpose?
09:31:37 <quicksilver> assl0r: (1) pad the [a] in [Maybe a]
09:31:41 <assl0r> quicksilver, alright
09:31:42 <quicksilver> assl0r: (2) run 'a4' on it
09:31:44 <Knuckles> mauke, what is transpose?
09:31:49 <quicksilver> assl0r: (3) catMaybes the result
09:32:01 <mauke> > transpose [[1,2,3],[4,5,6],[7,8,9]]
09:32:01 <mdmkolbe|work> Does haskell have anything close to Python's Pickle? (Types could be a problem, but I just want a cheap way for my haskell program to dump some data to a file, that can be read back in later (perhapse in another execution))
09:32:03 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
09:32:10 <shapr> mdmkolbe|work: Data.Binary ?
09:32:12 <quicksilver> mdmkolbe|work: read/show?
09:32:15 <Knuckles> oh gread fucntion
09:32:16 <dcoutts_> mnislaih: the breaking patch is "* change the directory layout of the HackageDB data"
09:32:31 <dcoutts_>     -tar -czf 00-index.tar.gz --exclude '*.tar.gz' --exclude '*.misc' .
09:32:31 <dcoutts_>     +find . -name '*.cabal' | tar -cz -T - -f - | gzip -9 >00-index.tar.gz
09:32:34 <dcoutts_> mnislaih: ^^
09:32:34 <Knuckles> i have another function that calculate the sum of the "lines"
09:32:43 <mnislaih> dcoutts_ I'm looking at it
09:32:45 <Knuckles> sommeLignes . transpose
09:32:48 <Knuckles> perfect
09:32:50 <Knuckles> thank you!
09:32:53 <mauke> sommeLignes = map sum
09:32:54 <mnislaih> I'll send a patch to Ross, so that he tests it
09:33:01 <dcoutts_> mnislaih: great
09:33:05 <Knuckles> i have it already
09:33:07 <Knuckles> but thanks :p
09:34:17 <mdmkolbe|work> shapr: I don't see a Data.Binary in the latest docs.  And niether Data.Bits nor Data.ByteString look like I'm after.  Did you mean some other package?
09:34:32 <Knuckles> not in scope transpose :(
09:34:40 <mauke> Knuckles: import Data.List
09:34:49 <Cheery> ?doc Comonads
09:34:50 <Knuckles> i don't know if i can use it
09:34:50 <lambdabot> Comonads not available
09:34:54 <Cheery> ?doc CoMonad
09:34:55 <lambdabot> CoMonad not available
09:34:58 <mdmkolbe|work> quicksilver: yeah, I'm thinking about that, but I'd like to explore my options in case there is something that matches the situation closer
09:35:01 <Knuckles> (i don't know if i'm authorize to use it.)
09:35:04 <mauke> @src transpose
09:35:05 <lambdabot> transpose []             = []
09:35:05 <lambdabot> transpose ([]   : xss)   = transpose xss
09:35:05 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
09:35:15 <mauke> oh wow
09:35:34 <quicksilver> there are some choices in how you define transpose
09:35:42 <quicksilver> depending how you feel about ragged matrices
09:35:51 <mauke> wait, aren't those just map head/map tail?
09:35:58 <quicksilver> no, they're not
09:36:04 <quicksilver> because they never fail
09:36:11 <quicksilver> whereas map head/map tail fail on empty lists :)
09:36:11 <mauke> ah
09:36:39 <Knuckles> ok
09:36:40 <quicksilver> there are also choices based on whether you want the transpose of an infinite matrix to do something sensible
09:36:46 <Knuckles> no other solution, without using transpose
09:37:11 <quicksilver> Knuckles: on the contrary
09:37:20 <quicksilver> Knuckles: you can write something which traverses the columns if you prefer...
09:37:34 <quicksilver> using !!, for example
09:37:40 <Knuckles> what is !!
09:37:45 <quicksilver> list indexing
09:37:49 <Knuckles> ok
09:37:50 <mdmkolbe|work> @type (!!)
09:37:53 <lambdabot> forall a. [a] -> Int -> a
09:37:54 <quicksilver> > [1,2,3,4,5] !! 3
09:37:55 <mdmkolbe|work> @src (!!)
09:37:56 <lambdabot> xs     !! n | n < 0 = undefined
09:37:56 <lambdabot> []     !! _         = undefined
09:37:56 <lambdabot> (x:_)  !! 0         = x
09:37:56 <lambdabot> (_:xs) !! n         = xs !! (n-1)
09:37:56 <lambdabot>  4
09:38:11 <Knuckles> ok
09:38:17 <sm> good morning
09:38:20 <Knuckles> ok so
09:38:32 <Knuckles> with a zipwith for example?
09:38:47 <quicksilver> yes, some mixture of maps and zipwiths
09:39:06 <quicksilver> (you can define transpose in terms of map and zipwith, too...)
09:39:36 <quicksilver> depending how reductionist you're feeling, you could argue that what you're really doing is reimplementing the part of transpose which you need for this problem
09:39:49 <mauke> > foldr (zipWith (+)) (repeat 0) [[1,2,3],[4,5,6],[7,8,9]]
09:39:51 <lambdabot>  [12,15,18]
09:39:56 <mauke> it's not quite the same, though
09:40:02 <Cheery> one of you guys proposed looking into implementing FRP with comonads
09:40:08 <balodja> @pl \f -> (.) (. f) f
09:40:08 <lambdabot> (.) =<< flip (.)
09:40:14 <balodja> why 'flip'?
09:40:23 <assl0r> stripResult :: [Maybe a] -> [a]
09:40:23 <assl0r> stripResult a = map ( filter ( == Nothing) ) a
09:40:35 <mauke> balodja: because (`op` x) is flip op x
09:40:38 <Cheery> after reading about that javascript stuff, it suddenly seems much more interesting
09:40:48 * balodja thinks, that there should be just (.) >>= (.)
09:41:04 <Knuckles> mauke, what is repeat 0 ?
09:41:12 <mauke> > repeat 0
09:41:14 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:41:31 <Knuckles> hum
09:41:37 <Knuckles> can't understand your function
09:41:38 <balodja> mauke: look, in Control.Monad.Instances:
09:41:40 <balodja> instance Monad ((->) r) where
09:41:42 <balodja>     return = const
09:41:44 <balodja>     f >>= k = \ r -> k (f r) r
09:42:22 <balodja> k (f r) r looks exactly like (.) (. f) f
09:43:05 <assl0r> quicksilver, how would you strip out Nothing?
09:43:14 <mauke> @pl \f k r -> k (f r) r
09:43:15 <lambdabot> flip flip id . (ap .) . flip (.)
09:43:32 <mauke> @pl \k r -> k (f r) r
09:43:32 <lambdabot> join . (. f)
09:44:14 <quicksilver> assl0r: catMaybes
09:44:21 <quicksilver> assl0r: watch this:
09:44:25 * shapr boings quietly
09:44:32 <quicksilver> > catMaybes [Just 5, Just 2, Just 4, Nothing, Nothing, Nothing]
09:44:34 <lambdabot>  [5,2,4]
09:44:35 <mauke> balodja: not to me
09:44:43 <quicksilver> assl0r: strips out your Nothings and also removes the 'justs'
09:44:58 <quicksilver> assl0r: gets you back from [Maybe a] to [a] as desired
09:45:15 <balodja> mauke: awful overflipping, yeah? :)
09:45:16 <osfameron> @src catMaybes
09:45:17 <lambdabot> catMaybes ls = [x | Just x <- ls]
09:45:27 <mauke> @type \f -> (\k r -> f k (f r), (.) (. f) f)
09:45:29 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
09:45:29 <lambdabot>     Probable cause: `f' is applied to too many arguments
09:45:42 <mauke> @type (\f k r -> f k (f r), \f -> (.) (. f) f)
09:45:45 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
09:45:45 <lambdabot>     Probable cause: `f' is applied to too many arguments
09:46:03 <hpaste>  one_sk annotated "please help to compile" with "more or less final revision" at http://hpaste.org/1747#a2
09:46:36 <assl0r> quicksilver, ah i thought catMaybes is a pseudo-name for the functionality you told me :-D
09:46:44 <mauke> balodja: heh, \f -> (.) (. f) f isn't even valid
09:47:12 <balodja> hm-m-m :))
09:47:18 <quicksilver> assl0r: no, it's a very handy function :)
09:47:27 <quicksilver> assl0r: although as osfameron showed the source is very simple
09:47:50 <balodja> mauke: no, it is. look
09:47:58 <osfameron> I didn't think it was simple...
09:48:07 <osfameron> I mean, it *looks* simple, but it seems to be doing a lot...
09:48:14 <assl0r> quicksilver, which module contains it?
09:48:17 <balodja> @pl \x y -> f x (f y)
09:48:17 <lambdabot> (. f) . f
09:48:28 <mauke> @type \x y -> f x (f y)
09:48:30 <LoganCapaldo> @index catMaybes
09:48:31 <lambdabot> Not in scope: `f'
09:48:31 <lambdabot>  
09:48:31 <lambdabot> <interactive>:1:13: Not in scope: `f'
09:48:31 <lambdabot> Data.Maybe
09:48:37 <mauke> @type \f x y -> f x (f y)
09:48:39 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
09:48:40 <lambdabot>     Probable cause: `f' is applied to too many arguments
09:48:55 <mauke> balodja: @pl doesn't check types
09:49:46 <LoganCapaldo> @ty mapM
09:49:48 <lambdabot>     Ambiguous occurrence `mapM'
09:49:49 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
09:50:18 <LoganCapaldo> > Control.Monad.mapM (+ 2) [Just 1, Nothing]
09:50:19 <lambdabot>   add an instance declaration for (Num (Maybe b))
09:50:31 <LoganCapaldo> > Control.Monad.mapM (return . (+ 2)) [Just 1, Nothing]
09:50:33 <lambdabot>   add an instance declaration for (Show (m [Maybe t]))
09:50:45 <LoganCapaldo> @type Control.Monad.mapM
09:50:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:51:11 <LoganCapaldo> that's not the type I wanted :)
09:51:19 <mauke> file a bug report!
09:51:19 <LoganCapaldo> @type liftM map
09:51:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m ([a] -> [b])
09:51:36 <LoganCapaldo> @type map . liftM
09:51:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> [m a1] -> [m r]
09:52:05 <LoganCapaldo> @hoogle (a -> m b) -> [m a] -> [m b ]
09:52:06 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
09:52:07 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:52:07 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
09:52:26 <LoganCapaldo> @type sequence
09:52:29 <lambdabot>     Ambiguous occurrence `sequence'
09:52:29 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
09:52:32 <LoganCapaldo> gah
09:52:41 <LoganCapaldo> @type Control.Monad.sequence
09:52:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:53:12 <LoganCapaldo> > sequence [Just 1, Nothing, Just 2]
09:53:14 <lambdabot> Terminated
09:53:21 <LoganCapaldo> interesitng
09:53:38 <mauke> :t map . (=<<)
09:53:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [m a] -> [m b]
09:53:56 <LoganCapaldo> that works
09:53:58 <balodja> mauke: yeah, my fault, f x (f y) is invalid :)
09:54:46 <LoganCapaldo> (map . (=<<)) (return . (+ 1)) [Just 1, Just 2, Nothing, Just 3]
09:54:53 <LoganCapaldo> > (map . (=<<)) (return . (+ 1)) [Just 1, Just 2, Nothing, Just 3]
09:54:54 <lambdabot>  [Just 2,Just 3,Nothing,Just 4]
09:55:31 <mauke> > map (liftM (+ 1)) [Just 1, Just 2, Nothing, Just 3]
09:55:33 <lambdabot>  [Just 2,Just 3,Nothing,Just 4]
09:55:48 <LoganCapaldo> well + 1 was a lousy example function
09:56:08 <LoganCapaldo> I was looking for map . catM really
09:56:19 <mauke> > (fmap `fmap` fmap succ) [Just 1, Just 2, Nothing, Just 3]
09:56:20 <lambdabot>  Couldn't match expected type `a -> a1' against inferred type `[a2]'
09:56:23 <mauke> :(
09:56:32 <LoganCapaldo> if there's sucha  thing as catM
09:56:59 <LoganCapaldo> I guess you can't really write catM in terms of (>>=) and return
09:57:09 <LoganCapaldo> even with fail
09:57:09 <mauke> what's catM?
09:57:21 <LoganCapaldo> catMaybes generalized
09:57:48 <LoganCapaldo> I made up the name
09:57:52 <LoganCapaldo> sorry if it was confusing :)
09:58:12 <mauke> sounds impossible
09:58:29 <mauke> you'd need to detect _|_
09:58:33 <Saizan> mmh catMaybes is not really related to the maybe monad
09:59:22 <Saizan> its' more the list monad + knowing how to decostruct a Maybe
09:59:30 <LoganCapaldo> mauke: not _|_, you'd just need a compainion to fail, isFailure :: m a -> Bool. e.g.: in Either it would be case x of Left _ -> True ; _ -> False
09:59:43 <mauke> and in Identity?
09:59:50 <LoganCapaldo> I have no idea :)
09:59:57 <mauke> > runIdentity (fail "zomg")
09:59:59 <lambdabot>  Exception: zomg
10:00:05 <LoganCapaldo> but doesn't fail screw up Identity anyway?
10:00:28 <mauke> why?
10:01:09 <LoganCapaldo> Cause its just newtype Id a = Id a right?
10:01:17 <mauke> yeah
10:01:29 <LoganCapaldo> so fail has to be written with error
10:01:40 <mauke> yeah
10:01:40 <olsner> according to how it's often used - Either should rather be something like Success a | Failure a
10:01:49 <LoganCapaldo> I guess isFailure could be the same thing
10:01:57 <Saizan> even knowing how to detect fail you'd still have to know how to exit from the monad
10:03:03 <dmwit> (== mzero) ?
10:03:05 <mauke> .oO( coreturn? )
10:03:07 <LoganCapaldo> Saizan: you would catMaybes . map (\x -> if isFailure x then Nothing else Just x) right?
10:03:15 <dmwit> But then unwrapping the value would still be a bit tricky, I guess.
10:03:41 <dmwit> LoganCapaldo: Then you get a list of type [m a]...
10:03:50 <LoganCapaldo> Oh
10:03:52 <LoganCapaldo> yeah
10:04:06 <LoganCapaldo> which is actually what I was thinking of
10:04:11 <LoganCapaldo> but not what i said :)
10:04:15 <dmwit> Oh!
10:04:24 <dmwit> Well, that should be significantly easier...
10:05:05 <dmwit> > let catM xs = xs >>= (\x -> if x == mzero then [] else x) in catM [[1,2,3], [], [5,7,9]] -- hmm...
10:05:07 <lambdabot>  [1,2,3,5,7,9]
10:05:20 <dmwit> > let catM xs = xs >>= (\x -> if x == mzero then [] else x) in catM [Just 1, Nothing, Just 42] -- hmm...
10:05:21 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Maybe t'
10:05:37 <dmwit> > let catM xs = xs >>= (\x -> if x == mzero then [] else return x) in catM [Just 1, Nothing, Just 42] -- hmm...
10:05:39 <lambdabot>  [Just 1,Just 42]
10:06:05 <dmwit> > let catM xs = filter (not . (== mzero)) in catM [Just 1, Nothing, Just 42] -- better
10:06:06 <lambdabot>   add an instance declaration for (Eq (m a))
10:06:06 <lambdabot>     In the expression:
10:06:06 <lambdabot>         l...
10:07:06 <dmwit> > let catM = filter (not . (== mzero)) in catM [Just 1, Nothing, Just 42] -- better
10:07:08 <lambdabot>  [Just 1,Just 42]
10:07:20 <LoganCapaldo> not gonna work for more complicated notions of failure though right?
10:07:26 <dmwit> > let catM = filter (not . (== mzero)) in catM [[1,2,3], [], [4,5,7,9]] -- better
10:07:28 <lambdabot>  [[1,2,3],[4,5,7,9]]
10:07:36 <LoganCapaldo> > mzero == Left "?"
10:07:38 <lambdabot>  False
10:07:41 <dmwit> LoganCapaldo: No, it won't.
10:07:55 <Cheery> @hoogle CoMonad
10:07:56 <lambdabot> No matches found
10:08:00 <dmwit> > mzero :: Either String String
10:08:02 <lambdabot>  Left ""
10:08:14 <Cheery> CoMonads aren't default Haskell?
10:08:32 <Saizan> > Left "?" `mplus` return ""
10:08:34 <lambdabot>  Right ""
10:08:57 <Saizan> Cheery: they are not in the stdlib
10:08:59 <Cheery> :t mplus
10:09:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
10:09:04 <dmwit> > mzero :: Either Int Int
10:09:05 <lambdabot>   add an instance declaration for (Error Int)
10:09:05 <lambdabot>     In the expression: mzero
10:09:05 <lambdabot>   ...
10:09:10 <dmwit> o
10:09:16 <Cheery> Saizan: where can I find them from?
10:09:28 <Cheery> I'd like to try out the Context -cmonad
10:09:47 <Saizan> mmh not sure, try google
10:09:59 <Saizan> ?google Context comonad
10:10:02 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.Context.html
10:11:03 <Cheery> does comonads have something like the 'do' -block is for monads?
10:11:14 <Saizan> Cheery: no
10:12:52 <Cheery> how can I get comonads?
10:12:59 <Cheery> ?where CoMonad
10:13:00 <lambdabot> I know nothing about comonad.
10:13:04 <Cheery> ?where Control.CoMonad
10:13:05 <lambdabot> I know nothing about control.comonad.
10:13:27 <Saizan> you can either define them, or search a module from someone who have done it
10:15:43 <Saizan> they are not so estabilished as arrows or monads..
10:23:58 <olsner> @src fromJust
10:23:59 <lambdabot> fromJust Nothing  = undefined
10:23:59 <lambdabot> fromJust (Just x) = x
10:25:24 <opqdonut> ?src undefined
10:25:24 <lambdabot> undefined =  error "Prelude.undefined"
10:25:38 <opqdonut> ^_^ laziness ftw
10:28:56 <mdmkolbe|work> > let u = u in u
10:29:05 <lambdabot>  Exception: <<loop>>
10:30:08 <mdmkolbe|work> undefined is just a faster bottom
10:31:31 <mauke> __=__
10:33:05 <kolmodin> anyone speaks Japanese? my best guess is that this is Japanese.. is it? http://www.youtube.com/watch?v=1EMub6vS-h8
10:33:44 <lucca> yep
10:33:49 <dmwit> Yes, Japanese.
10:34:08 <titusg> Hello all -- can anyone give me a potted definition of heterogeneity vs. homogeneity in reasoning systems? This is in the context of a paper on reasoning with Euler/Venn diagrams...
10:34:15 <kolmodin> lucca, dmwit: thanks!
10:35:40 <kolmodin> some random person in icq asked me if it's Swedish :) no way I said :D
10:37:33 <mauke> anyone who pronounces klose "kurose" must be japanese
10:40:47 <Knuckles> is it possible to return something inside a function
10:40:53 <Knuckles> like on each recursion
10:40:56 <Knuckles> it returns the value
10:41:34 <LoganCapaldo> Knuckles: and continues recursing with a sort of log of results?
10:42:01 <Knuckles> yep
10:42:09 <LoganCapaldo> You want the Writer monad
10:42:17 <Knuckles> what is it?
10:42:47 <mauke> http://www.haskell.org/all_about_monads/html/writermonad.html
10:42:48 <lambdabot> Title: The Writer monad
10:43:35 <Knuckles> nothing integrated in haskell?
10:44:06 <mauke> er, what?
10:44:08 <LoganCapaldo> You mean at the syntax level?
10:44:35 <LoganCapaldo> Writer is in the stdlib if that's what you are asking
10:44:44 <LoganCapaldo> import Control.Monad.Writer
10:44:55 <Knuckles> yeah
10:44:57 <Botje> Knuckles: for simple traces, you can look at Debug.Trace
10:45:04 <Knuckles> ok
10:45:06 <Knuckles> thanks
10:49:25 <Cheery> (Context f c) =>> g = Context g (f c) (Context f c) =>> g = Context (g . f) c
10:49:35 <Cheery> oops, it blended badly
10:49:46 <Cheery> which one?
10:49:47 <Cheery> (Context f c) =>> g = Context g (f c)
10:49:56 <Cheery> (Context f c) =>> g = Context (g . f) c
10:52:09 <Cheery> hmm, neither seems compiling
10:52:51 <Cheery> oh yeah, I'm dumb, fixing
10:56:04 <LoganCapaldo> I think Writer is so cool
10:56:13 <LoganCapaldo> But I've never used it :(
10:57:03 <Cheery> (Context f c) =>> g  = Context (g . Context f) c
10:57:09 <Cheery> maybe this time it went right
10:57:16 <dmwit> I think it's a beautiful day to go to the zoo and feed the ducks.  To the lions. -- Brian Kantor
10:57:18 <Cheery> I can't think of very many other ways. :)
10:57:55 <LoganCapaldo> I don't know much about Comonads, but I thought =>> went from w a to a .
10:58:05 <LoganCapaldo> (s/much/anything really/)
10:58:09 <Cheery> nah, it wen't from w a to b
10:58:24 <Cheery> I checked it
10:58:27 <LoganCapaldo> right sorry
10:58:31 <LoganCapaldo> I didn't mean a
10:58:49 <LoganCapaldo> So I'm just wondering why Context appears on the rhs
11:01:02 <LoganCapaldo> reading the page about Context is giving me brain hurt
11:02:51 <Cheery> what kind of program could I write with Context easily?
11:02:58 <Cheery> hmm
11:04:20 <LoganCapaldo> Some kind of time machine apparently. "Each operation in the context comonad runs in a context determined by later operations"
11:04:31 <LoganCapaldo> Not even a time machine
11:04:36 <LoganCapaldo> a paradox machine
11:07:20 <eumenides> does anyone know how to make Network.FastCGI work?
11:09:00 <Cheery> LoganCapaldo: yes, it is weird. :)
11:09:21 <Cheery> you can split the context, then do weird things
11:09:31 <Cheery> I try one thing, a mom
11:09:38 <Lemmih> eumenides: It works just like Network.CGI.
11:12:36 <Cheery> fuzzything w = let a = coeval w * 2 in coeval $ w =>> (\w -> coeval w + a)
11:12:45 <eumenides> Lemmih: i'm just... not sure how to set it up with lighttpd. it seems to be somewhat more complicated than apache. i guess i'll just install apache :)
11:13:29 <ski> @where+ Control.Comonad http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
11:13:30 <lambdabot> Done.
11:13:31 <Cheery> hmm, thought I'm not sure whether my Context -comonad is correct. :/
11:13:43 <mux> what the heck, I have Enum and Bounded derived from a type, but toEnum minBound throws an error for being outside of the enumeration range
11:13:56 <ski> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.Context.html
11:13:58 <lambdabot> http://tinyurl.com/245xyg
11:16:03 <norpan> mux: you mean fromEnum?
11:16:21 <mux> I'm not sure what I meant, I'm confused
11:16:30 <mux> maybe I will have this sorted
11:16:32 <norpan> toEnum takes an inte
11:16:33 <norpan> ger
11:16:36 <mux> yes
11:16:41 <norpan> @type toEnum
11:16:44 <lambdabot> forall a. (Enum a) => Int -> a
11:17:09 <Lemmih> eumenides: lighttpd is way simpler than apache.
11:17:20 <norpan> so your enum instance needs to have a large negative number, but derived instances start at 0 i think
11:17:51 <mux> what do you mean by it needs to have a large negative number?
11:18:00 <norpan> > minBound :: Int
11:18:02 <lambdabot>  -2147483648
11:18:07 <norpan> that number
11:18:11 <Lemmih> eumenides: I'm using lighttpd with my Haskell web-applications. Lighttpd has some really simple config file examples.
11:18:20 <mux> I don't get what you're trying to tell me
11:18:25 <Cheery> hmm, ah, like with normal monads, comonads will be constructed from smaller comonads
11:18:49 <norpan> mux: if you do toEnum minBound you will get toEnum (-2147483648)
11:18:55 <mux> yes
11:18:58 <mux> that's not my problem
11:19:05 <norpan> so your enum instance needs to accept that number
11:19:11 <mux> this was just a typo.
11:19:44 <norpan> ok, then sort that up first and ask again :)
11:19:48 <kpreid> mux: perhaps you want minBound without toEnum
11:20:13 <mux> no no no
11:20:15 <mux> so here's my problem
11:20:23 <ski> Cheery : do you mean comonad transformers ?
11:20:25 <mux> toEnumMaybe :: (Enum a, Bounded a) => Int -> Maybe a
11:20:25 <mux> toEnumMaybe x = if x <= maxBound && x >= minBound then Just (toEnum x) else Nothing
11:20:33 <mux> it seems this doesn't work
11:20:47 <mux> because the minBound and maxBound instances don't actually refer to a in this code
11:21:00 <mux> and I can't see how to "bind" those, because I only have a value at this point
11:21:11 <kpreid> asTypeOf
11:21:23 <mux> no other solution ?
11:21:23 <kpreid> fromEnum (maxBound `asTypeOf` x)
11:21:37 <kpreid> scoped type variables will do, but I don't understand 'em
11:21:42 <mux> oh, asTypeOf is in Prelude?
11:21:48 <kpreid> @index asTypeOf
11:21:48 <lambdabot> Prelude
11:21:55 <mux> that's just nice then, thankies! :-)
11:21:55 <kpreid> @src asTypeOf
11:21:56 <lambdabot> asTypeOf = const
11:21:59 <norpan> no, you need to do (fromEnum maxBound)
11:22:02 <kpreid> @type asTypeOf
11:22:03 <ski> toEnumMaybe x :: Maybe a = ..(.. :: a)..
11:22:05 <lambdabot> forall a. a -> a -> a
11:22:06 <norpan> x is Int
11:22:22 <mux> oh, right too
11:22:26 <kpreid> ah, you need to introduce a variable for the result
11:22:30 <mux> but will that suffice to "bind" to the correct type?
11:22:31 <kpreid> norpan: whoops
11:23:23 <mux> obviously I need to fix it as norpan said, but I guess I also need asTypeOf
11:23:42 <norpan> yeah
11:23:58 <norpan> asTypeOf, because you can't refer to the type variable
11:24:04 <Cheery> ski: I guess now I've gotten the comonads
11:24:26 <norpan> let result = ... `asTypeOf` result ... in result
11:24:41 <kpreid> @let toEnumMaybe x = if x <= fromEnum (maxBound `asTypeOf` result) && x >= fromEnum (minBound `asTypeOf` result) then Just result else Nothing where result = toEnum x
11:24:44 <lambdabot> Defined.
11:24:52 <kpreid> @type toEnumMaybe
11:24:55 <lambdabot> Not in scope: `toEnumMaybe'
11:24:56 <norpan> or "where"
11:25:08 <kpreid> > L.toEnumMaybe 0 :: Maybe Bool
11:25:10 <lambdabot>  Just False
11:25:11 <kpreid> > L.toEnumMaybe (-1) :: Maybe Bool
11:25:13 <lambdabot>  Nothing
11:25:16 <mux> mmm, it's still not working
11:25:18 <norpan> L?
11:25:22 <kpreid> > L.toEnumMaybe (2) :: Maybe Bool
11:25:23 <lambdabot>  Nothing
11:25:28 <Cheery> you can use comonad to handle with hidden state.
11:25:29 <mux> norpan: scope for @let
11:25:31 <kpreid> mux: I just gave a working definition
11:25:37 <mux> yeah, reading it now
11:26:09 <kpreid> the difference between result and just writing toEnum x is that result is monomorphic
11:26:23 <Cheery> but instead of usual monad, it's upside down
11:26:29 <kpreid> it's got the same type in all three positions it appears
11:26:36 <mux> ok, I get it
11:26:39 <mux> cheers!
11:27:15 <norpan> but is there no extension that allows you to refer to the type variable in the functino type?
11:27:23 <Cheery> similar to how I can hide signals with arrows, I can hide them also with comonads
11:28:11 <mux> *Moves> genMoves' (Square D R3) Queen
11:28:11 <mux> [d4,d5,d6,d7,d8,e4,f5,g6,h7,e3,f3,g3,h3,e2,f1,d2,d1,c2,b1,c3,b3,a3,c4,b5,a6]
11:28:22 <eumenides> Lemmih: can you show me the fastcgi part of lighttpd.conf that works with Network.FastCGI?
11:28:27 <mux> now I need to open a chess game and count squares to see if they have all been correctly generated heh
11:28:56 <Cheery> thought, unlike monads, comonads do not seem to be so obviously useful
11:29:25 <mux> ok, it's good
11:29:27 <DRMacIver> Monads don't seem obviously useful until you have a use you want to apply them to. :)
11:29:47 * mux hearts unfoldr
11:29:59 <Cheery> thought, I think there's lots of ways you could use comonads to represent FRP signals
11:30:11 <Cheery> and signal transitions
11:30:19 <Cheery> and I think it'd become quite readable too!
11:30:25 <sjanssen> unfoldr++ the neglected list operation
11:30:40 * DRMacIver doesn't have a clue what comonads are. :)
11:30:52 <DRMacIver> And if you say "Monads in Haskell*" I will smack you. ;)
11:31:30 <newsham> blah, tried mailing hallgren@ogi and it got forwarded to altocumulus.org which is down (which is why I'm mailing him)
11:31:48 <hpaste>  Lemmih pasted "My lighttpd config." at http://hpaste.org/1759
11:32:27 <ski> DRMacIver : well, rather in 'Haskell^op', i think
11:32:37 <eumenides> Lemmih: thanks!
11:32:52 <mux> @karma+ unfoldr
11:32:52 <Cheery> SF (c -> (t -> SF c t a, a)) c)
11:32:52 <lambdabot> unfoldr's karma raised to 11.
11:32:55 <Lemmih> eumenides: I think it can be even simpler than what I have.
11:33:06 <DRMacIver> ski: True. I temporarily forgot what the usual notation for the dual category was so defaulted to the vector space one. :)
11:33:36 <kpreid> norpan: there is such an extension
11:33:40 <ski> > build (\nil cons -> fix (0 `cons`))
11:33:41 <lambdabot>   Not in scope: `build'
11:33:42 <Cheery> or wait, it wouldn't be probably like that
11:33:48 <ski> > GHC.Exts.build (\nil cons -> fix (0 `cons`))
11:33:49 <lambdabot>   Not in scope: `GHC.Exts.build'
11:33:51 <eumenides> Lemmih: so... a haskell fastcgi binary runs at 2200 and lighttpd connects to it?
11:34:00 <ski> @hoogle build
11:34:01 <lambdabot> GHC.Exts.build :: ((a -> b -> b) -> b -> b) -> [a]
11:34:01 <lambdabot> Distribution.Simple.Build.build :: PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()
11:34:01 <lambdabot> Data.Graph.Inductive.Internal.Heap.build :: Ord a => [(a, b)] -> Heap a b
11:34:07 <DRMacIver> Not that I have any intuition whatsoever what Haskell^op looks like.
11:34:52 <ski> @tell ndm, hoogle removes the non-top-level 'forall' in '@hoogle build' :/
11:34:53 <lambdabot> Consider it noted.
11:35:58 <Lemmih> eumenides: Yes. (lighttpd takes care of starting the fastcgi binary)
11:36:00 <sjanssen> @hoogle runST
11:36:01 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
11:36:02 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
11:36:02 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
11:36:10 <sjanssen> ski: looks like a common bug
11:36:18 <shapr> @tell ddarius muwahahah!
11:36:19 <lambdabot> Consider it noted.
11:37:53 <Cheery> every Comonad is a Functor?
11:38:36 <Cheery> seems so
11:38:39 <LoganCapaldo> What, they aren't CoFunctors? :)
11:39:45 <ski> sjanssen : istr it didn't do that not long ago
11:40:05 <ski> Cheery : yes every comonad is a functor
11:40:30 <LoganCapaldo> let fmap = ?
11:40:33 <ski> usually one mean 'covariant functor' by 'functor' .. there's also 'contravariant functors'
11:41:14 <LoganCapaldo> coeval . (=>>) doesn't seem right
11:41:26 <LoganCapaldo> oh I guess its just (=>>) . coeval
11:41:38 <LoganCapaldo> bizzare
11:41:51 <assl0r> is there a type for all Numbers? Num is class not a type ;(
11:41:53 <ski> fmap f = (=>> (f . extract))
11:42:25 <Cheery> ski: where can I find the Control.CoMonad?
11:42:33 <Cheery> erm. Control.Comonad
11:42:33 <ski> @where Control.Comonad
11:42:34 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
11:42:51 <ski> (that's dave menendez version)
11:42:57 <SamB> @all-dict contravariant
11:43:06 <Cheery> is there cabal for installing it?
11:43:09 * ski dislikes the name 'coeval'
11:43:16 <SamB> is lb dead?
11:43:27 <Cheery> I dislike it too, it's too long I think
11:43:37 <ski> is 'return' also too long ?
11:43:47 <LoganCapaldo> ski: beat me to it
11:44:12 <LoganCapaldo> but I was gonna do > length "return" `compare` length "coeval" to be clever :)
11:44:23 <ski> Cheery : <http://www.eyrie.org/~zednenem/2004/hsce/> is what there is, i think
11:44:28 <kc5tja> Yes; if Smalltalk can get by with just ^, so can Haskell!  >:P  (playing devil's advocate)
11:44:39 <LoganCapaldo> > length "return" `compare` length "coeval"
11:44:47 <lambdabot>  EQ
11:44:53 <ski> (kc5tja : that's a completely different thing)
11:45:22 <LoganCapaldo> > let (^) = return in (^) 5 :: Maybe Int
11:45:24 <lambdabot>  Just 5
11:45:26 <kc5tja> ski: When has total contextual ignorance ever stopped me from being stupid silly?
11:45:31 <mux> @index join
11:45:32 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:45:53 <ski> kc5tja : er .. i dunno ?
11:47:16 <glguy> > let (^) = return in (5 ^) :: Maybe Int
11:47:17 <lambdabot>  Just 5
11:47:39 <mux> > let foo = liftM $ join (,) in foo (Just 5)
11:47:41 <lambdabot>  Just (5,5)
11:47:53 <mux> maybe a bit cryptic
11:47:55 <kc5tja> My job here is done now.  It's time now to fly to a meeting, and spread the stupid silliness around the world!  Whoosh!  (<-- this is what happens when you've been hacking all day, you have a sugar rush, AND you're hungry, all at the same time.)
11:53:26 <mux> @hoogle dup
11:53:27 <lambdabot> Control.Concurrent.Chan.dupChan :: Chan a -> IO (Chan a)
11:53:27 <lambdabot> Control.Concurrent.STM.TChan.dupTChan :: TChan a -> STM (TChan a)
11:53:27 <lambdabot> Language.Haskell.Syntax.HsFieldUpdate :: HsQName -> HsExp -> HsFieldUpdate
11:53:38 <mux> @let dup = join (,)
11:53:39 <lambdabot> Defined.
11:53:56 <mux> > liftM dup (Just 3)
11:53:58 <lambdabot>  Just (3,3)
11:54:02 * LoganCapaldo would have named it pair or pairOf
11:54:13 * mux ponders
11:54:17 <LoganCapaldo> ooo
11:54:20 <LoganCapaldo> twin! :)
11:54:24 <mux> heh
11:54:31 <LoganCapaldo> > let twin = join (,) in twin 5
11:54:33 <lambdabot>  (5,5)
11:56:16 <mux> :type dup
11:56:27 <mux> @type dup
11:56:29 <lambdabot> Not in scope: `dup'
11:56:32 <mux> @type L.dup
11:56:35 <lambdabot> Couldn't find qualified module.
11:56:41 <mux> hrmf.
11:58:02 <Cheery> wtf is :@: ?
11:58:15 <glguy> a data constructor?
12:00:42 <SamB> could be a type class!
12:01:48 <arjanoosting> Igloo: do you have a public VCS for your haskell-* Debian packages (the extralibs)? I want to extend them to build libhugs-* packages in addition to the current libghc6-* packages.
12:02:19 <genbie> short question, which is better for developing haskell, emacs or vim plz?
12:02:27 <glguy> lol
12:02:29 <SamB> genbie: bwahahahahaha
12:02:43 <SamB> whatever one seems to work best for you, duh
12:02:49 <dcoutts_> genbie: whichever you find you can tolerate
12:02:50 <genbie> neither lol
12:02:56 <glguy> Visual Haskell is best (with a Vim plugin, of course)
12:02:58 <SamB> yeah, what dcoutts said ;-P
12:03:16 <genbie> seriously i can tolerate emacs
12:03:26 <genbie> but why so many use vim?
12:03:26 <sjanssen> genbie: go with emacs, then
12:03:55 <glguy> genbie: because some people feel that vim suits them better as an editor while others feel that way about emacs
12:04:00 <sjanssen> genbie: because once you've used vim for a while, you develop a dependency
12:04:01 <phoniq> does anybody actively use Yi?
12:04:26 <Igloo> arjanoosting: No VCS at all
12:04:46 <genbie> i am asking about features specific to haskell like shim.. is emacs better supported?
12:05:12 <arjanoosting> Igloo: I just have to apt-get source them and send you patches?
12:05:42 <Igloo> arjanoosting: Yeah, that's probably easiest
12:06:06 <arjanoosting> will do that then
12:06:11 <Igloo> OK, thanks
12:06:17 <sjanssen> genbie: yes, emacs generally has better tools to work with Haskell
12:06:36 <genbie> thanks sjanssen
12:06:53 <Igloo> arjanoosting: What do you do about docs?
12:08:12 <glguy> the only thing I've found using emacs that I prefered over vim when doing haskell dev was the ability for it to display special characters or things like: -> :: => <- not
12:08:24 <Igloo> Hmm, building for two compilers kinda breaks the build/install separation
12:09:01 <shapr> glguy: Can vim dump source into ghci automatically?
12:09:16 <glguy> shapr: that's not something I need my editor to do
12:09:41 <shapr> Oh ok, just wondering.
12:09:47 <SamB> I don't tend to do that myself
12:09:52 <glguy> I just keep a ghci open
12:09:55 <glguy> and when I want to reload, I type :
12:10:22 <SamB> it would be nice if I had plan9-style "plumbing" for errors, though
12:10:46 <zafoeta> so
12:10:49 <shapr> glguy: I just like to be able to dump the current buffer into ghci directly with a keystroke.
12:10:52 <zafoeta> i was looking at some tests
12:11:13 <glguy> shapr: ah. I know that you *can* do that in Vim if you wanted to write the command yourself
12:12:30 <LoganCapaldo> is there an interactive haskell environment that pretends its a top level?
12:13:07 <glguy> you mean ghci?
12:14:29 <LoganCapaldo> s/top level/module ?
12:14:45 <LoganCapaldo> I thought ghci pretended it was  do block anyway?
12:15:43 <glguy> hmmm.. what are you trying to do?
12:15:45 <sjanssen> kind of
12:17:58 <LoganCapaldo> Mostly, just not type colon :). its the eternal I want to say "data Foo =..." in the interpreter complaint
12:18:36 <glguy> oh, ok
12:20:03 <LoganCapaldo> hehe I guess I could write a program that would constantlly append to a file that it ran runhaskell on :)
12:23:23 <hpaste>  mux pasted "How does this look?" at http://hpaste.org/1763
12:24:00 <Laney> Woohoo, my first use of monad transformers
12:24:49 <mux> still impressingly incomplete :-(
12:25:50 * Cale twitches at all the people on reddit who seem to think that closures are a language feature.
12:26:19 <DRMacIver> Just treat 'closure' as dysfunctional-programmer speak for 'anonymous function' and you'll be happy. :)
12:26:30 <SamB> DRMacIver: eh.
12:26:46 <Cale> Except that they're getting into debates where that's not a reasonable thing to do anymore.
12:26:48 <DRMacIver> s/anonymous/first class/
12:26:51 <SamB> I thought it was something which had captured some variables from its lexical scope
12:26:57 <DRMacIver> SamB: It is.
12:27:12 <SamB> not necessarily an anonymous function
12:27:18 <Cale> A closure is a pair consisting of some code with free variables, and a dictionary binding those free variables to values.
12:27:19 <DRMacIver> SamB: But among people who don't know that it's often used as a synonym for first class functions.
12:27:25 <SamB> in Python, it could be a class!
12:27:50 <Cale> I don't know of any language which provides closures as a basic data structure :)
12:28:39 <glguy> Yeah.. there were *pages* after *pages* of pjdelport and kawa bickering over whether Java's AICs were closures, broken closures, or neither
12:28:45 <Cale> They're an implementation mechanism for functions, but the distinction is important.
12:28:49 <Philippa> Cale: there must've been a lisp that did it
12:28:57 <Cale> Philippa: possibly. :)
12:29:05 <glguy> they went about 17 nested levels in one thread, and then started a new one
12:29:15 <DRMacIver> Ok, if the misunderstanding is relevant then I agree.
12:29:16 <dolio> Whoa, glguy is alive. :)
12:29:23 <Philippa> early implementations often did use an association list to store their environments
12:29:27 <arjanoosting> Igloo: for my own packages I also build -doc pacakge so if your packages don't do that yet I will add that as well.
12:29:38 <glguy> dolio: I've been logged in since April 10 :)
12:29:49 <arjanoosting> Igloo: /window size 20
12:29:52 <Igloo> arjanoosting: So you leave the docs for each package separate?
12:29:53 <arjanoosting> euh
12:29:58 <Igloo> heh
12:31:07 <Igloo> arjanoosting: I build libghc6-foo-doc, but it gets moerged into the ghc6 docs, and the docs for base at least presumably differ between ghc6 and hugs at the moment
12:31:17 <arjanoosting> Igloo: I usually build a libghc6-*-dev, a libgh6-*-prof, a libhugs-* and a haskell-*-doc package from each source package
12:32:00 <Igloo> arjanoosting: *nod*, the problem there is they get separate haddock contents/indexes, though
12:33:08 <dolio> I like the Maybe vs. null discussion. manuelg is on a "mission from God to stamp out stupidity," like the stuff that Lennart Augustsson says. :)
12:33:27 <glguy> dolio: do you have a link to that statement? :)
12:33:30 <arjanoosting> Igloo: true. But if they properly link to each other that is not a real problem is it?
12:34:01 <dolio> glguy: http://programming.reddit.com/info/1ocpl/comments/c1os6x
12:34:03 <lambdabot> Title: Why Maybe is Superior to Null Pointers (and Python&#39;s None) (reddit.com)
12:34:17 <glguy> dolio: I noticed this snippet "My blood pressure has not risen. I am enjoying myself."
12:34:47 <Igloo> arjanoosting: Well, it means you need to know which index/contents to look in. Also, if you do cross link, then you again have the problem of ghc6 and hugs both having their own base docs
12:36:03 <nominolo> @seen baughn
12:36:03 <lambdabot> baughn is in #haskell. I last heard baughn speak 9h 21m 43s ago.
12:38:37 <arjanoosting> Igloo: true. But I think we should try to keep the libhugs-* package in sync with the libghc-* packages which should be possible with the modular Hugs packaging we have now.
12:38:38 <nominolo> does lambdabot send messages to unidentified users?
12:38:38 <Baughn> nominolo: I'm still digesting that code.
12:38:57 <nominolo> Baughn: ah, heh
12:39:11 <nominolo> I didn't manage to make it more general
12:39:13 <glguy> nominolo: I'd doubt that lambdabot verifies whether you are identified before it sends
12:39:28 <Igloo> arjanoosting: Oh, definitely, I'm just wondering if we should have 2 doc packages as well as 2 library packages
12:39:46 <nominolo> Baughn: probably needs more effort
12:40:13 <Baughn> nominolo: Regardless, I think maybe I should get through the haskell school of expression before I try understanding it
12:40:16 <SamB> Igloo: couldn't we just use the GHC-based docs packages?
12:40:45 <mux> @hoogle maybeToBool
12:40:46 <lambdabot> No matches found
12:41:06 <SamB> you could seperate the GHC manual(s) from the base module documentation...
12:41:18 <arjanoosting> Igloo: two docs packages? I was thinking we should have one source package which build a package for hugs, opne for ghc6 and a docs pacakge
12:41:24 <mauke> @hoogle Maybe a -> Bool
12:41:25 <lambdabot> Maybe.isJust :: Maybe a -> Bool
12:41:25 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
12:41:36 <mux> I'd want maybe False (const True)
12:41:39 <davidL> @index inits
12:41:40 <lambdabot> Data.List
12:41:41 <nominolo> Baughn: ah.  I knew your nick from #lisp.  But I'm now a pretty serious Haskeller ;)
12:42:04 <Baughn> nominolo: Ironically, I've been too busy learning category theory to bother with Haskell
12:42:07 <mux> @djinn Maybe a -> Bool
12:42:08 <lambdabot> f a =
12:42:08 <lambdabot>     case a of
12:42:08 <lambdabot>     Nothing -> False
12:42:08 <lambdabot>     Just _ -> True
12:42:16 <mux> heh, good djinn.
12:42:22 <nominolo> Baughn: heh
12:42:47 <mux> @. djinn pl Maybe a -> Bool
12:42:48 <lambdabot> Cannot parse command
12:42:49 <lambdabot> Cannot parse command
12:42:49 <lambdabot> Cannot parse command
12:42:56 <mux> ah, too bad djinn is multi-line
12:43:27 <glguy> mux: wouldn't it be: @. pl djinn
12:43:37 <mauke> f = isJust
12:44:01 <mux> glguy: I think it's first command, then second command
12:44:02 <LoganCapaldo> @ty isRight
12:44:04 <lambdabot> Not in scope: `isRight'
12:44:08 <LoganCapaldo> drat
12:44:09 <mux> @. arr eleet
12:44:10 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "eleet"
12:44:15 <mux> @eleet lala
12:44:16 <lambdabot>  Parse error
12:44:16 <Baughn> @hoogle Boolean -> a -> a -> a
12:44:17 <lambdabot> No matches, try a more general search
12:44:27 <glguy> @elite test
12:44:28 <Baughn> @hoogle Bool -> a -> a -> a
12:44:28 <lambdabot> 73z7
12:44:29 <lambdabot> No matches, try a more general search
12:44:30 * shapr cheers!
12:44:40 <Baughn> I keep forgetting that. Hmm, no function for if?
12:44:40 <mux> @. hoogle elite Bool -> a
12:44:41 <lambdabot> Hoogle Error: Parse Error: Unexpected character '4'
12:44:41 <glguy> mux: @. works like (.)
12:44:56 <mux> @. pl djinn Maybe a -> Bool
12:44:57 <lambdabot> (line 3, column 13):
12:44:57 <lambdabot> unexpected ">" or "-"
12:44:57 <lambdabot> expecting variable, "(", operator or end of input
12:45:04 <mux> still no go because of multi-line though :-)
12:45:19 <nominolo> Baughn: if is built-in
12:45:30 <LoganCapaldo> > let isRight = either False (const True) in (isRight (Right 3), isRight (Left "foo"))
12:45:31 <lambdabot>  Couldn't match expected type `a -> c' against inferred type `Bool'
12:45:33 <Baughn> nominolo: It is, but I expected to see a function that does the same
12:45:35 <mauke> @hoogle if
12:45:36 <lambdabot> Prelude.if :: keyword
12:45:36 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
12:45:36 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
12:45:42 <LoganCapaldo> @type either
12:45:44 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:46:01 <LoganCapaldo> > let isRight = either (const False) (const True) in (isRight (Right 3), isRight (Left "foo"))
12:46:03 <lambdabot>  (True,False)
12:46:07 <nominolo> Baughn: what would duplicating the functionality accomplish?
12:46:39 <LoganCapaldo> @type isRight &&& isJust
12:46:41 <lambdabot> Not in scope: `isRight'
12:46:58 <LoganCapaldo> @let isRight = either (const False) (const True) in (isRight (Right 3), isRight (Left "foo"))
12:46:59 <lambdabot>  Parse error
12:47:07 <LoganCapaldo> @let isRight = either (const False) (const True)
12:47:08 <Baughn> nominolo: It'd allow me to use if as a function. Haskell sometimes confuses me - it's not as minimal as scheme, but it certainly doesn't have as many variations on a theme as CL.
12:47:09 <lambdabot> Defined.
12:47:13 <LoganCapaldo> @type isRight &&& isJust
12:47:16 <lambdabot> Not in scope: `isRight'
12:47:18 <mauke> @pl \c a b -> if c then a else b
12:47:18 <lambdabot> if'
12:47:20 <Baughn> Wait, let now works?
12:47:24 <LoganCapaldo> @type L.isRight &&& isJust
12:47:26 <lambdabot> Couldn't find qualified module.
12:47:58 <LoganCapaldo> @type let isRight = either (const False) (const True) in isRight &&& isJust
12:47:59 <nominolo> @environment
12:48:01 <lambdabot>     Couldn't match expected type `Either a b'
12:48:01 <lambdabot>            against inferred type `Maybe a1'
12:48:01 <lambdabot> Unknown command, try @list
12:48:03 <dolio> It got fixed a day or two ago.
12:48:12 <LoganCapaldo> @type &&&
12:48:14 <lambdabot> parse error on input `&&&'
12:48:21 <LoganCapaldo> @type (&&&)
12:48:23 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:48:33 <LoganCapaldo> right thats not what I wanted
12:48:40 <nominolo> :t (***)
12:48:42 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:49:00 <LoganCapaldo> :(
12:49:05 <LoganCapaldo> won't read the same
12:49:13 <LoganCapaldo> so much for my career in Haskell poetry
12:50:05 <dolio> @type isRight . fst &&& isJust . snd
12:50:07 <lambdabot> Not in scope: `isRight'
12:50:53 <mux> dcoutts_: are you planning to release a new gtk2hs version soon?
12:51:19 <dcoutts_> mux: possibly a minor version bump, why?
12:51:45 <matthew-_> how do I stop ghc from lifting explicit quantification outwards?
12:51:45 <dcoutts_> mux: you're not talking about windows installers are you?
12:51:49 <mux> just because of that colorSelectionDialog patch; would make my life easier if it was in an official release
12:51:54 <mux> no, not at all :)
12:51:55 <dcoutts_> mux: ah ok
12:52:36 <dcoutts_> mux: aye, we've got a number of minor fixes and we need a new windows build for ghc-6.6.1 so a minor release would make sense
12:56:13 <shapr> @seen CosmicRay
12:56:14 <lambdabot> I saw CosmicRay leaving #haskell 1d 18h 59m 15s ago, and .
12:56:24 <shapr> Has anyone here used HsLogger?
12:56:31 <shapr> I can't get it to log to a file.
12:58:14 * glguy is quite surprised that a windows build for 6.6.1 has yet to surface on h.o
13:02:01 <dcoutts_> glguy: the guy who normally does them is busy so ndm has made one using a different (Open Source) installer builder
13:02:39 <glguy> dcoutts_: very good then, is there a link on h.o with the interim solution?
13:03:26 <dcoutts_> glguy: http://haskell.org/ghc/dist/6.6.1/ghc-6.6.1-i386-windows-test1.exe
13:03:26 <dan__> hello cinimod
13:03:27 <lambdabot> http://tinyurl.com/2qgjvu
13:03:32 <cinimod> hi dan
13:03:50 <shapr> Is there some way to get #ifdef UNIX to work correctly from cabal?
13:04:11 <glguy> dcoutts_: is this better: ghc-6.6.1-i386-windows.exe                    08-May-2007 10:50   28M
13:04:17 <shapr> cinimod: Are you Dom Steinitz?
13:04:31 <cinimod> shapr: yes
13:04:34 <dcoutts_> shapr: not really, cabal doesn't add those kind of CPP defines automatically
13:04:38 <shapr> cinimod: Spiffy! I'm Shae Erisson!
13:04:43 <shapr> cinimod: Nice to meet you in realtime!
13:05:15 <dcoutts_> shapr: you can manually add cpp defines in the .cabal file, but not have them conditional on the platform. That needs cabal configurations.
13:05:20 <cinimod> shapr: likewise
13:05:22 <shapr> dcoutts_: I'd like to have some way to get cabal to add -DUNIX to ghc-options.
13:05:51 <shapr> cinimod: Thanks for sending me Language.ASN1
13:05:52 <dcoutts_> shapr: you want cabal configurations. We've got a spec and we need someone to implement it.
13:06:19 <cinimod> shapr: no problems - I'm working on PER at the moment
13:06:23 <nominolo> Ey!  You have one to implement it!
13:06:30 * nominolo <--
13:06:55 <dcoutts_> shapr, cinimod: ASN1? the crazy binary format right? Where does that code live? I'm looking into a parsing layer for the binary package.
13:07:17 <shapr> cinimod: When do we get XER? ;-)
13:07:27 <dcoutts_> I'd like to see some real binary parsing code to try and figure out what the right set of combinators should be
13:08:19 <cinimod> dcoutts_: it's in hackage - I'm on the phone at the moment
13:08:26 <_frederik_> valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
13:08:33 <_frederik_> what is the third argument?
13:09:04 <shapr> _frederik_: A list of DecQ?
13:09:21 <_frederik_> thanks, shapr
13:09:24 * shapr grins
13:09:32 <davidL> why do I always get errors when doing `map read`
13:09:43 <emu> can't do function application inside ``
13:09:50 <emu> i know, it sucks
13:09:59 <davidL> I'm not using those marks
13:10:13 <davidL> those are just there for quotation
13:10:16 <Heffalump> what are you mapping read over?
13:10:18 <LoganCapaldo> poor selection of quoting characters :)
13:10:20 <emu> ah, confusion
13:10:27 <mauke> what are you doing with the result list?
13:10:30 <davidL> Heffalump: a list of strings
13:10:31 <emu> what kind of errors? perhaps you haven't specified your types well enough
13:10:37 <DRMacIver> davidL: Try adding a type signature
13:10:49 <emu> read is overloaded and ambiguous when used alone
13:11:06 <LoganCapaldo> @type map read
13:11:08 <lambdabot> forall a. (Read a) => [String] -> [a]
13:11:54 <cinimod> @type (>>=)
13:11:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:11:59 <LoganCapaldo> @type map read ["1", "2", "3"]
13:12:01 <lambdabot> forall a. (Read a) => [a]
13:12:03 <mauke> > map succ . map read $ words "1 2 3 4"
13:12:05 <lambdabot>  [2,3,4,5]
13:12:15 <LoganCapaldo> > map read ["1", "2", "3"]
13:12:17 <lambdabot>  [1,2,3]
13:12:28 * LoganCapaldo really wanted an error
13:12:34 <emu> lambdabot is defaulting
13:12:42 <LoganCapaldo> > map read ["True", "True", "False"]
13:12:42 <emu> try it in ghci
13:12:43 <lambdabot>  Exception: Prelude.read: no parse
13:12:50 <LoganCapaldo> and not that error
13:13:07 <emu> > take 1 $ map read ["True","1","2"]
13:13:09 <lambdabot>  Exception: Prelude.read: no parse
13:13:13 <emu> > take 1 $ map read ["1","True","2"]
13:13:15 <lambdabot>  [1]
13:13:26 <davidL> @type map read ["hello","world","hmmm"]
13:13:28 <lambdabot> forall a. (Read a) => [a]
13:13:35 <LoganCapaldo> > map read ["True", "True", "False"] :: Bool
13:13:37 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[a]'
13:13:41 <glguy> > map read ["True
13:13:42 <lambdabot>  Improperly terminated string
13:13:43 <LoganCapaldo> > map read ["True", "True", "False"] :: [Bool]
13:13:45 <lambdabot>  [True,True,False]
13:13:47 <glguy> > map read ["True"] :: [Bool]
13:13:48 <lambdabot>  [True]
13:14:35 <davidL> thanks
13:15:28 <LoganCapaldo> type classes vs. type inference. A never ending battle of wills to see who will save more programmer keystrokes
13:15:54 <emu> i'll take type classes.  ML makes a horrible mess of that shit.
13:16:20 <Sgeo> Is my explanation for http://hpaste.org/1753 correct?
13:16:38 <Sgeo> @fact goldilocks
13:17:02 <ski> > let coerce = read . show in coerce (5 `div` 2) / 3
13:17:04 <lambdabot>  0.6666666666666666
13:17:22 <emu> may i suggest 1 as your base case
13:17:42 <LoganCapaldo> Sgeo: looks correct. why not have a expo [x] = case ?
13:17:59 * Sgeo was only attempting to explain the error
13:18:30 <LoganCapaldo> s'ok
13:19:15 <Sgeo> Mind you, expo [x] would be expo (x:[]) which would call expo []
13:19:33 <Sgeo> ..wait
13:19:40 <Sgeo> n/m
13:20:02 <chessguy> hi haskellers
13:20:06 <LoganCapaldo> well hopefully you'd write different code after the = :)
13:20:34 <LoganCapaldo> or (s)he would rather
13:21:42 <Sgeo> > fromJust Nothing
13:21:56 * Sgeo is on ignore from the bot
13:21:58 <Sgeo> I think
13:22:09 <glguy> ?bot
13:22:10 <lambdabot> :)
13:22:10 <cinimod> dcoutts_:http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ASN1-0.0.1
13:22:13 <lambdabot> http://tinyurl.com/yov8m6
13:22:25 <LoganCapaldo> > fromJust Nothing
13:22:27 <lambdabot>  Exception: Maybe.fromJust: Nothing
13:22:38 <LoganCapaldo> Seems that way
13:22:55 <cinimod> dcoutts_: and http://www.haskell.org/asn1/
13:22:56 <LoganCapaldo> > error "Maybe.fromJust: Nothing"
13:22:57 <lambdabot> Title: The ASN.1 Library
13:22:57 <lambdabot>  Exception: Maybe.fromJust: Nothing
13:23:05 <dcoutts_> cinimod: ta
13:23:26 <LoganCapaldo> > const 1 (error undefined)
13:23:28 <lambdabot>  1
13:23:41 <LoganCapaldo> laaaaazy lambdabot
13:23:45 <emu> error undefined seems redundant
13:23:56 <emu> @time lambdabot
13:23:56 <lambdabot> I live on the internet, do you expect me to have a local time?
13:23:57 <LoganCapaldo> I wanted parentheses
13:24:05 <emu> Internet Standard Time
13:24:07 <sjanssen> > fix error
13:24:09 <lambdabot>  Exception: <<loop>>
13:24:22 <emu> bug-fixing is undecidable
13:24:57 <LoganCapaldo> > fix (const 1)
13:24:59 <lambdabot>  1
13:25:24 <LoganCapaldo> @type fix . const
13:25:26 <lambdabot> forall a. a -> a
13:25:27 <chessguy> ?src const
13:25:28 <lambdabot> const x _ = x
13:25:33 <LoganCapaldo> @type id
13:25:36 <lambdabot> forall a. a -> a
13:25:56 <LoganCapaldo> @free fix
13:25:58 <lambdabot> f . g = h . f => f (fix g) = fix h
13:26:09 <LoganCapaldo> @free constt
13:26:09 <LoganCapaldo> @free const
13:26:11 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `constt'\n\n"
13:26:13 <lambdabot> f . const x = const (f x) . g
13:26:24 <glguy> I once read something about FreeBSD's X server supporting some feature of font antialiasing that linux distributions generally won't due to patents or similar
13:26:31 <glguy> anyone know what that was?
13:27:01 <igli> eh?
13:27:12 <dcoutts_> glguy: some kinds of font hinting
13:27:24 <LoganCapaldo> @type (\f g x -> f x (g x))
13:27:25 <dcoutts_> glguy: it's a freetype thing, not specifically X
13:27:27 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
13:27:36 <glguy> dcoutts_: ah
13:27:44 <glguy> dcoutts_: I'll have to switch up my google keywords
13:27:57 <LoganCapaldo> @hoogle (a -> b -> c) -> (a -> b) -> a -> c
13:27:58 <lambdabot> No matches, try a more general search
13:28:02 <dcoutts_> cinimod: how do you do the binary parsing would you say? I don't see any obvious parser monad kind of thing.
13:28:47 <LoganCapaldo> @type (\f g x -> f x (g x)) (+ 1)
13:28:48 <shoffsta> glguy: you mean cleartype?
13:28:50 <lambdabot> forall t t1. (Num (t -> t1)) => ((t -> t1) -> t) -> (t -> t1) -> t1
13:29:01 <LoganCapaldo> @type (\f g x -> f x (g x)) (+) (+ 1)
13:29:03 <lambdabot> forall a. (Num a) => a -> a
13:29:17 <LoganCapaldo> @type (\f g x -> f x (g x)) (+) (+ 1) 4
13:29:19 <lambdabot> forall a. (Num a) => a
13:29:23 <glguy> shoffsta: Does FreeBSD ship with cleartype enabled? (or even available?)
13:29:28 <LoganCapaldo> > (\f g x -> f x (g x)) (+) (+ 1) 4
13:29:30 <lambdabot>  9
13:29:35 <Saizan> ?type ap
13:29:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:29:56 <shoffsta> glguy: I don't know
13:29:58 <LoganCapaldo> > (\f g x -> f x (g x)) (,) id 2
13:30:00 <lambdabot>  (2,2)
13:30:47 <Saizan> LoganCapaldo: (r -> (a -> b)) -> (r -> a) -> r -> b <-- ap in the (r (->)) monad
13:30:56 <LoganCapaldo> Saizan: I know
13:31:07 <Saizan> oh ok
13:31:09 <LoganCapaldo> > ap (,) id 2
13:31:11 <lambdabot>  (2,2)
13:32:37 <TantumLex> is it possible to have lambdabot expressions that normally would go on multiple lines?
13:33:14 <TantumLex> > 2 + x where x = 2
13:33:15 <lambdabot>  Parse error
13:34:05 <Heffalump> TantumLex: that's not a valid expression
13:34:11 <Heffalump> where applies to declarations, not expressions
13:34:27 <Heffalump> > let y = 2 + x where x = 2 in y
13:34:29 <lambdabot>  4
13:35:18 <TantumLex> > let y = 2 + x + z where x = 2; z = 3 in y
13:35:20 <lambdabot>  7
13:35:26 <TantumLex> nice
13:36:03 <cinimod> dcoutts_: the binary stuff is done in TLV.hs
13:37:13 <dcoutts_> cinimod: yes, It looks deceptively simple :-)
13:37:27 <LoganCapaldo> @type ap (flip (.)) (+) (const 3)
13:37:29 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
13:37:30 <lambdabot>     Probable cause: `+' is applied to too few arguments
13:37:47 <cinimod> dcoutts_: But then you have to typecheck it to make sure it conforms to the ASN.1 spec
13:38:02 <TantumLex> @pl f x = y + x
13:38:02 <lambdabot> f = (y +)
13:38:07 <cinimod> dcoutts_: All TLV does is turn it into tag length and value
13:38:08 <dcoutts_> cinimod: right, but by that time it's no longer in binary format.
13:38:13 <dmhouse> Hey all. If you do hGetLine h >> hGetLine h, the two calls probably won't return the same string. Where is this difference in state represented? It can't be h as by referential transparency h has the same value in both calls, so perhaps in a global mutvar or something?
13:38:14 <TantumLex> @pl f x = y + x where y = 2
13:38:15 <lambdabot> (line 1, column 21):
13:38:15 <lambdabot> unexpected "="
13:38:15 <lambdabot> expecting variable, "(", operator, "+", "-" or end of input
13:38:25 <TantumLex> boo
13:38:34 <cinimod> dcoutts_: unfortunately it uses the unfortunately named newbinary
13:38:50 <mauke> dmhouse: why does it need to be represented?
13:39:10 <LoganCapaldo> @type ap (+) (const 2)
13:39:12 <lambdabot> forall a. (Num a) => a -> a
13:39:14 <dcoutts_> cinimod: yes. I'm currently hacking on the 'new' Binary package, aka Data.Binary
13:39:20 <LoganCapaldo> @type (+2)
13:39:23 <lambdabot> forall a. (Num a) => a -> a
13:39:28 <dmhouse> mauke: put it a different way. Say I want to define my own Handle-like type. Where would I indicate the change in state?
13:39:43 <mauke> in what monad?
13:40:01 <LoganCapaldo> @check (\n -> ap (+) (const 2) n == (+2)) :: Integer -> Bool
13:40:02 <cinimod> coutts_: and I will get round to using it but I want to crack PER first
13:40:02 <lambdabot>      The section `(+ 2)' takes one argument,     but its type `Integer' has n...
13:40:12 <LoganCapaldo> @check (\n -> ap (+) (const 2) n == (+2) n) :: Integer -> Bool
13:40:14 <lambdabot>  OK, passed 500 tests.
13:40:27 <dmhouse> mauke: in IO.
13:41:07 <mauke> dmhouse: you could do it on top of IORef
13:41:17 <dcoutts_> cinimod: right'o
13:41:25 <dmhouse> mauke: so a global mutvar, then.
13:41:35 <mauke> IORefs aren't global
13:41:38 <dmhouse> Or unless you mean make the handle the IORef...
13:41:38 <LoganCapaldo> @check (\f n v -> ap f (const n) v == (f n) v)
13:41:40 <lambdabot>  Add a type signature
13:41:40 <dmhouse> Ah, nice idea.
13:42:05 <LoganCapaldo> @check (\f n v -> ap f (const n) v == (f n) v) :: (Integer -> Integer) -> Integer -> Bool
13:42:06 <lambdabot>      The lambda expression `\ f n v -> ...' has three arguments,     but its ...
13:42:17 <LoganCapaldo> @check (\f n v -> ap f (const n) v == (f n) v) :: (Integer -> Integer) -> Integer -> Integer -> Bool
13:42:18 <lambdabot>  Couldn't match expected type `a1 -> a'
13:42:51 <LoganCapaldo> @check (\f n v -> ap f (const n) v == (f v) n) :: (Integer -> Integer) -> Integer -> Integer -> Bool
13:42:52 <lambdabot>  Couldn't match expected type `a1 -> a'
13:42:56 <LoganCapaldo> mmm
13:43:29 <LoganCapaldo> Can QuickCheck even create random functions?
13:44:19 <chessguy> yes
13:44:40 <nominolo> @src foldl
13:44:40 <lambdabot> foldl f z xs = lgo z xs
13:44:41 <lambdabot>     where lgo z []     =  z
13:44:41 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:44:43 <LoganCapaldo> chessguy: so do you know what I am doing wrong?
13:44:53 <chessguy> nope, not a clue
13:45:01 <LoganCapaldo> Ok :)
13:45:07 <chessguy> but then, i haven't been paying attention
13:45:18 <chessguy> and i don't remember how to do it correctly anyway
13:45:25 <mux> @src asTypeOf
13:45:26 <lambdabot> asTypeOf = const
13:45:43 <mauke> LoganCapaldo: the type of f is wrong
13:45:43 <matthew-_> what do you imagine "Cannot match a monotype with `forall f. (Num f) => f -> f' means?
13:45:52 <mauke> f must be a combiner
13:45:56 <chessguy> i just remember looking through a slide show on quickcheck that talked about being able to generate random functions
13:45:57 <LoganCapaldo> mauke: of course it is
13:46:02 <nominolo> @djinn (a -> a) -> (a -> a -> a) -> a
13:46:03 <lambdabot> -- f cannot be realized.
13:46:04 <LoganCapaldo> duh
13:46:16 <LoganCapaldo> @check (\f n v -> ap f (const n) v == (f v) n) :: (Integer -> Integer -> Integer) -> Integer -> Integer -> Bool
13:46:18 <lambdabot>  OK, passed 500 tests.
13:46:22 <LoganCapaldo> huzzah
13:46:24 <LoganCapaldo> wow
13:46:31 <LoganCapaldo> random functions cool :)
13:46:41 <LoganCapaldo> mauke: thanks
13:46:53 <SamB> what is some good parallelism propaganda?
13:47:11 <chessguy> @type id
13:47:14 <lambdabot> forall a. a -> a
13:47:20 <nominolo> SamB: it's required by modern CPUs?
13:47:20 <Cheery> this FRP -stuff is somehow annoying
13:47:21 <chessguy> @type const
13:47:24 <lambdabot> forall a b. a -> b -> a
13:47:26 <mauke> @quote
13:47:27 <lambdabot> JaffaCake says: I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
13:47:39 <SamB> I meant, propaganda about how nice Haskell is for it...
13:48:09 <matthew-_> SamB: I'm not convinced it is. At least, not until I've finished my PhD ;-)
13:48:10 <nominolo> @pl \x y -> f y
13:48:11 <lambdabot> const f
13:48:26 <SamB> but! map!
13:48:35 <SamB> basically I want map propaganda
13:48:40 <nominolo> > foldl const 0 [(1+),(2+)]
13:48:41 <lambdabot>  0
13:48:53 <chessguy> SamB: www.google.com :)
13:49:07 <chessguy> map is half of google
13:49:10 <nominolo> > foldl ($) 0 [(1+),(2+)]
13:49:11 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
13:49:11 <lambdabot>     Probabl...
13:49:41 <mauke> > foldl (flip id) 0 [(1+),(2+)]
13:49:43 <lambdabot>  3
13:49:56 <nominolo> > foldl (flip ($)) 0 [(1+),(2+)]
13:49:58 <lambdabot>  3
13:50:10 <chessguy> heh
13:50:11 <mauke> flip id is shorter
13:50:15 <chessguy> thus $ = id :)
13:50:21 <nominolo> :t flip id
13:50:23 <lambdabot> forall b c. b -> (b -> c) -> c
13:50:43 <chessguy> ?src ($)
13:50:44 <lambdabot> f $ x = f x
13:50:46 <mux> oooh, I get how asTypeOf works
13:50:56 <mux> it's not the implementation that matters, but the type signature of it
13:50:58 <mux> @type const
13:51:00 <lambdabot> forall a b. a -> b -> a
13:51:01 <mux> @type asTypeOf
13:51:04 <lambdabot> forall a. a -> a -> a
13:51:04 <mauke> @. djinn type flip id
13:51:07 <lambdabot> f a b = b a
13:51:21 <mux> smart trick
13:51:22 <chessguy> @free flip id
13:51:22 <lambdabot> Extra stuff at end of line
13:51:27 <chessguy> @free flip.id
13:51:28 <lambdabot> Extra stuff at end of line
13:51:33 <chessguy> @free flip
13:51:35 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
13:51:57 <nominolo> @help free
13:51:58 <lambdabot> free <ident>. Generate theorems for free
13:52:15 <LoganCapaldo> @help cheap
13:52:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:52:21 <chessguy> so what haskell libraries are there for web programming? i know of Text.Html, Text.Xhtml, hApps, the Network packages,...am i missing any?
13:52:28 <mauke> :t \x y = let _ = [x,y] in x
13:52:30 <lambdabot> parse error on input `='
13:52:32 <Cheery> @free Int -> Int
13:52:33 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:52:37 <mauke> :t \x y -> let _ = [x,y] in x
13:52:39 <lambdabot> forall t. t -> t -> t
13:52:45 <nominolo> > foldl (flip ($)) 0 [(1+),(2*)]
13:52:47 <lambdabot>  2
13:52:53 <Heffalump> @free a -> [a]
13:52:53 <lambdabot> Extra stuff at end of line
13:52:58 <Heffalump> @free f :: a -> [a]
13:52:59 <lambdabot> $map g . f = f . g
13:53:12 <Cheery> I wonder how would one easily describe data structures/monads which get constructed reactively, ie. changing over time
13:53:44 <nominolo> Cheery: Arrows?
13:53:51 <Cheery> nah, arrows aren't the solution
13:53:52 <nominolo> using the Switch-cominator
13:54:04 <Cheery> they just contaminate the whole shit and make it worse to handle
13:54:34 <nominolo> Can't monads change?
13:54:52 <Heffalump> @free f :: a -> m a
13:54:52 <lambdabot> Extra stuff at end of line
13:55:16 <Cheery> I'd want to get something like a reactive sheet for monads
13:55:32 <LoganCapaldo> (join . return) f = f -- does that count? :)
13:55:33 <dolio> @free f :: a -> M a
13:55:34 <lambdabot> $map_M g . f = f . g
13:56:02 <Cheery> that you could then write stuff similar to how you'd write stuff in flapjax
13:56:33 <TantumLex> @pl Y = (\g -> (\x -> g (x x)) (\x -> g (x x)))
13:56:34 <lambdabot> Y = ap (. join id) (. join id)
13:56:40 <mux> what's the ghc flag to have it dump the System F it generates - or approaching?
13:56:44 <TantumLex> @unpl Y = ap (. join id) (. join id)
13:56:45 <lambdabot> Y = (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ b p -> b (((\ a -> a) >>= \ k -> k) p)) (\ d s -> d (((\ c -> c) >>= \ m -> m) s))
13:56:58 <TantumLex> @pl Y = (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ b p -> b (((\ a -> a) >>= \ k -> k) p)) (\ d s -> d (((\ c -> c) >>= \ m -> m) s))
13:56:58 <lambdabot> Y = (. join id) >> join (join id) `fmap` (. join id)
13:57:05 <nominolo> it's system F_C now! ;P
13:57:10 <TantumLex> @unpl Y = (. join id) >> join (join id) `fmap` (. join id)
13:57:10 <lambdabot> Y = (\ b p -> b (((\ a -> a) >>= \ f -> f) p)) >> (fmap (((\ c -> c) >>= \ j -> j) >>= \ h -> h) (\ e s -> e (((\ d -> d) >>= \ l -> l) s)))
13:57:13 <mux> yeah, but I only have 6.6 so :-)
13:57:21 <augustss> howdy
13:57:24 <TantumLex> @pl Y = (\ b p -> b (((\ a -> a) >>= \ f -> f) p)) >> (fmap (((\ c -> c) >>= \ j -> j) >>= \ h -> h) (\ e s -> e (((\ d -> d) >>= \ l -> l) s)))
13:57:25 <lambdabot> Y = (. join id) >> fmap (join (join id)) (. join id)
13:57:29 <chessguy> hi augustss
13:57:37 <TantumLex> @unpl Y = (. join id) >> fmap (join (join id)) (. join id)
13:57:38 <lambdabot> Y = (\ b p -> b (((\ a -> a) >>= \ f -> f) p)) >> (fmap (((\ c -> c) >>= \ j -> j) >>= \ h -> h) (\ e s -> e (((\ d -> d) >>= \ l -> l) s)))
13:57:44 <TantumLex> hah
13:57:58 <mux> augustss: hiya! saw a talk on the Girard-Reynold isomorphism, and F2 and P2, and now that I really know what it does, I'm way impressed by djinn :-)
13:58:28 <olsner> @help unpl
13:58:29 <lambdabot> pointful <expr>. Make code pointier.
13:58:44 <mauke> it's a code obfuscator
13:58:50 <Heffalump> I think there should be something to make code sharper too.
13:58:52 <nominolo> mux: maybe -ddump-ds
13:59:01 <nominolo> ds = desugarer
13:59:08 <mux> nominolo: thanks, will try that, or dig into GHC docs - I badly wanted to avoid that :D
13:59:14 <LoganCapaldo> @unpl (\x -> x + 1)
13:59:15 <lambdabot> (\ x -> x + 1)
13:59:19 <LoganCapaldo> oh
13:59:23 <augustss> mux: but djinn doesn't really do all of that, so no need to be so impressed
13:59:24 <Heffalump> @pl (\x -> x + 1)
13:59:24 <lambdabot> (1 +)
13:59:32 <nominolo> mux: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html#id3130643
13:59:34 <lambdabot> Title: 4.16. Debugging the compiler, http://tinyurl.com/t96uq
13:59:35 <Heffalump> that's wrong.
13:59:39 <Heffalump> @pl (\x -> x - 1)
13:59:40 <lambdabot> subtract 1
13:59:40 <LoganCapaldo> it doesn't add additional points :(
13:59:42 <mux> augustss: well it's cool anyways :)
13:59:51 <chessguy> LoganCapaldo: you might find http://www.cis.upenn.edu/~bcpierce/courses/advprog/lectures/lec18.pdf interesting
13:59:53 <Heffalump> LoganCapaldo: what extra points could \x -> x + 1 have?
13:59:54 <lambdabot> http://tinyurl.com/2ffepl
14:00:03 <augustss> mux: cool, but mostly useless :)
14:00:10 <mux> *nods*
14:00:18 <dmhouse> Is there a way, in Cabal, to have optional parts of a package which can be included or excluded using --configure switches, that possibly have different dependencies to the main package?
14:00:18 <LoganCapaldo> Heffalump: I dunno. That's what I wanted to see :)
14:00:26 <mux> I still find it very very nice to be able to say "that type can't be inhabited"
14:00:50 <mauke> (\x -> (\y -> (+) x y) 1)
14:00:56 <augustss> mux: yes, that is useful sometimes.  that's why i wrote it in the first place
14:01:02 <mux> mmm, -dump-ds makes my eyes bleed
14:01:08 <Heffalump> mauke: that's beta-expanding, not eta-expanding
14:01:14 <matthew-_> @type negate
14:01:16 <lambdabot> forall a. (Num a) => a -> a
14:01:16 <matthew-_> @type (return negate) >>= (\(f::forall a . (Num a) => a -> a) -> return ())
14:01:18 <LoganCapaldo> (\f x y -> f y x) (\x y -> x + 1) 0 maybe?
14:01:18 <lambdabot>     Couldn't match expected type `a -> a'
14:01:18 <lambdabot>            against inferred type `forall a1. (Num a1) => a1 -> a1'
14:01:23 <matthew-_> help!
14:01:27 <mauke> beta, eta, what's the difference
14:01:31 <mux> augustss: does GHC check and warn about those types if encountered in a program?
14:01:33 <LoganCapaldo> @type (\f x y -> f y x) (\x y -> x + 1) 0
14:01:34 <dmhouse> Heffalump: wrong, (\y -> (+) x y) eta-reduces to (+) x.
14:01:34 <mauke> (answer: 1)
14:01:35 <lambdabot> forall a. (Num a) => a -> a
14:01:41 <augustss> mux: no
14:01:51 <LoganCapaldo> > (\f x y -> f y x) (\x y -> x + 1) 0 7
14:01:53 <lambdabot>  8
14:02:02 <LoganCapaldo> See, lots more points! :)
14:02:24 <LoganCapaldo> chessguy: neat, thanks
14:02:36 <Heffalump> dmhouse: oh, good point
14:02:42 <shapr> arrow collections?
14:03:34 <ski> spear chains!
14:03:54 * dmhouse gets POP over SSL working, yay!
14:04:19 * dmhouse is still astonished by the complete lack of support that HaskellNet has for POP over SSL, does anyone actually do unencrypted POP these days?
14:04:45 <mux> many many people still do, sadly
14:05:06 <dmhouse> Now to clean everything up, make a module out of it, then master IMAP.
14:10:18 <Cheery> How hard is it to make a ghc extension?
14:10:29 <Cheery> ie. similar to -farrows
14:18:47 <andygill> Does anyone know of any work to write a new edition of nofib? some tests are running way to fast to actually test us anything.
14:19:08 <dmhouse> andygill: there is indeed a newer version, ping dons.
14:19:55 <andygill> Thanks dmhouse; I've have a look at dons already (it look good), but I'm trying to see if anyone else has done anything?
14:20:55 <dmhouse> Last time I looked dons's collection was pretty expansive and included contributions from a wide variety of people
14:31:58 <LoganCapaldo> This error I understand not:  Illegal instance declaration for `Parseable [Char]'
14:32:11 <chessguy> code?
14:32:23 <sjanssen> LoganCapaldo: use -fglasgow-exts and be happy
14:32:39 * LoganCapaldo thought he tried that...
14:33:01 <LoganCapaldo> ah I did
14:33:04 <LoganCapaldo> but with :set
14:33:08 <LoganCapaldo> which didn't work
14:33:09 <chessguy> maybe you weren't happy enough
14:33:17 <ski> the type argument to a type class in an instance declaration must be a type constructor applied to distinct type variables
14:33:18 <LoganCapaldo> now it doesn't work for totally different reasons :)
14:33:28 <sjanssen> Haskell '98 only allows instances that look like (T a b c ...), where T is a type constructor and a, b, c ... are distinct type variables
14:33:42 <LoganCapaldo> So i cna't make an instance of a given type?
14:33:57 <LoganCapaldo> That so wrecks my plan
14:34:07 <LoganCapaldo> good thing it was mostly a thought exercise
14:34:10 <bos> LoganCapaldo: just use a LANGUAGE directive to turn it on
14:34:20 <sjanssen> bos: do you know which directive it is?
14:34:40 <matthew-_> sjanssen: turn them all on, and then turn them off until it stops working
14:35:09 <bos> FlexibleInstances
14:35:10 <LoganCapaldo> well now It's complaining about rigid variables. I'm gonna apste my code and you can all point and laugh
14:35:22 <bos> {-# LANGUAGE FlexibleInstances #-}
14:35:36 <Cheery> gah, I think I'm going to point this annoying reactive programming with a gun
14:35:56 <Cheery> then it'd may start behaving
14:36:00 <bos> unfortunately, the ghc docs don't list the directive you need for each feature you want to enable.
14:36:03 <hpaste>  LoganCapaldo pasted "toying with classes" at http://hpaste.org/1764
14:36:15 <chessguy> bwahahahaha
14:37:29 <ski> is this 'LANGUAGE' some pragma thing ?
14:38:18 <ski> (s/pragma/possibly more widely supported pragma/)
14:38:36 <bos> ski: it's the standard way to say what h98 extensions you want to use
14:38:55 <sjanssen> is it supported by Hugs?
14:38:58 <ski> is it a haskell' extension ?
14:39:44 <LoganCapaldo> So am I making any sense?
14:40:17 <bos> yes, hugs supports it, but not all extensions.
14:40:40 <bos> LoganCapaldo: your typeclass definition looks squirrelly to me, but i'm no expert.
14:40:57 <LoganCapaldo> Well i'm a negative expert
14:40:59 <LoganCapaldo> :)
14:41:03 <LoganCapaldo> or anti-expert
14:42:18 <bos> LoganCapaldo: the best way to hunt down a problem like this is to change the way you write your code.
14:42:37 <bos> first, don't define the function body in the instance declaration.
14:42:45 <bos> hoist it to the top level of your module.
14:42:48 <LoganCapaldo> You can do that?
14:42:55 <LoganCapaldo> woah
14:42:57 <bos> yeah, just give it a different name.
14:43:05 <LoganCapaldo> aaaaaaa
14:43:08 <LoganCapaldo> interesting
14:43:17 <bos> for example, i renamed parse to arse :-)
14:43:24 <LoganCapaldo> heh
14:43:28 <bos> the next thing to do is give the function a type signature.
14:43:43 <bos> then comment out all of the instance declarations, and see if your code typechecks.
14:43:49 <bos> in your case, it doesn't.
14:44:07 <kpreid> LoganCapaldo: your Parseable looks unuseful; I think you actually want 'class Parseable a b where parse :: a -> b'
14:44:09 <LoganCapaldo> And then you suddenly realize that a (:) b where b is some Parseable clearly will not typecheck for instance :)
14:44:48 <LoganCapaldo> I have only myself to blame
14:44:54 <bos> kpreid's comment sounds correct to me, btw.
14:45:12 <bos> LoganCapaldo: also, you're trying to read a Char, instead of a [Char].
14:45:16 <kpreid> LoganCapaldo: for example, your 'parse [] = Empty' is invalid given the current class definition because it can't produce any Parseable. if you use a MPTC like I just gave, you can specify that this is Parseable [Char] Parsed, not something more general
14:45:36 <kpreid> also, ([] Char) == [Char]
14:45:51 <LoganCapaldo> re: [] Char == [Char] I know
14:46:04 <bos> so it's the usual divide and conquer approach; you had so many problems in the initial definition of the module that it was impossible to tell where to start.
14:46:05 <LoganCapaldo> I was trying to get a handle on the error messag
14:46:29 <bos> by trimming it way down, and rebuilding from there, you can make progress more quickly.
14:46:56 <LoganCapaldo> My original idea was that I wanted to have N stages of parsing
14:47:22 <LoganCapaldo> where the rhs of all the parses s would look like parse (after transformation by this stage of parsing)
14:47:36 <LoganCapaldo> so that when it hit parsed it would stop "recursing"
14:47:59 <LoganCapaldo> parse "foo" ---> some Parsed value
14:48:05 <LoganCapaldo> So that was the plan
14:48:12 <LoganCapaldo> it didn't work out clearly :)
14:51:03 <matthew-_> damn, turning digest mode for mailman off does not flush the waiting messages.
14:55:38 <takamura> hi
15:06:23 <sorear> hello.
15:06:40 <matthew-_> howdy
15:07:28 <sorear> matthew-_: Indeed, if you relax monomorphic lambda bindings you lose decidability.
15:08:29 <matthew-_> it is to do with the lambdas in return and >>= then?
15:09:17 <matthew-_> so if I reimplement them without using lambdas then suddenly the polymorphism will be passed through without issue?
15:09:57 <wy> I wonder if there is a visitor pattern equivalence in Haskell?
15:10:12 <sorear> matthew-_: yes.  but good luck doing it without lambdas!
15:10:30 <matthew-_> sorear: that was going to be my next question...
15:10:38 <sorear> 'f x = x * 2'  is technically a lambda
15:10:44 <matthew-_> oh bother
15:10:55 <matthew-_> when does it stop being a lambda?
15:11:04 <DRMacIver> wy: Why would there be?
15:11:14 <DRMacIver> wy: The visitor pattern is a hack for giving you pattern matching in languages which don't have it.
15:11:17 <sorear> matthew-_: when you use 'let'.
15:11:24 <sorear> matthew-_: but that's not as general
15:11:31 <monochrom> If you want a visitor for an algebraic data type, maybe it suffices to have the catamorphism for the data type.
15:11:51 <DRMacIver> wy: Haskell has pattern matching, so doesn't need visitors.
15:11:52 <matthew-_> eh? so every normally defined function is actually treated as a lambda?
15:12:01 <monochrom> If catamorphism doesn't suffice, maybe "traversal" does.
15:12:02 <sorear> matthew-_: there's a ghc extension which lets you have polymorphism in lambdabot bindings, at the cost of more type signatures.
15:12:02 <wy> DRMacIver: I don't actually understand what a vistor is. So I ask here just in order to map the concept into my Haskell knowledge.
15:12:03 <sorear> yes.
15:12:26 <DRMacIver> wy: It's basically an implementation of pattern matching. :)
15:12:27 <matthew-_> so it's actually only fluke that this works: let f (fn :: forall a . Num a => a -> a) a b = (fn a, fn b) in f negate
15:12:46 <matthew-_> i.e. without using the let to make it into a one-liner, it wouldn't work?
15:12:48 <monochrom> I used visitor once. I used to as a fold.
15:12:52 <sorear> matthew-_: actually, you're using the extension I just mentioned
15:12:55 <wy> augustss: Good to see you here! I started to learn the G-machine.
15:12:58 <monochrom> err. I used it as a fold.
15:13:11 <LoganCapaldo> @docs Data.Traversable
15:13:11 <lambdabot> Data.Traversable not available
15:13:19 <LoganCapaldo> Did I make that up?
15:13:41 <matthew-_> sorear: oh? Does that come on with glasgow-exts?
15:13:47 <sorear> matthew-_: yes.
15:14:04 <monochrom> If you want a vistor over a type class hierarchy, there may be something new.
15:14:22 <DRMacIver> monochrom: It's just multiple dispatch really. :)
15:14:38 <monochrom> It may be new but trivial.
15:14:44 <Cale> heh, reddit's indentation mechanism for messages sort of fails miserably on long threads :)
15:14:54 <DRMacIver> (Hardcore multiple dispatch a la Nice, but multiple dispatch nonetheless)
15:15:49 <wy> Actually I'm reading Appel's compiler book "in Java". If I'm not equipped with functional languages, I'd be totally confused now.
15:16:02 <sorear> Appel does Java?
15:16:10 <monochrom> Visitor is a workaround for lack of multiple dispatch. You should understand from that angle. All workarounds are hard to understand if you think of them as technology rather than workarounds.
15:16:27 <wy> sorear: Modern Compiler Implementation in Java
15:16:29 <matthew-_> sorear: but it seems it has to appear at every step: (\(w::forall w . Num w => w -> w) a b -> (w a, w b)) negate is fine, but (\f g -> g f) negate (\(w::forall w . Num w => w -> w) a b -> (w a, w b)) still blows up
15:16:30 <sorear> Yea, appel.  pretty famous for ML, never heard of him in the context of java
15:16:47 <monochrom> Yeah, I painstakingly avoided the "in Java" edition and looked for the "in ML" edition. My sanity was preserved.
15:16:49 <matthew-_> wy: that book is poor
15:16:57 <DRMacIver> For once I agree with monochrom. :)
15:17:05 <wy> monochrom: You got the ML one?
15:17:09 <monochrom> YES!
15:17:11 <DRMacIver> The correct way to view design patterns is "What feature is this making up for the lack of?"
15:17:43 <wy> mattam: It should be as poor as Java, but my library doesn't have the ML one.
15:17:51 <sorear> matthew-_: you've just run into a related but separate limitation in Hindley-Milner.
15:18:01 <monochrom> Dynamic typing is a workaround for some limitations of decidable static typing.
15:18:04 <sorear> @seen mattam
15:18:05 <lambdabot> mattam is in #haskell. I don't know when mattam last spoke.
15:18:16 <matthew-_> sorear: so it would seem that that level of polymorphism is just not generally useable.
15:18:41 <sorear> matthew-_: it's called 'predicativity', and it means that type variables cannot represent polymorphic types.
15:18:52 <DRMacIver> monochrom: I'm not going there. :)
15:19:09 <sorear> matthew-_: Right, not generally usable.  You can do it with even more extensions, but you shouldn't bother unless you have a reason.
15:19:43 <matthew-_> sorear: what's the downside to turning on the extra extensions?
15:19:48 <monochrom> Functional programming is a workaround for the lack of framing in imperative programming. "framing" means you can declare "in the following five lines, only x,y,z can be written to, all other variables read-only"
15:20:11 <monochrom> Computer is a workaround for the lack of intelligence.
15:20:14 <sorear> matthew-_: None, indeed it's also enabled with glasgow-exts.  but you need even more type signatures
15:20:42 <matthew-_> sorear: right, so in my last example, I'd have to put the extra types in the (\f g -> g f) func?
15:21:04 <wy> augustss: I've read your paper on Cayenne yesterday.
15:21:12 <matthew-_> sorear: so it's not every going to be generally composable with generic functions?
15:21:17 <sorear> matthew-_: Adding the types in that part would completely avoid polymorphism.
15:21:23 <ddarius> monochrom: Last I checked, computers vastly magnified lack of intelligence, not made up for it.
15:21:24 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
15:21:39 <sorear> matthew-_: You could do it using impredicative instantiation *prepares example*
15:21:48 <monochrom> Anyway, I thoroughly enjoy "modern compilers in ML". I do not understand any of the attacks on it.
15:22:01 * matthew-_ awaits with baited breath
15:22:03 <SamB> I will make an attack on it!
15:22:04 <ddarius> Yay impredicativity!
15:22:10 <LoganCapaldo> there are attacks on modern compilers in ML?
15:22:13 <wy> monochrom: So I might want to buy it.
15:22:16 <DRMacIver> monochrom: I thought they were attacking "Modern Compilers in Java"?
15:22:17 <SamB> "It is in ML, not Haskell, which is annoying."
15:22:24 <monochrom> ddarius: heh, that is a logical consequence. If there is a lack, any workaround will only make that lack more visible.
15:22:54 <monochrom> For example, design patterns make OOP look more bitter, not less.
15:22:55 <wy> monochrom: But I'm so disappointed by "* in Java", so I wonder what language is he trying to compile in the "in ML" version?
15:23:05 <monochrom> Still the same tiger.
15:23:23 <monochrom> What is the disappointment? Perhaps I can understand.
15:23:30 <matthew-_> sorear: wow, even this doesn't work: (\(f::forall t . (Num t) => t -> t) g -> g f) negate (\(w::forall w . Num w => w -> w) a b -> (w a, w b))
15:23:32 <sorear> @ty (flip :: (forall a b. (Num a, Num b) => (forall w. Num w => w -> w) -> (a, b) -> (a, b)) -> (forall w. Num w => w -> w) -> (forall a b. (Num a, Num b) => (a,b) -> (a,b))) negate (\(w::forall w . Num w => w -> w) a b -> (w a, w b))  --  this should work, note the huge ugly signature on flip
15:23:35 <lambdabot>     Couldn't match expected type `forall a b.
15:23:35 <lambdabot>                                   (Num a, Num b) =>
15:24:01 <DRMacIver> matthew-_: Er.r What the smurf are you trying to do? :)
15:24:21 <matthew-_> DRMacIver: super polymorphism magic beans
15:24:32 <wy> monochrom: Someone told me the Java version is just a translation from ML one. But the Java version is trying to compile a Java like language. Is the ML also compiling a Java like language?
15:24:41 <DRMacIver> matthew-_: Ookay.
15:25:10 <DRMacIver> Hm. Why do we have a PircBot in here? :)
15:25:38 <monochrom> "java like" is ambiguous. but my definition says "yes". my definition also says it is quite alright, since my definition of "java like" does not include the bad aspects.
15:25:38 <sorear> Bah, I give up.
15:25:48 <sorear> btw, Fw is much nicer for this
15:25:54 <matthew-_> sorear: lol, yeah, I can't make that work!
15:26:14 <DRMacIver> Fw?
15:26:17 <monochrom> anyway my understanding is both compiles the same language called "tiger"
15:26:18 <matthew-_> sorear: but I see what you're trying to do
15:26:35 <ski> there's some variants of tiger in the book
15:26:45 <wy> monochrom: So I can consider that one.
15:26:58 * DRMacIver goes to bed
15:26:59 <DRMacIver> night
15:27:11 <ski> istr there was a pure functional one, using CPS for IO
15:27:12 <matthew-_> sorear: Fw?
15:27:13 <sorear> DRMacIver: System FW!
15:27:18 <matthew-_> tnx
15:27:19 <sorear> it's a type system
15:27:21 <monochrom> within the book there is a core "tiger" that's just procedural. then one chapter adds functional extension. another adds oo extension. you can ignore the oo chapter.
15:27:23 <matthew-_> oh!
15:27:28 <sorear> much nicer than haskell's
15:27:29 <LoganCapaldo> what about System FTW?
15:27:37 <sorear> but less user friendly - too verbose
15:27:38 <LoganCapaldo> ;)
15:27:52 <matthew-_> sorear: less inferable?
15:28:21 <sorear> matthew-_: type systems specify how much is to be infered.
15:28:27 <monochrom> Does Google Book have a copy of the book? Maybe you can evaluate it there.
15:28:30 <sorear> matthew-_: Fw infers much less
15:28:36 <wy> sorear: Have you tried Cayenne by augustsson?
15:28:56 <sorear> matthew-_: it requires types on ALL lambdas, and uses explicit instantiation and 'value forall'
15:29:01 <sorear> wy: No.
15:29:27 <ski> more value forall !
15:29:31 <sorear> matthew-_: but because it's soo simple they use a variation of it for GHC core
15:29:34 <monochrom> http://books.google.com/books?id=gQ1JDuG9JREC&pg=PR1&ots=dmM10KFMEv&dq=appel+modern+compilers+in+ML&sig=cxjzF2NBNr41gk29wowuTk458hg  seems to do wonder
15:29:38 <lambdabot> Title: Modern Compiler Implementation in ML - Google Book Search, http://tinyurl.com/ytwhdx
15:30:05 <sorear> the technical term is 'type abstraction', but I'm sure that would be meaningless to matthew-_ ;)
15:30:25 <matthew-_> sorear: ok, well I'll give up on that one. tbh, it's not something I've ever found I needed, I just was asked about supporting it via some library I'm writing
15:30:25 * monochrom <3 Cambridge University Press
15:30:29 <sorear> s/^/ski: /
15:31:43 <ddarius> matthew-_: You know what an abstraction (in FP, not the general notion) is, correct?
15:31:50 <matthew-_> yes.
15:32:05 <wy> monochrom: why can I read it there!
15:32:18 <ddarius> matthew-_: A type abstraction is the same thing (a lambda) at the type level (if you don't already know/can figure that out)
15:32:25 <matthew-_> sure.
15:32:26 <ski> sorear : 'value forall' makes me think of Prolog or something .. how about 'type arguments' ?
15:32:36 <wy> sorear: Why is system FW better?
15:32:47 <ddarius> System F\omega
15:32:53 <matthew-_> ddarius: so it's just introducing more explicit computation at the type level
15:33:18 <matthew-_> s/$/?/
15:33:30 <ski> (sorear : .. or maybe you afterall meant abstracting types out of *types* ?)
15:33:41 <nominolo> > 3 `inRange` (2,3)
15:33:42 <lambdabot>        add an instance declaration for (Num ((t, t1), (t, t1)))
15:33:46 <ddarius> matthew-_: It's more than that, but that is part of it.
15:33:53 <nominolo> :t inRange
15:33:54 <matthew-_> ddarius: presumeably, it's very limited - eg no general recursion etc?
15:33:54 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
15:34:16 <monochrom> wy: magic!
15:34:21 <nominolo> > inRange (2,3) 3
15:34:23 <lambdabot>  True
15:34:40 <wy> monochrom: It's just a review...
15:34:56 <ski> > inRange (False,False) True
15:34:58 <lambdabot>  False
15:35:32 <LoganCapaldo> > let outOfRange = (not .) . inRange in outOfRange (100, 200) 345
15:35:34 <lambdabot>  True
15:36:03 <LoganCapaldo> @ty inRange
15:36:05 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
15:36:10 <ddarius> matthew-_: Well the type level terms are "typed".
15:36:22 <monochrom> preview?
15:36:22 <LoganCapaldo> @instances Ix
15:36:24 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
15:36:26 <matthew-_> ddarius: right, with kinds I presume
15:36:32 <LoganCapaldo> @instances-importing Ix
15:36:33 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
15:36:42 <ddarius> And yes, you wouldn't have a fix primitive.  Though you could make such systems if you wanted to.
15:36:44 <monochrom> ok, you can still try to make the best use of a preview.
15:36:47 <joelr1> evening
15:36:50 <ski> @instances-importing Ix Ix
15:36:51 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
15:37:31 <ddarius> matthew-_: "kinds" is mostly just a name.
15:37:34 <wy> monochrom: I think it's almost the same as the Java one.
15:37:35 <LoganCapaldo> No 5 dimesional arrays?
15:37:56 <sorear> ddarius, matthew-_: type abstractions (in the sense I'm (mis) using the term) actually have nothing to do with kinds
15:37:56 <matthew-_> ddarius: oh sure, I'm familiar with Tim Sheard's Omega and Epigram and Cayenne etc.
15:38:26 <sorear> ddarius: I'm talking about     id = \/A. \(x :: A). x
15:38:32 <sorear> ddarius: the \/
15:38:42 <wy> matthew-_: I read the paper about Cayenne yesterday, and I don't understand what's the use of the types that can depend on values.
15:38:48 <ddarius> You are talking about type-level abstractions rather than type abstractions.
15:39:01 <TantumLex> numbersFrom = fix (ap (:) . (. (1 +)))
15:39:06 <TantumLex> What makes this recursive?
15:39:14 <sorear> ddarius: I'm talking about type abstractions, you're talking about type level abstractions.
15:39:14 <matthew-_> wy: err, try again ;-) dependently typed languages are one of /the/ hot topics atm
15:39:17 <ski> printf :: (s :: String) -> PrintfType s
15:39:28 <sorear> ddarius: are you saying I have my terms backward?
15:39:39 <ski> TantumLex : the 'fix'
15:39:41 <LoganCapaldo> TantumLex: fix
15:39:46 <ski> @src fix
15:39:47 <lambdabot> fix f = let x = f x in x
15:40:01 <ddarius> (Aimed generally) In the lambda cube there are four types of abstraction, value-value (normal lambda), value-type (dependent types), type-value (parametric polymorphism), type-type ("normal" lambdas at the type level, i.e. type constructors)
15:40:02 <sorear> ski: which language uses that syntax?
15:40:12 <TantumLex> Is that fix from Control.Monad.fix ?
15:40:14 <ski> sorear : err.. maybe Cayenne ?
15:40:22 <matthew-_> wy: read the papers on Epigram. You can use computation at the type level to construct proofs of your code that must be maintained (for example). I.e. an extensible type system.
15:40:26 <sorear> ddarius: yeah, I'm talking about the third.
15:40:28 <wy> matthew-_: I think Scheme can have such a type system if you want. Just package symbols into closures and that can be your structure and module.
15:40:35 <LoganCapaldo> @index fix
15:40:35 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
15:40:38 <ddarius> sorear: The third is in just System F
15:40:46 <LoganCapaldo> guess so
15:40:48 <TantumLex> cooool
15:41:21 <sorear> ddarius: Yes, but system F is missing other things
15:41:49 <ddarius> wy: squareMatrix :: \Pi n:Int.Array n n
15:41:51 <sorear> ddarius: I had other reasons to not suggest studying it
15:42:26 <matthew-_> ddarius: presumeably the goal is to get as close to the forth abstraction whilst maintaining nice things like inference and so forth.
15:43:24 <nominolo> ddarius: i prefer LF style syntax.  I.e. {n:Int} Array n n
15:43:50 <nominolo> at least that is what it's written in TWELF
15:44:09 <matthew-_> wy: scheme (afaik), is dynamically typed. Thus if you construct extra checks, they only exist at run time. With dependently typed languages, your extra proofs and constructions are checked at compile time. Thus you can assert (almost) any property you want /at compile time/.
15:44:22 <ddarius> matthew-_: They each are orthogonal (hence lambda cube), and the others make big problems themselves.  Reading you statement another way, -a- goal could be that.
15:44:35 <matthew-_> right, sorear, ddarius, many thanks for your help. I'm off to bed.
15:45:22 <wy> matthew-_: Is it decidable? I think any type depend on values will be undecidable. That's no difference from dynamic typed
15:45:23 <sorear> it's amazing what you can do with just typed binders...
15:45:35 <sorear> wy: sure it's decidable!
15:45:49 <matthew-_> wy: in the general case, if you allow general recursion, no. Hence cayenne.
15:46:08 <sorear> wy: the full lambdacube is decidable and dependantly typed.
15:46:10 <matthew-_> wy: but, eg, Epigram limits recursion to the structure of terms, so it is terminating
15:46:30 <sorear> wy: general recursion is an ugly crutch...
15:47:19 <matthew-_> oh, and do I take it that on one replied to my mail "Kleene star in types" because a) no one read it and b) no one realised there were some questions in it?
15:47:29 <ddarius> sorear is uninterested in programming language implementation.
15:47:45 <sorear> matthew-_: right.
15:47:52 <wy> matthew-_: Which one is the main paper about Epigram?
15:48:11 <matthew-_> wy: View from the left is the big one, but "why dependent types matter" is good
15:48:12 <matthew-_> iirc
15:48:23 <shapr> I like the idea of developing with a terminating language and then adding 'fix' for production code.
15:48:28 <matthew-_> ddarius: I'm /only/ interested in implementation ;-)
15:48:31 * sorear upgrades e2fslibs *cross fingers*
15:48:43 <shapr> I'm only interested in women, what am I doing here??
15:48:44 <augustss> matthew-_: there were question is your Kleene star posting?
15:48:58 <ddarius> shapr: I'm with you.
15:49:00 <davidL> can I use two conditions in one filter statement or must I use two separate filters?
15:49:07 <matthew-_> augustss: 'fraid so! Basically to do with allow-undecidable-instances
15:49:09 * ddarius walks away and talks to his girlfriend.
15:49:10 <sorear> shapr: I like the idea of developing with a terminating language and using creative types to have a terminating problem.
15:49:19 <LoganCapaldo> davidL: sure just combine them with and or or
15:49:23 <shapr> My girlfriend is in Sweden :-(
15:49:36 <davidL> LoganCapaldo: does && work?
15:49:44 <LoganCapaldo> :t (&&)
15:49:46 <lambdabot> Bool -> Bool -> Bool
15:49:51 <LoganCapaldo> appears so :)
15:49:53 <davidL> :t and
15:49:55 <lambdabot> [Bool] -> Bool
15:49:56 <matthew-_> My girlfriend is in bed, wondering why I'm up late talking to "imaginary people" as she puts it.
15:50:28 <wy> matthew-_: Thanks. You should go. hehe
15:50:53 <ddarius> matthew-_: I'll show -you- imaginary!
15:50:55 * ddarius grabs a rock.
15:51:01 <ski> what do you get if you mix imaginary and real people ?
15:51:08 * matthew-_ powers up the force-fields
15:51:12 <LoganCapaldo> complex people?
15:51:17 <sorear> shapr: EG, a window manager can be seen as State -> Event -> ([Action], State)  - if this nt's you've got problems!
15:51:23 <ski> LoganCapaldo : yes !!!
15:51:29 <matthew-_> Who's going to the Fun in the Afternoon in Cambridge then?
15:51:58 <sorear> Oh yay.  I think I've hung debconf ...
15:52:01 * ddarius isn't.
15:52:10 * ddarius admits it, he is an imaginary person.
15:52:15 <wy> matthew-_: Can you brief the difference between Epigram and Caynnen ?
15:52:30 <matthew-_> wy: Epigram's author isn't on #haskell.
15:52:32 <shapr> matthew-_: Have you been to any of the Haskell gatherings?
15:52:39 <matthew-_> wy: ;-)
15:52:51 <shapr> Though some of Epigram's implementors do show up here.
15:53:04 <matthew-_> shapr: I went to the Fun.. in Notts last time, I'm going to the london Hug.
15:53:08 <wy> matthew-_: Do they use haskell to implement their first version?
15:53:16 <shapr> wy: Yes.
15:53:19 <augustss> wy: Epigram ensure termination of the proof terms (at least in theory).  There are also some substantial syntactic differences.
15:53:27 <nominolo> :t source first
15:53:29 <lambdabot> Not in scope: `source'
15:53:34 <nominolo> @source first
15:53:35 <lambdabot> first not available
15:53:40 <matthew-_> augustss: I was getting to that ;)
15:53:49 <nominolo> @hoogle first
15:53:49 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
15:53:49 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:53:49 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
15:53:51 <ski> @source Control.Arrow.first
15:53:51 <lambdabot> Control.Arrow.first not available
15:53:58 <ski> @source Control.Arrow
15:53:59 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
15:54:24 <wy> augustss: Ah you are back!
15:54:36 <augustss> wy: also, Epigram is being developed, Cayenne is not
15:54:38 <sorear> New packages!
15:54:40 <sorear> p     libghc6-hlist-dev                                                                                                                             <none>     2.0+darcs2
15:54:51 * LoganCapaldo laughs at reading that instances must define first
15:54:57 <sorear> kaol++
15:55:11 <wy> augustss: Thanks. Actually I want more suggestions from you.
15:55:30 <matthew-_> It does seem that the type systems employed in Haskell and its extensions are /very/ complex and sophisticated when compared to, eg Ownership types, Separation logics, Session types, types for pi or Ambient calculi etc etc.
15:55:39 <matthew-_> I guess they've just been around longer.
15:55:39 <LoganCapaldo> @src (->) first
15:55:40 <lambdabot> first f = f *** id
15:55:45 <augustss> wy: I suggest a danish hot dog with a lot of mustard
15:56:10 <bos> i think the mixture of real and imaginary people would best be represented by automatically differentiated people.
15:56:12 <ski> @src Kleisli first
15:56:12 <lambdabot> Source not found. Where did you learn to type?
15:56:33 <shapr> augustss: bwaha
15:56:57 <LoganCapaldo> > (+1) *** (-1) 2
15:56:58 <ski> bos : how come ?
15:56:59 <lambdabot>   add an instance declaration for (Num (t -> b' -> c'))
15:57:08 <LoganCapaldo> > ((+1) *** (-1)) 2
15:57:09 <lambdabot>   add an instance declaration for (Num (b, b'))
15:57:20 <wy> augustss: I have only american hot dog. Is that ok?
15:57:23 <ski> > ((+1) *** (-1)) (3,4)
15:57:24 <lambdabot>   add an instance declaration for (Num (b' -> c'))
15:57:28 <LoganCapaldo> > ((+1) *** (-1)) (2,3)
15:57:28 <twanvl> matthew-_: The reason Haskell's type system is so complex is because it is a real programming language, the other things you list are not
15:57:29 <lambdabot>   add an instance declaration for (Num (b' -> c'))
15:57:43 <augustss> wy: they are not as pink as the danish
15:57:45 * LoganCapaldo has a comprehension failure
15:57:52 <LoganCapaldo> @type (***)
15:57:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:58:17 <wy> augustss: What's the time in Sweden?
15:58:21 <ski> > ((+1) *** subtract 1) (3,4)
15:58:22 <lambdabot>  (4,3)
15:58:27 <bos> ski: http://portal.acm.org/citation.cfm?id=838250.838251
15:58:29 <lambdabot> Title: The complex-step derivative approximation
15:58:31 <ski> @type (-1)
15:58:33 <augustss> matthew-_: also, Haskell's type system has grown by accumulating ever more features
15:58:34 <lambdabot> forall a. (Num a) => a
15:58:34 <LoganCapaldo> doh
15:58:37 <matthew-_> twanvl: well, the basic hindly milner inference and unification is a piece of cake, and that's really the core. The rest is, I would guess, just adding sophistication.
15:58:45 <LoganCapaldo> > ((+1) *** ((-)1)) (2,3)
15:58:47 <lambdabot>  (3,-2)
15:59:02 <LoganCapaldo> > ((+1) *** (flip (-) 1)) (2,3)
15:59:03 <lambdabot>  (3,2)
15:59:27 <LoganCapaldo> well that was fun
15:59:28 <augustss> wy: I'm in London.  It's midnight here
15:59:52 <ski> (bos : sorry, i don't have a key)
16:00:07 <matthew-_> augustss: indeed. But I've just done a (pretty funky) implementation of Session types into haskell, abusing the haskell type system to type check the session types. That's all fine. But in general, the new stuff going in (eg associated types and so forth) seem in a different league of complexity
16:00:08 <wy> augustss: Can I send you messege privately?
16:00:11 <ski> wy : 01:00
16:00:18 <nominolo> > second (+1) (2,3)
16:00:20 <lambdabot>  (2,4)
16:00:34 <wy> ski: Are you also in England?
16:00:40 <bos> ski: it was a joke anyway. automatic differentiation is a method that gives better accuracy sometimes than complex arithmetic.
16:00:48 <ski> wy : sweden
16:01:15 <wy> Let's do a research. How many people here are from Europe?
16:01:16 <nominolo> ski: goteborg?
16:01:21 <ski> bos : yes i know .. just wondered how it was related to complex numbers
16:01:25 <augustss> matthew-_: yeah, associated type synonyms (and GADT) are rather complex beasts
16:01:26 <LoganCapaldo> > (second id *** first id) ((1,2), (3,4))
16:01:26 * ski nods
16:01:28 <lambdabot>  ((1,2),(3,4))
16:01:57 <matthew-_> augustss: yet using them's nice and simple, thank goodness.
16:02:08 <matthew-_> wy: yup, london.
16:02:23 <ski> @map
16:02:24 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
16:02:45 <wy> augustss: Your G machine helped me a lot in understanding compilers in general.
16:03:05 <augustss> wy: it's not mine, it's Thomas Johnsson's
16:03:08 <LoganCapaldo> > (uncurry . flip (,)) (2,3)
16:03:09 <sorear> <- San Diego
16:03:09 <lambdabot>  Couldn't match expected type `b -> c'
16:03:14 <ski> (also http://www.haskell.org/haskellwiki/Haskell_user_locations)
16:03:16 <lambdabot> Title: Haskell user locations - HaskellWiki
16:03:25 <LoganCapaldo> > (flip . uncurry (,)) (2,3)
16:03:27 <lambdabot>  Couldn't match expected type `a -> b -> c'
16:03:37 <wy> augustss: SPJ said in his book that it's yours
16:03:40 <LoganCapaldo> > (flip . curry (,)) (2,3)
16:03:42 <lambdabot>  Add a type signature
16:03:50 <LoganCapaldo> > (flip . curry (,)) (2,3) :: (Int, Int)
16:03:51 <lambdabot>  Couldn't match expected type `(Int, Int)'
16:04:08 <sorear> wy: Augustsson created the compiler, but Johnsson formalised the AM
16:04:12 <LoganCapaldo> > uncurry (flip . curry (,)) (2,3) :: (Int, Int)
16:04:13 <lambdabot>  Couldn't match expected type `(Int, Int)'
16:04:16 <augustss> wy: I think Simon credited both of us in the book for what he wrote about.  Thomas and I did different parts
16:04:24 <LoganCapaldo> @tyuncurry (flip . curry (,)) (2,3)
16:04:25 <lambdabot> Unknown command, try @list
16:04:30 <LoganCapaldo> @ty uncurry (flip . curry (,)) (2,3)
16:04:33 <lambdabot> forall a b b1. (Num a, Num b1) => b -> ((a, b), b1)
16:04:49 <LoganCapaldo> @ty uncurry (flip . curry (,))
16:04:52 <lambdabot> forall a b b1. (a, b1) -> b -> ((a, b), b1)
16:04:52 <wy> augustss: I see. Whatever, that's neat
16:05:09 <augustss> sorear: actually, Thomas formalized and wrote the G-machine related parts of the compiler.  team work...
16:05:16 <ski> LoganCapaldo : trying to build associator ?
16:05:21 <LoganCapaldo> @pl (\(x, y) -> (y, x))
16:05:22 <lambdabot> uncurry (flip (,))
16:05:33 <LoganCapaldo> sigh
16:06:15 * LoganCapaldo wonders if the suggestion was automated or not
16:06:19 <augustss> LoganCapaldo: what are you trying to do?
16:06:32 <LoganCapaldo> I was trying to write swap
16:06:40 <augustss> ah
16:06:48 <wy> augustss: I want to get some suggestions from you about research in programming languages. Could you look at your dialog window?
16:07:05 <nominolo> > (first snd *** second fst) (1,2)
16:07:05 <lambdabot>   add an instance declaration for (Num (d, (a, b)))
16:07:06 <lambdabot>     In the expression: 2
16:07:19 <sorear> nominolo: (snd &&& fst)
16:07:22 <sorear> LoganCapaldo: ERC> /msg lambdabot @msg LoganCapaldo hi, I do respond to /msg
16:07:43 <LoganCapaldo> sorear: heh
16:07:54 <nominolo> sorear: hm, ERC. *thumbsup*
16:07:56 <LoganCapaldo> That answers that question. I got carried away tis true
16:08:11 <augustss> wy: my advice is to do something related to what other people do at the place you study
16:10:01 <augustss> lol, gotta love manuelg on reddit
16:11:06 <bos> hm?
16:12:14 <ddarius> Hmm. Imaginary me might soon have an imaginary tornado.
16:17:32 <wy> augustss: Don't be too polite. Things can go wrong if I just follow others.
16:18:09 <augustss> wy: you can't work in a vacuum
16:18:39 <ddarius> Indeed.  It is loud and dusty in there.
16:20:11 <augustss> absolutly!
16:21:41 <dons> augustss: oh man.
16:21:54 <dibblego> can reverse on a double linked list be written with O(1)?
16:22:30 <augustss> dons: :)
16:22:40 <dons> :)
16:22:41 <sorear> dibblego: Yes.
16:22:44 <dons> ?uptime
16:22:45 <lambdabot> uptime: 1d 22h 1m 43s, longest uptime: 13d 18h 36m 21s
16:22:49 <LoganCapaldo> dibblego: sure assuming the data structure looks like head, tail, direction
16:23:01 <dons> ok. and with that, I'm off on vacation. see you guys in a week.
16:23:03 <LoganCapaldo> swap head and tail and flip direction
16:23:04 <dons> be good to the bot!
16:23:12 <dmwit> Or, if you use a circular doubly linked list with XOR-encoded pointers, you just switch your two head pointers.
16:23:20 <sorear> http://www.chiark.greenend.org.uk/~sgtatham/algorithms/revlist.html
16:23:23 <lambdabot> Title: Reversible Linked Lists, http://tinyurl.com/yrzgwu
16:23:36 <dibblego> LoganCapaldo, where direction is one of two values?
16:23:38 <SamB> dmwit: those are a mite tricky to garbage collect
16:23:45 <dmwit> indeed
16:23:51 <LoganCapaldo> dibblego: yeah
16:23:52 <dibblego> thanks sorear
16:23:52 <sorear> SamB: Not at all.
16:24:02 <sorear> SamB: the GC needs to know your format, that's all
16:24:07 <SamB> sorear: yes
16:24:25 <SamB> the GC needs to know about the horrible things you do to your pointers
16:24:47 <sorear> Oh to have an extensible GC :)
16:25:36 <LoganCapaldo> Extensible GC? Naw jsut make XORed pointers a builtin type :)
16:26:08 <kc5tja> Check out how Oberon's GC works with its type system.  The compiler relies on type descriptors produced by the compiler.  Of course, since pointer manipulations are permitted at the code level, compacting collectors are pretty much impossible (unless you define all pointers to _really_ be handles).
16:26:13 <sorear> But what if someone wants added pointers?
16:26:42 <kc5tja> sorear: Added pointers?
16:26:54 <sorear> kc5tja: (+)
16:26:55 <LoganCapaldo> sorear: isn't a pointer + pointer stillr ecognizable as a pointer?
16:27:11 <augustss> how?
16:27:17 <LoganCapaldo> unless you want to add an arbitrary value for no reason
16:27:17 <kc5tja> + is not defined on pointers; if you want to use arrays, you need to declare your type as an array of something.
16:27:38 <LoganCapaldo> I don't see what it buys you compared to the XOR scenario
16:27:43 <sorear> <LoganCapaldo> Extensible GC? Naw jsut make XORed pointers a builtin type :)
16:27:52 <kc5tja> To use +, you'll need to cast a pointer to an integer (via SYSTEM.VAL() function), then add, then re-cast into an appropriate pointer (again using the SYSTEM.VAL() function).
16:27:58 <sorear> So I'm asking in :) what if the user wants (+) rather than xor?
16:28:13 <LoganCapaldo> and I'm asking what's the use case ? :)
16:28:18 <sorear> kc5tja: The timing was an accident.  I'm responding to LC not you.
16:28:35 <sorear> LoganCapaldo: ":)"
16:28:44 <augustss> LoganCapaldo: but I don't want XOR.  I want to use subtract.  and then I want to use some of those unused bits in the pointer.  are tou going to build it all in for me?
16:28:45 <kc5tja> FINE!  BE that way!  SEE if *I* care!  *sniff!* :)
16:28:55 * sorear drops it
16:28:57 <kc5tja> (actually, it's about aikido time anyway.  Going to jet.)
16:29:20 <kc5tja> sorear: ??  Note the smiley man...I'm just being silly.
16:29:24 <LoganCapaldo> augustss: Ok, you win, clearly :)
16:29:44 <sorear> kc5tja: And I'm just carrying it on too long :)
16:31:56 <monochrom> XOR pointers? Is this an attempt to encrypt the heap?
16:33:01 <sorear> No, it's an attempt to corrupt young minds.
16:33:05 <LoganCapaldo> monochrom: doubly linked lists
16:33:20 <sorear> As everyone knows, the operation is actually called EOR.
16:33:34 <jcreigh> EOR doesn't sound as cool.
16:33:36 <LoganCapaldo> The donkey?
16:34:22 <jcreigh> sorear: well, EO, actually, if you want the acronym to be correct.
16:34:23 <sorear> 65xxx and 680xx use EOR, x86 uses XOR.
16:34:36 <sorear> Assume battle postions!
16:34:41 <monochrom> Oh! brings back distant memories...
16:34:58 <monochrom> Assume 1<0 !
16:34:59 <augustss> PDP-11 uses XOR
16:35:09 <jcreigh> oh, I thought you were just being snarky. I hadn't realized people actually use EOR.
16:35:46 <LoganCapaldo> class Pointer a where toRealAddress :: a -> Addr
16:35:50 <monochrom> I still have an unused 6502 chip.
16:35:53 <augustss> IBM360 (and subsequent mainframes) use XOR
16:35:56 <LoganCapaldo> There's your extensible GC right there!
16:36:11 <LoganCapaldo> just need to teach the compiler about the specialness of that type class
16:36:15 <monochrom> I also have a couple of 68000s.
16:36:36 <monochrom> I should build a home-brew computer with them and port GHC there.
16:36:42 <LoganCapaldo> oh wait that won't work
16:36:51 <LoganCapaldo> not for XORs
16:36:56 <LoganCapaldo> Blast!
16:36:59 <monochrom> "I have dual core 68000 and GHC takes two weeks to build..."
16:37:13 <augustss> LoganCapaldo: but the XOR pointer are tricker than that class.  you need a pointer to the node to be able to extract the next pointer
16:37:17 <monochrom> err SMP 68000 I guess.
16:37:19 <jcreigh> EOR encryption would be fun: "I can easily see your plaintext!" "Thanks for noticing..."
16:37:21 <_magus_> is it the current wisdom to use an MVar in the signal-handler thread in order to trigger a clean shutdown of the main thread?
16:37:25 <Philippa> heh, I am so not trying to build GHC on my zaurus. Not given how long it took to build a 300 line interpreter
16:37:30 <LoganCapaldo> augustss: I just said that :)
16:37:43 <ddarius> Philippa: For?
16:38:09 <ddarius> _magnus_: Apparently.  Isn't that what is in the documentation?
16:38:10 <Philippa> ddarius: untyped CBV lambda calculus with let
16:38:18 <Philippa> lexer and parser written with parsec
16:38:24 <augustss> Philippa: ypu'd better wait for some beefier zaurus
16:38:35 <Philippa> unlikely to happen, Sharp canned the range :-(
16:38:43 <_magus_> ddarius: yeah, I think so, just wanted to make sure I've understood things
16:38:44 <sorear> Philippa: how did you build GHC?  I don't think ARM makes processors fast enough to build GHC, and cross compiling is supposed to be a royal pain
16:38:48 <Philippa> though a lot of the issue's actually RAM
16:38:56 <Philippa> sorear: I didn't, I used the debian binary :-)
16:39:21 <mattam> sorear: yes ?
16:39:22 <augustss> How much RAM does it have?
16:39:38 <dmwit> ?quote garbage.collect
16:39:39 <lambdabot> qwe1234 says: the problem is that ocaml has mandatory garbage collection.
16:39:42 <dmwit> ?quote garbage.collect
16:39:43 <lambdabot> qwe1234 says: the problem is that ocaml has mandatory garbage collection.
16:39:44 <Philippa> 64 meg. And yeah, it got swapping, but that's not the only issue - I need to make some serious changes to the filesystem on that thing sometime
16:39:45 <sorear> mattam: someone typoes your name, and I was making sure..j
16:39:56 <LoganCapaldo> region inference!
16:40:03 <dmwit> ?quote mutable.*manual
16:40:04 <lambdabot> PaulAJ says: Mutable state is actually another form of manual memory management: every time you over-write a value you are making a decision that the old value is now garbage, regardless of what
16:40:04 <lambdabot> other part of the program might have been using it.
16:40:05 <augustss> 64M!  Luxury!
16:40:06 <LoganCapaldo> Does that count as "not GC"
16:40:07 <sorear> mattam: but now that I've disturbed you - ooc, are you the Yhc typechecker SoC guy?
16:40:09 <Philippa> running out of an image on a loopback system that's kept in a FAT32 partition isn't clever
16:40:10 <ddarius> What's the specs on the processor?
16:40:10 <LoganCapaldo> ?
16:40:16 <monochrom> > 24/3
16:40:18 <lambdabot>  8.0
16:40:20 <mattam> nope
16:40:29 <monochrom> > 2^24 / 1000 / 1000
16:40:30 <lambdabot>  16.777216
16:40:39 <monochrom> 16M is not enough.
16:40:43 <sorear> mattam: Oh, a *different* Mathieu.
16:40:47 <Philippa> augustss: yeah yeah, it's rather more powerful than my first computer was :-)
16:40:51 <mattam> I have two t's
16:40:56 <mattam> like the saint
16:41:00 <sorear> mattam: I am so having no luck with my 'Is this a common name' subroutine :)
16:41:08 <Philippa> even the display is, despite the 3.7" screen
16:41:25 <mattam> Hehe, all saints names are pretty common in Europe
16:41:26 <Philippa> ddarius: 400-odd MHz xscale
16:41:52 <ddarius> Philippa: That's about comparable to the desktop I was using a couple years back (and did build GHC on several times).
16:41:52 <sorear> I never knew there even *was* a Saint Mathieu...
16:41:54 <mattam> That's a pretty reliable heuristic :)
16:42:10 <mattam> With two t's !
16:42:13 <Sgeo> Does the bot still hate me?
16:42:15 <Sgeo> :t Just Right
16:42:18 <Sgeo> @t Just Right
16:42:19 <Philippa> ddarius: yeah, the reason I don't want to build GHC on it has more to do with the filesystem issues - the HD isn't fast, and it takes forever to find files
16:42:27 <sorear> @ignore - Sgeo
16:42:30 <Sgeo> ty
16:42:31 <sorear> Not anymore, oops.
16:42:37 <ddarius> Yeah, building GHC hit the swap hard on my machine.
16:42:40 <dmwit> Sgeo: Maybe (a -> Either a)
16:42:41 <mattam> There was one with only one too anyway
16:42:42 <sorear> only meant that for 2m
16:42:46 <ddarius> Though Hat optimized was impossible.
16:42:49 <Sgeo> @t Just Right
16:42:50 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:42:53 <dmwit> Sgeo: Maybe (a -> Either a b)
16:42:58 <Sgeo> @type Just Right
16:43:01 <lambdabot> forall b a. Maybe (b -> Either a b)
16:43:02 <sorear> @ignore - SamB
16:43:07 <mattam> He was an apostle
16:43:11 <dmwit> Bah, I'm terrible at this.
16:43:23 * Sgeo made a joke w/ that
16:43:30 <ddarius> dmwit: You just don't know your left from your right.
16:43:35 <Sgeo> But I think most people here are sick of it..
16:43:40 <augustss> dmwit: you won't be the new lambdabot yet
16:43:55 <sorear> mattam: Can you tell I never studied Christian history? ;)
16:43:55 <dmwit> Both my hands make an 'L' when I stick my thumb out!
16:43:58 <dmwit> It's not my fault!
16:43:59 <Philippa> I have to admit, I'd really love a modded zaurus with a wide screen, much more RAM and a few other odds and ends. More realistically I'm going to have to wait 'til the code bloat in Windows Mobile makes the hardware good enough
16:44:09 <ddarius> sorear: "Christian history"?
16:44:11 <Sgeo> Does anyone want to see it?
16:44:38 <ddarius> Sgeo: No.
16:45:02 <sorear> ddarius: My pathetic attempt at a neutral term...
16:45:17 <Philippa> you mean you were avoiding mythology?
16:45:57 <ddarius> How about "the Bible"?
16:46:15 <ddarius> Though I guess you could study such things without studying the Bible.
16:46:15 <mattam> The existence of the apostle is about the most realistic part in this story :)
16:46:51 <ddarius> "Once, a person existed."
16:47:39 <mattam> His name was Matthew
16:47:47 <mattam> That's all there is to it :)
16:50:02 <njbartlett> Philippa: Yeah I also gave up trying to build GHC for my Zaurus. I can run Hugs without any problems though
16:51:23 <Pseudonym> For the record, most religious types who turn up here would likely not be offended by the word "mythology".
16:51:49 <Pseudonym> Myth is not necessarily non-historical, though it's often not literal history/
16:52:05 <dibblego> I think preferred programming language and religion are correlated
16:52:16 <Pseudonym> So post-modern Christians use Perl?
16:52:34 <ddarius> Pseudonym: What, you don't think there is a significant Fundamentalist subgroup with in the Haskell community?
16:52:45 <Pseudonym> ddarius: Not a religious fundamentalist subgroup, no.
16:52:59 <Pseudonym> A computer science theoretical fundamentalist subgroup perhaps.
16:53:01 <Philippa> njbartlett: which OS're you running, and do you have a binary I could nab? I've got a C3200 running Cacko
16:53:14 <Pseudonym> Anyway, for these and further interesting topics, we have #haskell-blah.
16:53:32 <Philippa> you mean I don't scare all the fundies away from it? :-)
16:53:54 * ddarius was not being serious anyways.
16:53:59 <njbartlett> Philippa: I've got a 3100 running Tetsu's kernel, there's a ipk package somewhere on one of the package directory sites. I'll see if I can find it
16:54:13 * ddarius just doesn't like emoticons and so determining whether he is serious or not is left to context.
16:55:00 <dibblego> emoticons are just a serialized form of body language; you need to serialize it somehow!
16:55:08 * ddarius uses words.
16:55:22 <njbartlett> Philppa: http://park8.wakwak.com/~sohgetsu/files/hugs_Sep2006-1_arm.ipk
16:55:28 <dibblego> ah, so you'd like this thing called XML too <smile/>
16:55:58 <Pseudonym> Philippa: No.  Sorry to burst your bubble.
16:56:40 <ddarius> Philippa: Anyways, you wouldn't scare them away rather our "acceptance" of you would repulse them.
16:56:56 <Philippa> njbartlett: thanks. It might be worth talking to Igloo about GHC building, btw - he maintains the Debian package
16:57:17 <davidL> > > let notElemInt a b = notElem (intToDigit a) (show b); mostlyOddDigits n = foldl1 (&&) $ map (\x -> notElem x n) [0,4,5,6,8] in mostlyOddDigits 23
16:57:18 <lambdabot>  Parse error
16:57:23 <davidL> > let notElemInt a b = notElem (intToDigit a) (show b); mostlyOddDigits n = foldl1 (&&) $ map (\x -> notElem x n) [0,4,5,6,8] in mostlyOddDigits 23
16:57:24 <lambdabot>   add an instance declaration for (Num [a])
16:57:47 <ddarius> dibblego: I use this thing called diction and form.
16:58:15 <njbartlett> Philippa: Thanks, will do. Most stuff I can compile right on the Zaurus, no cross compilation. Compiling GHC would probably take a year though
16:58:36 <njbartlett> Oh and Gambit-C (scheme compiler) was a bugger as well
16:59:07 <Philippa> njbartlett: I doubt it'd take a year so long as your swap's not too horrific
16:59:10 <joelr1> does anyone know if hpaste uses the hs-plugins architecture?
16:59:25 <Philippa> I should get round to repartitioning so I've got a separate swap partition for when I want it
16:59:26 <sorear> joelr1: Yes.
16:59:36 <sorear> joelr1: the answer is No, btw
16:59:39 <Sgeo> @t trace
16:59:40 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:59:45 <Sgeo> @type trace
16:59:45 <sorear>  @ty!
16:59:47 <lambdabot> Not in scope: `trace'
16:59:56 <sorear> Sgeo: @type deosn't auto import
16:59:56 <joelr1> sorear: darn
17:00:00 <Sgeo> @hoogle trace
17:00:01 <lambdabot> Debug.Trace.trace :: String -> a -> a
17:00:01 <lambdabot> Debug.Trace :: module
17:00:01 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
17:00:01 <sorear> @docs Debug.Trace
17:00:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
17:01:10 <Sgeo> > (trace "heyas" True)
17:01:10 <joelr1> sorear: are you familiar with HAppS? do you know if it can be upgraded without shutting down?
17:01:10 <Sgeo> > Debug.Trace.trace "heyas" True
17:01:10 <sorear> joelr1: Yes, and Yes.
17:01:10 <sorear> joelr1: the answer is No
17:01:24 <joelr1> sorear: no to what answer?
17:01:25 <sorear> joelr1: but it's still only <1 minute of downtime
17:01:48 <njbartlett> Philippa: I was very impressed with the OCaml build, actually. It managed to produce an optimizing native compiler for the ARM, bootstrapped itself, no problems at all
17:01:48 <njbartlett> But I still love writing Haskell on the Tube!
17:01:48 <lambdabot>   Not in scope: `trace'
17:01:49 <lambdabot>   Not in scope: `Debug.Trace.trace'
17:01:49 <sorear> I'm familiar with HApps.  I know if it can be upgraded without shutting down. It can't
17:02:06 <joelr1> sorear: sucks
17:02:15 <Philippa> I've only used it on the national rail
17:02:18 <joelr1> sorear: i'm trying to figure out a deployment scheme for my web app
17:02:24 <sorear> joelr1: why, your users can't wait a minute? ;)
17:02:24 <ddarius> joelr1: Change it.
17:02:40 <ddarius> Even if they couldn't you could still have zero downtime.
17:03:03 <Philippa> actually, my zaurus gets used for note-taking more than anything else - I did get an external keyboard, but it's actually too small! Will have to get another. Also, need to figure out WTF's with the (lack of?) key mapping and get it recognising UK USB keyboards properly
17:03:05 <ddarius> Albeit that would probably require more changes.
17:03:05 <joelr1> sorear: i guess i'll just go with lighttpd + happs, this way i can switch everyone to an upgrade-in-progress page
17:03:08 <davidL> sorear: does HAppS have less overhead than PHP?
17:03:19 <njbartlett> sorear: Some Erlang systems have nine nines reliability. That's just 30 milliseconds per year
17:03:41 <joelr1> ddarius: yeah, i can bring up 2 EC2 instances and point my dynamic DNS to the 2nd from the 1st
17:03:49 <sorear> njbartlett: I know about the craziness of Erlang.  However I also know not all applications require nine nines!
17:03:52 <ddarius> joelr1: Exactly.
17:04:03 <dibblego> joelr1, r1 as in the Yamaha?
17:04:16 <joelr1> dibblego: amazon ec2
17:04:22 <joelr1> elastic computing
17:04:24 <ddarius> sorear: What?!  You don't think hpaste needs  nine nines reliability?!
17:04:48 <njbartlett> ddarius: :-)
17:04:55 <joelr1> web-based easylanguage to c# compiler, written in haskell and deployed on amazon's elastic computing cloud
17:05:07 <joelr1> @google LtU easylanguage
17:05:14 <lambdabot> http://lambda-the-ultimate.org/node/2201
17:05:14 <lambdabot> Title: Easylanguage: domain specific language for trading stocks | Lambda the Ultimate
17:05:15 <dibblego> ah nice
17:06:11 <dibblego> lots of mispellings of language on that page :)
17:06:23 <joelr1> i guess i could try marrying hs-plugins and happs
17:06:26 <joelr1> somehow
17:06:30 <joelr1> i haven't looked into it
17:06:43 <sorear> ask on #happs
17:06:47 <sorear> ping alexj
17:06:54 <joelr1> oh
17:07:03 <joelr1> didn't know that channel existed
17:07:31 <joelr1> alexj's not there
17:07:45 <joelr1> how come there's no lambdabot on #happs?
17:09:20 <sorear> joelr1: i'm pretty sure it's int-e's fault
17:09:52 <joelr1> @hoogle hs-plugins
17:09:53 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-plugins'
17:10:02 <joelr1> @google hs-plugins
17:10:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
17:10:04 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
17:10:05 <joelr1> @where hs-plugins
17:10:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
17:10:30 <joelr1> @where lambdabot
17:10:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:15:48 <cdsmith> Is Hutton's "Programming in Haskell" a good book for new Haskellers?  Is there a better one I should recommend instead?
17:21:19 <gmh33_> cdsmith: you could always try yaht
17:21:39 <gravity> The haskell wikibook is fantastic
17:28:37 <newsham> anyone know how to get in touch with Thomas Hallgren?
17:28:54 <newsham> email to his OGI address got forwarded to altocumulus.org and bounced.
17:39:28 <sm> cdsmith: and, yes it is a good one
17:40:29 <cdsmith> sm and gmh33_: thanks to both of you.
17:40:58 <cdsmith> I'm trying to teach Haskell to all the smart programmers I know before the ICFP contest.  It's going slowly. ;)
17:42:51 <SamB> maybe you should shoot for the ICFP 2008 contest
17:42:58 <davidL> > all (==) [2,2,2,2]
17:42:59 <lambdabot>  Couldn't match expected type `Bool'
17:43:12 <newsham> > all (== 2) [2,2,2,2]
17:43:13 <lambdabot>  True
17:43:14 <cdsmith> SamB: No way.  I'll write all the code myself if I have to!
17:43:32 <SamB> I meant, for teaching haskell to the others
17:43:51 <davidL> newsham: anyway to do that without knowing what will be an element in the list?
17:43:57 <mauke> > group []
17:43:59 <lambdabot>  []
17:44:03 <newsham> you dont want all, you want group
17:44:37 <davidL> thanks
17:44:39 <cdsmith> SamB: I'm giving it a shot anyway.  I hate doing stuff by myself.
17:44:41 <newsham> > length $ groupBy even [2,4,6,8]
17:44:42 <lambdabot>  Couldn't match expected type `a -> Bool'
17:44:43 <mauke> > (null . drop 1 . group) [2,2,2,2]
17:44:44 <lambdabot>  True
17:45:20 <davidL> thanks mauke
17:45:39 <sorear> I'm a great programmer with a 100% chance of burning out at the 1000loc mark.
17:45:43 <mauke> > (null . drop 1 . group) [0..]
17:45:45 <lambdabot>  False
17:46:01 <sorear> Which makes me useless in practice, but I think I stand a chance at ICFP
17:46:33 <cdsmith> sorear: Nah.  They say the average programmer writes about 100 loc / month.  That makes you way above average.
17:47:18 <newsham> falacy: writing 1000loc during a contest is like writing 1000loc at work
17:47:18 <cdsmith> Scary part is, those are C/C++/Java lines of code
17:47:27 <sorear> cdsmith: Double check your figures
17:47:32 <Philippa> cdsmith: that's tested and documented, no?
17:47:37 <newsham> not really, most studies show that loc measurements are pretty consistent across languages.
17:47:42 <sorear> cdsmith: I refuse to believe I'm 40x above average.
17:47:50 <Cale> newsham: that is, it's exactly the same?
17:47:54 <Philippa> sorear: have you /met/ the average coder?
17:48:10 <sorear> Philippa: No, which is why I'm asking cdsmith.
17:48:12 <newsham> sorear: the measurements are for production code, written, debugged, shipped, bug fixes, etc..
17:48:13 <dibblego> sorear, have you ever worked in the industry?
17:48:22 <newsham> you do a lot more than write new code when you're working in a company that writes code
17:48:27 <SamB> the average coder ... is it this purplish drooling pimpled mass over there in the corner?
17:48:35 <cdsmith> sorear: I'm quoting from some software engineering paper; I'll have to dig it up.
17:48:42 <newsham> cale: i said its a falacy
17:48:45 <sorear> dibblego: No.  I'm figuring based on a brute-force life search program I wrote in about a week at about 1k lines
17:48:52 <cdsmith> Yes, it is tested/documented, and includes design, spec, etc.
17:49:19 <sorear> it's stable and semi-mature now...
17:49:33 <jcreigh> I think that sorear is about as far from the average coder as you can get.
17:49:34 <SamB> cdsmith: how many lines of that other stuff is involved?
17:49:39 <Cale> newsham: oh, fallacy -- somehow I'd thought that you were addressing someone named falacy, but there doesn't seem to be anyone here by that name :)
17:49:41 <Philippa> sorear: hah, that figures. I can write a few hundred lines in a night if I'm doing well, and given a documentation pass the next day it'll be decent. But I can't do that on demand
17:50:14 <cdsmith> SamB: I don't understand the question.
17:50:28 <newsham> cale: me speeling not gud.  thanx for lambadabot
17:50:32 <SamB> cdr: tests, documents, design, spec, etc.
17:50:35 <newsham> ?speel falacy
17:50:36 <SamB> er.
17:50:37 <SamB> cdsmith:
17:50:44 <SamB> how many lines of text are those?
17:51:00 <Philippa> I don't think lines of text are equivalent. They don't typically equate to statements
17:51:07 <chowmeined> How do I do integer division?
17:51:11 <mauke> `div`
17:51:17 <jcreigh> and `mod`
17:51:17 <cdsmith> SamB: Oh, I'm sure there are plenty of lines of text written in design -- or none, depending on the environment.  They aren't counted.
17:51:31 <sorear> `quot`
17:51:56 <Cale> > (-3) `div` 2
17:51:57 <lambdabot>  -2
17:52:02 <Cale> > (-3) `quot` 2
17:52:04 <lambdabot>  -1
17:52:07 <newsham> sorear: how many hours have you spent pulling in vty patches people sent you?
17:52:23 <sorear> newsham: about 2 minutes
17:52:32 <Cale> > (-3) `mod` 2
17:52:33 <newsham> does that include talking to people about it on irc?
17:52:34 <sorear> newsham: I've only recieved 2 patches
17:52:34 <lambdabot>  1
17:52:37 <Cale> > (-3) `rem` 2
17:52:39 <lambdabot>  -1
17:53:38 <davidL> > head [ x | x <- [1..], all (\y -> liftM2 (==) ($ x) ($ y) (sort . show)) (map (x*) [2..6])]
17:53:40 <lambdabot>  142857
17:53:49 <newsham> ?check n m = m == 0 || (let (q,r) = n `divMod` m in q*m+r == n)
17:53:49 <lambdabot>  Parse error
17:54:39 <newsham> ?check \n m -> m == 0 || (let (q,r) = n `divMod` m in q*m+r == n)
17:54:40 <lambdabot>  Add a type signature
17:54:48 <cdsmith> sorear: okay, just found another source that says 270 loc per month.  That makes you only a little over 12 times average. :)
17:54:49 <newsham> ?check \n m -> (m :: Int) == 0 || (let (q,r) = n `divMod` m in q*m+r == n)
17:54:50 <lambdabot>  OK, passed 500 tests.
18:17:18 <dibblego> > 208 * 210
18:17:20 <lambdabot>  43680
18:34:19 <ndm> @seen sorear
18:34:19 <lambdabot> sorear is in #haskell-overflow, #haskell-blah, #ghc, #haskell-soc, #xmonad and #haskell. I last heard sorear speak 41m 45s ago.
18:34:52 <davidL> > [ (m^2-n^2, 2*m*n, m^2+n^2) | n <- [1..10], m <- [1..10]]
18:34:54 <lambdabot>  [(0,2,2),(3,4,5),(8,6,10),(15,8,17),(24,10,26),(35,12,37),(48,14,50),(63,16,...
18:35:00 <sorear> ndm?
18:35:05 <ndm> sorear: just for your info (i'm sure you'll see the darcs commit in half an hour), i'm thinking of writing a paper on the automatic derivation stuff from derive for the York Doctoral Symposium
18:35:19 <sorear> Ooh, nice.
18:35:39 <sorear> I have no idea what a Doctoral Symposium is, but it sure sounds important :)
18:35:40 <ndm> its a York local thing, so not a real paper, but a chance to put it down in printed form
18:35:53 <ndm> think of it as a few PhD students and a free meal :)
18:36:13 <davidL> CS PhD's?
18:36:27 <ndm> mainly, yeah, although some chem/bio ones as well
18:36:35 <sorear> ndm: so a conference-format thing where all the wannabe PhDs talk about their research?
18:37:45 <ndm> sorear, yes, but with published proceedings and reviewing (although i think its very light reviewing)
18:38:03 <ndm> mainly a way to get PhD students doing conference style things but in a much more local setting
18:38:10 <ndm> plus a free banquet!
18:38:16 <sorear> Yum.
18:38:17 * sorear -> dinner
18:43:40 <sbenitezb> Hi. Say I output a line with putStrLn "bla bla some word with unicode char like Ã¡". Why that char does not show correctly on my utf-8 enabled term?
18:43:56 <allbery_b> because haskell doesn't actually support utf8 I/O :/
18:44:04 <allbery_b> just utf8 source code
18:44:10 <ddarius> Haskell implementations...
18:44:19 <allbery_b> yeh, I should say current haskell implementations
18:44:26 <allbery_b> the standard says it should work.  it doesn't.
18:45:12 <sbenitezb> Is there a way to make it work?
18:45:24 <ddarius> There are some libraries...
18:45:26 <mauke> encode it yourself
18:46:05 <sbenitezb> thanks.
18:47:44 <newsham> > (iterate succ 'a') !! 200
18:47:46 <lambdabot>  '\297'
18:48:06 <newsham> what happens when you print out '\297' ?
18:49:31 <newsham> i get weird chars when i  putStrLn "\280" or so...
18:49:47 <mauke> > 297 `mod` 256
18:49:49 <lambdabot>  41
18:49:57 <mauke> > '\41'
18:49:59 <lambdabot>  ')'
18:50:00 <newsham> i'm not getting char 41
18:50:03 <mauke> I am
18:50:06 <newsham> wait i was
18:50:25 <newsham> nevermind
19:12:45 <chessguy> ?seen procyon112
19:12:45 <lambdabot> I saw procyon112 leaving #gentoo-haskell and #haskell 1d 8m 11s ago, and .
20:09:57 <wy> Is there a cube root function?
20:10:19 <SamB_XP> > 27 ** (1/3)
20:10:21 <ddarius> (**(1/3))
20:10:24 <lambdabot>  3.0
20:10:47 <dmwit> > 27 ^^ (1/3)
20:10:48 <lambdabot>  Add a type signature
20:10:53 <dmwit> :t (^^)
20:10:55 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:11:33 <mainland_> i'm having a hard time figuring out how to use the profiler
20:11:51 <mainland_> i have a 4-lien function that takes up about 50% of my run-time
20:11:51 <ddarius> mainland_: You've RTFM?
20:11:59 <SamB_XP> mainland_: what have you figured out so far?
20:12:20 <SamB_XP> did you read about all the profiling-related compiler options?
20:12:22 <mainland_> well, i turned on -auto-all
20:12:27 <mainland_> yes, i did
20:12:46 <mainland_> i added cost centers to all 4 expressions in my 4-line function
20:12:49 <mainland_> just for kicks
20:12:59 <mainland_> and yet 50% still sits in the "individual" time column
20:12:59 <SamB_XP> oh?
20:13:15 <Cale> How many entries?
20:13:36 <mainland_> 1
20:14:33 <Cale> hmm, okay
20:14:36 <mainland_> space leak whose thunks all get collapsed?
20:15:19 <Cale> mm, I don't know. I think it attributes time to the thing which is creating the thunks in that case.
20:16:34 <wy> How about cube root into complex numbers?
20:16:45 <SamB_XP> hmm?
20:16:47 <Cale> What is the code doing?
20:16:56 <SamB_XP> you want the *other* cube roots?
20:16:59 <mainland_> all the other profiling numbers make sense and are broken down nicely, but this one function that doesn't do anything "owns" 50% of my runtime
20:17:11 <ddarius> :t exp
20:17:13 <lambdabot> forall a. (Floating a) => a -> a
20:17:16 <wy> SamB_XP: yes. Just for test.
20:17:17 <mainland_> it's a theorem prover
20:17:24 <mainland_> heavy use of LogicT
20:17:25 <Cale> wy: x**(1/3) ?
20:17:26 <dmwit> > (3 :+ 4) ^ (1/3) -- ?
20:17:28 <lambdabot>  Add a type signature
20:17:34 <dmwit> :t (:+)
20:17:35 <SamB_XP> Cale: he wants the *other* cube roots
20:17:37 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
20:17:40 <SamB_XP> not *that* one
20:17:48 <dmwit> > (3 :+ 4) ^ (1/3) :: Complex Double
20:17:49 <lambdabot>  Add a type signature
20:17:59 <dmwit> > (3 :+ 4) ** (1/3) :: Complex Double
20:18:00 <lambdabot>  1.6289371459221758 :+ 0.5201745023045458
20:18:31 <wy> Not in scope: type constructor or class `Complex'
20:18:42 <dmwit> ?index Complex
20:18:43 <lambdabot> Data.Complex
20:18:45 <Cale> wy: import Data.Complex
20:18:53 <wy> Thanks!
20:19:47 <dmwit> :t ((**), (^^), (^)) -- does anyone have a nice way of remembering which is which?
20:19:49 <lambdabot> forall a a1 b a2 b1. (Floating a, Integral b, Fractional a1, Integral b1, Num a2) => (a -> a -> a, a1 -> b -> a1, a2 -> b1 -> a2)
20:20:37 <wy> I want all three cube roots... I guess I have to write this myself now.
20:20:39 * ddarius has no trouble remembering which is which.
20:21:03 * dmwit does, obviously
20:22:39 <SamB_XP> dmwit: the ones with ^ are potentially exact
20:22:39 <SamB_XP> the ** one is for floating-point
20:22:45 <SamB_XP> and ^ is the simplest ever
20:23:29 <dmwit> Oh, (^) is something like (iterate (*)) !! n or whatever?
20:23:41 <dmwit> Okay, that's a good hint, thanks.
20:24:15 <sorear> yes, except it is more efficient
20:24:17 <sorear> @src ^
20:24:18 <dmwit> (Actually, I guess it would probably use repeated squaring under the hood, but yeah, I get it.)
20:24:18 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:24:21 <sorear> @src (^)
20:24:22 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:24:26 <sorear> yes.
20:34:27 <araujo> hi hi
20:34:49 <dmwit> heyo!
20:46:20 <Taral> @seen JohnMeacham
20:46:20 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. I don't know when JohnMeacham last spoke.
20:46:26 <Taral> Bah.
20:49:45 <appletizer> @seen bluew
20:49:45 <lambdabot> I haven't seen bluew.
20:49:49 <appletizer> ?seen bluew
20:49:50 <lambdabot> I haven't seen bluew.
21:22:05 <dibblego> ?where yaht
21:22:06 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:26:43 <wy> I still haven't figured out how to use random numbers
21:27:10 <ddarius> Don't worry.  They've figured out how to use you.
21:27:52 <sorear>  /q kc5tja
21:29:00 <wy> Can you give me an example generating a random number?
21:29:11 <sorear> 42
21:29:33 <sorear> > randomRs (0,9) (mkStdGen 42)
21:29:34 <wy> sorear: No. That's the answer to the ultimate question.
21:29:35 <lambdabot>  [1,1,7,4,6,1,8,1,8,5,5,9,6,8,4,5,7,1,3,6,6,4,2,4,6,4,0,8,3,4,4,5,2,2,6,3,4,2...
21:36:50 <wy> I have a problem understanding this tutorial: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
21:36:54 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
21:37:05 <wy> The part about randomized functions.
21:38:14 <dmwit> do tell
21:38:32 <wy> bind's type is bind :: (a â StdGen â (b,StdGen)) â (StdGen â (a,StdGen)) â (StdGen â (b,StdGen)). How can we get this?
21:39:07 <dmwit> As in, you want the solution?
21:39:58 <dmwit> Here's a hint: try writing it in this form:
21:40:18 <dmwit> bind :: (a -> StdGen -> (b, StdGen)) -> (StdGen -> (a, StdGen)) -> StdGen -> (b, StdGen)
21:40:23 <sorear> whoa
21:40:27 <monochrom> That is just (flip (>>=)) specialized to the State monad and further picking StdGen as state.
21:40:40 <dmwit> That way, you can write bind's pattern match as
21:40:46 <wy> I think it should be bind :: (a â StdGen â (b,StdGen)) â  (a,StdGen) â (b,StdGen)
21:40:49 <dmwit> bind f g stdgen = ...
21:41:00 <sorear> I CAN SEE WY'S ARROWS!
21:41:10 <dmwit> monochrom: Yeah, it's a monad tutorial. ;-)
21:41:13 <wy> Why is there another StdGen?
21:41:21 * monochrom welcomes sorear to the club
21:41:27 <ddarius> sorear: It's not polite to point it out.
21:41:46 <sorear> ddarius: even if I'm really really happy?
21:41:55 <sorear> oops.
21:42:00 <sorear> sorry, wy.
21:42:03 <dmwit> wy: Because the functions you have are of type (StdGen -> (a, StdGen)).
21:42:19 <dmwit> That is, you already have some random functions, and you want to write the plumbing for them.
21:42:31 <dmwit> So you have to respect their type signatures; you can't force them into an easier form.
21:42:49 <dmwit> s/can't/don't want to/
21:43:01 <wy> But eariler the tutorial says the type of the randomized function is: a â StdGen -> (b,StdGen)
21:43:36 <wy> So it takes a and seed, and it output b and another seed
21:44:57 <wy> The first argument to bind is of type (a â StdGen â (b,StdGen)). That's the original function.
21:45:04 * dmwit goes to review the actual questions asked
21:46:05 <wy> But the outputed function is type (StdGen â (a,StdGen)) â (StdGen â (b,StdGen)). It takes one more StdGen.
21:46:27 <ddarius> Nope.
21:46:32 <dmwit> wy: Conceptually, it takes a function and a StdGen, not an extra StdGen.
21:47:08 <monochrom> It takes time to see the true purpose of this.
21:47:20 <ddarius> Technically, you can view the two negative occurences of StdGen as two productions of it, but then there is two positive occurences as well.
21:48:10 <dmwit> wy: Here's one way to think about it.
21:48:21 <dmwit> The first argument is (a -> StdGen -> (b, StdGen)).
21:48:32 <wy> ddarius: What's negative occurence?
21:48:43 <dmwit> That means it is a function to generate random values "b", based on a parameter "a".
21:48:45 <wy> dmwit: yes.
21:48:58 <dmwit> The second argument tells how to randomly generate parameters "a".
21:49:10 <dmwit> Then, the return value should be something that randomly generates values "b".
21:50:01 <wy> dmwit: wait. Why does the second argument tells how to randomly generate "a" instead of "b"?
21:50:26 <dmwit> The second argument is of type (StdGen -> (a, StdGen)), right?
21:50:34 <dmwit> (I'm discussing the arguments of "bind" here.)
21:50:44 <wy> Oh. I see
21:51:44 <dmwit> So, if we know how to generate "a", and we know how to generate "b" given "a", we should be able to create a new thing that knows how to generate a "b" all on its own.
21:51:48 <wy> Why are (a,StdGen) randomly generated?
21:51:52 <dmwit> (In monad notation, we would write this as
21:52:06 <dmwit> "know how to generate 'a'" -> m a
21:52:20 <dmwit> "know how to generate 'b' given 'a'" -> (a -> m b)
21:52:31 <dmwit> "know how to generate 'b'" -> m b
21:53:30 <dmwit> wy: The random number generator function "consumes" its StdGen input and creates a new StdGen to pass on to future calls.
21:54:02 <dmwit> So it has to have a type like (StdGen -> (a, StdGen)), because it needs to tell you both the random value it generated and a new StdGen to pass on.
21:54:10 <wy> dmwit: Maybe I haven't understand what the randomized function is for...
21:55:07 <dmwit> wy: Have you generated random numbers in other languages?
21:55:27 <dmwit> The idea is that, to preserve referential transparency, you need to explicitly seed the random number generator *each time* you use it.
21:55:41 <wy> Yes, I have. I think it takes something of type "a", and a seed, then it can use this seed to randomly generate b.
21:55:54 <dmwit> right
21:55:57 <dmwit> exactly!
21:56:09 <wy> That's what (a -> StdGen -> (b, StdGen)) mean.
21:56:27 <dmwit> Nice.
21:56:45 <dmwit> And now you have a function (StdGen -> (a, StdGen)) that generates a random "a" to be used.
21:56:52 <dmwit> The question is just how to connect those two functions.
21:56:58 <wy> But I don't undertand why the augmented function takes (StdGen -> (a, StdGen))
21:57:51 <dmwit> wy: Because you want to delay specifying which seed is used until much later.
21:58:19 <dmwit> Put another way:
21:58:38 <dmwit> You want to be able to generate a "b" from any seed.
21:58:42 <dmwit> But you need both an "a" and a seed.
21:58:53 <wy> yes
21:59:04 <dmwit> So you need some function that takes a just a seed and gives you both a seed and an "a".
21:59:46 <wy> dmwit: Why don't I have "a" as input?
22:01:29 <dmwit> Let's just say you want to generate everything randomly.
22:01:33 <dmwit> This includes "a".
22:01:47 <dmwit> So, the only thing you get to start with is a seed.
22:02:05 <wy> dmwit: But that's not the purpose of the original function. It takes something of type "a"
22:02:05 <dmwit> There are certainly other use cases where you would have an "a", but for now you don't.
22:02:44 <dmwit> wy: It wouldn't be very interesting to use a deterministic "a", now would it?  Then things wouldn't be very random.
22:02:59 <dmwit> My advice would be just to accept the use case and see if you can work through the exercises.
22:03:19 <wy> OK. I'll see
22:06:51 <wy> Still hard to understand this.
22:08:03 <wy> Lost connection with former examples
22:09:06 <ddarius> Probably simply explaining state monads generally would be the best bet.  It is often easier to explain -more- polymorphic code because it is more constrained.
22:09:25 <wy> Former examples tried to augment the funtions so that they return more things than the original ones.
22:10:30 <wy> Then bind tries to augment their input channel to accept those augmented outputs.
22:11:30 <dmwit> wy: This one is similar; it tries to augment functions to allow them to hold some shared state.
22:11:38 <dmwit> ddarius' idea is good.
22:11:49 <dmwit> The basic idea is that you have a bunch of functions
22:12:03 <dmwit> State -> (Value, State)
22:12:22 <dmwit> where the State on the right-hand side could be modified in some way
22:12:52 <dmwit> You also have a function :: Input -> State -> (Value, State)
22:13:33 <dmwit> mmm...
22:13:43 <dmwit> So, let's say we have
22:13:50 <dmwit> foo :: State -> (Input, State)
22:13:52 <wy> My brain is not on this way yet...
22:14:01 <dmwit> bar :: Input -> State -> (Output, State)
22:14:30 <wy> In both former examples the output type of the funtion won't be changed by bind. But this one changed.
22:14:33 <lispy> drinks :: State -> State
22:14:34 <dmwit> And you want to generate quux :: State -> (Output, State)
22:15:44 <dmwit> wy: How is the output type changed?
22:16:01 <jbauman> in my limited experience, the best way to learn this stuff is to write programs with it
22:16:13 <wy> dmwit: from (b,StdGen) to (StdGen â (b,StdGen))
22:16:47 <dmwit> wy: That's the output of bind, not the output of the function that bind creates.
22:16:57 <wy> jbauman: I think so. Make it concrete and run would be good for me.
22:17:33 <wy> dmwit: Bind creates a function of (StdGen â (a,StdGen)) â (StdGen â (b,StdGen))
22:17:43 <jbauman> you soon learn what your misconceptions are, at least
22:17:50 <dmwit> wy: Hmmm...
22:18:02 <dmwit> The way I see it, bind creates a function of type (StdGen -> (b, StdGen)).
22:18:21 <wy> dmwit: So the output type of the function generated by bind is  (StdGen â (b,StdGen))
22:18:23 <ddarius> jbauman: You have to have some basis to work with.  Though in this case, perhaps seeing the "internals" of monads is not the best thing at the point wy is at.
22:18:59 <dmwit> wy: In your opinion, what is the output type of bind for the debuggable functions?
22:19:37 <jbauman> maybe just working with do notation, and expanding from that to a full understanding
22:19:50 <wy> dmwit: The former example has types: (t -> (t1, [a])) -> (t, [a]) -> (t1, [a])
22:19:52 <jbauman> although that has the risk of trapping you in a faulty understanding
22:20:02 <wy> (a -> [a1]) -> [a] -> [a1]
22:20:14 <wy> both haven't changed the output type of the function.
22:20:56 <dibblego> is there a function of type [[a]] -> [a] that returns an empty list if its argument is empty, or the head of the argument otherwise?
22:21:08 <dmwit> wy: Either you're confused, or I'm looking at a different page from you.
22:21:20 <ddarius> dibblego: drop 1
22:21:26 <dmwit> Or I'm confused.
22:21:27 <dibblego> ddarius, duh thanks
22:21:30 <dmwit> Probably I'm confused.
22:21:39 <ddarius> Er something like that
22:21:40 <lispy> > drop 1 []
22:21:42 <lambdabot>  []
22:21:44 <ddarius> :t drop 1
22:21:47 <lambdabot> forall a. [a] -> [a]
22:21:57 <wy> dmwit: Sorry I pasted the output from my interpreter.
22:22:01 <dmwit> :t concat . take 1
22:22:03 <lambdabot> forall a. [[a]] -> [a]
22:22:19 <wy> The first one is (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
22:22:31 <wy> on the page. right?
22:22:37 <dmwit> So, in your opinion, what is the output of that one?
22:22:43 <dmwit> wy: right, okay, I'm with you now.
22:23:54 <wy> dmwit: So he wants to change the funtion (Float -> (Float,String)) so that it accepts the same thing as its output. So he tried to augment the input type, without changing the output type.
22:23:54 <jbauman> > concat . take 1 $ [[1]]
22:23:56 <lambdabot>  [1]
22:24:02 <jbauman> > concat . take 1 $ []
22:24:03 <lambdabot>  []
22:25:10 <wy> The second is (Complex Double -> [Complex Double]) -> ([Complex Double] -> [Complex Double])
22:25:43 <wy> It outputs a list of complex numbers, but it only accept one complex number. So bind augmented the input type to a list.
22:26:26 <wy> I just wish I could get the correct type from this line of reasoning to the randomized ones.
22:27:28 <dmwit> wy: type BRAH a = StdGen -> (a, StdGen)
22:27:42 <dmwit> bind :: (a -> BRAH b) -> (BRAH a -> BRAH b)
22:27:52 <dmwit> This is how you extend the reasoning of the previous two.
22:28:30 <dmwit> You can also do this reasoning without the BRAH type, if you see the (StdGen -> (a, StdGen)) bit as one coherent whole.
22:30:04 <wy> (a -> BRAH b) == (a â StdGen â (b,StdGen))
22:30:30 <wy>  (BRAH a -> BRAH b) == (StdGen â (a,StdGen)) â (StdGen â (b,StdGen))?
22:30:41 <dmwit> yes
22:30:58 <wy> but why BRAH b != BRAH b ?
22:31:30 <dmwit> a -> StdGen -> (b, StdGen) == a -> (StdGen -> (b, StdGen)) == a -> BRAH b
22:32:07 <dmwit> Or, maybe I should ask why you think BRAH b /= BRAH b.
22:32:31 <wy> dmwit: .... Ah...
22:32:38 <wy> I almost see
22:32:55 <dmwit> commence mind warping!
22:33:13 <ddarius> begin mind wefting.
22:34:02 <wy> BRAH b == StdGen â (b,StdGen)
22:34:54 <wy> I thought BRAH b is  (b,StdGen) because I took both a and StdGen as input arguments.
22:35:54 <dmwit> aha
22:35:59 <wy> Thanks for the BRAH notation!
22:36:05 <dmwit> Yes, this is a slightly more complicated one. =)
22:36:39 <wy> Can this BRAH reasoning be applied in most cases?
22:36:47 <dmwit> Yes.
22:37:00 <dmwit> It can be applied for any monad. ;-)
22:37:05 <purejadekid> :t >>=
22:37:07 <lambdabot> parse error on input `>>='
22:37:10 <dmwit> I just used a different name to throw you off the track.
22:37:13 <dmwit> :t (>>=)
22:37:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:37:25 <wy> dmwit: Good. You can write yet another tutorial
22:37:37 <dmwit> heh
22:38:05 <ddarius> Good ole, (>>=) :: WFT a -> (a -> WFT b) -> WFT b
22:39:40 <test12> hey anyone out there use hws?
22:43:25 <wy> dmwit: Are you a student?
22:43:46 <dmwit> yeah
22:43:56 <wy> dmwit: What do you study?
22:44:06 <dmwit> Well, computer science.
22:44:11 <dmwit> I don't really have a focus within the area yet, though.
22:44:19 <wy> dmwit: grad?
22:44:23 <dmwit> under
22:44:29 <dmwit> You?
22:44:43 <wy> dmwit: I'm also CS, but I'm grad.
22:45:10 * dmwit commences googling/cornelling
22:45:18 <wy> dmwit: It seems no one in Stanford is studying these things either.
22:45:25 <dmwit> Yeah. =(
22:45:29 <purejadekid> can someone darcs get http://darcs.haskell.org/packages/network/ and tell me that I'm crazy because Setup.hs won't compile under GHC 6.6.1?
22:45:32 <lambdabot> Title: Index of /packages/network
22:45:54 <wy> dmwit: Maybe you can be the first huh
22:46:08 <dmwit> I'll probably go somewhere else for my graduate work.
22:46:14 <dmwit> I think it's typically recommended to move, right?
22:46:54 <wy> dmwit: I don't know. Where do you want to go?
22:47:15 <dmwit> purejadekid: Yeah, Setup.hs seems broken.
22:48:08 <purejadekid> dmwit: thx for checking
22:48:38 <dmwit> wy: I don't know.
22:48:42 <dmwit> I guess I should get on that, huh?
22:48:48 <dmwit> Got any recommendations? ;-)
22:48:54 <purejadekid> dmwit: I recompiled GHC 6.6.1 from source and Network.URI is AWOL
22:50:03 <wy> dmwit: I have no idea. It seems you'll get starved if you choose this as a topic in the US.
22:51:19 <wy> dmwit: But if you can pretend to do some Java, some security, some verification ;-)
22:51:30 <dmwit> ...
22:51:31 <dmwit> =(
22:51:40 <dmwit> Okay, I've narrowed you down to three possible people.
22:52:12 <wy> dmwit: Which three?
22:52:40 <dmwit> Woo Ram Youn, Yanling Wang, or Yin Wang
22:52:48 <dmwit> (I think it's Woo Ram Youn.)
22:53:24 <dmwit> Or you could be sneaky, and wy could have nothing to do with your name. =P
22:53:37 <wy> You are looking at our directory. haha
22:56:33 <wy> dmwit: I guess you won't have a directory of undergrads in Stanford
22:57:06 <sorear> wy: am I the only one you haven't told your plans to yet? ;)
22:57:22 <wy> sorear: What's my plan?
22:57:24 <dmwit> Oh, I found me (without logging in to the intranet), so you can too.
22:57:37 <dmwit> But I'm not terribly secretive, I'm Daniel Wagner.
22:58:00 <dmwit> (You could learn that much from a /whois. ;-)
22:58:21 <joelr1> good morning
22:58:24 <sorear> wy: You've singled out both augustsson and wagner, apparantly about CS research, odd behaviour....
22:58:26 <sorear> hello joelr1
22:58:49 <joelr1> @localtime joelr1
22:58:51 <lambdabot> Local time for joelr1 is 2007-05-09 06:58:19 +0100
22:58:52 <wy> sorear: Who's wagner?
22:58:54 <joelr1> he
22:59:13 <sorear> wy: dmwit when I'm in list-of-last-names mode
23:00:34 <wy> sorry for that
23:00:54 <sorear> I'm just being too-curious.  No need for sorries.
23:02:33 <wy> sorear: Why are you curious?
23:03:38 <sorear> I don't know.  Better consult a psychoanalyst.
23:04:46 <dmwit> wy: I'm disappointed, you don't have any papers on the first page of hits in Google Scholar.
23:06:49 <wy> dmwit: You look like FBI
23:07:13 * dmwit stops net-stalking
23:10:23 <joelr1> sorear: did you have any luck catching up with alexj?
23:10:52 <wy> It's so unfortunate if you say your favorite language is Haskell and not mention Java, you'll fail in almost all job interviews.
23:11:12 <Korollary> no you wouldnt
23:11:14 <sorear> joelr1: nope.
23:11:20 <dmwit> Dunno, at my last job interview, they made me explain monads.
23:11:22 <sorear> goodnight.
23:11:33 <joelr1> good night
23:11:44 <dmwit> Wel...
23:11:49 <wy> Google asked me: What's the difference between an abstract class and an interface...
23:11:57 <dmwit> I guess job interviews are a little atypical when you're just gunning for an internship.
23:12:09 <dmwit> wy: That's terrible!
23:12:28 <dmwit> wy: They asked me the best way to be a pirate. =D
23:12:56 <Japsu> Yarr harr, a pirate is free! You are a pirate.
23:13:09 <dmwit> You are a parrot!
23:13:21 <dmwit> pink hair is disturbing
23:13:34 <ddarius> not really
23:13:47 <goltrpoat> i haven't been to a job interview in about 5 years..  that's actually a pretty scary proposition
23:15:02 <wy> dmwit: I thought they should have known that functional languages that you can implement object oriented languages yourself. But it seems you still have to show them you know them.
23:16:08 <wy> dmwit: Who asked you about monads?
23:16:14 <dmwit> wy: So what is the difference?  An abstract class is just an interface that nobody implements, or what?
23:16:47 <dmwit> wy: The lunch-interviewer at Fog Creek was intrigued that I listed Haskell as a language.
23:17:06 <dmwit> I don't expect that they use it much in-house, but he probably had used it once or twice on his own.
23:18:14 <jbauman> abstract classes can include implementation details
23:18:39 <jbauman> also, you can only inherit from one abstract class, while you can implement many interfaces
23:19:09 <wy> dmwit: Ah, Fog Creek. That guy designed VB
23:19:56 <dmwit> Okay, so interfaces are (roughly) Haskell's type classes.
23:20:29 <goltrpoat> dmwit:  i think that's generally considered a bad comparison
23:20:52 <goltrpoat> c++-style type traits are a reasonable comparison to type classes in terms of usage
23:21:32 <goltrpoat> there are some issues with drawing too many parallels between base/interface classes in OO programs with haskell-style typeclasses.
23:21:34 <wy> jbauman: That's the correct answer, but who cares. You can modify their behavior to anything you want if you can modify the language.
23:22:02 <goltrpoat> templates are closer, but c++ templates implement dependent types
23:22:15 <goltrpoat> hence traits.
23:22:52 <jbauman> wy, well yes, but then you have your only little language that only you know how to program in
23:22:52 <goltrpoat> 'concepts' from TR2 are very close to, and probably inspired by, typeclasses, if that helps.
23:23:55 <jbauman> s/only/own/;
23:24:08 <wy> I just can't think of any proof of the necessity of their existence.
23:24:32 <goltrpoat> whose existence?
23:24:55 <wy> abstract classes and interfaces
23:25:08 <goltrpoat> in OO?
23:25:12 <dmwit> wy: You and dibblego would get along well -- he has the same soapbox.
23:25:14 <jbauman> well, interfaces are useful if you don't have multiple inheritance
23:25:15 <goltrpoat> or FP
23:25:31 <goltrpoat> interfaces have pretty obvious utility in OO
23:25:33 <Cale> They are inspired by typeclasses, they cite Wadler's paper even, if I recall.
23:25:49 <Cale> (concepts)
23:25:51 <jbauman> abstract classes would probably be better tied to an interface, though, for more flexibility
23:25:58 <jbauman> although this isn't #java...
23:26:13 <goltrpoat> Cale:  ah, definitely makes sense
23:26:17 <wy> jbauman: Your name starts with J.
23:26:42 <jbauman> intriguing
23:27:45 <wy> dmwit: I'd better go to sleep and continue the tutorial tomorrow. Thanks a lot!
23:27:52 <dmwit> ?localtime wy
23:27:54 <lambdabot> Local time for wy is Wed May 09 02:28:03
23:28:01 <dmwit> heh, yeah
23:28:03 <dmwit> Good luck!
23:28:25 <wy> Good night all!
23:29:07 <goltrpoat> odd.  i'd go as far as saying that the ability to define interface-level classes is the main thing that makes OO useful.
23:29:38 <goltrpoat> take that away, and you get a sort of a random mishmash of crap you can't reason about.
23:30:13 <jbauman> inheritance and data hiding can be somewhat useful
23:30:54 <goltrpoat> data hiding has little to do with OO
23:31:13 <goltrpoat> inheritance is only useful to the point that you can talk about supertypes
23:31:17 <jbauman> but it's a big part of the ideology
23:31:35 <goltrpoat> eg, the liskov principle type stuff
23:33:19 <goltrpoat> and once you're talking about supertypes, and delegating the particulars to the subtypes, it's only natural to want a supertype that only defines the functionality.  typically, in large projects, you *have* to have those supertypes.
23:34:20 <goltrpoat> it's part of why haskell's type system is so nice, because you can talk about supertypes while specifically eschewing the details of what the instances do within the constraints of the interface.
23:35:32 <goltrpoat> if member defaults were dropped from the language, it'd require some rewriting and some duplicated code, but no one would be particularly upset, i don't think.
23:48:09 <Cheery> http://mureakuha.com/paste/?c6c5bb1cdfd09da9a40f407547381a17
23:52:07 <dblhelix> goltrpoat: class definitions would become smaller, I think---and that's not necessarily a good thing
