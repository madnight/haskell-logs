00:00:51 <sjanssen> timthelion: correct
00:01:23 <timthelion> how do I change the mod1 to SUPER, I use the alt key in emacs
00:01:23 <sjanssen> timthelion: there's a 'restart' key combo that makes that pretty painless
00:01:34 <sjanssen> look in Config.hs
00:02:27 <timthelion> ok
00:03:08 <timthelion> ok, I'll be back
00:10:45 <rsavu> hello all. can somebody guide me in resolving the knight's tour problem in haskell? i know how to do it in an imperative language, but not in functional programming
00:12:18 <dons> http://www.google.com.au/search?hl=en&q=knight%27s+tour+haskell
00:12:19 <lambdabot> Title: knight&#39;s tour haskell - Google Search
00:12:19 <dons> :-)
00:13:51 <TSC> rsavu: Are you having any particular problem?
00:15:55 <notsmack> rsavu: would you use recursion in an imperative language?
00:17:44 <timthelion> didn't work, startx gives me blank screen M-S-RET does nothing
00:18:13 <dmwit> Which key is M in that combo?
00:18:17 <timthelion> alt
00:18:30 <dons> you sure xmonad is running?
00:18:39 <timthelion> but I tried ctrl and esc and super as well
00:18:43 <timthelion> both sides
00:18:45 <dmwit> xmonad needs a welcome screen. =P
00:18:53 <dons> (why not run it from .xinitrc or .xsession?)
00:19:03 <timthelion> I did
00:19:27 <dons> what does xmodmap say your mod1 key is?
00:19:38 <dons> and is xterm in your path?
00:20:25 <dons> try lauching an xterm from your start script first, so you can find out what's running
00:20:42 <timthelion> ok did so
00:20:42 <dons> xterm &
00:20:43 <dons> exec /home/dons/bin/xmonad
00:20:48 <timthelion> it's up
00:21:03 <timthelion> with a red boarder which is good
00:21:11 <dons> ok. good. xmodmap
00:21:16 <dons> does it report what key mod1 is?
00:21:37 <dons> try launching a couple more xterms from the first one
00:21:43 <dons> they should get tiled, if xmonad is running
00:22:40 <timthelion> alt_l,alt_l,meta_l
00:23:01 <dons> so , with several xterms open , does alt-j and alt-k move focus around?
00:23:03 <timthelion> they did
00:23:25 <timthelion> nope
00:23:59 <sjanssen> timthelion: is numlock on?
00:24:11 * sjanssen hopes that isn't the problem
00:24:36 <timthelion> no numlock is not on
00:25:00 <dons> the key to be used as the mod key is set in Config.hs,
00:25:01 <dons> modMask :: KeyMask
00:25:01 <dons> modMask = mod1Mask
00:25:29 <dons> so, you need to work out if your mod key is something else.
00:25:36 <dons> any change it got remapped somehow?
00:25:51 <dons> or do other mod / alt keys cause, say, mod-space to work?
00:25:58 <dmwit> Maybe use xev to find the modkey mask?
00:26:33 <timthelion> xev reports normal Alt_L
00:26:44 <dmwit> huh
00:26:46 <dons> KeyPress event, serial 20, synthetic NO, window 0x1c00001,
00:26:47 <dons>     root 0x40, subw 0xa002ac, time 1467857, (729,673), root:(731,675),
00:26:47 <dons>     state 0x0, keycode 64 (keysym 0xffe9, Alt_L), same_screen YES,
00:26:47 <timthelion> so it is bound to mod1
00:27:03 <timthelion> yes like that dons
00:27:37 <dons> are you sure mod-j isn't working? or say, mod-space ? or even quitting, with mod-shift-q ?
00:28:51 <timthelion> no luck
00:29:17 <dons> did you change your X environment in any way?
00:29:50 <dons> start X in an unusual manner? run some mod remapping before starting?
00:29:54 <timthelion> wait that worked
00:30:02 <timthelion> something did
00:30:10 <dons> sticky mod key? :-)
00:30:19 <timthelion> ah
00:30:23 <timthelion> nope
00:30:41 <timthelion> it's super that worked.  not sure why
00:30:51 <dons> what worked?
00:30:58 <timthelion> but thats what I wanted in the first place
00:30:59 <dmwit> super did ;-)
00:31:03 <dons> ah
00:31:24 <dons> 'super', what key is that?
00:31:25 <dmwit> Ambiguous grammars for the win!
00:31:28 <dons> Super_L bound to?
00:31:37 <timthelion> dons sometimes called k-key window-key or pinguine key
00:32:06 <dons> ok. so maybe your keyboard remaps those ? (my `happy hacking' keyboard does that)
00:32:15 <dons> so using that, then super-jk et al work?
00:32:25 <dons> if so, you can go through the tour, http://xmonad.org/tour.html
00:32:29 <lambdabot> Title: xmonad : a guided tour
00:34:27 <timthelion> yep  everything is happy now
00:34:53 <dons> ok. good. interesting that xmodmap was reporting the wrong info.
00:35:04 <timthelion> I hope that as well as being smart this will give me power like stumpwm
00:36:08 <timthelion> dons no I think it is because I changed the config file to mod4 temporarily and building it the 3rd time to change it back didn't click for some reason
00:36:15 <dons> ah ha.
00:36:25 <dons> mod-q to restart on the fly, btw.
00:36:29 <dmwit> Ah, yes, that's definitely it.
00:36:31 <dons> if you change the config file, and reinstall
00:36:34 <dmwit> Mod4 is almost always super.
00:36:36 <dons> yeah
00:36:38 <dons> it is here.
00:36:45 <dons> so we put that down as 'user error' ;)
00:36:53 <dons> phew!
00:36:59 <dmwit> heh
00:37:20 <dons> timthelion: yes, you need to reinstall the binary for config changes to stick.
00:37:45 <dmwit> That tour has some enormous window border!
00:38:03 <dons> yeah, for the config demo section?
00:38:21 <dons> (was trying to think of an obvious change)
00:38:30 <dmwit> yeah
00:38:46 <dmwit> I'm kind of interested in trying it now.
00:38:57 <dons> xmonad, or fat borders?
00:38:58 <dons> :-)
00:38:59 <dmwit> I've been sticking with 2px, but 10 or so could be refreshing.
00:39:06 <dons> its a bit cute
00:40:19 <rsavu> regarding the knight's tour problem, i don't know how to implement it in haskell. what aproach is best?
00:40:49 <dfranke> FGL?
00:41:44 <weitzman> rsavu: I imagine you won't see a great deal of agreement on a "best" approach, but if I had to do it I'd probably do depth first search with the list of unvisited squares and the current position as recursion parameters
00:41:51 <osfameron> morning
00:41:52 <lambdabot> osfameron: You have 1 new message. '/msg lambdabot @messages' to read it.
00:42:33 <osfameron> dcoutts: ta, I saw in the log archives (been a bit offline)
00:42:51 <dmwit> Yeah, with the list monad, DFS becomes really easy.
00:42:52 <osfameron> by the way, I couldn't find "intercalate" in Data.List.  "intersperse" yes.
00:43:01 <weitzman> rsavu: Probably with this type: findTour squares position :: [(Int,Int)]->(Int,Int)->Maybe [Int]
00:43:01 <dons> its in ghc head only
00:43:36 <dmwit> weitzman: Maybe [Int] ?
00:43:52 <weitzman> [Int] would be the solution tour if one is found
00:43:55 <weitzman> Or Nothing of it isn't
00:44:08 <notsmack> [(Int,Int)]?
00:44:14 <weitzman> The list of unvisited squares
00:44:30 <dmwit> I'd probably make something like
00:44:31 <notsmack> i mean shouldn't the tour be a list of squares as well?
00:44:33 <TSC> Then wouldn't the solution need to be [(Int,Int)]
00:44:37 <weitzman> Wait
00:44:40 <weitzman> Yeah, I'm stupid
00:45:03 <dmwit> takeOneStep :: [(Int, Int)] -> [[(Int, Int)]]
00:45:24 <TSC> I wrote a generic A* search algorithm a while ago, and just now plugged in the Knight's Tour problem to it
00:45:38 <TSC> It finds the solution very fast, with the right heuristic
00:46:09 <rsavu> :-?
00:46:28 <TSC> So take heart, it can be done in Haskell (:
00:46:36 <rsavu> I will try to think in the haskell way :D
00:46:37 <notsmack> TSC: what heuristic would you use?
00:46:48 <dmwit> rsavu: Do you grok A*, DFS, BFS, and other searches?
00:46:52 <TSC> Prefer squares that have few remaining neighbours
00:47:07 <TSC> (where "neighbour" means a knight's move away, not adjacency)
00:47:08 <notsmack> ah, interesting.
00:47:38 <dmwit> rsavu: If not, that's the first step, even before trying to do it "the Haskell way".
00:47:41 <dmwit> ;-)
00:48:13 <xpika> @where sourceview
00:48:14 <lambdabot> I know nothing about sourceview.
00:48:32 <rsavu> i know searching algorithms
00:48:56 <rsavu> that is not the problem. the haskell aproach is
00:49:01 <dmwit> ok
00:49:05 <xpika> @google sourceview
00:49:10 <lambdabot> http://www.tetradyne.com/srcvwax.htm
00:49:10 <lambdabot> Title: SourceView ActiveX Control
00:52:31 <dons> rsavu: you'll need an algorithm, or a data structure
00:52:39 <dons> then we can suggest how best to implement those in haskell
00:52:45 <dons> till then, its very hard to offer much advice.
00:53:29 <dons> timthelion: so how's it working, got all the key bindings worked out?
00:53:34 <rsavu> aha. okay. i'll try
00:53:40 <dons> timthelion: gone through the tour (any suggestions?)
01:01:13 <skew> sigh, I could use type lambdas. Newtypes are getting kind of annoying
01:05:07 <skew> Has anyone read that recent paper showing that higher-order matchin is deciable, well enough to say if it could be the basis of a checked-but-not-inferred part of a typesystem?
01:24:38 <roconnor> what is higher order matching?
01:25:18 <skew> a special case of higher order unification, where one lambda expression is known completely
01:25:49 <skew> higher order unification is when you have two lambda expressions with free variables and want to know if there are any substitions you can make that will make them unify, up to beta and eta equivalence
01:27:00 * osfameron read that as "lambda expressions with free will" and panicked
01:29:14 * roconnor wishes higher-order unification was poly-time
01:29:47 <skew> you'll have to settle for undecidable
01:30:03 <roconnor> yeah, it's pretty far from poly-time.
01:30:12 <skew> higher order matching is at least exponential, I think
01:31:59 <roconnor> In Coq, I have to keep changing the shape of my goals by hand before they will unify with theorems I want to apply. ... Wait, is this higher order maching?
01:32:26 <roconnor> I know the type of my lemma before hand
01:32:34 <roconnor> but I have dependent types.
01:32:43 <skew> perhaps
01:33:10 <skew> if you just need to instantiate some types on the lemmas then I think that bit is higher order matching
01:33:29 <roconnor> interesting
01:33:35 <skew> but if you also need to use some other lemmas to beat things into shape I'm not sure
01:34:09 <skew> but yeah, in general higher-order unification is good for figuring out whether a lemma can apply
01:34:50 <roconnor> I don't use other lemmas, I use the change tactic
01:35:03 <roconnor> this mean I reexpress my goal as another term that is converable
01:35:18 <roconnor> beta delta iota zeta equivalent.
01:35:58 <skew> I'm not sure about the delta iota zeta bit, beta would be covered
01:36:10 <roconnor> delta is unfolding definitions
01:36:17 <roconnor> so that isn't bad
01:36:30 <skew> seems like definitions shouldn't screw up the metatheory that much, but I've never worked out that sort of thing so I don't really know
01:36:41 <roconnor> iota is unfolding fixpoints and matches.  That may be a problem, but I don't think it is necessary most of the time.
01:37:10 <skew> It's just that higher order unification is usually studied under beta eta equivalence of pure lambda terms
01:37:11 <roconnor> zeta is unfolding let expressions, which also shouldn't be a problem and I also don't have much of.
01:37:37 <roconnor> yeah, delta isn't a big deal in theory, but it has a way of turning polynomial problems into exponential ones.
01:37:56 <skew> I know about all those bits, or where to look them up
01:38:21 <skew> I often find I have to use rewrite to make things go through, not just change
01:38:32 <roconnor> this is true
01:38:43 <roconnor> but when I have to use rewrite I don't complain.
01:38:56 <roconnor> the work just has to be done somewhere
01:39:04 <skew> yeah, but talking about matching it's really the elimination for =
01:39:18 <skew> which would look more like applying another lambda
01:39:32 <roconnor> interesting
01:39:43 <skew> er, lemma, not lambda
01:39:56 <skew> then you get back to a higher-order unification problem like
01:40:41 <skew> beat_stuff_into_shape Goal H1 H2 H3 H4 H5) ~= Lemm<fv1, fv2, fv2>
01:40:50 <skew> writing free variables with lowercase
01:41:25 <skew> at least if you do things the totally naive way
01:42:03 <skew> er, if you're just talking about equalities you might as well stick them on the right hand side
01:43:21 <skew> but really, I'm just happy to have a programming language with an "intuition" command
01:43:38 <roconnor> :)
01:43:41 <roconnor> funny I never use it
01:44:13 <Korollary> It works for some kind of proofs
01:44:16 <skew> what sort of things do you prove? mostly I'm trying to do simple properties of function definitions
01:44:43 <roconnor> skew: I'm currenly in the midst of proving that two different real number structures are isomorphic
01:45:18 <ivanm> evening everyone
01:45:37 <ivanm> just checking... there isn't an easy way of inverting functions automatically, is ther?
01:45:55 <dons> inverting?
01:45:55 <skew> usually my proofs go something like "induction on some arguments, then use these lemmas in these branches, and the rest is easy"
01:46:06 <dons> > not . isSpace -- ?
01:46:08 <lambdabot>  <Char -> Bool>
01:47:06 <ivanm> dons, as in if I have a function f of type Int -> Int, is it possible to automatically determine a function g such that f . g = g . f = id ?
01:47:12 <skew> ivanm: not in general, no. There are various special cases, if you have a specific problem
01:47:18 <ivanm> didn't think so
01:47:27 <ivanm> just checking just in case
01:47:31 <skew> for one, such a function doesn't necessarily exit
01:47:32 <ivanm> its only a trivial function anyway
01:47:34 <skew> exist
01:47:40 <skew> like, if f x = 0
01:47:48 <ivanm> but it'd look nicer in the code if the inverse was determined programatically
01:47:52 <ivanm> yeah :(
01:48:01 <ivanm> the function is just f n = n - 1
01:48:08 <ivanm> so its not like I can't do the inversion myself
01:48:17 <ivanm> just wanted to try and get haskell to do it
01:48:28 <skew> you can make a simple language of invertible operations
01:49:02 <quicksilver> you can't do much with 'real' functions
01:49:25 <ivanm> heh
01:49:25 <quicksilver> since haskell can't introspect code thunks, except as far as you can learn stuff by running them
01:49:34 <ivanm> yeah, I figured that
01:49:47 <quicksilver> if you want to manipulate functions-as-data then sometimes you want a higher level representation of them
01:49:55 <quicksilver> which amounts to an AST for a minilanguage, maybe
01:50:43 <Wild_Cat> inverting a non-injective function isn't possible anyway, by your definition of inverting.
01:53:12 * ivanm thinks a simple "no" would have been sufficient ;-)
01:53:44 <dons> not in #haskell!
01:53:51 <skew> well, if it's enough of a problem you can define a language of invertible functions
01:54:02 <skew> there are some serialization+deserialization libraries that work like that
01:54:07 <quicksilver> well the answer isn't 'no' :)
01:54:21 <quicksilver> the answer is 'yes, if that's what you need to do' :)
01:54:24 <Wild_Cat> ivanm: come on now, you don't expect computer scientists not to be pedantic, do you? :p
01:54:40 <ivanm> heh
01:54:40 <dons> "no." has only been used as an answer 274 times in the last 7 years here.
01:54:41 <quicksilver> you could make a typeclass of invertable functions, I think
01:54:42 <DRMacIver> wilx|wrk`: Well, there's an 'inverse'. It's just that the inverse of an arbitrary function of type a -> b is a function of type b -> Set a :)
01:54:45 <DRMacIver> Oops
01:54:48 <DRMacIver> I fail at tab complete.
01:54:54 <ivanm> heh
01:54:58 <dons> yes, 955 times.
01:54:58 <DRMacIver> That was to Wild_Cat
01:55:15 <ivanm> dons, what,  you regex'd the logs or something?
01:56:09 <quicksilver> dons just has a good memory
01:56:32 <ivanm> lol
01:56:49 <ivanm> dons also has time to save the world whilst kissing the girl as well, I take it? :p
01:56:55 <ivanm> something like that...
01:57:05 <dons> i usually have the time, yeah.
01:57:21 <dons> "yes!" has been used 337 times :-)
01:57:29 <Wild_Cat> DRMacIver: true. By that definition, g inverts f iff f . g . f == f
01:59:05 <dons> for some functions you can use SmallCheck or QuickCheck to find an inverse for you
01:59:34 <dons> ?check \f g -> f . g = g . (f :: Bool -> Bool)
01:59:34 <lambdabot>  Parse error
01:59:48 <dons> ?check \f g x -> (f . g) x = g . (f :: Bool -> Bool) $ x
01:59:49 <lambdabot>  Parse error
01:59:55 <dons> ?check \f g x -> (f . g) x == g . (f :: Bool -> Bool) $ x
01:59:56 <lambdabot>  Couldn't match expected type `Bool'
02:00:02 <dons> ?check \f g x -> (f . g) x == (g . (f :: Bool -> Bool) $ x)
02:00:03 <lambdabot>  Falsifiable, after 3 tests: <Bool -> Bool>, <Bool -> Bool>, False
02:00:08 <dons> ?scheck \f g x -> (f . g) x == (g . (f :: Bool -> Bool) $ x)
02:00:10 <lambdabot>   Failed test no. 5. Test values follow.: {True->True;False->True}, {True->Fa...
02:00:13 <dons> there we go
02:00:20 <dons> ?scheck \f g x -> (f . g) x /= (g . (f :: Bool -> Bool) $ x)
02:00:21 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, {True->Tr...
02:00:28 <dons> so that found a case where it was true
02:00:36 <dons> ?scheck \f g x -> (f . g) x /= (g . (f :: Int -> Int) $ x)
02:00:37 <lambdabot>   Failed test no. 1. Test values follow.: {-3->0;-2->0;-1->0;0->0;1->0;2->0;3...
02:00:43 <dons> seems to be lots of them :-)
02:00:46 <dons> (hint: const)
02:03:06 <ivanm> nah, too much for what I want
02:11:41 <olsner> @unpl const . const
02:11:42 <lambdabot> (\ e _ _ -> e)
02:17:48 <skew> what's the impractical inverse algorithm?
02:17:51 <skew> levin search?
02:18:09 * matthew-_ guesses
02:19:35 <DRMacIver> Wild_Cat: Your equation doesn't type check. ;)
02:20:14 <DRMacIver> (Even setting aside trivial things like functions not being in Eq)
02:20:40 * Wild_Cat shoots DRMacIver 
02:23:52 <hpaste>  skew pasted "omg display hax" at http://hpaste.org/112
02:24:52 <DRMacIver> Wild_Cat: I get that a lot. :)
02:26:57 <ivanm> going through the cafe posts...
02:27:05 <ivanm> I don't get what "fix show" is meant to do... :s
02:27:28 <skew> try it
02:27:34 <ivanm> yeah, I did...
02:27:43 <skew> it's kind of like fix (1:)
02:27:47 <ivanm> and its a bunch of quotation marks + \
02:27:47 <DRMacIver> ivanm: Great evil. :)
02:27:51 <ivanm> ?
02:27:56 <DRMacIver> 11:25 < ivanm> I don't get what "fix show" is meant to do... :s
02:28:10 <opqdonut> nice :)
02:28:22 <skew> show can at least make a quote before examining the argument string
02:28:33 <ivanm> DRMacIver, I meant as in how is it great evil?
02:28:35 <skew> then because of fix it goes and escapes the quote, producing \"
02:28:40 <ivanm> ahhhh
02:28:43 <skew> then it quotes \, and quotes "
02:28:47 <skew> etc.
02:28:49 <ivanm> and then the slashes get escaped
02:28:52 <ivanm> I get it now...
02:29:06 <matthew-_> heh, fix id reaches the event horizon faster...
02:29:47 <opqdonut> why doesn't fix id return?
02:30:08 <matthew-_> err, work out the type
02:30:10 <opqdonut> or is the least fixed point something like id.id.id.id. ...
02:30:11 <ivanm> skew, so where does the initial input into fix show come from?
02:30:27 <quicksilver> ivanm: because it knows it is a string
02:30:37 <quicksilver> ivanm: so it can do the quote, before even examining the input
02:30:38 <ivanm> *nod*
02:30:42 <skew> from the output of fix show
02:30:44 <quicksilver> :t show
02:30:45 <opqdonut> laziness wins
02:30:47 <lambdabot> forall a. (Show a) => a -> String
02:30:47 <ivanm> so it starts with the initial quote?
02:30:48 <matthew-_> opqdonut: yep - it'll end up as id . id ...
02:30:49 <skew> or rather, from the output of show
02:30:58 <skew> fix :: (a -> a) -> a
02:31:01 <opqdonut> matthew-_: hmm, yrd
02:31:01 <quicksilver> fix id and fix show 'converge' at the same speed
02:31:08 <quicksilver> it's just that fix id doesn't produce anythign on the way
02:31:13 * ivanm tried the full "map length . List.group . Control.Monad.Fix.fix $ show" from the mailing list...
02:31:14 <quicksilver> whilst fix show produces some stuff
02:31:16 <skew> feeds the function it's own result, that is the result you get when you feed it that result as input
02:31:18 <quicksilver> so it looks prettier
02:31:18 <ivanm> lb didn't like it :(
02:31:54 <skew> fix show is terminating if you think of codata
02:32:14 <skew> like, pretend it's some kind of iterator
02:33:37 <ivanm> what is "map length . List.group . Control.Monad.Fix.fix $ show" meant to do?
02:34:22 <opqdonut> nice
02:34:25 <skew> apply map length . group to the output of fix show, it groups up and counts all those slashes
02:34:35 <opqdonut> it produces a list of alternating 1:s and 2^i-1:s
02:34:54 <quicksilver> skew: I don't think you can call it 'terminating'
02:34:58 <quicksilver> skew: 'productive' maybe
02:35:18 <skew> yeah, I think that's the term
02:35:33 <skew> well-founded or antifounded or something like that
02:35:46 <skew> perfectly well behaved at any rate, not just undefined like fix id
02:39:29 <hpaste>  skew annotated "omg display hax" with "type signature fix" at http://hpaste.org/112#a1
02:41:09 <ivanm> opqdonut, ahhh.....
02:42:26 <ivanm> I might have to do a talk on my haskell project in windows if linux my laptop has a hissy fit with the projector
02:42:50 <ivanm> so I was thinking of rather than using a command line to demo my program, I'd use a gui for ghci if there was one
02:42:52 <ivanm> is there?
02:43:40 <matthew-_> I've had no problems recently with my laptop and projectors. And I only have linux on it
02:43:55 <matthew-_> I've also given lectures from that laptop entirely in emacs and ghci
02:46:51 <Mitar> i am new to monads ... but i am writing some IO actions where I would like to open a handle and then use it in all other actions ... but I do not like that i need to pass it all the time to all those actions ... how can i store the handle so that i can get it without passing it as an argument?
02:47:54 <ivanm> matthew-_, well, I'm hoping it will work, but just in case...
02:48:02 <TSC> Mitar: Reader monad, perhaps
02:48:41 <matthew-_> Mitar: some combination of Reader and IO I would guess
02:49:10 <quicksilver> ReaderT IO
02:49:19 <quicksilver> but that introduces its own overhead
02:49:29 <quicksilver> since you have to lift all your IO actions...
02:49:37 <quicksilver> (syntactic overhead, I mean)
02:50:15 <Mitar> hmm, what about state monad?
02:50:28 <quicksilver> you certainly could use that
02:50:36 <matthew-_> state would work - it's just a more "generic" version of Reader
02:50:42 <quicksilver> the reader monad is essentially a read-only state monad
02:50:46 <matthew-_> as state allows reading and writing
02:50:55 * matthew-_ leaves it to quicksilver ;)
02:51:32 <kfish> Mitar, section 4 of http://haskell.org/haskellwiki/Roll_your_own_IRC_bot explains it well
02:51:33 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
02:51:55 <kfish> ie. passing an IO handle around
02:54:55 <Mitar> but i will need to lift all io operations now?
02:55:30 <Bourbaki> moin
02:55:50 <Bourbaki> quick question how fast is haskell with respect to math functions that make use of recursion?
02:56:45 <dons> Bourbaki: compile native code speed?
02:56:56 <ivanm> that would be a highly implementation/requirement specific question, would it not>
02:56:58 <dons> recursion is a goto, math ops compile to C ops.
02:56:59 <ivanm> *?
02:57:44 <Bourbaki> hm ok
02:57:57 <Bourbaki> so stuff like unrolling loops and the like is not feasable in haskell?
02:58:10 <Bourbaki> or is not supported by the compiler in any way?
02:59:24 <dons> Bourbaki: you could do it , if you wanted to.
02:59:47 <Bourbaki> id like to write something that would include something like this
02:59:49 <dons> Bourbaki: you can write low level recursive stuff, and know pretty much exactly the C it wil produce, if needed.
03:00:02 <Bourbaki> S(x,y) = Sum_i^j g(x,y)
03:00:20 <Bourbaki> ok but i want to prevent any kind of loop
03:00:28 <Bourbaki> prevent using
03:00:32 <dons> why?
03:00:34 <quicksilver> dons: am I not right in thinking that the via-C compiler will unroll loops?
03:00:43 <quicksilver> dons: if the appropriate GCC flag unrolls them?
03:00:46 <dons> it will try, yes. if we generated loops.
03:00:58 <Bourbaki> hm maybe i need to write a code generator then ...
03:01:28 <quicksilver> Bourbaki: you may be able to do what you want with GHC
03:01:36 <quicksilver> Bourbaki: it permits you to write your own optimisation rules
03:01:39 <quicksilver> Bourbaki: (rewrite rules)
03:01:45 <Bourbaki> i see
03:01:56 <Bourbaki> the idea is to tailor the function in place
03:02:23 <Bourbaki> that is the S is a surface function and i want it to be as fast as possible so in c++ id use _force inline and allign all the function calls
03:02:27 <quicksilver> the speed gain for loop unrolling is pretty low on modern CPUs though
03:02:29 <Bourbaki> such that its not written in a loop
03:02:38 <quicksilver> given pipelining and branch prediction
03:03:02 <Bourbaki> well i was on a conf where they showed that for matrices its sufficiently speeding up to not use loops for it
03:03:08 <quicksilver> most applications have easier targets/fatter bottlenecks
03:03:30 <quicksilver> you could simply write the non-looped matrix code
03:03:30 <Bourbaki> and since this function will be called every frame a hell of a lot of times small speed gain will be still a good thing
03:03:42 <quicksilver> Bourbaki: a small speed gain is irrelevant if it isn't the bottleneck :)
03:03:46 <Bourbaki> yep i know :) just wanted to say id like to do the same thingy for the function
03:03:52 <Bourbaki> it is a bottle neck
03:04:14 <norpan> what is a thingy and how does it relate to a thing
03:04:17 <Bourbaki> when i rewrote the function just slightly i was able to make it a lot faster
03:04:23 <Bourbaki> sec
03:04:32 <dons> kosmikus: pong?
03:04:44 <Bourbaki> http://video.google.de/videoplay?docid=-979203120692178262&q=fluid+solver
03:04:46 <lambdabot> Title: Real Time Fluid Solver 3 - Google Video, http://tinyurl.com/288ohh
03:04:48 <Bourbaki> thats the stuff i am doing
03:05:10 <Bourbaki> so for everey particle an each point in the surface i have to call the S function
03:05:33 <Bourbaki> and the thingy is just using no loops for that kind of function
03:05:40 <quicksilver> the fact that *S* is called for every point doesn't make *loop unrolling* the bottleneck
03:05:59 <quicksilver> loop unrolling might turn out completely insignificant compared to FPU register contention
03:06:04 <quicksilver> or cache misses
03:06:09 <quicksilver> or any of a number of things I don't know much about
03:06:18 <Bourbaki> ok so how do i care about these things then?
03:06:28 <quicksilver> you write some code, you benchmark it
03:06:36 <quicksilver> you investigate ways of changing it and see if they help
03:06:42 <quicksilver> you ask dons here for cool compiler flags
03:06:58 <quicksilver> you inspected the Core code that GHC produces and see if it looks sance
03:07:07 <quicksilver> you inspect the C code that GHC produces and see if that looks sane
03:07:09 <Bourbaki> well the thing is that when i changed the core function underlying S i was able to gain a lot of speed
03:07:25 <Bourbaki> and im quite sure that there is a lot more space for speed gain
03:08:47 <Bourbaki> so in either way haskell will allow me to speed up that kind of problems?
03:08:56 <Bourbaki> in a generic way that is
03:09:03 <quicksilver> haskell is a pretty good tool for these things
03:09:13 <Bourbaki> ok thats cool
03:09:14 <quicksilver> having said that, it's not as good as C for precise control of the assembly produced
03:09:26 <quicksilver> but, it is capable of high level abstrctions which still compile to very small code
03:09:41 <olsner> is there a utility to transform .hs with lots of comments into literate haskell?
03:09:49 <Bourbaki> ok so if id like to get most of the speed out of it the core should be written in c then wrapped in haskell and then bound to c++ :)
03:10:10 <dons> Bourbaki: if you have very tight inner math loops, writing those in C and calling them from the FFI can be very profitable
03:10:27 <dons> Bourbaki: you can even generate the C specialised at runtime to particualr values, compile that, link it, and call the result.
03:10:30 <dons> that can be *really* fast
03:10:34 <gidyn> Olsner: a couple of regex replaces in any scripting language should do it
03:10:55 <quicksilver> or there is that neat 'x86 assembly DSL' someone wrote recently
03:10:56 <Bourbaki> the problem is that i cant deliver haskell with the program i think
03:11:08 <Bourbaki> isnt there a lightweight haskell compiler as of now?
03:11:09 <quicksilver> which lets you generate x86 assembly programmatically at run time
03:11:11 <quicksilver> and then call it
03:11:22 <olsner> gidyn: indeed, just wondered if someone had already done it ;-)
03:11:49 <Bourbaki> dons : did you btw find the time to have a look at that greap idea?
03:11:54 <Svrog> quicksilver: harpy?
03:11:59 <Bourbaki> cause thats the stuff id like to couple it to in the end
03:12:43 <Svrog> http://uebb.cs.tu-berlin.de/harpy/
03:14:43 <gidyn> Are there any plans for a new record system in GHC? Haskell' doesn't seem to be getting anywhere with this.
03:16:53 <dons> @seen apfelmus
03:16:53 <lambdabot> I haven't seen apfelmus.
03:18:29 <dons> Igloo: ping
03:18:37 <dons> Bourbaki: sorry, no.
03:22:20 <olsner> hmm... when "substituting x for y", am I "replacing y with x" and "changing y to x", or the other way around?
03:22:54 <olsner> why can't people decide in which order they take their arguments?
03:23:35 <olsner> and which one is it that is "being substituted"?
03:24:30 <Mitar> in http://haskell.org/haskellwiki/Roll_your_own_IRC_bot .. what type is disconnect function?
03:24:31 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
03:24:45 <quicksilver> Svrog: yes, that's the one
03:25:14 <kfish> ?type bracket
03:25:20 <lambdabot> Not in scope: `bracket'
03:25:27 <quicksilver> olsner: 'substituting x for y' is removing ys and replacing them with xes
03:25:42 <kfish> ?type Control.Exception.bracket
03:25:44 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
03:27:15 <dons> xmonad new release candidate, http://article.gmane.org/gmane.comp.lang.haskell.xmonad/303, and guided tour with screenshots : http://xmonad.org/tour.html
03:27:18 <lambdabot> Title: Gmane -- Mail To News And Back Again
03:27:24 <dons> testing would be appreciated :-)
03:28:31 <olsner> quicksilver: yeah, so is it the x's or the y's that are being substituted?
03:29:07 <olsner> it feels like replace = flip substitute
03:30:08 <ari> dons: How many LOC? ;)
03:30:27 <dolio> If 'xs are being substituted for ys' then ys are being replaced with xs.
03:30:56 <dons> 516 loc :-)
03:31:01 <dons> OH NOES!
03:31:11 <olsner> @pl xmonad
03:31:12 <lambdabot> xmonad
03:31:17 <dolio> :) You can't shave off 17 lines?
03:31:23 <xian> hi.
03:31:38 <dons> we could, yeah. hehe. but we're scared of introducing bugs before the release
03:32:15 <xian> how can a "return <value>" be interpreted in no particular monad context (eg after firing up ghci)?  what kind of object is that we get? it doesn't look very monadic at all.
03:32:51 <dons> xian: you're in the IO monad there, with some modified semantics, roughly.
03:33:29 <xian> ok
03:33:41 <Igel> hi all
03:33:59 <Igel> is there a way to find out the day of week?
03:34:01 <dons> ari: here's how the code base has grown, http://www.cse.unsw.edu.au/~dons/tmp/xmonad-loc.png
03:34:05 <olsner> it would be nice to have a refactoring helper that checks to see if the new version is equivalent.. limiting to changes that are just about moving stuff between functions, introducing/inlining abstraction, it should be feasible to make something that says something useful
03:34:15 <Igel> i was browsing the time module but i didn't find a way
03:34:21 <dons> Igloo: yeah, in System.Time, iirc
03:34:25 <dons> Igel.^^
03:35:19 <Igel> a thanks dons :)
03:35:23 <dons> Igel, here''s code I used to find the date of the next Tuesday:
03:35:25 <dons> findTuesday :: CalendarTime -> IO String
03:35:25 <dons> findTuesday time@(CalendarTime _ _ _ _ _ _ _ Tuesday _ _ _ _ )
03:35:25 <dons>     = return $ clean $ formatCalendarTime defaultTimeLocale fORMAT time
03:35:25 <dons> findTuesday time
03:35:27 <dons>     = let (TOD secs ps) = toClockTime time
03:35:30 <dons>       in do time' <- toCalendarTime (TOD (secs + 60*60*24) ps)
03:35:32 <dons>             findTuesday time'
03:35:46 <Igel> thanks
03:35:48 <dons> so, toClockTime, toCalendarTime
03:35:55 <Igel> i was looking for that in Data.Time
03:36:02 <Igel> which we used in our project
03:36:13 <Igel> i didn't know, there also was system.time
03:36:18 <Igel> thanks^^
03:36:20 <dons> yeah, System.Time.
03:36:45 <LeCamarade> @quote java's
03:36:46 <lambdabot> dons says: Java's type system is unsuitable for young children, the elderly or infirm of constitution
03:36:54 <LeCamarade> dons: What were you up to? ^^
03:37:00 <LeCamarade> :oD
03:37:19 <LeCamarade> I'm trying to get it on a T-shirt. And give it to boss.
03:40:21 <dons> heh
03:41:20 <mdmkolbe|work> When I was working with GHCi discovered that patterns on the left of let bindings are irrefutable.  Is there a way to make them non-irrefutable?
03:41:22 <mdmkolbe|work> > let Just x = Nothing in 1
03:41:23 <lambdabot>  1
03:41:40 <mdmkolbe|work> s/discovered/I discovered/
03:42:36 <LeCamarade> mdmkolbe|work: Hmm ... hadn't no'ced.
03:42:56 <Saizan> mdmkolbe|work: use the x :)
03:42:58 <dons> indeed thre is:
03:43:00 <dons> Prelude> let !(Just x) = Nothing in 1
03:43:00 <dons> *** Exception: <interactive>:1:4-22: Non-exhaustive patterns in pattern binding
03:43:00 <dons> Prelude> let (Just x) = Nothing in 1
03:43:00 <dons> 1
03:43:15 <mdmkolbe|work> thx dons that's exactly what I wanted
03:43:23 <dons> -fbang-patterns required
03:43:24 <mdmkolbe|work> Saizan: I couldn't use the x b/c it might be bottom
03:44:02 <dons> you could use 'case'. ?
03:44:22 <dons> it seems a bit suspicious, i must say
03:44:35 <dolio> Or if you're in a monad 'Just x <- return Nothing'
03:44:47 <dolio> That will fail in the monad.
03:45:01 <dons> ah that's nicer.
03:45:16 <mdmkolbe|work> dons: yes, but I was a lazy typest on the GHCi command line.  I was testing some data structures (that can't 'show') and was supprized when a 'let Just x = foo' line worked
03:45:59 <mdmkolbe|work> > (do Just x <- return Nothing; return 1)::Maybe Int
03:46:01 <lambdabot>  Nothing
03:46:54 <Igloo> dons: pong
03:47:16 <dons> Igloo: see mail re. X11 1.2.1 having been tagged at last ghc release, but not uploaded to hackage.
03:47:22 <Igloo> dons: The tagged X11 repo doesn't actually build with 6.6.1's Cabal, which is why I didn't put it into Hackage
03:47:24 <dons> do we have a policy, should it happen?
03:47:28 <dons> ah hmm.
03:47:47 <dons> we need 1.2.1 though, for 64 bit guys. what's the issue?
03:48:16 <Igloo> I'd suggest doing a 1.2.2 release and putting that in Hackage then (I think X11 is fixed now)
03:48:40 <dons> ah ok. so tag the current darcs version an upload that?
03:48:43 <dons> who's the maintainer?
03:49:04 <Igloo> libraries@haskell.org  :-)
03:49:10 <dons> (this is the other issue, we're key users, but a bit scared of treading on toes -- maybe we should give it to sjanssen to have ?)
03:49:25 <dons> then X11-extras could be merged in, too.
03:50:02 <dons> ok. what's the best way to get 1.2.2 tagged and uploaded?
03:55:17 <narain> hi all
03:55:49 <narain> what's a good way to represent a graph in haskell?
03:56:19 <narain> i thought using a circular data structure would be perfect but i couldn't fmap over it
03:56:28 <dons> using FGL ? :-)
03:56:40 <dons> or one of the other graph libraaries (actually , there's some good papers on this)
03:56:45 <quicksilver> narain: circular data structures are a poor way to model circular data
03:56:55 <quicksilver> narain: circular data structures are a good way to model *infinite* data
03:57:00 <quicksilver> narain: but that's not quite the same :)
03:57:06 <narain> quicksilver: hmm, i didn't know that
03:57:13 <quicksilver> haskell can't detect the circularity at the language level
03:57:25 <phoniq> adjacency list, adjacency matrix
03:57:55 <Mitar> i would like to match an list to fixed list ...
03:58:05 <dons> Igloo: i'm blocked. do we just tag X11 ourselves, and assume maintainership, or do we ask Mr. GHC-guy to do the tag?
03:58:06 <quicksilver> narain: there is no way to observe the difference, in haskell, between cycle [1,1,1,1] and cycle [1]
03:58:10 <narain> phoniq: right, i'd like to use an adjacency list, but... numeric vertex id would be kinda ugly
03:58:18 <narain> ^ids
03:58:25 <Mitar> is there anythin nicer than case foo of 0x00:0x01:0x02:[] -> ...
03:58:36 <quicksilver> narain: you write a nice bunch of combinators which hide the ugly IDs beneath the surface
03:58:48 <Igloo> dons: Doing it yourselves is fine
03:59:13 <narain> quicksilver: ...and it would be doing (!!) all over the place under the surface?
03:59:49 <quicksilver> narain: possibly. Or possibly it would use a faster data structure than lists.
03:59:59 <dons> Igloo: ok, i'll be tagging it, pushing the tag, and uploading to hackage tomorrow then.
04:00:09 * yaxu has a haskell day today
04:00:12 <yaxu> all haskell all day
04:00:20 <Igloo> dons: Don't forget to bump the version number first  :-)
04:00:32 <yaxu> i don't have enough of these...
04:00:36 <narain> i was hoping there would be something quick and neat i could do easily :/
04:01:18 <dons> Igloo: right
04:01:50 <narain> i made a circular data structure and i was all "lazy evaluation is so awesome" and then i show'ed it and... :(
04:02:11 <Saizan> you ran out of bits?
04:02:51 <narain> i did graph = [a,b,c] where a = Vertex [Edge b], b = Vertex [Edge a, Edge c], c = Vertex [Edge a] and thought it was perfect
04:02:55 <narain> but clearly i was wrong
04:03:17 <narain> doesn't it *look* so neat and elegant though? :)
04:03:32 * narain goes off to look at functional graph libraries
04:03:54 <edwardk> narain: show myinfinitedatastructure = show' myinfinitedatastructure 5 where show' _ 0 = "..."; show' x _ = ... your old show
04:04:39 <narain> edwardk: thanks, but show is just one symptom of the deeper problem
04:04:46 <edwardk> fair enough
04:04:48 <quicksilver> narain: you certainly can do some cool stuff with circularity
04:05:21 <narain> "...but this isn't one of them," are you're going to say?
04:05:44 <Saizan> you need some way to know when you are in a cycle.. naming the nodes maybe?
04:05:48 <quicksilver> well you just need to remember that you can't tell the difference between circularity and infinity
04:05:57 <quicksilver> you could name the nodes, for example
04:06:20 <narain> quicksilver: aye, there's the rub...
04:06:26 <phoniq> you might find boost.graph interesting
04:06:31 <narain> guess i will have to name them or something
04:06:38 <phoniq> it separates all these concerns
04:07:28 <mdmkolbe|work> narain: if you just want a graph library 'fgl' has a nice way to avoid cycles in the first place.  (Of course so do adjacency matrixes)
04:07:53 <mdmkolbe|work> narain: but 'fgl' doesn't nessisarily solve the cycle problem in general
04:08:01 <Saizan> fgl?
04:08:10 <mdmkolbe|work> @where fgl
04:08:10 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
04:08:34 <narain> i don't need to solve the cycle problem
04:08:46 <narain> i just need to represent a bunch of interconnected nodes
04:08:52 <narain> i'm looking at fgl now
04:10:19 <mdmkolbe|work> narain: fgl is trying to take a functional approch to graphs (which is quite cool).  but if you're just interested in a pragmatic solution, more traditional solutions (e.g. adjecancy graphs, etc) might be better depending on your situation
04:11:42 <Saizan> ?docs Data.Graph
04:11:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
04:11:52 <narain> mdmkolbe|work: thanks. my code is also a means of haskell exploration so fgl is interesting
04:12:01 <dons> Igloo: sent you a bump patch. i'm off for dinner. if you'd apply it and hmm, tag + upload, I'll owe you a beer :)
04:12:23 <dons> (though need to be sure the ./configure script ends up in the dist ball)
04:12:35 <narain> Saizan: hey, nice
04:13:01 <sitaram> hello everyone... I am a rank beginner in Haskell, and I am unable to understand the difference between "show" and "shows", and between "read" and "reads" in a practical way.  The haskell wiki didnt have anything that seemed to explain this -- perhaps I am being extremely dumb but if someone could point me to some URL, I'd be grateful!
04:13:17 <mdmkolbe|work> @type show
04:13:19 <lambdabot> forall a. (Show a) => a -> String
04:13:20 <mdmkolbe|work> @type shows
04:13:21 <lambdabot> forall a. (Show a) => a -> String -> String
04:13:49 <narain> > shows 42 "hello" -- so what does it *do*?
04:13:50 <mdmkolbe|work> sitaram: shows uses an accumulator as an optimization
04:13:50 <lambdabot>  "42hello"
04:13:51 <Saizan> sitaram: shows just use a nice "trick" to permit fast string concatenation
04:14:19 <MyCatVerbs> sitaram: read converts a string into some other type, reads converts a string into some other type plus whatever tokens weren't parsed as being of the same type as the reads function was after.
04:14:27 <sitaram> how does this trick work? by not actually doing the concat till eventually needed?  or something deeper?
04:14:33 <Saizan> > shows 43 . shows 100 $ "  last string"
04:14:34 <lambdabot>  "43100  last string"
04:14:35 <quicksilver> sitaram: roughly, yes
04:14:40 <mdmkolbe|work> > shows 1 . shows 2 . shows 4 ""
04:14:41 <lambdabot>  Couldn't match expected type `a -> String'
04:14:50 <mdmkolbe|work> > shows 1 . shows 2 . shows 4 $ ""
04:14:51 <lambdabot>  "124"
04:15:18 <ketil> About parsing, I'm currently trying to implement a relatively simple parser based on Parsec, but I wonder what other options are available.
04:15:21 <narain> :t reads
04:15:23 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:15:29 <sitaram> > shows 43 . shows 100  "  last string"
04:15:29 <lambdabot>  Couldn't match expected type `a -> String'
04:15:55 <sitaram> > shows 43 (shows 100  "  last string")
04:15:56 <lambdabot>  "43100  last string"
04:16:34 <mdmkolbe|work> doing 'show 1 ++ show 2 ++ show 4' would require a lot of linear time concats (++), but by passing in what should be concated to the end in the first place we can avoid actually having to do the concats
04:16:52 <filcab42> hi all
04:17:13 <quicksilver> mdmkolbe|work: although, actually, show 1 ++ show 2 ++ show 4 is fine, because ++ is right-binding
04:17:19 <narain> Saizan: it seems Data.Graph doesn't let you attach any data to the nodes or edges?
04:17:33 <quicksilver> mdmkolbe|work: the problem is when you build up complex expressions which have left-binding
04:17:40 <quicksilver> mdmkolbe|work: so the ++'s get done 'the wrong way'
04:17:59 <sitaram> mdmkolbe|work: so thats like passing in a ref, if you'll pardon the C-ish analogy?
04:18:02 <mdmkolbe|work> ketil: there are 'happy' for parsing and 'alex' for lexing if you like flex/yacc style.  (Personally I like parser combinators better)
04:18:17 <Saizan> narain: ehm, never used it :)
04:18:30 <narain> Saizan: ah, ok :)
04:19:35 <sitaram> last question: why does shows require that last string, which is often empty.  Is it like the "id" value you use in a foldr, sort of like a "seed"?
04:20:02 <dmwit> :t shows
04:20:04 <lambdabot> forall a. (Show a) => a -> String -> String
04:20:10 <Saizan> narain: graphFromEdges :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex) , so you should be able to have anything in "node"
04:20:27 <narain> oh, huh
04:20:32 <dmwit> shows actually creates a "concatenation" function, so you need to give it something to concatenate to.
04:20:46 <dmwit> The reason that might be useful is so you could do something like this:
04:21:13 <ketil> mdmkolbe|work: my problem is that I want to parse a format that isn't very rigid.
04:21:34 <dmwit> > shows 355 . shows (Maybe "heyo!") . shows [8, 9, 10] $ ""
04:21:34 <lambdabot>   Not in scope: data constructor `Maybe'
04:21:40 <dmwit> > shows 355 . shows (Just "heyo!") . shows [8, 9, 10] $ ""
04:21:41 <lambdabot>  "355Just \"heyo!\"[8,9,10]"
04:22:10 <mdmkolbe|work> sitaram: think of it this way.  Suppose I want to write a show for a data structure that has a hole bunch of single characters.  I could do: instance Show MyData where show (Data a b c d e) = show a ++ show b ++ show c ++ show d, but that would make lots of intermediate strings that are just thown away.  But shows for a character would be implemented something like 'shows c str = c:str' so instead I could do: instance Show MyData
04:22:19 <mdmkolbe|work> I hope that didn't cut off
04:22:19 <ketil> more like a set of hierarchical records, so while there are delimiters I can use, I would like something that is robust against small variations.
04:22:31 <ketil> Perhaps regexps is what I really need?
04:22:41 <sitaram> mdmkolbe|work: it didnt cut off
04:23:16 <mdmkolbe|work> ketil: so you want a fuzzy parser?
04:23:20 <sitaram> mdmkolbe|work: sorry I think it did cut off now that I read the whole thing
04:23:35 <mdmkolbe|work> sitaram: what was the last part that got through
04:23:40 <sitaram> dmwit: why cant your last example be:
04:23:54 <sitaram>  > shows 355 . shows (Just "heyo!") . show [8, 9, 10]
04:24:08 <ketil> mdmkolbe|work: yes.  Maybe :-)
04:24:20 <dmwit> sitaram: Parse error. ;-)
04:24:32 <dmwit> sitaram: But you're right, if you change the last (.) to a ($).
04:24:35 <ketil> mdmkolbe|work: or something that can be (easily?) extended to account for variations.
04:24:57 <ketil> Which regexp library should one use?  HackageDB lists about ten of them.
04:25:00 <sitaram> > shows 355 . shows (Just "heyo!") $ show [8, 9, 10]
04:25:01 <dmwit> mdmkolbe|work: That last part that made it was "I could do: instance Show MyDat"
04:25:01 <lambdabot>  "355Just \"heyo!\"[8,9,10]"
04:25:35 <sitaram> dmwit: yes I noticed that later...
04:26:15 <mdmkolbe|work> ketil: if the language is actually well defined including the variations being well defined (abet complex), then parsec or happy are probably what you want if you need full context free parsing.  (Use regex if you can easily b/c that is a simpler language.) If they are not well defined, then you've moved into the relm of natural language parsing.
04:26:58 <mdmkolbe|work> <resending>...so instead I could do: instance Show MyData where show (Data a b c d) = shows a (shows b (shows c (shows d ""))), that way I'm just building up the result and not building up parts that get torn down by the (++).
04:28:52 <sitaram> mdmkolbe|work: That's a nice explanation, and I think I get it now!
04:29:05 <mdmkolbe|work> sitaram: thx
04:29:17 <quicksilver> I disagree with mdmkolbe|work, I would never use a regex library in preference to a simple parsing library
04:29:24 <quicksilver> regexes are ugly and fragile
04:29:33 <quicksilver> good combinators are clean and scalable
04:29:56 <mdmkolbe|work> quicksilver: parsers are a super-set of regexes
04:30:12 <int-e> instance Show (MyData) where showsPrec _ (Data a b c d) = shows a . shows b . shows c . shows d  would be better
04:30:19 <ketil> mdmkolbe|work and quicksilver: Okay.  Is there a "noneOf"-like parser that targets a list of String instead of Char?
04:30:19 <quicksilver> mdmkolbe|work: not syntactically, they're not :)
04:30:27 <sitaram> mdmkolbe|work, dmwit , Saizan , MyCatVerbs : thanks for all the help!  I just wasn't getting it all by myself and this helped a lot
04:30:44 <matthew-_> I think the best difference is the readability - it's a lot easier to read a parser written with parsec than one written with regexps
04:31:00 <quicksilver> read, and debug, and change
04:31:01 <mdmkolbe|work> quicksilver: mathematiclaly speaking they are.  if syntax is a problem then someone needs to write a better regex library
04:31:42 <quicksilver> mdmkolbe|work: 'regex' in command parlance refers to a specific syntax
04:31:50 <matthew-_> well underneath, I would guess they're all DFAs. But, from an engineering pov, that's irrelevant - maintainability rules there.
04:31:58 <quicksilver>  /^(stuff) [like] (this|or|so)$/
04:31:59 <mdmkolbe|work> int-e: agreed, I only used 'show' to make the explanation clearer
04:32:00 <olsner> doesn't Num t imply Ord t?
04:32:10 <quicksilver> mdmkolbe|work: it is that syntax that I am deprecating
04:32:13 <ketil> Perhaps I should take one more step into Parsec, and do real lexing/tokenizing?
04:32:14 <sitaram> matthew-_: I believe most modern regex engines are NFAs
04:32:23 <sitaram> at least the ones with backtracking
04:32:26 <narain> ?instances-importing Ord
04:32:27 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
04:32:35 <narain> olsner: Complex isn't Ord
04:32:58 <narain> nor should it be :)
04:33:04 <quicksilver> Float shouldn't be Eq
04:33:06 <quicksilver> but it is :(
04:33:06 <matthew-_> sitaram: ahh ok. Been a while since I looked at that stuff. Yes, I would think that backtracking with a DFA would be limiting ;-)
04:33:07 <DRMacIver> matthew-_: Err. Parsec stuff isn't going to be a DFA.
04:33:28 <olsner> okay.. nm, not much work to add Ord t, just surprising
04:33:30 <narain> quicksilver: i agree!
04:34:02 <mdmkolbe|work> sitaram: no, there DFA's b/c DFAs can implement NFAs without needing backtracking (but neither are strong enough to implement parsers)
04:34:09 <matthew-_> DRMacIver: oh? I thought you could convert an NFA to a DFA?
04:34:11 <mdmkolbe|work> s/there/they're/
04:34:25 * matthew-_ finds parts of his undergrad degree coming back to him...
04:34:34 <narain> mattew-: context-free languages /= regular languages
04:34:59 <narain> matthew-: DFA == regular language, context-free language == push-down automata
04:35:16 <mdmkolbe|work> there's a nice little table for all these at the very end of http://en.wikipedia.org/wiki/Context-free_grammar
04:35:17 <lambdabot> Title: Context-free grammar - Wikipedia, the free encyclopedia
04:35:18 <narain> (eh, messed up the singular/plural)
04:35:26 <matthew-_> ok.
04:35:32 <Mitar> how can i defined my own io exceptions?
04:35:50 <ketil> The TokenParser stuff seems awfully geared towards programming languages...
04:36:05 <narain> mdmkolbe|work: that's a nice table
04:36:07 <ibid> matthew-_: DFA and NFA are equivalent in function, their difference is in space & time behavior
04:36:39 <narain> NFA's are purely theoretical constructs, right? to implement one you have to convert it to a DFA?
04:36:52 <ibid> narain: no
04:37:00 <mdmkolbe|work> narain: you could implement an NFA with backtracking or just parallel simulation
04:37:53 <narain> hmm, right, hadn't thought about backtracking. running in parallel is exactly the ->DFA conversion though
04:38:19 <ibid> narain: no it's not. it's similar though
04:38:24 <mdmkolbe|work> narain: *and* without any combinatorial explosion just be sure to recognize when to paths fuse back to gether
04:38:28 <ibid> narain: in terms of implementation at least
04:39:04 <narain> ibid: what's the difference?
04:39:20 <mdmkolbe|work> narain, ibid: the "mask" indicating which states are active in an NFA would match the names of the states created by the NFA -> DFA transformation
04:41:02 <narain> yes, that is what i meant. so what's the difference with parallel simulation?
04:41:17 <ibid> narain: you can implement a DFA using gotos with no data structures except the input, but to do parallel simulation of NFAs you need a dynamic set data structure
04:41:25 <DRMacIver> I don't think parsec actually builds push down automata does it?
04:41:39 <ibid> narain: (talking about imperative-style implementation that is)=
04:41:43 <mdmkolbe|work> narain: that's what I ment by parallel simulation
04:41:49 <mdmkolbe|work> DRMacIver: it does implicitly
04:41:54 <DRMacIver> ok
04:42:08 <DRMacIver> In what sense of 'implicitly'? :)
04:42:13 <EvilTerran> any recursive parser would do so implicitly
04:42:26 <narain> ibid: well, i was talking theoretically
04:42:30 <EvilTerran> 'cos you've got the interpreter's stack acting as the automaton's stack
04:42:32 <mdmkolbe|work> DRMacIver: the stack is the actual program's stack and the state is what function is active
04:42:39 <DRMacIver> Ah
04:42:48 <ibid> narain: you could consider the NFA->DFA translation as a "compilation" of NFA parallel simulation
04:42:59 <ibid> narain: i wasn't: 14:36  <ibid> narain: in terms of implementation at least
04:43:00 <narain> yes
04:43:00 <ibid> :)
04:43:05 <mdmkolbe|work> ibid: agreed
04:43:05 <narain> :)
04:43:27 <sitaram> ibid: DFA and NFA are eqvt only if you don't use back-references.  I have to look this up but I seem to recall that an DFA cant do back-references (where one part of a match is used-by-reference in a later part of the match)
04:43:57 <dmwit> Neither can an NFA.
04:44:00 <mdmkolbe|work> sitaram: pure DFA's / NFA's can't to either
04:44:05 <dmwit> That's the realm of Turing machines.
04:44:31 <mdmkolbe|work> dmwit: yes, but not sessisarly Turing complete machines
04:44:52 <mdmkolbe|work> dmwit: e.g. a linear bounded TM could do some of that
04:45:02 <ibid> sitaram: DFA and NFA are equivalent because each can simulate the other; what the one can do, the other can do too. neither can do back references
04:45:11 <dmwit> mdmkolbe|work: Hmmm, really?
04:45:26 <dmwit> I was under the impression that there were only three classes: DFA, PDA, TM.
04:45:39 <ibid> sitaram: the stuff people call "regular expressions" in practice are not actually regular expressions in theoretical parlance
04:45:49 <mdmkolbe|work> dmwit: even if a linear bounded time can't, then linear bounded space surely can.
04:45:54 <dmwit> mdmkolbe|work: Or, what is a "linear bounded" Turing machine?
04:46:12 <sitaram> ibid: yes, but a pure NFA can be made "corrputed" ;-) (make it nonregular) by adding support for backrefs.  I think you cant do that to a DFA
04:46:29 <ibid> sitaram: then it's no longer a NFA :)
04:46:43 <sitaram> ibid: agreed; that's what I meant by "nonregular"
04:46:50 <ibid> sitaram: it becomes something else. you can "corrupt" either by adding a stack, for example
04:46:53 <mdmkolbe|work> dmwit: a Turing machine that can only use a finite amount of space (or time depending on what you're doing (there very different)) that is a linear function of the length of the input tape
04:47:12 <dmwit> Ah, okay.
04:47:30 <mdmkolbe|work> dmwit: linear-bounded is what you need for context sensitive grammars
04:47:48 * EvilTerran was under the impression that NPDAs were a distinct computability class to DPDA
04:47:57 <dmwit> Yes, I could believe in the existence of a linearly-bounded back-reference algorithm.
04:48:11 <dmwit> EvilTerran: That's true.
04:48:12 <DRMacIver> EvilTerran: They are. Push down automata usually refers to the non-deterministic kind I think.
04:48:12 <mdmkolbe|work> dmwit: you can make lots and lots of catagories by just adding or removing crazy restrictions (but many of those just reduce back to one of the well known ones)
04:48:38 <mdmkolbe|work> EvilTerran: that depends on wheter P = NP
04:48:45 <EvilTerran> righto. that sounds plausible, DRMacIver
04:48:58 <ketil> On a related note: XML parsing: XML toolbox, HaXml, or HXML?
04:49:03 <EvilTerran> mdmkolbe|work, suddenly this looks to be a much deeper conversation than i anticipated :P
04:49:15 <narain> mdmkolbe|work: i don't think i does
04:49:32 * byorgey has a theory-gasm
04:50:12 <mdmkolbe|work> EvilTerran: err, sorry I miss-thought.  both NPDA and DPDA belong to P
04:50:19 <DRMacIver> EvilTerran: This is #haskell. Everything turns into a much deeper conversation than anticipated. We can turn conversations about the weather into deep discussions of the theoretical underpinnings of weather forecasting. ;)
04:50:42 <EvilTerran> okay. that makes more sense, mdmkolbe. DRMacIver, i know, that's why i hang out here
04:50:44 * narain tries to remember if there was a neat little proof about DPDA /= NPDA
04:50:45 <mdmkolbe|work> DPDA parsable languages is a strict subset of the NPDA languages
04:51:18 <EvilTerran> compare #perl, where a deep discussuin of the theoretical underpinnings of weather forecasting turns into vigorous debate re the ancestry of the other chatters.
04:52:23 <DRMacIver> Yeah, but Perl is known to cause brain damage, so that's hardly surprising. ;)
04:52:45 <DRMacIver> </troll>
04:52:45 * narain is relieved that googling for "deterministic pda" does not result in articles about the predictability of Palms and Blackberrys
04:52:47 <EvilTerran> oi, i use perl.
04:53:03 <EvilTerran> I just tend to stick to #perlmonks over #perl
04:53:06 <DRMacIver> EvilTerran: Don't worry. There are some remarkably good rehab programs these days.
04:53:17 <DRMacIver> (Most of them are written in Haskell)
04:53:33 <EvilTerran> i'm in one. it's called University-level CS
04:53:48 <mdmkolbe|work> narain: http://en.wikipedia.org/wiki/Deterministic_pushdown_automaton and http://en.wikipedia.org/wiki/Deterministic_context-free_language and http://en.wikipedia.org/wiki/Deterministic_context-free_grammar
04:53:49 <lambdabot> Title: Deterministic pushdown automaton - Wikipedia, the free encyclopedia
04:54:16 <EvilTerran> anyway, i spent most of my time doing funny things like implementing lambda calculus with anonymous functions
04:54:27 <EvilTerran> and translating NDPAs directly into perl regex
04:54:29 <EvilTerran> and so on
04:56:07 <EvilTerran> altho i will say this: i don't like perl in theory, but it's great for getting stuff done
04:56:26 <narain> mdmkolbe|work: [17:19] narain tries to remember if there was a neat little proof about DPDA /= NPDA
04:56:32 <narain> mdmkolbe|work: know any?
04:56:42 * EvilTerran wanders off to have lunch
04:56:42 <Saizan> narain: let w = (a*b*)+ in w(reverse w) is  NPDA but not DPDA ( wc(reverse w) would be DPDA, the central element helps a lot)
04:58:51 <narain> Saizan: aha, clever
05:00:18 <Saizan> i should have written w = (a|b)+ , simpler syntax :)
05:01:21 <narain> yeah, i missed the + outside the first time and thought you could just count an even number of b's
05:01:27 <yaxu> are the Data.Maybe and Maybe packages the same?
05:01:30 <narain> thankfully then i read it again
05:04:09 <quicksilver> yaxu: Maybe is the old version
05:07:00 <mdmkolbe|work> narain: (back from lunch) not off the top of my head
05:07:32 <narain> mdmkolbe|work: Saizan gave a nice one
05:08:34 <mdmkolbe|work> narain: ah, yes
05:08:36 <yaxu> quicksilver: aha, thanks
05:08:56 <LeCamarade> <Maybe Naive>Can I restrict what goes into a Char during creation of a constructor that has Char on the right? Maybe^H^H^H^H^H Just to say `the Char can only be one of these two'?</Maybe Naive>
05:10:33 <narain> LeCamarade: i don't know of any way other than a helper function
05:10:56 <Saizan> LeCamarade: only by not exporting the constructor and providing a function that check those condition when it builds your type
05:11:28 <LeCamarade> Aye.
05:11:30 <mdmkolbe|work> LeCamarade: but in that case why not just 'data MyChar = CharA | CharB'
05:11:36 <quicksilver> LeCamarade: yes, by providing your own constructor and hiding the built in one
05:11:47 <quicksilver> LeCamarade: this is a very common p attern
05:12:05 <Saizan> but the check will happen at runtime
05:12:44 <Saizan> (modulo TH)
05:13:31 <LeCamarade> quicksilver: Yeah, that's what I use, but I was wondering if it had be syntacised, seeing as syntax is for eliminating patterns. :o)
05:20:00 <Mitar> how can i define my own custom exceptions?
05:22:56 <mdmkolbe|work> Mitar: exceptions in Haskell are done with Monads, so it depends on what kind of exception you're wanting to throw (i.e. whether it is constrained to being part of IO code or any general monadic code)
05:22:58 <mdmkolbe|work> @type throw
05:23:07 <mdmkolbe|work> @src Error
05:23:08 <Mitar> part of io ...
05:23:12 <lambdabot> Not in scope: `throw'
05:23:12 <lambdabot> class Error a where
05:23:12 <lambdabot>     noMsg  :: a
05:23:12 <lambdabot>     strMsg :: String -> a
05:23:24 <Mitar> similar to that: http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
05:23:25 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
05:24:35 <mdmkolbe|work> @type throwIO
05:24:37 <lambdabot> Not in scope: `throwIO'
05:24:46 <mdmkolbe|work> @index throwIO
05:24:46 <lambdabot> Control.Exception
05:24:58 <mdmkolbe|work> @doc Control.Exception
05:24:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
05:25:40 <narain> nice, it looks like FGL has a clone living in Data.Graph.Inductive :)
05:25:41 <sioraiocht> okay, what are existential types?
05:25:49 <quicksilver> To define your own exceptions you need to use Dynamic and DynException, I believe
05:26:10 <mdmkolbe|work> sioraiocht: first, do you know what universal types are?
05:26:32 <sioraiocht> no, though I have a feeling we're talking something related to first order logic, now...lol
05:27:06 <mdmkolbe|work> sioraiocht: do you understand what 'forall a b. (a, b)' means?
05:27:12 <sioraiocht> yes
05:27:42 <mdmkolbe|work> sioraiocht: try to explain that in words then I'll show you how to change it to explain existentials
05:28:08 <sioraiocht> For every element of the sets a and b, there is a pair (a,b)
05:29:41 <narain> oh, FGL itself lives in Data.Graph.Inductive?
05:29:42 <sioraiocht> I've stunned you into silence?
05:30:03 <narain> sioraiocht: i believe your statement is a little off
05:30:05 <mdmkolbe|work> sioraiocht: exists a b. (a, b) [warning: not haskell syntax] means for some element in the sets a and b (which I won't tell you what specific elements they are) we have a pair (a,b)
05:30:19 <sioraiocht> ahh, okay
05:30:33 <mdmkolbe|work> sioraiocht: well you're reply was in terms of sets instead of types so it threw me for a while
05:31:00 <narain> don't you need to be talking about sets of types for the statement to be true?
05:31:05 <sioraiocht> mdmkolbe|work: ah, sorry
05:31:12 <narain> about types, i mean
05:31:21 <filcab42> hi newbie here :$
05:31:26 <sioraiocht> hihi filcab42
05:31:33 <filcab42> I'm trying to do an exercise from YAHT
05:31:41 <filcab42> but it seems... wrong
05:31:44 <filcab42> it's too verbose
05:31:51 <filcab42> but I'm not too used to haskell
05:31:55 <filcab42> I'll paste it
05:32:01 <filcab42> it seems I'm forgetting something
05:32:08 <mdmkolbe|work> sioraiocht: with universals the user gets to determine the type (since they can choose any they want) and the provider must treat that type as abstract.  with existentials the provider has packaged up a specific type and the user must treat the type as abstract
05:32:30 <mdmkolbe|work> sioraiocht: narain is right about 'sets of types'
05:32:36 <sioraiocht> mdmkolbe|work: okay
05:32:45 <quicksilver> so they are dual, in an important sense
05:32:51 <matthew-_> why is it that sometimes an implementation in a base class won't type check, but move the impl into the instance and it's fine??
05:32:54 <matthew-_> err, s/base/type/
05:32:54 <quicksilver> if I have a 'thing' of type (exists a . a)
05:32:56 <hpaste>  filcab pasted "Exercise 4.4" at http://hpaste.org/113
05:32:59 <sioraiocht> mdmkolbe|work: so universal types are analogous to haskell's polymorphic types?
05:33:00 <matthew-_> Sometimes it's really obvious, and sometimes it just doesn't seem to make sense why it doesn't work
05:33:09 <quicksilver> thenj all I can pass it to is a function of type (forall a . a -> a)
05:33:15 <quicksilver> because I don't know which type it is
05:33:17 <mdmkolbe|work> sioraiocht: existentials are how ML implements modules and can be used to do abstract data types
05:33:18 <narain> matthew-_: example?
05:33:26 <quicksilver> so I can only use it with functions which work over any type
05:33:34 <mdmkolbe|work> sioraiocht: haskell's polymorphic types *are* universal types
05:33:37 <mdmkolbe|work> ?type id
05:33:42 <lambdabot> forall a. a -> a
05:34:07 <quicksilver> filcab42: yeah, that is really that verbose
05:34:08 <sioraiocht> mdmkolbe|work: okay, that makes sense to me.  I've never done more than glance at ML...
05:34:21 <quicksilver> filcab42: there are better ways of doing that kind of thing, but not introduced at that point in the book
05:34:23 <filcab42> :s
05:34:28 <filcab42> hmmm
05:34:32 <filcab42> k
05:34:34 <filcab42> thanks
05:34:35 <quicksilver> filcab42: you have answered the exercise correctly
05:34:43 <filcab42> it just seemed too... weird
05:34:44 <quicksilver> that is, you've understood what you were supposed to be understanding
05:34:46 <filcab42> even for haskell ;)
05:35:06 <quicksilver> you could combine some of the 'nothing' cases
05:35:09 <narain> my, that's an ugly exercise
05:35:23 <narain> (filcab42, you are not to blame)
05:35:26 <filcab42> lol
05:35:39 <hpaste>  quicksilver annotated "Exercise 4.4" with "(no title)" at http://hpaste.org/113#a1
05:35:40 <mdmkolbe|work> sioraiocht: Haskell does support existentials (abet with a 'forall' syntax), but they are a pain to debug the types (to many 'quantified variable foo escapes'). for some reason people are better at universals (even though they are dual)
05:35:50 <quicksilver> filcab42: save a few lines that way
05:36:00 <filcab42> yes, quicksilver quite right
05:36:14 <sioraiocht> mdmkolbe|work: I was curious because someone on the Haskell listserv said the ST monad uses existential types
05:36:29 <sioraiocht> mdmkolbe|work: and staring at that sentence was getting me nowhere
05:36:37 <quicksilver> filcab42: also I personally wouldn't bother to name unused parameters
05:36:43 <mdmkolbe|work> @src ST
05:36:43 <lambdabot> newtype ST s a = ST (STRep s a)
05:36:50 <mdmkolbe|work> @src STRep
05:36:51 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
05:36:52 <narain> how often do you get "essential meaninglessness of life" jokes when existential types are being discussed?
05:36:53 <hpaste>  quicksilver annotated "Exercise 4.4" with "don't named unused" at http://hpaste.org/113#a2
05:37:11 <mdmkolbe|work> @src State#
05:37:11 <lambdabot> Source not found. Wrong!  You cheating scum!
05:37:18 <mdmkolbe|work> @doc ST
05:37:18 <lambdabot> ST not available
05:37:19 <filcab42> right. That should be faster too
05:37:21 <filcab42> right?
05:37:21 <quicksilver> sioraiocht: the existential in ST is used as a neat type hack
05:37:23 <mdmkolbe|work> @doc Control.Monad.ST
05:37:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
05:37:31 <quicksilver> sioraiocht: essentially the 's' type is "secret"
05:37:38 <osfameron> isn't there a way to index into the list of contents of a data type by index?
05:37:38 <quicksilver> sioraiocht: you don't know what it is, so you can't make one
05:37:46 <sioraiocht> hrm..
05:37:58 <quicksilver> sioraiocht: but it's used to make sure only 'matching' bits of ST are plugged together
05:38:22 <quicksilver> sioraiocht: it's like a special secret 'plug/socket' connector, which is unique for each different time you use ST
05:38:37 <quicksilver> osfameron: erm, that didn't parse :P
05:38:38 <matthew-_> and what is the deal with "Couldn't match expected type `x' (a rigid variable) against inferred type `some stuff'" ? WHY NOT?! It's not hard! It's called unification!
05:38:43 <quicksilver> osfameron: what's the contents of a data type?
05:38:55 <ski_> narain : .. when i hear about existentialism, i always think of the quantifier
05:38:57 <sioraiocht> matthew-_: so ANGRY!
05:38:57 <mdmkolbe|work> osfameron: only if you play scrap you boiler plate tricks e.g. Data.Generic, or Data.Dynamic
05:38:58 <quicksilver> matthew-_: it's expecting x to be general
05:39:08 <quicksilver> matthew-_: so it refuses to match it to a particular type
05:39:13 <osfameron> quicksilver: :-)  well, like (Four a b c d), it "contains" 4 things, a, b, c, and d
05:39:13 <matthew-_> sioraiocht: not really ;)
05:39:17 <ski_> @type Control.Monad.ST.runST
05:39:19 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
05:39:23 <quicksilver> osfameron: no
05:39:26 <osfameron> quicksilver: but I'm probably using the wrong words
05:39:39 <matthew-_> quicksilver: gotcha, thanks
05:39:41 <quicksilver> osfameron: or at least, in TH but not in pure haskell
05:40:09 <filcab42> omg... the next exercise should be very verbose, too :s
05:40:16 <filcab42> data Tuple a b c d = One a
05:40:17 <filcab42>                    | Two a b
05:40:17 <filcab42>                    | Three a b c
05:40:17 <filcab42>                    | Four a b c d
05:40:18 <filcab42> tuple1 :: Tuple a b c d -> Maybe a
05:40:18 <filcab42> tuple1 (One a) = Just a
05:40:19 <filcab42> tuple1 (Two a b) = Just a
05:40:21 <filcab42> tuple1 (Three a b c) = Just a
05:40:23 <filcab42> tuple1 (Four a b c d) = Just a
05:40:25 <filcab42> tuple2 :: Tuple a b c d -> Maybe b
05:40:27 <filcab42> tuple2 (One a) = Nothing
05:40:29 <filcab42> tuple2 (Two a b) = Just b
05:40:30 <int-e> @where paste
05:40:31 <lambdabot> http://hpaste.org/new
05:40:31 <filcab42> tuple2 (Three a b c) = Just b
05:40:33 <filcab42> tuple2 (Four a b c d) = Just b
05:40:35 <filcab42> tuple3 :: Tuple a b c d -> Maybe c
05:40:36 * int-e mumbles
05:40:37 <filcab42> tuple3 (One a) = Nothing
05:40:38 <opqdonut> yeah generic tuples are a pain
05:40:39 <filcab42> tuple3 (Two a b) = Nothing
05:40:41 <filcab42> tuple3 (Three a b c) = Just c
05:40:43 <filcab42> tuple3 (Four a b c d) = Just c
05:40:45 <filcab42> tuple4 :: Tuple a b c d -> Maybe d
05:40:47 <filcab42> tuple4 (One a) = Nothing
05:40:47 <narain> filcab42: don't paste into the channel!
05:40:49 <filcab42> tuple4 (Two a b) = Nothing
05:40:51 <opqdonut> hey please
05:40:51 <filcab42> tuple4 (Three a b c) = Nothing
05:40:53 <filcab42> tuple4 (Four a b c d) = Just d
05:40:55 <filcab42> ARGH
05:40:57 <filcab42> sorry
05:40:59 <filcab42> didn't mean that :(
05:41:01 <quicksilver> he can't stop once he's started :P
05:41:03 <filcab42> I know. I just pasted in the wrong place :$
05:41:07 <quicksilver> that's why you need an op to kill him
05:41:12 <quicksilver> but we don't have any :)
05:41:33 <filcab42> you can ask chanserv to op one of the "frequent ones"
05:42:00 <narain> one needs a Ctrl-C for GUI operations
05:42:22 <quicksilver> filcab42: well, obviously we do have ops :)
05:42:29 <quicksilver> filcab42: but none awake at this moment, apparently
05:42:36 <filcab42> lol
05:42:59 <opqdonut> you can always /cycle or /part on a mispaste
05:43:06 <quicksilver> opqdonut: that depends on your client :)
05:43:11 <opqdonut> and there is a command in irssi to purge the send queue
05:43:16 <opqdonut> yeah, assuming you use irssi :)
05:43:44 <quicksilver> @losers
05:43:45 <lambdabot> Maximum users seen in #haskell: 340, currently: 325 (95.6%), active: 50 (15.4%)
05:43:49 <quicksilver> climbing u p
05:44:01 <quicksilver> I wonder what time period lb's definition of 'active' is
05:44:18 <sioraiocht> hahahaha
05:44:30 <sioraiocht> love the command name
05:44:39 <sioraiocht> do any of you use haskell in your day job?
05:44:50 <int-e> 4 hours :)
05:45:11 <narain> sioraiocht: that was lambdabot's spell-check, the command actually starts with a 'u' :)
05:45:29 <quicksilver> sioraiocht: the command name is @users, but it has a levenstein distance fudge factor ;)
05:45:48 <ski_> (re 'runST' and existentialism, ':- some [S] pred store.new(store(S)::uo) is det.' in mercury, which would roughly be 'newState# :: exists s. State# s' in haskell)
05:46:50 <narain> ?pukers
05:46:50 <lambdabot> Maximum users seen in #haskell: 340, currently: 324 (95.3%), active: 48 (14.8%)
05:46:56 <narain> yuck
05:46:58 <narain> sorry
05:47:21 <opqdonut> ?ulcers
05:47:22 <lambdabot> Maximum users seen in #haskell: 340, currently: 324 (95.3%), active: 48 (14.8%)
05:47:24 <opqdonut> :)
05:47:25 <ski_> matthew-_ : i think what GHC calls 'rigid variable' is the same as 'skolem constant/function' in logic .. if you want, you can think of it like as a type constructor, thus it can only be matched with itself
05:50:20 <filcab42> oh god :s
05:50:32 <filcab42> does this seem right:Main> toHaskell (Four 1 3.3 "a" 'a')
05:50:32 <filcab42> Right (Right (Right (1,3.3,"a",'a')))
05:50:34 <filcab42> ?
05:50:47 <filcab42> it's so ugly
05:51:00 <mdmkolbe|work> @type toHaskell
05:51:05 <lambdabot> Not in scope: `toHaskell'
05:51:07 <filcab42> ?
05:51:09 <filcab42> sorry
05:51:14 <filcab42> I wrote that function
05:51:22 <filcab42> to convert from my Tuple
05:51:26 <filcab42> to a Haskell tuple
05:51:39 <filcab42> Either a (Either (a, b) ...)
05:51:50 <filcab42> that's the type
05:52:30 <mdmkolbe|work> filcab42: yes, then that would be about right (assuming you have good reason to convert to nested eithers and tuples instead of leaving it as a data type)
05:52:41 <matthew-_> ski_, quicksilver: ok, I think I'm starting to understand. Am I write in thinking that if you have class Foo a where f :: b then any instance of Foo can only specify an f that /can't be constrained in any way/? - sorry, I don't know how to phrase that last bit properly
05:53:16 <ski_> @djinn-add data Tuple a b c d = One a | Two a b | Three a b c | Four a b c d
05:53:20 <filcab42> mdmkolbe|work: it's an exercise to define a datatype Tuple so... I had to do that
05:53:41 <ski_> @djinn Tuple a b c d -> Either a (Either (a,b) (Either (a,b,c) (a,b,c,d)))
05:53:41 <lambdabot> f a =
05:53:41 <lambdabot>     case a of
05:53:41 <lambdabot>     One b -> Left b
05:53:41 <lambdabot>     Two c _ -> Left c
05:53:41 <lambdabot>     Three d _ _ -> Left d
05:53:43 <lambdabot>     Four e f g h -> Right (Right (Right (e, f, g, h)))
05:53:47 <matthew-_> ahh, you can't expect to be able to apply f into any function that isn't forall c . c ->
05:54:06 <ski_> lambdabot : you cheated !
05:54:44 <ski_> @djinn Either a (Either (a,b) (Either (a,b,c) (a,b,c,d))) -> Maybe (a,Maybe (b,Maybe (c,Maybe d)))
05:54:45 <lambdabot> f a =
05:54:45 <lambdabot>     case a of
05:54:45 <lambdabot>     Left _ -> Nothing
05:54:45 <lambdabot>     Right b -> case b of
05:54:45 <lambdabot>                Left _ -> Nothing
05:54:47 <lambdabot>                Right c -> case c of
05:54:49 <quicksilver> matthew-_: yes, that's right
05:54:49 <lambdabot>                           Left (d, e, f) -> Just (d, Just (e, Just (f, Nothing)))
05:54:51 <lambdabot>                           Right (g, h, i, j) -> Just (g, Just (h, Just (i, Just j)))
05:55:01 <quicksilver> matthew-_: if you need b to be constrained, then probably it's part of the type class too
05:55:02 <mdmkolbe|work> ski_: yeah, djinn needs smarts to lean make use of all parts of the input
05:55:06 <quicksilver> matthew-_: i.e. Foo a b
05:55:16 <quicksilver> matthew-_: and there may or may not be a fundep there
05:55:26 <quicksilver> mdmkolbe|work: it has some such smarts
05:55:29 <quicksilver> mdmkolbe|work: just not complete :)
05:55:38 <quicksilver> mdmkolbe|work: it is already 'somewhat relevant'
05:55:46 <matthew-_> quicksilver: indeed. ok, I might be making progress...
05:57:18 <quicksilver> matthew-_: I find it clearest in some ways to start with no fundeps
05:57:23 <matthew-_> yse
05:57:29 <quicksilver> matthew-_: and only add them if I convince myself they really applie
05:57:44 <quicksilver> the worst that heppens from missing fundeps is that you have to give explicity type annotations
05:57:46 <ski_> the 'f :: b' above was actually 'f :: forall b. b' .. that specifies an interface that any instance of the class has to conform to, i.e. the actual 'f' implementation must accept any 'b' whatsoever
05:58:03 <quicksilver> (the worst that happens with incorrect fundeps is total destruction of the universe)
05:58:35 <Botje> quicksilver: woah. haskell IS a powerful language.
05:59:15 <quicksilver> Botje: yeah. don't be messin' unless you know what you're doing :)
05:59:19 <DRMacIver> @quote genocide
05:59:19 <lambdabot> DRMacIver says: The number of genocides committed in sorting your array is asymptotically finite.
05:59:35 <Botje> lol
06:00:26 <mdmkolbe|work> nonsense, haskell is a safe langauge ;-)
06:01:47 <opqdonut> @quote DRMacIver
06:01:47 <lambdabot> DRMacIver says: Int# sounds like it should be a .NET language.
06:01:50 <opqdonut> @quote DRMacIver
06:01:50 <lambdabot> DRMacIver says: I'd like to rename C++ to UseD
06:02:21 <frobar> @quote
06:02:21 <lambdabot> SourceLabs says: Wilson, I understand we're vulnerable to a virus.
06:02:43 <shapr> @quote
06:02:43 <lambdabot> kolmodin says: it's nice to have static types after a bottle of wine
06:02:59 <Saizan> @quote
06:02:59 <lambdabot> i says: agree that Haskell isn't the worlds best imperative language (despite how many simon's may disagree)
06:03:28 <LeCamarade> :oD Kolmodin's quote. Very funny.
06:03:52 <Saizan> @quote at.the.party
06:03:53 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
06:04:08 <Saizan> somewhat related :D
06:04:22 * frobar is trying to wrap his head around LR parsing
06:04:58 <earthy> what issue do you have with it?
06:06:12 <frobar> earthy: right now i'm trying to understand the precise role of the stack. in LL parsing it holds the form of what remains to be parsed in a sense, but i can't quite figure out what it does in lr parsing.
06:07:08 <frobar> and in the case of look-ahead, which symbol is it it looks at? one past the next symbol in the input?
06:09:12 <earthy> lookahead is dependent on the number of lookahead tokens, obviously
06:09:21 <frobar> yeah, but say in the case of k = 1
06:09:23 <earthy> so in LR(1) you'll just look at the first token
06:10:00 <frobar> but which token is the "first"? the next token on the input stream? the token after that? doesn't it already look at the first token when applying the next rule?
06:10:01 <earthy> however, the stack contains a number of pseudo-tokens for the nonterminals followed by a number of tokens
06:10:13 <earthy> the next token on the input stream yeah
06:10:50 <earthy> the parser determines what to do to the stack based on that token
06:11:03 <earthy> (and it's internal state)
06:11:35 * frobar goes and stares at the wikipedia article some more
06:11:36 <earthy> and it can either push the token, or reduce what's on the stack to a 'recognized' nonterminal
06:11:49 <ibid> frobar: in LR(0), the parser decides what to do based on what has come before (its internal state) without looking at the input stream at all
06:12:19 <frobar> yeah, i think i've gotten the gist of how it works. it's just the implementation details i don't get.
06:12:23 <frobar> ibid: ok
06:12:25 <ibid> frobar: obviously, it'll then check if the input stream matches what it expected, but that's just to check whether the input parses or not, not to distinguish between alternatives
06:12:52 <ibid> frobar: have you written predictive parsers?
06:13:56 <frobar> ibid: nope, i've only written hacked-together parsers in the past before i even knew about different parsing models :)
06:13:58 <ibid> (also known as recursive descent without backtracking)
06:14:02 <frobar> this is for a formal languages course i'm taking
06:14:24 <frobar> i don't remember exactly how the worked either
06:14:27 <frobar> *they
06:14:45 <ibid> frobar: lookahead is very easy to understand when writing predictive parsing: each time you have to choose based on the next character, you're looking ahead
06:15:34 <frobar> yeah, i understand the concept. i'm just trying to see exactly how it's applied in the implementation of lr parsers.
06:15:36 <ibid> in the style i use (in imperative languages), i have a procedure called peek that tells me what the lookahead token is. most of the time, every time i call peek, i'm looking ahead
06:16:24 <ibid> frobar: in LR(1), the parsing table is indexed by the parser state and by the lookahead token; simple aintit? :)
06:16:38 <ibid> frobar: LR(2) basically has a 3d table indexed by the state and *two* lookahead tokens :)
06:17:31 <frobar> but isn't it indexed by the current terminal on the input stream and the state in LR(0)?
06:17:54 <earthy> frobar: LR(1)? yes.
06:18:45 <frobar> but LR(0) has to read from the input stream as well, so what's the kind of reading it does called?
06:18:57 <ibid> hm, wikipedia claims that LR(0) tables index by the token
06:19:13 <ibid> frobar: i *thought* that it just checks that the token is what it thinks it is, but let me check
06:19:15 <frobar> isn't look-ahead just looking further ahead on the input stream to make decisions than just the "current" token?
06:19:33 <frobar> ibid: wiki has been wrong before :)
06:19:38 <quicksilver> yes, that's my understanding
06:19:46 <quicksilver> any parser has to check the 'current' token, obviously
06:19:57 <quicksilver> lookahead is the next one aafter that
06:19:59 <ibid> frobar: i know :) and it's wikipedia, wiki is something else :)
06:20:02 <frobar> yeah, otherwise it'd be hard to parse anything..
06:20:06 <quicksilver> or that's the way I use the words
06:20:20 <frobar> ibid: i often use "wiki" as an abbreviation for wikipedia for some stupid reason :)
06:20:38 <ibid> frobar: many people do. i still don't like it but i suppose it's inevitable
06:21:01 <frobar> yeah, it's a bit sloppy
06:21:14 <ibid> ok, wikipedia looks correct in that sense
06:21:17 <ibid> sorry abour that, frobar
06:21:17 <ski_> wp
06:21:30 <ibid> (i'm reading appel now)
06:21:59 <frobar> could you view LR(0) as indexing only the 'current' token, while LR(k) indexes using k additional tokens?
06:22:14 <frobar> *uses
06:22:16 <ibid> no
06:22:28 <ibid> it's the automaton construction that's different
06:22:34 <frobar> ok
06:22:37 <ibid> brb
06:29:24 <frobar> i'm also curious how look-ahead interacts items (the productions with dots in them). in LR(0) the dots represent where you could be given the input read up until now, but how do you read items with added look-ahead? is it "this is where i could be provided that what follows is these look-ahead tokens", or "this is where i could be and what follows must be these look-ahead tokens", or..?
06:29:33 <frobar> the semantics aren't clear to me
06:29:40 <frobar> *interacts with
06:30:29 <Saizan> which languages are LR(0)? i didn't know it existed
06:30:49 <frobar> Saizan: those that can be parsed without look-ahead i guess
06:32:03 <frobar> err..
06:32:22 <frobar> those two "" say the same thing :P
06:32:45 <frobar> but i'm still not sure if it's the correct interpretation
06:33:40 <Saizan> http://en.wikipedia.org/wiki/LR%280%29#Constructing_LR.280.29_parsing_tables <-- judging from this, LR(0) is called LR(1) at my university :)
06:33:42 <lambdabot> http://tinyurl.com/yvfjam
06:34:41 <frobar> non-standardized terminology is annoying :(
06:34:56 <frobar> not as bad as when people standardize on bad terminology though..
06:36:55 <olsner> all LR-parsers build on the LR(0)-items - the difference is in the shift/reduce condition
06:37:15 <matthew-_> Am I the only one who apologies out loud to ghc when I make silly mistakes - I just found myself saying "sorry" out loud...
06:39:39 <olsner> I mostly spew profanities at my compilers when they don't accept my code
06:39:47 <shapr> Me too
06:40:00 <shapr> My girlfriend says I only swear when I'm driving or when I'm compiling.
06:40:06 <opqdonut> :)
06:40:08 <LeCamarade> Me too.
06:40:38 <matthew-_> why swear at it? It's not its fault!
06:41:21 <nattfodd> I noticed that I don't swear, but I make threatening gestures with my fingers while it's compiling
06:41:36 <Mitar> how can i redefine the show of an type Foo = Int ?
06:41:45 <nattfodd> clearly, the compiler is impressed and afraid
06:41:56 <chessguy> @get-slap
06:41:56 <lambdabot> shapr!!
06:41:57 <ski_> We should THANK the compiler FOR finding our mistakes !
06:42:15 <ski_> Mitar : no
06:42:23 <frobar> olsner: does the look-ahead allow the parser to look at the input to decide what reduction to make after it has shifted?
06:42:24 <chessguy> hey shapr, i hear you have some ideas for refactoring GPLib
06:42:25 <DRMacIver> Mitar: type just declares a type alias. There is no difference between Foo and Int there. You need to define a newtype or similar.
06:42:46 <olsner> frobar: depends on the flavour of LR
06:42:55 <nattfodd> no way, we should curse him for making obvious that we have been making mistakes instead of rolling them under the carpet
06:43:03 <nattfodd> which should be the normal behaviour
06:43:08 <hpaste>  Mitar pasted "show" at http://hpaste.org/114
06:43:12 <frobar> olsner: in what other ways could the look-ahead be used?
06:43:15 <Mitar> i just pasted ...
06:43:28 <DRMacIver> Cursing the compiler for not accepting code? How bizarre.
06:43:44 <DRMacIver> I curse the application for not working because of code the compiler should have refused.
06:43:53 <DRMacIver> (All the freaking time. Bloody Java.)
06:43:59 <Mitar> i would like that when I do show of NXTVersion i get something as NXTInfo (Name "Name") (BTAddress xx:xx:xx:xx:xx:xx) (BTStrength 0) (FlashFree 95468)
06:44:09 <nattfodd> no, that's when you blame cosmicrays which obviously changed bits in the binary
06:44:22 <Mitar> but when I do show BTAddress that i get xx:xx:xx:xx:xx and not (BTAddress xx:xx:xx:xx:xx:xx)
06:44:46 <ski_> 'BTAddress' ?
06:45:11 <shapr> chessguy: You screamt?
06:45:14 <hpaste>  Mitar annotated "show" with "(no title)" at http://hpaste.org/114#a1
06:45:22 <Mitar> :-)
06:45:23 <Mitar> ups ..
06:45:36 <chessguy> shapr, i hear you have some ideas for refactoring GPLib
06:45:53 <quicksilver> Mitar: it's not a particularly good plan to override show, IMO
06:46:00 <frobar> olsner: and what is the semantics of tokens with added look-ahead? is it "this is i could be, and i have this look-ahead", or..?
06:46:05 <quicksilver> Mitar: show should produce valid haskell expressions, that's what it's supposed to mean
06:46:06 <frobar> err, items
06:46:11 <frobar> the productions with dots in them
06:46:18 <quicksilver> Mitar: if you want something else, call it 'prettyprint' or 'pp' or something
06:47:14 <shapr> chessguy: Yeah, turn it into monad transformers.
06:47:35 <ski_> 'take 10 $ show (foo :: BTAdress)' ought to be '"(BTAddress"'
06:47:44 <matthew-_> DRMacIver: would you rather have the Eclipse Java Debugger + Java or Haskell? I.e. does haskell's better type checking effectively eliminate the need for runtime debugging?
06:47:52 <chessguy> shapr, mmmm, how so?
06:48:09 <DRMacIver> matthew-_: I haven't written enough large scale projects in Haskell to say for sure.
06:48:43 <DRMacIver> s/enough/any/ really
06:48:49 <DRMacIver> matthew-_: I suspect the answer is that I'd rather have Haskell's better type checking but I'd far rather have both.
06:49:21 <sioraiocht> compiling gcc is SO not for the faint of heart
06:49:22 <DRMacIver> Proper automated testing discipline is likely to be of more use than the debugger.
06:49:53 <DRMacIver> sioraiocht: I tried to compile gcc a few weekends ago and couldn't get it to work. :( (Although by the end it was the nonstandard extension which was breaking the compile rather than gcc itself)
06:49:53 <LeCamarade> Most of the problems that are being solved in mainstream languages (by IDEs and tricks and stuff and maybe even OO) don't exist in the functional side.
06:50:09 <SamB_XP> DRMacIver: but I bet eclipse's Java debugger doesn't work on Haskell programs
06:50:13 <shapr> chessguy: PopulationT and TrainingT monad transformers came to mind, but they wouldn't be so different from state and reader/writer.
06:50:16 <dozer> :t mapM (f::a -> State Int a) [xs::a]
06:50:18 <lambdabot>     Ambiguous occurrence `mapM'
06:50:18 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
06:50:25 <sioraiocht> DRMacIver: Apple just needs to hurry up and get their version of 4.2 out so I can use something that supports OpenMP
06:50:29 * osfameron doesn't like debuggers
06:50:32 <nattfodd> sioraiocht: I'd rather compile a hundred gcc than a firefox
06:50:42 <olsner> frobar: (somewhat rusty, but it's coming back to me) it's something like... everytime you add more rules to an item, i.e. from A -> .Ba you'd add B -> .b [a], because the (only possible) terminal after the B is an a - that's the lookahead.. propagate that lookahead down the road and you get to something like C -> c. [a] - then you know that in order to reduce that rule you must be looking-ahead at an a
06:50:42 <sioraiocht> nattfodd: never tried, never want to
06:50:52 <ski_> :t Control.Monad.mapM (f::a -> State Int a) [xs::a]
06:50:53 <chessguy> shapr, hmm. so what do they get us then?
06:50:54 <lambdabot> Not in scope: `f'
06:50:54 <lambdabot>  
06:50:54 <lambdabot> <interactive>:1:42: Not in scope: `xs'
06:50:58 <nattfodd> I had to once, let it go after losing an afternoon
06:51:04 <dozer> :t Contol.Monad.mapM (f::a -> State Int a) [xs::a]
06:51:06 <lambdabot> Couldn't find qualified module.
06:51:09 <SamB_XP> shapr: just because they might internally be implemented as RWST (or some smaller combination) doesn't mean that they aren't good ideas ;-)
06:51:14 <DRMacIver> SamB_XP: Given enough vicious beatings delivered to eclipse and LambdaVM I bet it could be reduced to a simple matter of code. ;)
06:51:34 <SamB_XP> DRMacIver: even if it operated, I bet it wouldn't help much
06:51:49 <dozer> :t Prelude.mapM (f::a -> State Int a) [xs::a]
06:51:51 <lambdabot> Not in scope: `f'
06:51:51 <lambdabot>  
06:51:51 <lambdabot> <interactive>:1:36: Not in scope: `xs'
06:52:03 <DRMacIver> SamB_XP: Well, yes.
06:52:06 <SamB_XP> Haskell being evaluated in such non-lexical ways
06:52:17 <shapr> chessguy: When stacking the GPLib MonadTs, you would get a purpose specific interpreter for this one application.
06:52:36 <DRMacIver> matthew-_: On further reflection, I can't think of anything I've solved with the debugger that would have occurred given suitably good static checking and maybe a bit of TDD.
06:52:46 <SamB_XP> shapr: the wonderful thing about newtype deriving is that you don't have to do it
06:53:12 <chessguy> well, that's not really a MonadT thing. if i build a DSL for anything, don't i basically have an interpreter like that?
06:53:31 <chessguy> i'm not saying it's a bad idea, just not seeing what the win is
06:53:36 <dozer> :t Prelude.mapM (f::(a -> State Int a)) [(xs::a)]
06:53:38 <lambdabot> Not in scope: `f'
06:53:38 <lambdabot>  
06:53:38 <lambdabot> <interactive>:1:39: Not in scope: `xs'
06:53:48 <dozer> I give up - lunch time
06:53:58 <shapr> Sure, but if GPLib furnished a few monad transformers specifically for genetic programming and some examples of how to plug them together, then people could build their own genetic programming DSL for just one purpose.
06:54:21 <quicksilver> the hardest things to test with TDD are highly interactive things
06:54:36 <quicksilver> either interactive with GUIs or interactive with bits of environment which are hard to fake
06:54:37 <shapr> For example, what if I want to have multiple populations each with different rules? And what if I'd like to re-rank the populations on each iteration according to whoever is performing best?
06:54:44 <quicksilver> complex behaviour of other network peers
06:54:54 <quicksilver> in those cases debuggers can be helpful
06:55:18 <DRMacIver> quicksilver: Yeah. I'm not suggesting it as a magic bullet, and it definitely doesn't eliminate the need for a debugger.
06:55:36 <DRMacIver> Hmm. Actually I guess you're right, in that a lot of the web facing stuff would have been hard to figure out without a debugger.
06:55:46 <chessguy> shapr, oh, i see. you're saying MonadTs will let the user build that into their own DSL instead of providing one overall GP DSL
06:55:53 <shapr> chessguy: Right
06:55:57 <DRMacIver> But a lot of it wouldn't have occurred in the first place because the compielr would have said "Oi, this code is shit and will break. Fix it!"
06:56:08 <chessguy> shapr, got any suggestions of simple libraries to look at?
06:56:12 <shapr> Er, no
06:56:19 * DRMacIver is in no way making a sweeping statement here, just reflecting on the problems I've used the debugger to solve. :)
06:56:43 <chessguy> or any library at all?
06:57:00 <shapr> I can't think of any library that currently uses monad transformers that way.
06:57:53 <chessguy> ugh. i'm really not sure what it would look like
06:59:14 <filcab42> DRMacIver: but... would the compiler say that, or the debugger?
06:59:45 <filcab42> you said the compiler would complain. And then changed to "just reflecting on the problems I've used the debugger for"
07:00:12 <SamB_XP> filcab42: well, Haskell compilers complain a lot more than Java compilers, I think
07:00:18 <DRMacIver> filcab42: The conversation is in comparing the relative benefits of a Java-like debugger and a Haskell-like type system for tracking down and eliminating bugs.
07:00:26 <SamB_XP> except Java compilers are picky about exceptions
07:00:28 <filcab42> yes, exactly my point ;)
07:00:41 <DRMacIver> filcab42: If it were Haskell, the compiler would have complained. In Java it did not and so I had to track the problem down with the debugger.
07:00:43 <filcab42> SamB_XP: unfortunately... not only about exceptions
07:02:14 <nattfodd> DRMacIver: sorry, what's TDD?
07:02:48 <Wild_Cat> nattfodd: Test-Driven Development.
07:02:50 <DRMacIver> Test driven development.
07:03:02 <nattfodd> like quickcheck, then?
07:03:13 <quicksilver> not really
07:03:18 <quicksilver> quickcheck is a testing tool
07:03:19 <Wild_Cat> not exactly. QuickCheck is a tool. TDD is a methodology.
07:03:19 <DRMacIver> Although I'm being sloppy and using it as a short hand for "Proper automated testing" rather than full on TDD. :)
07:03:31 <quicksilver> TDD is the style where you write the test first
07:03:42 <Wild_Cat> in Haskell, you do TDD using QuickCheck, though.
07:03:44 <nattfodd> but quickcheck is a tool to use TDD, or entirely different?
07:03:49 <LoganCapaldo> and QC is the tool that writes the test cases for you :)
07:03:51 <quicksilver> Wild_Cat: you might do
07:03:55 <nattfodd> ok, that was my question, thanks :)
07:04:08 <quicksilver> Wild_Cat: I sometimes write tests simply as tests :: [Bool]
07:05:43 <LoganCapaldo> @check (\x y -> x > y ==> (x + y) > y) :: Integer -> Integer -> Property
07:05:44 <lambdabot>  Falsifiable, after 6 tests: 0, -2
07:06:00 <LoganCapaldo> See
07:06:08 <LoganCapaldo> it even shows my errors
07:06:10 <LoganCapaldo> heh
07:07:05 <LoganCapaldo> @check (\x y -> x > y && x /= 0 && y /= 0 ==> (x + y) > y) :: Integer -> Integer -> Property
07:07:06 <lambdabot>  Falsifiable, after 6 tests: -1, -2
07:07:15 <LoganCapaldo> wow
07:07:25 <LoganCapaldo> My understanding of simple math is totally broken
07:07:30 <nattfodd> :)
07:07:31 <LoganCapaldo> thank you quickcheck!
07:07:34 <dolio> @check (\x y -> x > 0 ==> x + y > y) :: Integer -> Integer -> Property
07:07:35 <lambdabot>  OK, passed 500 tests.
07:08:16 * LoganCapaldo blames it on the one cup of coffee
07:08:45 <LoganCapaldo> Although I think my mistakes demostrate the coolness of QC better than OK Passed 500 Tests does
07:08:50 <nattfodd> @check (\x y -> (y > 0 || x > 0) && x > y ==> x + y > y) :: Integer -> Integer -> Property
07:08:51 <lambdabot>  OK, passed 500 tests.
07:09:09 <quicksilver> definitely, mistakes are more interesting
07:09:38 <jfredett> wait a second, you can do that? i mean- in general- do something like (\ x y z -> (conditions on x,y,z) => function)
07:09:53 <jfredett> could I do that in a normal function? or just a QC function?
07:10:02 <SamB_XP> jfredett: it is a QC thing
07:10:06 <jfredett> :(
07:10:12 <SamB_XP> @type (==>)
07:10:13 <lambdabot> Not in scope: `==>'
07:10:18 <jfredett> it should be an everywhere thing, thats a brilliant abstraction
07:10:31 <LoganCapaldo> jfredett: it's not to place constraints on the arguments.
07:10:34 <SamB_XP> @hoogle ==>
07:10:35 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
07:10:49 <nattfodd> jfredett: but then it would be caught at runtime and not compiletime
07:10:53 <LoganCapaldo> remember F -> anything is true
07:11:16 <Jaak> @check \f g x -> let _ = (f :: Int -> Int, g :: Int -> Int) in f (g x) == (f . g) x
07:11:17 <lambdabot>  OK, passed 500 tests.
07:12:08 <jfredett> nattfodd, wait, what? I'm talking about abstracting away from even the func args | cond = code | cond2 = code2, etc.
07:12:10 <LoganCapaldo> @check (\x -> False ==> x == x) :: Int -> Property
07:12:12 <lambdabot>  Arguments exhausted after 0 tests.
07:12:37 <LoganCapaldo> I guess that's not what ==> does
07:12:40 <LoganCapaldo> lol
07:12:59 <nattfodd> LoganCapaldo: no, it just means it can't find any argument of type False
07:13:09 <jfredett> occasionally, I have function in which I want to constrain to say "x shouldn't be less than zero" my current method is to make the datatype a Maybe (some data)
07:13:20 <SamB_XP> nattfodd: you mean it can't find any arguments such that False is True
07:13:31 <jfredett> and then put an explicit | cond = code for the corner case.
07:13:33 <nattfodd> SamB_XP: depends what False looks like :)
07:13:47 <jfredett> but If I could have haskell do that for me
07:14:03 <LoganCapaldo> I thought ==> was implication. but I guess the trivial cases aren't useful as far as testing  goes
07:14:14 <jfredett> something like f args ==> conditions = |cond = code | ...
07:14:18 <jfredett> that would be brilliant
07:14:19 <nattfodd> LoganCapaldo: sounds like implication to me
07:14:26 <SamB_XP> LoganCapaldo: it is supposed to be implication
07:15:21 <LoganCapaldo> Yeah, but if it is, shouldn't that come back with OK Passed N Tests?
07:15:43 <LoganCapaldo> regardless of the value of x
07:15:48 <nattfodd> LoganCapaldo: that's what it did
07:15:59 <nattfodd> OK, tried 0 tests
07:16:04 <jfredett> hmm, I should look at the QC library, I'm not even sure how that would work..
07:16:09 <LoganCapaldo> It said Arguments exhausted after 0 tests
07:16:26 <LoganCapaldo> not Ok tried 0 tests. but if that's what that means I'll take your word for it
07:16:29 <nattfodd> the "OK" was implicit, otherwise it would have said "test falsifiable"
07:16:41 <SamB_XP> well, usually you want the test to have tested cases where the lhs holds, to ensure that the rhs holds as well
07:16:41 <LoganCapaldo> ok
07:17:06 <dolio> LoganCapaldo: I think that means it didn't find any arguments that satisfied "False". :)
07:17:07 <LoganCapaldo> SamB_XP: Yeah, that's what i meant earlier by "the trivial cases aren't useful as far as testing goes"
07:17:30 <nattfodd> well, your function is always true
07:17:41 <LoganCapaldo> that was the idea :)
07:17:48 <nattfodd> so strictly speaking, the test *was* useful
07:18:35 <dolio> @check \x -> length (x :: [Int]) > 100 ==> not (null x)
07:18:36 <lambdabot>  Arguments exhausted after 0 tests.
07:18:46 <LoganCapaldo> I was trying to show that ==> wasn't a filter or guard, that it was jsut aprt of the conditions for a passing test
07:19:26 <LoganCapaldo> And wouldn't necessarily therefore be useful as such outside of test code
07:20:45 <LoganCapaldo> Since it seemed to me jfredett was thinking it was a more general case-like operator
07:20:49 <dolio> @scheck \x -> False ==> (x :: Int) == x
07:20:50 <lambdabot>   Completed 13 test(s) without failure.  But 13 did not meet ==> condition.
07:20:50 <SamB_XP> LoganCapaldo: I think it acts as a filter
07:21:31 <SamB_XP> @scheck \x -> False ==> (x :: [Bool]) == x
07:21:32 <lambdabot>   Completed 127 test(s) without failure.  But 127 did not meet ==> condition.
07:21:36 <LoganCapaldo> SamB_XP: Ok.
07:21:45 <olsner> generate->filter->test
07:22:13 <jfredett> From haskell.org: QC provides combinators to : "define properties, observe the distribution of test data, and define test data generators"
07:22:25 <jfredett> http://www.haskell.org/ghc/docs/latest/html/libraries/
07:22:30 <olsner> an implication where the left hand side is always false is always true
07:22:39 <jfredett> i think that its just imposing conditions
07:22:54 <LoganCapaldo> olsner: yes.
07:23:10 <HairyDude> what can make lhs2TeX cause a "missing $ inserted" error in pdflatex?
07:23:23 <jfredett> as QC is a statistical testing device, and not a logic resolution device. but what do i know. :/
07:23:42 * LoganCapaldo knows nothing
07:23:52 <LoganCapaldo> But I like to pretend :)
07:23:54 <jfredett> ditto,
07:24:39 <filcab42> maybe you have a '$' in a comment
07:25:13 <filcab42> or a '$' and, before another '$', an empty line.
07:25:19 <filcab42> (inside a comment)
07:25:31 <dolio> jfredett: Incidentally, what's wrong with: 'f args | condition = code | otherwise = other code' for general functions?
07:25:49 <dolio> jfredett: Or 'f args = guard (condition) >> return (code)'
07:25:52 <jfredett> well, nothing
07:25:53 <filcab42> I'm saying "inside a comment" because lhs2TeX should wrap the code inside apropriate tags
07:26:19 <jfredett> I'd just like 'f arg => (conditions) = | cond = code | ...
07:26:28 <jfredett> it'd look more intuitive to a math junkie like me
07:26:40 <jfredett> thats more or less how I write functions
07:27:05 <jfredett> name, arguments, 'global' conditions, specific conditions
07:27:27 <dolio> Ah.
07:28:10 <dolio> I suppose you could mimic that with something like 'f arg = guard (conditions) >> return g where g | cond = code | ...'
07:29:33 <jfredett> yeh, but thats ugly
07:29:50 <jfredett> i don't care how my code works underneath, i want it to look pretty on top
07:29:51 <dolio> :)
07:29:54 <jfredett> i'm a mathematician, damnit
07:29:59 <jfredett> not a hacker.
07:30:18 <jfredett> but if its "that" easy to implement
07:31:06 <LeCamarade> jfredett: Makes you a Haskeller by default, from what I've seen.
07:31:09 <dolio> It's a matter of syntax sugar, I think.
07:31:09 <olsner> does case have guards?
07:31:13 <jfredett> I'm sure it wouldn't be hard to write a kind of parsing function thing, which can take those conditions. heck, it might even be better to put those things in the Type sig.
07:31:23 <jfredett> dolio, damn right it is
07:31:51 <dolio> Although you'd have to decide what the return type of such functions would be.
07:32:37 <dolio> Perhaps nested guards would be another way to do something similar which wouldn't require that.
07:34:54 <chessguy> shapr, you still around?
07:35:21 <dolio> f args | condition { | cond = code | ... }
07:43:20 <hpaste>  dozer pasted "statefull" at http://hpaste.org/115
07:43:47 <dozer> so, I'd like to rewrite/remove the 'number' function in this paste
07:43:58 <dozer> using something more like a fold or map or something
07:44:01 <dozer> but can't see how to
07:44:29 <dozer> 'numberAll' doesn't do what I want
07:45:41 <chessguy> i think you want a mapM or something
07:45:47 <LoganCapaldo> dozer: maybe you want mapAccumL/mapAccumR?
07:46:11 <LoganCapaldo> or just listen to chessguy. :)
07:46:32 <chessguy> i'm a n00b, don't listen to me
07:46:47 <LoganCapaldo> I'm noobier than you
07:46:59 <olsner> @photontorpedo
07:47:00 <lambdabot> can haskell do data transfer from box to box over sockets?
07:47:11 <LoganCapaldo> lambdabot: no
07:47:11 <olsner> ^ noob
07:47:12 <chessguy> dozer, what result are you looking for?
07:47:25 <LoganCapaldo> that requires IO, which we simply can not allow
07:47:37 <Saizan> mmh numverAll = mapM numberPair
07:47:40 <LoganCapaldo> :)
07:47:45 <chessguy> something like [("pig",1),("dog",2),...] ?
07:48:16 <dolio> @src sequence
07:48:17 <lambdabot> sequence ms = foldr k (return []) ms
07:48:17 <lambdabot>     where
07:48:17 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:48:18 <LoganCapaldo> Saizan is usually right
07:48:20 <dozer> yeah, that's right chessguy
07:48:25 <olsner> > zip ["pig","dog"] [1..]
07:48:26 <lambdabot>  [("pig",1),("dog",2)]
07:48:31 <LoganCapaldo> so you should also listen to him :)
07:48:36 <chessguy> that's what i was just going to say
07:48:46 <dozer> mapM seems to do the job
07:49:04 <chessguy> @pl \xs -> zip xs [1..]
07:49:04 <lambdabot> flip zip [1..]
07:49:09 <chessguy> cute
07:49:09 <quicksilver> sure looks like mapM to me...
07:49:24 <chessguy> uh, zip is way better guys
07:49:28 <quicksilver> @src mapM
07:49:29 <lambdabot> mapM f as = sequence (map f as)
07:50:03 <quicksilver> chessguy: depends on what the general problem is
07:50:10 <LoganCapaldo> chessguy: not if you need the ticking to be updated, no?
07:50:10 <quicksilver> chessguy: maybe this is a simple case :)
07:50:16 <hpaste>  dozer annotated "statefull" with "works now" at http://hpaste.org/115#a1
07:50:23 <quicksilver> chessguy: most likely he is just playing with state monads
07:50:28 <quicksilver> chessguy: and so it's just a simple example of that
07:50:29 <chessguy> i'm assuming the problem is what he gave us
07:50:44 <chessguy> maybe that's a silly assumption...
07:51:07 <Saizan> dozer: what was wrong with numberAll? they should be the same
07:51:15 <nominolo> @seen dcoutts
07:51:15 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 37s ago.
07:51:27 <LoganCapaldo> clearly gremlins
07:51:32 <nominolo> 37s?
07:51:49 <chessguy> s=seconds
07:52:00 <nominolo> oh, other channel,  i guess
07:52:09 <dozer> Saizan: don't understand - come again?
07:52:52 <Saizan> dozer: numberAll xs = sequence (map numberPair xs) === mapM numberPair
07:53:16 <dozer> Saizan: yeah
07:53:59 <chessguy> he wasn't calling numberAll from main the first time
07:54:43 <Saizan> chessguy: yes, but he said it wasn't what he wanted, and i was puzzling over the difference :)
07:57:43 <dolio> @quote cheeseguy
07:57:43 <lambdabot> cheeseguy says: what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
07:59:29 * chessguy sighs
07:59:33 <olsner> see me meet a quote
07:59:36 <chessguy> it's so hard to get respect around here
08:00:34 <DRMacIver> chezzguy: Totally.
08:00:52 <chessguy> DRMacIver, bite me! :)
08:02:35 <dozer> I think the first time perhaps I was stumped by not calling evalState in main
08:03:17 <LoganCapaldo> I wish evalState and execState had easier to remember names
08:03:51 <LoganCapaldo> maybe finalState and runState_
08:03:55 <quicksilver> LoganCapaldo: fortunately, they have easy to remember types
08:04:03 <LoganCapaldo> but those might just be easier for me to remeber
08:04:09 <quicksilver> I just do
08:04:11 <LoganCapaldo> quicksilver: yep. thats the only way I keep em stright
08:04:12 <quicksilver> :t evalState
08:04:15 <lambdabot> forall s a. State s a -> s -> a
08:04:15 <quicksilver> if in doubt :)
08:05:16 * chessguy agrees with LoganCapaldo 
08:06:13 <quicksilver> to be honest, I just use runState
08:06:26 <quicksilver> and take or leave whichever bit I'm interested in
08:06:51 <chessguy> @type (.)
08:06:53 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:11:52 <chessguy> hiya sjanssen
08:12:06 <sjanssen> greetings, chessguy
08:13:04 <sjanssen> @yow
08:13:04 <lambdabot> DON'T go!!  I'm not HOWARD COSELL!!  I know POLISH JOKES ... WAIT!!
08:13:05 <lambdabot> Don't go!!  I AM Howard Cosell! ... And I DON'T know Polish jokes!!
08:14:17 <Apocalisp> @yarr
08:14:18 <lambdabot> Aye Aye Cap'n
08:16:03 * edwardk swears. @yow is the only thing that keeps the intellectual/abstraction level here out of the stratosphere and down around IRC norm.
08:17:12 <cjeris> edwardk: the other thing that makes #haskell not really an irc channel is that mostly people are much too nice. :)
08:17:18 <edwardk> hehe
08:19:06 <edwardk> I think what happens is that people really like to have other people like what they like, and Haskell has such a small audience to start with that by now, everyone who is here is willing to talk to anyone who even remotely cares about their topic. ;) It just comes across as being obsequiously nice.
08:20:28 <edwardk> its like hrmm, you've heard of catamorphisms? yay! i have this interesting use case for (apo/zygo/para/ana/cata/gcata/...)morphisms and I'll drag you up by your bootstraps so I have someone to talk to about it!
08:20:59 <edwardk> when thought about in those terms, it seems more pathetic than friendly ;)
08:21:09 <chessguy> lol
08:21:50 <DRMacIver> Actually, Haskell is part of a really nefarious psychological warfare plan. Thinking in monads and programming without side effects warps your brain and makes you a nicer person.
08:21:58 <edwardk> ah
08:22:22 <DRMacIver> When the aliens invade they shall see no resistance from the brightest of earth's programmers, because they'll have spent so long working with Haskell that they will welcome their new overlords with a big hug.
08:22:34 <edwardk> I wondered why I had stopped torturing small animals on the way in to work. Hrmm.
08:22:37 <chessguy> programming in Haskell != programming without side effects
08:22:39 <shapr> chessguy: Yeah, what's up?
08:23:04 <desp> hugs++
08:23:16 <DRMacIver> chessguy: Sure it is. It just describes how you might perform side effects should you choose to do so. ;)
08:23:44 <chessguy> it's more like being explicit about your side effects
08:24:12 <chessguy> shapr, so, you gave the example of wanting to be able to sort the population on every iteration
08:24:31 <chessguy> shapr, how would you want to be able to write that using monadTs?
08:24:50 <chessguy> shapr, on the client side i mean
08:26:59 <ski_> chessguy : if it is explicit, it isn't *side*-effects :)
08:27:31 <chessguy> ski_, for some definition of side effects maybe
08:27:45 <ski_> it's just a matter of POV
08:28:04 <chessguy> if it's not the primary effect, i'd consider it a side effect, even if you're explicit about it
08:28:43 <quicksilver> chessguy: it is a matter of english language semantics, of course
08:28:58 <quicksilver> but in programming languages, it's common to think that 'side-effects' are things not modelled in the type
08:29:16 <quicksilver> or not modelled in the simplistic denotational semantics of expressions
08:29:31 <quicksilver> in haskell everything is an expression, everything is modelled in the type, and nothing is 'side' :)
08:30:12 <ski_> [[e0 e1]] = [[e0]] >>= \f -> [[e1]] >>= \x -> return (f x)  -- part of local transformation from implicit side-effects to explicit effects
08:30:56 <HairyDude> anyone knwo how to use the subst directive in lhs2TeX?
08:30:56 <chessguy> if i have a stack, modelled in a monad, transformed with a writer, and every time i push something onto the stack, it logs it, the logging is a side effect. it's not the primary thing i'm doing
08:31:04 <byorgey> @djinn (a -> a) -> a
08:31:05 <lambdabot> -- f cannot be realized.
08:31:28 <byorgey> @type Control.Monad.Fix.fix
08:31:31 <lambdabot> forall a. (a -> a) -> a
08:31:34 <quicksilver> chessguy: I agree, that's a different meaning of 'side-effect' which makes sense
08:31:43 <quicksilver> chessguy: it's not the one commonly used by semanticists, though
08:31:51 <quicksilver> and, by extension, people in the haskell community
08:32:59 <byorgey> ok, what's up with Curry-Howard and Control.Monad.Fix.fix?
08:33:08 <ski_> chessguy : that's because you aren't primarily thinking on the level of the common "haskell category", so to speak, you are thinking in the "kleisli category" of the monad in question, where morphisms (/ functions) have side-effects
08:33:30 <ski_> (i think this is related to the notion of "internal language" as in topos theory ..)
08:33:44 <chessguy> i don't know, i just think it sounds hoaky to talk about programming "without side effects" in haskell. it's not like they go away. we still do the same things. we're just more explicit about how and when we do them
08:33:57 <quicksilver> and therefore they are no longer 'side'
08:33:59 <nominolo> byorgey: the Y combinator is not typable
08:34:00 <chessguy> ski_, i have no idea what you're talking about
08:34:03 <quicksilver> they become simple 'effects'
08:34:07 <chessguy> hablas ingles?
08:34:19 <byorgey> nominolo: ah.
08:34:42 * byorgey goes off to think about the Y combinator
08:34:45 <dolio> byorgey: (False -> False) -> False
08:35:08 <byorgey> dolio: exactly
08:35:10 <kosmikus> HairyDude: what do you want to use it for?
08:35:10 <lambdabot> kosmikus: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:35:13 <ski_> chessguy : exactly ! we often still perform the same effects .. but we're more picky about when/where they may occur, and when/where they may not
08:35:34 <dolio> byorgey: So the analogue of Y isn't part of a consistent logic, and djinn won't produce it for you.
08:35:36 <chessguy> fine. but then that's not programming without side effects
08:35:42 <nominolo> byorgey: i.e., a proof of that "a implies a" does not imply "there is an a"
08:35:59 <HairyDude> kosmikus: well I have a pragma split over a few lines, but it's putting it all on one line. I guess %subst pragma is the way to tell it how to do it properly, but I can't tell how to use it
08:36:14 <byorgey> nominolo: right, that's why I was confused... the fix function has type (a->a)->a, but that's obviously not a theorem in FOPL
08:36:42 <nominolo> byorgey: the haskell type system isn't very useful as a logic ;)
08:37:04 <osfameron> the "fix" combinator is at least slightly easier to work out than the Y combinator
08:37:10 <byorgey> nominolo: fair enough =)
08:37:21 <dolio> byorgey: It (or some other primitive that can produce it) is needed for turing completeness, though.
08:37:34 <dolio> If you're interested in Turing completeness.
08:37:34 <byorgey> dolio: right.
08:37:39 <ski_> chessguy : i (and i think quicksilver too) is just claiming that a good way to think of it is that it is programming without *side*-effects .. though it is still programming with effects .. (the same effects can be affected)
08:37:40 <byorgey> dolio: definitely =)
08:38:11 <HairyDude> kosmikus: oh, plus I have a bug report. in poly mode it passes through underscores intact, but it should put a backslash in front of them
08:38:36 <dolio> byorgey: Well, there are people who argue that Turing completeness isn't needed most of the time, so we should program in a total language with, say, a monad for non-total functions in the specific cases where they're necessary.
08:38:54 <ski_> http://lambda-the-ultimate.org/node/2003
08:38:56 <lambdabot> Title: Total Functional Programming | Lambda the Ultimate
08:39:12 <quicksilver> dolio: I certainly argue that
08:39:27 <dolio> quicksilver: I think I agree, as well.
08:39:28 <quicksilver> dolio: and I program in the total fragment of haskell when I can
08:39:31 <byorgey> interesting
08:39:34 <kosmikus> HairyDude: I don't think there's a good way to typeset multiline comments at the moment.
08:39:45 <HairyDude> ah, ok
08:39:48 <dolio> I look forward to when I can use Epigram. :)
08:39:53 <kosmikus> HairyDude: I don't see what you mean with the underscores.
08:39:58 <quicksilver> dolio: some algorithms are very cumbersome though, so it becomes easier to cheat
08:40:00 <kosmikus> underscores in a comment?
08:40:14 <kosmikus> comments are just treated as TeX -- so are pragmas
08:40:16 <HairyDude> kosmikus: I get a "inserting missing $" error on that pragma
08:40:20 <quicksilver> dolio: basically when 'implicit proof of termination' because too large
08:40:27 <quicksilver> dolio: /cause/comes/
08:40:51 <kosmikus> HairyDude: yes, you can see it as a bug, but I classify it was "wontfix" until someone makes a reasonable suggestion on how to format pragmas, generally.
08:40:52 <HairyDude> kosmikus: it chokes on the underscore in "OPTIONS_GHC"
08:41:00 <HairyDude> yeah, fair enough :)
08:41:25 <kosmikus> my general suggestion is not to format pragmas at all
08:41:34 <ski_> I, for one, welcome our new totalitarian overlords
08:42:04 <kosmikus> you can describe in the text that your code requires a certain compiler extension, I don't see the absolute need to have the source code pragma formatted in LaTeX. but I know, it would be nice to have.
08:43:16 <chessguy> araujo!
08:43:45 <kosmikus> HairyDude: another workaround in this case might be to use the LANGUAGE rather than the OPTIONS_GHC pragma ;)
08:44:26 <HairyDude> kosmikus: it still sticks it all on one line :)
08:44:52 <kosmikus> true
08:44:56 <HairyDude> kosmikus: personally I think verbatim would be a fairly sensible way to typeset pragmas
08:46:31 <kosmikus> hmm
08:47:19 <HairyDude> [pwb@rhuidean final]$ lhs2TeX --poly -o final2.tex final.tex
08:47:20 <HairyDude> lhs2TeX: Maybe.fromJust: Nothing
08:47:49 <quicksilver> badabom!
08:47:59 <quicksilver> that's where you need... 'Catch'! :)
08:48:42 <chessguy> yeah, if you can get your code working on nhc
08:49:12 <quicksilver> wouldn't of thought that would be a problem for lhs2TeX
08:49:17 <quicksilver> s/of/have/
08:49:17 <quicksilver> bah
08:49:37 <chessguy> i'm not saying it would be
08:50:25 <HairyDude> think that _might_ be caused by putting %subst pragma before the pragma instead of after it
09:04:00 <cjeris> ski_: where can i go to learn about Kleisli categories?
09:04:31 <quicksilver> cjeris: do you already know any category theory?
09:05:10 <cjeris> quicksilver: what you might expect a first-year math grad student other than an algebraic topologist (which I was once) to know.
09:05:43 <cjeris> say, everything up to but not including adjunctions.
09:07:56 <ski_> given a monoidal category 'C' and a monad 'M' over it, the kleisli category over that monad has as objects the objects of 'C', and the morphisms from object 'A' to object 'B' in the kleisli category is just the morphisms from object 'A' to 'M B' in 'C', identities is the monadic 'unit_A : A -> M A'
09:09:50 <ski_> composition of a morphism from 'A' to 'B' with a morphism from 'B' to 'C', i.e underlying morphisms 'f : A -> M B', 'g : B -> M C', is the morphism whose underlying morphism is 'join_A . M g . f : A -> M C'
09:10:26 <ski_> (er, s/join_A/join_C/)
09:10:38 <cjeris> or >>= ?
09:11:00 <Saizan> (>>= g) . f
09:11:15 <ski_> (>>= f) = join . fmap f
09:11:46 <ski_> '(>>= f)' is sometimes written 'f^*'
09:11:46 <Botje> :t fmap
09:11:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:12:09 <cjeris> so the Kleisli category is what ordinary Haskell monadic programming takes place in ?
09:12:11 <ski_> also 'ma >>= f' is sometimes written 'f * ma' (at least in some FP papers)
09:12:19 <ski_> cjeris : yes
09:12:39 <ski_> (one kleisli category for each monad over the basic category)
09:12:47 <cjeris> "The Kleisli category is all around you.  You can feel it as you go to work."
09:12:48 <Saizan> from the POV where the side effects are hidden?
09:13:17 <ski_> yes .. from the POV where the effects occur on the *side*
09:13:25 <quicksilver> cjeris: except, not really. because haskell types don't really form a category
09:13:35 <quicksilver> cjeris: but, that's the picture we like to paint, anyway
09:13:39 <DRMacIver> quicksilver: Why not?
09:13:45 <quicksilver> _|_
09:13:50 <ski_> (this isn't visible in the usual category theoretic language with compositions, etc, though)
09:14:09 <DRMacIver> quicksilver: I don't follow how that prevents them from forming a category.
09:14:18 <quicksilver> DRMacIver: haskell types aren't cartesian closed
09:14:20 <ski_> quicksilver : why would that hinder it from being a category ?
09:14:35 <quicksilver> DRMacIver: because (_|_,_|_) is different from _|_
09:14:58 <quicksilver> so (,) isn't quite a product
09:15:05 <ski_> so ?
09:15:09 <DRMacIver> quicksilver: Well that doesn't stop them being a category...
09:15:09 <quicksilver> and similarly (->) isn't quite a closure
09:15:15 <cjeris> quicksilver: so you can't just declare that each type is pointed at the bottom, because actually each type may have infinitely-many bottom points?
09:15:38 <ski_> no, each domain has one bottom
09:15:52 <ski_> _|_  =<  (_|_,_|_)
09:16:07 <quicksilver> and various of the monad laws are only true 'up to _|_'
09:16:14 <quicksilver> rather than being absolutely true
09:16:21 <quicksilver> which they'd be if this was a real monad
09:16:49 <ski_> hm .. the only instance of that i can bring to mind is because of 'seq' .. which we all know is suspicious
09:17:15 <quicksilver> well, if you remove seq then you can't 'observe' _|_ in the same way
09:17:32 <quicksilver> and then the moand laws become true 'up to observational equivalence' or something
09:17:40 <quicksilver> (which is still not the same as true)
09:18:05 <quicksilver> I am not qualified to explain the details, but it's been gone over a number of times in the cafe :)
09:18:16 * ski_ nods
09:19:03 * cjeris starts pawing through mailing list archives
09:19:08 <cjeris> thanks, quicksilver, ski_
09:21:15 <quicksilver> ah, that's right
09:21:19 <quicksilver> the worse problem is with id
09:21:34 <quicksilver> _|_ . id  =/= _|_
09:21:45 <quicksilver> so hask isn't a category at all
09:21:56 <quicksilver> it doesn't even satisfy the basic axioms
09:22:16 <DRMacIver> Hm. Dont' you mean id . _|_ =/= id ?
09:22:31 * HairyDude finally decides to bodge it by telling it not to typeset pragmas at all
09:23:22 <quicksilver> DRMacIver: no, it's the identity law
09:23:25 <edwardk> byorgey: just read your earlier question re fix and curry-howard, 'fix' is a logical fallacy called assuming the hypothesis. it enables recursion, so its useful as a programming tool, but not useful in a curry-howard logical sense. the existence of bottom says that every type is inhabited, so all things are provable in Haskell-the-logic.
09:23:48 <quicksilver> DRMacIver: the identity law says that x . id == x for all functions x
09:24:03 <quicksilver> DRMacIver: however it failes on the function _|_
09:24:32 <ski_> > undefined . id $ ()
09:24:33 <lambdabot>  Undefined
09:24:56 <quicksilver> > (undefined . id) `seq` ()
09:24:58 <lambdabot>  ()
09:25:03 <quicksilver> > undefined `seq` ()
09:25:03 <DRMacIver> quicksilver: Err, yes. I was being a moron. Beg pardon.
09:25:05 <lambdabot>  Undefined
09:25:07 <byorgey> edwardk: that makes a lot of sense, thanks!
09:25:12 <ski_> no, 'seq' is cheating ! ;)
09:25:15 <quicksilver> cjeris: thread starts http://www.haskell.org/pipermail/haskell-cafe/2007-January/021375.html
09:25:17 <lambdabot> Title: [Haskell-cafe] Article review: Category Theory, http://tinyurl.com/2gvddn
09:25:18 <cjeris> quicksilver: but forall t, forall x:t, _|_ . id $ x = _|_ $ x, right, so it's true extensionally ... that doesn't help?
09:25:20 <HairyDude> I'm manually doing the typesetting by repeating it
09:25:29 <DRMacIver> quicksilver: Although it's still not clear ot me why _|_ . id /= _|_
09:25:32 <quicksilver> cjeris: debate begins on http://www.haskell.org/pipermail/haskell-cafe/2007-January/021426.html
09:25:34 <lambdabot> Title: [Haskell-cafe] Article review: Category Theory, http://tinyurl.com/2znp5p
09:25:42 <quicksilver> DRMacIver: read the second link (and following comments)
09:26:04 <edwardk> byorgey: no problem
09:26:13 <ski_> (also, in the presence of 'seq', 'undefined' and '\x -> undefined x' is distinguishable)
09:26:16 <quicksilver> ski_, cjeris : I have a lot of sympathy for the view 'seq is cheating' and also the view 'extensionally true ought to be enough', however the theory isn't so simple
09:28:33 <cjeris> quicksilver: having spent the past couple months hacking Coq I have no problem with a system where equality is intensional :D  I just don't see why the category by which we represent Haskell types can't use extensional equality for morphisms.
09:29:00 <quicksilver> because it's undecidable, I suppose
09:29:01 <mattam> ski_: and that is bad because... ?
09:29:06 <quicksilver> but I'm not sure :)
09:29:08 <quicksilver> this is out of my depth
09:29:12 <quicksilver> which is why I referred you...
09:29:31 <ski_> (mattam : well, one might want eta-conversion to hold)
09:29:53 <cjeris> ok, reading now.  thanks for the pointers!
09:31:13 <mattam> I see
09:31:51 <edwardk> this is why i think seq should pollute the type ;)
09:32:39 <edwardk> then wadler's free theorems work anywhere the pollution is missing
09:33:39 <quicksilver> ski_: and, in fact, certain GHC optimisations 'rely' on the faithfulness of transformations which are in fact, not faithful, I believe
09:33:50 <ski_> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021484.html
09:33:52 <lambdabot> Title: [Haskell-cafe] Re: Article review: Category Theory, http://tinyurl.com/25ujgq
09:33:59 <quicksilver> ski_: however, I don't think it is ever semantically *harmful*, but it can be semantically different, in some cases
09:34:19 <quicksilver> typically in the sense of diverging a little sooner or later than it otherwise would
09:34:22 <quicksilver> if I understand it right
09:34:42 <ski_> well, i think it could possibly make a terminating program not terminate under another implementation, or under different compiler options
09:35:50 <quicksilver> I don't think any program, which is guaranteed by the semantics of haskell98 to terminate, will be transformed into a non-terminating one
09:36:15 <quicksilver> I could believe that some programs which, under haskell98 would diverge, but a particular implementation doesn't diverge on, might diverge...
09:36:26 <quicksilver> but, heck, I don't actually know :)
09:36:34 <ski_> "This solution was used in the first place.  But then some people were too lazy to actually use the Eval (as Seq was called) class, so they wanted a polymorphic seq."
09:36:38 <ski_> "And so we're in this mess.  And it is a mess, e.g., the foldr/build transformation ghc uses to fuse list processingisn't really valid when you have seq. -- Lennart"
09:36:50 * quicksilver nods
09:36:58 <quicksilver> that comment was undoubtedly lodged at the back of my mind
09:37:07 <sjanssen> I don't think there are many cases where GHC turns _|_ to not _|_
09:37:16 <quicksilver> any sensible comments I made were stolen from Lennart, or someone called Simon
09:37:17 <sjanssen> foldr/build is the only one I can think of
09:37:22 <quicksilver> and ridiculous things I said are all my own
09:38:12 <sjanssen> and foldr/build isn't really an innate compiler thing -- it's a buggy RULE
09:40:25 <ski_> hm .. one could maybe have bang-patterns only bring in the 'Eval' context only if polymorphically used ..
09:41:56 <sjanssen> ski_: you're trying to eliminate seq from the language?
09:42:37 <ski_> just a thought, should one go back to the previous state of affairs with a type class 'Eval'
09:42:46 <sjanssen> yeah
09:43:04 <sjanssen> I'd treat Eval patterns the same as Num constant patterns
09:43:32 <sjanssen> !x means 'Eval <type of x> =>'
09:43:42 * ski_ doesn't recall the details of how 'Num' literal patterns work
09:43:45 <sjanssen> let the compiler simplify it when x is monomorphic
09:43:58 <ski_> right, omit known instances
09:44:22 <sjanssen> f k = ... translates to f x | x == fromInteger k = ...
09:44:33 <ski_> ok
09:44:40 <sjanssen> I can't remember, is a guard desugaring valid for bang patterns?
09:45:13 <sjanssen> f !x = ... ===> f x | x `seq` True = ...
09:45:41 <sjanssen> hmm, not quite I guess
09:45:49 <ski_> not sure .. i assume the notes on bang-patterns explain possible translation
09:46:03 <fasta> What does $f1 mean in a profile report?
09:46:31 <chessguy> 1 french dollar
09:52:00 <olsner> lambda calculus truly is write-only code
09:52:59 <takamura> hi
09:54:19 <sjanssen> @seen Igloo
09:54:20 <lambdabot> Igloo is in #happs, #haskell-overflow, #darcs, #ghc and #haskell. I last heard Igloo speak 27m 4s ago.
09:54:27 <Igloo> hi
09:55:48 <sjanssen> I'm wondering about getting X11-1.2.1 into hackage.  However, the Setup.hs doesn't work with Cabal-1.1.6.1
09:56:13 <sjanssen> incorrect type signatures -- it works after deleting them
09:56:39 <Igloo> Right, 1.2.2 wants to be released if you want to update what's in Hackage
09:57:10 <joakim__> hi
09:57:24 <joakim__> just started with some haskell coding
09:57:25 <sjanssen> Igloo: so you're saying bump the version tag, then release it?
09:57:27 <takamura> someone here uses hsql on windows?
09:58:00 <Igloo> sjanssen: Yup. I have a mail from dons about it, but feel free to do it if you want. Don't forget to tag it if you do
09:58:04 <joakim__> and have come to declarations of variables. in files, you can't do:
09:58:06 <joakim__> r = 2
09:58:09 <joakim__> r = 4
09:58:25 <joakim__> but how can you give variables a new value?
09:58:38 <Igloo> What are you trying to do?
09:58:56 <joakim__> nothing, just wondering
09:59:08 <joakim__> say if i want tp give r a new value
09:59:08 <Igloo> Well, the simple answer is "you can't"
09:59:26 <Igloo> The longer answer depends on what you want to do
09:59:32 <joakim__> but i can't, because i get an error
10:00:09 <takamura> usually you dont need to change the values of variables
10:00:23 <joakim__> oh, i see
10:00:43 <joakim__> i have never touched functional languages before :/
10:00:48 <takamura> only between interfacing with imperative languaes, etc. you need them
10:00:57 <joakim__> ah
10:01:20 <cdsmith> joakim: yep, this is when you have to really start understanding functional programming.  If you pick something to want to do, then we could demonstrate how to do it without changing variables.
10:01:21 <takamura> what have you read about haskell? some tutorial?
10:01:40 <joakim__> reading the wiki
10:03:54 <takamura> maybe this is a good place to start: http://www.haskell.org/tutorial/
10:03:55 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
10:03:58 <byorgey> joakim__: also, since no one else has said it yet, welcome! =)
10:04:04 <dolio> Heh.
10:04:16 <takamura> yes, welcome :D
10:04:22 <sjanssen> Igloo: and I can just push these patches to d.h.o:/home/darcs/packages/X11?
10:04:22 <joakim__> thanks :)
10:04:34 <Igloo> sjanssen: Yes
10:05:03 <cdsmith> takamura: I've never found the "gentle" introduction all that gentle, actually, for anyone new to functional programming. :)  Perhaps other sources are better.
10:05:24 <joakim__> i'll take a look
10:05:44 <takamura> mmm maybe I find it gentle because I didnt much imperative programming before
10:05:57 <takamura> or because I have a math background
10:06:05 <cdsmith> Perhaps.  I flat out says in the introduction that it assumes functional programming experience.
10:06:15 <joakim__> the reason i have chosen haskell, is that i'm interested in compiler theory and stuff like that. have written one in c once
10:06:35 <joakim__> heard haskell was a nice language to implement compilers in ...
10:06:58 <cdsmith> joakim: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf might be more up your alley.
10:07:57 * rotbit finds yaht "gentler"
10:08:19 <joakim__> ill check it out
10:08:28 <rotbit> but I'm only on day three ;)
10:09:52 <joakim__> i think i will go on with yaht
10:10:06 <joakim__> just skip the first two chapters
10:10:44 <cdsmith> joakim: right, yaht really starts in chapter 3. :)
10:11:50 <Dot> @lambda (fn x -> x ) "a"
10:11:50 <lambdabot>  fd:25: hClose: resource vanished (Broken pipe)
10:11:56 <joakim__> brb
10:12:29 <cdsmith> @help lambda
10:12:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:12:42 <cdsmith> huh?
10:12:47 <cdsmith> @help lambda
10:12:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:12:50 <cdsmith> Hmm.
10:13:10 <takamura> @help \
10:13:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:13:36 <ddarius> olsner: Do you consider Haskell a write only language?
10:16:27 <dolio> Haskell has some niceties over the lambda calculus, depending on how much you restrict yourself with the latter.
10:17:32 <ddarius> Merely allowing the non-recursive naming of lambda terms (and even that can be simulated) you can catch a whole lot of nicety.
10:17:57 <dolio> Yeah. Naming is what I was thinking of.
10:18:26 <joakim__> i don't feel very comfortable while programming under windows :/
10:18:39 <takamura> me too :S
10:18:57 <takamura> but i need the money :(
10:19:00 <joakim__> upgraded ubuntu here one day, and it crashed
10:19:11 <takamura> oh
10:19:14 <joakim__> i have dual-boot
10:19:25 <joakim__> for the playing part
10:19:26 <takamura> i use debian and never crashed in 4 yr
10:19:40 <joakim__> i play WoW :/
10:20:36 <thoughtpolice> i never got the big hype about WoW; but I never really have been an MMO person
10:21:02 <joakim__> i'm kinda addicted
10:21:17 <fbuilesv> Has anyone worked with Gtk2HS and GtkImages?
10:21:45 <fbuilesv> Still trying to find out if it supports PNG files
10:22:20 <thoughtpolice> joakim__: my sister bought me it for my birthday, so I was obligated to play it a couple times (private servers.) maybe a public server account would change my mind.
10:22:46 <joakim__> i see
10:23:40 <takamura> fbuilesv, search the api: http://haskell.org/hoogle/?package=gtk&q=png
10:23:41 <lambdabot> Title: png - Hoogle
10:24:57 <fbuilesv> takamura,: Thank you, didn't know that doc :D
10:25:20 <joakim__> do yaht cover side-effects and stuff?
10:25:28 <takamura> you can search it from the home page of gtk2hs
10:25:28 <joakim__> i haven't really got that yet
10:26:41 <cdsmith> joakim: I'm unclear on what you're looking for, exactly.
10:27:36 <takamura> joakim__, im curious, what lang want you to write a compiler for?
10:28:01 <Apocalisp> osfameron: http://apocalisp.wordpress.com
10:28:03 <lambdabot> Title: Lambdakjöt
10:28:09 <joakim__> haven't thinked about that, really
10:28:31 <joakim__> i'm just very interested in compiler theory, techniques and stuff :/
10:28:49 <joakim__> and some day implement one for the experience
10:28:59 <joakim__> but never thought anything more than that
10:33:00 <kosmikus> HairyDude: please send a minimal document causing that bug
10:33:26 <HairyDude> kosmikus: the "_ in pragma" bug?
10:35:20 <HairyDude> kosmikus: or the "fromJust: Nothing" bug?
10:35:40 <kosmikus> the "fromJust: Nothing" bug
10:36:09 <HairyDude> right
10:39:10 <joakim__> the wiki tutorial, someone read it?
10:40:30 <fasta> joakim__: yes
10:40:36 <takamura> what tutorial?
10:40:36 <dozer> hoogle is linking to docs that are not very helpful
10:40:57 <dozer> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html#v%3AevalState
10:40:59 <lambdabot> http://tinyurl.com/yy4aqu
10:41:19 <joakim__> http://en.wikibooks.org/wiki/Haskell
10:41:20 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
10:41:48 <takamura> ah, i read some chapters
10:42:08 <takamura> but not the beginning chapters :/
10:42:09 <joakim__> i originally started reading that one
10:43:05 <joakim__> shall i continue with it, or stop, and start reading in yaht instead?
10:43:51 <cdsmith> joakim__: either should work.  I like YAHT better, but that's as much personal preference as anything.
10:44:03 <joakim__> k
10:44:04 <HairyDude> kosmikus: ok, emailed
10:45:05 <takamura> joakim__, I dont know, the part I read was not for begginers.
10:45:21 <joakim__> hmm, ok
10:48:02 <takamura> for me, http://www.math.chalmers.se/~rjmh/Papers/whyfp.html was a good introduction to functional programming in general (not only haskell), but maybe is a little difficult
10:48:04 <lambdabot> Title: Why Functional Programming Matters
10:51:05 <nomeata> strange. I have two threads, and an IO error in once causes the program to halt, although it runs within catch.
10:51:13 <ski_> @quote functional
10:51:13 <lambdabot> Pseudonym says: Why be skeptical about Wikipedia?  If it wasn't for that, I wouldn't know that functional programming was developed by **ERIC IS GAY**.
10:51:23 <ski_> @quote functional
10:51:24 <lambdabot> MyCatVerbs says: almost all powerful functional languages have awesome REPL banners. Hell, even GNU clisp has that awesome ASCII menorah
10:51:40 <nomeata> If I add another catch a bit further in my rescursive stuff, I can actually handle the one IO error, but the other thread still exists
10:51:58 <nomeata> (well, the main thread exists, or the whole program, who knows)
10:52:26 <takamura> @quote haskell
10:52:26 <lambdabot> procyon112 says: Haskell is part of the right wing conspiracy to make gay marriage not only illegal, but not type safe!
10:53:12 * ski_ raises eyebrows
10:55:20 <ski_> @quote terminal
10:55:21 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
10:55:21 <lambdabot> object in the category of religions and theomorphisms.
10:55:31 <ski_> :D
10:56:02 <takamura> @quote cons
10:56:02 <lambdabot> ghc says: All of the type variables in the constraint are already in scope (at least one must be universally quantified here)
10:56:19 <takamura> @quote fold
10:56:19 <lambdabot> dmwit says: > let foldb' op (x:y:rest) = op x y : foldb' op rest; foldb' _ e = e; foldb _ b [] = b; foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs) in foldb (*) 1 [1..1000] --
10:56:19 <lambdabot> here we go
10:56:30 <kilimanjaro> quote lambdabot
10:56:37 <kilimanjaro> woops
10:56:46 <kilimanjaro> @quote lambdabot
10:56:46 <lambdabot> lambdabot says: I know nothing about comprehending.
10:56:57 <takamura> @quote monad
10:56:57 <lambdabot> inv2004 says: lambdabot: monads ?
10:57:12 <dmwit> ?quote!
10:57:12 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
10:57:28 <nomeata> If I wrap "handle (\e -> print e) $" before all code, and the program still terminates unexpectedly, is that a bug?
10:57:30 <ski_> @vixen Are you sure you can't comprehend list comprehensions?
10:57:31 <lambdabot> <undefined>
10:57:40 <nomeata> (A ghc bug)
10:58:09 <takamura> @quote bug
10:58:10 <lambdabot> dons says: disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
10:58:12 <ski_> (nomeata : sorry, dunno)
10:59:46 <takamura> nomeata, a bug of the program or the compiler?
11:00:47 <takamura> its not an error of the compiler, i think
11:01:30 <Apocalisp> @quote debug
11:01:30 <lambdabot> lennart says:  I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
11:01:30 <lambdabot> useful for functional code
11:01:44 <nomeata> takamura: so what can make the program terminate that is not cought by Control.Exception’s handle?
11:04:13 <sjanssen> nomeata: unhandled signal, for one
11:04:44 <nomeata> that rings a bell... SIGPIPE
11:07:22 <takamura> also, if you dont handle the signal properly, the program halts. Say you are trying to open a file, and it doesnt exists, if the handler only prints the exception, program execution cant continue, because the function that was executing needed that file contents, say
11:07:50 <takamura> sorry my poor english
11:08:31 <takamura> @quote handle
11:08:31 <lambdabot> ex0r says: if map was a woman she could probably handle infinite arguments
11:08:45 <takamura> @quote catch
11:08:45 <lambdabot> syntaxfree says: "You can't catch me / I'm syntax free / I'm preconceived / preternaturally"
11:08:58 <takamura> @quote exception
11:08:58 <lambdabot> blackdog says: i think coding in your sleep should trigger an exception
11:10:10 <nomeata> 	installHandler sigPIPE Ignore Nothing
11:10:10 <nomeata>  seems to solve it
11:24:18 * sjanssen wants a Reduceron
11:26:57 <Vulpyne_> I have a fairly simple function (B is Data.ByteString.Lazy.Char8): bylines s | (length bylines') > 4 = Just bylines' | otherwise = Nothing where bylines' = B.lines $ B.filter (/= '\r') s
11:27:26 <Vulpyne_> If it's used to split up a string with consecutive blank lines, those lines are eliminated. Is that something to do with working with Maybe?
11:34:03 <EvilTerran> it's more likely to be a feature of B.lines
11:34:45 <EvilTerran> waitaminute. what exactly are you trying to do?
11:36:58 <Vulpyne> EvilTerran: I found the problem, it's that ByteString.lines drops blank lines. :)
11:37:10 <EvilTerran> i thought that sounded likely
11:37:25 <Vulpyne> I thought I was using it before and it didn't, but guess I was wrong.
11:37:34 <Vulpyne> So ByteString.split instead.
11:38:37 <nomeata> Vulpyne: oh, I bit that two. I think I filed a bug report
11:39:26 <nomeata> (Or I thought so)
11:40:08 <nomeata> first hit when you google for "haskell bytestring bug": [GHC] #1375: ByteString’s “lines” eats empty lines
11:40:25 <nomeata> oh, actually my mail... (/me is confused)
11:41:25 <nomeata> http://hackage.haskell.org/trac/ghc/ticket/1375
11:41:27 <lambdabot> Title: #1375 (ByteString’s “lines” eats empty lines) - GHC - Trac
11:45:19 <Vulpyne> Ah... Is it a bug, or a feature? :)
11:45:40 <jfredett> log(x)*log(y) == log(x+y), right?
11:45:50 <jfredett> i haven't fiddled with logarithms in so long
11:46:01 <jfredett> i can't remember...
11:46:31 <nomeata> other way around
11:46:42 <nomeata> log (x·y) = log x + log y
11:46:47 <nomeata> remember: log 1 = 0
11:46:48 <jfredett> ahh, brilliant
11:46:55 <jfredett> that makes my life tougher
11:47:17 <jfredett> i'm trying to implement AKS, and for that I need a perfectpower predicate
11:47:40 <jfredett> i was hoping log(x+y) -> log(x) log(y)
11:47:46 <jfredett> because then the whole op is trivial
11:48:48 <nomeata> e(x+y) = e^x · e^y if that helps
11:49:02 <jfredett> yah
11:49:16 <nomeata> Vulpyne: probably a bug, as the implementation varies between Lazy and non-Lazy
11:49:37 <jfredett> hmm, now i just need to find a good perfect power algorithm... :/
11:50:10 <dolio> You might generally want (unlines . lines) == id, too, which it isn't if you discard empty lines.
11:50:19 <hpaste>  Excedrin pasted "50 line webserver" at http://hpaste.org/118
11:50:41 <Excedrin> I'm going to post that as a comment in the reddit thread about the 50 line python "server"
11:50:47 <dolio> Then again, I suppose (unwords . words) /= id.
11:51:47 <nomeata> dolio: ignoreing the possibly missing last newline
11:51:58 <nomeata> > (unlines. lines) "noendofline"
11:51:59 <lambdabot>  "noendofline\n"
11:52:12 <dolio> Ah, there's that, too.
11:52:31 <nomeata> but besides that, I’d expect (unlines. lines)
11:52:48 <nomeata> last str == '\n' ===> (unlines. lines) str = str
11:52:50 <nomeata> > last str == '\n' ===> (unlines. lines) str = str
11:52:50 <lambdabot>  Parse error
11:53:04 <nomeata> @help quickcheck
11:53:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:53:20 <dolio> I guess it all depends on what you're using it for. But it's easier to filter out empty lines than it is to add them back in.
11:53:35 <kosmikus> everyone: a prerelease of the HCAR is available at haskell.org/communities/05-2007/report.pdf -- it might yet be possible to prevent the worst mistakes I made going fully public by telling me within the next 30 minutes
11:56:37 <nomeata> @check \str -> (unlines. lines) (str++"\n") == (str++"\n")
11:56:38 <lambdabot>  OK, passed 500 tests.
11:57:10 <Heffalump> I've looked at the beginning and the entry I submitted and not spotted any obvious problems with either.
11:57:55 <kosmikus> Heffalump: thanks
11:58:59 <Excedrin> http://programming.reddit.com/info/1uhge/comments
11:59:00 <lambdabot> Title: Roll your own server in 50 lines of code (reddit.com)
11:59:27 <dpiponi> You know when the Prelude is broken when...
11:59:45 <dpiponi> ...you find yourself writing the line "instance Floating Fixed where"
11:59:57 <Igloo> :-)
12:00:09 <dolio> Heh.
12:00:27 <dpiponi> What does sin/cos/atan etc. have to do with 'floating'?
12:00:35 <roconnor> dpiponi: I have instance Floating CReal where
12:00:46 <dpiponi> What's CReal?
12:00:52 <roconnor> Constructive Reals
12:01:01 <dpiponi> Very silly!
12:01:04 <roconnor> or Cauchy Reals
12:01:07 <roconnor> or Computable Reals
12:01:09 <roconnor> I'm not sure which
12:01:30 <MyCatVerbs> roconnor: obviously nothing to do with the C programming language, right? ;)
12:01:49 <dpiponi> Just curious...anyone know how this part of the Prelude got written?
12:02:01 <roconnor> MyCatVerbs: It's a wrapper for the primitive C real number type :P
12:02:06 * olsner_ bets on the keyboard
12:03:22 <MyCatVerbs> roconnor: dude, ";)" on the end of a line usually indicates blatant sarcasm.
12:03:40 <roconnor> MyCatVerbs: that's why I added a :P to my response
12:04:13 <dr_strangelove> I an error message from the happy parser generator: Couldn't match expected type `Token -> HappyIdentity a'
12:04:35 <dr_strangelove> any ideas?
12:04:36 <MyCatVerbs> roconnor: and don't gimme any of that "sarcasm is the lowest form of wit" bullshit. It's trivially refuted like so: "I presume you've not yet become acquainted with fart jokes, then?"
12:05:03 <dr_strangelove> message goes on: against inferred type `HappyIdentity (t -> [Token] -> a1)'
12:05:13 <dr_strangelove> what is HappyIdentity?
12:05:31 <roconnor> I'm surprised people are still using Happy.
12:05:40 <roconnor> interesting
12:05:56 <roconnor> dr_strangelove: 'fraid I don't know anything about Happy :(
12:06:05 <dr_strangelove> roconnor: why surprised?
12:06:16 <dr_strangelove> what's the alternative?
12:06:17 <roconnor> dr_strangelove: I figured most people would use Parsec.
12:06:39 <dr_strangelove> but parsec is a recursive-descent parser, no?
12:07:03 <roconnor> although Parsec is possible slower, I would imagine the ease of programming outweight the possible loss of speed.
12:07:20 <roconnor> possibly
12:07:39 <dr_strangelove> but you have to eliminate left-recursion
12:07:50 <olsner_> dr_strangelove: check out frisby, PolyParse and Parsec.. I found polyparse slightly nicer to work with than the other two
12:08:27 <olsner_> and left-recursion elimination isn't that hard
12:08:28 <roconnor> dr_strangelove: Hmmm,
12:09:51 <roconnor> dr_strangelove: I see you are right, Parsec works best on LL grammars rather than LR grammars
12:18:10 <dr_strangelove> is there a parser generator that uses template haskell?
12:18:29 <dr_strangelove> like boost.spirit for c++?
12:19:47 <SudoBash> how easy is haskell?
12:20:15 <Saizan> SudoBash: what's you background?
12:20:17 <sjanssen> SudoBash: there are easy things, and there are hard things
12:20:48 <sjanssen> SudoBash: if it helps, there are universities that teach Haskell to first semester computer science students
12:21:22 <Procyon112> SudoBash: It has a steep learning curve, particularly if you have never done functional programming or HM Typed programming.  I find actuall programming in Haskell easier than most languages because of the excellent abstractions available.
12:21:48 <MyCatVerbs> SudoBash: ever tried template metaprogramming in C++? If so, you'll find it absolutely rocksucking piss easy and you'll love it from start to end. :)
12:21:51 <Procyon112> SudoBash: But it's a bit of a pain to get up to speed in the language.
12:22:01 <njbartlett> Haskell is perhaps harder to learn in the first instance. But when you're 2 years into a project, with a million lines of Java or VB code to maintain, I'd challenge anybody to claim that Java or VB are easier than Haskell...
12:22:06 <Procyon112> MyCatVerbs: haha.  very true
12:23:34 <MyCatVerbs> Procyon112: I never got much into it, but I have a subdirectory somewhere around here with a handful of trivial things in it - a prime number filters, fibonacci and factorial implementations...
12:23:35 <SudoBash> i know some c, a little less c++, a little bit of a few types of assembly.. I know VB sucks cause ive used it and hate it.... im the best at AVR C
12:24:19 <MyCatVerbs> Procyon112: after that, FP in Haskell seemed rather natural, y'know? But I think it actually taught me more about state machines than FP for some reason.
12:24:22 <njbartlett> Actually VB won't suck for much longer. There's a Haskell guru working on it these days :-)
12:24:53 <MyCatVerbs> SudoBash: right. Haskell is going to be rather difficult and evil. It's fundamentally quite different to every programming language you've ever tried before.
12:25:04 <Procyon112> SudoBash: You are coming from the exact opposite paradigm from Haskell then.  I rcommend the book "Haskell: The Craft of Functional Programming".  It's the easiest introduction to Haskell for an imperative programmer.
12:25:25 <newsham_> ?seen glguy
12:25:25 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
12:25:46 <ski_> @where yaht
12:25:46 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
12:26:00 <ski_> you might want to try ^^ tutorial, too
12:26:14 <MyCatVerbs> ski_: yaht is kinda holey, though. :/
12:26:32 <Procyon112> MyCatVerbs: Learning Haskell taught me that Template Hacking in C++ is actually pretty easy in concept... it's just that the syntax is the absolute worst imaginable.
12:26:34 <SudoBash> what can haskell do the best?
12:26:40 <geezusfreeek> i'd say that just because of the academic and ever-changing nature of functional programming, nobody really knows haskell 100%
12:26:45 * ski_ wouldn't know as he's never actually read it fully .. :)
12:26:51 <MyCatVerbs> Procyon112: heh.
12:27:10 <MyCatVerbs> Procyon112: thing is, I attacked template programming with basically no conceptions of how to actually do it.
12:27:25 <Modius> Other than being different to the "mainstream" programming, what did you find about C++ templates that was similar to Haskell?
12:27:31 <MyCatVerbs> Procyon112: so I ended up bashing my brains out and really thrashing the topic out as a result.
12:28:27 <MyCatVerbs> Procyon112: it was so damn cool - fun, even - at the time, though. I think that figuring it out the dumbass way, from close to first principles, actually taught me rather more than learning it by sane methods. ^^
12:28:31 <Modius> I retract the quesiton - guessing you meant easier, not similar.
12:28:40 <geezusfreeek> SudoBash: that is a difficult question to answer, and different people might claim that haskell is best for different things.
12:28:54 <geezusfreeek> that is really just speculation on my part though
12:29:11 <Procyon112> Modius: C++ templates are 1) Parametric Polymorphism when used as originally intended... something that C++ programmers typically don't learn until the "advanced" stages, but is done by default in Haskell, and 2) Template Metaprogramming is typically just recursive algorithms, which are never done in C++, but in Haskell is used for everything.
12:30:15 <Procyon112> Modius: Also, C++ templates are lazily evaluated, which is weird for a C++ programmer, but after learning Haskell it's pretty natural.
12:30:39 <Modius> Procyon: Understood.  Ehheh, I remember implementing some recursive matrix operation in C++ templates and having to provide a Max-based termination case :)
12:30:42 <geezusfreeek> SudoBash: if you want an extremely fresh look at what programming can be like (and believe me, the water feels great), haskell might be good for you to try
12:32:00 <Procyon112> SudoBash: The biggest win for Haskell, IMHO, where no language comes close ion ease of use is in the creation of Parsers and Domain Specific Languages.  But it's a generic language and good for most anything save maybe low-level bit twiddling (where C excels)
12:32:04 <dpiponi> I did implement a little SKI combinator library as a C++ template metaprogram.
12:32:59 <sjanssen> SudoBash: historically, Haskell has been very good at compilers and interpreters (see GHC, Pugs, etc.)
12:33:14 <geezusfreeek> well, i wouldn't much want to bash out quick little scripts in haskell, myself, but for anything larger it's pretty nice
12:33:20 <Procyon112> dpiponi: That sounds pretty cool actually.  I've been meaning to see what VC++ and gcc do when I implement the Y combinator tail recursively and send te compiler into an infinite loop.
12:33:43 <sjanssen> SudoBash: however, it is a general programming language.  See darcs and xmonad for examples of more 'concrete' programming
12:41:46 <SudoBash> thanks
12:44:20 <dpiponi> Procyon112: http://homepage.mac.com/sigfpe/Computing/sk.html
12:44:43 <dpiponi> Procyon112: I've been meaning to take that web page down because I think it says somethings that aren't true
12:45:25 <dpiponi> Procyon112: Lazy evaluation was new to me at the time I wrote that and I may have been confused about how lazy C++ template evaluation is. (And I'm more confused now having not done that kind fo coding for ages...)
12:51:54 <Procyon112> dpiponi: interesting.. I would have expected it to take more code.
12:52:32 <augustss_> mmmmm, weird template programming :)
12:52:43 <dpiponi> Procyon112: I did try to pick the simplest system possible. And it is just a basic rewrite system. But, as I warn, it might not really work.
12:53:14 <dpiponi> Well, I think it works, I'm just not sure of theorder of evaluation
12:53:51 <augustss_> well, there's no prescribed order for SK
12:54:30 <dpiponi> But if it's not completely lazy you might get things failing to terminate when they should
12:56:11 <augustss_> it all depends on what you think should terminate. :)  the inventors of combinatory calculus were open to different evaluation orders
12:57:19 <dpiponi> I had this crazy idea of writing a compiler for SASL as a template metaprogram. But the template evaluation times started growing out of control.
12:58:29 <olsner_> I made a lisp in templates once
12:58:41 <olsner_> cons<LAMBDA, .....
12:59:08 <dpiponi> I made numbers in templates once... http://homepage.mac.com/sigfpe/Computing/peano.html
12:59:21 <olsner_> etc etc.. big, ugly and afaict turing complete
12:59:46 <Excedrin> I made something like Binary in templates once
12:59:52 <Modius> Has anyone here used Haskell (e.g. pure functional) - with, how should I put it - teams that include bored disinterested low IQ low skilled programmers?  Does Haskell with its uncompromising paradigm (which don't get me wrong, is a strength) have an ability cutoff higher than some other languages?
13:00:42 <olsner_> single-combinator combinatory calculus is nice though... you only need parantheses - no actual operators ;-)
13:00:43 <centrinia> Modius, myself and I are bored and disinterested. Me is the only skilled programmer in the team. :(
13:01:05 <emu> just me myself and I
13:01:52 <Modius> I'm trying to work out if functional style solutions are "harder" due to legacy of people using languages built up from assembly languages, or if they reflect, all else being equal, an objectively higher barrier to entry.
13:02:12 <centrinia> Olsner, our Math Analysis course developed analysis from set theory.
13:02:37 <centrinia> It is kind of like having parentheses containing parentheses, containing more parentheses.
13:02:51 <olsner_> centrinia: bah, analysis? that's *math*! ewwww
13:03:10 <olsner_> was it turing complete?
13:03:18 <centrinia> It doesn't compute.
13:03:19 <dpiponi> 0 = {}, 1 = {{}}, 2 = {{},{{}}} etc.
13:03:27 <centrinia> Yeah, exactly.
13:03:33 <emu> that's ordinals
13:04:05 <dpiponi> They'll do as representatives for the cardinals too
13:04:08 <centrinia> You can then set {a,b} = {c,d} if a +c = b + d
13:04:10 <emu> er yea
13:04:13 <centrinia> That's the integers.
13:05:08 <Procyon112> Modius: I have not worked on such a team using functional programming, but were I to find myself in that possition, I would think the way to go about it would be to implement a DSL, do all the hard conceptual work myself, and have the team of code monkeys writing scripts in my DSL.
13:05:28 <Procyon112> Modius: In fact, that's pretty much what I do in C++ also.
13:05:31 <centrinia> Why do we still use set theory in schools to teach analysis? Why not use Category theory?
13:05:57 <dpiponi> Category theory doesn't give very good foundations for mathematics
13:06:01 <dpiponi> IMHO
13:06:06 <cinema> Igloo: I have a problem with ghc HEAD. When I do (for example) ghci -package ghc, I get ghc-6.7.20070517: /usr/local/lib/ghc-6.7.20070517/HSghc.o: unknown symbol `rts_stop_on_exception'
13:06:12 <ibid> because set theory is a foundational theory, and category theory isn't (except if you bend it just so)
13:06:19 <centrinia> But category theory is so non-paradoxical.
13:06:32 <cinema> Igloo: rts_stop_on_exception is defined in package rts
13:06:32 <Mitar> how could i define a type which could have only 0, 1, 2, 3 values, but would be compatible with Int?
13:06:54 <cinema> Igloo: so it looks like a dependency not correctly defined
13:06:55 <dpiponi> Every category theory book is full of caveats about Small categories etc. It's very easy to be led into paradox by category theory.
13:07:15 <emu> and set theory isn't? :P
13:07:16 <Igloo> cinema: Does running ghci with no package work?
13:07:16 <ibid> essentially, category theory works as a foundation only if you start playing with elementary toposes, which is just encoding logic and sets in category parlance, making stuff unnecessarily complex
13:07:18 <centrinia> Small categories are sets?
13:07:18 <Modius> Procyon:  Understood.  I think however it would cause concern that there are areas off-limits to the "monkey", i.e. that the monkey can't go fix something broken in the "Real" code.
13:07:20 <mauke> Mitar: what do you mean by "compatible"?
13:07:20 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
13:07:21 <EvilTerran> Mitar, data FourValues = Zero | One | Two | Three, then derive Num
13:07:24 <Saizan> data Four = Zero | One | Two | Three deriving (Enum)
13:07:37 <cinema> Igloo: yes. I have the same problem with ghc actually
13:07:43 <EvilTerran> Mitar, whups, delete "derive num" from that, it's wrong
13:07:47 <Mitar> so that for example fromIntegral would convert between them?
13:07:48 <Igloo> cinema: What OS/arch?
13:07:53 <cinema> Igloo: I found it trying to buil yi
13:07:59 <Mitar> or some other standard function ..
13:08:02 <cinema> Igloo: Linux IA32
13:08:02 <EvilTerran> i meant to say "instantiate Integral"
13:08:22 <Igloo> cinema: OK, not sure what the problem is then, and I can't test at the moment
13:08:37 <Mitar> so that i could say (4 `div` 2) :: Four
13:08:53 <ibid> centrinia: category theory is non-paradoxical only if you stay away from the paradoxes (which most non-foundational category theory does only barely)
13:08:53 <cinema> Igloo: I had it for a ceratin time. Just wanted to report it. Nothing urgent
13:08:56 <centrinia> Four is not a type methinks.
13:09:41 <olsner_> tautology ;-) "non-paradoxical only if you stay away from the paradoxes"
13:09:41 <centrinia> ibid, I should read up on more categorical paradoxes. :D
13:10:11 <EvilTerran> Mitar, it would very much be helpful to derive... probably everything derivable
13:10:13 <dpiponi> If you want to do analysis in a categorical framework you could try this stuff: http://en.wikipedia.org/wiki/Synthetic_differential_geometry
13:10:14 <Procyon112> Modius: For years I've done that exact same thing in C++ though.  Most developers don't write heavy templates, non-virtual destructors, multiinheritance classes, actually, most devs don't use inheritance at all (at least not properly).... I do all that.  The lower level devs write to the class interface I provide.  When they complain that "doing XYZ task is too hard", I create a new interface to do XYZ for them.
13:10:15 <lambdabot> Title: Synthetic differential geometry - Wikipedia, the free encyclopedia
13:10:17 <EvilTerran> definitely Ord, Eq, and Enum
13:10:32 <centrinia> Is there a paradox that embodies all paradoxes in such a way that it does not embody itself? :p
13:11:03 <ibid> centrinia: i've been writing for my own use notes on category theory. i've had to work very hard to avoid paradoxes when constructing the basic machinery. categories by themselves are okay, but how do you deal with functors between big categories?
13:11:14 <Saizan> Mitar: for literals to work you need to write an instance of Num
13:11:19 <EvilTerran> Mitar, with a derived instance of Enum, you could make heavy use of fromEnum and toEnum to make your maths work
13:11:21 <centrinia> ibid, how big?
13:11:32 <centrinia> Categories of categories?
13:11:34 <Modius> Procyon:  Been in that role myself (with other progs doing subimplementations) - I guess the problem is one of perception - a manager could assume that they could work in the rest of the code as it's all C++, even though in practice it was as greek as if in another language.
13:11:38 <Procyon112> Modius: The majority of team programming is scripting business rules... provide a DSL for that, be it in Haskell or C++ or whatever, and the devs don't need to know how to code :)
13:11:53 <ibid> centrinia: "big category" is a technical term referring to a category whose objects and arrows are too numerous to form a set
13:11:55 <Igloo> cinema: If it's been happening for a while then please file a bug report with any details you think might be relevant
13:12:04 <centrinia> Ah.
13:12:12 <ibid> centrinia: for example, the category Set is a big category
13:12:25 <EvilTerran> Mitar, do you see?
13:12:42 <centrinia> What about the category of all conglomerates? :D
13:12:46 <Mitar> yes ... i see something ...
13:12:50 <dpiponi> ibid: I have a hard time when I think about category size. Category theory books will just let everything that's too big to be a set be a 'class' and then use classes exactly like sets.
13:12:51 <Procyon112> Modius: and I would imagine that the manager would assume that the devs could all work in Haskell if they are efficiently using your provided Monads, ADTs, etc...
13:13:08 <EvilTerran> (i see lots of delicious offtopic, but there you go)
13:13:15 <HairyDude> is it possible to make lhs2TeX compute alignments across multiple code blocks? I have a long instance that I want to intersperse with comments while keeping the methods at the same indentation
13:13:20 <ibid> centrinia: well, that's squarely in the middle of set-theoretical paradox country. you *can* do it but it's not trivial
13:13:34 <Mitar> what happend if the value passed to toEnum is to large?
13:13:35 <dpiponi> It needs quite a bit of care (I think) to make sure you don't do impossible things with classes
13:13:40 <EvilTerran> Mitar, error
13:14:02 <Procyon112> Modius: But a Monad is going to look no more or less greek to a low level dev than a recursive template or a (proper) multi-inherited class.
13:14:07 <ibid> dpiponi: not really, most stuff you can do with sets you can do with classes
13:14:20 <Mitar> runtime?
13:14:22 <ibid> dpiponi: about the only thing you can't is form the power class, or anything that derives from it
13:14:24 <EvilTerran> yes
13:14:41 <ibid> dpiponi: unless you admit hyperclasses...
13:14:42 <EvilTerran> Mitar, you may want to implement Enum yourself if, for instance, you want modular arithmetic
13:14:54 <HairyDude> ah, it's documented in §8.8 of the Guide
13:15:06 <ibid> dpiponi: are you familiar with vNBG set thory? or the Moire-Kelley (?) set theory?
13:15:52 <EvilTerran> Mitar, http://haskell.org/onlinereport/derived.html describes the derived types
13:15:53 <lambdabot> Title: The Haskell 98 Report: Derived Instances
13:15:59 <EvilTerran> so you can pick and choose from there
13:15:59 <dpiponi> ibid: I've come across NBG but I could use more familiarity
13:16:45 <dpiponi> The (ZF) Set Theory textbooks I know don't formalise classes so the rules for manipulating them seem ad hoc.
13:17:03 <Mitar> thanks
13:17:18 <ibid> centrinia: the most natural way of defining categories is to start with "a category consists of a set of objects and a set of arrows ...", but that disqualifies big categories. you can do s/set/class/, but then you can't have functors between big categories...
13:17:38 <centrinia> Ah.
13:17:58 <Mitar> how can i iteratate over all values of a newly constructed enum data?
13:18:06 <Procyon112> Modius: I'm thinking the hardest thing for your basic, low-level C++ guy to come to terms with in Haskell, provided you give them a good DSL to do their work with, would be recursion, since that's the one foreign concept to them that it would be hard to break from in the framework you provide.
13:18:13 <EvilTerran> mit if you derive bounded
13:18:16 <int-e> > [minBound .. maxBound] :: [Bool]
13:18:24 <lambdabot>  [False,True]
13:18:24 <EvilTerran> Mitar, if you derive Bounded, what int-e said
13:18:36 <centrinia> Oh, funny idea: is a Turan cograph as trivial as I think it is?
13:18:48 <EvilTerran> otherwise, [first constructor .. last constructor] also works
13:18:50 <centrinia> That might be too off topic. :(
13:19:18 <ibid> dpiponi: the main idea is, take a first-order formula P.  then { x | P } denotes a class.  a class is a set if it is a member of some class; one class every set is a member of is { x | true }
13:19:47 <EvilTerran> @topic
13:19:47 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join todo type
13:19:52 <ibid> dpiponi: the crucial point is that C is not in { x | P } if C is not a set, even if P[x:=C] is true
13:20:32 <centrinia> What is a set? :O
13:20:47 <EvilTerran> centrinia, ay, there's the rub.
13:21:05 <ibid> dpiponi: NBG restricts this a bit by not allowing quantifiers over classes inside the comprehension term
13:21:10 <dpiponi> "a class is a set if it is a member of some class" :-) I have a problem with that.
13:21:28 <ibid> dpiponi: MK admits full first-order formulas there
13:21:38 <HairyDude> dpiponi: classes aren't part of ZF afaik, they're defined in NBG
13:21:57 <HairyDude> oh, you mentioned that already
13:21:57 <ibid> dpiponi: NBG is essentially as expressive as ZF, MK is strictly more expressive
13:21:59 <dpiponi> ibid: http://groups.google.com/group/sci.math/browse_thread/thread/2162a0fd56f9429b/42b2bcf831c94530
13:22:01 <lambdabot> Title: Can classes be elements of classes? - sci.math | Google Groups, http://tinyurl.com/ypkfbq
13:22:11 <EvilTerran> centrinia, an abstract structure such that, if S is a set, forall a in everything, a \in S \xor a \notin S
13:22:24 <ibid> dpiponi: the trivial answer to the question in the title is, yes :)
13:22:37 <dpiponi> I read the statement "a class is a set if it is a member of some class" in a book that was talking ZF. It made no sense to me at all.
13:22:43 <centrinia> Okay.
13:23:03 <ibid> dpiponi: it doesn't make sense in the context of ZF
13:23:18 <dpiponi> Thank you! I needed to hear someone say that :-)
13:23:20 <EvilTerran> Mitar, another possibility for your limited type would be to newtype Foo = Foo Int, and then muck about with that
13:23:23 <ibid> dpiponi: in classy set theory (NBG or MK), class is the undefined concept, and set is defined
13:23:50 <Mitar> thanks, i will try with enum for now ...
13:24:10 <ibid> dpiponi: people who say such things are really wanting to use classy set theory but are too timid to break tradition
13:24:46 <HairyDude> proper classes can't be elements of classes.
13:24:48 <dpiponi> It was in the book Vicious Circles. They definitely weren't too timid. It's about the *axiom* of anti-foundation! I think they were just sloppy.
13:25:05 <dpiponi> I meant to stress the *anti* not axiom!
13:25:22 <ski_> down with foundation !
13:25:23 <centrinia> Evil, I don't like \forall a \in everything. Everything scares me. :p
13:25:40 <ibid> dpiponi: look up Kelly's "General Topology" (or something similar), its appendix is the standard reference on MK; i believe MK is the only good seth theory :)
13:25:47 <dpiponi> (BTW Vicious Circles is a great book for anyone wanting to see a possible mathematical foundation that meshes well with lazy evaluation.)
13:25:55 <EvilTerran> well, centrinia, you can't say \in <a specific set> before you've defined sets
13:26:43 <EvilTerran> but i think "everything" can be defined according to intuition
13:26:47 <ibid> centrinia: \forall x in everything is perfectly valid; it's how universal quantification works in standard logic
13:26:50 <EvilTerran> i mean, you've got to do it somewhere.
13:27:10 <EvilTerran> and "everything"'s a relatively obvious concept
13:27:13 <ibid> centrinia: or rather \forall x FORMULA (they don't say "in everything")
13:27:26 <EvilTerran> yeah, i should probably've left off the "in everything" bit :P
13:27:28 <centrinia> I guess that's better.
13:27:36 <EvilTerran> so
13:27:52 <ibid> centrinia: but the semantics is like that: \forall x FORMULA: let x range over the whole universe, then FORMULA is valid...
13:27:58 <ibid> is true, rather
13:28:05 <EvilTerran> S is a set iff \forall x (x \in S \xor x \notin S)
13:28:21 <ibid> EvilTerran: that's not how set is defined
13:28:26 <EvilTerran> it works for me
13:28:27 <EvilTerran> :P
13:28:32 <ibid> S is a set if \exists C (S \in C)
13:28:42 <ibid> is the standard definition :)
13:28:58 <EvilTerran> i haven't done category theory, i'm afraid
13:29:06 <ibid> EvilTerran: this isn't category theory
13:29:11 <EvilTerran> what is C, then?
13:29:17 <ibid> EvilTerran: a variable
13:29:28 <HairyDude> as I understand it, \forall (x \in S) P is just shorthand for \forall X (x \in s => P)
13:29:30 <EvilTerran> er...
13:29:47 <EvilTerran> S is a set if it's a member of something?
13:29:50 <ibid> HairyDude: in standard logic, yes; not in some nonstarnard logics
13:29:52 <ibid> EvilTerran: yes
13:29:56 <EvilTerran> ...what is that something? a set?
13:30:05 <ibid> EvilTerran: it's usually called a class
13:30:07 <ski_> ibid : no urelements, then ?
13:30:11 <ibid> EvilTerran: and sets are classes :)
13:30:21 <ibid> ski_: no :)
13:30:26 <ibid> ski_: which is a shame
13:30:34 <EvilTerran> i was thinking naive theory here
13:30:37 <ibid> you could also say S is a set if S in { x | true }
13:30:58 <EvilTerran> isn't that one equivalent to "S is a set if S exists"?
13:31:09 <ibid> EvilTerran: well, in naive set theory, a set is a thing that contain members without regard to repetition or order :)
13:31:17 <ibid> EvilTerran: no
13:31:19 <HairyDude> the universe exists, but it's plainly not a set ;)
13:31:36 <EvilTerran> ibid, ... and either contains something xor doesn't. which was the line i had.
13:31:37 <ibid> EvilTerran: for example, { x | true } in {x | true } is false :)
13:31:52 <EvilTerran> ... this is axiomatic set theory we're back to, isn't it?
13:31:52 <ibid> EvilTerran: well, sure :)
13:31:56 <ibid> yep
13:32:00 <ibid> i haven't left it :)
13:32:21 <ibid> and classy set theory, besides
13:32:25 <EvilTerran> see, this is why i'm getting confused. i was talking naive, you were talking axiomatic, and then i was talking both alternately...
13:32:30 * EvilTerran whimpers
13:32:32 <centrinia> Given the class of objects that contains an foundation object (such as an empty set), containers that can contain non-repeats of containers and the empty set; is this class as "big" as the sets?
13:32:33 <ibid> (i like classy set theory. that's probably why i call it classy, you know:)
13:32:59 <ibid> centrinia: sounds like you have the class of all finite sets
13:33:22 <ibid> centrinia: you need additionally one infinite set to build up the usual set universe
13:33:24 <centrinia> You can't go past infinity (and beyond) with that definition? :O
13:33:25 <ski_> in NF the universe is a set
13:33:43 <ibid> new foundations?
13:33:47 <ibid> haven't looked at that :)
13:33:49 * ski_ nods
13:34:22 <ibid> centrinia: take ZF without the axiom of infinity, then you cannot prove the existence of an infinite set
13:34:36 <centrinia> I see.
13:34:42 <ibid> centrinia: of course, your definition was a bit vague so i had to assume stuff :)
13:34:50 <centrinia> Sorry.
13:35:42 <ibid> centrinia: but basically, in axiomatic set theory, you have a bunch of axioms saying that if you have some sets you can buind some bigger sets from them (pairs, power sets), but this is not enough to go infinite
13:36:00 <ibid> centrinia: even if you postulate that there is a set in the first place :)
13:36:34 <ibid> centrinia: so you need some sort of axiom saying that there is a set that is infinite (there are several nontrivially different formulations)
13:37:07 <ibid> (this of course in classless set theory like ZF)
13:37:19 <ibid> *build
13:38:34 <ibid> (also unions)
13:39:12 <ibid> in addition to the build axioms you have the axiom of separation, of course (you can form any subset of a set that can be described by a first-order formula)
13:39:34 <ibid> i should go to bed
13:39:55 <ibid> back to proving the soundness of the partial-function logic on the morrow...
13:40:03 <kosmikus> HairyDude: yes, that's possible. say \savecolumns before the first block, and \restorecolumns before the next
13:40:31 <HairyDude> kosmikus: yeah, I found the documentation for it a few minutes after I asked :)
13:42:52 <lispy> [a] is heavily optimized by ghc, correct?
13:43:18 <lispy> anyone know how/where those optimizations are defined?  Is it just via re-write rules or is it more "built in" than that?
13:43:45 <lispy> i ask, because it would be nice to use a custom list type, but performance is already known to be crucial
13:44:37 <ClaudiusMaximus> @where plugins
13:44:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
13:45:38 <dolio> lispy: I think it's rewrite rules.
13:45:48 <dolio> lispy: For foldr/build.
13:45:58 <lispy> dolio: build?
13:46:20 <dolio> @type build
13:46:22 <lambdabot> Not in scope: `build'
13:46:32 <dolio> Oh well. It's something like...
13:47:23 <Saizan> ?index build
13:47:23 <lambdabot> Data.Graph.Inductive.Internal.Heap, Distribution.Simple.Build, GHC.Exts
13:47:36 <Saizan> ?type GHC.Exts.build
13:47:38 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
13:47:49 <dolio> Ah, there it is.
13:48:59 <nominolo> hm, is there an alternative way of writing:  if foo then x else if bar then y else if baz then z else 42 ?
13:49:26 <Heffalump> use guards
13:49:28 <nominolo> i find case () of _ | foo -> x; _ | bar -> y; ... kind of ugly
13:49:31 <Heffalump> with a silly case statement if necessary
13:49:32 <Heffalump> ah, ok
13:49:42 <Heffalump> nafaik, then
13:49:44 <nominolo> ok, yes.  on a function that might work
13:49:59 <Heffalump> you can do it in a where clause too
13:50:11 <Heffalump> .... result ..... where result | foo -> x ...
13:50:28 <mauke> select :: [(Bool, a)] -> a -> a
13:50:28 <EvilTerran> shurely result | foo = x ?
13:50:32 <Heffalump> I guess you can do it in a let too, never really thought of it
13:50:35 <Heffalump> EvilTerran: yep
13:50:46 <nominolo> Heffalump: yeah, good idea
13:50:48 <ski_> (.. 'case () of _ | foo -> x | bar -> y; ...' .. no need to repeat '_')
13:51:37 <mauke> @type flip foldr (\(c,x) z -> if c then x else z)
13:51:39 <lambdabot> forall a t. (a -> ((Bool, t) -> t -> t) -> (Bool, t) -> t -> t) -> [a] -> (Bool, t) -> t -> t
13:51:57 <Mitar> i have to manually make a data type which would be bounded between -100 and 100?
13:52:01 <mauke> @type flip (foldr (\(c,x) z -> if c then x else z))
13:52:02 <lambdabot> forall a. [(Bool, a)] -> a -> a
13:53:03 <Heffalump> Mitar: yes
13:53:14 <dolio> lispy: Anyhow, foldr f z (build g) == g f z, or something like that, and you can get some deforestation that way.
13:53:35 <nominolo> hm, are pattern guards H98?
13:53:38 <Mitar> and i just instance the enum and define minBound = -100 and maxBound = 100?
13:53:57 <Mitar> ehm, instance the Bounded
13:54:29 <dolio> lispy: It's kind of related to how you'd encode lists as functions.
13:55:05 <dolio> lispy: newtype List a = Build { foldr' :: (a -> b -> b) -> b -> b }
13:55:23 <EvilTerran> Mitar, i think you'll have to muck about with instantiating the numeric typeclasses, as well
13:55:35 <EvilTerran> if you want it to be numeric
13:56:07 <Heffalump> nominolo: no.
13:56:17 <nominolo> oh, pattern guards are different from regular guards
13:56:18 <Heffalump> assuming you mean Just x <- foo style things
13:56:19 <Heffalump> right.
13:56:21 <dolio> Then you erase adjacent destructor/constructor pairs, which saves building intermediate lists since Haskell lists aren't actually defined that way.
13:56:28 <Heffalump> regular guards are
13:56:33 <nominolo> Heffalump: ok, thx
13:56:50 <EvilTerran> actually, Mitar, see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#newtype-deriving
13:56:52 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
13:57:35 <nominolo> Heffalump: because when writeing cabal code, i want to make sure it's as portable as possible.  I read that yhc doesn't support them
14:08:39 <nominolo> @hoogle [a] -> Maybe a
14:08:40 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
14:08:40 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
14:09:15 <chessguy> @type lookup
14:09:17 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:09:35 <mauke> @type \xs -> do x:_ <- Just xs; return x
14:09:37 <lambdabot> forall t. [t] -> Maybe t
14:10:12 <Mitar> why, if i instantize Bounde (to -100 and 100), can still do: (123 :: BoundedInt)
14:10:35 <davidL> @seen sorear
14:10:35 <lambdabot> I saw sorear leaving #happs, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 15h 2m 4s ago, and .
14:10:49 <EvilTerran> Mitar, because the derived Num instance doesn't look at your Bounded instance
14:11:56 <jfredett> bah! Frakking type system!
14:12:16 <Mitar> and how could i make it look?
14:12:40 <Mitar> or better ... if I define Num instance manually ... what should i do if I notice out of bounds value?
14:13:15 <Mitar> as i know even Int type does not check for bounds and simply overlaps ...
14:13:50 <EvilTerran> up to you
14:13:55 <EvilTerran> what do you want it to do?
14:14:10 <EvilTerran> error "out of bounds" works, as does wrapping, or clipping. depends.
14:14:48 <Mitar> > (123456789010 :: Int)
14:14:49 <lambdabot>  -1097262574
14:14:54 <Mitar> no error :-)
14:15:14 <Heffalump> what problem are you trying to solve?
14:15:31 <Mitar> i am making a interface to Lego Mindstorms NXT in Haskell :-)
14:15:47 <Mitar> and there in specifications is written that some values can be only between -100 and 100
14:16:00 <Mitar> so I would like to have a type which would represent this ...
14:16:07 <Mitar> so that if I do some function
14:16:26 <Mitar> doSomethingWithMotors :: OutputPower -> NXT ()
14:16:43 <Mitar> and somebody calls with doSomethingWithMotors 123 it would throw an error ..
14:16:52 <Mitar> i know that I could check with quards ...
14:17:09 <lispy> new type with NXT and unNXT?
14:17:23 <Mitar> NXT is a reader lifted IO monad ...
14:17:33 <Heffalump> I suggest you throw an exception if you notice an out of bounds error
14:17:34 <Mitar> (to store a connection)
14:17:47 <hpaste>  jfredett pasted "Type Sig Woes" at http://hpaste.org/119
14:17:47 <lispy> oh, i see
14:17:48 <Mitar> and use Int as a type?
14:17:55 <jfredett> anyone feel like helping?
14:17:57 <jfredett> :/
14:17:57 <Heffalump> yes
14:18:02 <Heffalump> or Char if you care about space
14:18:11 <EvilTerran> Mitar, it looks like you're gonna have to instantiate Num, Real, and Integral yourself to pass through to Int/Char if you do it this way
14:18:11 <Heffalump> s/Char/Int8/
14:18:29 <EvilTerran> (what Heffalump said, Int8, not Char)
14:18:48 <Heffalump> @type logBase
14:18:50 <lambdabot> forall a. (Floating a) => a -> a -> a
14:18:57 <Mitar> but what do you think about that ... is it normal that somebody do this with defininig the types so strictly by the specification?
14:19:13 <Mitar> i do not care about space in Haskell ...
14:19:22 <Heffalump> jfredett: your problem is that you're trying to use Integer in one situation, and Floating f => f in another
14:19:23 <Mitar> (and the interface is already working! :-) )
14:19:35 <mauke> jfredett: you need an integer log
14:19:36 <Heffalump> Mitar: I don't think most people go to the effort, but if you want to it sounds like a good idea.
14:19:40 <jfredett> right- so is there some handy way to bounce around that?
14:19:44 <jfredett> mauke exactly
14:20:02 <jfredett> but it appears that none such function exists
14:20:05 <Saizan> jfredett: logBase 2 (fromIntegral x)
14:20:08 <Heffalump> get an integer log, either by calling floor on the result of that one (and using fromIntegral to get the inputs into the right type), or by writing your own
14:20:25 <mauke> jfredett: ceiling (logBase 2 (fromInteger x))
14:20:36 <jfredett> see, i tried something like that
14:20:51 <jfredett> (floor . (logBase 2))
14:20:53 <EvilTerran> Mitar, i'd be inclined to just check the range when actually passing things through the interface, but what you've trying to do is great if you think it's worth the effort
14:20:55 <jfredett> @type (floor . (logBase 2))
14:20:57 <lambdabot> forall b b1. (Integral b1, RealFrac b, Floating b) => b -> b1
14:21:04 <Heffalump> @type floor . logBase 2 . fromIntegral
14:21:06 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
14:21:13 <Heffalump> try that
14:22:05 <Mitar> i do no know if it is worth ... i am just learning haskell and was thinking that this is the "haskell way" to strictly define types so that they represent the model your are working on (in this case NXT specifications) as closely as possible
14:22:06 <jfredett> nope, still error ridden
14:22:20 <jfredett> oh, hold on
14:22:23 <jfredett> i forgot something
14:22:43 <jfredett> lol, that seems to work
14:22:53 <EvilTerran> Mitar, perhaps generalise even further, and write a TH template $(subset [t| Type |] [| predicate |]) ?
14:23:02 <EvilTerran> s/even further//
14:23:06 <jfredett> cool
14:23:13 <jfredett> that works, thanks Heffalump
14:23:20 <jfredett> and mauke and Saizan
14:23:22 <jfredett> etc
14:23:37 <EvilTerran> actually, ignore me.
14:23:52 <EvilTerran> if you're just learning Haskell, templates're best avoided, methinks.
14:24:06 <Mitar> sorry? TH template? i am far from that currently in my haskell knowledge ...
14:24:12 <EvilTerran> yes. my mistake.
14:24:22 <EvilTerran> i'm just tossing ideas around
14:24:45 * EvilTerran is currently rather fond of Template Haskell. i think i'm rather prone to suggest it inappropriately
14:24:54 <Mitar> but still, can you describe in few sentences why would that be good or what would accomplish?
14:25:16 <EvilTerran> you could say
14:25:45 <Heffalump> EvilTerran: using it for anything exciting?
14:25:54 <Heffalump> I keep finding the limitations get in my way too much.
14:26:18 <EvilTerran> $(subset "BoundedInt" [t| Int |] (\x -> x >= -100 && x < 100))
14:26:20 <EvilTerran> or something
14:26:37 <EvilTerran> and it'd create a type that did what you wanted
14:26:40 <EvilTerran> and then say
14:26:54 <EvilTerran> $(subset "DifferentlyBoundedInt" [t| Int |] (\x -> x >= 0 && x < 100))
14:27:08 <EvilTerran> or OddInt, where the predicate was \x-> x `mod` 2 == 0
14:27:14 <EvilTerran> *EvenInt, even#
14:27:16 <Mitar> hmm, nice ...
14:27:19 <EvilTerran> and so on and so on
14:27:29 <Mitar> and when I would do: (123 :: BoundedInt)?
14:27:34 <EvilTerran> I'm not sure if such a thing would be possible, but it's an interesting idea, IMO
14:27:54 <EvilTerran> i haven't considered the specifics enough to know if that would work
14:28:09 <Mitar> but if this is a template system, then it translates to something? to what would this BoundedInt then translate?
14:28:11 <EvilTerran> Heffalump, no, i haven't done anything particularly interesting with it yet. still getting the hang of it.
14:28:26 <Saizan> Mitar: the best you can do there is make your Num instance call error "Out of Bound"
14:28:39 <Saizan> ?src Num
14:28:39 <lambdabot> class  (Eq a, Show a) => Num a  where
14:28:39 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:28:39 <lambdabot>     negate, abs, signum     :: a -> a
14:28:39 <lambdabot>     fromInteger             :: Integer -> a
14:28:42 <EvilTerran> Mitar, the $(subset ...) construction would expand into a newtype decleration and some instance declerations, i suppose
14:29:08 <EvilTerran> so you'd use it where you would otherwise declare a type and instances, and it'd do what you meant
14:29:32 <Heffalump> you can probably do the same thing with a parameterised type, actually
14:29:35 <Heffalump> instead of messing around with TH
14:29:53 <Saizan> so you'll devine fromInteger x | x > 100 || x < -100 = error "Out of Bound" | otherwise = BoundInt (fromInteger x)
14:29:56 <Heffalump> you just need to represent 100 on the type level somehow and I'm sure a few mini-Olegs would do the job there.
14:30:13 <jfoutz> Mitar, think of the templates like lisp macros. It's kind of like a pre-processor that changes the code before the compiler sees it. so rather than writing a new type directly, you write a little program that when executed, will write the source for the new type.
14:30:27 <EvilTerran> Heffalump, i'd be inclined to at least template out the "100 on the template level" bit
14:30:30 <EvilTerran> *type level
14:30:48 <Mitar> jfoutz, yes, that's why i am asking about to what it translates this
14:30:50 <Heffalump> EvilTerran: there are type class tricks you can play that make it not that unpleasant
14:30:51 <Saizan> data Hundred -- :)
14:31:37 <EvilTerran> I envisage something of the form (Decimal One (Decimal Zero (Decimal Zero DecimalTerminator))
14:31:41 <mauke> D1 (D0 (D0 Z))
14:31:49 <EvilTerran> yes, quite, or that
14:31:51 <mauke> oleg had something like that
14:31:58 <EvilTerran> still, not pretty.
14:32:16 <EvilTerran> if you did infix type constructors, it could be improved on, i guess
14:32:26 <Heffalump> you don't really need to see it
14:32:27 <jfoutz> i think, EvilTerran was pointing out, he dosn't know how to write the *actual* code you need, so he's at a bit of a loss. but once you get one form working, you could then write a template to take care of whatever arbitrary bounding system you might want.
14:32:37 <Heffalump> stick it in a type class with a member that lets you extract the actual value as an Int
14:32:42 <Saizan> the peano/binary/etc.. encoding is only needed when you want runtime defined bounds, however
14:32:45 <EvilTerran> jfoutz, precisely
14:33:25 <jfoutz> :)
14:34:21 <EvilTerran> Saizan, in which case shurely you could have a data Subset a = Subset (a -> Bool) a, with the first parameter being a predicate you pass around everywhere (or somesuch)?
14:38:59 <Saizan> EvilTerran: yeah, but that's not pretty :)
14:40:02 <siti> what's the difference between chs and hsc?
14:41:15 <Mitar> thanks for everything ...
14:41:34 <EvilTerran> it's what we're here for =]
14:41:57 <Saizan> EvilTerran: there's a functional pearl by oleg on this kind of things, which ends with FFI to runtime build a type representation of nearly every haskell value
14:42:12 <mauke> oh yeah
14:42:24 <EvilTerran> I really must read some Oleg at some point
14:42:24 <int-e> siti: hmm. they're processed by different programs (c2hs and hsc2hs?)
14:42:30 <EvilTerran> @where oleg
14:42:30 <lambdabot> http://okmij.org/ftp/
14:42:41 <siti> int-e: ok
14:43:20 <mauke> http://okmij.org/ftp/Haskell/types.html#Prepose
14:43:22 <lambdabot> Title: Haskell Programming: Types
14:45:05 <Procyon112> EvilTerran: I just got "The Reasoned Schemer" last night.. I didn't realize Oleg was a co-author.  So far it's a very good introduction to logic programming.
14:45:17 <EvilTerran> is there a biography of the man somewhere? i still have no idea who he is beyond an almighty haskell guru.
14:45:39 <int-e> siti: c2hs homepage: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/ . hsc2hs is described at http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
14:45:39 <lambdabot> Title: Manuel M T Chakravarty - C->Haskell
14:45:57 <siti> c2hs is better right ;)?
14:46:41 <int-e> c2hs is higher-level, I think.
14:46:43 <Heffalump> EvilTerran: just search for his mailing list posts and papers
14:47:10 <Heffalump> http://okmij.org/ftp/ is his web pag
14:47:10 <Heffalump> e
14:47:10 <lambdabot> Title: This FTP site
14:47:39 <EvilTerran> (heffalump, i just got that from @where oleg)
14:47:40 <Mitar> how is in Haskell binary or?
14:47:49 <int-e> .|.
14:47:54 <int-e> from Data.Bits
14:48:06 <Mitar> thanks
14:49:17 <chessguy> @src (.|.)
14:49:18 <lambdabot> Source not found. It can only be attributed to human error.
14:50:31 <int-e> (I# x#) .|.   (I# y#)  = I# (word2Int# (int2Word# x# `or#`  int2Word# y#))
14:50:32 <int-e> ;)
14:50:45 <int-e> (well. for Int, and ghc)
14:50:47 <chessguy> in ghc maybe :)
14:50:47 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
14:51:19 <chessguy> @seen kowey
14:51:20 <lambdabot> I saw kowey leaving #darcs and #haskell 1h 59m 23s ago, and .
14:52:16 <mauke> why didn't they make .^. bitwise xor?
14:53:54 <lispy> what did they use?
14:54:11 <int-e> > 2`xor`3
14:54:11 <lispy> :t (.|.)
14:54:12 <lambdabot>  Add a type signature
14:54:13 <lambdabot> forall a. (Bits a) => a -> a -> a
14:54:18 <int-e> > 2`xor`3 :: Int
14:54:19 <lambdabot>  1
14:54:22 <mauke> xor
14:54:33 <mauke> which breaks symmetry with `or`
14:54:41 <lispy> interesting, yeah
14:55:06 <chessguy> It can only be attributed to human error.
14:55:20 <lispy> > let a .^. b = a `xor` b in 1 .^. 2 :: Int
14:55:21 <lambdabot>  3
14:59:30 <ddarius> Yay HCAR
15:03:14 <Saizan> @where HCAR
15:03:14 <lambdabot> http://www.haskell.org/communities/
15:04:25 <Saizan> http://www.haskell.org/communities/05-2007/html/report.html <-- the html link seems broken
15:04:26 <lambdabot> Title: Haskell Communities and Activities Report
15:05:15 <ari> @src fix
15:05:15 <lambdabot> fix f = let x = f x in x
15:05:27 <kosmikus> Saizan: works for me ...
15:05:51 <ari> Is there any specific reason why people keep talking about this way of saying it instead of fix f = f (fix f)?
15:06:18 <arjanb> it goes to the previous edition here
15:06:25 <Saizan> kosmikus: it gives me the 11th edition
15:06:35 <ari> Because, if you ask me, fix f = f (fix f) is easier to understand...
15:06:36 <Heffalump> WFM
15:06:43 <mauke> ari: your version is an infinite loop, not a cyclic data structure
15:07:00 <Heffalump> caching issues? Ctrl-Refresh?
15:07:26 <kosmikus> Saizan: oh, I just saw that. should be fixed in a minute. but only the title is wrong.
15:07:27 <sorear> kosmikus: When will the May2007 HC&Ar be published?
15:07:36 <Heffalump> sorear: it just was
15:07:48 <kosmikus> Saizan: better?
15:07:58 <sorear> kosmikus++ I look forward to reading it
15:08:05 <Saizan> kosmikus: yeah :)
15:08:10 <cdsmith> > (let myfix f = f (myfix f) in myfix (\f x -> if x == 0 then 1 else x * f (x - 1)) 6
15:08:10 <lambdabot>  Parse error
15:08:39 <cdsmith> > (let myfix f = f (myfix f) in myfix (\f x -> if x == 0 then 1 else x * f (x - 1))) 6
15:08:43 <lambdabot>  720
15:08:53 <cdsmith> mauke: not an infinite loop...
15:09:46 <mauke> the infinite loop is hidden in f
15:09:56 <mauke> it's a lazy infinite loop, of course
15:10:18 <Saizan> the pragmatic difference is that with let x = f x  the expasion is "memoized"
15:10:20 <mauke> > let myfix f = f (myfix f) in myfix ('x' :)
15:10:22 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
15:10:31 <mauke> I think this uses O(n) memory
15:10:46 <cdsmith> mauke: I don't understand the distinction you're making, then.  the two versions of fix act identically
15:11:25 <mauke> even with regard to memory usage?
15:11:42 <cdsmith> mauke: well, I don't know... but I'd be surprised to find they are different.
15:12:09 <mauke> I wouldn't
15:12:28 <cdsmith> > (let myfix f = f (myfix f) in myfix ('x' :)) !! 1000
15:12:30 <lambdabot>  'x'
15:12:42 <cdsmith> > (let myfix f = f (myfix f) in myfix ('x' :)) !! 10000
15:12:43 <lambdabot>  'x'
15:12:53 <cdsmith> > (let myfix f = f (myfix f) in myfix ('x' :)) !! 100000
15:12:54 <lambdabot>  'x'
15:13:03 <cdsmith> doesn't seem to be eating much memory to me.
15:13:33 <mauke> maybe it's fused with !!
15:13:43 <ari> Hmm
15:14:11 <ari> Experimenting with ghci here does show that the version using let is a hell of a lot faster
15:14:22 <ari> So, well, there's the answer to my question
15:14:31 <ari> (as in, faster for cdsmith's function)
15:14:36 <weitzman> > (let myfix f = f (myfix f) in myfix ('x' :)) !! (10^8 :: Int)
15:14:40 <emu> how about
15:14:42 <lambdabot> Terminated
15:14:47 <weitzman> > fix ('x' :) !! (10^8 :: Int)
15:14:49 <lambdabot>  'x'
15:14:53 <emu> fix ~f = f (fix f)
15:15:07 <mauke> emu: ~f is the same as f
15:15:15 <mauke> it can't fail anyway
15:15:22 <EvilTerran> er... how exactly does one use TH.reify?
15:15:34 <emu> it's not about the failing, it's about the laziness
15:15:44 <mauke> huh?
15:15:48 <EvilTerran> (that's a rather vague way of putting it, but you get the idea)
15:15:56 <Mitar> anybody has a Lego Mindstorms NXT here?
15:16:17 <ari> Ah, I see
15:16:42 <ari> I was catching up with haskell-cafe and happened to find someone talking about fix, which prompted me to ask this question
15:16:58 <ari> It seems that the very same question was answered just a little while later
15:17:01 <EvilTerran> printing the result of reify seems to be well-night impossible
15:17:04 <Saizan> Epigram is implemented in haskell?
15:17:07 <EvilTerran> *migh
15:17:09 <EvilTerran> *nigh
15:17:14 <ari> I just hadn't gotten to it yet
15:17:57 <ari> http://www.haskell.org/pipermail/haskell-cafe/2007-May/026181.html
15:17:59 <lambdabot> Title: [Haskell-cafe] Cute code [was: The C Equiv of != in Haskell miscommunication thr ..., http://tinyurl.com/2bw2kv
15:18:55 <Saizan> EvilTerran: i used stringE . show
15:19:11 <timthelion> wow, this xmonad is really great
15:19:51 <EvilTerran> ah, yes, that works, Saizan. thanks.
15:25:03 <EvilTerran> er... where does one get a Cxt (or CxtQ) from?
15:28:06 <sorear> EvilTerran: it's a type synonym!
15:28:06 <sorear> EvilTerran: Ctx will unify just fine with anything that returns [Typ]
15:28:06 <EvilTerran> allow me to rephrase, then; what goes in the first parameter of, say, dataD?
15:28:38 <sorear> the context!
15:28:43 <sorear> @src Array
15:28:43 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:28:54 <sorear> data Ix i => Array i e = ...
15:28:54 <EvilTerran> um. where do i get the context from?
15:28:58 <EvilTerran> ooooohhhh
15:29:03 <EvilTerran> _that_ sort of context
15:29:05 <EvilTerran> now I get it.
15:29:53 <sorear> you should almost always leave it [], class contexts on non-existential data declarations are considered a mistake
15:30:30 <EvilTerran> okay
15:38:09 <sorear> Bulat has a shift key!
15:38:20 <Jessehk> I had a question regarding some code this channel helped me write. http://hpaste.org/92
15:38:38 <Jessehk> In the dealCard function, lift $ randCard d is IO (Card, Deck)
15:38:59 <Jessehk> How is IO (Card, Deck) "assigned" to (c, d') ?
15:39:24 <TSC> You mean, how is its type inferred?
15:39:26 <emu> <-
15:39:26 <Jessehk> I understand the "<-", but I don't get the conversion between IO (Card, Deck) and (c, d)
15:39:35 <emu> the <- "unpacks" it from the monad
15:39:44 <Jessehk> I know that part :)
15:39:52 <emu> and what remains is (Card, Deck)
15:40:00 <emu> which can be pattern matched with a pair (c, d)
15:40:13 <Jessehk> doesn't the <- unpack the IO (Card, Deck) from the StateT monad?
15:40:22 <emu> that's what lift takes care of
15:40:30 <emu> @type lift
15:40:31 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
15:41:25 <Saizan> well lift packs your IO (Card,Deck) in StateT Deck IO (Card,Deck) then <- sees (StateT Deck IO) as a single monad and unpacks (Card,Deck) from it
15:42:27 <TSC> So you're right that the "<-" is working in StateT.  It's the IO action that has to be converted into a StateT action so it will work
15:43:23 <Saizan> but StateT is not a monad, only Monad m => StateT s m is one, StateT Deck IO in this case
15:43:26 <Jessehk> Ah, I get it. So (StateT Deck IO) is the m in ma
15:43:28 <Jessehk> *m a
15:44:03 <Saizan> Jessehk: which m a are you referring to?
15:44:14 <Jessehk> Saizan: Nevermind. :)
15:44:30 <Saizan> however yes, (StateT Deck IO) is your monad :)
15:44:49 <Saizan> the monad that <- uses
15:45:13 <Jessehk> last question: If (c, d) are just a (Card, Deck) pair, then how does "return c" add the "IO" to the card?
15:45:22 <Jessehk> by type inference?
15:45:51 <EvilTerran> hm... if i understand things correctly, a type created in a $[splice]d decleration isn't visible by name in the stuff after it, in order to maintain lexical scoping... is this right?
15:46:09 <Saizan> yes, because all expressions in a do block have to be in the same monad
15:47:22 <Saizan> (it adds (StateT Deck IO) in this case, in fact)
15:47:35 <EvilTerran> (ignore me, i'm talking rubbish)
15:48:18 <EvilTerran> (Top Level Declerations Are Special, or something)
15:49:05 <Saizan> (i don't know about types, but functions are surely visible)
15:50:38 <mdmkolbe|wor1> Do these data types already exist or have a well known name?
15:50:38 <mdmkolbe|wor1> data Erase c a = forall b. (Typeable b) => Erase { unErase :: (c b a) }
15:50:38 <mdmkolbe|wor1> data Flip c a b = Flip { unFlip :: c b a }
15:51:35 <sorear> the second has a well known name, Flip
15:51:56 <sorear> the second is also better written as a newtype
15:52:47 <mdmkolbe|wor1> @index Flip
15:52:47 <lambdabot> bzzt
15:53:12 <emu> @pl \x y -> out y x
15:53:12 <lambdabot> flip out
15:53:25 <sorear> mdmkolbe|wor1: I said well known, not standard :P
15:53:34 <mdmkolbe|wor1> sorear: :-)
15:54:13 <kpreid> is there a reason to make it a newtype/data rather than a type?
15:54:29 <sorear> kpreid: newtypes can be partially applied
15:54:44 <kpreid> hm, okay
15:56:02 <mdmkolbe|wor1> sorear: don't newtypes also not use any heap? (unless GHC now optimized single constructor/single argument data)
15:56:18 <timthelion> hmm, how best to concatenate multi-line output to be fed to dzen? it doesn't do it automagicaly.  I want to show the date, and both lines of acpi command
15:56:28 <sorear> mdmkolbe|wor1: No, type is just as efficient.
15:56:52 <sorear> timthelion: I'd go for intercalate " | " . lines
15:57:53 <EvilTerran> ?type intercalate
15:57:54 <timthelion> intercalate?
15:57:55 <lambdabot> Not in scope: `intercalate'
15:58:01 <EvilTerran> intersperse?
15:58:10 <mauke> (concat .) . intersperse
15:58:14 <TSC> intercalate x = concat . intersperse x
15:58:31 <Igloo> kpreid: newtype/data give you type safety
15:59:17 <kpreid> Igloo: I know that. It doesn't seem useful in this case. (but sorear gave another reason)
16:00:29 <timthelion> sorear: I'm afraid I don't know what you mean.
16:01:23 <sorear> > concat . intersperse " | " . lines $ "Line 1\nLine 2\nLine 3"
16:01:25 <lambdabot>  "Line 1 | Line 2 | Line 3"
16:01:29 <sorear> timthelion: ?
16:01:35 <timthelion> ok
16:02:43 <timthelion> grr, I wish dons would use 80 char long lines
16:02:57 <EvilTerran> what does he use?
16:03:11 <timthelion> whatever he wishes
16:03:29 <Procyon112> Hmmm.  Shouldn't this be in Data.List?  It's rather non-obvious: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
16:04:06 <ddarius> Procyon112: Does it come up that often?
16:04:20 <Procyon112> It does for me :)
16:05:14 <Procyon112> It seems like a rather basic operation on lists.
16:05:29 <Procyon112> C++ STL has it on all of their containers also.
16:05:45 <SamB> @quote Procyon112
16:05:45 <lambdabot> Procyon112 says: It really kind of bothers me that the universe feels the need to save processor cycles.
16:06:38 <SamB> hmm. I should probably do something... my stomache hurts so bad I can't remember the difference between Procyon112 and protontorpedo...
16:06:59 <Procyon112> hehe
16:07:19 <EvilTerran> also between your mind and your stomach, from the looks of it
16:07:22 <emu> @protontorpedo
16:07:22 <lambdabot> help please
16:07:27 <emu> @protontorpedo
16:07:27 <lambdabot> some dude called topmind says that oo is bs
16:07:40 <SamB> EvilTerran: ... it is distracting
16:08:05 <EvilTerran> i know, i know
16:08:05 <emu> must .. eat .. food
16:08:36 <EvilTerran> !!
16:08:39 <EvilTerran> how peculiar.
16:09:10 <EvilTerran> foobar2000 just crashed... and for some reason its coredump popped up in my text editor of choice
16:09:14 <Procyon112> ddarius: I mean, we've got zipWith7 in there... I think a simple inverse for sort wouldn't be uncalled for :)
16:09:18 <Saizan> Procyon112: the worse is that you could use Data.Set as the tree, just exporting the constructor
16:09:46 <Saizan> or a elemAtDel function
16:10:31 <Procyon112> shuffle is important for randomly permutated nondeterminism.
16:10:56 <SamB> EvilTerran: !
16:11:04 <Procyon112> Without shuffle, my nondeterminism is too deterministic ;)
16:11:17 <SamB> I thought coredumps were stored in executable image formats..
16:11:22 <EvilTerran> Procyon112, but should it be in Data.List, or System.Random, or...
16:11:36 <emu> the list monad is nondeterminism
16:12:03 <EvilTerran> samB, okay, i lie; the windows nearest-equivalent. being a register dump, stack trace, and some other useless information
16:12:57 <SamB> EvilTerran: I bet I can get a coredump on windows.
16:13:07 <Procyon112> EvilTerran: Well, Oleg's algorithm takes a list to shuffle by, so there is no need for it to be in System.Random.  It seems with that view it's a good fit for Data.List.
16:13:32 <EvilTerran> samb, if you're trying, probably. it doesn't happen spontaneously, tho
16:13:38 <EvilTerran> Procyon112, ah, okay then.
16:13:52 <Procyon112> emu: The list Monad's non-determinism will always return the same results though, so in a way, it's deterministic nondeterminism :)
16:14:04 <EvilTerran> maybe we should add an Oleg.* branch to the module tree, for all the useful bits he's done
16:14:15 <emu> no, it's non-determinism
16:14:24 <Procyon112> Data.Oleg
16:14:27 <SamB> EvilTerran: I haven't noticed it to happen spontaneously here in Linux for a long while, either
16:14:27 <emu> it will return all possible answers!
16:14:39 <EvilTerran> samb, i have a knack for breaking things :D
16:14:41 <emu> when non-deterministic turing machines are invented, Haskell IS ready!
16:14:56 <emu> screw multi-core
16:15:10 <SamB> EvilTerran: I meant, even in the situations where coredumps would happen, they don't happen
16:15:26 <Procyon112> emu: in order.  Sometimes I want just one of those answers, and I want it randomly.
16:15:27 <SamB> i.e. they seem to be turned off
16:15:36 <EvilTerran> oh, okay.
16:15:53 <EvilTerran> emu, unsafePerformIO destroyUniverse?
16:16:41 <Saizan> uhm is destroyUniverse not referentially transparent? i.e. can you get different results when you call it?:)
16:17:18 <EvilTerran> it's got side effects, tho
16:17:34 <edwinb> it probably takes the current universe state as an argument
16:17:36 <Procyon112> Saizan: Sometimes it fizzles out, and other times it crunches back down.. you never can tell
16:17:38 <EvilTerran> destroyUniverse :: IO ()
16:17:50 <davidL> sorear: were you able to derive a closed formula for that problem? (no hints)
16:17:52 <edwinb> maybe the universe is a state monad
16:18:09 <EvilTerran> i was thinking it'd be a RealWorld
16:18:35 <edwinb> if you have enough memory for it, yes
16:19:03 <Saizan> so we just need to implement mfix and we get time-travel
16:20:26 <mauke> @quote stereo
16:20:26 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
16:20:37 <SamB> > mfix (const (deleteFile "/etc/passwd"))
16:20:44 <lambdabot>   Not in scope: `deleteFile'
16:20:49 <SamB> > mfix (const (removeFile "/etc/passwd"))
16:20:50 <lambdabot>   Not in scope: `removeFile'
16:20:56 <SamB> > mfix (const (unlinkFile "/etc/passwd"))
16:20:57 <lambdabot>   Not in scope: `unlinkFile'
16:21:00 <SamB> arg.
16:21:32 <emu> destroyUniverse is definitely unsafe
16:21:33 <wy> Are monoids the same thing as monads?
16:21:38 <emu> no
16:21:44 <Jessehk> > let square n = n * n in square 4
16:21:45 <lambdabot>  16
16:21:49 <Mitar> are there already some functions which would convert from [Word8] to for example signed 16 bit int?
16:21:49 <Jessehk> wow, that was fun
16:21:50 <emu> monoids are semigroups with identity element
16:21:54 <int-e> emu: we need a forkUniverse to go with it :)
16:22:08 <Mitar> and some other which would convert to for example unsgined 16 bit int?
16:22:33 <wy> emu, I just encountered this in a paper and I don't understand it.
16:22:58 <emu> wy: a semigroup is (a) a set, (b) a binary operation on the set producing another member of the set (closed)
16:23:05 <hpaste>  int-e pasted "fun with unsafeInterleaveIO: a unique name supply with a mostly pure interface" at http://hpaste.org/121
16:23:09 <emu> wy: for example, integers and multiplication
16:23:24 <kpreid> wy: the monoid instances listed in http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html might help you see what can be a monoid
16:23:26 <lambdabot> http://tinyurl.com/y5qk9n
16:23:41 <emu> wy: a monoid is a semigroup where there is an identity element.  in this case, it's also a monoid, because 1 is the identity.
16:24:14 <dibblego> ?where quickcheck
16:24:14 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
16:24:28 <emu> wy: oh, and the operation in question must be associative.  it is not required to be commutative.
16:24:48 <wy> emu, But it seems monads also has something like identity. Is it unit?
16:25:05 <emu> aka return
16:26:22 <kpreid> hm, there could be an instance MonadPlus a => Monoid (MSum a), but there isn't.
16:27:20 <wy> emu, I've read the page. It's a little abstract. How can I think of it in an example?
16:27:56 <Saizan> kpreid: MonadPlus m => Monoid (MSum m a) with newtype Msum m = Msum m ?
16:28:06 <kpreid> Saizan: yup
16:28:26 <kpreid> wy: ((+), 0) describes a monoid
16:28:30 <Saizan> Msum m a = Msum (m a)
16:28:32 <kpreid> so does ((*), 1)
16:29:18 <kpreid> (Haskell-wise, that's a value representation whereas Data.Monoid provides a type-class representation)
16:30:03 <Saizan> wy: you have an associative binary operation over a set call it +, and a value of your set, call it 0 such that forall x  0+x= x and x+0 = x
16:31:06 <wy> Saizan, What are the other elements to produce the set?
16:31:07 <Procyon112> ping chessguy
16:31:24 <kpreid> wy: dependent on the particular monoid
16:31:38 <kpreid> wy: just like the extra operations that make monads interesting depend on the monad
16:32:08 <timthelion> grr
16:32:20 <Saizan> wy: they are defined the moment you chose the set, being a monoid doesn't say much about them
16:32:23 <timthelion> putStr only works if I get a line after it.
16:32:29 <timthelion> I have hSetBuffering stdout NoBuffering
16:32:35 <timthelion> wtf?
16:32:41 <kpreid> timthelion: hFlush stdout?
16:32:56 <timthelion> what does that do?
16:32:57 <wy> I wonder how are they useful?
16:33:32 <Saizan> wy, for example [a] is a monoid with ++ as the operation and [] as the zero
16:33:37 <kpreid> wy: well, the Writer monad uses them to abstract over any sort of accumulation you might want to do
16:33:57 <timthelion> kpreid: adding that to the end of the function did nothing
16:34:11 <wy> Ah... I see
16:34:29 <thoughtpolice> can someone explain Functor/fmap? I've looked at the docs several times and I feel pretty good about reading from types, but it's actual purpose generally escapes me (if anybody has an example I'd appreciate it.)
16:34:47 <Saizan> thoughtpolice: you know map?
16:35:32 <wy> Thanks. I'll look into it later. Just got it in a section about records. Record subtyping, ...
16:36:08 <Procyon112> @tell chessguy One thing I don't like about the current GPLib is the idea that dealing with the random number generator requires us to always be in the state monad, which forces a sequencing on us that is unnatural.  It will force us to not be able to generate trees in parallel.  Perhaps we should use a random sequence as a seed generator instead, passing the seed down to the functions that need random sequences where they can then b
16:36:08 <lambdabot> Consider it noted.
16:36:20 <Saizan> thoughtpolice: for the [a] type fmap = map, and in general the meaning is that of apply the given function to the elements inside your container
16:36:28 <int-e> > fmap (fmap succ) [Just 1, Nothing, Just 53]
16:36:30 <lambdabot>  [Just 2,Nothing,Just 54]
16:36:35 <Saizan> where "container" here is quite general
16:36:46 <wy> Have you heard of quotient types?
16:37:09 <mdmkolbe|wor1> how do I tell GHCi to print the type of all expressions
16:37:27 <wy> mdmkolbe|work, :type
16:37:50 <mdmkolbe|work> wy: I don't want to query the type.  I want it to print the value of the expression along with the type
16:38:17 <mdmkolbe|work> i.e. > 1
16:38:17 <mdmkolbe|work> 1 :: (Num a) => a
16:38:26 <wy> mdmkolbe|work: Will that require you to use types as values?
16:38:39 <mdmkolbe|work> wy: ?
16:39:18 <HairyDude> @type 1
16:39:20 <lambdabot> forall t. (Num t) => t
16:39:22 <Newbie> hi all
16:39:41 <Saizan> mdmkolbe|work: i've never heard of such a feature
16:39:44 <wy> mdmkolbe|work: Because you want to convert types into strings. I guess it's not possible in Haskell.
16:39:52 <EvilTerran> mdmkolbe|work, :set +t
16:40:02 <Saizan> :O
16:40:21 <thoughtpolice> Saizan: so all fmap really does is map function f over a where a might be whatever (an instance of Functor, to be exact), i.e. fmap f z where z = IO String?
16:40:24 <mdmkolbe|work> EvilTerran: thx, that's what I was looking for
16:40:30 <thoughtpolice> f in this instance could give back whatever, but I just want to get the point
16:40:36 <fuzan> :t fmap
16:40:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:40:48 <timthelion> why doesn't putStr work?
16:40:52 <wy> mdmkolbe|work: If you can do it, we would have something called "typeof"... Uhh
16:41:03 <EvilTerran> ?type typeOf
16:41:04 <sorear> > typeOf 'x'
16:41:06 <lambdabot>  Char
16:41:06 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:41:14 <Saizan> thoughtpolice: yeah, f should be of type String -> b for some b, in that case
16:41:15 <fuzan> > fmap (+1) (return 5)
16:41:16 <lambdabot>   add an instance declaration for (Show (f a))
16:41:22 <thoughtpolice> so if you had something wrapped in the IO monad, would fmap 'unwrap' the monad to give f the value?
16:41:25 <mdmkolbe|work> wy: I'm not needing the types as a string just GHCi to print the types of expressions
16:41:27 <Newbie> hi all
16:41:37 <thoughtpolice> fuzan: thanks for that example, explained it easily enough :p
16:41:39 <TSC> Hello Newbie
16:41:42 <Newbie> > reverse "hello all"
16:41:43 <lambdabot>  "lla olleh"
16:41:47 <EvilTerran> thoughtpolice, effectively; except in the context of a monad, fmap is called liftM
16:41:51 <wy> sorear: But that seems to be a command in ghci
16:41:52 <sorear> Newbie: Hi.  Your nick is probably a bad idea btw
16:41:57 <thoughtpolice> thanks all :)
16:42:03 <HairyDude> timthelion: in what way does it not work?
16:42:06 <wy> sorear: Oh no...
16:42:21 <timthelion> HairyDude: well, it only prints if I have a getLine after it.
16:42:27 <wy> sorear: So do you have a way to convert a type into a string?
16:42:45 <EvilTerran> wy, show . typeOf (undefined :: <your type here>)
16:42:46 <sorear> @instances-importing Data.Typeable Show
16:42:47 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
16:42:49 <Saizan> thoughtpolice: it's worth noticing that also fmap = (.)  for the ((->) r) functor :)
16:43:09 <EvilTerran> or rather show $ typeof...
16:43:10 <sorear> wy: "Oh no..." what?
16:43:21 <wy> mdmkolbe|work: I see your needs now. But you got me interested in the question of use types as values.
16:43:42 <wy> sorear: Oh no I was wrong
16:44:11 <EvilTerran> > show $ typeOf (undefined :: Either (Maybe [Int]) (Double, ()))
16:44:12 <lambdabot>  "Either (Maybe [Int]) (Double,())"
16:44:16 <mdmkolbe|work> wy: see Dependant Types; Scrap Your Boilerplate (Data.Generics, Data.Typeable); and Data.Dynamic
16:44:17 <wy> Oh, let me repeat my question about quotient types. I wonder if anyone has heard of it somewhere?
16:44:30 <EvilTerran> wy, Data.Ratio?
16:44:31 <mdmkolbe|work> wy: for info about types as value
16:44:46 <wy> mdmkolbe|work: Thanks
16:44:50 <HairyDude> timthelion: have you tried turning buffering off? sometimes that causes surprising behaviour
16:44:54 <augustss_> wy: yes, why?
16:45:01 <wy> EvilTerran: I guess it's not what I want
16:45:24 <HairyDude> dunno that that will actually help though
16:45:30 <sorear> wy: You know about quotients in group theory and topology?
16:45:31 <EvilTerran> what do you mean by "quotient types", then, wy?
16:45:38 <sorear> wy: Same idea.
16:45:42 <wy> augustss_: So it's a type with a different equality relation
16:45:52 <Newbie> i have a newbie question for you, if on ghci i puted let [(x,y)] = Array.assocs (Array.listArray(1..26)['a'..'z']
16:45:53 <timthelion> HairyDude: I have hSetBuffering stdout NoBuffering
16:45:55 <augustss_> wy: yep
16:46:04 * HairyDude shrugs
16:46:12 <EvilTerran> timthelion, have you tried flushing the stream manually?
16:46:22 <EvilTerran> iirc, some setups can't autoflush for whatever reason
16:46:25 <wy> augustss_: I wonder if it's a fundamental thing. Can I implement it using some more fundamental elements?
16:46:26 <timthelion> EvilTerran: is that hFlush stdout ?
16:46:31 <Newbie> how can i acces px to [X,Y] into position [2]?
16:46:31 <EvilTerran> I think so
16:46:33 <timthelion> because I have taht
16:46:56 <EvilTerran> i don't know, then O.o
16:47:08 <timthelion> grrr
16:47:29 <sorear> Newbie: [(x,y)] is a pattern which matches a single element list
16:47:34 <int-e> Newbie: that looks strange. what are you trying to do?
16:47:42 <mauke> Newbie: <interactive>:1:45: parse error on input `..'
16:47:43 * timthelion shakes his little fists at the evil debian, and cries "IT WORKED ON UBUNTU!?"
16:47:44 <int-e> > zip [1..26] ['a'..'z']
16:47:46 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(10...
16:48:06 <EvilTerran> newbie, what are you trying to do?
16:48:11 <wy> EvilTerran: So you see its meaning. I don't know how worthy it is.
16:48:17 <Newbie> > Array,assocs (Array.listArray (1,26)['a'..'z'])
16:48:17 <lambdabot>  Parse error
16:48:24 <augustss_> wy: you can make a free data type and the use some equivalence relation to quotient it.  In Haskell you can use an abstract data type.
16:48:46 <sorear> wy: Consider binary trees (Data.Set)
16:48:50 <wy> augustss_: You mean type classes?
16:48:54 <kpreid> Newbie: you typed Array,assocs instead of Array.assocs
16:49:00 <Newbie> Array.assocs (Array.listArray (1,26)['a'..'z'])
16:49:17 <sorear> wy: you don't want to know about the pattern of forking, so we hide it
16:49:49 <Newbie> sorear thanks
16:50:07 <augustss_> wy: no, no need for classes.  Haskell already has several quotient types, like Ratio, Data.Set, etc
16:50:14 <sorear> augustss_: kowey wants a creator of haskell to write in the WB - not sure of the details but the idea was in HC&AR
16:50:15 <wy> sorear: To do that, you assumed the type has an operation called equality?
16:51:07 * EvilTerran doesn't know what is meant by "quotient type" in this context
16:51:23 <int-e> Newbie: that code constructs an array only to produce a simple list - that's silly.  zip  can accomplish the same thing in an easier way.
16:51:24 <wy> augustss_: So my question evolved into "Is equality different from other operations?"
16:51:41 <augustss_> wy: well, you have to assume some kind of equality.  it doesn't have to be exposed to the user necessarily.  but you need some conceptual equality
16:52:07 <wy> augustss_: How do you do quotient types in Haskell?
16:52:25 <augustss_> wy: Haskell's == should not be confused with equality.  they may or may not be the same
16:52:26 <mux> > 2 % 3
16:52:41 <lambdabot>  thread killed
16:52:41 <lambdabot> mux: You have 1 new message. '/msg lambdabot @messages' to read it.
16:53:09 <mux> ew, 2 days ago
16:53:15 * dcoutts recommends JaffaCake's paper "Faster laziness using dynamic pointer tagging" as a good read
16:53:16 <dcoutts> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
16:53:17 <lambdabot> Title: Faster laziness using dynamic pointer tagging
16:53:31 <EvilTerran> jaffacake?
16:53:46 <augustss_> wy: there's no atomatic way to quotient a free type with an equivalence relation in Haskell
16:54:22 <sorear> EvilTerran: JaffaCake
16:54:23 <wy> augustss_: So do you need to define a new class for that?
16:54:23 <augustss_> wy: but you can do it by hand
16:54:33 <wy> augustss_: sorry new type
16:54:41 <augustss_> wy: why a class?  just make an abstract type
16:54:42 <sorear> EvilTerran: Known to uncool non-#haskellers as "Simon Marlow"
16:55:17 <wy> augustss_: For example I want some numbers that are considered equal when x = y mod n
16:55:23 * dcoutts was eating Jaffa Cakes in the room next door to JaffaCake yesterday
16:55:57 <augustss_> wy: so implement an abstract type, make a newtype from Integer , but define your own Eq
16:56:02 <Newbie> so whith  [(x,y) | (x,y) <- zip (1..26)['a''..z']] i would have more than one element, isnt true¿
16:56:28 <mauke> that list comprehension looks redundant
16:56:44 <wy> augustss_: So it's like type MyInt = Integer
16:56:48 <Saizan> Newbie: you would get them all
16:56:54 <sorear> wy: No!
16:56:58 <EvilTerran> wy, "newtype MyInt = MyInt Integer"
16:57:02 <Newbie> :Saizan thanks
16:57:06 <augustss_> wy: newtype MyInt = M Integer
16:57:33 <Saizan> Newbie: if for example you want the first you should write let (x:xs) = zip [1..26] ['a'..'z'] in x
16:57:47 <EvilTerran> Newbie, i suggest you have a look at
16:57:47 <wy> augustss_: Is it the same as datatype MyInt = M Integer?
16:57:55 <EvilTerran> @tutorial
16:57:55 <lambdabot> Unknown command, try @list
16:57:59 <EvilTerran> @where tutorial
16:57:59 <lambdabot> http://www.haskell.org/tutorial/
16:58:01 <sorear> wy: No, datatype is a syntax error
16:58:08 <EvilTerran> wy, you too.
16:58:24 <sorear> EvilTerran: that tutorial has fallen out of favor
16:58:32 <augustss_> wy: it's almost the same
16:58:36 <Newbie> so if i want (14,'n') ?
16:58:37 <EvilTerran> well, what do you suggest, sorear?
16:58:48 <Newbie> Saizan:
16:58:57 <EvilTerran> ...i don't like to just tell people to "RTFM", but it does help to to look over a tutorial or two when first starting out in a language.
16:59:01 <Saizan> uhm just to confirm an intuition, Data.Set is the quotient type defined as <binary tree>//<same elements> ?
16:59:07 <sorear> @where+ tutoral The tutorial which used to be at this @where has fallen out of favor.  YAHT is generally preferred now.
16:59:07 <lambdabot> Done.
16:59:20 <EvilTerran> @where yaht
16:59:20 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:59:27 <kpreid> sorear: tutoral?
16:59:32 <Saizan> or even the haskell wikibook..
16:59:42 <sorear> kpreid: Yah :(
16:59:53 <wy> augustss_: data MyInt = M Integer. I confused with ML just now ;-)
16:59:58 <sorear> @where+ tutoral <deleted>
16:59:58 <lambdabot> Done.
17:00:37 <wy> sorear_: data MyInt = M Integer. I confused with ML just now. So what's the difference with newtype?
17:00:58 <EvilTerran> wy, newtype can only have one constructor
17:00:59 <Newbie> Well, my english is very poor and its a hard job to understand TFM, i stay reading 3 days ago all kind of tutorials, and i only have c++ notions so.. u can understand how dificult is for me learn haskell
17:01:10 <EvilTerran> the constructor can only have one parameter
17:01:14 <Newbie> thanks all
17:01:16 <EvilTerran> but it performs better than a data
17:01:25 <kpreid> wy: newtypes have no runtime cost and don't introduce a new sort of bottom
17:01:32 <Saizan> Newbie: to index an element of a list you can use the !! operator
17:01:47 <Saizan> > [0..10] !! 7
17:01:48 <lambdabot>  7
17:01:59 <Newbie> Saizan: i would study it, t mate
17:02:11 <EvilTerran> wy, and (as a GHC extension) more classes can be derived for a newtype than a data
17:02:14 <wy> kpreid: Why can't the compiler recognized datatypes with only one constructor and reduce them to newtype?
17:02:27 <EvilTerran> wy, there's subtly different semantics
17:02:40 <augustss_> because they are not semantically equivalent
17:02:49 <kpreid> would data A = A !B be the same as a newtype?
17:02:54 <EvilTerran> with newtype Foo = Foo Int, Foo undefined = undefined
17:03:01 <augustss_> close, but not quite
17:03:15 <EvilTerran> but with data Foo = Foo Int, Foo undefined can be differentiated from undefined
17:04:25 <chessguy> Procyon112, ping
17:04:25 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
17:04:25 <Newbie> cu tomorrow cya all
17:05:13 <chessguy> @clear
17:05:13 <lambdabot> Messages cleared.
17:05:22 <chessguy> @seen Procyon112
17:05:23 <lambdabot> Procyon112 is in #haskell-blah, #gentoo-haskell and #haskell. I last heard Procyon112 speak 29m 14s ago.
17:08:48 <EvilTerran> hrm... I'm writing a TH template fn that creates a data decleration, but it's complaining "Not in scope: type constructor or class `NewTypeName'" if i try to do $(declTemplate ''NewTypeName ...). how do I get around that?
17:09:04 <EvilTerran> do I have to just mkName "NewTypeName"?
17:09:40 <lispy> EvilTerran: wish i could help, but it's been too long since i played with TH
17:09:52 <lispy> EvilTerran: if you try that, mkName does it help?
17:10:09 <EvilTerran> well, it works
17:10:32 <dons> moin
17:11:42 <lispy> hy dons
17:11:44 <lispy> er hey
17:14:05 <wy> augustss_: So that's a minor difference. Then how do you define the new equality? Use Instance Eq MyInt where... ?
17:15:00 <EvilTerran> wy, yes.
17:15:15 <jfoutz> is there a version of zip in the standard libraries that's picky about the lists being the same length?
17:15:28 <EvilTerran> instance Eq MyInt where M x == M y  =  ...
17:15:57 <wy> EvilTerran: So that falls into type classes.
17:16:13 <EvilTerran> wy, indeed it does
17:16:21 <EvilTerran> jfoutz, see for yourself:
17:16:24 <EvilTerran> @docs Data.List
17:16:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
17:16:25 <dons> ?users
17:16:25 <lambdabot> Maximum users seen in #haskell: 342, currently: 309 (90.4%), active: 51 (16.5%)
17:16:33 <dons> oh, new high score
17:16:37 <dons> ?users #xmonad
17:16:37 <lambdabot> Maximum users seen in #xmonad: 33, currently: 25 (75.8%), active: 14 (56.0%)
17:16:45 <EvilTerran> (i don't think so, tho)
17:16:59 <Mitar> is there possible to have somethin like:
17:17:01 <dons> the HCAR is out, btw everyone! http://programming.reddit.com/info/1urk9/details
17:17:01 <jfoutz> EvilTerran: yes, i looked at the lib, but was afraid i was being dumb.
17:17:02 <lambdabot> Title: Haskell Communities and Activities Report - 12th Ed. (reddit.com)
17:17:08 <Mitar> if debug then putStrLn "foo bar"
17:17:09 <Mitar> ?
17:17:22 <wy> I've also heard of universes. Is that something Haskell support?
17:18:37 <EvilTerran> ?type when
17:18:37 <sorear> wy: Yes, Haskell supports univers
17:18:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:18:48 <sorear> wy: We only have one however, namely *
17:18:51 <SamB> wy: you have to implement them yourself
17:18:56 <EvilTerran> Mitar, when debug $ putStrLn "foo bar"
17:19:01 <sorear> er, no, we have two
17:19:03 <SamB> or are you talking about another kind of universe?
17:19:03 <sorear> * and []
17:19:08 <wy> sorear: So that's the same thing as kinds?
17:19:14 <sorear> wy: No.
17:19:15 <Mitar> thanks ..
17:19:29 <EvilTerran> Mitar, when is in Control.Monad, btw
17:19:41 <sorear> wy: this is type theory arcana, which I'm not really qualified to explain
17:19:45 <sorear> @time mattam
17:19:48 <lambdabot> Local time for mattam is Thu May 31 02:18:12 2007
17:19:57 <sorear> mattam: awake?
17:20:14 <EvilTerran> actually, where're you trying to do this debug instruction? it will only work in an IO context
17:20:26 <wy> sorear: I'm reading a paper about Nuprl proof system, and I couldn't quite understand universes
17:20:34 <sorear> EvilTerran: unsafePerformIO
17:20:48 <Saizan> ?type trace
17:20:49 <EvilTerran> sorear, yes, but that's asking for trouble
17:20:50 <lambdabot> Not in scope: `trace'
17:20:51 * SamB was thinking of the kind of universe in which we live
17:21:05 <int-e> @type Debug.Trace.trace
17:21:07 <EvilTerran> especially for people just starting out in the language
17:21:07 <lambdabot> forall a. String -> a -> a
17:21:16 <wy> SamB: :-)
17:21:29 <wy> SamB: We are living in a matrix
17:22:03 <SamB> I'm just trying to figure out how you'd do lazy initialization
17:22:23 <dibblego> SamB, by observing
17:22:29 <dibblego> SamB, everything else is a thunk
17:23:06 <wy> augustss_: Are you augustss or a faker? hehe
17:23:08 <SamB> did I forget to say "efficiently"?
17:23:26 <Mitar> EvilTerran, it is in IO context ... i have it already around ... i just want to disable it (conditonally)
17:23:48 <EvilTerran> righto. that's okay then.
17:24:00 <Mitar> and i know about Debug.Trace ...
17:24:00 <EvilTerran> just checking.
17:24:01 <Mitar> thanks ...
17:24:25 <Mitar> i will discover very fast that it could not be used outside IO context :-)
17:24:32 <Mitar> s/will/would/
17:25:19 <SamB> dibblego: the obvious implementation would be the 3d zipper analogue of []
17:25:29 <dons> did people see the reduceron!!
17:25:41 <dons> http://programming.reddit.com/info/1usod/comments
17:25:42 <lambdabot> Title: Reduceron: a processor for executing Haskell programs on FPGA ! (reddit.com)
17:25:45 <SamB> dons: is that some kind of subatomic particle?
17:25:48 <dons> mod wildly up :-)
17:26:11 <sorear> dons: What ever happened to Implementing functional languages on stock hardware? :)
17:26:13 <dibblego> I'm over reddit
17:26:19 <lispy> so it converts haskell software into haskell hardware?
17:26:27 <dons> sorear: :-)
17:26:42 <dons> can't write verified network devices with stock hardware
17:26:49 <dons> @seen SyntaxNinja
17:26:49 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 4d 1h 12m 41s ago, and .
17:26:59 <lispy> and .
17:27:01 <wy> lispy: Good idea
17:27:06 <sorear> lispy: And .
17:27:20 <sorear> lispy: if you really don't like it, right a patch
17:27:29 <sorear> lispy: we're very lazy about cosmetic bugs
17:27:40 <lispy> sorear: i want to know what else lambdabot was going to say
17:27:49 <SamB> oooh
17:27:52 <SamB> added bonus
17:27:57 <augustss_> it's very cool that someone is doing haskell on fpgas.  but it will not easily beat a pc on real programs
17:27:58 <SamB> it comes with non-bit-rotted Lava!
17:28:07 <lispy> sorear: and if i write any lambdabot patches in the near future it will be to fix lambdaweb, i'm very sad it's broken :(
17:28:26 <dons> i like how they have a fib benchmark :-) very old school.
17:28:47 <augustss_> dons: yes.  and fib 10
17:29:03 <lispy> "Yes, here at Fib Inc, we do like to run fib on the baremetal."
17:29:25 <augustss_> one reason it can't outperform a pc is that you can't connect a fast enough memory bus
17:29:52 <sorear> even thinking about a memory bus is a sign your brain is lost
17:30:11 <sorear> we need to seal everything Neumann wrought off from the youth
17:30:18 <augustss_> memory is all that matters
17:30:34 <dibblego> sorear++
17:31:00 <Raystm2> hello.
17:31:11 <Raystm2> thanks to sorear for mentioning this chat.
17:31:16 <sorear> hello.
17:31:40 <augustss_> sorear: if you're willing to take a huge cut in the number of bits you can store then you can make other designs
17:31:55 <dons> come on guys, mod up, we can't let the anti-lambda enemies win! http://programming.reddit.com/info/1usod/details
17:31:56 <lambdabot> Title: Reduceron: a processor for executing Haskell programs on FPGA ! (reddit.com)
17:32:09 <Raystm2> hi sorear. I've done a BNF parser in toka-forth with full intention of using it to describe a lambda language and to show how all three are related.
17:32:33 <sorear> augustss_: And it matters? 99% of the memory in a computer is used for disgusting hacks like caches that are only needed because of VonNeumann
17:32:37 <Raystm2> Haskell is new for me, so if anyone would like to steer an old man in the right direction...
17:32:46 <Raystm2> It would be appreciated. :)
17:32:52 * Raystm2 checks out topic links.
17:33:16 <dibblego> Raystm2, I recommend YAHT if you're interested in learning Haskell
17:33:17 <dibblego> ?where yaht
17:33:18 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:33:28 <sorear> Raystm2: try /topic, most irc clients won't display our whole topic without an explicit request
17:34:06 <augustss_> sorear: 99% of the transistors are not taken by caches
17:34:36 <augustss_> at least not if you count the half transistors in the DRAM
17:34:38 <Raystm2> sorear: does it end with: "3 years running."
17:34:39 <Raystm2> ?
17:34:53 <sorear> Raystm2: It does.
17:35:04 <Raystm2> dibblego: thank you.
17:35:09 <sorear> augustss_: Right.  And what do you use 80% of your DRAM for?
17:35:11 * Raystm2 checks out dibblego's link.
17:36:18 <Raystm2> dibblego: double thanks :)
17:36:20 <mauke> sorear: is the answer porn?
17:36:23 <sorear> Raystm2: Oh, I'd assumed you were a veteran haskeller since characters 4-6 of your nick are one of our buzzword features
17:36:26 <dibblego> Raystm2, no problem, enjoy :)
17:36:39 <dibblego> Raystm2, also, please feel free to ask questions in the channel as you go
17:36:57 <dibblego> sorear, I assumed that too :)
17:37:00 <sorear> mauke: Caches.  (which I think most porn is a subtype of)
17:37:06 <Raystm2> no sorry, my name really. Raymond ( Arther) St. Marie jr.
17:37:15 <sorear> hehe
17:37:27 <sorear> people always think I have a sore ear or something
17:37:38 <sorear> Stefan O'REAR actually
17:37:40 <dibblego> Raystm2, STM is Software Transactional Memory - a research topic with lots of attention at the moment
17:37:45 <Raystm2> I thought so rear but that says much about my mind so...
17:37:51 <Raystm2> :)
17:37:55 <lispy> sorear: ah, i thought it was like, soooo rear
17:38:07 <migraine_> I just always have a migraine on work days
17:38:14 <Raystm2> dibblego: /me googles it. not familure.
17:38:26 <dibblego> sore rear is funnier, so I thought it was that (actually I didn't, even since I saw Stefan O'Rear on the mailing list)
17:38:28 <mauke> @where stm
17:38:28 <lambdabot> http://haskell.org/haskellwiki/Software_transactional_memory
17:38:32 <sorear> Raystm2: Think database transactions for your variables.
17:38:50 <Raystm2> hehe :) gotta like bots
17:39:09 <sorear> @botsnack
17:39:09 <lambdabot> :)
17:39:14 <Raystm2> thanks mauke.
17:39:24 <sorear> @version
17:39:24 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
17:39:24 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:39:33 <sorear> public source code
17:41:12 <kfish> ?where+ reduceron http://www-users.cs.york.ac.uk/~mfn/reduceron/index.html
17:41:12 <lambdabot> Done.
17:41:18 <jfoutz> so, how is STM coming along? is there some worry all the do atomically blocks would be run serially anyway?
17:42:55 <dons> i'm surprised this only has one vote, http://programming.reddit.com/info/1usod/comments :/
17:42:56 <lambdabot> Title: Reduceron: a processor for executing Haskell programs on FPGA ! (reddit.com)
17:43:39 <lispy> dons: well, i just don't see the point of reddit
17:44:26 <Raystm2> dons I have to assume that you are lambdabot Don? no?
17:44:30 <dons> lispy: its one of our few channels to the outside world in here, language
17:44:33 <dons> lispy. grr
17:44:38 <dons> Raystm2: correct.
17:44:54 <sorear> @where stats
17:44:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
17:45:03 <sorear> look at the 2007 active nicks
17:45:22 * HairyDude waits for some (deliberately) horrendously inefficient programs to run.
17:45:29 <dons> sorear: ?
17:46:01 <sorear> dons: knowing who the regulars are may be desirable
17:46:12 <dons> ah, yes, for new users?
17:46:27 <Excedrin> dons: Hyperterminal is a key component in that system, how can anyone vote it up? (kidding, I voted it up)
17:46:45 <thoughtpolice> dons: pretty cool. +1
17:47:12 <sorear> > fix(\x->0:1:[x!!k|m<-[1..],k<-[m,6*m+4]])
17:47:14 <lambdabot>  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:47:20 <sorear> > fix(\x->0:1:[1+x!!k|m<-[1..],k<-[m,6*m+4]])
17:47:21 <lambdabot>  [0,1,2,8,3,6,9,17,4,20,7,15,10,10,18,18,5,13,21,21,8,8,16,16,11,24,11,112,19...
17:47:38 <emu> i clearly don't blab enough in here
17:47:45 <Raystm2> Pleasure to make the aquaintence of this chat.
17:47:57 <Saizan> i'm 25 :O
17:48:13 * sorear likes being the best^?^?^?^?most active human
17:48:13 <Raystm2> I've got you on autojoin so ... and I have Asperger's--- just a warning. :) hehe
17:48:21 <cdsmith> Now that it's a competition, I guess I'll start talking more. :)
17:48:31 * sorear does too and does too (on paper at least)
17:48:53 <emu> i do have a portal to the outside world though
17:49:00 <emu> and i intend on taking it in a moment
17:49:01 <chessguy> welcome, Raystm2
17:49:02 <lispy> Raystm2: you won't be the only member of #haskell with Asperger's
17:49:05 * emu walks out the door
17:49:46 <Raystm2> I'm way behind and catching up to the list here but LAMBDA IN THE CHAT that's hot!
17:50:01 <chessguy> @bot
17:50:01 <lambdabot> :)
17:50:12 <chessguy> @quote lambdabot
17:50:13 <lambdabot> lambdabot says: Of course i'm female
17:50:29 <augustss_> @quote
17:50:29 <lambdabot> pozorvlak says: You could always shell out to perl :-)
17:50:30 <Raystm2> lispy, makes sence to me.
17:50:34 <sorear> λλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλy
17:50:47 <augustss_> jaha
17:50:57 <sorear> @quote
17:50:58 <lambdabot> Procyon says: There should be a law against 16 year olds giving me algorithms that break my head.
17:51:07 <chessguy> ha!
17:51:09 <augustss_> haha
17:51:13 <chessguy> that was probably about sorear, too
17:51:20 <Saizan> surely :D
17:51:38 <dolio> It's hard to say. We have so many 16-year-olds around here. :)
17:52:46 <Raystm2> i'm 16(2.6875)
17:52:49 <emu> pseudonym wrote filthy words 0.0% of the time!
17:52:54 <emu> i think i can win this competition
17:52:58 <emu> crap!
17:53:03 <SamB> who modded my comment down?
17:53:05 <chessguy> > 16*2.6875
17:53:06 <lambdabot>  43.0
17:53:22 <chessguy> @stats
17:53:22 <lambdabot> Unknown command, try @list
17:53:25 <chessguy> @stat
17:53:25 <lambdabot> Maybe you meant: slap what
17:53:30 <chessguy> @where stats
17:53:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
17:53:33 <emu> @slap chessguy
17:53:33 <lambdabot> why on earth would I slap chessguy
17:53:44 <chessguy> @slap emu
17:53:44 * lambdabot beats up emu
17:53:55 <emu> well i just added to that statistic
17:54:06 <sorear> Raystm2: No instance Num (a -> b)
17:54:44 <Raystm2> right right.
17:54:47 <Raystm2> okay okay.
17:54:47 <chessguy> how is it that Cale isn't on IRC for like a week but he's still the #3 most talkative human on #haskell?
17:54:58 <Raystm2> gotta think different.
17:55:19 <sorear> How is it that kc5tja has been gone for 2 weeks and promised to never return, but is still #16 ?
17:55:43 <chessguy> @seen kc5tja
17:55:43 <lambdabot> I saw kc5tja leaving #haskell 12d 5h 59m 29s ago, and .
17:55:50 <int-e> chessguy: 5 months is a long time.
17:55:59 <Saizan> promised to never return?
17:56:08 <sorear> Saizan: Yep.
17:56:18 <chessguy> int-e, these stats are just about this month
17:56:19 <Raystm2> he used to do that in #forth and then DID leave and never went back. Heck that was the day that I met him and he's been in #c4th-ot ever since. Yikes i hope he doesn't mind that getting out.
17:56:28 <chessguy> i think
17:56:29 <dolio> sorear: Because he racked up hundreds of lines arguing whether energy credits are money or not while he was here? :)
17:56:31 <Raystm2> thats kc5tja I mean.
17:57:17 <SamB> @quote kc5tja
17:57:18 <lambdabot> kc5tja says: Premature evil is the root of all optimization.
17:57:20 <SamB> @quote kc5tja
17:57:20 <lambdabot> kc5tja says: Premature evil is the root of all optimization.
17:57:23 <SamB> @quote kc5tja
17:57:23 <lambdabot> kc5tja says: Premature evil is the root of all optimization.
17:57:30 <SamB> is that all?
17:57:40 <int-e> chessguy: "During this 149-day reporting period"
17:57:48 <Raystm2> ah.
17:58:12 <chessguy> int-e, yeah, hmm. i guess only that one part is about the last 31 days
17:59:05 <sorear> Raystm2: So, we can chalk this up to kc5tja's personality?
17:59:13 * sorear feels pleasantly exculpated
17:59:57 <Raystm2> Indeed k's personallity.
18:00:18 <SamB> what is with the increased activity in the middle of the week?
18:00:22 <Raystm2> He and I have been steady friends for last few years and he is good to know and hard to keep :)
18:00:59 <SamB> or is that just today and last week?
18:01:32 <chessguy> i don't know, these stats are rather unclear
18:02:32 <SamB> hmm. I've gone down a lot :-(
18:02:42 <SamB> SamB_XP isn't even on that page exactly
18:03:32 <sorear> > iterate(\x->1+1/x) 2
18:03:34 <lambdabot>  [2.0,1.5,1.6666666666666667,1.5999999999999999,1.625,1.6153846153846154,1.61...
18:03:49 <SamB> DRMacIver: supposedly you are happy
18:04:05 <sorear> > iterate(\x->1+1/x) 1.4
18:04:06 <lambdabot>  [1.4,1.7142857142857144,1.5833333333333333,1.631578947368421,1.6129032258064...
18:04:33 <sorear> > iterate(\x->x/2+1/x) 1
18:04:35 <lambdabot>  [1.0,1.5,1.4166666666666667,1.4142156862745099,1.4142135623746899,1.41421356...
18:04:36 <SamB> sorear: hey, you've replaced dons as lambdabot's follower ;-)
18:04:47 <Saizan> SamB: the stats generator can recognise that SamB and SamB_XP are the same user, sometimes.
18:04:58 <mauke> > iterate (\x -> 4/x-x) 1
18:04:59 <sorear> SamB: For several months now.
18:05:00 <lambdabot>  [1.0,3.0,-1.6666666666666667,-0.7333333333333332,-4.7212121212121225,3.87397...
18:05:02 <SamB> Saizan: oh it can do that now can it?
18:05:17 <mauke> > drop 100 $ iterate (\x -> 4/x-x) 1
18:05:18 <lambdabot>  [42.671167387835816,-42.57742727607266,42.48348078245143,-42.3893265388177,4...
18:05:19 <SamB> sorear: I probably haven't looked in months
18:05:28 <mauke> > drop 150 $ iterate (\x -> 4/x-x) 1
18:05:29 <lambdabot>  [37.700441862304,-37.5943423100863,37.487943321456385,-37.38124234920778,37....
18:05:33 <chessguy> @seen SamB_XP
18:05:33 <lambdabot> SamB_XP is in #haskell-blah and #haskell. I last heard SamB_XP speak 10h 22m 45s ago.
18:05:48 <mauke> > iterate (\x -> 4/x-x) (sqrt 2)
18:05:49 <lambdabot>  [1.4142135623730951,1.4142135623730947,1.414213562373096,1.414213562373092,1...
18:05:56 <mauke> > drop 100 $ iterate (\x -> 4/x-x) (sqrt 2)
18:05:57 <lambdabot>  [-143.40566728651146,143.37777438607253,-143.34987605931215,143.321972303062...
18:05:58 <sorear> mauke: you need something with a convergent fixpoint
18:06:00 <SamB> yes I've been hacking today.
18:06:04 <SamB> not getting much done, mind you
18:06:20 <mauke> apparently this is the opposite of a convergent sequence
18:06:43 <SamB> I love the "most used words" stats
18:06:53 <SamB> Haskell, think, would, monad
18:07:08 <chessguy> SamB, yeah, it says a lot about the channel
18:07:26 <SamB> which, right, should, function, could, where
18:08:16 <SamB> of course, the fact that Monad, which, Right, and where are all significant Haskell lexemes may be a factor...
18:08:30 <chessguy> @hoogle which
18:08:31 <lambdabot> No matches found
18:08:33 <chessguy> ?
18:08:43 <SamB> erg.
18:08:47 <SamB> sorry.
18:08:52 <SamB> not which.
18:09:11 <SamB> Monad, Right, and where though
18:11:07 <SamB> hey it looks like I've been getting more sleep lately
18:12:26 <HairyDude> wow. the memoized version of the making-change algorithm terminated in 16 seconds. the non-memoized version has been going for over 10 minutes.
18:13:13 <chessguy> what algorithm is that?
18:13:24 <TSC> That problem is pretty amenable to DP, I think
18:13:47 <HairyDude> TSC: yup
18:13:48 <TSC> So I would expect it to improve dramatically
18:14:21 <HairyDude> TSC: the non-memoized version is just the recursive definition. the memoized version is basically an automatic implementation of the DP version of the same
18:14:36 <SamB> is that script still buggy WRT kicks?
18:15:51 <chessguy> HairyDude, !paste?
18:15:59 <sorear> @wiki Dynamic_programming_example
18:15:59 <lambdabot> http://www.haskell.org/haskellwiki/Dynamic_programming_example
18:15:59 <chessguy> i'd be curious to see the 2 versions
18:16:02 <sorear> chessguy: ^^
18:16:29 <SamB> horrors! Pseudonym and monochrom curse 0.0% of the time!
18:16:53 <sorear> HairyDude: So what did you think of the Optimization section I wrote?
18:17:17 <HairyDude> chessguy: well explaining it fully would involve also giving you all of the memoization machinery
18:17:31 <HairyDude> chessguy: once it's finished, I can give you a copy of my dissertation if you like
18:17:42 <chessguy> lol, not necessary
18:17:46 <HairyDude> :)
18:18:48 <sorear> HairyDude: Oh, you weren't doing the wiki example?
18:18:52 <chessguy> so you have a memoize :: (a->b) -> (a->b) ?
18:18:56 <HairyDude> sorear: nope
18:20:32 <HairyDude> chessguy: it's called memoFix and its type is ((a -> b) -> a -> b) -> a -> b, but yes
18:21:06 <chessguy> ummm, ok
18:22:01 <sorear> HairyDude: you weren't joking about the dissertation thing?
18:22:37 <HairyDude> sorear: no, it really is my dissertation
18:23:52 <sorear> wow.  i'm suprised it is possible to find a phd-sized chunk of original research in that field, I thought it was pretty much completely explored
18:24:17 <SamB> which field?
18:24:18 <HairyDude> sorear: it's an undergraduate dissertation, it doesn't have to be original :)
18:25:03 <sorear> heh.  there are certainly a LOT of phd students here
18:25:15 <SamB> how many is a lot?
18:25:17 <SamB> 10?
18:26:51 <HairyDude> it's still running
18:28:52 <Raystm2> http://retroforth.com/paste/?id=400
18:29:02 <Raystm2> oops sorry wrong room :)
18:29:16 * sorear converts to hs
18:31:01 <sorear> Raystm2: Oooh looks interesting.  Where is it?
18:31:25 <Raystm2> Toka? getting link, I don't HAVE a bot.
18:31:50 <Raystm2> http://charleschilders.com:9812/
18:31:51 <lambdabot> Title: Toka Language
18:31:55 <sorear> I mean, that looks like a irc channel excerpt.
18:32:55 <Raystm2> it was.
18:33:10 <Raystm2> it was origninally in a room for something else all together.
18:36:38 <davidL> sorear: did you ever come up with a closed formula for that problem from yesterday?
18:40:13 <sorear> davidL: Not the whole thing, just f
18:40:39 <davidL> hmm
18:42:08 <mutjida> @users
18:42:08 <lambdabot> Maximum users seen in #haskell: 342, currently: 308 (90.1%), active: 46 (14.9%)
18:42:39 <fuzan> anyone here use phooey?
18:43:16 <davidL> sorear: does f use logBase 10?
18:43:43 <sorear> davidL: No.
18:44:12 <sorear> davidL: Just +*/ floor and abs
18:44:29 <SimonRC> zzzzzz
18:44:35 <SimonRC> ops, ww
18:44:48 <davidL> k, that's all the hints for now :)
18:46:10 <fuzan> :t liftA
18:46:12 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
18:46:31 <fuzan> @hoogle Applicative
18:46:32 <lambdabot> No matches found
18:47:15 <fuzan> what's the best method for looking up what objects belong to certain types, etc?
18:48:06 <HairyDude> fuzan: hoogle?
18:48:30 <cdsmith> fuzan: no, but I was reading about it last night.  I have been meaning to learn more about it.
18:49:45 <QtPlatypus>  
18:53:22 <dons> xmonad 0.2 released!
18:53:25 <Korollary> @instances Applicative
18:53:26 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
18:53:38 <dons> http://www.haskell.org/pipermail/xmonad/2007-May/000433.html
18:53:39 <lambdabot> Title: [Xmonad] ANNOUNCE: xmonad 0.2
18:53:52 <Korollary> @instances Control.Applicative
18:53:53 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
18:54:04 <Korollary> @instances-importing Control.Applicative
18:54:05 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
18:54:37 <dolio> @instances-importing Control.Applicative Applicative
18:54:38 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
18:54:45 <sorear> dons: Woo!
18:55:14 <dons> http://programming.reddit.com/info/1ut8x/comments :)
18:55:16 <lambdabot> Title: xmonad 0.2: tiling window manager, based on a Zipper structure, in Haskell (redd ...
18:55:36 <Korollary> That's lacking the contexts. It should be Monoid a => Applicative ((,) a), not just ((,) a)
18:56:50 <dolio> Yeah.
19:21:32 <emu> hulo
19:22:32 <dons> hey emu
19:23:33 <emu> how goes the world of parallel arrays
19:23:40 <dons> zippy :-)
19:24:00 <dons> rl is in cambridge this week, hacking up more stuff on that front.
19:24:28 <emu> i need to give that stuff a go now that work has lightened up
19:25:47 <emu> dons, your hs-plugins has an eval-type function.  how did you coerce GHC to give you the result of runStmt nicely?
19:26:10 <dons> doesn't use ghc-api
19:26:22 <emu> that's probably the best way
19:26:33 <dons> i'm not so sure. its a way, not sure if its the best way
19:26:41 <dons> compiled extensions are interesting, though
19:27:53 <emu> i dunno, so far the endorsed method of getting the answer from runStmt is to redirect stdout :/
19:28:26 <dons> should be possible to get an HsValue out , surely
19:28:36 <dons> yi must do tihs
19:35:45 <falconair> is there a standard regex library?  perhaps one that works with bytestrings?  I will be receiving lines of key/value pairs of various types (seperated by some delimiter), probably from a bytestring connected to a network
19:36:04 <sorear> yep, it's called "regex"
19:36:18 <sorear> but see the jwz quote
19:36:36 <sorear>      Some people, when confronted with a problem, think "I know, I*ll use regular expressions." Now they have two problems. --Jamie Zawinski, in comp.lang.emacs
19:36:58 <EvilTerran> they do have their place, mind.
19:37:00 <falconair> i see several, posix, parsec, some others ...
19:37:42 <EvilTerran> you'll struggle to find a more succinct way of doing what regexes're good at
19:38:19 <sorear> falconair: Right.  there is not much of a difference between them
19:38:30 <dons> falconair: have a look on hackage. they provide the same interface, but different backends
19:38:41 <dons> so you pick your balance of speed and portability and external dependencies
19:38:47 <dons> regex-posix is the simplest
19:40:11 <falconair> so regex-posix is the one to go with for for someone doing a first project to learn haskell?
19:53:40 <dons> sorear: be nice to people reporting bugs please.
19:54:56 * sorear grumbles
19:55:07 * sorear wishes he had more luck with this "politeness" thing
19:56:18 <dons> try the same text, but hadd 'thanks for the report! looks like a duplicate of ... . cheers, .."
19:56:29 <dons> makes a huge different to the scared guy at the other end just hoping to help
19:57:03 <SamB_XP> please don't eat me!
20:07:03 <chessguy> > 75 / 4000
20:07:04 <lambdabot>  1.875e-2
20:08:07 <hpaste>  jfredett pasted "Type errror woes, again." at http://hpaste.org/122
20:08:25 <jfredett_> if anyone feels like helping, I'd appreciate
20:08:38 <jfredett_> i'm pretty close to finishing this stupid function... :/
20:09:37 <byorgey> @type logBase
20:09:39 <lambdabot> forall a. (Floating a) => a -> a -> a
20:09:54 <byorgey> there's your problem
20:09:56 <jfredett_> yah, I've been fiddling with logBase types for a while
20:10:01 <jfredett_> I couldn't figure it out.
20:10:11 <byorgey> logBase is being applied to two arguments, so you get back a Floating something
20:10:23 <byorgey> but then you're trying to compose that with another function
20:10:31 <byorgey> maybe you mean floor $ (logBase...  ?
20:10:37 <jfredett_> right- so heres what I need to do
20:10:56 <jfredett_> I need to determine whether the log base k of x is equal to its floor, aka that its an integer.
20:11:04 <byorgey> ah, right
20:11:17 <jfredett_> that would mean that the integer is then a perfect power of k
20:11:30 <jfredett_> k is what isPPH (isPerfPowerHelp) finds
20:11:32 <byorgey> yes, then you want (floor $ (logBase (isPHH x) x))
20:11:39 <jfredett_> okay, I'll give that a go
20:11:47 <byorgey> that applies floor to the result of the call to logBase
20:11:55 <jfredett_> hmm
20:12:00 <byorgey> actually, with the parens around logBase you don't even need the $
20:12:08 <byorgey> just (floor (logBase ...
20:12:43 <jfredett_> different error, type error over the whole func, hold on I'll get the nitty gritty
20:13:03 <jfredett_> basicly a no instance for "RealFrac a"
20:13:12 <jfredett_> err, s/a/Integer
20:13:20 <jfredett_> from using floor.
20:13:25 <jfredett_> damnit.
20:13:30 <dylan> :t floor
20:13:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:14:17 <jfredett_> right, so logbase needs to return a RealFrac
20:14:17 <byorgey> just wrap the call to floor in a fromInteger?
20:14:27 <jfredett_> :t fromInteger
20:14:29 <lambdabot> forall a. (Num a) => Integer -> a
20:14:36 <jfredett_> okay
20:14:46 <jfredett_> so fromInteger is essentially a cast?
20:14:55 <jfredett_> this type theory thing is a bitch.
20:15:01 <byorgey> well, no, it's not really a cast
20:15:14 <jfredett_> so if I do fromInteger 4.39, it should be 4? maybe?
20:15:16 <byorgey> think of it as loosening the restriction on the type
20:15:19 <dons> jfredett_: it converts, according to the rules for the from and to type :-)
20:15:28 <byorgey> no, you can't call fromInteger on 4.39
20:15:33 <byorgey> you can only call it on Integers
20:15:36 <jfredett_> damn, thats right
20:15:39 <chessguy> @type fromIntegal
20:15:40 <lambdabot> Not in scope: `fromIntegal'
20:15:41 <chessguy> @type fromIntegral
20:15:43 <lambdabot> forall a b. (Num b, Integral a) => a -> b
20:15:47 <jfredett_> integer goes to the num a
20:16:00 <jfredett_> right-
20:16:06 <chessguy> @hoogle fromInteger
20:16:06 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
20:16:33 <jfredett_> :t logBase
20:16:35 <lambdabot> forall a. (Floating a) => a -> a -> a
20:17:01 <byorgey> jfredett_: all the typing stuff with numbers really annoyed me too, until I got the hang of it
20:17:03 <jfredett_> so if I do a fromFloating on that, it should bring me to somewhere where floor can act on it?
20:17:14 <jfredett_> byorgey, yah, I'll get it eventually
20:17:21 <byorgey> @type floor
20:17:23 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:17:43 <brad_> i have been trying on the side to create a poor-man's DOM in haskell. i was wondering if anyone had advice on parsing xml
20:17:59 <brad_> i tried to roll my own, a bit of a hassle
20:18:05 <brad_> hxt is too hard
20:18:20 <brad_> wonder if parsec etc is the way to go
20:18:49 <byorgey> jfredett_: erm...
20:18:55 * byorgey goes to run jfredett_'s code
20:20:28 <jfredett_> bah, there is no such thing as fromFloating... :/
20:20:36 <chessguy> @hoogle from
20:20:36 <lambdabot> Maybe.fromJust :: Maybe a -> a
20:20:36 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
20:20:36 <lambdabot> Numeric.fromRat :: RealFloat a => Rational -> a
20:20:44 <lispy> oh, cool, new release of xmonad
20:20:47 <davidL> you can truncate
20:20:48 <chessguy> @hoogle+
20:20:49 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
20:20:49 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
20:20:49 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
20:20:59 <chessguy> @hoogle+
20:20:59 <lambdabot> Prelude.fromRational :: Fractional a => Rational -> a
20:20:59 <lambdabot> Data.Dynamic.fromDyn :: Typeable a => Dynamic -> a -> a
20:20:59 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
20:21:29 <chessguy> @hoogle+
20:21:30 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
20:21:30 <lambdabot> Data.IntMap.fromAscList :: [(Key, a)] -> IntMap a
20:21:30 <lambdabot> Data.IntMap.fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
20:24:44 <chessguy> > 204 / 33
20:24:47 <lambdabot>  6.181818181818182
20:24:59 <chessguy> 600% return on my investment, nice
20:25:15 <jfredett_> what investment?
20:25:20 <chessguy> chips :)
20:25:42 <chessguy> 54th place in a 4000-player tourney
20:26:05 <chessguy> > 54 / 4000
20:26:06 <lambdabot>  1.35e-2
20:26:15 <jfredett_> mb
20:26:45 <davidL> poker?
20:26:49 <chessguy> yup
20:26:56 <jfredett_> cool
20:27:01 <chessguy> NL holdem, the only way to play
20:27:08 <davidL> NL haha
20:27:11 <davidL> texas ftw
20:27:20 <byorgey> jfredett_: grr, I can't get this to type correctly either =(
20:27:34 <byorgey> jfredett_: my advice would be to decompose it into more smaller functions
20:27:42 <jfredett_> lol
20:27:47 <jfredett_> sounds like more type theory fun
20:27:52 <jfredett_> maybe its godel's fault
20:27:54 <byorgey> jfredett_: that would make it easier to make sure each function is typed correctly and works in isolation
20:27:55 <chessguy> what code are you guys trying to work on?
20:27:56 <jfredett_> and its untypable
20:27:57 <jfredett_> :P
20:28:09 <byorgey> chessguy: http://hpaste.org/122
20:28:11 <jfredett_> whats wierd
20:28:17 <jfredett_> this does work in isolation, as I remember
20:28:28 <byorgey> jfredett_: what does?
20:28:38 <jfredett_> oh, nvm
20:28:46 <jfredett_> its an ambiguous type error
20:28:52 <jfredett_> hmm
20:29:01 <chessguy> @hoogle isPPH
20:29:01 <lambdabot> No matches found
20:29:09 <chessguy> ...
20:29:16 <byorgey> jfredett_: nested where clauses says to me, "decompose"! =)
20:29:30 <chessguy> what type is isPPH?
20:29:37 <chessguy> oh, i see it
20:29:44 <jfredett_> heh, that wasn't necessary
20:29:56 <jfredett_> i had actually just decomposed it a bit
20:30:03 <byorgey> jfredett_: ah, ok =)
20:30:04 <jfredett_> isPPH was isPerfPower before
20:30:51 <chessguy> @type \x -> foldr (*) 1 [k | k <- takeWhile (\ a -> a <= logk 2 x) primes, x `divides` k]
20:30:52 <lambdabot> Not in scope: `logk'
20:30:53 <lambdabot>  
20:30:53 <lambdabot> <interactive>:1:61: Not in scope: `primes'
20:31:07 <davidL> try getting rid of the dot after floor?
20:31:14 <jfredett_> yah, primes is an infinite list of primes
20:31:21 <byorgey> davidL: yes, we already figured that out
20:31:28 <davidL> oh
20:31:30 <jfredett_> logk is just a floor . logBase k . fromInteger
20:31:33 <jfredett_> which works fine
20:31:39 <davidL> someone should annotate it :)
20:31:41 <jfredett_> its the =='s part thats broken
20:32:02 <chessguy> yeah, this needs to be decomposed a lot
20:32:11 <chessguy> this is ridiculous
20:32:23 <chessguy> there's no reason not to decompose it
20:32:55 <hpaste>  jfredett annotated "Type errror woes, again." with "(no title)" at http://hpaste.org/122#a1
20:33:27 <jfredett_> whatdya mean, chessguy I'm not sure what you mean by decompose? It's already pretty small, and that new peice is just a hack to see if it would work
20:33:34 <jfredett_> thats the operation i need to do
20:33:58 <jfredett_> its the types that are being problematic
20:33:58 <byorgey> jfredett_: decompose, as in separate it into multiple individual functions
20:34:13 <chessguy> e.g., you have logBase (isPPH x) x twice
20:34:21 <jfredett_> right-
20:34:32 <jfredett_> i need to learn how to do exporting of specific functions
20:34:39 <byorgey> jfredett_: so make that into a new function of x
20:34:43 <jfredett_> instead of all this silliness
20:34:56 <chessguy> and if the types are so problematic, break all the locally defined functions into top-level functions, and check their types
20:35:06 <jfredett_> okay, i'll try that
20:35:11 <jfredett_> it makes sense, i suppose
20:35:42 <chessguy> and...i don't think you need the nested where's
20:36:13 <jfredett_> I already mentioned that that was just a recent thing
20:36:24 <jfredett_> i forgot to change that when I annotated
20:36:33 <jfredett_> isPPH was isPerfPower before
20:36:40 <jfredett_> i just pushed it down a ways
20:36:49 <jfredett_> to work with the last part autonomously
20:36:56 <chessguy> ugh, i don't have a haskell compiler on this machine yet :(
20:37:30 <hpaste>  jfredett annotated "Type errror woes, again." with "(no title)" at http://hpaste.org/122#a2
20:37:41 <jfredett_> thats my most recent version, more or less
20:37:50 <davidL> isPPH returns a bool?
20:38:47 <davidL> hmm nope
20:39:00 <jfredett_> no, a integer
20:39:05 <davidL> weird name to give to a function with type Integer
20:39:07 <jfredett_> the product of the primes which divide x
20:39:21 <jfredett_> like i said, it was isPerfPower before I pused it down
20:39:29 <jfredett_> and isPerfPowerHelp was to long
20:39:36 <jfredett_> it'll get a name change later
20:39:45 <davidL> :)
20:40:01 <jfredett_> I have a horrible practice of 2-4 letter names up untill the last minute
20:40:08 <jfredett_> i lazily evaluate my function names
20:40:09 <jfredett_> :P
20:40:46 * dolio pre-plans his Haskell programs using State of the Art UML diagrams!
20:41:13 <jfredett_> silly dolio, UML is for kids!
20:41:51 <chessguy> @pl \x -> l (i x) x)
20:41:51 <lambdabot> (line 1, column 16):
20:41:52 <lambdabot> unexpected ")"
20:41:52 <lambdabot> expecting variable, "(", operator or end of input
20:41:58 <chessguy> @pl \x -> l (i x) x
20:41:59 <lambdabot> l =<< i
20:42:03 <chessguy> oooooh
20:42:17 <dons> heh
20:42:25 <dons> that's a good one
20:43:25 <davidL> @hoogle (RealFrac a, Floating b) => a -> b
20:43:26 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
20:43:26 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
20:43:26 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
20:43:35 <davidL> ...
20:45:46 <chessguy> @hoogle divides
20:45:46 <lambdabot> No matches found
20:45:52 <mutjida> is there an automatic way to update packages after updating ghc?
20:46:19 <davidL> > floor (logBase 10 923)
20:46:21 <lambdabot>  2
20:47:29 <davidL> > floor (logBase 10 923) == (logBase 10 923)
20:47:30 <lambdabot>  Add a type signature
20:48:38 <jfredett_> turns out isPPH is the radical function
20:48:41 <jfredett_> which is handy.
20:48:42 <davidL> > 1 == 1.0
20:48:43 <lambdabot>  True
20:49:01 <davidL> > 1 == (1.0::Float)
20:49:02 <lambdabot>  True
20:49:29 <davidL> > (1::Int) == (1.0::Float)
20:49:31 <lambdabot>  Couldn't match expected type `Int' against inferred type `Float'
20:50:12 <chessguy> ?hoogle logBase
20:50:13 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
20:52:03 <chessguy> @hoogle Integer -> Floating
20:52:03 <lambdabot> No matches, try a more general search
20:52:12 <chessguy> ?src Floating
20:52:12 <lambdabot> class  (Fractional a) => Floating a  where
20:52:12 <lambdabot>     pi                                                      :: a
20:52:12 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
20:52:12 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
20:52:12 <lambdabot>     (**), logBase                                           :: a -> a -> a
20:52:21 <chessguy> @instances-importing Floating
20:52:22 <lambdabot> Double, Float
20:52:36 <chessguy> @hoogle fromIntegral
20:52:37 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
20:53:28 <davidL> :t floor(logBase 10 349)
20:53:30 <lambdabot> forall b. (Integral b) => b
20:53:54 <davidL> :t fromIntegral(floor(logBase 10 349))
20:53:56 <lambdabot> forall b. (Num b) => b
20:54:01 <davidL> :t fromIntegral(floor(logBase 10 349))::Float
20:54:03 <lambdabot> Float
20:54:18 <hpaste>  byorgey annotated "Type errror woes, again." with "(no title)" at http://hpaste.org/122#a3
20:54:19 <chessguy> @hoogle floor
20:54:19 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
20:54:35 <byorgey> does that work?
20:55:17 <byorgey> jfredett_: I'm not exactly clear on what the code is supposed to do so I'm not 100% sure I didn't make a mistake refactoring it
20:55:33 <byorgey> jfredett_: but it typechecks! =)
20:58:11 <hpaste>  chessguy annotated "Type errror woes, again." with "I think what i came up with is equivalent" at http://hpaste.org/122#a4
20:59:22 <byorgey> chessguy: yup, pretty much the same
20:59:45 <byorgey> chessguy: except I added another "fromInteger" to logk which makes the type a lot nicer
21:00:07 <chessguy> well, i was a few minutes behind since i had to install GHC :)
21:00:18 <byorgey> chessguy: ah, details =)
21:00:33 <jfredett_> goodness
21:01:12 <chessguy> @quote stero
21:01:12 <lambdabot> No quotes match. stty: unknown mode: doofus
21:01:16 <chessguy> @quote stereo
21:01:16 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
21:01:21 <chessguy> almost applies :)
21:01:29 <jfredett_> the code is supposed to determine if the number is a perfect power, that is, if it's of the form a^b for some a and some exponent b
21:02:03 <byorgey> jfredett_: ok, I get it
21:02:15 <chessguy> so, does it work?
21:02:22 <byorgey> jfredett_: Project Euler??
21:02:27 <jfredett_> yep
21:02:36 <chessguy> i assume a and b are integers
21:02:40 <jfredett_> i'm actually working on an implementation of AKS right now
21:02:48 <byorgey> AKS?
21:02:48 <jfredett_> chessguy, your assumption is correct
21:03:01 <jfredett_> AKS is a primality proving algorithm that runs in Polynomial time
21:03:02 <chessguy> yep it works, or yep it's for Euler?
21:03:02 <davidL> jfredett_: which problem?
21:03:13 <jfredett_> @google Primes in P
21:03:16 <lambdabot> http://www.math.princeton.edu/~annals/issues/2004/Sept2004/Agrawal.pdf
21:03:26 <byorgey> jfredett_: oh, yes, I remember reading about that
21:03:29 <jfredett_> i'm working on 10/11 right now
21:03:36 <jfredett_> i've done more under the name KermitDFrog
21:03:43 <jfredett_> but i didn't save any of the code
21:03:57 <chessguy> well that was pretty dumb
21:04:01 <jfredett_> so I'm redoing them all in Haskell in an effort to teach myself (and eventually other people, I hope)
21:04:16 <davidL> heh!
21:04:24 <jfredett_> chessguy, I mostly did it for a pastime
21:04:26 <chessguy> so does the code work or not?
21:04:27 <davidL> I've always wondered wether kermit was my math teacher
21:04:27 <jfredett_> and i did it in VB
21:04:34 <chessguy> oh my
21:04:44 <jfredett_> oh, shizzle, i should go fix that code.
21:05:04 <chessguy> do you have your definition of primes handy, or should i code one up
21:05:11 <byorgey> jfredett_: Project Euler is how I learned J =)
21:05:23 <jfredett_> i can get you one, it's not the best in the world, but i use:
21:05:33 <chessguy> never mind, got one
21:05:37 <davidL> > let foo a = a `elem` [ x^y | x <- [1..100], y <- 100 ] in foo 4
21:05:39 <jfredett_> cool
21:05:41 <lambdabot>   add an instance declaration for (Num [t])
21:05:42 <lambdabot>     In a list comprehension: y <-...
21:05:53 <davidL> > let foo a = a `elem` [ x^y | x <- [1..100], y <- [1..100] ] in foo 4
21:05:55 <lambdabot>  True
21:06:06 <davidL> > let foo a = a `elem` [ x^y | x <- [1..100], y <- [1..100] ] in foo 51
21:06:07 <lambdabot>  True
21:06:22 <davidL> > let foo a = a `elem` [ x^y | x <- [1..100], y <- [1..100] ] in foo 23
21:06:23 <lambdabot>  True
21:06:59 <byorgey> > 40^40
21:07:01 <lambdabot>  12089258196146291747061760000000000000000000000000000000000000000
21:07:11 <chessguy> wait, do a and b have to be primes?
21:07:14 <byorgey> ok, just checking that it used Integers by default =)
21:07:22 <davidL> > let foo a = a `elem` [ x^y | x <- [1..100], y <- [1..100] ] in foo 12089258196146291747061760000000000000000000000000000000000000000
21:07:24 <lambdabot>  True
21:07:42 <chessguy> [(1,False),(2,True),(3,True),(4,True),(5,True),(6,False),(7,True),(8,True),(9,Tr
21:07:42 <chessguy> ue),(10,False),(11,True),(12,False),(13,True),(14,False),(15,False),(16,True),(1
21:07:42 <chessguy> 7,True),(18,False),(19,True),(20,False)]
21:07:53 <davidL> > let foo a = a `elem` [ x^y | x <- [1..100], y <- [1..100] ] in foo 12
21:07:54 <lambdabot>  True
21:07:56 <davidL> ...
21:08:10 <davidL> is it supposed to be primes?
21:08:44 <jfredett_> hmm, doesn't seem to be working
21:08:50 <jfredett_> no, a and p can be anything
21:08:59 <jfredett_> i'm using an algorithm taken from wikipedia
21:09:06 <jfredett_> that i verified to be more or less correct
21:10:00 <jfredett_> b*
21:10:16 <davidL> a and b have to be greater than 1 right?
21:10:20 <byorgey> jfredett_: which problem is this again?
21:10:27 <jfredett_> yah, unless n = 1
21:10:40 <jfredett_> this is part of the implementation of the AKS algorithms
21:10:45 <jfredett_> algorithm*
21:10:49 <jfredett_> not PE
21:10:56 <jfredett_> i'm writing it for future use
21:10:57 <byorgey> oh, ok, I was confused
21:11:03 <davidL> > let foo a = a `elem` [ x^y | [x,y] <- replicateM 2 [2..100] ] in foo 12
21:11:05 <lambdabot>  False
21:11:08 <davidL> there we go
21:11:25 <jfredett_> the function is supposed to determine whether n = a^b for some integral a and b
21:11:40 <chessguy> errm
21:11:42 <jfredett_> so I have it as just a predicate
21:11:54 <jfredett_> but i suppose you could write it as
21:12:01 <chessguy> n = n^1 ?
21:12:28 <chessguy> is n not integral?
21:12:32 <jfredett_> no, b is strictly greater than one
21:12:39 <chessguy> you might have told us that
21:12:42 <jfredett_> no, n is integral to
21:12:58 <byorgey> hmm... it doesn't seem to work for 36
21:13:03 <jfredett_> damnit! i don't know, so many types, brain type error, ambiguous types!
21:13:04 <jfredett_> aahh
21:13:10 <davidL> > let foo a = a `elem` [ x^y | [x,y] <- replicateM 2 [2..100] ] in foo 36
21:13:11 <lambdabot>  True
21:13:14 <jfredett_> it should return true
21:13:18 <jfredett_> 6^2
21:13:18 <chessguy> where's the wikipedia article?
21:13:22 <byorgey> oh, wait, duh =)
21:13:24 <jfredett_> perfect powers
21:13:32 <byorgey> I was stuck on the primes thing
21:13:35 <jfredett_> lol
21:13:44 <jfredett_> okay, here's the full definition:
21:13:46 <lispy> :t replicateM
21:13:47 <byorgey> looks like it works to me then
21:13:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
21:13:56 <jfredett_> isPerfPower takes an integer, n
21:14:11 <jfredett_> and returns a boolean indicating whether n can be written in the form
21:14:26 <jfredett_> a^b, for some integers a and b, with b > 1
21:14:27 <chessguy> for perfect powers <= 100, i'm getting this list: [2,3,4,5,7,8,9,11,13,16,17,19,23,25,27,29,31,32,36,37,41,43,47,49,53,59,61,64,67,71,73,77,79,81,83,89,91,97,100]
21:14:44 <jfredett_> you shouldn't get 2,3, etc.
21:14:49 <davidL> > let foo a = a `elem` [ x^y | [x,y] <- replicateM 2 [2..100] ] in filter foo [1..100]
21:14:50 <lispy> what about 71?
21:14:51 <lambdabot>  [4,8,9,16,25,27,32,36,49,64,81,100]
21:15:09 <jfredett_> it should look like [k^b | k <- [1..], b<-[2..
21:15:15 <dmead> > [x | x <- [1..20]]
21:15:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
21:15:28 <jfredett_> [k^b | k <- [1..], b<-[2..]]
21:15:30 <dmead> > [(x * 20) | x <- [1..20]]
21:15:32 <lambdabot>  [20,40,60,80,100,120,140,160,180,200,220,240,260,280,300,320,340,360,380,400]
21:15:36 <lispy> it seems the perfect powers <= 100 list above includes primes and their powers
21:15:41 <dmead> > [(x * 20 / 3) | x <- [1..20]]
21:15:43 <lambdabot>  [6.666666666666667,13.333333333333334,20.0,26.666666666666668,33.33333333333...
21:15:44 <EvilTerran> jfredett_, surely you can't say that, tho, 'cos you'll never get past k=1
21:15:47 <jfredett_> >[k^b | k <- [1..5], b<-[2..3]]
21:15:48 <dmead> > [(x * 20 / 4) | x <- [1..20]]
21:15:49 <lambdabot>  [5.0,10.0,15.0,20.0,25.0,30.0,35.0,40.0,45.0,50.0,55.0,60.0,65.0,70.0,75.0,8...
21:15:57 <chessguy> dmead, what are you doing?i
21:16:30 <chessguy> lispy, not primes
21:16:32 <jfredett_> as a set, it should be worded as {a^b : a in N, b in N, with b > 1}
21:16:45 <dmead> chessguy, messing
21:16:55 <lispy> chessguy: but it included numbers like 53 which are prime
21:17:04 <jfredett_> N is the numbers, Integers or Natural, doesn't really matter, dependds on what you nee
21:17:09 <byorgey> jfredett_: ok, well right now it looks like isPerfPower works, except that it's giving b=1 as well
21:17:28 <chessguy> lispy, oh, you mean the list i gave. well, that list isn't right
21:17:45 <lispy> jfredett_: i dunno, i was taught N is naturals, either starting at 0 or 1, and Z is the integers meaning they go negative and include zero
21:18:32 <lispy> and just to be careful we used to write N \union {0}, or N / {0}, to be clear
21:18:50 <dmead> ?src union
21:18:50 <lambdabot> union = unionBy (==)
21:18:55 <dmead> ?src unionBy
21:18:55 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
21:18:57 * EvilTerran 's intuitive solution is [ a^n | i <- [3..], a <- [1..i], let n = i-a ] (zigzag argument, like for proving Q countable or whatever), but that's got loads of duplicates
21:19:15 <chessguy> byorgey, do you understand the algorithm well enough to figure out where to fix that?
21:19:31 <byorgey> chessguy: I think so
21:19:34 <lispy> i would use mod
21:19:35 <byorgey> chessguy: working on it
21:19:42 <dmead> EvilTerran, so just filter it
21:19:51 <EvilTerran> could nub it...
21:20:01 <dmead> nub
21:20:01 <dmead> hehe
21:20:11 <dmead> nub should be implemented in lolcode
21:20:11 <EvilTerran> > nub [ a^n | i <- [4..], a <- [2..i], let n = i-a ]
21:20:12 <lambdabot>  [4,3,1,8,9,16,27,5,32,81,64,25,6,243,256,125,36,7,128,729,1024,625,216,49,21...
21:20:26 <EvilTerran> yay for somewhat arbitrary ordering
21:20:47 <EvilTerran> wait, that'snotright
21:20:58 <dmead> ?src nub
21:20:59 <lambdabot> nub = nubBy (==)
21:21:00 <lispy> > let foo n = gcd (product [1..floor (sqrt n)]) n in foo 36
21:21:01 <lambdabot>  Add a type signature
21:21:02 <dmead> ?src nubBy
21:21:09 <lambdabot> nubBy eq []             =  []
21:21:13 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:21:17 <lispy> > let foo n = gcd (product [1..floor (sqrt n)]) n in foo 36 :: Int
21:21:30 <lambdabot>        add an instance declaration for (RealFrac Int, Floating Int)
21:21:34 <lambdabot>     In th...
21:22:44 <jfredett_> byorgey, hmm
21:22:50 <jfredett_> well at least it works
21:23:15 <chessguy> jfredett_, for some definition of 'works'
21:23:17 <byorgey> yup, it's close...
21:23:37 <EvilTerran> > nub [ a^n | i <- [4..], n <- [2..i-1], let a = i-n ]
21:23:38 <lambdabot>  [4,1,9,8,16,27,25,64,81,32,36,125,256,243,49,216,625,1024,729,128,343,1296,3...
21:23:47 <EvilTerran> that looks better. the complexity is terrible, tho
21:24:09 <byorgey> jfredett_: wait, why does the isPPH (i.e. radical) function only take primes up to the log base 2 of x?
21:24:17 <byorgey> shouldn't that be sqrt of x?
21:24:50 <EvilTerran> dmead, lolcode looks like a fun idea, but i was looking at the site earlier, and it's a complete mess. there's no canonical formalisation at all
21:25:16 <jfredett_> well, i'm not honestly sure, but thats what the article said
21:25:16 <EvilTerran> they're designing syntax for OOP, semaphores, cl
21:25:21 <jfredett_> so I went with it
21:25:34 <jfredett_> so I said, I'll prove it later
21:25:34 <byorgey> jfredett_: can you paste a link to the article?
21:25:36 <dmead> EvilTerran, maybe they'll come out with a formal spec :)
21:25:37 <EvilTerran> *continuations, etcetc, even tho they haven't settled on even conditionals' syntax
21:25:39 <jfredett_> yah
21:25:51 <jfredett_> its http://en.wikipedia.org/wiki/Perfect_power
21:25:51 <lambdabot> Title: Perfect power - Wikipedia, the free encyclopedia
21:26:41 <jfredett_> its on hpaste too, i thought I had added that earlier..
21:26:53 <jfredett_> they mention that you can do this over the primes
21:27:29 <byorgey> jfredett_: hmm, I think the article is wrong...
21:27:33 <jfredett_> i think that the theory is that any integer can be represented (theoretically) as 2^k -1
21:27:49 <jfredett_> maybe
21:27:56 <byorgey> for example, log_2 25 is 4.something
21:28:03 <jfredett_> like i said, I haven't delved into the proof
21:28:07 <byorgey> if you only look for factors of 25 up to 4, you won't find 5
21:28:16 <jfredett_> and the paper at the bottom of the page is horribly bad.
21:28:22 <byorgey> heh
21:28:28 <jfredett_> hmm
21:28:42 <jfredett_> try isPerfPower on 25
21:28:45 <jfredett_> see what it says
21:29:12 <jfredett_> we'll know fo sho after that
21:29:13 <jfredett_> lol
21:29:25 <jfredett_> I may have to shoot my computer if thats the case
21:29:30 <EvilTerran> could someone clarify something for me... if you want instance Arrow Foo, then foo should take at least two type parameters, right?
21:29:50 <SamB_XP> two and only two
21:29:50 <byorgey> jfredett_: well, it worked on 25 before, but for the wrong reason I think
21:30:00 <EvilTerran> exactly two? okay. yeah, that makes more sense.
21:31:06 <chessguy> :k Arrow
21:31:08 <lambdabot> Class `Arrow' used as a type
21:31:20 <chessguy> @instances-importing Arrow
21:31:21 <lambdabot> (->), Kleisli m
21:31:28 <chessguy> :k (->)
21:31:30 <lambdabot> ?? -> ? -> *
21:33:44 <jfredett_> hmm.
21:33:49 <jfredett_> well that sucks
21:33:57 <byorgey> jfredett_: hmm, the problem is the implementation of the radical function
21:34:05 <jfredett_> if it won't work for all integers, than i guess I'm back to square one
21:34:14 <byorgey> jfredett_: no offense, but it turns out it's all kinds of wrong =)
21:34:25 <jfredett_> well, I know I can do gcd (primorial something) x
21:34:33 <byorgey> jfredett_: let me think about it for a minute...
21:34:44 <jfredett_> i take no offense, i didn't set out to right radical
21:34:46 <jfredett_> it just kindof happened
21:36:03 <byorgey> ohhhhhhhh
21:36:06 <byorgey> I get it now
21:36:07 <jfredett_> i wish the article (effectively linear time perfect power algorithm) was better written
21:37:18 <byorgey> wow, that wikipedia article is really horribly written
21:37:32 * byorgey is three kinds of not surprised
21:38:06 <jfredett_> lol, well, once we figure it out, I'll rewrite it
21:38:17 <byorgey> the k up to log_2 x thing is looking for possible *powers*.
21:38:21 <jfredett_> Perfect powers is a kind of obscure topic to run into
21:38:49 <byorgey> So what you do is factorize x, then run through prime values of k up to log_2 x, and try raising the factors to the k power
21:38:59 <jfredett_> hold up
21:38:59 <byorgey> or something like that
21:39:04 <jfredett_> if I'm factorizing x
21:39:20 <jfredett_> then why the frak do i need a primality algorithm.. thats silly.
21:39:32 <byorgey> jfredett_: hmm, a valid point =)
21:39:37 <byorgey> jfredett_: hang on...
21:39:39 <jfredett_> byorgey, hmm
21:39:56 <jfredett_> byorgey, its too nice that the current isPerf almost works
21:40:00 <jfredett_> its too convienent
21:40:12 <byorgey> jfredett_: yeah...
21:40:15 <jfredett_> i think that the method could be fixed.
21:40:34 <jfredett_> i mean- we know that and n = 2^k - 1
21:40:36 <jfredett_> err
21:40:40 <jfredett_> n <= 2^k -1
21:41:21 <jfredett_> that is, its the sum of some number of powers of 2 from 0 to k-1
21:41:40 <jfredett_> so if n = a^b, then a^b <= 2^k - 1
21:42:02 <byorgey> right, which is why you only need to search for values of k up to log_2 n
21:42:13 <jfredett_> right-
21:42:43 <jfredett_> but in practice (and granted my algorithm is likely to be wrong)
21:42:50 <jfredett_> that doesn't seem to work at 25
21:42:57 * EvilTerran pokes arrows some more
21:43:02 <jfredett_> 25 <= 2^5 - 1
21:43:06 <jfredett_> OH!
21:43:13 <byorgey> jfredett_: but your code was multiplying together all the possible values of k, which doesn't seem right
21:43:18 <jfredett_> change that logk 2 x to have a cieling.
21:43:23 <jfredett_> i think that'll fix it
21:43:29 <jfredett_> i'm searching one to low
21:43:41 <jfredett_> its not multipling all vals of k
21:43:45 <jfredett_> well, its not supposed to
21:44:07 <jfredett_> so wait- hang on
21:44:12 <byorgey> foldr (*) 1 [k | k <- takeWhile (\ a -> a <= logk 2 x) primes, x `divides` k]
21:44:20 <jfredett_> right-
21:44:29 <jfredett_> i got confused and thought that was finding a
21:44:40 <jfredett_> because if a = radical x
21:45:01 <jfredett_> then log_a x => integral if x is a perfect power
21:45:07 <byorgey> jfredett_: indeed.
21:45:15 <byorgey> jfredett_: but that code doesn't compute the radical.
21:45:20 <jfredett_> right
21:45:30 <byorgey> jfredett_: and computing the radical is basically no easier than factoring anyway
21:45:33 <byorgey> I think
21:45:37 <jfredett_> well
21:45:52 <jfredett_> you can do it by taking the primorial up to the largest prime factor
21:45:57 <jfredett_> and then doing a gcd
21:46:05 <jfredett_> the issue is you cant know the largest prime factor
21:46:26 <jfredett_> so in practice, computing gcd x (primorial x) => v. v. hard
21:46:45 <byorgey> jfredett_: not hard, just slow =)
21:47:01 <jfredett_> either way
21:47:05 <jfredett_> we dont want to do that
21:47:09 <byorgey> jfredett_: indeed.
21:47:18 <byorgey> tell you what, I should really go to bed...
21:47:21 <jfredett_> lol
21:47:25 <byorgey> but I will take a look at that paper tomorrow =)
21:47:26 <jfredett_> me too
21:47:30 <jfredett_> don't
21:47:37 <jfredett_> it'll make you dumber for reading it
21:47:45 <jfredett_> its about the worst written thing I've read in a while
21:48:02 <byorgey> fair enough, but I'm interested now =)
21:48:06 <byorgey> I'll at least give it a try
21:48:08 <jfredett_> he spends 4 pages talking about integers and floating point numbers
21:48:13 <jfredett_> and 2 actually talking about the algo.
21:48:14 <jfredett_> :/
21:48:19 <jfredett_> its silly
21:48:26 <jfredett_> he does suggest binary search... hm
21:48:27 <byorgey> ok, thanks for the warning... I'll skip the first 4 pages =D
21:48:36 <jfredett_> i dunno- gnite
21:48:43 <byorgey> goodnight!
21:52:33 * EvilTerran ponders expressing something similar to http://hackage.haskell.org/trac/haskell-prime/ticket/114 as an arrow
21:52:39 <lambdabot> Title: #114 (introduce lambda-match (explicit match failure and fall-through)) - Haskel ...
21:54:20 <EvilTerran> but it looks like you'd need to do something dodgey involving Control.Exception.PatternMatchFail
21:54:26 <EvilTerran> in order to implement arr
21:54:35 <EvilTerran> and that'd be very fallible
21:55:50 <EvilTerran> (what happens if some pattern other than the one you intended to catch failures on fails?)
21:56:11 <EvilTerran> and it'd also involve the joys of unsafePerformIO if i wanted to deal with the exceptions transparently...
21:56:37 <EvilTerran> huh. network's being very shakey.
21:57:18 <Korollary> Need to write an irc server in haskell maybe
21:57:54 <EvilTerran> hehe. 30 lines thereof, 8 of which are imports. :P
22:02:41 <notsmack> anybody use Yi regularly?
22:24:21 <dibblego> is there a way of writing reverse in O(n) time that uses whatever empty list that is at the end to terminate it?
22:26:05 <dolio> > foldr (flip (:)) [1 .. 5] [6 .. 10]
22:26:06 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
22:26:06 <lambdabot>       Expected...
22:26:16 <dibblego> > let reverse = reverse' [] {- without the need to pass this argument -}; reverse' acc [] = acc; reverse' acc (x:xs) = reverse' (x:acc) xs in reverse [1..10]
22:26:16 <dolio> > foldl (flip (:)) [1 .. 5] [6 .. 10]
22:26:18 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
22:26:18 <lambdabot>  [10,9,8,7,6,1,2,3,4,5]
22:27:02 <dibblego> that still requires an empty case essentially
22:27:13 <dibblego> > foldl (flip (:)) [1 .. 10] []
22:27:15 <sieni> I don't understand your question. An empty list is an empty list. It's always the same regardless of where you use it
22:27:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
22:27:36 <dibblego> I have a type, for which I can ask "is it empty", but I cannot create an empty one
22:28:43 <dibblego> I want to reverse it; I have everything else e.g. cons, head, tail
22:29:07 <sieni> well, then you probably have to scan through the list to find an empty element and then use that as an argument to reverse'
22:29:17 <sieni> but that's ok, it will still be O(n)
22:29:20 <dibblego> that's two list traversals
22:29:30 <dibblego> yes, really I only want one list traversal
22:29:41 <sieni> How do you plan to do it?
22:29:44 <dibblego> I don't
22:29:52 <dibblego> I'm not sure it's possible :)
22:30:01 <mauke> hmm
22:30:07 <sieni> You can only construct a list by consing stuff into an existing list.
22:30:11 <dibblego> perhaps, keep a pointer to the last element of the reeversed list
22:30:28 <sieni> and if you don't have a constructor for an empty list, you have to find one.
22:30:49 <dibblego> well, it's not exactly a list; imagine it's a type class and [] is just one instance
22:31:00 <dibblego> it's not even Haskell to be truthful :)
22:31:29 <sieni> work ->
22:34:29 <dolio> > let r l@([]) = (id, l) ; r (x:xs) = let (f, n) = r xs in (f . (x:), n) in uncurry ($) (r [1..10])
22:34:30 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
22:34:30 <mauke> dibblego: I may have a solution
22:34:41 <mauke> I'm still trying to understand how it works
22:34:51 <dolio> Bam!
22:34:52 <dibblego> I'm trying to write it all in Haskell, because it's easier
22:35:29 <mauke> rev l = let (r, n) = rev' n l in r where
22:35:30 <mauke>     rev' n xs
22:35:30 <mauke>         | null xs = (n, xs)
22:35:30 <mauke>         | otherwise = rev' (head xs : n) (tail xs)
22:36:44 <dolio> mauke: That should be 'let ... in r n', no?
22:36:50 <mauke> no
22:36:57 <mauke> r is a list, not a function
22:37:11 <dolio> Oh, Hmm...
22:37:47 <dolio> Oh, wait, I see. You're tying the knot.
22:38:11 <dolio> Cute.
22:38:14 <hpaste>  dibblego pasted "here is an approximation of what I am doing" at http://hpaste.org/123
22:40:10 <mauke> dibblego: that interface sucks
22:40:24 <dibblego> I agree
22:40:43 <mauke> I want headTail :: a b -> Maybe (a, a b) or headTail :: a b -> (a, a b) and isEmpty :: a b -> Bool
22:42:30 <dolio> Well, mauke's solution is more clever than mine, although it may not be easy to translate into a language without lazy evaluation.
22:42:56 <dibblego> I have lazy evaluation, just no multi-parameter type-classes
22:44:12 <hpaste>  mauke annotated "here is an approximation of what I am doing" with "working version" at http://hpaste.org/123#a1
22:44:20 <dibblego> I'm just having trouble reading it, switching between languages
22:44:57 <dibblego> {-# LANGUAGE MultiParamTypeClasses #-} is that a GHC annotation so I don't need -fglasgow-exts?
22:45:13 <mauke> it's supposed to be portable across implementations, I think
22:45:23 <dibblego> thanks for the solution by the way
22:45:35 <mauke> -fglasgow-exts is ghc-specific (and enables much more)
22:50:11 <dibblego> I wonder if proponents of Creationism subscribe to the 'False before True'  philosophy
22:50:33 <mauke> > False < True
22:50:42 <lambdabot>  True
22:50:58 <dibblego> lambdabot trumps Creationists?
22:52:14 <vlm> > False == False
22:52:15 <lambdabot>  True
22:52:45 <mauke> > [minBound .. maxBound] :: [Bool]
22:52:46 <lambdabot>  [False,True]
22:53:16 <vlm> > cycle [False]
22:53:17 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
22:53:24 <mauke> data Boolean = True | False | FileNotFound deriving (Eq, Ord, Enum, Bounded, Read, Show)
22:53:43 <dibblego> wasn't that on a website?
22:53:58 <mauke> yes
22:54:08 <dibblego> a parody of someone's code
22:54:21 <mauke> no, that code was real
22:54:35 <dibblego> I don't doubt it
22:54:48 <dibblego> I lost my stash of IBM code
22:55:04 <dibblego> some of that was quite amusing
22:56:38 <dibblego> let (r, n) = rev' n l in r -- can this be converted to a 'where'?
22:57:22 <mauke> r where (r, n) = rev' n l
22:57:22 <mauke> I guess
22:57:23 <dolio> dibblego: Incidentally...
22:57:32 <dolio> > let rev l = foldl (flip (:)) (dropWhile (const True) l) l in rev [1..10]
22:57:33 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
22:57:40 <dolio> That's still O(n) :)
22:57:52 <dolio> Just traverses twice. :)
22:58:25 <dibblego> yeah, I really meant one traversal, instead of O(n)
23:01:14 <goalieCa> lol.
23:01:34 <goalieCa> 40 mins
23:01:35 <goalieCa> jeez
23:02:07 <bos> @seen sorear
23:02:07 <lambdabot> sorear is in #happs, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 6m 39s ago.
23:03:28 <bos> sorear: what's this about the non-threaded RTS going away?
23:10:04 <sorear> it's not compatible with the concurrent ffi spec, and it doebles rts build time
23:10:36 <sorear> @users
23:10:36 <lambdabot> Maximum users seen in #haskell: 342, currently: 298 (87.1%), active: 23 (7.7%)
23:15:36 <bos> hmm, i wonder what the threaded RTS does with multiple file descriptors. one OS thread per FD?
23:16:34 <bos> the commentary is a bit thin on that.
23:16:39 <quicksilver> I shouldn't think so
23:16:45 <quicksilver> I imagine it still uses select()
23:16:52 <quicksilver> one OS thread per FD would be terribly heavyweight
23:17:07 <sjanssen> bos: there's an IO manager that selects() across blocked threads
23:17:58 <notsmack> Configuring yi-0.3...
23:17:58 <notsmack> setup: cannot satisfy dependency yi-lib>=0.3
23:18:10 <bos> ah, in posix/Signals.c
23:19:15 * notsmack found it
23:27:55 <bos> oh, i see. most (but not all) of the IO manager is written in Haskell
