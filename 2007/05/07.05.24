00:02:27 <Korollary> qog: Did you try ghc users mailing list? There's also a #ghc.
00:03:02 <ivanm> This is weird.... I compile my program using ghc <compilation flags> --make GenPremCrits.lhs
00:03:12 <ivanm> and normally it creates an executable called GenPremCrits
00:03:23 <ivanm> but just now, it instead created one called GenPremCrits_unop
00:03:27 <ivanm> anyone know why?
00:03:57 <qog> Good call, I'll try that.
00:04:19 <Korollary> ivanm: No idea. I typically specify the exe name explicitly via -o.
00:04:29 <ivanm> Korollary: *nod*
00:11:04 <ivanm> and now its not creating an executable at all... :s
00:11:49 <fuzan> anyone have any idea where sorear's ran off to?
00:12:08 * DRMacIver is occasionally astonished at how cunning compiler optimisations in Haskell can be.
00:12:49 <ivanm> "I have a cunning plan!" :p
00:13:47 <DRMacIver> (I'm just reading the stream fusion paper as some light reading prior to waking up properly. Rewrite rules are a very nice feature)
00:14:50 <ivanm> light reading?
00:14:58 <ivanm> you're even weirder than I am, DRMacIver
00:15:01 <ivanm> ;-)
00:15:13 <DRMacIver> I possibly wasn't being entirely serious in that description. :)
00:16:45 <DRMacIver> Although it's relatively light.
00:17:18 <DRMacIver> It's one of those "That's really neat. I wouldn't have thought of that." ideas rather than "My head explodes at merely trying to contemplate this paper"
00:17:57 <edwardk> what interests me about them is that with mixed lazy and strict semantics you could do both forms of fusion. one in the absence of seq, and the other when the terms are used strictly. nice little case for substructural types being held around while you play with rewrite rules
00:22:14 <ivanm> why won't ghc link anymore? :s
00:22:24 <larsen> Morning.
00:22:36 <ivanm> afternoon
00:22:39 <ivanm> ;-)
00:23:32 <earthy> hm. sounds like a nice paper to read before going to bed then. ;)
00:31:27 <ski_> (ivanm : lemmings ?)
00:31:39 <ivanm> lemmings?
00:33:23 <ski_> http://home.wanadoo.nl/lemmings-solution/lemmings/lemmings_tricky_levels21-30.html#level%2026
00:33:26 <lambdabot> Title: The Lemmings Solution - Lemmings Rating Tricky - Levels 21-30, http://tinyurl.com/2ppurl
00:34:35 <ivanm> ski_: nope, they probably stole the quote from the same place I did
00:34:44 <ivanm> @google "I have a cunning plan" baldric
00:34:46 <lambdabot> http://www.askandyaboutclothes.com/forum/showthread.php?p=500840
00:34:59 <ski_> ah, black adder, i take ?
00:35:10 * earthy nods
00:35:21 <ivanm> yup
00:35:30 <earthy> the funny atkinson. :)
00:35:40 <ivanm> heh
00:35:46 <ivanm> season 4 is the best, IMHO
00:39:19 <DRMacIver> Well, stream fusion is all very well, but I suppose I'd better go write documentation for boring Java web services instead. Sigh.
00:43:27 <ivanm> heh
01:05:03 <DRMacIver> ivanm: It's much less funny when you actulaly have to do it. :)
01:05:15 * DRMacIver is looking forward to having a job he actually likes.
01:05:45 <ivanm> well, I don't have to write docs for it, but I've got to learn how to make web pages + use jsp + connect to an oracle database for my stupid project management subject :s
01:05:50 <shiva> hi guys
01:05:57 <ivanm> and that's bad enough, so I don't really envy you :p
01:06:01 <ivanm> hey shiva
01:07:05 <shiva> hi
01:07:45 <shiva> what's ur name?
01:08:42 <paris> hio
01:12:25 * ivanm == Ivan
01:12:39 <ivanm> hence my IRC nick :p (surname starts with "M")
01:14:03 <dons> weird.
01:18:26 <ivanm> lol
01:18:39 <ivanm> dons: so where did you get your nick from? :p
01:18:52 * dons == Don
01:18:58 <dons> hence my IRC nick :p (surname starts with "S")
01:19:00 <ivanm> no, really? :o
01:19:01 <ivanm> ;-)
01:19:04 <ivanm> jk
01:19:07 <dons> hl
01:19:34 * ivanm isn't familiar with "hl"
01:19:42 <dons> actually, i stole it as part of an identity theft scheme with Don Syme
01:19:48 <ivanm> ahhhh.....
01:19:52 <ivanm> and who's Don Syme?
01:19:59 <dons> ?google Don Syme
01:20:01 <lambdabot> http://research.microsoft.com/~dsyme/
01:20:01 <lambdabot> Title: Don Syme, Microsoft Research
01:20:18 <dons> F# guy.
01:20:38 <quicksilver> Similarly, my name is 'Quicksilve', and my surname starts with an 'R'
01:20:47 <dons> yeah
01:20:55 <dons> hey Quicksilve.
01:21:23 <quicksilver> hey
01:21:25 <ivanm> actually, I stole mine from the serial killer responsible for the Backpacker murders... ;-)
01:21:34 <dons> ah yes that's a good one.
01:21:38 <ivanm> :D
01:21:47 <ivanm> now, let's see if any non-aussies get it...
01:22:07 <TSC> Haha
01:23:05 <ivanm> just like after the kosovo conflict, dumb people kept getting his name mixed up with the former president of yugoslavia
01:23:13 <dons> ha
01:23:29 * ivanm hopes people know who he's talking about
01:23:49 <ivanm> but yeah, my dad would say "no, he's my uncle" :p
01:24:31 <dons> hah
01:25:11 <ivanm> anyway, dinner time
01:25:23 <dons> yes! good idea.
01:34:02 <therp> finally some spare time, xmonad I'm coming
01:34:30 <dons> yay!
01:34:39 <ski_> B . L . T0 . B . B . L . T0 . L . T1 . T0 . L . T1 . T1 . I $ (0,((1,2),3)) :: Tree Int
01:34:44 <dons> good timing therp , we're days away from tagging 0.2
01:36:37 <therp> dons: fine! :) any work on the xft front yet?
01:36:49 <dons> regarding what?
01:37:03 <therp> dons: xft bindings and maybe using them in xmonad
01:37:17 <dons> none that i know of. what would they provide?
01:37:18 <therp> I'm not sure how much text xmonad displays
01:37:23 <dons> none :-)
01:37:29 <therp> dons: subpixel rendered fonts
01:37:37 <therp> or freetype rendered fonts in general
01:37:42 <dolio> @pl e >>= return
01:37:42 <lambdabot> e
01:37:48 <dons> that's for the client, in xmonad's case. it renders no text
01:38:00 <dons> a pure window manager :-)
01:38:11 <therp> no side-effects -> no text printing :)
01:38:45 <dons> xmonad :: Window a => [a] -> [(a,layout)]
01:38:47 <dons> :-)
01:40:59 <dons> therp: got any interesting ideas on how to tile a plane with rectangles holding X clients?
01:41:34 <therp> dons: I'm afraid no. my windows setup is most boring. dual screen => two maximized clients
01:41:47 <dons> ah well. that's easy then
01:41:58 <dons> you want a wm that supports fullscreen and xinerama.
01:42:00 <dons> i know of one.
01:42:08 <therp> dons: a friend of mine told me recently (after switching from ion3) that he really likes the dynamic way of handling space in wmii
01:42:30 <dons> its pretty similar to xmonad, iirc.
01:42:31 <therp> dons: doesn't xmonad support xinerama?
01:42:39 <dons> yes that's the one i was thinking of.
01:42:49 <dons> ;-)
01:42:54 <therp> ah no xinerama bindings.. right? ..
01:43:12 <dons> no, it supports xinerama fully. my joke fell flat.
01:43:23 <dons> e.g. http://xmonad.org/images/screen-jcreigh.png
01:43:32 <dons> actually 2/3 xmonad devs use >=2 screens.
01:43:36 <psnl> w/in 20
01:43:44 <quicksilver> l/ose 20
01:43:53 <dons> also supports randr, so you can plug in monitors on the fly
01:43:53 <mornfall> hm, i just switched -to- ion3
01:43:57 <LordBrain> is #{ } a common FFI thing?
01:44:09 <dons> mornfall: oh man, that's going against the trend :-) didn't you read the license ;-)
01:44:12 <quicksilver> dons: that's an unusual sort of 'screen shot' :)
01:44:17 <mornfall> dons: which one? :-)
01:44:23 <therp> dons: oh nice :)
01:44:45 <dons> mornfall: ion's license controversy :-) (bit of an in-joke, sorry)
01:45:02 <dons> quicksilver: we really should get the recursive version up for 0.2
01:45:11 <therp> dons: the license controversy itself is a joke :)
01:45:39 <dons> mornfall: also , you'll have to hand back your #haskell license, unless you try xmonad :-)
01:45:46 <LordBrain> what does it mean if i see something like this?:  #{peek RECT,left}
01:46:00 <quicksilver> LordBrain: I think that's a c2hs directive?
01:46:01 <dons> that's an hsc2hs pragma
01:46:12 <dons> it'll generate some peek code for the field of some C struct
01:47:08 <mornfall> dons: :(
01:48:06 <dons> :( :| :/ :- :\ :| :) :D
01:49:07 <mdmkolbe|work> dons: is there an xmonad that works with Cygwin?
01:49:17 <dons> gee. do any unix wms work on windows?
01:49:23 <quicksilver> sure
01:49:25 <mdmkolbe|work> dons: yes
01:49:28 <quicksilver> most of them do
01:49:30 <dons> if you can run X, then yes.
01:49:34 <quicksilver> (given an appropriate X server)
01:49:46 <dons> untested though.
01:49:57 <quicksilver> those that don't, fail if they rely on some parts of POSIX which cygwin doesn't implement perfectly
01:50:00 <quicksilver> that sort of thing
01:50:11 <dons> cygwin should be ok, the use of posix is very limited
01:50:16 <mdmkolbe|work> dons: but I don't think there is a cygwin ghc, only a windows ghc (which might not link against libX11)
01:50:18 <mornfall> dons: hmmmm, nice marketing for wmii ;-)
01:51:45 * therp wonders why there is x11-extras-darcs butt not x11-darcs in haskell ebuild repo
01:51:47 <dons> oh, its ok, but a bit unmaintained, weird. i used it before dwm.
01:51:48 <mornfall> somehow, xmonad is not in debian :\
01:52:16 <dons> therp: hmm. x11 1.2 might be there already, therp ?
01:53:10 <therp> dons: 1.2 is there but the xmonad readme says it doesn't work on amd64, so I hacked my own little ebuild to take a custom tar ball
01:53:20 <dons> therp: yeah, tou need 1.2.1 for 64 bit
01:53:21 <therp> darcsifying the ebuild would be better I know..
01:53:26 * therp got 1.2.1
01:53:32 <dons> sweet
01:54:10 <therp> but the x11-extra-darcs depends on 6.4.. and xmonad.ebuild wants x11-extra-darcs
01:54:33 <therp> s/xmonad.ebuild/xmonad-darcs.ebuild/
01:54:33 <dons> that's weird. cabal might be easier for this ?
01:54:54 <dons> all this darcs ebuild business is fishy, imo.
01:55:00 * quicksilver sniffs
01:55:26 <therp> hmm the xmonad-darcs ebuild seems to depend on ghc-6.4..
01:55:48 <dons> if you've got 6.6.x, i'd just use darcs + cabal. esp. if you plan on hacking.
01:56:00 <therp> yeah right..
01:56:10 * therp installs it by cabal..
01:56:32 <LordBrain> what is hsc, is that haskell or c? it looks like haskell, but i see it just #include <windows.h> at the top level
01:57:02 <dons> hsc2hs, its haskell with pragmas
01:57:07 <dons> for binding to C.
01:57:22 <dons> run through hsc2hs, generating a bunch of ffi bindings for you
01:59:15 <dons> Metabol: you're bouncing a bit.
01:59:52 <therp> Main.hs:175:8: Not in scope: data constructor `ConfigureEvent'
02:00:02 <therp> some inconsistancy with my X11 installation?
02:00:34 <dons> yeah, update X11-extras from darcs
02:00:39 <dons> missing a patch from a couple of days ago
02:00:48 <therp> ah from darcs. alright.
02:01:15 <therp> dons: you might want to add a statement to xmonad/README similarly to the one for X11: "get the darcs version!"
02:01:41 <dons> should be ok once 0.2 is tagged next week.
02:01:55 <dons> its that funny period when people want to use the new features, but they're only in darcs.
02:02:21 <dons> but yes, will do.
02:02:29 <therp> it's just a suggestion...
02:02:46 <dons> a couple of other people mentioned it today, its a good idea.
02:03:26 <dons> btw, --> #xmonad :-)
02:10:46 <mornfall> well
02:10:53 <mornfall> xmonad looks nifty, although i like the tagging approach
02:11:00 <mornfall> at least in theory
02:11:05 <mornfall> still need to try them out
02:11:48 <mornfall> hm
02:12:03 <dons> tagging as in arbitrary grouping of windows?
02:12:11 <dons> including duplicates?
02:12:40 <dons> (xmonad uses 'tags' but windows are unique across the entire set of workspaces. so not arbtirary grouping. we're thining about it though)
02:12:47 <dons> if we can find a natural semantics for how that works
02:17:11 <Saizan> which is the preferred database interface library?
02:17:29 <dons> hdbc i think, but check on hackage
02:22:27 <Saizan> it doesn't have a direct driver for mysql.. i'll try with hsql
02:22:51 <DRMacIver> Why would ou use MySQL anyway? :)
02:23:23 * ivanm would hope that mysql was better than oracle... *shudder*
02:23:57 <DRMacIver> If by 'better' you mean 'worse' then yes. :)
02:24:42 <mdmkolbe|work> what does this darcs error mean? http://hpaste.org/27
02:24:46 <DRMacIver> It's less arcane, but it's also hugely less powerful.
02:25:06 <Saizan> DRMacIver: it's what is installed on teh server :)
02:25:42 <DRMacIver> Saizan: Well, you could always install new things. ;)
02:26:26 <DRMacIver> I'm sure perl is installed on the server too, yet you're using Haskell. :)
02:26:47 <Saizan> haskell doesn't need to be installed :)
02:27:13 <Saizan> and my program won't run on "the server"
02:28:38 <dons> mdmkolbe|work: it looks like a bug to report to the darcs guys. could be caused by attempting to pull over a partial repo?
02:29:02 <dons> mdmkolbe|work: that's an unusual branch you're pulling from, yes?
02:31:27 <mdmkolbe|work> dons: it's a cache of the ghc-HEAD that is stored on the local disk
02:31:53 <mdmkolbe|work> the #darcs people don't seem to be awake yet
02:54:22 <yakov> hi
02:55:24 <ivanm> hi yourself
03:09:42 <JohnMeacham> hello.
03:33:52 <dons> have we taken over all the bases yet?
03:34:34 <ivanm> as in the all your base quote?
03:35:06 <dons> do they belong to us?
03:35:12 * dons is silly. time for more tea.
03:35:46 <ivanm> who introduced whom to drinking tea? dons, dcoutts, or mutual?
03:36:37 <dons> i used to drink a bit of green tea, but dcoutts got me hooked on the stuff.
03:37:08 <kaol> tea++
03:37:19 <ivanm> hot chocolate++
03:37:28 <kaol> @karma chocolate
03:37:29 <lambdabot> chocolate has a karma of 1
03:37:43 <ivanm> heh
03:37:46 <ivanm> @karma tea
03:37:46 <lambdabot> tea has a karma of 1
03:46:28 <ADEpt> dons: using relative silence on the channel, let me express my "+1" and "way to go!" on the book news ;)
03:56:44 <quicksilver> dons: only 20% of my base are belong to you
03:56:47 <quicksilver> dons: keep trying, though
03:57:16 <quicksilver> ivanm: briton visits australia and you ask who introduced who to tea? :)
03:58:01 <ivanm> quicksilver: lol...
03:58:38 <gleb> ADEpt: +1
03:59:48 <gleb> dons++
03:59:57 <gleb> @karma dons
03:59:57 <lambdabot> dons has a karma of 155
04:00:00 <matthew-_> so you can get tea bags in austrailia?
04:01:44 <quicksilver> matthew-_: you can get vegemite in the UK, so why not :)
04:02:01 <matthew-_> mmm. is vegemite like marmite?
04:02:02 <ivanm> yeah, we get our tea from sri lanka :p
04:02:15 <ivanm> and from companies owned by US cigarrete companies
04:02:16 <ivanm> :(
04:02:22 <matthew-_> ivanm: we built boats and an industry in order to do that...
04:02:46 <ivanm> matthew-_: you only drank tea because your coffee plantations were infested by a disease...
04:02:51 <ivanm> or was it the other way round?
04:03:23 <matthew-_> oh really? I clearly know sod all other than I like both tea and coffee
04:03:58 <quicksilver> ivanm: They caught diseases because their tea plantations were infested with coffee, I believe.
04:04:04 <quicksilver> In soviet russia, of course, tea drinks you!
04:04:07 <ivanm> heh
04:04:18 <ivanm> in soviet russia, they made tea out of old socks
04:04:25 <ivanm> _if_ they were lucky!!! :p
04:04:53 <quicksilver> no,no, in soviet russia, old socks are made out of YOU!
04:04:59 * quicksilver thinks this joke gets old fast
04:06:24 <Wallbraker> In soviet russia, you get old on jokes.
04:06:48 <kaol> actually, they make some very fine teas in Russia
04:07:04 <ivanm> quicksilver: well, you only have yourself to blame!
04:07:13 <ivanm> kaol: sure, if you live in the top 1%...
04:07:22 <ivanm> and you were either in the top 1% or you were treated as dirt
04:11:14 <kaol> undoubtedly... All the contact I've had with them is with what they've exported.
04:11:49 <matthew-_> they make some good vodka too. Actually, lots of places make good vodka these days.
04:12:28 <ivanm> its not hard.. just let some potato peelings rot in a bucket outside during winter :p
04:14:42 <JaffaCake> dcoutts?
04:14:50 <dcoutts> hia JaffaCake
04:15:06 <JaffaCake> can you add trac@galois.com to the allowed senders for cabal-devel@haskell.org
04:15:33 <JaffaCake> I've set up the notifications, we just need to let the messages through
04:16:14 <dcoutts> JaffaCake: I don't think I have admin perms for the list, I was delegated moderation some time ago, but I've not recieved any moderation emails for about 6 months. So we'll have to ask SyntaxNinja.
04:16:29 <JaffaCake> oh, ok
04:17:25 <dcoutts> I'm not sure who is moderating cabal-devel now either
04:19:18 <JaffaCake> I've emailed SyntaxNinja
04:33:55 <dcoutts> JaffaCake: ta
04:34:59 <nn-main> hi JaffaCake !
04:35:19 <quicksilver> @where derive
04:35:19 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
04:55:26 <nattfodd> is there a way to tell darcs "I want to get only directory foo inside repo bar" ?
04:55:48 <mornfall> nattfodd: from the way things work, probably no
04:56:04 <nattfodd> humpf
04:56:08 <nattfodd> annoying
04:56:13 <Lemmih> nattfodd: You can use wget if you aren't interested in patches.
04:56:14 <mornfall> nattfodd: at least not in case you are trying to save bandwidth
04:57:08 <mornfall> nattfodd: although you could probably filter patches server-side to only those that affect a given directory and their dependencies, no idea if that would save something significant
04:57:12 <nattfodd> Lemmih: ah, wget is fine too
04:57:32 <nattfodd> mornfall: no, it's just because there is another directory with my article source in the same repo
04:57:38 <nattfodd> and I'd rather not have people download it
04:58:09 <quicksilver> then don't make the (whole) repo public :)
04:58:26 <quicksilver> just use wget, or have a 'make install' which copies the files into a web-accessible dir
04:59:10 <nattfodd> yes, wget will be fine
04:59:38 <nattfodd> thanks
05:06:30 <manu3000> hello, can somebody help me ? I am trying to build the haskell98-1.0 package, and I get the following
05:06:33 <manu3000> $ runhaskell Setup.hs configure
05:06:33 <manu3000> <interactive>:1:84:
05:06:33 <manu3000>     Bad interface file: IO.hi
05:06:33 <manu3000>         IO.hi: openBinaryFile: does not exist (No such file or directory)
05:06:34 <manu3000> ghc-6.6: panic! (the 'impossible' happened)
05:06:34 <manu3000>   (GHC version 6.6 for i386-apple-darwin):
05:06:35 <manu3000>         interactiveUI:flush
05:07:20 <Lemmih> manu3000: You somehow uninstalled haskell98?
05:07:24 <jfredett> well, I'm no expert, but it looks like you're missing a file, maybe you're calling it by the wrong name?
05:07:46 <Lemmih> manu3000: GHCi (aka runhaskell) depends on haskell98.
05:08:05 <Lemmih> manu3000: Try compiling the setup script to a binary.
05:08:06 <manu3000> @Lemmih : no Ive just seen it listed in the dependencies for some other package, and it doesn't show up when I do ghc-pk list
05:08:06 <lambdabot> Unknown command, try @list
05:08:29 <Lemmih> manu3000: Can you run GHCi?
05:08:33 <Igloo> The problem is ghci is using files in . rather than the ones it is meant to use
05:08:54 <Igloo> Compiling Setup will fix it, as Lemmih says
05:09:05 <manu3000> oops sorry my mistake, it is indeed listed  by ghc-pkg list !!!!
05:09:37 <sphynx> @where parsec
05:09:37 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
05:09:43 <manu3000> too many packages installed !!! didn't see it
05:10:10 <arcatan> !!!!!
05:12:09 <Lemmih> manu3000: cabal-install will hopefully save us from the package nightmare.
05:12:15 <bringert> manu3000: how's your hope setup working out?
05:12:32 <manu3000> hi bringert , fine thanks ;)
05:14:30 <bringert> kosmikus: I remember you telling me that \usepackage{ae} is nonsense. However, when I build my PDF with the latest pdflatex from MacPorts, and look at it in OS X's Preview.app, the font is all fuzzy without it. Do I have old fonts, or is it Preview.app that sucks?
05:17:06 <quicksilver> bringert: which font(s) are you using?
05:18:06 <bringert> quicksilver: T1 encoding, but I'm actually not sure which font
05:18:16 <bringert> quicksilver: I'm using an existing .cls
05:18:33 <quicksilver> bringert: the purpose of the {ae} package is to bring the Computer Modern family (the default TeX fonts) into line with T1
05:18:54 <quicksilver> bringert: if you wish to use postscript (T1) versions of computer modern, then usepackage{ae} is, AFAIK, the correct way to do it
05:19:10 <quicksilver> bringert: and, if you want PDFs to look nice, then you want to use postscript fonts, so that's the right thing to do.
05:19:33 <bringert> quicksilver: right, that's was my purpose in using it. however, kosmikus told me that current font versions already come in T1 versions.
05:19:44 <quicksilver> they do
05:19:48 <quicksilver> {ae} isn't new fonts
05:19:50 <quicksilver> it's a new mapping
05:20:04 <quicksilver> it maps the computer modern (postscript) fonts into a standard postscript encoding
05:20:10 <quicksilver> http://www.ctan.org/tex-archive/fonts/ae/
05:20:11 <lambdabot> Title: CTAN: directory: /tex-archive/fonts/ae
05:20:14 <quicksilver> explains it better than I can :)
05:22:04 <bringert> quicksilver, thanks
05:27:39 <kosmikus> bringert: if you use T1 fontencoding, you should \usepackage{lmodern}. if you don't have that, your TeX distro is old, and {ae} might be the best option
05:27:55 <bringert> kosmikus: ah, thanks!
05:32:24 <drigz> @source System.Random
05:32:25 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
05:32:42 <drigz> ^^^ that leads to a 404 error
05:34:31 <Lemmih> http://darcs.haskell.org/packages/random/System/Random.hs
05:34:39 <Lemmih> It has moved, apparently.
05:44:48 <drigz> Lemmih: thanks
05:57:38 <quicksilver> @seen ndm
05:57:39 <lambdabot> I saw ndm leaving #haskell 10h 35m 17s ago, and .
05:59:14 <kwijibo>  #erlang
06:00:04 <quicksilver> heh
06:00:11 <quicksilver> #nothanksI'mhappyinhaskell
06:01:01 <Vq^> :/
06:01:04 <kfish> it's a bug in the erlang irc client, it only allows concurrent channel joins
06:01:27 <osfameron> tis awful quiet in #erlang
06:02:33 <arcatan> that just proves that erlang programmers have a lot less problems than, say, haskell programmers
06:03:36 <kfish> arcatan, haskell programmers don't have problems, just solutions they haven't yet learned how to understand
06:03:51 <arcatan> ooooh
06:06:26 <quicksilver> @quote solutions
06:06:27 <lambdabot> No quotes match. You speak an infinite deal of nothing
06:06:40 <quicksilver> @remember kfish haskell programmers don't have problems, just solutions they haven't yet learned how to understand
06:06:40 <lambdabot> Done.
06:06:59 <kfish> :-)
06:08:21 <dozer> is there a cleaner way to write this:
06:08:32 <dozer> concat $ map (\(dv, dr) -> [Map.insert dv d dataEnv | d <- dr]) datas
06:08:54 <ventonegro> :t concatMap
06:09:03 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:09:37 <dozer> sometwo: concatMap (\(dv, dr) -> [Map.insert dv d dataEnv | d
06:09:59 <dozer> oops, but concatMap rather than concat $ map
06:11:12 <dozer> thanks ventonegro
06:11:30 <quicksilver> dozer: you could write it as a nested list comprehension
06:11:36 <quicksilver> dozer: up to you if you think that's neater :)
06:12:07 <quicksilver> [ Map.insert dv d dataEnv | d <- dr, (dv,dr) <- datas ]
06:12:11 <quicksilver> I think that's right?
06:12:34 <quicksilver> probably the d <- dr has to come after the other one
06:12:46 <quicksilver> [ Map.insert dv d dataEnv | (dv,dr) <- datas , d <- dr ]
06:14:24 <dozer> ah, that is nicer
06:17:12 <dons> http://radar.oreilly.com/archives/2007/05/real_world_hask.html :-)
06:17:13 <lambdabot> Title: O'Reilly Radar > Real World Haskell title under development
06:18:42 <dozer> sweet
06:18:45 <dons> even better, http://programming.reddit.com/info/1t768/comments
06:18:46 <lambdabot> Title: Tim O&#39;Reilly: Real World Haskell under development (reddit.com)
06:18:51 <ventonegro> "avoid success at all" is bound to fail now
06:19:26 <dons> 'bout time we got jobs.
06:19:51 <edwinb> jobs are overrated
06:20:18 <dozer> aye - I've got away with a payed hobby so far
06:20:27 <quicksilver> > [a | a <- b , b <- ["foo","bar"]]
06:20:29 <lambdabot>   Not in scope: `b'
06:20:36 <quicksilver> yes, order does matter in list comprehensions
06:20:45 <quicksilver> PROPOSAL: list comprehensions should be 'mdo' :)
06:20:53 <dozer> yeah, you have to bind it before you use it
06:20:53 <dons> and also! http://programming.reddit.com/info/1t6x1/comments
06:20:54 <lambdabot> Title: Haskell at oreilly.net (reddit.com)
06:20:57 <quicksilver> > [a | b <- ["foo","bar"], a <- b]
06:20:59 <lambdabot>  "foobar"
06:21:01 <dons> (an intro to haskell!)
06:21:35 <quicksilver> dozer: if ever you have  concatMap, it could be a list comprehension
06:21:47 <quicksilver> dozer: because list comprehensions are desugared into concatMaps, in effect
06:22:03 <dozer> quicksilver: fine - I will remember that
06:26:24 <beelsebob> quicksilver: how did you like SEE?
06:28:14 <quicksilver> beelsebob: I didn't look further than the website :)
06:28:21 <beelsebob> lol
06:28:23 <beelsebob> why for?
06:28:23 <quicksilver> beelsebob: If I'm going to learn a new editor, it won't be a non-free one...
06:28:49 <beelsebob> hehe
06:28:51 <beelsebob> fair enough
06:29:24 <quicksilver> the editor I'm most likely to consider, I strongly suspect, is Yi
06:29:30 <quicksilver> I hope that project keeps moving
06:29:43 <beelsebob> tis another one with an interface I don't like
06:29:45 <beelsebob> but that's just me
06:29:57 <quicksilver> beelsebob: it doesn't have an interface yet! give it a chance...
06:30:03 <quicksilver> beelsebob: it's barely a prototype ;)
06:30:03 <chrismbrown> quicksilver: there is textmate too, I think they do a free trial so you can look at the editor, it's kind of similar to SEE...
06:30:06 <chrismbrown> http://macromates.com/
06:30:07 <lambdabot> Title: TextMate â€” The Missing Editor for Mac OS X
06:30:15 <quicksilver> chrismbrown: SEE has a free trial, too :)
06:30:18 <quicksilver> chrismbrown: that wasn't the point
06:30:19 <chrismbrown> ah :)
06:30:30 <quicksilver> beelsebob: I do agree (from the screenshots and the words on teh website) that it looks very good
06:30:52 <chrismbrown> quicksilver: you don't agree with the fee I take it... :?
06:31:37 <osfameron> gah, I was about to ask "SEE?" and then realised I'd asked yesterday
06:31:39 <beelsebob> chrismbrown: I believe the point is that while software developers are free to chose their price, so are buyers
06:31:46 <osfameron> what is it about that acronym?...
06:32:05 <quicksilver> chrismbrown: The argument is long and complex. Key points are "free software can be taken in new directions if the original team go somewhere I don't like", and "good free sofware packages don't die"
06:32:44 <beelsebob> quicksilver: yeh, I'm happy to pay for software as long as it's already been taken in the right direction
06:33:07 <beelsebob> (with SEE it's a case of it does everything I want, and nothing I don't want, so I'll pay)
06:33:16 <beelsebob> plus... you can get it cheep as a student
06:33:24 <quicksilver> chrismbrown: the SEE team, or the TextMate team, (although they are evidently talented) may become more interested in a new project
06:33:35 <quicksilver> chrismbrown: and the projects may wither and die; I've seen it happen before
06:34:17 <beelsebob> quicksilver: what I've tended to see with mac software is that if the dev gets bored they open source it
06:34:23 <quicksilver> beelsebob: also, I'm not yet 100% committed to OSX. So on balance I'd like a cross-platform editor, even though I use OSX 99% of the time at the moment
06:34:26 <beelsebob> but it's not guarenteed I appreciate
06:34:54 <quicksilver> There are a hundred ways Apple might piss me off which might make me not get an OSX machine next time :)
06:35:07 <beelsebob> what... like their hardware quality being shit?
06:35:08 <beelsebob> *cough*
06:36:49 <chrismbrown> editors aside, can anyone explain to me what a closure is in Haskell terms?
06:37:13 <osfameron> quicksilver: which reminds me... are you named after the osx utility or the element? ;-)
06:37:26 <quicksilver> osfameron: this nickname long predates OSX
06:37:33 <chrismbrown> osfameron: it could be the clothing brand as well!
06:37:34 <quicksilver> osfameron: I've been using it for more than 20 years
06:37:43 <quicksilver> osfameron: so, the element I guess
06:37:43 <osfameron> :-)
06:37:54 <quicksilver> chrismbrown: opinions differ
06:38:13 <quicksilver> chrismbrown: on exactly which part of the process a closure refers to
06:38:25 <quicksilver> but, consider f x y = (x+y)
06:38:31 <chrismbrown> yep...
06:38:32 <quicksilver> now consider "f 3"
06:38:42 <quicksilver> in the expression "f 3" , x has already got a value
06:38:47 <quicksilver> although y doesn't
06:38:54 <chrismbrown> yes, so it's partial...
06:38:56 <osfameron> eeeek!
06:39:07 <quicksilver> so that might be represented as { x : 3 , "\y -> x+y" }
06:39:21 <quicksilver> the 'closure' is the way you bundle together a chunk of code
06:39:28 <quicksilver> although with assignments for some of the free variables in it
06:39:32 <edwardk> chrismbrown: a closure is the set of variables that your function remembers for you behind the scenes. its a captured portion of the environment
06:39:56 <chrismbrown> edwardk: that's what I thought it vaguely meant
06:40:09 <quicksilver> closures don't have to be partial application, explicitly
06:40:16 <edwardk> true
06:40:17 <quicksilver> another example would be
06:40:20 <quicksilver> let x = 3 in (x+y)
06:40:30 <quicksilver> that is represented by the same closure
06:40:34 <quicksilver> let x = 3 in \y -> (x+y)
06:40:34 <quicksilver> rather
06:40:43 <chrismbrown> oh, I see
06:40:58 <chrismbrown> that's intruiging
06:40:59 <quicksilver> of course, you migth well expect a compiler to just arrange for the 3 to be 'inlined'
06:41:04 <quicksilver> and maybe it does, in practice
06:41:22 <quicksilver> but really closures refer to the idea that you can pass around chunks of code together with values for some but not all of their variables
06:41:34 <chrismbrown> so, I guess it's a way to share a common term? A way of optimising the code?
06:41:48 <edwardk> well, actually they are sort of the antithesis of sharing =)
06:41:52 <quicksilver> some people think of it as an implementation technique
06:41:54 <osfameron> it's another layer of function call too
06:41:58 <edwardk> you capture just the portion of the environment you need
06:42:03 <quicksilver> and they would say, for example 'C doesn't have closures'
06:42:08 <edwardk> rather than look in some monolithic environment
06:42:11 <quicksilver> because in C you can return a function (pointer)
06:42:12 <mauke> { my @set = 'a' .. 'z'; sub mkid { my $len = shift; join '', map $set[rand @set], 1 .. $len } }  # closure in perl
06:42:25 <quicksilver> but you can't return a function together with some variable assignments
06:42:34 <quicksilver> (the C compilation model is poorly suited to that kind of idea)
06:42:41 <Saizan> the fact that function defined in a where clause have the arguments of the main function in scope is also a closure, right?
06:42:44 <quicksilver> although there is a GCC extension which does that, more or less
06:42:56 <quicksilver> Saizan: if that fucntion can 'escape' then yes
06:43:08 <quicksilver> Saizan: if that function escapes by being returned, or passed to another function as an argument
06:43:13 <chrismbrown> is there a tutorial on this anywhere?
06:43:18 <quicksilver> Saizan: then it has to carry with it the arguments it needs
06:43:50 <quicksilver> chrismbrown: not sure, off hand
06:43:53 <edwardk> chrismbrown: if you really want a good way to think about it there are the old papers by Simon Peyton Jones and company about the spineless tagless g-machine
06:44:00 <quicksilver> chrismbrown: it would be coevered in a decent compiler course
06:44:08 <quicksilver> chrismbrown: typically 2nd or 3rd year undergrad
06:44:23 <edwardk> it discusses how haskell runs in the back end, and its a good way to get your head around it in a lazy setting.
06:44:36 <quicksilver> chrismbrown: there is some disagreement about whether 'closure' refers to an abstract concept, or a concrete implementation technique
06:44:45 <chrismbrown> edwardk: thanks, I have that paper lying around somewhere actually!
06:45:22 <edwardk> you can also probably read a javascript tutorial on the topic, since javascript functions capture closures as well (though they just sort of maintain a linked list of contexts)
06:45:50 <chrismbrown> well, thanks for you help. Although I'm still a little confused! I have to dash off now though
06:46:44 <chrismbrown> ciao, dudes
06:46:53 <edwardk> var f = (function (b) { var a = b; return function() { return a; } })(10) is a convoluted way to make a function f that will return 10 ;)
06:48:10 <mauke> my $f = sub { my $x = shift; sub { $x } }->(10);  # no love for perl :(
06:48:19 <edwardk> =)
06:48:20 <osfameron> edwardk: annoyingly, in both js and perl, only functions close, not bare scopes
06:48:26 <edwardk> yeah =(
06:49:01 <edwardk> learned that the hard way with my javascript compiler
06:49:22 <osfameron> sounds like fun - what's the compiler written in?
06:49:50 <Axioplase> osfameron: well, perl has objects. and closures are an object with a single method being "apply"
06:49:56 <araujo> morning
06:50:35 <osfameron> Axioplase: yeah, I once implemented closures in VBScript with classes with such a method (and some source munging)
06:52:12 <mauke> osfameron: what do you mean?
06:54:12 <osfameron> mauke: regarding?  The VBScript thing?
06:54:39 <mauke> the "only functions close, not bare scopes"
06:55:34 <DRMacIver> As I recall, blocks in e.g. if statements in javascript don't introduce a new scope, even though they look like they do.
06:55:47 <quicksilver> mauke: you don't get a proper closure for a variable which is, e.g., local to a for loop
06:55:54 <quicksilver> mauke: instead you share the reference to the same variable
06:55:59 <quicksilver> tis a bloody nightmare
06:56:12 <dcnstrct> guys I have a text file with a url on each line.  The urls look like this: http://www.google.com:80      I want to write a function that parses a line from this file, and returns a tuple (host,port).. so the type would be parseUrl :: String -> (String,Int).   I'm very new to Haskell and I'm having a hard time finding good documentation for it's string manipulation capabilities.  Should I be reading about parser combinators or is that overkill for such a 
06:56:12 <lambdabot> Title: Google
06:56:14 <osfameron> mauke: ah.  You can't do;  my @funs; for my $x (1..10) { push @funs, sub { $x+1 } }  for example
06:56:36 <osfameron> mauke: you have to get each closure out of a subroutine call.   I think.  Anyway, occsaionally it bites my bum.
06:56:59 <mauke> osfameron: you can, actually
06:57:13 <mauke> perl -wle 'for my $x (1..10) { push @funs, sub { $x+1 } } print $_->() for @funs'
06:57:38 <quicksilver> he's right, you can :)
06:57:45 <quicksilver> it's only javascript you can't
06:57:46 <mauke> perl's scoping isn't retarded (unlike other languages) :-)
06:57:48 <osfameron> mauke: then there was some other similar subtlety that occasionally bites me up the arse :-)
06:57:48 <quicksilver> silly javascript
06:58:55 <quicksilver> osfameron: it's the 'my' that saved you
06:59:11 <quicksilver> osfameron: if the 'my' isn't there, and it refers to the package varaiable, then it doesn't work
06:59:36 <quicksilver> dcnstrct: arguably, parser combinators are overkill
06:59:42 <quicksilver> dcnstrct: especially if you are new to haskell
06:59:42 <ADEpt> dcnstrct: Strings are lists. So "string processing" = "list processing". Browse through "Data.List". With ghci, it could be done as ":b Data.List". Experient in ghci
07:00:04 <quicksilver> dcnstrct: you can find the first colon with 'find' for example
07:00:05 <ADEpt> dcnstrct: For _heavy_ string processing, use Data.ByteString.
07:00:06 <quicksilver> :t find
07:00:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:00:29 <mauke> @hoogle (a -> Bool) -> [a] -> ([a], [a])
07:00:29 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
07:00:29 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
07:00:29 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
07:00:31 <quicksilver> find (==':') "http://google.com:80"
07:00:33 <lambdabot> Title: Google
07:00:35 <quicksilver> > find (==':') "http://google.com:80"
07:00:37 <lambdabot>  Just ':'
07:00:38 <lambdabot> Title: Google
07:00:42 <quicksilver> although the index might be more useful
07:00:46 <quicksilver> > findIndex (==':') "http://google.com:80"
07:00:48 <lambdabot>  Just 4
07:00:49 <lambdabot> Title: Google
07:00:58 <mauke> > break (':' ==) "http://google.com:80"
07:00:58 <quicksilver> dcnstrct: meaning, it found a ':' at index 4
07:00:59 <lambdabot>  ("http","://google.com:80")
07:01:00 <lambdabot> Title: Google
07:01:10 <dcnstrct> great! just what I was looking for, thanks people!
07:01:14 <ADEpt> quicksilver: _please_ use hppt instead of http :)
07:01:25 <quicksilver> ADEpt: yeah, good point :)
07:01:47 <quicksilver> ADEpt: although, IMO, Lb should not do the URL stuff if it's a LB-command in another way, such as '>' or '@'
07:01:53 <mauke> > fmap reverse . break (':' ==) . reverse $ "hxxp://google.com:80"
07:01:54 <lambdabot>  ("08","hxxp://google.com:")
07:03:12 <ADEpt> > let f "" = Nothing; f str = Just . break (':' ==) in unfoldr f "hxxp://google.com:80"
07:03:12 <lambdabot>  Couldn't match expected type `Maybe a'
07:03:29 <ADEpt> > let f "" = Nothing; f str = Just ( break (':' ==) str) in unfoldr f "hxxp://google.com:80"
07:03:30 <lambdabot>  ["hxxp","","","","","","","","","","","","","","","","","","","","","","",""...
07:04:07 <mauke> > (\(x,_:y) -> (reverse y, reverse x)) . break (':' ==) . reverse $ "hxxp://google.com:80"
07:04:08 <lambdabot>  ("hxxp://google.com","80")
07:05:09 <sieni> 5
07:05:44 <shapr> 6
07:05:49 <ADEpt> 42
07:05:53 <ADEpt> i win
07:05:54 <dons> undefined
07:06:00 <geezusfreeek> 1337
07:06:13 <roconnor> fix (+1)
07:06:20 <CosmicRay> NaN
07:06:22 <dons> n | False = n :: Int
07:06:24 <araujo> _|_
07:06:35 <dons> I love #haskell
07:07:22 <shapr> me too!
07:07:47 <chessguy> me four!
07:07:50 <chessguy> err, three
07:07:59 <roconnor> me (fix (1+))
07:08:00 * edwardk <3 #haskell
07:08:11 * araujo throws lambdas at everyone
07:08:24 <chessguy> @quote heart
07:08:24 <lambdabot> S.Behrens says: Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.
07:08:25 <edwardk> roconnor is a bottom? too much information =)
07:08:31 <chessguy> @quote break.heart
07:08:31 <lambdabot> No quotes match. I've seen penguins that can type better than that.
07:08:40 <chessguy> @quote breaks.heart
07:08:40 <lambdabot> kpreid says: @pl (<3) -- pl breaks hearts!
07:08:43 <araujo> haha
07:08:47 <chessguy> careful, edwardk
07:09:05 <roconnor> edwardk: how about (fix Succ)
07:09:23 <edwardk> that really Succs.
07:09:29 <chessguy> hoo boy
07:09:53 <chessguy> ?hoogle succ
07:09:54 <lambdabot> Prelude.succ :: Enum a => a -> a
07:09:54 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
07:09:54 <lambdabot> System.Exit.ExitSuccess :: ExitCode
07:09:57 <olsner> @pl (<3)
07:09:57 <lambdabot> (< 3)
07:10:01 <olsner> indeed
07:10:28 * edwardk has visions of a functional beavis going around saying 'succ it.'
07:10:57 <hkBst> one upping everyone ;)
07:11:34 <chessguy> dons: you had to know that everyone was going to be pretty stinking excited about this book :)
07:12:06 <edwardk> now where was it 8 months ago when i was first learning these things? ;)
07:12:11 <dons> its more than I thought, though.
07:12:29 <dons> a ridiculous amount more.
07:13:15 <dons> and who'd have thought Tim O'Reilly would be blogging about haskell books :)
07:14:44 <chitin> if I want to make a list [(a,b)] is it faster to use a list comprehension than it is to use zip?
07:14:57 <mauke> wrong question
07:15:19 <nattfodd> dons: I take it that you don't need any more reviewers, then?
07:15:41 <dons> the problem is narrowing down the list at this point. but more are always welcome.
07:16:25 <nattfodd> and would an experience from someone who doesn't yet know much haskell be welcome or is it not worth writing an "application"?
07:17:07 <dons> i think we want outsiders with experience reviewing technical books, or insiders with strong experience. that's my guess. (i'm new to this game)
07:17:13 <quicksilver> chitin: there should be no appreciable speed difference
07:17:23 <quicksilver> chitin: use whichever technique is clearer
07:17:29 <chitin> quicksilver: thank you
07:17:34 <haskellnew> do {hnd<-connectTo "127.0.0.1" (PortNumber 38980) ; hPutStr hnd hndMsg ; x1<-hGetChar hnd ;hClose hnd } i get eof after sometime
07:17:42 <nattfodd> dons: ok, too bad for me then :)
07:17:45 <quicksilver> chitin: used naively they do quite different things, mind you :)
07:18:08 <quicksilver> > [(a,b) | a <- [1,2,3], b <- ["apple","pear"] ]
07:18:10 <lambdabot>  [(1,"apple"),(1,"pear"),(2,"apple"),(2,"pear"),(3,"apple"),(3,"pear")]
07:18:22 <quicksilver> > zip [1,2,3]  ["apple","pear"]
07:18:23 <lambdabot>  [(1,"apple"),(2,"pear")]
07:18:40 <dons> its probably more fun to read the book, than to review it, anyway ;-)
07:18:57 <nattfodd> probably :)
07:19:32 <edwardk> reviewing is a lot of work. i remember one book I had to send in over 50 technical corrections... on chapter 2.
07:20:12 <edwardk> the worst part was it was a 2nd edition
07:20:39 <dons> i'm fairly hopeful we won't have huge technical errors, getting the focus right, and covering the right material, will be the hardest part, i think
07:20:41 <edwardk> and that most of my own counterexamples could be drawn from either their own chapter or logical understanding of when the data arrived in the packet.
07:20:46 <edwardk> =)
07:21:10 <edwardk> (er this was a for a CCIE study guide)
07:21:32 <edwardk> ya, if it compiles you've got the technical side right ;)
07:21:38 <edwardk> go haskell
07:21:57 <quicksilver> dons: clearly the technical content of the book will be QuickChecked :)
07:22:10 <dons> that's a good idea!
07:22:20 <quicksilver> all (==True] [ s | s <- chapter1 ]
07:22:32 <edwardk> so, will the book come with a literate haskell version of itself? ;)
07:22:43 <dons> i don't think i'd trust myself to write sectoins without QC
07:22:49 <dons> it'll come with darcs repos
07:22:53 <shapr> yay!
07:23:15 <shapr> dons: ooh, I have experience reviewing books!
07:23:23 <dons> shapr: send us a note!
07:23:31 <quicksilver> seen on #haskell
07:23:32 <shapr> I reviewed two books for the pragprog guys.
07:23:39 <quicksilver> dons soliciting bribes for reviewing posts!
07:23:41 <Axioplase> So many people want the book for free :)
07:23:42 <quicksilver> shock horror stop the press
07:23:45 <dons> shapr: so, you think its a good idea to write this book?   (/me teases shapr)
07:23:45 <CosmicRay> dons: he already did, via me
07:23:46 <chessguy> haha
07:23:47 <edwardk> heh
07:23:55 <dons> CosmicRay: ah, good.
07:23:55 <shapr> dons: hm... YES!
07:24:03 <edwardk> well, honestly its 'cheaper' to buy the book, than review unless you work REAL cheap ;)
07:24:21 <shapr> Truly, reviewing is a lot of work.
07:24:25 <CosmicRay> indeed it is.
07:25:34 <shapr> I reviewed two PDFs for the pragmatic version control book, it took me roughly five eight hour shifts.
07:25:51 <chessguy> so is the whole book going to be freely available online, or just parts of it?
07:25:58 <shapr> Lucky for me it was the "just prior to actual publishing" versions.
07:26:27 <nattfodd> chessguy: the whole book according to the webpage
07:27:49 <dons> see what Tim O'Reilly says , http://radar.oreilly.com/archives/2007/05/real_world_hask.html
07:27:50 <lambdabot> Title: O'Reilly Radar > Real World Haskell title under development
07:28:06 <dons> basically, open book, plus community feedback, it's the Haskell way
07:28:21 <dozer> a book with bugfixes :)
07:28:22 <dons> and then at the end no one can complain! ;-)
07:28:37 <dons> darcs send, yes :-)
07:28:38 <earthy> uh. yeah they can. :P
07:29:08 <dons> :P
07:29:19 <chessguy> you should put up a darcs repo with the text :)
07:29:31 <earthy> and yeah, reviewing is a lot of work, but reviewing *does* improve the product, and therefore is worth it
07:29:43 <earthy> if you value the product beyond just owning a copy
07:30:22 <haskellnew> can some one give me simple example of a client sending and receiving data from a socket using Network module
07:30:36 <chessguy> it's an awesome thing that OReilly picked this book to do this way. the Haskell community is the perfect guinea pig for it
07:30:59 * earthy nods
07:31:00 <quicksilver> chessguy: I don't think it's the first book to be 'done this way' ?
07:31:14 <olsner> so, the book will be open for everyone, not only for official reviewers?
07:31:18 <chessguy> quicksilver: see the link don just gave
07:31:30 <chessguy> quicksilver: i'm talking about the putting the 2 parts together
07:31:42 <dons> haskellnew: http://haskell.org/haskellwiki/Blog_articles#Network
07:31:43 <lambdabot> Title: Blog articles - HaskellWiki
07:31:47 <dons> haskellnew: some smaller examples there.
07:31:54 <shapr> O'Reilly has several 'open' books, one example is 'Linux Device Drivers' 2nd Ed.
07:31:58 <chitin> a,b,c,d <- list --is this syntactically correct?
07:32:08 <shapr> chitin: [a,b,c,d]
07:32:08 <dons> hmm , nope.
07:32:17 <quicksilver> chitin: no, what are you trying to do?
07:32:35 <dons> > let (a:b:c:rest) = [1..] in [c,b,a]
07:32:36 <lambdabot>  [3,2,1]
07:32:43 <quicksilver> chitin: inside a list comprehenstion you might say [ a | (a,b,c,d) <- list ]
07:32:50 <quicksilver> chitin: that would assume list was a list of 4-tuples
07:32:59 <dons> > [ x * 2 | x <- [1..] ]
07:33:00 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
07:33:12 <chitin> test = [ [(a,x),(b,y),(c,z),(d,w)] | [a,b,c,d] <- primesTo100, [x,y,z,w] <- [1..3] ] --I am a noob
07:33:54 <dons> zip [1..] (take 4 primesTo100) -- ?
07:34:00 <quicksilver> chitin: you want a - d to be four different primes?
07:34:08 <quicksilver> chitin: four primes in sequence?
07:34:10 <quicksilver> or?
07:34:24 <chitin> quicksilver: 4 different, doesnt have to be in sequence
07:34:54 <quicksilver> a <- primesTo100, b <- primesTo100, c <- primesTo100, d <- primesTo100
07:35:09 <chitin> so there's no nicer way to do it?
07:35:18 <quicksilver> there are some nicer ways, yes :)
07:35:48 * chitin guesses I need a monad
07:35:51 <dons> nah
07:35:52 <ski_> (a,b,c,d) <- liftM4 (,,,) primesTo100 primesTo100 primesTo100 primesTo100
07:35:57 <dons> well, maybe :-)
07:36:10 <quicksilver> [a,b,c,d] <- replicateM4 primesTo100
07:36:21 <quicksilver> erm,missing space
07:36:24 <quicksilver> [a,b,c,d] <- replicateM 4 primesTo100
07:37:03 <quicksilver> let p = [1,3,5,7,11] in [(a,b,c,d) | [a,b,c,d] <- replicateM 4 p ]
07:37:04 <chitin> ?hoogle replicateM
07:37:04 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
07:37:04 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
07:37:12 <quicksilver> > let p = [2,3,5,7,11] in [(a,b,c,d) | [a,b,c,d] <- replicateM 4 p ]
07:37:14 <lambdabot>  [(2,2,2,2),(2,2,2,3),(2,2,2,5),(2,2,2,7),(2,2,2,11),(2,2,3,2),(2,2,3,3),(2,2...
07:37:42 <quicksilver> covers every possibility in a kind of 'lexicographic' ordering
07:38:00 <quicksilver> so 'd' gets all values first, then 'c' gets shifted one, etc
07:39:00 <_frederik_> how do i convert an 8-byte double into an 8-byte integer with the same 8 bytes? is peek and poke the way?
07:39:19 <quicksilver> _frederik_: which same 8 bytes?
07:39:28 <quicksilver> _frederik_: according to whose floating point rep?
07:39:29 <quicksilver> :)
07:39:31 <chitin> quicksilver: how did you learn haskell?
07:39:32 <_frederik_> the double and the integer
07:39:51 <_frederik_> as in, their Storable representations
07:39:56 <quicksilver> chitin: osmosis
07:40:02 <quicksilver> _frederik_: by using storable, I think
07:40:03 <chitin> heh
07:40:14 <quicksilver> _frederik_: if it's the storable rep you're interested in, use that
07:40:29 <quicksilver> chitin: I learnt ML from a book by 'Paulson'
07:40:42 <quicksilver> chitin: I already had played somewhat with functional languages before then, though
07:40:45 <quicksilver> chitin: so it wasn't fresh to me
07:40:56 <quicksilver> chitin: I read quite a bit about haskell on the web and tried stuff out
07:41:06 <chitin> I see, I'm trying to learn by messing around but that is obviously not working :( I will need to get a book soon
07:41:12 <_frederik_> k thanks
07:41:21 <haskellnew> dons : thanks , i got the soln from there , i needed to set buffering to off  , i.e "hSetBuffering hnd NoBuffering"  thanks
07:41:32 <quicksilver> chitin: I think learning by messing about is quite good
07:41:38 <quicksilver> chitin: reading haskell blogs is helpful
07:41:45 <quicksilver> chitin: have you seen the haskell weekly news?
07:41:55 <quicksilver> chitin: each issue of HWN contains a roundup of haskell blog articles
07:42:01 <chitin> quicksilver: is that a mailing list?
07:42:04 <quicksilver> chitin: and reading some of those is instructive
07:42:15 <quicksilver> chitin: it's posted on the haskell mailinag lists, but it's also available online
07:42:16 <osfameron> messing about > reading  (ultimately)
07:42:18 <quicksilver> @where hwn
07:42:18 <lambdabot> http://sequence.complete.org/
07:42:22 <quicksilver> ^^ there
07:42:43 <quicksilver> chitin: if you want I book, I have heard good things about Hutton
07:42:58 <quicksilver> chitin: which is fairly new, so quite up to date
07:43:54 <chitin> quicksilver: do you know if that is better than Bird's book?
07:44:44 <dons> haskellnew: ah yes.
07:44:51 <haskellnew> quicksilver : does that book contain info on monads
07:45:32 <dcoutts_> haskellnew: yes, you can read the review in the latest TMR edition
07:45:38 <dcoutts_> @where TMR
07:45:39 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
07:45:44 <quicksilver> chitin: I have read neither, so you must take my opinions with a grain of salt. However. Bird's book is older, and is perhaps more advanced.
07:46:05 <quicksilver> chitin: Hutton's book is more up to date, and specifically aimed at people of 1st-year undergrad ability and background, I think
07:46:35 <dcoutts_> it's great for Haskell newbies
07:46:41 <quicksilver> chitin: they are both very well-respected authors; that isn't necessarily the right qualification for writing good textbooks though :)
07:46:59 <chitin> Thank you quicksilver, I will try Hutton's book
07:47:10 <dcoutts_> chitin: you can read the review too :-)
07:47:16 <dcoutts_> @where TMR
07:47:17 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
07:47:25 <chessguy_work> ha. for a minute i thought dcoutts_ was touting TMR for newbies
07:47:32 <dcoutts_> heh
07:47:56 <dcoutts_> for the book review I am touting it :-)
07:48:30 <dozer> can I use "sequence" over a state monad to do the same sort of thing as a mapAccumL?
07:48:42 <quicksilver> :t mapAccumL
07:48:44 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:49:21 <quicksilver> dozer: you want to 'accumualte' in the state?
07:49:22 <Saizan> that seems more like foldM
07:49:43 <quicksilver> Saizan: I think it's more like mapM; it returns [y]
07:50:02 <Saizan> uh, right
07:50:07 <edwardk> it should be mapM, because they can reference state but it returns the list
07:50:08 <edwardk> ah yeah
07:50:11 <edwardk> nm i'm slow ;)
07:50:14 <quicksilver> dozer: mapM in the state moand is essentially mapAccumL
07:50:22 <quicksilver> dozer: assuming you are identifying 'acc' with the state
07:50:36 <quicksilver> dozer: if you want a separate, external 'acc' then that's different
07:51:02 <dozer> I've got something that needs to chew on 3 lists, applying a function in an error monad, and thread one 'acc' parameter through them
07:51:18 <quicksilver> 3 lists in series or parallel?
07:51:25 <dozer> the 3x cross product
07:51:34 * quicksilver nods
07:51:55 <quicksilver> yes, you could 'StateT' your error monad, for that
07:52:19 <quicksilver> well, in a sense that is what you *have* to do. The choice is whether you decide to actgually use StateT, or thread the state by hand :)
07:52:29 <edwardk> does it need to transform the list or just need the accumulated answer?
07:53:15 <dozer> each computation returns a result in the error monad - I need the list of results back in the error monad
07:53:42 <quicksilver> sounds like mapM in StateT (errormonad)
07:53:42 <quicksilver> to me
07:53:49 <dozer> kk
07:55:30 <rabid> hello
07:56:00 <dozer> so make a list of StateT computations and then mapM them?
07:56:05 <rabid> How do you divide the result of round ?
07:56:21 <quicksilver> rabid: with `div`?
07:56:22 <rabid> (round 4.3)/100
07:56:36 <quicksilver> dozer: yes, essentially
07:56:40 <dozer> > (round 4.3)/100
07:56:41 <lambdabot>  Add a type signature
07:56:42 <quicksilver> > round 4.3 `div` 100
07:56:44 <lambdabot>  0
07:56:57 <quicksilver> rabid: or you want round 4.3 converted back to a float?
07:57:08 <quicksilver> > (fromIntegral $ round 4.3) / 100
07:57:10 <lambdabot>  4.0e-2
07:57:13 <rabid> Yes back to float.
07:57:21 <quicksilver> round always returns an integer
07:57:25 <quicksilver> fromIntegral goes back to a float
07:57:28 <quicksilver> (well, back to whatever)
07:57:43 <dozer> rabid: you may want to look at ceiling and floor
07:57:48 <rabid> Thanks, that was driving me crazy
07:58:00 <quicksilver> dozer: you probably don't need a list of StateT computations
07:58:06 <quicksilver> dozer: you have 1 StateT computation
07:58:12 <quicksilver> dozer: and you mapM it over your big list
07:58:17 <quicksilver> :t mapM
07:58:19 <lambdabot>     Ambiguous occurrence `mapM'
07:58:19 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
07:58:25 <quicksilver> :t Control.Monad.mapM
07:58:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:58:42 <quicksilver> dozer: ^^ [a] is a "pure list". The monadic bit is the computation (a -> m b)
07:59:07 <quicksilver> dozer: in your case a -> StateT (ErrorMonad b)
07:59:21 <dozer> quicksilver: so I would feed it with a list of tripples
07:59:25 <quicksilver> dozer: yup
07:59:31 <quicksilver> dozer: [a] would be the list of triples
08:00:14 <dozer> so do a liftM3 (\a b c -> (a,b,c)) [a] [b] [c]
08:00:53 <quicksilver> yes, or just [(a,b,c) | a <- al, b <- bl, c <- cl]
08:01:02 <quicksilver> depending which syntax you prefer
08:01:13 * dozer slaps forhead
08:01:29 <quicksilver> liftM3 (,,) [a] [b] [c] is fine, too
08:01:43 <quicksilver> it's acutally fewer characters
08:01:52 <quicksilver> but I think the list notation is cute
08:02:08 <dozer> it brackets better when embedding it as the last arg of a more complex function
08:03:11 <quicksilver> yes
08:03:19 <quicksilver> the [  ] are nice visual clues
08:03:24 <quicksilver> help your eyes understand that that is a list
08:04:39 <DRMacIver> Oh, cool. I didn't know there were higher arity versions of the (,) operator.
08:05:01 <quicksilver> :t (,,,,,,,)
08:05:03 <lambdabot> forall a b c d e f g h. a -> b -> c -> d -> e -> f -> g -> h -> (a, b, c, d, e, f, g, h)
08:05:11 <quicksilver> :t (,,,,,,,,,,,,,,,,,,,)
08:05:13 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q,
08:05:13 <lambdabot> r, s, t)
08:05:17 <quicksilver> how deep does the rabbithole go?
08:05:17 <quicksilver> :)
08:05:23 <DRMacIver> I just tested that in GHCI. :) It does seem to be unbounded.
08:05:25 <quicksilver> I cna't remember if that's real haskell98 or a ghc extension, though
08:05:33 <DRMacIver> (Or at least not reasonably bounded)
08:07:04 <quicksilver> "There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show."
08:07:40 <quicksilver> personally I seldom use tuples bigger than 3
08:07:53 <quicksilver> larger than that, I rather name the components
08:08:38 <bringert> generated code sometimes uses very large tuples
08:09:17 <quicksilver> bringert: I have some hand-written parser combinators which sort-of do. But actually they're nested 2-tuples :)
08:12:38 <chitin> thanks again for your help quicksilver, I'm off to class
08:53:03 <nominolo> bringert: did you read my message on @cafe about the interface?
08:53:17 <nominolo> bringert: http interface, that is
08:53:31 <bringert> nominolo: not yet
08:55:09 <shapr> SHAZAM!
08:57:00 * araujo transforms shapr into an ADT
08:57:08 <chitin> quicksilver: are you still around?
08:57:44 <quicksilver> chitin: depends who's asking
08:58:29 <chitin> me ;)
08:59:00 <chitin> regarding earlier, this is what I have test = [ [(a,w),(b,x),(c,y),(d,z)] | [d,c,b,a] <- replicateM 4 [2,3,5,7,11,13], [z,y,x,w] <- replicateM 4 [1..3], isUnique [a,b,c,d], isIncreasingOrder [a,b,c,d] ]
08:59:08 <shapr> CosmicRay: Hey, how do you explicitly close a logger in hslogger?
08:59:17 <Saizan> ?index when
08:59:17 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:59:19 <shapr> CosmicRay: Have you had a chance to try out the one line patch I sent you?
08:59:26 <quicksilver> chitin: that looks plausible to me
09:00:27 <quicksilver> chitin: it is possible to save time by makign sure they are unique + in increasing order to start with :) But, that doesn't mean what you have is wrong
09:00:31 <Botje> chitin: that doesn't do anything with zyxw though
09:00:42 <quicksilver> Botje: yes it does, they're in the output
09:01:16 <Botje> well yes, but it does mean that list is static
09:01:18 <chitin> quicksilver: alright, well, is there a way I can make the list comprehension run through the entire list of primes when w,x,y,z=1
09:01:44 <chitin> I want to do that before, increasing values of w..z
09:01:51 <quicksilver> chitin: if you swap around the zywx clause with teh abcd clause
09:01:56 <quicksilver> chitin: it will do it in the other order
09:02:04 <chitin> interesting
09:03:19 <ski_> > [(n,c) | n <- [0..2] , c <- "ab"]
09:03:20 <lambdabot>  [(0,'a'),(0,'b'),(1,'a'),(1,'b'),(2,'a'),(2,'b')]
09:03:28 <ski_> > [(n,c) | c <- "ab" , n <- [0..2]]
09:03:30 <lambdabot>  [(0,'a'),(1,'a'),(2,'a'),(0,'b'),(1,'b'),(2,'b')]
09:05:17 <quicksilver> > let {pick 0 l = [[]] ; pick n [] = []; pick n (x:xs) = map (x:) (pick (n-1) xs) ++ pick n xs } in pick 3 [1..4]
09:05:19 <lambdabot>  [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
09:05:31 <quicksilver> chitin: that would be one way to pick 'n' elements in ascending order, without repetitions
09:05:39 <quicksilver> > let {pick 0 l = [[]] ; pick n [] = []; pick n (x:xs) = map (x:) (pick (n-1) xs) ++ pick n xs } in pick 3 [2,3,5,7,11]
09:05:41 <lambdabot>  [[2,3,5],[2,3,7],[2,3,11],[2,5,7],[2,5,11],[2,7,11],[3,5,7],[3,5,11],[3,7,11...
09:07:35 <chessguy_work> ?where monadrandom
09:07:35 <lambdabot> I know nothing about monadrandom.
09:07:42 <chessguy_work> @go monadrandom
09:07:44 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
09:07:44 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
09:11:48 <byorgey> quicksilver: of course, that version of pick doesn't work for infinite lists (e.g. the list of all primes)
09:12:29 <bringert> nominolo: read it
09:12:57 <bringert> nominolo: I think that the basic interface should just return a lazy ByteString, just like readFile returns a lazy string
09:13:23 <bringert> nominolo: it's a simple interface, but of course it has the handle-closing problem
09:13:37 <quicksilver> byorgey: well, it 'works'
09:13:48 <quicksilver> byorgey: it doesn't give a fair distribution of the points it covers, though
09:13:55 <byorgey> quicksilver: well, you know what I mean =)
09:13:57 <bringert> nominolo: for most applications that isn't a problem
09:14:00 <nominolo> bringert: what about the "lazy region" approach?
09:14:23 <bringert> nominolo: what's that?
09:14:29 <chessguy_work> ?src Arbitrary
09:14:29 <lambdabot> Source not found. Where did you learn to type?
09:14:32 <byorgey> quicksilver: it doesn't generate all choices in a finite amount of time
09:14:33 <quicksilver> byorgey: hmm is there a primitive or simple way to write interleave :: [a] -> [a] -> [a] ?
09:14:40 <chessguy_work> ?hoogle coarbitrary
09:14:41 <lambdabot> Test.QuickCheck.coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
09:14:54 <dcoutts_> bringert: one could concoct a scheme where the data is demanded from the server as fast as possible, but is cached locally, possibly on disk if the caller is not consuming the data sufficiently quickly
09:14:57 <nominolo> bringert: withLazyHTTP request processFunction -- closes the handle when process function returns
09:15:01 <chessguy_work> can someone explain to me what coarbitrary means in the Arbitrary class? i don't get that function
09:15:10 <nominolo> bringert: and process function gets a lazy bytestring
09:15:27 <dcoutts_> chessguy_work: it's about generating random functions that handle that data type
09:15:32 <quicksilver> byorgey: concat [[a,b] : (a,b) <- zip l m]
09:15:35 <byorgey> quicksilver: as in, interleave [1,3..] [2,4..] == [1..] ?
09:15:43 <quicksilver> byorgey: doesn't feel all that elegant
09:15:47 <dcoutts_> chessguy_work: see the QC paper and look at the other examples in the QC source
09:15:58 <quicksilver> byorgey: yes
09:16:01 <byorgey> quicksilver: that certainly works
09:16:12 <chessguy_work> i've looked at them, but i don't get it
09:16:17 <byorgey> quicksilver: what's inelegant about it?
09:16:42 <JohnMeacham> gurgle.
09:16:49 * shapr gargles instead
09:16:50 <JohnMeacham> that means hello.
09:16:53 <quicksilver> > let {l +++ m =  concat [[a,b] : (a,b) <- zip l m] ; pick 0 l = [[]] ; pick n [] = []; pick n (x:xs) = map (x:) (pick (n-1) xs) +++ pick n xs } in pick 3 [2..]
09:16:54 <lambdabot>  Parse error
09:17:05 <dcoutts_> chessguy_work: I think someone had a good explanation on one of the Haskell lists recently, google the archives for coarbitrary
09:17:08 <bringert> nominolo: look spretty ok. my main concern is a simple API. readFile has a very simple type. it has gotchas, but most people don't run into them, and if they do, the answer is simple: force the string
09:17:11 <quicksilver> > let {l +++ m =  concat [[a,b] | (a,b) <- zip l m] ; pick 0 l = [[]] ; pick n [] = []; pick n (x:xs) = map (x:) (pick (n-1) xs) +++ pick n xs } in pick 3 [2..]
09:17:13 <chessguy_work> ok
09:17:15 <lambdabot>  Exception: stack overflow
09:17:19 <quicksilver> byorgey: bah :P
09:17:37 <byorgey> quicksilver: hmm
09:18:05 <bringert> dcoutts: how does that affect the API?
09:18:26 <dcoutts_> bringert: the api would still look like readFile
09:18:31 <shapr> @where ghc
09:18:31 <lambdabot> http://haskell.org/ghc
09:18:35 <bringert> dcoutts: ah, ok
09:18:47 <JohnMeacham> I have decided that I am a big fan of 'Word' instead of 'Int'. many needless checks for negative numbers are done when we could have just used Word in the type signature for things and let the type system take care of things statically.
09:18:56 <shapr> Is there some way to edit the GHC library docs via a wiki?
09:19:08 <byorgey> quicksilver: something like this doesn't already exist in some sort of combinatorics module somewhere?
09:19:15 <bringert> nominolo: basically I think there should be an API approximately like this:
09:19:26 <shapr> I found a typo in the Control.Concurrent docs and I'd like to fix it.
09:19:28 <JohnMeacham> I think the aversion to unsigned types is a holdover from C where the odd promotion rules and automatic casting could lead to unexpected results when mixing signed and unsigned arithmetic.
09:19:29 <bringert> get :: URL -> IO Lazy.ByteString
09:19:55 <bringert> getWithHeaders :: [(String,String)] -> URL -> IO Lazy.ByteString
09:20:14 <bringert> post :: URL -> Lazy.ByteString -> IO Lazy.ByteString
09:20:30 <bringert> postWithHeaders :: [(String,String)] -> URL -> Lazy.ByteString -> IO Lazy.ByteString
09:20:47 <bringert> hmm, you also need a way to get at the response headers
09:21:14 <bringert> anyway, that isn't the final API of course, but it should be much more complex than that
09:21:31 <bringert> taking hints from Oleg when designing APIs is not neccessarily a good idea
09:21:36 <dcoutts_> bringert: so it'd basically download it to disk and give it to the caller at the same time, with some scheme to shortcut the disk access if the caller is consuming sufficiently quickly.
09:21:47 <shapr> hah
09:21:59 <nominolo> dcoutts_: that sounds complicated
09:22:14 <bringert> dcoutts: I think the the default behavior should be to not cache, but there could be a variant that does that
09:22:19 <bringert> or a higher level library
09:22:37 <bringert> you could easily implement the caching version on top of the non-caching one
09:22:44 <nominolo> imo, that should be higher-level
09:23:21 <bringert> dcoutts: I would guess that for large downloads, most apps would write to disk anyway
09:23:44 <dcoutts_> bringert: that's fine, if you do it right, there should be 0 extra copies
09:24:18 <nominolo> dcoutts_: do you have any comments on the left-fold or withLazyHTTP api?
09:24:58 <dcoutts_> nominolo: the disadvantage of those is that it still does not deal with the problem of the client hogging the connection, taking too long to consume the data that is arriving over the network
09:25:22 <chessguy_work> @src rem
09:25:33 <nominolo> dcoutts_: hm, right.
09:25:35 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:25:43 <chessguy_work> @src (rem)
09:25:44 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:26:01 <mdmkolbe|work> @type rem
09:26:03 <lambdabot> forall a. (Integral a) => a -> a -> a
09:26:08 <mdmkolbe|work> @src Integral
09:26:09 <lambdabot> class  (Real a, Enum a) => Integral a  where
09:26:09 <lambdabot>     quot, rem, div, mod :: a -> a -> a
09:26:09 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
09:26:09 <lambdabot>     toInteger           :: a -> Integer
09:26:31 <nominolo> @src Integral rem
09:26:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:26:33 <dcoutts_> bringert: I'd imagine it'd work like this: get :: URL -> LBS, forks a thread and pulls chunks as fast as possible into an in-memory pool of chunks. At the same time it sets up a lazy bytestring that pulls from the buffer/chunk pool. If the size of that pool starts to get too large (ie the consumer is being too slow) then we write some of the chunks out to disk.
09:26:35 <mdmkolbe|work> @src (rem :: Int -> Int -> Int)
09:26:35 <lambdabot> Source not found. My mind is going. I can feel it.
09:26:42 <dcoutts_> bringert: ie it's totally transparent
09:27:03 <dcoutts_> bringert: and in the normal cases adds essentially no overhead
09:27:18 <sjanssen> whoa, shoulda simple function like 'get' really be writing to disk?
09:27:24 <bringert> dcoutts: sure, but it requires access to a file system with free space
09:27:39 <bringert> dcoutts: also, what sjanssen said
09:27:40 <byorgey> @pl \x y -> [x,y]
09:27:41 <lambdabot> (. return) . (:)
09:27:47 <sjanssen> dcoutts_: just let virtual memory take care of it
09:27:51 * kolmodin is trying to relax... :)
09:27:54 <sjanssen> it was invented for a reason :)
09:28:08 <bringert> kolmodin: hey, you've still gotta finish your report :-P
09:28:10 <dcoutts_> sjanssen: one can be more explicit by using the tmpfs
09:28:13 <ski_> > let [] +++ ys = ys; (x:xs) +++ ys = x:(ys+++xs); pick 0 _ = [[]]; pick _ [] = []; pick n (x:xs) = map (x:) (pick (n-1) xs) +++ pick n xs in pick 3 [0..]
09:28:15 <lambdabot>  [[0,1,2],[1,2,3],[0,2,3],[2,3,4],[0,1,3],[1,3,4],[0,3,4],[3,4,5],[0,1,4],[1,...
09:28:25 <kolmodin> bringert: not today! not today!...
09:28:26 <kolmodin> :D
09:28:47 <nominolo> dcoutts_: ok, that's definitely higher-level stuff.  like robustGet or sth.
09:28:57 <bringert> dcoutts: I would be a nice high-level library, but I don't think the basic HTTP library should be adding that complexity to the implementation
09:29:00 <nominolo> or "getCaching"
09:29:10 <kolmodin> bringert: Aarne is visiting the univ in Tartu?
09:29:23 <dcoutts_> sjanssen: bringert: btw this is how web browsers do it as far as I understand.
09:29:32 <bringert> @google nodalida
09:29:35 <lambdabot> http://phon.joensuu.fi/nodalida2005/
09:29:35 <lambdabot> Title: NODALIDA 2005
09:29:37 <ski_> (quicksilver)
09:29:46 <bringert> kolmodin: har Ã¤r pÃ¥ NODALIDA
09:29:49 <dcoutts_> bringert: nominolo: well you can do it without writing to disk, that just limits the amount downloaded
09:29:55 <kolmodin> bringert: ahhh
09:30:37 <dcoutts_> bringert: nominolo: the point is to keep management of the socket, don't let it be determined by how/when/if the caller actually consumes the data.
09:30:39 <kolmodin> bringert: och du stannade hÃ¤r fÃ¶r min skull? aaaww... :)
09:30:56 <bringert> dcoutts: yeah, that's what you should do in many apps, and it would be good to have a library for it. I'm just saying that it could be something that sits on top of the HTTP library
09:31:03 <dcoutts_> bringert: nominolo: erm, rather it limits the amount kept in memory at once
09:31:20 <bringert> kolmodin: hrrm, eh, nja
09:31:28 <dcoutts_> bringert: but it really affects the way your api works, if you want a simple api
09:31:29 <kolmodin> :D
09:31:36 <sjanssen> won't most HTTP downloads be less than 1MB, anyway?
09:31:49 <bringert> dcoutts: why?
09:32:21 <byorgey> _ski: nice!  although those sure come out in a strange order =)
09:32:22 <bringert> you mean that the memory and connection hogging behavior is changed?
09:32:35 <dcoutts_> bringert: otherwise you expose in the api the tricky issues of who is responsible for closing the socket, either by left fold IO combinators or withLazyHTTP or similar things
09:33:01 <LoganCapaldo> interleaveHTTP!
09:33:01 <bringert> dcoutts: why not just close the socket at the end of the bytestring? like readFile does
09:33:16 <bringert> eh
09:33:26 <bringert> what if server doesn't close the socket
09:33:34 <dcoutts_> bringert: readFile doesn't bork if you're slow consuming the data
09:33:40 <quicksilver> FWIW my opinion is this: Please provide an asynchronous (explicitly thread, using IO) and synchronous version, both of which don't use unsafeInterleave tricks
09:33:52 <dcoutts_> bringert: disks tend to have infinite patience, network servers don't.
09:33:56 <ski_> byorgey : yes, '(/\/)' .. er i mean '(+++)' is to blame for that .. (and possibly the order of the actual parameters to it in the call)
09:34:03 <quicksilver> if you wish to also provide a third 'magical' unsafeinterleave version, please so
09:34:08 <quicksilver> do so :)
09:34:44 <bringert> dcoutts: but the timeouts are at least tens of seconds, right?
09:34:45 <dcoutts_> quicksilver: so the synchronous version reads the entire ISO into memory before returning?
09:35:06 <quicksilver> dcoutts_: yes
09:35:09 <dcoutts_> bringert: yeah, but you can't control the consumer at all
09:35:22 <quicksilver> dcoutts_: most http GETs are not 650 M, though
09:35:32 <quicksilver> dcoutts_: that version could bomb out above a certain configurable limit
09:36:02 <bringert> dcoutts: well, I would guess that in most apps, the consumer would be fast enough, so that problem should only be for special apps
09:36:06 <dcoutts_> quicksilver: but why would you want a limited version of the api if it wasn't even any more simple/convenient?
09:36:09 <quicksilver> dcoutts_: i could imagine a synchronous -> straight to file version too
09:36:13 <bringert> dcoutts: and those could force the string, or use a caching layer
09:36:29 <quicksilver> dcoutts_: in my mind it's more simple/convenient to avoid IO interleaving and avoid temporary files
09:36:35 <dcoutts_> bringert: I should have never used the word caching, it gives the wrong impression
09:36:35 <quicksilver> dcoutts_: I concede that this is subjective
09:37:08 <bringert> dcoutts: I understand that you don't mean caching to avoid another request for the same thing
09:37:15 <sjanssen> you can make all of this user-configurable
09:37:27 <sjanssen> start with the naive lazy ByteString approach
09:37:36 <bringert> dcoutts: I guess on-disk buffering is a more accurate term
09:37:36 <dcoutts_> bringert: my suggestion really is to decouple the demand from the consumer from the demand we place on the server.
09:37:53 <dcoutts_> bringert: but even in-memory would be ok
09:37:57 <sjanssen> then write a function, demand :: ByteString -> IO ByteString.  demand will fork a thread and force chunks of the ByteString
09:38:32 <sjanssen> if you expect a slow consumer, then use: result <- demand =<< get url
09:38:32 <dcoutts_> actually, yes that's a self-contained operation 'demand'
09:38:46 <nominolo> i agree with sjanssen the lazy bytestring api is the most flexible
09:38:50 <bringert> dcoutts: yeah, I understand. but compare it to something using a C-style block recv. that would also fail if the time between the recvs is too long
09:38:51 <quicksilver> dcoutts_: IO interleaving with network IO is even more painful than files; the chances of an exception (which doesn't get discovered until you're in pure code) are much higher
09:39:01 <dcoutts_> however doing it inside the http api means you get control over when the socket can be closed or re-used for another incomming request.
09:39:06 <quicksilver> dcoutts_: for many cases I would rather know up-front that there had been an exception
09:39:18 <sjanssen> you could also provide synchronous, which forces the entire string before returning
09:39:32 <dcoutts_> yes, that'd cover quicksilver's issue
09:40:19 * bringert goes home
09:40:44 <nominolo> quicksilver: do you happen to know where exceptions are thrown in the case of lazy bytestrings?
09:41:02 <quicksilver> by 'explicitly asynchronous' by the way, I mean one which forks off a thread and hands you an MVar to tell if it's done
09:41:32 <quicksilver> so I could fork of 10 downloads (persumably being downloads straight-to-file) and do something when they've all arrived
09:41:38 <quicksilver> or when the first arrives,
09:41:38 <quicksilver> etc
09:42:23 <nominolo> quicksilver: but then you'd need polling
09:42:32 <nominolo> to close the socket
09:42:33 <quicksilver> nominolo: no you wouldn't
09:42:39 <quicksilver> nominolo: the socket would be closed when the download completes
09:42:48 <quicksilver> nominolo: and then it would signal its completion with the MVar
09:43:24 <quicksilver> nominolo: to answer your question, I think the exception gets signalled when you force the chunk which causes the error.
09:43:25 <nominolo> why do you need to know when it's done?
09:43:35 <quicksilver> nominolo: so I know it's safe to display on the screen of my web browser
09:43:38 <quicksilver> (or whatever)
09:43:47 <quicksilver> presumably I downloaded it for some reason
09:44:17 <sjanssen> what is the use case for the HTTP library?
09:44:25 <quicksilver> I think there are multiple, aren't there?
09:44:25 <kfish> sjanssen, quicksilver: bigger http downloads are getting quite common, like from youtube etc. -- i'm using HTTP1 to test video server atm ...
09:44:29 <nominolo> quicksilver: well, it's done when your processing function returned.  no matter what, you're not done processing when the file is downloaded
09:44:42 <quicksilver> nominolo: true
09:44:43 <sjanssen> kfish: ah, that is a good point
09:45:01 <quicksilver> nominolo: but I may not wish to start trying to display a graphic until I know it's all there.
09:45:13 <quicksilver> kfish: I totally agree. I just don't think the API should center around them.
09:45:22 <quicksilver> kfish: I agree streaming-really-big is a useful feature
09:45:27 <quicksilver> kfish: but it's not the only use case
09:45:35 <nominolo> quicksilver: you could do that with BS.length
09:45:46 <quicksilver> nominolo: yes, I could
09:45:59 <quicksilver> nominolo: but that's a hack
09:46:02 <nominolo> or BS.length . BS.take bigchunk
09:46:26 <quicksilver> nominolo: sometimes, I just want to know when the download has finished.
09:46:32 <quicksilver> nominolo: I don't think that's a strange requirement!
09:47:00 <nominolo> quicksilver: i still think that could be put in the UserAgent/Browser layer
09:47:17 <quicksilver> I don't like the idea of having 'unsafe' things under the hood and then abstracted away
09:47:23 <quicksilver> I'd much rather have a totally safe layer
09:47:25 <nominolo> ie., it doesn't disallow the simple LBS based API
09:47:34 <quicksilver> which I can then put the unsafe magic on top of
09:47:47 <nominolo> quicksilver: oh, then you'd better not use haskell
09:48:05 <quicksilver> nominolo: !?
09:48:28 <nominolo> quicksilver: what do you think starts the execution of main?
09:48:35 <quicksilver> the runtime system
09:48:38 <nominolo> unsafeInterleaveIO
09:48:40 <quicksilver> nothing 'unsafe' about that
09:48:46 <quicksilver> no, it isn't
09:48:59 <quicksilver> unsafeInterleave allows you to embed IO continuations in pure structures
09:49:05 <quicksilver> just having a 'main' allows no such thing
09:51:42 <nominolo> i still think the LBS api is the most flexible for building higher complicated things above
09:52:23 <quicksilver> the LBS api is, of course, a thing of beauty
09:52:26 <quicksilver> to which I have no objections
09:52:39 <quicksilver> however, using unsafeInterleaveIO with LBS is a can of worms
09:52:51 <quicksilver> and personally I'd prefer that can wasn't open by default
09:53:00 <Botje> you don't like worms?!
09:53:12 <dcoutts_> quicksilver: basically you object to lazy IO
09:53:12 <nominolo> quicksilver: getContents :: IO LBS is implemented in terms of unsafeInterleaveIO
09:53:24 <quicksilver> dcoutts_: yes, you already knew this :)
09:53:30 <quicksilver> nominolo: I know
09:53:47 <quicksilver> nominolo: hence, I think LBS is beautiful, but not it's applications with unsafeInterleave, like getContents
09:54:01 <nominolo> quicksilver: ok, so you'd rather chunk yourself?
09:54:07 <quicksilver> nominolo: actually, I *do* think that the unsafeInterleaveIO hack has beauty of its own
09:54:23 <quicksilver> but it's still a hack, and I think it's nice to be able to choose when to use it
09:54:28 <DRMacIver> What on earth does unsafeInterleaveIO do?
09:54:46 <dcoutts_> DRMacIver: it delays when the action happens until it is demanded
09:54:46 <quicksilver> DRMacIver: it enables you to 'hide' some IO magic from the program so it only gets called when a thunk is evaluated
09:54:50 <DRMacIver> ok
09:54:54 <DRMacIver> Hm
09:54:56 <quicksilver> DRMacIver: so you can interleave the IO with pure computation
09:55:02 <dcoutts_> it's what you use to build lazy IO
09:55:02 <ski_> unsafeInterleaveIO :: IO a -> IO a
09:55:13 <DRMacIver> And what's LBS? When I search for "Haskell LBS" I get "Registered sex offenders in Haskell, Texas". :)
09:55:17 <nominolo> quicksilver: oh, ok, so you'd be fine with a left-fold strict chunk consuming (alternative) interface?
09:55:25 <nominolo> quicksilver: that would be no problem
09:55:40 <nominolo> DRMacIver: Lazy ByteStrings
09:55:43 <DRMacIver> Ah
09:55:43 <quicksilver> nominolo: in principle definitely :) Although it would be an interesting challenge to have one of those which feels 'simple and easy'
09:55:49 <ski_> unsafeInterleaveIO m = return (unsafePerformIO m)
09:56:06 <dcoutts_> ski_: it's a bit safer that than that actually
09:56:10 <nominolo> quicksilver: well, that's what i asked for in my mail
09:56:22 <chessguy_work> wow, there is a haskell, TX. and it's a very organized place: http://maps.google.com/maps?f=q&hl=en&q=haskell,+TX&ie=UTF8&ll=33.159397,-99.733458&spn=0.029244,0.079823&z=14&iwloc=addr&om=1
09:56:25 <lambdabot> Title: Google Maps, http://tinyurl.com/yq4cov
09:56:36 <ski_> dcoutts_ : in what sense do you mean ?
09:56:53 <nominolo> quicksilver: but i didn't get any ideas for better interfaces so far
09:57:01 <dcoutts_> @src unsafeInterleaveIO
09:57:01 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
09:57:16 <dcoutts_> ski_: it doesn't invent any new state token
09:57:26 <Igloo> chessguy_work: Is it more so than your average US city?
09:57:29 <ski_> ah
09:57:36 <chessguy_work> Igloo: definitely
09:57:51 <quicksilver> nominolo: I think there is value in the explicitly threaded, and the purely strict/synchronous, as alternatives
09:58:03 <quicksilver> nominolo: I'm not saying the cute Lazy IO shouldn't be an option
09:58:10 <quicksilver> nominolo: just that it shuoldn't be the only option
09:58:58 <nominolo> quicksilver: ok, that can be arranged for (and in fact i wasn't planning to do, anyways)
09:59:05 <nominolo> s/was/wasn't/
09:59:23 <nominolo> arg
09:59:32 <nominolo> hm, is wasn'tn't = was ?
10:00:09 <quicksilver> :)
10:00:40 <quicksilver> for example, multiget : [URL] -> [(MVar,FilePath)]
10:00:42 <freshhawk> have you guys already considered using a strict lower level lib and having a browser/useragent supply a nice LBS interface (with some mem/disk caching or something)
10:00:50 <quicksilver> which downloads in the background, and gives you MVars to know when they're ready
10:00:56 <quicksilver> that would be a cute construct :)
10:01:02 <chessguy_work> ?check (not.not) (x::Bool) == id x
10:01:02 <quicksilver> (easy enough to layer over one of the others)
10:01:02 <lambdabot>   Not in scope: `x'
10:01:17 <chessguy_work> i can never figure out how to do that
10:01:46 <chessguy_work> ?check f x = (not.not) (x::Bool) == id x
10:01:46 <lambdabot>  Parse error
10:01:47 <nominolo> freshhawk: considered--of course. done--not yet.
10:02:15 <chessguy_work> ?check \x -> (not.not) (x::Bool) == id
10:02:15 <lambdabot>  Couldn't match expected type `Bool' against inferred type `a -> a'
10:02:17 <nominolo> freshhawk: though, LBS has its issues, so it can't be the only option
10:02:31 <nominolo> freshhawk: see backlog
10:02:37 <Jaak> ?check \x -> (not . not) (x :: Bool) == x
10:02:38 <lambdabot>  OK, passed 500 tests.
10:02:42 <chessguy_work> ?check \x -> (not.not) (x::Bool) == \x -> id (x :: Bool)
10:02:42 <lambdabot>      The lambda expression `\ x -> ...' has one argument,     but its type `B...
10:03:42 <freshhawk> nominolo, of course, i'm trying to scroll back and catch myself up here, but i was seeing some mention of lazy socket reading which is something i would avoid (although that's probably because i'm no haskell guru)
10:03:43 <nominolo> quicksilver: yes, multiget should be relatively easy in to do, but this should be in Network.UserAgent
10:03:44 <chessguy_work> why do i have such a stinking hard time with QuickCheck?
10:04:28 <ski_> @check \x -> (not . not) x == id x
10:04:29 <lambdabot>  OK, passed 500 tests.
10:04:36 <nominolo> freshhawk: yes, but you can't have LBS without lazy IO,  so there are issues to take care of.
10:04:58 <Apocalisp> chessguy_work: Having problems with QuickCheck, mate?
10:05:16 <nominolo> freshhawk: one workable solution would be to read lazily from disk-buffered network reads.  though that's higher-level
10:05:19 <quicksilver> nominolo: you can do strict IO net -> file
10:05:23 <chessguy_work> Apocalisp: i've never been able to use it
10:05:26 <quicksilver> nominolo: and then lazy IO file -> app
10:05:38 <quicksilver> nominolo: arguably that reduces the risk of exceptions, and decouples you from the server
10:05:51 <nominolo> quicksilver: yes, that's what dcoutts_ suggested.  but it shouldn't be part of the basic API
10:05:54 <freshhawk> nominolo, that's what i was thinking, mostly because you probably want to get data off the wire asap in the general case
10:05:59 <quicksilver> nominolo: (and for sufficiently small requests it makes perfect sense to go strict net -> mem)
10:06:46 <pitecus> I have some simple code to calculate mean hamming distance between two lists of lists. In pure haskell it is around 30 times slower than when calling out to C using FFI, and about 7 times slower than equivalent Java code. Would that be the performance I should expect?
10:07:03 <dcoutts_> nominolo: I suggested the same but in memory, then it doesn't make people worry about file IO
10:07:09 <quicksilver> I think allowing the client to dictate the rate of data consumption from the server is likely to be harmful
10:07:16 <quicksilver> in many, many cases
10:07:24 <quicksilver> and subject you to all kinds of annoying 'bug' reports that aren't bugs
10:07:39 <Apocalisp> ?check (\x -> (not . not) (x :: Bool)) = id
10:07:40 <lambdabot>  Parse error
10:07:41 <dcoutts_> pitecus: probably in C and Java you're using arrays rather than lists, if you use arrays in Haskell you might expect the same performance.
10:07:43 <Apocalisp> ?check (\x -> (not . not) (x :: Bool)) == id
10:07:44 <lambdabot>   add an instance declaration for (Eq (Bool -> Bool))     In the expression: ...
10:07:48 <quicksilver> app does nothing for 5 minutes after consuming just a little of the stream
10:07:53 <quicksilver> then user wakes up and clicks something
10:07:57 <quicksilver> server has gone away
10:08:00 <quicksilver> and app gets exception in pure code
10:08:18 <nominolo> quicksilver: but we'd want the quick'n'dirty read-LBS-from-socket but use at you're own risk
10:08:39 <nominolo> quicksilver: the default interface should be the UA anyways
10:08:39 <pitecus> dcoutts, i dont see why that would matter much in this case, the code is basically "mean $ [fromIntegral (hammingDistance xs ys) | xs <- xss , ys <- yss ]"
10:09:13 <Apocalisp> chessguy_work: (Bool -> Bool) is not of class type Eq.
10:09:29 <quicksilver> nominolo: I'm not sure I really see the use case for quick'n'dirty LBS
10:09:31 <pitecus> when I tried using lists of arrays it got even slower
10:09:37 <quicksilver> nominolo: if it's a small amount of data, then why bother to make it lazy?
10:09:40 <Apocalisp> s/class type/type class/
10:09:48 <quicksilver> nominolo: if it's a large amount of data, you probably need to be more careful anyway
10:09:51 <dcoutts_> pitecus: sadly that mean will not fuse currently with that list comp
10:10:06 <nominolo> quicksilver: well, simplest use case:  wget
10:10:33 <pitecus> dcoutts, should i try fusing it manually?
10:10:36 <dcoutts_> pitecus: how big is xss?
10:10:40 <quicksilver> nominolo: I think you should provide a primitive which writes (strictly) to a file
10:10:44 <quicksilver> nominolo: for that kind of case
10:11:13 <pitecus> dcoutts, xss is 10K, yss is 1K
10:11:14 <nominolo> quicksilver: the strict version takes 18 sec, the lazy 11 for 175 MB
10:11:17 <dcoutts_> pitecus: that might make a difference, it depends on where the real cost is, if most of the time is in hammingDistance then fusing the outer bit will not help much
10:11:19 <nominolo> (local traffic)
10:11:20 <ddarius> Also Int/Integer issue?
10:11:38 <pitecus> dcoutts, hammingDistance xs ys = foldl' (\z x -> if x then z+1 else z) 0 $! zipWith (/=) xs ys
10:11:57 <pitecus> so it just counts number of positions at which the two lists differ
10:12:11 <pitecus> those lists are short, 24 elements
10:12:20 <nominolo> quicksilver: and the strict version takes 175 mb of ram of course,  and it doesn't start writing before it's done reading
10:13:05 <dcoutts_> pitecus: sounds like the main cost is in the lists then (assuming generating xss and yss isn't so expensive)
10:13:34 <dcoutts_> pitecus: the current fusion system will not cope well with zipWith either (though a new experimental one I work on will)
10:13:51 <dcoutts_> pitecus: so you might find that manually defusing all the lists makes a big difference
10:14:04 <dcoutts_> erm fusing / deforesting
10:14:12 <pitecus> dcoutts, ok
10:14:28 <pitecus> dcoutts, i dont see how to avoid that zipWith tho....
10:15:00 <dcoutts_> pitecus: I'm not suggesting you can avoid it, I just mean that it will not get eliminated automatically at the moment
10:15:32 <pitecus> dcoutts, well that sort of implies it can be eliminated manually
10:15:40 <pitecus> i m not sure how to do that
10:16:14 <dcoutts_> pitecus: generate the list elements at the same time you consume them
10:18:19 <pitecus> Sorry im dumb but i dont see how to do this for this function...
10:19:09 <pitecus> write out a recursive loop?
10:19:36 <dcoutts_> pitecus: right, it makes it much less modular and more ugly
10:20:17 <dcoutts_> pitecus: nobody likes to do that, which is why we investigate better fusion systems :-)
10:20:27 <byorgey> question - I have a function f :: a -> [a], and I want to chain it a certain number of times, like l >>= f >>= f >>= f >>= ...
10:20:31 <pitecus> dcoutts, haskell must have altered my brain, I was unable to envisage a solution involving a look....
10:20:38 <pitecus> loop
10:20:42 <dcoutts_> :-)
10:20:43 <byorgey> I'm sure there's a slick way to do it with some sort of HOF from Control.Monad but I can't seem to figure it out...
10:21:14 <Saizan> ?type \f l -> iterate (>>= f) l
10:21:20 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b -> [m b]
10:21:38 <byorgey> Saizan: thanks!
10:21:40 <dcoutts_> byorgey: or cycle & sequence_
10:22:26 <byorgey> dcoutts_: I thought sequence collects a list of results?
10:23:01 <dcoutts_> yes it does, so perhaps not what you want exactly
10:23:33 <kpreid> byorgey: l >>= f >>= f ... can't be expressed by a combinator in Haskell's type system
10:23:46 <kpreid> because the type of the result depends on the number of iterations of f
10:24:09 <Saizan> ?type \f l n -> iterate (>>= f) l !! n  -- kpreid?
10:24:11 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b -> Int -> m b
10:24:16 <byorgey> kpreid: ?  I don't think that's true
10:24:22 <kpreid> oops
10:24:30 <kpreid> sorry, I was thinking f :: a -> [[a]]
10:24:37 <kpreid> for which what I said is true
10:24:41 <byorgey> kpreid: ah, indeed
10:25:10 <_roconnor> @type mfix
10:25:12 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:25:32 <byorgey> _roconnor: ooh shiny =)
10:25:37 <kpreid> @hoogle untilM
10:25:37 <lambdabot> No matches found
10:38:27 <quicksilver> nominolo: by strict IO I don't mean you have to do it all in one go :P
10:38:47 <quicksilver> nominolo: you are free to read in reasonable chunks using standard blocking IO calls, like you would in C
10:39:42 <nominolo> nominolo: but then you have to make sure you consume the chunks quickly enough
10:39:49 <pitecus> How come there is Control.Monad.State.Lazy but no Control.Monad.State.Strict?
10:39:53 <nominolo> getContents reads in chunks too
10:40:13 <monochrom> There is.
10:40:16 <quicksilver> nominolo: I'm talking about strict to a file
10:40:36 <quicksilver> nominolo: so that relies on the FS being able to consume as fast as the server can provide
10:40:44 <quicksilver> nominolo: but that's not an unreasonable hope
10:40:52 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Strict.html
10:40:54 <lambdabot> http://tinyurl.com/2a5opx
10:41:36 <nominolo> quicksilver: yes, it's just:  get url >>= hPutStr filehandle
10:41:42 <quicksilver> nominolo: I'm not sure I'm expressing myself very clearly; and my connection is now not good. I shall write it up in an email, which you can consider or ignore as you prefer :)
10:42:21 <nominolo> quicksilver: yes, please :)
10:42:23 <quicksilver> nominolo: shall I send it to the cafe?
10:42:42 <nominolo> yes
10:44:26 <quicksilver> nominolo: I'll reread your two emails, too.
10:44:49 <pitecus> aha
10:46:08 <monochrom> New since 6.6.1 :)
10:54:39 <hpaste>  pitecus pasted "stack overflow" at http://hpaste.org/28
10:55:01 <pitecus> i pasted a small function which casues a stack overflow i cant locate....
10:56:56 <byorgey> @src forM_
10:56:56 <lambdabot> forM_ = flip mapM_
10:57:13 <byorgey> pitecus: doesn't help with the stack overflow, but... =)
10:57:38 <pitecus> byorgey, ya i know it is in some module which i felt to lazy to import
10:58:01 <byorgey> pitecus: fair enough.
10:59:06 <pitecus> btw overflow also happens when i use the strict state monad...
11:00:21 <edwardk> Hrmm. How bad would you find a language that had a crapload of nice undecidable-in-general features, higher-order predicate subtypes, polymorphic records, exensible cases, etc. really sexy types, but which when confronted with a type it couldn't infer threw up a big red warning, treated it untyped, but still let things compile and run?
11:01:27 <Saizan> so it doesn't have typeclasses?
11:01:28 <edwardk> the absence of warnings would indicate a fully correct program, in which you got to use the spiffy features. warnings indicating that something may go wrong (pretty much falling back to a haskell-like typable default where possible), then really bad warnings for the untypable stuff, and errors for when it can prove a counterexample will hold.
11:02:07 <edwardk> typeclasses are still decidable, because i can carry the actual runtime type along with the term, and typecase it
11:02:51 <kpreid> edwardk: does that work for, say, maxBound?
11:03:11 <Saizan> ah ok, so the uninferred terms are dinamically typed rather than untyped?
11:03:28 <edwardk> yeah, i should have said dynamically typed.
11:04:04 <edwardk> kpreid: yeah, though the result of maxBound would necessarily also be dynamically typed.
11:04:10 * kpreid nods
11:04:22 * kpreid wrote a dynamic Haskell interpreter once
11:04:45 <Saizan> sounds like a fun language :)
11:04:54 <edwardk> ok. =)
11:05:17 <Saizan> if it doesn't take hours to compile..
11:05:57 <kpreid> edwardk: what would [dynamically-turns-out-to-be-Integer, dynamically-turns-out-to-be-String] do?
11:05:59 <edwardk> shouldn't be bad, most of what the compiler does is 'best-effort' anyways
11:06:45 <edwardk> depends on what the function you called to map over that list did with them, probably get pretty ugly ;)
11:07:09 <kpreid> ah, so the same as my interpreter then :)
11:08:08 <edwardk> [1,"String"] would fail to find an common form, yell really loud, then it would have to typecase to dispatch appropriately based on the runtime type of the term
11:08:35 <edwardk> i'm trying to avoid something THAT loose though.
11:09:14 <edwardk> right now most of the warnings are things like "couldn't prove that you weren't going to call head on an empty list here" sort of things. ;)
11:11:33 <edwardk> but if dependent types slip in in full generality there are some uninferable result types from, say, case analysis that may wind up with some weird 'should have had a type annotation' terms with no decidable principal type, then carrying the runtime type around would let me still typecase for dispatch
11:12:16 <edwardk> rather than error out and force the annotation, i'm being difficult and trying to see how bad things get if i just allow them to proceed ;)
11:12:35 <nominolo> edwardk: would you be able to have something like positive/negative blame?
11:13:00 <edwardk> nominolo: like this was where the problem was that led to this being untyped?
11:13:05 <edwardk> er dynamically typed
11:13:13 <nominolo> yes
11:13:25 <edwardk> yeah, i can spot where it happened.
11:13:32 <nominolo> i think wadler used it in that web-language
11:13:33 <edwardk> and give you a nice neon sign pointing to it
11:13:35 <nominolo> links or so
11:13:45 <edwardk> ah good, precedent ;)
11:14:05 <nominolo> edwardk: sounds fun, yup
11:14:51 <edwardk> cool. lastly does anyone know of any more recent work on optimistic evaluation than http://research.microsoft.com/Users/simonpj/Papers/optimistic/index.htm ?
11:14:53 <lambdabot> Title: Optimistic Evaluation: a fast evaluation strategy for non-strict programs, http://tinyurl.com/ynnnl7
11:18:25 <haskellnew> what are the symbols for bitwise operator in haskell
11:18:51 <lekro> haskellnew: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
11:18:52 <edwardk> the idea being to at every core let binding, check to see if we're allowed to run it optimistically, try to compute it eagerly, and then just use the result, and if we take too long, give up, store a continuation and make the thunk, and disable this let binding from ever being used eagerly again.
11:18:53 <lambdabot> http://tinyurl.com/y8kr9v
11:19:16 <edwardk> plus a bunch of other stuff, but the first part is the big idea
11:19:46 <nominolo> sounds hacky
11:19:50 <nominolo> "takes too long"
11:20:01 <edwardk> only finitely many let bindings in the program, so it will asymptotically approach lazy behavior over time
11:20:47 <nominolo> yes, but performance will degrade the more lazy feature you use
11:20:57 <edwardk> but it can win big on other problems, and with aggressive inlining really targets where laziness is used.
11:21:17 <pitecus> sorry, im gonna try asking again: any idea what might be causing stack overflow here: http://hpaste.org/28
11:21:53 <edwardk> nominolo: only the first time that let binding is invoked eagerly. in my case if i provide you with a substructural type annotation to disable it entirely then you could say 'fib = pessimistically $ ...' or something
11:23:41 <nominolo> so, you'd make "delay" explicit, but "force" implicit?
11:24:17 <edwardk> no, you can explicitly say 'strictly' or 'pessimistically', the default is 'eager with lazy semantics' ;)
11:24:56 <pejo> nominolo, Ennals dissertation is a good read. It's not just random hacking.
11:25:18 <nominolo> hmm.  i have to read up on that first, yes.
11:25:23 <edwardk> its nicer than my original version which was to say i'll diverge whenever i darn well please if either strict or lazy evaluation might ;)
11:25:32 <edwardk> now the default is safe and possibly really fast
11:26:08 <edwardk> and naively written programs no longer build up long accumulation thunks, etc.
11:27:17 * shapr kicks threading
11:27:34 <haskellnew> lekro : thanks , but why cant i have  this  in my code "bb=255 (.&.) 255"
11:27:35 <nominolo> hm, sounds interesting.
11:27:40 <edwardk> the biggest problem left space leak wise would be from abused CAFs.
11:27:48 <nominolo> haskellnew: remove the parens
11:28:14 <dolio> pitecus: At a guess, I'd say that modify is still too lazy, but you said you still got an overflow with strict state, which I would expect to solve the problem.
11:28:27 <nominolo> haskellnew: (.&.) 255 255 = 255 .&. 255
11:29:05 <pitecus> dolio, ya I'm using the strict state monad
11:29:21 <nominolo> edwardk: what did CAF stand for again?
11:29:22 <edwardk> haskellnew (!*@) is the way to write an infix binary operator in prefix form.
11:29:28 <pitecus> dolio, any idea how to make modify stricter?
11:29:33 <edwardk> constant applicable form
11:29:58 <edwardk> i.e. if i had a top level value that was like from1 = from 1 where from n = n : from (n + 1)
11:30:00 <Apocalisp> (.&.) looks like... boobies.
11:30:11 <nominolo> Apocalisp: (.).(.)
11:30:22 <edwardk> from1 is 'attached' to the root of the code, so if i inspect the first million terms, there is a chain for the garbage collector to follow for all time
11:30:26 <Apocalisp> @type (.).(.)
11:30:29 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:30:34 <nominolo> edwardk: i understand
11:30:36 <haskellnew> nominolo: thanks , it worked  in code
11:30:37 <dolio> pitecus: Nope. It could be something else, though. Are you sure hammingDistance isn't overflowing?
11:31:59 <pitecus> dolio, i dont think so
11:33:17 <pitecus> sometimes laziness is so mysterious...
11:33:53 <Apocalisp> Ooh, me too.
11:34:09 <Apocalisp> http://hpaste.org/29
11:34:26 <Apocalisp> I'm trying to figure out why that overflows.
11:35:51 <Apocalisp> is it zipWith?
11:35:54 <pitecus> Apocalisp, my guess would be sum
11:36:20 <pitecus> Apocalisp, try with sum = foldl' (+) 0
11:36:37 <Apocalisp> alright, thanks!
11:36:38 <haskellnew> nominolo : 255 .&. 255 does not work in GHCI but works fine in code
11:36:44 <haskellnew> why
11:37:04 <nominolo> > 255 .&. 255
11:37:05 <lambdabot>  Add a type signature
11:37:13 <edwardk> haskellnew: in ghci :m + Data.Bits
11:37:13 <nominolo> > 255 .&. 255 :: Int
11:37:14 <lambdabot>  255
11:37:24 <edwardk> that will load the module that has it in it
11:38:06 <haskellnew> why it need type signature for
11:38:30 <haskellnew> bits should always produce integers
11:38:58 <edwardk> :type (.&.)
11:39:00 <edwardk> er
11:39:04 <edwardk> @type (.&.)
11:39:06 <lambdabot> forall a. (Bits a) => a -> a -> a
11:39:18 <edwardk> Bits is defined for a wide array of integer-like types
11:39:27 <edwardk> including Ints
11:39:39 <haskellnew> and 255 is a type of Integer
11:40:07 <edwardk> but also including integers of different size, 64 bit, 32, etc. Integers of (nearly) unbounded size, etc, unsigned words, signed, etc.
11:40:24 <Apocalisp> @index foldl`
11:40:24 <lambdabot> bzzt
11:40:28 <Apocalisp> @index foldl'
11:40:28 <lambdabot> Data.List
11:40:49 <malsyned> If there are any Haskell Prime developers listening, consider this a vote for generalizing pattern matches into anonymous boolean functions: 'if (-> _:_) list then "Non-empty list" else "empty list"' or something similar.  the (-> ...) syntax is something I just threw out there for convenience and open to negotiation, but the idea is desirable, I think.
11:40:51 <Apocalisp> @src foldl'
11:40:51 <lambdabot> foldl' f a []     = a
11:40:51 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:41:04 <Apocalisp> nice
11:42:11 <Apocalisp> that works. Thanks pitecus.
11:42:31 <pitecus> Apocalisp, now figure out problem! ;-)
11:42:36 <pitecus> my problem
11:42:47 <Apocalisp> mmmokay... :-)
11:42:54 <haskellnew> edwardk : ok , thanks
11:42:56 <monochrom> There is no problem.
11:43:37 <pitecus> monochrom, there is a problem
11:43:58 <monochrom> There is no cabal.
11:44:25 <pitecus> there is stack overflow
11:44:32 <Apocalisp> There is no monochrom, only zuul.
11:45:23 <pitecus> azul
11:46:04 <Apocalisp> is mapM_ eager?
11:46:57 <monochrom> It uses >>=. The eagerness is in >>=
11:47:25 <pitecus> is flip eager?
11:47:25 <Chewie[]> is there a language with first-class types?
11:47:38 <MyCatVerbs> Chewie[]: yeah, some OO languages are, kinda.
11:47:40 <monochrom> But perhaps >>= is pretty eager by nature.
11:47:43 <Jaak> > take 10 . head $ (mapM return [1..] :: [[Int]])
11:47:47 <monochrom> flip is not eager.
11:47:50 <lambdabot> Terminated
11:48:26 <Jaak> oh
11:48:36 <Apocalisp> Alrighty. Does it overflow with any particular size of inputs?
11:48:39 <MyCatVerbs> Chewie[]: I think things like Python and friends have the property that any object also has a class object, which you can access with some method like "someobject.class()"
11:49:05 <Chewie[]> well, i'm trying to find an example of where you could overload + to do something meaningful in "type + type".
11:49:12 <MyCatVerbs> Chewie[]: (which itself _also_ has a class object, which also has a class object... off out into infinity)
11:49:15 <Chewie[]> concatenate data structure for example, but more coherent.
11:49:40 <pitecus> Apocalisp, Well even when both xss and yss and 1K elements
11:49:48 <pitecus> are
11:50:20 <titusg> has anybody got a copy of TAPL handy? I am confused by a function in the interpreter for ch. 4
11:50:20 <monochrom> mapM_ is unlikely to overflow.
11:50:24 <Chewie[]> MyCatVerbs: i'm also looking for something completely wacky just for the sake of trivia.. i know how python does it, doesn't seem too useful to me.
11:50:47 <dolio> Chewie[]: Dependently typed languages might qualify in some ways, too. Although I suppose that's the opposite direction, values can be used as types.
11:50:51 <MyCatVerbs> Chewie[]: I think ESR had a decent article on one place he used it.
11:50:59 <pitecus> I think Ill just send an email to haskell cafe, Im curious wtf is going on
11:51:03 <dolio> Chewie[]: Although they might go the other direction, too, I'm not certain.
11:51:14 <MyCatVerbs> Chewie[]: you can do funny metaprogramming tricks with it, and have them always done at runtime.
11:51:58 <Chewie[]> MyCatVerbs: true.
11:52:48 <chitin> does anyone here do project euler?
11:52:50 <Chewie[]> dolio: something like DML? http://en.wikipedia.org/wiki/Dependent_ML
11:53:31 <dolio> Chewie[]: That'd be one, I guess. I haven't looked at it. I was thinking Epigram.
11:53:37 <titusg> chitin: I did for a while, and got stuck/bored
11:53:46 <Chewie[]> yay, another language i've not heard of.
11:53:50 <chitin> titusg: have you done problem 47?
11:54:16 <Chewie[]> i dunno, i'm basically looking for C++ templates, but on more potent drugs.
11:54:16 <sjanssen> ooh, GHC 6.6.1 on SPOJ
11:55:18 <titusg> chitin: fraid not
11:55:29 <chitin> titusg: thanks anyway ;)
11:55:58 <dolio> Chewie[]: In epigram, you can have a type "List (n :: Natural) (a :: *)", where n is a variable of type Natural that specifies the size of the list, and a is a type variable, like you'd use in Haskell.
11:56:26 <titusg> chitin: how are you tackling that then?
11:56:43 <dolio> Chewie[]: You can mimic that in Haskell by encoding the natural numbers in the type system, but in epigram, natural numbers as runtime values and natural numbers used in the type system are one and the same.
11:56:59 <Chewie[]> dolio: ah, cool.
11:57:08 <chitin> titusg: bruteforce but that is obviously out of the question so I am trying to think of something clever
11:57:44 <chessguy_work> what about working backwards from prime factors
11:57:46 <Chewie[]> chitin: where's this problem 47?
11:57:58 <chitin> Chewie[]: http://projecteuler.net/index.php?section=view&id=47
11:58:00 <lambdabot> Title: Project Euler
11:58:06 <dolio> Chewie[]: I'm not sure if you can reverse that and work with types at runtime, though.
12:04:28 <jfredett> chitin, I've done 47, its the one about pentagonal triangle something or other numbers?
12:04:57 <chitin> jfredett: it's about consequtive numbers which have 4 distinct prime factors
12:05:09 <jfredett> oh, I must have it confused then
12:05:12 <jfredett> my bad
12:05:20 <chitin> no problem :)
12:05:53 <dcnstrct> hi,  earlier today I was asking for assistance with parsing a string "http://www.google.com:80".  into a tuple (host,port) so the type would be :: String -> (String,Int)  a gentleman named mauke suggested this lambda expression, and it works, but I need help understanding how it works, I'm very new to haskell, thanks people:
12:05:54 <dcnstrct> (\(x,_:y) -> (reverse y, reverse x)) . break (':' ==) . reverse $ "hxxp://google.com:80"
12:06:52 <dcnstrct> what does (\x,_:y) mean exactly ?
12:08:18 <LoganCapaldo> > break (':' ==) . reverse $ "http://google.com:80"
12:08:20 <lambdabot>  ("08",":moc.elgoog//:ptth")
12:08:21 <lambdabot> Title: Google
12:08:43 <Heffalump> (x,_:y) is a pattern that matches a tuple, and breaks up the second element of the tuple into a head and a tail, then throws away the head.
12:08:56 <LoganCapaldo> so the x matches "08" and y matches "moc.elgoog//:ptth"
12:08:57 <Heffalump> and the first element of the tuple gets named x, and the tail of the second element gets named y
12:11:33 <Apocalisp> > (\(x,_:y) -> (reverse y, reverse x)) . break (':' ==) . reverse $ "hxxp://google.com:80"
12:11:34 <lambdabot>  ("hxxp://google.com","80")
12:12:01 <Heffalump> (\(\x,_:y) -> show (x, y)) $ ("1234", "abcd")
12:12:03 <Heffalump> > (\(\x,_:y) -> show (x, y)) $ ("1234", "abcd")
12:12:03 <lambdabot>  Parse error
12:12:10 <Heffalump> > (\(x,_:y) -> show (x, y)) $ ("1234", "abcd")
12:12:11 <lambdabot>  "(\"1234\",\"bcd\")"
12:13:03 <Apocalisp> that's a bit clever innit
12:17:30 <LoganCapaldo> parseTest (sepBy (many (noneOf ":")) (char ':')) "http://www.google.com:80"
12:17:32 <lambdabot> Title: Google
12:17:56 <LoganCapaldo> Maybe importing parsec is overkill for this <g>
12:18:42 <monochrom> regex is less overkill
12:19:28 <monochrom> But perhaps you may rejoice at Network.URL
12:20:27 <chessguy_work> > (iterate (dropWhile (not . (== ':'))) "http://google.com")
12:20:35 <lambdabot>  ["http://google.com","://google.com","://google.com","://google.com","://goo...
12:20:45 <chessguy_work> > (iterate (dropWhile (not . (== ':'))) "http://google.com:80")
12:20:46 <lambdabot>  ["http://google.com:80","://google.com:80","://google.com:80","://google.com...
12:20:50 <LoganCapaldo> chessguy_work: the important bit was actually the port number
12:22:09 <chessguy_work> > (iterate (tail . dropWhile (not . (== ':'))) "http://google.com:80")
12:22:11 <lambdabot>  Exception: Prelude.tail: empty list
12:22:25 <chessguy_work> ok, i give up
12:24:15 <dcnstrct> thanks a ton people
12:29:18 * shapr kicks threading more
12:39:14 <roconnor> @hoogle parseURI
12:39:14 <lambdabot> Network.URI.parseURI :: String -> Maybe URI
12:39:15 <lambdabot> Network.URI.parseURIReference :: String -> Maybe URI
12:39:47 <roconnor> > Network.URI.parseURI "http://google.com:80/"
12:39:48 <lambdabot>   Not in scope: `Network.URI.parseURI'
12:39:49 <lambdabot> Title: Google
12:40:01 <roconnor> > Network.URI.parseURI "hxxp://google.com:80/"
12:40:02 <lambdabot>   Not in scope: `Network.URI.parseURI'
12:40:10 <shapr> Is there a standard way to shadow existing functions?
12:41:00 <roconnor> let clauses?
12:41:00 <Lemmih> shapr: Hide the function you want to shadow?
12:41:16 <roconnor> don't import it
12:41:29 <roconnor> hmm
12:41:58 <byorgey> @pl \f x -> (x, f x)
12:41:59 <lambdabot> ap (,)
12:42:21 <shapr> I was just wondering about transparent shadowing of forkIO
12:43:58 <ari> @type ap
12:44:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:45:21 <LoganCapaldo> @src (->) >>=
12:45:21 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:45:32 <LoganCapaldo> @src (->) (>>=)
12:45:33 <lambdabot> f >>= k = \ r -> k (f r) r
12:45:39 <sjanssen> shapr: that sounds really evil . . .
12:46:03 <LoganCapaldo> @src ap
12:46:03 <lambdabot> ap = liftM2 id
12:46:13 <shapr> sjanssen: Well yeah.. I was thinking evil thoughts.
12:47:15 <hpaste>  shapr pasted "instrumenting forkIO" at http://hpaste.org/30
12:47:52 <shapr> I know you can explicitly import the Prelude and replace bits, but can you do that with the base libs too?
12:48:30 <sjanssen> you can't replace bits of the Prelude
12:48:38 <sjanssen> you can just choose not to import them
12:48:54 <swiert> shapr: Have you had a look at IOSpec?
12:49:04 <swiert> It seems like the kind of thing you might be interested in.
12:49:23 <shapr> sjanssen: Can't you do that with --no-prelude ?
12:51:12 <LoganCapaldo> its -fno-implicit-prelude isn't it?
12:51:54 <shapr> oh right
12:52:47 <shapr> swiert: That's pretty impressive looking. Does it use unsafePerformIO under the hood?
12:52:59 <swiert> shapr: Nope.
12:53:07 <swiert> That's the cool part.
12:53:30 <shapr> Amazing, how?
12:53:35 * shapr grabs the dars repo
12:53:43 * ari realises that programming is complex :(
12:54:13 <shapr> ari: Yeah, but it's more fun than digging ditches.
12:54:26 <shapr> swiert: Is IOSpec in Hackage?
12:54:53 <swiert> shapr: Basically, we implement a pure version of the IO functions that behaves "the same" as the impure ones.
12:54:54 <shapr> Ah so it is!
12:54:58 <swiert> shapr: Yes.
12:55:03 <shapr> swiert: Wow, sounds like magic!
12:55:13 <swiert> shapr: Hardly...
12:55:54 <swiert> The source should be pretty clear.
12:56:45 <shapr> Oh, I see.
12:56:50 <shapr> Yeah, that is clear.
12:57:23 <shapr> I thought you'd solved a different problem.
12:57:28 <Heffalump> presumably "all" you have to do is implement a fake RealWorld
12:58:25 <shapr> This is a very cool paper1
12:58:26 <shapr> !
12:59:45 <shapr> swiert: Do you have any advice on how to connect a local pure model and a remote impure something via QuickCheck?
13:00:11 <swiert> shapr: What do you mean by local and remote?
13:00:14 <shapr> For example, how could I test Haskell against bc or dc (command-line calculators).
13:00:59 <swiert> shapr: Use unsafePerformIO?
13:01:13 <shapr> Any other solution?
13:01:28 <swiert> You might be able to write FFI bindings which aren't side-effecting...
13:01:42 <swiert> But that requires a bit more work.
13:01:44 <Heffalump> use unsafeIOtoST?
13:02:41 <shapr> hm
13:06:09 <dr_strangelove> how can I convert a ByteString into a String?
13:06:18 <sjanssen> dr_strangelove: unpack
13:06:32 <dr_strangelove> then I get a [Word8]
13:06:46 <sjanssen> Data.ByteString.Char8.unpack, then
13:07:05 <dr_strangelove> ah, thanks
13:07:15 <sjanssen> use .Char8 when you want to treat a ByteString as a sequence of Char
13:35:28 <pitecus> why is this ok: "instance FeatureSet IntSet" but this isnt: "FeatureSet (IntMap Double)"?
13:40:56 <chessguy_work> ?hoogle IntSet
13:40:56 <lambdabot> Data.IntSet :: module
13:40:56 <lambdabot> Data.IntSet.IntSet :: data IntSet
13:41:08 <chessguy_work> :k IntSet
13:41:10 <lambdabot> Not in scope: type constructor or class `IntSet'
13:41:56 <anders0> How can i test if one ByteString is contained within another?
13:42:10 <chessguy_work> anwyay, IntSet doesn't need any types. IntMap takes 2
13:42:14 <chessguy_work> err, no
13:42:18 <ski_> pitecus : in H98, the argument of a type class in an instance must be a type constructor applied to zero or more distinct type variables
13:42:49 <ski_> (s/instance/instance declaration/)
13:43:07 <pitecus> ski_, is there some extension which allows to use smth like what I pasted?
13:44:09 <ski_> pitecus : yes, in ghc i believe '-fglasgow-exts' allow what you want (possibly there is a narrower flag for this, i don't recall) .. (possibly '-98' in hugs also allow this)
13:44:27 <TomMD> anders0: isSubstringOf
13:44:32 <TomMD> :t isSubstringOf
13:44:34 <lambdabot> Not in scope: `isSubstringOf'
13:44:36 <pitecus> thanks ski_
13:44:49 <TomMD> Argh, stupid lambdabot interface.
13:45:07 <anders0> ohh.. its because im using lazy strings i cant find it :)
13:47:38 <anders0> Thanks TomMD.. my code works just fine with strict strings
13:50:57 <TomMD> @karma+ haskell
13:50:57 <lambdabot> haskell's karma raised to 25.
13:58:38 <_frederik_> sometimes GHC defaults numerical types to Integer, can i define similar defaults for other classes?
14:02:24 <sieni> _frederik_: Can't you just have functions of type (MyClass t) => t -> DefaultType or something?
14:02:36 <sieni> or like
14:02:59 <sieni> @type fromIntegral
14:03:00 <astrolabe> _frederik_: I don't think you can define defaults like that
14:03:01 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:03:03 <TomMD> _frederik_: unspecified numeric types should always default to "Int"  if they are 'defaulting' to "Integer" it would be because there is a use that implicitly binds the type to Integer.  I don't know of a good way to make a default, but sieni makes a good suggestion.
14:03:22 <_frederik_> i don't understand sieni's suggestion
14:03:41 <geezusfreeek> sieni: how would you define that?
14:03:58 <_frederik_> i want to for instance have my vectors (implementing Vector) default to the array-based implementation
14:04:10 <_frederik_> if the type is not otherwise specified
14:04:11 <TomMD> data Foo = Beer a | Bar b
14:04:11 <TomMD> defaultFoo a = Beer a
14:05:36 <_frederik_> that means for instance having  (vlen $ fromAssocs [(0,3),(4,5)])  return 2 rather than an ambiguous type variable error
14:05:53 <_frederik_> (where vlen is a member of Vector)
14:08:06 <Saizan> _frederik_: i think there's something like a default clause/pragma but i can't find it
14:08:21 <_frederik_> Saizan: hmm, thanks anyway
14:09:10 <Saizan> > let x = 1 in 2^40 `asTypeOf` x
14:09:12 <lambdabot>  1099511627776
14:09:25 <dmhouse> > 2^40
14:09:26 <lambdabot>  1099511627776
14:09:39 <Saizan> > 2^40 :: Int
14:09:40 <lambdabot>  0
14:09:56 <dmhouse> > let x = 1 :: Int in 2^40 `asTypeOf` x
14:09:57 <lambdabot>  1099511627776
14:09:59 <Saizan> just to demonstrate that numeric literals default to Integer
14:10:06 <edwardk> @type fromIntegral 1
14:10:06 <Saizan> oh..
14:10:08 <lambdabot> forall b. (Num b) => b
14:10:26 <dmhouse> > let x = (1 :: Int) in 2^40 `asTypeOf` x
14:10:27 <lambdabot>  1099511627776
14:10:39 <Saizan>  > let x = (1 :: Int) in (2^40) `asTypeOf` x
14:10:45 <Saizan> > let x = (1 :: Int) in (2^40) `asTypeOf` x
14:10:46 <lambdabot>  0
14:10:50 <dmhouse> Aha.
14:10:56 <Saizan> > let x = 1 in (2^40) `asTypeOf` x
14:10:57 <lambdabot>  1099511627776
14:11:10 <sieni> _frederik_: shouldn't then fromAssocs be of type (ArrayVector a, VectorizableType b) => b -> a
14:11:11 <_frederik_> hehe
14:11:29 <_frederik_> sieni: no, it is also a member of Vector, sorry I forgot to mention
14:11:29 <dmhouse> Hmm. I wonder how asTypeOf works with polymorphic types...
14:11:51 <dmhouse> > let x = [] in [] `asTypeOf` x
14:11:52 <lambdabot>  []
14:12:09 <dmhouse> Why, for example, didn't that show ""?
14:12:12 <norpan> dmhouse: asTypeOf is mainly useful when you have polymorphic types
14:12:22 <dmhouse> norpan: no, I meant polymorphic types in the second parameter.
14:12:30 <Saizan> dmhouse: it's just const with a different type
14:12:52 <dmhouse> Or even:
14:12:57 <edwardk> just forces unification no?
14:13:01 <dmhouse> No, actually, never mind.
14:13:15 <norpan> forces the first argument to be the type of the second
14:13:17 <dmhouse> > []
14:13:18 <lambdabot>  []
14:13:22 <norpan> because it has type a -> a -> a
14:13:25 <edwardk> yeah
14:13:43 <dmhouse> Actually, why does that show [] instead of ""?
14:14:13 <norpan> because lists don't default to be [Char]
14:14:14 <dmhouse> I don't think this is a case of incoherant/overlapping instances, I seem to remember there's a showList method of the Show typeclass that somehow handles this.
14:14:44 <quicksilver> am I allowed to do higher rank, quantified by typeclass?
14:15:02 <dmhouse> norpan: no, but [] :: String would print as "". Why should [] default to a type [a], a /= Char?
14:15:11 <quicksilver> (forall m . (Monad m) => m a) -> ...
14:15:12 <dmhouse> quicksilver: higher rank what?
14:15:17 <edwardk> > [] :: String
14:15:17 <dmhouse> quicksilver: yes.
14:15:18 <lambdabot>  ""
14:15:23 <quicksilver> dmhouse: nifty
14:15:41 <norpan> dmhouse: because there is a generic Show instance for [a]
14:15:44 <dmhouse> quicksilver: otherwise higher-rank types are pretty useless...
14:15:50 <mauke> dmhouse: http://haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html#extended-default-rules
14:15:51 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/ys6jcw
14:16:01 <edwardk> i thought there was some sort of hack for instance Show String isnt there?
14:16:01 <Saizan> yeah, you could use them only like runST
14:16:03 <dmhouse> norpan: but then doesn't that overlap with the Show instance for String?
14:16:16 <mauke> there is no Show instance for String
14:16:31 <edwardk> er in the [a] instance then
14:18:06 <edwardk> ahh its the showList method on instance Show Char
14:18:10 <edwardk> thats what it is =)
14:18:12 <dmhouse> Ah, so according to that GHC docs link, GHCi does defaulting on instances of Show, Eq and Ord as well as Nnum.
14:18:51 <dmhouse> edwardk: yeah, that's what I thought, but doesn't that still require overlapping instances?
14:18:55 <dmhouse> Ah, no it wouldn't!
14:19:11 <quicksilver> nominolo: you've got mail
14:19:17 <quicksilver> nominolo: (I'm afraid it's long)
14:19:27 <norpan> :type []
14:19:32 <norpan> @type []
14:19:34 <lambdabot> forall a. [a]
14:19:41 <Saizan> you only have Show a => Show [a] where show xs = showList xs ""
14:20:16 <norpan> i wonder which type [] defaults to for it to be showable
14:20:22 <dmhouse> class Show a where showList :: [a] -> String; instance Show Char where showList = ...; instance Show a => Show [a] where show = showList
14:20:30 <edwardk> Show a => Show [a], and instance Show Char overrides the default showList
14:20:33 <dmhouse> (Up to funniness involving ShowS.)
14:20:41 <quicksilver> dmhouse: MonadTrans t => (forall m . (Monad m) => a -> t m ()) -> t IO ()
14:20:48 <quicksilver> dmhouse: nice type for a general callback, I think
14:21:00 <quicksilver> dmhouse: unless there is a thinko in my conception
14:21:15 <dmhouse> Sounds like a nice trick for escaping overlapping instances, actually.
14:21:19 <edwardk> yeah
14:21:25 <edwardk> i was just thinking that =)
14:21:26 <dmhouse> (FSVO of 'nice', showList is a bit of a hack.)
14:21:36 <edwardk> though only a finite number of preknown cases
14:21:37 <norpan> > show []
14:21:38 <lambdabot>  "[]"
14:21:42 <Saizan> i prefer overlapping :)
14:22:01 <norpan> > show ([] :: [(a -> a)])
14:22:02 <lambdabot>  Add a type signature
14:22:12 <chessguy_work> ?vera FSVO
14:22:16 <lambdabot> No match for "FSVO".
14:22:19 <norpan> > show ([] :: [(Int -> Int)])
14:22:19 <dmhouse> 'For some value of'
14:22:20 <lambdabot>  "[]"
14:22:27 <chessguy_work> aha
14:23:39 <dmhouse> quicksilver: did you not mean MonadTrans t => (forall m. Monad m => a -> t m ()) -> a -> t IO ()?
14:23:49 <dmhouse> Otherwise where do you conjure up the 'a' from?
14:24:56 <dmhouse> With the addition I'd read that as "Given a function from 'a's to a monad transformer value with arbitrary underlying monad, we can specialise that function to always return monad transformer values with IO as the underlying monad."
14:25:16 <Saizan> i also wonder how do you go from (forall m. Monad m => t m ()) to t IO ()
14:25:46 <Saizan> just ignore my last sentence :)
14:27:35 <emu> any debian/haskell people here
14:27:52 <chessguy_work> we don't allow hybrids around here
14:28:06 <dmhouse> emu: dcoutts is the main person to ping, I think.
14:28:33 <anders0> I'm using haskell on Ubuntu.. but im a complete noob
14:29:13 * _frederik_ things "noobuntu"
14:29:18 <_frederik_> er thinks
14:29:27 <anders0> :)
14:29:29 <Saizan> i'm on sid but i use HEAD..
14:29:51 <_frederik_> i can never remember the debian release names
14:30:18 <Saizan> sid is always the unstable branch
14:30:18 <sieni> sid is always unstable :-)
14:30:27 <_frederik_> oh that helps :)
14:32:17 <monochrom> I use ubuntu. I am aware of debian.
14:33:00 <monochrom> I build ghc myself. But I know how to skip building it.
14:33:08 <geezusfreeek> OS X! *ducks*
14:34:07 <quicksilver> dmhouse: well there are probably missing parameters, in practice
14:34:19 <nominolo> quicksilver: no, it's good.  something we can work with.  much better than a irc transcript.  thanks for taking the time
14:34:24 <quicksilver> dmhouse: but in my example, the 'a's are provided by the IO framework you end up sitting in
14:34:33 <monochrom> If you are on ubuntu, I recommend the generic binary tar.bz2 on GHC home. Then you just need readline4 (available from ubuntu universe).
14:34:34 <quicksilver> dmhouse: it was a callback for a progressive HTTP get
14:34:38 <quicksilver> nominolo: cool thanks :)
14:34:49 <quicksilver> nominolo: took me quite a while to get those thoughts in orde r:)
14:34:56 <dmhouse> quicksilver: so the type you gave is more general than the actual type you'er using? Because the type you wrote doesn't make conceptual sense.
14:34:58 <quicksilver> nominolo: I hope Oleg has something to add, too
14:35:37 <quicksilver> dmhouse: it says (I hope) give me a callback, which is expecting 'a's and works as a transformer over a generic monad
14:35:48 <quicksilver> dmhouse: I'll run your callback, possibly multiple times
14:35:53 <quicksilver> dmhouse: transformed over IO
14:36:03 <quicksilver> dmhouse: and return the composite action that results
14:36:52 <quicksilver> dmhouse: the point of the higher rank is 'this callback is a monad which can be transformed over IO, but actually I promise it can be transformed over any monad, so you can prove that I don't actually do any IO in the callback'
14:37:01 <quicksilver> dmhouse: the most obvious use case is t = StateT
14:37:05 <nominolo> quicksilver: yes.  btw, i put oleg's enumerator paper on reddit and i got one very interesting comment
14:37:13 <dmhouse> quicksilver: what parameters do you feed it? You allow the function to take parameters of _any_ type, so where do you conjure these values up from?
14:37:22 <quicksilver> dmhouse: oh, sorry
14:37:25 <dmhouse> quicksilver: 'it' being the callback.
14:37:25 <nominolo> quicksilver: http://programming.reddit.com/info/1t1s3/comments/c1tasj
14:37:27 <lambdabot> Title: What&#39;s wrong with iterators, cursors or generators--and how to fix it? (redd ...
14:37:28 <quicksilver> dmhouse: that 'a' isn't supposed to be foralled
14:37:36 <quicksilver> dmhouse: that was some fixed a
14:37:42 <quicksilver> dmhouse: consider it to be ByteString
14:37:58 <dmhouse> quicksilver: right, so the type you wrote is more general than the type you meant, just like I asked you a minute ago?
14:37:59 <dmhouse> :)
14:38:12 <quicksilver> dmhouse: yes
14:38:17 <dmhouse> Makes sense.
14:38:23 <quicksilver> dmhouse: well you read an implicity forall on the 'a' that I didin't intend :)
14:38:25 <quicksilver> dmhouse: but yes
14:38:44 <dmhouse> quicksilver: well, Haskell would also read that implicit forall had you written that exact type ;)
14:44:32 <quicksilver> dmhouse: quite :(
14:44:45 <quicksilver> nominolo: looking at that now
14:47:44 <_frederik_> nominolo: the author of that comment criticises Haskell for being hard to read, that is interesting. i think it is true, but since the type system is so strong it doesn't really need to be as legible as other languages; whereas with Perl the 'write-only language' criticism is quite real i feel that it doesn't apply so much to Haskell
14:48:16 <nominolo> uh, did i quote the wrong comment?
14:48:41 <_frederik_> i'm looking at one by etcshadow
14:49:01 <nominolo> ah, in the last paragraph
14:49:07 <_frederik_> "I'm sad to admit that I was completely unable to understand the perported implementation of a general fold-to-iterator in Haskel(sic)"
14:49:40 <nominolo> well, i quoted that comment for its critique of the enumerator approach
14:49:41 <quicksilver> nominolo: interesting
14:49:50 <quicksilver> nominolo: quite a knowledgeable (sounding) comment
14:49:52 <nominolo> or, callback-based interfaces in general
14:50:09 <_frederik_> yeah i didn't really understand what he said about enumerators
14:50:15 <quicksilver> In haskell, a callback doesn't actually feel like ceding flow control
14:50:24 <quicksilver> because even our 'forM' primitive is actually a callback :)
14:50:32 <quicksilver> but we write it as it were a language construct
14:50:36 * quicksilver smiles
14:50:39 <_frederik_> yeah
14:50:55 <quicksilver> nominolo: the point about dual iteration is good
14:51:02 <quicksilver> nominolo: although less applicable to your actual point, perhaps
14:51:04 <nominolo> quicksilver: i think the point is, what i also thought about, if you specify your iterator as a leftfold you get the iterator for free if you're in a language with continuations
14:51:12 <_frederik_> there are so many ways of looking at the same thing
14:51:14 <quicksilver> nominolo: agreed
14:51:18 <_frederik_> in the end, you can use IORefs in Haskell
14:51:22 <nominolo> quicksilver: yeah, the problem is, we're in IO
14:51:41 <_frederik_> if you need them. i don't feel it's a point of concern
14:51:48 <quicksilver> nominolo: note that one of my solutions pulls the callback out of IO, if you prefer
14:51:59 <quicksilver> nominolo: although in many cases I anticipate that a callback in IO is what you want
14:52:13 <nominolo> quicksilver: you mean the monad transformer?
14:52:15 <ddarius> I'm pretty sure IO supports continuations.
14:52:16 <quicksilver> nominolo: yes
14:52:26 <_frederik_> ddarius: does it?
14:52:27 <nominolo> ddarius: sure
14:52:43 <quicksilver> nominolo: the monad transformer might be 'StateT' and then your callback is pure
14:52:47 <nominolo> ContT IO
14:52:56 <ddarius> _frederik_: I believe call/cc is implementable in terms of primitives available in IO.
14:53:11 <_frederik_> nominolo: ContT IO?
14:53:18 <ddarius> No, no monad transformer.
14:53:20 <quicksilver> call/cc is implementable with mfix, isn't it?
14:53:32 <nominolo> uh
14:53:34 <_frederik_> ddarius: i don't see an instance in the standard library. i think it is non-trivial
14:53:37 <nominolo> never looked into that
14:53:52 <quicksilver> mfix lets you tie arbitrary knots into your IO
14:53:55 <ddarius> _frederik_: No, it's not defined.  And it's not "trivial" but it should be possible.
14:53:57 <quicksilver> isn't that the essence of call/cc?
14:54:03 <ddarius> You'd do it via threads.
14:54:11 <_frederik_> oleg may have written a canonically good one for his paper i don't remember the name of
14:54:24 <_frederik_> but i think he used O'Caml for the main implementation
14:55:03 <_frederik_> http://okmij.org/ftp/Computation/dynamic-binding.html
14:55:04 <lambdabot> Title: Dynamic Binding
14:55:11 <nominolo> quicksilver: so, anyways, i think all your use cases are valid.  i think we can find a common primitive for them though.  also, i wouldn't mind implenting more than one interface if it's straightforward
14:55:29 <quicksilver> nominolo: agreed on both counts
14:55:32 <_frederik_> (that is a good paper, by the way)
14:57:14 <dmhouse> Someone remind me: how does one restrict a grep search to a certain subset of files again?
14:57:32 <ski_> hm .. possibly one could do 'callCC' via http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters
14:57:32 <nominolo> quicksilver: i still think though, that having the stream interface would be a good idea.  so, if we can find a way to get that on top of the chunk interface that'd be great
14:57:33 <lambdabot> Title: FunWithLinearImplicitParameters - TmrWiki
14:57:57 <_frederik_> dmhouse: grep expr files ? e.g. grep 'Foo' *.hs
14:58:14 <dmhouse> _frederik_: oh, right, globbing, of course. :)
14:58:22 <_frederik_> dmhouse: or 'find . -name \*.hs | xargs grep Foo'
14:58:37 <_frederik_> dmhouse: or 'find . -name \*.hs | while read i; do grep Foo $i; done'
14:58:46 <nominolo> man, guys, so much to read.  and i have a lab deadline in 24h
14:58:59 <_frederik_> what is a lab deadline?
14:59:11 <nominolo> you know homework
14:59:21 <monochrom> > let xs = mfix (\s -> do { x <- "abc"; return (x:s) }) in map (take 10) xs
14:59:22 <nominolo> with a due date
14:59:23 <lambdabot>  ["aaaaaaaaaa","bbbbbbbbbb","cccccccccc"]
14:59:54 <_frederik_> nominolo: oh, that
15:00:00 <nominolo> in CS you don't actually do your assignments in the lab, though ;)
15:00:31 <monochrom> you do assignments at home?
15:00:37 <opqdonut> how can you have assignments on functional programming?-)
15:00:42 <opqdonut> badabum-tshhh
15:00:49 <nominolo> it's hardware description
15:00:50 <monochrom> @slap opqdonut
15:00:50 * lambdabot slaps opqdonut
15:00:55 <nominolo> in haskell
15:01:29 <ski_> http://www.cs.chalmers.se/Cs/Research/Functional/Pictures/logo.gif
15:01:31 <lambdabot> http://tinyurl.com/ywyygf
15:01:58 <quicksilver> nominolo: as you pointed out, the stream interface is possible, it's just got to be a little more abstract than [a] is
15:02:26 <_frederik_> nominolo: do you have to comment your code? ;)
15:02:31 <monochrom> Hahaha great logo
15:02:48 <nominolo> _frederik_: yes, not extensively though
15:02:52 <monochrom> Is that a thunk in the blue sign? :)
15:02:56 <quicksilver> ddarius: I have changed my mind. You can't do continuations in IO.
15:03:20 <ski_> (monochrom : i assume it is something about lambda binders)
15:03:46 <ski_> quicksilver : you mean you have functionally updated your mind, itym ?
15:04:05 <_frederik_> heh
15:04:12 <quicksilver> ski_: I've executed a new continuation with a different 'mind' parameter
15:04:34 <_frederik_> let's just pretend you were joking the first time
15:05:39 <quicksilver> having a first-class call/cc in IO would be equivalent to time-travel
15:05:49 <quicksilver> it would imply you could 'reconstruct' earlier states at a later time
15:06:09 <ski_> what does 'state' mean here ?
15:06:32 <ddarius> quicksilver: You can't get a full call/cc without implementing thread duplication somehow.
15:06:33 <quicksilver> ski_: real world state
15:06:36 <ski_> just control context, or also assign state ?
15:06:51 <quicksilver> ski_: everything, from the amount of ink in your printer to which keys are depressed
15:06:55 <quicksilver> ski_: at least theoretically
15:07:11 <_frederik_> quicksilver: that is not what people usually mean by continuations
15:07:15 <quicksilver> ddarius: yes, so how 'faithful' it was would depend on how much of 'RealWorld' you felt you could duplicate
15:07:18 <ski_> (in scheme 'call-with-current-continuation' only captures control context)
15:07:21 <_frederik_> quicksilver: you are confusing it with purity i think
15:07:33 <_frederik_> read oleg's paper
15:07:39 <quicksilver> _frederik_: but call/cc is normally considered in an imperative language
15:07:41 <_frederik_> (if you have time)
15:07:47 <quicksilver> like scheme
15:07:58 <ddarius> quicksilver: call/cc only plays with the control context
15:08:05 <ddarius> @google "Threads Yield Continuations"
15:08:07 <quicksilver> hmm
15:08:08 <lambdabot> http://www.ingentaconnect.com/content/klu/lisp/1998/00000010/00000003/00161784
15:08:08 <lambdabot> Title: IngentaConnect Threads Yield Continuations
15:08:14 <monochrom> Hmm, so what does Scheme do? Or is it just ContT IO ?
15:08:23 <_frederik_> quicksilver: if there were no side-effects, then it would be the same as a pure function, no?
15:08:27 <quicksilver> well I'm not excluding the possibility that I'm wrong :)
15:08:32 <ski_> apropos, /me 's trying to work with CPSified types atm :)
15:08:47 <_frederik_> CPSified types?
15:08:51 <quicksilver> but I think 'real continuations in IO' ought to mean something different from just ContT IO
15:08:59 <ski_> monochrom : roughly 'ContT IO', yes
15:09:15 <ddarius> @google "Threads Yield Continuations" filetype:pdf
15:09:17 <lambdabot> http://www.cs.indiana.edu/~dyb/pubs/LaSC-10-3-pp223-236.pdf
15:09:23 <quicksilver> if you have ContT State s, for example
15:09:28 <ski_> _frederik_ : yes, the type constructor takes a continuation type parameter
15:09:35 <quicksilver> then the 'CC' preserves the current state, doesn't it?
15:09:44 <quicksilver> I mean, state at the point you save it with callcc
15:11:30 <ddarius> Hmm... session types.
15:11:31 <ski_> B . L . T0 . B . B . L . T0 . L . T1 . T0 . L . T1 . T1 . I $ (0,((1,2),3)) :: Tree Int  -- is an example of a value in my type
15:11:31 <_frederik_> ski_: what is this for?
15:11:34 <ski_> impure fun !
15:11:51 <monochrom> That is powerful.
15:12:31 <quicksilver> ddarius: will read the paper, thanks
15:12:42 <Saizan> err, what does that line mean?
15:12:44 <ski_> (the 'T0' and 'T1' are just newtype constructors, so can be mostly ignored)
15:12:48 <monochrom> I'm going to cook up a quick example of ContT State to see what happens.
15:13:38 <ddarius> There are various ways of lifting State through Cont.
15:13:38 <_frederik_> ski_: like a normal continuation, or some sort of type-level continuation?
15:13:38 <ski_> Saizan : 'B' is 'Branch' and 'L' is 'Leaf'
15:13:50 <ski_> Saizan : i've separated the tag information from the actual contents of the leafs
15:14:09 <_frederik_> oic
15:14:11 <ddarius> @google "Typed Quote/AntiQuote"
15:14:13 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
15:14:16 <Saizan> ooh
15:14:23 <ddarius> ski_: You may want to look at that.
15:14:28 <Saizan> so it's the data contructor that take a continuation, right?
15:14:35 <ski_> ddarius : danke
15:15:23 <ddarius> ski_: Only to make your craziness slightly more legible.  You also may get some ideas though.
15:15:26 <quicksilver> ddarius: I'd argue that the 'desired' semantics for callCC \exit -> do { putStrLn "hello" ; exit } is that the 'hello' should be undone...
15:15:45 <ddarius> quicksilver: Damn straight!
15:15:54 <quicksilver> ddarius: although I understand that 'flow-control-only' continuations do indeed have a meaning, too
15:16:08 * ski_ currently is trying to figure out how to traverse his trees .. he can currently convert from normal trees to this kind, but not the other way around
15:17:17 <hpaste>  LoganCapaldo pasted "This doesn't do what I expect (StateT Int []) What don't I get?" at http://hpaste.org/31
15:18:49 <LoganCapaldo> Oh yeah one thing, I know how to say foldr (+) 0 I'm just trying out this monad transformer stuff :)
15:20:06 <ski_> ddarius : hm, that seems possibly related to a paper for writing "forth" in haskell i've seen ..
15:21:06 <ddarius> LoganCapaldo: StateT Int [] is not a monad.
15:21:22 <LoganCapaldo> ddarius: oh
15:21:23 <ddarius> Er never mind
15:21:24 <LoganCapaldo> um
15:21:24 <ski_> ddarius : .. and maybe not so related to what i'm doing .. (otoh, possibly i need a parsing metaphor to be able to traverse the tree, so maybe it is somewhat related after all, .. hmm)
15:21:32 * LoganCapaldo is confused
15:21:39 * ddarius is misremembering.
15:21:43 <ddarius> I think.
15:21:58 <ski_> @kind StateT Int []
15:22:00 <lambdabot> * -> *
15:22:05 <ddarius> ski_: I didn't say it was related I said it would make your craziness more legible.
15:22:18 <ddarius> I believe I'm thinking of ListT
15:23:25 <ddarius> LoganCapaldo: What does it do?
15:23:27 <LoganCapaldo> the goal of my excerise was to make the state be the sum of all the elements in the list
15:24:27 * ski_ shudders to think of what types the constructors should have, to be able to use left-associative application of the "sequence" ..
15:24:36 <LoganCapaldo> instead I get back [(1,1),(2,2),(3,3)]
15:24:54 <LoganCapaldo> and I think I'm missing something fundamental
15:25:05 <ddarius> @src StateT
15:25:05 <lambdabot> Source not found. Where did you learn to type?
15:25:13 * araujo wonders if anyone would be interested to trade a book by TaPL
15:25:28 <dolio> ddarius: You're thinking of 'ListT m' only being a monad if m is a commutative monad, no?
15:25:30 <edwardk> heya ski
15:25:37 <ddarius> dolio: Yes.
15:25:38 <LoganCapaldo> At least it type checks I suppose
15:25:47 <ski_> hiya edwardk
15:25:57 <ddarius> StateT s m a = s -> m (a,s) if I remember correctly.
15:26:03 <edwardk> did you see the stuff from the other day about HTT and monad coproducts?
15:26:32 <ddarius> monad pushouts all the way!
15:26:35 <fuzan> lt runStateT
15:26:38 <fuzan> :t  runStateT
15:26:40 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:27:19 <LoganCapaldo> Maybe I should just wait for the book :)
15:27:34 <fuzan> LoganCapaldo: they're pretty simple :)
15:28:08 <ddarius> LoganCapaldo: In general, combining state and non-determinism is not very fun.
15:28:28 <ddarius> (If you think -laziness- and state is bad ... !)
15:28:37 <LoganCapaldo> Oh yeah I suppose
15:28:42 <LoganCapaldo> that was probably a lousy choice
15:29:07 <ddarius> Oh it can be useful, but there are various levels that the operations operate at.
15:29:18 * jfredett hides from state + nondeterminism
15:29:23 <jfredett> scary...
15:29:23 <quicksilver> > runWriter $ runContT (callCC (\exit -> do { lift $ tell "hello" ; exit ()})) return
15:29:25 <lambdabot>  ((),"hello")
15:29:45 <quicksilver> ddarius: ContT Writer disobeys my suggestion too
15:29:54 <quicksilver> ddarius: so ContT is 'broken' in this sense :)
15:30:02 <quicksilver> ddarius: it doesn't unroll effects, does it?
15:30:40 <ddarius> quicksilver: Continuations never unroll effects unless you explicitly arrange for them to.  It would be really nice if you could unroll IO effects.
15:31:00 * quicksilver nods
15:31:12 <quicksilver> ddarius: basically, that's not something ContT can do, in geenrally
15:31:23 <quicksilver> ddarius: although you might imagine a typeclass UnrollableMonad
15:31:40 <ddarius> quicksilver: Unrolling IO effects is something nothing can do.
15:31:40 <quicksilver> ddarius: and a more clever version of ContT for unrollables
15:31:44 <quicksilver> ddarius: quite :)
15:31:54 <quicksilver> ddarius: but State and Writer, we can manage :)
15:32:22 <ddarius> As I said there are multiple ways of lifting State through Cont.
15:32:32 * quicksilver nods
15:32:34 <ddarius> And then even more ways of putatively combining them.
15:32:41 <quicksilver> I now understand what you meant :)
15:32:46 <quicksilver> or at least, I understand more about it
15:33:02 <ddarius> @google Modular Monadic Interpreters
15:33:08 <lambdabot> http://library.readscheme.org/servlets/cite.ss?pattern=Ganz-00
15:33:08 <lambdabot> Title: Citation: A Modular Monadic Interpreter In Scheme With Objects
15:33:55 <ddarius> @google Monad Transformers and Modular Interpreters
15:33:57 <lambdabot> http://www.cse.ogi.edu/~mpj/pubs/modinterp.html
15:33:57 <lambdabot> Title: Redirect: Web resource has moved
15:34:13 <ddarius> That has two different liftings of State through Cont and some discussion of it.
15:34:48 <dolio> > runCont (runWriterT (callCC (\exit -> do { tell "hello" ; exit ()}))) id
15:34:49 <lambdabot>  ((),"")
15:34:57 <jfredett> does anyone know how to get Djinn running? I'm having some issues w/ compiling it
15:34:58 <jfredett> proof driven programming == Math major's dream.
15:35:03 <quicksilver> ddarius: the original version of ContT has some examples in the haddock
15:35:18 <quicksilver> ddarius: which say "Jumping to a continuation does not affect the output.
15:35:20 <quicksilver> etc
15:35:29 <quicksilver> dolio: oh that's interesting
15:35:42 <quicksilver> layer the other way around and it's different?
15:35:51 <dolio> :) Yeah.
15:36:04 <quicksilver> so this is related to the fact that there's no such thing as IOT
15:36:09 <ddarius> jfredett: "proof driven programming"  Proving -is- programming.
15:36:30 <quicksilver> we can get smart continuations for precisely those monads which we can writes as transformers?
15:36:31 <opqdonut> not per se
15:36:31 <ddarius> Well formal proofs
15:36:50 <opqdonut> ddarius: nah, only constructive proofs i'd saay
15:37:06 <quicksilver> are there some general statements you can write about what kind of monads can be written as transformers?
15:37:24 <opqdonut> and some things like the axiom of choice frequently used in proofs can be algorithmically horrible
15:37:27 <ddarius> quicksilver: Not comprehensive ones as far as I know.
15:37:41 <ddarius> opqdonut: And tend to have little to do with programming.
15:37:42 <quicksilver> ddarius: it seems that they tend to be well-behaved in this sense
15:38:08 <opqdonut> ddarius: yep
15:38:10 <ddarius> Monad transformers are not particularly pretty
15:40:54 <monochrom> Bird's "algebra of programming" is prove-driven programming.
15:43:16 <opqdonut> so is prolog, in a way
15:43:27 <opqdonut> mmmh prolog
15:45:50 <ArthurClemens> out of interest, could someone explain me how @tell works for lambdabot?
15:45:59 <ArthurClemens> I saw it used yesterday
15:49:31 <monochrom> @tell ArthurClemens this is a message for you
15:49:31 <lambdabot> Consider it noted.
15:49:43 <LoganCapaldo> ArthurClemens: now say something
15:49:45 <monochrom> Now say something, or /me something
15:50:11 <ArthurClemens> ok
15:50:11 <lambdabot> ArthurClemens: You have 1 new message. '/msg lambdabot @messages' to read it.
15:51:04 <ArthurClemens> thanks
15:51:51 <hpaste>  LoganCapaldo annotated "This doesn't do what I expect (StateT Int []) What don't I get?" with "this works, no monad transformers though :(" at http://hpaste.org/31#a1
15:58:11 <monochrom> LoganCapaldo: StateT Int [] works, but perhaps you mis-expect what it means?  It expands to s -> [(a,s)], so you get three state threads, not one?
15:58:26 <LoganCapaldo> monochrom: yeah
15:58:31 <LoganCapaldo> which wasn't what I wanted
15:58:40 <LoganCapaldo> So yes I misexpected it
15:58:46 <monochrom> Have you tried ListT (State Int)?
15:58:46 <jfredett> ddarius, yes, but what I meant is programming with the proof first, then the program
15:58:57 <jfredett> rather than program yielding proof.
15:59:05 <ddarius> jfredett: But the proof can be the program.
15:59:22 <jfredett> exactly, and thats why I want to get Djinn working
15:59:23 <jfredett> :P
15:59:49 <ddarius> jfredett: Djinn is a theorem prover.
16:00:00 <jfredett> that can extract haskell code
16:00:05 <jfredett> or so it appears
16:00:26 <ddarius> jfredett: No, it's basically just a theorem prover that uses a subset of Haskell as the proof language.
16:01:04 <jfredett> I've used Coq's extraction powers a little bit before
16:01:04 <jfredett> ddarius, oh, I see.
16:01:04 <jfredett> it still looks cool. :/
16:01:27 <ihope> Hmph. I'm having an urge to write a program in Haskell, but I have... little idea what to write.
16:01:47 <jfredett> ihope, welcome to my world
16:01:49 <ddarius> ihope: Start writing a webbrowser.
16:02:07 <ihope> Plus the most productive thing I could be doing is seeking out an x86 guy.
16:02:16 * jfredett i working on a lambda calc interpreter
16:02:28 <ihope> Sort of ironic, since Haskell and x86 are sort of opposites.
16:02:30 <jfredett> s/i/is
16:02:52 <ihope> I guess seeking out an x86 guy isn't the same as learning x86, though.
16:02:54 <ddarius> ihope: I'm working on something in x86 assembly "right now"
16:03:58 <ihope> ddarius: "right now" meaning somewhat right now?
16:04:39 <ddarius> Meaning I've had a vim buffer open on it for a week or two now with no changes...
16:04:53 <ihope> "Writing x86 Kernels for Dummies" would be really nice.
16:05:01 <ihope> What are you doing in x86, then?
16:05:17 <ddarius> Implementing a language.
16:05:20 <jfredett> assembly, mm, tasty bits and bytes there, ayup
16:05:36 <ddarius> @google TALx86
16:05:38 <lambdabot> http://www.cs.cornell.edu/talc/releases.html
16:05:38 <lambdabot> Title: Talc Releases
16:06:58 <ihope> Wouldn't it be much more productive to help me with my kernel? ;-)
16:07:08 <jfredett> lol
16:07:15 <LoganCapaldo> monochrom: I blame you
16:08:07 <monochrom> Haha
16:08:17 <hpaste>  LoganCapaldo pasted "GHC bug apparently" at http://hpaste.org/33
16:09:14 <LoganCapaldo> Is this fixed in *bleeding edge version*?
16:12:45 <monochrom> Reproducible on i386 linux
16:13:46 <dibblego> do we put a pattern match that is more likely to succeed first for performance reasons?
16:14:00 <monochrom> Yes.
16:14:16 <dibblego> cheers
16:15:11 <augustss> It's usually not necessary to put it first.
16:15:32 <dibblego> what's that mean?
16:15:48 <augustss> Only if you use guards, or some very tricky matching.
16:16:08 <dibblego> I'm still not following
16:16:26 <augustss> Don't worry about reordering patterns.
16:16:51 <hpaste>  fuzan annotated "GHC bug apparently" with "(no title)" at http://hpaste.org/33#a1
16:17:29 <LoganCapaldo> fuzan: well thanks heh
16:18:32 <ndm> dibblego: read the Core, you'll find that pattern matching isn't as obvious as you might have thought
16:18:53 <ndm> dibblego: usually all patterns are checked in parallel, unless they are particularly complex
16:19:07 <dibblego> ok cheers
16:19:39 <fuzan>   LoganCapaldo: i just recently adventured into monad transformers as well :)
16:21:44 <hpaste>  monochrom annotated "This doesn't do what I expect (StateT Int []) What don't I get?" with "(no title)" at http://hpaste.org/31#a2
16:24:28 <LoganCapaldo> monochrom: AHA
16:25:07 * _frederik_ wants the type system to catch his off-by-one errors
16:27:26 <chessguy> _frederik_: that's what QC is for
16:28:12 <_frederik_> QC?
16:28:18 <ndm> _frederik_: quickcheck
16:28:23 <dibblego> ?where QuickCheck
16:28:23 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
16:28:28 <chessguy> quantum combinatorics
16:28:33 <chessguy> just kidding
16:28:58 <_frederik_> i want the type system to do it
16:29:19 <DRMacIver> _frederik_: If you don't use numbers for indexing, the type system will catch all your off by one errors vacuously. ;)
16:30:10 <_frederik_> DRMacIver: that suggestion was very vacuous
16:30:23 <DRMacIver> But also valid.
16:30:43 <_frederik_> not in my case
16:30:45 <jbauman> dependent types?
16:30:46 <slava> does haskell allow circular dependencies between modules?
16:30:59 <DRMacIver> I don't think so, no.
16:31:09 <slava> ok
16:31:18 <ndm> slava: theory yes, practice no
16:31:51 <slava> i'm cleaning up circularity in my module system and wondering how a certain problem would be solved in haskell
16:32:19 <slava> i have this long chain of dependencies.  catch -> some sequence functions -> throw
16:32:28 <ndm> catch?
16:32:33 <ndm> eek, thats not a good thing to use
16:32:37 <slava> 'throw' is primitive, but 'catch' uses various libraries, these libraries sometimes throw exceptions with 'throw'
16:32:49 <ndm> what are you using exceptions for?
16:32:52 <slava> so, conceptually, i want throw/catch in the same module
16:32:53 <DRMacIver> ndm: Presumably he's talking about factor rather than Haskell.
16:33:05 <slava> but implementation-wise, i can't, unless the errors module has a circular dependency with sequences
16:33:07 <ndm> DRMacIver: oh, fair enough
16:33:10 <slava> in haskell, how would the corresponding code be designed?
16:33:20 <ndm> slava: without throw/catch
16:33:27 <slava> the specifics are irrelevant
16:33:33 <slava> you can substitute throw/catch with any other pair
16:33:39 <slava> which conceptually belong together
16:34:49 <dibblego> slava, I had to hack GHC to do that once (circular dependencies)
16:35:09 <slava> the thing is, circular dependencies are easy to do in my system, but i want to avoid them entirely
16:36:25 <ddarius> Mutually recursive modules are (barely) supported.
16:36:38 <ndm> they aren't
16:36:50 <ndm> unless you consider writing your own header files "supported"
16:37:29 <ddarius> I mean barely supported in so far as it is not a show-stopper, but it is a pain in the ass.
16:37:48 <_frederik_> jbauman: i have been reading the Coq manual, obviously dependent types are powerful; and probably even necessary for detecting such errors, but i don't know if that is really all Haskell would need...
16:38:13 <_frederik_> jbauman: i was not entirely serious
16:38:59 <_frederik_> jbauman: although i am willing to be proven wrong, if someone wants to write a library that i can use to get rid of off-by-1 errors
16:41:28 <ndm> _frederik_: what are your off by-1 errors in?
16:42:45 <ndm> _frederik_: if you use induction, usually there is no structure/number mapping, and therefore no numeric/structure mismatch
16:49:24 <_frederik_> ndm: hmm
16:50:31 <_frederik_> ndm: the details are not very interesting, in one place i store n and in another place i store n-1. i could give them different types, but that would cause a proliferation of types i think
16:50:45 <_frederik_> it has been fixed, anyway
16:50:50 <ndm> _frederik_: sounds like a bad design, why not just store one of them only?
16:52:08 <_frederik_> ndm: hehe bad design?
16:52:29 <ndm> _frederik_: if you store n and n+m, thats bad design if m is a constant
16:53:25 <_frederik_> ndm: it is because i want to use the full range of certain numeric datatypes, so i store the maximum value of an index rather than the number of valid values which is the maximum+1 == 0
16:53:43 <_frederik_> but in other places what matters is the number of valid values
16:54:05 <_frederik_> > (maxBound::Int)+1
16:54:06 <lambdabot>  -2147483648
16:54:11 <_frederik_> > (maxBound::CUInt)+1
16:54:12 <lambdabot>   Not in scope: type constructor or class `CUInt'
16:54:20 <_frederik_> > (maxBound::Foreign.C.Types.CUInt)+1
16:54:20 <lambdabot>      Not in scope: type constructor or class `Foreign.C.Types.CUInt'
16:54:24 <_frederik_> enh
16:54:29 <_frederik_> you get it
16:54:31 <ndm> _frederik_: why not use Integer? if your code depends on wrap-around, its broken
16:54:31 <_frederik_> hopefully
16:55:16 <_frederik_> ndm: because i care about efficiency in this application, and it is interfacing with a C library
16:55:27 <_frederik_> ndm: i'm not really that stupid, i hope
16:55:29 <ndm> _frederik_: efficiency /= correctness
16:55:56 * _frederik_ goes home
16:56:40 <chessguy> procyon112: hi
17:03:45 <ddarius> You scared him off ndm.
17:04:13 <ndm> ddarius: scared him into inductive logic and lack of efficientcy concern? thats a good thing!
17:05:14 <ddarius> Scared him home.
17:08:24 <monochrom> efficiency is part of correctness. efficiency is not in competition with correctness. unverified surgery to code is in competition with correctness.
17:08:48 <ddarius> Yay code surgery!
17:08:56 <Binkley> Yay cargo-cult programming
17:09:17 <ndm> lazy pure programming == highly efficiently
17:09:24 <ndm> we just don't have the algorithms to make the connection yet
17:09:32 <ndm> (well, i do, but the rest of you don't :) )
17:09:45 <monochrom> please upload yours to the wiki!
17:10:13 <ndm> monochrom: i give a talk on thursday on it, my blog has the results, the talk will be online by next friday
17:10:42 <monochrom> is next friday May 25?
17:10:53 <ndm> not in my time zone :)
17:13:44 <monochrom> Is the blog entry "47% faster than GHC"?
17:14:37 <ndm> yes
17:14:48 <ndm> plus 13% faster is one
17:14:57 <ndm> the 75% faster one hasn't yet been published
17:25:02 <davidL> how do I specify which directory to look for modules in GHCi?
17:25:23 <ndm> -idir
17:25:38 <davidL> thanks
17:28:44 <Binkley> @quote
17:28:44 <lambdabot> pjdelport says: [on qwe1234:] It must be a drag, being the sole beacon of sanity in a field where all the established researchers are unanimously insane.
17:34:22 <Binkley> @yow
17:34:22 <lambdabot> Are we THERE yet?  My MIND is a SUBMARINE!!
17:35:30 <augustss> @quote
17:35:30 <lambdabot> Paltas says: i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something..
17:39:01 <Binkley> @quote
17:39:01 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
17:46:10 <dons> ?yow
17:46:10 <lambdabot> Where's the Coke machine?  Tell me a joke!!
17:52:10 <davidL> can I "look ahead" with a lambda? for example: filter (\x y z -> foo) xs where x is the current element, y is the next element, and z the the next after that?
17:52:24 <Botje> no
17:52:28 <Botje> ?src filter
17:52:29 <lambdabot> filter _ []     = []
17:52:29 <lambdabot> filter p (x:xs)
17:52:29 <lambdabot>     | p x       = x : filter p xs
17:52:29 <lambdabot>     | otherwise = filter p xs
17:52:35 <Botje> there's no provision for lookaheads.
17:52:43 <Botje> davidL: perhaps you want to filter tails instead
17:52:46 <davidL> what about look backwards?
17:52:52 <Botje> > tails [1,2,3,4,5]
17:52:53 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
17:53:48 <Botje> lookbehind could be implemented with suitable addition of "reverse"
17:54:03 <Botje> davidL: does that answer your question?
17:54:13 <emu> > inits [1,2,3,4,5]
17:54:14 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
17:54:35 <ski_> > map head . filter (\xs -> case xs of x:y:z:_ -> x+y > z; _ -> False) . tails $ [1..5]
17:54:37 <lambdabot>  [2,3]
17:54:40 <Botje> or that.
17:55:01 <Botje> bah, there's a "tails" but no "heads" ? boo!
17:55:10 <davidL> there's inits
17:55:15 <Botje> i know
17:55:23 <davidL> not the same?
17:55:48 <Botje> never mind, was working up a crude english language joke :)
17:55:57 <davidL> I don't think tails would be the best thing on a list that is 150,000 elements big
17:56:03 <Botje> davidL: why not?
17:56:07 <Botje> remember, it's lazy
17:56:43 <Botje> that intermediate [[a]] is never actually generated, thanks to GHC's (and other compilers) ability to stream
17:57:28 <dolio> There's lots of sharing, too.
17:57:37 <Botje> > map head . filter (\xs -> case xs of x:y:z:_ -> x+y > z; _ -> False) . tails $ [1..150000]
17:57:39 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
17:57:47 <Botje> see? less than 3 seconds :]
17:58:42 <davidL> I will try this, thanks Botje and ski_
17:59:10 <Botje> you're welcome, have fun!
17:59:39 <emu> haskell is wonderful for making seemingly inefficient functional code be efficient.  it's also known to make seemingly efficient code dog-slow ..
17:59:41 * ari thinks about Botje's crude pun
17:59:52 <ari> Wouldn't heads = id?
18:00:11 <dolio> ari: That's what I was thinking, too.
18:01:34 <ndm> emu: what code goes dog slow?
18:02:03 <emu> > foldr (+) 0 [1..1000000]
18:02:04 <lambdabot>  Exception: stack overflow
18:02:17 <emu> > foldl (+) 0 [1..1000000]
18:02:18 <ndm> sum [1..1000000]
18:02:19 <lambdabot>  500000500000
18:02:22 <ndm> > sum [1..1000000]
18:02:26 <lambdabot>  500000500000
18:02:34 <emu> ah well, everyone runs into laziness issues at some pt
18:02:38 <ndm> why use a fold, when you have a beautiful "sum" sitting there
18:02:51 <emu> geez, can't i concoct straw men to knock down
18:03:01 <emu> :(
18:03:05 <ndm> sure, but we tend to burn them quickly :)
18:03:08 <Botje> maybe haskell could produce warnings if you have thunks bigger than a certain amount of folds
18:03:15 <dons> ?src sum
18:03:15 <lambdabot> sum = foldl (+) 0
18:03:17 <dons> ;-)
18:03:20 <dons> (!)
18:03:38 <emu> > foldl (+) 0 [1..1000000000]
18:03:44 <lambdabot> Terminated
18:03:47 <emu> > foldl' (+) 0 [1..1000000000]
18:03:53 <lambdabot> Terminated
18:03:56 <dons> hah
18:04:06 <emu> ok that may be too optimistic
18:04:25 <slava> hi dons
18:04:28 <dons> hey slava
18:04:34 <dons> how's code?
18:04:38 * ndm wonders if foldr (+) 0 can be automatically transformed to foldr' (+) 0
18:04:47 <Binkley> @type foldr'
18:04:53 <lambdabot> Not in scope: `foldr''
18:04:56 <emu> foldr'?
18:04:58 <dons> foldr' eh?
18:05:06 <ndm> (the theoretical, not actually existing, foldr')
18:05:09 <dons> foldl on strict atomic types could be foldl' without much bother
18:05:47 <ndm> i wonder if my optimisation automatically does that transformation
18:06:15 <dons> ghc uses SPECIALISE or RULES for this
18:06:26 <dons> { -# RULES sum = sumInt :: [Int]-> Int #-}
18:06:38 <dons> but i see no reason why it couldn't be done in general
18:06:46 <dons> other than, you know, changing semantics
18:06:57 <ndm> semantics is annoying :)
18:07:03 <dons> yeah
18:07:11 <procyon112> > foldl' (+) 0 [1..1000000]
18:07:12 <lambdabot>  500000500000
18:07:12 <lambdabot> procyon112: You have 1 new message. '/msg lambdabot @messages' to read it.
18:09:48 <TomMD> Ummm... Data.Generics.PlayOn?  What when and where?
18:10:46 <ski_> > foldl (const (const 0)) undefined (replicate 10 undefined)
18:10:47 <lambdabot>  0
18:10:55 <ndm> TomMD: my stuff, Play, but it got renamed yesterday :)
18:10:58 <ndm> @where play
18:11:04 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/play/
18:11:12 <ski_> http://www.cs.york.ac.uk/fp/darcs/play/play.htm ?
18:11:16 <lambdabot> Title: Play With Your Boilerplate
18:11:29 <ndm> TomMD: scrap your boilerplate, with less scary types
18:12:07 <ndm> "Play with your boilerplate", "Scrap your scary types" - those were my two original paper types
18:12:22 <ndm> now it looks like being "boilerplate removal and list processing" - how dull...
18:12:52 <ski_> LISt Processing ?
18:12:52 <Botje> "bore and lisp" ?
18:12:54 <TomMD> But I can't find it in hoogle and Catch complains loudly.
18:13:18 <ndm> TomMD: download Play, install it with cabal, and things will be happy
18:13:54 <ndm> TomMD: Hoogle doesn't contain my libraries, but it will do one day...
18:14:07 <Superpig> evening all. I'm getting a load of undefined references in my simple HAppS program - I'm guessing I've missed something obvious?
18:14:10 <ndm> Catch requires Play, because Play eliminates 100's of lines of code :)
18:14:14 <TomMD> Good - hoogle could be a truly great tool if it is made more inclusive.
18:14:17 <ndm> Superpig: --make?
18:14:25 <ndm> TomMD: Hoogle 4 is designed with that in mind
18:14:51 <Superpig> doh. thanks ndm. :)
18:15:16 <ndm> ps. if anyone wants to fund Hoogle 4 development, now would be a great time to step forward...
18:15:26 <TomMD> ndm: You wouldn't happen to be completing your academics and looking for a position, would you?
18:15:29 <ndm> plus i wonder if Hoogle makes a Real World Haskell boook?
18:15:46 <ndm> TomMD: by October, yes
18:15:52 <slava> what is hoogle?
18:15:58 <ndm> @where hoogle
18:15:58 <lambdabot> http://www.haskell.org/hoogle
18:16:07 <SamB_XP> @hoogle (a -> b) -> [a] -> [b]
18:16:08 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
18:16:08 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
18:16:08 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
18:16:09 <ndm> slava: type and name search for Haskell
18:16:11 <ski_> @hoogle replicateM
18:16:12 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
18:16:12 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
18:16:14 <slava> oh that's nice!
18:16:26 <SamB_XP> ndm: it needs a better LambdaRank...
18:16:51 <ndm> SamB_XP: hoogle has never been released, i'll worry about promotion after i make a release :)
18:17:19 <SamB_XP> wait.
18:17:22 <SamB_XP> I need better eyes
18:17:29 <SamB_XP> I missed "Prelude.map" at the top ;-)
18:17:48 <ndm> Hoogle 4 has a much better ranking algorithm
18:18:08 <ndm> but Hoogle 3 already has one which uses a constraint solver to generate an optimium ranking
18:18:37 <SamB_XP> someone code me some better eyes plz
18:18:49 <ndm> @hoogle Eyes -> IO ()
18:18:50 <lambdabot> No matches, try a more general search
18:19:18 <Procyon> so, hoogle 4 is "more optimal" ? :)
18:19:26 * SamB_XP wonders where the peripheral libraries for dsPIC33F* chips are...
18:19:31 <ndm> Hoogle 4 has better ranking criteria
18:19:52 <ndm> but uses the same constraint solving techniques to rank once it has scores
18:20:26 <ndm> in Hoogle 3, a ~= Just a, a ~= Just b - in Hoogle 4 those two are very different
18:21:01 <ari> weCanImproveHim :: (Bodypart a, Human h, MonadIO m) => h a -> Money -> m (h a)
18:21:22 <ndm> @instances Human
18:21:23 <lambdabot> Couldn't find class `Human'. Try @instances-importing
18:22:19 <dons> ari, hehe
18:22:44 <dons> ?users
18:22:44 <lambdabot> Maximum users seen in #haskell: 340, currently: 301 (88.5%), active: 45 (15.0%)
18:23:29 <ndm> dons: a question on your book, if you don't mind - are you including tagsoup/haxml in your HTTP and "mining the web" chapter
18:23:41 <dons> haxml, yes.
18:23:50 <dons> that's the planned xml framework, iirc
18:24:03 <ndm> fair enough
18:24:05 <Procyon> Why is it, that ever sense I learned Haskell, all my programming books I read now begin with "This book is written at the graduate level and is intended..."? :)
18:24:24 <dons> Procyon: raised standards? :-)
18:24:25 <ndm> you should get Malcolm to review whatever you write on HaXml
18:24:32 <Procyon> That never happend with C++.
18:24:48 <dons> ndm, yeah, i think we'll be contacting authors directly for reviews.
18:25:58 <Procyon> dons: I read somewhere in the blogspace you were currently accepting reviewers.  Where do I sign up?
18:26:10 <dons> let's see.
18:26:14 <dons> ?google real-world haskell
18:26:17 <lambdabot> http://changelog.complete.org/posts/612-Real-World-Haskell.html
18:26:17 <lambdabot> Title: Real-World Haskell - The Changelog
18:26:18 <dons> fingers crossed!
18:26:19 <dons> yay
18:26:22 <dons> almost
18:26:32 <dons> Procyon: there's an email addr on the web page
18:28:25 <davidL> > (group . sort) (take 10 (cycle [True, False]))
18:28:26 <lambdabot>  [[False,False,False,False,False],[True,True,True,True,True]]
18:29:35 <davidL> > False < True
18:29:37 <lambdabot>  True
18:30:41 <ptolomy> hmm.. making a 'build a random string, compare to a given string and re-randomize non-matching characters until the two strings are equal, return the number of tries required'  is turning out to be interesting, particularly if I'm at all concerned with efficiency.
18:32:13 <Korollary> is that fannkuch?
18:32:47 <ptolomy> no that I know of. Is it?
18:32:51 * ptolomy hasn't checked out the shootout in a while.
18:32:53 <dons> don't think so.
18:32:57 <Korollary> it's not
18:33:00 <dons> fannkuch is about flipping
18:33:07 <gravity> heh
18:33:16 <ptolomy> the task is pretty trivial in a language that allows side effects and mutable strings.
18:33:41 <dons> or without mutable string.
18:33:46 <dons> (how does mutation help?)
18:34:02 <Korollary> overwrite nonmatching characters
18:34:05 <ptolomy> oh, well, it mainly just makes it efficient.
18:34:12 <dons> there's an obvious efficient implementation, yes.
18:34:34 <dons> not sure its easier. looks to me like a use case for:
18:34:36 <dons> :t until
18:34:39 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
18:34:45 <dons> until (== x) (permute s)
18:34:51 <dons> something like that?
18:35:24 <ptolomy> hmm.. if I reconsider the specification to be 'randomly pick letter by letter, use the longest sequence of random letters as the total number of turns required, since random letters should theoretically be interchangeable', it is still fairly easy.
18:35:42 <dons> nice little exercise, actually.
18:35:50 <dons> i suspect there's some elegant solutions
18:36:00 <dons> lazy streams of random chars, and permutations
18:36:12 <Korollary> I'd do a list of infinitely long randomly generated strings
18:36:15 <ptolomy> I'm going the lazy stream way.
18:36:25 <ptolomy> with randomRs
18:36:52 <Korollary> actually, just use a single infinite random string
18:36:59 <Pseudonym> dons: What you need to do is do a lot of work on writing tools to write the book but never actually get around to writing the book.
18:37:13 <Binkley> like your namesake :-)
18:37:19 <dons> Pseudonym: nice idea.
18:37:20 <Korollary> dons: You need a metatheory of books
18:37:26 <Pseudonym> Oooh, good point!
18:37:32 <Pseudonym> What's a morphism between books?
18:37:39 <dons> I think that's a good plan.
18:37:45 <dons> probably should reimplement TeX first
18:37:49 <Pseudonym> True!
18:38:01 <Pseudonym> Let's be reasonable though.  Implement DocBook.
18:38:09 <Korollary> Who uses docbook?
18:38:10 <dons> yeah, better keep things practical
18:38:14 <dons> publishers.
18:38:19 <Korollary> Seriously?
18:38:22 <wchogg> Reimplement TeX?  A real man would write his own OS and drivers for talking with the printer first.
18:38:23 <dons> yup
18:38:44 <Pseudonym> O'Reilly, in particular.
18:38:48 <Korollary> Ah
18:38:58 <TSC> What's the easiest way to make a ByteString literal?  pack (map ord string) ?
18:40:35 <ptolomy> Hm. With very few exceptions, I've found that "task X is easy and efficient in <other language>, but really awkward in Haskell :("  is another way of saying, "I'm thinking about how to approach task X in haskell the completely wrong way".
18:40:37 <ptolomy> TSC:  I don't think you need the 'map ord'.
18:40:57 <ptolomy> Data.ByteString.Char8.pack
18:40:59 <Procyon> I've used docbook.  It made a very nice mechanism to automatically build a printed manual, help file and spec for an application, all as one document.  XSLT transformed the docbook to the proper format.
18:41:06 <gravity> I use docbook
18:41:22 <TSC> ptolomy: Ah, thanks!
18:41:28 <gravity> Of course, I was updating docs written in linuxdoc, so it was a natural progression
18:42:09 <Procyon> I normally swear off XML, but docbook wasn't too painful and the transforms into multiple formats were too good to pass up.
18:42:41 <dons> TSC: yeah, use the .Char8 modules.
18:43:58 <TSC> dons: I missed .Char8 completely; duh
18:44:08 <TSC> Please mention that in the book (:
18:46:23 <fuzan>   LoganCapaldo: i just recently adventured into monad transformers as well :)
18:47:11 <dons> OT, but interesting, http://reddit.com/info/1tdx4/comments
18:47:11 <lambdabot> Title: "We find that the successful assassination of autocrats produces institutional c ...
18:47:30 <dons> a nice study of the effectivness of assassination :}
18:47:56 <ptolomy> yikes, ghci did not like "pickChar lst c = (length pre, rest) where (pre,(x:rest)) = break (==c) lst" where lst was an infinite list of random chars and c was 'K'. Hung.
18:48:11 <slava> dons: do you really dislike the ML community so much that you're willing to consider this?
18:48:15 <Binkley> haha
18:48:20 <dons> slava: ha!
18:48:36 <dons> oh, the ML guys are fine. ayrnieu however.... ;-)
18:49:08 * gravity chuckles
18:50:37 <Korollary> By how much does the ocaml community outnumber SML people?
18:50:47 <Binkley> SML has people?
18:51:04 <SamB_XP> Procyon: why are you using obsolete things like XSLT instead of modern mechanisms like DSSSL?
18:51:15 <Korollary> They must exist. Vesa Karvonen exists. Ergo...
18:51:42 <dons>    /win 5
18:52:11 <Korollary> Then there's F# now. I wonder how big that is.
18:52:51 <Procyon> SamB_XP: Because someone else wrote stock transforms... I wasn't going to implement them myself :)
18:54:13 <Procyon> F# is near non existant here *at* Microsoft... few even know that it exists.  I can assume that if we are writing it, and it's non existant internally, it can't be too popular externally.
18:54:29 <Binkley> well, you could say the same thing about Haskell :-)
18:55:15 <ptolomy> Harrop sure is pushing the F# hard.
18:55:28 <Procyon> I'd sure love to be doing the C# here in F# instead though...
18:56:03 <SamB_XP> Procyon: didn't he also write them in DSSSL?
18:56:14 <Korollary> Harrop is another one of those not so fine ML people.
18:56:17 <Procyon> (I'd *really* love to dump the C-style C++ crap we code in here, but that's a pipe dream)
18:56:17 <TomMD> What are the buzzwords F# has associated with it?
18:56:24 * SamB_XP wonders SGML supports XML namespaces yet
18:56:27 <slava> TomMD: .net
18:56:47 <Procyon> SamB_XP: don't know...I didn't see any when I was doing it.
18:57:11 <TomMD> No, I mean like: strict, lazy, functional, $#%#! up, etc.
18:57:16 <slava> strict
18:57:25 <Korollary> it's very much like ocaml
18:57:38 <ptolomy> I had big plans for F#, then it turned out that I couldn't inherit from the C# class in the library I was basing stuff on, so I backed off.
18:57:39 <SamB_XP> #!
18:57:45 <SamB_XP> it has the # buzzword, too
18:57:57 <TomMD> Ahh... so did it actually differentiate itself from ocaml to a notable degree?
18:57:59 <dylan> F-pound.
18:58:37 <SamB_XP> dylan: I'm relatively certain that it is intended to be pronounced "F sharp"
18:58:41 <dylan> F# doesn't have functors (functions in the module space) or the same class system.
18:58:56 <dylan> SamB_XP: But # is not a sharp, it's a pound. And it sounds funnier.
18:59:03 <Korollary> TomMD: http://research.microsoft.com/fsharp/manual/ml-compat.aspx
18:59:04 <lambdabot> Title: F# Manual
18:59:15 <SamB_XP> dylan: the same excuse as for C sharp applies
18:59:18 <SamB_XP> or excuses
18:59:31 <SamB_XP> namely: easier to type, more compatible
18:59:33 <dylan> SamB_XP: I pronounce that as C-pound. :)
18:59:55 <ptolomy> F# has Active Patterns, which I don't understand, but seem pretty neat.
19:00:06 <dylan> I also like to try to turn things like "Oregon, Wisconsin" into "Organ, Wizcousin"
19:00:07 <Korollary> But no functors. Weird.
19:00:10 <SamB_XP> perhaps one day they will be renamed with an actual sharp sign
19:00:29 <slava> i never really grokked functors
19:01:30 <Korollary> It's easy if you don't read the ocaml tutorial, which is horrid.
19:01:36 <TomMD> "Strings are Unicode and immutable."  I typically agree with MS, unicode should be the defacto.
19:02:16 <Korollary> slava: There's an SML tutorial/book over at CMU, which describes modules/functors much better.
19:02:29 <davidL> > foldl1' (==) [2,2,2,2]
19:02:30 <lambdabot>   add an instance declaration for (Num Bool)
19:02:30 <lambdabot>     In the expression: 2
19:03:42 <Korollary> slava: http://www.cs.cmu.edu/~rwh/smlbook/online.pdf
19:03:49 <slava> thanks
19:04:12 <ptolomy> I never really played with SML (started with Ocaml), but it seems "cleaner" than Ocaml.
19:04:20 <davidL> > let f xs = all (==(head xs)) xs in f [2,2,2,2]
19:04:21 <lambdabot>  True
19:05:29 <Korollary> ptolomy: This comparison is excellent: http://www.cs.berkeley.edu/~adamc/mlcomp/
19:05:30 <lambdabot> Title: Comparing Objective Caml and Standard ML
19:06:54 <ptolomy> ah, from Adam Chlipala's page.
19:06:55 <ptolomy> I like that guy.
19:07:02 <ptolomy> Korollary: Thanks.
19:07:20 <ptolomy> sml : ocaml :: scheme : common lisp
19:07:45 <Korollary> Yeah he has a lot of cool stuff
19:08:00 <Procyon> # is pronounced "octothorpe", and the .Net languages are therefor "Coctothorpe" and "Foctothorpe"
19:08:31 <jfredett> Procyon, Thank you for the enlightening, if useless, information.
19:08:32 * ptolomy considers a "I <3 Coctothorpe" t-shirt..
19:08:32 <Korollary> Those are now my preferred pronunciations for those languages
19:08:51 <jfredett> I concur
19:08:57 <Binkley> both sound like things you don't want to run into in a dark alley
19:09:17 <jfredett> Coctothorpe == caulk toe thorpe?
19:09:44 <Procyon> That's how I say it.. it does get some weird looks here at microsoft though :)
19:09:50 <jfredett> lol
19:09:52 <jfredett> Nice
19:10:45 <jfredett> i guess that should be Caulk $ toe $ thorpe, where thorpe = thor . oar $ p
19:11:29 <jfredett> then again, function composition has always escaped me, so it's probably still wrong
19:12:27 <Procyon> I'm not sure whether to be more disturbed by the fact that your applying Caulk to your toe, or an oar to your p.
19:13:16 <monochrom> Hahaha
19:13:29 <jfredett> :)
19:13:54 <jfredett> I didn't think of that
19:14:28 <jfredett> but it is quite excellent
19:16:37 <luqui> here's a design question
19:16:43 <luqui> wait
19:16:53 <luqui> nevermind, back in a bit perhaps with a better-formed question :-)
19:17:07 <Binkley> come by anytime, we're here all night
19:17:20 <Binkley> @yow
19:17:20 <lambdabot> I wonder if I should put myself in ESCROW!!
19:17:49 <jfredett> brilliant Idea Lambda, I think I'll do just that
19:18:29 <Superpig> When trying to work with HAppS, is giving up beginning the healing process a reasonable course of action to take?
19:18:40 <Superpig> giving up *and* beginning the healing process, rather
19:18:48 <Procyon> Is there an implementation of light-weight threads in haskell, like continuation based threading in scheme, or erlang style threads that don't actually resolve to real OS threads?
19:19:11 <luqui> forkIO, right?
19:19:21 <monochrom> forkIO does not all resolve to real OS threads.
19:19:28 <ihope> Continuation-based threading?
19:19:32 <ihope> Sounds fancy.
19:19:33 <Procyon> really? cool.
19:19:46 <ihope> Does it involve call-with-current-continuation?
19:20:36 <Procyon> ihope: It's actually pretty simple.  And yeas, it's just call/cc, save the continuation in an outer scope, then context switches are just looping through the continuations.
19:20:51 <ihope> Interesting.
19:21:19 <Procyon> Dybvig's book has a simple implementation of them, calling them "engines".
19:21:31 <ihope> Say, is there a way for callCC continuations to escape?
19:21:39 <ihope> @hoogle callCC
19:21:40 <lambdabot> Control.Monad.Cont.callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
19:21:42 <Procyon> Termite (implemented in Gambit) uses them for an erlang-like scheme.
19:22:05 <ihope> Have "a" be a type containing (a -> m b)?
19:22:10 * Superpig gives up on HAppS, and begins the healing process, considering Ruby on Rails instead
19:22:35 <slava> how's ghc's unicode support?
19:22:56 <Procyon> fully functional. (har har)
19:23:05 <slava> hahaha
19:23:32 <ihope> Yes, but is it purely functional?
19:23:33 <ihope> :-)
19:23:51 <ihope> If it doesn't contain the entire Han character set, whatever that is, it's junk.
19:24:17 <Procyon> > length ['a'..]
19:24:19 <lambdabot>  1114015
19:24:31 <Procyon> > length ['\0'..]
19:24:32 <lambdabot>  1114112
19:24:39 <slava> > 2 ** 21
19:24:40 <monochrom> If you enter source code in UTF-8, ghc will read it fine.
19:24:40 <lambdabot>  2097152.0
19:26:10 <monochrom> > maxBound :: Char
19:26:12 <lambdabot>  '\1114111'
19:26:20 <ihope> And what character is that?
19:26:22 <ihope> :-)
19:26:35 <Binkley> we could tell you, but then we'd have to kill you
19:27:09 <ihope> Eh, I can probably tell by myself.
19:27:15 * ihope sneakily pulls out a GHCi
19:27:23 <Binkley> oh, ghci, the secret weapon
19:27:32 <ihope> Apparently, it's .
19:27:39 <ihope> Erm.
19:27:42 <ihope> It's  .
19:27:46 <ihope> Not to be confused with ..
19:28:07 <monochrom> Some surrogate perhaps.
19:28:28 <ihope> Indeed.
19:29:40 <jfredett> hmm
19:30:31 <jfredett> so, my lambda expression interpreter is kind of moving-- well, not at all. does anyone have an example i could drudge through? I've never done one of these before
19:31:43 <monochrom> Do you settle for a scheme interpreter in 48 hours?
19:32:35 <jfredett> monochrom, ... I know of write yourself a scheme in 48 hours, I was hoping for something less monolithic, though it occurs to me now that there would be a lambda interpreter in there somewhere.
19:32:44 <jfredett> I suppose I'll dig that up
19:32:58 <Procyon> jfredett: typed or untyped lambda calculus?
19:33:23 <jfredett> untyped, I supposed
19:33:26 <jfredett> suppose*
19:34:01 <monochrom> I have an SECD machine lying around.
19:34:19 <jfredett> It's probably easier, I can always figure out typed lambda calculus later.
19:35:47 <Procyon> an interpreter for Lambda calculus is trivial (like 1 line of code trivial).  The parser to get the terms into an abstract syntax tree is the hardest part.
19:35:57 <Pseudonym> I have a Turing machine lying around, but you can't buy tape any more.
19:36:02 <Procyon> lol
19:36:15 <jcreigh> @remember Pseudonym I have a Turing machine lying around, but you can't buy tape any more.
19:36:15 <lambdabot> Done.
19:36:25 <SamB_XP> Pseudonym: isn't the turing machine supposed to extrude tape as needed?
19:36:39 <Procyon> He bought the cheap kind.
19:36:40 <Pseudonym> No, you splice tape when the head gets near the end.
19:36:47 <SamB_XP> heh
19:38:01 <jfredett> see, I must not be thinking in the right frame of mind to write one then, I'm really only trying to implement the backend
19:38:07 <jfredett> parser can come later
19:38:17 <jfredett> i just want to see it work.
19:38:33 <Pseudonym> Actually, more seriously, I know someone with a VAX 11/780.
19:38:34 <jfredett> get my brain in the right setting and whatnot
19:38:35 <Pseudonym> And it works.
19:38:47 <Pseudonym> He's the only person I know with three-phase power in his living room.
19:38:54 <jfredett> lol, kickass.
19:39:20 <SamB_XP> what does three-phase look like?
19:40:07 <Pseudonym> It's a kind of a cross shape.
19:40:26 <Pseudonym> Hang on, let me find a picture,.
19:40:29 <SamB_XP> ... cross shape?
19:40:50 <Procyon> I had a sun E5500 in my living room, complete with 14 procs, but when my girlfriend moved in she mad it go away :(
19:40:51 <Pseudonym> http://joahua.com/blog/2006/05/17/three-phase-32a-415v-power-socket
19:40:55 <lambdabot> Title: Josh.st » Three-phase 32A 415V power socket, http://tinyurl.com/yss8wy
19:41:12 <Pseudonym> 415V, 32A of fatal goodness.
19:41:52 <Pseudonym> Note, by the way, that this socket is in an open area, and turned on.
19:41:58 <monochrom> The same thing drives washing machines.
19:42:00 <Pseudonym> Despite there being a key.
19:44:16 <monochrom> @instancd MonadFix
19:44:17 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:46:37 <Korollary> jfredett: There are LC examples all over the place.
19:47:23 <Korollary> jfredett: http://www.cis.upenn.edu/~bcpierce/tapl/
19:47:24 <lambdabot> Title: Types and Programming Languages
19:47:40 <Korollary> http://www.cis.upenn.edu/~bcpierce/tapl/checkers for the sources
19:47:42 <lambdabot> Title: Directory Index
19:48:45 <Procyon> jfredett: "untyped" should be the one you want.
19:49:37 <Procyon> They are in OCAML, but translation should be trivial.
19:49:51 <jfredett> Korollary, Brilliant,
19:49:55 <Korollary> Yeah I dont have any haskell links handy
19:50:00 <jfredett> exactly what I needed
19:50:06 <jfredett> i wouldn't want one
19:50:11 <jfredett> Ocaml is actually better
19:50:19 <jfredett> the act of translating will make me learn it better
19:50:31 <Korollary> ah
19:50:34 <Korollary> http://okmij.org/ftp/Computation/lambda-calc.html#lambda-calculator-haskell
19:50:36 <lambdabot> Title: Lambda Calculus and Lambda Calculators, http://tinyurl.com/2f997o
19:52:08 <Procyon> There appears to be no work involving Genetic Programming to evolve Pi Calculus terms...
19:52:11 <jfredett> How did I not find these things? I googled for hours... :/
19:52:20 <Korollary> google sucks heh
19:52:22 <jfredett> lol
19:54:06 <Korollary> Well, in a sense the fitness function is the type checker, and the programmer bangs on the keyboard until it checks. Voila.
19:54:38 <SamB_XP> couldn't you use a radio telescope or something instead?
19:54:53 <Korollary> Management wouldnt approve
19:55:27 * SamB_XP is thinking of those key-generation programs that suggest that you type on the keyboard or move the mouse
19:55:36 <jfredett> ... whats the "#" command do? I haven't seen it before (sorry to interupt.)
19:55:54 <jfredett> I've seen $ and ., but not ^ or #
19:57:51 <Korollary> I don't know about #.
19:58:46 <Binkley> jfredett: can you paste an example of code you're trying to understand?
19:59:12 <jfredett> yah, hang on
19:59:32 <jfredett> its short, so I'll just paste it to chat
19:59:36 <jfredett>  add = a ^ b ^ f ^ x ^ a # f # (b # f # x)	-- Add two numerals
19:59:50 <Binkley> is that Haskell or OCaml?
19:59:51 <jfredett> its from here: http://okmij.org/ftp/Haskell/LC_basic.lhs
19:59:54 <jfredett> haskell
19:59:55 <Binkley> ah ok
20:00:14 <jfredett> maybe he has these defined somewhere, and I'm just not seeing them
20:00:38 <Binkley> see http://okmij.org/ftp/Haskell/Lambda_calc.lhs
20:00:40 <Binkley> that's where he defines #
20:00:47 <jfredett> ahh, brilliant
20:00:49 <jfredett> thanks
20:00:56 <Binkley> the other place you might see a # is as part of the name of an unboxed variable
20:01:04 <Binkley> but you don't really need to worry about that until you run into it :-)
20:01:24 <jfredett> whoa, boxing, *hides*
20:02:55 <dmwit> I'll punch yer lights out!
20:05:22 * jfredett ducks and avoids dmwit 
20:05:49 <Pseudonym> Seconds down, round one.  *ding*
20:06:09 * Pseudonym has been to a boxing match, believe it or not
20:06:17 <Pseudonym> It was for work.
20:06:40 <Korollary> We still love you
20:06:42 * jfredett goes for the quick right hook
20:06:58 <dmwit> ABAB Left Right Left Right!  Barrel roll!
20:07:08 <jfredett> damn! foiled again!
20:07:13 <Pseudonym> The first bout of the afternoon, I didn't get a good look at.
20:07:17 <jfredett> you'll rue the day your crossed me, dmwit
20:07:18 <Pseudonym> It was between two trainers in the foyer.
20:08:12 * dmwit shivers in fear
20:08:29 * jfredett laughs evilly
20:13:31 * araujo wonders if anyone would be interested to trade a book by TaPL
20:24:08 <oh`> hey fellas, is it possible to pick off the last element of a list recursively?
20:24:13 <oh`> ie. each cycle you use the last element instead of the first one?
20:24:19 <dmwit> last, init
20:24:37 <dmwit> > (init &&& last) "hi there!"
20:24:42 <lambdabot>  ("hi there",'!')
20:24:47 <dmwit> Or, reverse the list. ;-)
20:25:20 <oh`> k cheers ill give it a go
20:31:20 <newsham> Happy's setup.lhs references BulidFlags and CleanFlags from Distribution.Setup which doesnt exist in cabal that comes with ghc 6.4.2. :(
20:31:40 <newsham> happy claims to build on "ghc version 5.04 or later"
20:32:22 <Korollary> It probably does if you were to compile files manually
20:32:53 <Korollary> I think you should be able to upgrade your cabal
20:33:36 <newsham> or i could just stab myself in the face :(
20:34:41 <Korollary> upgrading cabal (or ghc) is probably saner.
20:36:56 <newsham> upgrading ghc means no work till tomorow
20:43:38 <bos> @seen cosmicray
20:43:38 <lambdabot> I saw cosmicray leaving #haskell-blah, #darcs and #haskell 4h 1m 45s ago, and .
20:43:40 <bos> @seen dons
20:43:40 <lambdabot> dons is in #haskell, #haskell-overflow, #ghc, #haskell-soc and #xmonad. I last heard dons speak 8m 39s ago.
20:46:42 <ed1t> @seen lambdabot
20:46:42 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-
20:46:42 <lambdabot> haskell, #darcs and #scannedinavian
20:49:41 * bos curses darcs's unfriendly ways
20:52:49 <anotherdaniel> Hi, trying to build a ffi app... can GHC link to shared libraries (.so)?
20:58:28 <newsham> what is ghcxmake?
21:09:19 <lispy> bos: what is being unfriendly about it?
21:10:39 <bos> lispy: if you type "darcs rm somefile", you get more than a page of help output, so you can't see the error message.
21:11:54 <lispy> bos: ah, well rm isn't a valid command ;)
21:12:03 <lispy> bos: i do see what you mean though
21:12:27 <bos> yes, but everyone else knows that rm is remove
21:12:35 <bos> and darcs accepts mv instead of rename.
21:12:58 <lispy> there is a reason though, and has been a lot of discussion in the past about rm
21:13:21 <lispy> basically, as i recall, they didn't want people to think that darcs remove works like unix rm
21:13:41 <SamB_XP> what is the difference?
21:13:48 <lispy> unix rm calls unlink
21:13:53 <lispy> darcs remove does not
21:13:59 <SamB_XP> ah.
21:14:03 <bos> yes, which is also infuriating.
21:14:09 <SamB_XP> well, maybe they should have a darcs rm that does?
21:14:19 <lispy> SamB_XP: maybe
21:14:41 <lispy> bos: well, that might be personal preference.  I hate it that svn remove deletes the file
21:16:43 <lispy> bos: if you don't like the current behavior, i'd say file a bug report (bugs@darcs.net) so that the devs are aware that not everyone likes the current way
21:17:09 <lispy> (or if you don't mind joining a mailing list, start a thread about it at darcs-usesrs
21:17:14 <lispy> darcs-users*
21:17:22 <bos> sure, i know. impotent whining here gets me nowhere :-)
21:17:30 <SamB_XP> note that I am suggesting that darcs rm behave differently from darcs remove...
21:17:31 <lispy> :)
21:17:38 <robreim> @pl \x y -> 1 + (x * y)
21:17:38 <lambdabot> ((1 +) .) . (*)
21:17:40 <lispy> SamB_XP: right, i follow
21:18:18 <lispy> SamB_XP: it sounds reasonable to me, but i didn't follow the discussion much in the past...that may have been shot down for some reason but i dunno
21:18:38 <SamB_XP> I can think of reasons why it is a bad idea
21:18:57 <SamB_XP> but I don't think they are terribly good ones
21:38:29 <bos> what's the magic darcs-fu to run a command before every commit?
21:40:03 <Korollary> You don't know? oh boy. This book is not going to be good.
21:40:08 <Korollary> ;)
21:40:13 <jcreigh> bos: to run a test?
21:40:28 <bos> jcreigh: yep, i want to validate the docbook before every record.
21:40:48 <bos> Korollary: i'm just a humble wordsmith :-)
21:41:04 <jcreigh> darcs setpref test 'command to run'
21:41:06 <jcreigh> I think
21:41:33 <bos> thanks, that's the one.
21:42:03 <jcreigh> bos: congrats on the book deal, BTW. I'm really excited about it.
21:42:08 <bos> thanks!
22:08:46 <dons> bos: yo?
22:09:45 <mwc> Hey dons, nice work on the RWH book
22:09:52 <mwc> pre-props.
22:11:54 <araujo> hi there
22:12:23 <araujo> talking about books ... anyone interested to trade a book by TaPL?
22:14:18 <bos> dons: nothing in particular
22:14:44 <dons> araujo: trade by?
22:15:18 <araujo> dons, By another interesting book would be nice
22:15:19 <kilimanjaro> dons, it's sort of like trading for something, except when you give him yours he keeps his
22:16:04 <araujo> For let's say, a confusion, i ended up with two TaPL books
22:16:10 <dons> araujo: you want to swap a book for TaPL? or you want to swap something of yours , for someone else's TaP?/
22:16:14 <araujo> And i would like to change one for other book
22:16:15 <dons> ah ok.
22:18:07 <araujo> dons, spread the word if you can :-)
22:18:19 <araujo> The book is new
22:18:26 <dons> araujo: you should drop a mail to haskell-cafe@
22:18:36 <araujo> yeah?
22:18:41 <dons> probably someone in your area wants a copy, so the shipping won't be too expensive
22:18:47 <dons> i reckon.
22:18:52 <araujo> yeah, more likely
22:20:57 <kfish> araujo, i'll swap you for the copy of "Real-World Haskell" (O'Sullivan, Stewart, Goerzen 2008) that's gathering dust on my bookshelf
22:21:07 <araujo> hahaha
22:23:41 <araujo> kfish, i heard you have to be on queue for months to get a copy of that one ;-)
22:40:07 <gwern> I'm interested in taking a mass of English and indenting by grammatical structure. are there any good haskell libraries for that?
22:40:44 <stepcut> gwern: grammatical framework maybe ?
22:41:04 <gwern> is that a specific library?
22:41:17 <stepcut> http://www.cs.chalmers.se/~aarne/GF/
22:41:19 <lambdabot> Title: GF Version 2.7
22:41:54 <Korollary> indenting English people?
22:42:04 <stepcut> I think both shapr and bringert have actually used it
22:42:12 <stepcut> I've only looked at the docs
22:42:49 <gwern> Korollary: no indenting pls, we're British
22:42:58 <gwern> *a mass of English text
22:43:36 <gwern> "Resource grammar library: basic structures of ten languages (Danish, English, Finnish, French, German, Italian, Norwegian, Russian, Spanish, Swedish). Resource grammars can be used as libraries for writing GF applications, but they can also be useful for language training." <-- sounds promising
22:44:50 * gwern honestly just wanted something like parse :: String -> [Phrases], so I could mindleslly indent based on how deep in the list a phrase was
22:45:13 <gwern> wait, http://www.haskell.org/haskellwiki/Applications_and_libraries/Linguistics
22:45:16 <lambdabot> Title: Applications and libraries/Linguistics - HaskellWiki, http://tinyurl.com/2aaeeg
22:45:19 <gwern> why didn't that show up on google?
22:46:00 <dons> there's some work/research. i'd imagine you could find something
22:47:56 <gwern> (yeah. one of my old dreams is to have an IDE for english just like we have ides for java or haskell)
22:49:28 <gwern> (I mean, it's just embarassing that the best support one can offer  - in the Free software world - for natural language writers is a *spell checker*. but I'm a bit cranky on this subject, ignore my ramblings)
22:49:29 <Korollary> There was this thing about robots.txt and haskell.org
22:49:48 <gwern> ...google was deliberately blocked? that's stupid
22:51:28 <dr_strangelove> what is a monoid?
22:51:36 <dr_strangelove> what is it good for?
22:51:45 <dons> they're a good abstraction on sequences
22:51:47 <slava> a set with an associative binary oepration and identity
22:51:50 <dons> ?src Monoid
22:51:50 <lambdabot> class Monoid a where
22:51:50 <lambdabot>     mempty  :: a
22:51:50 <lambdabot>     mappend :: a -> a -> a
22:51:50 <lambdabot>     mconcat :: [a] -> a
22:52:24 <dons> Data.Binary uses a monoid for serialisation. other logging/writer abstractions use monoids
22:52:26 <slava> dons: how is ?src implemented, roughly?
22:52:46 <dons> lookup in a .gz-compressed Map from identifer to src, manually bulit
22:53:37 <dons> slava: i'd imagine @src would be good for any concise language with a std lib and an irc channel...
22:53:40 <dr_strangelove> I'm messing around with happs and try to store a tree in the State-Monad. But it fails because my tree is not an instance of monoid
22:54:05 <dons> make it an instance of Monoid, providing empty, append and concat
22:54:12 <slava> dons: you guys have some cool stuff, like @src and hoogle, but no interactive development environment :(
22:54:20 <gwern> what a coincidence. just half an hour ago, I was wondering whether I should write a HAppS Wikipedia article
22:54:39 <dons> slava: ghci is interactive enough :-) (yeah, i know, i know..)
22:54:41 <dr_strangelove> dons: yeah, but how does append work on a tree?
22:54:47 <slava> dons: i mean something smalltalk-ish
22:54:53 <dons> slava: no research papers in UIs for haskell.
22:54:54 <slava> dons: does ghci have something like @src?
22:55:06 <sjanssen> dr_strangelove: are you sure you aren't doing something incorrectly?
22:55:07 <dons> nope, but you can call lambdabot from ghci
22:55:19 <gwern> http://www.cs.chalmers.se/~aarne/GF/doc/tutorial/gf-tutorial2.html#toc10 <-- looks promising
22:55:21 <lambdabot> Title: Grammatical Framework Tutorial, http://tinyurl.com/2hemlm
22:55:25 <sjanssen> dr_strangelove: like using the Writer monad, perhaps?
22:55:38 <stepcut> gwern: a bunch of poorly behaving bots were trying to index every diff of every page on the wiki and causing problems -- so bots were temporarily blocked till someone could fix it, which never happened :)
22:55:38 <dons> gwern: you should write about it, if you find it useful. i don't think many know about this library
22:55:45 <dr_strangelove> sjanssen: I have no idea
22:56:11 <dr_strangelove> I just try to make sense of the error messages
22:56:30 <gwern> stepcut: oh. I hope that'll be fixed soon. I have to wonder how many people have wasted time because the wiki wasn't being indexed
22:56:51 <gwern> dons: well, it gets a bit of play on reddit, but after the attention xmonad attracted I'm not too sure
22:56:52 <dons> slava: so the UI issue, things like @src are nice, and cheap to implement. things like hoogle are smart, and you can get a research paper out of it. things like a smalltalk interactive env, smart, but no research papers, so no one does it. the joy of an economy based on research funding.
22:57:02 <gwern> are there many research papers on HAppS?
22:57:13 <dons> no, its a special case. Alex funded it personally
22:57:17 <dons> hence it got done.
22:57:28 <dons> things like xmonad get done, because they're fun, and open source. and small
22:57:36 <Korollary> slava: F# seems to have the most interactive env. ocaml toplevel and ghci are very minimal. UIs take a lot of code. Maybe Yi will turn into one.
22:57:39 <dons> but a ui, hard, lots of work, no research aspect.
22:57:49 <dr_strangelove> sjanssen: what do you mean by using the writer monad?
22:58:06 <dons> yeah, yi could get there. but it'll take a while. (based entirely on ghc-api)
22:58:25 <sjanssen> dr_strangelove: it's a monad ... called Writer :)
22:58:26 <stepcut> gwern: there was some recent discussion on the mailing list, and a possible solution, so maybe (regarding robots.txt)
22:58:28 <njbartlett> Video of SPJ's talk at the London HUG: http://video.google.co.uk/videoplay?docid=370317485066035666&hl=en-GB
22:58:30 <bos> all of the haskell UI research turned out to be a muddle.
22:58:31 <lambdabot> Title: Nested Data Parallelism in Haskell - Google Video, http://tinyurl.com/2e7u76
22:58:34 <dons> woo, njbartlett !
22:58:36 <gwern> dons: oh. that's too bad. I'd have no problems with AfD if I had a research paper or two. but if there aren't any, I'm not sure I want to bother. hm
22:58:37 <dons> njbartlett: good work
22:58:38 <Korollary> njbartlett: thanks
22:58:48 <bos> yampa, fudgets, etc, etc. ugh.
22:58:53 <njbartlett> Will put up the slides etc on the HUG webpage shortly
22:59:07 <sjanssen> dr_strangelove: it was just a random guess, it's the standard library that really requires monoid
22:59:17 <sjanssen> s/the/the only/
22:59:30 <njbartlett> dons: Congrats on the book, really looking forward to reading it
22:59:54 <gwern> bos: didn't the arrows stuff turn out well?
23:00:02 <dons> njbartlett: cheers.
23:02:08 <bos> gwern: it hasn't exactly swept the world :-)
23:02:47 <gwern> bos: well, no form of ui in haskell has swept the world period
23:03:03 <dons> conal's new arrowy ui seems nice
23:05:13 <Korollary> New?
23:05:46 <stepcut> IMO, the arrow-based GUI construction is too rigid. For example, I think it would be hard to use yampa, etc, to make a program that reads in an .xml spec and renders a GUI from it.
23:06:13 <slava> why would you want to use xml for that? :)
23:06:27 <slava> use a statically type checked internal DSL instead
23:07:12 <stepcut> slava: it does not have to be .xml. Just something sort of thing that is read at run-time.
23:07:44 <Korollary> Why at runtime?
23:08:29 <stepcut> Korollary: because, that is the most extreme example of what I think the current Haskell GUI things like yampa are bad at
23:09:30 <stepcut> Korollary: with yampa and friends, are good if you know all the widgets you want at compile time, and exactly how they should be hooked up. But they do not seem that great at 'dynamic' widget creation
23:10:19 <stepcut> the most extreme version of that is having 'nothing' at compile time, and creating the everything done at runtime.
23:11:13 <bos> which is very common. witness gtk2hs and glade.
23:15:51 <stepcut> I am thinking that the current arrow based approaches are kind of stuck. So maybe we need to try a completely different direction to get some new information.
23:18:47 <muh__> good morning
23:19:24 <muh__> I'm playing around with exception handling in haskell
23:19:53 <muh__> I'm trying to read all the files in a directory into a list of lazy bytestrings
23:20:47 <muh__> I get the directory's contents into a list and mapM readFile over it
23:20:49 <quicksilver> stepcut: hmmm, is that true?
23:21:01 <quicksilver> stepcut: can't yuou build your arrow network at runtime?
23:21:08 <quicksilver> stepcut: (I admit, I've never looked at yampa properly)
23:21:26 <muh__> obviously readFile fails when the path is a directory, not a file
23:21:59 <muh__> so I tried n <- catch (mapM B.readFile m) (\err -> return [B.pack "error"++B.empty])
23:22:47 <muh__> but that doesn't work
23:23:06 <muh__> pack expects [Word8], not [Char]
23:23:45 <muh__> but the documentation for ByteString says pack :: String -> ByteString
23:24:16 <muh__> so how do I convert a String into a ByteString?
23:26:02 <sieni> > fromIntegral . ord $ '7' :: Word8
23:26:03 <lambdabot>  55
23:26:34 <sieni> map (fromIntegral . ord) "Fubar" :: [Word8]
23:26:40 <sieni> > map (fromIntegral . ord) "Fubar" :: [Word8]
23:26:42 <lambdabot>  [70,117,98,97,114]
23:26:43 <Korollary> ?index c2w
23:26:44 <lambdabot> bzzt
23:26:51 <Korollary> ?index Data.ByteString.Base.c2w
23:26:51 <lambdabot> bzzt
23:26:54 <emu> muh__: using Data.ByteString.Char8?
23:26:56 <stepcut> muh__: pack
23:27:23 <stepcut> muh__: oh, use Data.ByteString.Char8.pack
23:30:56 <dons> muh__: Data.ByteString.Char8
23:32:38 <muh__> seems to work
23:32:41 <muh__> thank you
23:33:08 <LordBrain> With monad transformers, which is the "inner" monad, and does it matter or is this an arbitrary convention?
23:34:29 <LordBrain> i haven't groked them yet
23:35:14 <sieni> LordBrain: The monad being transformed is the inner monad.
23:35:28 <LordBrain> hmmm
23:35:50 <LordBrain> and lift takes you inward?
23:37:44 <LordBrain> lift $ put 3
23:37:57 <Thomas2> well, lift is really taking the put outward
23:37:59 <sieni> no outward
23:38:00 <LordBrain> put's 3 in the monad which is transformed?
23:38:09 <LordBrain> ah ok
23:38:14 <LordBrain> thanks for clearing that up
23:38:18 <LordBrain> it seemed outward to me
23:38:33 <LordBrain> but i'm reading a blog and he keeps saying inward
23:39:02 <LordBrain> http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
23:39:05 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
23:40:06 <LordBrain> "Ordinary Monad commands will
23:40:07 <LordBrain> talk to the outermost layer and you can use 'lift' to send your
23:40:07 <LordBrain> commands inwards by one layer."  He means just the opposite then, right?
23:42:12 <sieni> well, it depends on your view of what's inside and what's outside, right?
23:43:32 <sieni> It appears that he's using
23:43:34 <sieni> Argh
23:43:45 <LordBrain> hmmm
23:43:49 <LordBrain> my view...
23:43:54 <LordBrain> is his view consistent?
23:43:55 <sieni> LordBrain: Well, he is correct
23:44:49 <sieni> LordBrain: lift allows you to change an operation of the inner monad into an operation of the outer monad.
23:45:07 <LordBrain> "For various reasons
23:45:07 <LordBrain> the IO monad must form the innermost core of your onion so
23:45:07 <LordBrain> there's no need to wrap an IO layer around the Identity,
23:45:07 <LordBrain> you can just start with IO."  <-- Doesnt this sentence agree with the view you stated earlier?
23:45:08 <sieni> LordBrain: so you can talk "inwards"
23:45:49 <LordBrain> ok... so like i said earlier
23:46:16 <LordBrain> lift $ put 3  -- put's 3 in the state of the "inner monad"
23:47:24 <sieni> lift changes a function of the inner monad into a function of the outer monad, so in that sense it takes you outwards
23:47:37 <LordBrain> ok
23:48:13 <sieni> but in the other sense, that the resulting function takes a value in the outer monad, applies the lifted function in the inner monad and returns the value again in the outer monad, it takes you inwards
23:48:36 <LordBrain> takes me {in/out}wards is probably a muddling way of thinking of it
23:48:57 <LordBrain> yeah
23:49:02 <LordBrain> i see
23:49:32 <Vq^> sieni: is the transformer called the inner monad?
23:50:12 <LordBrain> the thing transformed...
23:50:30 <LordBrain> is what he said earlier
23:50:55 <LordBrain> i'm not sure if that clarifies actually
23:51:19 <dons> let's consider a real world example,
23:51:20 <dons>    newtype X a = X (ReaderT XConf (StateT XState IO) a)
23:51:27 <dons> here we have, at the very bottom, IO a
23:51:37 <dons> that is, code that talks to the outside world
23:51:50 <dons> layered over that is a state monad, carrying XState data
23:52:00 <dons> that uses a monad transformer to combine State and IO
23:52:07 <dons> giving us,  StateT XState IO
23:52:19 <dons> now, layered over that is a read-only set of values
23:52:35 <dons> using the ReaderT transformer, to combine Reader (read-only) with some other monad
23:52:49 <dons> giving us, ReaderT A  ( StateT  B   IO )
23:53:09 <dons> and 3 monads, combined, Reader, State and IO
23:53:28 <dons> which all up emulate a global mutable state, a global read-only state, and an explicit side effect layer
23:54:05 <dons> (which happens to be the type of functions running in the stateful skin of xmonad, a window manager)
23:54:28 <dons> videos,! http://programming.reddit.com/info/1tflc/comments
23:54:29 <lambdabot> Title: Haskell - Simon Peyton Jones video about Nested Data Parallelism (reddit.com)
23:54:31 <LordBrain> hehe
23:54:43 <LordBrain> thankyou, i think real world examples are very helpful
23:54:46 <Vq^> dons: so IO is the outhermost monad?
23:54:56 <LordBrain> i would have said inner most
23:55:17 <LordBrain> Reader being the outer most
23:55:25 <dons> Vq^: i'd say its the 'bottom' monad
23:55:26 <Vq^> s/outhermost/outermost/
23:55:30 <dons> in the monad stack
23:55:35 <Vq^> LordBrain: me too
23:55:52 <dons> [ Reader : State : IO ]
23:55:58 <Vq^> dons: that makes sense
23:56:09 <LordBrain> ok, so what we've been calling innermost, you call  bottom...
23:56:23 <dons> let me draw a picture.
23:58:34 <osfameron> quicksilver: fix makes a bit more sense now
23:59:02 <osfameron> quicksilver: even after your help I still got really frustrated when I came back to it.  Then I expanded it (lazily) and it became a little clearer.
23:59:24 <Vq^> the wikibook says: "ReaderT r m a is the type of values of the combined monad in which Reader is the base monad and m is the inner monad."
