00:00:46 <bos> and here's the obligatory blog link: http://www.serpentine.com/blog/2007/05/01/filemanip-an-expressive-haskell-library-for-manipulating-files/
00:00:49 <lambdabot> Title: teideal glic deisbh√©alach ª Blog Archive ª FileManip, an expressive Haskell lib ..., http://tinyurl.com/2yuayw
00:05:12 <dfranke> If a monad lifted into ErrorT returns failure, I assume that ErrorT does too?
00:08:29 <ailndx> anyone here got lambdabot or hs.plugins to run in win?
00:15:46 <dfranke> ok, this isn't good...
00:15:54 <dfranke> *Data.Transaction> runErrorT (liftIO (fail "foo") :: ErrorT IOError IO String)
00:15:54 <dfranke> *** Exception: user error (foo)
00:16:08 <dfranke> shouldn't that be returning something of type Right IOError?
00:16:32 <dfranke> i.e., shouldn't ErrorT's implementation of liftIO be smart enough to catch exceptions?
00:18:08 <dfranke> err, Left IOError rather.
00:22:33 <tsp653585> > hex "32"
00:22:34 <lambdabot>   Not in scope: `hex'
00:22:38 <tsp653585> heh
00:25:21 <tsp653585> > toHex 13
00:25:22 <lambdabot>   Not in scope: `toHex'
00:25:35 <tsp653585> heh
00:31:05 <matthew-_> wow, decent presence of #haskell on lwn.net
00:32:27 <dons> matthew-_: oh?
00:32:28 <dolio> > readHex "32"
00:32:30 <lambdabot>  [(50,"")]
00:32:56 <dolio> > showHex 13
00:32:58 <lambdabot>  <[Char] -> [Char]>
00:33:05 <dolio> > showHex 13 ""
00:33:06 <matthew-_> dons: http://lwn.net/Articles/232410/
00:33:07 <lambdabot>  "d"
00:33:07 <lambdabot> Title: LWN: The Rise of Functional Languages (Linux Journal)
00:33:26 <matthew-_> no surprise that one's fired up a few this morning...
00:34:27 <dons> hehe
00:35:09 <ailndx> dons: hs-plugins in win?
00:36:09 <dons> i don't think current head of hs-plugins works on win, and i don't have a windows machine to investigate why
00:36:49 <ailndx> http://groups.google.se/group/fa.haskell/browse_thread/thread/8f094d2b7e875703/c9c5eac103f4b2e1?lnk=raot
00:36:53 <lambdabot> Title: HS-Plugins 1.0 chokes on simple test, WinXP GHC-6.6 - fa.haskell | Google-gruppe ..., http://tinyurl.com/24cu3p
00:37:20 <ailndx> seems like its almost working for some.. but someone should really put some efford to get it to work and write a guide for it
00:37:37 <dons> needs someone with windows and an understanding of simple linker issues to dive in.
00:37:47 <ailndx> ye
00:38:35 <ailndx> since both hs-plugins and lambdabot are pretty popular its more than one person who would have use of it
00:40:43 <dons> right.
00:40:59 <dons> i just don't have the resources to maintain code for windows, unfortunately
00:41:54 <ailndx> hmm a small harddrive with win? the time it takes must be worse
01:02:13 <Adamant> I ask #haskell - is the new "Programming in Haskell" book worth purchasing?
01:03:28 <dolio> http://www.haskell.org/haskellwiki/The_Monad.Reader
01:03:30 <lambdabot> Title: The Monad.Reader - HaskellWiki
01:03:36 <dolio> The latest issue has a review of it.
01:08:23 <Adamant> thanks guys. looks like the book I have been looking for.
01:11:11 <helmut> I'm out of ideas for a problem, let me describe:
01:11:58 <helmut> I've got a function that returns a monad transformation like spam (x:xs) = do { transform x; spam xs } and spam [] = return
01:12:39 <helmut> However foo >>= spam somelist acts like foo >>= return
01:13:23 <helmut> when I change the function to spam (x:xs) = ("transform", x) : spam xs I get a list like [("transform", first), ...]
01:13:55 <helmut> manually transforming that results in the right behaviour.
01:14:35 <dcoutts> dons: I see we said almost exactly the same thing about optimising for compilvers vs interpreters
01:15:32 <dcoutts> dons: so now that I'm back and got the backlog of admin out of the way I've got time to look at stuff again
01:15:42 <dcoutts> so a bit of binary hacking I think :-)
01:15:45 <kosmikus> helmut: I don't understand it
01:15:49 <dcoutts> dons: show about you?
01:16:19 <helmut> kosmikus: well I don't either actually. I need hpaste. mom.
01:18:30 <quicksilver> helmut: spam [] = return doesn't look like a sensible type
01:18:39 <quicksilver> helmut: maybe you mean spam [] = return () ?
01:18:41 <hpaste>  helmut pasted "strange monad" at http://hpaste.org/1663
01:19:10 <helmut> quicksilver: spam doesn't return a monad, but a transformation
01:19:39 <quicksilver> helmut: no, it doesn't
01:19:44 <quicksilver> helmut: it doesn't return anything
01:19:56 <quicksilver> helmut: I see no value, and considerable confusion, in the base case being return
01:20:33 <quicksilver> you're forcing uses of it to take another parameter
01:20:39 <quicksilver> which is instantly returned, in the list is finite
01:20:42 <quicksilver> why would you want that?
01:20:54 <helmut> quicksilver: writing return () results in typing errors.
01:21:06 <quicksilver> that suggests to me that you're using it wrong
01:21:13 <quicksilver> what type do you think mergesame should have?
01:21:28 <helmut> The intended usage is:
01:21:43 <helmut> something >>= mergesame [...]
01:21:54 <helmut> so. let me deduce the type (mom)
01:22:06 <quicksilver> and what's the something got to do with mergesame?
01:22:19 <quicksilver> also, you're performing unify t1 t2 twice
01:22:24 <quicksilver> I doubt that's what you want either
01:23:16 <helmut> it needs to be done twice.
01:23:50 <quicksilver> why's that?
01:24:14 <quicksilver> apologies for all the questions but I can't solve your problem without understanding it a bit better :-)
01:24:23 <quicksilver> seeing the types of unify and mergesame would help quite a lot
01:24:25 <dons> dcoutts: hey.
01:24:29 <dcoutts> @arr!
01:24:30 <lambdabot> Arrr!
01:24:34 <helmut> > mergesame :: [Annotation Int] -> Int -> Type Int
01:24:35 <lambdabot>   Not in scope: type constructor or class `Type'
01:24:41 <dons> dcoutts: yeah, i replied, then read your response and did a double take.
01:24:44 <helmut> where Annotation Int is (Type Int, Type Int)
01:24:45 <dcoutts> :-)
01:24:54 <helmut> and instance Monad Type
01:25:03 <dcoutts> dons: singing from the same song sheet
01:25:48 <helmut> quicksilver: the questions are good as they help me in understanding what I'm doing!
01:26:21 <quicksilver> helmut: ok, well that doesn't look like a monad to me!
01:26:28 <quicksilver> helmut: or is 'Type' a monad?
01:26:35 <dons> dcoutts: check out Josef Sven*'s reply to 'More speed please!"
01:26:40 <helmut> quicksilver: 10:23 < helmut> and instance Monad Type
01:26:45 <dcoutts> dons: yes, that's what I said :-)
01:26:46 <quicksilver> ah, d'oh :)
01:27:02 <quicksilver> helmut: what kind of monad is Type?
01:27:13 <helmut> quicksilver: the monadiness is to replace SomeT n by something else.
01:27:43 <quicksilver> ok, let me ask a different question
01:27:48 <quicksilver> mergesame takes two parameters
01:27:50 <kosmikus> helmut: mergesame takes two arguments
01:27:54 <quicksilver> a list of annotations and a bare Int
01:28:01 <quicksilver> where is the second parameter in your definitions?
01:28:01 <kosmikus> helmut: in your paste, it's only one
01:28:07 <kolmodin> @yarr!
01:28:08 <lambdabot> Splice the Mainbrace!
01:28:08 <kosmikus> ok, I'm too slow ;)
01:28:14 <helmut> i.e. FuncT (SomeT 1) (SomeT 2) >>= (\n -> if n == 2 then SomeT 3 else return n) results in FuncT (SomeT 1) (SomeT 3)
01:28:56 <helmut> kosmikus: yes, but I don't need to write all arguments.
01:29:14 <quicksilver> helmut: true, but what is that second argument for and why don't you seem to use it?
01:29:30 <kosmikus> helmut: well, but it's a "do", you're returning, a "do" of type "Int -> Type Int"
01:29:31 <dolio> It seems wrong for 'unify (SomeT 1) (SomeT 0)' to be 'SomeT 0'.
01:29:37 <kosmikus> helmut: is that what you really want?
01:29:53 <helmut> kosmikus: I think so.
01:29:55 <dolio> Since then your larger example would be 'SomeT 1 >>= SomeT 0' wouldn't it?
01:30:14 <quicksilver> helmut: what kosmikus is observing is that your 'do' is not a 'do' in the Type monad. It's a 'do' in the (->) monad
01:30:22 <quicksilver> helmut: that is unlikely to be what you want
01:30:40 <quicksilver> (but maybe it is...)
01:30:43 <helmut> dolio: unify (SomeT a) (SomeT b) x = if x == a then SomeT b else return x
01:31:13 <dolio> Oh, okay, I see.
01:31:16 <helmut> why is it so highly unlikely? I don't understand that.
01:31:28 <quicksilver> helmut: do you understand what the (->) monad is?
01:31:43 <quicksilver> helmut: and what do does for that monad?
01:31:45 <helmut> I'm just starting to creatively use monads, so errors are highly probable. ;-)
01:32:00 <quicksilver> helmut: then I don't think it's your intention to use it :)
01:32:04 <helmut> quicksilver: Maybe? *g*
01:32:10 <quicksilver> for example, the (->) monad is complete side-effect free
01:32:17 <quicksilver> so your first call to unify does nothing at all
01:32:20 <kosmikus> helmut: because the way you've written it, mergesame xs is indeed the same as return
01:32:31 <quicksilver> its result is discarded and it has no side-effect
01:32:31 <mux> hello there
01:32:41 <kosmikus> the reason is what quicksilver said. there are no side-effects in (->)
01:32:43 <helmut> kosmikus: ok. then it's not what I want to do!
01:33:07 <helmut> let me give an example of what I want to do.
01:33:32 <kosmikus> helmut: just try to write mergesame using both arguments
01:34:12 <helmut> SomeT 0 >>= mergesame [(SomeT 0, SomeT 1), (SomeT 2, SomeT 3)] should result in SomeT 0 >>= unify (SomeT 0) (SomeT 1) >>= unify (SomeT 2) (SomeT 3)
01:35:16 <helmut> so how do I do that and what is the thingy I misunderstood?
01:35:26 <helmut> (probably the do notation ;-)
01:35:35 <quicksilver> there is a short way
01:35:46 <quicksilver> but maybe the long way is more instructive
01:38:16 <helmut> ahhh. I changed it and it works. now I need to understand what I did.
01:38:53 <quicksilver> mergesame ((a,b) : xs) start = start >>= unify a b >>= mergesame xs
01:38:57 <quicksilver> would be one way to write it
01:39:14 <kosmikus> helmut: you added the other parameter?
01:39:14 <helmut> (quite similar to mine)
01:39:18 <helmut> kosmikus: yes
01:39:28 <kosmikus> helmut: :)
01:39:28 <quicksilver> or mergesame ((a,b) : xs) start = do { v <- start; w <- unify a b v ; mergesame xs w }
01:39:37 <quicksilver> would be the do-notation version
01:39:56 <helmut> ahh. that explains errors in unify.
01:40:00 <helmut> :-)
01:40:15 <helmut> I'm doing something other than I want to do there, too.
01:42:20 <quicksilver> in fact, if I'm not mistaken, mergesame = foldr start (uncurry unify)
01:42:23 <helmut> so why exactly would do { unify ...; return } act like return?
01:42:38 <quicksilver> helmut: well that would depend absolutely on what monad you're in
01:42:47 <dolio> If it's 'SomeT 0 >>= mergesame [..]' then start would probably be unwrapped already.
01:43:02 <quicksilver> dolio: damn, good point
01:43:22 <quicksilver> helmut: do {foo ; bar} does foo, then bar
01:43:30 <quicksilver> helmut: but it throws away any 'return value' of foo
01:43:31 <helmut> uhm what about foldr (return start) (uncurry unify) ?
01:44:06 <quicksilver> I think I meant ((>>=) . (uncurry unify)) actually
01:44:09 <quicksilver> not very pretty at all
01:44:21 <quicksilver> helmut: so the only thing about do {foo ; bar} is if foo had side-effects
01:44:31 <quicksilver> helmut: and that depends in detail  on that actual monad being used
01:45:02 <helmut> I don't use monads with sideeffects at the moment. :-)
01:45:28 <helmut> Still you helped me in understanding monads a lot. :-)
01:45:43 <helmut> Now I need to apply this knowledge to the rest of the bugs.
01:46:20 <quicksilver> I'm not absolutely sure that your 'Type' is a Monad at all
01:46:26 <quicksilver> but I don't understand enough about how you're using it
01:46:40 <helmut> do you want to see the definition?
01:47:18 <quicksilver> sure
01:47:30 <hpaste>  helmut annotated "strange monad" with "(no title)" at http://hpaste.org/1663#a1
01:48:00 <helmut> (some day I'll learn how to use hpaste)
01:48:31 <ivanm> looks like you've worked it out... ;-)
01:48:55 <dons> dcoutts: seen the xmonad tshirts? :-)
01:49:21 <ivanm> dons: you have t-shirts? where?
01:49:38 <LeCamarade> T Shirts?
01:49:43 <dons> hehe, http://www.spreadshirt.com/shop.php?op=article&article_id=2125373#top :)
01:49:45 <lambdabot> Title: xmonad inverse:xmonad is a minimalist tiling window manager for X, written in Ha ..., http://tinyurl.com/2ytgo4
01:49:45 <dcoutts> dons: hah! no I havn't
01:50:05 <helmut> (unify also needs another argument ...)
01:50:08 * LeCamarade is sad he prefers flashier things ... but not KDE.
01:50:14 <dcoutts> dons: very nice :-)
01:50:19 <dons> nice eh? :)
01:50:37 <ivanm> very
01:50:45 <ivanm> do you know how much it costs to ship them down under?
01:51:00 * earthy is almost tempted to get that t-shirt just for the cool logo
01:51:05 <dons> US9.99 I think, I ordered one today
01:51:13 <earthy> don't like the URL on the back though. :)
01:51:19 <dons> heh
01:51:29 <earthy> plus, I just plonked down some EUR 370 on clothes last weekend
01:51:53 <ivanm> earthy: what's wrong with it?
01:52:09 <earthy> it's a URL. on the back of a shirt. :)
01:52:38 <ivanm> ahh, OK
01:52:52 <ivanm> dons: is there a reason the black ones don't say xmonad on the front?
01:53:07 <ivanm> and the text on the back of the whipped one isn't centred :s
01:53:09 <earthy> don't they say Xbind? :)
01:53:11 <igli> man what is the >>= operator? (just a one liner, i'll go and look it up ;)
01:53:17 <LeCamarade> But that logo is insanely beautiful.
01:53:19 <earthy> igli: bind. :)
01:53:23 <dons> :t (>>=)
01:53:23 <igli> ah ty
01:53:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:53:52 <earthy> I'd guess the kde version of xmonad should be called kpowershell, no? :)
01:54:14 <dons> hah
01:54:19 <ivanm> heh
01:54:29 <ivanm> so what would the gnome version be called?
01:54:38 <ivanm> gmonad?
01:54:43 <ivanm> gnomad?
01:54:44 <dons> scary
01:54:47 <LeCamarade> gmonad.
01:54:48 <earthy> gonad, what else. :)
01:54:54 <ivanm> heh
01:55:02 <LeCamarade> g{}
01:55:10 <LeCamarade> earthy: :oD
01:55:12 * ivanm though gonad was the FLOSS version of MS's new shell...
01:55:24 <LeCamarade> @go gonad
01:55:24 <earthy> is it? :)
01:55:26 <lambdabot> http://en.wikipedia.org/wiki/Gonad
01:55:27 <lambdabot> Title: Gonad - Wikipedia, the free encyclopedia
01:55:36 <LeCamarade> @go gonad shell
01:55:44 <lambdabot> http://www.springerlink.com/index/W6G32033192H85QL.pdf
01:55:50 <Adamant> @go go gadget gonads
01:55:52 <lambdabot> http://gizmodo.com/gadgets/gadgets/cat-paw-almost-useless-makes-you-do-weird-things-251686.php
01:55:53 <lambdabot> Title: Gadgets: Cat Paw: Almost Useless, Makes You Do Weird Things - Gizmodo
01:56:07 * LeCamarade it can be rather hard to get @go right, when you have a word like that.
01:56:09 <helmut> Could someone write \x -> unify t11 t21 x >>= unify t12 t22 with do-notion for me again? I know I don't fully understand it yet.
01:56:34 <earthy> helmut: that looks strange to my eyes
01:56:35 <ivanm> earthy: that was the joke going around when MS's shell was called monad...
01:56:43 <helmut> earthy: why?
01:56:44 <earthy> ivanm: I see. :)
01:56:54 <quicksilver> helmut: heading into a meeting, I'll look at your monad later
01:57:05 <helmut> quicksilver: Thanks for your help!
01:57:24 <earthy> because  do { x <- unify t11 t21; unify t12 t22 x }   would be   unify t11 t21 >>= \x -> unify t12 t22 x
01:58:03 <earthy> so what you wrote would be    do { \x -> unify t11 t21 x ;  unfiy t12 t22 }
01:58:08 <dolio> @do \x -> unify t11 t21 x >>= unify t12 t22
01:58:09 <lambdabot> \x -> unify t11 t21 x >>= unify t12 t22 not available
01:58:26 <earthy> (barring typos)
01:58:27 <dolio> @redo \x -> unify t11 t21 x >>= unify t12 t22
01:58:28 <lambdabot> \ x -> do { a <- unify t11 t21 x; unify t12 t22 a}
01:58:45 <earthy> !autolart
01:58:45 <earthy> duh
01:58:51 <earthy> my bad.
01:58:56 <helmut> (when I wrote that, I got a type error)
01:59:28 * earthy makes some more tea
01:59:35 <helmut> oh. no. there is a subtle difference. :-)
01:59:39 <helmut> thanks!
02:02:04 <chowmeined> hello
02:02:05 <igli> simple x y z = x * (y + z) has type simple :: Int -> Int -> Int whereas sign x \n | x > 0 = "+" \n | x < 0 = "-" has type sign :: Int -> String
02:02:14 <chowmeined> any suggestions for a C programming learning haskell?
02:02:18 <igli> i am confused
02:02:38 <igli> http://www.haskell.org/~pairwise/intro/intro.html chowmeined
02:02:40 <lambdabot> Title: Haskell for C Programmers
02:03:00 <helmut> wow. it types my larger example correctly now! :-)
02:03:00 <chowmeined> i am reading that
02:03:26 <igli> in the first decl simple takes 3 ints?
02:04:08 <igli> does anyone understand why i am confused?
02:04:36 <igli> um it doesn't seem to have a return type to me
02:04:53 <dolio> simple should be Int -> Int -> Int -> Int, clearly.
02:05:01 <igli> oic
02:05:34 <dolio> sign loks weird. Is the \n a newline?
02:05:39 <igli> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html linked from C programmers tutorial
02:05:40 <lambdabot> Title: Tour of the Haskell Syntax
02:05:47 <igli> yeah sorry
02:05:53 <vincenz> Hello
02:05:54 <LeCamarade> igli: I think your layout was broken in the IRC client.
02:05:57 <helmut> err. wait. there're still SomeTs...
02:06:04 <dolio> Ah, okay. Then I think Int -> String is the correct type.
02:06:05 <LeCamarade> igli: Try pasting.
02:06:06 <igli> the \n was put in by me ;)
02:06:08 <LeCamarade> @paste
02:06:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:06:32 <igli> sign x
02:06:32 <igli>           | x > 0 = "+"
02:06:32 <igli>           | x < 0 = "-"
02:06:49 <igli> i appreciate it has a hole for x=0
02:07:20 <dolio> @type let sign x | x > 0 = "+" | x < 0 = "-" in sign
02:07:21 <igli> it's from the syntax tour; dolio appears to be saying the simple type declaration is incorrect?
02:07:25 <lambdabot> forall a. (Num a, Ord a) => a -> [Char]
02:07:49 <dolio> @type simple x y z = x * (y + z)
02:07:52 <lambdabot> parse error on input `='
02:08:01 <dolio> @type let simple x y z = x * (y + z) in simple
02:08:04 <lambdabot> forall a. (Num a) => a -> a -> a -> a
02:08:21 <igli> ah thank you
02:08:24 <dolio> Of course, those 'a's are specialized to Int in whatever you're reading.
02:08:30 <igli> yes
02:09:09 <igli> the mix of -> for a separator and a ret type is confusing
02:09:37 <igli> is it something to do with fn composition?
02:10:08 <igli> nm at least i know why the tutorial was confusing :)
02:11:28 <MyCatVerbs> Fastastic new things I had learned, number one:
02:11:30 <mdmkolbe-work> igli: do you know about currying yet?  (if you do, then that is the answer to your question)
02:11:50 <igli> heh no, i'll get there tho; thanks for the hint mdmkolbe-work :)
02:11:57 <mdmkolbe-work> @type let f a b c in f
02:11:59 <lambdabot> parse error on input `in'
02:12:01 <MyCatVerbs> If you deliberately circumvent your language's typing system, it will automagically cease to help you with any problems.
02:12:15 <igli> makes sense
02:12:23 <mdmkolbe-work> @type let f a b c = a+b+c in f
02:12:26 <lambdabot> forall a. (Num a) => a -> a -> a -> a
02:12:32 <mdmkolbe-work> @type let f a b c = a+b+c in f 1
02:12:35 <lambdabot> forall t. (Num t) => t -> t -> t
02:13:10 <LeCamarade> igli: Check this:
02:13:13 <igli> so f 1 is a fn on two nums
02:13:30 <mdmkolbe-work> igli: yep, in haskell you can pass only the first few arguments to a function, you don't have to pass them all (like in the examples I just posted)
02:13:44 <igli> hmm
02:13:45 <LeCamarade> When you have a func that takes two args, and you give it one, it won't complain. It will return a function that takes the remaining. Watch.
02:13:54 <igli> k
02:14:04 <mdmkolbe-work> igli: so another way to think of f is that it is a function from a num to a function on two nums (i.e. Int -> (Int -> Int -> Int))
02:14:08 <opqdonut> > let inc = map (+1) in inc [1,2,3]
02:14:10 <lambdabot>  [2,3,4]
02:14:14 <LeCamarade> > let add x y = x + y; add3 = add 3 in add3 4
02:14:16 <lambdabot>  7
02:14:26 <LeCamarade> > let add x y = x + y; add3 = add 3 in add3 4
02:14:28 <lambdabot>  7
02:15:01 <igli> > let add x y = x + y; add5 = add 5 in add5 2
02:15:02 <lambdabot>  7
02:15:14 <igli> i like haskell :)
02:15:18 <mdmkolbe-work> igli: the (->) syntax (technically a type constructor but that doesn't matter) is right associative so a->b ->c -> d is the same as a -> (b -> (c -> d))
02:15:25 <LeCamarade> igli: See? So, while the type of add is Int -> Int -> Int, the type of add3 (which, in fact, is just add with one arg given) is Int -> Int. Because it is a function that takes one args (Int) and returns and Int.
02:15:40 <igli> heh this is cool
02:15:54 <LeCamarade> That's how you can do sexy, sexy stuff like ...
02:16:20 <LeCamarade> > let sum = foldr (+) [] in sum [1, 2]
02:16:21 <lambdabot>   add an instance declaration for (Num [a])
02:16:22 <lambdabot>     In the expression: 2
02:16:49 * LeCamarade merde, as the French say.
02:17:19 <mdmkolbe-work> igli: btw, how good is that tutorial? (and how far have you gotten)  I remember when I was learning Haskell it was *very* hard to find a good way to learn it so I'm always on the lookout for good tutorial to point my friends at.
02:17:21 <bluestorm_> > let sum = foldl ( + ) 0
02:17:22 <lambdabot>  Parse error
02:17:26 <bluestorm_> > let sum = foldl (+) 0
02:17:27 <lambdabot>  Parse error
02:17:30 <bluestorm_> grr :p
02:17:37 <bluestorm_> > let sum = foldl (+) 0 in sum [1, 2]
02:17:39 <lambdabot>  3
02:17:42 <igli> heh
02:17:54 <LeCamarade> Anyway, so maybe your problem is coming from the fact that the tutorial uses that feature, called currying. (Although most people/bots in here will say `eta reduction'.)
02:18:26 <LeCamarade> mdmkolbe-work: True, True, True.
02:19:00 <igli> mdmkolbe-work: it's cool as is the C one. The C one is great as it introduces stuff gently but quickly to give you an overview. the syntax is useful for someone who knows how to code already; i'm writing to the author to ask him to correct the type def'n of simple.
02:19:17 <LeCamarade> mdmkolbe-work: It is probably why everyone wants to write one. Especially on monads. For one, I think it has to be very interactive. It's why I try to make #haskell a nice place to learn the basics.
02:19:38 <igli> and it's appreciated :)
02:20:21 <mdmkolbe-work> At the time the best/only thing I could learn Haskell from was the book 'The Haskell School of Expression', but that's not online so it might be a little hard to find
02:21:01 <LeCamarade> mdmkolbe-work: I never use a single tut, usually, but I loved the YAHT and Wikibooks.
02:21:18 <mdmkolbe-work> YAHT?
02:21:32 <LeCamarade> @go yet another haskell tutorial
02:21:35 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
02:21:44 <LeCamarade> :oD
02:22:10 <Baughn> @hoogle Maybe a -> a -> a
02:22:12 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
02:22:12 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
02:23:25 <LeCamarade> ivanm: You're switching nicks like mad.
02:23:45 <ivanm> LeCamarade, I got ghosted, then couldn't work out how to kill the ghost :s
02:24:03 <ivanm> but its all good now, till the next time I get ghosted :p
02:24:32 <LeCamarade> :oD
02:38:42 <helmut> Hum. What can I do about types like foo :: x = x -> x? expanding this will result in an infinity type ...
02:39:05 <Botje_> they make the typechecker go into an infinite loop
02:39:10 <Botje_> which is a not-nice property to have
02:39:56 <helmut> well my typechecker somehow ships around this and leaves a SomeType.
02:40:19 <helmut> Everything else is expanded.
02:40:46 <njd> @users
02:40:47 <lambdabot> Maximum users seen in #haskell: 336, currently: 312 (92.9%), active: 43 (13.8%)
02:40:55 <Botje_> no idea then
02:41:05 <Botje_> is that infinite type wanted? or just an accident
02:41:08 <helmut> maybe I can just compile that with mixed dynamic and static typing.
02:41:32 <helmut> val iter' = fun iter' f n => if n == 0 then id else compose f (iter' iter' f (n - 1))
02:42:10 <helmut> so iter is of type a = a -> (Nat -> Nat) -> Nat -> Nat (uhm, Nat is the same as Integer ;-)
02:42:52 <helmut> I count this as intended (it's actually the only way to do recursion yet ;-)
02:52:04 <LeCamarade> @where yhc
02:52:04 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
02:54:03 <LeCamarade> See? Now I want to build Yhc for NetBSD, and I can't get the blerry source, because there is no darcs on that machine. It's a distant host. X-(
02:54:27 <LeCamarade> Or, maybe, which is the easiest way to build GHC on NetBSD?
02:54:51 <helmut> LeCamarade: 1) there are some statically linked binaries 2) wget -m should also work.
02:55:07 * LeCamarade is hoping for as close to `./configure; make; make test; make install;' as possible.
02:55:28 <LeCamarade> helmut: wget will work?
02:56:07 <helmut> LeCamarade: actually a darcs repository *is* a working copy.
02:56:22 <helmut> LeCamarade: so copying it will result in another working copy.
02:57:48 <LeCamarade> :oD. Not that I am a darcs guy too much. It's still CVS at work. :o(
03:12:29 <matthew-_> I do love how you can write code, release it to the world at large, and then be criticised for your choice of license.
03:13:04 <ivanm> why, what complaint do you have in particular?
03:13:17 <ivanm> s/complaint/example
03:13:55 <LeCamarade> ivanm: Syntax error:
03:14:00 <LeCamarade> ivanm: Try:
03:14:12 <dons> matthew-_: hehe.
03:14:26 <matthew-_> ivanm: post on -cafe
03:14:26 <LeCamarade> ivanm: s/complaint/example/
03:14:27 <LeCamarade> :oD
03:14:33 <ivanm> LeCamarade, wtf?
03:15:00 <LeCamarade> ivanm: You've been away from your vi too long. Not important. Forget it ever happened.
03:15:01 <ivanm> matthew-_: recently? I can't recall what you're mentioning, unless its new (/me uses digest)
03:15:18 <ivanm> LeCamarade, I've _never_ used vi!!! :D
03:16:02 <LeCamarade> ivanm: Oh, okay. Stick to the C++ of editors.
03:16:19 <ivanm> heh
03:16:24 <matthew-_> ivanm: last message digest: Message-ID: <005601c78c98$2b5c85f0$22418351@cr3lt>
03:16:29 <quicksilver> knowing vi or not knowing vi have nothing to do with the s// syntax
03:16:30 <nornagon> ivanm: you've been away from your sed too long
03:16:37 <quicksilver> the s// syntax is used in many many programs
03:16:50 <quicksilver> and is widely understood in technical IRC channels :P
03:16:55 <ivanm> nornagon, never used sed... just picked up that s/foo/bar from other people using it
03:16:57 <LeCamarade> Text.RegEx
03:17:01 <LeCamarade> :oD
03:17:36 <ivanm> matthew-_, ahh, I get you now
03:17:56 <ivanm> this is FileManip?
03:18:59 <matthew-_> yeah
03:20:29 <matthew-_> just seemed odd to me, esp from the haskell community :-)
03:23:52 <quicksilver> yay, now we can right really scary IO oneliners!
03:24:00 <quicksilver> find always >>= mapM remove
03:28:12 <matthew-_> quicksilver: only if that's depth first
03:29:24 <quicksilver> matthew-_: I was assuming remove was a NOP on non-empty directories but it would at least delete all the contents
03:30:06 <osfameron> is there an RSS feed for the Monad Reader ?
03:30:24 <matthew-_> ahh, ok. I was translating to "find | xargs rm", which, as find finds the directory before the contents, would not remove the directory
03:30:51 <Baughn> ÁßÅ„ÅÆ„Éõ„Éê„Éº„ÇØ„É©„Éï„Éà „ÅØÈ∞ª„Åå‰∏ÄÊùØ„Åß„Åô„ÄÇ
03:31:05 <Baughn> ..er, wrong channel. Sorry.
03:33:41 <kolmodin> Baughn: what language is that? your chars did not get displayed properly here
03:34:06 <norpan> "my hovercraft is full of eels"?
03:34:10 <Baughn> kolmodin: Japanese. It says.. yeah, that.
03:34:43 <kolmodin> Baughn: ok, cool. I've found it hard to display utf8 properly
03:35:47 <kolmodin> connecting with putty via ssh, then ssh again to my screen, then irssi. I haven't managed to get UTF8 work properly throughout the whole chain
03:36:19 <Baughn> ssh doesn't (shouldn't) affect the data, transmitting it verbatim. irssi doesn't. I think. putty definitely does.
03:36:43 <kolmodin> yeah. I got it somewhat working without putty
03:37:01 <kolmodin> and with putty nothing worked. so I had to turn utf8 off, using latin1 now
03:37:06 <kolmodin> :(
03:37:25 <kolmodin> I'll invest more time in it some day :)
03:37:41 <Baughn> You could maybe use cygwin+ssh
03:38:17 <kolmodin> hmm. yeah. except with cygwin I get these funny looking terminals, like cmd.exe. I prefer putty over them
03:38:52 <Baughn> I'd gloat about using linux, but that would be /mean/
03:39:15 <kolmodin> it seems to depend on the setting of the terminal, the screen, irrsi and also putty
03:39:37 <kolmodin> haha :D I am a linux user, in my spare time. at work I don't have that luxury
03:40:25 <kolmodin> unlesss... hmm
03:41:42 <dons> so did everyone get their HCAR submissions in?!
03:41:54 <Syzygy-> And at that, I'd point out that I still don't get transparency and utf8 working simultaneously onmy linux box.
03:42:21 <kolmodin> Syzygy-: yeah, utf8 sure doesn't come for free
03:42:27 <Baughn> I've never seen a single good use for transparency, so that's okay. *shrug*
03:42:49 <kolmodin> Baughn: :) it can look nice, but that's about it
03:42:52 <Syzygy-> Baughn: I like it for the bling. :P And to give some sort of vairation to the scrolling text windows that occupy most of my time.
03:42:54 <kolmodin> "nice"
03:43:22 <dons> hah, my brain is warped. "Silverlight Has A Mini-CLR, Can Be Programmed With Python" and I though , wow, Microsoft shifting a Common Lisp Runtime, that's innovative. and python targets it? cool! should have a go with haskell.
03:44:15 <dons> May Haskell Communities Report due super-soon, http://article.gmane.org/gmane.comp.lang.haskell.general/15161
03:44:18 <lambdabot> Title: Gmane -- Mail To News And Back Again
03:44:26 <dons> so if you've written a library, or a tool, better send kosmikus a note.
03:44:46 <kolmodin> dons: I sent kosmikus the text I showed you
03:44:58 <dons> great.
03:45:19 <kolmodin> I should probably update the hinotify entry too
03:45:33 <kolmodin> and perhaps announce the pure haskell dbus client
03:45:41 <dons> dcoutts has made some nice improvements to the binary bottom layer,, I don't know if you've seen the numbers?
03:45:47 <dons> kolmodin: oh, that sounds cool
03:45:51 <kolmodin> yeah, I have
03:46:02 <kolmodin> it was about 2.5x to 4x faster
03:46:10 <dons> yeah.
03:46:20 <dons> rewrite rules on appicative functors actually work
03:46:26 <dons> much nicer than on monad binds
03:46:28 <kolmodin> the dbus lib isn't finished yet though, but it has a nice ground layed out
03:46:37 <dons> so , scrap your bounds checking :-)
03:46:44 <kolmodin> haha, yeah :)
03:47:12 <kolmodin> that's a nice experience. that could go into the paper perhaps
03:47:25 <kolmodin> or at least into a blog entry or something
03:47:42 <dons> mm. we've got about a month now to the deadline, I think
03:47:49 <dons> we better try to finish up the code this week or next.
03:47:54 <dons> dcoutts: ^^
03:48:07 <kolmodin> I've got tons to do the upcomming month :/
03:48:29 <dons> well, i think we'll be right with the code side, and then we'll just have to work out the division of writing
03:48:31 <kolmodin> I'm afraid I can't help very much in 30 days or so
03:48:35 <dons> ok.
03:48:42 <dons> that's fine. we're all overworked anyway :-)
03:49:00 <kolmodin> :)
03:51:17 <jmg_> hi
03:52:07 <jmg_> i get compiler errors when compiling hs-plugins on mac-osx. is osx supported by hs-plugins?
03:52:35 <jmg_> and i am using ghc-6.6
03:56:39 <pejo> dons, submitting things to haskell workshop?
03:58:57 <therp> coding haskell makes stupid (wrt to C coding)
03:59:15 <therp> I'm simply unable to imagine this imperative weird spagetti code flow anymore.
03:59:58 <dcoutts> dons: yup!
04:00:05 <dcoutts> kolmodin: how's the thesis going? :-)
04:08:51 <Saizan_> therp: heh, i'm scared by for loops now!
04:09:49 <fax> hello
04:10:08 <therp> saizan: for-loops are still ok, but my fear of them grows exponentially by adding if conditionals inside of them probably even ones that modify loop variables.
04:10:36 <fax> What is the best piece of haskell code ever written?
04:10:54 <therp> y f = f (y f)
04:11:11 <fax> you can write y like that :O
04:11:16 <fax> er cant* ?
04:11:28 <meester> you can
04:11:36 <fax> hm I thought you could even write U in haskell.
04:11:39 <Saizan_> let y f = f (y f) in y (1:)
04:11:42 <Saizan_> > let y f = f (y f) in y (1:)
04:11:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:11:57 <fax> hm
04:12:07 <fax> thats pretty cool
04:13:06 <Saizan_> ?src fix
04:13:07 <lambdabot> fix f = let x = f x in x
04:16:08 <fax> its really the best though?
04:16:16 <fax> I was hoping for somthing more substantial
04:16:27 <fax> like a few pages maybe
04:19:44 <Saizan> fax: yours is not an easy question :)
04:20:10 <kosmikus> dons: thanks for the advertisement. thanks for your updates as well. your mail got classified as spam, but I found it ;)
04:20:15 <Saizan> the standard libraries have good code i think
04:27:51 <fasta> I installed haskell-mode 2.3. When I do C-c C-t I get "Symbol's function definition is void: inferior-haskell-type".
04:28:35 <fasta> Anybody else who had this problem?
04:28:50 <LeCamarade> > let hex = "09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0" in hex
04:28:52 <lambdabot>  "09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0"
04:28:56 <LeCamarade> :oD
04:28:57 <Botje_> LeCamarade++
04:29:46 <kolmodin> dcoutts: so much to do, so little time
04:29:54 <dcoutts> kolmodin: aye
04:30:00 <opqdonut> LeCamarade++
04:30:01 <kolmodin> I haven't worked this weekend, so I'm kinda stressing out
04:30:45 <kolmodin> weekend/holiday
04:30:45 <kolmodin> I ran into this http://www.tiobe.com/tiobe_index/index.htm
04:30:45 <kolmodin> which is a depressing sight
04:30:47 <kolmodin> we're number 38
04:31:02 <lambdabot> Title: TIOBE Programming Community Index
04:31:12 <kolmodin> at least we're in the top 50
04:31:55 <fasta> Below IDL :)
04:32:06 <fasta> Cannot go much lower, now can we?
04:32:10 <quicksilver> fasta: you haven't loaded or autoloaded inferior haskell
04:32:31 <fasta> quicksilver: the documentation didn't say I had to. Or I missed it.
04:32:43 <quicksilver> fasta: (load-library 'inf-haskell)
04:32:52 <quicksilver> fasta: the docs could be wrong or incomplete, I wouldn't be surprised
04:32:58 <quicksilver> I have this in my .emacs:
04:33:08 <quicksilver> (autoload 'run-haskell "inf-haskell" "Run interactive haskell interpreter." t)
04:33:13 <kolmodin> and, I could not pick haskell for my project just because it's not very common. that doesn't make it more common
04:33:17 <kolmodin> it's a catch 22
04:34:20 <matthew-_> what's the most fundamental feature of haskell that referential transparency gets us?
04:34:37 <fasta> quicksilver: the autoload form return nil here
04:35:37 <fasta> quicksilver: and your load-library first argument cannot be a symbol
04:35:47 <fasta> quicksilver: (at least not in my version of Emacs)
04:38:14 <fasta> quicksilver: hmm, the C-c C-i appears to be heavily broken.
04:38:40 <quicksilver> fasta: yes, 'inf-haskell was a typo for "inf-haskell"
04:38:44 <fasta> quicksilver: (it ignores the directories in the path)
04:38:47 <quicksilver> fasta: I've not actually used 2.3, I'm afraid
04:38:57 <quicksilver> fasta: I only replied because I could see what your error was :)
04:38:59 <fasta> quicksilver: Ok, never mind. Thanks, anyway
04:43:21 <Saizan> fasta: did you C-c C-l before C-c C-t?
04:43:27 <fasta> Saizan: yes
04:44:09 <Saizan> the buffer is called *ghci* or *haskell*?
04:44:28 <fasta> Saizan: ghci
04:45:23 <Saizan> i think that's the problem, inf-haskell uses *haskell*, *ghci* is used by haskell-ghci that should be replaced by inf-haskell
04:45:41 <Saizan> do you have (require 'inf-haskell) in .emacs?
04:45:58 <fasta> Saizan: I have load-library "inf-haskell, yes
04:46:15 <fasta> (load-library "inf-haskell")
04:46:35 <fasta> (I didn't remove the previous configuration, so there might be some conflict)
04:47:02 <fasta> (but haskell-mode 2.1 is not in my load path anymore)
04:47:38 <petekaz> @seen dons
04:47:39 <lambdabot> dons is in #xmonad, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dons speak 58m 57s ago.
04:49:11 <fax> hm
04:49:20 <fax> what about the almost best haskell program?
04:49:24 <fax> :D
04:53:19 <petekaz> Has anyone read dons' blog article on shell programming?  I have a newbie question to aske.
04:53:33 <pjd> quick, silly question:  what's the easiest way to return every second element of a list?
04:54:01 <mdmkolbe-work> petekaz: link?
04:54:08 <LeCamarade> pjd : You mean like [2, 4] for [1, 2, 3, 4]?
04:54:20 <mdmkolbe-work> pjd: head . tail
04:54:24 <pjd> similar to [::2] indexing in Python
04:54:35 <mdmkolbe-work> pjd: sorry, I miss read
04:54:36 <petekaz> mdmkolbe-work: http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10
04:54:37 <lambdabot> Title: Haskell hacking
04:55:08 <pjd> LeCamarade: yeah
04:56:26 <pjd> there's intersperse, which is almost the inverse
04:56:41 <LeCamarade> > let every_second x = if length x < 2 then [] else (head . tail $ x) : every_second . drop 2 $ x in every_second [1 .. 10]
04:56:42 <lambdabot>  Couldn't match expected type `[a]'
04:56:51 * LeCamarade merde.
04:56:57 * LeCamarade goes off to GHCi.
04:57:08 <mdmkolbe-work> @pl second (x:_:xs) = x:second xs
04:57:10 <lambdabot> second = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . const) .) . flip ((.) . (:)))
04:57:25 <pjd> heh
04:58:01 <MyCatVerbs> mdmkolbe-work: what the Hell is that, an automatic translation to points-free style!?
04:58:08 <mux> yes
04:58:09 <pjd> MyCatVerbs: yep
04:58:18 <mdmkolbe-work> [x | (x,i) <- zip x [1..] if i `mod` 2 == 0]
04:58:18 <mux> it is often better at it though :)
04:58:23 <MyCatVerbs> Holy Hell that is cool.
04:58:38 <MyCatVerbs> mux: well, not all code's really amenable to it, heh.
04:58:58 <LeCamarade> mdmkolbe-work: You don't worry about being passed [] ... :oD
04:59:10 <mux> MyCatVerbs: sure, but in some cases there are better ways to do it than what LB suggests :-)
04:59:39 <psykotic> > let { f (x:_:xs) = Just (x,xs) ; f _ = Nothing } in unfoldr f [1..10]
04:59:41 <lambdabot>  [1,3,5,7,9]
05:00:01 <pjd> hah, very nice
05:00:47 <Saizan> > let { f (x:_:xs) = Just (x,xs) ; f _ = Nothing } in unfoldr f [1..9]
05:00:49 <lambdabot>  [1,3,5,7]
05:01:02 <mux> > map odd [1..9]
05:01:04 <lambdabot>  [True,False,True,False,True,False,True,False,True]
05:01:38 <psykotic> Saizan, good point
05:02:14 <LeCamarade> petekaz: I read it back then.
05:02:16 <pjd> the x:_:xs pattern is the trickiness
05:02:22 <mdmkolbe-work> @type filter
05:02:25 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:02:59 <pjd> i tried a mutual recursion, but it's still somewhat verbose
05:03:01 <mdmkolbe-work> > map (odd . snd) $ zip [1..] [20..30]
05:03:03 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False]
05:03:08 <psykotic> > let { f (x:_:xs) = Just (x,xs) ; f [x] = Just (x,[]) ; f _ = Nothing } in unfoldr f [1..9]
05:03:09 <lambdabot>  [1,3,5,7,9]
05:03:10 <psykotic> but that's nastier
05:03:27 <mdmkolbe-work> > map fst $ filter (odd . snd) $ zip [1..] [20..30]
05:03:29 <lambdabot>  [2,4,6,8,10]
05:03:48 <mdmkolbe-work> > map snd $ filter (odd . fst) $ zip [1..] [20..30]
05:03:49 <lambdabot>  [20,22,24,26,28,30]
05:04:00 <pjd> it would be nice to have an implementation of Python slicing semantics
05:04:12 <LeCamarade> mdmkolbe-work: Neat. I was thinking of a similar thing ... :oD
05:04:36 <mdmkolbe-work> LeCamarade: it's a basterdization of the Swartzian transform
05:05:25 <petekaz> LeCamarade: (I'm a newbie so keep that in mind)  What is the point of using ErrorT?  If Shell is an instance of MonadError and defines throwError, then I don't see the point of using ErrorT.
05:05:54 <pjd> @pl [x | (x,i) <- zip xs [1..] if odd i ]
05:05:55 <LeCamarade> mdmkolbe-work: But I generally keep away from such stuff when not at #haskell. In many ways I think #haskell  is dangerous. Too many Olegs. :oD
05:05:55 <lambdabot> (line 1, column 1):
05:05:55 <lambdabot> unexpected reserved word "if"
05:05:55 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
05:06:32 <pjd> @pl [x | (x,i) <- zip xs [1..], odd i ]
05:06:32 <lambdabot> [x | (x, i) <- zip xs [1..], odd i]
05:06:38 <mdmkolbe-work> LeCamarade: #perl is the other place you could do such a thing (Randel Swarts was inventor of the iriginal transform)
05:07:03 <mdmkolbe-work> > [x | (x,i) <- zip [20..30] [1..], odd i ]
05:07:04 <lambdabot>  [20,22,24,26,28,30]
05:07:31 <bluestorm_> hm
05:07:52 <mdmkolbe-work> > [x | (x, i) <- ([20..30], [1..]), odd i]
05:07:53 <lambdabot>  Couldn't match expected type `[t]' against inferred type `(a, b)'
05:07:55 <bluestorm_> i'm trying to read http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01
05:07:56 <lambdabot> Title: Haskell hacking
05:08:07 <LeCamarade> petekaz: Hmm ... lemme go read it again/
05:08:24 <bluestorm_> it seems i have a different way to write "peek", but i'm not sure it's the seame
05:08:31 <petekaz> I have to shoot off to work, be back in an hour.
05:09:15 <hpaste>  bluestorm pasted "another peek ?" at http://hpaste.org/1665
05:09:20 <psykotic> pjd, i think this general version should work
05:09:22 <psykotic> > let { n = 2 ; f (x:xs) = Just (x, drop (n-1) xs) ; f _ = Nothing } in unfoldr f [1..10]
05:09:23 <lambdabot>  [1,3,5,7,9]
05:09:28 <psykotic> > let { n = 3 ; f (x:xs) = Just (x, drop (n-1) xs) ; f _ = Nothing } in unfoldr f [1..10]
05:09:30 <lambdabot>  [1,4,7,10]
05:09:58 <Saizan> > unfoldr (\xs -> do { (a:as,b) <- return $ splitAt 2 xs; return (a,b); }) [1..11]
05:10:00 <lambdabot>  [1,3,5,7,9,11]
05:10:48 <pjd> psykotic: give me second while i calibrate my unfoldr neuron
05:11:58 <mdmkolbe-work> ?src splitAt
05:11:59 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
05:12:27 <psykotic> ?src unfoldr
05:12:28 <lambdabot> unfoldr f b  = case f b of
05:12:28 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
05:12:28 <lambdabot>    Nothing        -> []
05:12:48 <pjd> right
05:14:21 <mdmkolbe-work> petekaz: Shell is implemented in terms of ErrorT
05:15:41 <pjd> cool, so then you'd just need a bit of taking and dropping, and the negative argument handling
05:16:48 <Saizan> (splitAt is implemented a little better than (take n xs,drop n xs) btw..)
05:17:30 <psykotic> pjd: btw, implementing negative arguments in a nice lazy way is kind of fun. you don't want to compute length n first, you want to always look n elements ahead and check when you hit the end with the furthest-away lookahead element... if that makes sense.
05:18:20 <psykotic> pjd: that way works even with infinite lists
05:18:25 <pjd> psykotic: hmm, for what kind of use?
05:18:39 <psykotic> pjd: the problem is that computing length forces you to evaluate the spine of the list.
05:18:44 <mdmkolbe-work> What is a negative argument?
05:18:46 <pjd> the slicing i have in mind depends on it pretty hardly, anyway
05:19:16 <psykotic> mdmkolbe-work, in some scripting languages it means "index from the end". so if you do array[0:-1] it means the subarray consisting of everything except the last element of array.
05:19:18 <pjd> (that is, it can't really be defined for infinite lists)
05:19:44 <psykotic> pjd: well, the trick is to reinterpret a -n bound as "everything except the last n", which in the infinite list is vacuous
05:19:52 <psykotic> *infinite list case
05:19:57 <pjd> true
05:20:15 <pjd> i was thinking more of negative steps :)
05:20:39 <psykotic> consider the -1 case. you can basically keep track of a "lookahead" tail and stop producing more elements when you hit the end of the list.
05:20:40 <psykotic> ah
05:21:17 <mdmkolbe-work> > let x = (1, x, 2) in x
05:21:25 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t1, t, t2)
05:21:25 <lambdabot>       ...
05:22:20 <pjd> negative lower bounds arguments also don't make much sense for infinite lists
05:22:22 <mdmkolbe-work> a deque could be infinite but still have a meaningfull slice [n:-n]
05:23:03 <pjd> s/arguments //
05:23:33 <LeCamarade> @quote hex
05:23:33 <lambdabot> hex says: 09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0
05:23:57 <psykotic> mdmkolbe-work, i think you have to define a recursive type first, for what you wrote to work. type T a = C a (T a) a or something like that.
05:31:56 <LeCamarade> Three things I learnt from Haskell: Laziness should be the default evaluation strategy. IO is bad, even if unavoidable. Monads exist.
05:32:57 <dcoutts> LeCamarade: sounds right :-)
05:34:23 <chowmeined> hmm
05:34:26 <chowmeined> so complicated
05:34:59 <LeCamarade> dcoutts: For the first time, I actually saw a use for Ocaml's lazy eval thing. And now, it feels so wrong, because it is not default.
05:35:14 <pjd> another random question: what's the impact of main's type, if IO foo instead of IO ()?
05:35:22 <pjd> "if it's", even
05:35:43 <mdmkolbe|work> IIRC, main must have type IO ()
05:35:46 <Saizan> foo is discarded
05:36:13 <Saizan> main is IO a
05:36:26 <pjd> Saizan: ok, thanks
05:36:50 * mdmkolbe|work just checked and Saizan is correct
05:37:06 <norpan> why is main IO a then
05:37:59 <Saizan> to save you a >> return () in some cases, i think
05:38:22 <mdmkolbe|work> norpan: probably so you don't have to do "main = do { some func; other func; return () }" just b/c 'other' is e.g. IO Int
05:38:52 <norpan> actually, the report says it must be of type IO t for some type t
05:39:07 <norpan> so it can't be IO a, arguably
05:40:32 <pejo> LeCamarade, is the majority of the things you write dependent on lazy evaluation?
05:40:56 <Saizan> ah well yes, "for some type a"
05:41:38 <LeCamarade> pejo: Everything I write is dependent on lazy evaluation.
05:42:04 <norpan> LeCamarade: you don't write it until somebody tries to read it? :)
05:42:17 <LeCamarade> Every once in a while, I won't want it. Not because it is not beneficial, but because my hardware sucks. (Low memory for thunks.)
05:42:17 <dylan> LOL
05:42:29 <LeCamarade> norpan: :oD
05:43:31 <quicksilver> it's been remarked before that (>> return()) should be in the standard libs
05:43:37 <quicksilver> :t (>> return ())
05:43:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
05:44:10 <Lemmih> ?hoogle void
05:44:11 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
05:44:12 <lambdabot> System.Win32.Types.LPVOID :: type LPVOID
05:44:12 <lambdabot> System.Win32.Types.MbLPVOID :: type MbLPVOID
05:44:45 <Lemmih> (Not that 'void' should be used, of course)
05:44:55 <quicksilver> well people do often suggest 'void' as the name
05:45:00 <quicksilver> clearly C++ habits die hard.
05:45:07 <pejo> LeCamarade, In hte latest issue of The Monad Reader there is an article about Janes.. janestreet capital (?). They see the ability to reason about time and space behaviour of ocaml as an advantage.
05:45:48 <pejo> Well. Reason in a loose sense I guess.
05:46:13 <LeCamarade> pejo: Yeah, in most cases when I choose strictness, I am ready to blame the hardware deficiencies of common systems, not that anything under the sun should be evaluated before it is needed.
05:47:03 <psykotic> pejo, of course it's an advantage. it seems to be hard to do for non-trivial (and even seemingly trivial) haskell code, even for the experts.
05:47:21 <psykotic> (reasoning about space leaks, etc)
05:48:57 <pejo> psykotic, does the ML-commmunity even talk about spaceleaks?
05:50:03 <psykotic> well, the usage of the term i have in mind is pretty specific to non-strict languages.
05:50:06 <psykotic> so no
05:51:11 <LeCamarade> I find it funny, by the way, that Haskell is not mentioned most of the time people are talking of the ML family. Who's kidding me?
05:51:21 <quicksilver> psykotic: you can have space leaks in strict languages
05:51:32 <quicksilver> psykotic: just by keeping references alive for longer than you need to
05:51:36 <psykotic> quicksilver, oh sure
05:51:40 <quicksilver> psykotic: I think it's perfectly common to talk about them...
05:51:58 <quicksilver> so, I'm sure the ML community talks about space leaks
05:52:05 <psykotic> quicksilver, but the thunking in typical non-strict language implementations means that it's not clear where things can stick around
05:52:11 <quicksilver> quite
05:52:24 <quicksilver> and you have two different classes of things which can stick around, too
05:52:26 <quicksilver> data + thunks
05:56:07 <helmut> quicksilver: did you read that my annotator works?
05:56:33 <quicksilver> helmut: yes. I tried to decide if I think your thing is a monad or not, but I couldn't make up my mind
05:56:51 <quicksilver> helmut: I'm pleased you got it all working, anyhow!
06:07:39 <petekaz> mdmkolbe|work: but what is the point of implementing Shell in terms of ErrorT?  Isn't the only point of using ErrorT is so that when you call throwError it does the correct thing with Either?  And since Shell implements MonadError class and thus throwError, is there any value in ErrorT?  Could shell just return something in the IO monad by itself instead of wrapping it in ErrorT?
06:11:43 <helmut> quicksilver: one thing is still missing: It does not complain about infinite types.
06:11:55 <quicksilver> helmut: you want the famous 'occurs check'
06:12:07 <quicksilver> (or maybe you like infinite types, but most people decide to rule them out)
06:13:10 <matthew-_> any pointers for doing type level computation in Haskell?
06:13:20 <matthew-_> I need to treat types as values...
06:13:44 <quicksilver> @where oleg
06:13:45 <lambdabot> http://okmij.org/ftp/
06:13:47 <quicksilver> matthew-_: there
06:13:51 <helmut> quicksilver: I'd like to have them. unfortunately I cannot compile it then.
06:13:51 <matthew-_> cheers
06:14:53 <helmut> quicksilver: If you've got a bit time left, you can have a look at http://subdivi.de/~helmut/Annotator.lhs and give comments on that.
06:15:29 <helmut> quicksilver: and yes, that's far from being perfect. the state is better described as improvable. ;-)
06:17:12 <quicksilver> helmut: you may wish to read the top part of http://tunes.org/~nef/logs/haskell/07.04.20
06:17:25 <quicksilver> helmut: including the links which I post in that transcript
06:17:40 <quicksilver> helmut: which explain the pitfalls of equirecursive inference
06:18:06 <helmut> quicksilver: :-) cool.
06:18:38 <quicksilver> I am, in fact, in no way an expert, I was just repeating the words of others ;)
06:19:01 <ivanm> I have a list of type Foo, and a second list of type Foo -> Bool
06:19:12 <ddarius> LeCamarade: Haskell is not considered to be of the ML family.
06:19:31 <quicksilver> ivanm: zipWith ($)
06:19:32 <ivanm> how can I efficiently go through the first list, and find how many of those elements are true for each of the functions in the second list?
06:19:36 <helmut> quicksilver: obviously enough expert to teach me. :-)
06:19:45 <quicksilver> ivanm: damn, I guessed the wrong question :)
06:19:53 <ivanm> quicksilver: heh
06:20:07 <quicksilver> ivanm: you want a grand total? or a total per function?
06:20:07 <ivanm> e.g. f [1,2,3,4,5] [odd,even] = [3,2]
06:20:14 <ivanm> total per function
06:21:09 <ivanm> the only way I can think of is by doing something like:
06:22:08 * Saizan hates -Wall -Werror
06:22:37 <quicksilver> > let f vs fs = map (\f -> sum . map (fromEnum . f) $ vs ) fs in f [1,2,3,4,5] [odd,even]
06:22:38 <lambdabot>  [3,2]
06:22:44 <Wild_Cat> something like [length filter f myList | f <- filter_funcs] should do the trick.
06:22:49 <LeCamarade> ddarius: Why? But it is. Via Miranda. Miaranda was/is clearly ML-inspired.
06:23:14 <ivanm> quicksilver: yeah, I was thinking something like that
06:23:22 <quicksilver> > let f vs fs = map (\f -> length . filter f $ vs ) fs in f [1,2,3,4,5] [odd,even]
06:23:24 <lambdabot>  [3,2]
06:23:30 <quicksilver> (thanks wild_cat)
06:23:37 <ivanm> no, wait, I wasn't...
06:23:49 <ivanm> problem with that is that it goes through vs too many times...
06:23:55 <ivanm> I'd like to go through vs in one pass...
06:23:57 <ivanm> something like:
06:24:16 <quicksilver> why would you like to go through vs in one pass?
06:24:26 <quicksilver> what makes you think that's better, it doesn't sound better to me
06:24:34 <ivanm> f vals ps = foldl (\ old val -> zipWith (+) old (map (fromEnum . ($) val) ps) (replicate (length ps) 0) vals
06:24:35 <Wild_Cat> I don't think you'll get away with a one-liner, then.
06:24:41 <olsner> argh.. why does happy just say "parE" instead of what's wrong?
06:24:42 <ivanm> quicksilver: because its a very, very long list :s
06:24:49 <Wild_Cat> (not without it being unreadable, anyway)
06:24:51 <ivanm> generated as part of a backtracking tree
06:25:09 <quicksilver> then you're going to need to explicitly accumulate as you fo
06:25:42 <ivanm> quicksilver: which is what I was trying to do...
06:25:48 <ivanm> but it doesn't seem very... nice
06:25:53 <ivanm> @pl f vals ps = foldl (\ old val -> zipWith (+) old (map (fromEnum . ($) val) ps) (replicate (length ps) 0) vals
06:25:53 <lambdabot> (line 1, column 11):
06:25:54 <lambdabot> unexpected "="
06:25:54 <lambdabot> expecting variable, "(", operator or end of input
06:26:13 <ivanm> @pl f vals ps = foldl (\ old val -> zipWith (+) old (map (fromEnum . ($) val) ps)) (replicate (length ps) 0) vals
06:26:14 <lambdabot> f = flip (ap (foldl . flip ((.) . zipWith (+)) . flip (map . (fromEnum .))) (flip replicate 0 . length))
06:26:21 <ivanm> heh, that's not much better
06:26:28 <ivanm> @pl f ps vals = foldl (\ old val -> zipWith (+) old (map (fromEnum . ($) val) ps)) (replicate (length ps) 0) vals
06:26:29 <lambdabot> f = ap (foldl . flip ((.) . zipWith (+)) . flip (map . (fromEnum .))) (flip replicate 0 . length)
06:26:38 <ivanm> @pl f' vals = foldl (\ old val -> zipWith (+) old (map (fromEnum . ($) val) ps)) (replicate (length ps) 0) vals
06:26:39 <Wild_Cat> I've seen Perl code that looked less like line noise.
06:26:39 <lambdabot> f' = foldl ((. flip (map . (fromEnum .)) ps) . zipWith (+)) (replicate (length ps) 0)
06:26:44 <ivanm> Wild_Cat: heh
06:27:00 <Wild_Cat> that's usually a sign that you're doing something Bad. Like golfing.
06:27:12 <ddarius> LeCamarade: Their certainly related, but they've diverged pretty much the entire existence of lazy functional programming.
06:28:02 <njd> @users
06:28:03 <lambdabot> Maximum users seen in #haskell: 336, currently: 316 (94.0%), active: 49 (15.5%)
06:28:39 <quicksilver> > let f vs fs = foldr (\v cs -> zipWith (+) cs (map (fromEnum . ($v)) fs)) (replicate (length fs) 0) vs in f [1,2,3,4,5] [odd,even]
06:28:41 <lambdabot>  [3,2]
06:28:46 <quicksilver> ivanm: there you go
06:29:06 <ivanm> yeah, hoping there'd be a cleaner version...
06:29:10 * quicksilver shrugs
06:29:12 <ivanm> but if there isn't, there isn't :s
06:29:15 <ivanm> thanks quicksilver
06:30:07 <quicksilver> I don't think that's particularly 'dirty'
06:30:14 <quicksilver> it expresses precisely the algorithm you asked for
06:30:19 <ivanm> true...
06:30:30 <quicksilver> well I'm not very keen on using fromEnum
06:30:33 <ivanm> @pretty f vals ps = foldl (\ old val -> zipWith (+) old (map (fromEnum . ($) val) ps) (replicate (length ps) 0) vals
06:30:34 <lambdabot> "Parse error" at column 109
06:30:41 <ivanm> @pretty f vals ps = foldl (\ old val -> zipWith (+) old (map (fromEnum . ($) val) ps)) (replicate (length ps) 0) vals
06:30:42 <lambdabot>  f vals ps  = foldl      (\ old val ->
06:30:42 <lambdabot>                                      zipWith (+) old (map (fromEnum . ($) val) ps))
06:30:42 <lambdabot>                          (replicate (length ps) 0)
06:30:42 <lambdabot>                          vals
06:30:48 <quicksilver> in a real program I might comment that or replace it with a functions which makes it clear
06:31:10 <liber> Why does putChar output a percent-sign after the char it printed??
06:31:19 <quicksilver> liber: it doesn't
06:31:31 <liber> Now that is strange :)
06:31:36 <ivanm> quicksilver: *nod*
06:31:38 <quicksilver> > let f vs fs = foldr1 (\v cs -> zipWith (+) cs (map (fromEnum . ($v)) fs)) vs in f [1,2,3,4,5] [odd,even]
06:31:39 <lambdabot>   add an instance declaration for (Integral [Int])
06:31:39 <lambdabot>     In the expression: even
06:31:55 <quicksilver> doh
06:32:00 <quicksilver> stupid idea, ignore that :)
06:32:04 <ivanm> heh
06:32:14 <ivanm> what would be better, foldl or foldl' ?
06:32:14 <quicksilver> liber: it's probably your shell prompt?
06:32:21 <liber> probably
06:32:23 <quicksilver> liber: because you didn't print a newline
06:32:31 <liber> aah
06:32:39 <liber> ofcource
06:32:44 <liber> Thx
06:32:48 <quicksilver> ivanm: foldl', I guess, since you're folding to a constant
06:32:53 <ivanm> *nod*
06:32:58 <quicksilver> ivanm: erm, sorry, folding to a single summary value
06:32:59 <quicksilver> I mean
06:33:07 <ivanm> heh, yeah, I got what you meant
06:33:44 <ivanm> quicksilver: but don't all folds go to a single value?
06:33:50 <ivanm> forget that... reverse, etc...
06:33:52 <quicksilver> :)
06:34:08 <quicksilver> > foldr (:) [] [1,2,3,4,5]
06:34:10 <lambdabot>  [1,2,3,4,5]
06:35:27 <ivanm> yeah
06:39:59 <ivanm> > putStrLn (show ([1,2,3,4,5] :: [Int]))
06:40:01 <lambdabot>  <IO ()>
06:40:09 <ivanm> > show ([1,2,3,4,5] :: [Int])
06:40:10 <lambdabot>  "[1,2,3,4,5]"
06:40:19 <ivanm> I guess that'll do
06:40:21 <mux> putStrLn . show = print
06:41:00 <helmut> Maybe I should really read the Tiger-Book.
06:41:10 <ivanm> mux: yeah, I know...
06:41:14 <ivanm> I just forgot :s
06:46:26 <LoganCapaldo> @djinn (Show a) => a -> IO ()
06:46:27 <lambdabot> Cannot parse command
06:46:39 <LoganCapaldo> moo
06:49:07 <liber> noobwarning: why won't this compile? http://pastie.textmate.org/58244
06:49:09 <lambdabot> Title: #58244 - Pastie
06:49:33 <LoganCapaldo> Because you didn't use hpaste
06:49:40 <liber> :)
06:49:45 <osfameron> no semicolon ?
06:50:11 <LoganCapaldo> not no semilcon
06:50:12 <osfameron> or alignment - does putChar need to be aligned with the map?
06:50:24 <LoganCapaldo> map (bajs 3) [1,2,3,4] is not an IO action
06:50:41 <liber> I have used haskell for a total of maybe 5 minutes :) How should it look to work?
06:51:00 <Syzygy-> liber: You could start by dropping the potty humour imho.
06:51:02 <LoganCapaldo> See if it were on hpaste we could annotate it :)
06:51:18 <LoganCapaldo> Potty humor?
06:51:42 <Syzygy-> LoganCapaldo: bajs is swedish for shit, excrements....
06:51:42 <liber> Syzygy-: sorry for that. Didn't expect anyone to be swedish (scandinavian)
06:51:49 <Syzygy-> liber: BOY did you expect wrongly.
06:52:03 <Syzygy-> This place has an insane scandinavian/rest-of-the-world ratio.
06:52:05 <LoganCapaldo> yes this is the wrong channel to expect no swedes ::)
06:52:18 <liber> Aight
06:52:21 * earthy laughs
06:52:30 <earthy> even some of the non-swedes understand swedish here ;)
06:52:37 <LoganCapaldo> So you have a few problems, 1 is that map ... is not an IO action 2) you are throwing the result away anyway and not using it
06:52:53 <liber> Well. I have a sort of programming-tourettes. Many foul words in my "trying"-programs
06:53:34 <LoganCapaldo> to break out into pure code in a do block you usually do let r = map f xs
06:54:09 <olsner> Could not find module `Pretty': it is a member of package ghc-6.6, which is hidden
06:54:44 <LeCamarade> liber: It happens. The words, I mean. Plus, put your Haskell at hpaste, where we can descend on it for your benefit.
06:54:47 <LeCamarade> @paste
06:54:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:57:23 <LoganCapaldo> liber: DId I clear it up for you, or just confuse you?
06:58:18 <liber> LoganCapaldo: as I said. 5 minutes. It is not very clear at all. You did not change that
06:58:24 <liber> :)
06:58:27 <liber> In any direction
06:58:31 <LoganCapaldo> heh
06:58:51 <LoganCapaldo> ok, so a do block contains some monadic code
06:58:52 <LeCamarade> liber: I'd encourage you to stay in the REPL for now. It's nicer that way.
06:58:55 <LeCamarade> liber, what do you want your code to accomplish?
06:59:02 <liber> But anyway: I got it wirking in ghci.
06:59:05 <LoganCapaldo> map f xs is not monadic
06:59:34 <LoganCapaldo> @undo do { f; g }
06:59:35 <lambdabot> f >> g
06:59:44 <LoganCapaldo> @type f
06:59:48 <LoganCapaldo> err
06:59:50 <lambdabot> Not in scope: `f'
06:59:53 <LoganCapaldo> @typ (>>)
06:59:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:00:08 <LoganCapaldo> @type map
07:00:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:00:17 <olsner> (re swedes) the book review in the latest Monad.Reader listed the price of the book in dollars, euro and kronor
07:00:41 <LoganCapaldo> a map does not result in a monadic value (I'm lying, because its monadic in the list monad but you're using the IO monad)
07:01:36 <LoganCapaldo> So your code is being transformed into map (bajs 3) [1,2,3,4] >> putChar("\a") which does not type check
07:01:47 <LoganCapaldo> hence the no compilation
07:02:02 <sioraiocht|sleep> liber: what's the hpaste URL of your code?
07:02:08 <LoganCapaldo> Maybe I should stop saying bajs
07:02:19 <liber> GUYs GUYS! I solved it! Now stopit already! :)
07:02:50 <liber> i wanted to do a map (+num) [1,2,3,4,5] - I just did it wrong :)
07:03:06 <sioraiocht> liber: new to haskell?
07:03:19 <liber> sioraiocht: about 10 minutes :)
07:03:27 <sioraiocht> welcome!
07:03:32 <liber> Thx
07:04:23 <liber> I'll continue reading the wikibook. I just wanted to try something on my own, bur my knowleage was not sufficient. :)
07:05:39 <quicksilver> liber: you can try things on your own easily
07:05:49 <quicksilver> liber: but do so in the REPL, don't try to compile a whole program
07:05:51 <quicksilver> much easier...
07:05:58 <liber> REPL?
07:06:06 <liber> ghci?
07:06:10 <Baughn> ghci.
07:06:22 <LeCamarade> Read-Eval-Print Loop. GHCi or Hugs.
07:06:46 <LoganCapaldo> also lambdabot, but /msg her for long sessions
07:06:46 <liber> well. The problem is thwn it works in ghci it does not always work to compile with ghc.
07:06:57 <LoganCapaldo> > map (+1) [1,2,3]
07:06:59 <lambdabot>  [2,3,4]
07:07:03 <LeCamarade> liber: 10 minutes is really, really long. Some people (me) quit after a few seconds. `Monad' just looked wrong.
07:07:18 <liber> Now. Stop being so nice. Leave me alone
07:07:28 <TSC> liber: You don't really need to compile programs when you're first starting
07:07:40 <Saizan> @quote tropical
07:07:40 <lambdabot> dons says: not sure that the irc culture outside happy lambda land is always so warm and tropical
07:07:49 <LeCamarade> liber: Well, because you are in a `do' section in GHCi, which eliminates all the adorning of monads, so that you can focus on what's important.
07:07:50 <Baughn> liber: If something works in ghci and not ghc, please show me
07:08:30 <Baughn> liber: GHCI does do a few shortcuts for ease of use; those are described in its documentation.
07:08:38 <liber> Baughn: It is not a bug. It is just me that do not know the "haskell way".
07:08:48 <liber> for example the main-function.
07:09:25 <liber> But I will get there.
07:13:16 <foxy-om_> ar fortiiori.../
07:13:39 <chessguy> hm, slightly off-topic question: what's the closest equivalent to nub in perl?
07:16:09 <fax> chessguy: I dont know if this is helpful but I just found this online: my @uniq = keys %{{ map { $_ => 1 } @list }};
07:17:15 <LoganCapaldo> that looks like it'll do it
07:18:21 <LoganCapaldo> @type nub
07:18:30 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:23:10 <quicksilver> chessguy: yes, hashes are the perl way to nub
07:24:12 <chessguy> ok, i was guessing that, but wasn't sure
07:24:55 <chessguy> someone pointed out an easier way though: cat list | sort -u
07:25:07 <quicksilver> that's not a perl way, though...
07:25:08 <Botje_> sort -u list
07:25:08 <quicksilver> :)
07:25:21 * quicksilver offers chessguy an award for 'pointless use of cat'
07:25:46 <earthy> cool! it meows! :)
07:25:54 <chessguy> pointless?
07:25:58 <Saizan> cat is shell's return!
07:26:02 <chessguy> oh
07:27:20 <br1> I recieved an email from a student in australia asking for help (and offering paying for it) ona haskell assignment. Was it a mass mail?
07:28:10 <chessguy> i don't know, forward it here and i'll check
07:28:14 * chessguy snickers
07:28:32 <ndm> br1: i haven't got it, what rates?
07:28:53 <kolmodin> for the same reasons people write "cat foo | grep bar" instead of "grep bar foo"
07:28:56 <kolmodin> :)
07:30:25 <LeCamarade> :oD
07:31:52 * kc5tja sometimes does that because it's easier to envision the data flow.
07:32:09 <kc5tja> This is especially the case when constantly tweaking grep or sed statements in exploratory shell scripting.
07:33:24 <osfameron> that perl version's sort order is defined, you can do something like:  my %seen; grep { !($seen{$_}++) } @list;  if you care about that
07:33:36 <osfameron> s/defined/not defined/
07:34:16 <kc5tja> osfameron: I don't understand a word of what you just wrote.
07:34:34 <quicksilver> osfameron: side-effectful grep expressions considered harmful :)
07:34:36 <LeCamarade> Wow. Check this quote. Not sure it maketh sense, but hey, it is always nice to hear something new:
07:34:41 <quicksilver> kc5tja: that's the beauty of perl :)
07:34:43 <LeCamarade> One serious obstacle to the adoption of good programming languages is the notion that everything has to be sacrificed for speed. In computer languages as in life, speed kills." -- Mike Vanier
07:34:57 <osfameron> kc5tja: referring to the version fax posted above
07:35:10 <osfameron> quicksilver: er, does it help if you think of %seen as a monad? ;-)
07:35:35 <kc5tja> Ahh -- scroll back stuff.  Got it.
07:35:48 <osfameron> yeah, sorry, I was a bit light on context...
07:36:10 <quicksilver> osfameron: not a lot :)
07:36:21 <osfameron> quicksilver: oh well, it was worth a try ;-)
07:36:36 <quicksilver> osfameron: after all, I understood it perfectly first time
07:36:42 <quicksilver> osfameron: I just don't like it :)
07:36:48 <osfameron> quicksilver: how would you do it?
07:36:53 <kc5tja> Speaking of monads, I ran into something while pondering the use of Haskell last night while drifting off to sleep.
07:36:59 <pjd> kolmodin: i prefer "<foo grep bar"
07:37:06 <osfameron> well, I'd do it as use List::Utils, @list = uniq @list;
07:37:11 <kc5tja> It's easy enough to have a State monad encompassing the state of "an object."  (If you'll pardon the analogy)
07:37:36 <kc5tja> It's also easy enough to have a State monad encompassing the state of a thousand objects, maintained in a lisp or map or whatever, provided you wrote it that way to begin with.
07:37:55 <quicksilver> osfameron: frankly, I'd probably do it the way you did it. And not like it.
07:38:18 <kc5tja> What if, however, you write some code that re-uses someone else's Stateful object, but you don't want to rewrite his code to fit in the collection approach above?
07:38:34 <quicksilver> osfameron: I might spell it out in a for loop with unless ($seen{$_}) { $seen{$_} = 1; push @results,$_ }
07:38:48 <kc5tja> That question didn't come out well.
07:38:54 <osfameron> quicksilver: hehe :-)  funnily enough I like it too - though I see your point, it's perfectly clear and perlish and as eficient as perl+hashes is going to get
07:39:24 <kc5tja> What if, however, you write some code that re-uses someone else's Stateful object, but you need thousands of these objects, without altering the original code?
07:39:52 <quicksilver> kc5tja: make a monad which encompasses that, and some simple primitives to extract a particular object easily
07:40:35 <kc5tja> The problem is, you can only maintain state while running _inside_ the stateful monad.
07:40:54 <quicksilver> ah well it does depend on the kind of monad
07:41:08 <quicksilver> I was rather assuming it was the kind which gives you, in some sense, external access to that stat
07:41:15 <kc5tja> I'm assuming State monads for the "objects," since it's easiest to understand.
07:41:16 <quicksilver> so you can store it in the way that suits you and push it back in later
07:41:18 <pjd> can you lift monadic binding into a functor?
07:41:24 <Saizan> is it me or ghc head snapshots are corrupt?
07:41:31 <kolmodin> kc5tja: you could add abstraction to switch state
07:41:40 <pjd> into the list functor, specifically
07:41:42 <quicksilver> kc5tja: with the actual monad called 'State', my solution is fine
07:41:49 <sproingie> it only recently occurred to me that State isn't about any particular instance of State, it just means it deals in some way with state
07:42:03 <quicksilver> kc5tja: you pull the state out of the individual objects and stuff them in a list
07:42:03 <sproingie> so the idea of "multiple states" is kind of an illusion.  is that about right?
07:42:07 <kc5tja> quicksilver: But, I don't see how; once runState returns, all state disappears.
07:42:19 <quicksilver> kc5tja: there is a variant of runState which returns the state :)
07:42:30 <kc5tja> runState does both return a value and the state.
07:42:34 <kc5tja> evalState filters it.  :)
07:42:38 <quicksilver> right
07:42:39 <osfameron> something is rotten...
07:42:46 <quicksilver> so then you stuff the old state back into your next runState
07:42:59 <quicksilver> (and you do all this behind the scenes in two reusable combinators)
07:43:04 <quicksilver> so that the code using it is simple and clear
07:43:10 <kc5tja> OK, I think I see what you're saying now.  So there's no need to maintain the monadic abstraction when nothing is happening to the "object," only when actually working with it.
07:43:19 <kc5tja> OK, that makes good sense.
07:43:32 <kc5tja> kolmodin: That sounds ... difficult.  :)
07:43:33 <quicksilver> sproingie: I think in your first sentence, you meant 'MonadState' the first time?
07:43:48 <quicksilver> kc5tja: if you have something like ST which hides the state and never lets you get it back
07:43:49 <kolmodin> kc5tja: I don't think I understood neither the question or the answer :D
07:43:51 <quicksilver> kc5tja: then you're stuffed :P
07:43:59 <sproingie> quicksilver: er yah.  seeing MonadState in a type
07:44:13 <quicksilver> kc5tja: although in practical applications you can normally extract 'enough state to recreate'
07:44:15 <kc5tja> quicksilver: Correct.
07:44:24 <quicksilver> kc5tja: this problem is analogous to serialisation
07:44:28 <kc5tja> quicksilver: But at a runtime performance cost.
07:44:31 <quicksilver> indeed
07:44:41 <quicksilver> 'freeze' in the ST Array stuff is an example
07:44:50 <quicksilver> you can pull out all the state and push it back into a later ST using that
07:44:56 <quicksilver> but you pay the copying cost, clearly
07:44:56 <kc5tja> What is ST versus State?
07:45:04 <quicksilver> ST is a particular, very clever, state monad
07:45:15 <quicksilver> which uses efficient mutation tricks behind the scenes
07:45:30 <quicksilver> true mutable arrays (like C) with a pure interface
07:45:45 * mux salivates at quicksilver's description
07:46:00 <quicksilver> it's no difference in performance from IOArrays
07:46:09 <quicksilver> (because behind the scenes they are *exactly the same*)
07:46:18 <quicksilver> but it doesn't spread IO types around your code
07:47:18 <sproingie> anything like that for mutable maps?
07:47:32 <quicksilver> kc5tja: actually what I was saying was 'sometimes you have to violate abstraction briefly so you can build a larger abstraction'
07:47:39 <kc5tja> Well, thus concludes my current set of philosophical ramblings.  I need to get ready for work.
07:47:45 <quicksilver> kc5tja: but as long as the violation is encapsulated, that's often considered OK
07:47:52 * kc5tja nods
07:47:59 <kc5tja> Isn't that true of everywhere else though?  :)
07:48:02 <quicksilver> absolutely
07:48:07 <quicksilver> it's a general notion, not a haskell one
07:48:27 <quicksilver> like efficient C++ libraries which bypass accessors and directly mutate objects' instances variables
07:48:33 <quicksilver> 'friend' methods, I think C++ calls them?
07:48:43 <chessguy> c++--
07:49:17 <kc5tja> Friend functions and friend classes as well.
07:49:35 <kc5tja> But they come in damn handy sometimes.  However, like anything else, they can certainly be abused.
07:50:04 <quicksilver> quite
07:50:30 <quicksilver> they are an artefact of C++'s protection system which is a bit coarse-grained
07:56:42 <Baughn>  @type when
07:58:14 <astrolabe> when :: Monad m => Bool -> m () -> m ()
07:58:28 <astrolabe> don't know where the bot is
07:58:38 <quicksilver> it ought to be when :: Monad m => Bool -> m a -> ma
07:58:49 <quicksilver> erm, missing a :)
07:58:57 <quicksilver> but maybe that's silly
07:58:57 <astrolabe> hmmm
07:59:05 <LoganCapaldo> why a?
07:59:08 <Cale> @type when
07:59:17 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:59:18 <Cale> okay, just checking :)
07:59:19 <Cale> ah
07:59:20 <LoganCapaldo> its got no else branch so it must be a side effect
07:59:24 <Cale> there we go :)
07:59:26 <quicksilver> I meant when :: Monad m => Bool -> a -> m a -> m a
07:59:34 <quicksilver> but I retract my suggestion in any case
08:00:19 <quicksilver> when :: Monad m => Bool -> m a -> m (Maybe a) ?
08:00:22 <quicksilver> so many options!
08:00:59 <quicksilver> I'm sure that's why the library is a bit weak on control structures
08:01:04 <olsner> Happy is b0rked... and unfortunately there doesn't seem to be a whole lot of GLR parser generators out there for haskell
08:01:07 <quicksilver> there are just so many it's hard to choose which should be standard
08:01:50 <osfameron> @src nubBy
08:01:51 <lambdabot> nubBy eq []             =  []
08:01:51 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
08:01:57 <osfameron> that's beautiful
08:02:35 <osfameron> it looks slightly insane though
08:02:54 <olsner> I guess I'll have to make my own
08:02:54 <ndm> @pl (\ y -> not (eq x y)
08:02:55 <lambdabot> (line 1, column 21):
08:02:55 <lambdabot> unexpected end of input
08:02:55 <lambdabot> expecting variable, "(", operator or ")"
08:03:03 <ndm> @pl \ y -> not (eq x y)
08:03:03 <lambdabot> not . eq x
08:03:13 <ndm> could be shorter...
08:03:27 <sproingie> @where when
08:03:27 <lambdabot> I know nothing about when.
08:03:40 <LoganCapaldo> Doesn't @src come from the report? Should it not then favor clarity over shortness?
08:04:13 <astrolabe> It's not clear to me which is clearer.
08:04:14 <ndm> @hoogle when
08:04:15 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
08:04:15 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
08:04:17 <Baughn> > nubBy (=) [1,2,3,1,2,2]
08:04:17 <lambdabot>  Parse error
08:04:26 <Baughn> > nubBy (==) [1,2,3,1,2,2]
08:04:28 <lambdabot>  [1,2,3]
08:04:34 <ndm> i find the shorter version easier in this particular case
08:04:35 <quicksilver> osfameron: it's beautiful but I think it's very inefficient
08:04:39 <norpan> (not . eq x) is clearer
08:04:57 <quicksilver> osfameron: it builds up a massive closure of filters, proportional to the number of unique input elements
08:05:06 <osfameron> quicksilver: yeah, I guess for a short list, wrapping that many function calls makes sense.  For a longer one, the hash lookup in Perl would be faster
08:05:14 <cdsmith> I'd prefer to see x : [y | y <- xs, not $ eq x y]; that would be clearer to me
08:05:15 <norpan> but do you have a choice if you want to be as lazy as possible
08:05:34 <LoganCapaldo> I wasn't talking about this specific case necessarily :)
08:05:48 <quicksilver> norpan: yes, you have a choice
08:05:49 <norpan> hash lookup is not possible if you only have eq
08:05:55 <astrolabe> I like ndm's best.
08:05:59 <LeCamarade> ?src nub
08:06:00 <lambdabot> nub = nubBy (==)
08:06:09 <LeCamarade> ?src nubBy
08:06:10 <lambdabot> nubBy eq []             =  []
08:06:11 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
08:06:12 <Baughn> norpan: Exercise: Build nubBy using Data.Map
08:06:26 <Baughn> What does nub stand for, though?
08:06:29 <norpan> Baughn: Map requires Ord, right?
08:06:34 <quicksilver> norpan: but, as you correctly point out, not with a generic predicate
08:06:48 <Baughn> norpan: It does. There's not a lot you can do with only Eq.
08:06:49 <quicksilver> Baughn: can't be done efficiently with 'eq' being an arbitrary predicate
08:07:10 <astrolabe> I prefer to use filter over [x | x <- xs, ***] because it is more specialised.
08:07:12 <norpan> Baughn: turn nub upside down and see :)
08:07:22 <norpan> Baughn: letter by letter
08:07:39 <Baughn> unp? pnu? bun?
08:07:42 <Baughn> ...
08:07:42 <olsner> unp?
08:07:48 <Maddas> not quite :-)
08:07:51 <Maddas> rotate by 180 degrees
08:08:05 <olsner> qun?
08:08:07 <Maddas> (hence turn, not flip :-)
08:08:16 <olsner> gnu?
08:08:19 <olsner> *qnu
08:08:19 <Maddas> olsner: only the letters, but there aren't many permutations left
08:08:43 <Baughn> Maddas: Just tell us
08:08:45 <olsner> ... haskellgolf
08:08:46 <norpan> unq
08:08:53 <Maddas> Baughn: Where's the fun in that? :-)
08:08:58 <Maddas> (yes, unq)
08:09:17 <Baughn> Okay. Next question:
08:09:21 <Baughn> What joker named nub?
08:09:36 <olsner> haskell is an iteration of all possible recursion patterns and an assignment of random letter sequences to them
08:09:58 <Baughn> olsner: Pseudorandom. You can't have random without IO.
08:10:12 <sproingie> wow, filemanip looks nice
08:10:26 <sproingie> at this rate i'll be replacing my perl one-offs with haskell
08:10:40 <Maddas> Baughn: 'nub' itself is an English word.
08:10:40 <LoganCapaldo> And even with IO random-ness starts getting epistemological :)
08:10:53 <olsner> Baughn: s/random/arbitrary/
08:10:58 <Baughn> Maddas: Not a /good/ one
08:11:07 <cdsmith> According to Princeton wordnet: nub = kernel: the choicest or most essential or most vital part of some idea or experience.  It kinda fits
08:11:22 <sproingie> i still want to pronounce it as "nubby"
08:11:30 <Baughn> instance (\) ...
08:11:31 <sproingie> i.e. covered with nubs
08:11:39 <Maddas> zvon.org says 'nub (meaning "essence")'; while I see the connection, it's certainly not a name that springs to mind :-)
08:11:48 <osfameron> so you could build nubBy with Data.Map ?
08:12:05 <Baughn> osfameron: Not quite, no
08:12:06 <cdsmith> Data.Map requires more than Eq
08:12:22 <cdsmith> (or, with nubBy, nothing at all I guess)
08:12:23 <osfameron> right, you could make a more specialised nubOrdBy or similar
08:12:36 <Baughn> Sure, and it'd be a good idea
08:12:39 <eumenides> doing time <- liftIO getClockTime in the CGI monad returns IO ClockTime. how do I get just ClockTime?
08:12:41 <ndm> osfameron: yes, and i did suggest it, and produced a patch - although its not yet gone in
08:12:43 <Baughn> nubBy is apparently O(n^2)
08:13:04 <quicksilver> well O((number unique)*(n))
08:13:07 <norpan> and it can't be any less, since you need to compare all elements with each other
08:13:27 <osfameron> I imagine it looks like the perl version but with the map threaded in as a Monad... nah, I can't imagine that (still too ignorant)
08:13:34 <Baughn> quicksilver: They might all be unique. In the spirit of O=worst case..
08:13:39 <olsner> but (number unique) is O(n) anyways
08:13:45 <quicksilver> olsner: it might not be
08:13:50 <quicksilver> olsner: number unique might be 5
08:13:50 <Maddas> olsner: Why so?
08:13:52 <quicksilver> :P
08:14:06 <quicksilver> however, I was wrong
08:14:09 <quicksilver> it's O(n^2)
08:14:12 <olsner> at least in the worst case, which is what you must assume
08:14:49 <cdsmith> <nit> since O(n) means "no worse than n", of course it's O(n).  It just may not be Omega(n) </nit>
08:15:13 <cdsmith> "it" = number of unique items
08:15:49 <Baughn> cdsmith: Nope, it isn't O(n), because it /can/ be worse than that
08:15:55 <Baughn> Omega(n), yes.
08:16:13 <norpan> cdsmith: it's the other way around
08:16:17 <Maddas> Baughn: I think he's referring to the number of unique elements.
08:16:31 <cdsmith> Baughn: how can the number of unique elements be more than the number of items in the list?
08:16:31 <olsner> but you can't have more unique elements than there are elements! that's just not a list anymore ;-)
08:16:36 <Maddas> :-)
08:16:43 <cdsmith> norpan: ??
08:16:45 <Baughn> cdsmith: I can think of a few ways
08:16:55 <Baughn> cdsmith: ..mind you, they involve infinite lists
08:17:19 <norpan> cdsmith: O(n) implies O(n¬≤) but O(n¬≤) does not imply O(n)
08:18:01 <Baughn> norpan: Correct me if I'm wrong, but isn't O-notation an /upper/ limit?
08:18:06 <norpan> O is an upper bound yes
08:18:08 <cdsmith> norpan: I agree that O(n) => O(n^2) but not vice versa.  What I said is that is the number of unique items were O(1) it would also be O(n), which is also true.
08:18:20 <norpan> so you can't say it's O(n) because that's not an upper limit
08:18:21 <LoganCapaldo> I would really like to see one of these # of unique elements > # number of elements lists even if it is infinite
08:18:26 <Baughn> norpan: ..right, never mind.
08:18:59 <bos> @seen dcoutts
08:18:59 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I last heard dcoutts speak 2h 45m 43s ago.
08:19:19 <Wild_Cat> #haskell-overflow?
08:19:31 <dcoutts_> @arr!
08:19:31 <lambdabot> Swab the deck!
08:19:33 <norpan> cdsmith: ok, maybe the part about unique items got overlooked by me :)
08:19:34 <dcoutts_> hia bos
08:19:44 <Baughn> LoganCapaldo: No such thing. While I could make a good try at convincing you, I'd be wrong - aleph-0 == aleph-0, always.
08:19:48 <bos> howdy hey.
08:20:00 <dcoutts_> hia shapr!
08:20:06 <cdsmith> norpan: ok, at least I'm not going crazy then. :)
08:20:15 <LoganCapaldo> Baughn: Oh good, I got scared there for a minute :)
08:20:20 * kc5tja wonders why languages insist on using singly-linked lists instead of doubly-linked lists for their "list" primitives.
08:20:37 <shapr> hiya dcoutts_!
08:20:42 <kc5tja> And that, ladies and gentlemen, is the most completely random thought of the day.  :)
08:20:46 <LoganCapaldo> kc5tja: sharing?
08:20:49 <Baughn> kc5tja: Because otherwise you have to throw out the entire tree to update one leaf
08:21:08 <ndm> hi bos
08:21:12 <norpan> for pure languages, singly linked lists rule
08:21:15 <ndm> i liked the filemanip thing :)
08:21:20 <norpan> since you can use the tail
08:21:29 <bos> thanks.
08:21:42 <Wild_Cat> actually, most languages I know use array-based lists.
08:21:47 <shapr> kc5tja: My random thought is... how could one design a small-in-installed-size but still-useful language? I was thinking of having only 23 finger-trees and then aliasing them to all the other standard data structures.
08:21:47 <bos> ndm: of course, i based it on everyone's favourite portable file naming library :-)
08:21:52 <LoganCapaldo> let foo = [2,3] in (7:foo, 9:foo) -- now I have to copy foo
08:22:06 <ndm> bos, yeah, i now see why you want the other order for arguments
08:22:10 <Maddas> Wild_Cat: I think that says more about the languages you know than about common implementation techniques, though :-)
08:22:15 <kc5tja> I lack knowledge of what finger-trees are.
08:22:20 <ndm> shapr: javascript
08:22:54 <kc5tja> shapr: However, I also must wonder what you mean by "still useful?"  Surely Scheme is a small language that is still useful?
08:23:03 <bos> ndm: it doesn't make much of a practical difference with two-argument functions. sticking "flip" in front isn't very painful :-)
08:23:05 <kc5tja> Or Forth, with suitable libraries?
08:23:09 <Wild_Cat> Maddas: probably. (Still, you wouldn't believe how many Java coders I've met who insist on using LinkedLists).
08:23:22 <ndm> bos: (`replaceExtension` ".foo") is my usual method
08:24:40 <Maddas> Wild_Cat: heh.
08:24:58 <shapr> kc5tja: Yeah, but I was thinking of how to make the smallest installed size. Finger trees are passable at doing everything, so I figure I can substitute them for everything else.
08:25:06 <cdsmith> @where filemanip
08:25:07 <lambdabot> I know nothing about filemanip.
08:25:45 <shapr> I want my filemanip!
08:26:08 <bos> @where+ filemanip http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip-0.1
08:26:09 <lambdabot> Done.
08:26:45 <cdsmith> bos: thanks; with so many people talking about it, I was gettign curious
08:26:50 <Baughn> @where+ filemanip http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip
08:26:51 <lambdabot> Done.
08:27:38 <shapr> bos: yay!
08:28:35 <LeCamarade> @quote hex
08:28:36 <lambdabot> hex says: 09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0
08:28:46 <Baughn> ..that's getting out of hand
08:28:59 <int-e> I've thought a bit about having separate implementations for a module for different haskell implementations; http://hpaste.org/1667 is the result. Does anyone have better ideas for this?
08:29:06 <LeCamarade> Yeah. I hate it too. I'm starting to hate it.
08:30:17 <fax> I dont see why everyone cares :/
08:30:22 <fax> people crack DRM all the time..
08:30:55 <shapr> fax: Er, what was that in response to?
08:31:01 <norpan> i like F0 0F C7 C8 better
08:31:03 <Maddas> shapr: the @quote hex
08:31:15 <shapr> Oh, is that the key?
08:31:20 <Maddas> Yup.
08:31:22 <shapr> heh
08:31:23 <bos> int-e: it hurts! :-)
08:31:44 <int-e> bos: still better than having two wildly different implementations in a single file
08:32:09 <norpan> i like the fact that you could do something like main = 0xc8c70ff0 and compile it with gcc
08:32:32 <fax> shapr: im assuming that those hex digits have somthing to do with DRM
08:32:38 <fax> based on whats been implied everywhere
08:32:47 <fax> is it something else?
08:32:49 <Wild_Cat> fax: they're a HDDVD decryption key.
08:32:58 <fax> uhu
08:33:49 <Maddas> fax: Don't worry, I'm sure it's a passing fad, just like the Tamagotchi :-)
08:33:57 <fax> hehe
08:34:03 <Wild_Cat> and they've been all the rage recently since they got censored when posted on digg.
08:34:26 <sproingie> digg caved, the riot stopped
08:35:12 <Wild_Cat> at some point, people even started putting them everywhere on Wikipedia, and a guy even made a (Youtube) song out of them.
08:35:16 <sproingie> it was interesting to see the page.  as with all things digg, the comments are better left unread
08:38:06 <Wild_Cat> yup. The main debate ("what's wrong/illegal with posting a string of hex digits?") is an interesting philosophical question, too.
08:38:34 <kc5tja> F0 0F is also the x86 instruction that can bring an unpatched Pentium chip to its knees, begging for mercy.  It's the closest instruction Intel's yet produced to HCF.  ;)
08:39:01 <Saizan> yeah, as "what's wrong with storing huge numbers that accidentally can be interpreted as media content?"
08:39:37 <sproingie> i'd call it a matter of length and context.  i think the context of "why do they want to keep that string of digits secret" is more interesting
08:40:17 <quicksilver> I have a string of digits, which I want to keep secret
08:40:23 <quicksilver> it's my gpg private key
08:40:29 <beelsebob> does anyone know where I can aquire a copy of Bernie Pope's PhD thesis?
08:40:36 <sproingie> lots of useful "fight the power" idiots on digg, great for propagating the flash meme, not sure i'd want them making philosophical arguments
08:40:49 <shiruken> fight the power
08:40:54 <Wild_Cat> sproingie: especially when it's not secret in the first place. Which is why the very idea of DRM is dumb to begin with.
08:40:55 <LeCamarade> Okay, I have a question. Could Haskell have survived without throwing exceptions around, only banking on Maybe?
08:41:03 <Syzygy-> HCF?
08:41:06 <LeCamarade> I hate exceptions, as it is.
08:41:06 <Wild_Cat> LeCamarade: Maybe :p
08:41:06 <quicksilver> beelsebob: I would email bernie pope
08:41:10 <sproingie> i believe that's "fight the power: 09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0"
08:41:20 <quicksilver> LeCamarade: no, because exceptions can occur in code which isn't expecting it
08:41:21 <beelsebob> quicksilver: that's kind of the problem -- he emailed me
08:41:23 <LeCamarade> Wild_Cat: Just True.
08:41:31 <beelsebob> saying "err, you know a lot of your ICFP paper is in my thesis"
08:41:56 <beelsebob> sproingie: http://uncyclopedia.org/wiki/Steganography#Famous_things_written_on_the_side_of_Dinosaurs
08:41:59 <lambdabot> Title: Steganography - Uncyclopedia, the content-free encyclopedia, http://tinyurl.com/yvd3gs
08:42:00 <ndm> beelsebob: do you need to withdraw your ICFP paper as a result?
08:42:19 <sproingie> exceptions are merely one implementation of 'fail'
08:42:20 <beelsebob> ndm: don't know yet -- I'm trying to find a copy of his thesis so I can assess the damage
08:42:23 <sproingie> propagating None is another
08:42:29 <LeCamarade> quicksilver: Like when I ^D instead of writing something for read or getLine
08:42:31 <LeCamarade> ?
08:42:43 <quicksilver> beelsebob: http://scholar.google.com/scholar?hl=en&lr=&cluster=10699006527302348865
08:42:45 <lambdabot> Title: - Google Scholar, http://tinyurl.com/yolkz8
08:42:53 <quicksilver> beelsebob: I have no idea if that's his thesis, but presumably
08:43:00 <quicksilver> beelsebob: I still dont' really understand why you didn't just ask him :)
08:43:03 <LeCamarade> But couldn't the writers of those particular things have used Nothing?
08:43:06 <beelsebob> quicksilver: no, I think that's his first paper on the subject
08:43:18 * LeCamarade is aware of the code burden introduced thus.
08:43:20 <beelsebob> quicksilver: I have asked him, he's said it wont be online for a while
08:43:47 <sproingie> that steganography article just cries out for the hex digits
08:44:03 <beelsebob> sproingie: they're already there
08:44:11 <beelsebob> that's why I linked you
08:44:17 <sproingie> i don't see them
08:44:22 <beelsebob> EXACTLY!
08:44:27 <sproingie> ohhh silly me
08:44:32 <beelsebob> :D
08:44:36 <sproingie> gawd that's cute
08:44:43 <quicksilver> beelsebob: well if he wants you to take his comment seriously, he has to make available a copy to you
08:44:56 <quicksilver> beelsebob: if he's not prepared to make a copy available then I would ignore his comments
08:45:18 <beelsebob> sproingie: steghide --extract -sf secret.jpeg
08:45:20 <quicksilver> there is no requirement that ICFP submissions be unrelated to 'future, unpublished work' :P
08:45:28 <beelsebob> quicksilver: indeed
08:45:29 <ndm> quicksilver: thats not how academic works
08:45:34 <beelsebob> I'm trying to get it out of him all the same
08:45:45 <ndm> beelsebob: is his thesis unpublished? was it not done some time ago?
08:45:58 <beelsebob> ndm: it was done a while ago
08:46:00 <sproingie> alright, gotta get to that non-haskell thing i get paid for
08:46:04 <beelsebob> but it is not possible to get copies
08:46:12 <sproingie> gotta turn it into a haskell thing i get paid for
08:46:15 <ndm> thats not the rule of academics, alas...
08:46:38 <quicksilver> ndm: which part is not how academia works?
08:46:44 <vincenz> "paid for"
08:46:45 * sproingie :: (Perl a, Haskell b) => Work a -> Work b 
08:46:47 <LeCamarade> sproingie: Good luck.
08:47:15 <Syzygy-> beelsebob: You could always add something like "It was brought to the authors attention that these and these parts of this paper have been independently discovered by Bernie Pope [42]." - "[42] Bernie Pope, PhD thesis, to appear."
08:47:25 <beelsebob> quite possibly
08:47:28 <ndm> quicksilver: it got written, a thesis is available, even if its not online - you can always write to the institution
08:47:36 <Syzygy-> Or PhD thesis, blah
08:47:38 <ndm> Syzygy-: but the thesis appeared a while ago
08:47:43 <beelsebob> Syzygy-: what I'm most worried about is that Bernie Pope is reviewing it
08:47:44 <Syzygy-> Writing the department is a good way to get a thesis.
08:47:48 <Syzygy-> ndm: Sorry, I missed it.
08:47:54 <beelsebob> (because I see no other way that he could have come accross it)
08:48:03 <quicksilver> ndm: however, it would be unreasonable of bernie to refuse to send an electronic copy, I believe
08:48:05 <ndm> beelsebob: is he on the review committee?
08:48:08 <Syzygy-> beelsebob: Bernie Pope is reviewing your paper? Obviously they wentfor the expertise in your field then. :P
08:48:25 <eumenides> putting a set into a set results in a stack overflow?
08:48:27 <ndm> quicksilver: yes, i agree - but thats not academic rules
08:48:29 <beelsebob> ndm: no, but there's no on debugging related on it -- I wouldn't be too surprised if he had been called in to look at it
08:48:43 <ndm> beelsebob: if he is, you aren't going to be accepted
08:48:50 <beelsebob> ndm: duh
08:48:58 <beelsebob> Syzygy-: the really really odd thing is that *none* of the other experts in the field knew about it
08:49:02 <Syzygy-> Hmmmm.
08:49:12 <beelsebob> Colin Runciman, Malcolm Wallace, Olaf Chitil, Henrik Nillson have all looked at it
08:49:24 <beelsebob> and none of them even commented that they thought Bernie Pope had done something similar
08:49:28 <Syzygy-> The book, first hit on scholar is a book that seems to be a thesis.
08:49:31 <quicksilver> beelsebob: are you affiliated with a university?
08:49:37 <Syzygy-> That's weird.
08:49:44 <quicksilver> Syzygy-: yes, I shoed him that link, he didn't seem to think it was
08:49:49 <beelsebob> quicksilver: yes, Olaf's my supervisor
08:49:50 <ndm> but none of those have worked with Bernie, have they?
08:49:54 <beelsebob> quicksilver: let me have another look
08:50:00 <quicksilver> beelsebob: shouldn't be a problem to get your university to pay for a copy of the thesis then
08:50:04 <beelsebob> ndm: I think Olaf has albeit briefly
08:50:13 <Syzygy-> beelsebob: Was it his PhD thesis or some other thesis?
08:50:25 <Syzygy-> http://www.cs.mu.oz.au/~bjpop/papers/thesis.ps.gz
08:50:27 <beelsebob> Syzygy-: should be his PhD Thhesis
08:50:31 <beelsebob> ohhhH!
08:50:32 <beelsebob> thanks!
08:50:33 <Syzygy-> From his webpage. Honours thesis though.
08:50:38 <Syzygy-> http://www.cs.mu.oz.au/~bjpop/papers.html
08:50:39 <lambdabot> Title: Bernie Pope's papers page
08:50:41 <Syzygy-> His pulbication list
08:50:49 <beelsebob> oh, no
08:50:49 <Syzygy-> With linked files everywhere.
08:50:53 <beelsebob> need his PhD one
08:50:56 <beelsebob> not his honours one
08:51:00 <Syzygy-> Hrm. Not quite.
08:51:11 <Syzygy-> There's nothing on his webpage that has him actually possessing a PhD.
08:51:28 <ndm> beelsebob: he's been with the Simons at MS recently, you can always track him down in person and kneecap him
08:51:30 <Syzygy-> "I am a postgrad student within the Department of Computer Science at the University of Melbourne"
08:51:30 <beelsebob> I know -- but there is on Lee Naish's webpage
08:51:36 <Syzygy-> Ah.
08:51:47 <beelsebob> (who was his supervisor)
08:51:58 <beelsebob> I wonder
08:52:02 <beelsebob> he may have *just* passed
08:52:12 <beelsebob> and there may be no published work on it *yet*
08:52:24 <beelsebob> in which case I may just have beaten him to the punch
08:53:01 <ndm> beelsebob: really, i seem to remember him from being around before i started my phd
08:53:01 <beelsebob> but I will need to get a copy of his theis to find out
08:53:01 <beelsebob> ndm: same here
08:53:01 <beelsebob> so there's something odd going on
08:53:04 <ndm> beelsebob: but it does say "phd student", in which case it may be brand new
08:53:19 <beelsebob> it may be that he was doing a lot of research before his PhD?
08:53:24 <Syzygy-> I don't see Lee Naish's webpage pronouncing him a PhD either.
08:53:26 <ndm> beelsebob: and he did an MS internship - i thought that was funny, as i didn't think he was a student
08:53:38 <Syzygy-> Rather Naish sattes him to be a postgraduate student.
08:54:00 <quicksilver> some people take a long time to write their thesis
08:54:08 * quicksilver looks guilty
08:54:17 <quicksilver> anyhow I'm quite unclear of the context of this discussion
08:54:30 <quicksilver> was the tone of the communication 'you might be interested in my work'
08:54:37 <beelsebob> not really
08:54:38 <quicksilver> or was it 'I allege your work is not original research'
08:54:44 <beelsebob> latter
08:54:47 <quicksilver> hmph
08:54:52 <quicksilver> well that's just rude, frankly :P
08:54:58 <beelsebob> "I don't mean any offence by writing to you about this, and I enjoyed the paper very much, especially the discussion of soundness, but I am a bit concerned that the paper seems to claim originality of the idea."
08:55:07 <ndm> @paste
08:55:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:55:10 <quicksilver> ah, that's a bit less rude :)
08:55:19 <hpaste>  ndm pasted "about bernie" at http://hpaste.org/1668
08:55:42 <eumenides> is there some way to see what kind of derive instance ghc generates?
08:55:44 <ndm> beelsebob: read that about the author from 3 months ago
08:55:53 <beelsebob> okay
08:56:03 <beelsebob> so the implication is that his thesis has not been submitted
08:56:16 <beelsebob> nor has he published any work on this
08:56:26 <ndm> yes, i guess
08:56:30 <beelsebob> (other than a bhudda tutorial that admittedly does look very similar)
08:56:30 <quicksilver> beelsebob: I would reply along the lines that 'I was unaware of your work in the area and I'd be really interested to see anything you can show me about it; have you published anything?'
08:56:56 <beelsebob> quicksilver: I replied along the lines of "oh... that's really odd... can you show me your thesis please?"
08:57:18 <quicksilver> I don't think the ICFP committee could rule you out on the grounds of non-novelty if there is no *published* work to point to
08:57:33 <beelsebob> there is published work that seems to outline it
08:57:33 <quicksilver> and even if there is, it would be really surprising if your own paper had no novelty left
08:57:34 <Syzygy-> Did he really point you to his PhD thesis? Or was it towards his "thesis"?
08:57:42 <beelsebob> but none that actually defines it
08:57:48 <ndm> beelsebob: have you considered that maybe he's got an ICFP paper in on the same topic?
08:57:51 <quicksilver> normally when two people attack the same problem there are plenty of different ways they approach it
08:57:52 <Syzygy-> Because it's bizarre how little evidence I find on the web for him having produced a thesis.
08:58:02 <beelsebob> Declarative Debugging with Buddha. In Varmo Vene and Tarmo Uustalu, editors, Advanced Functional Programming, 5th International School, AFP 2004, volume 3622 of Lecture Notes in Computer Science, pages 331-357. Springer Verlag, September 2005.
08:58:11 <beelsebob> that's the only thing I can find that mentions it
08:58:16 <beelsebob> and it's only kind of a passing mention
08:58:31 <hpaste>  matthew-_ pasted "bother. I'd hoped this would explode." at http://hpaste.org/1669
08:58:31 <beelsebob> "It is also discussed in detail in my phd thesis "
08:58:47 <Syzygy-> o.O
08:59:04 <beelsebob> conclusion -- there's only one published piece of work about it
08:59:15 <beelsebob> and he's going "SHIT, THAT GUY'S PUBLISHING MY PhD at ICFP"
08:59:30 <matthew-_> so I presume it didn't explode because there could be an instance Bar (Maybe a) elsewhere?
08:59:55 <Syzygy-> beelsebob: This really calls for a PhD-comics link, y'know.
08:59:57 <ndm> beelsebob: either way, you and him probably  need to either get really friendly or really violently agressive quite quickly :)
09:00:46 <beelsebob> ndm: well, looking at it at the moment, I'll discuss with Olaf, I don't think that I'll pull the ICFP paper for the moment, and try to keep replying in a friendly way
09:01:09 * LeCamarade thinks the whole PhD thing is an alien idea - he is a proud unschooled autodidact.
09:01:09 <int-e> matthew-_: no, it didn't explode because undefined inhabits the Foo a b type, no matter what a and b are
09:01:20 <beelsebob> bottom line is if he thought of this 3 years ago he should have published it
09:01:36 <quicksilver> matthew-_: it's the Foo *constructor* you have constrained
09:01:40 <quicksilver> matthew-_: not the Foo *type*
09:01:43 <matthew-_> quicksilver: indeed.
09:01:47 <quicksilver> matthew-_: and you aren't using the constructor
09:01:48 * LeCamarade sides with beelsebob, by the way. Kind of.
09:01:49 <quicksilver> thus, no blow up
09:02:02 <beelsebob> LeCamarade: not sure if it's really something you can take sides with
09:02:11 <beelsebob> I think it's an honest case of "both of us came up with it at the same time"
09:02:12 <matthew-_> int-e: ok, so I can't just use undefined when I can't be bothered to write the implementation?
09:02:17 <quicksilver> beelsebob: I would counsel friendliness, and discussions with your supervisor
09:02:37 <earthy> beelsebob: or you can do the really friendly thing and mention that you thank B. J. Pope for ideas contributing to the paper
09:02:39 <beelsebob> quicksilver: yeh, left me in a bit of a panic, because Olaf is out of his office for the week
09:02:49 <quicksilver> matthew-_: the moral is 'type class constraints on types don't really exist'
09:02:49 <LeCamarade> beelsebob: In short, just go on with your track, and say ... exactly. That's it. Same idea, same time.
09:03:04 <int-e> matthew-_: right.
09:03:15 <beelsebob> earthy: problem there is that that's like saying " I saw Bernie's ideas and developed them" in reality, I developed them independantly, and then got a nasty shock
09:03:18 <matthew-_> quicksilver: that there, is something of a pain.
09:03:42 <quicksilver> matthew-_: there are deep reasons for it which I cannot call to mind at all :)
09:03:48 <vincenz> beelsebob: what's your paper on?
09:03:51 <int-e> matthew-_: as quicksilver said you'd have to restrict the type to make that work (not sure how well that works actually).
09:03:55 <quicksilver> matthew-_: but having class restrictions on the constructors is good enough in practice
09:04:02 <beelsebob> vincenz: debugging higher order programs
09:04:16 <quicksilver> beelsebob: I certainly wouldn't be friendly enough to thank his contributions
09:04:26 <matthew-_> quicksilver: so there's no chance I can ever write: data (Baa a) => Foo :: * -> a -> * where FooC :: (Bar a) => b -> a -> Foo b a
09:04:29 <earthy> beelsebob: 'These ideas may have independently been discovered by B. J. Pope, but we strongly feel wider publication is warranted'
09:04:42 <beelsebob> earthy: that sounds not unreasonable
09:04:44 <quicksilver> beelsebob: I would (only if the ICFP committee ask you to) add a note that you became aware of similar work by Bernie Pope during the refereeing process
09:04:57 <quicksilver> beelsebob: unpublished work, that is
09:04:57 * earthy concurs
09:05:04 <beelsebob> sounds reasonable
09:05:08 <beelsebob> :)
09:05:11 <quicksilver> beelsebob: it is no crime to be unaware of other work, especially if it's unpublished...
09:05:12 * beelsebob is much happier now
09:05:19 <shiruken> crazy
09:05:22 <vincenz> quicksilver: "especially" :)
09:05:25 <earthy> I mean, you actually went through the trouble of writing it up for publication. ;)
09:05:26 <shiruken> if it's unpublished, it doesn't exist
09:05:29 * beelsebob was getting very worried that his PhD had disapeared down the toilet
09:05:32 <LeCamarade> *nod*
09:05:38 <beelsebob> which I imagine is where Bernie Pope was coming from too
09:05:39 <vincenz> beelsebob: surely you have other publications?
09:05:40 <ndm> beelsebob: i think you can probably be fine for hte ICFP, I thought he published ages ago, but that sounds not to be the case
09:05:43 <earthy> beelsebob: ah, you'll have to think of better ideas. :)
09:05:47 <earthy> as will he. ;)
09:05:52 <ndm> beelsebob: your phd will require a bit more thought, and a thorough read of his
09:05:56 <shiruken> publish first
09:06:07 <quicksilver> beelsebob: I'm sure there will be *loads* of interesting developments and ideas which will flesh out a thesis
09:06:09 <beelsebob> earthy: I'm sure I will, but I have 3 months left of funding :P
09:06:16 <beelsebob> quicksilver: hopefully
09:06:19 <quicksilver> beelsebob: debugging higher-order programs is a massive field and hardly scratched...
09:06:21 <earthy> ndm: which is somewhat hard if his isn't submitted yet
09:06:32 <beelsebob> quicksilver: indeed it is -- and there's lots to go on yet
09:06:34 <vincenz> beelsebob: you have other publications, no?
09:06:35 <earthy> there's a *great* PhD thesis on Dynamic in Clean... somewhere
09:06:37 <beelsebob> I have many directions to look at
09:06:40 <mdmkolbe|work> what is ':force'?  (Seen in some of the commit messages)
09:06:40 <earthy> never been submitted though
09:06:44 <ndm> earthy: but it will be by the time bob submitts...
09:06:52 <earthy> ndm: it may be. :)
09:06:52 <beelsebob> vincenz: well, the same idea was in the pre-proceedings for IFL last year
09:07:19 <beelsebob> but didn't get accepted (due to the lack of the now present proof of soundness)
09:07:26 * vincenz nods
09:07:39 * vincenz 's phd spans three topics :|
09:07:45 <beelsebob> yeh
09:07:52 <beelsebob> I have another topic that ties in nicely
09:08:01 <beelsebob> but it in it's self would not make up a thesis
09:08:03 <vincenz> well they don't tie in as nicely as I would like :)
09:08:13 <beelsebob> unfortunate :(
09:08:17 * ndm also has 3 topics
09:08:23 <beelsebob> mine started as being two completely independant topics
09:08:24 <ndm> speed, safety, succinct
09:08:31 <beelsebob> but seem to have joined together rather neatly
09:08:55 * earthy 's PhD tanked...
09:09:03 <vincenz> tanked
09:09:04 <vincenz> ?
09:09:05 <earthy> cue failure music
09:09:13 <beelsebob> that sucks :(
09:09:16 <beelsebob> what went wrong?
09:09:17 * vincenz would like to move to UK post phd
09:09:25 <beelsebob> where are you now?
09:09:29 <vincenz> .be
09:09:32 <Syzygy-> HERE!
09:09:35 <beelsebob> lol
09:09:35 <Syzygy-> beelsebob: http://www.phdcomics.com/comics/archive.php?comicid=789
09:09:37 <lambdabot> Title: Piled Higher and Deeper
09:09:38 * earthy isn't too good at doing theory
09:09:41 <Syzygy-> Damn that took some time to find.
09:09:44 * earthy needed more theory than available
09:09:55 <earthy> hence *mighty* slow progress
09:09:56 <vincenz> Syzygy-: hehe :)
09:09:57 <beelsebob> Syzygy-: hehe, perfect
09:10:03 <earthy> and strong demotivation
09:10:05 <vincenz> earthy: what was it on?
09:10:14 <beelsebob> earthy: yeh, I'm hitting the demotivation bit at the moment
09:10:26 <matthew-_> beelsebob: which year are you in?
09:10:26 <earthy> soundness-preserving combination of programming language concepts
09:10:40 <beelsebob> matthew-_: in theory I should be submitting in 3 months time
09:10:45 <beelsebob> that though is theory
09:10:46 <Syzygy-> beelsebob: Good luck.
09:10:50 <beelsebob> and I expect it'll be more like 9 months
09:10:59 <matthew-_> ahh. ok, I'm only 7 months in and have motivation issues
09:11:06 <beelsebob> so did I
09:11:14 <beelsebob> not quite as bad as they've got though
09:11:14 <vincenz> matthew-_: that's normal
09:11:20 <beelsebob> I think you just have to struggle through it
09:11:20 <quicksilver> in my experience this experience (PhD already written by someone else) is relatively uncommon, which I think is due to the fact that most CS fields are small, and the people know what each other (and each other's students) are working on
09:11:21 <earthy> i.e.: try to extend the well-known monadic formulations of programming language semantics such that soundness proofs can be transported through the composition
09:11:22 <vincenz> matthew-_: welcome to the phd-rollercoaster ride
09:11:43 <quicksilver> I finished mine in about 3 years and 8 months, as I recall
09:11:52 <vincenz> quicksilver: what topic?
09:11:52 * Syzygy- has the HIGH benefit of having very high residual motivation.
09:11:53 * earthy dropped out at the 3 year mark
09:11:55 <quicksilver> which was pretty good, by local standards
09:11:55 <vincenz> earthy: sounds interesting
09:12:00 <beelsebob> quicksilver: that appears to be about what I'm looking at
09:12:06 <beelsebob> what was yours on?
09:12:12 <Syzygy-> And people seem to find what I do quite sexy. To the extent that I'm surprised at the reactions I get from my research community.
09:12:14 <earthy> vincenz: oh, it was, it just involved too much heavy category theory lifting
09:12:14 * vincenz hopes to finish in a year, after 4 years (which is short by stds here)
09:12:15 <quicksilver> vincenz, beelsebob: proofs in the logic of bunched implications
09:12:21 <beelsebob> o.O
09:12:23 <beelsebob> scary
09:12:26 <vincenz> quicksilver: oh, so you worked closely with reynolds?
09:12:39 <beelsebob> vincenz: you got an std for 4 years?
09:12:40 <beelsebob> :P
09:12:43 <quicksilver> vincenz: not *that* closely, he's mostly in the US and I'm in the UK. We chatted a few times though.
09:12:47 <vincenz> beelsebob: yeah, most people do 4.5
09:12:48 <quicksilver> (smart man, that one)
09:12:56 <shapr> Syzygy-: What are you doing? I want to see sexy PhDs!
09:13:01 <vincenz> quicksilver: there was another name working on BIs, forgot it, tho
09:13:12 <earthy> yah, default PhD funding trajects in .nl are 4 years as well, but you have to do 20% of ta'ing
09:13:13 <Syzygy-> Here, fulltimers are suposed to do their phd in 2 years. I hope to get 3-4, but I'm teaching too.
09:13:13 <quicksilver> vincenz: Pym, O'Hearn, Calcagno, Berdine
09:13:21 <vincenz> quicksilver: whiche one are you?
09:13:24 <quicksilver> vincenz: Bean
09:13:26 <Syzygy-> shapr: A-infinity algebra structures in group cohomology, and computational aspects thereof.
09:13:29 <vincenz> Mr?
09:13:37 <quicksilver> indeed :)
09:13:50 <shapr> Syzygy-: Um, ok.
09:14:02 <shapr> The computational aspects part might interest me.
09:14:04 * earthy looks at a screenful of boilerplate mess
09:14:04 <Syzygy-> shapr: By people, of course, I meant "members of my research community". And by sexy, I meant "very, very interesting. Almost spectacularily so."
09:14:07 <shapr> But I have no idea what those things are.
09:14:15 <shapr> Syzygy-: Yeah, I understand.
09:14:27 <Syzygy-> shapr: Basically, I want to see whether I can get a New Shiny algorithm for calculations in homological algebra by using homotopy techniques.
09:14:31 <vincenz> quicksilver: so what do you do now?
09:14:41 <Syzygy-> This New Shiny seems to also end up being Much Slower, though.
09:14:50 <quicksilver> vincenz: I'm a perl programmer in a financial company
09:15:02 <chessguy> hey Syzygy- , nice article on math blogging the other day
09:15:05 <chessguy> Syzygy-++
09:15:15 <earthy> anyway, time to go hug the gf, back home
09:15:27 <Syzygy-> chessguy: Thanks.
09:15:31 <Syzygy-> @karma
09:15:31 <lambdabot> You have a karma of 3
09:15:35 <Syzygy-> Woots!
09:15:39 <beelsebob> woots?
09:15:42 <earthy> drat. :)
09:15:51 <Syzygy-> beelsebob: I got more karma. Hence the woots.
09:15:51 <earthy> a mathemagician with higher karma than me :)
09:15:57 <chessguy> i'm curious, you said you basically translate topological questions to algebraic ones? is that pretty accurate?
09:15:59 <beelsebob> Syzygy-: ah, I see
09:16:03 <shapr> @karma+ Syzygy- -- cool blog posts
09:16:03 <lambdabot> Syzygy-'s karma raised to 4.
09:16:06 <vincenz> quicksilver: why not stick to academia?
09:16:30 <Syzygy-> chessguy: The german mathematical community is just discovering blogs. And they pulled me into the workgroup for information and communication of the german mathematical society. So I'm basically supposed to preach the Blog Gospel to german mathematics.
09:16:41 <Syzygy-> This was one of the sideeffects of that.
09:16:42 <quicksilver> vincenz: short story: tried. failed.
09:16:50 <quicksilver> vincenz: didn't get the research post I was hoping for
09:16:51 <norpan> @karma
09:16:52 <lambdabot> You have a karma of -1
09:16:56 <norpan> that's not much
09:17:11 <Syzygy-> Yikes.
09:17:17 <vincenz> quicksilver: ah :/
09:17:21 <Syzygy-> norpan++ -- pity the negatives
09:17:26 <Syzygy-> @karma norpan
09:17:27 <lambdabot> norpan has a karma of 0
09:17:29 <Syzygy-> That's better.
09:17:38 <earthy> financial perl... that kinda boggles the mind.
09:17:40 <chessguy> is that a fair summary of the work you do though?
09:18:00 <norpan> well, at least -1 is something. 0 is ... nothing
09:18:10 <quicksilver> earthy: more common than you might imagine
09:18:10 <vincenz> norpan-- -- There you go :)
09:18:14 <Syzygy-> @karma- norpan -- if you insist
09:18:14 <lambdabot> norpan's karma lowered to -2.
09:18:17 <vincenz> haha
09:18:22 <quicksilver> earthy: there are very few large banking organisations with no perl in them
09:18:36 <hpaste>  matthew-_ annotated "bother. I'd hoped this would explode." with "what?! How are these duplicates?" at http://hpaste.org/1669#a1
09:18:37 <vincenz> quicksilver: heh, I worked at one that had .. tons of .. .COBOL!
09:18:38 <quicksilver> perl is, in fact, the duct tape of the world :)
09:18:46 * Syzygy- is happy that karma shots stick to me nowadays. My nick triggered a bug in the karma code back when.
09:18:47 <earthy> quicksilver: I know. kinda. ;)
09:19:14 <quicksilver> well yes, most large organisations have an incredibly diverse mixture over 30-40 years of computing legacy
09:19:22 <earthy> there's a number of fairly well-known perl mongers in my direct vicinity
09:19:57 <vincenz> funny you never see articles like "Perl Pearl"
09:20:07 <matthew-_> I really can't work out why ghc thinks these are duplicate instance declarations...
09:20:23 <earthy> that's perl golf :)
09:20:25 <earthy> anyway
09:22:13 <Maddas> vincenz: You mean like 'Pearls of Perl'? :-)
09:22:47 <vincenz> Maddas: really?
09:23:00 <vincenz> *woosh*, there goes my point
09:24:12 <Maddas> ;-)
09:25:34 <LeCamarade> earthy: By the way, Haskell Golf would be much fun.
09:25:34 <mdmkolbe|work> matthew-_: I suspect they are duplicates b/c both r and s are type variables, and thus could be the same.
09:25:47 <LeCamarade> We do it here, at #haskell, everyday.
09:26:01 <norpan> why golf?
09:26:41 <matthew-_> mdmkolbe|work: right, that makes sense as it wouldn't be able to resolve which instance to use...
09:27:04 <mdmkolbe|work> norpan: do you mean "why is it called golf" or "why do people golf"?
09:27:55 <vincenz> most likely the first, but that's just a guess
09:28:02 <quicksilver> matthew-_: you can try a mictgure of incoherent and undecideable instances
09:28:10 <quicksilver> matthew-_: and see if it can get the one you mean
09:28:19 <quicksilver> matthew-_: or you can send a mail to -cafe and get oleg to explain to you a better way
09:28:28 <quicksilver> (for there surely is one, and oleg surely knows it)
09:31:48 <matthew-_> gah, this type level computation stuff's a right pain as there's no way to test it without building lots of code...
09:31:52 <kc5tja> In the game of golf, the winner is that which has the lowest score, not the highest (minimum number of strokes to get the ball into the hole).  In Perl Golf, and other kinds of (insert-favorite-programming-language-here) golf, the goal is to achieve some goal in the minimum number of characters typed.
09:32:04 <osfameron> eeek!  there is haskell golf too?
09:32:07 * osfameron phears
09:32:37 <kc5tja> osfameron: I wouldn't be so afraid.  You can beat almost anyone at their own game by learning J or K.  ;D
09:32:48 <osfameron> J?  K?
09:33:09 <kc5tja> @google j apl language
09:33:12 <lambdabot> http://en.wikipedia.org/wiki/APL_(programming_language)
09:33:15 <osfameron> ah
09:33:25 <osfameron> ok, well haskell is already pretty compact by most standards
09:33:32 <fax> J is fantastic, but very hard
09:34:06 <quicksilver> haskell golf is very difficult, because haskell lacks the kind of syntactic tricks and shortcuts and aliases that perl golf relies on
09:34:08 <kc5tja> fax: Hard in what way?  I rather like J; however, I do tend to take the "NEV4R UZ SPACEZ!" mentality and throw it out the window.
09:34:44 <fax> I find the function composition rules difficult to remember
09:34:52 <fax> (so I have this http://rafb.net/p/5AVe8N31.txt )
09:35:15 <osfameron> quicksilver: well I guess things like $ being shorter than () and so on ?
09:35:43 <fax> kc5tja: how do you learn J?
09:36:07 <beelsebob> osfameron: $ isn't shorter than ()
09:36:22 <beelsebob> f $ g x
09:36:22 <beelsebob> f (g x)
09:36:26 <beelsebob> exactly the same length
09:36:40 <osfameron> good point!
09:36:47 <quicksilver> osfameron: yes, but there really isn't much scope there
09:36:54 <quicksilver> f$g x
09:36:57 <quicksilver> f(g x)
09:37:00 <quicksilver> 1 char longer
09:37:04 <kc5tja> fax: I just explored various tutorial sites, played along, then started tinkering on stuff on my own.
09:37:12 <osfameron> ah, even better point ;-)
09:37:15 <beelsebob> I do think that f $ g x is often clearer than f (g x), but not shorter
09:37:15 <hpaste>  toyvo pasted "R monad - Randoms" at http://hpaste.org/1670
09:37:15 <quicksilver> golfers don't use un-necessary spaces :P
09:37:15 <matthew-_> quicksilver: so long as you don't need -fth !
09:37:24 <fax> kc5tja: I stayed up 2 days reading about it obsessivly :p
09:37:39 <fax> so I guess ill continue trying stuff and doing tutorials :)
09:37:41 <assl0r> how do i swap elements of a list?
09:37:48 <kc5tja> fax: I didn't quite come that far, but close.  I still have to go through Iverson's book on calculus though.
09:37:59 <fax> oh yeah
09:38:12 <quicksilver> matthew-_: ?
09:38:13 <kc5tja> I read the first couple of chapters, which were very enlightening.
09:38:16 <fax> I checked it out but I think I should read a conventional book first, or my brain might get twisted
09:38:29 <kc5tja> The fact that there isn't a limit anywhere in the definition of a derivate is fascinating.
09:38:42 <fax> :O
09:38:49 <fax> I didnt see that section
09:38:57 <kc5tja> The book is intended for those who find limits to be brick walls of illogic.
09:39:01 <kc5tja> ??
09:39:04 <kc5tja> Chapter 1!  :)
09:39:09 <LeCamarade> assl0r: Swap? Like [1, 2] becoming [2, 1]?
09:39:28 <matthew-_> quicksilver: well if you've got TH on, then won't f$g x get interpreted as a splice of g ?
09:39:35 <norpan> how is the derivate defined then
09:39:40 <kc5tja> He does use J as a notation in the book though, so you can execute them on the computer if needed.
09:40:06 <kc5tja> norpan: Through algebraic manipulation exclusively -- using polynomials.
09:40:11 <assl0r> LeCamarade, yes
09:40:16 <quicksilver> matthew-_: ah, right
09:40:28 <quicksilver> matthew-_: hmm maybe TH would be a good way to approach haskell golf
09:40:29 <norpan> kc5tja: so, only working for polynomial functions?
09:40:47 <assl0r> LeCamarade, e.g swap the elements (x:xs)
09:40:48 <kc5tja> No.
09:41:00 <quicksilver> assl0r: but 'x' and 'xs' aren't elements
09:41:08 <quicksilver> assl0r: 'x' is an element, but 'xs' is a list of elements...
09:41:17 <assl0r> ah ok..
09:41:18 <kc5tja> norpan: The usual equation f(x+e)-f(x)/e is used, but it's solved algebraically, not with limits.
09:41:30 <LeCamarade> > reverse [1 .. 5]
09:41:34 <lambdabot>  [5,4,3,2,1]
09:41:37 <osfameron> I find $ very unclear, but that may be due to overloading of "$" in Perl
09:41:44 <LoganCapaldo> How do you solve that algebraically for arbitrary f?
09:41:45 <LeCamarade> assl0r: That's the closest.
09:41:49 <assl0r> LeCamarade, its not that simple :)
09:42:02 <LeCamarade> Lists can have more that one elem, so swap should be reverse.
09:42:12 <LeCamarade> Give me a sample run, then.
09:42:15 * LoganCapaldo feels a "go read the book" coming on
09:42:52 <LeCamarade> assl0r: Give me sample input and output.
09:43:04 <assl0r> i want to swap `even` elements with uneven
09:43:48 <chessguy> osfameron: whenever you see $ just imagine parentheses around the rest of the line
09:43:51 <LeCamarade> assl0r: Yeah, so you mean to put even elements where odds are, and odds where evens are?
09:44:06 <assl0r> yeah, swapping ;)
09:44:20 <quicksilver> osfameron: $ is like the 'church dot' in a sense
09:44:24 <osfameron> chessguy: yeah, I understand what it does kinda, just, er, not really why.  I have used it (once) in anger
09:44:30 <shapr> Lemmih: ping
09:44:38 <ddarius> > let f (x:y:xs) = y:x:f xs; f [] = [] in f [0..10]
09:44:40 <lambdabot>   Non-exhaustive patterns in function f
09:44:43 <chessguy> ?src ($)
09:44:43 <lambdabot> f $ x = f x
09:44:44 <norpan> assl0r: you can use the pattern (x:y:xs)
09:44:48 <ddarius> > let f (x:y:xs) = y:x:f xs; f [] = [] in f [0..9]
09:44:49 <chessguy> it doesn't 'do' anything.
09:44:51 <lambdabot>  [1,0,3,2,5,4,7,6,9,8]
09:44:51 <osfameron> it's handy when editing an expression on a slow internet tablet touchscreen... less stuff to change at the RHS of the expression...
09:45:02 <quicksilver> osfameron: there are two main groups of reasons to use $
09:45:09 <chessguy> it just changes the fixity
09:45:11 <norpan> ddarius: use f xs = xs instead as base case :)
09:45:14 <LeCamarade> assl0r: Oh. :oD But, still, I may have ...
09:45:15 <quicksilver> osfameron: (1) to use fewer parens in an expression
09:45:19 <chessguy> ermm, i don't think fixity is the word i want
09:45:22 <LeCamarade> > [1, 3 .. 9]
09:45:24 <lambdabot>  [1,3,5,7,9]
09:45:24 <quicksilver> assl0r: (2) to use $ as a higher-order function
09:45:28 <LeCamarade> How do youy swap that?
09:45:32 <quicksilver> osfameron: (2) to use $ as a higher-order function
09:45:39 <chessguy> precedence, i guess
09:45:47 <quicksilver> osfameron: the second reason is more convincing than the first, for me :)
09:45:50 <osfameron> what does it do as HO ?
09:46:04 <quicksilver> > map ($1) [(+1),(*2),(/2)]
09:46:06 <lambdabot>  [2.0,2.0,0.5]
09:46:11 <quicksilver> try that without $ :)
09:46:17 <osfameron> quicksilver: yeah, the "replace parens which you know and breathe from every language you've ever learnt with... a $ sign" argument doesn't really work for me with readability
09:46:29 <chessguy> osfameron: it's much less used for higher-order runctionality
09:46:33 <ddarius> quicksilver: Except there is another function that is equal to ($)
09:46:39 <osfameron> quicksilver: I don't even understand what that's doing
09:46:41 <quicksilver> ddarius: yes, but that's obfuscated
09:46:47 <quicksilver> osfameron: it's applying those three functions to 1
09:46:49 <ddarius> quicksilver: I agree.
09:46:57 <quicksilver> osfameron: ($1) is the section 'apply to 1'
09:47:04 <chessguy>  > map ($! 1) [(+1),(*2),(/2)]
09:47:10 <chessguy> > map ($! 1) [(+1),(*2),(/2)]
09:47:13 <lambdabot>  [2.0,2.0,0.5]
09:47:16 * shapr sighs
09:47:17 <chessguy> ha!
09:47:18 <mdmkolbe|work> ?src first
09:47:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:47:23 <osfameron> what's $! ?
09:47:28 <quicksilver> osfameron: strict version
09:47:34 <osfameron> @src $!
09:47:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:47:41 <chessguy> @src ($!)
09:47:43 <lambdabot> Source not found. Do you think like you type?
09:48:00 <norpan> why is lambdabot being rude
09:48:07 <quicksilver> f $! x = x `seq` f x, AFAIK
09:48:16 <mdmkolbe|work> ?src pure
09:48:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:48:20 <mdmkolbe|work> ?src first
09:48:21 <lambdabot> Source not found. Do you think like you type?
09:48:25 <osfameron> @src ($)
09:48:26 <lambdabot> f $ x = f x
09:48:38 <osfameron> ok, so the 1 is x above
09:48:44 <quicksilver> osfameron: yes
09:49:04 <osfameron> ok, that's cute, there is a question in SOE on how to write that (though it's not expecting that answer at that stage I wouldn't have thoughT)
09:49:08 <quicksilver> > map ($5) [(*2),(*3),(/2),(/3)]
09:49:10 <lambdabot>  [10.0,15.0,2.5,1.6666666666666667]
09:49:21 <quicksilver> osfameron: quite a common question on this channel actually
09:49:31 <quicksilver> osfameron: how do I apply a list of functions to a value
09:49:43 <quicksilver> osfameron: another one is "how do I apply a list of functions to a list of values"
09:49:48 <quicksilver> osfameron: which is zipWith ($)
09:50:00 <osfameron> really?  I can understand "how do I apply a pipeline of of functions to a value"
09:50:00 <quicksilver> osfameron: assuming they meant 'applying corresponding functions to corresponding values'
09:50:07 <fax> > zipWith ($) [1..]
09:50:09 <osfameron> ok
09:50:11 <lambdabot>   add an instance declaration for (Num (a -> b))
09:50:11 <lambdabot>     In the expression: 1
09:50:15 <fax> >:[
09:50:23 <LoganCapaldo> :t zipWith (\f x -> f x)
09:50:25 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
09:50:36 <quicksilver> :t zipWith ($)
09:50:39 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
09:50:49 <fax> hoho
09:51:04 * LoganCapaldo wonders why it chose b
09:51:07 <kc5tja> :t zipWith
09:51:07 <quicksilver> the type says it all, with that one :)
09:51:07 <fax> > zipWith (\f x -> f x) [1..]
09:51:10 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:51:10 <lambdabot>   add an instance declaration for (Num (b -> c))
09:51:10 <lambdabot>     In the expression: 1
09:51:36 <quicksilver> fax: it needs a list of functions and a list of value
09:51:51 <fax> > zipWith (repeat (\f x -> f x)) [1..]
09:51:53 <lambdabot>  Couldn't match expected type `a -> b -> c'
09:51:54 <quicksilver> > zipWith ($) [(+1),(*2),(/2)] [5.0,10.0,6.0]
09:51:55 <fax> :(
09:51:57 <lambdabot>  [6.0,20.0,3.0]
09:52:01 <Saizan> ?hoogle Element -> String
09:52:02 <lambdabot> No matches, try a more general search
09:52:10 <norpan> and of course the answer is not "map ($value) functionlist", but "sequence functionlist value"
09:52:34 <quicksilver> norpan: I don't really agree :) except for cuteness value
09:52:44 <LoganCapaldo> Saizan: show?
09:52:47 <ddarius> fax: \f x -> f x doesn't suggest something to you?
09:53:06 <fax> how do you make [[[[[[[infinity,1],1],1],1],1],1],1]
09:53:16 <LoganCapaldo> you can't
09:53:16 <ddarius> fax: You don't.
09:53:21 <fax> damn
09:53:27 <quicksilver> let x = [x,1] in x
09:53:30 <quicksilver> sure you do :)
09:53:30 <norpan> of course you can
09:53:31 <ddarius> :t fix (\x -> [x,1])
09:53:33 <LoganCapaldo> lists must be homogenous
09:53:34 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
09:53:34 <lambdabot>       Expected type: t
09:53:38 <quicksilver> it may not type, but you can do it :)
09:53:43 <fax> what does homogenous mean in a list?
09:53:49 <quicksilver> fax: each element at the same type
09:53:52 <norpan> all elements must have the same type
09:54:01 <quicksilver> but it's not just homogeneity that's the problem
09:54:05 <fax> each element is type X
09:54:08 <quicksilver> :t let x = (x,1) in x
09:54:09 <fax> X = [X,1]
09:54:11 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t1)
09:54:11 <lambdabot>       Expected type: t
09:54:19 <quicksilver> even with tuples, it's still an infinite type
09:54:19 <fax> > let x = [x,x] in x
09:54:21 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
09:54:21 <lambdabot>       Expected...
09:54:28 <fax> argh
09:54:28 <norpan> fax: but what type is X?
09:54:32 <Cale> fax: So 1 has the same type as well.
09:54:32 <fax> norpan: made of X
09:54:36 <assl0r> norpan, your method of swapping uneven elements is nice, but it fails for lists with uneven number of elements
09:54:41 <fax> recursive types are ok?
09:54:43 <norpan> there is no such type
09:54:44 <assl0r> pattern matching error
09:54:46 <Cale> > let x = [x] in x
09:54:47 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
09:54:47 <lambdabot>       Expected...
09:54:49 <norpan> assl0r: my method?
09:54:55 <fax> turn off occurs check :\
09:54:59 <quicksilver> fax: recursive types can be build using algebraic data types, but aren't automatically inferred
09:55:06 <fax> quicksilver: oh ok
09:55:10 <hpaste>  saucisson pasted "memory blow up" at http://hpaste.org/1671
09:55:11 <assl0r> ah sorry norpan
09:55:16 <quicksilver> if you infer recursive types, then ever expression type-checks
09:55:23 <quicksilver> which makes your type-checker less useful :)
09:55:28 <fax> so its impossiblke to make ... = [[[...],[...]],[[...],[...]]]
09:55:30 <norpan> assl0r: just replace f [] = [] with f xs = xs as i said
09:55:31 <assl0r> ddarius, it was your oneliner ;)
09:55:44 <assl0r> > let f (x:y:xs) = y:x:f xs; f [] = [] in f [0..9]
09:55:46 <lambdabot>  [1,0,3,2,5,4,7,6,9,8]
09:56:05 <LoganCapaldo> you can have lists of lists, just not an infinitely deep list of lists
09:56:13 <LoganCapaldo> > [[1,2], [3,4]]
09:56:15 <lambdabot>  [[1,2],[3,4]]
09:56:15 <fax> ack
09:56:16 <saucisson> could someone explain me why the code posted at http://hpaste.org/1671 causes a memory blow up, please ?
09:56:27 <fax> why can you have infinite lists but not infinitly deep lists?
09:56:37 <norpan> fax: because you can't have infinite types
09:56:44 <ddarius> fax: Use trees.
09:57:01 <assl0r> swapuneven (x:y:xs) = y:x:swapuneven xs
09:57:07 <norpan> you can have infinite types if you define your own algebraic datatype
09:57:12 <fax> ooh
09:57:12 <assl0r> works for even element count
09:57:15 <ddarius> If you want to nest lists arbitrarily, you want rose trees.
09:57:22 <fax> rose trees?
09:57:24 <fax> oh man
09:57:28 <ddarius> @src Tree
09:57:29 <lambdabot> Source not found. Wrong!  You cheating scum!
09:57:35 <ddarius> @src Data.Tree
09:57:36 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:57:39 <fax> why aer the haskell books so basic ... :/
09:57:39 <ddarius> @src Data.Tree.Tree
09:57:40 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:58:11 <kc5tja> Ahhhh.....suddenly, it's peaceful in here now that lambdabot is ignored.
09:59:13 <osfameron> I don't understand why such a helpful bot is programmed to respond so rudely
09:59:51 <chessguy> @type [0 .. ]
09:59:54 <lambdabot> forall t. (Num t, Enum t) => [t]
10:00:04 <LoganCapaldo> It's because everyone else in this channel is nice. It brings balance to the universe
10:00:13 <osfameron> aha!
10:00:28 <osfameron> curses!  I'm not in London for the haskell meeting
10:00:36 <assl0r> >even 1
10:00:43 <osfameron> but I get to make tomorrow's Perl (e.g. beer) meet
10:00:54 <assl0r> > even 1
10:00:56 <lambdabot>  False
10:01:09 <LoganCapaldo> > (even 0, odd 0)
10:01:11 <lambdabot>  (True,False)
10:01:17 <LoganCapaldo> 0 is even eh?
10:01:53 <LoganCapaldo> Is that a "mathematical truth" or just an acicdent of the implementation?
10:02:03 <LoganCapaldo> @src odd
10:02:04 <lambdabot> odd = not . even
10:02:38 <quicksilver> LoganCapaldo: mathematical truth
10:02:39 <LoganCapaldo> @src even
10:02:40 <lambdabot> even n = n `rem` 2 == 0
10:02:47 <quicksilver> LoganCapaldo: I've never seen anyone claim 0 wasn't even
10:02:59 <LoganCapaldo> k
10:03:04 <norpan> 0 is even
10:03:16 * LoganCapaldo felt like it was neither, but I've been wrong before
10:03:20 <norpan> otherwise a lot of things doesn't work
10:03:26 <norpan> don't?
10:04:16 <chessguy> the definition of even is that n is even iff n = 2*k for some integer k. since 0 is an integer, it follows very obviously that it's also even
10:04:23 <assl0r> > sum [1..]
10:04:27 <lambdabot> Terminated
10:05:23 <saucisson> can someone using GHC explain me why the small code pasted at http://hpaste.org/1671 does a memory blow up, please ?
10:05:58 <chessguy> saucisson: i wonder if it's defaulting to Int instead of Integer and overflowing.
10:05:59 <norpan> saucisson: because it keeps a gigantic list of integers in memory?
10:06:15 <saucisson> but then, why without the last line it does not ?
10:06:33 <norpan> because then list will not be used more than once and can be garbage collected
10:09:23 <saucisson> norpan: thanks, how does garbage collection occur within List.map to avoid storing the gigantic list ?
10:10:15 <norpan> saucisson: lazy evaluation will do it for you
10:10:42 <norpan> ... !! e will start working on the list, processing and dropping one element at a time
10:10:48 <norpan> so it should run in constant space
10:11:10 <norpan> as long as you don't need to store the list, which you do in the second line of main
10:11:49 <saucisson> norpan: why does the second line store the list ? i don't understand the difference
10:12:10 <norpan> because then main need to keep a reference to list and cannot garbage collect the elements of it
10:12:15 <LoganCapaldo> well storing the list is the whole point of memoizing it, is it not?
10:12:32 <norpan> yes, memoizing comes with a memory cost
10:13:34 <norpan> but this example is not a good example of memoizing
10:13:35 <LoganCapaldo> Although I don't see what you are gaining by memoizing x * 2
10:13:49 <norpan> and x * 2 is not even memoized
10:14:03 <LoganCapaldo> yeah
10:14:11 <LoganCapaldo> it's not for that matter
10:14:58 <norpan> saucisson: i think you need to think about what you are trying to achieve here :)
10:15:25 <sjanssen> saucisson: in a non-optimizing compiler, your program would blow up with or without the last line
10:15:41 <saucisson> norpan: in fact it was only an example to try what i read...
10:15:58 <sjanssen> because Haskell compilers are supposed to hold on to (memoize) top level bindings
10:16:29 <norpan> even if there are no more uses of them?
10:16:44 <LoganCapaldo> well that's the optimizing part, isn't it?
10:16:58 <sjanssen> but GHC is smart enough to see that the variable is used only once (when you comment out that second line), and throw it away immediately
10:18:05 <norpan> but if the type of list was Num a => [a] it couldn't keep it, right?
10:18:27 <sjanssen> probably
10:18:40 <norpan> or is it supposed to specialize?
10:18:45 <sjanssen> unless GHC does specialization in that case
10:18:58 <norpan> i hope not
10:19:54 <sjanssen> saucisson: the solution to your problem is to put list = [0..] in a local where binding, rather than a top level
10:20:09 <sjanssen> (and hope that GHC doesn't do any let-floating)
10:20:11 <malcolmw> beelsebob: just seen your panic about Bernie Pope's thesis
10:20:22 <saucisson> let-floating ? what is it ?
10:20:55 <sjanssen> saucisson: turning a local binding to a global
10:21:06 <malcolmw> beelsebob: what overlap is there with your work?  I thought he just covered algorithmic debugging, using a transformational approach like Hat
10:21:45 <malcolmw> beelsebob: i.e. nothing on delta-debugging
10:22:24 <beelsebob> malcolmw: pretty much everything
10:22:28 <beelsebob> all the functional maps stuff
10:22:31 <beelsebob> the FDT
10:22:39 <beelsebob> only thing he said he hadn't done is the soundness proof
10:22:41 <beelsebob> and that's Olaf's work
10:23:03 <malcolmw> beelsebob: ah, well, your paper without the soundness proof wasn't accepted
10:23:18 <beelsebob> malcolmw: tis not the paper he's submitting
10:23:19 <malcolmw> beelsebob: so presumably that is a good addition
10:23:22 <beelsebob> it's his PhD
10:23:32 <beelsebob> and there were other reasons for the rejection
10:23:36 <beelsebob> that was just the primary one
10:23:38 <assl0r> is it possible to bleed off else blocks?
10:23:43 <saucisson> sjanssen: but using two local lists disables reuse of computation result, or am i wrong ?
10:23:55 <beelsebob> malcolmw: I *think* it comes down to a race to publish
10:23:57 <beelsebob> which is an arse
10:24:06 <beelsebob> because it probably means one of us will lose our PhD in the process
10:24:10 <malcolmw> beelsebob: I remember back when heap profiling was all the rage
10:24:26 <malcolmw> beelsebob: there was a guy at Glasgow doing a PhD on it
10:24:34 <sjanssen> saucisson: you don't want to share the result of 'list' it's very trivial to compute
10:24:43 <shapr> beelsebob: Maybe you guys could collaborate instead? It's happened before where two people did one PhD. Fudgets maybe?
10:24:46 <malcolmw> beelsebob: and CR + DW at York published the same stuff first
10:25:01 <beelsebob> shapr: possibly
10:25:09 <beelsebob> he did appear to be suggesting something along those lines
10:25:10 <malcolmw> beelsebob: but the Glasgow guy still got his PhD
10:25:16 <beelsebob> malcolmw: cool :)
10:25:35 <shapr> Bernie is a cool guy, I met him once.
10:25:44 <sjanssen> saucisson: the strain put on the garbage collector when allocating this huge list is much more expensive than recomputing [0..]
10:25:49 <malcolmw> beelsebob: and several other people working on the same thing published papers claiming to do it in a different way (but they weren't really different that I could tell)
10:25:49 <beelsebob> malcolmw: my hope is that my paper gets into ICFP, because I don't think that would have as large repercussions for his PhD as him publishing his PhD before I get it out the door
10:26:43 <saucisson> sjanssen: i was interrested in not recomputing the function...
10:26:52 <shapr> While rebuilding my kernel, I really wish TMR had a text version as well.
10:27:10 <malcolmw> beelsebob: even if your paper was identical material to his PhD, that would not prevent it being published at ICFP
10:27:19 <malcolmw> beelsebob: for one thing, there is independent invention
10:28:00 <beelsebob> malcolmw: true, but there may be a case of "should have gone after that relevant work"
10:28:08 <malcolmw> beelsebob: and for another, PhD theses are not widely available, and it is usually expected that the author should at least publish a conference/journal paper to summarise it, for wider distribution
10:28:39 <malcolmw> beelsebob: if no such published summary exists, then the expectation that you should know about the work is much less
10:28:55 <beelsebob> malcolmw: well, there's no summary of this as distinct from the normal EDT
10:29:01 <beelsebob> but there is a paper in which he does this
10:29:03 <sjanssen> > 100000000 * (4 + 4 + 4) / 2^20 -- this is how many megabytes ghc will need to allocate to hold on to that list
10:29:04 <beelsebob> and calls it the EDT
10:29:05 <lambdabot>  1144.4091796875
10:29:26 <sjanssen> saucisson: your approach requires more than a gigabyte of memory!
10:30:07 <beelsebob> malcolmw: I think we should be okay
10:30:22 <beelsebob> but was certainly nerve wracking when I thought he had already published
10:30:24 <malcolmw> beelsebob: yes, relax about it.
10:30:42 <beelsebob> I for some reason thought Bernie got his PhD many lots of years ago
10:31:04 <hpaste>  saucisson pasted "(no title)" at http://hpaste.org/1672
10:31:13 <LoganCapaldo> sjanssen: why not just 4 + 4 ?
10:31:28 <malcolmw> beelsebob: no, only a year or two at most
10:31:40 <beelsebob> malcolmw: I'm not sure he even has got it
10:31:51 <beelsebob> both his website and Lee Naish's say he's a postgrad student
10:31:53 <sjanssen> LoganCapaldo: constructor tag + head pointer + tail pointer
10:32:22 <sjanssen> my estimate is probably a bit low: I forgot the cost of storing the Ints
10:32:34 <sjanssen> saucisson: you'll see no sharing/memoization there
10:32:54 <LoganCapaldo> Oh I was just thinking Int + pointer to next element
10:33:11 <beelsebob> malcolmw: so my understanding that no one else in the debugging community appears to know about this work seems to be true, yeh?
10:33:24 <sjanssen> saucisson: do you realize that this approach will require more memory than most computers have?
10:33:38 <malcolmw> beelsebob: well of course we know about Bernie and Buddha,
10:33:42 <beelsebob> yeh
10:33:45 <beelsebob> as did I
10:33:52 <beelsebob> just had no idea he was working on functional maps
10:33:59 <malcolmw> beelsebob: but I wasn't aware it went any further than other algorithmic debuggers
10:34:05 <beelsebob> k
10:34:15 <saucisson> sjanssen: of course... the high numbers were only used to get computation time big enough to see if there was sharing of results or not
10:34:15 <beelsebob> oh well *crosses fingers*
10:34:26 <beelsebob> not much I can do but talk to him in a friendly way and carry on working
10:34:58 <saucisson> sjanssen: it seems i will have to use usual cache techniques
10:35:04 <malcolmw> beelsebob: don't get stressed about it.  talk to Olaf when he gets back.  be polite to Bernie.  don't do anything rash.
10:35:06 <sjanssen> saucisson: btw, you won't see any meaningful sharing if 'cache' takes the function as a parameter
10:35:22 <beelsebob> malcolmw: luckily haven't done yet :)
10:35:22 <sjanssen> saucisson: or use a more compact structure
10:35:49 <malcolmw> beelsebob: I expect Bernie is just worried that you are going to get the ICFP glory :-)
10:36:02 <beelsebob> malcolmw: heh :P
10:36:03 <saucisson> sjanssen: why is there no sharing if the function is a parameter (sorry i'm a haskell newbie) ?
10:36:20 <sjanssen> saucisson: like a bit trie -- O(log n) access time and memory used per element saved
10:36:53 <beelsebob> malcolmw: all of this of course rests on me actually getting accepted for ICFP
10:37:18 <saucisson> sjanssen: in my domain we use hash tables for quicker access to elements
10:37:27 <sjanssen> saucisson: generally, only top level bindings are shared -- you don't have a top level binding to "map function [0..]" anywhere in your program
10:37:59 <sjanssen> saucisson: a bit trie is at least better than the list approach :) O(n) access time and memory
10:38:17 <LoganCapaldo> Mmm brie
10:38:53 <beelsebob> mmmm deep fried brie
10:40:00 <unknown> say i have a datatype: data Vehicle = Bike Brand | Car Brand | Train  , now i want a function getBrand :: Vehicle -> ?   which gives me the Brand of the vehicle, if it has one, how can i do this?
10:40:13 <malcolmw> beelsebob: there's a guy who regularly attends ICFP who is famous for asking a question at the end of almost every talk, basically saying "I did everything you just described 7 years ago"
10:40:31 <beelsebob> malcolmw: o.O
10:40:32 <beelsebob> hehe
10:40:43 <dolio> Vehicle -> Maybe Brand, I'd say.
10:40:49 <hpaste>  sjanssen pasted "a more traditional example" at http://hpaste.org/1673
10:40:55 <Gwern> is there any straightforward way to get an infinite list of alphanumeric random strings? I'm looking around, and they all seem to be either alphebetical or numerical only in Random
10:41:13 <malcolmw> beelsebob: so you'll be in good company if you get in...
10:41:16 <LoganCapaldo> unknown: Vehicle -> Maybe Brand; getBrand v = case v of Bike b -> Just b ; Car b -> Just b ; _ -> Nothing
10:41:24 <sjanssen> saucisson: perhaps that example is more clear?
10:41:57 <sjanssen> saucisson: you have sharing of the computed numbers because they're stored in a top level variable called 'fibs'
10:42:03 <beelsebob> malcolmw: thankfully he can't submit to ICFP any more :P
10:42:08 <beelsebob> anyway, I must go buy foodage
10:42:25 <beelsebob> see you all later
10:42:37 <hpaste>  assl0r pasted "(no title)" at http://hpaste.org/1674
10:42:43 <saucisson> sjanssen: ok now i see
10:43:04 <assl0r> may somebody tell me, how to make this little debug statement work? ;)
10:43:24 <dolio> Gwern: filter isAlphaNum (randomRs ('0', 'z')) ?
10:43:54 <LoganCapaldo> unsafePerformIO? :)
10:44:05 <Gwern> dolio: I'll try that
10:44:05 <sjanssen> @slap LoganCapaldo
10:44:06 <lambdabot> why on earth would I slap LoganCapaldo
10:44:15 <LoganCapaldo> @docs Debug.Trace
10:44:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
10:44:16 <unknown> LoganCapaldo: thanks
10:44:22 <dolio> Gwern: That'll give you one infinite string. You could slice it up if you need a list of strings.
10:45:13 <dolio> Gwern: There should be a random gen parameter in there, too. (randomRs ('0', 'z') g) I think.
10:45:21 <xerox> assl0r, you can't do IO in the middle of a pure function, but you can use Debug.Trace.trace as LoganCapaldo points
10:45:55 <osfameron> how does trace work?
10:46:16 <LoganCapaldo> probably unsafePerformIO
10:46:20 <assl0r> thx, i will give it a try
10:46:26 <LoganCapaldo> But that's just a guess
10:49:13 <LoganCapaldo> @type seq . (unsafePerformIO . putStrLn)
10:49:16 <lambdabot> Not in scope: `unsafePerformIO'
10:49:29 <assl0r> do putTraceMsg $ show length xs; y:x:swapuneven xs  :(
10:49:37 <LoganCapaldo> no no
10:49:39 <saucisson> how to use a function : a -> IO (b) in a Set.map ?
10:49:39 <assl0r> i dont have a clue...
10:49:42 <Gwern> dolio: right, I noticed there's a missing argument, and I saw some other examples using g
10:50:01 <LoganCapaldo> trace (show $ length xs) y:x:swapuneven
10:50:11 <LoganCapaldo> no do
10:50:21 <LoganCapaldo> the whole point is to use trace and "cheat"
10:50:48 <assl0r> hehe
10:51:24 <sjanssen> saucisson: I'd do "Set.fromList . mapM myfunc . Set.toList"
10:51:30 <sjanssen> erm, that isn't quite right
10:51:41 <Gwern> hmm. take 1000 $ randomRs ('0', 'z') (read "foo"::StdGen)
10:51:46 <Gwern> > take 1000 $ randomRs ('0', 'z') (read "foo"::StdGen)
10:51:48 <lambdabot>  "MOnpbd2`cpQNPKYo:?[6pztXV>xsipw65G@JS31a^h8lRXq2i:`4;;HhZPLu8]qDOzxtz<tpu?t...
10:52:00 <saucisson> sjanssen: this is what i use... no better way ?
10:52:01 <sjanssen> fmap Set.fromList . mapM myfunc . Set.toList $ theSetYouAreMapping
10:52:16 <Gwern> > take 10 $ randomRs ('0', 'z') (read "12345"::StdGen)
10:52:18 <lambdabot>  "eIFiXdcC^X"
10:52:24 <sjanssen> saucisson: I don't see a better way
10:52:45 <sjanssen> saucisson: unless you have proof that your "a -> IO b" is referentially transparent?
10:53:09 <saucisson> sjanssen: it is a common practice in haskell to transform to lists to perform IOs ?
10:53:10 <sjanssen> (this might be the case when it is an interface to a cache, for example)
10:54:16 <sjanssen> saucisson: not in general.  Here we're just emulating a function that Data.Set is missing (mapM)
10:55:40 <saucisson> why is a cache referentially transparent ?
10:56:10 <LoganCapaldo> because f(x) = f(y) -> x = y
10:56:48 <LoganCapaldo> if f is your cache you don't expect a different answer when you plug in x more than once that's like half the point of a cache
10:57:07 <LoganCapaldo> trade memory for computation
10:57:37 <LoganCapaldo> err
10:57:45 <LoganCapaldo> I wrote that implication backwards
10:57:47 <saucisson> and if the cache is a hash table ? is it stille the same ?
10:57:52 <LoganCapaldo> please not keel haul me
10:58:12 <LoganCapaldo> the implementation is immaterial to its "cachey-ness"
10:58:24 <cameron> saucisson: what matters is that the function always returns the same value for a given input
10:58:43 <cameron> i.e. it has to be a function in the mathematical sense
10:59:53 <emu> yarrr, keelhaul tis land lubber for mistakin referential transparency!
11:00:04 <vincenz> woah
11:00:06 <vincenz> anyone a kernel expert?
11:00:13 <vincenz> localhost kernel: [27527.668000] Uhhuh. NMI received for unknown reason b0 on CPU 0.
11:00:22 <vincenz> localhost kernel: [27527.668000] You have some hardware problem, likely on the PCI bus.
11:00:29 <vincenz> localhost kernel: [27527.668000] Dazed and confused, but trying to continue
11:01:05 <Baughn> vincenz: The message is probably correct. Does that happen a lot?
11:02:28 <Saizan> if i have data T = T1 Int Bool, there's a specific name for Int and Bool? in OO i'd call them attributes
11:02:30 <Baughn> vincenz: If it doesn't happen again, it might have been a radiation-induced bitflip. Otherwise.. some device is badly confused, /or/ you've got a device lacking a proper driver
11:04:22 <Baughn> Saizan: I'd call them factors, but.. attributes or elements sounds more normal.
11:04:42 <Baughn> Saizan: (Factors in that type T is the cartesian product of types Int and Bool)
11:07:07 <Saizan> Baughn: yeah, i see, even that would not go well with the tone of what i'm writing..
11:07:51 <LoganCapaldo> fields?
11:07:58 <LoganCapaldo> components?
11:08:23 <Baughn> Saizan: Go with attributes, if you like
11:08:57 <LoganCapaldo> elements?
11:09:08 <LoganCapaldo> stop me if I'm being annoying :)
11:09:12 <vincenz> Baughn: 've had it happen once before
11:09:35 <Saizan> fields is nice!
11:09:36 <Baughn> vincenz: Do you have any hardware on your machine that doesn't work/lacks a driver?
11:09:43 <vincenz> Baughn: not that I know o
11:09:45 <vincenz> +f
11:09:50 <vincenz> it's a recent thing
11:10:05 <Baughn> So it didn't /use/ to happen..
11:10:36 * vincenz nods
11:10:42 <vincenz> It's a recent thing, it happend once before a few days ago
11:10:50 <Baughn> vincenz: If you want a wild guess, it's a watchdog alarm of some sort telling you that a component (that is failing) has reset.
11:11:12 <vincenz> Baughn: It continues to work fine for the rest
11:11:56 <Baughn> vincenz: Not a problem. The kernel is good at handling transient failures, most of the time.
11:12:20 <vincenz> Alright, cool :)
11:12:25 <vincenz> I guess my hardware is just dying :D
11:12:33 <Baughn> ..you shouldn't be this happy about it
11:12:53 <vincenz> Well you said it's not a problem
11:13:05 <Baughn> It's not a problem for my wild theory
11:13:08 <vincenz> which is?
11:13:25 <Baughn> Which is that a component is failing, but keeps getting reset
11:13:43 <Baughn> If that's correct, then at some point the reset will fail
11:14:19 <vincenz> I just wish I knew which component
11:14:20 <LoganCapaldo> @type return . fail
11:14:23 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => String -> m (m1 a)
11:14:49 <Baughn> vincenz: Well, it's on the PCI bus...
11:15:01 <Baughn> vincenz: That excludes.. hmm... the disk drives.
11:15:40 <vincenz> hmm
11:15:41 <LoganCapaldo> @type let (foo :: (Monad m) => String -> m (m a)) = return . fail in foo
11:15:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m (m a)
11:16:15 <LoganCapaldo> @type let (foo :: (Monad m) => String -> m (m a)) = return . fail in join . foo
11:16:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
11:16:25 <narain> :t fail
11:16:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
11:16:40 <narain> > fail "egads" :: [Integer]
11:16:42 <lambdabot>  []
11:16:45 <vincenz> Baughn: alright, thx for the help
11:17:00 <LoganCapaldo> > fail "egads" :: Maybe a
11:17:02 <lambdabot>  Nothing
11:17:35 <eumenides> > fail 1 :: Maybe (Maybe Int)
11:17:36 <lambdabot>   add an instance declaration for (Num String)
11:17:47 <LoganCapaldo> :t fail
11:17:47 <eumenides> > fail "oh right" :: Maybe (Maybe Int)
11:17:50 <lambdabot>  Nothing
11:17:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
11:18:10 <narain> ?src fail
11:18:11 <lambdabot> fail s      = error s
11:18:18 <narain> :t error
11:18:20 <lambdabot> forall a. [Char] -> a
11:18:24 <LoganCapaldo> ?src [] fail
11:18:25 <lambdabot> fail _      = []
11:18:31 <LoganCapaldo> ?src Maybe fail
11:18:32 <lambdabot> fail _      = Nothing
11:18:44 <LoganCapaldo> ?src IO fail
11:18:45 <lambdabot> fail s  = failIO s
11:19:53 <LoganCapaldo> > fail "to communicate" :: IO a
11:19:54 <lambdabot>  Add a type signature
11:21:12 <LoganCapaldo> > fail "to communicate" :: IO ()
11:21:13 <lambdabot>  <IO ()>
11:22:04 <Baughn> ..it successfully failed
11:22:11 <LoganCapaldo> success
11:22:39 <LoganCapaldo> ripOffFeline ["a", "b"]
11:23:31 <dmwit> ?hoogle showHex
11:23:32 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
11:23:52 <dmwit> ?hoogle hex
11:23:53 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
11:23:53 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
11:23:53 <lambdabot> Numeric.readHex :: Integral a => ReadS a
11:24:05 <LoganCapaldo> > showHex 23 ""
11:24:07 <lambdabot>  "17"
11:24:31 <dmwit> > printf "%x" 23
11:24:32 <lambdabot>  Add a type signature
11:24:36 <dmwit> > printf "%x" 23 :: String
11:24:38 <lambdabot>  "17"
11:24:43 <dmwit> > printf "%8x" 23 :: String
11:24:45 <lambdabot>  "      17"
11:25:02 <dmwit> ...
11:25:08 <dmwit> How do I get it to be zero-padded?
11:25:11 <LoganCapaldo> printf "0x%08x" 23 :: String
11:25:21 <dmwit> Ah, okay, thanks.
11:25:27 <LoganCapaldo> > printf "0x%08x" 23 :: String
11:25:28 <lambdabot>  "0x00000017"
11:26:03 <LoganCapaldo> 0x being optional, clearly
11:26:09 <dmwit> right
11:26:16 <dmwit> ?index printf
11:26:17 <lambdabot> Text.Printf
11:29:09 <tcr> Is there some operator that you can give an expression, and the expression is evaluated strictly? (similiar to strict record fields, but just for any expression.)
11:29:23 <dmwit> > [-3] :: Integer
11:29:24 <LoganCapaldo> @src $!
11:29:24 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:29:25 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
11:29:29 <dmwit> =(
11:29:34 <LoganCapaldo> @src ($!)
11:29:35 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:29:38 <dmwit> > [-3] :: Int
11:29:39 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
11:29:40 <LoganCapaldo> well um
11:29:48 <LoganCapaldo> f $! x
11:30:29 <LoganCapaldo> > (+1) $! 2
11:30:31 <lambdabot>  3
11:31:54 <dmwit> tcr: also seq
11:32:26 <LoganCapaldo> (\f x -> x `seq` f x) (+1) 2
11:32:41 <dmwit> Oh, duh.
11:32:46 <tcr> thanks LoganCapaldo.
11:32:47 <dmwit> > [-3] :: [Integer] -- =)
11:32:49 <lambdabot>  [-3]
11:33:00 * dmwit needs sleep
11:33:10 <tcr> dmwit: Yeah I just looked how $! is implemented within the Prelude.
11:33:59 <LoganCapaldo> welcome
11:37:13 <eumenides> how do i make a link with Text.XHtml.Strict? There's no a :: Html -> Html
11:37:14 <LoganCapaldo> @free id
11:37:17 <lambdabot> f . id = id . f
11:37:48 <LoganCapaldo> @hoogle href
11:37:49 <lambdabot> Text.Html.href :: String -> HtmlAttr
11:37:49 <lambdabot> Text.Html.nohref :: HtmlAttr
11:37:58 <LoganCapaldo> so much for that idea
11:38:25 <eumenides> hm there's a thelink
11:38:28 <eumenides> @hoogle thelink
11:38:29 <lambdabot> Text.Html.thelink :: Html -> Html
11:38:53 <LoganCapaldo> thelink?
11:38:59 <LoganCapaldo> that's bizzare
11:39:25 <eumenides> well, it wouldn't be nice to call it "a" i guess :-)
11:40:07 <LoganCapaldo> why not link or anchor though?
11:40:23 <LoganCapaldo> @hoogle anchor
11:40:24 <lambdabot> Text.Html.anchor :: Html -> Html
11:40:28 <LoganCapaldo> heh
11:40:31 <LoganCapaldo> heheh
11:40:41 <eumenides> ah
11:41:24 <LoganCapaldo> @docs text.xhtml.strict
11:41:24 <lambdabot> text.xhtml.strict not available
11:41:35 <LoganCapaldo> @docs Text.XHtml.Strict
11:41:36 <lambdabot> Text.XHtml.Strict not available
11:41:41 <LoganCapaldo> ah well
11:41:49 <LoganCapaldo> @docs Text.Html
11:41:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html
11:41:52 <eumenides> the docs aren't very good
11:42:17 <LoganCapaldo> I'm just curious how you get something useful out of Html -> Html
11:42:18 <eumenides> ?index withAttr
11:42:18 <lambdabot> bzzt
11:42:36 <LordBrain> what is it people usually use for a win32 binding?
11:42:48 <eumenides> LoganCapaldo: you showHtml it :-)
11:43:22 <LoganCapaldo> no I mean anchor doesn't seem to take a url, or the text to display, etc.
11:43:31 <eumenides> oh. you use withAttr
11:43:49 <LoganCapaldo> the type makes me think its anchor htmlSoFar -> htmlWithAnanchortag
11:43:50 <LordBrain> no win32 programmers here?
11:44:03 <LordBrain> i know i've heard of something
11:44:48 <eumenides> ah wait
11:45:05 <eumenides> @type Text.XHtml.Strict.(!)
11:45:07 <lambdabot>     Not in scope: data constructor `Text.XHtml.Strict'
11:46:25 <eumenides> link txt hrf = anchor (toHtml txt) ! [href hrf] -- there we go
11:48:55 <norpan> what's up
11:50:14 <fasta> What's the implementation for Monad ((->) r)?
11:50:29 <LoganCapaldo> @src (->) Monad
11:50:30 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:50:39 <LoganCapaldo> @src (->) (>>=)
11:50:40 <lambdabot> f >>= k = \ r -> k (f r) r
11:50:49 <LoganCapaldo> @src (->) return
11:50:50 <lambdabot> return = const
11:55:45 <fasta> How can that instance we used?
11:55:48 <fasta> er be
11:56:34 <LoganCapaldo> > do { x <- (+2); y <- (-2); return (x, y) } 3
11:56:35 <lambdabot>  Parse error
11:57:00 <LoganCapaldo> > (do { x <- (+2); y <- (-2); return (x, y) }) 3
11:57:01 <nominolo> > 5 .*. HNil
11:57:09 <lambdabot>   add an instance declaration for (Num (a -> t))
11:57:09 <lambdabot>     In a 'do' expression: y ...
11:57:09 <lambdabot>   Not in scope: data constructor `HNil'
11:57:15 <LoganCapaldo> mmm
11:57:15 <nominolo> laaame!
11:57:30 <LoganCapaldo> I clearly am screwing this up
11:57:36 <xerox> nominolo, fix it :D
11:57:57 <nominolo> xerox: you mean a plugin?
11:58:40 <nominolo> the problem is that we need typeclass-let
11:58:44 <fasta> Actually, I just want to do something like callCC(\escape -> if b then escape () else foo (with multiple levels of if)
11:58:49 <xerox> adding HList to \bot's env right?
11:59:24 <nominolo> xerox: well, i'm not sure there's a complete standard implementation.  the source has many commented out alternative implementations for most stuff
11:59:53 <nominolo> xerox: and for example, to define type-level functions for use with hMap you need typeclasses anyway
12:00:18 <xerox> ah, I didn't know that
12:01:06 <nominolo> well, you can use ordinary functions, but that doesn't work well for heterogenous lists ..
12:01:35 <nominolo> naturally, you need to define the function for every element type in your HList
12:02:02 <xerox> can you map |(+1) :: Num a => a -> a| to an heterogeneous lists of Nums ?
12:02:29 * kc5tja is going to have to restructure his code to use more "combinators" in Python.  It's getting pretty hard to read in this quick-and-dirty "code and fix" cycle.
12:02:34 <kc5tja> Really, REALLY, pressed for time at the moment.
12:02:44 <kc5tja> So the code is getting quite ugly, and now it has to generate output in HTML format.  BLECH!
12:02:44 <nominolo> xerox: hm, not sure.  let me try
12:05:46 <Wild_Cat> kc5tja: in Python? Make sure you've had a look at some of the HTML template libraries then, it'll likely save some time.
12:06:28 <kc5tja> Wild_Cat: No time.
12:06:28 <moonlite> I need to program some Haskell on a 4-5h train-trip tomorrow
12:06:37 <kc5tja> I have to have this code done, oh, two minutes _ago_.  :(
12:06:42 <moonlite> are there any tar.gz's of hierarchical libraries?
12:06:56 <nominolo> xerox: hm, for some reason the (a -> b) instance for Apply doesn't work :/
12:07:22 <Wild_Cat> oh. That's what you mean by "pressed for time". Well, I hope your HTML output doesn't have to be complex then...
12:07:44 <kc5tja> Wild_Cat: However, if you have recommendations for when I get more time to refactor this code, I'd be greatful.  The less I have to re-invent means the less I have to support myself.
12:07:52 <kc5tja> No, it's not complex.
12:07:55 <kc5tja> VERY, very simple.
12:08:07 <kc5tja> But it has to be correct HTML or else the customer who needs it won't be able to use it.
12:08:18 <kc5tja> (customer == internal corporate customer, not market customer)
12:10:51 <Wild_Cat> kc5tja: well, if it's HTML templates you're after, I keep hearing good things about Genshi.
12:11:09 <Wild_Cat> and for a more general-purpose text template library, Cheetah is the standard.
12:12:24 <nominolo> xerox: no, it cannot infer this without help
12:12:39 <nominolo> xerox: so you need a specialized instance
12:13:11 <xerox> alright, maybe it would not be so useful in lambdabot
12:13:41 <kc5tja> Wild_Cat: Nothing that comes standard with Python?
12:14:16 <Wild_Cat> kc5tja: none that I'm aware of, sorry. Unless your idea of a template library is to programatically build the XHTML DOM with ElementTree...
12:14:47 <nominolo> > map ((1+) . fromDynamic) [ toDyn 5, toDyn 4.0, toDyn (-1) ]
12:14:48 <lambdabot>   add an instance declaration for (Num (Maybe a))
12:15:04 <nominolo> > map ((1+) . fromJust . fromDynamic) [ toDyn 5, toDyn 4.0, toDyn (-1) ]
12:15:06 <lambdabot>  Exception: Maybe.fromJust: Nothing
12:15:12 <kc5tja> Wild_Cat: No, I want something like this: def Head(aTitle): return Head([Title(aTitle), CSS(cssLocation)])
12:15:30 <nominolo> > map (fromDynamic) [ toDyn 5, toDyn 4.0, toDyn (-1) ]
12:15:32 <lambdabot>  [Just 5,Nothing,Just (-1)]
12:16:06 <sjanssen> @keal
12:16:06 <lambdabot> the fractal is 5 irrationals
12:16:09 <nominolo> wow, how does that work?
12:16:32 <fasta> I want to have an escape object, which every function can call (i.e. it must be in scope) and I want the something like the following code to work:
12:16:32 <fasta> \cont -> reverse (if a then cont b else zork)
12:16:33 <nominolo> > map (fromDynamic) [ toDyn 5.0, toDyn 4.0, toDyn (-1) ]
12:16:34 <lambdabot>  [Nothing,Nothing,Just (-1)]
12:16:35 <fasta> Is that possible?
12:16:35 <sjanssen> @keal
12:16:36 <lambdabot> 99% of my book has been erased by faulty hdd's
12:16:39 <Wild_Cat> kc5tja: aside from the fact that your example crashes the stack ( :p ), none of the libraries I know does that.
12:16:56 <shapr> @protontorpedo
12:16:57 <lambdabot> paul graham said static typing and ML types fo lisp hurt exploratory progrmaming
12:16:57 <nominolo> oh, plain old boring integer defaulting ...
12:17:05 <kc5tja> Wild_Cat: Crashes the stack?  EEHH??  It's just calling a function with a list of results from a bunch of other functions.
12:17:17 <kc5tja> I could code it here fairly quickly.
12:17:27 <nominolo> shapr: that's even true, to some extend
12:17:27 <Wild_Cat> kc5tja: yup. The function it calls is itself.
12:17:30 <kc5tja> But like I said, I need to finish delivery of actual results-producing code first.  :)
12:17:43 <kc5tja> Wild_Cat: Oh, well, you know what I mean.
12:17:44 <atp> Wild_Cat: no it doesn't ?
12:17:49 <kc5tja> atp: It does, actually.
12:17:59 <nominolo> :t [ toDyn 5.0, toDyn 4.0, toDyn (-1) ]
12:18:01 <lambdabot> [Dynamic]
12:18:02 <kc5tja> def Head(...): return Head(...)
12:18:04 <atp> isn't cont just the parameter passed to the lambda expression?
12:18:10 <atp> (forgive me, i'm a haskell newbie) :p
12:18:19 <shapr> nominolo: I think Java-style static typing hurts exploratory programming.
12:18:24 <xerox> nominolo, that muse be defaulting to Integer ?
12:18:29 <xerox> s/muse/must/
12:18:32 <Wild_Cat> admittedly, if Python had TCO it wouldn't cash the stack so much as hang indefinitely, but that's nitpicking. ;)
12:18:35 <nominolo> xerox: it seems
12:18:42 <fasta> atp: no, the idea is that reverse does not get applied in that case
12:19:03 <Wild_Cat> shapr: Java-style static typing hurts *the human brain*.
12:19:03 <nominolo> shapr: well, thinking of the HList magic I have to use to avoid boilerplate, it does have some more limitations
12:19:18 <Saizan>  > map (fromDynamic) [ toDyn 5.0, toDyn 4.0, toDyn (-1) ]
12:19:24 <atp> fasta: clearly there are some bad voodoo magicks here that i don't understand :)
12:19:45 <nominolo> shapr: ok, arguably, macros can be seen as orthorgonal
12:19:47 <fasta> atp: I am afraid that what I want is impossible in Haskell.
12:20:15 <atp> fasta: i've been led to believe that not a whole lot is impossible in haskell...
12:20:21 <nominolo> shapr: but consider, e.g., a constraint satisfaction problem, where the vars have different domains .. that's gonna be tricky in haskell
12:20:30 <atp> fasta: so the voodoo magicks you want must be truly bad voodoo :)
12:20:32 <fasta> atp: be impossible I mean without a Monad.
12:20:38 <fasta> er by
12:20:47 <atp> fasta: ah.  why are you avoiding monads?  monads are cool.
12:21:10 <fasta> atp: monads make the solution _much_ uglier
12:21:18 <fasta> atp: in this case
12:22:14 <nominolo> :t map (fromDynamic) [ toDyn 5.0, toDyn 4.0, toDyn (-1) ]
12:22:16 <lambdabot> forall a. (Typeable a) => [Maybe a]
12:22:39 <nominolo> :t map ((1+) . fromMaybe . fromDynamic) [ toDyn 5.0, toDyn 4.0, toDyn (-1) ]
12:22:42 <lambdabot> forall a. (Num (Maybe (Maybe a) -> Maybe a), Typeable a) => [Maybe (Maybe a) -> Maybe a]
12:22:44 * Wild_Cat doesn't get monads yet. But he's working on it.
12:22:57 <nominolo> :t map ((1+) . fromJust . fromDynamic) [ toDyn 5.0, toDyn 4.0, toDyn (-1) ]
12:22:59 <lambdabot> forall a. (Num a, Typeable a) => [a]
12:23:44 <LoganCapaldo> :t [ toDyn "a", toDyn 2 ]
12:23:47 <lambdabot> [Dynamic]
12:23:56 <LoganCapaldo> well
12:24:05 <nominolo> > map fromDynamic [ toDyn "a", toDyn 2 ]
12:24:07 <lambdabot>  [Nothing,Just 2]
12:24:33 <nominolo> it seems the default forall a. a instantiantes to Integer :)
12:24:41 <LoganCapaldo> Remind me agian why theres this static v.s dynamic argument again?
12:24:48 <nominolo> :t last $ map fromDynamic [ toDyn "a", toDyn 2 ]
12:24:50 <lambdabot> forall a. (Typeable a) => Maybe a
12:25:10 <nominolo> LoganCapaldo: because of lambdabot ;)
12:25:35 <nominolo> @protontorpedo
12:25:36 <lambdabot> or does it become a mishmash of code?
12:25:45 <nominolo> @protontorpedo
12:25:46 <lambdabot> how is smalltalk different from haskell?
12:25:53 <nominolo> @protontorpedo
12:25:54 <lambdabot> hey guys can haskeel be used to produce fast webapps?
12:26:47 <nominolo> i like the speling err0r
12:26:53 <DRMacIver> Heh. What are those from?
12:27:11 <nominolo> @help protontorpedo
12:27:12 <lambdabot> protontorpedo is silly
12:27:20 <nominolo> yah..
12:27:59 <Botje_> @. elite protontorpedo
12:27:59 <lambdabot> wi1 i Mak3 /\/\roE $$ t|-|AN |E4RnInG j4\/4 oR Ap| or $/\/\a11ta|x oR PLT s(h3me or RUbY oR p3r1 OR (1I$p?
12:28:24 <ventonegro> Wild_Cat: let's create a mailing list for those still not in monads
12:28:56 <Saizan> ?google sigfpe you could have invented monads
12:28:59 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
12:28:59 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
12:29:15 <nominolo> ?google programmable semicolon dons
12:29:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/blog
12:29:17 <lambdabot> Title: Haskell hacking
12:29:21 <ventonegro> Saizan: i understand the concept, the syntax, the uses...
12:29:35 <Wild_Cat> heh. "Hi. Mi name is Wild_Cat, I'm 24... And I don't get monads. I've been reading tutorials for 2 days straight."
12:29:48 <fax> lol
12:29:52 <ventonegro> but i do not yet "think" in them
12:29:57 <nominolo> Wild_Cat: simple solution: stop reading!
12:30:00 <Saizan> ventonegro: if you need intuition that sigfpe's blog entry is quite good
12:30:18 <ventonegro> Saizan: i've read it already
12:30:18 <nominolo> your haskell code gets better by taking a break to let it "sink"
12:30:35 <ventonegro> but then comes dons and creates monads for shells and permissions and stuff
12:30:38 <DRMacIver> As far as I can tell, the right way of thinking about monads is the follows (I have a brain dump in the works about this): Datastructures map onto control flow. e.g. collections map onto loops, enumerations map onto switch statements. Monads are a type of data structure which happens to map onto a very general form of control flow. By a wild coincidence, this turns out to be useful. :)
12:30:54 <Wild_Cat> well, at the very least I understand "do". Chapter 8 of yaht appears to be the key to understanding the rest.
12:30:54 <ventonegro> it's not that i do not understand them
12:30:55 <sm> nominolo: agreed
12:31:09 <ventonegro> i just can't think monadly yet
12:31:32 <fax> how do you learn to write a particular monad, given the concept in your head?
12:31:46 <nominolo> ventonegro: that's normal.  maybe google for domain specific embedded languages in haskell
12:31:49 <Wild_Cat> ...and I've been letting Haskell sink in for 2 years before resuming my learning a couple days ago :p
12:31:56 <nominolo> ventonegro: and deep and shallow embeddings
12:32:28 <nominolo> Wild_Cat: ok, that may require some prior unburying, first ..
12:32:55 <xerox> > let xs = zipWith dynApply [toDyn (++"-hoo!"), toDyn ord, toDyn (**pi)] [toDyn "woo", toDyn 'A', toDyn pi] in xs -- nominolo :D
12:32:57 <lambdabot>  [Just <<[Char]>>,Just <<Int>>,Just <<Double>>]
12:33:22 <fax> anyone? :S
12:33:23 <Wild_Cat> I think so. That's why I've been reading the tutorial from the beginning instead of trying to force my way through the end.
12:33:49 <nominolo> :t dynApply
12:33:52 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
12:34:06 <lispy> dynApply?
12:34:10 <Saizan> fax: you think of how to write >>= :: Monad m => m a -> (a -> m b) -> m b for your particular monad
12:34:12 <Wild_Cat> (besides, reading a tutorial that's different from the book I originally used is useful anyway, as it gives a different perspective on the language)
12:34:21 <xerox> > let xs = zipWith dynApp [toDyn (++"-hoo!"), toDyn ord, toDyn (**pi)] [toDyn "woo", toDyn 'A', toDyn pi] in xs
12:34:23 <lambdabot>  [<<[Char]>>,<<Int>>,<<Double>>]
12:34:28 <xerox> :P
12:34:47 <fax> Saizan: so if you can write a ugly function to do you, you can make a nice monad do it?
12:34:52 <fax> and vice versa?
12:35:21 <nominolo> > let xs = zipWith [toDyn show, toDyn show, toDyn show ] $ zipWith dynApp [toDyn (++"-hoo!"), toDyn ord, toDyn (**pi)] [toDyn "woo", toDyn 'A', toDyn pi] in xs
12:35:22 <lambdabot>  Couldn't match expected type `a -> b -> c'
12:35:34 <Saizan> "to do you" ?
12:35:54 <Wild_Cat> monad pr0n. Do we really need that?
12:36:35 <nominolo> > let xs = zipWith [toDyn show, toDyn show, toDyn show ] (zipWith dynApp [toDyn (++"-hoo!"), toDyn ord, toDyn (**pi)] [toDyn "woo", toDyn 'A', toDyn pi]) in xs
12:36:36 <lambdabot>  Couldn't match expected type `a -> b -> c'
12:36:44 <nominolo> :t let xs = zipWith [toDyn show, toDyn show, toDyn show ] (zipWith dynApp [toDyn (++"-hoo!"), toDyn ord, toDyn (**pi)] [toDyn "woo", toDyn 'A', toDyn pi]) in xs
12:36:46 <lambdabot>     Couldn't match expected type `a -> b -> c'
12:36:47 <lambdabot>            against inferred type `[a1]'
12:36:56 <Saizan> nominolo: zipWith needs 2 lists
12:36:57 <xerox> > let xs = zipWith dynApp [toDyn (++"-hoo!"), toDyn ord, toDyn (**pi)] [toDyn "woo", toDyn 'A', toDyn pi] in (fromDyn (xs !! 0) "", fromDyn (xs !! 1) 0, fromDyn (xs !! 2) pi)
12:36:59 <lambdabot>  ("woo-hoo!",0,36.4621596072079)
12:37:07 <xerox> duh
12:38:04 <nominolo> nice
12:38:13 <LordBrain> is the notation "module Main (main) where" a new thing?
12:38:24 <LordBrain> hmmm
12:38:31 <LordBrain> that just means it exports the main function i guess
12:38:38 <xerox> indeed
12:38:39 <nominolo> LordBrain: not since Haskell98
12:39:00 <LordBrain> its giving me unexpected (
12:39:25 <LordBrain> perhaps because i'm using windows ghc on a unix file?
12:39:40 <nominolo> possible
12:39:54 <nominolo> emacs can convert this
12:39:55 <Saizan> is that the first line of your file?
12:40:02 <nominolo> most other editor, too
12:40:25 <LordBrain> its the second line
12:40:35 <LordBrain> and i converted to dos, and it didn't help
12:40:58 * kc5tja sits in anticipation for the results of his code to come in....IF it comes in.... :/
12:41:08 <nominolo> does your editor have a mode to show hidden characters?
12:41:30 <LordBrain> is there a 6.6.1 binary for windows?
12:41:43 <LordBrain> nominolo, yes
12:42:04 <LordBrain> its gvim, it tells me wether its a unix or dos file too
12:43:05 <nominolo> hm.  so you have "module Main\n( ... "?  hm, that shouldn't happen :/
12:43:38 <LordBrain> there's no \n
12:43:45 <LordBrain> i treid in both unix and dos format
12:43:53 <LordBrain> in dos format it complains about a \r
12:44:05 <LordBrain> on the first line
12:44:42 <shapr> nominolo: Can you tell me more about a constraint satisfaction problem like the one you described? And show me how static typing makes it hard to write?
12:44:48 <sjanssen> LordBrain: what is the first line of your program?
12:44:56 <LordBrain> its empty
12:45:13 <LordBrain> its an empty line
12:45:23 <kc5tja> LordBrain: Maybe posting the full error, plus the commands you used to reproduce the error, on hpaste.org would be best at this point, so that we can "see what you see."
12:46:39 <LordBrain> @paste
12:46:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:47:24 <hpaste>  LordBrain pasted "The Error message" at http://hpaste.org/1675
12:47:44 <nominolo> shapr: say you have three variables: X in { red, green, blue },  Y in { round, triangular, rectangular } and Z in { 0, 1, 2 } and constraints between them.  e.g. if X is green then Y must be round, etc.  what would be the type of your binary constraint function?
12:48:13 <LordBrain> oh
12:48:15 <LordBrain> duh
12:48:19 <LordBrain> there's no #!
12:48:22 <LordBrain> :)
12:48:27 <Saizan> ..
12:48:28 <LordBrain> its trying to run it in bash
12:48:30 <Saizan> use runhaskell
12:48:35 <shapr> biConstraint :: {X,Y,Z} -> {X, Y, Z} ?
12:49:01 <quicksilver> nominolo: would it not be (X,Y,Z) -> Bool ?
12:49:20 <nominolo> shapr: no constraint (Var,Value) -> (Var,Value) -> Bool in general
12:49:55 * shapr thinks about that
12:49:58 <nominolo> quicksilver: you often assume binary constraints only.  all else can be translated to binary
12:50:49 <shapr> Why wouldn't the type I suggested work out?
12:51:02 <nominolo> quicksilver: of course, I'll look into frameworks with more general functions
12:51:09 <nominolo> shapr: what does { .. } stand for?
12:51:12 <shapr> records
12:51:19 <shapr> But why not tuples?
12:51:54 <nominolo> well, i'd prefer a framework with arbitrarily formed variables and constraints
12:52:13 <nominolo> or rather s/variables/domains/
12:52:25 <nominolo> of course Enum instances can help
12:53:51 <LordBrain> i always have such difficulty getting haskell libs installed on windows, that i end up, running out of time, and doing things in C++ or perl.
12:53:53 <nominolo> I also have type classes instead of plain functions as constraints, as this might allow more specific optimizations
12:54:34 <nominolo> er, there was "have ... in mind" missing
12:55:38 <Cheery> Hmm, I think I got a real thing I should derive
12:56:11 <Cheery> say, I'd like to make small event processors, I could later combine together with an algebraic datatype
12:57:01 <Cheery> ie. Lets say I'd have things of class EventProcessor a where Event -> a -> a
12:57:09 <Cheery> erm
12:57:23 <nominolo> Cheery: I am using HList for this.  it's quite tricky, though
12:57:37 <Cheery> process :: a -> Event -> a
12:57:48 <Cheery> (I think I want to foldl them
12:58:04 <nominolo> there's hFold ;)
12:58:20 <nominolo> hFoldr, to be specific
12:58:49 <Cheery> so, say I had instance EventProcessor ActiveEvent, EventProcessor Minimized, and so on.
12:59:26 <kc5tja> YYYEEESSS!!!  The data is in *AND* appears to match expected performance results.
12:59:38 <nominolo> Cheery: what will the result type of your fold be?
12:59:39 * kc5tja blames Haskell for allowing him to code by the seat of his pants and actually have it work.
12:59:51 <Cheery> nominolo: a
13:00:12 <Cheery> a -> [Event] -> a
13:00:14 <kc5tja> XP + unit tests + thinking functionally = miracle.
13:00:24 <nominolo> Cheery: i mean, do you plan to combine ActiveEvent and Minimized into one?
13:00:33 <kc5tja> (well, I suppose XP subsumes unit tests, but I digress ;) )
13:00:59 <nominolo> kc5tja: nonono, not unit tests, quickcheck subsumes unit tests ;)
13:00:59 <Cheery> then I'd like to do: data StuffIWant = SortsOfStuff Active Minimised | JustSomeSort Minimised deriving EventProcessor
13:01:24 <kc5tja> nominolo: QuickCheck is for Haskell.
13:01:25 <Cheery> This kind of stuff I want, nominolo :)
13:01:29 <kc5tja> I'm coding in Python.
13:01:57 <LoganCapaldo> quickcheck your python code! :)
13:01:58 <SamB> kc5tja: was there not a Python version?
13:02:07 <SamB> I was pretty sure that there was...
13:02:08 <kc5tja> TDD + unit tests + thinking functionally (especially in crisis mode) = software delivered only 15 minutes late.
13:02:48 <kc5tja> SamB: I'm only aware of a Haskell version.
13:02:53 <kc5tja> I've never heard of QuickCheck for Python.
13:03:01 <Heffalump> what is the current status of hs-plugins on ghc 6.6? Working, imminent, unknown?
13:03:06 <SamB> there is this thing called Peckcheck...
13:03:10 <kc5tja> Be that as it may, however, I have to use the accepted corporate coding guidelines, which state the use of PyUnit tests.
13:03:23 * kc5tja uses pychecker
13:03:28 <kc5tja> Is that what you're thinking of?
13:03:34 <Wild_Cat> kc5tja: http://www.accesscom.com/~darius/software/clickcheck.html
13:03:35 <kc5tja> pychecker != unit tests though.
13:03:36 <lambdabot> Title: Clickcheck and Peckcheck
13:03:38 <Cheery> nominolo: I'd simply then want to do something like: applyEvents myWeirdDataStructure bunchOfEvents
13:03:45 <Wild_Cat> appears to be in 0.1 only, but...
13:03:48 <nominolo> Cheery: You could have instance (EventProcessor e, HList l) => EventProcessor (HCons e l) where process (HCons e l) ev = HCons (process e ev) (process l ev)
13:04:01 <Wild_Cat> I'll have to read more about QuickCheck.
13:04:24 <nominolo> Cheery: and instance EventProcessor HNil where process HNil _ = HNil
13:04:52 <kc5tja> Wild_Cat: OK, but that won't help me in this code.
13:04:56 <Wild_Cat> curse you, Haskell, for having tools that r0xx0r lazily-computed amounts of b0xx0rZ!
13:05:05 <Cheery> nominolo: what's HList?
13:05:15 <Cheery> @source HList
13:05:16 <lambdabot> HList not available
13:05:26 <nominolo> @where hlist
13:05:27 <lambdabot> http://homepages.cwi.nl/~ralf/HList
13:05:27 <Cheery> @hoogle HList
13:05:28 <lambdabot> No matches found
13:05:32 <Wild_Cat> PyChecker is great, however, as far as static analysis is concerned. I hear good things about PyLint, too.
13:05:40 * kc5tja nods
13:05:45 <kc5tja> Oh -- I'm late for the meeting.
13:05:52 <kc5tja> Gotta go show off the code.   back in a bit.  :)
13:05:52 <SamB> oops
13:06:03 <nominolo> a heterogenous list/record implementation in haskell.  by Oleg, Ralf Hinze et. al.
13:06:08 <Wild_Cat> it's satisfying when they rate your code highly ^^
13:06:22 <nominolo> Cheery: very advanced type-level trickery though ;)
13:06:57 <nominolo> Cheery: depends on what else you want to do
13:07:32 <nominolo> Cheery: for you're case it's even simpler
13:08:22 <nominolo> you could just make tuples an instance of EventProcessor
13:09:08 <Cheery> hmm
13:09:23 <Cheery> nominolo: actually I could..
13:09:32 <nominolo> Cheery: anyways.  learning derive might still be a good idea anyways :)
13:10:03 <Cheery> well, I'd like to learn derive
13:10:17 <Cheery> unless it is inhumanly hard
13:10:25 <nominolo> i don't think so
13:10:41 <Cheery> I just think deriving stuff like that would be the most natural choice in this case
13:11:19 <Cheery> you wouldn't need to care much about the underlying stuff, just handling values would go. :)
13:11:57 <Cheery> especially when you could do: newtype Active = Bool deriving (Eq,Ord)
13:11:59 <Cheery> ;P
13:12:32 <Cheery> then it'd look just like a Bool, which just changes by Active -events
13:12:38 <earthy> hm. the cunning newtype deriving stuff doesn't allow you to add instances afterward, right?
13:12:44 <earthy> drat
13:13:09 <nominolo> bringert worked on a top-level deriving feature
13:13:20 <nominolo> not sure if it's generally available
13:13:39 <earthy> hm. right.
13:13:46 <earthy> I'll bug him for it, but not quite now
13:14:03 <earthy> (even if it's two screenfuls of boilerplate)
13:14:30 <Cheery> is deriving stuff that deep feature?
13:15:04 <Cheery> let me get this right, you just do not have something like: (Derivable a b) =
13:15:06 <Cheery> ?
13:15:27 <Saizan> earthy: i think is available in head
13:15:52 <earthy> saizan: that'd be nice
13:16:40 <earthy> cheery: newtype deriving is really simple. it just means that if you add a newtype wrapper, wrapping and unwrapping to get at instances of classes already defined for the type that you're hiding in the newtype comes for free
13:16:58 <earthy> however, currently, the deriving clause can only be specified directly at the point of the newtype
13:17:40 <earthy> so, if you were to add an instance for a type that's newtyped somewhere else, you won't get the option of adding that class to the newtyped type
13:18:18 <norpan> class instances are not as clean as you'd like
13:18:31 <Cheery> what about creating your own derivable class?
13:19:30 <Saizan> Cheery: to write instances automatically you need TH
13:19:40 * earthy nods
13:19:46 <Saizan> that's what ndm's derive is for :)
13:19:52 <earthy> which I don't want to contaminate my code with. ;)
13:19:53 <Saizan> ?where derive
13:19:54 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
13:19:55 <Cheery> TH?
13:20:03 <earthy> it's ugly and nasty enough as it is. :)
13:20:22 <Saizan> template haskell, or, in lisp terms, macros
13:20:49 <Cheery> ouch
13:21:22 <Cheery> I guess I'll use just that HList -things then
13:22:22 <Cheery> thought it'd be just so awesome to make your own automatic writing rules. :)
13:22:51 <Cheery> without template haskell or anysuch
13:22:58 <Saizan> well TH is not evil :D
13:23:21 <Baughn> No, but with great power comes great expandability
13:23:32 <Baughn> Using it badly can produce giant executables.
13:23:47 <Heffalump> So can just using ghc at all :-)
13:24:25 <Baughn> I'm used to hello, world being 16 MB from lisp. 300k is not much of an issue.
13:24:38 <fax> 16! wow?
13:24:41 <LoganCapaldo> 16MB, really?
13:24:42 <fax> what implementation is this
13:24:44 <fax> thats very small..
13:24:45 <Baughn> For SBCL... yes
13:24:59 <fax> its about 27 MB now
13:25:03 <LoganCapaldo> Did it include the compiler by default?
13:25:04 <Baughn> It doesn't have a tree shaker, meaning it includes *everything*. Plus the kitchen sink and, often enough, the IDE.
13:25:12 <Baughn> LoganCapaldo: *Everything*.
13:25:16 * fax wanted to write a stripper
13:25:17 <fax> b
13:25:23 <LoganCapaldo> geeezus
13:25:48 <Baughn> I much prefer ghc's approach. :P
13:26:08 <sieni> I would rather f**k a stripper than write to her
13:26:21 <sieni> oops, I thought I was writing to another channel
13:26:23 <sieni> sorry
13:26:48 <sieni> disregard that :-)
13:27:09 <LoganCapaldo> it is to laugh
13:27:25 <DukeDave> lmao, bash-tastic
13:30:27 <nominolo> that's  why it's called "tree shaker" instead ...
13:31:15 <nominolo> i think if you get an sbcl binary with Clim included you'll get close to 100mb
13:32:38 <Wild_Cat> a hundred megs for a Hello World program? That's... ridiculous.
13:33:20 <fasta> Wild_Cat: that's Lisp history
13:33:23 <emu> it's CLIM
13:33:26 <emu> not just hello world
13:33:29 <ventonegro> that's why i use scheme
13:33:31 <emu> CLIM is pretty neat
13:33:41 <emu> i wouldn't mind seeing some of those ideas be used elsewhere
13:33:44 <fasta> I concur CLIM is neat
13:33:55 <emu> it's not just another dumb toolkit like GTK
13:33:58 <Baughn> Wild_Cat: It depends on what compiler you use. ACL actually *has* a tree-shaker, but it's about the only one.
13:34:15 <Baughn> I'm thinking it could be useful to build a CL->Haskell compiler
13:34:26 <emu> lispworks does as well
13:34:42 <emu> that seems pretty tricky, unless you are an hs-plugins/ghcapi wiz
13:35:35 <Baughn> I'm not, nor did I really volunteer, but it doesn't really *need* full pluggability
13:36:31 <emu> i dunno about 100mb. i haven't dumped a clim core in ages.
13:36:50 <emu> but whatever number it is, it doesn't go up significantly when your application gets large, so, it's just a constant
13:36:53 <nominolo> oh, i always thought "concur" = "oppose"
13:36:57 <fax> well the source code isnt 100 MB :D
13:36:59 <emu> heh
13:37:12 <Baughn> CLIM is a pig, but not that much of one. 20MB, maybe.
13:38:11 <SamB> Baughn: CL->Haskell?
13:38:20 <SamB> what would that do for us?
13:38:38 <emu> port CL-emacs to haskell
13:38:52 <Baughn> SamB: Increase interoperability, in a way, and produce a CL compiler that makes /small/ executables
13:39:33 <emu> eh, by the time you incorporate what a CL executable does, it will be as big
13:39:45 * SamB is staring at the Haskell types involved and thinking "ewww"
13:39:47 <emu> remember, they need to have a full compiler in there
13:39:52 <Baughn> They don't
13:39:59 <SamB> also "how slow looking"
13:40:00 <Baughn> Very, very few complete programs actually /use/ it
13:40:01 <emu> well i don't think SBCL separates it
13:40:07 <nominolo> .ok, i retract my statement, it's only 50 MB
13:40:08 <Baughn> SBCL doesn't, no.
13:40:13 <emu> right
13:40:14 <nominolo> runtime overhead was 100 mb
13:40:17 <emu> that 50MB has a compiler in it
13:40:40 <emu> whereas my ACL dumped images here at work are about 10MB and have some limited debugging capability
13:40:55 <emu> and an interpreter for eval
13:41:27 * SamB wonders what happens if you try to eval code that calls the compiler
13:41:48 <nominolo> probably a condition?
13:41:58 <Baughn> Condition.
13:42:00 <fax> or maybe a compilation :p
13:42:09 <SamB> I was thinking maybe it would just pretend to run a compiler
13:42:13 <emu> it's fun to hack on the compiler while running inside it
13:42:23 <emu> if you fuck up, it's hard to salvage =)
13:42:33 <fasta> Squeak is a hell of a lot smaller than that.
13:42:35 <Saizan> Condition?
13:42:41 <SamB> Saizan: like an exception
13:42:43 <emu> Squeak doesn't produce code like SBCL
13:42:52 <Baughn> Saizan: An exception, only useful
13:43:07 * emu would like a better condition system in haskell as well
13:43:15 <eumenides> is it even possible to have a file uploaded with Network.CGI? I've tried all the input methods now and all of them just return the file name, not the contents
13:43:17 <fasta> emu: what kind of code does SBCL create then?
13:43:28 <SamB> fasta: machine code?
13:43:36 <emu> basically
13:43:37 <nominolo> emu: that's just libraries
13:43:42 <SamB> with some optimizations
13:44:03 <Saizan> eumenides: you have to specify multipart/form-data as the enctype in your form
13:44:10 <nominolo> emu: using the Cont monad you can probably get something like continuable exceptions
13:44:23 <eumenides> Saizan: ooh, right. thanks!
13:44:44 <fasta> I guess the problem is that it isn't nice to always work in a monad.
13:44:45 <sphynx> hi!
13:45:03 <SamB> Baughn: at this point it would be nice to get libraries that you use together to have error-handling strategies that go together...
13:45:18 <emu> yea admittedly i don't think you could implement CL condition system outside of a monad
13:45:40 <fasta> Scheme doesn't have those problems
13:45:49 <nominolo> emu: that would break referential transparency
13:46:03 <LordBrain> how would i make the c function GetSystemDirectory(LPTSTR lpBuffer, UINT uSize) which outputs a string to lpBuffer, accessable in my haskell?
13:46:06 <emu> scheme doesn't have a condition system
13:46:08 <sphynx> it seems that HsColour don't work as expected with literated haskell sources. Does anybody know some tool for producing nice HTML from .lhs?
13:46:09 <LoganCapaldo> Haskell's exceptions kind of do bite it seems to me
13:46:10 <LoganCapaldo> but I guess they beat C's exceptions
13:46:15 <fasta> emu: no, but you could build one.
13:46:17 <emu> so yes, by not having those problems, by not tackling the problem
13:46:20 <SamB> LoganCapaldo: no they don't
13:46:33 <SamB> because C has no exceptions for them to be put up against ;-P
13:46:39 <emu> fasta: "but you could build one" =)
13:46:45 <LoganCapaldo> SamB: :)
13:47:01 <emu> it's the rallying cry of the schemer
13:47:06 <LoganCapaldo> (longjmp is debatably an exception mechanism, but let's not go there)
13:47:31 <nominolo> LoganCapaldo: i've seen it used in a kernel
13:47:34 <SamB> it is no more than a mechanism
13:47:38 <emu> memset(0,0,0xFFFFFFFF) is also an exception mechanism
13:47:48 <fasta> emu: I agree that it would be better if we had a stable full of ponies.
13:47:55 <sphynx> Also HsColour behaves strangely with UTF8
13:48:00 <SamB> emu: why would you need to wipe the whole memory?
13:48:15 <emu> it's a clean exception
13:48:21 <DukeDave> Whoa, I think my brain just rewired itself... Man this is weird...
13:48:26 <Saizan> LordBrain: to call C functions you ahve to use the Foreign Function Interface, also called ffi, an extension by GHC, i don't know much more on it though :\
13:48:29 <fasta> emu: "using the Cont monad you can probably get something like continuable exceptions" <- that falls in the same category
13:48:35 <SamB> DukeDave: progressing well?
13:48:39 <emu> fasta: i don't disagree
13:48:39 * DukeDave just thought about writing something Monadically
13:48:54 <nominolo> DukeDave: successfully?
13:49:07 <DukeDave> Like I went straight there instead of writing it badly, then hacking it into Monadic form ;)
13:49:20 <DukeDave> I'll keep you updated!
13:49:32 <fasta> You make it sound like having it in monadic form is a good thing. :/
13:50:21 <LoganCapaldo> fasta: you make it sound like having it in monad form is a bad thing. I think it depends on the monad and what you do in it, no?
13:50:26 <DukeDave> Haha, well if it wasn't then I'd be writing something like    "f x y == Nothing = Nothing"
13:51:37 <DukeDave> And, that's just fugly!
13:51:37 <fasta> LoganCapaldo: yes, it depends on the monad.
13:51:37 <nominolo> fasta: better a monad than passing state around explicitly
13:51:38 <fasta> nominolo: there are also other solutions for that problem
13:51:46 <emu> haskell is the first monadic programming language
13:51:55 <nominolo> fasta: what about the Maybe monad?
13:51:57 <emu> just in case you thought it was functional -- no
13:52:35 <DukeDave> > Just 3 >>= (\x -> if x <3 then Nothing else Just x)
13:52:37 <lambdabot>  Just 3
13:52:50 <fasta>  and... ultimately... a programming language is a notation for a program. If you think about a certain program as having a global variable then writing it in a monad doesn't really help you solve the problem, now does it?
13:52:53 <DukeDave> > Just 2 >>= (\x -> if x <3 then Nothing else Just x)
13:52:53 <nominolo> :t guard
13:52:54 <lambdabot>  Nothing
13:52:56 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:53:00 <DukeDave> Ah I love it :)
13:53:17 <xerox> > return 2 >>= \x -> when (x >= 3) (return x) :: Maybe Int
13:53:18 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
13:53:21 <fasta> I have changed my mind on one subject, though.
13:53:21 <xerox> argh
13:53:22 <nominolo> > do x <- Just 2; guard (x > 3)
13:53:24 <lambdabot>  Nothing
13:53:31 <nominolo> > do x <- Just 2; guard (x < 3)
13:53:33 <lambdabot>  Just ()
13:54:08 <fasta> If it's possible to write down an algorithm purely functional as efficient as the imperative version, then do it.
13:54:33 <nominolo> fasta: no, it's a structuring mechanism.  and as always it requires careful consideration when to use and when not to
13:55:18 <nominolo> > do x <- Just 2; guard (x < 3); return x
13:55:19 <fasta> nominolo: ? AFAIK, everyone suggests a State/Reader/Writer monad when they need a global variable
13:55:19 <lambdabot>  Just 2
13:55:26 <LordBrain> anyone know how i would write the foreign declaration?  if the c function returns its output in the parameter?
13:55:43 <fasta> nominolo: some also suggest attribute grammars (one example other solution)
13:56:30 <nominolo> fasta: you'd suggest another representation?
13:57:40 <nominolo> fasta: of the algorithm, i mean.  yes, of course, asking for a global variable always smells bad
13:58:28 <ClaudiusMaximus> LordBrain: afaik, write the declaration as usual; you need to allocate space for the output when you call it
13:58:43 <fasta> nominolo: I don't think a "global variable" is that bad. By global I mean one global to one environment (e.g. a module or function)
13:59:35 <fasta> nominolo: Everyone names their State monad functions like set_bar
13:59:52 <nominolo> fasta: well, what i don't like about monads is that they sequence your code
13:59:56 <fasta> nominolo: this clearly implies that the mental model is to _set_ something.
14:00:29 <nominolo> fasta: also it's not proper camelCase ;)  i get your point though
14:00:49 <DukeDave> I actually avoided StateMonad nicely the other day, and ended up with a much clearer definition
14:00:51 <fasta> nominolo: What makes you think camelCase is the only good thing?
14:00:51 <nominolo> fasta: but that's what FP books are for.
14:01:05 <fasta> nominolo: I know that some of the best FP programmers don't use it.
14:01:09 <nominolo> fasta: it's consistent with common usage
14:01:15 <fasta> nominolo: there's no such thing as "proper".
14:01:25 <nominolo> fasta: i didn't say so
14:01:27 <DukeDave> Anyway guys, shouldn't we be talking about Arrows these days :)
14:01:30 <fasta> nominolo: the Prelude is only a very small bit of code
14:01:50 <ClaudiusMaximus> @docs Foreign.Marshal.Alloc
14:01:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Alloc.html
14:01:58 <shapr> fasta: Chill out man
14:02:08 <fasta> shapr: ?
14:02:14 <nominolo> fasta: i've hardly ever seen non-camel case code in haskell
14:02:16 <fasta> shapr: I was just making a point.
14:02:22 <nominolo> fasta: i don't say it's wrong
14:02:26 <LordBrain> ClaudiusMaximus, thankyou... i'm not very experienced with the FFI... if it's not too much trouble, I wonder if you could post a sample for me... I want to call the win32 function, GetSystemDirectory which takes a pointer to a buffer and the size of the buffer, and fills it up with the name of the directory(usually "c:\windows\system32")..
14:02:27 <fasta> nominolo: check darcs code
14:02:30 <fasta> nominolo: darcs.org
14:02:45 <nominolo> fasta: i just say, when it comes to conventions it's most important to be consistent
14:02:51 <fasta> nominolo: I didn't read the whole code base, but it seems pretty OK.
14:03:12 <LordBrain> so far i have something like:
14:03:16 <LordBrain> foreign import stdcall unsafe "windows.h GetSystemDirectory" c_GetSystemDirectory :: CString ->
14:03:18 <fasta> nominolo: that follows trivially from the definition of convention
14:03:32 <LordBrain> i'm not sure if that is right
14:04:12 <fasta> nominolo: anyway, really check out the darcs code. It shows how a real Haskell program works.
14:04:35 <nominolo> fasta: what's "a real Haskell program" ?
14:04:46 <fasta> nominolo: something non-trivial
14:04:54 <fasta> nominolo: written in Haskell :)
14:05:24 <LoganCapaldo> plus darcs is also used outside the haskell community so it gets more abuse
14:05:34 <kaol> any program seems trivial if written in Haskell
14:05:37 <shapr> haha
14:06:26 <LoganCapaldo> main = revisionControl ? :)
14:06:29 <nominolo> fasta: ok.  kind of seemed to assume I haven't seen any real haskell program.
14:07:01 <nominolo> kaol: only when accompanied by a blog entry
14:07:09 <nominolo> kaol: or a paper
14:08:00 <fasta> nominolo: Hmm, I did, by mistake, since you seem to know about HList.
14:08:18 <ClaudiusMaximus> LordBrain: i don't have an example to hand that allocates memory for output parameters, sorry...
14:08:20 <fasta> nominolo: I can't remember your nick and thus assumed you were new to Haskell.
14:08:43 <nominolo> fasta: i am pretty new, yes.  but i learn quickly :)
14:09:05 <nominolo> fasta: and i had good teachers
14:10:35 <ClaudiusMaximus> LordBrain: but you'll need alloca or allocaBytes, i think, and probably withCString to marshal a haskell String to the input parameter
14:10:58 <LordBrain> hmmm i think it may already be done for me in System.Win32
14:11:06 <LordBrain> but i am not clear how i would use it
14:11:16 <LordBrain> they have
14:11:55 <LordBrain> foriegn import ccall unsafe "GetSystemDirectoryW" c_getSystemDirectory :: LPSTR -> UINT -> IO UINT
14:12:35 <LordBrain> omg its so easy
14:12:41 <monochrom> heh
14:12:45 <LordBrain> dir <- getSystemDirectory
14:12:55 <LordBrain> someone has done the hard stuff for me
14:13:01 <ClaudiusMaximus> LordBrain: :)
14:13:38 * ClaudiusMaximus needs to learn how to do this kind of stuff for one of his projects..
14:15:10 <LoganCapaldo> is UINT an unsigned int?
14:15:21 <LordBrain> yeah, its a windows thing
14:15:26 <LoganCapaldo> how is a directory an integer?
14:15:31 <LordBrain> lol
14:15:37 <LordBrain> it's not
14:15:44 <LordBrain> the c function actually modifies its parameters
14:15:50 <LoganCapaldo> oooooo
14:15:56 <SamB> LordBrain: huh?
14:15:58 <LordBrain> the first parameter is the return of the directory name
14:16:04 <LoganCapaldo> duh
14:16:13 <SamB> oh.
14:16:18 <LoganCapaldo> char *, size_t buflen like that?
14:16:20 <monochrom> returns error code or "success" encoded in a number.
14:16:41 <LordBrain> i think it returns the number of bytes written
14:16:53 <LordBrain> there's a lot of stuff like this in win32
14:17:08 <monochrom> In unix too.
14:17:11 <sioraiocht> WHY doesn't mod play nice with negative numbers?
14:17:23 <monochrom> because rem plays nicer.
14:17:33 <sioraiocht> -_-
14:17:33 <LoganCapaldo> @type rem
14:17:39 <lambdabot> forall a. (Integral a) => a -> a -> a
14:17:41 <LoganCapaldo> @type mod
14:17:44 <lambdabot> forall a. (Integral a) => a -> a -> a
14:18:03 <sioraiocht> > -2 `rem` 4
14:18:05 <lambdabot>  -2
14:18:10 <LoganCapaldo> > (-3 `rem` 2, -3 `mod` 2)
14:18:12 <lambdabot>  (-1,-1)
14:18:26 <LoganCapaldo> I'm clearly missing something
14:18:29 <sioraiocht> mod DOES play nice? *growls*
14:18:31 <dolio> > ((-3) `rem` 2, (-3) `mod` 2)
14:18:31 <sioraiocht> n/m, lol
14:18:32 <lambdabot>  (-1,1)
14:18:42 <emu> > -1 `mod` 7
14:18:43 <lambdabot>  -1
14:18:46 <LoganCapaldo> and parens would be it
14:18:46 <emu> tsk
14:18:57 <emu> > -7 `mod` 7
14:18:58 <lambdabot>  0
14:19:00 <emu> well ok
14:19:06 <sioraiocht> > (-1) `rem` 3
14:19:08 <lambdabot>  -1
14:19:09 <kc5tja> sioraiocht: Because given a division, (-10/2), we know it to be -5.  But, there are two possibilities.  Either the numerator is negative, or the denominator (not both since that'd result in a positive result).  Which is it?  Nobody can tell.  Even if you hard-code the numerator to be negative, how can you be sure it's *really* that way in the scope of the larger equation?
14:19:55 <sioraiocht> really I want mod to give me the smallest positive integer in the congruence class =p
14:20:44 * kc5tja remembers a good PDF that went into the issues of computer division.
14:20:50 <kc5tja> (of which modulo is a type of)
14:21:24 <sioraiocht> > (2 + 1) `mod` 3
14:21:26 <lambdabot>  0
14:21:30 <monochrom> Is your divisor positive?  i.e.  xxx divided by (positive number here)?
14:21:40 <sioraiocht> > (2 + 3 + 1) `mod` 3
14:21:42 <lambdabot>  0
14:22:03 <monochrom> Anyway you always have the choice between rem and mod.
14:22:12 <sioraiocht> > ( 2 - 1 + 3) `mod` 3
14:22:14 <lambdabot>  1
14:22:23 <sioraiocht> okay, adding three does I want
14:22:43 <sioraiocht> monochrom: all I want is to increment or decrement a value and have it wrap
14:23:04 <monochrom> > (0 - 1) `rem` 3
14:23:06 <lambdabot>  -1
14:23:11 <monochrom> > (0 - 1) `mod` 3
14:23:13 <lambdabot>  2
14:23:19 <kc5tja> www.cs.uu.nl/~daan/download/papers/divmodnote.pdf
14:23:23 * sioraiocht blinks
14:23:27 <sioraiocht> (-1) `mod` 3
14:23:29 <monochrom> Does one of them suit your need?
14:23:32 <kc5tja> I knew I had it somewhere.  :)
14:23:34 <sioraiocht> > (-1) `mod` 3
14:23:36 <lambdabot>  2
14:23:40 <sioraiocht> i hate my life
14:23:41 <sioraiocht> yes =p
14:23:49 <sioraiocht> i must have had parens issues when i did this before
14:24:02 <monochrom> Yes, be careful with that.
14:24:25 <sioraiocht> I'm rewriting an interpreter i wrote last week, cutting down on the number of lines quite a bit
14:24:26 <monochrom> Premature whining is the root of all evils.
14:24:40 <sioraiocht> monochrom: even taxes?
14:24:55 <monochrom> Ha, I'll have to think about that one.
14:25:39 <kc5tja> Premature evil is the root of all optimization.
14:25:49 <sioraiocht> LOL
14:26:00 <chessguy> ?remember kc5tja Premature evil is the root of all optimization.
14:26:01 <monochrom> I just handed in my tax forms two days ago. I'll get cdn$700 back. It's so sweet I can't think of it as evil now. :)
14:26:01 <lambdabot> Done.
14:26:23 <kc5tja> Hehe -- thanks.  :)
14:26:45 <chessguy> @quote tax
14:26:46 * kc5tja will now proceed to work further on his Python code, so that it's even more presentable for the next week's meeting.
14:26:46 <lambdabot> syntaxfree says: * syntaxfree often uses (&) = flip (.)  for additional clarity.   <nmessenger> @src (->) (>>>)   <lambdabot> f >>> g = g . f   * syntaxfree drops dead.
14:27:51 <LordBrain> ok
14:28:02 <DukeDave> Erm, I need a function which...   Repeats the execution of a function on an input until it stops altering the input.. Any ideas
14:28:21 <LordBrain> how do i get my libunicows.a linked in so my System.Win32 operates correctly on windows 98 ?
14:28:31 <LordBrain> grrrr
14:29:01 <LordBrain> i've tried dropping it in lib directories, i've tried handing it to ghc on the command line....
14:29:28 <chessguy> DukeDave: got an example?
14:29:38 <nominolo> @quote tax
14:29:39 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
14:29:47 <LordBrain> i've tried compiling and then linking as a separate step
14:30:07 <Botje_> @quote zombie
14:30:07 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
14:30:12 <Botje_> #haskell needs a zombie quote.
14:30:24 <Botje_> Zombie :: IO Brains
14:30:42 <Botje_> unsafePerformEatBrains
14:30:43 <chessguy> ?remember Botje_ #haskell needs a zombie quote
14:30:44 <lambdabot> Done.
14:30:51 <nominolo> lol
14:30:53 <chessguy> @quote zombie
14:30:54 <lambdabot> Botje_ says: #haskell needs a zombie quote
14:30:57 <Botje_> yay!
14:31:09 <nominolo> those statements always backfire (to some degree)
14:31:22 <Saizan> DukeDave: sumething like groupBy (/=) . iterate f ?
14:31:55 <chessguy> @type let rep f n = if (f n) == n then n else rep f (f n)
14:32:06 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
14:32:06 <nominolo> soooo...  who wanted to talk about Arrows?
14:32:06 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
14:32:06 <lambdabot>  
14:32:21 * chessguy sighs
14:32:32 <nominolo> ?
14:32:37 <Saizan> @type let rep f n = if (f n) == n then n else rep f (f n) in rep
14:32:40 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
14:33:10 <nominolo> @info ShowQ
14:33:10 <lambdabot> ShowQ
14:33:36 <Saizan> lambdabot's module
14:33:41 <chessguy> @pl rep f n = if (f n) == n then n else rep f (f n)
14:33:42 <lambdabot> rep = fix (ap (ap . join . (if' .) . ((==) =<<)) . ((.) =<<))
14:33:43 <DukeDave> Hey sorry gang,
14:33:53 <chessguy> woohoo
14:34:01 <DukeDave> :t groupBy
14:34:03 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
14:34:14 <chessguy> DukeDave: do you have an example of what you want to do?
14:34:34 <dolio> Ooo...
14:34:42 <DukeDave> Given function  (\x -> if x > 4 then x -1 else x)
14:34:46 <Saizan> groupBy won't work
14:35:13 <DukeDave> So start it with 10, and will subtract by 1 over & over until we get to 5
14:35:38 <DukeDave> At that point you'll start getting an infinite list of 5s
14:35:48 * CosmicRay releases a new HDBC
14:36:01 <nominolo> @where hdbc
14:36:02 <lambdabot> http://quux.org/devel/hdbc
14:36:14 <LoganCapaldo> unfoldr maybe?
14:36:16 <CosmicRay> that link needs to be updated
14:36:26 <CosmicRay> http://software.complete.org/hdbc is the current location
14:36:26 <monochrom> > take 15 (iterate (\x -> if x > 4 then x -1 else x) 10)
14:36:27 <dolio> > let f x = if x > 4 then x - 1 else x in head . head . dropWhile (null . tail) . group . iterate f $ 10
14:36:28 <lambdabot>  [10,9,8,7,6,5,4,4,4,4,4,4,4,4,4]
14:36:29 <lambdabot>  4
14:36:29 <chessguy> > iterate (\x -> if x > 4 then x -1 else x) 10
14:36:29 <CosmicRay> how do you update the bot?
14:36:31 <lambdabot>  [10,9,8,7,6,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
14:36:31 <lambdabot> Title: Haskell Database Connectivity
14:36:36 <chessguy> ...
14:36:38 <DukeDave> But I obviously we can terminate there because referential transparency it'll never return anything other than 5
14:36:40 <nominolo> CosmicRay: @where+ <new>
14:36:52 <CosmicRay> @where+ hdbc http://software.complete.org/hdbc
14:36:52 <monochrom> 4 = 5 ?
14:36:52 <lambdabot> Done.
14:36:55 <CosmicRay> @where hdbc
14:36:55 <DukeDave> Uh, 4 ;)
14:36:55 <lambdabot> http://software.complete.org/hdbc
14:36:59 <monochrom> ok
14:37:07 <Saizan> > (\f -> unfoldr (\x -> let y = f x in if y == x then Nothing else Just (y,y))) (\x -> if x > 4 then x -1 else x) 10
14:37:09 <lambdabot>  [9,8,7,6,5,4]
14:37:26 <chessguy> > let rep f n = if (f n) == n then n else rep f (f n) in rep  (\x -> if x > 4 then x -1 else x) 10
14:37:28 <lambdabot>  4
14:38:04 <DukeDave> chessguy, nothing like that in Prelude?
14:38:16 <nominolo> @pl \x y -> if y == x then Nothing else Just (y,y)
14:38:17 <lambdabot> (`ap` (Just . join (,))) . flip flip Nothing . (if' .) . (==)
14:38:23 <chessguy> > let rep f n = if (f n) == n then n else n : rep f (f n) in rep  (\x -> if x > 4 then x -1 else x) 10
14:38:24 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
14:38:25 <lambdabot>       Expected...
14:39:17 <nominolo> @src nubBy
14:39:17 <lambdabot> nubBy eq []             =  []
14:39:18 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:40:38 <nominolo> :t join (,)
14:40:54 <nominolo> @botsnack
14:41:04 <lambdabot> :)
14:41:06 <lambdabot> forall a. a -> (a, a)
14:41:27 <CosmicRay> ghc seems to compile this data record OK, but has trouble compiling things that use it.  ideas?
14:41:32 <CosmicRay> data GlobalInfo = GlobalInfo {gcp :: ConfigParser,
14:41:32 <CosmicRay>                               gdbh :: IConnection a => a}
14:42:22 <nominolo> CosmicRay: what's the error message?
14:42:51 <CosmicRay>     Ambiguous type variable `a' in the constraint:
14:42:51 <CosmicRay>       `IConnection a'
14:42:51 <CosmicRay>         arising from use of `gdbh' at Commands/EnableDisable.hs:58:15-21
14:42:51 <CosmicRay>     Probable fix: add a type signature that fixes these type variable(s)
14:43:11 <CosmicRay> the code is commit (gdbh gi), where gi is the GlobalInfo object
14:43:13 <nominolo> well, you have an existential type there
14:43:16 <CosmicRay> and commit expects an IConnection
14:43:26 <CosmicRay> nominolo: but I have AllowExistentialQuantification in my cabal
14:43:27 <LoganCapaldo> I feel like the a should be over by the data GlobalInfo a = ...
14:43:38 <CosmicRay> s/Allow//g
14:43:43 <monochrom> This is, in fact, not existential.
14:43:45 <nominolo> well, it has to find out the a from the context
14:44:05 <monochrom> But let me double-check myself.
14:44:34 <CosmicRay> LoganCapaldo: then it has to track back through dozens of other type signatures
14:45:07 <monochrom> I checked. This is, in fact, not existential.
14:45:29 <hpaste>  DukeDave pasted "My implementation.." at http://hpaste.org/1676
14:45:45 <CosmicRay> monochrom: hrm, so what should I do?
14:45:49 <DukeDave> Okay, little question on that paste for you guys :)
14:45:52 <DukeDave> (Cheers!)
14:46:21 <Saizan> gdbh :: GlobalInfo -> (IConnection a => a), afaik this is a function from GlobalInfo to _|_
14:46:53 <monochrom> It is arbitrary-rank polymorphism
14:46:59 <CosmicRay> but the function that uses it is of type IConnection a => a -> IO ()
14:47:02 <Botje_> DukeDave: I believe so
14:47:10 <sjanssen> CosmicRay: that should be "data GlobalInfo = forall a. (IConnection a) => GlobalInfo {gdbh :: a}"
14:47:31 <Botje_> DukeDave: you could check that easily by importing Debug.Trace
14:47:38 <Botje_> and adding a trace action to the f
14:47:48 <DukeDave> Botje_, I've never played with Trace :o
14:47:58 <DukeDave> Is it the sort of think I'm likely to enjoy? :)
14:47:59 <Botje_> f x = trace "HALLO I AM BEING CALLED" (x + 1)
14:48:14 <Botje_> then call repeatF with suitable f and x
14:48:15 <vincenz> f x = trace "1 800 TRACEME" (x + 1)
14:48:23 <ddarius> > let f x = trace "HALLO I AM BEING CALLED" (x + 1) in f 3
14:48:23 <CosmicRay> sjanssen: I tried this:
14:48:23 <LoganCapaldo> f is a loud function
14:48:24 <DukeDave> Haha, cool, I'll check it out
14:48:27 <lambdabot>   Not in scope: `trace'
14:48:28 <augustss> howdy
14:48:31 <CosmicRay> data GlobalInfo = forall a. GlobalInfo {gcp :: ConfigParser,
14:48:31 <CosmicRay>                                         gdbh :: a}
14:48:33 <nominolo> DukeDave: be careful about using show in trace though
14:48:35 <CosmicRay> maybe that is not what you meant?
14:48:37 <vincenz> ddarius: can't do IO
14:48:42 <vincenz> augustss: any updates?
14:48:43 <CosmicRay> I am now getting errors about escaped type variables.
14:49:06 <nominolo> DukeDave: since it may force some values
14:49:10 <hpaste>  dolio annotated "My implementation.." with "shared" at http://hpaste.org/1676#a1
14:49:17 <sjanssen> CosmicRay: yes, you'll get those errors if you use the 'gdbh' function.  Use pattern matching instead
14:49:30 <CosmicRay> urk.
14:49:39 <CosmicRay> that makes the code significantly less convenient.
14:50:02 <DukeDave> dolio, I thought that too, but sure the compiler acn figure that out.. by taking advantage of referential transparency?
14:50:22 <sjanssen> or introduce a function like: applyGdbh :: (forall a. IConnection a => a -> b) -> GlobalInfo -> b
14:50:31 <CosmicRay> yeah.
14:50:33 <CosmicRay> sigh.
14:50:47 <Botje_> DukeDave: the compiler doesn't _ALWAYS_ eliminate subexpressions like that.
14:50:53 <dolio> DukeDave: It might, I suppose. Explicit sharing might be safer, though.
14:50:59 <ddarius> DukeDave: In either of those, both behaviors are legal.
14:51:19 <DukeDave> Grumble, fine I'll write a new Haskell compiler which does it properly ;)
14:51:19 <ddarius> In practice, the latter will share the former won't.
14:51:19 <sjanssen> CosmicRay: or make data AnyConnection = forall a. IConnection a => AC a, and make AnyConnection an instance of IConnection
14:51:33 <monochrom> myfun (GlobalInfo {gdbh = x}) = ... x ...   -- this isn't inconvenient.
14:51:40 <ddarius> DukeDave: GHC used to do CSE, but it is now not normally enabled.
14:52:03 <DukeDave> Ahem, common subexpression elimination?
14:52:11 <ddarius> Yes.
14:52:13 <monochrom> computer science and engineering
14:52:22 <DukeDave> I can't see why there would be a reason not to do it?
14:52:31 <ddarius> Space leaks.
14:53:02 <monochrom> Sometimes you prefer not to share.
14:53:04 <DukeDave> At this point I think I need to accept & move on :)
14:53:14 <Botje_> DukeDave: don't worry too much about it for now
14:53:26 <Botje_> how are you liking haskell?
14:53:38 <ddarius> let powerset [] = [[]]; powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)
14:53:38 <monochrom> If you share too much, you keep handles on things you no longer use.
14:53:46 <DukeDave> Oh I see
14:53:55 <ddarius> CSE powerset and bad things happen.
14:54:01 <LoganCapaldo> won't something like (\x -> (f x, g x)) (quuz 7) pretty much have to gurantee sharing?
14:54:08 <DukeDave> I was just typing out an explaination of my thinking & realised the problem
14:54:13 <ddarius> LoganCapaldo: No.
14:54:22 <abz_> ?users
14:54:22 <lambdabot> Maximum users seen in #haskell: 336, currently: 331 (98.5%), active: 53 (16.0%)
14:54:32 <DukeDave> Out of interest is what we're talking about called 'memoization' ?
14:54:46 <monochrom> Much of dynamic programming is about handcoding "I want this shared and I want it remembered for eternity".
14:54:53 <ddarius> DukeDave: I actually recommend you try each of those definitions of powerset (the other shares the two subcalls in the second branch) and see what happens.
14:55:00 <LoganCapaldo> ddarius: but I thought that was where the whole MR thing came in, unexpected multiple evaluations of something...
14:55:27 <Botje_> DukeDave: memoization is a side-effect of CSE, yes
14:55:52 <Botje_> but it doesn't last outside the call
14:55:59 <ddarius> LoganCapaldo: Haskell is non-strict, not lazy. (\x -> (f x, g x)) (quuz 7) -> (f (quuz 7), g (quuz 7))
14:56:01 <Botje_> better to have some kind of explicit memoization
14:56:29 <LoganCapaldo> ddarius: k
14:56:46 <DukeDave> With you, well Thanks all involved to a satisfying explanation  :)
14:56:54 * DukeDave is a satisfied #haskell user!
14:56:58 <LoganCapaldo> is there any scenario where non-strict is more desirable than lazy?
14:57:49 <LoganCapaldo> space leaks again?
14:58:01 <dolio> LoganCapaldo: Lazy evaluation is one of several non-strict evaluation strategies.
14:58:19 <Botje_> LoganCapaldo: have you read ICFP yet?
14:58:36 <ddarius> LoganCapaldo: Potentially, but it would be far worse than the cure.
14:58:38 <Botje_> it's SPJones' online book on how functional programming "works"
14:59:08 <Saizan> ?where ICFP
14:59:09 <lambdabot> I know nothing about icfp.
14:59:26 <ddarius> ifpl I think
14:59:31 <monochrom> http://research.microsoft.com/%7Esimonpj/Papers/pj%2Dlester%2Dbook/
14:59:33 <lambdabot> Title: Simon Peyton Jones: book, http://tinyurl.com/jm7pe
14:59:39 <monochrom> icfp is a conference
15:00:27 * LoganCapaldo is tempted to get the dead tree version
15:01:10 * LoganCapaldo fantasies about reading about g-machines in bed
15:01:31 <augustss> simon's books are good
15:01:43 * ddarius has a laptop.
15:01:45 <augustss> too bad they are out of print
15:02:19 <Botje_> ehm. yeah
15:02:25 <LoganCapaldo> ddarius: you must have a remarkable, cool light weigth laptop to find reading in bed with it pleasurable
15:02:27 * Botje_ not good at acronyms
15:02:38 <pejo> augustss, don't have any hidden desires to write a new book?
15:02:51 <Botje_> augustss: we have the 1985 version at our uni
15:03:22 <augustss> pejo: no desires.  just the wild thought now and then
15:03:35 <ddarius> LoganCapaldo: I haven't actually done it, I've considered it though.
15:03:49 <LoganCapaldo> ddarius: I've done it. It's not really fun :)
15:04:15 <ddarius> My laptop is not too bad.
15:04:59 <LoganCapaldo> it just doesn't seem to work for that lying down angle
15:05:18 <LoganCapaldo> allthough my sample size of 2 laptops is pretty small
15:07:10 <DukeDave> http://en.wikipedia.org/wiki/Sony_Reader
15:07:11 <lambdabot> Title: Sony Reader - Wikipedia, the free encyclopedia
15:07:42 <DukeDave> Shame about the DRM :(
15:08:34 <LoganCapaldo> mmm e ink
15:09:54 <DukeDave> I saw a Libre (its predecessor) in a Sony centre in Tokyo which had apparently been on the same page for >5 years... Even knowing (roughly) how the technology works it's hard to get ones head round..
15:11:03 <ddarius> Maintaining a page is not hard and not particularly interesting.
15:11:06 <LoganCapaldo> DukeDave, if you want I can give you paper book whose pages have been the same for >10 years :)
15:12:09 <DukeDave> Lmao, I should have seen that coming ;)
15:12:34 <augustss> the Sony Reader is very cool.  my wife has one
15:13:39 <sorear> hello.
15:13:47 <DukeDave> Hi
15:14:20 <DukeDave> I guess they decided that Britain has too many libraries to compete with or something :|
15:14:51 <sorear> I look forward with dread to what sounds like it will be bos and claus verbally disemboweling each other :(
15:15:28 <sorear> hello davidL
15:15:30 <LordBrain> i have the darndest thing
15:15:33 <LordBrain> a parse error
15:15:37 <LordBrain> on 'import'
15:15:40 <LordBrain> in my foriegn import
15:16:05 <sorear> -ffi
15:16:05 <LordBrain> let me show you
15:16:12 <sorear> LordBrain: use the -ffi option
15:16:17 <LordBrain> oh
15:16:48 <sorear> @users
15:16:49 <lambdabot> Maximum users seen in #haskell: 336, currently: 324 (96.4%), active: 53 (16.4%)
15:17:06 <LoganCapaldo> mm, fount looks so much cooler with a 'u'
15:17:12 <jmelesky> what's the definition of "active"?
15:17:29 <jmelesky> "said something in the past X minutes" ?
15:17:59 <TomMD> Correct... and I can't recall how many minutes
15:18:16 <nominolo> 42?
15:18:22 <sorear> 15 for @seen, 360 for active:
15:18:57 <nominolo> where does @seen need minutes?
15:19:10 <ski> @seen
15:19:11 <nominolo> @seen blab
15:19:12 <lambdabot> I haven't seen blab.
15:19:30 <TomMD> You can't 'seen' generically due to the rudeness factor
15:19:31 <nominolo> @seen anyone
15:19:31 <lambdabot> I haven't seen anyone.
15:19:31 <jmelesky> @seen lambdabot
15:19:32 <lambdabot> Yes, I'm here. I'm in #xmonad, #haskell, #parrot, #scannedinavian, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell-soc, #haskell.dut, #haskell.hac07, #haskell-overflow
15:19:32 <lambdabot> and #haskell-blah
15:19:40 <ski> oh
15:19:41 <ski> <lambdabot> Lately, I have seen augustss, ddarius, dukedave, jmelesky, logancapaldo, lordbrain, nominolo, sjanssen, ski, sorear, sphynx and tommd.
15:20:01 <LordBrain> hey, the linker is giving me trouble now
15:20:29 <TomMD> Blame the compiler... send in a bug report without first looking for errors in the linker... the GHC team LOVES that.
15:20:34 <ski> TomMD : 'rudeness factor' ?
15:20:55 <nominolo> ski: highlighting of your nick
15:21:08 <TomMD> if you @seen in the main channel and lambdabot prints all the names all those peoples IRC programs probably wake up and tell them someone is talking to them.
15:21:09 <nominolo> ski: or whatever notification you get
15:21:20 <ski> ah .. didn't think of that
15:21:47 <nominolo> ski: so you just woke up a lot of users ;)
15:21:51 <ski> (ok, that's reasonable)
15:22:10 <sorear> ski, TomMD: I added the check to @seen
15:22:39 <ski> (nominolo : mainly i pasted that line since you were wondering where it needs minutes ..)
15:23:00 <hpaste>  LordBrain pasted "link error" at http://hpaste.org/1677
15:23:14 <nominolo> ski: yes, sure, just blame me >:|
15:23:15 <nominolo> ;)
15:23:21 <ski> ;)
15:23:37 <sorear>  foreign import ccall unsafe "GetSystemDirectoryW" c_getSystemDirectory :: LPTSTR -> UINT -> IO UINT
15:23:47 <sorear> LordBrain: windows doesn't use ccall!
15:23:58 <sorear> LordBrain: that needs to be stdcall, just like in C
15:24:03 <LordBrain> yeah, thats what i thought, but i just copied what System.Win32 source did...
15:24:36 <LordBrain> ok, i'll try with stdcall
15:24:44 <LordBrain> but i'm perplexed why it works for them then
15:24:45 <SamB_XP_> LordBrain: !
15:24:56 <SamB_XP_> they must use the -fvia-C...
15:25:23 <sorear> SamB_XP_: Still - the declaration needs to be differenct
15:25:25 <SamB_XP_> there ought to be a "get the C compiler to tell us if we got the prototype horribly wrong"... mode...
15:25:58 <sorear> @bug
15:25:59 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:26:39 <nominolo> whoa, @bug is hardwired to ghc?
15:27:11 <nornagon> short levestein difference, i'd say :)
15:27:21 <nominolo> hm, once we have post-GSoC hackage, that might take a package parameter
15:27:27 <nornagon> owait, nevermind.
15:27:41 <nominolo> @help bug
15:27:42 <lambdabot> bug. Submit a bug to GHC's trac
15:28:13 <LordBrain> how can i test to see if i'm on windows nt,xp,2000, etc as opposed to 9x ?
15:29:10 <TomMD> LordBrian: compile time?
15:29:20 <LordBrain> no
15:29:25 <LordBrain> er
15:29:37 <LordBrain> i'm not sure the easiest way to accomplish this
15:29:39 <nominolo> > System.Info.os
15:29:40 <lambdabot>   Not in scope: `System.Info.os'
15:29:47 <nominolo> :t System.Info.os
15:29:50 <lambdabot> String
15:29:59 <LordBrain> my difficulty stems from the fact that the functions in System.Win32 are all the unicode variations
15:30:10 <LordBrain> which aren't there on 9x
15:30:21 <LordBrain> there's a library tho
15:30:25 <LordBrain> libunicows.a
15:30:36 <monochrom> unicows :)
15:31:04 <nominolo> are the functions prefixed with "moo_" ?
15:31:17 <LordBrain> yes... but i'm having difficulty with it.. i tried just linking it in, but on 9x my program causes an exception
15:31:42 <LordBrain> oh they're not named the same?
15:31:48 <icarroll> @quote cow
15:31:49 <lambdabot> vincenz says: Does a cow have least-fixed-point-nature?
15:32:05 <nominolo> hm, shouldn't 9x be outdated, now after 9+ years?
15:32:39 <nominolo> (excluding the joke, called Windows ME)
15:32:45 <shapr> dcoutts: haha, I like your response to the Stone Age comment on lwn.net
15:32:59 <dcoutts> :-)
15:33:12 <dcoutts> that thread really went on and on
15:33:17 <LordBrain> well i need to support 9x
15:33:22 <LordBrain> this is work related
15:33:34 <sorear> why does gtk2hs copy c2hs?
15:33:52 <dcoutts> sorear: historical reasons
15:34:17 <LordBrain> hmmm
15:34:22 <dcoutts> shapr: it's interesting how people use the phrase 'scripting language' as a put down :-)
15:34:42 <LordBrain> is the function no longer called GetSystemDirectoryW in unicows?
15:34:53 <dcoutts> shapr: as a way of saying it's not really serious, only for little tasks
15:36:00 <osfameron> dcoutts: people who know them use it more positively...
15:36:13 <shapr> dcoutts: Yeah, it's pretty sad.
15:36:24 <shapr> dcoutts: This ncm guy is singularly uninformed.
15:36:27 <dcoutts> osfameron: true, I've nothing against them. I would not call FP languages scripting languages though.
15:36:34 <dcoutts> shapr: yeah
15:36:49 <dcoutts> he's got a thing about destructors and manual memory management
15:36:53 <osfameron> true ;-)
15:37:09 <shapr> "Real software engineers have big problems that functional-style programming wouldn't help with, and many where it would be actively harmful."
15:37:10 <dcoutts> sorear: originally Axel extended it in various ways but could not get his patches accepted upstream so we ended up with a fork, now there is some feature divergence. I've been gradually trying to pull them back together.
15:37:11 * shapr laughs
15:37:15 <sorear> this is the Internet, not RL; he is attacking us verbally not physically; we can safely ignore them!
15:37:42 <osfameron> though funnily enough the best scripting languages take /some/ lessons from fp
15:37:43 <sorear> dcoutts: aren't you the c2hs upstream maintainer now? ;)
15:37:43 <dcoutts> sorear: we don't mind about him, but we don't want to let other people thing that he's correct
15:37:55 <shapr> sorear: Yeah, what dcoutts said.
15:38:50 <dcoutts> sorear: right, so the remaining differences are that the gtk2hs fork does pre-compiled headers which is a big help when you've got 100+ .chs module all of which use the gtk/gtk.h file (which is >1Mb)
15:39:16 <sorear> dcoutts: so why wasn't this accepted, I wonder?
15:39:24 <dcoutts> sorear: and also some minor thing to do with automatically stripping off ForeignPtrs in {# call #} hooks
15:39:42 <sorear> We need a good FFI interface generator!
15:39:44 <dcoutts> sorear: it was not compatible at the time with the cpp extensions that c2hs acquired
15:40:19 <dcoutts> sorear: I know, I'm trying to fix it. What I've been doing recently is making c2hs able to parse any C header file and making the combo of c2hs+cabal not suck.
15:40:25 <LordBrain> :/
15:40:31 <shapr> "I met somebody back in Massachusetts working on something he called Eager Haskell. People laugh, but it's much faster than regular Haskell, making it practical, at least for pure computational work. Probably Darcs should be rewritten in Eager Haskell."
15:40:33 * shapr laughs more
15:40:52 <dcoutts> next up is the pre-compiled headers and making gtk2hs not need the ForeignPtr {# call #} hook extension
15:40:53 <shapr> In case the viewers at home would like to follow along - http://lwn.net/Articles/232410/
15:40:55 <lambdabot> Title: LWN: The Rise of Functional Languages (Linux Journal)
15:41:18 <dcoutts> shapr: I was tempted to reply to that comment but I felt I'd said enough
15:42:13 <dcoutts> sorear: so the latest darcs versions of c2hs and cabal are probably mostly usable with each other without screaming
15:42:36 <dcoutts> sorear: though sadly one still needs to list .chs modules in dependency order since cabal does no dependency analysis
15:43:07 <kolmodin> shapr: ah, thanks
15:43:20 <dcoutts> kolmodin wrote a patch to do that bit but it's not been integrated yet (partly because it wasn't clear if it worked)
15:43:49 <kolmodin> it worked for me... once at least :) but I'm not 100% :D
15:43:55 <dcoutts> :-)
15:44:02 <dcoutts> it's probably a good start
15:44:15 <kolmodin> yeah, if we just want that functionality quickly
15:44:25 <kolmodin> I'd like to see it a bit generalized though
15:44:30 <dcoutts> sure
15:44:38 <dcoutts> but working at all would be good
15:44:56 <dcoutts> and c2hs is currently the only pre-processor that actually needs dep analysis
15:45:07 <kolmodin> true
15:45:18 <moonlite> does anyone know if i can find the hierarchical libraries docs in a tarball somewhere? I need to read it offline
15:45:26 <kolmodin> that's why I thought it was a idea good enough to implement
15:45:32 <sorear> yes, there is a debian package ghc6-doc
15:45:44 <sorear> you should be able to unpack and read it on any system
15:45:46 <moonlite> sorear: neat
15:47:07 <moonlite> sorear: actually im using ubuntu so the process is a bit simpler.
15:47:10 <sorear> http://ftp.se.debian.org/debian/pool/main/g/ghc6/ghc6-doc_6.6-3_all.deb
15:47:12 <sorear> ah good.
15:47:13 <lambdabot> http://tinyurl.com/26tx6h
15:47:28 <moonlite> thanks again
15:47:30 * sorear <3 whois
15:47:53 <sorear> takes me less than a minute to figure out which mirror to give you a link for :)
15:49:44 <LordBrain> ok, this must be really simple because i can't find documentation :)
15:49:52 <LordBrain> how do i use unicows?
15:50:02 <LordBrain> just link it in?
15:50:59 <sjanssen> "this must be really simple because i can't find documentation" -- admirable optimism!
15:51:25 <LordBrain> lol
15:51:28 <sorear> fools.
15:51:30 <icarroll> :m +Text.Unicows
15:51:45 * sorear acts like a hardened old cynic
15:53:09 <augustss> mmmmm, I've been reading ncm's comments on lwn.net.  it's rare to see such C++ fanatics these days.  it's fun to read about their delusions
15:54:10 <sorear> I'd much rather ignore his existance.
15:54:18 <shapr> augustss: Respond informatively?
15:54:51 <augustss> shapr: why?  there's nothing i can say that would change his mind.
15:55:17 <shapr> Because other readers might be swayed by ncm's invective?
15:56:07 <augustss> meybe, maybe not.  i've given up being an evangelist.  if people want to be idiots, i just let them go on
15:56:21 <TomMD> Duhhhh
15:56:37 * sorear welcomes augustss into his fold
15:57:00 <sorear> cynicism: the one true cure for fantasy
15:57:40 <kolmodin> let people go ahead and do what they want. it'll only make our applications look even better :)
15:58:13 <osfameron> he does admit that haskell has a powerful type system, and responded sanelly to comment on optimized compilation in modues
15:58:17 * monochrom welcomes sorear into his catamorphism
15:58:23 <augustss> though a few more people doing haskell would make our hiring easier :)
15:58:41 <osfameron> ie he seems at least a little informed
15:58:46 <kolmodin> yeah, and hopefully yeild a few more libs
15:58:48 <sorear> There is a shortage of haskell programmers?
15:58:59 <sorear> I always thought there was a surplus.
15:59:00 <augustss> yes
15:59:12 <stepcut> maybe the Haskell programmers are just too lazy to send their resume ?
15:59:22 <augustss> there's a shortage of good ones ;)
15:59:30 <monochrom> I agree with augustss regarding stop preaching.  I believe it is a sign of coming to age.
15:59:37 <kolmodin> although, according to the ocaml entry in TMR, the fp programmers out there are quite skilled
15:59:52 <kolmodin> so if you get hold of one, he's probably good :)
15:59:54 <osfameron> who is looking for haskell programmers and where?
15:59:55 <olsner> woa... #haskell was quite heavy in traffic indeed
16:00:07 <sorear> monochrom: so, instead of just being a silly cynic, I can look at it as maturity?
16:00:11 <ddarius> olsner: It waxes and wanes.
16:00:13 <shapr> monochrom: That'll probably never happen to me.
16:00:22 <augustss> osfameron: the HWN has job ads
16:00:26 <olsner> only about 2h of logs in scrollback from when I left
16:00:33 <shapr> olsner: Though this isn't what I would call heavy traffic.
16:00:35 <sorear> olsner:
16:00:38 <sorear> @where logs
16:00:38 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
16:00:50 <sorear> 200 Mbytes of logs covering five years.
16:00:57 <shapr> Only 200mb!
16:00:58 <shapr> ?
16:01:02 <sorear> yeah!
16:01:12 <shapr> Oh, and dons has user statistics for #haskell as well
16:01:15 <shapr> @where ircstats
16:01:16 <lambdabot> I know nothing about ircstats.
16:01:18 <olsner> which means there's about 4-5h of traffic which is between me leaving and last point of scrollback
16:01:18 <osfameron> @where hwn
16:01:18 <lambdabot> http://sequence.complete.org/
16:01:19 <shapr> hmm
16:01:20 <ddarius> @where stats
16:01:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
16:01:22 <matthew-_> hey, it's haskell - we're more efficient at communication!
16:01:33 <shapr> ddarius: aha, thanks
16:01:40 <sorear> olsner, shapr: I will hpaste my automatic incremental download script, if anyone is interested
16:01:49 <shapr> sorear: I would be actually.
16:01:49 <sioraiocht> okay so I have some confusion -- I am trying to use a StateT monad for this interpreter http://hpaste.org/1678
16:01:57 <sorear> maintains completely painlessly a disk mirror of the logs.
16:02:05 <olsner> I have all the logs in ~/.xchat/xchatlogs/
16:02:12 <sioraiocht> I am not sure how to initialise the state and pass it around.  My eval' function gives me an error
16:02:28 <shapr> For all the paying Haskell work I've gotten, the employers contacted me. The times I've applied for Haskell jobs, I got turned down.
16:02:48 <sorear> geh.
16:02:54 <sioraiocht> hrm, that cut off some of it
16:02:57 <olsner> but the fact that I can't scroll back that far tells enough.. I'm not really interrested in browsing the logs just to find out what I've missed ;-)
16:02:58 <sorear> Everyone knows about Shae Erisson.
16:02:58 <shapr> So I think the real problem for Haskell programmers is that we have to really exploit laziness :-)
16:03:05 <sorear> I need to make my name!
16:03:06 <jmelesky> i've yet to get a paying Haskell job. stuck in python/ruby land
16:03:06 <shapr> sorear: Bah, I'm not that famous!
16:03:27 <kc5tja> Google sought me out because I'd written CUT.
16:03:30 <hpaste>  sioraiocht pasted "StateT monad interpreter cont'd" at http://hpaste.org/1679
16:03:32 <shapr> sorear: Hm, maybe I am.. my name is in the HoPL paper.
16:03:34 <sioraiocht> that's the rest of it
16:03:36 <olsner> although it would be nice if anyone had anything interresting to say about GLR parsing from when I left
16:03:41 <kc5tja> Irony of ironies, nothing I'm doing is in any way related to CUT.  :D
16:03:43 * sorear suspects that he has already reached minor-celeb status.
16:03:53 <jmelesky> heh
16:03:55 <shapr> Of course, lots of people from #haskell are mentioned in the HoPL paper.
16:04:09 <sorear> I'm mentioned in the latest TMR
16:04:23 <olsner> brag, brag, brag .... :P
16:04:24 <ddarius> shapr: You have been fairly significant to the Haskell community.
16:04:25 <augustss> sorear: we'd hire ypu if you were old enough to work ;)
16:04:26 <kolmodin> woho! I bring happyness to the world! kolmodin brings happiness to the world. 15.7% lines contained smiling faces. :)
16:04:27 <pejo> shapr, you're in a far better position when employeers come to you though. (And I would guess most people perform better in interviews if there is less pressure).
16:04:29 <shapr> Oh no, lambdabot is approach my overall ranking in terms number of lines on #haskell !
16:04:31 * kc5tja has very few bragging rights.  :(
16:04:38 <kc5tja> Only one, actually -- my publication in TAPR's journal.
16:04:44 <shapr> olsner: Hey, I'm famous AND modest!
16:04:45 * shapr laughs
16:04:48 * olsner is however drunk, so don't trust him :P
16:05:15 <sorear> pejo: employeers, I like it
16:05:19 <shapr> olsner: But seriously, my reason of fame is just that I know a lot of people in the Haskell world, and what they do.. so people ask me "Who can I ask about X?" and I often know the answer.
16:05:36 <monochrom> sioraiocht: it's too large.
16:05:40 <sorear> shapr: look around
16:05:46 <kc5tja> That one is easy -- dons, sjanssen, and jcreigh of course.  ;D
16:05:52 <sorear> shapr: you remember starting #haskell, surely!
16:05:53 <shapr> sorear: Are you in my apartment??
16:05:55 <sioraiocht> monochrom: i added the rest http://hpaste.org/1679
16:05:58 <shapr> whew
16:06:18 <monochrom> That makes it even larger and harder to follow, sorry.
16:06:36 <shapr> sorear: Yeah, but I wasn't the first one to start a #haskell channel, it's just that this one succeeded. Also, one person does not make a community.
16:06:40 <sioraiocht> lol okies, sorry
16:06:49 <olsner> shapr: but that's often the kind of knowledge people need though
16:07:04 <int-e> shapr: you seem to have written enough for several people though :P
16:07:06 <monochrom> I am not sure I know enough about execute'
16:07:18 <shapr> int-e: On #haskell sure, but I'd like to write more working code too :-)
16:07:27 <olsner> "I want to know A, lots of "B" people know the answer, who are "B"?"
16:07:31 <sioraiocht> monochrom: execute' takes an int and performs a StateT Env IO () action
16:07:40 <hpaste>  sorear pasted "requested auto-downloader" at http://hpaste.org/1680
16:07:46 <shapr> dons has high ranking in both #haskell output and working code!
16:08:13 * sorear wants more working code :(
16:08:16 <shapr> olsner: Yeah true. Is that a commutative query?
16:08:25 <olsner> and people who know the "B" set are often in a position to give an impression of knowing everything :P
16:08:27 * kc5tja wants more working code too.
16:08:38 <monochrom> run' :: Integer -> IO ()  ?
16:09:02 <shapr> olsner: Yeah, but impressions and reality aren't the same thing. On the good side, when I don't know how to do something, I always know who to ask!
16:09:06 <sioraiocht> HA
16:09:20 <sioraiocht> monochrom: that fixed it, I had the wrong teyp signature for run'
16:09:27 <encryptio> @djinn (a -> b) -> (b -> c) -> a -> c
16:09:29 * olsner is beyond grokking haskelly answers to anything at this point :P
16:09:31 <lambdabot> f a b c = b (a c)
16:09:41 <monochrom> Because the whole point of evalStateT is to eliminate StateT.
16:09:55 <olsner> shapr: indeed, that's kind of my point
16:10:10 <sioraiocht> monochrom: ahhhhhh
16:10:21 <sioraiocht> I still don't grok stateT, but i'm getting there =)
16:10:41 <monochrom> Do not grok.  Do a resolution.
16:10:54 <olsner> shapr :: Question -> Either (Person | Answer)
16:10:58 <sioraiocht> monochrom: ?
16:11:00 <shapr> olsner: good point
16:11:06 <monochrom> Logic.
16:11:10 <sioraiocht> aha
16:11:20 <ddarius> Speaking of working code...
16:11:26 <shapr> ddarius: You have some new code?
16:11:37 <icarroll> Does this function already exist somewhere? If not, what's a good name for it?
16:11:39 <icarroll> frob f Nothing b = b
16:11:41 <icarroll> frob f a Nothing = a
16:11:42 <icarroll> frob f a b = liftM2 f a b
16:11:46 <ddarius> Nothing useful really.  The kind of code I excel at.
16:11:49 <olsner> (and I only learned haskell yesterday)
16:12:24 <shapr> olsner: That type sig is excellent for one day of Haskell .. not yet perfect, but the meaning is clear.
16:12:38 <ddarius> The power of natural language.
16:12:40 <shapr> ddarius: I sure like your lambda cal interpreter. That was useful for my learning.
16:12:59 <shapr> icarroll: Perhaps you want Data.Maybe.maybe ?
16:13:24 <shapr> or catMaybes?
16:13:31 <shapr> hmmm
16:14:41 <monochrom> @undo
16:14:42 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
16:14:49 <monochrom> @undo do{return x}
16:14:49 <lambdabot> return x
16:15:12 <monochrom> @undo do{ x<-a; y<-b; g a b }
16:15:13 <lambdabot> a >>= \ x -> b >>= \ y -> g a b
16:15:21 <olsner> ... but anyone know Happy? (GLR-parser-generator for haskell)? it is really bad/old/deprecated/bad... first, it cannot deduce type signatures... then, it gets them wrong (despite me telling it) and can't to anything - it wants me to build ForestIds despite that being what I want HAppy to build for me
16:15:45 <monochrom> @type liftM2
16:15:48 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:16:01 <ddarius> shapr: I implemented Thompson's NFA execution algorithm, or rather everything but that so far.
16:16:21 <int-e> @type mplus
16:16:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:16:38 <monochrom> > liftM2 (+) Nothing (Just 10)
16:16:40 <lambdabot>  Nothing
16:16:47 <monochrom> OH!
16:17:06 <olsner> [as previously indicated, I might be headed for a new parser Monad library and parser generator... just waiting for someone to give me a better way]
16:17:07 <ddarius> shapr: The main use I see for the code is as an example of some clean and clear basic Haskell code.
16:17:11 <shapr> ddarius: That's nifty, are you going to statch it into the regex code?
16:17:25 <icarroll> shapr: my function is something like a cross between liftM2 and mplus
16:17:31 <int-e> frob f a b = liftM2 f a b `mplus` a `mplus` b ... hmm
16:17:42 <monochrom> Yeah int-e
16:17:58 <icarroll> int-e: interesting...
16:18:23 <monochrom> I wonder if there is a short way with fewer testing.
16:18:36 <ddarius> shapr: What else I might do with it depends on how it goes.
16:18:47 <ddarius> Right now I'm also implementing it in C# in parallel.
16:18:47 <shapr> ddarius: Sounds like fun. I'd like to see it at some point.
16:19:10 <olsner> Really, all the different parser generators should be headed towards a common parser/grammer representation and some kind of framework to generate parsers from the Haskell representation
16:19:33 <LoganCapaldo> @type (\f a b -> liftM2 f a b `mplus` a `mplus` b)
16:19:36 <lambdabot> forall a2 (m :: * -> *). (MonadPlus m) => (a2 -> a2 -> a2) -> m a2 -> m a2 -> m a2
16:19:51 <icarroll> olsner: that'd be nice, but what about differences in semantics, such as GLR versus PEG?
16:20:37 <olsner> I mean Parsec was nice code-wise, but unfortunately really only suitable for LL(1) or LL(1)-converted grammars
16:21:28 <ndm> hello everybody!
16:21:32 <ndm> @seen sorear
16:21:33 <lambdabot> sorear is in #haskell-overflow, #haskell-blah, #ghc, #haskell, #haskell-soc and #xmonad. I last heard sorear speak 13m 20s ago.
16:21:59 <olsner> I'm leaning toward a parsec-like way of describing grammars, but that can be fed through any haskell parser-generator... Parsec is really just a CFG with some semantics in the end
16:22:10 <shapr> hiya ndm!
16:22:20 <ndm> sorear, newtype deriving for derive? seems an obvious thing to add - i wondered if there was a nice way of doing it in general
16:22:24 <ndm> hi shapr
16:22:49 <ndm> what are the runtime requirements for doing happs development?
16:22:54 <ndm> i.e. what do i have to get on the server
16:22:55 <sorear> hello ndm
16:23:05 <sorear> ndm: happs is a server
16:23:19 <ndm> i'm about to start work on BP's internal intranet, which is currently ASP - whats the chance of using Haskell?
16:23:22 <sorear> ndm: the best you can do with apache is a redirection rule
16:23:29 <sorear> BP?!
16:23:34 <ndm> sorear: apache, hehe!
16:23:39 <ndm> sorear: yeah, the BP company
16:23:57 <int-e> @type let frob f a = maybe id (maybe a . f) a in frob
16:23:59 <ndm> although i'm only working for one subsection, the lubricants division, on a particular campagin
16:23:59 <lambdabot> forall a. (a -> a -> Maybe a) -> Maybe a -> Maybe a -> Maybe a
16:24:26 <sorear> ndm: anyway, yes, I had thought about newtype deriving.
16:24:39 <ndm> sorear: i though you might have had :)
16:25:00 <ndm> sorear: seems like it should be automated in some way, for some large class of instances?
16:25:05 <sorear> ndm: but it's really hard.  we need information on the class, but even if we can do that, generating the functions won't be easy.
16:25:18 <sorear> ndm: newtype deriving is not a deriving extension
16:25:26 <sorear> ndm: it is a type system extension
16:25:41 <ndm> sorear: i think it should be possible to add, but as you say, its harder than it first looks
16:25:42 <sorear> ndm: you can do things with it that are provably impossible without
16:25:55 <shapr> ndm: If you have any questions about HAppS, it is my day job...
16:25:57 <ndm> really? like what
16:25:59 <sjanssen> are derivations with unsafeCoerce# out of the question? :)
16:26:16 <ndm> shapr: yes, if i have an ASP server, does that mean HAppS is out the question?
16:26:20 <sorear> sjanssen: if you allow that my life gets way easier.
16:26:23 <ndm> sjanssen: it would be less than ideal...
16:26:30 <SamB_XP_> sorear: I was under the impression that you could write out any of the derivings by hand...
16:26:37 <sorear> ndm: remember Unsafe.Coerce.unsafeCoerce is portable
16:26:42 <sorear> SamB_XP_: not with newtypes!
16:26:50 <SamB_XP_> sorear: oh?
16:26:51 <sjanssen> sorear: example?
16:26:55 <ndm> sorear: i know, i'd much rather not rely on it
16:27:08 <SamB_XP_> we need a limited version, then
16:27:11 <ndm> sjanssen: it has weird rules when it works with GHC, you can easily segfault if you are not nice to it
16:27:16 <SamB_XP_> that only works when you could do it by hand
16:27:18 <int-e> sorear: yes it does something unspecified for every haskell implementation ;)
16:27:22 <sjanssen> sorear: I recall an ML thread, but thought the implementors disagreed with you?
16:27:23 <ndm> JHC behaviour is to _always_ segfault
16:27:31 <stepcut> heh
16:27:31 <SamB_XP_> ndm: why segfault?
16:27:48 <SamB_XP_> couldn't it just do a jig or something?
16:27:49 <int-e> jhc expects you to coerce to Boxed (or what's the name) and back.
16:27:50 <sorear> data TEq a b where TEq :: TEq a a
16:27:50 <sorear> class IsInt a where isInt :: TEq Int a
16:27:50 <sorear> instance IsInt Int where isInt = TEq
16:27:50 <sorear> newtype Bar = Bar Int deriving(IsInt)
16:27:54 <shapr> ndm: HAppS is primarily a web application framework. For templating and the like it suggests XML/XSLT. HAppS builds a safe transaction system on top of  STM so you can guarantee you'll never lose data.
16:27:54 <int-e> everything else will break
16:28:06 <sorear> sjanssen:^^^
16:28:14 <sorear> sjanssen: isInt :: TEq Int Bar is not _|_
16:28:28 <sorear> sjanssen: but when I try to case analyse it ghc panics.
16:28:42 <shapr> ndm: Basically, you write a bunch of Haskell code to do whatever you want, then you describe how to turn your State type into an XML tag, then you format that tag with XSLT.
16:28:44 <ndm> shapr: ah, probably not suitable then
16:28:57 <SamB_XP_> sorear: perhaps that is what you call a *bug*?
16:29:03 <ndm> shapr: the requirement is to loose data regularly, and work with anal sysadmins :)
16:29:12 <shapr> ndm: Yeah, it sounds like you want HaskellScript inside ASP pages. I think that's available.
16:29:33 <sorear> sjanssen: Simon says the problem is that newtype deriving was neglected when they were looking at things to fix after adding GADTs.
16:29:36 <shapr> I'm pretty sure there's a version of Haskell that works with Windows Scripting Host, and therefore will let you script inside ASP pages.
16:29:37 <ndm> shapr: the evil sys-admins don't like installing stuff, but that may be possible
16:30:05 <sorear> sjanssen: but that's actually not the whole story - you can make an explicit coercion with only the one extension
16:30:21 <shapr> Isn't everything in ASP passed around as a Variant though? I mean, you basically get Dynamic, yeah?
16:30:22 <sorear> class IsInt a where isInt :: c a -> c Int
16:30:22 <sorear> instance IsInt Int where isInt = id
16:30:22 <sorear> newtype Bar = Bar Int deriving(IsInt)
16:30:49 <ndm> shapr, its a variant, which is an object, which is a COM object, which has some dynamic methods
16:31:12 <shapr> I look forward to hearing about your experiences :-)
16:31:14 <SamB_XP_> sorear: that one doesn't coerce
16:31:19 <olsner> icarroll: what is the difference between GLR and PEG?
16:31:20 <shapr> I'd like to know which parts are easy, and which are hard.
16:31:31 <sorear> ndm: so, even if you restrict yourself to haskell98 classes, newtype deriving is impossible.
16:31:37 <hpaste>  DukeDave pasted "Maybe a more elegant solution?" at http://hpaste.org/1681
16:31:41 <ndm> shapr: i've done it once before for them, using ASP - its not particularly hard, but it is a pain
16:31:42 <sjanssen> sorear: that last example seems less evil to me
16:31:54 <sorear> sjanssen: huh?
16:31:55 <SamB_XP_> sorear: it actually avoids coercing
16:32:01 <sorear> sjanssen: it still demonstrates my point
16:32:06 <SamB_XP_> sorear: in fact, I really really really like it...
16:32:24 <sorear> SamB_XP_: what do you think coerce means?  I'm using it in the same sense SystemFC does.
16:32:28 <SamB_XP_> too bad you cant do derivings outside the newtype definition...
16:32:29 <Saizan> isn't that deriving equivalent to  instance IsInte Bar where isInt (Bar i) = isInt i ?
16:32:32 <shapr> @quote newtype deriving
16:32:32 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
16:32:36 <shapr> @quote newtype
16:32:36 <lambdabot> ghc says: even with cunning newtype deriving the newtype is recursive
16:32:42 <icarroll> olsner: quite a bit http://en.wikipedia.org/wiki/Parsing_expression_grammar
16:32:43 <lambdabot> Title: Parsing expression grammar - Wikipedia, the free encyclopedia
16:32:47 <sjanssen> sorear: writing a function :: SomeClass a => a -> Int -- doesn't seem like a big problem
16:32:48 <olsner> hmm... "Unlike CFGs, PEGs are unambiguous; if a string parses, it has exactly one valid parse tree. " - but what about ambiguous grammars?
16:32:57 <sorear> Saizan: No.
16:32:58 <olsner> C++ for example, isn
16:32:59 <DukeDave> Hey guys, I'm open to suggestions on my last paste if you're feeling like a qucky :)
16:33:02 <SamB_XP_> sjanssen: did you notice the cs?
16:33:03 <sorear> sjanssen: No, you forgot the c
16:33:18 <olsner> darn... single-quote is too close to Enter :P
16:33:26 <sorear> sjanssen: Parametricity guarantees that this cannot be done.
16:33:34 <sjanssen> sorear: ah yes, the 'c' part makes it bad
16:33:37 <shapr> olsner: Try dvorak!
16:34:07 <Saizan> oh, the c..
16:34:13 <icarroll> olsner: IIRC, it's impossible to define an ambiguous grammer in PEG
16:34:15 <sorear> olsner: C++ isn't ambiguous IIRC.  It probably requires unlimited lookahead, but that's not the same.
16:34:22 <olsner> ... C++ isn't unambiguouse regardless of expression of the grammar AFAIK ... at least, name lookup and semantics both need to be involved to resolve the declaration/expression ambiguity
16:34:26 <SamB_XP_> okay, so do we need to make newtype derivings actually generate a method body to typecheck?
16:34:31 <araujo> is there a way to force an IO computation?
16:34:52 <sorear> araujo: yes, exactly one way.
16:34:53 <shapr> araujo: seq or DeepSeq when you get desperate?
16:34:58 <sorear> araujo: bind it to main
16:35:00 <araujo> to be evaluated
16:35:09 <sjanssen> sorear: any idea what sort of restrictions are needed to prevent this?
16:35:12 <araujo> mm...
16:35:12 <shapr> araujo: put its result into a strict datatype?
16:35:21 <sorear> sjanssen: why do you want it prevented?
16:35:29 * sorear feels persecuted
16:35:29 <araujo> shapr, let me try that
16:35:41 <SamB_XP_> sorear: well, it wasn't advertised as breaking the rules!
16:35:46 <olsner> in any case, I'd like to have a grammar/parser formalism that doesn't need an unambiguous grammar (it's all optimization from that point on - which is the kind of approach I like)
16:36:00 <SamB_XP_> sorear: it was supposed to be a shortcut with an efficiency hack
16:36:03 <sorear> olsner: Try polyparse!
16:36:07 <sjanssen> sorear: in some compilers a newtype isn't represented in the same way as the type itself
16:36:12 <ddarius> araujo: evaluate
16:36:13 <shapr> olsner: I thought PEGs weren't ambiguous?
16:36:26 <sorear> sjanssen: That's actually against the Haskell spec.
16:36:30 <shapr> oh, I misread, sorry.
16:36:40 <araujo> ddarius, i thought evaluate is for pure values
16:36:41 <sorear> sjanssen: there was a thread on it a while back.
16:36:49 <ddarius> :t evaluate
16:36:58 <lambdabot> forall a. (Testable a) => a -> Gen Result
16:36:59 <araujo> @hoogle DeepSeq
16:37:00 <lambdabot> No matches found
16:37:04 <olsner> shapr: that's what the wikipedia says at least.. but I assume that the work of transforming the standard grammar to PEG is equivalent to LR- or LL-ifying the grammar
16:37:05 <ddarius> @hoogle evaluate
16:37:06 <lambdabot> Control.Exception.evaluate :: a -> IO a
16:37:06 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
16:37:12 <sorear> a matches IO b!
16:37:33 <SamB_XP_> what exactly do we mean by "evaluate"?
16:37:37 <sorear> olsner: just use polyparse, no need to disambig!
16:37:42 <sorear> @where polyparse
16:37:43 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
16:37:47 <ddarius> Hmm, I thought it was something else.  Maybe I'm thinking of something else.
16:37:52 * olsner == looking at polyparse, yes
16:37:55 <shapr> olsner: I think I read long ago that PEGs are just like ambiguous grammars, except precedence is always added.
16:38:04 <ddarius> Anyways, how is your IO computation not "being forced"?
16:38:12 <monochrom> > mapMaybe (\z -> case z of (a,Nothing)->Nothing; (a,Just b)->Just(a,b)) [(1,Nothing), (2,Just True)]
16:38:14 <lambdabot>  [(2,True)]
16:38:20 <olsner> btw, is polyparse a PEG library?
16:38:25 <sorear> No!
16:38:26 <araujo> ddarius, For something reason, the computation doesn't run sometimes ...
16:38:28 <monochrom> DukeDave: do you like that?
16:38:32 <SamB_XP_> sorear: well, I'm pretty sure newtype derivings are not *intended* to break the rules
16:38:35 <araujo> ddarius, i am using gtk signals with gtk2hs
16:38:43 <olsner> ... I should call it a night and come back tomorrow really
16:38:51 <sorear> araujo: running has nothing to do with forcing.  Haskell is pure.
16:38:53 <SamB_XP_> if they *are*, that should be an extension of *them*
16:39:13 <sorear> I like my back doors!
16:39:18 <sjanssen> sorear: the statement "introduces a new type whose representation is the same as an existing type" is a statement of questionable value IMO
16:39:29 <araujo> sorear, well, i want to force the computation to run it.
16:39:54 <sorear> sjanssen: we can't ignore parts of the spec just because we doubt their value.
16:40:03 <int-e> ok, jhc can't implement clever newtype deriving as ghc does.
16:40:06 <sorear> araujo: running it will automatically force it
16:40:15 <int-e> sorear: can this actually crash a program?
16:40:27 <SamB_XP_> sorear: I don't think that part was exactly normative
16:40:32 <sorear> int-e: no, it's perfectly typesafe
16:40:46 <araujo> sorear, hah, now i am confused, the thing is, that doesn't run sometimes.
16:40:46 <sorear> int-e: because it desugars into type correct system fc
16:40:54 <SamB_XP_> I think it was more of a statement of the *point*
16:40:59 <sjanssen> sorear: I'm saying it should be changed, because it isn't consistent.  The report rarely constrains implementations in this way
16:41:01 <int-e> sorear: good. thanks.
16:41:20 <araujo> It's something like, object `signal` func ...... , func doesn't run sometimes.
16:41:22 <olsner> those kinds (weak, C-typedef-ish, etc) of types are in the gray zone between static/strict type checking and rapid prototyping IMO... and have their place in the scheme of things
16:41:56 <sorear> int-e: the point is it desugares into type correct system fc, and it is the only way to obtain said effect from the desugarer
16:42:16 <sorear> araujo: right, if the signal isn't recieved!
16:42:33 <Saizan> DukeDave: catMaybeSnd xs = [(a,b) | (a,Just b) <- xs ]
16:42:36 <olsner> on the one hand, you want them strict in order to abstract and modularize in the future - OTOH you want them weak in order to be able to Just Write It
16:42:46 <araujo> sorear, right .. mm ... well ... i am sending the signal ....
16:42:58 <sorear> araujo: check for race conditions.
16:43:08 <ddarius> sorear: Yes we can (re ignoring parts of the spec)
16:43:16 <araujo> sorear, ok, ok
16:43:18 <sorear> er, shouldn't
16:43:35 <int-e> sorear: and at that point you need a (system fc) coercion and that's what you were saying all along. right?
16:43:58 <LoganCapaldo> > let catMaybeSnd xs = [(a,b) | (a, Just b) <- xs] in catMaybeSnd [(1, Nothing), (2, Just 3)]
16:44:00 <lambdabot>  [(2,3)]
16:44:01 <sorear> int-e: yes.
16:44:06 <LoganCapaldo> eek!
16:44:27 <LoganCapaldo> I did not know pattern match failures had those semantics in list comprehensions
16:44:35 <LoganCapaldo> That's totally awesome
16:44:46 <sorear> int-e: I had a stroke of excessive cleverness and figured out how to reify the FC coercions.  It didn't work, I complained on the ML, they tried to close my back door.
16:44:58 <ddarius> olsner: Haskell has both strong and weak typedefs
16:45:13 <olsner> hmm.. is that type vs newtype?
16:45:18 <sorear> yes.
16:45:21 <olsner> Ada-ish :P
16:45:23 <SamB_XP_> sorear: if you want that feature, you need a new extension that is *supposed* to do what you do
16:45:44 <ddarius> LoganCapaldo: The same happens in do notation.  Hence fail being part of the Monad class.
16:46:06 <LoganCapaldo> ddarius: I was jsut gonna ask that question :)
16:46:16 <LordBrain> is there any ghc 6.6.1 windows binary ?
16:46:23 <LordBrain> on the web anywhere?
16:46:51 <sorear> LordBrain: just use 6.6.0
16:46:54 <LordBrain> i'd be willing to build it, if i have helpers.
16:46:58 <sorear> 6.6.1 is far too new
16:47:11 <LoganCapaldo> @type let foo x = do { (Just a) <- x; return a } in foo
16:47:14 <lambdabot> forall (t :: * -> *) t1. (Monad t) => t (Maybe t1) -> t t1
16:47:23 <sorear> no parens
16:47:55 <LordBrain> 6.6.1 is not considered stable?
16:48:27 <LordBrain> i sort of want a custom build anyway
16:48:59 <sorear> LordBrain: it's stable, but there is no point in building it
16:49:15 <LoganCapaldo> :t listToMaybe
16:49:18 <lambdabot> forall a. [a] -> Maybe a
16:49:25 <LoganCapaldo> :t maybeToList
16:49:28 <lambdabot> forall a. Maybe a -> [a]
16:49:31 <sorear> LordBrain: if you have the choice between 6.6.0 binary and build your own 6.6.1, take 6.6.0; 6.6.1 isn't worth it
16:49:37 <LoganCapaldo> :t maybeToM
16:49:40 <lambdabot> Not in scope: `maybeToM'
16:49:48 <sorear> doesn't exist,
16:49:54 <LordBrain> yes, well, it would be very convenient if at least one lib was rebuilt tho
16:50:13 <sjanssen> @type maybe (fail "") return
16:50:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
16:50:19 <LordBrain> it would be nice if my System.Win32 had libunicows statically linked in
16:50:27 <ddarius> or
16:50:31 <ddarius> :t maybe mzero return
16:50:33 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
16:50:57 <LoganCapaldo> but sjannssen works for more monads no?
16:51:08 <ddarius> His works for all monads.
16:51:21 <sorear> sjanssen blows up for some monads.
16:51:31 <sorear> ddarius always works when he typechecks
16:51:49 <ddarius> That said, arguably using patterns in do should add a MonadPlus (or MonadZero) constraint and not pollute the Monad class.
16:52:24 <LoganCapaldo> do+ { ... } :)
16:53:22 <ddarius> LoganCapaldo: The translation of do notation is purely syntactic, absolutely nothing needs to be done just replace uses of fail with mzer.
16:53:30 <ddarius> s/mzer/mzero\
16:56:38 <sorear> waaaahaaaah
16:56:41 <sorear> coreSyn/CoreUtils.lhs:258:0:
16:56:41 <sorear>     Equations for `mkAltExpr' have different numbers of arguments
16:58:15 <DukeDave> Saizan, thanks! :)
17:00:07 <monochrom> Hahaha too much hacking the core!
17:00:32 <sorear> I was actually able to fix that error.
17:00:42 <sorear> Now let's see if the build suceeds.
17:00:51 <sorear> if it does - mega fun!
17:01:17 <monochrom> What did you do?
17:01:26 <monochrom> I mean what is the mega fun?
17:02:28 <sorear> I'll have a working head ghc, and probably a few ++'s
17:02:28 <sorear> and more confidence!
17:02:28 <monochrom> that is business as usual.
17:02:35 <sorear> For you :)
17:08:34 <sorear> *faint* GHC proper just finished compiling
17:09:08 <Saizan> uoh, even regex-base/regex-compat ?
17:11:36 <sorear> Saizan:
17:11:42 <sorear> ghc *proper*
17:11:49 <ddarius> @spell repitition
17:11:58 <sorear> Erm, I hope I'm using it corectly.
17:12:03 <sorear> @web1913 proper
17:12:06 <lambdabot> *** "Proper" web1913 "Webster's Revised Unabridged Dictionary (1913)"
17:12:06 <lambdabot> Proper \Prop"er\, a. [OE. propre, F. propre, fr. L. proprius.
17:12:06 <lambdabot>    Cf. {Appropriate}.]
17:12:06 <lambdabot>    1. Belonging to one; one's own; individual. ``His proper
17:12:06 <lambdabot>       good'' [i. e., his own possessions]. --Chaucer. ``My
17:12:08 <lambdabot> [62 @more lines]
17:12:20 <ddarius> sorear: You are.
17:12:45 <sorear> OK, I'll put this paper dictionary down :)
17:12:52 <Saizan> :D
17:13:14 <Binkley> if only more people IRCed with a dictionary by their side :-)
17:14:24 <Saizan> i was hoping!
17:15:04 <jcreigh> So what's the deal with the _darcs/prefs files? Are they totally unversioned? Can I submit a patch against, eg, the _darcs/prefs/prefs file?
17:15:15 <DukeDave> > on
17:15:16 <lambdabot>   Not in scope: `on'
17:15:28 <sorear> jcreigh: yup, almost totally unversioned.
17:15:46 <sorear> jcreigh: you can use darcs setpref, but that only works for two of the files
17:16:09 <jcreigh> so...if the prefs file on the repo I'm pulling from gets updated, does mine get updated?
17:16:14 <sorear> jcreigh: the best approach is to crack sjanssen's box and modify the pref files in place
17:16:18 <sorear> I don't think so
17:16:44 <Saizan> and if ypou add it to the repo?
17:17:23 <sorear> amusingly, I lost the password for my ssh private key
17:17:37 <jcreigh> heh, I did that too. (my private key, not yours)
17:17:41 <sorear> and the only way I found this was when attempting to use it to log in to ndm's box
17:17:58 <sorear> it sounded easier than explaining how to configure email files
17:18:00 <sorear> it wasn't
17:18:10 <sorear> _darcs/prefs/email that is
17:21:22 <int-e> hmpf. darcs send -o foo --repodir bar  creates its output in bar/foo
17:21:51 <sorear> are you suprised? chdir--
17:22:02 <int-e> not surprised but disappointed.
17:22:36 <narain> there's a post on planet haskell that's a month or so old but keeps getting bumped up to the top
17:22:54 <sorear> yeah
17:23:02 <sorear> can we have him kicked off?
17:23:13 <stepcut> narain: probably whenever someone makes a comment, or something like that
17:23:22 <sorear> I wrote the planet maintainer and he says there's nothing he can do
17:23:41 <LoganCapaldo> @hoogle Dynamic -> Maybe a
17:23:42 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
17:23:58 <narain> i'm looking at the feed source right now, let's see if i can find anything
17:24:36 <sorear> It's most probably a bug in the Planet software (or in the relevant
17:24:36 <sorear> feeds) making Planet think that the reappearing entries are new when
17:24:36 <sorear> they are not.
17:24:39 <narain> yes, the published date is correct but the updated date, um, updates all the time
17:24:49 <narain> scratch that "yes"
17:25:24 <sorear> Anyone else want a "No buggy blogs" policy?
17:25:25 <ddarius> :t unfoldr
17:25:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:26:11 <Gwern> is that the Haskell eye for ruby guy post?
17:26:16 <sorear> Yes!
17:26:19 <Gwern> I thought that was just my gnus acting up
17:26:30 <LoganCapaldo> > unfoldr (\x -> (x  + 1, Just $ x + 1)) 0
17:26:32 <lambdabot>  Couldn't match expected type `Maybe (a, b)'
17:26:32 <Gwern> (I've seen that damn post like 20 times now)
17:26:41 <Gwern> also, an awful lot of xmonad posts recently
17:26:51 * sorear incites a mob to attack Antonio!
17:26:53 <narain> has somebody told the blog author that his feed is buggy
17:26:54 <narain> ?
17:27:18 <LoganCapaldo> > unfoldr (\x -> Just (x + 1, x + 1)) 0
17:27:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:27:22 <sjanssen> ha, I thought it was my client's fault too
17:27:36 <sorear> narain, Gwern, sjanssen: Let's all mail him at the same time!
17:27:48 <narain> otherwise one could conceivably patch Planet to sort by published rather than updated
17:28:07 <sjanssen> sorear: what did ibid say?
17:28:13 <narain> sorear: heh
17:28:37 <sorear> sjanssen: if ibid is Antti-Juliani Kattano
17:28:38 <sorear> <sorear> It's most probably a bug in the Planet software (or in the relevant
17:28:38 <sorear> <sorear> feeds) making Planet think that the reappearing entries are new when
17:28:38 <sorear> <sorear> they are not.
17:29:03 <sorear> erm, that should be Antsy-Juliani, for the sake of the theme
17:29:12 * sorear can't spell finnish names
17:29:30 <sorear> mailto:info@antoniocangiano.com
17:29:42 <sorear> Anyone who wants to complain, I invite you!
17:29:44 <narain> why do people not just look at the feed source? that's what they made rest and xml human-readable *for*
17:29:51 <Gwern> sorear: too lazy
17:30:08 * Gwern drools some more on the keyboard as I stuff some more cheetos into my mouth
17:30:48 <Pseudonym> Don't worry, Haskell is drool-proof.
17:31:48 <Gwern> yes, thanks to its advanced type system and encapsulation of drool-effects
17:33:35 <int-e> unsafeDroolOnKeyboard
17:33:59 <Binkley> careful, you might accidentally end up with twice the expected amount of drool on your keyboard
17:34:07 <narain> thanks to lazy evaluation, haskell never evaluates drool until it is actually needed. and i can't think of any place where drool is needed.
17:34:08 <Gwern> shouldn't use it unless you can prove it's referentially transparent w/r/t location of mouth
17:34:22 <Gwern> otherwise the drool might end up anywhere in memory like on your pants or cat!
17:36:55 <sorear> narain: as is my usual practice with potentially inflamatory messages I sent it to a random other address.
17:37:01 <sorear> narain: specifically yours
17:37:15 <sorear> narain: does it look safe to sent to Antonio?
17:37:33 <narain> "random" address you say
17:37:37 <sorear> Base is done building
17:37:38 <narain> let me go read it
17:41:29 <ddarius> @hoogle unfoldM
17:41:30 <lambdabot> No matches found
17:45:12 <LoganCapaldo> @hoogle unfoldrM
17:45:13 <lambdabot> No matches found
17:45:50 <LoganCapaldo> :t liftM . unfoldr
17:45:53 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (b -> Maybe (a, b)) -> m b -> m [a]
17:46:15 <narain> ?src foldM
17:46:15 <lambdabot> foldM _ a []     = return a
17:46:16 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
17:47:06 <LoganCapaldo> :t foldM
17:47:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:50:23 <sorear> done with html...
17:50:33 <LoganCapaldo> hmm the type of liftM . unfoldr doesn't sound right
17:50:51 <ddarius> LoganCapaldo: liftM = fmap
17:51:03 <LoganCapaldo> I know this :)
17:51:27 <ddarius> So all liftM . unfoldr does is call unfoldr f on the structure element
17:51:30 <ddarius> -wise
17:51:35 <LoganCapaldo> yes
17:52:16 <sorear> 16/33
17:52:23 * sorear is getting his hopes up
17:52:35 <ddarius> sorear's doing it again
17:56:04 <dons> jcreigh: patch applied.
17:56:38 <jcreigh> dons: thank you. this should help avoid followup "fixed tests" patches.
17:57:45 <dons> hopefully, yeah
17:57:48 <dons> ?users
17:57:48 <lambdabot> Maximum users seen in #haskell: 336, currently: 311 (92.6%), active: 49 (15.8%)
18:01:22 <dfranke> I'm trying to get Haddock to work with GADTs.  I found some mailing list noise on Google about a hack that sort of works, but I can't find the actual patch.  Any pointers?
18:01:33 <sorear> I'd recomment
18:01:37 <sorear> @where haddock-ghc
18:01:38 <lambdabot> I know nothing about haddock-ghc.
18:01:41 <sorear> @where haddock.ghc
18:01:42 <lambdabot> I know nothing about haddock.ghc.
18:01:48 <sorear> @slap wheredb
18:01:49 * lambdabot smacks wheredb about with a large trout
18:01:57 <sorear> @google haddock.ghc
18:02:00 <lambdabot> http://darcs.haskell.org/SoC/haddock.ghc/
18:02:00 <lambdabot> Title: Index of /SoC/haddock.ghc
18:02:03 <LoganCapaldo> @slap @slap
18:02:03 <sorear> that's it.
18:02:04 * lambdabot slaps @slap
18:05:17 <fax> @slap spals tobadbmal *
18:05:18 * lambdabot smacks spals tobadbmal * about with a large trout
18:05:22 <fax> aw damn
18:06:08 <dfranke> thanks.
18:06:26 <araujo> sorear, any special libs to work around race conditions?
18:06:57 <EvilTerran> so, there's this two-parameter type, and i want to declare it to be an instance of Monad parameterised on the first typaram. is this possible?
18:07:18 <EvilTerran> instance Monad (flip Foo a) where..., if such a thing worked
18:07:34 <LoganCapaldo> type Flip t a b = t b a
18:07:45 <ddarius> Won't work.
18:07:57 <LoganCapaldo> be nice if it did :(
18:08:17 <araujo> seq has seemed to help me to 'run' the code more frequently
18:08:24 <ddarius> Partially applied type synonyms = undecidable type system.
18:08:31 * kc5tja rather enjoys getting out of work on-time for a change.
18:08:45 <ddarius> There is some crazy Oleg type level hackery that could do it, but...
18:08:50 <sorear> ddarius: Perfectly decidable, you just have to give something else up.
18:09:06 <LoganCapaldo> newtype Flip t a b = Flip (t b a) ?
18:09:17 <sorear> ddarius: If you're willing to type your binders, the CoC can partially apply types and a whole lot more.
18:09:31 <sorear> araujo: uh, don't use threads or events?
18:09:48 <sorear> I can certainly see that being hard with GUIs, though :)
18:10:15 <EvilTerran> LoganCapaldo, and the instance declaration?
18:10:24 <araujo> sorear, let's say it is ... funny :-)
18:10:52 <EvilTerran> instance Monad (Flip (Foo a)) where... i guess sort-of makes sense...
18:11:00 <LoganCapaldo> well it would be instance (Flip Foo a)
18:11:04 <LoganCapaldo> I think
18:11:08 <Saizan> yup
18:11:08 <EvilTerran> ah, yes
18:11:26 <sorear> Actually, this CAN work.
18:11:28 <LoganCapaldo> but it would be a pain in the neck because you'd have to stick Flip in front of things all the time and what not
18:11:41 <sorear> oh, LC beat me to it
18:11:44 <centrinia> What implementation of a functional programming language is, on the average, very fast?
18:12:00 <sorear> centrinia: define very.
18:12:14 <sorear> centrinia: ghc is pretty much the best now, sadly
18:12:17 <kc5tja> centrinia: OCaml.
18:12:23 <ddarius> centrinia: Presumably you mean produces fast code.
18:12:38 <ddarius> Single Assignment C
18:12:39 <sorear> OCaml and Clean used to be much faster, but I've heard they've lost there lead
18:12:41 <kc5tja> GHC does amazingly well.
18:13:21 <centrinia> GHC is pretty good for multicore systems in my experience.
18:13:45 <kc5tja> OCaml is not as fast as GHC for some programs, but it IS more consistently faster than Haskell (in that, GHC can be as fast as or faster than OCaml, but you have to really work at it.  OCaml is faster for the average one-off, I-don't-care-how-fast-it-goes programs).
18:13:49 <ddarius> http://www.sac-home.org/
18:13:50 <lambdabot> Title: SAC-Home [Home]
18:14:18 <sorear> Amazingly, OCaml does this without even having machine ints.
18:14:26 <centrinia> Hmm.
18:15:18 <LoganCapaldo> OCamlohoma
18:15:35 <centrinia> I was thinking of making a low level functional programming language that wraps very small snippets of assembly code.
18:16:30 <sorear> Well you can pretty much do that in haskell.
18:16:44 <sorear> Haskell has IMO the best foreign interface in existance.
18:17:00 <sorear> it's almost as easy as 'extern "C"'
18:18:15 <SamB_XP_> perhaps easier
18:18:22 <SamB_XP_> you don't have to remember the }
18:18:56 <dons> centrinia: you've used ghc for some multicore programming?
18:19:32 <ClaudiusMaximus> is there a way to wrap a C .h file to a Haskell module without having to write loads of ffi declarations by hand?
18:19:35 <centrinia> Yes.
18:19:57 <dons> i'd say Clean has the best compiler and code generator currently, but I suspect a better ghc backend might be very competitive after this summer
18:19:58 <kc5tja> centrinia: Funny -- I'm actually pondering a Scheme subset that is statically compilable for the purposes of embedded software development.
18:20:09 <dons> ocaml and clean are comparable, but clean seems to do a little better
18:20:22 <centrinia> And cleaner? :p
18:20:36 <dons> centrinia: anything interesting, or just Control.Concurrent stuff? *.Parallel.Strategies? NDP arrays?
18:20:50 <Adamant> kc5tja, look at PreScheme
18:20:53 <kc5tja> sorear: Best FFI -- WITHOUT QUESTION!  I've looked at a lot of other systems, but Haskell's FFI just plain rules.
18:20:55 <centrinia> Actually, GHC did the parallelization for me.
18:21:03 <ddarius> "Hypothesis: Design patterns deal with universal constructions of category theory"
18:21:17 <dons> centrinia: oh, with `par` ?
18:21:29 <centrinia> I just wrote a Fibonacci number generator the way any linear algebraist would do.
18:21:31 <araujo> hi dons
18:21:33 <dons> or [: | :] parallel array comprehensions?
18:21:39 * kc5tja still thinks you can have design patterns with Haskell too -- they'll just be different sets of patterns.
18:21:42 <centrinia> dons, no.
18:21:56 <kc5tja> E.g., the Visitor pattern is nonsensical in CLOS, since it natively supports multiple dispatch.  But it's still a valid pattern.
18:21:59 <dfranke> kc5tja, you might think differently the first time you have to deal with FFI garbage collection.
18:22:06 <araujo> dons, i am having some race conditions problems (it seems) , do you know a way to force the evaluation of an IO computation?
18:22:08 <dons> centrinia: how did you parallelise it then?
18:22:15 <dons> araujo: yeah, deepSeq
18:22:27 <sorear> araujo: IO in haskell is strict!
18:22:28 <kc5tja> dfranke: Haskell's FFI supports unmanaged data objects, as I recall.
18:22:32 <centrinia> By using Strassen's matrix multiplication algorithm.
18:22:40 <araujo> dons, ok, yes, shapr mentioned it too , where can i find it?
18:22:48 <dons> did you use forkIO to get extra threads?
18:22:49 <dfranke> kc5tja, yes, but then you have to manage them yourself.
18:22:54 <araujo> dons, yes
18:23:02 <kc5tja> dfranke: Hey, if you're dealing with C, you deal with its problems too.
18:23:02 <dons> centrinia: ^^?/
18:23:04 <centrinia> [1,1; 1,0]^n => [F_n, F_{n-1}; F_{n-1}, F_{n-2}];
18:23:21 <araujo> dons, oh, well, no, sorry, i am not using forkIO in that part
18:23:38 <dons> centrinia: right. then what, a parMap? (it won't use multiple calls unless you ask for threads somewhere)
18:23:44 <araujo> sorear, yeah .. grasping at the idea ... though it's difficult when i am facing this :-P
18:23:44 <dons> multiple cores.
18:23:48 <sorear> centrinia: http://haskell.org/pipermail/haskell-cafe/2007-February/022647.html
18:23:50 <lambdabot> Title: [Haskell-cafe] speeding up fibonacci with memoizing, http://tinyurl.com/yrkpf4
18:24:10 <sorear> centrinia: read that, I've summarized a dozen fast fib algorithms in haskell
18:24:39 <centrinia> dons, I just timed it on a Core Duo and a similarly clocked Athlon 64 (with a single core), the Core Duo is about twice as fast. :D
18:24:56 <dons> it won't be using multiple cores though, just by doing that transformation.
18:24:58 <sorear> centrinia: you should have used 'time'
18:25:08 <centrinia> I did.
18:25:11 <sorear> centrinia: time will say '200% cpu'
18:25:12 <dons> not unles you actually ask for 'forkIO' or `par` and use +RTS -N2
18:25:23 <sorear> centrinia: if you are actually using both cores
18:25:37 <dons> there's no magic parallelisatoin in ghc :-)
18:25:43 <centrinia> What? :O
18:25:44 <dons> there's just semi-magic
18:25:45 <araujo> Anybody knows where can i find deepSeq?
18:25:55 <sorear> araujo: you can't
18:25:58 <ddarius> Use rnf in Control.Concurrent
18:26:00 <sorear> araujo: it doesn't exists
18:26:08 <dons> araujo: its on google, but basically its a simple typeclass that recursively descends a structure seq it
18:26:13 <dons> sorear: sure it does. its part of lambdabot
18:26:27 <dons> sorear: such a drama queen, you are!
18:26:35 <sorear> dons: it's in control.parallel.strategies, but it ain't called deepSeq!
18:26:40 <araujo> sorear, haha, you are driving me crazy :-P
18:26:46 <dons> deepSeq itself actually does exist.
18:27:07 <araujo> I think seq /= deepSeq , right?
18:27:12 <ddarius> correct
18:27:14 <ddarius> @hoogle rnf
18:27:15 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
18:27:25 <sorear> araujo: remember hpaste for when you give up :)
18:29:11 <LordBrain> hmmm.. is there a nice simple alternative to the sequence:  >>= return
18:29:21 <sorear> yeah, nothing at all
18:29:22 <araujo> sorear, hahaha
18:29:22 <LordBrain> besides liftM
18:29:41 <sorear> x >>= return         =========          x
18:29:45 <sorear> that's a monad law!
18:29:46 <LordBrain> i want to be able to just replace those symbols
18:29:46 <dons> ?src liftM
18:29:47 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:29:51 <LordBrain> no
18:29:52 <LordBrain> i have
18:30:08 <araujo> sorear, i am not sure if somebody would like to see a code snippet that doesn't make sense at all without the rest of the code ... but i will do it as the last resource :-)
18:30:08 <LordBrain> m a >= return f >= g
18:30:12 <LordBrain> er
18:30:17 <LordBrain> m a >>= return f >>= g
18:30:20 <LordBrain> somethign like that
18:30:28 <sorear> araujo: ok, tarballs and paste a url then :)
18:30:31 <LordBrain> i want to replace the first '>>='
18:30:48 <araujo> sorear, you will be the first to know it :-)
18:30:58 <sorear> oh, that return is in the (->) monad
18:31:11 <sorear> so m a >> f >>= g
18:31:30 <LordBrain> no
18:31:52 <ddarius> liftM f m = m >>= return . f
18:32:05 <LordBrain> right
18:32:11 <LordBrain> i want like an infix liftM
18:32:12 <sorear> LordBrain: you can't just replace symbols in haskell
18:32:19 <ddarius> `liftM`
18:32:25 <sorear> LordBrain: you have to consider precedence!
18:32:32 <LordBrain> hehe
18:32:53 * sorear defines >>$ as flip fmap
18:32:55 <LordBrain> also flipped
18:33:18 <LordBrain> ah
18:33:22 <LordBrain> thats a good one
18:35:20 <LordBrain> thats exactly what i'm after... perhaps we should have that semi standardized
18:35:26 <narain> isn't  m a >>= return f  ==  m f ?
18:35:46 <LordBrain> i meant return . f
18:35:50 <LordBrain> above
18:36:01 <narain> oh um. ok
18:40:07 <narain> ?hoogle Maybe a -> a
18:40:08 <lambdabot> Maybe.fromJust :: Maybe a -> a
18:40:08 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
18:40:08 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
18:40:19 <sorear> @quote spry
18:40:20 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
18:40:48 <narain> :t map (id *** fromJust) . filter (isJust . snd)
18:40:48 <ddarius> Insanity.  But with a pretty picture.
18:40:51 <lambdabot> forall a a1. [(a1, Maybe a)] -> [(a1, a)]
18:42:33 <MyCatVerbs> Hrmn. Is it possible to get the Haddock output for ghc's libraries in a tarball somewhere?
18:42:44 <sorear> MyCatVerbs: yes.
18:42:54 <sorear> <sorear> yes, there is a debian package ghc6-doc
18:42:54 <sorear> <sorear> you should be able to unpack and read it on any system
18:43:00 <MyCatVerbs> My internet access here is completely unmentionable, so offline browsing is something of a must.
18:43:16 <sorear> it's also on the ghc download page (which you did check, right?)
18:43:41 <MyCatVerbs> Oops.
18:45:57 <MyCatVerbs> sorear: thanks. I feel like a complete dumbass now, but that's nothing new. =)
18:46:05 <ddarius> Crazy choice of names == confusion.
18:47:28 <MyCatVerbs> CABAL rules. Whoo.
18:47:49 <sorear> WOOHOO!!!!
18:47:53 <sorear> GHC BUILDS!!!
18:48:04 <ddarius> Crazy reversed PDF explains everything.
18:48:20 <MyCatVerbs> sorear: ...I'd be lying if I said I wasn't thrilled every time that happened =)
18:48:38 <sorear> MyCatVerbs: I've been trying without sucess for about a month now.
18:48:52 <sorear> MyCatVerbs: Normally it's no big deal - I run head recompiled weekly.
18:49:08 * ddarius needs to write his PDF library.
18:50:02 <ddarius> That should make me feel better too.
18:50:30 <MyCatVerbs> sorear: development is, I presume, rather rapid?
18:51:58 <sorear> The Glorious Glasgow Haskell Compilation System, version 6.7.20070502
18:53:15 * MyCatVerbs only just noticed the seven.
18:53:42 <dolio> It hadn't been working for you for a month?
18:53:45 <MyCatVerbs> I presume it's the traditional kernel.org-style thing? Odd numbers are development branches, even stable?
18:55:29 <chowmeined> I am trying to follow this tutorial but ghci wont let me write test 1 = 1.. test n = 3 * (n-1)
18:56:17 <narain> > let test 1 = 1; test n = 3*(n-1) in test 10
18:56:19 <lambdabot>  27
18:56:29 <kpreid> chowmeined: ghci accepts only expressions; that's a definition. you can either put it in a file and load the file in ghci, or write "let test = ... in test"
18:56:53 <kpreid> I recommend having a file in which you define stuff and reload in ghci
18:56:59 <chowmeined> ok
18:57:48 <kpreid> (you can reload with just ":r")
18:58:02 <narain> sorear: have you send the mail to the buggy blog guy yet? can you @tell me when he responds?
18:58:11 * ddarius hacks PDF by hand.
18:58:21 <dfranke> what's new in HEAD?
19:03:04 <Cale> In fact, just : on its own is enough to reload the file in ghci
19:03:49 <dolio> Hmm... Wadler google talk.
19:04:44 <hpaste>  LoganCapaldo pasted "Generalizing ShowS, sort of, what's wrong with this picture?" at http://hpaste.org/1682
19:06:08 <fax> sno…Ø éuou‚àÄ
19:06:13 <fax> oops
19:07:10 <Cale> heh
19:07:33 <Cale> Too bad unicode characters aren't allowed in nicks.
19:08:14 <dolio> LoganCapaldo: I think, if anything, 'type M m a = forall a m. ...' would have a and m in '...' unrelated to the a and m in 'M m a'.
19:08:32 <fax> Cale: yeah!
19:08:35 <dolio> You'd be introducing new type variables that shadow the outer ones.
19:08:45 <fax> I think its really due time someone revise the IRC protocols
19:08:55 <Cale> That would be nice.
19:09:32 <dons> Pseudonym: thanks for raising that issue on the ml.
19:09:51 * narain wonders if every latin alphabet has an upside-down version in unicode
19:09:51 <LoganCapaldo> dolio: oh is that whats happening? that kind of makes sense
19:09:53 <dons> Pseudonym: I'd written something of a reply yesterday, then gave up in frustration
19:10:12 <dons> Pseudonym: the ml lists are fragmenting a bit
19:11:36 <dolio> LoganCapaldo: That'd be one problem. I'm not sure if you can have constrained type variables in a synonym.
19:12:29 <LoganCapaldo> dolio: well it only complains really when I give the functions explicit signatures
19:15:53 <dolio> LoganCapaldo: Note: 'type M = forall a m. (MonadPlus m) => m a -> m a' is also accepted.
19:16:10 <dolio> *Main> :t (undefined :: M)
19:16:10 <dolio> (undefined :: M) :: forall (m :: * -> *) a. (MonadPlus m) => m a -> m a
19:16:33 <LoganCapaldo> Hmm maybe that's what I want
19:17:58 <dolio> I suspect not...
19:19:16 <dolio> Because I think the type 'm a -> M' is essentially 'm a -> (forall b n. MonadPlus n => n b -> n b)'
19:19:53 <dolio> Where you might be able to lift out the 'forall...', but it still ammounts to 'm a -> n b -> n b' not 'm a -> m a -> m a'.
19:20:21 <hpaste>  LoganCapaldo annotated "Generalizing ShowS, sort of, what's wrong with this picture?" with "Progress, maybe?" at http://hpaste.org/1682#a1
19:20:49 <LoganCapaldo> unitMonadPlusS I still can't give the type I want...
19:20:58 <LoganCapaldo> Or I can, just not with the names I want to use
19:21:39 <LoganCapaldo> hpaste ate the b
19:21:47 <LoganCapaldo> or my clipboard ate the b rather
19:22:36 <liquidengineer> Is there a performance difference between List.union and Set.union?
19:22:49 <liquidengineer> I've been converting all my lists to sets and processing them, then converting them back
19:23:17 <dons> yes, as
19:23:18 <dons> data Set a    = Tip
19:23:18 <dons>               | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a)
19:23:38 <dons> though I note missing complexity annotations in the docs for Set.
19:23:43 <LoganCapaldo> dons: How the heck did you paste the defn. for Set so fast?
19:23:52 <dons> heh.
19:23:58 <kilimanjaro> LoganCapaldo, paste? He has it memorized...
19:24:07 <narain> ?quote magic
19:24:08 <dons> i have the src tree in ~/dons/libraries/ and vim is quick
19:24:08 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
19:24:34 <dons> LoganCapaldo: basically, I don't read the docs when looking up defns, i just read the src. then you get both the docs and the implementation
19:24:35 <fax> what is tying the knot
19:24:35 <fax> ?
19:24:39 <dons> i encourage everyon eto do this :-)
19:25:54 <ddarius> @hawiki TyingTheKnot
19:25:54 <lambdabot> Maybe you meant: gwiki wiki
19:26:03 <ddarius> @oldwiki TyingTheKnot
19:26:04 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
19:27:16 <liquidengineer> dons: I didn't quite understand that
19:27:40 <dons> liquidengineer:
19:27:40 <dons> $ ls ghc/libraries/base/Data/Set.hs
19:27:40 <dons> ghc/libraries/base/Data/Set.hs
19:27:40 <dons> $ pwd
19:27:40 <dons> /home/dons
19:27:53 <dons> $ grep 'data' ghc/libraries/base/Data/Set.hs
19:27:54 <dons> data Set a    = Tip
19:27:56 <dons> that's how.
19:30:44 <ddarius> PDF hacked.
19:32:25 <sorear> dolio: Not building, even!
19:32:25 <sorear> MyCatVerbs: yes.
19:32:25 <sorear> narain: Yes, and yes.
19:32:25 <sorear> dfranke: Too much to easily summarize.  ATs, data families, GADT/typeclasses work together, two debuggers, haddock-ghc, ...
19:32:42 <dolio> sorear: Huh. Weird.
19:32:50 <MyCatVerbs> sorear: spiffy.
19:33:25 <sorear> btw, it works.
19:33:55 <sorear> did I mess anyone :)
19:34:03 <dfranke> ATs?
19:34:15 <sorear> anyway, my fix made cvs-ghc@
19:34:24 <sorear> let's hope the Simons see it
19:40:01 <ddarius> This will be interesting.
19:40:31 <sorear> ddarius: what will?
19:40:52 <ddarius> "Objective C via Category Theory"
19:41:31 <fax> :L
19:41:43 <fax> ObjC the HARD WAY
19:42:01 <kc5tja> ROTFLMFAO!  8-D
19:42:03 <notsmack> is there a way to ask lambdabot for a datatype's class instance sources?
19:42:08 <sorear> yes
19:42:14 <sorear> well sorta
19:42:15 <kc5tja> WOW, that was excellent!
19:42:18 <sorear> @src Maybe >>=
19:42:19 <lambdabot> Source not found. Take a stress pill and think things over.
19:42:21 <sorear> @src Maybe (>>=)
19:42:22 <lambdabot> (Just x) >>= k      = k x
19:42:22 <lambdabot> Nothing  >>= _      = Nothing
19:42:31 <sorear> sjanssen++ Mod-n
19:47:50 <EvilTerran> is it possible to have a top-level expression that cannot be given a type, and yet somehow works?
19:48:16 <sorear> Yes.
19:48:30 <EvilTerran> this is odd.
19:48:51 <sorear> Dynamic languages like Python are popular precisely because not all ill-typed expressions fail.
19:49:34 <dfranke> sorear, eh, I'm not sure about that logic.  In that case Lisp should be just as popular as Python.
19:50:09 <sorear> dfranke: Obviously, JIT typing isn't python's only "benefit".
19:50:26 <sorear> dfranke: For instance, Lisp has that alien syntax.
19:50:27 <dfranke> or was Python just an example of the class and not intended to be unified on?
19:50:57 <sorear> yes.
19:51:05 <sorear> er, correct
19:51:42 <narain> isn't an ill-typed expression that doesn't fail a bug waiting to happen?
19:51:54 <narain> er, excuse the garden path sentence
19:52:01 <dfranke> well, in that case I'd state it as, "Haskell is the only strongly, staticly typed language that doesn't blow goats"
19:52:34 <narain> isn't (an ill-typed expression (that doesn't fail)) (a bug (waiting to happen))?
19:53:24 <dfranke> dynamic languages are a lot easier to design.
19:53:46 <kc5tja> narain: Only if a statements dependencies are altered after the statement is written.
19:53:54 <dons> the class of expressions that are safe, but won't type in ghc + extensions is not so big, I'd argue.
19:54:09 <sorear> narain: Spoken like a true haskell corrupt. ;)
19:54:18 <dons> i'm very interested, actually, in valid, say, python code, that's good style, but won't type
19:54:31 <dons> dfranke: design? :-)
19:54:59 <sorear> dons: not everyone is a quite as much of a TT guru as we are.
19:55:19 <dons> Type Tricks?
19:55:26 <kc5tja> dons: Lists can be vari-typed.  ['A', 123, {"Foo": lambda x, x*2}] is a valid construct.  :)
19:55:26 <ddarius> dons: countably infinite is not so big?
19:55:36 <sorear> Bitten by yet another apprevo.
19:55:40 <dfranke> dons, think of it this way.  We're dealing with Goedel incompleteness.  Haskell's type system is incomplete.  Dynamic type systems are inconsistent.  Any idiot can come up with a powerful inconsistent system.  Powerful consistent ones are hard.
19:55:41 <sorear> Type Thoery
19:55:45 <dons> Technical Turtles?
19:55:58 <dons> kc5tja: sure, but that's just using a runtime tag
19:56:18 <dons> so its, [C 'A', I 123, Pair "Foo" (\x -> x ^2)]
19:56:30 <dons> where the tags are explicit, rather than always inserted by the interpreter
19:56:41 <sorear> Pair of-what though.
19:56:43 <dons> so, no, hlists aren't an example. that's just syntax
19:56:56 <sorear> Implicit is always easier shortrun...
19:57:02 <sorear> hello
19:57:02 <kc5tja> then, all Python code types correctly then.  Even buggy code.
19:57:18 <sorear> Heck, even buggy C code types.
19:57:20 <kc5tja> (Remember that Python's method look ups are always done at run-time)
19:57:24 <dons> bug free, good style, but not typeable. that's the interesting stuff
19:57:30 <ddarius> Typechecking becomes very easy when you have only one type.
19:59:49 <kilimanjaro> I think the role of static typing is overemphasized (although I have not worked on any large projects so my views are narrow)
20:00:26 <dfranke> dons, no, it's not that simple.  A lisp list can hold *any* datatype.  You can add new objects to a list at runtime that weren't there at compile time.  You can't write a Haskell datatype for that because you'd need an infinite number of type constructors.
20:00:58 <kc5tja> kilimanjaro: I'm working on some large projects at Google, and static type checking is utterly invaluable at solving a large number of bugs.  And this is with Java, let alone Haskell.
20:01:03 <zeeeeee> when building hs-plugins-1.0-rc0 with ghc-6.6, i get 'src/AltData/Typeable.hs: parse error (possibly incorrect indentation)'. any help?
20:01:17 <dons> dfranke: so, [Dynamic] no?
20:01:27 <dons> (modulo runtime eval)
20:01:31 <QtPlatypus> kc5tja: I've found java's type system created more bugs then it found.
20:01:35 <dons> zeeeeee: you need the darcs version
20:01:39 <zeeeeee> dons: ok
20:01:52 <kc5tja> In fact, there are places in the code where a 32-bit integer is used to express an ID value, instead of Id<something>.  This results in some prett frilly code.
20:01:56 <dfranke> dons, well, ok, but that kinda defeats the purpose of static typing.
20:01:57 <dons> dfranke: where Dynamic is the universal data type
20:02:02 <dons> dfranke: indeed it does.
20:02:04 <kc5tja> QtPlatypus: err...then you're not using it right, me thinks.
20:02:05 <kilimanjaro> kc5tja, there are alternatives, such as unit testing or using a proof tool for stronger invariants than could be conveniently encoded in the type system
20:02:30 <dons> but it shows how dynamic languages are just the degenerate case of static typing , where you have 1 static type
20:02:42 <dons> you can always add dynamics to a static system, you can't go the other way though
20:02:44 <kc5tja> kilimanjaro: I'm an extreme programmer.  You don't need to preach the rhetoric of TDD to me.  And as a TDD developer, I can safely say, strong typing is god-sent.
20:02:45 <QtPlatypus> dons: I wouldn't argue that.
20:02:56 <dons> s/degneerate/limit case/
20:03:07 <dons> QtPlatypus: well, its not my words, it Robert Harper's :-)
20:03:15 <kilimanjaro> kc5tja, well I am just saying that there has been a significant amount of large system work done with Erlang using those two things (unit testing and proof tools)
20:03:17 <kc5tja> kilimanjaro: Unit testing _cannot_ detect incorrect uses of types.  It can only detect incorrect results.
20:03:19 <dons> but its a technical statement, not an opinion, anyway
20:03:44 <kc5tja> kilimanjaro: You said the magic words: proof tools.  That's all a type system is.
20:04:07 <kilimanjaro> kc5tja, it pervades the entire system. That's the difference
20:04:18 <kilimanjaro> err, type systems do
20:04:20 <kc5tja> kilimanjaro: Strong typing is a means of allowing the compiler proper to statically determine the correctness of a piece of code (within its expressive capabilities of course).
20:04:47 <kc5tja> And as well it should.
20:04:58 <dons> QtPlatypus: its a statement relating static and dynamic typing. dynamically typed systems are static type systems with a single universal type, and where checks are shifted to tag inspection at runtime. so in that sense, its a degenerate static type system: you have the minimal static semantics possible
20:05:12 <kc5tja> Again, you can use an integer to represent a customer number.  But what is 3 + a customer number?  Another customer number?  It's non-sensical.
20:05:16 <dons> it happens that dynamic checks are dead simple to implement in an interpreter
20:05:16 <kilimanjaro> I'm not sure what strong typing means, I always thought it meant that type safety was enforced at some time (not necessarily "compile time")
20:05:22 <dons> and interpreters are easy to write
20:05:32 <kc5tja> The ability to say: newtype CustomerID = Customer Int is invaluable.
20:05:33 <dons> so we have a lot of dynamically typed interpreted languages
20:06:05 <kc5tja> So that now, even though the representation of a customer ID is a 32-bit integer, it still is treated as a distinct type by the compiler; hence 3+aCustomerID is no longer valid.
20:06:12 <sorear> kilimanjaro: Strong typing means that you can't write unsafeCoerce#.
20:06:22 <kilimanjaro> dons, and binding time analysis can be used to detect some type errors as well, even in a "dynamic" language (although not nearly as effectively as a syntactic system)
20:06:24 <sorear> kilimanjaro: Python has strong typing, as does Java.
20:06:36 <dfranke> incidentally, some Common Lisp compilers have anti-typesystems.  They don't try to prove that your code is safe, but they're good at proving that it'll break.
20:06:43 <kc5tja> sorear: He's arguing about static typing, not strong typing.
20:06:47 <narain> kilimanjaro: i certainly agree that static typing doesn't solve everything. but it helps catch a lot of bugs at compile time. what is the disadvantage of having a type system pervade the entire system?
20:06:49 <sorear> <kilimanjaro> I'm not sure what strong typing means, I always thought it meant
20:06:49 <sorear>  
20:07:26 <kilimanjaro> I made that remark in regard to kc5tja's statement that strong typing is a means of allowing the compiler proper to statically determine correctness
20:07:37 <kc5tja> I meant, obviously, static typing.
20:07:37 <narain> let's not mix strong and static typing please
20:07:59 <QtPlatypus> sorear: Java doesn't have strong typing, it has casts.
20:08:18 <kc5tja> QtPlatypus: Casts only within a specific chain of inheritance.
20:08:28 <sorear> QtPlatypus: Last I checked you couldn't cause a crash with Java casts.
20:08:30 <narain> QtPlatypus: casting an object to a type it doesn't have is an error
20:08:43 <Pseudonym> @remember SimonCozens "Any sufficiently advanced technology is indistinguishable from magic."  In this case, "any sufficiently WHACKED OUT CRACK ADDLED FREAK TRAIN OF DESPAIR AND WEIRD SHIT ..."
20:08:43 <lambdabot> Done.
20:08:51 <zeeeeee> dons: if i'd like to build lambdabot, do you also advise i build from darcs
20:08:59 <dons> zeeeeee: yeah
20:10:54 <kc5tja> dfranke: anti-typesystems.  Interesting -- how does that technique compare against type-constraint systems?
20:10:57 <kilimanjaro> Surely the effectiveness of static typing depends on developers proficiency within the system. I have studied just enough Haskell to read papers well, so it shouldn't be surprising if I feel more comfortable in a language like Scheme than Haskell.
20:12:02 <QtPlatypus> sorear: (Its been a while since I've done Java) Cast from a superclass into a subclass, its permitted at compile time but may not work at runtime.
20:12:11 <chessguy> hi haskellers
20:12:22 <kc5tja> kilimanjaro: I can code much faster in Python than I can in Haskell.  (Currently, at least.)  I've been using Python since 1.3.  But that doesn't make my code "more correct."  I of course rely on unit tests and so forth to ensure my classes behave properly.  But that doesn't prevent someone from finding down the road some combination of inputs that causes it to go haywire.
20:13:14 <kc5tja> With a static type system, the odds of someone finding bogus input is significantly reduced (I won't say zero), because the majority of such programs simply won't even _compile_, much less run.
20:13:15 <QtPlatypus> kc5tja: Nothing will prevent that other then a turing orical.
20:13:21 <dons> kc5tja: so if you combine coding + testing, do you still spend more time coding in haskell?
20:13:32 <dino-> Christ, I remember working with a Borland compiler in the mid 90s and they had a macro in there, TYPESAFE_DOWNCAST. I kid you not, that bastard would cast from base to derived through void.
20:13:36 <narain> QtPlatypus: yes, if you cast an object to a subclass that it isn't an instance of, that's a run-time error. it's still an error, unlike c which will let you do the cast anyway.
20:13:47 <kc5tja> dons: At this point, yes.  Most of my time in Haskell is spent resolving type mismatches.
20:13:53 <dons> the idea is that, once proficient in haskell, you spend dramatically less time testing, since half the bugs are gone due to the type system, and QC catches the rest.
20:14:11 <kc5tja> dons: Umm..you still have to write the QC tests.  There is no time gain.
20:14:28 <dons> you do, but one QC property subsumes 10-100 unit tests :-)
20:14:38 <dons> so you should be able to get away with less
20:14:58 <dons> that followed on from the fact that a lot of unit tests don't make sense given purity and strong typing
20:15:17 <dons> you don't need to write tests to check f x == f x , or what happens if some value is called with some random type T
20:15:17 <kc5tja> dons: I'm not so sure about that last statement.
20:15:33 <kc5tja> You don't do that anyway.
20:15:41 <kc5tja> TDD is just that -- test driven _design_.
20:15:50 <dons> ok. so then there's bugs you'll have to check later, or ignore.. no?
20:15:54 <kc5tja> The only primary concern is that the application is correct within the context of some specification.
20:15:56 <hpaste>  zeeeeee pasted "help - build error from arrows (from darcs)" at http://hpaste.org/1683
20:16:08 <dons> kc5tja: right. 95% is enough.
20:16:17 <kc5tja> I'm sorry -- 95% of what?
20:16:27 <dons> coverage, testing, and so on.
20:16:29 <kc5tja> no
20:16:34 <kc5tja> TDD mandates 100% coverage.
20:16:39 <kc5tja> (when done properly)
20:16:43 <dons> the kind of hard correctness we might consider trying for in haskell, you don't look at in python
20:17:04 <kilimanjaro> Well, that 100% coverage isn't verified either... it's just going by the programmer's intuition
20:17:04 <dons> since to do so would mean modellling a type system , which people don't do
20:17:06 <kc5tja> Haskell relies on a formal proof system to ensure correctness.
20:17:15 <kc5tja> TDD relies on pragmatics and testing edge-cases.
20:17:21 <kc5tja> The two work together, I find.
20:17:30 <dons> right, which by definition doesn't cover 100% on its own.
20:17:44 <dons> so that's what I mean by 95%, you have a pretty good idea you're bug free, you hope.
20:17:44 <kc5tja> OK, stop.
20:17:48 <kc5tja> You're confusing something.
20:17:55 <zeeeeee> btw what's that font used in the hpaste.org title logo?
20:17:56 <kc5tja> TDD is 100% _test coverage_.
20:17:58 <zeeeeee> it's nice
20:18:01 <zeeeeee> :)
20:18:03 <kc5tja> That's what we've been talking about.
20:18:08 <kc5tja> 100% _provably correct_ is not.
20:18:15 <kc5tja> They are orthogonal attributes.
20:18:23 <dons> kc5tja: what does test coverage mean though? testing code paths with some values?
20:18:26 <kilimanjaro> kc5tja, what does "100% test coverage" mean?
20:18:30 <dfranke> there is no pointfree way to unwrap a type constructor, correct?
20:18:31 <narain> zeeeee: looks like century gothic to me
20:18:33 <kc5tja> dons: Yes.
20:18:39 <dons> how is that not just a rough approximation of testing code paths with all values?
20:18:52 <cdsmith> dons: test coverage is typically defined in terms of the actual text of the source code.
20:18:53 <kc5tja> A specification might be, "Given these inputs, I want a report containing X, Y, and Z."
20:18:55 <dons> i.e. a <100% coverage of code paths + possible values.
20:18:57 <dino-> zeeeeee: Could you put the code up there too?
20:19:05 <sorear> dfranke: type constructors can't be unwrapped, period
20:19:11 <kc5tja> So you write a test that passes a proposed set of inputs, and tests for X, Y, and Z.  Exactly as the specification stated.
20:19:20 <kc5tja> That has _nothing_ to do with formally proving the system correct.
20:19:21 <dfranke> sorear, you can pattern-match them.
20:19:22 <sorear> dfranke: you need associated types or classes even to pattern match them
20:19:32 <sorear> dfranke: not in standard haskell
20:19:38 <zeeeeee> dino-: you mean just the Setup.lhs from the 'arrows' darcs repository?
20:19:50 <zeeeeee> narain: very good!
20:19:51 <thoughtpolice> me and haskell are having our 2 month anniversary soon. what should I get her? :>
20:20:08 <dfranke> so for example,
20:20:11 <dfranke> guardIO = (>>= guardIO') . lift . try
20:20:11 <dfranke>     where guardIO' (Left e) = (throwError . show) e
20:20:11 <dfranke>           guardIO' (Right a) = return a
20:20:14 <dons> kc5tja: sure. i agree. what's the issue?
20:20:23 <dfranke> there's no way to remove the e and the a?
20:20:24 <sorear> dfranke: where is the type constructor in that?
20:20:32 <sorear> dfranke: that's not a type constructor
20:20:35 <dfranke> sorear, Left and Right
20:20:40 <sorear> dfranke: that's a *data* constructor
20:20:46 <dfranke> oh, ok.  my bad.
20:20:46 <kc5tja> Everyone seems to think that UTs can be the cure-all, or that formal proofs eliminate the need for UTs.  Nothing is further from the truth.  You need both to ensure a truely reliable system.
20:20:47 <dino-> zeeeeee: The portion of the code that error is coming from.
20:20:49 <sorear> dfranke: you want 'Data.Either.either'
20:20:51 <dons> kc5tja: also, see how QuickCheck generalises from "a proposed set of inputs" to "arbitrary inputs for a type"
20:20:55 <sorear> @type either
20:20:58 <kc5tja> The tests help to ensure your spec was understood, while the proof ensures safety.
20:21:05 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
20:21:10 <kc5tja> dons: I don't want that.
20:21:21 <kc5tja> I want to ensure my specification, as it's given to me, is verified to be working.
20:21:34 <dons> kc5tja: i'm arguing for a scale of a posteriori testing: unit tests < quick check < QC + type checks
20:21:43 <kc5tja> That way, if the customer comes back on us and says, "You didn't do this right," and can point at the code and say, "The hell I didn't."
20:21:45 <dfranke> sorear, ah, cool.  But I'm correct that there's no general way?
20:21:56 <sorear> dfranke: sadly, yes.
20:22:12 <hpaste>  zeeeeee annotated "help - build error from arrows (from darcs)" with "now with setup.hs" at http://hpaste.org/1683#a1
20:22:14 * narain thought specifications in general were more of the form "given a certain kind of input, i want a certain kind of output" which defines a class of inputs rather than one specific input/output pair you could directly test for, kc5tja
20:22:49 <kilimanjaro> narain, those are both specifications
20:22:49 <kc5tja> narain: That's partially true.  You can, for example, test edge-cases.
20:23:06 <kc5tja> For example, every bug that is submitted against software becomes one (or more) unit tests to ensure cde never regresses.
20:23:09 <kc5tja> code even
20:23:46 <kc5tja> While I was working for Hifn, I had to test 2048-bit and 3072-bit integer math coprocessors.
20:23:53 <kc5tja> Yes, you read that right -- KILOBITS per integer.
20:24:09 <dons> kc5tja: recall that unit tests are just quickcheck properties with no universal quantification. so as soon as you add one universally-quanitified unit tests (which holds for all values of some type), you're already testing the code to a greater degree than a simple "input -> output" unit test.. And that seems like a reasonable thing to do, doesn't it?
20:24:10 <kc5tja> You honestly expect us to exhaustively test the full range of modulo math on these units?
20:24:13 <kc5tja> No way.
20:24:15 <sorear> dons: AIUI, TDD means that code is written lazily in responce to failing tests.  Like lazy evaluation, this means no more code is written than tested, and 100% coverage is guaranteed trivially
20:24:21 <kc5tja> You have to test for edge cases, and rely on induction for everything else.
20:24:30 <sorear> dons: since you seem
20:24:39 <sorear> C-k -> C-j
20:24:41 <dons> sorear: 100% coverage isn't coverage when it doesn't test against all possible values.
20:25:09 <dons> kc5tja: have you used QuickCheck?
20:25:10 <sorear> dons: all possible values of IP should be good enough for anybody ;)
20:25:15 <kc5tja> Instead of taking centuries to run the tests, it took only days.  And the proof is in the pudding -- every Cisco 6500 or 12000 router, on which the Internet backbones rely daily, are proof that it works.  :)
20:25:33 <kc5tja> dons: No, but I perused the website when linked to it.  I didn't find anything of value for my needs.
20:25:35 <sorear> kc5tja: these things are for ipsec?
20:25:42 <kc5tja> sorear: Among other things.
20:25:59 <dons> kc5tja: i guess you've got to use it before you can argue against it :-) Ericsson seems to like it for testing network protocols.
20:26:22 <kc5tja> dons: I also think that there is widespread misunderstanding over my position on this too.
20:26:26 <dons> kc5tja: posisbly you could read my blog post earlier this week on using QuickCheck to verify properties of a window manager. its a useful, obvious generalisatoin of unit testing
20:26:30 <dfranke> yay, I've now made this totally uncomprehensible.
20:26:33 <sorear> Ericsson uses haskell? :)
20:26:41 <dfranke> guardIO = (>>= either (throwError . show) return) . lift . try
20:26:42 <kc5tja> dons: URL?
20:26:48 <sorear> planet.haskell.org
20:27:01 <sorear> 2nd or 3rd from top
20:27:13 <dons> kc5tja: http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01#xmonad_part1_model
20:27:15 <lambdabot> Title: Haskell hacking, http://tinyurl.com/232r46
20:27:30 <sorear> hello
20:27:36 <dons> kc5tja: QC is just a more generic approach to unit testing. it's available for python too, btw.
20:27:39 <narain> dfranke: not incomprehensible enough
20:28:06 <dons> so instead of writing single Input->Output test cases, you abstract over some of the inputs, yielding stronger properties, ones that hold for all possible values.
20:28:09 <narain> :t either
20:28:15 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
20:28:20 <dons> then QC generates test cases to exercise a particular code path with a wide range of values
20:28:26 <dons> so you hammer the particular code much harder
20:28:36 <sorear> is 500 a wide range?
20:28:41 <falconair> i'm at hackage.haskell.org's Data.Binary page ... there is a gzip file there ... how do i make it available to my ghc compiler?
20:28:44 <dons> given a sufficiently constrained type, QC actually produces a proof of correctness
20:29:00 <sorear> nah, that's what smallcheck does :)
20:29:07 <sorear> falconair: unpack it first
20:29:18 <kilimanjaro> dons, I may have asked you this before, but are you aware of any distributed systems work using Haskell?
20:29:23 <dons> anyone using unit testing as their core testing and correctness mechanism should understand QC , I think.
20:29:50 <sorear> falconair: ok OSX - you want to unpack it into any directory, then in Terminal run
20:29:52 <dino-> zeeeeee: I'm confused that buildHook is getting called with a UserHooks instead of PackageDescription -> LocalBuildInfo -> Maybe UserHooks ..
20:29:55 <dons> kilimanjaro: there's beeen a bit in the 90s. these days people tend to write a single Haskell node code, distribute that over multiple nodes, and communicate over mpi -- that kind of thing
20:30:15 <sorear> runhaskell Setup.hs configure --user --prefix=$HOME
20:30:16 <sorear> runhaskell Setup.hs build
20:30:16 <sorear> runhaskell Setup.hs install
20:30:29 <sorear> falconair: do you know how to unpack tar.gz files?
20:30:34 <kilimanjaro> I'd be interested to see a typed Mozart/Oz
20:30:42 <kilimanjaro> err, statically typed
20:30:56 <sorear> what does MPI offer over plain old sockets?
20:30:58 <kc5tja> dons: How does QC know what to hammer in the code I'm producing?
20:31:00 <falconair> sorear: yeah, i'm doing that now ... is there an auto installer in the works, list darwinports, yum, etc.?
20:31:28 <kc5tja> I've read the website, briefly I admit, but not skimming either.  And I really was not at all comfortable with it.
20:31:29 <dons> kc5tja: you write a generator for each type you need random values of.
20:31:30 <sorear> falconair: yeah, cabal-install
20:31:47 <falconair> sorear: is it something i can use now?
20:31:51 <sorear> (will lose network connection RSN, father is upgrading it)
20:31:57 <sorear> i don't know.
20:32:05 <dons> then a unit test becomes a test generator, that produces many many (1000s) of inputs to a particular function you want to test
20:32:16 <kc5tja> Errr...but again, on known edge cases, there is no randomness.
20:32:32 <kc5tja> And, also, unit tests simply MUST run fast (they get run as part of a continuous build system).
20:32:39 <dons> kc5tja: sure. you write the generator to produce test cases, based on t the knowledge you have of the type
20:32:45 <dons> kc5tja: they do run fast :-)
20:32:58 <kc5tja> 1000s of test cases in Python can result in minutes, not seconds, of runtime.
20:33:02 <dons> kc5tja: the issues you are complaining about aren't issues in quickCheck :-)
20:33:07 <dons> ok. so there are slow languages.
20:33:11 <falconair> sorear: thanks, that worked
20:33:15 <kc5tja> No, in theory, it's not.
20:33:19 <dons> (btw, I wrote a multicore, parallel driver for QuickChec, which is nice)
20:33:26 <kc5tja> But it does show one reason why QC is not appropriate for my commercial work.
20:33:30 <shapr> End-to-end tests run quickly and test everything.
20:33:46 <dino-> dons: I recently did my first testing with QC as well. I was wondering something that you guys just brought up..
20:33:47 <dons> kc5tja: you could have small test runs for rapid turn around, and exhaustinve runs over night, no?
20:33:47 <kc5tja> shapr: Not on the application we're coding, they don't.
20:33:58 <kc5tja> dons: No.
20:34:07 <kc5tja> The continuous build system rebuilds the system continuously.
20:34:19 <kc5tja> As soon as it's done downloading the latest head branch, it builds it.
20:34:24 <kc5tja> Then it runs the unit tests.
20:34:27 <dino-> Suppose I'd like my function tested with a random block of values and also always with some edge cases. Can I express that in defining arbitrary?
20:34:28 <kc5tja> Then it downloads head again.
20:34:29 <shapr> Couldn't you start running tests at 5pm and run them till 8am?
20:34:39 <dons> kc5tja: i still don't see why this approach, which obviously tests code harder than simple unit tests alone, and which works for the big commerical erlang companies, wouldn't be appropriate for you. don't you rely on having good testing? why wouldn't you *demand* QuickCheck?
20:34:43 <kc5tja> shapr: No.
20:35:14 <shapr> Why not?
20:35:41 <dons> so you've raised 'speed' ,well, that all depends on how deep you want to search the value space. hat else, corern cases: that's handled by the generators you write. any other reasons not to use test generators, rather than hand written input cases?
20:35:44 <kc5tja> shapr: Because I'm not the TM or PM of the project.
20:36:17 <kc5tja> dons: There's no one-to-one mapping of test cases to customer or managerial requirements.
20:36:25 <shapr> For QC there is...
20:36:43 <dons> kc5tja: its a simple generalisation of the zero-arity tests you're currently writing.
20:36:44 <shapr> The best way to write QC properties is directly express something that you get out of an RFC
20:36:53 <dons> its an *obvious* generalisation.
20:37:06 <Korollary> Talk by Wadler: http://video.google.com/videoplay?docid=-4167170843018186532
20:37:08 <lambdabot> Title: Faith, Evolution, and Programming Languages - Google Video
20:37:33 <dons> you write: prop_foo = f [1,2,3] == [3,2,1], QC lets you write: prop_foo forall x . f x == reverse x
20:37:35 <shapr> For example, I'm writing a unit test for a TCP/IP stack. I express that fragmenter packet == packet for any packet.
20:38:25 <kc5tja> Look, I'm not saying that QC is bad.
20:38:31 <falconair> Korollary: i saw most of the talk earlier today, i was very excited about it ... i think it may not be appreciated by run-of-the-mill imperative programmers...a bit boring
20:38:33 <kc5tja> I'm saying, QC does not apply to the work that I do.
20:38:50 <shapr> Well, without more information about your work, I won't believe it.
20:38:52 <Korollary> falconair: Oh? I haven't watched it yet.
20:39:14 <dolio> Korollary: It's pretty good.
20:39:16 <shapr> kc5tja: Could you suggest any types of applications that couldn't be QC'd but could be unit tested?
20:39:36 <kc5tja> At Google, we use unit testing and TDD.  It's worked exceptionally well for us, and continues to work well.  There is no way in hell that management will want to change _everything_ over to use QC just because, "it's a generalization."  There has to be _solid_ business cases to justify it (note the plurality)
20:39:47 <shapr> You can do TDD with QC.
20:39:58 <Korollary> QC doesn't replace TDD. It complementes standard unit tests.
20:40:00 <kc5tja> OK, you're not reading what I'm writing, so I'm done with this conversation.
20:40:08 <sjanssen> kc5tja: your argument against QC is speed?
20:40:09 <shapr> kc5tja: I really am trying to listen.
20:40:12 <falconair> Korollary: his goal was to communicate to the wider developer community ... i don't think they will appreciate several slides full of Gentzen's logical formulas ... i would have ignored them myself if i hadn't read Pierce's TAPL first
20:40:44 <Korollary> In fact QC "can't" replace unit tests because existing unit tests are precious.
20:41:00 <falconair> he also uses terms like free variables, binding this or that, head/tail (of lists) ... most programmers won't know what they are, but he uses them as if they are common knowledge (among devs)
20:41:07 <shapr> kc5tja: What if QC saved all failing test cases for future runs, and allowed you to specify values to input as well?
20:41:23 <dons> kc5tja: you freely intermix QC tests and normal unit tests. the QC tests just test more things.
20:41:28 <falconair> ...in fairness the attending crowd (google devs) knew lambda calculus
20:41:37 <sjanssen> shapr: that would be great!  Write the code please :)
20:41:57 <shapr> I wrote the first part already, but I don't think it's in QC2 these days.
20:42:01 <kc5tja> 20:34 < kc5tja> Look, I'm not saying that QC is bad.
20:42:02 <kc5tja> 20:34 < kc5tja> I'm saying, QC does not apply to the work that I do.
20:42:24 <dons> right. that's the bit we don't understand. since you already use unit test everywhere.
20:42:32 <kc5tja> 20:32 < kc5tja> shapr: Because I'm not the TM or PM of the project.
20:42:45 <Korollary> kc5tja: Is your project in haskell anyways?
20:42:49 <kc5tja> NO!
20:42:52 <shapr> Python
20:42:55 <Korollary> That's a good reason.
20:42:59 <dons> python, but that has a QC impl as well.
20:43:19 <shapr> And PeckCheck may get shrink soon...
20:43:34 <kc5tja> I work for Google, coding in Python.  I am a grunt coder, with no say in the process.  The most I can do is "offer suggestions," but I have 4 layers of management buy-in to go through before I can even impact something like adopting QC.
20:43:38 <shapr> Darius was asking me about shrink for the jungerl quickcheck yesterday.
20:43:44 <dons> though I think the Haskell and Erlang ones are the only ones where the testing culture is based on QuickCheck, rather than zero-aritunit tests
20:44:13 <Korollary> kc5tja: Yes, there are always non-technical things to deal with in the real world.
20:44:20 <sjanssen> kc5tja: another nice take on the QuickCheck concept is SmallCheck: it can exhaustively prove that your property holds for a subset of inputs
20:44:25 <dons> kc5tja: ah well, check it out in your side projects one day. it'll change your whole understanding of the testing process :)
20:44:42 <shapr> kc5tja: Yeah, I can see how that would be a problem.
20:44:48 <kc5tja> Also, the fact that QuickCheck runs thousands of tests based on each predicate you give it means that it will severely impact the continuous build cycle, and that will almost certainly cause problems for other developers.
20:44:49 <shapr> Reminds me of a Python job I recently dumped...
20:44:58 <shapr> kc5tja: You can choose how many tests to run.
20:45:25 <thetallguy> Hmmm....   Yahoo uses it.  QC that is.
20:45:34 <thetallguy> Does that help? ;-)
20:45:34 * sm fears QC more by the minute
20:45:38 * kc5tja didn't mean to make it sound like I hate life at Google -- but it apparently was the only way to get people to see the predicament.  :)
20:45:53 <kc5tja> Google is actually the best place I've ever worked.
20:46:08 <kc5tja> I actually look forward to going to work.
20:46:14 <kc5tja> I've never had that happen to me before.
20:46:25 <shapr> kc5tja: Maybe if you wrote some PeckCheck tests and ran them overnight on your workstation on a checked out copy?
20:46:30 <shapr> If you found some bugs that hadn't been found before, would that influence your management?
20:46:33 <kc5tja> But, still, I'm the low-man on the totem pole.  I can't just say, "hey!!  Let's all switch to this!"  Yeah, that'll go over like a lead zep.
20:46:56 <kc5tja> shapr: I think the furthest I'd get on that is giving a tech-talk.
20:47:00 <thetallguy> I understand.  Actually, it was one programmer at Yahoo who believes in FP who developed a QC like application to test their C libraries.
20:47:04 <shapr> kc5tja: Hm, good idea
20:47:15 <shapr> thetallguy: Darius? Brandon?
20:47:16 <kc5tja> Once I gave the tech talk, then it's up to other people to spread the meme.
20:47:21 <Korollary> Physically beating coworkers works best.
20:47:22 <thetallguy> Brandon
20:47:27 <shapr> thetallguy: He's a cool guy.
20:47:27 <kc5tja> But, I have to have a major project for it to have any kind of impact.
20:47:31 <kc5tja> Well, semi-major.
20:47:37 <shapr> thetallguy: Do you know both Brandon and Darius?
20:47:41 <kc5tja> And my code is less than 500 lines all total.  Hardly worthy of the investment.
20:47:44 <thetallguy> Indeed.  Only Brandon.
20:48:02 <thetallguy> He's been quiet for a while, too.
20:48:04 <shapr> Well, if you get a chance to chat with Darius Bacon, he's a very smart guy.
20:48:09 <SamB_XP_> how big is xmonad?
20:48:28 <kc5tja> 490 lines according to the website.
20:48:34 <dons> thetallguy: cool.
20:48:35 <thetallguy> I wonder if he's any relation to David Bacon of IBM?
20:48:44 <shapr> I don't know.
20:48:46 <dons> kc5tja: yeah, it varies between 450-490 loc daily
20:49:01 <SamB_XP_> so, your code is comparable to a reasonable window manager.
20:49:04 <SamB_XP_> is that really so bad?
20:49:17 <kc5tja> SamB_XP_: xmonad is vastly more sophisticated than my code.
20:49:35 <kc5tja> My code slurps data from a website, massages it into a format suitable for gdchart2, and spits out graphs.
20:49:40 <dons> hehe. we have 426 lines of QC properties
20:49:42 <kc5tja> It's virtually a pipeline application.
20:49:45 <dons> to test 490 lines of code:-)
20:49:50 * allbery_b looks confused for a moment and then realizes he's been trapped by 90210 yet again :/
20:49:50 <kc5tja> dons: That's good.
20:49:54 <dons> that's why xmonda works :)
20:50:09 <shapr> xmondo is the fork that's being secretly written by cyberpunks
20:50:16 <narain> a wm called xmonda
20:50:25 <dons> i note that if we'd tried to prove it correct in Isabelle, it'd be more like 3k lines of proof for 400 lines of code
20:50:35 <dons> so QC gives us a big bang for our testing buck.
20:50:46 <shapr> dons: I really enjoyed your blog post on this subject.
20:50:52 <kc5tja> If Haskell had proper range-checking as part of its type checking system, you probably wouldn't even have needed QC.
20:50:55 <SamB_XP_> dons: where did the other 90 go?
20:50:58 <dons> you get 1:1 code/semi-formal method, rather than the usual 1:8 code/proof ratio
20:51:09 <SamB_XP_> also, does Isabelle have FFI support?
20:51:12 <shapr> kc5tja: I disagree. That still won't give you associativity checking.
20:51:18 <dons> kc5tja: hmm, not really. there's the abstract properties of the wm api we need to prove
20:51:39 <dons> that say, moving a window across workspaces and back, or cycling focus, leaves the wm in a predictable state
20:51:44 <dons> that's the kind of thing we test with QC
20:51:49 <dons> very high level functionality
20:51:55 <dons> basically, a spec for the wm
20:52:12 <shapr> kc5tja: How would you write this for unit test? http://hpaste.org/1642
20:52:19 <shapr> Or how would range checking help?
20:52:26 <SamB_XP_> can't do that in C ;-P
20:52:41 <dons> QC really is a semi-formal method, bridging the gap between unit test and proof, it sits in between
20:53:00 <kc5tja> Errr ... I  can't even really read that.  :(
20:53:00 <shapr> What's it called, proof by contrariness?
20:53:14 * shapr grins
20:53:30 <narain> kc5tja: looks like the last line's the relevant bit
20:53:51 <shapr> kc5tja: It checks that x + y == y + x for various types in Num
20:54:19 <kc5tja> I'd generate a static list of test inputs, then iterate over that list in the unit test.
20:54:39 <kc5tja> But that is too trivial -- of course the result is going to be the same between QC and the unit test.
20:54:48 <kc5tja> (although the UT is static, while QC picks dynamically at runtime)
20:55:04 <kc5tja> As far as the rest of the LOC, err, HUH?!
20:55:18 <shapr> It's just a trick to do the same test with different types.
20:55:47 <kc5tja> Well, I don't know.
20:55:51 <sjanssen> kc5tja: a more reasonable property looks like:
20:55:52 <kc5tja> And that is a problem.
20:56:12 <sjanssen> @check \x y -> x + y == y + (x :: Double)
20:56:12 <kc5tja> Unit tests need to be readable -- more readable than the code their testing at the minimum.
20:56:13 <lambdabot>  OK, passed 500 tests.
20:56:33 <kc5tja> s/their/they're/
20:56:49 <sjanssen> kc5tja: that code is a giant hack -- don't consider it to be typical of quickcheck
20:56:58 <shapr> Still a cool hack though..
20:57:08 <shapr> I'll likely end up using it.
20:57:38 <dons> yeah, that's the other idea. use QC as your secret weapon to generate test cases...
20:57:49 <dons> and then just test them using normal unit testing.
20:58:00 <shapr> Doesn't ADEpt do that?
20:58:04 <dons> so you suddenly seem massively more productive at writing test cases.
20:58:12 <dons> since you're writing test case generators instead
20:58:29 <sjanssen> or write "unitTest = quickCheck $ \x -> ..." :P
20:58:40 <dons> then you could really use QC + Haskell to generate random/structure test cases for your python data
20:58:52 <dons> it would be an easy secret niche :)
20:59:12 <kc5tja> It would also get me extra word to transcode it back into Python.  No thanks.
20:59:36 <dons> transcode? just have haskell spit out python test cases
20:59:47 <dons> data is data, after all.
20:59:51 <kc5tja> "just have haskell" <-- problem.
21:00:11 <dons> ok. its all problems. i encourage you to continue manually writing test cases. :}
21:00:34 <kc5tja> dons: I do, I've done it for years, and the result is workable and reliable.
21:00:53 <encryptio> major darcs ssh problems. it never works: darcs failed:  (scp) failed to fetch: ckastorff@192.168.1.26:/Users/ckastorff/code/perl/mods/_darcs/inventory -- ~/code/perl/mods is a vaild repo, and the file exists, and ssh works between the machines.
21:01:20 <dons> i'd just grab any chance to automate manual labour. that's sort of what computers are for right? why do you think we rave about QC? it saves us manual labour :)
21:01:22 <kc5tja> encryptio: File _permissions_?
21:01:30 <encryptio> kc5tja: they're fine
21:01:59 <dino-> log close 1
21:02:10 <kc5tja> dons: Looking at the hpaste code, that's pretty doggone manual.  Remember, test-driven _design_.  We write tests as a design tool, not just as a verification tool.  The tests are evolving right along with the application.
21:02:10 <dino-> heh
21:02:23 <kc5tja> I'm not designing pacemakers here.  :)
21:02:29 <kc5tja> or F-22s.  :)
21:02:43 <sjanssen> kc5tja: do I need to tell you "that code is a giant hack -- don't consider it to be typical of quickcheck" again?
21:03:13 <kc5tja> sjanssen: No, but someone had to write it for a reason, and I just used that as a good example of what inevitably _would_ appear in a QC test.
21:03:18 <sjanssen> that is probably something you could never do in Python, anyway
21:03:49 <kc5tja> sjanssen: Sure it is.  Python is dynamically typed -- you can easily randomly generate pairs for addition and invoke __operator_add__.
21:04:02 <kc5tja> You could even do it for strings.
21:05:41 <sjanssen> kc5tja: I don't think Python has the concept of "forall a. (Num a) => a" -- ie. a value that can take *any* numeric type
21:06:19 <narain> :t 42
21:06:25 <lambdabot> forall t. (Num t) => t
21:06:28 <narain> :t 42.0
21:06:30 <lambdabot> forall t. (Fractional t) => t
21:06:37 <Sgeo> I defined fac in the usual way
21:06:42 <Sgeo> then tried fac $ fac 18
21:06:44 <Sgeo> in hugs
21:06:48 <Sgeo> Segfault
21:07:12 <ddarius> Sgeo: Don't use Hugs.
21:07:24 <LoganCapaldo> > let fac n = product [1..n] in fac $ fac 18 :: Integer
21:07:25 <jcreigh> IIRC, some versions of hugs segfault of they run out of heap.
21:07:28 <Sgeo> GHCi gave me a stack overflow
21:07:28 <lambdabot> Terminated
21:07:34 <jcreigh> and (18!)! is a large number.
21:07:52 <Sgeo> erm
21:08:05 <Sgeo> By "usual" I meant recursive :/
21:08:21 <LoganCapaldo> Sgeo: I was just being lazy / curious
21:09:17 <LoganCapaldo> @src product
21:09:18 <lambdabot> product = foldl (*) 1
21:09:28 <LoganCapaldo> @src fold
21:09:29 <lambdabot> Source not found. That's something I cannot allow to happen.
21:09:33 <LoganCapaldo> @src foldl
21:09:34 <lambdabot> foldl f z xs = lgo z xs
21:09:34 <lambdabot>     where lgo z []     =  z
21:09:34 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
21:09:44 <Sgeo> I ran it with the product definition
21:09:47 <LoganCapaldo> Looks recursive to me :)
21:09:51 <Sgeo> My computer's being slow now :/
21:10:02 <jcreigh> > product [1..18]
21:10:04 <lambdabot>  6402373705728000
21:10:17 <narain> "lgo"?
21:10:18 <jcreigh> I do not think you will have much success calcuating the factorial of that.
21:10:27 <narain> ?src foldr
21:10:28 <lambdabot> foldr k z xs = go xs
21:10:28 <lambdabot>     where go []     = z
21:10:28 <lambdabot>           go (y:ys) = y `k` go ys
21:10:46 <narain> so lgo = left go, but go = ?
21:11:04 <LoganCapaldo> regular go?
21:11:17 <narain> apparently 18!! took down Sgeo's computer :)
21:11:21 <dibblego> lego, as in building blocks
21:11:33 <LoganCapaldo> lgo myego
21:11:39 <narain> as in, does it stand for anything?
21:11:53 <narain> or is it just the english word?
21:12:24 <dibblego> lgo is not an English word afaik
21:12:50 <narain> go
21:13:30 <narain> the defn of foldl uses a helper fn called lgo, that of foldr uses go
21:13:47 <kilimanjaro> Can somebody briefly explain type vs newtype? What reasons would I have to choose one over the other?
21:13:52 <narain> so i figured lgo is left go, and i'm wondering why the helper of foldr is called go
21:14:06 <narain> kilimanjaro: type creates a synonym
21:14:07 <kc5tja> kilimanjaro: Type is like typedef in C -- it just creates an alias for another type.
21:14:26 <kc5tja> kilimanjaro: newtype is like a version of typedef where the compiler treats the new alias _as a distinct type unto itself_.
21:14:52 <jcreigh> kilimanjaro: "type" defines a type synonym. If you say "type Foo = Int", you can still pass a Foo as an Int. if you say "newtype Foo = Foo Int", Foos are distint from Ints, and cause a type error if you try to use one as the other.
21:14:55 <kc5tja> For example, FilePath is a "type" -- it can be used anywhere String can be used.
21:15:06 <narain> so, type is useful for shorthand, newtype is useful for things that are semantically different
21:15:11 <kilimanjaro> Ok, so newtype is a bit stronger than type
21:15:15 <kc5tja> Right.
21:15:16 <LoganCapaldo> kilimanjaro: where newtype creates a new type of an existing one. type Feet = Int; type Inches = Int; oops we can mix feet and inches. newtype Feet = Feet Int, newtype Inches = Inches Int now we can't
21:15:57 <kilimanjaro> And I guess newtype makes more sense for special stuff that would eventually have typeclass implementations different from the underlying type
21:16:00 <kc5tja> LoganCapaldo: Didn't Cale come up with some Haskell code that augmented ordinary math with units of measurement too, such that it performed proper units conversion and checking?
21:16:12 <LoganCapaldo> kc5tja: Maybe?
21:16:29 <Cale> Wasn't me, but that's certainly been done.
21:16:49 <kc5tja> Maybe you just provided a link to it before.  I thought it was you.  Sorry.
21:24:10 <kc5tja> From the blog entry:    peek w | Just (x:_) <- M.lookup (current w) (stacks w) = Just x
21:24:19 <kc5tja> I _really_ dislike that syntax.  :)
21:25:00 <LoganCapaldo> pattern matching in a guard, egads
21:26:22 <kc5tja> Yes.  Although succinct, I find it very hard to read.
21:26:35 <kc5tja> The direction of the arrow has a lot to do with that difficulty too.
21:27:21 <kc5tja> peek w | M.lookup (current w) (stacks w) == Just (x:_) -> Just x      -- I prefer this approach.  NOTE: not valid haskell syntax
21:27:47 <LoganCapaldo> I think I find that more confusing
21:28:08 <dmwit> kc5tja: Would you prefer
21:28:19 <LoganCapaldo> == a pattern involving _ makes me go "huh?"
21:28:20 <dmwit> peek w | case M.lookup (current w) (stacks w) of
21:28:28 <chowmeined> I am trying to follow this tutorial but I am getting the error: No instance for (Num String) arising from the literal `0' at nums.hs:15:13  , this is my code: http://hpaste.org/1684
21:28:29 <dmwit>   Just (x:_) -> Just x
21:29:17 <LoganCapaldo> chowmeined: getLine's type is:
21:29:19 <narain> chowmeined: you're trying to compare 0 to a string
21:29:22 <LoganCapaldo> @type getLine
21:29:25 <chowmeined> oh cause getLine
21:29:25 <lambdabot> IO String
21:29:28 <chowmeined> string
21:29:28 <chowmeined> ok
21:29:36 <chowmeined> whats the one for an Int?
21:29:47 <narain> use read
21:29:49 <narain> :t read
21:29:52 <lambdabot> forall a. (Read a) => String -> a
21:29:53 <dmwit> :t readLine
21:29:56 <chowmeined> ah ok, thanks
21:29:56 <lambdabot> Not in scope: `readLine'
21:30:00 <LoganCapaldo> @t read "0\n" :: Int
21:30:01 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
21:30:05 <dmwit> ?hoogle IO a
21:30:07 <lambdabot> System.exitFailure :: IO a
21:30:07 <lambdabot> Control.Exception.evaluate :: a -> IO a
21:30:07 <lambdabot> Network.withSocketsDo :: IO a -> IO a
21:30:08 <LoganCapaldo> @ty read "0\n" :: Int
21:30:11 <lambdabot> Int :: Int
21:30:12 <narain> > read "0"
21:30:14 <lambdabot>  0
21:30:19 <int-e> toggle beep_when_away
21:32:37 <kc5tja> LoganCapaldo: It's the normal "case" pattern match syntax.
21:33:36 <kc5tja> dmwit: If you're going to do that, there is no need for the pattern match syntax at all.
21:33:56 <kc5tja> peek w = case (M.lookup (current w) (stacks w)) of ...
21:34:05 <kc5tja> and, yes, I prefer the explicit case construct.
21:34:18 <kc5tja> (in this case, I might add, no pun intended)
21:34:48 <allbery_b> yay, finally I can build ghc again
21:35:10 <allbery_b> (had to move it back to a case-dependent filesystem, a patch from a couple weeks ago broke it on OSX)
21:35:49 <chowmeined> how do I convert a number to a string for printing?
21:36:09 <LoganCapaldo> > show 34
21:36:11 <lambdabot>  "34"
21:36:21 <chowmeined> thanks
21:36:35 <kc5tja> insert and delete are pretty intractible too -- I'm re-reading it for the third time, still trying to see how the things work.
21:36:37 <LoganCapaldo> you'd think the opposite of read would be write, but its show :)
21:37:10 <narain> ?hoogle write
21:37:11 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
21:37:11 <lambdabot> Data.IORef.writeIORef :: IORef a -> a -> IO ()
21:37:11 <lambdabot> Data.STRef.writeSTRef :: STRef s a -> a -> ST s ()
21:37:34 <narain> i wonders what the opposite of show is
21:37:36 <narain> wait, it's hid
21:37:39 <narain> *hide
21:37:49 <narain> that would definitely not work
21:38:45 <Heffalump> read?
21:39:03 <narain> yes, i was considering alternative names for read/show
21:39:13 <Heffalump> ah, right
21:39:20 <Heffalump> I did think that was a bit of a basic question :-)
21:40:22 <LoganCapaldo> fromString, toString ?
21:40:32 <LoganCapaldo> but that doesn't work for strings
21:40:53 <narain> sure it does, you can convert a string to a string :)
21:41:00 <LoganCapaldo> and it cna't be read / print because print is already taken
21:41:01 <narain> but they're too java-ish
21:41:21 <LoganCapaldo> narain: yeah but you'd expect it to be the identity I think if it was named toString
21:41:48 <narain> > show "foo" -- ah, does it add quotes?
21:41:51 <lambdabot>  "\"foo\""
21:42:21 <LoganCapaldo> marshal and unmarshal aren't really right either
21:43:14 <kilimanjaro> If I don't export a type constructor from a module, can the type still be matched in a pattern by a user of the module?
21:43:25 <kilimanjaro> I guess I can always try it myself, although asking certainly is faster :)
21:43:35 <Heffalump> kilimanjaro: I believe so, if you export the data constructors
21:45:04 <kilimanjaro> Wait, would that mean that objects of that type could be constructed? I want to restrict it so that outside of a module, no objects of the type can be created
21:46:08 <LoganCapaldo> kilimanjaro: "type constructor" actually means a constructor for types like IO is a type constructor because you can use it to construct a type like IO String
21:46:21 <dmwit> It's going to be tricky to allow pattern matching, but not allow data values to be created.
21:46:23 <kilimanjaro> ahh nvm I see section 5.8 of the language spec covers this
21:46:51 <kilimanjaro> err, maybe not
21:47:40 <kilimanjaro> I'll try it out
21:49:33 <LoganCapaldo> if your type is like data Foo = A Int | B String you could provide a function like maybe or either with a type like patternMatch :: Foo -> (Int -> b) -> (String -> b) -> b
21:50:01 <LoganCapaldo> But that seems weird to not want to let people construct 'em but still be able to pattern match
21:51:27 <narain> LoganCapaldo: seems like a perfectly reasonable desire to me. encapsulation and whatnot
21:51:43 <LoganCapaldo> But what are you encapsulating anymore?
21:52:02 <LoganCapaldo> To pattern match you have to know the guts of the object anyway
21:52:27 <narain> well ok, youre right, you're not encapsulating much. but pattern matching is convenient, guts notwithstanding
21:53:12 <kilimanjaro> LoganCapaldo, I have an invariant that must be enforced but I figure it would be nice to let other stuff be able to access the actual data
21:53:14 <narain> you may want to restrict construction of datatypes to enforce some invariants
21:53:23 <narain> ah! i knew it!
21:53:57 <kilimanjaro> You can do something similar in ocaml iirc
21:54:13 <narain> you could probably do something almost as convenient using guards
21:54:22 <kilimanjaro> Can you explain?
21:55:02 <narain> f x | isFoo x = ...; | isBar x = ...
21:55:09 <LoganCapaldo> Here's a thought
21:55:18 <LoganCapaldo> define your datatype twice
21:55:18 <kilimanjaro> narain, ahh
21:55:24 <narain> as a substitute for f (Foo x) = ...; f (Bar x) = ...
21:55:28 <LoganCapaldo> err not twice
21:55:32 <LoganCapaldo> define it once
21:55:47 <LoganCapaldo> but make the ersion the API uses use a newtype version that's not exported
21:55:59 <LoganCapaldo> then you can enforce your invariant on creation etc.
21:56:09 <kilimanjaro> Ahh ok
21:56:12 <LoganCapaldo> and provide an unwrap function to give uesers something to pattern match against
21:57:03 <narain> that's an interesting solution
21:57:15 <kilimanjaro> If I even bother, that will probably be the best way to go
21:59:27 <kolmodin> morning
21:59:46 <LoganCapaldo> kolmodin: don't remind me its morning
21:59:50 <kilimanjaro> I'm writing a pretty low level vm and I would like for external tools to have access to running state, but not actually do stuff like construct new references that would be outside the root set, etc
22:00:24 <kolmodin> LoganCapaldo: I won't if you won't
22:00:30 <kc5tja> Well, I finished dons blog article.  Interesting.
22:01:57 <kc5tja> But, I have to admit, I didn't find anything there that unit testing couldn't have addressed either.  I think we're all just going to have to agree to disagree.
22:02:19 <chowmeined> how do I just do a bunch of things to items in a list and add some text onto each result for the list?
22:02:43 <Cale> map
22:02:51 <chowmeined> map doesnt work
22:02:56 <chowmeined> neither does the list comprehension
22:03:02 <kc5tja> map only covers the "does things to items" part.
22:03:10 <chowmeined> its the other part that wont compile
22:03:11 <kilimanjaro> kc5tja, I think proponents of quickcheck would say that it allows for a different, but not disjoint, style of testing than traditional unit tests, and in many ways it is an extension to "dumb" unit tests
22:03:16 <chowmeined> doing stuff and adding text
22:03:16 <Cale> > map ((++ "hello") . show . (+10)) [1..5]
22:03:18 <lambdabot>  ["11hello","12hello","13hello","14hello","15hello"]
22:03:30 <Cale> like that?
22:03:57 <chowmeined> ok ill try it that way
22:04:02 <Cale> You can obviously only add text to other text.
22:04:07 <kc5tja> kilimanjaro: Yeah, but the rapture with which it was advocated earlier seems to suggest an attempt towards "conversion of the faith."
22:04:17 <dons> kc5tja: surely you can't hope to unit test to the depth that results from a quickcheck generator?
22:04:27 <kc5tja> dons: You don't have to.
22:04:31 <dons> you can only hope to approximate it, manually.
22:04:49 <kc5tja> dons: You're exercising [] as much as anything else -- we already know that [] works (by virtue of the fact that GHC can compile itself).
22:04:49 <dons> by manually writing the base cases, and the inductive steps
22:05:00 <kc5tja> Precisely.  Induction is very powerful.
22:05:16 <dons> the question is: do you want to manually write test data, or generate it from a spec.
22:05:21 <dons> i'd go for the automated method
22:05:34 <dons> it just seems a no brainer: automation beats manual any day
22:05:38 <kilimanjaro> dons, people also talk about "corner cases", which may or may not be covered by quickcheck (if it isn't exhaustive) and which the programmer's intuition leads him to believe these cases are more important than most
22:05:58 <dons> yep.
22:06:19 <dons> and that guides test generation. but as we've seen again and again, test generators produce data we tend not to consider
22:06:35 <dons> john hughes has a great example of a bug found in an network router by QuickCheck
22:06:40 <kc5tja> dons: I'm not going to argue this further.  All QC is doing in your example is hammering the data structure with random lists of integers.  It's not proving anything that a simple 'base case unit test' wouldn't also prove.
22:06:54 <dons> that was some 4 protocol combinations in a row. the point being they'd never manually have written such a test case
22:07:06 <kilimanjaro> kc5tja, sometimes hammering is easier than screwing
22:07:13 <dons> kc5tja: hmm, no, its testing high level properties automatically
22:07:30 <kc5tja> Not in any way different from any other unit test framework.
22:07:31 <dons> saving me writing page after page of manual test
22:07:36 <dons> no, its just automating it.
22:07:44 <dons> and why wouldn't you automate the manual effort?
22:08:12 <kc5tja> You're already writing the base case unit test when you code the properties.  All QC is doing is filling in the blanks with random lists of integers.
22:08:26 <kc5tja> The core logic of the unit test YOU had to write MANUALLY.
22:08:45 <kc5tja> The only difference between QC and base-case unit tests is the automation of bogus data.
22:08:48 <dons> in the test generator, yes. that's the point
22:08:59 <dons> you turn a test case into a generator of test cases, and then you get to test more thoroughly
22:09:16 <dons> and given type-based derivation, you're able to produce edge cases automatically
22:09:31 <dons> no, if it was the automation of bogus data, it wouldn't matter.
22:09:54 <dons> do you want references to the interesting bugs found by QC in the Ericsson erlang codE?
22:10:07 <dons> or you feel you can ignore automated testing methods?
22:10:13 <hpaste>  thetallguy pasted "Why do I need add (MyClass a) to the type signature(s) for `ghosthunter'" at http://hpaste.org/1685
22:10:21 <dons> i mean, there's got to be a reason we all abandoned unit testing to move to QC right?
22:10:23 <kc5tja> dons: That depends entirely on the nature of the code being tested.
22:10:25 <dons> or are we just insane?
22:10:46 <kilimanjaro> dons, maybe you thought QC tests were more pleasing to the eye
22:10:48 <thetallguy> Anyone up for a little puzzle?   http://hpaste.org/1685
22:10:48 <kc5tja> dons: Personal preference is perhaps the simplest answer.
22:10:53 <chowmeined> ok i see
22:11:07 <chowmeined> sorry I was trying to output text in this um
22:11:15 <sjanssen> thetallguy: because class contexts on data declarations in Haskell '98 don't work the way you think they do
22:11:28 <chowmeined> i dont really know what to call it, i guess im not supposed to call it a function
22:11:32 <thetallguy> sjanssen:  I guessed that much.
22:11:48 <thetallguy> What am I missing?
22:12:09 <narain> chowmeined: are you trying to print things while doing other computation?
22:12:17 <chowmeined> yes
22:12:23 <sjanssen> thetallguy: it ensures the value is an instance of a class on construction, but doesn't save proof that there is an instance when you deconstruct it (eg. during pattern matching)
22:12:29 <chowmeined> i guess im not supposed to do stuff like that
22:12:45 <chowmeined> but i cant really see how yet
22:12:52 <kc5tja> I mean, I hate to be the one who holds an opposing point of view, but that's that.  In my estimation of the evidence reviewed, I'm not convinced using QC adds anything significant for my needs.
22:12:59 <thetallguy> sjanssen: I was afraid that's what you were going to say.
22:13:03 <kilimanjaro> dons, out of curiosity, are you working on a thesis?
22:13:26 <narain> chowmeined: if you want to debug stuff, you should try running the function in ghci
22:13:35 <chowmeined> Yes, I have it running in ghci
22:13:40 <thetallguy> sjanssen: Sounds like that's a design decision you don't agree with
22:13:58 <notsmack> kc5tja: there are sorts of bugs you'd never catch with a unit test
22:14:12 <dons> kilimanjaro: yeah
22:14:19 <chowmeined> I have all my output in a list right now, but I wanted each of those on a different line.. I was trying to use putStrLn.. but.. when I go map putStrLn listOfResults.. i get some error about No instance for (Show (IO ()))
22:14:26 <thetallguy> sjanssen: or is it a nasty problem?
22:14:27 <sjanssen> thetallguy: I do think that the current semantics are pretty much useless
22:14:42 <kilimanjaro> dons, what is the topic?
22:14:47 <sjanssen> thetallguy: it is a proposed change for Haskell', by the way
22:14:54 <dons> notsmack: yes, that's probably the most convincing examples. John Hughes has a nice list of bugs he found in a couple of days of quickchecking some (deployed) network code in erlang, that the unit testing guys hadn't thought of
22:14:54 <thetallguy> sjanssen: Ah, interesting
22:14:55 <narain> chowmeined: ah, try mapM_
22:14:58 <narain> :t mapM_
22:14:59 <dons> really weird deep cases.
22:15:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:15:36 <narain> chowmeined: map would produce a list of IO actions instead of running them
22:15:38 <dons> the example I like is that QC makes testing fun and motivating. you actually want to write tests this way, since you get such a good understanding of the code, and good testing for the effort involved
22:15:41 <thetallguy> sjanssen: it certainly looks like  I'm going to have to have a lot of extra declarations
22:15:46 <dons> manual test generatoin is tedious in comparison
22:15:59 <dons> kilimanjaro: back later.
22:16:12 <sjanssen> thetallguy: you can use GADT syntax in GHC to do what you want
22:16:22 <notsmack> @check ((\x -> 1/(1/x) == x) :: Double -> Bool)
22:16:24 <lambdabot>  Falsifiable, after 18 tests: 3.6
22:16:35 <thetallguy> sjanssen: fabulous, thanks.  I'll look into it.
22:16:38 <narain> > 1/1/3.6
22:16:40 <lambdabot>  0.2777777777777778
22:16:46 <narain> > 1/(1/3.6)
22:16:47 <thetallguy> kc5tja: Do you SCUBA dive?
22:16:48 <lambdabot>  3.6
22:16:54 <narain> > 1/(1/3.6) - 3.6
22:16:55 <lambdabot>  0.0
22:17:04 <narain> eh
22:17:08 <sieni> > 1/(1/3.6) == 3.6
22:17:09 <kc5tja> notsmack: I'm sure, but, I strongly suspect that such cases don't appear in xmonad.  xmonad's core builds on well-defined and well-tested (through other means) modules and types.  You can rely on their reliability.  If you can't, you've got bigger problems.
22:17:09 <lambdabot>  True
22:17:11 <hpaste>  jcreigh pasted "dmenu :: [String] -> IO String" at http://hpaste.org/1686
22:17:13 <kc5tja> thetallguy: I don't even swim.
22:17:22 <hpaste>  sjanssen annotated "Why do I need add (MyClass a) to the type signature(s) for `ghosthunter'" with "using GADT syntax" at http://hpaste.org/1685#a1
22:17:32 <chowmeined> narain: thanks that worked
22:17:57 <narain> so it's not 3.6 but rather something like 3.6000001426 for which 1/(1/x) /= x
22:18:07 <narain> chowmeined: glad to help
22:18:12 <kc5tja> thetallguy: Why do you ask?
22:18:13 <notsmack> lambdabot must be rounding? it shows as untrue in ghci.
22:18:24 <thetallguy> kc5tja: too bad.  'Personal preference' is a dirty word in my SCUBA community
22:18:47 <kilimanjaro> Only sailors use it
22:19:00 <kc5tja> thetallguy: What?  Sorry, but the reference is lost on me.
22:19:44 <thetallguy> kc5tja: You said earlier: Personal preference is perhaps the simplest answer.
22:19:45 <narain> notsmack: it does in mine too. the difference being -4.44...e-16
22:19:52 <kc5tja> thetallguy: Yeah.  So?
22:20:40 <thetallguy> kc5tja: it rang a bell, that's all.  Many SCUBA divers reject the uniformity advocated by the group I joined
22:20:56 <narain> thetallguy: so your people in your scuba community personally don't prefer personal preferences? :)
22:21:27 <thetallguy> kc5tja: citing personal preference as a viable reason for each diver inventing their own system/dive gear configuration
22:21:39 <thetallguy> narain: ;-)
22:21:44 <kc5tja> thetallguy: Well, I'd imagine that SCUBA is like the military -- your life is on the line.  The requirements fundamentally change.
22:21:50 * kc5tja WAS in the military.
22:21:54 <kc5tja> So I can relate to that.
22:22:05 <thetallguy> narain: the people I listen to go 300' down and 4 miles into a cave
22:22:17 <thetallguy> kc5tja: yes, similar
22:22:24 <kc5tja> However, my code that I'm working on at work is, shall we say, quite far from being certified to run pacemakers or EKG machines.
22:22:35 <narain> thetallguy: i respect that, i was just kidding
22:22:40 <thetallguy> kc5tja: strangely, many ex- military really do not like their methods
22:22:50 <kc5tja> It's a data acquisition tool, which I know works by induction based on the proposition that Python is already "well tested."
22:23:13 <thetallguy> narain: no offense.  The debate about this has raged for years across usenet.
22:23:41 <thetallguy> but the similarity of the two discussions always strikes me
22:24:00 <thetallguy> I think I mentioned it in my CUFP talk
22:24:05 <kc5tja> I'm assuming you're referring to PADI?
22:24:18 <QtPlatypus> thetallguy: Let me guess, there are 2 or three correct ways to do it, the 2/3 ways are each advocated by diffrent groups comming from diffrent traditions/training.
22:24:22 <kc5tja> I'm sure PADI has a thick book just full of where "personal preferences" has resulted in death.
22:24:28 <thetallguy> kc5tja:  really, DIR versus everyone else
22:24:30 <kc5tja> E.g., they have justification for their point of view.
22:24:45 <kc5tja> OK, substitute your favorite organization as appropriate.
22:24:53 <thetallguy> kc5tja: PADI has a pretty amazing record, for open water divers
22:25:05 <thetallguy> QtPlatypus: not exactly
22:26:12 <thetallguy> QtPlatypus: but that's what many people who have been diving for a long time say, that the DIR people are telling them how to redo things that they have learned over many years.
22:27:23 <thetallguy> kc5tja: regarding pacemakers, you said you work at google.
22:27:36 <thetallguy> kc5tja: how do you know what your code is being used to do?
22:28:27 <kc5tja> It's purpose built, and only does one thing.
22:28:32 <kc5tja> There's not much else it CAN do.
22:28:53 <thetallguy> QtPlatypus:  DIR tries to get a consisten system with one solution for everything that woks at all level of training
22:29:14 <kc5tja> And, if someone else tweaks it to do something else, without suitably updating the unit tests, (a) they get what they deserve, (b) it's not my responsibility, (c) they're out of Google's coding requirements anyway, which means they have to correct their crappy code.
22:29:28 <thetallguy> kc5tja: but it's part of a whole system that provides computing to the internet
22:29:38 <kc5tja> No, it's not.
22:29:43 <QtPlatypus> kc5tja: I wish I could say that about any of my projects.  There always getting repurposed.
22:30:00 <kc5tja> My code is a data acquisition tool to monitor other software -- it is nothing at all that a customer would use.
22:30:24 <thetallguy> kc5tja: does it monitor software that customers use?
22:30:32 <kc5tja> QtPlatypus: If my code gets repurposed, then that's wonderful.  That means it's out of my hands, and someone else takes responsibility for it.
22:30:49 <thetallguy> Ah, and there's the slippery slope.
22:30:58 <kc5tja> thetallguy: It has the potential to do that, but I've not been given specific specifications that that's what it will do.
22:31:29 <thetallguy> kc5tja: My point is simple.  You created something that has an effect on the world.
22:31:44 <kc5tja> Well, EVERYBODY has an effect on the world somehow.
22:31:55 <kc5tja> That was never in contention.
22:31:58 <notsmack> this debate sucks.
22:32:11 <thetallguy> notsmack: agreed.  Trying to wind it up.
22:32:13 <kc5tja> The point is, my code will not be directly used by an end-user customer.
22:32:30 <kc5tja> And, even if it did, I really don't see the relavence.
22:33:24 <thetallguy> kc5tja: I can't wind this up neatly.  Suffice it to say, that dons and your discussion about QC reminded me of the DIR scuba discussions.
22:33:24 <kc5tja> notsmack: I'm sorry to disappoint you.  I can't please everyone.
22:33:56 <kc5tja> Hence my comment previously, "We need to agree to disagree.  I think QC is overkill.  He doesn't.  There is no need to drag this on.
22:34:03 <thetallguy> kc5tja: and that I have benefitted both from DIR and from thinking as dons is suggesting.
22:34:42 <thetallguy> kc5tja: Just offering another viewpoint.
22:34:46 <kc5tja> That's wonderful.  I'm very happy.  But, can we please STOP TRYING TO SHOVE QC DOWN MY THROAT?
22:35:00 <kc5tja> I have read the webpage, read an example of its use, and I still remain unconvinced.
22:35:03 <kc5tja> I'm sorry.
22:35:22 <thetallguy> kc5tja: Sure.
22:35:33 <thetallguy> kc5tja: Cheers.
22:39:18 <narain> ?quote
22:39:19 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
22:43:00 <thetallguy> sjanssen: I don't see the appropriate Haskell Prime ticket
22:55:23 <kc5tja> Well, I'm off to bed -- I've had enough fun for today.
23:00:16 <Cheery> I have that list of events, say: [1,3,4]
23:00:17 <Cheery> ok
23:00:40 <Cheery> so, what should I call a function which determines from this list whether it should quit?
23:01:18 <Cheery> > let w = elem 4 in w [1,3,4]
23:01:20 <lambdabot>  True
23:01:24 <Cheery> > let w = elem 4 in w [1,3]
23:01:26 <lambdabot>  False
23:03:56 <narain> whether what should quit?
23:04:35 <narain> Cheery: ^^
23:09:38 <Cheery> program
23:19:11 <dmwit> isTerminal
23:19:13 <dmwit> ?
23:19:36 <dmwit> Or, if you're a lispnik, maybe terminalp. ;-)
23:19:39 <Cheery> I were thinking about something like: quitSignaled
23:19:42 <Cheery> or: quitEmitted
23:20:12 <Cheery> the quit signal does not cut the stream
23:20:12 <dmwit> sure
23:22:58 <narain> Cheery: you may want to pick a name that fits well with the context you're going to use it in
23:23:36 <narain> > minimumBy (comparing abs) [4,-3,2] -- for example, "comparing" here
23:23:38 <lambdabot>  2
23:25:10 <TRWBW> howdy
23:26:04 <TRWBW> just to be up-front, i thought i might stir up some ruckus. any opinions on why after 20 years #haskell still hasn't proven itself in the form of killer apps written in #haskell?
23:27:12 <dmwit> I assume you mean s/#haskell/Haskell/g ?
23:28:22 <Cheery> TRWBW: things need time to happen, especially with small group
23:28:44 <TRWBW> dmwit: call it miranda if you like
23:28:48 <TRWBW> Cheery: 20 years.
23:29:38 <notsmack> TRWBW: how about darcs?
23:29:40 <Cheery> you realise that before C# was what it is now, there were lots behind?
23:29:40 <dmwit> TRWBW: Sure, I was just wondering how to implement things in an IRC room... ;-)
23:29:49 <TRWBW> Cheery: heck, throw scheme, lisp, T and ML into the bunch, 50 years
23:30:24 <Wild_Cat> TRWBW: if you want to include ML in all that, there's at least MLDonkey and FFTW.
23:30:44 <notsmack> emacs?
23:31:09 <Cheery> thus, I think neither other languages have any 'killer app'
23:31:17 <Wild_Cat> and as far as Haskell itself is concerned, Pugs may suit your definition of a killer app.
23:31:19 <Cheery> at least one which would interest me
23:31:32 <TRWBW> Wild_Cat: that doesn't change the point that for everyone using a haskell program, at any moment, there are 100,000 people using a program written in JCL for an IBM mainframe
23:31:42 <narain> Wild_Cat: FFTW? i assume you don't mean the Fastest Fourier Transform in the West, which is written in C
23:31:42 <TRWBW> Wild_Cat: well probably more like 10,000,000
23:32:05 <Wild_Cat> narain: I do. The C code is generated by an Ocaml program.
23:32:16 <narain> really? i didn't know that
23:32:19 <narain> i'm impressed
23:32:36 <Wild_Cat> TRWBW: and your point it?
23:32:42 <Wild_Cat> s/it/is/
23:33:04 <TRWBW> c'mon it's the elephant in the room that everyone pretends doesn't exist. if pure, mathematical, functional languages are better, why is all the software people use written in ugly, procedural, non-functional languages with vague semantics
23:33:27 <Wild_Cat> TRWBW: because LISP aside, that's what people already know.
23:34:04 <Wild_Cat> that's an example of the Counter-Strike syndrome. Why does everyone play Counter-Strike when there are countless superior games in the same genre? Because everyone plays Counter-Strike.
23:34:11 <TRWBW> Wild_Cat: this has been going on for 50 years. those ugly languages people actually use mostly post-date haskell. certainly early variants.
23:34:48 <dmwit> TRWBW: ...but were derived from previously popular languages in an almost mechanical fashion.
23:35:03 <Wild_Cat> also, UNIX was implemented first in ASM, then in C. It was logical for UNIX users to use the language in which their OS was coded.
23:35:13 <notsmack> TRWBW: i've suspected for a while that most 'programmers' aren't capable of doing purely functional properly
23:35:15 <dmwit> Haskell represents a pretty significant fundamental difference -- it can't be approached with very many of the "usual" mental attacks.
23:35:15 <cdsmith> Wild_Cat: what's counter-strike?
23:35:17 <TRWBW> i'm actually suprised, i wasn't expecting this level of jim jones kool-aid that you won't even admit that paradox that functional languages seem cooler but have been a practical failure
23:35:40 <TRWBW> and it's not that they are newer, if you think that, you must be under 40 years old
23:35:44 <reitblatt> TRWBW: since 1957 you say? Lisp hadn't even been invented yet
23:35:47 <Wild_Cat> once people got used to/hooked on C, they focused on it and its successors: C++, Java, C#...
23:36:01 * allbery_b suggests not feeding the trolls
23:36:10 <Wild_Cat> cdsmith: Counter-Strike. The Half-Life mod. The most-played multiplayer FPS ever.
23:36:10 <Korollary> Counter Strike suckx
23:36:10 <notsmack> TRWBW: which, if true, explains why things that are functional are often replaced by other languages once they gain traction.  pg's yahoo stores, for instance, when yahoo rewrote it because their programmers couldn't work on it.
23:36:15 <TRWBW> reitblatt: lisp existed in 1957
23:36:40 <reitblatt> according to wikipedia, it first came to existence in '58
23:36:41 <Wild_Cat> Korollary: no argument there. Yet everyone plays it.
23:36:58 <dmwit> "Nobody goes there any more, it's too crowded."
23:37:00 <allbery_b> lisp as a notation was around in the late 40s, IIRC
23:37:18 <allbery_b> it wasn't *implemented* as a language until the 50s
23:37:28 <dmwit> That is to say, popularity (even in the programming language realm) does not imply quality.
23:37:47 <Wild_Cat> dmwit: absolutely.
23:37:49 <reitblatt> as a data point, VB is quite popular
23:38:01 <allbery_b> but, I fail to be interested in trolls and poltroons.  gnite
23:38:03 <dmwit> Just because *more people* are writing in C++, and hence *more people* are available to create apps like, say, Firefox, does not make C++ a better language.
23:38:09 <Wild_Cat> people don't want what is better. They want what is familiar, and/or what they already have.
23:38:21 <reitblatt> whohoo!
23:38:22 <cdsmith> Wild_Cat: Well, that explains it then.  I think I played Doom once.
23:38:24 <reitblatt> we win the internets!
23:38:32 <notsmack> Wild_Cat: i'm not sure that's fair, paradigms have shifted a few times
23:38:42 <Wild_Cat> C feels familiar when you know ASM. C++ is familiar when you know C. Java/C# is familiar when you know C++.
23:38:59 <Wild_Cat> Haskell is familiar when you know... er... Haskell.
23:39:02 <reitblatt> Wild_Cat:  exactly
23:39:03 <dmwit> Oh, he's gone.
23:39:08 <dmwit> reitblatt: You're right, we win! =)
23:39:20 <dons> anyone have more info on TRWBW?
23:39:43 <dons> the ip looks vaguely like gschuett, our occasional troll
23:39:46 <reitblatt> well, he appears to be from new york
23:39:49 <Wild_Cat> @whois trwbw
23:39:50 <lambdabot> Unknown command, try @list
23:39:55 <dons> though more coherent, actually.
23:40:00 <dons> ah well.
23:40:07 * dons goes back to writing haskell for money in the real world
23:40:09 <Wild_Cat> didn't lambdabot have some kind of whois/info command?
23:40:42 <Korollary> Your language sucks.
23:40:46 <Wild_Cat> meh. I have to go writing Java for money in the real world. (one month to go, after that I'll level up to Python)
23:41:02 <cdsmith> Korollary: no it doesn't!  Take it back, loser!
23:41:21 <Korollary> cdsmith: No, show me the killer apps written in it first
23:41:38 <dons> yeah, man, where are all the killer functional apps!
23:41:55 <dons> hang on, let me turn on emacs
23:41:56 <Korollary> I actually never cared what language an app was written in
23:41:58 <dons> maybe it will know.
23:42:14 <dons> hey, i wonder how many people in here are using xmonad?
23:42:26 <Wild_Cat> if a Haskell driver for a life support system can be formally proven to kill someone, does that make it a killer app?
23:42:27 <notsmack> "notsmack: emacs?"
23:42:45 <dons> i noticed we're up to 45 people on the mailing list, and 23 in the irc channel, and 150k hits on the website. could xmonad be #3 most popular haskell app yet?
23:42:49 <Korollary> this is why you should have xmonad call home. Then you'd know exactly who.
23:42:58 <dons> yeah.
23:43:03 <Korollary> Then sell some viagra
23:43:15 <dons> should've put ads on the website for that
23:43:23 <cdsmith> dons: #1 and #2 are ... ?  ghc and darcs?
23:43:25 <dons> i'd have my solid gold lambda backscratcher by now
23:43:30 <dons> cdsmith: i was thinking pugs and darcs
23:43:37 <dons> since ghc counts as a language tool
23:43:50 <dibblego> lol @ "solid gold lambda backscratcher"
23:44:25 <cdsmith> hmm.  I didn't know about pugs.  Since it's perl-related, I probably intentionally blocked it from memory at some point.
23:44:41 <Wild_Cat> wouldn't sell much, I think. Penile enlargement is a side-effect, after all.
23:44:46 <dons> heh, the world's only perl6 implementation
23:45:10 <cdsmith> I'm looking at it now.
23:45:11 <dibblego> <dons> anyone have more info on TRWBW? he has TCP/22 (SSH) open
23:45:16 <dons> heh
23:45:20 <Korollary> according to audreyt, pugs will at one point stop using ghc altogether
23:45:26 <dons> i was wondering if it was gschuett/protontorpedo
23:45:34 <dons> Korollary: yeah, i'll believe that when I see it ;-)
23:45:50 <dons> its possible, like yale haskell was abandoned (an early implementation of haskell in lisp)
23:45:52 <dibblego> he seemed to ask reasonable questions; they are questions that some people feel need answering
23:46:05 <dons> but the effort invested seems huge: how do you duplicate say, the STM concurrency mechanisms.
23:46:09 <dons> that's a lot of work to build on
23:46:24 <dmwit> I'm wondering if he came from a discussion in #math, does anyone know of #math logs?
23:46:25 <dons> dibblego: yeah. that's true. hence I wasn't sure if it was just gschuett at it again
23:46:32 <Korollary> I dont think perlers are heavily into STM
23:46:43 <dons> i though the join parallelism was all predicated on STM
23:46:46 <dons> they just don't know it?
23:47:02 <dons> i suppose that leaves open the option of a non-stm implementation
23:47:04 <dmwit> (He seems to be a semi-respectable member on the #math room.)
23:47:27 <dons> ok. so why bother trolling us?
23:47:30 <dfranke> This is against my better judgement.
23:47:34 <dfranke> dfranke@laurelin:~$ darcs get --partial http://darcs.haskell.org/ghc
23:47:35 <lambdabot> Title: Index of /ghc
23:47:41 <dons> i mean, mbot in #math is in written in haskell... :)
23:47:52 <dons> dfranke: go man, go!
23:48:04 <dibblego> I think crap languages are popular for the same reasons that crap operating systems are popular and crap <lots-of-things> are popular
23:48:35 <dons> yep. 'nuff said.
23:48:44 <narain> #haskell should take mbot away from #math for trolling us
23:48:44 <dibblego> yep :) I got a train to catch anyway!
23:48:49 <dons> and not everyone can afford a mercedes
23:49:30 <dons> sure, you're less likely to crash and die, and all the components run a bit better, but it costs more. so people who don't care, buy a honda^h^h^hphp and write in that
23:49:44 <dons> i think i got lost in the middle of that analogy
23:50:01 <notsmack> haha, yeah.  hophp?
23:50:08 <Korollary> WHy do you even care. Haskell could be your competitive advantage.
23:50:33 <dons> yeah, its used like that by the 4 or so finance places using it now (that we're aware of)
23:50:39 <dons> and they happily hire hakellers. so all good.
23:50:45 <narain> as a non-mercedes-affording person, i resent that analogy
23:50:50 <dons> there's not even enough haskellers, in fact. theyhave to recruit ocaml and scheme coders!
23:51:33 <narain> (i should remember to put smileys in my just-kidding messages)
23:51:38 <sieni> if only they hired in finland :-/
23:51:43 <dons> narain: so my basic idea is that yeah, haskell is a bit more expensive, but you're paying for quality. however, just as with cars, people are happy with things that mostly work, but might break down more often ,just because they're cheaper.
23:51:58 <dons> so, make haskell cheap enough that we all have jobs. that's the goal
23:52:01 <reitblatt> as the driver of a '95 Maxima which shifts out of park ~50% of the time, I'm jealous of that analogy
23:52:03 <dfranke> FWIW I applied to Y Combinator with a startup idea that I was going to implement in Haskell.
23:52:19 <dons> and given the demand is ahead of supply currently (for the top end haskellers) , i'd say its working
23:52:36 <dons> dfranke: oh yeah, you said 'i want to do this in haskell' ?
23:52:46 <dfranke> didn't make the cut but mostly because my cofounder was still in college.  So I'm going to try again in a year.
23:52:49 <Korollary> liskell maybe
23:52:56 <vegai> demand is ahead of supply for any field for the top end
23:53:18 <dons> that's true. at least there is demand though :-) there wasn't outside of research 5 years ago
23:53:27 <Korollary> man. Who targets mzscheme anyway. Anybody who hasn;t seen the shootouts?
23:53:31 <cdsmith> narain: since many haskell users seem to be graduate students; I imagine many can't afford a mercedes.  Haskell makes for a good alternative.  Or something like that.
23:53:34 <dfranke> crud.  Compile errored out.
23:53:54 <dfranke> coreSyn/CoreUtils.lhs:258:0:
23:53:54 <dfranke>     Equations for `mkAltExpr' have different numbers of arguments
23:53:54 <dfranke>       coreSyn/CoreUtils.lhs:(258,0)-(259,59)
23:53:54 <dfranke>       coreSyn/CoreUtils.lhs:262:0-36
23:53:55 <narain> cdsmith: my other car is a functional programming language?
23:53:58 <dons> cdsmith: heh. yeah, i feel like i own some precision german engineering, when i fire up xmonad.
23:54:02 <dons> ;)
23:54:14 <dfranke> my other car is a cdr.
23:54:15 <reitblatt> my other car is cdr ;)
23:54:16 <dons> dfranke: there's a patch to that on the list today
23:54:23 <reitblatt> doh
23:54:40 <dons> you know what they say about stereo in here
23:56:22 <dfranke> dons, which list?
23:57:07 <dons> oh, cvs-ghc@ I think. sorear posted it.
23:57:21 <dons> your other option is to grab a snapshot from a week or so ago, before head broke
23:57:40 * notsmack can't find the source to State
23:57:55 <cdsmith> @source Control.Monad.State
23:57:55 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
23:58:34 <notsmack> cdsmith++
23:58:53 <cdsmith> Hmm... that didn't work out so well
23:59:00 <cdsmith> @source Control.Monad.State.Lazy
23:59:00 <lambdabot> Control.Monad.State.Lazy not available
23:59:03 <notsmack> cdsmith: pointed me the right place
23:59:06 <notsmack> http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
23:59:52 <dfranke> dons, found it, thanks.
