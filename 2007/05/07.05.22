00:00:31 <dons> its sort of a guide about as to how smelly some code is. we don't require 500 loc, but notionaly sticking to the 500 limit has helped keep the code cleaner
00:01:17 <twb> I'm bored, and trying to compile and run Yi 0.2.0 with GHC 6.6.  I did ./Setup.hs config && ./Setup.sh build, but subsequently dist/build/yi/yi immediately panics.
00:01:19 <dons> rewriting to a zipper knocked 55 lines off: good sign. some other things have been rejected for being too big. so it acts as a bit of a heuristic, and helps guide contributors
00:01:46 <dons> its one of the few forces that oppose never ending feature bloat
00:01:51 <kosmikus> twb: have you installed the -gtk or -vty frontends?
00:01:54 <quicksilver> stmartin: you can use its enum instance by using 'toEnum'
00:02:02 <quicksilver> stmartin: or you can just use 'chr'
00:02:06 <sebell`> twb: You're in #haskell now? I guess it was only a matter of time...
00:02:09 <twb> kosmikus: AFAIK, no.
00:02:15 <kosmikus> twb: you need one of them
00:02:16 <twb> sebell`: I used to come by here occasionally
00:02:21 <twb> kosmikus: I see.
00:02:28 <twb> kosmikus: maybe I'll RTFM before I ask stupid questions
00:02:33 <twb> *more stupid questions
00:02:56 <kosmikus> twb: it's not a stupid question. there could be a README, or even a meaningful error message ...
00:02:57 <stmartin> That's all very well, but it doesn't seem to convert to Word8
00:03:19 <quicksilver> stmartin: you said you wanted 'from' Word8
00:03:28 <quicksilver> :t toEnum
00:03:32 <lambdabot> forall a. (Enum a) => Int -> a
00:03:36 <kosmikus> dons: I always hear this "Zipper" talk. What exactly is a zipper now?
00:03:36 * stmartin tries to sort what it is he wants
00:03:58 <quicksilver> :t fromIntegral . toEnum
00:04:01 <lambdabot> forall b. (Num b) => Int -> b
00:04:14 <quicksilver> :t fromEnum . fromIntegral
00:04:17 <lambdabot> forall a. (Integral a) => a -> Int
00:04:30 <stmartin> I want to output a UTF8 encoded bytestream, so my encoder function is returing [Word8].
00:04:50 <quicksilver> stmartin: then you need to write a UTF8 encoding function :)
00:05:01 <dons> kosmikus: in this case, we represent a workspace (a [Window]), as a zipper on lists, i.e. a one-hole cursor into a [Window], --> ([Window],Window,[Window])
00:05:16 <stmartin> But that kicks up a fuss with writeFile, so I'm making a wrapper around my encoder function which converts it to a [Char]
00:05:22 <dons> this is the zipper for lists, a list with a hole punched in it, where the hole marks where window manager focus is.
00:05:24 <quicksilver> stmartin: but if you only care about the low 7 bits, then fromIntegral . fromEnum  should do
00:05:33 <quicksilver> :t fromIntegral . fromEnum
00:05:36 <lambdabot> forall b a. (Num b, Enum a) => a -> b
00:05:40 <dons> kosmikus: the code for manipulating focus then becomes obvious, happily.
00:05:42 <kosmikus> dons: yes, ok.
00:05:42 <stmartin> No, I definately _do_ care about all the bits.
00:05:56 <quicksilver> stmartin: then you have to write, or use, a UTF8 encoder
00:06:05 <quicksilver> stmartin: there is no UTF8 encoder built in to haskell
00:06:06 <stmartin> That's what I'm doing.
00:06:07 <kosmikus> dons: handwritten zipper, or do you use some obscure generic programming library?
00:06:28 <dons> no, its hand written, but is the same as you'd derive by hand on [a].
00:06:32 <dons> no obscure generics :-)
00:06:33 <twb> kosmikus: http://twb.ath.cx/tmp/tmp.log
00:06:40 <kosmikus> dons: good :)
00:06:58 <scodil> is there a version of hoogle that indexes the opengl bindings? or any of the other non-standard stuff that ships with ghc?
00:07:00 <quicksilver> dons: there was  UTF8 library layered on ByteString, wasn' there?
00:07:15 <dons> though the actual data structure, i found after the fact, is given as an example of type calculus in an intro to Conor's paper on one-hole context types.
00:07:19 <stmartin> I'm making the UTF-8 encoder as a learning experience.
00:07:44 <quicksilver> stmartin: the clearest thing probably is jsut to use 'ord' then
00:07:45 <dons> quicksilver: hmm, yesh, a utrecht lib. better check the archives of the news page on haskell.org
00:07:56 <quicksilver> stmartin: use 'ord' to convert Char to Int
00:08:02 <quicksilver> stmartin: then split the cases
00:08:11 <kosmikus> twb: this is completely normal. you have to *install* yi, then also download, build and install yi-gtk (or yi-vty, but I've not yet tried that), and only then the binary should work.
00:08:21 <quicksilver> stmartin: (if its less than 127, just use that, if it's over 127 then...)
00:08:34 <twb> kosmikus: confusing!  I will try.
00:08:44 * stmartin checks if hpaste is back up yet.
00:08:52 <kosmikus> twb: the yi binary tries to dynamically load modules that are provided only by the other package.
00:09:30 <twb> kosmikus: where is yi-vty?
00:09:32 <dons> kosmikus: oh, the other thing that keeps code clean, is requiring QC properties. patches aren't accepted on the core unless they have nice QC properties for their semantics. (idea is that ease of semi-formal statements about the code, hints at how good the code is)
00:09:39 <kosmikus> twb: they should all be on hackage
00:09:45 <stmartin> Is writeFile 8-bit clean?
00:10:03 <kosmikus> dons: interesting idea.
00:10:04 <twb> kosmikus: I don't know how to make hackage work on my Debian/GHC6.6 system.  AFAICT I need to use hackage to install hackage
00:10:15 <kosmikus> twb: now, you can just use the web.
00:10:27 <dons> and, more interrestingly, that simplicity of QC statements about the code, indicates how usable the interface is.
00:10:28 <quicksilver> :t writeFile
00:10:31 <lambdabot> FilePath -> String -> IO ()
00:10:35 <quicksilver> stmartin: yes
00:10:36 <dons> that's more controversial, I think, but seems to hold up.
00:10:46 <quicksilver> stmartin: under some OSes you have to open the file in binary mode
00:10:54 <kosmikus> twb: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Editor
00:10:58 <lambdabot> http://tinyurl.com/yqov7f
00:11:04 <dons> window manager behaviour that is easy to state with QC, tends to be lead to more intuitive interfaces.
00:11:37 <kosmikus> dons: do you have optional floating windows yet? ;)
00:11:57 <dons> jcreigh: mentioned he'd got a simple version working this morning.
00:12:08 <stmartin> Or would I be better to output a ByteString, do you think?
00:12:15 <dons> so whether that makes it into 0.2, or 0.3, i'm not sure, but we'll have it soon enough.
00:12:37 <kosmikus> great, I should make the switch then.
00:12:50 <dons> you need floating layer support?
00:12:53 <dons> for gimp or some such?
00:12:59 <kosmikus> yes, sometimes.
00:13:17 <dons> yeah. there must be other users in a similar state. hopefully we get that sorted soon
00:13:50 <quicksilver> stmartin: depends what your objectives are
00:14:16 <twb> kosmikus: so what am I supposed to do -- download the .tar.gz's for yi-vty and yi, and then build them as normal with Setup.hs?
00:14:19 <quicksilver> stmartin: bytestring is probably better, but if you're only doing this as an exercise it's up to you how you limit the complexity :)
00:14:21 <stmartin> Well I'd want to write it stdout or a file ideally.
00:14:42 <kosmikus> twb: yes. you already have downloaded yi though.
00:14:45 <twb> OK.
00:15:01 <twb> I thought hackage also had a download feature, like apt
00:15:01 <kosmikus> twb: so you only need the other one, I guess.
00:15:08 <twb> I guess I misunderstood.
00:15:27 <quicksilver> stmartin: you can do that equally well with either
00:15:42 <kosmikus> twb: there's a program (cabal-install, I think) that can interface automatically with hackage, but you don't have to use it.
00:16:28 <kosmikus> twb: I'm not sure in what state it currently is. But if it works it should track dependencies automatically.
00:16:57 <fuzan> are odd drawing issues common with VTY?
00:17:05 <twb> Oh, I evidently confused cabal-install with hackage.
00:17:48 <twb> kosmikus: FYI, both yi-gtk and yi-vty appear to be in packages/ in the yi darcs repo
00:18:39 <kosmikus> twb: sorry, I didn't realize you were using the darcs repo before.
00:18:46 <twb> kosmikus: no problem.
00:18:58 <kosmikus> twb: but you're right, of course.
00:21:31 <fuzan> http://www.fuzan.org/before.PNG
00:21:36 <fuzan> http://www.fuzan.org/after.PNG
00:21:49 <fuzan> examples of the drawing issue i'm having with VTY
00:21:53 <fuzan> on resize, it dissapears
00:22:04 <fuzan> and it only occurs when it the text reaches the info bar
00:24:20 <quicksilver> fuzan: never used it but it looks like a bug to me
00:25:33 <fuzan> i'm thinking if not, my fill code is incorrect; but then again, it the width of images need to be identical, so i think i'm doing that correctly :\
00:26:13 <quicksilver> fuzan: other possibility of course is a but in that terminal
00:26:20 <quicksilver> fuzan: FWIW, check it in a plain xterm too
00:26:24 <fuzan> kk
00:26:29 <fuzan> good call.
00:28:53 <fuzan> happens in console too :\
00:29:16 <sebell> dons: ``code smell'' Eww!
00:29:26 <twb> kosmikus: how do I do a user install of vty?
00:29:29 <fuzan> it's odd, the last character before spaces propogate down
00:29:40 <twb> kosmikus: ./Setup.lhs install --user?
00:32:02 <kosmikus> twb: yes.
00:36:03 <jmg> hi
00:36:29 <Lemmih> Hey
00:37:54 <jmg> i'am trying to find out where an exception is thrown during execution of an quickcheck property
00:38:08 <jmg> any ideas?
00:38:45 <Lemmih> Finding where exceptions are thrown from is a bit hard in Haskell.
00:38:55 <jmg> yes
00:38:57 <Lemmih> jmg: What kind of exception?
00:39:06 <jmg> *** Exception: Prelude.(!!): negative index
00:39:26 <twb> kosmikus: that doesn't seem to work... I mean that I have no root priviledges on this host, and I want to install somewhere in $HOME.
00:39:28 <jmg> i am using fql, quicheck, Data.Set, and Data.Map in that code
00:39:42 <jmg> s/fql/fgl/
00:40:34 <jmg> i don't use (!!), so the culprit must be in those libraries
00:40:54 <Lemmih> Oh, hm.
00:41:33 <jmg> and I didn't use any of the "unsafe" functions of Data.Set either
00:41:48 <kosmikus> twb: and you can't install with --user?
00:41:57 <fuzan> jmg: look for subtractions
00:42:15 <twb> kosmikus: --user tries to use /usr/local
00:42:25 <kosmikus> oh, you can provide a different prefix
00:42:38 <jmg> you mean  (\\) i suppose?
00:43:03 <fuzan> jmg: something's gotta make a subtraction for !! to occur :)
00:43:07 <fuzan> err, negative index
00:43:15 <fuzan> ?  [] \\ [5]
00:43:24 <fuzan> > [] \\ [5]
00:43:26 <lambdabot>  []
00:43:28 <kosmikus> twb: Setup configure --prefix=/my/home/yi
00:43:35 <stmartin> Well, that worked well. I love how you write an entire file in a single line.
00:43:43 <opqdonut> > [1,2,3] \\ [1,3]
00:43:44 <lambdabot>  [2]
00:43:48 * osfameron invents an operator (let _ & x = x) in order to be able to write map (&1) and then realises that there is a handy function 'const' in the prelude that does just that...
00:43:50 <twb> kosmikus: OK
00:44:14 <opqdonut> osfameron: :P
00:44:37 <jmg> fuzan: the strange thing is i don't use any indices for list elements myself
00:44:46 <fuzan> a prelude's probably calling it
00:44:56 <opqdonut> ?src (\\)
00:44:57 <lambdabot> (\\) = foldl (flip delete)
00:45:05 <Lemmih> jmg: The problem must be in fgl, then.
00:45:09 <opqdonut> ?src delete
00:45:09 <lambdabot> delete = deleteBy (==)
00:45:31 <Syzygy-> ?src deleteBy
00:45:31 <lambdabot> Source not found. It can only be attributed to human error.
00:45:32 <fuzan> ?src liftM
00:45:33 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:46:49 <jmg> thanks, i will try to avoid the usage of fgl and see what happens
00:49:21 <twb> Well, I have no clue what this rats nest of makefiles did, but I got yi to boot.
00:49:40 <twb> ...oh, except it's now saying error: YiConfig not loaded
00:50:03 <fuzan> i'm not using yi until either binary builds or the build process is made sane :)
00:50:03 <kosmikus> twb: yes, that's the next problem.
00:52:27 <kosmikus> twb: see http://www.haskell.org/haskellwiki/Yi#How_to_Configure_Yi
00:52:27 <lambdabot> Title: Yi - HaskellWiki
00:52:28 <jmob> ?hoogle sleep
00:52:28 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
00:52:28 * twb 's head hurts
00:52:28 <ejt__> dons: I just read you latest xmonad blog (v. good).  I was wondering why you wrote 'go' as a fold across a list rather than just composing with (.) ?
00:52:28 <fuzan> ?hoogle threadDelay
00:52:28 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
00:52:55 <jmob> fuzan: yeah, that's what I wanted
00:53:04 <osfameron> twb: yeah, I got that far.  During the build it popped up a yi window.  But when I closed it, I couldn't find the binary, and the one I did eventually find (in the "build" tree) moaned there was no YiConfig
00:53:27 <twb> osfameron: make runtime-config
00:54:44 <osfameron> twb: how odd!  thanks.  I wonder why that isn't done as part of build
00:54:45 <kosmikus> fuzan: actually, the build process of yi is pretty easy compared to what it used to be.
00:55:02 <fuzan> is it a viable alternative to emacs?
00:55:17 <kosmikus> fuzan: not yet, but you can help make it into one ;)
00:55:20 <twb> fuzan: no, since it has no web browser or newsreader
00:55:34 <fuzan> you don't want me hacking on code yet :)
00:55:46 <twb> It probably doesn't even have a directory editor or irc client!
00:56:01 <fuzan> i really only care about multiple buffers/tabs and sytntax highlighting/indention
00:56:03 <quicksilver> I believe it doesn't even have a tetris game, or an AI psychoanalyst
00:56:05 <kosmikus> twb: there's a dired patch in darcs, but I haven't tested it.
00:56:07 <quicksilver> it's really a very poor editor
00:56:09 <kosmikus> twb: no irc client afaik.
00:56:15 <osfameron> what!  no pyscoanalyst?
00:56:16 <quicksilver> ;)
00:56:43 <twb> osfameron: it's not a psychoanalyst, it's a psychoTHERAPIST.
00:56:49 <osfameron> the vim clone doesn't yet understand visual mode and other niceties. but it looks like a good start
00:57:00 <kosmikus> I guess it'll soon (if it hasn't already) have a "built-in" lambdabot.
00:57:29 <osfameron> twb: no wonder my editing has been inefficient while I was labouring under that delusion!  thanks ;-)
00:59:02 <fuzan> the vim mode should be put on hiatus
00:59:08 <fuzan> who here even uses vim for coding?
00:59:11 <kosmikus> me
00:59:19 <fuzan> that's one :)
00:59:29 <jmob> fuzan: I use emacs with viper
00:59:31 * earthy does
00:59:37 <fuzan> jmob: for reals?
00:59:40 <earthy> and what vim mode? there's dozens. :)
00:59:45 <jmob> fuzan: for reals
00:59:54 <kosmikus> earthy: he's referring to yi's vim-mode, I think
00:59:55 <earthy> (well, maybe not dozens, but at least 3)
00:59:57 <earthy> ah. ;)
01:00:21 * osfameron uses vim
01:00:35 <earthy> which reminds me to look into shim some more
01:00:41 <twb> No horizontal splitting, either.
01:00:44 <osfameron> I wish it had a proper programming language as the backend, like emacs, but I love the keyboard bindings
01:01:05 <osfameron> which is why I think yi is an interesting project - it's a proper extensible editor with a sane (roughly) scripting language
01:01:17 <earthy> hum, yeah, well, you can compile vim against python. ;)
01:01:20 <twb> Since when is Haskell a scripting language?
01:01:25 <opqdonut> osfameron: do you know lua (the scripting language)?
01:01:31 <earthy> since we want it to be. ;)
01:01:35 <twb> "scripting" is a denigration
01:01:46 <earthy> twb: explain that to John Ousterhout
01:01:48 <osfameron> unlike vim which is lovely and powerful but has a pissy little hacked together thing that has grown organically and only got arrays and hashes in the latest release
01:01:51 <osfameron> twb: my arse
01:02:00 <osfameron> I'm a perl programmer.  "Scripting" is a term of the utmost respect
01:02:01 <twb> elisp is a scripting language because it has broken scoping and only byte compiles
01:02:09 <osfameron> and in any case I meant it in a very specific way
01:02:17 <osfameron> Haskell is the scripting language of yi
01:02:22 <osfameron> because yi is scripted in it
01:02:26 <MarcWeber> fuzan: Me too
01:02:33 <opqdonut> osfameron: extension language might be more politically correct :)
01:02:34 <osfameron> if you write a (dynamically plugged in) extension to yi, it will be in haskell
01:02:37 <twb> yi is implemented and extended in Haskell; thus it is the implementation and extension language.
01:02:46 <dons> heh.
01:02:51 <osfameron> opqdonut: only if you think "scripting language" is denigratory, which I don't
01:02:53 <earthy> ooh, flamewar. ;)
01:02:58 <dons> this is funny
01:03:07 <dons> what do we call haskell in the yi paper?
01:03:09 * earthy dons his asbestos suit
01:03:18 <osfameron> opqdonut: I've heard good things about Lua, not used it
01:03:18 <opqdonut> osfameron: i don't, but some people seem to :)
01:03:19 * twb ducks and covers
01:03:22 * dons earthys his dons suit
01:03:22 <dons> what
01:03:27 * earthy laughs
01:03:29 <osfameron> dons++
01:03:31 <opqdonut> osfameron: i'm working on an editor extensible in lua
01:03:42 <osfameron> opqdonut: nice!  got a blog/url/repo ?
01:03:46 <earthy> anyway, yi is a laudable effort
01:03:48 <dons> i think we call haskell an extension language, officially, in yi.
01:03:50 <rhythm> why not just write the editor in it? its not like editing is CPU intensive
01:03:55 <twb> lua is icky
01:04:02 <osfameron> opqdonut: I have a half-baked project to write an editor in Perl
01:04:03 <dons> rhythm: hmm, it can be.
01:04:06 <earthy> I just probably will never use it
01:04:08 <opqdonut> osfameron: http://opqdonut.users.paivola.fi/repos/editor
01:04:10 <twb> Or at least all the projects that use lua seem to suck and be badly broken
01:04:11 <lambdabot> Title: Index of /repos/editor
01:04:15 <dons> big buffers. (think of some slow javascript editor in the browser)
01:04:16 <opqdonut> osfameron: i considered perl but lua has a nicer api
01:04:39 <opqdonut> twb: you've seen the wrong projects :)
01:04:39 <osfameron> opqdonut: fair enough.  I'm a perl dev, so I know it, and it has CPAN ;-)
01:04:44 <twb> osfameron: ion?
01:04:47 <opqdonut> ion3 is very nice
01:04:52 <twb> Ion is a horrible mistake
01:04:57 <dons> hah
01:05:14 <twb> It only looks good compared to wmi
01:05:15 <dons> twb, you're funny :-) its like watching flames shoot out left and right ;-)
01:05:17 <opqdonut> if you want more examples, try adobe lightroom, grim fandango and wow on the commercialside
01:05:40 <opqdonut> and lighttpd lua cgi-scripting from open source
01:05:46 <twb> Well, I've only seen grime crash twice in two days ;-)
01:05:47 <fuzan> too bad wow is for stupid people.
01:06:11 <dons> ejt: hey.
01:06:16 <osfameron> Lua sounded interesting as a proof that scripting languages are "better" than C++ etc. for games programming and other low level tasks (as long as the core engine is implemented efficiently)
01:06:18 <dons> i wrote go as a fold to fake a state monad :-)
01:07:04 <twb> lua only makes sense if you've already decided to use a stupid language like C or C++ for the core.  If you use something sensible for the core like Common Lisp or Forth, you get the extension language for free.
01:07:29 * twb has spoken
01:07:30 <opqdonut> twb: forth might be sensible but it's a pain to code
01:07:34 <dons> yeah, if you want a high level language to extend a low level one in, an out of the box extension system is a reasonable choice.
01:07:35 <ejt> dons: have to think about that for a bit ...
01:07:43 <dons> to recode twb's statement in a less inflammatory way ;-)
01:07:45 <osfameron> twb: yes, but if your staff know C and scripting language, then it's a good fit.  Lisp would be lovely, I guess, but not everyone has the mindset or experience
01:07:57 <dons> ejt, I wanted to write:   do a ; b ; c ; d
01:07:59 <fuzan> dons: this look like a vty bug or no? : http://fuzan.org/before.PNG http://fuzan.org/after.PNG
01:08:06 <dons> ejt, with each applied to a threaded stackSet
01:08:17 <dons> hence, foldl [a, b , c, d] s
01:08:18 <dons> :-)
01:08:23 * twb is a sysadmin, and can afford to be principled (sack c/java/php coders!) about programming
01:08:25 <fuzan> it's odd, the last character before spaces propogate down, and only if the text reaches the info bar
01:08:34 <dons> fuzan: hmm, talk to sorear or jyp.
01:08:39 <dons> my involvement in yi now is minimal.
01:08:42 <fuzan> kk
01:08:44 <dons> sorear is the vty author
01:09:20 <twb> As a user for the last three minutes, I think the next feature Yi should get is a stinking big texinfo manual
01:09:28 <dons> hah
01:09:44 <dons> good idea. but it is supposed to be either vim or emacs like. so you should be able to guess ;-)
01:09:46 <ejt> dons: thx
01:10:45 <quicksilver> lua is great, as a 'dynamic extension to C++'
01:10:48 <twb> It certainly seems more emacs-like than it was when I tried it a few years ago
01:10:54 <opqdonut> quicksilver: or c
01:10:55 <quicksilver> or indeed, C programs with an object model
01:11:05 <twb> quicksilver: I'm prepared to concede that point.
01:11:22 <twb> It just seems ludicrous to me that anyone with proper training would use C++ in the first place.
01:11:33 <opqdonut> c++ is a nice language
01:11:36 * twb pokes johnw
01:11:37 <quicksilver> it is also really simple to embed, which is nice for the programmer
01:11:50 <quicksilver> (not that I'm saying there aren't lisps which are simple to embed)
01:12:46 <ejt> dons: have you thought about using a golden spiral to tile the windows in xmonad ?
01:12:55 <opqdonut> simplicity is lua's greatest asset
01:13:05 <shiva> hi babies
01:13:06 <opqdonut> ejt: ugh, sound pretty unusable
01:13:19 <kolmodin> opqdonut: why lua?
01:13:23 <shiva> i am shiva
01:13:25 <quicksilver> actually ejt's idea is pretty cool
01:13:33 <quicksilver> ejt: but use GL scaling
01:13:34 <opqdonut> cool != usable
01:13:41 <quicksilver> ejt: so the outer ones are just compressed
01:13:54 <quicksilver> then, I think, you can get an unbounded number of windows in finite space?
01:13:55 <ejt> I didn't mean anything that fancy
01:14:16 <opqdonut> kolmodin: why not?
01:14:19 <quicksilver> but all of fixed size
01:14:30 <quicksilver> so you add more windows and never decrease the size of your 'main' ones
01:14:33 <quicksilver> could be a cool hack :)
01:14:57 * ejt goes to get the darcs version of xmonad
01:15:04 <kolmodin> opqdonut: good question :)
01:15:11 <twb> Can you :select - in xmonad, or are all windows always displayed?
01:15:28 <dons> ejt: hmm.... sound interesting.
01:15:37 <kolmodin> opqdonut: what I meant is that you must have picked between many languages
01:16:01 <dons> ejt: yeah, you can write  your own layout algos in Config.hs
01:16:07 <opqdonut> kolmodin: basically between perl, python and lua
01:16:15 <dons> and then if its fun , darcs send it as a patch against the contribs repo
01:16:18 <opqdonut> and lua is just so pretty and simple i decided to use it
01:16:31 <dons> i'd like xmonad to be a bit of a platform for tiling algos. they're rather trivial to write.
01:16:39 <kolmodin> opqdonut: ah, ok. I know some python and would probably have picked that just because I know it
01:16:43 <dons> twb: do you mean, are all windows always displayed?
01:16:50 <osfameron> gah!  don't talk to me about lua.  I might have to learn it, and I still have haskell, erlang, C to get through...
01:17:00 <opqdonut> kolmodin: python is overly bloated for this purpose and a pain to embed
01:17:09 <dons> i'm not sure lua offers a lot to be learnt, though, does it?
01:17:17 <kolmodin> opqdonut: ah. bummer. I've always thought that it'd be easy
01:17:23 <dons> other than for how to write a C extension language system.
01:17:24 <opqdonut> and i wanted good text-handling features, like perl has
01:17:28 <twb> dons: yes, that's my question
01:17:31 <osfameron> well, there is that.  I also intend to learn Ruby, but I guess that will take a day or two ;-)
01:17:34 <kolmodin> opqdonut: guess lua more or less is built to build in
01:17:50 <dons> twb, no, since there are virtual workspaces, so windows you don't want are tossed. (secondly) it depends on the layout algorithm in play
01:17:52 <opqdonut> so i decided to go with pcre+lua+c engine
01:18:03 <osfameron> why not pure lua ?
01:18:05 <kolmodin> opqdonut: oh, I've always thought python has excellent text-handling
01:18:08 * twb doesn't understand the point of workspaces
01:18:16 <opqdonut> dons: well, yeah the learning part was quite short
01:18:27 <opqdonut> now i'm trying to make it usable and good
01:18:38 <opqdonut> osfameron: because i like C :)
01:18:52 <fuzan> what is everyone's opinion of objC/
01:18:53 <opqdonut> and curses and memory management are nicer in c than in lua
01:18:55 <twb> Generally I have one window -- emacs.  Sometimes I have another one, such as evince or display(1), which I want to take up either the whole screen, or horizontally split -- usually 1:1 or 2:1
01:18:57 <dons> twb, it depends on the tiling algorithm in use, and no, you don't need to have all windows displayed.
01:19:01 <boegel> anyone from Scandinavia in here?
01:19:05 <opqdonut> boegel: me
01:19:06 <dons> twb, right. sound good.
01:19:12 <kolmodin> boegel: aye
01:19:13 <opqdonut> boegel: or actually finland :P
01:19:16 <dons> twb, you'd switch between fullscreen and vertical tiling mode.
01:19:24 <twb> dons: ah, I see.
01:19:44 <boegel> opqdonut, kolmodin: can you guys joing #haskell-blah, I don't want to spam #haskell with my pointless questions
01:19:48 <twb> In ratpoison, I do :only (fullscreen) or :hsplit [1/3 ]
01:19:55 <boegel> or join even
01:20:02 <dons> yeah, so that's much the same as xmonad.
01:20:05 <osfameron> opqdonut: er.... "memory management" is easier in C than Lua?  (* osfameron faints)
01:20:18 <dons> it has fullscreen, vsplit and hsplit, with custom ratios. (2%3 I like), or (1%2)
01:20:24 <twb> dons: what does xmonad offer that ratpoison doesn't?
01:20:27 <dons> but you can write your own layouts in Config.hs
01:20:36 <dons> its 10x smaller?
01:20:45 <twb> Smaller? It depends on Haskell!
01:20:47 <dons> you can write pure functions in Config.hs to extend it?
01:21:00 <dons> the code base is much smaller.
01:21:08 <twb> True
01:21:08 <dons> so you can hope to understand every line.
01:21:19 <dons> there's quite a few points of differentiation.
01:21:24 <dons> i think xmonad looks nicer.
01:21:25 <twb> That's probably only because it's younger, tho :-)
01:21:37 <dons> hmm, not so sure.
01:21:54 <kolmodin> opqdonut: ok. I've noticed that we're all different :D
01:22:27 <quicksilver> osfameron: presumably only in the sense 'if you need to do manual memory management for some reason'
01:22:27 <dons> twb, try it out. then you can make a detailed comparison
01:22:53 <dons> i'm a ion/wmii/dwm refugee, not ratpoision, so can't offer much more on ratpoison
01:23:06 <fuzan> i likes the wmii.
01:23:11 <twb> I looked at those last week, and they just seemed plain insane
01:23:49 <twb> Using environment variables and string pipes for customization?  Eek.
01:23:49 <dons> they're not.
01:23:59 <dons> oh, that's cute. but probably uneeded.
01:24:09 <dons> means you can script it in any language. good idea
01:24:41 <twb> You can do the same with ratpoison, all it does is look for properties on the root window
01:25:05 <stmartin> Ahh procrastination. The best way to learn Haskell.
01:25:55 <profmakx> stmartin: It`s the laziness that counts.
01:26:36 * stmartin is reminded of a paper my Lecture in Functional told us about today: "Listlessness is better than Laziness".
01:29:27 <aleator> I'm blind. Is there a ready made way of formatting floats for printing in ghc?
01:29:42 <stmartin> Text.Printf
01:30:06 <fuzan> dinounix: sourcemage? i went to school with sandalle :)
01:30:28 <quicksilver> aleator: showEFloat, showFFloat
01:30:53 <quicksilver> :t showEFloat
01:30:56 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
01:31:07 <quicksilver> showEFloat (Just 4) 1.2345467
01:31:09 <dinounix> fuzan: really? nice :)
01:31:20 <aleator> quicksilver: Thanks.
01:31:33 <quicksilver> > showEFloat (Just 4) 1.2345467 "blah"
01:31:35 <lambdabot>  "1.2345e0blah"
01:31:40 <quicksilver> > showEFloat (Just 4) 1.2345467 ""
01:31:42 <lambdabot>  "1.2345e0"
01:31:46 <quicksilver> > showFFloat (Just 4) 1.2345467 ""
01:31:47 <lambdabot>  "1.2345"
01:32:02 <profmakx> me likey
01:34:32 <Cheery> @ho Word8 -> Char
01:34:32 <lambdabot> Maybe you meant: hoogle hoogle+ . bf echo ft ghc id pl rc show v wn yow
01:34:38 <Cheery> @hoogle Word8 -> Char
01:34:39 <lambdabot> No matches, try a more general search
01:34:47 <Cheery> @hoogle+ Word8 -> Char
01:34:59 <kosmikus> dons: is there a channel for yi?
01:35:14 <quicksilver> Cheery: chr . fromIntegral
01:35:26 <quicksilver> Cheery: or toEnum . fromIntegral if you prefer
01:35:50 <quicksilver> kosmikus: personally I think 'yi' is ontopic here until it causes problems
01:36:04 <quicksilver> kosmikus: don't split channels until you have proved there is enough traffice to deserve it IMO
01:36:05 <Cheery> @hoogle chr
01:36:05 <lambdabot> Char.chr :: Int -> Char
01:36:05 <lambdabot> Text.PrettyPrint.HughesPJ.Chr :: Char -> TextDetails
01:36:05 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
01:36:36 <kosmikus> quicksilver: I didn't ask because I wanted to take traffic away, but because I was curious if I'm missing discussions by not being there.
01:37:05 <quicksilver> kosmikus: in that case, I would also like to know the answer :)
01:37:50 * earthy grins
01:40:07 <earthy> okay, that's about the point where I start taking up the gauntlet thrown down by dcoutts...
01:40:33 * earthy murmurs a bit to himself 'wxHaskell isn't all bad'
01:40:57 <kosmikus> did he imply something else?
01:41:08 <osfameron> isn't the main complaint that wxHaskell is more of a building block than a really haskellish solution ?
01:41:56 <dons> i thought it had quite a high level layer?
01:42:02 <dons> kosmikus: no yi channel
01:42:48 <osfameron> I was thinking of wxFruit being built on top of it
01:43:12 <earthy> wxHaskell actually has a higher level of interfacing than gtk2hs does, afaiui
01:43:24 <earthy> it's just woefully undermaintained
01:51:03 <stmartin> What's the way to exit cleanly out of a Haskell program? I notice there doesn't seem to be exit() defined.
01:51:18 <Cheery> what would be the nicest way to make cyclic redundancy check in haskell?
01:51:56 <stmartin> nm. /me just found System.Exit
02:19:47 <ivanm> with lists, what's the difference between concatMap and =<< (in terms of implementation, efficiency, etc) ?
02:20:16 <Saizan> ?src ([]) >>=
02:20:16 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:20:31 <fuzan> ?src (>>=)
02:20:32 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:21:08 <Saizan> ivanm: with >>= you need a typeclass method resolution, so a method dictionary and a lookup in ghc
02:21:54 <ivanm> so concatMap would be slightly faster as it doesn't need to bother checking if its a list?
02:21:57 <Cheery> is there a shorthand notation for something like: a . a . a . a . a   ?
02:21:59 <ivanm> it _has_ to be a list?
02:22:05 <ivanm> Cheery: iterate?
02:22:10 <Cheery> thanks
02:22:20 <ivanm> > take 10 . iterate succ $ 1
02:22:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:22:40 <Cheery> or wait, that's not what I'm looking for
02:22:48 <ivanm> > last . take 10 . iterate succ $ 1
02:22:50 <lambdabot>  10
02:22:54 <ivanm> ^^
02:23:07 <Jaak> > (iterate succ 1) !! 100
02:23:08 <lambdabot>  101
02:23:12 <ivanm> that's what you're after, isn't it?
02:23:18 <ivanm> or you could just do that :s
02:23:23 * ivanm forgot about list indexing
02:24:08 <Cheery> @type iterate
02:24:11 <lambdabot> forall a. (a -> a) -> a -> [a]
02:24:26 <ivanm> @hoogle (a -> a) -> a -> [a]
02:24:27 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
02:24:27 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
02:24:27 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
02:24:42 <ivanm> looks like iterate is it... just do what Jaak did
02:24:50 <Cheery> @type (.)
02:24:52 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:25:20 <Saizan> ?type \a arg -> replicate 5 a `sequence` arg
02:25:22 <lambdabot>     Ambiguous occurrence `sequence'
02:25:22 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
02:25:29 <dons> sorry
02:25:29 <Saizan> ?type \a arg -> replicate 5 a `Prelude.sequence` arg
02:25:31 <lambdabot> forall t a. (Monad ((->) t)) => (t -> a) -> t -> [a]
02:25:32 <Cheery> @type replicate
02:25:34 <lambdabot> forall a. Int -> a -> [a]
02:25:38 <dons> ?pl  \a arg -> replicate 5 a `Prelude.sequence` arg
02:25:39 <lambdabot> (line 1, column 25):
02:25:39 <lambdabot> unexpected "`"
02:25:39 <lambdabot> expecting variable, "(", operator or end of input
02:25:45 <dons> ?pl  \a arg -> replicate 5 a `sequence` arg
02:25:46 <lambdabot> sequence . replicate 5
02:26:06 <dons> ?hoogle replicateM
02:26:07 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
02:26:07 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
02:26:19 <matthew-_> @seen sjanssen
02:26:19 <lambdabot> sjanssen is in #haskell-overflow, #ghc, #gentoo-haskell, #xmonad and #haskell. I don't know when sjanssen last spoke.
02:27:12 <ivanm> back to what I asked above:  in general, for lists, is concatMap better than bind?
02:31:31 <osfameron> seen Apocalisp?
02:31:36 <osfameron> @seen Apocalisp?
02:31:36 <lambdabot> I haven't seen Apocalisp?.
02:31:40 <osfameron> stupid bot
02:32:16 <int-e> ivanm: it's a matter of taste I think - >>= is shorter but harder to understand (until you've got used to it)
02:32:53 <ivanm> *nod*
02:32:59 <matthew-_> oh, whoops, int-e, it was you I was looking for! /me must remember mapping between irc and email better...
02:33:35 <kaol> @src (=<<)
02:33:35 <lambdabot> f =<< x = x >>= f
02:33:48 <int-e> matthew-_: oh. my nick doesn't make that particularily easy though.
02:33:58 <kaol> wow. it's a palindrome
02:34:22 <matthew-_> int-e: I think you're right, but I also think it should work with synonynms
02:35:00 <matthew-_> int-e: because you should be able to determine the current type, apply any synonynms to it and work out which instance it came from. I think
02:36:00 <int-e> matthew-_: for type synonyms, you can assign the same type multiple times though.
02:36:05 <matthew-_> oh!
02:36:16 <int-e> matthew-_: which in an open type system means you can't do a reverse mapping.
02:36:23 <matthew-_> absolutely
02:37:00 <matthew-_> that rather ruins the idea that associated types replace fundeps though? Or is this just the same problem as with open classes
02:37:01 <matthew-_> ?
02:38:04 <matthew-_> so in fact, the reverse mapping is guaranteed by the fact that you must have unique constructors on the data type.
02:38:26 <int-e> matthew-_: well, they do replace one-way fundeps.  Foo a b | a -> b  can be expressed with Foo a where type B a :: *
02:38:44 <ivanm> so where is List defined as a monad?  /me can't find it in the docs
02:39:55 <int-e> matthew-_: if I understand the meaning of  data B a :: *  correctly, yes.
02:40:50 <stmartin> Is it my imagination, or does the Haskell report make no mention of how to catch errors?
02:41:22 <matthew-_> stmartin: I don't know, but errors are covered in "tackling the awkward squad"
02:42:30 <matthew-_> int-e: the reverse mapping's an interesting properly - one that you can't do with normal functional dependencies?
02:42:55 <Cheery> @hoogle Int -> (a -> a) -> (a -> a)
02:42:56 <lambdabot> No matches, try a more general search
02:43:01 <Cheery> @hoogle (a -> a) -> (a -> a)
02:43:01 <lambdabot> No matches, try a more general search
02:43:05 <int-e> @type catch
02:43:08 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
02:43:25 <matthew-_> not without class F a b | a -> b, b -> a;  but the indexed type doesn't demand the b -> a
02:43:53 <ivanm> @hoogle (a -> b) -> (b -> c)
02:43:54 <lambdabot> No matches, try a more general search
02:44:01 <ivanm> @hoogle (a -> b) -> (c -> d)
02:44:01 <lambdabot> No matches, try a more general search
02:44:10 <ivanm> well, that's as general as I can think of...
02:44:34 <int-e> matthew-_: well, Foo a b | a -> b, b -> a  is supposed to express that, but as we've seen a few days ago it doesn't really work.
02:44:54 <qwr> @hoogle a -
02:44:54 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-'
02:45:02 <qwr> @hoogle a -> (b -> c) -> d
02:45:03 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
02:45:03 <lambdabot> Control.Parallel.Strategies.(-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
02:45:03 <lambdabot> Control.Parallel.Strategies.(-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
02:45:10 <int-e> matthew-_: as you just wrote. yep.
02:48:54 <int-e> stmartin: section 7.3 of the haskell report specifies catch - but that only works for IO errors. The Control.Exception stuff isn't specified by Haskell 98.
02:49:30 <stmartin> Thanks. I've just looked at that. Seems to do the trick. Easy to forget how long ago '98 was.
02:50:23 <stmartin> Actually, its not catching the error thrown by  read()  when I pass in a non-number. Any ideas?
02:51:03 <stmartin> catch (dec_to_roman s) (\e -> hPutStr stderr $ show e)      -- read is called within doc_to_roman
02:51:32 <stmartin> Oh. I think perhaps I might need evaluate
02:53:48 <int-e> > (reads :: ReadS Int) "1421"
02:53:48 <lambdabot>  [(1421,"")]
02:53:49 <int-e> or you can do it with pure code and reads.
02:54:04 <stmartin> The version in Control.Exception does work better (just had to hide the Prelude version)
02:54:13 <haskellnew> is there any api for calculating sha hash
02:55:11 <Lemmih> haskellnew: Not in the standard libraries.
02:55:22 <dons> system $ "sha1 file.txt" -- ?
02:56:00 <Lemmih> haskellnew: There are several implementations available. Some written in Haskell, some using a C implementation.
02:56:15 <dons> in the crypto lib?
02:56:34 <haskellnew> Lemmih: ok , where do i find these crypto lib
02:56:49 <dons> on hackage, iirc.
02:56:53 <dons> ?hackage crypto
02:56:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/crypto
02:57:05 <dons> nope.
02:57:14 <dons> let me see..
02:57:24 <dons> Crypto.
02:57:29 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto-3.0.3
02:57:32 <lambdabot> http://tinyurl.com/2z4ujp
02:57:40 <dons> Data.Digest.SHA1 module
02:59:21 <quicksilver> Saizan: I don't believe ghc generates dictionary lookups when the type is statically known
02:59:55 * Lemmih prefers the minimal C implementations with a nice 'ByteString -> ByteString' interface.
03:00:02 <gleb> quicksilver: why are monad transformers slow then?
03:01:16 <quicksilver> gleb: I didn't think they were :P
03:01:26 <haskellnew> dons : Lemmih  , thanks i will download it  ,   bye
03:01:42 <quicksilver> gleb: but I can hypothesise that monad transformers make it easy to write code which is polymorphic, so dictionaries are required
03:02:15 <dons> they don't have to be slow
03:02:32 <dons> we use monad transformers in Data.Binary, which are massively inlined and optimised
03:02:43 <dons> (i think mtl could do with some INLINE aggression, in fact)
03:02:51 <quicksilver> dons: have you experienced code which turns out to be slow, with the bottleneck being dictionary lookup?
03:03:33 <dons> yeah, which then required inline pragmas to encourage the compiler a bit.
03:03:36 * quicksilver nods
03:03:45 <dons> not terribly common, one or two cases over serveral years
03:03:50 <quicksilver> ghc can't do cross-module specialisation, can it?
03:03:57 <quicksilver> specialisation over type class, not over constructor, I mean
03:04:00 <dons> it does, but not as agressively as within a module
03:04:04 <quicksilver> ah, interesting
03:04:07 <dons> and generally not without INLINE pragmas to push it
03:04:15 <quicksilver> can it specialise functions (as distinct from methods) ?
03:04:24 <dons> hmm, yes, pretty sure it can.
03:04:29 <dons> (i'd have to double check)
03:04:32 * quicksilver ndos
03:05:04 <dons> the monad stuff in Data.Binary is entirely inlined and specialised, fwiw
03:05:12 <dons> (leading to slow compile times for users of Data.Binary and -O2 !)
03:05:19 <dons> but in the end you end up with straight line Addr# code
03:05:31 <dons> although you start with get/put monoid/monad code.
03:06:09 * quicksilver nods
03:06:11 <quicksilver> nice
03:06:51 <dons> we use this guy,
03:06:52 <dons> instance Monad Get where
03:06:52 <dons>     return a  = Get (\s -> (a, s))
03:06:52 <dons>     m >>= k   = Get (\s -> let (a, s') = unGet m s
03:06:52 <dons>                            in unGet (k a) s')
03:06:54 <dons>     fail      = failDesc
03:06:57 <dons> specialised on
03:07:00 <dons> data S = S {-# UNPACK #-} !B.ByteString  -- current chunk
03:07:00 <dons>            L.ByteString                  -- the rest of the input
03:07:00 <dons>            {-# UNPACK #-} !Int64
03:07:14 <dons> and ghc happily inlines away all dictionaries, and all monads , and just about everything.
03:07:24 <dons> but it did require careful placement of INLINE pragmas
03:08:00 <dons> (all primitive read/write ops are inlined, for example:
03:08:01 <dons> getWord16be :: Get Word16
03:08:01 <dons> getWord16be = do
03:08:01 <dons>     s <- readN 2 id
03:08:01 <dons>     return $! (fromIntegral (s `B.index` 0) `shiftl_w16` 8) .|.
03:08:04 <dons>               (fromIntegral (s `B.index` 1))
03:08:06 <dons> {-# INLINE getWord16be #-}
03:08:23 <osfameron> optimizing haskell must be interesting (for the appropriate values of interesting)
03:08:33 <quicksilver> dons: so, in a sense, INLINE also means 'specialise'?
03:08:38 <quicksilver> dons: the one triggers the other?
03:08:42 <quicksilver> inline-and-specialise
03:08:46 <dons> yeah
03:08:59 <dons> osfameron: it is fun, you get to do some really high level thinking, to get low level performance
03:09:11 <dons> things like Data.Binary's new rewrite rules on applicative functors (!)
03:09:20 <dons> which lift and combine bounds checks
03:09:34 <dons> so that inner loops are entirely unchecked memory writes
03:09:57 <dons> that kind of fun you don't get with C, because you just don't know the things about the code we have in haskell: purity, and precise type information
03:10:12 <dons> purity enables all sorts of cool agressive optimisations
03:10:19 <stmartin> I'm trying to make a wrapper for read that catches any possible exception and rethrows it (with a nicer error message).
03:10:22 <stmartin> read' s = catch (read s) (error "Not a number")
03:10:32 <stmartin> But the type checker is complaining...
03:10:35 <osfameron> that's kind of what I was wondering (though I don't have the CS background to get all of that), but it kind of seems like there's lots of scope for cleverness and fun
03:10:54 <gleb> dons: i'm stupid. It seems to me that Get monad identical to State monad. Why duplicate? Is it necessary for inlining?
03:11:06 <dons> gleb: yes, in this case.
03:11:20 <dons> the missing INLINE pragmas in mtl meant that ghc wouldn't specialise/optimise across the package boundar
03:11:36 <dons> we could go back into mtl, and add the necessary tweaks we did in binary, but it was easier to just modify that code
03:12:11 <dons> also means we don't have to worry about preserving unspecified laziness behaviour in State.
03:13:12 <quicksilver> I still have this nagging suspicion that haskell is just begging for whole-program compilation
03:13:31 <dons> that's what jhc sez too :-)
03:13:35 <dons> and i'd agree, actually
03:13:37 * earthy nods
03:13:43 <quicksilver> I remember convincing myself 10 years ago that for a language to have powerful abstractions and be really fast, it essentially needs whole-program compilation
03:13:47 <dons> heavy inlining is turning into whole-program optimisation by stealth
03:13:54 <quicksilver> but in principle there is a 'middle way'
03:14:05 <quicksilver> separate compilation to some kind of 'intermediate form'
03:14:07 <earthy> if one looks at e.g. Clean, and the results the Clean team get
03:14:08 <dons> inline pragmas in Data.Binary basically inline the entire library into a user's code, which then gets optimise as if it was just one module.
03:14:11 <quicksilver> and then whole-program optimisation
03:14:31 <earthy> they don't really do whole-program optimisation, but they *do* assume a closed world, which makes a lot of optimizations a whole lot easier
03:14:33 <dons> yeah, the improved native code gen should tell us how much the clean advantage is just in the code gen.
03:14:37 <osfameron> is whole-program compliation in constrast with incremental compilation ?
03:14:54 <quicksilver> of course ghc's .hi files, in the presence of INLINE pragmas, are in fact a simple version of the 'intermediate form' I'm talking about
03:15:01 <quicksilver> osfameron: as opposed to one-file at a time
03:15:14 <quicksilver> osfameron: if you just change Foo.hs, you don't need to recompile Lib/Bar.hs, currently
03:15:17 <dons> yeah, inline pushes .hi files more towards the whole program end of the scale
03:15:19 <osfameron> ah, right, rather than linking them together as separate units
03:15:40 * dons wonders what ghc would do with INLINE on everything in base/mtl, and a users's program...
03:15:48 <dons> churn for a few days, i'd imagine
03:15:59 <osfameron> presumably as a last step before release rather than a compilation option you'd use every time ?
03:16:09 <dons> certainly.
03:16:31 <dons> Data.Binary as is, is a bit scary to use with -O2, due to compile times
03:25:32 <quicksilver> I really can't believe that people in this editor thread are suggesting the mouse is always faster than the keyboard
03:25:37 <quicksilver> quite boggling
03:25:56 <dons> hey andygill
03:25:57 <quicksilver> you can point me to any number of pieces of bogus research done on computer users who are in every way unlike me, but it won't help
03:26:06 <quicksilver> I *know* it's faster for me to use keys
03:26:15 <andygill> Hi Dons
03:26:29 <dons> i don't have a mouse, so hard to tell, quicksilver  ;-)
03:26:57 <dons> but it seems to me that key bindings are O(1) lookup, while moving the mouse isn't.
03:27:21 <quicksilver> dons: key bindings are O(something hard to calculate about the human memory)
03:27:26 <dons> yeah
03:27:31 <dons> which looks like O(1) to me :)
03:27:37 <quicksilver> dons: but I believe it tends to O(1) for experienced users with keybindings they are familiar with
03:28:05 <dons> ah right. yes, non-experienced users don't have O(1).
03:28:05 <osfameron> which editor thread is this?
03:28:26 <gleb> quicksilver: I will bet money that C-x C-f foo TAB bar is faster than File->Open - click * n -> OK
03:28:39 <profmakx> non-experienced users often have a high learning-resistance too
03:28:46 <quicksilver> osfameron: haskell-cafe
03:28:52 <osfameron> moving a mouse is easier to learn but deleting 4 lines and pasting them at the end of the next function definition is much much faster in vim than with a mouse
03:29:15 <quicksilver> gleb: yes although I believe that's not really the comparison they are discussing, per se
03:29:43 <quicksilver> gleb: more analagous would be to compare File->Open - click* - OK with Alt-F, O, <first part of name>, ENTER
03:31:32 <DRMacIver> Arguably that's still faster. :)
03:31:58 <DRMacIver> A lot of things which aren't designed for it are still faster with the keyboard. e.g. web browsing (or at least a core subset thereof)
03:33:09 <quicksilver> DRMacIver: I wasn't saying it wasn't faster. It is for me
03:33:16 <quicksilver> DRMacIver: I was just saying that was a 'fairer' comparison
03:35:51 <ndm> having keyboard AND gui means you can learn GUI (fast to learn) then for the small "5% of things you spend 95% of the time doing" you can learn keyboard shortcuts as well
03:35:52 <DRMacIver> True
03:36:09 <quicksilver> ndm: absolutely
03:36:13 <DRMacIver> ndm: Sure.
03:36:20 <quicksilver> ndm: and all the editors I use have both, certainly
03:36:44 <ndm> indeed, mine too - i wouldn't consider one that didn't support both like they were meant to be
03:36:54 <quicksilver> I'm interested that all the HCI advances the OP seems to be interested in are the input ones
03:36:58 <quicksilver> I don't find them very interesting
03:37:03 <quicksilver> I find my input devices work well
03:37:15 <quicksilver> the HCI advances I find exciting are the output ones: interactive feedback
03:37:24 <quicksilver> hints/clues/suggestions
03:37:33 <quicksilver> (stuff like 'the type expected at the cursor location is:')
03:38:02 <quicksilver> or intruiging ways to shade ares of the code to indicate dependencies
03:38:05 <quicksilver> or nesting
03:38:06 <quicksilver> etc etc
03:40:32 <ejt> anyone here going to the London HUG meeting tomorrow night ?
03:40:57 <ToRA> ejt: yup
03:41:45 <kaol> @seen shapr
03:41:45 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 12h 5m 16s ago.
03:42:58 <kaol> shapr: http://haskelldb.sourceforge.net/getting-started.html links to your site, but the URL is 404. Do you know anything about that?
03:42:59 <lambdabot> Title: HaskellDB - Getting Started
03:44:34 <Lemmih> @oldwiki HaskellDbTutorial
03:44:35 <lambdabot> http://www.haskell.org/hawiki/HaskellDbTutorial
03:45:36 <kaol> oh, it's just that page?
03:46:19 <Lemmih> I believe so.
03:47:47 <Lemmih> The "New Tutorial" was written by yours truly.
03:51:16 <dblhelix> igloo
03:51:22 <dblhelix> @seen igloo
03:51:23 <lambdabot> igloo is in #haskell, #ghc, #gentoo-haskell and #darcs. I last heard igloo speak 9h 15m 7s ago.
03:53:07 <Cheery> @hoogle even
03:53:08 <lambdabot> Prelude.even :: Integral a => a -> Bool
03:53:08 <lambdabot> GHC.ConsoleHandler.ConsoleEvent :: data ConsoleEvent
03:53:08 <lambdabot> System.Console.Readline.setEventHook :: Maybe (IO ()) -> IO ()
03:53:36 <kaol> I must say that I'm a bit suspicious of hdbc. I'm just too used to writing SQL queries myself. Can everything be expressed the hdbc way too? Does it pass the queries to the DB and let their query optimizer do their work?
03:54:31 <Lemmih> kaol: hdbc is not HaskellDB.
03:54:42 <kaol> oh. um.
03:54:57 * kaol sighs
03:55:01 <osfameron> the thing with database wrappers is that if you don't use one you end up rewriting one 100 times anyway
03:55:16 <osfameron> so it kind of makes sense to use one, as long as you have access to the raw SQL when you really need it
03:55:33 <Lemmih> kaol: I agree that HaskellDB has issues. I don't recommend using it unless you're completely familiar with all its limitations.
03:56:04 <kaol> well, my question still applies if you s/hsql/haskellDB/. even if I feel a bit embarassed now.
03:56:32 <kaol> argh. hsql != hdbc, either.
03:59:32 <quicksilver> osfameron: if you like SQL then what you *REALLY* want is somethign which allows you to write SQL, but actually parses the SQL at compile time and generates the correct types
03:59:52 <quicksilver> osfameron: most of the mini-languages around it are to circumvent the fact that that is quite hard
04:00:02 <quicksilver> osfameron: i.e. to provide some kind of 'type' information to the host language
04:00:25 <osfameron> quicksilver: oh, I'm not so much bothered about it being hard.  It's the "I want this clause, that clause and the other clause, now stick them together" bit that gets me writing a wrapper every time
04:01:16 <quicksilver> osfameron: I didn't mean SQL is hard
04:01:26 <quicksilver> osfameron: I meant, inferring a type discipline on SQL is hard
04:01:38 <quicksilver> osfameron: hence all the metadata all the various SQL interfaces require you to enter
04:01:47 <osfameron> oh, that.  I guess, er... as a Perl programmer I never really worried about type discipline all that much ;-)
04:02:09 <osfameron> and there's no metadata to enter there either
04:02:12 <quicksilver> osfameron: that's funny; as a perl programmer I use DBIx::Class precisely because it gives me some kind of type discipline
04:02:33 <quicksilver> osfameron: in the sense that, it know which columns a relation has, and it knows which relations can be sensibly joined to which others
04:02:48 <osfameron> right
04:03:29 <quicksilver> as a haskell programmer, though, I'd love to be able to write "SELECT foo,bar FROM x JOIN y" and have it know at compile time that the type of that was [(Foo,Bar)]
04:03:43 <quicksilver> (but this implies it needs schema access at compile time)
04:04:07 <osfameron> well, you could have a scaffolding module that knows the schema
04:05:01 <Cheery> how would I turn Word8 to Word32?
04:05:44 <Lemmih> Cheery: fromIntegral.
04:06:09 <quicksilver> osfameron: yup; that counts as 'schema access at compile time'
04:06:23 <osfameron> quicksilver: yep
04:06:24 <Cheery> > fromIntegral (2::Word8) :: Word32
04:06:26 <lambdabot>  2
04:06:29 <quicksilver> osfameron: there's still the whole "compile time SQL parsing' part, too
04:06:32 <Cheery> Lemmih: thanks
04:07:13 <osfameron> quicksilver: meh.  Sometimes dynamic is just easier :D
04:07:16 <osfameron> anyway, lunch
04:07:21 <quicksilver> osfameron: certainly
04:07:26 <quicksilver> osfameron: easier != better though :)
04:12:03 <ndm> what are the limitations of DrIFT?
04:12:06 <ndm> i.e. what can't it do?
04:12:11 <ndm> can it work with literate haskell?
04:12:16 <ndm> does it burn on certain extensions?
04:14:46 <Svrog> why am i getting "undefined reference to `__stginit_ZCMain`'" if im compiling a program with -no-hs-main and a custom main function written in c?
04:15:54 <ndm> Svrog: which GHC?
04:15:57 <ndm> ghc --version
04:16:03 <Svrog> 6.6.1 under windows xp
04:16:10 <ndm> no need for -no-hs-main
04:16:15 <ndm> and in fact that may be breaking it
04:16:20 <Svrog> under os x the same program compiles correctly
04:16:20 <ndm> ghc file.c works fine for me
04:16:28 <ndm> thats 6.6.1 on XP
04:16:29 <Svrog> hmm
04:16:32 <Svrog> ok ill try that
04:16:58 <Cheery> does Data.Binary recognize somehow between big and little endian?
04:17:07 <Cheery> if not, which one does it use for default?
04:17:19 <Svrog> nope - even without -no-hs-main i get the same error
04:17:19 <quicksilver> Cheery: if you use the high-level stuff, it writes in network byte-order by default
04:17:36 <quicksilver> Cheery: to produce stuff which can safely be sent across the wire and/or exchanged as disk files
04:17:36 <ndm> Svrog: works fine for me
04:17:59 <Svrog> hmm
04:18:10 <kolmodin> (big endan)
04:18:19 <ndm> Svrog: can you hpaste your code?
04:18:20 <ndm> @hpaste
04:18:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:18:49 <Svrog> yup - i was just thinking that
04:19:47 <Cheery> quicksilver: it seems PNG is using the same, ok, I think this will be enjoyable
04:21:21 <ndm> is the hpaste website down?
04:21:44 <kolmodin> ndm: seems that way
04:21:47 <quicksilver> ndm: yes, has been all day
04:21:53 <ndm> :(
04:27:22 <Svrog> hmm.. ok problem doesn't happen when i use main, only when i use WinMain and passing -optl -mwindows doesn't help
04:35:26 <ndm> yeah, you'll need to link some libraries
04:35:28 <ndm> win32
04:35:39 <ndm> and a few others, can't remember which
04:37:12 <dcoutts> dons: optimising mtl code would be an interesting project, take a stack of n monad transformers and optimise the data representation and >>= functions
04:37:26 <ndm> dcoutts, my optimiser will do that automatically
04:38:45 <dcoutts> ndm: I'm looking forward to seeing it
04:41:15 <quicksilver> ndm: whole-program compilation?
04:41:34 <Cheery> how should I handle the error handling when I'm decoding/encoding with Data.Binary?
04:41:52 <Cheery> say, the signature of file is wrong or cyclic redundancy test fails
04:42:35 <Cheery> or that my decoder can't simply decode the file
04:43:31 <Cheery> so, how should I do that?
04:46:54 <Svrog> hmm.. it seems i dont need a WinMain - main + -mwindows appears to work
04:47:19 <Svrog> i dont think that used to work
04:47:51 <Svrog> i dont even get a command prompt window and the app appears to run correctly
04:52:28 <dcoutts> Cheery: currently it'll just throw an error
04:55:07 <Cheery> I don't know whether that's appropriate, I mean somebody may want to know whether there's errors in the file, others may want to do some sort of data recovery
04:55:13 <njbartlett> Any London HUGgers online? I need to ask a favour
04:56:17 <quicksilver> Cheery: then you can catch the error :)
04:56:23 <njbartlett> I was planning to record Simon PJ's talk tomorrow but my camcorder has died. Wondering if anybody can help out
05:00:20 <dcoutts> toxic: you're the guy looking at ByteStrings for HTTP right?
05:00:59 <Cheery> dcoutts: is there ByteStrings for just IP?
05:01:18 <Cheery> and TCP+UDP
05:01:19 <dcoutts> Cheery: huh? for IP? Not sure what you mean.
05:01:50 <Cheery> well, for socket stuff
05:01:58 <dcoutts> the ByteString lib provides a low level way of building ByteStrings from memory chunks so you can connect it to any API like that
05:02:34 <Cheery> ok
05:03:44 <dcoutts> Cheery: the existing ByteString IO api is for Handles, and you can do networking in terms of Handles
05:04:48 <Baughn> Is it possible to block signals from other threads until after I've finished a critical section? (So I don't leak memory)
05:05:16 <dcoutts> Baughn: yes, though I don't recall how
05:05:18 <Baughn> I'm thinking of throwTo in particular
05:05:18 <opqdonut> well you can't block all signals :)
05:05:51 <Baughn> dcoutts: Oh. I found it - Control.Exception.block
05:10:05 <quicksilver> opqdonut: I imagine he means dynamic exceptions, rather than posix signals
05:10:32 <opqdonut> yeah, figured
05:11:31 <Baughn> If someone starts kill()ing my program, they /deserve/ a memory leak.
05:11:52 <Cheery> um.. maybe only in windows
05:12:09 <opqdonut> ^_^
05:12:19 <opqdonut> yeah in *nix memoryis freed
05:12:27 <quicksilver> opqdonut: not necessarily :P
05:12:29 <opqdonut> but for example sockets take some time to get cleaned
05:12:48 <opqdonut> quicksilver: well yeah, tmpfs, shm and other exceptions
05:12:50 <toxic> dcoutts: yes
05:12:56 <quicksilver> opqdonut: *nod*
05:13:03 <Baughn> Actually, I'd like to know how posix signals would affect it. Do they get converted into dynamic exceptions? Abort FFI code? Do anything other than just resuming execution where it was?
05:13:09 <dcoutts> toxic: I don't quite understand the lazy bytestring handle closing problem
05:13:16 <Baughn> opqdonut: Very good reasons for that
05:13:31 <toxic> well
05:13:34 <opqdonut> Baughn: of course
05:13:42 <dcoutts> toxic: presumably we only get EOF on the Handle if the other end closes the socket, no?
05:13:59 <toxic> when using lazy bytestrings we represent the http body as a lazy bytestring that isn't completely downloaded when the control leaves the http lib
05:14:17 <toxic> like our UA.getContent, it returns the lazy bytestring of the not yet downloaded http body
05:14:49 <toxic> in the getContent case the socket never closes
05:14:55 <dcoutts> toxic: ah, so when it gets closed depends on when the user consumes the input
05:15:00 <quicksilver> Baughn: they have their default effect
05:15:01 <dcoutts> toxic: right, but that was just a bug
05:15:07 <quicksilver> Baughn: so most of them kill the process
05:15:11 <quicksilver> Baughn: unless explicitly caught
05:15:15 <toxic> dcoutts: i dont think a lazy bytestring closes the handle when it reaches eof yet
05:15:17 <quicksilver> Baughn: (well, FSOV 'most')
05:15:29 <dcoutts> toxic: yes, but it should, I've already patched that
05:15:32 <toxic> but i'm not sure, haven't read the implementation that carefully yet
05:15:36 <toxic> ah, nice
05:16:24 <dcoutts> toxic: so how does a socket get re-used for multiple http transfers?
05:16:36 <dcoutts> toxic: presumably you ask the server to keep the other end open
05:17:05 <Baughn> Assuming I take care to avoid inlining, does using unsafePerformIO ever cause code to be executed more times than it would if I stuck it in IO?
05:17:14 <fasta> I have a derived state monad. I also have some ST actions. How can I combine the two actions in one do block? I tried do lift(derivedaction);lift(newSTRef "A);return (), but that isn't the way to do it apparently.
05:17:19 <toxic> haven't implemented any reusing yet with lazy bytestrings
05:17:23 <Baughn> dcoutts: Yep. Connection: Keep-Alive
05:17:33 <dcoutts> toxic: which btw, would mean that hGetContents would not stop when it got to the end of the file
05:17:41 <toxic> somehow the rspBody of the respons should stop giving away data when it reaches its end, and then not close
05:17:57 <dcoutts> toxic: you'd have to detect the end of the input yourself
05:18:01 <toxic> yes
05:18:05 <fasta> In fact the monad is a newtype of State.
05:18:50 <quicksilver> Baughn: haskell thunks are not reduced more than once
05:18:52 <dcoutts> toxic: btw, if you really do not want to use Handles, you can do a lazy get contents on a socket, you just have to implement it yourself
05:19:05 <quicksilver> Baughn: but, haskell functions with parameters are re-reduced each time they get a fresh parameter
05:19:15 <toxic> exactly, that shouldn't be a part of a http library to implement lowlevel bytestring socket handeling
05:19:19 <toxic> -e
05:19:22 <quicksilver> Baughn: those two rules should tell you how many times your unsafe will get performed
05:19:53 <dcoutts> toxic: aye, I suppose so, but we were not planning on adding that to the bytestring lib
05:20:18 <toxic> hmm, btw, the body is not taken directly from the handle, its downloaded as chunks and merged, hmm
05:20:46 <toxic> so maybe there is no need to "notice" when a new respons is there when reusing
05:20:53 <Baughn> quicksilver: Does this mean that "foo x y = ..." is not actually equivalent to "foo x = \y -> ..." (for less trivial function bodies)?
05:21:08 <quicksilver> Baughn: no
05:21:09 <toxic> dcoutts: maybe some other level then, because it's not a http specific issue
05:21:17 <dcoutts> sure
05:21:29 <Baughn> quicksilver: I mean, if the second foo does something with x that is then used inside the \y ?
05:21:31 <dcoutts> toxic: and you really have to use sockets because you need that level of control?
05:21:34 <quicksilver> Baughn: in the terminology I was using, a lambda form is still a 'function with parameters'
05:21:46 <toxic> no
05:21:57 <quicksilver> Baughn: oh, yes
05:21:58 <toxic> you can set the flags before doing socketToHandle
05:22:05 <quicksilver> Baughn: if the second form does something with the x
05:22:09 <quicksilver> Baughn: (e.g. a let expression)
05:22:32 <quicksilver> Baughn: then that let expression is shared between successive invovations of the '\y->' part returned
05:22:36 <quicksilver> Baughn: if you see what I mean
05:22:59 <Baughn> quicksilver: I do. Good to know, even if it means my code will have to be de-elgantified.
05:24:48 <dcoutts> toxic: well, good luck with your project, I think having a Haskell HTTP lib is rather better than a curl binding.
05:24:50 <fasta> http://pastebin.ca/502216
05:24:53 <osfameron> quicksilver: easier `can_be` better, under some circumstances :-)
05:24:58 <quicksilver> osfameron: hell yes
05:25:08 <dcoutts> toxic: you know where to find me if you have ByteString Qs
05:25:13 <fasta> I slightly oversimplified in my original question. This is the correct one.
05:25:26 <toxic> dcoutts: thanks, i guess we will have more time after the exams ;)
05:25:35 <toxic> and there even is nominolo
05:25:44 <nominolo> heya toxic
05:26:02 * dcoutts sends good luck to the chalmers students about to do exams
05:26:02 <nominolo> ?where logs
05:26:03 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
05:26:29 <nominolo> thanks a lot.
05:26:40 <Baughn> toxic: Assuming the target site works correctly, would it be safe for me to unsafePerformIO a http get?
05:26:46 <ToRA> fasta: can you paste a bit more context? - types of new_ref and what you think combine_ST_and_M should be?
05:27:14 <fasta> ToRA: ok, one minute
05:27:15 <Saizan> also, M is an instance of MonadTrans?
05:27:26 <dcoutts> Baughn: I would really really recommend against doing that. :-)
05:27:49 <Baughn> dcoutts: GET is supposed to be idempotent, though. :'(
05:28:22 <dcoutts> Baughn: at a very high level, that's true
05:28:49 <mux> pigs will fly the day where every web developer knows to use POST when the request ends up doing non-idempotent things
05:28:56 <mux> it's faaar beyond their grasp
05:29:12 <mux> consider most of these guys use php :-)
05:29:19 <Baughn> dcoutts: So a sufficiently high-level haskell library should be able to have a non-IO GET function
05:29:37 <quicksilver> GET isn't idempotent; it serves adverts and makes log entries and stores cookies on your computer
05:29:44 <fasta> ToRA: http://pastebin.ca/502222
05:29:58 <mux> quicksilver: it should be wrt to the web site, not wrt to your own computer
05:30:08 <toxic> Baughn: if the target site works incorrectly you get a parse error thrown
05:30:08 <mux> the point is to avoid spurious page reloads for dangerous things
05:30:14 <mux> like database inserts and so on.
05:30:27 <quicksilver> mux: yes, I understand this :)
05:30:38 <nominolo> Baughn: that requires a veery reliable server on the other end
05:30:45 <quicksilver> mux: however it does insert new log entries (presumably) on the server at the other end
05:30:50 <ski_> fasta :t new_ref ?
05:30:54 <quicksilver> mux: and in principle cost money (bandwidth isn't free) :)
05:31:03 <Baughn> nominolo: The getter could.. retry until it works? Or return an error instead of throwing on?
05:31:06 <Baughn> *one
05:31:38 <Baughn> I'm taking the latter approach with libpng, but at least that one's /reliable/.
05:31:41 <quicksilver> I *quite* like the notion of an ideal HTTP library with a non-IO interface to GET
05:31:41 <fasta> http://pastebin.ca/502224
05:31:47 <quicksilver> but I don't think it would be reliable :)
05:31:49 <fasta> ski_: that's just newSTRef
05:32:05 <mux> quicksilver: yeah, bt there isn't much sense in interpreting the idempotency as anything but with respect to the served website/web application :-)
05:32:18 <Saizan> ?type lift
05:32:23 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:32:32 <Baughn> quicksilver: It could have an IO interface for those who want that, and convert exceptions into error codes (or not!) for those who just want convenience
05:32:36 <fasta> Ok, so it needs to be an instance of MonadTrans.
05:33:00 <Saizan> fasta: also, you need different level of lifting for different inner monads
05:33:12 <fasta> Since it's an instance of MonadState it should also be an instance of MonadTrans?
05:33:21 <ski_> fasta : then 'new_ref "A"' is an action in the 'ST s' monad, while 'fooM undefined' is an action in the 'M a s' monad
05:33:41 <Saizan> fasta: no, State for example is not an instance of MonadTrans
05:33:50 <osfameron> Saizan: LPhas was looking for you earlier
05:34:04 <ski_> fasta : also 'instance (Monad (State (M a s))) => Monad (M a s)' looks strange
05:34:44 <ToRA> (using GeneralizedNewtypeDeriving) newtype Splat = Splat StateT (ST s) a (deriving Monad, MonadState), and then a custom new_ref fn needs writing?
05:35:03 <ToRA> mmm, that's very wrong
05:35:04 <ToRA> 1 sec
05:36:08 <quicksilver> cale's article on how to use monad transformers sanely is worth a read
05:36:30 <quicksilver> his point of view if I remember right is it's worth taking a moment to set up the correct (pre-lifted) primitives for your custom stack
05:36:40 <quicksilver> then once you've done it once, the rest of your code looks cleaner
05:36:49 <fasta> ski_: that's because I derive Monad.
05:36:59 <fasta> ski_: but I admit, that's odd.
05:37:50 <fasta> I wrote lots of code already in Monad M. It would be nice if I wouldn't need to change that.
05:39:55 * ski_ found it useful to write a <http://www.mdstud.chalmers.se/~md9slj/code/Ref.hs> module for monads supporting 'STRef s' or 'IORef' references ..
05:40:12 <quicksilver> fasta: you won't
05:40:14 <fasta> ski_: I know the module, I don't need it.
05:40:20 <quicksilver> fasta: that's what the lifting stuff is for
05:40:33 <nominolo> Baughn: I don't think this is a workable solution in the general case.  If you're really sure you could cache the first result and reuse that in the future.
05:40:51 <quicksilver> fasta: but you need to make sure it's lifting the right bit
05:41:05 <quicksilver> (in principle can't it lift the right thing using a type class match?)
05:41:17 <fasta> quicksilver: but do I need to write a new monad transformer type?
05:41:23 <fasta> quicksilver: e.g. MT?
05:42:29 <quicksilver> fasta: you need a transformer for every monad except the one at the bottom of the stack, I think?
05:42:44 <quicksilver> fasta: I haven't written code in anger using this stuff so I'm the wrong person to ask
05:43:53 <fasta> Is there a STT?
05:44:16 <ski_> fasta : no
05:44:17 <quicksilver> ah, perhaps there can't be
05:44:54 <ski_> there can't be unless you can control uses of thing (like maybe Clean could do it, had it 'ST' to begin with)
05:45:41 <fasta> ski_: so, ST needs to be at the bottom
05:45:51 * ski_ nods
05:46:36 <ToRA> fasta: is your M monad a newtype M = blah... monad or a totally custom one?
05:46:43 <fasta> ToRA: newtype
05:46:49 <ToRA> fasta: what's the newtype decl?
05:47:48 <fasta> ToRA: newtype M a b c =  M { state:: State (MState a b) c}  deriving (Monad,Monoid,MonadCont)
05:48:36 <fasta> (MState holds bits of state I use everywhere almost everywhere)
05:48:38 <ToRA> yeah
05:48:47 <ToRA> not deriving MonadState (MState a b) ?
05:48:51 <fasta> strip one everywhere
05:49:06 <fasta> ToRA: no, I am not doing that currently.
05:49:31 <ToRA> so can't you change that to newtype M a b c = M { state :: StateT (MState a b) (ST <? guys what goes here>) c }
05:49:46 <fasta> ToRA: Functional dependencies conflict between instance declarations:
05:49:53 <fasta> ToRA: When I add that instance
05:49:54 <ToRA> and then write a custom new_ref method that strips off your M, and then uses lift to get into ST
05:50:11 <ski_> ToRA : 's'
05:50:23 <ToRA> ski_: it needs a forall from somewhere
05:50:28 <fasta> ToRA: Never mind that last remark: I wrote my own instance for MonadState (MState a b)
05:50:40 <ski_> ToRA : yes, in the 'runXXX' function
05:50:59 <fasta> ToRA: no, I cannot change that type.
05:51:01 <ToRA> ski_: so you have to param M with s now too?
05:51:06 <ski_> indeed
05:51:17 <ski_> it's contagious
05:51:36 <ToRA> fasta: which type can you not change?
05:51:53 <fasta> ToRA: of M which is the monad in which I have written lots of code already
05:52:13 <fasta> ToRA: I only care about getting the example as pasted to work as easily as possible.
05:52:28 <ski_> (well .. i think one can also make the whole thing parametric over the inner monad, and then instantiate that to 'IO' or 'ST s' as you wish .. e.g in the 'run' function(s))
05:52:55 <fasta> ski_: what whole thing?
05:53:17 <ski_> sorry ?
05:53:26 <ToRA> fasta: if all your code only uses the MonadState methods, and nothing (apart from a couple of helpers) directly touch State then it should be a /really/ minimal change
05:54:21 <ski_> fasta : oh .. your whole monad type i mean, 'M' i surmise
05:55:03 <fasta> ToRA: that is the case. Question is: what mininal change? ;) I am reading the Cale tutorial again.
05:55:04 <ToRA> fasta: the alternative is just do the example only in the ST monad, and use let res = runMyMMonadCode (myMonadCode), let res' = runMyMonadCode2 res all through?
05:55:50 <ToRA> minimal change = change any type signatures that were M a b to M s a b (regex find & replace)
05:56:01 <ToRA> plus any helper methods that unpack your M will need to be updated
05:56:33 * ski_ wonders how much parameterized modules could help with such ..
05:57:54 <fasta> I don't think ST is contagious in up direction of the stack
05:58:43 <ski_> how do you mean ?
06:01:18 <fasta> ski_: I mean that I don't need to add the s parameter to the M type.
06:02:00 <ski_> in what case ?
06:02:08 <ski_> (what is "up direction")
06:03:20 <fasta> ski_: never mind
06:04:45 <fasta> Again the question: do you know how the original paste would work, without modifying M?
06:05:18 <ski_> the one case i can imagine in which you want to plug 'ST s' into a bigger monadic type, and you don't have to add 's' as parameter to that type, is when you instead add an 'm' as argument to that type (and later instantiate that 'm' to 'ST s', or somthing containing that)
06:05:58 <ToRA> fasta you could just run the example in the ST monad and use let res = runMMonad mmonadcode ?
06:06:15 * ToRA realises he already said that and didn't just think it
06:06:54 * beelsebob pokes malcolmw 
06:06:59 <beelsebob> if he's about
06:07:03 * ToRA thinks doing a phd is making him go mad
06:07:03 <chessguy_> 'morning haskellers
06:07:11 <kaol> I'm starting to feel that I'd like to improve HSQL a bit. I'm guessing that patches would be welcome.
06:07:13 <david48> morning !
06:07:17 <beelsebob> ToRA: sounds entirely plausable
06:07:20 <ski_> fasta : have i understood correctly in that you want to use 'MState a b' as an ordinary state as in 'State' (or 'StateT') monad, and still use some 'ST s'-state things ?
06:07:34 <david48> .... afternoon here though :)
06:07:45 * malcolmw slaps beelsebob with a coffee mug
06:07:50 <beelsebob> ow!
06:07:59 <chessguy_> ouch, that's gonna leave a mark
06:08:04 <malcolmw> ..filled with hot coffee
06:08:09 <beelsebob> OW!
06:08:18 <beelsebob> malcolmw: I was trying to respond to your haskell cafe email in the great editor flamer war
06:08:24 <david48> I wish I was able to patch HSQL... There's some MySQL features I miss
06:08:27 <malcolmw> hello beelsebob.  :-)
06:08:31 <beelsebob> but my emails to the list seem to disapear into the ether
06:08:33 <beelsebob> hello :P
06:08:35 <fasta> ski_: I want M to be unchanged, use MState a b as an ordinary state as in State and use 'ST s'- state things.
06:09:02 <chessguy_> beelsebob: they're probably getting sucked into the hole that leads into space. have you been following xkcd?
06:09:08 <beelsebob> I believe the reason that Apple had come up with for it being faster with a mouse while seeming faster with the keybeard was roughly this:
06:09:08 <fasta> ski_: but other than that for the example function you may invent as many types as you want.
06:09:17 <malcolmw> beelsebob: feel free to respond to my email here in IRC then, but you'll have a much smaller audience
06:09:43 <beelsebob> with the mouse, your brain needs to put very little effort in, because it's a very natural gesture
06:09:52 <beelsebob> thus you have a lot of brain time left to spend thinking about how long it's taking
06:10:02 <beelsebob> on the other hand, thinking up the relevant keyboard combo is hard
06:10:24 <beelsebob> your brain has fun doing a difficult task
06:10:34 <beelsebob> and as we know, time flies when you're having fun
06:10:38 <ski_> fasta : if you want to use them in a single combined monad, then you need to change 'M' (no monad sums unfortunately ..) .. an alternate way which maybe could be used in your case is to have an 'M'-monad action which returns an 'ST s'-monad action (or vice versa), so that you get things in two stages .. but it depends on your problem if you can use that or not
06:10:50 <quicksilver> beelsebob: I strongly suspect the study was done on people-not-like-me
06:10:53 <malcolmw> beelsebob: hmm, so we have conflicting hypotheses
06:10:58 <quicksilver> beelsebob: people like my father, perhaps
06:11:02 <beelsebob> malcolmw: indeed, almost exactly so
06:11:23 <beelsebob> quicksilver: I believe it was done on people who had already worked on computers where the only option was keyboard shortcuts
06:11:23 <malcolmw> beelsebob: I wonder how we could test them by experiment
06:11:39 <beelsebob> the first task would be to try and duplicate apple's results
06:11:45 <beelsebob> and see whether mousing really is faster
06:11:54 <beelsebob> and if so, for which keyboard combos
06:12:15 <beelsebob> because their reasoning was that there were three keyboard combos for which it was slower -- copy, paste, and cut
06:12:27 <araujo> morning
06:12:39 <beelsebob> and that those combos were used so commonly that they became muscle memorised
06:12:41 <chessguy_> have you guys read this article/paper/manifesto on GUI design? http://worrydream.com/MagicInk/
06:12:42 <lambdabot> Title: Magic Ink: Information Software and the Graphical Interface
06:12:47 <chessguy_> araujo!
06:13:01 <araujo> chessguy_, ya!!!
06:13:04 <earthy> chessguy: that's an interesting text yeah
06:13:20 <chessguy_> i love his point that interaction is a BAD thing
06:13:25 <malcolmw> beelsebob: funny, I only learnt that there are key shortcuts for cut/copy/paste recently, and had always used the mouse for those, ever since early X11 days
06:13:33 <beelsebob> hehe
06:13:40 <earthy> looks like a nice application to use tangible values for
06:13:55 <beelsebob> yeh, it's interesting, it suggests that X11 does it exactly the wrong way
06:13:56 <malcolmw> beelsebob: recently = when i got a mac
06:14:00 <beelsebob> lol
06:14:25 <beelsebob> malcolmw: I wouldn't have been surprised if you'd hung on a lot longer than that
06:14:50 <beelsebob> most of the accademics I know who have bought a mac still launch X11, xemacs, and all the tools they've used for the past 30 years
06:14:59 <earthy> hm
06:15:11 <earthy> maybe I never got very attached to X
06:15:12 <malcolmw> beelsebob: I do that too
06:15:13 <earthy> but I don't
06:15:14 <earthy> ;)
06:15:26 <earthy> ofcourse, I do run gVim
06:15:30 <earthy> and Terminal.app a *lot*
06:15:31 <beelsebob> hehe
06:15:39 <beelsebob> I use terminal.app quite a lot
06:15:45 <beelsebob> but not as much as most people I know
06:15:58 <beelsebob> I'm consistantly cutting out uses for it too
06:16:10 <earthy> but I definitely like combos such as TeXShop/gVim
06:16:22 <earthy> especially given my Make TeXShop target
06:16:27 <malcolmw> I avoid Terminal.app in favour of xterm - give be crisp fonts instead of fuzzy ones any day
06:16:42 <earthy> malcolmw: that's a matter of font choice. :)
06:16:44 <beelsebob> malcolmw: you know you can set Terminal.app not to anti-alias?
06:17:01 * earthy uses 10 point Monaco without anti aliasing in Terminal.app
06:17:02 <beelsebob> plus... I actually use Terminal.app for exactly the opposite reason...
06:17:15 <malcolmw> earthy: beelsebob: yeah, yeah, but xterm doesn't require any configuration, and I'm lazy
06:17:16 <beelsebob> give me nice smooth fonts I can read, not some odd bitmap
06:17:21 <beelsebob> malcolmw: lol
06:17:38 <opqdonut> grr terminal.app
06:17:40 <earthy> so am I. that's why I use a mac. no mucho setting up. ;)
06:17:41 <opqdonut> grr antialias
06:17:55 <beelsebob> incidentally -- Terminal.app in leopard *wins*
06:17:59 <earthy> 'it just works'. :)
06:18:04 <beelsebob> tabs, and presetup terminals ftw
06:18:19 <malcolmw> the mac's anti-aliased fonts are an order of magnitude better than windows or linux fonts though
06:18:25 <beelsebob> indeed
06:18:33 <ski_> screen ftw
06:18:37 <beelsebob> although vista seems to have got a little closer on that respect
06:19:22 <beelsebob> ski_: this is one of the benefits -- you can make it so you do cmnd-n, and it opens a terminal, sshes into another machine, and then connects to screen
06:19:31 <beelsebob> (complete win!)
06:19:36 * malcolmw just started up terminal.app for the first time in a couple of years, and was surprised  to see it uses nice crisp bitmap fonts by default
06:19:36 <quicksilver> I've just switched to iTerm
06:19:54 <beelsebob> quicksilver: yeh, the new terminal.app is basically iTerm without the annoying bugs
06:19:56 <earthy> oh, and the mousing/keyboarding thing: I often keep one hand on the mouse and one on the keyboard
06:20:00 <quicksilver> nice programmable default configs and clickable links
06:20:03 <earthy> to point and hit shortcuts
06:20:13 <opqdonut> earthy: but do you type one-handed?
06:20:23 <earthy> not normally
06:20:25 <osfameron> insane delete/backspace behaviour though
06:20:32 <beelsebob> this is actually one of the reasons I prefer to use a track pad over a mouse
06:20:40 <osfameron> it always catches me out when I'm forced to use gf's ibook
06:20:43 <beelsebob> I can use it just as fast, and it's under my thumb while I'm typing
06:20:47 <opqdonut> i prefer keyboard-only usage
06:20:52 <earthy> nah
06:21:07 <malcolmw> hmm, so the reason I don't use terminal.app would appear to be scrolling.  on xterm, I can scrollback with shift-pageup, but in terminal.app you have to use the mouse
06:21:30 <chessguy> grrrr
06:21:38 <osfameron> malcolmw: you can configure scrolling too
06:21:45 <osfameron> it's just hidden in the menus somewhere
06:21:57 <malcolmw> unless some mac user knows different and wants to enlighten me?
06:22:39 <psnl> I hit shift-fn-up to scroll up
06:22:41 <beelsebob> I don't think so
06:22:48 <malcolmw> osfameron: found it - apple-pageup, not shift-pageup
06:22:49 <nominolo> dcoutts: do you have an idea how to force the handle behind a lazy bytestring?  i.e. if you want to do: "read 1000 bytes and then close, even if there's no eof".
06:22:50 <beelsebob> I think that's the principal complaint that most people have
06:23:39 <beelsebob> it's somewhat irritating though, that discussion *could* have been really interesting
06:23:43 <beelsebob> and not a giant editor flame war
06:23:50 <nominolo> dcoutts: but abstracting it in the library.  since most other issues have been resolved this is the only thing that's stopping us from making this the new Network.HTTP release
06:23:57 <beelsebob> if the first response had not been "oh grow up and use vim or emacs"
06:24:00 <malcolmw> heh, editor flame wars are inevitable
06:24:04 <beelsebob> indeed
06:24:10 <toxic> nominolo: (except finishing UserAGent)
06:24:13 <quicksilver> beelsebob: I was that first responder
06:24:14 <toxic> -G+g
06:24:18 <quicksilver> beelsebob: and that wasn't what I intended
06:24:20 <beelsebob> quicksilver: o.O
06:24:25 <beelsebob> hmm
06:24:36 <quicksilver> beelsebob: My intention was 'can you explain more carefully what about vim and emacs you don't like, to make this debate more interesting'
06:24:44 <beelsebob> hmmm
06:24:48 <malcolmw> dismissing both emacs in vim in the OP was the mistake I think :-)
06:24:59 <earthy> actually, given the way editor flamewars generally run this one was rather civil and interesting. :)
06:25:00 <quicksilver> beelsebob: the OP then replied with somethign I believe to be a combination of prejudice and ignorance ;)
06:25:21 <beelsebob> I'm not sure that dismissing them was -- I think that the way he dismissed them had a lot to do with it though
06:25:31 <beelsebob> quicksilver: well, ignorance I think is a fair reason
06:25:38 <malcolmw> beelsebob: so, what interesting avenues do you think we should have been exploring instead?
06:25:39 <ndm> he seemed much more flamey and uninformed when he started discussing Windows
06:25:42 <beelsebob> I know enough vim to open it, edit something and quit
06:26:01 <beelsebob> I don't want to spend 2 years learning it, but that's somewhat irrelevant
06:26:10 <fasta> ski_: There's quite a bit of interaction between ST and M (I store references in the state type of M).
06:26:21 <fasta> ski_: that would rule out option 2?
06:26:24 <ski_> fasta : two-way interaction ?
06:26:38 <beelsebob> malcolmw: personally, I thought the interesting question was "what are the alternative editors out there... Does someone prefers a GUI actually have a choice"
06:27:02 <fasta> ski_: I am not sure what you mean by two-way.
06:27:08 <malcolmw> beelsebob: and that was probably the question he intended to ask
06:27:11 <opqdonut> beelsebob: and gui here means menus and whatnot?
06:27:33 <quicksilver> beelsebob: even that question i find hard to answer properly
06:27:34 <malcolmw> opqdonut: I don't think GUI needs to mean menus and mice
06:27:37 <quicksilver> beelsebob: emacs has a GUI
06:27:43 <beelsebob> opqdonut: I don't know what it means to a linux user, because I've never seen a "standard" gui on linux
06:27:53 <opqdonut> what is a standard gui?
06:27:57 <opqdonut> ala office?
06:28:00 <beelsebob> one that is standardised
06:28:02 <quicksilver> beelsebob: so to give a helpful answer, I need 'I don't like the GUIs of emacs and vim because *XYZ*, is there anything more like *ABC* ?
06:28:08 <beelsebob> one that is nice and consistant across the whole platform
06:28:19 <fasta> beelsebob: what platform?
06:28:19 <quicksilver> beelsebob: such things only exist in fairy tales
06:28:20 <beelsebob> I don't care what it looks like -- as long as 99% of linux apps use it
06:28:22 <opqdonut> beelsebob: well, take kde for example
06:28:27 <opqdonut> that is a consistent platform
06:28:32 <beelsebob> quicksilver: rubbish -- such things exist on a Mac
06:28:33 <beelsebob> :P
06:28:38 <opqdonut> but linux will never be fully consistent
06:28:40 <quicksilver> beelsebob: neither microsoft nor apple has ever achieved a remotely consistent UI
06:28:42 <beelsebob> I know
06:28:43 <opqdonut> there will always be choices
06:28:46 <quicksilver> beelsebob: and they have tried quite hard
06:28:57 <quicksilver> beelsebob: apple is *terrible* at consistency
06:29:02 <malcolmw> like the guy in Magic Ink says, most interaction design would be better targetted at information layout design, reducing interaction to a minimum
06:29:05 <quicksilver> beelsebob: every new app has brand new user interface widgets
06:29:06 <beelsebob> quicksilver: Apple's GUI is *way* more consistant than Linux's
06:29:13 <quicksilver> beelsebob: that's because linux isn't a 'thing'
06:29:17 <ski_> fasta : if 'M0' and 'M1' are two monads, and say you then define 'foobarbaz :: Foo -> M0 (Bar -> M1 Baz)', then you must be able to decide which value of type 'Bar -> M1 Baz' you want to return solely on the basis of the 'Foo' input, and on interaction with effects in the 'M0' monad .. in particular you can't depend on value of 'Bar' or interactions with the 'M1' monad
06:29:27 <ToRA> fasta:
06:29:29 <ToRA> http://pastebin.ca/502290
06:29:34 <ToRA> does that help?
06:29:34 <beelsebob> quicksilver: ah, but that's my point -- new apps may have new widgets, but they don't have different widgets that do the same thing
06:29:39 <quicksilver> beelsebob: yes, they do
06:29:44 <quicksilver> beelsebob: almost always :)
06:29:47 <beelsebob> in linux you have thousands of things that look different but behave the same
06:29:53 <beelsebob> name one
06:29:56 <opqdonut> beelsebob: what's unconsistent about the cli?-)
06:30:02 <quicksilver> beelsebob: iTunes was totally unlike all the MacOS apps that came before it
06:30:07 <beelsebob> opqdonut: we're talking about guis
06:30:10 <ToRA> it typechecks, i assume it works and i think it does what you want?
06:30:16 <opqdonut> beelsebob: yeah i know :)
06:30:31 <opqdonut> beelsebob: but you should consider ui consisntency on linux on a per-toolkit basis
06:30:37 <quicksilver> beelsebob: to be remotely fair, you'd have to compare apple to, say, KDE
06:30:41 <opqdonut> for example the kde/qt apps are quite consistent
06:30:47 <quicksilver> beelsebob: and, I grant you, apple probably is more consistent than KDE
06:30:50 <beelsebob> opqdonut: no I shouldn't -- I use lots of different apps -- they all use different toolkits
06:30:50 <opqdonut> or gnome/gtk
06:30:53 <quicksilver> beelsebob: but I maintain they do a fairly bad job at it
06:30:58 <fasta> ski_: hmm, it's too complicated to predict whether that will be the case.
06:31:01 <beelsebob> quicksilver: sure
06:31:05 <opqdonut> beelsebob: well that is the price of choice
06:31:06 <beelsebob> but a much better job than most
06:31:07 <quicksilver> meanwhile, adobe mostly ignore the windows and max guidelines
06:31:15 <quicksilver> and build apps exactly how they want to
06:31:15 <opqdonut> i would hate to be locked into one toolkit
06:31:16 <beelsebob> opqdonut: yes, I believe the point was that for some people the price is too high
06:31:24 <quicksilver> microsoft and apple ignore their own guidelines
06:31:34 <quicksilver> and make each new app look 'new and cool' (and different)
06:31:35 <opqdonut> and there almost always is an alternative that uses another toolkit
06:31:43 <beelsebob> quicksilver: apple don't ignore them -- they rewrite them to suit the new app :P
06:31:43 <opqdonut> quicksilver: yes, like the new offices
06:31:50 <quicksilver> beelsebob: that's newspeak :)
06:31:55 <beelsebob> yep :P
06:32:11 <malcolmw> apple mostly seem to go for different skins on different apps, rather than fundamentally different widgets
06:32:15 <quicksilver> the closest thing there is a a 'standard' is actually 'try to look like MS Word'
06:32:25 <beelsebob> malcolmw: that all appears to be changing in Leopard
06:32:30 <quicksilver> malcolmw: that's true, there is some underlying consistency
06:32:34 <beelsebob> *all* the apps use the same skin
06:32:48 <malcolmw> and there is a good argument that per-app skins allow you to identify which app ant particular window belongs to quickly
06:32:50 <beelsebob> looks roughly like the combined toolbar one, but a bit darker
06:33:23 <ToRA> fasta: the M a is your existing monad, the N is a variant of your M that can nest ST, and call is how you get M a code into N a code?
06:33:40 <ToRA> fasta: so you don't need to change /any/ of your existing code
06:33:49 <fasta> ToRA: oh, right, I wasn't paying attention.
06:33:54 <fasta> ToRA: thank you very much.
06:34:36 <ToRA> fasta: np if it works
06:35:22 <malcolmw> one thing I like about apple's gui design is that they usually try to avoid needing the menus.  Menus are for experts.  Simple stuff is available directly using buttons within the window pane
06:35:35 <beelsebob> indeed
06:35:43 <ski_> ToRA : hm, interesting take on it
06:36:16 <dcoutts> nominolo: hGet :: Handle -> Int -> IO ByteString
06:36:40 <ToRA> ski_: it's a pattern i use a bit, is there anything wrong with it?
06:36:40 <nominolo> dcoutts: that doesn't work with lazy bytestrings
06:36:47 <nominolo> does it?
06:36:50 <dcoutts> nominolo: yes
06:37:00 * ski_ wants 'MonadFunctor' and some class for relating monads to corresponding monad transformers
06:37:07 <ski_> ToRA : not that i can see
06:37:11 <ToRA> ski_: i just make this stuff up as i go, and as long as the type system passes it i usually assume it works ;)
06:37:11 <beelsebob> malcolmw: of note -- I think SubEthaEdit meets all his criteria, except function folding, and unfortunately, it doesn't run on Linux
06:37:21 <dcoutts> nominolo: it does the read strictly of course
06:37:23 <Spark> anyone know how much type safety algol'58 had?
06:37:26 <quicksilver> nominolo: are you confusing 'lazy' as in unsafeInterleave and 'lazy' as in lazy bytestring?
06:37:32 <Spark> and how much the original cobol design had
06:37:34 <nominolo> quicksilver: no
06:37:52 <nominolo> dcoutts: well, that's exactly what we don't want
06:37:56 <dcoutts> quicksilver: see the ByteString.Lazy.hGet docs
06:37:59 <malcolmw> beelsebob: from what I've seen of Kate/KDevelop, it is rather nice, (apart from Haskell support probably)
06:38:00 <quicksilver> beelsebob: I think emacs meets all his criteria and he's just too blinkered to try it
06:38:08 <dcoutts> nominolo: I don't think you can have both.
06:38:19 <beelsebob> quicksilver: except that you need to know to press ctrl-x ctrl-s to save
06:38:22 <ski_> (ToRA : i was just mumbling about how one possibly could structure your pattern up to a more general thing ..)
06:38:23 <beelsebob> I have no idea how you would exit
06:38:28 <quicksilver> dcoutts: yes, I know :) I was wondering if nominolo didn't
06:38:32 <beelsebob> I usually get lost in a sea of buffers in emacs
06:38:37 <quicksilver> beelsebob: no you don't. You save just like you do in SubEthaEdit
06:38:40 <dcoutts> nominolo: you can either read a certain amount strictly or read the whole thing, but then you give up control over when the Handle gets closed
06:38:43 <quicksilver> beelsebob: you go File > Save
06:38:47 <quicksilver> beelsebob: then File > Quit
06:38:49 <beelsebob> quicksilver: I doubt cmnd-s will work
06:38:53 <beelsebob> but yes, it has menus
06:39:02 <quicksilver> beelsebob: well he *seems* to want menus
06:39:08 <quicksilver> beelsebob: what with his stories about the mosue being faster
06:39:12 <nominolo> dcoutts: please see the last comment here: http://nominolo.blogspot.com/2007/05/networkhttp-bytestrings.html
06:39:14 <lambdabot> Title: nominolo's Blog: Network.HTTP + ByteStrings
06:39:20 <beelsebob> I *think* he wants one where the keyboard shortcuts are not banal
06:39:26 <quicksilver> beelsebob: if he finds emac's shortcut commands offensive, he doesn't have to use them
06:39:27 <beelsebob> plus probably one with menus
06:39:31 <ToRA> ski_ yeah - well i do that pattern a lot so an abstraction on it would be useful :)
06:39:38 <opqdonut> i thinks he's just lazy and afraid of new things :)
06:39:45 <quicksilver> beelsebob: and there is a set of emacs keybindings which are more 'windows like' than the defaults
06:39:53 <beelsebob> actually, I think most emacs/vim users are afraid of new things
06:39:57 <dcoutts> nominolo: sounds right
06:40:09 <dcoutts> nominolo: hGetContents will only close if it gets EOF
06:40:09 <quicksilver> beelsebob: most people with an investment in something which was hard to learn are
06:40:10 <gleb> beelsebob: You can tweak all keybindings. But it's better to learn default if you don't want to redefine everything in every mode. C-x C-s is not that bad
06:40:18 <quicksilver> beelsebob: hence java programmers being afraid of haskell
06:40:30 <quicksilver> beelsebob: however, I'm neither afraid of new editors nor new languages :)
06:40:37 <beelsebob> quicksilver: it being hard to learn does not make it good -- just because you have investment in something doesn't mean you shouldn't give it up
06:40:45 <opqdonut> i use emacs, vi and ed fluently :)
06:40:47 <quicksilver> beelsebob: yes, I wasn't defending it :) just stating it :)
06:40:53 <beelsebob> okay
06:40:54 <gleb> After working with Emacs I tend to press C-x C-s in Visual Studio
06:40:59 <beelsebob> I think we can probably agree to disagree now
06:41:06 <quicksilver> beelsebob: I don't even think we disagree :)
06:41:19 <dcoutts> nominolo: can you explain again, exactly what behaviour you're looking for?
06:41:34 <beelsebob> well, I think the only disagreement is "I like SEE" "you like emacs" "other people like vim"
06:41:45 <beelsebob> which really is just opinion, so lets not flame
06:41:48 <beelsebob> :)
06:41:55 <nominolo> dcoutts: yes. one sec
06:42:31 <dons> are we still talking about editors??
06:42:51 <beelsebob> dons: I hope not, I'm hoping that killed it
06:42:55 <dons> here's something cute, xmonad lines of code versus comment growth:
06:42:57 <dons>  loc, http://www.cse.unsw.edu.au/~dons/tmp/xmonad-loc.png
06:43:04 <dons>   comments, http://www.cse.unsw.edu.au/~dons/tmp/xmonad-comments.png
06:43:10 * malcolmw has just discovered that KDevelop is available on MacOS
06:43:14 <dons> and dwm, our competitor, loc: http://na.srck.net/dwm/dwmsloccountrevs.png
06:43:25 <beelsebob> malcolmw: heh, cool
06:43:39 <beelsebob> malcolmw: personally -- I like XCode, but it has crappy Haskell support
06:43:41 <beelsebob> so SEE it is
06:44:53 * malcolmw has never tried XCode
06:44:59 <beelsebob> I think that final comment that Ketil made is somewhat flawed
06:45:13 <beelsebob> the article stated that most of the time was spent thinking about which keyboard shortcut to use
06:45:22 <beelsebob> and he's said he's faster if he pre-caches it
06:45:35 <beelsebob> he thought about how to do a search and replace, started the timer, and then did it
06:46:07 <ndm> he's also missing how i do search and replace
06:46:15 <quicksilver> beelsebob: if I ever flame feel free to pick me up on it
06:46:20 <quicksilver> beelsebob: I don't believe I do :)
06:46:39 <beelsebob> quicksilver: I think it was quite hard not to
06:46:41 <malcolmw> beelsebob: any experiment is going to have to have a human giving out tasks to people using editors, and the stopwatch is started immediately the task description is complete
06:46:42 <ndm> I press F5 which brings up the search and replace GUI dialog box, with the selected text hilighted in the find box, then i tab around and press enter to do it
06:46:49 <ndm> i.e. 100% keyboard, but using a GUI
06:47:01 <beelsebob> quicksilver: it was after all a discussion about editors
06:47:08 <quicksilver> beelsebob: the only reason I haven't tried subethaedit is I have an innate resistance to non-free software when good free alternatives exist
06:47:19 <quicksilver> beelsebob: I will believe you when you say it's good, though
06:47:32 <chrismbrown_> quicksilver: I can vouch for how good SEE is
06:47:41 <quicksilver> two testimonials :)
06:47:44 <beelsebob> malcolmw: yes, but you don't need to tell the person what you're measuring, nor do you have to show them the stop watch
06:47:45 <chrismbrown_> :)
06:47:48 <osfameron> SEE ?
06:47:53 <chrismbrown_> Sub Etha Edit
06:47:56 <beelsebob> malcolmw: they need not even know that you're timing them
06:47:57 <osfameron> oh, yeah
06:48:11 <osfameron> is that good as an editor?  I like the multi-user gimmick, but how does the core functionality stack up ?
06:48:18 <osfameron> (not that I have or want a Mac so it's academic)
06:48:23 <manu3000> talking about non free software, Textmate is nice too, but the Haskell bundle is somewhat restricted
06:48:25 <chrismbrown_> osfameron: I like it, it works nicely for me. It's nice and simple.
06:48:26 <beelsebob> osfameron: as far as I'm concerned, it's perfect
06:48:27 <nominolo> dcoutts: if we use lazy bytestrings then we read a lazy bytestring once and then just take parts of it using the regular list operations.  if the server closes the connection we just get an EOF on the handle the string is termited and we're fine.  However, if the server doesn't close the connection:
06:48:37 <beelsebob> osfameron: it has every feature I need, and none I don't need
06:48:50 <fasta> M-% some letters M-/ RET some letters M-/ RET ! is also possible
06:48:50 <osfameron> ah, I'll try one time I'm on a mac
06:48:56 <chrismbrown_> it has search and replace, open and save, all a growing Haskeller needs :)
06:49:04 <beelsebob> heh
06:49:11 <nominolo> dcoutts: we want to have a way to close the connection _once we're done reading_.  I.e. we want a lazy takeAndClose n lbs
06:49:21 <dcoutts> nominolo: then you need some way of identifying the end of the transfer from the server
06:49:45 <nominolo> dcoutts: yes, after reading 'n' characters i want to force the EOF
06:49:46 <quicksilver> manu3000: the reason I prefer a free editor is that if the haskell bundle is restricted, I can improve it
06:49:48 <cdsmith> Whoa!  I know complaining about Java is one of our hobbies; but I just an email griping that it limits you to 65536 local variables per function.  Makes you wonder what some people's code looks like!
06:49:49 <dcoutts> nominolo: that doesn't sounds like a pure operation
06:49:57 <quicksilver> manu3000: of course, I'm aware that the community contribute lots of work to textmate too
06:50:02 <beelsebob> quicksilver: the reason I don't go for vim or emacs is that I'm a firm believer that it shouldn't take longer to learn how to use a text editor than, how to use the OS it's residing in
06:50:04 <dcoutts> nominolo: you can do take of course
06:50:21 <manu3000> @ quicksilver : well you can improve it with textmate too
06:50:24 <dcoutts> nominolo: but I thought you didn't want to hClose the handle, if there might be another transfer following
06:50:27 <quicksilver> manu3000: but to my mind, it's strange to constribute your free time to non-free code :)
06:50:42 <beelsebob> or actually in the case of emacs, I'm a firm believer that it shouldn't take longer to learn how to use an OS, than the text editor it's residing in
06:50:45 <nominolo> dcoutts: no there are case where I want to close it deliberately
06:50:49 <nominolo> *cases
06:50:54 <manu3000> well if it is a tool you spend hours on evry day, why not
06:50:59 <quicksilver> beelsebob: I take your point. But, I use my OS (in any meaningful sense) less than I use my text editor
06:51:02 <sris> if i have a recursive method. is there an easy way to make it print some output in between every call?
06:51:06 <dcoutts> nominolo: it sounds to me like you want to have more control over the IO, so use strict IO.
06:51:13 <quicksilver> beelsebob: and I demand more features from my editor than my OS (at the user level)
06:51:21 <beelsebob> which is odd
06:51:22 <quicksilver> beelsebob: so therefore I reasonably expect it will be complex
06:51:22 <opqdonut> sris: well you could just use trace
06:51:24 <fasta> I used to think ConText was a great editor on Windows.
06:51:32 <beelsebob> because the point of the OS is to distribute tasks between different programs
06:51:35 <nominolo> dcoutts: then i'd have to do the chunking myself.  fair enough
06:51:41 <beelsebob> so why are you sticking all the tasks in the editor?
06:51:48 <sris> opqdonut: whats that?
06:51:58 <beelsebob> my current king of the hill on Windows is Notepad++
06:52:04 <fasta> beelsebob: you don't need to use Emacs like an OS.
06:52:06 <opqdonut> ?hoogle trace
06:52:06 <lambdabot> Debug.Trace.trace :: String -> a -> a
06:52:07 <lambdabot> Debug.Trace :: module
06:52:07 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
06:52:25 <beelsebob> fasta: no, I was responding to quicksilver's "needing more features in a text editor than in an OS"
06:52:28 <malcolmw> I read someone yesterday who said that emacs is a great OS, shame it doesn't have a useful text editor in it
06:52:30 <beelsebob> I want my OS to manage processes
06:52:39 <beelsebob> and I want my editor to edit text
06:52:41 <beelsebob> and not much more
06:52:55 <SamB_XP> malcolmw: yeah, its a pretty standard joke ;-)
06:52:56 <dcoutts> nominolo: I don't think lazy IO is really compatible with re-using the same socket for multiple transfers
06:52:57 <fasta> beelsebob: Yesterday I was interested in what command I did a few strokes back. M-x view-lossage
06:52:57 <beelsebob> malcolmw: lol
06:53:18 <fasta> beelsebob: I don't think software can have too many features, unless it's too slow.
06:53:20 <dcoutts> nominolo: because you're relying on your caller to consume the input before you can get the next transfer
06:53:44 <beelsebob> fasta: on the contrary, I'm a great believer in each program being excellent at one specific task
06:53:45 <SamB_XP> fasta: well, you have to admit it can be harder to find the features
06:53:46 <fasta> beelsebob: especially with the interface Emacs or VIM has
06:53:50 <beelsebob> if I then want to combine the tasks, I can combine the programs
06:54:05 <SamB_XP> emacs has a lot of programs
06:54:07 <nominolo> dcoutts: true
06:54:12 <SamB_XP> why do you suppose they call it an OS?
06:54:27 <fasta> SamB_XP: it's a name space problem
06:54:46 <beelsebob> SamB: that's exactly my problem with it
06:54:59 <toxic> maybe if the reusing includes forcing to read all the old data
06:55:57 <quicksilver> beelsebob: as an example of how the combined approach works well, consider a complex ghci session.
06:56:17 <quicksilver> beelsebob: clearly I could run a putative GUI ghci (like winhugs) or I could just run ghci in a terminal
06:56:21 <quicksilver> beelsebob: and sometimes, I do
06:56:34 <beelsebob> quicksilver: of note, I don't... ever
06:56:35 <quicksilver> beelsebob: but, if I'm testing complex things, and entering complex haskell expressions
06:56:53 <beelsebob> if I'm exiditing complex haskell expressions I use an editor
06:56:59 <beelsebob> I then paste them into ghci
06:57:07 <dcoutts> toxic: you can do that if you're prepared to buffer the remaining input in memory or on disk, you might need threads to help with that, but this starts to sound too complex
06:57:07 <beelsebob> because my editor, and ghci can work together nicely
06:57:16 * quicksilver nods
06:57:21 <quicksilver> but what I'm doing is like what you're doing
06:57:28 <quicksilver> (using the editor to edit the complex expressions)
06:57:33 <quicksilver> except, I save the copy-paste step
06:57:33 <dcoutts> toxic: you really need to know who is responsible for pulling/consuming the data
06:57:34 <beelsebob> except that you're combining two arbitrary programs
06:57:37 <beelsebob> for no reason
06:57:38 <zorg0f> hey, i'm having some problems learning the foldr function. would someone mind explaining how foldr (+)1 [1,2,3] = 7 ?
06:57:42 <Speck> Is there any page/wiki/blog/repository where I can learn about the Parsec -> ParsecT/ByteString SoC project?
06:57:45 <quicksilver> beelsebob: not "for no reason"
06:57:52 <quicksilver> beelsebob: "for the reason I just described"
06:58:04 <SamB_XP> beelsebob: I suppose it would be gratuitous on plan 9...
06:58:05 <beelsebob> quicksilver: yes, but you gained a step -- the "enter ghci mode" step
06:58:13 <quicksilver> beelsebob: that's once per fortnight, though
06:58:17 <nominolo> zorg0f: 7 = (1 + (2 + (3 + 1)))
06:58:18 <quicksilver> beelsebob: once it's there, it's there
06:58:42 <SamB_XP> quicksilver: it isn't much harder than finding an empty xterm and typing "ghci"
06:58:43 <beelsebob> yes, but once there, you need to be you to actually know what it is and what it's doing
06:58:57 <beelsebob> wheras I have ghci that's always ghci
06:58:57 <quicksilver> beelsebob: eh?
06:58:59 <zorg0f> so basically, foldr does *whatever* (in this case +1) to the last element of a list?
06:59:04 <beelsebob> and an editor that's always an editor
06:59:05 <quicksilver> beelsebob: ghci in emacs is still ghci...
06:59:14 <beelsebob> yes... but emacs is no longer emacs
06:59:14 <SamB_XP> beelsebob: buffers have names
06:59:21 <SamB_XP> and emacs is still emacs
06:59:24 <beelsebob> SamB: so do programs... use them
06:59:25 <quicksilver> beelsebob: it doesn't behave differently, it just has a different line editor
06:59:45 <beelsebob> so it does behave differently then?
07:00:01 <beelsebob> but only subtly
07:00:01 <quicksilver> beelsebob: I can use my editor to edit things
07:00:10 <quicksilver> beelsebob: before I 'submit' my command to the ghci
07:00:11 <ski_> zorg0f : foldr (+) 42 [1,2,3] = 1 + (2 + (3 + 42))
07:00:11 <beelsebob> good, so use it to
07:00:17 <beelsebob> don't expect it to do other stuff too
07:00:24 <Saizan> zorg0f: foldr f z [a,b,c] = f a (f b (f c z))
07:00:28 <beelsebob> it is after all, an editor
07:00:28 <quicksilver> beelsebob: but using it in the same window is conveninet
07:00:32 <quicksilver> beelsebob: rather than needing two
07:00:41 <quicksilver> beelsebob: (and you get syntax hihglighting on ghci output)
07:00:44 <beelsebob> that's just a symptom of a poor window manager
07:00:58 <quicksilver> beelsebob: (which isn't desperately interesting for ghci but is for some other programs)
07:01:02 <beelsebob> click -> drag, done
07:01:18 <SamB_XP> I especially like the error clicking
07:02:00 <SamB_XP> beelsebob: since when do WMs do that?
07:02:11 <beelsebob> SamB: mine does
07:02:22 <beelsebob> or do you mean error clicking?
07:02:51 <zorg0f_> oops - was resting my feet on my case and they slipped and hit the power button! :$
07:02:58 <SamB_XP> hah
07:03:06 <zorg0f_> could someone paste that foldr example with the characters
07:03:09 <beelsebob> zorg0f: not quite as bad as a particular apple UI failing
07:03:15 <Saizan> zorg0f: foldr f z [a,b,c] = f a (f b (f c z))
07:03:19 <zorg0f_> ta
07:03:27 <opqdonut> ?src foldr
07:03:27 <lambdabot> foldr k z xs = go xs
07:03:28 <lambdabot>     where go []     = z
07:03:28 <lambdabot>           go (y:ys) = y `k` go ys
07:03:48 <beelsebob> on Mac IIs the cable coming out of the keyboard was the perfect size, shape and height to hit the reset button if you shoved the keyboard forwards
07:04:40 <opqdonut> .)
07:04:45 <SamB_XP> was it also the perfect horizontal location?
07:04:53 <beelsebob> usually
07:04:59 <SamB_XP> wow
07:05:02 <beelsebob> if you sat the keyboard directly in front of the box it was
07:05:11 <opqdonut> wtg apple :P
07:05:14 <beelsebob> indeed
07:05:16 <SamB_XP> yeah, 'swhat I meant ;-)
07:05:58 <bos> @seen dons
07:05:59 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 19m 21s ago.
07:09:02 <zorg0f_> why is this ( foldr (+) [4,4,4] ) not valid? does foldr need to have a value as well as a function?
07:09:18 <bos> yes.
07:09:19 <opqdonut> zorg0f_: yes
07:09:22 <zorg0f_> cool. ta
07:09:22 <beelsebob> you need to give it a zero value
07:09:25 <earthy> zorg0f: it needs to know what to stop on
07:09:26 <beelsebob> foldr needs two things
07:09:26 <opqdonut> use foldr0 if you want 0
07:09:31 <beelsebob> something to replace [] with
07:09:35 <beelsebob> and something to replace : with
07:09:52 <opqdonut> sorry, foldr1
07:10:00 <opqdonut> > foldr1 (+) [4,4,4]
07:10:02 <lambdabot>  12
07:10:11 <earthy> foldr1 takes the last element in the list to stop on
07:10:11 <SamB_XP> > foldr1 (+) []
07:10:12 <opqdonut> that requires a non-empty list
07:10:13 <lambdabot>  Exception: Prelude.foldr1: empty list
07:10:13 <therp> > foldr (+) 0 [4, 4, 4]
07:10:15 <lambdabot>  12
07:11:45 <ToRA> do we know who was responsible for www.foldr.com ?
07:11:53 <beelsebob> zorg0f: to think about foldr -- write out the list in it's un-sugared way (4 : 4 : 4 : []) -- then replace ':' with the function, and [] with the zero value, so for foldr (+) 0, you would end up with 4 + 4 + 4 + 0
07:12:55 <dons> ToRA: don't you mean www.foldl.com ?
07:13:32 <pitecus> what is the best way to split a darcs repo into several independent projects?
07:13:33 <beelsebob> dons: what are you trying to show, that foldl is more user friendly, because you can click it more easily?
07:13:34 <ski_> > let  plus x y = concat ["(",show x," + ",y,")"]  in  foldr plus "0" [1,2,4,7,12,20]
07:13:35 <lambdabot>  "(1 + (2 + (4 + (7 + (12 + (20 + 0))))))"
07:13:51 <osfameron> foldr.com++
07:13:53 <ToRA> dons: well i wanted to know why they havn't registered concatMap.com
07:13:53 <beelsebob> ski_: neat :)
07:14:00 <zorg0f_> excellent, yeah, i got it now.
07:14:01 <ski_> > let  plus x y = concat ["(",x," + ",show y,")"]  in  foldl plus "0" [1,2,4,7,12,20]
07:14:02 <lambdabot>  "((((((0 + 1) + 2) + 4) + 7) + 12) + 20)"
07:14:20 <zorg0f_> lol, when i was googling for foldr examples earlier i found foldr.com - sat there clicking it for ages :$
07:14:31 <opqdonut> :)
07:14:38 <osfameron> it's beautiful!
07:14:46 <osfameron> I think I like foldl.com even more
07:16:45 <nominolo> dcoutts: reading at a later place in the bytestring automatically forces the part before that
07:16:57 <nominolo> dcoutts: of course that will increase memory usage
07:17:32 <dcoutts> nominolo: yes, using take/drop for example to look later in the bytestring forces it that far
07:17:55 <nominolo> dcoutts: so we'd want the user to decide if she wants to reuse the old socket
07:18:11 <nominolo> dcoutts: but that'd be fine, i guess
07:18:56 <quicksilver> chessguy: that was a great article, thanks
07:19:38 <chessguy> quicksilver: yeah, it's great stuff
07:21:39 <cdsmith> chessguy: I'm enjoying the movie names in one of the examples.
07:26:26 * earthy thinks he ought to drop http://neugierig.org/content/unix/ into each following editor war :)
07:26:28 <lambdabot> Title: Unix
07:30:29 <kfish> why can't people argue about something tasty, like cheese?
07:30:41 <SamB_XP> oooh
07:30:45 <SamB_XP> I loves cheeses
07:31:30 <earthy> not all cheese is tasty though. :)
07:31:49 <Speck> who could argue about cheese? except like: "Do you have any cheese?" "No." "Screw you!"
07:31:56 <osfameron> I like the "How Dumbledore would sell Haskell" thread
07:34:45 <shapr> Griere(sp?) is the best cheese in the world.
07:35:10 <quicksilver> gruyere, I believe
07:35:22 <quicksilver> I can't bear cheese with a modal interface :P
07:35:23 <shapr> Ah, thanks. I can't spell before I've had coffee.
07:36:01 <earthy> Speck is not aware of the monty python cheese shop sketch then? :)
07:36:33 <Speck> earthy: I am very aware, now shut up that bloody basooki
07:36:46 <Speck> (or however you spell that)
07:37:06 <earthy> 'shut that bloody mazourka up!' :)
07:37:39 <earthy> oh, no, bouzouki
07:37:43 <earthy> other type of dance
07:37:44 <Apocalisp> No. 'Twas an act of sheer optimism to pose the question in the first place.
07:37:44 * Speck has a savant friend who can recite any sketch verbatim in accent
07:38:17 <earthy> that is just plain scary.
07:38:25 <Apocalisp> Can he do it in Hungarian?
07:39:02 <Speck> he can do it in whatever language the sketch is in. english mostly
07:39:30 * earthy dislikes wensleydale though. ;)
07:40:54 <osfameron> yeah, I'm not fussed on the crumbly, tart English cheeses
07:41:28 <osfameron> cheddar otoh is vastly underrated intrenationally
07:41:42 <earthy> there's cheddar and cheddar though
07:41:48 <osfameron> oh, sure
07:41:55 <earthy> much as there's gouda and gouda
07:41:59 <shapr> I'm fond of Gorgonzola.
07:42:11 <savanni> question (and this means a topic change back to Haskell for a moment)
07:42:16 <earthy> ;)
07:42:31 <savanni> In ghci, I'm using readFile to read a file from disk.  How do I keep it from printing the entire file to screen?
07:42:43 <savanni> Different function, maybe?
07:42:46 <earthy> contents <- readFile
07:42:52 --- mode: ChanServ set +o shapr
07:42:56 <earthy> is what you do?
07:43:00 <fasta> ToRA: Does your "call" not fit in some existing type class?
07:43:01 <savanni> Yeah, it is.
07:43:02 <quicksilver> earthy: some versions of ghci automatically show the return value, too
07:43:10 --- topic: set to 'Today only, this is #cheese! ["The Haskell programming language: because forall e1 e2. e1 -> v1 && e2 -> v2 => (e1,e2) -> (v1,v2)","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by shapr
07:43:19 <earthy> quicksilver: just determining what savanni's doing ;)
07:43:20 <quicksilver> I forget the hack that was advised
07:43:26 --- mode: shapr set -o shapr
07:43:30 <quicksilver> you can turn off that behaviour, of course
07:43:59 <osfameron> hmmm, I've been deliciousing articles about haskell since Feb 2005.  Took me a while to get around to learning it...
07:44:07 <lispy> mm...ttmrichter seems to be a troll
07:44:16 <earthy> lispy: oh, but he is. :)
07:44:27 <ToRA> fasta: no
07:44:51 <ToRA> fasta: i think ski_ was lamenting that fact
07:44:54 <ndm> mnislaih: i think your thread about debugging shows that debugging works best when its reliable, not when its fancy
07:45:09 <ToRA> fasta: (and i agree)
07:45:25 <lispy> ndm: i would agree with that statement purely on personal experience
07:46:01 <ndm> lispy: i think it works absolutely best in a GUI though
07:46:03 <lispy> ndm: BTW, what are the limitiations of catch?  do  you think it would work on darcs source?
07:46:37 <quicksilver> lispy: main limitation is it has to be YHC-compilable
07:46:46 <quicksilver> lispy: that means no pattern guards, e.g.
07:46:46 <ndm> lispy: its not going to work on darcs yet for a couple of reasons: Yhc must be able to compile the program (thats because GHC.Core is broken, once they fix, it will work with GHC)
07:47:12 <lispy> i see, yes darcs uses pattern guards
07:47:15 <fasta> ToRA: Yes, I thought you did. Just wanted to be sure.,
07:47:17 <ndm> secondly, the first-order transformation isn't perfect, but i've got one in a different project that is, so that needs moving over
07:47:48 <ndm> thirdly, darcs is somewhat larger than anything i've put through catch yet - but in theory that shouldn't be an issue, although may show up some places i'm using associative lists instead of maps etc
07:48:19 <ndm> in principle, once GHC.Core gets finished, and i port Catch over, i'd say you've got a shot at getting it through with a beefy computer
07:48:44 <lispy> ndm: that's great.  Sounds like I need to keep waiting for now though.
07:48:50 <lispy> thanks
07:49:12 <ndm> lispy: yes, its not ready yet for darcs, but can happily cope with projects in the thousands of lines
07:50:08 <earthy> savanni: run ghci with -fno-print-bind-result
07:56:16 <_case> hello, i have a binary search tree. i wan't to add a node to it, but i get the following error:
07:56:23 <_case> Main> insTree 17 aTree
07:56:30 <_case> ERROR - Cannot find "show" function for:
07:56:42 <_case> *** Expression : insTree 17 aTree
07:56:43 <_case> *** Of type    : Tree Integer
07:57:01 <_case> instree has arguments insTree :: Ord a => a -> Tree a -> Tree a
07:57:08 <_case> what's wrong here?
07:57:30 <_case> aTree is a static defined BST for testing purposes
07:57:32 <Saizan> that your interpret needs a way to print your Tree
07:57:42 <Saizan> *interptreter
07:57:48 <savanni> earthy: cool, thanks!
07:57:53 <Saizan> so you nee to make it an instance of Show
07:57:54 <_case> Saizan: i have a printBST function, can i use that?
07:58:26 <fasta> _case: a printBST function has type IO () probably, so no
07:58:40 <fasta> _case: you need something of type Tree a -> String
07:58:40 <ari> @type show
07:58:43 <lambdabot> forall a. (Show a) => a -> String
07:59:02 <fasta> _case: (but somewhere in your printBST function you already do this)
07:59:15 <_case> hmm, i don't quite understand
07:59:25 <Saizan> _case an easy solution is to add deriving (Show) to your Tree definition
07:59:46 <thruspa> And a dummy instance like : instance Show aTree where show x = ""  ?
07:59:53 <Saizan> i.e. data Tree a = .... deriving (Show)
08:00:06 <_case> ok
08:00:16 <Saizan> _case: but, what's the type of printBST?
08:00:34 <_case> printBST :: Tree a -> [a]
08:01:07 <_case> ah, the deriving part worked :)
08:01:15 <_case> what does it do exactly?
08:01:56 <Saizan> it defines Tree a as an instance of the class Show, so that you can use the function show on a tree
08:01:58 <Saizan> ?type show
08:02:01 <lambdabot> forall a. (Show a) => a -> String
08:02:17 <_case> Saizan: aah ok, i see
08:02:19 <Saizan> _case: do you know how typeclasses work?
08:02:29 <ari> _case: It conceptually writes out a bunch of code for you according to the rules at http://haskell.org/onlinereport/derived.html#sect10.4
08:02:30 <lambdabot> Title: The Haskell 98 Report: Derived Instances
08:02:50 <_case> Saizan: yeah in general
08:03:54 <Saizan> _case: well some of them can be derived in this way, as you can find on ari's link
08:04:33 <_case> ok, tnx guys
08:06:04 <shapr> Gruyere supreme!
08:06:57 <shapr> Cheddar is the Yugo of the cheese world.
08:07:15 * shapr tries to start a holey cheese war. (Should have talked about Swiss)
08:07:20 <Speck> cream cheese! (or neufchatel) ++
08:07:49 <osfameron> parmesan versus grana padano!
08:07:59 <osfameron> brie versus camembert!
08:08:39 <quicksilver> anyone around know Yi? specifically its display model?
08:08:51 <ski_> gammelost !
08:09:08 <shapr> America is the land of boring cheese. I went to the nearest specialty shop and they had Gruyere for one dollar an ounce (0.74 euro for 0.028 kilo of cheese)
08:09:30 * mux in .fr
08:09:36 <mux> lots of good cheeses
08:09:49 <shapr> Yeah, France is the land of fromage!
08:09:55 <osfameron> Gjetost (sp?) - strange norwegian cheese that looks (and almost tastes) like fudge
08:10:02 <phoniq_> ski queen!
08:10:03 <shapr> I like Vasterbottom.
08:10:08 <mux> shapr: and wine ;-)
08:10:15 <dcoutts_> osfameron: in can taste like fudge, but often smells like poo
08:10:26 <elrodeo_> elrodeo_: test
08:10:27 <phoniq> great with gala apples
08:10:27 <osfameron> eeek!
08:10:30 * dcoutts_ knows to his cost
08:10:46 <osfameron> there are swiss cheeses that smell rank
08:10:47 <shapr> The Swedish cheese is actually called Vasterbotten but its fat content is so high it *should* be called vaster*bottom*.
08:10:51 <ski_> mesost !
08:10:54 <osfameron> Muenster, maybe
08:11:03 <mux> hmmm, mnster
08:11:28 <osfameron> beautiful taste, but you wrap it in layers of plastic and boxes etc., put it in your luggage, and while you travel people are constantly looking at you to check if you've a) farted or b) died
08:11:37 * ski_ . o O ( muenster monster )
08:12:10 <shapr> osfameron: It means "goat cheese" and truly, goat cheese and sheep cheese is biological warfare.
08:12:28 <osfameron> shapr: which means "goat cheese" ?
08:12:45 <zorg0f_> im trying to write a recursive version of this:         f xs y = [y * x| x<-xs ]              i.e. doesn't use list comprehension, but i'm having problems using x:xs etc. I have:          f :: [Int] -> Int -> [Int]         f [] _ = []          f x:xs y = [ x*y ++ f xs y ]                - i know this is wrong but can anyone see what i'm trying to do? :(
08:12:49 <osfameron> there are wonderful sheep cheeses, the Spanish ones are great, and Italian Pecorino is occasionally marvellous
08:12:52 <shapr> My ex had this one mutton cheese that polluted our apartment for weeks, and it was only in the fridge for hours.
08:12:56 <shapr> osfameron: Sorry, I'm not awake yet :-)
08:13:10 <shapr> osfameron: getost is "goat cheese" in Swedish
08:13:25 <osfameron> ah, ok - I thought it was a norwegian cheese
08:13:25 <ski_> zorg0f_ : 'f (x:xs) y = ...'
08:13:50 <ski_> zorg0f_ : 'f x:xs y' gets parsed as '(f x):(xs y)' which is not what you want
08:14:17 <Baughn> zorg0f_: Or, even shorter, f x y = map (* y) x
08:14:21 <shapr> osfameron: Oh, I'm sure it is, but Swedish, Norwegian and Danish are very similar. So gjetost in Norwegian would be getost in Swedish and gedest in Danish.
08:14:33 <ski_> ('gjetost' is norwegian spelling)
08:14:43 <shapr> Er, gedeost in Danish
08:14:43 <osfameron> ah, cool
08:14:53 <malcolmw> goat's cheddar is delicious - totally much better than cow cheddar
08:15:06 <shapr> malcolmw: Yeah, but nothing you want to keep in your backpack on a warm summer's day.
08:15:24 <zorg0f_> baughn: yeah, i realize that map function would do it but i've got to do it this way for the sake of an exercise.            ski_: ta, i'll try and have a fiddle with it
08:15:24 <shapr> malcolmw: btw, did colourFragment become colour?
08:15:40 <shapr> malcolmw: Er, colourFragment -> hscolour?
08:15:41 <malcolmw> shapr: hmm, yes I think so
08:15:47 <shapr> ok, thanks.
08:16:18 <malcolmw> shapr: at any rate, someone introduced Fragment variations, and I decided to make them the default API
08:16:44 <zorg0f_> woo! got it working. third line should've been:       f (x:xs) y = [x*y] ++ f xs y
08:16:44 <malcolmw> shapr:  with a flag to choose partial/non-partial
08:16:54 <shapr> Well, I broke hpaste yesterday trying to update it, so I ended up with some questions.
08:17:27 <malcolmw> shapr: ah, so you are responsible for hpaste not working...
08:17:42 <ski_> zorg0f_ : you can (if you want) simplify '[foo] ++ bar' to 'foo : bar' .. in some cases the former can read better, though
08:17:46 <shapr> Not originally, no. but at this point, yes.
08:17:50 <lispy> zorg0f_: hmm...so you multiply each element by y?
08:18:24 <zorg0f_> lispy: lol, yeah - that's all.                    ski_: what's the difference between using a colon and double + ?
08:18:55 <lispy> zorg0f_: look at map :)
08:18:57 <lispy> :t map
08:19:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:19:08 <lispy> > map (*4) [1..4]
08:19:09 <lambdabot>  [4,8,12,16]
08:19:30 <zorg0f_> yeah, i'm aware of map. i just had to use recursion for the exercise.
08:19:35 <lispy> zorg0f_: now that you see how to write it by hand, you can start looking at more advanced ways
08:19:50 <osfameron> Apocalisp: ping?
08:19:56 <ski_> zorg0f_ : '++' will walk through it's left argument (a list) and add each element in front of the right argument (a list) (using ':') .. ':' just puts the left argument (an element) in front of the right argument (a list) directly
08:20:19 <ski_> (zorg0f_ : and in your case the left argument happened to be a one-element list)
08:20:32 <ski_> @src (++)
08:20:33 <lambdabot> (++) []     ys = ys
08:20:33 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
08:21:27 <mnislaih> ndm: about debugging: as long as I have the assurance it works _always_ (99% of times), the fancier, the better,
08:21:44 <ndm> mnislaih: oh yes, but realiable before features
08:21:45 <malcolmw> shapr: see patch "*Add a -partial option, to produce output without header/footer."  it says "Note that the library API has changed: hscolourFragment has been removed ..."
08:21:55 <shapr> malcolmw: Thanks
08:22:01 <zorg0f_> hrmmm. the way i think im understanding it, is that the x:whatever adds a single element to a list. wheras the ++ adds a list to a list. is that correct?
08:22:11 <ski_> zorg0f_ : yes
08:22:16 <zorg0f_> great, ta :)
08:22:17 <shapr> glguy said he'd fix hpaste when he has time, but he's been distracted with major life changes.
08:22:25 * rho is away: (ice cream time)
08:22:30 <zorg0f_> and they're just adding left/right-wise by the order they come in?
08:22:34 <ski_> (zorg0f_ : and the "element in front of list" is the primitive view of lists)
08:22:42 <ski_> @src []
08:22:43 <lambdabot> data [] a = [] | a : [a]
08:23:12 <malcolmw> shapr: at about the same time, I changed the cmdline options so -anchorHTML and -anchorCSS disappeared to become -anchor + [ -html | -css ]
08:23:15 <ski_> zorg0f_ : sorry, can you rephrase that question ?
08:23:48 <lispy> zorg0f_: you could define lists backwards if that's what you're asking
08:24:24 <malcolmw> shapr: but hpaste probably uses the library API rather than the cmdline, so maybe not a breaking issue
08:24:28 <lispy> they could have been defined, data [] a = [] | [a] : a
08:24:38 <zorg0f_> '1':"ab" would equal "1ab".  is "ab":'1' valid?
08:24:42 <zorg0f_> no it's not
08:24:46 <zorg0f_> ok
08:24:53 <ski_> (zorg0f_ : you always add elements to the "same side" of a list using ':' (and that side is usually thought of as "left"/"front"/"top"))
08:25:04 <lispy> :t (:)
08:25:07 <lambdabot> forall a. a -> [a] -> [a]
08:25:11 <lispy> zorg0f_: does that help ^^
08:25:21 <thruspa> :-)
08:25:35 <zorg0f_> cool, that's just what i was checking - that elements are always added to the front using :
08:26:46 <zorg0f_> lipsy: ive got the kind of brain that works things out by looking at examples and explanations rather than looking at definitions =/ :(
08:27:22 <zorg0f_> but i understand it now :) thanks guys
08:27:50 <ski_> > let xs `snoc` x = xs ++ [x] in "foo" `snoc` 'f'
08:27:52 <lambdabot>  "foof"
08:29:42 <Baughn> @src (++)
08:29:42 <lambdabot> (++) []     ys = ys
08:29:42 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
08:30:21 <roconnor> ahh, my arch repository is corrupted
08:30:58 <Apocalisp> osfameron: Pong
08:33:21 <shapr> roconnor: Try darcs?
08:33:33 <shapr> Tom Lord is darcs archenemy.
08:33:46 <roconnor> :)
08:34:00 <roconnor> arch is an institutional choice
08:34:34 <Baughn> Hum. Around here we're still on CVS.
08:34:55 <toxic> cvs generates a lot of head ache
08:35:17 <Baughn> Not to worry. There's a full-time position in dealing with it.
08:35:25 <shapr> toxic: Was that a pun? HEAD ache?
08:36:25 <toxic> it is now when you mention it :P
08:36:26 <osfameron> Apocalisp: heya
08:36:52 <osfameron> Apocalisp: I was about to post my version of SOE 2.2 to the blog.  I wanted to quote your version too (as it's nicer), with credit.  Would that be OK ?
08:36:59 <roconnor> I solve my problem by deleting my corrupted pristine-tree
08:37:19 <zorg0f_> can a haskell function take a variety of types? i want to write a function that takes *something* and returns a set thing if it's an integer
08:38:00 <ski_> zorg0f_ : what should it return otherwise ?
08:38:00 <Apocalisp> osfameron: Yes, except the version I pasted doesn't work!
08:38:21 <zorg0f_> erm, an integer returns "1", say
08:38:28 <zorg0f_> not the string "1", the integer :p
08:38:31 <osfameron> Apocalisp: harr!  that shows me up as not having tried it ;-)  I just admired its concision
08:38:46 <osfameron> Apocalisp: do you have a working version along those lines ?
08:39:37 <Apocalisp> osfameron: I do. It was just a slight bug.
08:39:50 <Baughn> zorg0f_: You could presumably use a typeclass for that, though I'm not sure how to get around its instances being overlapping
08:40:06 <Baughn> zorg0f_: (One instance for Num a => a, one for.. everything else?)
08:40:35 <quicksilver> zorg0f_: you could use typeclasses to do tricks like that
08:40:52 <quicksilver> zorg0f_: but more idiomatic haskell to to make a new data type for the possibilities
08:41:18 <quicksilver> zorg0f_: data PossibleArg = ZorgInteger Int | ZorgString String | ZorgSomethingCool
08:41:21 <Apocalisp> osfameron: I did the convexity exercise last night. Fun stuff.
08:41:49 <zorg0f_> hrmmm
08:42:02 <osfameron> Apocalisp: yeah!  I finished exercises for Chapter 7 this morning.  I'm finding that the ones that don't involve maths are easier (for some funny reason) ;-)
08:42:09 <zorg0f_> then just have a function f :: PossibleArg -> Int ?
08:42:18 <quicksilver> zorg0f_: right
08:42:19 <osfameron> Apocalisp: did you go with the "keep on turning left" approach?
08:42:34 <Baughn> zorg0f_: Or did you want 'f :: a -> TypeID' ?
08:43:04 <zorg0f_> basically, i want a function that can take anything and will return the number 1 if "anything" is an integer
08:43:20 <Apocalisp> osfameron: The approach is basically rotate (0,r) by 360/n degrees, repeat n times.
08:43:47 <Baughn> zorg0f_: Would 'f :: Typeable a => a -> TypeID' work?
08:43:50 <Baughn> That one already exists
08:43:54 <Apocalisp> osfameron: When I have some time, I will make a version that uses no trig.
08:44:06 <osfameron> Apocalisp: er, for t isConvex question?
08:44:10 <quicksilver> zorg0f_: 'a function which can take anything' is not idiomatic haskell
08:44:10 <ski_> zorgOf :: Zorgable a => a -> Zorg
08:44:18 <Apocalisp> oh! For convex...
08:44:27 <quicksilver> zorg0f_: I don't say it's not possible; you can do things like that with typeclasses
08:44:29 <Baughn> zorg0f_: f = Data.Typeable.typeOf, perhaps
08:44:32 <quicksilver> zorg0f_: but it's not idiomatic
08:44:40 <quicksilver> zorg0f_: you're fighting the type system instead of using it
08:44:42 <Apocalisp> osfameron: here's my convex version... wait
08:44:55 <Baughn> zorg0f_: Probably it would help if you explained why you want this
08:45:12 <zorg0f_> my exercise is: "Give a definition, with type, for the Haskell function toone which given an
08:45:14 <zorg0f_> integer, returns the number 1."
08:45:33 <quicksilver> I believe you are misunderstanding your exercise
08:45:45 <quicksilver> I believe they are just asking you to write a function of type Integer -> Integer
08:45:49 <quicksilver> which returns 1 :)
08:45:54 <zorg0f_> :|
08:46:05 <zorg0f_> they can't be serious
08:46:10 <quicksilver> they are not (in my opinion) asking you to consider the case you might be given something other than an integer
08:46:32 <mauke> I interpret it as f :: (Integral a) => a -> a
08:47:17 <quicksilver> I think they just want: toone :: Integer -> Integer ; toone x = 1
08:47:27 * fasta goes with quicksilver 
08:47:30 <quicksilver> I suspect the point of the exercise is to make you notice that you need the type signature
08:47:36 <quicksilver> because if you just type 'toone x = 1'
08:47:41 <quicksilver> you get a more general type than you want
08:47:52 <quicksilver> :t let toone x = 1 in toone
08:47:55 <lambdabot> forall t t1. (Num t1) => t -> t1
08:47:55 <fasta> quicksilver: you don't need it
08:48:06 <Baughn> I'd just go with toone = const 1
08:48:06 <osfameron> like (const 1) ?
08:48:10 <malsyned> Is cabal-linstall stable enough to use on win32 with ghc 6.6.1?
08:48:10 <quicksilver> fasta: you need the type signature, to get the function they ask for in the question :)
08:48:10 <fasta> quicksilver: (but that's nitpicking)
08:48:23 <quicksilver> well my argument is that const 1 is too general
08:48:23 <mauke> toone x = 1 `asTypeOf` x
08:48:33 <osfameron> const 1::Integer  ?
08:48:34 <zorg0f> lol sorry - keep kicking out the power cord - i need a footrest instead of my case
08:48:37 <quicksilver> mauke: I seriously doubt they want that
08:48:43 <zorg0f> but yeah, you think that's all that's required?
08:48:43 <fasta> quicksilver: no, you can call some useless function that already requires an Integer as input
08:48:50 <quicksilver> mauke: this is a beginners set of first exercises
08:48:57 <quicksilver> fasta: oh, I see. Yes, of course.
08:49:01 <fasta> quicksilver: e.g. in a where clause (yes, this is pedantic)
08:49:05 <quicksilver> fasta: the type signature is the better answer :)
08:49:08 <Baughn> zorg0f_: Given an integer, your function should return 1. Is there any indication that it might be given anything /but/ an integer?
08:49:09 <quicksilver> fasta: but yes, I understand your point
08:49:24 <fasta> quicksilver: it depends on how much you want to show your 1337'ness
08:49:30 <zorg0f> 2 secs
08:49:37 <fasta> "look no type signatures"
08:49:52 <fasta> (as in "look no hands")
08:50:29 <Apocalisp> osfameron: just testing to make sure it works!
08:50:57 <thruspa> For integers, could it be possible to detect with a function isInt if some data object is integer?
08:51:02 <mauke> toone x = head [1, x, fromInteger x]
08:51:10 <thruspa> Without using classes, just a function.
08:51:21 <mauke> thruspa: what would be the type of that function?
08:51:38 <osfameron> Apocalisp:  :-)   Oh, but while you're there, if you have that version of regularPoly as well that would rock
08:51:38 <thruspa> isInt :: x -> Int
08:51:42 <zorg0f> the full question is "Give a definition, with type, for the Haskell function toone which given an integer, returns the number 1.". It's worth 4 marks out of 90 on a 75 minute past exam paper.
08:52:07 <quicksilver> zorg0f_: the answer is toone :: Integer -> Integer ; toone x = 1
08:52:11 <mauke> thruspa: you know nothing about that x so there are no operations you can use with it
08:52:15 <quicksilver> I am sure of this :)
08:52:19 <thruspa> I think it is possible, using (\ x y -> case x of y) applied to [1..] , and the negative integers.
08:52:21 <ski_> @free isInt :: x -> Int
08:52:21 <lambdabot> isInt = isInt . f
08:52:26 <Baughn> thruspa: It needs to at least be Typeable or similar
08:52:30 <quicksilver> thruspa: no, you can't
08:52:32 <thruspa> Pattern-match the whole integers, lazily :-)
08:52:42 <zorg0f> it's a basic taster course is functional programming but im suprised they gave something that basic :|
08:52:46 <quicksilver> thruspa: pattern-matching is typed
08:52:56 <quicksilver> zorg0f_: you have to have some questions to check the basics
08:53:05 <fasta> (Num a)=> Integer -> a would be the type I would write down.
08:53:05 <zorg0f> yeah, fair enough
08:53:18 <zorg0f> glasgow uni love to word questions ambiguously
08:53:30 <quicksilver> it's bloody difficult to write questions like that precisely
08:53:35 <Apocalisp> osfameron: I have this on another workstation actually. I'm just reconstructing from memory.
08:53:36 <thruspa> > > (\x y -> case x of y) 1 []
08:53:36 <lambdabot>  Parse error
08:53:42 <malsyned> Anybody know why "runghc Setup.lhs configure" on cabal-install might crash with "Warning: Unknown field 'build-type'"?
08:53:47 <thruspa> > > (\x y -> case x of y -> 1) 1 []
08:53:47 <lambdabot>  Parse error
08:53:48 <zorg0f> heh, i guess so
08:53:52 <ski_> > (\x y -> case x of y) 1 []
08:53:53 <lambdabot>  Parse error
08:53:54 <fasta> zorg0f: you need to know what the literal 1 means in Haskell
08:54:01 <ski_> > (\x y -> case x of y -> "foo !") 1 []
08:54:03 <lambdabot>  "foo !"
08:54:04 <quicksilver> thruspa: in a case statement, the 'y' part is a pattern binder
08:54:07 <fasta> zorg0f: it's quite a tricky question for newbies
08:54:11 <quicksilver> thruspa: you can't abstract over pattern binders
08:54:18 <osfameron> Apocalisp: oh, heh.  There's no massive hurry btw, just interested, and as I'd liked the regularPoly approach I wanted to cite it, it can wait till you're on another machine.
08:54:26 <zorg0f> fasta: lol
08:54:46 <thruspa> Anyway, for some reason I think it shouldn't work.
08:54:46 <fasta> zorg0f: I am sure someone would write down Integer -> Integer
08:55:24 <quicksilver> fasta: and I'm sure Integer -> Integer is the answer they want
08:55:42 <ski_> :t let toone _ = 1 in (toone :: Integer -> Integer)
08:55:44 <lambdabot> Integer -> Integer
08:55:53 <quicksilver> s/want/expect, and would happily award full marks for/
08:55:56 <ski_> see, 'toone' does have type 'Integer -> Integer' ! :)
08:56:21 <ski_> (it also has some other types as well, of coursE)
08:56:34 <fasta> zorg0f: see? Even quicksilver gives the wrong answer
08:56:36 <fasta> quicksilver: ;)
08:57:12 <fasta> I think both answers will be OK, though.
08:57:20 <zorg0f> stop trying to trick the noob ;)
08:57:38 * fasta doesn't like "guess-the-question-questions"
08:57:38 <zorg0f> :D
08:57:46 <zorg0f> yeah, agreed.
08:58:48 <zorg0f> earlier this week i had an exam on databases and the sample database was on "hotels", "rooms", and "keys"  - they started asking lots of ambiguous questions using "key" :|
08:58:52 <zorg0f> i think they do it on purpose tbh
08:59:20 <fasta> A better question would be: what is the type of tone in: tone b = 1 where a = <something to force the b into an Integer>
08:59:25 <Apocalisp> osfameron: I will send you the correct versions when I have them. In the meantime, here's the convexity test from memory.
08:59:25 <ski_> 'Map Key Room' ?
08:59:41 <quicksilver> fasta: that would be a much much harder question
08:59:50 <quicksilver> fasta: not one I would ask first-years
09:00:29 <Baughn> "What is the type of f x = 1, where x is of type Integer"?
09:00:44 <Baughn> ..no, the correct answer there is -> Num a
09:01:13 <Apocalisp> http://paste.lisp.org/display/41594
09:01:34 <ski_> :t f x = 1
09:01:36 <fasta> hpaste still offline.
09:01:37 <lambdabot> parse error on input `='
09:01:40 <quicksilver> Baughn: again, too hard :)
09:02:07 <sjanssen> @keal
09:02:07 <lambdabot> what are epsilons?
09:02:08 <Baughn> quicksilver: Exactly, but it seems hard to formulate it so both new students and those who've studied ahead get the right answer.
09:02:09 <opqdonut> :t let f x = 1 in f
09:02:12 <lambdabot> forall t t1. (Num t1) => t -> t1
09:02:15 <opqdonut> :)
09:02:27 <sjanssen> aww, hpaste is still down :(
09:02:36 <quicksilver> I don't know that I'd even expect 3rd year undergrads who'd done 3 programming courses to be able to replicate the principle type/typeclass algorithm on paper
09:02:38 <ToRA> quicksilver: imperial college, first year haskell practice test, question 1 is "what is the type of...if correct questions": http://www.doc.ic.ac.uk/~ajf/Teaching/Haskell/practiceTest.pdf
09:02:39 * sjanssen pokes shapr
09:03:03 <Apocalisp> osfam: http://paste.lisp.org/display/41594 <-- just to get the name highlight
09:03:06 <Apocalisp> grr
09:03:12 <Apocalisp> osfameron: ^^
09:03:13 <chitin> does this syntax to intersect elements in a in this fashion [x1 /\ x2, x2 /\ x3, x3 /\ x4, etc..] : map (\x x' -> x `intersect` x') xs
09:03:14 <osfameron> ta, just saw it
09:03:34 <osfameron> Apocalisp: I privmsg'd you my email if you don't catch me online later
09:03:37 <quicksilver> ToRA: yup, but I bet they don't expect you to do the typeclass stuff?
09:03:46 <osfameron> though I'm usually connected from screen so I can read backlog
09:04:22 <quicksilver> ToRA: erm, hang on
09:04:27 <quicksilver> ToRA: that question ask for values, not types :)
09:05:14 <ToRA> quicksilver: i'll concede the type classes
09:05:20 <quicksilver> chitin: no, map is not for binary functions
09:05:30 <_case> if i have nodes of my own defined tupel, being a string and an int. How would i check if the string is already in the binary search tree?
09:05:31 <ToRA> quicksilver: does being able to type check ==> being able to assign types?
09:05:31 <shapr> arjanoosting: Hey, when will the debian/unstable libghc6-filepath-dev be working with ghc 6.6.1 ?
09:05:35 <quicksilver> chitin: you possibly want zipWith or scanr
09:05:40 <quicksilver> ToRA: no, not really
09:05:42 <ski_> chitin : zipWith intersect xs (tail xs)  -- assuming 'xs' is not empty
09:05:45 <ToRA> quicksilver: but i'll agree without the typeclasses it gets a lot simpler
09:05:47 <quicksilver> ToRA: you can type check intuitively
09:05:53 <shapr> sjanssen: Sorry, if you want to update hpaste to work with the latest HAppS, I can restart it.
09:05:57 <quicksilver> ToRA: (for the purpose of answering undergraduate questions)
09:06:00 <chitin> thanks ski_ and quicksilver
09:06:08 <LoganCapaldo> I think I'd pass that test ToRA, huzzah
09:06:19 <quicksilver> ToRA: I imagine the only kind of thing the author of those questions is hoping for is 'you can't add a number to a string'
09:06:44 <quicksilver> ToRA: so, the 'zip' example is 'X' because zip needs two lists
09:06:46 <quicksilver> ToRA: and so on
09:06:57 <quicksilver> ToRA: this is easier than full principal type inference, let alone typeclass inference :)
09:07:04 <fasta> quicksilver: Type class type inference isn't documented correctly anywhere(outside of code), AFAIK, so I wouldn't too.
09:07:22 <LoganCapaldo> quicksilver: isn't the zip example given two lists?
09:07:31 <quicksilver> LoganCapaldo: oh, so it is. You win, I lose :)
09:07:40 <chessguy> @pl \p -> if p then True else False
09:07:41 <lambdabot> flip (flip if' True) False
09:07:42 <quicksilver> LoganCapaldo: I bet that caught out lots of undergrads, too :)
09:08:13 * lispy wishes if' was in the prelude
09:08:30 * ndm agrees with lispy
09:08:39 * LoganCapaldo agrees with ndm
09:08:54 * ndm notes that agreement is transitive
09:09:26 <fasta> ndm: it's symmetric
09:09:43 <lispy> is it reflexive too?
09:09:54 <ari> I disagree with myself :(
09:09:55 <quicksilver> I never agree with myself
09:09:55 <fasta> lispy: unless you are insane, yes
09:09:59 <quicksilver> life would be so boring, then
09:10:02 <ndm> depends if agreement is equivalence, or an ordering
09:10:06 <lispy> we could consider all the equivalence classes created by agreements
09:10:07 <quicksilver> quicksilver: you can shut up, too
09:10:19 <ndm> i.e. you agree with me, but you might support a stronger viewpoint, of which mine is a subset
09:10:33 <ndm> in which case its a partial order
09:10:56 <lispy> ndm: well, if you have a relation that is transitive, reflexive and symmetric it's an equivalence
09:11:15 <fasta> ndm: yes, it's an equivalence relation.
09:11:20 <ndm> lispy: yes, i'm not sure agreement is reflexive
09:11:47 <chessguy> in http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Calendar.html , i can't remember, what's the difference between Gregorian and Julian calendars?
09:11:48 <fasta> I am not sure applying logic to humans has any value.
09:11:48 <ndm> you want to kill Fred, I want to kill Fred and Bob - i agree with you, but you don't agree with me
09:11:49 <lambdabot> http://tinyurl.com/2x95nr
09:12:33 <fasta> ndm: you always agree on some subject.
09:12:35 <earthy> chessguy: Gregorian has been fixed and includes leap years and stuff
09:12:39 <earthy> julian doesn't
09:12:49 <earthy> IIRC
09:13:12 <chessguy> ah, ok
09:13:42 <_case> if i have nodes containing my own defined tupel, being a string and an int. How would i check if the string is already in a binary search tree?
09:14:04 <_case> how would i get the string from the node
09:14:42 <LoganCapaldo> _case: use your name :)
09:14:56 <LoganCapaldo> sorry I couldn
09:14:59 <LoganCapaldo>  resist
09:14:59 <_case> LoganCapaldo: geh
09:15:12 <fasta> It depends on how you model agreement. If you make it depend on the person who said it, it's not transitive.
09:15:35 <quicksilver> _case: are you trying to write your own binary search tree as a learning exercise? or would it be helpful to direct you to Data.Map ?
09:15:46 <LoganCapaldo> if its like data Tup = Tup String Int; do case tupVal of Tup s _ -> s
09:16:04 <_case> quicksilver, exercise
09:16:06 <LoganCapaldo> bwhahaa
09:16:06 <chessguy> > showGregorian $ fromGregorian 2007 5 22
09:16:10 <_case> LoganCapaldo, hmm
09:16:12 <lambdabot>   Not in scope: `fromGregorian'
09:16:28 <quicksilver> _case: then at each stage you check if you're lesser or greater and you recurse down the loeft or right branch as appropriate :)
09:16:35 <LoganCapaldo> At least assuming that was your acutal question
09:16:38 <chessguy> > showGregorian $ Data.Time.Calendar.fromGregorian 2007 5 22
09:16:38 <lambdabot>   Not in scope: `Data.Time.Calendar.fromGregorian'
09:16:43 <_case> tupVal is my own function right?
09:16:49 <quicksilver> chessguy: s/Data/Date/ ?
09:16:55 <LoganCapaldo> tupVal would be a value of type Tup
09:17:14 <chessguy> quicksilver: no, Data is the correct package
09:17:18 <chessguy> ?hoogle gregorian
09:17:18 <lambdabot> No matches found
09:17:28 <chessguy> apparently LB just doesn't know about it
09:18:04 <_case> LoganCapaldo, when would the case tupVal be called?
09:18:05 <chessguy> ?hoogle day
09:18:05 <lambdabot> System.Time.Day :: data Day
09:18:05 <lambdabot> System.Time.Friday :: Day
09:18:05 <lambdabot> System.Time.Monday :: Day
09:18:06 <quicksilver> chessguy: ah *nod*
09:19:15 <chessguy> ?hoogle CalendarTime
09:19:16 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
09:19:16 <lambdabot> System.Time.CalendarTime :: data CalendarTime
09:19:16 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
09:19:29 <LoganCapaldo> _case: I thought you were asking how do I get the string out of the datastructure. You'd use a piece of code like that to get at the string so you could compare it etc.
09:21:03 <chessguy> ?hoogle Month
09:21:03 <lambdabot> System.Time.Month :: data Month
09:21:04 <lambdabot> System.Locale.months :: TimeLocale -> [(String, String)]
09:21:04 <lambdabot> System.Time.ctMonth :: CalendarTime -> Month
09:21:07 <_case> LoganCapaldo, so if i would say Tup1 == Tup2, it would compare the two strings?
09:21:15 <quicksilver> yup
09:21:19 <_case> k
09:21:21 <quicksilver> because strings are in the typeclass 'Eq'
09:21:27 <quicksilver> and therefore can be compared with ==
09:21:30 <_case> let me try that one
09:21:35 <quicksilver> but you don't want to compare the whole tuples
09:21:38 <quicksilver> just the 'string bit'
09:21:43 <quicksilver> > "foo" == "foo"
09:21:46 <lambdabot>  True
09:22:16 <sjanssen> yay, somebody started an editor flamewar on haskell-cafe
09:22:43 <Saizan> ghc-6.6.1 is still via-C by default right?
09:22:47 <gour> sjanssen: war is over. vim won ;)
09:23:13 <sjanssen> gour: good
09:23:23 <gour> :-)
09:23:47 <sjanssen> I thought I might have to stop using it, seeing as it's 'from the 1970s'
09:24:00 <gour> lol
09:24:11 <chessguy> > calendarTimeToString $ CalendarTime 2007 May 22 0 0 0 0 Tuesday 0 "EST" 0 True
09:24:12 <lambdabot>   Not in scope: data constructor `Tuesday'
09:24:41 * chessguy sighs
09:25:17 <quicksilver> sjanssen: I regret feeding the flames, now
09:25:27 <quicksilver> sjanssen: I was actually hoping to shift it into an interesting debate
09:25:42 <quicksilver> (because good editors for effective coding are in my opinion an interesting topic)
09:25:52 <sjanssen> sur
09:25:53 <sjanssen> e
09:26:03 <chessguy> what the heck is wrong with that?
09:26:26 <cjeris> lots of good things are from the 1970s... like... uh... HP-35 calculators!
09:26:26 <chessguy> > Tuesday
09:26:27 <lambdabot>   Not in scope: data constructor `Tuesday'
09:26:46 <chessguy> > System.Time.Tuesday
09:26:47 <lambdabot>   Not in scope: data constructor `System.Time.Tuesday'
09:27:08 <quicksilver> cjeris: and my wife!
09:27:29 <sjanssen> quicksilver: I have a feeling the conversation would be significantly more productive if it didn't start with emacs/vim bashing
09:27:55 <quicksilver> sjanssen: well my intention was to try to draw him out on what kind of editor he preferred. It didn't work.
09:27:56 <chessguy> ?hoogle Tuesday
09:27:56 <lambdabot> System.Time.Tuesday :: Day
09:28:01 <chessguy> wtf
09:28:08 <quicksilver> chessguy: hoogle != lambdabot
09:28:16 <quicksilver> chessguy: they have different sets of packages available
09:28:49 <Baughn> ?hoogle [IO a] -> IO ()
09:28:50 <lambdabot> No matches, try a more general search
09:29:01 <quicksilver> :t sequence_
09:29:03 <chessguy> @type sequence_
09:29:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
09:29:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
09:29:08 <quicksilver> chessguy: win!
09:29:25 <sjanssen> chessguy: only a certain set of modules are availabe for '> '
09:29:43 <chessguy> yeah
09:29:47 <chessguy> that's annoying
09:29:51 <sjanssen> chessguy: this is to avoid '> System.Unsafe.unsafePerformIO ...'
09:29:59 <Baughn> ?hoogle Monad a => [
09:30:00 <lambdabot> No matches, try a more general search
09:30:09 <chessguy> sure, but why not just lock out System.Unsafe then'
09:30:09 <Baughn> ?hoogle Monad m => [m a] -> m ()
09:30:10 <lambdabot> Prelude.head :: [a] -> a
09:30:11 <lambdabot> Prelude.last :: [a] -> a
09:30:23 <Baughn> ..thanks, hoogle.
09:30:25 <quicksilver> chessguy: periodically dons adds newer packagse and stuff to it
09:30:35 <sjanssen> chessguy: there are too many holes.  Whitelisting is safer than blacklisting
09:30:45 <opqdonut> yep
09:30:50 <chessguy> true
09:30:53 <quicksilver> chessguy: if you want the calendar stuff in there, nudge him
09:31:26 <chessguy> bah, i generally don't care, just when i want a list of what months for the next year are going to have 2 paychecks, and which are going to have 3 :)
09:31:35 <chessguy> or the next n years
09:31:54 <sjanssen> chessguy: don't you have ghci on your machine?
09:31:58 <chessguy> not at work
09:34:02 <chessguy> that's ok, i'll just work out the algorithm, and write the code later
09:35:33 <mnislaih> why isn't there a liftM2 for functors, i.e. fmap2 ?
09:35:52 <sjanssen> mnislaih: I don't think that's possible
09:36:03 <quicksilver> mnislaih: functors don't generally have that structure
09:36:21 <quicksilver> > liftM2 (+) [0,1] [10,20]
09:36:23 <lambdabot>  [10,20,11,21]
09:36:33 <quicksilver> mnislaih: note that that answer tells me qutie a bit about the monad structure of []
09:36:41 <quicksilver> mnislaih: it uses much more than merely its functor structure
09:36:42 <mnislaih> yes
09:36:50 <mnislaih> neat
09:37:12 <quicksilver> I'm tempted to suggest that a working definition of liftM2 is enough to make a monad out of a functor
09:37:16 <quicksilver> but that's only a hunch :)
09:37:18 <Saizan> applicative has liftA2
09:37:28 <quicksilver> ah, that would suggest I'm wrong
09:37:33 <quicksilver> merely enough to make an 'applicative'
09:37:57 <mnislaih> and from there to a monad there's still a bind to jump
09:38:06 <byorgey> @src liftM2
09:38:06 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:42:40 <chessguy> @paste
09:42:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:42:46 <chessguy> guess again, lb
09:43:35 <quicksilver> mnislaih: sort of
09:43:48 <quicksilver> mnislaih: but my claim is that liftA2 gives you 'something about bind'
09:44:03 <quicksilver> mnislaih: certainly it restricts your choice of possible binds to those compatible with liftA2
09:44:10 <quicksilver> mnislaih: it might even constraint it uniquely
09:44:22 <Baughn> @src liftIO
09:44:22 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:44:35 <chessguy> does this look about right? http://paste.lisp.org/display/41599
09:44:53 <quicksilver> Baughn: LB can't do the src for methods unless you tell it the class name
09:44:58 <quicksilver> Baughn: instance name, I mean
09:45:05 <quicksilver> Baughn: and I normally cna't work out the syntax for that :)
09:45:07 <chessguy> ?src head
09:45:07 <lambdabot> head (x:_) = x
09:45:07 <lambdabot> head []    = undefined
09:45:17 <Baughn> ?src liftM
09:45:18 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:45:36 <quicksilver> :t groupBy
09:45:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
09:45:53 <LoganCapaldo> @src Maybe (>>=)
09:45:53 <lambdabot> (Just x) >>= k      = k x
09:45:54 <lambdabot> Nothing  >>= _      = Nothing
09:46:28 <quicksilver> chessguy: looks sane to me
09:46:35 <quicksilver> chessguy: gratuitious use of 'ap' :)
09:46:48 <chessguy> quicksilver: thank @pl :)
09:46:52 <quicksilver> chessguy: isn't there a 'map' missing though?
09:47:13 <chessguy> hm, oh yes
09:47:31 <quicksilver> chessguy: that's a rather good example, actualy
09:47:46 <quicksilver> chessguy: of code which is really elegant in haskell, but would be slightly messy in classic imperative stylee
09:47:47 <chessguy> i think i want:
09:47:49 <chessguy> result :: [[Date]] -> [(Month, Int)]
09:47:49 <chessguy> result = map $ ap ((,) . month . head) length
09:47:57 <quicksilver> yes, I think you want that, too :)
09:48:31 <chessguy> quicksilver: seems like there ought to be a more idiomatic way to do it, but i can't put my finger on it
09:48:32 <quicksilver> chessguy: the little loop to figure that out and compare with the last iteration, with a special case for the first in the list, etc
09:48:51 <quicksilver> chessguy: I think what you've written is goo. Although personally I wouldn't bother with the cute use of ap (,)
09:49:01 <chessguy> yes, i tend to write gooey code
09:49:12 <ToRA> map (month . head &&& length) ?
09:49:26 <quicksilver> hmm yes, I prefer ToRA 's
09:49:27 <assl0r> > [ w1, " ", w2 | w1 <- repeat "foo ", w2 <- repeat "bar ", w1 /= ' ', w2 /= ' ' ]
09:49:27 <lambdabot>  Parse error
09:49:42 <quicksilver> although I was going to say map (\ds -> (month $ head ds, length ds))
09:49:49 <chessguy> oh good call
09:49:58 <quicksilver> chessguy: good, not 'goo', if that isn't obvious :)
09:50:02 <ToRA> someday i'll find a use for arrows that isn't (,) combinators
09:50:16 <chessguy> quicksilver: it was obvious, but i was being gratuitously cute again
09:51:27 <chessguy> it seems like there should be more of a pipeline approach somehow
09:52:15 <assl0r> > [ w1 ++ " " ++ w2 | w1 <- repeat "foo ", w2 <- repeat "bar ", w1 /= ' ', w2 /= ' ' ]
09:52:17 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
09:52:24 <chessguy> i don't know, i guess it's ok
09:52:40 <quicksilver> chessguy: sure, you could join it all together
09:52:53 <chessguy> i guess that might get messy though
09:52:55 <quicksilver> chessguy: but I like nice named, individually understandable chunks like you have
09:53:01 <mauke> :t repeat
09:53:01 <chessguy> yeah
09:53:03 <lambdabot> forall a. a -> [a]
09:53:06 <ToRA> assl0r: w1 /= " "
09:53:08 <mauke> :t cycle
09:53:10 <lambdabot> forall a. [a] -> [a]
09:53:14 <ToRA> assl0r: (and w2)
09:53:23 <mauke> > [ w1 ++ " " ++ w2 | w1 <- cycle "foo ", w2 <- cycle "bar ", w1 /= ' ', w2 /= ' ' ]
09:53:23 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
09:53:47 <mauke> > [ [w1, ' ', w2] | w1 <- cycle "foo ", w2 <- cycle "bar ", w1 /= ' ', w2 /= ' ' ]
09:53:49 <lambdabot>  ["f b","f a","f r","f b","f a","f r","f b","f a","f r","f b","f a","f r","f ...
09:53:51 <assl0r> ToRA, wat is cycle?
09:53:55 <assl0r> what
09:53:59 <ToRA> > cycle [1]
09:54:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:54:11 <ToRA> > repeat [1]
09:54:12 <lambdabot>  [[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1]...
09:54:18 <Igloo> Any French speakers about?
09:54:22 <assl0r> ahh ;)
09:54:33 <ToRA> asslor: in your example you wanted [ w1 ++ ........., w1 /= " ", w2 /= " "
09:54:39 <mauke> ToRA: I doubt that
09:54:48 <ToRA> well to make it type check
09:54:50 <arcatan> my speakers have some contact problems
09:54:55 <jmelesky> Igloo: i speak French well for an American, but that may not be useful for you
09:54:56 <arcatan> the sounds goes all wobly
09:54:58 <mauke> ToRA: it would make the /= checks useless
09:54:59 <mux> Igloo: yes
09:55:14 * mux is a frog
09:55:23 <ToRA> i don't know what he actually wanted to do, but it was the shortest route i could think of to make it type-check.  And yes, with some thought you're right.
09:55:28 <Igloo> disponibilit of epuise and indisponible are both bad, right?
09:55:33 <assl0r> i want to switch the words in two maybe infinite input lists
09:56:03 <mux> Igloo: err, I don't get your question
09:56:04 <assl0r> because they are infinite i can't use the words function first on each input stream
09:56:09 <mux> Igloo: "disponibilit of epuise" ?
09:56:22 <Igloo> mux: If something says "Disponibilit : epuise" it's unavailable, right?
09:56:30 <mux> yep
09:56:32 <mauke> > words (cycle "foo ")
09:56:33 <assl0r> > words cycle "foo bar"
09:56:34 <lambdabot>  ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","fo...
09:56:34 <lambdabot>  Couldn't match expected type `String'
09:56:42 <Igloo> mux: And likewise "Disponibilit : indisponible"?
09:56:42 <mauke> > words (cycle "foo bar ")
09:56:44 <lambdabot>  ["foo","bar","foo","bar","foo","bar","foo","bar","foo","bar","foo","bar","fo...
09:56:47 <mux> Igloo: yes
09:56:51 <Igloo> OK, thanks!
09:56:52 <assl0r> mhm
09:56:53 <mux> Igloo: in that context they both mean the same thing
09:56:55 <mux> Igloo: yw
09:57:25 <Igloo> OK, thanks
09:57:50 <assl0r> but switching the words in a stream wouldn't work like that..
09:57:55 <chessguy> @pl \(x,y,z) -> y
09:57:56 <lambdabot> (line 1, column 6):
09:57:56 <lambdabot> unexpected ","
09:57:56 <lambdabot> expecting letter or digit, operator or ")"
09:57:56 <lambdabot> ambiguous use of a non associative operator
09:58:10 <chessguy> @pl f (x,y,z) = y
09:58:11 <lambdabot> (line 1, column 11):
09:58:11 <lambdabot> unexpected "="
09:58:11 <lambdabot> expecting variable, "(", operator or end of input
09:58:42 <chessguy> ?hoogle (a,b,c) -> b
09:58:43 <lambdabot> No matches, try a more general search
09:59:00 <chessguy> ?hoogle (a,b,c)
09:59:01 <lambdabot> No matches, try a more general search
09:59:27 <chessguy> @type (,,)
09:59:30 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
09:59:51 <chessguy>  @pl \(x, y, z) -> y
09:59:55 <chessguy> @pl \(x, y, z) -> y
09:59:55 <lambdabot> (line 1, column 7):
09:59:55 <lambdabot> unexpected ","
09:59:55 <lambdabot> expecting letter or digit, operator or ")"
09:59:55 <lambdabot> ambiguous use of a non associative operator
10:00:00 <chessguy> grrrrrrrrr
10:00:47 <LoganCapaldo> chessguy: IIRC pl doesn't do triples
10:01:30 <chessguy> are there not any standard functions on triples any more either?
10:03:01 <sioraiocht|sleep> has anyone here read any version of "how to think like a computer scientist"?
10:03:22 <LoganCapaldo> > let projectl (a, b, _) = (a, b) ; projectr (_, a, b) = (a, b) in snd . projectl $ (1,2,3)
10:03:23 <lambdabot>  2
10:03:33 <ToRA> > fmap (+1) (1,2,3)
10:03:34 <lambdabot>   add an instance declaration for (Functor ((,,) t t1))
10:03:34 <lambdabot>     In the expression...
10:03:44 <luqui> what, knowing that you will never know if you will ever stop thinking?
10:03:53 <LoganCapaldo> ToRA: can you even write that instance?
10:04:07 <LoganCapaldo> (I mean for (a,a,a))
10:04:28 <ToRA> fmap (+1) ("hello",3)
10:04:29 <ToRA> > fmap (+1) ("hello",3)
10:04:31 <lambdabot>  ("hello",4)
10:04:37 <LoganCapaldo> I guess so
10:04:40 <ToRA> it only applies on the last bit
10:04:43 <ToRA> so no you can't ;)
10:04:44 <LoganCapaldo> oh thats different
10:05:09 <ToRA> i guess you could manually write the instance decl?
10:05:23 <ToRA> but it doesn't seem to exist
10:05:29 <LoganCapaldo> I'd think you'd need a newtype wouldn't you?
10:05:34 <ToRA> i though there were curry/uncurry methods for triples etc, but i can't find them
10:05:48 <LoganCapaldo> @type uncurry3
10:05:50 <lambdabot> Not in scope: `uncurry3'
10:05:52 <ToRA> LoganCapaldo: could probably get away with type synonym instance
10:06:10 <cdsmith> @pl \f x y z -> f (x, y, z)
10:06:11 <lambdabot> (. (,,)) . (.) . (.)
10:06:42 <LoganCapaldo> I don't *think* you can use synonyms for instance decls. I could be wrong
10:06:48 <chessguy> @type \(x,y,z) -> y $ ?t ?d
10:06:50 <lambdabot> forall t t1 a b t2. (?t::t2 -> a, ?d::t2) => (t, a -> b, t1) -> b
10:07:06 <sioraiocht|sleep> LoganCapaldo: afaik you can't, there was a convo on haskell-cafe about that recently
10:07:09 <chessguy> @type (\(x,y,z) -> y) ?t ?d
10:07:11 <cdsmith> LoganCapaldo: I did so a few days ago (declared an instance for a synonym)
10:07:12 <lambdabot> forall t t1 t2 t3. (?t::(t, t2 -> t3, t1), ?d::t2) => t3
10:07:44 <LoganCapaldo> sioraiocht and cdsmith, fight it out! :)
10:07:48 <sioraiocht> lol
10:07:57 <luqui> cdsmith: well, if it was a synonym for something that you could normally declare an instance on...
10:08:29 <cdsmith> luqui: perhaps I missed some context.  I'll reread past discussion now.
10:09:37 <ToRA> ah, don't think you can -
10:09:39 <ToRA> type Triple a = ( a , a , a )
10:09:39 <ToRA> instance Functor Triple where
10:09:53 <ToRA> won't let me write the instance line, due to Triple not being fully parameterised
10:10:13 <ToRA> (even with LANGUAGE TypeSynonymInstances #-})
10:10:28 <Saizan> shapr: i have 2 patches that applied to hpaste-devel make it work with current HAppS
10:10:50 <chessguy> @pl f d = g !! (m d)
10:10:50 <lambdabot> f = (g !!) . m
10:12:58 <osfameron> how much does ICFP usually cost?
10:13:13 <osfameron> I can't see a price on any of the related websites
10:13:35 <ndm> osfameron: around 250 for registration, i think
10:14:20 <osfameron> ndm: thanks
10:14:32 <assl0r> how do i append a single Char to [Char] list?
10:14:33 <osfameron> meh.  that's not "community" level pricing.  But I am tempted
10:15:01 <tapi> char:charlist
10:15:07 <osfameron> well, I guess it is compared to OSCON etc.
10:15:15 <tapi> append...
10:15:20 <opqdonut> assl0r: charlist++[char]
10:15:48 <assl0r> doh... yeah
10:16:11 <Stinger> @pl \(a,b,c)->a
10:16:11 <lambdabot> (line 1, column 6):
10:16:12 <lambdabot> unexpected ","
10:16:12 <lambdabot> expecting letter or digit, operator or ")"
10:16:12 <lambdabot> ambiguous use of a non associative operator
10:16:26 <tapi> is there an easy way or reading binary data from a file ? my goal is to decode a bitmap (bmp) file
10:16:34 <malsyned> anybody here have experience with cabal-install?  esp. on win32?
10:17:08 <chessguy> @pl \(a,b) -> a
10:17:08 <lambdabot> fst
10:17:12 <tapi> i tried to deal with the Word* datatypes, but wasn't able to produce something useable...
10:17:24 <Stinger> is that the standard error when pl cant do something?
10:17:28 <assl0r> let i1 = cycle "foo "; i2 = cycle "bar " in [(w1:[]) ++ " " ++ (w2:[]) | w1 <- i1, w2 <- i2, w1 /= ' ', w2 /= ' ' ]
10:17:34 <Stinger> cause it seems like an odd message otherwise :)
10:17:40 <assl0r> > let i1 = cycle "foo "; i2 = cycle "bar " in [(w1:[]) ++ " " ++ (w2:[]) | w1 <- i1, w2 <- i2, w1 /= ' ', w2 /= ' ' ]
10:17:49 <lambdabot>  ["f b","f a","f r","f b","f a","f r","f b","f a","f r","f b","f a","f r","f ...
10:19:05 <assl0r> i want "bar foo bar foo..." ;(
10:19:38 <chessguy> > iterate ("bar foo" :) []
10:19:40 <lambdabot>  [[],["bar foo"],["bar foo","bar foo"],["bar foo","bar foo","bar foo"],["bar ...
10:19:49 <chessguy> mff
10:19:49 <arjanoosting> shapr: I will look after my Debian haskell packages after diner. It seems ghc 6.6.1 ships the filepath package already, so I need to look into that first
10:19:59 <chessguy> >concat $  iterate ("bar foo" :) []
10:20:08 <chessguy> > concat $  iterate ("bar foo" :) []
10:20:09 <lambdabot>  ["bar foo","bar foo","bar foo","bar foo","bar foo","bar foo","bar foo","bar ...
10:20:16 <chessguy> bah
10:20:17 <assl0r> noo
10:20:40 <shapr> Saizan: Send me the patches!!
10:20:43 <Vulpyne> Is there any way, when installing a package from HackageDB to add some compile flags to what gets passed to the compiler?
10:20:56 <assl0r> i1 and i2 are infinite strings of words (streams)
10:21:30 <chessguy> > foldr (\s1 s2 -> s1 ++ " " + s2) "" $ concat $  iterate ("bar foo" :) []
10:21:31 <lambdabot>   add an instance declaration for (Num [Char])
10:21:38 <ToRA> >  let odds = [1,3..] in let evens = [2,4..] in take 20 $ concat $ (zipWith (\a b -> [a,b])) odds evens
10:21:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
10:21:44 <tapi> > cycle "bar foo "
10:21:45 <lambdabot>  "bar foo bar foo bar foo bar foo bar foo bar foo bar foo bar foo bar foo bar...
10:21:49 <ToRA> is that kinda what you want?
10:22:29 <ToRA> >  let odds = (words (cycle "foo ")) in let evens = (words (cycle "bar ")) in take 20 $ concat $ (zipWith (\a b -> [a,b])) odds evens
10:22:31 <lambdabot>  ["foo","bar","foo","bar","foo","bar","foo","bar","foo","bar","foo","bar","fo...
10:22:40 <ToRA> >  let odds = (words (cycle "foo ")) in let evens = (words (cycle "bar ")) in take 20 $ concat $ concat $ (zipWith (\a b -> [a,b])) odds evens
10:22:42 <lambdabot>  "foobarfoobarfoobarfo"
10:22:51 <ToRA> >  let odds = (words (cycle "foo ")) in let evens = (words (cycle "bar ")) in take 20 $ unwords $ concat $ (zipWith (\a b -> [a,b])) odds evens
10:22:52 <lambdabot>  "foo bar foo bar foo "
10:22:56 <ToRA> (last try)
10:22:58 <tapi> isn't 'cycle "bar foo "' what you want ?
10:23:12 <tapi> ^^
10:23:13 <assl0r> no
10:24:00 <chessguy> tapi: he doesn't seem to be able to elucidate what he wants
10:24:42 <assl0r> > let i1 = "i hate this shit"; "man i really do" in cycle i2 . cycle i1
10:24:43 <lambdabot>  Parse error
10:25:03 <assl0r> > let i1 = "i hate this shit"; i2 = "man i really do" in (cycle i2) . (cycle i1)
10:25:04 <lambdabot>  Couldn't match expected type `b -> c'
10:25:22 <ToRA> assl0r: what is it about my last example that doesn't do what you want?
10:25:41 <tapi> does someone know how to cast a 16 bits (2 char) string into an unsigned int ?
10:26:19 <assl0r> mhm
10:26:33 <ToRA> sum . map $ ord  as a really weak guess?
10:26:46 <kpreid> tapi: a string of two Chars is *NOT* 16 bits
10:26:48 <ToRA> (eek brackets really wrong there)
10:27:00 <tapi> kpreid: that's what i was afraid of...
10:27:02 <malsyned> > concat (cycle "bar foo ")
10:27:03 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
10:27:26 <tapi> i want to read 2 bytes from a file, and cast it into an unsigned int
10:27:42 <tapi> could that be easily done ?
10:27:52 <malsyned> > concat (cycle ["bar foo "])
10:27:53 <lambdabot>  "bar foo bar foo bar foo bar foo bar foo bar foo bar foo bar foo bar foo bar...
10:29:45 <ToRA> read two Word8's (or just a Word16) and use fromIntegral or something?
10:30:11 <ToRA> (or toInteger since they are in Num...)
10:30:18 <assl0r> thx ToRA ;)
10:31:14 <ToRA> assl0r: np
10:32:21 <tapi> ToRA: i tried to go this way, but i don't know how to read a Word16 from a file (or a string)...
10:32:41 * rho is back
10:33:19 <ToRA> tapi: http://www.haskell.org/haskellwiki/UTF-8
10:33:21 <lambdabot> Title: UTF-8 - HaskellWiki
10:33:23 <ToRA> have a look at the bottom of that
10:33:31 <tapi> ToRA: thx
10:33:35 <ToRA> it shows how to read Word8's from a handle
10:34:03 <ToRA> then since Word8 is an instance of Num, you can treat it like an 8bit int
10:36:42 <shapr> Bah, I want everything from Hackage to be in @index and @src
10:36:48 <shapr> There must be an automatic way to do it.
10:37:04 <shapr> Saizan: send me the patches: shae@Scanned In Avian dah com
10:42:00 <shapr> Is there something like wget for Browser.browse? I just want to get the page contents as an IO String
10:42:02 <zorg0f> Given this function:      f x (y:ys) z = z:(map x ys)              would this be a correct type:      f::(y->z)->[y]->[z]        ?
10:42:33 <nominolo> shapr: there's the get.hs example on Network.HTTP
10:42:33 <zorg0f> sorry:        f::(y->z)->[y]->z->[z]
10:42:49 <tapi> ToRA: thanks, that's exactly what i was looking for ;)
10:43:23 <shapr> nominolo: ooh, handy!
10:43:44 <nominolo> shapr: i used it for my http+bytestrings benchmarks
10:45:08 <nominolo> @seen bringert
10:45:08 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
10:45:27 <bringert> hi nominolo
10:46:12 <nominolo> hi
10:46:39 <nominolo> seems where in fact aren't that far away from a releasable version for the http package
10:47:05 <nominolo> bringert: simonM noted that socketToHandle does indeed work for threaded setup
10:47:25 <nominolo> bringert: and the handle closing bug has been fixed recently
10:47:48 <nominolo> bringert: so we still don't have a nice high-level interface, but at least we have lazy bytestrings
10:48:23 <nominolo> and if someone treats them as eager bytestrings they just behave as if they had been eager bytestrings in the first place
10:48:41 <assl0r> @src words
10:48:41 <lambdabot> words s = case dropWhile isSpace s of
10:48:42 <lambdabot>     "" -> []
10:48:42 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:49:50 <shapr> nominolo: Oh, I liked that blog post! The dramatic improvement that came with lazy bytestrings was impressive!
10:49:56 <nominolo> bringert: the only thing that's missing is to be able to automatically close a socket once we're done reading its contents lazily.  though we can always call close explicitly if we're sure
10:50:24 <nominolo> shapr: heh, thanks.  yes, we were suprised ourselves
10:50:58 <assl0r> how do i import Prelude excluding words?
10:51:24 <Saizan> import Prelude hiding (words)
10:51:26 <nominolo> import Prelude hiding (words)
10:53:35 <bringert> nominolo: doesn't hGetContents do that?
10:53:52 <nominolo> bringert: only if it gets an EOF
10:54:07 <bringert> nominolo: ah
10:54:09 <nominolo> which again only happens if the server closes the socket
10:54:44 <nominolo> bringert: it doesn't prevent us from re-using the socket though.
10:55:32 <nominolo> bringert: that only means that, before we can handle the next request the previous request will be forced completly.  which is ovious, i assume
10:55:35 <bringert> doesn't hGetContents slurp up everything that will every appear on the socket?
10:55:49 <bringert> s/every/ever/
10:55:56 <nominolo> bringert: yes, exactly
10:56:26 <cinimod> @pl \x y z -> (x,(y,z))
10:56:27 <lambdabot> (. (,)) . (.) . (,)
10:56:45 <bringert> nominolo: ah, so you don't really reuse the socket, just the tail of the bytestring
10:56:49 <cinimod> @pl \w x y z -> (w,(x,(y,z)))
10:56:50 <lambdabot> (. ((. (,)) . (.) . (,))) . (.) . (.) . (,)
10:56:51 <nominolo> bringert: so if we want to reuse that socket and the server sends some garbage in between we'll read that.  though that would happen in any case, right?
10:57:03 <nominolo> bringert: yup
10:57:04 <bringert> sure
10:57:27 <cinimod> @pl \x y z -> ((x,y),z)
10:57:28 <lambdabot> ((,) .) . (,)
10:57:53 <bos> nominolo: did you see my comment about being able to use ByteString directly with Socket?
10:58:13 <nominolo> bos, no, where? on reddit?
10:58:28 <bos> on your blog.
10:58:31 <nominolo> bos: ahh no
10:58:39 <nominolo> bos: yes, i did
10:59:07 <bos> basically what you do is read a fixed-size chunk via the non-blocking interface, then use createAndTrim' to shrink the ByteString
10:59:08 <nominolo> bos: but according to simonM's comment i actually don't need to implement this
10:59:10 <bos> it's kind of fiddly.
10:59:11 <bos> ok.
11:00:03 <nominolo> bos, oh, now that i didn't understand.  what's the non-blocking part?
11:00:31 <nominolo> bos: you mean the function parameter to createAndTrim' ?
11:00:41 <bos> you can do a non-blocking read on the socket.
11:00:47 <bos> yeah.
11:01:14 <nominolo> bos, but that would re-alloc, wouldn't it?
11:01:32 <bos> hmm, hpaste is dead.
11:01:35 <bos> nominolo: no.
11:01:37 <nominolo> and AFAIU re-alloc means memcpy?
11:01:55 <bos> it reads directly into the buffer allocated, then trims the size down without moving the data.
11:02:20 <bos> the potential downside is that if you ask to read 65536 bytes and get 1 byte, you have a lot of extra memory allocated
11:02:28 <nominolo> ah, ok
11:04:38 <nominolo> thanks.  if we run into problems with the handle-based solution i'll try that
11:11:21 <shapr> Isn't there a test or check target for cabal?
11:14:09 * shapr reads http://www.haskell.org/ghc/docs/latest/html/Cabal/builders.html#setup-test
11:14:11 <lambdabot> Title: 3. Building and installing a package, http://tinyurl.com/ox63q
11:19:34 <nominolo> bringert: ok, toxic just volunteered to make a releasable version from our code
11:19:38 <nominolo> :)
11:21:17 <elrodeo> lambdabot > [1..3]
11:22:56 <bringert> nominolo: great
11:24:17 <bringert> nominolo: hGetContents uses blocking reads, iirc. wouldn't this cause problems if the server doesn't close the socket?
11:24:41 <bringert> nominolo: hGetContents would block waiting to fill the buffer, even after the ned of the response
11:24:47 <bringert> s/ned/end/
11:25:08 <nominolo> hm, i think we did tests and didn't find that problem
11:25:16 <nominolo> not sure though
11:25:47 <araujo> mm..
11:25:55 * araujo needs to study something very boring
11:26:06 <shapr> araujo: Tax law
11:26:35 <araujo> shapr, business systems theory
11:26:43 <shapr> Hm, I find that interesting actually.
11:27:00 <araujo> shapr, the subject sounds interesting
11:27:04 <araujo> but it isn't
11:27:07 <shapr> Tax law is painfully boring, mostly because it'd be so easy to fix :-(
11:27:15 <vegai> shapr: flat?
11:27:29 <shapr> vegai: flat what? flat rate VAT?
11:27:40 <vegai> would your solution be flat tax as well? :)
11:27:43 <nominolo> bringert: hm, yes it hangs
11:28:08 <nominolo> bringert: so what should we do in that case?  i guess we need a timeout or sth.
11:28:23 <bringert> nominolo: use non-blocking reads
11:29:18 <nominolo> i.e., return an empty string?
11:29:24 <nominolo> or truncated string
11:29:46 <bringert> hGetNonBlocking
11:30:16 <bringert> write your own hGetContents using hGetNonBlocking
11:30:25 <motus> hi folks, can someone help me with ffi in ghc? I have an opaque structure I have to pass by pointer to a bunch of functions; the problem is that I have to allocate it - is there a way to do it Haskell without extra functions in C?
11:30:26 <bringert> ByteString ought to have one really
11:30:43 <nominolo> ok
11:30:44 <sjanssen> I thought Data.ByteString.Lazy had non-blocking IO?
11:30:46 <helmut> any recommended reading on row polymorphism?
11:30:53 <sjanssen> maybe it didn't make it into base . . .
11:31:28 <Xgc> It was blocked.
11:32:20 <motus> i.e. C code looks like this: YPI_MSGINFO info; ypi_sendproxymsg(..., &info, ...); ... ypi_recvproxymsg(..., &info,...);
11:33:27 <sjanssen> bringert, nominolo: see Data.ByteString.hGetNonBlocking
11:33:47 <nominolo> bringert: i'm not quite sure if this will work.  since i'm calling hGetContents when i open the socket it might very well be the case that the server will have nothing to send yet
11:33:55 <sjanssen> an hGetContentsNonBlocking would be really handy too
11:34:40 <sjanssen> nominolo: you can do a hybrid approach
11:34:44 <motus> i.e. passing ptr into a foreign funtion is not a problem, but can I allocate the structure without defining it fully in Haskell or writing an extra C function? maybe I can do "foreign import ..." on a struct in .h file or something?
11:34:53 <nominolo> bringert: maybe we should extend this to the stream interface, too.  so that we can use it only for the actual contents, not the headers
11:35:10 <nominolo> sjanssen: no, hGetContents and hGet doesn't mix well
11:35:11 <sjanssen> do hWaitForInput handle 1; s <- hGetNonBlocking handle
11:35:24 <nominolo> sjanssen: oh
11:35:25 <sjanssen> nominolo: yes, you'll need to rewrite hGetContents
11:37:08 <nominolo> i'm still not sure this is the right approach.  since we read on demand, how should hGetContentsNonBlocking behave?  whenever we have a demand we insist on something being available or otherwise end the string and close the handle?
11:37:30 <bringert> sjanssen, nominolo: I think is what we want Data.ByteString.Lazy.hGetNonBlocking
11:37:48 <bringert> modolo correct english syntax
11:37:55 <sjanssen> :)
11:38:24 <sjanssen> nominolo: no, hGetContentsNonBlocking should only terminate on EOF
11:38:40 <nominolo> sjanssen: and otherwise?
11:38:49 <nominolo> loop?
11:38:57 <sjanssen> nominolo: it should return input whenever input is available
11:39:27 <sjanssen> you're writing HTTP stuff, right?
11:39:34 <nominolo> but the code that uses the lazy bytestring still gets blocked since it wants to read the next byte
11:39:39 <nominolo> sjanssen: right
11:39:57 <nominolo> bringert: no, hGet* reads all data at once
11:40:17 <nominolo> bringert: ie., they're not lazy
11:40:52 <bringert> nominolo: not Data.ByteString.Lazy.hGetNonBlocking
11:41:15 <sjanssen> are you sure Lazy.hGetNonBlocking is lazy?
11:41:24 <bringert> look at the code
11:41:28 <toxic> BSLazy.hGetContentsUntilNBytesThenClose h would rock
11:41:41 <toxic> + n
11:41:44 <bringert> see http://darcs.haskell.org/packages/base/Data/ByteString/Lazy.hs
11:41:51 <bringert> hGetNonBlocking :: Handle -> Int -> IO ByteString
11:41:52 <bringert> hGetNonBlocking = hGetNonBlockingN defaultChunkSize
11:41:56 <sjanssen> bringert: oops, it's even in the haddocks :)
11:42:24 <nominolo> oh
11:42:52 <sjanssen> so the server doesn't close the socket because you might make another request, and it will need to send more data?
11:42:55 <nominolo> then maybe it was different in dons' online-accessible source? hm.  ok then.  problem solved
11:43:26 <nominolo> ah no
11:43:29 <nominolo> it doesn't work
11:43:56 <nominolo> no, wait, i'm confused
11:43:59 * nominolo has to think
11:45:02 <sjanssen> by the way, Data.ByteString.Lazy.hGetContents uses non-blocking reads
11:45:27 <toxic> it reads whenever you really access it
11:45:58 <sjanssen> and only blocks when there is actually no data to be read
11:46:25 <sjanssen> as opposed to System.IO.hGetContents, which will use the blocking policy stored in the Handle
11:49:28 <jmob> How would I fold max over a lift of numbers?
11:49:47 <jmob> Is there a initial value that would always be less than any other number?
11:49:59 <jmob> ?h list.max
11:49:59 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . v
11:50:03 <sjanssen> jmob: depends on the numeric type
11:50:07 <koeien> depends on your type, if you use Int there is
11:50:16 <jmob> ?hoogle List.max
11:50:17 <lambdabot> No matches, try a more general search
11:50:23 <jmob> ?hoogle max
11:50:23 <lambdabot> Prelude.max :: Ord a => a -> a -> a
11:50:24 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
11:50:24 <lambdabot> Prelude.maxBound :: Bounded a => a
11:50:27 <shapr> Didn't someone figure out how to integrate HUnit and QuickCheck? Was that one of don's blog posts?
11:50:54 <sjanssen> jmob: the library maximum function makes 'maximum []' an error
11:50:58 <sjanssen> > maximum []
11:50:59 <lambdabot>  Exception: Prelude.maximum: empty list
11:51:07 <sjanssen> @src maximum
11:51:07 <lambdabot> maximum [] = undefined
11:51:07 <lambdabot> maximum xs = foldl1 max xs
11:51:10 <opqdonut> jmob: if the lists are empty you can use foldl1
11:51:13 <opqdonut> yes exactly
11:51:20 <motus> Hey ADEpt you are here! do you know ffi?
11:51:46 <encryptio> > True > False
11:51:47 <lambdabot>  True
11:51:50 <encryptio> cool.
11:52:09 <jmob> ah, cool
11:52:14 <opqdonut> > [False..]
11:52:14 <lambdabot>  Parse error
11:52:18 <opqdonut> > [False,..]
11:52:19 <lambdabot>  Parse error
11:52:22 <opqdonut> gah
11:52:25 <sjanssen> > [False ..]
11:52:26 <koeien> i think that is evil
11:52:26 <lambdabot>  [False,True]
11:52:29 <opqdonut> yeah
11:52:35 <ADEpt> motus: hi. no, not really. I've always been scared shitless by FFI, for no apparent reason :)
11:52:38 <nominolo> bringert, sjanssen: ah i remember, BS.Lazy does not have hGetLine
11:52:42 <sjanssen> opqdonut: False.. parses as the . operator from the False module
11:52:49 <opqdonut> ah okay
11:53:24 <sjanssen> nominolo: that is an odd oversight
11:53:49 <motus> ADEpt: mee too, until recently, but it turned out not that bad. still have to figure out some corner cases, though
11:53:52 <stepcut> I found the FFI stuff confusing until I stopped trying to use things like c2hs, and just used plain ffi plus a little help from hsc2hs
11:54:11 <stepcut> but, now I need to learning a higher level tool, because hsc2hs is slow going for big projects
11:54:19 <elrodeo> ,    -- 0 . ,   -      ,   
11:54:32 <opqdonut> nice, elrodeo
11:54:36 <nominolo> sjanssen: yup, but mixing strict and lazy didn't turn out so nicely.
11:54:37 <elrodeo> sorry
11:55:10 <sjanssen> nominolo: why not?
11:55:26 <nominolo> we had some problems with inverted order
11:55:44 <elrodeo> elrodeo test
11:55:53 <sjanssen> inverted order?
11:56:25 <nominolo> since hGetLine reads what's there immediately, but lzay hGet doesn't
11:56:28 <motus> stepcut: cool. so maybe you can help me with my question? can you please take a quick look at the log - http://tunes.org/~nef/logs/haskell/07.05.22 so I don't post it here again?
11:57:06 <nominolo> so whenever you call strict hGetLine you get what's in the socket, although, logically it belonged to some lazy stuff returned earlier
11:58:29 <bringert> shapr: andy gill sent me some HUnit - QuickCheck integration code a a while ago
11:58:31 <nominolo> meh, hGetLine is really long
11:58:53 <bringert> nominolo: why do you want hGetLine?
11:59:07 <nominolo> bringert: the stream interface needs it
11:59:16 <bringert> oh
11:59:23 <nominolo> i could re-add custom buffering though
11:59:25 <bringert> nominolo: you can change the Stream interface
11:59:26 <stepcut> motus: if I understand correctly, you just want to malloc memory to hold a data structure, and then you will pass a pointer to that memory to a foreign function ?
11:59:42 <nominolo> bringert: that would involve changing all the protocol parsing stuff too ;)
11:59:50 <motus> yes, except I don't know the size of the structure :-)
11:59:58 <nominolo> so, basically everything! ;P
12:00:29 <motus> stepcut: I mean, I don't know the size of the structure in Haskell.
12:00:52 <Vulpyne> How can I add flags to the compiler commandline when installing a package from HackageDB?
12:01:13 <stepcut> motus: right, is where hsc2hs comes into play
12:01:20 <Vulpyne> I have been looking through the documentation, and I don't see how it's possible.
12:01:52 <shapr> bringert: ohh, I want to see it!
12:01:53 <assl0r> is there a way to check if a list has further elements __without__ evaluating it completly?
12:01:53 <nominolo> bringert: it's ok to have it, i think.  i'll just add simple custom buffering.
12:01:58 <stepcut> motus: you use the (#size struct_name) to get the number of bytes in the structure
12:02:37 <assl0r> foo (x:xs) = if length xs /= 0 ... -- evaluates the complete list
12:02:43 <stepcut> motus: so, something like, allocaBytes (#size YPI_MSGINFO) $\ infoPtr -> ...
12:02:44 <motus> stepcut: I see. OK, thanks a lot! I will look at it. so that (#size struct_name) is it a hsc2hs construct?
12:02:45 <sjanssen> assl0r: null
12:02:49 <sjanssen> > null []
12:02:50 <lambdabot>  True
12:02:52 <sjanssen> > null [1]
12:02:53 <lambdabot>  False
12:02:56 <Vulpyne> assl0r: Pass it to something that pattern matches on [] and returns False or returns true otherwise?
12:03:07 <assl0r> ah okay
12:03:08 <assl0r> thx
12:03:09 <Vulpyne> Does anyone have any idea about my question?
12:03:21 <motus> stepcut: that's exactly what I need! cool, lemme try it. thanks for help!
12:03:24 <stepcut> motus: yes. Typically you name your source file .hsc instead of .hs, and then use hsc2hs to generate the .hs file
12:03:30 <sjanssen> Vulpyne: are you using cabal-install?
12:03:37 <stepcut> motus: or perhaps, ghc does that part automatically if you name the file .hsc
12:03:42 * stepcut forgets
12:03:46 <Vulpyne> sjanssen: I'm using the Setup.hs that came with the package.
12:04:00 <shapr> ooh
12:04:01 <sjanssen> Vulpyne: edit the ghc-options field in the .cabal file
12:04:21 <shapr> hpaste: @quit
12:04:25 <shapr> hmm
12:04:30 <Vulpyne> Ah, thanks.
12:04:36 <sjanssen> !quit
12:04:43 * shapr beats hpaste with the C-c stick
12:04:47 <Vulpyne> Guess that was kind of dumb. I looked at it, but missed that.
12:04:56 <jmob> hrmm... I'm getting better with monads, kind of scary
12:04:56 <sjanssen> shapr: maybe I don't have permissions.  I believe the commands start with !
12:04:57 <shapr> Saizan: You fixed hpaste! w00!
12:05:00 <shapr> Saizan++
12:05:10 <shapr> sjanssen: Nah, I think access isn't in the repo by default.
12:05:59 <motus> stepcut: nope, at least ghc 6.4 (this is what I have at work) does not recognize .hsc
12:06:11 <Vulpyne> sjanssen: It didn't call ghc with the options in that field.
12:06:16 <stepcut> motus: ok, I think I must have rules in my Makefile that do it for me
12:06:26 <Vulpyne> sjanssen: Perhaps because it's trying to build a C file?
12:06:29 <sjanssen> Vulpyne: you probably need to rerun configure
12:06:29 <Vulpyne> Using ghc.
12:06:33 <Vulpyne> Yep, I did.
12:06:36 <jmob> shapr: doesn't look fixed to me
12:06:47 <sjanssen> Vulpyne: yeah, a C file might be a different story
12:07:05 <Vulpyne> I really need to pass -I/usr/local/include or it dies horribly.
12:07:18 <Vulpyne> Is there a different field I could add which would control that?
12:08:15 <shapr> jmob: It works locally, now installing it on the server.
12:08:35 <nominolo> bringert: hm, mixing strict and lazy BS seems to work.  maybe i used hGetContents instead of hGet last time
12:09:37 <stepcut> Vulpyne:  'include-dirs: directory list' perhaps ?
12:09:48 <Vulpyne> stepcut: Just about to try that actually, thank you. :)
12:10:21 <Vulpyne> Woot! That fixed it. Thanks again.
12:10:52 <stepcut> yay!
12:12:45 * shapr rebuilds HAppS for the Nth time.
12:13:11 * stepcut rebuild shapr for the Nth+1 time
12:13:31 <Saizan> ah, so it's really a bot!
12:13:52 <shapr> But I'm not named Anna.
12:14:49 <psnl> I've met shapr, and he didn't look like a bot.
12:14:53 <bringert> nominolo: why do you need to have an IORef ByteString? can't you just read a line/block at a time?
12:14:57 <psnl> nor a Anna, for that matter.
12:14:59 <emu> what would a bot look like
12:15:07 <bringert> nominolo: looking at http://www.dtek.chalmers.se/~tox/darcs/http/Network/TCP.hs
12:15:08 <nominolo> bringert: yes i changed it
12:15:11 <psnl> emu: arnie, clearly.
12:15:25 <nominolo> bringert: it's now almost like the strict version
12:15:59 <nominolo> bringert: i only change the strict bytestring returned by hGetLine into a lazy bytestring
12:17:11 <nominolo> bringert: i think the first time it didn't work because i used hGetContents in readBlock since it didn't look like hGet was actually lazy
12:17:25 <nominolo> time to repeat the benchmark
12:21:11 <chitin> is there a more idiomatic way of doing this: jj n xs | all (n==) (take n xs) = take n xs | otherwise = jj n (drop 1 xs)  --I want it to return the first instance when n consequtive elements are equal
12:21:14 <shapr> psnl: So, what did I look like?
12:22:21 <psnl> shapr: younger than I expected...
12:23:44 <swiert> Has anyone here bought the latest edition of "Compilers: Principles, Techniques and Tools"?
12:23:45 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
12:24:08 <shapr> psnl: Well, I am young and inexperienced.
12:24:14 <cdsmith> swiert: I've got it, I think.  Why?
12:24:36 <swiert> Do you have any idea how it compares to previous versions?
12:24:47 <bringert> swiert: I have it
12:25:09 <bringert> swiert: haven't read it yet
12:25:20 <cdsmith> swiert: Hmm. No, because it's been years since I've even seen older versions.
12:25:20 <psnl> shapr: the photo of you trying to teach simonpj to unicycle has stuck in my mind.
12:25:32 <bringert> swiert: I think it has visitors now, iirc
12:25:32 <shapr> psnl: Um, where is that photo?
12:25:36 <malsyned> Is there a good tutorial out there for understanding comonads?
12:28:15 <psnl> shapr: it might have been edwinb, actually.
12:28:15 <Botje> chitin: jj n xs = head $ filter (\l -> length l == n) $ group xs -- something like this?
12:30:23 <Saizan> @google cellular automata comonadic
12:30:26 <lambdabot> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
12:30:27 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
12:30:37 <Saizan> @oldwiki comonad
12:30:37 <lambdabot> http://www.haskell.org/hawiki/comonad
12:30:49 <cdsmith> swiert: by comparing tables of contents, the intro is reworked.  The new edition drops operator precedence parsing and talks a lot more about LR parser... should I go on?
12:30:50 <ray> ooh
12:30:58 <ray> comonads, my favorite
12:31:18 <chitin> thanks Botje
12:31:50 <Saizan> ?src group
12:31:50 <lambdabot> group = groupBy (==)
12:31:54 <Saizan> ?src groupBy
12:31:55 <lambdabot> groupBy _  []       =  []
12:31:55 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
12:31:55 <lambdabot>     where (ys,zs) = span (eq x) xs
12:32:00 <Botje> chitin: your code searches for a group of n times n though
12:32:11 <Botje> i'm assuming that wasn't what you meant, going by your description
12:32:41 <chitin> Botje: well my code worked, just very slowly
12:32:51 <pjd> http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Comonads
12:32:52 <pjd> http://haskell.org/haskellwiki/Blog_articles#Comonads
12:32:55 <lambdabot> Title: Blog articles - HaskellWiki
12:32:57 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/fgd83
12:33:10 <shapr> segfaulted??
12:33:11 <dcoutts_> nominolo: you don't really want to use hGetLine, it's much slower than getting blocks and finding line breaks afterwards
12:33:24 <dcoutts_> it involves an extra copy via the Handle buffer
12:33:39 * shapr kicks hpaste
12:34:12 <nominolo> dcoutts_: ok.  it works for now, though.
12:34:20 <cdsmith> swiert: I guess you're gone?
12:34:40 <swiert> cdsmith: Sorry. Afk for a bit.
12:34:47 <Saizan> segfaults?
12:34:54 <swiert> cdsmith: Is it still mostly parsing?
12:35:19 <swiert> It's been on my amazon wish list for a while, but I'm in two minds whether or not to buy it.
12:35:36 <cdsmith> swiert: There's a little bit more non-parsing stuff.  I'd say about the first 1/2, slightly less, is parsing.
12:36:20 <psnl> shapr: damn, can't find it - must have been edwinb
12:36:27 <cdsmith> swiert: okay, I guess more like less than a third is parsing in terms of number of pages.
12:36:41 <nominolo> bringert: hGetContentsNonBlocking doesn't work
12:36:56 <swiert> cdsmith: Thanks for the info.
12:36:59 <nominolo> bringert: it just aborts whenever the server has a hickup
12:37:23 <cdsmith> swiert: ooh; looks like someone gutted the type checking chapter, and turned it into a subsection. :(
12:37:56 <Saizan> !paste -- stable?
12:37:56 <hpaste> Haskell paste bin: http://hpaste.org/
12:38:54 <nominolo> bringert: oh, and my program using LazyBytestrings now uses the full 175MB again
12:39:05 <nominolo> so it's obviously not lazy anymore
12:39:40 <stepcut> nominolo: to could be lazy, but holding on to data is does not need to be
12:40:07 <nominolo> stepcut: ?
12:40:09 <nominolo> ;)
12:40:29 <nominolo> stepcut: it worked before with 3mb overhead
12:41:14 <nominolo> i don't quite understand though.  maybe i have the wrong version of bytestrings
12:42:39 * shapr has a hissy fit
12:43:07 <stepcut> nominolo: for example, drop 100 [1..], is lazy, and in normally does not hold on to the first 100 elements, so the garabage collector can collect those
12:43:26 <Igloo> shapr?
12:43:56 <stepcut> nominolo: but, what if you managed to make a version of drop that accidently held onto the first 100 elements. It would still be lazy, but it would also have space leak...
12:44:39 <stepcut> nominolo: so, maybe your code is lazy and is using the correct bytestring, but has a space leak ?
12:45:15 <shapr> Igloo: I can't start screen for whatever reason. I tried "nohup ./hpaste 1>/dev/null 2>/dev/null" but then C-z and bg killed the process. What am I doing wrong?
12:46:03 <dcoutts_> nominolo: what do you mean about hGetContentsNonBlocking? do you think there is some bug in the impl?
12:46:07 <stepcut> shapr: ugh. That does not always work
12:46:20 <Heffalump> can you just start it with & in the first place?
12:46:37 <stepcut> shapr: disown maybe ?
12:46:41 <Igloo> Does it read from stdin?
12:46:54 <nominolo> dcoutts_: hGetNonBlocking.  if i read from the socket non-blockingly then it doesn't download the complete file
12:47:12 <dcoutts_> nominolo: can you be more specific?
12:47:21 <nominolo> dcoutts_: bringert didn't like that the client get's blocked if the server doesn't respond
12:47:30 <shapr> stepcut: Never heard of disown.
12:47:33 <shapr> Igloo: No, it doesn't
12:47:34 <dcoutts_> nominolo: right
12:47:39 <stepcut> shapr: it might be bash specific
12:48:07 <nominolo> dcoutts_: but i think this should be handled at a different level.  e.g., using timeouts in network.browser
12:48:21 <dcoutts_> nominolo: perhaps yes.
12:48:22 <stepcut> shapr: I think I have also seen people use a sub-shell, like, ( ./hpaste 1> /dev/null 2>/dev/null & ), or something to that effect
12:48:29 <stepcut> the parens are important in that line, btw
12:48:36 <shapr> stepcut: I'll try that.
12:49:38 <pjd> shapr: *just* C-z and bg?
12:49:40 <stepcut> shapr: http://www.redhat.com/archives/fedora-list/2004-April/msg05387.html
12:49:42 <lambdabot> Title: Re: kill xterm kills app!, http://tinyurl.com/23n5yw
12:49:53 <pjd> it must be mis-catching SIGCONT, or something
12:50:13 <nominolo> bringert, sjanssen:  Data.ByteString.Lazy.hGet *is* strict.  it does read in chunks but it reads them all!  note the STRICT1(readChunks)
12:50:28 <dcoutts_> nominolo: yes.
12:50:43 <dcoutts_> nominolo: only hGetContents is lazy
12:51:22 <nominolo> yes, so the implemention described in my post is correct
12:51:47 <dcoutts_> I've not seen that yet
12:52:06 <nominolo> it's on planet lisp
12:52:21 <TomMD> xmonad is now invite only?
12:53:10 <sjanssen> TomMD: hmm?
12:53:24 <sjanssen> TomMD: you seem to have joined successfully
12:53:33 <TomMD> That was a weird IRC message I just got.  I am in xmonad now, but the first two tries resulted in "#xmonad is invite only"
12:53:33 <dcoutts_> nominolo: is your blog syndicated on planet Haskell yet?
12:54:30 <nominolo> yes
12:54:39 <TomMD> Err - my bad "requires an invitation" and it was for "#monad" bahh
12:54:52 <nominolo> funny, though, i mixed some numbers.  it should be 175 MB instead of 375 MB
12:55:24 <bringert> nominolo: my complaint wasn't about the server not responding. it was that if the server doesn't close the socket, hGetContent can block waiting to fill the last block of the response, even though the full response has been sent
12:55:35 <nominolo> dcoutts_: http://nominolo.blogspot.com/2007/05/networkhttp-bytestrings.html
12:55:36 <lambdabot> Title: nominolo's Blog: Network.HTTP + ByteStrings
12:55:52 <nominolo> bringert: oh. well that's exaclty the problem i described then
12:56:14 <nominolo> bringert: that's why i wanted a function readN and close or something
12:56:38 <nominolo> or i'd have to implement a custom version of hGetContents
13:00:52 <shapr> stepcut: I can't figure it out. ( /bin/sh -c ./hpaste 1> /dev/null 2>/dev/null & ) doesn't work.
13:01:05 <stepcut> shapr: :(
13:01:24 <stepcut> shapr: that is the extent of my ideas :(
13:02:18 <stepcut> did you try, ( /bin/sh -c "./hpaste 1> /dev/null 2>/dev/null" & )
13:03:57 <nominolo> bringert: any other ideas?
13:06:07 <shapr> CosmicRay: Hey, did you get the patch?
13:06:14 <CosmicRay> yes
13:06:24 <CosmicRay> haven't had time to test yet
13:06:27 <CosmicRay> hopefully I will by tomorrow
13:06:31 <bringert> nominolo: just to make sure we're on the same page: you want to implement the Stream class for Sockets, right?
13:06:48 <nominolo> yes
13:06:50 <bringert> nominolo: so you need readLine   :: x -> IO (Result ByteString)
13:06:50 <bringert>     readBlock  :: x -> Int -> IO (Result ByteString)
13:07:04 <nominolo> writeBlock and close
13:07:18 <bringert> readLine could just be Lazy.hGetLine
13:07:27 <bringert> it doesn't have to be lazy
13:07:56 <nominolo> no
13:08:01 <bringert> readBlock could be a lazy hGet
13:08:16 <nominolo> lazy hGet is not possible
13:08:36 <nominolo> because a subsequent hGet would have to make sure that all previous ones were forced
13:09:00 <bringert> sure
13:09:06 <bringert> that could be done
13:09:11 <nominolo> how?
13:10:46 <bringert> hmm, maybe using the method that splitAtST in http://darcs.haskell.org/binary/src/Data/Binary/Get.hs uses
13:11:12 <bringert> well, that wouldn't be hGet, but rather a way to get hGetNonBlocking to work
13:11:51 <bringert> but yeah, it is a messy problem
13:13:05 <bringert> nominolo: you could change the type of readBlock to make using a single lazy BS nicer, since it's onyl used in a few places
13:14:23 <nominolo> yes, it's only used for the the message body
13:15:40 <shapr> !paste
13:15:40 <hpaste> Haskell paste bin: http://hpaste.org/
13:16:01 * shapr swears
13:17:33 * assl0r swears too
13:17:35 <byorgey> shapr: what's the problem?  (or is that the question?)
13:17:45 <assl0r> hpaste.org is down
13:18:24 <byorgey> assl0r: I know, I meant, why does hpaste keep dying?
13:19:04 <shapr> byorgey: Mostly user error.
13:20:35 <shapr> I could either startup a new blank hpaste, or I could try to fix the existing state.
13:21:44 * shapr gives up and starts a blank hpaste
13:23:53 <olsner> I've got a problem with retained structures... what should be basically a linear traversion of a file seems to retain the entire file before doing anything
13:24:23 <olsner> @paste
13:24:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:24:36 <hpaste>  assl0r pasted "wrong idention...?!??" at http://hpaste.org/0
13:24:59 <assl0r> hpaste, u are ugly!
13:25:23 <hpaste>  shapr pasted "test paste" at http://hpaste.org/1
13:25:43 <Heffalump> can you get the number to start from where the old number was?
13:26:14 <shapr> assl0r: I just fixed that!
13:26:25 <shapr> I had forgotten to copy the static files over from eric's account.
13:26:45 <hpaste>  (anonymous) annotated "wrong idention...?!??" with "(no title)" at http://hpaste.org/0#a1
13:27:09 <Igloo> assl0r: Your parens don't match
13:28:01 <assl0r> what?
13:28:03 <Igloo> assl0r: Having () in your datatype is also a bit odd
13:28:11 <hpaste>  olsner pasted "Retained structures" at http://hpaste.org/2
13:28:52 <nominolo> shapr: could you maybe let the new pastes start at 2000, so that you could optionally add the old pastes later on?
13:29:09 <assl0r> Igloo, how would i do that more elegantly?
13:29:19 <Igloo> Do what?
13:29:34 <assl0r> an imbalanced bintree
13:29:46 <Igloo> Just don't put anything there
13:29:58 <assl0r> mhm
13:29:59 <Igloo> ... | KnotenL a (BinBaumFlexibel a) | ...
13:30:49 <Igloo> (it's not really a question of balance, as the tree could be unbalanced even with only the first and last constructor)
13:32:10 <assl0r> but a question whether it may have more than 2 children per node?!
13:33:00 * Igloo can't parse that
13:36:48 <_case> what's wrong with this Eq? instance Eq Resultaat where
13:36:48 <_case> Resultaat naam1 cijfer1 == Resultaat naam2 cijfer2 = naam1 == naam2
13:36:55 <assl0r> Igloo, expect that what you noted, why does the interpreter complains about incorrect idention?
13:36:59 <_case> data Resultaat = Resultaat String Int
13:37:17 <Igloo> assl0r: Because your parentheses aren't matched
13:37:29 <_case> i wan't Resultaat to be equal when the first argument matches
13:37:45 <assl0r> Igloo, i've checked them double... :(
13:37:49 <assl0r> twice
13:37:51 <assl0r> argh
13:38:57 <Igloo> assl0r: Only two of the three in "(KnotenR 18 ( KnotenLR 34 (" are closed
13:39:09 <assl0r> i should always use vi
13:39:21 <assl0r> :)
13:39:21 <Igloo> vim, yes  :-)
13:40:01 <hpaste>  (anonymous) annotated "wrong idention...?!??" with "(no title)" at http://hpaste.org/0#a2
13:40:23 <hpaste>  (anonymous) annotated "wrong idention...?!??" with "(no title)" at http://hpaste.org/0#a3
13:40:32 <pjd> silly question:
13:41:19 <pjd> you know how fmap in the Reader monad/functor is like function composition?
13:41:53 <pjd> what's the intuitive interpretation of join and bind in this context?
13:43:19 <sjanssen> join applies an argument twice
13:44:24 <sjanssen> f >>= g -- applies an argument, 'x', to both f and g, then applies the result of (f x) to g
13:44:40 <sjanssen> > join (++) "hello"
13:44:42 <lambdabot>  "hellohello"
13:45:40 <sjanssen> erm, applies (f x) to (g x) -- g x (f x)
13:49:52 <hpaste>  assl0r pasted "???" at http://hpaste.org/3
13:52:10 <kpreid> assl0r: your usage of KnotenB is incorrect
13:54:28 <assl0r> precisely?
13:55:26 <kpreid> the parentheses following it are inappropriate
13:56:05 <byorgey> _case: what error are you getting?
13:56:21 <kpreid> you're specifying an application of BlattF 45 to BlattF 68, which won't work as BlattF 45 is a type, not a type specifier; you're also giving KnotenS 2 parameters instead of 3
13:57:06 <olsner> @src mapMaybe
13:57:07 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:57:24 <kpreid> olsner: fmap
13:57:39 <kpreid> @src Maybe fmap
13:57:40 <lambdabot> fmap _ Nothing       = Nothing
13:57:40 <lambdabot> fmap f (Just a)      = Just (f a)
13:57:54 <olsner> :t mapMaybe
13:57:57 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
13:58:14 <olsner> for filtering out all Nothings from a list of Maybes
13:58:29 <kpreid> oh
13:58:31 <fasta> olsner: catMaybe
13:58:47 <fasta> olsner: trivial to see when you do :browse Data.Maybe
13:59:00 <nominolo> > do r <- newSTRef 4; readSTRef r
13:59:00 <lambdabot>   Not in scope: `readSTRef'
14:00:45 <olsner> I just wanted to see how mapMaybe was implemented... something in my program is causing everything to be retained, when I know that it should be able to process one item then forget it
14:01:14 <olsner> (and what I wanted was mapMaybe)
14:01:46 <nominolo> > runST $ do r <- newSTRef 4; readSTRef r
14:01:47 <lambdabot>   Not in scope: `readSTRef'
14:01:57 <nominolo> ?hoogle readSTRef
14:01:58 <lambdabot> Data.STRef.readSTRef :: STRef s a -> ST s a
14:08:22 <pjd> sjanssen: and return discards an argument
14:09:08 <pjd> ok, i think i see how it fits together
14:12:43 <ndm> Hi #haskell
14:12:54 <ndm> i'm going to add pragma
14:12:57 <ndm> 's to Catch
14:13:26 <ndm> i was thinking of {-# PARTIAL funcname1 funcname2 #-}
14:13:29 <ndm> was my thought
14:13:45 <assl0r> kpreid: thx
14:14:35 <ndm> anyone got any thoughts?
14:14:50 <ndm> or any things i should bare in mind to keep them more useful?
14:16:29 <monochrom> What does PARTIAL funcname1 funcname2 do?
14:17:03 <sieni> I have always wondered why some people have problems with correct spelling of homonphones...
14:17:06 <ndm> declares that the listed functions may return _|_
14:17:07 <sieni> homophones
14:17:24 <ndm> i.e. {-# PARTIAL head, tail #-}
14:17:46 <ndm> in order to make Catch give a warning that the function is partial, rather than an error
14:17:47 <Heffalump> bah, what is it about Valentines Day. Why do people actually pay attention to this commercialised crap?
14:17:54 <ndm> Heffalump, women!
14:18:05 <Botje> Heffalump: because lots of other people are :]
14:18:20 <Heffalump> mine doesn't!
14:18:26 <ndm> Heffalump, i have no problem with a randomly chosen date relating to a random saint - but its hard convincing a g/f of that
14:18:27 <Botje> and not doing so inevitably would result in "why didn't you buy anything for me? don't you love me? waa waa!"
14:18:45 <ndm> Heffalump, then you chose well...
14:19:14 <Heffalump> she does get flowers at some random point after Valentines Day. And she did remind me I'd failed to produce them yet this year the other day.
14:20:15 <encryptio> :t fmap Just
14:20:17 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (Maybe a)
14:20:48 <ndm> Heffalump, so she merely has a displaced valentines day
14:21:10 <kilimanjaro> Heffalump, just tell her that tomorrow is still after Valentines Day :)
14:21:25 <Heffalump> so far I've had three reminders about Valentines Day, one issue with the Chinese New Year and one mention of school half-terms (in trying to find a date for Fun in the Afternooon for Feb 08)
14:21:35 <Heffalump> ndm: yes, but without the commercialised crap.
14:21:45 <Heffalump> or indeed any duty to be available on a certain date
14:21:57 <ndm> you are doing it way in advance though
14:22:23 <Heffalump> yeah, I guess only general things like that will be booked up
14:22:38 <Heffalump> I need to book the room asap, is the reason.
14:25:03 <ndm> Colin prebooked the room for 6 afternoons
14:25:07 <byorgey> @src quot
14:25:08 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:25:13 <ndm> then now just cancels 5 of them
14:25:29 <byorgey> is there a difference between quot and div?
14:25:33 <Heffalump> I doubt I could get away with that.
14:26:26 <ndm> yeah, i was impressed that Colin thought of that
14:26:40 <ndm> > -12 `quot` 5
14:26:42 <lambdabot>  -2
14:26:45 <ndm> > -12 `div` 5
14:26:46 <lambdabot>  -2
14:26:57 <ndm> oh, yes, they are entirely different
14:27:05 <ndm> apart from on that particular example :)
14:27:12 <byorgey> I see. =)
14:27:14 <ndm> > 17 `div` 5
14:27:15 <lambdabot>  3
14:27:17 <ndm> > 17 `quot` 5
14:27:18 <lambdabot>  3
14:27:29 <sieni> -5 `div` 5
14:27:31 <emu> @src quot
14:27:31 <sieni> eiku
14:27:31 <lambdabot> Source not found. That's something I cannot allow to happen.
14:27:33 <ndm> > 12 `quot` -5
14:27:33 <lambdabot>      precedence parsing error
14:27:33 <lambdabot>         cannot mix `quot' [infixl 7] and prefix...
14:27:35 <sieni> > -5 `div` 5
14:27:36 <lambdabot>  -1
14:27:39 <sieni> > -5 `div` 3
14:27:40 <lambdabot>  -1
14:27:41 <ndm> > 12 `quot` (-5)
14:27:42 <lambdabot>  -2
14:27:43 <fasta> > tail []
14:27:44 <sieni> > -5 `quot` 3
14:27:44 <lambdabot>  Exception: Prelude.tail: empty list
14:27:45 <lambdabot>  -1
14:27:46 <ndm> > 12 `div` (-5)
14:27:47 <lambdabot>  -3
14:28:00 <sieni> > -5 `mod` 3
14:28:01 <ndm> ah, the difference is when the divisor is negative
14:28:02 <lambdabot>  -2
14:28:02 <byorgey> aha
14:28:06 <byorgey> indeed
14:28:11 <ndm> one rounds towards zero, one rounds downwards
14:28:13 <emu> > 12 `mod` (-5)
14:28:15 <lambdabot>  -3
14:28:21 <sieni> > -5 `rem` 3
14:28:22 <lambdabot>  -2
14:28:44 <byorgey> oh, I see... div goes with mod, and quot goes with rem
14:29:32 <sieni> wtf? why is -5 `mod` 3 wrong?
14:29:47 <sieni> It should be 1 or somebody has been a complete idiot
14:31:06 <Saizan> i just wish to point out that -5 `quot` 2 is parsed as -(5 `quot` 2)
14:31:18 <ndm> ah!
14:31:22 <ndm> those silly negative literals
14:31:31 <sieni> (-5) `quot` 2
14:31:38 <sieni> > (-5) `quot` 2
14:31:39 <lambdabot>  -2
14:31:46 <Saizan> > (-5) `div` 2
14:31:47 <lambdabot>  -3
14:31:52 <sieni> (-5) `mod` 2
14:31:57 <sieni> > (-5) `mod` 2
14:31:58 <lambdabot>  1
14:32:02 <sieni> huh
14:32:32 <sieni> Saizan: thanks for restoring my trust to saneness of the designers of Haskell
14:32:51 <Saizan> aside from the unary minus thing :)
14:33:25 <Heffalump> I blame the designers of Maths.
14:33:27 <sieni> Saizan: it is interesting that this is not noted on the following page: http://www.zvon.org/other/haskell/Outputprelude/mod_f.html
14:33:28 <lambdabot> Title: Haskell : mod
14:34:22 <Saizan> > -33 `mod` -12
14:34:23 <lambdabot>      precedence parsing error
14:34:23 <lambdabot>         cannot mix `mod' [infixl 7] and prefix ...
14:34:49 <Saizan> > show (-33)
14:34:49 <assl0r> how do breakline long strings?
14:34:50 <lambdabot>  "-33"
14:34:55 <sieni> > (-33) `mod` (-12)
14:34:56 <lambdabot>  -9
14:35:04 <assl0r> "....... \\n"..." doesn't work
14:35:33 <Saizan> assl0r: you want to write long string literals across multiple lines?
14:35:42 <assl0r> yeah
14:36:01 <assl0r> foo = "long baaaaaaaaaar"
14:36:35 <kpreid> assl0r: "........\        \......"
14:36:39 <Saizan> foo = "long \ <actual newline here> \baaaar"
14:36:53 <assl0r> ah thx
14:36:57 <kpreid> note: last time I tried, it didn't work right in >-style lhs
14:37:14 <kpreid> I might have been doing something else odd, though
14:38:04 <nominolo> hm, who do i have to ask to get access to darcs.haskell.org?  (for SoC purposes)
14:38:23 <nominolo> (or "whom"?)
14:39:02 <dcoutts> nominolo: ask SyntaxNinja
14:39:07 <dcoutts> heh
14:39:10 <dcoutts> hia SyntaxNinja
14:39:12 <nominolo> rofl
14:39:20 <nominolo> hej SyntaxNinja
14:39:23 * Daveman pets lambdabot
14:40:05 <ndm> nominolo, it should be JaffaCake, I think
14:40:19 <SyntaxNinja> y0y0
14:40:25 <SyntaxNinja> how's everyone today?
14:40:26 <ndm> i need to sort out access for my SoC student
14:40:37 <nominolo> SyntaxNinja: can you give me access to darcs.haskell.org?  (for SoC)
14:40:54 <nominolo> SyntaxNinja: or should i ask simonM as ndm says
14:41:01 <SyntaxNinja> nominolo, ndm, who don't we try something new actually :)
14:41:25 <ndm> community.haskell.org?
14:41:36 <SyntaxNinja> yeah, but it doesn't have a name yet; it's just an IP address
14:41:37 <nominolo> SyntaxNinja: ah, the guinnia pig part?
14:41:41 <SyntaxNinja> yeah
14:41:50 <SyntaxNinja> dcoutts: want to give him/them an account?
14:42:06 <nominolo> btw, SyntaxNinja, you got mail (not from aol)
14:42:19 <ndm> SyntaxNinja, if i email you my students public key, can you set it up and email us back instructions?
14:42:41 <dcoutts> SyntaxNinja: I can give nominolo an account on "community.haskell.org" yes.
14:42:56 <ndm> or should i be emailing dcoutts?
14:43:04 <SyntaxNinja> ndm: try dcoutts :)
14:43:08 <dcoutts> @yarr!
14:43:08 <lambdabot> Smartly me lass
14:43:22 <SyntaxNinja> I can do it too, but it's good as a test to let duncan do it :)
14:43:30 <robertfunfun> i'm trying to make a function that takes in a list and outputs it with a gap in the middle of it and i'm using
14:43:31 <robertfunfun> --splitlist -- splits list in the middle
14:43:31 <robertfunfun> splitlist :: [a] -> String
14:43:32 <robertfunfun> splitlist [a] = take (length [a]/2) [a] ++ " " ++ drop (length [a]/2) [a]
14:43:58 <robertfunfun> but when i load the file, i get Hugs> :l hugsfiles/intinset.hs
14:43:59 <robertfunfun> ERROR "hugsfiles/intinset.hs":32 - Inferred type is not general enough
14:43:59 <robertfunfun> *** Expression    : splitlist
14:43:59 <robertfunfun> *** Expected type : [a] -> String
14:43:59 <robertfunfun> *** Inferred type : [Char] -> String
14:44:02 <sjanssen> hey SyntaxNinja, the xmonad team is interested in hosting on the new community server.  Is this possible?
14:44:18 <robertfunfun> anyone got any ideas?
14:44:33 <mauke> robertfunfun: " " is a [Char], not an [a]
14:44:49 <mauke> wait
14:45:01 <mauke> robertfunfun: how can you convert a to Char in your function?
14:45:01 <ndm> dcoutts, you too have mail
14:45:09 <dcoutts> SyntaxNinja: can we get a dns names sorted out for the new server, did we decide on "community" vs "hackage" ? (I prefer the latter I think)
14:45:20 <ndm> i prefer community
14:45:25 <nominolo> dcoutts: so i should send you my sshkey.pub?
14:45:33 <ndm> hackage should be reserved for the releaed side of things, i would have thought
14:45:41 <Botje> robertfunfun: your use of ++ " " forces the input to be of type [Char]
14:45:42 <ndm> hackage is distributing all haskell code
14:45:54 <Botje> since ++ only works on lists of equal type
14:46:00 <ndm> community is for writing some
14:46:02 <SyntaxNinja> dcoutts: I'd prefer hackage, but that would require moving other stuff or changing links or something, which is something that someone would have to organize :)
14:46:09 <dcoutts> SyntaxNinja: hmm, I can't seem to ssh in at the moment, not sure what's wrong.
14:46:19 <SyntaxNinja> ndm: but I think hackage will probably want to move to that server
14:46:27 <robertfunfun> so how do i do what i'm trying to do
14:46:29 <Botje> robertfunfun: perhaps you can use show to convert the two halves into strings, then join with ++ ?
14:46:46 <robertfunfun> show?
14:46:48 <dcoutts> SyntaxNinja: well, not a whole lot, since most things that are acessible via hackage.h.o are more commonly known by the darcs.h.o name
14:46:53 <nominolo> robertfunfun: either change the type or add a parameter for what to fill into the gap
14:46:59 <dcoutts> SyntaxNinja: it's just the hackagedb and the trac instances iirc
14:47:08 <Botje> > let splitlist [a] = (show $ take (length [a]/2) [a]) ++ " " ++ (show drop (length [a]/2) [a]) in splitlist [1..10]
14:47:09 <lambdabot>  Couldn't match expected type `Int -> [t] -> [Char]'
14:47:15 <dcoutts> SyntaxNinja: I really can't seem to ssh in, and no ping
14:47:21 <Botje> > let splitlist [a] = (show $ take (length [a]/2) [a]) ++ " " ++ (show $ drop (length [a]/2) [a]) in splitlist [1..10]
14:47:22 <lambdabot>   add an instance declaration for (Fractional Int)
14:47:26 <Botje> argh
14:47:42 <Botje> > let splitlist l = (show $ take (length l`div`2) [a]) ++ " " ++ (show $ drop (length l`div`2) [a]) in splitlist [1..10]
14:47:43 <lambdabot>   Not in scope: `a'
14:47:55 <Botje> > let splitlist l = (show $ take (length l`div`2) l) ++ " " ++ (show $ drop (length l`div`2) l) in splitlist [1..10]
14:47:56 <lambdabot>  "[1,2,3,4,5] [6,7,8,9,10]"
14:48:03 <Botje> like that. *sigh*
14:48:19 <robertfunfun> ace thanks
14:48:42 <Botje> robertfunfun: although you might want to take a look at the standard splitAt function
14:49:03 <Botje> > let l = [1..10] in splitAt (length l`div`2)
14:49:05 <lambdabot>  Add a type signature
14:49:07 <robertfunfun> does that do what i;m doing?
14:49:14 <Botje> > let l = [1..10] in splitAt (length l`div`2) l
14:49:15 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
14:53:29 <zorg0f> is there somewhere where i can look at the definitions for all the haskell functions? foldr, map, etc.
14:54:01 <Botje> zorg0f: hoogle is nice
14:54:13 <Botje> haskell.org/hoogle
14:54:33 <Botje> all standard functions are described in http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
14:54:36 <lambdabot> http://tinyurl.com/ovjef
14:54:45 <luqui> hoogle doesn't give implementations, though, does it?
14:55:15 <zorg0f> nah, it doesnt :(
14:55:43 <zorg0f> im looking for the function definitions i.e. implimentations.
14:56:02 <DRMacIver> @src foldr
14:56:02 <lambdabot> foldr k z xs = go xs
14:56:02 <lambdabot>     where go []     = z
14:56:02 <lambdabot>           go (y:ys) = y `k` go ys
14:56:15 <DRMacIver> Where does lambdabot get its sources from?
14:56:24 <zorg0f> god :)
14:56:41 <DRMacIver> zorg0f: ghc is open source, so presumably you can find the library sources in there.
14:56:51 <zorg0f> ta
14:57:01 <Saizan> http://www.haskell.org/onlinereport/standard-prelude.html <-- prelude!
14:57:02 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
14:57:03 <zorg0f> @src map
14:57:03 <lambdabot> map _ []     = []
14:57:03 <lambdabot> map f (x:xs) = f x : map f xs
14:57:52 <Binkley> you can get to all the library sources at http://darcs.haskell.org/libraries/
14:57:54 <lambdabot> Title: Index of /libraries
14:57:56 <zorg0f> saizan: excellent - cheers
14:58:06 <zorg0f> exactly what i was looking for
14:59:36 <DRMacIver> Hm. London hug is actually somewhere convenient for me to get to. I didn't expect that. :)
15:00:44 <Saizan> zorg0f: some of the definitions there are quite naive, splitAt for example
15:10:32 <fasta> Ok, this is pretty bad: I need to call two functions(lift and a specific function depending on the type of monad I want to get functionality from) to just to select that I want to have stuff computed at the ContT level.
15:11:59 <fasta> Claiming that you just need a "small interface" of already lifted names also doesn't make sense, since it's not a "small module".
15:13:17 <fasta> I also don't really get why there's MonadIO, but no MonadST
15:17:29 <davidL> @seen mux
15:17:29 <lambdabot> mux is in #haskell-overflow and #haskell. I last heard mux speak 5h 20m 34s ago.
15:20:11 <hpaste>  thoughtpolice pasted "character frequency counter" at http://hpaste.org/4
15:23:38 <Saizan> ?type M.insertWith
15:23:40 <lambdabot> Couldn't find qualified module.
15:23:47 <Saizan> ?type Data.Map..insertWith
15:23:49 <lambdabot> parse error on input `Data.Map..'
15:23:51 <Saizan> ?type Data.Map.insertWith
15:23:53 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
15:29:15 <nominolo> dcoutts, SyntaxNinja: could you resolve that "no ping" issue?
15:30:25 <SyntaxNinja> nominolo: yeah just now
15:30:35 <SyntaxNinja> turns out they deleted everything on that machine because of a billing bug.
15:30:59 <SyntaxNinja> not exactly stellar customer service.
15:31:06 <SamB_XP> no
15:31:09 <SamB_XP> that is not
15:31:11 <nominolo> yikes
15:32:06 <SyntaxNinja> so stay tuned.
15:33:18 <SyntaxNinja> I paid for a year of service in advance, the 2nd month they decided I was delinquent and so deleted my account.
15:33:54 <monochrom> That is very sad.
15:34:44 <SyntaxNinja> at least we hadn't done too much, just a few hours of work getting everyones keys on there.
15:35:14 <Igloo> SyntaxNinja: Are they giving any compensation or free extra months?
15:35:31 <therp> ls
15:35:39 <emu> . ..
15:35:39 <therp> I love ion focus bugs.. sorry..
15:36:06 <SyntaxNinja> yeah, they offered 3 extra months.
15:36:33 <SyntaxNinja> I'm pushing a bit, just checking if htey have backups.
15:36:59 <Igloo> When does SoC start, BTW?
15:38:41 <encryptio> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
15:38:42 <lambdabot> No matches, try a more general search
15:38:57 <encryptio> @djinn (a -> b -> c -> d) -> (a,b,c) -> d
15:38:57 <lambdabot> f a (b, c, d) = a b c d
15:40:45 <Jedai> @djinn
15:40:46 <lambdabot> Cannot parse command
15:43:41 <pjd> @djinn problem -> solution
15:43:42 <lambdabot> -- f cannot be realized.
15:43:52 <pjd> dang
15:44:53 <Jedai> Too bad...
15:57:37 <nominolo> Igloo: next monday
15:58:16 <dibblego> why isn't class Enum a as class (Ord a) => Enum a ?
15:58:28 <Igloo> Oh, cool
16:05:48 <lispy> dibblego: sometimes it's just enumerated but not ordered?
16:06:01 <dibblego> that doesn't make sense to me
16:07:48 <lispy> dibblego: how would you order snow white's seven dwarves?
16:08:22 <dibblego> by height of course!
16:08:32 <assl0r> @src length
16:08:32 <lispy> i'd by go beard length, myself
16:08:32 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:08:40 <dibblego> how would you "order them" (since you do by implementing Enum)
16:08:49 <dibblego> Enum implies an ordering
16:09:08 <lispy> ?src Enum
16:09:08 <lambdabot> class  Enum a   where
16:09:08 <lambdabot>     succ                     :: a -> a
16:09:08 <lambdabot>     pred                     :: a -> a
16:09:08 <lambdabot>     toEnum                   :: Int -> a
16:09:08 <lambdabot>     fromEnum                 :: a -> Int
16:09:10 <lambdabot> [3 @more lines]
16:09:23 <lispy> i see, succ and pred
16:09:25 <dibblego> forall a. succ a > a -- ordering
16:09:33 <lispy> i didn't realize succ and pred were in Enum
16:10:00 <malsyned> is there a function already that is defined to something like myfunc f l = (filter f l, filter (not.f) l) ?
16:10:13 <lispy> dibblego: does Ord require equality?
16:10:14 <Igloo> partition
16:10:17 <lispy> ?src Ord
16:10:18 <lambdabot> class  (Eq a) => Ord a  where
16:10:18 <lambdabot>     compare      :: a -> a -> Ordering
16:10:18 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
16:10:18 <lambdabot>     max, min         :: a -> a -> a
16:10:19 <dibblego> lispy, yes
16:10:30 <malsyned> @hoogle (x -> Bool) -
16:10:32 <malsyned> oops
16:10:34 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-'
16:10:47 <lispy> dibblego: well, maybe that's the why?  they didn't want to require enum to have eq?
16:10:57 <malsyned> @hoogle (x -> Bool) -> [x] -> ([x], [x])
16:10:58 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
16:10:58 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
16:10:58 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
16:11:21 <dibblego> lispy, why not? forall a. succ a /= a
16:12:02 <Igloo> That's not enough to give you an equality function
16:12:19 <nominolo> dibblego: you can define orderings for infinite or tree-like structures
16:12:23 <Igloo> I think the answer to your original question is that there's no need for it to
16:12:27 <dibblego> forall a. succ $ pred a == a
16:13:13 <nominolo> > succ $ pred (maxBound :: Int) == (maxBound :: Int)
16:13:18 <lambdabot>  True
16:13:33 <dibblego> I think you mean minBound
16:13:45 <monochrom> There is a requirement on monads that (return a >>= f) = (f a).  This is not a requirement that monads must be Eq.
16:13:53 <nominolo> > succ $ pred (minBound :: Int) == (minBound :: Int)
16:13:54 <lambdabot>  Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
16:13:59 <nominolo> hehe
16:14:06 <dibblego> ok
16:14:29 <lispy> ?check \x -> succ (pred x) == (x :: Int)
16:14:30 <lambdabot>  OK, passed 500 tests.
16:14:33 <lispy> ah, must be true
16:14:37 <lispy> ?scheck \x -> succ (pred x) == (x :: Int)
16:14:38 <lambdabot>   Completed 13 test(s) without failure.
16:15:11 <nominolo> ?check \x -> succ (pred x) == (x :: Bool)
16:15:12 <lambdabot>  Exception: Prelude.Enum.Bool.pred: bad argument
16:15:24 <nominolo> ?check \x -> succ (pred x) == (x :: Int8)
16:15:25 <lambdabot>   add an instance declaration for (Arbitrary Int8)     In the expression: let...
16:15:43 <nominolo> @instances Arbitrary
16:15:44 <lambdabot> Couldn't find class `Arbitrary'. Try @instances-importing
16:16:04 <nominolo> @instances-importing Arbitrary
16:16:06 <lambdabot> Couldn't find class `Arbitrary'. Try @instances-importing
16:16:13 <nominolo> whatever
16:16:49 <nominolo> @instances Ord
16:16:51 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
16:17:27 <nominolo> @instances Enum
16:17:28 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
16:18:49 <lispy> data Foo = Foo Int Int -- pred (Foo x y) = Foo (x+1) y; succ (Foo x y) = Foo x (y+1)
16:31:06 <dibblego> I agree, thanks
16:35:35 <dibblego> to implement the Eq type-class I need to only define /= or ==, but the source to Eq clearly defines these two functions without implementations - where are the implementations that refer to each other?
16:38:19 <TSC> My source has implementations
16:38:26 <TSC> Which source are you looking at?
16:38:26 <lispy> dibblego: well...you could check the report, it should give the mutually recursive definitions
16:38:29 <dibblego> ?src Eq
16:38:29 <lambdabot> class  Eq a  where
16:38:29 <lambdabot>     (==), (/=)   :: a -> a -> Bool
16:38:34 <dibblego> that source
16:38:39 <TSC> Oh, that
16:38:44 <TSC> That's not the real source
16:38:48 <dibblego> where are you looking?
16:38:58 <dibblego> why isn't it real?
16:39:04 <TSC> /usr/share/doc/ghc6-libsrc/base/GHC/Base.lhs.gz
16:39:22 <TSC> GHC's source
16:39:39 <TSC> I don't know where lambdabot gets its source code from
16:39:48 <lispy>         x /= y  = not (x == y)
16:39:48 <lispy> x == y  = not (x /= y)
16:39:50 <dibblego> ok I see it, thanks
16:39:54 <lispy> according to: http://www.cs.chalmers.se/~patrikj/haskell/haskell98-report/basic.html
16:39:58 <lambdabot> Title: The Haskell 98 Report: Basic Types and Classes, http://tinyurl.com/2ggr5w
16:40:31 <dibblego> lambdabot, you misled me!
16:40:43 * dibblego divorces lambdabot 
16:43:50 <ozo_> ?src (==)
16:43:51 <lambdabot> x == y = not (x /= y)
16:47:19 <dibblego> I am still divorcing!
16:48:11 <chessguy> is Data.Time a new module?
16:50:08 <TSC> Is that the new one that replaces System.Time?
16:51:21 <chessguy> i don't know, its documentation is at http://haskell.org/ghc/docs/latest/html/libraries/time/Data-Time.html
16:51:24 <lambdabot> http://tinyurl.com/2hdu4w
16:51:50 <TSC> I think it's new
16:54:37 <jmob> shapr: I wrote a simple paste CGI in haskell: http://reason.homeunix.org:52180/~jam/cgi-bin/paste
16:56:48 <Botje> is there a way to get infinite-precision floats, as with Integer?
16:57:41 <monochrom> No.
16:57:44 <augustss> haskell doesn't come with any
16:58:08 <Botje> bah :(
16:59:45 <Apocalisp> Botje: try Rational
16:59:55 <augustss> nor is it clear to me what infinite precision floats would mean
17:00:01 <jmob> chessguy: it's part of the time package
17:00:05 <augustss> maybe you want real numbers?
17:00:06 <petekaz> Does hGetChar eventually call fgetc? or does it call read(2)?
17:00:27 <augustss> or maybe fixed (but arbitrary) precision
17:00:35 <shapr> jmob: cute! You should add hscolour support next!
17:00:41 <petekaz> I.e., if I call hGetChar repeatedly, is it going to cause a system call to fire off upon each invocation?
17:02:47 <petekaz> nevermind ... I found my answer.
17:02:48 <monochrom> infinite precision floats means all digits or bits of pi are explicitly produced and stored
17:03:10 <augustss> but what is "float" about them?
17:03:23 <jmob> shapr: eventually I want to add heuristics to automatically detect langauge type
17:03:48 <Botje> I'm trying to solve a project euler problem which needs to compute the continued fraction of a square root
17:04:07 <monochrom> nevermind, I'm joking.
17:04:15 <augustss> :)
17:04:22 <ndm> @seen Igloo
17:04:23 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 51m 59s ago.
17:04:28 <Igloo> ndm?
17:04:46 <augustss> Botje: you probably don't need an infinite number of digits
17:04:48 <ndm> Igloo, did you fix the haskell-cafe bounces from Japan in the end? cause they've started once again
17:04:57 <Igloo> Yes
17:04:58 <monochrom> cfrac of square roots of naturals is a well-known algorithm.  periodic so finite representation.
17:05:21 <Botje> i'm trying to find the period, actually :/
17:05:22 <monochrom> Pick up a good number theory book for CS.
17:05:33 <ndm> i got one from my post just now, but not one earlier today
17:05:58 <Botje> monochrom: know any good ones? i'll go visit the library tomorrow, then
17:06:36 <Igloo> ndm: For haskell-cafe?
17:06:38 <monochrom> I like Bressoud "factorization and primality testing". contains rexx code.
17:07:00 <Botje> don't think they'll have that , but i'll what comes up on "number theory" then
17:07:01 <augustss> Botje: have you tried wikipedia?
17:07:05 <Botje> thanks!
17:07:10 <ndm> Igloo haskell@cs.yale.edu, it appaers...
17:07:16 <Botje> i've been perusing mathworld.wolfram.com, mostly
17:07:21 <Apocalisp> Botje: "Trying to find the period" is an interesting way of putting that.
17:07:44 <ndm> probably a haskell@ issue, rather than haskell-cafe@ then
17:10:23 <ndm> how would you go about implementing a timeout in Haskell
17:10:40 <Igloo> ndm: OK, fixed, thanks. And AFAICT he's not on any other list either
17:10:42 <monochrom> Now I'm tempted to crack open my copy and implement the algorithm in haskell!
17:10:43 <ndm> i want to run an IO computation, but if it takes more than n seconds, abort it
17:10:49 <ndm> Igloo, thanks :)
17:11:01 <mooswa> how would you name a typeclass with inside, ouside:: a -> a -> Bool ?
17:11:16 <ndm> mooswa, Overlap?
17:11:25 <Igloo> I think there's code on the wiki somewhere, or failing that, the timeout program in the GHC testsuite could be adapted easily
17:11:35 <Igloo> In fact, wasn't it put into the standard libraries a while ago?
17:11:40 <ndm> on the wiki means that i can't google it :(
17:12:19 <Igloo> But there are caveats, e.g. GHC won't time out infinite loops that don't allocate memory
17:12:56 <ndm> thats fine, mine definately allocates memory :)
17:13:05 <ndm> i've got the code off the mailing list now, thanks
17:13:57 <Igloo> It's System.Timeout in sufficiently modern base
17:14:37 <ndm> Not 6.6, and its not going to be in Hugs
17:15:00 <Igloo> "not going to be in Hugs"?
17:15:17 <Igloo> It won't work in hugs, will it?
17:15:25 <ndm> not going to be in my copy of Hugs which predates GHC 6.6 by a bit
17:15:44 <ndm> i've got rebuilding and releasing WinHugs on my todo list
17:16:15 <timlarson> I am having trouble with the "scheme in 48 hours tutorial, specifically with this part: symbol :: Parser Char
17:16:15 <timlarson> symbol = oneOf "!$#%&|*+-/:<=>?@^_~"
17:16:37 <timlarson> I get this beautiful error: (.rodata+0x30): undefined reference to `parseczm2zi0_TextziParserCombinatorsziParsecziError_zdf1_closure'
17:16:38 <mooswa> ndm, Overlap it is, thanks
17:16:51 <timlarson> any clues?  I am pretty new to this.
17:16:58 <jmob> timlarson: try compiling with -package parsec
17:17:31 <timlarson> thanks, that works :)
17:22:41 <augustss> timlarson: or with --make
17:31:01 <Botje> ah!
17:31:16 <Botje> I finally found an algorithm to steal: http://www.mail-archive.com/haskell-cafe@haskell.org/msg19735.html
17:31:19 <lambdabot> Title: Re: [Haskell-cafe] Fractional sqrt, http://tinyurl.com/27mnvd
17:31:50 <Botje> i'll grab a book on number theory first, then figure out how it works
17:33:36 <augustss> if all you want is sqrt for rationals with some precision you could use my Data.Number.Fixed module
17:34:51 <Botje> no, I actually needed an algorithm for finding the continued fraction of sqrt(n)
17:35:20 <monochrom> Theorem: Every haskell program has been written on haskell-cafe.
17:37:11 <ndm> Counterexample: The program that debugs Haskell programs
17:37:18 <TSC> dc
17:38:20 <augustss> finding code like that is not really solving the Euler problems ;)
17:39:33 <monochrom> If Botje learns the number theory behind it tomorrow, it's honest and good again.
17:39:51 <augustss> true
17:40:32 <Botje> i'll certainly try
17:41:41 <Botje> most of euler consists of (try bruteforce algorithm) >> google >> (implement elegant math-y algorithm) anyway :(
17:42:07 <Binkley> hmm, that implies that the result of each step doesn't have any influence on the next step
17:42:24 <Botje> could be stateful? :)
17:42:56 <Botje> see a >> b as "try a for a while, then do b"
17:42:58 <ndm> could be the IO monad
17:46:48 <monochrom> <+> choice with bias to the left operand
17:47:30 <zorg0f> can   +    be used on anything other than integers?
17:47:49 <mauke> :t (+)
17:47:50 <monochrom> Yes. 0.1 + 0.2 works.
17:47:51 <lambdabot> forall a. (Num a) => a -> a -> a
17:48:10 <mauke> > 1%2 + 1%3
17:48:11 <lambdabot>  5%6
17:48:18 <monochrom> That one is rational numbers.
17:49:08 <Botje> > let (+) = (++) in "one" + "two" -- cheating!
17:49:10 <lambdabot>  "onetwo"
17:49:18 <mauke> > (1:+3) + (3:+4)
17:49:19 <lambdabot>  4.0 :+ 7.0
17:49:26 <monochrom> That one is complex numbers!
17:49:29 <zorg0f> i have:           f x y z = (head(x++y))+z             and have to specify the (most general) haskell type. i came up with:            f::[int]->[Int]->Int->Int                 Is that correct?
17:49:35 <mauke> > let 2 + 2 = 5 in 2 + 2
17:49:37 <lambdabot>  5
17:49:56 <mauke> zorg0f: no
17:50:06 <monochrom> (Num a) => [a] -> [a] -> a -> a
17:50:26 <mauke> @type let f x y z = (head(x++y))+z in f
17:50:28 <lambdabot> forall a. (Num a) => [a] -> [a] -> a -> a
17:50:53 <monochrom> zorg0f look for "type class" in your favourite haskell tutorial
17:51:19 <zorg0f> (num a) => whatever         specifies that a is a numerical type rather rather than specifically saying it's an int, yeah?
17:51:26 <monochrom> The short story is operator overloading
17:51:26 <mauke> yes
17:51:41 <mauke> Int is an instance of Num
17:52:36 <zorg0f> @type let h y zs=[x|x<-['a'..y]]+zs in h
17:52:38 <lambdabot>     No instance for (Num [Char])
17:52:38 <lambdabot>       arising from use of `+' at <interactive>:1:11-28
17:52:44 <zorg0f> :D
17:53:16 <zorg0f> h::Char->[Char]->[Char]
17:53:26 <zorg0f> nah cool. i get the num a thing
17:53:28 <zorg0f> cheers
17:53:36 <mauke> @type let h y zs=[x|x<-['a'..y]]++zs in h
17:53:38 <lambdabot> Char -> [Char] -> [Char]
18:07:17 <edwardk> @paste
18:07:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:08:06 <hpaste>  edwardk pasted "How to turn showE into show? (higher-order abstract syntax)" at http://hpaste.org/5
18:08:22 <edwardk> I am trying out HOAS for a little toy project, but I can't figure out how to make a '
18:08:32 <edwardk> a suitable instance of show, for my terms
18:08:35 <edwardk> any thoughts?
18:10:27 <edwardk> once loaded in ghci something like showE $ lam $ \x -> x   should print "(fn a. a)" which works fine, but I can't turn showE into an instance of show, can't figure out the right way to flip around foralls to get it to unify
18:13:33 <edwardk> it may be a bit catamorphism heavy for most people though =/
18:16:42 <monochrom> What is the type of showE?
18:16:49 <nn-main> trying to setup a haskell compile server
18:17:50 <monochrom> I actually can't get it to typecheck.  Already have -fglasgow-exts.  iter0 has a problem.
18:19:54 <monochrom> I see. showE :: Exp ([String] -> String) -> String.  This is not very friendly to Show.
18:21:49 <monochrom> With -fglasgow-exts, instance Show (Exp ([String] -> String)) where show = showE
18:23:27 <nn-main> edwardk: want a compile ssh account
18:23:28 <dons> haha, writing tiling algos for window managers in haskell makes evil powers too accesible,  http://cse.unl.edu/~sjanssen/xcomp_spiral.png
18:23:50 <gravity> Cool!
18:24:18 <dons> personally, i think fibonacci tiling might make more sense.
18:24:30 <dons> but maybe there's some radical tesselation/plane tiling algos we could try
18:24:48 <monochrom> You will never hope for "instance Show (Exp a)". It doesn't exist. Your code fixes a to [String] -> String.
18:25:18 <monochrom> OMG you're going to add a fractal tiling too.
18:25:40 <dons> mmm.
18:25:53 <monochrom> How about tilings inspired by Escher art? :)
18:26:04 <dons> fib tiling would be reasonabe, http://en.wikipedia.org/wiki/Image:FibonacciBlocks.svg
18:26:05 <lambdabot> Title: Image:FibonacciBlocks.svg - Wikipedia, the free encyclopedia
18:26:20 <dons> monochrom: yeah, thought about it. but basically we're restricted to squares and rectangles
18:26:33 <dons> so the algos only get to manipulate the geometry of those.
18:27:31 <sm> heh, heheheh.. nice dons, sjanssen
18:28:06 <dons> i used to love tesselation when i was a kid
18:28:17 <dons> one of the first programs i ever wrote was a basic program to do truchet tiling
18:28:38 <dons> it just flipped randomly sprites on the screen, for fun tiling
18:28:45 <chessguy> hey dons, you'll know this. is Data.Time new?
18:28:50 <dons> yeah
18:28:54 <chessguy> bah
18:29:01 <chessguy> time to update ghc again already
18:29:39 <dons> its in hackage
18:29:52 <chessguy> Data.Time is?
18:31:00 <chessguy> ah, so it is
18:31:01 <dibblego> ?where shootout
18:31:01 <lambdabot> http://shootout.alioth.debian.org/
18:33:43 <chessguy> now there's an interesting error
18:33:52 <chessguy>     precedence parsing error
18:33:52 <chessguy>         cannot mix `(.)' [infixr 9] and `(&&&)' [infixl 9] in the same infix expression
18:33:52 <chessguy> Paydays.hs:31:28: Not in scope: `&&&'
18:33:56 <monochrom> Now we know what kind of primordial fetish is behind dons's conviction of developing xmonad... :)
18:34:09 <chessguy> if &&& is not in scope, how the heck does it know its precedence?
18:34:19 <mauke> default precedence?
18:35:06 <monochrom> &&& is in scope. You know how you can import modules and unknowingly get stuff.
18:43:25 <edwardk> back
18:43:34 <edwardk> iter0 can have its typing removed
18:43:43 <allbery_b> ah, mit zephyr has discovered xmonad :)
18:45:03 <edwardk> if it takes the default (non rank-2) type it type checks, but i can't figure out how to turn something like showE into an instance of show
18:46:01 <edwardk> back
18:46:02 <edwardk> hrmm
18:46:44 <cdsmith> @pl  \ (x,y,z) -> x
18:46:44 <lambdabot> (line 1, column 7):
18:46:44 <lambdabot> unexpected ","
18:46:44 <lambdabot> expecting letter or digit, operator or ")"
18:46:44 <lambdabot> ambiguous use of a non associative operator
18:46:51 <cdsmith> ??
18:47:32 <TSC> I think @pl uses an imperfect parser
18:47:33 <edwardk> had hoped to be able to just say show $ lam $ \x -> x      but i guess i'll stick to showE
18:47:57 <edwardk> nn-main: ?
18:49:07 <cdsmith> TSC: huh.  Do you know if there's a nice-looking shorter for that expression?
18:49:26 <lispy> > \x y z -> x
18:49:27 <lambdabot>  Add a type signature
18:49:33 <lispy> ?pl \x y z -> x
18:49:33 <lambdabot> const . const
18:49:58 <nn-main> y
18:50:03 <nn-main> edwardk:
18:50:07 <mauke> @djinn (x,y,z) -> x
18:50:07 <lambdabot> f (a, _, _) = a
18:50:23 <mauke> @hoogle uncurry
18:50:24 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
18:50:25 <edwardk> nn-main: couldn't figure out if you were asking me for one or if i wanted one ;)
18:50:25 <nn-main> edwardk: you still want that account
18:50:39 <edwardk> i don't recall wanting one
18:50:43 <TSC> I don't think there's a nicer form, apart from giving it a name and using that instead (:
18:50:48 <edwardk> did i ask you about it or something?
18:50:52 <nn-main> well would you like one
18:50:57 * edwardk is really counfused =)
18:51:07 <lispy> ?pl (,,) x y z -> x
18:51:07 <lambdabot> (line 1, column 12):
18:51:07 <lambdabot> unexpected ">" or "-"
18:51:07 <lambdabot> expecting variable, "(", operator or end of input
18:51:14 <lispy> ?pl \(,,) x y z -> x
18:51:14 <lambdabot> (line 1, column 3):
18:51:14 <lambdabot> unexpected ","
18:51:14 <lambdabot> expecting pattern
18:51:17 <nn-main> trying to setup a compileing server
18:51:17 <edwardk> Nah, I'm good. I have a good mix of machines I run now that I compile on.
18:51:29 <nn-main> cool
18:51:49 <lispy> ?pl (,,)
18:51:49 <lambdabot> (,,)
18:52:00 <lispy> ?pl \x y z -> (x,y,z)
18:52:01 <lambdabot> (,,)
18:52:07 <lispy> heh, i should give up
18:52:21 <lispy> i'm just spamming the channel at this point :)
18:52:28 <nn-main> i just got my webserv and complie serv on the web just wondering if any one wanted an ssh account
18:52:49 <cdsmith> lispy: I just write it the ugly way.  Thanks, though.
18:52:56 <cdsmith> *wrote
18:53:02 <lispy> cdsmith: what is the ugly way?
18:53:18 <cdsmith> lispy: \(x,_,_) -> x
18:53:23 <lispy> \(x,y,z) -> x -- i don't think this is ugly at all, except for maybe the unneeded binding of y and z
18:53:39 <lispy> if you do it a lot you could give it a name i guess
18:53:57 <cdsmith> lispy: Okay, maybe it's just that I have an aversion to backslashes.  I've always hated them.  It's irrational.
18:54:05 <lispy> fstOfThreeple (x,_,_) = x
18:54:30 <lispy> or the more compact name, fst3
18:54:50 <lispy> (but, i'm fond of threeple for a three-tuple)
18:55:09 <lispy> (yes, i know triple is the accepted name ;)
18:55:30 <cdsmith> lispy: Who's to say what's "accepted" anyhow?
18:55:45 <lispy> cdsmith: the prescriptionists
18:56:01 <hpaste>  chessguy pasted "Where is this 'index too large' error coming from?" at http://hpaste.org/6
18:56:01 <lispy> oh, and cosmo
18:56:19 <cdsmith> hpaste is announcing again?
18:56:26 <chessguy> ohhhhhhhhhhh
18:56:29 <chessguy> never mind
18:57:29 <lispy> chessguy: it might make things easier for you if you did data Months = January | ... | December, and then made it instances of show, enum and ord
18:58:11 <chessguy> lispy: true
18:58:31 <lispy> chessguy: (and I think you can derive all those instances)
18:58:54 <lispy> monthList = map show [January .. December]
18:59:46 <lispy> oh, are your days 1 based?
18:59:54 <lispy> is that what give you the index out of bounds problem?
19:00:01 <chessguy> @pl f x = mL !! ((m x) - 1)
19:00:01 <lambdabot> f = (mL !!) . subtract 1 . m
19:00:37 <chessguy> that's what i needed for monthName
19:01:06 <lispy> that's what i thought
19:01:22 <lispy> chessguy: that's a perfect place to use a map i think
19:01:55 <lispy> actually maybe not
19:02:08 <lispy> it might be if i understood toGregorian
19:02:42 <lispy> but if it does what i think, returns y in the range 1..12, then a map work
19:03:27 <lispy> ?pl month d = (\(x,y,z) -> y) (toGregorian d)
19:03:27 <lambdabot> (line 1, column 9):
19:03:27 <lambdabot> unexpected "="
19:03:27 <lambdabot> expecting variable, "(", operator or end of input
19:03:48 <chessguy> yeah, @pl can't handle triples
19:04:07 <lispy> i tohught maybe it could if it appeared on the RHS
19:04:15 <lispy> but yeah, it seems to hate threeples
19:05:17 <lispy> good use of iterate
19:05:35 <lispy> i bet you could use a list comp. too
19:05:59 <myisi> hi
19:06:10 <chessguy> it's a pretty decent idiomatic piece of code. way better than the imperative version would be
19:06:33 <lispy> :t (&&&)
19:06:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:07:29 <lispy> chessguy: monthList and monthName are the only parts i can think to change
19:09:03 <chessguy> what for?
19:09:33 <lispy> chessguy: i would do the data Months = ... deriving (Show, Eq, Ord)
19:09:44 <lispy> chessguy: and then change monthList to be a map
19:09:47 <lispy> Data.Map
19:09:59 <chessguy> but why
19:10:16 <lispy> less code for you to write and it lets you use the types
19:10:52 <lispy> the reason for Data.Map is that it's a faster lookup than (!!)
19:11:05 <lispy> in case you ever start using this code for something :)
19:11:26 <lispy> (but i admit, a list of 12 elements will index the same speed...so maybe that change is irrelevant)
19:17:22 <lispy> what does hpaste need binary for?
19:19:37 <dons> checkpoints?
19:20:00 <dons> i think the internal pastes are serialised via compressed zlib binary strings
19:20:19 <chessguy> wait, how is monthList a map then?
19:21:28 <lispy> chessguy: map 1 -> January, 2 -> February, ..., 12 -> December
19:21:53 <lispy> dons: ah neat
19:23:23 <Korollary> Month should be an enum deriving show
19:23:29 <lispy> :t lookup
19:23:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:23:41 <Korollary> and Read, etc.
19:23:52 <lispy> you could use an associated list if you tihnk Data.Map is too heavy
19:24:12 <lispy> Korollary: yeah, Enum, Ord, and Show would be perfect for what he's currently doing
19:24:29 <lispy> well, Ord isn't strictly necessary...i think i meant Eq
19:26:30 <lispy> if you wanted to use an assoc list you could do: monthList = zip [1..12] [January .. December]
19:26:55 <lispy> if you trust toGregorian you could throw in a fromJust
19:27:02 <lispy> and bam!
19:27:10 <Korollary> @hoogle Day
19:27:11 <lambdabot> System.Time.Day :: data Day
19:27:11 <lambdabot> System.Time.Friday :: Day
19:27:11 <lambdabot> System.Time.Monday :: Day
19:27:27 <lispy> ah, Friday and Monday the two most important days of the week
19:27:30 <fuzan> any VTY gurus around?
19:29:14 <fuzan> [ http://fuzan.org/before.PNG  , http://fuzan.org/after.PNG ]  -- current issue
19:29:30 <Korollary> System.Time and Data.Time could use some refactoring I guess
19:29:50 <fuzan> for some reason characters propogate down after the text reaches the info bar, and it dissepears after a redraw/resize, etc.
19:30:30 <Korollary> the info bar? do you mean yi-vty or just vty?
19:30:34 <lispy> Korollary: probably one is a wrapper on the OS (really meaning unix) provided date and the other is a more haskell friendly api?
19:30:45 <Korollary> lispy: not really
19:35:40 <fuzan> Korollary: just vty
19:35:49 <fuzan> Korollary: you'll see what i mean by infobar in those screenies :)
19:43:30 <luqui> rl
19:49:43 <byorgey> @pl \x -> x/(x+1)
19:49:43 <lambdabot> ap (/) (1 +)
19:49:52 <byorgey> :t ap
19:49:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:50:43 <byorgey> :t (/)
19:50:45 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:50:50 <byorgey> :t ap (/)
19:50:52 <lambdabot> forall a. (Fractional a) => (a -> a) -> a -> a
19:51:11 <mauke> ap f g x = f x (g x)
19:51:25 <byorgey> ok, thanks =)
19:52:12 <mauke> as opposed to (>>=) f g x, which is g (f x) x
19:52:57 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8#a1
19:53:44 <chessguy> hmm, a spammer
19:53:45 <chessguy> ?
19:54:20 <byorgey> mauke: what do I need to import to get ap?
19:54:26 <mauke> @index ap
19:54:26 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
19:54:26 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
19:54:50 <mauke> you probably want Control.Monad.Reader to make it work with functions
19:55:06 <byorgey> ok, that makes sense
19:56:01 <slava> what is the type of a function f(x) := x(x) ?
19:56:10 <slava> haskell doesn't allow this
19:56:38 <mauke> a@(a -> b) -> b
19:58:27 <mauke> > let f :: (forall a. a -> b) -> b; f x = x x in f (const 42)
19:58:27 <lambdabot>  Parse error
20:00:11 <mauke> Prelude> let f :: (forall a. a -> b) -> b; f x = x x in f (const 42)
20:00:11 <mauke> 42
20:00:40 <dolio> @type let f :: (forall a. a -> b) -> b ; f x = x x in f
20:00:42 <lambdabot> (forall a. a -> b) -> b ; f x = x x in f :: forall b. (forall a. a -> b) -> b
20:01:42 <dons> ?src fix
20:01:42 <lambdabot> fix f = let x = f x in x
20:01:49 <dons> :t fix
20:01:51 <lambdabot> forall a. (a -> a) -> a
20:02:33 <dons> > fix (1:)
20:02:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:24:18 <dibblego> ?src instance Monad []
20:24:18 <lambdabot> Source not found. You type like i drive.
20:24:22 <dibblego> how do I do that?
20:26:50 <dolio> ?src [] return
20:26:51 <lambdabot> return x    = [x]
20:26:57 <dibblego> ah thanks
20:27:00 <dibblego> ?src [] (>>=)
20:27:00 <lambdabot> m >>= k     = foldr ((++) . k) [] m
20:27:23 <scodil> can anyone tell me what the purpose of using the fixed point combinator is here? http://okmij.org/ftp/Haskell/perfect-shuffle.txt    if you take it out the code only gets smaller. I'm still trying to figure out what this thing is for.
20:28:04 <dolio> What line?
20:28:12 <scodil> just grep for "fix"
20:28:28 <fuzan> ?seen sorear
20:28:28 <lambdabot> I saw sorear leaving #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 2d 13h 44m 18s ago, and .
20:30:13 <dolio> I'm not sure. Perhaps they just used it to give an example of using the fixpoint combinator instead of explicit recursion.
20:35:12 <dibblego> does @do convert the use of >>= to do-notation?
20:35:16 <dibblego> @do [1..5] >>= \x -> [1..x] >>= \x -> [x * 2] >>= \_ -> [] >>= \x -> [x * 2]
20:35:17 <lambdabot> [1..5] >>= \x -> [1..x] >>= \x -> [x * 2] >>= \_ -> [] >>= \x -> [x * 2] not available
20:35:31 <dolio> I think it's @redo.
20:35:34 <kpreid> @redo does >> conversion
20:35:35 <lambdabot> do { does; conversion}
20:35:58 <dibblego> @redo [1..5] >>= \x -> [1..x] >>= \x -> [x * 2] >>= \_ -> [] >>= \x -> [x * 2]
20:35:59 <lambdabot> do { x <- [1 .. 5]; x <- [1 .. x]; _ <- [x * 2]; x <- []; [x * 2]}
20:36:02 <dibblego> ah cheers
20:36:49 <fuzan> ?src atomically
20:36:50 <lambdabot> Source not found. Wrong!  You cheating scum!
20:37:39 <lispy> that most recent hpaste is bizzaro
20:37:53 <falconair> i'm trying to do a simple experiment, i want to read in a comma separated file, and write out multiple files, each containing a single column of data...
20:37:55 <cdsmith> @paste
20:37:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:38:25 <falconair> my initial attempt at Data.Binary.decode failed, I'm now trying ByteString (lazy, char8) readFile ... however, I can't even print a very basic list:
20:38:51 <hpaste>  falconair pasted "read file, write file" at http://hpaste.org/9
20:39:15 <cdsmith> lispy: alrighty, then.  I'm not sure if I want to know the story behind that one. :)
20:40:07 <cdsmith> falconair: what's going wrong?
20:40:26 <falconair> cdsmith: Couldn't match expected type `IO' against inferred type `[]'
20:40:40 <lispy> hmm...does readFile open the file too?
20:40:45 <cdsmith> falconair: try mapM_ BS.putStr files
20:40:45 <falconair> I guess putStr (bytestring version) is looking for ByteString, not [ByteString] ...
20:40:58 <falconair> i think readFile opens the file alright
20:41:41 <falconair> cdsmith: mapM_ didn't work
20:41:49 <davidL> which version of X11 is included with ghc-6.6.1?
20:41:53 <cdsmith> falconair: details?
20:41:59 <falconair> ...getting...
20:42:30 <fuzan> what's more efficent, using ReaderT with ioref/mvars or statet  ?
20:43:14 <hpaste>  falconair pasted "code and error" at http://hpaste.org/10
20:43:52 <lispy> fuzan: you can annotate an existing paste
20:44:06 <cdsmith> falconair: Oh, right.  let files = BS.lines file
20:44:13 <cdsmith> falconair: lines is not an IO action
20:44:41 <fuzan> lispy:  ?
20:45:06 <falconair> fuzan: i think that was meant for me :)
20:45:08 <fuzan> lispy: i'm guessing you meant "falconair" ? :)
20:45:20 <lispy> fuzan: oh sorry
20:45:27 <fuzan> i need to use a character to ensure tab completion.
20:45:27 <falconair> cdsmith: <- is only for IO stuff then?
20:45:30 <lispy> falconair: you can annotate existing pastes :)
20:45:35 <fuzan> :t (<-)
20:45:39 <lambdabot> parse error on input `<-'
20:45:39 <falconair> :) will do
20:45:54 <cdsmith> falconair: right.  It is part of the special monad syntax, and is used for monad binding.
20:46:06 <fuzan> falconair: the type of (<-) is usually something like :: m a -> a
20:46:13 <fuzan> :t (>>=)
20:46:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:46:48 <hpaste>  falconair annotated "code and error" with "updated, parse error" at http://hpaste.org/10#a1
20:47:04 <falconair> fileio.hs:7:2: parse error on input `mapM_'
20:47:34 <falconair> sorry for the parse error ... i thought i knew more haskell than this :)
20:47:38 <cdsmith> falconair: fine.  let { files = BS.lines file }
20:48:08 <cdsmith> falconair: or use layout with the do block, which would also solve it.
20:53:01 <hpaste>  falconair annotated "code and error" with "The last statement in a 'do' construct must be an expression" at http://hpaste.org/10#a2
20:53:22 <falconair> why should it be an expression?
20:53:33 <fuzan> fix your indention :)
20:53:36 <cdsmith> falconair: the lines of the do block have to begin in the same column.
20:53:55 <falconair> oh, in my textmate they do...
20:54:15 <cdsmith> falconair: Haskell layout is always 8-character tabs; if you've changed that, then don't use tabs.
20:54:31 <hpaste>  fuzan annotated "code and error" with "(no title)" at http://hpaste.org/10#a3
20:54:43 <fuzan> you idented to the wrong column
20:55:20 <falconair> that worked ... holy cow, i was fighting indentation :)  thanks!
20:55:44 <cdsmith> falconair: yeah, tabs are evil in haskell.
20:55:49 <lispy> falconair: maybe you use both tabs and spaces? i think that confuses haskell compilers
20:56:09 <falconair> luckily i quickly found tab setting in my editor ... it was set to 4 chars
20:56:14 <fuzan> falconair: what editor do you use? textmate?
20:56:18 <falconair> yup
20:56:36 <cdsmith> lispy: it doesn't so much confuse the compiler as confuse the people trying to figure out what the compiler did. :)
20:56:43 <fuzan> falconair: i rely heavily on the emacs haskell-mode. i just mash tab until it indents it to the right depth ;)
20:56:56 <falconair> and runhaskell in commandline to test (and ghci in another just for good measure) ...and obivously irc!
20:57:09 <lispy> cdsmith: good point
20:57:23 <falconair> fuzan: then i'd have to learn emacs before i learn haskell :)
20:57:40 <cdsmith> lispy: I've been reading the report, so I can confidently say that the behavior is perfectly well-defined; just not obvious.
20:57:51 <falconair> one of these days i may have to learn emacs ... too many smart people like it
20:58:10 <lispy> cdsmith: the spec isn't as well defined as you might think, but yes i agree :)
20:58:17 <fuzan> falconair: it's pretty nice. it grows on you.
20:58:27 <lispy> falconair: i love emacs, but haskell-mode is not a good reason to learn emacs
20:58:27 <fuzan> falconair: i use vim for little hacks, and emacs as an ide.
20:58:36 <cdsmith> falconair: don't give in to the dark side!
20:58:41 * cdsmith hides
20:58:44 <fuzan> lispy: do any haskell-modes for other editors even compare to it?
20:58:48 <kpreid> falconair: I find that emacs is a useful skill even if you can't stand it for regular editing
20:58:55 <falconair> textmate shows me pretty colors
20:59:16 <lispy> fuzan: eclipse-fp could probably outshine if it got a bit more attention
20:59:17 <fuzan> the problem with emacs is that you want to use the key commands EVERYWHERE
20:59:31 <falconair> normally i use vim for quick little edit jobs...never used it as an editor for programming langs
20:59:51 <lispy> fuzan: that's not so bad if you own a mac...Apple saw that the most common emacs movement commands are standard in their applications :)
21:00:20 <fuzan> lispy: that's neat. too bad all their applications are ugly imho ;(
21:00:26 <kpreid> Well, NeXT did.
21:00:28 <fuzan> lispy: can you change the aqua theme?
21:00:53 <lispy> fuzan: i've never tried, but i bet you could hack it a little
21:01:02 <kpreid> There are programs for changing it.
21:01:38 <lispy> probably a better discussion to have in #macosx though
21:02:19 <lispy> i'd really like to find some time to write a haskell compiler (or maybe an interpreter would be easier)
21:02:30 <lispy> just a simple proof of concept for h98 implementation
21:02:50 <lispy> this has to come after i finish helisp and start/finish my C compiler...
21:02:56 <fuzan> i'm a little off... isn't ghc already past h98 and ontoo h' ?
21:03:02 <lispy> oh, and i had an idea for a april 1st language...that i have to make still :)
21:03:29 <lispy> fuzan: yeah, but h98 is probably the simplest, yet consistent and well-defined subset of what ghc does
21:03:52 <lispy> i would of course just be doing it to learn the language better
21:04:41 <fuzan> 'tis a big project. implementing existentials and stuff would scare me.
21:05:14 <lispy> perhaps, but at least i'd understand them :)
21:06:45 <lispy> fuzan: you should ask some questions about them here :)
21:06:55 <fuzan> existentials?
21:06:58 <lispy> yeah
21:06:59 <cdsmith> Hey, I just looked at ICFP and something changed.  When did they decide on the "lightning division" thing?
21:07:08 <cdsmith> (ICFP contest, I mean)
21:07:17 <fuzan> i used them in my battle.net bot that i'm currently working on :)
21:07:18 <lispy> i think the lightning division has been a round several years
21:07:30 <cdsmith> lispy: okay, maybe I just missed it before.
21:07:40 <lispy> cdsmith: i doubt they had it last year, it wouldn't have made sense
21:07:52 <lispy> when does icfp start? is it already going?
21:07:59 <lispy> i haven't kept up
21:07:59 <cdsmith> Is it mutually exclusive with the main division?
21:08:06 <cdsmith> lispy: late July
21:08:11 <lispy> cdsmith: i don't recall
21:08:45 <lispy> i thought it was jsut for people that don't have as much time but still want to throw in an attempt
21:08:59 <fuzan> i got a question: is there ANY way to go from some sort of  :: (forall a b. b t => b t -> t
21:09:26 <lispy> you want to drop the b?
21:09:36 <fuzan> yah, you can do it with cast and typeable if you know the type
21:09:41 <lispy> so is the t the exestential?
21:09:46 <fuzan> yah
21:09:50 <fuzan> i don't think it's possible.
21:10:05 <lispy> my intuition says it would be unsafe
21:10:10 <fuzan> i work around it in my bot by adding an identifier to specify teh type of t
21:10:13 <lispy> because you just invented a type...that can be anything
21:11:27 <fuzan> they're pretty cool though :)
21:11:35 <fuzan> first time I ran into them was with Happy and BNFC
21:12:29 <fuzan> i got really annoyed once when I couldn't figure out how to do something like : data Container = Container String | Container Int | Container Bool
21:12:52 <fuzan> data Container = ContainerS String ... just looked ugly
21:13:03 <fuzan> does only GHC support existentials?
21:18:11 <hpaste>  falconair annotated "code and error" with "experiment works :)" at http://hpaste.org/10#a4
21:18:54 <cdsmith> falconair: Aww, you didn't want to post your /etc/passwd file for the world to see? :)
21:18:55 <falconair> the basic skeleton works, now I have to write lists out to files and I will have convert a comma delimited text file into several files, each containing only one column :)  thanks folks
21:19:23 <falconair> :) just a bunch of alphabets
21:19:41 <fuzan> congratulations!
21:20:19 <chessguy> am i the 1-millionth person to enter #haskell?
21:20:38 <falconair> thanks folks, I don't understand small parts of it ... but time to sleep
21:20:43 <fuzan> on a side note, yes. congratulations to you as well!
21:20:52 <chessguy> wooohoooooooooooo!
21:20:54 <chessguy> what do i win?
21:21:06 <fuzan> (just don't refresh your irc client, as the number will randomly change)
21:21:33 <fuzan> you win one free #haskell question
21:22:36 <chessguy> ohhh, i better think hard about that one
21:23:24 <bos31337> @seen CosmicRay
21:23:24 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 6h 12m 55s ago, and .
21:25:49 <chessguy> hmm. i'm trying to implement 1dCAs, and it's proving to be harder than i thought
21:26:16 <cdsmith> chessguy: hard enough that you're willing to spend your one free question?
21:26:17 <fuzan> is that a large hexidecimal die?
21:26:29 <chessguy> cdsmith: not likely
21:26:36 <chessguy> fuzan: are you talking to me?
21:26:48 <Weremanatee> @pl f a b = p (fst(d a b)) (snd(d a b))
21:26:48 <lambdabot> f = ap (ap . ((p . fst) .) . d) ((snd .) . d)
21:26:54 <fuzan> on first glance, a 1dCA looks liek a large die.
21:27:02 <chessguy> ...
21:27:13 <chessguy> a cellular automata?
21:27:26 <fuzan> haha, nevermind ;)
21:27:35 <cdsmith> @dice 1d20
21:27:35 <lambdabot> 1d20 => 10
21:27:41 <fuzan> @dce 1dCA
21:27:41 <lambdabot> unexpected "C": expecting number
21:27:43 <chessguy> ohhhh
21:27:43 <cdsmith> chessguy: it looks like that
21:27:51 <chessguy> @slap chessguy
21:27:52 * lambdabot beats up chessguy
21:28:04 <chessguy> thanks lambdabot
21:28:05 <fuzan> @dice 1d0xCA
21:28:05 <lambdabot> unexpected "x": expecting digit, "+" or end
21:28:19 <chessguy> > 0xCA
21:28:20 <lambdabot>  202
21:28:24 <chessguy> that is a big die
21:28:35 <fuzan> thats why you have to make it really huge.
21:28:46 <chessguy> @dice 1d202
21:28:46 <lambdabot> 1d202 => 38
21:28:53 * cdsmith wonders if it's possible to make a fair 202-sided die
21:30:56 * cdsmith stops wondering
21:31:30 <fuzan> any sided dice > 1 and less than inf is fair :)
21:32:09 <cdsmith> fuzan: really?  How would you make a fair 3-sided die, then?
21:32:09 <Weremanatee> @haddock ap
21:32:10 <lambdabot> Unknown command, try @list
21:32:17 <Weremanatee> @doc ap
21:32:18 <lambdabot> ap not available
21:32:27 <Weremanatee> What's ap?
21:32:35 <cdsmith> @type ap
21:32:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:32:40 <Weremanatee> ooh
21:32:41 <cdsmith> @index ap
21:32:41 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
21:32:41 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
21:32:51 <fuzan> cdsmith: a 6 sided die with {1,1,2,2,3,3}  :)
21:33:16 <cdsmith> fuzan: I don't think that counts as a 3-sided die!
21:33:17 <bos> @seen dons
21:33:17 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 4m 12s ago.
21:33:36 <chessguy> @pl calc rule (x:y:z:xs) = (rule x y z) : (calc rule (y:z:xs))
21:33:39 <lambdabot> calc = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . (flip .) . ((ap .) .) . flip flip head . (flip .) . (((.) .) .) . flip flip tail . (flip .) . ((flip .) .) . (((ap .)
21:33:39 <lambdabot>  .) .) . flip flip head . (flip .) . ((flip .) .) . ((((.) .) .) .) . ap (flip . ((ap . ((ap . (((.) . (:)) .)) .)) .)) . flip flip ((. (:)) . (.) . (:)) . (((.) . (.) . (.)) .))
21:33:39 <lambdabot> optimization suspended, use @pl-resume to continue.
21:33:43 <chessguy> woohoo
21:33:50 <Weremanatee> haha
21:33:59 <fuzan> i don't think that's optimized.
21:34:40 <bos> @pl-resume
21:34:46 <lambdabot> calc = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) .
21:34:46 <lambdabot> flip flip head . (flip .) . ((flip .) .) . ((((.) .) .) .) . ap (flip . ((ap . ((ap . (((.) . (:)) .)) .)) .)) . flip flip ((. (:)) . (.) . (:)) . (((.) . (.) . (.)) .))
21:34:46 <lambdabot> optimization suspended, use @pl-resume to continue.
21:34:54 <bos> @pl-resume
21:35:07 <lambdabot> calc = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) .
21:35:07 <lambdabot> flip flip head . ((flip . ((flip . ((.) .)) .)) .) . liftM2 flip (liftM2 (ap . (((.) . (:)) .)) .) . flip flip ((. (:)) . (.) . (:)) . (((.) . (.) . (.)) .))
21:35:07 <lambdabot> optimization suspended, use @pl-resume to continue.
21:35:13 <bos> @pl-resume
21:35:18 <bos> we're getting places.
21:35:20 <lambdabot> calc = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) .
21:35:20 <lambdabot> flip flip head . ((flip . ((flip . ((.) .)) .)) .) . liftM2 flip (liftM2 (liftM2 ((.) . (:))) .) . flip flip ((. (:)) . (.) . (:)) . (((.) . (.) . (.)) .))
21:35:29 <cdsmith> bos: slowly
21:35:39 <bos> aye
21:35:45 <fuzan> someone should invent a entirely pointfree language
21:36:24 <Eelis> isn't combinatory logic like that?
21:36:32 <Heffalump> yes
21:36:37 <fuzan> no idea.
21:37:20 <cdsmith> fuzan: So next, we convince managers that there are benefits to programmers writing in pure combinatory logic.
21:37:22 <Pseudonym> Someone should invent an entirely pointfree language which supports higher-ranked types.
21:37:31 <Pseudonym> That'd be interesting.
21:37:40 <slava> stack languages are point-free
21:39:03 <cdsmith> The danger here is that you get laughed at when you advocate more pointless programming.
21:39:12 <fuzan> ?hoogle MonadReader
21:39:12 <lambdabot> Control.Monad.Reader.MonadReader :: class Monad m => MonadReader r m
21:39:29 <Weremanatee> @pl sqrt((fst d)^2 + (snd d)^2)
21:39:29 <lambdabot> sqrt (fst d ^ 2 + snd d ^ 2)
21:39:40 <Weremanatee> @pl f d = sqrt((fst d)^2 + (snd d)^2)
21:39:40 <lambdabot> f = sqrt . ap ((+) . (^ 2) . fst) ((^ 2) . snd)
21:40:38 <Weremanatee> @src ap
21:40:39 <lambdabot> ap = liftM2 id
21:40:46 <Weremanatee> hah
21:40:49 <slava> @src liftM2
21:40:49 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:41:06 <slava> @src id
21:41:06 <lambdabot> id x = x
21:41:19 <dolio> > sqrt . uncurry (+) . join (***) (^2) $ (3, 4)
21:41:20 <lambdabot>  5.0
21:41:28 <slava> @src uncurry
21:41:28 <lambdabot> uncurry f p = f (fst p) (snd p)
21:41:41 <slava> @src .
21:41:41 <lambdabot> (.) f g x = f (g x)
21:44:03 <dons> people might find this nice, true fibonacci spiral layout algorithsm for windows, http://xmonad.org/images/screen-sjanssen-spiral-thumb.png
21:44:59 <Weremanatee> That is a thing of beauty
21:45:03 <fuzan> haha, cute.
21:45:09 <fuzan> it's like a little snail.
21:45:20 <Weremanatee> Do you use xmonad for day-to-day work?
21:45:34 <chessguy> > cycle (1:)
21:45:35 <lambdabot>  Couldn't match expected type `[a]'
21:45:43 <chessguy> > fix (1:)
21:45:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:46:42 <thoughtpolice> nice
21:47:19 <chessguy> ugh, this is making my head hurt too much'
21:47:25 <chessguy> which means i'm probably thinking too hard about it
21:47:56 <chessguy> time to (try to) go to bed and pick it up tomorrow
21:49:23 <lispy> fix is fun
21:50:01 <slava> dons: are type inference algorithms generally worse-than-linear-time?
21:54:38 <dons> they have some nasty corner cases usually
21:56:23 <cdsmith> @hoogle [m a] -> m [a]
21:56:23 <lambdabot> Prelude.head :: [a] -> a
21:56:24 <lambdabot> Prelude.last :: [a] -> a
21:56:24 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
21:59:50 <fuzan> :t sequence
21:59:52 <lambdabot>     Ambiguous occurrence `sequence'
21:59:52 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
22:00:04 <cdsmith> fuzan: yeah, I found it.  Thanks!
22:00:48 <fuzan> is there anyway to craft a throw a VTY event?
22:00:54 <fuzan> ?seen sorear
22:00:54 <lambdabot> I saw sorear leaving #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 2d 15h 16m 44s ago, and .
22:01:01 <fuzan> err, "to craft and throw"
22:01:35 <slava> ?seen slava
22:01:35 <lambdabot> You are in #haskell. I last heard you speak just now.
22:13:41 <sjanssen> whoa, sorear gone from #haskell for two days?
22:15:38 <MyCatVerbs> sjanssen: I call shenanigans.
22:15:44 <MyCatVerbs> sjanssen: namely, a backhoe.
22:15:58 <MyCatVerbs> sjanssen: either that or sorear got hitched or something.
22:16:47 <chessguy> @pl f c = if c == w then 1 else 0
22:16:48 <lambdabot> f = flip (flip if' 1 . (w ==)) 0
22:18:03 <MyCatVerbs> @djinn [a] -> (a->b) -> [b]
22:18:04 <lambdabot> -- f cannot be realized.
22:18:15 <MyCatVerbs> !?
22:18:17 <MyCatVerbs> :t map
22:18:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:18:29 <chessguy> @type flip map
22:18:31 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
22:18:41 <skew> djinn doesn't know about many types
22:18:59 <skew> just variables and arrows, unless it's been extended in the meantime
22:19:12 <MyCatVerbs> @djinn [a] -> ([a]->b) -> b
22:19:12 <lambdabot> f a b = b a
22:19:37 <MyCatVerbs> skew: so you'd have to pass in functions to construct lists?
22:19:51 <skew> yeah, you could try something like that
22:20:12 <MyCatVerbs> @djinn [a] -> (a->b) -> ([a]->a) -> (b->[b]) -> [b]
22:20:13 <lambdabot> f a b c d = d (b (c a))
22:20:25 <Eelis> but since the result type is not very descriptive, it wouldn't be a very reliable way to get a map implementation
22:21:06 <MyCatVerbs> Eelis: it's still fun to play with anyway.
22:21:14 <scodil> why does this blow up the stack? : shuff rng xs = map snd $ sortBy (comparing fst) $ (randoms rng :: [Int]) `zip` xs
22:21:15 <Eelis> sure :)
22:21:33 <Heffalump> scodil: isn't randoms an infinite list?
22:21:41 <scodil> xs isn't
22:21:41 <Heffalump> oh, zipped with xs
22:21:53 <geezusfreeek> djinn does know Maybe
22:21:55 * Heffalump gotta go
22:21:57 <MyCatVerbs> > let { f a b c d = d (b (c a)) } in f [1..4] (\x->x+1) head (\x->[x])
22:21:59 <lambdabot>  [2]
22:22:00 <scodil> try it with, say, [0..100000]
22:22:01 <geezusfreeek> i don't know about much else
22:22:40 <MyCatVerbs> geezusfreeek: reliable, but useless. =)
22:22:53 <geezusfreeek> yeah
22:23:36 <MyCatVerbs> :t foldr
22:23:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:23:48 <MyCatVerbs> > let { f a b c d = d (b (c a)) } in f [1..4] (foldr (+) 0) head (\x->take (head x) $ cycle x)
22:23:48 <lambdabot>   add an instance declaration for (Num [Int])
22:23:56 <MyCatVerbs> ...gah.
22:24:22 <sjanssen> > (\rng xs -> map snd $ sortBy (comparing fst) $ (randoms rng :: [Int]) `zip` xs) (mkStdGen 42) [0..100000]
22:24:25 <lambdabot>  [63496,65177,20128,34113,95217,59132,42702,2267,36532,66713,14948,70986,4444...
22:24:42 <sjanssen> scodil: does it work with -O?
22:24:58 <scodil> sjanssen: would that be different than -O2?
22:25:19 <lispy> -O is just optimize, -O2 is a more indepth optimize
22:25:25 <sjanssen> scodil: -O2 should be just as good
22:25:25 <MyCatVerbs> Switches a few features off.
22:26:09 <sjanssen> > (\rng xs -> map snd $ sortBy (comparing fst) $ (randoms rng :: [Int]) `zip` xs) (mkStdGen 42) [0..1000000]
22:26:15 <lambdabot> Terminated
22:26:18 <scodil> so why is my stack blowing up while lambdabot's is fine? how big is his stack?
22:27:26 <scodil> mine blows up with -K16M and 100K elements in the list to be shuffled
22:29:02 <scodil> > sort [1..100000]
22:29:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:29:08 <scodil> > sort [1..1000000]
22:29:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:29:34 <scodil> > randoms (mkStdGen 42)
22:29:35 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
22:33:11 <sjanssen> scodil: too much laziness in randoms
22:34:26 <sjanssen> > let randoms' = foldr (\x xs -> seq x (x:xs)) [] randoms in (\rng xs -> map snd $ sortBy (comparing fst) $ (randoms' rng :: [Int]) `zip` xs) (mkStdGen 42) [0..1000000]
22:34:27 <lambdabot>  Couldn't match expected type `[a]'
22:35:07 <sjanssen> > let randoms' g = foldr (\x xs -> seq x (x:xs)) [] (randoms g) in (\rng xs -> map snd $ sortBy (comparing fst) $ (randoms' rng :: [Int]) `zip` xs) (mkStdGen 42) [0..1000000]
22:35:13 <lambdabot> Terminated
22:35:55 <Weremanatee> @pl f a b = fst a - fst b
22:35:55 <lambdabot> f = (. fst) . (-) . fst
22:37:32 <scodil> > let rs = take 1000000 $! randoms (mkStdGen 42) in map snd $ sortBy (comparing fst) $ rs `zip` [1..1000000]
22:37:38 <lambdabot> Terminated
22:37:59 <sjanssen> scodil: $! isn't enough strictness
22:38:16 <scodil> yeah i don't really know how that thing works anyway
22:38:19 <slava> @src $!
22:38:19 <lambdabot> Source not found. stty: unknown mode: doofus
22:38:26 <scodil> > let rs = take 1000000 $! randoms (mkStdGen 42) in map snd $ sort $ rs `zip` [1..1000000]
22:38:31 <lambdabot> Terminated
22:39:03 <dmwit> > sort . take 100000 . randoms . mkStdGen $ 42
22:39:06 <sjanssen> slist = foldr (\x xs -> x `seq` (x:xs)) [] -- has the strictness you need
22:39:06 <lambdabot>  [-2147450660,-2147443309,-2147424060,-2147414040,-2147401053,-2147394860,-21...
22:39:42 <scodil>  > sort . take 1000000 . randoms . mkStdGen $ 42
22:40:05 <dmwit> > sort . take 1000000 . randoms . mkStdGen $ 42
22:40:11 <lambdabot> Terminated
22:40:12 <scodil>  > print "hi"
22:40:14 <scodil> hah
22:40:30 <dmwit> (No space is allowed at the beginning.)
22:41:05 <chessguy> @hoogle [a] -> [a]
22:41:05 <lambdabot> Prelude.cycle :: [a] -> [a]
22:41:05 <lambdabot> Prelude.init :: [a] -> [a]
22:41:05 <lambdabot> Prelude.reverse :: [a] -> [a]
22:41:10 <chessguy> @hoogle+
22:41:10 <lambdabot> Prelude.tail :: [a] -> [a]
22:41:10 <lambdabot> List.intersperse :: a -> [a] -> [a]
22:41:10 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
22:41:23 <chessguy> ?src List.intersperse
22:41:23 <lambdabot> Source not found. Are you on drugs?
22:41:44 <LoganCapaldo> @source Data.List
22:41:44 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
22:42:19 <scodil> this is kind of disappointing because the simply zip-with-randoms-and-sort method seems to be just as fast as the perfect tree-based algorithm here http://okmij.org/ftp/Haskell/perfect-shuffle.txt ... except for the stack overflowing
22:42:27 <scodil> simply -> simple
22:44:03 <JohnMeacham> I just built new precompiled libraries for jhc and put them up to coorespond with the newest tag.
22:47:58 <chessguy> @pl \c -> con $ (i " ") c
22:47:58 <lambdabot> con . i " "
22:51:19 <chessguy> ?hoogle iterate
22:51:20 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
22:52:45 <chessguy> @pl generateN n rule row = (iterate (generate rule) row) !! n
22:52:45 <lambdabot> generateN = flip (flip . ((!!) .) . iterate . generate)
23:09:07 * Thomas2 is grumpy
23:09:15 <Thomas2> a monadic update function would be really useful in Map
23:09:19 <Thomas2> (Data.Map that is)
23:09:38 <cdsmith> @doc Data.Traversable
23:09:38 <lambdabot> Data.Traversable not available
23:09:51 <Thomas2> heh
23:10:00 <Thomas2> ok, I'll look into it
23:10:32 <cdsmith> Thomas2: it may not be what you want
23:10:37 <cdsmith> Thomas2: but it came to mind
23:10:42 <Thomas2> no, I want to update at a particular key
23:10:44 <Thomas2> good point though
23:11:40 <cdsmith> Thomas2: why not Data.Map.update?
23:12:34 <Thomas2> there's no option for the function provided to fail
23:13:02 <cdsmith> Thomas2: okay, I'm out of tricks, then.
23:13:06 <Thomas2> yeah
23:13:49 <Thomas2> you can kind of fake it with updateLookupWithKey, but it kludges its cases together so you need some way to differentiate between x's that will cause f to return None and x's that f can return
23:14:49 <Thomas2> alternatively ... f could always return a special value, which can then be used to flag the error. interesting.
23:14:55 <skew> Thomas2: how about just putting it together with lookup and insert?
23:15:19 <Thomas2> yeah. I just feel bad about doubling the time of this operation *again*
23:16:12 <skew> well, take a look at http://darcs.haskell.org/packages/base/Data/Map.hs
23:16:21 <Thomas2> yeah, I've got a copy of it
23:16:29 <skew> ought to be pretty easy to code up what you want
23:16:31 <fuzan> i still enjoy the feeling of writing a lot of horrible C code and having it not segfault once. I'm now experiencing the same feeling with my Haskell code :)
23:16:33 <Thomas2> in fact, to do what I want to do, I have to hack an additional function into it already
23:16:45 <skew> so what's the problem then?
23:16:59 <Thomas2> well, the temptation to do it again is pretty strong
23:17:13 <skew> don't forget to darcs send that patch
23:17:27 <Thomas2> but the more specialised it gets the less chance of anyone upstream being interested in keeping it
23:17:56 <skew> if it it comes to that, I think you're quite justified in using unsafeCoerce# to turn your version of Map into a Data.Map, if you didn't screw up the representation
23:18:10 <skew> and don't break the invariants
23:18:49 <skew> you ought to figure out what reasonable interface you could use to do the things you actually want to do
23:18:59 <Thomas2> yeah, I know
23:19:09 <Thomas2> point is, updateM would be a sensible part of it
23:19:31 <skew> like, something with zippers opening up a cursor into map would probably let you do quite a lot of stuff efficiently
23:19:31 <fuzan> > 10 - 2 - 3
23:19:32 <lambdabot>  5
23:19:48 <skew> and updateM seems like something that just ought to be in the module in the first place
23:19:56 <dons> skew: hmm yes, zippers into Data.Map might be fun.
23:20:05 <Thomas2> hoo boy, what are zippers?
23:20:07 <dons> zippers into lists should be a general purpoose library, too.
23:20:36 <dons> Thomas2: they're a tricky cursor into a purely functional data structure
23:20:41 <fuzan> Thomas2: wait until they start talking about buttons
23:20:45 <dons> so you can remember an update site, and navigate around it locally
23:20:58 <skew> you take appart the tree representing your map into a subtree rooted at a node you care about, and the stuff around that
23:21:01 <dons> for example, while indexing a list is O(n)
23:21:20 <dons> a zipper into a list, gives O(1) index at the cursor site, and O(1) ops on the neighbours of a node
23:22:15 <skew> is conor mcbride's paper a good place to look?
23:22:29 <dons> hmm. its a pretty abstract introductoin
23:22:34 <skew> Oleg's construction with delimited continuations is a bit of a detour
23:22:36 <dons> really more about how to automatically derive zippers
23:22:42 <dons> the wikibook is rather good, i'd say
23:22:50 <skew> i.e, how to derive a zipper for your type
23:22:56 <skew> as I see it
23:23:07 <skew> abstract = generic = reusable
23:23:53 <Thomas2> the wikibook is somewhat amusing, anyway :-)
23:23:54 <skew> unless making a function takes 5 lines of cruft, boo C
23:24:06 <slava> now imagine zippers in C
23:24:14 <skew> :(
23:24:25 <dons> hah
23:24:43 <dons> yeah, deriving zippers actually needs a decent type system, for you to do type calculus on.
23:24:52 <dons> differentiating a C typedef doesn't sound pleasant
23:25:16 <Thomas2> yeah, ok. but the concrete zipper for the map datatype is just a function which reassembles the tree given the new subtree?
23:25:31 <skew> the other day I had C code with three functions, each of which looped over the same list of strings, and repeated a subcomputation twice (with two different values stuck in somewhere)
23:25:42 <skew> I simply couldn't find any way to abstract it out that made the code shorter or clearer
23:26:23 <slava> skew: i used function pointers in my garbage collector quite successfully as a closure substitute, but then at one point i had to pass a curried function, which you can't do in C. so i changed the 'higher order function' into a macro. then some other problem came up and in the ned i just copy/pasted the loop boilerplate to some 4 or 5 call sites
23:26:36 <slava> s/ned/end
23:26:56 <skew> yeah, I've tried to do that sort of thing a few times
23:27:41 <SamB_XP> slava: those replace closures how?
23:27:51 <SamB_XP> don't you need to bundle 'em with structs?
23:27:59 <slava> a closure with a null environment :)
23:32:00 <Thomas2> as part of a seperate discussion, what is the value of updateWithKey?
23:32:17 <skew> if you want to know the key
23:32:33 <Thomas2> as near as I can tell the WithKey part can be relevant if and only if the key type of the tree is of a comparison type which has equality classes and you want to know which element
23:32:43 <skew> depends what you are doing
23:32:47 <Thomas2> otherwise it's *always* set to the key you passed
23:33:00 <skew> oh, hmm
23:33:13 <skew> I was thinking of the map
23:33:31 <Thomas2> oh, sure, if you're changing the whole thing it makes perfect sense
23:34:04 <skew> well, perhaps if you curry it
23:34:25 <skew> like, map (updateWithKey (\key val -> ???)) stuff_to_change
23:34:45 <Thomas2> that's still a bit soft
23:34:58 <Thomas2> it's a lot of syntax to help you write a lambda term
23:34:58 <elrodeo> Od
23:35:05 <skew> or, you could use (\key -> update (\val -> .. key ..) key)
23:36:13 <Thomas2> it just seems silly to me in a functional language to ever have two versions of a function in a library when you can specialise the more complex one yourself
23:37:43 <SamB_XP> s
23:37:46 <SamB_XP> so
23:37:57 <SamB_XP> you don't like (.) or map?
23:38:00 <skew> why not supply some of the common things?
23:38:34 <Thomas2> hmm? no, those are genuinely useful
23:38:47 <skew> but, this seems to be more a case of supplying a generalization you could build yourself if needed
23:39:11 <MyCatVerbs> There's also nothing wrong with supplying a few of the more commonly-used specialisations. At the very *least* they'll be useful as an illustration of how to wield the generalised form.
23:39:14 <Thomas2> what I'm getting at is doing something like giving map of head a seperate name and implementation
23:39:18 <SamB_XP> > fmap (ord `fmap` toUpper) "Hello!"
23:39:19 <lambdabot>  [72,69,76,76,79,33]
23:39:30 <SamB_XP> see. all you need is fmap, right?
23:39:38 <skew> no
23:39:54 <SamB_XP> no . or map
23:39:54 <Thomas2> well, it's OK to keep the simpler specialisations
23:39:57 <skew> why so specialized?
23:40:09 <skew> gcata!
23:40:21 <Thomas2> to avoid having to pass default arguments to the full generality all the time
23:41:16 <skew> I think what you said about supplying the more general form is kind of silly. I also think updateWithKey is not an instance of that, and is perhaps itself silly
23:41:43 <skew> although, like you said you might want to get at the actual key used
23:42:04 <Thomas2> in the very special case of an equality which contains different elements
23:42:15 <Thomas2> i'm not sure that was intended
23:42:26 <skew> or just if you care about sharing
23:42:42 <Thomas2> sharing/
23:42:43 <Thomas2> ?
23:42:58 <skew> hmm, I'm not sure how that would actually come up
23:43:16 <skew> but like, if you have a giant string in some map, and then you read the same characters from a file, it takes up more space
23:44:01 <Thomas2> oh, hrmm. yeah, that makes sense
23:44:01 <skew> so if you're getting all technical about RAM not being infinite and stuff, you might prefer to keep the version from the map everybody else refers to, rather than make some reference that keeps the new copy alive too
23:44:50 <skew> but I'm not sure how that comes up in updateWithKey either
23:45:19 <skew> I could see having values with lots of members in a map indexed by some of the members
23:45:24 <Thomas2> well, only if you want to journal the key as a part of the indexed element, there's no other way to get that information out
23:45:26 <skew> but you know, then it's already indexed on it
23:45:48 <skew> so you don't need to know the key again - updateWithKey can't move it around
23:46:14 <Thomas2> well, I think I've made enough of my point
23:46:25 <Thomas2> I'd be interested to know what the original motivation for having it was
23:46:52 <skew> because other stuff had WithKey versions
23:47:02 * kfish misread that function name as updateWhiskey
23:47:08 <Thomas2> heh
23:47:20 <skew> and there are vaguely plausible things like equivalence classes and sharing you might care about
23:47:20 <Thomas2> there are a few oddities in Map.hs
23:47:35 <skew> plus, it's imported qualified anyway
23:47:38 <Thomas2> like lookup/lookup'
23:48:05 <skew> lookup' ?
23:48:30 <Thomas2> lookup (which is in an arbitrary monad) calls a helper function lookup' (which returns a Maybe)
23:48:34 <skew> insertWith' is quite handy
23:48:41 <Thomas2> lookup' isn't exported
23:49:09 <skew> oh, I think I know why that is
23:49:26 <Thomas2> ok. it looks to me like it just wastes time dragging failures across different monads.
23:49:26 <skew> because then all the actual tree walking is done in Maybe, and the compiler can specialize for that case
23:49:35 <Thomas2> it's possible the compiler knows more about how to use Maybe though
23:49:56 <skew> rather than having to get the Monad instance at runtime, and look up that >>= member, and call it all over the place
23:50:17 <skew> it's more that having a concrete type lets it do all sorts of stuff
23:50:22 <skew> or, like do anything at all
23:50:35 <Thomas2> yeah, you're right, it's one less indirect function call in the key loop in return for an additional one outside
23:50:42 <skew> hmm?
23:51:36 <SamB_XP> Thomas2: well, more like it has a clue wtf is going on with the recursion, I think...
23:51:38 <skew> oh, I figured it was doing more monadic stuff somehow
23:52:02 <fuzan> how does one lift some work into an arbitrary monad? i have a monad Core, and a function of type Core Picture, and I'm trying to use this function from a function of type IO ()
23:52:04 <skew> well, if it's naive there's an extra argument getting passed into each recursion
23:52:24 <skew> fuzan: return lifts pure stuff, other than that it depends on the monad
23:52:56 <SamB_XP> fuzan: is there something called dumpCore that you could use ;-)?
23:53:01 <skew> but I'd hope worker/wrapper would also avoid passing that monad instance all the way down
23:53:34 <SamB_XP> doubt it
23:53:38 <fuzan> SamB_XP: that doesn't sound good :(
23:53:49 <SamB_XP> fuzan: bad joke
23:53:53 <SamB_XP> maybe runCore ?
23:54:06 * SamB_XP goes to bed
23:54:13 <fuzan> nite :)
23:54:30 <SamB_XP> nite
23:55:23 <fuzan> ?hoogle lift
23:55:24 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
23:55:24 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
23:55:24 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
23:57:19 <skew> is there any technical reason why Haskell doesn't have extensible records or an ML-style module system?
23:57:36 <Weremanatee> @seen osfameron
23:57:37 <lambdabot> osfameron is in #haskell-blah and #haskell. I last heard osfameron speak 13h 42m 28s ago.
23:58:16 <bos> hey, kids! dons, CosmicRay and i have big news: we're writing a book!
23:58:22 <bos> http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/
23:58:25 <lambdabot> Title: Real-World Haskell  Blog Archive  Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
23:58:41 <kfish> bos: rock!
