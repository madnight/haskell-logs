00:03:01 <araujo> oh geez, imperative programming is so hard
00:04:14 <dons> heh
00:04:27 <dons> you gotta think like the machine, araujo . that's the key.
00:05:46 <araujo> dons, oh, right, right
00:05:55 * araujo makes an effort
00:06:53 <dons> imagine you have a mutable state in your brain, now, each line of code sets some random bits in that big buffer.
00:07:02 <dons> what your program does is encoded in how those bits are flipped around.
00:07:04 <dons> easy -- see!
00:07:29 <dons> just don't refactor though, or your bits will be flipped in the wrong order
00:07:33 <dons> and chaos will rule
00:09:31 <araujo> this is so .... primitive
00:09:33 <araujo> :-)
00:10:03 <edwardk> dons: =)
00:10:33 <araujo> I am so used to this 'lexical' programing from functional languages.
00:10:47 <edwardk> next you're going to tell me i have an infinitely long tape flossing back and forth through my ears and that i have a head that is capable of reading and writing a single value...
00:11:35 <appletizer> lol
00:11:40 * araujo doesn't like to be jumping around á la goto-like programing
00:13:47 <araujo> dons, so, you mean the brain is a Monad? :-)
00:25:26 <dons> no, but that to understand imperative programming, you must become one with the state machine :-)
00:25:36 <opqdonut> :D
00:27:17 * edwardk often feels like he has has become one with the STM monad. I sit there and spin my wheels and get lots of stuff done, then in the end I sit down and get ready to record for posterity what I have accomplishe, I read what everyone else has done and I realize I have to start over.
00:27:28 <edwardk> s/has has/has/g
00:28:50 <kfish> the imperative states are just the blinkenlights on the front of the machine, telling you what the combinators are up to -- what's the point of programming if you can't get at the combinators?
00:29:02 <newsham> if you build and install a lib with cabal, is there an easy way to uninstall it?
00:30:11 <dons> yeah, encoding algorithms in terms of blinkenlights is a fun challenge :-)
00:31:07 <dons> data Tree a = Empty | Node (Tree a) a (Tree a)
00:31:15 <kfish> newsham, no, no uninstall yet :-( but you can unregister / hide it with ghc-pkg
00:31:17 <dons> oh wait, no, the blinkenlights won't underrstand that
00:31:26 <dons> better translate it to blinkencode.
00:31:27 <newsham> if i unregister does that remove the files?
00:31:33 <nornagon> yo kfish :)
00:31:40 <kfish> dons: blinkencode!
00:31:45 <kfish> newsham, nope
00:31:57 <newsham> i installed wrong version haxml and would like to avoid the extra disk space
00:31:59 <newsham> oh well
00:32:04 <dons>    if(item->val<(*tree)->val)
00:32:04 <dons>       insert(&(*tree)->left, item);
00:32:04 <dons>    else if(item->val>(*tree)->val)
00:32:04 <dons>       insert(&(*tree)->right, item);
00:32:16 <dons> blinkencode is fun. like programming in sed!
00:32:21 <newsham> disk is cheap.  why am I always running out?
00:32:52 <dons> "i know, we can encode True as a bit pattern! oh, and we can signal failure with a pointer to 0. yeah, cool idea!"
00:33:15 * kfish dereferences NULL
00:33:30 <newsham> are you against true being encoded as a voltage?
00:34:01 <newsham> for(p = head; p; p = p->next) { ... }
00:34:02 <newsham> mmmmm
00:34:07 <newsham> pointery goodness
00:34:09 <appletizer> what's a good haskell compiler?
00:34:15 <newsham> ghc?
00:34:15 * NULL
00:34:18 <dons> ghc.
00:34:22 <appletizer> ah glasgow
00:34:26 <dons> appletizer: http://haskell.org/ghc
00:34:28 <lambdabot> Title: The Glasgow Haskell Compiler
00:34:33 <appletizer> dons, thanks
00:35:20 <newsham> for(p = tree; p; p = p->val < val ? p->left : p->right) { ... }
00:35:49 <byorgey> newsham: my eyes!  it burns!
00:36:14 <kfish> heya nornagon
00:38:13 <newsham> 1fish, 2fish, kfish, bluefish
00:38:46 <MyCatVerbs> newsham: bleehhhhhh.
00:38:46 <edwardk> I didn't realize that I had become allergic to C until I was reading through the IBM unicode reference library today and started twitching
00:38:56 <MyCatVerbs> newsham: write that recursively, dammit.
00:39:11 <newsham> its just tail-call optimized thats all
00:39:19 <MyCatVerbs> newsham: I don't care if it's C. Even gcc has tail recusion by now, for the love of Pete.
00:39:43 <Korollary> edwardk: icu4c?
00:40:13 <edwardk> kor: yeah
00:40:21 <MyCatVerbs> edwardk: I dunno about *allergic*...
00:40:32 <edwardk> my current hack is to just ffi out to stringprep
00:40:32 <Korollary> edwardk: It has the most retarded api I've ever seen
00:40:46 <MyCatVerbs> edwardk: I mean, C is exceptionally good - unmatched, even - for two purposes in particular. OS kernels is one.
00:40:58 <edwardk> mycatverbs: well i also broke out in a rash, but I was going to spare you the gory details ;)
00:41:05 <MyCatVerbs> edwardk: and target language for initial prototypes of programming languages that don't suck is the other. XD
00:41:06 <Syzygy-> Speaking of traversals of datastructures - I caught a nasty bug in a library I was hired to work on once.
00:41:09 <newsham> mycat: functional language runtimes being another? :)
00:41:31 <Syzygy-> Deleting items in a linked list was done with a for loop, using a pointer and a double pointer. And the original author updated the wrong thing in the iterative step.
00:41:34 <edwardk> kor: i was trying to avoid lgpl'd code in case i had to drag it into the app ultimately, and the ibm version has a cleaner license.
00:41:42 <Syzygy-> So as long as all you wanted to delete was teh head of the list, it worked.
00:41:58 <Syzygy-> But insert(k1), insert(k2), delete(k2), delete(k1) => infinite loop.
00:42:03 <MyCatVerbs> newsham: well, yes, though in principle I'd rather have as much as possible pushed into the real language and as little as possible left in the hands of the loser bagbiting languages.
00:42:26 <newsham> prevp = &head; for(p = head; p; p = next) { next = p->next; if(p->val == val) { *prevp = p; free(p); } else { prevp = &p->next; } }
00:42:29 <newsham> like so?
00:42:39 <edwardk> so as it is i am stuck ripping it out of a bytestring, generating a c string, sending it through, and bytestringing the result. blech.
00:42:42 <newsham> common idiom
00:42:46 <MyCatVerbs> newsham: that said, I doubt it's particularly easy to write a lazy language GCing runtime *in* a lazy language with GC, so. Heh.
00:43:28 <newsham> *prevp = p->next; rather (oops)
00:43:33 <newsham> irc code :)
00:43:38 <MyCatVerbs> newsham: eh? Noooo. What the Hell is next=p->next; in there for? Just replace that clause with p=p->next in the for loop, much nicer.
00:43:44 <balodja> hi, where can i read about how to define subtraction in terms of lambda calculus?
00:43:56 <newsham> mycatverbs: because you cant do p = p->next after you did free(p);
00:44:01 <MyCatVerbs> balodja: what, using Church numerals? Beats me.
00:44:09 <newsham> so you keep around next = p->next; before potential free of p
00:44:14 <MyCatVerbs> newsham: oh. Oops.
00:44:21 <newsham> surely you've done this before :)
00:44:23 <balodja> MyCatVerbs: year, exactly them
00:44:24 <MyCatVerbs> newsham: too lazy to read more than the first sentence.
00:44:56 * MyCatVerbs hangs his head in shame, for he just TL;DR
00:45:08 <MyCatVerbs> *TL;DR'd a goddamn C stub. :(
00:45:12 <newsham> balodja: the wikipedia article on lambda calculus touches it briefly
00:45:54 <newsham> balodja: exapmle code here http://www.thenewsh.com/%7Enewsham/x/numbers.py
00:46:01 <newsham> in python (sorry)
00:46:26 <newsham> i tried doing it in haskell but i couldnt get the type system happy
00:46:41 <MyCatVerbs> newsham: :O
00:47:36 <MyCatVerbs> newsham: I honestly cannot see any way of making .\ calculus not insanely difficult to sneak past Haskell's type system that doesn't involve writing a Scheme 'terp in Haskell.
00:47:54 <newsham> mycat: i suspected as much.
00:48:28 <newsham> there's a really cool paper about encoding algebraic types into untyped lambda calculus
00:49:12 <newsham> http://www.cs.nott.ac.uk/~nhn/TFP2006/Papers/03-JansenKoopmanPlasmeijer-EfficientInterpretation.pdf
00:49:17 <lambdabot> http://tinyurl.com/2drus8
00:49:28 <newsham> that paper is what got me goofing around with the lambdas
01:01:25 <dolio> @pl \((x1,y1),(x2,y2)) -> ((y1, -x1), (y2, -x2))
01:01:25 <lambdabot> (line 1, column 27):
01:01:25 <lambdabot> unexpected ","
01:01:25 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
01:02:01 <edwardk> newsham reading now
01:09:36 <whitenoyce> hi, i suck at math, well i did one semester of calculus in college. does that mean i can't program in haskell?
01:10:01 <newsham> no, but you may find reasoning about programs weird :)
01:10:22 <newsham> also calculus is not terribly relevant
01:10:32 <whitenoyce> so i'm right to avoid haskell b/c its too mathy?
01:10:48 <newsham> I wouldnt say "you're right to avoid haskell because its mathy"
01:10:58 <newsham> but you may find it mathy and give up on it.
01:11:00 <whitenoyce> what would you say?
01:11:11 <whitenoyce> if i did it i would be in angst?
01:11:15 <newsham> on the other hand you might not notice the mathiness
01:11:23 <newsham> and end up having a lot of fun instead.
01:11:26 <newsham> who's to say
01:11:40 <kfish> whitenoyce, like anything, if you don't try it you'll never find out
01:12:46 <balodja> www.cl.cam.ac.uk/teaching/Lectures/funprog-jrh-1996/chapter3.ps.gz
01:13:35 <newsham> what book is that from?
01:13:39 <balodja> newsham: may be you know more elegant way of defining subtraction than decribed there?
01:14:34 <jyp> "In its purest form programming is math", says buddha.
01:14:53 <whitenoyce> well i like programming
01:15:04 <jyp> Then you must like math
01:15:05 <kfish> whitenoyce, that's the most important thing :-)
01:15:06 <whitenoyce> it seems to be all i do with my free time
01:15:21 <kfish> there are some good tutorials listed at http://www.haskell.org/haskellwiki/Learning_Haskell
01:15:22 <lambdabot> Title: Learning Haskell - HaskellWiki
01:15:24 <jyp> maybe you don't know it yet.
01:15:46 <newsham> pred (Succ n) = n;  pred Zero = Zero;   sub n Zero = n; sub n (Succ m) = sub (pred n) m
01:15:49 <newsham> something like that?
01:15:59 <newsham> (you can xlate to lambdas pretty easily from that)
01:16:07 <whitenoyce> i started a tutorial a while back that seemed addressed to newcomers to haskell from C, does anyone have the link?
01:16:28 <whitenoyce> the first page was titled "what the heck is going on?"
01:16:28 <kfish> whitenoyce, this kind of math is all about making rules to manipulate symbols -- not about number crunching
01:16:28 <newsham> balodja: btw, the python code i URL'd has a sub function in it
01:16:49 <newsham> whitenoyce: www.haskell.org has a collection of tutorials.
01:16:50 <kfish> whitenoyce, http://www.haskell.org/~pairwise/intro/section1.html
01:16:51 <lambdabot> Title: Haskell for C Programmers
01:17:37 <newsham> balodja: that's when numbers are   Zero or (Succ number)
01:18:48 <whitenoyce> yep that's the one
01:18:50 <whitenoyce> thanks for the link
01:18:57 <newsham> jyp: thats like saying building stuff is math.  architects build stuff iwth math all the time, but some hobbyists build stuff without doing any math at all and get by just fine
01:19:33 <kfish> newsham, that's a pretty good analogy to the software industry :-)
01:19:40 <newsham> yup
01:19:48 <newsham> we're not really at engineering yet :)
01:19:58 <newsham> but there are some good artisans out there (and some bad ones :)
01:20:03 <kfish> exactly :-)
01:20:54 <kfish> the software industry is at the stage where architecture was 100 years ago -- starting to work with steel, inventing elevators, talking about mechanics
01:21:33 <kfish> the master architects of 100 years ago (like Gaudi) didn't use no stinking math, at least not as we know it
01:21:38 <appletizer> lol
01:21:45 <kfish> but, that's no way to build a skyscraper
01:21:46 <appletizer> really?
01:21:55 <appletizer> i thought the pyramids were built on precise mathematical foundations
01:21:56 <appletizer> :\
01:22:09 <kfish> yes :-) but no calculus of mechanics etc.
01:22:19 <kfish> lots of good heuristics for number relations
01:22:26 <newsham> yah, super precise.  they said "let's make the top 10 units tall,  we'll roll out a wheel with one unit diameter ten times to make the base!"
01:22:29 <kfish> and gaudi used physical models
01:22:37 <newsham> and some other guy said "sounds good!  line up the slaves!"
01:22:46 <kfish> oh yeah, and they had slaves.
01:23:16 <appletizer> well i think that doesn't do the pyramids any justice though i get your point
01:23:23 <appletizer> they were actually far more precise than 1:10
01:23:33 <appletizer> down to 1/10th of a mm
01:23:36 <newsham> then 3000yrs later some wacko measured the base and the height and found PI lying around and declared that the egyptians were mathematical genii
01:23:48 <newsham> (where genii is the plural of genius ;-)
01:24:20 <newsham> clearly a sign that they were communicating with extratarestrial types
01:24:54 <appletizer> :)
01:25:05 <appletizer> it could be possible that the egyptians have discovered pi back then
01:25:22 <kfish> and ate it too
01:26:22 <newsham> three of this guy (does egyptian pose), and about one tenth of this guy (another egyptian pose)
01:28:03 <kfish> yeah, and our puny "source code" is the heiroglyphics of programming
01:28:41 <kfish> i mean, how the hell do we get anything *done* if we haven't invented holographic combinator imaging yet?
01:29:40 <newsham> push 3 push 10 mul push 1 add push 10 mul push 4 add push 100 div
01:31:11 <Syzygy-> 3 =
01:31:12 <Syzygy-> ?
01:32:03 <Syzygy-> Seems that way. 3 -> 3, 10 -> 30 -> 30, 1 -> 31 -> 31,10 -> 310 -> 310,4 -> 314 -> 314, 100 -> 3
01:32:15 <Syzygy-> (or possibly 3.14 if your div works that way around.
01:32:18 <newsham> > 314 / 100
01:32:20 <lambdabot>  3.14
01:36:25 <kfish> dons: is goa a ghci extension or replacement?
01:37:39 <ivanm> an extra library for ghci, isn't it?
01:37:47 <ivanm> it runs inside ghci
01:37:52 <appletizer> kfish, newsham, looks like you guys were right
01:37:55 <appletizer> the pi thing's a scam
01:37:55 <ivanm> s/library/module
01:37:57 <appletizer> blaaah :D
01:38:48 <newsham> unless "the wheel" counts, of course ;-)
01:38:55 <newsham> thats kinda got pi in it somewhere :)
01:39:06 <dons> kfish: its an extra library of bindings. unmaintained though.
01:39:20 <kfish> ivanm, dons ah ok
01:39:24 <ivanm> anyone know why compiling a program with ghc -prof -auto-all -caf-all won't work?
01:39:32 <kfish> seems like a useful thing for anyone using haskell anyway ...
01:39:40 <ivanm> dons: isn't it by you? so you wrote it then stopped maintaining it?
01:39:55 * ivanm thinks lambdabot in IRC is more useful than goa
01:40:09 <ivanm> especially since compiling a new program/module into ghci then kills goa
01:40:30 <kfish> ah ok -- i thought it just added some extra commands to ghci
01:40:48 <dons> ivanm: right.
01:40:48 <kfish> anyway, lambdabot's cuter
01:40:59 <dons> i find i just use lambdabot directly
01:41:09 <dons> so don't have the needed incentives to keep goa in sync.
01:41:29 <ivanm> exactly
01:41:59 <ivanm> dons: is there anything extra needed to get a local lambdabot to be able to evaluate haskell code or use the src command?
01:42:05 <ivanm> or do I just have too old a version?
01:42:37 <dons> you need hs-plugins from darcs, and lambdabot from darcs.
01:42:41 <ivanm> *nod*
01:42:54 <ivanm> don't have hs-plugins from darcs probably then
01:42:59 <ivanm> and definitely don't have lambdabot from darcs
01:43:22 <ivanm> dons: do you know why compiling a program with ghc -prof -auto-all -caf-all won't work?
01:43:45 <dons> a) you should use -O, otherwise you're not profiling the program you'll be running
01:43:55 <dons> b) maybe if there's missing .prof versions of libraries
01:45:21 <ivanm> *nod*
01:45:26 <ivanm> its the -caf-all that's the problem
01:45:37 <ivanm> it complains about multiple Mainman.caf or something like that
01:46:02 <ivanm> the only mention I found online was an old email post stating that it was a repeated bug in ghc
01:46:12 <ivanm> but I didn't know you needed at least -O2
01:46:22 * ivanm thought profiling should be done without any optimization
01:46:26 <ivanm> s/-O2/-O
01:46:42 <dons> nope.
01:46:55 <dons> otherwise you're not profiling the code you'll be running in the real world.
01:47:20 <ivanm> ahhh, k
01:47:25 <ivanm> thanks dons
01:47:33 <opqdonut> the reason to prof. w/o -O is that in most c compilers -O messes profiling data up
01:47:34 * ivanm would give dons karma, but he doesn't really need it ;-)
01:47:39 <ivanm> @karma dons
01:47:39 <lambdabot> dons has a karma of 155
01:47:44 <ivanm> opqdonut: *nod*, OK
01:47:52 <ivanm> does anyone actually have more karma than dons?
01:49:11 <dons> ?karma-all
01:49:11 <lambdabot>  "audreyt"             837
01:49:11 <lambdabot>  "fglock"              235
01:49:11 <lambdabot>  "agentz"              173
01:49:11 <lambdabot>  "dons"                155
01:49:11 <lambdabot>  "larry"               106
01:49:13 <lambdabot> [1165 @more lines]
01:49:22 <dons> the perl guys have a karma bot ;)
01:49:46 <ivanm> heh
01:49:57 <ivanm> who's audreyt? don't recall seeing him online before...
01:50:52 <jql> the founder of pugs
01:51:49 <ivanm> ahhh
01:51:59 <ivanm> and lambdabot is in the pugs channel as well?
01:52:16 <jql> yeah, she gets most of that karma over on #perl6, I'd bet
01:55:00 <edwardk> ah wow, yeah she's racked up quite a bit of it lately then, i recalled dons being on top before =)
02:15:39 <takamura> hi
02:16:18 <kfish> hi takamura
02:31:59 <Lemmih> Igloo: Welcome.
03:05:20 <givi> sorry, guys. how do  change my nickname?
03:05:39 <Korollary> type /nick newname
03:05:57 <makukha> thanx!
03:17:31 <Igloo> dons: Is that "database is locked" foxed now?
03:17:51 <dons> ?bug
03:17:52 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
03:17:57 <dons> let's see..
03:18:45 <dons> works now.
03:19:11 <Igloo> OK, it sometimes does that
03:19:23 * Igloo has no idea why
03:21:05 <dons> php? :-)
03:24:05 <matthew-_> you know how you can do an unbalanced infix op with: x f y = \z -> ... where f is the func, well I want it the other way round, with > 1 arg on the lhs and one arg on the rhs. any ideasL
03:24:06 <matthew-_> ?
03:24:42 <ivanm> maybe have a different function on the left hand side?
03:24:50 <dons> there's a paper by okasaki on postfix notation
03:24:55 <dons> you could check that out.
03:24:59 <ivanm> bar foo y = ... where bar x = stuff
03:25:02 <dons> it wsa at the haskell workshop in 02 or 03 I think
03:25:28 <matthew-_> dons: tnx, will do
03:25:57 <matthew-_> ivanm: I don't see how that would work with pattern matching as I think you end up trying to pattern match on a function
03:26:16 <ivanm> shmeh, wouldn't have a clue
03:26:20 <ivanm> just a wild guess
03:31:21 <matthew-_> oh, and how do you define your own list syntax? The [ , , , ... , ] syntax?
03:31:36 <matthew-_> or is it a magic builtin?
03:32:22 <ivanm> list syntax?
03:33:16 <roconnor> matthew-_: it is magic built-in
03:33:31 <matthew-_> ahh, ok. ta.
03:37:09 <roconnor> matthew-_: you can make infix type constructors, although they must begin with ':' and may only work in GHC.
03:40:16 <matthew-_> yup. So I've seen. I want to create my own 'emptylist', a la []. But ghc doesn't seem to like me trying to define |[]| or similar... I find the 98 report hard to navigate - where is it defined what chars can define a function?
03:41:35 <Igloo> http://haskell.org/onlinereport/syntax-iso.html
03:41:35 <lambdabot> Title: Haskell 98 Syntax
03:42:05 <matthew-_> thanks Igloo
03:42:05 <Igloo> In particular, varid and varsym in parentheses
03:42:21 <roconnor> Igloo: is infix type constructors haskell 98?
03:42:29 <Igloo> Can't remember
03:53:34 <augustss_> no
04:21:41 <roconnor> (ln 307)/(ln 2)
04:21:46 <roconnor> > (ln 307)/(ln 2)
04:21:47 <lambdabot>   Not in scope: `ln'
04:21:52 <roconnor> > (log 307)/(log 2)
04:21:54 <lambdabot>  8.262094845370179
04:22:11 <roconnor> > 307*(log 10)/(log 2)
04:22:12 <lambdabot>  1019.8319251304204
04:24:26 <roconnor> >307 * (logBase 2 10)
04:24:31 <roconnor> > 307 * (logBase 2 10)
04:24:33 <lambdabot>  1019.8319251304204
04:24:40 <roconnor> @src logBase
04:24:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:25:42 <jyp> Why these obnoxious error messages, btw?
04:26:23 <CosmicRay> jyp: fun?
04:27:44 <jyp> m'kay.
04:48:54 <roconnor> I'm pretty bored with the obnoxious messages myself.
04:49:44 <arcatan> me too
04:50:05 <arcatan> src never seems to work anyway
04:50:17 <roconnor> @src id
04:50:17 <lambdabot> id x = x
04:51:28 <nominolo> @src catMaybes
04:51:28 <lambdabot> catMaybes ls = [x | Just x <- ls]
04:52:24 <nominolo> @check msum xs == catMaybes (xs :: Maybe Char)
04:52:25 <lambdabot>   Not in scope: `xs'
04:52:35 <nominolo> @check \xs -> msum xs == catMaybes (xs :: Maybe Char)
04:52:36 <lambdabot>  Couldn't match expected type `Maybe Char'
04:52:51 <TSC> [Maybe Char] ?
04:52:57 <nominolo> @check \xs -> msum xs == catMaybes (xs :: [Maybe Char])
04:52:58 <lambdabot>  Couldn't match expected type `Maybe' against inferred type `[]'
04:53:28 <nominolo> @check \xs -> msum xs == catMaybes xs
04:53:28 <lambdabot>  Couldn't match expected type `Maybe' against inferred type `[]'
04:53:38 <nominolo> :t msum
04:53:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
04:53:47 <nominolo> ah
05:11:35 <hpaste>  dr_strangelove pasted "utf8" at http://hpaste.org/69
05:12:21 <nominolo> :t uncurry map
05:12:24 <lambdabot> forall a b. (a -> b, [a]) -> [b]
05:16:01 <dr_strangelove> somebody have an idea how I can print a utf-8 string on the console (see hpaste)?
05:16:24 <dr_strangelove> my editor is set to utf8 and the console, too
05:17:09 <dr_strangelove> I played a little bit with Data.CompactString, but without success
05:18:05 <roconnor> @where utf8
05:18:05 <lambdabot> I know nothing about utf8.
05:18:10 <roconnor> :/
05:20:45 <ivanm> dr_strangelove: I assume you're using a utf8 compatible console?
05:21:21 <dr_strangelove> ivanm, yes
05:22:30 <dr_strangelove> gnome-terminal and gvim 7, both set to utf-8 encoding
05:26:56 <dr_strangelove> main = putStrLn "Touch\195\169"
05:27:54 <dr_strangelove> this works, but then I always have to lookup the codepoints and utf-8 translations
05:28:59 <Saizan> Prelude> putStrLn "Touché"
05:28:59 <Saizan> Touché
05:30:11 <dr_strangelove> Saizan, yeah works in ghci for me too
05:30:19 <dr_strangelove> but not with runghc
05:30:46 <Saizan> what error do you get?
05:31:01 <dr_strangelove> no error, but "Touch"
05:31:58 <dr_strangelove> see hpaste 69
05:31:59 <Saizan> very strange.. have you tried with another editor?
05:33:09 <dr_strangelove> no, but I opened the file with a hex editor and the encoding was correct
05:34:20 <dr_strangelove> echo "main = putStrLn \"Touché\"" > touche.hs
05:34:45 <dr_strangelove> this, on the same console where ghci works, gives Touch, too
05:35:14 <dr_strangelove> (with runghc touche.hs)
05:38:36 <dr_strangelove> can someone reproduce this?
05:38:48 <erider> good morning
05:39:02 <dr_strangelove> morning
05:39:44 <Cynos> Hi all, Haskell newbie here, having issues importing a Cabal package I installed - using Windows XP and GHC. I get the error message "Could not find module `Network.Browser':   it is a member of package HTTP-3000.0.0, which is hidden"
05:40:03 <Cynos> How do I unhide it?
05:40:21 <Heffalump> -package HTTP
05:40:37 <ndm> Cynos, and "Build-Depends:  HTTP" to the cabal file
05:40:53 <Saizan> dr_strangelove: on my gnome-terminal it appears as Touch? but i think it's the same problem
05:41:17 <dr_strangelove> hm, probably
05:41:17 <Heffalump> oh, right, depends on what you're doing. If you're building a cabal package of your own, then yes, what ndm said.
05:41:30 <Heffalump> If you're just compiling some code not using cabal, then what I said
05:42:15 <Saizan> dr_strangelove: ghc interprets source code as utf-8, so it converts your utf-8 string literal to true unicode, then putStrLn prints the least significant 8-bits of whatever is in the Char
05:43:10 <Cynos> Oh right, thanks Heffalump, I'll have another poke.
05:43:21 <Saizan> dr_strangelove: you should convert explicitly to utf-8 before printing
05:43:59 <dr_strangelove> Saizan, how? Data.CompactString?
05:44:25 <dr_strangelove> I tried that, but without success
05:44:56 <Saizan> same problem?
05:45:03 <dr_strangelove> yes
05:45:42 <Cynos> Thanks Heffalump. :) At the very least it allows the code to compile.
05:48:07 <dr_strangelove> Saizan: I think it prints the most significant bits, because putStrLn "Touché!..." gives Touch, too
05:49:43 <Saizan> dr_strangelove: i get "Touch?!..."
05:50:52 <dr_strangelove> ok, then you seem to have a different problem ...
05:51:07 <Saizan> dr_strangelove: http://zzodici.yi.org/s/repo/UTF8.hs <-- you can try using this module
05:54:11 <dr_strangelove> Saizan: great, thanks. works with "toUTF8 "Touché" :)
05:54:46 <hpaste>  Saizan annotated "utf8" with "this works for me" at http://hpaste.org/69#a1
05:57:54 <Saizan> mmh, i get \xa8\xc3 instead of \xa9\xc3
05:58:10 <Saizan> > 0xa8
05:58:12 <lambdabot>  168
05:59:11 <roconnor> internal error: interpretBCO: unknown or unimplemented opcode 39780
05:59:11 <roconnor>     (GHC version 6.6 for i386_unknown_linux)
05:59:59 <roconnor> ah, works better when compiled
06:00:06 <roconnor> silly runhaskell
06:00:17 <Lemmih> roconnor: Fixed in 6.6.1
06:00:27 <roconnor> :)
06:00:59 <dr_strangelove> Saizan, it should be \xc3\xa9, no?
06:03:33 <Saizan> dr_strangelove: yes, typed è isntead of é, however i don't get why it appears wrong on hpaste, probably hscolour mangling the codepoints
06:05:03 <roconnor> @type interact
06:05:06 <lambdabot> (String -> String) -> IO ()
06:06:25 <dr_strangelove> Saizan, I meant the c3 should be first, not a9
06:07:07 <dr_strangelove> that may explain our different errors
06:08:07 <roconnor> can I get ghc --make foo.hs -o foo not to leave around other files?
06:10:07 <dr_strangelove> Saizan: btw, in my browser your hpaste annotation appears as Touch??!..
06:11:06 <dr_strangelove> are you on a big-endian machine? :)
06:12:13 <Saizan> roconnor: ghc --make -odir /tmp -hidir /tmp foo.hs -o foo
06:12:47 <Saizan> dr_strangelove: who knows :)
06:13:18 <Saizan> hexdump surely gives \xa9 first
06:16:39 <dr_strangelove> according to http://www.utf8-chartable.de/  it should be c3 a9
06:16:41 <lambdabot> Title: Unicode/UTF-8-character table
06:17:01 <Saizan> vi agrees
06:28:38 <Baughn> How tightly does a DiffUArray (Int,Int,Int) (Word8) pack its members? And in what order?
06:47:33 <Baughn> Oh, I see. Ix takes care of it..
06:48:28 <dons> ?yo
06:48:29 <lambdabot> My vaseline is RUNNING...
06:49:10 <LoganCapaldo> vaseline and amphetamines
06:53:20 <fasta> How does the type GHC.Prim.Any1 get derived?
06:53:58 <sorear> fasta: Deep magic
06:54:05 <sorear> fasta: it
06:54:06 <sorear> '
06:54:14 <sorear> s like (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
06:54:25 <sorear> Any is an infinite family of types
06:54:41 <sorear> so there is code in GHC to create members on demand
06:54:56 <fasta> sorear: so there's nothing "wrong" with having such types?
06:55:14 <fasta> sorear: In my experience my code never works when functions have such types.
06:55:30 <sorear> fasta: Nothing 'wrong', but each time you need to add special case code to the compiler.
06:56:09 <sorear> fasta: What? you managed to get ghc to type an expression as :: Any1 ?
06:56:44 <sorear> afaik, the only way to get Any* values is unsafeCoerce#
06:56:58 <fasta> sorear: no, (othercontext, Monad Any1) =>
06:57:35 <fasta> sorear: but this without unsafeCoerce#
06:57:44 <sorear> Yikes.
06:59:32 <fasta> Glorious Glasgow Haskell compiler => The Buggy Glasgow Haskell Compiler?
07:02:03 <sorear> http://hackage.haskell.org/trac/ghc/attachment/wiki/Status/April07/bugs_per_day.png
07:02:05 <lambdabot> Title: Status/April07: bugs_per_day.png - GHC - Trac, http://tinyurl.com/2aa336
07:03:03 <fasta> sorear: is there also an image showing the number of bugs solved?
07:04:08 <sorear> not that I know about
07:08:34 <fasta> Hmm, this is not good. I have had this error before, but now it doesn't make much sense to me.
07:14:08 <astrolabe> Is there a library for making gifs?
07:14:20 <sorear> gd
07:14:47 <dons> cute, sorear .
07:14:57 <dons> i think a lot of new tickets have been opened (so not nec. bugs?)
07:15:06 <astrolabe> sorear: thanks
07:17:21 <Igloo> I think the ticket open rate mainly reflects the increase in number of users
07:17:39 <Igloo> Although I have no evidence to support that
07:21:00 <fasta> Igloo: do you have any idea where the Monad GHC.Prim.Any1 constraint can come from?
07:21:08 * roconnor trottles make!
07:21:09 <Igloo> No
07:21:14 <roconnor> arg
07:21:40 <sorear> @paste
07:21:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:24:11 <dons> Igloo: and people making feature requests
07:24:19 <dons> and library requests
07:24:54 <Igloo> I'm not sure if that's more common (proportionally) these days or not
07:25:14 <Igloo> Perhaps also people using the BTS more rather than just sending a mail to the list
07:25:23 <dons> yeah
07:25:27 <dons> ?bug <-- might help
07:25:28 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:25:38 <dons> people are encouraged to go there, from here.
07:29:00 <Baughn> @djinn (a, IO a) -> IO (a, a)
07:29:00 <lambdabot> -- f cannot be realized.
07:30:48 <dons> bit too hard
07:30:51 <Lemmih> @type uncurry (fmap . (,))
07:30:53 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
07:31:07 <dons> @djinn (Functor f) => (a1, f a) -> f (a1, a)
07:31:16 <dons> does it know about Functor? guess not.
07:31:40 <dons> @djinn (Eq a) => (a, a) -> Bool
07:31:40 <lambdabot> f (a, b) = a == b
07:34:37 <roconnor> fuck, my file names have : in them
07:34:41 <roconnor> fucking make!
07:34:43 <roconnor> Grrrrr
07:35:04 <dons> for i in * ; do j=`echo $i | sed 's/://g'; mv $i $j ; done -- ?
07:35:31 <dons> don't put off till tomorrow what you can sed today.
07:35:31 <roconnor> Hey, make is the trouble maker not my file names.
07:36:21 <roconnor> I'm thinking $(subst :,\\:, $(Files))
07:36:21 <phoniq> erm
07:36:32 <phoniq> COLON := ":"
07:36:48 <phoniq> myfile$(COLON)thing : depend$(COLON)dency
07:36:54 <dons> roconnor: doesn't that make your haskell bones creak? :-)
07:37:03 <dons> make must be the worst functional language by stealth ever.
07:37:27 <roconnor> where's our DSL haskell make thingy
07:37:38 <Igloo> It's not pure; the presence or absence of files can affect which rules apply
07:38:29 <roconnor> ?
07:38:51 <dons> make isn't a pure fp lang, though it has the flavour of one with its string ops
07:39:11 <dons> oleg has a nice post on how to do closures in make
07:39:26 <dons> s/nice/causes self harm/
07:40:09 <arcatan> oleg has a causes self harm post?
07:40:34 <dons> programming in make, causes me to want to hurt myself. :}
07:40:37 <wolverian> dons, have a url or so for it?
07:41:14 <dons> on, on his pobox domain somewhere
07:41:25 <dons> ?google closures make oleg
07:41:26 <lambdabot> http://okmij.org/ftp/Scheme/oop-in-fp.txt
07:41:32 <dons> somewhere around there
07:42:18 <roconnor> http://savannah.gnu.org/bugs/?112
07:42:20 <lambdabot> Title: make - Bugs: bug #112, Rules cannot cope with colons in... [Savannah]
07:42:31 <roconnor> Severity: Wish
07:42:42 <roconnor> of course dealing with directories with colons is only a wish
07:42:47 <fasta> Igloo: I managed to make a 66 line module that derives a Monad Any1 type.
07:42:52 <roconnor> why should make work with any file name?
07:42:55 <Saizan> oleg might become my only reason to learn scheme..
07:43:21 <roconnor> maybe I should remove all vowels too
07:43:24 <roconnor> grrr
07:44:47 <fasta> Where's the attach file button in Trac?
07:44:58 <Igloo> You have to make the bug first, then attach afterwards
07:46:56 <roconnor> phoniq: that's a nice idea, but i'm not sure how to make that fit in static pattern rules
07:47:31 <fasta> Igloo: what should be filled in in the test case field? "Yes"?
07:47:43 <phoniq> hrm
07:48:27 <phoniq> colons in your filesnames are dorking your static patterns?
07:48:32 <Igloo> fasta: The name of a bug in the testsuite, i.e. you should leave it blank
07:49:41 <roconnor> phoniq: yep
07:51:02 <phoniq> yeah
07:51:15 <phoniq> they just disappear somewhere in there
07:52:22 <phoniq> grr
07:53:38 <fasta> Igloo: There it is: http://hackage.haskell.org/trac/ghc/attachment/ticket/1382/Bugs.hs
07:53:41 <lambdabot> Title: #1382: Bugs.hs - GHC - Trac, http://tinyurl.com/2hxtg2
07:54:21 <Igloo> fasta: Thanks
08:07:44 <roconnor> maybe there is an alternative to gnu make that isn't broken?
08:08:19 <fasta> roconnor: since when is GNU Make broken?
08:08:41 <fasta> roconnor: I know some versions are not comparible with the GHC build process, but that's about all I have against it.
08:09:00 <fax> Hi
08:09:14 <fax> Does anyone have pictures of monds?
08:09:16 <fax> monads
08:10:04 <ohmega> http://en.wikibooks.org/wiki/Haskell/Monads
08:10:05 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
08:10:06 <roconnor> fasta: I can't get filenames with colons in them to work with static pattern rules
08:10:11 <ohmega> perhaps
08:10:42 <roconnor> http://savannah.gnu.org/bugs/?12126
08:10:43 <lambdabot> Title: make - Bugs: bug #12126, Backslashes for escaping colons in... [Savannah]
08:10:45 <Heffalump> I could take a picture of my computer, that's got lots of monads
08:12:22 <dons> fax, yeah, sigfpe did some picture
08:12:23 <dons> s
08:12:27 <dons> check his blog
08:15:07 <cinimod> @pl f x y = \c o -> f x (f y c) o
08:15:08 <lambdabot> f = fix (flip =<< (((.) . (.)) .))
08:15:25 <fax> hm
08:15:30 <fax> dons: I cant find it sigfpe.blogspot.com
08:15:34 <cinimod> @pl f (x,y) = \c o -> f x (f y c) o
08:15:35 <lambdabot> f = fix ((`ap` snd) . (. fst) . (flip =<< (((.) . (.)) .)))
08:16:22 <fax> ugh I have to go out
08:16:27 <fax> Ill search again, thanks
08:16:27 <fasta> roconnor: ok, that's not good.
08:17:18 <roconnor> fasta: Someone wrote a patch for it in 1995
08:17:50 <fasta> roconnor: O.o
08:22:10 <cinimod> fax: buy the t-shirt
08:22:15 <cinimod> http://www.cafepress.com/buy/monad/-/pv_design_prod/p_storeid.13479523/pNo_13479523/id_5238171/opt_/pg_/c_/fpt_
08:22:18 <lambdabot> Title: CafePress.com : Error, http://tinyurl.com/2e2m4m
08:26:29 <roconnor> *sigh* maybe dons is right, maybe I have to remove the :'s from my filenames
08:30:49 <pitecus> how do i tell cabal to copy header files in the right place?
08:37:43 <fasta> Wow, GHC really is doing something odd here.
08:38:04 <fasta> When I make a record, and then set a field to a value, I get the Any1 type.
08:38:18 <fasta> When I use a constructor to make the value, it doesn't.
08:38:42 <fasta> That seems pretty seriously broken.
08:45:39 <Lemmih> fasta: paste?
08:46:26 <fasta> Lemmih: Bug nr. #1382
08:46:54 <fasta> Lemmih: It should be a simple ghci Bugs.hs to reproduce it.
08:47:07 <fasta> Lemmih: so, it wouldn't cost you much time.
08:47:24 <fasta> Lemmih: for specific instructions on my latest finding, see the same bug.
08:47:50 <fasta> Now, let's hope that the work around works for my real code.
08:49:27 <sorear> Wow.  I never realized it was possible for someone to accidentally make 6 errors in a short 4-line program...
08:50:19 <fasta> Whoohoo, my work around works.
08:50:49 <fasta> Well, at least the type is sane now, don't know whether the code will actually work :)
08:53:30 <roconnor> > 0x113
08:53:31 <lambdabot>  275
08:53:35 <roconnor> > 0x133
08:53:36 <lambdabot>  307
08:54:51 <LoganCapaldo> > and . foldr (== 0) $ [0x0, 0b0, 0]
08:54:52 <lambdabot>   Not in scope: `b0'
08:55:00 <LoganCapaldo> > and . foldr (== 0) $ [0x0, 0o0, 0]
08:55:01 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `Bool'
08:55:19 <LoganCapaldo> > and id . foldr (== 0) $ [0x0, 0o0, 0]
08:55:27 <lambdabot>  Couldn't match expected type `[Bool]'
08:55:37 <LoganCapaldo> > and (== 0) [0x0, 0o0, 0]
08:55:37 <lambdabot>      The section `(== 0)' takes one argument,
08:55:38 <lambdabot>     but its type `[Bool]' has none
08:55:47 <LoganCapaldo> > and (==) [0x0, 0o0, 0]
08:55:48 <lambdabot>  Couldn't match expected type `[Bool]'
08:55:51 <fasta> >  all (== 0) [0x0, 0o0, 0]
08:55:58 <lambdabot>  True
08:56:02 <LoganCapaldo> brain fart
08:56:36 <LoganCapaldo> O!
08:56:56 <LoganCapaldo> it would be awesome if there was some program that just streamed interactions w/ ghci
08:57:11 <LoganCapaldo> to a window
08:57:13 <LoganCapaldo> with nicks
08:57:16 <fasta> LoganCapaldo: for me that would be quite boring.
08:57:17 <LoganCapaldo> (liek this)
08:57:34 <LoganCapaldo> and then smart people could show the dumb people how dumb they were being
08:57:37 <LoganCapaldo> heh
08:58:07 <LoganCapaldo> ok maybe it wouldn't be awesome
08:58:15 <fasta> LoganCapaldo: If you would look to my stream, you would see nothing for about 30 minutes on end.
08:58:21 <LoganCapaldo> I've only had .5 cups of coffee
08:59:26 <LoganCapaldo> @docs Network
08:59:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
08:59:44 <fasta> Meh, I think GHC 6.6.1 changed the type inference in some annoying ways.
09:01:22 <LoganCapaldo> @hoogle select
09:01:22 <lambdabot> Text.Html.select :: Html -> Html
09:01:22 <lambdabot> Text.Html.selected :: HtmlAttr
09:01:27 <LoganCapaldo> @hoogle poll
09:01:28 <lambdabot> No matches found
09:01:36 <LoganCapaldo> @hoogle Must I use threads?
09:01:37 <lambdabot> Did you mean: Must I Use Threads?
09:02:08 <sorear> LoganCapaldo: Yes!
09:02:25 <LoganCapaldo> sorear: Really?
09:02:47 <sorear> LoganCapaldo: Really.  What do you have against them?  They use select underneath
09:03:18 <LoganCapaldo> Nothing really, I just like giant event loops
09:04:21 <fasta> Any way to see the version of ghc currently being used in haskell-mode?
09:04:23 <LoganCapaldo> And I was expecting to see a really HOFy version of select in Haskell
09:05:36 <LoganCapaldo> like select :: (Handle -> IO a) -> (Handle -> IO a ) -> (Handle -> IO a) -> Int -> [Socket] -> [Socket] -> [Socket] -> IO () or something
09:06:14 <fasta> Never mind
09:06:21 <cinimod> Anyone here on the very latest ghc who wouldn't mind trying something for me?
09:06:22 <LoganCapaldo> threads it is
09:06:36 <cinimod> I'll paste the code
09:06:38 <sorear> cinimod: No, the ghc build is rather broken atm
09:06:48 <LoganCapaldo> PortID is a pretty datta type
09:06:49 <sorear> cinimod: I can try somthing on 2-week-old ghc
09:06:50 <bos> @seen CosmicRay
09:06:50 <lambdabot> CosmicRay is in #haskell-blah, #darcs and #haskell. I last heard CosmicRay speak 4h 40m 26s ago.
09:07:07 <LoganCapaldo> Service "http" or PortNumber 80. I likes it
09:07:11 <cinimod> sorear: that would be good
09:07:21 <cinimod> sorear: I'll go and paste
09:08:50 <gidyn> @help
09:08:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:09:49 <hpaste>  cinimod pasted "Functional Unparsing with GADTs" at http://hpaste.org/70
09:11:38 <sorear> cinimod: Um, what are you trying to do?
09:11:59 <cinimod> the exercises in fun with phantom types
09:13:06 <cinimod> sorear: this one is supposed to C's printf function
09:13:12 <sorear> I think you have the type of :^: wrong.
09:13:50 <sorear> it probably should be (:^:) :: Dir a b -> Dir b c -> Dir a c   or   Dir a b -> Dir c a -> Dir c a
09:14:01 <sorear> (i'm too lazy to figure out which one)
09:14:43 <cinimod> sorear: I think I'm right. I'll give you an example.
09:15:24 <cinimod> take d2 to be Dir x (String -> x) and d1 to be Dir a (Int -> a)
09:16:41 <sorear> Instantiate a to be String -> x, then d2 :: Dir x (String->x)  d1 :: Dir (String->x) (Int->String->x)
09:17:04 <sorear> @type (.)  -- shouldn't it look like this type?
09:17:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:17:13 <cinimod> yes
09:17:35 <sorear> @type (>>>)
09:17:36 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
09:17:40 <cinimod> I mean yes to (Int -> String -> x)
09:18:13 <cinimod> It's not meant to be functional composition
09:18:19 <cinimod> Did it compile on your ghc?
09:18:48 <sorear> no, I didn't try it
09:20:05 <sorear> nope, doesn't compile on  / /_\// /_/ / /  | |    GHC Interactive, version 6.7.20070518, for Haskell 98.
09:20:27 <cinimod> I think it should be Dir a b :^: Dir c a
09:20:35 <cinimod> I'll go and try
09:20:44 <cinimod> Thanks for trying it out
09:22:11 <cinimod> Aah that's done the trick. It wasn't something that only works in the latest ghc.
09:33:12 <LoganCapaldo> @hoogle StdOut
09:33:12 <lambdabot> IO.stdout :: Handle
09:35:36 <nominolo> hm, what is the preferred way to override an installed package with a (development) version in the current directory?
09:36:19 <nominolo> maybe just add a local pkg info?  if so, how do i do that?
09:40:42 <waern_> configure --user
09:42:37 <nominolo> ah, thanks, just discoverd it too.
09:55:50 * LoganCapaldo is annoyed getLine doesn't preserve the line terminator
09:56:29 <LoganCapaldo> is there an alternative function that does?
09:57:07 <LoganCapaldo> @hoogle IO String
09:57:08 <lambdabot> Prelude.getContents :: IO String
09:57:08 <lambdabot> Prelude.getLine :: IO String
09:57:08 <lambdabot> System.getProgName :: IO String
09:57:35 <LoganCapaldo> @hoogle Char -> IO String
09:57:36 <lambdabot> No matches, try a more general search
09:57:58 <LoganCapaldo> @hoogle (Char -> Bool) -> IO String
09:57:59 <lambdabot> No matches, try a more general search
09:59:05 <LoganCapaldo> >  lines "a\nb\n"
09:59:09 <lambdabot>  ["a","b"]
09:59:12 <LoganCapaldo> grr
09:59:22 <LoganCapaldo> Must be some kind of conspiracy, <g>
10:01:22 <LoganCapaldo> sorear: fwiw looks like the select functionality does exist, in a sense, hWaitForInput and hReady
10:08:50 <shapr> SHAZAM!
10:09:03 <Lemmih> WHAHOO!
10:09:07 * shapr hugs Lemmih 
10:10:00 <Lemmih> How's this Sunday afternoon treating you, Shae?
10:10:58 <shapr> Quite well, I went to a family party yesterday and met people I hadn't seen in fifteen years. Today my sister and my mother and I went out for a relaxed breakfast that lasted four or five hours. It's been great fun!
10:11:17 <shapr> How's your day?
10:12:26 <shapr> Now it's time for HAPPY HACKING!
10:12:31 <shapr> YOW! Are we having CODE yet?
10:13:05 <Lemmih> Happy hacking? Is that related to happy slapping?
10:13:16 <shapr> Definitely not.
10:13:30 <shapr> I mean that sort of hyperfocus coding where you can leave the world behind and hack until you fall over.
10:13:58 <shapr> If someone tried happy slapping on me I'd show them that I don't always use my powers for good.
10:18:56 <LoganCapaldo> Writing type signatures makes me happy
10:19:55 <opqdonut> :D
10:20:07 <opqdonut> "writing type signatures floats my boat"
10:20:47 <dmwit> > cast (3 :: Float) :: Boat -- ?
10:20:48 <lambdabot>   Not in scope: type constructor or class `Boat'
10:23:29 <LoganCapaldo> @type mfix
10:23:31 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:23:47 <LoganCapaldo> @pl forever a = a >> forever a
10:23:47 <lambdabot> forever = fix (ap (>>))
10:24:31 <dmwit> :t fix . ap $ (>>)
10:24:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:24:44 <LoganCapaldo> @type let forever a = a >> forever a in forever
10:24:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:25:37 <dmwit> > fix . ap . (>>) $ [1,2]
10:25:37 <lambdabot>  Couldn't match expected type `b -> a' against inferred type `[a1]'
10:26:23 <dmwit> > fix (ap (>>)) [1,2]
10:26:25 <lambdabot>  Exception: stack overflow
10:26:55 <LoganCapaldo> Should this make me feel better, or is it just silly?
10:26:57 <LoganCapaldo> forever :: IO a -> IO ()
10:26:57 <LoganCapaldo> forever a = a >> forever a >> return ()
10:27:36 <dmwit> It's not just silly, it's probably actively bad.
10:27:51 <LoganCapaldo> Hoorah!
10:27:53 <dmwit> This gets rid of the obviousness of tail-call optimization...
10:27:57 * LoganCapaldo debadifies
10:28:47 <Lemmih> forever :: IO a -> IO (); forever a = let loop = a >> loop in loop
10:29:17 <LoganCapaldo> Lemmih: Why the extra binding?
10:29:27 <fasta> Lemmih: does forever a = a >> forever a not work as efficiently?
10:29:41 <dmwit> :t let forever a = let loop = a >> loop in loop in forever
10:29:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:30:39 <Lemmih> fasta: GHC isn't very good at hoisting out constant arguments.
10:31:07 <LoganCapaldo> @type (\a -> sequence_ (replicate a))
10:31:09 <lambdabot>     Couldn't match expected type `[m a]'
10:31:09 <lambdabot>            against inferred type `a1 -> [a1]'
10:31:20 <LoganCapaldo> :t sequence_
10:31:20 <fasta> Lemmih: are you saying that my version of forever doesn't run in constant space?
10:31:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:31:29 <LoganCapaldo> :t replicate
10:31:31 <lambdabot> forall a. Int -> a -> [a]
10:31:35 <LoganCapaldo> oops
10:31:43 <LoganCapaldo> @hoogle a -> [a]
10:31:44 <lambdabot> Prelude.repeat :: a -> [a]
10:31:44 <lambdabot> List.intersperse :: a -> [a] -> [a]
10:31:44 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
10:31:51 <LoganCapaldo> @type (\a -> sequence_ (repeat a))
10:31:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
10:32:18 <LoganCapaldo> Will that be deforested?
10:32:55 <Lemmih> fasta: Nah, it'll just peek/poke from/to the stack at every iteration.
10:34:26 <fasta> Lemmih: ?
10:34:41 <fasta> Lemmih: does it run in constant space or not?
10:35:19 <LoganCapaldo> Lemmih: Does this: forever a = loop where loop = a >> loop have the same chareteristics as the let version?
10:35:40 <LoganCapaldo> (I just like the way it reads better)
10:35:54 <Lemmih> LoganCapaldo: Yes.
10:36:44 <LoganCapaldo> Thanks
10:36:47 <Lemmih> fasta: I hope it does.
10:37:01 * fasta looks at 3 pages of types 
10:37:17 <fasta> Something is wrong
10:39:26 <LoganCapaldo> @index forkIO
10:39:27 <lambdabot> Control.Concurrent
10:39:32 <LoganCapaldo> @ty forkIO
10:39:41 <lambdabot> Not in scope: `forkIO'
10:41:28 <int-e> @ty Control.Concurrent.forkIO
10:41:30 <lambdabot> IO () -> IO GHC.Conc.ThreadId
11:02:25 <hpaste>  LoganCapaldo pasted ""Echo" server, comments, criticisms?" at http://hpaste.org/71
11:02:55 <LoganCapaldo> I realize you guys have nothing better to do on a sunday afternoon than pick aprt my code so I figured...
11:02:59 <LoganCapaldo> kidding of course!
11:07:47 <wolverian> would be nice for symmetry if server was its own function like client
11:09:00 <LoganCapaldo> wolverian: Fair enough
11:09:10 <wolverian> nitpicking, I know :)
11:09:24 <LoganCapaldo> main is / was supposed to be server's own function
11:09:35 <LoganCapaldo> but I thought withSocketsDO $ do ... looks ugly
11:15:13 <hpaste>  LoganCapaldo annotated ""Echo" server, comments, criticisms?" with "echo was silly" at http://hpaste.org/71#a1
11:22:03 <hpaste>  LoganCapaldo annotated ""Echo" server, comments, criticisms?" with "So long unecessary function" at http://hpaste.org/71#a2
11:22:41 <Cheery> now I've seen prolog, haskell, forth.. and I think I'm addicted
11:22:50 <opqdonut> to what?
11:22:53 <opqdonut> programming?
11:22:58 <augustss_> Cheery: to what?
11:22:58 <Cheery> to diversity in programming
11:23:08 <LoganCapaldo> Cheery++
11:24:13 <opqdonut> prolog++
11:24:18 <opqdonut> :)))
11:25:14 <Cheery> that trio consist from languages which are far as possible from each other
11:25:39 <opqdonut> wouldn't say so, really
11:25:46 <opqdonut> forth is quite lazy and functional in a way
11:25:47 <LoganCapaldo> Cheery: you sure? After all both prolog and haskell have pattern matching...
11:26:06 <Cheery> yes, but they all are foundationally different
11:26:06 <newsham> hpaste question: what's the minimal way to disable the bot?  can I just neuter runBot or do I need to alter the thread communications in the main thread too?
11:26:07 <LoganCapaldo> declarations look fairly similar in both
11:26:20 <dmwit> And as everybody knows, pattern matching is the defining point of Haskell.
11:26:24 <dmwit> ;-)
11:26:42 <LoganCapaldo> dmwit: what I'm not allowed to make surface comparisions? :)
11:26:48 <Excedrin> Prolog is just a stack based lazy functional language
11:28:09 <Cheery> Do you know language(s) which would be as far from those three as they are from each other?
11:28:30 <mauke> tamerlane
11:28:34 <dmwit> Well, there's always pathological languages.
11:28:47 <LoganCapaldo> Can't get enough of those pathological languages :)
11:28:48 <dmwit> Mondrian
11:28:54 <Excedrin> Malbolge and Piet
11:29:04 <mauke> Sorted!
11:29:25 <LoganCapaldo> Labview is pretty far out there
11:29:25 <mauke> http://catseye.tc/projects/tamerlane/doc/tamerlane.html
11:29:27 <lambdabot> Title:
11:29:28 <opqdonut> Gripped!
11:30:18 <pitecus> I can't figure out how to use cabal with a project which uses FFI and C++ sources
11:30:26 <pitecus> Is it even possible?
11:30:33 <sorear> pitecus: Afaik, no.
11:30:47 <Lemmih> sorear: No?
11:30:54 <pitecus> sorear, so i should use make?
11:31:58 <sorear> pitecus: Yeah, we normally use make+autotools for the 3% of projects that cabal doesn't handle... cf gtk2hs for a good example of a non-cabal haskell build system
11:33:20 <pitecus> sorear, i dont quite feel like learning the autotools thing for just one small library ... I ll have a look at gtk2hs though
11:33:39 <ejt> @hoogle unique
11:33:39 <lambdabot> Data.Unique :: module
11:33:39 <lambdabot> Data.Unique.Unique :: data Unique
11:33:39 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
11:33:40 <Lemmih> pitecus: What problems did you encouter?
11:33:47 <Lemmih> *encounter
11:34:14 <pitecus> Lemmih, basically i think cabal is trying to make ghc compile the c++ sources and it barfs at them
11:34:48 <pitecus> manually i did it liek this: use gcc to compile the c++ stuff
11:35:05 <pitecus> and then pass the resulting .o files to ghc
11:35:49 <Lemmih> pitecus: GHC should be able to delegate C++ sources to gcc.
11:36:01 <pitecus> Thing is i'd like to install the compiled library somewhere where GHC is gonna look for it
11:36:12 <pitecus> And i always relied on cabal to do that
11:36:17 <fasta> MonadST s m => MonadST s (FooMonad m) <- why is this undecidable?
11:36:22 <pitecus> i dont even know what files GHC needs
11:37:03 <pitecus> Lemmih, any idea what to put in .cabal to make ghc use gcc to compile c++?
11:37:21 <Lemmih> pitecus: It should do it by itself.
11:37:26 <Lemmih> pitecus: `ghc -c somefile.cpp` barfs?
11:38:16 <pitecus> cabal runs this: /usr/bin/ghc -Isrc/GramLab/Maxent -odir dist/build -hidir dist/build -c src/GramLab/Maxent/c_maxent.cpp
11:38:26 <pitecus> and this gives dozens of errors
11:38:32 <Lemmih> ?paste
11:38:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:38:35 <Heffalump> fasta: perhaps because the 's' is a type variable? Just guessing.
11:41:59 <shapr> jiihaa!
11:42:07 <hpaste>  pitecus pasted "cabal with FFI" at http://hpaste.org/73
11:42:54 <sorear> fasta: Because GHC doesn't look at the left part when checking fundep coverage conditions.
11:46:25 <fasta> sorear: so, it's not undecidable, it's just that GHC isn't smart enough for this particular instance in the standard setting (without that flag)
11:46:59 <Lemmih> pitecus: What version of ghc do you have?
11:47:07 <pitecus> 6.6.1
11:48:47 <nominolo> anyone with admin access for the hackage trac?
11:49:15 <Lemmih> pitecus: Those errors don't look like GHC errors. Try running ghc with -v.
11:57:01 <dmwit> http://www.jucs.org/jucs_10_7/total_functional_programming/ -- I found this paper very interesting.
11:57:03 <lambdabot> Title: (D. A. Turner) Total Functional Programming
11:57:26 <augustss_> it is
11:57:50 <dmwit> (Although I don't understand a lot of it.)
11:57:52 * araujo loves lexical closures
12:00:44 <fasta> dmwit: I didn't read it, but I saw the webpage.
12:02:29 <dmwit> It covers a lot of ground in one paper.
12:03:47 <fasta> It sounds like the Holy Grail of safe programming languages.
12:04:07 <dmwit> Even more bondage than Haskell!  It's a godsend. =)
12:04:23 <fasta> OTOH, for some new algorithms, the complexity is not known.
12:05:01 <dmwit> Yeah, that could be a problem
12:05:02 <dmwit> .
12:05:28 <augustss_> fasta: but you can write any algorithm that is provably terminating in second order arithmetic
12:05:57 <dmwit> I thought it was mildly amusing when he said the possibility of passing a strictly decreasing complexity parameter "doesn't win any prizes for elegance."
12:06:01 <augustss_> but sometimes you need to break out of the provably terminating
12:06:48 <augustss_> a monad for general recursion is the way to go, i think
12:07:00 <ndm> @seen dcoutts
12:07:01 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 2d 3h 28m 56s ago.
12:07:06 <ndm> @seen dcoutts_
12:07:06 <lambdabot> dcoutts_ is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I last heard dcoutts_ speak 3d 1h 43m 57s ago.
12:07:08 <fasta> augustss_: so, you don't need to know the actual complexity, just that it terminates?
12:07:19 <ndm> @karma- cabal
12:07:19 <lambdabot> cabal's karma lowered to 4.
12:08:06 <mattam> augustss_: you mean permitting non-termintation in a particular monad ?
12:11:02 <pitecus> Lemmih, you were right it was something else.
12:11:09 <pitecus> I managed to install the library
12:11:18 <pitecus> One glitch is tho
12:11:23 <sorear> augustss_: Really?  How do you turn a proof of TM termination into a high order fold?
12:11:54 <pitecus> that now when try to compile a program which used the module I have to pass -lstdc++ option to GHC
12:12:10 <pitecus> Should that be necessary?
12:12:12 <ndm> sorear, i'm about to release derive - any final things that need doing?
12:12:15 <Lemmih> pitecus: Yes.
12:12:20 <pitecus> Hmm
12:12:23 <ndm> everything else can be punted to the next release, i'm only 0.1'ing it
12:12:40 <pitecus> Thats not quite confusing...
12:12:50 <LoganCapaldo> @type forM
12:12:52 <lambdabot>     Ambiguous occurrence `forM'
12:12:52 <sorear> ndm: Not that I can immediately think of
12:12:52 <lambdabot>     It could refer to either `forM', imported from Data.Traversable
12:13:04 <LoganCapaldo> @type Control.Monad.forM
12:13:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
12:13:34 <ndm> cool :) - expect a release within a few hours
12:15:19 <LoganCapaldo> @type Control.Monad.forM_
12:15:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
12:16:50 <aleator> If I stick my speed critical code that iterates (a-> m a) type dingus in cont-monad, how huge speed hit do I take?
12:19:08 <dmwit> > let trunc xs ys = unzip (zip xs ys) in trunc [1,2,3] (repeat False)
12:19:09 <lambdabot>  ([1,2,3],[False,False,False])
12:25:36 <dmwit> > (-1 `mod` 3, -(1 `mod` 3), (-1) `mod` 3) -- x_x
12:25:38 <lambdabot>  (-1,-1,2)
12:29:58 <newsham> anyone awake who knows hpaste or happs?
12:30:03 <ndm> hmm, how do i get a hackage username/password?
12:30:11 <ndm> Igloo perhaps?
12:30:17 <ndm> @seen Igloo
12:30:17 <lambdabot> Igloo is in #happs, #haskell-overflow, #darcs, #ghc and #haskell. I last heard Igloo speak 2h 50m 2s ago.
12:30:35 <shapr> newsham: What's up?
12:32:32 <newsham> hey shapr.   when I run "dist/build/hpaste/hpaste >& out &" the program stops immediately
12:32:35 <newsham> [2]+  Stopped                 dist/build/hpaste/hpaste 1>&out
12:32:41 <newsham> any idea why?
12:32:48 <newsham> does it want stdinput?
12:33:14 <newsham> i would like to background this thing
12:33:27 <newsham> is this a happs thing or something due to hpaste's impl?
12:33:28 <kaol> use screen?
12:33:54 <newsham> kaol: so my server doesnt background properly so I should run another large program to run my server in?  wrong answer. :(
12:34:59 <ndm> sorear, do you have a Hackage username/password?
12:35:04 <ndm> or is there a default one I can use
12:35:13 <ndm> it doesn't mention one
12:35:55 <fasta> Aarg, when I do :t <expr> in ghci I get the right type, but when I put a = <expr> in a file and ask for the type I get the wrong type.
12:36:33 <Igloo> ndm: Do you have a Cabal or ghc trac loging?
12:36:38 <Igloo> ndm: If so that might work
12:36:51 <fasta> GHC is becoming _way_ too unpredictable.
12:36:59 <ndm> Igloo, i always go in under guest
12:37:16 <ndm> i maybe should have one
12:37:32 <ndm> but i love that in trac you can log in as guest, then change the username field before you post :)
12:37:41 <Igloo> ndm: e-mail Ross, as per http://hackage.haskell.org/packages/accounts.html
12:37:43 <lambdabot> Title: HackageDB: User accounts
12:38:04 <ndm> Igloo, already done, just was trying to upload my package with instant gratification
12:38:22 <ndm> and I even included a LICENSE file :)
12:38:40 * Igloo knows nothing about the hackage implementation, so doesn't want to go prodding things
12:38:42 <sjanssen> fasta: defaulting, perhaps?
12:38:50 <ndm> fair enough
12:39:11 <ndm> anyone mind uploading a tarball for me?
12:39:15 <ndm> i can put it on the web
12:39:23 <fasta> sjanssen: I thought of that, but I am not sure how that mechanism works in ghci.
12:39:50 <dmwit> ?index nub
12:39:50 <lambdabot> Data.List
12:40:04 <sjanssen> fasta: ghci gives a more or less polymorphic type?
12:40:16 <ndm> monomorphism i bet
12:40:30 <ndm> fasta, try a _ = ... and then type check
12:40:47 <fasta> sjanssen: hard to answer, but ghci gives the right type in the interpreter. In a file it returns a type containing Any in contexts.
12:41:57 <fasta> ndm: same problem with an extra parameter.
12:42:12 <fasta> ndm: AFAIK, Any should _never_ be derived.
12:43:04 <shapr> newsham: Nah, I have the same sort of problem, I just used screen.
12:44:05 <shapr> newsham: Lemmih and I switched HAppS to use hslogger for console output and Posix signal handlers for termination, so HAppS programs should work just fine that way now, but I couldn't get hpaste to do that.
12:44:09 <hpaste>  LoganCapaldo pasted "Multiuser "chat" server, comments, criticisms?" at http://hpaste.org/74
12:45:54 <sorear> ndm: I do have a hackage acct
12:45:57 <LoganCapaldo> I suspect I might be abusing MVar
12:46:39 <fasta> sjanssen: what else can I do?
12:46:47 <ndm> sorear, do you mind releasing derive? darcs pull, runhaskell Setup sdist is probably easier than me posting a tarball
12:47:40 <ndm> anway, dinner - back later
12:48:35 <sjanssen> fasta: hmm, not sure
12:48:55 <jfredett> muhaha, another PE problem down... :)
12:48:56 <newsham> hrmm.. i'm using the latest happs with hslogger prereq (got from darcs last night)
12:48:57 <sjanssen> fasta: this Any is ghc's builtin universal type?
12:49:15 <fasta> sjanssen: I don't know, but it's not any of my types.
12:51:24 <jfredett> is there a LCM function which operates over a list? or am I gonna have to foldr?
12:51:54 <jfredett> i know about the normal lcm function
12:52:00 <jfredett> > :t lcm
12:52:00 <lambdabot>  Parse error
12:52:10 <sjanssen> > foldl' lcm 1 [1..5]
12:52:11 <lambdabot>  60
12:52:13 <fasta> All the problems I have with GHC currently make me long to Scheme, but somehow I doubt that any of the Scheme implementations would please me. :(
12:52:13 <sorear> > foldr lcm 1 [2,3,4,5,6]
12:52:15 <lambdabot>  60
12:52:22 <jfredett> okay, so I have to foldr, cool
12:52:32 <sorear> not hard! :)
12:52:57 <jfredett> yah, I'd just rather use builtin's than reinventing the wheel
12:53:01 <sjanssen> jfredett: foldl or foldl' will generally use less space (important if your input is large)
12:53:08 <jfredett> cool
12:55:30 <fasta> sjanssen: it's only a constant factor less space for non-streaming applications, right?
12:56:27 <sjanssen> fasta: O(n) additional space vs. O(1)
12:56:50 <fasta> sjanssen: yes, but when compared to the input it's a constant factor.
12:57:18 <sjanssen> sure, but I don't think that's a particularly useful point of view
12:57:36 <sjanssen> especially in the presence of laziness, which you already pointed out
12:57:39 <dmwit> If I have (newtype Circular = Circular Int), what's the most convenient way of pushing, say, (+1) into that type?
12:58:12 <sjanssen> dmwit: deriving Num? (needs -fglasgow-exts)
12:58:55 <sjanssen> or: newtype C = C {unC :: Int}; add1 = C . (+1) . unC
12:59:29 <dmwit> Okay, so define something like (lift f (Circular a) = Circular (f a)).
12:59:31 <dmwit> Thanks.
13:05:10 <Alneyan> I'm curious: is Data.Set supposed to work with infinite, ordered lists? Say, member 3 $ fromDistinctAscList [1..] . It fails to terminate here, so I wonder if I'm doing something wrong or Data.Set is only for finite sets.
13:06:19 <dmwit> Data.Set is for finite sets.
13:08:05 <Alneyan> Thanks.
13:10:18 <Heffalump> shame :-)
13:10:40 <dmwit> Heffalump: How to do it (quickly) for infinite sets?
13:11:25 <Heffalump> I wasn't serious
13:11:34 <int-e> dmwit: for integers you can still build (skewed) ordered trees.
13:11:46 <Heffalump> Given that the operations are log-n, there's a bit of an issue with n being infinite.
13:11:54 <LoganCapaldo> I see there is an isEmptyChan function.  If I don't want block on reading from a chan, isn't if isEmptyChan c then Nothing else Just (readChan c) a race condition?
13:12:01 <dmwit> ?hoogle (Functor f) => f (a -> b) -> f a -> f b
13:12:05 <lambdabot> Prelude.asTypeOf :: a -> a -> a
13:12:05 <lambdabot> Prelude.const :: a -> b -> a
13:12:05 <lambdabot> Prelude.seq :: a -> b -> b
13:12:10 <LoganCapaldo> And if so, is there a non-race conditiony way to do it?
13:12:21 <int-e> dmwit: but that wouldn't be Data.Set. (note that when building a set from an ascending list, even unsuccessful membership tests can terminate)
13:13:01 <int-e> dmwit: the O(log n) would become O(log k) where k is the accessed key, I guess.
13:13:13 <Heffalump> dmwit: f (a -> b, a) -> f b is easy, if that helps..
13:13:26 <dmwit> int-e: Hmm, you can build a non-degenerate skewed tree?
13:14:21 <dmwit> i.e. something that is better for a list, but still can be build from an infinite ascending list?
13:14:27 <dmwit> s/for/than/
13:14:39 <sjanssen> LoganCapaldo: guard the Chan with an MVar?
13:14:50 <sjanssen> LoganCapaldo: or use STM and TChan
13:15:04 <Heffalump> dmwit: think of the degenerate skewed tree (i.e. a list)
13:15:18 <int-e> dmwit: you can represent it as a list of normal sets: [Set for values 1..n, Set for values n+1 .. 2n, Set for values 2n+1 .. 4n, Set for values 4n+1 .. 8n, etc (where the ranges become increasingly longer)]
13:15:19 <Heffalump> then instead of hanging one element off the non-infinite children, hang 2^n
13:15:51 <Heffalump> Then each element k is at depth 2log_2 k, roughly
13:15:53 <int-e> dmwit: and you can view that as a skewed tree. I think the list is actually a viable representation if you want to reuse Data.Set though :)
13:16:08 <dmwit> Ah, that's interesting.
13:16:10 <dmwit> Very nice!
13:16:55 <sorear> You can also use tries.
13:17:01 <LoganCapaldo> sjanssen: so I'd atomically (if isEmptyTChan ...) ?
13:17:15 <sorear> data NatSet = NatSet Bool NatSet NatSet
13:17:24 <sorear> member 0 (NatSet a _ _) = a
13:17:53 <int-e> hmm, but that is inefficient for sparse sets
13:17:59 <sorear> member (k+1) (NatSet _ x y) = member (k `div` 2) (if (odd x) then y else x)
13:18:00 <sjanssen> LoganCapaldo: yeah.  The algorithm you showed earlier automatically works correctly in STM
13:18:16 <int-e> but yes, the idea works, of course.
13:18:22 <sorear> int-e: no more so than your approach
13:18:53 <sorear> int-e: I have to decend lg(k) levels, you have to inspect the lg(k)'th element of a linked list
13:19:05 <int-e> sorear: but you use more memory
13:19:21 <int-e> sorear: that's what I meant. Sorry, efficiency is ambiguous :)
13:19:46 <dmwit> ?instances Functor
13:19:48 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:19:53 <dmwit> :k (,) a
13:19:55 <lambdabot> Not in scope: type variable `a'
13:20:00 <dmwit> :k forall a . (,) a
13:20:02 <lambdabot>     `(,) a' is not applied to enough type arguments
13:20:02 <lambdabot>     Expected kind `*', but `(,) a' has kind `* -> *'
13:20:24 <sorear> int-e: We both use an infinite amount of memory :)
13:20:54 <sorear> lazily of course
13:21:08 <dmwit> Why does "newtype Ident a = Ident a deriving Monad" fail?  (I have -fglasgow-exts enabled.)
13:21:44 <sjanssen> dmwit: kind issues
13:21:58 <sjanssen> newtype Ident m a = Ident (m a) -- should work
13:22:28 <dmwit> Wait, isn't Ident :: * -> * ?
13:22:43 <sorear> dmwit: yes, but deriving is
13:22:48 <sorear> n't smart enough
13:23:05 <dmwit> hmph
13:25:00 <int-e> sorear: hmm. it depends on the use case too much, really. but the concept is neat :)
13:26:16 <Heffalump> how is deriving supposed to know about the identity monad?
13:26:27 <sorear> Yeah, it's probably about as useful as SICP's differential equation combinators :)
13:26:28 <Heffalump> I mean, I realise it _could_, but it seems rather ad-hoc
13:27:19 <sorear> Heffalump: isn't the whole point of deriving to be ad-hoc? :)
13:27:37 <Heffalump> only in a principled way :-)
13:28:41 <SamB> sjanssen: isn't that called IdentT?
13:29:24 <Heffalump> oh, I see, are you trying to eta-reduce newtypes?
13:29:25 <sjanssen> SamB: yeah.  I kinda missed the point of dmwit's question
13:29:38 * Heffalump thinks there are two different possibilities for what was meant
13:29:41 <SamB> sjanssen: I think Heffalump's answer is most useful
13:30:04 <SamB> sorear: newtype deriving isn't supposed to be ad-hoc
13:30:06 <Heffalump> either dmwit did want IdentT but tried to eta-reduce the newtype (which I don't think makes sense, but I would need to think about it more)
13:30:19 <fasta> How would MonadST s Control.Monad.Identity.Identity look like?
13:30:24 <Heffalump> SamB: I think sorear was referring to the fact that type classes are about ad hoc polymorphism
13:30:34 <SamB> Heffalump: oh.
13:30:39 * SamB groans at pun
13:30:40 <Heffalump> fasta: unimplementable?
13:30:50 <sjanssen> fasta: not possible
13:30:53 <fasta> Heffalump: yep, that's what I thought
13:31:13 <Heffalump> SamB: I nearly replied your way too before I realised what (I think) he meant :-)
13:31:13 <fasta> So, would that mean I need to add a liftST somewhere?
13:31:28 <Heffalump> actually, is it even kind correct?
13:31:37 <SamB> Heffalump: dunno.
13:31:45 <Heffalump> is the instance MonadST s ST, or MonadST s (ST s)?
13:31:53 <Heffalump> (I don't recall actually seeing MonadST in the mtl)
13:32:29 <fasta> Heffalump: what do you mean? How the class declaration look slike?
13:32:41 <Heffalump> yes
13:32:54 <fasta> class Monad m => MonadST s m | m->s where liftST :: ST s a -> m a
13:33:05 <Heffalump> ok, so it is MonadST s (ST s)
13:33:12 <Heffalump> and the Identity one would be kind correct.
13:33:20 <fasta> instance MonadST s (ST s) where liftST = id
13:33:36 <fasta> Heffalump: What do you mean by that last remark?
13:33:45 <fasta> Heffalump: never mind
13:34:11 <sorear> it probably can be done.  but rankn forall polymorphism is too disgusting for me to figure out how
13:35:06 * sorear greatly prefers Fw-style type abstraction semantically, but acknowledges the objections people have to its verbosity
13:37:17 <ndm> @seen Igloo
13:37:17 <lambdabot> Igloo is in #happs, #haskell-overflow, #darcs, #ghc and #haskell. I last heard Igloo speak 57m 52s ago.
13:37:35 <kosmikus> sorear: agreed, being explicit has many advantages indeed.
13:38:16 <ndm> Igloo, does th-lift do anything that Data.Derive shouldn't be doing? i.e. should we incorporate it and kill of th-lift?
13:40:19 <Igloo> ndm: What would deriving Lift Int look like with Data.Derive?
13:40:56 <Igloo> ndm: Actually, maybe an instance for Maybe would be a better example
13:43:32 <ndm> Ilgoo, it doesn't yet - if you give me an example i can base it all off that
13:44:01 <ndm> http://www.cs.york.ac.uk/fp/haddock/derive/Data-DeriveGuess.html
13:44:12 <ndm> if you give me an example instance for that data type, i can probably do it all
13:44:23 <ndm> i just wondered if th-lift did anything more than Data.Derive?
13:45:03 <Igloo> ndm: OK, can you point me at an example for any class?
13:45:24 <ndm> Igloo, the results, or how we write an instance deriver?
13:45:38 <Igloo> ndm: Both
13:46:10 <ndm> http://www.cs.york.ac.uk/fp/darcs/derive/Data/Derive/Eq.hs
13:46:39 <ndm> thats the Eq deriver, showing derivation by guess, and a hand written (commented out) definition as well
13:46:45 <ndm> the "result" looks exactly like you
13:47:14 <ndm> 'd expect, i.e. instance Eq a => Eq (Maybe a) where Nothing == Nothing = True; Just x == Just y = x == y
13:48:06 <int-e> ; _ == _ = False
13:48:20 <ndm> of course :)
13:48:27 <Heffalump> it's a shame you can't write
13:48:29 <Heffalump> Nothing == Nothing
13:48:29 <ndm> Data.Derive is a lot more reliable than Neil
13:48:36 <dcoutts> hia ndm, you were after me?
13:48:48 <ndm> dcoutts, i've worked around it - i managed to get cabal sdist working
13:48:50 <Heffalump> (well, not much of a shame, it's not really necessary extra syntax, but it'd be neat)
13:49:12 <ndm> dcoutts, i still don't have a  hackage account, do i need to wait for ross?
13:49:47 <Igloo> ndm: I'm a bit confused; is eq' automatically written by looking at the hand-written instance in example and guessing?
13:49:56 <dcoutts> ndm: yep, ask Ross
13:50:19 <Igloo> ndm: And how would you actually use it?
13:50:24 <ndm> Igloo, yes, if you read the manual it explains it all
13:50:30 <dcoutts> Excedrin: you probably want to cache a cairo image surface, see the gtk2hs/cairo clock demo for an example
13:50:52 <ndm> Igloo, and file.hs --derive=Eq, or deriving ({-! Eq  !-})
13:51:08 <ndm> or $(derive mkEq ''Foo)
13:51:31 <ndm> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
13:51:32 <Igloo> OK, it's probably pretty much the same functionality, then
13:51:33 <lambdabot> Title: Data.Derive: A User Manual
13:51:37 <waern> ndm: you got the O'Rear problem with cabal sdist? :)
13:51:51 <ndm> waern, no - what was it?
13:52:01 <waern> oh, that's not with sdist
13:52:38 <waern> it's when making cabal generate packate register scripts
13:52:52 <waern> for packaging systems
13:53:02 <ndm> just with derive, or will cabal in general?
13:53:13 <waern> it's a problem with cabal
13:53:45 <waern> it's the ' in O'Rear that breaks the quotation used in the shell scripts that get generated
13:54:12 <ndm> hehe!
13:54:19 <ndm> so all stefan's fault
13:54:33 <ndm> so do i need to strip Stefan of his authorship before releasing derive?
13:54:34 <waern> yep. let's assign it to him :)
13:55:07 <waern> yes, might be a good idea for people doing the packaging for external systems
13:55:07 <Igloo> I fixed that the other day
13:55:11 <sorear> ndm: i ran the hackage test on the darcs dist
13:55:12 <sorear>    However the package generated the following warnings:
13:55:16 <sorear>                                                                                                                                                                                                                     
13:55:20 <ndm> no maintainer?
13:55:20 <sorear>      * No license-file field.
13:55:25 <sorear>      * No description field.
13:55:26 <waern> Igloo, ah, nice
13:55:29 <sorear>      * No maintainer field.
13:55:29 <ndm> hmm, did you do a fresh pull first?
13:55:32 <sorear> worth fixing?
13:55:35 <ndm> i fixed those and pushed just before
13:55:49 <ndm> apart from no maintainer
13:56:08 <sorear> I pull every day. Nobody ever updates code more often then that :)
13:56:14 <ndm> given i'm in the copyright and author fields, if they haven't figured out who the maintainer is i'm not sure i really want their bug report...
13:57:08 <sorear> exactly.  derive is unmaintained, no point submitting bugs
13:57:32 <ndm> fair enough, what should do in maintainer
13:57:35 <ndm> names? emails?
13:57:39 <Igloo> ndm: If it's maintained then it should be filled in, (a) so people know and (b) so that tools can display the info
13:57:43 <sorear> so what's this deal with O'Rear ?
13:58:17 <sorear> i'm using darcs dist since approximately -1% of cabal users fill in the fields required for sdist to work
13:58:34 <sorear> cabal really ought to give a fatal error when other-source-files is missing
13:58:56 <ndm> i checked, derive has enough stuff in it, i think?
13:59:14 <ndm> is there a webpage and darcs field in cabal?
13:59:56 <Heffalump> it seems a little insular to add something darcs-specific
14:00:16 <sorear> ndm: there is a webpage field, it's even in the cabal manual
14:00:30 <ndm> its called Homepage, apparently
14:00:48 <sorear>    maintainer: address
14:00:52 <sorear>                                                                                                                                                                                                                     
14:00:56 <sorear>            The current maintainer or maintainers of the package. This is an e-mail address to which users should send bug reports, feature requests and patches.
14:01:00 <sorear> you were asking earlier
14:01:27 <dylan> hmm, how do I get ghc 6.6 on gentoo?
14:01:47 <Igloo> You need to un-hard-mask it or something, last I heard
14:02:05 <dylan> fun.
14:02:22 <Heffalump> emerge debian ;-)
14:02:28 <sorear> ndm: Ouch, why is the documentation listed as a required data file?
14:03:04 <ndm> sorear, what else should it be under?  it has to be somewhere so it gets into the sdist
14:03:35 <ndm> i could only see Data-Files, and Extra-Source-Files
14:03:37 <sorear> ndm: other-source-files
14:03:39 <ndm> its definately not source
14:03:48 <sorear> extra rather
14:04:05 <Igloo> If it's in the source tarball then it's source
14:04:14 <ndm> oh, extra source files means extra files to go into sdist, not actual source files
14:05:37 <dylan> Heffalump: I use debian on most of my machine, gentoo is a real benefit on this one, though
14:05:44 <dylan> *machines.
14:06:01 <ndm> sorear, all updated as required - sdist should work fine, i did a test install from an sdist and it was fine
14:06:47 <Heffalump> I was just trolling. I'm sure gentoo has plenty of advantages of its own.
14:07:54 <dylan> what's bad is neither debian nor gentoo are very good on my nvidia-using ppc laptop
14:09:13 <jfredett> I use gentoo on my desktop, ubuntu on my laptop, because I tend to break things on my laptop on a regular basis, and ubuntu installs in about ~1.5 hrs
14:18:18 <sorear> ndm: Is derive ready to upload?
14:19:14 <Lemmih> Igloo: What are the differences between the two Foo modules in bug #1385?
14:20:01 <Igloo> Lemmih: Thanks, fixed
14:21:02 * Igloo is somewhat impressed at having 2 people spot a bug in my bug report within 6 minutes of opening it
14:21:49 <DarkRaider> i have a little problem with ghc6.6.1 and debian. i installed ghc, but while compiling a project it cant find the module Language. dose anybody know what i could do to fix it?
14:22:09 <sorear> DarkRaider: write a module called Language
14:22:18 <sorear> DarkRaider: there is no standard module by that name
14:23:36 <sorear> ndm: Do you mean to not include yds2007/*, push.bat, Example.hs, Language.Haskell.TH.Semtex, or Data.DeriveSYB in the tarball ?
14:23:51 <DarkRaider> the haskell program need Language.Haskell.Parser
14:24:25 <sorear> DarkRaider: that's the name of the module - haskell doesn't have submodules
14:24:26 <Lemmih> DarkRaider: Install libghc6-hsakell-src-dev
14:24:38 <sorear> DarkRaider: anyway, (what Lemmih just said)
14:25:08 <sorear> you should be able to fix the typo :)
14:25:48 <DarkRaider> yeah... i allready tried that... but the debian packages are just vor ghc6.6 ...
14:26:53 <sorear> DarkRaider: update
14:26:58 <Lemmih> DarkRaider: Find a proper debian package or install from source.
14:27:10 <sorear> DarkRaider: they were delayed a week or so, but they showed up yesterday
14:27:21 <sorear> (the packages for 6.6.1)
14:27:52 <DarkRaider> ok
14:30:45 <hpaste>  LoganCapaldo annotated "Interaction" with "Suggestions for how to build this graph w/o mutation?" at http://hpaste.org/76#a2
14:31:25 <LoganCapaldo> I was wondering if anyone could take a look at that and tell me the appropiate idiom to get it going?
14:32:35 <sorear> use recursive let
14:33:08 <LoganCapaldo> sorear: I did.
14:33:20 <LoganCapaldo> at least in the definition of connect
14:33:37 <Igloo> DarkRaider: I think the haskell-src package is still not updated
14:33:37 <sorear> room1 = Room "bedroom" (M.fromList [(North, room2)])
14:33:51 <sorear> room2 = Room "closet" (M.fromList [(South, room1)])
14:33:53 <sorear> ...
14:33:57 <LoganCapaldo> Yeah
14:34:23 <LoganCapaldo> But I was looking for something that I could load from a config file or similar eventually
14:34:24 <kpreid> that structure's not so good if you want a mutable contents list etc. eventually.
14:34:45 <sorear> @goo tying the knot generically
14:34:47 <lambdabot> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
14:34:47 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
14:34:52 <sorear> LoganCapaldo: ^^
14:35:29 <LoganCapaldo> sorear: thanks
14:35:31 * LoganCapaldo reads
14:35:32 <ndm> sorear, yes - those were all deliberately excluded
14:35:54 <ndm> perhaps Example wants including, but the others are all either broken or an inprogress paper
14:36:44 <fasta> How is it possible that I create a type of the form STRef s (Stack s1 a)?
14:38:09 <sorear> fasta: Use runST in too many places
14:38:15 <DarkRaider> Igloo: that bad... but im just compiling ghc6.6.1 + extralibs right now for myself
14:38:16 <sorear> I suspect $ could also do it
14:38:55 <sorear> DarkRaider: get 6.6 from the oldstable repo if you need it for bootstrapping
14:39:09 <fasta> sorear: runST isn't used.
14:39:35 <sorear> fasta: ... then what is the use of STRef ?
14:39:53 <fasta> sorear: It isn't used _yet_.
14:40:31 <fasta> sorear: are you suggesting this is yet another GHC bug?
14:41:29 * allbery_b thinks he got that list comprehension wrong...
14:41:35 <allbery_b> I never use list comprehensions per se
14:41:54 <DarkRaider> sorear: thx, but maybe it works with th installed 6.6.1 too
14:42:58 <sorear> fasta: No, it's an ancient design bug in haskell.  Adding rank-2 to an implicit polymorphism system was a mistake
14:43:39 <fasta> sorear: but is the type correct? I thought it should be STRef s (Stack s a)
14:43:51 <Eelis> yay, my bug report asking for a switch to disable ghci's startup ascii art banner is being received well!
14:43:59 <sorear> fasta: It's a legal (well kinded) type
14:44:20 <sorear> fasta: I can't say if it's the right one without also seeing the term
14:44:38 <LoganCapaldo> This makes me realize my connect function is totally useless.
14:44:55 <sorear> ndm: Done.
14:45:38 <ndm> sorear, thanks, i'll put out a release announcement
14:46:28 <sorear> anyone know whan the HC&A report is due?
14:46:45 <ndm> a while ago :)
14:53:10 <ari> You know, I consider doing a bit of C to break successive nights Haskell to be rather refreshing... but I always forget that it's refreshing the same way jumping off a cliff is
14:57:46 * allbery_b uses ruby for that these days
15:00:53 <LoganCapaldo> I wonder if I should just do something like Data.Map Direction RoomId. Even if I do "tie the knot", that leaves me in the unhappy position of being unable to remove rooms easily
15:01:38 * LoganCapaldo thinks out loud
15:08:56 <Igloo> dcoutts: Are you around?
15:09:02 <dcoutts> Igloo: yep
15:09:18 <Igloo> How come bugs like http://hackage.haskell.org/trac/hackage/ticket/117 aren't closed in the Cabal trac?
15:09:20 <lambdabot> Title: #117 (Cabal is not line-ending agnostic) - Hackage - Trac
15:15:50 <sorear> huh.  i've been @localtime'd twice today
15:16:10 <Baughn> @hoogle IO (IO a) -> IO a
15:16:14 <lambdabot> No matches, try a more general search
15:16:18 <sorear> Baughn: join
15:16:40 <Baughn> Thanks. I'm lost in a maze of monads, all alike..
15:17:22 <mauke> @pl f x = x >>= id
15:17:22 <lambdabot> f = join
15:18:03 <SamB> @src join
15:18:03 <lambdabot> join x =  x >>= id
15:18:14 <mauke> haha
15:18:31 <Baughn> Oh, and if I say something like "do foo <- cFunction; let bar = unmarshal foo; cfree; return bar"... will laziness cause trouble, possibly making the unmarshal run /after/ foo has been freed?
15:18:35 <SamB> @. pl src join
15:18:35 <lambdabot> (line 1, column 1):
15:18:35 <lambdabot> unexpected end of input
15:18:35 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
15:18:50 <Baughn> s/cfree/cfree foo/
15:19:08 <SamB> @. id src join
15:19:22 <mauke> that depends on unmarshal, I think
15:19:24 <sorear> Baughn: it will run after, but not due to anything lazyness-related
15:19:42 <mauke> oh wait
15:19:51 <sorear> you want do foo <- cFunction ; bar <- unmarshal foo ; cfree ; return bar
15:20:36 <Baughn> Okay. Why?
15:22:11 <roconnor> > 0x25d
15:22:13 <lambdabot>  605
15:22:15 <roconnor> > 0x225d
15:22:17 <lambdabot>  8797
15:25:25 <roconnor> > 0x223c
15:25:27 <lambdabot>  8764
15:26:17 <hpaste>  Baughn pasted "Am I doing this right?" at http://hpaste.org/77
15:27:55 <Baughn> I'm worried about lines 34-36, in particular
15:28:03 <roconnor> > 0x22a6
15:28:05 <lambdabot>  8870
15:31:28 <sorear> Baughn: lines 1-2 are wrong
15:31:42 <sorear> Baughn: OPTIONS_GHC must be the very first thing in the file
15:31:54 <sorear> Baughn: and the option is capitalized -fvia-C
15:32:18 <Baughn> Odd that it didn't complain. Fixed now.
15:33:52 <sorear> but the actual code looks fine
15:34:22 <Baughn> So there's no chance the pointers will be used after being freed?
15:34:41 <sorear> no chance
15:35:01 <sorear> assuming readBlob returns freshly malloced pointers and doesn't free its argument
15:35:12 <nburlett> hey all
15:35:20 <nburlett> quick question... a friend asked about doing this:
15:35:24 <nburlett> data BoundedInt = BoundedInt Int Int Int
15:35:27 <nburlett> newtype Percent = BoundedInt 0 100
15:35:42 <mauke> that looks invalid
15:35:44 <nburlett> that won't work, I believe because newtype doesn't do currying on types
15:35:46 <Baughn> It does and doesn't. I'm worried about out of order execution, not multiple freeing. ;)
15:35:59 <mauke> nburlett: that's a redefinition of BoundedInt
15:36:19 <mauke> nburlett: and you can't put ints in types
15:36:20 <sorear> my only complaint is that going via [Word8] is likely to be very inefficient.  if it turns out to be a bottleneck, do it by hand with Ptrs
15:36:26 <sorear> Baughn: ^^
15:36:52 <Baughn> sorear: I'd like to. How can I fill a DiffUArray without using listArray, though?
15:36:52 <LoganCapaldo> type Percent = BoundedInt 0 100 works though don't it?
15:37:03 <sjanssen> LoganCapaldo: no
15:37:06 <Baughn> My original code was a horrendous list comprehension using plain array
15:37:10 <sorear> Baughn: IO always executes stuff in order.  But, IO uses call-by-name like old Algol, and that must be remembered
15:37:15 <LoganCapaldo> fooey
15:37:31 <mauke> mkPercent = BoundedInt 0 100
15:37:33 <sorear> Baughn: Anything else *will* be more horrendous
15:37:49 <LoganCapaldo> Oh wait
15:37:52 <LoganCapaldo> Of course it doens't
15:38:03 <LoganCapaldo> theres no type var
15:38:11 * LoganCapaldo feels dumb
15:38:44 <Baughn> sorear: Using listArray at least generates less garbage than using array. But you mentioned setting the array directly/by hand?
15:38:58 <nburlett> so, this might be okay:
15:38:59 <nburlett> data BoundedInt = BoundInt Integer Integer Integer
15:38:59 <nburlett> mkpercent = BoundInt 0 100
15:39:15 <sjanssen> nburlett: yeah, that's fine
15:39:27 <nburlett> I don't think that quite does what my friend was asking for
15:39:34 <nburlett> I think he wanted to use Percent as a type
15:39:44 <mauke> @where oleg
15:39:44 <lambdabot> http://okmij.org/ftp/
15:40:18 <nburlett> not sure though, because he asked over  AIM , and now he's gone
15:40:20 <sjanssen> nburlett: it seems like your friend wanted the typesystem to guarantee the first two values in a bounded int meet certain constraints
15:40:24 <ndm> anyone want to beta-test Catch?
15:40:29 <mauke> nburlett: http://okmij.org/ftp/Haskell/number-parameterized-types.html
15:40:30 <lambdabot> Title: Haskell Programming: Types that depend on numbers
15:40:32 <LoganCapaldo> data Percent = P0 | P1 | P2 | ... | P100 deriving (Eq, Ord, Enum)
15:40:34 <nburlett> sjanssen: I htink yopu're right
15:40:43 <sjanssen> nburlett: this essentially means dependent types -- Haskell doesn't quite do this
15:40:47 * nburlett looks at sjanssen's link
15:41:44 <LoganCapaldo> if you write an integral instance for it (not hard with deriving enum) I think this will work: ( 37 :: Percent)
15:41:52 <sorear> Baughn: yes.  you should use unsafeFreeze :: IOUArray ... -> DiffUArray ... ; there is a O(1) RULE
15:42:00 <defcon8> how is "haskell, the craft of fp" compared o YAHT?
15:42:05 <defcon8> to*
15:42:10 <joelr1> evening
15:42:22 <defcon8> hello
15:42:28 <LoganCapaldo> > ( 80 :: PortNumber )
15:42:29 <lambdabot>   Not in scope: type constructor or class `PortNumber'
15:42:45 <LoganCapaldo> > ( 0 :: Bool )
15:42:46 <lambdabot>   add an instance declaration for (Num Bool)
15:42:46 <Baughn> sorear: I'll do that, thanks
15:42:46 <lambdabot>     In the expression: 0
15:42:46 <lambdabot>     In ...
15:43:01 <LoganCapaldo> Oh maybe it was an instance for Num
15:43:05 <LoganCapaldo> I dunno
15:44:47 <defcon8> anyone?
15:45:23 <nburlett> defcon8: sorry, don't know
15:45:32 <nominolo> :t 0
15:45:34 <lambdabot> forall t. (Num t) => t
15:45:35 <defcon8> ok
15:45:45 <nominolo> :t 1
15:45:47 <lambdabot> forall t. (Num t) => t
15:46:44 <nburlett> defcon8: read them both :->
15:46:52 <Mitar> i have a dual core processor (core duo) ... and i do not understand why running with parmap instead of map is 4 times slower (it is two times slower if i exchange map with parmap and do not compile with -threaded, if i compiles with threaded it is four times slower)
15:47:17 <nominolo> Mitar: is that from DPH?
15:47:27 <sjanssen> Mitar: there is some overhead with sparking parallel evaluations
15:47:56 <Mitar> from DPH?
15:48:00 <sjanssen> Mitar: in general, you want to find coarse grained parallelism rather than fine grained
15:48:02 <nominolo> data parallel haskell
15:48:04 <Mitar> yes ... but four times slower?
15:48:11 <Mitar> no, ghc
15:48:17 <nominolo> Mitar: how do you measure
15:48:25 <Mitar> cputime
15:48:26 <sjanssen> Mitar: you might be doing something wrong -- the combinators are notoriously hard to use
15:48:30 <sjanssen> Mitar: can you paste?
15:48:34 <nominolo> Mitar: DPH is only implemented in ghc, AFAIK
15:48:35 <Mitar> of course
15:48:50 <sjanssen> nominolo: Mitar is referring to Control.Parallel.Strategies (not DPH)
15:48:51 <sorear> nominolo: parMap has absolutely nothing to do with DPH
15:49:03 <nominolo> oh, ok
15:49:10 <Mitar> yes, .. parMap
15:49:12 * nominolo fades into background
15:50:12 <emu> Mitar: are you supplying the +RTS options
15:50:14 <Mitar> http://www.druga.org/~mitar/Temp/Main.hs
15:50:32 <Mitar> i tried with ghc --make -O2 Main.hs << 2x slower
15:50:43 <emu> Program +RTS -N 2
15:50:49 <Mitar> ghc --make -threaded -O2 Main.hs << 4x times slower
15:50:50 <emu> don't forget to do that
15:50:57 <emu> ...
15:51:20 <Mitar> and there is no difference if i (with -threaded) add -N2 or not
15:51:37 <emu> maybe your program doesn't admit parallelization?
15:51:48 <Mitar> if there is only map, it is 1x speed (around 60 s it takes)
15:51:51 <emu> defined the instances correctly?
15:51:57 <emu> NFData
15:52:09 <Mitar> nooo
15:52:13 <Mitar> i use normal haskkel
15:52:23 <Mitar> no parallel structures ...
15:52:32 <Mitar> i just use Control.Parallel.Strategies
15:52:38 <Mitar> so i change map with parmap
15:52:42 <wolverian> This isn’t a very successful way to colonize. In our all-too-short ramp-up period, both Jane and I read enough reports on the demise of wildcat colonies that were designed in just this fashion to be convinced of this salient fact.
15:52:46 <wolverian> This isn’t a very successful way to colonize. In our all-too-short ramp-up period, both Jane and I read enough reports on the demise of wildcat colonies that were designed in just this fashion to be convinced of this salient fact.
15:52:50 <wolverian> This isn’t a very successful way to colonize. In our all-too-short ramp-up period, both Jane and I read enough reports on the demise of wildcat colonies that were designed in just this fashion to be convinced of this salient fact.
15:52:54 <wolverian> er
15:52:55 <wolverian> holy crap mouse freakout
15:53:02 <wolverian> very sorry
15:53:14 <Mitar> can you check my program?
15:53:15 <emu> Mitar: well you have to be sure it's completing the computation in the thread, and not after
15:53:20 <emu> ?paste
15:53:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:53:30 <Mitar> http://www.druga.org/~mitar/Temp/Main.hs
15:53:58 <Mitar> emu: does not haskell and its strategies do this by itself?
15:54:12 <Saizan> why don't you use rnf?
15:54:49 <Mitar> rnf?
15:55:10 <Mitar> let check what is this :-)
15:55:18 <emu> @type rnf
15:55:18 <Saizan> a "strategy"
15:55:26 <lambdabot> forall a. (NFData a) => a -> Done
15:55:28 <emu> @hoogle parMap
15:55:29 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
15:55:39 <emu> @type rwhnf
15:55:41 <lambdabot> forall a. a -> Done
15:55:47 <Saizan> rnf= reduce to normal form, rwhnf = reduce to weak head normal form
15:56:05 <shapr> How is hal related to udev?
15:56:17 <Saizan> so rwhnf doesn't ensure that the value is fully evaluated
15:56:17 <emu> yes use rnf and define an instance of NFData for Ray
15:56:32 <emu> NFData should be straightforward. it's basically just forcing evaluation.
15:56:34 <Mitar> ok, this is too much for me ... i am not so far in parallel yet ... any good reading on the subject?
15:56:41 <emu> the tutorial
15:56:55 <shapr> Sounds like you're doing well so far.
15:58:01 <Mitar> ok, but this does answer my question ... why it is slower with parmap?
15:58:12 <Mitar> i thought it should be at least the same ...
15:58:17 <emu> because it's not doing the work in the thread
15:58:22 <emu> and there's overhead
15:58:30 <Mitar> four times the overhead?
15:58:33 <Saizan> Mitar: because it's sparking threads that doesn't quite do anything
15:58:35 <ndm> sjanssen: i've just emailed you a beta of catch, with StackSet from darcs it has 15 incomplete patterns and proves them all safe :)
15:58:56 <emu> http://www.macs.hw.ac.uk/~dsg/gph/papers/
15:58:58 <lambdabot> Title: Glasgow Parallel Haskell Papers
15:59:03 <emu> ^ tutorial and other things
16:00:03 <Mitar> thanks ...
16:00:46 <emu> NFData instances aren't hard, they're actually derivable if you use things like Drift.
16:01:10 <ndm> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm - that does them automatically
16:01:10 <lambdabot> Title: Data.Derive: A User Manual
16:01:14 <emu> they all look like this: instance NFData ... where rnf (... a b c) = rnf a `seq` rnf b `seq` rnf c `seq` ()
16:01:22 <Mitar> so than i have some questions: i would like to render and image - this can be easily parallelised as every pixel is independed from others
16:01:25 <emu> pretty much
16:01:39 <sjanssen> ndm: cool, I'll check it out
16:01:41 <Mitar> but which datastructure would be good for platform independed drawing then?
16:01:51 <sjanssen> ndm: by the way, your tarball will make unix users angry
16:01:59 <Mitar> so that it would be easy to swap it to the screen
16:02:18 <sjanssen> ndm: we call tarballs that don't create their own top level directory 'tarbombs' ;)
16:02:28 <emu> hmm, data-parallel haskell array? =)
16:02:32 <Mitar> because i think that list which i am using now is not really good as I draw pixel by pixel now ..
16:02:38 * emu gets angry at ndm!
16:03:06 <ndm> sjanssen - is there a flag to stop it donig that?
16:03:06 <cdsmith53> sjanssen: I learned the hard way to always do a tar t before a tar x, many years ago. :)
16:03:26 * ndm points out that winzip can handle this fine
16:03:30 <sjanssen> ndm: not that I'm aware of
16:03:35 <emu> i just make my tar from the dir above
16:03:46 <emu> darcs dist handles it too
16:03:57 <ndm> i don't want either of those things :(
16:04:02 <sjanssen> ndm: so can tar.  But you never expect it, all software releases do it this way
16:04:13 <ndm> sjanssen, give me 10 mins and i'll have a new one up
16:04:25 <emu> tar -C target sure
16:05:28 <Mitar> so is there some gui module which would be fast for drawing pixel by pixel?
16:05:48 <ndm> Mitar, traditionallly, drawing pixel by pixel is never fast
16:06:54 <nburlett> Mitar: you're usually better off drawing pixel-by-pixel to a buffer and then dumping the buffer all at once
16:07:15 <Mitar> it would be if i would store the values directly in the memory segment which will be canvas for the window ..
16:07:38 <emu> i'd suggest data-parallel haskell except i never used it.  dons makes it seem really cool though.
16:07:40 <Mitar> and not first into the list and there call function to draw it pixel by pixel ...
16:07:49 <Mitar> dons?
16:08:30 <nburlett> sjanssen: "tarbombs" :->
16:08:41 <sorear> sjanssen: I redid the tarring myself with reasonable tools :P
16:09:17 <ndm> sorear, which tarring?
16:09:28 <sorear> ndm: for hackage
16:09:37 <sjanssen> ndm: the windows line endings confuse Cabal
16:09:48 <sjanssen> ndm: the generated executable is catch^M :(
16:10:13 <Saizan> can you have
16:10:15 <sorear> sjanssen: the hackage tarball is bad?  I didn't test it *gulp*
16:10:19 <Saizan> ^M in filenames?
16:10:26 <SamB> cdsmith53: I also "learned" the hard way
16:10:32 <ndm> sjanssen, grr, all my code uses UNIX line endings then Haskell goes and opens the generated file in text mode...
16:10:33 <SamB> but for some reason I never actually *learn*
16:10:34 <sorear> Saizan: Absolutely!
16:10:39 <ndm> sjanssen, fixing it now
16:11:22 <sorear> Saizan: ext2 uses pascal-style strings.  absolutely anything is legal as long as it is less than 256 bytes
16:11:41 <sorear> Saizan: the linux abi makes it impossible to use '/' and '\0'
16:12:14 <SamB> sorear: is '\0' and '/' actually *legal* ext2?
16:12:23 <SamB> there is a spec that allows it?
16:12:41 <ndm> sorear, this is Catch, not derive - my fault not yours :)
16:12:44 <sorear> SamB: Legal insofar as fsck can parse it.  it will however be "helpfully" renamed
16:12:45 <Excedrin> is there an ext2 spec?
16:12:58 <SamB> Excedrin: good question
16:13:05 <Saizan> sorear: wow, one never cease to learn something about unix (myself, at least)
16:13:08 <SamB> can Windows use such filenames?
16:13:15 <sorear> SamB: you can use those characters with debuge2fs, just not ext2.ko
16:13:36 <sorear> Excedrin: yes there is
16:13:39 <SamB> sorear: maybe you are thinking of rebuge2fs
16:14:05 * sorear dabbled in osdev long ago, and read the ext2 spec. (and forgot almost all)
16:14:36 <sorear> SamB: No, debugfs.  it seems they broke the naming convention :/
16:15:25 <sjanssen> ndm: 'yhc: Yhc.Core.coreFuncMap, function not found, StackSet.main'?
16:15:42 <ndm> sjanssen, you'll need a bang up to date Yhc
16:15:43 <Excedrin> I have a svg that's a single color (it's just a path really), is there a way to render it as a different color (or SVG -> mask so I can fill or something)?
16:15:48 <sjanssen> ndm: okay
16:16:13 <sorear> Excedrin: sed :)
16:16:57 <Excedrin> hmm, I'd like to render the same path in multiple different colors... forking sed seems inelegant
16:17:26 <sorear> HaXml comes to mind.  How are you rendering the image?
16:17:41 <dmwit> How is the SVG created?
16:17:46 <Excedrin> renderWithDrawable / svgRender
16:17:54 <Excedrin> created in inkscape
16:17:57 <dmwit> If it's a single path, you can probably recreate that path in Cairo.
16:18:00 <sorear> Excedrin: package?
16:18:20 <ndm> grr, now tar is creating DOS files
16:18:20 <sorear> (hoogle deliberately doesn't do gui libs)
16:18:26 <Excedrin> I'm using gtk2hs...
16:18:33 <ndm> even when i give it UNIX files
16:18:44 <ndm> sorear, there is Hoogle Gtk2Hs edition
16:18:47 <Excedrin> http://haskell.org/hoogle/?package=gtk&q= <- searches gtk2hs stuff
16:18:48 <lambdabot> Title: Hoogle
16:19:03 <sorear> Nice!!
16:19:27 * shapr finally upgrades to 6.6.1
16:19:32 <sorear> ndm++ I never noticed the hoogle 4 release anounce (or was multipackage bumped up?)
16:19:54 <ndm> sorear, there is gtk only, its a light hack over hoogle 3 - not proper multipackage
16:20:30 <dcoutts> Excedrin: btw, re your earlier question, you probably want to cache cairo image surfaces, see the gtk2hs/demo/cairo/Clock.hs demo for an example
16:20:54 <ndm> any flag to tar --dont-screw-with-my-files to stop it changing the line ending?
16:21:06 <Excedrin> dcoutts: thanks
16:22:04 <sorear> ndm: this gnutar?
16:22:12 <Excedrin> dcoutts: is the clock example scalable?
16:22:18 <sorear> stefan@stefans:/tmp$ tar --help | wc -l
16:22:18 <sorear> 248
16:22:38 * sorear stares
16:22:48 <dcoutts> Excedrin: scalable in what sense? scalable as in zooming or as in building bigger programs ?
16:22:59 <ndm> sorear, seems that you can't, but it may be that Hugs has copyFile which is doing the conversion
16:23:08 <Excedrin> zooming.. the window doesn't have decorations
16:24:17 <sorear> fdclock is scalable
16:24:28 <Excedrin> ok, I changed it so it has decorations and I see that it's scalable/zoomable
16:24:58 <sorear> ndm: what tar program are you using?
16:25:35 <sjanssen> ndm: I know I've asked this before, but what does 'Answer: 0' mean after 'Checking whole program'?
16:25:46 <shapr> Yay, on my machine 6.6.1 compiles faster than 6.6.0!
16:25:58 <sorear> shapr: Not suprising at all.
16:26:09 <ndm> sorear, a port of GNU tar to windows
16:26:13 <ndm> i think i've got it sorted out now...
16:26:15 <sorear> shapr: ghc-stage-two compiles the standard libs with -O2
16:26:21 <ndm> was several layers of conversion
16:26:29 <sorear> shapr: 6.6.0 has -O2 implying -fvia-C, 6.6.1 doesn't
16:26:31 <ndm> sjanssen, 0 = False, precondition is "not good"
16:26:45 <sorear> shapr: -fvia-C is much slower than -fasm (but you knew that)
16:28:08 <ndm> sjanssen, i've uploaded a new version - \n's all round, and tarbomb defused
16:28:18 <shapr> I didn't know the default had changed with 6.6.1, but that is good to know.
16:29:34 <sjanssen> ndm++ much smoother installation.  Catch proves StackSet as safe (except for 'new', and the pattern guards)
16:30:08 <ndm> sjanssen, thanks thats what i was aiming for - is that result with the latest darcs version of xmonad?
16:30:23 <sjanssen> ndm: correct
16:31:05 <ndm> sjanssen, with the latest darcs pull i get complete success - no partern guards present
16:31:47 <sjanssen> ndm: you must have some extra patches?
16:32:07 <ndm> sjanssen, oh, yes, i have some local changes
16:34:25 <sjanssen> ndm: I'm willing to pay a small price for easier catch-ability
16:35:02 <sjanssen> ndm: so feel free to send pattern guard removal patches if they're not too painful
16:35:43 <ndm> sjanssen, cool :)
16:37:06 <ndm> sjanssen, of course, once GHC.Core is unbroken, you can even use associated rank-n GADT's
16:44:16 <Mitar> how can i force evaluation of the value?
16:46:03 <ndm> sjanssen, new is unsafe, is m >= n then you crash
16:47:03 <ndm> sjanssen, plus Catch can't specify that kind of condition anyway, so if you rely on that for safety you won't get a complete catch proof
16:49:23 <ndm> for Catch, data Int = Neg | Zero | One | Pos
16:49:41 <ndm> so if you can't prove safety given that interpretation, Catch can't
16:51:09 <SamB> what? no MinusOne?
16:51:19 <ndm> SamB, no
16:51:46 <ndm> SamB, think about it - how do you specify -1 in Haskell? its really hard, because - is so horrible, and it turns out to rarely be useful
16:51:58 <SamB> > (-1)
16:51:59 <lambdabot>  -1
16:52:04 <SamB> it doesn't seem so hard to me
16:52:09 <ndm> yes, but where would people use it?
16:52:19 <ndm> n-1 ? thats One, not MinusOne
16:52:20 <SamB> ... point
16:52:36 <ndm> it would be easy to add, but pragmatically, its never useful
16:52:54 <SamB> pragmatically I must say "wait and see!"
16:53:42 <ndm> not long to wait, release in a few weeks :)
16:53:47 <ndm> unless you want to beta test sooner
16:54:54 <SamB> no.
16:55:03 <SamB> for to do that I'd have to remember to actually write some Haskell code.
16:56:36 <dibblego> has anyone written QuickCheck in other languages?
16:56:47 <ndm> John Hughes has an Erlang product
16:56:54 <ndm> and yes, loads of ports have been done
16:57:01 <sorear> SamB: You could always test someone else's.  Just today I found (the hard way) an incomplete case in GHC
16:57:03 <ndm> QuivCheck
16:57:14 <dibblego> ndm, got any references? I'm having trouble googling them up
16:57:24 <ari> dibblego: http://www.cs.chalmers.se/~rjmh/QuickCheck/
16:57:26 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
16:57:35 <ari> dibblego: See "Other languages"
16:57:39 <dibblego> oh yes, thanks
16:58:44 <ndm> http://www.quviq.com/
16:58:45 <lambdabot> Title: QuviQ homepage
16:58:47 <ndm> thats the erlang one
17:00:08 <dibblego> thanks
17:36:39 <edwardk> @where frisby
17:36:39 <lambdabot> I know nothing about frisby.
17:37:22 <edwardk> hrmm. is the code for Text.Parsers.Frisby out there somewhere? I can only find the page on Meacham's site describing the interface http://repetae.net/computer/frisby/
17:38:03 * edwardk just realized that his grammar makes a simple PEG
17:39:46 <olsner> "frisby is a work in progress, it has a darcs repo at http://repetae.net/repos/frisby which may be browsed at http://repetae.net/dw/darcsweb.cgi?r=frisby;a=summary"
17:39:48 <lambdabot> Title: Index of /repos/frisby
17:40:03 <olsner> (quote from that page ;-)
17:40:03 <edwardk> @where+ frisby http://repetae.net/repos/frisby/
17:40:04 <lambdabot> Done.
17:40:06 <edwardk> found it =)
17:40:19 * edwardk is a little slow some times ;)
17:42:08 <LoganCapaldo> I'm having a bizzaro moment
17:42:22 <LoganCapaldo> is there a reason for _ -> return c not to work?
17:42:23 <olsner> PEG seems nice, yeah, but I wonder how much work it'll be to transform grammars into a PEG-friendly format
17:42:29 <LoganCapaldo> and be a parse error?
17:43:18 <olsner> was that supposed to be a lambda expression? isn't it lacking a backslash then?
17:43:33 <LoganCapaldo> olsner: sorry i mean in a case
17:43:41 <edwardk> olsner: well, i wrote this grammar, and it turned out to be peg friendly, so all good ;)
17:43:50 <sorear> LoganCapaldo: check your indendation
17:44:04 <hpaste>  LoganCapaldo pasted "Wild card pattern not parseing" at http://hpaste.org/78
17:44:42 <LoganCapaldo> I have no tabs in the file at all
17:44:53 <LoganCapaldo> and it looks lined up
17:44:56 <edwardk> remove one space before the _
17:45:02 <sorear> LoganCapaldo: I didn't say anything about tabs
17:45:19 <edwardk> its aligned with the c in 'c' not the '
17:45:38 <LoganCapaldo> :(
17:45:41 <olsner> ah, does that parse as "... return '\v' _ -> return c" then?
17:45:48 <sorear> LoganCapaldo: tabs are perfectly safe (using an editor with an atypical interpretation of ascii isn't)
17:46:05 <edwardk> it doesn't parse as a new case because it isn't outdented far enough so no ; is inserted
17:46:31 <edwardk> olsner: so yeah
17:46:44 <MyCatVerbs> sorear: atypical interpretation of ascii?
17:47:12 <LoganCapaldo> what would return '\v' _ -> return c even mean?
17:47:13 <edwardk> ugh, nevermind, have do-sugar, that won't peg
17:47:20 <edwardk> logan: exactly =)
17:47:26 <edwardk> thats what the compiler is telling you ;)
17:47:31 <MyCatVerbs> sorear: what, like setting your editor to have non-eight-space tabs and then trying to match columns exactly using mixtures of tabs and spaces?
17:47:42 <sorear> MyCatVerbs: 99% of the world interprets \011 as inserting just enough spaces to make the column number divisible by 8
17:48:07 <sorear> MyCatVerbs: invariably we see lusers who think it would be "fun" to mangle their editors
17:48:16 <LoganCapaldo> So what you are telling me is that _over_ indenting can mess it up just as much as not indenting enough?
17:48:19 <sorear> IOW, yes
17:48:21 <edwardk> i interpret it as inserting just anough characters to make the column number divisible by whatever the vim:ts setting in the modeline is ;)
17:48:37 <edwardk> logan: yup. unless you want to semi-colon terminate the previous line
17:48:53 <LoganCapaldo> I clearly don't understand this layout thing
17:48:58 <MyCatVerbs> sorear: oh. Ummm. I think I might be counted in that.
17:49:01 <olsner> hmm.. frisby isn't a monad? what's the difference between do and mdo?
17:49:12 <sorear> edwardk: Yes, I do have to class Joy and Moolenar in this :)
17:49:32 <MyCatVerbs> sorear: but I set my editor to pretend tabs are three spaces, then deliberately insert n-tabs for nth level indenting and to Hell with matching columns up.
17:49:47 <LoganCapaldo> Oh I indented so it considered it a continuation of the previous case
17:49:50 <MyCatVerbs> sorear: ghc doesn't seem to mind. ^^
17:50:07 <LoganCapaldo> gah
17:50:22 <edwardk> layout says that after an 'of' 'in' 'let' or 'where' if the next symbol isn't a "{", then everything indented the exact same distance as the start of the next word will get a semi-colon inserted before it, and if you indent less you will get a } inserted before it and layout will turn off.
17:50:52 <edwardk> unless i missed something
17:51:05 <sorear> MyCatVerbs: You're playing with fire.  (OTOH If people always listened to that we would never have had an industrial revolution)
17:51:16 <LoganCapaldo> edwardk: this does not operate as I imagined
17:51:26 <sorear> edwardk: Almost.  there
17:51:33 <edwardk> there?
17:51:33 <Philippa_> edwardk: the offside rule, or the normal kludges to emulate it
17:52:02 <edwardk> offside rule?
17:52:18 <sorear> 's a rule that layout can't decrease, and another thing called "the dread parse-error rule"
17:52:18 <MyCatVerbs> sorear: well, it seems to work perfectly, and I'm pretty anal about keeping strictly to it.
17:52:33 * LoganCapaldo imagined everything idented to the right of a magic keyword would be surrounded by { } and ; would replace _every_ newline
17:52:46 <MyCatVerbs> sorear: besides, the compiler messages (should I mess it up) are sufficiently ill-tempered and easy to track down that it's not really an issue. ^^
17:52:48 <edwardk> ah, so if i nest a scope inside another layout scope
17:52:49 <edwardk> i get it
17:53:19 <edwardk> logan: that would play hell with if then else inside do-sugar
17:53:59 <MyCatVerbs> sorear: I just vaguely like to have the same indentation style *between* languages. As in, I use the same one in C, Java, Scheme, Haskell... I *think* the convention I use matches the whitespace sensitivity scheme that's in use in Python, though I've not tried it to be certain.
17:54:05 <edwardk> (technically layout can play hell with it anyways, because you have to remember to indent the 'then' and the 'else' slightly or rely on the compiler to break the standard a bit
17:54:26 <LoganCapaldo> edwardk: and this is why you must indent the else beyond
17:54:30 <LoganCapaldo> err nvm
17:54:33 <edwardk> yeah
17:54:38 <edwardk> its all tied together =)
17:54:40 <LoganCapaldo> the extra identation makes it not insert the ;
17:54:55 <sorear> MyCatVerbs: Python uses 8-space tabs too, and your approach just happens to work for exactly the same reason
17:55:12 <MyCatVerbs> sorear: see? =D
17:55:22 * edwardk sets his editor to 4 space tabs, then makes it expand them to spaces. no problem. ;)
17:55:31 <LoganCapaldo> this doesn't solve my desire to have my underscore aligned with the c instead of the ' though
17:55:37 <MyCatVerbs> sorear: besides, the alternative is that I'd start using shiftwidth=4 and tabstop=8, and nobody wants *that*.
17:55:43 <mauke> :set sw=4 ts=4 noet
17:55:48 <edwardk> you could throw a semicolon on the end of the previous line if you really want
17:56:02 <edwardk> but thats kinda ugly ;)
17:56:05 <LoganCapaldo> edwardk: I'd just be trading ugliness at that point :)
17:56:18 <edwardk> and easily broken by a well-intended person browsing the code
17:56:20 <MyCatVerbs> sorear: I would really, really rather not use expandtab. So... ick.
17:57:07 <LoganCapaldo> well at least its safe to align the ->
17:59:56 <LoganCapaldo> > (\(a, ___) -> a) (1,undefined)
17:59:58 <lambdabot>  1
18:00:03 <LoganCapaldo> weeeeell
18:00:46 <LoganCapaldo> and the winner is ___ -> c
18:01:27 <mauke> > (\(___, _) -> ___) (1, undefined)
18:01:28 <lambdabot>  1
18:01:46 <Philippa_> MyCatVerbs: really, just don't use tabs in haskell. It's a bad, bad idea, and it's also aesthetically limiting
18:01:59 <LoganCapaldo> mauke: yeah I know its not a magic wildcard anymore, but since I don't look at it it doesn't really matter
18:02:13 <mauke> LoganCapaldo: b-but the compiler warnings!
18:02:24 <LoganCapaldo> There are compiler wanrings?
18:02:40 <HairyDude> hmm, I seem to be misunderstanding fundeps.
18:03:04 <HairyDude> if you have "class C a b | a -> b" doesn't that mean that for any a, there is only ever going to be one b?
18:03:17 <sorear> Yes....
18:03:19 <MyCatVerbs> Philippa_: I *like* my tabstop setting. Go lick a tree. :(
18:03:30 <olsner> has someone made a haskell AST-editor, i.e. editing the parse tree rather than text, or something in that direction?
18:03:36 <Philippa_> MyCatVerbs: you're lucky the standard allows tabs at all
18:03:49 <MyCatVerbs> Philippa_: foo!
18:03:50 <HairyDude> so if you have "instance C Foo Bar" and something can only infer "C Foo a" it should be able to infer a = Bar, right?
18:03:57 <Philippa_> last time I implemented the layout rule for something, I just didn't allow tabs as valid whitespace
18:04:14 <mauke> Philippa_: you should disallow spaces instead
18:04:23 <mauke> it simplifies things a lot
18:05:28 <Philippa_> not if you use indentation as anything more than a simple ordering - which I do in my haskell code
18:06:05 <MyCatVerbs> Philippa_: look, this is obviously a religious issue.
18:06:43 <MyCatVerbs> Philippa_: and, frankly, I'm the one belonging to the cult. No worries, I'll drop out in a few years. Just lemme worship my daemonic squid gods in peace in the meantime, please?
18:07:49 <emu> calimari!
18:08:28 <olsner> (some languages work well with a simple hierarchical indentation scheme, and in that case tabs and editor settings do a good job in presenting the code in the way the coder wants it presented)
18:08:31 <MyCatVerbs> emu: yes, that too. My deity *is* more delicious than your deity.
18:08:45 <Philippa_> MyCatVerbs: don't worry, I left the pitchfork behind. Actually, I'm just waiting 'til your worship succeeds and I get to tape some live action tentacle porn...
18:09:26 <mauke> .oO( Rape Rape Revolution )
18:09:28 * emu gets the torches and pitchforks ... for the bbq
18:09:30 <MyCatVerbs> Philippa_: unfortunately for you, I know of only one other member of my own particular cult and, uh, frankly? You really, really don't wanna see either of us in tentacle porn.
18:09:46 <olsner> while talking about tentacular deities: FSM FTW
18:09:59 <mauke> ramen.
18:10:21 <MyCatVerbs> mauke: bleargh. Real spaghetti FTW! :/
18:10:23 <olsner> mauke: dattebayo!
18:10:46 <MyCatVerbs> mauke: that or real damn noodles. But I'm too lazy for actual noodles, spaghetti is easier.
18:16:01 <HairyDude> is there a good reason why the inference I'm describing can't be done?
18:17:58 <edwardk> has anyone here had experience with the haskellnet packrat parser and have any thoughts about its performance?
18:25:26 <olsner_> recursive monads seem interesting
18:27:14 <edwardk> recursive as in nested? or as in delegating pointedness to a monad?
18:27:44 <olsner_> as in the mdo thingy
18:38:02 <dons> haha, reddit can be fun, on explaining ocaml's bizarre syntax,
18:38:04 <dons>   "Haskell is a computer language in English by Englishmen. OCaml is a computer language in English by Frenchmen."
18:39:39 <olsner> what does deriving (Monad) actually produce? (or how can I find that out?)
18:40:41 <dons> for newtypes only, it generates the Monad instance of the underlying type, wrapped in the ewtype constructur
18:41:01 <dons> you can only derive Monad,Functor,MonadState et al for newtypes that wrap a type already in those classes
18:41:16 <dons> newtype T a = T (IO a) deriving Monad
18:41:16 <dibblego> "you can only" - or the compiler fails?
18:41:31 <dons> you can't just produce arbitrary monad implementations, for some type, no :-)
18:41:41 <dibblego> dang :)
18:41:54 <olsner> aah, okay.. in this case, it was a newtype of a type of State, so I guess it's the state monad in the bottom
18:42:11 <dons> yeah, if its something like newtype T a = T (State S a)
18:42:28 <petekaz> regarding reymont's ocaml post, is this language worth learning?  I'm still trying to learn haskell, I wonder if ocaml is easier.
18:42:37 <dons> you get a monad instance for State, (and you could derive MonadState S too, and get the 'gets' and 'puts' for free.
18:43:08 <dons> petekaz: its different. its older. it has no typeclasses, smp, type extensions, purity. so, you know ocaml if you know haskell, but not the other way around
18:43:12 <edwardk> petekaz: i find haskell to be a lot easier than ocaml, fewer arbitrary keywords, etc.
18:43:47 <dons> if you only knew ocaml, haskell would be pretty scary, but if you know haskell, ocaml seems like a easy version with bizarre syntax
18:44:05 <kpreid> I picked Haskell over OCaml because why should I learn a *more* mainstreamish language?
18:44:14 <edwardk> kpreid: =)
18:44:16 <petekaz> haha
18:44:33 <dons> of course, that doesn't address whether ocaml is easier.
18:44:41 <tautologico> well, I don't know if haskell is less mainstream than ocaml right now
18:44:48 <dons> it lets you confuse side effects and impure code, so that might be a simplification
18:44:57 <tautologico> especially with an o'reilly book about haskell :)
18:44:58 <petekaz> well, once you finish your book, I'll hopefully find the practical use of haskell much easire!
18:45:07 <dons> but haskell is taught to newbies, and i don't know anywhere , where ocaml is taught to beginners?
18:45:17 <edwardk> i learned haskell rather than ocaml because i wanted a language that extended what i knew about programming. there was nothing new in ocaml that i couldn't write in perl, javascript or C.
18:45:24 <tautologico> dons: france
18:45:27 <dylan> dons: france.
18:45:34 <dons> yes, i'd imagine it would have to be taught in French unis
18:45:35 <sjanssen> @quote stereo
18:45:35 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
18:45:37 <tautologico> edwardk: you sure?
18:45:47 <dons> but I don't know of particular examples.
18:45:50 <edwardk> tautologico: ok, well it has hindley-milner
18:46:03 <edwardk> tautologico: but the style of programming tends to still be imperative
18:46:06 <tautologico> edwardk: and lots more
18:46:10 <petekaz> I have also come to learn that joel r sometimes makes decisions a little prematurely.
18:46:18 <tautologico> edwardk: not at all... most ocaml programs are functional with some imperative bits
18:46:26 <dons> joel likes to try out the new and exciting bleeding edges of things
18:46:31 <dons> which can lead him down funny paths :-)
18:46:55 <edwardk> tautologico: sure, and since learning haskell i have learned ocaml, i just am always stuck watching my back in ocaml to make sure i don't go off and do something stupid like build an infinite data structure ;)
18:46:57 <petekaz> yes.
18:47:17 <olsner> what's wrong with infinite data structures?
18:47:25 <dons> he does try out things other people don't though, which is very useful.
18:47:38 <petekaz> thanks to him though, I would never have ventured into the functional world.  I learned Erlang first, very very easy language, then tried my hand at haskell.
18:47:40 <dons> we had no idea if you could run 10k threads on ghc 5 until he tried it. (and it worked)
18:48:04 <tautologico> well, you wouldn't try to use declensions when speaking english just because you know latin :)
18:48:20 <dylan> tautologico: I know people that try...
18:48:57 <tautologico> languages are different... I agree ocaml's syntax is uglier, but it's a good language anyway, infinitely better than java and most other mainstream languages
18:49:16 <edwardk> tautologico: sure, i just find i think better without the clutter.
18:49:22 <tautologico> ocaml's syntax is uglier than haskell, I meant
18:49:27 <dylan> tautologico: a duck is a better language than java.
18:49:44 <dons> haskell actively wanted to avoid looking like the ML family.
18:49:44 <tautologico> java is not really bad, is just incredibly boring
18:49:57 <edwardk> dons: and they succeeded marvelously.
18:50:17 * olsner is suddenly thinking about turing-complete flocks of ducks
18:50:21 <Thomas2> this is why . is fn composition?
18:50:24 <dons> btw everyone, xmonad supports pop up statusbars now
18:50:46 <Korollary> I imagine a reduction relation between ducks
18:50:50 <dons> also, half the original haskell designers are from math depts, not engineering
18:51:04 <tautologico> milner was from math
18:51:30 <dons> yep, my point is that the more math guys you have, the prettier your language
18:51:39 <Thomas2> but not necessarily the more practical
18:51:44 <Korollary> that's getting ad hominem
18:51:56 <dons> you need engineering guys to come in and kick code generators around and write libraries :-)
18:51:56 <Thomas2> it's ab?
18:52:20 <Korollary> engineering is not about code generation or libraries, tho.
18:52:31 <dons> (anyway, i'm just thinking particular of the oxford FP guys, with the functional pearls, and the bird syntax)
18:52:46 <Thomas2> Korollary: hmm, sorry, it's ad hominem. why did I think it was ab?
18:53:00 <edwardk> the main thing i like about haskell is that it occupies such a sweet spot in the design space. you try to shift one syntactic and type system decision another way and it ripples in so many ways that make the resulting language that much uglier or requires so many more annotations, etc. as much as they crack jokes about wadler's law, they managed to find a nice balance.
18:53:27 <Korollary> Thomas2: I'd love to help you, but I don't know.
18:54:03 <dons> Thomas2: btw, do you know if anyone over in ertos is using xmonad?
18:54:19 <Thomas2> dons: I don't even know what xmonad is :-)
18:54:21 * Thomas2 googles
18:54:26 <Korollary> sin
18:54:35 <dons> yes, hand back your membership card.
18:54:43 <Thomas2> oh, right, sjw was looking for something like that a while back
18:54:53 <dons> yeah, sjw is trying it out.
18:56:56 <Thomas2> I don't think anyone else will jump at it yet
18:57:09 <Thomas2> it's the sort of thing I'd consider trying myself given a bit of spare time, which atm i don't have
18:57:52 <dons> oh, they wouldn't jump at it yet? that's an interesting thing to say. why?
18:57:57 <dylan> trying to get xmonad to work on gentoo is a pain in the monkey. I use it at work now, however.
18:58:08 <dons> dylan: due to missing packages?
18:58:23 <Thomas2> oh, because we don't get a huge amount of haskell propaganda around here, and I don't think there are many zealots :-)
18:58:23 <dylan> dons: exac-a-tackly.
18:58:27 <dons> i'm going to try to push the maintainers to get X11 and X11-extras into the package systems with the 0.2 release in a few days
18:58:43 <dons> Thomas2: oh, i thought there were quite a few tiling wm users though?
18:58:48 <araujo> dylan, just unmask the needed packages :-P
18:58:53 <nburlett> dylan: what did you need to do to get xmonad going on gentoo? (I use gentoo, and have thought about trying it)
18:58:56 <dons> Thomas2: its a tiling wm. the language isn't the main thing.
18:58:58 <dylan> araujo: it fails to compile then
18:59:04 <Thomas2> dons: yeah, but do you realise how many tiling wms there are?
18:59:11 <dons> i do. and they suck :-)
18:59:20 <dons> you can't do xinerama :-)
18:59:27 <dons> or they have weird bugs. anyway..
18:59:35 <dylan> ion does xinerama, but ion has trademark insanity now
18:59:38 <nburlett> dons: is there a way to search for a window in xmonad?
18:59:38 <olsner> http://tools.wikimedia.de/sixdeg/index.jsp?from=Kevin+Bacon&to=Haskell&ign_dates=1
18:59:43 <dons> there's about 4 practical tiling wms.
18:59:45 <lambdabot> Title: Six degrees of Wikipedia, http://tinyurl.com/2hxrxk
18:59:52 <dons> nburlett: there is.
19:00:04 <nburlett> dons: like, press a key and get a search box?
19:00:05 <dons> nburlett: in StackSet
19:00:14 <dons> no, not currently. but that could be written.
19:00:31 <nburlett> dons: okay, cool (maybe I should write it an an exercise in haksell) :->
19:00:46 <dons> yes, i'd probably use dmenu to handle the popup query
19:00:52 <araujo> dylan, what's the problem?, i didn't have problems here
19:00:54 <dons> then take the result text as a window name
19:00:58 <nburlett> a friend of mine wrote a generic X11 program that did that
19:01:01 <dons> then search the window list for that name
19:01:05 <dons> when you find it, raise the window
19:01:23 <nburlett> well, I'd want something that resembles Quicksilver on the Mac
19:01:33 <nburlett> so that as I type it would find reasonable matches
19:01:51 * araujo is waiting for floating windows to use xmonad though
19:01:58 <dons> i'm not sure that makes much sense on a tiling wm though.
19:02:03 <dons> other than to find a window on a hidden workspace
19:02:10 <nburlett> I often have tons of windows open, as MULTI (embedded debugger) is window-happy
19:02:35 <nburlett> dons, oh, you can't selectively bring some windows forward and hide the othrs?
19:02:51 <dons> you can, yes.
19:03:01 <nburlett> ah, well, I'd need it for that ;->
19:03:02 <dons> but its a different ui paradigm, really.
19:03:13 <dylan> xmonad doesn't have floating windows?
19:03:27 <dons> nope. it tiles them in various ways.
19:03:38 <dons> floating is the 'i give up' option for tiling a plane
19:04:00 <dylan> it's a nice option for dialog boxes and stuff
19:04:13 <dylan> (transient windows, etc)
19:04:18 <dons> yep.
19:04:20 <tautologico> hmm, xmonad seems interesting
19:04:21 <nburlett> how does xmonad handle modal boxes?
19:04:26 <dons> transients are o, since delete . insert == id
19:04:27 <tautologico> I was looking for a tiling wm
19:04:27 <dibblego> I read 'tiling' as 'tilting'
19:04:31 <dons> s/ok/
19:04:38 <dibblego> I though you were referring to crash landing an aircraft
19:04:45 <dibblego> and 'floating' is the 'i give up' option
19:04:52 <dons> heh
19:05:16 <dons> tautologico: try it out. if you grab the darcs version, that'd be most useful, since its about to become the 0.2 release candidate.
19:05:26 <olsner> mm... tilting wm... could writing to the accelerometer device tilt the computer?
19:05:39 <dylan> dons: I'm not sure if I understand. Are you saying you can't allow floating windows because it breaks the theory of the wm?
19:05:42 <tautologico> dons: what do I need to compile it? I'd like to take a look at the code too
19:06:03 <dons> dylan: hehe. no. i was hinting at that ;) (we plane to add floating/i-give-up support for 0.3)
19:06:20 <dylan> "plane" to, eh? :-)
19:06:27 <dons> tautologico: you need ghc 6.6, and X11-1.2 package.
19:06:44 <dylan> araujo: btw, it's ghc 6.6 that is the problem.
19:06:44 <dons> dylan: tip of the slongue.
19:06:59 <dons> tautologico: and you need xmonad from darcs, and X11-extras from darcs
19:07:08 <dons> the darcs urls are on the webpage, the X11-1.2 package is on hackage
19:07:22 <dons> they're all just cabal libs, so they build identically.
19:07:36 <tautologico> cool, I'll try it out this week
19:07:51 <Saizan> mmmh, does xmonad support anti-aliased fonts? (not sure if this is really a wm thing..)
19:07:58 <dons> Saizan: not a wm thing.
19:08:17 <dons> a wm is a function :: Window a => [a] -> [(Rectangle a)]
19:08:18 <SamB> Saizan: some wms might
19:08:22 <tautologico> I see you're using zippers
19:08:27 <dons> that tiles a plane using a list of windows.
19:08:40 <SamB> but notably it only applies to things that have text
19:08:44 <dons> tautologico: quite so. natural structure to track focus.
19:09:01 <dons> (the only real world zipper use?)
19:09:21 <dylan> btw, is anyone maintaining vty now?
19:09:27 <dons> sorear should be.
19:09:34 <dylan> I thought he gave up or something.
19:09:44 <tautologico> I don't remember seeing real-world uses of zippers before... that's quite cool :)
19:09:58 <sorear> gave up /= spontaneously lost interest
19:10:10 <dons> sorear: after destorying the fine curses binding?
19:10:15 <dons> in yi :/
19:10:15 <sorear> the former scares away new maintainers, the latter shouldn't
19:10:24 <dons> you have an obligation to maintain it now you know. yi depends on it.
19:10:39 * sorear grumbles
19:11:30 <dylan> heh, I thought it was dead so I ended up rewriting my prototype thingy in C. <g>
19:12:00 <edwardk> tautologico: i'm currently abusing them to represent the runtime state of my interpreter, the thread is the stack, the heap is the stuff dangling off the end.
19:12:02 * allbery_b is half tempted to reply to Oleg that he can implement them in FORTRAN theoretically --- but he's not stupid enough to do something that insane
19:12:36 <dylan> edwardk: that really is abuse.
19:12:55 <tautologico> :)
19:12:55 <dylan> and also scary.
19:13:22 <SamB> allbery_b: but it is very easy to be able to do that theoretically
19:13:34 <SamB> theoretically, I could program in Java
19:13:46 <sorear> allbery_b: I've read of zippers implemented in hardware
19:13:53 <edwardk> dylan: well, its even worse because a fegaras/sheard catamorphism traverses the higher order abstract syntax and returns a record of monadic actions that are used to enter subterms
19:13:57 <sorear> allbery_b: I've seen several C implemetations
19:14:17 <edwardk> laziness is the only thing that saves my bacon
19:14:41 <allbery_b> I'm not talking about zippers, I'm talking about Oleg's "we really don't need GADTs" rant on -cafe
19:15:01 <edwardk> i'm trying to see how much of the compiler i can implement wholly within HOAS.
19:15:04 <allbery_b> we don't *need* them, sure.  but there's a difference between "can be done" and "should be done"
19:15:15 <dons> yeah, seems obvious. oleg's a purist though
19:15:37 <edwardk> oleg just wants to turn haskell into prolog ;)
19:15:54 <sorear> allbery_b: iirc fortran is close enough to untyped we get gadts for free
19:17:05 <sorear> tautologico: I've seen zippers in C code so old that it was sharred and usenetted instead of tarred and webbed.
19:17:28 <sorear> tautologico: the minischeme garbage collector uses a zipper to traverse the heap
19:17:57 <sorear> tautologico: a comment in the code says the algorithm was transcribed directly from TAOCP, but I lack the resources to verify that
19:18:28 <tautologico> sorear: I'm not familiar with the minischeme gc, but thanks for the info
19:19:19 <sorear> i think this was before the term zipper was coined.  it was described as "pointer reversal"
19:19:27 <edwardk> yeah
19:19:41 <edwardk> i remember the pointer reversal trick
19:19:54 <tautologico> yes, pointer reversal is well-known
19:20:19 <edwardk> the moment i started thinking of the stack as a zipper, zippers clicked.
19:21:42 <sorear> stacks are zippers?   stacks are zippers!
19:21:43 <edwardk> then of course all the dynamic wind stuff makes immediate sense as well
19:21:47 <gravity> They are?
19:21:56 <edwardk> they are just unzipping and going down another path
19:22:00 <nburlett> sorear: isn't it that zippers are stacks?
19:22:10 * sorear now understands SKIM's pointer reversal evaluator
19:22:12 <LoganCapaldo> foos are bars!
19:24:10 <edwardk> sorear: i think dave herman mentioned something to that effect on his blog around october or so and i just ignored it, then i was trying to figure out how to traverse a HOAS representation, and i realized I have a stack behind me when evaluating terms, so lets call that the zipper and provide a mechanism to move around in the form of a set of monadic operations on the zipper.
19:25:14 <sorear> SKIM == SKI Machine, one of the first (and last) natively functional computers  (in case anyone is wondering)
19:26:48 <edwardk> of course viewed in that context, with the stacks are zippers thing, it is immediately obvious that multiple threads run into problems, because you now have 'two holes' in the data structure and the zipper invariants fail.
19:27:28 <edwardk> its just a viewpoint i never had on how multithreading gets you into trouble before
19:28:04 <petekaz> dons: "write less, think more" ... I love that.
19:28:10 <LoganCapaldo> I would think multithreading means you have two data structures
19:28:37 <LoganCapaldo> You can't jump into another threads stack afaik
19:28:39 <edwardk> logan: you can have two data structures, but if you traverse common mutable data then the zipper invariants can fail
19:29:05 <LoganCapaldo> Ok
19:29:56 <edwardk> its pretty cheesy and basic, but i will admit i bounced around quite happily when it all clicked.
19:29:57 <SamB> edwardk: are you leading in to talking about how zipperfs works?
19:30:45 <edwardk> samb: not particularly. in my case i just wanted it to walk a HOAS tree, since its hard to rephrase all of your algorithms as catamorphisms.
19:31:19 <SamB> how *does* that handle multithreaded access?
19:32:27 <edwardk> er, in my case? i don't. =) its just used in the compiler, though i suppose blackholing would work, you build the blackhole, then you prevent another thread from opening a blackhole with its zipper.
19:32:40 <edwardk> er you mean zipperfs?
19:32:49 <SamB> yeah, zipperfs
19:33:32 <edwardk> heh, now i need to read oleg's two-hole zipper stuff ;)
19:35:24 <edwardk> http://okmij.org/ftp/Haskell/Zipper2.lhs
19:38:20 <dino-> This was disappointing to read, and would be even if it wasn't found on planet.haskell.org: "Haskell slows me down, I have to think too much"
19:40:59 <SamB_XP> dino-: soon maybe comes the realization that "oh, it slows me down if I waste too much time not thinking"
19:41:00 <dylan> heh, I'd argue you can think less.
19:41:38 <dylan> at least, worry less.
19:42:14 <edwardk> i wonder if one could (ab) use tvar links on that style of zipper to let a bunch of threads mutate different parts of the syntax tree
19:43:03 <HairyDude>     No instance for (MemIso Int f)
19:43:03 <HairyDude>       arising from use of `hlI' at <interactive>:1:18-20
19:43:07 <HairyDude> grarrr!
19:44:04 <HairyDude> but there is one for f = NatT, and cos of the fundep it's the only possible one!
19:45:05 <dino-> I was surprised with the complaints about QuickCheck too. Ok, it's not for everything, but it does a huge amount of work for you by thinking up the test cases.
19:45:30 <HairyDude> oh wait, no there isn't. doh, forgot to actually declare the instance.
19:47:12 <nburlett> dino-: what paper are you talkiing about?
19:47:16 <dino-> I'm not claiming to be very good with QC yet. Hell, I'm terrible with math. But I've used QC on a couple of things and it doesn't seem that scary. People seem perplexed and terrified or something.
19:47:57 <dino-> nburlett: Current top-post on planet haskell. http://planet.haskell.org/
19:47:59 <lambdabot> Title: Planet Haskell
19:49:16 <dons> "Haskell slows me down, I have to think too much." could be a slogan.
19:49:32 <dons> "write less, think more" is another encoding
19:49:45 <nburlett> time to change the topic?
19:50:01 <nburlett> although, I do like the current one ;->
19:50:23 <dons> its nice :-)
19:50:30 --- mode: ChanServ set +o dons
19:50:34 * MyCatVerbs glances upward.
19:50:38 --- topic: set to '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
19:50:45 --- mode: ChanServ set -o dons
19:51:05 <ryani> Newbie question: How can I make getChar return immediately after the first character typed instead of waiting until newline?
19:51:26 <dons> getChar should always return.
19:51:28 <ryani> I tried hSetBuffering stdin NoBuffering but that didn't work.
19:51:32 <dons> do x <- getChar ; print x
19:51:45 <LoganCapaldo> ryani: thine terminal controleth this
19:52:08 <LoganCapaldo> thou wisheth to make use of curses or set thine terminal to raw mode
19:52:21 <ryani> I suspected something like that
19:52:28 <dons> raw mode in curses works, yes.
19:54:09 <dino-> On a positive note, I did like how Adam Turoff started off in his Intro to Haskell article at ONLamp.com: "Let me start by being perfectly clear: if you are a professional programmer, then Haskell is in your future."
19:54:30 <dino-> http://www.onlamp.com/pub/a/onlamp/2007/05/21/an-introduction-to-haskell---part-1-why-haskell.html
19:54:32 <lambdabot> Title: ONLamp.com -- An Introduction to Haskell, Part 1: Why Haskell, http://tinyurl.com/3cpyts
19:55:33 <dons> yes, that's a nice strong statement.
19:56:21 <nburlett> yeah, I liked that
19:56:32 <nburlett> I wish I could get people using Haskell here at GHS
19:56:39 <nburlett> however, I don't see it happening
19:56:40 <dino-> dons: I'm really going to have to try to make one of those meetings with zig in the DC area. I'm close enough to be embarrassed for not trying.
19:58:18 <edwardk> http://coblitz.codeen.org:3125/citeseer.ist.psu.edu/cache/papers/cs/16413/http:zSzzSzwww.cs.uu.nlzSz~johanjzSzpublicationszSzTheWeb.pdf/hinze01web.pdf <-- neat: zippers with less boilerplate
19:58:22 <lambdabot> http://tinyurl.com/2yd2c4
19:58:29 <nburlett> however, I expect Haskell isn't suitable for writing an RTOS in
19:59:08 <LoganCapaldo> yeah iot is!
19:59:10 <dino-> nburlett: Maybe so, but I would hope people could come up with a better reason than "I don't want to be smarter" to avoid it for the task.
19:59:19 * LoganCapaldo starts writting a RTOS in Haskell
19:59:21 <dino-> :(
19:59:24 <LoganCapaldo> Just kidding
19:59:26 <nburlett> LoganCapaldo: good luck
19:59:37 * LoganCapaldo continues to write a mud in haskell
20:00:20 <nburlett> I'd love to come up with a way to do haskell with gauranteed resource allocation
20:00:27 <nburlett> but I'm not smart enough :-<
20:00:31 <sorear> i wouldn't write a RTOS *directly* in haskell
20:00:58 <_dolio> You'd write it in Coq and compile to Haskell?
20:01:02 <sorear> but i've already figured out how to write a resource limit guaranteeing dsl
20:01:14 <nburlett> sorear: statically allocated everything?
20:01:15 <SamB_XP> dino-: yeah. how about "even experts are scared to try an RTOS in Haskell, because implicit lazyness is so hard to predict"
20:01:38 <sorear> note, I have not fleshed out all the details - always the <sarcasm>easiest</sarcasm> part
20:02:04 <sorear> nburlett: Static allocation only helps you with space usage.
20:02:16 <nburlett> sorear: well, that's necessary
20:02:27 <sorear> nburlett: I will reflect time complexities into type signatures!
20:02:33 <SamB_XP> sorear: you sure you can't semi-statically allocate time?
20:02:40 <sorear> REALLY hard real time
20:02:56 <SamB_XP> UNPOSSIBLE real time
20:03:21 <dino-> This reminds me, I wanted to ask: Why is length implemented in terms ot foldl' (foldl with strict function application)?
20:03:39 <nburlett> well, the RTOS I use is a hard-real-time OS
20:03:41 <SamB_XP> dino-: to avoid stack overflows
20:03:46 <sorear> dino-: Because it's conciser than explicit recursion
20:04:08 * araujo coding on himerge
20:04:12 <nburlett> we can prove that an interrupt will be serviced within a bounded time
20:04:15 <dino-> SamB_XP: So, basically to make sure it will handle ridiculous large lists?
20:04:17 <dibblego> *more concise
20:04:20 <sorear> dino-: because haskell doesn't support infinite numbers, so handling infinite lists are wasteful
20:04:30 <SamB_XP> dino-: not even ridiculously large ones
20:04:40 <MyCatVerbs> dino-: because if (length list) gets evaluated at all then you'll have to evaluate the whole list anyway. And eager evaluation is slightly faster than lazy.
20:04:48 <dino-> I see.
20:04:55 <sorear> length (readFile "/dev/hda")
20:05:06 <MyCatVerbs> sorear: oO
20:05:12 <sorear> 80 billion element list, lengthed in constant space
20:05:14 <dino-> I wonder if this means I should think about using the ' versions of folds now and again.
20:05:21 <SamB_XP> sorear: that ain't gonna work for most of us
20:05:22 <dino-> (which I basically never do)
20:05:26 <dibblego> dino-, s/folds/foldl
20:05:26 <MyCatVerbs> sorear: System.POSIX, use the stat function, for the love of Pete! ;-;
20:05:31 * nburlett is tempted to ask lambdabot to do that :->
20:05:32 <sorear> MyCatVerbs: You say you don't think?
20:05:34 <SamB_XP> also types are wrong
20:05:51 <SamB_XP> sorear: do you have a tiny hard drive?
20:06:12 <MyCatVerbs> sorear: indeed I don't. My neurons haven't been used in nigh on eighteen years now.
20:06:24 <sorear> SamB_XP: Not at all.  My hard drive is 16,000 times bigger than one of my father's
20:06:33 <LoganCapaldo> MyCatVerbs: will stating /dev/hda actually give you the size of the disk?
20:06:58 <SamB_XP> > 16000 * 10*1024^2
20:07:00 <lambdabot>  167772160000
20:07:03 <dino-> Thank you.
20:07:05 * sorear read that as "... for the love of Perl! ;-)"
20:07:06 <MyCatVerbs> LoganCapaldo: oh right, my bad.
20:07:34 <sorear> SamB_XP: Actually his was 5MB, not 10
20:07:38 <MyCatVerbs> LoganCapaldo: ioctl, then, surely?
20:07:38 <LoganCapaldo> MyCatVerbs: I only ask cause I don't have lin box to check with, but my mac seems to think that's not really gonna work :)
20:07:40 <SamB_XP> sorear: oh.
20:07:54 <SamB_XP> well, I just picked the smallest size I recalled from my childhood
20:07:57 <MyCatVerbs> LoganCapaldo: it doesn't, no. Gives a size of zero, because it's just an inode and not a regular file.
20:08:33 <LoganCapaldo> regular files are inodes too :)
20:08:33 <sorear> block special nodes can have sizes, surely?
20:08:42 <MyCatVerbs> LoganCapaldo: I think open(2)'ing the device then iostat(fd,FIONRED) might work.
20:08:49 <SamB_XP> sorear: perhaps they could
20:08:55 <SamB_XP> but how much does /dev/zero get?
20:08:57 <MyCatVerbs> LoganCapaldo: yars, but it's *just* an inode, no data.
20:09:07 <LoganCapaldo> uh huh
20:09:23 <LoganCapaldo> all those block pointers, not being used...
20:09:25 <LoganCapaldo> hmm
20:09:25 <SamB_XP> then again maybe that would imply having contents!
20:09:47 <SamB_XP> LoganCapaldo: "all those"?
20:10:08 <LoganCapaldo> well all 10ish of em
20:10:17 <MyCatVerbs> LoganCapaldo: does the POSIX module in Haskell have iostat, offhand?
20:10:22 <sorear> MyCatVerbs: Even after years of oleg eye surgery, haskell
20:10:27 <LoganCapaldo> MyCatVerbs: I have no idea
20:10:36 <MyCatVerbs> Righto
20:10:37 <sorear> 's type system can't telll the difference between ioctl and my foot
20:10:38 * MyCatVerbs checks.
20:11:50 <SamB_XP> sorear: your foot has type CInt -> CInt -> Ptr a -> IO ()?
20:11:56 <MyCatVerbs> Oh, um, bollocks.
20:13:00 <MyCatVerbs> LoganCapaldo: it would seem that it doesn't have ioctl. So there's no non-wasteful way to do that in Haskell other than adding to the libraries.
20:13:09 <dibblego> > let f = 7; ?type f -- can I do this in one statement to lambdabot? or must I use @let?
20:13:10 <lambdabot>  Parse error
20:13:23 <SamB_XP> oh, wait, ioctl doesn't even have a proper type
20:13:26 <mauke> @type let f = 7 in f
20:13:27 <SamB_XP> it ends in ...
20:13:28 <lambdabot> forall t. (Num t) => t
20:13:33 <dibblego> ah thanks
20:14:02 <SamB_XP> it totally needs an vioctl variant
20:14:35 <MyCatVerbs> SamB_XP: no, ioctl has variable arguments.
20:15:21 <MyCatVerbs> SamB_XP: perhaps a list of... ah, screwit.
20:15:55 <LoganCapaldo> I have: int ioctl(int d, unsigned long request, char *argp)
20:16:04 <SamB_XP> wait a moment
20:16:20 <SamB_XP> it seems that it is intended to have only three arguments
20:16:25 <SamB_XP> but the third has variable type
20:16:32 <SamB_XP> and... C can't do that.
20:16:41 <MyCatVerbs> SamB_XP: hahahaha, yes it damn well can.
20:16:58 <SamB_XP> (Haskell can only do that with GADTs)
20:17:02 <MyCatVerbs> SamB_XP: trivially with type punning, for example.
20:17:14 <SamB_XP> (and even then it has to close them)
20:17:38 <MyCatVerbs> SamB_XP: on my platform it seems to have been written with the assumption that sizeof(void*)==sizeof(long), but aside from that it's trivial.
20:18:25 <mauke> no, it isn't
20:18:39 <MyCatVerbs> mauke: hrmn?
20:18:40 <mauke> ioctl is a horrible hack
20:18:56 <MyCatVerbs> mauke: if by that you mean "it works," yes.
20:19:15 <mauke> only because current compilers are insufficiently evil/awesome
20:19:24 <mauke> gcc is evolving, though
20:20:28 <MyCatVerbs> Okay, I think all the sensible people in the room are going to flame me for saying something so incredibly stupid, but...
20:20:33 <allbery_b> ioctl() is indeed a horrible hack
20:20:50 <MyCatVerbs> I'd say the solution to this kinda stuff is to add a mechanism for inline C inside IO monads.
20:21:03 <LoganCapaldo> That would be convient
20:21:14 <MyCatVerbs> Since every damn OS on the planet has its own myriad little syscalls with their own highly specific semantics.
20:21:17 <allbery_b> I think the bytestrings stuff fakes that currently
20:21:34 <mauke> MyCatVerbs: oh yes. having access to the C errno would be great, for example
20:21:38 <MyCatVerbs> And it'd make life really really *ever so very* much easier to write lowish level stuff in Haskell.
20:22:07 <SamB_XP> MyCatVerbs: well, if that assumption holds, then we could just go with Ptr a, as I said...
20:22:07 <LoganCapaldo> plus ghc can compile C++ apparently now. So there's precedent, or something.
20:22:16 <MyCatVerbs> Unfortunately, it'd also make life really ever so very much easier when deliberately writing totally non cross platform stuff in Haskell, so... :/
20:22:20 <allbery_b> re ioctl:  AT&T tried to fix that with STREAMS, you can send control messages to the streams infrastructure
20:22:37 <SamB_XP> LoganCapaldo: what?
20:22:50 <sah> so
20:23:13 <sah> trying, ultimately, to build HAppS
20:23:22 <MyCatVerbs> allbery_b: dammit, they're fine. Just need better documentation. Like, a version of "info" that doesn't suck so you can browse drivers' manual pages with hyperlinks to and from the lists of IOctl commands that each accepts.
20:23:33 <scodil> so I wrote a gaussian elimination function, and it runs faster using readArray than unsafeRead... should I just consider myself lucky and forget about it or is there something else going on?
20:23:47 <sah> to do that I need to build a thing called "binary"
20:24:00 <sah> to build that I need two things: greencard and pfesetup
20:24:06 <sah> 1) where do I get pfesetup?
20:24:14 <allbery_b> in practice it turns out to be ever so much more painful than ioctl, which is a hack but a convenient one
20:24:15 <MyCatVerbs> allbery_b: and everything from SysV needs lighting on fire and pissing on anyway. Hoorah for Bezerkely! ;)
20:24:20 <allbery_b> (grargh, dsl is wonky)
20:24:29 <sah> 2) compiling greencard, I get: ghc-6.6: unknown package: text
20:24:50 <sah> any clues?
20:25:05 <MyCatVerbs> allbery_b: I'm prepared to go with "horrible hack that works flawlessly in practice" over "stinking pile of overengineered shit that nobody ever actually wants to use."
20:25:07 <allbery_b> greencard is ancient
20:25:15 <allbery_b> I think the text package is in base these days
20:25:27 <sah> is HAppS ancient?  it seems to require greencard
20:25:32 <allbery_b> MCV: that was more or less my point :)
20:25:33 <SamB_XP> MyCatVerbs: ioctl doesn't work flawlessy...
20:25:39 <SamB_XP> it only works mostly okay...
20:25:45 <allbery_b> ==SamB_XP though
20:26:17 <MyCatVerbs> SamB_XP: my system boots every time I turn it on and "eject /dev/cd0c" works every time I issue it. I've yet to note any failures.
20:26:29 <SamB_XP> did I mention that GADTs don't let you reuse the same IOCTL with different arg types?
20:26:53 <SamB_XP> yes, but I bet eject /dev/toaster doesn't pop your toast up...
20:27:11 <SamB_XP> ... and wouldn't even if your toaster had good drivers!
20:27:24 <sah> okay, having removed "-package text", I get: GreenCard.lhs:10:7:
20:27:24 <sah>     Could not find module `GetOpt':
20:27:24 <sah>       Use -v to see a list of the files searched for.
20:27:34 <sah> and I still have no idea where to find pfesetup
20:28:01 <MyCatVerbs> SamB_XP: depends what kinda drivers you're talking about. Tranducer drivers and solenoids? Totally fine.
20:28:10 <allbery_b> ioctl doesn't stop you from doing the wrng operation on something that doesn't support it.  eject /dev/sda won't do much if it's a regular hard drive, and TIOCGETS will just fail at runtime
20:28:30 <SamB_XP> I was just thinking that probably your toaster would have different IOCTLs that did similar things
20:29:04 <MyCatVerbs> allbery_b: no, but the system's job isn't to prevent you attempting to do stupid things in the first place.
20:29:33 <allbery_b> you miss the point.  that's the equivalent of a type error at runtime
20:29:34 <hpaste>  LoganCapaldo pasted "SamB_XP: See? Unless the what? part was about precedence or lack thereof" at http://hpaste.org/79
20:29:40 <MyCatVerbs> allbery_b: yyyes, so?
20:29:49 <allbery_b> in Haskell you ideally want to catch that at compile time, as a type error
20:29:57 <allbery_b> if you want C, you know where to fin it :)
20:30:02 <MyCatVerbs> allbery_b: but you can't.
20:30:15 <SamB_XP> LoganCapaldo: oh, so it can maybe invoke G++
20:30:26 <mlh> you can't?
20:30:46 <MyCatVerbs> allbery_b: not without writing a Cassandra-complete compiler, anyway. Because you can't prove that the user won't deliberately tell your program to send that ioctl to something that won't accept it.
20:31:13 <SamB_XP> well, in Haskell you'd at least want to make sure the user gave the right kind of argument to an IOCTL
20:31:19 <LoganCapaldo> SamB_XP: Ok it was a little over the top to say it "compiled C++"
20:31:24 <allbery_b> you're still missing the point, I think
20:31:33 <allbery_b> ioctl() is a C-style barely-typed interface
20:31:38 <MyCatVerbs> allbery_b: if you allow the user to give the filename of the device node s?he wants to send the eject message to, they are free to tell it to send it to something that won't accept that. There is never, ever, any way whatsoever you could ever prevent that.
20:31:52 <allbery_b> ideally for Haskell you'd want to have a typed OS interface
20:32:01 <allbery_b> instead of overloading ioctl()
20:32:18 <MyCatVerbs> allbery_b: if you attempt to hardcode the path, you not only make your program nigh-useless but you also don't gain anything anyway 'cuz the user could just replace /dev/toaster with a symlink to
20:32:20 <mlh> yeah. there's two things going on here. one is helping the programmer, one is protecting the ssytem, they're not the same thing and have different solutions
20:32:23 <bitwiseshiftleft> ick.  sounds unportable and impossible to write
20:32:34 <MyCatVerbs> *a symlink to ~/toast.jpg
20:32:45 <MyCatVerbs> And then you're still stuffed.
20:33:46 <MyCatVerbs> So either you have to replace all Unix (a lofty and noble goal, admittedly) or you just can't have both the sort of type safety you're desiring and be able to actually use any of the functionality handed out by ioctl anyway.
20:34:19 <bitwiseshiftleft> MyCatVerbs: actually, you're missing a possibility
20:34:27 <MyCatVerbs> bitwiseshiftleft: hmmmyes?
20:34:27 <bitwiseshiftleft> you can have an intermediate layer
20:34:40 <bitwiseshiftleft> where the open() fails if it's the wrong kind of device
20:34:48 <bitwiseshiftleft> and open() can fail for 60 million reasons anyway
20:34:53 <MyCatVerbs> bitwiseshiftleft: that still counts as replacing all Unix and you still don't have a chance in Hell.
20:35:30 <bitwiseshiftleft> it doesn't seem like much more work than codifying all the types of ioctls
20:35:32 <MyCatVerbs> bitwiseshiftleft: now you're going to have to map out every device major and minor number on every OS you want to port that to. Have fun.
20:36:12 <bitwiseshiftleft> aren't we talking about "why can't you write down the types of all the ioctls and make it type safe"?  if the answer is, "that's unpossible" well you're probably right
20:36:18 <MyCatVerbs> Uhuh. Or alternatively you could just leave it up to the programmer to be careful about what they call ioctl on, and pass the exception back to them if they do try something invalid.
20:36:21 <bitwiseshiftleft> but if the answer is "but the user can open the wrong device"
20:36:27 <bitwiseshiftleft> then you could do this instead
20:36:30 <bitwiseshiftleft> well, i agree
20:37:01 <MyCatVerbs> There's not really much point in going to extreme lengths to assume that the _programmer_ is damn stupid when we could just spend all that time doing useful work instead.
20:37:23 <bitwiseshiftleft> i have no problem with forcing library authors to be careful with ioctls, since you can still issue ioctls to do the wrong thing, ioctls can still fail, etc
20:37:31 <bitwiseshiftleft> no matter how type-safe it is
20:38:00 <MyCatVerbs> bitwiseshiftleft: the problem is that in order to know what typify what ioctls are possible for what devices, you have to make a list of what devices are in every OS you port to and what ioctls each supports and the whole thing becomes a hyuuuuuge steeeenkeeeng mess. :/
20:38:24 <LoganCapaldo> name it unsafePerformIoCtl and be done with it :)
20:38:25 <bitwiseshiftleft> right, of course
20:38:51 <Thomas2> someone has pointed out already that the OS can't make any assumptions about the safety built in at the sys layer, so the checks have to be done already?
20:38:56 <MyCatVerbs> And you're still boned if the damn user rolls their own kernel for a lark. =)
20:39:03 <Thomas2> erk
20:39:07 <Thomas2> let me rewrite that
20:39:33 <Thomas2> that the OS can't make any assumptions about safety guarantees at the app/language/lib layer, and has to do the checks anyway?
20:40:03 <SamB_XP> how about unsafeIoCtl
20:40:12 <SamB_XP> since it isn't like unsafePerformIO really
20:40:14 <Thomas2> if you want a nice type safe layer for *using* ioctl, and telling you what's gone wrong when you make a mistake, that makes perfect sense, but the general assumption is that if you're using ioctl you're evil anyway
20:40:27 <MyCatVerbs> SamB_XP: I'd still prefer unsafeEmbedC... 
20:40:49 <SamB_XP> you mean {-# UNSAFE_C ... #-} ?
20:41:05 <MyCatVerbs> SamB_XP: can you do that already?
20:41:10 <SamB_XP> no.
20:41:22 <bitwiseshiftleft> hard to say... it wouldn't really be safe to replace it with a comment if your compiler doesn't understand it
20:41:23 <SamB_XP> well, maybe not exactly that syntax
20:41:25 <MyCatVerbs> Oh. But yes, that'd be the ideal solution, I think.
20:41:35 <SamB_XP> but you'd need funky syntax, anyway
20:41:58 <MyCatVerbs> Call it "Systems Haskell" or something and mark *all* these features as massively unsafe.
20:42:09 <LoganCapaldo> {-# SAFETY_NOT_GUARENTEED ... #-}
20:42:17 <MyCatVerbs> LoganCapaldo: ...no. Less safe than that.
20:42:20 <MyCatVerbs> {-
20:42:24 <MyCatVerbs> Erk, dammit.
20:42:34 <SamB_XP> {-# UNSAFETY_GUARENTEED #-}
20:42:39 <sorear> {-# NOT_SAFETY_GUARANTEED #-}
20:42:57 <SamB_XP> sorear: how is that better?
20:42:58 <MyCatVerbs> sorear: heehee.
20:43:14 <SamB_XP> ambiguity?
20:43:27 <MyCatVerbs> {-# HERE'S_SOME_ROPE,_GO_HAVE_FUN #-}
20:43:29 <bitwiseshiftleft> you might need a debian-style warning
20:43:32 <bitwiseshiftleft> To continue, type the phrase "I am aware that this is a very bad idea"
20:43:41 <LoganCapaldo> {-# OPTIONS -fno-safety #-}
20:43:46 <sorear> SamB_XP: there are a few dark corners of the english language where word order makes a difference
20:43:47 <MyCatVerbs> {-# MADNESS?_THIS_IS_HASKELL! #-}
20:44:01 <sorear> bitwiseshiftleft: Never seen that one - where is it?
20:44:04 <SamB_XP> sorear: dark corners? hardly.
20:44:06 <bitwiseshiftleft> it's not any more unsafe than the other unsafe* operations though
20:44:09 <SamB_XP> the man ate the dog.
20:44:23 <LoganCapaldo> unsafePerformHaskell :: a -> IO a
20:44:24 <MyCatVerbs> LoganCapaldo: but jah. I'm *totally* okay with the idea of no safety whatsoever in a systems programming language, because otherwise you can't get any damn work done anyway.
20:44:37 <bitwiseshiftleft> sorear: dpkg operations that break the base system i think
20:44:44 <emu> who says that
20:45:11 <LoganCapaldo> {-# ABSTRACTION_LEAK_FOLLOWS #-}
20:45:20 <SamB_XP> MyCatVerbs: they call that C, I think
20:45:26 <emu> safety, and power!  someday
20:45:34 <MyCatVerbs> bitwiseshiftleft: uhhhm. Well, it'd be *much* easier to shoot yourself in the foot and *much* harder to _not_ fuck up embedding C into your Haskell program than using vanilla suicide pills.
20:45:57 <MyCatVerbs> SamB_XP: heehee, yeah. But C blows chunks.
20:46:04 <bitwiseshiftleft> i suppose this is true.  unsafePerformIO is followed most of the time by newIORef or print anyway
20:46:07 <sorear> bitwiseshiftleft: Too bad I don't get that before 'ls: cannot load shared libraries: /lib/libc.so.6: I/O error'
20:46:14 * sorear got that once :/
20:46:28 <bitwiseshiftleft> yeah.  or "ssh: You don't exist.  Go away."
20:46:35 <SamB_XP> MyCatVerbs: but apparantly you wanted to blow chunks, anyway
20:46:47 <SamB_XP> bitwiseshiftleft: is that on OpenBSD?
20:46:54 <MyCatVerbs> SamB_XP: blow chunks up, in this case.
20:47:21 <sorear> try doing ANYTHING on a linux system with a libc made of badsectors
20:47:31 <SamB_XP> MyCatVerbs: that sounds like essentially what you expressed a desire for a system programming language to suppoer
20:47:33 <bitwiseshiftleft> SamB_XP on just about everything, i think.  strings `which ssh` | grep away
20:47:33 <SamB_XP> er.
20:47:34 <SamB_XP> support
20:47:48 <LoganCapaldo> Actually all this "I know this is a bad thing but I'm doing it anyway" reminds me of pointers in Ada
20:47:55 <sorear> (actually, that hard drive died so fast it might just have been the inode table that broke)
20:48:50 <SamB_XP> strings: /usr/bin/ssh: No such file or directory
20:48:53 <MyCatVerbs> SamB_XP: uhuh. But then, whatever chunks of unsafe C I embed in IO monads would be *much* smaller than if I'd written the whole program in C.
20:49:37 <SamB_XP> couldn't you just stick 'em in another module and use FFI to get at 'em?
20:49:57 <SamB_XP> or, well, there is maybe some preprocessor that already does that
20:49:57 <MyCatVerbs> SamB_XP: yes. Definately. But it'd be nice to have it all in one place.
20:50:04 <SamB_XP> hsc2hs or whatever...
20:50:09 <MyCatVerbs> SamB_XP: jah, just a preprocessor would do it.
20:51:01 * MyCatVerbs googles hsc2hs and takes a looksee.
20:54:23 <MyCatVerbs> SamB_XP: this seems good, but I was thinking much more handholding and far more, uh, circumscribed interfaces.
20:54:44 <SamB_XP> handholding? with C?
20:54:47 <SamB_XP> hah!
20:55:10 <MyCatVerbs> SamB_XP: handholding with FFI. =)
20:56:36 <MyCatVerbs> SamB_XP: make the parameter passing retard-friendly (i.e. so that I can use it
20:57:33 <MyCatVerbs> ^~) and then provide basically no interaction whatsoever outside of arguments given and structs or pointers recieved.
20:57:56 <scodil> so in my matrix-matrix multiplication function, unsafeRead beats readArray, but in the matrix inversion function its the opposite. by healthy margins. does anyone know why this might be?
20:58:11 <scodil> er, beats it regarding speed
20:58:25 * LoganCapaldo makes wild uninformed guess
20:58:28 <LoganCapaldo> memoization?
20:58:46 <MyCatVerbs> Mebbe even have really strict requirements for what sort of values can be returned and how.
20:58:51 <LoganCapaldo> page faults?
20:59:06 <LoganCapaldo> That's _2_ wild uninformed guesses
20:59:14 <LoganCapaldo> for the price of one
21:01:07 <scodil> yeah those are wild
21:01:20 <scodil> there's less actual code in the slower version
21:01:36 <scodil> this is weird
21:02:47 <LoganCapaldo> well theres less code in a linear search than a binary search...
21:03:06 <scodil> no its the same algorithm, but unsafeRead replaced by readArray
21:03:16 <scodil> readArray calls unsafeRead, as well as checks bounds
21:03:24 <scodil> so its very strange that it should be faster
21:03:39 <LoganCapaldo> I return to my memoization WAG
21:03:43 <MyCatVerbs> scodil: quit wondering and profile already.
21:03:54 <scodil> MyCatVerbs: how do you think I can tell its faster?
21:04:05 <MyCatVerbs> scodil: heehee, silly me.
21:04:45 <scodil> I know I should just forget about it and go with the faster, safer version, but this makes me think that some optimization in the unsafe version isn't happening, and if I figured out what that was I could make it faster still
21:04:51 <bitwiseshiftleft> there's always "look at the core"
21:04:59 <scodil> I can't pierce that stuff
21:05:07 <LoganCapaldo> careful, it might stop spinning
21:05:39 <LoganCapaldo> the core that is
21:05:55 <MyCatVerbs> LoganCapaldo: s'okay, we have nukes.
21:06:07 <MyCatVerbs> LoganCapaldo: and physically impossible materials.
21:06:43 <MyCatVerbs> LoganCapaldo: and mechanically impossible nuclear power plants.
21:06:53 <mwc> My favourite is the welding of the cables onto the hull
21:07:03 <MyCatVerbs> mwc: that doesn't even make the list.
21:07:10 <mwc> Of course it does
21:07:31 <LoganCapaldo> My favorite is I make this joke without having seen the movie
21:07:33 <MyCatVerbs> mwc: what you *really* oughta be concerned by is how the Hell come the effects of gravity on the crew are completely unvarying?
21:08:05 <gravity> It's one of my secrets.
21:08:13 <MyCatVerbs> mwc: like somehow their boots stick to the floor even though their craft is pointed directly at the Earth's centre of mass.
21:08:21 <MyCatVerbs> gravity: ...damn your inscrutable nature.
21:08:24 <gravity> hehe
21:08:44 <mwc> MyCatVerbs: if you remember the movie, the inner deck are mounted in some kind of gimballing cage
21:08:58 <MyCatVerbs> gravity: and would you please quit f---ing with our heads over the whole quantum mechanics thing? We'd like to get a unified theory eventually, dammit.
21:08:59 <mwc> and we're supposed to overlook how they get through the door
21:09:02 <LoganCapaldo> @remember MyCatVerbs: mwc: what you *really* oughta be concerned by is how the Hell come the effects of gravity on the crew are completely unvarying? gravity: It's one of my secrets
21:09:02 <lambdabot> Done.
21:09:07 <gravity> I'll get right on that :-)
21:09:42 <mwc> But yeah, the gravitational field should have lessened off a bit. I never actually ran the numbers, but I figure they ought to have been bouncing around like they were on the moon
21:09:42 <jql> Ahh, I'm waiting for them to unify the forces of Gravity and the Left Turn. That'll be a breakthrough
21:09:59 <MyCatVerbs> mwc: which is plainly impossible because of the fixed-position doors. Which are *always* running in a line parallel to the craft's nose, but somehow the doors are never on the ceiling or anything...
21:10:08 <MyCatVerbs> mwc: IIRC, it takes a kinda weird curve.
21:10:16 <LoganCapaldo> type Unify = Either Gravity LeftTurn
21:10:29 <mwc> MyCatVerbs: I could compute it out, but I'm too lazy
21:10:37 <mwc> looks like my major in theoretical physics was totally wasted
21:10:39 <jql> haskell is entirely too useful
21:10:39 <SamB_XP> MyCatVerbs: maybe they are like elevator doors?
21:10:52 <MyCatVerbs> mwc: to begin with it increases because of the inverse square law. Towards the end it drops towards zero because the attraction from the rock above you cancels out that from the rock below.
21:11:06 <SamB_XP> jql: what kind of complaint is that?
21:11:08 <mwc> MyCatVerbs: sort of, but not quite
21:11:11 <MyCatVerbs> mwc: so it follows an upside-down tick curve.
21:11:22 <mwc> your explanation is wrong
21:11:27 <MyCatVerbs> mwc: hmmm?
21:11:41 <MyCatVerbs> Elaborate, please?
21:11:53 <LoganCapaldo> Forget elaboration!
21:11:54 <mwc> you actually only experience gravitational attraction with the mass of radius less than your position
21:11:57 <LoganCapaldo> Let's just go there!
21:12:06 <mwc> everything wiht a greater radius entirely cancels itself out
21:12:22 <bitwiseshiftleft> everyone loves Gauss' law
21:12:26 <mwc> bitwiseshiftleft: bingo ;)
21:12:49 <LoganCapaldo> I am not a uniform Gaussian surface! I am a man!
21:13:04 <mwc> LoganCapaldo: no, but you are a man locked inside an equipotental surface!
21:13:13 <MyCatVerbs> mwc: yuhuh. The stuff above you is ignorable because the attraction to the rock in one direction is balanced by the attraction from the rock in t'other direction. I... don't really see where our explainations differ. You just phrased it along a different variable.
21:13:22 <SamB_XP> hmm, my physics teacher wishes we taught gravity with gauss' law...
21:13:40 <MyCatVerbs> mwc: and the upside-down-tick curve does happen. Peaks somewhere around 2g I think.
21:13:46 <LoganCapaldo> I wish gravity was taught with Gauss rifles
21:13:48 <MyCatVerbs> SamB_XP: Gauss' law?
21:14:01 <mwc> MyCatVerbs: do you know any vector calculus?
21:14:04 * MyCatVerbs googles. Yay, hyperphysics.
21:14:11 <mwc> Or can I give you the handwaving explanation ;)
21:14:30 <MyCatVerbs> mwc: no and I don't trust you, obviously. ;)
21:14:49 <mwc> Damn, I was just gonna appeal to radial symettry ;(
21:15:02 <jfredett> ... *spits* pah, physics..
21:15:13 <LoganCapaldo> Radial Symmetry: Denied.
21:15:34 <MyCatVerbs> SamB_XP: Gauss law is for electrical fields, though. Sure, you can rephrase it for gravity, but since when was there ever such a concept as variable permittivity for gravitational fields?
21:15:49 <SamB_XP> MyCatVerbs: that is irrelevant
21:16:26 * LoganCapaldo is pretty sure he saw some gravimetric sheilds on star trek...
21:16:34 <jfredett> lol
21:16:49 <MyCatVerbs> SamB_XP: yeah, it still *works*, but explaining it using Gauss' law involves using one more constant than the situation really requires, surely?
21:17:03 <mwc> MyCatVerbs: iirc, div g = -4piGM
21:17:37 <LoganCapaldo> mwc: I don't think that type checks
21:17:41 <LoganCapaldo> @type div
21:17:43 <lambdabot> forall a. (Integral a) => a -> a -> a
21:17:51 <MyCatVerbs> mwc: div? What the Heck is div in this context, sorry?
21:17:56 <mwc> Damn, the prelude omitted a divergence operator ;(
21:18:00 <jfredett> divergence?
21:18:01 <jfredett> lol
21:18:16 <jfredett> its been a LONG time since V/T Calc
21:19:04 <LoganCapaldo> > fix (1:) -- divergence
21:19:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:19:55 <jfredett> what does fix do,anyway?   repeatedly catenate the argument to itself?
21:20:03 <mwc> jfredett: not quite
21:20:10 <mwc> let fix f = let x = f x in x
21:20:14 <LoganCapaldo> @src fix
21:20:15 <lambdabot> fix f = let x = f x in x
21:20:20 <jfredett> i see
21:20:29 <LoganCapaldo> it's Y
21:20:31 <mauke> fix = unconst
21:20:38 <jfredett> oh, okay
21:20:41 <sah> argh, how the hell does anyone ever get HAppS installed?
21:20:42 <mwc> jfredett: think of it as passing a function its result as an argument
21:20:43 <mauke> > fix (const 42)
21:20:44 <lambdabot>  42
21:20:55 <jfredett> cool
21:20:59 <mwc> mauke: heh, never thought of doing that
21:21:25 <LoganCapaldo> > fix (\n f -> if n == 0 || n == 1 then 1 else f (n-1) + f (n-2)) 5
21:21:26 <lambdabot>      Occurs check: cannot construct the infinite type:
21:21:26 <lambdabot>       t = (t -> t1) ->...
21:21:38 <LoganCapaldo> > fix (\f n -> if n == 0 || n == 1 then 1 else f (n-1) + f (n-2)) 5
21:21:39 <lambdabot>  8
21:21:54 <dfranke> dons, while building lambdabot:
21:21:56 <dfranke> scripts/BotPP.hs:21:17:
21:21:56 <dfranke>     Could not find module `Data.ByteString.Char8':
21:21:56 <dfranke>       it was found in multiple packages: fps-0.7 base
21:22:03 <dfranke> is there a quick fix for that?
21:22:33 <dons> ghc-pkg unregister fps
21:24:30 <LoganCapaldo> @type fix . const
21:24:32 <lambdabot> forall a. a -> a
21:24:46 <dfranke> Setup.hs: cannot satisfy dependency fps>=0.7
21:25:12 <bitwiseshiftleft> blargh, fps is pretty old too... you can probably still download it though
21:25:41 <SamB_XP> bitwiseshiftleft: you mean because it comes with base now?
21:25:45 <bitwiseshiftleft> yeah
21:25:51 <bitwiseshiftleft> it hasn't been called fps for a while
21:26:08 <SamB_XP> the standalone Data.ByteString still had the package name "fps"
21:26:11 <bitwiseshiftleft> maybe you can hack setup.hs?
21:26:50 <bitwiseshiftleft> SamB_XP: oh, my bad
21:32:55 <dfranke> oh, no wonder.  Looks like I'm using an out-of-date version of lambdabot.
21:43:34 <dons> sah: those warnings about pfesetup are just warnings
21:43:40 <dons> happs doesn't need greencard or pfesetup or anythiing
21:55:28 <sah> dons: it needs "binary"
21:55:57 <sah> ah, but those are warnings for binary
21:56:15 <sah> but now I get: cc1: error: unrecognized option `-fno-unit-at-a-time'
21:56:22 <sah> trying to build binary
21:57:29 <dons> wow. what OS/arch?
21:57:34 <sah> debian
21:57:38 <sah> x86
21:59:14 <foof> Hey all, I'm looking for an article or library I saw once about an alternative to printf style formatting, using combinators instead.
21:59:35 <kaol> sah: stable, testing or unstable?
21:59:38 <sah> weird, I guessed and upgraded gcc, and now it's building
21:59:39 <sah> stable
22:00:08 <sah> looks like I had some old gcc-related something that ghc fails to correctly exclude as a viable dependency
22:00:36 <sorear> sah: Stable or oldstable?
22:00:50 <sah> I don't know what oldstable is
22:00:55 <sorear> sah: woody
22:01:00 <sorear> er, sarge
22:01:03 <LoganCapaldo> increasingly stable
22:01:07 <sorear> stable is 'etch' now
22:02:17 <Korollary> foof: maybe this? http://www.informatik.uni-bonn.de/~ralf/publications/Format.ps.gz
22:03:20 <sah> deb http://debian.lcs.mit.edu/debian/ stable main
22:03:21 <lambdabot> Title: Index of /debian
22:03:25 <sah> whatever that means
22:04:10 <kaol> I guess I could backport happs...
22:05:37 <sorear> sah: Yow.  OK, that mirror is up to date (not that I knew it existed before today)
22:05:43 <foof> Korollary: thanks, I think that was it
22:06:09 <LoganCapaldo> backport always makes it sound like someone's got a time machine, but its really hard to use
22:06:39 <sorear> backport sounds like backhoe to me...
22:07:05 <araujo> hah
22:07:13 <foof> that doesn't seem to handle padding though
22:07:16 * araujo throws a lambda at sorear 
22:07:27 <foof> how do people usually do formatting in haskell?
22:08:31 <LoganCapaldo> > printf "%s hasn't formatted anything in Haskell" "LoganCapaldo" :: String
22:08:32 <lambdabot>  "LoganCapaldo hasn't formatted anything in Haskell"
22:08:37 <sorear> (++), printf, or HughesPJ  depending on the level of sophistication required
22:09:27 <MyCatVerbs> @type printf
22:09:28 <lambdabot> forall r. (PrintfType r) => String -> r
22:09:47 <foof> how does printf handle multiple arguments?
22:10:01 <LoganCapaldo> type class hackery
22:10:21 <LoganCapaldo> Annnnnd it's overloaded
22:10:27 <LoganCapaldo> > printf "%s hasn't formatted anything in Haskell" "LoganCapaldo" :: IO ()
22:10:28 <lambdabot>  <IO ()>
22:10:49 <LoganCapaldo> if lambdabot printed things, that would printed
22:10:55 <LoganCapaldo> amazng!
22:11:06 <newsham> ?type printf
22:11:08 <lambdabot> forall r. (PrintfType r) => String -> r
22:11:27 <newsham> printf can do IO () too?
22:11:31 <foof> > printf "%d and %d blackbirds" 4 20
22:11:32 <lambdabot>  Add a type signature
22:11:42 <foof> :/
22:11:45 <LoganCapaldo> newsham: indeedly do
22:11:55 <LoganCapaldo> > printf "%d and %d blackbirds" 4 20 :: String
22:11:56 <lambdabot>  "4 and 20 blackbirds"
22:12:05 <newsham> i know the stringyness
22:13:15 <foof> > printf "%d and 20 blackbirds" 4 20 :: String
22:13:16 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
22:13:22 <MyCatVerbs> > printf "%d and %d screaming type mismatches shredding your soul from inside out." 4 (20.0::Float) :: String
22:13:23 <lambdabot>  Exception: Printf.printf: bad argument
22:13:49 <MyCatVerbs> > printf "%d and %f bleargh put some irrevelant crap here." 4 (20.0::Float) :: String
22:13:50 <lambdabot>  "4 and 20.0 bleargh put some irrevelant crap here."
22:14:14 <MyCatVerbs> > printf "%d and %f reasons type inference rules." 4 20 :: String
22:14:15 <lambdabot>  Exception: Printf.printf: bad argument
22:14:19 <MyCatVerbs> Hrmn, damnation.
22:14:47 <LoganCapaldo> > printf "%f" (20 :: Float) :: String
22:14:48 <lambdabot>  "20.0"
22:14:50 <MyCatVerbs> Well, screw printf. To Heck with anything that breaks the type inference mechanism.
22:14:56 <mauke> as in C, the compiler doesn't parse format strings to determine types :-)
22:15:12 <LoganCapaldo> mauke: Doesn't gcc do some checking for obvious boo boos?
22:15:14 <mauke> how does it break type inference?
22:15:17 * araujo thinks ... and wonders if he could do this with recursion ....
22:15:26 <mauke> LoganCapaldo: yes, but only for warnings
22:15:28 <MyCatVerbs> mauke: yes it does. Well, it oughtn't, but it does anyway. gcc checks for incorrectly typed printf expressions.
22:15:38 <MyCatVerbs> Then swears at you.
22:15:38 <mornfall> you can do everything with recursion :-)
22:15:59 <mauke> MyCatVerbs: gcc 2>/dev/null  # fixed
22:16:26 * araujo thinks better ... and tries it out
22:16:34 <LoganCapaldo> cout << 20.0 << "whee"
22:16:38 <sorear> MyCatVerbs: No, it doesn't.  (printf "%d" 'x' :: String) is well typed and doesn't go wrong  (it reduces to _|_, but that's beside the point)
22:16:56 <MyCatVerbs> mauke: do I *look* like a videogame developer to you?
22:17:36 <LoganCapaldo> > printf "%d" $ fromEnum 'x' :: String
22:17:37 <lambdabot>  "120"
22:17:59 <MyCatVerbs> sorear: but it doesn't let the type inferrer work out that 20 in printf "%f bleah" 20 :: String should be taken as 20::Float instead of 20::Int
22:18:20 <LoganCapaldo> @type 20
22:18:22 <lambdabot> forall t. (Num t) => t
22:19:09 <MyCatVerbs> (And yeah, there's no way for it to, but that's kinda the point - other methods solve the problems printf is used for more effectively - in Haskell, anyway. C is different.)
22:19:15 <foof> GCC will warn for bad printf strings, but it's just looking at functions with the name "printf".  If you define your own it still warns.
22:20:30 <LoganCapaldo> MyCatVerbs: and how do you print a floating point decimal number w/ two decimal places?
22:21:06 <MyCatVerbs> LoganCapaldo: ...damnation. You have a point.
22:21:14 <mauke> > printf "%.02f" 1.234 :: String
22:21:16 <lambdabot>  "1.23"
22:21:16 <Japsu> @hoogle printf
22:21:17 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
22:21:17 <lambdabot> Text.Printf :: module
22:21:17 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
22:21:25 <LoganCapaldo> mauke: :)
22:21:33 <nburlett> how the hell does Text.Printf.printf work?
22:21:39 <mauke> > printf "%5.2f" 1.234 :: String
22:21:40 <lambdabot>  " 1.23"
22:21:43 <dons> check the source :-)
22:21:46 <mauke> > printf "%-5.2f" 1.234 :: String
22:21:48 <lambdabot>  "1.23 "
22:21:50 <dons> it uses a recursive type class to accumulate constraints
22:21:52 <dons> :t printf
22:21:52 <mauke> > printf "%+5.2f" 1.234 :: String
22:21:54 <lambdabot> forall r. (PrintfType r) => String -> r
22:21:55 <lambdabot>  Exception: Printf.printf: bad formatting char +
22:21:58 <dons> :t printf "%d%c"
22:21:59 <mauke> bah
22:21:59 <lambdabot> forall r. (PrintfType r) => r
22:22:02 <dons> :t printf "%d%c" (7 :: Int)
22:22:04 <lambdabot> forall t. (PrintfType (Int -> t)) => t
22:22:05 <dons> :t printf "%d%c" (7 :: Int) 'x'
22:22:05 <mauke> why doesn't it support +?
22:22:07 <lambdabot> forall t. (PrintfType (Int -> Char -> t)) => t
22:22:09 <nburlett> @source Printf
22:22:09 <lambdabot> Printf not available
22:22:10 <LoganCapaldo> nburlett: it's not even that bad (at least not the type parts). _I_ of all people read it
22:22:14 <dons> :t printf "%d%c%s" (7 :: Int) 'x' "foo"
22:22:14 <nburlett> @source Text.Printf.printf
22:22:15 <lambdabot> Text.Printf.printf not available
22:22:16 <lambdabot> forall t. (PrintfType (Int -> Char -> [Char] -> t)) => t
22:22:23 <foof> Hmmm... I've got a functional formatter in Scheme that should translate to Haskell without any hackery (minus the stuff that uses call/cc).
22:22:29 <dons> > printf "%d%c%s" (7 :: Int) 'x' "foo" :: String
22:22:30 <lambdabot>  "7xfoo"
22:22:36 <LoganCapaldo> foof: including the stuff that uses call/cc
22:22:40 <LoganCapaldo> @type callCC
22:22:42 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
22:22:57 <dons> continuation are just another programmable semicolon, after all :-)
22:23:23 <foof> Oh.  Are those full, re-entrant continuations?
22:23:40 <mauke> Cont is one of the more natural interpretations of >>=, actually
22:23:40 <mauke> I think
22:23:45 * SamB never got those
22:23:51 <dons> ?source Control.Monad.Cont
22:23:52 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
22:23:56 <SamB> re-entrent continuations...
22:25:26 <foof> Ack, except the parts that use call/cc are non-functional (the only place I ever use set! is in conjunction with call/cc).  I could put the state in the monad, I guess.
22:25:52 <mauke> now what's the difference between ContT State and StateT Cont?
22:26:16 <LoganCapaldo> mauke: elemIndex 'T' ?
22:26:29 <mauke> blargh
22:27:50 <sah> dons: I finally got HAppS built!  thanks for your help.
22:27:54 <dfranke> dons, another lambdabot compile issue.  This one in both 4.0.1 and darcs.
22:27:56 <dfranke> Lib/Parser.hs:7920:4: Not in scope: `as_name'
22:27:56 <dfranke> Lib/Parser.hs:7926:4: Not in scope: `qualified_name'
22:27:56 <dfranke> Lib/Parser.hs:7932:4: Not in scope: `hiding_name'
22:27:56 <dfranke> Lib/Parser.hs:8015:4: Not in scope: `minus_name'
22:27:56 <dfranke> Lib/Parser.hs:8021:4: Not in scope: `pling_name'
22:27:57 <dfranke> Lib/Parser.hs:8034:4: Not in scope: `pling_name'
22:28:23 <dfranke> those functions appear to be in old versions of haskell-src but not recent ones.
22:28:32 <dons> ok. interesting.
22:30:05 <sorear> dfranke: Right.  lambdabot is deeply incompatible with 6.7 (6.6.1?)
22:30:13 <dfranke> sorear, 6.6.1
22:30:25 <sorear> I'm not suprised :(
22:35:54 * araujo compiled the code .. and now test
22:36:49 <dons> 6.6.1??
22:36:53 <dons> ?version
22:36:54 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
22:36:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:37:06 <MyCatVerbs> ...rh\
22:37:09 <dons> "deeply incompatible" with 6.6.x series sounds wrong.
22:37:12 <MyCatVerbs> ...ruhh?
22:37:28 <MyCatVerbs> Why does lambdabot report it's CPU speed in the version reply?
22:37:36 <dons> why not? :-)
22:37:38 <MyCatVerbs> *its
22:37:45 <SamB> tra-di-tion!
22:37:46 <dons> want to know how many free bogomips you get?
22:37:52 <araujo> muahahaha ..... other successful way of avoiding mutable state variables on himerge
22:37:54 <SamB> x-chat does that too
22:37:59 <dons> araujo: heh
22:38:08 <MyCatVerbs> dons: s'hardly relevant. It's not as if a 486 gives you different answers to an Opeteron. Just slower.
22:39:25 * araujo laughs histerically 
22:39:27 <SamB> of course, x-chat responds to CTCP VERSION rather than to @version
22:39:55 <dons> there's no reason for it. its our cultural heritage.
22:40:06 <dons> looks cute when there's 16x2Ghz though
22:40:16 <SamB> hysterical raisons
22:40:22 <dons> zactly
22:40:29 * araujo wants a "I don't believe on State" t-shirt
22:40:43 <MyCatVerbs> dons: 16x? Gahhhh,
22:40:44 <dons> oh, i note amd64bot didn't print 16x,   <amd64bot> lambdabot 4p512, GHC 6.6 (Linux x86_64 870)
22:40:56 <MyCatVerbs> Dammit, can't type for shit today
22:43:42 <dons> anyone running xmonad with an interesting set up, and they'd like to have a screenshot included on http://xmonad.org/ for the upcoming release?
22:43:43 <lambdabot> Title: xmonad : a tiling window manager
22:43:53 <dons> maybe you have a 3 head xinerama set up? or a cool status bar?
22:44:55 * nburlett goes to install xmonad
22:45:23 <araujo> dons, one of the attempt behind himerge is to show it's possible to code usable stuff without explicit state
22:45:37 <dons> if you hang on a few hours, you'll get a release candidate, nburlett. or you can go from the darcs repos now, linked on the web page.
22:45:46 <nburlett> http://darcs.haskell.org/~sjanssen/X11-extras/ ?
22:45:47 <nburlett> err
22:45:47 <lambdabot> Title: Index of /~sjanssen/X11-extras
22:45:49 <nburlett> oops
22:45:52 <dons> araujo: so no State monad?
22:46:03 <dons> nburlett: yeah, from there, and http://darcs.haskell.org/~sjanssen/xmonad
22:46:04 <lambdabot> Title: Index of /~sjanssen/xmonad
22:46:07 <dons> is what you need.
22:46:08 <araujo> Most of the state-like computation i have faced, are usually solved using: recursion, closures, and local declarations
22:46:10 <nburlett> yeah, that's the one :->
22:46:17 <araujo> dons, correct, no State monad anywhere
22:46:20 <nburlett> I have a darcs pull from yesterday
22:46:26 <dons> araujo: right. so you just manually thread the truly global stuff?
22:46:32 <araujo> dons, correct
22:46:33 <dons> nburlett: update, lots of patches last night
22:46:39 <dons> nburlett: such as a status bar :-)
22:46:42 * nburlett runs darcs pull
22:46:46 <nburlett> what kind of status bar?
22:47:04 <araujo> dons, i have found this kind of programming ... very .... 'lexically readable'
22:47:06 <dons> support for arbitrary status bars, on any side of the screen, on any xinerama screen
22:47:25 <dons> you just run some program in the gap, and it acts like a status bar. dzen is a good example
22:47:36 <nburlett> um, ok
22:47:57 <dons> here's an example, http://xmonad.org/images/screen-dons-tall-status.png
22:47:59 <nburlett> can I run xfce panel or somethign?
22:48:13 <dons> that's dzen, an external program. but you could run any panel/dock/menu style app
22:48:16 * araujo will probably blog about it soon
22:48:28 <dons> araujo: good.
22:48:41 <nburlett> dons: the thing at the top?
22:49:06 <dons> yep, that's dzen
22:49:20 <dons> ?where+ dzen http://gotmor.googlepages.com/dzen
22:49:21 <lambdabot> Done.
22:50:20 <nburlett> ?where X11
22:50:20 <lambdabot> I know nothing about x11.
22:50:34 <dons> ?hackage X11
22:50:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
22:50:49 <nburlett> dons: thanks
22:50:57 <LoganCapaldo> hackage, egads that's a whole command I didn't know existed
22:51:38 <nburlett> LoganCapaldo: you and me both
22:52:17 <LoganCapaldo> And it's not like I've not done
22:52:18 <LoganCapaldo> @help
22:52:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:52:24 <LoganCapaldo> @list
22:52:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:52:27 <LoganCapaldo> many a tim
22:52:28 <nburlett> has anyone anyone bult this on Mac OS X?
22:52:43 <dons> i've heard rumours, yes.
22:52:54 <dons> you'll probably need to specify the path to X11 libs in the .cabal file though
22:53:11 <nburlett> @quote girl119
22:53:12 <lambdabot> No quotes match. I've seen penguins that can type better than that.
22:53:25 <LoganCapaldo> Hmm the list of commands seems out of date (no hackage)
22:53:28 <nburlett> @quote girl19
22:53:28 <lambdabot> No quotes match. Take a stress pill and think things over.
22:53:29 <dons> see the faq, http://xmonad.org/faq.html, if you get link errors with X11
22:53:30 <lambdabot> Title: xmonad : frequently asked questions
22:53:34 <nburlett> @girl19
22:53:34 <lambdabot> well.. I never hacked Russians
22:53:38 <LoganCapaldo> Is it automatically generated?
22:53:59 <dons> it is, on demand.
22:54:42 <LoganCapaldo> k
22:56:24 <nburlett> what's with girl19?
22:57:12 <LoganCapaldo> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
22:57:13 <lambdabot>  fd:24: hClose: resource vanished (Broken pipe)
22:57:26 <nburlett> ?
22:57:42 <LoganCapaldo> vanishing resources eh
22:58:29 <nburlett> grr.. why can't people decide between Setup.hs and Setup.lhs
22:59:07 <LoganCapaldo> nburlett: what diff. does it make to you?
22:59:25 <LoganCapaldo> Unless theres some bizzare project with both...
22:59:29 <nburlett> shell history.
22:59:59 <dons> .lhs is portable as an executable script
23:00:07 <dons> so theoreticay you could configure with hugs
23:00:18 <LoganCapaldo> put this in your shell history: runhaskell Setup.*hs
23:00:20 <nburlett> I usually type: runhasell Setup.lhs configure
23:00:23 <nburlett> yeah
23:00:35 <dons> $ which c
23:00:36 <dons> c: aliased to runhaskell Setup configure --prefix=/home/dons -b /usr/obj/cabal
23:00:37 <dons> :-)
23:00:45 <nburlett> nice
23:00:47 <dons> (dump .o files into a scratch dir)
23:01:21 <LoganCapaldo> I see dons compiles a _lot_ of haskell packages
23:01:28 <nburlett> I have about 15 different versions of my company's C debugger available, so I have a script to select between them
23:01:51 <QtPlatypus> nburlett: Why so meany?
23:02:01 <sorear> i have about 10 different versions of ghc installed.  yay for cabal's -w option!
23:02:08 <nburlett> QtPlatypus: various versions, target architectures, etc
23:02:41 <sorear> hm, exactly 10 atm
23:04:06 <nburlett> nburlett@blizzard ~> myt | wc -l
23:04:08 <nburlett> 28
23:04:20 <nburlett> so yeah, 28 versions
23:05:05 <nburlett> four or so are my own compiled copies, 8 or so are versions installed from CD, 5-6 are autobuilt versions
23:05:18 <sorear> stefan@stefans:/tmp$ cat `which cabal-build`
23:05:19 <sorear> #! /bin/sh
23:05:19 <sorear> #set -e
23:05:19 <sorear> F="runhaskell `([ -e Setup.lhs ] && echo Setup.lhs) || echo Setup.hs`"
23:05:19 <sorear> $F clean ; $F configure --prefix=/home/stefan --user "$@" ; $F build ; $F install
23:05:45 <sorear> 1 command to build any cabal package with any version of ghc
23:05:52 <nburlett> :->
23:06:09 <sorear> notice line 3 :)
23:06:30 <nburlett> yeah, whacked stuffs
23:07:02 <Japsu> one command to build them all, one command to run them, one command to crash them all and in a core dump bind them
23:07:20 <sorear> makes regression testing a breeze!
23:08:19 <nburlett> someone wrote a really cool script to automatically binary-search regressions
23:09:58 <sorear> one of the major dvcs' (I was so sure it was darcs...) has a binary regression search command built in :)
23:10:17 <sorear> ah yes it was darcs
23:10:39 <nburlett> cool
23:10:43 <nburlett> we're on subversion
23:11:09 <LoganCapaldo> subverison isn't very subversive
23:11:38 <dons> darcs does it, but its subversive.
23:12:57 <nburlett> now, how do I have macosx use xmonad?
23:13:32 <dons> you'll need to be running X somehow
23:13:39 <sjanssen> nburlett: edit .xinitrc
23:13:41 <nburlett> yes, that I have
23:13:41 <dons> and then in X, run xmonad as the window manager.
23:13:58 <nburlett> huh, I don't seem to have that, strange
23:13:59 <sjanssen> nburlett: you'll also have to turn 'full screen mode' on
23:14:14 <sjanssen> nburlett: yeah, it won't be there by default
23:14:14 <dons> we should have advice for mac peopel
23:14:15 <nburlett> oh?
23:14:33 <dons> sjanssen: and there should be an example .xinitrc in the readme
23:14:42 <sjanssen> .xinitrc is just:
23:14:45 <sjanssen> #!/bin/sh
23:14:50 <sjanssen> exec xmonad
23:14:55 <dons> ok
23:14:56 <nburlett> cool, it works now
23:15:23 <dons> hey nice.
23:15:26 <nburlett> now i need to figure out how to use it
23:15:39 <dons> ok. mod-shift-return to get an xterm up
23:15:45 <dons> mod-space to cycle through tiling modes
23:15:49 <dons> mod-jk to move focus around
23:15:59 <dons> mod-1..9 to go to other workspaces
23:16:03 <dons> and the rest is in Config.hs
23:16:19 <dons> you'll need dzen or dmenu for status bar and app launching from a menu (optional)
23:18:15 <dons> rxvt-unicode is a nicer terminal to use, too. it refreshes better on resize, than xterm
23:22:50 <ari> Also, urxvtd+urxvtc is awesome
23:23:27 <aleator> Is there a trick to make something like this work "let a x = x (1::Int) || x (3::Double) in a (<2)"?
23:24:04 <nburlett> dons: spiffy :->
23:24:38 <nburlett> now if you can just make it work with Mac OS X native windows :->
23:24:40 <dons> aleator: heh. what's the type of 'a' ?
23:25:13 <dons> aleator: no. basically. you can't pattern match on types like that. that's a `typecase' in the literature, which is pretty evil
23:25:36 <dons> aleator: you want to do something different in the floating case?
23:25:53 <dons> if so, best to use a typeclass, and provide an instance for Double/Float, and one for integer values
23:26:50 <aleator> dons: It of course does not type. Why I'm not using a typeclass is that I want to change the condition 'x' every now and then.
23:27:15 <dons> what are you trying to do though? its unclear from that code fragment
23:27:58 <aleator> Well. that is a toy example, in reality I'm doing an optimization framework.
23:28:41 <aleator> ie. having stuff like (ga :: GAState -> m GAState) and typeclasses for accessing common things like number of fitness evaluations.
23:28:56 <aleator> And now I wish to compose several different kinds.
23:29:17 <aleator> Kinda complex so I thought I present a toy example :/
23:34:12 <nburlett> dons: I'm going to try this on my work machine tomorrow
23:34:16 <nburlett> I like :->
23:34:55 <dons> cool
23:38:37 <araujo> http://dev.gentoo.org/~araujo/lasthimerge.png
23:38:49 <edwardk> > let loeb x = (\a -> a $ loeb x) `fmap` x in loeb $ listArray (('a',1),('c',3)) $ [(!('a',2)), const 10, (!('a',2)), (!('a',1)), liftM2 (+) (!('a',3)) (!('a',1)), (!('c',3)), const 4, const 5, const 600]
23:38:51 <lambdabot>  array (('a',1),('c',3)) [(('a',1),10),(('a',2),10),(('a',3),10),(('b',1),10)...
23:40:24 <nburlett> how do I use this dzen thing?
23:40:40 <edwardk> er, guess lambdabot cut the spreadsheet off before anything interesting
23:44:44 <edwardk> >  fix (fmap . flip id =<<) $ listArray (('a',1),('c',3)) $ [(!('a',2)), const 10, (!('c',2)), (!('a',1)), liftM2 (+) (!('a',3)) (!('a',1)), (!('c',3)), const 4, const 5, const 600]
23:44:46 <lambdabot>  array (('a',1),('c',3)) [(('a',1),10),(('a',2),10),(('a',3),5),(('b',1),10),...
23:44:55 <edwardk> there
23:47:58 <nburlett> dons: what's the status.sh mentioned in the dzen guide: http://dzen.googlecode.com/svn/trunk/README ?
23:48:22 <dons> an program of some kind that prints strings to stdout
23:48:31 <nburlett> ah
23:48:38 <dons> while true ; do date ; sleep 30 ; done
23:48:40 <dons> for example.
23:48:52 <nburlett> does xmonad have some sort of way of talking to dzen?
23:49:05 <nburlett> like, how do I display the title of the front window
23:49:22 <dons> some experiments have been tried, so that is possible. we've not done it recently though
23:49:28 <dons> the idea would be:   xmonad | dzen
23:49:35 <dons> would print the current window state to stdout
23:49:37 <nburlett> ahhh
23:49:39 <dons> and dzen would render that
23:51:31 <nburlett> hmm.. maybe dzen could hook into a notification framework
23:57:14 <dons> that's an interesting idea
23:57:36 <nburlett> anyone know what modNMask the apple  Command key is?
