00:00:12 <dons> code of the day, http://programming.reddit.com/info/1uabt/comments
00:00:13 <lambdabot> Title: "Proofs (so that I don&#39;t have to edit the test-suite)" - A Haskell library g ...
00:04:36 <ivanm> dons: what is that?
00:04:44 <roconnor> bah, Data.Function
00:04:50 <ivanm> proof/logic transformation library?
00:05:07 <dons> ivanm: standard library module.
00:05:18 <dons> roconnor: yeah, the name is a bit fun :-)
00:05:56 <dons> ivanm: its just a haskell module, but there are hand proofs for properties in the comments.
00:06:04 <dons> since that's easier than writing test cases :-)
00:06:57 <ivanm> ahhhh
00:06:58 <ivanm> heh
00:07:37 <ivanm> dons: so its a standard library module containing all of 2 functions?
00:08:25 <dons> yeah, but with a bit of a cultural insight in the comments ;)
00:08:43 <dons> come on guys, mod up!http://programming.reddit.com/info/1uabt/details :-)
00:08:45 <lambdabot> Title: "Proofs (so that I don&#39;t have to edit the test-suite)" - A Haskell library g ...
00:08:47 <dons> where else would you see that.
00:09:19 <roconnor> but the proofs aren't even computered verified.
00:09:29 <roconnor> Let's just write it in Coq, and then extract to haskell.
00:09:46 <dons> oh, i wonder. hmm
00:09:51 <dons> ?djinn (a -> a) -> a
00:09:53 <dons> nah too hard
00:09:55 <lambdabot> -- f cannot be realized.
00:10:11 <dons> but what about `on`?
00:10:12 <dons> ?djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
00:10:13 <lambdabot> f a b c _ = a (b c) (b c)
00:10:34 <dons> oh, that's almost it.
00:10:52 <dons> should be, f a b c d = a (b c) (b d)
00:14:21 <dons> data PLZ a = AWSUM_THX a | O_NOES String
00:14:35 <mauke> oh god
00:14:55 <mauke> (the /r/ monad)
00:15:06 <ivanm> wtf isi the /r/ monad?
00:15:31 <ivanm> dons: I don't have an account on reddit, and don't plan on getting one, as it will just be another procrastination excuse :p
00:15:40 * ivanm thinks IRC is a good enough timewaster as it is ;-)
00:16:05 <mauke> instance Monad Plz where return = AWSUM_THX; fail = O_NOES; O_NOES s >>= _ = O_NOES s; AWSUM_THX x >>= f = f x
00:16:32 <dons> cool
00:17:16 <sebell> Are Int* and Word* types signed and unsigned, respectively?
00:17:40 <sjanssen> *?
00:17:47 <sjanssen> > minBound :: Word
00:17:48 <mauke> of course, I'm probably the first designer to include a KTHX command in a programming language
00:17:52 <sjanssen> > minBound :: Int
00:17:52 <lambdabot>  0
00:17:53 <lambdabot>  -2147483648
00:18:08 <dons> mauke: i was just thining about KTHXBYE for fail
00:18:32 <mauke> ploki uses KTHX for return and IACS for throw
00:19:21 <sebell> sjanssen: Thanks, by * I mean 8, 16, etc.
00:19:59 <sjanssen> ah
00:21:24 <mauke> dons: http://home.cs.tum.edu/~mai/ploki/ploki-0.6.4/examples/bf2c.pk
00:21:50 <dons> hah
00:34:51 <ivanm> dons: that cute code you posted on the mailing list...
00:35:05 <ivanm> its meant to be an even more condensed form of fibonacci, I presume?
00:36:21 <dons> oh, its a standard implementation in here, but i thought it might prove distracting on the list :-)
00:36:33 <ivanm> heh
00:36:38 * ivanm has never seen that before
00:36:45 <ivanm> just the sipWith version
00:36:48 <mauke> fix/scanl?
00:36:55 <dons> > fix ((0:) . scanl (+) 1)
00:36:56 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
00:36:56 <dons> yeah
00:36:59 <ivanm> + all the other ones in that humour page
00:37:05 <dons> i used it instead of switching the lights on and off
00:37:10 <ivanm> heh
01:02:02 <lumi> Hi, how do I turn on GADTs in GHC for a file?
01:02:54 <dolio> {-# OPTIONS_GHC -fglasgow-exts #-} most likely works.
01:03:03 <dolio> At the top.
01:03:40 <lumi> dolio: Thank you
01:03:51 <lumi> Is there a LANGUAGE way of doing it, or not so much?
01:04:37 <dolio> I don't see one. Maybe they're not widely implemented enough/too new...
01:05:59 <dolio> There are probably several LANGUAGE options you could use that would enable GADTs on GHC, but only because GHC does LANGUAGE stuff by using the corresponding -f flag.
01:06:16 <dolio> So, any other option turned on by -fglasgow-exts would probably work. :)
01:06:30 <dolio> That's rather obfuscated, though. :)
01:06:44 <lumi> Oh, I didn't know that, sounds kinda hacky
01:07:14 <dolio> I imagine they plan to change it in the future.
01:07:14 <lumi> I thought the -f flags would turn on the features, and not vice-versa
01:08:43 <jethr0> holla
01:08:50 <dolio> GHC probably just doesn't have the internal granularity of options necessary to do LANGUAGE like it's supposed to be at the moment.
01:10:16 <lokadin> how do you send a ping to thee irc server?
01:11:08 <lokadin> currently I write "PING : irc.oftc.net"
01:11:17 <lokadin> though it doesn't seem effective
01:12:15 <jethr0>  /ping ? ;)
01:12:23 <lokadin> well in terms of IRC bot
01:12:33 <jethr0> hehe
01:13:15 <lokadin> dons: how do I ping IRC server? write "PING" (':' : server)
01:13:35 <lokadin> or something else?
01:13:58 <dons> lokadin: something like that. check the IRC RFC spec.
01:14:05 <lokadin> cool :)
01:14:13 <dons> some send you pings, and you pong back with a timetamp
01:17:24 <lokadin> how do I set a thread timer?
01:17:31 <lokadin> so that the ping can timeout?
01:18:00 <mae> nested data parallelism anyone?
01:20:41 <lokadin> ping turns out doesn't need the :
01:22:05 <dons> mae, yes please!
01:22:18 <mae> dons, versus erlang built in concurrency?
01:23:00 <earthy> hmmm ndp! yum yum
01:23:08 <earthy> *waaaant*. :)
01:23:13 <kilimanjaro> nested data parallelism isn't all that similar to erlang's processes afaik
01:23:13 <dons> its just a  library, mae. on top of the underlying concurrency mechanisms.
01:24:05 <mae> dons, right i'm just new to functional languages i'm evaluating haskell and erlang, so whats your pitch for erlang :) i read disturbing things about the performance of haskell (i ignore all the whining about monads, thats for wimps :)
01:24:08 <flux> nested data parallelism is something you want to high performance computing.. not something you'd find in your average lambdabot I'd say.
01:24:27 <dons> performance should be better than erlang in all cases, I'd think.
01:24:42 <dons> or close for those that it isn't. native code compilers are a big win
01:24:55 <earthy> flux: I'd imagine that anything dealing with largish amounts of data, e.g. audio, images or video, would benefit from ndp on multicore systems
01:24:55 <noj> erlang has native code compiling
01:24:57 <noj> HiPE
01:25:05 <mae> but erlang lets you forget bindings and has a it-which-should-not-be-mentioned process dictionary
01:25:08 <dons> right, but all that dynamic checking doesn't make for blindingly fast code.
01:25:29 <flux> earthy, well, yes. things done in C libraries these days..
01:25:49 <noj> true
01:25:55 <flux> (not in a parallel fashion, though, so perhaps you want to rewrite them in haskell)
01:26:12 <dons> also, for some reason, erlang's speed is usually contrasted with python and ruby. while haskell's is contrasted with C
01:26:13 <mae> so
01:26:14 <mae> i guess
01:26:15 <dons> i'm not sure why.
01:26:20 <mae> how much cooler is haskell than erlang :)
01:26:27 <mae> erlang has a definite prolog finish to it
01:26:37 <flux> dons, static versus dynamic typing? toy versus real language?-) (now that last came off a bit trollish..)
01:26:40 <noj> the erlang syntax is a bit icky
01:26:52 <dons> haskell makes erlang look boring, 'cept for the distribution
01:27:13 <mae> heh
01:27:21 <mae> dons, in what sense?
01:27:43 <kfish> haskell is a toy language, the same way a ferrari is a toy car
01:27:44 <dons> oh, literally. if you learn haskell, erlang will be obvious. if you learn erlang, haskell will still be full of strange things
01:27:57 <caff> hi. As a haskell newbie, I've a problem building hmp3. please help
01:28:01 <caff> http://pastebin.4programmers.net/2293
01:28:20 <dons> hi caff. i'm the author. good thing you dropped by.
01:28:35 <mae> dons,  ok :)
01:28:43 <caff> dons: FastIO.hs:161:22: Couldn't match expected type `CInt' against inferred type `CMode'
01:29:06 <dons> caff, which ghc version you using?
01:29:19 <mae> dons, on some levels i sorta see erlang as the "C" of the new wave of functional languages.
01:29:20 <dons> (you need to update to ghc 6.6.x)
01:29:24 <caff> 6.6.1
01:29:33 <dons> caff. oh, hmm, ah. you're not using the darcs version?
01:29:35 <mae> dons, its small (core) practical, and slightly ugly :)
01:29:58 <caff> dons: no, the latest official release. I need to use darcs code?
01:30:05 <dons> caff, hmm. hang on. let me see.
01:30:13 <caff> dons: thank you
01:30:30 <dolio> What about OCaml. That can be pretty ugly. :)
01:30:39 <dolio> They use *two* semicolons to end a line!
01:30:45 <flux> they don't
01:31:01 <flux> only to say the repl that please, do evaluate
01:31:10 <caff> dons: on openbsd, it's 6.6.1 compiled from sources, because openbsd ships 6.2.x in the ports
01:31:19 <dons> yep. i'm on openbsd too.
01:31:20 <dolio> Ah, my bad. I have little OCaml experience.
01:31:23 <flux> (albeit you can use them in programs too if you wish)
01:32:17 <mae> dons, is ruby a toy? :)
01:32:23 <mae> kfish, rather :)
01:32:29 <dons> hmm. caff, compiles here with 6.6. let me try with 6.6.1.
01:35:29 <dons> caff: can you try a patch?
01:35:36 <caff> dons: yes
01:36:03 <dons> edit FastIO.hs on line 161-163, and add some fromIntegrals infront of the fields:
01:36:06 <dons>   readp <- c_access s $ fromIntegral r_OK
01:36:14 <dons> like that. rather than:
01:36:15 <dons>   readp <- c_access s r_OK
01:36:19 <caff> dons: ok
01:37:59 <caff> dons: wonderful, now compiles
01:38:22 <dons> cool
01:38:33 <dons> you'll want mpg321 from ports
01:38:39 <caff> dons: thank you very much. you're very kind
01:38:56 <caff> dons: already installed mpg321
01:39:05 <dons> actually, i have a screenshot of it running on openbsd here, http://xmonad.org/images/screen-dons-tall-status.png
01:39:48 <caff> dons: "$ fromIntegral" is it like a cast?
01:40:29 <dons> yeah
01:40:43 <caff> ok
01:40:43 <dons> the type changed from a CInt to a CMode between released (hmm :/) so we need to convert
01:41:09 <dons> hmp3 uses an internal part of the base library. i should probably factor that out, so it doesn't change between versions
02:14:48 <yakov> hi
02:16:13 <dmwit> heyo!
02:16:14 <ttmrichter> Hello.
02:21:50 <roconnor> If I use xmonad, will new windows steal my keyboard focus?
02:25:13 <nattfodd> roconnor: I seem to remember that yes
02:25:17 <nattfodd> but I'm not 100% sure
02:30:52 * roconnor grubles at KDE
02:32:10 <roconnor> I hate it when applications steal keyboard focus when I'm typing my password
02:32:43 <MyCatVerbs> roconnor: HELLS yes!
02:33:09 <roconnor> then you end up posting it as a comment to reddit or something like that. :P
02:33:19 <MyCatVerbs> roconnor: were I designing a windowing system, I'd design it so that no application could ever steal user focus under any circumstances whatsoever, punishable by death.
02:34:02 <MyCatVerbs> roconnor: ummm, maybe applications run as *root* would be able to, but only those. Wouldn't wanna make it impossible for the nuclear reactor controller software to pop up a bright red warning box, after all. ^^
02:34:26 <dmwit> MyCatVerbs: Why not allow it to steal visibility, but not focus?
02:34:38 <dmwit> Seems reasonable enough...
02:34:44 <MyCatVerbs> dmwit: no.
02:34:50 <dmwit> no?
02:35:06 <MyCatVerbs> No. I want application designers to feel like oppressed slaves.
02:35:25 <dmwit> haha
02:35:56 <MyCatVerbs> Maybe a good half to two thirds of the real usability problems people encounter with applications in the real world stem from the application programmers being fucking arrogant.
02:36:39 <MyCatVerbs> To such programmers, I say: no, fuck off. If the user wanted to pay your program attention they'd DAMN WELL BE LOOKING AT IT ON PURPOSE THEMSELVES.
02:37:01 <roconnor> What I really want is focus on the window I'm looking at
02:37:11 <roconnor> except when I don't
02:37:39 <MyCatVerbs> Like I'd like to burn Mozilla, because under conditions of unreliable network connection, it totally screws up trying to use other apps in the system by stealing focus with utterly useless popup dialog boxes.
02:37:48 <MyCatVerbs> I dpm
02:38:08 <roconnor> where's that haskell web browser?
02:38:33 <MyCatVerbs> *I do not give a shit if one out of the twenty damn tabs I'm trying to read failed to load. Or at least, certainly I do not care enough that I'd like to be interrupted halfway through typing my SSH key in.
02:39:10 <roconnor> MyCatVerbs: doesn't the X standard say that apps can steal kbd focus?
02:39:15 <MyCatVerbs> roconnor: tempting.
02:39:38 <MyCatVerbs> roconnor: maybe. If so, I do personally consider that a flaw. Lord knows X has 'em in droves.
02:39:47 <roconnor> :)
02:40:02 <DRMacIver> roconnor: Unfortunately no matter how hard you try, your static type system can't guarantee that the system is free of annoyance. :)
02:40:35 <roconnor> DRMacIver: you underestimate Oleg.
02:41:05 <MyCatVerbs> DRMacIver: unless, of course, your windowing API was designed by a vicious little sadistic barely-human bastard. Which is where I believe I come in.
02:41:46 <ttmrichter> DRMacIver, A type system can't prevent a system from being annoying, but a cattle prod applied just right to the people writing apps sure can!
02:42:49 <MyCatVerbs> DRMacIver: I mean, we just write up a list of things which people do with conventional windowing APIs that bug the living shit out of users, then design the system so that not only are better alternatives available but they're also easier to write in a non annoying way than an irritable one.
02:43:19 <DRMacIver> ttmrichter: I like your thinking!
02:43:26 <DRMacIver> I suppose MyCatVerbs's idea isn't awful either.
02:43:39 <ttmrichter> Why not combine them?
02:43:47 <MyCatVerbs> DRMacIver: like, make it painfully difficult to write popup error boxes.
02:43:56 <ttmrichter> Add a "cattle-prod the developer" button to all apps.
02:43:57 <MyCatVerbs> I'm all for ttmrichter's plan, too.
02:44:10 <ttmrichter> When they piss you off, you click the button and the developer gets a shock.  To where it counts most.
02:44:29 <MyCatVerbs> DRMacIver: and at the same time, add trivially-easy-to-use widgets for things like status bars, and error/warning consoles.
02:45:01 <MyCatVerbs> ttmrichter: ehhh, only problem I have with that is, well.
02:45:24 <MyCatVerbs> tmoertel_away: what if the gender imbalance in programming gets reduced? It'd really put the kybosh on zapping developer testes.
02:45:48 <ttmrichter> I didn't say "testes".  I said "where it counts most".
02:46:17 <MyCatVerbs> Oh you're right, my bad.
02:48:18 <ttmrichter> I really do wish there was a good functional GUI library for Haskell, personally
02:48:31 <ttmrichter> GtkHs is fine, but doesn't feel... well, doesn't feel like Haskell to me.
02:48:34 * MyCatVerbs ponders Tk bindings... ;)
02:48:39 <ttmrichter> It feels like Haskell wrapped around something else.
02:48:48 * ttmrichter kills MyCatVerbs....
02:49:19 <MyCatVerbs> ttmrichter: well, it's likely to. I mean, GTK is pretty purely imperative. Hell, isn't it even written in C++?
02:49:42 <dolio> GTK is written in C.
02:49:53 <ttmrichter> Yes, of course.  That's why I said that GtkHs is fine.
02:50:14 <ttmrichter> It's good for what it is: a functional wrapper around a viciously imperative library.
02:50:30 <ttmrichter> It's much easier to use than raw Gtk or Gtk++ for certain.
02:50:40 <MyCatVerbs> dolio: ahhh, danke. Sorry, I'd've googled, but there's a damn dodgy http proxy in between me and the wider intertubes.
02:51:27 <MyCatVerbs> dolio: weird as Hell. My SSH connections remain unscathed, but it plays merry *HELL* with attempting to read po-websites.
02:52:03 <dolio> Well, ssh isn't http, after all. :)
02:53:02 <dolio> Anyway, C is at least as imperative as C++, so the result is the same.
02:53:07 <MyCatVerbs> dolio: jah, that's why I think it's a damn dodgy http proxy. Doesn't seem to affect anything else.
02:54:28 <roconnor> @google 485 SEK in EUR
02:54:29 <lambdabot> 485 Swedish kronor = 52.7496166 Euros
02:58:14 <nattfodd> I've got a segfault with a haskell piece of software
02:58:18 <nattfodd> gdb doesn't show much
02:58:26 <nattfodd> is there a way to recompile it with debug info?
02:58:33 <nattfodd> (it's got a cabal build system)
03:00:45 <Igloo> Assuming GHC, the best you can easily do is to use -debug when linking
03:03:37 <MyCatVerbs> Hrmn. If you were planning to write some insanely overengineered videogame, where'd you start?
03:04:56 <kfish> MyCatVerbs, with an adequately-engineered video game :-)
03:06:08 <nattfodd> Igloo: is there a way to edit foo.cabal to tell it to add the flag?
03:06:24 <Igloo> nattfodd: "ghc-options: -debug" will probably do it
03:07:02 <MyCatVerbs> kfish: damn that's wise. ^^
03:07:03 <nattfodd> ok
03:12:10 <MyCatVerbs> roconnor: which'd be cooler, Haskell videogames or browser? =D
03:14:06 <nattfodd> hum, there seems to be some sort of cache, which makes the recompilation nearly instantaneous, even though ghc-options have been changed
03:14:10 <nattfodd> and it fails at link time
03:14:20 <nattfodd> any idea where/how I can deactivate this "feature"?
03:14:43 <ivanm> nattfodd: rm *.hi *.o
03:14:58 <ivanm> that should make it recompile everything
03:15:31 <nattfodd> I was running runhaskell Setup.hs clean
03:15:36 <nattfodd> doesn't that do the same thing?
03:15:45 <ivanm> *shrug* no idea
03:15:54 <nattfodd> k, I'll try your solution
03:15:57 <ivanm> try ls'ing and see if you have any .hi or .o files
03:16:19 <nattfodd> still the same
03:16:32 <ivanm> dunno then
03:16:33 <ivanm> sorry
03:18:07 <nattfodd> thanks anyway :)
03:18:14 <nattfodd> it's not ccache either
03:47:45 <kfish> omg: http://code.google.com/p/xml5/
03:47:47 <lambdabot> Title: xml5 - Google Code
03:48:19 <kfish> [ The idea is that having a non "draconian" version of XML would allow it be adopted more easily on the web as people tend to generate content using string concatenation which makes it very hard to guarantee "well-formed XML". ]
03:49:42 <ndm> yuk!
03:49:54 <ndm> HTML should have been rejected from the very begining if it didn't nest properly
03:50:18 <ndm> people who can't nest tags probably can't pick a background that isn't a hideous bright red
03:50:34 <matthew-_> there's some law that states you should be as liberal as possible in what you accept
03:50:58 <ndm> defining what malformed stuff does predictably is actually making it part of the spec, which makes the language non-obvious
03:51:09 <matthew-_> I'd argue that to a degree, the explosive growth of the internet was aided by the liberal parsing of html by the browsers
03:51:12 <ndm> matthew-_: yes, but those people are wrong
03:51:35 <quicksilver> 'be liberal in what you accept and conservative in what you send'
03:51:38 <kfish> matthew-_, yes, and the corollary to that is that you should also be as strict as possible in what you produce, which is what a spec (like xml) defines
03:51:44 <quicksilver> however this is a controversial point of view
03:51:46 <matthew-_> quicksilver: that rings a bell
03:51:53 <ndm> matthew-_: perhaps at the begining, but now its hampering progress - we need to move towards correct HTML, and no point crapping up XML
03:51:58 <ndm> (which is already pretty crap)
03:52:14 <quicksilver> it is the so-called 'robustness principle'
03:52:20 <ndm> quicksilver: its a good position for a minority player, but not a good position if assumed by a majority player
03:52:24 <quicksilver> http://en.wikipedia.org/wiki/Robustness_Principle
03:52:25 <lambdabot> Title: Robustness Principle - Wikipedia, the free encyclopedia
03:52:28 <quicksilver> and credited to Postel
03:52:30 <matthew-_> ndm: agreed. However, I feel there are more important things to fix first ;)
03:52:32 <ndm> since quickly, minority players have to match every quirk
03:52:47 <ndm> matthew-_: agreed, but lets not break XML deliberately...
03:53:13 <matthew-_> ndm: meh, I just use json anyway...
03:54:04 <matthew-_> and I think first on the list of "things to fix" is something relating to Haskell's use of /= vs != ...
03:57:08 <ndm> why?
03:57:13 <ndm> in C != makes sense
03:57:19 <matthew-_> ndm: err, t'was a joke
03:57:26 <ndm> ! is not, == is equals, != is not equals
03:57:36 <ndm> matthew-_: fair enough :)
03:59:47 * quicksilver lols at apfelmus for recommending girard/lafont/taylor to a non-CS person as an intro to system F :)
04:07:20 <malcolmw> kfish: someone needs to raise a bug against xml5, pointing out that specifying a broken version of XML is ridiculous
04:07:33 <roconnor> @what xml5
04:07:34 <lambdabot> I know nothing about xml5.
04:08:13 <matthew-_> specifying a broken version of maths has received funding in the past...
04:08:20 <matthew-_> xml's no better ;)
04:08:50 <roconnor> @what maths
04:08:50 <lambdabot> I know nothing about maths.
04:09:07 <roconnor> ah http://code.google.com/p/xml5/
04:09:09 <lambdabot> Title: xml5 - Google Code
04:10:44 <boegel> @what Haskell
04:10:44 <lambdabot> http://haskell.org/
04:10:49 <boegel> damned...
04:10:53 <boegel> @what "Haskell"
04:10:53 <lambdabot> I know nothing about "haskell".
04:10:56 <boegel> hehe :-)
04:12:24 <roconnor> Can't we generate XML using string concatination by some combination of multip-part mime messages and entity reference?
04:12:24 <Vq^> @what lambdabot
04:12:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:12:37 <roconnor> entity references?
04:33:03 <gidyn> What's up with Haskell'? The timeline at http://hackage.haskell.org/trac/haskell-prime/wiki/TimeLine is long passed, and the status page doesn't seem to give any indication of ongoing progress. The mailing list archives also don't seem to discuss any kind of end plan.
04:33:06 <lambdabot> Title: TimeLine - Haskell Prime - Trac
04:34:20 <gidyn> Thank you. Just what I needed.
04:35:57 <bringert> whoa, wtf happend in that "The C Equiv of != in Haskell" thread
04:37:11 <bringert> someone woke up on the wrong side
04:38:29 <quicksilver> yup
04:39:05 <quicksilver> not the first time that particular person has been involved in heated discussions
04:43:29 <gidyn> the discuss/refine stage was supposed to finish about a year ago
04:45:10 <dolio> gidyn: Yeah. Haskell' is kind of in limbo.
04:46:37 <gidyn> Starting to understand why the Perl 6 interpreter was written in Haskell :)
04:47:20 <matthew-_> does that perl 6 interpreter manage without any unsafe coerces ?
04:47:36 <quicksilver> because it models the perl type system
04:47:59 <quicksilver> when you are writing a language in haskell you are not constrained by the haskell type system for your source language :)
04:48:11 <quicksilver> you don't have to try to map perl types to haskell types
04:48:34 <matthew-_> quicksilver: true. I just rather have that mode of thinking on my mind right now...
04:50:25 <Saizan> Ã¹is there yet a Scheme to Haskell converter? my eyes refuse to parse s-expressions
04:50:45 <quicksilver> a scheme to haskell 'converter'? working on the source level?
04:50:55 <quicksilver> that sounds like a surprising thing to want :)
04:51:13 <flux> maybe liskell can do something like that?
04:51:22 <quicksilver> liskell is the oppposite
04:51:30 <quicksilver> liskell is the power of haskell, expressed as s-expressions
04:51:38 <flux> ok, so it doesn't actually convert to haskell in order to do the compliation?
04:51:41 <matthew-_> well just put the answer in and you'll get the question out...
04:51:58 <matthew-_> and iterate through all the answers until you get to your question!
04:54:17 <Saizan> flux: it has its own AST, which probably gets converted to the GHC.Core? dunno
04:55:44 <HelgeS> Would Haskell be a good language, to write a sound-processing application with a GUI?
05:00:00 <quicksilver> HelgeS: you're unlikely to receive unbiased answers here
05:00:10 <quicksilver> by and large, we think haskell is a good language for most stuff :)
05:01:04 <MyCatVerbs> HelgeS: well, it'll almost certainly make writing the filters an' stuff easier than most languages. You might need to work at it a bit to get it to run fast once you're done getting it to run at all, though.
05:01:20 <nattfodd> ghc seems to have some sort of compilation cache
05:01:26 <nattfodd> any idea how I can deactivate it?
05:01:30 <nattfodd> or at least empty it?
05:02:51 <matthew-_> -fforce-recomp
05:03:00 <nattfodd> thanks
05:03:06 <matthew-_> will cause it to ignore .hi and .o files
05:03:21 <HelgeS> My application would be a bit like a guitar tuner, doing FFT and frequency estimation, with microphone input, and a nice GUI. Are there apps written that do similar things in Haskell, like process real-time signals?
05:03:28 <matthew-_> but find -type f -name "*.o" "*.hi" -exec rm '{}' ';' will do a "better" clean
05:03:41 <matthew-_> nattfodd: but why is the caching a problem?
05:03:45 <nattfodd> matthew-_: ah, then no
05:03:53 <nattfodd> I already removed .hi/.o files
05:03:57 <quicksilver> HelgeS: I'm not aware of any (which isn't saying 'no')
05:04:05 <nattfodd> matthew-_: because I changed ghc-options and now it fails at link time
05:04:09 <matthew-_> ahh!
05:04:32 <nattfodd> known problem?
05:04:47 <matthew-_> so, if you really removed all the .hi and .o files and everything's being compiled fresh with the same ghc options then it really should be fine.
05:05:06 <nattfodd> well, the issue is that no, it isn't being compiled with the same ghc options
05:05:19 <nattfodd> but the build takes ~45 seconds instead of half an hour
05:05:35 <nattfodd> which makes me a bit suspicious to say the least
05:05:38 <matthew-_> yeah, I turn of optimisations when I'm developing
05:05:42 <matthew-_> off, rather
05:05:54 <quicksilver> HelgeS: you could check out the big list on hackage
05:05:55 <matthew-_> 30 mins isn't unheard of for a big code base
05:05:57 <quicksilver> @where hackage
05:05:57 <lambdabot> http://hackage.haskell.org/trac/hackage
05:06:58 <HelgeS> quicksilver: Thank you, I will check it out!
05:07:03 <matthew-_> nattfodd: but, err, why can't you compile the whole thing with your "new" flags?
05:07:37 <nattfodd> matthew-_: I *am* recompiling the whole thing after a thorough clean
05:07:43 <nattfodd> and it still takes 45s instead of 30m
05:07:47 <nattfodd> and fails at link time
05:08:01 <matthew-_> ok, *that's* bizarre then! Not seen that myself.
05:08:15 <matthew-_> which version of ghc and is there any ffi stuff?
05:08:34 <nattfodd> ghc 6.6
05:08:39 <nattfodd> dunno what ffi is, sorry
05:08:48 <matthew-_> err, is it trying to link with any C code?
05:09:05 <matthew-_> ffi is the foreign interface - haskell <-> C (and others) bindings
05:09:16 <nattfodd> not to my knowledge
05:09:23 <nattfodd> find . -iname \*.c doesn't return anything
05:09:52 <matthew-_> ok, can you paste the link error?
05:09:53 <matthew-_> @paste
05:09:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:12:11 <yakov> @paste
05:12:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:12:14 <Saizan> nattfodd: are you using cabal and forgot to rerun configure?
05:12:33 <nattfodd> I am using cabal and have rerun configure dozen of times
05:12:47 <nattfodd> bleh, now link worked o_O
05:13:09 <nattfodd> hum no, wait a minute
05:14:32 <matthew-_> nattfodd: if it built once with runghc Setup.hs clean && runghc Setup.hs configure && runghc Setup.hs build and it doesn't after altering the flags then some of the flags might be crucial. But that shouldn't show up at the link stage...
05:14:57 <nattfodd> matthew-_: that's what happened
05:15:08 <nattfodd> and the change in flags was s/-O/-debug/
05:16:09 * nattfodd finishes recompilation
05:16:18 <matthew-_> mmm, well it's definately the case that if you turn on the debug flags then you have to do a complete clean.
05:16:56 <matthew-_> ohh - maybe it doesn't link with the base libraries - do you have debugging base installed?
05:17:03 <nattfodd> well, I *have* done a complete clean
05:17:10 <nattfodd> huh, no, what's that?
05:17:49 <matthew-_> (I really am guessing here) you might need ghc6-prof as well as ghc6: "ghc6-prof - Profiling libraries for the Glasgow Haskell Compilation system"
05:18:07 <nattfodd> hum
05:18:09 <matthew-_> can you make anything link if you compile it with -debug?
05:18:18 <nattfodd> butI'm not trying to profile, just to have debugging info
05:18:28 <matthew-_> on the other hand, I may be getting highly confused between debugging and profiling...
05:19:16 <matthew-_> -debug Use the debugging runtime. Mmm. I wonder where that is...
05:19:55 <matthew-_> still, can you get a basic "hello world"[0] to compile with -debug, and what's the link error? [0]: of course, hello world for functional languages is either fib or fac
05:21:58 <Igloo> What's the problem? You shouldn't need ghc6-prof to compile with -debug
05:22:09 <matthew-_> Igloo: thanks, I didn't know.
05:22:22 <nattfodd> hum, it did link correctly this time
05:22:31 <nattfodd> *and* it doesn't segfault anymore
05:22:44 <matthew-_> sounds like haskell to me ;-)
05:23:57 <nattfodd> thanks, then
05:39:43 <hpaste>  MarcWeber pasted "no instance for" at http://hpaste.org/95
05:40:15 <dmhouse> ?tell mauke I love his monad :)
05:40:15 <lambdabot> Consider it noted.
05:40:50 <MarcWeber> I have trouble understanding this error message because it does'nt appear when compiling the same code from within the main module. (app is called there) And I don't have any insntance declarations there
05:40:58 <kolmodin> nattfodd: hey! :)
05:41:02 <kolmodin> I'm back in gbg
05:41:40 <MarcWeber> Any ideas what might cause this?
05:42:16 <nattfodd> heya kolmodin
05:42:37 <kolmodin> I've been helping my parents to move. ugg
05:44:45 <dmhouse> MarcWeber: which is line 69?
05:45:05 * nattfodd in the process of darcs trackdown...
05:45:51 <kolmodin> nattfodd: how are your swedish lessons progressing?
05:46:10 <nattfodd> slowly is probably the word you are looking for...
05:46:49 * DRMacIver is idly wondering about trying to write some Haskell bindings for Clucene.
05:46:56 <DRMacIver> CLucene even.
05:47:08 <dmhouse> MarcWeber: and perhaps compiling Main imports another module with the correct instance decls.
05:47:26 <DRMacIver> Is there already any Haskell stuff out there for doing IR?
05:48:29 <MarcWeber> dmhouse  anrede <- labi "Anrede"
05:48:53 <ToRA> MarcWeber: what are the types of labi and labeled supposed to be?
05:49:12 <dmhouse> ToRA: from the looks of things, labeled is just const.
05:49:40 <dmhouse> ToRA: so labi "Anrede" has the type of inputField empty.
05:49:48 <MarcWeber> I have to go now. (appointment). I'll be back in an hour. I'll read annotations then. sry
05:50:14 <ToRA> dmhouse: i'm wondering whether that is intentional though ;)
05:50:14 <dmhouse> ToRA: my guess is that if it works when compiles from Main, then it's actually a case of having not imported the correct instance.
06:10:07 <bringert> is there any problem with instance MonadPlus m => Monoid (m a) where { mempty = mzero; mappend = mplus }
06:10:18 <bringert> except for the fact that it's not Haskell98
06:10:42 <dolio> It'll probably overlap with existing instances.
06:11:00 <dolio> Although, it might be defining the same instance, indirectly.
06:12:27 <dolio> @instances Monoid
06:12:30 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
06:12:41 <dolio> [a] is the obvious one.
06:12:56 <yakov> wow
06:12:58 <quicksilver> bringert: there is no problem with it, in principle
06:13:04 <quicksilver> bringert: it's just the overlapping problem
06:13:17 <yakov> what does lambdabot do?
06:13:23 <quicksilver> bringert: the inability to pleasantly cope with two monoids for the same type :(
06:13:40 <quicksilver> note, that, for example:
06:13:50 <DRMacIver> Hm
06:14:00 <quicksilver> > ([1,2]`mappend`[3,4],[1,2]`mplus`[3,4])
06:14:02 <lambdabot>  ([1,2,3,4],[1,2,3,4])
06:14:15 <DRMacIver> @pl let nums = 1 : (map (+1) nums) in nums
06:14:16 <lambdabot> fix ((1 :) . map (1 +))
06:14:25 <quicksilver> bah, bad example
06:14:30 * quicksilver ponders
06:14:33 <DRMacIver> > let nums = 1 : (map (+1) nums) in nums
06:14:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:14:38 <quicksilver> ah no, it's ok
06:14:45 <quicksilver> the two instances do coincide for [] :)
06:15:38 <Saizan> > mempty :: (Int,Int,Int)
06:15:39 <lambdabot>   add an instance declaration for (Monoid Int)
06:15:39 <lambdabot>     In the expression: mempty
06:15:39 <lambdabot> ...
06:15:52 <DRMacIver> > let nums = 1 : (map (+1) nums) in zipWith (,) nums nums
06:15:53 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,1...
06:16:05 * DRMacIver stops playing with the bot now. :)
06:16:10 <Saizan>  @instances should mantain the context
06:16:36 <dolio> quicksilver: Integer might be a better example. Which is what the 'Product a' and 'Sum a' are for above.
06:16:54 <dolio> Although that's not a monad.
06:16:57 <quicksilver> dolio: Integer isn't a MonadPlus :P
06:17:54 <dolio> Monads should be monoids with >> somehow, too, no?
06:18:01 <quicksilver> only on the type ()
06:18:10 <quicksilver> if m is a monad then m () is a monoid
06:18:15 <quicksilver> it's the "monoid of side-effects"
06:18:28 <dolio> Ah, indeed.
06:18:28 <quicksilver> or, "monoid of computational effect"
06:18:41 <quicksilver> and that, certainly, is different from the MonadPlus one
06:19:01 <quicksilver> ([()] >> [()],[()]`mappend`[()])
06:19:07 <quicksilver> > ([()] >> [()],[()]`mappend`[()])
06:19:09 <lambdabot>  ([()],[(),()])
06:19:26 <dolio> You probably won't find that as the declared Monoid instance, though. :)
06:19:38 <quicksilver> no
06:19:46 <quicksilver> although it is, actually, a useful monoid
06:19:53 <quicksilver> it's useful in 'Writer' instances
06:20:06 <quicksilver> any kind of effect could make sense in Writer instances
06:22:57 <dolio> @src (->) mappend
06:22:57 <lambdabot> Source not found. You speak an infinite deal of nothing
06:23:17 <opqdonut> ?instances Monad
06:23:18 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:30:39 <kolmodin> has dcoutts said he'd be away?
06:31:11 <quicksilver> @seen dcoutts
06:31:12 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 18h 58m 41s ago.
06:31:17 <quicksilver> not in my hearing
06:31:33 <kolmodin> not mine neither
06:31:40 <kolmodin> er..
06:35:11 <bringert> @pl \m1 m2 -> m1 >>= \x1 -> m2 >>= \x2 -> return (x1 x2)
06:35:11 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
06:35:19 <bringert> eh
06:35:24 <bringert> right
06:36:00 <dons> ?yow
06:36:00 <lambdabot> Why are these athletic shoe salesmen following me??
06:36:06 <opqdonut> @do \m1 m2 -> m1 >>= \x1 -> m2 >>= \x2 -> return (x1 x2)
06:36:06 <lambdabot> \m1 m2 -> m1 >>= \x1 -> m2 >>= \x2 -> return (x1 x2) not available
06:36:13 <shapr> Good morning #Haskell!
06:36:17 <dons> xmonad release candidate 2 available, http://tinyurl.com/395gan :-)
06:36:22 <shapr> yay xmonad!
06:36:24 <lambdabot> Title: Gmane -- Mail To News And Back Again
06:36:31 <Vq^> goodafternoon shapr
06:36:33 <dons> taking over the world, tile by tile.
06:36:45 <shapr> dons: Hey, did you see the question about type-safe and network transparent chans on haskell-general?
06:36:59 <dons> oh, i saw a thread about broadcast messages?
06:37:17 <shapr> This thread was "composing channels"
06:37:29 <shapr> It's just a question, but I think it's a good question that needs a good answer.
06:38:37 <shapr> Lemmih and I have sent data across the network via HTTP, UDP and TCP and we've often had deserialization problems because there's no type information being sent across as well.
06:38:47 <shapr> I think I asked you this question before, but I've forgotten the answer...
06:39:01 <dons> hmm. so send as binary+typeables?
06:39:37 * shapr looks at Data.Typeable
06:40:05 <dons> there's a variant of binary out there where all the instances add and remove typeable checks
06:40:12 <dons> so you can check your values as you deserialise them
06:41:58 <shapr> Oh that sound perfect.
06:43:04 <kolmodin> iirc it's called pickle or similar
06:43:30 <dons> kolmodin: yeah, pickle. did it make it do hackage?
06:43:39 <kolmodin> don't know
06:43:43 <dons> (we probably should just provide it as Data.Binary.Typeable or something)
06:43:43 <kolmodin> but it's not perfect
06:44:05 <kolmodin> if you serialize the data type Person it'll look like Person<data>
06:44:15 <kolmodin> without saying what the datatype Person is made up of
06:44:42 <dons> yes, so it assumes you're running the same code on both ends
06:44:43 <kolmodin> so if your datatypes doesn't match you won't get an error
06:44:47 <kolmodin> yes
06:44:47 <dons> right.
06:44:53 <dons> you'd need versioning
06:44:57 <kolmodin> exactly
06:45:13 <kolmodin> dons: know where dcoutts is?
06:45:25 <dons> hmm, at cambridge?
06:45:29 <kolmodin> still?
06:45:39 <dons> maybe he's back.
06:45:56 <kolmodin> he said he had something this past weekend
06:46:08 <kolmodin> and we'd do binary paper on monday or later
06:46:10 <dons> yes, i'll mail out some plan for the paper in the morning, actually.
06:46:10 <kolmodin> now is later :)
06:46:14 <dons> yes.
06:46:14 <kolmodin> great
06:46:17 <dons> time to get started.
06:46:21 <kolmodin> absolutely
06:46:29 <kolmodin> I'm finishing the report of my thesis too
06:46:33 <kolmodin> much papers atm :)
06:46:39 <dons> ah ok. hehe. you're in the mood then!
06:46:47 <kolmodin> yeah!
06:46:55 <dons> kolmodin: tried out the xmonad 0.2 release candidate?
06:47:00 <kolmodin> my opponent showed me that my English grammar and spelling is crap
06:47:01 <dons> got status bars now :-)
06:47:04 <dons> heh
06:47:07 <kolmodin> wow!
06:47:09 <dons> `opponent' ?
06:47:23 <kolmodin> yeah?
06:47:27 <dons> reviewer?
06:47:41 <kolmodin> no
06:47:48 <dons> opponent is like the other team in a sporting match.
06:48:04 <opqdonut> isn't an opponent like a peer reviewer?
06:48:05 <kolmodin> right. I'll look for the right term :)
06:48:14 <opqdonut> somebody with whom you cross-review papers
06:48:19 <dons> ah i see!
06:48:22 <kolmodin> dons: it's like what you guys have for your Ph.D.s
06:48:38 <dons> for our reviews? and we have a panel of 3 guys who tell you where you went wrong.
06:48:40 <phoniq> i think 'reviewer' is the term
06:48:47 <dons> yeah.
06:48:50 <kolmodin> dons: exactly
06:48:54 <phoniq> or referee
06:48:55 <dons> they kind of are the opponents though :-)
06:48:59 <phoniq> yah
06:48:59 <kolmodin> ah, ok
06:49:09 <kolmodin> they're called opponents in Swedish :D
06:49:15 <dons> you want to beat them. :-)
06:49:19 <kolmodin> yes!
06:49:22 <opqdonut> kolmodin: finnish too
06:49:33 <kolmodin> and they tries to crush you
06:49:39 <phoniq> ah interesting
06:49:41 <kolmodin> opqdonut: cool
06:49:42 <dons> right! same system here :-)
06:49:59 <kolmodin> dons: except we have it on the masters degree too. not only PhD
06:50:21 <dons> ah yes. we have lightweight reviews on masters degrees. same guys, but they don't ask such tough questions
06:50:24 <kolmodin> and it's students opponing on each other
06:50:32 <kolmodin> yeah, excactly
06:50:34 <opqdonut> yes, exactly
06:50:36 <opqdonut> heh
06:50:37 <dons> so no "why are you here?" or "why do you think you should even be in the room? "
06:50:37 <kolmodin> I got away pretty easy :D
06:50:43 <dons> hehe
06:50:56 <kolmodin> nah, they actually had pretty good questions
06:51:01 <dons> ah, students against each other. interesting.
06:51:12 <kolmodin> but only for themselves to understand further. not questioning my work
06:51:28 <kolmodin> I was hoping someone would try to say I'd gone completely wrong from the start
06:51:34 <dons> i see. yes, we have students who can sit in, and ask questions.
06:51:47 <kolmodin> so we could have an interesting dicussion
06:51:51 <kolmodin> right
06:52:19 <kolmodin> we're supposed to find a friend or two who will do this, and officially be the opponent
06:52:33 <kolmodin> then the supervisor and examinor can ask tricky questions too
06:52:50 <dons> and you survived? :-)
06:52:58 <kolmodin> yes!
06:53:16 <kolmodin> bringert was/is my supervisor :)
06:53:23 <dons> ah, easy then ;)
06:53:28 <dons> he's a softy.
06:53:32 <kolmodin> yeah, he's far to kind :)
06:53:56 <dons> i'll have to encourage him to be tougher.
06:54:06 <kolmodin> I'm glad that other people, the spectators, also had questions
06:54:16 <kolmodin> which probably meant that they understood at least something :)
06:54:17 <dons> yeah, that's a good sign
06:54:22 <dons> right. and that it was interesting.
06:54:28 <kolmodin> yeah
06:54:38 <dons> if there are no quetions, either it was stunningly good, or terribly bad :)
06:54:48 <kolmodin> no questions can only mean that they've understood everything or nothing. the former is rare
06:54:54 <dons> heh
06:54:55 <kolmodin> right :D
06:55:10 <dons> ok. time for bed. binary paper and take over the world tomorrow. so sleep time.
06:55:13 <dons> night!
06:55:19 <kolmodin> g'night dons!
06:56:36 <bringert> dons: well, we haven't passed his report yet...
06:57:38 <shapr> Dang, I want a copy of that Pickle library.
07:00:30 <shapr> kolmodin: Did you write Pickle? or know who did?
07:00:45 <kolmodin> shapr: I did not
07:00:58 <kolmodin> I've got a mail aboutit somewhere... just a sec
07:01:06 <shapr> Spiffy, I couldn't find it on google.
07:01:46 <kolmodin> argh! chalmers webmail sucks
07:01:53 <kolmodin> so sloooow..
07:03:59 <kolmodin> bos wrote it
07:04:14 <kolmodin> http://darcs.serpentine.com/pickle that's the url in the mail
07:04:17 <fasta> A free exercise for you: Write a function f s.t. f [2,4,..] [1,3,..] = [1..]
07:04:53 <kolmodin> um.. it's 404ing
07:05:17 <kolmodin> shapr: ^^
07:06:25 <ph8> hi guys, i'm trying to define map without using list comprehensions for an old exam question is it just, map :: (a->b) -> [a] -> [b]; map f [] = 0; map f (x:xs) = f x : map xs
07:06:28 <ph8> or is that a list comprehension?
07:06:47 <Botje> ph8: map xs is an error.
07:07:04 <Botje> so is map f [] = 0
07:07:13 <Botje> 0 is not of type [b]
07:08:01 <Botje> fasta: f (y:ys) (x:xs) = x:y:f ys xs
07:08:44 <Botje> > let f (y:ys) (x:xs) = x:y:f ys xs in f [2,4..] [1,3..]
07:08:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:08:55 <ph8> sorry = 0 replaced with = []
07:09:00 <dolio> > let f = (concat .) . zipWith (flip (:) . return) in f [2, 4 ..] [1, 3 ..]
07:09:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:09:08 <ph8> map f xs?
07:09:12 <Botje> yes.
07:09:16 <ph8> ty :)
07:09:20 <Botje> dolio: cute. I was thinking about something like that :)
07:09:24 <ph8> exam tomorrow - shoudl be fun
07:09:28 <huschi_> ph8: map f (x:xs) = f x : map f xs
07:09:33 <dolio> :)
07:09:33 <shapr> kolmodin: Doesn't exist, that's too bad.
07:09:33 <DRMacIver> @pl let f (y:ys) (x:xs) = x:y:f ys xs in f
07:09:36 <lambdabot> fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . (((.) . flip ((.) . (:))) .)) .) . flip ((.) . (.) . (:)))
07:09:39 <DRMacIver> Ouch
07:09:54 <ph8> huschi_: and then deal with the [] case in f?
07:09:56 <Botje> that's not meant to be pl'ed
07:10:12 <huschi_> map f [] = [] (but this line *before* the other)
07:10:27 <Botje> huschi_: why?
07:10:32 <ph8> ah k
07:10:34 <ph8> cheers
07:10:35 <Botje> (x:xs) doesn't pattern match []
07:10:52 <ph8> yeh i thought not
07:10:53 <hpaste>  mdmkolbe|work pasted "Nightly mingw snapshot (verbose)" at http://hpaste.org/99
07:11:00 <huschi_> Botje: ah, it's nonsense.
07:11:24 <Botje> although listing the base case first is a Very Good Thing To Do.
07:12:41 <Botje> :t flip (:) . return
07:12:43 <lambdabot> forall a. a -> a -> [a]
07:13:00 <kolmodin> shapr: yeah
07:13:50 <Botje> :t (concat . )
07:13:53 <lambdabot> forall a a1. (a1 -> [[a]]) -> a1 -> [a]
07:15:33 <huschi_> is there any difference between hs-plugins and plugins? and do they work with ghc 6.6.1?
07:15:43 <Botje> hello 101010!
07:16:09 <SamB_XP> hmm, you know we are failing when we get "Most Practical Paper"
07:16:49 <ph8> it asks for the type of map, after this question about defining it manually
07:16:50 <SamB_XP> huschi_: the Cabal package is called plugins, I guess
07:16:51 <binary42> Hey. Just lurking today.
07:17:01 <ph8> what's the 'type'? is it just map :: (a->b) -> [a] -> [b]? or is that it's signature?
07:17:05 <huschi_> SamB_XP: ok. thx.
07:17:36 <Botje> ph8: yes, that's the type
07:17:43 <ph8> briloooo
07:17:46 <ph8> * brillo
07:17:48 <SamB_XP> huschi_: that isn't a very good name to use in conversation, though, since it is, well, kinda generic
07:17:51 <huschi_> the type of map is "(a -> b) -> [a] -> [b]" without the name map, afaik.
07:18:25 <huschi_> SamB_XP: i don't understand which name you mean.
07:18:57 <SamB> "plugins"
07:19:20 <SamB> that is such a generic name
07:19:56 <ph8> hmm, a function to remove anything less than 3 and greater than 10 using map/filter: map (filter (\x -> x>=3 && x<=10)) list
07:20:01 <ph8> is && valid?
07:20:03 <huschi_> SamB: you're right. and there is no hint that the are the same packe.
07:20:15 <ph8> sorry to abuse you like this :p help much appreciated
07:20:23 <ph8> exam tomorrow :-)
07:20:41 <huschi_> ph8: && is right. but why map and filter?
07:20:49 <ph8> s'what the question says
07:21:04 <ph8> it's given me a function that does the removal without using map/filter and told me to rewrite it using map and filter
07:21:27 <huschi_> :t  map . filter (\x -> x>=3 && x<=10)
07:21:32 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
07:21:32 <lambdabot>     In the second argument of `(.)', namely
07:21:45 <huschi_> :t  map (filter (\x -> x>=3 && x<=10))
07:21:47 <lambdabot> forall a. (Num a, Ord a) => [[a]] -> [[a]]
07:21:54 <SamB> @tell dons that naming the package for hs-plugins "plugins" confuses people (such as huschi_)
07:21:55 <lambdabot> Consider it noted.
07:22:36 <huschi_> SamB: thanks.
07:22:37 <ph8> ok so that's good then huschi_?
07:22:48 <ph8> i actually need to times the results by 3
07:22:50 <ph8> but i could just do
07:23:05 <ph8> map times3 $ map (filter ...) list
07:23:07 <ph8> right?
07:23:14 <ph8> assuming times3 is appropriately defined
07:23:36 <profmakx> is it right that you are operating on lists of lists?
07:23:44 <shapr> kolmodin: Did you get sent the source as well?
07:24:13 <huschi_> ph8: that would interest me, too.
07:26:29 * bringert hits some unknow emacs key combination, dumping 30 pages of LaTeX code on the printer
07:26:42 <shapr> bringert: Cool!
07:26:49 <shapr> bringert: Probably the print this buffer key combo
07:26:54 <DRMacIver> ph8: Note that you can write times3 as (*3) in Haskell.
07:27:15 <DRMacIver> Or (*) 3 if you prefer.
07:27:32 <huschi_> DRMacIver: the types say it must be "map (*3)".
07:28:07 <huschi_> because "map (filter ...)" returns sth. of type [[a]].
07:29:11 <DRMacIver> I wasn't suggestiong you could apply (*3) to a list. He already had "map times3" and I was suggesting a shorter way of writing times3. :)
07:29:19 <sjanssen> @keal
07:29:19 <lambdabot> you need a Zh function in Haskell
07:29:32 <kmb> Hello all.  I want to use getStdRandom (Random.randomR (x,y)) in a function, but it uses the IO monad.  Is there any way that I can unpack the resulting IO (Int) into an Int so that my function doesn't have to operate w/in a monad context?
07:29:36 <sjanssen> of course you can apply (*3) to a list!
07:29:43 <sjanssen> @type (*3) []
07:29:48 <lambdabot> forall a. (Num [a]) => [a]
07:30:01 <sjanssen> instance Num a => Num [a] where ...
07:30:15 <sjanssen> :)
07:30:25 <DRMacIver> sjanssen: Mmhmm. :)
07:30:37 <EvilTerran> kmb, not really. if you could, it'd break the functional purity of haskell
07:30:39 <huschi_> sjanssen: i think this was not ph8's intension :)
07:30:48 <sjanssen> huschi_: almost certainly not
07:31:00 <LoganCapaldo> kmb: you can do do r <- getStdRandom (Random.randomR (x,y)); return yourPureFunction r
07:32:16 <LoganCapaldo> I messed up there should be return (yourPureFunction r)
07:32:20 <ph8> Hugs.Base> map . filter (\x -> x>=3 && x<=10) [1..10]
07:32:21 <ph8> ERROR - Type error in application
07:32:23 <ph8> have i missed something?
07:32:29 <quicksilver> ph8: yes
07:32:34 <quicksilver> ph8: you don't want map, only filter
07:32:41 <ph8> oh :-)
07:32:43 <quicksilver> that's what huschi_ was trying to tell you :)
07:32:45 <ph8> then presumably the map is for the *3
07:32:55 <quicksilver> yes, that's likely
07:32:58 <ph8> nice! cheers
07:32:58 <huschi_> ph8: it looks like.
07:33:00 <quicksilver> map (*3) . filter (floorble)
07:33:21 <blackdog> kmb: the tricky bit is that you'll always get the same random number
07:33:27 <quicksilver> @pl \x -> x>=3 && x<=10
07:33:28 <lambdabot> liftM2 (&&) (>= 3) (<= 10)
07:33:33 <blackdog> unless you do it in an IO context and seed it...
07:33:51 <ph8> how would i do that with not?
07:33:59 <ph8> map (..) . not . filter(..) ?
07:34:07 <ph8> hmm no i suppose that's wrong
07:34:11 <quicksilver> think about what that means
07:34:15 <EvilTerran> kmb, how slick are you with haskell? do you understand how IO works?
07:34:26 <quicksilver> the 'output' of filter (on the left) is a list
07:34:31 <quicksilver> what does it mean to 'not' a list? :)
07:34:31 <ph8> filter (\x -> x>=3 && x<= 10) [1..10]
07:34:32 <int-e> ph8: did you mean filter (not . ..)?
07:34:33 <ph8> is what i have
07:34:47 <ph8> filter (\x -> not (x>=3 && x<= 10)) [1..10]
07:34:49 <ph8> does that work?
07:34:55 <int-e> it should
07:34:56 <quicksilver> why don't you try it?
07:34:58 <ph8> brillo :-)
07:35:00 <ph8> shall do
07:35:00 <kmb> EvilTerran, I understand it I believe.  why?
07:35:05 <quicksilver> > filter (\x -> not (x>=3 && x<= 10)) [1..10]
07:35:07 <lambdabot>  [1,2]
07:35:07 <fasta> > filter (\x -> not (x>=3 && x<= 10)) [1..10]
07:35:07 <int-e> and that's x < 3 || x > 10
07:35:08 <lambdabot>  [1,2]
07:35:12 <ph8> mega :-)
07:36:05 <EvilTerran> kmb, so you see that it's necessary for a function to return something of type (IO a) if it can return different values between calls?
07:36:35 <EvilTerran> kmb: ... this being why the random functions which don't take a seed are all in IO
07:37:22 <chessguy> hi haskellers
07:37:46 <EvilTerran> kmb, however, if you're writing a complete program (as compared to just fragments), you'll be working in IO anyway
07:37:53 <EvilTerran> so you could do something like
07:38:03 <ph8> oh god
07:38:08 <ph8> now it wants me to rewrite it using list comp
07:38:12 <seafood> It might be a little strange for me to ask this on this channel, but where would I go to learn about Javascript?
07:38:29 <blackdog> seafood: that's totally inappropriate. you should be ashamed of yourself.
07:38:30 <seafood> I'm looking for sources that aren't aiming at complete doofuses.
07:38:36 <seafood> blackdog: Hi
07:38:39 <blackdog> :)
07:38:47 <ph8> [ (*3) x | \x -> (x>=3 && x<=10) | x <- xs ]
07:38:52 <ph8> how do i make the bot exec things?
07:38:54 <ph8> > [ (*3) x | \x -> (x>=3 && x<=10) | x <- xs ]
07:38:54 <lambdabot>  Parse error
07:38:56 <ph8> gah
07:38:58 <blackdog> but, uh, if anyone knows, i'd like to know too please :)
07:39:02 <ph8> oh whoops
07:39:05 <ph8> > [ (*3) x | \x -> (x>=3 && x<=10) | x <- [1..10] ]
07:39:06 <lambdabot>  Parse error
07:39:09 <desp> seafood: just a wild guess... ##javascript? ;p
07:39:16 <LoganCapaldo> ph8: just one |
07:39:28 <LoganCapaldo> comma instead for the second one
07:39:29 <seafood> desp: I'm checking that now :)
07:39:30 <blackdog> ah, but he wants one aimed at genius-level haskell programmers :)
07:39:31 <ph8> you're only allowed one? or this only needs one?
07:39:34 <ph8> > [ (*3) x | \x -> (x>=3 && x<=10), x <- [1..10] ]
07:39:34 <LoganCapaldo> and the generator comes firs
07:39:34 <lambdabot>      The lambda expression `\ x -> ...' has one argument,
07:39:34 <lambdabot>     but its type `B...
07:39:40 <ph8> :o
07:39:41 <desp> blackdog: :)
07:39:53 <LoganCapaldo> and the guard isn't a lambda expression
07:40:03 <ph8> > [ (*3) x | (x>=3 && x<=10), x <- [1..10] ]
07:40:04 <lambdabot>   Not in scope: `x'
07:40:08 <ph8> i'll take this to hugs :p
07:40:21 <LoganCapaldo> > [ x * 3 | x <- [1..10], (x >= 3 && x <= 10) ]
07:40:22 <lambdabot>  [9,12,15,18,21,24,27,30]
07:41:00 <ph8> ahh
07:41:01 <ph8> thx
07:41:23 <EvilTerran> main = do rs <- liftM randoms getStdGen :: IO [Int]; <rest of your code here> and then work with that
07:42:03 <DRMacIver> How well (if at all) does the FFI work with C++ instead of C?
07:42:11 <LoganCapaldo> > [ (x, y) | x <- [1..10] | y <- [1..10] ] -- this isn't standard
07:42:11 <lambdabot>  Parse error
07:42:28 <LoganCapaldo> and lambdabot doesn't do it apparently anyway
07:43:27 <DRMacIver> seafood: The O'Reilly javascript book is good.
07:43:41 <quicksilver> DRMacIver: via C
07:43:48 <quicksilver> DRMacIver: fortunately, C++ is used to interfacing with C
07:43:50 <int-e> DRMacIver: you write your C++ code like you would for interfacing C. I.e. use extern "C" stuff.
07:43:51 <seafood> DRMacIver: Thanks :)
07:44:04 <DRMacIver> quicksilver, int-e: Ok. :) Thanks.
07:45:15 <ph8> ?t foldr
07:45:15 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
07:45:20 <ph8> errrm
07:45:22 <ph8> :type foldr
07:45:26 <ph8> :t foldr
07:45:28 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:45:31 <ph8> there we go
07:45:40 <fasta> :( The spammers found my "spam-free" e-mail address.
07:46:10 <ph8> fasta: i'm using a bayesspam filter - it's awesome
07:46:11 <fasta> Now they force me to get a good e-mail setup, which isn't trivial last time I checked.
07:46:18 <ph8> i've trained it on about 400 messages and it's virtually flawless
07:46:26 <ph8> squirrelmail with a bayesspam plugin all the way :)
07:46:52 <fasta> ph8: All the messages are already flagged ***SPAM**** in the subject header.
07:47:03 <ph8> my plugin just moves them to the spam folder
07:47:05 <ph8> automagically
07:47:17 <DRMacIver> Flawless spam filters are dangerous, because you get out of the habit of checking your spam folder. </bitter>
07:47:28 <ph8> it's foldr <function to perform on consecutive elements> <function to perform when [] is encountered> <list> right?
07:47:33 <fasta> ph8: the problem is that the filtering software in all graphical e-mail clients is broken.
07:47:41 <sjanssen> ph8: right
07:47:44 <ph8> server-side bayesspam :)
07:47:46 <ph8> thanks sjanssen
07:48:07 <fasta> You are all using Mutt or something like that?
07:48:18 <sjanssen> ph8: I remember it as: foldr ((:) replacer) ([] replacer) input
07:48:43 <DRMacIver> ph8: Not quite. It's foldr <function> <value to use when [] is encountered> <list>
07:50:10 <ph8> as i say fasta, i'm using squirrelmail
07:50:12 <ph8> it's got some good plugins
07:50:31 <ph8> although if i ever find a half decent client i might change, now i'm imap'ed up
07:51:08 <ph8> does foldl start at the end of a list (left assoc.) whereas foldr starts at the beginning (right assoc.)?
07:51:18 <ph8> or does fold start at the beginning in a left - assoc manner?
07:51:20 <ph8> * foldl
07:51:24 <fasta> ph8: but that requires your machine to be always on, right?
07:52:16 <quicksilver> ph8: it's very hard to make statements like 'starts at the beginning' precise :)
07:52:18 <sjanssen> ph8: well, the actual implementation of foldl starts at the beginning
07:52:29 <quicksilver> ph8: foldr right-associates and foldl left-associates, yes
07:52:30 <ph8> fasta: i have a mail/web server
07:52:40 <ph8> you could install it yourself on a web hosting account
07:52:48 <ph8> hmm
07:52:58 <quicksilver> ph8: there is a sense in which foldr 'starts at the right' but despite that it works on infinite lists which have no right end
07:52:58 <ph8> the question on the paper is, why is foldl better for list reversals than foldr?
07:52:59 <sjanssen> you can say that in foldl the head of the list is in the most nested application, and foldr the head is in the least nested application
07:53:03 <ph8> i know it is, but i'm struggling to express why
07:53:24 <quicksilver> ph8: is your paper about haskell? or is it about a strict language?
07:53:32 <ph8> yep haskell
07:53:55 <sjanssen> ph8: have you written down definitions for both?
07:54:00 <ph8> the hint is "considering the example foldl (\xs x -> x xs)
07:54:06 <ph8> yup
07:54:16 <ph8> foldr was last question and it gives me the foldl type here
07:54:17 <sjanssen> presumably it means (x:xs)?
07:54:21 <ph8> sorry yes
07:54:25 <sjanssen> okay
07:54:34 <sjanssen> use classic algorithm analysis
07:54:44 <sjanssen> you know that the inner function will run O(n) times
07:54:53 <sjanssen> (x:xs) is O(1)
07:55:00 <ph8> yup
07:55:01 <sjanssen> so the foldl version is O(n)
07:55:32 <sjanssen> foldr (\x xs -> xs ++ [x]) [] -- here's our foldr version
07:56:06 <ph8> how come you can't use xs : x?
07:56:20 <sjanssen> we know that (++) is O(length xs), but the length of xs isn't static here
07:56:53 <ph8> O(n^2) then?
07:56:59 <sjanssen> right
07:57:00 <int-e> > foldr (foldr (:) . (:[])) [] [1..3]
07:57:01 <lambdabot>  [3,2,1]
07:57:15 <sjanssen> because it's O(n) for the first ++ executed, O(n-1), ...
07:57:37 <sjanssen> ph8: xs : x means a different thing
07:58:23 <ph8> they both would add x onto the end of xs no?
07:58:39 <sjanssen> it produces a list where xs is the first element, and x is the rest of the elements (ie. xs : x means 'x' must be a list)
07:58:46 <ph8> ah i see
07:58:51 <ph8> so the list wouldn't be formatted properly
07:58:58 <sjanssen> well, it wouldn't type check either
07:59:01 <hhg> ph8: it's similar to cons in lisp
07:59:01 <quicksilver> :t ([1,2,3]:)
07:59:04 <lambdabot> forall t. (Num t) => [[t]] -> [[t]]
07:59:15 <quicksilver> note the [[ <---- two sets of brackets
07:59:30 <quicksilver> haskell deduces 'if [1,2,3] is an *element* then this is a *list* of *lists*
08:01:41 <fasta> ph8: there are data structures that support that operation, a list isn't one.
08:05:00 <int-e> @type (Data.Sequence.|>)
08:05:02 <lambdabot> forall a. Data.Sequence.Seq a -> a -> Data.Sequence.Seq a
08:07:23 <kolmodin> shapr: no :/
08:09:04 <int-e> > Data.Foldable.toList (foldr (flip (Data.Sequence.|>)) Data.Sequence.empty [1..3])
08:09:05 <lambdabot>  [3,2,1]
08:11:24 * jfredett wishes Avidyne would get back to him...
08:11:36 * jfredett needs a job to support his crystal math habit...
08:14:01 <opqdonut> :)
08:14:07 <roconnor> cons isn't a symetric operation, and shouldn't use a symetric symbol.
08:14:30 <jfredett> what then would you prefer for a cons symbol?
08:14:33 <quicksilver> roconnor: choose a better font, then, in which : isn't symettric :)
08:14:38 <jfredett> i rather like :
08:15:02 <jfredett> i like to think of it as the straight part in the links of a chain
08:15:18 <jfredett> the elements of the list are the curvybits
08:15:26 <jfredett> ayup
08:17:40 <roconnor> off the top of my head I'd use a triangle of some sort
08:17:57 <roconnor> but I'm open to suggestions
08:18:19 <roconnor> @google mathematical operators unicode
08:18:21 <lambdabot> http://en.wikipedia.org/wiki/Unicode_Mathematical_Operators
08:18:21 <lambdabot> Title: Unicode Mathematical Operators - Wikipedia, the free encyclopedia
08:18:53 <quicksilver> '-' is after all not symmetric
08:18:58 <quicksilver> so there is plenty of precedent
08:19:07 <quicksilver> I think ':' is now well-enough known to enough people to stick
08:19:10 <quicksilver> I agree in principle though
08:20:04 <roconnor> quicksilver: - is unary; the + is often omitted.
08:20:07 <roconnor> :)
08:23:03 <shapr> Dang I missed seafood
08:23:07 <shapr> Haven't seen him around here in a long time.
08:23:17 <shapr> blackdog: Hiya! Long time no see! What's up?
08:23:41 <quicksilver> roconnor: nice idea. Not true, though. :P
08:23:43 <sjanssen> @users
08:23:44 <lambdabot> Maximum users seen in #haskell: 340, currently: 322 (94.7%), active: 42 (13.0%)
08:23:47 <quicksilver> :t (-)
08:23:50 <lambdabot> forall a. (Num a) => a -> a -> a
08:24:37 <roconnor> quicksilver: how do you know it isn't true?
08:24:51 <DRMacIver> :t -1
08:24:52 <lambdabot> forall a. (Num a) => a
08:25:02 <DRMacIver> :t - 1
08:25:03 <lambdabot> forall a. (Num a) => a
08:25:07 <roconnor> sure, so haskell is broeken ;)
08:25:10 <roconnor> er
08:25:12 <roconnor> broken
08:25:14 <quicksilver> roconnor: because, look at the type of (-)
08:25:17 <DRMacIver> Yes. :)
08:25:21 <quicksilver> roconnor: ah, well I'm talking about haskell
08:25:34 <roconnor> quicksilver: since they got cons wrong, we shouldn't be surpried they got - wrong too ;)
08:25:59 <MyCatVerbs> roconnor: - is deliberately wrong for a good reason.
08:26:12 <quicksilver> however, in many fields (-) is definitely binary
08:26:16 <roconnor> MyCatVerbs: what's the reason?
08:26:23 <quicksilver> for example (-) :: Time -> Time -> Interval
08:26:25 <MyCatVerbs> roconnor: what's the problem with cons? Right-associative infix operator, seems fine to me.
08:26:26 <quicksilver> is inherently binary
08:26:37 <quicksilver> you can't unroll that with the unary trick
08:26:47 <roconnor> quicksilver: that's not a field ... that's an affine space.
08:26:58 <quicksilver> roconnor: 'field' meaning 'area of endeavour or study'
08:27:09 <roconnor> *L* I've done too much math
08:27:31 <MyCatVerbs> roconnor: the fact that it's deliberately broken in order to allow both "x-5" to represent "(-) x 5" and "(-5)" to represent (0-5)
08:27:52 * quicksilver nods
08:27:56 <quicksilver> which I regret, personally
08:28:03 <quicksilver> I'd rather have to write 'negate' in full
08:28:06 <quicksilver> and have working sections
08:28:09 <MyCatVerbs> roconnor: whereas, jah, the slightly less newbie friendly but kinda preferrable way to do it would've been to steal from ML's book.
08:28:16 <MyCatVerbs> And have a seperate unary symbol (
08:28:30 * shapr boings cheerfully
08:28:32 <MyCatVerbs> And have a seperate unary symbol ("~" in ML's case) for negation.
08:28:43 <MyCatVerbs> (Also, fuck you too, enter key.)
08:29:35 <roconnor> I want a layer of indirection between my choice of notation and the haskell code.
08:29:45 <roconnor> that way everyone can have their own notation!
08:29:48 <roconnor> :)
08:30:34 <edwardk> roconnor: its called 'haskell', feel free to replace it and generate core as output ;)
08:31:01 <roconnor> edwardk: not a bad idea, but core is a little bit too far down I think.
08:31:21 <roconnor> Are type classes already dictionaries by then?
08:31:47 <edwardk> ah yeah
08:31:57 <edwardk> ok, then feel free to replace it and generate haskell as output ;)
08:31:57 <roconnor> But I could take Haskell as the core perhaps.
08:32:01 <roconnor> :)
08:32:25 <roconnor> maybe I should do that.
08:32:38 <edwardk> $(compile "mylanguage.foo")
08:33:37 <roconnor> well it is more than that.  A notation should provide an isomorphism between haskell and your document.
08:34:28 <roconnor> or at least under some reasonable equivalence relations
08:36:20 <Cale> Whoa, that's odd. Refreshing reddit repeatedly, I can see 3 different versions of my comment, and sometimes I get a 404. :)
08:36:52 <shapr> Which comment?
08:37:26 <Cale> http://programming.reddit.com/info/1ubf9/comments/c1udep
08:37:27 <lambdabot> Title: Why "Zipwith" is a terrible abstraction (and how to fix it) (reddit.com)
08:37:48 <quicksilver> wow, a Cale!
08:37:59 <quicksilver> they seem to have been a rare phenomenon these weeks
08:38:26 <Cale> Yeah, I haven't been on IRC much the last couple weeks, as my friend from Australia was staying over.
08:39:15 <quicksilver> ah, friends
08:39:22 <quicksilver> good for you, bad for IRC!
08:39:26 <Cale> hehe
08:39:47 <quicksilver> the underlying issue in that article, it seems to me, is that obfuscation is in the eye of the beholder
08:39:50 <quicksilver> we give stuff names
08:39:55 <Cale> indeed
08:39:57 <quicksilver> if other people know those names, that's good communication
08:40:05 <quicksilver> if other people don't know those names, it's poor communication
08:40:16 <quicksilver> sometimes the names save us time and/or help us see more clearly
08:40:32 <chessguy> Cale!
08:40:36 <Cale> hello :)
08:40:43 <chessguy> welcome back!
08:40:43 <quicksilver> to my mind, zipWith is perfectly clear, even elegant
08:40:45 <sjanssen> bah, 'broadside'?
08:40:50 <quicksilver> that's cos I know what it does
08:41:11 * quicksilver tacks against the wind and broadside's sjanssen with 38 cannon
08:41:17 <roconnor> "Why 'Zipwith' is a terrible abstraction (and how to fix it)" is a terrible title and should be fixed by calling it "Why 'Zipwith' is a terrible name (and how to fix it)".
08:41:33 <sjanssen> quicksilver: *exactly*.  It makes you think of naval battles
08:41:34 <edwardk> one does have to admit that haskell gives constructs inordinately short names for a lot of things. mapM_ foldl' ...they can be a little offputting
08:41:52 <quicksilver> "Why 'Why 'ZipWith' is a terrible abstraction (and how to fix it)' is a terrible title (and how to fix it)'
08:41:58 <sjanssen> you can certainly make better arguments against mapM_ and foldl'
08:42:10 <Cale> Would you really be willing to use mapM_ at all if it had many more characters?
08:42:16 <quicksilver> edwardk: absolutely
08:42:29 <quicksilver> edwardk: and then when you know what they mean, it's concise and elegant
08:42:32 <roconnor> god forbid people having to learn a new language when learning a new language.
08:42:36 <Cale> After all, most of the time, you can use mapM just as well.
08:42:50 <sjanssen> @remember roconnor god forbid people having to learn a new language when learning a new language.
08:42:50 <lambdabot> Done.
08:43:01 <sjanssen> Cale: you should use mapM_ when you mean it
08:43:08 <sjanssen> no sense rationing _'s
08:43:40 <Cale> But if it was called mapWithoutResultsM or something, you'd surely hesitate :)
08:43:50 <quicksilver> sjanssen: well with a bit of lazy evaluation and a bit of compiler fu, I doubt it matters much
08:43:52 <emu> mapWithoutResultsInAMonad
08:44:05 <kaol> unsafePerformMap
08:44:15 <sjanssen> quicksilver: I'm not quite comfortable with that transformation
08:44:19 <edwardk> the M suffix is also somewhat arbitrarily thrown in, its liftM, but ap, not apM, join, not joinM, etc. we tack an f onto map for functors, when map, fmap, and liftM are all basically the same, etc. there is a bit of random detritus in there.
08:44:26 <sjanssen> eg. in the IO monad
08:44:38 <quicksilver> mapDiscardingResultsAlthoughOpenParenthesisOfCourseCloseParenthesisNotDiscardingSideEffectsWhichStillOccurOverAMonad
08:44:51 <roconnor> Hey we should have an infix function called _ defined as (_) f = f >> return ()
08:45:12 <quicksilver> roconnor: we can't, because that's not lexically valid
08:45:17 <quicksilver> roconnor: however, we do need that function
08:45:17 <roconnor> :)
08:45:19 <sjanssen> roconnor: that is, by definition, a no-op
08:45:24 <quicksilver> some people call it 'void'
08:45:37 <quicksilver> sjanssen: no it's not it's DiscardReturnValueButNotSideEffectsInAMonad
08:45:38 <roconnor> that isn't a noop!
08:45:53 <quicksilver> 'void' is a poor name, though :)
08:45:58 <EvilTerran> f `silent` x = (f x) >> return ()
08:45:59 <EvilTerran> ?
08:46:03 <quicksilver> but obviously it's intuitive to C(++) people
08:46:04 <EvilTerran> (or void)
08:46:32 <pjd> how about __
08:46:35 <EvilTerran> then it'd be map `void` ...
08:46:47 <shmooz> who here has a problem with dibblego , I'd like to know
08:46:53 <edwardk> evilterran: nah, it should be prefix applied to the function/value, because you may want to forget the output of a value as well.
08:47:01 <EvilTerran> true
08:47:15 <roconnor> oh right (_) = fmap (const ())
08:47:35 <EvilTerran> and you could still use it infix, if the left parameter was a fn...
08:47:55 <EvilTerran> (altho that would probaby be gratuitous)
08:49:05 <Cale> shmooz: hmm?
08:50:57 <shmooz> I think he's a snobby arrogant stubborn tard, on some high horse thinking he can go around insulting people and change meanings of terms of the English language
08:51:22 <shmooz> anyway , forget my problem, I want to know how many other think that way about him
08:51:47 <shmooz> probably noone here cause he loves haskell
08:52:00 <shmooz> but when he comes into our java channel he insults everyone
08:53:17 <Cale> Huh, he is a bit strange, but I don't recall him being insulting. Then again, I've been away for 2 weeks.
08:53:28 <desp> is there someone working with Jabber/XMPP in Haskell?
08:53:35 <sjanssen> shmooz: I don't believe we've had a problem with dibblego
08:53:48 <sjanssen> shmooz: no offense, but this sounds like #java business
08:54:11 <desp> I found <http://www.dtek.chalmers.se/~henoch/text/hsxmpp.html>, but the version number (0.0.1) doesn't inspire much confidence :)
08:54:24 <shmooz> no its dibblego, not java ;)
08:54:48 <MarcWeber> @tell dmhouse you were right. I did copy the wrong imports. I didn't notice it :( Thanks.
08:54:48 <roconnor> desp: hey cool
08:54:48 <lambdabot> Consider it noted.
08:55:00 <shmooz> he may be right about some things but he doesn't know how to communicate them without offending people
08:55:32 <roconnor> @seen dibblego
08:55:32 <lambdabot> dibblego is in #happs, #haskell and #jtiger. I last heard dibblego speak 9h 9m 13s ago.
08:55:40 <MarcWeber> ToRA: note my note for dmhouse..
08:55:43 <desp> roconnor: hm?
08:56:04 <roconnor> desp: I'm surpries that there is even an XMPP client in Haskell
08:56:08 <roconnor> surprised
08:56:14 <desp> ah
08:56:45 <roconnor> desp: you should fork it and develop it further
08:57:00 <roconnor> let's see if darcs really does work
09:00:19 <fasta> roconnor: why would you use darcs when you can get corrupt repositories?
09:01:54 <roconnor> fasta: I'm not sure how to properly parse that.  Are you saying darcs generates corrupt repositories or that it is missing that feature?
09:02:32 <fasta> roconnor: I am saying that via some sequence of operations darcs creates corrupt repositories.
09:02:44 <roconnor> :(
09:02:44 <fasta> roconnor: until that is fixed I wouldn't use it.
09:03:16 <fasta> roconnor: Check the darcs bugs. There are lots of them.
09:03:16 <roconnor> is this on the darcs wiki?
09:03:41 <roconnor> fasta: what do you use?
09:04:03 <fasta> roconnor: I used darcs, but I backup everything when I make a large change.
09:04:14 <fasta> roconnor: I haven't had time to change.
09:04:39 <fasta> roconnor: A real versioning system needs to be trusted. I don't trust Darcs.
09:04:57 * Igloo isn't aware of any corruption bugs - this sounds like FUD to me
09:05:11 <SamB> Igloo: hmm?
09:05:16 <SamB> darcs has corruption bugs for sure!
09:05:23 <ph8> hmmm, what does Ord a => [a] -> a mean?
09:05:26 <SamB> unless they fixed them somehow
09:05:29 <ph8> is it saying it takes a list of Ords?
09:05:30 <Igloo> SamB: Got an example?
09:05:36 <ph8> and what is an Ord?
09:05:42 <SamB> the trouble is that they are intermittent
09:05:43 <allbery_b> Ord is a typeclass
09:05:45 <roconnor> @info Ord
09:05:45 <lambdabot> Ord
09:05:47 <ph8> the guy who teaches this seems to assumed it's implied
09:05:47 <int-e> ph8: it is saying that whatever a is, you can compare these things
09:05:51 <Igloo> ph8: It has type [a] -> a, where a is in the Ord class
09:05:53 <roconnor> great, thanks lambdabot
09:05:56 <SamB> or, at least, in practice they are
09:05:59 <int-e> ph8: Ord is a type class that provides  compare
09:06:01 <ph8> what does Ord stand for?
09:06:03 <int-e> @type compare
09:06:03 <roconnor> @src Ord
09:06:03 <ph8> ah ok
09:06:07 <int-e> ph8: Ordering
09:06:07 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:06:07 <lambdabot> class  (Eq a) => Ord a  where
09:06:07 <lambdabot>     compare      :: a -> a -> Ordering
09:06:08 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:06:08 <lambdabot>     max, min         :: a -> a -> a
09:06:09 <Igloo> Ordering
09:06:16 <ph8> nice
09:06:18 <ph8> @src Eq
09:06:18 <lambdabot> class  Eq a  where
09:06:18 <lambdabot>     (==), (/=)   :: a -> a -> Bool
09:06:19 <fasta> What's monadic concatMap?
09:06:31 <ph8> so, if i was submitting input to that function
09:06:32 <int-e> fasta: >>= ?
09:06:37 <ph8> it would have to be a data type that derives Ord?
09:06:40 <SamB> Igloo: they seem to pop up a lot when you use --partial
09:06:45 <ph8> or do int etc automagically do that?
09:06:57 <byorgey> ph8: yes, and yes =)
09:07:11 <Igloo> SamB: Some operations fail with partial repositories, but that is very much not a case of corruption
09:07:14 <SamB> of course, maybe they've fixed most or all of it, I couldn't tell
09:07:19 <byorgey> ph8: lots of built-in data types already implement Ord, like Int, Char, and so on
09:07:29 <SamB> Igloo: well I've seen corruption in the past
09:07:51 <byorgey> ph8: technically I should say "are instances of Ord"
09:08:09 <quicksilver> ph8: it doesn't have to *derive* ord
09:08:17 <quicksilver> ph8: it could derive Ord, or it could implement it
09:08:33 <quicksilver> ph8: deriving refers specifically to a way to make the compiler do the work for you
09:08:59 <ph8> ah
09:09:03 <ph8> i don't think we've covered implementing Ord
09:09:12 <ph8> which is fine by me at this point :)
09:09:30 <chessguy> @src Ord
09:09:30 <lambdabot> class  (Eq a) => Ord a  where
09:09:30 <lambdabot>     compare      :: a -> a -> Ordering
09:09:30 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:09:30 <lambdabot>     max, min         :: a -> a -> a
09:09:33 <ph8> so
09:09:40 <ph8> using the type sig from above
09:09:41 <chessguy> just means you have to define those functions
09:09:43 <ph8> Ord a => [a] -> a
09:09:48 <ph8> if i wanted a 'max' function
09:09:52 <ph8> max :: Ord a => [a] -> a
09:09:52 <int-e> @type minimum
09:09:55 <lambdabot> forall a. (Ord a) => [a] -> a
09:10:02 <DRMacIver> > minimum []
09:10:04 <lambdabot>  Exception: Prelude.minimum: empty list
09:10:07 <roconnor> chessguy: you only need to define compare if you want.
09:10:10 <quicksilver> ph8: if you want max, you're surely going to need '>'
09:10:12 <ph8> @sec maximum
09:10:12 <lambdabot> maximum [] = undefined
09:10:12 <lambdabot> maximum xs = foldl1 max xs
09:10:16 <ph8> @sec max
09:10:17 <lambdabot> max x y = if x <= y then y else x
09:10:21 <quicksilver> ph8: if you need '>' you need Ord
09:10:24 <ph8> yes, which ord provides right
09:10:29 <quicksilver> ph8: just like if you need '==' you need Eq
09:10:37 <ph8> i'm just wondering how to define the function
09:10:40 <roconnor> quicksilver: that's not true.  I have max for my real numbers without having '>' as such.
09:10:54 <quicksilver> roconnor: indeed, and I'm being slightly approximate :P
09:10:56 <chessguy> roconnor: well, yeah. i guess i should say those functions have to be defined, whether they are by default or not
09:11:02 <quicksilver> roconnor: my comments, however, are helpful to ph8 I believe
09:11:10 <ph8> max (x:xs) = | x > (max xs) = true
09:11:12 <roconnor> quicksilver: ah okay
09:11:13 <ph8> | otherwise = false
09:11:13 <ph8> ?
09:11:25 <ph8> erm
09:11:27 <ph8> not quite right even
09:11:33 <ph8> true should be x
09:11:36 <ph8> otherwise should be max xs
09:11:45 <ph8> sound right?
09:11:47 <chessguy> you don't want max to return a boolean
09:11:55 <chessguy> do you?
09:12:00 <int-e> ph8: yes. but what's the base case? :)
09:12:16 <ph8> :-)
09:12:19 <ph8> good should
09:12:20 <ph8> * shout
09:12:21 <int-e> ph8: and there's a = too much in that.
09:12:32 <ph8> between ) |
09:12:35 <ph8> got it
09:12:58 <ph8> we were told we can assume the input is never empty :))
09:13:08 <ph8> :t .
09:13:10 <lambdabot> parse error on input `.'
09:13:12 <ph8> hmm
09:13:13 <ph8> :type .
09:13:19 <ph8> :type (.)
09:13:22 <ph8> :t (.)
09:13:24 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:14:01 <mdmkolbe|work> how do I debug shift/reduce conflicts in happy? I can't find any flags to help with that in the manual
09:14:38 <roconnor> @type shift
09:14:40 <lambdabot> forall a. (Bits a) => a -> Int -> a
09:14:45 <roconnor> boo
09:14:47 <roconnor> @hoogle shift
09:14:48 <lambdabot> Data.Bits.shift :: Bits a => a -> Int -> a
09:14:48 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
09:14:48 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
09:14:52 <roconnor> boo
09:14:56 <roconnor> @hoogle reduce
09:14:56 <lambdabot> No matches found
09:15:04 <roconnor> :/
09:15:15 <mdmkolbe|work> roconnor: in 'happy' the LR parser for Haskell
09:15:20 <hpaste>  Brent pasted "takeUntilRep -- a more elegant way?" at http://hpaste.org/100
09:15:42 <byorgey> can anyone take a look at the function I just pasted and see if there's a more elegant way to implement it?
09:15:43 <mdmkolbe|work> roconnor: see also yacc and LR parse theory for the meaning of 'shift'/'reduce'
09:15:57 <byorgey> it works, but it feels like there should be a better way...
09:16:05 <roconnor> mdmkolbe|work: is it the same as for continuations?
09:16:28 <pitecus> Isn't that sentence garbled?: "No instance for (Ord (Feature String Double)) arising from is bound by the instance declaration at"
09:18:17 <mdmkolbe|work> roconnor: no.  Shift means that the FSM will push to the stack and reduce means it will pop several from the stack and push one on the stack while construting a parse tree element.  If you have a shift/reduce conflict it means the FSM can't determine whether it should shift or reduce b/c they might both lead to a valid parse (i.e. the grammar is ambiguous (which might happen even if the language isn't ambig))
09:18:35 <mdmkolbe|work> @pl (map snd . takeWhile (uncurry (/=)) $ zip ls (tail ls))
09:18:35 <lambdabot> map snd (takeWhile (uncurry (/=)) (zip ls (tail ls)))
09:18:46 <hpaste>  quicksilver annotated "takeUntilRep -- a more elegant way?" with "(no title)" at http://hpaste.org/100#a1
09:19:02 <roconnor> mdmkolbe|work: Ah, thanks
09:19:26 <roconnor> Does shift/reduce mean anything in the context of continuations, or am I just wrong?
09:19:48 <Saizan>  roconnor shift/reset
09:19:54 <byorgey> quicksilver: hm, I guess the explicitly recursive version is more elegant.
09:20:06 <roconnor> ah, shift reset
09:20:19 <mdmkolbe|work> roconnor: shift/reset and ???/control (I can't remember the fourth)
09:20:29 <byorgey> quicksilver: I suppose I'm going through the "explicit recursion is bad, use HOFs!" phase which I guess everyone learning Haskell probably goes through =)
09:20:31 <roconnor> no wonder I couldn't find it.
09:20:47 <roconnor> byorgey: I'm starting to go through that phase too.
09:20:56 <quicksilver> byorgey: nod
09:21:11 <roconnor> byorgey: I was inspired by SPJ's talk about dons et. al.'s work.
09:21:28 <byorgey> roconnor: which talk was that?
09:21:37 <roconnor> HOF allows rewrite rules to active.
09:21:40 <quicksilver> byorgey: you could for example get rid of the explicit call to 'head' and 'tail' though
09:21:53 <quicksilver> byorgey: just use pattern matching on (l:ls)
09:21:57 <byorgey> quicksilver: good point.
09:21:59 <quicksilver> byorgey: that would already look a bit nicer
09:22:56 <roconnor> byorgey: http://video.google.co.uk/videoplay?docid=370317485066035666&hl=en-GB
09:22:59 <lambdabot> Title: Nested Data Parallelism in Haskell - Google Video, http://tinyurl.com/2e7u76
09:23:33 <byorgey> roconnor: oh, ok, that one.  I watched half of that but haven't finished yet.
09:23:48 <byorgey> roconnor: I didn't know dons was involved.
09:23:50 <ph8> "explain what the composition of maximum . map length will do when applied to appropriate input"
09:23:53 <roconnor> byorgey: yeah, it's the last bit where he talks about the stream rewriting
09:23:59 <ph8> it'll find the maximum of the lengths of each input item right?
09:24:00 <roconnor> I was more excited about that.
09:24:16 <byorgey> roconnor: ok, well I'll be sure to go back and finish watching it, then!
09:24:16 <DRMacIver> ph8: Yes
09:24:18 <ph8> i think the key is in explain what their composition will do
09:24:20 <ph8> is that something clever?
09:24:24 <fasta> ph8: how difficult must the answer be?
09:24:27 <ph8> 4 marks
09:24:51 <ph8> 4% of the paper
09:24:53 <ph8> 2 hrs
09:24:58 <ph8> (2 hr paper total :p)
09:25:12 <ph8> worth 60% of the course, so 60 * 0.04 of a module of my degree
09:25:13 <fasta> ph8: then that's probably the correct answer
09:25:18 <ph8> hmm, seemed a bit easy
09:25:20 <ph8> cheers :)
09:25:24 <ph8> so is . the same as $ ?
09:25:25 <byorgey> ph8: composition just means you first do one, then the other.  that is, (f . g) x == f (g x)
09:25:31 <mdmkolbe|work> @type (.)
09:25:33 <roconnor> byorgey: I didn't know how's dons's stream fusion worked, and now I do.
09:25:34 <mdmkolbe|work> @type ($)
09:25:35 <ph8> or does $ imply there's input being 'passed back'
09:25:38 <fasta> ph8: not in my universe
09:25:40 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:25:40 <ph8> :type (.)
09:25:42 <lambdabot> forall a b. (a -> b) -> a -> b
09:25:44 <ph8> oh it's just slow
09:25:44 <roconnor> I can't believe it wasn't done before.
09:25:46 <ph8> hmm
09:25:49 <roconnor> it is soooo nice.
09:26:10 <byorgey> roconnor: nifty.  I know what stream fusion is in a vague hand-wavy sort of sense but not any details.
09:26:20 <quicksilver> ph8: there are places where you can replace . with $
09:26:26 <quicksilver> ph8: but this is a non-trivial trick
09:26:33 <byorgey> roconnor: ahh, so much to learn about and so little time! =)
09:26:35 <mdmkolbe|work> ph8: $ is function application pure and simple (but right assoc instead of the standard left assoc), but (.) is function composition
09:26:36 <quicksilver> ph8: it's because at the same time, you change the associativity
09:26:42 <ph8> ah
09:26:43 <ph8> cheers
09:26:50 <mdmkolbe|work> @src (.)
09:26:51 <lambdabot> (.) f g x = f (g x)
09:26:53 <mdmkolbe|work> @src ($)
09:26:53 <lambdabot> f $ x = f x
09:27:00 <quicksilver> f . g . h $ x = f $ g $ h $ x
09:27:13 <quicksilver> but the associativity differs which is why it's a bit clever
09:27:18 <ph8> but f g $ f x != f $ g $ f $ x?
09:27:31 <ph8> but rather f g f x
09:27:39 <quicksilver> rather f g (f x)
09:27:46 <ph8> cool, je comprends
09:27:53 <roconnor> byorgey: I love learning new functional programming techniques.
09:28:01 <mdmkolbe|work> ph8 think of $ as a left paren that auto-closes
09:28:35 <fasta> roconnor: remember the issue we discussed about complexity and FP? Turner agrees with you.
09:28:38 <roconnor> There are some really sophisicated and cool ways of writing programms in Haskell, but it takes a long time to learn how to do them.
09:28:41 <byorgey> roconnor: me too.  ATM I'm learning about arrows...
09:28:46 <mdmkolbe|work> f g $ f x = f g (f x), f $ g $ h $ x = f (g (h (x)))
09:28:57 <ph8> hmm - "determine the type of show . maximum . map length"... Show a => a -> [a] -> Show a ?
09:29:01 <roconnor> fasta: oh nice, what was I claiming?
09:29:05 <ph8> or do i need to somehow insert the map definition?
09:29:19 <ph8> i suppose i do
09:29:50 <fasta> roconnor: you thought that every algorithm that runs in O(f(n)) in C can be implemented to run in amortized O(f(n)) in a functional programming language.
09:30:08 <Cale> In my opinion, $ has the wrong associativity. It should have been left associative like function application normally is.
09:30:16 <quicksilver> I agree with Cale
09:30:18 <Saizan> ph8, think of the input type of (map length) and the output type of show
09:30:21 <roconnor> I think there are some good techniques to solve Joel Reymont's problems, but they are non trivial.
09:30:21 <byorgey> ph8: think of show . maximum . map length as a pipeline -- things go in the right end and come out the left
09:30:36 <byorgey> ph8: hence, what Saizan said =)
09:30:45 <EvilTerran> ph8, what types are (show), (maximum), and (map length)?
09:30:46 <DRMacIver> Cale: You could always define $$ to be $ with left associativity and use that. :)
09:30:54 <ph8> a -> Show a, presumably
09:31:09 <Saizan> ?type show
09:31:11 <lambdabot> forall a. (Show a) => a -> String
09:31:19 <ph8> ah.
09:31:38 <byorgey> ph8: i.e. anything that is "showable" can be turned into a String by the show function
09:31:44 <ph8> ?type maximum
09:31:46 <lambdabot> forall a. (Ord a) => [a] -> a
09:32:06 <ph8> and map is (a->b) -> a -> a
09:32:07 <ph8> ?type map
09:32:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:32:12 <roconnor> fasta: ah, in a lazy language right?  It was just a conjecture.  Does Turner agree as a conjecture, or agrees as a theorem that he knows?
09:32:12 <ph8> shit
09:32:14 <ph8> i knew that
09:32:16 <DRMacIver> Hm. I thought Haskell allowed the # symbol in identifiers?
09:32:24 <ph8> do i literally just put them all together?
09:32:36 <mdmkolbe|work> Cale, quicksilver: the hole point of $ is that it has right assoc instead of left assoc, otherwise you couldn't write "show $ ppr $ getUnique x" (ok, so its also a higher precidence, but so are parens)
09:32:38 <fasta> roconnor: he conjectures it
09:32:47 <quicksilver> mdmkolbe|work: but there is no need to write that
09:32:59 <quicksilver> mdmkolbe|work: you can write show . ppr . getUnique $ x
09:33:04 <quicksilver> mdmkolbe|work: which is more convenient anyway
09:33:07 <byorgey> ph8: no -- again, think about what sort of things go into the pipeline, and what sort of things come out
09:33:14 <fasta> roconnor: I think that when you go to the point of faking memory management in a lazy language and going really low-level you can go pretty far.
09:33:15 <roconnor> fasta: Ah, I'm glad I'm in good company.
09:33:15 <quicksilver> mdmkolbe|work: and shows you how to abstract the 'pipeline part'
09:33:29 <byorgey> ph8: then the type of the overall pipeline would be in -> out
09:33:52 <byorgey> ph8: for suitable 'in' and 'out' (which could themselves be more complicated things, perhaps)
09:34:00 <EvilTerran> show returns a string, so the whole thing must return a string
09:34:09 <Cale> quicksilver: thanks for already having said what I was going to say :)
09:34:20 <roconnor> fasta: yeah, you don't get constant memory access, but then again computers don't really have constant memory access either if they are forced to allow arbitrarily large memory.
09:34:27 <quicksilver> Cale: I have stolen your best lines!
09:35:08 <quicksilver> Cale: or, as we say on the internet: "O HAI, IM IN UR IRCS STEELIN UR QUOTEZ"
09:35:10 <fasta> roconnor: No, I am talking about constant memory access.
09:35:34 <roconnor> fasta: oh
09:35:45 <ph8> (Show a) => a -> b (maximum) -> (a->b) (map) -> [a] (map) -> [a] (map) -> String
09:35:45 <ph8> gargh
09:35:47 <ph8> that looks wrong
09:35:51 <ph8> obviously the bracket'ed bits are just notes
09:35:54 <mdmkolbe|work> quicksilver: ok, you have a point.  I'd still want "foldr (+) 0 $ length xs" but then again that works even with left assoc
09:36:01 <fasta> roconnor: If you have say access to a fixed amount of memory and you are allowed to use all that, a lot more should be possible.
09:36:01 <quicksilver> mdmkolbe|work: correct :)
09:36:23 <quicksilver> mdmkolbe|work: and a left assoc '$' lets you write other things which are currently inexpressible
09:36:24 <roconnor> :)
09:36:30 <quicksilver> mdmkolbe|work: well, which currently require brackets
09:36:31 <fasta> roconnor: then your functions go from X MB of memory to X MB of memory :)
09:36:43 <byorgey> ph8: that isn't right.  that would be a function that takes 5 inputs.
09:36:46 <Cale> It's really the precedence and not so much the associativity that's important about $. If $ were left associative, by combining it with (.), we could eliminate even more parens.
09:36:49 <quicksilver> mdmkolbe|work: like f (g x) (h y) (j z)
09:36:57 <Cale> Right :)
09:37:00 <roconnor> cool
09:37:05 <quicksilver> mdmkolbe|work: which would be f $ g x $ h y $ j z
09:37:09 <quicksilver> if I got that right :)
09:37:14 <Cale> yes
09:38:09 <byorgey> ph8: you got the -> String part.  now what type of things are input to (map length)?
09:38:28 <ph8> (a->b) -> [b]
09:38:31 <ph8> and it returns [b]
09:38:36 <ph8> well or [a]
09:38:39 <ph8> does that letter even matter?
09:38:44 <ph8> could it be [x] -> [x] on the end?
09:38:47 <mdmkolbe|work> quicksilver: so doing it that way $ is not longer an auto-closing left paren, but rather a parameter-separator (comma in other langs)
09:38:57 <int-e> quicksilver: you got that wrong :)
09:39:09 <quicksilver> mdmkolbe|work: it still auto-closes, it just auto-closes in a different place
09:39:27 <quicksilver> mdmkolbe|work: auto-closes when it hits the next $ instead of at the end of the line
09:39:31 <quicksilver> int-e: did I?
09:39:33 <byorgey> ph8: map has type (a->b) -> [a] -> [b] (the letters do matter), but not map length
09:39:58 <quicksilver> int-e: looks right to me
09:39:59 <int-e> quicksilver: yes. $ associates to the right; f $ (g x $ (h y $ (j z)))
09:40:04 <quicksilver> int-e: erm
09:40:10 <quicksilver> int-e: you should read a little more context before butting in :P
09:40:12 <byorgey> ph8: another way to think about map is that it "lifts" a function a -> b to a function [a]->[b]
09:40:13 <EvilTerran> quicksilver, isn't it an auto-opening right paren?
09:40:32 <quicksilver> int-e: the conversation is a discussion of why it would be better if it was left-associating
09:40:35 * mdmkolbe|work concurs with EvilTerran
09:40:43 <int-e> quicksilver: you said that was  f (g x) (h y) (j z) .. and it's not
09:40:49 <int-e> quicksilver: ah
09:40:51 <byorgey> ph8: so if you know the type of 'length', you can use that to figure out the type of 'map length'
09:41:06 <int-e> ok, sorry then.
09:41:08 <quicksilver> :)
09:41:12 <Cale> ph8: the fact that the letters are different matters, but the actual letters used doesn't of course
09:41:27 <EvilTerran> (f $ g x $ h y $ j z) = (((f g x) h y) j z) in this case?
09:41:39 <EvilTerran> actually, it isn't quite, is it?
09:41:40 <quicksilver> no
09:41:40 <Cale> so you can say:  map :: (s -> t) -> [s] -> [t] or map :: (x -> y) -> [x] -> [y]
09:41:46 <EvilTerran> (((f g x) (h y)) (j z))
09:41:53 <EvilTerran> (yay lisp)
09:42:02 <quicksilver> f (g x) (h y) (j z), it is
09:42:03 <mdmkolbe|work> But thinking of it as an auto-opening right paren is kind of mentally hard (and not just b/c I'm used to it)
09:42:07 <int-e> oh and I agree - because right now a $ b $ c can be expressed at a . b $ c so its associativity is almost always useless.
09:42:16 <ph8> well length is presumably just [a] -> [b]
09:42:22 <ph8> no wait
09:42:23 <ph8> a -> b
09:42:25 <ph8> my bad
09:42:26 <EvilTerran> ph8, what does length return?
09:42:26 <quicksilver> or (((f (g x)) (h y)) (j z)) if you really want full bracketing
09:42:29 <ph8> an Int
09:42:36 <ph8> but does it need to be typed?
09:42:38 <ph8> :type length
09:42:45 <EvilTerran> yes
09:42:53 <EvilTerran> forall a. [a] -> Int
09:42:53 <byorgey> @type length
09:43:01 <ph8> ah balls
09:43:02 <lambdabot> forall a. [a] -> Int
09:43:09 * EvilTerran = lambdabot :P
09:43:20 <EvilTerran> @src length
09:43:20 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:43:21 <mdmkolbe|work> quicksilver: I think the choice of $ to be right assoc was probably influenced by scheme where they get so many right parens at the end that people are always begging for an auto-close
09:43:29 <EvilTerran> @source length
09:43:30 <lambdabot> length not available
09:43:38 <mdmkolbe|work> @src Prelude.length
09:43:39 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:43:49 <EvilTerran> length [] = 0
09:43:52 <ph8> show . maximum . map length
09:43:56 <byorgey> ph8: length takes a list of anything, and returns an Int telling you the length of the list: so its type is [a] (list of anything) -> Int
09:43:58 <EvilTerran> length (_:xs) = 1 + length xs
09:44:15 <ph8> ([a] -> Int a) -> String
09:44:18 <ph8> that's the end atm?
09:44:32 <EvilTerran> (intentionally speaking; i rather suspect it's actually a fold.)
09:44:34 <ph8> a -> ([a] -> Int a) -> String -- signifies map
09:44:35 <mdmkolbe|work> ph8: there is no 'Int a'
09:44:42 <ph8> :(
09:44:44 <ph8> confusing++
09:44:48 <byorgey> ph8: getting closer, but not quite
09:44:59 <EvilTerran> foldl' (1+) 0 --?
09:45:03 <byorgey> ph8: so if the type of length is [a] -> Int, what is the type of (map length)?
09:45:24 <byorgey> ph8: remember, map takes functions x -> y and turns them into functions [x] -> [y]
09:48:53 <hpaste>  masak pasted "is there a more elegant way to write next_value?" at http://hpaste.org/101
09:49:48 <masak> also, I'm currently getting "Not in scope: data constructor `Bits'" which I don't think I should get when importing Data.Bits
09:49:49 <emu> :t not elem
09:49:51 <lambdabot>     Couldn't match expected type `Bool'
09:49:51 <lambdabot>            against inferred type `a -> [a] -> Bool'
09:50:01 <emu> how does that compile?
09:50:18 <masak> emu: it's a function
09:50:43 <int-e> masak: there's zipWith for starters
09:50:44 <emu> i realize.  but (not elem lst) is the same as ((not elem) lst) and (not elem) doesn't make any sense
09:50:50 <ToRA> @type take
09:50:51 <masak> int-e: good, thx
09:50:51 <ph8> map length is (a->b) -> [a] -> [a]
09:50:52 <lambdabot> forall a. Int -> [a] -> [a]
09:50:52 <int-e> > zipWith xor [1..3] [4..5]
09:50:53 <lambdabot>  Add a type signature
09:50:57 <ph8> map length is (a->Int) -> [a] -> [a]
09:50:58 <emu> maybe you meant (not . elem lst)
09:51:19 <ph8> ((a->Int) -> [a] -> [a]) -> String for the last part?
09:51:20 <int-e> @type zipWith xor [1..3] [4..5]
09:51:21 <lambdabot> forall a. (Bits a, Enum a) => [a]
09:51:23 <masak> emu: I think I did
09:51:36 <masak> emu: strangely it does compile
09:51:44 <emu> or not element of list? well it's item `elem` list so (not . (`elem` lst))
09:51:51 <emu> @hoogle elem
09:51:51 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
09:51:51 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
09:51:51 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
09:52:05 <emu> @hoogle until
09:52:06 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
09:52:06 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
09:52:21 <int-e> masak: why did you write the Bits in xor Bits (fst pair) Bits (snd pair) ?!
09:52:23 <emu> @type \lst -> until (not elem lst) (+1) 0
09:52:25 <lambdabot>     Couldn't match expected type `Bool'
09:52:25 <lambdabot>            against inferred type `a -> [a] -> Bool'
09:52:42 <masak> int-e: I thought I had to
09:53:09 <int-e> masak: no, xor (fst pair) (snd pair)  is just fine.
09:53:13 <masak> good.
09:53:16 <ToRA> masak: also, arguments to take are the wrong way round arn't they?
09:53:16 <byorgey> ph8: not quite
09:53:26 <emu> yea they are
09:53:29 <emu> heh
09:53:43 <masak> ah
09:53:50 <emu> also (take reverse lst n) is all wrong for the same reasons as above
09:53:56 <emu> no way this compiled!
09:54:17 <dmhouse> Is there a parsec combinator for executing a certain parser, then restoring the input? I.e. something that turns a parser into a parser that behaves the same, but doesn't consume anything?
09:54:17 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
09:54:18 <byorgey> ph8: map makes functions from x->y into functions [x]->[y]... so since length :: [a] -> Int, map length :: [[a]] -> [Int]
09:54:32 <ph8> gah
09:54:39 <byorgey> ph8: in other words, length takes a list and gives you an Int; map length takes a list of lists and gives you a list of Ints
09:54:46 <ph8> i see
09:54:54 <ph8> ok that's cool
09:54:54 <masak> emu: no, on second thought it didn't compile, it got stuck on early errors :)
09:54:58 <ph8> was missing the combination part
09:55:00 <int-e> masak: oh and mex is probably best implemented with sort - sort, then scan for the first missing number.
09:55:02 <byorgey> ph8: it applies length to each list in the list of lists
09:55:02 <emu> (take n $ reverse lst)
09:55:21 <masak> int-e: how?
09:55:23 <masak> emu: thx
09:55:29 <emu> yes that will be nlogn rather than n^2
09:55:33 <emu> presumably
09:55:40 <emu> more space though
09:55:47 <dmhouse> Ah, lookAhead seems to do it.
09:55:47 <masak> I have space
09:55:48 <int-e> emu: not really
09:56:11 <dmhouse> Wait, no, that deals with state, not input.
09:56:14 <int-e> emu: mex has to hold onto the complete list anyway :)
09:56:29 <emu> this is functional programming -- who cares about space anyhow!
09:56:57 <masak> :)
09:57:10 <int-e> emu: but it's probably best to use Data.Set anyway - then the (currently elegant) code can be reused.
09:57:16 <byorgey> ph8: so what type goes into the right end of the pipeline?
09:57:26 <emu> Data.Set and Data.Map are very handy
09:57:30 <emu> i use them almost everywhere
09:57:49 <ph8> you mean the -> String end?
09:57:50 <mdmkolbe|work> since space / time = c, we must also not care about time
09:57:51 <ph8> or the beginning?
09:57:53 <int-e> oh. mex doesn't compile either. tsk.
09:58:13 <mdmkolbe|work> that was badly executed on my part
09:58:41 <mdmkolbe|work> since space *is* time we don't care about that either
09:58:43 <byorgey> ph8: I mean the beginning
09:59:02 <byorgey> ph8: since when you write it like show . maximum . map length the beginning is on the right side
09:59:20 <ph8> ah i see
09:59:51 <ph8> i was trying to map it literally
09:59:59 <ph8> why isn't it just a -> String?
10:00:06 <ph8> maximum to the showable string?
10:00:16 <byorgey> ph8: that's a little to general
10:00:23 <mdmkolbe|work> hpaste needs a compile-with-ghc option (I've seen some C paste sites do that for C)
10:00:23 <ph8> Int rather
10:00:25 <byorgey> ph8: it doesn't work on just anything
10:00:33 <byorgey> for example:
10:00:45 <byorgey> > show . maximum . map length $ 3
10:00:53 <lambdabot>   add an instance declaration for (Num [[a]])
10:01:16 <Cale> ph8: Why isn't what just a -> String?
10:01:23 <byorgey> ph8: so the input type can't be just 'a' since that would mean the function can take any sort of input at all
10:01:30 <Cale> ah, okay
10:01:40 <ph8> ok
10:01:43 <ph8> so it takes an Int
10:01:47 <Cale> yeah, length needs a list to work with
10:01:59 <ph8> derived from a list of lists
10:02:01 <Cale> and so  map length  needs a list of lists
10:02:11 <ph8> this makes me head hurt
10:02:17 <ph8> i'm still missing something obvious
10:02:25 <byorgey> ph8: right, so what does it need to START with?
10:02:37 <ph8> the input from (map length) ?
10:02:42 <byorgey> ph8: right!
10:02:47 <byorgey> ph8: which is what?
10:02:53 <hpaste>  masak pasted "implemented mex with sort and search instead" at http://hpaste.org/102
10:03:00 <ph8> which is [a]
10:03:03 <ToRA> dmhouse: some combination of getInput and setInput
10:03:07 <ph8> no
10:03:07 <ph8> [Int]
10:03:12 <byorgey> ph8: almost
10:03:15 <ToRA> dmhouse: ?
10:03:17 <byorgey> ph8: no, not [Int]
10:03:18 <Cale> length :: [a] -> Int, so map length :: [[a]] -> [Int]
10:03:29 <ph8> but it only returns [Int]?
10:03:32 <ph8> so why does the rest need to be included?
10:03:48 <Cale> ph8: the rest?
10:03:56 <Saizan> type inference is just like solving a system of equations by substitution, you start from some known relations (i.e. the type of the known function) and substitute that into the variables according to function applciation
10:04:03 <byorgey> ph8: the output of (map length) is [Int], but we were talking about the input
10:05:06 <Cale> ph8: Just for reference, which languages do you already know? :)
10:05:20 <ph8> java, ruby, php, perl, bits of C
10:05:31 <Cale> okay
10:05:45 <ph8> argh
10:05:45 <ph8> so
10:05:52 <ph8> may length takes [[a]]
10:05:56 <ph8> and returns [Int]
10:05:58 <byorgey> ph8: right!
10:06:05 <ph8> and i need to include both those bits of information in the answer?
10:06:10 <byorgey> ph8: no
10:06:14 <ph8> that's what i thought
10:06:16 <Cale> "the answer"?
10:06:19 <ph8> so i only need to include [[a]]?
10:06:38 <byorgey> ph8: when looking at the type of the pipeline as a whole, all that matters is what goes in one end and what comes out the other
10:06:41 <ph8> [.: 17:27:14 :.] <ph8> hmm - "determine the type of show . maximum . map length"... Show a => a -> [a] -> Show a ?
10:06:44 <Cale> If you provide map length with a value of type [[a]], it gives you a value of type [Int]
10:06:51 <byorgey> ph8: right
10:06:52 <Cale> (for any type a)
10:06:56 <ph8> ok
10:06:57 <ph8> so
10:06:59 <ph8> at the beginning
10:07:01 <ph8> [[a]] ->
10:07:07 <byorgey> ph8: right
10:07:10 <ph8> ok!
10:07:21 <byorgey> ph8: and the end?
10:07:22 <ph8> [[a]] -> Int -> String?
10:07:24 <Cale> ah, you're working out the type of the composition?
10:07:31 <byorgey> ph8: where did the Int come from?
10:07:33 <ph8> maximum?
10:07:40 <byorgey> ph8: but that's still inside the pipeline
10:07:46 <Cale> Oh!
10:07:50 <byorgey> Cale: yes
10:07:50 <ph8> i thought String was the 'show' end
10:07:53 <Cale> I know what the confusion is! :)
10:07:54 <ph8> and [[a]] was the map length end
10:08:08 <byorgey> ph8: that's right!
10:08:08 <Cale> [[a]] -> Int -> String means the same thing as [[a]] -> (Int -> String)
10:08:25 <byorgey> Cale: I'm not sure that's what the confusion is
10:08:33 <Cale> that is, a value of that type is a function which takes a list of list of a's, and produces a function from an Int to a String
10:08:40 <ph8> ok
10:08:52 <ph8> so that's not the final answer is it? don't i have to represent maximum's presence somehow?
10:09:03 <byorgey> ph8: no, not in the type.
10:09:04 <Cale> Which you could also read as meaning that the function has two parameters, one of type [[a]] and one of type Int, and returns a String
10:09:06 <ph8> oh
10:09:12 <ph8> so it's [[a]] -> String
10:09:17 <byorgey> ph8: you got it. =)
10:09:20 <Cheery_> @type id
10:09:25 <lambdabot> forall a. a -> a
10:09:26 <ph8> hurrah!
10:09:27 <ph8> :-)
10:09:29 <ph8> thx
10:09:33 <ph8> gonna go read about monads now
10:09:35 <byorgey> ph8: sure
10:10:01 <ToRA> @type show . maximum . map length
10:10:03 <lambdabot> forall a. [[a]] -> String
10:10:16 <ph8> omg
10:10:17 <Cale> I think that understanding the type system is the most important thing to do when you start learning Haskell. Everything else is pretty easy once you understand how to check types.
10:10:20 <ph8> i could've done that all along? :p
10:10:31 <byorgey> ph8: no, 'cuz that would have been cheating =)
10:10:35 <ph8> heh
10:10:38 <ToRA> ph8 ;)
10:10:44 <Cale> Knowing how to do it by hand is pretty important :)
10:10:59 <byorgey> Cale speaks truth!
10:13:44 <mdmkolbe|work> ph8: FYI, ghci supports the ':type' command so you can do it offline without lambdabot, it's nice for poking around e.g. the type of 'show', but when you're learning what Cale said is absolutely right.  Otherwise, when you get a type error you won't know why it's a type error or how to fix it.
10:14:25 <DRMacIver> Haskell's type system is fairly intuitive anyway.
10:14:33 <DRMacIver> Ignoring some of the more arcane extensions to it. :)
10:15:13 <DRMacIver> (And even those are usually not too bad once looked at in the right light. Or so I hope.)
10:16:45 <Cale> Well, more or less intuitive depending on your background :)
10:17:03 <Cale> Intuitive to those with a mathematics background certainly.
10:17:46 <DRMacIver> It's intuitive to anyone, as long as they train their intuition properly first. ;)
10:18:07 <mdmkolbe|work> DRMacIver: what you say is true, but it might only be so once you understand how type checking actually works.  I remember thinking the haskell compiler must be some kind of magic to be able to infer types the first time I saw it (mostly due to my previous experience with C)
10:19:06 <byorgey> mdmkolbe|work: mm, the type system is intuitive to me but I don't actually know how type checking/inference works yet (although it's on my list of things to read about...)
10:19:08 <DRMacIver> mdmkolbe|work: It's possible that I find it intuitive because I came to Standard ML with no programming background.
10:19:32 <DRMacIver> But, as Cale points out, a significant amount of mathematical background.
10:20:05 <DRMacIver> So a) I didn't have any preconceptions about type checking being hard and b) Abstraction was already my bitch. :) Functions as values? No problem.
10:20:50 <dmhouse> ?remember <DRMacIver> Abstraction is my bitch. :)
10:20:50 <lambdabot> Done.
10:20:54 <weitzman> In my experiences, there has been a difference between being able to see whether something is well-typed and being able to understand the type-checking algorithm
10:20:59 <dmhouse> (Excuse the paraphrasing. :))
10:21:06 <DRMacIver> Paraphrasing excused. :)
10:21:22 <weitzman> Don't know if Haskell has any subtleties like the ones I had to cope with in Harper-Stone-ish ML with Singleton Kinds
10:21:55 <weitzman> Weak-Head Normal Forms and stuff like that
10:22:05 <mdmkolbe|work> DRMacIver: Oh, I had scheme and such before Haskell, but still in the C world every variable will get a declared value and the types of expressions are constructed bottom up.  Haskell adds unifiction which (now I've learned) is what was giving Haskell that extra 'magic'
10:22:59 <assl0r> > take 1000 $ repeat "haskell ist ein arschloch"
10:23:01 <lambdabot>  ["haskell ist ein arschloch","haskell ist ein arschloch","haskell ist ein ar...
10:23:17 <mdmkolbe|work> @help babel
10:23:17 <lambdabot> babel <lang1> <lang2> <phrase>.
10:23:18 <lambdabot> Translate a phrase in lang1 to lang2.
10:23:18 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
10:23:30 <mdmkolbe|work> @babel de en arschloch
10:23:31 <lambdabot>   asshole
10:23:51 <byorgey> woah, lambdabot does babel?!
10:23:55 <mdmkolbe|work> @babel de en haskell ist ein arschloch
10:23:56 <lambdabot>   an asshole is haskell
10:24:16 <pjd> haskell is like an asshole:  everyone needs one?
10:24:21 * DRMacIver -> home
10:24:25 <byorgey> assl0r: was ist los?
10:24:37 <mdmkolbe|work> @babel en de bitch
10:24:38 <lambdabot>   Weibchen
10:27:38 <assl0r> byorgey, nix, ich verzweifel nur grad
10:28:10 <mdmkolbe|work> @babel de en byorgey, nix, ich verzweifel nur grad
10:28:11 <lambdabot>   byorgey, nix, I despair only degree
10:29:02 <byorgey> ah, babelfish... =)
10:29:18 <shapr> SHAZAM!
10:29:22 <assl0r> @babel de en klopp dich selbst inne tonne du nix raffendes mistding
10:29:24 <lambdabot>   klopp you ton you nix raffendes muck thing
10:30:15 <mdmkolbe|work> I think that was below the nyqest limit
10:30:29 <assl0r> @google nyquest
10:30:32 <lambdabot> http://www.go-nyquest.com/
10:30:32 <lambdabot> Title: Nyquest Training & Placement: Job Placement and Staffing Services for Outdoor Pr ...
10:30:39 <assl0r> @google nyqest
10:30:41 <lambdabot> http://www.loni.ucla.edu/ICBM/Research/Research_Structure_DTI.shtml
10:30:43 <lispy> with ghc -O0 is optization?
10:30:47 <lispy> optimization*
10:30:56 <weitzman> @google nyquist
10:30:58 <lambdabot> http://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem
10:30:58 <lambdabot> Title: NyquistâShannon sampling theorem - Wikipedia, the free encyclopedia
10:31:01 <lispy> gah, i meant to ask...is that NO optimization?
10:31:38 <mdmkolbe|work> lispy: IIRC, that is correct
10:31:47 <lispy> thanks
10:31:55 <mdmkolbe|work> lispy: well at least as close to no opt as GHC will allow
10:32:10 <Saizan> i've seen -Onot
10:35:13 <lispy> hmm...yes -O0 seems to be speeding up my build time
10:35:16 <lispy> that is good
11:13:04 <migraine> if you had a minute to sell haskell to someone how would you go about it?
11:13:16 <nominolo> lispy: -O is best, -O0 is no, and -O1 is medium optimization
11:13:49 <Cale> migraine: Depends on who it was I was trying to sell it to, I suppose.
11:13:51 <byorgey> migraine: sort of depends who it is!
11:13:51 <chessguy> ?seen dpiponi
11:13:51 <lambdabot> I saw dpiponi leaving #haskell 4d 16h 34m 55s ago, and .
11:13:56 <Igloo> For GHC? -O is -O1 AFAIK
11:14:01 <defcon8> hello
11:14:05 <olsner> > let f (n+1) = n in f 7
11:14:05 <lambdabot>  Parse error in pattern
11:14:09 <defcon8> what do most people develop haskell programmes in?
11:14:15 <defcon8> I mean, editor environment.
11:14:17 <migraine> coworker
11:14:22 <migraine> c programmer
11:14:27 * nominolo <- emacs
11:14:30 <nattfodd> defcon8: most I don't know, but happily living with vim here
11:14:31 <Lemmih> defcon8: emacs.
11:14:34 <Cale> defcon8: vim, emacs, anything really.
11:14:34 <savor> emacs
11:14:35 <defcon8> hmm
11:14:44 <defcon8> with haskell-mode? It seems there's nothing like slime for haskell
11:14:49 <pjd> migraine: "it's like c, but better"
11:14:54 <migraine> heh
11:14:55 <nominolo> defcon8: shim comes a _bit_ close
11:14:57 <nattfodd> no there isn't really
11:15:03 <nattfodd> but it isn't needed
11:15:06 <byorgey> migraine: "it's nothing at all like c"
11:15:08 <Cale> migraine: No more segfaults?
11:15:27 <Cale> migraine: Easy declaration of data structures?
11:15:29 <desp> migraine: TextMate
11:15:29 <defcon8> where is shim's site?
11:15:32 <DRMacIver> migraine: No more migraines? ;)
11:15:44 <migraine> migraines result from C++ ;)
11:16:04 <Cale> Control over side-effects? I don't know how well most C programmers would see that one though.
11:16:12 <migraine> yeah that one is hard to explain
11:16:18 <migraine> without going in depth
11:16:28 <Cale> However, cutting down debug times is a good point to make.
11:16:31 <chessguy> is it just me or is the markup on http://en.literateprograms.org/Sierpinski_triangle_(Haskell) messed up?
11:16:33 <lambdabot> Title: Sierpinski triangle (Haskell - LiteratePrograms
11:16:41 <desp> I'm not sure if Haskell is a direct competitor to C
11:16:47 <shapr> Igloo: ghc6-doc seems to be pretty much empty. The index is blank and the contents show zero modules.
11:16:48 <nominolo> @go haskell shim
11:16:49 <byorgey> migraine: "it compiles; must be correct" is more than just a hilarious joke
11:16:51 <lambdabot> http://shim.haskellco.de/trac/
11:16:51 <lambdabot> Title: shim - Trac
11:16:52 <desp> I would say both serve different purposes, no?
11:16:56 <Cale> desp: It is, but only because people abuse C.
11:16:57 <defcon8> anyone tell me where shim's site is?
11:16:58 <nattfodd> migraine: but what kind of programming is your friend doing?
11:17:12 <DRMacIver> migraine: One sentence pitch: "Functional programming language with an extremely advanced type system which allows an unparalleled amount of expressivity and safety." :)
11:17:15 <nominolo> defcon8: over you ;)
11:17:23 <defcon8> google din't help
11:17:25 <olsner> one-liners always impress C coders
11:17:27 <defcon8> oh, thanks nominolo
11:17:43 <migraine> same stuff I am doing, actually it is a team of people and I am lead dev...
11:17:44 <Igloo> shapr: What does "dpkg -s ghc6-doc | head -2" say?
11:17:48 <migraine> not sure I would promote it for work though
11:17:54 <migraine> just trying to get them interested
11:17:59 <nattfodd> migraine: again, it would depend which kind of work
11:18:01 <nominolo> defcon8: iff you code compiles, it can tell you the types of top-level functions
11:18:06 <chessguy> quick! everyone ignore me!
11:18:13 <DRMacIver> olsner: I find one liners pretty useless for getting a feel for the language.
11:18:16 <nominolo> defcon8: it can complete module names
11:18:28 <byorgey> migraine: just show them an interesting example program.  that's probably ten times better than anything you could say.
11:18:38 <nominolo> defcon8: to get closer to slime+parenmode you'd need a structural editor
11:18:46 <shapr> Igloo: Package: ghc6-doc \n Status: install ok installed
11:18:52 <migraine> well we work on web content management/publishing systems in C due to reasons beyond my control
11:19:01 <pjd> migraine: http://www.haskell.org/hawiki/QuotesPage
11:19:02 <lambdabot> Title: QuotesPage - The Haskell Wiki
11:19:08 <pjd> that's probably as good a hook as you'll get
11:19:15 <DRMacIver> migraine: Good lord.
11:19:19 <defcon8> nominolo, does shim do font-lock and indentation?
11:19:22 <Igloo> shapr: Hmm, what about   dpkg -s ghc6-doc | grep "^Version"   ?
11:19:24 <DRMacIver> migraine: My condolences.
11:19:25 <nattfodd> byorgey: that, and explaining some principles of functional programming first
11:19:26 <defcon8> or is that the job of haskell-ode?
11:19:29 <nominolo> defcon8: that's pretty tricky, though.  and i personally don't like emacs lisp.  it's wasn't even state of the art 20 years ago
11:19:30 <nattfodd> so as not to scare them right away
11:19:42 <nominolo> defcon8: yes, but that does haskell-mode already
11:19:51 <migraine> yes good lord, but actually it turned out nice, and with < 2 second page load times for db's with 100k+ multiversioned documents I can't complain
11:19:58 <byorgey> nattfodd: I suppose
11:20:28 <migraine> just hard to find more employees ;)
11:20:36 <migraine> and people who don't think I am insane
11:21:43 <shapr> Igloo:  Version: 6.6.1-2
11:21:51 <nominolo> defcon8: in shim, C-c C-t is nice.  it adds a type declaration for the function at point
11:22:05 <defcon8> cool
11:22:44 <Igloo> shapr: And you don't have, e.g., /usr/share/doc/ghc6-doc/html/libraries/base/Data-Bits.html ?
11:23:09 <Cale> migraine: One thing which is true, though some people won't understand it, is that learning Haskell changes the way that you think about programming, and so changes the way that you program in all the other languages you know.
11:23:13 <Igloo> shapr: Oh, I've just realised what you mean. What arch is this?
11:23:15 <Cale> (Like many other languages)
11:23:35 <migraine> Cale: yes which is why I am trying to get them to look at it :)
11:23:48 <migraine> but it may turn out to be over their head
11:23:48 <Cale> Have you told them that?
11:24:09 <Igloo> shapr: If it's a 32bit arch then it's almost certainly a symptom of http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=426335
11:24:11 <lambdabot> Title: #426335 - can not resolve names in .haddock files generated on other architectur ...
11:24:13 <migraine> Cale: that point I haven't made interestingly enough
11:24:26 <nominolo> defcon8: the big drawback holds.  first the code has to compile
11:24:29 <emu> shim needs a repl, then it is good to go
11:24:34 <Cale> migraine: Well, if 11 year old kids can learn about monads... :)
11:24:55 <emu> i tried hacking one in, but ran into serious problems with GHC API runStmt
11:25:26 <migraine> heh, seems when you go to college you revert to 5 year old state before entering the work force
11:25:33 <emu> GHC API is a mess :(
11:25:54 <Igloo> emu: Please put constructive suggestions in a bug report!
11:26:06 <DRMacIver> Cale: People say that a lot. I'm not entirely convinced that it's a good thing.
11:26:28 <Cale> DRMacIver: Well, I've actually seen it happen :)
11:26:45 <emu> Igloo: i've put plenty of mail list posts in
11:26:45 <DRMacIver> Cale: I'm not disputing it. I'm just saying that it's not neccessarily a positive feature.
11:26:48 <DRMacIver> Cale: If migraine's coworkers start writing C code as if it were Haskell then the results will be... interesting.
11:27:03 <Cale> DRMacIver: er, oh, are we talking about the same thing?
11:27:06 <defcon8> emu, pay me and I'll go down the road to Glasgow uni and sort them out!
11:27:08 <Cale> DRMacIver: Which feature?
11:27:11 <defcon8> seriously, it's down the road :p
11:27:16 <Cale> oh, I see.
11:27:20 <emu> even the simons admitted defeat!
11:27:26 <SamB_XP> I don't think 11 year olds are smart enough to write Haskell like C
11:27:33 <SamB_XP> or do I mean stupid enough?
11:27:36 <SamB_XP> wait...
11:27:38 <Cale> DRMacIver: The feature that it changes the way you think about code. Well, yeah.
11:27:40 <DRMacIver> Cale: "Haskell changes the way that you think about programming"
11:27:55 <SamB_XP> you said C like Haskell.
11:27:57 <defcon8> SamB, I discovered haskell and cl before I even bothered with C
11:28:05 <defcon8> I'm quite happy about that
11:28:08 <SamB_XP> okay, I don't think *I* am smart enough to write C like Haskell
11:28:31 <defcon8> though I hardly know anything of Haskell
11:28:31 <Cale> Well, it might teach you to avoid needlessly mutating state, for example.
11:28:36 <Cale> If you can avoid it.
11:28:42 <DRMacIver> SamB_XP: I occasionally find myself writing Java like Haskell.
11:28:53 <DRMacIver> SamB_XP: Then I realise that even I can't read the damn stuff and rewrite it to be a bit more sane.
11:29:09 <SamB_XP> DRMacIver: I don't understand how anyone can read Java at all
11:29:13 <weitzman> If the alternative to mutating state is using malloc in C, I'll take the mutation :)
11:29:16 <nattfodd> DRMacIver: a sane person would stop using java :)
11:29:19 <Cale> and to keep functions referentially transparent whenever you can, and pass parameters rather than using global state
11:29:39 <DRMacIver> SamB_XP: I occasionally agree with you.
11:29:50 <DRMacIver> nattfodd: Nah.
11:29:50 <defcon8> Cale, could you tell me how I would do this in haskell: do factorising of numbers that use a list of pre-computed primes. If the number to be factorised is larger Sqrt(2)*last computed prime, compute the next prime and add it to the list. And then how would I be able to use this list later on?
11:29:57 <SamB_XP> or perhaps I should say "more than a little bit"
11:30:06 <nattfodd> DRMacIver: java is the boringestest language in the world
11:30:29 <SamB_XP> defcon8: just make a lazy list of primes?
11:30:36 <defcon8> SamB_XP, damn it
11:30:46 <DRMacIver> nattfodd: Agreed. But this is sometimes a virtue, as it means that everything ever has a Java port. :) More importantly my day job involves coding Java, so I don't have much of a choice.
11:30:46 <defcon8> I always forget about laziness
11:30:57 <defcon8> is laziness really functional?
11:31:03 <SamB_XP> sure
11:31:07 <defcon8> of course it is
11:31:07 <Cale> yes, it's just an evaluation order
11:31:19 <pitecus> @src fromIntegral
11:31:19 <lambdabot> fromIntegral = fromInteger . toInteger
11:31:24 <Cale> well, with a means of sharing results from duplicated parameters
11:31:46 <nattfodd> DRMacIver: it's certainly why it's so widespread, since even mediocre programmers can produce stuff
11:31:47 <SamB_XP> I don't think the Haskell standard mandates laziness
11:31:59 <nattfodd> it has so many safeguards that their stuff even stands a chance of actually working
11:32:12 <Cale> I suppose it depends a bit on how you need to access that list of primes. If you're just going to do trial division over all the primes, then a list is appropriate.
11:32:25 <Cale> SamB_XP: No, just non-strictness.
11:32:27 <defcon8> Cale, SamB_XP, is my question possible without laziness?
11:32:31 <defcon8> and without monads
11:32:37 <Cale> defcon8: Sure.
11:32:42 <SamB_XP> totally
11:32:47 <defcon8> how?
11:32:47 <SamB_XP> you can just write it in maths
11:32:54 <defcon8> ?
11:33:01 <SamB_XP> (well, okay, its called "normal order")
11:33:16 <defcon8> in Haskell?
11:33:20 <DRMacIver> nattfodd: It also means it can act as a lingua franca of programming languages. There are some very good Java tools and resources out there as a result.
11:33:29 <Cale> defcon8: yes, of course
11:33:31 <SamB_XP> if you write an implementation that uses normal-order evaluation, sure
11:33:37 <Cale> defcon8: What part are you having trouble with?
11:33:44 <defcon8> Cale, just a hypothesis
11:33:44 <weitzman> Java is a perfectly useful language. The tools are a second-to-none and it has a great collection of cross-platform libraries
11:33:57 <weitzman> When there's IntelliJ for Haskell, call me up
11:34:02 <SamB_XP> defcon8: you need non-strictness, sure
11:34:08 <SamB_XP> but there are things that aren't lazy or strict
11:34:14 <Cale> defcon8: In some sense, the parameter you'd use to hold the list of primes is sort of like using the State monad without that level of abstraction.
11:34:35 <Cale> defcon8: If you didn't just want to use the complete list of primes.
11:34:36 <SamB_XP> actually, to do what you actually said, you do need laziness
11:34:38 <defcon8> Cale, will I learn about this from the haskell school of expression?
11:34:41 <defcon8> I'm reading it right now
11:35:10 <SamB_XP> or, well, mutation
11:35:22 <defcon8> ok
11:35:25 <Cale> defcon8: This specifically? I don't know, I don't really remember that book, but probably not this *exact* thing. :) You should see at least one example of an accumulator though.
11:35:28 <defcon8> is list mutation possible in haskell?
11:35:30 <defcon8> without monads
11:35:42 <defcon8> Cale, okay
11:35:45 <Axioplase> is it possible to factorize patterns as case x of (1,0) | (0,1) -> foo   ?
11:35:49 <Cale> Everything is a constant in haskell, but data structures can share components.
11:36:11 <Cale> defcon8: It's possible to construct a new list which has the same tail as another list in constant time.
11:36:12 <monochrom> No, Axioplase.
11:36:13 <emu> weitzman: help out with shim!
11:36:23 <Axioplase> monochrom: ok, thanks
11:36:48 <defcon8> Cale, like conses in lisp?
11:36:54 <Cale> defcon8: yes, exactly.
11:37:06 <Cale> Haskell lists are cons-lists.
11:37:22 <emu> decent, law abiding cons-lists
11:37:43 <Cale> Except that since things are lazy, each part can be at some low level a pointer to code which computes what's supposed to be there.
11:38:30 <Cale> (and there's a mutation which goes on at that level, replacing the code with the final result when it's evaluated)
11:38:33 <opqdonut> i didn't really understand the power of laziness before reading the wiki article about laziness and tail-recursion and the sicp chapter on streams
11:39:05 <nominolo> @seen dcoutts
11:39:05 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 1d 6m 34s ago.
11:40:57 <monochrom> I like immutable. Many people say "I need [sic] mutable". Turns out they just need write-once. Laziness is great for that. Also frees you from handcoding the correct order of execution.
11:41:31 <defcon8> in haskell, is nil evaluated as an empty list?
11:41:38 <monochrom> > nil
11:41:38 <lambdabot>   Not in scope: `nil'
11:41:42 <opqdonut> > null
11:41:43 <lambdabot>  Add a type signature
11:41:45 <monochrom> There is no nil
11:41:47 <weitzman> > None
11:41:47 <lambdabot>   Not in scope: data constructor `None'
11:41:54 <opqdonut> > null :: [a]
11:41:54 <weitzman> > Nothing
11:41:54 <lambdabot>  Couldn't match expected type `[a]'
11:41:55 <lambdabot>  Nothing
11:42:03 <opqdonut> > null :: [Int]
11:42:04 <monochrom> :t null
11:42:04 <lambdabot>  Couldn't match expected type `[Int]'
11:42:05 <weitzman> @type Nothing
11:42:06 <lambdabot> forall a. [a] -> Bool
11:42:07 <lambdabot> forall a. Maybe a
11:42:19 <monochrom> > null [0,1,2]
11:42:20 <lambdabot>  False
11:42:28 <monochrom> @src null
11:42:28 <lambdabot> null []     = True
11:42:28 <lambdabot> null (_:_)  = False
11:42:50 <monochrom> (_:_) is obscene :)
11:43:04 <desp> :)
11:43:04 <opqdonut> because of strict typing NULL (or an equivalent) is only allowed if defined
11:43:14 <opqdonut> :src Maybe
11:43:22 <opqdonut> ?src Maybe
11:43:22 <lambdabot> data Maybe a = Nothing | Just a
11:43:30 <opqdonut> for example in Maybe
11:43:40 <Saizan> ?type undefined
11:43:42 <lambdabot> forall a. a
11:43:52 <opqdonut> but Int for example can never contain anything else than an int, undefined or bottom
11:43:53 <monochrom> undefined is defined.
11:44:06 <opqdonut> yeah undefined and bottom are the exceptions
11:44:06 <defcon8> is there TCO in haskell?
11:44:16 <defcon8> thanks monochrom
11:44:19 <monochrom> No, I mean it as a pun :)
11:44:41 <opqdonut> ?wiki tail recursion
11:44:41 <lambdabot> http://www.haskell.org/haskellwiki/tail_recursion
11:44:46 <monochrom> undefined is defined. defined is undefined.
11:44:50 <monochrom> > defined
11:44:51 <lambdabot>   Not in scope: `defined'
11:44:55 <monochrom> hehehe
11:44:55 <opqdonut> no that's not it
11:45:08 <weitzman> @let defined = True
11:45:10 <monochrom> There is TCO in haskell.
11:45:11 <lambdabot> Defined.
11:45:14 <weitzman> There
11:45:23 <defcon8> but is i tnormally better to use iteration?
11:45:30 <monochrom> @let defined = undefined
11:45:31 <lambdabot> <local>:6:0:     Multiple declarations of `L.defined'     Declared at: <local...
11:45:38 <monochrom> I hate you.
11:45:43 <EvilTerran> @undefine defined
11:45:43 <lambdabot> Undefined.
11:45:48 <defcon8> opqdonut, no text on the page
11:45:48 <monochrom> @let defined = undefined
11:45:49 <lambdabot> Defined.
11:45:52 <monochrom> hehehehehe!
11:45:55 <opqdonut> defcon8: yeah i know
11:45:57 <assl0r> O_o
11:45:59 <opqdonut> where is the article on tail calls and laziness?
11:46:00 <weitzman> > L.defined
11:46:01 <lambdabot>  Undefined
11:46:12 <EvilTerran> should @let defined = defined
11:46:19 <EvilTerran> that'd cause trouble
11:46:25 <monochrom> You do it. :)
11:46:31 <EvilTerran> @undefine defined
11:46:32 <lambdabot> Undefined.
11:46:35 <EvilTerran> @left defined = defined
11:46:36 <lambdabot> Defined.
11:46:37 <monochrom> It'll just <<loop>>.
11:46:43 <EvilTerran> wait, @left?
11:46:45 <weitzman> Left?
11:46:47 <EvilTerran> > defined
11:46:48 <lambdabot>  Exception: <<loop>>
11:46:54 <EvilTerran> apparently it works...
11:47:02 <monochrom> It likes typos.
11:47:10 <EvilTerran> evidently
11:47:34 <weitzman> @babe en fr What's your sign?
11:47:35 <lambdabot>   Quel est votre signe ?
11:48:18 <nattfodd> weitzman: what do you mean?
11:48:32 <weitzman> I sent that to babel via the power of spell correction
11:49:09 <nattfodd> weitzman: yes, but I was wondering what "what's your sign" meant
11:49:17 <nattfodd> I could help since I'm a french native speaker
11:49:23 <nattfodd> if you're translating something
11:49:33 <weitzman> nattfodd: It's just a corny pickup line. What's your sign of the zodiac, I believe
11:49:34 <desp> nattfodd: a tired pickup line?
11:49:54 <nattfodd> doesn't beat "do you come here often", I bet
11:51:50 <matthew-_> it's fun when you have to wait 5 seconds for ghci to finish printing the explanation as to why your program doesn't type check...
11:52:24 <SamB> really really long message, or just a slow link?
11:52:25 <flux> I remember there being a white paper on how to make type inference errors better suitable for humans
11:52:27 <fasta> Botje: your solution only worked for infinite lists, btw.
11:52:37 <flux> too bad the solution never got into real world :)
11:52:41 <fasta> flux: ?
11:52:49 <fasta> flux: someone did a Phd on it.
11:52:53 <fasta> flux: with working code.
11:52:56 <matthew-_> SamB: really really long - about 1000 lines or so...
11:53:00 <fasta> flux: freely available
11:53:01 <Botje> fasta: i know that. adding in the other clause was an exercise for the interested reader :]
11:53:06 <flux> fasta, yes.. and where is the ocaml or haskell support it?
11:53:10 <flux> fasta, btw, got an url?
11:53:17 <ph8> [IO a] -> IO [a] <= does that describe a list of IO actions, a (e.g. getLine) that then get converted a list of IO types (e.g. the value of getLine) ?
11:53:22 <fasta> @google helium haskell
11:53:26 <lambdabot> http://www.cs.uu.nl/helium/
11:53:26 <lambdabot> Title: [ The Helium Homepage - Home]
11:53:41 <Botje> ph8: sequence takes a list of IO actions, and returns an IO action that yields a list
11:53:47 <fasta> flux: it's not in GHC, but I wouldn't say it's not "available".
11:53:55 <ph8> sequence?
11:53:56 <sjanssen> ph8: a list of actions that return an 'a' into an action that returns a list of 'a's
11:54:03 <ph8> ah yes
11:54:05 <ph8> sequence it is
11:54:06 <Botje> ph8: that's the function your type describes.
11:54:07 <ph8> missed that part of the question
11:54:23 <fasta> Botje: oh, it was was a trivial function to write, but I thought let's give the channel some food.
11:54:26 <ph8> so my examples are valid?
11:54:43 <Botje> ph8: errr
11:54:54 <Botje> your example isn't perfectly clear to me
11:55:14 <Botje> let's say you do "sequence [readLine,readLine,readLine]"
11:55:16 <ph8> so the input could be [getLine, getLine, getLine]
11:55:18 <ph8> sorry readline
11:55:21 <Botje> doesn't matter :)
11:55:25 <Botje> yes
11:55:31 <ph8> and the output could be
11:55:37 <ph8> ["blue", "red", "yellow"]
11:55:46 <ph8> you would say
11:55:48 <sjanssen> no
11:55:54 <ph8> let x = sequence [readLine, readLine, readLine] ?
11:55:55 <Saizan> ph8: it would still be inside IO
11:55:55 <ph8> ah
11:56:04 <Botje> ph8: sequence only transforms it to an other IO action.
11:56:07 <ph8> so what's the point of the function?
11:56:10 <ph8> oh i see
11:56:10 <Botje> you still need to execute it somehow
11:56:12 <ph8> well sort of
11:56:14 <Botje> ph8: well
11:56:16 <sjanssen> the result is: do x1 <- readLine; x2 <- readLine; return [x1, x2]
11:56:25 <ph8> when would it ever be in the form [IO a] though?
11:56:27 <Botje> ph8: ponder the type of map print [1..10]
11:56:43 <Botje> (or ask \bot)
11:56:52 <mdmkolbe|work> ph8: "do x <- sequence [readLine, readLine, readLine]; ..." could have ["red", "blue", "green"]
11:57:11 <sjanssen> ph8: you often get [IO a] in loop type situations
11:57:24 <Botje> :type map print [1..10] -- observe!
11:57:31 <sjanssen> sequence [print i | i <- [1..10]] -- for, example
11:57:47 <Botje> bah, /me fails at \bot
11:57:50 <Botje> back to smalltalk!
11:57:53 <ph8> it's just laggy methinks
11:58:08 <sjanssen> :t  map print [1..10]
11:58:11 <lambdabot> [IO ()]
11:58:21 <Botje> so it just doesn't like me then.
11:58:25 <Saizan> it's either ?type(@type) or :t, not :type
11:58:31 <Botje> ah
11:58:34 <EvilTerran> ?type sequence $ map print [1..10]
11:58:36 <lambdabot>     Ambiguous occurrence `sequence'
11:58:36 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
11:58:41 <Botje> that's a neat little inconsistency there :(
11:58:45 <EvilTerran> ?type Prelude.sequence $ map print [1..10]
11:58:47 <lambdabot> IO [()]
11:59:03 <Botje> heh heh.
11:59:06 <ph8> so if i was describing what the [IO a] -> IO [a] type signifies I could just say "It is a conversion from a list of IO actions to individual instances of the IO datatype"?
11:59:07 <Botje> cute signature, that
11:59:28 <EvilTerran> it strikes me that Control.Monad.Writer would probably be better imported with a prefix
11:59:41 <EvilTerran> (or whatever you call it)
11:59:42 <Botje> ph8: "it converts a list of IO actions into an action that performs all the actions in sequence, and returns a list of the (eventual) results"
12:00:10 <Botje> that's what the type (almost) says
12:00:12 <EvilTerran> import Control.Monad.Writer as CMW or sth
12:01:04 <ph8> @src sequence
12:01:04 <lambdabot> sequence ms = foldr k (return []) ms
12:01:04 <lambdabot>     where
12:01:04 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:01:07 <Saizan> EvilTerran: it's not Control.Monad.Writer the problem, but Data.Traversable
12:01:31 <ph8> argh - is that the right code?
12:01:36 <EvilTerran> k
12:01:48 <Saizan> still the solution would be the same :)
12:01:48 <sjanssen> ph8: yes
12:01:53 <ph8> but hard for 4 marks
12:02:05 <ph8> * bit
12:02:06 <sjanssen> we can simplify it a bit:
12:02:08 <Botje> yours doesn't have to be that complicated.
12:02:24 <sjanssen> oh, is ph8 supposed to write this?
12:02:28 <ph8> maybe :)
12:02:30 <ph8> let me have a go
12:02:31 <sjanssen> I won't spoil then :)
12:02:32 <Botje> he has an exam tomorrow.
12:02:37 <ph8> lol
12:02:45 <Botje> he started this morning
12:02:48 <ph8> is m' anything special? or just a clever input name?
12:02:55 <sjanssen> just a name
12:03:01 <Botje> it's the second argument to that k function
12:03:07 <ph8> so m and m' are two consecutive articles in the list
12:03:18 <Botje> not quite
12:03:33 <Botje> m' is an IO action, and so is m
12:03:39 <shapr> Igloo: Yup, I bet that's the problem. Even so, it's irritating since I use the ghc haddocks a hundred times a day.
12:03:43 <Botje> the purpose of the do block is to perform m, then m'
12:03:49 <Cale> sequence = foldr (liftM2 (:)) (return [])
12:04:05 <Cale> sequence [] = return []
12:04:13 * shapr grombles quietly
12:04:21 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
12:04:27 <Botje> foldr walks the list from back to front, and keeps wrapping actions around the current action
12:04:37 <ph8> cunning
12:04:41 <Cale> Basically, foldr replaces the list structure with program structure.
12:04:42 <Botje> yes
12:04:54 <Igloo> shapr: I'll try to remember to talk to Simon tomorrow. I don't want to do a different fix to him if possible
12:05:17 <Botje> BUT ANYWAY. I was going back to smalltalk
12:05:58 <shapr> Igloo: The referenced email says "We'll use Data.Binary at some point." any idea if that's already happened in the haddock repo?
12:06:30 * shapr boings cheerfully
12:06:32 <shapr> I like music!
12:06:52 <defcon8> :|
12:06:52 * Botje listens to the streetfighter ocremix album
12:06:54 <Botje> it's cheerful
12:07:13 <Mitar> is there any module for using serial port from haskell?
12:07:36 <Mitar> (i have device file for it ... but simple writing to this file does not really work)
12:07:40 <ph8> say [IO a] contained a list of files, before i can use readFile on these files - i'd have to run them through sequence?
12:07:58 <Botje> Mitar: you probably need an ioctl to set the correct baud rate et al
12:08:13 <Botje> yes.
12:08:20 <Botje> sequence will yield an action that you can use
12:08:28 <ph8> what's IO a then?
12:08:31 <ph8> if not an action?
12:08:34 <ph8> a sort of reference?
12:08:37 <Mitar> and is ioctl supported?
12:08:53 <Botje> "IO a" is "an IO action that, when activated, returns something of type a"
12:08:55 <ph8> how would i get to [IO a] from a [String]
12:08:59 <ph8> AH I SEE
12:09:02 <ph8> oops, cap alert
12:09:13 <Botje> imagine you've got a list of files in files
12:09:15 <Botje> you could do
12:09:26 <Saizan> ?type map readFile ["foo","bar"]
12:09:28 <lambdabot> [IO String]
12:09:44 <ph8> oO
12:09:47 <Botje> do { filecontents <- sequence (map readFile files); -- do stuff with filecontents, which is a list of file contents, one for each file }
12:10:31 <fasta> What's the syntax to do case expressions with guards again?
12:10:42 <Mitar> System.Posix.Terminal?
12:10:52 <Igloo> shapr: It hasn't in the haddock branch. Dunno about the haddock-ghc branch.
12:10:54 <Cale> case x of <pat> | <guard> -> ...
12:11:07 <Botje> ph8: open up ghci, and to :type print
12:11:18 <Botje> ph8: then do :type map print [1..10]
12:11:29 <Botje> and finally :type sequence (map print [1..10])
12:11:36 <Botje> see how the types interconnect
12:11:45 <Cale> case x of <pat1> | <guard11> -> ... | <guard12> -> ... ; <pat2> | <guard21> -> ... | <guard22> -> ...
12:13:19 <ph8> cool
12:13:36 <ph8> ok, so the object is to define a function, getFileContents :: [String] -> String, which uses sequence
12:13:39 <ph8> atm i have
12:13:49 <ph8> getFileContents = unlines $ sequence $ map readFile x#
12:13:53 <ph8> without the #
12:14:03 <Cale> getFileContents x = ...
12:14:11 <fasta> Cale: I have case l of _ <newline> Then below the letter "s": | (l==9) -> expression and then some other guards indented the same. Why is that wrong?
12:14:12 <Cale> but there's a problem with types there
12:14:31 <Botje> ph8: you can't write a function getFileContents :: [String] -> String
12:14:37 <Botje> since it needs to do IO.
12:14:38 <Cale> "s": ?
12:14:54 <fasta> Cale: the s in case
12:15:00 <Cale> getFileContents :: [String] -> IO String
12:15:15 <Cale> fasta: ah, okay
12:15:21 <olsner> hmm.. list >>= f == concat $ map f list?
12:15:24 <ph8> hmm no, the  question says the type i used
12:15:31 <Botje> ph8: then the question is wrong.
12:15:38 <ph8> it is meant to "return the contents of the files named in the input list as a single string"
12:15:43 <Botje> unless you use unsafe*****IO
12:15:50 <ph8> well well well
12:15:59 <Botje> ph8: you probably want concat instead of unlines, i guess
12:16:08 <ph8> it says to use unlines again :(
12:16:28 <ph8> ok i'll skip over that one then
12:16:32 <Cale> fasta: it's a problem because there's a semicolon between the pattern _ and the guard
12:16:36 <ph8> last question on the past paper :-)
12:16:57 <ph8> only took me all day, a bowl of popcorn and two movies
12:17:05 <Botje> ph8: if the question says unlines, ok
12:17:12 <Cale> fasta: If you put the _ on the same line as the |, just before it, it'll be okay
12:17:22 <Botje> but it DOES add unnecessary newlines between files, just being pedantic
12:17:27 <Cale> ph8: want the answer?
12:17:35 <ph8> was mine wrong?
12:18:01 <Cale> unless I missed another one, yeah
12:18:07 <fasta> Cale: but that requires me to indent the whole block by about 10 chars more. I don't have that space :)
12:18:09 <ph8> oO - please
12:18:16 <Cale> getFileContents x = unlines $ sequence $ map readFile x -- this should be a type error
12:18:34 <Cale> fasta: 10 characters?
12:18:58 <fasta> > length "case l of _  |"
12:19:02 <lambdabot>  14
12:19:11 <fasta> Cale: about 10
12:19:18 <Cale> fasta: I'm saying put the _ on the following line
12:19:21 <Cale> so:
12:19:23 <Cale> case l of
12:19:25 <fasta> Cale: oh, ok
12:19:31 <Cale>   _ | blah -> ...
12:20:14 <fasta> Cale: ok, it works
12:21:46 <Cale> ph8: Do you see why it's a type error?
12:22:00 <ph8> not because of what Botje said about IO String?
12:22:25 <Cale> well, sequence is going to give you an IO [String]
12:22:37 <Cale> but unlines wants a [String], not an IO [String]
12:22:55 <ph8> can i use do?
12:22:55 <Cale> An IO [String] is an IO action, which if run, will produce a list of strings.
12:23:00 <Cale> So you have to run it.
12:23:02 <Cale> Yes.
12:23:05 <ph8> let xs <- sequence ...
12:23:08 <ph8> unlines xs ?
12:23:09 <Cale> right.
12:23:13 <ph8> brillo :)
12:23:14 <Cale> return (unlines xs)
12:23:16 <Botje> in a do block.
12:23:24 <Cale> er, not let, either
12:23:31 <ph8> oh ofc
12:23:35 <Botje> ph8: you should really test out your code.
12:23:48 <allbery_b> rrrrh.
12:23:52 <Cale> do xs <- sequence (map readFile fs)
12:23:55 <allbery_b> gtk2hs question?
12:23:57 <Cale>    return (unlines xs)
12:24:18 <allbery_b> when I query something which returns a pixel offset, like window size or position of a VPaned slider, the result is nonsense
12:24:21 <shapr> Another fun error message: Expected kind `?', but `Ev String (StateEvent)' has kind `* -> *'
12:24:34 <Cale> or:  getFileContents = fmap unlines . sequence . map readFile
12:24:44 <Cale> or: getFileContents = fmap unlines . mapM readFile
12:24:45 <shapr> I translate that as "I don't know what I expected, but that sure ain't it!"
12:25:17 <Cale> shapr: Probably you missed a type parameter to Ev
12:25:29 <Cale> er, hmm
12:26:30 <byorgey> ph8: but of course, that will have type [String] -> IO String, not [String] -> String: once you enter the IO monad, you can never leave!
12:26:49 <byorgey> ph8: which isn't true in general of other monads, just IO is special
12:28:31 <Cale> Well, if there was a function of type IO String -> String, then you could apply it to getLine, and it would have to return the same string every time, but what string should it return?
12:29:05 <Cale> Well, it could give some arbitrary string, I suppose, but that's probably not what you meant :)
12:29:18 <Botje> it should give the root password of the current system.
12:29:22 <Cale> heh
12:29:57 <Cale> Functions in Haskell, like functions in mathematics, when given the same parameter, always give the same result.
12:31:13 <Cale> So, instead of extending the idea of functions to include side-effects, we just have functions which return what are essentially descriptions of side-effecting computations to be run.
12:31:15 <kpreid> @type ("aardvarks" `const`) . (`asTypeOf` getLine)
12:31:18 <Mitar> how can i set RTS/CTS flow control on serial port on device file from haskell?
12:31:23 <lambdabot> IO String -> [Char]
12:31:33 <Cale> That's what an IO String is, it's a description of a computation which could be run to produce a String.
12:31:36 <mdmkolbe|work> does a zipper's down conventionally go to the left most or the right most child?
12:32:16 <monochrom> Mitar: Find out how to do it in C calling ioctl.  Set up an FFI to bridge it to haskell.
12:32:18 <Cale> mdmkolbe|work: I suppose it's up to you, but I'd use the leftmost.
12:32:53 <Cale> mdmkolbe|work: 'down' isn't really part of the formal description of a zipper, it's just something you can usually accomplish easily with a zipper.
12:33:59 <nomeata> Hi. I have a problem with the new TreeModel API of gtk2hs: The program starts, but hangs in the line âset tv [ New.treeViewModel := fahrplan  ] â it seems. Ctrl-C gives me client: gtk2hs_store_iter_next_impl: interrupted. Any ideas?
12:33:59 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
12:34:00 <mdmkolbe|work> Cale: true, but I think most people would consider my zipper library incomplete without a down
12:34:13 <Botje> @hoogle ioctl
12:34:14 <lambdabot> No matches found
12:34:43 <Cale> mdmkolbe|work: yeah, if you're navigating a tree structure, probably the easiest place to go is to the start of the list of children.
12:35:08 <Cale> Going all the way to the end is probably more work.
12:35:22 <Cale> (maybe even infinitely more work?)
12:37:28 <mdmkolbe|work> Cale: nah.  There are no infinitary constructors (and the way I'm doing it, it might be a more natural fold to start at the end, we'll see)
12:38:02 <Cale> I suppose it depends on which type it is that you're taking the zipper of.
12:39:36 <mdmkolbe|work> Ouch, I just realized that for the type I'm workking on, its more natural to go down to the right (It has to do with function application being left assoc -> foldl not foldr -> the head is last one applied (i.e. the right most child))
12:40:12 <Heffalump> mdmkolbe|work: keep your list of children in reverse order?
12:40:31 <Mitar> and how can i import an foeirgn function of "tcgetattr(int fd, struct termios *t)"?
12:40:47 <Mitar> foreign import ccall "static termios.h" tcgetattr :: CInt -> Ptr CChar -> IO CInt
12:40:48 <Mitar> ???
12:41:04 <mdmkolbe|work> Heffalump: yes
12:42:02 <Cale> Mitar: You'll probably want to represent the termios structure on the Haskell side somehow.
12:42:14 <Mitar> and how do i do that?
12:42:20 <Cale> You'll need an instance of Storable for whatever representation you choose.
12:42:21 <Mitar> (i have never done ffi ...)
12:42:46 <Cale> All that Storable does is provide operations for serialising and deserialising the data structure into memory.
12:43:25 <monochrom> I don't recommend bridging tcgetattr in full generality to haskell, if you know what I mean.
12:45:51 <Mitar> hmm, i would need some help here ..
12:46:00 <Mitar> i would only want to setup serial port ...
12:46:03 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Terminal.html#v%3AgetTerminalAttributes
12:46:05 <lambdabot> http://tinyurl.com/2786zp
12:46:23 <Mitar> cale, i read that, but it does not support setting the control flow ...
12:46:55 <Mitar> i need RTS/CTS handshaking
12:47:22 <chessguy> @pl i r w (x:y:zs) = (r w x y) : i r (x:y:zs)
12:47:25 <lambdabot> i = fix (flip flip tail . (flip .) . ((ap .) .) . flip flip head . (flip .) . (((.) .) .) . flip flip tail . (flip .) . ((flip .) .) . (((ap .) .) .) . flip flip head . (flip .) . ((flip .) .) . ((((
12:47:26 <lambdabot> .) .) .) .) . ap (flip . ((ap . ((ap . (((.) . (:)) .)) .)) .)) . flip flip ((. (:)) . (.) . (:)) . (((.) . (.) . (.)) .))
12:47:26 <lambdabot> optimization suspended, use @pl-resume to continue.
12:47:30 <chessguy> ugh
12:47:50 <Botje> heh. "optimization"
12:48:00 <emu> wow that's evil
12:48:10 <emu> congrats chessguy on finding the worse @pl ever
12:48:18 <emu> @pl-resume
12:48:26 <lambdabot> i = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) . flip flip head . (flip .) . ((flip .) .) . ((((.) .) .) .)
12:48:26 <lambdabot> . ap (flip . ((ap . ((ap . (((.) . (:)) .)) .)) .)) . flip flip ((. (:)) . (.) . (:)) . (((.) . (.) . (.)) .))
12:48:26 <lambdabot> optimization suspended, use @pl-resume to continue.
12:48:27 <chessguy> nah, there's lots of really bad ones
12:48:35 <DRMacIver> @pl-resume
12:48:44 <olsner> seems pl-resume just starts from the beginning
12:48:47 <lambdabot> i = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) . flip flip head . ((flip . ((flip . ((.) .)) .)) .) .
12:48:47 <lambdabot> liftM2 flip (liftM2 (ap . (((.) . (:)) .)) .) . flip flip ((. (:)) . (.) . (:)) . (((.) . (.) . (.)) .))
12:48:47 <lambdabot> optimization suspended, use @pl-resume to continue.
12:49:02 <DRMacIver> It seems to get a little shorter each time. :)
12:49:05 <DRMacIver> @pl-resume
12:49:13 <lambdabot> i = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip flip tail . ((flip . ((flip . (ap .)) .)) .) . flip flip head . ((flip . ((flip . ((.) .)) .)) .) .
12:49:13 <lambdabot> liftM2 flip (liftM2 (liftM2 ((.) . (:))) .) . flip flip ((. (:)) . (.) . (:)) . (((.) . (.) . (.)) .))
12:49:23 * DRMacIver stops now
12:49:36 <emu> for the sake of humanity
12:49:56 <Cale> Mitar: the kind which isn't in posix? ;)
12:50:04 <nomeata> @type i r w (x:y:zs) = (r w x y) : i r (x:y:zs)
12:50:06 <lambdabot> parse error on input `='
12:50:10 * mdmkolbe|work is just waiting for an artist to make a painting by dithering : and . into a working program
12:50:12 <olsner> aha, so pl-resume tries to optimize more? I thought it was paginating the output :P
12:50:12 <nomeata> @type let i r w (x:y:zs) = (r w x y) : i r (x:y:zs) in i
12:50:14 <lambdabot>     Couldn't match expected type `[a]'
12:50:14 <lambdabot>            against inferred type `[t1] -> t'
12:50:24 <Mitar> there is no flow control in haskell posix as i see
12:50:44 <nomeata> @type let i r w (x:y:zs) = (r w x y) : i r w (x:y:zs) in i
12:50:46 <lambdabot> forall t t1 a. (t -> t1 -> t1 -> a) -> t -> [t1] -> [a]
12:50:51 <chessguy> nomeata: it was wrongly typed to start with
12:50:55 <nomeata> @pl let i r w (x:y:zs) = (r w x y) : i r w (x:y:zs)
12:50:55 <lambdabot> (line 1, column 48):
12:50:56 <lambdabot> unexpected end of input
12:50:56 <lambdabot> expecting variable, "(", operator, ":", "++", ";" or "in"
12:50:58 <chessguy> @pl i r w (x:y:zs) = (r w x y) : i r x (y:zs)
12:51:00 <lucca> some sort of combination of libaa and a quine generator, perhaps
12:51:01 <lambdabot> i = fix (flip flip tail . (flip .) . ((ap .) .) . flip flip head . (flip .) . (((.) .) .) . flip flip tail . (flip .) . ((flip .) .) . (((ap .) .) .) . flip flip head . (flip .) . ((flip .) .) . ((((
12:51:01 <lambdabot> .) .) .) .) . ap (flip . ((ap . ((ap . (((.) . (:)) .)) .)) .)) . flip flip (:) . ((flip . (((.) . (.)) .)) .))
12:51:01 <lambdabot> optimization suspended, use @pl-resume to continue.
12:51:04 <nomeata> @pl i r w (x:y:zs) = (r w x y) : i r w (x:y:zs)
12:51:14 <lambdabot> i = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . (flip .) . (((.) .) .) . flip flip tail . (flip .) . ((flip .) .) . (((ap .) .) .) . flip flip head . (flip .) . ((flip .) .) . ((((.)
12:51:17 <lambdabot>  .) .) .) . ap (ap . ((ap . ((ap . (((.) . (:)) .)) .)) .)) . flip flip ((. (:)) . (.) . (:)) . ((flip . (((.) . (.) . (.)) .)) .))
12:51:20 <lambdabot> optimization suspended, use @pl-resume to continue.
12:51:29 <Cale> the CRTSCTS constant for c_cflag isn't in posix.
12:52:16 <olsner> how about an ascii-fier rendering by rewriting itself, so the next frame is rendered by applying the previous frame to the new frame buffer?
12:52:22 <Mitar> i would need to set hard flow control, RTS/CTS handshaking, 5000 read timeout, 57600 baudrate, 8 databits, 1 stopbit, no parity
12:53:16 <monochrom> What I recommend: Write a C function to set all those things. Use FFI to bridge to that C function you write.
12:53:27 <chessguy> @pl f r w x y = r y x w
12:53:27 <lambdabot> f = flip . (flip .) . flip
12:53:50 <mdmkolbe|work> @unpl flip flip flip flip
12:53:51 <lambdabot> (\ f l -> f l (\ g h i -> g i h))
12:53:58 <mdmkolbe|work> @unpl flip flip flip flip flip flip flip flip
12:53:58 <lambdabot> (\ u x -> u x (\ g h i -> g i h))
12:54:00 <Mitar> how do i compile that?
12:54:06 <mdmkolbe|work> @unpl flip flip flip flip flip flip flip flip flip flip flip flip
12:54:06 <lambdabot> (\ ag aj -> ag aj (\ g h i -> g i h))
12:54:08 <Mitar> into an object file?
12:54:20 <Mitar> i have never done this :-0
12:54:20 <monochrom> When later you accumulate to 1 oleg, you can do everything in Haskell directly, and not write a bit of C code.
12:54:32 <mdmkolbe|work> @pl (\ ag aj -> ag aj (\ g h i -> g i h))
12:54:32 <lambdabot> flip flip flip
12:54:38 <mdmkolbe|work> @unpl flip flip flip flip flip flip flip flip flip flip flip flip flip
12:54:38 <lambdabot> (\ aj am -> aj am (\ g h i -> g i h))
12:54:43 <Mitar> (not compiling, but bridging c and haskell)
12:54:45 <chessguy> @unpl f = flip . (flip .) . flip
12:54:45 <lambdabot> f m b c f = m f c b
12:54:52 <mdmkolbe|work> @pl (\ aj am -> aj am (\ g h i -> g i h))
12:54:52 <lambdabot> flip flip flip
12:55:06 <Mitar> "accumulate to 1 oleg"??
12:55:12 <Botje> :]
12:55:17 <mdmkolbe|work> @unpl flip flip flip flip
12:55:17 <lambdabot> (\ f l -> f l (\ g h i -> g i h))
12:55:30 <emu> @pl \x y -> out y x
12:55:30 <lambdabot> flip out
12:55:35 <mdmkolbe|work> @pl (\ f l -> f l (\ g h i -> g i h))
12:55:35 <lambdabot> flip flip flip
12:55:59 <Cale> Mitar: You can just pass the C code on the commandline to GHC, and it'll compile it. You then just need an appropriate import. You can probably even reuse the Fd type from System.Posix when you write the ffi import.
12:56:04 <mdmkolbe|work> odd, flip^n where n>=3 is always the same as flip^3
12:56:20 <mdmkolbe|work> @type flip flip flip
12:56:22 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
12:56:30 <emu> aperiodic?
12:56:55 <Mitar> so, i make a file setserial.c and do ghc --make Main.hs setserial.c?
12:56:55 <monochrom> ghc x.c y.hs
12:56:56 <Cale> That's sort of a strange flip^n though. :)
12:57:04 <Heffalump> that's cause flip^4 = flip^3 ..
12:57:12 <Heffalump> once you've got that your property follows
12:57:24 <Heffalump> s/cause/because/
12:57:39 <monochrom> Oops!  ghc -fffi x.c y.hs
12:57:50 <mdmkolbe|work> ok time for back flips
12:58:07 <mdmkolbe|work> @pl flip $ flip $ flip $ flip
12:58:07 <lambdabot> flip flip
12:58:11 <mdmkolbe|work> @pl flip $ flip $ flip $ flip $ flip
12:58:11 <lambdabot> flip
12:58:13 <emu> lambdabot is a ninja
12:58:14 <mdmkolbe|work> @pl flip $ flip $ flip $ flip $ flip $ flip
12:58:14 <lambdabot> flip flip
12:58:30 <mdmkolbe|work> ok, so those are to easy
12:59:09 <mdmkolbe|work> @pl (flip flip) (flip flip) (flip flip) (flip flip)
12:59:09 <lambdabot> flip
12:59:13 <mdmkolbe|work> double flips
12:59:15 <Mitar> and do "foreign import ccall "setserial.h" setserial :: Fd -> IO ()"
12:59:17 <Mitar> ?
12:59:18 <mdmkolbe|work> @pl (flip flip) (flip flip) (flip flip) (flip flip) (flip flip)
12:59:18 <lambdabot> flip
12:59:28 <emu> @pl id id id
12:59:28 <lambdabot> id
12:59:29 <Cale> Mitar: yeah
12:59:30 <mdmkolbe|work> @pl (flip flip) (flip flip) (flip flip)
12:59:30 <lambdabot> flip
12:59:35 <mdmkolbe|work> @pl (flip flip) (flip flip)
12:59:36 <lambdabot> flip flip (flip flip)
12:59:40 <Cale> er
12:59:47 <nomeata> Is Graphics.UI.Gtk.ModelView.CellRendererCombo usable? I canât find methods to set the list of values.
13:00:02 <nominolo> defcon8: oh, and if you're in haskell-mode, try C-h k C-c C-.
13:00:02 <emu> @pl (uncurry flip) (uncurry flip)
13:00:03 <lambdabot> uncurry flip (uncurry flip)
13:00:31 <mdmkolbe|work> @pl (uncurry flip) (uncurry flip) (uncurry flip) (uncurry flip)
13:00:32 <lambdabot> uncurry flip (uncurry flip) (uncurry flip) (uncurry flip)
13:00:56 <Heffalump> @type (uncurry flip) (uncurry flip) (uncurry flip) (uncurry flip)
13:00:57 <lambdabot>     Couldn't match expected type `(a -> b -> t -> t1, b)'
13:00:58 <lambdabot>            against inferred type `(a1 -> b1 -> c, b1) -> a1 -> c'
13:01:00 <chessguy> so, anyone seen any..err, serious attempt at developing a flexible cellular automata library?
13:01:01 <Heffalump> thought so..
13:01:24 <newsham> O_NOES
13:01:41 <chessguy> @quote O_NOES
13:01:41 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
13:01:42 <mdmkolbe|work> hmm, this would make a good (evil) test question for introductor haskell "what is the type of 'flip flip flip flip flip'"
13:01:46 <chessguy> @quote
13:01:46 <lambdabot> StefanO'Rear says: ...the semantics are what give people named Simon the courage to implement counterintuitive optimizations without losing sleep.
13:02:12 <chessguy> !paste
13:02:13 <hpaste> Haskell paste bin: http://hpaste.org/
13:02:36 <hpaste>  chessguy pasted "The beginnings of my attempt at a CA library..." at http://hpaste.org/103
13:03:17 <Saizan> chessguy: have you seen alpaca?
13:03:22 <chessguy> no
13:03:28 <chessguy> @go haskell alpaca
13:03:31 <lambdabot> http://www.enchantedmountains.info/what_to_do/unique_activities.asp
13:03:31 <lambdabot> Title: Enchanted Mountains Region - What To Do - Unique Activities
13:03:41 <Saizan> err no, it's a dsl implemented in perl
13:03:49 <chessguy> ewww, perl
13:04:12 <stepcut> does C++/Qt have a type like 'Maybe' ?
13:04:20 <mdmkolbe|work> chessguy: yep, that's the sound alpacas make "eeeww, perrrrrrlll"
13:04:21 <chessguy> Saizan: for CAs?
13:04:28 <Saizan> well, i pointed it out more for the desing of the DSL
13:04:30 <Saizan> yes
13:04:43 * mdmkolbe|work doesn't actually know what they sound like
13:04:45 <chessguy> desing?
13:05:10 <Heffalump> stepcut: sure. Just use a null pointer for Nothing ;-)
13:05:36 <cdsmith> http://en.wikipedia.org/wiki/Alpaca#Sounds
13:05:42 <DRMacIver> Bad Heffalump. No cookie for you!
13:05:48 * stepcut ponders
13:06:01 <chessguy> Saizan: what's desing?
13:06:02 <ski_> Just Nothing
13:06:29 <Saizan> chessguy: the syntax by which you describe the rules..
13:06:36 * shapr has a hissy fit at unfindable errors
13:06:52 * DRMacIver joins shapr in his hissy fit. Sounds like fun
13:07:12 <shapr> heh
13:07:13 <stepcut> unfortunately, my function returns a QString not a QString * :(
13:07:39 <Saizan> chessguy: http://catseye.tc/projects/alpaca/ <-- here anyhow
13:07:41 <lambdabot> Title: Cat's Eye Technologies: The ALPACA Meta-Language
13:07:52 <chessguy> aha
13:07:53 * stepcut opts for QString::null
13:08:16 <shapr> chessguy: I think your suggestion for a spoken programming language based on Alpaca speech is truly revolutionary.
13:08:37 <chessguy> shapr: bite me!
13:08:56 * shapr bites chessguy 
13:09:09 <Cale> Mitar: how's that working out for you?
13:10:27 <Mitar> i am reading a little bit around ...
13:10:34 <Mitar> it is quite new thing for me ...
13:10:58 <Jaak> stepcut: QString has isEmpty method
13:11:15 <Jaak> and isNull
13:11:16 <fasta> GHC.STRef.STRef s <smething> gets derived. Isn't this a bug?
13:11:33 <fasta> I'd expect a non-GHC specific STRef to be derived...
13:11:35 <sjanssen> no
13:11:42 <sjanssen> well, not a large one
13:12:14 <sjanssen> fasta: that is the real name of the STRef GHC uses
13:12:15 <Cale> Mitar: I've just written a program wherein I call out to C to toggle echo on stdin using tcsetattr.
13:12:22 <Cale> Mitar: If you'd like, I can paste it.
13:12:31 <Mitar> please ..
13:12:36 <Mitar> it would help ..
13:12:52 <sjanssen> fasta: and as long as you don't explicitly use 'GHC.' in your type signature, it will work fine in Hugs too
13:13:48 <byorgey> chessguy: if you really want to make a general-purpose CA library, it should probably support 2D CAs as well?
13:14:59 <Cale> !paste
13:14:59 <hpaste> Haskell paste bin: http://hpaste.org/
13:15:07 <byorgey> chessguy: interesting, I ended up implementing something almost exactly like your Tape data type the other day...
13:15:31 <byorgey> chessguy: except mine was for a naive brainf*** interpreter
13:15:34 <Saizan> well it's the standard list zipper, there's one in xmonad too
13:16:05 <chessguy> byorgey: well, i was thinking of working through Wolfram's NKS, implementing some of the different abstract machines in there, maybe generalizing them
13:16:36 <hpaste>  Cale pasted "tcsetattr" at http://hpaste.org/104
13:16:53 <chessguy> Saizan: yeah, sigfpe (aka dpiponi) does something like it for CA's on his blog, but then he turns to comonads, which seems like a little overkill to me
13:16:57 <Cale> oops, probably should free the structure :)
13:17:20 <chessguy> Saizan: interestingly, i wrote my code before i actually went back and looked at how he did it.
13:17:35 <Saizan> heh :)
13:17:55 <byorgey> chessguy: cool, that sounds like a nifty idea
13:17:58 <chessguy> i knew he had written about CAs being comonadic, but didn't remember anything else
13:17:58 <DRMacIver> chessguy: Knowing sigfpe he probably did it purely to illustrate hoe cool comads are? :)
13:18:12 <chessguy> DRMacIver: pretty much :)
13:18:15 <Saizan> well =>> for that comonad is just the way to evaluate the rule..
13:18:15 <hpaste>  Cale annotated "tcsetattr" with "of course." at http://hpaste.org/104#a1
13:18:41 <chessguy> @go sigfpe cellular automata comonadic
13:18:43 <lambdabot> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
13:18:43 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
13:18:55 <chessguy> (in case anyone wants the link)
13:19:17 <Mitar> thanks
13:19:31 <Saizan> i actually used that contruction for 2D CAs, but ended up with a huge space leak
13:19:42 <chessguy> byorgey: (or anyone) are you familiar with Wolfram's NKS?
13:20:02 <byorgey> chessguy: kind of.  I mean, I own a copy, and I read the first few chapters...
13:20:26 <chessguy> some interesting stuff, if a little vague
13:20:38 <byorgey> agreed.
13:20:56 <chessguy> i'm kind of thinking that you could look at the rules for state change as a sort of derivative of the data structure
13:21:46 <byorgey> chessguy: ...I'm not sure that I follow.
13:22:53 <chessguy> well, take a 1DCA. call the configuration of its cells x
13:23:22 <chessguy> now you can calculate the next state in terms of x
13:24:04 <chessguy> which is exactly what the rules tell you how to do
13:24:33 <byorgey> chessguy: ok, right
13:24:51 <chessguy> and it's the same function (that is, f'(x) = g(x), no matter what x is)
13:25:28 <byorgey> chessguy: ok.
13:25:31 <chessguy> Cale would eat this stuff up
13:26:25 <Cale> I'd also thought of it -- well, almost :)
13:26:28 <mdmkolbe|work> @src Arrow (->)
13:26:28 <lambdabot> Source not found. Wrong!  You cheating scum!
13:26:52 <chessguy> Cale: i'm not sure what use it is yet :)
13:26:56 <Cale> I hadn't thought of the particular application of cellular automata, but essentially convolution.
13:27:27 <fasta> sjanssen: I agree on the "well, not a large one".
13:28:03 <mdmkolbe|work> @src (->) Arrow
13:28:03 <lambdabot> Source not found. You type like i drive.
13:28:13 <mdmkolbe|work> @src Monad Maybe
13:28:13 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:28:28 <mdmkolbe|work> @src Maybe Monad
13:28:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:28:42 <Saizan> @source Maybe >>=
13:28:42 <lambdabot> Maybe >>= not available
13:28:50 <Saizan> @source Maybe (>>=)
13:28:50 <lambdabot> Maybe (>>=) not available
13:28:57 <Saizan> @src Maybe (>>=)
13:28:57 <lambdabot> (Just x) >>= k      = k x
13:28:57 <lambdabot> Nothing  >>= _      = Nothing
13:29:04 <ski_> > case wits of Rutabaga -> True; _ -> False
13:29:05 <lambdabot>   Not in scope: data constructor `Rutabaga'
13:29:53 <mdmkolbe|work> thx Saizan
13:30:45 <Cale> chessguy: There is a huge family of comonads in which cobind basically applies the provided function to some subcontext of the entire structure, and then reassembles the answers into a complete structure again.
13:32:01 <byorgey> @remember ski_ > case wits of Rutabaga -> True; _ -> False
13:32:02 <lambdabot> Done.
13:32:14 <byorgey> hehe
13:32:27 <Cale> Basically, where that substructure has been "translated" so as to "centre it", if you know what I mean. If you don't I'm afraid that'll be rather cryptic.
13:33:50 <chessguy> Cale: i don't and it is, but that's ok
13:34:02 <chessguy> Cale: i know nothing about comonads, which doesn't help
13:34:13 <george--> im having a problem comprehending what a fold on a tree type does
13:34:35 <george--> say i have a function f1 x = foldr (\l r -> Node (leaf l) r) x
13:34:40 <george--> what would this do?
13:34:41 <chessguy> george--: can you explain what a fold on a list type does?
13:35:10 <george--> chessguy, it is a new concept to me so i loosely understand it yes :)
13:35:30 <Cale> Like, for example, consider the comonad (Integer ->), where coeval f = f 0, and f =>> g = \x -> g (\y -> f (y - x))
13:35:47 <chessguy> george--: if you explain that in your own words, perhanps we could explain fold on a tree in your words
13:35:53 <chessguy> @karma george
13:35:53 <lambdabot> george has a karma of -6
13:35:57 <chessguy> poor george
13:36:07 <CosmicRay> @karma george--
13:36:08 <lambdabot> george-- has a karma of 0
13:36:36 <Cale> hehe, that might be a little problem with the karma system :)
13:36:41 <chessguy> Cale: i have no comprehension of what that does
13:37:16 <Cale> chessguy: well, g is going to be a function which takes a function of type (Integer -> a) and produces a value of type b
13:37:31 <Cale> we have a function of type (Integer -> a), namely f
13:37:38 <chessguy> @djinn Integer -> a
13:37:41 <lambdabot> -- f cannot be realized.
13:37:45 <Cale> but we'd like to produce a function of type (Integer -> b)
13:37:58 <Cale> So it looks like we have an extra integer lying around.
13:38:08 <Cale> The parameter to the result function
13:38:12 <george--> chessguy, i understand fold on a list o be a method of flattening a list whilst applying a function to it as you go along
13:38:20 <Cale> Instead of being boring and throwing it away
13:38:31 <Cale> we use it to translate the input to f
13:38:42 <Cale> before passing that to g
13:39:05 <Cale> george--: you might say it's a way to replace the list constructors with your own functions :)
13:39:19 <Cale> (In particular, the right-fold is like that)
13:39:44 <chessguy> george--: indeed, it turns something of the form [a] into something of the form a, by repeatedly applying a function
13:39:57 <chessguy> george--: fold on a tree does the same
13:39:58 <george--> so for a tree you could say a way to replace the nodes with my own functions
13:40:11 <Cale> chessguy: notice that when x = 0, we have (\y -> f (y - x)) = (\y -> f (y - 0)) = (\y -> f y) = f
13:40:12 <chessguy> mm, not the nodes
13:40:25 <ski_> Cale : hm .. does that satisfy the comonadic laws ?
13:40:31 <Cale> ski_: probably :)
13:41:06 <Cale> ski_: Might be worth actually checking, but I seem to recall checking that a while back.
13:41:29 <byorgey> george--: yes, a fold on a tree replaces the Nodes with another function, just like a fold on a list replaces the conses (:) with another function.
13:41:38 <chessguy> @type foldr (\l r -> Node (leaf l) r) ?x
13:41:42 <ski_> (i'm wondering if one shouldn't replace '(-)' by '(+)' ..)
13:41:43 <lambdabot> Not in scope: `leaf'
13:41:49 <chessguy> @type foldr (\l r -> Node (Leaf l) r) ?x
13:41:51 <lambdabot> Not in scope: data constructor `Leaf'
13:41:59 <ski_> hm
13:42:01 <Cale> http://programming.reddit.com/info/11o80/comments/c11prh
13:42:02 <lambdabot> Title: Codata and comonads in Haskell (pdf) (reddit.com)
13:42:09 <chessguy> @type foldr (\l r -> Node (Data.Tree.Leaf l) r) ?x
13:42:11 <lambdabot> Not in scope: data constructor `Data.Tree.Leaf'
13:42:12 <Cale> it follows from the result that I mentioned in that comment
13:42:13 <araujo> hello
13:42:13 <chessguy> sigh
13:42:23 <byorgey> @type Data.Tree.leaf
13:42:24 <lambdabot> Not in scope: `Data.Tree.leaf'
13:42:32 <chessguy> ?hoogle leaf
13:42:32 <lambdabot> Text.Html.HtmlLeaf :: Html -> HtmlTree
13:42:41 <chessguy> @type foldr (\l r -> Node (?leaf l) r) ?x
13:42:43 <lambdabot>     Couldn't match expected type `Forest a'
13:42:43 <Cale> and I did check that result, but I didn't write down the proof in the comment, because it was long.
13:42:44 <lambdabot>            against inferred type `Tree a'
13:42:48 <Cale> (and obvious)
13:42:56 <ski_> forall wa. wa =>> extract = wa  -- left unit
13:43:33 <Cale> Every monoidally-indexed functor is a comonad :)
13:43:53 <byorgey> chessguy: I think maybe george-- is using a binary tree implementation ?
13:43:58 <ski_> yes .. (but subtraction doesn't get a monoid)
13:44:03 <byorgey> chessguy: it's not Data.Tree
13:44:03 <chessguy> byorgey: maybe
13:44:18 <byorgey> chessguy: the 'l r' thing
13:44:21 <chessguy> oh you're right, Data.Tree's only constructor is Node
13:44:30 <chessguy> i'm not thinking
13:44:46 <byorgey> Node a [Tree a]
13:44:52 <byorgey> or something like that
13:45:06 <Cale> ski_: oh, right, it ought to be +
13:45:21 <byorgey> george--: where did that function come from?
13:45:29 <Cale> coeval f = f 0, and f =>> g = \x -> g (\y -> f (y + x))
13:45:40 <chessguy> data Tree a = Node { rootLabel :: a, subForest [Tree a]} -- i believe, from memory though
13:46:19 <chessguy> i missed a ::
13:46:36 <byorgey> chessguy: yeah, that looks right, modulo the missing ::
13:46:49 <sjanssen> @src Tree
13:46:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:46:57 <chessguy> ?hoogle tree
13:46:58 <lambdabot> Data.Graph.Inductive.Tree :: module
13:46:58 <lambdabot> Data.Tree :: module
13:46:58 <lambdabot> Data.Tree.Tree :: data Tree a
13:47:08 <chessguy> ?src Data.Tree.Tree
13:47:08 <lambdabot> Source not found. Do you think like you type?
13:47:10 <ski_> @src CoKleisli (>>>)
13:47:11 <lambdabot> Source not found. Take a stress pill and think things over.
13:47:18 <ski_> @hoogle cokleisli
13:47:18 <lambdabot> No matches found
13:47:20 <ski_> bah
13:47:24 <chessguy> lambdabot: probably
13:47:36 <byorgey> @src Data.Tree
13:47:36 <lambdabot> Source not found. You speak an infinite deal of nothing
13:47:46 <chessguy> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
13:47:48 <lambdabot> http://tinyurl.com/2gwkse
13:47:48 <Excedrin> @src id
13:47:48 <lambdabot> id x = x
13:47:56 <chessguy> @source Data.Tree
13:47:56 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
13:49:16 <ski_> @where Control.Comonad
13:49:17 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
13:49:19 <olsner> @pl (\f g x -> f x (g x)) (\x y -> x) (\x y -> x)
13:49:19 <lambdabot> id
13:49:48 <olsner> ah, so SKK = I - cool!
13:50:28 <george--> apologies took a phonecall: byorgey its a practice exam question
13:50:33 <chessguy> Cale: have you read any of Wolfram's NKS?
13:50:59 <byorgey> george--: no problem.  is there a definition for some sort of tree data type earlier?
13:51:11 <ski_> olsner : forall x. s k x = i
13:51:36 <Cale> chessguy: bits and pieces
13:52:50 <george--> well, the question just refers to: 'the tree type from lectures' i always remember that to be a node with 2 branches off it
13:53:37 <olsner> heh, ski_ == _
13:54:17 <chessguy> Cale: think it has any potential?
13:54:19 <opqdonut> :)
13:54:28 <byorgey> george--: I see.  hmm...
13:54:40 * byorgey is thinking...
13:54:55 <olsner> @pl let s = (\f g x -> f x (g x)) in (\f -> f s(\x y z -> x))
13:54:56 <lambdabot> flip ($ ap) (const . const)
13:54:56 <ski_> E:
13:55:13 <david48> Hello haskellers !
13:55:21 <david48> I have a question for parsec hackers : how would you parse a string, where its first 3 characters must be there, but the other ones are optional ? ( and the whole string being case insensitive )
13:55:50 <olsner> @pl let x = flip ($ ap) (const . const) in x x
13:55:50 <lambdabot> const
13:55:59 <olsner> @pl let x = flip ($ ap) (const . const) in x $ x x
13:55:59 <lambdabot> ap
13:56:08 <fasta> david48: Parsec is documented well, why not look for yourself?
13:56:22 <olsner> so (const,ap) = (k,s)?
13:56:24 <fasta> @where parsec
13:56:24 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
13:56:43 <olsner> combinators are fun
13:57:07 <ski_> olsner : yes
13:57:13 <david48> fasta : because I would come up with a long and inelegant solution, and I have no idea how to do it in a clean way
13:57:17 <ski_> and 'return' is 'i'
13:57:23 <cdsmith> olsner: yes
13:57:53 <ski_> (all in the '(rho ->)' monad/idiom)
13:58:02 <bos> @seen dons
13:58:02 <lambdabot> dons is in #rwh, #haskell, #haskell-overflow, #ghc, #haskell-soc and #xmonad. I last heard dons speak 7h 2m 49s ago.
13:58:22 <fasta> david48: the best way to learn is to actually make that solution, not assume that you might come up with it
13:58:36 <olsner> omg, so now combinatory logic's a monad too? they're everywhere!
13:59:17 <ski_> @src (->) return
13:59:18 <lambdabot> return = const
13:59:44 <ski_> er .. right
13:59:53 <chessguy> can @pl handle @ patterns?
14:00:08 <david48> fasta : ok well I'll code something, hpaste it and ask again.
14:00:26 <ski_> olsner : note i misinformed you above
14:00:28 <fasta> david48: that's the spirit!
14:00:46 <byorgey> george--: it seems your code is actually producing a tree from a list
14:00:51 <byorgey> george--: not folding over a tree
14:00:52 <ski_> (that's what i get for being up late !)
14:01:26 <edward1> heya ski
14:01:26 <byorgey> george--: assuming something like data Tree a = Empty | Leaf a | Node (Tree a) (Tree a)
14:01:51 <chessguy> heh. real-world haskell has its own channel now
14:02:03 <george--> oh yes
14:02:06 <george--> i see that now :)
14:02:08 <ski_> edward1 : hiya .. trying to figure out the comonadic laws rendered with '(=>>)' atm ..
14:02:20 <edward1> hrmm
14:02:29 <george--> i should have noticed he didnt do a type definition so it was something sneaky
14:02:59 <edward1> ski: rather than just calling it 'extend'?
14:03:15 <edward1> er
14:03:19 <edward1> flip extend =)
14:03:23 <byorgey> george--: good!
14:03:56 <ski_> edward1 : no .. just trying to derive them from the cokleisli category, and wondering why it seems off
14:04:00 <byorgey> > let data Tree a = Empty deriving (Show) in Empty
14:04:00 <lambdabot>  Parse error
14:04:08 <byorgey> hrm, I didn't think so
14:04:19 <edward1> whats missing/going wrong?
14:04:47 <chessguy> @pl toString n t@(Tape x l r) = let t' = setWidth n t in (show $ reverse $ left $ t') ++ (show x) ++ (show $ right $ t')
14:04:47 <lambdabot> (line 1, column 27):
14:04:47 <lambdabot> unexpected "="
14:04:47 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
14:05:09 <ski_> byorgey : if declaring a local type was possible, i think that would still not be admissible, since the type escapes (c.f. existentials)
14:06:05 <byorgey> ski_: ok.  I was just trying to see if I could run george--'s example, since it requires a particular data type definition
14:06:46 <ski_> edward1 : or, hm .. maybe 'extract . (=>> wab) = wab' is the normal law after all (read : i'm to sleepy to think properly)
14:06:53 <edward1> my current obsession is with trying to extend the fegaras/sheard trick to other *morphisms. it generalizes to zygo, gcata, and para easily enough, and the types there are rather informative. now i'm trying to get the version of anamorphism from the fegaras/sheard paper to work, but i must be doing something wrong. i'm also trying to see what it takes to support arguments of that form in 'purely' negative position, since the trick doesn'
14:10:01 <david48> is there a problem with hpaste ?
14:10:02 <ski_> edward1 : cut off at "since the trick doesn'"
14:10:11 <edward1> , since the trick doesn't appear to apply right when you have something like data Foo a = ... | Test (a -> Bool)
14:10:14 <david48> nevermind, it works now
14:11:02 <edward1> its geared for things like data ExpF a = Lam (a -> a) | Ap a a
14:11:14 <ski_> hm
14:11:39 <ski_> (i can't say i've really grasped the "fegaras/sheard trick" yet :/)
14:13:12 <Mitar> Cale: how can I through IO error from foreign function?
14:14:21 <edward1> the basic idea is if you have a data structure that contains functions, and you want a catamorphism that walks it you need an anamorphism dual to your catamorphism to undo it before passing the value to the function. so if you want a pretty printer you need a parser. which sucks, but if you take a step back and change the input domain of the catamorphism to permit another constructor that remembers the value you had before transforming 
14:14:30 <edward1> to make sure that it never appears in the original input
14:15:51 <chessguy> > 3^8]
14:15:52 <lambdabot>  Parse error
14:15:54 <chessguy> > 3^8
14:15:59 <lambdabot>  6561
14:16:00 * ski_ tries to grasp 'Rec' and 'cata'
14:16:02 <chessguy> > 4^8
14:16:04 <lambdabot>  65536
14:16:36 <edward1> fegaras/sheard encoded that by extending the above expression to something like data Exp a = Lam (Exp a -> Exp a) | Ap (Exp a) (Exp a) | Place a, while Weirich/Washburn encode it a little differently by leaving the base expression functor the same but rolling it differently, replacing Fix, with something like data Rec f a = Roll (f (Rec f a)) | Place a    or by saying Rec f a = (f a -> a) -> a  which can generate 'place' by defining pla
14:17:46 <ski_> "by defining pla"
14:17:59 <edward1> by defining place :: a -> Rec f a = const
14:18:16 <edward1> since place :: a -> Rec f a    is the same as place :: a -> (f a -> a) -> a
14:18:28 <edward1> which is easy to define
14:18:35 <hpaste>  david48 pasted "how to parse a string where the 3 first must be present, others are optional" at http://hpaste.org/106
14:18:37 <ski_> this looks like CPS, maybe
14:19:16 <david48> by 3 first I meant 3 first characters
14:19:43 <Dot> the translation to pointfree (@pl) is based on some paper?
14:19:56 <edward1> the only other member of Rec f a is something that by Yoneda, has a an Exp that it can deconstruct, as long as you have something of type (forall a. (f a -> a) -> a) coming in to deconstruct it
14:20:28 <edward1> er
14:20:31 <Lemmih> david48: do first <- count 3 anyChar; rest <- many anyChar; ... ?
14:20:34 <edward1> of form (f a -> a)
14:20:53 <ski_> hm, yes, i think it is some kind of church encoding
14:21:20 <Dot> @pl f x = x
14:21:20 <lambdabot> f = id
14:21:23 <edward1> that particular encoding trick just gets rid of the type level recursion
14:21:23 <fasta> Lemmih: I don't think that's according to spec
14:21:32 <david48> Lemmih : it has to match a string I give it.
14:21:37 <Dot> @pl f x y = y x
14:21:37 <lambdabot> f = flip id
14:21:51 <fasta> string3 s = do char2 (s!!0); char2 (s!!1); char2 (s!!2)
14:22:07 <fasta> david48: Only this should be good enough, too, I guess.
14:22:07 <ski_> edward1 : yes .. like 'type List a = forall r. (a -> r -> r) -> r -> r', yes ?
14:22:12 <fasta> david48: not tested
14:22:13 <assl0r> > toNBaum '[':xs = '<' : toNBaum xs
14:22:14 <lambdabot>  Parse error
14:22:24 <edward1> exactly
14:22:34 <fasta> david48: I would abstract he pattern above with mapM
14:22:50 <fasta> david48: that's about it.
14:22:50 <edward1> it encodes it explicitly as its elimination form
14:23:03 * ski_ nods .. church
14:23:05 <david48> fasta : that's the kind of things I have no idea how to do. ( using mapM with parsers )
14:23:20 <Lemmih> david48: \match -> do w <- word; guard (take 3 word == take 3 match) ?
14:23:43 <fasta> david48: a parser is a monad. mapM generates a list of monadic values.
14:23:48 <fasta> david48: exactly what you want.
14:23:59 <edward1> http://citeseer.ist.psu.edu/fegaras96revisiting.html is the original fegaras/sheard paper
14:24:01 <lambdabot> Title: Revisiting Catamorphisms over Datatypes with Embedded Functions - Fegaras, Shear ...
14:24:06 <fasta> david48: ask ghci for the types and figure it out, then come back.
14:24:28 <edward1> it references an older meijer/hutton paper, but the meijer/hutton aproach required an actual anamorphism to undo the catamorphism, which i'm not willing to use
14:24:34 <david48> lemmih : if the string to match is longer than 3 chars, then the others chars have to match too
14:24:45 <assl0r> whats wrong with my pattern matching?
14:24:57 <assl0r> toNBaum :: String -> String
14:25:14 <ski_> assl0r : ityw 'toNBaum ('[':xs) = '<' : toNBaum xs'
14:25:22 <assl0r> ah thx
14:25:38 <Lemmih> david48: \match -> do w <- word; guard (word `isPrefixOf match && length word >= 3) ?
14:26:49 <edward1> ski: anyways it feels in some ways like it replaces the anamorphism with a particularly simple apomorphism, so i'm trying to see what the dual case is, thats probably ill-phrased and ill-thought out.
14:27:14 <ski_> edward1 :)
14:27:25 <ski_> (always seek the dual !)
14:27:31 <edward1> =)
14:27:49 <fasta> @type guard
14:27:57 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:28:11 <david48> lemmih : try to understand, then I'll check that
14:28:25 <david48> fasta : I'll try
14:28:46 <assl0r> not isAlphaNum excludes all whitespaces?
14:28:46 <fasta> david48: Lemmih's solution is nice, because it captures semantics better.
14:29:34 <fasta> Lemmih: guard calls fail when the Bool is False, right?
14:29:47 <Lemmih> ?src guard
14:29:47 <lambdabot> guard True  =  return ()
14:29:47 <lambdabot> guard False =  mzero
14:29:50 <edward1> the main reason is that wierich/washburn found a dual for the simple case that was less than useful at first glance, but i'm wondering about the dual analogues to the extended cases, generalized apomorphisms, etc. and also why they didn't recover a form that had the same fixed point as the primal since we're in haskell and codata ~= data
14:30:15 <Procyon> chessguy: ping
14:30:30 <chessguy> Procyon!
14:30:33 <fasta> Lemmih: but isn't the instance mzero for Parsec to parse an empty string?
14:30:34 <chessguy> you changed your name
14:30:47 <Procyon> hm... that wasn't supposed tohappen
14:30:57 <Procyon> I'm on a silly windows box with Mirc...
14:31:30 <chessguy> anyway, i've been out of town for a few days
14:31:33 <Procyon112> That's better.
14:31:44 <Lemmih> fasta: Nope.
14:31:53 <david48> fasta : I'll have to adapt it to work case insensitive, once I fully understand it ( and if it works :) )
14:32:24 <chessguy> Procyon112: i've been thinking hard about GPLib
14:32:43 <chessguy> Procyon112: i really want to start over, do it from a more DSL perspective
14:32:44 <Procyon112> cool.  We need lots of hard thinking :)
14:32:57 <edward1> afk
14:34:58 <olsner> GPLib?
14:35:27 <Procyon112> chessguy: Sounds good.  I haven't thought as hard about how to present the library interface myself, but an Idea that keeps seeming appealing is some kind of Monad, like a state monad, where you "runEval" on it.
14:35:31 <david48> lemmih : it works though there was an error
14:35:33 <Procyon112> olsner: yes
14:35:55 <chessguy> Procyon112: i've learned a lot since i started work on it, and i can do better on my part of the code. i'm not sure how to handle that with your code attached
14:35:57 <fasta>  parseTest (mzero::Parser a) ""
14:36:02 <chessguy> ?where GPLib
14:36:02 <lambdabot> I know nothing about gplib.
14:36:05 <fasta> Lemmih: what should that return?
14:36:32 <david48> lemmih: corrected =  \match -> do w <- word; guard (w `isPrefixOf match && length w >= 3)
14:36:58 <chessguy> olsner: http://www.haskell.org/haskellwiki/GPLib
14:36:59 <lambdabot> Title: GPLib - HaskellWiki
14:37:03 <chessguy> ?where+ http://www.haskell.org/haskellwiki/GPLib
14:37:03 <lambdabot> Done.
14:37:11 <chessguy> ?where+ GPLib http://www.haskell.org/haskellwiki/GPLib
14:37:12 <lambdabot> Done.
14:37:38 <Procyon112> chessguy: my part is not well integrated... in fact, it's kind of sitting along side.  I was working on abstracting out the generators and crossovers into the config record, then moving those into individual "type system" modules... specifically MonoType and HMType.
14:38:35 <olsner> genetic programming, ok
14:38:37 <chessguy> Procyon112: do you think i should just re-write my code using Data.Tree again?
14:38:49 <fasta> Lemmih: Parser (\state -> Empty (Error (unknownError state)))
14:39:07 <Procyon112> chessguy: As it stands now, Since most of HMType deals with type unification, parsing and utility functions, reconstructing GPLib would have only a minimal impact on it.
14:39:18 <fasta> Odd choice for mzero
14:39:37 <fasta> It seems rather ad-hoc.
14:39:58 <sjanssen> fasta: what else could it be?
14:40:07 <sjanssen> remember mzero :: MonadPlus m => m a
14:40:12 <fasta> sjanssen: parse epsilon?
14:40:31 <sjanssen> fasta: the return type is polymorphic, what would it return?
14:40:33 <chessguy> Procyon112: ok, then i'll just work on my part independently for now
14:40:39 <Procyon112> chessguy: I'm almost wondering if we can't factor out the container completely and apply a monad transformer to it or something.  Data.Tree seems overly general for most applications.  Many representations need only a binary tree, or even a list.
14:41:19 <chessguy> Procyon112: i think that would be tricky, but i'm really not sure
14:41:23 <Procyon112> chessguy: Perhaps the representation should fulfill some typeclass, and then the user can supply any representation.
14:41:34 <Saizan> fasta: mplus = <|>, so the zero is the parser that never succeed, no?
14:41:40 <chessguy> Procyon112: i've thought about having something like class Evolvable a where ...
14:41:56 <chessguy> Procyon112: but i think it's harder than it first appears. i could just be a ninny though
14:42:23 <george--> i wonder if anyone here could possibly answer question on floyd-hoare logic? i realise this is offtopic somewhat
14:42:37 <assl0r> dropComments ('/':'/':xs) = dropWhile (== '\n') xs
14:42:44 <fasta> Saizan: isn't fail used for that normally?
14:42:45 <assl0r> why is this wrong?
14:43:02 <Procyon112> chessguy: yeah.. I'm the same way.  I am at that point where I am proficient in Haskell semantically, but I have very little intuition as to what makes a good design.
14:43:09 <fasta> Saizan: your logic makes sense, though.
14:43:21 <Saizan> fasta: in fact mzero and fail often coincides..
14:43:22 <assl0r> if // is detected everything before \n should be droppe
14:43:22 <sjanssen> fasta: it's generally convention for mzero = fail ""
14:43:26 <assl0r> +d
14:43:47 <chessguy> @type dropComments (x:y:zs) | x == '/' && y == '/' = dropWhile (== '\n') xs
14:43:49 <lambdabot> parse error on input `|'
14:44:15 <chessguy> Procyon112: yeah, i hear you on that
14:44:21 <olsner> @index ap
14:44:21 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
14:44:21 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
14:44:28 <Saizan> in fact there's who wants to remove fail from Monad
14:44:57 <assl0r>  > dropWhile ( == 'f' ) "asdfasdf"
14:45:04 <assl0r> > dropWhile ( == 'f' ) "asdfasdf"
14:45:05 <lambdabot>  "asdfasdf"
14:45:24 <assl0r> dropWhile (<4) [1..]
14:45:28 <assl0r> > dropWhile (<4) [1..]
14:45:29 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
14:45:38 <assl0r> mhm
14:45:56 <chessguy> @type dropWhile (== '\n') xs
14:45:58 <lambdabot> Not in scope: `xs'
14:46:01 <chessguy> @type dropWhile (== '\n') ?xs
14:46:03 <lambdabot> (?xs::[Char]) => [Char]
14:46:04 <hpaste>  david48 annotated "how to parse a string where the 3 first must be present, others are optional" with "Lemmih's solution, adapted for case insensitivity" at http://hpaste.org/106#a1
14:49:29 <fasta> david48:  parse_without_parsec(map toLower input); parse_without_parsec ('i':'n':'i':rest) = GoodParse (etc)
14:50:01 <fasta> david48: not all problems require parsec.
14:50:26 <david48> fasta: it's part of a parser for a weird language
14:50:52 <Procyon112> chessguy: I am liking the Evolvable class idea though... it seems like the correct approach in my mind.
14:51:14 <david48> fasta : it's a programming language we used at work. I'm testing the parser against all the source codes we have... so far it parses the first 100 lines of code
14:51:54 <david48> fasta : the language is a huge mess.
14:52:08 <fasta> david48: how am I not surprised
14:52:18 <david48> fasta: I wouldn't have done it without parsec :)
14:52:42 <david48> it's a good example to learn parsec, though.
14:52:46 <fasta> david48: if you only need to parse a language, there are better tools, I guess.
14:52:53 <Procyon112> chessguy: The current GPLib has the following issues that seem "messy": 1) Too much reliance on the State monad 2) The return type of the functions need to be threaded to almost everything, there should be a way to abstract it more. 3) I don't think most of the operations have any reliance on Data.Tree conceptually, and we should be able to abstract away from that.
14:52:57 <fasta> david48: well, it depends on what kind of language.
14:53:07 <fasta> david48: for context-free languages there are better options.
14:53:38 <david48> fasta : that language is more like a hack than a read one with a well defined grammar
14:54:06 <fasta> david48: I am sure there exists a well-defined grammar for it ;)
14:54:39 <david48> fasta : sometimes, you can give it code that shouldn't work, but he doesn't complain. and does who knows what.
14:55:01 <chessguy> Procyon112: i'd love to hear your thoughts on what an Evolvable class should look like
14:55:02 <Procyon112> chessguy: Unfortuately, the need for random numbers in almost all parts of the algorithm kind of force us into a state monad way of doing things.... I'm wondering if we can work to minimize the impact though.
14:55:40 <Saizan> has anyone evolved a genetic algorithm?
14:55:55 <Procyon112> Saizan: you mean like higher order gp?
14:56:05 <chessguy> Saizan: you'd need a supercomputer for that
14:56:08 <fasta> Saizan: I know some people are doing that.
14:56:20 <assl0r> > dropWhile (== '\n') "asdf\nasdf"
14:56:22 <lambdabot>  "asdf\nasdf"
14:56:43 <assl0r> why doesn't it work?
14:56:44 <Procyon112> Saizan: Yes, there have been experiments in it... The results tend to be very problem specific though, and there is no "best GP algorithm" in general.
14:57:08 <fasta> "No Free Lunch Theorem"
14:57:14 <opqdonut> assl0r: dropWhile only drops matching items from the start of the list
14:57:28 <opqdonut> ?src dropWhile
14:57:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:57:34 <opqdonut> :)
14:57:36 <david48> fasta : how do you know if a language is context-free or not ?
14:57:48 <roconnor> > dropWhile (/= '\n') "asdf\nasdf"
14:57:49 <lambdabot>  "\nasdf"
14:58:10 <roconnor> > filter (== '\n') "asdf\nasdf"
14:58:11 <lambdabot>  "\n"
14:58:15 <roconnor> > filter (/= '\n') "asdf\nasdf"
14:58:16 <lambdabot>  "asdfasdf"
14:58:19 <opqdonut> :)
14:58:20 <assl0r> ah thx
14:58:33 <stevan> hello. how can i implement [ [x, y] | x <- [1..3], y <- [1..3] ] without using list comprehensions? thanks.
14:58:34 <ddarius> @src scanl
14:58:34 <lambdabot> scanl f q ls = q : case ls of
14:58:34 <lambdabot>     []   -> []
14:58:34 <lambdabot>     x:xs -> scanl f (f q x) xs
14:58:59 <roconnor> > sequence [[1..3],[1..3]]
14:59:00 <lambdabot> Terminated
14:59:02 <ddarius> stevan: liftM2 (\x y -> [x,y])
14:59:11 <int-e> > replicateM 2 [1..3]
14:59:13 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
14:59:22 <Saizan> Procyon112: uoh, well a genetic algorithm has many variables that has to be tuned, so i thought it could be a nice candidate
14:59:32 <TSC> stevan: a simple unrolling would use map and concat
14:59:34 <int-e> roconnor: I don't know why but you need to qualify 'sequence' in lambdabot
14:59:49 <roconnor> int-e: oh right, damn imports
14:59:55 <roconnor> > Control.Monad.sequence [[1..3],[1..3]]
14:59:56 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
15:00:03 <chessguy> Procyon112: i gotta run. i'll touch base with you again
15:00:08 <opqdonut> the list monad rocks
15:00:22 <fasta> david48: http://en.wikipedia.org/wiki/Context-free_grammar
15:00:24 <lambdabot> Title: Context-free grammar - Wikipedia, the free encyclopedia
15:00:24 <roconnor> @hoogle sequence
15:00:25 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
15:00:25 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
15:00:25 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
15:00:25 * byorgey sings a song about the list monad
15:00:33 <monochrom> The PLZ monad is AWSUM
15:01:02 <fasta> OMG CONT!
15:01:23 <ddarius> Tree monad all the way.
15:01:41 <desp> NGA PLZ?
15:01:42 <fasta> ddarius: Zipper monad?
15:02:03 * byorgey sings: try every combo, fuse every stream...
15:02:50 <ddarius> fasta: Zipper monad? ?
15:03:15 <fasta> ddarius: I assumed the Tree monad was implemented with a zipper like Oleg's.
15:03:24 <roconnor> int-e:  I think replicateM 2 [1..3] is the winner
15:05:04 <ddarius> fasta: The Tree monad is the natural monad for non-determinism.
15:05:04 <stevan> yes, solved my problem beautifully.
15:05:27 <sieni> > replicateM 2 [1..3]
15:05:28 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
15:06:06 <Saizan> > flip join [1..3] $ liftM2 (\x y -> return x `mplus` return y)
15:06:07 <lambdabot>   add an instance declaration for (Show (m a2))
15:06:07 <sieni> > replicateM 3 [1..3]
15:06:09 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
15:06:26 <Saizan> > flip join [1..3] $ liftM2 (\x y -> return x `mplus` return y) :: [[Int]]
15:06:27 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
15:06:37 <ddarius> @src Tree
15:06:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:06:45 <ddarius> @doc Data.Tree
15:06:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
15:07:46 <Saizan> ?type flip join [1..3] $ liftM2 (\x y -> return x `mplus` return y)
15:07:48 <lambdabot> forall a2 (m :: * -> *). (Num a2, Enum a2, MonadPlus m) => [m a2]
15:07:52 <fasta> ddarius: "tree monad" nondeterminism is very unpopular on Google.
15:08:09 <ddarius> instance Monad Tree where return = flip Node []; Node a cs >>= f = Node (f a) (map (>>= f) cs)
15:09:14 <ddarius> Actually, Data.Tree is not appropriate.
15:09:55 <Saizan> ddarius: (f a) doesn't seem right, you'll get a Node with a Tree a as value
15:10:45 <nominolo> fasta: google code search is pretty useful
15:11:12 <fasta> nominolo: are you saying google code search returns stuff google search doesn't?
15:11:42 <nominolo> fasta: if you're looking for code, maybe
15:11:55 <fasta> Meh, copy-pasting code introduces errors :(
15:11:58 <ddarius> Saizan: Right, well the easy way is just to say it is the free monad generated from a simple signature but it is better to use a rose tree base.
15:12:26 <nominolo> fasta: true.  but getting inspiration helps
15:12:41 <nominolo> fasta: or "How does one use this function?"
15:12:56 <nominolo> fasta: or "What does this Monad instance look like?"
15:13:26 <fasta> nominolo: I don't have an Emacs command to do a query in CodeSearch
15:13:42 <fasta> nominolo: => so it takes too much time, unless I am really interested.
15:14:05 <fasta> nominolo: I have used CodeSearch, but the things I am interested in are not implemented.
15:15:18 <nominolo> fasta: (defun search-for-code-at-point () (interactive) (browse (format "http://code.google.com/search?q=%s" (symbol-at-point))))  ;; or similar ;)
15:15:40 <nominolo> fasta: yes. true.
15:18:29 <sorear> hello.
15:20:37 <nominolo> Hello sorear.  You've got 0 messages.
15:20:50 <hpaste>  fasta pasted "CodeSearch from Emacs" at http://hpaste.org/109
15:21:05 <fasta> nominolo: this code works.
15:22:12 <fasta> nominolo: it would be better to use the current symbol as default input and then have the user change that, though. Now, multiple terms are not possible.
15:22:53 <nominolo> fasta: yes, i forgot the argument to interactive to do that
15:24:42 <nominolo> fasta: also, "...?q=%s+lang%%3Ahaskell"
15:24:59 <nominolo> fasta: it was more like a code-sketch ;)
15:26:30 <fasta> nominolo: How do I bind the call to interactive to an actual value that's not nil?
15:27:26 <fasta> nominolo: never mind
15:30:33 <malsyned> Can anybody give me a hint about what this warning means?  "Warning: Pattern match(es) are overlapped"
15:31:09 <nominolo> malsyned: you have two patterns that match the same thing
15:31:30 <nominolo> malsyned: e.g., case x of y -> 42; _ -> 23
15:32:12 <nominolo> fasta: the best thing would be to extend http://haskell.org/haskellwiki/Hoogle.el
15:32:13 <lambdabot> Title: Hoogle.el - HaskellWiki
15:32:39 <malsyned> yeah, that's exactly the pattern I've got.  I get it, that code probably should be case x of _ | x == y -> 42; _ -> 23 ?
15:32:50 <malsyned> or in that case, then, just an if/else.
15:35:36 <nominolo> malsyned: yep.  this warning sometimes occurs after refactoring.  Can be quite helpful at times
15:36:18 <ndm> malsyned: beware though, sometimes that warning is wrong
15:38:20 <malsyned> ndm: yeah, it was right in this case though.
15:38:28 <malsyned> thanks guys
15:40:46 <ddarius> data Tree a = Node [Tree a] | Leaf a; instance Monad Tree where return = Leaf; Leaf a >>= f = f a; Node cs >>= f = Node (map (>>= f) cs); instance MonadPlus Tree where mzero = Node []; msum = Node
15:42:06 <sorear> ddarius: Yes?
15:43:16 <ddarius> A much delayed comment.
15:43:16 <nominolo> :t msum
15:43:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
15:43:36 <ddarius> @src MonadPlus
15:43:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:43:57 <nominolo> ddarius: i was just puzzled about msum = Node
15:44:13 <filcab42> Hi, I'm lerning Haskell but I'm having a little problem with what's supposed to be a simple example :s
15:44:15 <monochrom> msum = Node is cute :)
15:44:28 <ddarius> I just wanted to verify that msum is in MonadPlus.  I feel very confident that it is though.
15:44:40 <ddarius> Presumably, mplus is defaultly defined as msum [x,y]
15:44:47 <filcab42> I want to write a function that returns the maximum in a list (don't care about an empty list)
15:44:51 <nominolo> ddarius: no
15:45:02 <ddarius> @doc Control.Monad
15:45:02 <nominolo> msum = foldl mplus mzero
15:45:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
15:45:11 <filcab42> I can't see why the compiler doesn't like my:
15:45:14 <nominolo> @src msum
15:45:14 <lambdabot> msum =  foldr mplus mzero
15:45:20 <filcab42> (i'll paste it)
15:45:24 <nominolo> ah, dammit
15:45:31 <ddarius> Clearly I need to promulgate my own MonadPlus.
15:45:47 <hpaste>  filcab pasted "simple example" at http://hpaste.org/110
15:45:57 <filcab42> can anyone help
15:45:58 <filcab42> ?
15:46:17 <monochrom> maxList (x:xs) = max x (maxList xs)
15:46:22 <ddarius> filcab42: Haskell isn't Prolog.
15:46:38 <opqdonut> (x:xs) instead of [x:xs] :)
15:46:38 <filcab42> I can't see why he's trying to match the 'x' in [x:xs] with [x]
15:46:40 <filcab42> OH
15:46:41 <filcab42> right
15:46:43 <filcab42> :$
15:47:01 <filcab42> but the first is right because it only has an element. it could be (x:[])
15:47:03 <filcab42> right?
15:47:08 <monochrom> Yes.
15:48:08 <filcab42> thanks ;)
15:48:22 <opqdonut> :)
15:48:39 <fasta> Using GP to solve #haskell newbie problems would be a nice goal :)
15:49:24 <filcab42> GP?
15:49:24 <ddarius> fasta: I'm sure the newbies would appreciate it.
15:49:27 <monochrom> How do you bias evolution towards favouring haskell experts?
15:50:14 * shapr hugs fasta 
15:50:22 <fasta> filcab42: Genetic Programming, Procyon112 and chessguy are fond of that.
15:50:27 <shapr> me too!
15:50:32 <filcab42> lol
15:50:40 <kaol> is there a GP monad yet?
15:50:54 <shapr> Probably
15:50:56 <shapr> If not, there should be
15:51:03 * shapr thinks about it
15:51:13 <shapr> It'd just be a state monad to pass around trained values, yeah?
15:51:37 <shapr> I can't immediately think of how a stack of transformers would be valuable.
15:52:15 <psnl> shapr: there is more to the idea than meets the eye ;-)
15:52:26 <shapr> Yeah, I was just thinking about that.
15:52:43 <fasta> shapr: did you see bug #1388?
15:53:00 <Procyon112> Chessguy and Iare thinking of how a GP Monad would work... We aren't quite sure and welcome input :)
15:53:35 <ddarius> I guess, "Here's an incomprehensible mass that solves your problem" isn't too different from the answers newbies typically receive here.
15:53:48 <shapr> fasta: Is that the haddock being arch specific bug?
15:54:06 <fasta> shapr: no
15:54:09 <shapr> Oh, which bug is it?
15:54:49 <fasta> shapr: A way to reduce the number of FAQs here
15:55:42 <shapr> Procyon112: I think you really would want a stack of transformers. For example, what if you want to run multiple populations at once, and re-rank the populations according to whoever is giving the best results right now? In that case you'd want to stack the PopulationT monad on itself, I suspect.
15:55:51 <Procyon112> I'm thinking of something similar to nondeterministic backtracking in a monad... A GP monad might be similar, but instead of returning something that just works, aka backtracking, it would return the best found solution, having run through an evolution.
15:56:43 <shapr> fasta: No, I haven't seen it, and 1388 isn't mentioned in my scrollback buffer. Could you give me an url?
15:57:01 <shapr> Since you haven't mentioned a specific project, I don't know which trac instance to check.
15:57:17 <sorear> shapr: Only one haskell program has that many bugs
15:57:37 <shapr> lambdabot?
15:57:48 <sorear> + with a trac :p
15:57:54 <shapr> oh
15:58:16 <ndm> sorear, thats not true, just Yhc doesn't have them in the bug tracker
15:58:58 <shapr> fasta: Looks like a good idea, when will you have a rough prototype? :-)
15:59:50 <shapr> You may want to hack in Helium's help templating system so specific institutions could customize their error messages.
16:00:30 <ndm> shapr, why would that be wanted?
16:00:47 <ndm> so you can specify "the lecturer is too busy, please email haskell-cafe" ?
16:00:57 <ndm> plus it makes tutorials go wrong
16:01:18 <SamB> ndm: what?
16:01:20 <fasta> http://hackage.haskell.org/trac/ghc/ticket/1382 <- fast response time by Simon :)
16:01:22 <lambdabot> Title: #1382 (Monad GHC.Prim.Any1 gets derived in a context) - GHC - Trac
16:01:42 <Procyon112> shapr: What if you want different behaviors per-population?  HFC does this (and is a particular favorite of mine).. I think there's more complexity than just stacking transformers allows.
16:01:44 <shapr> No, I mean that 1. not all institutions have English as their default language 2. different experience levels will make for different flavors of bugs 3. templates are *easy* to patch and redistribute without recompilation
16:01:56 <shapr> Procyon112: TrainingT !
16:02:22 <shapr> Procyon112: I was thinking about that myself. I'd definitely like to mutate the training rules as well and see how that affects it.
16:02:42 <fasta> shapr: reporting bugs/features also helps GHC, AFAIK.
16:02:47 <shapr> fasta: I agree.
16:03:19 <shapr> Ok, time to unicycle, bbl!
16:03:48 <Procyon112> shapr: we should start a discussion about how the interface of the library should happen: http://www.haskell.org/haskellwiki/GPLib
16:03:49 <lambdabot> Title: GPLib - HaskellWiki
16:04:24 <Procyon112> @msg shapr we should start a discussion about how the interface of the library should happen: http://www.haskell.org/haskellwiki/GPLib
16:04:24 <lambdabot> Not enough privileges
16:05:01 <sorear> @msg Procyon112 Are you sure you wanted @msg ?
16:05:06 <Procyon112> no :)
16:05:25 <Procyon112> Trying to remember how to record a message with lambdabot....
16:05:31 <sorear>  @tell
16:05:41 <sorear> but just prefix it - shapr IS here
16:05:43 <fasta> Procyon112: Wouldn't it make much more sense to just try to implement such programs and then see with what kind of monad you end up with?
16:05:58 <SamB_XP> @tell shapr he is boingy
16:05:58 <lambdabot> Consider it noted.
16:06:58 <Procyon112> fasta: Well, we implemented it once, and both I and chessguy dislike how it turned out... but we are both Haskell apprentices :)
16:07:35 <Procyon112> fasta: We are trying to comeup with something better, having learned from the first iteration.
16:09:17 <fasta> Procyon112: ok, good.
16:11:31 <Procyon112> fasta: our implementation uses no monads... It's a record structure that contains the configurable functions to use in evolution, then gets run in a state monad that operates on a Data.Tree.. it's all pretty imperative and needs alot more abstraction.
16:12:14 <Procyon112> fasta: http://www.paulwberg.com/repos/GPLib  <-- current incarnation
16:12:16 <lambdabot> Title: Index of /repos/GPLib
16:15:28 -Nop(n=SAS@87-196-85-178.net.novis.pt)- You have 1 new message. Type /server mail to read.
16:15:58 <opqdonut> gyah
16:16:02 <emu> what you doing nop?
16:16:07 <emu> lol
16:16:18 <Nop> lol
16:16:22 <Nop> sending messages
16:16:24 <Xgc> That wasn't very nice.
16:16:51 <Nop> do you know what's cool?
16:16:53 * sjanssen is embarassed for being stupid
16:16:58 <sorear> hiya sjanssen
16:17:00 <dibblego> so how was the mail server guys?
16:17:05 <opqdonut> :)
16:17:06 * Nop laugs at sabakas1
16:17:08 <Nop> sjanssen*
16:17:31 <sjanssen> Nop: don't do that again
16:17:48 <Nop> i mean, you shouldn't do that again :p
16:19:01 <Nop> LOL
16:19:24 <fasta> Nop: what IRC command did you use?
16:19:33 <Nop> /server mail
16:19:33 <kpreid> Nop: Do you have something Haskell-related to say?
16:19:56 --- mode: ChanServ set +o sjanssen
16:20:00 * fasta votes to kick Nop 
16:20:01 <Nop> wth noob
16:20:04 <Nop> LOL
16:20:04 --- kick: Nop was kicked by sjanssen (sjanssen)
16:20:13 <emu> use /kickban for that
16:20:19 --- mode: sjanssen set +b *!*n=SAS@*.net.novis.pt
16:20:20 --- kick: Nop was kicked by sjanssen (sjanssen)
16:20:25 <kaol> trolls just like to pick large channels as their targets
16:20:26 <desp> heh
16:20:27 <desp> pwned
16:20:35 <dibblego> I thought /server /kickban worked better
16:20:39 * dibblego runs
16:20:52 <kaol> @users
16:20:52 <lambdabot> Maximum users seen in #haskell: 340, currently: 310 (91.2%), active: 52 (16.8%)
16:21:02 * sorear remembers not to laugh at sjanssen ever *gulp*
16:21:20 <opqdonut> :)
16:21:50 <SamB_XP> @quote sjanssen
16:21:50 <lambdabot> sjanssen says: your mom has a thunk for a tail
16:21:56 <desp>  haha
16:21:56 * SamB_XP laughs at sjanssen 
16:22:09 <olsner> @quote thunk
16:22:09 <lambdabot> sjanssen says: your mom has a thunk for a tail
16:22:17 <SamB_XP> @quote tail
16:22:17 <lambdabot> sjanssen says: your mom has a thunk for a tail
16:22:22 <olsner> @quote lambdabot
16:22:22 <lambdabot> lambdabot says: Enough!
16:22:23 <SamB_XP> @quote mom
16:22:23 <lambdabot> sjanssen says: your mom has a thunk for a tail
16:22:27 <olsner> @quote lambdabot
16:22:27 <lambdabot> lambdabot says: You have QuickCheck and 3 seconds. Prove something
16:22:31 <SamB_XP> @quote your
16:22:31 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
16:22:32 <fasta> How to add a quote again?
16:22:45 <sorear> @remember fasta How to add a quote again?
16:22:45 <lambdabot> Done.
16:23:02 <SamB_XP> sorear: we are going to end up with too many of those, you know?
16:23:06 <SamB_XP> @quote quote
16:23:06 <lambdabot> dons says: boegel, stop polluting the quote-space please
16:23:09 <SamB_XP> @quote quote
16:23:09 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
16:23:12 <SamB_XP> @quote quote
16:23:12 <lambdabot> lambdabot says: <dmwit> ?quote ?quote <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
16:23:17 <SamB_XP> @quote quote
16:23:18 <lambdabot> sjanssen says: "shapr: Erik Kidd == emu? don't quote me on that"
16:23:20 <fasta> @remember fasta "If you have seen one nuclear war, you have seen them all".
16:23:20 <lambdabot> Done.
16:23:24 <SamB_XP> @quote quote
16:23:24 <lambdabot> mbishop says: darn, someone removed my one quote from lambdabot now I'll never be famous :(
16:23:28 <SamB_XP> @quote quote
16:23:28 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
16:23:31 --- mode: ChanServ set -o sjanssen
16:23:31 <SamB_XP> @quote quote
16:23:31 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
16:23:44 <SamB_XP> @quote remember
16:23:44 <lambdabot> Turks says: i need to read on how the ?remember function work in lambdabot
16:23:48 <fasta> sorear: and how to forget?
16:23:56 <SamB_XP> fasta: forget?
16:23:57 <sorear> fasta: submit a patch
16:23:58 <SamB_XP> heh
16:24:05 <emu> eric kidd = emk
16:24:08 <emu> confusing, i know
16:24:10 <SamB_XP> but you have to wait until your quote gets into darcs
16:24:14 <fasta> Wow, eternal memory! ;)
16:24:19 <sorear> sjanssen: Since according to my JOIN logs the only thing you saw from Nop was the laughing ... that was banworthy!?
16:24:19 <emu> sometimes i get confused and think i said something i didn't
16:24:44 <sjanssen> sorear: I got the /server mail thing
16:24:57 <emu> sorear: he sent a /notice to the channel trying to get people to disconnect
16:24:58 <fasta> sjanssen: do you know how he did that?
16:25:08 -emu(i=mrd@debian/developer/mrd)- like this
16:25:21 -SamB_XP(n=Sam@216-15-104-38.c3-0.upd-ubr7.trpr-upd.pa.cable.rcn.com)- hi!
16:25:25 <emu> there may be a way to disable that in the channel mode, but i forgot
16:25:29 <phoniq> w0o0o0o
16:25:32 <Cale> Many IRC clients render notices in a stupid way.
16:25:33 <dibblego> there is, but I forget too
16:25:38 <SamB_XP> yes they do
16:25:40 <sjanssen> sorear: convincing (admittedly naive) people to drop their connections and laughing about it is enough
16:25:45 -fasta(n=fasta@zonnebloem.demon.nl)- notice this
16:25:45 <kpreid> emu: that's silly
16:25:55 <opqdonut> ?quote
16:25:56 <lambdabot> sethk says: it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
16:26:03 <opqdonut> ?quote
16:26:03 <lambdabot> glguy says: Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
16:26:07 <SamB_XP> @quote stack
16:26:07 <lambdabot> emu says: hijack the stack and take this compiler to Fun-land!
16:26:10 <emu> kpreid: which that?
16:26:12 <opqdonut> ?quote
16:26:13 <lambdabot> decaf says: whare are these quotes coming?
16:26:16 <opqdonut> :)
16:26:17 <kpreid> emu: blocking notices
16:26:20 <SamB_XP> heh
16:26:20 <Cale> They really should render them like other channel messages, possibly using a different colour or something.
16:26:38 <emu> well i believe the +n takes care of ppl who are not in channel
16:26:40 <SamB_XP> there are a lot of quotes of people wanting to know how @quote gets quotes
16:26:41 <kpreid> (fwiw I don't see such a thing in freenode's mode list)
16:27:36 <Procyon112> We need another book, as a sequel to Dons... Something along the lines of "Software Design in Haskell" That targets not the semantics of the language, but rather, the hows and whys of how to architect good haskell code.  Is there much out there like this?
16:27:50 <olsner> @photontorpedo
16:27:51 <lambdabot> is there going to be a better dns server in haskell?
16:27:55 <emu> dons has a book? or is a book?
16:27:56 <ddarius> Procyon112: No.
16:28:01 <fasta> olsner: good timign
16:28:04 <ddarius> Dons: The Book
16:28:05 <Procyon112> eme: hehe... both.
16:28:09 <fasta> olsner: timing*
16:28:33 <ddarius> emu: dons (and bos and CosmicRay) will have a book.
16:29:55 <nominolo> It'll be available as Dons.lhs
16:30:08 <emu> who is publishing
16:30:24 <nominolo> o'reilly
16:30:30 <emu> o really
16:30:33 <Procyon112> Coming from a OOP and imperative background, now that I've wrapped my brain around the semantics of Haskell, I am finding it difficult to see where to use different constructs, eg, when to make classes, Monad Transformers, etc... I do this by instinct in OOP, but I just don't see the patterns when writing Haskell.
16:31:05 <weitzman> I imagine a book on software design in Haskell would have a limited audience
16:31:10 <Procyon112> My nose isn't attuned to Haskell "code smells"...
16:31:13 <emu> you mean o'reilly's gotten over the functional prejudice?
16:31:37 <Procyon112> weitzman: Don't all Haskell books have a limited audience ;)
16:31:39 <weitzman> My understanding is that Haskell currently doesn't scale too well to extremely large projects, and the PhD students using it are all so smart they don't need advice
16:31:49 <opqdonut> :D
16:31:55 <SamB_XP> weitzman: hah
16:31:59 <pjd> Procyon112: it'll come from refactoring redundant code
16:32:00 <weitzman> So it would be targetted at lay-people who don't actually have large software to build
16:32:02 <weitzman> I think
16:32:12 <nominolo> Procyon112: maybe this helps a little: http://www.haskell.org/haskellwiki/Programming_guidelines
16:32:13 <lambdabot> Title: Programming guidelines - HaskellWiki
16:33:18 <nominolo> weitzman: OOP and the rest doesn't scale well either
16:33:29 <weitzman> Depends what you mean by scaling
16:33:37 <emu> i'm curious what you mean by scaling
16:33:39 <nominolo> weitzman: it'll all get "enterprise software" at a certain point
16:33:43 <weitzman> Haskell, for example, doesn't currently do seperate compliation well, right?
16:33:46 <weitzman> Perhaps, at all?
16:33:48 <nominolo> weitzman: from then on there's no return
16:33:54 <emu> ghc does fine, afaict
16:33:57 <Procyon112> weitzman: I think your second point is apt, but your first point is unsubstantiated.  I see no reason why Haskell wouldn't scale.  I do agree though that there is a large disconnect between those in the know and the layman engineers.  Not in the semantics, which are well covered by the wiki and "Haskell School of Expression", but rather in the bigger engineering concepts.
16:34:02 <nominolo> weitzman: ah, that you mean.
16:34:04 <emu> it can even detect at below the module level what changes were made
16:34:13 <nominolo> weitzman: that'll be fixed sooner or later
16:34:23 <weitzman> Still, that's kind of...important
16:34:29 <weitzman> That's not the only thing, though
16:34:36 <weitzman> Don't typeclasses share a global namespace?
16:34:39 <dibblego> Haskell wouldn't scale to be usable by a team of idiots
16:34:41 <weitzman> You can have two with the same name?
16:34:43 <emu> sorry, what world are we living in where separate compilation doesn't work?
16:34:43 <weitzman> *n't
16:34:55 * emu makes sure not to use it in his code
16:35:08 <sjanssen> weitzman: instances share a global space
16:35:36 <sjanssen> weitzman: you can use the usual module qualifications for classes with conflicting names
16:35:38 <emu> frankly, OOP isn't usable by a team of idiots
16:35:44 <emu> its a #%^# disaster
16:35:46 <weitzman> Also, Haskell's pervasive laziness can lead to hard-to-understand performance
16:35:47 <SamB_XP> ooh, haskton are we using?
16:35:58 <SamB_XP> idiots are the disaster
16:36:08 <Procyon112> nominolo: Yeah, I've read that.  It's more low level than what I'm thinking.  I'm envisioning a paper where a project is being written, then the author discribes "These are the symptoms that this should be a MonadT", then refactors and abstracts the Monad...
16:36:11 <dibblego> weitzman, thank you for proving my point
16:36:45 <nominolo> Procyon112: oh.  yes.  i had lectures from Koen Classen.  helped _a_lot_
16:36:59 <nominolo> Procyon112: we should do videos
16:37:07 <weitzman> I know some very smart and accomplished professors and grad students of programming languages who don't like Haskell's pervasive laziness
16:37:15 <Cale> I don't know if it's all *that* hard to understand. There's a kind of reasonable performance model for Haskell programs.
16:37:18 <weitzman> They see no problem with making laziness explicit
16:37:26 <emu> grad students and professors tend to be horrible programmers
16:37:36 <Cale> I couldn't stand having to make laziness explicit. :)
16:37:37 <dibblego> weitzman, tell them to study harder
16:37:39 <Procyon112> emu: OOP isn't useable by a team of idiots, but there are VAST resources to train people on the proper uses of OO... Haskell doesn't have those resources.
16:37:39 <emu> i know -- i fix their code all the fucking time
16:37:46 <dibblego> Cale, I have to deal with it every day (Scala)
16:37:50 <SamB_XP> dibblego: code harder?
16:38:02 <Cale> dibblego: deal with what?
16:38:03 <weitzman> dibblego: Study what? They are the ones writing the papers on their field
16:38:11 <dibblego> Cale, explicit laziness
16:38:13 <Cale> ah
16:38:25 <dibblego> weitzman, are they writing papers on why there is no problem with explicit laziness?
16:38:36 <weitzman> Not on that specific topic
16:38:46 <dibblego> then they should, so they can learn
16:38:48 <Cale> The annoying part about explicit laziness isn't so much to do with your own code, but having to use external libraries which are usually going to be strict.
16:38:56 <SamB_XP> yeah.
16:39:00 <emu> right. if you use code which isn't lazy, you don't get the benefit
16:39:03 <dibblego> Cale, yep, I have to rewrite much of Scala's core API
16:39:04 <weitzman> Actually I was told there *were* specific problems with pervasive laziness
16:39:07 <emu> that's why i prefer haskell
16:39:15 <weitzman> That the forcing construct is flawed
16:39:24 <emu> seq?
16:39:29 <SamB_XP> eh?
16:39:30 <weitzman> Ah, that's the one
16:39:32 <emu> yes
16:39:41 <SamB_XP> seq is rather singular
16:39:51 <sorear> Haskell has no proper forcing construct at all.
16:40:01 <weitzman> I didn't write down my discussions with Karl Crary, but if you ever encounter him I encourage you to try to convince him that pervasive laziness is a good idea
16:40:01 <Procyon112> weitzman: The choice as to whether to make laziness the default and allow strictness, or vice versa is simply taste.  There's no practical difference.  You can code all-lazy in scheme if you want, or all strict in Haskell.  Both have advantages in different situations.
16:40:03 <sorear> seq just introduces false dependencies
16:40:04 <nominolo> weitzman: it breaks contextual equivalence
16:40:14 <Cale> Why do I always think of set theory when people say "forcing"? :)
16:40:17 <nominolo> weitzman: i.e., equational reasoning
16:40:28 <sorear> nominolo: Huh?
16:40:37 <emu> Procyon112: you can't code all lazy in scheme.  the built-in stuff is strict.
16:40:45 <sjanssen> sorear: I wonder what will happen when we have a compiler that follows the semantics of seq more closely
16:40:47 <dibblego> weitzman, shall I point him to all these APIs I have to rewrite because of implicit strictness in this particular language?
16:40:51 <Procyon112> weitzman: There *are* specific problems with pervasive strictness also.
16:40:54 <Cale> It doesn't completely break equational reasoning, but it does harm it somewhat.
16:41:05 <weitzman> There is a practical difference. Real code can have side-effects, for example, even if it says it's pure
16:41:06 <sjanssen> eg. when it can statically prove a value is non-bottom, seq is a no-op
16:41:12 <weitzman> The effect of laziness can be seen
16:41:14 <sorear> sjanssen: What do you mean?  GHC implements seq exactly
16:41:17 <Cale> I think the problems with pervasive strictness are much worse than those with pervasive laziness.
16:41:17 <Procyon112> emu: you can stream-ize everything with a lambda thunk.
16:41:30 <weitzman> Pervasive strictness is harmless. Just create suspensions
16:41:35 <emu> no
16:41:37 <dibblego> weitzman, you can plausibly argue that no code has side-effects; what's your point?
16:41:39 <emu> you have to rewrite every library
16:41:43 <emu> with suspensions
16:41:55 <Cale> what emu said :)
16:42:00 <weitzman> Only if you wrote them incorrectly in the first place
16:42:01 <nominolo> sorear: it's the usual strictness pitfalls
16:42:25 <Cale> weitzman: Basically, if you have to rewrite everything to use suspensions, then what's the point of defaulting to strictness? :)
16:42:27 <sorear> nominolo: I have yet to see a case where strictness breaks equational reasoning
16:42:30 <sjanssen> sorear: all the report says about seq is that "seq _|_ b = _|_; seq _ b = b".  ie. seq doesn't necessarily mean reduce to WHNF
16:42:32 <weitzman> I see no reason why you couldn't create a programming language where you could make functions that could be used either lazily or strictly
16:42:43 <dibblego> when I see Java code that uses the file system,. I imagine it is in the IO monad; if I quiz the developer, they will add in the IO monad as well (implicitly usually) - they just store it in their head
16:42:49 <emu> another problem with strictness
16:42:56 <sorear> sjanssen: The report leaves pretty much everything it can, unspecified.
16:42:59 <Cale> weitzman: separate compilation, maybe?
16:43:01 <emu> you can't express circular data structures strictly
16:43:04 <emu> (in FP)
16:43:13 <sorear> sjanssen: Reduce to WHNF is a perfectly valid interpretation of seq
16:43:27 <sorear> sjanssen: Just as valid as heap graphs are for haskell values
16:43:28 <weitzman> Cale: I imagine it could be as simple as a type annotation
16:43:29 <dibblego> weitzman, once a structure is strict, it has incurred a space cost; which cannot be reversed - the inverse is not true
16:43:33 <sjanssen> sorear: right.  Imagine how many things would be awkward in a compiler that doesn't always WHNF seq'ed values
16:44:02 <dibblego> a lazy structure can always be made strict, at the expense of space - after which, there is no going back
16:44:05 <weitzman> Functions could have overloaded versions which are lazy and strict, chosen based on the desire of the person calling them
16:44:20 <weitzman> Some functions could only be one or the other
16:44:28 <Cale> The semantics for seq essentially mean that it must reduce most things to WHNF.
16:44:59 <Cale> and it certainly can't reduce things farther
16:45:08 <sjanssen> Cale: there are certainly cases where the compiler could prove that a value will not be _|_ without evaluating it
16:45:14 <Cale> Oh, sure.
16:45:29 <sjanssen> not all the time, of course (see halting problem)
16:45:29 <twanvl> http://research.microsoft.com/%7Esimonpj/papers/not-not-ml/index.htm
16:45:32 <lambdabot> Title: Haskell is not not ML, http://tinyurl.com/2ar2l4
16:45:35 <Cale> sjanssen: of course.
16:45:46 <weitzman> So honestly, I'm not making an argument on my own behalf because I really don't know enough about the consequences of laziness vs strictness. I'm just relaying that there are some very well researched people who feel that Haskell is not that perfect language :)
16:45:53 <dibblego> Scala uses 'def' to annotate laziness and 'val' for strictness, but function arguments are strict by default - and lazy with an annotation (=>)
16:46:07 <dibblego> weitzman, I don't think anybody would disagree with that
16:46:17 <Cale> weitzman: Well, laziness is probably not perfect, but the ideal will at least have non-strict semantics.
16:46:22 <twanvl> That paper describes a system that supports both lazyness and strictness and conversion between them
16:46:27 <sjanssen> dibblego: do you have to explicitly force lazy values to get at them?
16:46:35 <weitzman> I like laziness, I just worry about pervasive laziness
16:46:42 <weitzman> When you want laziness, you probably know you want it
16:46:42 <Cale> weitzman: That is, the ideal language would reduce every normalisable term to normal form.
16:46:46 <dibblego> sjanssen, no, which is a bonus
16:46:59 <dibblego> weitzman, other way around - you *always* want laziness by default
16:47:01 <Cale> weitzman: When you want strictness, you probably also know you want it.
16:47:09 <sjanssen> dibblego: yeah, that's good.  I don't count languages that require a force-thunk construct or some such :)
16:47:12 <emu> weitzman: for sure, denotational semantics for say, SML, are well .. existent
16:47:23 <dibblego> sjanssen, I agree - it's not as bad as some other strict languages
16:47:27 <weitzman> Cale: Not necessarily. Witness the strange-looking Haskell code designed to do well in the great language shootout
16:47:39 <weitzman> I could write that
16:47:41 <weitzman> *n't
16:48:00 <Cale> You mean the stuff which unboxes values and uses compiler hacks? :)
16:48:07 <sjanssen> weitzman: much of those hacks have little to do with strictness
16:48:15 <sorear> that's not haskell
16:48:21 <sorear> that's FORTRAN
16:48:28 <Cale> That's not really Haskell, it's GHC.
16:48:52 <fasta> photon torpedo: so Haskell is slow? ;)
16:48:53 <Cale> Though, there are libraries now which hide lots of that mess.
16:49:04 <sorear> like most good FORTRAN programmers, dons can write FORTRAN in any language
16:49:09 <Cale> (and get reasonably close results)
16:49:45 <DRMacIver> sorear: SPJ was saying in his talk at London HUG that the motto of the nested data parallelism stuff was "Let's beat FORTRAN!" :)
16:49:54 <davidL> how is findIndices any different from filter?
16:50:08 <Cale> davidL: It finds the indices
16:50:13 <sjanssen> davidL: findIndices finds the indices
16:50:17 <sjanssen> @quote stereo
16:50:17 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
16:50:26 <davidL> ohh
16:50:37 <Cale> :t findIndices
16:50:39 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
16:50:51 <davidL> :t filter
16:50:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:51:01 <davidL> I see.
16:51:03 <Cale> > findIndices even [1,4,2,4,6,7,3,6,2,6,3,9]
16:51:03 <davidL> thanks
16:51:04 <lambdabot>  [1,2,3,4,7,8,9]
16:51:10 <Cale> > filter even [1,4,2,4,6,7,3,6,2,6,3,9]
16:51:11 <lambdabot>  [4,2,4,6,6,2,6]
16:51:44 <emu> i went to a seminar and the guy gave a talk about a proof program he'd developed in a subset of haskell
16:52:01 <emu> what's the first thing out of harper's mouth? "but haskell doesn't have a denotational semantics!"
16:52:31 <Cale> weitzman: anyway, those examples are fairly atypical, in that they're trying to run as quickly as possible, and not merely quick enough.
16:52:45 <Binkley> oh burn!
16:52:58 <Cale> weitzman: In real programs, you tend not to go to such lengths.
16:53:15 <weitzman> Cale: I can't point to any examples offhand, but I'm sure everyone has, at some point, accidentally wrote some code that builds a gigantic suspented sequence of additions
16:53:59 <Procyon112> weitzman: If a Normal form of an expression exists, a lazy language will always find it be default, whereas a strict language may fail to terminate.  This is a big reason for choosing laziness by default.
16:54:05 <Cale> weitzman: Right, and then you learn that collapsing large sets of data down to small results is where you want strictness, so the next time you see that, you write in a seq, or use foldl'.
16:54:06 <sjanssen> weitzman: sure, when I was new(ish) to Haskell.  I can't say that's happened to me lately
16:54:09 <sorear> weitzman: I can't point to any examples offhand, but I'm sure everyone has, at some point, accidentally wrote some code that computes a gigantic object that never is used
16:54:30 <sorear> weitzman: which only happens in strict languages :)
16:55:54 <stepcut> just today, I wrote the code,  m_umountCmd == "smbumount";
16:56:31 <dibblego> there are massive amounts of that kind of code in IBM WebSphere (I used to work on it)
16:57:09 <stepcut> it my seem like an error to have a line of code that just computes a boolean value and throws it away, but maybe == has some important side-effects!
16:57:42 <sorear> dibblego: what kind?
16:57:53 <dibblego> sorear, strict, leading to wasted spac
16:58:19 <dibblego> sorear, e.g. "let's read this massive thing into an array, pass it to a method (copy the array), get the first element and use it in a computation"
16:58:36 <weitzman> I still haven't jumped on the bandwagon that no line of code should be wasted
16:58:50 <dibblego> "line of code" and "space" are very different things
16:59:00 <weitzman> Typing speed is not a limiting factor in writing code, and reading speed is not a limiting factor in understanding it
16:59:02 <lucca> I think I want something like a subclass of Ix that provides a neighbors function
16:59:22 <dibblego> weitzman, do you know what a "domain of discourse" is (from Set Theory)?
16:59:32 <lucca> obviously in a 1d indexing space, there's a clear pred/succ, but in greater numbers of dimensions it gets trickier
16:59:33 <weitzman> dibblego: Nope
16:59:55 <lucca> and some of the topologies I want are toroidal, so correct wrapping at the endpoints would be essential
17:00:14 <jfredett> lucca, sounds like you're looking for Neumann Neighborhoods
17:00:20 <dibblego> weitzman, let me explain a little; suppose a method accepts a 32 bit integer type; the domain size is 2^32 - this can be written as |U| = 2^32 (U means universe or domain)
17:00:36 <lucca> hmmm, reading up on that
17:00:55 <jfredett> its really rather trivial, its related in some ways to cellular automata
17:00:58 <chessguy> @go wikipedia neumann neighborhoods
17:00:59 <lambdabot> http://en.wikipedia.org/wiki/Von_Neumann_neighborhood
17:01:00 <lambdabot> Title: Von Neumann neighborhood - Wikipedia, the free encyclopedia
17:01:02 <xpika> hi
17:01:13 <dibblego> weitzman, I would argue that evaluating an entire domain, simply "because you can", despite being superfluous to the computation, is a bad thing to do - I hope you'd agree
17:01:37 <chessguy> hi xpika
17:01:50 <weitzman> dibblego: Is there another term for domain of discourse? I'm not getting many useful-looking google results
17:01:58 <dibblego> weitzman, universe of discourse
17:01:58 <xpika> when did GHC get the --make option?
17:02:07 <dibblego> weitzman, what strict languages are you familiar with?
17:02:13 <lucca> jfredett: where is a good place to read up on this?  the first google paper seems to be $19, heh...
17:02:39 <Procyon112> chessguy: shapr is also thinking of good interfaces for GPLib and hs some interesting ideas... make sure to include him in discussions.
17:03:00 <lucca> oh I see now
17:03:01 <chessguy> Procyon112, oh cool
17:03:13 <lucca> chessguy: thanks
17:03:15 <chessguy> Procyon112, i just got a fresh new OS install. very invigorating
17:03:17 <jfredett> lucca, last i looked, there was a good article on it at mathworld
17:03:20 <chessguy> lucca, eh?
17:03:28 <weitzman> dibblego: On actual computers, whether or not overcalculating is bad is unclear to me. For large or sparse problems, surely it's better
17:03:32 <lucca> chessguy: for the link
17:03:35 <Procyon112> chessguy: He's thinking of some kind of PopulationT transformer.
17:03:40 <jfredett> really, reading anything by wolfram will probably run into stuff about neighborhoods
17:03:42 <chessguy> oh. that was for me :)
17:03:44 <weitzman> dibblego: I mean worse
17:03:47 <Procyon112> chessguy: Which OS?
17:03:52 <weitzman> I've been saying the opposite of what I mean all evening
17:03:55 <dibblego> weitzman, let me simplify; are you familiar with Java's InputStream or Iterator?
17:03:58 <chessguy> Procyon112, that crappy one out of seattle
17:04:02 <weitzman> dibblego: Yep
17:04:03 <Procyon112> lol
17:04:06 <Procyon112> Vista?
17:04:10 <chessguy> no
17:04:15 <chessguy> i'm not that brave
17:04:28 <dibblego> weitzman, suppose I ask you to read two numbers off an Iterator and add them, then output the result - will you read all the way to the end "because you can"?
17:04:41 <Procyon112> Ahh... make sure to Validate it with WGA and think of me :)
17:04:41 <jfredett> lucca, I've only ever looked at neighborhoods except in the world of cellular automata
17:04:48 <olsner> yes! because you can!
17:04:56 <chessguy> Procyon112, like i havea choice
17:04:56 <jfredett> so I'd bet that's the best place to look.
17:04:58 <lucca> jfredett: this is (loosely) related
17:05:08 <dibblego> weitzman, furthermore, what if there is no end? (hasNext returns true always)
17:05:10 <chessguy> Procyon112, i was having a terrible time finding the right packages for my 64-bit arch.
17:05:16 <davidL> ?hoogle sumBy
17:05:17 <lambdabot> No matches found
17:05:17 <weitzman> dibblego: Clearly not, but I doubt you'll find any strict code in the world that reads an entire stream to add two numbers
17:05:28 <jfredett> lucca, what are you aiming to do?
17:05:35 <weitzman> dibblego: A more realistic example might be sorting a list and reading two numbers from the middle
17:05:44 <weitzman> dibblego: Should you sort the whole thing? Partial lazy sort it?
17:05:50 <dibblego> weitzman, so you at least agree that sometimes you do not evaluate your entire universe - can you plausibly argue for *any* cases?
17:05:56 <Procyon112> chessguy: Packages?  We don't have any stinking Packages... just a monolithic pile of stink.
17:05:56 <weitzman> dibblego: And the answer, as far as I'm concern, is "it depends"
17:06:04 <emu> no you should use QUICK-SELECT not sort ;) linear time
17:06:12 <chessguy> Procyon112, yeah, thus the fresh start
17:06:13 <weitzman> dibblego: For small lists, sorting unconditionally will be faster
17:06:20 <lucca> jfredett: essentially calculate the von neumann neighborhood equivalent for n-dimensional lattices
17:06:21 <dibblego> weitzman, of course you should sort the whole thing - that is the definition of sort
17:06:31 <jfredett> right,
17:06:39 <weitzman> dibblego: I mean (sort [some list]) !! 10
17:06:41 <dibblego> weitzman, are you talking about some other kind of sort?
17:06:46 <lucca> very new to haskell though, so I'm still learning how to do things idiomatically
17:06:50 <weitzman> dibblego: Lazy sort
17:06:51 <dibblego> weitzman, that requires an evaluation of the entire list
17:07:16 <dibblego> weitzman, are you objecting to sort, then index (two traversals?)
17:07:17 <weitzman> dibblego: Evaluation, but not necessarily comparison. Perhaps it wasn't a great example
17:07:25 <chessguy> Procyon112, so tell me about PopulationT
17:07:35 <dibblego> weitzman, no, it wasn't - so I argue, do you have a plausible example - I say no
17:07:41 <weitzman> dibblego: You can save time if you don't need the whole sorted list
17:07:52 <chessguy> Procyon112, i assume this is on top of IO?
17:07:59 <jfredett> so are you trying to calculate something exactly from the stuff? or just return a datatype with the neighborhood in it?
17:08:07 <dibblego> weitzman, of course, with laziness - how will strictness help you?
17:08:30 <weitzman> dibblego: Ah, it might help you because you don't have to pay for laziness. Much like using insertion sort will be an n log n sort on a small list
17:08:38 <weitzman> *be -> beat
17:08:45 <lucca> jfredett: well, a list of the surrounding locations so that the other algorithms can process the data in a topology-agnostic fashion
17:09:00 <dibblego> weitzman, what is the price exactly? the subsequent traversal?
17:09:21 <jfredett> lucca, i see... interesting problem
17:09:28 <weitzman> dibblego: Every value in memory is either a suspension or a value, and you have to check all accesses
17:09:31 <lucca> (working on Go analysis but got distracted by n-dimensional and toroidal gobans, heh)
17:09:47 <jfredett> lol
17:09:59 <lucca> and realized that most of the life/death analysis stuff could be independent of board shape with the proper abstraction
17:10:04 <dibblego> weitzman, so you argue that you should trade space (strictness) to save computation? sure, that would be plausible
17:10:12 <dibblego> weitzman, recall, that it is a *trade*
17:10:20 <fasta> Is seq documented somewhere with an example of evaluation with a graph reduction sequence?
17:10:39 <emu> or rather, deterministic-select
17:10:40 <weitzman> dibblego: So I think everyone would agree that strictness is good sometimes. I think there's even a sorta-strict Haskell implementation
17:10:41 <dibblego> weitzman, the point is, whether or not you make that trade, should be decided by you
17:10:47 <weitzman> dibblego: Yes, I agree
17:10:52 <dibblego> weitzman, absolutely - seq exists for a reason
17:10:55 <emu> weitzman: of course it's good sometimes, the question is about the default
17:11:05 <dibblego> weitzman, with a strict type, that decision no longer exists - you cannot reverse strictness
17:11:06 <weitzman> dibblego: And you could either have a strict language with suspensions or a lazy language with strict markings
17:11:23 <dibblego> weitzman, imagine you method that accepts an Iterator, instead accepts an array - this is a leak
17:11:49 <dibblego> I have even heard Java people say "it is more abstract"
17:11:57 <weitzman> dibblego: The extreme case is imagine the entire Haskell standard library implemented with manuel suspensions everywhere
17:12:06 <weitzman> It would more than double in size, but it would work
17:12:13 <Procyon112> chessguy: shapr didn't go into alot of detail about PopulationT before he left, but hes definately thinking about it :)
17:12:16 <dibblego> weitzman, that would be fine, since pure FP is decompoasble - I would just seq wherever necessary
17:12:21 <weitzman> What if annotations and clever type design could remove the verbosity, though?
17:12:44 <weitzman> Lazyness, in some sense, is already an effect. I wouldn't mind it being in the type of something
17:12:47 <dibblego> right now, I am having to rewrite scala.List - why? because it is strict - I have to rewritethe entire damn thing
17:12:49 <chessguy> Procyon112, ok, that works. i can check the log too
17:13:10 <dibblego> I'd much rather it be lazy, and I add my strictness whenever I so choose
17:14:04 <weitzman> dibblego: There's a function called deepSeq, right? Does it actually do what I would like to hope it does?
17:14:10 <dibblego> weitzman, have you seen those methods that convert a byte[] to an InputStream?
17:14:13 <olsner> (I'd like to make deepSeq part of the language so that strictness actually makes things strict)
17:14:16 <dibblego> weitzman, I cannot be sure
17:14:37 <dibblego> weitzman, I'd imagine it uses normal form
17:14:51 <fasta> If I understand it correctly it's like this: with f defined as f x = x `seq` (x + 5) and called as g = f (5*5). seq reduces 5*5 to 25, but since 5*5 and 25 are the same value (it's FP) afterall. f finds 25 instead of 5*5 to add 5 to, so ends up with 25 + 5, which gets evaluated to 30 because it's needed by the interpreter?
17:14:53 <olsner> weitzman: deepSeq has to be instantiated manually for all types you want to work with, to produce a traversal with `seq` interspersed
17:14:55 <weitzman> Ah, right, deepSeq isn't real
17:15:01 <olsner> it works, but it's ugly
17:15:02 <weitzman> So you can't enforce strictness actually
17:15:10 <olsner> google deepseq haskell or something
17:15:15 <weitzman> Except by manually implementing it
17:15:23 <sorear> It's real.  Except that it is called rnf
17:15:24 <weitzman> Which is the same as you might have to do to get laziness in a strict language
17:15:29 <sorear> > rnf [1,2,3,undefined]
17:15:29 <weitzman> Seems like complete parellels to me
17:15:34 <lambdabot>  Undefined
17:15:44 <olsner> @type rnf
17:15:44 <dibblego> you can't get laziness in a strict language; without a space cost
17:15:46 <lambdabot> forall a. (NFData a) => a -> Done
17:15:58 <emu> NFData is Data.Derive-able =)
17:16:07 <sorear> And DrIFT
17:16:16 <olsner> @src Done
17:16:16 <lambdabot> Source not found. It can only be attributed to human error.
17:16:17 <emu> DrIFTable?
17:16:19 <sorear> inded it was DrIFT's motivating use case
17:16:22 <fasta> sorear: is the above I said correct?
17:16:22 <weitzman> The cost was always there, you just hid it in the runtime
17:16:23 <sorear> type Done = ()
17:16:45 <dibblego> weitzman, it's not always there; I don't need to evaluate the entire universe to complete a computation
17:16:53 <sorear> weitzman: People should use strict code sometimes, it is lower level and faster
17:17:06 <sorear> weitzman: but speed doesn't usually matter
17:17:10 <weitzman> dibblego: Are we refering to implementing laziness in a strict language?
17:17:24 <weitzman> dibblego: Versus a real lazy language
17:17:29 <sorear> weitzman: i think we should optimize languages for the common case, and that is "No perf requirements"
17:17:34 <dibblego> weitzman, I am referring to specific cases of using a strict type versus its lazy equivalent
17:17:51 <dibblego> weitzman, the strict type has incurred a cost, that cannot be traded - the lazy type hasn't
17:18:04 <sorear> weitzman, dibblego: Aside from things like SKIM, *ALL* lazy code is written on a strict system, namely asm!
17:18:11 <dibblego> the lazy type can trade space for computation speed benefits
17:18:59 <weitzman> dibblego: I'm actually supposing that the strict code could be designed in a language such that laziness is added and the actually performance is identical
17:19:18 <chessguy> there ought to be a single command for the ghost/nick/identify combination
17:19:23 <dibblego> weitzman, then, you'd have Scala
17:19:25 <weitzman> dibblego: I believe such a language could exist if types were allowed to be, for example, optionally lazy.
17:19:42 <dibblego> weitzman, I think it is a great language - I just hate having to rewrite all its strict types
17:19:55 <weitzman> dibblego: I'll check Scala out
17:19:55 <dibblego> weitzman, since, I cannot add laziness to them
17:20:06 <weitzman> dibblego: Is that a library design flaw or a language flaw?
17:20:16 <dibblego> weitzman, Scala (in terms of laziness) is somewhere between Java/C and Haskell
17:20:30 <dibblego> weitzman, it is a library flaw imo - encouraged by implicit strictness
17:20:35 <monochrom> I wonder whether this physical cosmos is a strict system to begin with.  For example, some quantum superpositions seem to remain as superpositions until you observe them, then they collapse to singular answers and remain so thereafter. To me that's laziness.
17:20:39 <sorear> chessguy: In ERC, identification is automatic when you receive a "This nickname is owned..."
17:20:51 <dibblego> weitzman, I could write the strict version in terms of the lazy version quite easily; but the other way around requires a complete rewrite
17:21:01 <SamB_XP> monochrom: doesn't sound very referentially transparent
17:21:16 <SamB_XP> not if we can detect it
17:21:22 <weitzman> dibblego: Fair enough. I think there's definitely a risk that people would write strict code if they could simply out of habit
17:21:25 <sorear> monochrom: That's only one interpretation of the QM spec
17:21:50 <Procyon112> monochrom: It really kind of bothers me that the universe feels the need to save processor cycles.
17:21:54 <weitzman> dibblego: Perhaps it would be ideal of support sementics something like scala but default somehow to being lazy?
17:22:11 <weitzman> dibblego: Do scala types include laziness or is it hidden somewhere else?
17:22:38 <dibblego> weitzman, e.g. scala.List is inherently strict - this cannot be undone
17:22:44 <dibblego> weitzman, but using laziness is quite easy
17:23:24 <weitzman> I'm imagining a world where there are two ways to say Int x = 1 + undefined
17:23:24 <monochrom> OK, but I just want you to think.  Before you say "strictness is preferred because physical systems are strict", think twice.  Likewise, before you say "mutable state is preferred because physical systems are mutable", think twice.
17:23:36 <weitzman> One resulting in a type Lazy Int, one Strict Int
17:23:44 <dibblego> weitzman, you're imagining Scala
17:23:48 <weitzman> Ok
17:24:06 <weitzman> But Scala defaults to Strict Int
17:24:11 <weitzman> Whereas it could default to Lazy Int?
17:24:15 <dibblego> yes, in fact, it uses Java's int
17:24:21 <dibblego> you could write def x: Int = 7
17:24:24 <monochrom> I rather feel that there are natural, lazy, immutable physical systems.
17:24:26 <dibblego> which is a thunk to an Int
17:24:34 <weitzman> Aha, so I might be able to stand by modified scala with lazy-by-default
17:24:40 <dibblego> (actually, with type inference, it is def x = 7)
17:25:08 <Procyon112> physical systems are immutable when viewed as a function of time.
17:25:19 <weitzman> But I bet it doesn't encode side-effects in the type :(
17:25:23 <dibblego> weitzman, any accesses to x invoke the thunk then
17:25:29 <dibblego> weitzman, no it doesn't
17:25:31 <sorear> weitzman: Making things strict is almost invariably a premature optimization
17:26:03 <sorear> weitzman: implicity strict languages actively encourage premature optimization
17:26:03 <dibblego> weitzman, if you access x twice, which costs speed, you might want to incur the space cost, then val x = 7 and it is strict
17:26:39 <dibblego> this is not such a big deal, only that Java programmers associate 'def' with methods and 'val' with local variables, so they use val by default
17:26:49 <Cale> Assuming that the universe you're talking about is one defined by modern physics, it can't really be said to be strict or lazy. For the most part it's defined using equations.
17:26:55 <dibblego> also, Scala's method arguments are strict by default requiring an annotation for laziness
17:27:10 <Cale> Evaluation order doesn't really mean much when you have an implicit definition in terms of differential equations :)
17:27:22 <dibblego> this is nowhere near as bad as what I have to endure in Java/C, but still worse than I would in Haskell/CAL
17:27:41 <weitzman> sorear: If a language had sufficiently expressive lazy functional sementics *and* good imperative constructs, I think people would be inclined to try the less imperative solution first (or am I an optimist?)
17:27:49 <dons> moin
17:27:49 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:28:03 <dibblego> weitzman, I would agree, if they haven't used an imperative language beforehand
17:28:06 <Procyon112> weitzman: You are an optimist
17:28:25 <dibblego> weitzman, a naive person opts for the "less imperative" solution almost consistently in my observations
17:28:26 <sorear> weitzman: You're being an optimist by assuming such a language exists :)
17:28:55 <Cale> Haskell doesn't have good imperative constructs?
17:28:57 * ndm finishes marking 50 undergrad open assessments
17:29:11 <Baughn> Cale: If you were going to /simulate/ a universe, lazy evaluation would let you simulate even an infinite one using finite resources. Could be handy.
17:29:23 <Cale> Baughn: I agree :)
17:29:38 <SamB_XP> Baughn: a finite part of one, yes
17:29:40 <weitzman> I find that the confusion that comes with summoning state-related monads scares me away from imperative solutions in Haskell
17:30:09 <Baughn> SamB_XP: Luckily, given finite time, the outside observer would only be able to see a finite part
17:30:15 <sorear> ndm: What's an open assessment?  Is that where they publish there work publically and then you review it, for added humiliation? :)
17:30:16 <Cale> weitzman: It's not so bad once you've done it once.
17:30:16 <weitzman> Seeing a bunch of monad transformers declarations makes my head spin
17:30:18 <SamB_XP> I think anyone who had got anywhere in Haskell would want to use the functional approach
17:30:31 <Procyon112> weitzman: IMO, a language should support 1 sane construct by default, and let the compiler do the hard work of optimization.  Compilers are always better at writing fast code than developers in the general case, and developers don't need the extra mental overhead of choosing between multiple equivelent constructs.
17:30:42 <Cale> weitzman: Transformers are a bit of a separate issue, and the confusion there is made worse by the fact that lots of people misuse them.
17:30:54 <SamB_XP> unless maybe they were writing an interpreter for an imperative system
17:31:07 <SamB_XP> or something like that
17:31:09 <Cale> Monad transformers are basically a way to construct a domain specific language quickly.
17:31:13 <ndm> sorear, no, anonomous individual submissions, each of which has to be marked,, and no feedback, so i can't even humiliate them to themselves
17:31:24 <ndm> (or tell them how a Hash table is meant to look like!)
17:31:37 <Cale> That is, they get you to a monad which is close to the one that you want fairly quickly in a lot of cases.
17:31:52 <SamB_XP> ndm: well how is it useful to mark anonymous things?
17:31:55 <Cale> But there are also a lot of cases where you just want State, or ST, or IO.
17:32:15 <weitzman> I don't even have to think about that in a normal imperative langauge
17:32:26 <weitzman> And that's an improvement from an easy-of-writing-code standpoint
17:32:29 <weitzman> *e
17:32:30 <SamB_XP> weitzman: don't get to think about it
17:32:32 <Cale> Well, using a normal imperative language is just like using the IO monad.
17:32:40 <SamB_XP> personally I like my State monad
17:32:41 <ndm> SamB_XP, very - so i don't know who it is and am not biased given their performance in the practicals
17:32:42 <Procyon112> Baughn: Which is why quantum superpositioning and observation causing a collapse of the wave fascinates me... does the universe have finite resources to compute the state of an analog system?
17:32:59 <ndm> (even though one of them cited their network drive...)
17:33:03 <SamB_XP> oh.
17:33:04 <Cale> So if you don't want to think about it, just use the IO monad. Other Haskell programmers might not like it, but you could get away with it.
17:33:37 <Cale> It doesn't give you very many guarantees, but then, neither does the typical imperative language.
17:33:38 <SamB_XP> I'd probably lose points for revealing my identity in that kind of thing...
17:33:42 <sorear> ndm: But if you don't know who did it, what is it useful for?  Gathering statistics about the York intel curve?
17:33:52 <Baughn> Procyon112: The only case where you might reason based on finite resources is when the universe /is/ a simulation. Which is, admittedly, quite possible.
17:34:03 <SamB_XP> other haskell programmers will refactor your program to use IO less
17:34:25 <weitzman> Be that as it may, I personally would rather write imperative code in C++ than Haskell, and I really don't like using C++
17:34:32 <ndm> sorear, every assessment has a 7 digit number, i give marks to that number, then someone in admin (not an academic) matches the numbers up to people
17:34:47 <siti> c++, you're crazy ;)
17:34:48 <ndm> the idea is that academics (which i am filling in as) never know the number <-> person link
17:34:54 <sorear> ndm: Ah.  So it's not so much anonymous as blind?
17:35:00 <ndm> sorear, yes
17:35:09 <Cale> weitzman: hmm, I don't know. The ability to easily construct my own control structures is something that I'd miss programming imperatively in C++.
17:35:12 <sorear> ok.  makes sense now
17:35:16 <Procyon112> Baughn: Right, and the concept that the universe calculates it's state in the most processor-cycle concerving fashion is evidence towards simulation.
17:36:13 <SamB_XP> weitzman: don't assume that people can be that stupid in Haskell
17:36:16 <Baughn> Procyon112: Yes, so if we ever find evidence favoring non-MWI versions of QM over MWI, that would be a good sign. Of course, the fact that it's /quantum/ physics is a bit of a giveaway already.
17:36:27 <weitzman> So remember that we were discussing language design
17:36:47 <Baughn> I see no problem with analog physics, except that it requires infinite resources
17:36:53 <weitzman> And my claim is that it would be nice to have a language where imperative constructs and lazy constructs can be built with equal ease and expressiveness
17:37:02 <weitzman> And I don't feel that Haskell is that language
17:37:08 <sorear> Baughn: No, just use laziness
17:37:12 <weitzman> </myClaims>
17:37:22 <Cale> weitzman: hmm
17:37:27 <ndm> weitzman, but what is it you want imperativeness for?
17:37:28 <sorear> Baughn: I can compute numbers with infinite precision, as long as I print them in order
17:37:37 <SamB_XP> weitzman: what? I can build lazy imperative things!
17:37:37 <Cale> weitzman: What do you think that Haskell's imperative constructs are missing?
17:37:52 <ndm> weitzman, i agree that Haskell isn't the worlds best imperative language (despite how many simon's may disagree)
17:38:00 <fasta> Cale: I know the answer to that one: *
17:38:03 <weitzman> Cale: I don't think they're missing anything per se, I just find them less intuitive and natural to use than imperative languages
17:38:10 <Cale> fasta: but we do have pointers! :)
17:38:18 <Cale> fasta: and IORefs, even :)
17:38:18 <fasta> Cale: we have references
17:38:25 <Cale> No, proper pointers too.
17:38:33 <Baughn> sorear: That just means that the universe could be simulated using finite resources even if it were analog. As it is, it's /not/ analog. ;)
17:38:35 <dibblego> @remember i agree that Haskell isn't the worlds best imperative language (despite how many simon's may disagree)
17:38:35 <lambdabot> Done.
17:38:36 <ndm> Cale, we have monads, they have sequencing built in - obviously we have laziness easily, they have sequencing easily
17:38:45 <ndm> @quote i
17:38:45 <lambdabot> i says: agree that Haskell isn't the worlds best imperative language (despite how many simon's may disagree)
17:38:47 <fasta> Cale: It's a syntactic thing I menat.
17:38:50 <fasta> Cale: meant
17:38:54 <Cale> fasta: ah
17:38:56 <Binkley> dibblego: you left out the attribution there :-)
17:38:58 <ndm> dibblego, its @remember name quote
17:39:01 <weitzman> Cale: Using Haskell for long enough could change my mind, perhaps, but I want a language that bends to my needs instead of enslaving my soft, simple brain
17:39:04 <Procyon112> weitzman: That may be an issue of training.  I also find imperative constructs more natural, but I'm not sure that it's not just a symptom of having programmed imperatively for 20 years.
17:39:12 <fasta> Cale: using monadic syntax is also not very great.
17:39:14 <dibblego> oh
17:39:24 <Cale> fasta: what about it?
17:39:35 <dibblego> @remember <ndm> weitzman, i agree that Haskell isn't the worlds best imperative language (despite how many simon's may disagree)
17:39:35 <lambdabot> Done.
17:39:46 <sorear> @quote ndm imperative
17:39:46 <Binkley> you shouldn't include the <>, either
17:39:47 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
17:39:54 <sorear> @quote <ndm> imperative
17:39:54 <lambdabot> <ndm> says: weitzman, i agree that Haskell isn't the worlds best imperative language (despite how many simon's may disagree)
17:40:00 <fasta> Cale: I'd rather have a good functional programming language (which Haskell already is) and a good imperative language (something like Pascal or Python)
17:40:14 <fasta> Cale: but then joined into one
17:40:17 <Binkley> Pascal is good?
17:40:26 <gravity> Maybe perl 6
17:40:33 <dibblego> how is programming everything in the IO monad, not a good (as good as others) imperative language?
17:40:40 <dibblego> s/a good/as good
17:40:51 <dibblego> er, take that back
17:40:59 <weitzman> Procryon112: We've still got some time until the next generation of hooligans comes along and puts us out of work with their Haskell expertise, so we can demand languages that bend to us for the time being
17:40:59 <sorear> Vonneumann programming is a bad idea to begin with.
17:41:02 <Binkley> Because you need a PhD in category theory to understand monads
17:41:03 <Binkley> ;-)
17:41:12 <SamB_XP> Binkley: since when?
17:41:17 <Binkley> </sarcasm>
17:41:18 <Cale> Probably the hardest thing for beginners in do-notation is that you can't pass actions as parameters to functions and have them run automatically. That means you have to sequence things a little more explicitly (though that might be a good thing, given that there may be side effects), but it also means that you have the ability to pass actions around to construct other actions. (i.e. make your own control structures)
17:41:22 <SamB_XP> doesn't syntaxfree understand them?
17:41:25 <dibblego> Binkley, how so? you just declare IO on everything (or leave it out even)
17:41:28 <Procyon112> weitzman: I've written enough bad code in my life to desire a bit of mind enslavement.  Types are that kind of enslavement, C++'s const-correctness, etc... It's a layer of protection that you aren't writing bad logic.
17:41:33 <dibblego> oh
17:41:35 <sorear> i've worked out the computational efficiency of a P4 chip, it's about 0.0001% - all thanks to the von neumann paradigm
17:41:46 <Binkley> Sorry, I was making fun of the "I don't understand this, therefore it's not useful" threads on the mailing lists
17:41:55 <Cale> There's a lot of mind enslavement going on in C, C++ and Java.
17:42:13 <Binkley> yes, and the primary form of mind enslavement is that people who use those languages tend to think they are good :-)
17:42:14 <gravity> Cale: That reminds me, do you have any examples of people passing around actions to do things like that? I keep hearing about the ability to use actions as first class, but I don't think I've ever seen it
17:42:20 <Cale> In particular, one starts thinking about everything in terms of the order in which to go about doing things.
17:42:41 <Cale> gravity: Well, I'll admit that many of the best examples are already in Control.Monad.
17:42:47 <gravity> heh, ok
17:42:52 <sorear> gravity: look at replicateM_ in the standard library
17:43:00 <gravity> sorear: Cool, thanks
17:43:01 <sorear> gravity: that's a N TIMES loop
17:43:17 <dibblego> "Haskell is not practical because I cannot do my imperative things with it", then "what is impractical (relatively) about programming everything in the IO monad?" -- I've never seen a good answer to this question
17:43:18 <Cale> But probably you could come up with more relatively easily.
17:43:22 <sorear> gravity: the others are a bit more complicated - mapM_ is foreach, etc
17:43:33 <Cale> Actually, Data.Traversable gives you lots lots more too. :)
17:43:39 <gravity> sorear: Ah, ok
17:43:54 <gravity> Somehow I'd missed exactly what these functions were doing
17:43:58 <Cale> Any Traversable data structure becomes a potential control structure :)
17:44:03 <weitzman> dibblego: What's impractical about using Java? You don't like the verbosity of that, maybe I don't like the verbosity of using the IO monad everywhere
17:44:24 <Binkley> at least in Haskell you don't have to write public static void main = ...
17:44:33 <dibblego> weitzman, it's less verbose in Haskell; also, it is more general, so I don't have to rewrite things all the time
17:44:39 <monochrom> I don't like verbosity. No whitespace character wasted.
17:44:46 <dibblego> weitzman, Java is less practical, because it is more (repetitive) work
17:44:56 <sorear> at least in hava you don't have to write writeIORef ...
17:45:24 <Cale> We really do need a standard library for general operations on references in Haskell.
17:45:24 <monochrom> hava would be a great language
17:45:39 <fasta> Java isn't that bad for algorithms where you need STRef in Haskell.
17:45:43 <Procyon112> weitzman: Java is probably the most mind-enslaving language there is... It forces you to do everything a very particular way.
17:45:56 <weitzman> Procyon122: Isn't that the idea behind Python?
17:45:59 <dibblego> weitzman, google for Refunctoring if you want to know what I really think, in a verbose way
17:46:05 <sorear> Cale: The problem with that is it would mean admitting Bulat was right, which is physically impossible for most haskellers
17:46:11 <SamB_XP> weitzman: python fails miserably at it
17:46:24 <SamB_XP> python probably has more TIMTOWTDI than *perl*
17:46:27 <Cale> Something like Graphics.Rendering.OpenGL.GL.StateVar, but not in the OpenGL libraries :)
17:46:36 <Binkley> ?remember sorear The problem with that is it would mean admitting Bulat was right, which is physically impossible for most haskellers
17:46:37 <lambdabot> Done.
17:46:40 <SamB_XP> by accident, maybe, but even so
17:46:46 <Excedrin> monochrom: what's hava?
17:46:56 <fasta> Excedrin: Java spelt wrong
17:46:57 <Cale> In fact, I'd be happy enough just to have that moved up to the Data.* heirarchy.
17:47:01 <SamB_XP> Cale: who said we didn't want one?
17:47:03 <weitzman> SamB_XP: I know people who are so mad about python enforcing whitespace instead of brackets that they refuse to you it
17:47:05 <monochrom> hava is a typo that I exploited :)
17:47:11 <SamB_XP> I thought the problem was that ST could never have instances for it?
17:47:12 <weitzman> SamB_XP: Although those people are crazy
17:47:22 <weitzman> you -> use
17:47:22 <Cale> Hierarchy*
17:47:45 <dolio> @vera TIMTOWTDI
17:47:47 <lambdabot> No match for "TIMTOWTDI".
17:47:50 <Excedrin> I thought it might be some sort of cross between Haskell and Java, but that already exists (CAL)
17:47:51 <SamB_XP> Cale: it seems like it would be kinda silly to have a class like that for just IORef
17:47:54 <Cale> SamB_XP: nobody, but people were talking about having to write writeIORef
17:48:00 * SimonRC reads the logs.  Today's look very interesting
17:48:13 <Cale> SamB_XP: and MVars, TVars, STRefs...
17:48:21 <SamB_XP> Cale: ah, there's the thing
17:48:25 <SamB_XP> MVars are totally different
17:48:35 <SamB_XP> and STRefs have that pesky s
17:48:41 <Cale> oh, right :)
17:48:49 <SamB_XP> which would surely prevent them from being usable with that system
17:48:57 <Cale> MVars aren't *totally* different though
17:48:57 <SamB_XP> so...
17:49:07 <fasta> I hear Mmmmmeeettttaaaa
17:49:09 <sorear> SamB_XP: Bulat can unify IORef with STRef a
17:49:19 <SamB_XP> sorear: I'd like to see it
17:49:19 <Binkley> Bulat Facts ...
17:49:35 <sorear> SamB_XP: I think ghc can too - iirc    type IORef = STRef RealWorld
17:49:35 <SamB_XP> if it works better than MArray on STUArray
17:49:48 <Cale> Oh, right, and elements of IOArrays.
17:49:57 <Cale> we have those too :)
17:50:34 <SamB_XP> but, if MArray on STUArray is any indication... there'd be a lot of nastyness...
17:50:45 <fasta> sorear: You "discovered" that STUArray was not referentially transparant. I am relying on that behaviour.
17:51:02 <SamB_XP> fasta: it isn't?
17:51:19 <sorear> SamB_XP: it isn't!
17:51:28 <SamB_XP> where how why?
17:51:31 <sorear> SamB_XP: newArray_
17:51:38 <SamB_XP> oh?
17:51:43 <fasta> SamB_XP: my algorithm that runs on top of it is, but it's possible to do non-referentially transparant things
17:51:51 <sorear> SamB_XP: Returns an uninitialized array.
17:51:52 <SamB_XP> does that count?
17:52:05 <Cale> It does?
17:52:11 <SamB_XP> Cale: sure!
17:52:22 <Cale> Doesn't it return an action which constructs an uninitialised array?
17:52:27 <SamB_XP> should perhaps be called unsafeNewArray
17:52:41 <SamB_XP> or something
17:52:49 <SamB_XP> it is that kind of function
17:53:08 <Cale> Er, wait, no
17:53:16 <fasta> Some algorithms need such "primitives".
17:53:19 <Cale> newArray_ ... Builds a new array, with every element initialised to undefined.
17:53:38 <fasta> Cale: it's semantically undefined
17:53:44 <fasta> Cale: not actually undefined :)
17:53:57 <fasta> Or I am mixing up things
17:54:52 <Cale> I suppose for unboxed arrays, there's not a whole lot you can do.
17:55:06 <SamB_XP> they can't hold _|_
17:55:13 <Cale> Apart from keeping a mask with as many bits as the array has elements.
17:55:22 <SamB_XP> you could make it call fail I suppose
17:55:33 <SamB_XP> if you wanted to get technical
17:56:20 <dons> please test the xmonad release candidate! --> http://tinyurl.com/395gan
17:56:23 <lambdabot> Title: Gmane -- Mail To News And Back Again
17:56:46 <fasta> Right, I think what I said is correct. However, when one makes a mistake and actually uses a supposedly undefined value it's not detected.
17:56:47 <Cale> Does it have floating windows yet? ;)
17:56:51 <Pseudonym> What's there to test?  Didn't you prove it correct?
17:56:58 <sorear> unfortunately my ghc is broken now
17:57:08 <dons> yeah, ndm did check the core was pattern match safe. :-)
17:57:29 <sorear> Pseudonym: it works.  it does need usability testing though
17:57:33 <dons> in particular, if you have a xinerama set up, testing it all makes sense would be good.
17:57:40 <dons> right.
17:57:44 <fasta> sorear: you can't prove that???!?!?! ;)
17:57:51 <shapr> @yow ! UNICYCLING!
17:57:51 <lambdabot> I want EARS!  I want two ROUND BLACK EARS to make me feel warm 'n secure!!
17:57:55 <dons> the spec is a bit tricky, fasta ;)
17:58:06 <dons> forall x . makesSenseToHumans(x) -- hmm
17:58:09 <shapr> So, how do I express the reverse pendulum problem in Haskell?
17:58:09 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
17:58:33 <Pseudonym> What's the reverse pendulum problem?
17:58:39 <dons> people need not run it: it would be useful to just ensure the build process works.
17:58:45 <Binkley> usually it's more like forall x . exists h . human(h) && makesSenseTo(h, x)
17:58:47 <sorear> Setup.lhs: cannot satisfy dependency X11>=1.1
17:58:47 <sorear> Perhaps you need to download and install it from
17:58:47 <sorear> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11?
17:58:47 <dons> so if you want to fire up cabal, that'd be good.
17:59:00 <dons> indeed
17:59:01 * sorear does a darcs changes on Cabal with intent to ++
18:00:04 <dons> reminds me, we need a new X11 release.
18:00:14 <Pseudonym> That'd be X12, surely.
18:00:19 <SamB_XP> X11R8?
18:00:26 <dons> shapr: testing the candidate? we can't take over the world without you :-)
18:00:47 <SamB_XP> Xorg 7.3?
18:00:57 <sorear> Igloo++
18:01:02 <dons> new X11 haskell binding.
18:01:04 * Pseudonym read a paper in the early 90s about applying fuzzy control systems to the problem of balancing a pole on your hand.
18:01:22 <Pseudonym> They actually built a robot with a ball joint at the base and a long pole sticking up out of it.
18:01:28 <Pseudonym> And the robot managed to keep the pole in the air.
18:01:42 <dons> heh
18:01:44 <SamB_XP> 'tis a popular pastime among roboticists
18:01:47 <Pseudonym> Yeah.
18:01:55 <Binkley> well, it keeps them off the streets
18:01:59 <SamB_XP> the lego version had a trailer
18:02:01 <Pseudonym> This was one of the first attempts which successfully used fuzzy control.
18:02:07 <SamB_XP> which it would forknife
18:02:11 <SamB_XP> I mean jacknife
18:02:29 <Pseudonym> I think it might be easier to control a segway-like device in Haskell.
18:02:36 <SamB_XP> (too slow for the vertical version)
18:03:06 <Pseudonym> The tricky bit is that your motors sometimes need to behave like motors and sometimes like servos.
18:03:24 <sorear> Hmm, is xmonad | x11-extras in debian yet?
18:03:38 <SamB_XP> I don't yet know what that means
18:03:45 <SamB_XP> do they cover that in electrical engineering?
18:03:50 <Pseudonym> What, servos?
18:04:06 <SamB_XP> I'm guessing "yes"?
18:04:12 <Pseudonym> Maybe.
18:04:20 <Pseudonym> Depends on the school, I'm guessing.
18:04:27 <Pseudonym> A servo is a motor plus a position sensor.
18:04:32 <shachaf> sorear: xmonad as a package wouldn't do much good, you'd want to compile it yourself.
18:04:34 <Pseudonym> Plus logic.
18:04:42 <Pseudonym> So a servo can "hold" its position via negative feedback.
18:04:49 <Pseudonym> If it's too far one way, you nudge the motor the other way.
18:05:04 <Pseudonym> A good servo can actually hold a steady torque.
18:05:19 <Pseudonym> e.g. keep the segway vertical even when you're stepping on and off it.
18:05:27 <sorear> shachaf: I'm running xmonad as-is
18:05:55 <shachaf> sorear: I thought you used emacs?
18:06:11 <dmwit> ?where logs
18:06:12 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
18:06:31 <sorear> shachaf: ... and these are mutually exclusive?
18:06:47 <shachaf> sorear: Well, xmonad uses left-alt by default.
18:06:54 <sorear> shachaf: Right.
18:06:58 <shachaf> sorear: Unless you remapped your keyboard.
18:07:10 <sorear> shachaf: And emacs, at least on debian, doesn't use left alt
18:07:21 <sorear> shachaf: it uses left-meta, even in the documentation
18:07:50 <gravity> Xorg 7.3 yes, X12 no way
18:10:10 <i_> 1.3 you mean
18:10:24 <gravity> That's the server
18:10:56 <dons> gravity: testing the snapshot of xmonad? :-)
18:11:03 * dons plays `pimp the open source testing'
18:11:07 <gravity> dons: I'll do it before the night is out :-)
18:11:21 <dons> great. we plan to release around this time tomorrow
18:12:21 <gravity> Nice
18:13:41 <dons> we should get the debian / gentoo / et al package managers up to speed
18:13:54 <gravity> I was going to package it for Debian. I have a package actually for 1.0
18:13:58 <gravity> Er... 0.1
18:14:16 <gravity> The whole having to edit source to modify it kind of threw me off
18:14:33 <dons> how do they handle dwm?
18:14:42 <dons> there's some techniques for this, i think, that packagers use.
18:14:45 <gravity> I don't know, I should check
18:14:58 <dons> the main thing would be to get the dependencies into the package system though
18:15:00 <gravity> I mean, I could patch it easily. I'd probably ship with it a lot of the modifications
18:15:04 <gravity> Oh, that part's easy.
18:15:04 <dons> X11-extras and X11, with xinerama support
18:15:22 <gravity> I packaged x11-extras too. CosmicRay's packaging scripts for haskell libs made it dead simple
18:15:23 <dons> oh, how would you modify it? are our defaults not right?
18:15:27 <dons> cool.
18:15:40 <gravity> They're fine, it's just really bare bones
18:15:53 <gravity> I know that was the goal though :-)
18:15:55 <dons> maybe try 0.2, its quite a bit more featured.
18:16:06 <dons> also, it would be good to package dzen, as a default status bar
18:16:14 <gravity> Ok, I'll give it a go. I'd be happy to maintain it.
18:16:15 <dons> and dmenu, for program launching.
18:16:33 <gravity> I think I may have packaged that too.
18:17:01 <dons> cool
18:19:16 * ray crowns dons volunteer fireman
18:19:57 <dons> do i get a hat?
18:20:04 <sorear> is the loccap going to be restored to 400?
18:20:16 <ray> yeah!
18:20:49 <dons> sorear: if you send the patch to refactor it to 400 lines.
18:21:09 <dons> sorear: do you think that's important?
18:24:37 <dibblego> \forall xs. and xs => or xs is false
18:24:49 <dibblego> does this make sense?
18:25:22 <sorear> Yes,
18:25:26 <sorear> s/,/./
18:25:36 <sorear> > and []
18:25:38 <lambdabot>  True
18:25:39 <sorear> > or []
18:25:40 <lambdabot>  False
18:25:47 <dibblego> right, why does that make sense?
18:26:10 <sorear> @check \ a b -> and (a++b) == and a && and b
18:26:11 <lambdabot>  Falsifiable, after 4 tests: [], [True,False]
18:26:21 <sorear> @check \ a b -> and (a++b) == (and a && and b)
18:26:23 <lambdabot>  OK, passed 500 tests.
18:26:35 <sorear> that doesn't hold unless you use the identity as the base case
18:26:44 <dibblego> if and [] holds, then surely or [] holds?
18:27:18 <sorear> @check let or' [] = True; or' x = or' in \ a b -> or' (a++b) == (or' a || or' b)
18:27:18 <lambdabot>  Couldn't match expected type `Bool'
18:27:29 <dibblego> ah ok
18:27:31 <sorear> @check let or' [] = True; or' x = or x in \ a b -> or' (a++b) == (or' a || or' b)
18:27:32 <lambdabot>  Falsifiable, after 10 tests: [], [False]
18:27:37 <sorear> @check let or' [] = True; or' x = or x in \ a b -> or (a++b) == (or a || or b)
18:27:38 <lambdabot>  OK, passed 500 tests.
18:27:57 <sorear> there is an argument to be had for or [] = _|_
18:28:08 <dibblego> right
18:28:09 <dibblego> thanks
18:28:12 <sorear> i like False (slightly) better
18:28:33 <dibblego> wouldn't any proponent of _|_ also argue the same for and [] ?
18:28:58 <sorear> I suppose, there are two valid interpretations of or xs
18:29:23 <sorear> er, brain error
18:30:21 <sorear> incmaster is cool
18:30:28 <dibblego> I wish Scala had multi-parameter type-classes
18:30:29 <sorear> don't think I'll ever use it
18:32:19 <sorear> Wow. kc5tja is on the top25 for this year
18:32:34 <jcreigh> top 25?
18:32:42 <sorear> active nicks
18:33:01 <sorear> pretty impressive for someone piqued enough to stay off #haskell for a week and a half with a promise of forever :(
18:33:09 <Binkley> haha
18:33:24 <dibblego> why?
18:33:34 <dibblego> why make that promise?
18:33:58 <Excedrin> empty promises leading to heartbreak...
18:34:11 <sorear> 15:12 < lambdabot> kc5tja said 3h 16m 54s ago: I will no longer be returning to #Haskell. It's evident that all my discussions are "pointless." This is a pity. The Haskell community is supposed to be better than this.
18:34:22 <dibblego> a dummy spit?
18:34:33 <dons> sigh.
18:34:42 <dibblego> been a couple of those lately
18:35:01 <dons> he didn't really seem to enjoy discussions on here
18:35:13 <dons> the QC discussion springs to mind. oh well.
18:35:24 <dibblego> according to my IRC logs, that didn't happen here
18:35:33 <dibblego> May 18 13:29:04 <kc5tja>        That'd be useful too.
18:35:34 <dibblego> May 30 11:30:56 <sorear>        Wow. kc5tja is on the top25 for this year
18:36:10 <dons> not everyone fits in. we have maybe 1 person a year where it doesn't work out.
18:36:57 <dibblego> some dummy spits are just knee jerks, and after a recovery, if they are brave enough to admit it, they rejoin
18:37:52 <sorear> dibblego: it's in my logs, because it appeared in response to < sorear> @messages  (I do it in public, so you probably just weren't there)
18:37:57 <sorear> what's a dummy spit?
18:38:24 <dibblego> sorear, loss of temper with an overreaction
18:38:31 <notsmack> he had a blog post complaining about how he was attacked with quickcheck, too
18:38:47 <dons> heh.
18:38:47 <Binkley> IRC is serious business
18:38:48 <dibblego> quickcheck attacks people!?
18:38:55 <notsmack> with, not by
18:39:05 <Binkley> where's the blog post?
18:39:07 <dons> i think the misinterpretation of the QC discussion as a personal attack illustrates the issue
18:39:12 <dibblego> quickcheck is a weapon?
18:39:25 <Binkley> "every tool is a weapon if you hold it right"
18:39:30 <sorear>  http://falvotech.com/news/
18:39:31 <dons> he spent a couple of hours trying to convince us that QC was not useful, and unit tests were just as good.
18:39:31 <lambdabot> Title: NEW NEWS
18:39:33 <dibblego> QC is a WMD
18:39:51 <dibblego> dons, funny, I'm giving a talk soon about quite the opposite
18:39:53 <dons> but he does seem to take things personally, so maybe that's it.
18:40:58 <Binkley> if I wrote a blog post of that length every time someone disagreed with me, I'd never have time to do anything else
18:41:10 <dons> the other side is that he makes inflammatory statements, that invite long discussion
18:41:19 <wchogg> My fun discovery:  trying to do a drop in replacement of the h0p rts into a current ghc doesn't build for more than five seconds.  Wee!
18:41:21 <dons> like "i don't see the value of quickcheck", i think that triggered the last one
18:41:32 <dons> Binkley: :-)
18:42:48 <davidL> @seen int-e
18:42:48 <lambdabot> I saw int-e leaving #ghc, #haskell-overflow and #haskell 2h 3m 21s ago, and .
18:43:01 <dibblego> where is the blog post? is it worth reading at least?
18:43:06 <sorear>  http://falvotech.com/news/
18:43:06 <lambdabot> Title: NEW NEWS
18:43:22 <Binkley> scroll to "haskell community woes"
18:43:37 <Binkley> I like how he's all "QuickCheck was being proselytized to me for hours"
18:43:46 <araujo> hello
18:43:49 <Binkley> because everyone was obviously also forcing him to stay at his computer and keep paying attention to irc :-)
18:45:54 <dibblego> "There has to be a reason why everyone here switched to using QC. Everyone in #Haskell can't be wrong!" <-- is that a misquote? I can't imagine someone using that kind of logical fallacy and getting away with it
18:46:17 <dons> yes, he has a particular way of responding that encourages more discussion
18:46:17 <sorear> wchogg: I don't think it even *could* work.  GHC has to produce binaries that work on the current OS - remember it's bootstrapped
18:46:25 <dons> then he gets suprised that we're still talking about it.
18:46:44 <dibblego> so nobody actually said that - it's his interpretation of what was said
18:47:21 <wchogg> sorear:  Well, when I had looked at the old archived h0p page he made it sound like the rts could just be dropped into ghc-6.2.  Not understanding how ghc works (yet), I wondered if that could still hold.
18:47:35 <dibblego> I think that can be my next blog post - why unit testing (as the industry knows it) is inferior
18:47:49 <dibblego> (universally quantified)
18:48:17 <dolio> I'm not particularly surprised most of the channel was arguing against him, considering the reason most people are here involves an enthusiasm for Haskell and related projects.
18:48:19 <wchogg> dibblego:  What is unit testing "as the industry knows it"?
18:48:26 <sorear> dibblego: False.  Unit testing is superior to no testing at all
18:48:30 <dibblego> wchogg, assertEquals(4, 2 + 2)
18:48:39 <dons> basically, this is why the debate went on and on and on:
18:48:41 <dons>  "<kc5tja> I have read the webpage, read an example of its use, and I still remain unconvinced"
18:48:43 <dibblego> sorear, I don't necessarily believe that
18:48:54 <dons> which is , um, asking irc people to try to convince him, in my book :-)
18:49:18 <dibblego> I think the paper is the best
18:49:25 <Binkley> well
18:49:28 <Binkley> maybe he just felt like sharing
18:49:33 <wchogg> dons:  It was post-ironic meta-conversation.  He didn't expect people to take him so sincerely.
18:50:06 <dibblego> if that is the case, then he should have no problem with a response of "you're wrong [and I'm not going to convince you why]"
18:50:41 <dons> dibblego: i actually suggest the more diplomatic:   "Oh, interesting. I'll look into that"
18:50:52 <wchogg> dibblego:  So is your thesis that basic unit testing doesn't cover complicated enough conditions to be useful?  At least that's what I'm assuming from the 2+2=4 joke.
18:50:53 <dons> then everyone goes "cool", and EOF.
18:51:11 <Heffalump> wi wchogg
18:51:15 <Heffalump> waah.
18:51:26 <Heffalump> I think my / key is broken.
18:51:32 <dons> hai Heffalump.
18:51:36 <dibblego> wchogg, it is that it would be better to state a property about the function (in this case +) and quantify it, since that is what *really* is going on
18:51:36 <Heffalump> morning :-)
18:52:05 <Heffalump> QC is only suitable in a relatively narrow range of circumstances, IMO
18:52:14 <dibblego> wchogg, e.g. forall n. n + 0 = n
18:52:32 <Heffalump> where (a) you have a property that is amenable to equational specification and (b) a set of valid data values that is amenable to random generation
18:52:41 <Heffalump> with good coverage
18:53:01 <dons> yeah. so a lot of haskell, but not a lot of IO-ish stuff. or other languages.
18:53:09 <dons> libraries in particular.
18:53:14 <dons> apps, much harder.
18:53:19 <Heffalump> it's really cool where it applies, but I'm not convinced that it does apply all that often
18:53:45 <dons> actually, we can blame Heffalump for kc5tja leaving, I think:
18:53:46 <dons> "07.05.18:11:55:30 * Heffalump picks the side against kc5tja on the basis that it was a good side to pick in the last pointless argument
18:53:50 <dons> 07.05.18:11:55:39 <kc5tja> Fin.e
18:53:55 <dons> "
18:53:59 <dons> classic Heffalump there :-)
18:54:40 <wchogg> Well, what I really thought was cool was some of the stuff the Programmatica group was working on with actually mixing proofs in with the code.  They do a bit of it in the House paper.
18:54:56 <EvilTerran> internet: serious business
18:55:05 <dibblego> that has a name - forget what it is (p was wrong before, therefore p is wrong now)
18:55:19 <wchogg> But not as serious of business as internet porn.
18:55:50 <Heffalump> dons: yeah :-) Though we did talk by msgs for a while afterwards and he said it wasn't just me.
18:55:52 <dons> yes, we had a bit of a serious cat overdose that day.
18:56:29 <dons> Heffalump: oh, I know, I had a huge msg with him, where he refuted my view that "thanks, looks interesting" was a more diplomatic way to end the debate
18:56:56 <dons> there was some baud rate error I think.
18:57:14 <Heffalump> he didn't seem to be able to just agree to disagree
18:57:32 <dons> yes. exactly.
18:57:43 <Heffalump> even when it was clear (to me) that he was just looking at things from a perspective that other people just didn't share
18:57:52 <dibblego> well sometimes, you don't want to, to either learn or teach, by resolving who is wrong
18:58:15 <sorear> Here, pay us /wg 11
18:58:23 <Heffalump> dibblego: sure, but those arguments really seemed to be about the intuition behind definitions, rather than logical truth or falsehood
18:58:36 <dons> Heffalump: that's my impression to. he wasn't interested, because he couldn't use it on C++/python at work.
18:58:38 <sorear> I love it when I forget about partially typed lines :(
18:58:40 <dibblego> Heffalump, then one or both parties should concede that
18:58:49 <dibblego> Heffalump, want an argument do ya!? huh??
18:58:56 <Heffalump> dibblego: yeah. I don't think we did, either.
18:58:58 <dons> which is all fair enough. just the language involved kept flaming things along.
18:59:36 <Binkley> I've found that not responding is the best way to stop other people from talking :-)
18:59:39 <dibblego> sometimes, I draw a threshold, where, if my estimate that one or both parties will learn something crosses that threshold, I terminate
18:59:42 <dibblego> it seems to work well
18:59:45 <dibblego> screw diplomacy :)
18:59:49 <Heffalump> dibblego: you're wrong, and you're a grotesquely ugly freak.
18:59:59 <Binkley> also, your mom dresses you funny
19:00:01 * dibblego Leffahumps Heffalump 
19:00:03 <Heffalump> (google for the phrase if it seems like I'm just being randomly insulting ;-)
19:00:06 <dons> heh
19:01:14 <Heffalump> anyway, I should go back to bed. Hopefully #haskell has cured my insomnia..
19:01:27 <dolio> dibblego: Tell him he looks like a woozle. That'll show him.
19:01:40 <Heffalump> back in 2 1/2 hours or so
19:01:45 <Binkley> #haskell: curing insomnia since 2002
19:01:51 <dibblego> oh I tell him worse while I am leffahumping him
19:01:52 <Heffalump> before that, IIRC
19:02:07 <Binkley> if I wasn't there, it didn't happen
19:02:10 <monochrom> @remember Binkley #haskell: curing insomnia since 2002
19:02:11 <lambdabot> Done.
19:02:18 <dons> i'm not sure it cures it.
19:02:36 <Heffalump> I made an entire webpage about woozles, thankyouverymuch. It was quite short and I seem to have deleted it since, though.
19:03:23 <Pseudonym> You're not having my hunny.
19:03:35 <dolio> :)
19:04:02 <gravity> Things I learn in #haskell keep me up at night, but maybe that's just me
19:04:21 <Heffalump> ah no, here it is: http://ana10.woozle.arguewith.me.uk/cgi-bin/link.pl
19:04:27 <lambdabot> Title: ana woozle
19:04:45 <Heffalump> a friend was in some contest to make a large chain of woozle links
19:05:02 <araujo> mm.. interesting ... i have suffered of insomnia since 2002
19:05:26 <dibblego> me too, I am recently cured
19:05:44 * Heffalump really goes back to bed
19:06:39 <TSC> @src fix
19:06:39 <lambdabot> fix f = let x = f x in x
19:07:02 <dolio> Whoa, voodoo!
19:07:13 <dons> don't freaky me out with that stuff.
19:09:57 <Binkley> @yow
19:09:57 <lambdabot> Jesuit priests are DATING CAREER DIPLOMATS!!
19:11:19 <dolio> @keal
19:11:19 <lambdabot> proofs are no longer sound
19:11:37 <Binkley> @ghc
19:11:38 <lambdabot> ghc says: No constructor has all these fields
19:13:06 <UUStudent> ???
19:13:16 <dolio> !!!
19:13:54 <wchogg> ...
19:14:11 <hpaste>  blackdog pasted "js hackage" at http://hpaste.org/111
19:14:42 <sorear> @quote punctuation
19:14:42 <lambdabot> clanehin says: <migraine_> ... <shapr> !!! <sorear> ??? <clanehin> Please, take it to #haskell-punctuation.
19:18:46 <blackdog> oops. sorry, didn't mean to announce that.
19:19:54 <blackdog> although i'm slightly amused by the fact that the easiest way to do a simple animation in javascript seems to involve inheritance hacking ;)
19:22:17 <mcnster> hi.  i have a puzzlement re. forkIO ...
19:22:27 <SamB_XP> hmm?
19:23:42 <mcnster> when i make "main do { print "hello" ; forkIO threadA ; print "goodbye" }               (con't)
19:23:59 <mcnster> threadA = print "foo"
19:24:10 <mcnster> all i get is "hello, goodbye"
19:24:32 <SamB_XP> thats because the program exits when the main thread terminates
19:25:02 <mcnster> do i have to explicitly "yield" to threadA then?
19:25:04 <SamB_XP> so the other thread doesn't necessarily get scheduled
19:25:42 <kpreid> mcnster: you need to have main wait for threadA to signal it's done
19:25:55 <SamB_XP> in order to do that, you need the thread id.
19:26:04 <SamB_XP> or handle or whatever it is called
19:26:16 <SamB_XP> (that forkIO returns)
19:26:31 <kpreid> I don't see a way to do that
19:26:37 <kpreid> (wait for a thread exit)
19:26:46 <kfish> ?hoogle wait
19:26:46 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
19:26:47 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
19:26:47 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
19:27:08 <mcnster> SamB_XP, s/threadA ;/threadA ; yield ;/        will that do it?
19:27:42 <kpreid> main = do print "hello"; v <- newEmptyMVar; forkIO $ threadA v; print "goodbye" where threadA v = do print "foo"; putMVar v () -- this should work
19:27:57 <kpreid> mcnster: you shouldn't rely on that; there's no guarantee it won't exit first anyway
19:28:31 <SamB_XP> oh? you can't wait on a thread like that?
19:28:35 <SamB_XP> well, MVars it is then.
19:28:52 <kpreid> Well, I don't see something to do it in Control.Concurrent.
19:29:31 <gravity> I don't understand why that works. Why does the MVar ensure that the thread gets scheduled?
19:29:53 <mcnster> i agree with gravity
19:30:28 <mcnster> ack
19:30:57 <kpreid> gravity: it ensures that the program doesn't exit (by way of falling off main) until the other thread *finishes*
19:31:08 <kpreid> without that, there is no such guarantee
19:31:16 <kpreid> oh, wait
19:31:28 <kpreid> I forgot to write a takeMVar in main!
19:31:34 <kfish> lol
19:31:39 <gravity> Ok, that makes sense then :-)
19:31:49 <SamB_XP> heh
19:32:03 <mcnster> kpreid, hold it.  i assume the vm will switch threads on a finer grain than just thread start and termination....?
19:32:12 <mcnster> am i wrong?
19:32:26 <kpreid> No.
19:32:37 <sorear> mcnster: right, it also switches threads after each GC cycle
19:32:38 <SamB_XP> mcnster: not wrong. but don't assume that it will switch them when you'd like it to
19:32:47 <SamB_XP> assume the opposite, actually
19:32:50 <kpreid> Th problem with your program is that the end of the 'main' thread *triggers the process to terminate*, causing all other threads to stop.
19:32:58 <sorear> mcnster: and when the current thread sleeps (no point in staying on a waiting thread!)
19:33:39 <mcnster> does anyone know the rationale for creating a thread that might never be run if its not "fast enough"?
19:33:45 <kpreid> mcnster: the *right thing to do* is to write your program not to rely on ordering of events that isn' guaranteed
19:34:16 <Zao> mcnster: The rationale is: "When you reach the end of the program, all of it ends"
19:35:04 <mcnster> Zao, ok, i can see that.  it just seems strange
19:35:42 <kfish> the initial thread is special, perhaps that's what's strange
19:35:59 <kpreid> waiting for all threads to exit would have its own oddities
19:35:59 <SamB_XP> I admit sometimes it is a bit odd
19:36:13 <SamB_XP> but, yeah, kpreid is correct
19:36:46 <kpreid> actually, I can see having wait-for-me and don't-wait-for-me threads
19:37:10 <mcnster> kfish, understood.  it just seems strange from a "lazy" point of view.  if a thread forks should not both points of the fork need to terminate before the vm cleans up?
19:37:47 <kpreid> except it doesn't need to be a feature of the thread. forkIO $ withBusiness $ do ... -- as long as any withBusiness is active, the process doesn't exit, let's say
19:38:59 <sorear> @botsnack
19:38:59 <lambdabot> :)
19:39:07 <LoganCapaldo> well if its anything C / unix, the program tells the OS when to end its process. It's just that the code that says "end me" is implictly tacked on to the end of the first thread.
19:39:15 <kpreid> you can even implement that user-level by writing main = do ...; waitForBusiness, with appropriate definitions for those
19:39:22 <SamB_XP> we were just talking about how it is odd that haskell programs exit when the main thread terminates
19:41:21 <mcnster> ok, i'll try it using mvars.  i forget, did someone say it was unwise to use yield?
19:41:43 <SamB_XP> mcnster: not unwise to use it, necessarily
19:41:53 <SamB_XP> just don't depend on it doing anything
19:42:30 * SamB_XP thinks there ought to be an RTS option to get it not to do anything
19:42:50 <kfish> yield just switches to the other thread, it doesn't guarantee that the other thread will run to completion
19:43:44 <mcnster> SamB, say i have a binary tree of threads with main at the top and threadA and threadB forkIO-ed from main.  if main yields, then _something_ else is going to run (or so I'd like it)
19:44:30 * kpreid points out that in sufficiently-multicore machines yield may not have anything to do!
19:44:44 <SamB_XP> mcnster: yield only shuffles the schedules a bit
19:45:02 <mcnster> kpreid, ah so!  that answers my q!
19:45:24 <mcnster> i'll play with mvars and see what i get.  thanks all.
19:54:17 <Binkley> @quote
19:54:17 <lambdabot> desp says: [monochrom]: It is, however, hard to demand other people to be open-minded. [desp]: not if you've got a big enough axe
19:54:26 <pchiusano> hello
19:54:34 <gravity> Well, the xmonad RC works great for me
19:55:07 <pchiusano> does haskell have a replace function?
19:55:32 <LoganCapaldo> @hoogle replace
19:55:32 <lambdabot> Data.Array.Diff.replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
19:55:32 <lambdabot> System.Win32.File.mOVEFILE_REPLACE_EXISTING :: MoveFileFlag
19:55:32 <lambdabot> System.Win32.Registry.c_RegReplaceKey :: PKEY -> LPCTSTR -> LPCTSTR -> LPCTSTR -> IO ErrCode
19:55:37 <EvilTerran> O.O
19:55:41 <monochrom> what is a replace function?
19:55:44 <EvilTerran> pchiusano, what do you mean?
19:56:24 <pchiusano> I'd like replace [1, 2, 3] f = [1, 2, 2]
19:56:45 <EvilTerran> hm... network's choppy tonight.
19:56:50 <sorear> Oh nice.
19:56:53 <EvilTerran> pchiusano, where f is what?
19:56:58 <LoganCapaldo> Yarr. Tis a storm brewing
19:57:03 <Binkley> @yarr
19:57:03 <lambdabot> Splice the Mainbrace!
19:57:03 <monochrom> replace xs f = case xs of [1,2,3] -> [1,2,2]  ?
19:57:05 <pchiusano> for f x = case x of 3 -> Just 2; otherwise -> Nothing
19:57:17 <sorear> It seems they've improved on SchÃ¶nhage-Strassen
19:57:24 <jfredett> hmm, what else should I make people buy me for my birthday?
19:57:34 <sorear> lambdapops
19:57:35 <monochrom> A haskell book.
19:57:38 <Binkley> a pony
19:57:44 <LoganCapaldo> The heart of a small child
19:57:47 <jfredett> I have TaPL, ATTaPL, Purely Functional Data Structures
19:57:55 <monochrom> @slap LoganCapaldo
19:57:56 <lambdabot> why on earth would I slap LoganCapaldo
19:57:56 <jfredett> and Principia Mathematica to the 56
19:58:11 <monochrom> Fun in Programming?
19:58:11 <jfredett> @slap myself
19:58:12 * lambdabot smacks myself about with a large trout
19:58:17 <jfredett> lol
19:58:24 <Binkley> @slap jfredett
19:58:24 * lambdabot smacks jfredett about with a large trout
19:58:29 <sorear> LoganCapaldo: not quite sure that's legal
19:58:30 <pchiusano> erm, does that definition make sense? basically, it takes a replacement function which maps only the values in the list for which the replacement function returns a non Nothing value
19:58:30 <SamB_XP> I want TaPL
19:58:47 <jfredett> Fun in Programming? is it good?
19:58:56 <kpreid> pchiusano: replace xs f = map (fromJust . (f `mplus`) . Just) xs
19:58:56 <SamB_XP> I mentioned yesterday that I got Purely Functional Data Structures to save on shipping for a TI 30-IIX ;-)
19:59:03 <monochrom> There is no replace function in the library. Do you know how to write it?
19:59:18 <jfredett> hmm, TI 30-IIX
19:59:24 <jfredett> that sounds nice
19:59:26 <LoganCapaldo> @type maybe
19:59:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:59:49 <EvilTerran> kpreid, that strikes me as overkill O.o
19:59:55 <monochrom> Fun in Programming is good. It's so good Andrew Choppin doesn't understand all of it.
20:00:02 <Binkley> haha
20:00:32 <kpreid> replace xs f = map (\x -> maybe x (f x)) xs -- this?
20:00:49 <sorear> Choppin eh?
20:00:55 <pchiusano> kpreid: reading...
20:01:03 <jfredett> more accurately, a new calculator sounds nice
20:01:38 <pchiusano> kpreid: yes, that's it
20:02:07 <pchiusano> I was just wondering if it was in the prelude
20:02:10 <kpreid> pchiusano: how about making the argument order replace f xs
20:02:12 <pchiusano> ...already
20:02:13 <SamB_XP> my little sister was complaining that the calculator she was supposed to be using didn't have expression display...
20:02:30 <SamB_XP> and I couldn't find my old one...
20:02:33 <kpreid> pchiusano: well, if you changed the function to return its argument in the no-change case, then t's just map f xs
20:02:42 <pchiusano> kpreid: ya, I think that was what I meant
20:03:03 <kpreid> @pl replace f xs = map (\x -> maybe x (f x)) xs
20:03:04 <lambdabot> replace = map . ap maybe
20:03:06 <pchiusano> that's true...
20:03:14 * kpreid recognized the ap pattern :-)
20:03:44 <kpreid> @type ap maybe
20:03:46 <lambdabot> forall b a. (b -> a -> b) -> b -> Maybe a -> b
20:03:47 <pchiusano> yeah, there is really no point to making otherwise return Nothing, rather than the arg
20:04:47 <pchiusano> okay, now suppose I have a function, f 'a' = 'b'
20:04:57 <kpreid> @type map . ap maybe
20:04:59 <lambdabot> forall b a. (b -> a -> b) -> [b] -> [Maybe a -> b]
20:05:08 <kpreid> hm, looks like pl forgot some parentheses
20:05:22 <kpreid> @type (map . ap) maybe
20:05:24 <lambdabot> forall b a. [b -> a -> b] -> [b -> Maybe a -> b]
20:05:42 <kpreid> huh?
20:05:43 <pchiusano> can I get a function which is equivalent to f, but just returns f x for all x != 'a'
20:05:58 <kpreid> pchiusano: no, you can't (or, shouldn't)
20:06:22 <pchiusano> basically, there is no way to 'catch' the missed pattern match?
20:06:42 <kpreid> not specifically
20:07:25 <EvilTerran> pchiusano, you'll have to wait for Haskell' for that, i think. if they even decide to implement it then. (i seem to recall it was on the "probably not" list, last i checked)
20:08:12 <pchiusano> hum, ok
20:09:00 <EvilTerran> (what was the notation, again? (|pat -> exp) of (\pat -> exp) invoked monadic fail instead of error if no patterns matched or sth?
20:09:06 <EvilTerran> s/of/over/
20:09:44 <edwardk> My coworkers have found a way to get back at me for monopolizing their lunch breaks with discussions of type theory... they started calling me Eddie Haskell.
20:09:44 <EvilTerran> pchiusano, if you're writing the fn yourself, you can just write "f 'a' = 'b'; f x = x"
20:09:46 * edwardk sighs.
20:11:23 <monochrom> I don't actually understand.  f 'a' = 'b'; f _ = undefined.  Then we want g such that g 'a' = what? and g x = f x = undefined for x /= 'a'?  I mean is it easier to just write g _ = undefined?
20:11:43 <edwardk> i think the issue is the lack of an extensible case construct in haskell
20:12:10 <EvilTerran> monochrom, i think he wanted f 'a' = 'b'; g x = (f x) `catchPatternMatchFailure` x
20:12:22 <edwardk> yeah
20:13:29 <EvilTerran> edwardk, i think the idea behind (| -> ) notation would be to provide something equivalent to that
20:15:59 <EvilTerran> http://hackage.haskell.org/trac/haskell-prime/ticket/114
20:16:01 <lambdabot> Title: #114 (introduce lambda-match (explicit match failure and fall-through)) - Haskel ...
20:17:39 <pchiusano> back
20:18:46 <monochrom> Is there a way to write a pattern matching that matches nothing?
20:19:02 <lispy> foo Nothing = 1
20:19:04 <lispy> :)
20:19:11 <Binkley> you mean like case foo of { _ | False -> ... } ?
20:19:14 <monochrom> Not that Nothing.
20:19:34 <monochrom> Yes, like that.
20:19:51 <lispy> why would you want a pattern that matches nothing?
20:19:54 <LoganCapaldo> data Void; f x :: Void -> (); f x = case x of ..
20:19:58 <LoganCapaldo> that's still not right
20:20:03 <LoganCapaldo> stupid undefined
20:20:16 <mcnster> followup:  if I want a thread to "catchDyn forever handleMessage", what would be good definition of "forever" be?
20:20:23 <chessguy> @type f Nothing = 1
20:20:25 <lambdabot> parse error on input `='
20:20:32 <lispy> i have seen the thing like Binkley described used for strictness...iirc ghc has an extension for it now
20:20:46 <LoganCapaldo> @type (\Nothing -> 1)
20:20:48 <lambdabot> forall t t1. (Num t1) => Maybe t -> t1
20:21:04 <EvilTerran> i guess it might be of some use when reasoning about programs algebraically
20:21:11 <monochrom> If there is extensible pattern matching, then there should be a "zero".
20:21:26 <EvilTerran> yeah, that's what i was trying to say
20:21:58 <lispy> that argument is too abstract for me
20:22:20 <chessguy> how does it know that 1 can be any instance of Num?
20:22:30 <monochrom> If you can prepend stuff to a list, you also want an empty list naturally.
20:22:38 <lispy> chessguy: some evil magic, i think it's referred to as defaulting
20:22:45 <EvilTerran> lispy, says someone named after a modtly-academic programming language, in a channel about a mostly-academic programming language
20:23:00 <EvilTerran> how could anything be too abstract for you? :P
20:23:06 <chessguy> mm, no, defaulting would be if it can't determine anything beyond Num, and so it picks something
20:23:21 <chessguy> (Integer in ghc, IIRC)
20:23:56 <EvilTerran> i guess it's just a bit of magic behind the Num classes
20:24:03 <EvilTerran> *types
20:24:06 <lispy> chessguy: good point
20:24:18 <EvilTerran> there's plenty ofthat regardless; there's an infinity of constructors, for one
20:24:28 <lispy> how about this
20:24:34 <lispy> ?tpe (\Nothing -> [])
20:24:36 <lambdabot> forall t a. Maybe t -> [a]
20:24:41 <monochrom> The type checker looks for numeric literals and assigns them "Num a => a". No questions asked.
20:25:01 <lispy> ?type (\Nothing -> 1.0)
20:25:03 <lambdabot> forall t t1. (Fractional t1) => Maybe t -> t1
20:25:13 <EvilTerran> ?type fail "eeeegad"
20:25:14 <lispy> monochrom: it might ask some questions :)
20:25:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
20:25:15 <edwardk> numeric literals get a 'fromInteger' stuck in front of them
20:25:35 <edwardk> then ghci/lambdabot sticks a 'default' to Int in there if nothing more concrete is inferred
20:25:40 <lispy> chessguy: so the short answer is that it wants to least general type that it can get away with?
20:26:01 <monochrom> OK, I go with edwardk
20:26:21 * EvilTerran wibble
20:26:57 <lispy> i would love to find some time to write a haskell type inferencer
20:27:15 <lispy> i think it would really advance my knowledge of the language, especially if it supported GADTS
20:27:55 <lispy> well, i'm off, good night
20:27:57 * lispy *
20:28:06 <lispy> let me try that again
20:28:07 * lispy &
20:36:41 <shapr> I really enjoyed that laziness discussion that happened while I was unicycling.
20:37:45 <decaf> I think I understood what lazyness is, after weeks.
20:38:07 <kfish> ah unicycling, the secret to lazy evaluation of IRC
20:38:19 <shapr> hah
20:38:34 <decaf> this would be easier if I've never written any code before
20:38:44 <edwardk> decaf: =)
20:38:49 <shapr> I got stopped by a bunch of people today while unicycling, they had to tell me it was cool.
20:38:58 <shapr> Kept breaking me out of my coding daze.
20:39:04 <Binkley> and you were all, "thanks, I didn't know that"?
20:39:08 <shapr> Yeah, pretty much.
20:39:13 <edwardk> so somehow this morphed into a discussion of lazy evaluation?
20:39:43 <shapr> Some good quotes from today's discussion: "<dibblego> weitzman, once a structure is strict, it has incurred a space cost; which cannot be reversed - the inverse is not true"
20:39:53 <shapr> "<stepcut> it my seem like an error to have a line of code that just computes a boolean value and throws it away, but maybe == has some important side-effects!"
20:40:03 <sorear> shapr: um, how do you code while unicycling?
20:40:12 <shapr> sorear: How do you code while looking out the window?
20:40:26 <edwardk> with an erasable marker?
20:40:26 <kfish> edwardk, discusions about lazy evaluation are the fixpoint of #haskell, they tend to happen regardless of topic
20:40:27 <edwardk> =)
20:40:53 <edwardk> and something to wipe the window off with afterwards
20:41:13 <sorear> shapr: I use xmonad.  I'm *always* in a window, there is no slop. :)
20:41:31 <Binkley> Or... how do you code in the shower?
20:41:38 <shapr> "<dibblego> weitzman, so you argue that you should trade space (strictness) to save computation? sure, that would be plausible \n <dibblego> weitzman, the point is, whether or not you make that trade, should be decided by you "
20:41:52 <shapr> Binkley: I have the urge to make all sorts of suggestive jokes.
20:42:00 <Binkley> shapr: I won't be the one to stop you
20:42:24 <shapr> "<dibblego> weitzman, I could write the strict version in terms of the lazy version quite easily; but the other way around requires a complete rewrite"
20:42:43 <shapr> weitzman makes a bunch of interesting points too, but they're more spread out, and so harder to quote.
20:42:47 <shapr> "<weitzman> And my claim is that it would be nice to have a language where imperative constructs and lazy constructs can be built with equal ease and expressiveness"
20:43:07 <mcnster> can someone explain to me what a "blackhole" is?
20:43:27 <shapr> And one of my favorite quotes:<Procyon112> weitzman: IMO, a language should support 1 sane construct by default, and let the compiler do the hard work of optimization.  Compilers are always better at writing fast code than developers in the general case, and developers don't need the extra mental overhead of choosing between multiple equivelent constructs.
20:43:46 <sorear> mcnster: A point of decidable no return.
20:44:03 <sorear> mcnster: Once the evaluation zipper enters a blackhole, it ain't coming out.
20:44:18 <edwardk> mcnster: you enter into a thunk to evaluate it, but maybe its going to need itself for the answer, so you tag it, with a blackhole while you are working on it, before you write the answer in. if you encounter a black hole you know you can't compute what you need
20:44:22 <shapr> In my opinion, that's the great power of Haskell, not laziness or anything else, but instead writing code with very little programmer micromanagement involved, and relying on the compiler to do all the hard work.
20:44:38 <shapr> It's equivalent to instruction ordering in the CPU, and all sorts of other stuff.
20:45:16 <sorear> mcnster: In GHC this is done using the elementary result on FSM's that once you've looped once, you will loop forever.  So we abort when the evaluation zipper loops back on itself
20:45:21 <shapr> I think Haskell is one step closer to the essential intent of a program because of that.
20:46:07 <sorear> mcnster: this is a cheap nicity on a UP system, and free on SMP systems (it falls out naturally of thunk locking + deadlock detection)
20:46:56 <edwardk> you place the blackhole there for a number of reasons, one is in case you come back you can see you are stuck in a rut, another is it enables garbage collection of certain structures that would otherwise be uncollectable during evaluation
20:47:40 <mcnster> so an expression is tagged as a blackhole then when it reaches a criteria?
20:48:24 <shapr> It's funny that there's so much interesting traffic when #haskell is 42 users below the high water mark.
20:48:32 <Japsu> 42!
20:48:36 <Japsu> \o/
20:48:53 <shapr> joo
20:49:35 <edwardk> mcnster: when you start to evaluate it, you mark it, then if you come back to evaluate it again, in the course of evaluating it the first time you can spot that something hinky is happening
20:49:51 <shapr> The Morel of this story is: Mushrooms um... oh never mind.
20:50:31 <mcnster> edwardk, ok.  so how is it ever resolved?
20:50:52 <edwardk> mcnster when you get the answer you write it in place of the blackhole
20:51:04 <edwardk> then if you come back to evaluate it, you just get the answer. ;)
20:51:10 <edwardk> thats the whole power of a memo-thunk
20:51:34 <mcnster> edwardk, grok
20:52:07 <edwardk> so say you have a thunk representing a deferred calculuation of 2 + 2.. you start to evaluate it, mark it with blackhole, recurse in and do the stuff, get an answer 4, write it over the blackhole and back out.
20:53:07 <mcnster> edwardk, but "2 + 2" would never be marked as a blackhole in the first place, would it?
20:53:15 <edwardk> now, try to evaluate a thunk equal to  fix id, you enter in, write the blackhole, come around and you need to evaluate that same thunk to get your answer, so you yell very loudly
20:53:24 <sorear> Yes, lazy languages require impure implementations.  It has been proven that laziness can run certain algorithms asymptotically faster than strictness if you assume purity.
20:54:08 <sorear> Try fix id in GHCi 6.6 and 6.4
20:54:12 <edwardk> my understanding is that blackholes are generally marked on any expression that could possibly be reused while the thunk is being evaluated.
20:54:13 <Binkley> > fix id
20:54:16 <lambdabot>  Exception: <<loop>>
20:54:44 <edwardk> without the blackhole you'd never  be able to spot the <<loop>> condition
20:54:45 <mcnster> interesting
20:55:06 <edwardk> it won't catch everything , but it catches a surprisingly broad class of infinite loops
20:55:12 <mcnster> @hoogle fix
20:55:13 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
20:55:13 <lambdabot> Control.Monad.Fix :: module
20:55:13 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:55:32 <edwardk> and it serves other purposes for garbage collection, etc.
20:55:32 <SamB_XP> edwardk: or not so surprisingly
20:56:02 <SamB_XP> it does, after all, include the greater part of the "oh I'm such a dumbass" class
20:56:29 <SamB_XP> it also serves thread-coordination purposes
20:56:29 <edwardk> well, by the time the optimizer has done its job it catches a lot of things I thought it shouldn't be able to catch, so surprising to me ;)
20:56:55 <SamB_XP> so that multiple threads won't waste lots of time on long computations
20:57:40 <SamB_XP> edwardk: one wonders if maybe the optimizer could just insert code that prints <<loop>> instead of letting it blackhole, sometimes
20:57:49 <sorear> too bad the rts not see one off bug
20:57:49 <mcnster> in another unrelated q, what does GRAN stand for in the vm?
20:58:02 <edwardk> sam =)
20:58:11 <SamB_XP> what?
20:58:21 <sorear> mcnster: Scheduling granularity, I guess.  Like HZ in linux, if you're familiar w that
20:58:30 <mcnster> sorear, yes i am
20:58:38 <SamB_XP> wasn't there some parallel version with GRAN in the name?
20:58:47 <SamB_XP> GRANSIM or something?
20:58:50 <mcnster> GRAN is more granular than say, nonthreaded?
20:59:18 <sorear> SamB_XP: that was a simulator only
20:59:26 <SamB_XP> true
20:59:32 <SamB_XP> at least, so the name suggests
20:59:45 <sorear> SamB_XP: tracks the data deps and reports how much time would be needed on $UNAFFORDABLY_MANY processors
20:59:59 <mcnster> oh a simulator.  that makes sense now
21:00:07 <SamB> > 2^16
21:00:08 <lambdabot>  65536
21:00:12 <SamB> that many processors?
21:00:17 * sorear thinks jiffies is the most hysterical raisin in linux
21:00:30 <sorear> SamB_XP: Computers have been built with that many cores.
21:00:41 <mcnster> connection machine
21:00:41 <SamB> sorear: yes but can any of us afford them?
21:00:44 <sorear> I think that's the count of PPC64's in blue gene/l
21:00:52 <sorear> uh, probably not
21:01:04 <SamB> also blue gene counts not afaict
21:01:21 <SamB> because I don't think we have an ethernet bus implementation...
21:01:37 <mcnster> ... with a little red cpu activity light just to keep one amused :)
21:01:49 * sorear would like to see 64k old schools stack processors on a chip.  would probably take less silicon than a single p4
21:01:56 <SamB> or whatever interconnect blue gene uses
21:02:02 <sorear> +core
21:02:29 <mcnster> thanks all.  time to listen to Riley Martin.  ciao
21:04:35 <Binkley> @quote
21:04:35 <lambdabot> delicious-malicious-test says: @quote dmt
21:04:53 <SamB> @quote dmt
21:04:53 <lambdabot> delicious-malicious-test says: @quote dmt
21:05:03 <SamB> ack
21:05:07 <SamB> @quote
21:05:07 <lambdabot> sethk says: it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
21:05:13 <SamB> @quote
21:05:13 <lambdabot> lennart says: the best way of debugging is to understand your code
21:05:24 * SamB can't clobber the stack in C without getting out of bed
21:05:30 <SamB> (I don't have a laptop)
21:05:36 <SamB> (or a computer in my room)
21:05:46 <SamB> I had one in there, but it was way too noisy...
21:05:53 <Binkley> that explains why my dreams last night kept getting overwritten with garbage data
21:15:14 <Binkley> @quote
21:15:14 <lambdabot> your_mom says: Oh, that felt good.  Can you do it again?
21:18:25 <SamB> @quote
21:18:25 <lambdabot> greentea says: To learn Monads, one must /become/ a Monad.
21:18:30 <SamB> @quote
21:18:30 <lambdabot> ##C++ says: [asking about C++ rules] vincenz: how should we know what those rules mean ?
21:19:40 <SamB> @quote
21:19:41 <lambdabot> edwinb says: I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them.
21:20:08 <SamB> @quote
21:20:09 <lambdabot> Paltas says: i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something..
21:21:00 <slowriot> @quote
21:21:00 <lambdabot> araujo says:  Feel free to stop by and drop in some words if you like :-)
21:21:14 <i_> yeah i saw some big thread about guido wanting to remove lambda
21:21:24 <i_> i guess stick with your core competencies..
21:21:52 <decaf> @quote
21:21:53 <lambdabot> araujo says: [Ontolog] araujo: if you like Haskell so much why don't you marry it?! [araujo] Ontolog, I am .... internally .... i am
21:23:23 <Pseudonym> @quote guido
21:23:24 <lambdabot> dons says: [When asked what qualifications Guido van Rossum has...] a chip on his shoulder?
21:23:48 <decaf> if you like haskell so much, why don't you write and share some useful tools with it, like novell does for mono.
21:24:36 <araujo> mm.. i don't remember that quote :-)
21:24:44 <dibblego> what is R6RS?
21:24:55 * araujo probably has been around longer than what he thought
21:24:55 <SamB> dibblego: comes after R5RS
21:28:34 <SamB> dibblego: you know, the latest Scheme standard?
21:28:45 <dibblego> I do now, thanks :)
21:29:01 <shapr> @quote
21:29:01 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
21:29:01 <lambdabot> Haskell
21:29:28 <shapr> @quote
21:29:28 <lambdabot> Taral says: But I can do DP in C, which has no RT
21:31:34 <slowriot> @quote
21:31:34 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
21:32:16 <araujo> languages that don't work on infinite data structures ... are worthless
21:32:18 <araujo> :-)
21:40:08 <jfredett> araujo, i dont know about worthless
21:40:14 <jfredett> but they certainly aren't as fun
21:59:10 <decaf> @quote
21:59:10 <lambdabot> Procyon112 says: It really kind of bothers me that the universe feels the need to save processor cycles.
22:00:16 <sorear> Heh, that was remembered today.
22:01:03 <TSC> How do "really" and "kind of" go together?
22:01:45 <kfish> O RLY?
22:01:46 <kfish> KINDA!
22:03:45 <SamB> @quote
22:03:46 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
22:03:56 <SamB> @quote
22:03:56 <lambdabot> lennart says: system verilog is one of the worst "designs" i've ever seen. so i bet it will be popular
22:04:02 <SamB> @quote
22:04:03 <lambdabot> I says: think a quote from Cylons of the Lambs would be most appropriate: 'Would you frak me? I'd frak me. I'd frak me hard.
22:04:11 <davidL> is it insane to expect "fil a b = (length . filter (==a) . map digitToInt . show) b" to run 10^9 times in under a minute?
22:05:15 <SamB> davidL: what type is b?
22:05:31 <davidL> SamB: Int
22:05:59 <SamB_XP> profiled yet?
22:06:28 <davidL> no
22:07:00 <weitzman> I believe 10^9 simple arithmetic operations should be doable well within a minute. If memory allocation happens, perhaps not
22:07:04 <TSC> Project euler?
22:07:09 <davidL> yeah
22:07:51 <sorear> davidL: how big are a and b ?
22:08:18 <davidL> a = [1..9]; b = [1..10^9]
22:09:18 <davidL> ghci just crashed =\
22:09:25 <davidL> figures
22:09:57 <sorear> davidL: what pe #
22:10:07 <davidL> problem156
22:11:01 <davidL> there's undoubtedly something simple that I'm failing to realize
22:14:58 <davidL> sorear: do you see anything?
22:15:22 <sorear> i'm trying to derive your 10^9 (no hints please)
22:15:55 <davidL> oh
22:16:00 <davidL> heh
22:21:53 <jargonjustin> How would one write a function: average :: [Int] -> Float
22:22:14 <jargonjustin> (or something of similar type)
22:24:38 <dibblego> ?dict detail
22:24:38 <lambdabot> Supported dictionary-lookup commands:
22:24:38 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
22:24:38 <lambdabot> Use "dict-help [cmd...]" for more.
22:26:19 <notsmack> jargonjustin: what's the problem?
22:26:38 <jargonjustin> notsmack: I'm trying to compute the floating-point average of a list of integers
22:26:44 <Cale> jargonjustin: first convert the elements to floats using fromIntegral, then do the arithmetic
22:27:06 <notsmack> (or just convert the sum using fromIntegral)
22:27:14 <Cale> er, yeah :)
22:27:35 <davidL> > let average xs = fromIntegral(sum xs) / (length xs) in average [1..10]
22:27:36 <lambdabot>   add an instance declaration for (Fractional Int)
22:27:36 <lambdabot>     In the expression: (fr...
22:27:37 <Cale> fromIntegral (sum xs) / fromIntegral (length xs)
22:27:49 <davidL> > let average xs = fromIntegral(sum xs) / fromIntegral(length xs) in average [1..10]
22:27:50 <lambdabot>  5.5
22:28:00 <Cale> Unfortunately, length doesn't have as general a type as you might like.
22:28:15 <jargonjustin> Cale: thanks
22:28:30 <jargonjustin> If I need lists with over a billion elements I'l write my own :-)
22:29:52 <SamB_XP> jargonjustin: or use genericLength
22:30:20 <notsmack> @type genericLength
22:30:22 <lambdabot> forall b i. (Num i) => [b] -> i
22:30:35 <notsmack> @src genericLength
22:30:35 <lambdabot> genericLength []    = 0
22:30:35 <lambdabot> genericLength (_:l) = 1 + genericLength l
22:30:41 <jargonjustin> Wait, (/) :: Fractional a => a -> a -> but fromIntegral is (Num b, Integral a) => a -> b, how does that work?
22:31:48 <jargonjustin> Oh, nevermind.
22:32:18 <jargonjustin> Type-class polymorphism saves the day again.
22:35:28 <davidL> is there any way this could be more efficient: "fil a b = (length . filter (==a) . map digitToInt . show) b" to find the number of digits a in Int b?
22:36:05 <emu> :t count
22:36:07 <lambdabot> Not in scope: `count'
22:36:41 <davidL> ?index count
22:36:41 <lambdabot> Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
22:36:42 <emu> yea im sure there's some clever math trix
22:37:01 <davidL> math trix would be good :)
22:37:23 <emu> d1 + d2*10 + d3*100 + d4 * 1000 ...
22:37:26 <jargonjustin> davidL: Decimal digits?
22:37:40 <sorear> davidL: I've just put f into CLOSED FORM
22:37:55 <emu> seems exciting
22:37:58 <davidL> sorear: I don't belive you
22:38:05 <Pseudonym> jargonjustin: Actually, that's a very weird dice roll in D&D.
22:38:06 <davidL> believe rather
22:38:07 <sorear> er, not quite, oops
22:38:19 <Pseudonym> @dice d1 + d2*10
22:38:19 <lambdabot> unexpected "d": expecting number
22:38:26 <Pseudonym> @dice d1 + 10d2
22:38:26 <lambdabot> unexpected "d": expecting number
22:38:31 <Pseudonym> @dice 1d1 + 10d2
22:38:31 <lambdabot> 1d1 + 10d2 => 17
22:38:31 <sorear> fvo closed form including conditionals (but not sums etc)
22:38:34 <Pseudonym> Right.
22:38:42 <Pseudonym> @dice d1 + 10d2 + 100d3 + 1000d4
22:38:42 <lambdabot> unexpected "d": expecting number
22:38:47 <Pseudonym> @dice 1d1 + 10d2 + 100d3 + 1000d4
22:38:47 <lambdabot> 1d1 + 10d2 + 100d3 + 1000d4 => 2787
22:38:49 <Pseudonym> Gah.
22:39:35 <monochrom> @hoogle Int -> Char
22:39:35 <lambdabot> Char.chr :: Int -> Char
22:39:35 <lambdabot> Char.intToDigit :: Int -> Char
22:39:35 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
22:40:05 <monochrom> length . filter (== intToDigit a) . show   ?
22:40:25 <emu> davidL: like, you could divide by 10^i, quotient is the ith place, take the remainder and divide that by 10^(i-1)...
22:40:32 <emu> or something
22:40:47 <monochrom> show already does all that division
22:40:52 <emu> yea
22:40:58 <emu> i don't think its any better
22:41:26 <monochrom> Moreover it doesn't compute 10^n and 10^(n-1) redundantly.
22:41:31 <davidL> thanks emu and monochrom
22:41:56 <monochrom> @src showInt
22:41:56 <lambdabot> Source not found. You type like i drive.
22:42:18 <emu> lambdabot is a menace behind the wheel
22:42:45 <monochrom> @src showIntAtBase
22:42:45 <lambdabot> Source not found. Where did you learn to type?
22:42:48 <emu> always distracted
22:42:55 <monochrom> @src Numeric.showIntAtBase
22:42:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:57:03 <emu> @src mercy
22:57:04 <lambdabot> Source not found. Are you on drugs?
22:59:33 <emu> i'm high on amino acid
22:59:59 <emu> polypeptides
23:07:00 * sorear just successfully wasted another day on freenode.
23:07:06 <emu> congrats
23:07:13 <emu> i'm somewhere up around 10 years
23:07:25 <emu> you'll be there someday
23:07:37 <sorear> say, is there a time-sensitive k-line feature in hyperion?
23:08:06 <TSC> @pl (\a b -> [a,b])
23:08:06 <lambdabot> (. return) . (:)
23:08:23 <TSC> I'll stick with the pointy form, thanks anway lambdabot
23:08:36 <emu> @pl phb
23:08:37 <lambdabot> phb
23:08:49 <emu> oh no, the phb is a fixed point for pl
23:09:54 <dmead> lolcode is sweeping the internets
23:16:37 <dons> a guided tour of xmonad, http://xmonad.org/tour.html  :-) (with screenshots)
23:16:41 <lambdabot> Title: xmonad : a guided tour
23:16:43 <dons> for those who want to see how it works
23:17:16 <flux-_> dons, people want a javascript-implementation of that, to try it out, without the bother of actually running it!
23:17:28 <flux-_> fortunately that should be a piece of cake with that haskell-to-javascript-compiler, right?-)
23:17:28 <dons> heh
23:17:41 <dons> just need to translate Xlib to JS.
23:20:04 <jargonjustin> dons: some combination of the <canvas> element and SVG should make it _possible_â¦ ?
23:25:27 <dmead> ?time
23:25:27 <lambdabot> Local time for dmead is Thu May 31 00:52:38
23:25:36 <dmead> wtf
23:26:00 <sieni> ?time
23:26:03 <lambdabot> Local time for sieni is Wed May 30 09:24:29 2007
23:26:14 <dons> omg wtf hai!
23:26:17 <dons> kthxbye
23:26:41 <dmead> laffs
23:26:41 <timthelion> hmm, I'm on debian, and attempting to install xmonad.  when I configure, it has no greencard found as one of the things, could this be the cause of all the long stream of errors that follow?
23:26:59 <dons> timthelion: just warnings, most likely
23:27:01 <dmead> hmm
23:27:02 <timthelion> I tried installing greencard, but their binary server is down, and the source doesn't work
23:27:04 <dons> cabal warns about heaps of silly things
23:27:06 <dmead> in C++
23:27:09 <timthelion> Setup.hs: Error: Could not find module: Control.Monad.Error with any suffix: ["hi"]
23:27:12 <dons> timthelion: don't worry, they're not real dependencies
23:27:17 <dons> right. you need the 'mtl' package
23:27:21 <dmead> we have sleep(int miliseconds)
23:27:24 <dons> also, the 'unix' package, they're in debian
23:27:25 <timthelion> I get that hi one a lot
23:27:26 <dmead> what would that be in lolcode
23:27:37 <dmead> sleep(10
23:27:38 <dmead> )
23:27:44 <dmead> zzzzzzzzzzz(10)
23:27:44 <dmead> ?
23:28:17 <jql> well, in caps, of course
23:28:32 <timthelion> it would be nice if there was a nice normal install script for this wm :(
23:30:24 <dons> timthelion: well, cabal is normal round these parts.
23:30:35 <dons> ideally, you'd use your package system for the deps, though
23:31:00 <timthelion> dons: you can say that, but when I get to X11-extras, I get Setup.lhs: cannot satisfy dependency X11>=1.2 and it refuses to install. even though I (with errors) installed X11 from darcs
23:31:18 <dons> ok. did you register it?
23:31:28 <dons> $ ghc-pkg list X11
23:31:28 <dons> /home/dons/lib/ghc-6.6/package.conf:
23:31:28 <dons>     X11-1.1, X11-1.2
23:31:38 <dons> i.e. runhaskell Setup.lhs install ?
23:32:02 <dons> I think the X11  binding is in debian too
23:32:14 <timthelion> ya, that's what I did. but I got an error, Setup.hs: Error: Could not find module: Graphics.X11 with any suffix: ["hi"]
23:32:28 <timthelion> what would the package be called?
23:32:49 <dons> there are 2 packages, first install X11-1.2 from hackage
23:32:53 <dons> then X11-extras
23:32:56 <timthelion> ah, I see libghc6-x11-dev
23:33:00 <dons> yeah, that's it
23:33:04 <timthelion> let me try doing this through aptitude
23:33:18 <dons> for X11-extras, best to get it from the release candidates here:
23:33:19 <dons>   http://tinyurl.com/395gan
23:33:23 <lambdabot> Title: Gmane -- Mail To News And Back Again
23:33:59 <timthelion> ok we'll see how extras does now that I'm aptituding the others. it says on the web site that I need to do extras from darcs
23:34:09 <dons> so, mtl , unix and X11 should be in debian. you then grab X11-extras and xmonad from the above release candidate.
23:34:26 <dons> grab the RC from the above url. easier than darcs
23:35:40 <dons> Igloo: can we get the 6.6.1-tagged X11 library (1.2.1) onto hackage?
23:35:46 <dons> it got tagged at release time, but not uploaded.
23:37:10 <timthelion> Setup.lhs: cannot satisfy dependency X11-extras==0.0
23:37:22 <timthelion> Setup.lhs: Error: Could not find module: Graphics.X11.Xlib.Extras with any suffix: ["hi"]
23:37:38 <timthelion> those where the errors from xmonad and X11-extras respectivly
23:37:44 <dons> you're building xmonad from the release candidate?
23:37:52 <timthelion> darcs
23:38:21 <dons> ok. X11-extras hasn't been installed.
23:38:33 <timthelion> well it gave me that "hi" error
23:38:37 <dons> $ ghc-pkg list X11-extras
23:38:37 <dons> /home/dons/lib/ghc-6.6/package.conf:
23:38:37 <dons>     X11-extras-0.0, X11-extras-0.1
23:38:54 <dons> xmonad needs X11-extras, X11-extras needs X11.
23:39:02 <timthelion> it failed because Setup.lhs: Error: Could not find module: Graphics.X11.Xlib.Extras with any suffix: ["hi"]
23:39:03 <dons> you need all 3. so, you have X11 from debian?
23:39:20 <timthelion> yes, I have everything but X11-extras with gave me the error I just showed you
23:39:41 <dons> ok. you have to get X11-extras built. now that X11 is installed (check with ghc-pkg list X11)
23:39:52 <dons> try build X11-extras (assume you have the darcs version?)
23:40:23 <timthelion> zsh: command not found: build
23:40:33 <timthelion> sorry, I'm new to haskell packages
23:40:36 <dons> runhaskell Setup.lhs configure --prefix=/home/dons
23:40:40 <dons> runhaskell Setup.lhs build
23:40:49 <dons> runhaskell Setup.lhs install --user
23:41:04 <timthelion> same error
23:41:16 <dons> what's the output of ghc-pkg list X11 ?
23:41:34 <timthelion> ghc-pkg list X11
23:41:34 <timthelion> /usr/lib/ghc-6.6/package.conf:
23:41:34 <timthelion>     X11-1.2
23:41:34 <timthelion>  
23:41:44 <dons> ok. ghc version?
23:41:47 <dons> 6.6?
23:41:56 <timthelion> ghc --version
23:41:56 <timthelion> The Glorious Glasgow Haskell Compilation System, version 6.6
23:41:56 <timthelion>  
23:42:34 <dons> ah ha. i know :-)
23:42:43 <timthelion> what?
23:42:47 <dons> you are using the darcs version, and you didn't run 'autoreconf' first
23:42:54 <dons> not the release candidate
23:43:02 <dons> see the README for X11-extras
23:43:16 <timthelion> there is not README
23:43:23 <timthelion> *no
23:43:24 <dons> However, if you are building from darcs, X11-extras uses autoconf, so you need
23:43:24 <dons> to have autoconf installed and run autoconf/autoheader before building:
23:43:24 <dons>     autoconf
23:43:24 <dons>     autoheader
23:43:24 <dons> or
23:43:26 <dons>     autoreconf
23:43:44 <dons> do you really have X11-extras from darcs?
23:43:58 <dons> $ darcs get http://darcs.haskell.org/~sjanssen/X11-extras
23:44:00 <lambdabot> Title: Index of /~sjanssen/X11-extras
23:44:14 <dons> $ cd X11-extras
23:44:14 <dons> $ ls README
23:44:14 <dons> README
23:44:31 <timthelion> yes, I'm pretty sure. not the same line though, the one I did has --partial in it
23:44:46 <dons> $ darcs changes | head
23:44:46 <dons> Tue May 29 13:23:33 EST 2007  Don Stewart <dons@cse.unsw.edu.au>
23:44:46 <dons>   * update readme
23:44:47 <dons> ?
23:45:03 <timthelion> oooh
23:45:05 <timthelion> I see
23:45:47 <timthelion> dons, sorry about this, I tried doing this about two months ago, and it didn't work, and I still had X11-extras directory left over. so the darcs one wath X11-extras_0
23:45:55 <dons> ah right!
23:46:05 <dons> cd X11-extras_0 then :-)
23:47:31 <timthelion> .h?  is this in C?
23:48:17 <dons> it is a binding to C.
23:48:58 <timthelion> oh, I don't trust C, my dad tried to teach it to me when I was in 5th grade, and I've never been able to touch the language since :(
23:49:25 <dons> have to call Xlib somehow :-)
23:50:32 <timthelion> where is xmonad installed?
23:50:57 <dons> into bin in the path you specify
23:51:09 <dons> runhaskell Setup.lhs configure --prefix=/....
23:51:35 <timthelion> oh,
23:52:39 <dons> got it built?
23:52:49 <timthelion> I don't know
23:53:12 <timthelion> which xmonad doesn't say anything, so I was trying to figure out how to add it to .xinitrc without that output
23:53:25 <dons> rehash?
23:53:31 <dons> check is in your path
23:53:40 <dons> check it is in ..
23:54:05 <timthelion> ah,
23:54:12 <timthelion> /home/timothy/bin/xmonad
23:54:27 <timthelion> because I set the prefix to my own home dir
23:54:38 <timthelion> takeing off your example without thought
23:54:43 <timthelion> ;)
23:55:33 <timthelion> ok, I'll be back when I'm in.  is there some hotkey I should know to open a shell?
23:55:51 <therp> mod+return imho
23:56:03 <therp> have a look at Config.hs
23:56:06 <sjanssen> timthelion: mod-shift-return
23:56:18 <sjanssen> therp: not an opinion question, I think :)
23:56:33 <therp> s/imho/iirc/
23:56:43 <timthelion> where is said Config.hs?
23:58:58 <TSC> timthelion: in the xmonad directory
23:59:17 <timthelion> like where I build it?
23:59:37 <timthelion> do I have to rebuild to customize it?
