00:01:10 <LordBrain> great, so the base is the opposite of the bottom
00:01:33 <LordBrain> it must be upside down
00:02:01 <quicksilver> osfameron: good stuff :)
00:02:45 <quicksilver> osfameron: lazy expansion is a very good way to picture it
00:03:29 <nomeata> Hi. How can I signal between several forkIO threads with broadcast semantics?
00:03:33 <dons> http://www.cse.unsw.edu.au/~dons/tmp/monad-stack-arch.png
00:03:34 <dons> :-D
00:03:54 <dons> so although IO is the inner most, lexically (it is enclosed by Reader and State
00:04:01 <dons> from an application arch point of view, it is the outermost layer
00:04:10 <Vq^> dons: you drew it insideout! :o)
00:04:14 <quicksilver> nomeata: you have essentially two choices, exceptions and MVars
00:04:16 <dons> calls go from the pure core, through the other layers, before ending up as IO on the way out
00:04:19 <nomeata> It seems that for MVars, I need one per thread, and TChans contain too much „data“
00:04:44 <dons> this illustrates what we mean by imperative/monadic 'skin' too.
00:04:49 <nomeata> And the sending thread does not know which other threads are currently “interested” in the signal.
00:05:00 <dons> the thin layer of code in IO , that's the depature point from pure code, to the outside world
00:05:19 <nomeata> Maybe a IORef [MVar] where each interested thread puts a MVar himself?
00:05:44 <osfameron> quicksilver: not only a good way, afaics the only way.  It's completely batshit insane otherwise
00:05:51 <dons> nomeata: a broadcast Chan?
00:05:54 <nomeata> IORef [MVar ()] actually
00:06:09 <dons> all those emulate Chans, I think (?)
00:06:10 <osfameron> quicksilver: you start thinking "how does it know what value will make the recursion stop!" otherwise
00:06:15 <nomeata> dons: yes, but it should not keep the data if noone listens ATM
00:06:29 <nomeata> dons: it seems that TChans makes sure that each piece of data is actually read
00:06:29 <dons> -- |Duplicate a 'Chan': the duplicate channel begins empty, but data written to
00:06:30 <dons> -- either channel from then on will be available from both.  Hence this creates
00:06:30 <dons> -- a kind of broadcast channel, where data written by anyone is seen by
00:06:30 <dons> -- everyone else.
00:06:31 <dons> dupChan :: Chan a -> IO (Chan a)
00:06:35 <dons> nomeata: ah ok.
00:06:38 <dons> yes, TChans might be nicer
00:06:49 <dons> I think channels of some form are the way to go
00:06:52 <LordBrain> dons, that arch seems like something you could use in just about any program.... i suppose it might be overkill in some
00:07:03 <nomeata> dons: hmm. ok.
00:07:21 <dons> LordBrain: except that there's a typeful distinction between each layer
00:07:28 <dons> and the pure core is larger than a non-haskell app
00:07:35 <dons> the type system *enforces* the separation of layers
00:07:42 <dons> it enforces the architecture
00:07:51 <nomeata> Maybe some more information about what I’m programming. It’s similar to IMAP as it’s a server where some clients change state, and some clients subscribe to chnage notifications (think IMAP’s IDLE)
00:08:16 <nomeata> So I need a way to globally signal „state changed“, so that the threads for IDLEing clients can wake up and send the state.
00:08:28 <quicksilver> nomeata: the exception based approach might have a separate 'notification' thread
00:08:35 <LordBrain> dons, i'm not sure what you meant by "larger than a non-haskell app"
00:09:04 <dons> LordBrain: the part that is required to do no IO makes up a larger percent of haskell programs, usually, than you find in a language that allows unrestrained side effects
00:09:08 <quicksilver> nomeata: the 'sending  thread' sends the signal to the notification thread, which maintains the list of interested listners and passes it on
00:09:11 <LordBrain> of course i wasnt saying every program uses that architecture...
00:09:13 <dons> there's simply a bigger body of referentially transparent code
00:09:26 <dons> no, but I ttake your point about the architecture being common
00:09:36 <nomeata> quicksilver: I don’t really like the “list of interested listeners”....
00:09:39 <dons> its a good model, and nicely, one that can be specified in the type system
00:09:48 <quicksilver> osfameron: yes, right. It doesn't know when the recursion should stop. It just does, hopefully :)
00:09:50 <LordBrain> hmmm
00:09:52 <LordBrain> yeah
00:10:00 <nomeata> I’d like a TChan that does not keep n pieces of data, but just one (or none)
00:10:06 <nomeata> Or alternatively a dupMVar
00:10:24 <quicksilver> nomeata: at some level you have a list of listeners :) whether you like to admit you do or not
00:10:29 <nomeata> Maybe I’ll write a wrapper around TChan that keep’s reading until isEmptyTChan
00:10:41 <quicksilver> nomeata: you may keep it implicit somehow inside a library function, though
00:10:46 <nomeata> quicksilver: not if I have something that the listeners can just read from without telling it someone
00:10:51 <nomeata> (as dup’ed TChans)
00:11:12 <quicksilver> they 'told someone' when they duped the TChan
00:11:26 <quicksilver> but this is anthropomorphism and doesn't really matter :)P
00:11:27 <nomeata> ok, but that someone is hidden deeply enough :-)
00:11:40 <nomeata> And I don’t trust exceptions here
00:11:48 <nomeata> (maybe irrational, or out of inexperience :-))
00:11:53 <quicksilver> one of the questions is whether or not you need a guarantee about the messages being read
00:11:59 <quicksilver> before the next message comes along
00:12:12 <quicksilver> and whether-or-not it matters if one client is too busy to read at the moment
00:12:25 <nomeata> it does not matter
00:12:33 <nomeata> it must not matter, actually
00:12:45 <quicksilver> exceptions may not be wehat you want, because they can interrupt the target thread 'anywhere'. I don't think there's any call to not trust them, though :)
00:13:03 <nomeata> ok, but they are a tad too dangerous :-)
00:13:45 <LordBrain> i was thinking of reader as having an environment, i notice you associate it with read only
00:14:01 <LordBrain> but reader would allow temporary modifications...
00:14:06 <LordBrain> i thought
00:14:21 <LordBrain> if i recall right, unless i'm thinking of something else
00:14:25 <quicksilver> if it doesn't matter, then isn't it sufficient to have a single MVar and have the listeners using readMVar ?
00:14:47 <nomeata> quicksilver: wouldn’t just one of them get the data?
00:14:55 <quicksilver> not with readMVar, no
00:15:04 <quicksilver> with readMVar as many threads as want can get the data
00:15:21 <quicksilver> (read is a take followed immediately by a put, which puts the data back)
00:15:32 <nomeata> hmm. but then the MVar will never be empty, after it’s filled once.
00:15:37 <quicksilver> correct
00:15:40 <quicksilver> does that matter?
00:15:57 <quicksilver> it matters if threads can't "tell" on their own that they've read teh same thing twice
00:15:58 <nomeata> yes, because then the signal will be received again and again
00:16:02 * quicksilver nods
00:16:12 <quicksilver> unless they have some way of recognising it to be 'the same', then yes
00:16:14 <nomeata> I could put a timestamp or a counter in the MVar...
00:16:25 <quicksilver> but actually, part of the data in the MVar could be the MVar to use next
00:16:26 <nomeata> counter would be good
00:16:46 <quicksilver> MVar (MVar,String)
00:16:54 <nomeata> and each subscriber gets a pair of the MVar and an IORef for his last counter
00:16:57 <quicksilver> you read (a) your signal data and (b) the mvar to use next time
00:17:24 <nomeata> (the signal has no data, actually)
00:17:37 <nomeata> so MVar MVar (looks funny)
00:17:44 <quicksilver> then it could just be MVar Mvar, yes
00:17:54 <nomeata> but then I need an IORef that has the next MVar to use.
00:18:01 <nomeata> Or just another MVar MVar...
00:18:13 <appletizer> whats the difference between a generalisation under theta-subsumption and a generalisation under logical implication?
00:18:14 <quicksilver> don't think you need an IORef...
00:18:22 <appletizer> so far i understand that a generalisation under logical implication can be reduced to that under theta-subsumption... but i don't understand how to go about it
00:18:32 <appletizer> eg s(f(f(X))):-s(f(X)).
00:18:39 <appletizer> s(f(f(X))):-s(X).
00:18:44 <nomeata> so I have two MVars, one is nextMVar, one is currentMVar, and both contains MVar which are used only once
00:18:45 <appletizer> s(f(X)):-s(X).
00:18:51 <appletizer> in the three clauses above, the third generalises to first under theta subsumption
00:18:52 <nomeata> first in nextMVar, then in currentMVar.
00:18:57 <appletizer> and the third generalises to first two under logical implication
00:18:57 <quicksilver> nomeata: hmm of course actually it's MVar Mvar Mvar Mvar MVar Mvar ....
00:19:06 <appletizer> i get the theta subsumption bit, but not the logical implication
00:19:12 <nomeata> quicksilver: hmm. occur check :-)
00:19:16 <quicksilver> nomeata: so you need a data declaeration :)
00:19:33 <LordBrain> i know nothing of theta subsumption
00:19:37 <nomeata> quicksilver: maybe I just roll my own based on the TChan implementation
00:19:38 <quicksilver> data MyMVar = MVar MyMVar
00:20:37 <LordBrain> what's a good introduction?
00:20:59 <stepcut> quicksilver: yampa has some 'switching' mechanisms for changing the arrow network at run time. But it is pretty limited. In theory, you might be able to abuse that to create a new network from scratch at runtime -- but that would not be very practical
00:21:11 <nomeata> MVar is in Eq. So maybe an IORef [MVar ()] is not too bad after all
00:21:15 <quicksilver> nomeata: you must use whatever you find most comprehensible
00:21:25 <quicksilver> nomeata: but I think just a single MVar is the simplest
00:21:38 <quicksilver> stepcut: hmm
00:21:46 <LordBrain> what are you trying to do nomeata?
00:21:56 <stepcut> quicksilver: switching says, replace this element with this other element. But the 'other element' is still something you 'hardcode' into the program at compile time
00:21:59 <Korollary> LordBrain: Did you randomly picked that concept?
00:22:05 <nomeata> LordBrain: implement broadcast signaling between threads
00:22:05 <quicksilver> stepcut: but what I don't understandm, really, is that haskell can always build up things at runtime
00:22:12 <quicksilver> LordBrain: 'observer pattern'
00:22:27 <LordBrain> Korollary, haha, i grabbed it from appletizer
00:22:31 <quicksilver> stepcut: I can write f a b c  = a >>> b >>> c
00:22:33 <nomeata> LordBrain: with sevaral listeners, no data carried, and no action if someone is not listeing to the signal
00:22:39 <quicksilver> stepcut: or whatever
00:22:52 <nomeata> But I have to go, thanks for the hints everyone!
00:22:58 <quicksilver> stepcut: and then use 'f' to build up arrow shapes based on what I read from my XML file
00:23:14 <Cheery> quicksilver: I think I've started to detest arrows
00:23:30 <quicksilver> stepcut: or is it something more subtle to do with runtime-typing?
00:23:36 <quicksilver> Cheery: I've never used them in anger
00:24:23 <Cheery> well, in AFRP, they were horrible, sure I may like them if I'll someday find them a place where they actually makes something more clear
00:28:16 <LordBrain> well... you could have have a spider like network, where one thread acts as a dispatcher for each of the other threads, so for n communicative threads, you have at least n-1 mvars corresponding to the legs of the spider...
00:28:45 <stepcut> quicksilver: hrm, perhaps reading from an xml file is not the best example after all, because that might actually be a bit feasible
00:28:47 <LordBrain> i'm just brainstorming here
00:29:38 <stepcut> quicksilver: but, if you want to edit the GUI after it is loaded, I think it gets a bit trickier
00:30:05 <LordBrain> that way, between any two threads there's at most 2 hops so to speak
00:30:06 <stepcut> quicksilver: because nothing has any names, just 'positions' in the graph
00:31:03 <LordBrain> oh he left before my idea
00:31:08 <LordBrain> blast him
00:31:11 <LordBrain> or her
00:31:13 <LordBrain> haha
00:31:37 * Lemmih just received his new furniture. Yay!
00:31:49 <LordBrain> no data carried.. not sure what he means there
00:32:37 <LordBrain> maybe he wants 1 hop, then you'd need a complete graph, 2^n mvars... perhaps double so you could have ins and outs
00:33:03 <stepcut> quicksilver: I have not quite figured out what the problem is yet. It turns out that explain why arrows *aren't* the right solution is pretty hard :)
00:33:28 <dons> > maxBound :: Word8
00:33:29 <lambdabot>  255
00:33:31 <dons> > maxBound :: Word16
00:33:32 <lambdabot>  65535
00:33:55 <dons> > 0 `rem` 256 :: Word8
00:33:57 <lambdabot>  Exception: divide by zero
00:34:00 <dons> > 0 `rem` 256 :: Word16
00:34:01 <lambdabot>  0
00:34:10 <dons> > 256 :: Word16
00:34:12 <lambdabot>  256
00:34:13 <dons> > 256 :: Word8
00:34:15 <lambdabot>  0
00:34:22 <dons> > 0 `rem` 0 :: Word8
00:34:24 <lambdabot>  Exception: divide by zero
00:34:56 * stepcut goes to bed
00:42:21 <TSC> dons: Ahh, I was trying to work that out
00:42:54 <dons> hehe. i'm exhausted! its funny how the brain works
00:42:57 <dons> osfameron: around?
00:43:09 <dons> osfameron: your blog article about 'join' is 'intercalate' I believe.
00:43:22 <dons> osfameron:
00:43:24 <dons> intercalate :: [a] -> [[a]] -> [a]
00:43:24 <dons> intercalate xs xss = concat (intersperse xs xss)
00:43:27 <osfameron> dons: ah!  nice and easy, trips off the tongue :-)
00:43:31 <dons> i.e. concat . intersperse
00:43:35 <osfameron> ah, intersperse.  cute
00:43:39 <dons> yeah, very haskellish, eh? ;-)
00:43:55 <dons> only the haskell community would name the join function 'intercalate'
00:44:00 <dons> but of coufse, join was already taken:
00:44:01 <dons> :t join
00:44:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:44:11 <dons> :t Control.Monad.join
00:44:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:44:21 <osfameron> heh.  At least they didn't call head car and tail cdr
00:44:21 <dons> i.e. your join, but for monads, (duh!) :-)
00:44:23 <LordBrain> :t intercalate
00:44:26 <lambdabot> Not in scope: `intercalate'
00:44:26 <osfameron> aha!
00:44:42 <osfameron> also, in a strongly typed language, the type of join is problematic
00:44:55 <dons> which 'join'?
00:44:55 <LordBrain> why? is intersperse from lisp?
00:45:02 <osfameron> to me it would make sense to be able to:    join thing [thing]  and also join [thing] [thing]
00:45:18 <dons> you'd overload join then. but that' a bit perlish.
00:45:19 <osfameron> my version was specialised for strings, like the Perl one, so it's [thing] [[thing]]
00:45:26 <dons> the first one is a special case of the latter, isn't it?
00:45:42 <dons> join1 :: a -> [a] -> [a]
00:45:48 <dons> and join2 :: [a] -> [a] -> [a]
00:45:56 <dons> join1 x = join2 [x]
00:46:21 <dons> > join ["x","y","z"]
00:46:22 <lambdabot>  "xyz"
00:46:23 <Jaak> > join [[1, 2], [3]]
00:46:24 <lambdabot>  [1,2,3]
00:46:40 <dons> :t join (return getChar)
00:46:42 <lambdabot> IO Char
00:46:46 <Jaak> > join (Just (Just 1))
00:46:47 <lambdabot>  Just 1
00:47:29 <dons> :t intersperse
00:47:31 <lambdabot> forall a. a -> [a] -> [a]
00:47:51 <dons> so yeah, to answer your question, the standard way is to:   concat . intersperse
00:48:02 <dons> which is known as 'intercalate' in ghc head
00:48:15 <dons> ?web1918 intercalate
00:48:16 <lambdabot> *** "Intercalate" web1913 "Webster's Revised Unabridged Dictionary (1913)"
00:48:16 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
00:48:16 <lambdabot>    {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
00:48:16 <lambdabot>    intercalatus, p. p. of intercalare to intercalate to
00:48:16 <lambdabot>    intercalate; inter between + calare to call, proclaim. See
00:48:19 <lambdabot> [10 @more lines]
00:48:22 <dons> @more
00:48:23 <lambdabot>    {Calendar}.]
00:48:23 <lambdabot>    1. (Chron.) To insert, as a day or other portion of time, in
00:48:24 <lambdabot>       a calendar.
00:48:26 <lambdabot>  
00:48:29 <lambdabot>    2. To insert among others, as a verse in a stanza; specif.
00:48:30 <lambdabot> [5 @more lines]
00:48:33 <dons> that's it.
00:48:34 <dons> @more
00:48:34 <lambdabot>       (Geol.), to introduce as a bed or stratum, between the
00:48:34 <lambdabot>       layers of a regular series of rocks.
00:48:36 <lambdabot>  
00:48:38 <lambdabot>             Beds of fresh-water shells . . . are intercalated
00:48:40 <lambdabot>             and interstratified with the shale.   --Mantell.
00:49:03 <dons> osfameron: fwiw, 'intercalate' is a bit literary, maybe it is perlish after all :-)
00:49:22 <slava> i just call that 'join' :)
00:49:48 <dons> no no, join is obviously the monad primitive ;-)
00:49:56 <slava> :)
00:50:07 <dons> osfameron: oh also, your version of 'join' for strings, is pretty spot on:
00:50:16 <dons> :t \j -> foldr (\left right -> left ++ j ++ right) []
00:50:19 <lambdabot> forall a. [a] -> [[a]] -> [a]
00:50:21 <dons> :src foldr
00:50:33 <dons> ?src concatMap
00:50:33 <lambdabot> concatMap f = foldr ((++) . f) []
00:50:47 <dons> ?src intersperse
00:50:47 <lambdabot> intersperse _   []     = []
00:50:48 <lambdabot> intersperse _   [x]    = [x]
00:50:48 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
00:51:10 <osfameron> yeah, that was pretty much my definition of join, except with ++ instead of :
00:51:13 <dons> so you wrote your own concatMap first off, then your own itnersperse, I think
00:51:30 <osfameron> roight, I missed an opportunity to be more higher order
00:51:55 <osfameron> I'm still having trouble getting my head around the duality of string as an atomic thing, and string as [Char]
00:52:02 <profmakx> on a side note: Happy Towel Day, everyone *relurk*
00:52:18 <scodil> so, i've got some transformation matrices for 3d graphics, and I'm storing them as unboxed arrays, but multiplying them is proving to be a bottleneck. what options to I have to speed them up, besides unsafeAt and other non-standard stuff? Or are unboxed arrays already nonstandard?
00:52:21 <dons> osfameron: yeah, [Char], where [a] is polymorphic, changes things a fair bit
00:52:34 <dons> scodil: unboxed arrays of what type?
00:52:38 <scodil> double
00:52:41 <scodil> or float
00:52:51 <dons> ok. there's some things to know about Double, let me find the code
00:53:14 <dons> i'd start by adding:
00:53:15 <dons> {-# OPTIONS -O2 -fglasgow-exts -fbang-patterns -fexcess-precision -optc-O -optc-march=pentium4 -optc-mfpmath=sse -optc-msse2 #-}
00:53:32 <dons> note, sse, and the critical -fexcess-precision
00:53:51 <dons> due to a ghc wibble, -fexcess-precision needs to be specified as a pragma
00:53:56 <dons> at the top of your src file
00:54:07 <LordBrain> what's it do?
00:54:11 <scodil> ok i'll try that, but I really don't think its compute bound...
00:54:12 <osfameron> annoyingly, Perl doesn't have intersperse, only the join primitive.  So to join things other than strings, the easiest thing to do is to map { $thing, $sep } and finally chop the last element off (which is fine, but a bit ugly).
00:54:31 <dons> scodil: it usually makes a 2x speedup (-fexcess-precisoin) to mutable Double code
00:54:49 <scodil> its not mutable code... is that my problem?
00:54:57 <LordBrain> maybe perl6 will have more higher order functions
00:55:07 <dons> well, start with the above flags
00:55:12 <scodil> ?paste
00:55:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:55:12 <dons> then we can look again at the code
00:55:19 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/35
00:55:28 <scodil> thats me
00:55:37 <dons> double code is a known bottleneck though
00:55:48 <dons> its possible to get to hmmm 3-4x C at best, imo.
00:56:00 <dons> oh, very abstract code
00:56:15 <dons> with checked indexing
00:56:20 <scodil> ?
00:56:24 <dons> you already check the bounds, so use unsafeAt
00:56:28 <dons> unsafeRead et al
00:56:40 <dons> they're not unboxed arrays, are they?
00:56:51 <scodil> they are unboxed
00:57:13 <dons> this looks too high level , sum' i j = sum $ map (\k -> m1!(i,k) *  m2!(k,j)) [i1..m]
00:57:20 <dons> sum won't even fuse (its a left fold)
00:57:39 <scodil> nobody tells me these things
00:57:48 <dons> oh, they're unboxed 2d arrays?
00:57:54 <scodil> yeah, matrices
00:57:58 <LordBrain> you just making a utils, or are you doing something with the matrix code?
00:58:10 <dons> hmm, so no unchecked indexing.
00:58:12 <scodil> i could write it for 1d arrays, if that makes a difference
00:58:37 <dons> scodil: is it possible to paste a compilable module, with a sample input/output that runs too slow?
00:58:42 <dons> i can have a look if you like.
00:59:02 <dons> in general, explicit unchecked indexing, and strict loops, seems to produce better array code.
00:59:19 <dons> and for all out speed, Ptr Double is fastest
00:59:34 <scodil> jeez i may as well call out to C
01:00:00 <dons> i'm confused though, you said "multiplying them is proving to be a bottleneck"
01:00:04 <dons>  but also that it isn't compute bound?
01:00:08 <dons> are they very large or something?
01:00:22 <dons> ah i see, it will be the access actually
01:00:35 <scodil> that function I pasted eats a lot of time and alloc in profiling
01:00:45 <dons> things like ! , and the non-fused loop, sum . map, won't be ideal
01:00:51 <LordBrain> heh, use your opengl hardware
01:00:56 <LordBrain> :)
01:01:05 <dibblego> ?hoogle Ord a => [a] -> Bool
01:01:05 <lambdabot> Prelude.null :: [a] -> Bool
01:01:05 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
01:01:05 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
01:01:13 <osfameron> LordBrain: yeah, Perl6 definitely will :-)
01:01:16 <dons> here's an example of limit-optimised Double /array code
01:01:20 <dons> scodil: http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=ghc&id=4
01:01:22 <lambdabot> Title: spectral-norm Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 ..., http://tinyurl.com/2e7msp
01:01:28 <dons> it uses Ptr Double, and strict loops
01:01:32 <dibblego> in the QC paper, there is a reference to a function called 'ordered', but I can't find the thing!
01:01:48 <dons> things like:
01:01:49 <dons>     go !i = when (i < n) $ do
01:01:49 <dons>         pokeElemOff au i (avsum i 0 0)
01:01:49 <dons>         go (i+1)
01:01:55 <dons> compile to very good code in GHC.
01:02:03 <dons> but yes, you're writing in C, essentially
01:02:19 <dons> to do high level, and fast, arrays, you might possible look at the data parallel array work
01:02:27 <dons> but that mightn't be practical
01:02:49 <dons> dibblego: doesn't appear to be in QC1.
01:02:54 <scodil> these are small arrays. 3x2, 3x3, 3x4, 4x4 only
01:03:15 <dibblego> dons, it is first referenced in section 2.3 of http://www.md.chalmers.se/~koen/Papers/quick.ps
01:03:25 <dibblego> ?type (==>)
01:03:26 <dons> dibblego: in QC2, there's, Arbitrary.hs:newtype OrderedList a = Ordered [a]
01:03:28 <lambdabot> forall a. (Testable a) => Bool -> a -> Property
01:03:35 <dons> scodil: oh. ok! hmm. that changes things a lot
01:03:35 <scodil> 2d and 3d projective and affine transformations. If need be I can write separate multiply and invert functions for each, but its nice to use one for all of em
01:03:42 <Cheery> @go prolog implementation in haskell
01:03:44 <lambdabot> http://lambda-the-ultimate.org/classic/message3941.html
01:03:44 <lambdabot> Title: LtU Classic Archives
01:04:03 <dons> scodil: can you paste a compilable module containing all code necessary to run a smal benchmark that takes too long?
01:04:10 <dons> if you do, i'll have a go at optimising it
01:04:19 <dibblego> dons, I'll just assume it is of type Ord a => [a] -> Bool
01:04:21 <scodil> Its kinda big
01:04:26 <scodil> 5 or 6 files
01:04:39 <dons> dibblego: oh, ordered x = x == sort x -- ?
01:04:56 <dibblego> ordered xs ==> ordered (insert x xs)
01:05:11 <dons> scodil: ok. well, i'd write your sum $ map loop as a manual, strict tail-recursion first
01:05:19 <dons> scodil: i'd use the flags i pasted above.
01:05:20 <dibblego> now I know the type of ==>, my assumption is reasonable
01:05:26 <dibblego> (I was reading in bed without ghci)
01:05:31 <dons> and think about how to index using unchecked reads, (1d array)
01:05:37 <dons> if that's not fast enough, i'd use Ptr Double
01:05:45 <dons> and that's pretty much it.
01:06:36 <scodil> so, if the arrays are fixed size, and i'm using unsafeAt anway, does it make sense to use the GHC byte vector (or whatever its called) type? the thing arrays are built on?
01:06:54 <dons> nah, should be optimised, given appropriate strictness and -O2
01:07:09 <dons> likely your allocs are due to the intermediate lists in the map $ sum code
01:07:25 <dons> work on that, and add {-# SCC "foo" #-} pragmas to expression, to narrow down the bad code
01:07:43 <scodil> but that would save a handful of words on the bounds, right? because all arrays of a given type are of the same size
01:08:40 <scodil> encoding that size into the type is not simple (I can't follow that oleg stuff.) In c++ its a no brainer, but since I only have 4 concrete instances of my abstract matrix type, its not that much extra work to "instantiate the templates" by hand
01:08:55 <dons> yeah, you could put it in the type
01:09:08 <dons> if your indices are small
01:09:18 <scodil> 2 3 and 4 only
01:09:25 <quicksilver> you can do something quite equivalent to the C++ template trick
01:09:28 <dons> still, get rid of the use of ! (checked read)
01:09:32 <quicksilver> write the 4 instances by hand
01:09:32 <dons> and the sum $ map
01:09:37 <quicksilver> and make them all membvers of a typeclass
01:09:43 <dons> data D0 = D0
01:09:46 <dons> data D1 = D1 ...
01:10:06 <scodil> quicksilver: yeah thats a good idea
01:10:07 <dibblego> does anyone know if the ubuntu-feisty ghc package comes with those additional GHC extensions (I can't find Test.QuickCheck at least)?
01:10:47 <dons> dibblego: hmm. no. but you can get QC2,http://www.cs.chalmers.se/~bringert/darcs/QuickCheck
01:10:49 <LordBrain> at home i have a ghc on ubuntu with quickcheck i believe
01:10:50 <lambdabot> Title: Index of /QuickCheck
01:10:54 <LordBrain> and i used a  package
01:10:57 <LordBrain> i think
01:10:57 <dibblego> dons, ah thanks
01:10:58 <LordBrain> i mean
01:10:59 <dons> neither QC1 nor 2 follow the paper precisely
01:11:03 <LordBrain> it came with my ghc
01:11:14 <dons> QC1 is on hackage, of course.
01:11:52 <scodil> so, the GHC internal datatypes (Int# and whatnot) are just as non-standard and stable as unboxed arrays, right? I don't lose any portability if I work with raw byte vectors, since its GHC only... right?
01:13:36 <dons> they're non-standard, and stable (only 15 years old :-)
01:13:52 <dons> but there's no reason to use them, since unboxed arrays are light sugar on top anyway
01:13:59 <dons> just ensure your loops are strict
01:14:04 <dons> in the array argument
01:14:07 <scodil> but they carry bounds
01:14:16 <dons> they do, but there's unchecked access
01:14:25 <LordBrain> wow, 15 years...
01:14:25 <dons> ?hoogle unsafeRead
01:14:26 <lambdabot> No matches found
01:14:34 <dons> :t Data.Array.Base.unsafeRead
01:14:37 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *). (Data.Array.Base.MArray a e m, Ix i) => a i e -> Int -> m e
01:14:45 <dons> Int indicies only though.
01:14:57 <dons> but that's just a read# primop
01:15:05 <scodil> right... but hypothetically speaking, I could save those few bytes by using the internal GHC array type, and not lose any portability or risk breakage on a GHC update
01:15:19 <dons> well, you'd be more portable using Foreign.Array
01:15:30 <dons> since that'll work in hugs, nhc, and is standardised
01:15:34 <dons> and compiles to the same code
01:16:00 <scodil> don't foreign calls interact with threads somehow?
01:16:08 <dons> no no, they're not foreign calls
01:16:08 <scodil> they block all threads or something
01:16:13 <scodil> oh
01:16:15 <dons> its just an api into raw memory
01:16:27 <dons> that memory can be used to pass or fill from foreign code
01:16:29 <dons> or haskell code
01:16:31 <scodil> right ok. and I just put unsafePerformIO infront of everything
01:16:35 <dons> its the same raw-memory api bytestring is built on
01:16:40 <dons> if you want it to be pure, yep.
01:16:54 <dons> if you know statically the arrays are immutable
01:17:12 <dons> it'd be safe to have:   read = inlinePerformIO . unsafeRead
01:17:13 <scodil> yeah maybe I'll do that... will make passing to opengl easier and more efficient
01:17:17 <bringert> dons: QC2 has moved to http://darcs.haskell.org/QuickCheck/
01:17:18 <lambdabot> Title: Index of /QuickCheck
01:17:28 <dons> ?where+ QC2 http://darcs.haskell.org/QuickCheck/
01:17:28 <lambdabot> Done.
01:17:40 <LordBrain> you making a game?
01:17:51 <dons> scodil: fwiw, here's an example of the kind of low level uarray code i'm talking about, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=ghc&id=4
01:17:53 <lambdabot> Title: nsieve-bits Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 C ..., http://tinyurl.com/2fjnzl
01:18:03 <dons> the next step lower is to use Ptr
01:18:03 <scodil> oh this is no game
01:18:54 <LordBrain> what is it?
01:18:59 <LordBrain> renderer?
01:20:04 <scodil> hah no I do lots of different 3d stuff and I'm trying to make a simple, flexible library for 2d and 3d points, vectors and transformations with floats and doubles
01:20:20 <scodil> so that covers games and renderers, yes
01:20:44 <dons> for speed, and for a library, i'd build a wrapper over Ptr Double
01:20:56 <dons> kind of like Data.ByteString is a Ptr Word8, at the bottom
01:20:58 <scodil> yeah I think that's what I'll do
01:21:41 <dibblego> ?type collect
01:21:43 <lambdabot> forall a b. (Testable b, Show a) => a -> b -> Property
01:22:00 <dibblego> msg lambdabot ?src Testable
01:23:02 <LordBrain> sounds cool
01:24:51 <dibblego> ?type choose
01:24:53 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
01:24:58 <dibblego> > choose (7, 7)
01:24:58 <lambdabot>   Not in scope: `choose'
01:25:01 <dibblego> wtf?
01:25:44 <hpaste>  quicksilver pasted "'Observer Pattern' using one MVar" at http://hpaste.org/36
01:25:58 <scodil> are functional dependencies around to stay? or is there something else (dependent types?) that may replace them?
01:26:31 <DRMacIver> I think they're in as a fairly likely candidate for Haskell'.
01:26:39 <dons> hmm. FDs potentially could go, in favour of ATs
01:26:49 <dons> but in practice, unlikely in the short-to-medium temr
01:26:52 <scodil> ATs?
01:26:57 <quicksilver> @tell nomeata Wrote an exampel of the simple MVar approach I was talking about, it's on http://hpaste.org/36. I don't think you can get much 'simpler' than that.
01:26:57 <lambdabot> Consider it noted.
01:27:08 <dons> associated types, some argue, are a simpler, more haskell, way to program on the type level
01:27:19 <scodil> are they implemented?
01:27:32 <dons> while FDs are more like logic programming on the type level, ATs et al, give us functional programming on the type level. that's the cuteness arugment
01:27:35 <dons> yeah, in ghc head.
01:27:50 <dons> for real code, use FDs, if you need them, sparingly
01:27:59 <dons> ATs are only in unreleased ghc currently
01:28:31 <scodil> yeah I use FDs now, to specify that, say, a Point3 Double minus a Point3 Double returns a Vector3 Double
01:28:48 <scodil> but it gets cumbersome when you add in all the different types of transformations
01:29:01 <scodil> I was wondering if there was an easier way... more like C++ templates
01:29:15 <quicksilver> but the ATs in GHC HEAD are not yet powerful enough to replace FDs as I understand it
01:30:21 <dons> yes, associated somethings (one of the type forms) are still missing , iirc
01:30:29 <quicksilver> type synonyms
01:30:42 <quicksilver> Hmm adrian hey was a bit spiky in that email to dmhouse. Uncalled for IMO.
01:30:44 <dons> ah yes, they're a bit harder.
01:31:18 <dons> quicksilver: hmm, the one that ends in 'malloc' ?
01:31:36 <quicksilver> dons: yes
01:31:57 <dons> yeah a bit spikey.
01:32:22 <dons> i'm not sure how his ACIO stuff would be adopted, without a paper on the semantics, and sitting down with Simon et al.
01:32:32 <quicksilver> mind you I'm a bit spiky sometimes ;)
01:32:44 <dons> meaning, no one can really decide either way, till we've a paper to read on it.
01:33:00 <quicksilver> dons: I haven't written enough (any) low level library code to really have my head around the existance of the problem
01:33:03 <dons> morning swiert
01:33:10 <quicksilver> dons: I've simpler never needed to use the unsafePerformIO hack
01:33:18 <quicksilver> dons: and every time I've considered it, there's been a better way..
01:33:23 <dons> i've had hmm, 2 cases i can think of in hmm 4 years, where it was necessary
01:33:33 <dons> which implies its not crucial, I suppose.
01:33:42 <dons> the one case that does come to mind is the Random seed in System.Random
01:34:01 <dons> -- |Gets the global random number generator.
01:34:01 <dons> getStdGen :: IO StdGen
01:34:01 <dons> getStdGen  = readIORef theStdGen
01:34:01 <dons> theStdGen :: IORef StdGen
01:34:01 <dons> theStdGen  = unsafePerformIO $ do
01:34:03 <dons>    rng <- mkStdRNG 0
01:34:05 <dons>    newIORef rng
01:34:21 <dons> setStdGen :: StdGen -> IO ()
01:34:21 <dons> setStdGen sgen = writeIORef theStdGen sgen
01:34:29 <dons> a true mutable bit of state, secreted in the base lib.
01:34:34 * quicksilver nods
01:34:47 <dons> using the ill-defined unsafePerformIO/global semantics
01:35:02 <dons> so hmm. it should be clarified how is supposed to work.
01:36:30 <quicksilver> I think it should be clarified exactly what is needed
01:36:48 <quicksilver> is it just newIORef? interestingly not, in that example
01:37:32 <quicksilver> there are two intermingled things happening, IMO: (1) IO action implicitly executed at startup
01:37:42 <quicksilver> (2) result of that action captured *lexically* into a module
01:38:06 <quicksilver> (2) is a little bit too much like dynamic scoping and implicit parameters, for me to feel quite happy about it
01:38:22 <swiert> hi dons.
01:40:16 <dons> quicksilver: yeah, its weird/scary.
01:40:57 <quicksilver> dons: it's like the module is abstracted at the top level
01:41:07 <quicksilver> dons: the module is really \theStdGen -> Module
01:41:15 <dons> there's some similar things in the GHC.Conc module
01:41:25 <quicksilver> dons: and the sensible question that raises is, can we instantiate a module more than once?
01:41:33 <dons> yeah. currently, no.
01:41:35 <LordBrain> like a parameterizable module?
01:41:37 <quicksilver> dons: can we decided never to instantiate it after all (even though we imported it)
01:41:43 <dons> but then, imports shouldn't have side effects. urk
01:41:55 <quicksilver> dons: If A uses B, and B uses C, but if A uses D which uses E which uses C as well
01:41:56 <dons> maybe we can help Adrian a bit by pointing to this System.Random wart
01:42:02 <quicksilver> dons: are they 'the same copy' of C?
01:42:05 <dons> and using that to help make discussion a bit mor econcrete.
01:42:08 <quicksilver> dons: or are they 'different copies' of C
01:42:28 <dons> hmm
01:42:35 <quicksilver> At teh moment, they're the same copy of C
01:42:39 <quicksilver> but is that sensible?
01:42:42 <quicksilver> what about a haskell app-server?
01:42:49 <quicksilver> running lots of haskell 'mini-apps'
01:42:55 <quicksilver> should its modules share state? is that sane?
01:43:00 <dons> oh hmm. there's an exception in ghc's impl, btw.
01:43:12 <dons> symbols aren't shared between statically linked code, and dynamic code, in ghci
01:43:18 <quicksilver> can I write a server which forks lots of 'mains' form other modules and epxpect it to work sensibly?
01:43:35 <quicksilver> (currently, no; for example if they call setStdGen they'll interfere with each other)
01:43:37 <dons> so you could get two copies of the module instantiated
01:43:46 <quicksilver> (that's a pretty subtle kind of interference, but it is interference)
01:44:02 <quicksilver> dons: interesting
01:44:39 <dons> so depending on whether the code is purely interpreted, or calls into compiled .o files (e.g. via libraries)
01:44:46 * quicksilver nods
01:44:52 <dons> you'll get A.ioref, or A'.ioref
01:44:57 <quicksilver> there might even be two StdGens?
01:45:03 <quicksilver> what about the conc stuff?
01:45:11 <quicksilver> sounds like two copies of the thread state could really mess things up
01:45:12 <quicksilver> intuitively
01:45:14 <Trollinator> how can i tell ghci to stop doing something?
01:45:20 <quicksilver> Trollinator: Ctrl-C
01:45:22 <dons> ^C
01:45:38 <Trollinator> that doesn't work inside emacs...
01:45:43 * dons imagines Trollinator's screen filling with incrementing numbers
01:45:47 <LordBrain> lol
01:45:56 <quicksilver> Trollinator: C-c C-c
01:46:03 <Trollinator> dons: no, i'm only calculating ackermann(4,2)
01:46:09 <quicksilver> Trollinator: (if you're in emacs it would have helped to mention that first :P)
01:46:11 <dons> ah he. you can wait ;)
01:46:16 <Trollinator> thx, quicksilver
01:46:39 <quicksilver> dons: I wonder if the 'sane' thing isn't to instantiate such modules quite explicitly in main
01:46:53 <quicksilver> dons: initConc >> initRandom >> (...)
01:50:42 <DRMacIver> Hm. How would you statically guarantee that you initialise all the modules you need?
01:55:32 <dcoutts> @seen osfameron
01:55:32 <lambdabot> I saw osfameron leaving #haskell-blah and #haskell 27m 19s ago, and .
01:56:01 <quicksilver> DRMacIver: you'd know which modules you used
01:56:16 <quicksilver> DRMacIver: if they used other modules maybe htey'd initialise them in their init functions
01:56:26 <quicksilver> DRMacIver: this does bring us back to the 'initialise twice' problem
01:56:34 <quicksilver> DRMacIver: but my hope is that not many modules need this, anyway
01:56:54 <dcoutts> @tell osfameron I would have left this comment on your blog but apparently VOX wants me to become a member(!!??). To answer your question, join sep xs = concat (intersperse sep xs), this also goes by the name Data.List.intercalate
01:56:54 <lambdabot> Consider it noted.
01:56:56 <DRMacIver> That's not my question. How do you guarantee at compile time that you didn't import the module, forget to initialise and then use it anyway?
02:00:37 <quicksilver> DRMacIver: that is indeed a pertinent point
02:01:03 <quicksilver> DRMacIver: the only way you can guarantee it is to force you to pass a 'token' to each function you call from the library
02:01:31 <quicksilver> DRMacIver: rs <- initRandom ; ..... (later, elsewhere) ... getRandom rs
02:01:50 <quicksilver> DRMacIver: that may end up being cumbersome; althouhg you can abstract out the mess to some extent
02:05:56 <ivanm> !paste
02:05:57 <hpaste> Haskell paste bin: http://hpaste.org/
02:06:02 <ivanm> @paste
02:06:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:09:03 <dons> mwhaha, http://www.forbes.com/feeds/ap/2007/05/23/ap3753019.html
02:09:04 <lambdabot> Title: HASH(0x8d08b44) - Forbes.com
02:09:09 <dons> and that is why we like static typing.
02:11:45 <jql> I was heartened to know that forbes.com still runs on a 32-bit machine, at least
02:13:19 <dons> hehe
02:13:45 <hpaste>  ivanm pasted "Removing elements from a matrix" at http://hpaste.org/37
02:16:22 <ejt> ivanm: that's exactly how I envisaged doing it from your description :)
02:16:33 <ivanm> ejt: heh
02:17:04 <ivanm> One thing I don't like about it is how it keeps looking through a list of indices to check if that element should become 0
02:17:35 <ivanm> what I'd like to try and do is to remove that index from the list once its been used
02:17:42 <ivanm> or some kind of ordering
02:17:47 <ivanm> maybe a replacement of elem
02:19:29 <ejt> so combinations is allowing duplicates ?
02:20:56 <ejt> oh, no I see what you mean
02:23:32 <ivanm> originally, I was just removing one element at a time, which was pretty easy..
02:24:05 <ivanm> recurse through the matrix, each time I reach a non-zero element I'd either unset it or create a new list where I didn't unset it
02:24:07 <ejt> I think it's just unsetVals that needs re-writing.  Give me 10 minutes to get this running
02:24:16 <ivanm> *nod* thanks ejt
02:24:30 <ejt> BTW, what is an 'unset value' ?
02:24:40 <ejt> would you be better using a matrix of Maybe s ?
02:25:18 <ivanm> ejt: I'm trying that out at the moment
02:25:22 <DRMacIver> quicksilver: Yeah, something like that would work. It seems unsatisfactory though.
02:25:25 <ivanm> just have to profile it to compare performance
02:25:47 <ivanm> since I re-wrote it to use maybes, but then it looked like it was at least 3* the runtime :s
02:26:02 <ivanm> but it ended up being something to do with dodgy library linking or something
02:26:07 <ejt> that doesn't sound right
02:26:11 <ivanm> yeah
02:26:24 <ivanm> I think its the same now, but I'm going to let it run overnight to check
02:26:43 <ivanm> since for my overall program, an in put of 4 takes < 1s, but 5 takes 90 minutes
02:26:50 <ivanm> that's without profiling ;-)
02:27:03 <ivanm> so meaningful comparisons between versions are hard to do :s
02:27:15 <ejt> !
02:27:57 <quicksilver> DRMacIver: unsatisfactory unless we can make the boilerplate sufficiently low-visibility and convenient, yeah
02:30:57 <DRMacIver> Let's use an implicit parameter! :)
02:31:31 <quicksilver> DRMacIver: I'm begining to think that Adrian Hey's preferred ACIO stuff does in fact amount to implicit parameters
02:31:42 <quicksilver> DRMacIver: and that may be part of what I don't like about it
02:35:13 <DRMacIver> ACIO?
02:38:38 <quicksilver> DRMacIver: top-level IO bindings
02:38:59 <quicksilver> DRMacIver: 'ACIO' supposed to be those bits of IO which are 'fairly safe' to do at the top level
02:39:05 <quicksilver> Affine Commutative
02:40:22 <DRMacIver> Ah
02:45:48 <kuribas> It is impossible to create a toplevel IORef variable?
02:48:56 <quicksilver> kuribas: that is perfectly possible, if you're happy with it having the (correct) type IO (IORef a)
02:49:30 <quicksilver> kuribas: however if you wish to duck between the cracks in the semantics and have the type IORef a, then you have to use unsafePerformIO
02:51:09 <Vq^> quicksilver: how do you define the variable with the "correct" type?
02:52:36 <quicksilver> Vq^: toplevel = newIORef "initial value"
02:53:11 <Vq^> quicksilver: but that will create a new IORef for each use
02:53:16 <quicksilver> quite
02:53:21 <quicksilver> that's what the type means ;P
02:53:28 <Vq^> yeah :)
02:53:34 <Vq^> but it wont be very usefull
02:54:57 <quicksilver> it's very useful. Just only call it once per 'instance'
02:55:02 <Vq^> and it wont be a "toplevel IORef variable"
02:55:13 <kuribas> quicksilver: wouldn't it be theoretically possible to have an IORef type with an initial value?
02:55:18 <quicksilver> ah well, that dependes what you think toplevel IORef means :)
02:55:54 <Vq^> quicksilver: indeed
02:56:41 <nomeata> Hi again
02:56:41 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
02:56:48 <nomeata> I think I found a nice way to implement these signals
02:56:54 <Vq^> hello mr Meata
02:57:07 <nomeata> http://darcs.nomeata.de/gift/common/MSignal.hs comments welcome
02:58:11 <nomeata> quicksilver: hi. thx for your code, but mine looks even simpler, doesn’t it? Not sure if its good, though.
02:58:24 <Vq^> quicksilver: IO (IORef a) would be an IO-action that creates an IORef variable with a default value
02:59:13 <nomeata> quicksilver: especially as you don’t have to remember the “next MVar”
02:59:18 <ivanm> ejt: anything? not that I'm pressuring you, mind... ;-)
02:59:28 <nomeata> so no need for fold
02:59:34 <quicksilver> nomeata: but your code doesn't stop someone receiving the same notification twice
02:59:36 <ejt> ivanm: compiling now, have changed the matrix rep to something else
02:59:43 <quicksilver> nomeata: since it keeps reusing the same mv
02:59:46 <ejt> as a sanity check
02:59:59 <Bourbaki> moin
03:00:07 <ivanm> ejt: *nod*
03:00:07 <Bourbaki> is there anything like emacs just with haskell?
03:00:20 <ivanm> Bourbaki: yi, but its still a work in progress
03:00:20 <quicksilver> Vq^: yes, that's a more precise way of phrasing it
03:00:27 <ivanm> @where yi
03:00:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
03:00:36 <nomeata> quicksilver: But it is emptied once per signal sending
03:00:55 <Vq^> quicksilver: yes, but my point is that it isn't a variable in itself
03:01:03 <nomeata> quicksilver: and since MVar are FIFO, each receive can only be woken up by exactly one send, I think.
03:01:14 <quicksilver> nomeata: no, that's not right
03:01:27 <Bourbaki> dang a pitty
03:01:43 <Bourbaki> ah :) its one of dons thingies
03:02:05 <quicksilver> nomeata: your MVar never gets emptied
03:02:07 <Bourbaki> is there any kind of tool chain to get haskell .o files into dynamic libs?
03:02:13 <nomeata> quicksilver: it does get emptied by the sender
03:02:17 <quicksilver> nomeata: (until it's time for the next notification)
03:02:20 <quicksilver> nomeata: yes, but not before then
03:02:32 <quicksilver> nomeata: let's suppose your server notifies once, and the next notification is going to be 5 minutes later
03:02:41 <quicksilver> nomeata: during that 5 minutes, the MVar will never be empty
03:02:54 <quicksilver> nomeata: the 'clients' will receive as many signals as they want in that time!
03:03:07 <quicksilver> nomeata: every tiem they call receiveMSignal, it will return immediately and successfully
03:03:22 <nomeata> quicksilver: no, because when the client has read the signal, and starts reading again, they will be _behin_ the cleanup thread from the sender
03:03:22 <quicksilver> Vq^: I understand, yes :)
03:03:30 <nomeata> quicksilver: thus it will be empty the second time
03:03:37 <jmg_> hi
03:03:42 <nomeata> quicksilver: (if the FIFO promise in the MVar docs holds)
03:03:58 <quicksilver> nomeata: there's only one MVar
03:04:04 <nomeata> quicksilver: right
03:04:09 <quicksilver> nomeata: it isn't a separate copy for each thread
03:04:11 <jmg_> ?source return :: Either e
03:04:11 <lambdabot> return :: Either e not available
03:04:33 <nomeata> quicksilver: right. but the listeners don’t change the MVar, they just move their readMVar to the end of the queue, behind the takeMVar from the sender
03:04:36 <quicksilver> nomeata: there are two possibiliities with your cleanup thread
03:04:49 <quicksilver> nomeata: either your cleanup thread runs 'before' the putMVar
03:04:58 <quicksilver> nomeata: (you have nothing there to stop it doing so)
03:05:08 <nomeata> quicksilver: assuming an empty MVar?
03:05:11 <quicksilver> yes
03:05:15 <nomeata> quicksilver: then it can’t run before
03:05:18 <quicksilver> in which case it blocks
03:05:23 <nomeata> quicksilver: right, that’s what I mean
03:05:24 <quicksilver> and runs instantly when the put happens
03:05:43 <nomeata> quicksilver: only _after_ all those readMVars run that have been started before
03:05:54 <quicksilver> nomeata: oh, now I see what you mean
03:05:57 <nomeata> quicksilver: because readMVars and takeMVars are done FIFO
03:06:13 <nomeata> quicksilver: which makes it quite nice (unless I forgot some corner case)
03:06:51 <quicksilver> nomeata: interesting
03:07:01 * nomeata got to go again real soon, trains are not waiting for me
03:07:12 <quicksilver> nomeata: what if two signals are sent rather close together?
03:07:19 <nomeata> If you find something wrong with the code, I’d be glad for a lamdabot message....
03:07:27 <quicksilver> nomeata: such that the second put happens before the first take
03:07:38 <nomeata> I have to think that through...
03:07:51 <nomeata> Thanks for your code, anyways
03:08:00 <quicksilver> nomeata: thanks for yours. That's a neat trick.
03:08:00 <nomeata> cu
03:11:10 <Bourbaki> does either of you happen to know if theres a haskell.net yet?
03:11:31 <quicksilver> either? there are more than two people here...
03:11:32 <quicksilver> @losers
03:11:33 <lambdabot> Maximum users seen in #haskell: 340, currently: 305 (89.7%), active: 34 (11.1%)
03:11:48 <quicksilver> there has been some work on haskell .NET integration
03:11:52 <quicksilver> I don't know how good it is
03:12:14 <Bourbaki> :)
03:12:20 <Bourbaki> anyone then ;)
03:13:05 <LPhas> i think that someone should put up a @haskell.org jabber server
03:18:24 <hpaste>  ejt annotated "Removing elements from a matrix" with "alternative implementation" at http://hpaste.org/37#a1
03:19:18 <ejt> ivanm: see pasted code
03:19:28 <ivanm> thanks ejt++ ! :D
03:19:33 <ivanm> @karma ejt
03:19:34 <lambdabot> ejt has a karma of 1
03:20:06 <ivanm> ejt: sure, make me re-write my whole code just for one function :p
03:20:06 <quicksilver> awesome. I tried to click on the link ejt posted, but I missed and clicked on matric
03:20:21 <quicksilver> so I got the IMDB page for the matrix, instead :)
03:20:23 <ivanm> nah, I"ve been thinking of storing the size of the matrix in the matrix, but haven't got round to it
03:20:28 <ivanm> quicksilver: lol!
03:20:35 <ejt> ivanm: I think you'll get enough ideas in there to rewrite you function yourself
03:20:44 * ivanm has been worrying more about algorithmic enhancements than data structures
03:20:50 <ivanm> ejt: yeah, thanks
03:21:02 <quicksilver> but in haskell, your data structure is your algorithm!
03:21:05 <quicksilver> well, sometimes it is
03:21:05 <ejt> my main worry was just how much you were changing your lists of lists
03:21:07 <ivanm> heh
03:21:10 <ejt> that just wasn't going to scale
03:21:34 <ivanm> I tried arrays... maybe the same error I was having when using maybes at one point was slowing it down, but it seemed to be really slow
03:21:41 <ivanm> since I do a lot of list-based processing
03:22:20 <ejt> I think maps are the way to go to start with
03:22:22 <ivanm> You can find an older copy of my code here: users.tpg.com.au/kataryna/Report.pdf
03:22:43 * ivanm does very little index-based functions
03:22:55 <ivanm> most of what I do involves filtering, etc
03:23:21 <ivanm> I might go and try re-writing it to use arrays or maps down the track..
03:23:41 <ivanm> but a lot of what I do is row and column based, and to extract the rows out of an array... :s
03:23:58 <ejt> have you read the modular lazy search paper ?
03:24:04 <ivanm> though I did try and traverse through the toList form of the array using an accumulating map
03:24:09 <ivanm> ejt: never heard of it...
03:24:23 <ivanm> my code was originally based on bird's sudoku solver ;-)
03:24:45 <ejt> birds code is good, I've used similar techniques for solving problems
03:24:49 <ejt> can send you examples if you want
03:25:06 <ivanm> sure
03:25:20 <ejt> http://citeseer.ist.psu.edu/nordin01modular.html
03:25:20 <lambdabot> Title: Modular Lazy Search for Constraint Satisfaction Problems - Nordin, Tolmach (Rese ...
03:27:08 <ivanm> I've been writing this program incrementally since december last year
03:27:15 <ivanm> just extending upon what I've done, etc
03:27:34 <ivanm> one day I should go and try re-writing it all using an array or something, but I've never had the time :(
03:29:44 <Excedrin> is there a usual way to write "the i-th element of set s" in plain ascii math? (S_i ?)
03:29:45 <ejt> ivanm: sent
03:29:49 <ivanm> thanks
03:30:05 <ivanm> Excedrin: ummm... sets have no explicit ordering...
03:30:53 <ivanm> ejt: with you're matrix setup, where you constructing a lookup function table for mLookup?
03:31:58 <dmhouse> Excedrin: if you mean the ith element of a sequence s, then yes, S_i is the canonical way of doing it.
03:33:26 <ejt> empty
03:33:36 <ejt> which always returns Nothing
03:34:04 <ivanm> arrgghhh......
03:34:12 * ivanm is getting all his homophones mixed up
03:34:16 <ejt> I've skimmed your paper, your problem is suitable for the approach in that search paper
03:34:23 <Excedrin> thanks.. I'd like to express this in Haskell, but it's difficult for me: P^1_i = S_i/sum_k S_k  ,  P^m_i = sum_{k!=i} P^1_k*P^m-1_i(S_~k)
03:34:40 <ivanm> I meant "are you creating a lookup function table for mLookup?"
03:35:10 <ejt> mLookup is a lookup function
03:35:15 <ivanm> Excedrin: are you trying to write your variable/function as P^1_i?
03:35:20 <ivanm> ejt: *nod*
03:35:23 <Excedrin> I've been using lists, but I think it might be easier with arrays, any advice?
03:35:27 <ivanm> yeah, I might have a look at that paper...
03:35:31 <Excedrin> ivanm: yes
03:35:51 <ivanm> Excedrin: well, you can't... as ^ is the power operator in Haskell
03:35:59 <ivanm> underscore's will probably work though
03:36:00 <ejt> ivanm: don't get too hung up on the matrix rep.  that should be changeable to Map trivially
03:36:02 <Excedrin> oh, no, it's named 'prob' in Haskell
03:36:25 <ivanm> ejt: but I'm wanting to run this on uni's servers as soon as I've finished my exams
03:36:28 <ivanm> Excedrin: ahhh
03:36:46 <ivanm> ejt: nah, I was just making sure I was reading your code properly
03:37:24 <ejt> I'm composing lookup functions to build the matrix
03:39:05 <ivanm> ejt: with unsetElts... should it read "foldr unsetElt ps m", rather than "m ps" ?
03:39:24 <ejt> no
03:39:40 <ejt> m is the 'zero' for foldr
03:40:23 <ivanm> I'm just looking at the types of unsetElt
03:40:38 <ivanm> oh, wait...
03:40:40 <ivanm> @type foldr
03:40:51 <ivanm> come on lambdabot...
03:40:52 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:40:54 <ivanm> :type foldr
03:41:22 <ivanm> ejt: you're right... I forgot about taking the fold into consideration :s
03:44:33 <ivanm> ejt: did you win the bottle of champagne? :p
03:45:44 <roconnor> is there a yhc channel, we are having trouble building it.
03:46:57 <roconnor> ndm: is there a yhc channel, we are having trouble building it.
03:47:30 <roconnor> actually we are having trouble with configure
03:47:46 <ndm> roconnor: #haskell-overflow
03:49:15 <quicksilver> ndm: can data.derive only derive type classes or can it also derive (e.g.) new data declarations?
03:49:40 <bringert> manu3000: ping
03:55:20 <vincenz> Hello
03:55:58 <vincenz> Anyone know how to call haskell code from c++?
03:56:03 <vincenz> basically a reverse FFI
03:56:13 <Lemmih> Same way you call Haskell code from C?
03:56:19 <Lemmih> Hi vincenz.
03:56:32 <vincenz> Hi Lemmih
03:56:40 * vincenz sighs as he's on a really poor irc client
03:56:50 <Syzygy-> vincenz: netcat9$?
03:56:57 <vincenz> irc
03:56:57 <Syzygy-> Hrm. s/9$//
03:57:15 <manu3000> helloe bringert
03:57:21 <vincenz> better
03:57:33 <vincenz> Lemmih: so do you have to initialize the haskell rt?
03:58:15 <bringert> manu3000: about hosting: if they have GHC 6.6, you can make user installs of your own libraries
03:58:34 <manu3000> bringert: ok, well it's great news then !
03:58:39 <bringert> manu3000: my web host doesn't even have GHC, I compile on my own machine and upload the binary
03:58:45 <Lemmih> vincenz: startupHaskell(argc, argv, your_root_module);
03:59:05 <manu3000> bringert : I just upload the hop.cgi, right ?
03:59:08 <bringert> manu3000: you just have to have a linux machine or VM (if the web host uses linux), and link the program statically
03:59:30 <quicksilver> Lemmih: and what if you don't want haskell to have control? is that possible?
03:59:31 <manu3000> bringert: Im on a mac ...
03:59:53 <bringert> manu3000: me too. I compile in a Linux VM
04:00:20 <manu3000> bringert: do you have pointers ? I am out of my depth here :)
04:00:21 <Lemmih> quicksilver: Yes. Initializing the Haskell RTS doesn't transfer control to Haskell.
04:00:56 <bringert> manu3000: I use Parallels desktop, and run Linux in that. There's also the currently free VMWare Fusion beta 3
04:01:13 <bringert> manu3000: but if the web host has GHC, you might as well use that
04:01:33 <manu3000> bringert: yes I use VMWare already, but I need to install exactly the same linux than my host then ?
04:01:46 <bringert> manu3000: no, not if you link statically
04:02:08 <bringert> manu3000: edit site/Makefile and add -static -optl-static to GHCLINK
04:02:52 <bringert> manu3000: I don't even know what Linux distribution my web host runs. I use some Ubuntu version, I forget which, in VMWare to compile, and it works fine
04:03:11 <bringert> well, in Parallels actually
04:03:12 <manu3000> bringert: ok, and then upload my hope.cgi and everything should be sweet !
04:03:22 <bringert> and the style sheets etc of course
04:03:48 <manu3000> bringert: yes, CSS is the only thing I'm totally confident about ;)
04:03:59 <bringert> and you need to set up the DB connection stuff for the DB at the web host of course
04:04:11 <manu3000> bringert: thanks...I'll let you know how I'm going
04:04:46 <bringert> manu3000: oh, it'd be great if you wanted to help improving the Hope CSS, or contribute new themes
04:05:17 <manu3000> bringert:  it's going to be...ahem...interesting ;)
04:05:45 <bringert> manu3000: you mean that you will be learning lots of new things?
04:05:54 <bringert> that's good, right?
04:06:07 <manu3000> bringert: well I can definitely do that... I owe you at least that !
04:06:24 <manu3000> bringert: yeah... learning is all the fun !
04:36:11 <roconnor> How does HaXml compare with HXT?
04:36:57 <njbartlett> roconnor: I've had better results with HXT than HaXml
04:40:07 <quicksilver> roconnor: I believe they are differently designed APIs
04:40:20 <quicksilver> roconnor: I haven't seem an informed comparison. One would be interesting.
04:45:26 <hpaste>  mdmkolbe|work pasted "Problems with the Windows GHC and the -cpp option" at http://hpaste.org/38
04:45:53 <mdmkolbe|work> is that a local problem?  bug in GHC?
04:47:20 <quicksilver> mdmkolbe|work: looks like a local problem, to
04:47:23 <quicksilver> mdmkolbe|work: to me
04:47:33 <quicksilver> mdmkolbe|work: your ghc installation is confused about where your GCC installation is
04:48:00 <quicksilver> mdmkolbe|work: I wouldn't know how to being solving it, though, I'm afraid I don't know how that stuff works
04:49:45 <mdmkolbe|work> quicksilver: well the windows GHC provides it's own gcc and cc1 so it should find them
04:51:38 <quicksilver> mdmkolbe|work: in that case, maybe it is a ghc bug...
04:51:46 <quicksilver> (or at least an installer bug)
04:52:34 <hpaste>  mdmkolbe|work annotated "Problems with the Windows GHC and the -cpp option" with "Looks like GHC forgot to pass the full path for cc1" at http://hpaste.org/38#a1
04:54:30 <hpaste>  mdmkolbe|work annotated "Problems with the Windows GHC and the -cpp option" with "And this is where cc1 is located (not in the path)" at http://hpaste.org/38#a2
05:07:32 <roconnor> @hoogle Data.Generics.PlayOn
05:07:33 <lambdabot> No matches, try a more general search
05:33:52 <roconnor> I'm surprised there is not HXT debian package
05:35:17 <fasta> Is it more efficient to write a function which calls the recursive function in tail-position with a list that builds up (accumulator) or to use the environment to store these things, s.t. the tail call isn't apparent in my code? I guess it's possible to automatically transform the code in to the tail version, but I am not sure of that. I like the version which uses the environment more from a cleanness point.
05:36:41 <DRMacIver> It seems to often be the case that tail calls prevent you from properly taking advantage of laziness.
05:36:57 <fasta> DRMacIver: but what if it's not lazy
05:36:58 <dmhouse> E.g. foldl.
05:37:10 <Thomas2> it's a tradeoff
05:37:43 <fasta> I am not using laziness consciously now.
05:39:12 <erider> good morning
05:40:23 <fasta> Code: do stuff<- something; recursive_call; do_something_with_stuff
05:40:23 <fasta>                  VS
05:40:23 <fasta>       do stuff<- something; recursive_call (stuff:more_stuff)
05:40:30 <fasta> It's essentially that
05:42:56 <DRMacIver> fasta: I don't know. :)
05:43:53 <Cheery> you are struggling with that haskell type inferencer, why don't you just blend prolog in?
05:44:59 <njbartlett> DRMacIver: Were you at the HUG? I either didn't meet you, or I did meet you but failed to realise whom I was speaking with.
05:45:31 <fasta> Cheery: ?
05:46:38 <DRMacIver> njbartlett: I was, but didn't meet you owing to failure on my part. :)
05:47:14 <njbartlett> I well. I wish we had done the going-around-the-room thing, but it was just too hot and late
05:47:30 <roconnor> who's in charge of making all the libghc6-foo-dev
05:47:46 <DRMacIver> Yeah. I'd have been a bit embarassed to though. "Hi, I'm David. I think I wrote some Haskell once. Maybe."
05:50:36 <Cheery> fasta: well, haskell type inferencer is very similar to prolog
05:50:42 <njbartlett> Well that's fine... some people hadn't even done that much.
05:51:14 <fasta> Cheery: Better question: this was some topic before mine?
05:51:47 <Cheery> nop
05:51:52 <roconnor> @seen arjanoosting
05:51:53 <lambdabot> arjanoosting is in #haskell. I don't know when arjanoosting last spoke.
05:51:54 <Cheery> just asking in general sense
05:52:00 <roconnor> @seen igloo
05:52:01 <lambdabot> igloo is in #darcs, #ghc and #haskell. I last heard igloo speak 22m 24s ago.
05:53:52 <Igloo> Yup?
05:54:04 <ari> Remember when Einar Karttunen was charged with breaking the Finnish copyright law in February ( http://openlife.cc/node/171 ) with a DeCSS program? It seems he was pronounced not guilty on the grounds that CSS is not secure. (fi) http://sektori.com/uutiset/7715/karajaoikeuden
05:54:08 <lambdabot> Title: Mikko Rauhala being busy: charged for breaking EUCD, running for parliament and  ...
05:54:34 <fasta> ari: heh, that means about everything is not "secure".
05:55:21 <fasta> I wonder whether an army of tanks before your DVD-player would count as "secure" :)
05:55:47 <dmhouse> "The charge is especially serious because Rauhala paid Karttunen 0,05€ for this program." Woah, those guys must be hardcore criminals with moneys that large.
05:56:13 <opqdonut> dmhouse: that was pretty much a project to test the new copyright law
05:56:35 <dmhouse> Pretty risky project.
05:56:44 <opqdonut> twenty-something nerds gave themselves up
05:57:07 <opqdonut> well, the new law for example forbids "organized conversation on breaking copyprotection"
05:57:12 <fasta> "Haskell programming language."
05:57:34 <opqdonut> i'd say testing that is a worthy goal
05:57:35 <fasta> Does that person visit #haskell?
05:57:42 <arjanoosting> roconnor: what's up?
05:57:50 <dmhouse> fasta: Einar Karttunen does.
05:57:51 <opqdonut> fasta: okay okay i get the point
05:58:04 <dmhouse> He's... *struggles to remember* musasbi?
05:58:06 <fasta> dmhouse: what's his nick?
05:58:13 <dmhouse> He wrote a large chunk of HAppS.
05:58:30 <dmhouse> shapr: ping, you'll know this.
05:58:38 <fasta> dmhouse: musabi, IIRC
05:58:59 <edwardk> has anyone here tried to write a zipper for a higher-order abstract syntax representation?
05:59:22 <Apocalisp> http://cgi.cse.unsw.edu.au/~dons/blog
05:59:23 <lambdabot> Title: Haskell hacking
05:59:36 <Apocalisp> How do you make the haskell code format nicely like that?
05:59:38 <edwardk> I have a HOAS rep, I can transform it to first-order, but I'd really like to walk it right in HOAS.
06:00:47 <fasta> edwardk: I would suggest that's better done as meta-programming.
06:00:59 <edwardk> that would be the standard answer
06:01:25 <fasta> edwardk: but I understand that writing something like that takes some time and you don't feel like that :)
06:02:06 <edwardk> but i have this nice structure, and i'd like to be able to move around in it to perform simplifications, etc. and the zipper lets me 'change focus' so I don't have to transform the entire tree, then come back down or have pre-planned all of the optimizations to do
06:02:32 <edwardk> heh well, i've put a couple days into this so far
06:02:33 <balodja> hm-m-m, lambdabot doesn't check whether the nick is authored... that's not good
06:03:16 <fasta> edwardk: I also seriously doubt that a zipper will work forever
06:03:35 <edwardk> there is probably some trick with the fegaras/sheard catamorphism that i could use.
06:03:40 <edwardk> fasta: huh?
06:03:44 <fasta> edwardk: it could be that your requirements change some day and that you need a reference based structure.
06:04:04 <fasta> edwardk: zippers have limitations
06:04:10 <edwardk> sure
06:04:12 <DRMacIver> njbartlett: Yeah, I know. I just embarass easily. :)
06:04:54 <quicksilver> balodja: ?
06:04:54 <edwardk> but the structure that i'm working with right now will remain a tree/DAG , because it represents a terminating fragment in the language
06:05:24 <edwardk> 'references' right now require unrolling variables, which is fine, because i only unroll a finite amount of times in the analysis
06:05:32 <edwardk> to keep things bounded
06:09:12 <balodja>                         ok      <- liftM2 (||) (return $ cmd' `notElem` (privs ++ illegal))
06:09:14 <balodja>                                                (lift $ checkPrivs msg)
06:09:31 <balodja> quicksilver: there is no check if the nick is authorized to nickserv
06:09:56 <roconnor> arjanoosting: you make debian packages for ghc libraries?
06:10:45 <quicksilver> balodja: that is a deliberate decision
06:10:55 <quicksilver> balodja: by default, lambdabot wouldn't even see the message from a non-auth person
06:10:57 <roconnor> Igloo: you also make debian packages for ghc libraries?
06:11:09 <kaol> I make them too
06:11:09 <quicksilver> balodja: but his freenode account is deliberately chosen to see non-auth messages
06:11:32 <mdmkolbe|work> @source System.Cmd
06:11:32 <lambdabot> http://darcs.haskell.org/packages/base/System/Cmd.hs
06:11:36 <mdmkolbe|work> but that link is 404
06:11:53 <mdmkolbe|work> where did it go?
06:12:40 <roconnor> kaol: how would we get the HXT packaged up in debian
06:13:37 <kaol> if it's a cabalised library then it's pretty straightforward.
06:15:45 <ari> @poll-results cheeky-off
06:15:45 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=1, AddFlag=2, No=4, Yes=13
06:16:06 <balodja> quicksilver: that's not just about private messages
06:16:30 <arjanoosting> roconnor: yes I do. If you want to package HXT I suggest you look at the source of other packages
06:16:35 <roconnor> kaol: it is cabalzied
06:16:38 <mdmkolbe|work> ari: what poll is that?
06:16:45 <quicksilver> balodja: oh, you mean it will 'trust' someone with the same nick as a trusted user, even if they have just changed their nick with /nick?
06:16:48 <Itkovian> afternoon
06:16:57 <Igloo> roconnor: I'm a bit confused about the tarball; what's the doc directory?
06:17:21 <balodja> quicksilver: yeah, exactly
06:17:25 <Igloo> roconnor: I can't tell if the soures for the docs are in the tarball or not
06:17:49 <balodja> most of the bots have there own athorizations or use nickserv
06:18:22 <quicksilver> balodja: maybe most of the privileged owners are online 24/7 so it's quite  hard to steal their nicks
06:18:23 <ari> @src hello
06:18:23 <lambdabot> Source not found. My pet ferret can type better than you!
06:18:38 <quicksilver> balodja: actually freenode will change your nick for you if you try to use a regged nick, won't it?
06:18:41 <ari> mdmkolbe|work: It's about lambdabot's cheekiness
06:18:58 <balodja> quicksilver: but a hacker has a minute :)
06:19:06 <quicksilver> balodja: *nod*
06:19:16 <quicksilver> balodja: you should point it out to dons, or someone
06:21:12 <mdmkolbe|work> @vote cheeky-off yes
06:21:12 <lambdabot> "yes" is not currently a candidate in this poll
06:21:16 <mdmkolbe|work> @vote cheeky-off Yes
06:21:16 <lambdabot> voted on "Yes"
06:21:50 <ibid> will Yes be elected?
06:22:09 <quicksilver> no, there were too many dimpled chads
06:22:43 <fasta> I would expect the factoids to be back-upped somewhere.
06:23:20 <fasta> So, if someone "hacks" an IRC account (trivially for anyone working for an ISP), I don't think they care that much.
06:23:29 <fasta> trivial*
06:24:27 <dylan> @vote cheeky-off Ye
06:24:27 <lambdabot> "Ye" is not currently a candidate in this poll
06:24:30 <dylan> @vote cheeky-off Yes
06:24:30 <lambdabot> voted on "Yes"
06:25:30 <roconnor> @type maybe
06:25:32 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:26:22 <fasta> roconnor: did you see my Coq question?
06:27:45 <roconnor> er sorry let me look
06:29:01 <emu> Igloo: got a moment for .deb pkging questions?
06:29:21 <Igloo> Yup
06:29:55 <emu> i've created my first cabal/debian package using the cabalDebianTemplate.  it seems to work fine except for a couple issues:
06:30:19 <emu> haddock by default doesn't find the interface files for associated libraries.  is there a proper way to get it right?
06:30:45 <Igloo> I don't use cabalDebianTemplate so I'm not sure about that
06:30:50 <emu> and i don't quite understand how the testing-suite scripts work, what stage they are run at, what they expect to be around
06:31:01 <emu> oh, well it just calls ./Setup.lhs haddock
06:32:02 <Igloo> Hmm, my scripts just call that too, and they work
06:32:07 <Igloo> Is this ghc 6.6.1?
06:32:17 <emu> yes, unstable
06:32:24 <emu> i installed it all fresh
06:33:04 <emu> "HTML directory /usr/share/mtl-1.0.1/doc/html does not exist." like it's trying to look for it in some assumed default
06:33:55 <emu> i looked at haskell-http, but it seems to "just work" for that package and i can't see why
06:37:09 <profmakx> hm... next haskell project: Some browser like links2 with vim navigation, haskell scriptable.
06:37:14 <profmakx> or did someone do that already?
06:37:48 <quicksilver> I don't think anybody has written much of anything 'haskell scriptable' to be honest
06:38:03 <quicksilver> I think haskell-as-a-scripting language remains quite unexplored
06:38:12 <CosmicRay> probably so.  unfortunate.
06:38:14 <quicksilver> xmonad uses it as a config language but that isn't quite the same.
06:38:30 <CosmicRay> the fact that ghc-plugins isn't terribly portable doesn't help
06:38:38 <emu> there is some magic waiting to be worked with -plugins and scripting
06:38:49 <quicksilver> CosmicRay: I'm sure that's a factor
06:38:58 <quicksilver> CosmicRay: it tends to break on minor GHC point releases too
06:39:05 <CosmicRay> ah, bummer
06:39:28 <CosmicRay> it would be interesting to see a basic Haskell interpreter written in haskell.
06:39:52 <quicksilver> I don't think haskell is a very easy language to interpret :)
06:39:56 <profmakx> hm
06:40:04 <profmakx> well config language would suit me fine
06:40:10 <quicksilver> that's why hugs and ghci are big programs, not small ones...
06:40:14 <CosmicRay> profmakx: http://software.complete.org/configfile
06:40:15 <lambdabot> Title: ConfigFile
06:40:26 <CosmicRay> quicksilver: yeah but if you're already running under haskell....
06:40:31 <CosmicRay> maybe it would be easier
06:40:35 <emu> i suspect everyone just concocts something with parsec real fast
06:41:22 <quicksilver> CosmicRay: not really. There isn't 'enough' of the haskell environment left around in compiled code
06:41:32 <quicksilver> CosmicRay: it is a 'real' compiler, in that sense
06:42:15 <CosmicRay> quicksilver: right, I understand.  I was wondering if writing the interpreter in the language being interpreted might have some advantages.  for instance, we don't have to hack around an environment's lack of closures.
06:42:21 <Igloo> emu: Ah, it looks like the extralibs aren't getting their haddock directories set correctly
06:42:48 <emu> its not me?
06:43:11 <Igloo> emu: No
06:43:48 <emu> ok
06:44:03 <quicksilver> CosmicRay: yes, that much is certainly true
06:44:05 <emu> well, then maybe i will upload these later this weekend
06:44:18 <quicksilver> CosmicRay: but you'd still got desugaring, type inference, kind inference, and typeclass resolution to do :)
06:44:41 <CosmicRay> yeah, I see your point.
06:45:28 <emu> better would be a standardized interface to the compiler a la eval =)
06:46:28 <quicksilver> emu: well, that's what hs-plugins is
06:46:32 <quicksilver> emu: it's just not perfect yet :)
06:46:39 <emu> aye
06:46:40 <quicksilver> it's pretty bloody impressive, though
06:48:21 <roconnor> @src Functor
06:48:22 <lambdabot> class  Functor f  where
06:48:22 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
06:49:14 <roconnor> @src Monad
06:49:15 <lambdabot> class  Monad m  where
06:49:15 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
06:49:15 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
06:49:15 <lambdabot>     return      :: a -> m a
06:49:15 <lambdabot>     fail        :: String -> m a
06:49:20 <CosmicRay> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-8.html#node_sec_C
06:49:21 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules, http://tinyurl.com/2b9rop
06:50:01 <quicksilver> CosmicRay: *nod*
06:50:59 <ski_> @djinn (Eq a) => (a,Either a (Not Bool)) -> Bool
06:50:59 <lambdabot> f (a, b) =
06:51:00 <lambdabot>     case b of
06:51:00 <lambdabot>     Left c -> a == c
06:51:00 <lambdabot>     Right d -> void (d False)
06:52:35 <king51290> bitte helft mir und besucht http://www.Saphir-mailer.de/raub.php?user=zork  danke
06:52:38 <lambdabot> Title: www.saphir-mailer.de
06:54:32 <mdmkolbe|work> The recent mingw32 snapshots are 403 (Forbidden) (e.g. http://www.haskell.org/ghc/dist/current/dist/ghc-6.7.20070523-i386-unknown-mingw32.tar.bz2 ).  Is there an easy way to get that fixed? (I want to test a hypothesis about one of the recent changes to Cabal and it's interaction with mingw)
06:54:34 <lambdabot> http://tinyurl.com/2lwgyq
07:30:16 <mdmkolbe|work> Is there a simpler expression for (\f xs -> sequnce (mapM f xs))?
07:30:36 <opqdonut> ?pl \f xs -> sequnce (mapM f xs)
07:30:37 <lambdabot> (sequnce .) . mapM
07:30:40 <opqdonut> there
07:30:45 <opqdonut> :)
07:31:30 <mdmkolbe|work> heh, I already tried that
07:32:28 <sjanssen> @type  (\f xs -> sequence (mapM f xs))
07:32:30 <lambdabot>     Ambiguous occurrence `sequence'
07:32:30 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
07:32:47 <sjanssen>  @type  (\f xs -> Control.Monad.sequence (mapM f xs))
07:32:59 <sjanssen> @type  (\f xs -> Control.Monad.sequence (mapM f xs))
07:33:01 <lambdabot>     Ambiguous occurrence `mapM'
07:33:01 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
07:33:05 <sjanssen> bah
07:33:07 <opqdonut> :)
07:33:12 <Vq^> ?
07:33:28 <sjanssen> @tell dons can you fix the "Ambiguous occurrence `mapM'" problem?
07:33:28 <lambdabot> Consider it noted.
07:33:40 <mdmkolbe|work> @type  (\f xs -> Control.Monad.sequence (Control.Monad.mapM f xs))
07:33:42 <lambdabot> forall a b. (a -> [b]) -> [a] -> [[b]]
07:34:00 <sjanssen> mdmkolbe|work: an interesting function
07:35:47 <mdmkolbe|work> sjanssen: oops.  I guess I was thinking (sequence . map), which is the same as mapM which is actually what I want
07:46:26 <Cheery> have you thought about doing unicode support for haskell?
07:47:12 <sjanssen> Cheery: who is 'you' and what do you mean by Unicode support? :)
07:47:27 <Cheery> UTF-16 and 32
07:47:43 <MyCatVerbs> Cheery: burn in Heck. utf8 foooreeeevaaaaar.
07:47:56 <sjanssen> Haskell already supports Unicode -- however, all the IO libraries packaged with the compilers suck
07:48:03 <Cheery> 'you' is anyone
07:48:05 <Eelis> is there some option to disable ghci's awfully smug ascii art banner that it shows on startup?
07:48:07 <MyCatVerbs> Cheery: mmm, I think Scheme interpretations are supposed to use UCS-4 internally. Close enough.
07:48:21 <sjanssen> Cheery: actually, Hugs has limited Unicode support
07:48:23 <MyCatVerbs> Eelis: no, learn to love it already. =)
07:48:42 <Eelis> MyCatVerbs: i'd sooner edit the source!
07:48:53 <MyCatVerbs> Eelis: bah.
07:48:57 <Cheery> I think about UTF-16 and 32 since haskell would have relatively easy to do support for them
07:49:18 <Eelis> the ocaml interactive interpreter is at least a little more humble
07:49:28 <MyCatVerbs> Eelis: almost all powerful functional languages have awesome REPL banners. Hell, even GNU clisp has that awesome ASCII menorah.
07:49:46 <opqdonut> :D
07:49:55 <Eelis> i don't mind banners, as long as i can turn them off with a switch
07:50:30 * Eelis files a ghc bug report
07:50:39 <Cheery> you could just define datatypes Utf16 and Utf32 from Word32 and Word16
07:50:52 <opqdonut> ?remember MyCatVerbs almost all powerful functional languages have awesome REPL banners. Hell, even GNU clisp has that awesome ASCII menorah
07:50:52 <lambdabot> Done.
07:50:57 <opqdonut> :)
07:51:00 <opqdonut> ?quote menorah
07:51:01 <lambdabot> MyCatVerbs says: almost all powerful functional languages have awesome REPL banners. Hell, even GNU clisp has that awesome ASCII menorah
07:51:16 <Cheery> then define Show and Read for [Utf16] and [Utf32]
07:52:23 <Cheery> heck, in *nix systems, you could probably even provide such actions that print out them as proper symbols :)
07:53:32 <Eelis> ah, -v0 kills the banner
07:53:34 <sjanssen> Cheery: are you aware that Char is a Unicode code point?
07:53:39 <Eelis> though i wonder what else i lose by doing -v0
07:54:26 <Cheery> sjanssen: nop
07:54:35 <MyCatVerbs> opqdonut: I'm honoured. =)
07:54:37 <sjanssen> Cheery: well, it is :)
07:54:43 <Cheery> so it actually already has unicode support? :)
07:55:05 <MyCatVerbs> Cheery: except for the fact that the IO libraries kinda suck at it, apparently.
07:55:05 * Cheery needs to test that
07:55:06 <sjanssen> Cheery: yes, String can represent the full Unicode range
07:55:14 <Cheery> ['a'..]
07:55:17 <Cheery> > ['a'..]
07:55:19 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
07:55:20 <sjanssen> but our IO libraries suck
07:55:28 <sjanssen> > maxBound :: Char
07:55:29 <lambdabot>  '\1114111'
07:55:41 <Cheery> > ['\137'..]
07:55:42 <lambdabot>  "\137\138\139\140\141\142\143\144\145\146\147\148\149\150\151\152\153\154\15...
07:55:46 <Cheery> > ['\300'..]
07:55:47 <lambdabot>  "\300\301\302\303\304\305\306\307\308\309\310\311\312\313\314\315\316\317\31...
07:55:52 <Cheery> niiiceee :)
07:55:57 <Cheery> you are sweet people
07:56:34 <MyCatVerbs> sjanssen: so it'd be a case of sticking a utf8 parser in the hGet* functions?
07:56:41 <sjanssen> MyCatVerbs: yes
07:57:01 <sjanssen> MyCatVerbs: nobody seems interested in this, though :(
07:57:09 <MyCatVerbs> Hrmn. Wonder how you'd deal with utf16, le, and be?
07:57:22 <sjanssen> my idea was to add encoding info to Handle
07:58:30 <sjanssen> so each Handle would be tagged with an encoding, and perhaps some encoding specific state (like in-between bytes in multi-byte characters)
07:58:32 <fasta> Eelis: You can always work around banners.
07:58:43 <fasta> Eelis: As evidenced by haskell-mode.
07:59:00 <MyCatVerbs> sjanssen: hSetUnicodeType :: Handle -> UnicodeTransform -> IO (); datatype UnicodeTransform = Utf7 | Utf8 | Utf16 | Utf32?
07:59:06 <Eelis> fasta: sure, but the question is: how much effort do i have to put in?
07:59:17 <sjanssen> MyCatVerbs: yeah, something like that
07:59:49 <MyCatVerbs> sjanssen: (no need to specify utf16 endianness, I think, there's a code point that explicitly comes out one way or the other depending on the endianness, so you can just guess it from the first character of input, right?)
08:00:33 <sjanssen> MyCatVerbs: A UTF-16 stream will have a byte order mark at the beginning
08:00:33 <MyCatVerbs> sjanssen: I wonder if it'd be worthwhile to add ISO-8859-n support?
08:00:41 <MyCatVerbs> sjanssen: that'd be the one.
08:00:53 <olsner> I don't think the BOM is *always* there, just almost always?
08:00:53 <sjanssen> but UTF-16BE and UTF-16-LE are valid encodings too -- they won't have a BOM
08:00:54 <MyCatVerbs> I mean, on one hand, yay, seamless character set handling.
08:01:12 <MyCatVerbs> sjanssen: ah, damn.
08:01:18 * Cheery has realised how much nicer the world would be if everybody would just use network-byte-order
08:01:24 <Cheery> :)
08:01:27 <sjanssen> MyCatVerbs: you probably don't want to make encoding a closed data type.  You want a class or some such
08:01:27 <MyCatVerbs> OTOH, 8859 sucks ass beyond all belief an' anything we can do to discourage their use would be just awesome.
08:01:53 <MyCatVerbs> Cheery: better still, utf8, dammit, and make this crap irrelevant (for character streams, anyway).
08:02:30 <olsner> I vote UTF-8.. for most intents and purposes it'll pretend to be a standard 8-bit encoding
08:02:33 <MyCatVerbs> sjanssen: whyso? I'd've thought this'd be stuff ideally put into the C code underlying the standard libraries.
08:02:33 <quicksilver> sjanssen: the thing about BOMs is you might want to consider the possibility of being halfway through a stream
08:02:34 <Cheery> I think utf8 should be just file-encoding, dealing with it in a running app seems harder
08:02:53 <MyCatVerbs> sjanssen: rather than letting the Haskell coders touch it directly.
08:03:00 <quicksilver> sjanssen: one of the things that many of the family got right was the ability to tell where you are even if you're halfway through a character
08:03:13 <Cheery> I guess all my editors already are automatically typing UTF8 :)
08:03:23 <MyCatVerbs> Cheery: well yeah, but *all* variable length encodings suck for application use unless you have a very clever library set that abstracts away the complexity.
08:03:49 <sjanssen> MyCatVerbs: extensibility would be really handy.  What if a user needs to use some rare, legacy encoding?
08:04:08 <MyCatVerbs> Cheery: utf16 is no better, at least not once you get into oriental character sets. Merely more compact if most of your text happens to be sourced from Korea. 
08:04:12 <MyCatVerbs> sjanssen: ahh, I see.
08:05:05 <MyCatVerbs> sjanssen: so make most of 'em done hard in C, with the option of allowin the user to define their own encoding-scheme transformations from plain byte lists or arrays into [Char]s?
08:05:07 <sjanssen> MyCatVerbs: by the way, not much of GHC's IO code is written in C
08:05:14 <sjanssen> buffering, locking, etc. are all done in Haskell
08:05:22 <MyCatVerbs> sjanssen: Oh. I am surprised.
08:05:40 <MyCatVerbs> Gratitiously so, even. My bad.
08:06:06 <quicksilver> haskell, despite being a purely functional language, remains a more convenient imperative language than C :)
08:06:07 <MyCatVerbs> sjanssen: can ghc perform partial application at compile time as an optimization?
08:06:34 <sjanssen> MyCatVerbs: I'm not really sure
08:06:37 <quicksilver> A suprisingly small amount of C is in volved in the whole system
08:06:44 <quicksilver> MyCatVerbs: under some circumstances, yes
08:06:47 <MyCatVerbs> quicksilver: being a slavish fanboy of both Haskell and C (albeit for entirely disparate problem domains), I'm tempted to disagree.
08:07:21 <quicksilver> MyCatVerbs: if the parameter is a compile-time constant, and the function is a top-level case, then that can be specialised at compile time, I believe
08:07:33 <MyCatVerbs> quicksilver: spiffffyyy. ^^
08:07:33 <quicksilver> I'm not sure of the details
08:09:06 <MyCatVerbs> I vaguely remember hearing of, but being too lazy to read, some postgrad student's work on smooth transition from interpreters to compilers based on increasing degree of partical application. It sounded like a truly awesome third-way for compiler design. ^^
08:12:00 <olsner> I've seen partial application applied to scheme code to produce compiled parsers from a dynamic parser ("interpreter")
08:12:21 <dcoutts> partial evaluation is pretty cool
08:12:25 <olsner> but that was through some transformer software to perform the partial application
08:12:41 <dcoutts> it's been nearly mainstream for about 20 years however
08:13:01 <dcoutts> which is frustrating
08:13:22 <fasta> dcoutts: you mean mainstream in the academic world?
08:13:33 <dcoutts> fasta: yeah, even there
08:14:00 <dcoutts> everyone knows that many common techniques are special cases of partial evaluation
08:14:07 <fasta> dcoutts: since I don't see all this partial evaluation beauty anywhere near e.g. GHC
08:14:17 <MyCatVerbs> dcoutts: hmmm.
08:14:22 <dcoutts> fasta: exactly!
08:14:32 <MyCatVerbs> dcoutts: damn difficult to actually perform in practice?
08:14:36 <dcoutts> where are all the practical partial evaluators?
08:14:39 <fasta> It's because GHC uses the RULES mechanism.
08:14:42 <dcoutts> MyCatVerbs: somewhat
08:14:54 <MyCatVerbs> dcoutts: ah well. VLIW was a beautiful idea too =)
08:14:54 <fasta> dcoutts: Stratego has implemented some.
08:14:54 <dcoutts> fasta: no, I think it's more fundamental than that
08:15:33 <dcoutts> partial eval is tricky on typed languages and it's tricky to use in practise for non-experts
08:15:51 <dcoutts> when it doesn't specialise it's sometimes hard to work out why, and what you have to do to make it specialise
08:16:15 <dcoutts> and you have to worry about termination
08:17:40 <byorgey> question - is the Functor type class a superset of Monad?  Or are there some monads which are not functors? (I suppose the answer could be different in Haskell as opposed to pure category theory?)
08:18:06 <ski_> every monad ought to be a functor
08:18:35 <olsner> c++ templates seems to be almost the same thing, but is explicit on the coder's part.. non-termination there is eliminated by limiting the recursion depth of template instantiations..
08:18:38 <MyCatVerbs> dcoutts: tricky on *typed* languages? o_O
08:18:46 <byorgey> ski_: ok, that's what I thought.
08:18:47 <ski_> MyCatVerbs : yes
08:18:49 <dcoutts> MyCatVerbs: right
08:18:50 <MyCatVerbs> dcoutts: is it easier on untyped languages or something?
08:18:52 <dcoutts> yes
08:18:53 <fasta> dcoutts: I think the problem is that people worry too much and don't do anything :)
08:18:57 <MyCatVerbs> Wow.
08:19:11 <dcoutts> fasta: I think it'll come eventually, but it needs more work
08:19:19 <MyCatVerbs> That'd have to be the first case I've ever heard of of strong typing making an optimization _harder_ to perform.
08:19:28 <TomMD> Does lambdabot increment the karma of a user named 'c' every time you mention c++?
08:19:32 <TomMD> @karma c
08:19:32 <lambdabot> c has a karma of 15
08:19:46 <fasta> dcoutts: I find your remark on typing making it harder also odd and therefor interesting.
08:19:46 <dcoutts> MyCatVerbs: one traditional technique is self-application of partial evaluators
08:19:46 <MyCatVerbs> TomMD: that's not a problem.
08:19:50 * ski_ seem to recall someone partially evaluating *by-hand* a partial evaluator applied to itself (in some miniML iirc)
08:19:56 <MyCatVerbs> TomMD: C is a fine language (for operating systems).
08:20:03 <fasta> dcoutts: ah, you mean mix mix
08:20:07 <dcoutts> fasta: it's the tagging problem for typed interpreters or typed languages
08:20:16 <dcoutts> fasta: yes, mix mix mix
08:20:22 <MyCatVerbs> TomMD: it's when people type C++++ that we shall need to worry.
08:20:25 <dcoutts> or/on
08:20:28 <TomMD> But it can still constitute a flaw in lambdabot - it should not misinterpret such common statements.
08:20:37 <fasta> dcoutts: Futurama (or something like that) projection
08:20:39 <olsner> argh, I have things that need my attention more than #haskell :(
08:20:48 <MyCatVerbs> TomMD: ehhhh, it's harmless.
08:20:51 <dcoutts> fasta: yes, mix mix mix is the 3rd Futurama projection
08:21:01 <MyCatVerbs> TomMD: 'sides, whoever paid attention to the karmabot?
08:21:11 <ski_> Futamura
08:21:13 <dcoutts> fasta: one approach for typed languages is to write  mix mix mix = cogen directly
08:21:24 <dgoodlad> Hi all - I'm trying to build mtl on a fresh install of ghc, but it's complaining that it can't find module 'Control.Monad.Instances'; I've done some searching and it seems that module should be in the base library, but I can't seem to get mtl to find it... Any ideas?
08:21:30 <dcoutts> another technique is to tackle the tagging problem directly
08:21:47 <emu> TomMD: it's countered by mention of c--
08:21:53 <fasta> dcoutts: and what is the tagging problem?
08:21:53 <emu> @karma c
08:21:53 <lambdabot> c has a karma of 15
08:22:11 <opqdonut> hehe
08:22:11 <erider> @karma erider
08:22:11 <lambdabot> You have a karma of 0
08:22:16 <fasta> Yes, it's Futamura
08:22:22 <erider> damn
08:22:29 <TomMD> Or perhaps it is not a lambdabot problem at all.  I seems such ++ statements must begin the line. c++
08:22:29 <sjanssen> dgoodlad: what version of ghc/base do you have?
08:22:32 <quicksilver> fortunately, I steal karma from a certain well-known OSX application
08:22:33 <TomMD> @karma c
08:22:33 <lambdabot> c has a karma of 15
08:22:36 <TomMD> Yep
08:22:40 <quicksilver> which just goes to show the justice in the karma system
08:22:43 <dcoutts> fasta: imaging an interpreter in a typed language for a language with Ints and Bools, you typically need a type, data Value = Int Int | Bool Bool
08:22:44 <quicksilver> since it stole my name
08:22:52 <dgoodlad> sjanssen: ghc version 6.4.2
08:23:14 <dcoutts> fasta: however if you partially evaluate an interpreter like that you end up with Int/Bool tags in the final code
08:23:25 <sjanssen> dgoodlad: newer versions of mtl will require base>=2.0, which requires ghc 6.6
08:23:26 <emu> i just wrote an excel macro. i feel dirty.
08:23:47 <dgoodlad> sjanssen: hmm interesting; 'newer versions' == 1.0?
08:24:02 <dgoodlad> (that's what I'm trying to build)
08:24:16 <byorgey> emu: the horror! you should power-cycle your box three times now
08:24:35 <dcoutts> fasta: now imagine that you have to have a source program that manipulates syntax trees, it's got an extra layer of tagging, then once you get mix mix mix, you've got 3 too many layers of tagging and it goes slow as molassis and produces highly sub-optimial final code
08:25:02 <sjanssen> dgoodlad: hmm, apparently.  It seems strange that it is only at 1.0, though . . .
08:25:13 <sjanssen> did somebody change mtl without bumping the version?
08:26:39 <fasta> dcoutts: and why can't one just strip the tags in the real code and hold a mapping to remember the tags of whatever what was left?
08:27:13 <dcoutts> fasta: yes, that's another approach to solving it, however it's rarely a total solution.
08:27:30 <dgoodlad> sjanssen: hmm odd I just ran ghc-pkg and it lists mtl-1.0 already installed... I guess I don't have to build it myself, but this whole thing seems odd to me
08:27:35 <fasta> dcoutts: well, it's pretty pointless to talk about it, since I don't understand the complete problem.
08:27:50 <dgoodlad> I'm a relative haskell newbie, so am still trying to get around all the different tools available
08:27:55 <sjanssen> dgoodlad: are you building from the tarball on hackage?
08:28:14 <dcoutts> fasta: a direct solution of the tagging problem allows you to have a types AST for the target language that encodes *only* well typed target program and without extra tags.
08:28:23 <dcoutts> a typed*
08:28:34 <dgoodlad> sjanssen: yes, it's the tarball from haskell.org, can't remember the exact url
08:28:52 <dgoodlad> sjanssen: ahh, yes, it was hackage.haskell.org
08:28:54 <araujo> morning
08:29:00 <ski_> hughes had some paper about "type specialization" that managed to fully specialize an interpreter applied to an object program, istr
08:29:20 <dgoodlad> sjanssen: my goal is building xmonad, so I'm just following their build instructions, which include the need to build mtl
08:29:22 <dcoutts> fasta: so yeah, there's a lot of detail there, but you can see perhaps why it's more of a problem in a typed language than an untyped one.
08:30:03 <matthew_-> mmm. I wish the type checker was lazy...
08:30:25 <dcoutts> dgoodlad: if you got ghc from your distro then it should also have an mtl package
08:30:32 <fasta> dcoutts: I only see that all values are wrapped, but AFAIK, this wrapping and unwrapping can also be partially evaluated, so I clearly miss something.
08:30:51 <sjanssen> dgoodlad: we should probably rejig that a bit.  mtl comes with ghc distributions < 6.6 automatically
08:30:52 <dgoodlad> dcoutts: I installed it via gentoo portage (it installed ghc-bin, the compiled ghc from source)
08:30:59 <dgoodlad> sjanssen: ahh ok
08:31:17 <dcoutts> dgoodlad: then also emerge dev-haskell/mtl
08:31:21 <dgoodlad> jumping into a new language is always ... interesting... trying to figure out all the common libs and what comes with what
08:31:50 <dcoutts> dgoodlad: you'll have to unmask that one too, just like you unmasked ghc-6.6
08:32:00 <dgoodlad> dcoutts: I'm on 6.4, not 6.6
08:32:06 <dgoodlad> is 6.6 'recommended'?
08:32:30 <jfredett> does haskell have a set datatype and I'm just blind?
08:32:31 <dcoutts> dgoodlad: then you've already got mtl, but perhaps xmonad needs ghc-6.6. You could use the ghc-6.6 and xmonad ebuild from the Haskell overlay.
08:32:37 <dcoutts> jfredett: Data.Set
08:32:44 <dgoodlad> dcoutts: ok cool I'll give that a try
08:32:46 <dcoutts> jfredett: that is the Data.Set module
08:32:48 <jfredett> docs for it?
08:32:54 <dcoutts> @docs Data.Set
08:32:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
08:33:01 <jfredett> dcoutts, your brilliant
08:33:07 <dcoutts> :-)
08:33:57 <dcoutts> thank lambdabot
08:33:58 <dcoutts> @botsnack
08:33:58 <lambdabot> :)
08:34:06 <jfredett> lol
08:34:08 <dgoodlad> hahaha
08:34:17 <jfredett> lambdabot, brilliant show
08:34:21 <jfredett> @botsnack
08:34:21 <lambdabot> :)
08:34:29 * jfredett pets lambdy
08:34:37 <jfredett> ataboy lambdy. :)
08:35:14 <dcoutts> @arr
08:35:14 <lambdabot> Swab the deck!
08:36:36 <dgoodlad> dcoutts: is it reasonably safe to emerge ghc-6.6 over my existing 6.4 installation?
08:36:50 <whaleofconfusion> you know, compilation can be seen as the partial application of a "run-program" function
08:36:52 <dgoodlad> (I'm always wary of doing upgrades to software I'm not totally familiar with)
08:37:31 <whaleofconfusion> evaluated on its first input, the program source code
08:37:56 <whaleofconfusion> then when you actually run the program, you apply the second input, namely the runtime environment
08:38:00 <dcoutts> dgoodlad: yes, it's pretty much fine, if you have problems ask in #gentoo-haskell
08:38:41 <dgoodlad> dcoutts: ok thanks
08:39:55 <whaleofconfusion> macros are simply the ability to run code at an earlier stage of execution
08:43:16 <ndm> is there a flag to permit no definitions?
08:43:22 <ndm> i.e. foobar :: String -> Int
08:43:31 <ndm> but then not implement foobar, and have it just crash if called?
08:45:11 <ari> ndm: I take it you don't want to just say foobar = undefined?
08:45:13 <quicksilver> I'm not aware of a flag. is foobar _ = error "BANG" not what you need?
08:45:32 <ndm> ari: yes, i don't want to have to write that
08:45:47 <ndm> quicksilver: you assume then that foobar takes 1 argument, i want foobar = error "BANG"
08:45:56 <ndm> its for automatic transformation, i know how to do it in one case
08:46:04 <ndm> but if i can do it with a flag, i don't have to do it manually
08:46:51 <fasta> ndm: foobar = error "BANG" just works
08:47:03 <ndm> fasta: i know, but i want it without having to write it
08:47:05 <fasta> ndm: It's a function taking any number of arguments.
08:47:16 <ndm> i.e. all missing implementations have error "auto-generated"
08:47:56 <fasta> ndm: I need more context to say anything useful.
08:48:28 <ndm> fasta: i want a flag so that "foo :: String -> Int" -fsomething means that if foo doesn't have an implementation, it gets a default BANG one
08:48:34 <Saizan> the only useful thing here would be the name of the requested flag :)
08:48:51 <ndm> indeed
08:49:20 <dr_strangelove> do haskell strings support utf-8?
08:49:37 <quicksilver> not in any direct sense, no
08:49:41 <fasta> ndm: open a ticket :)
08:49:54 <quicksilver> haskell strings are [Char] where Char is 'big enough' to hold any unicode char in principle
08:50:01 <quicksilver> in practice Char is 32 bits I believe
08:50:06 <ndm> fasta: i want it now (makes my life easier), or never (i'll have worked around it by the time the ticket is fixed)
08:50:10 <ndm> quicksilver: 21 bits, actually
08:50:25 <ndm> in GHC at least
08:50:25 <quicksilver> well, thre you go :)
08:50:34 <ndm> 32 in Yhc
08:51:32 <sjanssen> ndm: Yhc lets you construct Chars outside the Unicode range?
08:51:32 <Saizan> but the IO primitives use only the least significant 8, iirc
08:51:34 <dr_strangelove> ok, so if I have a web form and I set the charset to utf8 it should work for non-asian people?
08:51:43 <quicksilver> Saizan: some of them do, yes
08:51:43 <Igloo> ndm: In what sense? Do you mean you just don't check the value when doing things like toEnum?
08:51:51 <quicksilver> Saizan: hPut and hGet and friends
08:51:55 <ndm> sjanssen: no, it restricts you to ASCII - it just so happens we still use 32 bits for char
08:52:04 <ndm> Igloo: no idea, the unicode support is broken beyond belief
08:52:10 <ndm> for Yhc Char == Int
08:52:26 <ndm> they are actually synonyms, and things like cases on chars become cases on Ints really early on
08:52:35 <sjanssen> Unicode support is broken beyond believe in all Haskell compilers
08:52:46 <sjanssen> (I know I'm trolling ;) )
08:53:40 <fasta> What is an implementation of any language that hasn't got broken unicode support?
08:53:56 <DRMacIver> fortress alleges to have good unicode support.
08:53:58 <Saizan> dr_strangelove: it depends on how you use the data later, you'll probably end up with a String where each Char is an utf-8 Octet
08:54:11 <fasta> DRMacIver: fortress is still vapourware
08:54:24 <fasta> Or a toy to be more precise.
08:55:09 <thruspa> I think limbo and Plan9 C have good unicode support.
08:55:15 <DRMacIver> Perhaps. I don't know enough to comment. :) But it is a language with an implementation that at least claims to have good unicode support.
08:56:00 <quicksilver> Java unicode support is pretty straightforward, isn't it?
08:56:29 <fasta> quicksilver: I intended that as an example of what might not be broken, but I left it out intentionally.
08:56:48 <quicksilver> AIUI perl's isn't too bad
08:56:52 <fasta> I think it mostly is an issue with a lack of awareness.
08:57:15 <sjanssen> well, Java's support leaks the fact that strings are UTF-16
08:57:22 <sjanssen> that leaves a foul taste in my mouth
08:57:31 <dr_strangelove> Saizan: you mean all non-ascii characters are split up in 2 or three chars?
08:57:44 <quicksilver> dr_strangelove: no, it depends what you do
08:57:46 <fasta> I don't understand why there are no "big chars", just like "big nums".
08:57:50 <Saizan> dr_strangelove: yes
08:57:57 <quicksilver> dr_strangelove: 'inside' haskell you can work fine with unicod
08:58:04 <fasta> Every X time some guy comes up: "hey, we need some more bits".
08:58:14 <quicksilver> dr_strangelove: it's only 'at the edges': when you want to write to a file or a handle (or read from) that you have a problem
08:58:14 <sjanssen> fasta: why would you need a 'big char'?  Char already supports the whole Unicode range
08:58:21 <fasta> That's just insane. Maybe that's history now.
08:58:31 <ihope> Might the Unicode range get bigger?
08:58:31 <quicksilver> dr_strangelove: then you need to use a UTF8 enc/decoding function
08:58:45 <fasta> sjanssen: my point is that the unicode range might get larger.
08:58:59 <quicksilver> 4 billion chars ought to be enough for anyone
08:59:16 <ihope> Mostly true, quicksilver.
08:59:17 <sjanssen> fasta: this is a really fundamental change -- it'll require compiler support anyway
08:59:46 <sjanssen> you don't want programmers construction the code point 2^64.  What does it mean?
09:00:24 <sjanssen> I do agree that implementations of String and the like need to avoid leaking representation details
09:01:08 <fasta> sjanssen: it means the code point 2^64 which might not have a glyph or whatever it's called associated with it. (e.g. a standard "not defined glyph")
09:01:14 <Saizan> dr_strangelove: so you'll need to decode your uft-8 String from the webform to an Unicode one, unless the web library/framework does it for you
09:01:31 <Saizan> i think we shoudl represent encodings int eh type system by default :)
09:01:41 <sjanssen> fasta: what's the point?  None of the fonts can render it, none of the encodings can represent it
09:02:36 <fasta> sjanssen: my only point is related to the "big chars", in that it abstracts over the number of bits.
09:02:51 <dr_strangelove> Saizan: what do you mean by a unicode one? ucs-16?
09:02:57 <Bourbaki> WOW!
09:03:03 <Bourbaki> dr_strangelove : i always wanted to meet you :)
09:03:22 <dr_strangelove> yeah, here I am
09:03:31 <dr_strangelove> :)
09:03:35 <whaleofconfusion> are you worrying?
09:09:31 <quicksilver> dr_strangelove: no, true unicode number
09:09:41 <quicksilver> dr_strangelove: or whatever the correct jargon is for that
09:09:58 <sjanssen> dr_strangelove, quicksilver: code point
09:10:02 <quicksilver> dr_strangelove: 'toEnum' in Char doesn't give you access to a particular encoding but to the underlying code points
09:10:06 <quicksilver> thanks sjanssen :)
09:10:17 <quicksilver> there are a couple of UTF8 -> Char libs around
09:10:21 <quicksilver> is one called CompactString?
09:10:24 <quicksilver> or am I mixing that up
09:10:49 <sjanssen> I'm not sure if it does UTF8 -> Char conversion
09:11:04 <sjanssen> it's a ByteString-like lib that can hold any Char
09:12:03 <quicksilver> sjanssen: it's parametric by encoding
09:12:09 <quicksilver> sjanssen: and one of the encodings it offers is UTF8
09:12:17 <quicksilver> sjanssen: http://twan.home.fmf.nl/compact-string/doc/html/Data-CompactString.html#t%3AEncoding
09:12:20 <lambdabot> http://tinyurl.com/2993hq
09:12:41 <quicksilver> twanvl: that's your code, perhaps?
09:12:51 <sjanssen> ah yes, encode and decode
09:13:15 <dr_strangelove> thanks, I'll try them
09:14:47 <twanvl> quicksilver: Yes, that is mine
09:20:29 <thruspa> \quit
09:24:13 <quicksilver> twanvl: is it a good choice for UTF8 -> [Char] conversion?
09:24:46 <twanvl> It is not really meant to be used with lists
09:27:29 <Saizan> would it be more efficient to have ByteStrings instead of a Strings in a DBMS interface?
09:27:45 <quicksilver> you recommend just using CompactString itself, basically?
09:28:01 <quicksilver> Saizan: yes, although it only matters if that turns out to be a critical path
09:28:41 <quicksilver> twanvl: what internal encoding does compactstring use?
09:29:07 <twanvl> It can use any encoding for which there is an Encoding instance
09:31:05 <quicksilver> twanvl: but if I call 'decode'
09:31:06 <quicksilver> oh, I see
09:31:08 <CosmicRay> anyone here going to be at oscon?
09:31:17 <quicksilver> decode takes *two* encoding parameters
09:31:30 <quicksilver> the encoding in the bytestring, and the encoding in the compactstring
09:34:45 <quicksilver> twanvl: is it stable?
09:35:55 <twanvl> Not really, although I doubt the interface will change much. It needs to be updated for the new bytestring version (using stream fusion) when it is out. Also, I have not tested the performance, so that may suck.
09:37:08 <Saizan> do you plan on providing a lazy version too?
09:37:26 <Saizan> *to privide
09:38:04 <twanvl> lazy bytestrings are tricky, because a single encoded char can be spread out over multiple chunks
09:39:30 <Saizan> right..
09:40:07 <quicksilver> twanvl: I don't actually care about laziness
09:40:15 <quicksilver> twanvl: or performance
09:40:15 <quicksilver> :)
09:40:19 <quicksilver> twanvl: I just want something that works
09:40:38 <quicksilver> although, FWIW, the split over chunks this is not too hard
09:40:47 <quicksilver> you just make a little 'mini-chunk' around the boundary to fix it up
09:40:59 <quicksilver> that doesn't change anythings asymptotic complexity
09:41:04 <quicksilver> at most it doubles your spine length
09:41:33 <twanvl> Yes, it should be possible to do.
09:42:04 <quicksilver> But I do want to be able to read/write UTF8 strings
09:42:09 <quicksilver> and still 'understand' them :)
09:42:20 <twanvl> Do you use ByteStrings or Strings?
09:43:04 <quicksilver> Well, I'm talking about a few different projects
09:43:06 <quicksilver> so, a mixture
09:43:10 <quicksilver> I'm familiar with both, though
09:43:22 <bos> CosmicRay: i'll probably be at oscon. you?
10:20:30 <shapr> How do you not a Maybe?
10:20:46 <shapr> I want to use catchJust to catch everything except for asyncExceptions.
10:23:36 <quicksilver> nominolo: it seems my long spiel killed the thread, anyhow :)
10:26:37 <quicksilver>  :t \e -> maybe (Just e) (const Nothing)  (asyncExceptions e)
10:26:39 <EvilTerran> \handler pred exn -> maybe (handler exn) (const Nothing) (pred exn) -- how's this, shapr?
10:26:45 <quicksilver> :t \e -> maybe (Just e) (const Nothing)  (asyncExceptions e)
10:26:50 <lambdabot> Not in scope: `asyncExceptions'
10:26:51 <EvilTerran> heh
10:26:54 <quicksilver> shapr: like that, I think
10:27:32 <quicksilver> :)
10:30:19 <nominolo> quicksilver: just be patient
10:31:02 <quicksilver> nominolo: I lack patience, I'm afraid :)
10:38:18 <quicksilver> @tell nomeata I'm afraid your version might contain a race condition. If a second 'signal' comes along before the first has been 'consumed' by all its listeners, then its 'Put' will 'split open' a listener readMVar. That listener will deadlock.
10:38:19 <lambdabot> Consider it noted.
10:43:46 <mdmkolbe|work> where is the build bot?
10:44:01 <mdmkolbe|work> I mean the reports about building status
10:47:04 <Saizan> http://darcs.haskell.org/buildbot/head/
10:47:06 <lambdabot> Title: BuildBot: GHC
10:47:26 <mdmkolbe|work> thx
10:47:45 <mdmkolbe|work> @where+ buildbot http://darcs.haskell.org/buildbot/head/
10:47:45 <lambdabot> Done.
10:50:20 <Syzygy-> Hmmmm. The build failure at Mnemosyne... Is that due to bad code or due to bad build environment?
10:51:05 <Syzygy-> It seems to fail across the board, so I'm going to guess bad code.
10:56:03 <newsham> question: I already have ghc6.6.1 installed, and I want to build the bin from src, is there a quick way to do this that skips some of the steps (ie. avoids building a bootstrap phase)?
10:58:01 <mdmkolbe|work> newsham: you basically want to build stage2 without building stage1?
10:58:27 <newsham> i imagine something like that.  what i would like to be able to do is a new "make install" because I messed something up, and i already deleted my old build tree :)
10:58:33 <newsham> (also I forgot to build the extra-libs)
10:58:58 <newsham> so i'd like to do the minimal amount of work to get this built quickly
10:59:01 <mdmkolbe|work> newsham: ouch
10:59:33 <edwardk> @paste
10:59:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:59:34 <mdmkolbe|work> newsham: if you can give up GHCi and template haskell you can build just stage1 (you can run that in-place, but I'm not sure if you can install that)
11:00:07 <hpaste>  edwardk pasted "can someone think of a good variable supply/way to implement Subst?" at http://hpaste.org/40
11:00:33 <newsham> ghci important.  i guess i'll just suck it up
11:01:20 <edwardk> wanted to see if a dependently typed lambda calculus could be done cleanly in the type system, btw- that will probably not compile
11:03:47 <roconnor> edwardk: I just dropped in, but don't use named variables?
11:04:11 <edwardk> i was thinking about doing this HOAS like i was doing before
11:04:26 <edwardk> i just haven't figured out how to do that given the lack of 'functions' in the type level in haskell
11:04:40 <edwardk> well, lack of ones i can really pass around
11:04:48 <roconnor> used debruijn syntax at the type level.
11:04:52 <edwardk> yeah
11:04:58 <edwardk> thats what i was thinking about
11:05:10 <edwardk> as an alternative
11:05:15 <edwardk> just blech ;)
11:05:56 <edwardk> debruijn it is i guess
11:06:13 <hpaste>  roconnor annotated "can someone think of a good variable supply/way to implement Subst?" with "lambda-bar-mu-mutilde" at http://hpaste.org/40#a1
11:06:39 <pitecus> What are the guideline for when to use the lazy versus strict state monad?
11:06:43 <Syzygy-> Bah.
11:06:51 <Syzygy-> My terminal can't write mu-tilde.
11:06:53 <edwardk> neat, reading
11:06:56 <Syzygy-> ~µ  << see?
11:07:18 <roconnor> edwardk: this is a bit more complicated that the lambda calculus (but simpler because of no dependent types)
11:07:29 <roconnor> but I want to point out what I do
11:07:38 <roconnor> VVar :: Value (t,x) g t
11:07:40 <edwardk> yeah
11:07:44 <opqdonut> Syzygy-: of course, it's not in any charset (bar unicode)
11:07:47 <roconnor> See here, I use the pair (t,x)
11:08:02 <edwardk> without dependent types this is easy ;)
11:08:04 <Syzygy-> opqdonut: I can be annoyed by it anyway, can't I? :)
11:08:04 <roconnor> this is the stack of types of variable
11:08:10 <opqdonut> Syzygy-: of course :)
11:08:20 <edwardk> with them i have to be able to evaluate terms
11:08:22 <roconnor> VVar is the variable of the top of the stack
11:08:40 <roconnor> Succ removes a variable from the stack (so that it can no longer be reference)
11:08:46 <roconnor> there are no explict names
11:08:58 <mdmkolbe|work> pitecus: in most cases you'll want lazyness unless you have a performance problem. (just import e.g. Control.Monad.State and the default lazy vs strict will be used)
11:08:59 <roconnor> just a location in the stack of open lambdas
11:09:10 <roconnor> Lambda :: Value (a,x) g b -> Value x g (a -> b)
11:09:22 <roconnor> As you ca see, Lambda adds a new variable onto the stack
11:09:23 <edwardk> yeah
11:09:49 <roconnor> In this case I am using GADTs and haskell's type system to enforce type correctness for the simply typed lambda calculus
11:09:56 <roconnor> but you can get rid of that safety
11:10:03 <roconnor> and use your own data type for types
11:10:04 <pitecus> mdmkolbe|work, i mean i'd like to know if what cases the lazy state monad will cause stack overflow
11:10:05 <roconnor> I think
11:10:09 <edwardk> my correctness is coming from Judge
11:10:27 <roconnor> but I think the idea of using a stack of types is still usefull
11:10:41 <pitecus> i feel kind of dumb just changing lots of random things to strict whenever i get a stack overlow
11:11:03 <edwardk> yeah
11:11:36 <roconnor> edwardk: Um, how do you allow for converability?
11:13:31 <edwardk> well, this was just a toy
11:13:35 <edwardk> its pretty broken ;)
11:13:35 <roconnor> ah
11:14:02 <edwardk> i just heard the notion of using judgments as a GADT an hour or so ago, and thought i'd give it a shot
11:14:23 <edwardk> this is ugly enough i'll probably go back to HOAS
11:14:23 <roconnor> :)
11:14:32 <roconnor> bleh, HOAS
11:14:52 <roconnor> you can also use nominal logic and named variables
11:15:02 <roconnor> that seems like another promising way to go
11:15:57 <roconnor> you need a function fresh : [String] -> String
11:16:03 <roconnor> or whatever type you use for names
11:16:15 <edwardk> well, i use something like that when i prettyprint the HOAS rep
11:16:30 <edwardk> or when i convert it down to first order
11:16:37 <roconnor> crossing your fingers that you don't have exotic terms ;)
11:16:41 <edwardk> which i currently do to zip
11:17:07 <edwardk> stole stephanie weirich's trick to avoid them. parametricity forces the absence of exotic terms
11:17:14 <edwardk> only one thats left is 'bottom'
11:17:19 <edwardk> and if i have that i have bigger problems ;)
11:17:21 <shapr> Cars suck. They cost way too much money. I'd rather pay $1k or even $5k a year for a quality nationwide train system.
11:17:22 <roconnor> oh
11:17:26 <roconnor> I'd like to see how to do that.
11:17:51 <MarcWebe1> Which functions would you use to access single bytes from a memory buffer (ForeignPtr ) ? Recently I was surprised noticing that the poke functions to write 4byte Blocks.
11:17:57 <edwardk> http://comonad.com/paste/1 ... http://comonad.com/paste/4 or so
11:18:14 <sjanssen> MarcWebe1: you're using the wrong poke, then
11:18:18 <edwardk> from when we were talking about it on ##logic earlier
11:18:39 <edwardk> xmap builds up a fegaras/sheard catamorphism, which can handle the negatively positioned terms
11:19:04 <sjanssen> MarcWebe1: poke ptr (0 :: Word8), will write a single byte
11:19:27 <roconnor> edwardk: ah,
11:19:33 <edwardk> any attempt to abuse 'place' or inspect the value forces the polymorphic argument to take a specific value
11:19:46 <edwardk> which then rules out its assignment as a (forall a. Exp a)
11:19:56 <edwardk> clean, no real mess
11:20:24 <edwardk> rewrite transformations that need multiple alternatives based on the type of their children as a catamorphism that returns a record of functions to apply. laziness saves you extraneous effort
11:20:31 <roconnor> must make pattern matching more difficult :)
11:20:34 <edwardk> er based on the constructor of
11:21:30 <edwardk> http://comonad.com/paste/3 shows a reduction to first-order terms
11:22:17 <roconnor> okay, that's pretty damn clever
11:22:37 <edwardk> stole the trick, but it makes a nice representation
11:22:51 <edwardk> so what i'm working on for it now is a catamorphism that returns a monadic zipper that can be used to walk around in the terms
11:23:21 <edwardk> which uses those monadic actions returned in the record to move in and out of terms
11:23:50 <edwardk> because having the first-order zipper like i have right now is almost useless
11:24:18 <edwardk> but it'd be REALLY nice to just be able to zip to a point and start beta reducing by applying
11:24:24 <hpaste>  (anonymous) pasted "xorg.log" at http://hpaste.org/41
11:24:40 <MarcWebe1> sjanssen: I think I've tried pokeByteOff the first time. Thanks
11:25:57 <edwardk> if i can get the zipper right, then even if i can't figure out a nice clean catamorphism for something i'll be able to do it with a state monadic zipper
11:26:26 <edwardk> type checking is another catamorphism, etc. so my lint pass is cheap
11:37:11 <MarcWebe1> When using mallocArray will the pointer be freed automatically or do I have to call reallocArray 0 ?
11:37:30 <sjanssen> MarcWebe1: use free
11:37:33 <sjanssen> @hoogle free
11:37:34 <lambdabot> Foreign.Marshal.Alloc.free :: Ptr a -> IO ()
11:37:34 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
11:37:34 <lambdabot> Foreign.StablePtr.freeStablePtr :: StablePtr a -> IO ()
11:42:03 <TomMD> Has anyone here used Catch (as in, Neils tool, not catching exceptions)?
11:42:11 <Procyon> @seen chessguy
11:42:11 <lambdabot> I saw chessguy leaving #haskell and #haskell-overflow 18h 17m 9s ago, and .
11:42:15 <Procyon> @seen chessguy_work
11:42:15 <lambdabot> I saw chessguy_work leaving #haskell, #xmonad, #darcs, #haskell-soc and #haskell-overflow 21h 9m 48s ago, and .
11:57:04 <yetAnotherOne> > 0 / 0
11:57:06 <lambdabot>  NaN
12:00:03 <TomMD> > let f = forkIO f in f
12:00:04 <lambdabot>   Not in scope: `forkIO'
12:01:57 <byorgey> whaleofconfusion: I notice you're at UMass Amherst... I'm looking at grad schools and was just wondering what your experience there is like?
12:02:04 <pitecus> where can one browse standard libraries sources?
12:02:24 <sjanssen> pitecus: darcs.haskell.org/packages
12:02:32 <pitecus> thanks
12:03:23 <yghor> hey
12:03:28 <sjanssen> hi
12:03:50 <byorgey> hi yghor
12:04:03 <yghor> is there any channel for xmonad?
12:04:07 <sjanssen> #xmonad
12:04:22 <yghor> i dont know much, actually i know shit about haskell, but i wanted to try compiling xmonad
12:04:25 <yghor> oh thanks
12:05:08 <yghor> ill just grab some lunch and get back here to build it, shouldnt be hard, right?
12:05:25 <sjanssen> yes, it should be easy
12:05:34 <yghor> sjanssen: thanks!
12:07:36 <byorgey> ...guess whaleofconfusion doesn't want to talk about it =)
12:08:33 <pitecus> is there any reason why IntMap doesnt have an instance for Traversable?
12:08:37 <Vulpyne> http://hpaste.org/42 -- How horrible is this from an efficiency standpoint? (It's meant to parse SIP packets, which are pretty much like HTTP requests/responses.)
12:11:39 <sjanssen> Vulpyne: you might want to lift the wanted variable to the top level
12:11:56 <sjanssen> just to make sure those strings are packed once, then shared
12:11:59 <Vulpyne> That'll keep it from calling the B.pack multiple times?
12:12:09 <Vulpyne> Thanks. That was one of the main things I was wondering about.
12:12:27 <sjanssen> GHC probably does that already with -O, but it doesn't hurt to be explicit
12:13:44 <Vulpyne> I see.
12:15:28 <Vulpyne> That seemed like it was the main possibility of inefficiency?
12:15:54 * EvilTerran quite likes ML's "local <declerations> in <declerations> end" decleration for that sort of thing
12:17:25 <EvilTerran> i guess it was more necessary in ML, because side-effects and what-have-you could make working out what could be cached between calls a bit tricky
12:27:32 <roconnor> so as far as I can tell ocaml requires all recusive calls to have the same parametric parameters :(
12:37:47 <pitecus> Is there a function which would convert  (a -> m t) to  (a,b) -> m (t,b)?
12:41:38 <kpreid> pitecus: runKleisli . first . Kleisli
12:41:46 <kpreid> pitecus: (all names from Control.Arrow)
12:42:05 <pitecus> kpreid, cool thanks
12:42:48 <kpreid> or \m (a,b) -> fmap (\a' -> (a,b)) (m a)
12:43:44 <kpreid> actually, first is sufficient by itself
12:43:53 <kpreid> er, no
12:43:55 * EvilTerran notes that ?djinn doesn't seem to like "m a"
12:44:07 <kpreid> just first would produce (m t, b), not m (t, b)
12:50:18 <pitecus> aha
12:56:20 <Heffalump> it's the weekend!
12:56:45 <augustss> yes, but which weekend?
12:57:18 <monochrom> both weekends
12:59:09 <Heffalump> this weekend!
13:00:52 <DRMacIver> A long weekend even. :)
13:00:59 <Heffalump> indeed.
13:01:04 * Heffalump is a bit short of sleep
13:01:27 <EvilTerran> ?type uncurry $ flip $ fmap . flip (,)
13:01:29 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => (f a, a1) -> f (a, a1)
13:02:39 <kpreid> ?unpl uncurry $ flip $ fmap . flip (,)
13:02:39 <lambdabot> (uncurry (\ b c -> fmap (\ f -> (,) f c) b))
13:03:41 * kpreid wonders if unpl should expand uncurry
13:04:45 <Heffalump> is it a direct inverse of pl?
13:05:37 <kpreid> well, right now it does the best it can to undo what pl does
13:05:55 <kpreid> pl doesn't use uncurry, so this would be an expansion of its activities
13:06:28 <kpreid> ?pl \f (a,b) -> f a b
13:06:28 <lambdabot> (`ap` snd) . (. fst)
13:06:35 <EvilTerran> oh eris
13:06:39 <kpreid> @src uncurry
13:06:39 <lambdabot> uncurry f p = f (fst p) (snd p)
13:06:51 <kpreid> huh
13:07:04 <kpreid> ?pl \f p -> f (fst p) (snd p)
13:07:04 <lambdabot> (`ap` snd) . (. fst)
13:07:08 <kpreid> yup
13:09:09 <Heffalump> eris?
13:10:02 * Heffalump realises that he's been propagating incorrect definitions of uncurry to unsuspecting modellers :-)
13:10:13 <kpreid> Oh?
13:10:41 <Heffalump> uncurry f (x,y) = f x y
13:10:52 <Heffalump> which is a bit too strict
13:11:18 <edwardk> ah good point
13:11:20 <EvilTerran> should that have a twiddle in the pattern or sth?
13:11:22 <edwardk> didn't notice that before
13:11:22 <monochrom> It's ok.
13:11:36 <Heffalump> oh, a twiddle would work too
13:11:37 <edwardk> uncurry f ~(x,y) = f x y
13:11:38 <edwardk> yeah
13:11:44 <monochrom> That works.
13:12:01 <Heffalump> actually, if I'd realised, I'd still have misled them, just deliberately rather than accidentally :-)
13:12:04 <mdmkolbe|work> @seen dons
13:12:04 <lambdabot> dons is in #haskell, #haskell-overflow, #ghc, #haskell-soc and #xmonad. I last heard dons speak 4h 56m 6s ago.
13:12:11 <edwardk> heh
13:12:31 <ptolomy> I'm a little ashamed that http://developers.slashdot.org/comments.pl?sid=142494&threshold=5&commentsort=0&mode=thread&cid=11942528 still frustrates me.
13:12:34 <lambdabot> Title: OCaml vs. C++ for Dynamic Programming, http://tinyurl.com/ypgmao
13:12:56 <monochrom> If they haven't thought through lazy evaluation (if they even assume eager evaluation) it's all ok.
13:13:19 <Heffalump> I don't really tell them about how pattern matching works anyway
13:13:29 <edwardk> bashing lists? a quick reply pointing out fusion rules would nip that in the bud
13:13:32 <Heffalump> and certainly not the concept of a _|_
13:13:45 <kpreid> How bad would it be if a pattern for which there's no next choice is always irrefutable?
13:14:40 <monochrom> List are designed for performance. Prepending is cheaper than arrays.
13:14:56 <Heffalump> it'd make multi-clause function definitions even less modular than they already are
13:15:06 <Heffalump> and it would make it impossible to force strictness when you wanted to
13:15:17 <Heffalump> and it'd be a nasty ugly hack :-)
13:15:18 <monochrom> But much dynamic programming benefits from arrays.
13:16:26 <Heffalump> that poster seems to be concluding that noone has written a proper implementation of Haskell (where "proper" = fast enough) because (s)he can't get GHC on his/her platform..
13:22:44 <EvilTerran> ?hoogle m (a -> b) -> a -> m b
13:22:44 <lambdabot> Prelude.asTypeOf :: a -> a -> a
13:22:45 <lambdabot> Prelude.const :: a -> b -> a
13:22:45 <lambdabot> Prelude.seq :: a -> b -> b
13:24:27 <mdmkolbe|work> Is Yi still implemented in terms of hs-plugins?  Has hs-plugins been superceeded by anything?  (Not that I'm suggesting it should, I just want to know what the state of the art it)
13:24:40 <Heffalump> hs-plugins hasn't been superceded, as far as I know
13:25:30 <waern> people seem to rather use the ghc-api for plugin stuff
13:25:30 <lambdabot> waern: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:25:32 <sjanssen> mdmkolbe|work: I believe Yi uses a custom solution using ghc-api
13:26:13 <mdmkolbe|work> and lambdabot? is that on ghc-api or hs-plugins?
13:26:54 <Saizan> hs-plugins
13:27:05 <Saizan> but i think that you can't use it with them :)
13:29:23 <MarcWebe1> Is there yet a useful lib to create pdf files?
13:29:25 <Heffalump> the plan is to make hs-plugins a thin layer on ghc-api, isn't it?
13:35:29 <hpaste>  mdmkolbe|work pasted "A bug or am I doing it wrong?" at http://hpaste.org/43
13:36:37 <ptolomy> it asks you to report it< i say go for it.
13:36:39 <Heffalump> seems unlikely you're doing it wrong..
13:36:41 <monochrom> Apparently "break" really means break. :)
13:36:49 <Heffalump> :-)
13:37:33 <EvilTerran> it shouldn't provide that sort of message even if you are doing it wrong
13:40:56 <Heffalump> you can provoke similar messages, and segfaults from compiled programs, with recompilation problems
13:41:10 <Heffalump> (where some things weren't recompiled when they should have been)
13:41:46 <HairyDude> @djinn (a -> b) -> a
13:41:46 <lambdabot> -- f cannot be realized.
13:41:54 <HairyDude> oops, wrong one
13:42:00 <HairyDude> @djinn (a,b) -> a
13:42:00 <lambdabot> f (a, _) = a
13:42:04 <HairyDude> now that's clever.
13:42:25 <mdmkolbe|work> @djinn a -> [a] -> a
13:42:25 <lambdabot> f a _ = a
13:42:31 <olegfink> lambdabot: version
13:42:37 <mdmkolbe|work> HairyDude: just don't feed it a list and it's clever
13:42:38 <olegfink> well
13:42:40 <Heffalump> @djinn ((a -> ()) -> ()) -> a
13:42:40 <lambdabot> -- f cannot be realized.
13:42:47 <Heffalump> @djinn a -> ((a -> ()) -> ())
13:42:47 <lambdabot> f a b = b a
13:43:08 <mdmkolbe|work> @version
13:43:08 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
13:43:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:43:15 <olegfink> okay
13:43:57 <sjanssen> @type (\a b -> b a) :: a -> ((a -> ()) -> ())
13:44:02 <lambdabot> a -> ((a -> ()) -> ()) :: forall a. a -> (a -> ()) -> ()
13:44:28 <sjanssen> oh, I see
13:45:16 <Saizan> ?
13:46:15 <sjanssen> Saizan: I was a bit skeptical of djinn's answer.  But now I realize I was reading the parens incorrectly
13:46:53 <opqdonut> @. pl djinn ((a -> ()) -> ()) -> a
13:46:53 <lambdabot> (line 1, column 1):
13:46:53 <lambdabot> unexpected "-"
13:46:53 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
13:47:01 <opqdonut> hrmm
13:47:18 <opqdonut> @pl f a b = b a
13:47:19 <lambdabot> f = flip id
13:47:29 <opqdonut> yes, yes
13:48:46 <hpaste>  pitecus pasted "fundeps" at http://hpaste.org/44
13:49:14 <pitecus> GHC is complaining about  Functional dependencies conflict between instance declarations
13:49:26 <pitecus> When I try to compile smth like what I pasted
13:49:38 <pitecus> Any idea if it can be done?
13:50:13 <mauke> v includes Double
13:50:27 <mauke> this looks overlapping
13:50:43 <sjanssen> pitecus: this program might require -fallow-overlapping-instances (not generally recommended)
13:51:04 <pitecus> mauke, sjanssen, why not recommened?
13:51:54 <Heffalump> it means there's not one "right" answer to which instance to use, if you consider them separately
13:52:05 <Heffalump> you end up with a not-very-compositional "best match" rule
13:52:09 <sjanssen> pitecus: it becomes hard to predict which instance will be chosen
13:52:34 <EvilTerran> i'd've expected this to be possible with a more agressive fundep
13:52:37 <pitecus> Hm Even with undecidable instance i get " Functional dependencies conflict between instance declarations:
13:52:37 <pitecus>       instance [overlap ok]"
13:52:49 <Heffalump> I don't think a fundep will help avoid overlapping instances
13:52:54 <Heffalump> but your fundep is just wrong
13:52:54 <pitecus> EvilTerran, and suggestions?
13:53:00 <Heffalump> key val doesn't imply index
13:53:06 <Heffalump> for k Double, there are two possible indexes
13:53:11 <Heffalump> (k, Double), and k.
13:53:18 <pitecus> Heffalump, i see
13:53:34 <ptolomy> It seems common for folks to say, "High level language X is neat, but if you actually use it in the way that the demos of its elegance show, it is impractically slow. You end up having to write low-level code in that language if you have exact low-level things you want it to do." That argument against languages seems crapful to me, unless they are responding to someone suggesting that they...
13:53:34 <Heffalump> bring on associated types
13:53:35 <ptolomy> ...rewrite all of their inner loops in clean-but-naive HLL code without considering performance.
13:53:40 * ptolomy doesn't know why he felt like saying that.
13:53:45 <pitecus> is there some wahy of saying, anything other than a Double??
13:53:51 <Heffalump> pitecus: no
13:54:02 <Heffalump> unless you make a type class IsNotDouble and write lots of instances for it
13:54:17 <pitecus> Hmm
13:54:20 <Heffalump> and even then they'll be a bit unpleasant for the type checker to handle
13:54:33 <Heffalump> cos it won't be sure that Double isn't an instance of IsNotDouble until it tries
13:54:56 <monochrom> What would necessitate an "every type except Double"?
13:55:01 <pitecus> So basically there is no sane way of doing what im trying to do?
13:55:39 <monochrom> I mean I don't even see such a thing in untyped languages.
13:55:43 <EvilTerran> er... coll -> key, val, index?
13:56:07 <EvilTerran> (i don't know what the syntax is)
13:56:46 <_dolio> monochrom: Oleg's done something like 'every type that isn't a function' so 'every type that isn't Double' can't be that hard. :)
13:56:58 <EvilTerran> it seems to me that your collection type would itself have to be parameterised with your other three types, so those types should be able to depend on it
13:57:59 <EvilTerran> does that make sense?
13:58:17 <Saizan> EvilTerran: v still includes Double though, so for (Map k Double) you could still have k or (k,v)
13:58:18 <EvilTerran> or am i confused about what you're trying to do?
13:58:45 <Heffalump> wi EvilTerran
13:58:49 <Heffalump> ahem
13:59:04 * Heffalump bashes his / key
13:59:12 <pitecus> ok so what i want to generate is this feature set thing (Map Int Double) for a few types of maps. If the values are Doubles, leave them in, otherwise take convert the key-value pair and treat that as a new key
13:59:32 <Heffalump> I don't follow
13:59:41 <Heffalump> but does Scrap Your Boilerplate help?
14:00:20 <pitecus> Dont know, I need some way of distinguishing whether the values in a Map are doubles or not...
14:01:52 <mdmkolbe|work> pitecus: forall a. Either Double a
14:01:55 <mdmkolbe|work> ?
14:02:04 <Saizan> you need only map?
14:02:43 <pitecus> Saizan, ya Map should be enough...
14:02:53 <EvilTerran> > typeOf (undefined :: Double) == typeOf 1.0
14:02:54 <lambdabot>  True
14:02:54 <pitecus> mdmkolbe|work, i dont get it?
14:02:57 <EvilTerran> > typeOf (undefined :: Double) == typeOf True
14:02:58 <lambdabot>  False
14:03:20 <Saizan> if you can do what you want with a single parameter type class you can almost safely use overlapping instances
14:03:21 <pitecus> EvilTerran, let me try that
14:03:32 <EvilTerran> imposes a Typeable constraint, but it should do what you want. albeit in a rather hackish way.
14:04:17 <mdmkolbe|work> pitecus: what is the high level objective?
14:04:39 <EvilTerran> it's funny, actually. i was wondering earlier if it would be possible to construct a Not typeclass with fundeps or sth
14:05:46 <pitecus> mdmkolbe|work, If I have a Map of doubles I know those are real-valued feature weights, otherwise i want to binarize the features, that is use the key-value pair and the new value feature with weight 1.0
14:07:18 <Heffalump> I think you should redesign your types to make that knowledge a bit more explicit
14:07:53 <EvilTerran> class Not c a; instance (c a) => Not (Not c) a; but then i get stuck
14:08:18 <mdmkolbe|work> pitecus: ok, one sure method would be to not use a class at all and instead pass around the toFeatureSet function but that might get laborious
14:08:42 <pitecus> aha
14:11:44 <mdmkolbe|work> pitecus: I think you want "| coll -> key value index"
14:12:07 <pitecus> mdmkolbe|work, i think i tried that
14:12:12 <pitecus> let me try again
14:12:22 <Heffalump> EvilTerran: so Not is a type constructor too?
14:12:51 <Heffalump> I can't see how it'd be possible, the type class system is based on positive instances, not negative ones
14:13:04 <Saizan> also c in (c a) is intended as a class variable?
14:13:08 <Heffalump> but perhaps there's a way to Oleg it
14:13:19 <EvilTerran> Heffalump, yeah, (Not c) would be the class of everything that doesn't have class c
14:13:27 <EvilTerran> Saizan, yes; does that work?
14:13:48 <Saizan> EvilTerran: no
14:13:59 <mdmkolbe|work> EvilTerran: try using constructive logic
14:14:01 <EvilTerran> bah. oh well, it was an interesting thought.
14:14:05 <pitecus> mdmkolbe|work, i get a conflict
14:14:13 <pitecus> I think I ll give up on this
14:14:14 <mdmkolbe|work> pitecus: what is the conflict?
14:14:24 <pitecus>  Functional dependencies conflict between instance declarations
14:14:28 <pitecus> etc
14:14:40 <pitecus> between the two instances
14:14:41 <Saizan> pitecus: post on the mailing list with a title that would catch oleg attention :)
14:14:44 <mdmkolbe|work> pitecus: paste the error I want to see which instances
14:15:07 <pitecus>     Functional dependencies conflict between instance declarations:
14:15:07 <pitecus>       instance [overlap ok] FeatureSet (Map.Map k Double) k Double k
14:15:08 <pitecus>       instance [overlap ok] FeatureSet (Map.Map k v) k v (k, v)
14:15:34 <EvilTerran> mdmkolbe|work, ccould you elaborate slightly?
14:16:05 <mdmkolbe|work> pitecus: right, does it give the same error without the fun-deps but with the -fallow-overlaped-instances?
14:16:24 <pitecus> Saizan, Hmm maybe I should stick to code I can understand, bringing oleg in wouldt be such a good idea ;-)
14:17:13 <pitecus> mdmkolbe|work, Witho fundeps the declarations dont give an error
14:17:25 <pitecus> but I get one when i try to sue the method
14:17:29 <pitecus> use
14:17:42 <Saizan> pitecus: can you paste the body of the class?
14:18:21 <mdmkolbe|work> EvilTerran: a program is to it's type as a proof is to it's constructivist proof.  but in constructive logic, you can't get from (not not a) to (a).  But you can get from (not not not a) to (not a) and from (not not not not a) to (not not a).
14:18:47 <EvilTerran> o.ô
14:18:49 <mdmkolbe|work> EvilTerran: Of course there is the problem that we can't nest type classes but we can next data types
14:19:01 <pitecus> No instance for (FeatureSet (Map.Map Char t) key val index)
14:19:08 <pitecus> This is the error ai get
14:19:29 <mdmkolbe|work> EvilTerran: your objective is not to separate (not a) from (a), but you should aim to separate (not a) from (not not a)
14:19:40 <EvilTerran> right.
14:20:19 * EvilTerran thinks that having to declare class Is c a alongside class c a would be Good Enough
14:20:20 <Saizan> pitecus: that's because without fundeps it can't infer that key is Char and val is t
14:20:46 <hpaste>  pitecus annotated "fundeps" with "(no title)" at http://hpaste.org/44#a1
14:21:06 <pitecus> So I do need the fundeps but i cant make them work
14:25:14 <Saizan> so toFeatureSet :: coll -> State (Table index) (IntMap v) ?
14:25:42 <LordBrain> Anyone know, does Clean re-implement the IO monad using uniqueness types?
14:26:46 <pitecus> Saizan, actually the result type is alwasy (IntMap Double)
14:27:00 <EvilTerran> mdmkolbe|work, i think the problem with trying to use intuitionistic logic is that you can still use "a -> (~a -> b)" in that, and i don't see how to do that in typeclasses
14:28:14 <EvilTerran> pitecus, do key and val necessarily need to be parameters to this class?
14:29:04 <pitecus> EvilTerran, I dont know, but key needs the Ord constraint
14:30:06 <EvilTerran> why?
14:30:07 <mdmkolbe|work> EvilTerran: isn't that a restatement of excluded middle?
14:30:31 <pitecus> its the key in the Map
14:30:36 <mdmkolbe|work> EvilTerran: sorry not excluded middle
14:30:40 <EvilTerran> mdmkolbe|work, no, under intuitionistic you still can't have a & ~a
14:30:51 <EvilTerran> you just might not have a | ~a
14:31:54 * shapr hugs Lemmih
14:32:01 <EvilTerran> pitecus, surely this class doesn't need to worry about that?
14:32:22 <pitecus> hm
14:37:50 <mauke> w00t
14:37:51 <mauke>     My brain just exploded.
14:37:57 <mauke> does that mean I win?
14:38:05 <Binkley> you win a year's supply of turtle wax!
14:38:11 <Heffalump> I think many people have won.
14:38:38 <waern> any good reason why libraries don't come with Arbitrary for their datatypes instances included?
14:39:03 <Igloo> They'd have to depend on QuickCheck to do that
14:39:06 <waern> yep
14:39:14 <waern> is that so bad?
14:39:27 <Igloo> If you apply similar logic to other things then you end up with everything-depends-on-everything
14:39:38 <EvilTerran> circular dependencies woo!
14:39:40 <waern> I guess :)
14:39:57 <Binkley> with circular dependencies at least you have no loose ends
14:40:10 <monochrom> intuitionistic logic still asserts ~(a & ~a). It just misses out a|~a. You will also see that it omits some parts of de Morgan.
14:41:09 <monochrom> Wouldn't it be nice if Prelude depended on Quickcheck? :)
14:41:49 <waern> hehe
14:41:51 <EvilTerran> what about providing Foo.Bar.Arbitrary alongside Foo.Bar?
14:42:15 <EvilTerran> (where Foo.Bar doesn't depend on QuickCheck, but Foo.Bar.Arbitrary does)
14:42:32 <EvilTerran> you could even have Prelude.Arbitrary if you so desired
14:42:35 <Igloo> EvilTerran: Which package is Foo.Bar.Arbitrary in?
14:42:48 <waern> EvilTerran, and put Foo.Bar.Arbitrary in another package?
14:42:56 <EvilTerran> hm. well, i guess.
14:43:10 <wolverian> dependencies aren't a bad thing, sheesh.
14:43:20 <EvilTerran> we need fundeps for hackage :P
14:43:21 <monochrom> I think it's still useful for each library to provide several packages. The main package. Then a small package containing just "instance Arbitrary". Then a small package containing just "instance Data". etc.
14:43:34 <EvilTerran> well
14:43:35 <wolverian> you just need automatic dependency management and you're set.
14:43:49 <waern> wolverian: you can't have circular package dependencies
14:45:22 <waern> monochrom: that sounds like the current way to solve that
14:46:02 <wolverian> waern, who said you have to have circular dependencies?
14:46:39 <EvilTerran> :t curry $ uncurry (liftM2 (,)) . second return
14:46:41 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> b -> m (a1, b)
14:46:54 * EvilTerran has been playing with this problem for most of the evening :P
14:46:55 <monochrom> Ideally, every line of code is in its own package. :)
14:47:43 <monochrom> We would beat CPAN at least in the number of packages :)
14:49:30 <mdmkolbe|work> @pl curry $ uncurry (liftM2 (,)) . second return
14:49:30 <lambdabot> curry (uncurry (liftM2 (,)) . second return)
14:49:39 <mdmkolbe|work> @type second
14:49:41 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
14:49:57 <EvilTerran> ?src second
14:49:57 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:50:11 <mdmkolbe|work> @type liftM2 (,) . snd return
14:50:13 <lambdabot>     Couldn't match expected type `(a, b)'
14:50:13 <lambdabot>            against inferred type `a1 -> m a1'
14:50:28 <dolio> @src (->) second
14:50:28 <lambdabot> second f = id *** f
14:50:29 <mdmkolbe|work> @type ap
14:50:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:52:14 <mdmkolbe|work> @type \a b -> liftM2 (,) a (return b)
14:52:15 <mdmkolbe|work> @pl \a b -> liftM2 (,) a (return b)
14:52:15 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> a2 -> m (a1, a2)
14:52:16 <lambdabot> (. return) . liftM2 (,)
14:52:42 <dolio> ?pl \ma b -> ma >>= \a -> return (a, b)
14:52:42 <lambdabot> flip (fmap . flip (,))
14:52:42 <Saizan> ?type flip (liftM . (,))
14:52:44 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => m a1 -> a -> m (a, a1)
14:53:33 * Saizan is starting to think like pl, it's not good
14:53:34 <mdmkolbe|work> EvilTerran: after playing with the 'not' class I've come to the conclusion that there is no way to construct any negative knowlege in the class system, so it's not possible to get intuitionistic logic
14:53:44 <EvilTerran> oh well
14:53:46 <mdmkolbe|work> @unpl Saizan
14:53:46 <lambdabot> Saizan
14:54:27 <mdmkolbe|work> @unpl flip (fmap . flip (,))
14:54:27 <lambdabot> (\ b c -> fmap (\ f -> (,) f c) b)
15:01:54 <Binkley> @yow
15:01:55 <lambdabot> I want the presidency so bad I can already taste the hors d'oeuvres.
15:06:45 <Binkley> @quote
15:06:46 <lambdabot> adaptec says: [in documentation for their raid chipsets] We have a disclaimer because there may be corner cases
15:07:13 <davidL> > approxRational pi 0.0000001
15:07:14 <lambdabot>  75948%24175
15:08:08 <vali> are there any functional languages that have a performance similar to C concerning graphics programming (opengl)?
15:08:41 <nattfodd> ocaml, probably
15:08:51 <EvilTerran> i was under the impression that "ghc -O"ed haskell did a fairly respectable job of being speedy
15:08:59 <nattfodd> there's lablgl/lablglut which is a direct interface to GL
15:09:19 <nattfodd> and ocaml is supposed to have C++ order of magnitude in speed
15:10:19 <mdmkolbe|work> vali: any functionally library with an OpenGL interface will perform up to C speeds b/c the bottle neck is the GPU not the CPU (assuming standard disclamers)
15:10:36 <mdmkolbe|work> s/any functionally library/any functional language/
15:10:43 <monochrom> Disclaimer: I have no GPU, it's all software :)
15:11:45 <davidL> > isInfinite pi
15:11:46 <lambdabot>  False
15:11:54 <mdmkolbe|work> monochrom: mesa's need not apply
15:14:12 <lemao> I am having a hell of a time with trying to install GHC using Darwin ports. After I install it backspace in GHCi does not work. It seems to be readline related and I followed some directions I found on the internet without any success.
15:14:14 <lemao> Any ideas?
15:18:41 <Excedrin> does backspace work if you use cat?
15:19:48 <nominolo> > approxRational pi 0.001
15:19:52 <lambdabot>  201%64
15:19:58 <nominolo> > 22/7 - pi
15:19:59 <lambdabot>  1.2644892673496777e-3
15:20:09 <nominolo> ?
15:20:26 <nominolo> > approxRational pi 0.0015
15:20:27 <lambdabot>  22%7
15:21:12 <nominolo> @src approxRational
15:21:13 <lambdabot> Source not found. That's something I cannot allow to happen.
15:21:25 <nominolo> @yarr
15:21:25 <lambdabot> Prepare to be boarded!
15:23:12 <nominolo> @quote
15:23:12 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
15:23:39 <nominolo> @quote simon
15:23:39 <lambdabot> Cale says: It ought to be called simonPerformIO, and only used if your first name is Simon.
15:23:52 <nominolo> @quote peyton
15:23:53 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
15:23:53 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
15:23:53 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
15:30:09 <dmwit> ?quote
15:30:09 <lambdabot> I says: think a quote from Cylons of the Lambs would be most appropriate: 'Would you frak me? I'd frak me. I'd frak me hard.
15:30:23 <Binkley> @yow
15:30:24 <lambdabot> My mind is making ashtrays in Dayton ...
15:30:50 <dmwit> ?quote z
15:30:50 <lambdabot> dons says: the fuzzy cloud of experimental languages is the only thing beyond haskell
15:30:56 <dmwit> ?quote z
15:30:57 <lambdabot> LoganCapaldo says: <sorear> I am not having any luck converting Chris Kuklewicz :( <LoganCapaldo> Does he implement Typeable?
15:31:03 <dmwit> ?quote z
15:31:03 <lambdabot> glguy says: Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
15:33:01 <fourbissime> hi there. for my first small haskell app, I'd like to design a simple network communication protocol based on UDP messages. How can I do that ? I may be wrong, but the Network packet seems to be more oriented toward persistent, TCP connections ...
15:33:31 <TomMD> @doc Network.Socket
15:33:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
15:34:09 <newsham> ?paste
15:34:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:34:55 <monochrom> sendTo, recvFrom may be what you're looking for.
15:35:57 <TomMD> fourbissime: the above Network.Socket link is the typical method I use for accessing the normal 'C' routines used for networking.  I am rather unhappy with Haskell networking support, which is why I am looking at making a new library.
15:36:52 <nominolo> TomMD: what do you have in mind?
15:36:55 <fourbissime> ok.
15:40:16 <TomMD> nominolo: Mainly I want some basic (String -> IP),  (IP -> String), and more powerful access to raw sockets.  I suppose I should say that my 'new library' will likely be a higher level library that uses network6.  Although last time I used network6 it wasn't actually in a useful state - many patches have hit since then so I am looking at this now.
15:43:38 <TomMD> Expanding on "more powerful access to raw sockets".  I sometimes want to specify my own IP header or read certain values from IP headers, but Haskell doesn't have functions that return (IPv4Header, payload :: [Char]).
15:45:06 <MyCatVerbs> TomMD: that would be naughty. Plus you do *not* want it to return [Char], because those are (and may well in future versions become usable as) unicode code points. Byte string instead.
15:46:51 <mauke> what's the problem with storing bytes in Chars?
15:47:17 <drigz> mauke: because they can contain invalid values
15:47:19 <TomMD> MyCatVerbs: Actually, [Word8] is what I have, I shouldn't have typed Char.
15:47:26 <drigz> if you have Word8s, they are always valid
15:47:31 <MyCatVerbs> TomMD: Word8 is good. ^^
15:47:42 <mauke> drigz: huh?
15:47:56 <mauke> what values are invalid for Char?
15:47:59 <drigz> mauke: a Char can contain any unicode character
15:48:03 <mauke> yes
15:48:05 <drigz> > maxBound :: Char
15:48:06 <lambdabot>  '\1114111'
15:48:31 <drigz> which doesn't fit in a byte
15:48:38 <mauke> yeah, so?
15:48:38 <TomMD> mauke: 'Char' could (and I think 'should') be unicode.  Many people would see [Char] and assume each element contains 8 bits of the payload.
15:48:54 <mauke> TomMD: I agree with both statements
15:51:03 <nominolo> TomMD: make sure it's ByteString instead of [Char] or [Word8]
15:51:16 <drigz> mauke: so what does ['\1114111'] mean? ['\255'] or ['\16', '\255', '\255']?
15:51:21 <mauke> neither
15:51:40 <mauke> it means ['\1114111']
15:51:49 <MyCatVerbs> mauke: what if you want to build a library to convert raw bytes from some source into Chars by interpreting whichever utf-* or UCS-blah format the input data is in? ByteString->[Char] is a *much* saner datatype to give it than [Char]->[Char] because then you can use the type inferrer to make sure you didn't accidentally apply it twice.
15:52:20 <nominolo> TomMD: maybe you can get some inspiration from erlang.  it has very neat bit-level parsing.  this might be nice if you want to work on lower-level network protocols
15:52:38 <mauke> MyCatVerbs: but then you'd have to rewrite System.IO to return ByteStrings for all input operations
15:52:48 <MyCatVerbs> drigz: Char's are unicode code points. Unicode has a thirty one and a third bit space.
15:53:16 <nominolo> mauke: bytestrings use handle
15:53:19 <nominolo> *handles
15:53:21 <drigz> mauke: this is raw socket data, isn't it? why does it make sense to interpret it as a unicode string?
15:53:22 <nominolo> that's enough
15:53:28 <MyCatVerbs> mauke: nah, rewrite System.IO to interpret utf*/ucs* on things as it inputs them, with a unicode transformation being applied to the data as you slurp it.
15:54:01 <mauke> "interpret utf*" doesn't make sense
15:54:04 <monochrom> drigz: TomMD has changed it back to [Word8].
15:54:09 <mauke> the utfs are mutually incompatible
15:54:30 <MyCatVerbs> mauke: tag each handle with an encoding object.
15:54:44 <MyCatVerbs> hGetEncoding, hSetEncoding, etc.
15:55:20 <MyCatVerbs> Then you can also make it easy to support weird crap like ISO 8859 and unusual things like shift-JIS.
15:55:28 <mauke> MyCatVerbs: what if the underlying encoding doesn't support characters > 255?
15:55:29 <MyCatVerbs> s/weird/godawful/
15:55:32 <edwardk> i'm a little slow, 10 minutes to figure out that the reason i was getting a filename does not match module name error was because i had typed Simple.Zippper ... sigh
15:55:37 <mauke> IO exception?
15:55:42 <MyCatVerbs> mauke: then you throw an exception, I guess.
15:55:46 <monochrom> hahaha
15:56:04 <mauke> MyCatVerbs: that all sounds pretty sane
15:56:06 <MyCatVerbs> mauke: just leave output handles in utf8 mode by default.
15:56:21 <nominolo> edwardk: i was looking for a bug 3 hours, and it turned out that i just hadn't the file saved yet
15:56:34 <MyCatVerbs> mauke: cool, thanks. The really properly insane ones always go straight into my home directory =)
15:57:13 <nominolo> edwardk: (3 hours though, mainly because i didn't really try hard and just did something else instead)
16:00:22 <TomMD> nominolo, edwardk: I am glad to hear I am not alone in this.
16:02:50 <TomMD> Is the primary author of network6 here?
16:03:29 <george--> can someone please remind me how to set the environment variable for editor in linux? i have completely forgotten and :e isn't working in hugs without it
16:03:40 <Binkley> george--: the variable name is EDITOR
16:03:46 <Binkley> how to set it depends on your shell
16:03:53 <MyCatVerbs> george--: export EDITOR=blah in bourne shells
16:04:06 <TomMD> @karma george
16:04:07 <lambdabot> george has a karma of -4
16:04:08 <MyCatVerbs> george--: (since you almost definately have bash, that's the one you want to use)
16:04:21 <TomMD> lol george-- is harming the karma of george!
16:04:24 <monochrom> There is also VISUAL.
16:04:27 <MyCatVerbs> TomMD: oh go take a walk off the end of a piano :P
16:04:36 <george--> TomMD, this is pointed out daily ;)
16:04:46 <TomMD> Ohhhhh.  I love this issue.  I find it humorous.
16:05:01 <george--> thanks guys :) got it working
16:05:12 <MyCatVerbs> george--: spiffy.
16:11:32 <george--> what is wrong with:
16:11:57 <george--> > filter (>2 && <11) [1..20]
16:11:57 <lambdabot>  Parse error
16:12:03 <dmwit> You need parentheses.
16:12:10 <george--> e.g.?
16:12:11 <dmwit> > filter ((>2) && (<11)) [1..20]
16:12:11 <lambdabot>      The section `(> 2)' takes one argument,
16:12:12 <lambdabot>     but its type `Bool' has none
16:12:28 <dmwit> ooo, plus you need something else
16:12:37 <dmwit> ?pl \f g x -> f x && g x
16:12:37 <lambdabot> liftM2 (&&)
16:12:51 <dmwit> > filter (liftM2 (&&) (>2) (<11)) [1..20]
16:12:52 <lambdabot>  [3,4,5,6,7,8,9,10]
16:13:07 <dmwit> Or, if you find that unreadable... ;-)
16:13:17 <dmwit> > filter (\x -> x > 2 && x < 11) [1..20]
16:13:18 <lambdabot>  [3,4,5,6,7,8,9,10]
16:13:19 <nominolo> george--: you would not happen to study in nottingham, do you?
16:13:28 <george--> nominolo, durham
16:14:27 <george--> dmwit, ill use the lambda way. my lecturer will love it more
16:15:05 <dmwit> > [x | x <- [1..20], x > 2, x < 11]
16:15:06 <lambdabot>  [3,4,5,6,7,8,9,10]
16:15:26 <nominolo> george--: ok, nevermind than :)
16:15:29 <nominolo> *then
16:16:32 <mauke> > filter (\x -> all (flip id x) [(>2),(<11)]) [1..20]
16:16:33 <lambdabot>  [3,4,5,6,7,8,9,10]
16:16:45 <dolio> @pl return . fromInteger
16:16:46 <lambdabot> return . fromInteger
16:16:53 <nominolo> TomMD: the network6 author is probably someone from the ghc or some other compiler team.  at least there's no author listed in any file
16:18:03 <george--> > map (*3) (filter (\x -> x>2 && x <11) [1..20]
16:18:03 <lambdabot>  Parse error
16:18:07 <george--> > map (*3) (filter (\x -> x>2 && x <11) [1..20])
16:18:08 <lambdabot>  [9,12,15,18,21,24,27,30]
16:18:18 <george--> > map (*3) . filter (\x -> x>2 && x <11) [1..20]
16:18:19 <lambdabot>  Couldn't match expected type `a -> [a1]'
16:18:24 <george--> why does first work and second not?
16:18:41 <nominolo> george--: use $ instead of .
16:18:51 <george--> i thought they were interchangeable :P
16:18:51 <TSC> Or put in a $ at the end
16:18:52 <nominolo> george--: or use (f . g) arg
16:19:01 <TSC> >  map (*3) . filter (\x -> x>2 && x <11) $ [1..20]
16:19:02 <lambdabot>  [9,12,15,18,21,24,27,30]
16:19:12 <nominolo> george--: no, precedence levels are different
16:19:14 <TSC> It's merely a precedence problem
16:19:44 <george--> so $ means : brackets from here to end of statement?
16:19:52 <nominolo> exactly
16:19:54 <mauke> not really
16:20:01 <nominolo> huh?
16:20:04 <george--> LOL!
16:20:23 <mauke> $ is just another operator
16:20:28 <nominolo> well, of course, you have to have a function on the left
16:20:53 <nominolo> @src ($)
16:20:53 <lambdabot> f $ x = f x
16:20:57 <mauke> f (g $ x) y doesn't translate to f (g (x) y)
16:21:30 <nominolo> f (g $ x) y = f (g (x)) y
16:21:37 <nominolo> simple enough
16:21:46 <drigz> maybe it would be better expressed as bracketing either side of the $
16:22:07 <drigz> respecting existing expressions
16:22:20 <mauke> yeah, f + g $ x doesn't translate to f + g (x) :-)
16:22:54 <nominolo> > 2 + (1+) $ 3
16:22:55 <lambdabot>   add an instance declaration for (Num (t -> t))
16:23:17 <nominolo> ok, that sucks
16:23:31 <nominolo> > 2 + (1+) 3
16:23:32 <lambdabot>  6
16:23:51 <drigz> > (2+) . (1+) $ 3
16:23:52 <lambdabot>  6
16:24:01 <drigz> > ((2+) . (1+)) (3)
16:24:02 <lambdabot>  6
16:25:09 <george--> @src foldr
16:25:09 <lambdabot> foldr k z xs = go xs
16:25:09 <lambdabot>     where go []     = z
16:25:09 <lambdabot>           go (y:ys) = y `k` go ys
16:25:19 <nominolo> mauke: incidentally though, i haven't run into problems in 6+ months
16:25:51 <mauke> > runST $ do return 'X'
16:25:52 <lambdabot>   Not in scope: `runST'
16:25:59 <mauke> > Control.Monad.ST.runST $ do return 'X'
16:26:00 <lambdabot>   Not in scope: `Control.Monad.ST.runST'
16:26:03 <mauke> :(
16:30:06 <nominolo> mauke: ST can do IO
16:30:33 <mauke> what!
16:31:03 <george--> what is the difference in foldl and foldr? foldl is a left nested fold and foldr is right nested?
16:31:19 <mauke> nominolo: how?
16:31:34 <greenrd> Wow! This is the coolest thing ever!
16:31:38 <nominolo> @hoogle ST s a -> IO a
16:31:39 <lambdabot> No matches, try a more general search
16:31:49 <nominolo> @hoogle STToIO
16:31:50 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
16:32:18 <greenrd> Because I wrote my search function in a fully monadic way, I can just change its type to [Foo] from Maybe Foo, and it'll return all the matches, not just the first!
16:32:18 <mauke> nominolo: that translates ST x to IO x
16:32:30 <greenrd> At least, I think so
16:32:33 <mauke> it doesn't perform the action, though
16:33:10 <nominolo> :t unsafeIOToST
16:33:12 <lambdabot> Not in scope: `unsafeIOToST'
16:33:33 <mauke> george--: http://cale.yi.org/index.php/Fold_Diagrams
16:33:34 <lambdabot> Title: Fold Diagrams - CaleWiki
16:33:37 <davidL> Data.Ratio.approxRational is only accurate to 1e7, is this a limit or a bug?
16:33:39 <nominolo> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html#3
16:33:41 <lambdabot> http://tinyurl.com/yy2zqk
16:33:45 <george--> mauke, tyvm :)
16:34:18 <nominolo> mauke: anyways, there was some break-in a while ago, so they disabled it
16:35:18 <mauke> anyway, the intended error message was "Couldn't match expected type `forall s. GHC.ST.ST s a' against inferred type `a1 b'
16:35:21 <mauke> In the second argument of `($)', namely `do return 'X''"
16:37:14 <george--> mauke, arrow dirrection is time?
16:37:54 <george--> no wait. its not :P
16:37:59 <mauke> more or less
16:38:14 <mauke> left is input, right is output
16:38:15 <mae> how does erlang concurrency stack against haskell's ?
16:40:31 <dmwit> Haskell has more models for concurrency than Erlang does.
16:40:48 <dmwit> But, probably, if you want Erlang-style concurrency, Erlang will have more natural syntax for it. ;-)
16:44:17 <davidL> can someone confirm something stupid for me, if I were to do [ a/b | a <- [1..10^6], b <- [1..10^6] ] it would take 3 years to compute the list assuming you can do a billion calculations per second.
16:45:15 <monochrom> > 10^12 / 86400 / 365
16:45:16 <lambdabot>  31709.791983764586
16:46:03 <dmwit> > 10^12 / 10^9 / 60 / 60 / 24 / 365
16:46:05 <lambdabot>  3.1709791983764585e-5
16:46:10 <davidL> heh
16:46:15 <dmwit> Looks like less than three years to me...
16:46:19 <monochrom> Takes a year if 31710 ops per second
16:46:19 <drigz> depends on what a calculation is
16:46:32 <dmwit> Yeah, that's true.
16:46:50 <drigz> and the list would take up 4 TB i think
16:47:24 <dmwit> Unless you used LIST FUSION to fuel the SUN!
16:49:07 <dmwit> ?quote fusion
16:49:07 <lambdabot> monochrom says: Interesting. Beginner confusion cannot be eliminated, only  moved around.
16:49:22 <dmwit> ?quote \sfusion\s
16:49:22 <lambdabot> sorear says: ghc's map fusion is provably incorrect
16:52:30 <Binkley> @yow
16:52:30 <lambdabot> I wish I was on a Cincinnati street corner holding a clean dog!
16:52:46 <dmwit> Don't we all.
16:52:49 <tga> hello
16:52:57 <phoniq> ah the good old days
16:53:27 <mauke> @quota
16:53:27 <lambdabot> ihope says: Laziness is free, but it doesn't always pay off.
16:53:28 <dmwit> Heyo, tga!
16:53:31 <tga> quick question for my sanity.. should typing "foo 1 = 1" in ghci work?
16:53:35 <tga> (and do nothing)
16:53:48 <dmwit> Try "let foo 1 = 1" instead.
16:53:48 <mauke> tga: no
16:53:48 <phoniq> i'm gonna say no
16:54:31 * tga scratches his head
16:54:32 <tga> right
16:54:50 <dmwit> tga: How much do you know?  I assume you're just beginning.
16:55:15 <tga> tutorial level, heh
16:55:17 <dmwit> Just remember that ghci is slightly different from typing things into a file.
16:55:30 <dmwit> But you can put things in a file, then load it in ghci; that's the recommended method.
16:55:31 <tga> "learn functional programming tonight" kinda thing
16:55:59 <dmwit> (The technical explanation is that ghci interprets its commands to be in the IO monad, but you shouldn't have to worry about that too much yet.)
16:57:11 <mauke> tga: what languages do you know?
16:57:47 <tga> the closest I got to functional is some Ruby
16:58:24 <tga> I've managed to stick to C/Java so far
16:58:45 <mauke> ok, you can think of ghci as being the body of an interactive main function
16:58:57 <mauke> it doesn't let you define top-level stuff
16:58:59 * tga nods
16:59:33 <tga> I'm passing through the "yet another" tutorial atm
16:59:48 <monochrom> best is to put defs into a file, then load.
17:00:51 <dmwit> I agree with monochrom; that keeps confusion to a minimum.  With the :r command to reload the file when you change it, things are pretty painless that way.
17:01:09 <mauke> you can optimize :r to :
17:01:18 <mauke> that's a 50% space improvement
17:01:22 <dmwit> Really? Nice!
17:02:03 <dmwit> Mmm, doesn't work here.
17:02:14 <dmwit> That feature must be new in 6.6, huh?
17:02:43 <mauke> hmm, apparently
17:05:32 <davidL> wow, he's right :D
17:07:46 <george--> what is wrong with:
17:08:01 <george--> > map length [1..20]
17:08:02 <lambdabot>   add an instance declaration for (Num [a])
17:08:02 <lambdabot>     In the expression: 20
17:08:12 <george--> im expecting a return a list of 1's
17:08:17 <george--> as all elements are length 1
17:08:23 <jbauman> length 1 doesn't make any sense
17:08:23 <Botje> :t length
17:08:25 <lambdabot> forall a. [a] -> Int
17:08:39 <Botje> so length wants a list of something
17:08:47 <Botje> :t [1..20]
17:08:50 <lambdabot> forall t. (Num t, Enum t) => [t]
17:09:03 <jbauman> :t map length
17:09:04 <Botje> but [1..20] is just a list of numbers
17:09:05 <lambdabot> forall a. [[a]] -> [Int]
17:09:14 <Botje> heh. that makes it even more clear
17:09:16 <Botje> jbauman++
17:09:37 <drigz> > map length . map (:[]) $ [1..20]
17:09:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
17:09:47 <drigz> i just love that section
17:09:54 <Botje> robot monkey!
17:10:15 <araujo> hello!
17:10:29 <sjanssen> @keal
17:10:29 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
17:10:33 <sjanssen> @quote
17:10:33 <lambdabot> mdmkolbe says: remember to save a continuation next time in case we die
17:10:39 <sjanssen> @yow!
17:10:39 <lambdabot> I KAISER ROLL?!  What good is a Kaiser Roll without a little COLE SLAW
17:10:39 <lambdabot> on the SIDE?
17:10:45 <sjanssen> @protontorpedo
17:10:45 <lambdabot> what is so good about continuations/
17:10:50 <Binkley> @vixen
17:10:50 <lambdabot> <undefined>
17:10:51 <sjanssen> @gratuitous-quoting
17:10:51 <lambdabot> Unknown command, try @list
17:10:57 <Botje> @quote monkey
17:10:57 <lambdabot> Botje says: replacing "monad" with "monkey" makes haskell much more easy to understand
17:11:04 <Binkley> @quote robot
17:11:05 <lambdabot> No quotes match. I feel much better now.
17:12:08 <davidL> @vote-list
17:12:08 <lambdabot> Unknown command, try @list
17:21:23 <george--> @src sequence
17:21:24 <lambdabot> sequence ms = foldr k (return []) ms
17:21:24 <lambdabot>     where
17:21:24 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
17:30:35 <Binkley> @yow
17:30:35 <lambdabot> World War III?  No thanks!
17:34:57 <george--> how can i make a function read in a text file i.e. /home/george/test and then output it?
17:35:05 <george--> im trying to use readFile
17:35:56 <mauke> readFile "/home/george/text" >>= putStr
17:37:34 <george--> thanks
17:41:16 <davidL> > [ x^n + y^n == z^n | [x,y,z,n] <- replicateM 4 [1..] ]
17:41:18 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
17:41:25 <davidL> aww
17:42:08 <dolio> > or [ x^n + y^n == z^n | [x,y,z,n] <- replicateM 4 [1..] ]
17:42:14 <lambdabot> Terminated
17:42:28 <davidL> ?ty or
17:42:30 <lambdabot> [Bool] -> Bool
17:42:39 <drigz> > replicateM 2 [1..4]
17:42:40 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4,...
17:42:43 <davidL> sweet, had no idea about or
17:43:17 <george--> ?paste
17:43:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:43:19 <dolio> > or [ x^2 + y^2 == z^2 | [x,y,z] <- replicateM 3 [1..] ]
17:43:25 <lambdabot> Terminated
17:43:42 <drigz> i think replicateM 4 [1..] will never get past [1,1,1,x]
17:44:10 <davidL> > last $ replicateM 4 [1..3]
17:44:12 <lambdabot>  [3,3,3,3]
17:44:33 <drigz> > [(x,y,z) | [x,y,z] <- replicateM 3 [1..100], x^2 + y^2 == z^2]
17:44:36 <lambdabot>  [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(7,24,25),(8,6,10),(8,15,17),(9,12,15),(...
17:45:18 <davidL> nice
17:45:27 <drigz> but it won't go infinite
17:45:36 <hpaste>  george-- pasted "practice with IO" at http://hpaste.org/46
17:45:57 <george--> can anyone have a quick look at this please :)
17:46:46 <drigz> george--: return [] has type IO [a], not [IO a]
17:46:53 <drigz> that may not be all
17:47:04 <mauke> george--: precedence error
17:47:17 <mauke> you meant to write return (length y : namesToContents xs)
17:47:23 <mauke> except that doesn't typecheck
17:48:02 <drigz> also length y has type Int, not IO Int
17:48:21 <dolio> (length y:) `liftM` namesToContents xs
17:48:43 <mauke> I'd do it like this: nameToLength :: String -> IO Int; nameToLength s = do x <- readFile s; return (length x)
17:48:54 <mauke> namesToContents = map nameToLength
17:49:38 <mauke> george--: your error message is because return [] should be []
17:50:02 <george--> heh :) i like your way more than mine
17:50:05 <george--> ill do it like that
17:50:23 <george--> i was going to originally do it similar but wanted to try all in one function
17:50:36 <george--> thanks for help. bed for me now
17:50:37 <mauke> except I'd probably go for [String] -> IO [Int], not [IO Int]
17:55:44 <drigz> is it possible for the value of a do-block to not be in the monad which it operates on
17:55:54 <Botje> no, that's the whole point of monads
17:56:27 <drigz> @hoogle m [a] -> [m a]
17:56:31 <lambdabot> Prelude.repeat :: a -> [a]
17:56:31 <lambdabot> List.intersperse :: a -> [a] -> [a]
17:56:31 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
17:56:54 <Botje> :t sequence
17:56:57 <lambdabot>     Ambiguous occurrence `sequence'
17:56:57 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
17:57:06 <Botje> :t Control.Monad.sequence
17:57:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:57:30 <mauke> :t (: []) . liftM head
17:57:31 <drigz> i was wondering if there was a inverse of sequence
17:57:32 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> [m a]
17:58:18 <edwardk> drigz: that would require you to be able to extract from an arbitrary monad, not possible
18:00:30 <hpaste>  drigz annotated "practice with IO" with "similar to the original style" at http://hpaste.org/46#a1
18:01:18 <drigz> edwardk: :(
18:01:34 <drigz> oops my mistake
18:02:06 <davidL> Does anyone know where I can Wiles' supposed 300 page proof of Fermat's Last Theorem?
18:02:09 <hpaste>  drigz annotated "practice with IO" with "slightly less similar this time" at http://hpaste.org/46#a2
18:03:29 <drigz> btw, is there a better way to print the result of that than mapM_ (>>= print)?
18:07:25 <mauke> http://cgi.ebay.com/Bible-signed-by-Jesus-Christ_W0QQitemZ110130520271QQihZ001QQcategoryZ378QQrdZ1QQcmdZViewItem
18:07:27 <lambdabot> Title: eBay: Bible signed by Jesus Christ (item 110130520271 end time May-30-07 11:51:0 ..., http://tinyurl.com/2648zs
18:07:28 <TSC> print . sequence_ ?
18:07:36 <TSC> (I'm guessing)
18:08:16 <drigz> :t liftM print . sequence
18:08:18 <lambdabot>     Ambiguous occurrence `sequence'
18:08:18 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
18:08:22 <davidL> lol @ mauke
18:08:28 <drigz> :t liftM print . Control.Monad.sequence
18:08:30 <lambdabot> forall (m :: * -> *) a. (Show [a], Monad m) => [m a] -> m (IO ())
18:08:49 <drigz> :t mapM_ (>>= print)
18:08:50 <lambdabot> forall a. (Show a) => [IO a] -> IO ()
18:09:43 <TSC> :t print . sequence_
18:09:45 <lambdabot> forall (m :: * -> *) a. (Show (m ()), Monad m) => [m a] -> IO ()
18:10:37 <ari> @type print . sequence
18:10:39 <lambdabot>     Ambiguous occurrence `sequence'
18:10:39 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
18:11:00 <ari> @type print . Prelude.sequence
18:11:02 <lambdabot> forall (m :: * -> *) a. (Show (m [a]), Monad m) => [m a] -> IO ()
18:12:18 <drigz> @type (print =<<) . Prelude.sequence
18:12:20 <lambdabot> forall a. (Show [a]) => [IO a] -> IO ()
18:12:32 <drigz> that's it, but it's not really any nicer
18:28:12 <tga> let ff = firstfactor (c 2)
18:28:17 <tga> does this make sense in itself?
18:28:47 <jcreigh> depends on the types of firstfactor and c
18:29:20 <tga> I'm asking because I'm getting a 'keyword expected' error on the next line
18:29:45 <jcreigh> @paste
18:29:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:31:11 <tga> http://pastebin.ca/510752
18:31:13 <tga> already here
18:32:30 <jcreigh> oh, sorry, that is incorrect. the syntax is "let <bindings> in <expr>"
18:32:40 <jcreigh> > let x = 5 in x*x
18:32:42 <lambdabot>  25
18:33:43 <allbery_b> (except in do blocks)
18:33:48 <jcreigh> oh, right
18:33:50 <tga> erm?
18:33:52 <tga> *confused
18:34:22 <tga> let newvar = function in values?
18:34:43 <tga> sorry, VALUES in FUNCTION
18:35:02 <allbery_b> you could also define a function that way
18:35:26 <allbery_b> > let f x = x * 2 in (f . f) 5
18:35:27 <lambdabot>  20
18:36:08 <kfish> hmm, perhaps getting up at 4am and reading that deforestation paper was a bad idea ... (z_O )
18:36:36 <dons> moin
18:36:52 <kfish> moin dons
18:36:59 <tga> still getting an error
18:37:21 <tga> let ff = (c 2) in firstfactor ?
18:37:47 <jcreigh> let ff = firstfact (c 2) in
18:37:52 <jcreigh> *firstfactor
18:37:57 <jcreigh> you were missing the "in" keyword
18:38:25 <tga> ooh.. "in.. following code"
18:38:26 <tga> got it
18:38:53 <allbery_b> let ff = firstfactor (c 2) in if ...
18:39:24 <allbery_b> alternatvely you can write your code using ff, then append "where ff = firstfactor (c 2)"
18:43:04 <tga> what's the English translation of "*** Type           : a -> a -> b a"?
18:44:20 <Korollary> takes an 'a and produces a function that takes an 'a and produces a function that takes a 'b and produces a 'b.
18:44:44 * tga sighs
18:44:45 <tga> thanks
18:47:17 <hpaste>  tga pasted "pseudosyntax" at http://hpaste.org/47
18:47:43 <tga> I think I know what I want to do, but I get the feeling I'm getting the syntax all wrong
18:49:31 <hpaste>  dcnstrct pasted "need help compiling an asynchronous exception based timeout function" at http://hpaste.org/48
18:49:45 <jcreigh> well, firstfactor (c 2) calls c with argument 2, and then calls firstfactor with the result of calling 'c'. probably not what you meant.
18:50:04 <allbery_b> I see some indentation problems in the pseudocode as well
18:50:09 <dolio> tga: What does 'list:ff' mean in your pseudocode?
18:50:12 <allbery_b> haskell cares about indentation
18:50:17 <tga> append ff to the list
18:50:23 <allbery_b> doesn't work
18:50:31 <dolio> tga: You'll want ff:list, then.
18:50:41 <dolio> Or list ++ [ff] if you want to append at the end.
18:50:58 <allbery_b> it's often faster to use (:) to prepend, then reverse the result at the end
18:51:24 <allbery_b> :t (:)
18:51:25 <tga> gotcha
18:51:26 <lambdabot> forall a. a -> [a] -> [a]
18:51:37 <allbery_b> see, (:) prepends an item to a list, it can't append
18:52:06 <allbery_b> (think of haskell lists as linked lists, prepending to the front is fast, appending requires traversing the list)
18:52:53 <dons> interesting, a package filter language with a compiler written in Haskell, http://usr-share-morlock.blogspot.com/2007/05/piffle-packet-filter-language_26.html (?)
18:52:56 <dons> hey ekidd
18:52:56 <lambdabot> Title: /usr/share/morlock: Piffle, a Packet Filter Language, http://tinyurl.com/2e8wll
18:53:02 <ekidd> dons: Hello!
19:00:47 <hpaste>  tga pasted "translation please" at http://hpaste.org/49
19:00:58 <tga> how can a function not match its own type?
19:02:21 <Binkley> tga: the error message is saying that (c, d, [b]) -> a [b] is not the same type as a [b]
19:02:33 <Binkley> which is indeed true, because the first is a function that takes a tuple and gives you back something with type a [b]
19:02:37 <Binkley> and the second is just a value of type a [b]
19:03:05 <tga> where is it getting the last a [b] from though?
19:03:11 <Binkley> because you're using return
19:03:18 <Binkley> so it assumes that f has a monadic type
19:03:21 <tga> oh
19:03:29 <Binkley> I think you don't want to have those two uses of "return" there
19:04:03 <tga> I mistakenly figured they would make no difference
19:04:07 <allbery_b> in haskell, return does not mean "return this value from the function"; it's part of the monad machinery, and means "lift this value into the monad"
19:04:20 <tga> gotcha
19:04:25 <tga> thanks
19:04:45 <allbery_b> it's named that way because typiclaly you do need to lift a pure value into the monad to return it from amonadic function
19:05:25 <allbery_b> but it is a rather confusing term for beginners
19:06:26 <tga> can I get the interpreter to describe a specific function?
19:06:34 <tga> its parameters and return value
19:06:35 <allbery_b> describe how?
19:06:41 <allbery_b> :t map
19:06:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:06:52 <Binkley> you might want the library docs -- http://hpaste.org/49
19:06:55 <Binkley> oops
19:06:59 <Binkley> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
19:06:59 <allbery_b> @docs
19:07:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:07:03 <Binkley> right
19:07:59 <allbery_b> one of the neat things about haskell is how often the description of the parameters and return value exactly characterizes the function
19:08:14 <allbery_b> as with map above:  take a function from a to b, and a list of a, and produce a list of b
19:08:32 <allbery_b> @. djinn type map
19:08:34 <lambdabot> -- f cannot be realized.
19:08:37 <allbery_b> whoops
19:08:42 <allbery_b> right, djinn doesn't do lists
19:08:55 <dons> :t foldr
19:08:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:09:03 <dons> I often start with the type, with higher order functions
19:09:09 <allbery_b> (djinn takes a type and produces a function that has that type)
19:09:14 <dons> > foldr (\a b -> b) 0 [1..10]
19:09:15 <lambdabot>  0
19:09:16 <dons> for example
19:09:28 <dons> you can produce working code just by filling out the type template
19:09:29 <dons>  
19:09:55 <dons> :t unfoldr
19:09:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:10:10 <dons> > unfoldr (\b -> Just (b, b+1)) 0
19:10:11 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:11:10 <hpaste>  Excedrin pasted "(no title)" at http://hpaste.org/50
19:11:12 <hpaste>  tga pasted "f signature" at http://hpaste.org/51
19:11:20 <tga> how would you call something like this then?
19:11:46 <dons> its a sign that we have a good type system, that we can actually use the type info to guide implementatoin -- it contains enough info to make that possible.
19:11:46 <tga> it's supposed to be something like List f (int a, int b, List c)
19:11:58 <Excedrin> any comments on my code would be appreciated, I'm sure it can be improved
19:12:27 <dons> f :: a -> b -> [c] -> [c] ?
19:12:34 <dons> :t map
19:12:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:12:38 <allbery_b> one normally doesn't wrap all the arguments in tuples like that, for one thing
19:12:51 <allbery_b> one of haskell's strengths is currying, which enables partial application
19:12:55 <dons> so 'n' and 'c' are bounds?
19:13:09 <dons> but 'n' is a constant anyway. its unused in the result type
19:13:16 <allbery_b> and partial application is nice with things like map:
19:13:24 <allbery_b> > map (+2) [1..10]
19:13:25 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
19:13:32 <stepcut> how do I convert a CFloat to Float ?
19:13:41 <tga> dons: n is the number I'm trying to factor, c is the current part of it I'm working on
19:13:45 <dons> fromIntegral, stepcut
19:13:48 <tga> if that makes any sense
19:13:58 <yghor> hi
19:14:03 <dons> tga: ah I see. but you don't actually use 'n' anywhere?
19:14:29 <yghor> anyone knows if theres a pdf version of the Haskell wikibook?
19:14:34 <tga> dons: I check c against n. for(c=1; c<n; c++) kinda thing
19:14:35 <dolio> Excedrin: I'd import Data.Foldable and use it to implement aSum. :)
19:14:49 <Korollary> ah I was just going to say that
19:14:51 <Excedrin> dolio: thanks, I hadn't looked at Data.Foldable
19:14:51 <dons> yghor: I think so. hmm.
19:14:59 <Korollary> Array is already Foldable
19:15:12 <dons> tga: that's a fold, you've got :-)
19:15:33 <dolio> Korollary: Yeah, but you need to import the module, no?
19:15:35 <tga> I'm afraid I don't follow
19:15:36 <stepcut> dons: i think that only works for CInt -> Int. `No instance for (Integral CFloat)'
19:15:41 <stepcut> fromIntegral (1.0 :: CFloat) :: Float
19:16:10 <dons> tga: hmm, what's the list argument?
19:16:22 <dons> you immediately discard the 'xs' for some reason?
19:16:33 <Excedrin> why does ghci say, 'x not in scope' when I've loaded a module that's compiled?
19:16:38 <tga> dons: I'm trying to fill the list with n's factors
19:17:07 <yghor> dons: ill try printing to a ps file
19:17:09 <yghor> thanks
19:17:13 <tga> dons: I'm appending to the list until the end, when I just return it as is
19:17:15 <allbery_b> CFloat appears to be Enum, so try fromEnum
19:17:40 <allbery_b> except that produces an Int
19:17:41 <allbery_b> hm
19:17:46 <allbery_b> that makes no sense t me anyway
19:18:02 <allbery_b> yeh, that';s wrong
19:18:02 <tga> dons: I'm seriously haskell challenged and I'm thinking this procedurally
19:18:04 <dons> tga: oh, ff:[] is wrong, you mean ff : xs or some such
19:18:04 <dons> that's your accumulator?
19:18:05 <allbery_b> and downright weird
19:18:36 <tga> dons: ugh, right, typo
19:18:48 <tga> dons: ff:x:xs rather
19:19:24 <stepcut> hrm, simon marlow thinks realToFrac, http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/3357, I'll do that ;)
19:19:29 <lambdabot> Title: gmane.comp.lang.haskell.cafe
19:19:42 <allbery_b> looks like you can convert via fromRational . toRational, if it comes to that
19:19:43 <dons> tga, something like:
19:19:45 <dons> factor n = go n []
19:19:45 <dons>     where
19:19:45 <dons>         go 0 acc = acc
19:19:45 <dons>         go c acc = go (c / f) (f : acc)
19:19:47 <dons>             where
19:19:50 <dons>                 f = firstFactor c 2
19:19:57 <allbery_b> or the ultimate silly way to do it, read . show :)
19:20:21 <stepcut> allbery_b: thanks. for now, realToFrac seems to be good enough
19:20:32 <dons> > realToFrac (42 :: Foreign.C.Types.CFloat) :: Float
19:20:35 <dons> you're write, stepcut
19:20:40 <lambdabot>      Not in scope: type constructor or class `Foreign.C.Types.CFloat'
19:20:41 <dons> :t realToFrac (42 :: Foreign.C.Types.CFloat) :: Float
19:20:43 <tga> dons: let me digest that for a sec
19:20:43 <lambdabot> Float :: Float
19:20:50 <dons> write. oh my. time for coffee
19:20:57 <stepcut> :p
19:21:01 <allbery_b> @index realToFrac
19:21:01 <lambdabot> Prelude
19:21:04 <allbery_b> huh
19:21:32 <stepcut> dons: good thing you have quickcheck to keep you inline on the programming side of things ;)
19:21:35 <Excedrin> neat, Data.Foldable is very cool
19:21:41 <dons> stepcut: very much so!
19:23:01 <dons> tga: also, just for you to ponder,
19:23:02 <dons> factor n = unfoldr next n
19:23:03 <dons>     where
19:23:03 <dons>         next 0 = Nothing
19:23:03 <dons>         next c = Just (f, c/f) where f = firstFactor c 2
19:25:33 <dons> that's probably far from right, but gives you a intro to list generation
19:26:11 <tga> dons: I've just officially overflowed my buffer
19:26:17 <yghor> lol
19:28:35 <jfredett> hmm, I have an interesting problem, I'm using a .lhs source file. The code in it works, right up until I add a "import Data.Set"
19:28:50 <dons> you have to import Set qualified
19:28:56 <dons> since it redefines map and fold and so on
19:28:59 <jfredett> i see
19:29:01 <dons> import qualified Data.Set as S
19:29:05 <jfredett> okay
19:29:06 <dons> then refer to names as S.map
19:29:15 <jfredett> excellent, thanks
19:31:39 <jfredett> hmm, still not working, hmm
19:32:11 <jfredett> I must be doing something stupid, I'll figure it out... :/
19:34:36 <jfredett> thats wierd, in hugs, it says, "unexpected symbol plist" and nothing about name collisions... :/
19:35:09 <allbery_b> @paste it?
19:35:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:35:25 * sorear returns
19:35:48 <jfredett> well, its from project euler, so don't look if you don't want to cheat :P
19:36:46 * allbery_b doesn't do project euler
19:36:57 <allbery_b> I'm a sysadmin, not really a mathy or algorithms type
19:37:02 <hpaste>  jfredett pasted "Weird Syntax Error" at http://hpaste.org/52
19:37:10 <jfredett> ooh, thats nifty
19:37:11 <sorear> yow!
19:37:15 <sorear> 52?!
19:37:22 <sorear> what happened to hpaste?
19:37:27 <jfredett> is that bad? *hides*
19:37:49 <sorear> jfredett: Very.  we just lost 2000-odd pastes
19:37:50 <allbery_b> not your fault, it aparently got reset a couple weeks ago
19:37:57 <jfredett> oh, shizzle
19:38:01 <sorear> allbery_b: it has CHECKPOINTS!
19:38:22 <allbery_b> I have no clue
19:38:40 <allbery_b> I noticed last week that it was syuddenly reporting low numbers, have no idea what happened
19:39:27 <sorear> is glguy still awol?
19:39:55 <allbery_b> hm.  jfredett: try not indenting the import statement
19:40:00 <jfredett> okay
19:40:24 <allbery_b> haskell's layout can lead to unexpected effects when you indent some things
19:40:31 <jfredett> allbery_b, you are a genius.
19:40:35 <sorear> -*-Mutt: /var/mail/stefan [Msgs:388 New:343 Del:1 Post:1 2.3M]---(threads/date)----------------------------------------------------------------------------------(99%)---
19:40:37 <jfredett> works perfectely now
19:40:39 <sorear> yay.
19:40:52 <jfredett> *note to self, when in doubt, don't indent...*
19:41:24 <davidL> Have fun sorear.
19:41:41 <allbery_b> well, just be careful with it.  indentation is significant in haskell, you need to follow its rules or it will bite back
19:42:56 <sorear> davidL: Fortunately, most of it isn't directly for me.  Skimming haskell-cafe@ mails doesn't take a great deal of time...
19:44:41 <davidL> I wouldn't mind reading three hundred emails that were written by humans for me.
19:46:20 <dons> sorear: you're back!
19:46:31 <dons> sorear: and glguy also, but shapr or lemmih might know what happened.
19:48:51 <dons> ?users
19:48:51 <lambdabot> Maximum users seen in #haskell: 340, currently: 284 (83.5%), active: 33 (11.6%)
19:50:07 <sorear> nice.  it looks like they are actually splitting up base
19:53:00 <stepcut> sorear: shapr has cursing left and right trying to get hpaste back online a few days ago
19:53:27 <stepcut> shapr: and then it wouldn't read the save data for some reason, so he eventually gave up and started fresh
19:53:39 <stepcut> s/shapr/sorear/
19:54:34 <hpaste>  tga pasted "syntax pains" at http://hpaste.org/53
19:54:44 <tga> can anyone please take a look?
19:55:02 <tga> firstfactor works as expected, but I'm getting the syntax wrong for f
19:55:29 <tga> List f (int n, int c, List xs)
19:55:40 <sorear> i'm kinda suprised at how few @seen sorear's are in the logs, actually :)
19:55:47 <awesomess3> davidL: lol
19:55:55 <tga> I know it's not the most optimal way to do this but I'd like to stick to it for now
19:56:06 <davidL> awesomess3: you get banned from #math?
19:56:13 <dons> tga, missing ( ) around ff:xs
19:56:39 <awesomess3> davidL: May 25 19:33:01 <awesomess3>	Is Anil short for Anal?
19:56:54 <awesomess3> davidL: what do you think?
19:56:59 <Binkley> 0_o
19:57:11 <davidL> I think Anil is OP :D
19:57:37 <shapr> sorear: I have the previous state dirs if you want to resurrect them.
19:57:45 <dons> shapr: oh good.
19:57:48 <tga> dons: I'm getting an unresolved overloading
19:57:48 <dons> as long as we have them somewhere.
19:58:07 <tga> dons: mind if I message you so I can paste stuff quicker?
19:58:09 <awesomess3> I wonder how long we're banned, hopefully soon :(
19:58:13 <awesomess3> davidL
19:58:18 <dons> tga, probably a good idea to give eplicit type signatures.
19:58:23 <davidL> awesomess3: talk in #chemistry
19:58:27 <dons> tga, also, you sure you want floating point division?
19:58:56 <tga> okay, switched to div
19:58:57 <shapr> awesomess3: #haskell also encourages mutual respect.
19:59:01 <dons> shapr: looks cute, do we know anything more about this ? --> http://www.gaetanocaruana.com/2007/05/25/embedding-origami-constructs/
19:59:03 <lambdabot> Title: Gaetano Caruana&#8217;s Blog  Blog Archive  Embedding Origami Constructs, http://tinyurl.com/2rwusb
19:59:12 <dons> a EDSL in Haskell for origami
19:59:27 <shapr> Whoa AWESOME
19:59:29 <awesomess3> shapr, As long as the operators are likewise
19:59:36 <shapr> I've been a fan of origami for years.
19:59:39 <tga> dons: oh hey, switching to int division fixed the overloading problem
20:00:21 <shapr> awesomess3: likewise as in respectful?
20:00:36 <sorear> shapr: heh, cool.  i think the problem is glguy applied a breaking patch without restarting
20:00:58 <awesomess3> shapr, yes.  that's what I meant.
20:01:42 <sorear> shapr: too bad nobody has figured out how to make strong types coexist with upgradability...  if I ever write something like hpaste it will be dynamic structures for storage :(
20:01:44 <shapr> awesomess3: In my experience the #haskell ops are polite but not particularly tolerant of disrespectful behaviour.
20:01:57 <shapr> sorear: That is an open question for HAppS.. how to upgrade state types.
20:02:58 <shapr> sorear: But the problem isn't that the state type changed. hpaste fails to load one of the state files.
20:03:27 <dons> today's interesting theory article, http://programming.reddit.com/info/1togt/comments
20:03:29 <lambdabot> Title: Even more type hacking: indexed type families in Haskell (reddit.com)
20:03:32 <sorear> shapr: fails to load?  like IO error?  *gulp*
20:03:38 <dons> (just points to the wiki, btw, but worth a read)
20:05:06 <davidL> > or [ x^n+y^n == z^n | [x,y,z,n] <- replicateM 4 [1..] ]
20:05:12 <lambdabot> Terminated
20:05:25 <awesomess3> lol!
20:05:49 <shapr> dons: I can't find any info outside of that blog, but it sure looks cool.
20:05:49 <tga> it's aaalive!
20:05:54 * tga laughs maniacally
20:06:06 <tga> my first haskell program actually works
20:06:09 <tga> thanks for the patience folks
20:06:14 <dons> tga, great!
20:06:15 * jcreigh cheers
20:07:19 <davidL> are the old hpaste posts archived somewhere?
20:07:31 <shapr> Not really
20:07:34 <araujo> tga, Haskell is an addiction , run away while you can ?!!?!
20:07:45 <Binkley> i.e., don't use hpaste to write your dissertation
20:07:47 <shapr> I mean, I have the old state dirs, but they won't load. I haven't tried to fix that though.
20:08:25 <tga> it is quite a rush to see something suddenly start working after fixing the last syntax asininity
20:09:07 <shapr> awesomess3: Are you learning Haskell?
20:09:59 <awesomess3> shapr, I had to find a friend that I knew was in #haskell .  But I've always wanted to learn Lisp...and Haskell seems to look a lot like Lisp lol
20:10:20 <jcreigh> yeah, what happened with hpaste anyway? Did the state just get clearer?
20:10:20 <dons> shapr: seen the new fibonacci spiraling layout algo for xmonad?
20:10:21 <shapr> There are some similarities, it's true.
20:10:26 <jcreigh> *cleared
20:10:29 <shapr> dons: ooh, no! Sounds awesome!
20:10:41 <shapr> Wow, sounds like hpaste needs its own news page.
20:10:57 <dons> its surprisingly nice.http://xmonad.org/images/screen-sjanssen-spiral-thumb.png
20:11:31 <dons> and look exactly like the abstract model, http://en.wikipedia.org/wiki/Image:FibonacciBlocks.svg
20:11:31 <lambdabot> Title: Image:FibonacciBlocks.svg - Wikipedia, the free encyclopedia
20:11:33 <allbery_b> <sorear> shapr: heh, cool.  i think the problem is glguy applied a breaking patch without restarting
20:11:35 <davidL> is that the Golden spiral?
20:11:38 <dons> makes me thing there's some other nice tiling ideas out there.
20:11:42 <shapr> dons: ooh, that's neat!
20:11:51 <allbery_b> (so it's unable to load its state)
20:11:51 <dons> davidL: close, see, http://en.wikipedia.org/wiki/Golden_spiral
20:11:52 <lambdabot> Title: Golden spiral - Wikipedia, the free encyclopedia
20:12:31 <shapr> allbery_b: I don't think that's the problem.
20:12:58 <dons> shapr: oh, to update after a state change, the strategy would be to apply the state writer change first
20:13:03 <shapr> awesomess3: You should try Haskell, you might like it!
20:13:04 <dons> then load the state, write it in the new format
20:13:07 <dons> then apply the reader patch
20:13:20 <dons> then load up the new reader, sucking the state in, in its new format
20:13:31 <tga> to get a loop from 2 to x I am calling f(2), then f calls f(i+1) until it gets to x
20:13:49 <tga> can I get f to initialize itself when it doesn't have a first arg?
20:14:29 <shapr> dons: musasabi used code like Data.Binary's type tagging example to do state versioning.
20:14:47 <dons>  ah yeah, that's another way. permanent compatibility
20:14:48 <jbauman> you can make an f' which f calls with a first argument
20:14:50 <tga> I guess I'm really talking about function overloading
20:14:57 <dons> f' = f 10
20:15:04 <tga> can I overload f(x) to call f(x,y)?
20:15:15 <jbauman> well, they would have different types
20:15:16 <dons> f x = f' x 10
20:15:27 <shapr> Do you think xmonad will ever have a float layout?
20:15:41 <dons> shapr: yeah, jcreigh has a draft working
20:15:47 <shapr> Cool
20:15:47 <dons> but we've decided to delay it till 0.3
20:16:39 <shapr> I really like the speed of xmonad. ion and dwm could be very slow at times.
20:16:40 <Excedrin> is there an easy way to parse a list of floats from the command line with System.Console.GetOpt?
20:16:47 <Excedrin> openbox > *
20:16:51 <allbery_b> tga: easy? no
20:16:59 <tga> that's all I want to know :)
20:17:19 <allbery_b> especially if you insist on using tuples for arguments
20:17:24 <sorear> Excedrin: No.  I have a plan for a library that could, *but*
20:17:44 <allbery_b> there's a complex way of doing it with currying and typeclasses, but you probably don't want to go there
20:17:52 <dons> shapr: yeah, i noticed ion was slow. all that lua stuff
20:17:53 <sorear> Excedrin: I can't figure out how to get anything reasonable out of --help automatically.
20:17:55 <allbery_b> @src Text.Printf
20:17:56 <lambdabot> Source not found. Where did you learn to type?
20:18:05 <allbery_b> @source Text.Printf
20:18:06 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
20:18:08 <sorear> Excedrin: which is a killer nonfeature...
20:18:14 <allbery_b> ...if you want your brain warped
20:19:08 <lispy> let's do the brain warp again!!
20:19:15 <Excedrin> sorear: I guess I can supply some argument many times, -z 4 -z 5 -z 6, etc
20:19:33 <Excedrin> I'm not sure if that's any better than -z [4,5,6] and a potential read error
20:20:21 <sorear> Excedrin: you can do that, but it's ugly in the code
20:20:32 <sorear> Excedrin: my system has a nice many combinator
20:24:20 <sorear> @botsnack
20:24:20 <lambdabot> :)
20:32:36 <jfredett> @docs DataSet
20:32:36 <lambdabot> DataSet not available
20:32:39 <jfredett> @docs Data.Set
20:32:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
20:33:18 <stepcut> sorear: i was working on a command-line processing library a long time ago. I addition to autogenerating --help, I thought it would be cool to autogenerate tab-completion code for different shells...
20:34:04 <sorear> stepcut: Twas an idea of mind, too
20:34:30 <sorear> sorear: but my combinators are just too expressive - the best you can extract is a grammar
20:34:33 <stepcut> sorear: awesome!
20:34:46 <sorear> stepcut: to which?
20:34:57 <stepcut> sorear: autogenerating tab-completion code
20:35:28 <dons> mmm. rye bread and vegemite. yummy!
20:36:28 <sorear> stepcut: Actually, my idea was a bit more modular.
20:37:01 <sorear> stepcut: I would have a ^A^Atabcomplete magic argument, which would be used by completion scripts
20:37:30 <stepcut> sorear: yeah, that is the only way I could figure to implement it as well
20:37:45 <sorear> like fooprog ^A^Atabcomplete {-cursor-arg-} {-cursor-char-} args
20:38:06 <sorear> hmm, maybe an environment variable would be less likely to shoot you in the foot
20:39:41 <stepcut> yeah
20:40:23 * stepcut goes off to do some non-programming stuff
20:42:25 <sorear> *phew* finished skimming 500-odd emails
20:52:20 <sorear> @seen fasta
20:52:20 <lambdabot> I saw fasta leaving #haskell 6h 43m ago, and .
20:54:38 <tga> stupid question, how do you stick multiple things into a then block?
20:55:14 <dons> tga: well, those things are either expressions or variable bindings?
20:55:18 <sorear> "then block"
20:55:18 <tga> expressions
20:55:21 <tga> call a function, then recurse
20:55:23 <dons> in which case you name the subexressions with 'wher' or 'let'
20:55:41 <tga> nope, just function calls
20:55:41 <dons> then let n = 2 in go (n+1)
20:57:09 <tga> what about something like if(x) then a() b() c() else d()
20:59:10 <dons> if x then ... else d
20:59:25 <dons> but you only get to return one value from the 'then' branch
20:59:28 <sorear> tga: what would a() b() c()  mean?  we don't have effects
20:59:45 <dons> yeah, you don't call functions for their side effect -- they don't have any :-)
20:59:50 <dons> so it would be something like:
20:59:51 <tga> uhm, right
21:00:01 <tga> I want to test my function for values from 1 to x
21:00:06 <dons> let x = a .. ; y = b ... in c x  y
21:00:19 <dons> test eh? you mean literally test it ?
21:00:30 <tga> print out results
21:00:32 <tga> as in effects
21:00:36 <dons> ah, print out the results.
21:00:55 <dons> main = mapM_ print [ myfun x | x <- [ 1.. 10] ]
21:00:57 <sorear> forM_ [1..x] (print . function)
21:01:17 <tga> I see
21:01:20 <dons> that's basically a 'for' loop that prints the result of applying 'myfun' to values from 1 .. 10
21:01:32 <dons> [ myfun x | x <- [ 1.. 10] ] is the list you get.
21:01:38 <jcreigh> In my mind, Haskell *does* have side effects, in the form of various state-ism monads. True, it's not built into the core language, but Haskell will happily let you write sloppy, stateful, side-effecting code. Just because the language is functional doesn't mean your code is.
21:01:38 <tga> sweet
21:01:40 <dons> also , you could write it as:    map myfun [1..10]
21:01:59 <dons> jcreigh: bit hard to be very stateful though.
21:02:08 <dons> since the syntactic pain of , say, global IORefs is heaavy
21:02:22 <dons> and StateT et al tend to encourage nice compositional style of state coding
21:02:27 <dons> (only get/put/modify allowed)
21:02:36 <jcreigh> ha. use Coldfusion, then talk to me about syntactic pain.
21:03:01 <dons> also, the stateful stuff is isolated by type
21:03:19 <dons> you simply can't affect remotely some pure code you already wrote, by changing some global variable
21:03:33 <dons> but you could happily, blindly, do that in an impure langauage
21:03:58 <dons> so my argument is that "sloppy, stateful, side-effecting code" is too hard to write
21:04:01 <jcreigh> ah, now that is a good point. You can do stupid things, but they don't spill over into code that was done right.
21:04:15 <dons> yeah
21:04:22 <dons> strong separation
21:04:36 <kb_> yeah; it's one of the things that allows 'coding while tired' in haskell
21:04:53 <sorear> @quote drunk
21:04:53 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
21:04:53 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
21:04:55 <dons> exactly. or coding while drunk, or .. :-)
21:05:09 <tga> funny
21:05:30 <kb_> yeah, i've seen you say that before; it's so true [my c whilst tired code is.... not nice]
21:05:30 <dons> jcreigh: this is why StackSet can be checked and proved in isolation
21:05:43 <dons> it won't suddenly stop working if we hack something new into X
21:07:05 <jcreigh> I have a theory about testing software; roughly, the easier your code is to test via some automatic method, the less likely it is to contain bugs in the first place. I think this is part of why testing is a good idea: Not just because you'll find some bugs, but because the code will end up cleaner anyway.
21:08:48 <dons> jcreigh: i think that is related to my 'if you can come up with more QC properties, the code is better" rule.
21:09:12 <dons> and related also to the idea that the ease of formal verification of some code, is related to the ease of human understanding of that code.
21:09:15 <kb_> dons: hm, what else is correlated with being able to find more QC properties?
21:09:37 <dons> the more properties, the more orthogonal the api, i think.
21:09:59 <dons> QC is a form of mechanical support for finding the optimal api for some data type, when used this way
21:10:24 <dons> so while things like 'stack' or 'queue' have obvious natural apis now (in hindsight), with a new structure, you can find the natural api, by writing QC properties about that api
21:10:50 <jcreigh> kb_: Finding more QC properties is strongly correlated with your name being Don Stewart :)
21:10:51 <dons> and then reworking it till all the functions in the interface relate naturally to each other, as shown by their QC properites
21:11:12 <kb_> hmm, cool
21:11:16 <dons> nah, its just a process of stating the code's behaviour, in a machine checkable way
21:11:19 <dons> i.e. writing a spec :-)
21:11:38 <dons> but the insight is to use QC properties as feedback on the code
21:11:40 <kb_> sure, but i'd never thought about using quickcheck that way
21:11:42 <kb_> exactly
21:11:43 <dons> and then to change the code in light of its properties
21:12:08 <kb_> that's a great way to get tool support to something that i've always done in an ad-hoc way, based on when a (hopefully) good idea hit me
21:12:19 <dons> so its like a cheap form of the code improvement that occurs when doing real formal verificatoin
21:12:35 <kb_> hmm, what do you consider real formal verification?
21:12:45 <jcreigh> dons: do you need to think of QC properties before hacking in new features, or after?
21:12:47 <dons> oh, things like using Isabelle on the L4 kernel. serious theorem proving.
21:12:54 <jcreigh> s/think of/write/
21:13:07 <dons> to get the theorem prover to go through, you have to get the code into a form that clearly states what is going on
21:13:11 <jcreigh> s/need/tend/
21:13:15 <dons> QC is like theorem-proving-light
21:13:20 <jcreigh> s/jcreigh/someone who can frikkin type/
21:13:32 <dons> jcreigh: its a re-enforcing process.
21:13:42 <dons> you come up with a basic orthogonal api
21:13:44 <dons> you implement it
21:13:47 <dons> you check it with QC
21:13:49 <dons> recurse
21:13:57 <jcreigh> dons: well, the unit-testing crowd is always pushing test-driven development. (ie, write the tests first)
21:14:07 <jcreigh> I was just wondering how you went about it.
21:14:13 <dons> yeah, you could happily state the properties first.
21:14:20 <dons> that TDD, but generalised a bit
21:14:56 <kb_> hm, how is that a generalization of TDD?
21:15:06 <dons> oh, properties abstract over variables in tests.
21:15:16 <dons> so you get rules that hold universially over some code
21:15:28 <dons> forall (x :: MyType) . f x = reverse (g x)
21:15:31 <jcreigh> yeah, unit testing is like "square 2 = 4" QC is like "square x = x * x"
21:15:45 <dons> which is really the more foundational aspect.
21:15:53 <kb_> ah, ok, you just mean the way the properties are as opposed to standard unit tests, gotcha
21:16:00 <dons> you get at the essence of what the code is doing, when you state tests in their most general form.
21:16:11 <dons> abstracted over particular values, to all values.
21:16:18 <kb_> yeah
21:16:32 <dons> so the interesting idea is whether this then scales up to complex software , like window managers
21:16:49 <dons> i think the xmonad experience has been that yes, even a window manager interface can have nice QC properties
21:17:00 <dons> and that having nice properties leads to an intuivitive UI.
21:17:09 <sorear> QC's only problem is that finding good equations is tricky.  you often wind up assuming properties that you don't test, or don't constrain the tests well enough to get good coverage.
21:17:20 <dons> as the result of each operation is more predictable, simply because the rules are simpler
21:17:46 <sorear> *only big problem
21:17:49 <dons> we should write up a paper on the QC approach to design some day
21:18:17 <dons> so not just as a testing mechanism, but as mechanical design assitance, an entire methodology of finding and checking the spec.
21:19:31 <kb_> dons: yeah, that would be interesting to read
21:19:45 <shapr> sorear: I think the good equations are the sort of thing you find in an RFC.
21:20:01 <shapr> Though I admit, I haven't been able to figure out how to QC HAppS' MACID code yet.
21:20:01 <dons> i always contend that if we had QC when haskell 98 was being written,   unlines . lines == id would be true
21:20:03 <sorear> shapr: Implementing rfcs is easy, QC or no.
21:20:21 <shapr> sorear: Correct implementations are much easier when you have QC.
21:20:34 <shapr> I wrote an RFC822 lib long ago, it had bugs that QC found.
21:20:48 <sorear> shapr: Writing RFCs is as hard as writing good properties - either way, harder than writing amorphous code
21:21:05 <dons> yeah, i used to trust code in perl, then i found haskell's type system, and I only trusted code with strong typing that checked, now with QC I only trust it if it also has comprehensive properties
21:21:19 <dons> finally, i'm finding i am wanting to use Catch on everything as well
21:21:24 <dons> to check for error behaviour
21:21:32 <sorear> shapr: I don't buy "Good design is inherently hard" ;)
21:21:58 <shapr> I don't either.
21:25:56 <shapr> dons: Any ideas on an elegant way to QC against an external input? For example, QC Haskell against bc or dc (command line calculators) without unsafePerformIO, unsafeSTtoIO, or unsafe anything?
21:27:32 <dons> hmm. presumably bc and dc are referentially transparent
21:27:40 <dons> so unsafePerformIO would be best
21:27:52 <dons> otherwise, you'd have to use QC2 monadic tricks
21:28:07 <shapr> Yeah, I should read those to see if they're any different from QCm
21:30:16 <shapr> Ah, Test.QuickCheck.Monadic.monadicIO uses unsafePerformIO
21:42:45 <Binkley> @quote
21:42:46 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
21:44:05 <lispy> ?quote Pseudonym
21:44:05 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
21:46:00 <lemao> Excedrin: backspace works if I use cat
21:46:49 <lemao> Excedrin: would that confirm that I have gnu readline installed?
21:47:05 <jcreigh> lemao: no
21:47:29 <lemao> jcreigh: this is what I have installed:
21:47:30 <lemao> readline-5 @5.0.005_0+darwin_8 (active)
21:48:35 <jcreigh> now, when you say backspace "does not work", what exactly does that mean?
21:49:45 <lemao> jcreigh: while using ghci 6.6 when I try to delete (backspace) characters in the prompt I get ^?
21:52:19 <jcreigh> lemao: hmm. try this: open a terminal. type "stty erase <c-v><bksp>" (that is, type "stty erase " followed by control-v, followed by your backspace key)
21:52:25 <jcreigh> lemao: then try to start ghci and see what happens
21:53:59 <lemao> same thing
21:54:29 <jfredett> Ahhh, I'm so close to solving this problem-- but infinite sets don't seem to work as well as infinite lists... :/
21:55:53 <jcreigh> lemao: ah, sorry. that's the tradition unix backspace problem, so I thought that might help, but I guess not.
21:56:32 <lemao> jcreigh: I read something about building ghc not picking up the right readline lib
21:56:58 <lemao> jcreigh: but the solutions provided didnt help
22:17:55 <thetallguy> shapr, isn't dc the stack based calculator?
22:18:57 <jcreigh> thetallguy: yeah, it uses RPN
22:21:48 <dancor> gentoo: haskell shows in   layman -L   on my comp that already has the overlay but not on the one that does not
22:22:02 <dancor> is that normal, and if so how do i install the overlay
22:22:15 <dancor> do you need to like have darcs installed to see it
22:24:37 <Korollary> try that in #gentoo-haskell ?
22:25:44 <dancor> ah yeah
22:28:22 <c_> layman -L only shows certain repos by default :/
22:29:12 <c_> maybe its changed, used to ignore ones without some metadata or smth
22:33:43 <dancor> ok nm i think i can figure it out actually
22:34:13 <xpika> in vim whats the code for the current filename?
22:34:43 <c_> :q! echo $0 maybe
22:35:48 <ari> The thing about seeing the same thing said on multiple irc channels is that it looks weird when you switch between them on a terminal irc client
22:36:32 <xpika> ok i found it. it was %.
22:44:06 <hpaste>  Weremanatee pasted "How to proceed?" at http://hpaste.org/55
22:46:38 <Weremanatee> I'm afraid I've gotten myself in too deep with this proof.
22:55:41 <dancor> well start by killing some parens and *1 :)
22:56:12 <dons> Weremanatee: and using some 'where' clauses to name subexpressions
22:57:03 <Weremanatee> alright
22:57:09 <dons> yeah, also a lisp-like overuse of ( ) :-)
22:57:14 <dons> '$' might be your friend.
22:57:35 <Weremanatee> *1, heh. Just noticed that. I was thinking of 1/sin(...) as being a unit
22:57:42 <dons> so i'd start with:
22:57:44 <dons>    areaPoly n s = abs . sum . zipwith trapezoid $ tail l ++ [head l]
22:57:51 <dons> then use where clauses to name all the subexprs
22:58:12 <jbauman> SML-like overuse of ()
22:58:20 <jbauman> SML really could use $
22:58:41 <Weremanatee> Yea, sorry about that. I'm a bit lispy.
22:59:32 <lispy> a bit lispy eh?
22:59:37 <lispy> well, that's excusable ;)
22:59:40 <bos> @djinn a -> b -> b
22:59:40 <lambdabot> f _ a = a
23:00:11 <jbauman> @pl f _ a = a
23:00:12 <lambdabot> f = const id
23:03:08 <hpaste>  dons annotated "How to proceed?" with "started refactoring" at http://hpaste.org/55#a1
23:03:17 <dons> Weremanatee: I started on naming subvars, for you, but gave up when the parens got too deep
23:03:51 <dancor> dons: it has to be: areaPoly n s = abs . sum . zipWith trapezoid (tail l ++ [head l]) l where
23:03:54 <dancor> need the l
23:04:00 <dons> ah yes
23:10:32 <Weremanatee> dons: hah
23:10:44 <Weremanatee> Do my work for me!
23:12:51 <hpaste>  Weremanatee annotated "How to proceed?" with "Refactored a bit" at http://hpaste.org/55#a2
23:14:53 <Weremanatee> one too many parens in firstVertex
23:17:25 <Weremanatee> no, one too few :o)
23:17:39 <dons> have you worked out how to use $ ?
23:18:00 <dancor> dons: yeah it's in his latest
23:18:07 <dancor> oh
23:18:08 <dancor> no
23:19:40 <hpaste>  Weremanatee annotated "How to proceed?" with "simplified" at http://hpaste.org/55#a3
23:20:34 <hpaste>  matrix pasted "(no title)" at http://hpaste.org/56
23:20:49 <Weremanatee> The $ is totally redundant now. :-)
23:24:30 <jbauman> you've checked that they are equivalent, I assume
23:25:57 <roconnor> data List' a = A [a] | B List' a
23:25:57 <Weremanatee> they return very similar results
23:26:12 <roconnor> is that datatype isomorphic to ([a],[a])?
23:30:06 <hpaste>  Weremanatee annotated "How to proceed?" with "removed ++" at http://hpaste.org/55#a4
23:44:23 <hpaste>  Weremanatee annotated "How to proceed?" with "as good as it will get" at http://hpaste.org/55#a5
23:45:17 <Weremanatee> At least it's easier to read now.
23:45:24 <Weremanatee> Must sleep...
23:45:55 <Weremanatee> Thanks for your help.
